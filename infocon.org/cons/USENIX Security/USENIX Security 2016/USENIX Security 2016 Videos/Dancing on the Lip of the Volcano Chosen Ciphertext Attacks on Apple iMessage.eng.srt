1
00:00:10,639 --> 00:00:13,599
hi so this is a talk on a new type of

2
00:00:13,599 --> 00:00:15,599
chosen ciphertext attack we developed in

3
00:00:15,599 --> 00:00:17,920
order to exploit a vulnerability we

4
00:00:17,920 --> 00:00:21,279
found in apple's imessage protocol

5
00:00:21,279 --> 00:00:23,760
imessage is of course uh apple's intane

6
00:00:23,760 --> 00:00:26,000
encrypted messaging protocol it was

7
00:00:26,000 --> 00:00:28,240
first developed in 2011

8
00:00:28,240 --> 00:00:30,160
it is now deployed on about a billion

9
00:00:30,160 --> 00:00:32,640
devices um handles a peak of about 200

10
00:00:32,640 --> 00:00:34,320
000 messages a second

11
00:00:34,320 --> 00:00:37,520
um and it was really sort of the first

12
00:00:37,520 --> 00:00:40,000
large scaly deployed uh end-to-end

13
00:00:40,000 --> 00:00:41,520
encrypted messaging protocol prior to

14
00:00:41,520 --> 00:00:43,360
this most messaging was sent in fact

15
00:00:43,360 --> 00:00:44,640
over sms which of course has no

16
00:00:44,640 --> 00:00:47,200
encryption whatsoever um

17
00:00:47,200 --> 00:00:48,480
and

18
00:00:48,480 --> 00:00:49,840
it's sort of interesting that we kind of

19
00:00:49,840 --> 00:00:50,800
think of

20
00:00:50,800 --> 00:00:52,719
messaging as not being that important of

21
00:00:52,719 --> 00:00:54,160
course these kind of things are actually

22
00:00:54,160 --> 00:00:56,879
relied on by by activists and oppressive

23
00:00:56,879 --> 00:00:58,879
government regimes and stuff to to sort

24
00:00:58,879 --> 00:01:00,719
of protect themselves and sort of from a

25
00:01:00,719 --> 00:01:02,320
technical standpoint it's interesting

26
00:01:02,320 --> 00:01:03,920
because it turns out that imessage the

27
00:01:03,920 --> 00:01:06,640
encryption protocol isn't actually just

28
00:01:06,640 --> 00:01:08,799
used for messaging turns out that apple

29
00:01:08,799 --> 00:01:11,840
uses it uh in handoff which syncs the

30
00:01:11,840 --> 00:01:13,840
state on your browser from your desktop

31
00:01:13,840 --> 00:01:16,240
uh to your phone um you could see why

32
00:01:16,240 --> 00:01:17,680
you might want indian encryption there

33
00:01:17,680 --> 00:01:20,240
and then apple uses it in uh one other

34
00:01:20,240 --> 00:01:22,240
undisclosed product that they mentioned

35
00:01:22,240 --> 00:01:23,520
existed when you were discussing

36
00:01:23,520 --> 00:01:24,880
mitigations with them when we disclosed

37
00:01:24,880 --> 00:01:26,960
the attack but they wouldn't actually

38
00:01:26,960 --> 00:01:28,960
tell us uh what it was

39
00:01:28,960 --> 00:01:29,840
um

40
00:01:29,840 --> 00:01:31,280
i'd like to think that it was the apple

41
00:01:31,280 --> 00:01:32,720
car but realistically there's probably

42
00:01:32,720 --> 00:01:34,640
something involving the iwatch i don't

43
00:01:34,640 --> 00:01:36,799
actually know so what do we mean when we

44
00:01:36,799 --> 00:01:38,560
say indian encrypted right well if

45
00:01:38,560 --> 00:01:40,159
you're sending a message from one device

46
00:01:40,159 --> 00:01:41,920
to another over a network or using a

47
00:01:41,920 --> 00:01:44,079
server right you can basically have

48
00:01:44,079 --> 00:01:45,520
three options of how you can send it you

49
00:01:45,520 --> 00:01:47,040
can use no encryption in which case your

50
00:01:47,040 --> 00:01:49,040
message is sort of exposed

51
00:01:49,040 --> 00:01:50,560
you can do what i think we'd all come to

52
00:01:50,560 --> 00:01:52,560
expect uh you can do transport

53
00:01:52,560 --> 00:01:54,000
encryption where the link from the

54
00:01:54,000 --> 00:01:55,439
client to the server and from the server

55
00:01:55,439 --> 00:01:56,960
to the recipient is encrypted but the

56
00:01:56,960 --> 00:01:59,280
message itself is not so it's exposed on

57
00:01:59,280 --> 00:02:01,119
the server and then and these are not

58
00:02:01,119 --> 00:02:03,119
mutually exclusive you can do end-to-end

59
00:02:03,119 --> 00:02:05,200
encryption where you encrypt the message

60
00:02:05,200 --> 00:02:06,719
on the device

61
00:02:06,719 --> 00:02:08,878
and it is not decrypted by anyone it

62
00:02:08,878 --> 00:02:10,560
cannot be decrypted by anyone until you

63
00:02:10,560 --> 00:02:12,000
get to the recipient right and this is

64
00:02:12,000 --> 00:02:13,599
sort of the gold standard this is what

65
00:02:13,599 --> 00:02:15,680
imessage sought out to do this is what

66
00:02:15,680 --> 00:02:17,360
signal and whatsapp do this is even what

67
00:02:17,360 --> 00:02:19,599
facebook messenger now has a uh

68
00:02:19,599 --> 00:02:21,760
deployed version of doing for only on

69
00:02:21,760 --> 00:02:23,200
phones um

70
00:02:23,200 --> 00:02:25,360
and what we developed in in this case

71
00:02:25,360 --> 00:02:27,200
was an attack that for some types of

72
00:02:27,200 --> 00:02:29,440
imessages reduces the security from the

73
00:02:29,440 --> 00:02:30,879
setting where you have indian encryption

74
00:02:30,879 --> 00:02:32,640
over here to the setting where you only

75
00:02:32,640 --> 00:02:35,360
have transport encryption right because

76
00:02:35,360 --> 00:02:37,440
uh at that point then the message is

77
00:02:37,440 --> 00:02:39,440
only protected to the extent that you

78
00:02:39,440 --> 00:02:41,680
can't break the links on the encryption

79
00:02:41,680 --> 00:02:44,000
uh or that you can't get into the server

80
00:02:44,000 --> 00:02:45,920
and this may not seem that significant

81
00:02:45,920 --> 00:02:47,040
you may think that that's a fairly

82
00:02:47,040 --> 00:02:49,200
secure scenario i think a couple of the

83
00:02:49,200 --> 00:02:50,480
other authors in the session might

84
00:02:50,480 --> 00:02:52,319
disagree with you about trusting tls at

85
00:02:52,319 --> 00:02:56,160
least as is um but uh okay that maybe

86
00:02:56,160 --> 00:02:57,440
that's not that big of a threat in your

87
00:02:57,440 --> 00:02:59,040
head and you're probably thinking the

88
00:02:59,040 --> 00:03:01,120
server here is probably pretty secure

89
00:03:01,120 --> 00:03:03,440
it's like 102 devices it boxes it's not

90
00:03:03,440 --> 00:03:04,879
going to be that easy to get into and no

91
00:03:04,879 --> 00:03:07,120
one would care but for a cloud-based

92
00:03:07,120 --> 00:03:08,640
service that's handling you know

93
00:03:08,640 --> 00:03:10,239
hundreds of thousands of messages of a

94
00:03:10,239 --> 00:03:12,400
second across a large geographically

95
00:03:12,400 --> 00:03:14,239
diverse area

96
00:03:14,239 --> 00:03:15,840
this schematic is really inaccurate

97
00:03:15,840 --> 00:03:18,400
because that little box there is

98
00:03:18,400 --> 00:03:20,400
actually um

99
00:03:20,400 --> 00:03:22,400
something far more complicated right you

100
00:03:22,400 --> 00:03:24,000
might expect you know to involve

101
00:03:24,000 --> 00:03:26,000
multiple servers or even multiple data

102
00:03:26,000 --> 00:03:28,480
centers and you might maybe you should

103
00:03:28,480 --> 00:03:30,400
be a little skeptical about your ability

104
00:03:30,400 --> 00:03:31,840
to secure something like this just off

105
00:03:31,840 --> 00:03:32,799
the bat because there are a lot of

106
00:03:32,799 --> 00:03:34,319
things that can go wrong

107
00:03:34,319 --> 00:03:36,080
um and for those of you who recognize

108
00:03:36,080 --> 00:03:38,400
where this slide is actually taken from

109
00:03:38,400 --> 00:03:40,159
you should be incredibly skeptical of

110
00:03:40,159 --> 00:03:41,440
your ability to secure this if you're

111
00:03:41,440 --> 00:03:42,879
the kind of thing that nation states are

112
00:03:42,879 --> 00:03:44,799
interested in because they have very

113
00:03:44,799 --> 00:03:46,640
well resourced very smart motivated

114
00:03:46,640 --> 00:03:47,920
attackers who will go look at your

115
00:03:47,920 --> 00:03:49,840
architecture and gleefully point out

116
00:03:49,840 --> 00:03:51,360
that in fact you have no encryption in

117
00:03:51,360 --> 00:03:53,040
one particular step and they can read

118
00:03:53,040 --> 00:03:54,640
all of your messages in this case this

119
00:03:54,640 --> 00:03:56,000
diagram is actually taken from something

120
00:03:56,000 --> 00:03:59,120
against google for gmail but uh

121
00:03:59,120 --> 00:04:00,400
funnily enough gmail doesn't have any

122
00:04:00,400 --> 00:04:01,599
encryption but nonetheless these kind of

123
00:04:01,599 --> 00:04:03,040
attacks apply you can imagine someone

124
00:04:03,040 --> 00:04:04,080
doing the same kind of thing to an

125
00:04:04,080 --> 00:04:05,599
ending encrypted message

126
00:04:05,599 --> 00:04:07,200
encrypted messaging system right so this

127
00:04:07,200 --> 00:04:09,040
is why you want in-demand encryption

128
00:04:09,040 --> 00:04:10,720
right it really is important right so

129
00:04:10,720 --> 00:04:13,680
how does imessage get this um imessage

130
00:04:13,680 --> 00:04:15,760
is really the simplest protocol you

131
00:04:15,760 --> 00:04:17,680
could probably think of there's no crazy

132
00:04:17,680 --> 00:04:19,199
properties for forward security as an

133
00:04:19,199 --> 00:04:22,960
otr there's no overly complex uh

134
00:04:22,960 --> 00:04:25,040
you know trippy triple or quadruple or

135
00:04:25,040 --> 00:04:26,479
sex tuple jiffy helmet handshake

136
00:04:26,479 --> 00:04:28,000
whatever it is that signal slash

137
00:04:28,000 --> 00:04:30,240
octolodon was up to these days

138
00:04:30,240 --> 00:04:32,400
there is simply just a directory server

139
00:04:32,400 --> 00:04:34,320
that distributes public keys and then

140
00:04:34,320 --> 00:04:35,600
you encrypt your message under the

141
00:04:35,600 --> 00:04:37,600
recipient's public key and you send it

142
00:04:37,600 --> 00:04:41,520
via apple's push notification network

143
00:04:41,520 --> 00:04:43,600
and the question of course is is this

144
00:04:43,600 --> 00:04:45,199
secure right there's some questions

145
00:04:45,199 --> 00:04:47,280
about you know how apple distributes uh

146
00:04:47,280 --> 00:04:49,120
keys and does device registration and we

147
00:04:49,120 --> 00:04:50,560
examined uh

148
00:04:50,560 --> 00:04:52,080
that found some

149
00:04:52,080 --> 00:04:53,199
floss and other people were discovered

150
00:04:53,199 --> 00:04:54,080
and confirmed they're still there and

151
00:04:54,080 --> 00:04:55,360
found a couple of other other ones but

152
00:04:55,360 --> 00:04:56,720
the main question is you know what is

153
00:04:56,720 --> 00:04:58,080
this encryption and is it actually

154
00:04:58,080 --> 00:05:01,199
secure right and so interestingly this

155
00:05:01,199 --> 00:05:03,360
is actually documented apple did in an

156
00:05:03,360 --> 00:05:04,880
irs security white paper they published

157
00:05:04,880 --> 00:05:06,800
a while ago give you a very short like

158
00:05:06,800 --> 00:05:08,080
paragraph description of what their

159
00:05:08,080 --> 00:05:10,800
encryption format is and that format is

160
00:05:10,800 --> 00:05:13,199
very simple uh an i encrypted imessage

161
00:05:13,199 --> 00:05:15,600
consists of an rsa ciphertext encrypted

162
00:05:15,600 --> 00:05:17,360
under the recipient's public key

163
00:05:17,360 --> 00:05:20,000
the ciphertext is uh 1288 bits so you

164
00:05:20,000 --> 00:05:22,080
can't fit a full message in there so

165
00:05:22,080 --> 00:05:23,120
they don't

166
00:05:23,120 --> 00:05:25,360
they uh just encrypt a symmetric key and

167
00:05:25,360 --> 00:05:27,520
then they encrypt the actual message

168
00:05:27,520 --> 00:05:29,520
using aes under that symmetric key with

169
00:05:29,520 --> 00:05:31,440
aes encounter mode and then for good

170
00:05:31,440 --> 00:05:34,160
measure they signed it with the cinders

171
00:05:34,160 --> 00:05:36,240
public key right with an ecdsa signature

172
00:05:36,240 --> 00:05:38,160
so you know who it came from and so the

173
00:05:38,160 --> 00:05:39,840
interesting thing is from this one

174
00:05:39,840 --> 00:05:41,759
paragraph description you can actually

175
00:05:41,759 --> 00:05:43,039
conclude that there are several things

176
00:05:43,039 --> 00:05:44,080
wrong and the protocol is in fact

177
00:05:44,080 --> 00:05:46,000
cryptographically broken right this is

178
00:05:46,000 --> 00:05:47,600
all you actually need to see to know

179
00:05:47,600 --> 00:05:48,639
that right

180
00:05:48,639 --> 00:05:50,720
and so what what's the what's the catch

181
00:05:50,720 --> 00:05:53,199
what's wrong well first of all you may

182
00:05:53,199 --> 00:05:55,120
remember that you you ought to be using

183
00:05:55,120 --> 00:05:56,639
authenticated encryption these days

184
00:05:56,639 --> 00:05:58,880
right and that maybe that means you use

185
00:05:58,880 --> 00:06:01,600
uh as in gcm mode maybe you use ocb

186
00:06:01,600 --> 00:06:04,000
maybe you just use an hmac but this is

187
00:06:04,000 --> 00:06:05,840
not this is as encounter mode right so

188
00:06:05,840 --> 00:06:07,199
it's not an authenticated cyber suit

189
00:06:07,199 --> 00:06:09,120
itself um and i'm not hiding anything in

190
00:06:09,120 --> 00:06:11,039
the schematic queue there is no hmac in

191
00:06:11,039 --> 00:06:12,800
here anywhere right

192
00:06:12,800 --> 00:06:15,120
and some of you may be thinking well but

193
00:06:15,120 --> 00:06:16,319
there is a signature right and i

194
00:06:16,319 --> 00:06:17,520
actually suspect maybe one of the

195
00:06:17,520 --> 00:06:19,440
engineers at apple was thinking this too

196
00:06:19,440 --> 00:06:21,360
uh and that's that's authenticated right

197
00:06:21,360 --> 00:06:22,720
we're signing the thing we know who it

198
00:06:22,720 --> 00:06:24,400
came from that's that's authentication

199
00:06:24,400 --> 00:06:26,080
in the standard definition right and

200
00:06:26,080 --> 00:06:28,160
indeed in most uses you might be able to

201
00:06:28,160 --> 00:06:30,560
think that uh but it turns out that

202
00:06:30,560 --> 00:06:31,600
remember how i said there were two

203
00:06:31,600 --> 00:06:33,520
things wrong here well

204
00:06:33,520 --> 00:06:34,479
uh

205
00:06:34,479 --> 00:06:35,840
the sort of the second one is that

206
00:06:35,840 --> 00:06:37,360
there's an identity misbinding attack

207
00:06:37,360 --> 00:06:38,720
which means that if alice is sending a

208
00:06:38,720 --> 00:06:41,039
message to bob and i grab it i can strip

209
00:06:41,039 --> 00:06:42,479
off alice's name from the envelope

210
00:06:42,479 --> 00:06:44,319
information strip off her signature put

211
00:06:44,319 --> 00:06:45,919
my name and my signature on it and then

212
00:06:45,919 --> 00:06:47,840
send it to bob and bob will think it's a

213
00:06:47,840 --> 00:06:49,280
message from me

214
00:06:49,280 --> 00:06:51,440
and this seems sort of like a pedantic

215
00:06:51,440 --> 00:06:54,080
objection it is a type of flaw in in in

216
00:06:54,080 --> 00:06:56,160
protocols right uh but it's not really

217
00:06:56,160 --> 00:06:57,280
clear what this would do to the

218
00:06:57,280 --> 00:06:58,960
confidentiality of the protocol right

219
00:06:58,960 --> 00:07:00,240
because that's not there's no way you

220
00:07:00,240 --> 00:07:01,199
should be able to use it to actually

221
00:07:01,199 --> 00:07:02,800
read what's in that message you've just

222
00:07:02,800 --> 00:07:04,080
managed to send it to the bob and made

223
00:07:04,080 --> 00:07:05,919
him think it came from someone else

224
00:07:05,919 --> 00:07:07,039
but

225
00:07:07,039 --> 00:07:08,479
the thing is that if i do this attack

226
00:07:08,479 --> 00:07:10,479
i'm not limited to just replaying the

227
00:07:10,479 --> 00:07:12,000
exact message i got because once you've

228
00:07:12,000 --> 00:07:13,599
stripped off the signature

229
00:07:13,599 --> 00:07:14,800
i can do whatever i want the cipher

230
00:07:14,800 --> 00:07:16,400
ciphertext and then sign it as if it

231
00:07:16,400 --> 00:07:17,520
came by me

232
00:07:17,520 --> 00:07:19,360
and so this means the ciphertext is

233
00:07:19,360 --> 00:07:20,639
malleable

234
00:07:20,639 --> 00:07:22,639
and this should actually worry you

235
00:07:22,639 --> 00:07:24,800
because if you remember um if you've

236
00:07:24,800 --> 00:07:26,080
taken a cryptographic class there is

237
00:07:26,080 --> 00:07:28,479
this very complicated definition of

238
00:07:28,479 --> 00:07:29,919
indistinguishability under adaptive

239
00:07:29,919 --> 00:07:31,360
chosen ciphertext attack which is sort

240
00:07:31,360 --> 00:07:33,039
of the you know the basic gold standard

241
00:07:33,039 --> 00:07:34,000
for what you want for a secure

242
00:07:34,000 --> 00:07:36,560
encryption scheme um and it basically

243
00:07:36,560 --> 00:07:38,639
says that if you have malleable

244
00:07:38,639 --> 00:07:39,919
ciphertext

245
00:07:39,919 --> 00:07:42,960
you can't meet this definition um

246
00:07:42,960 --> 00:07:44,639
and

247
00:07:44,639 --> 00:07:46,639
great so now we know that imessage is is

248
00:07:46,639 --> 00:07:48,720
technically textbook broken based on

249
00:07:48,720 --> 00:07:50,319
merely the nice paragraph description

250
00:07:50,319 --> 00:07:52,400
they gave us but it's not really clear

251
00:07:52,400 --> 00:07:54,400
how you were going to exploit this

252
00:07:54,400 --> 00:07:56,960
because this this game involves a

253
00:07:56,960 --> 00:07:58,560
attacker who has oracle access to be

254
00:07:58,560 --> 00:08:00,639
able to decrypt any ciphertext they want

255
00:08:00,639 --> 00:08:02,879
to just literally ask for the decryption

256
00:08:02,879 --> 00:08:04,160
provided it's not the one they are

257
00:08:04,160 --> 00:08:06,240
challenged on and the natural reaction

258
00:08:06,240 --> 00:08:07,199
to those of you on the you know the

259
00:08:07,199 --> 00:08:08,800
system side of this or anything is well

260
00:08:08,800 --> 00:08:10,160
that's unrealistic no one would ever

261
00:08:10,160 --> 00:08:11,680
build such a system and if you did you

262
00:08:11,680 --> 00:08:15,039
deserve to get owned um

263
00:08:15,039 --> 00:08:16,879
well okay so how do we how do we go

264
00:08:16,879 --> 00:08:18,639
about translating this into practice so

265
00:08:18,639 --> 00:08:19,919
consider something that's maybe a little

266
00:08:19,919 --> 00:08:21,520
more plausible suppose instead of having

267
00:08:21,520 --> 00:08:24,080
an api that said uh you know hey what's

268
00:08:24,080 --> 00:08:25,680
the decryption of this message we had an

269
00:08:25,680 --> 00:08:28,240
api that said hey is this message valid

270
00:08:28,240 --> 00:08:29,840
is it the right link is it encoded

271
00:08:29,840 --> 00:08:32,000
properly etc

272
00:08:32,000 --> 00:08:33,120
and

273
00:08:33,120 --> 00:08:34,799
this still might seem a little

274
00:08:34,799 --> 00:08:36,080
unrealistic because again why would you

275
00:08:36,080 --> 00:08:37,760
add that api

276
00:08:37,760 --> 00:08:39,679
but it turns out in fact that this

277
00:08:39,679 --> 00:08:41,039
actually does happen just sort of

278
00:08:41,039 --> 00:08:42,719
indirectly right this is an example of

279
00:08:42,719 --> 00:08:44,480
an actual stack trace someone posted to

280
00:08:44,480 --> 00:08:46,080
stack overflow going hey why am i

281
00:08:46,080 --> 00:08:48,160
getting this and it turns out right that

282
00:08:48,160 --> 00:08:50,160
this is an example of a padding oracle

283
00:08:50,160 --> 00:08:51,360
attack this

284
00:08:51,360 --> 00:08:53,120
system is probably encrypting a cookie

285
00:08:53,120 --> 00:08:54,800
is vulnerable to exactly this type of

286
00:08:54,800 --> 00:08:56,160
thing it's called a

287
00:08:56,160 --> 00:08:59,040
format oracle attack um and

288
00:08:59,040 --> 00:09:00,399
it turns out that you don't directly

289
00:09:00,399 --> 00:09:02,000
have to have an api that exposes this

290
00:09:02,000 --> 00:09:03,440
right this is the server wasn't very

291
00:09:03,440 --> 00:09:04,959
well configured it's reporting stack

292
00:09:04,959 --> 00:09:07,360
traces and such but you can infer that

293
00:09:07,360 --> 00:09:08,640
there was an error maybe by a side

294
00:09:08,640 --> 00:09:10,399
channel by a violent timing or by the

295
00:09:10,399 --> 00:09:11,760
fact that the server didn't do the next

296
00:09:11,760 --> 00:09:13,040
step that it was supposed to in the

297
00:09:13,040 --> 00:09:14,640
process like say you know supposed to

298
00:09:14,640 --> 00:09:16,399
email you after you submitted something

299
00:09:16,399 --> 00:09:17,920
um and so this attack is actually

300
00:09:17,920 --> 00:09:19,600
practical and it's used quite a good

301
00:09:19,600 --> 00:09:20,839
degree of effect

302
00:09:20,839 --> 00:09:24,000
um and so seemingly we have some good

303
00:09:24,000 --> 00:09:25,200
news here right we can come up with an

304
00:09:25,200 --> 00:09:27,920
actual exploit except for the fact that

305
00:09:27,920 --> 00:09:30,160
uh

306
00:09:30,160 --> 00:09:32,560
there's no panic right this is aes

307
00:09:32,560 --> 00:09:34,080
encounter mode right as encounter mode

308
00:09:34,080 --> 00:09:35,519
is a stream cipher you generate a bunch

309
00:09:35,519 --> 00:09:37,839
of random bits using aes and you xor

310
00:09:37,839 --> 00:09:39,600
them with your message right and this is

311
00:09:39,600 --> 00:09:40,959
very good for us from the point of view

312
00:09:40,959 --> 00:09:42,080
of doing malleability because if you

313
00:09:42,080 --> 00:09:44,640
want to flip an arbitrary bit in the

314
00:09:44,640 --> 00:09:46,000
plain text that's being decrypted you

315
00:09:46,000 --> 00:09:48,080
just flip the corresponding bit in the

316
00:09:48,080 --> 00:09:49,600
ciphertext right you don't know what the

317
00:09:49,600 --> 00:09:51,040
value of it was but you know you flipped

318
00:09:51,040 --> 00:09:51,760
it

319
00:09:51,760 --> 00:09:53,920
but this also means there's no padding

320
00:09:53,920 --> 00:09:55,760
right so we can't mount a padding oracle

321
00:09:55,760 --> 00:09:57,920
attack right we also can't mount out of

322
00:09:57,920 --> 00:09:59,279
the other variants of this that people

323
00:09:59,279 --> 00:10:00,480
have developed there was an xml one

324
00:10:00,480 --> 00:10:02,399
there's a font encoding one um none of

325
00:10:02,399 --> 00:10:04,640
these really work directly here

326
00:10:04,640 --> 00:10:05,519
so

327
00:10:05,519 --> 00:10:08,160
it's not exactly clear

328
00:10:08,160 --> 00:10:10,079
what we should be doing right um and in

329
00:10:10,079 --> 00:10:12,160
fact in order to actually exploit this

330
00:10:12,160 --> 00:10:13,839
in order to get a proof of concept we're

331
00:10:13,839 --> 00:10:15,680
going to have to develop a new type of

332
00:10:15,680 --> 00:10:18,079
uh format oracle attack right and

333
00:10:18,079 --> 00:10:19,920
unfortunately this is where we leave the

334
00:10:19,920 --> 00:10:21,440
the realm of what apple nicely

335
00:10:21,440 --> 00:10:23,760
documented for us because we need to do

336
00:10:23,760 --> 00:10:25,680
two things to get a format oracle right

337
00:10:25,680 --> 00:10:27,839
we need to figure out some format that

338
00:10:27,839 --> 00:10:29,200
we can exploit and how to flip it to

339
00:10:29,200 --> 00:10:30,480
actually get errors that tell us what

340
00:10:30,480 --> 00:10:31,600
the ciphertext the contents of the

341
00:10:31,600 --> 00:10:33,600
ciphertext are and then the second thing

342
00:10:33,600 --> 00:10:35,120
is we need to actually be able to do

343
00:10:35,120 --> 00:10:36,800
that remotely which means we need to see

344
00:10:36,800 --> 00:10:39,279
the errors somehow right

345
00:10:39,279 --> 00:10:41,600
and this sort of begs the question what

346
00:10:41,600 --> 00:10:43,680
is in this box right what is the actual

347
00:10:43,680 --> 00:10:44,640
format

348
00:10:44,640 --> 00:10:46,959
and so this isn't documented right there

349
00:10:46,959 --> 00:10:48,560
was a a sort of partial reverse

350
00:10:48,560 --> 00:10:50,640
engineering done by quarks labs a while

351
00:10:50,640 --> 00:10:52,480
ago they also found some some issues

352
00:10:52,480 --> 00:10:53,760
with how uh

353
00:10:53,760 --> 00:10:56,160
keys are distributed um but

354
00:10:56,160 --> 00:10:57,600
we basically had to finish this off

355
00:10:57,600 --> 00:10:59,200
right you have to go stare at the raw

356
00:10:59,200 --> 00:11:00,560
messages and like write a bunch of

357
00:11:00,560 --> 00:11:02,240
python code to parse them and figure out

358
00:11:02,240 --> 00:11:03,760
what's going on and if you do that and

359
00:11:03,760 --> 00:11:05,839
it's a painful process you recover

360
00:11:05,839 --> 00:11:07,360
basically this diagram and this is a

361
00:11:07,360 --> 00:11:10,240
fairly complicated format actually right

362
00:11:10,240 --> 00:11:12,959
it's at high level it's a gzip binary p

363
00:11:12,959 --> 00:11:14,640
list binary p list being this uh

364
00:11:14,640 --> 00:11:16,959
proprietary sort of format apple uses

365
00:11:16,959 --> 00:11:19,360
for for for serializing data

366
00:11:19,360 --> 00:11:20,880
and it's kind of interesting because

367
00:11:20,880 --> 00:11:22,640
they went to a lot of trouble to save

368
00:11:22,640 --> 00:11:24,160
space in this right because the push

369
00:11:24,160 --> 00:11:25,519
notification network didn't want to deal

370
00:11:25,519 --> 00:11:27,440
with large messages so they compressed

371
00:11:27,440 --> 00:11:29,920
the thing and they actually stuffed part

372
00:11:29,920 --> 00:11:32,079
of the message uh into the rsa

373
00:11:32,079 --> 00:11:33,519
ciphertext right because i said it was

374
00:11:33,519 --> 00:11:36,480
1288 bits you're only putting a 256-bit

375
00:11:36,480 --> 00:11:37,760
aes key in there so you have some

376
00:11:37,760 --> 00:11:39,839
leftover space so that space actually

377
00:11:39,839 --> 00:11:42,320
has part of the message genuine um and

378
00:11:42,320 --> 00:11:43,680
the rsa subjects by the way is actually

379
00:11:43,680 --> 00:11:46,399
correctly done it's rsa or aap and you

380
00:11:46,399 --> 00:11:49,680
you can't uh mess with them um

381
00:11:49,680 --> 00:11:51,200
and so this is just sort of interesting

382
00:11:51,200 --> 00:11:52,480
looking at it it's not quite clear what

383
00:11:52,480 --> 00:11:53,920
we can use for format oracle but if you

384
00:11:53,920 --> 00:11:55,440
start looking you notice that this might

385
00:11:55,440 --> 00:11:57,920
be we might have a few snags

386
00:11:57,920 --> 00:11:59,519
uh the first one is that there's the

387
00:11:59,519 --> 00:12:02,000
sender id in here and remember this is

388
00:12:02,000 --> 00:12:03,440
the cipher text i'm showing you this is

389
00:12:03,440 --> 00:12:04,720
not the full message format with the

390
00:12:04,720 --> 00:12:05,920
envelope information which of course has

391
00:12:05,920 --> 00:12:07,760
the sender the receiver the date and

392
00:12:07,760 --> 00:12:09,120
some routing information on it this is

393
00:12:09,120 --> 00:12:11,279
just the encrypted point part of it and

394
00:12:11,279 --> 00:12:13,440
that itself includes who's sending the

395
00:12:13,440 --> 00:12:15,200
message which doesn't make much sense

396
00:12:15,200 --> 00:12:16,560
because you can't read that until you've

397
00:12:16,560 --> 00:12:17,839
decrypted it and after that you've

398
00:12:17,839 --> 00:12:19,200
already had to validate the signature to

399
00:12:19,200 --> 00:12:20,240
do this so you don't need this

400
00:12:20,240 --> 00:12:22,000
information here in here and apple

401
00:12:22,000 --> 00:12:23,519
actually is trying to save space so why

402
00:12:23,519 --> 00:12:24,560
are they

403
00:12:24,560 --> 00:12:26,720
they wasting these bits

404
00:12:26,720 --> 00:12:28,800
uh and it turns out right the worry

405
00:12:28,800 --> 00:12:30,480
about this might is well placed because

406
00:12:30,480 --> 00:12:32,240
it because if you mount the identity

407
00:12:32,240 --> 00:12:33,839
miss binding attack i just articulated

408
00:12:33,839 --> 00:12:34,800
earlier

409
00:12:34,800 --> 00:12:36,320
um

410
00:12:36,320 --> 00:12:38,240
the system will reject the message

411
00:12:38,240 --> 00:12:39,360
because the

412
00:12:39,360 --> 00:12:40,959
uh id on the outside of the envelope

413
00:12:40,959 --> 00:12:43,279
that i replaced with my signature on it

414
00:12:43,279 --> 00:12:44,959
won't match the id on the inside that's

415
00:12:44,959 --> 00:12:46,560
encrypted because i haven't changed that

416
00:12:46,560 --> 00:12:48,240
and so apple rejects the message and

417
00:12:48,240 --> 00:12:49,600
this i think is because some clever

418
00:12:49,600 --> 00:12:50,800
engineer realized that there was

419
00:12:50,800 --> 00:12:52,079
anything hiddenly misbinding attack and

420
00:12:52,079 --> 00:12:54,079
added a counter measure

421
00:12:54,079 --> 00:12:56,720
well that's really unfortunate

422
00:12:56,720 --> 00:12:58,000
except for one point they weren't quite

423
00:12:58,000 --> 00:12:59,680
clever enough because remember the

424
00:12:59,680 --> 00:13:01,600
problem about ciphertext variability

425
00:13:01,600 --> 00:13:03,440
this is in the cipher text it's not in

426
00:13:03,440 --> 00:13:05,200
the oap part of it if the message is

427
00:13:05,200 --> 00:13:06,959
long enough and so we can just flip the

428
00:13:06,959 --> 00:13:08,480
bits in it right we know what it is we

429
00:13:08,480 --> 00:13:09,760
know the value and so we can actually

430
00:13:09,760 --> 00:13:11,600
flip it to be my id instead of the

431
00:13:11,600 --> 00:13:13,680
attackers instead of the the centers

432
00:13:13,680 --> 00:13:15,519
rather and

433
00:13:15,519 --> 00:13:16,720
then this countermeasure amounts to

434
00:13:16,720 --> 00:13:18,240
nothing right because it will it will

435
00:13:18,240 --> 00:13:19,680
correctly have the information on both

436
00:13:19,680 --> 00:13:21,839
sides of the message and it'll validate

437
00:13:21,839 --> 00:13:23,519
so this is just an annoying speed bump

438
00:13:23,519 --> 00:13:26,639
but it's interesting nonetheless um okay

439
00:13:26,639 --> 00:13:28,160
so we still need a format oracle right

440
00:13:28,160 --> 00:13:29,680
we could mess with the actual binary

441
00:13:29,680 --> 00:13:30,639
plist

442
00:13:30,639 --> 00:13:32,959
but that's compressed so

443
00:13:32,959 --> 00:13:34,160
maybe it's better that we target the

444
00:13:34,160 --> 00:13:35,839
compression itself um because that's you

445
00:13:35,839 --> 00:13:39,040
know the next layer of the onion um

446
00:13:39,040 --> 00:13:40,880
and if you start doing that well

447
00:13:40,880 --> 00:13:42,560
what is the compression format it's gzip

448
00:13:42,560 --> 00:13:43,839
gzip for those of you don't know is

449
00:13:43,839 --> 00:13:45,600
basically a header

450
00:13:45,600 --> 00:13:47,440
a compressed data data stream that's

451
00:13:47,440 --> 00:13:48,639
compressed with deflate which is the

452
00:13:48,639 --> 00:13:50,079
actual compression algorithm and then a

453
00:13:50,079 --> 00:13:52,639
coc32 over the decompressed data and of

454
00:13:52,639 --> 00:13:54,160
course when you get the message you're

455
00:13:54,160 --> 00:13:56,079
going to decompress the data compute

456
00:13:56,079 --> 00:13:58,160
your own crc32 and then check that it

457
00:13:58,160 --> 00:14:00,480
aligns with the uh the one that was set

458
00:14:00,480 --> 00:14:01,600
with the message right this is just how

459
00:14:01,600 --> 00:14:02,880
gzip works in general this is nothing

460
00:14:02,880 --> 00:14:04,480
special about imessage

461
00:14:04,480 --> 00:14:05,920
and

462
00:14:05,920 --> 00:14:07,440
this is problematic right because we

463
00:14:07,440 --> 00:14:08,800
need to flip bits in here and that's

464
00:14:08,800 --> 00:14:09,760
obviously going to change what the

465
00:14:09,760 --> 00:14:11,279
decompressed version is and the crc is

466
00:14:11,279 --> 00:14:13,519
not going to align so again another

467
00:14:13,519 --> 00:14:14,800
speed bump

468
00:14:14,800 --> 00:14:15,920
and if this was a cryptographically

469
00:14:15,920 --> 00:14:18,240
secure hash we'd be in deep trouble i

470
00:14:18,240 --> 00:14:19,199
probably wouldn't actually be able to

471
00:14:19,199 --> 00:14:20,160
give this talk because we wouldn't have

472
00:14:20,160 --> 00:14:21,360
an exploit we just have an interesting

473
00:14:21,360 --> 00:14:22,639
observation of apple didn't quite do

474
00:14:22,639 --> 00:14:23,839
things correctly

475
00:14:23,839 --> 00:14:26,800
uh luckily for us unluckily for apple uh

476
00:14:26,800 --> 00:14:28,800
coc32s are actually cc and general are

477
00:14:28,800 --> 00:14:30,320
quite malleable right it turns out that

478
00:14:30,320 --> 00:14:33,360
c or c of a xor with c r c or b of b is

479
00:14:33,360 --> 00:14:35,519
equal to the c o c of message a x over

480
00:14:35,519 --> 00:14:36,800
the message b

481
00:14:36,800 --> 00:14:38,000
right technically this is slightly

482
00:14:38,000 --> 00:14:38,800
different if you want to deal with

483
00:14:38,800 --> 00:14:40,720
non-zero ivs but it doesn't really

484
00:14:40,720 --> 00:14:42,160
actually change them

485
00:14:42,160 --> 00:14:43,839
so it's not exactly clear what you do

486
00:14:43,839 --> 00:14:46,560
with this observation right well

487
00:14:46,560 --> 00:14:48,079
if we have a message that we don't know

488
00:14:48,079 --> 00:14:50,079
the contents of and we have the crc

489
00:14:50,079 --> 00:14:51,519
which we also don't know but we have the

490
00:14:51,519 --> 00:14:53,600
encrypted version of it right and we are

491
00:14:53,600 --> 00:14:54,880
flipping a bit

492
00:14:54,880 --> 00:14:56,480
in the message and represented that by

493
00:14:56,480 --> 00:14:58,160
xoring another vector in with the bits

494
00:14:58,160 --> 00:14:59,680
set the high that we want to flip right

495
00:14:59,680 --> 00:15:02,000
this is basic xor we do know the crc of

496
00:15:02,000 --> 00:15:03,600
that thing that we're flipping and it

497
00:15:03,600 --> 00:15:05,040
turns out that we can based on this

498
00:15:05,040 --> 00:15:07,120
exact uh equation

499
00:15:07,120 --> 00:15:09,199
get acocc on the valid mutated message

500
00:15:09,199 --> 00:15:10,399
even though we don't know the contents

501
00:15:10,399 --> 00:15:11,519
of the message and we don't know the

502
00:15:11,519 --> 00:15:14,560
original crc because we just xor in the

503
00:15:14,560 --> 00:15:17,120
coc of what we're flipping um plus the

504
00:15:17,120 --> 00:15:18,240
actually the length of the message in

505
00:15:18,240 --> 00:15:20,079
all zeros because if it's a non-zero id

506
00:15:20,079 --> 00:15:23,839
um xor that in to the encrypted uh crc

507
00:15:23,839 --> 00:15:25,279
because the encryption's just done via

508
00:15:25,279 --> 00:15:27,199
stream cipher when you decrypt this

509
00:15:27,199 --> 00:15:29,519
actually persists through and the coc

510
00:15:29,519 --> 00:15:31,279
validates

511
00:15:31,279 --> 00:15:33,199
so okay we've avoided another speed bump

512
00:15:33,199 --> 00:15:35,600
that's good um

513
00:15:35,600 --> 00:15:37,680
but there's a problem that

514
00:15:37,680 --> 00:15:39,360
we still need a format oracle right and

515
00:15:39,360 --> 00:15:42,000
in fact uh luckily for me what i just

516
00:15:42,000 --> 00:15:44,560
told you is not quite accurate um it's a

517
00:15:44,560 --> 00:15:45,759
little more complicated because remember

518
00:15:45,759 --> 00:15:47,360
we're decompressing this thing that we

519
00:15:47,360 --> 00:15:49,440
export together and flip right and that

520
00:15:49,440 --> 00:15:50,639
means that the bit you're actually

521
00:15:50,639 --> 00:15:53,120
flipping might move right it might even

522
00:15:53,120 --> 00:15:54,720
flip multiple bits and then we don't

523
00:15:54,720 --> 00:15:56,959
know the crc correction to actually do

524
00:15:56,959 --> 00:15:58,399
the reason for this is that deflate

525
00:15:58,399 --> 00:16:00,320
which is what's used uses huffman coding

526
00:16:00,320 --> 00:16:02,079
right and so there's a static for small

527
00:16:02,079 --> 00:16:04,000
message there's a static huffman table

528
00:16:04,000 --> 00:16:06,079
um that is used to encode all these

529
00:16:06,079 --> 00:16:08,160
symbols and it's done by frequency and

530
00:16:08,160 --> 00:16:11,279
so if you have say e i and h in these in

531
00:16:11,279 --> 00:16:12,800
these things and given some relative

532
00:16:12,800 --> 00:16:15,440
frequencies flipping one bit uh in the

533
00:16:15,440 --> 00:16:17,120
huffman symbol is going to get you the

534
00:16:17,120 --> 00:16:19,120
next like similarly frequent symbol or

535
00:16:19,120 --> 00:16:20,480
something right and that might not

536
00:16:20,480 --> 00:16:22,240
actually be the adjacent one in ascii

537
00:16:22,240 --> 00:16:24,560
space right so the bit you flip here is

538
00:16:24,560 --> 00:16:26,079
not actually when it decompresses the

539
00:16:26,079 --> 00:16:28,560
bits that actually change

540
00:16:28,560 --> 00:16:30,079
and this makes our lives more

541
00:16:30,079 --> 00:16:32,000
complicated but it actually is a really

542
00:16:32,000 --> 00:16:33,360
a good thing because this means we

543
00:16:33,360 --> 00:16:35,120
actually have a format oracle we can use

544
00:16:35,120 --> 00:16:37,040
right we can actually learn the contents

545
00:16:37,040 --> 00:16:38,240
of the message based on the coc

546
00:16:38,240 --> 00:16:41,279
correction the way we do this is we

547
00:16:41,279 --> 00:16:43,040
guess what the character in the message

548
00:16:43,040 --> 00:16:45,839
is we flip a bit in the cipher text and

549
00:16:45,839 --> 00:16:48,160
we guess what the resulting change was

550
00:16:48,160 --> 00:16:50,880
in the decompressed message right and

551
00:16:50,880 --> 00:16:52,320
that guess is probably gonna be wrong on

552
00:16:52,320 --> 00:16:54,720
both counts so we try again

553
00:16:54,720 --> 00:16:57,519
and eventually after far more than three

554
00:16:57,519 --> 00:16:59,440
actually uh you will probably guess

555
00:16:59,440 --> 00:17:00,959
correctly and you will now have some

556
00:17:00,959 --> 00:17:02,560
idea what the contents of that message

557
00:17:02,560 --> 00:17:04,400
that character in the message is because

558
00:17:04,400 --> 00:17:06,640
you actually know that the crc is valid

559
00:17:06,640 --> 00:17:07,520
um

560
00:17:07,520 --> 00:17:08,640
you repeat this a couple of times to

561
00:17:08,640 --> 00:17:09,839
deal with false positives and then you

562
00:17:09,839 --> 00:17:11,199
can move on and you can do this

563
00:17:11,199 --> 00:17:13,520
iteratively over the entire message

564
00:17:13,520 --> 00:17:15,679
uh to discover the contents right and so

565
00:17:15,679 --> 00:17:17,280
this is this is the basic trick we're

566
00:17:17,280 --> 00:17:20,319
using the fact that uh gzip errors if

567
00:17:20,319 --> 00:17:22,000
the crc is invalid and that we can

568
00:17:22,000 --> 00:17:23,839
actually make corrections to the crc to

569
00:17:23,839 --> 00:17:25,760
validate what's going on to validate the

570
00:17:25,760 --> 00:17:26,640
message

571
00:17:26,640 --> 00:17:27,679
um

572
00:17:27,679 --> 00:17:29,280
so

573
00:17:29,280 --> 00:17:30,559
just a second for those of you like

574
00:17:30,559 --> 00:17:32,720
following along at home um this is not a

575
00:17:32,720 --> 00:17:35,280
compression oracle right uh

576
00:17:35,280 --> 00:17:37,039
compression oracle is a possible chosen

577
00:17:37,039 --> 00:17:38,320
plain text attack that leverages the

578
00:17:38,320 --> 00:17:39,840
fact that you can just on any generic

579
00:17:39,840 --> 00:17:41,039
form of compression doesn't matter how

580
00:17:41,039 --> 00:17:43,200
it works you can look at how the message

581
00:17:43,200 --> 00:17:45,039
size changes if you put in maybe guesses

582
00:17:45,039 --> 00:17:46,559
as to what uh the other part of the

583
00:17:46,559 --> 00:17:47,840
message is

584
00:17:47,840 --> 00:17:49,200
we can't do that here we're doing a

585
00:17:49,200 --> 00:17:50,720
chosen ciphertext attack and it actually

586
00:17:50,720 --> 00:17:52,240
only works for a specific type of

587
00:17:52,240 --> 00:17:53,840
compression which is uh gzip with a

588
00:17:53,840 --> 00:17:56,320
huffman encoding um so they both use

589
00:17:56,320 --> 00:17:57,200
compression but they're completely

590
00:17:57,200 --> 00:17:59,600
different attacks just just to clarify

591
00:17:59,600 --> 00:18:01,600
um all right so that's nice we now have

592
00:18:01,600 --> 00:18:03,440
this format we can we can exploit we

593
00:18:03,440 --> 00:18:04,960
have the technique we call it a gzip

594
00:18:04,960 --> 00:18:06,880
oracle um

595
00:18:06,880 --> 00:18:08,400
but we still need to be able to observe

596
00:18:08,400 --> 00:18:10,160
when that works right we need to see if

597
00:18:10,160 --> 00:18:11,600
this works or doesn't

598
00:18:11,600 --> 00:18:12,960
uh and

599
00:18:12,960 --> 00:18:14,880
that's a little hard because imessage is

600
00:18:14,880 --> 00:18:17,360
not nice enough to send uh you errors

601
00:18:17,360 --> 00:18:18,480
when you send someone a message that

602
00:18:18,480 --> 00:18:20,320
doesn't uh work right doesn't say i'm

603
00:18:20,320 --> 00:18:21,360
sorry your message could not be

604
00:18:21,360 --> 00:18:24,000
delivered invalid crc please try again

605
00:18:24,000 --> 00:18:24,799
um

606
00:18:24,799 --> 00:18:27,280
and so

607
00:18:27,360 --> 00:18:28,960
we need something right there are read

608
00:18:28,960 --> 00:18:30,400
receipts right if you send someone a

609
00:18:30,400 --> 00:18:32,640
message uh you can tell if they read it

610
00:18:32,640 --> 00:18:33,520
uh

611
00:18:33,520 --> 00:18:35,039
that has two problems with it first of

612
00:18:35,039 --> 00:18:36,240
all it requires that someone actually is

613
00:18:36,240 --> 00:18:37,919
there to read the messages

614
00:18:37,919 --> 00:18:40,320
right which they might not be and second

615
00:18:40,320 --> 00:18:41,679
um

616
00:18:41,679 --> 00:18:42,960
we're going to have to send a lot of

617
00:18:42,960 --> 00:18:44,559
messages and so if you see like two to

618
00:18:44,559 --> 00:18:46,160
the 10 or to the 18 messages getting

619
00:18:46,160 --> 00:18:47,760
sent from someone the game is probably

620
00:18:47,760 --> 00:18:48,640
up

621
00:18:48,640 --> 00:18:50,720
so we're trying to do a realistic attack

622
00:18:50,720 --> 00:18:52,720
here and that's sort of a complete

623
00:18:52,720 --> 00:18:55,679
non-starter um

624
00:18:55,679 --> 00:18:58,240
so we need something else um

625
00:18:58,240 --> 00:19:00,080
luckily it turns out that if you send a

626
00:19:00,080 --> 00:19:02,080
large message in imessage or if you send

627
00:19:02,080 --> 00:19:04,000
a message with a video or a photo as an

628
00:19:04,000 --> 00:19:06,240
attachment um apple's push notification

629
00:19:06,240 --> 00:19:07,600
network as we saw are sort of space

630
00:19:07,600 --> 00:19:09,520
sensitive they don't want to send that

631
00:19:09,520 --> 00:19:11,440
so instead they upload it to the icloud

632
00:19:11,440 --> 00:19:13,200
encrypted under a symmetric key and they

633
00:19:13,200 --> 00:19:14,559
send you a brief notification which is

634
00:19:14,559 --> 00:19:16,799
effectively hey you have mail at this

635
00:19:16,799 --> 00:19:19,280
url with this key to decrypt it and then

636
00:19:19,280 --> 00:19:20,640
when the phone gets that and

637
00:19:20,640 --> 00:19:22,000
decompresses the decrypts and

638
00:19:22,000 --> 00:19:23,840
decompresses the message it does a

639
00:19:23,840 --> 00:19:26,960
download to icloud and um

640
00:19:26,960 --> 00:19:28,240
there doesn't request an icloud and

641
00:19:28,240 --> 00:19:29,840
downloads the message and the cool part

642
00:19:29,840 --> 00:19:32,080
is we can observe this and we know if we

643
00:19:32,080 --> 00:19:34,559
see this request that our message was uh

644
00:19:34,559 --> 00:19:35,679
correct

645
00:19:35,679 --> 00:19:37,039
and if we don't see the request after

646
00:19:37,039 --> 00:19:38,559
some time out we know that it failed and

647
00:19:38,559 --> 00:19:39,840
so now we have our

648
00:19:39,840 --> 00:19:41,120
error oracle we can observe this

649
00:19:41,120 --> 00:19:42,240
remotely

650
00:19:42,240 --> 00:19:43,360
um

651
00:19:43,360 --> 00:19:44,960
it actually gets better

652
00:19:44,960 --> 00:19:46,320
we don't

653
00:19:46,320 --> 00:19:47,280
remember how i said we wanted the

654
00:19:47,280 --> 00:19:49,360
stealth attack we can block the response

655
00:19:49,360 --> 00:19:51,600
to that request from icloud and then you

656
00:19:51,600 --> 00:19:53,120
can't download the attachment and it

657
00:19:53,120 --> 00:19:54,799
turns out that imessage fails silently

658
00:19:54,799 --> 00:19:56,000
in that case right it doesn't display

659
00:19:56,000 --> 00:19:57,440
anything doesn't display a question mark

660
00:19:57,440 --> 00:19:59,600
you know broken unicode box or anything

661
00:19:59,600 --> 00:20:00,799
nothing you never see the attack

662
00:20:00,799 --> 00:20:02,799
happened um and so we can do this entire

663
00:20:02,799 --> 00:20:05,440
thing stealthily more interestingly

664
00:20:05,440 --> 00:20:07,280
we can actually do this even if we can't

665
00:20:07,280 --> 00:20:08,799
observe this request directly because we

666
00:20:08,799 --> 00:20:10,400
can mutate the message and make the

667
00:20:10,400 --> 00:20:12,400
request not go to icloud but go to an

668
00:20:12,400 --> 00:20:15,159
attacker controlled server say you know

669
00:20:15,159 --> 00:20:17,600
i8cloud.com which fun fact matt actually

670
00:20:17,600 --> 00:20:20,000
uh registered just as a proof of concept

671
00:20:20,000 --> 00:20:21,600
um

672
00:20:21,600 --> 00:20:23,760
and so yeah this is nice um this is the

673
00:20:23,760 --> 00:20:25,280
attachment message it's a little big

674
00:20:25,280 --> 00:20:27,039
it's a little complicated um but you can

675
00:20:27,039 --> 00:20:28,559
see that there's a key in there that we

676
00:20:28,559 --> 00:20:30,400
uh probably want to read out this is

677
00:20:30,400 --> 00:20:31,760
what the message is encrypted under so

678
00:20:31,760 --> 00:20:33,280
if we can read this out of the message

679
00:20:33,280 --> 00:20:34,880
we can decrypt the attachment there's

680
00:20:34,880 --> 00:20:36,240
also the url that points to where you're

681
00:20:36,240 --> 00:20:38,320
downloading it

682
00:20:38,320 --> 00:20:39,520
unfortunately this message is a little

683
00:20:39,520 --> 00:20:41,440
big and so the attack gets a lot harder

684
00:20:41,440 --> 00:20:44,400
because uh

685
00:20:44,400 --> 00:20:46,400
gzip it turns out remember i said it

686
00:20:46,400 --> 00:20:48,720
uses static huffman tables well that's

687
00:20:48,720 --> 00:20:50,080
true if the message is small if the

688
00:20:50,080 --> 00:20:52,400
message is large it dynamically computes

689
00:20:52,400 --> 00:20:53,679
the husband table based on the frequency

690
00:20:53,679 --> 00:20:56,240
of the characters in the message

691
00:20:56,240 --> 00:20:57,679
and this message happens to be large

692
00:20:57,679 --> 00:20:59,120
enough for that and so this is a problem

693
00:20:59,120 --> 00:21:00,799
because we can't do the crc guess and

694
00:21:00,799 --> 00:21:02,000
check attack when we don't know the

695
00:21:02,000 --> 00:21:04,080
huffman table and so this is actually

696
00:21:04,080 --> 00:21:05,280
the hardest part of the attack it's the

697
00:21:05,280 --> 00:21:06,559
most expensive part of running it we

698
00:21:06,559 --> 00:21:08,080
have to somehow recover the

699
00:21:08,080 --> 00:21:09,840
cover the huffman table and i don't

700
00:21:09,840 --> 00:21:10,880
really have the time to go into the

701
00:21:10,880 --> 00:21:12,799
exact details it's a pain you basically

702
00:21:12,799 --> 00:21:14,640
have to leverage the same crc error

703
00:21:14,640 --> 00:21:16,799
error issue but do it on known plaintext

704
00:21:16,799 --> 00:21:18,240
and do some complicated stuff to search

705
00:21:18,240 --> 00:21:19,679
for edges between variable length

706
00:21:19,679 --> 00:21:21,440
symbols um

707
00:21:21,440 --> 00:21:23,039
right so once you have that the attack

708
00:21:23,039 --> 00:21:24,480
is fairly straightforward you get a

709
00:21:24,480 --> 00:21:27,039
message somehow uh you change the sender

710
00:21:27,039 --> 00:21:28,799
id you use the crc guess and check

711
00:21:28,799 --> 00:21:31,280
attack both to recover the huffman table

712
00:21:31,280 --> 00:21:32,880
and then to read out the attachment key

713
00:21:32,880 --> 00:21:36,000
right this this key right here um and

714
00:21:36,000 --> 00:21:38,080
then given that you simply decrypt the

715
00:21:38,080 --> 00:21:38,960
attachment message that you've

716
00:21:38,960 --> 00:21:41,679
downloaded from icloud um

717
00:21:41,679 --> 00:21:44,000
right so we did actually implement this

718
00:21:44,000 --> 00:21:47,280
um it takes two to the 18 queries um and

719
00:21:47,280 --> 00:21:48,880
remember i said you have to wait when

720
00:21:48,880 --> 00:21:50,880
you make a cipher text you send a send

721
00:21:50,880 --> 00:21:52,559
to them all from ciphertext to see if

722
00:21:52,559 --> 00:21:53,919
you get this request

723
00:21:53,919 --> 00:21:54,640
well

724
00:21:54,640 --> 00:21:56,320
you usually that happens pretty quickly

725
00:21:56,320 --> 00:21:57,039
like

726
00:21:57,039 --> 00:22:00,080
290 sorry 390 milliseconds um but you

727
00:22:00,080 --> 00:22:01,440
have to wait to make sure if you don't

728
00:22:01,440 --> 00:22:02,559
see it until you're sure that it

729
00:22:02,559 --> 00:22:04,400
actually fails it's not just being slow

730
00:22:04,400 --> 00:22:05,760
and unfortunately there's some

731
00:22:05,760 --> 00:22:07,280
variability on this it's a very long

732
00:22:07,280 --> 00:22:09,360
tail and so the maximum we have to wait

733
00:22:09,360 --> 00:22:11,440
is a second right and so on the naive

734
00:22:11,440 --> 00:22:13,039
proof of concept code we just wait to

735
00:22:13,039 --> 00:22:14,640
see this we have to space every query

736
00:22:14,640 --> 00:22:16,799
out at one second and so that takes 70

737
00:22:16,799 --> 00:22:18,559
to 73 hours

738
00:22:18,559 --> 00:22:20,720
um if you uh improve on the code and you

739
00:22:20,720 --> 00:22:22,159
do backtracking where you send in a

740
00:22:22,159 --> 00:22:24,720
bunch of messages at once and then uh

741
00:22:24,720 --> 00:22:26,240
leverage the fact that most of these are

742
00:22:26,240 --> 00:22:27,679
not going to require

743
00:22:27,679 --> 00:22:28,799
trigger requests most of them will be

744
00:22:28,799 --> 00:22:29,600
bad

745
00:22:29,600 --> 00:22:31,039
and then when you see a request you can

746
00:22:31,039 --> 00:22:32,640
backtrack over the last like tin that

747
00:22:32,640 --> 00:22:34,159
you sent in to find out what it is you

748
00:22:34,159 --> 00:22:35,280
can do this a lot faster in about

749
00:22:35,280 --> 00:22:38,080
probably 35 hours but in either case we

750
00:22:38,080 --> 00:22:39,280
actually executed the attack with proof

751
00:22:39,280 --> 00:22:41,679
of concept code against a real system um

752
00:22:41,679 --> 00:22:44,400
and we recovered 232 out of 256 bits

753
00:22:44,400 --> 00:22:45,600
which is you know pretty good you can

754
00:22:45,600 --> 00:22:47,760
brief force the rest of them uh but of

755
00:22:47,760 --> 00:22:49,679
course this is on one sample ciphertext

756
00:22:49,679 --> 00:22:51,679
that we just happened to pick um and so

757
00:22:51,679 --> 00:22:52,960
maybe it's not clear if this attack

758
00:22:52,960 --> 00:22:54,559
actually works you know in general but

759
00:22:54,559 --> 00:22:56,159
unfortunately we can't easily test it a

760
00:22:56,159 --> 00:22:58,159
bunch of times so instead what we did

761
00:22:58,159 --> 00:23:00,080
was we wrote an emulator that emulated

762
00:23:00,080 --> 00:23:02,640
how imessage validated ciphertext

763
00:23:02,640 --> 00:23:04,880
um and we

764
00:23:04,880 --> 00:23:06,240
actually tested that against the real

765
00:23:06,240 --> 00:23:08,000
implementation and then we ran a huge

766
00:23:08,000 --> 00:23:11,039
number of about 10 000 simulated uh

767
00:23:11,039 --> 00:23:12,000
attacks

768
00:23:12,000 --> 00:23:14,240
it turns out that for uh

769
00:23:14,240 --> 00:23:16,960
about uh 34 of the time we cover all 40

770
00:23:16,960 --> 00:23:18,880
bits of the message uh this encryption

771
00:23:18,880 --> 00:23:21,120
key this and the attachment and

772
00:23:21,120 --> 00:23:24,080
for uh about 25 of the time we recover

773
00:23:24,080 --> 00:23:26,159
uh all about 24 bits of it so the

774
00:23:26,159 --> 00:23:27,440
interesting thing is if you plot the

775
00:23:27,440 --> 00:23:29,120
number of queries it takes versus the

776
00:23:29,120 --> 00:23:30,960
number of bits we recover the attack is

777
00:23:30,960 --> 00:23:32,799
actually fairly efficient when we

778
00:23:32,799 --> 00:23:34,640
actually get it to work

779
00:23:34,640 --> 00:23:37,600
but as you as you go down um

780
00:23:37,600 --> 00:23:38,960
and start failing and recovering enough

781
00:23:38,960 --> 00:23:40,480
bits it actually starts getting worse so

782
00:23:40,480 --> 00:23:41,679
this tells me actually that the proof of

783
00:23:41,679 --> 00:23:43,679
concept code we wrote has some room for

784
00:23:43,679 --> 00:23:45,760
optimizations um

785
00:23:45,760 --> 00:23:48,640
so how do you fix this well ideally you

786
00:23:48,640 --> 00:23:50,240
deploy something like axelot or a signal

787
00:23:50,240 --> 00:23:52,400
which has you know forward secure

788
00:23:52,400 --> 00:23:54,720
properties and a nice nice system if you

789
00:23:54,720 --> 00:23:55,679
didn't want to do that you could use

790
00:23:55,679 --> 00:23:57,919
authenticated encryption use aes dcm or

791
00:23:57,919 --> 00:23:59,760
ocv mode

792
00:23:59,760 --> 00:24:01,919
and or just include an hmac but the

793
00:24:01,919 --> 00:24:03,279
problem is this breaks backwards

794
00:24:03,279 --> 00:24:05,120
compatibility right because both ends of

795
00:24:05,120 --> 00:24:06,559
the protocol both ends have to be

796
00:24:06,559 --> 00:24:08,320
upgraded and if you have a billion

797
00:24:08,320 --> 00:24:09,600
devices and there's a bunch of different

798
00:24:09,600 --> 00:24:10,960
versions and a bunch of different things

799
00:24:10,960 --> 00:24:12,880
that's a problem so that gives gets us

800
00:24:12,880 --> 00:24:13,760
into the question of real board

801
00:24:13,760 --> 00:24:16,240
mitigations um and uh for those of you

802
00:24:16,240 --> 00:24:17,440
who've ever done that this is kind of a

803
00:24:17,440 --> 00:24:19,039
tire fire you're kind of trying to

804
00:24:19,039 --> 00:24:20,159
develop

805
00:24:20,159 --> 00:24:21,840
a the smallest minimal band-aid that

806
00:24:21,840 --> 00:24:23,039
doesn't break anything but actually does

807
00:24:23,039 --> 00:24:26,240
protect against the attack um and

808
00:24:26,240 --> 00:24:30,000
uh very briefly we sort of uh

809
00:24:30,000 --> 00:24:31,600
we gave two proposals one of which was

810
00:24:31,600 --> 00:24:33,600
to fix the uh

811
00:24:33,600 --> 00:24:36,240
the uh identity miss binding attack that

812
00:24:36,240 --> 00:24:38,000
apple had um but that was a little

813
00:24:38,000 --> 00:24:39,279
sensitive to how you did formatting it

814
00:24:39,279 --> 00:24:41,200
didn't work the actual mitigation we

815
00:24:41,200 --> 00:24:43,919
propose which is what's deployed is that

816
00:24:43,919 --> 00:24:44,960
uh

817
00:24:44,960 --> 00:24:47,120
you blacklist rsa cipher texts because

818
00:24:47,120 --> 00:24:48,880
the rsa ciphertext is unmarriable so

819
00:24:48,880 --> 00:24:50,320
you're going is invaluable so you're

820
00:24:50,320 --> 00:24:51,440
going to get

821
00:24:51,440 --> 00:24:53,440
this rsa ciphertext and then multiple

822
00:24:53,440 --> 00:24:54,960
versions of the as ciphertext with like

823
00:24:54,960 --> 00:24:57,039
bits permuted in it and so if you see

824
00:24:57,039 --> 00:24:59,360
the same rsa ciphertext twice you know

825
00:24:59,360 --> 00:25:00,640
that someone's running this attack and

826
00:25:00,640 --> 00:25:02,559
you can just discard those responses so

827
00:25:02,559 --> 00:25:06,240
this is deployed in irs uh

828
00:25:06,240 --> 00:25:08,720
nine three plus and os x um it took

829
00:25:08,720 --> 00:25:10,960
apple about four months and 30 engineers

830
00:25:10,960 --> 00:25:12,559
to deploy and test this because it takes

831
00:25:12,559 --> 00:25:13,600
a large amount of time to actually

832
00:25:13,600 --> 00:25:15,440
validate these things

833
00:25:15,440 --> 00:25:16,640
um

834
00:25:16,640 --> 00:25:19,760
and yeah uh that's sort of i have to

835
00:25:19,760 --> 00:25:21,120
give up a lot of props because while

836
00:25:21,120 --> 00:25:22,799
this was going on the end of it they

837
00:25:22,799 --> 00:25:26,080
were dealing with uh this as well uh so

838
00:25:26,080 --> 00:25:27,840
with that

839
00:25:27,840 --> 00:25:28,799
i'm actually just going to take

840
00:25:28,799 --> 00:25:30,640
questions

841
00:25:30,640 --> 00:25:32,030
thank you

842
00:25:32,030 --> 00:25:40,960
[Applause]

843
00:25:40,960 --> 00:25:42,799
uh kenny patterson from royal holloway

844
00:25:42,799 --> 00:25:44,240
thank you for the great talk and i

845
00:25:44,240 --> 00:25:45,520
really appreciate the great work that

846
00:25:45,520 --> 00:25:47,200
you guys have done on this paper i just

847
00:25:47,200 --> 00:25:48,559
wanted to point out that the solution is

848
00:25:48,559 --> 00:25:50,480
not really authenticated encryption this

849
00:25:50,480 --> 00:25:52,320
is a public key primitive what you

850
00:25:52,320 --> 00:25:54,480
really want is a sign encryption scheme

851
00:25:54,480 --> 00:25:56,240
which you can build from authenticated

852
00:25:56,240 --> 00:25:58,000
encryption with the appropriate use of

853
00:25:58,000 --> 00:25:59,600
public key encryption and signatures

854
00:25:59,600 --> 00:26:01,279
right and actually if you look at the

855
00:26:01,279 --> 00:26:02,880
encryption literature which clearly the

856
00:26:02,880 --> 00:26:05,679
apple engineers manifestly failed to do

857
00:26:05,679 --> 00:26:07,840
you find out that including the identity

858
00:26:07,840 --> 00:26:09,600
as part of the plaintext is one of the

859
00:26:09,600 --> 00:26:11,279
counter measures you need to prevent the

860
00:26:11,279 --> 00:26:12,720
identity miss binding attacks that you

861
00:26:12,720 --> 00:26:15,279
pointed out so the what's really

862
00:26:15,279 --> 00:26:16,400
interesting here is that the cryptal

863
00:26:16,400 --> 00:26:18,720
literature is very clear about how you

864
00:26:18,720 --> 00:26:20,320
should design a system to achieve the

865
00:26:20,320 --> 00:26:22,159
security properties that imessage sets

866
00:26:22,159 --> 00:26:24,400
out to to have right and so i think one

867
00:26:24,400 --> 00:26:25,679
of the one of the interesting things

868
00:26:25,679 --> 00:26:26,960
someone once asked when i was giving a

869
00:26:26,960 --> 00:26:28,799
talk on this like why do we have this

870
00:26:28,799 --> 00:26:30,799
weird mix of rsa and ecdsa for

871
00:26:30,799 --> 00:26:32,320
primitives right you'd think if you used

872
00:26:32,320 --> 00:26:34,640
one if you use ecdsa you use some fancy

873
00:26:34,640 --> 00:26:36,799
you know alcohol whatever elliptical

874
00:26:36,799 --> 00:26:38,480
falcomold scheme i think the answer to

875
00:26:38,480 --> 00:26:40,400
this is this sort of was designed based

876
00:26:40,400 --> 00:26:43,279
on the menu of apis that whatever

877
00:26:43,279 --> 00:26:44,640
cryptographic library they're using i

878
00:26:44,640 --> 00:26:45,760
believe at the time probably opened an

879
00:26:45,760 --> 00:26:48,559
ssl though not anymore um was and those

880
00:26:48,559 --> 00:26:51,360
primitives just don't exist as far as i

881
00:26:51,360 --> 00:26:53,919
know even in implementations

882
00:26:53,919 --> 00:26:55,039
so that's sort of i think how we ended

883
00:26:55,039 --> 00:26:57,840
up in this situation

884
00:27:00,000 --> 00:27:01,919
so i would like to ask

885
00:27:01,919 --> 00:27:05,039
two questions about rsa so have you

886
00:27:05,039 --> 00:27:07,600
tried panicura cladducks against rsa

887
00:27:07,600 --> 00:27:09,840
ciphertext like manners attack

888
00:27:09,840 --> 00:27:11,440
so uh

889
00:27:11,440 --> 00:27:13,360
we as far as we could determine this was

890
00:27:13,360 --> 00:27:15,360
rsa or ap and it was implemented

891
00:27:15,360 --> 00:27:17,120
correctly so i think those attacks

892
00:27:17,120 --> 00:27:19,279
shouldn't be uh viable but in all

893
00:27:19,279 --> 00:27:21,279
honesty we mainly went for the the one

894
00:27:21,279 --> 00:27:22,559
the vulnerability that we saw that we

895
00:27:22,559 --> 00:27:24,240
knew would have uh traction

896
00:27:24,240 --> 00:27:26,159
okay and the second question also uh

897
00:27:26,159 --> 00:27:28,080
airside oip is static

898
00:27:28,080 --> 00:27:30,240
defense or you cannot do some backwards

899
00:27:30,240 --> 00:27:33,600
compatibility to pkcs 1.5 so that you

900
00:27:33,600 --> 00:27:35,120
could uh maybe

901
00:27:35,120 --> 00:27:37,200
execute black in background attacks

902
00:27:37,200 --> 00:27:38,720
yeah you might be able to do that

903
00:27:38,720 --> 00:27:41,039
actually i'm not entirely sure

904
00:27:41,039 --> 00:27:42,559
okay

905
00:27:42,559 --> 00:27:44,879
thank you

906
00:27:45,520 --> 00:27:47,679
i also have one question um so when

907
00:27:47,679 --> 00:27:49,279
explaining the attack you also said that

908
00:27:49,279 --> 00:27:51,440
you're dealing with false positives but

909
00:27:51,440 --> 00:27:53,279
didn't go into details can you maybe

910
00:27:53,279 --> 00:27:55,120
elaborate on this oh sorry the false

911
00:27:55,120 --> 00:27:57,360
positive is what uh when you had when

912
00:27:57,360 --> 00:27:59,440
you explained the uh the decryption so

913
00:27:59,440 --> 00:28:01,520
your actual attack and you said that

914
00:28:01,520 --> 00:28:03,919
sometimes false positives can happen

915
00:28:03,919 --> 00:28:05,600
right so what can happen is of course

916
00:28:05,600 --> 00:28:07,279
you're not guessing as to what the

917
00:28:07,279 --> 00:28:09,039
actual character was and what you

918
00:28:09,039 --> 00:28:10,320
changed it to you're guessing as to what

919
00:28:10,320 --> 00:28:12,559
the xo of those two things were and

920
00:28:12,559 --> 00:28:13,919
occasionally that could of course be

921
00:28:13,919 --> 00:28:15,679
valid for something else and so what

922
00:28:15,679 --> 00:28:17,039
happens is you make a couple of more

923
00:28:17,039 --> 00:28:19,200
guesses as to the character was this and

924
00:28:19,200 --> 00:28:21,200
i'm now going to change a different bit

925
00:28:21,200 --> 00:28:22,480
and it's going to be permuted to a

926
00:28:22,480 --> 00:28:23,840
different symbol and so if you do that

927
00:28:23,840 --> 00:28:25,360
two or three times you get a fairly high

928
00:28:25,360 --> 00:28:27,360
assurance uh that

929
00:28:27,360 --> 00:28:30,240
it's the right guess

930
00:28:30,240 --> 00:28:32,490
let's thank the speaker again

931
00:28:32,490 --> 00:28:38,069
[Applause]

