1
00:00:10,800 --> 00:00:12,880
thank you dr lesson and

2
00:00:12,880 --> 00:00:14,920
thanks sebastian's great talk on

3
00:00:14,920 --> 00:00:17,600
sench good morning everyone my name is

4
00:00:17,600 --> 00:00:20,720
dave i'm from university of florida and

5
00:00:20,720 --> 00:00:23,359
i'm here to present our paper making usb

6
00:00:23,359 --> 00:00:25,920
great again with usb filter i would like

7
00:00:25,920 --> 00:00:28,080
to thank our co-authors

8
00:00:28,080 --> 00:00:31,199
nolan's gave adam bass kevin butler and

9
00:00:31,199 --> 00:00:33,280
patrick trainer

10
00:00:33,280 --> 00:00:35,440
so first we would like to thank our

11
00:00:35,440 --> 00:00:37,840
advisors who provide solid funding to

12
00:00:37,840 --> 00:00:40,559
make this solid head and ask us to wear

13
00:00:40,559 --> 00:00:42,840
this hat during the

14
00:00:42,840 --> 00:00:47,360
presentation so here is my head

15
00:00:48,559 --> 00:00:50,000
all right so

16
00:00:50,000 --> 00:00:54,000
what is usb and why usb was great so usb

17
00:00:54,000 --> 00:00:56,960
is short for universal serial bus with

18
00:00:56,960 --> 00:00:59,359
the 20 years of development it has

19
00:00:59,359 --> 00:01:02,239
replaced a lot of old technologies so

20
00:01:02,239 --> 00:01:05,438
for example uh at the left corner no one

21
00:01:05,438 --> 00:01:07,840
can find the ps2 ports which were for

22
00:01:07,840 --> 00:01:10,080
keyboard and mouse uh in the current

23
00:01:10,080 --> 00:01:12,400
laptop or laptops

24
00:01:12,400 --> 00:01:15,600
and it also has been evolving from 1.0

25
00:01:15,600 --> 00:01:19,040
to the latest one 3.1 and type c

26
00:01:19,040 --> 00:01:23,040
in usb 3.1 the speed can be up to 10

27
00:01:23,040 --> 00:01:25,680
gigabits per second which is fast enough

28
00:01:25,680 --> 00:01:28,560
to support most external storage devices

29
00:01:28,560 --> 00:01:30,799
and even gpu cards

30
00:01:30,799 --> 00:01:33,840
usb is truly ubiquitous

31
00:01:33,840 --> 00:01:37,439
virtually everyone can find usb ports on

32
00:01:37,439 --> 00:01:40,880
every computer which includes desktops

33
00:01:40,880 --> 00:01:44,880
servers routers switches right and

34
00:01:44,880 --> 00:01:46,720
essentially there are tons of different

35
00:01:46,720 --> 00:01:50,159
usb devices so we've got usb shoes we've

36
00:01:50,159 --> 00:01:52,640
got usb fridge

37
00:01:52,640 --> 00:01:55,920
everyone just love usb

38
00:01:55,920 --> 00:01:59,360
but what is the problem so um

39
00:01:59,360 --> 00:02:01,920
in oakland this year uh

40
00:02:01,920 --> 00:02:04,159
there's a paper talking about

41
00:02:04,159 --> 00:02:07,439
people just plugging the usb device or

42
00:02:07,439 --> 00:02:09,840
the flash drive they found somewhere

43
00:02:09,840 --> 00:02:13,680
without a second consideration so

44
00:02:13,680 --> 00:02:16,319
this makes usb flash drive a perfect way

45
00:02:16,319 --> 00:02:17,520
to

46
00:02:17,520 --> 00:02:20,400
propagate the malware and even breaking

47
00:02:20,400 --> 00:02:23,920
into the air gap so the the most famous

48
00:02:23,920 --> 00:02:25,360
example is

49
00:02:25,360 --> 00:02:28,319
the stock net uh malware which can be

50
00:02:28,319 --> 00:02:30,800
find within the usb flash drive

51
00:02:30,800 --> 00:02:33,040
and this malware is able to destroy the

52
00:02:33,040 --> 00:02:35,519
industrial control system of a nuclear

53
00:02:35,519 --> 00:02:37,200
plant

54
00:02:37,200 --> 00:02:39,599
and for sure more recently we've got bad

55
00:02:39,599 --> 00:02:41,120
usb attacks

56
00:02:41,120 --> 00:02:43,680
so basically battery usb attacks allows

57
00:02:43,680 --> 00:02:46,560
users to add a new functionality within

58
00:02:46,560 --> 00:02:49,519
the usb firmware so for example a usb

59
00:02:49,519 --> 00:02:52,160
flash drive can behave like a keyboard

60
00:02:52,160 --> 00:02:54,239
and inject malicious script into the

61
00:02:54,239 --> 00:02:56,000
host machine

62
00:02:56,000 --> 00:02:59,280
but actually we've got tons of

63
00:02:59,280 --> 00:03:01,440
usb penetration tools available in the

64
00:03:01,440 --> 00:03:04,159
market for a year one of the example is

65
00:03:04,159 --> 00:03:07,200
usb rubber ducky which is 39 bucks i

66
00:03:07,200 --> 00:03:08,319
think

67
00:03:08,319 --> 00:03:10,640
it looks like usb flash drive but

68
00:03:10,640 --> 00:03:13,519
essentially it is a programmable usb

69
00:03:13,519 --> 00:03:14,879
keyboard

70
00:03:14,879 --> 00:03:16,560
and for sure we've got some solutions

71
00:03:16,560 --> 00:03:18,640
right so one of the solutions is to

72
00:03:18,640 --> 00:03:21,760
physically block the usb port

73
00:03:21,760 --> 00:03:23,760
this is really common for a security

74
00:03:23,760 --> 00:03:25,440
sensitive environment for example for

75
00:03:25,440 --> 00:03:26,560
governments

76
00:03:26,560 --> 00:03:30,879
national labs or mentally military labs

77
00:03:30,879 --> 00:03:33,920
but before we start to use super glue to

78
00:03:33,920 --> 00:03:36,159
destroy our usb port we probably want to

79
00:03:36,159 --> 00:03:37,200
know

80
00:03:37,200 --> 00:03:39,040
something deeper about usb

81
00:03:39,040 --> 00:03:41,440
so the way for the usb host machine to

82
00:03:41,440 --> 00:03:43,360
recognize the device

83
00:03:43,360 --> 00:03:46,000
is called usb enumeration so when the

84
00:03:46,000 --> 00:03:49,760
device is plugged into the host machine

85
00:03:49,760 --> 00:03:52,319
the host machine is gonna ask for some

86
00:03:52,319 --> 00:03:54,080
information and the device is

87
00:03:54,080 --> 00:03:56,799
responsible for all this information for

88
00:03:56,799 --> 00:03:59,920
example the manufacturer the product as

89
00:03:59,920 --> 00:04:02,000
we can see this device is a kingston

90
00:04:02,000 --> 00:04:03,200
flash drive

91
00:04:03,200 --> 00:04:06,400
and then the device got a request for

92
00:04:06,400 --> 00:04:08,400
some functionality which can be

93
00:04:08,400 --> 00:04:11,120
satisfied by the operating system

94
00:04:11,120 --> 00:04:13,040
and as we can see this device is

95
00:04:13,040 --> 00:04:15,280
requesting a storage device since it is

96
00:04:15,280 --> 00:04:17,918
a flash drive in bad usb attacks

97
00:04:17,918 --> 00:04:20,238
unfortunately this device would also

98
00:04:20,238 --> 00:04:23,360
request a human interface functionality

99
00:04:23,360 --> 00:04:25,440
which is required

100
00:04:25,440 --> 00:04:28,479
for all the keyboard or any other input

101
00:04:28,479 --> 00:04:31,040
to usb devices

102
00:04:31,040 --> 00:04:33,840
and then if we look into the usb device

103
00:04:33,840 --> 00:04:36,720
we realize a usb device can have

104
00:04:36,720 --> 00:04:39,840
multiple interfaces so each interface is

105
00:04:39,840 --> 00:04:42,479
a standalone functionality so for

106
00:04:42,479 --> 00:04:45,199
example in a usb headset we probably

107
00:04:45,199 --> 00:04:47,520
have more than three interfaces

108
00:04:47,520 --> 00:04:50,560
one for audio uh the other for speaker

109
00:04:50,560 --> 00:04:52,160
and the last one maybe for the volume

110
00:04:52,160 --> 00:04:53,360
control

111
00:04:53,360 --> 00:04:56,160
and if we look into the interface we'll

112
00:04:56,160 --> 00:04:58,240
see a bunch of endpoints

113
00:04:58,240 --> 00:05:01,520
which are grouped based on the direction

114
00:05:01,520 --> 00:05:04,240
of the usb communication so if the

115
00:05:04,240 --> 00:05:06,639
communication is from the usb host

116
00:05:06,639 --> 00:05:09,759
machine to the device then it is out

117
00:05:09,759 --> 00:05:13,120
otherwise it is in which means

118
00:05:13,120 --> 00:05:15,360
the communication is from the device to

119
00:05:15,360 --> 00:05:17,039
the host machine

120
00:05:17,039 --> 00:05:20,560
so once we know the device the interface

121
00:05:20,560 --> 00:05:23,280
the direction of the usb communication

122
00:05:23,280 --> 00:05:26,800
the real communication of the usb

123
00:05:26,800 --> 00:05:30,720
happens within the endpoint

124
00:05:32,720 --> 00:05:35,440
then the question is what is the basic

125
00:05:35,440 --> 00:05:38,720
communication unit within the usb wires

126
00:05:38,720 --> 00:05:41,759
so it turns out it is a usb packet

127
00:05:41,759 --> 00:05:44,240
so for example every time when you type

128
00:05:44,240 --> 00:05:46,240
a key on the keyboard there will be a

129
00:05:46,240 --> 00:05:48,479
usb package encapsulated within the

130
00:05:48,479 --> 00:05:50,479
keystroke and delivered to the host

131
00:05:50,479 --> 00:05:51,680
machine

132
00:05:51,680 --> 00:05:53,280
similarly

133
00:05:53,280 --> 00:05:55,680
if we want to read or write a file saved

134
00:05:55,680 --> 00:05:58,080
in a usb storage there will be bunch of

135
00:05:58,080 --> 00:06:00,240
usb packages encapsulating the

136
00:06:00,240 --> 00:06:02,240
corresponding data

137
00:06:02,240 --> 00:06:04,960
and in bad usb attacks

138
00:06:04,960 --> 00:06:07,600
the storage is also able to send out the

139
00:06:07,600 --> 00:06:10,160
keyboard usb pad

140
00:06:10,160 --> 00:06:13,120
usb package

141
00:06:13,120 --> 00:06:14,000
so

142
00:06:14,000 --> 00:06:16,880
basically inspired by net filter within

143
00:06:16,880 --> 00:06:18,479
the lens kernel

144
00:06:18,479 --> 00:06:20,960
we we were wondering if it is possible

145
00:06:20,960 --> 00:06:23,680
to control the behavior of usb devices

146
00:06:23,680 --> 00:06:27,440
by controlling the usb packet

147
00:06:27,440 --> 00:06:29,680
and here we go uh we designed and

148
00:06:29,680 --> 00:06:33,199
implemented usb filter so usb filter is

149
00:06:33,199 --> 00:06:36,000
a kernel component working under the

150
00:06:36,000 --> 00:06:37,840
host controller so which means we

151
00:06:37,840 --> 00:06:40,319
basically trust the kernel and it has

152
00:06:40,319 --> 00:06:43,039
two other kernel components

153
00:06:43,039 --> 00:06:45,919
the right one is usb filter modules

154
00:06:45,919 --> 00:06:48,080
which means system main or developers

155
00:06:48,080 --> 00:06:49,520
can write

156
00:06:49,520 --> 00:06:52,479
new features and plug in these kernel

157
00:06:52,479 --> 00:06:54,400
modules into usb fuse

158
00:06:54,400 --> 00:06:57,360
filter dynamically and before usb filter

159
00:06:57,360 --> 00:06:59,840
is able to filter each usb packet it

160
00:06:59,840 --> 00:07:02,400
would query the root database which can

161
00:07:02,400 --> 00:07:05,039
which contains all the policies for the

162
00:07:05,039 --> 00:07:07,120
packet filtering and within the use

163
00:07:07,120 --> 00:07:08,160
space

164
00:07:08,160 --> 00:07:10,639
we provide a user-based tool called usb

165
00:07:10,639 --> 00:07:11,680
tables

166
00:07:11,680 --> 00:07:14,160
which is to manage all this policy and

167
00:07:14,160 --> 00:07:16,080
rules

168
00:07:16,080 --> 00:07:19,759
one cool feature of usb filter as

169
00:07:19,759 --> 00:07:21,120
one can see

170
00:07:21,120 --> 00:07:24,720
it is able to correlate a usb packet

171
00:07:24,720 --> 00:07:27,039
within the kernel with the i o

172
00:07:27,039 --> 00:07:29,759
operations of circuit applications in

173
00:07:29,759 --> 00:07:31,440
the user space

174
00:07:31,440 --> 00:07:34,000
so to uh to achieve this goal we

175
00:07:34,000 --> 00:07:37,360
instrumented um a bunch of general usb

176
00:07:37,360 --> 00:07:41,120
devices drivers to trace back the pid of

177
00:07:41,120 --> 00:07:43,840
the originating applications for certain

178
00:07:43,840 --> 00:07:46,560
usb package so for example we did some

179
00:07:46,560 --> 00:07:48,960
hacking within the usb driver to recover

180
00:07:48,960 --> 00:07:51,599
the pid

181
00:07:52,720 --> 00:07:55,280
but before we designed implemented usb

182
00:07:55,280 --> 00:07:58,080
filters we set up some goals to make

183
00:07:58,080 --> 00:08:00,800
sure it is not just a firewall within

184
00:08:00,800 --> 00:08:03,360
the lens kernel so the first goal

185
00:08:03,360 --> 00:08:06,000
is complete mediation which means we're

186
00:08:06,000 --> 00:08:08,800
able to mediate all the usb packets

187
00:08:08,800 --> 00:08:10,879
within the host machine

188
00:08:10,879 --> 00:08:13,120
the second goal is temper proof

189
00:08:13,120 --> 00:08:15,840
that means no use space program can

190
00:08:15,840 --> 00:08:18,720
bypass or disable usb filter without

191
00:08:18,720 --> 00:08:20,560
root permission

192
00:08:20,560 --> 00:08:23,039
the third one is verifiability while

193
00:08:23,039 --> 00:08:25,360
we're not able we're not able to

194
00:08:25,360 --> 00:08:26,960
formally verify the kernel

195
00:08:26,960 --> 00:08:29,120
implementation but instead we're

196
00:08:29,120 --> 00:08:32,958
focusing on the rule consistency verify

197
00:08:32,958 --> 00:08:35,440
verifiability that means before each

198
00:08:35,440 --> 00:08:38,240
rule is added into the kernel we want we

199
00:08:38,240 --> 00:08:40,719
want to make sure there's no conflict

200
00:08:40,719 --> 00:08:42,559
between this neural and all other

201
00:08:42,559 --> 00:08:45,279
existing rules within the kernel

202
00:08:45,279 --> 00:08:48,000
so basically these three

203
00:08:48,000 --> 00:08:49,920
goals are the

204
00:08:49,920 --> 00:08:52,000
properties of a

205
00:08:52,000 --> 00:08:55,120
reference monitor and then the last

206
00:08:55,120 --> 00:08:57,839
the fourth goal is granularity so in

207
00:08:57,839 --> 00:09:00,320
general we want to provide as many root

208
00:09:00,320 --> 00:09:02,720
constructions as possible to enable

209
00:09:02,720 --> 00:09:05,440
system in to write powerful and flexible

210
00:09:05,440 --> 00:09:06,720
rules

211
00:09:06,720 --> 00:09:09,839
the last one is extensibility

212
00:09:09,839 --> 00:09:12,080
just like the usb filter module we've

213
00:09:12,080 --> 00:09:13,519
mentioned before

214
00:09:13,519 --> 00:09:16,160
we allow system main to write new

215
00:09:16,160 --> 00:09:18,720
features and plugging them into usb

216
00:09:18,720 --> 00:09:21,120
filter

217
00:09:21,519 --> 00:09:23,680
so first let's look at rule

218
00:09:23,680 --> 00:09:26,560
constructions so basically we've had we

219
00:09:26,560 --> 00:09:29,279
have 21 rule constructions and we

220
00:09:29,279 --> 00:09:32,480
divided them uh into four tables the

221
00:09:32,480 --> 00:09:34,880
first table is the process table which

222
00:09:34,880 --> 00:09:37,040
has all the information about this user

223
00:09:37,040 --> 00:09:39,120
space process application

224
00:09:39,120 --> 00:09:42,720
for example we've got pid ppid ui dn

225
00:09:42,720 --> 00:09:43,920
command line

226
00:09:43,920 --> 00:09:45,839
and then the second table is device

227
00:09:45,839 --> 00:09:48,160
table which has all the information

228
00:09:48,160 --> 00:09:51,120
about this device like manufacturer

229
00:09:51,120 --> 00:09:54,160
product serial number and some physical

230
00:09:54,160 --> 00:09:56,399
connecting information about this device

231
00:09:56,399 --> 00:09:59,040
for example where this device is plugged

232
00:09:59,040 --> 00:10:02,240
into the bus number the port number

233
00:10:02,240 --> 00:10:05,200
and then the third table is packet table

234
00:10:05,200 --> 00:10:06,399
it has

235
00:10:06,399 --> 00:10:09,360
the properties about this usb pack for

236
00:10:09,360 --> 00:10:11,440
example if this is a

237
00:10:11,440 --> 00:10:14,000
keyboard packet or if this is a usb

238
00:10:14,000 --> 00:10:15,519
storage packet

239
00:10:15,519 --> 00:10:18,079
uh what about the direction if is in or

240
00:10:18,079 --> 00:10:21,600
out and what is the endpoint which is

241
00:10:21,600 --> 00:10:23,920
responsible for the communication and

242
00:10:23,920 --> 00:10:26,640
the last table islam which is short for

243
00:10:26,640 --> 00:10:28,959
linux usb filter module and we will talk

244
00:10:28,959 --> 00:10:30,839
about that in later

245
00:10:30,839 --> 00:10:32,640
slides

246
00:10:32,640 --> 00:10:34,560
so before

247
00:10:34,560 --> 00:10:37,279
we can talk about rule consistency we

248
00:10:37,279 --> 00:10:39,839
need to talk about uh something else

249
00:10:39,839 --> 00:10:42,720
because the way we look for rule

250
00:10:42,720 --> 00:10:45,920
consistent verify of verification is to

251
00:10:45,920 --> 00:10:48,560
look for the conflict between any two

252
00:10:48,560 --> 00:10:50,160
rules

253
00:10:50,160 --> 00:10:52,240
so

254
00:10:52,240 --> 00:10:54,240
we need to define

255
00:10:54,240 --> 00:10:57,360
a general conflict at first

256
00:10:57,360 --> 00:10:59,600
here is the formal description so what

257
00:10:59,600 --> 00:11:01,519
it says is

258
00:11:01,519 --> 00:11:04,640
if root a is a subset of rule b

259
00:11:04,640 --> 00:11:05,519
or

260
00:11:05,519 --> 00:11:08,160
put it in another way if there's a usb

261
00:11:08,160 --> 00:11:11,120
packet which matches both the rule a and

262
00:11:11,120 --> 00:11:13,920
root b we will say there will be some

263
00:11:13,920 --> 00:11:16,959
general conflict between ru a and ruby

264
00:11:16,959 --> 00:11:18,480
so for example

265
00:11:18,480 --> 00:11:21,279
if we have a rule saying that blocking

266
00:11:21,279 --> 00:11:23,920
all usb ports and then we have another

267
00:11:23,920 --> 00:11:27,760
rule saying that blocking usb port 5

268
00:11:27,760 --> 00:11:30,959
then there will be general conflict

269
00:11:30,959 --> 00:11:33,360
and depends on the

270
00:11:33,360 --> 00:11:36,240
the final action of these rules which is

271
00:11:36,240 --> 00:11:38,880
either allow this package or to drop

272
00:11:38,880 --> 00:11:42,399
this packet we have weak conflict and

273
00:11:42,399 --> 00:11:44,880
strong conflict so if

274
00:11:44,880 --> 00:11:47,279
the action is the same then we call it a

275
00:11:47,279 --> 00:11:50,160
weak conflict otherwise it is a strong

276
00:11:50,160 --> 00:11:52,320
conflict the reason why we talk about

277
00:11:52,320 --> 00:11:54,320
all all these different conflict

278
00:11:54,320 --> 00:11:56,399
definitions is our current

279
00:11:56,399 --> 00:11:58,320
implementation is

280
00:11:58,320 --> 00:12:00,880
looking for general conflict which

281
00:12:00,880 --> 00:12:02,079
provides

282
00:12:02,079 --> 00:12:03,519
the strongest

283
00:12:03,519 --> 00:12:06,240
consistency checking but in reality we

284
00:12:06,240 --> 00:12:09,200
probably can just look for strong

285
00:12:09,200 --> 00:12:12,800
conflict and allow weak conflict so the

286
00:12:12,800 --> 00:12:15,040
whole rule consistent tracking is

287
00:12:15,040 --> 00:12:17,680
implemented as a prologue engine which

288
00:12:17,680 --> 00:12:18,800
turns

289
00:12:18,800 --> 00:12:21,279
the the rule policy checking into

290
00:12:21,279 --> 00:12:23,760
logical reasoning

291
00:12:23,760 --> 00:12:25,920
and then here is the linux usb filter

292
00:12:25,920 --> 00:12:28,800
module it is essentially a user defined

293
00:12:28,800 --> 00:12:31,920
extension for usb filter so to write

294
00:12:31,920 --> 00:12:34,320
alarm all we need is to include this

295
00:12:34,320 --> 00:12:36,320
header file and then one can write a

296
00:12:36,320 --> 00:12:38,639
cool current module so it is a rule

297
00:12:38,639 --> 00:12:41,519
construction unit which means once the

298
00:12:41,519 --> 00:12:44,320
alarm is plugged into the usb filter one

299
00:12:44,320 --> 00:12:47,200
can write new rules using this long as

300
00:12:47,200 --> 00:12:48,800
we have seen in the root construction

301
00:12:48,800 --> 00:12:50,000
table

302
00:12:50,000 --> 00:12:52,720
and essentially llama is a way to look

303
00:12:52,720 --> 00:12:56,240
into the usb package may encapsulate uh

304
00:12:56,240 --> 00:12:59,040
other packs like scusi command ip

305
00:12:59,040 --> 00:13:01,040
package or

306
00:13:01,040 --> 00:13:03,680
human interface device package like the

307
00:13:03,680 --> 00:13:06,320
keystroke from keyboard

308
00:13:06,320 --> 00:13:08,160
so here we show a

309
00:13:08,160 --> 00:13:10,800
simple alarm implementation to detect

310
00:13:10,800 --> 00:13:13,920
viscosity write command so sagasi is the

311
00:13:13,920 --> 00:13:16,959
protocol used by most usb storage

312
00:13:16,959 --> 00:13:19,760
devices so to read or write a file

313
00:13:19,760 --> 00:13:23,600
within a usb storage the usb package is

314
00:13:23,600 --> 00:13:26,639
able or needs to carry the corresponding

315
00:13:26,639 --> 00:13:29,680
sc command and the data inside to finish

316
00:13:29,680 --> 00:13:30,880
the real job

317
00:13:30,880 --> 00:13:33,519
the core implementation of this alarm is

318
00:13:33,519 --> 00:13:36,560
only 28 lines including space and

319
00:13:36,560 --> 00:13:38,240
comments

320
00:13:38,240 --> 00:13:40,639
so the first thing is we look at the

321
00:13:40,639 --> 00:13:42,560
direction of the packet we want to make

322
00:13:42,560 --> 00:13:44,160
sure this is packaged from the host

323
00:13:44,160 --> 00:13:46,800
machine to the device

324
00:13:46,800 --> 00:13:48,959
then we want to make sure this packet is

325
00:13:48,959 --> 00:13:51,519
large enough because we want to know it

326
00:13:51,519 --> 00:13:53,279
has to contain some

327
00:13:53,279 --> 00:13:55,760
some skus command inside

328
00:13:55,760 --> 00:13:57,760
and then we want to make sure

329
00:13:57,760 --> 00:14:00,000
this packet has something rather than

330
00:14:00,000 --> 00:14:03,040
just a usb packet header

331
00:14:03,040 --> 00:14:05,440
and then we extract the op code of

332
00:14:05,440 --> 00:14:09,440
discussing command from this usb packet

333
00:14:09,440 --> 00:14:11,760
we look at this op code if this is a

334
00:14:11,760 --> 00:14:14,000
discussion rec command we return one

335
00:14:14,000 --> 00:14:17,839
otherwise we return zero

336
00:14:17,920 --> 00:14:21,199
so in general uh

337
00:14:21,199 --> 00:14:23,040
the usb filter

338
00:14:23,040 --> 00:14:25,760
has changed 27 kernel source files

339
00:14:25,760 --> 00:14:28,560
including four new files and 23 modified

340
00:14:28,560 --> 00:14:33,040
files all the changes are across usb sc

341
00:14:33,040 --> 00:14:36,399
block networking subsystems

342
00:14:36,399 --> 00:14:38,720
we also design and implement a use space

343
00:14:38,720 --> 00:14:41,279
tool called usb tables which has an

344
00:14:41,279 --> 00:14:43,600
internal prolog engine to do root

345
00:14:43,600 --> 00:14:46,800
consistency checking and we provided 20

346
00:14:46,800 --> 00:14:49,600
rule constructions which covers almost

347
00:14:49,600 --> 00:14:51,920
all the useful information which can be

348
00:14:51,920 --> 00:14:54,959
provided by the kernel

349
00:14:55,279 --> 00:14:58,880
so the first case is here to show how we

350
00:14:58,880 --> 00:15:01,760
can stop bad usb attacks using a usb

351
00:15:01,760 --> 00:15:03,120
filter

352
00:15:03,120 --> 00:15:05,680
so one common bad usb attacks is to

353
00:15:05,680 --> 00:15:06,920
allow

354
00:15:06,920 --> 00:15:09,839
non-input devices to type like keyboard

355
00:15:09,839 --> 00:15:11,600
or to move like a mouse

356
00:15:11,600 --> 00:15:14,079
so the first rule we need is basically

357
00:15:14,079 --> 00:15:16,959
to allow our own mouse to move like a

358
00:15:16,959 --> 00:15:18,399
mouse

359
00:15:18,399 --> 00:15:20,079
then we've got a second rule

360
00:15:20,079 --> 00:15:22,639
that means we allow our own keyboard to

361
00:15:22,639 --> 00:15:24,160
type

362
00:15:24,160 --> 00:15:26,399
then the last one is seeing that we will

363
00:15:26,399 --> 00:15:29,360
drop all other

364
00:15:29,360 --> 00:15:32,079
keyboard or mouse package for any other

365
00:15:32,079 --> 00:15:34,638
devices

366
00:15:34,720 --> 00:15:37,519
the second case is to show how we can

367
00:15:37,519 --> 00:15:40,000
pin certain applications to certain usb

368
00:15:40,000 --> 00:15:41,759
device

369
00:15:41,759 --> 00:15:45,120
now the first reason that we allow

370
00:15:45,120 --> 00:15:48,240
application skype to access the web

371
00:15:48,240 --> 00:15:51,440
camera with this serial number is b44

372
00:15:51,440 --> 00:15:53,920
blah blah and the second rule is is

373
00:15:53,920 --> 00:15:56,240
saying we're gonna drop all other

374
00:15:56,240 --> 00:15:59,519
packets for this device so this case is

375
00:15:59,519 --> 00:16:02,639
really useful because we prevent any

376
00:16:02,639 --> 00:16:03,519
other

377
00:16:03,519 --> 00:16:06,160
malicious programs in the user space to

378
00:16:06,160 --> 00:16:11,360
uh from accessing the the usb vap camera

379
00:16:11,839 --> 00:16:13,920
and to stop that exfiltration from the

380
00:16:13,920 --> 00:16:16,639
host machine all we need is essentially

381
00:16:16,639 --> 00:16:19,920
one simple rule so within this rule uh

382
00:16:19,920 --> 00:16:22,480
we are using the alarm we we introduced

383
00:16:22,480 --> 00:16:24,959
before which is able to detect the sc

384
00:16:24,959 --> 00:16:28,160
command within the usb packet

385
00:16:28,160 --> 00:16:30,639
so all we need is this simple rule uh

386
00:16:30,639 --> 00:16:34,880
then we can drop all the usb package

387
00:16:34,880 --> 00:16:37,600
which contains viscosity command and

388
00:16:37,600 --> 00:16:39,920
we're able to make sure no data can be

389
00:16:39,920 --> 00:16:42,880
written into any external usb service

390
00:16:42,880 --> 00:16:44,880
devices

391
00:16:44,880 --> 00:16:47,199
and in this case we show how we can use

392
00:16:47,199 --> 00:16:50,160
uav usb filter to disable certain

393
00:16:50,160 --> 00:16:53,680
functionalities within the usb device so

394
00:16:53,680 --> 00:16:56,720
here we show how we can disable

395
00:16:56,720 --> 00:16:59,360
the microphone functionality within a

396
00:16:59,360 --> 00:17:01,279
usb headset

397
00:17:01,279 --> 00:17:04,160
this case is really useful because in

398
00:17:04,160 --> 00:17:06,959
security sensitive environments

399
00:17:06,959 --> 00:17:08,559
the speak of the microphone

400
00:17:08,559 --> 00:17:10,799
functionality is forbidden so with the

401
00:17:10,799 --> 00:17:14,720
help of this rule users can bring their

402
00:17:14,720 --> 00:17:16,880
own usb headset

403
00:17:16,880 --> 00:17:19,280
and using them without worrying about

404
00:17:19,280 --> 00:17:22,000
breaking the security uh the security

405
00:17:22,000 --> 00:17:24,559
requirement

406
00:17:24,959 --> 00:17:27,839
and then here uh we've got something

407
00:17:27,839 --> 00:17:30,080
much more interesting

408
00:17:30,080 --> 00:17:32,960
so as we know like um the cell phone can

409
00:17:32,960 --> 00:17:34,320
be malicious

410
00:17:34,320 --> 00:17:36,160
so we want to make sure the cell phone

411
00:17:36,160 --> 00:17:37,360
can only

412
00:17:37,360 --> 00:17:38,400
uh

413
00:17:38,400 --> 00:17:40,559
be charged when they are plugged into

414
00:17:40,559 --> 00:17:42,960
our machine so here we show

415
00:17:42,960 --> 00:17:46,400
an example for the nexus 4. so what this

416
00:17:46,400 --> 00:17:49,840
rule says is if this is a nexus 4 cell

417
00:17:49,840 --> 00:17:53,520
phone we would drop any other usb packet

418
00:17:53,520 --> 00:17:54,880
which makes

419
00:17:54,880 --> 00:17:57,840
a perfect charger for nexus 4.

420
00:17:57,840 --> 00:17:59,600
for sure the

421
00:17:59,600 --> 00:18:02,960
nexus 4 can lie about its eye intensity

422
00:18:02,960 --> 00:18:06,080
so thanks to bad usb attacks the nexus 4

423
00:18:06,080 --> 00:18:08,960
can claim itself as an iphone which

424
00:18:08,960 --> 00:18:12,000
makes this useless and then we've got

425
00:18:12,000 --> 00:18:15,280
another rule here so what this rule says

426
00:18:15,280 --> 00:18:16,080
is

427
00:18:16,080 --> 00:18:18,720
no matter what kind of device you are

428
00:18:18,720 --> 00:18:21,679
as long as you plug into that bus number

429
00:18:21,679 --> 00:18:24,320
with that part number we will get a rid

430
00:18:24,320 --> 00:18:27,440
of all the usb traffic so that makes

431
00:18:27,440 --> 00:18:30,320
that port a perfect charger port

432
00:18:30,320 --> 00:18:31,440
so basically

433
00:18:31,440 --> 00:18:35,039
we're safe to charge the cell phone

434
00:18:36,640 --> 00:18:39,679
well to to understand the performance

435
00:18:39,679 --> 00:18:42,799
overhead introduced by usb filter we

436
00:18:42,799 --> 00:18:45,039
conduct a series of

437
00:18:45,039 --> 00:18:47,200
evaluation using

438
00:18:47,200 --> 00:18:49,440
adele machine with a

439
00:18:49,440 --> 00:18:53,360
intel quad-core 3.2 gigahertz cpu and 8

440
00:18:53,360 --> 00:18:57,840
gigabytes memory and and intel usb 2.0

441
00:18:57,840 --> 00:18:59,679
uh host controller

442
00:18:59,679 --> 00:19:03,000
uh running ubuntu

443
00:19:03,000 --> 00:19:08,000
14.04 lts with kernel version 3.13

444
00:19:08,000 --> 00:19:10,799
so uh first we measure the scalability

445
00:19:10,799 --> 00:19:13,600
of usb tables since it uses a prolog

446
00:19:13,600 --> 00:19:15,919
engine to to do the rule consistency

447
00:19:15,919 --> 00:19:18,799
checking so uh

448
00:19:18,799 --> 00:19:22,559
before we add a new rule into the kernel

449
00:19:22,559 --> 00:19:23,840
we measure

450
00:19:23,840 --> 00:19:27,440
the overhead uh of this action when

451
00:19:27,440 --> 00:19:29,840
there are 20 base rules

452
00:19:29,840 --> 00:19:32,720
and 100 base rules

453
00:19:32,720 --> 00:19:33,600
so

454
00:19:33,600 --> 00:19:35,679
it turns out the result is almost the

455
00:19:35,679 --> 00:19:36,559
same

456
00:19:36,559 --> 00:19:39,039
the overhead is 5.9

457
00:19:39,039 --> 00:19:42,000
millisecond this is the result of

458
00:19:42,000 --> 00:19:44,880
compiling prolog into the assembly code

459
00:19:44,880 --> 00:19:46,320
directly

460
00:19:46,320 --> 00:19:48,799
and accordingly we measure the overhead

461
00:19:48,799 --> 00:19:51,760
of package filtering for usb filter when

462
00:19:51,760 --> 00:19:54,480
there are 20 base rules and 100 base

463
00:19:54,480 --> 00:19:56,160
rules in the kernel

464
00:19:56,160 --> 00:19:57,919
as one can see

465
00:19:57,919 --> 00:20:00,559
the overhead of usb filter to do

466
00:20:00,559 --> 00:20:02,799
filtering

467
00:20:02,799 --> 00:20:05,280
is linear to the increasing of the

468
00:20:05,280 --> 00:20:07,440
number of rules

469
00:20:07,440 --> 00:20:09,919
and when there are 20 base rules in the

470
00:20:09,919 --> 00:20:13,280
kernel to filter each usb packet we

471
00:20:13,280 --> 00:20:15,600
probably need 2.6

472
00:20:15,600 --> 00:20:17,760
microseconds

473
00:20:17,760 --> 00:20:20,960
well based on our experience 20 base

474
00:20:20,960 --> 00:20:23,840
rules is fairly good enough to cover

475
00:20:23,840 --> 00:20:24,799
most

476
00:20:24,799 --> 00:20:28,000
common usb devices for example within

477
00:20:28,000 --> 00:20:30,960
these 20 rules we covered

478
00:20:30,960 --> 00:20:34,559
keyboards mouse web cameras wi-fi

479
00:20:34,559 --> 00:20:39,360
adapters flash drives and etc

480
00:20:40,240 --> 00:20:43,919
we then run file bench by operating 20

481
00:20:43,919 --> 00:20:47,039
files with main file size ranging from 1

482
00:20:47,039 --> 00:20:49,039
kilobyte to 100

483
00:20:49,039 --> 00:20:50,480
megabytes

484
00:20:50,480 --> 00:20:51,360
so

485
00:20:51,360 --> 00:20:53,120
as one can see

486
00:20:53,120 --> 00:20:55,360
the throughput of usb

487
00:20:55,360 --> 00:20:57,919
is comparable with the throughput of the

488
00:20:57,919 --> 00:21:00,159
stock kernel

489
00:21:00,159 --> 00:21:02,240
this table shows the corresponding

490
00:21:02,240 --> 00:21:03,520
latency

491
00:21:03,520 --> 00:21:06,640
during the file bench uh benchmarking

492
00:21:06,640 --> 00:21:09,200
and when the main file size is less than

493
00:21:09,200 --> 00:21:11,440
one megabytes

494
00:21:11,440 --> 00:21:14,159
the latency of usb filter is almost

495
00:21:14,159 --> 00:21:17,440
negligible comparing to the stock kernel

496
00:21:17,440 --> 00:21:19,919
but when the file size increase we can

497
00:21:19,919 --> 00:21:22,480
see some latency as well this is

498
00:21:22,480 --> 00:21:25,200
reasonable since usb filter needs to

499
00:21:25,200 --> 00:21:28,159
look into each usb packet and try to

500
00:21:28,159 --> 00:21:31,200
match with one of the 20 rules saved in

501
00:21:31,200 --> 00:21:33,600
the kernel

502
00:21:33,600 --> 00:21:35,600
and then we give a

503
00:21:35,600 --> 00:21:39,039
five times rung for real world

504
00:21:39,039 --> 00:21:42,000
workload including creating and

505
00:21:42,000 --> 00:21:44,960
installing a key vm from a usb

506
00:21:44,960 --> 00:21:46,640
flash drive

507
00:21:46,640 --> 00:21:49,520
running web browser benchmark for chrome

508
00:21:49,520 --> 00:21:53,120
using a usb wi-fi adapter and scanning

509
00:21:53,120 --> 00:21:54,640
virus

510
00:21:54,640 --> 00:21:57,679
within a usb flash drive using clam av

511
00:21:57,679 --> 00:21:59,039
and then we

512
00:21:59,039 --> 00:22:01,840
double get a linux kernel

513
00:22:01,840 --> 00:22:04,080
4.4 zip file

514
00:22:04,080 --> 00:22:06,240
as one can see

515
00:22:06,240 --> 00:22:09,280
basically the performance of usb filter

516
00:22:09,280 --> 00:22:13,840
is comparable with the stock kernel

517
00:22:14,640 --> 00:22:18,320
the ability to correlate the usb packet

518
00:22:18,320 --> 00:22:21,039
with the io operations

519
00:22:21,039 --> 00:22:23,520
of applications within the use space is

520
00:22:23,520 --> 00:22:26,640
vital but sometimes we just cannot have

521
00:22:26,640 --> 00:22:29,360
that information so one example is the

522
00:22:29,360 --> 00:22:31,200
interrupt concept

523
00:22:31,200 --> 00:22:34,480
so for example when a key is pressed on

524
00:22:34,480 --> 00:22:35,679
a keyboard

525
00:22:35,679 --> 00:22:38,400
this corresponding usb packet does does

526
00:22:38,400 --> 00:22:40,720
not have any application to to be

527
00:22:40,720 --> 00:22:43,760
associate associated with since uh the

528
00:22:43,760 --> 00:22:45,600
key stroke happens within the interrupt

529
00:22:45,600 --> 00:22:48,400
concept that means for the keystroke we

530
00:22:48,400 --> 00:22:50,960
probably cannot use process information

531
00:22:50,960 --> 00:22:52,640
to write a rule

532
00:22:52,640 --> 00:22:56,880
and similarly we have instrumented

533
00:22:56,880 --> 00:22:59,840
a bunch of general usb device drivers to

534
00:22:59,840 --> 00:23:03,200
recover the pid information but some for

535
00:23:03,200 --> 00:23:06,880
some usb devices which requires

536
00:23:06,880 --> 00:23:09,760
vendor specific drivers we need to look

537
00:23:09,760 --> 00:23:12,400
into each driver to cover that pid

538
00:23:12,400 --> 00:23:15,120
information if we want to leverage the

539
00:23:15,120 --> 00:23:17,600
pid within the rules

540
00:23:17,600 --> 00:23:19,760
the current implementation of

541
00:23:19,760 --> 00:23:23,280
usb filter is to put itself in the

542
00:23:23,280 --> 00:23:24,880
request pass

543
00:23:24,880 --> 00:23:27,360
during the filtering which is the pass

544
00:23:27,360 --> 00:23:30,080
which is the usb communication pass from

545
00:23:30,080 --> 00:23:32,320
the usb host machine to the device

546
00:23:32,320 --> 00:23:33,280
machine

547
00:23:33,280 --> 00:23:37,360
this works for usb 1.0 and usb 2.0

548
00:23:37,360 --> 00:23:41,279
because basically usb is a master slave

549
00:23:41,279 --> 00:23:45,200
protocol but for usb 3.0 it is possible

550
00:23:45,200 --> 00:23:48,559
for usb devices to initiate the usb

551
00:23:48,559 --> 00:23:51,840
request so we probably need to consider

552
00:23:51,840 --> 00:23:54,480
putting usb filter in the response pass

553
00:23:54,480 --> 00:23:56,880
as well

554
00:23:57,679 --> 00:24:01,200
the general overhead of usb filter to

555
00:24:01,200 --> 00:24:05,440
filter each usb packet is 2.6

556
00:24:05,440 --> 00:24:06,799
microsecond

557
00:24:06,799 --> 00:24:10,400
it is fast for usb 2.0 but it may not be

558
00:24:10,400 --> 00:24:13,520
fast enough for usb 3.0 so in the future

559
00:24:13,520 --> 00:24:15,840
we are thinking about leveraging a

560
00:24:15,840 --> 00:24:18,720
berkeley pack filter to accelerate

561
00:24:18,720 --> 00:24:21,520
the speed of

562
00:24:21,600 --> 00:24:24,880
usb filter for package filtering

563
00:24:24,880 --> 00:24:28,000
and for sure we need more useful lumps

564
00:24:28,000 --> 00:24:30,240
to enable system in to write more

565
00:24:30,240 --> 00:24:32,320
powerful rules

566
00:24:32,320 --> 00:24:35,039
regarding the usability issues

567
00:24:35,039 --> 00:24:38,400
usb filter is targeting administrators

568
00:24:38,400 --> 00:24:40,000
or assistant means

569
00:24:40,000 --> 00:24:42,880
because it is not that easy to write

570
00:24:42,880 --> 00:24:45,039
useful usb filter rules since it

571
00:24:45,039 --> 00:24:47,520
requires some knowledge about usb in

572
00:24:47,520 --> 00:24:51,039
general but we're hoping um the linux

573
00:24:51,039 --> 00:24:53,279
distribution team may be able to provide

574
00:24:53,279 --> 00:24:56,159
some default default rules such as the

575
00:24:56,159 --> 00:25:00,400
linux rules and which can help users to

576
00:25:00,400 --> 00:25:03,600
customize these rules based on their own

577
00:25:03,600 --> 00:25:06,559
working environments

578
00:25:06,799 --> 00:25:09,440
so in this talk we have seen

579
00:25:09,440 --> 00:25:12,320
why usb was great

580
00:25:12,320 --> 00:25:15,679
why it is not great and then we design

581
00:25:15,679 --> 00:25:17,200
and implemented

582
00:25:17,200 --> 00:25:20,480
usb filter which is essentially a usb

583
00:25:20,480 --> 00:25:22,880
layer firewall within the kernel we

584
00:25:22,880 --> 00:25:25,039
provide the corresponding user space

585
00:25:25,039 --> 00:25:27,360
tool which is called usb tables

586
00:25:27,360 --> 00:25:30,000
it has a prolog engine and it is used to

587
00:25:30,000 --> 00:25:33,279
manage all the tools from the user space

588
00:25:33,279 --> 00:25:36,640
so with usb filter we're able to defend

589
00:25:36,640 --> 00:25:39,440
against any bad usb attacks we're able

590
00:25:39,440 --> 00:25:41,440
to limit the behaviors of

591
00:25:41,440 --> 00:25:45,200
usb device by only introducing a minimum

592
00:25:45,200 --> 00:25:46,400
overhead

593
00:25:46,400 --> 00:25:48,159
so please

594
00:25:48,159 --> 00:25:51,039
go to this website download it and have

595
00:25:51,039 --> 00:25:52,000
a try

596
00:25:52,000 --> 00:25:55,279
and hopefully with usb filter we can

597
00:25:55,279 --> 00:25:58,160
make usb great again thank you

598
00:25:58,160 --> 00:25:59,360
[Applause]

599
00:25:59,360 --> 00:26:00,210
[Music]

600
00:26:00,210 --> 00:26:06,720
[Applause]

601
00:26:06,720 --> 00:26:07,919
thanks dave

602
00:26:07,919 --> 00:26:10,240
we're still running ahead so please step

603
00:26:10,240 --> 00:26:11,919
up to the mic and ask

604
00:26:11,919 --> 00:26:14,880
interesting or difficult questions

605
00:26:14,880 --> 00:26:15,919
to dave

606
00:26:15,919 --> 00:26:17,600
otherwise i'll have to ask shallow

607
00:26:17,600 --> 00:26:20,879
questions for for 10 minutes

608
00:26:22,880 --> 00:26:24,720
hi cynthia irvin

609
00:26:24,720 --> 00:26:25,679
um

610
00:26:25,679 --> 00:26:27,919
when you were looking at your rules and

611
00:26:27,919 --> 00:26:30,320
uh doing your verification

612
00:26:30,320 --> 00:26:33,120
uh did you look at any formal safety

613
00:26:33,120 --> 00:26:34,559
properties that you were trying to

614
00:26:34,559 --> 00:26:35,919
enforce

615
00:26:35,919 --> 00:26:38,559
um since we're not focusing on the

616
00:26:38,559 --> 00:26:40,960
implementation side we just look for the

617
00:26:40,960 --> 00:26:43,440
rule consistency checking so we just

618
00:26:43,440 --> 00:26:46,000
want to make sure each rule

619
00:26:46,000 --> 00:26:48,080
if you allow me to come back to the real

620
00:26:48,080 --> 00:26:51,080
thing

621
00:26:52,080 --> 00:26:54,799
right so we just want to make sure each

622
00:26:54,799 --> 00:26:57,600
rule does not have any conflict with

623
00:26:57,600 --> 00:26:59,840
existing rules before it is added into

624
00:26:59,840 --> 00:27:02,320
the kernel

625
00:27:03,039 --> 00:27:04,159
okay

626
00:27:04,159 --> 00:27:06,960
so um

627
00:27:06,960 --> 00:27:08,960
then essentially

628
00:27:08,960 --> 00:27:12,320
your rule set could potentially

629
00:27:12,320 --> 00:27:14,559
leak

630
00:27:14,559 --> 00:27:16,400
correct

631
00:27:16,400 --> 00:27:18,880
i'm sorry i don't get well

632
00:27:18,880 --> 00:27:22,159
you you have a situation where you

633
00:27:22,159 --> 00:27:23,760
you're showing that your rules are

634
00:27:23,760 --> 00:27:25,840
self-consistent but not with respect to

635
00:27:25,840 --> 00:27:28,559
some security property that you're um

636
00:27:28,559 --> 00:27:30,960
attempting to enforce

637
00:27:30,960 --> 00:27:34,840
correct all right

638
00:27:36,799 --> 00:27:39,440
uh okay i one one thing i wondered about

639
00:27:39,440 --> 00:27:41,440
is in your rules you need to

640
00:27:41,440 --> 00:27:44,240
actually name the um you have to provide

641
00:27:44,240 --> 00:27:46,320
a lot of information in your right right

642
00:27:46,320 --> 00:27:49,279
for usb tables so if you've never used a

643
00:27:49,279 --> 00:27:52,080
device before and it could be dangerous

644
00:27:52,080 --> 00:27:53,840
how are you going to come up with that

645
00:27:53,840 --> 00:27:55,679
some of that information

646
00:27:55,679 --> 00:27:58,640
well um basically

647
00:27:58,640 --> 00:28:01,360
so let's come back to the rules

648
00:28:01,360 --> 00:28:03,600
yeah

649
00:28:03,600 --> 00:28:06,399
so i think the usb charger rule is an

650
00:28:06,399 --> 00:28:08,720
example here if we're not able to

651
00:28:08,720 --> 00:28:10,799
leverage any information or we do not

652
00:28:10,799 --> 00:28:12,799
know any information about this device

653
00:28:12,799 --> 00:28:15,440
all we can do is to leverage the

654
00:28:15,440 --> 00:28:18,240
physical information about the port like

655
00:28:18,240 --> 00:28:20,720
where the device is plugged into

656
00:28:20,720 --> 00:28:22,720
and then we can write some rules like

657
00:28:22,720 --> 00:28:24,960
for any phone so as long as the device

658
00:28:24,960 --> 00:28:27,200
is plugged into this port

659
00:28:27,200 --> 00:28:30,159
we would do something so basically by

660
00:28:30,159 --> 00:28:31,919
leveraging the physical information of

661
00:28:31,919 --> 00:28:35,120
the usb port we physically partition all

662
00:28:35,120 --> 00:28:38,159
the usb ports and do some

663
00:28:38,159 --> 00:28:40,000
traffic through there and so the then

664
00:28:40,000 --> 00:28:41,760
there i assume there's some form of

665
00:28:41,760 --> 00:28:43,600
logging i guess actually you would be

666
00:28:43,600 --> 00:28:44,880
able to see

667
00:28:44,880 --> 00:28:45,919
um

668
00:28:45,919 --> 00:28:48,000
look at your k messages and see what the

669
00:28:48,000 --> 00:28:50,159
device looked like and right

670
00:28:50,159 --> 00:28:52,399
from there okay we can't do that as well

671
00:28:52,399 --> 00:28:56,600
okay thank you thank you

672
00:28:59,039 --> 00:29:00,480
nice talk thank you

673
00:29:00,480 --> 00:29:02,880
uh one question

674
00:29:02,880 --> 00:29:04,880
so in your usability you mentioned the

675
00:29:04,880 --> 00:29:08,159
usability point uh and targeting system

676
00:29:08,159 --> 00:29:11,200
administrators right uh i was wondering

677
00:29:11,200 --> 00:29:13,279
uh whether you had any experience doing

678
00:29:13,279 --> 00:29:14,960
any study about

679
00:29:14,960 --> 00:29:15,760
uh

680
00:29:15,760 --> 00:29:19,440
mapping the physical usb ports to the

681
00:29:19,440 --> 00:29:22,640
actual logical bus and uh port numbers

682
00:29:22,640 --> 00:29:24,240
so what i'm trying to say here is for

683
00:29:24,240 --> 00:29:27,760
example my laptop has six usb ports and

684
00:29:27,760 --> 00:29:28,799
three

685
00:29:28,799 --> 00:29:31,440
eaci controllers and depending on where

686
00:29:31,440 --> 00:29:34,240
i plug my device it has a unique bus and

687
00:29:34,240 --> 00:29:35,440
port number

688
00:29:35,440 --> 00:29:37,200
so i'm wondering if you write a rule

689
00:29:37,200 --> 00:29:40,000
which you specify a bus and port number

690
00:29:40,000 --> 00:29:40,880
uh

691
00:29:40,880 --> 00:29:42,880
is the user going to have to plug that

692
00:29:42,880 --> 00:29:44,399
you know particular device on that

693
00:29:44,399 --> 00:29:47,039
physical port always how's that

694
00:29:47,039 --> 00:29:48,480
have we done some you know study on

695
00:29:48,480 --> 00:29:50,799
making sure that the administrator knows

696
00:29:50,799 --> 00:29:52,640
exactly to plug the device there and not

697
00:29:52,640 --> 00:29:54,559
anywhere else well this is a great

698
00:29:54,559 --> 00:29:57,520
question um because like there's no ex

699
00:29:57,520 --> 00:30:00,000
explicit mapping between the physical

700
00:30:00,000 --> 00:30:02,480
port number and the the virtual or the

701
00:30:02,480 --> 00:30:04,880
logical port number right so we need to

702
00:30:04,880 --> 00:30:07,120
plug in the device to know like okay

703
00:30:07,120 --> 00:30:10,240
this physical port has the port number x

704
00:30:10,240 --> 00:30:11,600
so there is an enumeration sort of

705
00:30:11,600 --> 00:30:13,360
phrase that you right we need to know

706
00:30:13,360 --> 00:30:15,279
that information okay so how does that

707
00:30:15,279 --> 00:30:17,120
do you basically plug in devices on

708
00:30:17,120 --> 00:30:18,480
every physical port and you sort of

709
00:30:18,480 --> 00:30:20,799
educate the right data because basically

710
00:30:20,799 --> 00:30:22,880
this is one time effort right you can

711
00:30:22,880 --> 00:30:25,279
use one trusted device to try all the

712
00:30:25,279 --> 00:30:27,279
ports then you have all the information

713
00:30:27,279 --> 00:30:29,600
then you know how these physical ports

714
00:30:29,600 --> 00:30:32,000
are mapped into the logic port number

715
00:30:32,000 --> 00:30:33,840
then you can write wouldn't it be

716
00:30:33,840 --> 00:30:36,000
wonderful if usb controllers had a

717
00:30:36,000 --> 00:30:37,520
method by which you could actually

718
00:30:37,520 --> 00:30:39,600
program it to say glow a particular

719
00:30:39,600 --> 00:30:41,360
number on each of the ports so that it

720
00:30:41,360 --> 00:30:43,840
enables people to that is fantastic but

721
00:30:43,840 --> 00:30:45,679
but yeah well that's the ideal world

722
00:30:45,679 --> 00:30:47,440
let's hope for it thanks man that's a

723
00:30:47,440 --> 00:30:50,760
great idea

724
00:30:53,279 --> 00:30:55,520
if there are no more questions we're

725
00:30:55,520 --> 00:30:57,919
almost caught up but i have a single one

726
00:30:57,919 --> 00:30:59,840
i know the linux kernel is run by

727
00:30:59,840 --> 00:31:02,159
project people with strong opinions but

728
00:31:02,159 --> 00:31:03,679
right what you think would happen if you

729
00:31:03,679 --> 00:31:05,600
were to offer this to them uh for up

730
00:31:05,600 --> 00:31:06,960
streaming

731
00:31:06,960 --> 00:31:10,080
well um actually if we want to upstream

732
00:31:10,080 --> 00:31:12,880
this thing uh it has at least well we

733
00:31:12,880 --> 00:31:15,279
have at least to do two things so first

734
00:31:15,279 --> 00:31:16,559
um

735
00:31:16,559 --> 00:31:21,039
as you can see from this architecture

736
00:31:21,440 --> 00:31:22,559
figure

737
00:31:22,559 --> 00:31:26,559
we introduced a new now link socket

738
00:31:26,559 --> 00:31:28,640
and most kernel developer would object

739
00:31:28,640 --> 00:31:30,880
this idea because just like when

740
00:31:30,880 --> 00:31:33,279
everyone wants to introduce a new cisco

741
00:31:33,279 --> 00:31:34,880
people would say no

742
00:31:34,880 --> 00:31:37,120
so we need to find a way to leverage the

743
00:31:37,120 --> 00:31:38,720
existing modeling socket to do the

744
00:31:38,720 --> 00:31:41,600
communication and another thing is

745
00:31:41,600 --> 00:31:43,760
i mentioned within

746
00:31:43,760 --> 00:31:45,519
the future works

747
00:31:45,519 --> 00:31:47,919
the current performance is maybe not

748
00:31:47,919 --> 00:31:51,279
good for usb 3.0 and we need to

749
00:31:51,279 --> 00:31:53,679
leverage the bpf to accelerate the

750
00:31:53,679 --> 00:31:55,519
performance

751
00:31:55,519 --> 00:31:57,279
similar case happens within the kernel

752
00:31:57,279 --> 00:31:59,360
development

753
00:31:59,360 --> 00:32:02,159
for example the scam secure com secure

754
00:32:02,159 --> 00:32:05,360
computing which is a cisco filter uh it

755
00:32:05,360 --> 00:32:07,360
has been proposed like

756
00:32:07,360 --> 00:32:10,799
uh 10 or 20 years ago but no one cares

757
00:32:10,799 --> 00:32:14,240
until recently a google developer has

758
00:32:14,240 --> 00:32:15,840
refactored the whole implementation

759
00:32:15,840 --> 00:32:18,480
using bpf and now it is in the kernel

760
00:32:18,480 --> 00:32:20,960
and is a great component for the linux

761
00:32:20,960 --> 00:32:22,720
links container

762
00:32:22,720 --> 00:32:24,240
thank you thank you

763
00:32:24,240 --> 00:32:25,600
so one more question i'm back again just

764
00:32:25,600 --> 00:32:27,039
a quick question

765
00:32:27,039 --> 00:32:29,039
you had mentioned that uh

766
00:32:29,039 --> 00:32:30,880
you know verifiability as one of your

767
00:32:30,880 --> 00:32:32,080
sort of goals

768
00:32:32,080 --> 00:32:34,000
uh i was wondering is your

769
00:32:34,000 --> 00:32:37,200
implementation in in c i'm assuming yes

770
00:32:37,200 --> 00:32:38,799
uh you had mentioned you were you had

771
00:32:38,799 --> 00:32:40,960
touched four new files and touched 23

772
00:32:40,960 --> 00:32:42,880
odd inner kernels i was just wondering

773
00:32:42,880 --> 00:32:45,360
do you have any metrics on the actual

774
00:32:45,360 --> 00:32:47,519
number of source lines that you have in

775
00:32:47,519 --> 00:32:49,679
your implementation and how you've

776
00:32:49,679 --> 00:32:51,519
how do you think it's sort of conducive

777
00:32:51,519 --> 00:32:54,240
towards uh you know actual you know

778
00:32:54,240 --> 00:32:56,080
source code level of verification to

779
00:32:56,080 --> 00:32:58,080
establish your properties

780
00:32:58,080 --> 00:32:59,200
uh

781
00:32:59,200 --> 00:33:01,039
like a normal developer we do not

782
00:33:01,039 --> 00:33:02,799
provide useful documentation for the

783
00:33:02,799 --> 00:33:04,399
changes

784
00:33:04,399 --> 00:33:06,000
sorry about that man

785
00:33:06,000 --> 00:33:08,080
uh but but i'm i'm assuming i have

786
00:33:08,080 --> 00:33:09,919
access to your github right right you

787
00:33:09,919 --> 00:33:11,279
can look into the current appreciate

788
00:33:11,279 --> 00:33:13,840
let's give dave a big round of applause

789
00:33:13,840 --> 00:33:18,279
for the talk and also for the

