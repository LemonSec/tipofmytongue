1
00:00:12,320 --> 00:00:15,320
okay

2
00:00:16,720 --> 00:00:18,480
the general topic of my presentation

3
00:00:18,480 --> 00:00:20,480
will be using just in time compilers in

4
00:00:20,480 --> 00:00:23,039
modern browsers to inject arbitrary code

5
00:00:23,039 --> 00:00:24,160
fragments

6
00:00:24,160 --> 00:00:27,039
uh on the fly for later using it for

7
00:00:27,039 --> 00:00:28,720
codereuse attacks

8
00:00:28,720 --> 00:00:31,840
more specifically

9
00:00:33,440 --> 00:00:36,160
so just in time compiler is a process of

10
00:00:36,160 --> 00:00:38,079
creating native code out of a higher

11
00:00:38,079 --> 00:00:39,840
level language that is javascript in our

12
00:00:39,840 --> 00:00:42,719
case jet compiler is using by all modern

13
00:00:42,719 --> 00:00:46,000
browsers to improve the performance of

14
00:00:46,000 --> 00:00:47,680
javascript code

15
00:00:47,680 --> 00:00:50,160
however jit compilation also creates

16
00:00:50,160 --> 00:00:51,520
some

17
00:00:51,520 --> 00:00:54,559
security threads for browsers namely

18
00:00:54,559 --> 00:00:56,239
git compilers

19
00:00:56,239 --> 00:00:58,480
must make sure that no attacker control

20
00:00:58,480 --> 00:01:00,879
data from the javascript can end up in

21
00:01:00,879 --> 00:01:03,120
the native code after compilation

22
00:01:03,120 --> 00:01:05,600
there have been already several

23
00:01:05,600 --> 00:01:08,560
attack techniques that illustrated how

24
00:01:08,560 --> 00:01:10,080
this can be done

25
00:01:10,080 --> 00:01:11,200
however

26
00:01:11,200 --> 00:01:13,439
modern browsers already defend against

27
00:01:13,439 --> 00:01:15,360
this type of attacks in this

28
00:01:15,360 --> 00:01:17,600
presentation i will show yet another way

29
00:01:17,600 --> 00:01:19,680
how we are able to emit arbitrary three

30
00:01:19,680 --> 00:01:22,400
byte gadgets

31
00:01:22,400 --> 00:01:24,640
and also we will consider modern defense

32
00:01:24,640 --> 00:01:26,560
code rules defenses such as non-readable

33
00:01:26,560 --> 00:01:29,360
code to do so

34
00:01:29,360 --> 00:01:31,119
in the end i will also introduce defense

35
00:01:31,119 --> 00:01:33,360
techniques that will help g-com

36
00:01:33,360 --> 00:01:35,920
compilers to defend against our proposed

37
00:01:35,920 --> 00:01:37,920
technique

38
00:01:37,920 --> 00:01:40,079
so before i go into details i will

39
00:01:40,079 --> 00:01:41,520
quickly overview

40
00:01:41,520 --> 00:01:43,920
uh code reduce attacks

41
00:01:43,920 --> 00:01:46,960
the basic code reuse attack

42
00:01:46,960 --> 00:01:49,920
as name suggests attacker reuses already

43
00:01:49,920 --> 00:01:51,600
existing code from

44
00:01:51,600 --> 00:01:54,560
executable and imported libraries

45
00:01:54,560 --> 00:01:56,240
for example in the following setup of

46
00:01:56,240 --> 00:01:57,520
the memory

47
00:01:57,520 --> 00:01:59,439
attacker first identifies all the

48
00:01:59,439 --> 00:02:01,600
gadgets that he and function pointer

49
00:02:01,600 --> 00:02:04,560
that he needs for code reuse attack

50
00:02:04,560 --> 00:02:06,479
gadgets are small sequence of assembly

51
00:02:06,479 --> 00:02:08,959
instructions usually and

52
00:02:08,959 --> 00:02:10,639
ending with the return instruction

53
00:02:10,639 --> 00:02:12,720
return instruction helps attacker to

54
00:02:12,720 --> 00:02:15,760
chain multiple of these gadgets together

55
00:02:15,760 --> 00:02:17,280
having all these gadgets the attackers

56
00:02:17,280 --> 00:02:19,360
and override the stack to chain multiple

57
00:02:19,360 --> 00:02:21,840
gadgets together and also provide

58
00:02:21,840 --> 00:02:24,480
parameters for gadgets and functions

59
00:02:24,480 --> 00:02:26,400
and finally divert the control flow to

60
00:02:26,400 --> 00:02:29,200
the first gadget of the gadget chain

61
00:02:29,200 --> 00:02:32,399
triggering the execution

62
00:02:33,360 --> 00:02:35,440
so basic assumption of

63
00:02:35,440 --> 00:02:37,280
basic coder user

64
00:02:37,280 --> 00:02:39,200
attack is that attacker must know the

65
00:02:39,200 --> 00:02:41,519
addresses of these gadgets in advance

66
00:02:41,519 --> 00:02:43,920
the most widely used defense technique

67
00:02:43,920 --> 00:02:46,160
against basic coder user is

68
00:02:46,160 --> 00:02:49,840
address-based layout randomization

69
00:02:49,840 --> 00:02:52,800
or simply slr slr randomizes the base

70
00:02:52,800 --> 00:02:56,400
addresses of the code and by doing so

71
00:02:56,400 --> 00:02:58,080
for which the attacker to know the

72
00:02:58,080 --> 00:03:00,319
addresses of the gadget scene at once

73
00:03:00,319 --> 00:03:03,280
however aslr has major limitation namely

74
00:03:03,280 --> 00:03:05,599
that leaking given a single pointer from

75
00:03:05,599 --> 00:03:07,920
the code reveals all the information and

76
00:03:07,920 --> 00:03:10,720
addresses from the neighboring gadgets

77
00:03:10,720 --> 00:03:12,959
this has been fixed by introducing

78
00:03:12,959 --> 00:03:14,959
fine-grained code randomization which

79
00:03:14,959 --> 00:03:16,879
randomizes the code inside memory

80
00:03:16,879 --> 00:03:20,239
segments thus attacker cannot know

81
00:03:20,239 --> 00:03:23,040
by leaking a pointer cannot know

82
00:03:23,040 --> 00:03:27,040
information about neighboring segments

83
00:03:27,040 --> 00:03:28,799
however all fine-grained code

84
00:03:28,799 --> 00:03:31,200
randomization have been shown to be

85
00:03:31,200 --> 00:03:33,040
ineffective against dynamic coder use

86
00:03:33,040 --> 00:03:36,319
attack for example in gtro attacker uses

87
00:03:36,319 --> 00:03:38,560
memory disclosure vulnerability multiple

88
00:03:38,560 --> 00:03:40,799
times from javascript

89
00:03:40,799 --> 00:03:43,760
to acquire arbitrary memory rates

90
00:03:43,760 --> 00:03:45,840
having arbitrary memory reads that occur

91
00:03:45,840 --> 00:03:48,080
then does pointer chasing to leak as

92
00:03:48,080 --> 00:03:50,000
many code pointers as possible

93
00:03:50,000 --> 00:03:52,560
and then follow these code pointers to

94
00:03:52,560 --> 00:03:55,120
read code pages and find gadgets and

95
00:03:55,120 --> 00:03:58,480
function pointers on the fly

96
00:03:59,439 --> 00:04:00,640
having

97
00:04:00,640 --> 00:04:02,080
all the gadgets ready the enter

98
00:04:02,080 --> 00:04:04,159
attackers then change them together

99
00:04:04,159 --> 00:04:06,799
and divert the control flow to trigger

100
00:04:06,799 --> 00:04:10,480
execution of the gadget chain

101
00:04:10,720 --> 00:04:12,400
the main strength of g trope is that

102
00:04:12,400 --> 00:04:13,680
attacker

103
00:04:13,680 --> 00:04:14,879
can

104
00:04:14,879 --> 00:04:16,160
leak

105
00:04:16,160 --> 00:04:17,680
addresses of the gadgets and function

106
00:04:17,680 --> 00:04:19,279
pointers after they have been already

107
00:04:19,279 --> 00:04:20,560
randomized

108
00:04:20,560 --> 00:04:22,639
to fix this issue several researchers

109
00:04:22,639 --> 00:04:25,040
propose similar defense techniques which

110
00:04:25,040 --> 00:04:26,960
deal with this problem

111
00:04:26,960 --> 00:04:28,800
i will call this new class of defense

112
00:04:28,800 --> 00:04:31,759
xnr as in executable and non-readable

113
00:04:31,759 --> 00:04:34,720
and also his name suggests xnr the main

114
00:04:34,720 --> 00:04:36,400
principle behind dictionary is to mark

115
00:04:36,400 --> 00:04:38,320
what pages are non-readable

116
00:04:38,320 --> 00:04:40,960
and also to forbid attacker to guess or

117
00:04:40,960 --> 00:04:43,759
compute the addresses of gadgets xnr

118
00:04:43,759 --> 00:04:45,919
further randomizes the code and also

119
00:04:45,919 --> 00:04:48,479
hides code pointers

120
00:04:48,479 --> 00:04:50,639
by doing so xanar successfully defends

121
00:04:50,639 --> 00:04:52,000
against jitrop

122
00:04:52,000 --> 00:04:54,080
and by forbidding the attacker to

123
00:04:54,080 --> 00:04:56,160
execute the first tab of the jit rope

124
00:04:56,160 --> 00:04:58,960
that is finding the gadgets

125
00:04:58,960 --> 00:05:00,639
however

126
00:05:00,639 --> 00:05:02,960
is reading the code necessary for

127
00:05:02,960 --> 00:05:06,400
successful code use attacks

128
00:05:06,400 --> 00:05:08,560
as it seems and as it was demonstrated

129
00:05:08,560 --> 00:05:11,039
by jit spraying it's not necessary for

130
00:05:11,039 --> 00:05:13,280
example in jit spring attacker uses

131
00:05:13,280 --> 00:05:15,199
predictable code output of javascript

132
00:05:15,199 --> 00:05:16,720
compilers

133
00:05:16,720 --> 00:05:18,320
and

134
00:05:18,320 --> 00:05:20,479
sprays its own code in the executable

135
00:05:20,479 --> 00:05:22,479
portions of the memory for example as it

136
00:05:22,479 --> 00:05:24,880
is shown on the figure

137
00:05:24,880 --> 00:05:27,600
attacker can create a huge javascript

138
00:05:27,600 --> 00:05:29,680
function which contains lots of integer

139
00:05:29,680 --> 00:05:31,919
constants after compilation these

140
00:05:31,919 --> 00:05:34,320
integer constants will end up as part of

141
00:05:34,320 --> 00:05:36,320
assembly instructions namely emitted

142
00:05:36,320 --> 00:05:38,479
fields of assembly instructions and

143
00:05:38,479 --> 00:05:40,720
diverting the control flow to any of

144
00:05:40,720 --> 00:05:43,360
these constants will execute arbitrary

145
00:05:43,360 --> 00:05:46,160
code that attacker puts here for example

146
00:05:46,160 --> 00:05:47,759
in our example

147
00:05:47,759 --> 00:05:48,639
this

148
00:05:48,639 --> 00:05:51,440
spread code is an op sled which is a

149
00:05:51,440 --> 00:05:53,440
long sequence of knob instructions

150
00:05:53,440 --> 00:05:55,680
usually followed by shell code creating

151
00:05:55,680 --> 00:05:58,400
large enough knob sled will help

152
00:05:58,400 --> 00:05:59,919
attacker to

153
00:05:59,919 --> 00:06:00,880
guess

154
00:06:00,880 --> 00:06:03,600
code pages more easily

155
00:06:03,600 --> 00:06:05,360
however this spraying attack doesn't

156
00:06:05,360 --> 00:06:07,759
work anymore in modern browsers because

157
00:06:07,759 --> 00:06:11,039
they employ a few defense techniques for

158
00:06:11,039 --> 00:06:13,840
example internet explorer and chrome use

159
00:06:13,840 --> 00:06:16,639
constant blinding that is instead of

160
00:06:16,639 --> 00:06:18,240
for example if

161
00:06:18,240 --> 00:06:19,120
in

162
00:06:19,120 --> 00:06:22,000
in our example this integer constant is

163
00:06:22,000 --> 00:06:23,840
controlled by the attacker instead of

164
00:06:23,840 --> 00:06:25,919
directly moving it to the target

165
00:06:25,919 --> 00:06:27,680
register it

166
00:06:27,680 --> 00:06:30,479
first moves integer constant xor with a

167
00:06:30,479 --> 00:06:32,479
random key to the register and then to

168
00:06:32,479 --> 00:06:34,880
restore the original value it emits

169
00:06:34,880 --> 00:06:37,759
another xor instruction

170
00:06:37,759 --> 00:06:39,440
therefore target register is set to the

171
00:06:39,440 --> 00:06:41,280
correct value but attacker doesn't have

172
00:06:41,280 --> 00:06:43,199
the ability to

173
00:06:43,199 --> 00:06:45,759
spray the code by providing integer

174
00:06:45,759 --> 00:06:47,360
constants

175
00:06:47,360 --> 00:06:49,280
another defense technique that is used

176
00:06:49,280 --> 00:06:51,520
by internet internet explorer only is

177
00:06:51,520 --> 00:06:53,680
knop insertion and it further

178
00:06:53,680 --> 00:06:56,080
diversifies the code

179
00:06:56,080 --> 00:06:58,319
uh we will later see this implication of

180
00:06:58,319 --> 00:07:00,560
our in our

181
00:07:00,560 --> 00:07:03,280
attack technique

182
00:07:03,280 --> 00:07:05,360
however there is a limitation in

183
00:07:05,360 --> 00:07:07,520
constant blinding that is because of

184
00:07:07,520 --> 00:07:09,840
performance reasons only constants that

185
00:07:09,840 --> 00:07:11,199
are larger than the two bytes are

186
00:07:11,199 --> 00:07:14,080
diversified are blinded

187
00:07:14,080 --> 00:07:16,240
this limitation was used by the authors

188
00:07:16,240 --> 00:07:18,720
or also authors of the papers they

189
00:07:18,720 --> 00:07:20,240
released in the constants

190
00:07:20,240 --> 00:07:23,039
in this paper authors realize that it's

191
00:07:23,039 --> 00:07:25,039
not necessary to encode return

192
00:07:25,039 --> 00:07:27,199
instruction as part of their integer

193
00:07:27,199 --> 00:07:28,880
constant

194
00:07:28,880 --> 00:07:31,520
instead what i did was

195
00:07:31,520 --> 00:07:34,720
encode the required two byte instruction

196
00:07:34,720 --> 00:07:37,360
sequence as part of return statement in

197
00:07:37,360 --> 00:07:38,880
javascript

198
00:07:38,880 --> 00:07:41,039
and then diverting the control flow to

199
00:07:41,039 --> 00:07:43,039
this two byte constant

200
00:07:43,039 --> 00:07:45,520
will execute the required instruction

201
00:07:45,520 --> 00:07:47,599
and after following the regular control

202
00:07:47,599 --> 00:07:50,319
flow then epilogue would be executing

203
00:07:50,319 --> 00:07:53,680
executed and final return instruction

204
00:07:53,680 --> 00:07:55,919
and if epilogue doesn't break the

205
00:07:55,919 --> 00:07:59,120
execution as it was the case in firefox

206
00:07:59,120 --> 00:08:01,520
and internet explorer the attacker gets

207
00:08:01,520 --> 00:08:04,160
arbitrary two byte length

208
00:08:04,160 --> 00:08:05,680
gadgets

209
00:08:05,680 --> 00:08:08,319
excluding the return instruction

210
00:08:08,319 --> 00:08:10,240
however there are few limitations with

211
00:08:10,240 --> 00:08:13,360
this technique first that it requires

212
00:08:13,360 --> 00:08:17,120
readable code and we can it's not usable

213
00:08:17,120 --> 00:08:19,039
in our context when we assume mixer

214
00:08:19,039 --> 00:08:21,120
defenses that is called segments of the

215
00:08:21,120 --> 00:08:22,960
memory are not readable another

216
00:08:22,960 --> 00:08:24,639
limitation is aligned return

217
00:08:24,639 --> 00:08:26,479
instructions in this attack attackers

218
00:08:26,479 --> 00:08:27,599
use

219
00:08:27,599 --> 00:08:29,680
aligned return instructions therefore if

220
00:08:29,680 --> 00:08:31,280
there is some control flow integrity

221
00:08:31,280 --> 00:08:32,719
checks between

222
00:08:32,719 --> 00:08:35,519
two byte gadget and return instruction

223
00:08:35,519 --> 00:08:39,279
this attack technique will fail

224
00:08:39,279 --> 00:08:41,039
in the second part of this presentation

225
00:08:41,039 --> 00:08:43,679
i will now introduce how attacker is

226
00:08:43,679 --> 00:08:46,160
able to emit three bad gadgets

227
00:08:46,160 --> 00:08:48,240
and in this attack technique i will

228
00:08:48,240 --> 00:08:51,200
assume that xnr code uh xnr is applied

229
00:08:51,200 --> 00:08:53,040
to the code sections of the memories

230
00:08:53,040 --> 00:08:55,120
therefore we cannot read it and as a

231
00:08:55,120 --> 00:08:57,440
threat model i will assume that

232
00:08:57,440 --> 00:09:00,959
we have arbitrary memory lead

233
00:09:00,959 --> 00:09:02,640
so all previous

234
00:09:02,640 --> 00:09:04,480
attack techniques concentrated on

235
00:09:04,480 --> 00:09:06,240
emitted fields to inject arbitrary

236
00:09:06,240 --> 00:09:08,959
values in jit compiled code

237
00:09:08,959 --> 00:09:10,880
consequently constant blinding is also

238
00:09:10,880 --> 00:09:13,600
applied only on emitted values however

239
00:09:13,600 --> 00:09:15,680
in our work we will focus more on the

240
00:09:15,680 --> 00:09:17,760
displacement field

241
00:09:17,760 --> 00:09:20,480
displacement field in x86 instruction is

242
00:09:20,480 --> 00:09:22,640
used in address computation and stores

243
00:09:22,640 --> 00:09:24,480
an offset from some base address

244
00:09:24,480 --> 00:09:25,839
register

245
00:09:25,839 --> 00:09:28,240
some types of

246
00:09:28,240 --> 00:09:30,800
displacement fields in x86 instructions

247
00:09:30,800 --> 00:09:31,600
are

248
00:09:31,600 --> 00:09:33,120
instruction successive memory and

249
00:09:33,120 --> 00:09:35,040
control flow instructions

250
00:09:35,040 --> 00:09:36,560
we will be using control flow

251
00:09:36,560 --> 00:09:40,479
instructions in our technique

252
00:09:40,720 --> 00:09:42,399
control examples of control phone

253
00:09:42,399 --> 00:09:44,640
instructions are conditional jumps and

254
00:09:44,640 --> 00:09:46,800
direct calls

255
00:09:46,800 --> 00:09:49,600
first we start with easier case that is

256
00:09:49,600 --> 00:09:51,519
conditional jumps to emit attacker

257
00:09:51,519 --> 00:09:54,320
controlled values

258
00:09:56,480 --> 00:09:59,120
the simplest case to get

259
00:09:59,120 --> 00:10:01,040
conditional jump after jit compilation

260
00:10:01,040 --> 00:10:03,600
is to use javascript if statement for

261
00:10:03,600 --> 00:10:06,000
example as it is shown in the figure if

262
00:10:06,000 --> 00:10:08,399
we have the following if statement in

263
00:10:08,399 --> 00:10:10,160
javascript after compilation it will

264
00:10:10,160 --> 00:10:12,640
give the conditional jump

265
00:10:12,640 --> 00:10:14,720
depending on the condition if condition

266
00:10:14,720 --> 00:10:17,200
of the conditional jump is true it will

267
00:10:17,200 --> 00:10:19,519
jump over the body of compile if

268
00:10:19,519 --> 00:10:20,720
statement

269
00:10:20,720 --> 00:10:22,560
this means attacker can change the value

270
00:10:22,560 --> 00:10:24,720
encoded in displacement field by varying

271
00:10:24,720 --> 00:10:26,160
the size of

272
00:10:26,160 --> 00:10:28,480
post compiled size of

273
00:10:28,480 --> 00:10:32,200
if statements body

274
00:10:33,600 --> 00:10:34,560
and

275
00:10:34,560 --> 00:10:36,399
what makes it easy for the attacker to

276
00:10:36,399 --> 00:10:39,120
change precisely change the size of

277
00:10:39,120 --> 00:10:41,440
post compiled if statements body is that

278
00:10:41,440 --> 00:10:43,600
in jit compilers all javascript

279
00:10:43,600 --> 00:10:45,920
statements have predetermined size

280
00:10:45,920 --> 00:10:48,000
sequence of assembly instruction in

281
00:10:48,000 --> 00:10:49,920
which they are compiled therefore

282
00:10:49,920 --> 00:10:52,320
attacker knows in advance

283
00:10:52,320 --> 00:10:54,480
the number of bytes that is required to

284
00:10:54,480 --> 00:10:57,760
compile each javascript statement

285
00:10:57,760 --> 00:11:00,000
so for conditional jobs to emit gadgets

286
00:11:00,000 --> 00:11:02,640
attacker has to create if statement

287
00:11:02,640 --> 00:11:04,640
whose body size after compilation equals

288
00:11:04,640 --> 00:11:07,120
to the value of the gadget

289
00:11:07,120 --> 00:11:08,880
in our second approach of emitting

290
00:11:08,880 --> 00:11:11,279
gadgets we use direct calls displacement

291
00:11:11,279 --> 00:11:13,839
in direct calls encodes

292
00:11:13,839 --> 00:11:16,079
distance between the colli that is the

293
00:11:16,079 --> 00:11:17,440
function that we are calling and the

294
00:11:17,440 --> 00:11:19,920
caller instruct call instruction

295
00:11:19,920 --> 00:11:21,920
therefore to control the value encoded

296
00:11:21,920 --> 00:11:24,560
in displacement we have to precise we

297
00:11:24,560 --> 00:11:26,720
have to put our call instruction at

298
00:11:26,720 --> 00:11:29,040
precise location from the colleague

299
00:11:29,040 --> 00:11:30,480
however this is

300
00:11:30,480 --> 00:11:32,880
not easy because we do not know in

301
00:11:32,880 --> 00:11:34,800
advance where our function will be

302
00:11:34,800 --> 00:11:36,800
compiled

303
00:11:36,800 --> 00:11:38,959
however we can create

304
00:11:38,959 --> 00:11:41,680
large functions and contains many enough

305
00:11:41,680 --> 00:11:44,480
displacement fields in many enough

306
00:11:44,480 --> 00:11:46,480
direct calls that it will cover all

307
00:11:46,480 --> 00:11:49,279
possible 3 byte displacements and all

308
00:11:49,279 --> 00:11:52,399
possible 3 by distances from the colli

309
00:11:52,399 --> 00:11:54,800
for example in the case in the figure

310
00:11:54,800 --> 00:11:57,600
we use instruction i equals i plus j in

311
00:11:57,600 --> 00:11:59,200
chrome

312
00:11:59,200 --> 00:12:01,120
this instruction is compiled into 16

313
00:12:01,120 --> 00:12:03,600
bytes and if we use this instruction one

314
00:12:03,600 --> 00:12:06,160
one thousand one hundred thousand hex

315
00:12:06,160 --> 00:12:07,120
times

316
00:12:07,120 --> 00:12:09,279
it will be compiled into one million hex

317
00:12:09,279 --> 00:12:10,399
bytes

318
00:12:10,399 --> 00:12:12,800
and this will emit all possible 3 byte

319
00:12:12,800 --> 00:12:14,560
displacements

320
00:12:14,560 --> 00:12:16,800
however the least significant hull byte

321
00:12:16,800 --> 00:12:19,200
of all these displacements will be set

322
00:12:19,200 --> 00:12:22,399
to the fixed value

323
00:12:22,880 --> 00:12:25,519
however we can also adjust this fixed

324
00:12:25,519 --> 00:12:27,600
value by preparing the javascript

325
00:12:27,600 --> 00:12:29,600
function with other javascript

326
00:12:29,600 --> 00:12:31,040
statements

327
00:12:31,040 --> 00:12:33,519
for example our correct current fixed

328
00:12:33,519 --> 00:12:35,920
value is 5 and to emit system call

329
00:12:35,920 --> 00:12:37,760
gadget for example we need to add

330
00:12:37,760 --> 00:12:40,399
additional five eight bytes to

331
00:12:40,399 --> 00:12:42,399
to five

332
00:12:42,399 --> 00:12:44,720
this means if we use i equals one

333
00:12:44,720 --> 00:12:46,399
javascript statement at the beginning

334
00:12:46,399 --> 00:12:48,000
this will give us

335
00:12:48,000 --> 00:12:50,160
system call and also all possible three

336
00:12:50,160 --> 00:12:51,600
byte gadgets that

337
00:12:51,600 --> 00:12:55,360
and with a hex digit d

338
00:12:57,120 --> 00:12:59,360
after emitting all these gadgets

339
00:12:59,360 --> 00:13:02,000
we have to find them however we do not

340
00:13:02,000 --> 00:13:05,040
we cannot read code because we assume

341
00:13:05,040 --> 00:13:07,200
code segments are non-readable

342
00:13:07,200 --> 00:13:08,800
however there are

343
00:13:08,800 --> 00:13:11,040
a few places from data segments where we

344
00:13:11,040 --> 00:13:13,360
can leak function pointers

345
00:13:13,360 --> 00:13:15,920
these places are compilers keep or

346
00:13:15,920 --> 00:13:18,560
return addresses from the stack or

347
00:13:18,560 --> 00:13:20,399
for example reading javascript

348
00:13:20,399 --> 00:13:22,560
objects and linking code pointers from

349
00:13:22,560 --> 00:13:24,720
them

350
00:13:24,720 --> 00:13:27,440
and knowing the address of our function

351
00:13:27,440 --> 00:13:29,200
and address of the call function it's

352
00:13:29,200 --> 00:13:30,320
easy to

353
00:13:30,320 --> 00:13:32,240
to compute the address of emitted

354
00:13:32,240 --> 00:13:34,720
gadgets

355
00:13:34,720 --> 00:13:37,279
having the basic concepts ready we will

356
00:13:37,279 --> 00:13:39,279
now discuss their applicability in

357
00:13:39,279 --> 00:13:40,959
modern browsers

358
00:13:40,959 --> 00:13:42,800
i will start by

359
00:13:42,800 --> 00:13:45,440
showing how to emit the following set of

360
00:13:45,440 --> 00:13:47,199
gadgets in chrome

361
00:13:47,199 --> 00:13:49,839
so in this set of gadgets we set

362
00:13:49,839 --> 00:13:51,839
argument register for a system call and

363
00:13:51,839 --> 00:13:54,399
then we execute the system call

364
00:13:54,399 --> 00:13:55,839
we start by

365
00:13:55,839 --> 00:13:57,839
emitting system call

366
00:13:57,839 --> 00:14:00,560
using direct calls in chrome so as we

367
00:14:00,560 --> 00:14:02,399
already described the first step is to

368
00:14:02,399 --> 00:14:04,079
align least significant half byte of

369
00:14:04,079 --> 00:14:07,279
displacement to hex digit d

370
00:14:07,279 --> 00:14:09,199
and then we will

371
00:14:09,199 --> 00:14:10,399
allocate

372
00:14:10,399 --> 00:14:12,639
enough direct calls to

373
00:14:12,639 --> 00:14:15,519
cover one million hex bytes

374
00:14:15,519 --> 00:14:17,199
note that this doesn't only give us

375
00:14:17,199 --> 00:14:19,040
system call gadgets but all possible

376
00:14:19,040 --> 00:14:21,279
three byte gadgets with

377
00:14:21,279 --> 00:14:24,320
the same hex digit and also this will

378
00:14:24,320 --> 00:14:26,959
cover pop rcx and pop rdx gadgets which

379
00:14:26,959 --> 00:14:28,839
are two byte

380
00:14:28,839 --> 00:14:31,680
gadgets to emit remaining three byte

381
00:14:31,680 --> 00:14:34,880
gadgets we use conditional jumps

382
00:14:34,880 --> 00:14:37,600
and we use stacked if statements in

383
00:14:37,600 --> 00:14:40,639
javascript to emit pop r8 and power 9.

384
00:14:40,639 --> 00:14:42,800
as popular 8 is

385
00:14:42,800 --> 00:14:44,959
the value of popper 8

386
00:14:44,959 --> 00:14:47,199
gadget is smaller than copper knight

387
00:14:47,199 --> 00:14:49,760
inner if statement body will be compiled

388
00:14:49,760 --> 00:14:51,600
to the value

389
00:14:51,600 --> 00:14:54,320
and to reach from operate to popper9 we

390
00:14:54,320 --> 00:14:57,600
add additional 100 hex bytes

391
00:14:57,600 --> 00:15:00,079
and this will give us

392
00:15:00,079 --> 00:15:03,600
both of these gadgets

393
00:15:03,600 --> 00:15:06,160
gadget generation in chrome took around

394
00:15:06,160 --> 00:15:08,720
1.3 seconds

395
00:15:08,720 --> 00:15:11,440
however there are some limitations in

396
00:15:11,440 --> 00:15:13,600
internet explorer which doesn't allow us

397
00:15:13,600 --> 00:15:17,440
to image these gadgets easily

398
00:15:19,440 --> 00:15:21,760
for example internet explorer limits the

399
00:15:21,760 --> 00:15:24,680
size of a compiled javascript

400
00:15:24,680 --> 00:15:26,480
function and

401
00:15:26,480 --> 00:15:28,320
javascript function function code size

402
00:15:28,320 --> 00:15:30,720
limitation directly limits us with

403
00:15:30,720 --> 00:15:32,480
maximum value of displacement fields

404
00:15:32,480 --> 00:15:34,720
that we can encoding conditional jump

405
00:15:34,720 --> 00:15:36,560
because conditional jumps can only be

406
00:15:36,560 --> 00:15:37,920
made inside

407
00:15:37,920 --> 00:15:41,440
the same function however we can still

408
00:15:41,440 --> 00:15:44,800
use uh direct calls because uh direct

409
00:15:44,800 --> 00:15:46,560
calls encode the distance between two

410
00:15:46,560 --> 00:15:48,800
functions and not is not limited by

411
00:15:48,800 --> 00:15:51,040
function size however we are still

412
00:15:51,040 --> 00:15:52,399
limited with

413
00:15:52,399 --> 00:15:54,639
our previous technique where we wanted

414
00:15:54,639 --> 00:15:56,079
to spray

415
00:15:56,079 --> 00:15:57,759
a large enough code

416
00:15:57,759 --> 00:16:00,240
we are not allowed to do so

417
00:16:00,240 --> 00:16:03,199
and uh further nope insertion also

418
00:16:03,199 --> 00:16:04,720
diversifies

419
00:16:04,720 --> 00:16:07,279
the displacement field emitted by direct

420
00:16:07,279 --> 00:16:09,199
calls

421
00:16:09,199 --> 00:16:11,839
and we have to deal with it also

422
00:16:11,839 --> 00:16:14,880
so our plan to emit gadgets in internet

423
00:16:14,880 --> 00:16:17,040
explorer takes the following steps we

424
00:16:17,040 --> 00:16:19,199
first get the correct code page at

425
00:16:19,199 --> 00:16:21,839
correct distance from the

426
00:16:21,839 --> 00:16:23,680
then we fill the page with gadget

427
00:16:23,680 --> 00:16:26,399
emitting functions and finally we

428
00:16:26,399 --> 00:16:28,399
check if direct column is correct

429
00:16:28,399 --> 00:16:31,040
distance correct displacement and if not

430
00:16:31,040 --> 00:16:34,079
we recompile the function

431
00:16:34,079 --> 00:16:36,880
so the first step is the following we

432
00:16:36,880 --> 00:16:39,120
compile in a function to get 100 code

433
00:16:39,120 --> 00:16:41,600
pages in internet explorer out of this

434
00:16:41,600 --> 00:16:43,759
code pages we choose the one that is at

435
00:16:43,759 --> 00:16:45,680
the correct distance from the colleen

436
00:16:45,680 --> 00:16:47,920
that is mass random in our case

437
00:16:47,920 --> 00:16:50,240
and correct distance means that a third

438
00:16:50,240 --> 00:16:52,399
byte of the displacement will call

439
00:16:52,399 --> 00:16:54,880
contain c byte which is a return

440
00:16:54,880 --> 00:16:57,439
instruction

441
00:16:57,680 --> 00:16:59,920
having correct code page

442
00:16:59,920 --> 00:17:02,240
what we do first is we deallocate it to

443
00:17:02,240 --> 00:17:04,400
make space for

444
00:17:04,400 --> 00:17:06,640
gadget emitting functions then we fill

445
00:17:06,640 --> 00:17:08,480
up the space so that next gadget

446
00:17:08,480 --> 00:17:10,000
emitting functions that we want to

447
00:17:10,000 --> 00:17:12,559
compile will be compiled at the correct

448
00:17:12,559 --> 00:17:15,520
place this will set another hex digit in

449
00:17:15,520 --> 00:17:19,480
the displacement field

450
00:17:19,919 --> 00:17:22,160
next we compile our gadget emitting

451
00:17:22,160 --> 00:17:23,839
function which

452
00:17:23,839 --> 00:17:25,679
contains a statement that is called to

453
00:17:25,679 --> 00:17:28,640
mass random which emits direct call

454
00:17:28,640 --> 00:17:30,559
and displacement field of this direct

455
00:17:30,559 --> 00:17:33,520
call will have all the bytes set except

456
00:17:33,520 --> 00:17:35,039
for the last one

457
00:17:35,039 --> 00:17:36,799
this least significant half byte of this

458
00:17:36,799 --> 00:17:38,640
displacement is randomized by nope

459
00:17:38,640 --> 00:17:40,320
insertion

460
00:17:40,320 --> 00:17:42,160
therefore we don't know the value what

461
00:17:42,160 --> 00:17:44,400
it contains

462
00:17:44,400 --> 00:17:47,520
to know the value encoding displacement

463
00:17:47,520 --> 00:17:49,440
we leak return address put there by

464
00:17:49,440 --> 00:17:50,960
direct call

465
00:17:50,960 --> 00:17:53,280
we verify if this is at the correct

466
00:17:53,280 --> 00:17:54,559
place

467
00:17:54,559 --> 00:17:56,240
if not

468
00:17:56,240 --> 00:17:58,320
if it is at the correct place it means

469
00:17:58,320 --> 00:18:00,960
that we have found a gadget otherwise we

470
00:18:00,960 --> 00:18:02,880
decompile the function

471
00:18:02,880 --> 00:18:05,280
and go back to step three step three

472
00:18:05,280 --> 00:18:07,600
will recompile the function again now

473
00:18:07,600 --> 00:18:10,240
displacement field will also be

474
00:18:10,240 --> 00:18:12,960
randomized and we do so until we find

475
00:18:12,960 --> 00:18:15,840
the correct gadget

476
00:18:16,000 --> 00:18:17,760
so we tried this technique in internet

477
00:18:17,760 --> 00:18:19,360
explorer 11

478
00:18:19,360 --> 00:18:22,480
and our we aim to emit pop a and system

479
00:18:22,480 --> 00:18:24,320
call gadget this is because internet

480
00:18:24,320 --> 00:18:26,240
explorer by default uses 32-bit

481
00:18:26,240 --> 00:18:29,360
javascript compiler

482
00:18:29,360 --> 00:18:30,960
so the first two steps of gadget

483
00:18:30,960 --> 00:18:33,760
generation took around eight seconds and

484
00:18:33,760 --> 00:18:37,360
the third step of recompiling cisco

485
00:18:37,360 --> 00:18:39,760
took around two seconds but this took

486
00:18:39,760 --> 00:18:42,799
two seconds per each iteration

487
00:18:42,799 --> 00:18:44,720
so on average gadget generation in

488
00:18:44,720 --> 00:18:49,440
internet explorer took around 32 seconds

489
00:18:51,360 --> 00:18:53,919
so to sum up our attack technique we

490
00:18:53,919 --> 00:18:56,240
demonstrated two ways how we can emit

491
00:18:56,240 --> 00:18:58,480
arbitrary threat gadgets in modern

492
00:18:58,480 --> 00:18:59,760
browsers

493
00:18:59,760 --> 00:19:02,240
we use conditional jumps which works in

494
00:19:02,240 --> 00:19:04,160
firefox and chrome but it doesn't work

495
00:19:04,160 --> 00:19:06,080
in internet explorer because of code

496
00:19:06,080 --> 00:19:08,480
size limitation

497
00:19:08,480 --> 00:19:10,799
another technique is direct calls

498
00:19:10,799 --> 00:19:13,600
it works in chrome and firefox however

499
00:19:13,600 --> 00:19:15,600
it doesn't work against

500
00:19:15,600 --> 00:19:18,160
firefox because firefox doesn't use

501
00:19:18,160 --> 00:19:22,240
direct calls after jit compilation

502
00:19:22,960 --> 00:19:25,440
the final part of my talk is about how

503
00:19:25,440 --> 00:19:28,720
to prevent this gadget emission attack

504
00:19:28,720 --> 00:19:30,960
inject compiled code the main main idea

505
00:19:30,960 --> 00:19:33,679
of this defense will be to

506
00:19:33,679 --> 00:19:34,720
get rid

507
00:19:34,720 --> 00:19:36,559
to take away

508
00:19:36,559 --> 00:19:38,480
the leverage from

509
00:19:38,480 --> 00:19:41,679
attacker that is we convert all relative

510
00:19:41,679 --> 00:19:44,000
addresses into absolute ones that means

511
00:19:44,000 --> 00:19:46,000
attacker cannot control

512
00:19:46,000 --> 00:19:49,360
the values encoded in them anymore

513
00:19:49,360 --> 00:19:50,240
we

514
00:19:50,240 --> 00:19:53,200
start by direct calls so we distinguish

515
00:19:53,200 --> 00:19:55,520
between two cases the first case if we

516
00:19:55,520 --> 00:19:59,760
know the absolute address of direct call

517
00:19:59,760 --> 00:20:01,120
in this case we simply move this

518
00:20:01,120 --> 00:20:02,880
absolute address into a scratch register

519
00:20:02,880 --> 00:20:06,799
and execute an indirect call the second

520
00:20:06,799 --> 00:20:09,039
case is when we know only the relative

521
00:20:09,039 --> 00:20:10,880
address of destination

522
00:20:10,880 --> 00:20:12,960
in this case we have to compute

523
00:20:12,960 --> 00:20:15,919
absolute address on the fly at runtime

524
00:20:15,919 --> 00:20:17,840
to do this we use lia instruction and

525
00:20:17,840 --> 00:20:19,760
add relative address to the instruction

526
00:20:19,760 --> 00:20:22,400
pointer however now this lia instruction

527
00:20:22,400 --> 00:20:24,720
emits this relative address which we

528
00:20:24,720 --> 00:20:26,960
wanted to hide in the first place

529
00:20:26,960 --> 00:20:28,960
to get rid of this relative address we

530
00:20:28,960 --> 00:20:31,360
split it into two as it as it was done

531
00:20:31,360 --> 00:20:33,520
already in constant blinding

532
00:20:33,520 --> 00:20:35,679
the first part we'll add

533
00:20:35,679 --> 00:20:38,799
relative address ended with a random key

534
00:20:38,799 --> 00:20:40,640
to the instruction pointer and second

535
00:20:40,640 --> 00:20:43,120
part we will add the remaining bits that

536
00:20:43,120 --> 00:20:45,039
is relative address ended with the

537
00:20:45,039 --> 00:20:48,480
inverse of a key

538
00:20:48,480 --> 00:20:50,240
the second part of the defense is

539
00:20:50,240 --> 00:20:53,039
converting from conditional jumps

540
00:20:53,039 --> 00:20:55,440
to safer conditional jumps the first

541
00:20:55,440 --> 00:20:57,760
part what we do is

542
00:20:57,760 --> 00:20:59,120
change from

543
00:20:59,120 --> 00:21:01,360
direct jumps into indirect ones

544
00:21:01,360 --> 00:21:03,120
we do this similarly as we did for

545
00:21:03,120 --> 00:21:05,679
direct calls however there is a problem

546
00:21:05,679 --> 00:21:08,480
that we do not have indirect conditional

547
00:21:08,480 --> 00:21:12,720
jumps in x86 therefore in this case

548
00:21:12,720 --> 00:21:15,120
statements inside the if body will never

549
00:21:15,120 --> 00:21:17,200
be executed

550
00:21:17,200 --> 00:21:19,200
to fix this issue we add additional

551
00:21:19,200 --> 00:21:20,720
conditional jump

552
00:21:20,720 --> 00:21:22,720
at the beginning this conditional jump

553
00:21:22,720 --> 00:21:26,000
will have the inverse condition as we as

554
00:21:26,000 --> 00:21:27,919
original jump head

555
00:21:27,919 --> 00:21:29,360
that's because

556
00:21:29,360 --> 00:21:31,919
if body was executed in original case

557
00:21:31,919 --> 00:21:33,440
where

558
00:21:33,440 --> 00:21:35,280
only in the case where original

559
00:21:35,280 --> 00:21:38,240
condition was false

560
00:21:41,919 --> 00:21:44,960
we implemented our defense in v8

561
00:21:44,960 --> 00:21:47,360
and to measure the performance overhead

562
00:21:47,360 --> 00:21:51,039
we used v8's javascript benchmark suite

563
00:21:51,039 --> 00:21:52,799
on average it showed two percent

564
00:21:52,799 --> 00:21:54,720
performance overhead

565
00:21:54,720 --> 00:21:56,000
and

566
00:21:56,000 --> 00:21:58,720
however it showed 26 percent code size

567
00:21:58,720 --> 00:21:59,840
overhead

568
00:21:59,840 --> 00:22:04,640
after generation however this 26 percent

569
00:22:04,640 --> 00:22:07,760
equals to around 300 kilobytes for the

570
00:22:07,760 --> 00:22:09,840
entire benchmark so it which is still

571
00:22:09,840 --> 00:22:11,760
tolerable

572
00:22:11,760 --> 00:22:14,080
we additionally used micro benchmarks to

573
00:22:14,080 --> 00:22:16,000
test for worst cases

574
00:22:16,000 --> 00:22:18,559
in micro benchmarks we used 1 million

575
00:22:18,559 --> 00:22:22,000
direct calls and conditional jumps

576
00:22:22,000 --> 00:22:23,039
and

577
00:22:23,039 --> 00:22:25,600
the performance decrease was 14 percent

578
00:22:25,600 --> 00:22:29,840
and 10 percent on average

579
00:22:31,280 --> 00:22:34,080
so to summarize in this presentation i

580
00:22:34,080 --> 00:22:35,280
have shown

581
00:22:35,280 --> 00:22:36,799
that displacement fields can also

582
00:22:36,799 --> 00:22:39,120
contain attacker controlled values and

583
00:22:39,120 --> 00:22:42,240
to make sure that generated code is not

584
00:22:42,240 --> 00:22:43,840
influenced by the attacker these

585
00:22:43,840 --> 00:22:46,320
compilers have also

586
00:22:46,320 --> 00:22:48,159
have to get rid of them

587
00:22:48,159 --> 00:22:50,159
we also demonstrated that we don't need

588
00:22:50,159 --> 00:22:52,640
readable code and predictable code

589
00:22:52,640 --> 00:22:56,720
output from jit compilers is enough to

590
00:22:56,720 --> 00:23:00,480
leak the addresses of emitted gadgets

591
00:23:00,480 --> 00:23:02,880
and finally we showed how to remove

592
00:23:02,880 --> 00:23:04,559
gadgets from these displacement fields

593
00:23:04,559 --> 00:23:08,240
by converting relative addressing into a

594
00:23:08,240 --> 00:23:11,200
direct indirect one

595
00:23:11,200 --> 00:23:14,400
thank you for your attention

596
00:23:19,919 --> 00:23:21,840
thanks georgie for the presentation and

597
00:23:21,840 --> 00:23:24,240
there's the first question

598
00:23:24,240 --> 00:23:26,559
hello um

599
00:23:26,559 --> 00:23:29,120
it's on okay my name is pierre i'm from

600
00:23:29,120 --> 00:23:32,080
uc irvine i worked on one of the jet rob

601
00:23:32,080 --> 00:23:33,200
defenses

602
00:23:33,200 --> 00:23:34,880
you might know this

603
00:23:34,880 --> 00:23:36,640
and

604
00:23:36,640 --> 00:23:38,000
this is more of a comment than a

605
00:23:38,000 --> 00:23:39,760
question um

606
00:23:39,760 --> 00:23:41,760
the assumption was always that code

607
00:23:41,760 --> 00:23:43,360
pointer hiding would be

608
00:23:43,360 --> 00:23:45,039
applied uniformly

609
00:23:45,039 --> 00:23:46,799
and it looks like in your paper you're

610
00:23:46,799 --> 00:23:48,559
assuming that it's not

611
00:23:48,559 --> 00:23:50,640
applied to the jit compile code which it

612
00:23:50,640 --> 00:23:52,480
wasn't in our prototype

613
00:23:52,480 --> 00:23:54,400
and we we don't think there's any

614
00:23:54,400 --> 00:23:56,400
limitations or reasons why we wouldn't

615
00:23:56,400 --> 00:23:57,440
do that

616
00:23:57,440 --> 00:23:59,200
we simply ran out of time before we had

617
00:23:59,200 --> 00:24:02,080
to submit the paper

618
00:24:03,760 --> 00:24:05,440
would you agree with that that

619
00:24:05,440 --> 00:24:08,000
your attack would no longer work if if

620
00:24:08,000 --> 00:24:09,440
code pointer hiding was applied

621
00:24:09,440 --> 00:24:10,880
uniformly

622
00:24:10,880 --> 00:24:12,080
so

623
00:24:12,080 --> 00:24:14,159
there was no implemented code pointer

624
00:24:14,159 --> 00:24:16,159
hiding in cheat code it was mentioned

625
00:24:16,159 --> 00:24:17,840
that this can be

626
00:24:17,840 --> 00:24:19,919
extended to also protect jit code

627
00:24:19,919 --> 00:24:21,120
however

628
00:24:21,120 --> 00:24:23,279
however this defense technique was using

629
00:24:23,279 --> 00:24:25,200
trampolines to

630
00:24:25,200 --> 00:24:27,360
for code point pointer hiding

631
00:24:27,360 --> 00:24:29,440
and in our case when we also encode

632
00:24:29,440 --> 00:24:32,159
gadgets in direct calls trampolines will

633
00:24:32,159 --> 00:24:34,720
now contain all these possible gadgets

634
00:24:34,720 --> 00:24:36,960
so for example if we

635
00:24:36,960 --> 00:24:41,200
again emit this 100 000 direct calls now

636
00:24:41,200 --> 00:24:43,279
these direct calls will also be in

637
00:24:43,279 --> 00:24:47,679
compiled code and in the trampolines

638
00:24:47,679 --> 00:24:49,520
the compiler if we don't get code

639
00:24:49,520 --> 00:24:51,840
pointers this will be defended

640
00:24:51,840 --> 00:24:53,200
but

641
00:24:53,200 --> 00:24:56,159
we know addresses of trampolines and all

642
00:24:56,159 --> 00:24:59,360
we need to know is uh somehow leak

643
00:24:59,360 --> 00:25:02,320
address of the call destination

644
00:25:02,320 --> 00:25:04,480
if everything is hidden this will be

645
00:25:04,480 --> 00:25:07,120
defended

646
00:25:07,679 --> 00:25:10,640
but if there is still some code pointer

647
00:25:10,640 --> 00:25:12,320
missing

648
00:25:12,320 --> 00:25:14,880
in not complete implementation then

649
00:25:14,880 --> 00:25:16,400
our attack was right that's kind of a

650
00:25:16,400 --> 00:25:18,240
circular argument right if there's a

651
00:25:18,240 --> 00:25:20,320
code pointer not protected then there's

652
00:25:20,320 --> 00:25:23,360
a problem yeah and another issue is that

653
00:25:23,360 --> 00:25:25,440
i think uh i mean

654
00:25:25,440 --> 00:25:27,279
we do not try to

655
00:25:27,279 --> 00:25:29,200
propose some

656
00:25:29,200 --> 00:25:30,640
better defense

657
00:25:30,640 --> 00:25:32,080
we

658
00:25:32,080 --> 00:25:32,799
we

659
00:25:32,799 --> 00:25:35,120
so what we wanted to show that it's

660
00:25:35,120 --> 00:25:36,880
important to get rid of gadgets from

661
00:25:36,880 --> 00:25:38,080
displacement

662
00:25:38,080 --> 00:25:40,320
but for example in

663
00:25:40,320 --> 00:25:41,840
when you hide all code pointers there

664
00:25:41,840 --> 00:25:43,520
are also side channels that can be used

665
00:25:43,520 --> 00:25:45,360
for example when we use conditional

666
00:25:45,360 --> 00:25:46,320
jumps

667
00:25:46,320 --> 00:25:49,279
we created really huge functions

668
00:25:49,279 --> 00:25:50,159
and

669
00:25:50,159 --> 00:25:52,799
depending on allocation from compilers

670
00:25:52,799 --> 00:25:54,799
we could somehow know where this

671
00:25:54,799 --> 00:25:56,480
function was allocated

672
00:25:56,480 --> 00:25:59,600
and there after that because of

673
00:25:59,600 --> 00:26:01,120
predictable code output from jit

674
00:26:01,120 --> 00:26:05,120
compiler we know direct offset where

675
00:26:05,120 --> 00:26:06,720
our gadget is

676
00:26:06,720 --> 00:26:09,440
in that case we have indirect leak

677
00:26:09,440 --> 00:26:12,799
without code pointer of our function

678
00:26:12,799 --> 00:26:14,799
and then we have all the gadgets inside

679
00:26:14,799 --> 00:26:17,279
conditional jumps which might still be

680
00:26:17,279 --> 00:26:19,200
doable but

681
00:26:19,200 --> 00:26:19,919
it

682
00:26:19,919 --> 00:26:21,760
sort of uses some side channels

683
00:26:21,760 --> 00:26:23,520
interesting thank you

684
00:26:23,520 --> 00:26:25,840
welcome

685
00:26:26,000 --> 00:26:27,810
thanks speak again

686
00:26:27,810 --> 00:26:34,139
[Applause]

