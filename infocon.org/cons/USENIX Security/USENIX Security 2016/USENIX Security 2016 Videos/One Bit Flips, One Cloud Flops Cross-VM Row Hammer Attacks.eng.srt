1
00:00:11,120 --> 00:00:13,599
hi everyone i am yuen shah from the ohio

2
00:00:13,599 --> 00:00:15,599
state university the topic of my

3
00:00:15,599 --> 00:00:18,000
presentation today is one bit slots one

4
00:00:18,000 --> 00:00:20,240
card flops cross vmware hammer attacks

5
00:00:20,240 --> 00:00:22,800
and privilege escalation the paper is

6
00:00:22,800 --> 00:00:24,640
the joint work of childhood professor

7
00:00:24,640 --> 00:00:26,800
intent john professor rado tilda rasku

8
00:00:26,800 --> 00:00:28,080
and me

9
00:00:28,080 --> 00:00:29,679
what we did has something in common with

10
00:00:29,679 --> 00:00:32,000
the previous talk we both exploited

11
00:00:32,000 --> 00:00:34,399
hammering crossbeam settings however we

12
00:00:34,399 --> 00:00:37,040
do not uh we didn't need any presumption

13
00:00:37,040 --> 00:00:39,520
of the settings of the hypervisor and

14
00:00:39,520 --> 00:00:42,399
we'll see how it goes

15
00:00:43,200 --> 00:00:44,719
let's start with some news from the

16
00:00:44,719 --> 00:00:47,760
internet the first one is in 2014 by

17
00:00:47,760 --> 00:00:49,360
when the iran disturbance error was

18
00:00:49,360 --> 00:00:51,680
first reported in academic papers

19
00:00:51,680 --> 00:00:54,719
the camera attack is based on such error

20
00:00:54,719 --> 00:00:57,280
in march 2015 the google zero project

21
00:00:57,280 --> 00:00:59,039
presented the first kernel level

22
00:00:59,039 --> 00:01:01,359
exploitation with your camera

23
00:01:01,359 --> 00:01:04,000
and no longer no long not long after

24
00:01:04,000 --> 00:01:06,240
that some researchers showed that your

25
00:01:06,240 --> 00:01:07,360
camera could be triggered with

26
00:01:07,360 --> 00:01:08,560
javascript

27
00:01:08,560 --> 00:01:10,560
in other words even a website page on

28
00:01:10,560 --> 00:01:13,119
your browser is able to do the attack

29
00:01:13,119 --> 00:01:15,840
and recently cdf4 drams were also proven

30
00:01:15,840 --> 00:01:18,080
vulnerable although although they were

31
00:01:18,080 --> 00:01:20,960
once designed and thought to be immune

32
00:01:20,960 --> 00:01:23,040
different from previous work our

33
00:01:23,040 --> 00:01:25,439
research focused on strengthening it by

34
00:01:25,439 --> 00:01:27,840
enabling double-sided air hammer and we

35
00:01:27,840 --> 00:01:29,759
exploited its power to break software

36
00:01:29,759 --> 00:01:32,079
isolation on the memory in cross-vm

37
00:01:32,079 --> 00:01:34,079
settings

38
00:01:34,079 --> 00:01:35,920
before we move into the attack i would

39
00:01:35,920 --> 00:01:38,880
like to provide some basic ideas of the

40
00:01:38,880 --> 00:01:41,280
organization and architecture

41
00:01:41,280 --> 00:01:43,119
the memory system in your computer is

42
00:01:43,119 --> 00:01:45,680
organized on a hierarchical basis the

43
00:01:45,680 --> 00:01:47,759
dram modules are first divided into one

44
00:01:47,759 --> 00:01:50,720
multiple channels each consisting of one

45
00:01:50,720 --> 00:01:53,360
multiple dram modules each module is

46
00:01:53,360 --> 00:01:55,439
actually called a dim during line memory

47
00:01:55,439 --> 00:01:56,560
module

48
00:01:56,560 --> 00:01:59,360
each side with chips is called a rank

49
00:01:59,360 --> 00:02:01,520
and each blackjack includes

50
00:02:01,520 --> 00:02:03,680
multiple banks a common number of banks

51
00:02:03,680 --> 00:02:05,040
is eight

52
00:02:05,040 --> 00:02:07,360
the banks consist of a number of memory

53
00:02:07,360 --> 00:02:09,919
blocks a memory block is recognized as

54
00:02:09,919 --> 00:02:12,800
bytes they are they organized in the two

55
00:02:12,800 --> 00:02:15,200
like two-dimensional way indexed by the

56
00:02:15,200 --> 00:02:17,760
real number and column number

57
00:02:17,760 --> 00:02:19,840
while the chips have their own buses and

58
00:02:19,840 --> 00:02:21,680
not standalone from each other when

59
00:02:21,680 --> 00:02:24,000
referring to a certain bank index the

60
00:02:24,000 --> 00:02:26,000
banks with their index in other chips

61
00:02:26,000 --> 00:02:27,840
will be loaded simultaneously and be

62
00:02:27,840 --> 00:02:31,280
combining to a 64-bit word

63
00:02:31,280 --> 00:02:33,120
now let's see how to access the memory

64
00:02:33,120 --> 00:02:34,959
block in the bank

65
00:02:34,959 --> 00:02:36,560
every square in the figure is a memory

66
00:02:36,560 --> 00:02:38,720
block and they they all have their

67
00:02:38,720 --> 00:02:40,959
unique physical addresses

68
00:02:40,959 --> 00:02:42,400
first of all the drama will charge

69
00:02:42,400 --> 00:02:44,879
literally where the block locates we

70
00:02:44,879 --> 00:02:47,280
call the charging here a row activation

71
00:02:47,280 --> 00:02:49,360
now the row is loaded into a structure

72
00:02:49,360 --> 00:02:51,599
called root buffer each bank has its own

73
00:02:51,599 --> 00:02:53,040
row buffer

74
00:02:53,040 --> 00:02:54,800
then the block is chosen by using its

75
00:02:54,800 --> 00:02:56,720
column number from it

76
00:02:56,720 --> 00:02:59,120
if the next block to access is still in

77
00:02:59,120 --> 00:03:01,040
the same row there will be no activation

78
00:03:01,040 --> 00:03:03,200
of the row the block can directly be

79
00:03:03,200 --> 00:03:06,239
accessed from the row buffer

80
00:03:06,239 --> 00:03:07,920
now we can move on to the rohingya

81
00:03:07,920 --> 00:03:09,519
vulnerability

82
00:03:09,519 --> 00:03:11,519
before we do anything the dram is

83
00:03:11,519 --> 00:03:14,080
normally maintaining the values

84
00:03:14,080 --> 00:03:15,840
the figure here shows a single bandwidth

85
00:03:15,840 --> 00:03:17,280
or buffer

86
00:03:17,280 --> 00:03:19,360
notice that each screen here stands for

87
00:03:19,360 --> 00:03:22,000
bits rather than a box for convenience

88
00:03:22,000 --> 00:03:23,760
now we wish to access the block in the

89
00:03:23,760 --> 00:03:26,159
row between the two gray rows we charge

90
00:03:26,159 --> 00:03:27,599
it before we access it from the row

91
00:03:27,599 --> 00:03:28,560
buffer

92
00:03:28,560 --> 00:03:30,319
after that we access a block in a

93
00:03:30,319 --> 00:03:32,799
different row but still in the same bank

94
00:03:32,799 --> 00:03:34,799
now the buffer contains the second row

95
00:03:34,799 --> 00:03:37,519
and we access the special again

96
00:03:37,519 --> 00:03:38,959
since we have to

97
00:03:38,959 --> 00:03:41,120
load into the row buffer we have to

98
00:03:41,120 --> 00:03:43,840
charge and activate it again

99
00:03:43,840 --> 00:03:46,720
by accessing the two in turn they are

100
00:03:46,720 --> 00:03:48,400
charging and activated in all the

101
00:03:48,400 --> 00:03:50,159
accesses

102
00:03:50,159 --> 00:03:51,920
the rapid real activation will lead to

103
00:03:51,920 --> 00:03:54,400
some electric magnetic influence on this

104
00:03:54,400 --> 00:03:56,159
enabling routes and finally it will

105
00:03:56,159 --> 00:03:58,640
cause some bits enabling roads to charge

106
00:03:58,640 --> 00:04:00,400
or discharge and be changed into a

107
00:04:00,400 --> 00:04:02,000
different value

108
00:04:02,000 --> 00:04:03,760
the value change is called a basically

109
00:04:03,760 --> 00:04:06,319
it may be one to zero or zero to one and

110
00:04:06,319 --> 00:04:07,599
the flipped bit is called the

111
00:04:07,599 --> 00:04:09,840
disturbance error

112
00:04:09,840 --> 00:04:11,200
and the attack

113
00:04:11,200 --> 00:04:13,120
the attack to trigger plays by

114
00:04:13,120 --> 00:04:14,879
intentional rapid role activation is the

115
00:04:14,879 --> 00:04:17,600
so-called humor attack

116
00:04:17,600 --> 00:04:19,759
now imagine the two rows we use in the

117
00:04:19,759 --> 00:04:21,759
camera so close that there is only one

118
00:04:21,759 --> 00:04:23,919
row between them naturally the mineral

119
00:04:23,919 --> 00:04:26,080
will be influenced by both rows causing

120
00:04:26,080 --> 00:04:27,919
the chance of bit flips to be much

121
00:04:27,919 --> 00:04:30,800
higher than the upper and lower rows

122
00:04:30,800 --> 00:04:32,880
so a stronger type of real camera attack

123
00:04:32,880 --> 00:04:34,960
is called double-sided camera while the

124
00:04:34,960 --> 00:04:36,560
previous one is called single-sided

125
00:04:36,560 --> 00:04:38,320
camera

126
00:04:38,320 --> 00:04:40,000
although the concept of double-sided

127
00:04:40,000 --> 00:04:42,639
camera was suggested long ago none of

128
00:04:42,639 --> 00:04:44,720
the previous works um correctly

129
00:04:44,720 --> 00:04:47,040
conducted in um

130
00:04:47,040 --> 00:04:50,080
on modern success processors

131
00:04:50,080 --> 00:04:51,840
these projects are quite interesting and

132
00:04:51,840 --> 00:04:54,880
helpful like like uh sibon from google

133
00:04:54,880 --> 00:04:56,800
presented kernel privilege escalation

134
00:04:56,800 --> 00:04:59,120
and same sandbox escape

135
00:04:59,120 --> 00:05:01,360
however no explanation was ever done in

136
00:05:01,360 --> 00:05:03,680
the cross-vm settings

137
00:05:03,680 --> 00:05:05,440
here comes some questions leading to our

138
00:05:05,440 --> 00:05:06,479
research

139
00:05:06,479 --> 00:05:08,160
how to conduct double-sided camera

140
00:05:08,160 --> 00:05:10,600
attacks and how to explore your camera

141
00:05:10,600 --> 00:05:14,479
vulnerabilities in cross-beam settings

142
00:05:14,479 --> 00:05:16,320
all work and roll camera attacks falls

143
00:05:16,320 --> 00:05:18,479
into three parts in the first section

144
00:05:18,479 --> 00:05:20,880
i'm going to introduce a novel method to

145
00:05:20,880 --> 00:05:22,479
reverse engineer the physical address

146
00:05:22,479 --> 00:05:24,880
mapping of the ramps thus we have enough

147
00:05:24,880 --> 00:05:26,800
knowledge to bring forward the accurate

148
00:05:26,800 --> 00:05:28,320
and efficient double-sided camera

149
00:05:28,320 --> 00:05:29,280
attacks

150
00:05:29,280 --> 00:05:31,759
the second part is about how we exploit

151
00:05:31,759 --> 00:05:34,080
arbitrary memory access by real camera

152
00:05:34,080 --> 00:05:36,160
attacks in the cross-beam settings our

153
00:05:36,160 --> 00:05:38,320
camera serves as an excellent tool to

154
00:05:38,320 --> 00:05:40,960
break the isolation of virtual machines

155
00:05:40,960 --> 00:05:42,320
in the end i will talk about a

156
00:05:42,320 --> 00:05:44,560
sophisticated attack against openness

157
00:05:44,560 --> 00:05:46,000
server based on the previous two

158
00:05:46,000 --> 00:05:48,160
sections now let me introduce to you the

159
00:05:48,160 --> 00:05:50,240
first first section the reverse

160
00:05:50,240 --> 00:05:52,960
engineering of the ram mapping

161
00:05:52,960 --> 00:05:54,880
remember our first question we need a

162
00:05:54,880 --> 00:05:56,960
way to find two rows in the same bank

163
00:05:56,960 --> 00:05:58,880
and there is only one other row in

164
00:05:58,880 --> 00:06:00,000
between

165
00:06:00,000 --> 00:06:02,160
however intel keeps how physical

166
00:06:02,160 --> 00:06:03,840
addresses are mapped to the hardware

167
00:06:03,840 --> 00:06:04,880
secret

168
00:06:04,880 --> 00:06:06,880
and different cpus different different

169
00:06:06,880 --> 00:06:08,639
types and sizes all lead to different

170
00:06:08,639 --> 00:06:10,880
mapping rules so given two physical

171
00:06:10,880 --> 00:06:13,199
addresses how do we know which bank and

172
00:06:13,199 --> 00:06:15,199
which role are they meant to

173
00:06:15,199 --> 00:06:17,440
or more specifically are they in the

174
00:06:17,440 --> 00:06:20,400
same bank and neighboring rows

175
00:06:20,400 --> 00:06:22,240
we make use of the timing channel to

176
00:06:22,240 --> 00:06:24,400
analyze the memory block

177
00:06:24,400 --> 00:06:27,280
with the physical addresses x1 and x2

178
00:06:27,280 --> 00:06:29,520
suppose x1 and x2 are mapped to 2

179
00:06:29,520 --> 00:06:31,919
different banks b1 and b2 we want to

180
00:06:31,919 --> 00:06:34,560
first read x1 we activate the row here

181
00:06:34,560 --> 00:06:37,039
activation takes the extra time and we

182
00:06:37,039 --> 00:06:39,520
load it into the row buffer

183
00:06:39,520 --> 00:06:41,280
then we read it from the buffer and

184
00:06:41,280 --> 00:06:43,360
reading text to read time

185
00:06:43,360 --> 00:06:45,759
do we want to read x2 we do exactly the

186
00:06:45,759 --> 00:06:47,440
same as before

187
00:06:47,440 --> 00:06:49,360
activate row loading to the row buffer

188
00:06:49,360 --> 00:06:50,639
in read

189
00:06:50,639 --> 00:06:53,360
after the first one we read x1 again now

190
00:06:53,360 --> 00:06:55,520
since the buffer still contains zero x1

191
00:06:55,520 --> 00:06:57,680
is in we directly read it without

192
00:06:57,680 --> 00:06:59,199
activating again

193
00:06:59,199 --> 00:07:03,360
in the saving same happens to reading x2

194
00:07:03,360 --> 00:07:05,599
after reading x1 and x2 in turn for n

195
00:07:05,599 --> 00:07:08,160
times the total time will be 2 times t

196
00:07:08,160 --> 00:07:11,919
xv plus 2 times n times t read

197
00:07:11,919 --> 00:07:13,759
now let's consider the situation where

198
00:07:13,759 --> 00:07:16,400
x1 and 2 are mapped to different rows in

199
00:07:16,400 --> 00:07:17,919
the same bank

200
00:07:17,919 --> 00:07:21,280
first we react x1 x3 loading to buffer

201
00:07:21,280 --> 00:07:24,639
in read same steps for x2

202
00:07:24,639 --> 00:07:26,479
here comes something different

203
00:07:26,479 --> 00:07:28,880
since the buffer now contains the row of

204
00:07:28,880 --> 00:07:31,360
x2 we have to actuate the x1 row and

205
00:07:31,360 --> 00:07:33,440
load it into the row buffer again before

206
00:07:33,440 --> 00:07:34,960
we read x1

207
00:07:34,960 --> 00:07:37,120
and the following reading of x2 also

208
00:07:37,120 --> 00:07:39,280
requires activating and loading before

209
00:07:39,280 --> 00:07:40,240
reading

210
00:07:40,240 --> 00:07:42,160
as a result there are more operations in

211
00:07:42,160 --> 00:07:44,080
each following round of reading x1 and

212
00:07:44,080 --> 00:07:46,479
x2 and the time consumption goes to two

213
00:07:46,479 --> 00:07:49,199
times n times t x3 plus two times n

214
00:07:49,199 --> 00:07:52,639
times t to read and obviously t2 is

215
00:07:52,639 --> 00:07:55,199
greater than t1

216
00:07:55,199 --> 00:07:57,360
to conclude if wind is a high let's see

217
00:07:57,360 --> 00:07:59,199
when accessing two physical addresses in

218
00:07:59,199 --> 00:08:01,520
turn repeatedly they are definitely in

219
00:08:01,520 --> 00:08:03,520
the same bank with different roles this

220
00:08:03,520 --> 00:08:05,919
is the basis of our method

221
00:08:05,919 --> 00:08:07,840
so what can we infer when the two

222
00:08:07,840 --> 00:08:10,080
addresses are different only in specific

223
00:08:10,080 --> 00:08:12,479
big positions

224
00:08:12,479 --> 00:08:14,400
we can use the timing primitive to

225
00:08:14,400 --> 00:08:16,319
determine the physical address mapping

226
00:08:16,319 --> 00:08:18,319
but we have to do it bit by bit for

227
00:08:18,319 --> 00:08:20,800
example we want to know what b20 is in

228
00:08:20,800 --> 00:08:22,240
charge of

229
00:08:22,240 --> 00:08:24,000
we choose two physical addresses only

230
00:08:24,000 --> 00:08:26,000
different in bit 20 while the other bits

231
00:08:26,000 --> 00:08:27,599
are exactly the same

232
00:08:27,599 --> 00:08:30,560
we read x1 x and x2 in turn for a number

233
00:08:30,560 --> 00:08:31,919
of times

234
00:08:31,919 --> 00:08:34,399
in practice a thousand times of accesses

235
00:08:34,399 --> 00:08:36,559
already makes the result clear

236
00:08:36,559 --> 00:08:38,640
it will measure the time we use to do

237
00:08:38,640 --> 00:08:40,640
all the readings everyone needs a high

238
00:08:40,640 --> 00:08:43,360
latency in the in timing we know that x1

239
00:08:43,360 --> 00:08:45,040
and x2 are mapped to the same bank with

240
00:08:45,040 --> 00:08:47,040
different rows then we can conclude that

241
00:08:47,040 --> 00:08:49,040
b20 decides the row but it does not

242
00:08:49,040 --> 00:08:51,040
design the bank

243
00:08:51,040 --> 00:08:53,279
after doing the first test on all base

244
00:08:53,279 --> 00:08:55,760
positions we find that we find the bits

245
00:08:55,760 --> 00:08:57,920
that only control the row index and we

246
00:08:57,920 --> 00:09:00,160
call them the row bits

247
00:09:00,160 --> 00:09:02,240
or pick one of the row bits and and

248
00:09:02,240 --> 00:09:05,120
unknown bits to do the next tests

249
00:09:05,120 --> 00:09:06,720
again we choose two addresses that

250
00:09:06,720 --> 00:09:09,279
differ only in the chosen two bits

251
00:09:09,279 --> 00:09:12,000
in this case bit 20 and bit four

252
00:09:12,000 --> 00:09:13,200
then we'll read them in turn for a

253
00:09:13,200 --> 00:09:14,880
number of times

254
00:09:14,880 --> 00:09:17,200
if we win is a highlighting c

255
00:09:17,200 --> 00:09:19,920
in timing then the two addresses y1 and

256
00:09:19,920 --> 00:09:22,000
y2 are also in the same bank but

257
00:09:22,000 --> 00:09:23,360
different rows

258
00:09:23,360 --> 00:09:25,839
in previous tests we know that b20 is a

259
00:09:25,839 --> 00:09:27,680
row bit and has nothing to do with the

260
00:09:27,680 --> 00:09:30,480
bank and since changing bit 4 also does

261
00:09:30,480 --> 00:09:32,800
not change the bank b4 does not decide

262
00:09:32,800 --> 00:09:34,320
bank either

263
00:09:34,320 --> 00:09:36,480
bit4 is not aerobic it can only be a

264
00:09:36,480 --> 00:09:39,600
column which decides the column

265
00:09:39,600 --> 00:09:43,120
which only decides the column index

266
00:09:43,120 --> 00:09:45,519
we do the second test on all the unknown

267
00:09:45,519 --> 00:09:47,839
bits some of them will be recognized as

268
00:09:47,839 --> 00:09:50,399
column bits that's already identifies

269
00:09:50,399 --> 00:09:52,800
the robust as in blue and the column

270
00:09:52,800 --> 00:09:54,399
bits in yellow

271
00:09:54,399 --> 00:09:56,320
however we still have no idea what the

272
00:09:56,320 --> 00:09:59,040
white bits are they show low latency in

273
00:09:59,040 --> 00:10:01,680
both previous tests are they all bank

274
00:10:01,680 --> 00:10:04,320
bits which decide the bank index by

275
00:10:04,320 --> 00:10:06,720
themselves the answer is no

276
00:10:06,720 --> 00:10:08,560
in practice by simply counting the real

277
00:10:08,560 --> 00:10:10,959
bank number can we infer that the actual

278
00:10:10,959 --> 00:10:12,959
bank number of bank bits is smaller than

279
00:10:12,959 --> 00:10:15,920
the number of white bits here

280
00:10:15,920 --> 00:10:18,399
the truth is that in the physical

281
00:10:18,399 --> 00:10:20,480
address mappings there exists such a

282
00:10:20,480 --> 00:10:22,880
relationship such a relationship

283
00:10:22,880 --> 00:10:25,279
while the 18 decides the role the result

284
00:10:25,279 --> 00:10:28,720
of 18 extra bits 16

285
00:10:28,720 --> 00:10:30,720
or the size of the bank we call such a

286
00:10:30,720 --> 00:10:32,640
scheme xor scheme

287
00:10:32,640 --> 00:10:34,720
so how do we determine such an xor

288
00:10:34,720 --> 00:10:36,000
scheme

289
00:10:36,000 --> 00:10:37,600
similar to before we first pick two

290
00:10:37,600 --> 00:10:38,640
addresses

291
00:10:38,640 --> 00:10:41,600
only different in bits 18 and bit 16.

292
00:10:41,600 --> 00:10:43,760
the 18 and bit 16 are both the white

293
00:10:43,760 --> 00:10:46,079
space whose job we do not know from the

294
00:10:46,079 --> 00:10:48,240
previous two tests

295
00:10:48,240 --> 00:10:50,399
we read them in turn

296
00:10:50,399 --> 00:10:52,880
let's say the timing of x into them

297
00:10:52,880 --> 00:10:54,720
as before if

298
00:10:54,720 --> 00:10:56,880
a high latency is witnessed they are

299
00:10:56,880 --> 00:10:58,240
again in the same bank but different

300
00:10:58,240 --> 00:11:01,360
routes in other words either bit 18 or

301
00:11:01,360 --> 00:11:03,440
bit 16 decides to roll

302
00:11:03,440 --> 00:11:05,680
however row bits tend to be higher bits

303
00:11:05,680 --> 00:11:07,360
for efficiency issues

304
00:11:07,360 --> 00:11:09,120
putting row base on higher positions

305
00:11:09,120 --> 00:11:11,600
help reduce the bank direction

306
00:11:11,600 --> 00:11:13,360
bank threshing means frequently changing

307
00:11:13,360 --> 00:11:16,000
a bank's currently activated row

308
00:11:16,000 --> 00:11:18,880
so in this tank so in this case we take

309
00:11:18,880 --> 00:11:22,160
18 to be aerobic however b18 has more

310
00:11:22,160 --> 00:11:23,680
jobs than simply designing the road

311
00:11:23,680 --> 00:11:25,920
index that's why we didn't recognize it

312
00:11:25,920 --> 00:11:28,160
in the previous bit row bit detection

313
00:11:28,160 --> 00:11:30,079
tests

314
00:11:30,079 --> 00:11:31,920
let's take a comprehensive look at the

315
00:11:31,920 --> 00:11:33,680
choose we already know

316
00:11:33,680 --> 00:11:35,680
this one is the result of the previous

317
00:11:35,680 --> 00:11:39,200
low bit detection tests and b18 is the

318
00:11:39,200 --> 00:11:40,720
only different

319
00:11:40,720 --> 00:11:43,040
base in the two tested addresses y1 and

320
00:11:43,040 --> 00:11:47,279
y2 while bit 16 remains constant

321
00:11:47,279 --> 00:11:49,680
however x1 and x2 cannot be in the same

322
00:11:49,680 --> 00:11:51,600
bank in the same row because the 18

323
00:11:51,600 --> 00:11:52,959
decides so

324
00:11:52,959 --> 00:11:55,040
so they can only be in different rows

325
00:11:55,040 --> 00:11:57,440
also in different banks

326
00:11:57,440 --> 00:11:59,600
test two and test three are the current

327
00:11:59,600 --> 00:12:02,320
tests we are taking we change both

328
00:12:02,320 --> 00:12:05,040
both 18 and bit 16 in the two tested

329
00:12:05,040 --> 00:12:06,480
addresses

330
00:12:06,480 --> 00:12:09,200
we know that c1 and z2 are in the same

331
00:12:09,200 --> 00:12:10,880
bank but different rows

332
00:12:10,880 --> 00:12:13,120
now let's calculate the value of

333
00:12:13,120 --> 00:12:16,079
18 extra bit 16 and let's focus on the

334
00:12:16,079 --> 00:12:19,040
the extra column and the back column

335
00:12:19,040 --> 00:12:20,959
with this simple table it is clear that

336
00:12:20,959 --> 00:12:24,160
the result of bits 18 xor 16 decides

337
00:12:24,160 --> 00:12:25,839
their bank index

338
00:12:25,839 --> 00:12:28,240
thus such a setting of xor's game is

339
00:12:28,240 --> 00:12:30,959
corresponding to our test results

340
00:12:30,959 --> 00:12:32,720
however this is just the most basic

341
00:12:32,720 --> 00:12:35,440
version of the exo scheme

342
00:12:35,440 --> 00:12:37,519
there exists such complicated mapping

343
00:12:37,519 --> 00:12:39,839
schemes involving multiple xors in these

344
00:12:39,839 --> 00:12:42,160
cases our graph-based bit detection

345
00:12:42,160 --> 00:12:45,120
algorithm is required to decode them

346
00:12:45,120 --> 00:12:47,040
on the right are the schemes and on the

347
00:12:47,040 --> 00:12:49,519
left are the corresponding graphs

348
00:12:49,519 --> 00:12:51,360
however there's no

349
00:12:51,360 --> 00:12:53,279
not enough time to cover them more so

350
00:12:53,279 --> 00:12:54,959
please refer to our paper for more

351
00:12:54,959 --> 00:12:56,959
details

352
00:12:56,959 --> 00:12:58,959
after we have the knowledge of how a

353
00:12:58,959 --> 00:13:00,959
physical address is mapped to the dram

354
00:13:00,959 --> 00:13:02,880
we are able to do accurate and powerful

355
00:13:02,880 --> 00:13:05,040
double-sided hammer attacks

356
00:13:05,040 --> 00:13:06,959
and now our next step is to make as much

357
00:13:06,959 --> 00:13:09,839
use as it possible uh to do the hacking

358
00:13:09,839 --> 00:13:12,320
in the crossbeam settings

359
00:13:12,320 --> 00:13:14,480
cross vmware camera exploitation catches

360
00:13:14,480 --> 00:13:17,040
our eyes because virtualization is the

361
00:13:17,040 --> 00:13:19,680
core of cloud computing let's take the

362
00:13:19,680 --> 00:13:22,959
zen-based cloud services as an example

363
00:13:22,959 --> 00:13:24,560
a physical machine provides services

364
00:13:24,560 --> 00:13:26,480
with virtual machines to the users in

365
00:13:26,480 --> 00:13:28,000
all virtual machines on a single

366
00:13:28,000 --> 00:13:29,680
physical machine is managed by the

367
00:13:29,680 --> 00:13:31,519
hypervisor

368
00:13:31,519 --> 00:13:33,600
our attack technique is proven effective

369
00:13:33,600 --> 00:13:36,399
understand pair virtualized settings

370
00:13:36,399 --> 00:13:38,880
and then pv is widely in use by multiple

371
00:13:38,880 --> 00:13:41,760
cloud service providers including amazon

372
00:13:41,760 --> 00:13:44,480
ec2 and rackspace

373
00:13:44,480 --> 00:13:46,720
in the zengus vm the physical addresses

374
00:13:46,720 --> 00:13:48,560
used by the kernel are no longer the

375
00:13:48,560 --> 00:13:50,800
real physical address of the hardware we

376
00:13:50,800 --> 00:13:52,480
call them pseudo physical addresses

377
00:13:52,480 --> 00:13:54,079
while the real physical addresses are

378
00:13:54,079 --> 00:13:56,240
called machine pages

379
00:13:56,240 --> 00:13:59,920
if not in non-virtualized settings

380
00:13:59,920 --> 00:14:01,680
a virtual address can be converted into

381
00:14:01,680 --> 00:14:03,120
a physical address by looking at the

382
00:14:03,120 --> 00:14:04,480
page tables

383
00:14:04,480 --> 00:14:06,880
luckily in the mpv we are also able to

384
00:14:06,880 --> 00:14:09,360
do so to get the machine addresses

385
00:14:09,360 --> 00:14:11,440
there's there is only one layer of the

386
00:14:11,440 --> 00:14:14,480
page tables of exam pv and this is the

387
00:14:14,480 --> 00:14:17,120
basis of our double cellular hammer

388
00:14:17,120 --> 00:14:19,440
it's more all the entries in these page

389
00:14:19,440 --> 00:14:22,880
tables point to machine page addresses

390
00:14:22,880 --> 00:14:25,199
and another important point is that all

391
00:14:25,199 --> 00:14:27,120
these page tables are directly

392
00:14:27,120 --> 00:14:30,560
maintained in the guest memory space

393
00:14:30,560 --> 00:14:32,480
now let's go a little deeper into page

394
00:14:32,480 --> 00:14:34,079
tables

395
00:14:34,079 --> 00:14:35,920
a virtual address is divided into

396
00:14:35,920 --> 00:14:38,240
several segments each segment is an

397
00:14:38,240 --> 00:14:40,079
offset to a certain level of page table

398
00:14:40,079 --> 00:14:42,399
or to a normal machine page

399
00:14:42,399 --> 00:14:44,320
when looking at the machine addresses

400
00:14:44,320 --> 00:14:45,920
the kernel first gets

401
00:14:45,920 --> 00:14:48,800
the the address of pgd from the gesture

402
00:14:48,800 --> 00:14:51,680
then it uses the pgd offset segment to

403
00:14:51,680 --> 00:14:53,920
find the pcb entry containing the edges

404
00:14:53,920 --> 00:14:56,800
of pud the look cap continues in similar

405
00:14:56,800 --> 00:14:58,880
ways until it finally gets the machine

406
00:14:58,880 --> 00:15:00,320
address

407
00:15:00,320 --> 00:15:02,160
although all page tables are directly

408
00:15:02,160 --> 00:15:04,240
maintained in the gas memory space they

409
00:15:04,240 --> 00:15:06,560
are read only to the gas kernel

410
00:15:06,560 --> 00:15:08,800
all the changes to the page table

411
00:15:08,800 --> 00:15:12,000
need to be checked by the hypervisor

412
00:15:12,000 --> 00:15:13,920
when when a guest wish to modify its

413
00:15:13,920 --> 00:15:16,320
page tables you need to make a hypercall

414
00:15:16,320 --> 00:15:18,800
to the hypervisor and the hypervisor

415
00:15:18,800 --> 00:15:21,040
will check whether all pages pointed to

416
00:15:21,040 --> 00:15:23,760
by page tables no matter a lower level

417
00:15:23,760 --> 00:15:26,160
page table or a normal machine page or

418
00:15:26,160 --> 00:15:28,959
in control of the requesting guest

419
00:15:28,959 --> 00:15:30,639
if the check passes the changes are

420
00:15:30,639 --> 00:15:32,639
permitted and the controls are given

421
00:15:32,639 --> 00:15:34,160
back to the guests

422
00:15:34,160 --> 00:15:36,160
if not it is not allowed and there will

423
00:15:36,160 --> 00:15:38,639
be a vote

424
00:15:38,639 --> 00:15:40,639
knowing how the mpv manages the memory

425
00:15:40,639 --> 00:15:42,320
we can now talk about how we explore

426
00:15:42,320 --> 00:15:44,880
arbitrary memory access regardless of vm

427
00:15:44,880 --> 00:15:47,279
isolation by using your camera

428
00:15:47,279 --> 00:15:49,600
the attacker is a normal guest vm and

429
00:15:49,600 --> 00:15:52,160
the goal is to be able to to visit any

430
00:15:52,160 --> 00:15:54,800
member page on that machine before we do

431
00:15:54,800 --> 00:15:56,880
the attack we can visit a legal machine

432
00:15:56,880 --> 00:15:58,639
page controlled by the attacker by its

433
00:15:58,639 --> 00:15:59,920
virtual address

434
00:15:59,920 --> 00:16:01,759
everything inside the dashed boundary

435
00:16:01,759 --> 00:16:04,639
here belongs to the attack vm

436
00:16:04,639 --> 00:16:06,800
the first step is to forge a last level

437
00:16:06,800 --> 00:16:08,240
page table where there's entries

438
00:16:08,240 --> 00:16:10,560
pointing to arbitrary page regardless of

439
00:16:10,560 --> 00:16:13,600
whether it is controlled by the attacker

440
00:16:13,600 --> 00:16:15,680
the most similar trick here is that the

441
00:16:15,680 --> 00:16:18,320
forger pt has the same machine address

442
00:16:18,320 --> 00:16:21,600
as the original pc except one single bit

443
00:16:21,600 --> 00:16:24,399
in a specified position for example on

444
00:16:24,399 --> 00:16:27,120
the screen the address of pt and forger

445
00:16:27,120 --> 00:16:30,160
pt only differing bit 18. the reason to

446
00:16:30,160 --> 00:16:33,600
choose 18 will be soon explained

447
00:16:33,600 --> 00:16:35,120
let's go back here and move on to the

448
00:16:35,120 --> 00:16:36,880
next snap

449
00:16:36,880 --> 00:16:39,040
the second step is to copy the pmd the

450
00:16:39,040 --> 00:16:40,800
second level playstable into the

451
00:16:40,800 --> 00:16:42,720
vulnerable motion page containing a

452
00:16:42,720 --> 00:16:44,079
flippable bit

453
00:16:44,079 --> 00:16:46,160
the flip of a bit should be should lie

454
00:16:46,160 --> 00:16:49,360
in the entry point into pt

455
00:16:49,360 --> 00:16:51,360
and the position of the flip of it in

456
00:16:51,360 --> 00:16:54,000
the pnd entry should be the same as the

457
00:16:54,000 --> 00:16:55,839
difference between the addresses of pt

458
00:16:55,839 --> 00:16:57,600
and folder pt

459
00:16:57,600 --> 00:16:59,680
in fact we need to find the flip up a

460
00:16:59,680 --> 00:17:02,079
bit before we do the attack and we

461
00:17:02,079 --> 00:17:04,160
decide the bit index based on the

462
00:17:04,160 --> 00:17:08,000
position of this flip-up bits

463
00:17:08,079 --> 00:17:10,400
from now on we call the vulnerable page

464
00:17:10,400 --> 00:17:12,880
shadow pmd

465
00:17:12,880 --> 00:17:15,039
since the shadow pmd is exactly the same

466
00:17:15,039 --> 00:17:17,280
as the original pmd we can safely

467
00:17:17,280 --> 00:17:19,439
replace the uh replace the original one

468
00:17:19,439 --> 00:17:21,919
with the shadow pmd via hypercall the

469
00:17:21,919 --> 00:17:25,359
hypervisor won't notice anything wrong

470
00:17:25,359 --> 00:17:27,359
now let's pay attention to the red arrow

471
00:17:27,359 --> 00:17:30,480
and the flipper bit in the pmd entry now

472
00:17:30,480 --> 00:17:32,799
here comes our camera

473
00:17:32,799 --> 00:17:35,840
by hammering the entry of the shadow pmd

474
00:17:35,840 --> 00:17:38,799
ps18 is flipped

475
00:17:38,799 --> 00:17:41,280
since the new page equal response now is

476
00:17:41,280 --> 00:17:43,919
as the photo pt we successfully bypass

477
00:17:43,919 --> 00:17:45,600
the surveillance of the hypervisor and

478
00:17:45,600 --> 00:17:48,480
put the folder pt into use instead of

479
00:17:48,480 --> 00:17:50,160
the original pt

480
00:17:50,160 --> 00:17:52,240
and any access to the original virtual

481
00:17:52,240 --> 00:17:54,240
address will finally touch an arbitrary

482
00:17:54,240 --> 00:17:55,360
page

483
00:17:55,360 --> 00:17:57,600
what's more we still have right access

484
00:17:57,600 --> 00:17:59,679
to the for the pt since the kernel and

485
00:17:59,679 --> 00:18:02,400
the provider both still regard it as a

486
00:18:02,400 --> 00:18:05,120
normal page it means that we literally

487
00:18:05,120 --> 00:18:09,120
can access any page we want to visit

488
00:18:09,120 --> 00:18:11,360
after having access to arbitrary pages

489
00:18:11,360 --> 00:18:13,520
we are now able to conduct numerous

490
00:18:13,520 --> 00:18:14,400
interesting

491
00:18:14,400 --> 00:18:15,520
attacks

492
00:18:15,520 --> 00:18:18,080
there are two such examples in our paper

493
00:18:18,080 --> 00:18:20,240
but i can only present you with one of

494
00:18:20,240 --> 00:18:22,559
them since the time is limited if you

495
00:18:22,559 --> 00:18:24,720
are interested please refer to our to

496
00:18:24,720 --> 00:18:28,160
our paper for more content

497
00:18:28,160 --> 00:18:30,480
um coincidentally and interesting the

498
00:18:30,480 --> 00:18:31,760
open

499
00:18:31,760 --> 00:18:35,280
accessory edge is the target again but

500
00:18:35,280 --> 00:18:37,919
in a different much different way

501
00:18:37,919 --> 00:18:39,919
our sample attack is to bypass the

502
00:18:39,919 --> 00:18:42,240
authentication when logging onto an open

503
00:18:42,240 --> 00:18:43,679
ss server

504
00:18:43,679 --> 00:18:46,240
the prerequisite is that the attacker vm

505
00:18:46,240 --> 00:18:48,400
shares the same physical machine with

506
00:18:48,400 --> 00:18:51,360
the openssh server vm

507
00:18:51,360 --> 00:18:53,600
our primary goal is to log on to the

508
00:18:53,600 --> 00:18:56,000
openss server without legal credentials

509
00:18:56,000 --> 00:18:58,000
by modifying some of the code of the

510
00:18:58,000 --> 00:18:59,520
server process

511
00:18:59,520 --> 00:19:01,280
shown in figure is a snippet of the

512
00:19:01,280 --> 00:19:04,320
coding assembly notice that the second

513
00:19:04,320 --> 00:19:06,559
line in the graph is a judgment of

514
00:19:06,559 --> 00:19:08,000
whether the authentication results

515
00:19:08,000 --> 00:19:11,600
stored in register eax is zero

516
00:19:11,600 --> 00:19:14,240
if not the authentication fails so our

517
00:19:14,240 --> 00:19:16,160
target is to change the code so that

518
00:19:16,160 --> 00:19:17,679
every time the authentication is

519
00:19:17,679 --> 00:19:18,880
requested

520
00:19:18,880 --> 00:19:21,760
eax always can always contain zero as a

521
00:19:21,760 --> 00:19:23,440
result

522
00:19:23,440 --> 00:19:25,360
originally the first line of the code

523
00:19:25,360 --> 00:19:26,960
calls the function

524
00:19:26,960 --> 00:19:29,039
pam authenticate to allow password

525
00:19:29,039 --> 00:19:31,200
authentication and it stores the

526
00:19:31,200 --> 00:19:34,160
authentication results in eax

527
00:19:34,160 --> 00:19:36,720
we change it into directly writing 0 to

528
00:19:36,720 --> 00:19:37,520
that

529
00:19:37,520 --> 00:19:39,280
to the register

530
00:19:39,280 --> 00:19:41,200
the machine code of both instructions

531
00:19:41,200 --> 00:19:43,200
are 5 bytes long so it is a perfect

532
00:19:43,200 --> 00:19:44,559
replacement

533
00:19:44,559 --> 00:19:47,039
now let's see in detail how the attacker

534
00:19:47,039 --> 00:19:49,919
how the attack is brought out

535
00:19:49,919 --> 00:19:52,640
our attack applies to the demon sshd

536
00:19:52,640 --> 00:19:54,640
process so that all the all the all the

537
00:19:54,640 --> 00:19:56,640
connections afterwards will bypass

538
00:19:56,640 --> 00:19:58,400
authentication

539
00:19:58,400 --> 00:20:00,480
first of all the attacker vm conducts

540
00:20:00,480 --> 00:20:02,000
the pitch table replacement attack

541
00:20:02,000 --> 00:20:04,880
described in section 2 and tries to gain

542
00:20:04,880 --> 00:20:07,280
access to the memory space of the server

543
00:20:07,280 --> 00:20:08,720
vm

544
00:20:08,720 --> 00:20:10,480
then the searches for the five byte

545
00:20:10,480 --> 00:20:12,240
machine code are called pam

546
00:20:12,240 --> 00:20:13,840
authenticates

547
00:20:13,840 --> 00:20:15,679
although the five byte pattern seems to

548
00:20:15,679 --> 00:20:17,840
to be true short we found that it was

549
00:20:17,840 --> 00:20:20,559
unique our on our experimental mission

550
00:20:20,559 --> 00:20:22,320
in our tests

551
00:20:22,320 --> 00:20:24,240
once the pattern is found we change the

552
00:20:24,240 --> 00:20:26,960
code into move 0 to eax by directly

553
00:20:26,960 --> 00:20:29,039
writing to the memory

554
00:20:29,039 --> 00:20:31,120
by then we finish our attack

555
00:20:31,120 --> 00:20:32,640
the time consumption of our attack

556
00:20:32,640 --> 00:20:34,480
depends on how many pages we need to

557
00:20:34,480 --> 00:20:35,360
search

558
00:20:35,360 --> 00:20:37,440
if the code is the first page research

559
00:20:37,440 --> 00:20:40,080
the complete attack takes only about 0.3

560
00:20:40,080 --> 00:20:43,840
seconds and to search one extra 4kb page

561
00:20:43,840 --> 00:20:45,440
will take about

562
00:20:45,440 --> 00:20:46,840
58

563
00:20:46,840 --> 00:20:49,760
microseconds now let's see a demo of our

564
00:20:49,760 --> 00:20:52,158
attack

565
00:20:55,520 --> 00:20:58,240
before we do the attack we open the

566
00:20:58,240 --> 00:21:00,400
terminal of the vm on the test mission

567
00:21:00,400 --> 00:21:03,039
and try logging onto the server vm also

568
00:21:03,039 --> 00:21:05,520
on the same machine however we cannot

569
00:21:05,520 --> 00:21:07,200
log in because we do not have the

570
00:21:07,200 --> 00:21:08,960
password it will try different

571
00:21:08,960 --> 00:21:11,200
authentication methods but anyway we

572
00:21:11,200 --> 00:21:13,760
cannot be in

573
00:21:13,760 --> 00:21:16,159
and at this moment we do the attack from

574
00:21:16,159 --> 00:21:18,480
another from another vm on the same

575
00:21:18,480 --> 00:21:19,520
machine

576
00:21:19,520 --> 00:21:21,520
we first conduct the page table

577
00:21:21,520 --> 00:21:22,960
replacement attack

578
00:21:22,960 --> 00:21:24,960
we need to map a memory buffer to find

579
00:21:24,960 --> 00:21:27,760
the pages that meet our requirements

580
00:21:27,760 --> 00:21:29,600
after the preparation is done we do the

581
00:21:29,600 --> 00:21:32,400
real camera thus we have opportunity

582
00:21:32,400 --> 00:21:34,960
access and start searching for the 5

583
00:21:34,960 --> 00:21:36,159
pattern

584
00:21:36,159 --> 00:21:38,559
once it's found we change it into

585
00:21:38,559 --> 00:21:42,000
move 0 to eax and so

586
00:21:42,000 --> 00:21:46,159
now we can try log in again

587
00:21:47,200 --> 00:21:49,679
we are directly in the server without

588
00:21:49,679 --> 00:21:52,480
inputting anything

589
00:21:55,039 --> 00:21:57,280
there are a number of existing measures

590
00:21:57,280 --> 00:21:59,039
against your camera attacks

591
00:21:59,039 --> 00:22:02,799
ecc is a common solution and enables the

592
00:22:02,799 --> 00:22:05,280
memory to do single error correction or

593
00:22:05,280 --> 00:22:07,120
double error detection

594
00:22:07,120 --> 00:22:09,679
ddr4 was once thought to be immune but

595
00:22:09,679 --> 00:22:12,400
it was also proven vulnerable recently

596
00:22:12,400 --> 00:22:15,520
since trr is removed from the ddr4

597
00:22:15,520 --> 00:22:16,799
center

598
00:22:16,799 --> 00:22:18,960
using hardware assisted virtualization

599
00:22:18,960 --> 00:22:21,600
adds an extra layer of page levels and

600
00:22:21,600 --> 00:22:22,559
heights

601
00:22:22,559 --> 00:22:25,120
on the real machine address from the gas

602
00:22:25,120 --> 00:22:26,559
kernel

603
00:22:26,559 --> 00:22:28,640
but it's replacing the mpv is rather

604
00:22:28,640 --> 00:22:32,720
slow for efficiency or other issues

605
00:22:32,720 --> 00:22:35,280
to conclude we use timing channel to

606
00:22:35,280 --> 00:22:37,360
reverse engineer the physical address

607
00:22:37,360 --> 00:22:39,760
mapping to the dram and double sided

608
00:22:39,760 --> 00:22:42,640
hammer is possible only on this basis

609
00:22:42,640 --> 00:22:45,120
and we successfully break the

610
00:22:45,120 --> 00:22:47,840
break the zmpv memory isolation by your

611
00:22:47,840 --> 00:22:49,039
hammer

612
00:22:49,039 --> 00:22:50,559
further attacks were

613
00:22:50,559 --> 00:22:52,720
also proven viable that's so much of

614
00:22:52,720 --> 00:22:54,159
today thank you all for coming and

615
00:22:54,159 --> 00:22:57,120
listening to my presentation

616
00:22:57,120 --> 00:22:57,710
this is great

617
00:22:57,710 --> 00:23:04,720
[Applause]

618
00:23:04,720 --> 00:23:08,400
so again we have time for some questions

619
00:23:08,400 --> 00:23:10,559
so i guess i can start also um so what

620
00:23:10,559 --> 00:23:12,159
would what would it take to fix these

621
00:23:12,159 --> 00:23:14,080
drams so these rowhammer attacks are not

622
00:23:14,080 --> 00:23:16,000
possible

623
00:23:16,000 --> 00:23:18,720
um you mean the measures well these are

624
00:23:18,720 --> 00:23:19,600
counter measures that would be

625
00:23:19,600 --> 00:23:21,600
implemented in the memory controller but

626
00:23:21,600 --> 00:23:22,400
could you

627
00:23:22,400 --> 00:23:24,240
would you do these in dram or why aren't

628
00:23:24,240 --> 00:23:26,400
you implemented today

629
00:23:26,400 --> 00:23:28,720
um

630
00:23:29,919 --> 00:23:32,240
actually um can you repeat your question

631
00:23:32,240 --> 00:23:34,159
once well why aren't these

632
00:23:34,159 --> 00:23:35,840
countermeasures already in place today

633
00:23:35,840 --> 00:23:38,159
so that the attack would not be possible

634
00:23:38,159 --> 00:23:41,120
all right because um actually our attack

635
00:23:41,120 --> 00:23:43,600
is still about real hammer and it's just

636
00:23:43,600 --> 00:23:46,080
a more powerful type

637
00:23:46,080 --> 00:23:48,799
by the double-sided hammer and the

638
00:23:48,799 --> 00:23:50,799
existing column measures

639
00:23:50,799 --> 00:23:54,080
um makes the hammer attacks much harder

640
00:23:54,080 --> 00:23:56,880
but still um they cannot be fully

641
00:23:56,880 --> 00:23:58,159
exterminated

642
00:23:58,159 --> 00:23:59,679
and if we

643
00:23:59,679 --> 00:24:02,559
apply these conversions correctly

644
00:24:02,559 --> 00:24:05,919
then um of course our attack may also

645
00:24:05,919 --> 00:24:08,000
lose our loose effects

646
00:24:08,000 --> 00:24:12,480
however like i said uh uh like the hvm

647
00:24:12,480 --> 00:24:15,360
is a perfect uh protection against our

648
00:24:15,360 --> 00:24:16,960
attack however

649
00:24:16,960 --> 00:24:18,559
for some

650
00:24:18,559 --> 00:24:22,000
uh for f3m is slightly slower than pv

651
00:24:22,000 --> 00:24:23,200
and also

652
00:24:23,200 --> 00:24:26,000
some cloud providers are hesitant to

653
00:24:26,000 --> 00:24:30,080
switch to hvm for other issues like the

654
00:24:30,080 --> 00:24:34,000
cost issues money issues so it's um

655
00:24:34,000 --> 00:24:35,840
actually the protection against the

656
00:24:35,840 --> 00:24:38,080
hammer are rather slow

657
00:24:38,080 --> 00:24:41,360
well um of course uh i think most of the

658
00:24:41,360 --> 00:24:44,080
cloud providers are now using eccd ramps

659
00:24:44,080 --> 00:24:46,320
in their servers

660
00:24:46,320 --> 00:24:49,360
but we still suggest that all the cloud

661
00:24:49,360 --> 00:24:52,159
providers can switch to svm for the

662
00:24:52,159 --> 00:24:54,400
um security rather than

663
00:24:54,400 --> 00:24:58,000
um just sticking to the pv

664
00:24:58,000 --> 00:24:59,360
to save money

665
00:24:59,360 --> 00:25:00,559
yup yup

666
00:25:00,559 --> 00:25:02,480
makes sense thanks a lot any other

667
00:25:02,480 --> 00:25:04,799
questions

668
00:25:04,799 --> 00:25:06,080
okay in that case let's thank the

669
00:25:06,080 --> 00:25:07,679
speaker again thank you

670
00:25:07,679 --> 00:25:10,840
thank you

