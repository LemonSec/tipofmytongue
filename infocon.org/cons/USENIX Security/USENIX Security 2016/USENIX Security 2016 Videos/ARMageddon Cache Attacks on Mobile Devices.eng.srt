1
00:00:10,559 --> 00:00:12,000
so i will start right away with an

2
00:00:12,000 --> 00:00:13,280
overview

3
00:00:13,280 --> 00:00:15,599
we had powerful cache attacks like flash

4
00:00:15,599 --> 00:00:17,760
and reload like prime and probe on x86

5
00:00:17,760 --> 00:00:20,720
in a not in a few last years and

6
00:00:20,720 --> 00:00:23,359
we have no not seen any powerful cache

7
00:00:23,359 --> 00:00:25,680
attacks like this on arm cpus and on

8
00:00:25,680 --> 00:00:28,720
mobile devices and we asked the question

9
00:00:28,720 --> 00:00:30,560
why is that why are there no such

10
00:00:30,560 --> 00:00:33,040
powerful attacks there and we started

11
00:00:33,040 --> 00:00:35,360
identifying the challenges and solving

12
00:00:35,360 --> 00:00:38,000
them systematically

13
00:00:38,000 --> 00:00:40,320
we find that we can make all cash

14
00:00:40,320 --> 00:00:42,879
attacks work on armed cpus as well it

15
00:00:42,879 --> 00:00:45,760
depends on the arm cpu which specific

16
00:00:45,760 --> 00:00:47,520
attacks work better or

17
00:00:47,520 --> 00:00:50,399
maybe don't work um

18
00:00:50,399 --> 00:00:52,480
we can use those attacks on android

19
00:00:52,480 --> 00:00:54,719
phones to monitor user activity like

20
00:00:54,719 --> 00:00:55,760
swipes

21
00:00:55,760 --> 00:00:58,480
we can determine the length of the swipe

22
00:00:58,480 --> 00:01:01,359
we can distinguish key presses from

23
00:01:01,359 --> 00:01:03,520
swipes so we can do all sort of

24
00:01:03,520 --> 00:01:05,920
user activity monitoring

25
00:01:05,920 --> 00:01:09,040
we also found that on android you still

26
00:01:09,040 --> 00:01:12,000
have weak crypto because no one knows

27
00:01:12,000 --> 00:01:12,720
that

28
00:01:12,720 --> 00:01:15,759
that armed cpus are very vulnerable to

29
00:01:15,759 --> 00:01:18,159
those cache side channel attacks as well

30
00:01:18,159 --> 00:01:20,000
so no one thinks about

31
00:01:20,000 --> 00:01:22,080
implementing crypto in a safe way so

32
00:01:22,080 --> 00:01:24,320
they still use t tables on android in

33
00:01:24,320 --> 00:01:26,240
some cases

34
00:01:26,240 --> 00:01:28,320
and then we also thought okay we might

35
00:01:28,320 --> 00:01:31,200
check out whether we can attack the arm

36
00:01:31,200 --> 00:01:33,360
trust zone and then we found that

37
00:01:33,360 --> 00:01:35,280
depending on what happens inside the

38
00:01:35,280 --> 00:01:36,880
trust zone we can see a difference in

39
00:01:36,880 --> 00:01:38,079
the

40
00:01:38,079 --> 00:01:39,920
in the cache by doing a prime and probe

41
00:01:39,920 --> 00:01:40,880
attack

42
00:01:40,880 --> 00:01:43,840
so what is a cache attack basically we

43
00:01:43,840 --> 00:01:46,880
look at the timing the access time of

44
00:01:46,880 --> 00:01:49,200
memory access and there we can

45
00:01:49,200 --> 00:01:52,640
distinguish cash hits and cash misses

46
00:01:52,640 --> 00:01:54,799
and cache hits are those memory accesses

47
00:01:54,799 --> 00:01:56,479
that are already buffered in the cache

48
00:01:56,479 --> 00:01:58,560
hash misses are those that have to be

49
00:01:58,560 --> 00:02:00,479
served from the dram so they take more

50
00:02:00,479 --> 00:02:02,719
time and here you can see that they are

51
00:02:02,719 --> 00:02:03,920
very well

52
00:02:03,920 --> 00:02:06,159
distinguishable

53
00:02:06,159 --> 00:02:08,160
yeah this is a log scale so it's really

54
00:02:08,160 --> 00:02:10,160
very well distinguishable what can you

55
00:02:10,160 --> 00:02:12,160
do with that imagine that you have a

56
00:02:12,160 --> 00:02:15,920
shared library and you would acquire um

57
00:02:15,920 --> 00:02:18,319
you would write a program that that

58
00:02:18,319 --> 00:02:20,000
opens this shared library and maps it

59
00:02:20,000 --> 00:02:22,640
into memory

60
00:02:22,640 --> 00:02:24,959
then if another program uses the same

61
00:02:24,959 --> 00:02:26,640
shared library for instance to process

62
00:02:26,640 --> 00:02:28,400
keystrokes something like this could

63
00:02:28,400 --> 00:02:30,319
happen so you can see the key down and

64
00:02:30,319 --> 00:02:32,239
the key up events here

65
00:02:32,239 --> 00:02:33,360
and

66
00:02:33,360 --> 00:02:35,120
basically you can

67
00:02:35,120 --> 00:02:38,080
you can make something up from that by

68
00:02:38,080 --> 00:02:40,879
by using those inter key stroke timings

69
00:02:40,879 --> 00:02:45,120
to derive whatever the user entered

70
00:02:45,120 --> 00:02:47,280
there are also more powerful attacks

71
00:02:47,280 --> 00:02:50,080
like this so in some cases you can even

72
00:02:50,080 --> 00:02:51,200
single out

73
00:02:51,200 --> 00:02:53,920
some of the keys so you can you can

74
00:02:53,920 --> 00:02:55,519
determine that the users

75
00:02:55,519 --> 00:02:57,200
press the specific key depending on the

76
00:02:57,200 --> 00:02:59,920
library that you're using so these

77
00:02:59,920 --> 00:03:02,400
attacks are really powerful

78
00:03:02,400 --> 00:03:05,040
the most important techniques that we

79
00:03:05,040 --> 00:03:07,280
use today are flush and reload and prime

80
00:03:07,280 --> 00:03:09,840
and probe both of them work on the last

81
00:03:09,840 --> 00:03:12,159
level cache and both work across cores

82
00:03:12,159 --> 00:03:13,599
for this reason

83
00:03:13,599 --> 00:03:15,519
flash and reload works like this so you

84
00:03:15,519 --> 00:03:17,360
have an attacker address space and a

85
00:03:17,360 --> 00:03:19,120
victim address space and a cache in the

86
00:03:19,120 --> 00:03:20,800
middle and

87
00:03:20,800 --> 00:03:22,879
if you access a memory location it will

88
00:03:22,879 --> 00:03:25,200
be cached in in your cache and it will

89
00:03:25,200 --> 00:03:26,879
be cached for both at the same time

90
00:03:26,879 --> 00:03:30,000
because the cpu cache is shared

91
00:03:30,000 --> 00:03:32,400
it will be shared in the cache as well

92
00:03:32,400 --> 00:03:33,760
the shared memory

93
00:03:33,760 --> 00:03:35,920
so now the attacker can just remove it

94
00:03:35,920 --> 00:03:38,319
from the cache this this particular

95
00:03:38,319 --> 00:03:39,440
cache line

96
00:03:39,440 --> 00:03:40,480
and

97
00:03:40,480 --> 00:03:41,440
then the

98
00:03:41,440 --> 00:03:43,840
if the victim reloads the data

99
00:03:43,840 --> 00:03:46,239
the attacker can also reload the data

100
00:03:46,239 --> 00:03:48,799
and notices that now it is not a cache

101
00:03:48,799 --> 00:03:51,360
miss but a cache hit so the victim must

102
00:03:51,360 --> 00:03:53,920
have reloaded this particular cache line

103
00:03:53,920 --> 00:03:56,480
this specific memory location and this

104
00:03:56,480 --> 00:03:59,200
has a granularity of 64 bytes and you

105
00:03:59,200 --> 00:04:01,280
can do this in a really high resolution

106
00:04:01,280 --> 00:04:03,120
so you can monitor what the victim

107
00:04:03,120 --> 00:04:06,239
process does on a 64 byte granularity

108
00:04:06,239 --> 00:04:08,480
at a higher frequency

109
00:04:08,480 --> 00:04:10,080
the prime and probe attack works a bit

110
00:04:10,080 --> 00:04:11,760
different so the primary pro attack does

111
00:04:11,760 --> 00:04:14,159
not require shared memory instead here

112
00:04:14,159 --> 00:04:16,880
you fill an entire cache set and then

113
00:04:16,880 --> 00:04:19,199
you have the victim do some computation

114
00:04:19,199 --> 00:04:20,720
and replacing

115
00:04:20,720 --> 00:04:22,240
memory

116
00:04:22,240 --> 00:04:24,080
cache lines in

117
00:04:24,080 --> 00:04:26,960
this particular cache set and if the

118
00:04:26,960 --> 00:04:29,600
attacker now tries to re-access it its

119
00:04:29,600 --> 00:04:32,639
own memory locations uh you will first

120
00:04:32,639 --> 00:04:35,360
see fast access and then maybe a slow

121
00:04:35,360 --> 00:04:37,680
access and then then the attacker knows

122
00:04:37,680 --> 00:04:40,160
that the victim has done some specific

123
00:04:40,160 --> 00:04:42,960
operation on addresses congruent to this

124
00:04:42,960 --> 00:04:44,639
cache set

125
00:04:44,639 --> 00:04:46,960
how are caches today organized if you

126
00:04:46,960 --> 00:04:48,800
look at an intel cpu you will have three

127
00:04:48,800 --> 00:04:51,280
levels of caches maybe four but the

128
00:04:51,280 --> 00:04:52,960
fourth level is a bit different so i

129
00:04:52,960 --> 00:04:54,479
will only talk about the three levels

130
00:04:54,479 --> 00:04:55,840
here

131
00:04:55,840 --> 00:04:58,479
level one and level two are private so

132
00:04:58,479 --> 00:05:00,320
if you have any data in there that's not

133
00:05:00,320 --> 00:05:02,720
shared if you have shared memory

134
00:05:02,720 --> 00:05:04,800
you might have multiple copies of them

135
00:05:04,800 --> 00:05:06,479
in the level one caches and the level

136
00:05:06,479 --> 00:05:08,880
two caches but the last level cache the

137
00:05:08,880 --> 00:05:10,960
level three cache is shared and it is

138
00:05:10,960 --> 00:05:12,000
inclusive

139
00:05:12,000 --> 00:05:14,400
any data that is anywhere in level one

140
00:05:14,400 --> 00:05:16,960
one or level two cache must also be in

141
00:05:16,960 --> 00:05:18,479
the level three cache and then you have

142
00:05:18,479 --> 00:05:20,240
the nice property that if you throw

143
00:05:20,240 --> 00:05:21,919
something out of the level three cache

144
00:05:21,919 --> 00:05:24,160
it will also be evicted from the local

145
00:05:24,160 --> 00:05:26,960
l1 and l2 caches of the victim process

146
00:05:26,960 --> 00:05:28,960
so if you run simultaneously you can

147
00:05:28,960 --> 00:05:32,160
really force data that the other process

148
00:05:32,160 --> 00:05:34,720
uses out of the cache just by accessing

149
00:05:34,720 --> 00:05:36,800
the memory that you are supposed to be

150
00:05:36,800 --> 00:05:39,919
able to access because of this property

151
00:05:39,919 --> 00:05:42,240
on arms this is a bit different there

152
00:05:42,240 --> 00:05:44,479
you have two layers of cache usually the

153
00:05:44,479 --> 00:05:46,560
level one cache which is again private

154
00:05:46,560 --> 00:05:48,400
and the level two cache with which is

155
00:05:48,400 --> 00:05:51,360
again shared but this time on arm cpu

156
00:05:51,360 --> 00:05:54,639
you have a wide uh a wide range of

157
00:05:54,639 --> 00:05:57,520
possible implementations and usually the

158
00:05:57,520 --> 00:05:59,440
level two cache will not be inclusive

159
00:05:59,440 --> 00:06:01,440
and therefore you cannot if you cannot

160
00:06:01,440 --> 00:06:04,080
throw something out of some uh other

161
00:06:04,080 --> 00:06:06,400
level one cache because it won't go out

162
00:06:06,400 --> 00:06:08,160
of the level one cache just because you

163
00:06:08,160 --> 00:06:09,600
do something in the level two cache

164
00:06:09,600 --> 00:06:11,039
right

165
00:06:11,039 --> 00:06:12,080
so

166
00:06:12,080 --> 00:06:14,240
the first challenge we identified is

167
00:06:14,240 --> 00:06:16,400
this that we have non-inclusive caches

168
00:06:16,400 --> 00:06:18,000
and we need to perform a tax on those

169
00:06:18,000 --> 00:06:20,240
non-inclusive caches and that might be a

170
00:06:20,240 --> 00:06:22,400
bit tricky

171
00:06:22,400 --> 00:06:23,440
um

172
00:06:23,440 --> 00:06:25,440
then the next part

173
00:06:25,440 --> 00:06:26,319
we

174
00:06:26,319 --> 00:06:29,600
we found another problem on modern c

175
00:06:29,600 --> 00:06:31,039
modern smartphones you will have

176
00:06:31,039 --> 00:06:33,120
multiple cpus for instance with a big

177
00:06:33,120 --> 00:06:34,960
little arc architecture you will have

178
00:06:34,960 --> 00:06:38,240
for instance in a weaker a53 and a

179
00:06:38,240 --> 00:06:39,759
stronger cpu than

180
00:06:39,759 --> 00:06:42,319
a57 and depending on what you do you

181
00:06:42,319 --> 00:06:44,160
will be scheduled to one of those cpus

182
00:06:44,160 --> 00:06:46,240
and one of them might even be turned off

183
00:06:46,240 --> 00:06:49,520
and you can't really force the cpu to

184
00:06:49,520 --> 00:06:52,080
locate you on one of the two

185
00:06:52,080 --> 00:06:54,880
um processors right

186
00:06:54,880 --> 00:06:57,120
and app shouldn't be able to do that and

187
00:06:57,120 --> 00:06:59,280
we assume that the app is not able to do

188
00:06:59,280 --> 00:07:00,960
that so

189
00:07:00,960 --> 00:07:03,120
we want to do an attack without any

190
00:07:03,120 --> 00:07:04,880
shared cache

191
00:07:04,880 --> 00:07:06,560
across the cpus

192
00:07:06,560 --> 00:07:08,400
and we will later on find out how we

193
00:07:08,400 --> 00:07:10,479
solve that challenge too

194
00:07:10,479 --> 00:07:11,759
another

195
00:07:11,759 --> 00:07:13,520
challenge we have for instance to

196
00:07:13,520 --> 00:07:15,280
perform a flush and reload attack you

197
00:07:15,280 --> 00:07:17,680
have to flush something from memory on

198
00:07:17,680 --> 00:07:19,599
x86 that's easy because you have an

199
00:07:19,599 --> 00:07:21,599
unprivileged flush instruction that any

200
00:07:21,599 --> 00:07:23,680
process can use at any time

201
00:07:23,680 --> 00:07:26,080
on arm v7 we have privileged flush

202
00:07:26,080 --> 00:07:27,759
instructions but for the user space

203
00:07:27,759 --> 00:07:29,440
that's not possible the user space can't

204
00:07:29,440 --> 00:07:30,880
flush memory

205
00:07:30,880 --> 00:07:33,199
on arm v8 you can

206
00:07:33,199 --> 00:07:34,960
unlock a flush instruction for user

207
00:07:34,960 --> 00:07:37,120
space and this is done by

208
00:07:37,120 --> 00:07:38,800
off-the-shelf devices for instance we

209
00:07:38,800 --> 00:07:40,160
had the case

210
00:07:40,160 --> 00:07:42,800
with a samsung galaxy s6 there the user

211
00:07:42,800 --> 00:07:44,560
space again can use a flash instruction

212
00:07:44,560 --> 00:07:46,000
which is great for the flash and reload

213
00:07:46,000 --> 00:07:47,199
attack

214
00:07:47,199 --> 00:07:49,759
so challenge again um

215
00:07:49,759 --> 00:07:51,840
here the challenge just focuses on arm

216
00:07:51,840 --> 00:07:54,080
v7a where we have no flash instruction

217
00:07:54,080 --> 00:07:55,599
we need to figure out how to do that

218
00:07:55,599 --> 00:07:58,720
then and the solution how to do

219
00:07:58,720 --> 00:08:01,120
cache eviction without um a flash

220
00:08:01,120 --> 00:08:03,520
instruction is accessing a lot of memory

221
00:08:03,520 --> 00:08:05,039
and throwing data out of the cache by

222
00:08:05,039 --> 00:08:06,639
that doing that

223
00:08:06,639 --> 00:08:08,800
previous work always worked with

224
00:08:08,800 --> 00:08:10,879
strategies like x if you haven't you

225
00:08:10,879 --> 00:08:13,440
have a 16 way cache and you

226
00:08:13,440 --> 00:08:15,440
access 16 memory locations that go into

227
00:08:15,440 --> 00:08:18,080
that cache set and then it's evicted

228
00:08:18,080 --> 00:08:21,199
but if you look at current arm cpus so

229
00:08:21,199 --> 00:08:22,720
they have a pseudo random replacement

230
00:08:22,720 --> 00:08:24,479
policy so you might have to access more

231
00:08:24,479 --> 00:08:25,360
than

232
00:08:25,360 --> 00:08:26,479
16

233
00:08:26,479 --> 00:08:29,599
addresses to a victor 16 way cache

234
00:08:29,599 --> 00:08:30,639
and

235
00:08:30,639 --> 00:08:32,479
it's it's also

236
00:08:32,479 --> 00:08:35,120
not really guaranteed that you have some

237
00:08:35,120 --> 00:08:37,360
specific eviction rate so this will

238
00:08:37,360 --> 00:08:39,279
introduce noise in your attack you will

239
00:08:39,279 --> 00:08:41,760
have false positives false negatives and

240
00:08:41,760 --> 00:08:43,360
it will make the attack

241
00:08:43,360 --> 00:08:45,600
just take longer or make it impossible

242
00:08:45,600 --> 00:08:46,800
if you want to

243
00:08:46,800 --> 00:08:48,640
want to spy on singular events like

244
00:08:48,640 --> 00:08:51,279
keystrokes

245
00:08:51,760 --> 00:08:52,640
so

246
00:08:52,640 --> 00:08:54,800
the challenge here is perform fast and

247
00:08:54,800 --> 00:08:56,880
reliable cache eviction but that was

248
00:08:56,880 --> 00:08:58,480
later on we will see that that was

249
00:08:58,480 --> 00:09:00,480
rather easy

250
00:09:00,480 --> 00:09:03,519
a more difficult part um but we also

251
00:09:03,519 --> 00:09:05,360
found very nice solutions for that

252
00:09:05,360 --> 00:09:08,640
timing measurements and we um checked

253
00:09:08,640 --> 00:09:11,120
all the previous work on android

254
00:09:11,120 --> 00:09:12,880
cache attacks and

255
00:09:12,880 --> 00:09:15,600
we found that most of them use uh

256
00:09:15,600 --> 00:09:20,000
unprivileged you use the privileged

257
00:09:20,000 --> 00:09:22,080
cycle counter so you can only access

258
00:09:22,080 --> 00:09:24,080
them from kernel mode

259
00:09:24,080 --> 00:09:26,480
or you have to write a kernel module to

260
00:09:26,480 --> 00:09:28,480
unlock it for the user space so you can

261
00:09:28,480 --> 00:09:30,320
do that on a rooted android phone so you

262
00:09:30,320 --> 00:09:32,880
assume that the android phone is rooted

263
00:09:32,880 --> 00:09:34,000
but

264
00:09:34,000 --> 00:09:35,839
if the android phone is not rooted then

265
00:09:35,839 --> 00:09:37,760
you cannot perform these attacks

266
00:09:37,760 --> 00:09:41,440
um on x86 again this is easy because the

267
00:09:41,440 --> 00:09:43,680
retc instruction is unprivileged so you

268
00:09:43,680 --> 00:09:46,160
don't need to have a

269
00:09:46,160 --> 00:09:48,240
pro program running with root privileges

270
00:09:48,240 --> 00:09:51,120
there in any case so

271
00:09:51,120 --> 00:09:52,959
challenge five is we need to find

272
00:09:52,959 --> 00:09:54,640
unprivileged highly accurate timing

273
00:09:54,640 --> 00:09:57,120
sources and we investigated a few new

274
00:09:57,120 --> 00:09:59,519
timing sources here

275
00:09:59,519 --> 00:10:01,360
so the challenge is just an overview we

276
00:10:01,360 --> 00:10:03,519
will now step through the challenges and

277
00:10:03,519 --> 00:10:05,200
how we solved them

278
00:10:05,200 --> 00:10:07,839
so for the non-inclusive caches

279
00:10:07,839 --> 00:10:09,760
attacking in

280
00:10:09,760 --> 00:10:11,920
instruction inclusive data non-inclusive

281
00:10:11,920 --> 00:10:14,800
cache so that means um in level one

282
00:10:14,800 --> 00:10:16,480
instruction all data and level one

283
00:10:16,480 --> 00:10:18,320
instruction caches must also be in the

284
00:10:18,320 --> 00:10:21,200
level two unified cache and

285
00:10:21,200 --> 00:10:23,680
data non-inclusive that means that data

286
00:10:23,680 --> 00:10:26,079
can be in both levels it can be in one

287
00:10:26,079 --> 00:10:28,640
of them there is no strict policy on

288
00:10:28,640 --> 00:10:31,279
that how can we do an attack here so we

289
00:10:31,279 --> 00:10:33,760
can just access enough data that it

290
00:10:33,760 --> 00:10:36,480
spills our level one data cache and then

291
00:10:36,480 --> 00:10:38,959
it will fill the entire level two

292
00:10:38,959 --> 00:10:42,800
unified cache set um over time and by

293
00:10:42,800 --> 00:10:44,880
this we can evict the instructions so we

294
00:10:44,880 --> 00:10:47,519
have a data non-inclusive cache and we

295
00:10:47,519 --> 00:10:49,120
can still throw something out from the

296
00:10:49,120 --> 00:10:50,160
other

297
00:10:50,160 --> 00:10:51,519
program

298
00:10:51,519 --> 00:10:53,040
how does it work with entirely

299
00:10:53,040 --> 00:10:54,800
non-inclusive caches that gets more

300
00:10:54,800 --> 00:10:58,560
tricky and also more noisy of course

301
00:10:58,560 --> 00:11:00,560
the first part again is easy so if we

302
00:11:00,560 --> 00:11:03,200
want to look at cache hits then we we

303
00:11:03,200 --> 00:11:05,120
find that the cache coherency protocol

304
00:11:05,120 --> 00:11:07,839
allows us to to measure the access time

305
00:11:07,839 --> 00:11:10,320
of a remote cache hit so the

306
00:11:10,320 --> 00:11:12,079
the cache coherency protocol won't

307
00:11:12,079 --> 00:11:13,600
actually fetch the data from dram

308
00:11:13,600 --> 00:11:15,120
because that was would it would be a

309
00:11:15,120 --> 00:11:17,279
waste of time instead it fetches the

310
00:11:17,279 --> 00:11:20,240
data from the remote level one cache and

311
00:11:20,240 --> 00:11:22,480
this is much faster we actually only

312
00:11:22,480 --> 00:11:24,160
find a very small timing difference

313
00:11:24,160 --> 00:11:26,480
between the local and the remote level

314
00:11:26,480 --> 00:11:28,880
one cache

315
00:11:28,880 --> 00:11:30,720
but what about eviction and eviction

316
00:11:30,720 --> 00:11:33,040
gets a bit more tricky so again we will

317
00:11:33,040 --> 00:11:35,920
spill our level one set and we'll fill

318
00:11:35,920 --> 00:11:38,880
the entire level two cache set and if we

319
00:11:38,880 --> 00:11:41,440
now look at an arm cpu on in the on the

320
00:11:41,440 --> 00:11:42,800
level one

321
00:11:42,800 --> 00:11:45,200
cache they usually have something like

322
00:11:45,200 --> 00:11:48,959
uh two ways or four ways that's not much

323
00:11:48,959 --> 00:11:51,040
so two ways you can access two memory

324
00:11:51,040 --> 00:11:52,639
locations that are congruent to each

325
00:11:52,639 --> 00:11:55,040
other and that means they they have like

326
00:11:55,040 --> 00:11:59,839
128 or 256 cash sets so many addresses

327
00:11:59,839 --> 00:12:02,079
will map to the same cash set and having

328
00:12:02,079 --> 00:12:04,320
an associativity in the cash of two

329
00:12:04,320 --> 00:12:07,920
means that you will evict uh

330
00:12:07,920 --> 00:12:09,120
will evict

331
00:12:09,120 --> 00:12:11,680
data and instructions by yourself if

332
00:12:11,680 --> 00:12:13,519
there is no room in the level 2 cache so

333
00:12:13,519 --> 00:12:15,920
our trick is we keep the level 2 cache

334
00:12:15,920 --> 00:12:18,959
filled all the time and then we

335
00:12:18,959 --> 00:12:21,440
throw out data by that indirectly from

336
00:12:21,440 --> 00:12:24,800
the remote level 1 cache and if we look

337
00:12:24,800 --> 00:12:26,320
at the timing for that so here we can

338
00:12:26,320 --> 00:12:29,360
see the timing for a cache hit or a

339
00:12:29,360 --> 00:12:32,079
cache miss so if the eviction was

340
00:12:32,079 --> 00:12:34,880
done on another core

341
00:12:34,880 --> 00:12:36,880
that's really a small difference and it

342
00:12:36,880 --> 00:12:38,959
works in both cases

343
00:12:38,959 --> 00:12:41,279
more complicated or actually not more

344
00:12:41,279 --> 00:12:43,360
complicated but we thought it might be

345
00:12:43,360 --> 00:12:45,200
more complicated to do the attack on

346
00:12:45,200 --> 00:12:47,360
multiple cpus but again the cash

347
00:12:47,360 --> 00:12:49,839
coherency protocol saves the day for the

348
00:12:49,839 --> 00:12:50,839
attacker

349
00:12:50,839 --> 00:12:54,720
and it allows us to do the remote

350
00:12:54,720 --> 00:12:55,839
cache hits

351
00:12:55,839 --> 00:12:58,079
over the coherency protocol again and

352
00:12:58,079 --> 00:12:59,279
again we can

353
00:12:59,279 --> 00:13:01,200
apply our technique to keep the level 2

354
00:13:01,200 --> 00:13:03,279
cache filled to increase the probability

355
00:13:03,279 --> 00:13:06,399
of a remote l1 l2 eviction

356
00:13:06,399 --> 00:13:09,519
we also observed that you can do remote

357
00:13:09,519 --> 00:13:11,839
cpu flushes so that's nice for the flush

358
00:13:11,839 --> 00:13:14,880
and reload attack but this is also so it

359
00:13:14,880 --> 00:13:17,760
sort of works it gets a lot of noise and

360
00:13:17,760 --> 00:13:19,680
you can you need much more repetitions

361
00:13:19,680 --> 00:13:21,200
to perform an attack but you can still

362
00:13:21,200 --> 00:13:22,480
perform a cross

363
00:13:22,480 --> 00:13:26,639
cross cpu prime and probe attack here

364
00:13:26,639 --> 00:13:27,839
so

365
00:13:27,839 --> 00:13:29,920
for the flush instruction last year at

366
00:13:29,920 --> 00:13:31,839
usnix i presented the cache template

367
00:13:31,839 --> 00:13:34,240
attacks paper and in that paper we had a

368
00:13:34,240 --> 00:13:36,240
short paragraph on the eviction reload

369
00:13:36,240 --> 00:13:38,399
attack where the idea was to remove the

370
00:13:38,399 --> 00:13:40,720
flush instruction and

371
00:13:40,720 --> 00:13:43,120
that was by then

372
00:13:43,120 --> 00:13:44,480
discussed whether that would be a

373
00:13:44,480 --> 00:13:46,000
reasonable counter-measure against flush

374
00:13:46,000 --> 00:13:47,839
and reload attack and basically we

375
00:13:47,839 --> 00:13:49,920
showed that we can do eviction instead

376
00:13:49,920 --> 00:13:51,120
and

377
00:13:51,120 --> 00:13:52,800
yeah that's the eviction reload attack

378
00:13:52,800 --> 00:13:54,560
then works exactly the same as flush and

379
00:13:54,560 --> 00:13:56,480
reload just you do cache eviction it

380
00:13:56,480 --> 00:13:59,440
works on x86 very reliable but we now

381
00:13:59,440 --> 00:14:01,680
get the problem that we have to solve

382
00:14:01,680 --> 00:14:04,000
the unreliable cache eviction on our arm

383
00:14:04,000 --> 00:14:05,760
cpus

384
00:14:05,760 --> 00:14:06,560
and

385
00:14:06,560 --> 00:14:09,279
there we worked just recently on row

386
00:14:09,279 --> 00:14:11,760
hammer js where this was our

387
00:14:11,760 --> 00:14:14,240
central idea to replace the flush

388
00:14:14,240 --> 00:14:17,440
instruction by very efficient and fast

389
00:14:17,440 --> 00:14:20,240
uh and and um

390
00:14:20,240 --> 00:14:21,360
working

391
00:14:21,360 --> 00:14:23,680
uh memory loop of memory accesses that

392
00:14:23,680 --> 00:14:26,240
evict the data from the cache and so we

393
00:14:26,240 --> 00:14:30,240
again uh spent many many days

394
00:14:30,240 --> 00:14:33,360
doing sort of row hammer on on on phones

395
00:14:33,360 --> 00:14:35,279
to find eviction strategies so you do

396
00:14:35,279 --> 00:14:38,000
this in a in a loop a few multiple a few

397
00:14:38,000 --> 00:14:40,320
million times and then you can have an

398
00:14:40,320 --> 00:14:41,600
average

399
00:14:41,600 --> 00:14:43,360
amount of cycles

400
00:14:43,360 --> 00:14:46,800
that the eviction takes so here we had a

401
00:14:46,800 --> 00:14:50,000
strategy so the the 4848 strategy that

402
00:14:50,000 --> 00:14:52,560
would be what you had to use before and

403
00:14:52,560 --> 00:14:55,120
it didn't work on on our phone the

404
00:14:55,120 --> 00:14:58,079
alcatel in this case um so it had a very

405
00:14:58,079 --> 00:15:00,000
bad eviction rate and we had to go up to

406
00:15:00,000 --> 00:15:01,680
800

407
00:15:01,680 --> 00:15:04,800
addresses to stick to this old eviction

408
00:15:04,800 --> 00:15:06,240
strategy

409
00:15:06,240 --> 00:15:08,880
to get to an eviction rate above 99

410
00:15:08,880 --> 00:15:11,440
percent and then we said okay we need to

411
00:15:11,440 --> 00:15:13,920
figure out uh what's what's working

412
00:15:13,920 --> 00:15:16,240
better and we found a strategy with uh

413
00:15:16,240 --> 00:15:20,000
23 unique addresses and 50 accesses to

414
00:15:20,000 --> 00:15:22,399
to those unique addresses and that's

415
00:15:22,399 --> 00:15:24,880
much faster than the 48

416
00:15:24,880 --> 00:15:26,720
accesses and

417
00:15:26,720 --> 00:15:29,120
also the eviction rate is much higher

418
00:15:29,120 --> 00:15:31,199
the reason for that is that you keep the

419
00:15:31,199 --> 00:15:33,120
data in the cache more likely and

420
00:15:33,120 --> 00:15:36,079
therefore the accesses are faster

421
00:15:36,079 --> 00:15:37,759
then for the last challenge the

422
00:15:37,759 --> 00:15:40,800
unprivileged timing so we

423
00:15:40,800 --> 00:15:42,800
compared the performance counter with

424
00:15:42,800 --> 00:15:45,600
the perf event open interface that

425
00:15:45,600 --> 00:15:47,440
provides a syscall that allows you to

426
00:15:47,440 --> 00:15:48,720
read the

427
00:15:48,720 --> 00:15:52,240
cycle count register from user space so

428
00:15:52,240 --> 00:15:54,000
user space application can just use this

429
00:15:54,000 --> 00:15:56,639
this call and

430
00:15:56,639 --> 00:15:58,160
read the cycle count through this

431
00:15:58,160 --> 00:16:00,639
syscall another method was clock get

432
00:16:00,639 --> 00:16:02,320
time which is a

433
00:16:02,320 --> 00:16:04,160
c library interface which gives you a

434
00:16:04,160 --> 00:16:06,240
nanosecond or close to nanosecond

435
00:16:06,240 --> 00:16:08,320
accurate timestamp and then we also

436
00:16:08,320 --> 00:16:09,920
checked out the

437
00:16:09,920 --> 00:16:11,600
idea of

438
00:16:11,600 --> 00:16:14,320
using a thread counter so you have a

439
00:16:14,320 --> 00:16:16,399
second thread running and it increments

440
00:16:16,399 --> 00:16:18,959
a global variable all the time and we

441
00:16:18,959 --> 00:16:20,079
thought okay

442
00:16:20,079 --> 00:16:21,839
in worst case if you have no timing

443
00:16:21,839 --> 00:16:23,759
information at all you can still go back

444
00:16:23,759 --> 00:16:25,680
to that and then you can use the threat

445
00:16:25,680 --> 00:16:28,240
the global global variable to count that

446
00:16:28,240 --> 00:16:31,199
but it probably won't be very accurate

447
00:16:31,199 --> 00:16:33,600
now if we look at the actual measurement

448
00:16:33,600 --> 00:16:35,360
data we got

449
00:16:35,360 --> 00:16:37,199
so you see in black the performance

450
00:16:37,199 --> 00:16:39,920
counter register uh the peak for the hit

451
00:16:39,920 --> 00:16:42,320
and the cache miss the

452
00:16:42,320 --> 00:16:44,480
timing difference

453
00:16:44,480 --> 00:16:47,360
and in red you see the solution with

454
00:16:47,360 --> 00:16:50,880
syscall and surprising uh part here is

455
00:16:50,880 --> 00:16:53,440
that this is call uh it

456
00:16:53,440 --> 00:16:56,639
actually is a bit faster for the

457
00:16:56,639 --> 00:16:59,040
uh for the cash hit and probably that's

458
00:16:59,040 --> 00:17:00,560
because our implementation for the

459
00:17:00,560 --> 00:17:02,320
performance counter register was just

460
00:17:02,320 --> 00:17:04,480
less efficient

461
00:17:04,480 --> 00:17:06,400
the other part so in case of a cache

462
00:17:06,400 --> 00:17:08,480
miss it was much slower probably they

463
00:17:08,480 --> 00:17:10,880
optimized the other code path more i

464
00:17:10,880 --> 00:17:13,119
don't know

465
00:17:13,119 --> 00:17:16,319
but this is all on a very small scale

466
00:17:16,319 --> 00:17:18,240
more interesting so the clock get time

467
00:17:18,240 --> 00:17:20,079
also works but it's less accurate you

468
00:17:20,079 --> 00:17:23,520
see that the the bluish uh line they are

469
00:17:23,520 --> 00:17:26,079
closer together and the most interesting

470
00:17:26,079 --> 00:17:29,120
part here is that the counter thread has

471
00:17:29,120 --> 00:17:30,400
a very

472
00:17:30,400 --> 00:17:32,480
large distance here and also if you look

473
00:17:32,480 --> 00:17:34,720
at the at the scaling factors so we had

474
00:17:34,720 --> 00:17:37,520
to scale down the counter thread a lot

475
00:17:37,520 --> 00:17:40,160
and that showed us that with the counter

476
00:17:40,160 --> 00:17:42,240
thread as long as we don't have any

477
00:17:42,240 --> 00:17:44,160
interrupt the counter threat will be the

478
00:17:44,160 --> 00:17:46,720
most accurate way to measure the time

479
00:17:46,720 --> 00:17:48,480
but if we have an interrupt it ruins the

480
00:17:48,480 --> 00:17:50,880
measurement for that time

481
00:17:50,880 --> 00:17:52,640
we then investigated what kinds of

482
00:17:52,640 --> 00:17:54,559
attacks we can perform so we performed

483
00:17:54,559 --> 00:17:56,400
the flush and reload attack on the

484
00:17:56,400 --> 00:17:58,480
samsung galaxy s6 but we also performed

485
00:17:58,480 --> 00:18:00,240
the flush and flush attack so there is a

486
00:18:00,240 --> 00:18:01,760
timing difference in the flush

487
00:18:01,760 --> 00:18:03,760
instruction alone so you don't have to

488
00:18:03,760 --> 00:18:05,760
reload the data actually

489
00:18:05,760 --> 00:18:07,440
we performed the prime and probe attack

490
00:18:07,440 --> 00:18:09,120
on multiple devices here you can see a

491
00:18:09,120 --> 00:18:13,360
trace on the alcatel one touch pop too

492
00:18:13,360 --> 00:18:16,080
so it's a bit noisy but it still works

493
00:18:16,080 --> 00:18:19,760
um to transmit data or to spy on someone

494
00:18:19,760 --> 00:18:22,320
we then compared the performance of our

495
00:18:22,320 --> 00:18:25,440
covered channels with state-of-the-art

496
00:18:25,440 --> 00:18:27,120
cover channels and there we found that

497
00:18:27,120 --> 00:18:29,919
we are three orders of magnitude almost

498
00:18:29,919 --> 00:18:32,799
three orders of magnitude faster

499
00:18:32,799 --> 00:18:35,120
than state of the art and we can perform

500
00:18:35,120 --> 00:18:38,320
attacks cross core and cross cpu so our

501
00:18:38,320 --> 00:18:40,799
environment for the attack is not more

502
00:18:40,799 --> 00:18:43,280
restricting than previous work

503
00:18:43,280 --> 00:18:46,480
but it works in the same setup

504
00:18:46,480 --> 00:18:47,520
we then

505
00:18:47,520 --> 00:18:49,200
implemented cache template attacks on

506
00:18:49,200 --> 00:18:50,960
the base of our

507
00:18:50,960 --> 00:18:53,600
attack primitives that we got so far and

508
00:18:53,600 --> 00:18:56,400
there we scanned all kinds of libraries

509
00:18:56,400 --> 00:18:58,240
that are present on

510
00:18:58,240 --> 00:19:00,640
android phones and in this case it's the

511
00:19:00,640 --> 00:19:03,360
lib input shared library and we can

512
00:19:03,360 --> 00:19:04,640
distinguish

513
00:19:04,640 --> 00:19:07,200
based on where a cache hit occurs we can

514
00:19:07,200 --> 00:19:09,360
distinguish different events so we know

515
00:19:09,360 --> 00:19:12,880
for instance on based on address 8100

516
00:19:12,880 --> 00:19:16,799
that uh probably text has been

517
00:19:16,799 --> 00:19:20,320
entered and not a swipe or a tab

518
00:19:20,320 --> 00:19:23,440
so we did the same also on the android

519
00:19:23,440 --> 00:19:26,480
aosp keyboard so in case the other

520
00:19:26,480 --> 00:19:28,160
library doesn't give any results on a

521
00:19:28,160 --> 00:19:30,720
phone we can also do an attack here and

522
00:19:30,720 --> 00:19:32,880
again distinguish key groups we didn't

523
00:19:32,880 --> 00:19:35,600
find any library that actually leaked

524
00:19:35,600 --> 00:19:41,200
the specific key for us as on linux but

525
00:19:41,200 --> 00:19:42,960
on android we only can distinguish the

526
00:19:42,960 --> 00:19:45,280
key groups and if we do that over time

527
00:19:45,280 --> 00:19:47,520
so here i have a trace of tabs and

528
00:19:47,520 --> 00:19:49,840
swipes and you can see the exact

529
00:19:49,840 --> 00:19:52,559
timestamp when the user touched the

530
00:19:52,559 --> 00:19:55,200
touchscreen and removed the finger from

531
00:19:55,200 --> 00:19:56,799
the touch screen again so you know

532
00:19:56,799 --> 00:19:59,280
exactly how long the swipe movement was

533
00:19:59,280 --> 00:20:00,480
you can

534
00:20:00,480 --> 00:20:02,480
distinguish taps and swipes because the

535
00:20:02,480 --> 00:20:04,320
tabs are only very

536
00:20:04,320 --> 00:20:06,880
small and and short peaks

537
00:20:06,880 --> 00:20:09,840
um the same works on here on the samsung

538
00:20:09,840 --> 00:20:12,320
galaxy s6 with a flush and reload attack

539
00:20:12,320 --> 00:20:14,159
and here it's with an evicted reload

540
00:20:14,159 --> 00:20:16,000
attack on the oneplus one because it

541
00:20:16,000 --> 00:20:18,240
doesn't have a flash instruction there

542
00:20:18,240 --> 00:20:22,000
and here i have a trace of a cache

543
00:20:22,000 --> 00:20:24,960
template attack that distinguishes space

544
00:20:24,960 --> 00:20:27,919
and keys and this exactly gives you the

545
00:20:27,919 --> 00:20:30,159
length of the words that you entered in

546
00:20:30,159 --> 00:20:33,679
a um in a sentence right so this is also

547
00:20:33,679 --> 00:20:36,559
nice to to spy on user input

548
00:20:36,559 --> 00:20:37,520
we then

549
00:20:37,520 --> 00:20:40,240
uh also tried to attack cryptographic

550
00:20:40,240 --> 00:20:43,120
algorithms and we attacked bouncy castle

551
00:20:43,120 --> 00:20:45,200
which is a widely used crypto library

552
00:20:45,200 --> 00:20:47,520
it's not so widely used anymore as it

553
00:20:47,520 --> 00:20:50,880
was some years ago but it is still used

554
00:20:50,880 --> 00:20:53,679
by whatsapp for instance and the default

555
00:20:53,679 --> 00:20:56,640
uh variant in bouncy castle

556
00:20:56,640 --> 00:20:59,200
is a fast implementation of aes in

557
00:20:59,200 --> 00:21:01,600
software and they use t tables so unless

558
00:21:01,600 --> 00:21:04,799
you opt for the slow but safe variant

559
00:21:04,799 --> 00:21:06,159
you will be using the t table

560
00:21:06,159 --> 00:21:07,760
implementation which is known to be

561
00:21:07,760 --> 00:21:10,240
vulnerable for timing attacks

562
00:21:10,240 --> 00:21:12,320
and especially for cache timing attacks

563
00:21:12,320 --> 00:21:14,320
so if we were on an attack on this

564
00:21:14,320 --> 00:21:16,000
t-table implementation it will look like

565
00:21:16,000 --> 00:21:18,640
this and leak us the key bytes

566
00:21:18,640 --> 00:21:21,039
immediately you see a eviction reload

567
00:21:21,039 --> 00:21:22,880
attack on the left and a flush and

568
00:21:22,880 --> 00:21:24,480
reload attack on the right on the

569
00:21:24,480 --> 00:21:26,480
samsung

570
00:21:26,480 --> 00:21:28,640
these attacks are

571
00:21:28,640 --> 00:21:30,559
kind of artificial because we usually

572
00:21:30,559 --> 00:21:32,880
cannot acquire shared memory with bouncy

573
00:21:32,880 --> 00:21:34,240
castle because bouncy castle is

574
00:21:34,240 --> 00:21:36,799
implemented in java and the java vm will

575
00:21:36,799 --> 00:21:39,840
create a copy of the t table

576
00:21:39,840 --> 00:21:43,200
of the t tables when the program starts

577
00:21:43,200 --> 00:21:46,080
so we then did a prime and probe attack

578
00:21:46,080 --> 00:21:48,799
on the java

579
00:21:48,799 --> 00:21:51,760
on the on the crypto library in java and

580
00:21:51,760 --> 00:21:54,000
there we found that we again can get the

581
00:21:54,000 --> 00:21:55,520
key bytes out of that

582
00:21:55,520 --> 00:21:57,919
we just need more repetitions because

583
00:21:57,919 --> 00:21:59,360
prime and probe is

584
00:21:59,360 --> 00:22:00,640
more noisy

585
00:22:00,640 --> 00:22:02,720
then we use prime and probe

586
00:22:02,720 --> 00:22:04,799
later on to check whether we can get

587
00:22:04,799 --> 00:22:07,280
some information out of the trust zone

588
00:22:07,280 --> 00:22:08,320
and

589
00:22:08,320 --> 00:22:10,799
that was a bit complicated because the

590
00:22:10,799 --> 00:22:13,600
trust zone we don't have the source code

591
00:22:13,600 --> 00:22:15,760
of the trusts of programs running in the

592
00:22:15,760 --> 00:22:17,840
trust zone so we didn't really know what

593
00:22:17,840 --> 00:22:19,600
was going on in there

594
00:22:19,600 --> 00:22:20,880
we tried to

595
00:22:20,880 --> 00:22:23,520
find timing differences for different

596
00:22:23,520 --> 00:22:27,120
rsa signature keys and we found timing

597
00:22:27,120 --> 00:22:29,760
differences but

598
00:22:29,760 --> 00:22:32,000
we couldn't really

599
00:22:32,000 --> 00:22:34,400
we couldn't really

600
00:22:34,400 --> 00:22:35,919
confirm or

601
00:22:35,919 --> 00:22:37,760
we couldn't really verify

602
00:22:37,760 --> 00:22:38,559
that

603
00:22:38,559 --> 00:22:41,760
we can distinguish keys so it was below

604
00:22:41,760 --> 00:22:44,080
a threshold that we would still consider

605
00:22:44,080 --> 00:22:46,400
as noise and therefore we

606
00:22:46,400 --> 00:22:48,480
didn't include that in the paper

607
00:22:48,480 --> 00:22:50,799
but what we have is we can

608
00:22:50,799 --> 00:22:52,080
distinguish

609
00:22:52,080 --> 00:22:54,880
invalid keys from valid keys so you can

610
00:22:54,880 --> 00:22:56,480
see that there is a different

611
00:22:56,480 --> 00:22:59,360
computation going on in the trust zone

612
00:22:59,360 --> 00:23:01,440
and if you would have access to the

613
00:23:01,440 --> 00:23:03,520
source code or if you would have more

614
00:23:03,520 --> 00:23:05,280
knowledge about what's happening in the

615
00:23:05,280 --> 00:23:07,600
trust zone or you would run a template

616
00:23:07,600 --> 00:23:10,640
attack like on an aes uh t table

617
00:23:10,640 --> 00:23:13,120
implementation that's really easy

618
00:23:13,120 --> 00:23:14,799
um then you could do a more

619
00:23:14,799 --> 00:23:16,559
sophisticated attack on trust zone as

620
00:23:16,559 --> 00:23:18,559
well so trust zone doesn't protect

621
00:23:18,559 --> 00:23:21,440
against cache side channels and we just

622
00:23:21,440 --> 00:23:24,480
show that that indeed it doesn't

623
00:23:24,480 --> 00:23:27,280
for the conclusions uh we show that all

624
00:23:27,280 --> 00:23:28,960
the powerful cache attacks are now

625
00:23:28,960 --> 00:23:31,360
applicable to smartphones including

626
00:23:31,360 --> 00:23:33,679
prime and probe and flush and reload

627
00:23:33,679 --> 00:23:35,760
we are able to monitor user

628
00:23:35,760 --> 00:23:38,720
activity with with high accuracy we are

629
00:23:38,720 --> 00:23:40,640
able to derive crypto keys because

630
00:23:40,640 --> 00:23:43,120
android was uh apparently still uses

631
00:23:43,120 --> 00:23:46,240
weak crypto and it shouldn't and finally

632
00:23:46,240 --> 00:23:49,760
we found leakage from the trust zone and

633
00:23:49,760 --> 00:23:51,760
we can use that later on in more

634
00:23:51,760 --> 00:23:54,080
sophisticated attacks thank you for your

635
00:23:54,080 --> 00:23:56,400
attention i would be pleased to answer

636
00:23:56,400 --> 00:23:58,730
your questions later

637
00:23:58,730 --> 00:24:05,120
[Applause]

638
00:24:05,120 --> 00:24:06,880
so we have time for a few questions if

639
00:24:06,880 --> 00:24:08,640
um you have one please approach the mic

640
00:24:08,640 --> 00:24:12,320
and state your name and affiliation

641
00:24:15,279 --> 00:24:18,960
okay so i i will uh kick it off um so i

642
00:24:18,960 --> 00:24:20,400
actually have a fairly specific question

643
00:24:20,400 --> 00:24:22,720
for the first one so um back on slide 32

644
00:24:22,720 --> 00:24:24,960
you were distinguishing

645
00:24:24,960 --> 00:24:26,960
um keystrokes that were entered by the

646
00:24:26,960 --> 00:24:29,039
user right

647
00:24:29,039 --> 00:24:30,960
so i just wanted to clarify you were not

648
00:24:30,960 --> 00:24:33,279
just distinguishing between space

649
00:24:33,279 --> 00:24:36,530
no back on slide 32 32 okay

650
00:24:36,530 --> 00:24:39,609
[Music]

651
00:24:40,159 --> 00:24:43,039
let me just go there

652
00:24:43,279 --> 00:24:45,840
so yeah just just to clarify um because

653
00:24:45,840 --> 00:24:46,880
it wasn't clear to me you're

654
00:24:46,880 --> 00:24:49,279
distinguishing also um not not just

655
00:24:49,279 --> 00:24:51,120
between spaces and other keys but really

656
00:24:51,120 --> 00:24:53,440
labeling no no no no this is just the

657
00:24:53,440 --> 00:24:55,440
sentence that we typed on the on the

658
00:24:55,440 --> 00:24:56,960
touch screen that is the ground truth

659
00:24:56,960 --> 00:24:59,200
yeah okay okay i just wanted to clarify

660
00:24:59,200 --> 00:25:01,200
that so it depends on what library you

661
00:25:01,200 --> 00:25:03,360
use on linux for instance the gtk

662
00:25:03,360 --> 00:25:05,520
library does a binary search over an

663
00:25:05,520 --> 00:25:08,159
array that translates translates key

664
00:25:08,159 --> 00:25:10,080
codes to

665
00:25:10,080 --> 00:25:13,679
utf-8 and the binary search

666
00:25:13,679 --> 00:25:16,159
leaves a very nice access pattern in the

667
00:25:16,159 --> 00:25:19,200
cache and then you can exactly derive

668
00:25:19,200 --> 00:25:22,000
what key has been entered with

669
00:25:22,000 --> 00:25:23,919
exactly with some some limitations of

670
00:25:23,919 --> 00:25:25,120
course

671
00:25:25,120 --> 00:25:25,840
but

672
00:25:25,840 --> 00:25:27,919
on android we didn't find such a library

673
00:25:27,919 --> 00:25:29,919
that performs a binary search over user

674
00:25:29,919 --> 00:25:32,640
input or any search over user input

675
00:25:32,640 --> 00:25:35,360
interesting thanks

676
00:25:35,919 --> 00:25:38,640
hello diamond juan from uc riverside i'm

677
00:25:38,640 --> 00:25:40,640
wondering but i'm having some questions

678
00:25:40,640 --> 00:25:44,000
about your timestamp counter method

679
00:25:44,000 --> 00:25:45,600
so you say you can

680
00:25:45,600 --> 00:25:48,400
accurately measure distinguish between

681
00:25:48,400 --> 00:25:50,799
hit and miss using a system called

682
00:25:50,799 --> 00:25:53,919
perform perf event open and the clock at

683
00:25:53,919 --> 00:25:54,960
time

684
00:25:54,960 --> 00:25:55,760
so

685
00:25:55,760 --> 00:25:57,840
those system calls like

686
00:25:57,840 --> 00:25:59,919
platforms specific because we tried it

687
00:25:59,919 --> 00:26:02,400
in our attack and we found the perf even

688
00:26:02,400 --> 00:26:04,720
open has a very high overhap overhead

689
00:26:04,720 --> 00:26:07,200
and does not distinguish well

690
00:26:07,200 --> 00:26:09,600
okay so for for us perfect event open

691
00:26:09,600 --> 00:26:12,240
did work well on uh on those devices

692
00:26:12,240 --> 00:26:13,600
where it was available it was not

693
00:26:13,600 --> 00:26:15,520
available on all devices that's why we

694
00:26:15,520 --> 00:26:18,400
investigated more different methods um

695
00:26:18,400 --> 00:26:21,120
clocked time worked for us on

696
00:26:21,120 --> 00:26:24,159
all devices but had a due to the lower

697
00:26:24,159 --> 00:26:26,400
granularity we had much more noise with

698
00:26:26,400 --> 00:26:28,640
clock get time and the threat counter

699
00:26:28,640 --> 00:26:32,240
also worked for us on on all devices

700
00:26:32,240 --> 00:26:34,559
and for your square counter like uh you

701
00:26:34,559 --> 00:26:36,720
said the circumference will not work if

702
00:26:36,720 --> 00:26:38,799
there's an interrupt so do you have any

703
00:26:38,799 --> 00:26:40,960
measurement on how

704
00:26:40,960 --> 00:26:43,200
in your experiment how much interrupt

705
00:26:43,200 --> 00:26:45,840
did you observe or usually there's no

706
00:26:45,840 --> 00:26:47,760
interrupt whatsoever

707
00:26:47,760 --> 00:26:50,799
yeah so interrupts do not occur in

708
00:26:50,799 --> 00:26:52,880
that high frequency so you can perform

709
00:26:52,880 --> 00:26:54,559
measurements but for instance for a

710
00:26:54,559 --> 00:26:57,200
keystroke attack it would probably make

711
00:26:57,200 --> 00:27:00,480
it infeasible because um

712
00:27:00,480 --> 00:27:02,880
you you would not be able to distinguish

713
00:27:02,880 --> 00:27:05,279
a false positive from from

714
00:27:05,279 --> 00:27:07,200
from anything else you would have lots

715
00:27:07,200 --> 00:27:09,360
of false positives because there will be

716
00:27:09,360 --> 00:27:12,400
multiple interrupts per second

717
00:27:12,400 --> 00:27:13,440
but

718
00:27:13,440 --> 00:27:15,120
you wouldn't know that this was not a

719
00:27:15,120 --> 00:27:16,400
keystroke

720
00:27:16,400 --> 00:27:19,400
thanks

721
00:27:20,880 --> 00:27:24,080
okay um i have uh one more question um

722
00:27:24,080 --> 00:27:26,320
so i i know in this work that you you're

723
00:27:26,320 --> 00:27:28,799
mainly focusing on attacks right but um

724
00:27:28,799 --> 00:27:30,000
you know have you talked to vendors

725
00:27:30,000 --> 00:27:32,159
about what might be done to detect or

726
00:27:32,159 --> 00:27:34,480
prevent these attacks and and did your

727
00:27:34,480 --> 00:27:36,159
attacks give you any insight into what

728
00:27:36,159 --> 00:27:37,120
might be done

729
00:27:37,120 --> 00:27:40,000
well you can make attacks harder you can

730
00:27:40,000 --> 00:27:41,760
not use shared memory

731
00:27:41,760 --> 00:27:43,679
first of all then you can do a flush and

732
00:27:43,679 --> 00:27:45,600
reload attack and you have to go

733
00:27:45,600 --> 00:27:47,039
back to the

734
00:27:47,039 --> 00:27:50,000
much more noisy prime and probe attack

735
00:27:50,000 --> 00:27:52,399
and that probably won't work well on

736
00:27:52,399 --> 00:27:54,720
user input

737
00:27:54,720 --> 00:27:55,679
so

738
00:27:55,679 --> 00:27:57,120
you could also

739
00:27:57,120 --> 00:27:58,880
reduce the

740
00:27:58,880 --> 00:28:01,760
attack surface by by

741
00:28:01,760 --> 00:28:03,440
removing functions like the flush

742
00:28:03,440 --> 00:28:05,679
instruction of course

743
00:28:05,679 --> 00:28:07,679
but again you can then do eviction

744
00:28:07,679 --> 00:28:09,840
instead so it will make an attack harder

745
00:28:09,840 --> 00:28:11,919
and noisier but it is not an ultimate

746
00:28:11,919 --> 00:28:14,559
solution i think

747
00:28:14,559 --> 00:28:17,440
there is no uh no really really

748
00:28:17,440 --> 00:28:20,640
satisfying uh solution on cash attacks

749
00:28:20,640 --> 00:28:22,240
yet that is why there's still much

750
00:28:22,240 --> 00:28:25,440
research on on countermeasures going on

751
00:28:25,440 --> 00:28:27,360
okay thanks uh let's thank the speaker

752
00:28:27,360 --> 00:28:30,360
again

753
00:28:34,399 --> 00:28:36,479
you

