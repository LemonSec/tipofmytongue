1
00:00:10,320 --> 00:00:12,000
hello everyone so i'm going to present

2
00:00:12,000 --> 00:00:14,160
my work on the security of wi-fi

3
00:00:14,160 --> 00:00:16,880
groupies so what are wi-fi group keys

4
00:00:16,880 --> 00:00:18,560
well these are the keys that are used to

5
00:00:18,560 --> 00:00:21,359
encrypt broadcast on multicast wi-fi

6
00:00:21,359 --> 00:00:23,359
frames on these keys are of course

7
00:00:23,359 --> 00:00:25,519
shared by all clients in a wireless

8
00:00:25,519 --> 00:00:26,880
network

9
00:00:26,880 --> 00:00:28,480
the reason why we did this work is

10
00:00:28,480 --> 00:00:30,560
because we noticed that these group keys

11
00:00:30,560 --> 00:00:32,719
are have not yet been properly

12
00:00:32,719 --> 00:00:35,280
investigated this in contrast with a

13
00:00:35,280 --> 00:00:37,680
pre-shared key of a network or the

14
00:00:37,680 --> 00:00:39,840
negotiated pairwise keys

15
00:00:39,840 --> 00:00:42,320
so what we did in our work is we

16
00:00:42,320 --> 00:00:44,800
more investigated in detail the security

17
00:00:44,800 --> 00:00:46,399
of these group keys during their full

18
00:00:46,399 --> 00:00:48,480
lifetime now what do i mean with their

19
00:00:48,480 --> 00:00:51,360
full lifetime that means that we first

20
00:00:51,360 --> 00:00:53,600
investigate how these group keys are

21
00:00:53,600 --> 00:00:55,600
generated and we found that the

22
00:00:55,600 --> 00:00:57,120
construction that is used to generate

23
00:00:57,120 --> 00:00:59,760
these keys is not ideal and we also

24
00:00:59,760 --> 00:01:03,280
found that the wi-fi standard so 812.11

25
00:01:03,280 --> 00:01:06,479
contains a bad random number generator

26
00:01:06,479 --> 00:01:08,479
um of course this group key also has to

27
00:01:08,479 --> 00:01:10,840
be transported to clients that join the

28
00:01:10,840 --> 00:01:13,119
network and this group key is

29
00:01:13,119 --> 00:01:14,960
transported to clients during the

30
00:01:14,960 --> 00:01:17,520
four-way handshake and we found a way to

31
00:01:17,520 --> 00:01:20,880
uh force encryption uh of to

32
00:01:20,880 --> 00:01:23,920
force usage of rc4 to encrypt the group

33
00:01:23,920 --> 00:01:25,840
key while it is being transported to a

34
00:01:25,840 --> 00:01:28,400
client that is trying to connect

35
00:01:28,400 --> 00:01:30,479
and we're going to show how this attack

36
00:01:30,479 --> 00:01:31,680
works

37
00:01:31,680 --> 00:01:33,520
on with the group key you can of course

38
00:01:33,520 --> 00:01:36,640
decrypt on inject broadcast frames but

39
00:01:36,640 --> 00:01:39,280
we also devised a method to inject a

40
00:01:39,280 --> 00:01:42,320
unicos traffic and we also found and

41
00:01:42,320 --> 00:01:44,159
will present away how we can use the

42
00:01:44,159 --> 00:01:46,720
group key uh to decrypt nearly all

43
00:01:46,720 --> 00:01:49,200
traffic of a network including unicast

44
00:01:49,200 --> 00:01:50,320
traffic

45
00:01:50,320 --> 00:01:53,200
and we also have a small proposal for a

46
00:01:53,200 --> 00:01:54,720
better random number generator

47
00:01:54,720 --> 00:01:57,439
specifically for wi-fi platforms

48
00:01:57,439 --> 00:02:00,320
so let's start with the first part how

49
00:02:00,320 --> 00:02:01,680
is the group key

50
00:02:01,680 --> 00:02:04,240
in a wireless network generated

51
00:02:04,240 --> 00:02:08,000
well the adren 2.11 standard proposes

52
00:02:08,000 --> 00:02:10,160
but does not mandate

53
00:02:10,160 --> 00:02:13,520
a group key hierarchy which basically

54
00:02:13,520 --> 00:02:17,200
says how you can generate the group key

55
00:02:17,200 --> 00:02:18,560
and of course the group key is always

56
00:02:18,560 --> 00:02:20,160
generated by the access point and then

57
00:02:20,160 --> 00:02:22,800
transported to clients so what the

58
00:02:22,800 --> 00:02:25,280
standard suggests that you should do is

59
00:02:25,280 --> 00:02:28,000
that you should randomly generate

60
00:02:28,000 --> 00:02:29,920
two values i call them the public

61
00:02:29,920 --> 00:02:32,239
counter on the private master key so

62
00:02:32,239 --> 00:02:34,000
this public counter is assumed to be

63
00:02:34,000 --> 00:02:36,560
known to attacker but the master key

64
00:02:36,560 --> 00:02:38,720
must remain secret

65
00:02:38,720 --> 00:02:41,200
these two values are then used to derive

66
00:02:41,200 --> 00:02:44,560
group keys so how is that done well it's

67
00:02:44,560 --> 00:02:46,400
quite simple you increase the public

68
00:02:46,400 --> 00:02:49,120
counter by one you then combine it with

69
00:02:49,120 --> 00:02:51,440
the master key using a pseudorandom

70
00:02:51,440 --> 00:02:54,000
function onto the output of this

71
00:02:54,000 --> 00:02:57,120
function is the temporal group key

72
00:02:57,120 --> 00:02:58,000
so

73
00:02:58,000 --> 00:03:00,720
just to be clear the group key is

74
00:03:00,720 --> 00:03:04,800
abbreviated to gtk um and this

75
00:03:04,800 --> 00:03:07,200
construction allows you to

76
00:03:07,200 --> 00:03:09,680
periodically generate a new group key

77
00:03:09,680 --> 00:03:11,760
for example every hour by simply

78
00:03:11,760 --> 00:03:14,560
increasing this public counter however

79
00:03:14,560 --> 00:03:17,360
there is one big disadvantage with this

80
00:03:17,360 --> 00:03:20,720
construction and that's that these two

81
00:03:20,720 --> 00:03:24,000
values are randomly generated only at

82
00:03:24,000 --> 00:03:26,879
boot and that means that as your access

83
00:03:26,879 --> 00:03:29,360
point keeps on running no new entropy

84
00:03:29,360 --> 00:03:31,680
isn't is introduced to generate this

85
00:03:31,680 --> 00:03:32,720
group key

86
00:03:32,720 --> 00:03:35,120
in other words if for some reason this

87
00:03:35,120 --> 00:03:37,360
master key here leaks

88
00:03:37,360 --> 00:03:40,560
an attacker can calculate all past on

89
00:03:40,560 --> 00:03:42,640
future group keys that are used by the

90
00:03:42,640 --> 00:03:45,040
wi-fi network and that is of course not

91
00:03:45,040 --> 00:03:46,400
something that you want

92
00:03:46,400 --> 00:03:48,959
because if this random number generator

93
00:03:48,959 --> 00:03:51,920
that is used to generate these values is

94
00:03:51,920 --> 00:03:52,879
weak

95
00:03:52,879 --> 00:03:55,040
then we could try to recover these

96
00:03:55,040 --> 00:03:57,680
values and in turn recover all group

97
00:03:57,680 --> 00:03:58,640
keys

98
00:03:58,640 --> 00:04:01,040
so let's see whether the random number

99
00:04:01,040 --> 00:04:03,840
generator is actually secure or not

100
00:04:03,840 --> 00:04:04,640
now

101
00:04:04,640 --> 00:04:06,439
interestingly the

102
00:04:06,439 --> 00:04:09,760
802.11 standard so wi-fi

103
00:04:09,760 --> 00:04:11,840
contains an example random number

104
00:04:11,840 --> 00:04:14,480
generator and when you are reading the

105
00:04:14,480 --> 00:04:16,720
specification itself

106
00:04:16,720 --> 00:04:18,560
there are references in the text that

107
00:04:18,560 --> 00:04:21,440
states if you need cryptographic quality

108
00:04:21,440 --> 00:04:23,040
randomness

109
00:04:23,040 --> 00:04:24,320
then you can

110
00:04:24,320 --> 00:04:26,560
implement the random number generator

111
00:04:26,560 --> 00:04:28,560
that is contained in the appendix of the

112
00:04:28,560 --> 00:04:31,199
standard so if you read that line it

113
00:04:31,199 --> 00:04:33,199
sounds good i mean you have a random

114
00:04:33,199 --> 00:04:35,520
number generator it's supposed to be

115
00:04:35,520 --> 00:04:37,680
cryptographic quality

116
00:04:37,680 --> 00:04:39,360
but if you then actually go to the

117
00:04:39,360 --> 00:04:42,000
appendix of the standard

118
00:04:42,000 --> 00:04:43,680
you immediately encounter a very

119
00:04:43,680 --> 00:04:46,000
different tone it says yeah this

120
00:04:46,000 --> 00:04:48,800
algorithm is an example only

121
00:04:48,800 --> 00:04:50,880
you're supposed to extend it with other

122
00:04:50,880 --> 00:04:52,720
sources of entropy

123
00:04:52,720 --> 00:04:54,560
this is basically just to show that you

124
00:04:54,560 --> 00:04:57,199
can collect some amount of entropy so in

125
00:04:57,199 --> 00:04:58,880
other words the standard is not

126
00:04:58,880 --> 00:05:00,800
consistent with itself at least in my

127
00:05:00,800 --> 00:05:01,919
opinion

128
00:05:01,919 --> 00:05:04,400
in some cases it says that this random

129
00:05:04,400 --> 00:05:07,039
number generator is good but if you look

130
00:05:07,039 --> 00:05:08,960
at the algorithm it says this is just an

131
00:05:08,960 --> 00:05:10,720
example you're supposed to extend on

132
00:05:10,720 --> 00:05:11,840
improve it

133
00:05:11,840 --> 00:05:14,320
so now the question is how secure is

134
00:05:14,320 --> 00:05:17,440
this example random number generator on

135
00:05:17,440 --> 00:05:20,479
do people actually implement it

136
00:05:20,479 --> 00:05:23,520
so if we look at the

137
00:05:23,520 --> 00:05:25,360
if you look in this appendix and we look

138
00:05:25,360 --> 00:05:27,840
at the random number generator you

139
00:05:27,840 --> 00:05:30,160
indeed see that it's

140
00:05:30,160 --> 00:05:32,320
quite quickly thrown together the

141
00:05:32,320 --> 00:05:35,360
description is not that formal and

142
00:05:35,360 --> 00:05:37,199
basically the random number generator

143
00:05:37,199 --> 00:05:39,039
that they promote proposed that they

144
00:05:39,039 --> 00:05:41,440
give as an example is just a stateless

145
00:05:41,440 --> 00:05:44,320
function that returns uh two 32

146
00:05:44,320 --> 00:05:46,880
supposedly random bytes

147
00:05:46,880 --> 00:05:49,440
and the entropy that is used to generate

148
00:05:49,440 --> 00:05:52,720
232 bytes is collected on demand so

149
00:05:52,720 --> 00:05:54,479
when this random number generator is

150
00:05:54,479 --> 00:05:57,039
being called only then are events uh

151
00:05:57,039 --> 00:05:59,520
being sampled and used to extract

152
00:05:59,520 --> 00:06:00,960
randomness

153
00:06:00,960 --> 00:06:03,919
um on the the vents that are used here

154
00:06:03,919 --> 00:06:06,720
are frame arrival times on clock jitter

155
00:06:06,720 --> 00:06:09,600
so those are the sources of entropy

156
00:06:09,600 --> 00:06:12,240
so if you see this you should be quite

157
00:06:12,240 --> 00:06:14,560
concerned because this deviates from the

158
00:06:14,560 --> 00:06:16,400
normal construction of a random number

159
00:06:16,400 --> 00:06:18,639
generator where your random number

160
00:06:18,639 --> 00:06:21,600
generating is random number generator is

161
00:06:21,600 --> 00:06:24,080
maintaining a pool of entropy which is

162
00:06:24,080 --> 00:06:26,560
uh constantly updated and received and

163
00:06:26,560 --> 00:06:28,160
reseeded

164
00:06:28,160 --> 00:06:29,039
and

165
00:06:29,039 --> 00:06:31,120
normally you also constantly collect

166
00:06:31,120 --> 00:06:33,280
entropy from events and not just when

167
00:06:33,280 --> 00:06:36,080
you call your random number generator

168
00:06:36,080 --> 00:06:38,639
so let's go in detail about the entropy

169
00:06:38,639 --> 00:06:40,960
sources that are used so these frame

170
00:06:40,960 --> 00:06:45,039
arrival times on the clock chatter

171
00:06:45,600 --> 00:06:46,639
so

172
00:06:46,639 --> 00:06:49,599
the standard says that you can collect

173
00:06:49,599 --> 00:06:51,520
the arrival times of

174
00:06:51,520 --> 00:06:53,680
ethernet packets but

175
00:06:53,680 --> 00:06:54,720
of course

176
00:06:54,720 --> 00:06:56,319
an access point may not always be

177
00:06:56,319 --> 00:06:58,960
connected to a backbone ethernet network

178
00:06:58,960 --> 00:07:01,759
so the second option it provides

179
00:07:01,759 --> 00:07:04,080
is that you can try to repeatedly

180
00:07:04,080 --> 00:07:06,639
initiate the four-way handshake and then

181
00:07:06,639 --> 00:07:08,720
collect entropy from the arrival time of

182
00:07:08,720 --> 00:07:11,440
frames now this is a very strange

183
00:07:11,440 --> 00:07:14,160
suggestion by the wi-fi standard because

184
00:07:14,160 --> 00:07:15,919
initiating this handshake is only

185
00:07:15,919 --> 00:07:18,240
possible when a try and client is trying

186
00:07:18,240 --> 00:07:19,680
to connect or you would have to

187
00:07:19,680 --> 00:07:21,280
disconnect the client so he would

188
00:07:21,280 --> 00:07:22,720
reconnect so

189
00:07:22,720 --> 00:07:24,960
it's very strange that they

190
00:07:24,960 --> 00:07:26,960
proposed this because it's also very

191
00:07:26,960 --> 00:07:28,240
slow

192
00:07:28,240 --> 00:07:30,800
but a more important problem is that if

193
00:07:30,800 --> 00:07:32,080
you would indeed

194
00:07:32,080 --> 00:07:34,400
constantly try to initiate this

195
00:07:34,400 --> 00:07:37,039
handshake and then abort it your client

196
00:07:37,039 --> 00:07:39,280
would simply blacklist this access point

197
00:07:39,280 --> 00:07:41,039
for example if your phone is constantly

198
00:07:41,039 --> 00:07:43,199
trying to connect to a network but it

199
00:07:43,199 --> 00:07:45,520
repeatedly loses the connection it won't

200
00:07:45,520 --> 00:07:47,440
try to reconnect again so

201
00:07:47,440 --> 00:07:49,680
if you would use this approach the

202
00:07:49,680 --> 00:07:51,759
access point would essentially dos

203
00:07:51,759 --> 00:07:53,599
itself

204
00:07:53,599 --> 00:07:56,080
so that's not a good idea

205
00:07:56,080 --> 00:07:58,879
so the second suggestion uh that was uh

206
00:07:58,879 --> 00:08:01,759
provided to collect entropy was uh to

207
00:08:01,759 --> 00:08:04,479
use uh the clock jitter so to

208
00:08:04,479 --> 00:08:06,800
essentially constantly query uh what

209
00:08:06,800 --> 00:08:08,800
time is it and uh

210
00:08:08,800 --> 00:08:12,160
collect uh entropy from that

211
00:08:12,160 --> 00:08:15,039
now a first small note here it's not

212
00:08:15,039 --> 00:08:17,280
that important is that the current time

213
00:08:17,280 --> 00:08:19,759
of a router can be leaked through the

214
00:08:19,759 --> 00:08:21,840
beacons

215
00:08:21,840 --> 00:08:24,160
so as an attacker we know how long the

216
00:08:24,160 --> 00:08:27,360
router is running now this is not really

217
00:08:27,360 --> 00:08:29,199
a concern if you want to base yourself

218
00:08:29,199 --> 00:08:30,720
on clock jitter

219
00:08:30,720 --> 00:08:32,159
because uh

220
00:08:32,159 --> 00:08:33,839
knowing the uptime is not really

221
00:08:33,839 --> 00:08:36,080
sufficient to predict the amount of

222
00:08:36,080 --> 00:08:37,279
jitter

223
00:08:37,279 --> 00:08:39,760
however what is a problem is that the

224
00:08:39,760 --> 00:08:42,240
wi-fi standard doesn't mandate a minimum

225
00:08:42,240 --> 00:08:43,440
resolution

226
00:08:43,440 --> 00:08:45,839
for the clock that is being used

227
00:08:45,839 --> 00:08:47,200
so it could be that if you are

228
00:08:47,200 --> 00:08:48,880
constantly trying to get the current

229
00:08:48,880 --> 00:08:49,680
time

230
00:08:49,680 --> 00:08:51,839
you repeatedly get the same result and

231
00:08:51,839 --> 00:08:54,640
you aren't really collecting that much

232
00:08:54,640 --> 00:08:56,000
entropy

233
00:08:56,000 --> 00:08:59,040
so when i read the standard i think it

234
00:08:59,040 --> 00:09:01,440
was around a year ago or two i

235
00:09:01,440 --> 00:09:03,279
encountered this random number generator

236
00:09:03,279 --> 00:09:04,959
but i thought that no one would

237
00:09:04,959 --> 00:09:06,800
implement this

238
00:09:06,800 --> 00:09:08,800
a year later i encountered some source

239
00:09:08,800 --> 00:09:11,519
code where surprisingly someone did

240
00:09:11,519 --> 00:09:13,600
implement this and then i decided to

241
00:09:13,600 --> 00:09:15,760
investigate this in more detail

242
00:09:15,760 --> 00:09:16,480
so

243
00:09:16,480 --> 00:09:18,480
what's surprising here is that for

244
00:09:18,480 --> 00:09:21,440
example mediatek they

245
00:09:21,440 --> 00:09:23,839
almost exactly implement this random

246
00:09:23,839 --> 00:09:26,080
number generator but they only collect

247
00:09:26,080 --> 00:09:28,560
randomness from the clock jitter

248
00:09:28,560 --> 00:09:31,440
on broadcom also has a custom random

249
00:09:31,440 --> 00:09:34,399
number generator it doesn't resemble uh

250
00:09:34,399 --> 00:09:35,839
the

251
00:09:35,839 --> 00:09:37,920
random number generator provided by

252
00:09:37,920 --> 00:09:40,640
wi-fi that much but it still also uses a

253
00:09:40,640 --> 00:09:42,800
clock jitter so i'm going to focus on

254
00:09:42,800 --> 00:09:44,880
the random number generator that is used

255
00:09:44,880 --> 00:09:48,080
by mediatek because it resembles this

256
00:09:48,080 --> 00:09:50,000
supposedly official

257
00:09:50,000 --> 00:09:53,200
random number generator a lot so

258
00:09:53,200 --> 00:09:57,120
to briefly summarize mediatek

259
00:09:57,120 --> 00:09:59,120
almost exactly implements this random

260
00:09:59,120 --> 00:10:01,120
number generator but it only uses a

261
00:10:01,120 --> 00:10:05,680
clock jitter as a source of entropy and

262
00:10:05,680 --> 00:10:08,000
what is more problematic is that the

263
00:10:08,000 --> 00:10:09,839
time stamp that it tries to collect is

264
00:10:09,839 --> 00:10:11,040
the so-called

265
00:10:11,040 --> 00:10:13,760
jiffy's counter of the linux kernel

266
00:10:13,760 --> 00:10:15,839
now the time

267
00:10:15,839 --> 00:10:18,079
the time resolution of this jeffy

268
00:10:18,079 --> 00:10:21,680
counter is very low at best it has a

269
00:10:21,680 --> 00:10:23,920
accuracy of around

270
00:10:23,920 --> 00:10:26,720
a few of millisecond accuracy which

271
00:10:26,720 --> 00:10:28,480
means that if you would repeatedly try

272
00:10:28,480 --> 00:10:30,959
to query the amount of jiffys that have

273
00:10:30,959 --> 00:10:33,120
been passed you would constantly get the

274
00:10:33,120 --> 00:10:34,959
same value and there is not much

275
00:10:34,959 --> 00:10:37,360
variation so you also won't be

276
00:10:37,360 --> 00:10:40,079
collecting that much entropy

277
00:10:40,079 --> 00:10:43,360
so one example router that implements

278
00:10:43,360 --> 00:10:46,320
this algorithm is the one illustrated

279
00:10:46,320 --> 00:10:47,360
here

280
00:10:47,360 --> 00:10:50,240
on we tried to uh break the random

281
00:10:50,240 --> 00:10:52,560
number generator of this device by

282
00:10:52,560 --> 00:10:55,040
predicting uh the group key

283
00:10:55,040 --> 00:10:57,360
so how did we do that uh well we still

284
00:10:57,360 --> 00:10:59,760
need to be fast enough

285
00:10:59,760 --> 00:11:02,079
to explore all the possible candidates

286
00:11:02,079 --> 00:11:04,800
for the group key so essentially we made

287
00:11:04,800 --> 00:11:06,640
an opencl program

288
00:11:06,640 --> 00:11:09,680
that we can run on a gpu

289
00:11:09,680 --> 00:11:10,640
and

290
00:11:10,640 --> 00:11:12,720
even on a very

291
00:11:12,720 --> 00:11:15,120
standard gpu for example the one in my

292
00:11:15,120 --> 00:11:17,920
laptop here it's not a it's a decent gpu

293
00:11:17,920 --> 00:11:20,640
but definitely not a high-end one

294
00:11:20,640 --> 00:11:23,120
if we then uh capture some traffic of

295
00:11:23,120 --> 00:11:24,399
the network

296
00:11:24,399 --> 00:11:26,320
and then if we then try to search for

297
00:11:26,320 --> 00:11:28,240
the group key by trying to decrypt a

298
00:11:28,240 --> 00:11:30,640
broadcast or multicast frame it takes

299
00:11:30,640 --> 00:11:33,279
around three to four minutes to uh

300
00:11:33,279 --> 00:11:35,680
obtain the group key on in a sense to

301
00:11:35,680 --> 00:11:37,920
break the random number generator

302
00:11:37,920 --> 00:11:40,480
and the result of this attack is not

303
00:11:40,480 --> 00:11:42,399
just the current group key but we are

304
00:11:42,399 --> 00:11:45,839
also able to recover this uh master key

305
00:11:45,839 --> 00:11:48,160
our explanation is a bit simplified here

306
00:11:48,160 --> 00:11:50,800
but essentially once we also have this

307
00:11:50,800 --> 00:11:53,360
monster key it is trivial to predict the

308
00:11:53,360 --> 00:11:56,560
next group key that will be generated so

309
00:11:56,560 --> 00:11:58,480
the first time we perform this attack it

310
00:11:58,480 --> 00:12:00,320
takes about three to four minutes but if

311
00:12:00,320 --> 00:12:02,000
the access point then generates a new

312
00:12:02,000 --> 00:12:04,480
group key we can predict and guess that

313
00:12:04,480 --> 00:12:06,959
one very fast

314
00:12:06,959 --> 00:12:09,680
so the other example here of broadcom we

315
00:12:09,680 --> 00:12:12,560
were also able to implement

316
00:12:12,560 --> 00:12:13,680
an algorithm

317
00:12:13,680 --> 00:12:16,000
on the gpu where it took around four to

318
00:12:16,000 --> 00:12:18,720
five minutes to predict uh this group

319
00:12:18,720 --> 00:12:20,079
key

320
00:12:20,079 --> 00:12:20,800
so

321
00:12:20,800 --> 00:12:22,480
the conclusion here is that this random

322
00:12:22,480 --> 00:12:25,200
number generator is indeed quite bad

323
00:12:25,200 --> 00:12:27,519
so for the second

324
00:12:27,519 --> 00:12:29,519
part we

325
00:12:29,519 --> 00:12:31,360
investigated how this group key is

326
00:12:31,360 --> 00:12:33,040
transported to clients that are trying

327
00:12:33,040 --> 00:12:35,279
to connect to the network

328
00:12:35,279 --> 00:12:37,360
so this is done using the four-way

329
00:12:37,360 --> 00:12:40,639
handshake so let's uh briefly illustrate

330
00:12:40,639 --> 00:12:43,200
this using a simplified illustration of

331
00:12:43,200 --> 00:12:45,440
the handshake so when you're trying to

332
00:12:45,440 --> 00:12:47,200
connect to a network

333
00:12:47,200 --> 00:12:48,880
what a client does is you listen for

334
00:12:48,880 --> 00:12:51,440
beacons you detect which ciphers this

335
00:12:51,440 --> 00:12:54,240
network supports you select the cipher

336
00:12:54,240 --> 00:12:56,399
you want to use and then you tell the

337
00:12:56,399 --> 00:12:59,120
access point hey i want to connect using

338
00:12:59,120 --> 00:13:01,040
this cipher

339
00:13:01,040 --> 00:13:03,519
then you initiate the first part of the

340
00:13:03,519 --> 00:13:06,800
actual four-way group a four-way

341
00:13:06,800 --> 00:13:08,240
handshake

342
00:13:08,240 --> 00:13:09,760
where the first two messages are

343
00:13:09,760 --> 00:13:11,920
essentially nonsense which are used to

344
00:13:11,920 --> 00:13:15,120
negotiate session keys so here the ptkey

345
00:13:15,120 --> 00:13:17,120
here is the session key

346
00:13:17,120 --> 00:13:20,320
once we have uh agreed on these session

347
00:13:20,320 --> 00:13:22,079
keys we can continue the four-way

348
00:13:22,079 --> 00:13:23,440
handshake

349
00:13:23,440 --> 00:13:25,200
on the first thing that the access point

350
00:13:25,200 --> 00:13:28,320
does it sends the list of

351
00:13:28,320 --> 00:13:30,959
available ciphers that it supports in a

352
00:13:30,959 --> 00:13:33,760
secure manner so these information

353
00:13:33,760 --> 00:13:36,720
elements here contain the list of

354
00:13:36,720 --> 00:13:39,120
ciphers that the access point

355
00:13:39,120 --> 00:13:41,360
supports in a secure manner so the

356
00:13:41,360 --> 00:13:44,160
attacker is not able to mess with these

357
00:13:44,160 --> 00:13:46,839
information elements

358
00:13:46,839 --> 00:13:51,760
um so once the client has received the

359
00:13:51,760 --> 00:13:53,920
list of supported cipher suites it

360
00:13:53,920 --> 00:13:55,680
compare can compare it with the cipher

361
00:13:55,680 --> 00:13:57,680
suites that are contained in the beacon

362
00:13:57,680 --> 00:13:59,199
in order to try to

363
00:13:59,199 --> 00:14:01,199
detect a downgrade attack

364
00:14:01,199 --> 00:14:02,720
for example if there was a man in the

365
00:14:02,720 --> 00:14:04,639
middle that said the access point only

366
00:14:04,639 --> 00:14:08,880
supported an old cipher

367
00:14:09,040 --> 00:14:10,959
that downgrade attack will be detected

368
00:14:10,959 --> 00:14:12,720
here so

369
00:14:12,720 --> 00:14:15,519
what's the problem with this approach is

370
00:14:15,519 --> 00:14:18,880
that this message tree also contains

371
00:14:18,880 --> 00:14:21,120
the group key in an encrypted form in

372
00:14:21,120 --> 00:14:23,760
other words it is sending on encrypting

373
00:14:23,760 --> 00:14:26,160
the group key before a possible

374
00:14:26,160 --> 00:14:28,560
downgrade attack is detected

375
00:14:28,560 --> 00:14:31,360
so as an attacker we can abuse this uh

376
00:14:31,360 --> 00:14:33,920
we can construct uh and

377
00:14:33,920 --> 00:14:35,199
um

378
00:14:35,199 --> 00:14:37,440
of course now it's important uh whether

379
00:14:37,440 --> 00:14:39,519
a weak cipher can be used to encrypt

380
00:14:39,519 --> 00:14:41,040
this group key or not

381
00:14:41,040 --> 00:14:42,800
um so

382
00:14:42,800 --> 00:14:45,199
how does the standard decide which

383
00:14:45,199 --> 00:14:47,279
cipher is being used to encrypt this

384
00:14:47,279 --> 00:14:48,560
group key here

385
00:14:48,560 --> 00:14:52,160
well if your selected cipher is wpa2

386
00:14:52,160 --> 00:14:53,199
tkip

387
00:14:53,199 --> 00:14:55,279
then this here will be encrypted using

388
00:14:55,279 --> 00:14:56,480
rc4

389
00:14:56,480 --> 00:14:59,600
if your pairwise cipher is aes

390
00:14:59,600 --> 00:15:01,680
then the group key will be encrypted

391
00:15:01,680 --> 00:15:04,399
using aes as well and of course the

392
00:15:04,399 --> 00:15:07,120
problem here is rc4

393
00:15:07,120 --> 00:15:09,440
so how can we mount an attack against

394
00:15:09,440 --> 00:15:10,240
this

395
00:15:10,240 --> 00:15:13,120
well essentially

396
00:15:13,120 --> 00:15:15,920
we will put up a rogue access point

397
00:15:15,920 --> 00:15:17,600
where instead of listing all the

398
00:15:17,600 --> 00:15:20,079
supported ciphers of this access point

399
00:15:20,079 --> 00:15:22,079
we will pretend that this access point

400
00:15:22,079 --> 00:15:25,040
only supports wpa tkip

401
00:15:25,040 --> 00:15:28,240
the client is then forced to use this

402
00:15:28,240 --> 00:15:30,959
cipher suite so it will use so we'll say

403
00:15:30,959 --> 00:15:32,800
to the access point okay i want to

404
00:15:32,800 --> 00:15:35,839
connect to you using wpatkip

405
00:15:35,839 --> 00:15:37,600
the rest of the handshake here will

406
00:15:37,600 --> 00:15:40,959
continue as normal but now the group key

407
00:15:40,959 --> 00:15:43,680
will be encrypted using rc4 because the

408
00:15:43,680 --> 00:15:45,680
client here uh

409
00:15:45,680 --> 00:15:49,199
requested wpa tkip and this downgrade

410
00:15:49,199 --> 00:15:51,920
attack is only detected after the group

411
00:15:51,920 --> 00:15:54,639
key has been encrypted using this weak

412
00:15:54,639 --> 00:15:56,639
cipher

413
00:15:56,639 --> 00:16:00,079
so now we can try to attack rc4 in this

414
00:16:00,079 --> 00:16:02,240
setting now i'm not going to go in the

415
00:16:02,240 --> 00:16:04,560
details here

416
00:16:04,560 --> 00:16:07,199
essentially the rc4 key that is used to

417
00:16:07,199 --> 00:16:08,720
encrypt the group key is the

418
00:16:08,720 --> 00:16:11,120
concatenation of a 16 byte public

419
00:16:11,120 --> 00:16:14,079
initialization vector together with a 16

420
00:16:14,079 --> 00:16:16,480
byte session key

421
00:16:16,480 --> 00:16:19,440
and interestingly the first 256 key

422
00:16:19,440 --> 00:16:22,720
stream bytes are dropped now we can use

423
00:16:22,720 --> 00:16:28,079
existing attacks against rc4 modified to

424
00:16:28,079 --> 00:16:32,399
essentially work in this situation and

425
00:16:32,399 --> 00:16:34,399
one of the best attacks we can come up

426
00:16:34,399 --> 00:16:36,480
with

427
00:16:36,480 --> 00:16:37,360
is

428
00:16:37,360 --> 00:16:39,360
in a sense similar to the attacks that

429
00:16:39,360 --> 00:16:42,160
were used against ssl on tls where we

430
00:16:42,160 --> 00:16:45,040
try to decrypt

431
00:16:45,440 --> 00:16:48,160
a secret that is repeatedly

432
00:16:48,160 --> 00:16:50,800
that is repeatedly included in a message

433
00:16:50,800 --> 00:16:53,839
so um essentially this means that as an

434
00:16:53,839 --> 00:16:56,480
attacker if i am able to generate two to

435
00:16:56,480 --> 00:16:59,440
the 31 handshakes which all include the

436
00:16:59,440 --> 00:17:01,920
same group key then i am able to recover

437
00:17:01,920 --> 00:17:04,400
this group key however the problem with

438
00:17:04,400 --> 00:17:06,640
this attack is that it takes

439
00:17:06,640 --> 00:17:08,640
a lot of time to

440
00:17:08,640 --> 00:17:11,039
simply execute one handshake onto exit

441
00:17:11,039 --> 00:17:12,640
and to capture one encryption of the

442
00:17:12,640 --> 00:17:15,439
group key so assuming we can as an

443
00:17:15,439 --> 00:17:18,559
attacker uh force a client to

444
00:17:18,559 --> 00:17:20,959
perform one handshake every second this

445
00:17:20,959 --> 00:17:23,119
would take more than 50 years to execute

446
00:17:23,119 --> 00:17:24,079
so

447
00:17:24,079 --> 00:17:26,559
it is not a practical attack however it

448
00:17:26,559 --> 00:17:28,319
does show that we should definitely

449
00:17:28,319 --> 00:17:31,600
avoid rc4 here because if someone comes

450
00:17:31,600 --> 00:17:33,679
up with an even better attack or is able

451
00:17:33,679 --> 00:17:35,679
to collect these handshakes

452
00:17:35,679 --> 00:17:37,600
faster then this could turn into a

453
00:17:37,600 --> 00:17:40,000
practical attack

454
00:17:40,000 --> 00:17:42,559
so what are the counter measures

455
00:17:42,559 --> 00:17:46,320
the first is to disable wpatkip and rc4

456
00:17:46,320 --> 00:17:49,200
then you avoid this all together however

457
00:17:49,200 --> 00:17:51,679
another important remark is that

458
00:17:51,679 --> 00:17:54,400
in the handshake we were sending secret

459
00:17:54,400 --> 00:17:55,600
data

460
00:17:55,600 --> 00:17:58,799
in this case the group key before

461
00:17:58,799 --> 00:18:01,280
we prevented and tried to detect

462
00:18:01,280 --> 00:18:03,120
downgrade attacks so another way to

463
00:18:03,120 --> 00:18:05,039
defend against this is to first execute

464
00:18:05,039 --> 00:18:07,280
the handshake and not yet include the

465
00:18:07,280 --> 00:18:09,360
group key in this handshake but only

466
00:18:09,360 --> 00:18:11,280
send a group key after the handshake has

467
00:18:11,280 --> 00:18:13,440
been completed and this is perfectly

468
00:18:13,440 --> 00:18:16,000
possible in a backwards compatible uh

469
00:18:16,000 --> 00:18:18,320
manner

470
00:18:18,320 --> 00:18:20,400
so uh in other words we are able to

471
00:18:20,400 --> 00:18:23,600
force usage of rc4 uh on in theory we

472
00:18:23,600 --> 00:18:26,240
can then decrypt the group key

473
00:18:26,240 --> 00:18:28,640
so the third part of our attacks is that

474
00:18:28,640 --> 00:18:31,120
we are going to abuse this group key to

475
00:18:31,120 --> 00:18:34,320
try to decrypt unicost packets onto

476
00:18:34,320 --> 00:18:37,280
inject unicost packets as well

477
00:18:37,280 --> 00:18:39,760
so let's say we have a wireless network

478
00:18:39,760 --> 00:18:42,080
we have our access point here on a

479
00:18:42,080 --> 00:18:43,440
victim

480
00:18:43,440 --> 00:18:45,280
here and

481
00:18:45,280 --> 00:18:47,200
let's assume that we as an attacker know

482
00:18:47,200 --> 00:18:49,360
the group key for example by brute

483
00:18:49,360 --> 00:18:51,120
forcing it

484
00:18:51,120 --> 00:18:53,039
on exploiting this bad random number

485
00:18:53,039 --> 00:18:55,280
generator then

486
00:18:55,280 --> 00:18:57,360
an initial id might be to simply

487
00:18:57,360 --> 00:19:00,720
encapsulate a unicost ip packet in a

488
00:19:00,720 --> 00:19:03,840
multicast or broadcast wi-fi frame

489
00:19:03,840 --> 00:19:06,320
however this is not possible

490
00:19:06,320 --> 00:19:08,960
this is detected by the so called

491
00:19:08,960 --> 00:19:13,039
hall 196 check so a few years ago at

492
00:19:13,039 --> 00:19:16,160
defcon the whole 196 attack was

493
00:19:16,160 --> 00:19:18,720
demonstrated on basically

494
00:19:18,720 --> 00:19:21,360
they proposed this attack scenario where

495
00:19:21,360 --> 00:19:23,600
if you have a group key you could inject

496
00:19:23,600 --> 00:19:25,679
unicost packets in a broadcast wi-fi

497
00:19:25,679 --> 00:19:28,400
frame however most systems now try to

498
00:19:28,400 --> 00:19:31,360
detect this they try to detect whether a

499
00:19:31,360 --> 00:19:34,240
unicost ip packet was received

500
00:19:34,240 --> 00:19:37,280
in a broadcast link layer address and if

501
00:19:37,280 --> 00:19:40,559
that's the case they drop this package

502
00:19:40,559 --> 00:19:42,400
however this detection can only be

503
00:19:42,400 --> 00:19:44,240
implemented

504
00:19:44,240 --> 00:19:45,919
by a device

505
00:19:45,919 --> 00:19:48,000
which actually processes these ip

506
00:19:48,000 --> 00:19:49,760
packets

507
00:19:49,760 --> 00:19:51,919
so our insight here is that if you have

508
00:19:51,919 --> 00:19:54,559
an access point it only works at the

509
00:19:54,559 --> 00:19:56,720
link layer or not at the net network

510
00:19:56,720 --> 00:19:58,559
layer in other words it doesn't know

511
00:19:58,559 --> 00:19:59,760
anything about

512
00:19:59,760 --> 00:20:03,039
ip or any protocol above it

513
00:20:03,039 --> 00:20:05,360
and we can now abuse the access point in

514
00:20:05,360 --> 00:20:08,240
order to inject a unicast packet so how

515
00:20:08,240 --> 00:20:10,960
does this work well we have our attacker

516
00:20:10,960 --> 00:20:14,159
here it will encapsulate the ip packet

517
00:20:14,159 --> 00:20:16,480
which is represented by the data here

518
00:20:16,480 --> 00:20:19,600
inside a broadcast packet and it will

519
00:20:19,600 --> 00:20:21,600
encrypt this packet using the group key

520
00:20:21,600 --> 00:20:24,159
and it will then send this broadcast

521
00:20:24,159 --> 00:20:26,720
packet towards the access point

522
00:20:26,720 --> 00:20:28,960
so here the access point is the receiver

523
00:20:28,960 --> 00:20:31,200
of this packet however the final

524
00:20:31,200 --> 00:20:34,080
destination of the packet will be our

525
00:20:34,080 --> 00:20:35,039
victim

526
00:20:35,039 --> 00:20:37,280
so when the access point receives this

527
00:20:37,280 --> 00:20:41,039
packet it will simply uh decrypt it um

528
00:20:41,039 --> 00:20:43,760
it will process it and uh it will then

529
00:20:43,760 --> 00:20:45,360
forward the frame to its final

530
00:20:45,360 --> 00:20:46,960
destination

531
00:20:46,960 --> 00:20:48,640
let's assume that the final destination

532
00:20:48,640 --> 00:20:50,960
now is the victim well it has this

533
00:20:50,960 --> 00:20:52,320
normal uh

534
00:20:52,320 --> 00:20:55,280
ip packet here uh it simply encrypts it

535
00:20:55,280 --> 00:20:56,960
now using the pairwise key that was

536
00:20:56,960 --> 00:20:58,799
negotiated between the access point on

537
00:20:58,799 --> 00:20:59,919
the victim

538
00:20:59,919 --> 00:21:02,000
the destination address is now simply a

539
00:21:02,000 --> 00:21:03,919
unicost mac address

540
00:21:03,919 --> 00:21:06,400
in other words the victim sees a very

541
00:21:06,400 --> 00:21:07,360
normal

542
00:21:07,360 --> 00:21:10,159
unicost wi-fi frame which is encrypted

543
00:21:10,159 --> 00:21:12,400
using the correct key and it contains a

544
00:21:12,400 --> 00:21:15,440
unicast ip packet so to summarize this

545
00:21:15,440 --> 00:21:18,480
slide basically we can try we can inject

546
00:21:18,480 --> 00:21:21,360
unicost ip packets using uh the group

547
00:21:21,360 --> 00:21:23,919
key by abusing the access point to

548
00:21:23,919 --> 00:21:27,360
forward it to the victim

549
00:21:27,360 --> 00:21:29,280
so we can now inject

550
00:21:29,280 --> 00:21:32,240
unicast packet so how are we able to

551
00:21:32,240 --> 00:21:33,679
decrypt

552
00:21:33,679 --> 00:21:36,080
most of the other traffic well the idea

553
00:21:36,080 --> 00:21:37,840
is very simple

554
00:21:37,840 --> 00:21:39,039
we simply

555
00:21:39,039 --> 00:21:41,200
are poison all the other stations to the

556
00:21:41,200 --> 00:21:43,600
broadcast mac address so if the router

557
00:21:43,600 --> 00:21:46,400
now wants to send a packet

558
00:21:46,400 --> 00:21:47,200
to

559
00:21:47,200 --> 00:21:49,520
a client

560
00:21:49,520 --> 00:21:51,840
it will look up the mac address of this

561
00:21:51,840 --> 00:21:53,600
client which is now the broadcast mac

562
00:21:53,600 --> 00:21:54,480
address

563
00:21:54,480 --> 00:21:55,919
and it will send this

564
00:21:55,919 --> 00:21:58,080
data as a broadcast wi-fi frame meaning

565
00:21:58,080 --> 00:22:00,240
it's encrypted using the group key on

566
00:22:00,240 --> 00:22:02,240
since it encrypt since it is encrypted

567
00:22:02,240 --> 00:22:04,240
using the group key we can simply uh

568
00:22:04,240 --> 00:22:07,840
decrypt this frame so we can target ipv4

569
00:22:07,840 --> 00:22:11,520
ipv6 and so on using a method similar to

570
00:22:11,520 --> 00:22:13,039
our poisoning

571
00:22:13,039 --> 00:22:14,720
so the counter measure against this

572
00:22:14,720 --> 00:22:16,960
attack is that the access point simply

573
00:22:16,960 --> 00:22:19,520
should never process frames that are

574
00:22:19,520 --> 00:22:21,679
received on a group

575
00:22:21,679 --> 00:22:22,559
or

576
00:22:22,559 --> 00:22:24,159
that are received on a broadcast or

577
00:22:24,159 --> 00:22:27,200
multicast mac address because clients

578
00:22:27,200 --> 00:22:29,600
shouldn't be sending a broadcast or

579
00:22:29,600 --> 00:22:32,000
multicast package themself it's always

580
00:22:32,000 --> 00:22:33,360
the access point

581
00:22:33,360 --> 00:22:35,039
that sends broadcast

582
00:22:35,039 --> 00:22:37,120
frames because that also assures that

583
00:22:37,120 --> 00:22:39,440
all connected clients will receive

584
00:22:39,440 --> 00:22:42,400
these broadcast messages

585
00:22:42,400 --> 00:22:45,919
so that concludes uh most of our attacks

586
00:22:45,919 --> 00:22:48,400
the final thing that we did

587
00:22:48,400 --> 00:22:50,240
it's

588
00:22:50,240 --> 00:22:52,159
the more smaller contribution is that we

589
00:22:52,159 --> 00:22:55,360
proposed a random number generator that

590
00:22:55,360 --> 00:22:58,159
is designed specifically for uh wi-fi

591
00:22:58,159 --> 00:23:01,200
platforms and our idea is essentially

592
00:23:01,200 --> 00:23:03,520
that well if you want to generate random

593
00:23:03,520 --> 00:23:05,760
numbers on a wi-fi platform you have

594
00:23:05,760 --> 00:23:08,000
access to the antenna of the wi-fi chip

595
00:23:08,000 --> 00:23:10,080
so why not simply use the physical

596
00:23:10,080 --> 00:23:12,880
background noise of the wi-fi channel

597
00:23:12,880 --> 00:23:15,200
and it turns out that commodity chips

598
00:23:15,200 --> 00:23:18,240
can generate a very large amount of

599
00:23:18,240 --> 00:23:20,080
single strand

600
00:23:20,080 --> 00:23:22,880
measurements per second and this is done

601
00:23:22,880 --> 00:23:25,919
using a so-called spectral scan feature

602
00:23:25,919 --> 00:23:27,840
you should see an illustration of this

603
00:23:27,840 --> 00:23:29,039
feature here

604
00:23:29,039 --> 00:23:31,200
essentially you can generate a huge

605
00:23:31,200 --> 00:23:34,480
amount of measurements per second

606
00:23:34,480 --> 00:23:36,880
and we process all these measurements in

607
00:23:36,880 --> 00:23:39,520
the firmware of the wi-fi chip by just

608
00:23:39,520 --> 00:23:41,840
storing these samples together so let's

609
00:23:41,840 --> 00:23:44,720
say we can store a thousand measurements

610
00:23:44,720 --> 00:23:46,720
together in the firmware this can be

611
00:23:46,720 --> 00:23:48,559
done very fast and

612
00:23:48,559 --> 00:23:50,640
normally also doesn't require that much

613
00:23:50,640 --> 00:23:51,600
energy

614
00:23:51,600 --> 00:23:53,679
the result of these

615
00:23:53,679 --> 00:23:56,480
of uh this court sample is then passed

616
00:23:56,480 --> 00:23:59,039
on to the operating system which can use

617
00:23:59,039 --> 00:24:01,760
an existing and proper method

618
00:24:01,760 --> 00:24:06,000
to manage this entropy on randomness

619
00:24:06,000 --> 00:24:08,720
so we proposed this method however there

620
00:24:08,720 --> 00:24:10,480
are still some future work to be

621
00:24:10,480 --> 00:24:12,400
performed here for example we did not

622
00:24:12,400 --> 00:24:14,240
yet investigate how well this random

623
00:24:14,240 --> 00:24:16,559
number generator would perform if there

624
00:24:16,559 --> 00:24:19,440
is for example a jammer present

625
00:24:19,440 --> 00:24:21,039
so that is still something to be

626
00:24:21,039 --> 00:24:22,720
investigated

627
00:24:22,720 --> 00:24:23,840
so

628
00:24:23,840 --> 00:24:26,559
that leads me to the conclusion of our

629
00:24:26,559 --> 00:24:27,440
work

630
00:24:27,440 --> 00:24:28,480
so

631
00:24:28,480 --> 00:24:30,240
basically i'm going to discuss four

632
00:24:30,240 --> 00:24:32,640
lessons that we learned the first two

633
00:24:32,640 --> 00:24:35,600
are rather practical that's that you

634
00:24:35,600 --> 00:24:37,360
should use a proper random number

635
00:24:37,360 --> 00:24:38,720
generator

636
00:24:38,720 --> 00:24:40,720
on the second one is the counter measure

637
00:24:40,720 --> 00:24:43,279
that an access point should ignore group

638
00:24:43,279 --> 00:24:45,440
addressed wi-fi frames

639
00:24:45,440 --> 00:24:47,840
the other the next two lessons are a bit

640
00:24:47,840 --> 00:24:50,240
more broad the first one is that you

641
00:24:50,240 --> 00:24:52,799
shouldn't put an example algorithm

642
00:24:52,799 --> 00:24:55,120
especially on example security algorithm

643
00:24:55,120 --> 00:24:57,360
in an official specification

644
00:24:57,360 --> 00:24:58,960
if you include an algorithm in a

645
00:24:58,960 --> 00:25:01,440
specification it should either be decent

646
00:25:01,440 --> 00:25:03,279
or it should not be in there don't

647
00:25:03,279 --> 00:25:05,200
include something that's in between or

648
00:25:05,200 --> 00:25:06,799
where you say that you should be

649
00:25:06,799 --> 00:25:08,320
extending this because people will

650
00:25:08,320 --> 00:25:10,080
simply implement it like it's

651
00:25:10,080 --> 00:25:12,559
implemented in the specification

652
00:25:12,559 --> 00:25:14,159
the second observation is that you

653
00:25:14,159 --> 00:25:16,320
shouldn't transmit sensitive data for

654
00:25:16,320 --> 00:25:18,159
example the group key before your

655
00:25:18,159 --> 00:25:19,840
handshake or protocol is trying to

656
00:25:19,840 --> 00:25:22,799
detect a downgrade text against this

657
00:25:22,799 --> 00:25:24,080
protocol

658
00:25:24,080 --> 00:25:25,279
so that

659
00:25:25,279 --> 00:25:27,120
concludes my talk if there are any

660
00:25:27,120 --> 00:25:29,870
questions feel free to ask

661
00:25:29,870 --> 00:25:38,400
[Applause]

662
00:25:38,400 --> 00:25:39,440
okay so

663
00:25:39,440 --> 00:25:40,640
one question

664
00:25:40,640 --> 00:25:42,159
so did you also collaborate with

665
00:25:42,159 --> 00:25:45,200
mediatek and the vendors to imp and to

666
00:25:45,200 --> 00:25:46,559
actually implement those counter

667
00:25:46,559 --> 00:25:48,400
measures you proposed

668
00:25:48,400 --> 00:25:49,279
um

669
00:25:49,279 --> 00:25:50,400
not yet

670
00:25:50,400 --> 00:25:53,520
i am planning to report this bad random

671
00:25:53,520 --> 00:25:56,000
number generator to them so they should

672
00:25:56,000 --> 00:25:57,200
instead

673
00:25:57,200 --> 00:25:59,360
simply use a random number generator of

674
00:25:59,360 --> 00:26:01,760
linux and then they should be fine

675
00:26:01,760 --> 00:26:03,360
so we still have to report these

676
00:26:03,360 --> 00:26:05,039
vulnerabilities

677
00:26:05,039 --> 00:26:07,120
please do

678
00:26:07,120 --> 00:26:09,760
so warren kumari google

679
00:26:09,760 --> 00:26:12,000
there's some work in the ietf now on

680
00:26:12,000 --> 00:26:14,400
opportunistic wireless encryption which

681
00:26:14,400 --> 00:26:17,679
uses diffie-hellman to derive the pmk so

682
00:26:17,679 --> 00:26:19,600
between the ap and the client there's

683
00:26:19,600 --> 00:26:21,360
diffie-hellman and it generates the pmk

684
00:26:21,360 --> 00:26:22,559
from that

685
00:26:22,559 --> 00:26:24,159
and i think that it changes the four-way

686
00:26:24,159 --> 00:26:25,840
handshake enough that this doesn't work

687
00:26:25,840 --> 00:26:26,960
anymore

688
00:26:26,960 --> 00:26:29,200
um have you looked at that at all do you

689
00:26:29,200 --> 00:26:31,760
know if it does actually mitigate this

690
00:26:31,760 --> 00:26:33,840
so i haven't looked at that in detail

691
00:26:33,840 --> 00:26:36,320
but i would guess that uh this

692
00:26:36,320 --> 00:26:38,320
opportunistic encryption would be used

693
00:26:38,320 --> 00:26:40,960
to negotiate session keys so pairwise

694
00:26:40,960 --> 00:26:43,279
keys between clients on access points

695
00:26:43,279 --> 00:26:45,520
however the group key might still just

696
00:26:45,520 --> 00:26:47,440
be generated by the access point so you

697
00:26:47,440 --> 00:26:49,600
can still be using a bad random number

698
00:26:49,600 --> 00:26:51,039
generator there

699
00:26:51,039 --> 00:26:54,000
because the pairwise keys between access

700
00:26:54,000 --> 00:26:55,840
point and client are generated using the

701
00:26:55,840 --> 00:26:57,440
method you set but the group key is

702
00:26:57,440 --> 00:27:00,880
simply generated by the access point

703
00:27:02,799 --> 00:27:06,210
okay let's thank the speaker

704
00:27:06,210 --> 00:27:12,430
[Applause]

