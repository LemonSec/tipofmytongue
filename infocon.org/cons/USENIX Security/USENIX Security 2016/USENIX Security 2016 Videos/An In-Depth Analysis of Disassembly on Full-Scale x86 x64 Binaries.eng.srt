1
00:00:10,160 --> 00:00:11,599
okay so that seems to be working so

2
00:00:11,599 --> 00:00:13,440
thank you for the introduction

3
00:00:13,440 --> 00:00:15,280
i'm dennis andrissa from frey university

4
00:00:15,280 --> 00:00:16,880
amsterdam

5
00:00:16,880 --> 00:00:19,199
and yeah as i mentioned this is kind of

6
00:00:19,199 --> 00:00:21,279
a switch of topic this is a measurement

7
00:00:21,279 --> 00:00:22,880
study on how well disassembly actually

8
00:00:22,880 --> 00:00:25,680
works in practice

9
00:00:26,400 --> 00:00:27,920
so first of all of course why did we

10
00:00:27,920 --> 00:00:29,679
want to measure this

11
00:00:29,679 --> 00:00:31,679
well because disassembly is the backbone

12
00:00:31,679 --> 00:00:33,200
of a lot of

13
00:00:33,200 --> 00:00:34,880
a lot of security work especially in

14
00:00:34,880 --> 00:00:37,200
system security and especially work that

15
00:00:37,200 --> 00:00:38,640
we do in our group

16
00:00:38,640 --> 00:00:40,640
it's relevant to a variety of topics but

17
00:00:40,640 --> 00:00:41,680
basically

18
00:00:41,680 --> 00:00:44,559
anytime you want to add security onto

19
00:00:44,559 --> 00:00:45,920
a binary for which you don't have to

20
00:00:45,920 --> 00:00:47,520
source so for instance it could be a

21
00:00:47,520 --> 00:00:49,600
legacy binary

22
00:00:49,600 --> 00:00:51,760
or it could be a proprietary binary or

23
00:00:51,760 --> 00:00:52,960
just a binary that somebody else

24
00:00:52,960 --> 00:00:54,399
compiled with a tool chain that you

25
00:00:54,399 --> 00:00:56,160
don't have access to

26
00:00:56,160 --> 00:00:58,559
or if you want to do analysis of

27
00:00:58,559 --> 00:01:00,559
malware for instance anytime you have

28
00:01:00,559 --> 00:01:02,320
scenarios like this disassembly is a

29
00:01:02,320 --> 00:01:04,720
very basic prerequisite for that

30
00:01:04,720 --> 00:01:06,240
so some of the stuff that we've done

31
00:01:06,240 --> 00:01:08,159
ourselves is for instance binary based

32
00:01:08,159 --> 00:01:11,439
control flow integrity systems

33
00:01:11,439 --> 00:01:13,439
but also you might want to do uh search

34
00:01:13,439 --> 00:01:14,880
for vulnerabilities in binaries

35
00:01:14,880 --> 00:01:16,799
sometimes the binary level is the most

36
00:01:16,799 --> 00:01:18,479
natural level to search for some kinds

37
00:01:18,479 --> 00:01:20,560
of vulnerabilities uh reoptimization

38
00:01:20,560 --> 00:01:22,640
malware analysis any kind of binary

39
00:01:22,640 --> 00:01:24,400
hardening or instrumentation these are

40
00:01:24,400 --> 00:01:26,159
all examples where disassembly is very

41
00:01:26,159 --> 00:01:28,560
important

42
00:01:28,880 --> 00:01:30,640
unfortunately it's an undecidable

43
00:01:30,640 --> 00:01:32,000
problem

44
00:01:32,000 --> 00:01:33,759
and there are lots of potential

45
00:01:33,759 --> 00:01:36,240
challenges that disassemblers can face

46
00:01:36,240 --> 00:01:38,320
and that can mess up the disassembly

47
00:01:38,320 --> 00:01:39,280
results

48
00:01:39,280 --> 00:01:41,360
so just to mention a few examples there

49
00:01:41,360 --> 00:01:43,360
could be data interspersed with the code

50
00:01:43,360 --> 00:01:45,680
so you might have a code section but it

51
00:01:45,680 --> 00:01:47,280
might not be purely code there might be

52
00:01:47,280 --> 00:01:49,520
data in there and if you just happily

53
00:01:49,520 --> 00:01:51,200
disassemble that entire code section

54
00:01:51,200 --> 00:01:53,119
expecting code then you're also going to

55
00:01:53,119 --> 00:01:55,119
disassemble data as code which is going

56
00:01:55,119 --> 00:01:57,920
to give you wrong results of course

57
00:01:57,920 --> 00:01:59,840
there might also be overlapping basic

58
00:01:59,840 --> 00:02:01,920
blocks or overlapping instructions even

59
00:02:01,920 --> 00:02:03,600
on variable length instruction sets such

60
00:02:03,600 --> 00:02:06,640
as x86 or x64 so you might have one

61
00:02:06,640 --> 00:02:08,479
instruction and then as a subset of the

62
00:02:08,479 --> 00:02:10,479
bytes of that instruction

63
00:02:10,479 --> 00:02:11,680
you can actually encode another

64
00:02:11,680 --> 00:02:13,520
instruction in that and both might be

65
00:02:13,520 --> 00:02:15,760
used simultaneously

66
00:02:15,760 --> 00:02:17,440
also yeah what you see very often

67
00:02:17,440 --> 00:02:19,200
indirect jumps and calls which are of

68
00:02:19,200 --> 00:02:20,879
course very hard to resolve statically

69
00:02:20,879 --> 00:02:22,720
as well all kinds of alignment bite

70
00:02:22,720 --> 00:02:24,400
that's not meant to be interpreted as an

71
00:02:24,400 --> 00:02:25,760
instruction

72
00:02:25,760 --> 00:02:27,360
function level optimizations and so on

73
00:02:27,360 --> 00:02:28,640
so there are lots of potential

74
00:02:28,640 --> 00:02:31,360
challenges but the question is

75
00:02:31,360 --> 00:02:32,480
how much of a problem do these

76
00:02:32,480 --> 00:02:34,959
challenges cause in practice

77
00:02:34,959 --> 00:02:36,640
and that's the motivation of our work so

78
00:02:36,640 --> 00:02:38,160
as i've mentioned we do a lot of binary

79
00:02:38,160 --> 00:02:39,360
based work

80
00:02:39,360 --> 00:02:40,959
and we've noticed that there's not

81
00:02:40,959 --> 00:02:42,720
really a consensus on how common all

82
00:02:42,720 --> 00:02:44,319
these problems are in practice so what

83
00:02:44,319 --> 00:02:46,080
we see a lot is that

84
00:02:46,080 --> 00:02:48,400
we do work on the at the binary level

85
00:02:48,400 --> 00:02:50,239
and then we get questions from reviewers

86
00:02:50,239 --> 00:02:53,040
for instance um how reliable

87
00:02:53,040 --> 00:02:54,720
is this in practice can you guarantee

88
00:02:54,720 --> 00:02:56,160
that there won't be any problems that

89
00:02:56,160 --> 00:02:58,959
this will work reliably

90
00:02:58,959 --> 00:03:00,560
and that's the main motivation of our

91
00:03:00,560 --> 00:03:03,040
work so we wanted to really

92
00:03:03,040 --> 00:03:05,040
in take an in-depth look at how common

93
00:03:05,040 --> 00:03:06,720
these problems are and which problems

94
00:03:06,720 --> 00:03:08,480
you can really expect so that in the

95
00:03:08,480 --> 00:03:10,800
future it will be clearer when reviewing

96
00:03:10,800 --> 00:03:12,560
a paper or when doing new research like

97
00:03:12,560 --> 00:03:14,959
where you can expect the problems

98
00:03:14,959 --> 00:03:17,120
so in that light we study the frequency

99
00:03:17,120 --> 00:03:19,040
of corner cases in real binaries and we

100
00:03:19,040 --> 00:03:20,800
also measure how well disassemblers deal

101
00:03:20,800 --> 00:03:24,560
with these corner cases when they occur

102
00:03:25,360 --> 00:03:26,959
so because we wanted to get a realistic

103
00:03:26,959 --> 00:03:28,319
picture of this

104
00:03:28,319 --> 00:03:29,840
we tried to cover a wide range of

105
00:03:29,840 --> 00:03:32,159
commonly targeted binary types we had

106
00:03:32,159 --> 00:03:35,280
981 test cases

107
00:03:35,280 --> 00:03:37,920
and yeah our test cases consisted

108
00:03:37,920 --> 00:03:40,959
partially of spec cpu 2006 but also of

109
00:03:40,959 --> 00:03:42,720
several real world applications so that

110
00:03:42,720 --> 00:03:44,239
we could sort of cross verify that the

111
00:03:44,239 --> 00:03:45,680
results were in agreement with each

112
00:03:45,680 --> 00:03:46,560
other

113
00:03:46,560 --> 00:03:48,239
so that our test set wasn't biased or

114
00:03:48,239 --> 00:03:50,000
anything

115
00:03:50,000 --> 00:03:52,640
these were cn sleepers plus applications

116
00:03:52,640 --> 00:03:54,159
we compiled them with the three major

117
00:03:54,159 --> 00:03:56,319
compilers so gcc and clang for elf

118
00:03:56,319 --> 00:03:58,640
binaries and visual studio for pe

119
00:03:58,640 --> 00:03:59,680
binaries

120
00:03:59,680 --> 00:04:01,120
we tested with

121
00:04:01,120 --> 00:04:04,319
both x86 and x64 at all the

122
00:04:04,319 --> 00:04:06,400
common optimization levels

123
00:04:06,400 --> 00:04:08,480
including optimizing for size we also

124
00:04:08,480 --> 00:04:10,159
tested with link time optimization and

125
00:04:10,159 --> 00:04:11,599
with both dynamically and statically

126
00:04:11,599 --> 00:04:13,680
linked binaries with and without symbols

127
00:04:13,680 --> 00:04:15,599
and we also tested the

128
00:04:15,599 --> 00:04:17,600
library code because there's typically

129
00:04:17,600 --> 00:04:18,959
handwritten assembly in there which you

130
00:04:18,959 --> 00:04:21,040
might expect to have more weird cases

131
00:04:21,040 --> 00:04:24,160
like manual optimizations and so on

132
00:04:24,160 --> 00:04:27,040
we did focus on benign use cases because

133
00:04:27,040 --> 00:04:29,280
um for opt for obfuscated binaries it's

134
00:04:29,280 --> 00:04:30,560
not really a question whether or not

135
00:04:30,560 --> 00:04:32,160
they can mess up the disassembly results

136
00:04:32,160 --> 00:04:34,960
that's that's a given

137
00:04:35,840 --> 00:04:37,600
so yeah the first prerequisite of course

138
00:04:37,600 --> 00:04:38,880
for this study is that we have to have

139
00:04:38,880 --> 00:04:40,639
very reliable ground truth and that's

140
00:04:40,639 --> 00:04:42,320
actually not quite trivial because the

141
00:04:42,320 --> 00:04:44,000
compilers

142
00:04:44,000 --> 00:04:45,919
don't really emit this by default and

143
00:04:45,919 --> 00:04:47,759
you can also not use a disassembler to

144
00:04:47,759 --> 00:04:49,120
get this ground truth because then you

145
00:04:49,120 --> 00:04:51,360
would be biased for this disassembler

146
00:04:51,360 --> 00:04:52,479
so

147
00:04:52,479 --> 00:04:54,320
that was actually a non-trivial process

148
00:04:54,320 --> 00:04:57,360
and i won't go into details here but

149
00:04:57,360 --> 00:04:59,360
basically we derived this from dwarf and

150
00:04:59,360 --> 00:05:00,960
pdb information

151
00:05:00,960 --> 00:05:02,960
coupled with source level info collected

152
00:05:02,960 --> 00:05:04,880
by an llvm pass but the full details on

153
00:05:04,880 --> 00:05:06,560
how we did that exactly are given in the

154
00:05:06,560 --> 00:05:08,639
paper

155
00:05:08,639 --> 00:05:10,960
we focused on the most commonly used

156
00:05:10,960 --> 00:05:12,560
binary analysis primitives and the most

157
00:05:12,560 --> 00:05:15,280
common complex cases

158
00:05:15,280 --> 00:05:16,479
or at least the complex cases that are

159
00:05:16,479 --> 00:05:18,240
perceived to be most common

160
00:05:18,240 --> 00:05:19,600
the primitives that we looked at are

161
00:05:19,600 --> 00:05:21,120
first of all the raw instructions of

162
00:05:21,120 --> 00:05:22,880
course so just the instructions as

163
00:05:22,880 --> 00:05:24,400
recovered by the disassembler how well

164
00:05:24,400 --> 00:05:26,160
do these match up with

165
00:05:26,160 --> 00:05:27,919
the actual instructions in the binary

166
00:05:27,919 --> 00:05:30,080
that are executed

167
00:05:30,080 --> 00:05:32,000
also function start information how are

168
00:05:32,000 --> 00:05:34,639
disassemblers able to pinpoint which

169
00:05:34,639 --> 00:05:36,240
instructions form the start of a

170
00:05:36,240 --> 00:05:37,600
function

171
00:05:37,600 --> 00:05:40,800
function signatures so that's just um

172
00:05:40,800 --> 00:05:42,639
how many parameters does a function have

173
00:05:42,639 --> 00:05:44,080
and what return type does the function

174
00:05:44,080 --> 00:05:44,880
have

175
00:05:44,880 --> 00:05:46,479
also the accuracy of the control flow

176
00:05:46,479 --> 00:05:48,960
graph and the call graph

177
00:05:48,960 --> 00:05:50,400
so those are the primers we looked at

178
00:05:50,400 --> 00:05:52,080
and then we also looked at complex cases

179
00:05:52,080 --> 00:05:53,680
so just the ones that i mentioned before

180
00:05:53,680 --> 00:05:54,800
overlapping basic blocks and

181
00:05:54,800 --> 00:05:57,039
instructions inline data

182
00:05:57,039 --> 00:05:58,639
switches padding bytes function

183
00:05:58,639 --> 00:06:01,199
optimizations and so on

184
00:06:01,199 --> 00:06:03,199
and we tested the performance with all

185
00:06:03,199 --> 00:06:05,120
of these parameters on nine popular

186
00:06:05,120 --> 00:06:06,880
industry and research disassemblers

187
00:06:06,880 --> 00:06:08,720
again i won't go through the entire list

188
00:06:08,720 --> 00:06:10,639
that's mentioned in the paper uh i'll

189
00:06:10,639 --> 00:06:12,160
just mention the specific disassemblers

190
00:06:12,160 --> 00:06:15,199
where needed in the results

191
00:06:15,520 --> 00:06:17,520
so yeah as you can sort of gather from

192
00:06:17,520 --> 00:06:19,360
this we did a lot of testing so we also

193
00:06:19,360 --> 00:06:21,759
had a lot of data as our results it's

194
00:06:21,759 --> 00:06:23,039
far too much data to fit in this

195
00:06:23,039 --> 00:06:25,039
presentation so i've tried to pick out a

196
00:06:25,039 --> 00:06:26,720
couple of interesting results that i

197
00:06:26,720 --> 00:06:28,479
will show you here but there's a lot

198
00:06:28,479 --> 00:06:30,240
more in the paper and we're also

199
00:06:30,240 --> 00:06:31,840
releasing all our detailed results in

200
00:06:31,840 --> 00:06:33,440
ground truth publicly

201
00:06:33,440 --> 00:06:34,720
and that's even more detailed than

202
00:06:34,720 --> 00:06:36,479
what's given in the paper

203
00:06:36,479 --> 00:06:37,919
that url will be repeated in the

204
00:06:37,919 --> 00:06:40,719
conclusion slide

205
00:06:41,039 --> 00:06:43,120
so we first looked at the accuracy of

206
00:06:43,120 --> 00:06:44,000
just

207
00:06:44,000 --> 00:06:46,400
pure instruction recovery

208
00:06:46,400 --> 00:06:48,400
and yeah the picture there is actually

209
00:06:48,400 --> 00:06:51,039
encouraging so for ida pro which is of

210
00:06:51,039 --> 00:06:52,960
course uh for those that do any reverse

211
00:06:52,960 --> 00:06:54,560
engineering that's one of the best known

212
00:06:54,560 --> 00:06:56,240
disassemblers

213
00:06:56,240 --> 00:06:58,080
ida pro is actually quite good at

214
00:06:58,080 --> 00:06:59,680
recovering the instructions it typically

215
00:06:59,680 --> 00:07:03,199
gets an accuracy between 96 and 99

216
00:07:03,199 --> 00:07:05,120
correct instructions

217
00:07:05,120 --> 00:07:06,479
um

218
00:07:06,479 --> 00:07:08,479
and so yeah that shows you that

219
00:07:08,479 --> 00:07:09,840
depending on the optimization level

220
00:07:09,840 --> 00:07:12,960
there is up to four percent instructions

221
00:07:12,960 --> 00:07:14,639
that may be missed but we found that

222
00:07:14,639 --> 00:07:16,160
those instructions are mostly padding

223
00:07:16,160 --> 00:07:18,400
codes so at high optimization levels you

224
00:07:18,400 --> 00:07:20,400
have lots of padding instructions

225
00:07:20,400 --> 00:07:22,400
between functions to align them for

226
00:07:22,400 --> 00:07:24,720
memory efficiency

227
00:07:24,720 --> 00:07:26,160
and yeah those instructions are not

228
00:07:26,160 --> 00:07:27,840
found by ida because it follows the

229
00:07:27,840 --> 00:07:29,919
control flow and the control flow flows

230
00:07:29,919 --> 00:07:32,080
around these padding instructions

231
00:07:32,080 --> 00:07:34,080
so arguably it's not really a problem if

232
00:07:34,080 --> 00:07:35,520
you miss these instructions because

233
00:07:35,520 --> 00:07:36,880
these are typically not instructions

234
00:07:36,880 --> 00:07:38,160
that you would want to instrument or

235
00:07:38,160 --> 00:07:40,000
anything like that

236
00:07:40,000 --> 00:07:41,919
and false positives fortunately are very

237
00:07:41,919 --> 00:07:43,680
rare we only saw a handful of those in

238
00:07:43,680 --> 00:07:46,319
all our tests

239
00:07:46,560 --> 00:07:47,840
and actually

240
00:07:47,840 --> 00:07:50,000
quite surprising to us finding is that

241
00:07:50,000 --> 00:07:52,080
linear disassembly which is often seen

242
00:07:52,080 --> 00:07:53,680
as sort of inferior to recursive

243
00:07:53,680 --> 00:07:56,800
disassembly actually got 100 correctness

244
00:07:56,800 --> 00:07:58,879
on elf with no false positives or false

245
00:07:58,879 --> 00:08:00,879
negatives and this turns out to be

246
00:08:00,879 --> 00:08:02,720
because there's actually no inline data

247
00:08:02,720 --> 00:08:04,639
in modern elf binaries so the compilers

248
00:08:04,639 --> 00:08:06,639
for elf binaries nowadays

249
00:08:06,639 --> 00:08:08,639
take a lot of care to separate

250
00:08:08,639 --> 00:08:10,319
data from code

251
00:08:10,319 --> 00:08:11,440
and that actually means that linear

252
00:08:11,440 --> 00:08:13,039
disassembly there is the most reliable

253
00:08:13,039 --> 00:08:14,400
choice

254
00:08:14,400 --> 00:08:16,479
uh for pe binaries it also did pretty

255
00:08:16,479 --> 00:08:18,400
well in terms of true positives getting

256
00:08:18,400 --> 00:08:20,720
99 true positives but there were some

257
00:08:20,720 --> 00:08:22,080
false positives and false negatives

258
00:08:22,080 --> 00:08:23,919
there and that's because visual studio

259
00:08:23,919 --> 00:08:25,680
the the compiler which we used for our

260
00:08:25,680 --> 00:08:28,240
pe tests does insert some inline data

261
00:08:28,240 --> 00:08:30,960
and those are mainly jump tables there

262
00:08:30,960 --> 00:08:32,640
so yeah it's a little more detailed

263
00:08:32,640 --> 00:08:34,240
results are given in the graphs below so

264
00:08:34,240 --> 00:08:35,440
those are not too important for your

265
00:08:35,440 --> 00:08:36,880
understanding it's just for illustration

266
00:08:36,880 --> 00:08:39,440
but it shows for each compiler and

267
00:08:39,440 --> 00:08:40,719
architecture

268
00:08:40,719 --> 00:08:42,240
how the accuracy varies over

269
00:08:42,240 --> 00:08:45,120
optimization level

270
00:08:45,920 --> 00:08:47,600
i won't go into details on the cfg and

271
00:08:47,600 --> 00:08:49,920
call graph accuracy here because as the

272
00:08:49,920 --> 00:08:51,760
instruction recovery rate is quite

273
00:08:51,760 --> 00:08:52,800
accurate

274
00:08:52,800 --> 00:08:54,560
so is the cfg in call graph accuracy

275
00:08:54,560 --> 00:08:56,560
because those are based on that

276
00:08:56,560 --> 00:08:58,720
but again yeah paper paper has more

277
00:08:58,720 --> 00:09:01,360
details than that

278
00:09:01,680 --> 00:09:04,000
one thing that is kind of interesting is

279
00:09:04,000 --> 00:09:06,240
function signatures of course

280
00:09:06,240 --> 00:09:08,160
those are only offered by ida pro and

281
00:09:08,160 --> 00:09:09,600
they're mostly important for manual

282
00:09:09,600 --> 00:09:10,880
reverse engineering so if you're doing

283
00:09:10,880 --> 00:09:12,560
malware analysis for instance you're

284
00:09:12,560 --> 00:09:13,920
you're analyzing a particular function

285
00:09:13,920 --> 00:09:15,200
it really helps to know how many

286
00:09:15,200 --> 00:09:16,800
parameters does this function have it

287
00:09:16,800 --> 00:09:18,160
helps in your understanding of this

288
00:09:18,160 --> 00:09:19,440
function

289
00:09:19,440 --> 00:09:21,200
unfortunately we found that the accuracy

290
00:09:21,200 --> 00:09:24,720
there is pretty poor especially on x64

291
00:09:24,720 --> 00:09:28,000
so the graph here shows actually only um

292
00:09:28,000 --> 00:09:30,399
in how many instances ida pro correctly

293
00:09:30,399 --> 00:09:31,279
found

294
00:09:31,279 --> 00:09:33,040
the number of arguments so not not the

295
00:09:33,040 --> 00:09:34,720
type but just the number of arguments

296
00:09:34,720 --> 00:09:37,040
and then only for the non-empty argument

297
00:09:37,040 --> 00:09:37,920
lists

298
00:09:37,920 --> 00:09:39,360
we only looked at the non-empty list

299
00:09:39,360 --> 00:09:41,279
because ida defaults to a guess of an

300
00:09:41,279 --> 00:09:42,720
empty list so that would buy us our

301
00:09:42,720 --> 00:09:44,320
results if we if we counted that as

302
00:09:44,320 --> 00:09:46,160
correct

303
00:09:46,160 --> 00:09:50,000
you see that on x86 it's sometimes uh

304
00:09:50,000 --> 00:09:52,720
decent so up to about 80 percent uh

305
00:09:52,720 --> 00:09:54,399
correctness

306
00:09:54,399 --> 00:09:56,480
but on x64 it's really only a couple of

307
00:09:56,480 --> 00:09:58,240
percent that that is guessed correctly

308
00:09:58,240 --> 00:09:59,120
so

309
00:09:59,120 --> 00:10:00,880
this is not something that you want to

310
00:10:00,880 --> 00:10:02,800
rely on in your automated analysis but

311
00:10:02,800 --> 00:10:05,040
it might be helpful for manual analysis

312
00:10:05,040 --> 00:10:08,719
if you if you don't count on it too much

313
00:10:09,519 --> 00:10:11,600
but what we found to be the main problem

314
00:10:11,600 --> 00:10:13,760
in this assembly currently actually is

315
00:10:13,760 --> 00:10:15,279
function detection

316
00:10:15,279 --> 00:10:17,360
and this is because there are lots and

317
00:10:17,360 --> 00:10:18,560
lots of

318
00:10:18,560 --> 00:10:20,720
function optimization so

319
00:10:20,720 --> 00:10:22,320
all the prologues that you might scan

320
00:10:22,320 --> 00:10:23,519
for could be removed at high

321
00:10:23,519 --> 00:10:25,680
optimization levels there might be tail

322
00:10:25,680 --> 00:10:27,279
calls where there's a transfer between

323
00:10:27,279 --> 00:10:29,120
two functions that uses not a call but

324
00:10:29,120 --> 00:10:30,959
just a normal jump instruction so it

325
00:10:30,959 --> 00:10:32,399
might look as if those functions

326
00:10:32,399 --> 00:10:34,160
actually form one hole

327
00:10:34,160 --> 00:10:36,000
even though they don't functions might

328
00:10:36,000 --> 00:10:38,720
be inline and so on and so on

329
00:10:38,720 --> 00:10:40,079
and that leads to lots of false

330
00:10:40,079 --> 00:10:41,760
positives and false negatives so even

331
00:10:41,760 --> 00:10:44,240
doing just function start detection

332
00:10:44,240 --> 00:10:46,000
so that's just trying to find the first

333
00:10:46,000 --> 00:10:48,560
address of a function um the false

334
00:10:48,560 --> 00:10:50,079
positive and false negative rates are

335
00:10:50,079 --> 00:10:52,560
both uh 20 or more even for the best

336
00:10:52,560 --> 00:10:53,839
performing disassemblers in the worst

337
00:10:53,839 --> 00:10:55,120
case

338
00:10:55,120 --> 00:10:57,680
so that's really um

339
00:10:57,680 --> 00:10:59,279
yeah that's really the most unreliable

340
00:10:59,279 --> 00:11:00,399
primitive that we found and that's

341
00:11:00,399 --> 00:11:02,399
unfortunate because a lot of binary

342
00:11:02,399 --> 00:11:03,839
analysis actually requires function

343
00:11:03,839 --> 00:11:05,120
information if you're doing binary

344
00:11:05,120 --> 00:11:07,200
instrumentation for instance

345
00:11:07,200 --> 00:11:09,600
function granularity is very typical

346
00:11:09,600 --> 00:11:12,000
granularity to do that at and also all

347
00:11:12,000 --> 00:11:14,079
other kinds of analyses typically

348
00:11:14,079 --> 00:11:16,240
operate at the function granularity so

349
00:11:16,240 --> 00:11:19,120
that's unfortunate

350
00:11:19,360 --> 00:11:21,040
to go into a little bit more detail here

351
00:11:21,040 --> 00:11:22,720
this is an example of a function that

352
00:11:22,720 --> 00:11:25,360
was missed by ida pro

353
00:11:25,360 --> 00:11:27,519
it was the binary that idopro was run on

354
00:11:27,519 --> 00:11:32,079
was gcc compiled with gcc at o3 for elf

355
00:11:32,079 --> 00:11:34,079
and yet this is just

356
00:11:34,079 --> 00:11:36,320
a small function and as you can see

357
00:11:36,320 --> 00:11:38,240
there's not really a recognizable

358
00:11:38,240 --> 00:11:39,839
prologue that either could scan for and

359
00:11:39,839 --> 00:11:41,360
in addition this function is called

360
00:11:41,360 --> 00:11:43,600
indirectly so and those are kind of

361
00:11:43,600 --> 00:11:45,519
basically the two two heuristics that

362
00:11:45,519 --> 00:11:47,279
ida has to find to look for functions

363
00:11:47,279 --> 00:11:49,279
like it follows call edges what can't do

364
00:11:49,279 --> 00:11:50,480
that in this case because it's called

365
00:11:50,480 --> 00:11:52,639
indirectly or scans for

366
00:11:52,639 --> 00:11:54,240
well-known prologue signatures and it

367
00:11:54,240 --> 00:11:55,839
also cannot do that in this case so that

368
00:11:55,839 --> 00:11:58,480
one was missed

369
00:11:59,040 --> 00:12:00,800
there can also be false positives this

370
00:12:00,800 --> 00:12:02,480
is an example of a false positive for

371
00:12:02,480 --> 00:12:03,839
dynast

372
00:12:03,839 --> 00:12:06,560
again this is due to where heuristic

373
00:12:06,560 --> 00:12:08,880
dyna scans for epilogues of functions

374
00:12:08,880 --> 00:12:11,200
and it sees a return instruction

375
00:12:11,200 --> 00:12:12,639
followed by some padding and then it

376
00:12:12,639 --> 00:12:14,399
assumes whatever comes after that is a

377
00:12:14,399 --> 00:12:16,079
new instruction in this case it's

378
00:12:16,079 --> 00:12:17,680
actually not true this is a function

379
00:12:17,680 --> 00:12:19,920
with multiple return cases so there's a

380
00:12:19,920 --> 00:12:21,680
switch in this function

381
00:12:21,680 --> 00:12:23,600
with multiple cases that might each have

382
00:12:23,600 --> 00:12:25,680
their own return statement

383
00:12:25,680 --> 00:12:26,800
and because

384
00:12:26,800 --> 00:12:28,800
the switch uses an indirect jump with a

385
00:12:28,800 --> 00:12:31,360
jump table the compiler is also able to

386
00:12:31,360 --> 00:12:33,200
between these case statements to insert

387
00:12:33,200 --> 00:12:35,279
some knobs there so it really looks like

388
00:12:35,279 --> 00:12:36,560
it might be the end of a function but

389
00:12:36,560 --> 00:12:38,639
it's not in this case these are just two

390
00:12:38,639 --> 00:12:40,399
examples there are many more cases that

391
00:12:40,399 --> 00:12:42,160
are mentioned also in the paper but this

392
00:12:42,160 --> 00:12:43,600
is just to give you an idea of what can

393
00:12:43,600 --> 00:12:46,000
go wrong

394
00:12:46,800 --> 00:12:48,320
all right so that's

395
00:12:48,320 --> 00:12:50,560
some of our results for the

396
00:12:50,560 --> 00:12:52,639
performance on basic primitives we also

397
00:12:52,639 --> 00:12:54,240
looked at the prevalence of complex

398
00:12:54,240 --> 00:12:55,920
cases

399
00:12:55,920 --> 00:12:57,279
first of all we looked at the prevalence

400
00:12:57,279 --> 00:13:00,639
of complex cases in application code

401
00:13:00,639 --> 00:13:03,120
and again we got some surprising results

402
00:13:03,120 --> 00:13:05,360
at least to us

403
00:13:05,360 --> 00:13:07,680
in the literature one of the most common

404
00:13:07,680 --> 00:13:09,279
complex cases that is mentioned is of

405
00:13:09,279 --> 00:13:11,680
course inline data so we really expected

406
00:13:11,680 --> 00:13:13,120
that we would see a lot of this but as

407
00:13:13,120 --> 00:13:14,720
i've mentioned before we didn't see this

408
00:13:14,720 --> 00:13:16,880
in alpha at all even jump tables were

409
00:13:16,880 --> 00:13:19,120
just placed neatly in in the dot ro data

410
00:13:19,120 --> 00:13:21,600
section uh we did see some inline data

411
00:13:21,600 --> 00:13:23,760
for pe binaries as i mentioned but those

412
00:13:23,760 --> 00:13:24,880
are mostly jump tables and they're

413
00:13:24,880 --> 00:13:26,560
actually quite well recognized by ida

414
00:13:26,560 --> 00:13:28,480
pro so it parses them correctly and and

415
00:13:28,480 --> 00:13:30,560
it doesn't interpret them as code and

416
00:13:30,560 --> 00:13:32,560
also the other major disassemblers do

417
00:13:32,560 --> 00:13:35,440
quite well there we also didn't find any

418
00:13:35,440 --> 00:13:37,040
overlapping basic blocks which is again

419
00:13:37,040 --> 00:13:38,480
surprising because this is one of the

420
00:13:38,480 --> 00:13:40,399
other complex cases that you hear a lot

421
00:13:40,399 --> 00:13:41,600
about

422
00:13:41,600 --> 00:13:42,480
um

423
00:13:42,480 --> 00:13:44,320
we didn't see them in any of our you

424
00:13:44,320 --> 00:13:46,800
know of our test cases what we did see a

425
00:13:46,800 --> 00:13:48,959
lot is function level optimizations such

426
00:13:48,959 --> 00:13:50,800
as tail calls which explains why the

427
00:13:50,800 --> 00:13:54,399
function detection results are so poor

428
00:13:55,120 --> 00:13:56,959
so we also looked at complex cases in

429
00:13:56,959 --> 00:13:58,560
library code because as i've mentioned

430
00:13:58,560 --> 00:14:00,079
there's handwritten assembly there which

431
00:14:00,079 --> 00:14:02,079
is very optimized and might contain more

432
00:14:02,079 --> 00:14:03,600
weird cases

433
00:14:03,600 --> 00:14:05,519
we looked at what we thought was a very

434
00:14:05,519 --> 00:14:08,399
representative library um it's used a

435
00:14:08,399 --> 00:14:10,720
lot and it's quite complex and that's

436
00:14:10,720 --> 00:14:12,000
glib c

437
00:14:12,000 --> 00:14:14,320
we looked at 2.22 but also at some other

438
00:14:14,320 --> 00:14:16,160
versions

439
00:14:16,160 --> 00:14:18,399
and again we didn't see any inline data

440
00:14:18,399 --> 00:14:20,320
it actually um

441
00:14:20,320 --> 00:14:22,160
that that was very surprising to us but

442
00:14:22,160 --> 00:14:24,000
we actually looked at over all the

443
00:14:24,000 --> 00:14:26,000
handwritten assembly code in glpc and it

444
00:14:26,000 --> 00:14:27,519
looks like the glibc developers actually

445
00:14:27,519 --> 00:14:29,440
take quite a lot of care to explicitly

446
00:14:29,440 --> 00:14:31,680
separate data and code they explicitly

447
00:14:31,680 --> 00:14:33,680
push data into the dot ro data section

448
00:14:33,680 --> 00:14:35,600
whenever they manually define it in the

449
00:14:35,600 --> 00:14:37,920
assembly

450
00:14:37,920 --> 00:14:39,839
there were also no overlapping basic

451
00:14:39,839 --> 00:14:41,600
blocks tail calls were again quite

452
00:14:41,600 --> 00:14:42,959
common

453
00:14:42,959 --> 00:14:45,040
and there were some weird cases that we

454
00:14:45,040 --> 00:14:46,880
didn't see in normal code

455
00:14:46,880 --> 00:14:48,240
and those were some overlapping

456
00:14:48,240 --> 00:14:50,320
instructions and also some multi

457
00:14:50,320 --> 00:14:51,760
multi-entry functions and i'll show you

458
00:14:51,760 --> 00:14:54,320
some examples of those

459
00:14:54,320 --> 00:14:56,240
so this is the typical format that an

460
00:14:56,240 --> 00:14:58,800
overlapping instruction takes in geolocy

461
00:14:58,800 --> 00:15:00,079
um

462
00:15:00,079 --> 00:15:02,399
yeah so it's basically all it is is

463
00:15:02,399 --> 00:15:04,560
there's a comparison and then based on

464
00:15:04,560 --> 00:15:06,639
the outcome of that you either take the

465
00:15:06,639 --> 00:15:09,600
instruction with a log prefix or without

466
00:15:09,600 --> 00:15:11,199
and that's basically the the only kind

467
00:15:11,199 --> 00:15:13,040
of overlapping instruction that we found

468
00:15:13,040 --> 00:15:16,000
even in this handwritten code

469
00:15:16,000 --> 00:15:17,680
so strictly speaking it is an

470
00:15:17,680 --> 00:15:19,920
overlapping instruction but is it really

471
00:15:19,920 --> 00:15:24,719
a problem for analysis well arguably not

472
00:15:25,680 --> 00:15:27,600
multi-rank functions typically take this

473
00:15:27,600 --> 00:15:29,040
format

474
00:15:29,040 --> 00:15:32,000
you have a function with two entry

475
00:15:32,000 --> 00:15:33,920
points and then depending on which entry

476
00:15:33,920 --> 00:15:35,759
point you take you get a thread save

477
00:15:35,759 --> 00:15:38,160
variant or a thread unsafe variant and

478
00:15:38,160 --> 00:15:40,560
the one entry point jumps over the start

479
00:15:40,560 --> 00:15:42,160
of the next entry point into the middle

480
00:15:42,160 --> 00:15:44,480
of the function again

481
00:15:44,480 --> 00:15:45,279
so

482
00:15:45,279 --> 00:15:47,279
this could lead to some false negatives

483
00:15:47,279 --> 00:15:49,279
because of um

484
00:15:49,279 --> 00:15:52,160
or some false positives i mean sorry

485
00:15:52,160 --> 00:15:54,880
because if there might be direct calls

486
00:15:54,880 --> 00:15:56,480
to both of these entry points causing

487
00:15:56,480 --> 00:15:57,920
the december to believe that these are

488
00:15:57,920 --> 00:15:58,959
actually different functions when

489
00:15:58,959 --> 00:16:01,360
they're not so this could lead to some

490
00:16:01,360 --> 00:16:03,759
problems

491
00:16:04,880 --> 00:16:06,399
all right so in addition to these

492
00:16:06,399 --> 00:16:08,160
results we were interested in uh seeing

493
00:16:08,160 --> 00:16:09,440
how well these match up with the

494
00:16:09,440 --> 00:16:11,040
expectations in the literature because

495
00:16:11,040 --> 00:16:13,040
that was of course uh one of our primary

496
00:16:13,040 --> 00:16:16,079
motivations like we wanted to see um

497
00:16:16,079 --> 00:16:17,440
whether or not there was a mismatch

498
00:16:17,440 --> 00:16:18,800
between what what the problems that

499
00:16:18,800 --> 00:16:20,240
people expect in this assembly and the

500
00:16:20,240 --> 00:16:22,240
problems that you actually get so we

501
00:16:22,240 --> 00:16:24,000
looked at all the disassembly-based

502
00:16:24,000 --> 00:16:26,079
security work published between 2013 and

503
00:16:26,079 --> 00:16:29,360
2015 in the top tier security venues so

504
00:16:29,360 --> 00:16:32,959
using exec ccs ness security and privacy

505
00:16:32,959 --> 00:16:36,320
and also in exact and raid

506
00:16:36,320 --> 00:16:38,079
and we found that nearly all of these

507
00:16:38,079 --> 00:16:40,240
papers used instruction

508
00:16:40,240 --> 00:16:42,320
or control flow graph information that's

509
00:16:42,320 --> 00:16:43,680
not so surprising these are the most

510
00:16:43,680 --> 00:16:45,120
basic primitives

511
00:16:45,120 --> 00:16:46,959
but also half of the papers used

512
00:16:46,959 --> 00:16:49,600
function detection and that's

513
00:16:49,600 --> 00:16:51,680
of course yeah kind of unfortunate

514
00:16:51,680 --> 00:16:53,360
because we've seen that this is one of

515
00:16:53,360 --> 00:16:54,959
the most unreliable primitives so it

516
00:16:54,959 --> 00:16:56,959
really means that papers that use this

517
00:16:56,959 --> 00:16:59,040
primitive should take care to account

518
00:16:59,040 --> 00:17:02,719
for potential errors there

519
00:17:02,880 --> 00:17:04,959
linear disassembly is rarely used even

520
00:17:04,959 --> 00:17:06,480
in cases where it's more accurate and

521
00:17:06,480 --> 00:17:08,720
yeah we suspect that this is because of

522
00:17:08,720 --> 00:17:10,240
the reputation of linear disassembly

523
00:17:10,240 --> 00:17:11,599
that it's inferior to recursive

524
00:17:11,599 --> 00:17:13,039
disassembly

525
00:17:13,039 --> 00:17:15,359
uh surprisingly only 30 percent of the

526
00:17:15,359 --> 00:17:16,959
papers that use function detection

527
00:17:16,959 --> 00:17:19,039
actually discuss potential errors even

528
00:17:19,039 --> 00:17:20,559
though function detection

529
00:17:20,559 --> 00:17:22,160
we've seen is the most unreliable

530
00:17:22,160 --> 00:17:24,400
primitive in fact function detection

531
00:17:24,400 --> 00:17:26,480
errors are discussed less often than for

532
00:17:26,480 --> 00:17:28,079
any other primitive

533
00:17:28,079 --> 00:17:29,919
so that really shows you that there's

534
00:17:29,919 --> 00:17:31,600
there's really a mismatch there between

535
00:17:31,600 --> 00:17:32,880
the kind of

536
00:17:32,880 --> 00:17:34,799
errors that are discussed in in papers

537
00:17:34,799 --> 00:17:36,000
and the kind of errors that you actually

538
00:17:36,000 --> 00:17:37,280
get

539
00:17:37,280 --> 00:17:39,440
and it's really too bad because

540
00:17:39,440 --> 00:17:41,039
in 70 of the papers that we looked at

541
00:17:41,039 --> 00:17:42,720
errors are potentially fatal so they can

542
00:17:42,720 --> 00:17:46,080
result in crashes or unusable results

543
00:17:46,080 --> 00:17:48,640
so that's really unfortunate especially

544
00:17:48,640 --> 00:17:50,960
because only 43 of those papers handle

545
00:17:50,960 --> 00:17:53,200
errors in any kind of primitive so even

546
00:17:53,200 --> 00:17:55,120
though crashes can be fatal errors are

547
00:17:55,120 --> 00:17:57,919
rarely handled at all

548
00:17:57,919 --> 00:17:59,919
most papers that do handle errors use

549
00:17:59,919 --> 00:18:01,679
either overestimation so they try to

550
00:18:01,679 --> 00:18:03,840
make the analysis conservative or they

551
00:18:03,840 --> 00:18:08,159
do run time fixes of potential errors

552
00:18:09,600 --> 00:18:10,640
all right so

553
00:18:10,640 --> 00:18:12,880
the conclusion here is that

554
00:18:12,880 --> 00:18:14,640
the expectations of disassembly in the

555
00:18:14,640 --> 00:18:16,320
in the literature are really mismatched

556
00:18:16,320 --> 00:18:18,480
with the actual results that we see we

557
00:18:18,480 --> 00:18:21,039
see a lot of work focusing on very rare

558
00:18:21,039 --> 00:18:22,720
or non-existent corner cases mostly

559
00:18:22,720 --> 00:18:25,120
inline data and overlapping basic blocks

560
00:18:25,120 --> 00:18:27,039
and that leads to a belief that yeah

561
00:18:27,039 --> 00:18:28,880
these cases are really common and it

562
00:18:28,880 --> 00:18:30,320
leads to

563
00:18:30,320 --> 00:18:34,160
an incorrect focus on on problem solving

564
00:18:34,160 --> 00:18:35,280
function detection is currently the

565
00:18:35,280 --> 00:18:36,880
biggest challenge but as we've seen it's

566
00:18:36,880 --> 00:18:38,480
actually problems in that are discussed

567
00:18:38,480 --> 00:18:40,400
less often than for any other primitive

568
00:18:40,400 --> 00:18:42,400
and very few papers actually implement

569
00:18:42,400 --> 00:18:43,919
error handling mechanisms at all even

570
00:18:43,919 --> 00:18:46,240
though errors may be fatal

571
00:18:46,240 --> 00:18:48,320
so our hope is that by providing this

572
00:18:48,320 --> 00:18:50,720
data it will become clear in the future

573
00:18:50,720 --> 00:18:52,160
where to expect problems and where to

574
00:18:52,160 --> 00:18:53,919
focus our attention and we hope that it

575
00:18:53,919 --> 00:18:54,640
will

576
00:18:54,640 --> 00:18:57,200
help future research and future reviews

577
00:18:57,200 --> 00:18:59,280
as i've said we have more results and

578
00:18:59,280 --> 00:19:00,799
details in our paper and we also

579
00:19:00,799 --> 00:19:03,679
publicly release all our raw data at the

580
00:19:03,679 --> 00:19:05,360
url given here

581
00:19:05,360 --> 00:19:06,799
and that's it for my site are there any

582
00:19:06,799 --> 00:19:09,100
questions

583
00:19:09,100 --> 00:19:14,689
[Applause]

584
00:19:17,919 --> 00:19:21,679
so mike if you have any questions

585
00:19:22,880 --> 00:19:25,039
okay well i have one um this is really

586
00:19:25,039 --> 00:19:26,559
really interesting work i mean i think

587
00:19:26,559 --> 00:19:28,000
there are some really nice observations

588
00:19:28,000 --> 00:19:30,000
here um for anyone that's working in the

589
00:19:30,000 --> 00:19:32,080
space um

590
00:19:32,080 --> 00:19:33,679
one question i had was you know lots of

591
00:19:33,679 --> 00:19:35,520
people are interested right now in

592
00:19:35,520 --> 00:19:37,919
analyzing kind of really low level

593
00:19:37,919 --> 00:19:39,440
objects right like operating system

594
00:19:39,440 --> 00:19:41,200
kernels or really low level firmware

595
00:19:41,200 --> 00:19:42,640
images um

596
00:19:42,640 --> 00:19:43,919
and um

597
00:19:43,919 --> 00:19:45,120
maybe you haven't looked at these yet

598
00:19:45,120 --> 00:19:47,120
but are you planning to um because that

599
00:19:47,120 --> 00:19:48,960
would be really interesting to see uh

600
00:19:48,960 --> 00:19:50,480
yeah so that's that's a very good point

601
00:19:50,480 --> 00:19:53,360
actually because um no so sort of the

602
00:19:53,360 --> 00:19:55,039
the most weird code that we've looked at

603
00:19:55,039 --> 00:19:56,400
is library code currently so we haven't

604
00:19:56,400 --> 00:19:57,840
looked at that yet but you might indeed

605
00:19:57,840 --> 00:20:00,080
expect that there are some very strange

606
00:20:00,080 --> 00:20:01,600
optimizations there there might actually

607
00:20:01,600 --> 00:20:04,080
be some inline data going on there yeah

608
00:20:04,080 --> 00:20:05,360
so that's definitely something that

609
00:20:05,360 --> 00:20:06,480
would be interesting to look at in the

610
00:20:06,480 --> 00:20:08,799
future

611
00:20:14,480 --> 00:20:16,000
so i understand you tested things at a

612
00:20:16,000 --> 00:20:17,760
number of optimization levels and so

613
00:20:17,760 --> 00:20:19,520
forth but there's also a number of weird

614
00:20:19,520 --> 00:20:21,360
instructions that compilers don't won't

615
00:20:21,360 --> 00:20:22,880
normally emit

616
00:20:22,880 --> 00:20:25,200
even if they're optimized and so forth

617
00:20:25,200 --> 00:20:27,039
do you have any estimate on what

618
00:20:27,039 --> 00:20:28,799
percentage coverage you achieved over

619
00:20:28,799 --> 00:20:32,640
like x86 or x64 the actual set of all

620
00:20:32,640 --> 00:20:34,880
opt codes and mammonics

621
00:20:34,880 --> 00:20:36,640
uh so i'm not entirely sure if i

622
00:20:36,640 --> 00:20:38,080
understand the question correctly but

623
00:20:38,080 --> 00:20:39,679
basically your question is how prevalent

624
00:20:39,679 --> 00:20:41,520
are these um really uncommon

625
00:20:41,520 --> 00:20:42,320
instructions that might be

626
00:20:42,320 --> 00:20:44,159
misinterpreted by this assembler

627
00:20:44,159 --> 00:20:44,880
more

628
00:20:44,880 --> 00:20:46,880
do you have any estimates like

629
00:20:46,880 --> 00:20:50,159
in gcc emitted binaries we only see say

630
00:20:50,159 --> 00:20:52,480
15 percent of the total possible like

631
00:20:52,480 --> 00:20:55,200
vocabulary of construction could be used

632
00:20:55,200 --> 00:20:55,919
and

633
00:20:55,919 --> 00:20:57,600
what what what kind of rough coverage

634
00:20:57,600 --> 00:21:00,080
did you achieve with these disassemblers

635
00:21:00,080 --> 00:21:01,760
oh so we haven't actually measured that

636
00:21:01,760 --> 00:21:03,679
but just from well i've looked at a lot

637
00:21:03,679 --> 00:21:06,080
of code of course uh in this study and

638
00:21:06,080 --> 00:21:08,159
um yeah what i've seen is typically the

639
00:21:08,159 --> 00:21:09,840
the very common instructions that are

640
00:21:09,840 --> 00:21:11,440
emitted by gci i haven't seen a lot of

641
00:21:11,440 --> 00:21:12,880
weird instructions emitted there so it's

642
00:21:12,880 --> 00:21:14,080
all the really common structures like

643
00:21:14,080 --> 00:21:17,600
add subtract compare leah and so on yeah

644
00:21:17,600 --> 00:21:19,120
it really seems to consist mostly of

645
00:21:19,120 --> 00:21:20,400
those instructions but i don't have any

646
00:21:20,400 --> 00:21:22,240
concrete numbers on that unfortunately

647
00:21:22,240 --> 00:21:24,559
thank you

648
00:21:24,559 --> 00:21:26,320
i just had a quick question about the

649
00:21:26,320 --> 00:21:28,480
you know the problems with the function

650
00:21:28,480 --> 00:21:31,600
identification and what did you uh

651
00:21:31,600 --> 00:21:33,840
count it correctly identified

652
00:21:33,840 --> 00:21:35,440
like did it have to identify the whole

653
00:21:35,440 --> 00:21:37,120
scope of the function or just the start

654
00:21:37,120 --> 00:21:39,200
of the function no that's that's the the

655
00:21:39,200 --> 00:21:41,039
worrying part just the start address of

656
00:21:41,039 --> 00:21:43,280
the function so if you uh if you require

657
00:21:43,280 --> 00:21:45,039
that it correctly identifies all the

658
00:21:45,039 --> 00:21:46,159
basic blocks of the function then the

659
00:21:46,159 --> 00:21:48,640
results are even worse so this 20 false

660
00:21:48,640 --> 00:21:50,080
positives or false negatives is just

661
00:21:50,080 --> 00:21:51,919
identifying the start address

662
00:21:51,919 --> 00:21:54,240
yeah

663
00:21:54,799 --> 00:21:57,200
hey there um i noticed you uh did your

664
00:21:57,200 --> 00:22:00,000
analysis with a gcc 5.1 and visual

665
00:22:00,000 --> 00:22:02,559
studio 15 um did you do did you do any

666
00:22:02,559 --> 00:22:04,320
more analysis with older compilers which

667
00:22:04,320 --> 00:22:06,000
may not follow the same um

668
00:22:06,000 --> 00:22:07,440
yeah so we didn't repeat all our

669
00:22:07,440 --> 00:22:08,799
experiments with the older compilers but

670
00:22:08,799 --> 00:22:11,440
we did did do some uh some experience

671
00:22:11,440 --> 00:22:12,720
with the older compilers just to see

672
00:22:12,720 --> 00:22:14,000
whether or not the results matched up

673
00:22:14,000 --> 00:22:15,360
and the results seemed to match up match

674
00:22:15,360 --> 00:22:16,640
up quite well so

675
00:22:16,640 --> 00:22:18,799
it doesn't look like um

676
00:22:18,799 --> 00:22:21,280
the errors are due to weird stuff that

677
00:22:21,280 --> 00:22:23,679
the new compiler does okay thanks all

678
00:22:23,679 --> 00:22:26,679
right

679
00:22:26,720 --> 00:22:28,640
okay well if there aren't any questions

680
00:22:28,640 --> 00:22:30,640
that concludes this session and let's

681
00:22:30,640 --> 00:22:34,520
thank the speaker one more time

