1
00:00:10,559 --> 00:00:13,360
hello um so as mentioned my name is ben

2
00:00:13,360 --> 00:00:15,200
dowling and i'm a student at the

3
00:00:15,200 --> 00:00:16,800
queensland university of technology

4
00:00:16,800 --> 00:00:20,240
under the supervision of douglas stabilo

5
00:00:20,240 --> 00:00:22,400
who has recently moved to mcmaster

6
00:00:22,400 --> 00:00:24,000
university

7
00:00:24,000 --> 00:00:25,519
this work was

8
00:00:25,519 --> 00:00:28,080
done on securing the authentication of

9
00:00:28,080 --> 00:00:30,400
the network time protocol

10
00:00:30,400 --> 00:00:32,159
and was partly done while i was a

11
00:00:32,159 --> 00:00:34,480
microsoft research intern

12
00:00:34,480 --> 00:00:37,680
under the mentorship of greg zapparucha

13
00:00:37,680 --> 00:00:41,920
who is also one of our co-authors

14
00:00:42,079 --> 00:00:44,239
so as a little bit of an overview for

15
00:00:44,239 --> 00:00:45,920
the talk uh first we'll begin with an

16
00:00:45,920 --> 00:00:47,680
introduction of time synchronization

17
00:00:47,680 --> 00:00:50,640
protocols uh in general and add some

18
00:00:50,640 --> 00:00:52,800
background on the network time protocol

19
00:00:52,800 --> 00:00:53,920
itself

20
00:00:53,920 --> 00:00:56,320
uh we'll introduce our new construction

21
00:00:56,320 --> 00:00:59,039
for securing the authentication of ntp

22
00:00:59,039 --> 00:01:00,559
which we entitle

23
00:01:00,559 --> 00:01:02,399
antp

24
00:01:02,399 --> 00:01:04,720
we describe our novel security framework

25
00:01:04,720 --> 00:01:06,720
for analyzing time synchronization

26
00:01:06,720 --> 00:01:09,600
protocols its goals and we touch on our

27
00:01:09,600 --> 00:01:12,479
security analysis of antp

28
00:01:12,479 --> 00:01:14,400
we finished by talking about our proof

29
00:01:14,400 --> 00:01:16,799
of concept implementation

30
00:01:16,799 --> 00:01:19,520
and the experiments we performed and the

31
00:01:19,520 --> 00:01:21,680
results we saw

32
00:01:21,680 --> 00:01:24,080
so let's get started

33
00:01:24,080 --> 00:01:26,479
so why is it so important to know the

34
00:01:26,479 --> 00:01:27,360
time

35
00:01:27,360 --> 00:01:29,840
so in recent years we've seen men in the

36
00:01:29,840 --> 00:01:31,920
middle attacks on the network time

37
00:01:31,920 --> 00:01:34,159
protocol that allow rollback style

38
00:01:34,159 --> 00:01:36,799
attacks on time synchronization

39
00:01:36,799 --> 00:01:38,000
um

40
00:01:38,000 --> 00:01:39,680
now i feel i'm

41
00:01:39,680 --> 00:01:42,000
assuming we're all familiar with x 509

42
00:01:42,000 --> 00:01:44,320
certificates and we're aware that each

43
00:01:44,320 --> 00:01:47,200
has an associated validity period now if

44
00:01:47,200 --> 00:01:48,880
you consider an adversary that's able to

45
00:01:48,880 --> 00:01:52,479
set your clock back to 1995 if your bank

46
00:01:52,479 --> 00:01:54,560
has leaked its private key in the years

47
00:01:54,560 --> 00:01:57,119
since then or it

48
00:01:57,119 --> 00:01:59,200
the adversary has spent 20 years working

49
00:01:59,200 --> 00:02:01,280
on cracking the key pair

50
00:02:01,280 --> 00:02:03,119
the adversary may be able to man in the

51
00:02:03,119 --> 00:02:05,840
middle tls connections by injecting old

52
00:02:05,840 --> 00:02:07,439
certificates that you still think are

53
00:02:07,439 --> 00:02:08,479
valid

54
00:02:08,479 --> 00:02:10,639
uh kerberos is another example it

55
00:02:10,639 --> 00:02:12,959
requires strict uh five-minute uh

56
00:02:12,959 --> 00:02:15,280
synchronization with the communicating

57
00:02:15,280 --> 00:02:17,599
party and so an adversary if they're

58
00:02:17,599 --> 00:02:20,160
able to shift your time is able to cause

59
00:02:20,160 --> 00:02:21,680
denial of service attacks against

60
00:02:21,680 --> 00:02:23,440
kerberos

61
00:02:23,440 --> 00:02:26,800
similarly uh hsts has valid validity

62
00:02:26,800 --> 00:02:29,760
periods associated uh with the policies

63
00:02:29,760 --> 00:02:32,400
and so an adversary are capable of

64
00:02:32,400 --> 00:02:34,800
shifting your time is able to jeopardize

65
00:02:34,800 --> 00:02:37,680
the security of your connections

66
00:02:37,680 --> 00:02:40,160
we've got there an example of a x59

67
00:02:40,160 --> 00:02:41,360
certificate

68
00:02:41,360 --> 00:02:42,959
from qut

69
00:02:42,959 --> 00:02:45,440
and we can see that it has an associated

70
00:02:45,440 --> 00:02:47,760
validity period that expires

71
00:02:47,760 --> 00:02:51,440
on the 30th of november

72
00:02:51,440 --> 00:02:52,720
so a little

73
00:02:52,720 --> 00:02:54,879
bit of history on the

74
00:02:54,879 --> 00:02:57,280
network time protocol the most popular

75
00:02:57,280 --> 00:02:58,800
time synchronization protocol is the

76
00:02:58,800 --> 00:03:01,519
network time protocol introduced in 85

77
00:03:01,519 --> 00:03:03,519
by david mills

78
00:03:03,519 --> 00:03:06,959
and revised several times as we can see

79
00:03:06,959 --> 00:03:09,200
in its most used mode which is client

80
00:03:09,200 --> 00:03:12,480
server mode the client pings the server

81
00:03:12,480 --> 00:03:13,680
with a

82
00:03:13,680 --> 00:03:16,720
periodically with their current time and

83
00:03:16,720 --> 00:03:18,640
attempts to compute the offset between

84
00:03:18,640 --> 00:03:20,720
the two machines and adjust their time

85
00:03:20,720 --> 00:03:22,319
appropriately

86
00:03:22,319 --> 00:03:25,040
however ntp v3 which we see was

87
00:03:25,040 --> 00:03:27,360
introduced in 92 was the first variant

88
00:03:27,360 --> 00:03:29,920
of ntp that actually started utilizing

89
00:03:29,920 --> 00:03:32,400
authentication and in this case it's

90
00:03:32,400 --> 00:03:35,680
appreciate key authentication

91
00:03:35,680 --> 00:03:38,480
by using an md5 keyed hash

92
00:03:38,480 --> 00:03:40,480
before this point any men in the middle

93
00:03:40,480 --> 00:03:42,799
could easily modify the timestamps

94
00:03:42,799 --> 00:03:44,720
included by the server and force the

95
00:03:44,720 --> 00:03:45,840
client to

96
00:03:45,840 --> 00:03:48,080
incorrectly synchronize the time and

97
00:03:48,080 --> 00:03:50,159
indeed um

98
00:03:50,159 --> 00:03:53,040
the establishment of these appreciate

99
00:03:53,040 --> 00:03:56,640
keys is considered out of band for ntp

100
00:03:56,640 --> 00:03:59,040
so even if you want to try and

101
00:03:59,040 --> 00:04:01,599
get secure authentication of your time

102
00:04:01,599 --> 00:04:04,080
synchronizations from a time server run

103
00:04:04,080 --> 00:04:07,280
by nist you have to set up snail mail or

104
00:04:07,280 --> 00:04:11,120
fax in order to get the pre-shared key

105
00:04:11,120 --> 00:04:12,400
which is real state-of-the-art

106
00:04:12,400 --> 00:04:15,040
cryptography

107
00:04:15,040 --> 00:04:18,798
so in 2010 we see ntp version 4 which

108
00:04:18,798 --> 00:04:22,960
introduces auto key which is a pki-based

109
00:04:22,960 --> 00:04:24,960
authentication mechanism

110
00:04:24,960 --> 00:04:27,680
now subsequent analysis of auriki has

111
00:04:27,680 --> 00:04:30,720
shown it to be dangerously broken

112
00:04:30,720 --> 00:04:32,000
there's

113
00:04:32,000 --> 00:04:34,560
identity

114
00:04:34,560 --> 00:04:36,560
schemes that have been introduced that

115
00:04:36,560 --> 00:04:39,280
can easily be overridden

116
00:04:39,280 --> 00:04:42,320
in addition it has a trusted certificate

117
00:04:42,320 --> 00:04:46,400
self-signed setup that is trivial for

118
00:04:46,400 --> 00:04:48,240
an adversary to force a client to

119
00:04:48,240 --> 00:04:49,520
utilize

120
00:04:49,520 --> 00:04:52,880
so it's not quite that great now in 2013

121
00:04:52,880 --> 00:04:55,919
a uh essentially an evolution of auto

122
00:04:55,919 --> 00:04:58,000
key was introduced which is the network

123
00:04:58,000 --> 00:05:00,240
time security protocol

124
00:05:00,240 --> 00:05:02,720
and it inherits a lot of design features

125
00:05:02,720 --> 00:05:04,479
including pki based

126
00:05:04,479 --> 00:05:06,639
authentication but we'll elaborate a

127
00:05:06,639 --> 00:05:09,360
little bit a little bit more on that in

128
00:05:09,360 --> 00:05:11,280
a little while

129
00:05:11,280 --> 00:05:13,120
but to go into a little bit more detail

130
00:05:13,120 --> 00:05:16,560
into mtp as its mainstream use today

131
00:05:16,560 --> 00:05:17,759
uh

132
00:05:17,759 --> 00:05:18,720
we'll

133
00:05:18,720 --> 00:05:20,720
go through the protocol flow so we'll

134
00:05:20,720 --> 00:05:22,960
notice that the client starts by

135
00:05:22,960 --> 00:05:25,360
accessing its own time and creating an

136
00:05:25,360 --> 00:05:27,919
ntp message with this timestamp and

137
00:05:27,919 --> 00:05:30,720
eventually pinging the server with this

138
00:05:30,720 --> 00:05:32,800
ntp request

139
00:05:32,800 --> 00:05:34,720
immediately upon receiving the request

140
00:05:34,720 --> 00:05:37,039
message the server records the current

141
00:05:37,039 --> 00:05:40,720
time as the t2 timestamp

142
00:05:40,720 --> 00:05:42,960
and then at some future point will

143
00:05:42,960 --> 00:05:45,280
access its clock and generates a new

144
00:05:45,280 --> 00:05:47,120
timestamp t3

145
00:05:47,120 --> 00:05:49,280
the server creates an ntp response

146
00:05:49,280 --> 00:05:50,800
message

147
00:05:50,800 --> 00:05:53,440
which is t1 concatenated t2 concatenate

148
00:05:53,440 --> 00:05:57,120
t3 and sends it without delay

149
00:05:57,120 --> 00:05:59,120
to the client

150
00:05:59,120 --> 00:06:00,960
so the client records the time upon

151
00:06:00,960 --> 00:06:03,120
receiving the response message and uses

152
00:06:03,120 --> 00:06:05,199
the four time stamps to determine the

153
00:06:05,199 --> 00:06:06,400
latency time

154
00:06:06,400 --> 00:06:08,960
approximate the propagation

155
00:06:08,960 --> 00:06:11,199
time and compute the offset between the

156
00:06:11,199 --> 00:06:14,080
two machines as such

157
00:06:14,080 --> 00:06:16,000
so the client determines the total round

158
00:06:16,000 --> 00:06:17,440
trip delay

159
00:06:17,440 --> 00:06:19,280
by taking the difference of the total

160
00:06:19,280 --> 00:06:21,680
round trip that it's seen minus the

161
00:06:21,680 --> 00:06:26,000
server processing time between t3 and t2

162
00:06:26,000 --> 00:06:28,160
the client approximates the propagation

163
00:06:28,160 --> 00:06:30,400
time by halving this value so it

164
00:06:30,400 --> 00:06:32,240
implicitly ensures

165
00:06:32,240 --> 00:06:35,120
symmetric um delay

166
00:06:35,120 --> 00:06:36,720
uh the offset is then computed as the

167
00:06:36,720 --> 00:06:37,759
difference

168
00:06:37,759 --> 00:06:39,120
um

169
00:06:39,120 --> 00:06:42,479
of the server transmit timestamp t3

170
00:06:42,479 --> 00:06:43,520
with the

171
00:06:43,520 --> 00:06:46,160
client receive timestamp t4 with the

172
00:06:46,160 --> 00:06:48,160
addition of the offset and it's fairly

173
00:06:48,160 --> 00:06:49,919
intuitive to see that if the adversary

174
00:06:49,919 --> 00:06:51,599
doesn't have the power to modify the

175
00:06:51,599 --> 00:06:54,000
timestamps in transit then the only way

176
00:06:54,000 --> 00:06:55,840
that they can influence the clock update

177
00:06:55,840 --> 00:06:58,479
function for the client is by delaying

178
00:06:58,479 --> 00:07:00,880
the messages asymmetrically

179
00:07:00,880 --> 00:07:02,400
and we can bound the amount of error

180
00:07:02,400 --> 00:07:05,360
that the adversary can introduce by this

181
00:07:05,360 --> 00:07:08,639
mechanism by the total round trip time

182
00:07:08,639 --> 00:07:12,800
between t1 and t4

183
00:07:14,160 --> 00:07:17,919
we can also see that um

184
00:07:18,880 --> 00:07:20,720
sorry

185
00:07:20,720 --> 00:07:22,160
so it's pretty obvious that the lack of

186
00:07:22,160 --> 00:07:24,160
authentication in timestamps is an

187
00:07:24,160 --> 00:07:26,240
objectively bad thing as it allows the

188
00:07:26,240 --> 00:07:27,919
adversary to inject their own bad

189
00:07:27,919 --> 00:07:30,160
timestamps and force inaccurate time

190
00:07:30,160 --> 00:07:31,919
synchronization

191
00:07:31,919 --> 00:07:33,840
and we note that a man in the middle can

192
00:07:33,840 --> 00:07:35,840
also attempt to delay and advance

193
00:07:35,840 --> 00:07:38,080
packets in order to add and remove

194
00:07:38,080 --> 00:07:40,160
propagation error so what should a

195
00:07:40,160 --> 00:07:43,360
security protocol task with securing ntp

196
00:07:43,360 --> 00:07:45,520
be able to do

197
00:07:45,520 --> 00:07:47,360
so the first few goals are fairly

198
00:07:47,360 --> 00:07:48,879
self-evident we want to be able to

199
00:07:48,879 --> 00:07:51,759
authenticate messages from the server

200
00:07:51,759 --> 00:07:53,599
we want to be able to protect against

201
00:07:53,599 --> 00:07:56,080
modification of the messages in transit

202
00:07:56,080 --> 00:07:58,560
we want to be able to protect in some

203
00:07:58,560 --> 00:08:02,800
way against replay and delay attacks

204
00:08:02,800 --> 00:08:04,639
um but since we're working with time

205
00:08:04,639 --> 00:08:07,039
synchronization services there are a few

206
00:08:07,039 --> 00:08:08,800
additional restrictions on our protocol

207
00:08:08,800 --> 00:08:11,120
to construction first any cryptographic

208
00:08:11,120 --> 00:08:13,840
protection of the server messages

209
00:08:13,840 --> 00:08:17,039
introduces an asymmetric delay and thus

210
00:08:17,039 --> 00:08:19,440
introduces error into the

211
00:08:19,440 --> 00:08:22,080
approximation of the propagation time

212
00:08:22,080 --> 00:08:24,840
which directly affects the offset and

213
00:08:24,840 --> 00:08:26,479
introduces um

214
00:08:26,479 --> 00:08:30,000
error into the clock update function

215
00:08:30,000 --> 00:08:32,399
so we require any protections uh

216
00:08:32,399 --> 00:08:35,440
cryptographically to be uh add as little

217
00:08:35,440 --> 00:08:37,760
computation time as possible or even

218
00:08:37,760 --> 00:08:39,760
attempt to find a way around introducing

219
00:08:39,760 --> 00:08:41,839
delays in this manner

220
00:08:41,839 --> 00:08:44,800
the next two are more practical concerns

221
00:08:44,800 --> 00:08:45,519
so

222
00:08:45,519 --> 00:08:49,519
there are i think about 600 primary

223
00:08:49,519 --> 00:08:51,760
time synchronization servers out there

224
00:08:51,760 --> 00:08:53,120
at the moment so those are servers that

225
00:08:53,120 --> 00:08:55,040
are connected to

226
00:08:55,040 --> 00:08:55,839
a

227
00:08:55,839 --> 00:08:57,600
time keeping device such as an atomic

228
00:08:57,600 --> 00:08:58,560
clock

229
00:08:58,560 --> 00:08:59,680
but there are

230
00:08:59,680 --> 00:09:01,839
millions if not billions of clients out

231
00:09:01,839 --> 00:09:03,760
there who are all attempting to access

232
00:09:03,760 --> 00:09:05,680
and synchronize their times with these

233
00:09:05,680 --> 00:09:06,720
servers

234
00:09:06,720 --> 00:09:08,800
so any kind of

235
00:09:08,800 --> 00:09:11,200
state that is required to be maintained

236
00:09:11,200 --> 00:09:12,720
by the server

237
00:09:12,720 --> 00:09:15,680
immediately makes the construction a lot

238
00:09:15,680 --> 00:09:18,720
less scalable and the same goes for

239
00:09:18,720 --> 00:09:22,000
computational load

240
00:09:22,000 --> 00:09:23,279
but i mean

241
00:09:23,279 --> 00:09:25,519
why do we need another protocol i mean

242
00:09:25,519 --> 00:09:27,680
we already talked about nts network time

243
00:09:27,680 --> 00:09:29,680
security that already exists

244
00:09:29,680 --> 00:09:32,399
um but i mean what else we why can't we

245
00:09:32,399 --> 00:09:34,560
establish like a tls connection in order

246
00:09:34,560 --> 00:09:35,680
to

247
00:09:35,680 --> 00:09:37,360
authenticate and protect the sending of

248
00:09:37,360 --> 00:09:41,519
ntp messages or even use applebomb's tls

249
00:09:41,519 --> 00:09:43,040
date in order to fetch time

250
00:09:43,040 --> 00:09:45,600
synchronization requests

251
00:09:45,600 --> 00:09:48,720
well using tls has its problems it can't

252
00:09:48,720 --> 00:09:51,200
fully support a stateless server between

253
00:09:51,200 --> 00:09:53,360
the initial handshakes and requires a

254
00:09:53,360 --> 00:09:55,120
server to maintain mappings between

255
00:09:55,120 --> 00:09:57,040
clients and sessions

256
00:09:57,040 --> 00:09:59,839
um so again it's making our construction

257
00:09:59,839 --> 00:10:01,839
less scalable

258
00:10:01,839 --> 00:10:03,600
it also adds a symmetric cryptographic

259
00:10:03,600 --> 00:10:05,519
delay both of which we want to do

260
00:10:05,519 --> 00:10:07,040
without

261
00:10:07,040 --> 00:10:09,680
tls date uses timestamps included in the

262
00:10:09,680 --> 00:10:11,680
hello messages of the

263
00:10:11,680 --> 00:10:13,680
tls handshake

264
00:10:13,680 --> 00:10:15,440
which doesn't allow the client to

265
00:10:15,440 --> 00:10:17,519
account for the server processing time

266
00:10:17,519 --> 00:10:20,000
so for instance fetching certificates or

267
00:10:20,000 --> 00:10:22,640
generating diffie-hellman values things

268
00:10:22,640 --> 00:10:25,360
along those lines which is what the t2

269
00:10:25,360 --> 00:10:28,079
and t3 inside the standard ntp protocol

270
00:10:28,079 --> 00:10:30,399
allows us to do

271
00:10:30,399 --> 00:10:32,240
and it also adds cryptographic delay to

272
00:10:32,240 --> 00:10:34,640
the time synchronization data

273
00:10:34,640 --> 00:10:37,600
and in addition once tls 1.3 eventually

274
00:10:37,600 --> 00:10:41,040
comes into fashion um tls 1.3 it's

275
00:10:41,040 --> 00:10:42,880
currently in draft status and it's

276
00:10:42,880 --> 00:10:45,040
considering removing the time stamps

277
00:10:45,040 --> 00:10:47,200
inside these hello messages

278
00:10:47,200 --> 00:10:50,720
but that'll be like 15 years away

279
00:10:50,720 --> 00:10:53,120
um okay what about network security i

280
00:10:53,120 --> 00:10:54,720
mean it was designed to fix the problems

281
00:10:54,720 --> 00:10:56,640
in auto key and it's designed to be an

282
00:10:56,640 --> 00:10:58,160
authentication protocol for time

283
00:10:58,160 --> 00:11:00,320
synchronization protocols so it should

284
00:11:00,320 --> 00:11:03,360
be pretty good and it is pretty good but

285
00:11:03,360 --> 00:11:05,279
there's definitely room for improvement

286
00:11:05,279 --> 00:11:07,279
as we'll see on the next slide uh

287
00:11:07,279 --> 00:11:09,279
inherits a lot of the design decisions

288
00:11:09,279 --> 00:11:10,800
from autokey

289
00:11:10,800 --> 00:11:12,399
which requires

290
00:11:12,399 --> 00:11:14,959
clients to manage and maintain their own

291
00:11:14,959 --> 00:11:17,440
public keys and certificates it doesn't

292
00:11:17,440 --> 00:11:18,880
allow for parties to remove

293
00:11:18,880 --> 00:11:20,720
cryptographic delay and it's

294
00:11:20,720 --> 00:11:23,120
unnecessarily expensive on the server

295
00:11:23,120 --> 00:11:25,200
side in terms of

296
00:11:25,200 --> 00:11:27,760
public key operations and in addition

297
00:11:27,760 --> 00:11:29,839
when we initially analyzed the uh

298
00:11:29,839 --> 00:11:31,360
autokey

299
00:11:31,360 --> 00:11:34,079
the network time security protocol um

300
00:11:34,079 --> 00:11:35,680
when we were first writing this up there

301
00:11:35,680 --> 00:11:38,240
was also um downgrade style attacks on

302
00:11:38,240 --> 00:11:39,839
the negotiation of cryptographic

303
00:11:39,839 --> 00:11:42,240
primitives

304
00:11:42,240 --> 00:11:43,680
so getting a little bit ahead of

305
00:11:43,680 --> 00:11:45,279
ourselves at this point but here is a

306
00:11:45,279 --> 00:11:47,839
comparison to sell our point

307
00:11:47,839 --> 00:11:49,760
so we notice that nts and auto key

308
00:11:49,760 --> 00:11:52,079
require four round trips to establish

309
00:11:52,079 --> 00:11:54,320
time synchronization now each of these

310
00:11:54,320 --> 00:11:57,120
protocols and that includes our own amtp

311
00:11:57,120 --> 00:11:58,639
it has an initial

312
00:11:58,639 --> 00:12:01,519
few rounds so three in the

313
00:12:01,519 --> 00:12:04,160
case of auto key and nts and two in the

314
00:12:04,160 --> 00:12:06,720
case of antp to establish a shared

315
00:12:06,720 --> 00:12:09,440
secret key and then it utilizes that

316
00:12:09,440 --> 00:12:11,920
shared secret key in subsequent time

317
00:12:11,920 --> 00:12:14,399
synchronization phases

318
00:12:14,399 --> 00:12:16,639
we note that nts servers require three

319
00:12:16,639 --> 00:12:18,880
public key operations and two symmetric

320
00:12:18,880 --> 00:12:20,959
key operations in order to establish

321
00:12:20,959 --> 00:12:23,279
this shared secret key and then

322
00:12:23,279 --> 00:12:24,639
additionally two symmetric key

323
00:12:24,639 --> 00:12:28,320
operations during every preceding

324
00:12:28,320 --> 00:12:30,399
time synchronization phase

325
00:12:30,399 --> 00:12:32,000
in comparison to our construction which

326
00:12:32,000 --> 00:12:33,600
will only require a single public key

327
00:12:33,600 --> 00:12:36,000
operation with admittedly

328
00:12:36,000 --> 00:12:38,160
six symmetric key operations in order to

329
00:12:38,160 --> 00:12:40,480
establish that shared secret key

330
00:12:40,480 --> 00:12:43,120
uh and two symmetric key operations

331
00:12:43,120 --> 00:12:45,200
uh in order to establish uh time

332
00:12:45,200 --> 00:12:47,120
synchronization

333
00:12:47,120 --> 00:12:48,320
so

334
00:12:48,320 --> 00:12:51,360
heading into our construction now

335
00:12:51,360 --> 00:12:53,600
it's split up into three separate phases

336
00:12:53,600 --> 00:12:55,440
a negotiation phase where a client and a

337
00:12:55,440 --> 00:12:58,079
server or negotiate cryptographic

338
00:12:58,079 --> 00:13:01,200
primitives and the server is able to

339
00:13:01,200 --> 00:13:03,760
offload service state

340
00:13:03,760 --> 00:13:06,399
a key exchange phase where as the name

341
00:13:06,399 --> 00:13:07,360
suggests

342
00:13:07,360 --> 00:13:08,800
the client in the server is able to

343
00:13:08,800 --> 00:13:11,519
establish a shared symmetric key which

344
00:13:11,519 --> 00:13:13,680
the server again is able to offload onto

345
00:13:13,680 --> 00:13:15,200
the client

346
00:13:15,200 --> 00:13:16,800
and end

347
00:13:16,800 --> 00:13:19,120
time synchronization phases where you

348
00:13:19,120 --> 00:13:21,920
utilize the same shared symmetric key in

349
00:13:21,920 --> 00:13:23,760
order to protect

350
00:13:23,760 --> 00:13:28,240
ntp requests and responses

351
00:13:29,279 --> 00:13:30,480
so

352
00:13:30,480 --> 00:13:33,040
we'll have a look through our protocol

353
00:13:33,040 --> 00:13:34,639
uh so we begin with our negotiation

354
00:13:34,639 --> 00:13:36,639
phase the client generates a nonce and

355
00:13:36,639 --> 00:13:38,160
sends a nonsense list of supported

356
00:13:38,160 --> 00:13:39,839
algorithms to the server which

357
00:13:39,839 --> 00:13:41,920
negotiates the optimal set of

358
00:13:41,920 --> 00:13:44,959
cryptographic primitives

359
00:13:44,959 --> 00:13:48,079
the server then creates a hash of the

360
00:13:48,079 --> 00:13:50,240
message one from the client as well as

361
00:13:50,240 --> 00:13:53,839
its own supported uh set of algorithms

362
00:13:53,839 --> 00:13:56,959
and its own certificate information

363
00:13:56,959 --> 00:13:59,680
it encrypts this data under its long

364
00:13:59,680 --> 00:14:03,279
term secret key s which is a pseudo

365
00:14:03,279 --> 00:14:06,560
session ticket idea used from tls in

366
00:14:06,560 --> 00:14:08,160
order to offload service state

367
00:14:08,160 --> 00:14:10,959
maintenance to the client

368
00:14:10,959 --> 00:14:13,279
so the server sends over m2 which is the

369
00:14:13,279 --> 00:14:16,000
concatenation of its algorithms its

370
00:14:16,000 --> 00:14:18,480
certificate information and

371
00:14:18,480 --> 00:14:22,240
the opaque value that contains this

372
00:14:22,240 --> 00:14:24,639
hash

373
00:14:25,199 --> 00:14:27,360
now we get to the key exchange phase

374
00:14:27,360 --> 00:14:29,040
where the client

375
00:14:29,040 --> 00:14:31,440
first negotiates the optimal set of

376
00:14:31,440 --> 00:14:33,199
cryptographic algorithms it also

377
00:14:33,199 --> 00:14:35,199
generates the same hash value and then

378
00:14:35,199 --> 00:14:37,760
uses the negotiated key encapsulation

379
00:14:37,760 --> 00:14:39,600
mechanism in order to generate a

380
00:14:39,600 --> 00:14:43,040
ciphertext and a pre-master secret

381
00:14:43,040 --> 00:14:45,600
sending across the opaque value that was

382
00:14:45,600 --> 00:14:47,680
sent across in the negotiation phase

383
00:14:47,680 --> 00:14:50,240
along with this cipher text the server

384
00:14:50,240 --> 00:14:52,000
decrypts um

385
00:14:52,000 --> 00:14:54,399
the opaque value

386
00:14:54,399 --> 00:14:55,680
and also

387
00:14:55,680 --> 00:14:58,240
generates the pre-master secret based on

388
00:14:58,240 --> 00:15:02,240
decapulation of the ciphertext

389
00:15:02,240 --> 00:15:04,320
and the server uses the premaster secret

390
00:15:04,320 --> 00:15:06,639
as input to the kdf in order to generate

391
00:15:06,639 --> 00:15:09,440
the session key and then utilizes again

392
00:15:09,440 --> 00:15:12,480
in the session ticket fashion

393
00:15:12,480 --> 00:15:15,360
an encryption uh of an second opaque

394
00:15:15,360 --> 00:15:16,720
value

395
00:15:16,720 --> 00:15:18,639
there's finally the server uses the

396
00:15:18,639 --> 00:15:21,199
session key to generate a mac over the

397
00:15:21,199 --> 00:15:23,519
hash value concatenated with the

398
00:15:23,519 --> 00:15:26,000
client's m3 message and concatenated

399
00:15:26,000 --> 00:15:29,519
with its second opaque value

400
00:15:29,519 --> 00:15:31,519
which the server promptly sends to the

401
00:15:31,519 --> 00:15:33,759
client the client verifies the mac

402
00:15:33,759 --> 00:15:35,839
authenticating both the negotiation

403
00:15:35,839 --> 00:15:39,279
phase and the key exchange phase

404
00:15:39,279 --> 00:15:40,320
so this is the actual time

405
00:15:40,320 --> 00:15:42,639
synchronization phase meant to reuse the

406
00:15:42,639 --> 00:15:45,600
session key in order to authenticate

407
00:15:45,600 --> 00:15:47,680
time synchronization data

408
00:15:47,680 --> 00:15:49,759
the client generates a new nonce and

409
00:15:49,759 --> 00:15:52,880
also performs a standard ntp computation

410
00:15:52,880 --> 00:15:54,880
as we saw before

411
00:15:54,880 --> 00:15:58,639
sends over the ntp message concatenated

412
00:15:58,639 --> 00:16:02,639
with this new nonce and the second

413
00:16:02,639 --> 00:16:05,040
server opaque value

414
00:16:05,040 --> 00:16:06,399
again these

415
00:16:06,399 --> 00:16:09,040
as in standard ntp the server takes note

416
00:16:09,040 --> 00:16:10,720
of the time of receipt of this message

417
00:16:10,720 --> 00:16:13,040
and then decrypts the opaque value in

418
00:16:13,040 --> 00:16:16,800
order to find the shared symmetric key

419
00:16:16,800 --> 00:16:18,320
the server finishes the time

420
00:16:18,320 --> 00:16:22,000
synchronization data necessary for ntp

421
00:16:22,000 --> 00:16:24,320
and computes the mac over the client

422
00:16:24,320 --> 00:16:27,600
message as well as its own ntp response

423
00:16:27,600 --> 00:16:28,800
message

424
00:16:28,800 --> 00:16:30,320
sending that

425
00:16:30,320 --> 00:16:31,759
to the client

426
00:16:31,759 --> 00:16:33,279
and then the client from that point

427
00:16:33,279 --> 00:16:36,480
onwards again time of receipt and then

428
00:16:36,480 --> 00:16:39,120
computes the round trip time verifies

429
00:16:39,120 --> 00:16:40,639
the mac

430
00:16:40,639 --> 00:16:43,360
and synchronizes the data as long as the

431
00:16:43,360 --> 00:16:45,759
round trip time doesn't exceed some

432
00:16:45,759 --> 00:16:48,320
accuracy margin

433
00:16:48,320 --> 00:16:49,279
and

434
00:16:49,279 --> 00:16:52,320
also that the mac verifies correctly

435
00:16:52,320 --> 00:16:55,040
now uh we said before that we wanted the

436
00:16:55,040 --> 00:16:57,360
ability to potentially remove asymmetric

437
00:16:57,360 --> 00:16:59,920
delay caused by cryptographic operations

438
00:16:59,920 --> 00:17:01,600
now in order to do so we allow the

439
00:17:01,600 --> 00:17:06,880
sender to immediately send the ntp

440
00:17:06,880 --> 00:17:09,199
response message m6

441
00:17:09,199 --> 00:17:10,720
before

442
00:17:10,720 --> 00:17:13,439
authenticating it via the mac the client

443
00:17:13,439 --> 00:17:16,079
receiving the m6 message without the

444
00:17:16,079 --> 00:17:19,199
authentication tag takes note of the t4

445
00:17:19,199 --> 00:17:22,079
the time that it receives it so you gain

446
00:17:22,079 --> 00:17:24,799
back that cryptographic delay but then

447
00:17:24,799 --> 00:17:27,679
waits to receive the second message m6

448
00:17:27,679 --> 00:17:31,039
which contains the uh ntp message

449
00:17:31,039 --> 00:17:32,880
concatenated with the tag in order to

450
00:17:32,880 --> 00:17:36,160
verify that this is correct

451
00:17:36,799 --> 00:17:38,720
so now we'll hit upon our security

452
00:17:38,720 --> 00:17:41,919
framework that we use to analyze antp

453
00:17:41,919 --> 00:17:45,200
and we will also have a quick brief look

454
00:17:45,200 --> 00:17:48,559
at the proof

455
00:17:48,960 --> 00:17:49,679
so

456
00:17:49,679 --> 00:17:51,919
we design a novel security model for

457
00:17:51,919 --> 00:17:54,160
time synchronization protocols it's very

458
00:17:54,160 --> 00:17:56,080
similar to br style key exchange

459
00:17:56,080 --> 00:17:58,799
protocols has the same ideas you've got

460
00:17:58,799 --> 00:18:00,640
a game played between an adversary and a

461
00:18:00,640 --> 00:18:03,520
challenger the um

462
00:18:03,520 --> 00:18:06,160
adversary has access to fairly standard

463
00:18:06,160 --> 00:18:09,120
br style queries such as

464
00:18:09,120 --> 00:18:13,039
create send reveal corrupt

465
00:18:13,039 --> 00:18:14,720
but it has several extensions in order

466
00:18:14,720 --> 00:18:16,080
to capture time synchronization

467
00:18:16,080 --> 00:18:17,360
protocols

468
00:18:17,360 --> 00:18:20,000
so sessions in their session state

469
00:18:20,000 --> 00:18:22,480
also have a time counter the adversary

470
00:18:22,480 --> 00:18:24,320
wins if you can force the client to

471
00:18:24,320 --> 00:18:26,880
synchronize time inaccurately outside

472
00:18:26,880 --> 00:18:28,960
the accuracy margin of some server

473
00:18:28,960 --> 00:18:30,799
sessions counter

474
00:18:30,799 --> 00:18:32,880
in addition we give the adversary access

475
00:18:32,880 --> 00:18:35,440
to a tick function which allows it to

476
00:18:35,440 --> 00:18:37,360
increment the time counters of any given

477
00:18:37,360 --> 00:18:39,280
session essentially giving them control

478
00:18:39,280 --> 00:18:41,840
of the computation speed and latency of

479
00:18:41,840 --> 00:18:43,760
a network

480
00:18:43,760 --> 00:18:45,679
however this is a little bit too strong

481
00:18:45,679 --> 00:18:48,160
now one can imagine an adversary that

482
00:18:48,160 --> 00:18:50,880
immediately after this server sends over

483
00:18:50,880 --> 00:18:51,840
its

484
00:18:51,840 --> 00:18:53,840
final ntp message

485
00:18:53,840 --> 00:18:56,320
just ticks over the server until

486
00:18:56,320 --> 00:18:58,400
eventually you get to the end and the

487
00:18:58,400 --> 00:19:00,799
client is well outside the accuracy

488
00:19:00,799 --> 00:19:03,200
margin of the service time counter in

489
00:19:03,200 --> 00:19:05,200
order to prevent this in the proof and

490
00:19:05,200 --> 00:19:07,200
as well as to capture the notion that

491
00:19:07,200 --> 00:19:10,320
clock drift during protocol execution is

492
00:19:10,320 --> 00:19:12,480
fairly negligible we require that the

493
00:19:12,480 --> 00:19:15,039
adversary cannot issue tick

494
00:19:15,039 --> 00:19:17,520
counters asymmetrically when two

495
00:19:17,520 --> 00:19:20,480
sessions have a matching transcript

496
00:19:20,480 --> 00:19:22,880
note that an adversary between

497
00:19:22,880 --> 00:19:25,039
different executions of time

498
00:19:25,039 --> 00:19:28,640
synchronization phases can

499
00:19:28,640 --> 00:19:30,720
cause clock drift as much as they want

500
00:19:30,720 --> 00:19:34,080
that's allowed within our model

501
00:19:34,320 --> 00:19:37,200
so we prove antp secure in both the

502
00:19:37,200 --> 00:19:39,520
initial time synchronization phase and

503
00:19:39,520 --> 00:19:42,160
subsequent time synchronization phases

504
00:19:42,160 --> 00:19:44,480
bound by the

505
00:19:44,480 --> 00:19:46,320
standard assumptions of security of

506
00:19:46,320 --> 00:19:49,360
cryptographic primitives where e here is

507
00:19:49,360 --> 00:19:52,559
represented again as an accuracy margin

508
00:19:52,559 --> 00:19:54,720
which we tend to define as the total

509
00:19:54,720 --> 00:19:57,679
round trip time

510
00:19:59,520 --> 00:20:01,520
so now moving on to

511
00:20:01,520 --> 00:20:04,640
our implementation of antp

512
00:20:04,640 --> 00:20:06,640
and the subsequent experiments that we

513
00:20:06,640 --> 00:20:08,080
uh do with this

514
00:20:08,080 --> 00:20:10,799
so we utilize openmtpd

515
00:20:10,799 --> 00:20:13,440
and we extend it using openssl's

516
00:20:13,440 --> 00:20:16,000
cryptographic libraries we give here the

517
00:20:16,000 --> 00:20:17,120
um

518
00:20:17,120 --> 00:20:19,360
cryptographic primitives that we use to

519
00:20:19,360 --> 00:20:21,360
implement antp

520
00:20:21,360 --> 00:20:23,600
in particular we implement

521
00:20:23,600 --> 00:20:25,280
two different key encapsulation

522
00:20:25,280 --> 00:20:27,520
functionalities rsa

523
00:20:27,520 --> 00:20:30,720
pkcs and static ephemeral elliptic curve

524
00:20:30,720 --> 00:20:32,640
diffie helmet in order to compare

525
00:20:32,640 --> 00:20:35,440
performance

526
00:20:35,440 --> 00:20:37,600
so what kind of experiments did we do

527
00:20:37,600 --> 00:20:40,320
well what we wanted ultimately was to

528
00:20:40,320 --> 00:20:42,400
determine the reduction and throughput

529
00:20:42,400 --> 00:20:45,760
of using antp as opposed to using

530
00:20:45,760 --> 00:20:48,240
straight ntp but we also wanted to

531
00:20:48,240 --> 00:20:50,080
determine what additional latency is

532
00:20:50,080 --> 00:20:52,240
added and thus what kind of additional

533
00:20:52,240 --> 00:20:54,080
error is added due to cryptographic

534
00:20:54,080 --> 00:20:56,720
operations

535
00:20:56,960 --> 00:21:00,159
so we had two main experiments one was a

536
00:21:00,159 --> 00:21:02,720
setup at qut two client machines

537
00:21:02,720 --> 00:21:05,039
connected to a server machine via a

538
00:21:05,039 --> 00:21:07,760
gigabit lan

539
00:21:07,840 --> 00:21:10,799
and we also had two amazon

540
00:21:10,799 --> 00:21:13,679
web service instances set up on the east

541
00:21:13,679 --> 00:21:16,559
coast and west coast in order to see

542
00:21:16,559 --> 00:21:18,960
what kind of latencies would be

543
00:21:18,960 --> 00:21:23,360
observed in a real world deployment

544
00:21:26,080 --> 00:21:28,400
and here are experimental results i

545
00:21:28,400 --> 00:21:30,480
won't go through all the details here um

546
00:21:30,480 --> 00:21:32,960
but the most salient comparison is the

547
00:21:32,960 --> 00:21:34,880
throughput of the time synchronization

548
00:21:34,880 --> 00:21:38,880
phase of antp versus standard ntp

549
00:21:38,880 --> 00:21:41,840
so you can see in the

550
00:21:41,840 --> 00:21:45,440
first column the throughput is measured

551
00:21:45,440 --> 00:21:48,000
in messages per second and we can see

552
00:21:48,000 --> 00:21:51,200
that typically uh amtp could handle on

553
00:21:51,200 --> 00:21:51,919
our

554
00:21:51,919 --> 00:21:54,679
server machines about um

555
00:21:54,679 --> 00:21:59,520
175k messages per second versus ntp

556
00:21:59,520 --> 00:22:02,799
which gives us about 291k messages per

557
00:22:02,799 --> 00:22:04,799
second

558
00:22:04,799 --> 00:22:06,640
which we argue wasn't significant enough

559
00:22:06,640 --> 00:22:10,080
to preclude deployment of amtp

560
00:22:10,080 --> 00:22:11,600
now we mentioned earlier that the time

561
00:22:11,600 --> 00:22:13,120
synchronization phase is meant to be

562
00:22:13,120 --> 00:22:15,679
done many times so the negotiation and

563
00:22:15,679 --> 00:22:17,600
key exchange phase is performed once and

564
00:22:17,600 --> 00:22:20,080
then you do end times time

565
00:22:20,080 --> 00:22:22,240
synchronization phases

566
00:22:22,240 --> 00:22:24,799
so the majority of traffic going to an

567
00:22:24,799 --> 00:22:28,480
amtp server would be

568
00:22:28,480 --> 00:22:31,200
time synchronization messages

569
00:22:31,200 --> 00:22:33,840
so that is the most important comparison

570
00:22:33,840 --> 00:22:35,200
to be made

571
00:22:35,200 --> 00:22:38,240
in addition we see here that the latency

572
00:22:38,240 --> 00:22:39,440
edition

573
00:22:39,440 --> 00:22:40,559
by

574
00:22:40,559 --> 00:22:43,039
authenticating the ntp

575
00:22:43,039 --> 00:22:48,240
messages is about 21 microseconds

576
00:22:48,240 --> 00:22:49,760
so when you

577
00:22:49,760 --> 00:22:50,799
consider

578
00:22:50,799 --> 00:22:52,720
approximation of propagation errors

579
00:22:52,720 --> 00:22:55,520
about half of the total round trip time

580
00:22:55,520 --> 00:22:57,679
you're adding approximately an error of

581
00:22:57,679 --> 00:23:01,039
about 10 microseconds which we argue is

582
00:23:01,039 --> 00:23:04,880
probably accurate for most clients

583
00:23:04,880 --> 00:23:06,960
probably accurate enough for most

584
00:23:06,960 --> 00:23:08,559
clients if you wanted to utilize

585
00:23:08,559 --> 00:23:11,120
something that uh is a little bit better

586
00:23:11,120 --> 00:23:13,440
i think you would try and utilize the

587
00:23:13,440 --> 00:23:16,400
precision time protocol instead

588
00:23:16,400 --> 00:23:19,360
so here are our results for

589
00:23:19,360 --> 00:23:21,919
our experiments on the east coast and

590
00:23:21,919 --> 00:23:23,360
west coast

591
00:23:23,360 --> 00:23:25,520
and we see here that the

592
00:23:25,520 --> 00:23:28,880
latency has now increased from a measure

593
00:23:28,880 --> 00:23:32,080
of microseconds to a measurement of

594
00:23:32,080 --> 00:23:33,679
milliseconds

595
00:23:33,679 --> 00:23:36,240
and in particular what we're seeing is

596
00:23:36,240 --> 00:23:37,039
that

597
00:23:37,039 --> 00:23:39,760
the impact of synchronization on latency

598
00:23:39,760 --> 00:23:41,919
is negligible compared to the latency

599
00:23:41,919 --> 00:23:44,000
course by distance which we further

600
00:23:44,000 --> 00:23:46,880
argue makes antp a suitable

601
00:23:46,880 --> 00:23:51,559
candidate for securing ntp

602
00:23:52,240 --> 00:23:55,360
so in summary we introduce our new

603
00:23:55,360 --> 00:23:57,679
construction antp an authentication

604
00:23:57,679 --> 00:23:59,279
protocol that is built over the top of

605
00:23:59,279 --> 00:24:01,360
the network time protocol

606
00:24:01,360 --> 00:24:04,240
we formalized notions of time

607
00:24:04,240 --> 00:24:06,960
synchronization protocols in a security

608
00:24:06,960 --> 00:24:09,200
framework and we used that security

609
00:24:09,200 --> 00:24:11,760
framework to prove antp

610
00:24:11,760 --> 00:24:13,919
under standard assumptions

611
00:24:13,919 --> 00:24:15,600
we developed a proof of concept

612
00:24:15,600 --> 00:24:18,799
implementation of antp and we further

613
00:24:18,799 --> 00:24:21,039
evaluated latency and slowdown that is

614
00:24:21,039 --> 00:24:24,320
introduced by our construction

615
00:24:24,320 --> 00:24:25,760
so a

616
00:24:25,760 --> 00:24:27,200
little bit of

617
00:24:27,200 --> 00:24:29,679
future work

618
00:24:29,679 --> 00:24:31,679
one of the things that we encountered

619
00:24:31,679 --> 00:24:34,559
upon our analysis was a so-called first

620
00:24:34,559 --> 00:24:37,360
boot problem so it's kind of a chicken

621
00:24:37,360 --> 00:24:38,720
and egg problem right we're trying to

622
00:24:38,720 --> 00:24:41,760
utilize pki which itself relies on a

623
00:24:41,760 --> 00:24:44,320
validity period in order to

624
00:24:44,320 --> 00:24:47,600
correctly find out what the time is

625
00:24:47,600 --> 00:24:50,720
so how do you kind of solve that problem

626
00:24:50,720 --> 00:24:52,480
one of the solutions that we ended up

627
00:24:52,480 --> 00:24:55,600
describing was ocsp with nonces to

628
00:24:55,600 --> 00:24:58,159
ensure freshness of responses but i

629
00:24:58,159 --> 00:25:00,559
think that we can possibly do better and

630
00:25:00,559 --> 00:25:02,960
it's probably worth investigating

631
00:25:02,960 --> 00:25:03,919
um

632
00:25:03,919 --> 00:25:05,039
in addition

633
00:25:05,039 --> 00:25:07,039
i feel like there should be a little bit

634
00:25:07,039 --> 00:25:08,240
of a

635
00:25:08,240 --> 00:25:10,159
caveat on the proof of concept

636
00:25:10,159 --> 00:25:13,440
implementation the pki based stuff

637
00:25:13,440 --> 00:25:17,360
is a little underdeveloped and so um

638
00:25:17,360 --> 00:25:20,159
you can find in our paper the link to

639
00:25:20,159 --> 00:25:22,400
the github which will contain

640
00:25:22,400 --> 00:25:24,960
the code for antp and you can have a

641
00:25:24,960 --> 00:25:28,080
look and have a play yourself

642
00:25:28,080 --> 00:25:31,740
so thank you any questions

643
00:25:31,740 --> 00:25:39,999
[Applause]

644
00:25:42,480 --> 00:25:44,320
hi kenny patterson from royal holloway

645
00:25:44,320 --> 00:25:46,159
can you say anything about the status of

646
00:25:46,159 --> 00:25:48,960
your uh source code for this system that

647
00:25:48,960 --> 00:25:50,480
you're building sorry i couldn't quite

648
00:25:50,480 --> 00:25:51,440
hear that can you say about the

649
00:25:51,440 --> 00:25:53,440
availability of your code all right so

650
00:25:53,440 --> 00:25:55,360
it's not quite available at the moment

651
00:25:55,360 --> 00:25:56,559
it will be

652
00:25:56,559 --> 00:25:58,720
eventually probably in the next week or

653
00:25:58,720 --> 00:26:01,360
so uploaded to github

654
00:26:01,360 --> 00:26:04,159
on my account i don't have the

655
00:26:04,159 --> 00:26:06,960
link up here unfortunately but it's

656
00:26:06,960 --> 00:26:08,840
dowling bj is

657
00:26:08,840 --> 00:26:11,039
the my

658
00:26:11,039 --> 00:26:12,880
account name and you can find the

659
00:26:12,880 --> 00:26:14,960
repository in there okay that's great

660
00:26:14,960 --> 00:26:18,799
and one more comment uh to your ps yes

661
00:26:18,799 --> 00:26:20,480
come talk to me all right sounds good

662
00:26:20,480 --> 00:26:22,720
thank you kenny

663
00:26:22,720 --> 00:26:25,600
okay do we have any other questions

664
00:26:25,600 --> 00:26:27,840
okay then i have one um ntp is a

665
00:26:27,840 --> 00:26:30,159
udp-based protocol yes and so it's

666
00:26:30,159 --> 00:26:33,279
notoriously vulnerable to either dna or

667
00:26:33,279 --> 00:26:34,960
ddos attacks

668
00:26:34,960 --> 00:26:36,960
of some sort so did you do any analysis

669
00:26:36,960 --> 00:26:38,400
to see if your

670
00:26:38,400 --> 00:26:39,279
um

671
00:26:39,279 --> 00:26:41,600
modifications to the protocol

672
00:26:41,600 --> 00:26:44,080
enable either computational or

673
00:26:44,080 --> 00:26:46,720
reflectional amplification ddos attacks

674
00:26:46,720 --> 00:26:50,000
yeah so i mean adding any type of

675
00:26:50,000 --> 00:26:51,760
cryptographic

676
00:26:51,760 --> 00:26:54,960
operations to something like antp is

677
00:26:54,960 --> 00:26:56,400
going to increase the ability of the

678
00:26:56,400 --> 00:26:59,600
adversary to cause ddos attacks and it's

679
00:26:59,600 --> 00:27:01,039
an unfortunate side effect and it's not

680
00:27:01,039 --> 00:27:02,480
something that we

681
00:27:02,480 --> 00:27:05,760
attempt to address within our work

682
00:27:05,760 --> 00:27:07,520
but it is something that is

683
00:27:07,520 --> 00:27:09,360
needs to be considered when uh

684
00:27:09,360 --> 00:27:12,640
considering full-time deployment

685
00:27:12,640 --> 00:27:14,799
okay any other questions all right let's

686
00:27:14,799 --> 00:27:16,240
thank our speaker

687
00:27:16,240 --> 00:27:22,769
[Applause]

688
00:27:24,720 --> 00:27:26,799
you

