1
00:00:10,160 --> 00:00:13,200
so sorry for the delay no let's start so

2
00:00:13,200 --> 00:00:16,320
i'm talking about drama about concretely

3
00:00:16,320 --> 00:00:19,199
about the biggest drama there ever is

4
00:00:19,199 --> 00:00:22,080
uh about the story of romeo and juliet

5
00:00:22,080 --> 00:00:24,000
these are two tenants in a multi-cpu

6
00:00:24,000 --> 00:00:25,519
cloud server and they would like

7
00:00:25,519 --> 00:00:27,439
secretly like to talk to each other

8
00:00:27,439 --> 00:00:29,359
across the cpus but the hypervisors

9
00:00:29,359 --> 00:00:31,439
tries to prevent it by assigning them to

10
00:00:31,439 --> 00:00:33,360
different physical cpus so they don't

11
00:00:33,360 --> 00:00:35,200
share a cache and cache attacks are not

12
00:00:35,200 --> 00:00:37,040
directly possible

13
00:00:37,040 --> 00:00:38,800
this already brings me to the concrete

14
00:00:38,800 --> 00:00:41,440
setting we evaluate in our work we

15
00:00:41,440 --> 00:00:44,640
consider multi-cpu multi-socket systems

16
00:00:44,640 --> 00:00:46,320
on such systems you typically have

17
00:00:46,320 --> 00:00:48,399
multiple tenants which are co-located on

18
00:00:48,399 --> 00:00:51,199
this one system and they are isolated by

19
00:00:51,199 --> 00:00:54,000
using separate vms

20
00:00:54,000 --> 00:00:56,320
these tenants can then run on different

21
00:00:56,320 --> 00:00:59,280
physical cpus either just by coincidence

22
00:00:59,280 --> 00:01:01,199
or they were assigned by the hypervisor

23
00:01:01,199 --> 00:01:04,159
to dedicated cpus so that cash attacks

24
00:01:04,159 --> 00:01:06,880
are not possible anyway we cannot assume

25
00:01:06,880 --> 00:01:09,439
that there is a shared cpu cache

26
00:01:09,439 --> 00:01:11,680
also we assume that there is no shared

27
00:01:11,680 --> 00:01:13,439
memory in the form of for instance

28
00:01:13,439 --> 00:01:15,759
cross-vm memory deduplication this is

29
00:01:15,759 --> 00:01:18,320
often also disabled for security reasons

30
00:01:18,320 --> 00:01:20,640
and for instance we saw yesterday that

31
00:01:20,640 --> 00:01:23,439
disabling that might be a good idea

32
00:01:23,439 --> 00:01:25,439
previously in this scenario we only had

33
00:01:25,439 --> 00:01:27,119
a slow covered channel with a

34
00:01:27,119 --> 00:01:28,479
transmission rate of less than one

35
00:01:28,479 --> 00:01:30,159
kilobits per second

36
00:01:30,159 --> 00:01:32,720
and also no side channel attack

37
00:01:32,720 --> 00:01:34,960
we changed that by presenting our cross

38
00:01:34,960 --> 00:01:36,400
cpu attacks

39
00:01:36,400 --> 00:01:38,960
we exploit dram addressing and hence the

40
00:01:38,960 --> 00:01:42,399
nice abbreviation drama

41
00:01:42,399 --> 00:01:44,799
we present a fast cover channel at first

42
00:01:44,799 --> 00:01:46,399
cover channel that allows transmission

43
00:01:46,399 --> 00:01:48,799
rates of up to 2 megabits per second and

44
00:01:48,799 --> 00:01:50,880
also the first side channel attack in

45
00:01:50,880 --> 00:01:53,119
this cross cpu scenario

46
00:01:53,119 --> 00:01:55,119
we exploit reverse engineered dram

47
00:01:55,119 --> 00:01:56,880
addressing functions

48
00:01:56,880 --> 00:01:58,479
we do that by

49
00:01:58,479 --> 00:02:00,719
having two approaches

50
00:02:00,719 --> 00:02:03,040
and apart from enabling these two

51
00:02:03,040 --> 00:02:05,119
attacks above these

52
00:02:05,119 --> 00:02:07,360
reverse engineered functions also allows

53
00:02:07,360 --> 00:02:09,758
us to improve upon existing attacks

54
00:02:09,758 --> 00:02:13,119
namely the rowhammer attack

55
00:02:13,440 --> 00:02:15,680
before i can talk about the attacks

56
00:02:15,680 --> 00:02:17,599
specifically i'll have to discuss a

57
00:02:17,599 --> 00:02:18,720
little bit

58
00:02:18,720 --> 00:02:21,040
dram and its organization

59
00:02:21,040 --> 00:02:23,520
dram is organized into a hierarchy or

60
00:02:23,520 --> 00:02:25,440
tree if you want to

61
00:02:25,440 --> 00:02:27,520
and modern multi-cpu multi-socket

62
00:02:27,520 --> 00:02:30,319
systems you have that each cpu has a

63
00:02:30,319 --> 00:02:32,400
dedicated memory controller and attached

64
00:02:32,400 --> 00:02:35,440
memory so you have multiple nodes

65
00:02:35,440 --> 00:02:37,440
the memory is still organized into a

66
00:02:37,440 --> 00:02:39,760
single address space and request to the

67
00:02:39,760 --> 00:02:41,840
other cpu's memory is done over dcpu

68
00:02:41,840 --> 00:02:46,640
interconnect for instance intel's qpi

69
00:02:46,879 --> 00:02:49,680
now if we go one level down we have

70
00:02:49,680 --> 00:02:51,519
for each memory controller we can have

71
00:02:51,519 --> 00:02:53,840
multiple channels these are

72
00:02:53,840 --> 00:02:56,560
independent electrical links and for

73
00:02:56,560 --> 00:02:59,680
each channel we can house multiple

74
00:02:59,680 --> 00:03:02,959
memory modules or dimms

75
00:03:02,959 --> 00:03:06,080
now for each team we can have multiple

76
00:03:06,080 --> 00:03:07,440
ranks

77
00:03:07,440 --> 00:03:09,040
usually one or two and this often

78
00:03:09,040 --> 00:03:11,280
corresponds to the front and back side

79
00:03:11,280 --> 00:03:13,120
physically of the module but not

80
00:03:13,120 --> 00:03:15,120
necessarily

81
00:03:15,120 --> 00:03:17,440
and then for each bank can house

82
00:03:17,440 --> 00:03:18,560
multiple

83
00:03:18,560 --> 00:03:20,319
banks

84
00:03:20,319 --> 00:03:22,239
the typical number of banks depends on

85
00:03:22,239 --> 00:03:24,480
the technology you use on ddr3 you

86
00:03:24,480 --> 00:03:26,720
usually have eight banks per rank on

87
00:03:26,720 --> 00:03:30,480
ddr4 you have 16.

88
00:03:30,560 --> 00:03:33,760
now finally at the level of the banks

89
00:03:33,760 --> 00:03:36,159
we have the actual memory arrays which

90
00:03:36,159 --> 00:03:38,720
are organized into rows of columns

91
00:03:38,720 --> 00:03:39,680
but then

92
00:03:39,680 --> 00:03:42,080
each bank also has another component

93
00:03:42,080 --> 00:03:44,480
namely the so-called row buffer

94
00:03:44,480 --> 00:03:46,480
as the name implies this component

95
00:03:46,480 --> 00:03:48,879
buffers one entire row

96
00:03:48,879 --> 00:03:51,599
the typical row size in dram is eight

97
00:03:51,599 --> 00:03:52,959
kilobytes

98
00:03:52,959 --> 00:03:55,920
and if you look at this ropa from a high

99
00:03:55,920 --> 00:03:57,840
level perspective

100
00:03:57,840 --> 00:04:00,400
it has behavior kind of similar to a

101
00:04:00,400 --> 00:04:03,360
cache namely there's always one row that

102
00:04:03,360 --> 00:04:05,280
is currently buffered or active in the

103
00:04:05,280 --> 00:04:06,640
row buffer

104
00:04:06,640 --> 00:04:08,560
and if you have a memory request that

105
00:04:08,560 --> 00:04:10,159
targets this specif

106
00:04:10,159 --> 00:04:12,000
the currently active row

107
00:04:12,000 --> 00:04:14,000
then the request is served directly from

108
00:04:14,000 --> 00:04:16,478
the row buffer and the memory access is

109
00:04:16,478 --> 00:04:20,238
fast we call such an event a row hit

110
00:04:20,238 --> 00:04:22,639
if a different row is open then we first

111
00:04:22,639 --> 00:04:24,960
need to close the other row

112
00:04:24,960 --> 00:04:27,600
that is not targeted open the other row

113
00:04:27,600 --> 00:04:30,720
so this is of course takes time is slow

114
00:04:30,720 --> 00:04:33,680
and we call such an event a row conflict

115
00:04:33,680 --> 00:04:35,919
on this graphic you on this graph you

116
00:04:35,919 --> 00:04:38,479
can see the access times of potential

117
00:04:38,479 --> 00:04:42,240
cash hits row hits and row conflicts and

118
00:04:42,240 --> 00:04:44,240
in the green shaded area you have that

119
00:04:44,240 --> 00:04:46,160
you can see that for row heats we have a

120
00:04:46,160 --> 00:04:49,120
minimum access time of 180 cyclists

121
00:04:49,120 --> 00:04:51,360
whereas for row conflicts we take at

122
00:04:51,360 --> 00:04:54,800
least 228 cyclists so they're definitely

123
00:04:54,800 --> 00:04:56,960
slower

124
00:04:56,960 --> 00:04:59,280
so row buffer behaves like a cache well

125
00:04:59,280 --> 00:05:02,000
then let's exploit it like a cache

126
00:05:02,000 --> 00:05:05,120
well first we need to find out how

127
00:05:05,120 --> 00:05:07,360
many how physically addresses map to

128
00:05:07,360 --> 00:05:09,840
dram channels ranks and banks because

129
00:05:09,840 --> 00:05:11,919
only if two addresses are in the same

130
00:05:11,919 --> 00:05:14,240
bank then they

131
00:05:14,240 --> 00:05:16,560
have also a shared row buffer thus we

132
00:05:16,560 --> 00:05:18,560
need to reverse engineer the dram

133
00:05:18,560 --> 00:05:20,880
addressing

134
00:05:20,880 --> 00:05:22,960
now the mapping to channels ranks and

135
00:05:22,960 --> 00:05:25,840
banks is done using a subset of physical

136
00:05:25,840 --> 00:05:27,280
address bits

137
00:05:27,280 --> 00:05:29,919
these bits are often not used directly

138
00:05:29,919 --> 00:05:32,479
but instead first combined into

139
00:05:32,479 --> 00:05:34,720
some sort of complex addressing

140
00:05:34,720 --> 00:05:35,759
functions

141
00:05:35,759 --> 00:05:38,240
this is done so to distribute the memory

142
00:05:38,240 --> 00:05:40,160
traffic to channels and banks more

143
00:05:40,160 --> 00:05:42,000
evenly and thus to increase the

144
00:05:42,000 --> 00:05:45,039
performance by using the inbuilt channel

145
00:05:45,039 --> 00:05:49,039
and bank parallelism more efficiently

146
00:05:49,120 --> 00:05:51,600
however these addressing functions are

147
00:05:51,600 --> 00:05:52,960
at least in the case of intel

148
00:05:52,960 --> 00:05:55,280
undisclosed thus the need for reverse

149
00:05:55,280 --> 00:05:56,479
engineering

150
00:05:56,479 --> 00:05:58,720
we now give two approaches that achieve

151
00:05:58,720 --> 00:05:59,600
this

152
00:05:59,600 --> 00:06:01,680
both of which use the presumption that

153
00:06:01,680 --> 00:06:02,639
the

154
00:06:02,639 --> 00:06:04,479
addressing functions are linear in other

155
00:06:04,479 --> 00:06:06,479
words they're just xors of physical

156
00:06:06,479 --> 00:06:08,160
address bits

157
00:06:08,160 --> 00:06:10,400
for all our tested systems this was the

158
00:06:10,400 --> 00:06:12,560
case but our analysis can also be

159
00:06:12,560 --> 00:06:16,319
adapted to the non-linear setting

160
00:06:16,319 --> 00:06:18,880
now the first approach we used is a

161
00:06:18,880 --> 00:06:20,880
physical probing of the memory bus this

162
00:06:20,880 --> 00:06:23,120
picture on the right this white strip is

163
00:06:23,120 --> 00:06:24,960
the dram slot so where insert your

164
00:06:24,960 --> 00:06:27,759
memory module and there the pins are

165
00:06:27,759 --> 00:06:29,600
actually exposed

166
00:06:29,600 --> 00:06:31,840
so you can easily contact them

167
00:06:31,840 --> 00:06:34,160
so we performed a probing of all the

168
00:06:34,160 --> 00:06:35,680
control signals which were of interest

169
00:06:35,680 --> 00:06:37,600
for our analysis so mainly the chip

170
00:06:37,600 --> 00:06:41,199
select and dedicated bank address pins

171
00:06:41,199 --> 00:06:42,720
we measured the voltage at the pin with

172
00:06:42,720 --> 00:06:45,120
an oscilloscope and can thus recover the

173
00:06:45,120 --> 00:06:48,000
logic value sent over the bus

174
00:06:48,000 --> 00:06:50,479
to make this measurement easy we pick a

175
00:06:50,479 --> 00:06:52,800
single address and perform repeated

176
00:06:52,800 --> 00:06:55,120
access to the single address until we

177
00:06:55,120 --> 00:06:57,039
have found the logic value

178
00:06:57,039 --> 00:06:58,319
so we

179
00:06:58,319 --> 00:07:00,400
we don't need to perform a full ddr

180
00:07:00,400 --> 00:07:02,479
protocol analysis and we don't need to

181
00:07:02,479 --> 00:07:04,639
locate single memory accesses because

182
00:07:04,639 --> 00:07:06,319
that would be a bit more complex than

183
00:07:06,319 --> 00:07:09,919
just using one probe

184
00:07:10,160 --> 00:07:11,919
after having done this for enough

185
00:07:11,919 --> 00:07:14,319
addresses and all the interesting pins

186
00:07:14,319 --> 00:07:16,720
we feed these the results to a function

187
00:07:16,720 --> 00:07:18,960
reconstruction which is just linear

188
00:07:18,960 --> 00:07:20,560
algebra of a bits

189
00:07:20,560 --> 00:07:24,639
solving a linear system of equations

190
00:07:24,639 --> 00:07:27,039
now the second approach we have is a

191
00:07:27,039 --> 00:07:29,520
fully automated software-based method it

192
00:07:29,520 --> 00:07:32,000
exploits timing differences

193
00:07:32,000 --> 00:07:33,840
coming from the row buffer these are the

194
00:07:33,840 --> 00:07:36,080
same timing differences we have

195
00:07:36,080 --> 00:07:37,120
for

196
00:07:37,120 --> 00:07:39,599
the attack then later on

197
00:07:39,599 --> 00:07:42,319
it proceeds in two phases first in a

198
00:07:42,319 --> 00:07:45,280
measuring phase we try to build sets of

199
00:07:45,280 --> 00:07:47,680
addresses that map to the same bank but

200
00:07:47,680 --> 00:07:49,199
a different role

201
00:07:49,199 --> 00:07:52,000
we do that by picking address pairs and

202
00:07:52,000 --> 00:07:54,000
then performing an alternating access

203
00:07:54,000 --> 00:07:56,319
between those two addresses

204
00:07:56,319 --> 00:07:58,639
and also keep measuring the average

205
00:07:58,639 --> 00:08:01,520
access time now if these two addresses

206
00:08:01,520 --> 00:08:03,280
are in the same bank but a different

207
00:08:03,280 --> 00:08:05,520
road and we trigger a row conflict for

208
00:08:05,520 --> 00:08:07,759
each and every access thus the average

209
00:08:07,759 --> 00:08:10,000
access time is high this corresponds to

210
00:08:10,000 --> 00:08:11,840
the small peak on the right of this

211
00:08:11,840 --> 00:08:13,039
histogram

212
00:08:13,039 --> 00:08:15,120
if the addresses are either in the same

213
00:08:15,120 --> 00:08:17,039
bank and same row which is kind of

214
00:08:17,039 --> 00:08:19,120
unlikely or in a different bank

215
00:08:19,120 --> 00:08:20,720
altogether which is by far the most

216
00:08:20,720 --> 00:08:22,240
likely case

217
00:08:22,240 --> 00:08:25,360
then axis is fast this is the large peak

218
00:08:25,360 --> 00:08:28,240
on the left of this histogram

219
00:08:28,240 --> 00:08:30,080
we then feed the sets into the

220
00:08:30,080 --> 00:08:32,240
reconstruction phase where we perform an

221
00:08:32,240 --> 00:08:34,958
exhaustive search over linear functions

222
00:08:34,958 --> 00:08:38,640
with up to n set coefficients and i know

223
00:08:38,640 --> 00:08:40,880
the term exhaustive search always sounds

224
00:08:40,880 --> 00:08:43,120
a bit scary but actually the search

225
00:08:43,120 --> 00:08:44,880
space is already so small that this is

226
00:08:44,880 --> 00:08:47,760
still very efficient uh the total run

227
00:08:47,760 --> 00:08:49,760
time for this reverse engineering of

228
00:08:49,760 --> 00:08:51,440
course depends on the machine but in

229
00:08:51,440 --> 00:08:53,120
most cases we are done in a couple of

230
00:08:53,120 --> 00:08:55,279
seconds and there we have that the

231
00:08:55,279 --> 00:08:57,279
majority of time is still used for

232
00:08:57,279 --> 00:09:00,800
measuring not reconstruction

233
00:09:00,800 --> 00:09:04,080
uh we analyzed a large set of machines

234
00:09:04,080 --> 00:09:05,040
using

235
00:09:05,040 --> 00:09:05,920
oh

236
00:09:05,920 --> 00:09:09,040
first this one yeah

237
00:09:09,040 --> 00:09:11,279
when we compare these two approaches

238
00:09:11,279 --> 00:09:13,680
for the probing we can recover the

239
00:09:13,680 --> 00:09:15,839
functions and the labels so we know okay

240
00:09:15,839 --> 00:09:17,519
this function computes a general bit

241
00:09:17,519 --> 00:09:20,240
this function computes a rank bit and so

242
00:09:20,240 --> 00:09:21,760
on we can't do that for the

243
00:09:21,760 --> 00:09:24,160
software-based attack but in the context

244
00:09:24,160 --> 00:09:26,240
of our attack

245
00:09:26,240 --> 00:09:28,160
we don't actually need the labels just

246
00:09:28,160 --> 00:09:31,120
the fun knowing the functions is enough

247
00:09:31,120 --> 00:09:32,480
for the probing

248
00:09:32,480 --> 00:09:35,279
the probing allowed us to find a ground

249
00:09:35,279 --> 00:09:38,000
truth because we are very certain if we

250
00:09:38,000 --> 00:09:39,680
do the probing then we know that these

251
00:09:39,680 --> 00:09:42,080
found functions are correct so we use

252
00:09:42,080 --> 00:09:44,080
that then to cross verify the

253
00:09:44,080 --> 00:09:46,240
software-based method and it also helped

254
00:09:46,240 --> 00:09:48,080
us to build the software-based method in

255
00:09:48,080 --> 00:09:49,600
the first place

256
00:09:49,600 --> 00:09:51,200
for the probing of course you need

257
00:09:51,200 --> 00:09:53,839
equipment a scope and access to the

258
00:09:53,839 --> 00:09:56,560
internals of the tested machine here

259
00:09:56,560 --> 00:09:58,399
however bear in mind that once you have

260
00:09:58,399 --> 00:10:00,720
reverse engineered one machine then you

261
00:10:00,720 --> 00:10:02,959
can attack any similar machine as well

262
00:10:02,959 --> 00:10:04,800
you don't need to

263
00:10:04,800 --> 00:10:06,720
you don't need to reverse engineer every

264
00:10:06,720 --> 00:10:08,640
single machine you attack this would be

265
00:10:08,640 --> 00:10:10,000
kind of pointless with the probing

266
00:10:10,000 --> 00:10:12,320
anyway

267
00:10:12,480 --> 00:10:13,839
the software-based approach on the other

268
00:10:13,839 --> 00:10:16,720
hand is fully automated can run remotely

269
00:10:16,720 --> 00:10:19,120
sandboxed and even on mobile devices

270
00:10:19,120 --> 00:10:21,519
where probing gets a bit difficult due

271
00:10:21,519 --> 00:10:25,360
to soldered on memory

272
00:10:26,000 --> 00:10:28,959
now we analyzed a large set of machines

273
00:10:28,959 --> 00:10:30,880
using these two approaches and now give

274
00:10:30,880 --> 00:10:34,720
at least a little excerpt of our results

275
00:10:34,720 --> 00:10:36,399
here you have the mapping of an intel

276
00:10:36,399 --> 00:10:38,720
haswell desktop system using ddr3 dual

277
00:10:38,720 --> 00:10:40,720
channel memory channel is computed by

278
00:10:40,720 --> 00:10:43,600
xoring seven bits together and bank and

279
00:10:43,600 --> 00:10:45,680
rank addressing is done by xoring bits

280
00:10:45,680 --> 00:10:48,800
14 to 17 with the lowest bits of the row

281
00:10:48,800 --> 00:10:52,560
index which starts at bits 18.

282
00:10:52,560 --> 00:10:55,440
now for a dual cpu server system this

283
00:10:55,440 --> 00:10:58,000
mapping gets a bit more complex and you

284
00:10:58,000 --> 00:11:00,160
can maybe guess that attacking a machine

285
00:11:00,160 --> 00:11:01,680
without knowledge of this mapping and

286
00:11:01,680 --> 00:11:03,519
just by guessing addresses might gonna

287
00:11:03,519 --> 00:11:05,200
get a bit difficult

288
00:11:05,200 --> 00:11:07,200
also apparently intel got a bit lazy

289
00:11:07,200 --> 00:11:08,480
with their channel addressing because

290
00:11:08,480 --> 00:11:12,079
they just use each other bits

291
00:11:12,320 --> 00:11:13,680
on the other side of the spectrum we

292
00:11:13,680 --> 00:11:15,680
have mobile devices here for instance

293
00:11:15,680 --> 00:11:18,000
the galaxy s6 where the mappings are

294
00:11:18,000 --> 00:11:21,120
usually much simpler

295
00:11:21,120 --> 00:11:24,079
so now let's use these mappings in our

296
00:11:24,079 --> 00:11:26,160
cross cpu attacks and of course i'll

297
00:11:26,160 --> 00:11:28,720
also have to continue the story of romeo

298
00:11:28,720 --> 00:11:30,720
and juliet

299
00:11:30,720 --> 00:11:32,079
our first

300
00:11:32,079 --> 00:11:34,160
first attack is a high-speed coverage

301
00:11:34,160 --> 00:11:36,480
channel that allows these two guys to

302
00:11:36,480 --> 00:11:39,760
talk across cpus and vms

303
00:11:39,760 --> 00:11:42,320
this covered channel works as follows

304
00:11:42,320 --> 00:11:44,480
first

305
00:11:44,480 --> 00:11:46,480
the sender and the receiver so romeo and

306
00:11:46,480 --> 00:11:49,440
juliet need to agree on one bank which

307
00:11:49,440 --> 00:11:51,279
they use for transmission

308
00:11:51,279 --> 00:11:54,800
then they need to allocate memory which

309
00:11:54,800 --> 00:11:56,959
is in different rows but in this one

310
00:11:56,959 --> 00:12:00,480
bank this is actually fairly easy to do

311
00:12:00,480 --> 00:12:02,560
then for the attack

312
00:12:02,560 --> 00:12:05,200
for the actual transmission juliet the

313
00:12:05,200 --> 00:12:07,920
receiver just keeps accessing one of her

314
00:12:07,920 --> 00:12:10,079
rows and measuring the average access

315
00:12:10,079 --> 00:12:11,360
time

316
00:12:11,360 --> 00:12:14,000
now if romeo wants to send a 1 he

317
00:12:14,000 --> 00:12:16,639
continuously accesses his row this of

318
00:12:16,639 --> 00:12:18,880
course activates his row in the row

319
00:12:18,880 --> 00:12:20,000
buffer

320
00:12:20,000 --> 00:12:21,360
then

321
00:12:21,360 --> 00:12:22,720
juliet

322
00:12:22,720 --> 00:12:24,639
for them if juliet

323
00:12:24,639 --> 00:12:26,800
accesses her row again she triggers a

324
00:12:26,800 --> 00:12:28,880
row conflict the access time is high

325
00:12:28,880 --> 00:12:32,320
thus she can infer okay a one was sent

326
00:12:32,320 --> 00:12:34,079
if on the other hand romeo wants to send

327
00:12:34,079 --> 00:12:36,639
a zero he just doesn't do anything uh

328
00:12:36,639 --> 00:12:39,200
julia's next access is served directly

329
00:12:39,200 --> 00:12:40,720
from the row buffer and this is of

330
00:12:40,720 --> 00:12:43,360
course fast

331
00:12:43,600 --> 00:12:45,680
uh we implemented a proof of concept of

332
00:12:45,680 --> 00:12:48,079
this covered channel where we used some

333
00:12:48,079 --> 00:12:50,959
tricks mainly that each bank can be used

334
00:12:50,959 --> 00:12:52,959
as a separate transmission channel we

335
00:12:52,959 --> 00:12:55,040
use up to eight banks in parallel so

336
00:12:55,040 --> 00:12:58,560
transmit one byte per

337
00:12:59,120 --> 00:13:00,959
per time frame and we also use

338
00:13:00,959 --> 00:13:03,279
multi-threading to regain some of the

339
00:13:03,279 --> 00:13:05,680
channel parallelism which we use by

340
00:13:05,680 --> 00:13:09,279
which we lose by doing the measuring

341
00:13:09,440 --> 00:13:11,600
on the right you can see

342
00:13:11,600 --> 00:13:13,920
a performance curve or for a desktop

343
00:13:13,920 --> 00:13:15,839
system intel haswell so in this case

344
00:13:15,839 --> 00:13:18,880
we're cross core but not cross cpu

345
00:13:18,880 --> 00:13:21,680
and we show the bit error probability as

346
00:13:21,680 --> 00:13:23,519
a function of the raw bit rate and also

347
00:13:23,519 --> 00:13:25,360
the channel capacity

348
00:13:25,360 --> 00:13:27,839
and this channel capacity peaks at about

349
00:13:27,839 --> 00:13:30,720
2.1 megabits per second

350
00:13:30,720 --> 00:13:33,920
for the cross cpu scenario on a dual cpu

351
00:13:33,920 --> 00:13:36,959
server we still achieve 1.2 megabits per

352
00:13:36,959 --> 00:13:38,720
second

353
00:13:38,720 --> 00:13:41,120
and these numbers fare quite well when

354
00:13:41,120 --> 00:13:43,120
we compare them to previously proposed

355
00:13:43,120 --> 00:13:44,720
cover channels

356
00:13:44,720 --> 00:13:46,959
when compared to the cash-based attacks

357
00:13:46,959 --> 00:13:48,480
which are in the middle part of this

358
00:13:48,480 --> 00:13:51,839
section you can see that it's there our

359
00:13:51,839 --> 00:13:54,320
attack is about as fast as cache-based

360
00:13:54,320 --> 00:13:57,199
cover channel and it is also faster than

361
00:13:57,199 --> 00:13:59,440
the one using prime and probe

362
00:13:59,440 --> 00:14:01,279
which is the only one that does not

363
00:14:01,279 --> 00:14:03,839
require shared memory so our attacks are

364
00:14:03,839 --> 00:14:06,240
not restricted to just the multi-cpu

365
00:14:06,240 --> 00:14:08,079
setting they can also be a threat in the

366
00:14:08,079 --> 00:14:10,800
single cpu scenario

367
00:14:10,800 --> 00:14:12,480
now there have been previous works

368
00:14:12,480 --> 00:14:15,920
targeting cross-cpu covered channels but

369
00:14:15,920 --> 00:14:17,920
achieve transmission rates are orders of

370
00:14:17,920 --> 00:14:20,079
magnitude lower than that what you can

371
00:14:20,079 --> 00:14:23,760
achieve using the dram functions

372
00:14:25,120 --> 00:14:27,519
oh unfortunately for romeo and juliet

373
00:14:27,519 --> 00:14:29,440
their feuding families found out about

374
00:14:29,440 --> 00:14:31,279
their little secret about their row

375
00:14:31,279 --> 00:14:33,839
buffer and now use

376
00:14:33,839 --> 00:14:35,839
also the robot foot to perform a low

377
00:14:35,839 --> 00:14:37,279
noise side channel attack so that they

378
00:14:37,279 --> 00:14:39,440
can spy on each other

379
00:14:39,440 --> 00:14:41,839
our attack allows to spy on memory

380
00:14:41,839 --> 00:14:43,519
accesses

381
00:14:43,519 --> 00:14:45,760
it works as follows first the victim and

382
00:14:45,760 --> 00:14:48,639
the the spy needs to allocate memory

383
00:14:48,639 --> 00:14:52,320
which is in the same row as a as a

384
00:14:52,320 --> 00:14:56,240
memory uh owned by the victim now as the

385
00:14:56,240 --> 00:14:57,920
typically dram row size is eight

386
00:14:57,920 --> 00:15:00,480
kilobytes and pages are four kilobytes

387
00:15:00,480 --> 00:15:03,519
you have at least two pages per row due

388
00:15:03,519 --> 00:15:05,760
to the complex addressing functions you

389
00:15:05,760 --> 00:15:08,880
typically have even more page chunk more

390
00:15:08,880 --> 00:15:12,480
than two page chunks per row um here i

391
00:15:12,480 --> 00:15:15,279
also have to say that please this is not

392
00:15:15,279 --> 00:15:16,880
shared memory they're just adjacent to

393
00:15:16,880 --> 00:15:18,800
hr that they can't access each other's

394
00:15:18,800 --> 00:15:20,800
memory

395
00:15:20,800 --> 00:15:23,040
now for the actual spying the first step

396
00:15:23,040 --> 00:15:25,440
is that the spy activates a conflict

397
00:15:25,440 --> 00:15:27,839
role which is just any row that is not

398
00:15:27,839 --> 00:15:30,079
shared with the victim

399
00:15:30,079 --> 00:15:32,240
then the spy waits for the victim to

400
00:15:32,240 --> 00:15:34,720
compute and in this time possibly access

401
00:15:34,720 --> 00:15:38,000
the contents of the shared row

402
00:15:38,000 --> 00:15:40,800
then in the final step uh the spy also

403
00:15:40,800 --> 00:15:43,199
accesses the shared row and measures the

404
00:15:43,199 --> 00:15:45,680
access time now if this access time is

405
00:15:45,680 --> 00:15:48,160
below a certain threshold then we know

406
00:15:48,160 --> 00:15:51,920
okay this row this memory request must

407
00:15:51,920 --> 00:15:53,680
have been served directly from the row

408
00:15:53,680 --> 00:15:56,399
buffer and this can only happen if the

409
00:15:56,399 --> 00:15:59,040
row was previously activated so we know

410
00:15:59,040 --> 00:16:01,519
that the victim accessed this single

411
00:16:01,519 --> 00:16:02,959
address because otherwise we wouldn't

412
00:16:02,959 --> 00:16:05,839
have a row hit

413
00:16:06,560 --> 00:16:08,880
you can see this attack

414
00:16:08,880 --> 00:16:11,519
uh a real application of this attacks we

415
00:16:11,519 --> 00:16:13,839
we spy on keystrokes in the firefox

416
00:16:13,839 --> 00:16:17,040
address bar and just keep monitoring the

417
00:16:17,040 --> 00:16:19,759
access time to one vulnerable address

418
00:16:19,759 --> 00:16:21,279
and you can clearly see that each time

419
00:16:21,279 --> 00:16:23,440
the user presses a button in the address

420
00:16:23,440 --> 00:16:24,240
bar

421
00:16:24,240 --> 00:16:27,040
the access time tool developer address

422
00:16:27,040 --> 00:16:29,360
goes down dramatically so we can detect

423
00:16:29,360 --> 00:16:32,000
keystrokes

424
00:16:32,639 --> 00:16:34,880
this attack achieves a very high spatial

425
00:16:34,880 --> 00:16:37,519
accuracy down to

426
00:16:37,519 --> 00:16:39,360
the spatial accuracy depends on the

427
00:16:39,360 --> 00:16:41,360
actual mapping we have in the machines

428
00:16:41,360 --> 00:16:44,560
but we can get down to 512 bytes which

429
00:16:44,560 --> 00:16:46,720
is almost in the range of the best cache

430
00:16:46,720 --> 00:16:48,000
attacks

431
00:16:48,000 --> 00:16:50,480
also we have a very low number of false

432
00:16:50,480 --> 00:16:52,880
positives this is actually the low noise

433
00:16:52,880 --> 00:16:56,639
part of the low noise such and attack

434
00:16:56,639 --> 00:16:59,199
this allows us to monitor single events

435
00:16:59,199 --> 00:17:01,120
single key strokes single memory

436
00:17:01,120 --> 00:17:02,399
accesses

437
00:17:02,399 --> 00:17:04,880
this sets it apart from other cache

438
00:17:04,880 --> 00:17:07,280
attacks for instance prima probe which

439
00:17:07,280 --> 00:17:08,480
has a

440
00:17:08,480 --> 00:17:10,799
much more noise and doesn't really allow

441
00:17:10,799 --> 00:17:14,240
to monitor singing events

442
00:17:14,240 --> 00:17:16,480
one challenge i haven't talked about

443
00:17:16,480 --> 00:17:18,959
yet is well how to find vulnerable

444
00:17:18,959 --> 00:17:20,400
addresses

445
00:17:20,400 --> 00:17:23,280
we do that by using cache methods from

446
00:17:23,280 --> 00:17:25,599
cache template attacks so we perform an

447
00:17:25,599 --> 00:17:27,599
automatic location of vulnerable

448
00:17:27,599 --> 00:17:29,679
addresses by

449
00:17:29,679 --> 00:17:31,360
uh first

450
00:17:31,360 --> 00:17:33,200
allocating a large fraction of the

451
00:17:33,200 --> 00:17:35,679
physical memory ideally in four kilobyte

452
00:17:35,679 --> 00:17:37,840
pages and then scanning over all this

453
00:17:37,840 --> 00:17:40,880
memory uh automatically and

454
00:17:40,880 --> 00:17:44,559
trying to find vulnerable addresses

455
00:17:44,880 --> 00:17:46,480
so when you

456
00:17:46,480 --> 00:17:48,240
propose a new attack you'll also have to

457
00:17:48,240 --> 00:17:50,559
think about well what can we actually do

458
00:17:50,559 --> 00:17:52,160
against that

459
00:17:52,160 --> 00:17:54,640
well the first intuition will just

460
00:17:54,640 --> 00:17:57,200
restrict the cpu instructions rdtsc and

461
00:17:57,200 --> 00:17:59,600
cl flush first is used for getting

462
00:17:59,600 --> 00:18:02,240
accurate timestamps the second one for

463
00:18:02,240 --> 00:18:04,799
uh flushing the cache

464
00:18:04,799 --> 00:18:07,520
and while these might make well these

465
00:18:07,520 --> 00:18:10,400
probably make the attacks harder

466
00:18:10,400 --> 00:18:12,400
they do not fully prevent that there are

467
00:18:12,400 --> 00:18:14,400
alternatives to using these instructions

468
00:18:14,400 --> 00:18:16,480
and actually we already have a cover

469
00:18:16,480 --> 00:18:18,559
channel implementation that does not

470
00:18:18,559 --> 00:18:20,960
need these two instructions

471
00:18:20,960 --> 00:18:24,880
one way to definitely shut down this

472
00:18:24,880 --> 00:18:26,720
side channel is at least in the

473
00:18:26,720 --> 00:18:28,880
multi-cpu setting multi-socket

474
00:18:28,880 --> 00:18:31,840
setting to not also uh

475
00:18:31,840 --> 00:18:34,480
assign the tenants to dedicated physical

476
00:18:34,480 --> 00:18:38,160
cpus but then to also restrict access to

477
00:18:38,160 --> 00:18:41,440
the cpu local memory thus then they

478
00:18:41,440 --> 00:18:43,679
never share a row buffer and our tags

479
00:18:43,679 --> 00:18:45,039
are not possible

480
00:18:45,039 --> 00:18:46,640
but then uh

481
00:18:46,640 --> 00:18:48,559
you kind of essentially degrade a

482
00:18:48,559 --> 00:18:51,440
multi-cpu system in multiple series cpu

483
00:18:51,440 --> 00:18:53,360
system which kind of defeats the point

484
00:18:53,360 --> 00:18:54,320
of having

485
00:18:54,320 --> 00:18:56,320
such an expensive multi-cpu system in

486
00:18:56,320 --> 00:18:58,480
the first place

487
00:18:58,480 --> 00:18:59,280
so

488
00:18:59,280 --> 00:19:02,960
prevention might be difficult uh but we

489
00:19:02,960 --> 00:19:04,240
can uh

490
00:19:04,240 --> 00:19:06,320
but we might be able to detect these

491
00:19:06,320 --> 00:19:08,559
attacks due to the high number of cache

492
00:19:08,559 --> 00:19:13,200
misses and row conflicts we induce

493
00:19:14,799 --> 00:19:17,039
apart from enabling these two previous

494
00:19:17,039 --> 00:19:18,640
attacks the cover channel and the side

495
00:19:18,640 --> 00:19:20,400
channel attack

496
00:19:20,400 --> 00:19:22,240
we can also improve upon existing

497
00:19:22,240 --> 00:19:24,480
attacks namely the row hammer bug for

498
00:19:24,480 --> 00:19:25,919
those of you who haven't been in

499
00:19:25,919 --> 00:19:28,000
yesterday's sessions

500
00:19:28,000 --> 00:19:30,559
row hammer is about inducing bit flips

501
00:19:30,559 --> 00:19:33,200
in dram by quickly switching between two

502
00:19:33,200 --> 00:19:36,799
rows quickly activating rows

503
00:19:36,799 --> 00:19:39,200
here you need uh for for doing that you

504
00:19:39,200 --> 00:19:41,600
need addresses that map to the same bank

505
00:19:41,600 --> 00:19:44,559
and to rows which ideally close to each

506
00:19:44,559 --> 00:19:46,080
other

507
00:19:46,080 --> 00:19:48,720
and of course finding such addresses is

508
00:19:48,720 --> 00:19:50,799
of course a lot easier if you have the

509
00:19:50,799 --> 00:19:52,640
addressing functions by just guessing it

510
00:19:52,640 --> 00:19:56,240
you might never find these addresses

511
00:19:56,240 --> 00:19:57,520
and in fact

512
00:19:57,520 --> 00:19:59,200
by using our addressing functions we

513
00:19:59,200 --> 00:20:01,679
were the first to document bitflips in

514
00:20:01,679 --> 00:20:05,360
ddr4 memory and strangely we also found

515
00:20:05,360 --> 00:20:07,520
bit flips in system where the target row

516
00:20:07,520 --> 00:20:09,600
refresh row hammer counter measures

517
00:20:09,600 --> 00:20:12,080
should have been active

518
00:20:12,080 --> 00:20:14,000
so these findings are

519
00:20:14,000 --> 00:20:16,480
in a bit of a contradiction to claims

520
00:20:16,480 --> 00:20:17,840
that have been floating around the

521
00:20:17,840 --> 00:20:19,919
internet that yeah rowhammer is a thing

522
00:20:19,919 --> 00:20:21,280
of the past for

523
00:20:21,280 --> 00:20:23,200
for ddr4 well

524
00:20:23,200 --> 00:20:25,919
obviously not

525
00:20:26,240 --> 00:20:28,960
so this brings me then to the end

526
00:20:28,960 --> 00:20:31,840
of romeo and juliet

527
00:20:31,840 --> 00:20:34,159
but also coincidentally that of our

528
00:20:34,159 --> 00:20:36,960
presentation as a final note the source

529
00:20:36,960 --> 00:20:39,280
code for the reverse engineering tool

530
00:20:39,280 --> 00:20:41,360
and the side channel attack is available

531
00:20:41,360 --> 00:20:43,919
online so you can download it now you

532
00:20:43,919 --> 00:20:45,760
just have to set a few parameters and

533
00:20:45,760 --> 00:20:47,520
press start you can reverse engineer the

534
00:20:47,520 --> 00:20:49,600
mapping on your own laptop

535
00:20:49,600 --> 00:20:52,559
okay so and that's it thank you for your

536
00:20:52,559 --> 00:20:53,530
attention

537
00:20:53,530 --> 00:21:00,700
[Applause]

538
00:21:01,280 --> 00:21:03,280
so we have uh quite a bit of time for

539
00:21:03,280 --> 00:21:05,678
questions

540
00:21:08,640 --> 00:21:10,960
okay i have one so you already answered

541
00:21:10,960 --> 00:21:13,039
one of the questions i had was which was

542
00:21:13,039 --> 00:21:14,480
of course you know what could be done to

543
00:21:14,480 --> 00:21:16,400
you know prevent this kind of a scary

544
00:21:16,400 --> 00:21:18,640
attack um and so you know thanks for

545
00:21:18,640 --> 00:21:21,440
that um

546
00:21:21,520 --> 00:21:23,280
i guess one one one thing that i'm

547
00:21:23,280 --> 00:21:24,799
interested in is of course you know

548
00:21:24,799 --> 00:21:26,480
doing this probing takes a lot of work

549
00:21:26,480 --> 00:21:27,919
and so you mentioned you showed some of

550
00:21:27,919 --> 00:21:29,360
the mappings that you're able to recover

551
00:21:29,360 --> 00:21:30,960
but could you give us an idea of how

552
00:21:30,960 --> 00:21:33,520
many you actually found

553
00:21:33,520 --> 00:21:34,720
of these mappings where you were doing

554
00:21:34,720 --> 00:21:36,640
the probing of different sorts of

555
00:21:36,640 --> 00:21:39,919
probing we did mainly two machines a

556
00:21:39,919 --> 00:21:43,280
dual cpu desktop and a and a

557
00:21:43,280 --> 00:21:45,200
i know a dual cpu server and a desktop

558
00:21:45,200 --> 00:21:46,880
machine and in different memory

559
00:21:46,880 --> 00:21:49,200
configurations and we then did a lot of

560
00:21:49,200 --> 00:21:50,880
other machines using the software based

561
00:21:50,880 --> 00:21:53,440
approach including uh mobile devices so

562
00:21:53,440 --> 00:21:55,520
can you quantify a lot

563
00:21:55,520 --> 00:21:57,679
can you quantify a lot for the

564
00:21:57,679 --> 00:21:58,880
software-based approach how many

565
00:21:58,880 --> 00:22:00,320
software-based

566
00:22:00,320 --> 00:22:02,080
uh how many systems did you apply the

567
00:22:02,080 --> 00:22:03,440
software basically

568
00:22:03,440 --> 00:22:04,720
we give

569
00:22:04,720 --> 00:22:07,200
the list the entire list in the paper i

570
00:22:07,200 --> 00:22:08,320
think it was

571
00:22:08,320 --> 00:22:10,880
10 to 15 systems or something like that

572
00:22:10,880 --> 00:22:12,799
okay

573
00:22:12,799 --> 00:22:14,159
you mentioned that

574
00:22:14,159 --> 00:22:16,400
oh sorry

575
00:22:16,400 --> 00:22:18,000
um so

576
00:22:18,000 --> 00:22:20,640
did you do any measurements that said

577
00:22:20,640 --> 00:22:21,679
basically

578
00:22:21,679 --> 00:22:23,679
how close together two rows have to be

579
00:22:23,679 --> 00:22:26,720
before you can flip bits in them so if

580
00:22:26,720 --> 00:22:28,400
i'm willing to give up like

581
00:22:28,400 --> 00:22:30,880
uh i don't know 80 of my ram can i

582
00:22:30,880 --> 00:22:33,039
prevent row hammer by making sure that

583
00:22:33,039 --> 00:22:34,640
things only get mapped to rows they're

584
00:22:34,640 --> 00:22:36,000
far enough away

585
00:22:36,000 --> 00:22:36,880
well

586
00:22:36,880 --> 00:22:38,960
what i was talking about is you need to

587
00:22:38,960 --> 00:22:41,840
have a road that is adjacent uh ideally

588
00:22:41,840 --> 00:22:44,080
to the road that you attack and ideally

589
00:22:44,080 --> 00:22:46,400
you have to roll the two adjacent rows

590
00:22:46,400 --> 00:22:48,159
to the attack draw so the wrong row

591
00:22:48,159 --> 00:22:50,000
above and the row below

592
00:22:50,000 --> 00:22:51,440
okay so that's right

593
00:22:51,440 --> 00:22:53,679
away maybe i'm safe if i'm three away

594
00:22:53,679 --> 00:22:57,600
maybe i'm safe now yeah okay

595
00:22:58,400 --> 00:23:00,240
so uh fascinating work with this in the

596
00:23:00,240 --> 00:23:02,640
one before really congratulations uh i

597
00:23:02,640 --> 00:23:04,240
have a question about the figure you

598
00:23:04,240 --> 00:23:06,400
showed about the physical probing yeah

599
00:23:06,400 --> 00:23:09,280
um i'm actually quite surprised that you

600
00:23:09,280 --> 00:23:11,520
took a standard passive probe and

601
00:23:11,520 --> 00:23:12,480
touched

602
00:23:12,480 --> 00:23:15,120
uh three gigahertz bus and actually

603
00:23:15,120 --> 00:23:16,960
managed to measure something and not

604
00:23:16,960 --> 00:23:18,400
destroy the system so if it could come

605
00:23:18,400 --> 00:23:21,679
yeah that was also my reaction

606
00:23:21,679 --> 00:23:22,480
so

607
00:23:22,480 --> 00:23:24,320
but it works yeah

608
00:23:24,320 --> 00:23:26,159
using such a standard passive probe you

609
00:23:26,159 --> 00:23:28,240
might not be able to do a full protocol

610
00:23:28,240 --> 00:23:30,400
analysis because it's too slow but for

611
00:23:30,400 --> 00:23:32,640
the reverse engineering uh this was more

612
00:23:32,640 --> 00:23:34,880
than enough so we could easily read so

613
00:23:34,880 --> 00:23:36,320
you just took the standard probe and

614
00:23:36,320 --> 00:23:39,840
touched the ddr4 bus and

615
00:23:39,840 --> 00:23:41,440
okay

616
00:23:41,440 --> 00:23:43,279
i might save a couple of dollars next

617
00:23:43,279 --> 00:23:44,960
time i buy scope okay thank you very

618
00:23:44,960 --> 00:23:47,120
much

619
00:23:48,880 --> 00:23:51,440
so i'm also curious so what what can you

620
00:23:51,440 --> 00:23:53,279
describe the experimental setup that you

621
00:23:53,279 --> 00:23:55,679
performed all of this in um was this

622
00:23:55,679 --> 00:23:56,960
like in the cloud or was this kind of a

623
00:23:56,960 --> 00:23:59,279
laboratory i know we did it uh locally

624
00:23:59,279 --> 00:24:01,279
okay so have you tried it okay we had

625
00:24:01,279 --> 00:24:02,960
local desktop machines and also we had

626
00:24:02,960 --> 00:24:05,520
our own server have you tried doing this

627
00:24:05,520 --> 00:24:08,159
in the cloud we have not yet no

628
00:24:08,159 --> 00:24:09,760
do you think that you know kind of the

629
00:24:09,760 --> 00:24:11,440
ad noise you might see would would bring

630
00:24:11,440 --> 00:24:13,279
down the

631
00:24:13,279 --> 00:24:15,520
the transmission rates yes definitely

632
00:24:15,520 --> 00:24:17,600
because we tested this on silent systems

633
00:24:17,600 --> 00:24:20,080
where there was no other main processing

634
00:24:20,080 --> 00:24:21,360
uh

635
00:24:21,360 --> 00:24:23,760
doing a lot of memory intensive work so

636
00:24:23,760 --> 00:24:25,440
of course then the transmission rates

637
00:24:25,440 --> 00:24:27,120
will go down yeah but it would be very

638
00:24:27,120 --> 00:24:28,240
interesting to see how well it

639
00:24:28,240 --> 00:24:31,240
translates

640
00:24:32,240 --> 00:24:36,360
okay let's thank the speaker again

