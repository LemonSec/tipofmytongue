1
00:00:08,000 --> 00:00:10,380
today I'm going to present my work

2
00:00:10,380 --> 00:00:12,960
Playing for Keeps understanding and

3
00:00:12,960 --> 00:00:14,519
improving Linux kernel expiry

4
00:00:14,519 --> 00:00:15,839
reliability

5
00:00:15,839 --> 00:00:18,359
this is a collaborated work from Arizona

6
00:00:18,359 --> 00:00:20,520
State University Pennsylvania State

7
00:00:20,520 --> 00:00:22,500
University University of Colorado

8
00:00:22,500 --> 00:00:24,779
Boulder sunso University and

9
00:00:24,779 --> 00:00:27,680
Northwestern University

10
00:00:27,840 --> 00:00:30,660
a Lena's kernel hip exploit usually

11
00:00:30,660 --> 00:00:32,520
involves a victim object

12
00:00:32,520 --> 00:00:35,280
the attacker will use vulnerabilities to

13
00:00:35,280 --> 00:00:37,079
override the victim object with

14
00:00:37,079 --> 00:00:38,940
attacker-controlled data

15
00:00:38,940 --> 00:00:41,040
when a kernel tries to de-reference the

16
00:00:41,040 --> 00:00:44,040
Control Data as the victim object it

17
00:00:44,040 --> 00:00:46,379
allows the attack to break the security

18
00:00:46,379 --> 00:00:48,059
boundary and perform privilege

19
00:00:48,059 --> 00:00:49,620
escalation

20
00:00:49,620 --> 00:00:53,399
however in a typical kernel exploit the

21
00:00:53,399 --> 00:00:56,100
object override does not succeed 100 of

22
00:00:56,100 --> 00:00:59,219
the time in other words the exploits are

23
00:00:59,219 --> 00:01:01,559
unreliable

24
00:01:01,559 --> 00:01:04,379
we know it as a fact that Venus kernel

25
00:01:04,379 --> 00:01:06,299
exploits are dangerous because they

26
00:01:06,299 --> 00:01:08,820
affect millions of devices

27
00:01:08,820 --> 00:01:11,280
but at the same time they are also known

28
00:01:11,280 --> 00:01:13,439
to be unreliable

29
00:01:13,439 --> 00:01:15,840
there are existing practices to improve

30
00:01:15,840 --> 00:01:17,939
exploratory reliability we call them

31
00:01:17,939 --> 00:01:20,759
x-ray stabilization techniques

32
00:01:20,759 --> 00:01:23,280
however how to and when to use them

33
00:01:23,280 --> 00:01:26,460
heavily relies on personal expertise

34
00:01:26,460 --> 00:01:28,680
so it is important for us to understand

35
00:01:28,680 --> 00:01:31,140
expiry reliability to evaluate the

36
00:01:31,140 --> 00:01:33,000
vulnerability of severity

37
00:01:33,000 --> 00:01:35,579
unfortunately this topic is not covered

38
00:01:35,579 --> 00:01:38,759
by existing works to fill the Gap we

39
00:01:38,759 --> 00:01:40,740
want to study this problem more

40
00:01:40,740 --> 00:01:43,259
specifically we want to systematically

41
00:01:43,259 --> 00:01:45,360
study why Linux kernel heap-based

42
00:01:45,360 --> 00:01:48,540
exploits are unreliable

43
00:01:48,540 --> 00:01:51,299
so to perform the systematic study we

44
00:01:51,299 --> 00:01:54,479
want to answer a few research questions

45
00:01:54,479 --> 00:01:56,159
what are the commonly used XY

46
00:01:56,159 --> 00:01:57,899
stabilization techniques

47
00:01:57,899 --> 00:02:00,479
how effective are existing techniques

48
00:02:00,479 --> 00:02:03,360
are they as effective as expected and

49
00:02:03,360 --> 00:02:05,640
why do existing techniques work

50
00:02:05,640 --> 00:02:07,979
with knowledge from the systematic study

51
00:02:07,979 --> 00:02:10,800
can we find new ways to further improve

52
00:02:10,800 --> 00:02:13,819
exploratory reliability

53
00:02:14,040 --> 00:02:16,560
we designed a hybrid approach to answer

54
00:02:16,560 --> 00:02:18,000
the questions

55
00:02:18,000 --> 00:02:20,220
first we performed a qualitative

56
00:02:20,220 --> 00:02:22,800
interview on human experts and collect

57
00:02:22,800 --> 00:02:25,560
existing techniques from the experts

58
00:02:25,560 --> 00:02:28,080
then we perform a quantitative

59
00:02:28,080 --> 00:02:30,480
experiment to measure the effectiveness

60
00:02:30,480 --> 00:02:32,459
of all the techniques

61
00:02:32,459 --> 00:02:35,340
then we investigate why and how do they

62
00:02:35,340 --> 00:02:37,860
work and use the knowledge to build a

63
00:02:37,860 --> 00:02:40,980
theoretical model to explain the problem

64
00:02:40,980 --> 00:02:44,160
then we derive a new technique and a

65
00:02:44,160 --> 00:02:46,920
technique combination from the model to

66
00:02:46,920 --> 00:02:50,599
further improve exploratory reliability

67
00:02:50,940 --> 00:02:53,459
for the first step we interviewed 11

68
00:02:53,459 --> 00:02:55,800
Linux Kernel Security Experts and

69
00:02:55,800 --> 00:02:57,720
collected five exploitation

70
00:02:57,720 --> 00:03:00,140
stabilization techniques namely

71
00:03:00,140 --> 00:03:03,120
defragmentation hip grooming hip spray

72
00:03:03,120 --> 00:03:06,000
and CPU painting since there are two

73
00:03:06,000 --> 00:03:08,819
kinds of implementation of History we

74
00:03:08,819 --> 00:03:10,379
regarded them as two different

75
00:03:10,379 --> 00:03:13,379
techniques

76
00:03:14,040 --> 00:03:17,640
then we collected 17 public exploits and

77
00:03:17,640 --> 00:03:19,860
strip away existing techniques employed

78
00:03:19,860 --> 00:03:23,640
in the exploits as the Baseline exploits

79
00:03:23,640 --> 00:03:26,220
and then we apply one single technique

80
00:03:26,220 --> 00:03:28,739
from the collected technique set to the

81
00:03:28,739 --> 00:03:31,200
Baseline exploit to form the exploited

82
00:03:31,200 --> 00:03:32,400
variants

83
00:03:32,400 --> 00:03:36,980
in total we obtain 85 samples

84
00:03:37,800 --> 00:03:39,599
the result of the quantitative

85
00:03:39,599 --> 00:03:42,060
experiment is summarized here

86
00:03:42,060 --> 00:03:44,599
as you can see overall speaking

87
00:03:44,599 --> 00:03:47,220
multi-processed hip spray involved

88
00:03:47,220 --> 00:03:49,140
improves exploratory reliability in the

89
00:03:49,140 --> 00:03:51,019
most significantly

90
00:03:51,019 --> 00:03:53,940
and while all other techniques improve

91
00:03:53,940 --> 00:03:57,360
exploit reliability as expected this

92
00:03:57,360 --> 00:03:59,400
recommendation as a stabilization

93
00:03:59,400 --> 00:04:03,799
technique somehow hurts reliability

94
00:04:03,959 --> 00:04:07,440
we investigated further on this case it

95
00:04:07,440 --> 00:04:09,120
turns out that defermentation only

96
00:04:09,120 --> 00:04:12,180
improves XY reliability for out-of-bound

97
00:04:12,180 --> 00:04:13,980
Access exploits

98
00:04:13,980 --> 00:04:17,160
and interestingly if we used incorrectly

99
00:04:17,160 --> 00:04:19,798
it can significantly hurt reliability

100
00:04:19,798 --> 00:04:23,359
for other exploits

101
00:04:23,759 --> 00:04:26,820
based on our analysis we summarize the

102
00:04:26,820 --> 00:04:29,520
life cycle of Linux kernel exploits as

103
00:04:29,520 --> 00:04:31,080
shown here

104
00:04:31,080 --> 00:04:34,020
typically a Linux kernel hip exploit

105
00:04:34,020 --> 00:04:37,020
involves a contact setup step Where It

106
00:04:37,020 --> 00:04:39,660
prepares system resources to trigger the

107
00:04:39,660 --> 00:04:41,699
vulnerability in the first step

108
00:04:41,699 --> 00:04:43,860
after the vulnerability is triggered

109
00:04:43,860 --> 00:04:46,380
there could be a time delay before the

110
00:04:46,380 --> 00:04:49,020
Heap is actually corrupted

111
00:04:49,020 --> 00:04:51,960
then for exploits that corrupt the

112
00:04:51,960 --> 00:04:54,300
allocator it needs to restore the

113
00:04:54,300 --> 00:04:56,040
allocator back to its normal State

114
00:04:56,040 --> 00:05:00,300
before the kernel detects its anomaly

115
00:05:00,300 --> 00:05:02,759
finally the exploit will trigger the

116
00:05:02,759 --> 00:05:06,180
payload and break the security boundary

117
00:05:06,180 --> 00:05:08,400
knowing the life cycle of the exploits

118
00:05:08,400 --> 00:05:11,340
we then investigated when exploits can

119
00:05:11,340 --> 00:05:12,479
fail

120
00:05:12,479 --> 00:05:15,740
it turns out that exploits can fail

121
00:05:15,740 --> 00:05:18,780
in different periods in the life cycle

122
00:05:18,780 --> 00:05:20,880
if they use different exploitation

123
00:05:20,880 --> 00:05:22,800
techniques

124
00:05:22,800 --> 00:05:24,840
for use other free and double free

125
00:05:24,840 --> 00:05:28,259
exploits as expected the exploits May

126
00:05:28,259 --> 00:05:30,960
Fail between the target objects is freed

127
00:05:30,960 --> 00:05:33,720
and the allocator is restored back to

128
00:05:33,720 --> 00:05:35,940
its normal state

129
00:05:35,940 --> 00:05:38,820
interestingly the success of outer bound

130
00:05:38,820 --> 00:05:41,759
access exploits aiming to override other

131
00:05:41,759 --> 00:05:44,580
objects is fully determined by its hip

132
00:05:44,580 --> 00:05:46,560
layout preparation step

133
00:05:46,560 --> 00:05:49,620
in other words their success is fully

134
00:05:49,620 --> 00:05:51,600
determined before even triggering the

135
00:05:51,600 --> 00:05:53,699
vulnerability

136
00:05:53,699 --> 00:05:56,580
for out-of-bound Access exploits aiming

137
00:05:56,580 --> 00:05:59,220
to hijack the free list they can fail

138
00:05:59,220 --> 00:06:00,900
after triggering the vulnerability

139
00:06:00,900 --> 00:06:03,539
because they need to restore the

140
00:06:03,539 --> 00:06:06,000
corrupted allocator

141
00:06:06,000 --> 00:06:08,220
we call these time windows that

142
00:06:08,220 --> 00:06:10,800
determine the XY success the critical

143
00:06:10,800 --> 00:06:12,060
phases

144
00:06:12,060 --> 00:06:13,800
they are highlighted in red in this

145
00:06:13,800 --> 00:06:15,979
model

146
00:06:16,440 --> 00:06:19,800
in fact we discovered that there are two

147
00:06:19,800 --> 00:06:21,660
types of critical phases

148
00:06:21,660 --> 00:06:24,419
we call them slot critical and a locator

149
00:06:24,419 --> 00:06:26,039
critical

150
00:06:26,039 --> 00:06:28,740
a hip based kernel exploit has a Target

151
00:06:28,740 --> 00:06:31,319
slot that it needs to occupy to be

152
00:06:31,319 --> 00:06:32,699
successful

153
00:06:32,699 --> 00:06:35,039
for example in out of bound access

154
00:06:35,039 --> 00:06:38,160
exploits when the vulnerable object is

155
00:06:38,160 --> 00:06:41,340
allocated the adjacent free slot becomes

156
00:06:41,340 --> 00:06:43,080
the target slot

157
00:06:43,080 --> 00:06:45,660
if the target slot is accidentally

158
00:06:45,660 --> 00:06:48,180
occupied by other objects

159
00:06:48,180 --> 00:06:51,000
the kernel of my crashes after the

160
00:06:51,000 --> 00:06:53,039
Overflow

161
00:06:53,039 --> 00:06:55,860
for exploits that corrupt the allocator

162
00:06:55,860 --> 00:06:58,020
they need to restore the allocator back

163
00:06:58,020 --> 00:07:00,960
to its normal state to be successful

164
00:07:00,960 --> 00:07:04,860
for example in a double free exploits it

165
00:07:04,860 --> 00:07:07,319
wraps the linearly linked free list into

166
00:07:07,319 --> 00:07:08,639
a loop

167
00:07:08,639 --> 00:07:10,680
when the kernel tries to use the free

168
00:07:10,680 --> 00:07:13,080
list it will detect the anomaly and

169
00:07:13,080 --> 00:07:14,880
crashes

170
00:07:14,880 --> 00:07:17,280
so these are the phases when exploits

171
00:07:17,280 --> 00:07:20,160
can fail now the question is what is

172
00:07:20,160 --> 00:07:23,220
exactly causing the failures such as

173
00:07:23,220 --> 00:07:26,780
obtaining the target slot

174
00:07:27,120 --> 00:07:30,240
we concluded four factors for exploit

175
00:07:30,240 --> 00:07:34,080
failures as expected a non-initial heap

176
00:07:34,080 --> 00:07:36,720
layout can fail exploits that require

177
00:07:36,720 --> 00:07:39,240
known Heap layout

178
00:07:39,240 --> 00:07:42,900
and unexpected Heap usage from other

179
00:07:42,900 --> 00:07:45,720
processes or kernel components can fail

180
00:07:45,720 --> 00:07:47,880
exploits as well

181
00:07:47,880 --> 00:07:50,520
besides we found out that the scheduler

182
00:07:50,520 --> 00:07:53,280
which causes task migration and the

183
00:07:53,280 --> 00:07:55,740
delayed operations in Linux kernel which

184
00:07:55,740 --> 00:07:58,080
causes unpredictable unpredictable

185
00:07:58,080 --> 00:08:00,720
corruption timing also contribute to

186
00:08:00,720 --> 00:08:03,960
exploit failures

187
00:08:03,960 --> 00:08:07,139
now putting pieces together we have the

188
00:08:07,139 --> 00:08:09,180
full kernel Heap exploit model

189
00:08:09,180 --> 00:08:11,880
based on the model it is intuitive that

190
00:08:11,880 --> 00:08:14,940
actually unreliability is related to the

191
00:08:14,940 --> 00:08:17,220
length of the critical phases

192
00:08:17,220 --> 00:08:19,919
in other words if we can reduce the

193
00:08:19,919 --> 00:08:22,139
length of the critical phase we can

194
00:08:22,139 --> 00:08:25,520
improve exploit reliability

195
00:08:25,800 --> 00:08:28,500
in our study we identified that contact

196
00:08:28,500 --> 00:08:30,720
switch which is how Linux kernel

197
00:08:30,720 --> 00:08:32,880
implements the time sharing mechanism

198
00:08:32,880 --> 00:08:35,820
can significantly prolongs the critical

199
00:08:35,820 --> 00:08:37,140
phases

200
00:08:37,140 --> 00:08:40,440
in a out of bound access exploit if it

201
00:08:40,440 --> 00:08:43,559
happens after the target slot is open

202
00:08:43,559 --> 00:08:46,440
the execution of other processes is

203
00:08:46,440 --> 00:08:48,959
included in the critical phase which

204
00:08:48,959 --> 00:08:51,600
hurts expiry reliability

205
00:08:51,600 --> 00:08:54,120
naturally one way to improve expert

206
00:08:54,120 --> 00:08:56,399
reliability is to avoid contact switch

207
00:08:56,399 --> 00:08:59,820
in critical phases

208
00:08:59,820 --> 00:09:02,279
we achieved it by using the timestamp

209
00:09:02,279 --> 00:09:05,279
counter or TSC for short as the context

210
00:09:05,279 --> 00:09:06,839
switch indicator

211
00:09:06,839 --> 00:09:10,620
TSC is a CPU register that counts Cycles

212
00:09:10,620 --> 00:09:12,120
since boot time

213
00:09:12,120 --> 00:09:15,300
we can read TSC in a loop if it detects

214
00:09:15,300 --> 00:09:18,120
a huge bomb in the TSC value that means

215
00:09:18,120 --> 00:09:21,240
the process is just enter a fresh time

216
00:09:21,240 --> 00:09:22,320
slice

217
00:09:22,320 --> 00:09:24,839
then we can start the exploitation by

218
00:09:24,839 --> 00:09:28,080
allocating two objects of atomically

219
00:09:28,080 --> 00:09:31,560
without context switch in between

220
00:09:31,560 --> 00:09:33,899
we evaluated this technique in two

221
00:09:33,899 --> 00:09:37,019
different workloads as and it is indeed

222
00:09:37,019 --> 00:09:38,100
effective

223
00:09:38,100 --> 00:09:42,260
especially when the system is busy

224
00:09:42,540 --> 00:09:45,300
previously from the model we identified

225
00:09:45,300 --> 00:09:48,480
four unreliability factors in our study

226
00:09:48,480 --> 00:09:51,420
we also notice that each of them can be

227
00:09:51,420 --> 00:09:54,420
mitigated by existing techniques

228
00:09:54,420 --> 00:09:57,480
it seems that unreliability factors are

229
00:09:57,480 --> 00:09:59,519
orthogonal to each other and the

230
00:09:59,519 --> 00:10:01,440
techniques do not conflict with each

231
00:10:01,440 --> 00:10:04,740
other naturally the question will be

232
00:10:04,740 --> 00:10:06,660
what if we combine the techniques

233
00:10:06,660 --> 00:10:08,760
together

234
00:10:08,760 --> 00:10:11,580
to perform the experiment we apply all

235
00:10:11,580 --> 00:10:13,380
the applicable techniques on the

236
00:10:13,380 --> 00:10:15,839
Baseline exploit and obtain the combo

237
00:10:15,839 --> 00:10:17,640
exploit variance

238
00:10:17,640 --> 00:10:21,060
we then evaluated the combo technique

239
00:10:21,060 --> 00:10:23,339
the result shows that the technique

240
00:10:23,339 --> 00:10:25,560
combination derived from our systematic

241
00:10:25,560 --> 00:10:28,320
study outperforms both the Baseline

242
00:10:28,320 --> 00:10:30,480
exploit and the real world exploits

243
00:10:30,480 --> 00:10:33,019
substantially

244
00:10:33,959 --> 00:10:36,839
so in this work we systematically

245
00:10:36,839 --> 00:10:39,180
systematically studied the kernel hip

246
00:10:39,180 --> 00:10:41,160
exploit reliability problem

247
00:10:41,160 --> 00:10:43,560
we proposed a model to explain the

248
00:10:43,560 --> 00:10:46,500
problem and guide future research

249
00:10:46,500 --> 00:10:48,839
we also discovered a new technique and

250
00:10:48,839 --> 00:10:51,000
technique combination to further improve

251
00:10:51,000 --> 00:10:53,579
exploratory reliability

252
00:10:53,579 --> 00:10:56,100
our project is open sourced the

253
00:10:56,100 --> 00:10:58,620
evaluation framework and the exploits

254
00:10:58,620 --> 00:11:01,740
are dockerized you can just run and play

255
00:11:01,740 --> 00:11:03,959
thank you everyone I'm ready to answer

256
00:11:03,959 --> 00:11:06,319
questions

