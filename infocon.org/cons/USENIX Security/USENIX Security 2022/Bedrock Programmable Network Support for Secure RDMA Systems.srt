1
00:00:08,540 --> 00:00:12,360
hello yeah let's get started in this

2
00:00:12,360 --> 00:00:14,400
talk I will show you how to provide

3
00:00:14,400 --> 00:00:16,859
security support for RDMA systems in

4
00:00:16,859 --> 00:00:19,320
programmable Networks

5
00:00:19,320 --> 00:00:21,660
consider a scenario where a local

6
00:00:21,660 --> 00:00:23,880
application is trying to raise some data

7
00:00:23,880 --> 00:00:26,699
in remote memory traditional protocols

8
00:00:26,699 --> 00:00:29,760
like a TCP IP involve the remote CPU to

9
00:00:29,760 --> 00:00:32,579
process the requests so this will incur

10
00:00:32,579 --> 00:00:34,860
actual latency and consume more CPU

11
00:00:34,860 --> 00:00:37,260
Cycles

12
00:00:37,260 --> 00:00:39,780
remote direct memory access or shortly

13
00:00:39,780 --> 00:00:42,660
RDMA enables the local application to

14
00:00:42,660 --> 00:00:44,579
read the remote data or drive the remote

15
00:00:44,579 --> 00:00:49,739
data without CPU involvement

16
00:00:49,739 --> 00:00:52,379
the magic happens in the RDMA enable

17
00:00:52,379 --> 00:00:55,379
unique or arnique which process the RDMA

18
00:00:55,379 --> 00:00:58,079
request and use dma to operate the

19
00:00:58,079 --> 00:01:03,300
application memory with CPU by passing

20
00:01:03,300 --> 00:01:06,840
The Proposal of row kv2 enable RDMA to

21
00:01:06,840 --> 00:01:09,600
run over convert the ethernet and

22
00:01:09,600 --> 00:01:12,060
because of the high performance and easy

23
00:01:12,060 --> 00:01:14,700
deployment many Cloud providers today

24
00:01:14,700 --> 00:01:17,460
have a widely deploy RDMA in their data

25
00:01:17,460 --> 00:01:19,699
centers

26
00:01:20,280 --> 00:01:23,340
but RDMA was initially designed for

27
00:01:23,340 --> 00:01:25,439
private usage with minimal security

28
00:01:25,439 --> 00:01:26,659
support

29
00:01:26,659 --> 00:01:30,360
but as it is increasingly deployed in

30
00:01:30,360 --> 00:01:32,939
multi-tending public clouds RDMA

31
00:01:32,939 --> 00:01:36,360
security has been a concern

32
00:01:36,360 --> 00:01:39,119
recent Studies have revealed a lot of

33
00:01:39,119 --> 00:01:42,060
vulnerabilities in current RDMA systems

34
00:01:42,060 --> 00:01:44,939
including illegal memory access denial

35
00:01:44,939 --> 00:01:47,640
of services side Channel attacks and

36
00:01:47,640 --> 00:01:50,340
many others

37
00:01:50,340 --> 00:01:53,159
these vulnerabilities are caused by the

38
00:01:53,159 --> 00:01:55,079
insufficient RDMA native security

39
00:01:55,079 --> 00:01:56,119
support

40
00:01:56,119 --> 00:01:59,939
RDMA is unencrypted instead it uses very

41
00:01:59,939 --> 00:02:04,320
simple credentials like qpn RK PSN you

42
00:02:04,320 --> 00:02:06,420
don't need to worry about the details of

43
00:02:06,420 --> 00:02:09,479
how these credentials work the idea the

44
00:02:09,479 --> 00:02:11,280
key idea here is that these security

45
00:02:11,280 --> 00:02:13,739
mechanism are not secure enough and they

46
00:02:13,739 --> 00:02:17,280
can be bypassed by the attacker easily

47
00:02:17,280 --> 00:02:20,280
first qpa and arcade they are not

48
00:02:20,280 --> 00:02:22,680
randomly generated

49
00:02:22,680 --> 00:02:25,500
recent Studies have shown that at the

50
00:02:25,500 --> 00:02:27,840
generation of qpnrk has a very

51
00:02:27,840 --> 00:02:29,340
predictable pattern

52
00:02:29,340 --> 00:02:32,099
so this figure shows the arcade value

53
00:02:32,099 --> 00:02:35,580
generated by three different rnics and

54
00:02:35,580 --> 00:02:37,560
as you can see here the arcade values

55
00:02:37,560 --> 00:02:39,540
for different memory regions are just

56
00:02:39,540 --> 00:02:42,720
increased linearly

57
00:02:42,720 --> 00:02:44,879
package sequence number will be

58
00:02:44,879 --> 00:02:48,360
increased by one for every RDMA packet

59
00:02:48,360 --> 00:02:51,840
but many RDMA applications use the fixed

60
00:02:51,840 --> 00:02:53,940
initial value which makes it easier for

61
00:02:53,940 --> 00:02:56,519
attackers to guess the right value for

62
00:02:56,519 --> 00:02:59,519
package injection attacks

63
00:02:59,519 --> 00:03:03,599
and given that PSI and the qpn there are

64
00:03:03,599 --> 00:03:06,599
only 24 bit long so it's possible for

65
00:03:06,599 --> 00:03:09,120
attacker to guess the right value by

66
00:03:09,120 --> 00:03:11,819
enumerating all possibilities

67
00:03:11,819 --> 00:03:14,340
so in summary RDMA native security

68
00:03:14,340 --> 00:03:16,440
support is not enough attacker can

69
00:03:16,440 --> 00:03:19,019
bypass this mechanism to attack RDMA

70
00:03:19,019 --> 00:03:20,580
systems

71
00:03:20,580 --> 00:03:23,819
here is example in this example we have

72
00:03:23,819 --> 00:03:26,040
a victim client and malicious client

73
00:03:26,040 --> 00:03:27,840
they're running on different machines

74
00:03:27,840 --> 00:03:30,959
and they have created RDMA connections

75
00:03:30,959 --> 00:03:34,980
with the same remote RDMA server and in

76
00:03:34,980 --> 00:03:38,099
normal cases an RDMA client can only

77
00:03:38,099 --> 00:03:41,840
access the memory owned by itself

78
00:03:42,060 --> 00:03:45,180
but a tiger can access the memory owned

79
00:03:45,180 --> 00:03:47,819
by the weak team if she successfully

80
00:03:47,819 --> 00:03:49,620
guesses the right value for the

81
00:03:49,620 --> 00:03:52,379
credentials using the vulnerability I

82
00:03:52,379 --> 00:03:55,280
show you on last page

83
00:03:56,159 --> 00:03:58,560
although the attack is not very

84
00:03:58,560 --> 00:04:01,440
complicated addressing the underlying

85
00:04:01,440 --> 00:04:03,659
security issues in the RDMA system is

86
00:04:03,659 --> 00:04:06,180
very challenging there are two possible

87
00:04:06,180 --> 00:04:08,819
solutions on end host first we can

88
00:04:08,819 --> 00:04:11,700
redesign the RDMA protocol or the early

89
00:04:11,700 --> 00:04:14,159
Hardware from scratch but new protocol

90
00:04:14,159 --> 00:04:15,959
and the new hardware they are not

91
00:04:15,959 --> 00:04:18,298
available yet and it will take long time

92
00:04:18,298 --> 00:04:20,880
for them to come out but even if they

93
00:04:20,880 --> 00:04:23,940
are ready in the future it still

94
00:04:23,940 --> 00:04:26,400
requires intrusive changes of exiting

95
00:04:26,400 --> 00:04:29,840
REM systems to deploy them

96
00:04:30,180 --> 00:04:33,419
we can also use a software approach for

97
00:04:33,419 --> 00:04:35,340
example we can deploy software security

98
00:04:35,340 --> 00:04:38,400
patches on remote CPUs but this will

99
00:04:38,400 --> 00:04:42,560
negate the benefits of CPU by passing

100
00:04:43,380 --> 00:04:46,020
to address this problem in this work we

101
00:04:46,020 --> 00:04:49,440
proposed a barrock Bedrock takes a very

102
00:04:49,440 --> 00:04:52,560
different approach it keeps the in-host

103
00:04:52,560 --> 00:04:54,720
untouched and the pro wise security

104
00:04:54,720 --> 00:04:58,160
support in the network

105
00:04:58,500 --> 00:05:01,500
buy rock is a platform with several

106
00:05:01,500 --> 00:05:03,600
security services so far we have

107
00:05:03,600 --> 00:05:05,880
provided false authentication Access

108
00:05:05,880 --> 00:05:10,080
Control monitoring and logging and it's

109
00:05:10,080 --> 00:05:11,400
not difficult to add more Security

110
00:05:11,400 --> 00:05:13,560
Services following the same approach we

111
00:05:13,560 --> 00:05:16,500
proposed in this work

112
00:05:16,500 --> 00:05:19,199
besides barrock preserves CPU by passing

113
00:05:19,199 --> 00:05:21,720
on the end host and it can be deployed

114
00:05:21,720 --> 00:05:25,520
immediately in today's data centers

115
00:05:26,340 --> 00:05:29,220
the key Ebola of barrock is that today's

116
00:05:29,220 --> 00:05:31,500
networks have become programmable

117
00:05:31,500 --> 00:05:33,419
programmable switches are commercially

118
00:05:33,419 --> 00:05:36,479
available now and they can be programmed

119
00:05:36,479 --> 00:05:39,600
with high-level languages like P4

120
00:05:39,600 --> 00:05:43,080
P4 provides a program parser for us to

121
00:05:43,080 --> 00:05:45,780
extract the RDMA header files which can

122
00:05:45,780 --> 00:05:49,020
be further used as a match keys in mesh

123
00:05:49,020 --> 00:05:51,000
action tables to customize the

124
00:05:51,000 --> 00:05:53,039
processing Logic on the switch

125
00:05:53,039 --> 00:05:55,759
and here is a quick example

126
00:05:55,759 --> 00:05:58,860
this table generates a log for RDMA

127
00:05:58,860 --> 00:06:02,400
request with a certain Q pair numbers

128
00:06:02,400 --> 00:06:06,660
memory addresses and operation code

129
00:06:06,660 --> 00:06:08,880
um people also offers registers for

130
00:06:08,880 --> 00:06:11,460
stated for processing for example we can

131
00:06:11,460 --> 00:06:13,979
use them to measure the traffic racing

132
00:06:13,979 --> 00:06:16,800
by a certain RDMA client to detect the

133
00:06:16,800 --> 00:06:19,699
DDOS attacks

134
00:06:19,740 --> 00:06:22,139
this programmability does not sacrifice

135
00:06:22,139 --> 00:06:24,060
the performance of the switch the switch

136
00:06:24,060 --> 00:06:27,419
can still run at the line speed

137
00:06:27,419 --> 00:06:29,400
because of this benefits programmable

138
00:06:29,400 --> 00:06:31,319
switches have been widely used to build

139
00:06:31,319 --> 00:06:33,000
security defenses for traditional

140
00:06:33,000 --> 00:06:35,819
protocols and in this work we'll use it

141
00:06:35,819 --> 00:06:37,860
to provide security support for RDMA

142
00:06:37,860 --> 00:06:40,560
systems next my colleague ofan will

143
00:06:40,560 --> 00:06:42,960
introduce more implementation details

144
00:06:42,960 --> 00:06:46,340
and their evaluation results

145
00:06:47,160 --> 00:06:49,500
thank you

146
00:06:49,500 --> 00:06:51,780
so let me start with Source

147
00:06:51,780 --> 00:06:54,000
authentication I will use the same

148
00:06:54,000 --> 00:06:56,400
example jalo mentioned earlier but here

149
00:06:56,400 --> 00:06:59,100
I also show the programmable switch and

150
00:06:59,100 --> 00:07:01,380
the ports it's used to connect to the

151
00:07:01,380 --> 00:07:03,240
clients

152
00:07:03,240 --> 00:07:06,000
in this scenario the attack the attacker

153
00:07:06,000 --> 00:07:08,479
needs to spoof the victim's Source IP

154
00:07:08,479 --> 00:07:12,000
qpn and other request metadata

155
00:07:12,000 --> 00:07:15,539
our key idea to defend against this

156
00:07:15,539 --> 00:07:18,660
attack is to utilize the invariance for

157
00:07:18,660 --> 00:07:21,900
Naval infrastructure that is beyond the

158
00:07:21,900 --> 00:07:23,940
attacker's control

159
00:07:23,940 --> 00:07:26,340
this is possible because we assume a

160
00:07:26,340 --> 00:07:30,539
cloud setup where a network is trusted

161
00:07:30,539 --> 00:07:33,300
therefore even if the attacker can

162
00:07:33,300 --> 00:07:35,460
support the IP address she cannot

163
00:07:35,460 --> 00:07:38,039
control which Port the package will be

164
00:07:38,039 --> 00:07:39,840
received

165
00:07:39,840 --> 00:07:42,240
with programmable switch we can further

166
00:07:42,240 --> 00:07:45,479
create a mapping table matching on this

167
00:07:45,479 --> 00:07:47,819
invariants including Source IP and

168
00:07:47,819 --> 00:07:50,160
incoming port

169
00:07:50,160 --> 00:07:53,819
every RDMA request pacing by therefore

170
00:07:53,819 --> 00:07:56,960
must hit an entry on this table if not

171
00:07:56,960 --> 00:08:00,859
they will be dropped

172
00:08:01,259 --> 00:08:03,780
this technique can work very well if the

173
00:08:03,780 --> 00:08:06,240
attacker is on a different machine but

174
00:08:06,240 --> 00:08:08,460
when the attacker is on the same machine

175
00:08:08,460 --> 00:08:11,520
as the victim

176
00:08:11,520 --> 00:08:13,500
she uh

177
00:08:13,500 --> 00:08:15,660
layer package will share the same

178
00:08:15,660 --> 00:08:17,880
incoming port on the switch

179
00:08:17,880 --> 00:08:20,699
so we need to further obtain other

180
00:08:20,699 --> 00:08:23,120
invariants from qpair initialization

181
00:08:23,120 --> 00:08:26,639
using an ebpf module

182
00:08:26,639 --> 00:08:29,460
you can find more detail in the paper on

183
00:08:29,460 --> 00:08:31,698
this

184
00:08:31,919 --> 00:08:34,440
another important feature of bayrock is

185
00:08:34,440 --> 00:08:36,360
SS control

186
00:08:36,360 --> 00:08:38,399
this figure here

187
00:08:38,399 --> 00:08:41,520
shows an SS control Loop SS control rule

188
00:08:41,520 --> 00:08:44,039
which specifies the start address and

189
00:08:44,039 --> 00:08:47,279
the address of an SS accessible memory

190
00:08:47,279 --> 00:08:48,240
range

191
00:08:48,240 --> 00:08:50,279
it also specifies the permitted

192
00:08:50,279 --> 00:08:52,860
operation for late range in this case

193
00:08:52,860 --> 00:08:55,200
read only

194
00:08:55,200 --> 00:08:58,920
if a request has long range or the wrong

195
00:08:58,920 --> 00:09:02,519
operation we should reject this request

196
00:09:02,519 --> 00:09:04,620
to enforce such rule

197
00:09:04,620 --> 00:09:06,600
we need to determine the containing

198
00:09:06,600 --> 00:09:09,779
relationship of the two ranges one is

199
00:09:09,779 --> 00:09:11,820
from the request and the other is

200
00:09:11,820 --> 00:09:15,360
specified by the RDMA application

201
00:09:15,360 --> 00:09:18,420
in other words we need to ensure the

202
00:09:18,420 --> 00:09:20,700
start address and the A and end address

203
00:09:20,700 --> 00:09:24,839
of the request are in the inside the

204
00:09:24,839 --> 00:09:28,260
range of the SS control rule

205
00:09:28,260 --> 00:09:31,320
we implement this mechanism using people

206
00:09:31,320 --> 00:09:34,320
language as a table like this

207
00:09:34,320 --> 00:09:37,560
as you can see we use range matching on

208
00:09:37,560 --> 00:09:41,479
the two address field of the request

209
00:09:42,420 --> 00:09:45,120
an important challenge of Access Control

210
00:09:45,120 --> 00:09:46,800
is Hardware limit

211
00:09:46,800 --> 00:09:49,980
for example a switch can only

212
00:09:49,980 --> 00:09:52,320
do range matching with a certain number

213
00:09:52,320 --> 00:09:54,959
of bits per field for example 20 bits

214
00:09:54,959 --> 00:09:59,519
but an address field has 48 bits so we

215
00:09:59,519 --> 00:10:02,279
need to partition this field into three

216
00:10:02,279 --> 00:10:06,480
smaller segments each with 16 bits

217
00:10:06,480 --> 00:10:08,820
another Hardware limit is

218
00:10:08,820 --> 00:10:12,300
that range matching consumes too much

219
00:10:12,300 --> 00:10:13,920
switch resource

220
00:10:13,920 --> 00:10:16,740
so we further derive three rule

221
00:10:16,740 --> 00:10:18,600
compression techniques

222
00:10:18,600 --> 00:10:20,399
that can

223
00:10:20,399 --> 00:10:22,560
further optimize the usage of switch

224
00:10:22,560 --> 00:10:24,920
results

225
00:10:25,500 --> 00:10:28,080
finally beta also supports monitoring

226
00:10:28,080 --> 00:10:29,459
and logging

227
00:10:29,459 --> 00:10:32,399
with programmability on data paths beta

228
00:10:32,399 --> 00:10:35,160
can provide visibility to RDMA request

229
00:10:35,160 --> 00:10:37,860
processing even when the server CPU is

230
00:10:37,860 --> 00:10:39,060
bypassed

231
00:10:39,060 --> 00:10:42,979
you can find more details in the paper

232
00:10:43,500 --> 00:10:46,740
next let's see how Bedrock performs we

233
00:10:46,740 --> 00:10:49,380
set out a test bed with melanox needs

234
00:10:49,380 --> 00:10:53,279
and a turvino switch in this testbed we

235
00:10:53,279 --> 00:10:55,620
run nine different attacks which can

236
00:10:55,620 --> 00:10:58,620
happen in traditional RDMA systems but

237
00:10:58,620 --> 00:11:00,899
here with spray Rock we can mitigate all

238
00:11:00,899 --> 00:11:03,260
of them

239
00:11:04,800 --> 00:11:06,720
to further maximize the security

240
00:11:06,720 --> 00:11:09,660
benefits of bayrock we also have several

241
00:11:09,660 --> 00:11:12,420
optimization techniques to increase the

242
00:11:12,420 --> 00:11:14,880
number of ss control rules

243
00:11:14,880 --> 00:11:17,279
we evaluate paragraph with and without

244
00:11:17,279 --> 00:11:19,980
these techniques on several workloads

245
00:11:19,980 --> 00:11:22,800
and here is the result

246
00:11:22,800 --> 00:11:25,860
as you can see beta can achieve up to

247
00:11:25,860 --> 00:11:29,339
seven times more SS control rules after

248
00:11:29,339 --> 00:11:32,300
the optimizations

249
00:11:32,459 --> 00:11:35,060
in the paper we also have several

250
00:11:35,060 --> 00:11:37,860
evaluation on payroll's performance and

251
00:11:37,860 --> 00:11:40,320
overhead you can find more detail in the

252
00:11:40,320 --> 00:11:42,360
paper

253
00:11:42,360 --> 00:11:45,360
in conclusion motivated by recent

254
00:11:45,360 --> 00:11:48,540
discoveries on RDMA vulnerabilities

255
00:11:48,540 --> 00:11:50,940
we took the opportunity of programmable

256
00:11:50,940 --> 00:11:52,800
switches

257
00:11:52,800 --> 00:11:55,920
to propose and in Network rdms Security

258
00:11:55,920 --> 00:11:57,540
Suite

259
00:11:57,540 --> 00:12:00,120
which can support full effective

260
00:12:00,120 --> 00:12:02,839
security Primitives and is Deployable

261
00:12:02,839 --> 00:12:05,220
immediately and extensible against

262
00:12:05,220 --> 00:12:07,260
future attacks

263
00:12:07,260 --> 00:12:09,480
our evaluation shows that payroll can

264
00:12:09,480 --> 00:12:12,779
mitigate up to 9 RDMA attacks with

265
00:12:12,779 --> 00:12:14,459
minimal overhead

266
00:12:14,459 --> 00:12:17,040
with this I conclude this talk thank you

267
00:12:17,040 --> 00:12:20,839
and we are happy to take any questions

