1
00:00:01,199 --> 00:00:04,199
foreign

2
00:00:08,540 --> 00:00:11,400
thank you for attending my talk my name

3
00:00:11,400 --> 00:00:13,440
is Muhammad Ismail and today uh the

4
00:00:13,440 --> 00:00:14,759
present this is the presentation of our

5
00:00:14,759 --> 00:00:16,500
work title tightly seal your sensitive

6
00:00:16,500 --> 00:00:18,840
pointers with pactites this is Joint

7
00:00:18,840 --> 00:00:20,460
work with Andrew quach Christopher

8
00:00:20,460 --> 00:00:22,680
yosnianski Young Jin Jang and Chang

9
00:00:22,680 --> 00:00:24,240
gumin

10
00:00:24,240 --> 00:00:26,100
so arm processors have been increasing

11
00:00:26,100 --> 00:00:28,199
in popularity in recent years due to

12
00:00:28,199 --> 00:00:30,000
their entrance into the desktop and Data

13
00:00:30,000 --> 00:00:32,700
Center Market this expansion exposes R

14
00:00:32,700 --> 00:00:35,399
more than ever to security attacks and

15
00:00:35,399 --> 00:00:36,840
thus it's becoming increasingly

16
00:00:36,840 --> 00:00:38,579
important to have effective and

17
00:00:38,579 --> 00:00:40,500
efficient defenses for arm in these new

18
00:00:40,500 --> 00:00:42,059
environments

19
00:00:42,059 --> 00:00:44,040
many of these security attacks are due

20
00:00:44,040 --> 00:00:46,260
to memory corruption vulnerabilities in

21
00:00:46,260 --> 00:00:47,879
a study done by Microsoft on its

22
00:00:47,879 --> 00:00:49,920
products they reported that 70 percent

23
00:00:49,920 --> 00:00:52,260
of all security bugs found were due to

24
00:00:52,260 --> 00:00:54,600
memory safety issues and 30 percent of

25
00:00:54,600 --> 00:00:56,879
bugs in Google's open source were memory

26
00:00:56,879 --> 00:00:58,739
safety bugs

27
00:00:58,739 --> 00:01:00,000
so let's take a look at some background

28
00:01:00,000 --> 00:01:01,680
and related work and I'll start with

29
00:01:01,680 --> 00:01:04,140
some attacks here I will introduce two

30
00:01:04,140 --> 00:01:06,180
attacks based on violating memory safety

31
00:01:06,180 --> 00:01:08,040
control flow hijacking and news after

32
00:01:08,040 --> 00:01:10,380
free attacks control flow hijacking

33
00:01:10,380 --> 00:01:13,020
attacks aim to maliciously change the

34
00:01:13,020 --> 00:01:15,600
legitimate control flow of a program and

35
00:01:15,600 --> 00:01:17,040
this can be done either by corrupting

36
00:01:17,040 --> 00:01:19,979
indirect calls or jumps or corrupting

37
00:01:19,979 --> 00:01:22,439
return addresses and this allows the

38
00:01:22,439 --> 00:01:24,479
adversary to execute an illegitimate

39
00:01:24,479 --> 00:01:26,700
control flow transfer that can reach for

40
00:01:26,700 --> 00:01:28,320
example a system call

41
00:01:28,320 --> 00:01:30,840
use after free attacks are temporal

42
00:01:30,840 --> 00:01:33,000
attacks aim to exploit the incorrect use

43
00:01:33,000 --> 00:01:35,880
of dynamic memory a pointer is allocated

44
00:01:35,880 --> 00:01:37,860
on the Heap and can be used legitimately

45
00:01:37,860 --> 00:01:40,200
by the program and when the memory is

46
00:01:40,200 --> 00:01:42,600
freed the pointer becomes dangling and

47
00:01:42,600 --> 00:01:46,020
can be exploited by an attacker

48
00:01:46,020 --> 00:01:47,820
to help combat abusing pointers

49
00:01:47,820 --> 00:01:49,979
arm-released pointer Authentication

50
00:01:49,979 --> 00:01:51,659
pointer authentication relies on

51
00:01:51,659 --> 00:01:54,420
utilizing the unused bits of a 64-bit

52
00:01:54,420 --> 00:01:56,820
pointer to store a pointer

53
00:01:56,820 --> 00:01:59,280
authentication code or a pack it's a

54
00:01:59,280 --> 00:02:00,899
that is generated by a cryptographic

55
00:02:00,899 --> 00:02:02,280
hash function

56
00:02:02,280 --> 00:02:04,740
the pack cannot be calculated without a

57
00:02:04,740 --> 00:02:06,479
secret key and this allows the pointer

58
00:02:06,479 --> 00:02:09,000
to be signed by this pack and thus the

59
00:02:09,000 --> 00:02:11,099
pack needs to be properly removed or

60
00:02:11,099 --> 00:02:13,020
authenticated before the pointer can be

61
00:02:13,020 --> 00:02:15,200
used

62
00:02:15,599 --> 00:02:17,819
so how does this mechanism work there

63
00:02:17,819 --> 00:02:20,220
are two main Primitives the first is the

64
00:02:20,220 --> 00:02:22,620
signing of the pointer the cryptographic

65
00:02:22,620 --> 00:02:25,500
hash algorithm takes a secret key the

66
00:02:25,500 --> 00:02:27,420
pointer and the modifier which is

67
00:02:27,420 --> 00:02:29,040
provided by the program

68
00:02:29,040 --> 00:02:31,440
and the secret key is initialized by the

69
00:02:31,440 --> 00:02:33,780
kernel and stored in a register the

70
00:02:33,780 --> 00:02:35,819
algorithm then computes the pack and

71
00:02:35,819 --> 00:02:37,920
places it on top of the pointer

72
00:02:37,920 --> 00:02:39,540
then when a pointer needs to be

73
00:02:39,540 --> 00:02:41,819
authenticated the algorithm takes the

74
00:02:41,819 --> 00:02:44,340
same exact inputs again and regenerates

75
00:02:44,340 --> 00:02:45,480
the pack

76
00:02:45,480 --> 00:02:47,340
if the pack matches then the pack is

77
00:02:47,340 --> 00:02:48,959
removed from the pointer and the pointer

78
00:02:48,959 --> 00:02:50,640
can be used

79
00:02:50,640 --> 00:02:53,459
however if the authentication fails the

80
00:02:53,459 --> 00:02:55,500
top two bits of the pointer are flipped

81
00:02:55,500 --> 00:02:57,480
thus rendering the pointer to be

82
00:02:57,480 --> 00:03:00,060
unusable any change in any of the

83
00:03:00,060 --> 00:03:01,800
components passed to the cryptographic

84
00:03:01,800 --> 00:03:03,599
algorithm will result in a different

85
00:03:03,599 --> 00:03:07,019
pack and thus a failed Authentication

86
00:03:07,019 --> 00:03:08,580
there have been several defenses

87
00:03:08,580 --> 00:03:10,379
proposed very recently that utilize

88
00:03:10,379 --> 00:03:12,480
pointer authentication I'll quickly go

89
00:03:12,480 --> 00:03:14,220
over their main points of interest but

90
00:03:14,220 --> 00:03:16,140
this is pretty simplified so please read

91
00:03:16,140 --> 00:03:17,519
the respective papers for the full

92
00:03:17,519 --> 00:03:19,739
technical details

93
00:03:19,739 --> 00:03:22,260
the first one is part CFI which offers

94
00:03:22,260 --> 00:03:23,940
forward and backward edge control flow

95
00:03:23,940 --> 00:03:26,580
protection its modifier is the stack

96
00:03:26,580 --> 00:03:28,260
pointer with the function ID for return

97
00:03:28,260 --> 00:03:30,720
addresses and a type ID for indirect

98
00:03:30,720 --> 00:03:32,340
code pointers

99
00:03:32,340 --> 00:03:34,500
next we have pack stack a defense

100
00:03:34,500 --> 00:03:36,060
mechanism that protects the backward

101
00:03:36,060 --> 00:03:38,220
Edge its modifier is the previous

102
00:03:38,220 --> 00:03:41,700
chained return address on the stack

103
00:03:41,700 --> 00:03:43,739
and last we have PT auth which is a

104
00:03:43,739 --> 00:03:45,120
temporal defense mechanism for

105
00:03:45,120 --> 00:03:46,739
protecting against dynamic memory

106
00:03:46,739 --> 00:03:49,379
attacks its modifier is a generated

107
00:03:49,379 --> 00:03:51,780
object ID for each for each Heap object

108
00:03:51,780 --> 00:03:52,980
allocated

109
00:03:52,980 --> 00:03:55,440
and one quick observation in these

110
00:03:55,440 --> 00:03:57,120
defenses is that they put a lot of

111
00:03:57,120 --> 00:03:59,040
emphasis on the modifier and thus this

112
00:03:59,040 --> 00:04:01,920
showcases its importance

113
00:04:01,920 --> 00:04:03,959
there are limitations present in the

114
00:04:03,959 --> 00:04:06,120
current state of the art one limitation

115
00:04:06,120 --> 00:04:08,099
is the Reliance on a modifier that can

116
00:04:08,099 --> 00:04:10,439
be repeated this means that attackers

117
00:04:10,439 --> 00:04:13,319
can reuse the packs that are generated

118
00:04:13,319 --> 00:04:15,420
another limitation is needing a forward

119
00:04:15,420 --> 00:04:18,298
Edge CFI technique to be present so that

120
00:04:18,298 --> 00:04:19,620
the attacker cannot skip the

121
00:04:19,620 --> 00:04:21,000
instrumentation

122
00:04:21,000 --> 00:04:22,680
and another limitation of some

123
00:04:22,680 --> 00:04:24,419
techniques is the Reliance on a weaker

124
00:04:24,419 --> 00:04:27,060
threat model with only arbitrary read so

125
00:04:27,060 --> 00:04:29,100
the attacker must not have arbitrary

126
00:04:29,100 --> 00:04:31,320
with only arbitrary right I'm sorry the

127
00:04:31,320 --> 00:04:33,300
attacker must not have arbitrary reads

128
00:04:33,300 --> 00:04:35,460
for the defense to be viable

129
00:04:35,460 --> 00:04:37,020
there are many limitations in the

130
00:04:37,020 --> 00:04:38,520
current state of the art with plenty of

131
00:04:38,520 --> 00:04:40,380
room for improvement

132
00:04:40,380 --> 00:04:42,660
so now I'll introduce our solution pack

133
00:04:42,660 --> 00:04:44,160
types

134
00:04:44,160 --> 00:04:46,500
So based on the limitations I mentioned

135
00:04:46,500 --> 00:04:49,259
we identified three security properties

136
00:04:49,259 --> 00:04:52,259
in pointers that if enforced completely

137
00:04:52,259 --> 00:04:54,840
protect pointers from being abused

138
00:04:54,840 --> 00:04:57,419
and they are unforgeability in which a

139
00:04:57,419 --> 00:04:59,340
pointer must always point to its

140
00:04:59,340 --> 00:05:00,919
legitimate objects

141
00:05:00,919 --> 00:05:03,419
non-copyability meaning a pointer can't

142
00:05:03,419 --> 00:05:06,000
be used at a location other than its

143
00:05:06,000 --> 00:05:08,820
legitimate one and finally non-bangling

144
00:05:08,820 --> 00:05:10,800
meaning that a pointer cannot be used

145
00:05:10,800 --> 00:05:12,800
after its object has been freed

146
00:05:12,800 --> 00:05:15,120
enforcing these three properties tightly

147
00:05:15,120 --> 00:05:18,180
seals the pointers from illegal use

148
00:05:18,180 --> 00:05:20,699
so let's take a closer look now at the

149
00:05:20,699 --> 00:05:23,340
three properties to better Define them

150
00:05:23,340 --> 00:05:25,139
starting with forgibility forgeability

151
00:05:25,139 --> 00:05:27,000
means that a pointer that points to a

152
00:05:27,000 --> 00:05:29,160
specific object becomes corrupted with a

153
00:05:29,160 --> 00:05:30,660
forged pointer that points to another

154
00:05:30,660 --> 00:05:33,660
objects and copyability means that a

155
00:05:33,660 --> 00:05:35,820
maliciously copied pointer can still be

156
00:05:35,820 --> 00:05:38,820
legitimately used to point to an object

157
00:05:38,820 --> 00:05:41,220
and dangling means that the pointer of a

158
00:05:41,220 --> 00:05:43,979
freed or re-alloc object still points to

159
00:05:43,979 --> 00:05:45,600
that object and can be used by an

160
00:05:45,600 --> 00:05:47,280
attacker

161
00:05:47,280 --> 00:05:49,740
powerful memory corruption attacks are a

162
00:05:49,740 --> 00:05:51,539
direct implication of violating these

163
00:05:51,539 --> 00:05:53,520
three properties and an attacker can

164
00:05:53,520 --> 00:05:55,919
generate packs with forgeability they

165
00:05:55,919 --> 00:05:57,900
can reuse pack they can reuse valid

166
00:05:57,900 --> 00:05:59,940
pointers with copyability and they can

167
00:05:59,940 --> 00:06:03,419
reuse invalid pointers with dangling

168
00:06:03,419 --> 00:06:05,400
the importance of these properties stems

169
00:06:05,400 --> 00:06:07,020
from the fact that in order to hijack

170
00:06:07,020 --> 00:06:09,120
control flow at least one of these

171
00:06:09,120 --> 00:06:11,039
properties must be violated based on our

172
00:06:11,039 --> 00:06:13,860
analysis and so peptide seals a point

173
00:06:13,860 --> 00:06:15,840
sulfactite seals pointers and guarantees

174
00:06:15,840 --> 00:06:18,060
that they cannot be misused pactlite

175
00:06:18,060 --> 00:06:19,560
also overcomes the limitations of

176
00:06:19,560 --> 00:06:21,960
previous approaches the non-copyability

177
00:06:21,960 --> 00:06:24,780
property prevents any Packer use pactide

178
00:06:24,780 --> 00:06:26,880
protects all globals stack and Heap

179
00:06:26,880 --> 00:06:28,020
variables

180
00:06:28,020 --> 00:06:30,120
and pactate assumes a strong threat

181
00:06:30,120 --> 00:06:31,800
model with arbitrary read write

182
00:06:31,800 --> 00:06:33,600
capabilities

183
00:06:33,600 --> 00:06:35,520
next let's take a closer look into the

184
00:06:35,520 --> 00:06:36,660
design

185
00:06:36,660 --> 00:06:38,639
so how will pack that enforce the three

186
00:06:38,639 --> 00:06:40,800
properties pack that relies on the

187
00:06:40,800 --> 00:06:43,380
pointer authentication modifier and this

188
00:06:43,380 --> 00:06:45,180
modifier is used by the cryptographic

189
00:06:45,180 --> 00:06:47,160
hash algorithm to generate the pack as I

190
00:06:47,160 --> 00:06:49,199
mentioned and the reason we rely on it

191
00:06:49,199 --> 00:06:50,819
is that it's controlled and can be made

192
00:06:50,819 --> 00:06:53,520
complex enough to generate a unique pack

193
00:06:53,520 --> 00:06:56,400
any modification to it or the pointer

194
00:06:56,400 --> 00:06:58,800
would result in a violation

195
00:06:58,800 --> 00:07:02,039
so pactite Blends the address of the

196
00:07:02,039 --> 00:07:04,500
pointer Ampersand p and the unique

197
00:07:04,500 --> 00:07:07,020
random tag generated by the pactide

198
00:07:07,020 --> 00:07:09,419
compiler and associated with the memory

199
00:07:09,419 --> 00:07:13,080
object to enforce the three properties

200
00:07:13,080 --> 00:07:16,020
so for signing we incorporate these

201
00:07:16,020 --> 00:07:18,000
elements into the modifier so the

202
00:07:18,000 --> 00:07:19,860
cryptographic algorithm modifier takes

203
00:07:19,860 --> 00:07:22,259
the location of the pointer and the red

204
00:07:22,259 --> 00:07:25,440
and the random tag

205
00:07:25,440 --> 00:07:27,840
and the same way for authentication as

206
00:07:27,840 --> 00:07:30,000
can be seen to regenerate the pack

207
00:07:30,000 --> 00:07:33,419
successfully so now I'll explain how

208
00:07:33,419 --> 00:07:35,759
this choice of a modifier enforces the

209
00:07:35,759 --> 00:07:37,620
three properties

210
00:07:37,620 --> 00:07:40,080
starting with unforgibility the pack

211
00:07:40,080 --> 00:07:42,720
mechanism on itself includes the pointer

212
00:07:42,720 --> 00:07:44,460
as one of the inputs to generate the

213
00:07:44,460 --> 00:07:47,819
pack and thus a forged pointer would

214
00:07:47,819 --> 00:07:50,460
trigger a fault on authentication due to

215
00:07:50,460 --> 00:07:52,259
the pointer having a different value

216
00:07:52,259 --> 00:07:56,160
from the one that was used for that pack

217
00:07:56,160 --> 00:07:58,680
and then for non-copyability the

218
00:07:58,680 --> 00:08:00,479
location of the pointer being included

219
00:08:00,479 --> 00:08:03,180
as part of the modifier means that any

220
00:08:03,180 --> 00:08:05,220
copied pointer will generate a different

221
00:08:05,220 --> 00:08:07,979
pack on authentication due to a

222
00:08:07,979 --> 00:08:10,680
different Ampersand P thus resulting in

223
00:08:10,680 --> 00:08:13,440
a in a mismatch on Authentication

224
00:08:13,440 --> 00:08:15,419
this means that a pointer can only be

225
00:08:15,419 --> 00:08:16,740
used at its legitimate location

226
00:08:16,740 --> 00:08:19,680
enforcing the second property

227
00:08:19,680 --> 00:08:21,599
to enforce the non-dangling property

228
00:08:21,599 --> 00:08:23,639
pactite assigns a random tag to the

229
00:08:23,639 --> 00:08:25,979
pointer this random tag is generated

230
00:08:25,979 --> 00:08:28,080
upon allocation and changes when an

231
00:08:28,080 --> 00:08:30,599
object is freed or reallocated thus

232
00:08:30,599 --> 00:08:32,458
allowing the life cycle of the object to

233
00:08:32,458 --> 00:08:34,860
be tracked and a dangling pointer being

234
00:08:34,860 --> 00:08:37,620
used will not have a tag

235
00:08:37,620 --> 00:08:39,360
and thus the pack generated all

236
00:08:39,360 --> 00:08:41,760
authentication will not match resulting

237
00:08:41,760 --> 00:08:43,860
in a violation and thus preventing any

238
00:08:43,860 --> 00:08:46,980
misuse of dangling pointers

239
00:08:46,980 --> 00:08:48,540
taking a look at the structure and

240
00:08:48,540 --> 00:08:50,220
overall design pactlite security

241
00:08:50,220 --> 00:08:52,080
properties are used as a framework to

242
00:08:52,080 --> 00:08:53,760
instrument programs and the

243
00:08:53,760 --> 00:08:55,500
instrumentation itself depends on how

244
00:08:55,500 --> 00:08:57,300
broadly the properties will be applied

245
00:08:57,300 --> 00:08:59,940
and pactlite is composed of the pactite

246
00:08:59,940 --> 00:09:01,980
llvm pass that does static analysis on

247
00:09:01,980 --> 00:09:04,560
the llvm IR and instruments the program

248
00:09:04,560 --> 00:09:07,440
with pectites functions the result is an

249
00:09:07,440 --> 00:09:09,839
instrumented and a protected program and

250
00:09:09,839 --> 00:09:11,399
this is a simplified example for the

251
00:09:11,399 --> 00:09:12,660
sake of the presentation but we have

252
00:09:12,660 --> 00:09:15,180
more details in our paper

253
00:09:15,180 --> 00:09:17,160
so next I'll talk about pactite's

254
00:09:17,160 --> 00:09:19,019
defense mechanisms

255
00:09:19,019 --> 00:09:21,360
easily be applied to protect a variety

256
00:09:21,360 --> 00:09:23,220
of pointer types and the pactate

257
00:09:23,220 --> 00:09:25,019
compiler automatically instruments all

258
00:09:25,019 --> 00:09:26,700
the globals stack variables and Heap

259
00:09:26,700 --> 00:09:28,740
variables as I said so we chose to

260
00:09:28,740 --> 00:09:30,360
implement four pack type defense

261
00:09:30,360 --> 00:09:32,399
mechanisms to demonstrate peptide's

262
00:09:32,399 --> 00:09:34,200
versatility and coverage

263
00:09:34,200 --> 00:09:36,120
I'll only be explaining pactite code

264
00:09:36,120 --> 00:09:38,700
pointer Integrity or pactate CPI but

265
00:09:38,700 --> 00:09:40,560
packedite is versatile and can also be

266
00:09:40,560 --> 00:09:42,240
applied to enforce control flow

267
00:09:42,240 --> 00:09:44,640
Integrity to protect C plus v table

268
00:09:44,640 --> 00:09:46,380
pointers and to enforce return address

269
00:09:46,380 --> 00:09:48,720
protection more details on that are in

270
00:09:48,720 --> 00:09:50,339
the paper

271
00:09:50,339 --> 00:09:52,680
so pac.cpi guarantees the three

272
00:09:52,680 --> 00:09:54,660
properties for all sensitive pointers

273
00:09:54,660 --> 00:09:56,880
and in this context sensitive pointers

274
00:09:56,880 --> 00:09:58,740
are all code pointers and all data

275
00:09:58,740 --> 00:10:01,140
pointers that point to code pointers and

276
00:10:01,140 --> 00:10:02,640
the sensitive pointers are authenticated

277
00:10:02,640 --> 00:10:04,560
only at legitimate sensitive sites

278
00:10:04,560 --> 00:10:06,540
otherwise the pointer has a pack on it

279
00:10:06,540 --> 00:10:08,160
and it cannot be used

280
00:10:08,160 --> 00:10:10,800
pactide CPI relies on llvm static

281
00:10:10,800 --> 00:10:13,200
analysis for instrumentation and it

282
00:10:13,200 --> 00:10:15,360
recursively looks inside all elements of

283
00:10:15,360 --> 00:10:18,600
a composite type to guarantee coverage

284
00:10:18,600 --> 00:10:20,700
next we take a look at the evaluation of

285
00:10:20,700 --> 00:10:21,959
pactites

286
00:10:21,959 --> 00:10:23,940
we evaluate pactlide by answering the

287
00:10:23,940 --> 00:10:25,980
following questions how effectively can

288
00:10:25,980 --> 00:10:27,959
pacti prevent not only synthetic attacks

289
00:10:27,959 --> 00:10:30,300
but also real world attacks and how much

290
00:10:30,300 --> 00:10:31,740
performance and memory overhead does

291
00:10:31,740 --> 00:10:33,540
pactate impose

292
00:10:33,540 --> 00:10:35,040
for the sake of time I'll only go

293
00:10:35,040 --> 00:10:36,420
through the performance evaluation but

294
00:10:36,420 --> 00:10:38,220
the full security evaluation is in the

295
00:10:38,220 --> 00:10:39,839
paper

296
00:10:39,839 --> 00:10:41,700
we ran pact tights with three sets of

297
00:10:41,700 --> 00:10:44,760
benchmarks the spec CPU 2006 and bench

298
00:10:44,760 --> 00:10:46,980
and core Mark we also ran one real world

299
00:10:46,980 --> 00:10:49,079
application nginx which is a web server

300
00:10:49,079 --> 00:10:50,820
and the following graph shows our

301
00:10:50,820 --> 00:10:52,140
numbers for the different pact type

302
00:10:52,140 --> 00:10:53,880
defense mechanisms and as can be seen

303
00:10:53,880 --> 00:10:56,339
pactite has low average overhead across

304
00:10:56,339 --> 00:10:57,480
the board

305
00:10:57,480 --> 00:10:59,579
we also evaluated memory overhead of

306
00:10:59,579 --> 00:11:01,980
peptide CPI and on the spec benchmarks

307
00:11:01,980 --> 00:11:05,940
and got a 19 memory overhead on average

308
00:11:05,940 --> 00:11:08,279
and finally I will conclude

309
00:11:08,279 --> 00:11:10,140
I have introduced pactlite which is an

310
00:11:10,140 --> 00:11:11,760
efficient and robust mechanism that

311
00:11:11,760 --> 00:11:13,380
utilizes arms pointer authentication

312
00:11:13,380 --> 00:11:14,880
Primitives to guarantee pointer

313
00:11:14,880 --> 00:11:17,459
Integrity we identified three security

314
00:11:17,459 --> 00:11:20,339
properties that pactlite enforces we

315
00:11:20,339 --> 00:11:22,079
showcased tactite with four defense

316
00:11:22,079 --> 00:11:23,880
mechanisms that protect a wide variety

317
00:11:23,880 --> 00:11:26,339
of security sensitive pointers we also

318
00:11:26,339 --> 00:11:28,260
evaluated pactite against Real World and

319
00:11:28,260 --> 00:11:30,120
synthesized attacks and like I said more

320
00:11:30,120 --> 00:11:32,160
details are in the paper on those and we

321
00:11:32,160 --> 00:11:33,660
showcased that slow overhead on a

322
00:11:33,660 --> 00:11:35,880
variety of benchmarks and we used real

323
00:11:35,880 --> 00:11:37,980
pack instructions

324
00:11:37,980 --> 00:11:40,860
also I spent my PhD during covid and

325
00:11:40,860 --> 00:11:42,720
this is the first in-person conference

326
00:11:42,720 --> 00:11:45,120
that I attend so uh please feel free to

327
00:11:45,120 --> 00:11:46,920
reach out to me and connect I'd be more

328
00:11:46,920 --> 00:11:48,120
than happy to connect with all of you

329
00:11:48,120 --> 00:11:50,459
and thank you very much for listening to

330
00:11:50,459 --> 00:11:52,500
my presentation and I will gladly take

331
00:11:52,500 --> 00:11:54,920
any questions

