1
00:00:07,639 --> 00:00:11,340
I'm wrote from the University of Utah

2
00:00:11,340 --> 00:00:13,620
it's a great pleasure to present our

3
00:00:13,620 --> 00:00:15,599
paper Grand choose for our binary

4
00:00:15,599 --> 00:00:17,520
disassembly is not easy

5
00:00:17,520 --> 00:00:20,460
this is a joint work with chongbin Pang

6
00:00:20,460 --> 00:00:23,640
Tien Tai Zhang and Professor Bing Mao

7
00:00:23,640 --> 00:00:27,060
from 19 University and Professor jinshu

8
00:00:27,060 --> 00:00:30,259
from the University of Utah

9
00:00:32,840 --> 00:00:35,940
so binary disassembly is a process of

10
00:00:35,940 --> 00:00:38,100
translating a binary executable to

11
00:00:38,100 --> 00:00:41,340
assembly file during this process the

12
00:00:41,340 --> 00:00:43,440
disassembler will handle several tasks

13
00:00:43,440 --> 00:00:44,820
include

14
00:00:44,820 --> 00:00:47,219
instruction recovery function start

15
00:00:47,219 --> 00:00:49,500
detection control flow graph

16
00:00:49,500 --> 00:00:51,239
reconstruction

17
00:00:51,239 --> 00:00:53,460
bandwidth assembly is also the core

18
00:00:53,460 --> 00:00:56,399
component of many applications such as

19
00:00:56,399 --> 00:00:58,579
code similarity detection

20
00:00:58,579 --> 00:01:01,860
vulnerability Discovery and binary

21
00:01:01,860 --> 00:01:05,539
Bender code patching

22
00:01:05,640 --> 00:01:07,740
so generating ground shoes for binary

23
00:01:07,740 --> 00:01:10,380
disassembly is very important for

24
00:01:10,380 --> 00:01:12,659
instance many machine learning models

25
00:01:12,659 --> 00:01:15,060
like byteweight relies on the ground

26
00:01:15,060 --> 00:01:17,520
shoes for training purpose on the other

27
00:01:17,520 --> 00:01:20,640
hand if we don't have the this if we

28
00:01:20,640 --> 00:01:22,619
don't have the ground rules for binary

29
00:01:22,619 --> 00:01:24,659
disassembly we won't be able to verify

30
00:01:24,659 --> 00:01:27,119
the disassembly result and the user

31
00:01:27,119 --> 00:01:28,740
won't be able to pick the best

32
00:01:28,740 --> 00:01:31,380
performance disassemblers

33
00:01:31,380 --> 00:01:33,540
although everyone is aware the

34
00:01:33,540 --> 00:01:35,820
importance of ground shoes for binary

35
00:01:35,820 --> 00:01:38,400
disassembly they have less agreement on

36
00:01:38,400 --> 00:01:41,520
the way of generating ground shoes

37
00:01:41,520 --> 00:01:44,159
so here we summarize all the mainstream

38
00:01:44,159 --> 00:01:46,200
approaches of generating ground rules

39
00:01:46,200 --> 00:01:48,540
for bandages assembly

40
00:01:48,540 --> 00:01:51,479
so first is the manual analyze so this

41
00:01:51,479 --> 00:01:53,820
approach relies on manually crafted

42
00:01:53,820 --> 00:01:55,079
ground shoes

43
00:01:55,079 --> 00:01:57,720
so the second approach is you're using

44
00:01:57,720 --> 00:02:00,600
the existing disassemblers for instance

45
00:02:00,600 --> 00:02:03,600
some people just borrow the result from

46
00:02:03,600 --> 00:02:06,360
Ida Pro as the ground shoes because it

47
00:02:06,360 --> 00:02:08,459
has the stable performance

48
00:02:08,459 --> 00:02:11,459
on the other hand intermediate compiler

49
00:02:11,459 --> 00:02:13,379
output could also be used for generating

50
00:02:13,379 --> 00:02:16,620
ground shoes for example listing file

51
00:02:16,620 --> 00:02:19,560
generated by the assembler contains the

52
00:02:19,560 --> 00:02:22,020
informations of instruction and this

53
00:02:22,020 --> 00:02:24,120
information could be used for generating

54
00:02:24,120 --> 00:02:25,760
ground shoes

55
00:02:25,760 --> 00:02:28,980
similarly compilation metadata such as

56
00:02:28,980 --> 00:02:31,319
simple and debug info and debug

57
00:02:31,319 --> 00:02:33,360
information could be used in a similar

58
00:02:33,360 --> 00:02:36,599
way and the last approach is tracing

59
00:02:36,599 --> 00:02:39,239
compiling process we will discuss more

60
00:02:39,239 --> 00:02:41,220
detail about this approach in the later

61
00:02:41,220 --> 00:02:43,819
slides

62
00:02:44,340 --> 00:02:46,800
so far we have discussed all the

63
00:02:46,800 --> 00:02:48,660
mainstream approaches of generating

64
00:02:48,660 --> 00:02:51,660
ground shoes to understand the quality

65
00:02:51,660 --> 00:02:53,580
of the ground rules generated by

66
00:02:53,580 --> 00:02:56,400
different approach we will evaluate them

67
00:02:56,400 --> 00:02:58,800
from four aspective

68
00:02:58,800 --> 00:03:01,920
so the first is the Precision and the

69
00:03:01,920 --> 00:03:04,860
second is recall third is generality and

70
00:03:04,860 --> 00:03:07,560
the last one is externability

71
00:03:07,560 --> 00:03:10,080
so the Precision basically reflects the

72
00:03:10,080 --> 00:03:12,480
correctness and recall reflect the

73
00:03:12,480 --> 00:03:13,760
coverage

74
00:03:13,760 --> 00:03:16,379
generality requires the ground truth

75
00:03:16,379 --> 00:03:18,599
approach support various disassembly

76
00:03:18,599 --> 00:03:21,780
tasks such as jump table recovery

77
00:03:21,780 --> 00:03:24,800
control flow recovery and externability

78
00:03:24,800 --> 00:03:27,780
requires the approach can be applied to

79
00:03:27,780 --> 00:03:31,159
multiple architectures

80
00:03:31,440 --> 00:03:34,800
so previously we have no okay um so

81
00:03:34,800 --> 00:03:36,120
let's going back

82
00:03:36,120 --> 00:03:38,159
um so according to this table we can see

83
00:03:38,159 --> 00:03:40,379
all these none of this approach is

84
00:03:40,379 --> 00:03:42,840
actually perfect so for instance running

85
00:03:42,840 --> 00:03:46,140
manuals is not doing well on the recall

86
00:03:46,140 --> 00:03:49,260
uh reusing existing disassembler and its

87
00:03:49,260 --> 00:03:52,440
Improvement on precision and recall uh

88
00:03:52,440 --> 00:03:54,659
relying on intermediate compiler result

89
00:03:54,659 --> 00:03:57,420
or compilation metadata needs

90
00:03:57,420 --> 00:03:59,400
Improvement in the generality and

91
00:03:59,400 --> 00:04:01,620
choosing compilation process needs

92
00:04:01,620 --> 00:04:04,379
Improvement on externability

93
00:04:04,379 --> 00:04:06,959
so as we have seen none of this approach

94
00:04:06,959 --> 00:04:09,360
is perfect so here comes the next

95
00:04:09,360 --> 00:04:12,299
question how is the imperfect ground

96
00:04:12,299 --> 00:04:15,060
truth will influence the disassembly uh

97
00:04:15,060 --> 00:04:17,820
battery disassembly

98
00:04:17,820 --> 00:04:19,738
um so let's begin to answer this

99
00:04:19,738 --> 00:04:21,959
question with the result from a case

100
00:04:21,959 --> 00:04:24,660
study so this table presented the

101
00:04:24,660 --> 00:04:27,000
performance of by the way trained with

102
00:04:27,000 --> 00:04:28,919
ground shoes produced by two different

103
00:04:28,919 --> 00:04:31,979
approaches so the symbol refers to the

104
00:04:31,979 --> 00:04:33,780
ground rules generated based on simple

105
00:04:33,780 --> 00:04:36,540
information and Oracle refers to the

106
00:04:36,540 --> 00:04:39,900
ground shoes used by or sok paper all

107
00:04:39,900 --> 00:04:43,680
you ever want to know about x86 and x64

108
00:04:43,680 --> 00:04:46,139
binary disassembly but were free to ask

109
00:04:46,139 --> 00:04:49,020
so the Oracle is designed based on

110
00:04:49,020 --> 00:04:52,199
intercepting the compiling process

111
00:04:52,199 --> 00:04:55,320
so as we can see from this table there

112
00:04:55,320 --> 00:04:57,960
is an observable differences between the

113
00:04:57,960 --> 00:05:00,960
Precision under the of sighting when bit

114
00:05:00,960 --> 00:05:03,060
wide when byte weight is treated with

115
00:05:03,060 --> 00:05:05,100
two different approaches

116
00:05:05,100 --> 00:05:07,500
so that leads us to the finding the

117
00:05:07,500 --> 00:05:09,840
Fidelity of ground rules of facts

118
00:05:09,840 --> 00:05:13,020
disassembly to design

119
00:05:13,020 --> 00:05:15,600
so we did another experiment by

120
00:05:15,600 --> 00:05:17,940
evaluating this assembler with different

121
00:05:17,940 --> 00:05:19,259
ground shoes

122
00:05:19,259 --> 00:05:21,600
so this table presents the performance

123
00:05:21,600 --> 00:05:24,060
of Dennis on identifying complex

124
00:05:24,060 --> 00:05:26,580
constructs with ground shoes produced by

125
00:05:26,580 --> 00:05:28,620
different approaches

126
00:05:28,620 --> 00:05:31,139
so according to this table Dennis

127
00:05:31,139 --> 00:05:33,660
achieves the perfect performance of

128
00:05:33,660 --> 00:05:35,820
manually crafted ground shoes

129
00:05:35,820 --> 00:05:39,380
it achieves a 100 precision and recall

130
00:05:39,380 --> 00:05:42,780
but this number significantly drops when

131
00:05:42,780 --> 00:05:46,199
we evaluate it based on Oracle

132
00:05:46,199 --> 00:05:48,660
so this lead us to another conclusion

133
00:05:48,660 --> 00:05:51,780
the use of incomplete or in precise

134
00:05:51,780 --> 00:05:54,120
ground shoes will lead to misleading

135
00:05:54,120 --> 00:05:56,720
conclusions

136
00:05:57,720 --> 00:06:00,600
so previously we have presented enough

137
00:06:00,600 --> 00:06:02,699
evidence during that

138
00:06:02,699 --> 00:06:05,280
uh imperfect ground shoes will not only

139
00:06:05,280 --> 00:06:07,860
lead to contradictions but also affect

140
00:06:07,860 --> 00:06:10,620
the disassembly to design so it's very

141
00:06:10,620 --> 00:06:12,539
important to improve the ground shoes

142
00:06:12,539 --> 00:06:14,940
into a better precision

143
00:06:14,940 --> 00:06:17,820
so in this paper we decided to follow

144
00:06:17,820 --> 00:06:20,160
the direction of treason compilation

145
00:06:20,160 --> 00:06:22,319
process because it has the best

146
00:06:22,319 --> 00:06:25,460
potential we can see from this table

147
00:06:25,460 --> 00:06:28,380
Argo has a very good performance on

148
00:06:28,380 --> 00:06:31,800
precision and recall so we decided to

149
00:06:31,800 --> 00:06:34,560
improve to improve article from the

150
00:06:34,560 --> 00:06:37,440
other two aspects so we will first

151
00:06:37,440 --> 00:06:40,380
handle the missing cases in Oracle to

152
00:06:40,380 --> 00:06:42,660
improve the recall and also we will

153
00:06:42,660 --> 00:06:44,639
extern Oracle to support more

154
00:06:44,639 --> 00:06:47,360
architectures

155
00:06:48,240 --> 00:06:50,940
so before we discuss the Improvement we

156
00:06:50,940 --> 00:06:52,979
made I would like to begin the

157
00:06:52,979 --> 00:06:55,319
discussion on how treason compiling

158
00:06:55,319 --> 00:06:57,060
process works

159
00:06:57,060 --> 00:07:00,000
so here according to this table we can

160
00:07:00,000 --> 00:07:03,120
see uh the Oracle will instrument the

161
00:07:03,120 --> 00:07:06,419
GCC front-end the gas assembler and the

162
00:07:06,419 --> 00:07:09,060
gold Linker to insert metadata to the

163
00:07:09,060 --> 00:07:12,240
output at different compilation stages

164
00:07:12,240 --> 00:07:14,880
so the metadata is started into the

165
00:07:14,880 --> 00:07:17,520
object file and the ground shoes will

166
00:07:17,520 --> 00:07:19,560
finally be recovered based on the

167
00:07:19,560 --> 00:07:20,819
metadata

168
00:07:20,819 --> 00:07:23,940
so the internal mechanism for oracle's

169
00:07:23,940 --> 00:07:29,360
design is same for both GCC and Salem

170
00:07:29,940 --> 00:07:33,000
so now let's move on to the first major

171
00:07:33,000 --> 00:07:35,880
Improvement we made so I'd like to begin

172
00:07:35,880 --> 00:07:38,160
the discussion here by answering the

173
00:07:38,160 --> 00:07:40,680
question why there are Corner cases

174
00:07:40,680 --> 00:07:42,900
exist in Oracle

175
00:07:42,900 --> 00:07:45,300
so in the first case the instructions

176
00:07:45,300 --> 00:07:47,699
are failed to be recognized by Oracle

177
00:07:47,699 --> 00:07:51,000
during the assembly process because the

178
00:07:51,000 --> 00:07:53,280
instructions are intentionally encoded

179
00:07:53,280 --> 00:07:55,860
as data by the Developers

180
00:07:55,860 --> 00:07:58,280
so the developers are doing so because

181
00:07:58,280 --> 00:08:01,500
some version of the assembly assembler

182
00:08:01,500 --> 00:08:03,960
may not always support such instructions

183
00:08:03,960 --> 00:08:07,440
so encoded the instruction by row byte

184
00:08:07,440 --> 00:08:09,840
can successfully bypass the assembly

185
00:08:09,840 --> 00:08:12,060
process

186
00:08:12,060 --> 00:08:15,720
so the second example is uh this is the

187
00:08:15,720 --> 00:08:19,379
handwritten assembly code from openssl

188
00:08:19,379 --> 00:08:23,039
so such handwritten such handwritten

189
00:08:23,039 --> 00:08:25,680
assembly function may not always be

190
00:08:25,680 --> 00:08:27,360
properly labeled

191
00:08:27,360 --> 00:08:30,180
so in both of these cases comparatively

192
00:08:30,180 --> 00:08:32,760
is not involved in the process of

193
00:08:32,760 --> 00:08:35,399
generating this assembly code so as a

194
00:08:35,399 --> 00:08:39,240
result Oracle is not able to handle most

195
00:08:39,240 --> 00:08:41,520
of them because intercepting the

196
00:08:41,520 --> 00:08:43,740
compiling process doesn't help in both

197
00:08:43,740 --> 00:08:46,020
cases

198
00:08:46,020 --> 00:08:48,420
so the second major Improvement we made

199
00:08:48,420 --> 00:08:51,300
is to extern Oracle design to more

200
00:08:51,300 --> 00:08:54,180
architectures so the original version of

201
00:08:54,180 --> 00:08:57,540
Oracle only support x86 and x64

202
00:08:57,540 --> 00:08:59,880
boundaries and we externate to support

203
00:08:59,880 --> 00:09:03,660
more architectures including Arms 32 Arc

204
00:09:03,660 --> 00:09:07,860
64 mips 32 and MIP 64.

205
00:09:07,860 --> 00:09:10,440
so during this process when we are

206
00:09:10,440 --> 00:09:12,300
trying to handle to support more

207
00:09:12,300 --> 00:09:14,220
architectures there are also challenges

208
00:09:14,220 --> 00:09:18,480
we need to solve for instance uh while

209
00:09:18,480 --> 00:09:20,760
generating the ground shoes for Arms 32

210
00:09:20,760 --> 00:09:23,279
boundaries we need to keep track of the

211
00:09:23,279 --> 00:09:24,779
execution mode

212
00:09:24,779 --> 00:09:28,260
so to do so we save extra information to

213
00:09:28,260 --> 00:09:32,839
the Mida data for each basic block

214
00:09:33,839 --> 00:09:36,600
so to demonstrate the benefits of or

215
00:09:36,600 --> 00:09:40,320
Improvement to the Oracle design we

216
00:09:40,320 --> 00:09:42,480
evaluate the accuracy of six popular

217
00:09:42,480 --> 00:09:44,940
disassembly tools a recovering jump

218
00:09:44,940 --> 00:09:47,880
table from glibc so this figure

219
00:09:47,880 --> 00:09:51,060
presented the evaluation result

220
00:09:51,060 --> 00:09:54,600
so as we can see here uh in case of the

221
00:09:54,600 --> 00:09:57,600
idle Pro it's performance varies between

222
00:09:57,600 --> 00:09:59,519
the improved version and the original

223
00:09:59,519 --> 00:10:02,700
version and the number is pretty large

224
00:10:02,700 --> 00:10:04,860
over 60 percent

225
00:10:04,860 --> 00:10:07,940
so the key observation here is that or

226
00:10:07,940 --> 00:10:10,860
Improvement to the Oracle helps the

227
00:10:10,860 --> 00:10:13,500
understand of true accuracy of this

228
00:10:13,500 --> 00:10:16,260
assembly tool

229
00:10:16,260 --> 00:10:19,740
so given the better ground shoes we

230
00:10:19,740 --> 00:10:22,140
again evaluate the performance of modern

231
00:10:22,140 --> 00:10:25,320
disassemblers so this figure presented

232
00:10:25,320 --> 00:10:26,940
the Precision of mainstream

233
00:10:26,940 --> 00:10:29,160
disassemblers on binary with different

234
00:10:29,160 --> 00:10:31,939
architectures

235
00:10:31,980 --> 00:10:35,339
um so if so according to this tables we

236
00:10:35,339 --> 00:10:37,339
can see the performance of modern

237
00:10:37,339 --> 00:10:39,839
disassemblers vary across the

238
00:10:39,839 --> 00:10:42,720
architectures uh for instance we can see

239
00:10:42,720 --> 00:10:45,920
object down could easily achieve over 90

240
00:10:45,920 --> 00:10:49,500
accuracy on most of the architectures uh

241
00:10:49,500 --> 00:10:52,100
but its performance significantly drops

242
00:10:52,100 --> 00:10:55,260
on arm32 boundaries

243
00:10:55,260 --> 00:10:58,200
um in fact arm32 usually posed a bigger

244
00:10:58,200 --> 00:11:01,740
challenge than Arc 64 because of the

245
00:11:01,740 --> 00:11:03,420
execution mode

246
00:11:03,420 --> 00:11:06,240
so the second observation comes from the

247
00:11:06,240 --> 00:11:09,060
commercial digital Summers uh if we

248
00:11:09,060 --> 00:11:13,440
looking at the figure C we can see both

249
00:11:13,440 --> 00:11:17,040
B and C we can see uh disassemblers like

250
00:11:17,040 --> 00:11:20,760
Ida Pro and better ninja uh doesn't

251
00:11:20,760 --> 00:11:25,399
doing well on the mips boundaries

252
00:11:26,579 --> 00:11:29,040
so at the very end I would like to share

253
00:11:29,040 --> 00:11:31,620
with you our code is valuable on the

254
00:11:31,620 --> 00:11:35,820
GitHub repo and or paper uh past all the

255
00:11:35,820 --> 00:11:38,339
usenix artifacts evaluations

256
00:11:38,339 --> 00:11:40,620
uh you are welcome to investigate our

257
00:11:40,620 --> 00:11:44,760
paper and code for more details

258
00:11:44,760 --> 00:11:47,399
this is about my presentation and thank

259
00:11:47,399 --> 00:11:49,740
you so much for listening uh the first

260
00:11:49,740 --> 00:11:52,019
answer of this paper Chung bin and I

261
00:11:52,019 --> 00:11:53,339
would like to answer any of your

262
00:11:53,339 --> 00:11:55,579
questions

