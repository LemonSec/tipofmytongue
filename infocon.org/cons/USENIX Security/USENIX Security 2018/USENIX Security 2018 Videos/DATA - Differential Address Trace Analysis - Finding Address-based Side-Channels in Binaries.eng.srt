1
00:00:10,540 --> 00:00:15,639
so this is joint work between<font color="#E5E5E5"> crowd some</font>

2
00:00:13,000 --> 00:00:15,970
University of Technology and<font color="#CCCCCC"> a loofah</font><font color="#E5E5E5"> I</font>

3
00:00:15,639 --> 00:00:19,860
say

4
00:00:15,970 --> 00:00:22,560
<font color="#E5E5E5">community as you</font><font color="#CCCCCC"> can see from</font><font color="#E5E5E5"> the title</font>

5
00:00:19,860 --> 00:00:27,000
this work is about finding<font color="#E5E5E5"> a dress based</font>

6
00:00:22,560 --> 00:00:27,000
side-channel<font color="#E5E5E5"> leakage in program fineries</font>

7
00:00:27,779 --> 00:00:36,010
sorry<font color="#E5E5E5"> so let's dive into the topic what</font>

8
00:00:33,130 --> 00:00:37,630
is exactly<font color="#E5E5E5"> side channel leakage well</font>

9
00:00:36,010 --> 00:00:41,260
suppose that<font color="#CCCCCC"> Alice emails with her</font>

10
00:00:37,630 --> 00:00:43,739
<font color="#CCCCCC">friend she securely encrypts her email</font>

11
00:00:41,260 --> 00:00:46,239
before<font color="#E5E5E5"> sending it out into the</font><font color="#CCCCCC"> ether and</font>

12
00:00:43,739 --> 00:00:48,220
<font color="#E5E5E5">for now let's ignore potential attacks</font>

13
00:00:46,239 --> 00:00:52,239
on asthma<font color="#E5E5E5"> and</font><font color="#CCCCCC"> BGP</font><font color="#E5E5E5"> as we have heard</font>

14
00:00:48,220 --> 00:00:54,610
<font color="#CCCCCC">previously when looking closer</font><font color="#E5E5E5"> what</font>

15
00:00:52,240 --> 00:00:56,920
happens inside a computer<font color="#CCCCCC"> we see that</font>

16
00:00:54,610 --> 00:00:59,140
there's some<font color="#CCCCCC"> information leaking during</font>

17
00:00:56,920 --> 00:01:02,140
the computation<font color="#CCCCCC"> that</font><font color="#E5E5E5"> is during</font>

18
00:00:59,140 --> 00:01:05,290
<font color="#E5E5E5">encryption or decryption</font><font color="#CCCCCC"> and we call</font>

19
00:01:02,140 --> 00:01:07,540
this side channel leakage and if enough

20
00:01:05,290 --> 00:01:10,479
information<font color="#CCCCCC"> is leaked then an attacker</font>

21
00:01:07,540 --> 00:01:12,130
can maybe guess infer the secret key

22
00:01:10,479 --> 00:01:13,810
which<font color="#E5E5E5"> is bad because you can decrypt all</font>

23
00:01:12,130 --> 00:01:18,009
past and<font color="#E5E5E5"> future communication in the</font>

24
00:01:13,810 --> 00:01:20,500
worst case so it's very important to

25
00:01:18,009 --> 00:01:25,680
<font color="#CCCCCC">avoid sighting leakage in your source</font>

26
00:01:20,500 --> 00:01:28,870
<font color="#E5E5E5">code so what exactly is address leakage</font>

27
00:01:25,680 --> 00:01:32,020
address leakage occurs<font color="#E5E5E5"> whenever a secret</font>

28
00:01:28,870 --> 00:01:34,450
information<font color="#E5E5E5"> is somehow leaked through</font>

29
00:01:32,020 --> 00:01:39,429
memory access patterns<font color="#E5E5E5"> that is through</font>

30
00:01:34,450 --> 00:01:41,170
memory accesses memory addresses<font color="#E5E5E5"> secret</font>

31
00:01:39,430 --> 00:01:43,420
information<font color="#E5E5E5"> can be anything from text</font>

32
00:01:41,170 --> 00:01:49,120
messages to passwords to cryptographic

33
00:01:43,420 --> 00:01:51,850
keys etc<font color="#CCCCCC"> and memory accesses somehow</font>

34
00:01:49,120 --> 00:01:54,060
depend on this secret<font color="#E5E5E5"> so we say</font><font color="#CCCCCC"> that</font>

35
00:01:51,850 --> 00:01:56,259
there is a secret<font color="#E5E5E5"> dependency a</font>

36
00:01:54,060 --> 00:02:00,460
dependency between secret input and

37
00:01:56,260 --> 00:02:03,040
memory addresses output so how does this

38
00:02:00,460 --> 00:02:06,429
<font color="#E5E5E5">look</font><font color="#CCCCCC"> like in practice</font><font color="#E5E5E5"> well we know two</font>

39
00:02:03,040 --> 00:02:09,310
root causes for<font color="#E5E5E5"> address leakage first</font>

40
00:02:06,430 --> 00:02:11,799
data leakage which occurs whenever<font color="#CCCCCC"> the</font>

41
00:02:09,310 --> 00:02:14,830
secret is used to compute data<font color="#E5E5E5"> addresses</font>

42
00:02:11,799 --> 00:02:17,610
an example on the<font color="#E5E5E5"> left</font><font color="#CCCCCC"> the secret is</font>

43
00:02:14,830 --> 00:02:21,040
used as index into a lookup table T and

44
00:02:17,610 --> 00:02:23,290
during runtime<font color="#E5E5E5"> this will translate to</font><font color="#CCCCCC"> a</font>

45
00:02:21,040 --> 00:02:27,340
data access in which<font color="#E5E5E5"> the accessed</font>

46
00:02:23,290 --> 00:02:28,929
<font color="#E5E5E5">address depends on the secret on the</font>

47
00:02:27,340 --> 00:02:29,500
other hand we have control flow leakage

48
00:02:28,930 --> 00:02:31,390
which

49
00:02:29,500 --> 00:02:33,970
<font color="#CCCCCC">kurz whenever a secret is used in a</font>

50
00:02:31,390 --> 00:02:36,429
<font color="#CCCCCC">conditional thus different code gets</font>

51
00:02:33,970 --> 00:02:37,960
executed for different secrets<font color="#E5E5E5"> for</font>

52
00:02:36,430 --> 00:02:41,680
example when a secret condition is true

53
00:02:37,960 --> 00:02:44,410
<font color="#E5E5E5">the function left</font><font color="#CCCCCC"> it's executed if false</font>

54
00:02:41,680 --> 00:02:46,240
<font color="#E5E5E5">the function right gets executed</font><font color="#CCCCCC"> so by</font>

55
00:02:44,410 --> 00:02:51,220
just<font color="#CCCCCC"> observing</font><font color="#E5E5E5"> which code gets executed</font>

56
00:02:46,240 --> 00:02:52,959
<font color="#E5E5E5">an attacker can infer the secret so now</font>

57
00:02:51,220 --> 00:02:55,450
that we<font color="#CCCCCC"> know what</font><font color="#E5E5E5"> address leakage is</font>

58
00:02:52,959 --> 00:02:58,360
let's<font color="#E5E5E5"> look at how we can explore this in</font>

59
00:02:55,450 --> 00:03:00,220
practice<font color="#CCCCCC"> when we have a look</font><font color="#E5E5E5"> at modern</font>

60
00:02:58,360 --> 00:03:02,770
<font color="#E5E5E5">CPUs there</font><font color="#CCCCCC"> are</font><font color="#E5E5E5"> plenty of components like</font>

61
00:03:00,220 --> 00:03:06,040
<font color="#E5E5E5">complex memory hierarchies branch</font>

62
00:03:02,770 --> 00:03:07,720
prediction<font color="#CCCCCC"> etcetera which all share some</font>

63
00:03:06,040 --> 00:03:09,730
form of<font color="#CCCCCC"> memory between</font><font color="#E5E5E5"> different</font>

64
00:03:07,720 --> 00:03:13,450
programs<font color="#CCCCCC"> and this resource sharing</font>

65
00:03:09,730 --> 00:03:15,730
creates<font color="#E5E5E5"> side channels for</font><font color="#CCCCCC"> example an</font>

66
00:03:13,450 --> 00:03:18,730
<font color="#CCCCCC">attacker process might use 2 cache lines</font>

67
00:03:15,730 --> 00:03:20,260
in the shared caches and let's now

68
00:03:18,730 --> 00:03:22,119
assume that<font color="#CCCCCC"> Ellis has a control flow</font>

69
00:03:20,260 --> 00:03:25,209
leak<font color="#CCCCCC"> as in the previous example on the</font>

70
00:03:22,120 --> 00:03:27,280
right side here<font color="#CCCCCC"> so she accesses</font><font color="#E5E5E5"> the left</font>

71
00:03:25,209 --> 00:03:29,100
cache line<font color="#E5E5E5"> when a secret condition is</font>

72
00:03:27,280 --> 00:03:31,870
true and<font color="#CCCCCC"> the right cache line otherwise</font>

73
00:03:29,100 --> 00:03:33,670
so in our<font color="#E5E5E5"> example</font><font color="#CCCCCC"> the secret condition</font>

74
00:03:31,870 --> 00:03:35,890
is true so Ellis accesses the<font color="#CCCCCC"> left cache</font>

75
00:03:33,670 --> 00:03:37,809
line and the deck has data which was

76
00:03:35,890 --> 00:03:41,649
previously there gets displaced to<font color="#CCCCCC"> the</font>

77
00:03:37,810 --> 00:03:43,750
UM so now when the attacker accesses the

78
00:03:41,650 --> 00:03:47,350
right cache line this one<font color="#E5E5E5"> is fast</font><font color="#CCCCCC"> a fast</font>

79
00:03:43,750 --> 00:03:48,790
access because data is<font color="#E5E5E5"> in the cache but</font>

80
00:03:47,350 --> 00:03:51,549
when he accesses the<font color="#E5E5E5"> left cache line</font>

81
00:03:48,790 --> 00:03:55,239
<font color="#E5E5E5">this is slow because</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> attackers data</font>

82
00:03:51,549 --> 00:03:57,790
has to<font color="#CCCCCC"> be first loaded from the UM so by</font>

83
00:03:55,239 --> 00:04:00,610
mere climbing measurement the<font color="#E5E5E5"> attacker</font>

84
00:03:57,790 --> 00:04:03,070
can learn which cache line<font color="#CCCCCC"> L</font><font color="#E5E5E5"> is accessed</font>

85
00:04:00,610 --> 00:04:06,250
and<font color="#E5E5E5"> he can infer</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> the secret</font>

86
00:04:03,070 --> 00:04:09,370
condition was<font color="#E5E5E5"> true so this is an example</font>

87
00:04:06,250 --> 00:04:12,820
of<font color="#E5E5E5"> address leakage how you can exploit</font>

88
00:04:09,370 --> 00:04:14,470
it<font color="#CCCCCC"> while shared caches but in practice</font>

89
00:04:12,820 --> 00:04:16,839
there are many more components like<font color="#E5E5E5"> dear</font>

90
00:04:14,470 --> 00:04:19,899
Emma cetera<font color="#E5E5E5"> which all</font><font color="#CCCCCC"> leaked</font><font color="#E5E5E5"> some form</font>

91
00:04:16,839 --> 00:04:21,458
of address information<font color="#CCCCCC"> and we do not</font>

92
00:04:19,899 --> 00:04:23,349
give details<font color="#E5E5E5"> about all those components</font>

93
00:04:21,459 --> 00:04:26,560
<font color="#E5E5E5">but it's important to understand that</font>

94
00:04:23,350 --> 00:04:31,180
<font color="#E5E5E5">the term address leakage captures all of</font>

95
00:04:26,560 --> 00:04:33,310
them so what did we<font color="#E5E5E5"> do first</font><font color="#CCCCCC"> our</font>

96
00:04:31,180 --> 00:04:36,340
objective is and we want<font color="#E5E5E5"> to analyze a</font>

97
00:04:33,310 --> 00:04:38,830
program and want to find as many address

98
00:04:36,340 --> 00:04:40,869
leaks as possible<font color="#E5E5E5"> we've constrained</font>

99
00:04:38,830 --> 00:04:43,080
resources and<font color="#CCCCCC"> limited developer effort</font>

100
00:04:40,870 --> 00:04:45,880
so we<font color="#E5E5E5"> want to be efficient</font>

101
00:04:43,080 --> 00:04:48,340
so how do we<font color="#E5E5E5"> achieve this</font><font color="#CCCCCC"> first we have</font>

102
00:04:45,880 --> 00:04:51,100
to<font color="#E5E5E5"> decide between two methods for</font>

103
00:04:48,340 --> 00:04:53,530
finding<font color="#CCCCCC"> address leaks</font><font color="#E5E5E5"> namely static and</font>

104
00:04:51,100 --> 00:04:56,050
dynamic analysis so this<font color="#E5E5E5"> is only very</font>

105
00:04:53,530 --> 00:05:02,140
<font color="#E5E5E5">coarse-grained overview</font><font color="#CCCCCC"> year</font><font color="#E5E5E5"> there's</font>

106
00:04:56,050 --> 00:05:04,320
certainly methods in between also static

107
00:05:02,140 --> 00:05:07,300
analysis typically<font color="#E5E5E5"> symbolically</font>

108
00:05:04,320 --> 00:05:10,870
<font color="#E5E5E5">symbolically evaluates all program paths</font>

109
00:05:07,300 --> 00:05:12,430
<font color="#CCCCCC">and</font><font color="#E5E5E5"> that way they can compute upper</font>

110
00:05:10,870 --> 00:05:16,240
leakage bounds they can achieve<font color="#E5E5E5"> zero</font>

111
00:05:12,430 --> 00:05:19,410
<font color="#E5E5E5">false negatives they can approve they</font>

112
00:05:16,240 --> 00:05:21,220
can prove absence of leaks<font color="#E5E5E5"> in some cases</font>

113
00:05:19,410 --> 00:05:23,320
<font color="#E5E5E5">however there are</font><font color="#CCCCCC"> certain problems</font>

114
00:05:21,220 --> 00:05:26,290
<font color="#E5E5E5">because they suffer from imprecision</font>

115
00:05:23,320 --> 00:05:28,780
which yields false positives<font color="#E5E5E5"> which</font>

116
00:05:26,290 --> 00:05:31,750
prohibits analysis of interpret<font color="#E5E5E5"> that</font>

117
00:05:28,780 --> 00:05:33,330
code for<font color="#E5E5E5"> example</font><font color="#CCCCCC"> and also the symbolic</font>

118
00:05:31,750 --> 00:05:37,320
execution is quite expensive

119
00:05:33,330 --> 00:05:40,810
<font color="#E5E5E5">it does not scale the large programs in</font>

120
00:05:37,320 --> 00:05:44,290
contrast<font color="#E5E5E5"> dynamic analysis can use a</font>

121
00:05:40,810 --> 00:05:46,780
concrete<font color="#E5E5E5"> execution real execution and it</font>

122
00:05:44,290 --> 00:05:49,120
<font color="#E5E5E5">only reports real address leaks so we</font>

123
00:05:46,780 --> 00:05:52,210
can achieve<font color="#CCCCCC"> zero false positives</font><font color="#E5E5E5"> and</font>

124
00:05:49,120 --> 00:05:53,770
that's what we want<font color="#E5E5E5"> to have however</font><font color="#CCCCCC"> the</font>

125
00:05:52,210 --> 00:05:56,169
main problem<font color="#CCCCCC"> with dynamic methods is</font>

126
00:05:53,770 --> 00:05:59,020
that they suffer from false negatives

127
00:05:56,170 --> 00:06:01,180
<font color="#E5E5E5">that is they might miss leakage which is</font>

128
00:05:59,020 --> 00:06:06,490
not found<font color="#E5E5E5"> so it's very important to</font>

129
00:06:01,180 --> 00:06:08,680
reduce false negatives in this case<font color="#E5E5E5"> okay</font>

130
00:06:06,490 --> 00:06:10,510
and we<font color="#E5E5E5"> will use dynamic analysis because</font>

131
00:06:08,680 --> 00:06:13,080
it gives<font color="#E5E5E5"> us several practical benefits</font>

132
00:06:10,510 --> 00:06:16,349
for<font color="#E5E5E5"> analyzing</font><font color="#CCCCCC"> real-world</font><font color="#E5E5E5"> software</font>

133
00:06:13,080 --> 00:06:20,650
so let's come to<font color="#CCCCCC"> our contribution data</font>

134
00:06:16,350 --> 00:06:22,920
<font color="#E5E5E5">differential errors trace analysis what</font>

135
00:06:20,650 --> 00:06:25,690
<font color="#E5E5E5">did we do we designed and implemented</font><font color="#CCCCCC"> a</font>

136
00:06:22,920 --> 00:06:29,770
dynamic<font color="#E5E5E5"> leakage detection</font><font color="#CCCCCC"> tool which we</font>

137
00:06:25,690 --> 00:06:32,020
call data how does<font color="#E5E5E5"> it work first the</font>

138
00:06:29,770 --> 00:06:34,180
user specifies which information is

139
00:06:32,020 --> 00:06:37,060
<font color="#E5E5E5">secret for example the</font><font color="#CCCCCC"> refer</font>

140
00:06:34,180 --> 00:06:38,890
cryptographic key<font color="#CCCCCC"> use</font><font color="#E5E5E5"> and messages then</font>

141
00:06:37,060 --> 00:06:41,290
the tool will automatically find

142
00:06:38,890 --> 00:06:46,599
arbitrary<font color="#CCCCCC"> address based</font><font color="#E5E5E5"> side-channel</font>

143
00:06:41,290 --> 00:06:49,180
leaks<font color="#CCCCCC"> in</font><font color="#E5E5E5"> the program binary also since</font>

144
00:06:46,600 --> 00:06:51,340
not all leaks are equally dangerous in

145
00:06:49,180 --> 00:06:54,130
practice with one more<font color="#E5E5E5"> step where the</font>

146
00:06:51,340 --> 00:06:56,049
<font color="#E5E5E5">tool uses statistical tests known from</font>

147
00:06:54,130 --> 00:06:57,789
the hardware side<font color="#E5E5E5"> channel literature</font>

148
00:06:56,050 --> 00:07:03,310
to test how<font color="#CCCCCC"> much information is actually</font>

149
00:06:57,789 --> 00:07:05,710
<font color="#E5E5E5">leaked and our tool can detect arbitrary</font>

150
00:07:03,310 --> 00:07:07,930
errors leaks<font color="#E5E5E5"> that is data leaks and</font>

151
00:07:05,710 --> 00:07:11,250
control flow leaks which captures all

152
00:07:07,930 --> 00:07:14,110
errors based attacks we<font color="#CCCCCC"> saw before and</font>

153
00:07:11,250 --> 00:07:17,440
we achieve good results<font color="#E5E5E5"> by lowering both</font>

154
00:07:14,110 --> 00:07:19,539
false positives<font color="#E5E5E5"> and false negatives we</font>

155
00:07:17,440 --> 00:07:22,000
filter<font color="#CCCCCC"> out</font><font color="#E5E5E5"> a non-deterministic program</font>

156
00:07:19,539 --> 00:07:24,520
behavior<font color="#E5E5E5"> which is common for</font><font color="#CCCCCC"> asymmetric</font>

157
00:07:22,000 --> 00:07:27,729
<font color="#E5E5E5">ciphers as we saw before errors a</font>

158
00:07:24,520 --> 00:07:33,698
blinding that is we filter leaks that

159
00:07:27,729 --> 00:07:35,680
<font color="#CCCCCC">are independent of</font><font color="#E5E5E5"> the secret and data</font>

160
00:07:33,699 --> 00:07:37,990
<font color="#CCCCCC">our approach is practical into</font><font color="#E5E5E5"> several</font>

161
00:07:35,680 --> 00:07:40,389
directions<font color="#CCCCCC"> first</font><font color="#E5E5E5"> it's fully automated</font>

162
00:07:37,990 --> 00:07:42,280
<font color="#E5E5E5">that is there's no developer annotations</font>

163
00:07:40,389 --> 00:07:45,639
needed in the source code we even don't

164
00:07:42,280 --> 00:07:49,090
need source code for analysis<font color="#E5E5E5"> and our</font>

165
00:07:45,639 --> 00:07:51,039
tool<font color="#CCCCCC"> is fast and openly available</font><font color="#E5E5E5"> we</font>

166
00:07:49,090 --> 00:07:53,440
<font color="#CCCCCC">used our tool to</font><font color="#E5E5E5"> analyze different</font>

167
00:07:51,039 --> 00:07:56,020
cryptographic libraries and we<font color="#E5E5E5"> found and</font>

168
00:07:53,440 --> 00:08:00,150
fixed<font color="#E5E5E5"> two critical vulnerabilities in</font>

169
00:07:56,020 --> 00:08:03,609
open<font color="#E5E5E5"> SSL which</font><font color="#CCCCCC"> were</font><font color="#E5E5E5"> previously unknown</font>

170
00:08:00,150 --> 00:08:08,460
also we were able<font color="#CCCCCC"> to analyze interpreted</font>

171
00:08:03,610 --> 00:08:09,610
code<font color="#CCCCCC"> PI crypto where we - found leaks</font>

172
00:08:08,460 --> 00:08:11,020
<font color="#CCCCCC">okay</font>

173
00:08:09,610 --> 00:08:14,080
now let's have a look<font color="#E5E5E5"> at how data works</font>

174
00:08:11,020 --> 00:08:18,130
in practice<font color="#E5E5E5"> so we have three consecutive</font>

175
00:08:14,080 --> 00:08:20,198
<font color="#E5E5E5">phases phases the first phase analyzes</font>

176
00:08:18,130 --> 00:08:23,469
the program to find irregularities in a

177
00:08:20,199 --> 00:08:27,729
memory<font color="#CCCCCC"> access patterns</font><font color="#E5E5E5"> these are called</font>

178
00:08:23,469 --> 00:08:31,509
<font color="#CCCCCC">Aaron's differences the phase two asks</font>

179
00:08:27,729 --> 00:08:33,069
the question<font color="#CCCCCC"> is</font><font color="#E5E5E5"> it actually a</font><font color="#CCCCCC"> leak the</font>

180
00:08:31,509 --> 00:08:36,010
program could<font color="#CCCCCC"> be not that</font><font color="#E5E5E5"> are non</font>

181
00:08:33,070 --> 00:08:39,190
deterministic for example so we test all

182
00:08:36,010 --> 00:08:43,630
<font color="#CCCCCC">arrest differences for this secret</font>

183
00:08:39,190 --> 00:08:46,630
<font color="#E5E5E5">dependency and the</font><font color="#CCCCCC"> phase free then asks</font>

184
00:08:43,630 --> 00:08:48,610
<font color="#CCCCCC">the question how severe is a leak in</font>

185
00:08:46,630 --> 00:08:50,260
practice<font color="#E5E5E5"> so we try to quantify the</font>

186
00:08:48,610 --> 00:08:54,220
information loss under<font color="#E5E5E5"> certain leakage</font>

187
00:08:50,260 --> 00:08:57,579
models so let's have a look at the first

188
00:08:54,220 --> 00:08:59,649
phase how does it work<font color="#E5E5E5"> well we</font><font color="#CCCCCC"> execute</font>

189
00:08:57,579 --> 00:09:01,719
the program multiple times with

190
00:08:59,649 --> 00:09:05,440
different<font color="#E5E5E5"> secret inputs with different</font>

191
00:09:01,720 --> 00:09:07,959
keys<font color="#E5E5E5"> and then we recall</font><font color="#CCCCCC"> so-called</font>

192
00:09:05,440 --> 00:09:09,050
<font color="#E5E5E5">address traces containing all memory</font>

193
00:09:07,959 --> 00:09:11,959
accesses

194
00:09:09,050 --> 00:09:15,260
and if the<font color="#CCCCCC"> eros traces are the same</font>

195
00:09:11,959 --> 00:09:15,949
there was no leak<font color="#E5E5E5"> visible however if</font>

196
00:09:15,260 --> 00:09:19,069
they differ

197
00:09:15,950 --> 00:09:22,490
we found<font color="#E5E5E5"> a potential leak and we can</font>

198
00:09:19,070 --> 00:09:25,490
report it back to the developer so let's

199
00:09:22,490 --> 00:09:27,680
get let's go through the<font color="#E5E5E5"> steps again we</font>

200
00:09:25,490 --> 00:09:29,870
use multiple different<font color="#E5E5E5"> keys which is</font>

201
00:09:27,680 --> 00:09:32,239
important to<font color="#CCCCCC"> explore many different</font>

202
00:09:29,870 --> 00:09:35,959
program paths<font color="#E5E5E5"> and this interest</font><font color="#CCCCCC"> that we</font>

203
00:09:32,240 --> 00:09:37,970
can lower the false negatives in

204
00:09:35,959 --> 00:09:41,000
practice we even observed that<font color="#E5E5E5"> for</font>

205
00:09:37,970 --> 00:09:42,860
symmetric ciphers<font color="#CCCCCC"> two to three keys are</font>

206
00:09:41,000 --> 00:09:44,600
enough so<font color="#E5E5E5"> two to three executions are</font>

207
00:09:42,860 --> 00:09:47,300
enough because symmetric ciphers do not

208
00:09:44,600 --> 00:09:51,610
have<font color="#E5E5E5"> control flow leaks and for</font>

209
00:09:47,300 --> 00:09:55,310
asymmetric<font color="#E5E5E5"> ciphers we used ten traces</font>

210
00:09:51,610 --> 00:09:58,760
and then we used a binary dynamic

211
00:09:55,310 --> 00:10:01,010
instrumentation framework<font color="#E5E5E5"> to record all</font>

212
00:09:58,760 --> 00:10:01,579
control flow instructions and all memory

213
00:10:01,010 --> 00:10:04,730
accesses

214
00:10:01,579 --> 00:10:08,750
this<font color="#CCCCCC"> ensures that we kept all kinds</font><font color="#E5E5E5"> of</font>

215
00:10:04,730 --> 00:10:12,350
address leakage<font color="#E5E5E5"> and in the end we use a</font>

216
00:10:08,750 --> 00:10:14,779
sync sequential comparison algorithm to

217
00:10:12,350 --> 00:10:17,029
compare the traces<font color="#CCCCCC"> and we do this</font>

218
00:10:14,779 --> 00:10:20,089
pairwise for all pairs of<font color="#E5E5E5"> traces we</font>

219
00:10:17,029 --> 00:10:22,689
recorded<font color="#E5E5E5"> previously and this comparison</font>

220
00:10:20,089 --> 00:10:25,459
<font color="#CCCCCC">tries</font><font color="#E5E5E5"> to find these irregularities and</font>

221
00:10:22,690 --> 00:10:27,800
special care has to be taken for control

222
00:10:25,459 --> 00:10:31,099
flow leaks<font color="#CCCCCC"> because here the control flow</font>

223
00:10:27,800 --> 00:10:32,810
diverts into multiple branches for

224
00:10:31,100 --> 00:10:34,910
example into<font color="#CCCCCC"> the functions left and</font>

225
00:10:32,810 --> 00:10:36,709
right from the<font color="#E5E5E5"> previous example so</font><font color="#CCCCCC"> in</font>

226
00:10:34,910 --> 00:10:38,719
this case we have to<font color="#E5E5E5"> find the point</font>

227
00:10:36,709 --> 00:10:41,359
where<font color="#E5E5E5"> the control flow leak is over and</font>

228
00:10:38,720 --> 00:10:43,610
the two<font color="#E5E5E5"> traces merge again and where if</font>

229
00:10:41,360 --> 00:10:47,450
a<font color="#E5E5E5"> special trace realignment</font><font color="#CCCCCC"> algorithm</font>

230
00:10:43,610 --> 00:10:49,970
which you can read<font color="#E5E5E5"> up in a paper</font><font color="#CCCCCC"> okay</font>

231
00:10:47,450 --> 00:10:51,589
and by<font color="#CCCCCC"> doing so we can find all leaks</font>

232
00:10:49,970 --> 00:10:53,810
which are visible<font color="#CCCCCC"> in</font><font color="#E5E5E5"> the execution</font>

233
00:10:51,589 --> 00:10:55,790
traces however not all address

234
00:10:53,810 --> 00:10:59,959
differences are<font color="#CCCCCC"> actually secret</font>

235
00:10:55,790 --> 00:11:02,000
<font color="#CCCCCC">dependent</font><font color="#E5E5E5"> but they might stem from non</font>

236
00:10:59,959 --> 00:11:04,489
<font color="#E5E5E5">determinism as we heard before</font><font color="#CCCCCC"> and now</font>

237
00:11:02,000 --> 00:11:11,060
my colleague will tell you what to do in

238
00:11:04,490 --> 00:11:13,480
this case<font color="#CCCCCC"> alright</font><font color="#E5E5E5"> so once we have those</font>

239
00:11:11,060 --> 00:11:16,550
address differences from<font color="#CCCCCC"> the first phase</font>

240
00:11:13,480 --> 00:11:19,100
<font color="#E5E5E5">we</font><font color="#CCCCCC"> advance to the second phase called</font>

241
00:11:16,550 --> 00:11:21,890
leakage detection<font color="#CCCCCC"> and what we do</font><font color="#E5E5E5"> here is</font>

242
00:11:19,100 --> 00:11:24,649
we again start<font color="#E5E5E5"> an instrumentation</font>

243
00:11:21,890 --> 00:11:26,660
so a<font color="#CCCCCC"> trace recording phase</font><font color="#E5E5E5"> but this time</font>

244
00:11:24,649 --> 00:11:28,850
we<font color="#CCCCCC"> only look at the</font><font color="#E5E5E5"> differences that we</font>

245
00:11:26,660 --> 00:11:32,360
<font color="#E5E5E5">found earlier</font><font color="#CCCCCC"> so we are a lot</font><font color="#E5E5E5"> faster and</font>

246
00:11:28,850 --> 00:11:34,459
our<font color="#E5E5E5"> traces are a lot smaller now</font><font color="#CCCCCC"> in</font>

247
00:11:32,360 --> 00:11:36,230
contrast<font color="#CCCCCC"> to the previous</font><font color="#E5E5E5"> phase what we</font>

248
00:11:34,459 --> 00:11:38,630
do is we execute<font color="#E5E5E5"> the program with two</font>

249
00:11:36,230 --> 00:11:41,329
<font color="#CCCCCC">different input sets</font><font color="#E5E5E5"> so one fixed input</font>

250
00:11:38,630 --> 00:11:42,439
and a<font color="#E5E5E5"> number of varying inputs so let's</font>

251
00:11:41,329 --> 00:11:43,250
suppose<font color="#E5E5E5"> I want</font><font color="#CCCCCC"> to take a hundred</font>

252
00:11:42,440 --> 00:11:45,170
measurements

253
00:11:43,250 --> 00:11:47,660
I would<font color="#E5E5E5"> execute the program a hundred</font>

254
00:11:45,170 --> 00:11:50,899
times<font color="#E5E5E5"> with fixed input and a hundred</font>

255
00:11:47,660 --> 00:11:54,680
<font color="#E5E5E5">times with a hundred random distinct</font>

256
00:11:50,899 --> 00:11:56,360
secret inputs<font color="#E5E5E5"> and this gives me two</font>

257
00:11:54,680 --> 00:11:59,510
different<font color="#CCCCCC"> inputs there</font><font color="#E5E5E5"> are two different</font>

258
00:11:56,360 --> 00:12:04,519
trace sets and these trace<font color="#E5E5E5"> sets are the</font>

259
00:11:59,510 --> 00:12:06,740
<font color="#E5E5E5">input to what we call sorry the generic</font>

260
00:12:04,519 --> 00:12:09,110
leakage test<font color="#E5E5E5"> so what the generic leakage</font>

261
00:12:06,740 --> 00:12:10,610
test is<font color="#E5E5E5"> doing basically is</font><font color="#CCCCCC"> it's</font>

262
00:12:09,110 --> 00:12:12,380
iterating over<font color="#CCCCCC"> all the address</font>

263
00:12:10,610 --> 00:12:15,010
differences<font color="#E5E5E5"> that we found in phase one</font>

264
00:12:12,380 --> 00:12:19,790
and then<font color="#CCCCCC"> it's looking into</font><font color="#E5E5E5"> these two</font>

265
00:12:15,010 --> 00:12:21,769
<font color="#E5E5E5">different</font><font color="#CCCCCC"> tray sets and extracting</font><font color="#E5E5E5"> all</font>

266
00:12:19,790 --> 00:12:24,339
the<font color="#CCCCCC"> addresses that we see for instance</font>

267
00:12:21,769 --> 00:12:28,850
one instruction let's say a difference

268
00:12:24,339 --> 00:12:31,130
makes a memory access<font color="#CCCCCC"> than we recalled</font>

269
00:12:28,850 --> 00:12:34,040
<font color="#E5E5E5">all the addresses</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> that instruction</font>

270
00:12:31,130 --> 00:12:35,839
<font color="#E5E5E5">and we build address distributions so in</font>

271
00:12:34,040 --> 00:12:39,529
the end we have for every differences

272
00:12:35,839 --> 00:12:42,350
<font color="#E5E5E5">that we detect we have two distributions</font>

273
00:12:39,529 --> 00:12:48,050
<font color="#E5E5E5">and these two distributions we then</font>

274
00:12:42,350 --> 00:12:50,000
compare<font color="#CCCCCC"> with a</font><font color="#E5E5E5"> statistical test and if</font>

275
00:12:48,050 --> 00:12:51,829
those<font color="#CCCCCC"> two distributions are not similar</font>

276
00:12:50,000 --> 00:12:54,140
<font color="#CCCCCC">or do not</font><font color="#E5E5E5"> stem</font><font color="#CCCCCC"> from the same base</font>

277
00:12:51,829 --> 00:12:56,120
distribution we know<font color="#E5E5E5"> that this is an</font>

278
00:12:54,140 --> 00:12:59,360
information leak so the reason behind is

279
00:12:56,120 --> 00:13:01,640
if I change<font color="#E5E5E5"> my secret input and if I</font>

280
00:12:59,360 --> 00:13:03,649
observe a different address distribution

281
00:13:01,640 --> 00:13:06,529
and I inevitably<font color="#E5E5E5"> learn something about</font>

282
00:13:03,649 --> 00:13:08,779
<font color="#E5E5E5">my secret input the problem is I'm not</font>

283
00:13:06,529 --> 00:13:11,540
<font color="#E5E5E5">really sure like how</font><font color="#CCCCCC"> much</font><font color="#E5E5E5"> I learn on how</font>

284
00:13:08,779 --> 00:13:13,579
critical that<font color="#CCCCCC"> leak actually is so</font><font color="#E5E5E5"> this</font>

285
00:13:11,540 --> 00:13:16,790
is why we also<font color="#E5E5E5"> introduced</font><font color="#CCCCCC"> the third</font>

286
00:13:13,579 --> 00:13:19,459
phase<font color="#E5E5E5"> and that</font><font color="#CCCCCC"> will give us this insight</font>

287
00:13:16,790 --> 00:13:21,290
<font color="#E5E5E5">so but first we accumulate all the leaks</font>

288
00:13:19,459 --> 00:13:24,439
in an intermediate report and then we

289
00:13:21,290 --> 00:13:27,699
<font color="#E5E5E5">advance</font><font color="#CCCCCC"> to the third phase so in the</font>

290
00:13:24,440 --> 00:13:30,740
third phase we do a two step preparation

291
00:13:27,699 --> 00:13:34,790
<font color="#CCCCCC">starting with again we take a look at</font>

292
00:13:30,740 --> 00:13:37,040
the<font color="#E5E5E5"> trace set based on the random input</font>

293
00:13:34,790 --> 00:13:39,110
and instead<font color="#CCCCCC"> of building</font><font color="#E5E5E5"> address</font>

294
00:13:37,040 --> 00:13:41,540
distributions we simply list<font color="#E5E5E5"> the</font>

295
00:13:39,110 --> 00:13:44,090
addresses that<font color="#CCCCCC"> we see</font><font color="#E5E5E5"> so for instance</font>

296
00:13:41,540 --> 00:13:49,910
one instructions may access addresses<font color="#CCCCCC"> 4</font>

297
00:13:44,090 --> 00:13:51,740
<font color="#CCCCCC">5 6 and the second step would be</font><font color="#E5E5E5"> we</font><font color="#CCCCCC"> take</font>

298
00:13:49,910 --> 00:13:54,380
the corresponding<font color="#E5E5E5"> secret inputs that</font>

299
00:13:51,740 --> 00:13:56,089
<font color="#E5E5E5">produce the traces and plug them into a</font>

300
00:13:54,380 --> 00:13:57,439
leakage model so a leakage model is

301
00:13:56,089 --> 00:13:59,990
known from<font color="#CCCCCC"> second literature is</font>

302
00:13:57,440 --> 00:14:02,990
basically a reduction in input<font color="#E5E5E5"> space</font>

303
00:13:59,990 --> 00:14:06,020
complexity<font color="#E5E5E5"> and can be for</font><font color="#CCCCCC"> instance</font><font color="#E5E5E5"> I</font>

304
00:14:02,990 --> 00:14:08,839
only consider<font color="#E5E5E5"> the first byte</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> my</font>

305
00:14:06,020 --> 00:14:11,210
secret<font color="#E5E5E5"> value or one single</font><font color="#CCCCCC"> bit or the</font>

306
00:14:08,839 --> 00:14:14,510
Hamming weight and the leakage model is

307
00:14:11,210 --> 00:14:16,760
in some ways<font color="#CCCCCC"> domain-specific</font><font color="#E5E5E5"> so of</font>

308
00:14:14,510 --> 00:14:20,240
<font color="#E5E5E5">course I have to check for something</font>

309
00:14:16,760 --> 00:14:22,939
that I do<font color="#E5E5E5"> not want to leak in the</font>

310
00:14:20,240 --> 00:14:26,480
addresses<font color="#E5E5E5"> so let's say in a</font><font color="#CCCCCC"> general case</font>

311
00:14:22,940 --> 00:14:28,010
maybe the byte leakage model<font color="#CCCCCC"> makes a lot</font>

312
00:14:26,480 --> 00:14:29,900
of sense because<font color="#E5E5E5"> I do not want for</font>

313
00:14:28,010 --> 00:14:31,790
<font color="#CCCCCC">instance the byte values of my secret</font>

314
00:14:29,900 --> 00:14:37,819
key or the<font color="#E5E5E5"> byte values of my password to</font>

315
00:14:31,790 --> 00:14:41,180
<font color="#E5E5E5">show up in the addresses so let's say I</font>

316
00:14:37,820 --> 00:14:43,280
choose a leakage model one particular

317
00:14:41,180 --> 00:14:46,729
<font color="#E5E5E5">bit of</font><font color="#CCCCCC"> my inputs</font>

318
00:14:43,280 --> 00:14:51,100
I may get these outputs<font color="#E5E5E5"> all ones and</font>

319
00:14:46,730 --> 00:14:51,100
what<font color="#E5E5E5"> this gives me</font><font color="#CCCCCC"> essentially is a</font>

320
00:14:51,550 --> 00:14:57,740
<font color="#CCCCCC">operators a list of observation pairs</font>

321
00:14:54,050 --> 00:14:59,599
<font color="#E5E5E5">basically and these pairs</font><font color="#CCCCCC"> we then plug</font>

322
00:14:57,740 --> 00:14:59,990
<font color="#CCCCCC">into</font><font color="#E5E5E5"> what we call a</font><font color="#CCCCCC"> specific leakage</font>

323
00:14:59,600 --> 00:15:02,450
test

324
00:14:59,990 --> 00:15:03,980
it's<font color="#E5E5E5"> a</font><font color="#CCCCCC"> bivariate relationship test and</font>

325
00:15:02,450 --> 00:15:05,510
it simply tells me if there<font color="#E5E5E5"> is any</font>

326
00:15:03,980 --> 00:15:08,570
linear or<font color="#CCCCCC"> nonlinear relation between</font>

327
00:15:05,510 --> 00:15:10,839
those<font color="#E5E5E5"> two</font><font color="#CCCCCC"> sequences and</font><font color="#E5E5E5"> in this example</font>

328
00:15:08,570 --> 00:15:13,640
for<font color="#E5E5E5"> instance our test will probably say</font>

329
00:15:10,839 --> 00:15:15,650
no<font color="#E5E5E5"> so if I take a look at</font><font color="#CCCCCC"> the addresses</font>

330
00:15:13,640 --> 00:15:16,959
<font color="#E5E5E5">4 5 6 I do not necessarily learn</font>

331
00:15:15,650 --> 00:15:19,400
anything new

332
00:15:16,959 --> 00:15:20,959
however if I change<font color="#E5E5E5"> my leakage model</font>

333
00:15:19,400 --> 00:15:23,839
let's say for instance<font color="#E5E5E5"> to the byte</font>

334
00:15:20,959 --> 00:15:26,810
values of my secret the sequence<font color="#E5E5E5"> would</font>

335
00:15:23,839 --> 00:15:28,400
change as well<font color="#E5E5E5"> and our specific leakage</font>

336
00:15:26,810 --> 00:15:31,060
test would say okay yeah now there is a

337
00:15:28,400 --> 00:15:34,069
clear linear<font color="#CCCCCC"> relation between</font><font color="#E5E5E5"> that and</font>

338
00:15:31,060 --> 00:15:35,750
this means that<font color="#CCCCCC"> the leakage model in</font>

339
00:15:34,070 --> 00:15:38,810
this case<font color="#CCCCCC"> directly gives us the</font>

340
00:15:35,750 --> 00:15:39,880
<font color="#E5E5E5">information that we lose from this leak</font>

341
00:15:38,810 --> 00:15:42,880
[Music]

342
00:15:39,880 --> 00:15:42,880
so

343
00:15:43,610 --> 00:15:50,490
you know to finish<font color="#CCCCCC"> these to</font><font color="#E5E5E5"> finish this</font>

344
00:15:46,170 --> 00:15:52,770
<font color="#E5E5E5">face</font><font color="#CCCCCC"> we test all the address leaks that</font>

345
00:15:50,490 --> 00:15:56,010
<font color="#E5E5E5">we found previously with all the outputs</font>

346
00:15:52,770 --> 00:15:58,050
<font color="#E5E5E5">of the leakage model and we augment the</font>

347
00:15:56,010 --> 00:16:00,390
leakage<font color="#CCCCCC"> reboard that we had</font><font color="#E5E5E5"> from phase</font><font color="#CCCCCC"> 2</font>

348
00:15:58,050 --> 00:16:02,250
so note<font color="#CCCCCC"> that we do</font><font color="#E5E5E5"> not drop any leaks</font>

349
00:16:00,390 --> 00:16:03,870
here<font color="#E5E5E5"> so already still show up</font><font color="#CCCCCC"> in the</font>

350
00:16:02,250 --> 00:16:06,480
<font color="#E5E5E5">final</font><font color="#CCCCCC"> report but we have some additional</font>

351
00:16:03,870 --> 00:16:08,220
<font color="#E5E5E5">information that helps us to</font><font color="#CCCCCC"> prioritize</font>

352
00:16:06,480 --> 00:16:12,990
the leak and determine which one<font color="#CCCCCC"> is more</font>

353
00:16:08,220 --> 00:16:14,910
critical<font color="#CCCCCC"> than the other so let's take a</font>

354
00:16:12,990 --> 00:16:18,390
look<font color="#CCCCCC"> at some practical results we use</font>

355
00:16:14,910 --> 00:16:21,510
data to<font color="#E5E5E5"> analyze open SSL anti crypto</font>

356
00:16:18,390 --> 00:16:23,580
we found a set off or confirmed a set of

357
00:16:21,510 --> 00:16:25,740
<font color="#CCCCCC">known leak so a lot of symmetric cipher</font>

358
00:16:23,580 --> 00:16:28,860
implementations<font color="#E5E5E5"> still use look-up tables</font>

359
00:16:25,740 --> 00:16:31,590
<font color="#E5E5E5">those</font><font color="#CCCCCC"> leaked heavily Triple DES test</font>

360
00:16:28,860 --> 00:16:36,000
Blowfish<font color="#CCCCCC"> Kamiya cast so a lot of</font>

361
00:16:31,590 --> 00:16:38,130
<font color="#E5E5E5">examples</font><font color="#CCCCCC"> that still leaked there are</font>

362
00:16:36,000 --> 00:16:39,330
some protected implementations for AES

363
00:16:38,130 --> 00:16:42,330
of course

364
00:16:39,330 --> 00:16:44,670
still we found that in<font color="#E5E5E5"> the ASP last</font>

365
00:16:42,330 --> 00:16:46,410
implementation the key schedule<font color="#E5E5E5"> itself</font>

366
00:16:44,670 --> 00:16:49,319
is vulnerable<font color="#CCCCCC"> because it also uses</font>

367
00:16:46,410 --> 00:16:52,439
lookup tables and the<font color="#E5E5E5"> UCD is a</font>

368
00:16:49,320 --> 00:16:54,510
implementation opposite SSL still uses a

369
00:16:52,440 --> 00:16:56,820
vulnerable<font color="#CCCCCC"> WN</font><font color="#E5E5E5"> AF point multiplication</font>

370
00:16:54,510 --> 00:17:01,710
function which has<font color="#E5E5E5"> been noted previously</font>

371
00:16:56,820 --> 00:17:03,600
and has already<font color="#CCCCCC"> been exploited next to</font>

372
00:17:01,710 --> 00:17:07,950
the confirmed leaks we also found new

373
00:17:03,600 --> 00:17:10,460
leaks for instance in years a we<font color="#E5E5E5"> found</font>

374
00:17:07,950 --> 00:17:12,800
the back that<font color="#E5E5E5"> omitted a constant time</font>

375
00:17:10,460 --> 00:17:15,900
<font color="#CCCCCC">modular inversion during key</font>

376
00:17:12,800 --> 00:17:19,169
initialization so this is<font color="#E5E5E5"> very found</font>

377
00:17:15,900 --> 00:17:21,510
quite some quite a number<font color="#E5E5E5"> of leaks</font><font color="#CCCCCC"> and</font>

378
00:17:19,170 --> 00:17:24,000
also in RSA<font color="#E5E5E5"> we found this similar back</font>

379
00:17:21,510 --> 00:17:25,920
but also<font color="#CCCCCC"> emitted a constant time modular</font>

380
00:17:24,000 --> 00:17:28,200
exponentiation function<font color="#CCCCCC"> and instead for</font>

381
00:17:25,920 --> 00:17:30,140
the vulnerable<font color="#E5E5E5"> variant we also found a</font>

382
00:17:28,200 --> 00:17:33,870
substantial<font color="#CCCCCC"> number</font><font color="#E5E5E5"> of leaks there</font>

383
00:17:30,140 --> 00:17:35,010
<font color="#CCCCCC">despite the fact</font><font color="#E5E5E5"> that for instance RSA</font>

384
00:17:33,870 --> 00:17:38,189
introduces

385
00:17:35,010 --> 00:17:41,490
quite an amount of<font color="#CCCCCC"> non-determinism</font><font color="#E5E5E5"> for</font>

386
00:17:38,190 --> 00:17:43,670
instance stemming from the randomization

387
00:17:41,490 --> 00:17:46,170
in base<font color="#CCCCCC"> blending so</font><font color="#E5E5E5"> I have to query</font>

388
00:17:43,670 --> 00:17:47,910
random numbers I have<font color="#E5E5E5"> to</font><font color="#CCCCCC"> gather</font><font color="#E5E5E5"> entropy</font>

389
00:17:46,170 --> 00:17:50,190
and this causes<font color="#E5E5E5"> for instance in the</font>

390
00:17:47,910 --> 00:17:52,470
execution a lot of differences<font color="#CCCCCC"> that are</font>

391
00:17:50,190 --> 00:17:55,110
<font color="#E5E5E5">not critically or not directly related</font>

392
00:17:52,470 --> 00:17:57,090
<font color="#E5E5E5">to the</font><font color="#CCCCCC"> secret key</font><font color="#E5E5E5"> but we filter that</font>

393
00:17:55,110 --> 00:18:00,659
data automatically

394
00:17:57,090 --> 00:18:02,580
and we still revealed<font color="#E5E5E5"> those two backs</font>

395
00:18:00,660 --> 00:18:04,470
<font color="#E5E5E5">that we</font><font color="#CCCCCC"> also reported to organize</font>

396
00:18:02,580 --> 00:18:08,699
<font color="#E5E5E5">provide the patches and that has been</font>

397
00:18:04,470 --> 00:18:10,590
already fixed for a s<font color="#E5E5E5"> and E and all the</font>

398
00:18:08,700 --> 00:18:14,160
asymmetric<font color="#E5E5E5"> keys we loaded via PEM files</font>

399
00:18:10,590 --> 00:18:16,230
we found that<font color="#E5E5E5"> the key parsing function</font>

400
00:18:14,160 --> 00:18:20,340
that converted hex strings to<font color="#E5E5E5"> binary</font>

401
00:18:16,230 --> 00:18:23,190
format<font color="#CCCCCC"> also heavily leaks the key this</font>

402
00:18:20,340 --> 00:18:25,740
<font color="#E5E5E5">is so previous tools may not have found</font>

403
00:18:23,190 --> 00:18:29,520
this<font color="#E5E5E5"> because they didn't</font><font color="#CCCCCC"> analyze the</font>

404
00:18:25,740 --> 00:18:32,159
<font color="#CCCCCC">entire program execution from start to</font>

405
00:18:29,520 --> 00:18:35,870
end<font color="#E5E5E5"> but we say that this is no problem</font>

406
00:18:32,159 --> 00:18:40,620
this<font color="#E5E5E5"> is why we found those leaks in our</font>

407
00:18:35,870 --> 00:18:43,469
analysis<font color="#CCCCCC"> to give you some performance</font>

408
00:18:40,620 --> 00:18:44,820
numbers so basically data scales with

409
00:18:43,470 --> 00:18:46,740
the number of leaks or the number of

410
00:18:44,820 --> 00:18:50,129
differences<font color="#CCCCCC"> that I have to analyze so</font>

411
00:18:46,740 --> 00:18:53,309
leakage free implementations are done in

412
00:18:50,130 --> 00:18:56,250
a<font color="#CCCCCC"> couple</font><font color="#E5E5E5"> of seconds and RSA with quite a</font>

413
00:18:53,309 --> 00:18:59,418
<font color="#E5E5E5">number of way above 2000 differences</font>

414
00:18:56,250 --> 00:19:03,929
<font color="#E5E5E5">that we had to analyze</font><font color="#CCCCCC"> still is below</font>

415
00:18:59,419 --> 00:19:11,010
<font color="#E5E5E5">for CPU</font><font color="#CCCCCC"> hours below 4.5 gigabyte of RAM</font>

416
00:19:03,929 --> 00:19:11,370
and below<font color="#CCCCCC"> one gigabyte</font><font color="#E5E5E5"> of storage</font><font color="#CCCCCC"> all</font>

417
00:19:11,010 --> 00:19:14,879
<font color="#CCCCCC">right</font>

418
00:19:11,370 --> 00:19:16,500
the rori brings me to the<font color="#E5E5E5"> conclusion so</font>

419
00:19:14,880 --> 00:19:18,659
data is a tool<font color="#CCCCCC"> that helps</font><font color="#E5E5E5"> you find</font>

420
00:19:16,500 --> 00:19:20,549
address based leaks leaks<font color="#E5E5E5"> that can</font>

421
00:19:18,659 --> 00:19:22,200
eventually be exploited<font color="#E5E5E5"> via caches</font>

422
00:19:20,549 --> 00:19:25,440
theorem or other<font color="#E5E5E5"> micro architecture of</font>

423
00:19:22,200 --> 00:19:27,240
the<font color="#CCCCCC"> units we provide statistical</font>

424
00:19:25,440 --> 00:19:29,220
guarantees to reduce the number of false

425
00:19:27,240 --> 00:19:31,770
positives<font color="#CCCCCC"> and also deploy a number of</font>

426
00:19:29,220 --> 00:19:34,530
<font color="#E5E5E5">strategies</font><font color="#CCCCCC"> to reduce the number of force</font>

427
00:19:31,770 --> 00:19:39,320
negatives and<font color="#CCCCCC"> we also provide a</font><font color="#E5E5E5"> way</font><font color="#CCCCCC"> to</font>

428
00:19:34,530 --> 00:19:43,889
prioritize<font color="#E5E5E5"> leaks based on leakage models</font>

429
00:19:39,320 --> 00:19:46,370
we design data to<font color="#E5E5E5"> provide some benefits</font>

430
00:19:43,890 --> 00:19:48,330
for developers and<font color="#E5E5E5"> analysts so it is</font>

431
00:19:46,370 --> 00:19:50,969
automated<font color="#E5E5E5"> we don't need to annotate</font>

432
00:19:48,330 --> 00:19:54,240
anything we don't<font color="#E5E5E5"> need a source code and</font>

433
00:19:50,970 --> 00:19:55,890
once we start data it like processes

434
00:19:54,240 --> 00:19:58,500
through and gives us the<font color="#E5E5E5"> final report in</font>

435
00:19:55,890 --> 00:20:00,600
the end it<font color="#E5E5E5"> is rather efficient so</font><font color="#CCCCCC"> we can</font>

436
00:19:58,500 --> 00:20:03,330
actually<font color="#E5E5E5"> analyze interpreted code such</font>

437
00:20:00,600 --> 00:20:06,840
<font color="#CCCCCC">as Python and stay well within</font><font color="#E5E5E5"> the range</font>

438
00:20:03,330 --> 00:20:07,980
<font color="#E5E5E5">of commodity</font><font color="#CCCCCC"> Hardware and</font><font color="#E5E5E5"> it is also</font>

439
00:20:06,840 --> 00:20:10,949
<font color="#E5E5E5">practically</font>

440
00:20:07,980 --> 00:20:12,990
as we showed we found new

441
00:20:10,950 --> 00:20:16,500
vulnerabilities and<font color="#CCCCCC"> OpenSSL not</font>

442
00:20:12,990 --> 00:20:18,980
discovered so far<font color="#E5E5E5"> data is still</font>

443
00:20:16,500 --> 00:20:21,809
<font color="#CCCCCC">work-in-progress and</font><font color="#E5E5E5"> so we're designing</font>

444
00:20:18,980 --> 00:20:24,059
and implementing to improve usability it

445
00:20:21,809 --> 00:20:26,970
rapidly user interface some performance

446
00:20:24,059 --> 00:20:29,340
improvements<font color="#CCCCCC"> we're</font><font color="#E5E5E5"> also happy about any</font>

447
00:20:26,970 --> 00:20:31,350
like remarks or ideas or features<font color="#CCCCCC"> that</font>

448
00:20:29,340 --> 00:20:34,320
you would wish<font color="#CCCCCC"> for in a tool like data</font>

449
00:20:31,350 --> 00:20:36,449
<font color="#E5E5E5">and for this reason we</font><font color="#CCCCCC"> may date the open</font>

450
00:20:34,320 --> 00:20:39,750
<font color="#CCCCCC">source so you can download it very soon</font>

451
00:20:36,450 --> 00:20:42,270
from<font color="#E5E5E5"> the given github URL and with this</font>

452
00:20:39,750 --> 00:20:45,190
<font color="#E5E5E5">we thank you for your attention and</font>

453
00:20:42,270 --> 00:20:48,750
<font color="#CCCCCC">we're</font><font color="#E5E5E5"> happy to</font><font color="#CCCCCC"> answer</font><font color="#E5E5E5"> any questions</font>

454
00:20:45,190 --> 00:20:49,500
[Applause]

455
00:20:48,750 --> 00:20:53,600
[Music]

456
00:20:49,500 --> 00:20:56,340
[Applause]

457
00:20:53,600 --> 00:20:59,639
hi I<font color="#E5E5E5"> have two</font><font color="#CCCCCC"> questions</font><font color="#E5E5E5"> one quick</font>

458
00:20:56,340 --> 00:21:01,500
question<font color="#E5E5E5"> and did you</font><font color="#CCCCCC"> try to get the</font>

459
00:20:59,640 --> 00:21:04,470
secret key or which<font color="#E5E5E5"> extend you are</font>

460
00:21:01,500 --> 00:21:06,690
<font color="#E5E5E5">saying that there is a leak sorry again</font>

461
00:21:04,470 --> 00:21:09,210
nothing did you find try to find the

462
00:21:06,690 --> 00:21:12,440
secret key

463
00:21:09,210 --> 00:21:15,240
so you mean did<font color="#CCCCCC"> we actually</font><font color="#E5E5E5"> try it</font>

464
00:21:12,440 --> 00:21:16,590
<font color="#CCCCCC">through a check</font><font color="#E5E5E5"> so to mount an attack to</font>

465
00:21:15,240 --> 00:21:20,970
actually mount on<font color="#E5E5E5"> second</font><font color="#CCCCCC"> if</font><font color="#E5E5E5"> you tried</font>

466
00:21:16,590 --> 00:21:23,610
that<font color="#CCCCCC"> no so as far</font><font color="#E5E5E5"> as I know no we</font>

467
00:21:20,970 --> 00:21:28,320
<font color="#CCCCCC">haven't</font><font color="#E5E5E5"> tried that okay so my question</font>

468
00:21:23,610 --> 00:21:30,570
<font color="#CCCCCC">is</font><font color="#E5E5E5"> uh for this type of attack</font><font color="#CCCCCC"> our</font>

469
00:21:28,320 --> 00:21:33,809
<font color="#CCCCCC">ability for the environment of the</font>

470
00:21:30,570 --> 00:21:39,139
address<font color="#CCCCCC"> space randomization</font><font color="#E5E5E5"> you</font><font color="#CCCCCC"> know</font>

471
00:21:33,809 --> 00:21:42,030
will be affected<font color="#CCCCCC"> yeah yeah so I mean</font>

472
00:21:39,140 --> 00:21:44,870
since we are in an<font color="#E5E5E5"> evaluation context so</font>

473
00:21:42,030 --> 00:21:48,030
I want<font color="#E5E5E5"> to like evaluate my own software</font>

474
00:21:44,870 --> 00:21:51,239
<font color="#CCCCCC">it's not a problem</font><font color="#E5E5E5"> to turn off a SLR</font><font color="#CCCCCC"> and</font>

475
00:21:48,030 --> 00:21:53,160
<font color="#CCCCCC">this is what we did for the analysis but</font>

476
00:21:51,240 --> 00:21:55,320
it is to find the problem<font color="#E5E5E5"> right</font>

477
00:21:53,160 --> 00:21:56,730
in practice ears<font color="#E5E5E5"> alarm might be another</font>

478
00:21:55,320 --> 00:21:58,470
<font color="#E5E5E5">obstacle that an attacker has</font><font color="#CCCCCC"> to</font>

479
00:21:56,730 --> 00:21:59,850
overcome<font color="#CCCCCC"> but it doesn't change</font><font color="#E5E5E5"> the fact</font>

480
00:21:58,470 --> 00:22:00,960
<font color="#CCCCCC">that there is a problem</font><font color="#E5E5E5"> in the software</font>

481
00:21:59,850 --> 00:22:03,570
<font color="#CCCCCC">it it</font><font color="#E5E5E5"> needs to</font><font color="#CCCCCC"> be fixed</font>

482
00:22:00,960 --> 00:22:06,390
yep for<font color="#E5E5E5"> me of people</font><font color="#CCCCCC"> I have seen that</font>

483
00:22:03,570 --> 00:22:09,389
<font color="#E5E5E5">you basically turn down the a</font><font color="#CCCCCC"> sugar but</font>

484
00:22:06,390 --> 00:22:11,820
you<font color="#E5E5E5"> evaluate these approach to the</font><font color="#CCCCCC"> xeon</font>

485
00:22:09,390 --> 00:22:14,160
<font color="#E5E5E5">processor using modern compiler and most</font>

486
00:22:11,820 --> 00:22:15,370
of the modern comply enforce<font color="#E5E5E5"> the address</font>

487
00:22:14,160 --> 00:22:18,100
space<font color="#CCCCCC"> randomized</font>

488
00:22:15,370 --> 00:22:21,370
even<font color="#CCCCCC"> in tents</font><font color="#E5E5E5"> basically do that so how</font>

489
00:22:18,100 --> 00:22:27,370
can you justify<font color="#E5E5E5"> this approach by turn</font>

490
00:22:21,370 --> 00:22:29,768
down you're a<font color="#E5E5E5"> healer</font><font color="#CCCCCC"> so I mean if like</font>

491
00:22:27,370 --> 00:22:31,658
<font color="#E5E5E5">if I understand it correctly you say</font>

492
00:22:29,769 --> 00:22:34,690
that there is like software<font color="#E5E5E5"> out there</font>

493
00:22:31,659 --> 00:22:36,279
<font color="#E5E5E5">where I cannot like turn</font><font color="#CCCCCC"> off a SLR and I</font>

494
00:22:34,690 --> 00:22:37,179
have to live<font color="#E5E5E5"> with that in the evaluation</font>

495
00:22:36,279 --> 00:22:40,179
is<font color="#CCCCCC"> that correct</font>

496
00:22:37,179 --> 00:22:43,179
I mean basically<font color="#CCCCCC"> yes Euler is in force</font>

497
00:22:40,179 --> 00:22:46,570
for all modern<font color="#E5E5E5"> compiler and also the</font>

498
00:22:43,179 --> 00:22:49,059
<font color="#E5E5E5">process of that so yeah we are</font><font color="#CCCCCC"> doing</font>

499
00:22:46,570 --> 00:22:51,279
some sort<font color="#E5E5E5"> of a Dirks which we are turned</font>

500
00:22:49,059 --> 00:22:53,470
off the ashes<font color="#E5E5E5"> or so how can</font><font color="#CCCCCC"> you justify</font>

501
00:22:51,279 --> 00:22:56,159
<font color="#CCCCCC">I mean what is the real application for</font>

502
00:22:53,470 --> 00:23:00,999
that<font color="#E5E5E5"> this type of attack can</font><font color="#CCCCCC"> happen</font>

503
00:22:56,159 --> 00:23:04,960
<font color="#E5E5E5">because</font><font color="#CCCCCC"> I am done on my</font><font color="#E5E5E5"> Euler so just to</font>

504
00:23:00,999 --> 00:23:06,759
clarify<font color="#CCCCCC"> ASLR must not be turned off on</font>

505
00:23:04,960 --> 00:23:09,490
any like running or<font color="#CCCCCC"> production</font>

506
00:23:06,759 --> 00:23:11,919
<font color="#E5E5E5">production system so we only turn it off</font>

507
00:23:09,490 --> 00:23:13,840
for<font color="#E5E5E5"> the</font><font color="#CCCCCC"> evaluation of</font><font color="#E5E5E5"> the software so</font>

508
00:23:11,919 --> 00:23:17,169
that's<font color="#E5E5E5"> it so once we find</font><font color="#CCCCCC"> the leaks</font>

509
00:23:13,840 --> 00:23:19,299
you can like deploy your software<font color="#E5E5E5"> on</font>

510
00:23:17,169 --> 00:23:25,659
systems<font color="#E5E5E5"> with the</font><font color="#CCCCCC"> SLS there</font><font color="#E5E5E5"> is</font><font color="#CCCCCC"> no like</font>

511
00:23:19,299 --> 00:23:27,820
connection or relation at all<font color="#CCCCCC"> so</font><font color="#E5E5E5"> our</font>

512
00:23:25,659 --> 00:23:30,519
<font color="#E5E5E5">approach is really</font><font color="#CCCCCC"> to find leaks in</font><font color="#E5E5E5"> the</font>

513
00:23:27,820 --> 00:23:33,279
source<font color="#E5E5E5"> code so we give developers and</font>

514
00:23:30,519 --> 00:23:35,889
<font color="#CCCCCC">aides</font><font color="#E5E5E5"> to find the leakage and therefore</font>

515
00:23:33,279 --> 00:23:38,049
we try to<font color="#E5E5E5"> reduce any noise from the</font>

516
00:23:35,889 --> 00:23:40,449
operating<font color="#E5E5E5"> system</font><font color="#CCCCCC"> or so far that we</font>

517
00:23:38,049 --> 00:23:43,179
really can<font color="#CCCCCC"> in pinpoints</font><font color="#E5E5E5"> the leakage</font>

518
00:23:40,450 --> 00:23:45,220
origin in the source code<font color="#E5E5E5"> in practice</font>

519
00:23:43,179 --> 00:23:47,230
attacks might be hard to<font color="#E5E5E5"> do difference</font>

520
00:23:45,220 --> 00:23:49,480
if you architectures<font color="#E5E5E5"> and all stuff but</font>

521
00:23:47,230 --> 00:23:51,990
we really want to<font color="#E5E5E5"> find the problems in</font>

522
00:23:49,480 --> 00:23:51,990
<font color="#CCCCCC">the source code</font>

523
00:23:57,030 --> 00:24:00,220
[Applause]

