1
00:00:11,320 --> 00:00:16,820
<font color="#CCCCCC">hmm</font><font color="#E5E5E5"> okay hi everyone my name is Sam</font>

2
00:00:15,200 --> 00:00:20,390
<font color="#CCCCCC">Silvestro</font><font color="#E5E5E5"> today I'll</font><font color="#CCCCCC"> be</font><font color="#E5E5E5"> presenting</font>

3
00:00:16,820 --> 00:00:22,040
garter<font color="#E5E5E5"> a tunable secure</font><font color="#CCCCCC"> alligator</font><font color="#E5E5E5"> this</font>

4
00:00:20,390 --> 00:00:23,960
<font color="#E5E5E5">work was a collaboration with my lab</font>

5
00:00:22,040 --> 00:00:26,540
mates<font color="#CCCCCC"> Hong Yu Liu and Tian Yu Liu as</font>

6
00:00:23,960 --> 00:00:31,790
well as<font color="#E5E5E5"> dr. Lin of Ohio State University</font>

7
00:00:26,540 --> 00:00:35,090
and<font color="#E5E5E5"> my advisor dr.</font><font color="#CCCCCC"> Tong</font><font color="#E5E5E5"> Peng Lu so I'll</font>

8
00:00:31,790 --> 00:00:38,269
start by briefly<font color="#E5E5E5"> resizing some of the</font>

9
00:00:35,090 --> 00:00:40,610
common<font color="#CCCCCC"> keep vulnerabilities so first we</font>

10
00:00:38,270 --> 00:00:43,100
<font color="#E5E5E5">have buffer ovary which can result in</font>

11
00:00:40,610 --> 00:00:45,410
information<font color="#E5E5E5"> leakage</font><font color="#CCCCCC"> this occurs</font><font color="#E5E5E5"> when</font><font color="#CCCCCC"> I</font>

12
00:00:43,100 --> 00:00:47,989
read the length of a read goes beyond

13
00:00:45,410 --> 00:00:49,190
the end of an object<font color="#CCCCCC"> a good example of</font>

14
00:00:47,989 --> 00:00:51,468
<font color="#E5E5E5">this</font><font color="#CCCCCC"> problem is the heartbleed</font>

15
00:00:49,190 --> 00:00:53,420
vulnerability in open<font color="#CCCCCC"> SSL that was</font>

16
00:00:51,469 --> 00:00:55,159
discovered<font color="#CCCCCC"> a</font><font color="#E5E5E5"> few years</font><font color="#CCCCCC"> ago</font><font color="#E5E5E5"> which</font>

17
00:00:53,420 --> 00:00:58,370
affected millions<font color="#E5E5E5"> of users private</font>

18
00:00:55,159 --> 00:01:00,469
information<font color="#E5E5E5"> next</font><font color="#CCCCCC"> is use after free</font><font color="#E5E5E5"> as</font>

19
00:00:58,370 --> 00:01:02,329
the name implies this occurs when<font color="#E5E5E5"> an</font>

20
00:01:00,469 --> 00:01:03,879
application<font color="#E5E5E5"> frees an object but then</font>

21
00:01:02,329 --> 00:01:06,170
continues<font color="#CCCCCC"> to use</font><font color="#E5E5E5"> it</font>

22
00:01:03,879 --> 00:01:08,810
buffer overflow I'm sure you're familiar

23
00:01:06,170 --> 00:01:10,820
with the stack based buffer overflow<font color="#E5E5E5"> and</font>

24
00:01:08,810 --> 00:01:12,260
<font color="#E5E5E5">on the heap it looks very</font><font color="#CCCCCC"> similar except</font>

25
00:01:10,820 --> 00:01:14,509
the<font color="#E5E5E5"> attacker may be looking for</font>

26
00:01:12,260 --> 00:01:16,040
<font color="#CCCCCC">something</font><font color="#E5E5E5"> like a function</font><font color="#CCCCCC"> pointer</font><font color="#E5E5E5"> in a</font>

27
00:01:14,510 --> 00:01:18,920
structure that's allocated<font color="#CCCCCC"> to the key</font>

28
00:01:16,040 --> 00:01:21,320
<font color="#E5E5E5">that</font><font color="#CCCCCC"> they can attack and then finally</font>

29
00:01:18,920 --> 00:01:24,290
double free refers to when<font color="#E5E5E5"> the heap is a</font>

30
00:01:21,320 --> 00:01:26,240
heap object is freed more than once and

31
00:01:24,290 --> 00:01:28,610
an invalid<font color="#CCCCCC"> free occurs when an address</font>

32
00:01:26,240 --> 00:01:32,479
<font color="#E5E5E5">not associated with the valid heap</font>

33
00:01:28,610 --> 00:01:36,710
object is passed into<font color="#E5E5E5"> the allocation</font>

34
00:01:32,480 --> 00:01:38,480
de-allocation functions now these<font color="#E5E5E5"> last</font>

35
00:01:36,710 --> 00:01:41,089
three can produce unexpected<font color="#E5E5E5"> results</font>

36
00:01:38,480 --> 00:01:45,320
anything from a program crash<font color="#E5E5E5"> to</font><font color="#CCCCCC"> hijack</font>

37
00:01:41,090 --> 00:01:47,450
control flow so<font color="#E5E5E5"> to show where we are</font>

38
00:01:45,320 --> 00:01:49,009
<font color="#E5E5E5">with these vulnerabilities right now you</font>

39
00:01:47,450 --> 00:01:50,710
can see the number<font color="#CCCCCC"> of occurrences for</font>

40
00:01:49,010 --> 00:01:52,970
each of these in<font color="#E5E5E5"> just the</font><font color="#CCCCCC"> past year</font>

41
00:01:50,710 --> 00:01:55,460
<font color="#E5E5E5">according</font><font color="#CCCCCC"> to nist national</font>

42
00:01:52,970 --> 00:01:57,350
vulnerabilities database not

43
00:01:55,460 --> 00:01:59,720
surprisingly buffer overflows<font color="#CCCCCC"> topped the</font>

44
00:01:57,350 --> 00:02:02,030
list<font color="#CCCCCC"> but interestingly youssef to free</font>

45
00:01:59,720 --> 00:02:03,710
is in the runner-up<font color="#CCCCCC"> spot</font><font color="#E5E5E5"> and a recent</font>

46
00:02:02,030 --> 00:02:05,480
<font color="#E5E5E5">study showed that use after free errors</font>

47
00:02:03,710 --> 00:02:08,060
are the most severe vulnerabilities of

48
00:02:05,480 --> 00:02:10,280
<font color="#CCCCCC">the chrome chromium browser</font><font color="#E5E5E5"> in terms</font><font color="#CCCCCC"> of</font>

49
00:02:08,060 --> 00:02:14,239
both the number of<font color="#CCCCCC"> occurrences</font><font color="#E5E5E5"> and the</font>

50
00:02:10,280 --> 00:02:15,920
severity<font color="#CCCCCC"> of security impacts typically</font>

51
00:02:14,239 --> 00:02:17,120
though the memory allocator forms the

52
00:02:15,920 --> 00:02:17,858
front line<font color="#E5E5E5"> of defense against these</font>

53
00:02:17,120 --> 00:02:20,060
vulnerabilities

54
00:02:17,859 --> 00:02:21,760
however the<font color="#CCCCCC"> linux allocator doesn't</font>

55
00:02:20,060 --> 00:02:24,560
provide any security guarantee

56
00:02:21,760 --> 00:02:26,149
because of this we<font color="#E5E5E5"> have several</font><font color="#CCCCCC"> secure a</font>

57
00:02:24,560 --> 00:02:28,190
locator<font color="#CCCCCC"> that were designed</font><font color="#E5E5E5"> to alleviate</font>

58
00:02:26,150 --> 00:02:32,209
these problems<font color="#CCCCCC"> each with a varying level</font>

59
00:02:28,190 --> 00:02:33,709
<font color="#CCCCCC">of security so first we should talk</font>

60
00:02:32,209 --> 00:02:38,450
about<font color="#CCCCCC"> the</font><font color="#E5E5E5"> default Linux allocator and</font>

61
00:02:33,709 --> 00:02:40,129
<font color="#E5E5E5">why we need secure alligators the</font><font color="#CCCCCC"> Linux</font>

62
00:02:38,450 --> 00:02:42,319
alligator was designed<font color="#CCCCCC"> to perform well</font>

63
00:02:40,129 --> 00:02:46,099
<font color="#E5E5E5">as a general purpose alligator and</font>

64
00:02:42,319 --> 00:02:48,890
combines bump pointers and free lists<font color="#E5E5E5"> to</font>

65
00:02:46,099 --> 00:02:50,720
manage<font color="#CCCCCC"> chief objects so a free list is</font>

66
00:02:48,890 --> 00:02:53,359
simply a linked list of<font color="#E5E5E5"> D allocated</font>

67
00:02:50,720 --> 00:02:55,280
objects and a bump pointer points to<font color="#E5E5E5"> the</font>

68
00:02:53,360 --> 00:02:57,859
top of the heap<font color="#E5E5E5"> which represents the</font>

69
00:02:55,280 --> 00:02:59,599
next<font color="#E5E5E5"> unused portion of the key so I have</font>

70
00:02:57,859 --> 00:03:01,700
a<font color="#E5E5E5"> simple example</font><font color="#CCCCCC"> here</font><font color="#E5E5E5"> of a bump pointer</font>

71
00:02:59,599 --> 00:03:04,488
<font color="#E5E5E5">modeled after the</font><font color="#CCCCCC"> Linux alligator</font><font color="#E5E5E5"> and</font>

72
00:03:01,700 --> 00:03:06,679
you can see that this state represents

73
00:03:04,489 --> 00:03:11,629
the bump pointer immediately prior<font color="#CCCCCC"> to an</font>

74
00:03:06,680 --> 00:03:13,280
allocation<font color="#E5E5E5"> request and this is after so</font>

75
00:03:11,629 --> 00:03:18,560
<font color="#E5E5E5">you can see this is a very fast and</font>

76
00:03:13,280 --> 00:03:20,659
simple mechanism<font color="#E5E5E5"> but but the problem is</font>

77
00:03:18,560 --> 00:03:22,849
<font color="#E5E5E5">that the default</font><font color="#CCCCCC"> Linux alligator</font><font color="#E5E5E5"> wasn't</font>

78
00:03:20,659 --> 00:03:24,409
designed for<font color="#E5E5E5"> security purposes and one</font>

79
00:03:22,849 --> 00:03:28,099
of the<font color="#E5E5E5"> issues is</font><font color="#CCCCCC"> that it prepends</font>

80
00:03:24,409 --> 00:03:30,168
metadata before actual heap objects so

81
00:03:28,099 --> 00:03:32,179
you<font color="#E5E5E5"> can see from this illustration the</font>

82
00:03:30,169 --> 00:03:34,400
metadata contains the previous object

83
00:03:32,180 --> 00:03:36,829
size as well<font color="#E5E5E5"> as</font><font color="#CCCCCC"> the current</font><font color="#E5E5E5"> object size</font>

84
00:03:34,400 --> 00:03:38,540
and there's also some status bits

85
00:03:36,829 --> 00:03:41,150
embedded in there which I made it just

86
00:03:38,540 --> 00:03:43,578
<font color="#E5E5E5">for</font><font color="#CCCCCC"> a clarity</font><font color="#E5E5E5"> and in the free space it</font>

87
00:03:41,150 --> 00:03:45,650
stores<font color="#E5E5E5"> its free list pointers it</font>

88
00:03:43,579 --> 00:03:47,000
<font color="#E5E5E5">typically uses doubly linked free lists</font>

89
00:03:45,650 --> 00:03:49,220
<font color="#CCCCCC">which</font><font color="#E5E5E5"> is why there's a forward and</font>

90
00:03:47,000 --> 00:03:52,609
backward pointer there but you can see a

91
00:03:49,220 --> 00:03:54,769
problem<font color="#CCCCCC"> if an overflow occurs it can not</font>

92
00:03:52,609 --> 00:03:56,989
<font color="#CCCCCC">only crash the size and status metadata</font>

93
00:03:54,769 --> 00:03:58,609
<font color="#E5E5E5">but it can manipulate those free list</font>

94
00:03:56,989 --> 00:03:59,780
pointers which can give<font color="#E5E5E5"> the attacker</font>

95
00:03:58,609 --> 00:04:03,139
some control<font color="#CCCCCC"> over the allocation</font>

96
00:03:59,780 --> 00:04:05,209
functions<font color="#E5E5E5"> also</font><font color="#CCCCCC"> it provides</font><font color="#E5E5E5"> no</font>

97
00:04:03,139 --> 00:04:07,160
randomization<font color="#E5E5E5"> which makes it easy for</font><font color="#CCCCCC"> an</font>

98
00:04:05,209 --> 00:04:09,250
attacker<font color="#CCCCCC"> to determine which object</font>

99
00:04:07,160 --> 00:04:12,620
objects will come up for<font color="#E5E5E5"> reuse next and</font>

100
00:04:09,250 --> 00:04:15,379
then lastly it has<font color="#E5E5E5"> poor handling of</font>

101
00:04:12,620 --> 00:04:18,139
double<font color="#E5E5E5"> and invalid</font><font color="#CCCCCC"> fries</font><font color="#E5E5E5"> so as an</font>

102
00:04:15,379 --> 00:04:19,909
example if the metadata were crashed<font color="#E5E5E5"> the</font>

103
00:04:18,139 --> 00:04:21,769
<font color="#E5E5E5">alligator is</font><font color="#CCCCCC"> unable</font><font color="#E5E5E5"> to check the object</font>

104
00:04:19,910 --> 00:04:24,320
status<font color="#E5E5E5"> which can lead to</font><font color="#CCCCCC"> the same object</font>

105
00:04:21,769 --> 00:04:26,180
<font color="#E5E5E5">being utilized more than once and could</font>

106
00:04:24,320 --> 00:04:29,419
ultimately result<font color="#CCCCCC"> in hijacked control</font>

107
00:04:26,180 --> 00:04:31,250
flow so<font color="#E5E5E5"> as you can see here the default</font>

108
00:04:29,419 --> 00:04:33,169
<font color="#E5E5E5">Linux alligator can't provide a good</font>

109
00:04:31,250 --> 00:04:35,300
defense<font color="#E5E5E5"> which is why we have secured</font>

110
00:04:33,169 --> 00:04:39,139
alligators which are designed to improve

111
00:04:35,300 --> 00:04:41,030
the<font color="#E5E5E5"> situation now a few of these</font>

112
00:04:39,139 --> 00:04:44,960
existing alligators are the OpenBSD

113
00:04:41,030 --> 00:04:46,789
<font color="#E5E5E5">alligator</font><font color="#CCCCCC"> dive harder and free guard now</font>

114
00:04:44,960 --> 00:04:49,039
each of these alligators are known as

115
00:04:46,789 --> 00:04:50,960
<font color="#E5E5E5">bit bob style alligators right which was</font>

116
00:04:49,039 --> 00:04:53,568
<font color="#CCCCCC">mentioned</font><font color="#E5E5E5"> due to their choice of memory</font>

117
00:04:50,960 --> 00:04:55,609
layout<font color="#CCCCCC"> bib upstanding</font><font color="#E5E5E5"> for big bag</font><font color="#CCCCCC"> of</font>

118
00:04:53,569 --> 00:04:58,159
pages in which a bag is just<font color="#E5E5E5"> a</font>

119
00:04:55,610 --> 00:05:00,530
<font color="#CCCCCC">collection</font><font color="#E5E5E5"> of pages</font><font color="#CCCCCC"> that store objects</font>

120
00:04:58,159 --> 00:05:02,599
of the same size<font color="#CCCCCC"> class so for example we</font>

121
00:05:00,530 --> 00:05:05,809
<font color="#E5E5E5">might</font><font color="#CCCCCC"> have a bag</font><font color="#E5E5E5"> for 16 byte objects</font><font color="#CCCCCC"> a</font>

122
00:05:02,599 --> 00:05:08,300
bag for 32 byte objects<font color="#E5E5E5"> you know 64 and</font>

123
00:05:05,810 --> 00:05:10,400
so on<font color="#E5E5E5"> in addition</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> bebop they also</font>

124
00:05:08,300 --> 00:05:12,409
segregate metadata away from the actual

125
00:05:10,400 --> 00:05:15,440
heap which helps mitigate against

126
00:05:12,409 --> 00:05:17,569
metadata based attacks now each of these

127
00:05:15,440 --> 00:05:20,449
alligators also feature randomization

128
00:05:17,569 --> 00:05:23,000
for example die harder has log n<font color="#E5E5E5"> bits of</font>

129
00:05:20,449 --> 00:05:26,030
entropy<font color="#E5E5E5"> where n is the</font><font color="#CCCCCC"> number of</font><font color="#E5E5E5"> free</font>

130
00:05:23,000 --> 00:05:28,129
objects in a given size<font color="#E5E5E5"> class</font><font color="#CCCCCC"> OpenBSD</font>

131
00:05:26,030 --> 00:05:30,799
<font color="#CCCCCC">ranges from two to ten depending</font><font color="#E5E5E5"> on the</font>

132
00:05:28,129 --> 00:05:33,199
particular size class and free guard has

133
00:05:30,800 --> 00:05:36,590
a constant two bits<font color="#E5E5E5"> which</font><font color="#CCCCCC"> is the same</font>

134
00:05:33,199 --> 00:05:38,090
across all the size classes now as an

135
00:05:36,590 --> 00:05:41,119
aside<font color="#E5E5E5"> each of these alligators offer</font>

136
00:05:38,090 --> 00:05:43,250
many good security features but<font color="#CCCCCC"> OpenBSD</font>

137
00:05:41,120 --> 00:05:46,340
<font color="#CCCCCC">and die harder in particular can also</font>

138
00:05:43,250 --> 00:05:47,120
experience<font color="#E5E5E5"> high performance overhead</font><font color="#CCCCCC"> so</font>

139
00:05:46,340 --> 00:05:49,400
as you<font color="#E5E5E5"> can</font><font color="#CCCCCC"> see</font>

140
00:05:47,120 --> 00:05:52,969
OpenBSD<font color="#E5E5E5"> had an average runtime</font><font color="#CCCCCC"> overhead</font>

141
00:05:49,400 --> 00:05:55,909
of<font color="#CCCCCC"> 31%</font><font color="#E5E5E5"> in our</font><font color="#CCCCCC"> evaluation and die harder</font>

142
00:05:52,969 --> 00:06:02,719
<font color="#CCCCCC">metric</font><font color="#E5E5E5"> 74% but actually showed up to</font>

143
00:05:55,909 --> 00:06:04,580
<font color="#E5E5E5">nine times in the worst case so after</font>

144
00:06:02,719 --> 00:06:06,680
<font color="#E5E5E5">analyzing the allocation entropy for</font>

145
00:06:04,580 --> 00:06:09,680
each of<font color="#E5E5E5"> these alligators</font><font color="#CCCCCC"> you can see the</font>

146
00:06:06,680 --> 00:06:12,800
problem visualized in this chart<font color="#E5E5E5"> first</font>

147
00:06:09,680 --> 00:06:14,659
<font color="#E5E5E5">they each either exhibit low entropy</font>

148
00:06:12,800 --> 00:06:17,900
<font color="#E5E5E5">like free guard with its constant two</font>

149
00:06:14,659 --> 00:06:20,539
bits or unstable entropy like<font color="#CCCCCC"> OpenBSD</font>

150
00:06:17,900 --> 00:06:22,638
<font color="#CCCCCC">and die harder where the entropy starts</font>

151
00:06:20,539 --> 00:06:27,560
to drop precipitously as we move toward

152
00:06:22,639 --> 00:06:30,110
<font color="#E5E5E5">larger and larger</font><font color="#CCCCCC"> size classes so let's</font>

153
00:06:27,560 --> 00:06:32,719
<font color="#E5E5E5">look</font><font color="#CCCCCC"> at die harder die harder always</font>

154
00:06:30,110 --> 00:06:34,159
<font color="#E5E5E5">chooses one object from among all the</font>

155
00:06:32,719 --> 00:06:36,830
<font color="#CCCCCC">available objects in the size class</font>

156
00:06:34,159 --> 00:06:39,289
<font color="#E5E5E5">however the bags hold fewer and fewer</font>

157
00:06:36,830 --> 00:06:41,479
objects<font color="#E5E5E5"> as we increase the</font><font color="#CCCCCC"> size of the</font>

158
00:06:39,289 --> 00:06:43,339
objects in them<font color="#E5E5E5"> so unfortunately this</font>

159
00:06:41,479 --> 00:06:45,109
means<font color="#E5E5E5"> the allocation entropy will</font>

160
00:06:43,339 --> 00:06:47,870
decrease as cross the size classes like

161
00:06:45,110 --> 00:06:48,889
we saw<font color="#CCCCCC"> also it can take a very long time</font>

162
00:06:47,870 --> 00:06:51,020
to perform

163
00:06:48,889 --> 00:06:52,490
the search for<font color="#E5E5E5"> an available object</font>

164
00:06:51,020 --> 00:06:54,740
<font color="#CCCCCC">because there</font><font color="#E5E5E5"> can be a high probability</font>

165
00:06:52,490 --> 00:06:57,050
you'll<font color="#CCCCCC"> select an object that's</font><font color="#E5E5E5"> already</font>

166
00:06:54,740 --> 00:06:59,240
in use<font color="#E5E5E5"> so we can end up repeating this</font>

167
00:06:57,050 --> 00:07:02,750
process<font color="#E5E5E5"> of random checking over and over</font>

168
00:06:59,240 --> 00:07:05,030
again<font color="#CCCCCC"> and</font><font color="#E5E5E5"> finally</font><font color="#CCCCCC"> its security is bound</font>

169
00:07:02,750 --> 00:07:07,130
to its specific<font color="#E5E5E5"> design which means it's</font>

170
00:07:05,030 --> 00:07:09,169
<font color="#E5E5E5">not flexible</font><font color="#CCCCCC"> so this leads us to the</font>

171
00:07:07,130 --> 00:07:13,930
<font color="#CCCCCC">motivation for</font><font color="#E5E5E5"> an alligator that's</font>

172
00:07:09,169 --> 00:07:13,930
designed<font color="#E5E5E5"> to be both reliable and tunable</font>

173
00:07:13,960 --> 00:07:19,099
so for an alligator<font color="#E5E5E5"> to</font><font color="#CCCCCC"> offer</font><font color="#E5E5E5"> reliable</font>

174
00:07:16,820 --> 00:07:21,800
security<font color="#E5E5E5"> we would like it</font><font color="#CCCCCC"> to provide</font>

175
00:07:19,100 --> 00:07:24,949
stable randomization entropy<font color="#E5E5E5"> across all</font>

176
00:07:21,800 --> 00:07:27,380
size classes inputs execution phases and

177
00:07:24,949 --> 00:07:29,330
applications this would mean that<font color="#E5E5E5"> the</font>

178
00:07:27,380 --> 00:07:31,430
<font color="#E5E5E5">user should</font><font color="#CCCCCC"> be</font><font color="#E5E5E5"> able to precisely specify</font>

179
00:07:29,330 --> 00:07:33,320
a lower bound for<font color="#E5E5E5"> the entropy and the</font>

180
00:07:31,430 --> 00:07:35,560
alligator<font color="#E5E5E5"> will guarantee</font><font color="#CCCCCC"> to provide at</font>

181
00:07:33,320 --> 00:07:38,840
<font color="#CCCCCC">least this minimum level of security</font>

182
00:07:35,560 --> 00:07:40,940
<font color="#E5E5E5">also tunable security refers to the</font>

183
00:07:38,840 --> 00:07:42,710
alligators ability to be adjustable

184
00:07:40,940 --> 00:07:44,780
<font color="#E5E5E5">based on the user's particular</font>

185
00:07:42,710 --> 00:07:47,000
performance budget and their<font color="#E5E5E5"> security</font>

186
00:07:44,780 --> 00:07:49,008
needs<font color="#E5E5E5"> so if I use</font><font color="#CCCCCC"> ten bits</font><font color="#E5E5E5"> and the</font>

187
00:07:47,000 --> 00:07:50,720
memory overhead<font color="#E5E5E5"> is too large then the</font>

188
00:07:49,009 --> 00:07:54,590
<font color="#CCCCCC">tunability will allow me to tailor my</font>

189
00:07:50,720 --> 00:07:56,840
security to my<font color="#E5E5E5"> particular environment so</font>

190
00:07:54,590 --> 00:07:58,789
<font color="#E5E5E5">to achieve these goals</font><font color="#CCCCCC"> we</font><font color="#E5E5E5"> need to talk</font>

191
00:07:56,840 --> 00:08:02,210
<font color="#CCCCCC">about how we can</font><font color="#E5E5E5"> achieve</font><font color="#CCCCCC"> specific a</font>

192
00:07:58,789 --> 00:08:03,800
<font color="#CCCCCC">specific level</font><font color="#E5E5E5"> of entropy so a basic</font>

193
00:08:02,210 --> 00:08:05,900
<font color="#E5E5E5">approach to this</font><font color="#CCCCCC"> problem might be</font><font color="#E5E5E5"> to</font>

194
00:08:03,800 --> 00:08:08,389
simply use<font color="#CCCCCC"> an array of a particular size</font>

195
00:08:05,900 --> 00:08:10,549
which will act as<font color="#E5E5E5"> an object buffer for</font>

196
00:08:08,389 --> 00:08:13,760
example if we populated<font color="#E5E5E5"> this array with</font>

197
00:08:10,550 --> 00:08:15,229
256 objects<font color="#E5E5E5"> then randomly choosing one</font>

198
00:08:13,760 --> 00:08:17,930
from amongst them would give us<font color="#CCCCCC"> eight</font>

199
00:08:15,229 --> 00:08:20,030
bits of entropy<font color="#CCCCCC"> of course this</font>

200
00:08:17,930 --> 00:08:22,760
introduces<font color="#E5E5E5"> a couple of challenges</font><font color="#CCCCCC"> first</font>

201
00:08:20,030 --> 00:08:24,770
how do we<font color="#E5E5E5"> handle the allocations</font><font color="#CCCCCC"> more</font>

202
00:08:22,760 --> 00:08:26,539
specifically how do we<font color="#E5E5E5"> avoid searching</font>

203
00:08:24,770 --> 00:08:29,150
for a position<font color="#E5E5E5"> in the buffer in which to</font>

204
00:08:26,539 --> 00:08:31,669
place the<font color="#CCCCCC"> freed object-- secondly how do</font>

205
00:08:29,150 --> 00:08:33,740
<font color="#CCCCCC">we avoid the issue of excessive random</font>

206
00:08:31,669 --> 00:08:35,770
check cycles when trying to<font color="#E5E5E5"> find an</font>

207
00:08:33,740 --> 00:08:38,810
<font color="#CCCCCC">available object in the buffer</font><font color="#E5E5E5"> and</font>

208
00:08:35,770 --> 00:08:41,029
thirdly how do we provide a stable<font color="#E5E5E5"> level</font>

209
00:08:38,809 --> 00:08:43,250
<font color="#E5E5E5">of entropy without being</font><font color="#CCCCCC"> required to</font>

210
00:08:41,029 --> 00:08:45,350
<font color="#E5E5E5">repopulate the buffer after every</font>

211
00:08:43,250 --> 00:08:46,940
allocation because<font color="#CCCCCC"> in this example we</font>

212
00:08:45,350 --> 00:08:50,320
would need<font color="#E5E5E5"> to maintain that full set of</font>

213
00:08:46,940 --> 00:08:50,320
256 objects

214
00:08:51,889 --> 00:08:57,290
so in<font color="#E5E5E5"> order</font><font color="#CCCCCC"> to address the first</font><font color="#E5E5E5"> issue</font>

215
00:08:54,810 --> 00:08:59,279
concerning handling<font color="#CCCCCC"> deallocations</font>

216
00:08:57,290 --> 00:09:02,010
<font color="#CCCCCC">gardener maintains a separate</font>

217
00:08:59,279 --> 00:09:03,260
<font color="#CCCCCC">deallocation buffer</font><font color="#E5E5E5"> every thread has</font><font color="#CCCCCC"> a</font>

218
00:09:02,010 --> 00:09:06,240
pair of allocation and de-allocation

219
00:09:03,260 --> 00:09:08,819
buffers for each size class so for

220
00:09:06,240 --> 00:09:11,250
<font color="#E5E5E5">example in a particular thread the 16</font>

221
00:09:08,820 --> 00:09:13,589
<font color="#CCCCCC">bite size class has a pair of buffers so</font>

222
00:09:11,250 --> 00:09:16,199
just the 32 by class and and so on

223
00:09:13,589 --> 00:09:18,209
so this<font color="#CCCCCC"> the allocation buffer gives us</font>

224
00:09:16,199 --> 00:09:20,670
the ability<font color="#E5E5E5"> to</font><font color="#CCCCCC"> provide constant</font><font color="#E5E5E5"> time</font><font color="#CCCCCC"> T</font>

225
00:09:18,209 --> 00:09:23,040
allocations<font color="#CCCCCC"> in the</font><font color="#E5E5E5"> common case because</font>

226
00:09:20,670 --> 00:09:24,689
we manage it as a circular<font color="#CCCCCC"> buffer</font><font color="#E5E5E5"> and</font>

227
00:09:23,040 --> 00:09:27,660
the<font color="#E5E5E5"> newly freed objects just inserted at</font>

228
00:09:24,690 --> 00:09:29,970
the<font color="#E5E5E5"> head the</font><font color="#CCCCCC"> second</font><font color="#E5E5E5"> challenge was how</font><font color="#CCCCCC"> to</font>

229
00:09:27,660 --> 00:09:32,279
provide<font color="#E5E5E5"> a minimum a bits of user</font>

230
00:09:29,970 --> 00:09:34,410
<font color="#CCCCCC">spence's specified entropy</font><font color="#E5E5E5"> without being</font>

231
00:09:32,279 --> 00:09:37,220
<font color="#CCCCCC">required to refill the allocation buffer</font>

232
00:09:34,410 --> 00:09:40,290
<font color="#E5E5E5">after every satisfied allocation request</font>

233
00:09:37,220 --> 00:09:42,990
<font color="#CCCCCC">so for this we use a buffer that's twice</font>

234
00:09:40,290 --> 00:09:45,029
the size<font color="#E5E5E5"> necessary to accommodate a bits</font>

235
00:09:42,990 --> 00:09:47,699
<font color="#E5E5E5">so in other words we have a buffer</font>

236
00:09:45,029 --> 00:09:49,320
capacity<font color="#E5E5E5"> of</font><font color="#CCCCCC"> 2 to</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> II plus 1 objects</font>

237
00:09:47,699 --> 00:09:53,399
and we ensure that<font color="#E5E5E5"> we never fall below</font>

238
00:09:49,320 --> 00:09:55,949
<font color="#E5E5E5">half that level and the last challenge</font>

239
00:09:53,399 --> 00:09:58,410
concerned how we would avoid excessive

240
00:09:55,949 --> 00:10:00,209
checking cycles during allocations<font color="#E5E5E5"> due</font>

241
00:09:58,410 --> 00:10:02,430
<font color="#E5E5E5">to that</font><font color="#CCCCCC"> probability</font><font color="#E5E5E5"> of</font><font color="#CCCCCC"> choosing an empty</font>

242
00:10:00,209 --> 00:10:03,779
slot in the allocation buffer<font color="#E5E5E5"> which of</font>

243
00:10:02,430 --> 00:10:06,209
course<font color="#E5E5E5"> as more and more objects are</font>

244
00:10:03,779 --> 00:10:08,510
consumed<font color="#E5E5E5"> and taken out</font><font color="#CCCCCC"> of the buffer the</font>

245
00:10:06,209 --> 00:10:11,130
likelihood of that happening increases

246
00:10:08,510 --> 00:10:13,470
for this we divide the allocation buffer

247
00:10:11,130 --> 00:10:15,660
into eight regions<font color="#CCCCCC"> so</font><font color="#E5E5E5"> we can test each</font>

248
00:10:13,470 --> 00:10:17,389
region as a whole<font color="#CCCCCC"> unit without having to</font>

249
00:10:15,660 --> 00:10:20,010
check<font color="#E5E5E5"> each and</font><font color="#CCCCCC"> every object</font><font color="#E5E5E5"> inside of it</font>

250
00:10:17,389 --> 00:10:22,680
<font color="#E5E5E5">also</font><font color="#CCCCCC"> when</font><font color="#E5E5E5"> we do end up selecting an</font>

251
00:10:20,010 --> 00:10:24,930
empty slot<font color="#E5E5E5"> rather than just continuing</font>

252
00:10:22,680 --> 00:10:27,209
<font color="#CCCCCC">to try random</font><font color="#E5E5E5"> choices indefinitely we</font>

253
00:10:24,930 --> 00:10:29,609
perform a<font color="#CCCCCC"> forward walk from the current</font>

254
00:10:27,209 --> 00:10:32,069
location<font color="#CCCCCC"> and you</font><font color="#E5E5E5"> can see from</font><font color="#CCCCCC"> the</font>

255
00:10:29,610 --> 00:10:34,680
diagram<font color="#CCCCCC"> that the allocation buffer will</font>

256
00:10:32,069 --> 00:10:36,899
perform its filling step from either the

257
00:10:34,680 --> 00:10:38,969
D allocation buffer or<font color="#E5E5E5"> the top of the</font>

258
00:10:36,899 --> 00:10:42,930
heap if not enough freed objects are

259
00:10:38,970 --> 00:10:44,750
available so this<font color="#E5E5E5"> design actually allows</font>

260
00:10:42,930 --> 00:10:47,399
us<font color="#CCCCCC"> to provide</font><font color="#E5E5E5"> both tunable heap</font>

261
00:10:44,750 --> 00:10:50,899
over-provisioning and random guard pages

262
00:10:47,399 --> 00:10:50,899
to which we'll talk<font color="#E5E5E5"> about next</font>

263
00:10:53,069 --> 00:10:58,569
so<font color="#CCCCCC"> Heep over-provisioning is an</font>

264
00:10:56,289 --> 00:11:00,399
<font color="#CCCCCC">allocator feature</font><font color="#E5E5E5"> where some portion of</font>

265
00:10:58,569 --> 00:11:02,949
<font color="#E5E5E5">the</font><font color="#CCCCCC"> heap objects are dedicated to never</font>

266
00:11:00,399 --> 00:11:05,349
being<font color="#E5E5E5"> used the idea here is</font><font color="#CCCCCC"> to</font>

267
00:11:02,949 --> 00:11:08,079
interleave this unused space among the

268
00:11:05,349 --> 00:11:10,539
<font color="#E5E5E5">normal heap data so if an overflow were</font>

269
00:11:08,079 --> 00:11:12,339
to occur hopefully it would be<font color="#E5E5E5"> contained</font>

270
00:11:10,539 --> 00:11:15,369
within<font color="#CCCCCC"> one of</font><font color="#E5E5E5"> these</font><font color="#CCCCCC"> adjacent unused</font>

271
00:11:12,339 --> 00:11:17,319
objects the design of<font color="#CCCCCC"> gardner's</font>

272
00:11:15,369 --> 00:11:19,509
allocation buffer lends itself for

273
00:11:17,319 --> 00:11:21,579
<font color="#E5E5E5">allowing for tunable over-provisioning</font>

274
00:11:19,509 --> 00:11:23,799
<font color="#E5E5E5">when the allocation buffer falls below</font>

275
00:11:21,579 --> 00:11:25,659
<font color="#CCCCCC">half-full it</font><font color="#E5E5E5"> will initiate that filling</font>

276
00:11:23,799 --> 00:11:27,608
step<font color="#E5E5E5"> at which point gardener will</font>

277
00:11:25,659 --> 00:11:29,649
randomly select<font color="#CCCCCC"> one out of eight new</font>

278
00:11:27,609 --> 00:11:31,749
objects positioned at the<font color="#E5E5E5"> top</font><font color="#CCCCCC"> of the</font>

279
00:11:29,649 --> 00:11:34,509
heap<font color="#E5E5E5"> and skip them which will cause them</font>

280
00:11:31,749 --> 00:11:36,970
<font color="#CCCCCC">to never be used</font><font color="#E5E5E5"> the remaining seven out</font>

281
00:11:34,509 --> 00:11:39,549
of eight objects will<font color="#CCCCCC"> be used</font><font color="#E5E5E5"> to for the</font>

282
00:11:36,970 --> 00:11:41,499
filling operation<font color="#E5E5E5"> now this is actually</font>

283
00:11:39,549 --> 00:11:43,539
<font color="#CCCCCC">this figures actually</font><font color="#E5E5E5"> a simplification</font>

284
00:11:41,499 --> 00:11:45,909
<font color="#CCCCCC">of how guardar actually performs the</font>

285
00:11:43,539 --> 00:11:48,069
over-provisioning but we reduced the

286
00:11:45,909 --> 00:11:50,829
<font color="#CCCCCC">number</font><font color="#E5E5E5"> of random operations required by</font>

287
00:11:48,069 --> 00:11:52,358
7/8 compared to the naive method<font color="#E5E5E5"> of just</font>

288
00:11:50,829 --> 00:11:54,368
computing probabilities for each of

289
00:11:52,359 --> 00:11:56,109
these objects if you're interested in

290
00:11:54,369 --> 00:12:03,189
the specifics of the implementation<font color="#CCCCCC"> it's</font>

291
00:11:56,109 --> 00:12:05,379
explained in section 4.2 of the paper so

292
00:12:03,189 --> 00:12:07,839
the allocation buffer design<font color="#E5E5E5"> also allows</font>

293
00:12:05,379 --> 00:12:09,999
us<font color="#CCCCCC"> to provide tunable random guard pages</font>

294
00:12:07,839 --> 00:12:12,099
and a guard page is<font color="#E5E5E5"> just like a regular</font>

295
00:12:09,999 --> 00:12:14,019
<font color="#E5E5E5">page in memory except it has all of its</font>

296
00:12:12,099 --> 00:12:15,789
protection<font color="#E5E5E5"> bits turned off so any</font>

297
00:12:14,019 --> 00:12:18,099
attempt to<font color="#E5E5E5"> read write or execute on it</font>

298
00:12:15,789 --> 00:12:21,699
<font color="#CCCCCC">will trigger a seg fault</font><font color="#E5E5E5"> and the program</font>

299
00:12:18,099 --> 00:12:23,979
<font color="#E5E5E5">will crash</font><font color="#CCCCCC"> gardener uses static guard</font>

300
00:12:21,699 --> 00:12:26,799
pages<font color="#E5E5E5"> to which are placed at the end of</font>

301
00:12:23,979 --> 00:12:29,139
every bag<font color="#E5E5E5"> but it also provides a tunable</font>

302
00:12:26,799 --> 00:12:31,478
proportion of random guard pages which

303
00:12:29,139 --> 00:12:33,999
get<font color="#E5E5E5"> distributed throughout the bag</font><font color="#CCCCCC"> we</font>

304
00:12:31,479 --> 00:12:36,279
use a default proportion of<font color="#CCCCCC"> 10%</font><font color="#E5E5E5"> so by</font>

305
00:12:33,999 --> 00:12:37,959
<font color="#E5E5E5">default</font><font color="#CCCCCC"> 10% of the heaps address space</font>

306
00:12:36,279 --> 00:12:40,619
will be dedicated to<font color="#E5E5E5"> these random guard</font>

307
00:12:37,959 --> 00:12:42,998
pages and I<font color="#E5E5E5"> mention address space</font>

308
00:12:40,619 --> 00:12:45,279
because guard pages<font color="#E5E5E5"> aren't backed by</font>

309
00:12:42,999 --> 00:12:47,699
<font color="#CCCCCC">physical memory</font><font color="#E5E5E5"> so this isn't increasing</font>

310
00:12:45,279 --> 00:12:50,169
the memory footprint of the application

311
00:12:47,699 --> 00:12:52,089
obviously<font color="#CCCCCC"> this will help protect against</font>

312
00:12:50,169 --> 00:12:54,098
things<font color="#E5E5E5"> like buffer overflow and heap</font>

313
00:12:52,089 --> 00:12:55,989
spraying attacks<font color="#E5E5E5"> because if an overflow</font>

314
00:12:54,099 --> 00:12:57,999
were to<font color="#E5E5E5"> touch one of the guard pages it</font>

315
00:12:55,989 --> 00:13:02,159
will<font color="#E5E5E5"> cause a seg fault and the program</font>

316
00:12:57,999 --> 00:13:02,159
will crash<font color="#E5E5E5"> or halt</font><font color="#CCCCCC"> right there</font>

317
00:13:03,000 --> 00:13:07,899
here you can see<font color="#CCCCCC"> our runtime</font><font color="#E5E5E5"> performance</font>

318
00:13:05,129 --> 00:13:09,970
<font color="#E5E5E5">so we evaluated Gardner with 21</font>

319
00:13:07,899 --> 00:13:12,069
applications including the parsec

320
00:13:09,970 --> 00:13:14,649
multi-threaded benchmark suite<font color="#E5E5E5"> as well</font>

321
00:13:12,069 --> 00:13:16,060
as<font color="#E5E5E5"> eight</font><font color="#CCCCCC"> real-world applications</font><font color="#E5E5E5"> all of</font>

322
00:13:14,649 --> 00:13:18,490
these values<font color="#E5E5E5"> here have been normalized</font>

323
00:13:16,060 --> 00:13:19,930
to G<font color="#CCCCCC"> Livesey</font><font color="#E5E5E5"> so anything less than one</font>

324
00:13:18,490 --> 00:13:22,899
is faster than the default Linux

325
00:13:19,930 --> 00:13:25,000
<font color="#E5E5E5">allocator</font><font color="#CCCCCC"> and as you</font><font color="#E5E5E5"> can</font><font color="#CCCCCC"> see on average</font>

326
00:13:22,899 --> 00:13:27,399
<font color="#CCCCCC">Gardner</font><font color="#E5E5E5"> is faster than</font><font color="#CCCCCC"> dive harder and</font>

327
00:13:25,000 --> 00:13:29,769
<font color="#E5E5E5">OpenBSD</font><font color="#CCCCCC"> and is essentially tied with</font>

328
00:13:27,399 --> 00:13:32,350
free guard so free guard has less<font color="#CCCCCC"> than</font>

329
00:13:29,769 --> 00:13:34,899
<font color="#CCCCCC">2%</font><font color="#E5E5E5"> overhead on average and Gardner has</font>

330
00:13:32,350 --> 00:13:39,790
less<font color="#CCCCCC"> than 3% on average but</font><font color="#E5E5E5"> with the</font>

331
00:13:34,899 --> 00:13:42,550
much<font color="#E5E5E5"> stronger security guarantee so why</font>

332
00:13:39,790 --> 00:13:44,649
is that well there's two<font color="#CCCCCC"> primary reasons</font>

333
00:13:42,550 --> 00:13:46,660
<font color="#CCCCCC">why Gardner performs better than</font><font color="#E5E5E5"> other</font>

334
00:13:44,649 --> 00:13:50,230
secure<font color="#CCCCCC"> allocators like open BSD</font><font color="#E5E5E5"> and die</font>

335
00:13:46,660 --> 00:13:52,329
harder first<font color="#CCCCCC"> garter avoid avoids the use</font>

336
00:13:50,230 --> 00:13:54,160
<font color="#CCCCCC">of a</font><font color="#E5E5E5"> central lock with the exception of</font>

337
00:13:52,329 --> 00:13:55,920
a global free<font color="#CCCCCC"> cache that's used under</font>

338
00:13:54,160 --> 00:13:58,449
certain<font color="#E5E5E5"> memory access</font><font color="#CCCCCC"> patterns like</font>

339
00:13:55,920 --> 00:14:00,910
<font color="#CCCCCC">producer-consumer</font><font color="#E5E5E5"> the other</font><font color="#CCCCCC"> allocators</font>

340
00:13:58,449 --> 00:14:03,849
have to acquire<font color="#E5E5E5"> a lock on allocation and</font>

341
00:14:00,910 --> 00:14:05,680
de-allocation<font color="#CCCCCC"> and the second reason</font><font color="#E5E5E5"> can</font>

342
00:14:03,850 --> 00:14:07,720
be<font color="#E5E5E5"> seen in the</font><font color="#CCCCCC"> table which shows</font><font color="#E5E5E5"> the</font>

343
00:14:05,680 --> 00:14:10,239
number<font color="#CCCCCC"> of trials needed to perform</font><font color="#E5E5E5"> each</font>

344
00:14:07,720 --> 00:14:12,519
operation<font color="#E5E5E5"> for these alligators you can</font>

345
00:14:10,240 --> 00:14:14,769
see that while garter has a larger

346
00:14:12,519 --> 00:14:17,290
<font color="#CCCCCC">maximum</font><font color="#E5E5E5"> for allocations it also has a</font>

347
00:14:14,769 --> 00:14:19,449
smaller<font color="#CCCCCC"> average</font><font color="#E5E5E5"> also</font><font color="#CCCCCC"> due to the design</font>

348
00:14:17,290 --> 00:14:22,649
of<font color="#E5E5E5"> the</font><font color="#CCCCCC"> D</font><font color="#E5E5E5"> allocation buffer we have</font>

349
00:14:19,449 --> 00:14:26,258
constant time<font color="#CCCCCC"> single trial</font><font color="#E5E5E5"> D allocations</font>

350
00:14:22,649 --> 00:14:28,300
and this data was<font color="#CCCCCC"> collected with</font>

351
00:14:26,259 --> 00:14:31,470
Gardner's default tunable parameter of

352
00:14:28,300 --> 00:14:31,469
<font color="#CCCCCC">nine bits of entropy</font>

353
00:14:35,980 --> 00:14:40,040
here we can<font color="#CCCCCC"> see a comparison</font><font color="#E5E5E5"> of the</font>

354
00:14:38,270 --> 00:14:42,860
security<font color="#E5E5E5"> features that</font><font color="#CCCCCC"> are implemented</font>

355
00:14:40,040 --> 00:14:44,300
among these alligators garter provides

356
00:14:42,860 --> 00:14:46,010
the most complete feature set with

357
00:14:44,300 --> 00:14:48,199
respect<font color="#CCCCCC"> to</font><font color="#E5E5E5"> these works and provides the</font>

358
00:14:46,010 --> 00:14:50,870
strongest guarantee<font color="#CCCCCC"> in terms of</font>

359
00:14:48,200 --> 00:14:52,340
randomization entropy<font color="#E5E5E5"> you can see that</font>

360
00:14:50,870 --> 00:14:55,160
garter also implements<font color="#CCCCCC"> full</font><font color="#E5E5E5"> the</font>

361
00:14:52,340 --> 00:14:57,440
segregated metadata<font color="#E5E5E5"> canary checking on</font>

362
00:14:55,160 --> 00:15:01,430
free and can detect<font color="#E5E5E5"> all double and</font>

363
00:14:57,440 --> 00:15:03,260
invalid<font color="#CCCCCC"> fries so now that we've</font><font color="#E5E5E5"> seen an</font>

364
00:15:01,430 --> 00:15:05,300
overview<font color="#CCCCCC"> of garters allocation and</font>

365
00:15:03,260 --> 00:15:07,370
de-allocation buffers<font color="#E5E5E5"> let's take a look</font>

366
00:15:05,300 --> 00:15:11,689
again at<font color="#CCCCCC"> the entropy data but with</font>

367
00:15:07,370 --> 00:15:14,180
<font color="#E5E5E5">garter included so you can see here that</font>

368
00:15:11,690 --> 00:15:16,730
Gardner shows stable entropy across<font color="#E5E5E5"> each</font>

369
00:15:14,180 --> 00:15:18,439
size class like I said for<font color="#E5E5E5"> this</font>

370
00:15:16,730 --> 00:15:20,690
evaluation<font color="#E5E5E5"> garter was configured with</font>

371
00:15:18,440 --> 00:15:22,670
nine bits<font color="#E5E5E5"> of entropy and the</font><font color="#CCCCCC"> average</font>

372
00:15:20,690 --> 00:15:24,830
<font color="#CCCCCC">overall value was nine point nine</font>

373
00:15:22,670 --> 00:15:26,360
<font color="#E5E5E5">because of course a nine bit would be</font>

374
00:15:24,830 --> 00:15:29,240
<font color="#E5E5E5">the bare minimum</font><font color="#CCCCCC"> at</font><font color="#E5E5E5"> that it would</font>

375
00:15:26,360 --> 00:15:33,140
<font color="#CCCCCC">guarantee in actuality it came out</font><font color="#E5E5E5"> much</font>

376
00:15:29,240 --> 00:15:35,390
closer to<font color="#E5E5E5"> twice</font><font color="#CCCCCC"> one more bit</font><font color="#E5E5E5"> because it</font>

377
00:15:33,140 --> 00:15:42,080
has twice<font color="#E5E5E5"> twice the</font><font color="#CCCCCC"> number of required</font>

378
00:15:35,390 --> 00:15:44,689
<font color="#E5E5E5">objects to maintain the nine bits so why</font>

379
00:15:42,080 --> 00:15:45,920
does tunability matter<font color="#CCCCCC"> here we</font><font color="#E5E5E5"> can see</font>

380
00:15:44,690 --> 00:15:48,410
the results<font color="#E5E5E5"> when we use different</font>

381
00:15:45,920 --> 00:15:49,819
tunable factors whenever we<font color="#E5E5E5"> use</font>

382
00:15:48,410 --> 00:15:52,130
parameters<font color="#CCCCCC"> that introduce higher</font>

383
00:15:49,820 --> 00:15:54,890
<font color="#E5E5E5">security of course that usually</font>

384
00:15:52,130 --> 00:15:56,960
<font color="#CCCCCC">indicates higher overhead if we use</font>

385
00:15:54,890 --> 00:15:59,270
higher<font color="#E5E5E5"> entropy the memory overhead is</font>

386
00:15:56,960 --> 00:16:02,180
actually significantly<font color="#CCCCCC"> higher the table</font>

387
00:15:59,270 --> 00:16:03,710
here is<font color="#E5E5E5"> showing performance and all of</font>

388
00:16:02,180 --> 00:16:05,930
these<font color="#CCCCCC"> values</font><font color="#E5E5E5"> have been normalized to</font>

389
00:16:03,710 --> 00:16:08,390
<font color="#CCCCCC">garters default settings</font><font color="#E5E5E5"> so like I said</font>

390
00:16:05,930 --> 00:16:11,060
<font color="#CCCCCC">nine</font><font color="#E5E5E5"> bits is the</font><font color="#CCCCCC"> default entropy</font>

391
00:16:08,390 --> 00:16:13,310
parameter<font color="#E5E5E5"> one eighth</font><font color="#CCCCCC"> over provisioning</font>

392
00:16:11,060 --> 00:16:16,869
factor is the default<font color="#CCCCCC"> and</font><font color="#E5E5E5"> ten percent</font>

393
00:16:13,310 --> 00:16:16,869
<font color="#CCCCCC">guard page proportion</font>

394
00:16:23,730 --> 00:16:28,799
so overall this is<font color="#E5E5E5"> garters position with</font>

395
00:16:26,999 --> 00:16:32,339
regard to<font color="#E5E5E5"> the</font><font color="#CCCCCC"> allocators we've discussed</font>

396
00:16:28,799 --> 00:16:34,679
<font color="#E5E5E5">on</font><font color="#CCCCCC"> one side</font><font color="#E5E5E5"> die harder features strong</font>

397
00:16:32,339 --> 00:16:37,019
security but<font color="#E5E5E5"> has the worst performance</font>

398
00:16:34,679 --> 00:16:38,850
overhead<font color="#E5E5E5"> and on the other</font><font color="#CCCCCC"> extreme we</font>

399
00:16:37,019 --> 00:16:41,899
<font color="#CCCCCC">have the</font><font color="#E5E5E5"> linux</font><font color="#CCCCCC"> allocator which performs</font>

400
00:16:38,850 --> 00:16:44,160
very well<font color="#CCCCCC"> but has no</font><font color="#E5E5E5"> security</font><font color="#CCCCCC"> guarantee</font>

401
00:16:41,899 --> 00:16:46,379
in<font color="#CCCCCC"> terms</font><font color="#E5E5E5"> of both performance and</font>

402
00:16:44,160 --> 00:16:51,839
<font color="#CCCCCC">security aspects</font><font color="#E5E5E5"> gauger provides the</font>

403
00:16:46,379 --> 00:16:54,389
best combination of them both<font color="#E5E5E5"> which</font>

404
00:16:51,839 --> 00:16:56,309
leads<font color="#E5E5E5"> me to conclude by</font><font color="#CCCCCC"> saying</font><font color="#E5E5E5"> tunable</font>

405
00:16:54,389 --> 00:16:58,019
security allows users to<font color="#E5E5E5"> choose their</font>

406
00:16:56,309 --> 00:17:01,169
security level based on<font color="#E5E5E5"> the performance</font>

407
00:16:58,019 --> 00:17:03,509
budget reliable security provides a

408
00:17:01,169 --> 00:17:06,319
stable entropy level across size classes

409
00:17:03,509 --> 00:17:09,179
<font color="#E5E5E5">inputs execution phases and applications</font>

410
00:17:06,319 --> 00:17:11,879
the allocation buffer design<font color="#E5E5E5"> facilitates</font>

411
00:17:09,179 --> 00:17:14,089
<font color="#E5E5E5">other tunable features like the heap</font><font color="#CCCCCC"> /</font>

412
00:17:11,880 --> 00:17:16,230
<font color="#E5E5E5">provisioning and random guard pages and</font>

413
00:17:14,089 --> 00:17:18,000
gardener implements the greatest feature

414
00:17:16,230 --> 00:17:21,329
set compared to the other evaluated

415
00:17:18,000 --> 00:17:27,898
<font color="#CCCCCC">alder caters all with less</font><font color="#E5E5E5"> than</font><font color="#CCCCCC"> 3%</font>

416
00:17:21,329 --> 00:17:31,690
<font color="#E5E5E5">performance overhead on average so with</font>

417
00:17:27,898 --> 00:17:40,399
that I'll take<font color="#CCCCCC"> questions</font>

418
00:17:31,690 --> 00:17:40,400
[Applause]

419
00:17:41,239 --> 00:17:46,350
thanks for the talk<font color="#E5E5E5"> when we start to</font>

420
00:17:44,429 --> 00:17:48,299
introduce<font color="#E5E5E5"> to nobility we start to</font>

421
00:17:46,350 --> 00:17:50,879
increase<font color="#E5E5E5"> mental cognitive overhead</font>

422
00:17:48,299 --> 00:17:53,970
required<font color="#E5E5E5"> on the developers did you do</font>

423
00:17:50,879 --> 00:17:56,549
any<font color="#CCCCCC"> research into</font><font color="#E5E5E5"> understanding how</font>

424
00:17:53,970 --> 00:17:59,399
users might use these features whether

425
00:17:56,549 --> 00:18:00,840
<font color="#E5E5E5">or not they might actually to</font><font color="#CCCCCC"> not</font>

426
00:17:59,399 --> 00:18:02,518
understand<font color="#CCCCCC"> the implications in</font><font color="#E5E5E5"> tune</font>

427
00:18:00,840 --> 00:18:05,309
<font color="#E5E5E5">against or for security because they</font>

428
00:18:02,519 --> 00:18:08,070
want better performance<font color="#CCCCCC"> the question is</font>

429
00:18:05,309 --> 00:18:10,559
<font color="#E5E5E5">really like is</font><font color="#CCCCCC"> tunability</font><font color="#E5E5E5"> versus static</font>

430
00:18:08,070 --> 00:18:13,408
<font color="#E5E5E5">set of features worth the cognitive</font>

431
00:18:10,559 --> 00:18:15,989
overhead and possible failure of

432
00:18:13,409 --> 00:18:19,499
developers yeah that's a really

433
00:18:15,989 --> 00:18:21,359
<font color="#E5E5E5">interesting angle and question</font><font color="#CCCCCC"> um</font><font color="#E5E5E5"> no I I</font>

434
00:18:19,499 --> 00:18:23,789
definitely happen<font color="#CCCCCC"> to I considered that</font>

435
00:18:21,359 --> 00:18:26,519
or<font color="#E5E5E5"> that</font><font color="#CCCCCC"> was</font><font color="#E5E5E5"> founded outside the scope of</font>

436
00:18:23,789 --> 00:18:28,649
<font color="#E5E5E5">what we looked at</font><font color="#CCCCCC"> but no that's that's a</font>

437
00:18:26,519 --> 00:18:31,830
<font color="#CCCCCC">very interesting</font><font color="#E5E5E5"> point and probably</font>

438
00:18:28,649 --> 00:18:35,309
<font color="#E5E5E5">warrants some research thank you</font><font color="#CCCCCC"> yeah</font>

439
00:18:31,830 --> 00:18:37,139
<font color="#E5E5E5">thank you really interesting work on my</font>

440
00:18:35,309 --> 00:18:40,440
<font color="#E5E5E5">question is actually</font><font color="#CCCCCC"> very similar to</font><font color="#E5E5E5"> the</font>

441
00:18:37,139 --> 00:18:42,238
previous<font color="#E5E5E5"> gentleman</font><font color="#CCCCCC"> may I have a</font>

442
00:18:40,440 --> 00:18:43,919
suggestion though<font color="#E5E5E5"> you know because we</font>

443
00:18:42,239 --> 00:18:47,129
build secure systems you know we always

444
00:18:43,919 --> 00:18:49,409
<font color="#E5E5E5">can come up with</font><font color="#CCCCCC"> a chart</font><font color="#E5E5E5"> saying security</font>

445
00:18:47,129 --> 00:18:51,779
here performance here see<font color="#E5E5E5"> where they</font><font color="#CCCCCC"> are</font>

446
00:18:49,409 --> 00:18:53,789
right better<font color="#E5E5E5"> than everybody else can the</font>

447
00:18:51,779 --> 00:18:55,710
community challenge ourselves<font color="#E5E5E5"> putting</font>

448
00:18:53,789 --> 00:18:58,679
another dimension saying usability

449
00:18:55,710 --> 00:19:02,070
adoption you know<font color="#CCCCCC"> I can tell you my</font>

450
00:18:58,679 --> 00:19:04,320
system here is great<font color="#CCCCCC"> usability is the</font>

451
00:19:02,070 --> 00:19:06,359
lowest<font color="#E5E5E5"> because it's more complicated</font><font color="#CCCCCC"> and</font>

452
00:19:04,320 --> 00:19:08,039
so forth<font color="#E5E5E5"> just a suggestion you</font><font color="#CCCCCC"> know</font>

453
00:19:06,359 --> 00:19:09,449
challenge for the<font color="#E5E5E5"> whole community</font><font color="#CCCCCC"> you</font>

454
00:19:08,039 --> 00:19:11,519
know<font color="#E5E5E5"> if you want to make anything</font><font color="#CCCCCC"> this</font>

455
00:19:09,450 --> 00:19:16,590
<font color="#E5E5E5">this is useful we have to think about</font>

456
00:19:11,519 --> 00:19:18,330
<font color="#CCCCCC">that angle thank you thank you hello</font><font color="#E5E5E5"> I'm</font>

457
00:19:16,590 --> 00:19:20,939
<font color="#E5E5E5">Tess</font><font color="#CCCCCC"> you came from Georgia Tech I</font>

458
00:19:18,330 --> 00:19:23,220
actually have two questions<font color="#CCCCCC"> for you the</font>

459
00:19:20,940 --> 00:19:25,769
<font color="#CCCCCC">first</font><font color="#E5E5E5"> only using a little</font><font color="#CCCCCC"> bit</font><font color="#E5E5E5"> unfair to</font>

460
00:19:23,220 --> 00:19:28,139
<font color="#E5E5E5">say</font><font color="#CCCCCC"> that having larger entropy in</font>

461
00:19:25,769 --> 00:19:30,720
<font color="#CCCCCC">particularly in the</font><font color="#E5E5E5"> hip space having</font>

462
00:19:28,139 --> 00:19:32,428
better security for<font color="#E5E5E5"> instance Windows 10</font>

463
00:19:30,720 --> 00:19:35,429
introduced here a locator<font color="#CCCCCC"> that have</font>

464
00:19:32,429 --> 00:19:38,850
randomness in their implementation<font color="#CCCCCC"> but</font>

465
00:19:35,429 --> 00:19:40,980
in many cases<font color="#CCCCCC"> deterministic behavior</font><font color="#E5E5E5"> of</font>

466
00:19:38,850 --> 00:19:43,949
the application<font color="#CCCCCC"> and he play out some</font>

467
00:19:40,980 --> 00:19:45,720
<font color="#CCCCCC">time prohibits some to exploit ation and</font>

468
00:19:43,950 --> 00:19:48,539
thank to your<font color="#CCCCCC"> rent earnest that you</font>

469
00:19:45,720 --> 00:19:50,120
<font color="#E5E5E5">introduced from the library sometimes</font>

470
00:19:48,539 --> 00:19:52,429
the expectation become possible

471
00:19:50,120 --> 00:19:54,979
are you what<font color="#CCCCCC"> they think about</font><font color="#E5E5E5"> this kind</font>

472
00:19:52,429 --> 00:20:00,590
of problem that you<font color="#CCCCCC"> introduced from your</font>

473
00:19:54,980 --> 00:20:03,049
<font color="#CCCCCC">alligator it's</font><font color="#E5E5E5"> the first question yeah</font>

474
00:20:00,590 --> 00:20:06,580
that's that<font color="#E5E5E5"> I mean that's that's true</font>

475
00:20:03,049 --> 00:20:11,809
right<font color="#CCCCCC"> so the the increased randomization</font>

476
00:20:06,580 --> 00:20:14,330
is as a tool that<font color="#E5E5E5"> you know may</font><font color="#CCCCCC"> or may</font>

477
00:20:11,809 --> 00:20:17,178
not necessarily mean<font color="#CCCCCC"> anything if the</font>

478
00:20:14,330 --> 00:20:18,830
application<font color="#E5E5E5"> you know has other</font><font color="#CCCCCC"> problems</font>

479
00:20:17,179 --> 00:20:21,110
I think<font color="#CCCCCC"> is that is that</font><font color="#E5E5E5"> what you're is</font>

480
00:20:18,830 --> 00:20:22,309
<font color="#CCCCCC">that what you're saying okay a</font><font color="#E5E5E5"> second</font>

481
00:20:21,110 --> 00:20:24,860
question

482
00:20:22,309 --> 00:20:28,210
<font color="#E5E5E5">it's the most of the</font><font color="#CCCCCC"> Hiba a locator is</font>

483
00:20:24,860 --> 00:20:31,309
optimized for reducing fragmentation

484
00:20:28,210 --> 00:20:33,740
<font color="#CCCCCC">that's directly</font><font color="#E5E5E5"> related</font><font color="#CCCCCC"> to their</font>

485
00:20:31,309 --> 00:20:36,110
performance goal but it seems<font color="#E5E5E5"> your most</font>

486
00:20:33,740 --> 00:20:39,350
of the<font color="#CCCCCC"> your performance benefit</font><font color="#E5E5E5"> directly</font>

487
00:20:36,110 --> 00:20:41,590
come from<font color="#CCCCCC"> per core</font><font color="#E5E5E5"> allocation behavior</font>

488
00:20:39,350 --> 00:20:44,149
which<font color="#CCCCCC"> is a little bit unfair to compare</font>

489
00:20:41,590 --> 00:20:46,520
against the other hip a locator that<font color="#CCCCCC"> you</font>

490
00:20:44,149 --> 00:20:48,979
<font color="#E5E5E5">evaluated</font><font color="#CCCCCC"> these</font><font color="#E5E5E5"> guys are do not care</font>

491
00:20:46,520 --> 00:20:51,110
<font color="#E5E5E5">about this perfect behavior</font><font color="#CCCCCC"> but the</font>

492
00:20:48,980 --> 00:20:54,549
reason<font color="#CCCCCC"> that you introduced the perk or</font><font color="#E5E5E5"> a</font>

493
00:20:51,110 --> 00:20:57,740
locator indeed a locator list perhaps<font color="#E5E5E5"> I</font>

494
00:20:54,549 --> 00:21:00,620
think<font color="#E5E5E5"> that's only direct I'll say</font>

495
00:20:57,740 --> 00:21:04,179
performance benefit right do you<font color="#E5E5E5"> have</font>

496
00:21:00,620 --> 00:21:07,178
any number for the fragmentation<font color="#CCCCCC"> no no</font>

497
00:21:04,179 --> 00:21:07,179
okay

498
00:21:11,150 --> 00:21:16,040
<font color="#E5E5E5">hi great talk</font><font color="#CCCCCC"> Shawn healin University of</font>

499
00:21:13,850 --> 00:21:18,530
Oxford<font color="#CCCCCC"> one of the questions I often have</font>

500
00:21:16,040 --> 00:21:20,810
<font color="#E5E5E5">when people</font><font color="#CCCCCC"> talk about secure allocators</font>

501
00:21:18,530 --> 00:21:22,340
is<font color="#E5E5E5"> say what are the known</font><font color="#CCCCCC"> limitations</font>

502
00:21:20,810 --> 00:21:23,659
<font color="#E5E5E5">say at the time of</font><font color="#CCCCCC"> presentation like</font>

503
00:21:22,340 --> 00:21:26,510
have you sat<font color="#CCCCCC"> down and tried to</font><font color="#E5E5E5"> write an</font>

504
00:21:23,660 --> 00:21:28,850
exploit with<font color="#CCCCCC"> garter as the as like to</font>

505
00:21:26,510 --> 00:21:30,200
<font color="#E5E5E5">say the system allocator and</font><font color="#CCCCCC"> if so have</font>

506
00:21:28,850 --> 00:21:32,030
you any<font color="#CCCCCC"> thoughts on what</font><font color="#E5E5E5"> the limitations</font>

507
00:21:30,200 --> 00:21:32,890
might be or<font color="#E5E5E5"> what would you do what would</font>

508
00:21:32,030 --> 00:21:37,100
<font color="#E5E5E5">you do next</font>

509
00:21:32,890 --> 00:21:39,260
yeah<font color="#CCCCCC"> actually in the paper we we use</font>

510
00:21:37,100 --> 00:21:42,949
several<font color="#CCCCCC"> real-world bugs to evaluate</font>

511
00:21:39,260 --> 00:21:44,150
<font color="#CCCCCC">Gardner</font><font color="#E5E5E5"> yeah so those details are</font>

512
00:21:42,950 --> 00:21:47,570
actually in there if<font color="#E5E5E5"> you or if you're</font>

513
00:21:44,150 --> 00:21:51,050
interested<font color="#CCCCCC"> in those but obviously I</font>

514
00:21:47,570 --> 00:21:52,220
hadn't included those<font color="#CCCCCC"> in the talk ok</font><font color="#E5E5E5"> I</font>

515
00:21:51,050 --> 00:21:53,419
guess my<font color="#CCCCCC"> question is more have</font><font color="#E5E5E5"> you then</font>

516
00:21:52,220 --> 00:21:55,850
sat down and tried<font color="#CCCCCC"> to have</font><font color="#E5E5E5"> to eat defeat</font>

517
00:21:53,420 --> 00:21:57,290
guard<font color="#CCCCCC"> they're like purposely as opposed</font>

518
00:21:55,850 --> 00:22:07,760
to taking existing exploits and running

519
00:21:57,290 --> 00:22:09,649
them<font color="#CCCCCC"> oh</font><font color="#E5E5E5"> no</font><font color="#CCCCCC"> ok</font><font color="#E5E5E5"> thank you all right we are</font>

520
00:22:07,760 --> 00:22:11,330
right about<font color="#E5E5E5"> on time to finish this</font>

521
00:22:09,650 --> 00:22:14,770
session let's just give one more round

522
00:22:11,330 --> 00:22:14,770
<font color="#E5E5E5">of applause</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> this because</font>

