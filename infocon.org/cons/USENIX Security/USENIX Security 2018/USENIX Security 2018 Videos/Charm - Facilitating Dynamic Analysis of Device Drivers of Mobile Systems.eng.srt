1
00:00:11,240 --> 00:00:17,220
hello everyone<font color="#CCCCCC"> I</font><font color="#E5E5E5"> am said mama Java</font>

2
00:00:14,250 --> 00:00:19,289
sitadevi from UC<font color="#E5E5E5"> Irvine this work was a</font>

3
00:00:17,220 --> 00:00:22,979
collaboration<font color="#CCCCCC"> between researchers from</font>

4
00:00:19,289 --> 00:00:23,579
UC Irvine<font color="#CCCCCC"> and UC Riverside I'm talking</font>

5
00:00:22,980 --> 00:00:25,529
about charm

6
00:00:23,579 --> 00:00:28,649
<font color="#CCCCCC">that's</font><font color="#E5E5E5"> interfacing dynamic analysis of</font>

7
00:00:25,529 --> 00:00:30,719
device drivers<font color="#CCCCCC"> of mobile systems first</font>

8
00:00:28,649 --> 00:00:33,780
<font color="#E5E5E5">let's see what is the problem</font><font color="#CCCCCC"> that charm</font>

9
00:00:30,719 --> 00:00:36,450
tries to solve today<font color="#E5E5E5"> we use our mobile</font>

10
00:00:33,780 --> 00:00:38,579
systems<font color="#CCCCCC"> everywhere from sharing our</font>

11
00:00:36,450 --> 00:00:40,500
family photos<font color="#CCCCCC"> in social media app to</font>

12
00:00:38,579 --> 00:00:42,600
paying our bill in<font color="#E5E5E5"> our banking</font>

13
00:00:40,500 --> 00:00:44,970
application<font color="#CCCCCC"> the security of mobile</font>

14
00:00:42,600 --> 00:00:47,340
<font color="#E5E5E5">system is very important this mobile</font>

15
00:00:44,970 --> 00:00:49,050
systems are diverse<font color="#E5E5E5"> there are thousands</font>

16
00:00:47,340 --> 00:00:51,660
of distinct Android devices in<font color="#E5E5E5"> the</font>

17
00:00:49,050 --> 00:00:55,470
market made by different<font color="#CCCCCC"> manufacturers</font>

18
00:00:51,660 --> 00:00:58,230
<font color="#E5E5E5">and this market is very</font><font color="#CCCCCC"> competitive</font>

19
00:00:55,470 --> 00:01:00,300
<font color="#E5E5E5">different vendors tries to attract their</font>

20
00:00:58,230 --> 00:01:02,790
customers by adding new<font color="#E5E5E5"> features one</font>

21
00:01:00,300 --> 00:01:04,709
might add<font color="#CCCCCC"> a new high-end camera</font><font color="#E5E5E5"> while</font>

22
00:01:02,790 --> 00:01:06,899
another one using<font color="#CCCCCC"> a new fingerprint</font>

23
00:01:04,709 --> 00:01:10,649
modules<font color="#E5E5E5"> this new features means new</font>

24
00:01:06,899 --> 00:01:13,229
<font color="#E5E5E5">hardware and new</font><font color="#CCCCCC"> hardware needs more new</font>

25
00:01:10,649 --> 00:01:14,880
device drivers<font color="#CCCCCC"> to be managed</font><font color="#E5E5E5"> so there</font>

26
00:01:13,229 --> 00:01:17,249
<font color="#E5E5E5">are a lot</font><font color="#CCCCCC"> of device</font><font color="#E5E5E5"> drivers out there</font>

27
00:01:14,880 --> 00:01:19,469
<font color="#E5E5E5">the time to market for device drivers is</font>

28
00:01:17,249 --> 00:01:23,818
short and you're<font color="#E5E5E5"> vulnerable to errors</font>

29
00:01:19,469 --> 00:01:26,279
and a study shows that 85%<font color="#E5E5E5"> of box</font><font color="#CCCCCC"> find</font>

30
00:01:23,819 --> 00:01:29,729
in<font color="#CCCCCC"> Android kernels</font><font color="#E5E5E5"> were due to errors in</font>

31
00:01:26,279 --> 00:01:32,670
device drivers so we need efficient ways

32
00:01:29,729 --> 00:01:35,520
<font color="#E5E5E5">to analyze device servers and find bugs</font>

33
00:01:32,670 --> 00:01:37,409
and vulnerabilities in them it has been

34
00:01:35,520 --> 00:01:39,779
shown<font color="#E5E5E5"> that dynamic analysis is very</font>

35
00:01:37,409 --> 00:01:42,299
useful for fine<font color="#CCCCCC"> Wellner abilities in</font>

36
00:01:39,779 --> 00:01:45,119
software<font color="#E5E5E5"> there are many techniques like</font>

37
00:01:42,299 --> 00:01:47,159
fuzzing interactive debugging<font color="#E5E5E5"> record and</font>

38
00:01:45,119 --> 00:01:51,119
replay<font color="#CCCCCC"> selectively symbolic execution</font>

39
00:01:47,159 --> 00:01:52,950
<font color="#E5E5E5">and dynamic paint analysis which have</font>

40
00:01:51,119 --> 00:01:56,429
been used<font color="#CCCCCC"> for</font><font color="#E5E5E5"> find vulnerabilities and</font>

41
00:01:52,950 --> 00:02:00,119
<font color="#CCCCCC">Ally analyze them many of existing tools</font>

42
00:01:56,429 --> 00:02:03,419
of many existing dynamic analysis to use

43
00:02:00,119 --> 00:02:05,909
virtual machines for example<font color="#E5E5E5"> to fuzzers</font>

44
00:02:03,419 --> 00:02:09,419
kfl and<font color="#CCCCCC"> deep tools that were introduced</font>

45
00:02:05,909 --> 00:02:13,680
<font color="#CCCCCC">in last year using</font><font color="#E5E5E5"> security use virtual</font>

46
00:02:09,419 --> 00:02:15,119
machines<font color="#CCCCCC"> to work and if you want to use</font>

47
00:02:13,680 --> 00:02:18,090
<font color="#E5E5E5">gdb for the kernel</font>

48
00:02:15,120 --> 00:02:21,180
you need a<font color="#E5E5E5"> virtual virtualization</font>

49
00:02:18,090 --> 00:02:23,850
environment the<font color="#E5E5E5"> qmu with help of</font>

50
00:02:21,180 --> 00:02:27,750
virtualization<font color="#CCCCCC"> provide some recording</font>

51
00:02:23,850 --> 00:02:31,799
play<font color="#E5E5E5"> h3 also used virtualization and a</font>

52
00:02:27,750 --> 00:02:34,350
whole<font color="#E5E5E5"> system dynamic taint analysis</font>

53
00:02:31,800 --> 00:02:36,210
called<font color="#CCCCCC"> decaf also used ritual</font><font color="#E5E5E5"> virtual</font>

54
00:02:34,350 --> 00:02:38,700
machines<font color="#E5E5E5"> but the problem is</font><font color="#CCCCCC"> that</font>

55
00:02:36,210 --> 00:02:40,470
<font color="#E5E5E5">applying these tools to mobile system</font>

56
00:02:38,700 --> 00:02:43,950
especially device drivers of mobile

57
00:02:40,470 --> 00:02:45,840
system is hard why because one<font color="#E5E5E5"> reason is</font>

58
00:02:43,950 --> 00:02:48,989
hardware-assisted virtualization<font color="#E5E5E5"> czar</font>

59
00:02:45,840 --> 00:02:52,200
not supported in<font color="#CCCCCC"> many commodity mobile</font>

60
00:02:48,990 --> 00:02:56,250
systems and<font color="#E5E5E5"> software only</font><font color="#CCCCCC"> VM leave you</font>

61
00:02:52,200 --> 00:02:58,290
with a very poor performance<font color="#CCCCCC"> so let's</font>

62
00:02:56,250 --> 00:03:01,920
see how we can<font color="#E5E5E5"> tackle this problem and</font>

63
00:02:58,290 --> 00:03:04,590
solve solve it<font color="#CCCCCC"> our idea is to</font><font color="#E5E5E5"> run the</font>

64
00:03:01,920 --> 00:03:07,140
<font color="#E5E5E5">device drivers of a mobile system in a</font>

65
00:03:04,590 --> 00:03:12,090
different<font color="#CCCCCC"> physical machine</font><font color="#E5E5E5"> for example</font><font color="#CCCCCC"> a</font>

66
00:03:07,140 --> 00:03:14,489
powerful x86 server<font color="#E5E5E5"> the problem with</font>

67
00:03:12,090 --> 00:03:16,560
that<font color="#E5E5E5"> is</font><font color="#CCCCCC"> that the execution</font><font color="#E5E5E5"> of device</font>

68
00:03:14,490 --> 00:03:18,960
driver is<font color="#E5E5E5"> tightly coupled with its</font>

69
00:03:16,560 --> 00:03:19,620
underlying<font color="#E5E5E5"> device and without access</font><font color="#CCCCCC"> to</font>

70
00:03:18,960 --> 00:03:22,170
<font color="#E5E5E5">its IO</font>

71
00:03:19,620 --> 00:03:25,890
the driver execution will fail and we

72
00:03:22,170 --> 00:03:28,649
cannot analyze that are either to solve

73
00:03:25,890 --> 00:03:31,980
this problem<font color="#CCCCCC"> is forward low-level IO</font>

74
00:03:28,650 --> 00:03:35,570
operations and use<font color="#CCCCCC"> actually a mobile</font>

75
00:03:31,980 --> 00:03:39,000
device<font color="#CCCCCC"> to</font><font color="#E5E5E5"> serve for these IO operations</font>

76
00:03:35,570 --> 00:03:42,359
<font color="#E5E5E5">let's see how we design the system to</font>

77
00:03:39,000 --> 00:03:44,490
<font color="#E5E5E5">implement this idea first before going</font>

78
00:03:42,360 --> 00:03:47,280
<font color="#E5E5E5">to implementation of our system let's</font>

79
00:03:44,490 --> 00:03:49,860
have a closer look<font color="#E5E5E5"> to device driver of</font>

80
00:03:47,280 --> 00:03:51,840
mobile system<font color="#E5E5E5"> the driver is running</font>

81
00:03:49,860 --> 00:03:54,570
<font color="#E5E5E5">within the kernel</font><font color="#CCCCCC"> of mobile system and</font>

82
00:03:51,840 --> 00:03:57,750
interacts<font color="#CCCCCC"> with the device</font><font color="#E5E5E5"> in several</font>

83
00:03:54,570 --> 00:04:00,480
ways one<font color="#E5E5E5"> of them is memory</font><font color="#CCCCCC"> map register</font>

84
00:03:57,750 --> 00:04:03,150
read read<font color="#CCCCCC"> rights to control control</font>

85
00:04:00,480 --> 00:04:05,220
registers<font color="#E5E5E5"> of a device if an event</font>

86
00:04:03,150 --> 00:04:08,820
happens<font color="#CCCCCC"> and the device wants to notify</font>

87
00:04:05,220 --> 00:04:12,060
the driver<font color="#E5E5E5"> it will use</font><font color="#CCCCCC"> interrupts in the</font>

88
00:04:08,820 --> 00:04:14,730
system there<font color="#CCCCCC"> also</font><font color="#E5E5E5"> is there also are</font><font color="#CCCCCC"> some</font>

89
00:04:12,060 --> 00:04:17,070
<font color="#E5E5E5">shared resources like clock power</font>

90
00:04:14,730 --> 00:04:18,930
management GPIO and<font color="#CCCCCC"> ping controllers</font>

91
00:04:17,070 --> 00:04:22,680
that<font color="#E5E5E5"> the driver needs to manage for its</font>

92
00:04:18,930 --> 00:04:25,110
device Linux kernel provide<font color="#CCCCCC"> API</font><font color="#E5E5E5"> for</font>

93
00:04:22,680 --> 00:04:27,240
sharing these resources and accessing

94
00:04:25,110 --> 00:04:31,200
shared<font color="#CCCCCC"> module for example the device</font>

95
00:04:27,240 --> 00:04:33,990
driver can call<font color="#E5E5E5"> functions to this API to</font>

96
00:04:31,200 --> 00:04:37,650
adjust the clock frequency<font color="#E5E5E5"> or change the</font>

97
00:04:33,990 --> 00:04:39,970
voltage<font color="#E5E5E5"> of a regulator</font>

98
00:04:37,650 --> 00:04:42,429
having<font color="#E5E5E5"> this knowledge of the</font><font color="#CCCCCC"> u.s. driver</font>

99
00:04:39,970 --> 00:04:44,980
<font color="#CCCCCC">let's see how we can move the</font><font color="#E5E5E5"> device</font>

100
00:04:42,430 --> 00:04:47,950
driver to the<font color="#CCCCCC"> workstation colonel and</font>

101
00:04:44,980 --> 00:04:49,960
run it in a virtual machine<font color="#E5E5E5"> first we</font>

102
00:04:47,950 --> 00:04:52,390
need<font color="#E5E5E5"> to disable the</font><font color="#CCCCCC"> device</font><font color="#E5E5E5"> driver in the</font>

103
00:04:49,960 --> 00:04:55,840
mobile system<font color="#CCCCCC"> since we</font><font color="#E5E5E5"> don't want to</font>

104
00:04:52,390 --> 00:04:57,969
device driver<font color="#E5E5E5"> managing one device then</font>

105
00:04:55,840 --> 00:05:00,520
we can move the code and<font color="#E5E5E5"> build it within</font>

106
00:04:57,970 --> 00:05:02,530
a<font color="#CCCCCC"> kernel of</font><font color="#E5E5E5"> the virtual machine as I</font>

107
00:05:00,520 --> 00:05:04,359
mentioned before the driver needs<font color="#E5E5E5"> to</font>

108
00:05:02,530 --> 00:05:07,440
<font color="#CCCCCC">manage the shared module shared</font>

109
00:05:04,360 --> 00:05:11,410
resources<font color="#E5E5E5"> using shared module by calling</font>

110
00:05:07,440 --> 00:05:14,980
kernel<font color="#E5E5E5"> API but we cannot move the shared</font>

111
00:05:11,410 --> 00:05:16,780
modules to the<font color="#E5E5E5"> workstation kernel since</font>

112
00:05:14,980 --> 00:05:19,840
if we disable these modules in the

113
00:05:16,780 --> 00:05:23,919
mobile system<font color="#E5E5E5"> the mobile system</font><font color="#CCCCCC"> will not</font>

114
00:05:19,840 --> 00:05:27,219
boot and we cannot<font color="#E5E5E5"> use it</font><font color="#CCCCCC"> for</font><font color="#E5E5E5"> remote i/o</font>

115
00:05:23,920 --> 00:05:29,350
accesses<font color="#CCCCCC"> so we</font><font color="#E5E5E5"> decided</font><font color="#CCCCCC"> to keep the</font>

116
00:05:27,220 --> 00:05:32,260
shared modules in the mobile<font color="#CCCCCC"> system and</font>

117
00:05:29,350 --> 00:05:35,650
<font color="#E5E5E5">access them remotely</font><font color="#CCCCCC"> I will discuss it</font>

118
00:05:32,260 --> 00:05:38,440
later<font color="#E5E5E5"> in this</font><font color="#CCCCCC"> slide</font><font color="#E5E5E5"> so let's see how we</font>

119
00:05:35,650 --> 00:05:41,349
handle remote i/o operations for this

120
00:05:38,440 --> 00:05:43,690
<font color="#E5E5E5">purpose we use two it stops one in the</font>

121
00:05:41,350 --> 00:05:45,790
<font color="#CCCCCC">working station hypervisor and one in</font>

122
00:05:43,690 --> 00:05:48,630
the mobile system<font color="#E5E5E5"> kernel and we</font>

123
00:05:45,790 --> 00:05:52,060
connected them using a USB<font color="#E5E5E5"> Channel</font><font color="#CCCCCC"> I</font>

124
00:05:48,630 --> 00:05:55,840
should<font color="#E5E5E5"> mention here that a device driver</font>

125
00:05:52,060 --> 00:05:58,419
and its underlying<font color="#CCCCCC"> hardware opera</font>

126
00:05:55,840 --> 00:06:01,479
interactions<font color="#E5E5E5"> is very</font><font color="#CCCCCC"> time-sensitive and</font>

127
00:05:58,419 --> 00:06:04,570
<font color="#E5E5E5">we could not use a normal USB channel</font>

128
00:06:01,480 --> 00:06:07,210
like<font color="#CCCCCC"> famous ADB because due to many</font>

129
00:06:04,570 --> 00:06:09,370
layers of<font color="#E5E5E5"> indirection</font><font color="#CCCCCC"> the latency of</font>

130
00:06:07,210 --> 00:06:13,450
this<font color="#E5E5E5"> channel is high and it will result</font>

131
00:06:09,370 --> 00:06:16,060
in many timeouts<font color="#E5E5E5"> so we built our</font><font color="#CCCCCC"> own USB</font>

132
00:06:13,450 --> 00:06:18,190
channel which connects the hypervisor of

133
00:06:16,060 --> 00:06:21,010
the<font color="#CCCCCC"> working</font><font color="#E5E5E5"> station to the kernel of</font>

134
00:06:18,190 --> 00:06:25,380
mobile system directly<font color="#E5E5E5"> and we reduce the</font>

135
00:06:21,010 --> 00:06:28,750
latency and avoided timeouts having this

136
00:06:25,380 --> 00:06:31,090
low latency USB<font color="#E5E5E5"> channel we can implement</font>

137
00:06:28,750 --> 00:06:34,540
all the interfaces<font color="#CCCCCC"> between</font><font color="#E5E5E5"> the driver</font>

138
00:06:31,090 --> 00:06:37,299
and device remotely<font color="#E5E5E5"> first interface is</font>

139
00:06:34,540 --> 00:06:39,940
remote register read and writes we know

140
00:06:37,300 --> 00:06:42,460
the physical<font color="#CCCCCC"> addresses range for each</font>

141
00:06:39,940 --> 00:06:44,950
device and<font color="#E5E5E5"> we</font><font color="#CCCCCC"> can track those</font><font color="#E5E5E5"> addresses</font>

142
00:06:42,460 --> 00:06:48,430
in the hypervisor of our workstation and

143
00:06:44,950 --> 00:06:50,960
if any register access<font color="#CCCCCC"> happen on those</font>

144
00:06:48,430 --> 00:06:54,009
addresses<font color="#E5E5E5"> we can forward it</font>

145
00:06:50,960 --> 00:06:57,680
to the mobile system<font color="#E5E5E5"> using Aria stop</font>

146
00:06:54,009 --> 00:07:01,220
since we disabled<font color="#CCCCCC"> the device driver in</font>

147
00:06:57,680 --> 00:07:04,069
the mobile system<font color="#CCCCCC"> we can capture all</font><font color="#E5E5E5"> the</font>

148
00:07:01,220 --> 00:07:06,500
<font color="#E5E5E5">interrupts that the device issue inside</font>

149
00:07:04,069 --> 00:07:08,330
<font color="#CCCCCC">are</font><font color="#E5E5E5"> a stub in the mobile</font><font color="#CCCCCC"> system and we</font>

150
00:07:06,500 --> 00:07:10,460
can<font color="#CCCCCC"> forward them to our work a station</font>

151
00:07:08,330 --> 00:07:15,500
and inject them to the kernel<font color="#CCCCCC"> or virtual</font>

152
00:07:10,460 --> 00:07:18,650
machine<font color="#E5E5E5"> and when the device driver wants</font>

153
00:07:15,500 --> 00:07:21,349
<font color="#CCCCCC">to manage the shared resources</font><font color="#E5E5E5"> we build</font>

154
00:07:18,650 --> 00:07:24,289
a remote procedure procedure<font color="#E5E5E5"> called on</font>

155
00:07:21,349 --> 00:07:27,110
top of the Linux API<font color="#CCCCCC"> for sharing</font><font color="#E5E5E5"> for</font>

156
00:07:24,289 --> 00:07:30,380
managing the shared resources so we<font color="#CCCCCC"> can</font>

157
00:07:27,110 --> 00:07:33,099
<font color="#CCCCCC">manage those</font><font color="#E5E5E5"> resources remotely from our</font>

158
00:07:30,380 --> 00:07:35,360
<font color="#E5E5E5">workstation by having these three</font>

159
00:07:33,099 --> 00:07:37,849
<font color="#CCCCCC">interfaces</font><font color="#E5E5E5"> the device driver will</font>

160
00:07:35,360 --> 00:07:40,220
successfully initialize and work inside

161
00:07:37,849 --> 00:07:43,190
the virtual machine<font color="#CCCCCC"> and we can run</font>

162
00:07:40,220 --> 00:07:48,039
<font color="#E5E5E5">different dynamic analysis on top of</font>

163
00:07:43,190 --> 00:07:51,409
that let's<font color="#CCCCCC"> see how well this system work</font>

164
00:07:48,039 --> 00:07:54,139
to show the generality of our system we

165
00:07:51,409 --> 00:07:57,800
<font color="#E5E5E5">ported for major device drivers</font><font color="#CCCCCC"> naming</font>

166
00:07:54,139 --> 00:08:01,039
camera audio GPU and IMU sensors<font color="#E5E5E5"> drivers</font>

167
00:07:57,800 --> 00:08:03,380
to our system<font color="#E5E5E5"> and reported the these</font>

168
00:08:01,039 --> 00:08:05,020
drivers from different phones<font color="#E5E5E5"> three</font>

169
00:08:03,380 --> 00:08:08,990
different phones from three different

170
00:08:05,020 --> 00:08:12,020
manufacturers for this purpose reported

171
00:08:08,990 --> 00:08:15,020
thousand line of lines of code<font color="#E5E5E5"> one</font>

172
00:08:12,020 --> 00:08:18,139
important metric for<font color="#CCCCCC"> our system is the</font>

173
00:08:15,020 --> 00:08:20,960
time it<font color="#E5E5E5"> takes to port a new driver to</font>

174
00:08:18,139 --> 00:08:22,789
our system for this<font color="#E5E5E5"> purpose after</font>

175
00:08:20,960 --> 00:08:25,489
finishing the implementation of our

176
00:08:22,789 --> 00:08:28,250
system we<font color="#E5E5E5"> asked another author of our</font>

177
00:08:25,490 --> 00:08:30,469
paper<font color="#E5E5E5"> to port new drivers to our system</font>

178
00:08:28,250 --> 00:08:31,280
<font color="#CCCCCC">and we measure the time it takes</font><font color="#E5E5E5"> to port</font>

179
00:08:30,469 --> 00:08:34,549
a new driver

180
00:08:31,280 --> 00:08:37,640
we can see that<font color="#E5E5E5"> porting GPU driver which</font>

181
00:08:34,549 --> 00:08:41,689
<font color="#CCCCCC">is a huge driver to our system</font><font color="#E5E5E5"> took</font>

182
00:08:37,640 --> 00:08:44,240
seven days<font color="#E5E5E5"> and porting IMU sensors to</font>

183
00:08:41,690 --> 00:08:46,970
our system<font color="#CCCCCC"> to two days I should mention</font>

184
00:08:44,240 --> 00:08:50,470
that this<font color="#E5E5E5"> author has good knowledge of</font>

185
00:08:46,970 --> 00:08:54,800
kernel programming and device drivers

186
00:08:50,470 --> 00:08:57,529
<font color="#E5E5E5">another point that it's worth mentioning</font>

187
00:08:54,800 --> 00:08:59,839
<font color="#CCCCCC">here is that most</font><font color="#E5E5E5"> of the process of</font>

188
00:08:57,529 --> 00:09:03,589
porting<font color="#CCCCCC"> the new device drivers to this</font>

189
00:08:59,839 --> 00:09:04,610
system is mechanical<font color="#E5E5E5"> and constant and we</font>

190
00:09:03,589 --> 00:09:07,250
plan to

191
00:09:04,610 --> 00:09:11,480
right<font color="#CCCCCC"> automatic program to port a new</font>

192
00:09:07,250 --> 00:09:15,320
driver to our system in future having

193
00:09:11,480 --> 00:09:18,290
<font color="#E5E5E5">these drivers in our system we can run</font>

194
00:09:15,320 --> 00:09:20,720
several<font color="#E5E5E5"> dynamic analysis tools and</font>

195
00:09:18,290 --> 00:09:23,439
techniques<font color="#E5E5E5"> in our system the</font><font color="#CCCCCC"> first one</font>

196
00:09:20,720 --> 00:09:26,690
is<font color="#CCCCCC"> fuzzing fighting as you may know is</font>

197
00:09:23,440 --> 00:09:29,000
testing the program by feeding random

198
00:09:26,690 --> 00:09:31,070
inputs to it to see whether the program

199
00:09:29,000 --> 00:09:36,620
crashes or<font color="#CCCCCC"> anything</font><font color="#E5E5E5"> happened to it</font><font color="#CCCCCC"> or</font>

200
00:09:31,070 --> 00:09:43,839
<font color="#E5E5E5">not our system fatima fete fighting in</font>

201
00:09:36,620 --> 00:09:43,839
several ways for<font color="#CCCCCC"> example</font>

202
00:09:44,050 --> 00:09:50,870
<font color="#CCCCCC">kfl and the tool</font><font color="#E5E5E5"> that</font><font color="#CCCCCC"> i mentioned before</font>

203
00:09:48,470 --> 00:09:53,899
<font color="#CCCCCC">used virtualization and because we run</font>

204
00:09:50,870 --> 00:09:57,620
the device driver within<font color="#E5E5E5"> an x86 machine</font>

205
00:09:53,899 --> 00:10:00,260
we have intel vt-x<font color="#CCCCCC"> which facilitates</font>

206
00:09:57,620 --> 00:10:02,510
virtualization also<font color="#CCCCCC"> pity</font><font color="#E5E5E5"> trace can</font>

207
00:10:00,260 --> 00:10:05,450
provide more<font color="#CCCCCC"> feedback information</font><font color="#E5E5E5"> for</font>

208
00:10:02,510 --> 00:10:07,579
the<font color="#CCCCCC"> fuzzers if you want to find more</font>

209
00:10:05,450 --> 00:10:09,529
<font color="#E5E5E5">bugs in the kernel especially in on</font>

210
00:10:07,579 --> 00:10:12,050
crashing bugs<font color="#CCCCCC"> there are some kernel</font>

211
00:10:09,529 --> 00:10:16,310
sanitizers which are helpful for<font color="#E5E5E5"> example</font>

212
00:10:12,050 --> 00:10:19,810
<font color="#CCCCCC">Kazon</font><font color="#E5E5E5"> and KMS</font><font color="#CCCCCC"> on helps to find memory</font>

213
00:10:16,310 --> 00:10:23,060
but like out<font color="#E5E5E5"> of order out</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> bond</font>

214
00:10:19,810 --> 00:10:26,329
accesses<font color="#E5E5E5"> and</font><font color="#CCCCCC"> katie sun is useful for</font>

215
00:10:23,060 --> 00:10:30,920
fine<font color="#E5E5E5"> data races but because mobile</font>

216
00:10:26,329 --> 00:10:33,739
system usually<font color="#E5E5E5"> use use older versions of</font>

217
00:10:30,920 --> 00:10:36,069
kernel these sanitizers are not

218
00:10:33,740 --> 00:10:38,990
available<font color="#E5E5E5"> for all</font><font color="#CCCCCC"> the mobile systems but</font>

219
00:10:36,070 --> 00:10:41,720
using our system we can<font color="#CCCCCC"> have these</font>

220
00:10:38,990 --> 00:10:45,529
mobile sanitizers<font color="#E5E5E5"> at eternal sanitizers</font>

221
00:10:41,720 --> 00:10:48,140
<font color="#E5E5E5">and find non crashing box another thing</font>

222
00:10:45,529 --> 00:10:49,970
is that<font color="#CCCCCC"> to fuzzing</font><font color="#E5E5E5"> you need to have the</font>

223
00:10:48,140 --> 00:10:53,240
output of<font color="#E5E5E5"> the program and you</font><font color="#CCCCCC"> need a</font>

224
00:10:49,970 --> 00:10:55,370
reliable console access this task is

225
00:10:53,240 --> 00:10:59,209
hard<font color="#E5E5E5"> for many mobile devices</font><font color="#CCCCCC"> because you</font>

226
00:10:55,370 --> 00:11:01,339
might need a specialized hardware or in

227
00:10:59,209 --> 00:11:04,790
<font color="#E5E5E5">some cases you need engineering effort</font>

228
00:11:01,339 --> 00:11:08,000
<font color="#CCCCCC">and soldering new devices</font><font color="#E5E5E5"> to your system</font>

229
00:11:04,790 --> 00:11:12,170
which in our system<font color="#E5E5E5"> it's not necessary</font>

230
00:11:08,000 --> 00:11:15,770
because we used a<font color="#E5E5E5"> normal USB channel to</font>

231
00:11:12,170 --> 00:11:17,990
test the fighting performance<font color="#E5E5E5"> we</font>

232
00:11:15,770 --> 00:11:20,970
experimented<font color="#CCCCCC"> two</font><font color="#E5E5E5"> scenarios</font>

233
00:11:17,990 --> 00:11:23,640
scenario<font color="#CCCCCC"> one</font><font color="#E5E5E5"> we run the father on a</font>

234
00:11:20,970 --> 00:11:27,950
phone and on scenario to execute the

235
00:11:23,640 --> 00:11:32,550
father<font color="#E5E5E5"> on an x86 server using our system</font>

236
00:11:27,950 --> 00:11:34,410
<font color="#E5E5E5">one good metric</font><font color="#CCCCCC"> to measure the</font>

237
00:11:32,550 --> 00:11:37,439
performance of the father is number of

238
00:11:34,410 --> 00:11:40,050
<font color="#E5E5E5">the father inputs you can run within a</font>

239
00:11:37,440 --> 00:11:42,540
given time<font color="#CCCCCC"> you can</font><font color="#E5E5E5"> see that based on</font>

240
00:11:40,050 --> 00:11:44,939
this metric<font color="#CCCCCC"> our system have a slightly</font>

241
00:11:42,540 --> 00:11:47,010
better<font color="#CCCCCC"> performance than</font><font color="#E5E5E5"> negative</font>

242
00:11:44,940 --> 00:11:52,050
execution of the father on the phone<font color="#CCCCCC"> it</font>

243
00:11:47,010 --> 00:11:54,210
might<font color="#E5E5E5"> seem surprising first but we</font>

244
00:11:52,050 --> 00:11:56,459
should notice that<font color="#E5E5E5"> in the</font><font color="#CCCCCC"> fuzzing</font>

245
00:11:54,210 --> 00:11:59,010
application because the<font color="#CCCCCC"> inputs to the</font>

246
00:11:56,460 --> 00:12:01,710
device drivers<font color="#E5E5E5"> are random they're not</font>

247
00:11:59,010 --> 00:12:03,990
they're not<font color="#E5E5E5"> causing many low level i/o</font>

248
00:12:01,710 --> 00:12:06,390
<font color="#E5E5E5">operations and because you're running</font><font color="#CCCCCC"> on</font>

249
00:12:03,990 --> 00:12:09,030
an x86 machine we<font color="#CCCCCC"> have a higher</font>

250
00:12:06,390 --> 00:12:12,540
performance course to execute which can

251
00:12:09,030 --> 00:12:16,140
can't compensate for the auto<font color="#E5E5E5"> forwarding</font>

252
00:12:12,540 --> 00:12:17,730
cost so by this we have a slightly

253
00:12:16,140 --> 00:12:21,449
better performance<font color="#CCCCCC"> on fuzzing</font>

254
00:12:17,730 --> 00:12:24,230
application<font color="#E5E5E5"> after we</font><font color="#CCCCCC"> fought</font><font color="#E5E5E5"> our drivers</font>

255
00:12:21,450 --> 00:12:27,210
<font color="#E5E5E5">using our</font><font color="#CCCCCC"> system we could find 25 bucks</font>

256
00:12:24,230 --> 00:12:29,130
<font color="#CCCCCC">14 of them where</font><font color="#E5E5E5"> new</font><font color="#CCCCCC"> BOTS which we</font>

257
00:12:27,210 --> 00:12:33,240
reported<font color="#CCCCCC"> most of them</font><font color="#E5E5E5"> to driver</font>

258
00:12:29,130 --> 00:12:35,730
developers<font color="#E5E5E5"> two of these bugs found by</font>

259
00:12:33,240 --> 00:12:38,070
<font color="#CCCCCC">kernel sanitizers</font><font color="#E5E5E5"> which were not</font>

260
00:12:35,730 --> 00:12:41,070
available<font color="#E5E5E5"> on that phone and the good</font>

261
00:12:38,070 --> 00:12:43,290
news<font color="#E5E5E5"> is that although we fought the</font>

262
00:12:41,070 --> 00:12:45,690
system<font color="#E5E5E5"> using a different machine which</font>

263
00:12:43,290 --> 00:12:48,329
has<font color="#CCCCCC"> a</font><font color="#E5E5E5"> different</font><font color="#CCCCCC"> architecture and we</font>

264
00:12:45,690 --> 00:12:51,900
<font color="#E5E5E5">change the timing of the device driver</font>

265
00:12:48,330 --> 00:12:54,900
by<font color="#E5E5E5"> forwarding the i/o we could verify</font>

266
00:12:51,900 --> 00:12:59,240
all of<font color="#CCCCCC"> these 25 parts on the phone</font><font color="#E5E5E5"> and</font>

267
00:12:54,900 --> 00:13:02,340
none<font color="#CCCCCC"> of them were</font><font color="#E5E5E5"> were false positives</font>

268
00:12:59,240 --> 00:13:04,070
the next dynamic analysis that we tested

269
00:13:02,340 --> 00:13:06,780
on<font color="#E5E5E5"> our system is record and replay</font>

270
00:13:04,070 --> 00:13:10,430
<font color="#E5E5E5">record and replay especially for mobile</font>

271
00:13:06,780 --> 00:13:13,980
<font color="#E5E5E5">device drivers is challenging and</font>

272
00:13:10,430 --> 00:13:14,640
without<font color="#E5E5E5"> our system but because</font><font color="#CCCCCC"> in</font><font color="#E5E5E5"> our</font>

273
00:13:13,980 --> 00:13:16,920
system

274
00:13:14,640 --> 00:13:20,400
all<font color="#E5E5E5"> of the interactions of the device</font>

275
00:13:16,920 --> 00:13:22,829
and the driver<font color="#E5E5E5"> are going through a</font>

276
00:13:20,400 --> 00:13:24,959
<font color="#E5E5E5">well-defined interfaces which all of</font>

277
00:13:22,830 --> 00:13:27,810
them goes<font color="#E5E5E5"> through</font><font color="#CCCCCC"> our stop in</font><font color="#E5E5E5"> the</font>

278
00:13:24,960 --> 00:13:30,090
virtual station hypervisor<font color="#E5E5E5"> we can record</font>

279
00:13:27,810 --> 00:13:30,819
all<font color="#CCCCCC"> of these interactions while we do</font>

280
00:13:30,090 --> 00:13:33,850
the record

281
00:13:30,820 --> 00:13:36,250
in some large and then<font color="#E5E5E5"> you replay</font><font color="#CCCCCC"> the</font>

282
00:13:33,850 --> 00:13:38,590
virtual machine we<font color="#E5E5E5"> can use our</font><font color="#CCCCCC"> lot to</font>

283
00:13:36,250 --> 00:13:41,710
replay<font color="#E5E5E5"> all of these interactions</font><font color="#CCCCCC"> the</font>

284
00:13:38,590 --> 00:13:44,650
good news here<font color="#CCCCCC"> is that you don't even</font>

285
00:13:41,710 --> 00:13:46,810
need<font color="#CCCCCC"> that specific mobile system</font><font color="#E5E5E5"> when</font>

286
00:13:44,650 --> 00:13:49,030
you're doing<font color="#CCCCCC"> replaying</font>

287
00:13:46,810 --> 00:13:51,790
for example consider<font color="#E5E5E5"> this scenario</font><font color="#CCCCCC"> that</font>

288
00:13:49,030 --> 00:13:54,400
you are fighting<font color="#E5E5E5"> you're fighting a</font>

289
00:13:51,790 --> 00:13:56,920
device driver and<font color="#CCCCCC"> you</font><font color="#E5E5E5"> find a</font><font color="#CCCCCC"> part while</font>

290
00:13:54,400 --> 00:14:00,579
you were recording<font color="#CCCCCC"> you</font><font color="#E5E5E5"> can send a lot to</font>

291
00:13:56,920 --> 00:14:04,329
any expert<font color="#E5E5E5"> in any city in a</font><font color="#CCCCCC"> different</font>

292
00:14:00,580 --> 00:14:06,190
<font color="#CCCCCC">locations</font><font color="#E5E5E5"> and he can analyze that part</font>

293
00:14:04,330 --> 00:14:11,290
for you without<font color="#CCCCCC"> accessing to that</font>

294
00:14:06,190 --> 00:14:13,780
<font color="#E5E5E5">specific mobile system to measure the</font>

295
00:14:11,290 --> 00:14:17,980
<font color="#E5E5E5">performance of record and replay on in</font>

296
00:14:13,780 --> 00:14:19,810
our system we measured the very eye on

297
00:14:17,980 --> 00:14:23,530
intensive<font color="#E5E5E5"> tasks which is camera</font>

298
00:14:19,810 --> 00:14:25,180
initialization<font color="#CCCCCC"> time because in this</font>

299
00:14:23,530 --> 00:14:27,579
process<font color="#E5E5E5"> there are a lot of</font><font color="#CCCCCC"> other</font>

300
00:14:25,180 --> 00:14:29,500
<font color="#CCCCCC">operations</font><font color="#E5E5E5"> we can see the perform at the</font>

301
00:14:27,580 --> 00:14:33,040
time it takes<font color="#E5E5E5"> to initialize the camera</font>

302
00:14:29,500 --> 00:14:36,340
driver<font color="#E5E5E5"> in charm is more than that time</font>

303
00:14:33,040 --> 00:14:39,120
the same<font color="#E5E5E5"> time in the phone and when we</font>

304
00:14:36,340 --> 00:14:41,530
do recording<font color="#E5E5E5"> we have a slight</font>

305
00:14:39,120 --> 00:14:45,250
<font color="#E5E5E5">performance overhead</font><font color="#CCCCCC"> but the good thing</font>

306
00:14:41,530 --> 00:14:47,500
is is that<font color="#E5E5E5"> and we replay that same</font>

307
00:14:45,250 --> 00:14:50,800
<font color="#E5E5E5">process we have a good performance which</font>

308
00:14:47,500 --> 00:14:56,170
is<font color="#E5E5E5"> even better than</font><font color="#CCCCCC"> normal execution</font><font color="#E5E5E5"> of</font>

309
00:14:50,800 --> 00:14:58,270
the camera driver<font color="#E5E5E5"> on the phone the</font><font color="#CCCCCC"> next</font>

310
00:14:56,170 --> 00:15:01,020
dynamic analysis that<font color="#E5E5E5"> we tested in our</font>

311
00:14:58,270 --> 00:15:04,240
system is manual interactive debugging

312
00:15:01,020 --> 00:15:09,040
<font color="#E5E5E5">because we want</font><font color="#CCCCCC"> a device driver</font><font color="#E5E5E5"> within a</font>

313
00:15:04,240 --> 00:15:11,920
<font color="#CCCCCC">virtual machine we can</font><font color="#E5E5E5"> use the gdb</font><font color="#CCCCCC"> we</font>

314
00:15:09,040 --> 00:15:14,650
can use the gdb on our VM and<font color="#E5E5E5"> on the</font>

315
00:15:11,920 --> 00:15:18,160
device driver<font color="#E5E5E5"> so we can add breakpoints</font>

316
00:15:14,650 --> 00:15:21,250
<font color="#CCCCCC">to the code we can add a watch point to</font>

317
00:15:18,160 --> 00:15:24,069
see memory interactions<font color="#E5E5E5"> and even we can</font>

318
00:15:21,250 --> 00:15:27,520
do single<font color="#E5E5E5"> step execution on</font><font color="#CCCCCC"> the device</font>

319
00:15:24,070 --> 00:15:30,030
driver<font color="#E5E5E5"> using these</font><font color="#CCCCCC"> capabilities we could</font>

320
00:15:27,520 --> 00:15:33,490
<font color="#E5E5E5">analyze three known vulnerabilities and</font>

321
00:15:30,030 --> 00:15:36,550
<font color="#E5E5E5">we also can build an arbitrary kernel</font>

322
00:15:33,490 --> 00:15:38,650
code execution<font color="#E5E5E5"> exploit using one of</font>

323
00:15:36,550 --> 00:15:42,449
these vulnerability with help of gdb

324
00:15:38,650 --> 00:15:47,279
because we have gdb we can easily

325
00:15:42,449 --> 00:15:50,488
see the heap object allocation and also

326
00:15:47,279 --> 00:15:54,660
memory layout<font color="#E5E5E5"> which helps</font><font color="#CCCCCC"> us helps us</font><font color="#E5E5E5"> a</font>

327
00:15:50,489 --> 00:15:59,699
lot in building this journal exploit<font color="#E5E5E5"> on</font>

328
00:15:54,660 --> 00:16:04,618
top of out of<font color="#CCCCCC"> bounds right</font><font color="#E5E5E5"> out of</font><font color="#CCCCCC"> bonds</font>

329
00:15:59,699 --> 00:16:07,889
<font color="#CCCCCC">right vulnerability I want to compare</font>

330
00:16:04,619 --> 00:16:10,410
our work with<font color="#E5E5E5"> two to the two of the most</font>

331
00:16:07,889 --> 00:16:13,019
<font color="#E5E5E5">closest related work avatar and</font>

332
00:16:10,410 --> 00:16:17,969
surrogate which both of<font color="#CCCCCC"> them</font><font color="#E5E5E5"> same as our</font>

333
00:16:13,019 --> 00:16:20,129
system use<font color="#E5E5E5"> of</font><font color="#CCCCCC"> IO access forwarding in in</font>

334
00:16:17,970 --> 00:16:22,859
<font color="#E5E5E5">low-level Alexis's</font><font color="#CCCCCC"> but the main</font>

335
00:16:20,129 --> 00:16:26,699
<font color="#CCCCCC">difference is</font><font color="#E5E5E5"> that the target in Avatar</font>

336
00:16:22,859 --> 00:16:29,100
<font color="#CCCCCC">and surrogate</font><font color="#E5E5E5"> their target system is the</font>

337
00:16:26,699 --> 00:16:32,219
<font color="#CCCCCC">hole</font><font color="#E5E5E5"> closed source embedded system</font>

338
00:16:29,100 --> 00:16:34,470
<font color="#CCCCCC">framer</font><font color="#E5E5E5"> binary but in our system we want</font>

339
00:16:32,220 --> 00:16:36,269
to support a part of mobile system

340
00:16:34,470 --> 00:16:39,239
<font color="#CCCCCC">software which is open source device</font>

341
00:16:36,269 --> 00:16:41,609
driver and the communication channel<font color="#E5E5E5"> is</font>

342
00:16:39,239 --> 00:16:43,799
different in<font color="#E5E5E5"> our system</font><font color="#CCCCCC"> - we use the</font>

343
00:16:41,609 --> 00:16:47,459
normal USB<font color="#E5E5E5"> which is available everywhere</font>

344
00:16:43,799 --> 00:16:49,919
but<font color="#CCCCCC"> Avatar used the UART and JTAG which</font>

345
00:16:47,459 --> 00:16:53,939
leads<font color="#CCCCCC"> to very poor performance</font><font color="#E5E5E5"> and</font>

346
00:16:49,919 --> 00:16:59,639
surrogate<font color="#CCCCCC"> use PCI Express FPGA</font><font color="#E5E5E5"> board</font>

347
00:16:53,939 --> 00:17:04,678
which is not available<font color="#CCCCCC"> everywhere we we</font>

348
00:16:59,639 --> 00:17:07,230
plan to automate the porting driver<font color="#CCCCCC"> -</font><font color="#E5E5E5"> to</font>

349
00:17:04,679 --> 00:17:10,049
our system in our future work we also

350
00:17:07,230 --> 00:17:12,209
plan<font color="#CCCCCC"> to support the DMA as another</font>

351
00:17:10,049 --> 00:17:14,220
interface<font color="#E5E5E5"> between the driver</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> the</font>

352
00:17:12,209 --> 00:17:17,459
device<font color="#E5E5E5"> and in addition to many</font>

353
00:17:14,220 --> 00:17:19,829
<font color="#CCCCCC">open-source device drivers which charm</font>

354
00:17:17,459 --> 00:17:24,899
<font color="#E5E5E5">already supports we</font><font color="#CCCCCC"> planned to support</font>

355
00:17:19,829 --> 00:17:27,299
<font color="#CCCCCC">binary drivers</font><font color="#E5E5E5"> as well</font><font color="#CCCCCC"> in summary</font><font color="#E5E5E5"> our</font>

356
00:17:24,898 --> 00:17:29,459
system facilitates dynamic analysis<font color="#E5E5E5"> of</font>

357
00:17:27,299 --> 00:17:31,620
mobile device drivers<font color="#E5E5E5"> Charles</font>

358
00:17:29,460 --> 00:17:34,049
performance is similar<font color="#E5E5E5"> for dynamic</font>

359
00:17:31,620 --> 00:17:37,260
analysis like fuzzing is similar to the

360
00:17:34,049 --> 00:17:38,850
<font color="#E5E5E5">actual mobile systems and</font><font color="#CCCCCC"> charms'</font>

361
00:17:37,260 --> 00:17:41,129
supports a broad variety of device

362
00:17:38,850 --> 00:17:43,559
drivers<font color="#CCCCCC"> with reasonable engineering</font>

363
00:17:41,130 --> 00:17:46,320
effort should mention<font color="#CCCCCC"> that our system is</font>

364
00:17:43,559 --> 00:17:48,809
open<font color="#CCCCCC"> sourced you can find it in this</font>

365
00:17:46,320 --> 00:17:51,178
link<font color="#E5E5E5"> and using that QR code our slides</font>

366
00:17:48,809 --> 00:17:54,178
will be available in using using

367
00:17:51,179 --> 00:17:55,500
<font color="#E5E5E5">security website and</font><font color="#CCCCCC"> I'm going</font><font color="#E5E5E5"> to demo</font>

368
00:17:54,179 --> 00:17:58,100
<font color="#CCCCCC">our system</font>

369
00:17:55,500 --> 00:18:00,660
tomorrow at the poster and demolition

370
00:17:58,100 --> 00:18:03,610
<font color="#CCCCCC">thank you</font><font color="#E5E5E5"> for your attention and time</font>

371
00:18:00,660 --> 00:18:04,500
I'm happy<font color="#CCCCCC"> to answer your</font><font color="#E5E5E5"> questions</font>

372
00:18:03,610 --> 00:18:08,570
[Applause]

373
00:18:04,500 --> 00:18:12,750
[Music]

374
00:18:08,570 --> 00:18:12,750
[Applause]

375
00:18:20,820 --> 00:18:27,060
hi first of all thanks<font color="#CCCCCC"> for</font><font color="#E5E5E5"> the talk</font>

376
00:18:23,510 --> 00:18:28,800
<font color="#E5E5E5">that's great</font><font color="#CCCCCC"> I have a short question so</font>

377
00:18:27,060 --> 00:18:32,240
I was a<font color="#E5E5E5"> little bit confused when</font><font color="#CCCCCC"> you</font>

378
00:18:28,800 --> 00:18:35,190
said as part of your motivation<font color="#CCCCCC"> that</font>

379
00:18:32,240 --> 00:18:36,960
mobile system and<font color="#CCCCCC"> PI</font><font color="#E5E5E5"> mobile system I</font>

380
00:18:35,190 --> 00:18:41,160
<font color="#CCCCCC">just assumed that you're targeting all</font>

381
00:18:36,960 --> 00:18:44,160
the ARM based systems on<font color="#E5E5E5"> market don't</font>

382
00:18:41,160 --> 00:18:46,650
support<font color="#E5E5E5"> hardware virtualization</font><font color="#CCCCCC"> and</font>

383
00:18:44,160 --> 00:18:48,990
therefore we don't<font color="#E5E5E5"> have virtual</font><font color="#CCCCCC"> machines</font>

384
00:18:46,650 --> 00:18:51,540
which support which are running<font color="#E5E5E5"> on arm</font>

385
00:18:48,990 --> 00:18:54,660
basically<font color="#E5E5E5"> have you looked at then</font>

386
00:18:51,540 --> 00:18:57,270
because<font color="#E5E5E5"> Xen does exactly that and for</font>

387
00:18:54,660 --> 00:19:00,900
several several years<font color="#CCCCCC"> no and my question</font>

388
00:18:57,270 --> 00:19:04,740
is why didn't you just<font color="#E5E5E5"> port something</font>

389
00:19:00,900 --> 00:19:06,930
like<font color="#CCCCCC"> ka FL -</font><font color="#E5E5E5"> then thank you that's a</font>

390
00:19:04,740 --> 00:19:09,390
good question<font color="#E5E5E5"> although</font><font color="#CCCCCC"> ARM architecture</font>

391
00:19:06,930 --> 00:19:12,440
<font color="#E5E5E5">supports visualization and we have then</font>

392
00:19:09,390 --> 00:19:15,000
the visualization hardware is not

393
00:19:12,440 --> 00:19:17,550
supported in<font color="#CCCCCC"> many mobile phones for</font>

394
00:19:15,000 --> 00:19:20,640
example<font color="#CCCCCC"> they locked it because they want</font>

395
00:19:17,550 --> 00:19:22,560
<font color="#E5E5E5">to prevent rootkits to use them use</font><font color="#CCCCCC"> them</font>

396
00:19:20,640 --> 00:19:24,990
<font color="#E5E5E5">and they they're locked and you cannot</font>

397
00:19:22,560 --> 00:19:28,440
use<font color="#E5E5E5"> on the for example</font><font color="#CCCCCC"> for a Nexus phone</font>

398
00:19:24,990 --> 00:19:30,480
you cannot have a<font color="#E5E5E5"> harder assisted</font>

399
00:19:28,440 --> 00:19:32,970
virtual machine on that<font color="#E5E5E5"> although there</font>

400
00:19:30,480 --> 00:19:35,280
<font color="#E5E5E5">are some shapes your support</font><font color="#CCCCCC"> at all</font>

401
00:19:32,970 --> 00:19:36,900
right but yes<font color="#E5E5E5"> so there are development</font>

402
00:19:35,280 --> 00:19:38,910
boards where you could do basically<font color="#CCCCCC"> the</font>

403
00:19:36,900 --> 00:19:39,680
<font color="#E5E5E5">same but</font><font color="#CCCCCC"> alright that answers my</font>

404
00:19:38,910 --> 00:19:42,680
question

405
00:19:39,680 --> 00:19:42,680
<font color="#E5E5E5">Thanks</font>

406
00:19:52,670 --> 00:19:59,280
so thank you<font color="#E5E5E5"> that's it very</font><font color="#CCCCCC"> good</font>

407
00:19:55,290 --> 00:20:01,649
<font color="#E5E5E5">questions</font><font color="#CCCCCC"> type of for</font><font color="#E5E5E5"> example most of</font>

408
00:19:59,280 --> 00:20:04,500
<font color="#E5E5E5">the box that we find</font><font color="#CCCCCC"> where null pointer</font>

409
00:20:01,650 --> 00:20:08,190
dereferences<font color="#E5E5E5"> and this null pointer</font>

410
00:20:04,500 --> 00:20:11,670
dereferences<font color="#E5E5E5"> can directly be exploitable</font>

411
00:20:08,190 --> 00:20:13,410
in<font color="#E5E5E5"> stone scenarios and there I found a</font>

412
00:20:11,670 --> 00:20:17,970
study I can<font color="#CCCCCC"> share</font><font color="#E5E5E5"> you after the</font>

413
00:20:13,410 --> 00:20:21,630
presentation that even the the bug is

414
00:20:17,970 --> 00:20:25,410
not<font color="#E5E5E5"> directly exploitable</font><font color="#CCCCCC"> there is a new</font>

415
00:20:21,630 --> 00:20:27,690
project<font color="#E5E5E5"> that they could build an exploit</font>

416
00:20:25,410 --> 00:20:30,510
using<font color="#E5E5E5"> denial of service box for example</font>

417
00:20:27,690 --> 00:20:34,560
<font color="#CCCCCC">any work that</font><font color="#E5E5E5"> can crash the system</font><font color="#CCCCCC"> they</font>

418
00:20:30,510 --> 00:20:37,710
exploit something<font color="#E5E5E5"> in crash handling that</font>

419
00:20:34,560 --> 00:20:41,370
can<font color="#CCCCCC"> results</font><font color="#E5E5E5"> in arbitrary code execution</font>

420
00:20:37,710 --> 00:20:44,060
<font color="#E5E5E5">and if you have any</font><font color="#CCCCCC"> park</font><font color="#E5E5E5"> that can crash</font>

421
00:20:41,370 --> 00:20:47,030
a system crash parts of the<font color="#CCCCCC"> system that</font>

422
00:20:44,060 --> 00:20:52,010
that<font color="#CCCCCC"> project suffers it can lead to</font>

423
00:20:47,030 --> 00:20:55,290
exploit but and<font color="#E5E5E5"> two of our</font><font color="#CCCCCC"> bugs we're</font>

424
00:20:52,010 --> 00:20:58,110
out of pond<font color="#E5E5E5"> and memory accesses which</font>

425
00:20:55,290 --> 00:20:59,909
then they<font color="#CCCCCC"> also potentially can be</font>

426
00:20:58,110 --> 00:21:03,479
exploitable<font color="#E5E5E5"> but we didn't</font><font color="#CCCCCC"> feel the need</font>

427
00:20:59,910 --> 00:21:07,650
<font color="#CCCCCC">on</font><font color="#E5E5E5"> top of that are so high</font><font color="#CCCCCC"> thankfully</font>

428
00:21:03,480 --> 00:21:09,420
<font color="#E5E5E5">took over from</font><font color="#CCCCCC"> Eureka my question</font><font color="#E5E5E5"> is if</font>

429
00:21:07,650 --> 00:21:11,460
I must<font color="#E5E5E5"> on well you currently support</font>

430
00:21:09,420 --> 00:21:13,560
only drivers for we<font color="#E5E5E5"> should</font><font color="#CCCCCC"> the source</font>

431
00:21:11,460 --> 00:21:16,920
code on you do some limitation on the

432
00:21:13,560 --> 00:21:21,929
driver<font color="#CCCCCC"> what it would take</font><font color="#E5E5E5"> to support</font>

433
00:21:16,920 --> 00:21:25,650
binary drivers<font color="#E5E5E5"> yes the most important</font>

434
00:21:21,930 --> 00:21:31,140
part is that for for supporting binary

435
00:21:25,650 --> 00:21:34,910
is for support for our<font color="#E5E5E5"> RPC interface we</font>

436
00:21:31,140 --> 00:21:40,140
need to change some part of the code

437
00:21:34,910 --> 00:21:43,110
<font color="#CCCCCC">that on binary some part of the code of</font>

438
00:21:40,140 --> 00:21:47,910
the driver<font color="#CCCCCC"> as the changes are small but</font>

439
00:21:43,110 --> 00:21:50,840
<font color="#E5E5E5">there are they are and for supporting</font>

440
00:21:47,910 --> 00:21:53,580
binary drivers<font color="#E5E5E5"> which can we should do</font>

441
00:21:50,840 --> 00:21:56,399
binary instrumentation to change those

442
00:21:53,580 --> 00:22:00,110
part of<font color="#E5E5E5"> the driver but they they can be</font>

443
00:21:56,400 --> 00:22:00,110
<font color="#E5E5E5">supported thank you</font>

444
00:22:05,330 --> 00:22:13,529
[Music]

445
00:22:05,410 --> 00:22:13,529
[Applause]

