1
00:00:10,060 --> 00:00:16,369
<font color="#E5E5E5">all right</font><font color="#CCCCCC"> thank</font><font color="#E5E5E5"> you for the introduction</font>

2
00:00:12,950 --> 00:00:18,529
<font color="#CCCCCC">I'm Michele</font><font color="#E5E5E5"> Wong and I'm a PhD students</font>

3
00:00:16,369 --> 00:00:20,720
at the University of<font color="#E5E5E5"> Toronto</font><font color="#CCCCCC"> studying</font>

4
00:00:18,529 --> 00:00:23,000
with my advisor professor<font color="#E5E5E5"> David Lee and</font>

5
00:00:20,720 --> 00:00:25,430
<font color="#E5E5E5">our paper is on</font><font color="#CCCCCC"> a new</font><font color="#E5E5E5"> type of</font>

6
00:00:23,000 --> 00:00:27,100
<font color="#CCCCCC">obfuscation that we're seeing in Android</font>

7
00:00:25,430 --> 00:00:29,660
malware<font color="#E5E5E5"> and the tool that we've</font>

8
00:00:27,100 --> 00:00:32,900
<font color="#CCCCCC">developed</font><font color="#E5E5E5"> to try to detect and D</font><font color="#CCCCCC"> off</font>

9
00:00:29,660 --> 00:00:35,330
<font color="#CCCCCC">escape these techniques so there's been</font>

10
00:00:32,900 --> 00:00:37,610
a large<font color="#E5E5E5"> body of</font><font color="#CCCCCC"> research in mobile</font>

11
00:00:35,330 --> 00:00:40,309
security<font color="#E5E5E5"> into the development of</font>

12
00:00:37,610 --> 00:00:42,590
analysis and detection<font color="#E5E5E5"> tools for Android</font>

13
00:00:40,309 --> 00:00:44,899
malware<font color="#E5E5E5"> and in response to the scrutiny</font>

14
00:00:42,590 --> 00:00:46,820
<font color="#E5E5E5">malware developers of course tried to</font>

15
00:00:44,899 --> 00:00:48,649
hide the actions that<font color="#CCCCCC"> their applications</font>

16
00:00:46,820 --> 00:00:50,719
take so<font color="#CCCCCC"> that these applications don't</font>

17
00:00:48,649 --> 00:00:52,100
<font color="#E5E5E5">get flagged as malware and they</font>

18
00:00:50,719 --> 00:00:53,989
<font color="#E5E5E5">generally do this by using code</font>

19
00:00:52,100 --> 00:00:57,260
obfuscation techniques to defeat code

20
00:00:53,989 --> 00:01:00,769
analysis we've seen obfuscation in x86

21
00:00:57,260 --> 00:01:02,620
malware on mobile and on<font color="#E5E5E5"> Android devices</font>

22
00:01:00,770 --> 00:01:05,149
the obfuscation techniques that are<font color="#E5E5E5"> used</font>

23
00:01:02,620 --> 00:01:07,130
<font color="#CCCCCC">manifests a little bit differently</font><font color="#E5E5E5"> since</font>

24
00:01:05,149 --> 00:01:10,250
<font color="#E5E5E5">most applications are implemented in</font>

25
00:01:07,130 --> 00:01:12,860
<font color="#E5E5E5">Java compiled into a text bytecode</font>

26
00:01:10,250 --> 00:01:15,979
format and then executed on a custom<font color="#E5E5E5"> run</font>

27
00:01:12,860 --> 00:01:18,679
<font color="#E5E5E5">time on</font><font color="#CCCCCC"> the Android device</font><font color="#E5E5E5"> previous work</font>

28
00:01:15,979 --> 00:01:21,020
into Android<font color="#E5E5E5"> deification</font><font color="#CCCCCC"> has</font><font color="#E5E5E5"> mostly</font>

29
00:01:18,679 --> 00:01:23,330
looked into how the applications Java or

30
00:01:21,020 --> 00:01:25,880
Dex bytecode tries to hide<font color="#E5E5E5"> itself from</font>

31
00:01:23,330 --> 00:01:27,950
analysis and<font color="#CCCCCC"> thus Singley the techniques</font>

32
00:01:25,880 --> 00:01:30,830
like<font color="#CCCCCC"> using reflection</font><font color="#E5E5E5"> dynamic code</font>

33
00:01:27,950 --> 00:01:33,440
loading<font color="#E5E5E5"> or hiding specific functionality</font>

34
00:01:30,830 --> 00:01:36,590
in native code<font color="#E5E5E5"> and invoking it using the</font>

35
00:01:33,440 --> 00:01:38,479
Java native interface or J&I since a lot

36
00:01:36,590 --> 00:01:41,660
of<font color="#E5E5E5"> existing security tools are limited</font>

37
00:01:38,479 --> 00:01:43,310
to Java code analysis<font color="#E5E5E5"> in this work we</font>

38
00:01:41,660 --> 00:01:45,530
refer to these techniques<font color="#CCCCCC"> as language</font>

39
00:01:43,310 --> 00:01:47,869
based<font color="#E5E5E5"> office</font><font color="#CCCCCC"> keishon since they worked</font>

40
00:01:45,530 --> 00:01:49,729
by making use of features<font color="#E5E5E5"> of the</font><font color="#CCCCCC"> Java</font>

41
00:01:47,869 --> 00:01:52,509
<font color="#E5E5E5">programming language</font><font color="#CCCCCC"> and the use of</font>

42
00:01:49,729 --> 00:01:55,910
<font color="#CCCCCC">these features such as specific api's is</font>

43
00:01:52,509 --> 00:01:58,580
detectable in the<font color="#CCCCCC"> bytecode and the</font>

44
00:01:55,910 --> 00:02:00,560
detectable by an analyzer<font color="#CCCCCC"> but not always</font>

45
00:01:58,580 --> 00:02:03,979
resolvable without some form of runtime

46
00:02:00,560 --> 00:02:06,050
<font color="#E5E5E5">information about the application on the</font>

47
00:02:03,979 --> 00:02:09,739
other hand an application could try to

48
00:02:06,050 --> 00:02:12,739
hide<font color="#E5E5E5"> itself as much as possible by</font>

49
00:02:09,739 --> 00:02:14,660
implementing it in by having<font color="#CCCCCC"> it</font>

50
00:02:12,739 --> 00:02:17,030
implemented entirely in native code

51
00:02:14,660 --> 00:02:19,400
<font color="#CCCCCC">bypassing the</font><font color="#E5E5E5"> Java</font><font color="#CCCCCC"> runtime and any sort</font>

52
00:02:17,030 --> 00:02:21,260
<font color="#E5E5E5">of</font><font color="#CCCCCC"> Java code</font><font color="#E5E5E5"> analysis and to do this</font>

53
00:02:19,400 --> 00:02:21,920
<font color="#E5E5E5">there can be no indications to Java</font>

54
00:02:21,260 --> 00:02:25,130
methods

55
00:02:21,920 --> 00:02:27,019
of any kind<font color="#CCCCCC"> we call this full native</font>

56
00:02:25,130 --> 00:02:29,510
code obfuscation and theoretically they

57
00:02:27,020 --> 00:02:31,880
<font color="#CCCCCC">could also use</font><font color="#E5E5E5"> existing x86 office</font>

58
00:02:29,510 --> 00:02:34,849
<font color="#CCCCCC">keishon techniques to pot itself even</font>

59
00:02:31,880 --> 00:02:37,220
<font color="#CCCCCC">more while this is a</font><font color="#E5E5E5"> very effective way</font>

60
00:02:34,849 --> 00:02:39,350
of<font color="#E5E5E5"> performing Android application</font>

61
00:02:37,220 --> 00:02:41,180
obfuscation<font color="#CCCCCC"> we don't</font><font color="#E5E5E5"> really find a lot</font>

62
00:02:39,350 --> 00:02:43,340
<font color="#CCCCCC">of examples of malware</font><font color="#E5E5E5"> that do this and</font>

63
00:02:41,180 --> 00:02:45,709
we believe this<font color="#CCCCCC"> is because</font><font color="#E5E5E5"> most of the</font>

64
00:02:43,340 --> 00:02:48,739
interesting<font color="#E5E5E5"> sensitive functionality on</font>

65
00:02:45,709 --> 00:02:50,900
an<font color="#E5E5E5"> Android</font><font color="#CCCCCC"> device that am our developer</font>

66
00:02:48,739 --> 00:02:53,090
<font color="#E5E5E5">would want to abuse is provided by</font>

67
00:02:50,900 --> 00:02:54,920
system services<font color="#E5E5E5"> and accessible through</font>

68
00:02:53,090 --> 00:02:57,319
<font color="#CCCCCC">the android framework</font><font color="#E5E5E5"> and the api's it</font>

69
00:02:54,920 --> 00:03:00,319
provides<font color="#E5E5E5"> however the framework and the</font>

70
00:02:57,319 --> 00:03:02,540
api's are<font color="#E5E5E5"> mostly implemented in Java so</font>

71
00:03:00,319 --> 00:03:04,238
a full native code<font color="#CCCCCC"> application that</font>

72
00:03:02,540 --> 00:03:06,980
would want<font color="#E5E5E5"> to access this functionality</font>

73
00:03:04,239 --> 00:03:08,840
<font color="#E5E5E5">generally has</font><font color="#CCCCCC"> to bypass</font><font color="#E5E5E5"> the framework</font>

74
00:03:06,980 --> 00:03:11,209
and access either<font color="#E5E5E5"> low-level or</font>

75
00:03:08,840 --> 00:03:13,130
undocumented<font color="#E5E5E5"> interfaces of the system</font>

76
00:03:11,209 --> 00:03:15,680
services themselves<font color="#E5E5E5"> making these</font>

77
00:03:13,130 --> 00:03:17,660
applications more difficult to<font color="#CCCCCC"> implement</font>

78
00:03:15,680 --> 00:03:21,580
<font color="#E5E5E5">and more susceptible to compatibility</font>

79
00:03:17,660 --> 00:03:21,579
loss<font color="#E5E5E5"> if these interfaces should change</font>

80
00:03:21,819 --> 00:03:26,690
in this work<font color="#E5E5E5"> we were interested in</font>

81
00:03:24,650 --> 00:03:28,400
whether other types of office station

82
00:03:26,690 --> 00:03:30,470
was possible for<font color="#E5E5E5"> Android applications</font>

83
00:03:28,400 --> 00:03:32,150
<font color="#E5E5E5">and specifically whether there was a</font>

84
00:03:30,470 --> 00:03:34,310
middle<font color="#E5E5E5"> ground between language based</font>

85
00:03:32,150 --> 00:03:36,320
office station which<font color="#CCCCCC"> is fairly easy to</font>

86
00:03:34,310 --> 00:03:38,060
<font color="#E5E5E5">use but also</font><font color="#CCCCCC"> either the</font><font color="#E5E5E5"> obfuscated</font>

87
00:03:36,320 --> 00:03:40,579
versus full native code obfuscation

88
00:03:38,060 --> 00:03:42,709
<font color="#CCCCCC">which is effective but</font><font color="#E5E5E5"> makes it</font>

89
00:03:40,579 --> 00:03:44,810
difficult<font color="#CCCCCC"> to access that sensitive</font>

90
00:03:42,709 --> 00:03:46,760
<font color="#CCCCCC">android functionality and in our</font>

91
00:03:44,810 --> 00:03:48,650
investigation of recent Android malware

92
00:03:46,760 --> 00:03:51,230
we found that<font color="#E5E5E5"> this middle ground does</font>

93
00:03:48,650 --> 00:03:53,359
exist<font color="#E5E5E5"> and applications do this by</font>

94
00:03:51,230 --> 00:03:55,548
<font color="#CCCCCC">tampering or modifying the runtime</font>

95
00:03:53,359 --> 00:03:58,609
<font color="#CCCCCC">that's actually executing it's Java or</font>

96
00:03:55,549 --> 00:04:00,260
<font color="#E5E5E5">Dex bytecode we look at these techniques</font>

97
00:03:58,609 --> 00:04:02,420
<font color="#E5E5E5">and call them runtime based</font><font color="#CCCCCC"> office</font>

98
00:04:00,260 --> 00:04:04,280
keishon and it essentially<font color="#CCCCCC"> allows an</font>

99
00:04:02,420 --> 00:04:05,690
application<font color="#CCCCCC"> the sort</font><font color="#E5E5E5"> of declared that</font>

100
00:04:04,280 --> 00:04:07,780
they're<font color="#E5E5E5"> doing one thing when</font><font color="#CCCCCC"> really</font>

101
00:04:05,690 --> 00:04:10,400
doing<font color="#E5E5E5"> something else under the covers</font><font color="#CCCCCC"> so</font>

102
00:04:07,780 --> 00:04:13,010
<font color="#CCCCCC">the way runtime based office</font><font color="#E5E5E5"> station</font>

103
00:04:10,400 --> 00:04:15,829
<font color="#E5E5E5">usually works is that the application</font>

104
00:04:13,010 --> 00:04:17,630
will load or initialize the runtime<font color="#E5E5E5"> with</font>

105
00:04:15,829 --> 00:04:20,269
some Dex<font color="#CCCCCC"> file that seems fairly</font>

106
00:04:17,630 --> 00:04:23,419
innocuous<font color="#E5E5E5"> and would probably get flagged</font>

107
00:04:20,269 --> 00:04:25,310
as benign<font color="#E5E5E5"> by an analyzer however the</font>

108
00:04:23,419 --> 00:04:27,200
application<font color="#E5E5E5"> also has</font><font color="#CCCCCC"> a separate</font>

109
00:04:25,310 --> 00:04:29,840
component<font color="#CCCCCC"> that's not necessarily</font>

110
00:04:27,200 --> 00:04:31,039
malicious per se<font color="#E5E5E5"> but it's</font><font color="#CCCCCC"> definitely in</font>

111
00:04:29,840 --> 00:04:33,320
a<font color="#E5E5E5"> gray area</font>

112
00:04:31,040 --> 00:04:35,000
it changes values in the<font color="#E5E5E5"> runtime</font><font color="#CCCCCC"> that</font>

113
00:04:33,320 --> 00:04:37,880
applications normally wouldn't access

114
00:04:35,000 --> 00:04:40,490
and the results of<font color="#E5E5E5"> these changes is that</font>

115
00:04:37,880 --> 00:04:42,320
for instance<font color="#CCCCCC"> the</font><font color="#E5E5E5"> runtime may think that</font>

116
00:04:40,490 --> 00:04:44,450
it's loading a class from this benign

117
00:04:42,320 --> 00:04:45,860
<font color="#CCCCCC">decks ball when really it's loading a</font>

118
00:04:44,450 --> 00:04:48,320
class from a different source of

119
00:04:45,860 --> 00:04:50,780
<font color="#CCCCCC">bytecode</font><font color="#E5E5E5"> similarly the runtime they</font>

120
00:04:48,320 --> 00:04:52,849
think<font color="#E5E5E5"> it's invoking one method when</font>

121
00:04:50,780 --> 00:04:54,830
really it's invoking another<font color="#E5E5E5"> or it's</font>

122
00:04:52,850 --> 00:04:56,690
executing instructions for some benign

123
00:04:54,830 --> 00:04:58,340
method when really it's executing

124
00:04:56,690 --> 00:05:01,370
instructions from some<font color="#E5E5E5"> different source</font>

125
00:04:58,340 --> 00:05:04,130
<font color="#E5E5E5">and the benefits of</font><font color="#CCCCCC"> doing this runtime</font>

126
00:05:01,370 --> 00:05:06,320
tampering<font color="#E5E5E5"> to achieve obfuscation</font><font color="#CCCCCC"> is that</font>

127
00:05:04,130 --> 00:05:08,420
while the tampering or modification<font color="#E5E5E5"> of</font>

128
00:05:06,320 --> 00:05:10,700
runtime<font color="#CCCCCC"> state has</font><font color="#E5E5E5"> to be done in native</font>

129
00:05:08,420 --> 00:05:12,980
code<font color="#CCCCCC"> due</font><font color="#E5E5E5"> to the memory management</font>

130
00:05:10,700 --> 00:05:14,570
<font color="#E5E5E5">restrictions in</font><font color="#CCCCCC"> java</font><font color="#E5E5E5"> the actual</font>

131
00:05:12,980 --> 00:05:17,000
obfuscated or hidden<font color="#E5E5E5"> code that's</font>

132
00:05:14,570 --> 00:05:17,420
executed as a result is implemented in

133
00:05:17,000 --> 00:05:19,220
Java

134
00:05:17,420 --> 00:05:20,960
meaning that malicious<font color="#E5E5E5"> code that's</font>

135
00:05:19,220 --> 00:05:22,970
office gated in this way has easy access

136
00:05:20,960 --> 00:05:26,539
<font color="#CCCCCC">to those framework api's</font><font color="#E5E5E5"> and the</font>

137
00:05:22,970 --> 00:05:28,610
functionality<font color="#E5E5E5"> they provide so to look at</font>

138
00:05:26,540 --> 00:05:31,280
how exactly this unexpected code

139
00:05:28,610 --> 00:05:32,930
behavior is possible we investigated<font color="#CCCCCC"> the</font>

140
00:05:31,280 --> 00:05:35,419
code loading<font color="#E5E5E5"> and code execution</font>

141
00:05:32,930 --> 00:05:38,120
processes<font color="#E5E5E5"> within the Android runtime</font><font color="#CCCCCC"> or</font>

142
00:05:35,420 --> 00:05:40,550
art<font color="#E5E5E5"> and identified several ways where</font>

143
00:05:38,120 --> 00:05:43,910
the application can modify this runtime

144
00:05:40,550 --> 00:05:46,250
<font color="#CCCCCC">state so looking first into the code</font>

145
00:05:43,910 --> 00:05:48,560
loading<font color="#CCCCCC"> process</font><font color="#E5E5E5"> when the application</font>

146
00:05:46,250 --> 00:05:51,050
wants<font color="#CCCCCC"> to load a file byte code into the</font>

147
00:05:48,560 --> 00:05:53,360
<font color="#E5E5E5">runtime art will first map this file</font>

148
00:05:51,050 --> 00:05:55,610
<font color="#E5E5E5">into memory and it also creates objects</font>

149
00:05:53,360 --> 00:05:57,440
<font color="#E5E5E5">that keeps track</font><font color="#CCCCCC"> of the metadata for</font>

150
00:05:55,610 --> 00:05:59,690
this<font color="#E5E5E5"> ball there is a Java text file</font>

151
00:05:57,440 --> 00:06:01,700
object that allows Java code to

152
00:05:59,690 --> 00:06:03,290
<font color="#E5E5E5">reference this ball later and it</font>

153
00:06:01,700 --> 00:06:05,960
contains a pointer to<font color="#CCCCCC"> a</font><font color="#E5E5E5"> native Dex file</font>

154
00:06:03,290 --> 00:06:08,180
object that will track where<font color="#E5E5E5"> this file</font>

155
00:06:05,960 --> 00:06:10,700
and<font color="#E5E5E5"> where this</font><font color="#CCCCCC"> bytecode</font><font color="#E5E5E5"> was loaded into</font>

156
00:06:08,180 --> 00:06:12,980
memory<font color="#E5E5E5"> and we found that one type of</font>

157
00:06:10,700 --> 00:06:15,830
runtime<font color="#E5E5E5"> based office keishon can happen</font>

158
00:06:12,980 --> 00:06:18,050
here if the pointers in these objects

159
00:06:15,830 --> 00:06:19,849
are modified so that<font color="#E5E5E5"> they either point</font>

160
00:06:18,050 --> 00:06:22,040
to<font color="#E5E5E5"> different Dex file objects or a</font>

161
00:06:19,850 --> 00:06:24,050
different location<font color="#CCCCCC"> in memory</font><font color="#E5E5E5"> where the</font>

162
00:06:22,040 --> 00:06:27,350
application has secretly loaded other

163
00:06:24,050 --> 00:06:29,900
<font color="#E5E5E5">byte code we call this Dex Val hulking</font>

164
00:06:27,350 --> 00:06:31,370
because it essentially the<font color="#E5E5E5"> original Dex</font>

165
00:06:29,900 --> 00:06:32,900
<font color="#E5E5E5">ball that was that should have been</font>

166
00:06:31,370 --> 00:06:34,630
loaded into the runtime has been swapped

167
00:06:32,900 --> 00:06:37,520
out<font color="#CCCCCC"> for</font><font color="#E5E5E5"> another one</font>

168
00:06:34,630 --> 00:06:39,469
also if the application<font color="#E5E5E5"> knows where this</font>

169
00:06:37,520 --> 00:06:41,270
file was loaded into memory

170
00:06:39,470 --> 00:06:41,980
it could<font color="#CCCCCC"> also overwrite the contents at</font>

171
00:06:41,270 --> 00:06:43,510
that location

172
00:06:41,980 --> 00:06:45,940
so that the<font color="#E5E5E5"> farm might now contain</font>

173
00:06:43,510 --> 00:06:49,060
malicious<font color="#CCCCCC"> code</font><font color="#E5E5E5"> and we call this bytecode</font>

174
00:06:45,940 --> 00:06:51,280
<font color="#CCCCCC">overwriting in the application can</font><font color="#E5E5E5"> time</font>

175
00:06:49,060 --> 00:06:52,750
<font color="#E5E5E5">this hooking or</font><font color="#CCCCCC"> overriding</font><font color="#E5E5E5"> so that it</font>

176
00:06:51,280 --> 00:06:53,530
happens<font color="#CCCCCC"> after the file</font><font color="#E5E5E5"> has been</font><font color="#CCCCCC"> loaded</font>

177
00:06:52,750 --> 00:06:55,990
into<font color="#E5E5E5"> memory</font>

178
00:06:53,530 --> 00:06:58,150
but before art parses it<font color="#E5E5E5"> to create</font>

179
00:06:55,990 --> 00:06:59,620
classes and<font color="#E5E5E5"> method objects this can</font>

180
00:06:58,150 --> 00:07:02,200
essentially<font color="#E5E5E5"> lead to the execution of</font>

181
00:06:59,620 --> 00:07:05,830
unexpected class and methods<font color="#E5E5E5"> from this</font>

182
00:07:02,200 --> 00:07:07,960
file next<font color="#CCCCCC"> we looked into</font><font color="#E5E5E5"> the code</font>

183
00:07:05,830 --> 00:07:09,669
execution<font color="#CCCCCC"> process where these classes</font>

184
00:07:07,960 --> 00:07:12,370
and<font color="#CCCCCC"> methods are used after</font><font color="#E5E5E5"> they've been</font>

185
00:07:09,670 --> 00:07:14,550
loaded<font color="#E5E5E5"> and execution happens when the</font>

186
00:07:12,370 --> 00:07:17,710
application makes a method invocation

187
00:07:14,550 --> 00:07:19,570
<font color="#CCCCCC">assuming a virtual invocation before art</font>

188
00:07:17,710 --> 00:07:21,669
can actually execute<font color="#E5E5E5"> anything it has to</font>

189
00:07:19,570 --> 00:07:23,740
<font color="#E5E5E5">first resolve which method or over in</font>

190
00:07:21,670 --> 00:07:25,990
the method<font color="#CCCCCC"> it should be using and it</font>

191
00:07:23,740 --> 00:07:28,300
does this by<font color="#CCCCCC"> looking up the type or the</font>

192
00:07:25,990 --> 00:07:30,760
class of the receiver object for the

193
00:07:28,300 --> 00:07:33,040
<font color="#E5E5E5">invoke statement and indexing</font><font color="#CCCCCC"> into its</font>

194
00:07:30,760 --> 00:07:35,170
virtual method table<font color="#CCCCCC"> to retrieve this</font>

195
00:07:33,040 --> 00:07:37,240
art method object<font color="#CCCCCC"> that ill done</font><font color="#E5E5E5"> executed</font>

196
00:07:35,170 --> 00:07:39,310
and we found that another type of

197
00:07:37,240 --> 00:07:41,770
runtime<font color="#E5E5E5"> based office keishon can happen</font>

198
00:07:39,310 --> 00:07:45,100
if<font color="#E5E5E5"> the pointers in this</font><font color="#CCCCCC"> virtual method</font>

199
00:07:41,770 --> 00:07:47,229
table<font color="#E5E5E5"> are modified so that unexpected</font>

200
00:07:45,100 --> 00:07:49,630
<font color="#CCCCCC">art method object is returned and</font>

201
00:07:47,230 --> 00:07:53,080
executed and we call this art method

202
00:07:49,630 --> 00:07:55,240
hooking finally after<font color="#CCCCCC"> the method</font>

203
00:07:53,080 --> 00:07:58,510
resolution process has returned some

204
00:07:55,240 --> 00:08:00,640
method execution happens in art by

205
00:07:58,510 --> 00:08:02,440
looking up an entry point<font color="#E5E5E5"> which keeps</font>

206
00:08:00,640 --> 00:08:04,510
<font color="#CCCCCC">track of</font><font color="#E5E5E5"> how this method</font><font color="#CCCCCC"> should be</font>

207
00:08:02,440 --> 00:08:06,700
executed<font color="#E5E5E5"> for the current</font><font color="#CCCCCC"> configuration</font>

208
00:08:04,510 --> 00:08:09,099
of the<font color="#E5E5E5"> runtime and essentially this</font>

209
00:08:06,700 --> 00:08:10,750
entry<font color="#CCCCCC"> point code will grab a coke</font>

210
00:08:09,100 --> 00:08:12,160
<font color="#CCCCCC">pointer</font><font color="#E5E5E5"> that it should be using</font><font color="#CCCCCC"> and then</font>

211
00:08:10,750 --> 00:08:15,070
execute<font color="#E5E5E5"> the instructions that are found</font>

212
00:08:12,160 --> 00:08:17,470
<font color="#E5E5E5">there and we found that obfuscation can</font>

213
00:08:15,070 --> 00:08:19,270
also<font color="#E5E5E5"> happen here if the entry points are</font>

214
00:08:17,470 --> 00:08:21,540
hooked<font color="#E5E5E5"> so that arbitrary code gets</font>

215
00:08:19,270 --> 00:08:23,950
executed when<font color="#CCCCCC"> the</font><font color="#E5E5E5"> method is invoked and</font>

216
00:08:21,540 --> 00:08:26,350
obfuscation can also<font color="#E5E5E5"> happen if these</font>

217
00:08:23,950 --> 00:08:28,810
code pointers are hooked or the contents

218
00:08:26,350 --> 00:08:30,460
<font color="#CCCCCC">that they point to modified so that</font>

219
00:08:28,810 --> 00:08:33,490
unexpected<font color="#E5E5E5"> instructions get executed</font>

220
00:08:30,460 --> 00:08:36,970
<font color="#E5E5E5">even</font><font color="#CCCCCC"> though</font><font color="#E5E5E5"> a seemingly benign method</font>

221
00:08:33,490 --> 00:08:39,460
might be being<font color="#E5E5E5"> invoked and overall we've</font>

222
00:08:36,970 --> 00:08:41,640
identified six specific<font color="#E5E5E5"> ways where</font>

223
00:08:39,460 --> 00:08:43,930
runtime<font color="#CCCCCC"> State can be modified by the</font>

224
00:08:41,640 --> 00:08:46,180
<font color="#E5E5E5">application in this way to achieve</font>

225
00:08:43,929 --> 00:08:47,739
unexpected<font color="#E5E5E5"> and likely malicious code</font>

226
00:08:46,180 --> 00:08:50,349
behavior even<font color="#CCCCCC"> though it looks like</font>

227
00:08:47,740 --> 00:08:52,840
<font color="#E5E5E5">benign code was initialized</font><font color="#CCCCCC"> or loaded</font>

228
00:08:50,350 --> 00:08:54,490
into the runtime<font color="#E5E5E5"> and this isn't an</font>

229
00:08:52,840 --> 00:08:56,080
exhaustive<font color="#E5E5E5"> list of</font>

230
00:08:54,490 --> 00:08:58,899
all the different types<font color="#E5E5E5"> of runtime</font><font color="#CCCCCC"> based</font>

231
00:08:56,080 --> 00:09:00,910
<font color="#CCCCCC">office Gatien that's possible the one</font>

232
00:08:58,899 --> 00:09:02,800
we've identified here<font color="#E5E5E5"> do touch</font><font color="#CCCCCC"> different</font>

233
00:09:00,910 --> 00:09:05,380
parts of the code<font color="#E5E5E5"> loading and code</font>

234
00:09:02,800 --> 00:09:07,029
execution processes<font color="#CCCCCC"> within art and we</font>

235
00:09:05,380 --> 00:09:10,420
have found<font color="#CCCCCC"> examples of them in</font><font color="#E5E5E5"> recent</font>

236
00:09:07,029 --> 00:09:12,189
Android<font color="#E5E5E5"> malware</font><font color="#CCCCCC"> so of course the</font><font color="#E5E5E5"> next</font>

237
00:09:10,420 --> 00:09:14,589
step<font color="#E5E5E5"> is to try</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> detect and D office</font>

238
00:09:12,190 --> 00:09:16,750
<font color="#CCCCCC">gate these techniques</font><font color="#E5E5E5"> and our ultimate</font>

239
00:09:14,589 --> 00:09:18,580
<font color="#CCCCCC">goal</font><font color="#E5E5E5"> is</font><font color="#CCCCCC"> to have a unified framework that</font>

240
00:09:16,750 --> 00:09:20,230
can handle<font color="#E5E5E5"> older language based</font>

241
00:09:18,580 --> 00:09:22,180
techniques as well as<font color="#E5E5E5"> these newer and</font>

242
00:09:20,230 --> 00:09:25,120
<font color="#E5E5E5">more complex runtime based office</font>

243
00:09:22,180 --> 00:09:26,829
keishon in our design<font color="#E5E5E5"> we found that pure</font>

244
00:09:25,120 --> 00:09:29,020
static analysis was generally

245
00:09:26,830 --> 00:09:31,060
insufficient for<font color="#CCCCCC"> deification since we</font>

246
00:09:29,020 --> 00:09:32,829
really do need runtime<font color="#E5E5E5"> information about</font>

247
00:09:31,060 --> 00:09:35,560
what the application has loaded<font color="#E5E5E5"> and</font>

248
00:09:32,830 --> 00:09:37,120
executed<font color="#E5E5E5"> but pure dynamic analysis often</font>

249
00:09:35,560 --> 00:09:39,219
<font color="#E5E5E5">suffers from a</font><font color="#CCCCCC"> lack of code</font><font color="#E5E5E5"> coverage</font>

250
00:09:37,120 --> 00:09:41,290
<font color="#E5E5E5">since you can't analyze a piece of code</font>

251
00:09:39,220 --> 00:09:42,850
<font color="#CCCCCC">without first executing it</font><font color="#E5E5E5"> and this</font>

252
00:09:41,290 --> 00:09:45,099
would mean trying<font color="#E5E5E5"> to execute all of the</font>

253
00:09:42,850 --> 00:09:47,050
paths<font color="#E5E5E5"> or possibly office gated paths in</font>

254
00:09:45,100 --> 00:09:50,709
an<font color="#CCCCCC"> application</font><font color="#E5E5E5"> which might not always be</font>

255
00:09:47,050 --> 00:09:52,510
<font color="#E5E5E5">feasible we turn to the idea</font><font color="#CCCCCC"> of targeted</font>

256
00:09:50,709 --> 00:09:55,449
execution which is something<font color="#E5E5E5"> we've used</font>

257
00:09:52,510 --> 00:09:57,640
in<font color="#E5E5E5"> the past and the idea behind targeted</font>

258
00:09:55,450 --> 00:09:59,800
execution is that when we're performing

259
00:09:57,640 --> 00:10:01,930
security analysis a lot<font color="#E5E5E5"> of the times</font>

260
00:09:59,800 --> 00:10:04,420
were interested in whether an

261
00:10:01,930 --> 00:10:06,670
application performs some interesting

262
00:10:04,420 --> 00:10:09,279
behavior<font color="#E5E5E5"> and more often than</font><font color="#CCCCCC"> not this</font>

263
00:10:06,670 --> 00:10:11,319
interesting behavior only<font color="#E5E5E5"> happens in a</font>

264
00:10:09,279 --> 00:10:13,990
small<font color="#E5E5E5"> part of the applications code</font>

265
00:10:11,320 --> 00:10:16,450
<font color="#E5E5E5">therefore</font><font color="#CCCCCC"> trying to execute</font><font color="#E5E5E5"> all</font><font color="#CCCCCC"> of the</font>

266
00:10:13,990 --> 00:10:18,579
paths<font color="#E5E5E5"> in an application dynamically can</font>

267
00:10:16,450 --> 00:10:20,110
be a bit<font color="#E5E5E5"> of a wasted effort</font><font color="#CCCCCC"> with respect</font>

268
00:10:18,579 --> 00:10:22,810
<font color="#E5E5E5">to that security analysis we're trying</font>

269
00:10:20,110 --> 00:10:24,640
to<font color="#E5E5E5"> perform so in targeted execution we</font>

270
00:10:22,810 --> 00:10:26,859
take a hybrid approach<font color="#CCCCCC"> where we use</font>

271
00:10:24,640 --> 00:10:28,899
<font color="#E5E5E5">static analysis to</font><font color="#CCCCCC"> identify potential</font>

272
00:10:26,860 --> 00:10:31,630
interesting behaviors and extract the

273
00:10:28,899 --> 00:10:33,820
<font color="#E5E5E5">paths to them from those paths we</font>

274
00:10:31,630 --> 00:10:36,490
extract constraints that<font color="#E5E5E5"> we then solve</font>

275
00:10:33,820 --> 00:10:38,560
to generate inputs<font color="#E5E5E5"> to inject and on the</font>

276
00:10:36,490 --> 00:10:40,120
dynamic side were more efficient since

277
00:10:38,560 --> 00:10:42,399
we're<font color="#E5E5E5"> only injecting inputs and</font>

278
00:10:40,120 --> 00:10:44,350
<font color="#CCCCCC">triggering core</font><font color="#E5E5E5"> paths that can lead</font><font color="#CCCCCC"> to</font>

279
00:10:42,399 --> 00:10:47,529
potential interesting behavior that we

280
00:10:44,350 --> 00:10:49,540
<font color="#E5E5E5">want to analyze of course for obfuscated</font>

281
00:10:47,529 --> 00:10:51,579
applications<font color="#CCCCCC"> there's a problem</font><font color="#E5E5E5"> in that</font>

282
00:10:49,540 --> 00:10:53,589
the static analysis might be incomplete

283
00:10:51,579 --> 00:10:57,189
<font color="#E5E5E5">and</font><font color="#CCCCCC"> some of these execution flows might</font>

284
00:10:53,589 --> 00:10:59,529
be missing<font color="#E5E5E5"> from our model so we adjust</font>

285
00:10:57,190 --> 00:11:01,180
<font color="#E5E5E5">this by</font><font color="#CCCCCC"> passing dynamic information</font><font color="#E5E5E5"> back</font>

286
00:10:59,529 --> 00:11:04,360
in the static analysis to try<font color="#E5E5E5"> and</font>

287
00:11:01,180 --> 00:11:06,189
resolve<font color="#E5E5E5"> these flows in this scenario the</font>

288
00:11:04,360 --> 00:11:07,450
interesting behavior that we would<font color="#E5E5E5"> want</font>

289
00:11:06,190 --> 00:11:10,090
to<font color="#CCCCCC"> target and</font>

290
00:11:07,450 --> 00:11:11,860
dynamically<font color="#E5E5E5"> or then the locations where</font>

291
00:11:10,090 --> 00:11:15,310
office<font color="#CCCCCC"> Kishin might be occurring</font><font color="#E5E5E5"> in the</font>

292
00:11:11,860 --> 00:11:18,010
application so we took this idea<font color="#CCCCCC"> and</font>

293
00:11:15,310 --> 00:11:20,199
designed and implemented<font color="#E5E5E5"> tiro a hybrid</font>

294
00:11:18,010 --> 00:11:22,780
iterative the<font color="#E5E5E5"> office cater for Android</font>

295
00:11:20,200 --> 00:11:25,510
applications<font color="#E5E5E5"> tiro stands for the four</font>

296
00:11:22,780 --> 00:11:27,189
steps<font color="#E5E5E5"> target instrument run and observe</font>

297
00:11:25,510 --> 00:11:29,650
<font color="#E5E5E5">and it's based on the</font><font color="#CCCCCC"> idea of having</font>

298
00:11:27,190 --> 00:11:31,600
<font color="#E5E5E5">static analysis identify office keishon</font>

299
00:11:29,650 --> 00:11:33,340
locations and triggering them and<font color="#E5E5E5"> then</font>

300
00:11:31,600 --> 00:11:35,260
<font color="#E5E5E5">using dynamic analysis to gather</font>

301
00:11:33,340 --> 00:11:38,230
<font color="#E5E5E5">information that can</font><font color="#CCCCCC"> help us D off</font>

302
00:11:35,260 --> 00:11:40,900
escape those locations the input should

303
00:11:38,230 --> 00:11:43,600
be<font color="#E5E5E5"> a compiled apk file and after several</font>

304
00:11:40,900 --> 00:11:45,520
<font color="#E5E5E5">iterations tiro</font><font color="#CCCCCC"> should reduce</font><font color="#E5E5E5"> ad office</font>

305
00:11:43,600 --> 00:11:47,260
gated applications that we<font color="#CCCCCC"> can then</font><font color="#E5E5E5"> pass</font>

306
00:11:45,520 --> 00:11:49,390
to<font color="#E5E5E5"> other tools to improve the</font>

307
00:11:47,260 --> 00:11:52,390
effectiveness or completeness of their

308
00:11:49,390 --> 00:11:55,750
analysis<font color="#E5E5E5"> and to show the four steps of</font>

309
00:11:52,390 --> 00:11:57,250
tiro this is a<font color="#E5E5E5"> reflection example where</font>

310
00:11:55,750 --> 00:11:59,470
the name of the method<font color="#E5E5E5"> being invoked</font>

311
00:11:57,250 --> 00:12:02,320
reflectively is obfuscated<font color="#E5E5E5"> by</font><font color="#CCCCCC"> this</font>

312
00:11:59,470 --> 00:12:04,000
decryption routine and in the first

313
00:12:02,320 --> 00:12:06,610
targeting<font color="#CCCCCC"> step</font><font color="#E5E5E5"> zero will first identify</font>

314
00:12:04,000 --> 00:12:09,010
office<font color="#CCCCCC"> keishon locations</font><font color="#E5E5E5"> which in this</font>

315
00:12:06,610 --> 00:12:11,410
case is the reflection<font color="#E5E5E5"> API invocation</font>

316
00:12:09,010 --> 00:12:13,569
and I'll extract<font color="#E5E5E5"> the call path and</font>

317
00:12:11,410 --> 00:12:15,910
constraints from<font color="#E5E5E5"> on create</font><font color="#CCCCCC"> to method</font><font color="#E5E5E5"> and</font>

318
00:12:13,570 --> 00:12:17,980
bug<font color="#E5E5E5"> in the instrument step</font>

319
00:12:15,910 --> 00:12:20,079
instrument<font color="#E5E5E5"> this location to report</font>

320
00:12:17,980 --> 00:12:22,030
values that it needs<font color="#E5E5E5"> for the obfuscation</font>

321
00:12:20,080 --> 00:12:26,230
which in this case is the name<font color="#CCCCCC"> of the</font>

322
00:12:22,030 --> 00:12:28,000
method<font color="#E5E5E5"> in the dynamic run step ill take</font>

323
00:12:26,230 --> 00:12:30,220
the previous targeting<font color="#CCCCCC"> information and</font>

324
00:12:28,000 --> 00:12:32,110
generate inputs<font color="#E5E5E5"> that will trigger this</font>

325
00:12:30,220 --> 00:12:34,900
path from on<font color="#E5E5E5"> create two methods on</font>

326
00:12:32,110 --> 00:12:36,910
<font color="#E5E5E5">invoke and as it executes this path the</font>

327
00:12:34,900 --> 00:12:38,980
<font color="#E5E5E5">instrumentation will log that the</font>

328
00:12:36,910 --> 00:12:41,890
<font color="#E5E5E5">reflection in this method at this</font>

329
00:12:38,980 --> 00:12:45,190
location can result in this<font color="#E5E5E5"> method being</font>

330
00:12:41,890 --> 00:12:47,319
invoked<font color="#E5E5E5"> and in the observe</font><font color="#CCCCCC"> phase zero</font>

331
00:12:45,190 --> 00:12:48,970
<font color="#E5E5E5">will take this information and model the</font>

332
00:12:47,320 --> 00:12:52,390
<font color="#CCCCCC">flow from our creates a foo</font>

333
00:12:48,970 --> 00:12:54,550
so reflection is a rather<font color="#E5E5E5"> simple form of</font>

334
00:12:52,390 --> 00:12:56,260
language<font color="#E5E5E5"> based office</font><font color="#CCCCCC"> keishon but</font><font color="#E5E5E5"> tiro</font>

335
00:12:54,550 --> 00:12:58,180
can use the same four steps<font color="#E5E5E5"> to handle</font>

336
00:12:56,260 --> 00:12:59,410
the more complex runtime based office

337
00:12:58,180 --> 00:13:02,560
<font color="#E5E5E5">station that</font><font color="#CCCCCC"> I've described previously</font>

338
00:12:59,410 --> 00:13:04,689
<font color="#CCCCCC">and it does this</font><font color="#E5E5E5"> by</font><font color="#CCCCCC"> taking advantage of</font>

339
00:13:02,560 --> 00:13:06,760
the<font color="#CCCCCC"> knowledge that to modify runtime</font>

340
00:13:04,690 --> 00:13:09,280
<font color="#E5E5E5">state the</font><font color="#CCCCCC"> application</font><font color="#E5E5E5"> has to use native</font>

341
00:13:06,760 --> 00:13:11,319
code<font color="#E5E5E5"> to do this</font><font color="#CCCCCC"> modification so before</font>

342
00:13:09,280 --> 00:13:13,140
obfuscation happens there has to be some

343
00:13:11,320 --> 00:13:15,640
<font color="#CCCCCC">java to native code</font><font color="#E5E5E5"> transition</font>

344
00:13:13,140 --> 00:13:17,620
however the obfuscation isn't actually

345
00:13:15,640 --> 00:13:18,170
complete until this obfuscated code is

346
00:13:17,620 --> 00:13:20,330
execute

347
00:13:18,170 --> 00:13:22,880
and this office<font color="#E5E5E5"> gated</font><font color="#CCCCCC"> code implemented</font>

348
00:13:20,330 --> 00:13:25,100
in Java<font color="#E5E5E5"> so there also has to be a native</font>

349
00:13:22,880 --> 00:13:28,580
to Java code transition<font color="#E5E5E5"> after</font><font color="#CCCCCC"> this</font>

350
00:13:25,100 --> 00:13:30,350
tampering is done so for tiro<font color="#CCCCCC"> we take</font>

351
00:13:28,580 --> 00:13:32,660
advantage<font color="#CCCCCC"> of this by checking for</font>

352
00:13:30,350 --> 00:13:34,490
changes in runtime<font color="#CCCCCC"> state before</font><font color="#E5E5E5"> and</font>

353
00:13:32,660 --> 00:13:38,959
after application native code is

354
00:13:34,490 --> 00:13:41,450
executed<font color="#CCCCCC"> so to show how</font><font color="#E5E5E5"> this</font><font color="#CCCCCC"> works this</font>

355
00:13:38,960 --> 00:13:43,430
<font color="#E5E5E5">is a different</font><font color="#CCCCCC"> example where a native</font>

356
00:13:41,450 --> 00:13:45,830
<font color="#E5E5E5">method called native foo is being</font>

357
00:13:43,430 --> 00:13:48,620
invoked followed by a normal Java method

358
00:13:45,830 --> 00:13:50,780
called bar and<font color="#E5E5E5"> so when</font><font color="#CCCCCC"> T Rose ceases</font>

359
00:13:48,620 --> 00:13:52,640
code<font color="#CCCCCC"> if they'll first target</font><font color="#E5E5E5"> this</font>

360
00:13:50,780 --> 00:13:54,560
invocation<font color="#E5E5E5"> to native</font><font color="#CCCCCC"> foo</font>

361
00:13:52,640 --> 00:13:57,670
since<font color="#E5E5E5"> ill-treat all application native</font>

362
00:13:54,560 --> 00:14:00,739
code<font color="#E5E5E5"> as a possible source of</font><font color="#CCCCCC"> obfuscation</font>

363
00:13:57,670 --> 00:14:02,959
<font color="#E5E5E5">in the instruments tab</font><font color="#CCCCCC"> cyril uses an</font>

364
00:14:00,740 --> 00:14:05,330
instrumented art runtime that<font color="#E5E5E5"> checks for</font>

365
00:14:02,960 --> 00:14:06,860
changes in runtime<font color="#CCCCCC"> State on these Java</font>

366
00:14:05,330 --> 00:14:09,050
to native and native to Java code

367
00:14:06,860 --> 00:14:10,940
transitions<font color="#E5E5E5"> and in this case were</font>

368
00:14:09,050 --> 00:14:13,550
interested<font color="#CCCCCC"> in the runtime state for the</font>

369
00:14:10,940 --> 00:14:15,500
bar method and when native who<font color="#CCCCCC"> executes</font>

370
00:14:13,550 --> 00:14:17,959
it changes the state<font color="#E5E5E5"> so</font><font color="#CCCCCC"> that the code</font>

371
00:14:15,500 --> 00:14:19,370
pointer for bar now points<font color="#E5E5E5"> to a</font>

372
00:14:17,960 --> 00:14:23,270
different<font color="#CCCCCC"> sequence of instructions that</font>

373
00:14:19,370 --> 00:14:25,250
<font color="#E5E5E5">will get executed in 1-0 runs this code</font>

374
00:14:23,270 --> 00:14:27,800
and triggers that path to native foo

375
00:14:25,250 --> 00:14:30,080
<font color="#E5E5E5">this instrumentation will log that in</font>

376
00:14:27,800 --> 00:14:31,219
the oncreate method<font color="#E5E5E5"> at the</font><font color="#CCCCCC"> location at</font>

377
00:14:30,080 --> 00:14:33,470
the location where native who is

378
00:14:31,220 --> 00:14:35,120
<font color="#E5E5E5">returning back into java code the code</font>

379
00:14:33,470 --> 00:14:37,100
corner<font color="#E5E5E5"> for bar has</font><font color="#CCCCCC"> been modified</font><font color="#E5E5E5"> and</font>

380
00:14:35,120 --> 00:14:40,430
I'll extract this new<font color="#E5E5E5"> byte code for the</font>

381
00:14:37,100 --> 00:14:42,170
bar method and finally we model this new

382
00:14:40,430 --> 00:14:44,689
<font color="#CCCCCC">bytecode with a synthetic method and</font>

383
00:14:42,170 --> 00:14:47,270
then model the<font color="#E5E5E5"> flow from on creek to</font>

384
00:14:44,690 --> 00:14:49,880
<font color="#E5E5E5">this new method and since</font><font color="#CCCCCC"> tiro</font><font color="#E5E5E5"> is</font>

385
00:14:47,270 --> 00:14:51,829
iterative<font color="#E5E5E5"> this runtime</font><font color="#CCCCCC"> information can</font>

386
00:14:49,880 --> 00:14:54,260
be passed back into static analysis<font color="#E5E5E5"> so</font>

387
00:14:51,830 --> 00:14:56,270
in<font color="#CCCCCC"> a subsequent targeting step zero will</font>

388
00:14:54,260 --> 00:14:58,069
see that this<font color="#CCCCCC"> invocation the</font><font color="#E5E5E5"> bar can</font>

389
00:14:56,270 --> 00:15:00,860
lead to this new<font color="#CCCCCC"> bytecode being executed</font>

390
00:14:58,070 --> 00:15:02,750
<font color="#E5E5E5">so it also look for locations of</font>

391
00:15:00,860 --> 00:15:04,730
obfuscation<font color="#CCCCCC"> in this new bytecode</font><font color="#E5E5E5"> and</font>

392
00:15:02,750 --> 00:15:09,440
then the office gate them using the<font color="#E5E5E5"> same</font>

393
00:15:04,730 --> 00:15:11,480
four steps<font color="#E5E5E5"> for the implementation</font><font color="#CCCCCC"> we use</font>

394
00:15:09,440 --> 00:15:13,010
the sub framework for the static

395
00:15:11,480 --> 00:15:15,530
<font color="#CCCCCC">component to do the analysis and</font>

396
00:15:13,010 --> 00:15:18,140
instrumentation of<font color="#E5E5E5"> application code on</font>

397
00:15:15,530 --> 00:15:20,600
the dynamic side<font color="#CCCCCC"> we use a modified</font>

398
00:15:18,140 --> 00:15:22,730
version<font color="#E5E5E5"> of a OSP that contains our</font>

399
00:15:20,600 --> 00:15:25,280
instrumented<font color="#E5E5E5"> art runtime that does this</font>

400
00:15:22,730 --> 00:15:27,560
runtime state monitoring<font color="#E5E5E5"> we also have a</font>

401
00:15:25,280 --> 00:15:29,420
separate process<font color="#E5E5E5"> that parses our the</font>

402
00:15:27,560 --> 00:15:30,359
office<font color="#CCCCCC"> Gatien log and extracts any</font>

403
00:15:29,420 --> 00:15:32,610
<font color="#CCCCCC">dynamically low</font>

404
00:15:30,360 --> 00:15:37,260
or modified<font color="#CCCCCC"> by code from</font><font color="#E5E5E5"> our testing</font>

405
00:15:32,610 --> 00:15:39,480
device for<font color="#E5E5E5"> evaluation we first want to</font>

406
00:15:37,260 --> 00:15:41,339
look<font color="#E5E5E5"> at Iran's abilities to detect and D</font>

407
00:15:39,480 --> 00:15:43,589
<font color="#E5E5E5">office</font><font color="#CCCCCC"> gate</font><font color="#E5E5E5"> techniques used in modern</font>

408
00:15:41,339 --> 00:15:44,820
<font color="#E5E5E5">Android malware and we also want to look</font>

409
00:15:43,589 --> 00:15:46,800
at how different<font color="#E5E5E5"> office</font><font color="#CCCCCC"> Gatien</font>

410
00:15:44,820 --> 00:15:49,740
techniques were being used<font color="#E5E5E5"> by malware in</font>

411
00:15:46,800 --> 00:15:51,899
the wild and finally we<font color="#CCCCCC"> provide an</font>

412
00:15:49,740 --> 00:15:55,950
evaluation<font color="#CCCCCC"> of tiros performance in our</font>

413
00:15:51,899 --> 00:15:58,200
paper so looking first<font color="#CCCCCC"> in-depth heroes</font>

414
00:15:55,950 --> 00:16:00,870
are the office<font color="#CCCCCC"> Gatien capabilities we</font>

415
00:15:58,200 --> 00:16:03,089
evaluate<font color="#E5E5E5"> at</font><font color="#CCCCCC"> ero</font><font color="#E5E5E5"> on a data set</font><font color="#CCCCCC"> of office</font>

416
00:16:00,870 --> 00:16:05,370
<font color="#CCCCCC">kated malware samples that</font><font color="#E5E5E5"> was provided</font>

417
00:16:03,089 --> 00:16:08,130
to<font color="#E5E5E5"> us from the Android</font><font color="#CCCCCC"> security team at</font>

418
00:16:05,370 --> 00:16:10,350
Google and this data set was manually

419
00:16:08,130 --> 00:16:12,230
<font color="#E5E5E5">labeled by the office Gator or Packer</font>

420
00:16:10,350 --> 00:16:14,760
<font color="#E5E5E5">that was likely used</font><font color="#CCCCCC"> on the original</font>

421
00:16:12,230 --> 00:16:17,820
<font color="#CCCCCC">application and these are</font><font color="#E5E5E5"> listed on the</font>

422
00:16:14,760 --> 00:16:19,529
left<font color="#E5E5E5"> this is</font><font color="#CCCCCC"> a subset of the interesting</font>

423
00:16:17,820 --> 00:16:21,899
results we had and our paper<font color="#E5E5E5"> has the</font>

424
00:16:19,529 --> 00:16:24,600
<font color="#E5E5E5">full results of the 22 office caters we</font>

425
00:16:21,899 --> 00:16:26,640
evaluated on we found<font color="#CCCCCC"> that all</font><font color="#E5E5E5"> the</font>

426
00:16:24,600 --> 00:16:29,459
<font color="#E5E5E5">samples did some form of</font><font color="#CCCCCC"> language based</font>

427
00:16:26,640 --> 00:16:31,680
office keishon for runtime<font color="#CCCCCC"> based office</font>

428
00:16:29,459 --> 00:16:34,109
keishon<font color="#E5E5E5"> we looked for changes or</font>

429
00:16:31,680 --> 00:16:37,050
<font color="#E5E5E5">tampering a runtime</font><font color="#CCCCCC"> state in Dex</font>

430
00:16:34,110 --> 00:16:39,750
<font color="#CCCCCC">bytecode Dex file objects and class and</font>

431
00:16:37,050 --> 00:16:41,790
<font color="#CCCCCC">method objects and we found that 53%</font><font color="#E5E5E5"> of</font>

432
00:16:39,750 --> 00:16:44,250
the samples<font color="#E5E5E5"> did some form of runtime</font>

433
00:16:41,790 --> 00:16:46,380
based<font color="#E5E5E5"> office keishon a lot of the</font>

434
00:16:44,250 --> 00:16:48,810
tampering of runtime<font color="#CCCCCC"> State was done on a</font>

435
00:16:46,380 --> 00:16:51,180
larger scale where entire<font color="#E5E5E5"> Dex files were</font>

436
00:16:48,810 --> 00:16:52,800
being hooked or swapped in although we

437
00:16:51,180 --> 00:16:54,810
did find<font color="#E5E5E5"> cases of more fine-grained</font>

438
00:16:52,800 --> 00:16:57,479
obfuscation where method or instruction

439
00:16:54,810 --> 00:16:59,819
pointers were being modified<font color="#E5E5E5"> to the</font>

440
00:16:57,480 --> 00:17:02,490
<font color="#E5E5E5">obfuscated these applications</font><font color="#CCCCCC"> Cyril took</font>

441
00:16:59,820 --> 00:17:04,319
on average<font color="#CCCCCC"> 2.3</font><font color="#E5E5E5"> iterations with all of</font>

442
00:17:02,490 --> 00:17:06,270
the samples requiring more<font color="#CCCCCC"> than one</font>

443
00:17:04,319 --> 00:17:08,418
iteration because of the<font color="#E5E5E5"> combination of</font>

444
00:17:06,270 --> 00:17:11,309
office<font color="#E5E5E5"> keishon techniques they used and</font>

445
00:17:08,419 --> 00:17:14,040
<font color="#E5E5E5">finally we want to look at how</font><font color="#CCCCCC"> TIROS</font>

446
00:17:11,309 --> 00:17:16,199
results could potentially be used<font color="#CCCCCC"> and we</font>

447
00:17:14,040 --> 00:17:18,540
looked at the sensitive<font color="#CCCCCC"> API on vacations</font>

448
00:17:16,199 --> 00:17:20,549
that<font color="#E5E5E5"> could be detected statically before</font>

449
00:17:18,540 --> 00:17:22,559
and after running tiro<font color="#CCCCCC"> where the</font>

450
00:17:20,549 --> 00:17:24,510
sensitive api's are the<font color="#CCCCCC"> list</font><font color="#E5E5E5"> of</font>

451
00:17:22,559 --> 00:17:27,240
sensitive sources and<font color="#CCCCCC"> syncs from the</font>

452
00:17:24,510 --> 00:17:30,270
flojoy tool and we<font color="#E5E5E5"> found that on</font><font color="#CCCCCC"> average</font>

453
00:17:27,240 --> 00:17:32,400
<font color="#E5E5E5">we were able to detect over 30 new uses</font>

454
00:17:30,270 --> 00:17:34,918
of sensitive api's per application

455
00:17:32,400 --> 00:17:37,740
<font color="#E5E5E5">showing that by using these deification</font>

456
00:17:34,919 --> 00:17:39,450
results<font color="#E5E5E5"> we can get a better view of the</font>

457
00:17:37,740 --> 00:17:40,090
actions<font color="#E5E5E5"> and potential malicious behavior</font>

458
00:17:39,450 --> 00:17:44,020
and

459
00:17:40,090 --> 00:17:46,059
<font color="#CCCCCC">application next</font><font color="#E5E5E5"> we want to look at how</font>

460
00:17:44,020 --> 00:17:48,429
different office<font color="#CCCCCC"> Gatien techniques</font><font color="#E5E5E5"> might</font>

461
00:17:46,059 --> 00:17:51,029
be used by<font color="#E5E5E5"> malware in the wild and</font><font color="#CCCCCC"> we</font>

462
00:17:48,429 --> 00:17:53,500
<font color="#CCCCCC">rant hero</font><font color="#E5E5E5"> on a data set of</font><font color="#CCCCCC"> 2000</font>

463
00:17:51,029 --> 00:17:56,260
obfuscated malware samples from<font color="#CCCCCC"> Barba's</font>

464
00:17:53,500 --> 00:17:58,150
total once again we found<font color="#E5E5E5"> that most of</font>

465
00:17:56,260 --> 00:18:01,090
<font color="#E5E5E5">the</font><font color="#CCCCCC"> samples</font><font color="#E5E5E5"> did some form of language</font>

466
00:17:58,150 --> 00:18:03,309
based operation and for<font color="#CCCCCC"> one</font><font color="#E5E5E5"> time based</font>

467
00:18:01,090 --> 00:18:05,260
on<font color="#E5E5E5"> the station we found that</font><font color="#CCCCCC"> 80%</font><font color="#E5E5E5"> of them</font>

468
00:18:03,309 --> 00:18:07,720
did<font color="#E5E5E5"> some form of</font><font color="#CCCCCC"> runtime based technique</font>

469
00:18:05,260 --> 00:18:10,299
<font color="#E5E5E5">this</font><font color="#CCCCCC"> is a much larger percentage of</font>

470
00:18:07,720 --> 00:18:12,700
runtime<font color="#E5E5E5"> based office keishon usage than</font>

471
00:18:10,299 --> 00:18:14,200
in our previous<font color="#E5E5E5"> data set and we believe</font>

472
00:18:12,700 --> 00:18:17,039
<font color="#E5E5E5">this might be because this virustotal</font>

473
00:18:14,200 --> 00:18:19,149
<font color="#CCCCCC">data is slightly</font><font color="#E5E5E5"> newer and might contain</font>

474
00:18:17,039 --> 00:18:23,649
more sophisticated obfuscation

475
00:18:19,149 --> 00:18:26,080
techniques so to conclude<font color="#E5E5E5"> in this work</font>

476
00:18:23,649 --> 00:18:27,820
<font color="#E5E5E5">we show a new type of office</font><font color="#CCCCCC"> Gatien</font>

477
00:18:26,080 --> 00:18:30,399
techniques in<font color="#CCCCCC"> android</font><font color="#E5E5E5"> that hasn't really</font>

478
00:18:27,820 --> 00:18:32,379
been reported before we categorize<font color="#E5E5E5"> these</font>

479
00:18:30,399 --> 00:18:34,449
techniques<font color="#E5E5E5"> and call them runtime based</font>

480
00:18:32,380 --> 00:18:36,399
office keishon because of the way they

481
00:18:34,450 --> 00:18:39,340
tamper with runtime state to<font color="#E5E5E5"> achieve</font>

482
00:18:36,399 --> 00:18:41,979
this unexpected code behavior<font color="#E5E5E5"> we also</font>

483
00:18:39,340 --> 00:18:43,870
present<font color="#CCCCCC"> tiro a hybrid</font><font color="#E5E5E5"> iterative the</font>

484
00:18:41,980 --> 00:18:46,120
obfuscation framework that can handle

485
00:18:43,870 --> 00:18:48,969
<font color="#CCCCCC">older office keishon techniques as well</font>

486
00:18:46,120 --> 00:18:50,979
as<font color="#E5E5E5"> these newer runtime based ones we</font>

487
00:18:48,970 --> 00:18:53,470
show that tiro is able to do<font color="#E5E5E5"> escape</font>

488
00:18:50,980 --> 00:18:55,809
modern malware and uncover new sensitive

489
00:18:53,470 --> 00:18:57,490
behaviors in these<font color="#CCCCCC"> applications and we</font>

490
00:18:55,809 --> 00:18:59,470
also show that runtime based<font color="#E5E5E5"> office</font>

491
00:18:57,490 --> 00:19:01,870
<font color="#CCCCCC">keishon is already in use in malware</font>

492
00:18:59,470 --> 00:19:04,179
today with<font color="#CCCCCC"> 80%</font><font color="#E5E5E5"> of the samples from our</font>

493
00:19:01,870 --> 00:19:07,870
virus total<font color="#E5E5E5"> data set</font><font color="#CCCCCC"> doing some form of</font>

494
00:19:04,179 --> 00:19:08,860
runtime<font color="#CCCCCC"> based office keishon this is our</font>

495
00:19:07,870 --> 00:19:10,779
contact information

496
00:19:08,860 --> 00:19:13,029
if you're<font color="#E5E5E5"> interested in our work and we</font>

497
00:19:10,779 --> 00:19:17,279
have put some<font color="#CCCCCC"> of the code for tiro</font><font color="#E5E5E5"> up on</font>

498
00:19:13,029 --> 00:19:17,279
github<font color="#E5E5E5"> thank you for your attention</font>

499
00:19:21,690 --> 00:19:33,070
<font color="#E5E5E5">okay thank you and we have time for some</font>

500
00:19:24,970 --> 00:19:35,950
questions hello this is<font color="#E5E5E5"> an email from</font>

501
00:19:33,070 --> 00:19:38,740
<font color="#E5E5E5">Google if I understand correctly the</font>

502
00:19:35,950 --> 00:19:43,750
additional sensitive API<font color="#E5E5E5"> call</font><font color="#CCCCCC"> city found</font>

503
00:19:38,740 --> 00:19:46,420
they were already<font color="#E5E5E5"> in some Java class so</font>

504
00:19:43,750 --> 00:19:48,460
did you find them<font color="#E5E5E5"> because</font><font color="#CCCCCC"> you found the</font>

505
00:19:46,420 --> 00:19:51,100
new paths on how to invoke them or

506
00:19:48,460 --> 00:19:52,990
<font color="#CCCCCC">Verdot sensitive API calls themselves</font>

507
00:19:51,100 --> 00:19:56,620
office obfuscated through native

508
00:19:52,990 --> 00:19:58,480
<font color="#E5E5E5">invocations</font><font color="#CCCCCC"> some of them were obfuscated</font>

509
00:19:56,620 --> 00:20:00,699
through native<font color="#E5E5E5"> implications so native</font>

510
00:19:58,480 --> 00:20:03,910
<font color="#E5E5E5">code invoking those methods some of them</font>

511
00:20:00,700 --> 00:20:06,460
were in<font color="#CCCCCC"> these sort</font><font color="#E5E5E5"> of dynamically loaded</font>

512
00:20:03,910 --> 00:20:07,960
or modified<font color="#CCCCCC"> bytecode</font><font color="#E5E5E5"> that was that</font>

513
00:20:06,460 --> 00:20:10,600
resulted from runtime based<font color="#E5E5E5"> office</font>

514
00:20:07,960 --> 00:20:13,120
keishon<font color="#E5E5E5"> but that was originally loaded</font>

515
00:20:10,600 --> 00:20:16,629
<font color="#E5E5E5">from another java file just hooked into</font>

516
00:20:13,120 --> 00:20:18,520
the control flow through<font color="#E5E5E5"> natives yeah</font>

517
00:20:16,630 --> 00:20:20,200
some of<font color="#E5E5E5"> them were in</font><font color="#CCCCCC"> just</font><font color="#E5E5E5"> they were they</font>

518
00:20:18,520 --> 00:20:22,660
were<font color="#E5E5E5"> like called from</font><font color="#CCCCCC"> Java code</font><font color="#E5E5E5"> that's</font>

519
00:20:20,200 --> 00:20:24,370
<font color="#E5E5E5">because the API calls would have they</font>

520
00:20:22,660 --> 00:20:26,080
are already<font color="#E5E5E5"> in</font><font color="#CCCCCC"> Java code</font><font color="#E5E5E5"> but a static</font>

521
00:20:24,370 --> 00:20:32,379
analyzer wouldn't have you seen them

522
00:20:26,080 --> 00:20:34,960
being invoked<font color="#E5E5E5"> yeah okay thank you so</font>

523
00:20:32,380 --> 00:20:37,060
what if an<font color="#CCCCCC"> attacker</font><font color="#E5E5E5"> is aware</font><font color="#CCCCCC"> of your</font>

524
00:20:34,960 --> 00:20:40,510
<font color="#E5E5E5">methods</font><font color="#CCCCCC"> so what are the limitations how</font>

525
00:20:37,060 --> 00:20:43,480
could he bypass the analysis steps<font color="#E5E5E5"> right</font>

526
00:20:40,510 --> 00:20:46,420
so our monitoring of runtime<font color="#CCCCCC"> state is</font>

527
00:20:43,480 --> 00:20:48,160
done in<font color="#E5E5E5"> the same</font><font color="#CCCCCC"> in</font><font color="#E5E5E5"> the runtime so and</font>

528
00:20:46,420 --> 00:20:49,990
it's<font color="#E5E5E5"> not a native code so we keep the</font>

529
00:20:48,160 --> 00:20:51,940
same<font color="#E5E5E5"> runtime based techniques can't</font>

530
00:20:49,990 --> 00:20:53,740
bypass<font color="#E5E5E5"> them but native code obfuscation</font>

531
00:20:51,940 --> 00:20:55,030
techniques could try and<font color="#E5E5E5"> hook some of</font>

532
00:20:53,740 --> 00:20:57,490
the methods we use<font color="#E5E5E5"> so this is a</font>

533
00:20:55,030 --> 00:20:59,620
limitation<font color="#E5E5E5"> for us and it's sort of the</font>

534
00:20:57,490 --> 00:21:01,510
same limitation as<font color="#E5E5E5"> why runtime based</font>

535
00:20:59,620 --> 00:21:03,760
<font color="#CCCCCC">office keishon is possible in the sense</font>

536
00:21:01,510 --> 00:21:05,379
<font color="#E5E5E5">that the runtime and the application is</font>

537
00:21:03,760 --> 00:21:08,080
in the<font color="#E5E5E5"> same</font><font color="#CCCCCC"> memory space and there's no</font>

538
00:21:05,380 --> 00:21:09,900
<font color="#E5E5E5">protection there and the second question</font>

539
00:21:08,080 --> 00:21:12,429
<font color="#CCCCCC">is</font><font color="#E5E5E5"> related to the data set</font><font color="#CCCCCC"> so you</font>

540
00:21:09,900 --> 00:21:14,260
<font color="#E5E5E5">mentioned in</font><font color="#CCCCCC"> your</font><font color="#E5E5E5"> talk that the</font><font color="#CCCCCC"> 2,000</font>

541
00:21:12,430 --> 00:21:16,270
samples<font color="#E5E5E5"> from</font><font color="#CCCCCC"> virustotal</font><font color="#E5E5E5"> they were</font>

542
00:21:14,260 --> 00:21:19,210
obfuscated<font color="#E5E5E5"> or did you just</font><font color="#CCCCCC"> randomly</font>

543
00:21:16,270 --> 00:21:21,220
download<font color="#CCCCCC"> android</font><font color="#E5E5E5"> sample they</font><font color="#CCCCCC"> were</font><font color="#E5E5E5"> stated</font>

544
00:21:19,210 --> 00:21:23,320
yeah how did<font color="#CCCCCC"> you</font><font color="#E5E5E5"> determine that they</font>

545
00:21:21,220 --> 00:21:26,250
also<font color="#E5E5E5"> stated I believe</font><font color="#CCCCCC"> we use office</font>

546
00:21:23,320 --> 00:21:26,250
<font color="#CCCCCC">kated as a keyword</font>

547
00:21:26,270 --> 00:21:31,620
<font color="#E5E5E5">okay so if there are no</font><font color="#CCCCCC"> more questions</font>

548
00:21:28,860 --> 00:21:34,810
<font color="#E5E5E5">then let's</font><font color="#CCCCCC"> think Michelle again and</font>

549
00:21:31,620 --> 00:21:34,810
[Applause]

