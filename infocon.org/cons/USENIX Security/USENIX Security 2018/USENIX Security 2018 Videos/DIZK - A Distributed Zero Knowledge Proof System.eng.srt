1
00:00:10,019 --> 00:00:16,329
<font color="#E5E5E5">all right um so hi my name is Howard</font><font color="#CCCCCC"> I'm</font>

2
00:00:13,840 --> 00:00:18,310
a<font color="#E5E5E5"> graduate student at UC Berkeley</font><font color="#CCCCCC"> today</font>

3
00:00:16,329 --> 00:00:19,750
I'm going to<font color="#E5E5E5"> talk about physic this is a</font>

4
00:00:18,310 --> 00:00:22,720
distributed zero knowledge proof system

5
00:00:19,750 --> 00:00:27,130
<font color="#CCCCCC">and this is joint work done with</font><font color="#E5E5E5"> wenting</font>

6
00:00:22,720 --> 00:00:30,160
<font color="#CCCCCC">Alessandro Luca</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> Don so to begin what</font>

7
00:00:27,130 --> 00:00:31,840
<font color="#E5E5E5">is</font><font color="#CCCCCC"> a zero knowledge proof</font><font color="#E5E5E5"> well as</font><font color="#CCCCCC"> your</font>

8
00:00:30,160 --> 00:00:34,989
knowledge proof involves two parties

9
00:00:31,840 --> 00:00:37,960
approver and<font color="#E5E5E5"> a verifier and both know of</font>

10
00:00:34,989 --> 00:00:42,370
a public function f and some claimed

11
00:00:37,960 --> 00:00:45,250
output<font color="#E5E5E5"> Y the prover says hey I know some</font>

12
00:00:42,370 --> 00:00:48,099
secret input X such that f of X is<font color="#CCCCCC"> equal</font>

13
00:00:45,250 --> 00:00:49,600
to<font color="#CCCCCC"> Y and the verifier will challenge the</font>

14
00:00:48,100 --> 00:00:51,610
prover and they play this interactive

15
00:00:49,600 --> 00:00:53,110
game after which a prove<font color="#E5E5E5"> our will</font>

16
00:00:51,610 --> 00:00:56,620
convince the verifier that they know

17
00:00:53,110 --> 00:00:57,970
<font color="#E5E5E5">this claim now one particular type of</font>

18
00:00:56,620 --> 00:01:00,370
zero knowledge proof that<font color="#E5E5E5"> has gained</font>

19
00:00:57,970 --> 00:01:03,309
significant attention<font color="#E5E5E5"> is that</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> ZK</font>

20
00:01:00,370 --> 00:01:04,839
snarks<font color="#CCCCCC"> and easy case</font><font color="#E5E5E5"> narc is a zero</font>

21
00:01:03,309 --> 00:01:07,780
knowledge proof<font color="#E5E5E5"> that has a few</font>

22
00:01:04,839 --> 00:01:10,390
additional<font color="#E5E5E5"> guarantees first</font><font color="#CCCCCC"> off it is</font>

23
00:01:07,780 --> 00:01:13,180
<font color="#E5E5E5">non interactive meaning the prover only</font>

24
00:01:10,390 --> 00:01:14,770
needs to prove provide a proof to

25
00:01:13,180 --> 00:01:18,100
convince the verifier that they know the

26
00:01:14,770 --> 00:01:19,960
private input<font color="#E5E5E5"> X but in addition it</font><font color="#CCCCCC"> is</font>

27
00:01:18,100 --> 00:01:21,699
<font color="#E5E5E5">also succinct meaning that the proof is</font>

28
00:01:19,960 --> 00:01:25,330
small in size<font color="#CCCCCC"> and the verification time</font>

29
00:01:21,700 --> 00:01:26,619
is fast<font color="#E5E5E5"> one particular type</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> the ZK</font>

30
00:01:25,330 --> 00:01:29,920
snark that we're going<font color="#E5E5E5"> to</font><font color="#CCCCCC"> look at today</font>

31
00:01:26,619 --> 00:01:31,690
<font color="#CCCCCC">is a pre-processing ZK snark and this is</font>

32
00:01:29,920 --> 00:01:33,520
one where you<font color="#E5E5E5"> have a</font><font color="#CCCCCC"> set up</font><font color="#E5E5E5"> that takes</font>

33
00:01:31,690 --> 00:01:36,369
<font color="#E5E5E5">us input a public function f and</font>

34
00:01:33,520 --> 00:01:39,220
produces two outputs<font color="#E5E5E5"> a proving key and a</font>

35
00:01:36,369 --> 00:01:41,229
verification key note that the proving

36
00:01:39,220 --> 00:01:45,548
here is significantly larger than the

37
00:01:41,229 --> 00:01:48,580
verification key and overall ZK<font color="#CCCCCC"> snart's</font>

38
00:01:45,549 --> 00:01:52,030
have many interesting applications<font color="#CCCCCC"> two</font>

39
00:01:48,580 --> 00:01:53,350
of which we'll<font color="#CCCCCC"> discuss today</font><font color="#E5E5E5"> so the</font>

40
00:01:52,030 --> 00:01:56,890
first application we're going<font color="#CCCCCC"> to</font><font color="#E5E5E5"> look at</font>

41
00:01:53,350 --> 00:02:00,490
is<font color="#E5E5E5"> peer to</font><font color="#CCCCCC"> peer payments suppose</font><font color="#E5E5E5"> Alice</font>

42
00:01:56,890 --> 00:02:01,630
wants to<font color="#CCCCCC"> pay</font><font color="#E5E5E5"> Bob one dollar she may use</font>

43
00:02:00,490 --> 00:02:04,270
something like a blockchain to

44
00:02:01,630 --> 00:02:06,339
facilitate this<font color="#CCCCCC"> payment but this would</font>

45
00:02:04,270 --> 00:02:08,500
<font color="#E5E5E5">certainly reveal that she's the sender</font>

46
00:02:06,340 --> 00:02:10,470
that<font color="#E5E5E5"> Bob's the receiver and that the</font>

47
00:02:08,500 --> 00:02:12,670
payment amount is for<font color="#CCCCCC"> a dollar</font>

48
00:02:10,470 --> 00:02:15,189
instead<font color="#CCCCCC"> alice could encrypt the contents</font>

49
00:02:12,670 --> 00:02:17,379
of the payment attaching a<font color="#CCCCCC"> ZK start</font>

50
00:02:15,189 --> 00:02:20,230
proof attesting to<font color="#E5E5E5"> the validity</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> this</font>

51
00:02:17,379 --> 00:02:22,480
payment this is

52
00:02:20,230 --> 00:02:25,988
protocol<font color="#CCCCCC"> code zero cash</font><font color="#E5E5E5"> which has</font>

53
00:02:22,480 --> 00:02:28,149
manifested in industry<font color="#CCCCCC"> as e cash</font><font color="#E5E5E5"> let's</font>

54
00:02:25,989 --> 00:02:30,250
look at a second application<font color="#CCCCCC"> so suppose</font>

55
00:02:28,150 --> 00:02:33,430
<font color="#E5E5E5">you wanted to use smart contracts to run</font>

56
00:02:30,250 --> 00:02:35,349
a publicly verifiable computation while

57
00:02:33,430 --> 00:02:37,980
today<font color="#E5E5E5"> invoking a smart contract requires</font>

58
00:02:35,349 --> 00:02:40,780
validators to rerun<font color="#CCCCCC"> the computation</font><font color="#E5E5E5"> and</font>

59
00:02:37,980 --> 00:02:42,540
a more scalable<font color="#E5E5E5"> approaches for the</font>

60
00:02:40,780 --> 00:02:44,890
caller to run the computation off chain

61
00:02:42,540 --> 00:02:46,900
sending the result along with the proof

62
00:02:44,890 --> 00:02:49,958
and attesting to<font color="#E5E5E5"> the validity of the</font>

63
00:02:46,900 --> 00:02:53,470
result then the validators would only

64
00:02:49,959 --> 00:02:54,879
<font color="#E5E5E5">need to check the proof and we have</font>

65
00:02:53,470 --> 00:02:58,930
already<font color="#E5E5E5"> established here that the proof</font>

66
00:02:54,879 --> 00:03:00,310
<font color="#E5E5E5">itself is quite cheap so first off these</font>

67
00:02:58,930 --> 00:03:01,540
<font color="#CCCCCC">are only two</font><font color="#E5E5E5"> applications of</font><font color="#CCCCCC"> ceará</font>

68
00:03:00,310 --> 00:03:03,129
knowledge proofs and<font color="#E5E5E5"> don't be offended</font>

69
00:03:01,540 --> 00:03:05,048
if your<font color="#E5E5E5"> favorite application</font><font color="#CCCCCC"> wasn't</font>

70
00:03:03,129 --> 00:03:07,390
presented here<font color="#CCCCCC"> these</font><font color="#E5E5E5"> two applications</font>

71
00:03:05,049 --> 00:03:09,870
<font color="#E5E5E5">were</font><font color="#CCCCCC"> chosen specifically</font><font color="#E5E5E5"> to motivate our</font>

72
00:03:07,390 --> 00:03:12,250
problem<font color="#E5E5E5"> which I'm now going to address</font>

73
00:03:09,870 --> 00:03:17,230
<font color="#CCCCCC">so we have some good news</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> some bad</font>

74
00:03:12,250 --> 00:03:18,730
news<font color="#CCCCCC"> if we look at the</font><font color="#E5E5E5"> circuit sizes of</font>

75
00:03:17,230 --> 00:03:21,129
the applications that<font color="#E5E5E5"> we just discussed</font>

76
00:03:18,730 --> 00:03:22,480
<font color="#E5E5E5">well in the case of</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> private payment</font>

77
00:03:21,129 --> 00:03:25,959
<font color="#E5E5E5">we're looking at something that is</font>

78
00:03:22,480 --> 00:03:28,720
<font color="#E5E5E5">approximately a million gates and this</font>

79
00:03:25,959 --> 00:03:31,090
is actually pretty good<font color="#CCCCCC"> it's practical</font>

80
00:03:28,720 --> 00:03:33,989
and this is something<font color="#CCCCCC"> that</font><font color="#E5E5E5"> can be used</font>

81
00:03:31,090 --> 00:03:36,430
in<font color="#E5E5E5"> current decays snark implementations</font>

82
00:03:33,989 --> 00:03:38,769
however if we look<font color="#E5E5E5"> at a typical smart</font>

83
00:03:36,430 --> 00:03:40,450
contract execution<font color="#CCCCCC"> we find that the size</font>

84
00:03:38,769 --> 00:03:44,079
is<font color="#CCCCCC"> approximately a</font><font color="#E5E5E5"> hundred million gates</font>

85
00:03:40,450 --> 00:03:45,548
<font color="#E5E5E5">and if we look at even larger smart</font>

86
00:03:44,079 --> 00:03:47,970
contract executions we find ourselves

87
00:03:45,549 --> 00:03:50,319
using<font color="#E5E5E5"> billions of gates</font>

88
00:03:47,970 --> 00:03:52,720
unfortunately current monolithic<font color="#CCCCCC"> z:k</font>

89
00:03:50,319 --> 00:03:55,238
snark implementations<font color="#E5E5E5"> run out of memory</font>

90
00:03:52,720 --> 00:03:57,669
at approximately<font color="#E5E5E5"> 10 million gates and</font>

91
00:03:55,239 --> 00:04:00,549
this makes these applications just<font color="#E5E5E5"> out</font>

92
00:03:57,669 --> 00:04:02,769
of reach from current techniques so we

93
00:04:00,549 --> 00:04:04,660
<font color="#CCCCCC">ask ourselves what would be a stepping</font>

94
00:04:02,769 --> 00:04:12,010
stone<font color="#CCCCCC"> for enabling</font><font color="#E5E5E5"> applications</font><font color="#CCCCCC"> such as</font>

95
00:04:04,660 --> 00:04:14,349
<font color="#E5E5E5">this and so we designed</font><font color="#CCCCCC"> physic</font><font color="#E5E5E5"> physic is</font>

96
00:04:12,010 --> 00:04:17,108
a<font color="#E5E5E5"> zero knowledge proof system that is</font>

97
00:04:14,349 --> 00:04:19,269
one distributed<font color="#E5E5E5"> meaning it enables the</font>

98
00:04:17,108 --> 00:04:22,780
execution<font color="#E5E5E5"> of a</font><font color="#CCCCCC"> ZK</font><font color="#E5E5E5"> start set up and prove</font>

99
00:04:19,269 --> 00:04:24,460
across a compute cluster<font color="#CCCCCC"> - it is</font>

100
00:04:22,780 --> 00:04:26,500
<font color="#CCCCCC">scalable</font><font color="#E5E5E5"> meaning</font><font color="#CCCCCC"> that it reaches</font>

101
00:04:24,460 --> 00:04:28,960
<font color="#CCCCCC">heretofore unreachable circuit sizes up</font>

102
00:04:26,500 --> 00:04:30,550
<font color="#CCCCCC">to billions of</font><font color="#E5E5E5"> gates and the pattern</font>

103
00:04:28,960 --> 00:04:32,140
<font color="#CCCCCC">that we see here</font><font color="#E5E5E5"> is that as we double</font>

104
00:04:30,550 --> 00:04:33,460
the<font color="#CCCCCC"> number of machines we can support</font>

105
00:04:32,140 --> 00:04:33,909
<font color="#CCCCCC">approximately twice the number of</font>

106
00:04:33,460 --> 00:04:38,109
circuit

107
00:04:33,910 --> 00:04:39,520
and lastly it is<font color="#E5E5E5"> parallel meaning</font><font color="#CCCCCC"> that</font>

108
00:04:38,110 --> 00:04:41,500
we can speed up the<font color="#E5E5E5"> time it takes to</font>

109
00:04:39,520 --> 00:04:43,479
<font color="#CCCCCC">generate a proof</font><font color="#E5E5E5"> and the pattern that we</font>

110
00:04:41,500 --> 00:04:46,570
see here<font color="#E5E5E5"> is that as we double the number</font>

111
00:04:43,480 --> 00:04:50,320
<font color="#CCCCCC">of machines the proof generation itself</font>

112
00:04:46,570 --> 00:04:53,050
<font color="#E5E5E5">runs at approximately twice as fast so</font>

113
00:04:50,320 --> 00:04:55,719
how did<font color="#CCCCCC"> we do</font><font color="#E5E5E5"> this well the approach</font>

114
00:04:53,050 --> 00:04:58,540
<font color="#E5E5E5">that we took</font><font color="#CCCCCC"> was we used a</font><font color="#E5E5E5"> model of a</font>

115
00:04:55,720 --> 00:05:01,690
snark<font color="#E5E5E5"> namely one by N's</font><font color="#CCCCCC"> gras</font><font color="#E5E5E5"> from 2016</font>

116
00:04:58,540 --> 00:05:05,380
<font color="#E5E5E5">and we distributed it on a cluster</font><font color="#CCCCCC"> of</font>

117
00:05:01,690 --> 00:05:07,420
machines<font color="#E5E5E5"> now this approach appears quite</font>

118
00:05:05,380 --> 00:05:08,710
simple however it turns out there are<font color="#CCCCCC"> a</font>

119
00:05:07,420 --> 00:05:11,710
lot of<font color="#CCCCCC"> challenges to</font><font color="#E5E5E5"> distributing this</font>

120
00:05:08,710 --> 00:05:13,510
protocol<font color="#CCCCCC"> we chose grass 16 for example</font>

121
00:05:11,710 --> 00:05:15,520
<font color="#CCCCCC">specifically because it's highly</font>

122
00:05:13,510 --> 00:05:18,159
<font color="#E5E5E5">efficient and currently offers the</font>

123
00:05:15,520 --> 00:05:19,659
smallest<font color="#CCCCCC"> decay</font><font color="#E5E5E5"> start proof size and in</font>

124
00:05:18,160 --> 00:05:21,880
general we had to tailor our

125
00:05:19,660 --> 00:05:23,560
architecture at every<font color="#E5E5E5"> level</font><font color="#CCCCCC"> to ensure</font>

126
00:05:21,880 --> 00:05:26,130
<font color="#CCCCCC">that</font><font color="#E5E5E5"> our protocol could adequately</font>

127
00:05:23,560 --> 00:05:28,120
demonstrate<font color="#E5E5E5"> scalability and parallelism</font>

128
00:05:26,130 --> 00:05:32,110
<font color="#E5E5E5">let me walk</font><font color="#CCCCCC"> you through some</font><font color="#E5E5E5"> of the</font>

129
00:05:28,120 --> 00:05:34,960
<font color="#CCCCCC">challenges</font><font color="#E5E5E5"> we faced now so take this</font>

130
00:05:32,110 --> 00:05:36,910
diagram of<font color="#CCCCCC"> a Z</font><font color="#E5E5E5"> connect protocol and I</font>

131
00:05:34,960 --> 00:05:39,340
want to point out<font color="#E5E5E5"> that the verifier here</font>

132
00:05:36,910 --> 00:05:41,170
<font color="#E5E5E5">is extremely small and</font><font color="#CCCCCC"> cheap to run</font>

133
00:05:39,340 --> 00:05:43,989
therefore we're going<font color="#E5E5E5"> to turn our</font>

134
00:05:41,170 --> 00:05:46,060
<font color="#E5E5E5">attention to the setup and the</font><font color="#CCCCCC"> prover at</font>

135
00:05:43,990 --> 00:05:48,190
first glance<font color="#CCCCCC"> will want to spin up a</font>

136
00:05:46,060 --> 00:05:52,030
<font color="#E5E5E5">cluster of</font><font color="#CCCCCC"> machines</font><font color="#E5E5E5"> and run the set up</font>

137
00:05:48,190 --> 00:05:54,160
and prove<font color="#CCCCCC"> our on it</font><font color="#E5E5E5"> next we'll want to</font>

138
00:05:52,030 --> 00:05:55,750
<font color="#CCCCCC">use a</font><font color="#E5E5E5"> distributed data structure to</font>

139
00:05:54,160 --> 00:05:57,400
<font color="#CCCCCC">represent our public function f</font><font color="#E5E5E5"> for</font>

140
00:05:55,750 --> 00:06:01,560
approving<font color="#CCCCCC"> key which we said was</font><font color="#E5E5E5"> large</font>

141
00:05:57,400 --> 00:06:04,630
<font color="#E5E5E5">and our secret input this looks</font><font color="#CCCCCC"> alright</font>

142
00:06:01,560 --> 00:06:06,220
however it's not there<font color="#E5E5E5"> are several</font>

143
00:06:04,630 --> 00:06:09,070
challenges<font color="#CCCCCC"> that arise</font><font color="#E5E5E5"> with this current</font>

144
00:06:06,220 --> 00:06:11,110
<font color="#E5E5E5">setup first we're multiplying</font>

145
00:06:09,070 --> 00:06:14,950
polynomials of degree that<font color="#E5E5E5"> are now in</font>

146
00:06:11,110 --> 00:06:18,780
the billions<font color="#CCCCCC"> to</font><font color="#E5E5E5"> we're representing these</font>

147
00:06:14,950 --> 00:06:21,250
polynomials as terabit sized arrays

148
00:06:18,780 --> 00:06:23,979
third were<font color="#E5E5E5"> accessing large pools of</font>

149
00:06:21,250 --> 00:06:27,970
shared memory<font color="#CCCCCC"> in complex access patterns</font>

150
00:06:23,980 --> 00:06:29,860
<font color="#E5E5E5">and fourth were synchronizing shared</font>

151
00:06:27,970 --> 00:06:34,630
<font color="#E5E5E5">state that incurs significant</font><font color="#CCCCCC"> network</font>

152
00:06:29,860 --> 00:06:36,580
delays these are<font color="#E5E5E5"> fundamental challenges</font>

153
00:06:34,630 --> 00:06:40,000
that we<font color="#CCCCCC"> need to overcome and so we do so</font>

154
00:06:36,580 --> 00:06:42,250
in the following<font color="#E5E5E5"> way for for</font><font color="#CCCCCC"> disick</font><font color="#E5E5E5"> our</font>

155
00:06:40,000 --> 00:06:43,960
<font color="#E5E5E5">architecture looks like this so we start</font>

156
00:06:42,250 --> 00:06:45,610
with<font color="#E5E5E5"> the</font><font color="#CCCCCC"> setup it turns out it's not</font>

157
00:06:43,960 --> 00:06:47,120
enough to keep the subcomponents<font color="#E5E5E5"> of the</font>

158
00:06:45,610 --> 00:06:48,740
<font color="#CCCCCC">setup monolithic</font>

159
00:06:47,120 --> 00:06:50,510
so we distribute<font color="#E5E5E5"> the</font><font color="#CCCCCC"> setup by</font>

160
00:06:48,740 --> 00:06:52,720
implementing distributed algorithms for

161
00:06:50,510 --> 00:06:55,190
<font color="#E5E5E5">each of the sub components in</font><font color="#CCCCCC"> this</font><font color="#E5E5E5"> setup</font>

162
00:06:52,720 --> 00:06:57,229
<font color="#E5E5E5">the distribute setup then outputs a</font>

163
00:06:55,190 --> 00:07:00,650
distributed proving<font color="#E5E5E5"> team and a small</font>

164
00:06:57,229 --> 00:07:02,810
verification key<font color="#E5E5E5"> just as before</font><font color="#CCCCCC"> we</font>

165
00:07:00,650 --> 00:07:04,310
distribute the prover<font color="#E5E5E5"> by distributing</font>

166
00:07:02,810 --> 00:07:07,729
the monolithic sub components of the

167
00:07:04,310 --> 00:07:09,620
prover and lastly<font color="#E5E5E5"> the verifier will then</font>

168
00:07:07,729 --> 00:07:11,570
check<font color="#CCCCCC"> that the proof is valid</font><font color="#E5E5E5"> and again</font>

169
00:07:09,620 --> 00:07:15,650
<font color="#E5E5E5">we forego distributing this step as it</font>

170
00:07:11,570 --> 00:07:17,810
is extremely cheap to<font color="#E5E5E5"> run for the sake</font>

171
00:07:15,650 --> 00:07:20,419
of time<font color="#E5E5E5"> today</font><font color="#CCCCCC"> I want to focus on one</font>

172
00:07:17,810 --> 00:07:23,060
critical part<font color="#CCCCCC"> of</font><font color="#E5E5E5"> our system</font><font color="#CCCCCC"> and that's</font>

173
00:07:20,419 --> 00:07:24,530
<font color="#E5E5E5">the distributed</font><font color="#CCCCCC"> proved err you'll find</font>

174
00:07:23,060 --> 00:07:28,490
detailed explanations for all<font color="#E5E5E5"> of our</font>

175
00:07:24,530 --> 00:07:30,198
techniques<font color="#E5E5E5"> in the paper</font><font color="#CCCCCC"> and today I want</font>

176
00:07:28,490 --> 00:07:33,470
to<font color="#E5E5E5"> discuss one critical component</font><font color="#CCCCCC"> in our</font>

177
00:07:30,199 --> 00:07:35,270
system<font color="#E5E5E5"> that is the witness reduction I</font>

178
00:07:33,470 --> 00:07:37,340
will go<font color="#E5E5E5"> over our thought process for</font>

179
00:07:35,270 --> 00:07:39,919
distributing this guy<font color="#E5E5E5"> and also show you</font>

180
00:07:37,340 --> 00:07:41,570
<font color="#E5E5E5">some of the few</font><font color="#CCCCCC"> of the few off-the-shelf</font>

181
00:07:39,919 --> 00:07:44,150
approaches to computing the reduction

182
00:07:41,570 --> 00:07:45,710
<font color="#E5E5E5">and lastly show you the tailored</font>

183
00:07:44,150 --> 00:07:47,690
approach that we used to make the

184
00:07:45,710 --> 00:07:52,099
<font color="#E5E5E5">witness reduction itself both</font><font color="#CCCCCC"> scaleable</font>

185
00:07:47,690 --> 00:07:54,710
and parallel so to efficiently compute

186
00:07:52,099 --> 00:07:56,900
the<font color="#E5E5E5"> ZK start proof we need to reduce the</font>

187
00:07:54,710 --> 00:08:01,430
circuit<font color="#CCCCCC"> we started with</font><font color="#E5E5E5"> into polynomial</font>

188
00:07:56,900 --> 00:08:04,750
form and namely the equation that<font color="#E5E5E5"> we</font><font color="#CCCCCC"> are</font>

189
00:08:01,430 --> 00:08:07,060
<font color="#E5E5E5">going to evaluate here is this one if</font>

190
00:08:04,750 --> 00:08:09,470
you<font color="#E5E5E5"> haven't seen this equation before</font>

191
00:08:07,060 --> 00:08:11,810
<font color="#CCCCCC">this</font><font color="#E5E5E5"> is an important equation introduced</font>

192
00:08:09,470 --> 00:08:14,780
in GG PR<font color="#E5E5E5"> 13 that defines a quadratic</font>

193
00:08:11,810 --> 00:08:18,470
arithmetic program and this has to do

194
00:08:14,780 --> 00:08:20,479
with<font color="#E5E5E5"> arithmetic</font><font color="#CCCCCC"> circuits</font><font color="#E5E5E5"> if we zoom in</font>

195
00:08:18,470 --> 00:08:22,699
<font color="#CCCCCC">on this</font><font color="#E5E5E5"> equation there are three terms</font>

196
00:08:20,479 --> 00:08:24,919
<font color="#E5E5E5">that need</font><font color="#CCCCCC"> to be efficiently represented</font>

197
00:08:22,699 --> 00:08:27,440
<font color="#E5E5E5">and evaluated in order to perform the</font>

198
00:08:24,919 --> 00:08:30,289
<font color="#E5E5E5">witness reduction and also notice</font><font color="#CCCCCC"> that</font>

199
00:08:27,440 --> 00:08:33,500
these are these each have summations

200
00:08:30,289 --> 00:08:36,890
that are from<font color="#CCCCCC"> zero to</font><font color="#E5E5E5"> n and n here</font><font color="#CCCCCC"> is</font>

201
00:08:33,500 --> 00:08:39,169
going<font color="#E5E5E5"> to be in the billions so I will</font>

202
00:08:36,890 --> 00:08:41,419
focus<font color="#E5E5E5"> on how we can efficiently evaluate</font>

203
00:08:39,169 --> 00:08:43,610
these<font color="#E5E5E5"> summations</font><font color="#CCCCCC"> note</font><font color="#E5E5E5"> that the</font>

204
00:08:41,419 --> 00:08:45,980
<font color="#E5E5E5">arithmetic operations</font><font color="#CCCCCC"> outside of these</font>

205
00:08:43,610 --> 00:08:48,910
three terms<font color="#E5E5E5"> will make use of distributed</font>

206
00:08:45,980 --> 00:08:51,920
<font color="#CCCCCC">f of T's</font><font color="#E5E5E5"> which I will leave to the paper</font>

207
00:08:48,910 --> 00:08:53,540
now zooming in on one of<font color="#E5E5E5"> these terms we</font>

208
00:08:51,920 --> 00:08:57,740
see that there are<font color="#E5E5E5"> two components</font><font color="#CCCCCC"> a</font>

209
00:08:53,540 --> 00:08:59,420
<font color="#E5E5E5">matrix a and a vector Z the matrix a</font>

210
00:08:57,740 --> 00:09:00,980
represents one part of<font color="#E5E5E5"> the employers</font>

211
00:08:59,420 --> 00:09:03,079
comprising our circuit

212
00:09:00,980 --> 00:09:05,269
and the<font color="#E5E5E5"> vector Z is a satisfying</font>

213
00:09:03,079 --> 00:09:06,739
<font color="#CCCCCC">assignment to the circuit it's you can</font>

214
00:09:05,269 --> 00:09:11,600
think<font color="#E5E5E5"> of it as a combination of the</font>

215
00:09:06,740 --> 00:09:14,899
public inputs and the secret inputs so

216
00:09:11,600 --> 00:09:18,769
we start by representing our matrix a as

217
00:09:14,899 --> 00:09:21,440
an<font color="#E5E5E5"> n plus 1 by M matrix and</font><font color="#CCCCCC"> we'll</font>

218
00:09:18,769 --> 00:09:24,500
represent<font color="#E5E5E5"> our vector Z as an n plus 1</font>

219
00:09:21,440 --> 00:09:26,000
vector and for a strawman approach to

220
00:09:24,500 --> 00:09:28,130
evaluate the sums<font color="#E5E5E5"> what we need to do</font>

221
00:09:26,000 --> 00:09:33,949
first is join the<font color="#E5E5E5"> elements by their</font>

222
00:09:28,130 --> 00:09:37,370
index here<font color="#E5E5E5"> which is I we may partition</font>

223
00:09:33,949 --> 00:09:40,819
our matrix a row wise and our vector is

224
00:09:37,370 --> 00:09:43,190
the element<font color="#E5E5E5"> wise and next we'll join our</font>

225
00:09:40,820 --> 00:09:46,370
partition row wise so<font color="#E5E5E5"> you know</font><font color="#CCCCCC"> 8 0 goes</font>

226
00:09:43,190 --> 00:09:50,060
with<font color="#E5E5E5"> Z 0 a 1 goes with its u 1 and all</font>

227
00:09:46,370 --> 00:09:51,440
the way<font color="#E5E5E5"> down to a n with Zn and this</font>

228
00:09:50,060 --> 00:09:52,029
generates a join table that looks like

229
00:09:51,440 --> 00:09:55,459
this

230
00:09:52,029 --> 00:09:57,199
it appears quite<font color="#E5E5E5"> uniform and costs with</font>

231
00:09:55,459 --> 00:09:59,750
each<font color="#E5E5E5"> entry now independent of all other</font>

232
00:09:57,199 --> 00:10:03,829
entries<font color="#E5E5E5"> however it turns out this isn't</font>

233
00:09:59,750 --> 00:10:05,120
<font color="#CCCCCC">the case and let's see why so because of</font>

234
00:10:03,829 --> 00:10:08,620
the nature<font color="#CCCCCC"> of our circuit representation</font>

235
00:10:05,120 --> 00:10:11,720
<font color="#E5E5E5">our matrix is what we call</font><font color="#CCCCCC"> almost sparse</font>

236
00:10:08,620 --> 00:10:14,180
<font color="#E5E5E5">this means that most rows and columns</font>

237
00:10:11,720 --> 00:10:17,180
are<font color="#E5E5E5"> sparse however there will always</font><font color="#CCCCCC"> be</font>

238
00:10:14,180 --> 00:10:19,519
a handful that<font color="#E5E5E5"> are dense if we</font>

239
00:10:17,180 --> 00:10:21,800
partitioned<font color="#E5E5E5"> our matrix column wise for</font>

240
00:10:19,519 --> 00:10:24,829
<font color="#E5E5E5">the cluster</font><font color="#CCCCCC"> to compute the second column</font>

241
00:10:21,800 --> 00:10:27,469
in this<font color="#E5E5E5"> case would be slow and what we</font>

242
00:10:24,829 --> 00:10:29,120
would call<font color="#E5E5E5"> a straggler this causes all</font>

243
00:10:27,470 --> 00:10:35,300
the other<font color="#E5E5E5"> machines to wait on it to</font>

244
00:10:29,120 --> 00:10:38,300
<font color="#E5E5E5">finish its task so if we partition our</font>

245
00:10:35,300 --> 00:10:40,370
matrix row wise<font color="#E5E5E5"> again we actually run</font>

246
00:10:38,300 --> 00:10:42,370
<font color="#E5E5E5">into the same problem and as you see</font>

247
00:10:40,370 --> 00:10:44,569
here with the first row as our straggler

248
00:10:42,370 --> 00:10:50,600
<font color="#E5E5E5">causing all other machines to wait on it</font>

249
00:10:44,569 --> 00:10:53,899
<font color="#E5E5E5">to finish its task so we studied some</font>

250
00:10:50,600 --> 00:10:55,399
off-the-shelf<font color="#E5E5E5"> approaches and the goal</font>

251
00:10:53,899 --> 00:10:57,680
here<font color="#CCCCCC"> is to address</font><font color="#E5E5E5"> the problem of data</font>

252
00:10:55,399 --> 00:10:59,449
skew<font color="#E5E5E5"> and we</font><font color="#CCCCCC"> benchmarked them across</font>

253
00:10:57,680 --> 00:11:01,089
<font color="#CCCCCC">bearing circuit sizes a number of</font>

254
00:10:59,449 --> 00:11:03,589
<font color="#CCCCCC">machines to determine the feasibility</font>

255
00:11:01,089 --> 00:11:06,949
<font color="#CCCCCC">the</font><font color="#E5E5E5"> approach that's taken by these</font>

256
00:11:03,589 --> 00:11:09,949
off-the-shelf approaches is<font color="#E5E5E5"> to</font><font color="#CCCCCC"> replicate</font>

257
00:11:06,949 --> 00:11:11,420
and partition the data<font color="#E5E5E5"> so the</font><font color="#CCCCCC"> first</font>

258
00:11:09,949 --> 00:11:14,060
approach<font color="#CCCCCC"> that we looked</font><font color="#E5E5E5"> at was block</font>

259
00:11:11,420 --> 00:11:15,979
join<font color="#E5E5E5"> now block</font>

260
00:11:14,060 --> 00:11:18,199
<font color="#CCCCCC">is a common</font><font color="#E5E5E5"> technique to address data</font>

261
00:11:15,980 --> 00:11:20,570
skew and what it does is replicate<font color="#CCCCCC"> each</font>

262
00:11:18,200 --> 00:11:23,960
<font color="#CCCCCC">of the</font><font color="#E5E5E5"> entries in one distribute data</font>

263
00:11:20,570 --> 00:11:25,640
set<font color="#E5E5E5"> across every</font><font color="#CCCCCC"> machine the hope is</font>

264
00:11:23,960 --> 00:11:28,640
<font color="#CCCCCC">that when joining</font><font color="#E5E5E5"> with the other</font>

265
00:11:25,640 --> 00:11:30,470
distributed data set the partitions will

266
00:11:28,640 --> 00:11:33,260
<font color="#CCCCCC">be more evenly spread across</font><font color="#E5E5E5"> the</font>

267
00:11:30,470 --> 00:11:34,430
machines and what we end<font color="#E5E5E5"> up with is a</font>

268
00:11:33,260 --> 00:11:35,890
<font color="#CCCCCC">join</font><font color="#E5E5E5"> table that looks something like</font>

269
00:11:34,430 --> 00:11:38,930
this

270
00:11:35,890 --> 00:11:42,170
now at first<font color="#E5E5E5"> glance this table looks</font>

271
00:11:38,930 --> 00:11:44,900
quite large<font color="#E5E5E5"> and indeed it is</font><font color="#CCCCCC"> borrowing</font>

272
00:11:42,170 --> 00:11:47,479
has performed actually n plus 1 times

273
00:11:44,900 --> 00:11:49,550
<font color="#E5E5E5">the number of partition replications</font><font color="#CCCCCC"> and</font>

274
00:11:47,480 --> 00:11:55,040
recall that<font color="#CCCCCC"> n plus</font><font color="#E5E5E5"> 1 here is in the</font>

275
00:11:49,550 --> 00:11:57,740
<font color="#E5E5E5">billions so every partition is dense and</font>

276
00:11:55,040 --> 00:12:00,230
so we could say<font color="#CCCCCC"> that</font><font color="#E5E5E5"> may hey maybe the</font>

277
00:11:57,740 --> 00:12:02,690
computation is uniform<font color="#CCCCCC"> that's that's</font>

278
00:12:00,230 --> 00:12:06,170
<font color="#E5E5E5">actually true but the table is also now</font>

279
00:12:02,690 --> 00:12:08,600
huge and impractical<font color="#E5E5E5"> to compute so this</font>

280
00:12:06,170 --> 00:12:10,459
<font color="#E5E5E5">doesn't work</font><font color="#CCCCCC"> for our system and so we</font>

281
00:12:08,600 --> 00:12:13,670
<font color="#CCCCCC">turn to other off-the-shelf approaches</font>

282
00:12:10,460 --> 00:12:17,290
and looked at them as well<font color="#E5E5E5"> namely one is</font>

283
00:12:13,670 --> 00:12:19,490
a system approach called skew<font color="#CCCCCC"> joy</font><font color="#E5E5E5"> and</font>

284
00:12:17,290 --> 00:12:22,670
<font color="#CCCCCC">skew what's</font><font color="#E5E5E5"> you skew</font><font color="#CCCCCC"> Joanne</font><font color="#E5E5E5"> we</font>

285
00:12:19,490 --> 00:12:24,140
benchmarked<font color="#E5E5E5"> this and we see that Co</font>

286
00:12:22,670 --> 00:12:26,240
<font color="#CCCCCC">train basically is</font><font color="#E5E5E5"> trying to take a more</font>

287
00:12:24,140 --> 00:12:29,240
<font color="#CCCCCC">fine-grained approach</font><font color="#E5E5E5"> what it does is</font>

288
00:12:26,240 --> 00:12:32,210
<font color="#CCCCCC">first compute usage statistics</font><font color="#E5E5E5"> and only</font>

289
00:12:29,240 --> 00:12:34,700
then replicate<font color="#E5E5E5"> frequently used entries</font>

290
00:12:32,210 --> 00:12:37,460
for<font color="#CCCCCC"> every machine this sounds more</font>

291
00:12:34,700 --> 00:12:40,730
<font color="#E5E5E5">reasonable and indeed in most cases it</font>

292
00:12:37,460 --> 00:12:42,500
<font color="#E5E5E5">really is however for our system it</font>

293
00:12:40,730 --> 00:12:47,360
turns out<font color="#E5E5E5"> this provides us minimal</font>

294
00:12:42,500 --> 00:12:49,790
advantage and let's see why so if<font color="#E5E5E5"> our</font>

295
00:12:47,360 --> 00:12:51,470
matrix a is partitioned<font color="#CCCCCC"> row wise and we</font>

296
00:12:49,790 --> 00:12:54,380
perform a skew<font color="#CCCCCC"> join operation with</font>

297
00:12:51,470 --> 00:12:56,570
vector Z we see that<font color="#E5E5E5"> each partition only</font>

298
00:12:54,380 --> 00:12:59,660
needs access<font color="#E5E5E5"> to one unique element from</font>

299
00:12:56,570 --> 00:13:01,880
the<font color="#CCCCCC"> vector</font><font color="#E5E5E5"> Z in this case it turns out</font>

300
00:12:59,660 --> 00:13:03,469
actually<font color="#E5E5E5"> that skew joint is functionally</font>

301
00:13:01,880 --> 00:13:08,840
<font color="#CCCCCC">equivalent to that straumann approach we</font>

302
00:13:03,470 --> 00:13:11,330
saw earlier<font color="#E5E5E5"> and if our matrix a is now</font>

303
00:13:08,840 --> 00:13:14,270
<font color="#E5E5E5">partitioned column wise and we perform a</font>

304
00:13:11,330 --> 00:13:17,270
skew joint with vector Z we see that

305
00:13:14,270 --> 00:13:20,240
<font color="#E5E5E5">each partition now needs access to every</font>

306
00:13:17,270 --> 00:13:23,180
unique element from the<font color="#CCCCCC"> vector</font><font color="#E5E5E5"> Z and in</font>

307
00:13:20,240 --> 00:13:26,120
this case no matter<font color="#E5E5E5"> no matter how we</font>

308
00:13:23,180 --> 00:13:27,800
organize<font color="#E5E5E5"> our</font><font color="#CCCCCC"> data here the</font><font color="#E5E5E5"> off-the-shelf</font>

309
00:13:26,120 --> 00:13:29,269
approach will cause<font color="#E5E5E5"> unnecessary</font>

310
00:13:27,800 --> 00:13:31,069
<font color="#CCCCCC">occasions that blow up our memory</font><font color="#E5E5E5"> cost</font>

311
00:13:29,269 --> 00:13:34,339
requirements<font color="#E5E5E5"> making it possible to scale</font>

312
00:13:31,070 --> 00:13:36,320
the<font color="#CCCCCC"> system and if</font><font color="#E5E5E5"> you</font><font color="#CCCCCC"> observe here</font><font color="#E5E5E5"> this</font>

313
00:13:34,339 --> 00:13:40,190
is<font color="#E5E5E5"> actually equivalent to blood showing</font>

314
00:13:36,320 --> 00:13:41,899
<font color="#CCCCCC">from earlier so in</font><font color="#E5E5E5"> fact we found that</font>

315
00:13:40,190 --> 00:13:44,810
<font color="#E5E5E5">the foregoing</font><font color="#CCCCCC"> sujin approach does not</font>

316
00:13:41,899 --> 00:13:48,470
<font color="#E5E5E5">scale beyond 50 million constraints even</font>

317
00:13:44,810 --> 00:13:50,959
<font color="#CCCCCC">on 128 machines</font><font color="#E5E5E5"> and until then it's</font>

318
00:13:48,470 --> 00:13:55,040
actually<font color="#E5E5E5"> twice as slow as our tailored</font>

319
00:13:50,959 --> 00:13:56,300
approach which<font color="#E5E5E5"> I will now describe so we</font>

320
00:13:55,040 --> 00:13:57,980
designed and implemented a tailored

321
00:13:56,300 --> 00:14:00,589
approach to evaluate our witness

322
00:13:57,980 --> 00:14:03,560
reduction<font color="#E5E5E5"> and the approach we took was</font>

323
00:14:00,589 --> 00:14:05,120
<font color="#CCCCCC">to isolate</font><font color="#E5E5E5"> and transform the data so</font>

324
00:14:03,560 --> 00:14:07,760
that<font color="#CCCCCC"> the computation is distributed</font>

325
00:14:05,120 --> 00:14:11,149
<font color="#E5E5E5">evenly let me show you at a high</font><font color="#CCCCCC"> level</font>

326
00:14:07,760 --> 00:14:13,939
<font color="#CCCCCC">how we do this</font><font color="#E5E5E5"> so we start with an</font>

327
00:14:11,149 --> 00:14:16,310
almost sparse matrix a from before<font color="#E5E5E5"> and</font>

328
00:14:13,940 --> 00:14:18,769
perform a pre-processing step<font color="#CCCCCC"> whereby we</font>

329
00:14:16,310 --> 00:14:22,579
compute the density count for<font color="#E5E5E5"> each</font>

330
00:14:18,769 --> 00:14:26,269
partition<font color="#E5E5E5"> now to</font><font color="#CCCCCC"> perform the join</font>

331
00:14:22,579 --> 00:14:28,760
operation between<font color="#CCCCCC"> matrix a and vector</font><font color="#E5E5E5"> Z</font>

332
00:14:26,269 --> 00:14:30,709
we perform what we<font color="#E5E5E5"> call a hybrid joint</font>

333
00:14:28,760 --> 00:14:33,380
which replicates<font color="#CCCCCC"> only a handful of</font>

334
00:14:30,709 --> 00:14:36,560
unique elements<font color="#CCCCCC"> from vector Z as we set</font>

335
00:14:33,380 --> 00:14:40,550
our matrix<font color="#E5E5E5"> a is almost sparse and so in</font>

336
00:14:36,560 --> 00:14:43,130
this case<font color="#E5E5E5"> we need</font><font color="#CCCCCC"> to split our dense</font>

337
00:14:40,550 --> 00:14:45,020
vector<font color="#E5E5E5"> into sparse partitions and from</font>

338
00:14:43,130 --> 00:14:47,260
there we<font color="#E5E5E5"> will perform our hybrid join</font>

339
00:14:45,020 --> 00:14:49,880
with all the individual<font color="#CCCCCC"> elements</font>

340
00:14:47,260 --> 00:14:53,959
connected<font color="#CCCCCC"> to their respective</font><font color="#E5E5E5"> partitions</font>

341
00:14:49,880 --> 00:14:57,860
here notice<font color="#CCCCCC"> that each partition</font><font color="#E5E5E5"> has just</font>

342
00:14:53,959 --> 00:14:59,270
one nonzero computation<font color="#CCCCCC"> in this case</font>

343
00:14:57,860 --> 00:15:00,709
that<font color="#E5E5E5"> means that we just have one dense</font>

344
00:14:59,270 --> 00:15:04,189
computation to perform in each of these

345
00:15:00,709 --> 00:15:07,010
partitions<font color="#CCCCCC"> and as our replication factor</font>

346
00:15:04,190 --> 00:15:08,630
was minimal<font color="#E5E5E5"> because our approach itself</font>

347
00:15:07,010 --> 00:15:11,120
was able to preserve<font color="#E5E5E5"> the almost sparse</font>

348
00:15:08,630 --> 00:15:13,610
<font color="#CCCCCC">structural representation of matrix a we</font>

349
00:15:11,120 --> 00:15:16,100
find that this enables<font color="#E5E5E5"> us</font><font color="#CCCCCC"> to join our</font>

350
00:15:13,610 --> 00:15:19,790
data to<font color="#E5E5E5"> compute the summations from</font>

351
00:15:16,100 --> 00:15:21,290
before without stragglers<font color="#CCCCCC"> in practice</font>

352
00:15:19,790 --> 00:15:22,730
for<font color="#E5E5E5"> the same number of machines we find</font>

353
00:15:21,290 --> 00:15:24,500
that our tailored approach now enables

354
00:15:22,730 --> 00:15:27,220
us<font color="#CCCCCC"> to reach</font><font color="#E5E5E5"> billions of gates where</font>

355
00:15:24,500 --> 00:15:30,589
off-the-shelf approaches kept us in the

356
00:15:27,220 --> 00:15:32,540
<font color="#E5E5E5">kept us in the millions of gates and so</font>

357
00:15:30,589 --> 00:15:33,800
along<font color="#CCCCCC"> with the other distributes of</font>

358
00:15:32,540 --> 00:15:36,079
components we described in this paper

359
00:15:33,800 --> 00:15:37,880
<font color="#CCCCCC">we're able</font><font color="#E5E5E5"> to architect a zero knowledge</font>

360
00:15:36,079 --> 00:15:41,270
proof system<font color="#E5E5E5"> that is scalable</font><font color="#CCCCCC"> and</font>

361
00:15:37,880 --> 00:15:44,210
parallel so<font color="#E5E5E5"> being</font>

362
00:15:41,270 --> 00:15:48,020
the system and we used a cluster compute

363
00:15:44,210 --> 00:15:49,490
framework<font color="#CCCCCC"> apache spark</font><font color="#E5E5E5"> our system is</font>

364
00:15:48,020 --> 00:15:52,819
written in<font color="#CCCCCC"> java</font><font color="#E5E5E5"> with approximately</font>

365
00:15:49,490 --> 00:15:56,780
<font color="#E5E5E5">10,000 lines of code</font><font color="#CCCCCC"> and we ran our</font>

366
00:15:52,820 --> 00:15:58,780
insects parents on<font color="#CCCCCC"> amazon ec2</font><font color="#E5E5E5"> and using</font>

367
00:15:56,780 --> 00:16:00,770
<font color="#E5E5E5">our three edx large instances</font><font color="#CCCCCC"> our</font>

368
00:15:58,780 --> 00:16:03,350
<font color="#CCCCCC">evaluations show us some interesting</font>

369
00:16:00,770 --> 00:16:06,530
patterns<font color="#E5E5E5"> and properties which i will now</font>

370
00:16:03,350 --> 00:16:10,310
<font color="#CCCCCC">present first</font><font color="#E5E5E5"> we evaluated by system on</font>

371
00:16:06,530 --> 00:16:12,560
the largest<font color="#E5E5E5"> supported circuit size so</font>

372
00:16:10,310 --> 00:16:13,609
when we profiled a lip snark<font color="#CCCCCC"> in our</font>

373
00:16:12,560 --> 00:16:16,609
<font color="#E5E5E5">environment</font>

374
00:16:13,610 --> 00:16:19,490
we found that<font color="#E5E5E5"> it reaches approximately 4</font>

375
00:16:16,610 --> 00:16:22,280
million gates<font color="#E5E5E5"> and when we profile physic</font>

376
00:16:19,490 --> 00:16:24,590
across different numbers<font color="#CCCCCC"> of machines for</font>

377
00:16:22,280 --> 00:16:26,120
<font color="#CCCCCC">the same environment we found</font><font color="#E5E5E5"> that we</font>

378
00:16:24,590 --> 00:16:32,360
<font color="#E5E5E5">were able</font><font color="#CCCCCC"> to reach approximately 2</font>

379
00:16:26,120 --> 00:16:35,650
billion gates<font color="#E5E5E5"> with 256 machines the</font>

380
00:16:32,360 --> 00:16:38,600
pattern<font color="#E5E5E5"> that we see here is that as we</font>

381
00:16:35,650 --> 00:16:39,920
double the<font color="#CCCCCC"> number of machines</font><font color="#E5E5E5"> were able</font>

382
00:16:38,600 --> 00:16:43,570
to<font color="#E5E5E5"> support</font><font color="#CCCCCC"> approximately</font><font color="#E5E5E5"> twice the</font>

383
00:16:39,920 --> 00:16:47,449
<font color="#E5E5E5">circuit size this then led us to ask</font>

384
00:16:43,570 --> 00:16:49,250
could we compute<font color="#E5E5E5"> up to these large</font>

385
00:16:47,450 --> 00:16:52,100
<font color="#E5E5E5">circuit sizes in a time efficient manner</font>

386
00:16:49,250 --> 00:16:54,770
<font color="#E5E5E5">and so we have here two graphs that</font>

387
00:16:52,100 --> 00:16:56,480
demonstrate<font color="#E5E5E5"> a scalability so on the Left</font>

388
00:16:54,770 --> 00:16:58,310
graph we have the<font color="#CCCCCC"> distributed</font><font color="#E5E5E5"> set up and</font>

389
00:16:56,480 --> 00:17:00,950
on<font color="#CCCCCC"> the right graph we have the</font>

390
00:16:58,310 --> 00:17:05,359
distributed<font color="#E5E5E5"> proved</font><font color="#CCCCCC"> er note</font><font color="#E5E5E5"> that this is</font>

391
00:17:00,950 --> 00:17:08,780
a log-log graph and if we follow<font color="#E5E5E5"> the</font>

392
00:17:05,359 --> 00:17:11,810
line for 256 machines<font color="#E5E5E5"> we see that the</font>

393
00:17:08,780 --> 00:17:13,430
<font color="#E5E5E5">slope is actually approximately 1 and so</font>

394
00:17:11,810 --> 00:17:16,369
the pattern<font color="#CCCCCC"> that we see is that as we</font>

395
00:17:13,430 --> 00:17:20,000
double the circuit size<font color="#E5E5E5"> we're able to to</font>

396
00:17:16,369 --> 00:17:21,819
generate<font color="#E5E5E5"> our proof and learn and run our</font>

397
00:17:20,000 --> 00:17:24,170
<font color="#E5E5E5">set up at approximately twice the time</font>

398
00:17:21,819 --> 00:17:28,580
<font color="#CCCCCC">this is a good</font><font color="#E5E5E5"> demonstration that our</font>

399
00:17:24,170 --> 00:17:31,400
system here is indeed<font color="#E5E5E5"> scalable and here</font>

400
00:17:28,580 --> 00:17:33,620
again<font color="#E5E5E5"> we plot the same data</font><font color="#CCCCCC"> but</font><font color="#E5E5E5"> now we</font>

401
00:17:31,400 --> 00:17:36,710
show them machines on the<font color="#CCCCCC"> x axis</font><font color="#E5E5E5"> and</font>

402
00:17:33,620 --> 00:17:38,479
plot the circuit size on the<font color="#E5E5E5"> left</font><font color="#CCCCCC"> again</font>

403
00:17:36,710 --> 00:17:40,010
<font color="#CCCCCC">you see the distributes set up</font><font color="#E5E5E5"> and on</font>

404
00:17:38,480 --> 00:17:42,230
<font color="#E5E5E5">the right you see the distribute prove</font>

405
00:17:40,010 --> 00:17:45,410
<font color="#CCCCCC">err and</font><font color="#E5E5E5"> if we follow this particular</font>

406
00:17:42,230 --> 00:17:46,640
<font color="#E5E5E5">line</font><font color="#CCCCCC"> here at</font><font color="#E5E5E5"> 2 to the 26</font><font color="#CCCCCC"> the patterning</font>

407
00:17:45,410 --> 00:17:49,010
<font color="#E5E5E5">that we see here is that as we double</font>

408
00:17:46,640 --> 00:17:50,240
the<font color="#CCCCCC"> number of machines we're able to run</font>

409
00:17:49,010 --> 00:17:55,190
our proof generation at<font color="#CCCCCC"> approximately</font>

410
00:17:50,240 --> 00:17:57,170
<font color="#CCCCCC">twice as fast so it</font>

411
00:17:55,190 --> 00:18:00,220
conclusion we found that<font color="#E5E5E5"> prior easy case</font>

412
00:17:57,170 --> 00:18:03,230
<font color="#E5E5E5">narcs</font><font color="#CCCCCC"> support maximum circuit sizes of</font>

413
00:18:00,220 --> 00:18:05,090
<font color="#E5E5E5">approximately millions of gates</font><font color="#CCCCCC"> at an</font>

414
00:18:03,230 --> 00:18:07,520
amortized cost per gate of about one

415
00:18:05,090 --> 00:18:09,199
millisecond<font color="#E5E5E5"> and we find with our</font>

416
00:18:07,520 --> 00:18:11,120
<font color="#E5E5E5">techniques that</font><font color="#CCCCCC"> Disick is able to</font>

417
00:18:09,200 --> 00:18:13,100
support<font color="#E5E5E5"> a maximum circuit size in the</font>

418
00:18:11,120 --> 00:18:16,669
billions<font color="#E5E5E5"> of gates at an amortized cost</font>

419
00:18:13,100 --> 00:18:18,980
<font color="#E5E5E5">per gate of</font><font color="#CCCCCC"> 10 microseconds the full</font>

420
00:18:16,670 --> 00:18:21,650
paper is<font color="#E5E5E5"> available on crypto</font><font color="#CCCCCC"> you print</font>

421
00:18:18,980 --> 00:18:23,750
<font color="#E5E5E5">and I'm proud</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> say</font><font color="#CCCCCC"> that we have</font>

422
00:18:21,650 --> 00:18:26,930
released<font color="#CCCCCC"> dessert</font><font color="#E5E5E5"> as an</font><font color="#CCCCCC"> open-source</font>

423
00:18:23,750 --> 00:18:29,510
<font color="#CCCCCC">library on github you can find it by</font>

424
00:18:26,930 --> 00:18:30,500
going<font color="#CCCCCC"> to</font><font color="#E5E5E5"> digit org and we've put a lot</font>

425
00:18:29,510 --> 00:18:32,090
of hard<font color="#CCCCCC"> work into making this library</font>

426
00:18:30,500 --> 00:18:34,520
<font color="#CCCCCC">available to the public with a</font>

427
00:18:32,090 --> 00:18:36,199
convenient profiling infrastructure so

428
00:18:34,520 --> 00:18:37,280
that<font color="#CCCCCC"> you can replicate our results as</font>

429
00:18:36,200 --> 00:18:40,640
well<font color="#E5E5E5"> as build new and interesting</font>

430
00:18:37,280 --> 00:18:41,930
applications using<font color="#CCCCCC"> disick</font><font color="#E5E5E5"> lastly I would</font>

431
00:18:40,640 --> 00:18:45,770
<font color="#CCCCCC">like to leave you with</font><font color="#E5E5E5"> two open</font>

432
00:18:41,930 --> 00:18:48,290
questions<font color="#CCCCCC"> and</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> first is with regards</font>

433
00:18:45,770 --> 00:18:50,500
to even<font color="#E5E5E5"> larger circuits what techniques</font>

434
00:18:48,290 --> 00:18:53,360
will get us<font color="#CCCCCC"> to trillions</font><font color="#E5E5E5"> of gates if any</font>

435
00:18:50,500 --> 00:18:54,800
<font color="#E5E5E5">with our current techniques</font><font color="#CCCCCC"> we would</font>

436
00:18:53,360 --> 00:18:56,899
need approximately<font color="#E5E5E5"> a</font><font color="#CCCCCC"> hundred thousand</font>

437
00:18:54,800 --> 00:19:00,200
machines<font color="#E5E5E5"> in the</font><font color="#CCCCCC"> best-case scenario</font><font color="#E5E5E5"> and</font>

438
00:18:56,900 --> 00:19:01,610
this in practice<font color="#CCCCCC"> is just too many the</font>

439
00:19:00,200 --> 00:19:02,930
second<font color="#E5E5E5"> question is with regards to</font>

440
00:19:01,610 --> 00:19:05,719
others it<font color="#E5E5E5"> seems to the knowledge groups</font>

441
00:19:02,930 --> 00:19:07,550
so how efficiently can other things

442
00:19:05,720 --> 00:19:09,710
their knowledge proofs be distributed

443
00:19:07,550 --> 00:19:11,659
our techniques<font color="#E5E5E5"> seem like an excellent</font>

444
00:19:09,710 --> 00:19:15,170
starting<font color="#CCCCCC"> point for things like Starks</font>

445
00:19:11,660 --> 00:19:17,330
and bulletproof sand etc<font color="#E5E5E5"> and with that</font>

446
00:19:15,170 --> 00:19:19,600
I'd<font color="#E5E5E5"> like</font><font color="#CCCCCC"> to conclude and thank you for</font>

447
00:19:17,330 --> 00:19:19,600
attention

