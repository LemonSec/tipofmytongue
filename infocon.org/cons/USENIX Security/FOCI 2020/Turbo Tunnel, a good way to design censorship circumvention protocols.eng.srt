1
00:00:08,800 --> 00:00:10,960
this talk is directed towards designers

2
00:00:10,960 --> 00:00:13,599
of censorship circumvention systems

3
00:00:13,599 --> 00:00:14,880
i want to convince you that you should

4
00:00:14,880 --> 00:00:16,720
include a session layer in your

5
00:00:16,720 --> 00:00:18,320
circumvention protocol stack

6
00:00:18,320 --> 00:00:20,800
separate from the obfuscation layer and

7
00:00:20,800 --> 00:00:22,480
what do i mean by that

8
00:00:22,480 --> 00:00:24,160
i think it's easiest to show by example

9
00:00:24,160 --> 00:00:26,320
so let's start by taking a step back in

10
00:00:26,320 --> 00:00:28,160
time

11
00:00:28,160 --> 00:00:30,160
back in 2013 i was presenting a system

12
00:00:30,160 --> 00:00:31,760
called oss

13
00:00:31,760 --> 00:00:33,920
and oss was based on the principle of

14
00:00:33,920 --> 00:00:35,120
smuggling information

15
00:00:35,120 --> 00:00:39,120
in http urls i was presenting this very

16
00:00:39,120 --> 00:00:40,559
visual

17
00:00:40,559 --> 00:00:43,520
which shows the structure of an oss url

18
00:00:43,520 --> 00:00:44,879
i want to call your attention the part

19
00:00:44,879 --> 00:00:46,640
highlighted in green

20
00:00:46,640 --> 00:00:49,120
that's the session identifier that's

21
00:00:49,120 --> 00:00:50,640
just a random number generated by the

22
00:00:50,640 --> 00:00:51,360
client

23
00:00:51,360 --> 00:00:54,000
and its purpose is to enable the oss

24
00:00:54,000 --> 00:00:56,559
server to disambiguate the requests

25
00:00:56,559 --> 00:00:58,960
of potentially multiple clients

26
00:00:58,960 --> 00:01:01,600
simultaneously

27
00:01:01,600 --> 00:01:03,359
another important part of the url

28
00:01:03,359 --> 00:01:04,640
structure are these sequence and

29
00:01:04,640 --> 00:01:06,159
acknowledgement numbers

30
00:01:06,159 --> 00:01:08,320
and those are there because we expect

31
00:01:08,320 --> 00:01:10,400
some non-negligible fraction of http

32
00:01:10,400 --> 00:01:11,600
requests to fail

33
00:01:11,600 --> 00:01:13,280
and when that happens there's a need to

34
00:01:13,280 --> 00:01:16,400
retransmit any lost data it's a very

35
00:01:16,400 --> 00:01:18,799
tcp like retransmission reliability

36
00:01:18,799 --> 00:01:20,880
scheme

37
00:01:20,880 --> 00:01:23,439
now oss was never very widely deployed

38
00:01:23,439 --> 00:01:25,040
and to be honest i was never

39
00:01:25,040 --> 00:01:27,200
super confident in the sequence number

40
00:01:27,200 --> 00:01:29,360
acknowledgement reliability scheme that

41
00:01:29,360 --> 00:01:30,159
i had made

42
00:01:30,159 --> 00:01:33,520
for oss i'm sure that if the system had

43
00:01:33,520 --> 00:01:35,119
been deployed more widely

44
00:01:35,119 --> 00:01:37,040
certain bugs and problems would have

45
00:01:37,040 --> 00:01:38,799
been uncovered in it just because we

46
00:01:38,799 --> 00:01:40,079
know that these types of things

47
00:01:40,079 --> 00:01:43,200
are hard to design i was not the only

48
00:01:43,200 --> 00:01:44,880
one thinking about these things

49
00:01:44,880 --> 00:01:48,000
in fact even earlier code talker tunnel

50
00:01:48,000 --> 00:01:50,960
skype morph was a system based on udp

51
00:01:50,960 --> 00:01:52,840
packets and udp is as we know

52
00:01:52,840 --> 00:01:55,439
unreliable so every code talker tunnel

53
00:01:55,439 --> 00:01:57,759
packet includes a sequence number and an

54
00:01:57,759 --> 00:01:59,280
acknowledgement number to facilitate

55
00:01:59,280 --> 00:02:02,479
re-transmission of unacknowledged data

56
00:02:02,479 --> 00:02:04,399
similarly stegotaurus a really

57
00:02:04,399 --> 00:02:06,719
innovative circumvention design

58
00:02:06,719 --> 00:02:08,239
split up an incoming stream into little

59
00:02:08,239 --> 00:02:10,318
pieces and each one of those pieces

60
00:02:10,318 --> 00:02:11,360
could be delivered

61
00:02:11,360 --> 00:02:13,520
over potentially very different cover

62
00:02:13,520 --> 00:02:15,200
channels

63
00:02:15,200 --> 00:02:16,959
every piece had a sequence number

64
00:02:16,959 --> 00:02:18,480
attached so that if they happen to

65
00:02:18,480 --> 00:02:20,239
arrive out of order the server on the

66
00:02:20,239 --> 00:02:20,879
other end

67
00:02:20,879 --> 00:02:22,640
could reorder them before delivering the

68
00:02:22,640 --> 00:02:24,800
stream

69
00:02:24,800 --> 00:02:26,640
fast forward now to the early days of

70
00:02:26,640 --> 00:02:28,720
when i was working on meek

71
00:02:28,720 --> 00:02:30,560
meek builds a bi-directional channel out

72
00:02:30,560 --> 00:02:32,400
of a sequence of http

73
00:02:32,400 --> 00:02:34,800
requests and responses and the notion of

74
00:02:34,800 --> 00:02:35,680
a session

75
00:02:35,680 --> 00:02:38,480
is baked very deeply into meek you can

76
00:02:38,480 --> 00:02:40,080
see here there's a header field

77
00:02:40,080 --> 00:02:42,239
x session id that contains a session

78
00:02:42,239 --> 00:02:44,959
identifier

79
00:02:45,120 --> 00:02:47,840
now one of the challenges of building a

80
00:02:47,840 --> 00:02:49,519
system on top of http

81
00:02:49,519 --> 00:02:53,040
is that the order of simultaneous http

82
00:02:53,040 --> 00:02:55,040
requests is not guaranteed

83
00:02:55,040 --> 00:02:56,640
so for a long time i was thinking about

84
00:02:56,640 --> 00:02:58,959
oss thinking about sequence numbers and

85
00:02:58,959 --> 00:03:00,159
acknowledgments

86
00:03:00,159 --> 00:03:01,680
thinking that i would need something

87
00:03:01,680 --> 00:03:04,800
like this for meek

88
00:03:04,800 --> 00:03:06,640
now i knew that meek was going to be big

89
00:03:06,640 --> 00:03:07,920
and i knew it was something that i

90
00:03:07,920 --> 00:03:10,480
wanted to deploy for real

91
00:03:10,480 --> 00:03:12,480
so more than anything i knew i needed

92
00:03:12,480 --> 00:03:13,920
something that was practical and

93
00:03:13,920 --> 00:03:14,720
deployable

94
00:03:14,720 --> 00:03:16,720
and i was never confident enough in what

95
00:03:16,720 --> 00:03:18,239
i had done for oss

96
00:03:18,239 --> 00:03:21,360
for that to be true so in the end what i

97
00:03:21,360 --> 00:03:22,560
ended up doing for meek

98
00:03:22,560 --> 00:03:25,120
is very simple i designed the system so

99
00:03:25,120 --> 00:03:26,720
that there could never be more than one

100
00:03:26,720 --> 00:03:29,040
request outstanding at a time

101
00:03:29,040 --> 00:03:30,959
no simultaneous request means there's no

102
00:03:30,959 --> 00:03:32,159
question of

103
00:03:32,159 --> 00:03:35,920
misordering but even then i knew that

104
00:03:35,920 --> 00:03:38,480
there was a right way to do this sort of

105
00:03:38,480 --> 00:03:39,360
thing

106
00:03:39,360 --> 00:03:41,920
and it was just a matter of putting in

107
00:03:41,920 --> 00:03:42,480
the work

108
00:03:42,480 --> 00:03:46,080
necessary to realize it

109
00:03:46,080 --> 00:03:47,680
now coming closer to the present i have

110
00:03:47,680 --> 00:03:49,200
been helping develop the

111
00:03:49,200 --> 00:03:51,920
snowflake circumvention system snowflake

112
00:03:51,920 --> 00:03:53,439
is based on the use of temporary

113
00:03:53,439 --> 00:03:54,879
browser-based proxies

114
00:03:54,879 --> 00:03:56,400
when you use snowflake your traffic is

115
00:03:56,400 --> 00:03:57,920
actually going through someone else's

116
00:03:57,920 --> 00:03:59,599
web browser

117
00:03:59,599 --> 00:04:01,280
one of the problems with snowflake until

118
00:04:01,280 --> 00:04:03,840
recently is that your entire browsing

119
00:04:03,840 --> 00:04:06,080
session was coupled very tightly to the

120
00:04:06,080 --> 00:04:07,280
first

121
00:04:07,280 --> 00:04:09,760
temporary proxy that you were assigned

122
00:04:09,760 --> 00:04:11,599
so you would start a browsing session

123
00:04:11,599 --> 00:04:14,080
you would start using a proxy and these

124
00:04:14,080 --> 00:04:14,720
proxies

125
00:04:14,720 --> 00:04:16,560
are by nature temporary they don't stick

126
00:04:16,560 --> 00:04:17,759
around forever

127
00:04:17,759 --> 00:04:19,918
and when that proxy stopped working your

128
00:04:19,918 --> 00:04:20,798
session would just

129
00:04:20,798 --> 00:04:22,880
end and you would have no recourse but

130
00:04:22,880 --> 00:04:25,919
to restart the snowflake software

131
00:04:25,919 --> 00:04:27,600
what was missing is some idea of a

132
00:04:27,600 --> 00:04:30,400
session independent of any single

133
00:04:30,400 --> 00:04:33,040
proxy connection and by now i had seen

134
00:04:33,040 --> 00:04:34,720
this pattern recur enough times that i

135
00:04:34,720 --> 00:04:35,759
knew

136
00:04:35,759 --> 00:04:38,160
there is a right way to do this we need

137
00:04:38,160 --> 00:04:39,680
some sort of interior session

138
00:04:39,680 --> 00:04:41,440
reliability protocol

139
00:04:41,440 --> 00:04:42,960
rather than just transmitting raw

140
00:04:42,960 --> 00:04:45,120
unstructured chunks of an underlying

141
00:04:45,120 --> 00:04:47,360
stream through these proxies

142
00:04:47,360 --> 00:04:49,759
so it was about a year ago i decided

143
00:04:49,759 --> 00:04:50,960
enough is enough

144
00:04:50,960 --> 00:04:53,280
let's sit down figure it out and do this

145
00:04:53,280 --> 00:04:55,520
right

146
00:04:55,759 --> 00:04:57,360
so that's what i've been working on for

147
00:04:57,360 --> 00:04:59,600
about the past year in a project i call

148
00:04:59,600 --> 00:05:00,880
turbo tunnel

149
00:05:00,880 --> 00:05:02,880
turbo tunnel is just my name for this

150
00:05:02,880 --> 00:05:04,320
design pattern of

151
00:05:04,320 --> 00:05:05,919
incorporating a session slash

152
00:05:05,919 --> 00:05:07,759
reliability layer in the middle of a

153
00:05:07,759 --> 00:05:10,240
circumvention protocol stack

154
00:05:10,240 --> 00:05:12,000
if you adopt the design you're under no

155
00:05:12,000 --> 00:05:14,400
obligation to also adopt the name

156
00:05:14,400 --> 00:05:16,320
i just find it's useful to have a label

157
00:05:16,320 --> 00:05:19,919
to discuss things like this

158
00:05:19,919 --> 00:05:21,280
now in a typical contemporary

159
00:05:21,280 --> 00:05:23,280
circumvention system you receive a bunch

160
00:05:23,280 --> 00:05:24,479
of user streams

161
00:05:24,479 --> 00:05:26,800
perhaps over socks and you pass those

162
00:05:26,800 --> 00:05:27,840
into some

163
00:05:27,840 --> 00:05:29,680
circumvention layer and then that

164
00:05:29,680 --> 00:05:31,680
circumvention layer transforms them in a

165
00:05:31,680 --> 00:05:33,440
way such that they won't get blocked by

166
00:05:33,440 --> 00:05:34,880
a sensor

167
00:05:34,880 --> 00:05:36,560
in a turbo tunnel design there's an

168
00:05:36,560 --> 00:05:38,080
additional design element

169
00:05:38,080 --> 00:05:40,000
an additional protocol layer that

170
00:05:40,000 --> 00:05:42,639
session slash reliability layer

171
00:05:42,639 --> 00:05:44,880
that is what receives the user streams

172
00:05:44,880 --> 00:05:46,320
and it takes those streams

173
00:05:46,320 --> 00:05:48,320
and breaks them up into packets it

174
00:05:48,320 --> 00:05:49,680
attaches sequence numbers

175
00:05:49,680 --> 00:05:51,280
it handles things like timeouts and

176
00:05:51,280 --> 00:05:52,880
re-transmissions

177
00:05:52,880 --> 00:05:55,199
and then it passes those packets into

178
00:05:55,199 --> 00:05:57,360
the obfuscation layer

179
00:05:57,360 --> 00:05:58,479
the obfuscation layer's only

180
00:05:58,479 --> 00:05:59,840
responsibilities to deliver those

181
00:05:59,840 --> 00:06:01,280
packets in a way that doesn't get

182
00:06:01,280 --> 00:06:04,000
blocked by the sensor

183
00:06:04,000 --> 00:06:05,440
it's worth thinking about this handoff

184
00:06:05,440 --> 00:06:06,880
between the session layer and the

185
00:06:06,880 --> 00:06:08,000
obfuscation layer

186
00:06:08,000 --> 00:06:10,639
which i call encapsulation you're

187
00:06:10,639 --> 00:06:13,759
fundamentally transmitting packets now

188
00:06:13,759 --> 00:06:15,759
your obfuscation channel however may not

189
00:06:15,759 --> 00:06:17,840
even be packet based it may be stream

190
00:06:17,840 --> 00:06:18,639
based

191
00:06:18,639 --> 00:06:20,479
and in that case you need to encode the

192
00:06:20,479 --> 00:06:22,080
packets in a way such that the packet

193
00:06:22,080 --> 00:06:22,800
boundaries

194
00:06:22,800 --> 00:06:25,840
can be recovered at the other end even

195
00:06:25,840 --> 00:06:26,319
if your

196
00:06:26,319 --> 00:06:28,639
obfuscation channel is packet-based you

197
00:06:28,639 --> 00:06:30,800
may not want a one-to-one correspondence

198
00:06:30,800 --> 00:06:32,240
between session layer packets

199
00:06:32,240 --> 00:06:35,680
and obfuscation layer packets in general

200
00:06:35,680 --> 00:06:37,280
adopting a turbo tunnel design

201
00:06:37,280 --> 00:06:38,800
may increase your system's

202
00:06:38,800 --> 00:06:40,319
susceptibility to certain forms of

203
00:06:40,319 --> 00:06:42,080
traffic analysis attack because

204
00:06:42,080 --> 00:06:43,759
you're imposing structure that wasn't

205
00:06:43,759 --> 00:06:46,080
there now you're now transmitting

206
00:06:46,080 --> 00:06:49,440
encapsulated packets so it's worth

207
00:06:49,440 --> 00:06:51,199
thinking about doing things like

208
00:06:51,199 --> 00:06:53,840
adding padding or adding timing delays

209
00:06:53,840 --> 00:06:55,440
or doing other things to

210
00:06:55,440 --> 00:06:57,440
break up your protocol signature in

211
00:06:57,440 --> 00:06:59,840
order to resist these types of attacks

212
00:06:59,840 --> 00:07:01,440
although i admit i haven't investigated

213
00:07:01,440 --> 00:07:03,919
very far in that direction

214
00:07:03,919 --> 00:07:05,440
and speaking of the session slash

215
00:07:05,440 --> 00:07:07,039
reliability protocol

216
00:07:07,039 --> 00:07:08,639
there's no need to invent something new

217
00:07:08,639 --> 00:07:11,199
here good third-party libraries exist to

218
00:07:11,199 --> 00:07:12,880
do this sort of thing and you can more

219
00:07:12,880 --> 00:07:14,160
or less just plug them

220
00:07:14,160 --> 00:07:17,120
into an existing design i've listed two

221
00:07:17,120 --> 00:07:17,440
here

222
00:07:17,440 --> 00:07:20,080
kcpgo and quick go these are the two

223
00:07:20,080 --> 00:07:21,759
that i've prototyped with extensively

224
00:07:21,759 --> 00:07:23,039
over the past year

225
00:07:23,039 --> 00:07:25,039
i'm sure there are others but the

226
00:07:25,039 --> 00:07:26,639
crucial feature of these two libraries

227
00:07:26,639 --> 00:07:28,240
is that they don't send their own

228
00:07:28,240 --> 00:07:29,360
network packets

229
00:07:29,360 --> 00:07:31,280
whenever they need to send or receive a

230
00:07:31,280 --> 00:07:33,120
packet or do any other sort of network

231
00:07:33,120 --> 00:07:34,400
interaction

232
00:07:34,400 --> 00:07:36,880
they call into your application which

233
00:07:36,880 --> 00:07:38,560
gives you an opportunity to obfuscate

234
00:07:38,560 --> 00:07:39,599
the packets

235
00:07:39,599 --> 00:07:41,599
in whatever way is appropriate for your

236
00:07:41,599 --> 00:07:44,960
circumvention system

237
00:07:44,960 --> 00:07:46,560
my way of developing the turbo tunnel

238
00:07:46,560 --> 00:07:48,319
idea has been to implement it in a

239
00:07:48,319 --> 00:07:50,479
variety of circumvention systems

240
00:07:50,479 --> 00:07:53,360
so i did it in ops 4 in meek in

241
00:07:53,360 --> 00:07:54,080
snowflake

242
00:07:54,080 --> 00:07:56,639
and in a new dns tunnel that can do dns

243
00:07:56,639 --> 00:07:58,720
over https

244
00:07:58,720 --> 00:08:00,400
meek and snowflake we've talked about so

245
00:08:00,400 --> 00:08:02,479
in meek the turbo tunnel design enables

246
00:08:02,479 --> 00:08:04,000
the client to send data whenever it

247
00:08:04,000 --> 00:08:04,800
wants

248
00:08:04,800 --> 00:08:06,560
without having to wait for a response to

249
00:08:06,560 --> 00:08:08,879
its previous requests

250
00:08:08,879 --> 00:08:11,199
in snowflake it enables a session to

251
00:08:11,199 --> 00:08:12,080
migrate across

252
00:08:12,080 --> 00:08:15,280
multiple temporary proxy connections

253
00:08:15,280 --> 00:08:17,440
and in fact the snowflake implementation

254
00:08:17,440 --> 00:08:19,280
has been merged into mainline and if you

255
00:08:19,280 --> 00:08:20,800
download tor browser now

256
00:08:20,800 --> 00:08:22,639
and turn on the snowflake option you

257
00:08:22,639 --> 00:08:24,240
will be getting this turbo tunnel

258
00:08:24,240 --> 00:08:25,599
enabled snowflake

259
00:08:25,599 --> 00:08:27,520
it's been a really big benefit for

260
00:08:27,520 --> 00:08:29,840
usability

261
00:08:29,840 --> 00:08:31,599
a dns tunnel it should be pretty clear

262
00:08:31,599 --> 00:08:33,599
dns is based on udp

263
00:08:33,599 --> 00:08:35,839
udp is unreliable so you need some sort

264
00:08:35,839 --> 00:08:37,760
of reliability layer

265
00:08:37,760 --> 00:08:39,839
rather than inventing something custom

266
00:08:39,839 --> 00:08:41,839
purely for a dns tunnel you can use

267
00:08:41,839 --> 00:08:44,480
one of these existing session protocol

268
00:08:44,480 --> 00:08:46,560
libraries

269
00:08:46,560 --> 00:08:48,640
and finally you may be asking yourself

270
00:08:48,640 --> 00:08:50,160
why would you need a session and

271
00:08:50,160 --> 00:08:52,959
reliability protocol for ops 4. ops 4 is

272
00:08:52,959 --> 00:08:54,800
already based on the use of tcp

273
00:08:54,800 --> 00:08:56,800
which is already a reliable inorder

274
00:08:56,800 --> 00:08:58,240
protocol

275
00:08:58,240 --> 00:08:59,760
well the answer to that is that ops 4 is

276
00:08:59,760 --> 00:09:03,120
vulnerable to tcp termination attacks

277
00:09:03,120 --> 00:09:05,519
a sensor can reset a tcp connection and

278
00:09:05,519 --> 00:09:06,640
that tears down the whole

279
00:09:06,640 --> 00:09:09,120
ops 4 connection and all the session

280
00:09:09,120 --> 00:09:11,120
state attached to it so any ongoing

281
00:09:11,120 --> 00:09:12,800
downloads you had going on

282
00:09:12,800 --> 00:09:15,519
are all terminated the turbo tunnel

283
00:09:15,519 --> 00:09:16,880
version of ops 4

284
00:09:16,880 --> 00:09:19,680
is resistant to tcp termination attacks

285
00:09:19,680 --> 00:09:21,200
because it has a notion of a session

286
00:09:21,200 --> 00:09:23,440
that is independent of any one

287
00:09:23,440 --> 00:09:25,839
tcp connection so when one tcp

288
00:09:25,839 --> 00:09:27,279
connection gets terminated

289
00:09:27,279 --> 00:09:28,959
you can start a new one and resume the

290
00:09:28,959 --> 00:09:30,959
session on that new connection as if

291
00:09:30,959 --> 00:09:33,839
nothing had happened

292
00:09:33,839 --> 00:09:36,399
now i'm not going to claim that this is

293
00:09:36,399 --> 00:09:37,680
the right

294
00:09:37,680 --> 00:09:40,000
or the only way to design a

295
00:09:40,000 --> 00:09:41,760
circumvention system

296
00:09:41,760 --> 00:09:43,279
but this is how i'm planning to design

297
00:09:43,279 --> 00:09:46,240
my circumvention systems in the future

298
00:09:46,240 --> 00:09:48,640
if you want to help i think you can help

299
00:09:48,640 --> 00:09:50,000
by trying to implement this

300
00:09:50,000 --> 00:09:52,720
idea in one of your own designs i've

301
00:09:52,720 --> 00:09:54,720
prepared some example code that shows

302
00:09:54,720 --> 00:09:56,880
how to adapt a simple client server

303
00:09:56,880 --> 00:09:59,279
system to a turbo tunnel design

304
00:09:59,279 --> 00:10:00,800
and i've tried to focus on just the

305
00:10:00,800 --> 00:10:02,800
essential elements and make the diffs

306
00:10:02,800 --> 00:10:05,360
small and comprehensible so the main

307
00:10:05,360 --> 00:10:07,760
programs are less than 100 lines

308
00:10:07,760 --> 00:10:09,839
and i've included all the ancillary

309
00:10:09,839 --> 00:10:11,839
support code that i found necessary

310
00:10:11,839 --> 00:10:15,200
in implementing turbo tunnel

311
00:10:15,200 --> 00:10:16,880
for feedback there's a discussion thread

312
00:10:16,880 --> 00:10:18,480
linked here of course you can email me

313
00:10:18,480 --> 00:10:20,000
directly

314
00:10:20,000 --> 00:10:21,760
thank you for your attention and keep on

315
00:10:21,760 --> 00:10:32,640
finding the good fight

316
00:10:32,640 --> 00:10:34,720
you

