1
00:00:08,639 --> 00:00:12,639
hi i'm wayne hancher

2
00:00:09,920 --> 00:00:14,799
from university of california riverside

3
00:00:12,639 --> 00:00:17,039
today i'm going to present how to

4
00:00:14,799 --> 00:00:19,039
generate exploit for linux kernel

5
00:00:17,039 --> 00:00:23,279
autobahn right vulnerabilities

6
00:00:19,039 --> 00:00:25,279
with the help of our system called kubi

7
00:00:23,279 --> 00:00:26,560
according to seedbot google's kernel

8
00:00:25,279 --> 00:00:28,320
fighting platform

9
00:00:26,560 --> 00:00:30,400
there were more than one thousand links

10
00:00:28,320 --> 00:00:31,279
kernel bugs discovered during one single

11
00:00:30,400 --> 00:00:33,280
year

12
00:00:31,279 --> 00:00:34,399
given such a large number of bugs we

13
00:00:33,280 --> 00:00:36,640
have to deal with

14
00:00:34,399 --> 00:00:38,320
prioritizing the fix for them as

15
00:00:36,640 --> 00:00:40,640
critical

16
00:00:38,320 --> 00:00:42,079
one promising direction is to automate

17
00:00:40,640 --> 00:00:44,000
the exploit generation

18
00:00:42,079 --> 00:00:45,920
and prioritize the bugs that are

19
00:00:44,000 --> 00:00:48,239
definitely exploitable

20
00:00:45,920 --> 00:00:49,360
in this work we focus one common type of

21
00:00:48,239 --> 00:00:52,879
vulnerabilities

22
00:00:49,360 --> 00:00:55,199
autobahn right vulnerability

23
00:00:52,879 --> 00:00:57,440
this is the simplified version of cve

24
00:00:55,199 --> 00:01:00,239
2018 5703

25
00:00:57,440 --> 00:01:01,760
and line 9 we can see that it allocates

26
00:01:00,239 --> 00:01:04,798
an object of type

27
00:01:01,760 --> 00:01:08,320
1. we refer to this object as the

28
00:01:04,799 --> 00:01:10,560
vulnerable object and there is a type

29
00:01:08,320 --> 00:01:12,880
confusion block at line 11

30
00:01:10,560 --> 00:01:15,119
where the vulnerable object is casted

31
00:01:12,880 --> 00:01:16,880
into an object of type 2.

32
00:01:15,119 --> 00:01:18,720
if we take a look at the definition of

33
00:01:16,880 --> 00:01:21,839
these two types at top

34
00:01:18,720 --> 00:01:23,280
we can see that type 2 contains a field

35
00:01:21,840 --> 00:01:25,520
of type 1.

36
00:01:23,280 --> 00:01:27,360
therefore the size of type 2 is larger

37
00:01:25,520 --> 00:01:29,200
than the size of type 1.

38
00:01:27,360 --> 00:01:31,360
so when we access the second field

39
00:01:29,200 --> 00:01:33,759
option and line 12

40
00:01:31,360 --> 00:01:35,119
the written address is beyond range of

41
00:01:33,759 --> 00:01:38,640
the vulnerable object

42
00:01:35,119 --> 00:01:40,960
and thus we have another boundary

43
00:01:38,640 --> 00:01:42,479
however if we only look at the first two

44
00:01:40,960 --> 00:01:45,199
system codes we may

45
00:01:42,479 --> 00:01:46,880
conclude that it only allows to override

46
00:01:45,200 --> 00:01:49,040
with a fixed value

47
00:01:46,880 --> 00:01:50,720
in this example the value to be

48
00:01:49,040 --> 00:01:53,280
overwritten by line 12

49
00:01:50,720 --> 00:01:56,240
is actually from the global variable

50
00:01:53,280 --> 00:01:58,560
defined island 6

51
00:01:56,240 --> 00:02:00,240
but in fact if we can explore some other

52
00:01:58,560 --> 00:02:03,360
part of the kernel code

53
00:02:00,240 --> 00:02:04,960
that is not executed by the poc we have

54
00:02:03,360 --> 00:02:06,479
we may find that there is actually

55
00:02:04,960 --> 00:02:09,598
another system called define

56
00:02:06,479 --> 00:02:12,160
island 13 that could change the value of

57
00:02:09,598 --> 00:02:14,959
the global variable

58
00:02:12,160 --> 00:02:17,599
so the first challenge we have is that

59
00:02:14,959 --> 00:02:18,640
the initial poc does not necessarily

60
00:02:17,599 --> 00:02:20,840
manifest

61
00:02:18,640 --> 00:02:22,559
complete capability for the

62
00:02:20,840 --> 00:02:25,280
vulnerability

63
00:02:22,560 --> 00:02:28,959
here are some more examples the first

64
00:02:25,280 --> 00:02:31,680
one is from cv 2016-6187

65
00:02:28,959 --> 00:02:32,400
it allows to overflow only one byte of

66
00:02:31,680 --> 00:02:34,879
zero

67
00:02:32,400 --> 00:02:36,800
but the size of the vulnerable object is

68
00:02:34,879 --> 00:02:41,679
controllable to the attacker

69
00:02:36,800 --> 00:02:43,599
the bottom one is from cv 2017-7184

70
00:02:41,680 --> 00:02:45,040
although the size of the vulnerable

71
00:02:43,599 --> 00:02:47,518
object is fixed

72
00:02:45,040 --> 00:02:49,760
the outside of the oval retail adjusts

73
00:02:47,519 --> 00:02:51,280
as controllable

74
00:02:49,760 --> 00:02:53,840
as we can see for different

75
00:02:51,280 --> 00:02:56,959
vulnerabilities the capability of

76
00:02:53,840 --> 00:02:59,440
overflow varies significantly so the

77
00:02:56,959 --> 00:03:01,840
second challenge is how we can model the

78
00:02:59,440 --> 00:03:04,400
capability of overflow

79
00:03:01,840 --> 00:03:06,480
intuitively there are three important

80
00:03:04,400 --> 00:03:08,720
dimensions we should consider

81
00:03:06,480 --> 00:03:10,319
how far the write can reach which is

82
00:03:08,720 --> 00:03:12,640
basically the offsite

83
00:03:10,319 --> 00:03:15,280
how many bias we can write and what

84
00:03:12,640 --> 00:03:17,440
value can be written

85
00:03:15,280 --> 00:03:19,040
the right hand side of the figure shows

86
00:03:17,440 --> 00:03:21,040
the knowledge we have all the

87
00:03:19,040 --> 00:03:22,720
vulnerabilities

88
00:03:21,040 --> 00:03:25,519
we know the size of the vulnerable

89
00:03:22,720 --> 00:03:27,920
object we also know the outside

90
00:03:25,519 --> 00:03:28,959
length and the range of the overwritten

91
00:03:27,920 --> 00:03:31,518
value

92
00:03:28,959 --> 00:03:32,080
however the effect of the overflow

93
00:03:31,519 --> 00:03:34,159
depends

94
00:03:32,080 --> 00:03:35,200
on the object following the vulnerable

95
00:03:34,159 --> 00:03:37,840
object

96
00:03:35,200 --> 00:03:40,560
we refer to the object to be overwritten

97
00:03:37,840 --> 00:03:42,319
as the target object

98
00:03:40,560 --> 00:03:44,000
in the motivating example there is

99
00:03:42,319 --> 00:03:46,238
another structure times three

100
00:03:44,000 --> 00:03:47,920
with a function pointer at the beginning

101
00:03:46,239 --> 00:03:50,319
defined at line 3.

102
00:03:47,920 --> 00:03:51,760
we can see that if we can allocate an

103
00:03:50,319 --> 00:03:54,560
object of type 3

104
00:03:51,760 --> 00:03:57,280
and put it next to the volume object

105
00:03:54,560 --> 00:03:59,200
then when we triggered the autobot right

106
00:03:57,280 --> 00:04:00,480
to modify the function point in the

107
00:03:59,200 --> 00:04:03,280
target object

108
00:04:00,480 --> 00:04:04,480
we can easily hijack the control flow by

109
00:04:03,280 --> 00:04:07,360
invoking the last

110
00:04:04,480 --> 00:04:09,200
system called define eye line 19 to

111
00:04:07,360 --> 00:04:09,680
trigger the reference of the function

112
00:04:09,200 --> 00:04:13,599
point

113
00:04:09,680 --> 00:04:14,159
we modified earlier so now the question

114
00:04:13,599 --> 00:04:16,079
becomes

115
00:04:14,159 --> 00:04:18,079
how we can put these two objects

116
00:04:16,079 --> 00:04:19,918
together

117
00:04:18,079 --> 00:04:21,840
well there is actually a well-known

118
00:04:19,918 --> 00:04:24,080
technique called hip functioning

119
00:04:21,839 --> 00:04:24,880
the idea is that we can pre-arrange the

120
00:04:24,080 --> 00:04:27,440
heap layout

121
00:04:24,880 --> 00:04:30,080
because the behavior of linux allocator

122
00:04:27,440 --> 00:04:32,240
is deterministic

123
00:04:30,080 --> 00:04:34,479
given that each target object is so

124
00:04:32,240 --> 00:04:35,680
unique in terms of the critical field we

125
00:04:34,479 --> 00:04:38,400
want to override

126
00:04:35,680 --> 00:04:39,800
and how we can exploit it the challenge

127
00:04:38,400 --> 00:04:42,080
is how to evaluate

128
00:04:39,800 --> 00:04:42,960
exploitability against different target

129
00:04:42,080 --> 00:04:44,960
objects

130
00:04:42,960 --> 00:04:47,359
and we also want to have an efficient

131
00:04:44,960 --> 00:04:51,120
algorithm to be able to search through

132
00:04:47,360 --> 00:04:52,080
hundreds of candidates in this work we

133
00:04:51,120 --> 00:04:54,479
only generate

134
00:04:52,080 --> 00:04:55,680
exploit primitives to achieve control

135
00:04:54,479 --> 00:04:58,560
flow hijacking

136
00:04:55,680 --> 00:05:00,479
some modern defenses like kernel address

137
00:04:58,560 --> 00:05:03,840
space layout randomization

138
00:05:00,479 --> 00:05:05,280
are considered adapt scope also we use

139
00:05:03,840 --> 00:05:06,080
some well-known headphone jack

140
00:05:05,280 --> 00:05:10,559
strategies

141
00:05:06,080 --> 00:05:12,000
rather than exploring nuances here's the

142
00:05:10,560 --> 00:05:13,600
overview of our system

143
00:05:12,000 --> 00:05:16,320
specific to other bandwidth

144
00:05:13,600 --> 00:05:19,919
vulnerabilities which consists of four

145
00:05:16,320 --> 00:05:22,159
components given one plc our goal is to

146
00:05:19,919 --> 00:05:25,280
assist exploit generation

147
00:05:22,160 --> 00:05:27,360
although the whole process of exploit

148
00:05:25,280 --> 00:05:30,080
generation sounds complex

149
00:05:27,360 --> 00:05:30,880
the design principle of of this system

150
00:05:30,080 --> 00:05:33,520
is that

151
00:05:30,880 --> 00:05:34,320
we could actually couple the capability

152
00:05:33,520 --> 00:05:37,120
extraction

153
00:05:34,320 --> 00:05:38,080
for the rest of the pipeline in this way

154
00:05:37,120 --> 00:05:40,720
we simplify

155
00:05:38,080 --> 00:05:42,080
the search space to the point where we

156
00:05:40,720 --> 00:05:44,400
only need to check

157
00:05:42,080 --> 00:05:48,159
whether a target object we choose could

158
00:05:44,400 --> 00:05:49,758
match the capability we summarized

159
00:05:48,160 --> 00:05:52,080
the first step is to perform

160
00:05:49,759 --> 00:05:54,639
vulnerability analysis to pinpoint

161
00:05:52,080 --> 00:05:56,400
the vulnerable object as well as all the

162
00:05:54,639 --> 00:06:00,240
vulnerability points where

163
00:05:56,400 --> 00:06:01,840
other bond access occur in addition to

164
00:06:00,240 --> 00:06:04,840
kernel address sanitizer

165
00:06:01,840 --> 00:06:06,880
we do symbolic tracing to improve its

166
00:06:04,840 --> 00:06:08,880
precision

167
00:06:06,880 --> 00:06:11,120
and then we also use small electricity

168
00:06:08,880 --> 00:06:12,400
to summarize the capability of this

169
00:06:11,120 --> 00:06:15,280
particular poc

170
00:06:12,400 --> 00:06:16,638
and store as a result in the database

171
00:06:15,280 --> 00:06:18,960
for the same cve

172
00:06:16,639 --> 00:06:20,080
we may have different plcs and hence

173
00:06:18,960 --> 00:06:23,919
different capability

174
00:06:20,080 --> 00:06:26,719
summarizations now that we have the

175
00:06:23,919 --> 00:06:29,039
database of capabilities we summarized

176
00:06:26,720 --> 00:06:30,319
we could check the target objects one by

177
00:06:29,039 --> 00:06:32,080
one to see

178
00:06:30,319 --> 00:06:33,759
if any of them could match the

179
00:06:32,080 --> 00:06:35,440
capabilities

180
00:06:33,759 --> 00:06:37,440
in the case where the vulnerability can

181
00:06:35,440 --> 00:06:40,800
be triggered multiple times

182
00:06:37,440 --> 00:06:43,360
our system allows combining capabilities

183
00:06:40,800 --> 00:06:46,479
if we find any solution we could further

184
00:06:43,360 --> 00:06:48,960
synthesize and exploit

185
00:06:46,479 --> 00:06:50,080
if we are not satisfied by the poc we

186
00:06:48,960 --> 00:06:52,960
already have

187
00:06:50,080 --> 00:06:54,639
we could explore the poc to find more

188
00:06:52,960 --> 00:06:57,840
interesting inputs

189
00:06:54,639 --> 00:07:00,800
and then repeat the whole process

190
00:06:57,840 --> 00:07:03,119
the capability summarization is the is

191
00:07:00,800 --> 00:07:05,120
the crucial part of this work

192
00:07:03,120 --> 00:07:07,440
recall the three dimensions i mentioned

193
00:07:05,120 --> 00:07:10,720
earlier for each other one white

194
00:07:07,440 --> 00:07:15,360
we could extract its offsite lens and

195
00:07:10,720 --> 00:07:18,400
operating value with symbolic tracing

196
00:07:15,360 --> 00:07:20,240
for one single pass that is executed by

197
00:07:18,400 --> 00:07:22,239
one particular poc

198
00:07:20,240 --> 00:07:23,280
we could collect a site of other

199
00:07:22,240 --> 00:07:26,960
boundary

200
00:07:23,280 --> 00:07:29,440
summarizations in addition

201
00:07:26,960 --> 00:07:31,198
the past constraints are included

202
00:07:29,440 --> 00:07:32,400
because they could be coupled with

203
00:07:31,199 --> 00:07:34,720
autobahn light

204
00:07:32,400 --> 00:07:36,638
in the motivating example we conclude

205
00:07:34,720 --> 00:07:38,319
that the overreach and value is

206
00:07:36,639 --> 00:07:41,360
controllable to the attacker

207
00:07:38,319 --> 00:07:44,160
and its value seems to be arbitrary but

208
00:07:41,360 --> 00:07:47,599
in fact there is a check at line 14

209
00:07:44,160 --> 00:07:49,599
which prohibits value to be -1 we also

210
00:07:47,599 --> 00:07:50,159
consider the size of the vulnerable

211
00:07:49,599 --> 00:07:53,680
object

212
00:07:50,160 --> 00:07:55,919
for the same reason in order to explore

213
00:07:53,680 --> 00:07:58,960
some other part of the kernel code

214
00:07:55,919 --> 00:08:01,680
that is related to the capability we

215
00:07:58,960 --> 00:08:02,960
propose a noble capability guided filing

216
00:08:01,680 --> 00:08:04,960
solution

217
00:08:02,960 --> 00:08:06,638
existing coverage guided fusing

218
00:08:04,960 --> 00:08:09,120
solutions are ineffective

219
00:08:06,639 --> 00:08:09,919
because they only focus on the coverage

220
00:08:09,120 --> 00:08:12,000
feedback

221
00:08:09,919 --> 00:08:13,280
and hems are insensitive to the

222
00:08:12,000 --> 00:08:15,520
capability

223
00:08:13,280 --> 00:08:16,960
therefore we use dynamic instrumentation

224
00:08:15,520 --> 00:08:19,198
to hook older

225
00:08:16,960 --> 00:08:21,039
vulnerability points to client

226
00:08:19,199 --> 00:08:23,120
information as the feedback

227
00:08:21,039 --> 00:08:25,680
we also maintain different cues for

228
00:08:23,120 --> 00:08:28,080
different feedback

229
00:08:25,680 --> 00:08:30,160
as i mentioned earlier the effect of

230
00:08:28,080 --> 00:08:31,520
overflow really depends on the target

231
00:08:30,160 --> 00:08:33,760
object we choose

232
00:08:31,520 --> 00:08:34,880
in general we can see the three types of

233
00:08:33,760 --> 00:08:37,279
objects

234
00:08:34,880 --> 00:08:39,120
objects with function pointers objects

235
00:08:37,279 --> 00:08:41,200
with data pointers

236
00:08:39,120 --> 00:08:42,560
and objects with some special fields

237
00:08:41,200 --> 00:08:45,279
like uid and

238
00:08:42,559 --> 00:08:47,599
reference counters since the code base

239
00:08:45,279 --> 00:08:50,399
of linux kernel is quite stable

240
00:08:47,600 --> 00:08:53,440
we manually construct the database for

241
00:08:50,399 --> 00:08:55,680
the target objects

242
00:08:53,440 --> 00:08:56,800
with hip function to pre-arrange the hip

243
00:08:55,680 --> 00:08:58,800
layout we can

244
00:08:56,800 --> 00:09:01,040
ensure the vulnerable and target objects

245
00:08:58,800 --> 00:09:03,040
are adjacent to each other

246
00:09:01,040 --> 00:09:04,160
therefore given the capability

247
00:09:03,040 --> 00:09:07,199
summarization and

248
00:09:04,160 --> 00:09:08,000
one target object we construct a memory

249
00:09:07,200 --> 00:09:10,480
model only

250
00:09:08,000 --> 00:09:11,600
containing these two objects and apply

251
00:09:10,480 --> 00:09:14,320
all the overflow

252
00:09:11,600 --> 00:09:16,160
on the memory model and then we could

253
00:09:14,320 --> 00:09:18,240
carry the constraints over

254
00:09:16,160 --> 00:09:20,719
whether the critical field in the target

255
00:09:18,240 --> 00:09:21,600
object can be overwritten to the desired

256
00:09:20,720 --> 00:09:24,800
payload

257
00:09:21,600 --> 00:09:26,959
with respect to the path constraints for

258
00:09:24,800 --> 00:09:29,599
the multi-waiting example we can modify

259
00:09:26,959 --> 00:09:32,399
the first 8 bytes of the target objects

260
00:09:29,600 --> 00:09:34,080
and type 3 happens to have a function

261
00:09:32,399 --> 00:09:35,600
pointer at the beginning

262
00:09:34,080 --> 00:09:38,080
therefore the constraint server can

263
00:09:35,600 --> 00:09:39,360
produce a solution

264
00:09:38,080 --> 00:09:41,440
on the other hand since the

265
00:09:39,360 --> 00:09:43,120
vulnerability does not allow to temper

266
00:09:41,440 --> 00:09:47,760
the second a byte

267
00:09:43,120 --> 00:09:51,279
we fail to find a solution for type 4.

268
00:09:47,760 --> 00:09:52,560
we we evaluate our system against 17

269
00:09:51,279 --> 00:09:55,200
different other boundaries

270
00:09:52,560 --> 00:09:56,880
vulnerabilities in linux kernel seven

271
00:09:55,200 --> 00:09:59,200
are from cv database

272
00:09:56,880 --> 00:10:01,279
and the right wizard cv numbers are from

273
00:09:59,200 --> 00:10:03,440
6bot

274
00:10:01,279 --> 00:10:04,640
for the seven cves four of and have

275
00:10:03,440 --> 00:10:06,800
public exploits

276
00:10:04,640 --> 00:10:08,480
with our system we could generate seven

277
00:10:06,800 --> 00:10:10,959
more exploits

278
00:10:08,480 --> 00:10:14,000
note that we cut the number of exploits

279
00:10:10,959 --> 00:10:16,479
based on the target object we used

280
00:10:14,000 --> 00:10:17,200
for those results v numbers only one has

281
00:10:16,480 --> 00:10:19,920
been started

282
00:10:17,200 --> 00:10:21,600
and thus has one public's point with our

283
00:10:19,920 --> 00:10:25,680
system we also generally sell

284
00:10:21,600 --> 00:10:27,839
more exploits as shown in this table we

285
00:10:25,680 --> 00:10:31,359
break down the time cost for each

286
00:10:27,839 --> 00:10:32,320
step as we can see the solving time per

287
00:10:31,360 --> 00:10:34,959
target object

288
00:10:32,320 --> 00:10:36,160
varies from as much as one second to

289
00:10:34,959 --> 00:10:37,920
about three minutes

290
00:10:36,160 --> 00:10:39,600
indicating that our system can

291
00:10:37,920 --> 00:10:42,560
efficiently search through

292
00:10:39,600 --> 00:10:44,959
hundreds of targets objects for the

293
00:10:42,560 --> 00:10:47,279
fuzzing part we attempted to compare our

294
00:10:44,959 --> 00:10:49,279
solution with the vanilla seeds color

295
00:10:47,279 --> 00:10:51,279
but this color is not designed to

296
00:10:49,279 --> 00:10:53,360
explode the crushing input

297
00:10:51,279 --> 00:10:56,240
and does fail to produce any result in

298
00:10:53,360 --> 00:10:58,880
the limited time budget

299
00:10:56,240 --> 00:11:00,880
although in this work we only focus on

300
00:10:58,880 --> 00:11:03,519
other bandwidth vulnerability

301
00:11:00,880 --> 00:11:05,079
the principle of separating capability

302
00:11:03,519 --> 00:11:07,519
summarization through

303
00:11:05,079 --> 00:11:08,959
exploitability evaluation can also be

304
00:11:07,519 --> 00:11:10,160
applied to other types of

305
00:11:08,959 --> 00:11:13,199
vulnerabilities

306
00:11:10,160 --> 00:11:15,360
such as use of the free and double free

307
00:11:13,200 --> 00:11:18,240
this is because for kernel it usually

308
00:11:15,360 --> 00:11:21,279
has an extremely large search space

309
00:11:18,240 --> 00:11:23,839
and we also observe that vulnerabilities

310
00:11:21,279 --> 00:11:24,720
sometimes can be converted from one type

311
00:11:23,839 --> 00:11:27,200
to another

312
00:11:24,720 --> 00:11:28,630
but all of them required to corrupt some

313
00:11:27,200 --> 00:11:30,000
kernel data

314
00:11:28,630 --> 00:11:33,839
[Music]

315
00:11:30,000 --> 00:11:33,839
that's all for my talk thanks for your

316
00:11:40,279 --> 00:11:43,279
listening

