1
00:00:08,480 --> 00:00:12,080
hello everyone i'm insulin from georgia

2
00:00:10,400 --> 00:00:14,240
tech today i'm gonna talk about

3
00:00:12,080 --> 00:00:15,759
automatic techniques to systematically

4
00:00:14,240 --> 00:00:16,640
discover new heap exploitation

5
00:00:15,759 --> 00:00:17,920
primitives

6
00:00:16,640 --> 00:00:20,160
this is showing to work with my

7
00:00:17,920 --> 00:00:21,840
colleague double kaphil and my advisor

8
00:00:20,160 --> 00:00:23,600
test kim

9
00:00:21,840 --> 00:00:25,198
as we already know hip vulnerabilities

10
00:00:23,600 --> 00:00:25,840
are very common in serious security

11
00:00:25,199 --> 00:00:30,000
issues

12
00:00:25,840 --> 00:00:32,558
according to microsoft 39 of cvc in 2018

13
00:00:30,000 --> 00:00:34,719
are related to hipaa nobilities one way

14
00:00:32,558 --> 00:00:36,640
to exploit this vulnerability is using

15
00:00:34,719 --> 00:00:38,800
hip exploitation techniques heap

16
00:00:36,640 --> 00:00:39,360
exploitation techniques we call att for

17
00:00:38,800 --> 00:00:41,120
short

18
00:00:39,360 --> 00:00:43,440
abuse underlying allocator to achieve

19
00:00:41,120 --> 00:00:45,360
more powerful primitive for exploitation

20
00:00:43,440 --> 00:00:46,879
in the presence of the vulnerabilities

21
00:00:45,360 --> 00:00:48,239
this is preferable because it is

22
00:00:46,879 --> 00:00:50,079
application agnostic

23
00:00:48,239 --> 00:00:51,519
in other words it only depends on the

24
00:00:50,079 --> 00:00:53,520
underlying allocators

25
00:00:51,520 --> 00:00:55,360
and it is powerful by exchanging

26
00:00:53,520 --> 00:00:57,280
seemingly weak vulnerability into very

27
00:00:55,360 --> 00:00:57,839
powerful primitives for example we can

28
00:00:57,280 --> 00:00:59,600
convert

29
00:00:57,840 --> 00:01:01,120
up by one null vital overflow into

30
00:00:59,600 --> 00:01:03,760
arbitrary code execution

31
00:01:01,120 --> 00:01:05,438
using hip hip exploitation technique as

32
00:01:03,760 --> 00:01:07,920
a result heap exploitation techniques

33
00:01:05,438 --> 00:01:10,960
are widely used to exploit multiple

34
00:01:07,920 --> 00:01:12,880
applications one of the most

35
00:01:10,960 --> 00:01:14,240
famous heap exploitation technique is

36
00:01:12,880 --> 00:01:16,240
called unsafe and link

37
00:01:14,240 --> 00:01:18,640
to explain this we first look at

38
00:01:16,240 --> 00:01:21,679
unlinked mechanism in ptml 2 which is

39
00:01:18,640 --> 00:01:23,280
linux default allocator in pt melody a

40
00:01:21,680 --> 00:01:25,759
heap object we call a chunk

41
00:01:23,280 --> 00:01:27,439
is managed by a doubly linked list with

42
00:01:25,759 --> 00:01:29,680
two pointer fdm bk

43
00:01:27,439 --> 00:01:31,360
after points to the next free chunk bk

44
00:01:29,680 --> 00:01:33,920
points to the previous pre-chunk

45
00:01:31,360 --> 00:01:35,920
if we want to remove a chunk in this

46
00:01:33,920 --> 00:01:37,040
double linked list a link happens with

47
00:01:35,920 --> 00:01:38,960
this code

48
00:01:37,040 --> 00:01:40,479
first a chunk updates its backward

49
00:01:38,960 --> 00:01:41,759
pointer of the fourth pointer with

50
00:01:40,479 --> 00:01:43,600
chunks backward pointer

51
00:01:41,759 --> 00:01:45,200
then it updates its fourth pointer of

52
00:01:43,600 --> 00:01:46,240
the backward pointer with this for the

53
00:01:45,200 --> 00:01:48,960
pointer

54
00:01:46,240 --> 00:01:49,839
and then it removes the chunk if an

55
00:01:48,960 --> 00:01:52,240
attacker can

56
00:01:49,840 --> 00:01:53,920
corrupt these internal structures with

57
00:01:52,240 --> 00:01:55,520
memory corruption they can abuse this

58
00:01:53,920 --> 00:01:58,000
behavior for exploitation

59
00:01:55,520 --> 00:01:59,679
for example if it overrides is fd into

60
00:01:58,000 --> 00:02:00,479
an object with the function pointer and

61
00:01:59,680 --> 00:02:03,040
backward with the

62
00:02:00,479 --> 00:02:04,719
evil function the unlink mechanism will

63
00:02:03,040 --> 00:02:06,640
be converted into the arbitrary right

64
00:02:04,719 --> 00:02:09,038
modifying the function pointer into the

65
00:02:06,640 --> 00:02:09,840
info function finally the attacker can

66
00:02:09,038 --> 00:02:11,760
hijack

67
00:02:09,840 --> 00:02:13,440
control by calling the corrupted

68
00:02:11,760 --> 00:02:13,760
function pointer this technique is

69
00:02:13,440 --> 00:02:16,400
called

70
00:02:13,760 --> 00:02:17,760
unsafe and link to prevent this the pt

71
00:02:16,400 --> 00:02:19,360
melody's developer put

72
00:02:17,760 --> 00:02:21,120
a security check to ensure that the

73
00:02:19,360 --> 00:02:23,280
object has a legitimate form

74
00:02:21,120 --> 00:02:24,400
however this check is still bypassable

75
00:02:23,280 --> 00:02:25,920
but it makes the

76
00:02:24,400 --> 00:02:28,640
hip exploitation technique more

77
00:02:25,920 --> 00:02:29,920
complicated to handle such complexities

78
00:02:28,640 --> 00:02:32,640
researchers have studied

79
00:02:29,920 --> 00:02:34,399
reusable hip exploitation techniques

80
00:02:32,640 --> 00:02:37,119
starting from the famous

81
00:02:34,400 --> 00:02:38,800
frag packaging once upon a free there

82
00:02:37,120 --> 00:02:40,319
are many works related to the hip

83
00:02:38,800 --> 00:02:42,800
exploitation technique

84
00:02:40,319 --> 00:02:44,958
however all analysis are manual ad-hoc

85
00:02:42,800 --> 00:02:46,800
and allocated specific

86
00:02:44,959 --> 00:02:49,200
such manual analysis have several

87
00:02:46,800 --> 00:02:51,360
problems first existing analysis

88
00:02:49,200 --> 00:02:53,119
are highly biased to certain allocators

89
00:02:51,360 --> 00:02:54,319
because of its large amount of manual

90
00:02:53,120 --> 00:02:56,000
efforts

91
00:02:54,319 --> 00:02:57,760
even though there are several many

92
00:02:56,000 --> 00:02:59,599
allocators have been developed

93
00:02:57,760 --> 00:03:01,518
researchers mostly for have focused on

94
00:02:59,599 --> 00:03:03,679
the ptmallet too there are a few work

95
00:03:01,519 --> 00:03:05,920
related to the t semilung and jmel

96
00:03:03,680 --> 00:03:09,040
there is no security analysis for other

97
00:03:05,920 --> 00:03:10,559
allocators such as diehard and mi malloc

98
00:03:09,040 --> 00:03:12,959
second an allocator needs to be

99
00:03:10,560 --> 00:03:14,959
reanalyzed if it has some changes

100
00:03:12,959 --> 00:03:16,720
an allocator can be evolving if its

101
00:03:14,959 --> 00:03:18,239
implementation is changed

102
00:03:16,720 --> 00:03:19,840
we require to have another manual

103
00:03:18,239 --> 00:03:21,840
analysis to understand the security

104
00:03:19,840 --> 00:03:23,840
implications of these changes

105
00:03:21,840 --> 00:03:25,360
for example recently ptmole 2 adopts a

106
00:03:23,840 --> 00:03:26,000
new feature called the threat local

107
00:03:25,360 --> 00:03:27,920
cache

108
00:03:26,000 --> 00:03:30,080
after this researchers have analyzed the

109
00:03:27,920 --> 00:03:32,399
security implications and discovered new

110
00:03:30,080 --> 00:03:33,599
hip exploitation techniques related to

111
00:03:32,400 --> 00:03:35,280
this feature

112
00:03:33,599 --> 00:03:36,720
this should be happening every time in

113
00:03:35,280 --> 00:03:38,560
the manual analysis

114
00:03:36,720 --> 00:03:40,319
a research question is how can we

115
00:03:38,560 --> 00:03:42,000
automate this task

116
00:03:40,319 --> 00:03:43,679
our key idea is to make machine to

117
00:03:42,000 --> 00:03:45,760
autonomously explore

118
00:03:43,680 --> 00:03:48,080
spaces to find heap exploitation

119
00:03:45,760 --> 00:03:50,239
techniques similar to fuzzing

120
00:03:48,080 --> 00:03:52,560
our tool archive keeps generating a set

121
00:03:50,239 --> 00:03:54,799
of heap actions and finally discover

122
00:03:52,560 --> 00:03:55,680
a certain set of actions that can be

123
00:03:54,799 --> 00:03:58,239
used for the

124
00:03:55,680 --> 00:04:00,319
exploitation which what we call hip

125
00:03:58,239 --> 00:04:01,920
exploitation technique

126
00:04:00,319 --> 00:04:03,518
however this is not trivial there are

127
00:04:01,920 --> 00:04:05,119
several technical challenges

128
00:04:03,519 --> 00:04:07,120
first the search space of heap

129
00:04:05,120 --> 00:04:08,959
exploitation technique is very large

130
00:04:07,120 --> 00:04:10,640
second we should find an efficient way

131
00:04:08,959 --> 00:04:12,080
to evaluate the hip exploitation

132
00:04:10,640 --> 00:04:13,679
technique

133
00:04:12,080 --> 00:04:15,760
first we will discuss how to handle

134
00:04:13,680 --> 00:04:17,680
large search space

135
00:04:15,760 --> 00:04:19,120
heap exploitation technique consists of

136
00:04:17,680 --> 00:04:21,759
many heap actions and

137
00:04:19,120 --> 00:04:23,440
each space is very large for example we

138
00:04:21,759 --> 00:04:25,199
have legitimate actions such as a

139
00:04:23,440 --> 00:04:26,240
location dl location hip right and

140
00:04:25,199 --> 00:04:27,919
buffer right

141
00:04:26,240 --> 00:04:29,600
moreover we also need to simulate the

142
00:04:27,919 --> 00:04:31,280
bug actions to discover

143
00:04:29,600 --> 00:04:32,880
heap exploitation techniques such as

144
00:04:31,280 --> 00:04:34,960
overflow ride f3

145
00:04:32,880 --> 00:04:37,120
double free and arbitrary free each

146
00:04:34,960 --> 00:04:39,039
parameter also has large search space

147
00:04:37,120 --> 00:04:40,560
for example in our location we have two

148
00:04:39,040 --> 00:04:43,520
to the 64 candidates

149
00:04:40,560 --> 00:04:44,160
heap rights space is even larger it has

150
00:04:43,520 --> 00:04:46,880
size p

151
00:04:44,160 --> 00:04:49,360
times two to the 64 candidates to handle

152
00:04:46,880 --> 00:04:51,440
this archive reduces search space using

153
00:04:49,360 --> 00:04:54,000
model based search based on the common

154
00:04:51,440 --> 00:04:55,840
designs of all locators

155
00:04:54,000 --> 00:04:57,680
we have obtained several common designs

156
00:04:55,840 --> 00:04:59,198
in all locators regardless of their

157
00:04:57,680 --> 00:05:01,440
underlying implementation

158
00:04:59,199 --> 00:05:03,360
first one is spinning it means that the

159
00:05:01,440 --> 00:05:04,719
allocator specially managed chunks in

160
00:05:03,360 --> 00:05:08,000
the different size group

161
00:05:04,720 --> 00:05:09,919
because for small chunks performance is

162
00:05:08,000 --> 00:05:11,120
more important for the an allocator and

163
00:05:09,919 --> 00:05:13,039
for the large chunk

164
00:05:11,120 --> 00:05:15,840
it more carefully handles its memory

165
00:05:13,039 --> 00:05:18,000
footprint for example pt malloc has

166
00:05:15,840 --> 00:05:20,159
fast beam and small beam fast pin does

167
00:05:18,000 --> 00:05:21,199
not have merging mechanism but small bin

168
00:05:20,160 --> 00:05:23,680
has

169
00:05:21,199 --> 00:05:24,960
thus if we sample a size uniformly in 2

170
00:05:23,680 --> 00:05:26,880
to the 624 space

171
00:05:24,960 --> 00:05:28,880
the probability of getting fast beam

172
00:05:26,880 --> 00:05:31,039
becomes extremely low

173
00:05:28,880 --> 00:05:32,880
to handle this archive selects an all

174
00:05:31,039 --> 00:05:35,520
location size aware of binning

175
00:05:32,880 --> 00:05:36,320
are sample size in exponentially distant

176
00:05:35,520 --> 00:05:38,639
size group

177
00:05:36,320 --> 00:05:39,360
rk partitions and allocation size into

178
00:05:38,639 --> 00:05:41,759
four groups

179
00:05:39,360 --> 00:05:42,400
archive first selects a group and then

180
00:05:41,759 --> 00:05:45,520
selects

181
00:05:42,400 --> 00:05:47,599
uh size in the group uniformly thus the

182
00:05:45,520 --> 00:05:50,479
probability of choosing fast spin size

183
00:05:47,600 --> 00:05:52,400
would be much higher than before it it

184
00:05:50,479 --> 00:05:54,240
will be greater than the probability of

185
00:05:52,400 --> 00:05:56,400
choosing the first group which is one of

186
00:05:54,240 --> 00:05:58,800
the fourth

187
00:05:56,400 --> 00:06:00,159
we also found that allocators share

188
00:05:58,800 --> 00:06:02,479
other common designs

189
00:06:00,160 --> 00:06:04,319
cardinal data and in-place metadata

190
00:06:02,479 --> 00:06:06,960
cardinal data represent the

191
00:06:04,319 --> 00:06:08,800
metadata contain only size and point not

192
00:06:06,960 --> 00:06:10,560
random value for efficiency

193
00:06:08,800 --> 00:06:11,840
implies metadata illustrate that

194
00:06:10,560 --> 00:06:14,880
allocators place

195
00:06:11,840 --> 00:06:15,198
metadata near its chunks start or and

196
00:06:14,880 --> 00:06:17,840
for

197
00:06:15,199 --> 00:06:20,000
locality not random position cardinal

198
00:06:17,840 --> 00:06:22,080
data and in-place metadata also help

199
00:06:20,000 --> 00:06:23,440
us to reduce search space for example if

200
00:06:22,080 --> 00:06:25,599
we generate a heap write

201
00:06:23,440 --> 00:06:26,639
our clip choose value size and pointer

202
00:06:25,600 --> 00:06:28,960
related values

203
00:06:26,639 --> 00:06:30,319
not random value like that beef i could

204
00:06:28,960 --> 00:06:32,799
randomly select size

205
00:06:30,319 --> 00:06:34,800
or use other chunks size for point value

206
00:06:32,800 --> 00:06:35,919
it is other chunk buffer or container

207
00:06:34,800 --> 00:06:38,720
which is an

208
00:06:35,919 --> 00:06:39,440
array that stores other chunks moreover

209
00:06:38,720 --> 00:06:42,400
r clip

210
00:06:39,440 --> 00:06:44,080
limits its right location into the start

211
00:06:42,400 --> 00:06:46,880
or the end of the chunk

212
00:06:44,080 --> 00:06:48,000
instead of random position next we will

213
00:06:46,880 --> 00:06:49,840
discuss how arcade

214
00:06:48,000 --> 00:06:52,479
efficiently evaluate a potential heap

215
00:06:49,840 --> 00:06:54,318
exploitation technique

216
00:06:52,479 --> 00:06:56,318
one way to evaluate heap exploitation

217
00:06:54,319 --> 00:06:58,080
techniques to synthesize a full exploit

218
00:06:56,319 --> 00:07:00,160
however this is inappropriate in

219
00:06:58,080 --> 00:07:02,560
evaluating heap exploitation techniques

220
00:07:00,160 --> 00:07:04,639
first automatic exploit generation is

221
00:07:02,560 --> 00:07:06,800
very difficult problem particularly for

222
00:07:04,639 --> 00:07:08,400
exploits for example in darpa cjc

223
00:07:06,800 --> 00:07:09,840
competition only one hit bug was

224
00:07:08,400 --> 00:07:11,758
successfully exploited

225
00:07:09,840 --> 00:07:13,359
second automatic exploit generation is

226
00:07:11,759 --> 00:07:15,520
usually inefficient

227
00:07:13,360 --> 00:07:16,560
one try can take a few seconds minutes

228
00:07:15,520 --> 00:07:18,479
or even hours

229
00:07:16,560 --> 00:07:20,639
finally automatic exploit generation is

230
00:07:18,479 --> 00:07:22,479
application dependent however a useless

231
00:07:20,639 --> 00:07:23,360
hip exploitation technique in a certain

232
00:07:22,479 --> 00:07:25,758
application

233
00:07:23,360 --> 00:07:26,880
might be useful in other applications to

234
00:07:25,759 --> 00:07:28,800
overcome these

235
00:07:26,880 --> 00:07:30,960
issues we evaluate impacts of the

236
00:07:28,800 --> 00:07:32,319
exploitation instead of making a full

237
00:07:30,960 --> 00:07:34,000
exploit

238
00:07:32,319 --> 00:07:35,599
impacts of the exploitations are the

239
00:07:34,000 --> 00:07:36,560
broken invariants that have security

240
00:07:35,599 --> 00:07:38,719
implications

241
00:07:36,560 --> 00:07:40,479
first invariant is that allocate memory

242
00:07:38,720 --> 00:07:44,160
should not be overlapped with

243
00:07:40,479 --> 00:07:46,000
pre-allocated memory if the allocator or

244
00:07:44,160 --> 00:07:48,240
violate this it will result in

245
00:07:46,000 --> 00:07:50,080
overlapping chunk or arbitrary chunk

246
00:07:48,240 --> 00:07:51,520
second an allocator should not modify

247
00:07:50,080 --> 00:07:52,159
the member which is not under its

248
00:07:51,520 --> 00:07:53,919
control

249
00:07:52,160 --> 00:07:55,919
if we violate this it results in the

250
00:07:53,919 --> 00:07:58,318
arbitrator only straight to the right

251
00:07:55,919 --> 00:07:59,599
the first invariant is easy to check by

252
00:07:58,319 --> 00:08:02,000
using a location

253
00:07:59,599 --> 00:08:03,680
information what about the second one

254
00:08:02,000 --> 00:08:05,599
note that this detection should be

255
00:08:03,680 --> 00:08:08,080
efficient to search large space of the

256
00:08:05,599 --> 00:08:10,000
heap exploitation techniques

257
00:08:08,080 --> 00:08:11,680
to do the archive uses the shadow memory

258
00:08:10,000 --> 00:08:12,879
to detect the arbitrary rise and the

259
00:08:11,680 --> 00:08:14,639
restricted rights

260
00:08:12,879 --> 00:08:16,080
in every action which can change its

261
00:08:14,639 --> 00:08:18,319
internal data structure

262
00:08:16,080 --> 00:08:20,240
we also update its shadow memory for

263
00:08:18,319 --> 00:08:22,720
example in all location

264
00:08:20,240 --> 00:08:25,039
we update a container and in buffer

265
00:08:22,720 --> 00:08:27,440
write we update the global buffer

266
00:08:25,039 --> 00:08:29,680
then in every action such as a location

267
00:08:27,440 --> 00:08:31,440
deal location hip right and buffer right

268
00:08:29,680 --> 00:08:33,039
we check whether the shadow memory's

269
00:08:31,440 --> 00:08:35,120
contents diverge

270
00:08:33,039 --> 00:08:37,360
these divergence means that heap

271
00:08:35,120 --> 00:08:39,039
allocator internally modifies memory in

272
00:08:37,360 --> 00:08:41,519
the container or global buffer

273
00:08:39,039 --> 00:08:43,279
which is not here thus this can be

274
00:08:41,519 --> 00:08:44,640
converted into the arbitrary or restrict

275
00:08:43,279 --> 00:08:46,560
to write

276
00:08:44,640 --> 00:08:48,640
for further analysis arc provides a

277
00:08:46,560 --> 00:08:50,560
minimized poc code written in c

278
00:08:48,640 --> 00:08:53,120
this is trivial because every action has

279
00:08:50,560 --> 00:08:55,199
one-to-one mapping with the c code

280
00:08:53,120 --> 00:08:56,160
archive also minimizes plc code using

281
00:08:55,200 --> 00:08:58,800
data debugging

282
00:08:56,160 --> 00:09:01,120
basically it eliminates an action that

283
00:08:58,800 --> 00:09:03,359
is not required to trigger the impact of

284
00:09:01,120 --> 00:09:04,640
the exploitation

285
00:09:03,360 --> 00:09:06,959
we want to answer the following

286
00:09:04,640 --> 00:09:08,720
evaluation question first how effective

287
00:09:06,959 --> 00:09:10,000
is archive in finding new heap

288
00:09:08,720 --> 00:09:11,839
exploitation techniques

289
00:09:10,000 --> 00:09:14,080
compared to the existing tools of

290
00:09:11,839 --> 00:09:16,080
hip-hopper second how generally is

291
00:09:14,080 --> 00:09:18,240
arcade's approach

292
00:09:16,080 --> 00:09:20,480
archive discovers five new heap

293
00:09:18,240 --> 00:09:22,000
exploitation techniques in pt malloc ii

294
00:09:20,480 --> 00:09:23,920
which cannot be discovered by the hip

295
00:09:22,000 --> 00:09:26,880
hopper first technique is called

296
00:09:23,920 --> 00:09:28,640
unsorted beam stack this requires fewer

297
00:09:26,880 --> 00:09:29,600
steps than the exist one another

298
00:09:28,640 --> 00:09:31,839
technique house of

299
00:09:29,600 --> 00:09:33,440
uncertainty irony converts oppai will

300
00:09:31,839 --> 00:09:34,000
not bite into the arbitrary chunk

301
00:09:33,440 --> 00:09:37,200
without

302
00:09:34,000 --> 00:09:39,120
hip on the line the double three is the

303
00:09:37,200 --> 00:09:41,839
first technique that abuse

304
00:09:39,120 --> 00:09:43,519
double free in the small chunk bin which

305
00:09:41,839 --> 00:09:45,760
it has more checks than the

306
00:09:43,519 --> 00:09:46,720
fast bit these techniques cannot be

307
00:09:45,760 --> 00:09:48,560
discovered by

308
00:09:46,720 --> 00:09:50,000
existing true hip-hopper because of its

309
00:09:48,560 --> 00:09:51,760
scalability issues

310
00:09:50,000 --> 00:09:55,200
coming from its underlying techniques

311
00:09:51,760 --> 00:09:57,360
symbolic execution and modal checking

312
00:09:55,200 --> 00:09:58,800
archive's technique is also general

313
00:09:57,360 --> 00:10:00,880
enough to test the various

314
00:09:58,800 --> 00:10:02,959
allocators we have tested 10 different

315
00:10:00,880 --> 00:10:04,800
allocators archivals to find

316
00:10:02,959 --> 00:10:06,959
heap exploitation technique in three

317
00:10:04,800 --> 00:10:09,120
allocators levm scooter

318
00:10:06,959 --> 00:10:10,079
free guard and guarder which are secure

319
00:10:09,120 --> 00:10:12,160
allocators

320
00:10:10,079 --> 00:10:14,079
first we want to mention that archives

321
00:10:12,160 --> 00:10:14,800
successfully discover heap exploitation

322
00:10:14,079 --> 00:10:17,120
technique in

323
00:10:14,800 --> 00:10:18,160
all locators that are not related to pit

324
00:10:17,120 --> 00:10:20,560
miller 2 which

325
00:10:18,160 --> 00:10:22,000
shows its generality secondly it even

326
00:10:20,560 --> 00:10:22,640
can find the heap exploitation

327
00:10:22,000 --> 00:10:24,640
techniques

328
00:10:22,640 --> 00:10:26,880
in secure allocators such as mi malek

329
00:10:24,640 --> 00:10:28,319
secure and die harder

330
00:10:26,880 --> 00:10:30,560
we want to share several interesting

331
00:10:28,320 --> 00:10:32,399
case study first one is that

332
00:10:30,560 --> 00:10:34,319
hipaa exploitation technique converting

333
00:10:32,399 --> 00:10:36,480
double free to overlapping chunk and die

334
00:10:34,320 --> 00:10:39,279
harder and then mimic secure

335
00:10:36,480 --> 00:10:40,959
if we double free a lot very large chunk

336
00:10:39,279 --> 00:10:42,560
it results in the overlapping chunk we

337
00:10:40,959 --> 00:10:45,279
found that the same thing happens

338
00:10:42,560 --> 00:10:46,319
in both die harder and the mi milo

339
00:10:45,279 --> 00:10:48,640
interestingly these

340
00:10:46,320 --> 00:10:49,760
issues are irrelevant we reported this

341
00:10:48,640 --> 00:10:51,839
issue to the

342
00:10:49,760 --> 00:10:53,920
mi mello developer whether mi malek has

343
00:10:51,839 --> 00:10:56,560
certain relationship with the die harder

344
00:10:53,920 --> 00:10:57,599
the answer was no after analysis we

345
00:10:56,560 --> 00:10:59,920
found that

346
00:10:57,600 --> 00:11:01,279
if we double free a very large chunk die

347
00:10:59,920 --> 00:11:03,760
hardened missed the check

348
00:11:01,279 --> 00:11:05,680
and the mi mello's check was wrong note

349
00:11:03,760 --> 00:11:06,959
that our auto generated poc has been

350
00:11:05,680 --> 00:11:10,239
integrated into a

351
00:11:06,959 --> 00:11:11,920
mi mallox regression test second one is

352
00:11:10,240 --> 00:11:12,480
the heap exploitation technique that

353
00:11:11,920 --> 00:11:14,640
converts

354
00:11:12,480 --> 00:11:15,760
overflow into the arbitrary chunk in the

355
00:11:14,640 --> 00:11:17,920
latest dml

356
00:11:15,760 --> 00:11:19,680
note that the ammo log is a pd melody's

357
00:11:17,920 --> 00:11:22,560
ancestor but has been

358
00:11:19,680 --> 00:11:24,560
diverged after its fork thus this heap

359
00:11:22,560 --> 00:11:26,560
exploitation technique only works for

360
00:11:24,560 --> 00:11:28,719
the diameter ptml 2.

361
00:11:26,560 --> 00:11:30,640
this plg require several memory sizes

362
00:11:28,720 --> 00:11:32,959
and look complicated

363
00:11:30,640 --> 00:11:33,920
interestingly its root cause is more

364
00:11:32,959 --> 00:11:35,680
complicated

365
00:11:33,920 --> 00:11:37,680
several sizes are required to set up

366
00:11:35,680 --> 00:11:40,880
special flag in the dmlo

367
00:11:37,680 --> 00:11:43,279
use memory map instead of sbr k and

368
00:11:40,880 --> 00:11:46,000
cause the underflow

369
00:11:43,279 --> 00:11:47,279
this kind of behavior is easy to miss by

370
00:11:46,000 --> 00:11:49,279
manual analysis which

371
00:11:47,279 --> 00:11:50,639
shows benefits of automated method like

372
00:11:49,279 --> 00:11:52,399
a arcade

373
00:11:50,639 --> 00:11:54,079
definitely archive solution is not

374
00:11:52,399 --> 00:11:56,880
perfect first it is

375
00:11:54,079 --> 00:11:58,319
incomplete unlike hip-hopper which is

376
00:11:56,880 --> 00:12:00,720
complete under its model

377
00:11:58,320 --> 00:12:02,639
however due to its scalability issue he

378
00:12:00,720 --> 00:12:05,279
purpose model cannot be complete

379
00:12:02,639 --> 00:12:07,040
second it can have overfitting issue our

380
00:12:05,279 --> 00:12:07,760
strategy might not work for certain

381
00:12:07,040 --> 00:12:09,680
allocator

382
00:12:07,760 --> 00:12:11,680
however in practice archives model is

383
00:12:09,680 --> 00:12:13,359
quite generic and discovers several heap

384
00:12:11,680 --> 00:12:16,160
exploitation techniques in different

385
00:12:13,360 --> 00:12:16,880
allocators finally archivally focuses on

386
00:12:16,160 --> 00:12:19,439
finding

387
00:12:16,880 --> 00:12:20,639
heap exploitation technique and does not

388
00:12:19,440 --> 00:12:23,760
generate end-to-end

389
00:12:20,639 --> 00:12:25,120
exploit like existing automatic exploit

390
00:12:23,760 --> 00:12:26,880
generation tool

391
00:12:25,120 --> 00:12:28,880
i want to conclude this though we have

392
00:12:26,880 --> 00:12:30,720
discussed the automatic ways to discover

393
00:12:28,880 --> 00:12:32,320
heap exploitation techniques using

394
00:12:30,720 --> 00:12:33,360
model-based search and shadow memory

395
00:12:32,320 --> 00:12:35,279
based detection

396
00:12:33,360 --> 00:12:36,959
as a result our clip discovered five new

397
00:12:35,279 --> 00:12:37,519
techniques in ptmallet2 and several

398
00:12:36,959 --> 00:12:39,518
everyone's

399
00:12:37,519 --> 00:12:40,959
in other allocators including die harder

400
00:12:39,519 --> 00:12:42,880
and the mi mat look secure

401
00:12:40,959 --> 00:12:44,959
we want to emphasize that our tool is

402
00:12:42,880 --> 00:12:46,560
released as an open source so please try

403
00:12:44,959 --> 00:12:48,000
arcade if you want to find the new type

404
00:12:46,560 --> 00:12:49,599
exploitation techniques in your all

405
00:12:48,000 --> 00:12:51,200
locators

406
00:12:49,600 --> 00:13:04,560
thank you if you have any questions i'm

407
00:12:51,200 --> 00:13:04,560
happy to answer them

