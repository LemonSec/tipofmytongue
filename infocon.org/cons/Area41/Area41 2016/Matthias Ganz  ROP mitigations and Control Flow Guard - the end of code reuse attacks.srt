1
00:00:09,190 --> 00:00:14,959
medications and control flow guard so

2
00:00:12,620 --> 00:00:16,790
you can expect something about code

3
00:00:14,960 --> 00:00:19,610
reuse text and give you a quick

4
00:00:16,790 --> 00:00:21,980
refresher then<font color="#E5E5E5"> I will talk about in its</font>

5
00:00:19,610 --> 00:00:25,820
<font color="#CCCCCC">growth educational techniques and</font>

6
00:00:21,980 --> 00:00:29,239
there's a third bullet point talk about

7
00:00:25,820 --> 00:00:33,230
<font color="#CCCCCC">Microsoft control Hobart the compiler</font>

8
00:00:29,239 --> 00:00:36,230
feature my name is Monty estas I'm CTO

9
00:00:33,230 --> 00:00:38,839
and co-founder oh it's for lab we<font color="#E5E5E5"> were</font>

10
00:00:36,230 --> 00:00:42,949
<font color="#E5E5E5">late espino rebuilding a software</font>

11
00:00:38,840 --> 00:00:46,490
product<font color="#E5E5E5"> detect fire based software</font>

12
00:00:42,950 --> 00:00:49,100
exploits you<font color="#E5E5E5"> probably heard of this</font>

13
00:00:46,490 --> 00:00:54,110
year's a pond to own competition it

14
00:00:49,100 --> 00:00:56,720
happened in march this year and all of

15
00:00:54,110 --> 00:01:00,200
the most<font color="#E5E5E5"> current browsers namely chrome</font>

16
00:00:56,720 --> 00:01:05,140
<font color="#E5E5E5">edge safari and with most current</font>

17
00:01:00,200 --> 00:01:08,780
security mitigations have been owned and

18
00:01:05,140 --> 00:01:13,670
system or root privilege has been

19
00:01:08,780 --> 00:01:17,600
achieved so attackers could execute

20
00:01:13,670 --> 00:01:20,450
arbitrary code as an attacker you do

21
00:01:17,600 --> 00:01:23,360
some before<font color="#CCCCCC"> you do the attacking you do</font>

22
00:01:20,450 --> 00:01:26,600
some basic math according<font color="#CCCCCC"> to Microsoft</font>

23
00:01:23,360 --> 00:01:29,780
you your attacker return so the money

24
00:01:26,600 --> 00:01:32,270
you actually get you calculate it by by

25
00:01:29,780 --> 00:01:34,460
<font color="#E5E5E5">the gains</font><font color="#CCCCCC"> peruse so how much money can</font>

26
00:01:32,270 --> 00:01:37,699
you steal with an attack times the

27
00:01:34,460 --> 00:01:40,899
number of thefts but of<font color="#E5E5E5"> course you have</font>

28
00:01:37,700 --> 00:01:44,330
some costs so you have initial costs to

29
00:01:40,900 --> 00:01:46,970
acquire maybe a vulnerability so either

30
00:01:44,330 --> 00:01:50,170
you do some may be fuzzy or you do

31
00:01:46,970 --> 00:01:53,179
static or dynamic analysis of your

32
00:01:50,170 --> 00:01:55,189
software you want to exploit and of

33
00:01:53,180 --> 00:02:01,369
<font color="#CCCCCC">course you need</font><font color="#E5E5E5"> to subtract the cost of</font>

34
00:01:55,189 --> 00:02:03,048
weaponizing the vulnerability then this

35
00:02:01,369 --> 00:02:06,890
is exactly the<font color="#CCCCCC"> point where v as the</font>

36
00:02:03,049 --> 00:02:11,659
defenders try to to raise the cost of an

37
00:02:06,890 --> 00:02:14,359
attack so such mitigations to raise

38
00:02:11,659 --> 00:02:18,649
costs it's a as already mentioned is a

39
00:02:14,359 --> 00:02:19,440
<font color="#CCCCCC">ms rope mitigations which are runtime</font>

40
00:02:18,650 --> 00:02:22,140
mitigation

41
00:02:19,440 --> 00:02:25,579
make<font color="#E5E5E5"> mitigations so you deploy these</font>

42
00:02:22,140 --> 00:02:29,160
mitigations<font color="#E5E5E5"> into arbitrary windows</font>

43
00:02:25,580 --> 00:02:30,990
processes and the<font color="#CCCCCC"> second mitigation is</font>

44
00:02:29,160 --> 00:02:33,570
control<font color="#E5E5E5"> flow guard this</font><font color="#CCCCCC"> is a</font>

45
00:02:30,990 --> 00:02:37,440
compile-time mitigation which is

46
00:02:33,570 --> 00:02:40,890
compiled into your program and then

47
00:02:37,440 --> 00:02:44,910
checked at runtime this requires some

48
00:02:40,890 --> 00:02:47,100
more or less recent<font color="#CCCCCC"> Windows versions but</font>

49
00:02:44,910 --> 00:02:48,810
before<font color="#CCCCCC"> we start</font><font color="#E5E5E5"> I give you a quick</font>

50
00:02:47,100 --> 00:02:51,060
refresher on<font color="#CCCCCC"> the data execution</font>

51
00:02:48,810 --> 00:02:55,080
prevention and address space layout

52
00:02:51,060 --> 00:02:59,850
randomization and how an attacker can

53
00:02:55,080 --> 00:03:02,460
<font color="#CCCCCC">bypass this so quick refresher so data</font>

54
00:02:59,850 --> 00:03:05,910
execution prevention what is it this is

55
00:03:02,460 --> 00:03:09,300
a you mark areas of<font color="#E5E5E5"> your virtual memory</font>

56
00:03:05,910 --> 00:03:12,090
you give it permission flags so

57
00:03:09,300 --> 00:03:13,860
typically you<font color="#CCCCCC"> have</font><font color="#E5E5E5"> a your code section</font>

58
00:03:12,090 --> 00:03:17,610
in your virtual memory is typically

59
00:03:13,860 --> 00:03:19,950
readable and executable your hip and

60
00:03:17,610 --> 00:03:24,780
stack is typically readable<font color="#E5E5E5"> rideable</font>

61
00:03:19,950 --> 00:03:28,350
<font color="#CCCCCC">sono so attackers who place code like on</font>

62
00:03:24,780 --> 00:03:31,590
the stack like this has been done some

63
00:03:28,350 --> 00:03:35,250
time ago this<font color="#E5E5E5"> doesn't work when you have</font>

64
00:03:31,590 --> 00:03:38,280
data execution prevention enabled but

65
00:03:35,250 --> 00:03:42,030
instead of placing code on a stack you

66
00:03:38,280 --> 00:03:44,070
do where so-called code reuse attacks<font color="#E5E5E5"> so</font>

67
00:03:42,030 --> 00:03:47,220
there is<font color="#E5E5E5"> various techniques you can do</font>

68
00:03:44,070 --> 00:03:48,959
return to<font color="#E5E5E5"> leap attacks or the more</font>

69
00:03:47,220 --> 00:03:51,359
generic form of this is a return

70
00:03:48,959 --> 00:03:55,920
oriented programming I will get<font color="#CCCCCC"> to this</font>

71
00:03:51,360 --> 00:03:58,350
<font color="#E5E5E5">and a similar form but a form which</font>

72
00:03:55,920 --> 00:04:01,670
doesn't rely return instructions is a

73
00:03:58,350 --> 00:04:05,670
jump or call oriented programming and

74
00:04:01,670 --> 00:04:09,720
the basic idea is to<font color="#CCCCCC"> use like existing</font>

75
00:04:05,670 --> 00:04:13,470
code until you can as an attacker until

76
00:04:09,720 --> 00:04:16,769
you can make a call<font color="#E5E5E5"> to some functions</font>

77
00:04:13,470 --> 00:04:19,560
like memory functions which change the

78
00:04:16,769 --> 00:04:22,260
protection flags of your memory so

79
00:04:19,560 --> 00:04:26,310
typically<font color="#E5E5E5"> your do you do return oriented</font>

80
00:04:22,260 --> 00:04:29,130
programming until you find a call to

81
00:04:26,310 --> 00:04:32,550
maybe virtual protect and then you can

82
00:04:29,130 --> 00:04:33,590
mark any piece of<font color="#E5E5E5"> memory you want</font>

83
00:04:32,550 --> 00:04:36,479
executable

84
00:04:33,590 --> 00:04:39,810
so return oriented programming how does

85
00:04:36,479 --> 00:04:43,889
it work you have a<font color="#E5E5E5"> so-called Rope</font>

86
00:04:39,810 --> 00:04:46,110
catches these are arbitrary sequences of

87
00:04:43,889 --> 00:04:49,080
instructions which<font color="#E5E5E5"> end with a return</font>

88
00:04:46,110 --> 00:04:52,650
instructions so for instance these three

89
00:04:49,080 --> 00:04:55,229
<font color="#E5E5E5">guys and return oriented programming</font>

90
00:04:52,650 --> 00:05:01,138
just puts the start addresses of these

91
00:04:55,229 --> 00:05:02,729
gadgets to a memory locations and like

92
00:05:01,139 --> 00:05:08,039
an attacker<font color="#E5E5E5"> can craft like a puzzle</font>

93
00:05:02,729 --> 00:05:16,289
craft its own functionality by using

94
00:05:08,039 --> 00:05:21,030
already loaded code so how does a SLR

95
00:05:16,289 --> 00:05:23,190
work how<font color="#E5E5E5"> to bypass our seller so address</font>

96
00:05:21,030 --> 00:05:26,039
space<font color="#CCCCCC"> layout randomization this is where</font>

97
00:05:23,190 --> 00:05:30,000
we randomly place stuff at different

98
00:05:26,039 --> 00:05:33,539
locations so by passing it you may think

99
00:05:30,000 --> 00:05:36,060
of if there<font color="#E5E5E5"> is a weak implementation of</font>

100
00:05:33,539 --> 00:05:40,469
ISIL are you can just try to<font color="#CCCCCC"> brute-force</font>

101
00:05:36,060 --> 00:05:44,009
it or you try to construct construct a

102
00:05:40,469 --> 00:05:47,580
memory leak leak some addresses of some

103
00:05:44,009 --> 00:05:49,800
useful functions or depending on the

104
00:05:47,580 --> 00:05:51,870
application you<font color="#E5E5E5"> want to attack you can</font>

105
00:05:49,800 --> 00:05:54,690
force the application into some

106
00:05:51,870 --> 00:05:59,550
predictable memory state by for instance

107
00:05:54,690 --> 00:06:01,800
applying memory pressure and other

108
00:05:59,550 --> 00:06:06,110
<font color="#CCCCCC">techniques is it's like pointer in</font>

109
00:06:01,800 --> 00:06:08,909
feirense or you can try to not use the

110
00:06:06,110 --> 00:06:12,719
randomized parts of your addresses in

111
00:06:08,909 --> 00:06:16,379
your gadgets so this would be you avoid

112
00:06:12,719 --> 00:06:18,960
<font color="#E5E5E5">using exact addresses and these both</font>

113
00:06:16,379 --> 00:06:20,509
techniques data execution prevention and

114
00:06:18,960 --> 00:06:24,330
address space layout randomization

115
00:06:20,509 --> 00:06:27,839
station these are rather generic defense

116
00:06:24,330 --> 00:06:35,128
techniques and are widely adopted in x86

117
00:06:27,839 --> 00:06:37,139
world so this is exploit exploit riding

118
00:06:35,129 --> 00:06:40,800
has become harder through these

119
00:06:37,139 --> 00:06:44,099
techniques for like most classes of

120
00:06:40,800 --> 00:06:47,190
attacks and together if implemented

121
00:06:44,099 --> 00:06:50,310
right<font color="#CCCCCC"> the this is quite an effective</font>

122
00:06:47,190 --> 00:06:52,650
defense mechanism but as we've seen<font color="#CCCCCC"> in</font>

123
00:06:50,310 --> 00:06:58,770
<font color="#E5E5E5">the pond to own slider it's not</font>

124
00:06:52,650 --> 00:07:01,590
effective enough so how how do we

125
00:06:58,770 --> 00:07:05,820
measure<font color="#CCCCCC"> the security of an egg exploit</font>

126
00:07:01,590 --> 00:07:08,070
mitigation or how much of how<font color="#E5E5E5"> much do we</font>

127
00:07:05,820 --> 00:07:11,580
increase the<font color="#E5E5E5"> cost of an attack when we</font>

128
00:07:08,070 --> 00:07:13,980
enable specific security features so

129
00:07:11,580 --> 00:07:17,609
quantifying this stuff is is rather

130
00:07:13,980 --> 00:07:22,080
difficult and academia as well seems to

131
00:07:17,610 --> 00:07:24,060
<font color="#E5E5E5">somehow struggle with this question</font><font color="#CCCCCC"> for</font>

132
00:07:22,080 --> 00:07:27,229
this talk we tried a different more

133
00:07:24,060 --> 00:07:32,550
practical approach we constructed a

134
00:07:27,230 --> 00:07:35,130
program an exploitable program and try

135
00:07:32,550 --> 00:07:38,520
it out how hard it gets<font color="#E5E5E5"> when we enable</font>

136
00:07:35,130 --> 00:07:41,630
specific security features like<font color="#E5E5E5"> emit</font>

137
00:07:38,520 --> 00:07:45,840
rope mitigations or control flow guard

138
00:07:41,630 --> 00:07:48,510
so we hope to understand these

139
00:07:45,840 --> 00:07:51,719
<font color="#E5E5E5">mitigations better so let's start with</font>

140
00:07:48,510 --> 00:07:54,390
code reuse attacks first the example we

141
00:07:51,720 --> 00:07:57,480
created a an example<font color="#CCCCCC"> program we call it</font>

142
00:07:54,390 --> 00:08:01,669
mainframe inventory this<font color="#E5E5E5"> is a vulnerable</font>

143
00:07:57,480 --> 00:08:04,440
C++ program<font color="#CCCCCC"> it's exploitable by design</font>

144
00:08:01,669 --> 00:08:06,060
but still as an attacker you need still

145
00:08:04,440 --> 00:08:08,580
need to bypass address space layout

146
00:08:06,060 --> 00:08:12,870
randomization and data execution

147
00:08:08,580 --> 00:08:17,729
prevention so we created this mainframe

148
00:08:12,870 --> 00:08:20,460
inventory program as a 64-bit program we

149
00:08:17,730 --> 00:08:24,419
compiled it with with visual studio try

150
00:08:20,460 --> 00:08:26,640
to the 2015 on Windows 10 and what it

151
00:08:24,419 --> 00:08:31,159
basically does we keep a link linked

152
00:08:26,640 --> 00:08:36,809
list<font color="#CCCCCC"> of</font><font color="#E5E5E5"> of programs of arbitrary object</font>

153
00:08:31,160 --> 00:08:41,400
and maintain this list and expose a HTTP

154
00:08:36,809 --> 00:08:45,239
interface to clients so this HTTP

155
00:08:41,400 --> 00:08:48,089
interface with this you can<font color="#E5E5E5"> do you can</font>

156
00:08:45,240 --> 00:08:52,650
<font color="#E5E5E5">create new programs or list them or</font>

157
00:08:48,089 --> 00:08:55,589
<font color="#E5E5E5">start programs so for instance this HTTP</font>

158
00:08:52,650 --> 00:08:59,569
<font color="#CCCCCC">request would create a new program with</font>

159
00:08:55,589 --> 00:08:59,570
some specific ID

160
00:08:59,670 --> 00:09:06,459
so this<font color="#CCCCCC"> is how the the program class</font>

161
00:09:02,950 --> 00:09:10,240
looks like so we have a few attributes

162
00:09:06,459 --> 00:09:14,079
like status ID the length of ID

163
00:09:10,240 --> 00:09:16,540
indicates the number of<font color="#E5E5E5"> bytes which are</font>

164
00:09:14,080 --> 00:09:19,269
rallied in this<font color="#E5E5E5"> idea ray then we have</font><font color="#CCCCCC"> a</font>

165
00:09:16,540 --> 00:09:21,819
pointer to a state buffer and again a

166
00:09:19,269 --> 00:09:24,940
state size which indicates this number

167
00:09:21,820 --> 00:09:27,070
of valid bytes in state buffer and the

168
00:09:24,940 --> 00:09:30,220
pointer to the next enter in our linked

169
00:09:27,070 --> 00:09:34,769
list and of<font color="#CCCCCC"> course we have some fancy</font>

170
00:09:30,220 --> 00:09:38,310
method which is by by accident virtual

171
00:09:34,769 --> 00:09:42,880
<font color="#CCCCCC">in-memory this looks like this we have a</font>

172
00:09:38,310 --> 00:09:46,719
the the<font color="#E5E5E5"> object p 1 we have a pointer to</font>

173
00:09:42,880 --> 00:09:52,439
the v table of<font color="#CCCCCC"> the program and then the</font>

174
00:09:46,720 --> 00:09:55,769
attributes follow so an example request

175
00:09:52,440 --> 00:09:59,410
like this would this would create a new

176
00:09:55,769 --> 00:10:01,329
program object with a<font color="#E5E5E5"> good</font><font color="#CCCCCC"> creedon</font>

177
00:09:59,410 --> 00:10:06,430
approaching program object with some

178
00:10:01,329 --> 00:10:09,219
specific ID and some specific state we

179
00:10:06,430 --> 00:10:12,209
can define as a client so in memory this

180
00:10:09,220 --> 00:10:16,350
looks like this we have the attributes

181
00:10:12,209 --> 00:10:20,500
here we have a pointer to the<font color="#CCCCCC"> v table of</font>

182
00:10:16,350 --> 00:10:23,110
program what an importance i know this v

183
00:10:20,500 --> 00:10:26,680
table is located in<font color="#CCCCCC"> the read-only data</font>

184
00:10:23,110 --> 00:10:28,750
section of<font color="#CCCCCC"> the executable and here the</font>

185
00:10:26,680 --> 00:10:36,060
first entry of the<font color="#E5E5E5"> v table is the</font>

186
00:10:28,750 --> 00:10:39,310
program's main method so we have some

187
00:10:36,060 --> 00:10:42,430
pointer to state buffer so there<font color="#E5E5E5"> is some</font>

188
00:10:39,310 --> 00:10:47,199
some more data which<font color="#CCCCCC"> we can control as a</font>

189
00:10:42,430 --> 00:10:49,810
client so but you already think this may

190
00:10:47,199 --> 00:10:53,829
look fishy so why the heck can<font color="#E5E5E5"> we set</font>

191
00:10:49,810 --> 00:10:57,430
the ID length so the programmer forget

192
00:10:53,829 --> 00:11:01,149
to forgot to check ID length so as an

193
00:10:57,430 --> 00:11:05,010
attacker we can we have control over the

194
00:11:01,149 --> 00:11:07,810
length of this ID field which is<font color="#E5E5E5"> which</font>

195
00:11:05,010 --> 00:11:10,660
indicates a number of bytes in your ID

196
00:11:07,810 --> 00:11:12,250
buffer which has a fixed size of<font color="#E5E5E5"> eight</font>

197
00:11:10,660 --> 00:11:15,969
<font color="#E5E5E5">in this example</font>

198
00:11:12,250 --> 00:11:17,980
so if if an attacker provides an ideal

199
00:11:15,970 --> 00:11:22,750
length bigger than<font color="#CCCCCC"> eight we can read and</font>

200
00:11:17,980 --> 00:11:24,580
<font color="#CCCCCC">write after this ID memory section so</font>

201
00:11:22,750 --> 00:11:27,100
what do we<font color="#E5E5E5"> get</font><font color="#CCCCCC"> out of this we can leak</font>

202
00:11:24,580 --> 00:11:30,520
memory we can construct an arbitrary

203
00:11:27,100 --> 00:11:32,950
read we can deliver some payload week

204
00:11:30,520 --> 00:11:35,500
and<font color="#E5E5E5"> eventually we can hijack control</font>

205
00:11:32,950 --> 00:11:39,220
flow so how do<font color="#E5E5E5"> we do this how</font><font color="#CCCCCC"> do we leak</font>

206
00:11:35,500 --> 00:11:42,880
the memory so we could set ID length to

207
00:11:39,220 --> 00:11:46,570
32 so this would allow us<font color="#E5E5E5"> to read and</font>

208
00:11:42,880 --> 00:11:50,140
<font color="#CCCCCC">write the read stuff which is</font><font color="#E5E5E5"> indicated</font>

209
00:11:46,570 --> 00:11:53,580
in<font color="#E5E5E5"> blue writing stuff would do the other</font>

210
00:11:50,140 --> 00:11:56,290
thing so arbitrary an arbiter read would

211
00:11:53,580 --> 00:11:59,830
to have an arbitrary read we would set

212
00:11:56,290 --> 00:12:01,449
ID length to 24 assign the number of

213
00:11:59,830 --> 00:12:03,880
bytes we want to read assign it to

214
00:12:01,450 --> 00:12:06,180
straight size and the point driven to

215
00:12:03,880 --> 00:12:09,280
read we will design<font color="#E5E5E5"> two state buffer and</font>

216
00:12:06,180 --> 00:12:13,180
reading the state would then like read

217
00:12:09,280 --> 00:12:15,670
our desired memory address delivering

218
00:12:13,180 --> 00:12:17,920
payload also is easy we<font color="#CCCCCC"> just</font><font color="#E5E5E5"> used this</font>

219
00:12:15,670 --> 00:12:21,520
<font color="#CCCCCC">state buffer to deliver arbitrary</font>

220
00:12:17,920 --> 00:12:25,110
payload and we can use the memory leak

221
00:12:21,520 --> 00:12:27,339
to read the address of<font color="#CCCCCC"> the state buffer</font>

222
00:12:25,110 --> 00:12:29,740
so how do we do the control flow

223
00:12:27,339 --> 00:12:32,770
hijacking we use if we could create a

224
00:12:29,740 --> 00:12:36,490
fake object which would look like this

225
00:12:32,770 --> 00:12:39,750
we could give<font color="#CCCCCC"> it a fake V table and the</font>

226
00:12:36,490 --> 00:12:45,460
first<font color="#CCCCCC"> V table entry would</font><font color="#E5E5E5"> point to our</font>

227
00:12:39,750 --> 00:12:48,910
escape location so let's try<font color="#E5E5E5"> to</font>

228
00:12:45,460 --> 00:12:53,920
construct<font color="#E5E5E5"> this fake fake object we have</font>

229
00:12:48,910 --> 00:12:57,969
a a same object p<font color="#CCCCCC"> one in the state</font>

230
00:12:53,920 --> 00:13:00,760
<font color="#E5E5E5">buffer we place our fake vtable we</font>

231
00:12:57,970 --> 00:13:03,880
create another buffer with our fake

232
00:13:00,760 --> 00:13:06,460
object which not now knows the address

233
00:13:03,880 --> 00:13:10,089
to the v table we previously leaked so

234
00:13:06,460 --> 00:13:13,570
we have constructed<font color="#E5E5E5"> the fake object when</font>

235
00:13:10,089 --> 00:13:16,570
we update the next pointer we can

236
00:13:13,570 --> 00:13:21,150
successfully<font color="#E5E5E5"> insert the this new fake</font>

237
00:13:16,570 --> 00:13:24,600
object into the list of programs objects

238
00:13:21,150 --> 00:13:28,449
so hijacking control flow is just

239
00:13:24,600 --> 00:13:33,610
calling the virtual method of this fake

240
00:13:28,450 --> 00:13:38,560
object so this would then be some<font color="#E5E5E5"> auto</font>

241
00:13:33,610 --> 00:13:41,320
<font color="#E5E5E5">type a request in this example so but</font>

242
00:13:38,560 --> 00:13:43,000
still we need to bypass data execution

243
00:13:41,320 --> 00:13:46,089
prevention and address space layout

244
00:13:43,000 --> 00:13:48,880
randomization this needs the following

245
00:13:46,089 --> 00:13:51,010
steps at first we need to leak some base

246
00:13:48,880 --> 00:13:54,450
addresses of some libraries we want to

247
00:13:51,010 --> 00:13:58,450
use code from we need to deliver our

248
00:13:54,450 --> 00:14:01,600
shellcode we need to level the rope

249
00:13:58,450 --> 00:14:05,290
chain we need two hijacked control flow

250
00:14:01,600 --> 00:14:08,170
to our first rope gadget do some stack

251
00:14:05,290 --> 00:14:10,480
pivoting and then our rope chain will

252
00:14:08,170 --> 00:14:13,329
call virtual pro txt and marks the

253
00:14:10,480 --> 00:14:16,990
payload executable and then we can

254
00:14:13,330 --> 00:14:18,970
return<font color="#E5E5E5"> to our shellcode so how do we</font>

255
00:14:16,990 --> 00:14:22,780
leak the base addresses of our libraries

256
00:14:18,970 --> 00:14:27,100
so if you have two objects<font color="#E5E5E5"> next pointer</font>

257
00:14:22,780 --> 00:14:29,920
points to the<font color="#CCCCCC"> next object which at the</font>

258
00:14:27,100 --> 00:14:32,980
offset 0 has the<font color="#CCCCCC"> V table so we</font><font color="#E5E5E5"> just</font>

259
00:14:29,920 --> 00:14:38,410
follow this V table pointer and we will

260
00:14:32,980 --> 00:14:40,360
find the address of<font color="#CCCCCC"> the main function in</font>

261
00:14:38,410 --> 00:14:43,390
the executable since we<font color="#E5E5E5"> know the</font>

262
00:14:40,360 --> 00:14:46,390
<font color="#E5E5E5">executable we can calculate the offset</font>

263
00:14:43,390 --> 00:14:49,589
we know the offset of this main function

264
00:14:46,390 --> 00:14:54,130
in the executable because this is static

265
00:14:49,589 --> 00:14:56,339
we can derive the randomized we can

266
00:14:54,130 --> 00:14:59,020
derive the randomized base address and

267
00:14:56,339 --> 00:15:01,959
this gives us the image<font color="#E5E5E5"> base address</font>

268
00:14:59,020 --> 00:15:05,470
with this base address we we can read

269
00:15:01,959 --> 00:15:08,349
the import address table of the<font color="#CCCCCC"> dis</font>

270
00:15:05,470 --> 00:15:11,410
executable and in our example we have

271
00:15:08,350 --> 00:15:14,020
like imports as we use functions this

272
00:15:11,410 --> 00:15:18,060
executable users functions from in this

273
00:15:14,020 --> 00:15:23,829
example kernel32 and some<font color="#E5E5E5"> CPP rest</font>

274
00:15:18,060 --> 00:15:26,140
library so we can leak more addresses so

275
00:15:23,830 --> 00:15:30,730
with this<font color="#E5E5E5"> we can say address space</font>

276
00:15:26,140 --> 00:15:34,120
layout randomization is bypassed exploit

277
00:15:30,730 --> 00:15:36,640
delivery is in<font color="#E5E5E5"> an example example quite</font>

278
00:15:34,120 --> 00:15:38,470
easy we<font color="#CCCCCC"> just use this state buffer and</font>

279
00:15:36,640 --> 00:15:45,189
<font color="#CCCCCC">lick the address of the</font><font color="#E5E5E5"> state</font>

280
00:15:38,470 --> 00:15:48,910
offer for<font color="#CCCCCC"> this inventory example we</font>

281
00:15:45,190 --> 00:15:54,280
created the shellcode with metasploit we

282
00:15:48,910 --> 00:15:58,300
use a<font color="#CCCCCC"> Windows xik shellcode with which</font>

283
00:15:54,280 --> 00:16:01,089
pops a conch yeah so this<font color="#CCCCCC"> is standard</font>

284
00:15:58,300 --> 00:16:04,569
generated code then the rope chain is

285
00:16:01,090 --> 00:16:07,630
also pretty straightforward we do some

286
00:16:04,570 --> 00:16:11,500
we use some basic gadgets to prepare our

287
00:16:07,630 --> 00:16:14,950
arguments like this prepares argument<font color="#CCCCCC"> 0</font>

288
00:16:11,500 --> 00:16:18,880
argument 1 etc here you for instance you

289
00:16:14,950 --> 00:16:21,520
see the third argument to virtual

290
00:16:18,880 --> 00:16:28,320
protect and eventually we call virtual

291
00:16:21,520 --> 00:16:32,620
protect and return to the shellcode so

292
00:16:28,320 --> 00:16:35,830
how do<font color="#E5E5E5"> we actually then hijack control</font>

293
00:16:32,620 --> 00:16:40,180
flow you have the this is the<font color="#E5E5E5"> call site</font>

294
00:16:35,830 --> 00:16:42,970
which we want to hijack so if you look

295
00:16:40,180 --> 00:16:47,050
closely this is the these points then to

296
00:16:42,970 --> 00:16:49,390
our fake object the fake object the

297
00:16:47,050 --> 00:16:52,120
pointer is dereferenced and now<font color="#E5E5E5"> Rex</font>

298
00:16:49,390 --> 00:16:54,939
points to the<font color="#E5E5E5"> V table and eventually we</font>

299
00:16:52,120 --> 00:17:01,750
call the<font color="#E5E5E5"> first entry in the V table and</font>

300
00:16:54,940 --> 00:17:05,230
so controls<font color="#CCCCCC"> all gets hijacked our first</font>

301
00:17:01,750 --> 00:17:08,310
target after hijacking is a so-called

302
00:17:05,230 --> 00:17:12,069
stack pivoting gadget we try to get

303
00:17:08,310 --> 00:17:14,919
control over the stack pointer so the

304
00:17:12,069 --> 00:17:16,359
first gadget looks like this when you

305
00:17:14,920 --> 00:17:19,960
remain as<font color="#CCCCCC"> you remember from</font><font color="#E5E5E5"> the previous</font>

306
00:17:16,359 --> 00:17:22,990
slide racks contained the<font color="#E5E5E5"> V table</font>

307
00:17:19,960 --> 00:17:25,270
address so this would load the second

308
00:17:22,990 --> 00:17:29,620
entry of your retail and put it into<font color="#E5E5E5"> the</font>

309
00:17:25,270 --> 00:17:31,720
stack pointer so if we put our the

310
00:17:29,620 --> 00:17:35,189
address of our rope chain into the

311
00:17:31,720 --> 00:17:39,850
second entry of our fake v table we can

312
00:17:35,190 --> 00:17:42,670
like we can people the stack pointer to

313
00:17:39,850 --> 00:17:45,399
our rope chain so this will happen so

314
00:17:42,670 --> 00:17:50,320
the exploitation in pictures we<font color="#E5E5E5"> have a</font>

315
00:17:45,400 --> 00:17:51,590
<font color="#E5E5E5">normal cold normal stack we deliver the</font>

316
00:17:50,320 --> 00:17:54,610
shellcode

317
00:17:51,590 --> 00:17:57,020
the heap this is non executable code

318
00:17:54,610 --> 00:18:01,219
then we deliver the rope chain also

319
00:17:57,020 --> 00:18:04,158
non-executable then we hijack control

320
00:18:01,220 --> 00:18:06,230
flow p vote the stack to point to the

321
00:18:04,159 --> 00:18:11,179
<font color="#E5E5E5">rope chain the rope chain gets executed</font>

322
00:18:06,230 --> 00:18:14,510
and eventually we end up in a virtual

323
00:18:11,179 --> 00:18:17,120
protect call which marks the code the

324
00:18:14,510 --> 00:18:20,539
shellcode executable and then execute

325
00:18:17,120 --> 00:18:24,289
our shellcode so data execution

326
00:18:20,539 --> 00:18:27,169
prevention is also bypassed this is some

327
00:18:24,289 --> 00:18:32,770
screenshot of our demo program we could

328
00:18:27,169 --> 00:18:35,809
pop cog so next next topic let's enable

329
00:18:32,770 --> 00:18:41,090
let's enable<font color="#E5E5E5"> Rob mitigations for our</font>

330
00:18:35,809 --> 00:18:43,490
exploit so what<font color="#E5E5E5"> is what is Emmett before</font>

331
00:18:41,090 --> 00:18:47,559
we<font color="#E5E5E5"> start like Emmett was introduced in</font>

332
00:18:43,490 --> 00:18:51,470
2009 and the most<font color="#E5E5E5"> current version is a</font>

333
00:18:47,559 --> 00:18:56,178
5.5 and then was released the end of

334
00:18:51,470 --> 00:18:59,090
January this year so Emmett implements

335
00:18:56,179 --> 00:19:00,649
various security related features and

336
00:18:59,090 --> 00:19:05,120
hardening techniques which you can apply

337
00:19:00,649 --> 00:19:08,750
to arbitrary processes on your<font color="#E5E5E5"> Windows</font>

338
00:19:05,120 --> 00:19:11,779
desktop machine but for this top we will

339
00:19:08,750 --> 00:19:15,049
focus only on Rob related mitigations

340
00:19:11,779 --> 00:19:18,340
this is the m8 config<font color="#E5E5E5"> we if you don't</font>

341
00:19:15,049 --> 00:19:22,129
know it so you can you can configure

342
00:19:18,340 --> 00:19:25,789
processes processes to be guarded and

343
00:19:22,130 --> 00:19:29,000
you can enable specific security checks

344
00:19:25,789 --> 00:19:32,840
for your processes so we wrote

345
00:19:29,000 --> 00:19:36,620
mitigations are these stuff in the boxes

346
00:19:32,840 --> 00:19:38,360
we will focus on this the<font color="#CCCCCC"> rock</font>

347
00:19:36,620 --> 00:19:43,580
mitigations were introduced it

348
00:19:38,360 --> 00:19:46,879
introduced to through Rob card<font color="#E5E5E5"> rock</font>

349
00:19:43,580 --> 00:19:49,428
guard was<font color="#E5E5E5"> the</font><font color="#CCCCCC"> Microsoft blue hat one</font>

350
00:19:46,880 --> 00:19:52,669
microsoft blue hat price and this<font color="#CCCCCC"> Rob</font>

351
00:19:49,429 --> 00:19:57,710
card was integrated into Emmett firstly

352
00:19:52,669 --> 00:20:00,679
integrated to<font color="#CCCCCC"> Emmett 3.5 if you know</font>

353
00:19:57,710 --> 00:20:05,149
<font color="#E5E5E5">Amit there is some rope mitigations</font>

354
00:20:00,679 --> 00:20:05,900
which are only available for 32-bit so

355
00:20:05,149 --> 00:20:07,580
so

356
00:20:05,900 --> 00:20:10,190
of the<font color="#E5E5E5"> Rope mitigations namely the</font>

357
00:20:07,580 --> 00:20:14,780
<font color="#CCCCCC">caller checks and simulated execution</font>

358
00:20:10,190 --> 00:20:17,390
flow is not available for<font color="#E5E5E5"> 64-bit but</font>

359
00:20:14,780 --> 00:20:22,730
before<font color="#CCCCCC"> we</font><font color="#E5E5E5"> continue how does omit the</font>

360
00:20:17,390 --> 00:20:25,460
hooking so Emmett inject a dll into

361
00:20:22,730 --> 00:20:28,990
every process you want to have secured

362
00:20:25,460 --> 00:20:33,500
so it injects a dll and then hooks into

363
00:20:28,990 --> 00:20:36,110
sensitive<font color="#E5E5E5"> api calls so this sensitive</font>

364
00:20:33,500 --> 00:20:38,270
api calls our virtual<font color="#E5E5E5"> protec</font><font color="#CCCCCC"> load</font>

365
00:20:36,110 --> 00:20:41,889
<font color="#CCCCCC">library createprocess etc there are</font>

366
00:20:38,270 --> 00:20:46,940
about<font color="#E5E5E5"> I think 50 functions which are</font>

367
00:20:41,890 --> 00:20:50,510
protected by a<font color="#CCCCCC"> mint so if we talk about</font>

368
00:20:46,940 --> 00:20:53,210
<font color="#CCCCCC">Rob mitigations there is rather a rope</font>

369
00:20:50,510 --> 00:20:57,230
detection<font color="#E5E5E5"> than rope prevention because</font>

370
00:20:53,210 --> 00:21:02,330
the<font color="#CCCCCC"> Rope checks are only done when</font><font color="#E5E5E5"> you</font>

371
00:20:57,230 --> 00:21:05,750
call these critical API functions so how

372
00:21:02,330 --> 00:21:09,080
does an m8 look look like if you call

373
00:21:05,750 --> 00:21:11,030
for instance virtual protect and you if

374
00:21:09,080 --> 00:21:14,810
you follow the debugger you will notice

375
00:21:11,030 --> 00:21:18,170
a weird jump at this symbol so this is<font color="#CCCCCC"> a</font>

376
00:21:14,810 --> 00:21:21,919
ma took<font color="#E5E5E5"> this jumps to some dynamically</font>

377
00:21:18,170 --> 00:21:24,890
generated code if you<font color="#E5E5E5"> do some more</font>

378
00:21:21,920 --> 00:21:27,980
debugging you will see that the m8 code

379
00:21:24,890 --> 00:21:33,610
eventually jumps back to the code you

380
00:21:27,980 --> 00:21:37,340
wanna have called and this next location

381
00:21:33,610 --> 00:21:41,179
has another<font color="#E5E5E5"> m8 hook and there is like on</font>

382
00:21:37,340 --> 00:21:44,510
every<font color="#E5E5E5"> level of API call there is this</font>

383
00:21:41,180 --> 00:21:47,140
Emma talk<font color="#E5E5E5"> even for the right before the</font>

384
00:21:44,510 --> 00:21:51,950
system call so even system<font color="#E5E5E5"> calls are</font>

385
00:21:47,140 --> 00:21:55,430
guarded by<font color="#CCCCCC"> Amit so this</font><font color="#E5E5E5"> is a</font><font color="#CCCCCC"> mhd poking</font>

386
00:21:51,950 --> 00:21:58,850
and it prevents an attacker from just

387
00:21:55,430 --> 00:22:01,310
skipping over some hook and like call

388
00:21:58,850 --> 00:22:06,260
the next<font color="#E5E5E5"> lower function this should</font>

389
00:22:01,310 --> 00:22:08,659
prevent this so these<font color="#CCCCCC"> Rob mitigations</font>

390
00:22:06,260 --> 00:22:11,270
let's start<font color="#CCCCCC"> with the first mitigation</font>

391
00:22:08,660 --> 00:22:14,410
term memory protection mitigation this

392
00:22:11,270 --> 00:22:17,980
is fairly easy you just MHS this allows

393
00:22:14,410 --> 00:22:19,580
the program for marking the thread stack

394
00:22:17,980 --> 00:22:22,550
executable

395
00:22:19,580 --> 00:22:25,669
so placing your shellcode on a stack and

396
00:22:22,550 --> 00:22:32,290
market executable will not work anymore

397
00:22:25,670 --> 00:22:35,770
and the next mitigation color checks

398
00:22:32,290 --> 00:22:38,180
during an ongoing a rope attack

399
00:22:35,770 --> 00:22:41,360
functions are not called but they're

400
00:22:38,180 --> 00:22:44,810
rather returned<font color="#E5E5E5"> in two so Emmett checks</font>

401
00:22:41,360 --> 00:22:50,479
the call site if there<font color="#E5E5E5"> is actually a</font>

402
00:22:44,810 --> 00:22:52,940
call instruction so when<font color="#E5E5E5"> Emma does the</font>

403
00:22:50,480 --> 00:22:55,820
check it<font color="#E5E5E5"> checks the stack pointer like</font>

404
00:22:52,940 --> 00:22:57,980
it checks the top of stack reads the

405
00:22:55,820 --> 00:23:00,129
return address follows the return

406
00:22:57,980 --> 00:23:04,880
address and checks<font color="#E5E5E5"> the previous function</font>

407
00:23:00,130 --> 00:23:07,010
whether this is a a valid call to the

408
00:23:04,880 --> 00:23:12,350
hooked function so it<font color="#E5E5E5"> checks is this</font>

409
00:23:07,010 --> 00:23:16,060
really virtual protect call then the

410
00:23:12,350 --> 00:23:18,320
next<font color="#E5E5E5"> step mitigation is a simulated</font>

411
00:23:16,060 --> 00:23:21,889
execution flow and according to

412
00:23:18,320 --> 00:23:24,860
<font color="#E5E5E5">documentation this should detect a rope</font>

413
00:23:21,890 --> 00:23:27,860
gadget following a call to a protected

414
00:23:24,860 --> 00:23:31,490
API so this we're not hundred percent

415
00:23:27,860 --> 00:23:34,340
sure<font color="#E5E5E5"> what it really does but it seems to</font>

416
00:23:31,490 --> 00:23:37,610
simulate instructions affecting the

417
00:23:34,340 --> 00:23:42,679
stack and<font color="#CCCCCC"> the base pointer and does some</font>

418
00:23:37,610 --> 00:23:46,270
sanity checks on them so next mitigation

419
00:23:42,680 --> 00:23:49,450
is<font color="#CCCCCC"> tag pivoting m8 just checks if the</font>

420
00:23:46,270 --> 00:23:52,790
stack pointer is within<font color="#CCCCCC"> the bounds of</font>

421
00:23:49,450 --> 00:23:57,260
the stack which is a of the<font color="#E5E5E5"> expected</font>

422
00:23:52,790 --> 00:24:06,260
stack so<font color="#E5E5E5"> ma detects any deviation like</font>

423
00:23:57,260 --> 00:24:08,360
stack pivoting attack attempts the next

424
00:24:06,260 --> 00:24:12,020
<font color="#E5E5E5">mitigation is a export address table</font>

425
00:24:08,360 --> 00:24:16,939
access filtering this is not<font color="#E5E5E5"> really an</font><font color="#CCCCCC"> n</font>

426
00:24:12,020 --> 00:24:21,850
<font color="#CCCCCC">rob mitigation but it makes lot a lot of</font>

427
00:24:16,940 --> 00:24:25,520
off-the-shelf code like<font color="#CCCCCC"> metasploit the</font>

428
00:24:21,850 --> 00:24:28,490
exploits makes a<font color="#CCCCCC"> it prevents them</font>

429
00:24:25,520 --> 00:24:31,580
because<font color="#CCCCCC"> are</font><font color="#E5E5E5"> the export address table</font>

430
00:24:28,490 --> 00:24:32,550
access fielding it checks read<font color="#E5E5E5"> accesses</font>

431
00:24:31,580 --> 00:24:35,520
to

432
00:24:32,550 --> 00:24:38,520
the export address table of<font color="#E5E5E5"> the three</font>

433
00:24:35,520 --> 00:24:42,240
critical system libraries so it checks

434
00:24:38,520 --> 00:24:45,510
access to kernel32 and the<font color="#E5E5E5"> dlm</font><font color="#CCCCCC"> colonel</font>

435
00:24:42,240 --> 00:24:48,450
base so whenever<font color="#E5E5E5"> someone wants</font><font color="#CCCCCC"> to read a</font>

436
00:24:45,510 --> 00:24:53,070
few bites of this export address table

437
00:24:48,450 --> 00:24:57,140
of<font color="#CCCCCC"> the three functions it ma triggers so</font>

438
00:24:53,070 --> 00:25:02,010
<font color="#E5E5E5">Emma tosses by inserting hardware</font>

439
00:24:57,140 --> 00:25:05,100
<font color="#CCCCCC">breakpoints and</font><font color="#E5E5E5"> then there is</font><font color="#CCCCCC"> a a I've</font>

440
00:25:02,010 --> 00:25:07,860
<font color="#CCCCCC">closed which is some black listing of</font>

441
00:25:05,100 --> 00:25:10,590
specific module modules to further

442
00:25:07,860 --> 00:25:15,479
prevent reading of this export address

443
00:25:10,590 --> 00:25:18,570
table and recently there<font color="#CCCCCC"> are and being</font>

444
00:25:15,480 --> 00:25:23,130
been a lot of talks and publications

445
00:25:18,570 --> 00:25:25,409
about<font color="#E5E5E5"> Emmett bypasses so you can read up</font>

446
00:25:23,130 --> 00:25:28,770
on<font color="#CCCCCC"> this if you're interested in too but</font>

447
00:25:25,410 --> 00:25:31,830
<font color="#E5E5E5">basically bypassing Emmett is a you have</font>

448
00:25:28,770 --> 00:25:35,310
two options either you try to disable

449
00:25:31,830 --> 00:25:39,030
Emmett this was a<font color="#E5E5E5"> this has been</font><font color="#CCCCCC"> shown</font>

450
00:25:35,310 --> 00:25:43,409
for m8 version 5.2 I think we're an

451
00:25:39,030 --> 00:25:47,010
attacker could just call dll unload of

452
00:25:43,410 --> 00:25:50,190
my Emmett and then emitted some nice and

453
00:25:47,010 --> 00:25:52,650
nice unloading of of itself<font color="#E5E5E5"> and the in</font>

454
00:25:50,190 --> 00:25:56,430
solid hooks basically so you could

455
00:25:52,650 --> 00:26:01,290
disable it by calling<font color="#CCCCCC"> disable basically</font>

456
00:25:56,430 --> 00:26:04,920
and this I<font color="#E5E5E5"> think they fixed it in</font>

457
00:26:01,290 --> 00:26:07,409
version 5.5 and the other option you

458
00:26:04,920 --> 00:26:11,610
have to bypass<font color="#E5E5E5"> Emmett is too hard on you</font>

459
00:26:07,410 --> 00:26:17,130
exploit and make it emit aware so it

460
00:26:11,610 --> 00:26:20,280
will dance this runtime checks so how do

461
00:26:17,130 --> 00:26:24,480
we bypass amet memory protection this is

462
00:26:20,280 --> 00:26:27,300
the feature very prevent the stack from

463
00:26:24,480 --> 00:26:29,490
being marked as executable so we just

464
00:26:27,300 --> 00:26:32,520
delivered the shellcode not on a stack

465
00:26:29,490 --> 00:26:34,980
but on the heap or<font color="#CCCCCC"> rich we just use</font>

466
00:26:32,520 --> 00:26:37,889
return oriented programming and code

467
00:26:34,980 --> 00:26:43,050
reuse attacks and not rely on marking

468
00:26:37,890 --> 00:26:46,020
any memory as executable out yeah and

469
00:26:43,050 --> 00:26:48,139
there is another<font color="#CCCCCC"> way we be found out</font>

470
00:26:46,020 --> 00:26:51,230
about

471
00:26:48,140 --> 00:26:54,060
we constructed a sample program which

472
00:26:51,230 --> 00:26:57,690
which allocates some stuff on<font color="#E5E5E5"> the heap</font>

473
00:26:54,060 --> 00:27:02,149
with some meaningful non meaningful but

474
00:26:57,690 --> 00:27:06,690
valid x86 code and then we called it and

475
00:27:02,150 --> 00:27:09,660
you see<font color="#CCCCCC"> Emmett is enabled so the m8</font>

476
00:27:06,690 --> 00:27:12,480
library is loaded into the<font color="#E5E5E5"> memory the m8</font>

477
00:27:09,660 --> 00:27:15,300
checks are enabled but we<font color="#E5E5E5"> still can</font>

478
00:27:12,480 --> 00:27:20,640
could call the function located on a

479
00:27:15,300 --> 00:27:25,680
stack without m8 complaining so if we

480
00:27:20,640 --> 00:27:27,900
<font color="#CCCCCC">cannot voice key we can talk</font><font color="#E5E5E5"> about it</font>

481
00:27:25,680 --> 00:27:31,290
<font color="#E5E5E5">yet because we are still discussing with</font>

482
00:27:27,900 --> 00:27:38,340
Microsoft but if you're interested<font color="#E5E5E5"> come</font>

483
00:27:31,290 --> 00:27:43,230
by after<font color="#CCCCCC"> the talk and yeah let's see so</font>

484
00:27:38,340 --> 00:27:46,580
how do we bypass caller checks to bypass

485
00:27:43,230 --> 00:27:50,340
<font color="#E5E5E5">color checks we just use gadgets that</font>

486
00:27:46,580 --> 00:27:53,370
begin after a call instruction this can

487
00:27:50,340 --> 00:27:59,189
maybe this is tricky I didn't actually

488
00:27:53,370 --> 00:28:01,080
try it but this may be tricky<font color="#E5E5E5"> and so</font>

489
00:27:59,190 --> 00:28:08,400
you'll get<font color="#E5E5E5"> your</font><font color="#CCCCCC"> op gadget may become</font>

490
00:28:01,080 --> 00:28:11,310
larger and<font color="#CCCCCC"> may be more complex</font><font color="#E5E5E5"> and we</font>

491
00:28:08,400 --> 00:28:14,640
also found some issue on these<font color="#E5E5E5"> color</font>

492
00:28:11,310 --> 00:28:19,909
checks which we also cannot talk about

493
00:28:14,640 --> 00:28:25,740
it yeah whatever szostak pivoting

494
00:28:19,910 --> 00:28:27,660
<font color="#E5E5E5">bypassing stack pivoting is a you just</font>

495
00:28:25,740 --> 00:28:30,450
make sure if you enter one<font color="#CCCCCC"> of these</font>

496
00:28:27,660 --> 00:28:32,430
critical functions which<font color="#E5E5E5"> M it protects</font>

497
00:28:30,450 --> 00:28:35,160
you just make sure<font color="#CCCCCC"> that your stack</font>

498
00:28:32,430 --> 00:28:38,040
pointer points to the stack actually and

499
00:28:35,160 --> 00:28:41,940
not to your fancy rope chain somewhere

500
00:28:38,040 --> 00:28:44,899
<font color="#CCCCCC">on the heap another option would be just</font>

501
00:28:41,940 --> 00:28:48,120
delivered the rope chain to the<font color="#E5E5E5"> stack or</font>

502
00:28:44,900 --> 00:28:51,630
copy the rope chain from the heap to the

503
00:28:48,120 --> 00:28:54,229
stack you could do this with rope code

504
00:28:51,630 --> 00:28:54,230
so

505
00:28:55,000 --> 00:29:02,080
yeah how<font color="#E5E5E5"> to bypass</font><font color="#CCCCCC"> eif and since the AF</font>

506
00:28:59,590 --> 00:29:04,209
was this is checked with some hardware

507
00:29:02,080 --> 00:29:06,370
feature there was some guy on<font color="#E5E5E5"> the</font>

508
00:29:04,210 --> 00:29:09,700
internet which explains how to disable

509
00:29:06,370 --> 00:29:11,979
this harder feature I'm not<font color="#E5E5E5"> quite sure</font>

510
00:29:09,700 --> 00:29:16,710
whether this works in most current

511
00:29:11,980 --> 00:29:16,710
version of<font color="#E5E5E5"> a mint but it should I guess</font>

512
00:29:18,060 --> 00:29:26,409
yeah so let's harden our our sample

513
00:29:23,110 --> 00:29:29,129
program the which we which<font color="#CCCCCC"> I introduced</font>

514
00:29:26,410 --> 00:29:32,380
before let's harden it with with a met

515
00:29:29,130 --> 00:29:38,400
because the sample program is a 64-bit

516
00:29:32,380 --> 00:29:42,610
we have to there is less mitigations 46

517
00:29:38,400 --> 00:29:44,680
<font color="#E5E5E5">64-bit so let's enable it and then we</font>

518
00:29:42,610 --> 00:29:47,469
see<font color="#CCCCCC"> that our exploit doesn't work</font>

519
00:29:44,680 --> 00:29:52,510
anymore and we get a animate violation

520
00:29:47,470 --> 00:29:56,560
about stack pivoting so m8 detected that

521
00:29:52,510 --> 00:30:01,770
the stack pointer was out of bounds for

522
00:29:56,560 --> 00:30:05,110
this virtual well virtual protect call

523
00:30:01,770 --> 00:30:07,750
so having our rope chain on a stack

524
00:30:05,110 --> 00:30:11,260
doesn't work anymore<font color="#E5E5E5"> so what we do</font>

525
00:30:07,750 --> 00:30:14,170
instead what do<font color="#E5E5E5"> we do instead we copy we</font>

526
00:30:11,260 --> 00:30:18,700
used<font color="#CCCCCC"> the first drop chain to copy a</font>

527
00:30:14,170 --> 00:30:22,570
second rope chain to the<font color="#E5E5E5"> stack and then</font>

528
00:30:18,700 --> 00:30:25,090
we pivot again we people<font color="#E5E5E5"> to stack</font>

529
00:30:22,570 --> 00:30:28,510
pointer again back to<font color="#E5E5E5"> the original stack</font>

530
00:30:25,090 --> 00:30:30,580
but to a different location and now we

531
00:30:28,510 --> 00:30:33,610
can call the virtual protect function

532
00:30:30,580 --> 00:30:38,040
and<font color="#CCCCCC"> Amit will not complain about stack</font>

533
00:30:33,610 --> 00:30:38,040
pivoting yeah

534
00:30:39,660 --> 00:30:46,120
yeah we you<font color="#E5E5E5"> for this example we</font><font color="#CCCCCC"> use the</font>

535
00:30:42,940 --> 00:30:51,730
mem copy but you could do simple roping

536
00:30:46,120 --> 00:30:55,989
to copy<font color="#E5E5E5"> by stuff byte by byte so we try</font>

537
00:30:51,730 --> 00:30:58,390
this and with the<font color="#E5E5E5"> next m8 violation so</font>

538
00:30:55,990 --> 00:31:03,340
this was a<font color="#E5E5E5"> export addressed filtering</font>

539
00:30:58,390 --> 00:31:06,040
violation because our<font color="#E5E5E5"> a shellcode scans</font>

540
00:31:03,340 --> 00:31:08,770
through the export address again we have

541
00:31:06,040 --> 00:31:11,290
some detailed information more or less

542
00:31:08,770 --> 00:31:13,840
detail so instead of<font color="#CCCCCC"> using</font><font color="#E5E5E5"> the</font>

543
00:31:11,290 --> 00:31:19,240
<font color="#CCCCCC">metasploit payload we constructed our</font>

544
00:31:13,840 --> 00:31:22,659
own payload and try it again<font color="#E5E5E5"> and this</font>

545
00:31:19,240 --> 00:31:26,290
time it works<font color="#E5E5E5"> so no Amit complaining so</font>

546
00:31:22,660 --> 00:31:30,670
for our constructed example<font color="#E5E5E5"> bypassing m8</font>

547
00:31:26,290 --> 00:31:33,310
was somewhat easy because there are no

548
00:31:30,670 --> 00:31:36,370
<font color="#CCCCCC">color checks and no simulated execution</font>

549
00:31:33,310 --> 00:31:39,970
flow checks in<font color="#E5E5E5"> 64-bit this memory</font>

550
00:31:36,370 --> 00:31:43,209
protection issue was not didn't really

551
00:31:39,970 --> 00:31:47,320
matter for our case and stack pivoting

552
00:31:43,210 --> 00:31:49,660
checks could be bypassed by copying<font color="#CCCCCC"> the</font>

553
00:31:47,320 --> 00:31:54,639
rough chain another up chained to the

554
00:31:49,660 --> 00:31:58,750
stack<font color="#E5E5E5"> the</font><font color="#CCCCCC"> AF check was bypassed with a</font>

555
00:31:54,640 --> 00:32:01,110
with some custom<font color="#CCCCCC"> shellcode and with some</font>

556
00:31:58,750 --> 00:32:03,640
more engineering you could make this

557
00:32:01,110 --> 00:32:06,250
like the cosmic shellcode now relies on

558
00:32:03,640 --> 00:32:07,810
specific library versions but with some

559
00:32:06,250 --> 00:32:10,780
engineering you could make this more

560
00:32:07,810 --> 00:32:14,399
reliable so let's enable<font color="#CCCCCC"> microsoft</font>

561
00:32:10,780 --> 00:32:17,770
control flow guard for our example

562
00:32:14,400 --> 00:32:21,520
control flow integrity is a not too new

563
00:32:17,770 --> 00:32:25,540
so the original publication was in 2005

564
00:32:21,520 --> 00:32:28,420
and there has been<font color="#E5E5E5"> many implemented</font><font color="#CCCCCC"> cfi</font>

565
00:32:25,540 --> 00:32:31,090
implementations proposed since then so

566
00:32:28,420 --> 00:32:34,960
somewhere compiler<font color="#E5E5E5"> based that there was</font>

567
00:32:31,090 --> 00:32:37,389
some binary only implementations and so

568
00:32:34,960 --> 00:32:40,660
forth and debate the<font color="#E5E5E5"> basic idea about</font>

569
00:32:37,390 --> 00:32:45,670
control flow<font color="#CCCCCC"> Integrity's to restrict</font>

570
00:32:40,660 --> 00:32:49,710
control flow transfers to some limited

571
00:32:45,670 --> 00:32:49,710
set of allowed targets

572
00:32:50,620 --> 00:32:56,290
so the first adoption the practical

573
00:32:54,260 --> 00:33:02,240
adoption of control so integrity<font color="#E5E5E5"> was</font>

574
00:32:56,290 --> 00:33:05,350
control flow guard and it yeah it's

575
00:33:02,240 --> 00:33:08,120
available with visual studio 2015 on

576
00:33:05,350 --> 00:33:10,760
current windows versions and it

577
00:33:08,120 --> 00:33:14,949
restricts<font color="#E5E5E5"> indirect calls and indirect</font>

578
00:33:10,760 --> 00:33:17,840
jumps to a static global set of valid

579
00:33:14,950 --> 00:33:20,900
functions valid targets which are

580
00:33:17,840 --> 00:33:23,720
functions so how does<font color="#E5E5E5"> this look in code</font>

581
00:33:20,900 --> 00:33:27,050
we have a 32-bit code so this<font color="#CCCCCC"> is a</font>

582
00:33:23,720 --> 00:33:32,030
function call an indirect function call

583
00:33:27,050 --> 00:33:34,909
in without<font color="#CCCCCC"> guard and this is a function</font>

584
00:33:32,030 --> 00:33:39,350
call with guard so you see some

585
00:33:34,910 --> 00:33:42,950
additional overhead code you see this

586
00:33:39,350 --> 00:33:46,310
check function which checks the indirect

587
00:33:42,950 --> 00:33:52,370
call target whether this is in the set

588
00:33:46,310 --> 00:33:58,220
of valid targets<font color="#CCCCCC"> 64bit is basically the</font>

589
00:33:52,370 --> 00:34:02,290
same so this dysfunction checks whether

590
00:33:58,220 --> 00:34:06,280
the<font color="#CCCCCC"> target is in this global set of</font>

591
00:34:02,290 --> 00:34:09,620
valid functions and this introduces some

592
00:34:06,280 --> 00:34:12,259
some runtime overhead of course and some

593
00:34:09,620 --> 00:34:14,989
memory overhead because implementation

594
00:34:12,260 --> 00:34:18,110
look like this in pictures so we<font color="#CCCCCC"> have</font>

595
00:34:14,989 --> 00:34:22,520
the compiler the compiler generates a

596
00:34:18,110 --> 00:34:26,090
list of valid functions and put it into

597
00:34:22,520 --> 00:34:29,179
the binary and during runtime this list

598
00:34:26,090 --> 00:34:32,810
of functions is like compressed into a

599
00:34:29,179 --> 00:34:38,719
bitmap<font color="#E5E5E5"> and put into memory so we have a</font>

600
00:34:32,810 --> 00:34:43,940
bitmap of i get to this later and also

601
00:34:38,719 --> 00:34:46,279
<font color="#CCCCCC">we have the guard track like this check</font>

602
00:34:43,940 --> 00:34:52,760
function which guards every indirect

603
00:34:46,280 --> 00:34:55,490
call or indirect jump so what about<font color="#E5E5E5"> this</font>

604
00:34:52,760 --> 00:34:59,540
bitmap how does it work so this control

605
00:34:55,489 --> 00:35:04,220
flow guard bitmap so one bit<font color="#E5E5E5"> of this</font>

606
00:34:59,540 --> 00:35:07,720
bitmap covers 8 bytes of

607
00:35:04,220 --> 00:35:12,939
dresses in<font color="#CCCCCC"> your virtual address space so</font>

608
00:35:07,720 --> 00:35:19,848
here we lose some precision so<font color="#E5E5E5"> actually</font>

609
00:35:12,940 --> 00:35:22,010
so I get this is now so when we

610
00:35:19,849 --> 00:35:24,560
transition from this set of valid

611
00:35:22,010 --> 00:35:29,599
function to the to the bitmap we lose

612
00:35:24,560 --> 00:35:31,099
some precision<font color="#E5E5E5"> by by that the</font>

613
00:35:29,599 --> 00:35:35,960
implementation gets rid of the least

614
00:35:31,099 --> 00:35:38,570
significant<font color="#E5E5E5"> three bits basically so if</font>

615
00:35:35,960 --> 00:35:41,180
you have a<font color="#CCCCCC"> one in this bitmap the this</font>

616
00:35:38,570 --> 00:35:43,310
means the the address you you've<font color="#E5E5E5"> been</font>

617
00:35:41,180 --> 00:35:46,779
checking is a valid indirect control

618
00:35:43,310 --> 00:35:52,570
<font color="#E5E5E5">sole target so this pic map may become</font>

619
00:35:46,780 --> 00:35:56,150
large so for for instance<font color="#E5E5E5"> for 64-bit I</font>

620
00:35:52,570 --> 00:36:00,680
had a look<font color="#E5E5E5"> at this bitmap so I use this</font>

621
00:35:56,150 --> 00:36:04,520
internal vm map and you<font color="#CCCCCC"> will</font><font color="#E5E5E5"> find the</font>

622
00:36:00,680 --> 00:36:07,609
two terabyte chunk of memory which<font color="#CCCCCC"> is</font>

623
00:36:04,520 --> 00:36:12,920
reserved but not<font color="#E5E5E5"> yet allocated so it's</font>

624
00:36:07,609 --> 00:36:16,180
reserved and so this<font color="#CCCCCC"> is how this bitmap</font>

625
00:36:12,920 --> 00:36:19,430
<font color="#CCCCCC">looks like and some parts of it are like</font>

626
00:36:16,180 --> 00:36:24,140
allocated and this is where your control

627
00:36:19,430 --> 00:36:26,839
for integrity information is encoded so

628
00:36:24,140 --> 00:36:29,750
this this bitmap is shared across all

629
00:36:26,839 --> 00:36:35,270
your processes on your<font color="#E5E5E5"> Windows machine</font>

630
00:36:29,750 --> 00:36:38,050
so<font color="#E5E5E5"> you have some shared memory and some</font>

631
00:36:35,270 --> 00:36:40,550
of some parts of<font color="#E5E5E5"> this bitmap is is for</font>

632
00:36:38,050 --> 00:36:42,260
private use only so if you load the

633
00:36:40,550 --> 00:36:46,369
library which<font color="#CCCCCC"> is shared among all</font>

634
00:36:42,260 --> 00:36:48,830
processes you may your zeros and ones

635
00:36:46,369 --> 00:36:51,320
end up in some blue parts with which you

636
00:36:48,830 --> 00:36:56,299
share for all and if you have like

637
00:36:51,320 --> 00:36:58,520
private cold you don't<font color="#E5E5E5"> share this how do</font>

638
00:36:56,300 --> 00:37:00,500
I'll do you bypass control<font color="#E5E5E5"> flow guard</font>

639
00:36:58,520 --> 00:37:03,920
there has been<font color="#CCCCCC"> last year there's been</font>

640
00:37:00,500 --> 00:37:06,830
some black guy talks about bypassing

641
00:37:03,920 --> 00:37:09,859
control flow guard and the essence

642
00:37:06,830 --> 00:37:12,650
basically was you use search for

643
00:37:09,859 --> 00:37:17,490
unprotected in direct calls or indirect

644
00:37:12,650 --> 00:37:21,660
jumps some guys found some in

645
00:37:17,490 --> 00:37:24,839
in dynamic code so just in time compiled

646
00:37:21,660 --> 00:37:35,670
code this was the<font color="#E5E5E5"> case in some old flash</font>

647
00:37:24,840 --> 00:37:39,060
version excuse me so you search for

648
00:37:35,670 --> 00:37:44,280
<font color="#E5E5E5">unprotected calls or jumps or you search</font>

649
00:37:39,060 --> 00:37:46,440
for<font color="#CCCCCC"> an CFG disabled modules so like old</font>

650
00:37:44,280 --> 00:37:49,680
libraries which have control flow guard

651
00:37:46,440 --> 00:37:53,160
which are not have not enabled control

652
00:37:49,680 --> 00:37:55,109
flow guard so when the loader loads a

653
00:37:53,160 --> 00:37:58,230
legacy module which doesn't support is

654
00:37:55,110 --> 00:38:00,690
it needs to fill the CFG bitmap with

655
00:37:58,230 --> 00:38:04,530
with<font color="#CCCCCC"> one's and basically needs to allow</font>

656
00:38:00,690 --> 00:38:08,730
any indirect control flow transfer to

657
00:38:04,530 --> 00:38:11,580
this legacy module or another<font color="#E5E5E5"> way</font><font color="#CCCCCC"> to</font>

658
00:38:08,730 --> 00:38:15,510
bypass control flow guard is just don't

659
00:38:11,580 --> 00:38:18,660
use calls and jumps and use returns so

660
00:38:15,510 --> 00:38:21,780
if you can control the stack or part of

661
00:38:18,660 --> 00:38:24,569
the stack you can just hijack a return

662
00:38:21,780 --> 00:38:28,369
instruction because<font color="#E5E5E5"> we turns are not</font>

663
00:38:24,570 --> 00:38:28,369
protected by CFG

664
00:38:33,760 --> 00:38:39,040
that's what<font color="#E5E5E5"> I mentioned before so legacy</font>

665
00:38:36,550 --> 00:38:41,290
modules have a the CFG bitmap

666
00:38:39,040 --> 00:38:44,310
initialized to 1 so<font color="#E5E5E5"> you're allowed to</font>

667
00:38:41,290 --> 00:38:47,259
jump and call anywhere<font color="#E5E5E5"> you want and</font>

668
00:38:44,310 --> 00:38:50,880
another problem<font color="#CCCCCC"> of th e f g is this</font>

669
00:38:47,260 --> 00:38:54,070
imprecision because you have a trade-off

670
00:38:50,880 --> 00:39:01,150
between memory consumption of your

671
00:38:54,070 --> 00:39:04,150
bitmap and precision so if you if CFG

672
00:39:01,150 --> 00:39:08,200
allows a function at address 420 for

673
00:39:04,150 --> 00:39:11,590
instance to be a valid call target you

674
00:39:08,200 --> 00:39:13,930
imp you allow by implementations all

675
00:39:11,590 --> 00:39:18,100
these addresses like seven more

676
00:39:13,930 --> 00:39:20,129
addresses to be jumped or calls to so

677
00:39:18,100 --> 00:39:24,930
you have some imprecision there and

678
00:39:20,130 --> 00:39:27,850
another bypass possibilities<font color="#CCCCCC"> just call</font>

679
00:39:24,930 --> 00:39:30,970
functions like critical functions like

680
00:39:27,850 --> 00:39:33,630
v-neck<font color="#CCCCCC"> sec or not you can still call</font>

681
00:39:30,970 --> 00:39:36,129
them<font color="#CCCCCC"> they're not protected they're</font>

682
00:39:33,630 --> 00:39:43,090
protected by CFG but you're allowed<font color="#E5E5E5"> to</font>

683
00:39:36,130 --> 00:39:45,100
call them so let's assume<font color="#E5E5E5"> we have no</font>

684
00:39:43,090 --> 00:39:50,910
<font color="#E5E5E5">control over the stack as an attacker</font>

685
00:39:45,100 --> 00:39:54,130
and we can control we<font color="#E5E5E5"> can hijack some</font>

686
00:39:50,910 --> 00:39:58,899
indirect call which is on the CFG

687
00:39:54,130 --> 00:40:01,600
protection so we will try we try to<font color="#E5E5E5"> look</font>

688
00:39:58,900 --> 00:40:04,930
for gadgets which are still reachable

689
00:40:01,600 --> 00:40:09,400
because of this imprecision so how many

690
00:40:04,930 --> 00:40:13,299
gadgets so we<font color="#E5E5E5"> still</font><font color="#CCCCCC"> have to work with so</font>

691
00:40:09,400 --> 00:40:17,410
for<font color="#E5E5E5"> this we use some rope captured</font>

692
00:40:13,300 --> 00:40:19,600
finders in this case we use we<font color="#E5E5E5"> added</font>

693
00:40:17,410 --> 00:40:22,870
<font color="#CCCCCC">some features to a rope or maybe you</font>

694
00:40:19,600 --> 00:40:27,279
notice this is<font color="#E5E5E5"> some python module and we</font>

695
00:40:22,870 --> 00:40:31,299
made<font color="#CCCCCC"> it CFG aware and looked for CFG</font>

696
00:40:27,280 --> 00:40:34,870
aware gadgets so and we noticed that<font color="#CCCCCC"> for</font>

697
00:40:31,300 --> 00:40:39,480
Windows 10 64 bit dll the number of

698
00:40:34,870 --> 00:40:42,790
gadgets reduced from about 20,000 to

699
00:40:39,480 --> 00:40:45,610
factor I could use by a factor of about

700
00:40:42,790 --> 00:40:47,640
eight to two and<font color="#E5E5E5"> a half thousand so we</font>

701
00:40:45,610 --> 00:40:50,460
have still two and<font color="#CCCCCC"> a half thousand</font>

702
00:40:47,640 --> 00:40:54,660
gadgets which are which you are allowed

703
00:40:50,460 --> 00:40:59,070
to jump or call<font color="#E5E5E5"> to despite of the CFG</font>

704
00:40:54,660 --> 00:41:02,270
checks and for a very<font color="#E5E5E5"> small program we</font>

705
00:40:59,070 --> 00:41:05,760
observed<font color="#E5E5E5"> that the gadget count reduced</font>

706
00:41:02,270 --> 00:41:08,910
to in this case<font color="#CCCCCC"> two three and we also</font>

707
00:41:05,760 --> 00:41:12,870
notice that if you enable incremental

708
00:41:08,910 --> 00:41:15,620
linking this is a visual<font color="#E5E5E5"> studio linker</font>

709
00:41:12,870 --> 00:41:19,410
flag the gadget count reduced to zero

710
00:41:15,620 --> 00:41:22,799
what so what<font color="#CCCCCC"> is this a what is this</font>

711
00:41:19,410 --> 00:41:25,680
incremental linking so this is<font color="#CCCCCC"> a linker</font>

712
00:41:22,800 --> 00:41:28,110
flag and it should this is a for

713
00:41:25,680 --> 00:41:31,169
programmers to have a foster linking

714
00:41:28,110 --> 00:41:33,540
time with small code changes so you

715
00:41:31,170 --> 00:41:37,020
don't need to wait for your compiler the

716
00:41:33,540 --> 00:41:38,940
whole day and this<font color="#CCCCCC"> incur</font><font color="#E5E5E5"> some some run</font>

717
00:41:37,020 --> 00:41:42,840
time and memory overhead and it

718
00:41:38,940 --> 00:41:47,010
obviously helps CFG reducing number of

719
00:41:42,840 --> 00:41:49,740
valid targets so why<font color="#E5E5E5"> is this so so this</font>

720
00:41:47,010 --> 00:41:53,940
is<font color="#CCCCCC"> a incremental linking table you</font><font color="#E5E5E5"> have</font>

721
00:41:49,740 --> 00:41:58,729
at the start<font color="#E5E5E5"> of your code section you</font>

722
00:41:53,940 --> 00:42:03,510
<font color="#E5E5E5">have a table</font><font color="#CCCCCC"> a jump table which contains</font>

723
00:41:58,730 --> 00:42:06,600
jumps to module in turn so if you do a

724
00:42:03,510 --> 00:42:10,110
module in turn call or a jump you use

725
00:42:06,600 --> 00:42:15,900
this linking table and do a detour over

726
00:42:10,110 --> 00:42:18,540
this table so if you enable incremental

727
00:42:15,900 --> 00:42:21,330
linking ends<font color="#E5E5E5"> efg this table looks like</font>

728
00:42:18,540 --> 00:42:25,529
this and visual studio pads this stuff

729
00:42:21,330 --> 00:42:30,380
with a with a<font color="#E5E5E5"> breakpoint instructions</font>

730
00:42:25,530 --> 00:42:36,900
with<font color="#E5E5E5"> inter optics instructions and now</font>

731
00:42:30,380 --> 00:42:39,930
CFG<font color="#CCCCCC"> Valley targets are only under CFG</font>

732
00:42:36,900 --> 00:42:42,450
you're only allowed to call these

733
00:42:39,930 --> 00:42:45,180
functions and you can imagine<font color="#E5E5E5"> on your</font>

734
00:42:42,450 --> 00:42:48,509
own if<font color="#CCCCCC"> you look for a rope gadget this</font>

735
00:42:45,180 --> 00:42:53,279
is<font color="#E5E5E5"> pretty hard to find any useful Rob</font>

736
00:42:48,510 --> 00:42:55,830
gadgets here so this is<font color="#CCCCCC"> why incremental</font>

737
00:42:53,280 --> 00:42:58,880
linking reduces the number of CFG

738
00:42:55,830 --> 00:43:03,090
Aware's aware gadgets

739
00:42:58,880 --> 00:43:06,030
another thing to<font color="#CCCCCC"> have in mind for</font>

740
00:43:03,090 --> 00:43:10,400
control flow guard is a dynamic code so

741
00:43:06,030 --> 00:43:14,370
most modern browsers and your java

742
00:43:10,400 --> 00:43:18,480
hotspot does it it generates code at

743
00:43:14,370 --> 00:43:22,680
runtime so when you do this you allocate

744
00:43:18,480 --> 00:43:27,110
some executable memory to be backward

745
00:43:22,680 --> 00:43:30,750
compatible your CFG bitmap needs to be

746
00:43:27,110 --> 00:43:33,930
initialized to 1 so we you want to allow

747
00:43:30,750 --> 00:43:41,310
any indirect control so transfer to this

748
00:43:33,930 --> 00:43:43,049
chunk of memory<font color="#CCCCCC"> ok so</font><font color="#E5E5E5"> Microsoft</font>

749
00:43:41,310 --> 00:43:47,480
introduced some new memory protection

750
00:43:43,050 --> 00:43:49,500
flag too hard and cheat and proposed and

751
00:43:47,480 --> 00:43:52,740
gave the programmers some new

752
00:43:49,500 --> 00:43:56,130
functionality to like specifically take

753
00:43:52,740 --> 00:43:59,609
control over<font color="#CCCCCC"> the CFG bitmap but the</font>

754
00:43:56,130 --> 00:44:02,240
take-home message is your<font color="#E5E5E5"> tip compiler</font>

755
00:43:59,610 --> 00:44:14,690
or your cheat code needs to be<font color="#E5E5E5"> aware of</font>

756
00:44:02,240 --> 00:44:22,200
CFG so this<font color="#CCCCCC"> is again how do we bypass</font>

757
00:44:14,690 --> 00:44:24,420
CFG are we try to so we applied to our

758
00:44:22,200 --> 00:44:28,129
sample program we<font color="#E5E5E5"> are applied control</font>

759
00:44:24,420 --> 00:44:31,500
<font color="#CCCCCC">sogard and now</font><font color="#E5E5E5"> our indirect call to the</font>

760
00:44:28,130 --> 00:44:35,100
program main function is now guarded our

761
00:44:31,500 --> 00:44:38,730
exploit obviously fails because our

762
00:44:35,100 --> 00:44:46,110
<font color="#E5E5E5">first stack pivoting gadget is not CFG</font>

763
00:44:38,730 --> 00:44:50,780
valid so we fail yeah so is this<font color="#CCCCCC"> the end</font>

764
00:44:46,110 --> 00:44:53,400
<font color="#CCCCCC">of code reuse attacks probably not but</font>

765
00:44:50,780 --> 00:44:55,530
but these<font color="#CCCCCC"> rock mitigations and control</font>

766
00:44:53,400 --> 00:44:59,840
flow guard they definitely raise the

767
00:44:55,530 --> 00:45:05,310
<font color="#CCCCCC">cost of weaponizing your vulnerability</font>

768
00:44:59,840 --> 00:45:07,650
so take on message<font color="#E5E5E5"> install</font><font color="#CCCCCC"> Emmet and the</font>

769
00:45:05,310 --> 00:45:11,279
CFG stuff<font color="#E5E5E5"> disney is still</font><font color="#CCCCCC"> is time to</font>

770
00:45:07,650 --> 00:45:12,910
reach end-users and reach the end users

771
00:45:11,280 --> 00:45:17,320
and as a programmer

772
00:45:12,910 --> 00:45:20,410
if you generate dynamic code as a

773
00:45:17,320 --> 00:45:23,110
programmer do use the CFG it it's a nice

774
00:45:20,410 --> 00:45:27,089
<font color="#E5E5E5">thing and if you generate generate cheat</font>

775
00:45:23,110 --> 00:45:30,250
code take care there's a lot of pitfalls

776
00:45:27,090 --> 00:45:33,010
you need to<font color="#E5E5E5"> be aware what you do when</font>

777
00:45:30,250 --> 00:45:36,060
you generate dynamic code and in the

778
00:45:33,010 --> 00:45:39,640
future<font color="#CCCCCC"> you may or may not see your shift</font>

779
00:45:36,060 --> 00:45:46,230
<font color="#E5E5E5">you do towards data only attacks and</font>

780
00:45:39,640 --> 00:45:46,230
less code reuse attacks<font color="#E5E5E5"> thanks</font>

781
00:45:56,010 --> 00:45:58,070
you

