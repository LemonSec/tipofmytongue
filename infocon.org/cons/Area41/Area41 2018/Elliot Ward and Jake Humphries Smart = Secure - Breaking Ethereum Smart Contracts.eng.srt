1
00:00:02,600 --> 00:00:06,359
there we go okay so my name is Trey come

2
00:00:04,740 --> 00:00:08,090
freeze I'm a security consultant at

3
00:00:06,359 --> 00:00:12,300
Gotham digital science based in London

4
00:00:08,090 --> 00:00:16,650
and yeah I'm also a security consultant

5
00:00:12,300 --> 00:00:18,869
but I'm based here in Zurich and yet we

6
00:00:16,650 --> 00:00:21,240
both work for the same company yep so

7
00:00:18,869 --> 00:00:25,189
göttingen Sciences base difference was

8
00:00:21,240 --> 00:00:30,330
three continents almost for a pack

9
00:00:25,189 --> 00:00:34,460
Europe Europe and America yes so what

10
00:00:30,330 --> 00:00:38,879
we're going to be talking about is so

11
00:00:34,460 --> 00:00:42,390
basically yeah mate smart contracts are

12
00:00:38,879 --> 00:00:44,640
so hot right now so yeah basically we've

13
00:00:42,390 --> 00:00:49,100
been doing some research on the security

14
00:00:44,640 --> 00:00:54,480
of smart contracts specifically around

15
00:00:49,100 --> 00:00:56,670
so yeah Beth so yeah basically we've

16
00:00:54,480 --> 00:00:59,309
been doing some work around the security

17
00:00:56,670 --> 00:01:02,460
of smart contracts and we've basically

18
00:00:59,309 --> 00:01:04,229
implemented and designed some suite of

19
00:01:02,460 --> 00:01:06,840
tools that we can be used for reverse

20
00:01:04,229 --> 00:01:09,689
engineering and automated analysis of

21
00:01:06,840 --> 00:01:12,299
smart contracts and then with this we've

22
00:01:09,689 --> 00:01:15,298
basically taken a snapshot of the

23
00:01:12,299 --> 00:01:20,460
blockchain at a given point in time and

24
00:01:15,299 --> 00:01:22,259
we've ran our tool against this against

25
00:01:20,460 --> 00:01:24,658
the framework that we've built and

26
00:01:22,259 --> 00:01:28,920
basically just gathered out a summary of

27
00:01:24,659 --> 00:01:31,950
the state of security for abilities on

28
00:01:28,920 --> 00:01:34,890
the ethereum blockchain at the moment

29
00:01:31,950 --> 00:01:36,720
great and then to give you guys just a

30
00:01:34,890 --> 00:01:39,420
bit of background we've got two layers

31
00:01:36,720 --> 00:01:42,150
on the on the slides here gotham's of

32
00:01:39,420 --> 00:01:45,060
science and a on that's what happened in

33
00:01:42,150 --> 00:01:46,860
2016 GDS cognitive science got bought

34
00:01:45,060 --> 00:01:50,009
out by comical straws Friedberg who does

35
00:01:46,860 --> 00:01:54,149
digital forensics ir in due diligence

36
00:01:50,009 --> 00:01:56,579
and then sort of midway through 2017 it

37
00:01:54,149 --> 00:01:59,549
was then Ostrosky but then acquired by a

38
00:01:56,579 --> 00:02:02,820
on so from here on you'll see

39
00:01:59,549 --> 00:02:05,159
occasionally the two logos we still run

40
00:02:02,820 --> 00:02:09,239
as Gotham digital science but we are as

41
00:02:05,159 --> 00:02:11,730
part of the Aon family so what we're

42
00:02:09,239 --> 00:02:13,270
going to be talking about so we're not

43
00:02:11,730 --> 00:02:14,709
talking about even what

44
00:02:13,270 --> 00:02:16,270
not talking about the politics so we're

45
00:02:14,710 --> 00:02:19,900
not gonna go into what altcoin is best

46
00:02:16,270 --> 00:02:22,120
or what you can do with different coins

47
00:02:19,900 --> 00:02:24,040
or even the politics of the etherion

48
00:02:22,120 --> 00:02:26,500
blockchain we're definitely not going to

49
00:02:24,040 --> 00:02:28,840
be breaking the crypto cryptography

50
00:02:26,500 --> 00:02:29,770
we're not mathematicians so we didn't

51
00:02:28,840 --> 00:02:31,210
even look at that we've kind of just

52
00:02:29,770 --> 00:02:33,970
trusted that those guys knew what they

53
00:02:31,210 --> 00:02:35,350
were doing and we're not gonna be

54
00:02:33,970 --> 00:02:36,790
looking at the EVM well as we have

55
00:02:35,350 --> 00:02:38,290
implemented the EVM but we're not

56
00:02:36,790 --> 00:02:40,090
actually looking at how with the EVM can

57
00:02:38,290 --> 00:02:41,910
be broken there are plenty of good

58
00:02:40,090 --> 00:02:44,680
clients out there already that are

59
00:02:41,910 --> 00:02:48,790
pretty good at what they do so that's

60
00:02:44,680 --> 00:02:50,290
kind of not scope of this talk so now

61
00:02:48,790 --> 00:02:54,840
we're going to be looking at view theory

62
00:02:50,290 --> 00:02:56,679
and background yeah basically so

63
00:02:54,840 --> 00:02:58,420
regarding a theorem like we're not

64
00:02:56,680 --> 00:03:00,670
focusing on a theorem itself we're

65
00:02:58,420 --> 00:03:02,320
looking at the smart contract component

66
00:03:00,670 --> 00:03:04,720
and the smart contract component

67
00:03:02,320 --> 00:03:07,930
basically if you're not familiar it

68
00:03:04,720 --> 00:03:09,880
provides a different paradigm for

69
00:03:07,930 --> 00:03:11,740
programming and basically allows

70
00:03:09,880 --> 00:03:14,230
developers to write completely

71
00:03:11,740 --> 00:03:17,320
decentralized code so this code is

72
00:03:14,230 --> 00:03:20,560
stored on the blockchain and it's fully

73
00:03:17,320 --> 00:03:23,170
decentralized and then when it comes to

74
00:03:20,560 --> 00:03:26,650
execution this code gets executed on all

75
00:03:23,170 --> 00:03:30,458
of the nodes and basically yeah we're

76
00:03:26,650 --> 00:03:32,530
allowed to decentralize code running

77
00:03:30,459 --> 00:03:35,740
which allows us to do some cool things

78
00:03:32,530 --> 00:03:37,660
basically EBM it stands for a theory in

79
00:03:35,740 --> 00:03:40,470
virtual machine and this is where the

80
00:03:37,660 --> 00:03:43,090
actual byte code that gets compiled down

81
00:03:40,470 --> 00:03:45,190
executed on and there are a few

82
00:03:43,090 --> 00:03:46,630
different implementations of this you've

83
00:03:45,190 --> 00:03:49,420
got the primary ones such as parity and

84
00:03:46,630 --> 00:03:51,490
get but we're not really going into the

85
00:03:49,420 --> 00:03:53,230
specifics of that we're more just

86
00:03:51,490 --> 00:03:56,740
looking around what the EVM can do for

87
00:03:53,230 --> 00:03:59,470
us so in terms of how the EVM is

88
00:03:56,740 --> 00:04:02,500
architected it basically a stack based

89
00:03:59,470 --> 00:04:08,380
architecture and it has a stack size of

90
00:04:02,500 --> 00:04:12,880
100 and 1024 limit and that's basically

91
00:04:08,380 --> 00:04:15,730
made up of 256 bit words and it's

92
00:04:12,880 --> 00:04:16,510
basically like they call it

93
00:04:15,730 --> 00:04:18,190
turing-complete

94
00:04:16,510 --> 00:04:20,469
but it's only really quasi

95
00:04:18,190 --> 00:04:22,570
turing-complete because of you can't

96
00:04:20,470 --> 00:04:25,140
basically do infinite loops and this is

97
00:04:22,570 --> 00:04:26,620
due to the gas cost so there's basically

98
00:04:25,140 --> 00:04:28,599
transactions are

99
00:04:26,620 --> 00:04:31,540
paid for in GAF so each instruction that

100
00:04:28,600 --> 00:04:34,270
gets executed inside the UVM has a gas

101
00:04:31,540 --> 00:04:38,560
cost and there's basically a gas limit

102
00:04:34,270 --> 00:04:41,490
and this is basically how it prevents an

103
00:04:38,560 --> 00:04:44,949
attacks and basically allow the

104
00:04:41,490 --> 00:04:47,050
computers executing the opcodes they

105
00:04:44,949 --> 00:04:50,860
receive this it basically forms the

106
00:04:47,050 --> 00:04:52,979
transaction fee and then on top of this

107
00:04:50,860 --> 00:04:58,600
it has an independent storage module

108
00:04:52,979 --> 00:05:01,240
storage ideology so basically the this

109
00:04:58,600 --> 00:05:04,780
de system storage is basically formed of

110
00:05:01,240 --> 00:05:07,539
the state of the contract and a contract

111
00:05:04,780 --> 00:05:09,849
each contract has its own state and this

112
00:05:07,539 --> 00:05:12,219
is where persistent storage is held so

113
00:05:09,850 --> 00:05:14,229
if a contract holds addresses of

114
00:05:12,220 --> 00:05:16,270
participants that are taking place it's

115
00:05:14,229 --> 00:05:18,099
basically stored in there and then it

116
00:05:16,270 --> 00:05:24,039
also has memory which is just a byte

117
00:05:18,100 --> 00:05:26,050
addressable memory storage okay and

118
00:05:24,039 --> 00:05:28,090
we'll move on to sort of some of the

119
00:05:26,050 --> 00:05:31,240
inbuilt restrictions and security that

120
00:05:28,090 --> 00:05:34,479
exist within the etherion blockchain so

121
00:05:31,240 --> 00:05:36,580
as Elliott touched on the gas usage it's

122
00:05:34,479 --> 00:05:37,750
the gas usage is quite a intrinsic part

123
00:05:36,580 --> 00:05:39,370
of the ethereum blockchain in it

124
00:05:37,750 --> 00:05:42,479
actually can be used to prevent the

125
00:05:39,370 --> 00:05:45,460
denial of service attack so the gas

126
00:05:42,479 --> 00:05:47,469
requirement on a contract restricts the

127
00:05:45,460 --> 00:05:50,560
amount that a potential attacker could

128
00:05:47,470 --> 00:05:54,849
use and abuse the etherion blockchain to

129
00:05:50,560 --> 00:05:57,610
prevent a potential outage program to

130
00:05:54,849 --> 00:06:00,449
may only interact with each other in the

131
00:05:57,610 --> 00:06:03,130
form of a single laboratory rights array

132
00:06:00,449 --> 00:06:04,210
so they're not actually the the etherium

133
00:06:03,130 --> 00:06:05,680
contracts that are running are not

134
00:06:04,210 --> 00:06:07,690
actually able to communicate with each

135
00:06:05,680 --> 00:06:09,729
other throughout any other way so the

136
00:06:07,690 --> 00:06:12,430
can sort of go through the EVM into a

137
00:06:09,729 --> 00:06:14,490
backdoor kind of way everything is

138
00:06:12,430 --> 00:06:17,110
sandbox on the EVM there's there's no

139
00:06:14,490 --> 00:06:19,060
there's no way that it can break out

140
00:06:17,110 --> 00:06:21,760
onto the the user's machine that that is

141
00:06:19,060 --> 00:06:25,690
known I mean obviously this presentation

142
00:06:21,760 --> 00:06:27,849
isn't going into the EVM security so

143
00:06:25,690 --> 00:06:30,520
from what we know at the moment there is

144
00:06:27,849 --> 00:06:31,900
no way that you can actually execute

145
00:06:30,520 --> 00:06:35,530
anything on the host machine that's not

146
00:06:31,900 --> 00:06:37,960
within the EVM and the EVM is fully

147
00:06:35,530 --> 00:06:40,510
deterministic this does produce some

148
00:06:37,960 --> 00:06:41,880
issues that we will go into later

149
00:06:40,510 --> 00:06:43,659
it does restrict the facts that

150
00:06:41,880 --> 00:06:44,710
randomization is a big problem at the

151
00:06:43,660 --> 00:06:46,690
moment than the etherion blockchain and

152
00:06:44,710 --> 00:06:48,039
we do touch on that because everything

153
00:06:46,690 --> 00:06:49,330
needs to be fully deterministic it's

154
00:06:48,040 --> 00:06:50,470
actually quite hard to have something

155
00:06:49,330 --> 00:06:57,880
that can produce a random number

156
00:06:50,470 --> 00:06:59,800
accurately produced multiple times and

157
00:06:57,880 --> 00:07:02,650
to give you guys sort of an overview of

158
00:06:59,800 --> 00:07:04,090
what the architecture compared to sort

159
00:07:02,650 --> 00:07:06,190
of a standard application or traditional

160
00:07:04,090 --> 00:07:07,359
application if you're not fully aware at

161
00:07:06,190 --> 00:07:10,000
the top there you've got your

162
00:07:07,360 --> 00:07:11,980
traditional I can do this you've got

163
00:07:10,000 --> 00:07:13,900
your traditional front-end that could be

164
00:07:11,980 --> 00:07:15,640
written in JavaScript or C sharp or

165
00:07:13,900 --> 00:07:17,590
whatever what you like you've got a

166
00:07:15,640 --> 00:07:19,659
back-end of node and then your data

167
00:07:17,590 --> 00:07:21,489
stores pray squares and then you can

168
00:07:19,660 --> 00:07:22,990
look at the etherium chain and again you

169
00:07:21,490 --> 00:07:25,390
have a front-end of JavaScript this can

170
00:07:22,990 --> 00:07:29,650
be uses you distribute it out as they're

171
00:07:25,390 --> 00:07:32,020
known this is not quite correct like

172
00:07:29,650 --> 00:07:34,150
there'll be some people that say that

173
00:07:32,020 --> 00:07:35,500
this isn't correct at all because the

174
00:07:34,150 --> 00:07:37,120
smart contract a blockchain a basically

175
00:07:35,500 --> 00:07:38,140
one in the same but to provide sort of

176
00:07:37,120 --> 00:07:40,330
an understanding of how it actually

177
00:07:38,140 --> 00:07:41,860
works this is quite a nice way of

178
00:07:40,330 --> 00:07:43,450
viewing it so you can see that the smart

179
00:07:41,860 --> 00:07:45,910
contract is almost like whether what the

180
00:07:43,450 --> 00:07:47,890
server is where your functions are

181
00:07:45,910 --> 00:07:53,050
performed and then the blockchain is

182
00:07:47,890 --> 00:07:56,469
where I think stored cool yeah so

183
00:07:53,050 --> 00:07:58,030
basically with the etherium contracts

184
00:07:56,470 --> 00:08:01,450
they're basically there's a primary

185
00:07:58,030 --> 00:08:03,700
language called solidity and this is the

186
00:08:01,450 --> 00:08:06,280
main language the smart contracts are

187
00:08:03,700 --> 00:08:11,590
developed in so the the language was

188
00:08:06,280 --> 00:08:14,289
inspired by C++ JavaScript and Python it

189
00:08:11,590 --> 00:08:18,369
types a little bit like JavaScript

190
00:08:14,290 --> 00:08:20,410
people say but the it's really not

191
00:08:18,370 --> 00:08:21,970
anything like JavaScript yeah it just

192
00:08:20,410 --> 00:08:24,370
looks a little bit like JavaScript when

193
00:08:21,970 --> 00:08:26,290
it's written out it's a statically typed

194
00:08:24,370 --> 00:08:28,470
language again so that's one thing

195
00:08:26,290 --> 00:08:31,990
that's completely different JavaScript

196
00:08:28,470 --> 00:08:35,560
and basically this gets compiled down to

197
00:08:31,990 --> 00:08:38,680
a VM bytecode and that's typically with

198
00:08:35,559 --> 00:08:41,890
the soul C compiler and it's also

199
00:08:38,679 --> 00:08:44,140
important to note that solidity isn't

200
00:08:41,890 --> 00:08:46,360
the only programming language for the

201
00:08:44,140 --> 00:08:48,240
EVM block code so there's others such as

202
00:08:46,360 --> 00:08:50,410
serpent and Viper

203
00:08:48,240 --> 00:08:54,370
but solidity is definitely the most

204
00:08:50,410 --> 00:08:58,020
common one and most developers

205
00:08:54,370 --> 00:09:02,230
smart contracts typically using solidity

206
00:08:58,020 --> 00:09:05,079
and for the one of the main reasons

207
00:09:02,230 --> 00:09:08,370
we're also focusing on IBM bytecode

208
00:09:05,080 --> 00:09:11,380
specifically is this allows us to

209
00:09:08,370 --> 00:09:14,200
analyze contracts written in multiple

210
00:09:11,380 --> 00:09:15,730
different languages so in terms of the

211
00:09:14,200 --> 00:09:18,250
tools that we've made they don't care

212
00:09:15,730 --> 00:09:22,540
about if it's written in solidity or

213
00:09:18,250 --> 00:09:24,550
viper it basically just those compilers

214
00:09:22,540 --> 00:09:29,980
compiled down to the IBM byte code and

215
00:09:24,550 --> 00:09:33,130
we work on that instead so yes I think

216
00:09:29,980 --> 00:09:35,860
that's okay and it's just a quick

217
00:09:33,130 --> 00:09:37,600
snippet of a solidity code example just

218
00:09:35,860 --> 00:09:39,250
give you guys that may not have been

219
00:09:37,600 --> 00:09:42,070
counted before just a quick look

220
00:09:39,250 --> 00:09:45,670
actually how it would sort of look we

221
00:09:42,070 --> 00:09:48,040
will be giving some city code snippets

222
00:09:45,670 --> 00:09:49,810
throughout the presentation so we will

223
00:09:48,040 --> 00:09:53,439
explain them as they go but it's not

224
00:09:49,810 --> 00:09:56,829
it's not too difficult to understand so

225
00:09:53,440 --> 00:09:58,960
to start this off we set out some ideas

226
00:09:56,830 --> 00:09:59,920
that we wanted to achieve and one of

227
00:09:58,960 --> 00:10:02,590
them was obviously the creation of a

228
00:09:59,920 --> 00:10:03,819
tool and then we sort of said well can

229
00:10:02,590 --> 00:10:08,260
we then scan the blockchain with that

230
00:10:03,820 --> 00:10:09,460
tool and yeah you can we definitely had

231
00:10:08,260 --> 00:10:12,819
some objectives we wanted to collect the

232
00:10:09,460 --> 00:10:13,810
binaries that were being run and then we

233
00:10:12,820 --> 00:10:15,640
wanted to store them in a way that could

234
00:10:13,810 --> 00:10:18,790
then easily query those binaries to then

235
00:10:15,640 --> 00:10:20,890
use the tool against and then you know

236
00:10:18,790 --> 00:10:24,459
fairly fast and repeatable that final

237
00:10:20,890 --> 00:10:25,960
objective was actually fairly fast is

238
00:10:24,460 --> 00:10:27,160
not not something I would say that the

239
00:10:25,960 --> 00:10:31,090
ethereum blockchain is definitely

240
00:10:27,160 --> 00:10:32,709
capable of repeatable yes fast new and

241
00:10:31,090 --> 00:10:35,020
then we stood some context around those

242
00:10:32,710 --> 00:10:36,400
of those contracts as well just to give

243
00:10:35,020 --> 00:10:38,110
us a little bit of information that we

244
00:10:36,400 --> 00:10:39,939
could then sort of refer back to and you

245
00:10:38,110 --> 00:10:41,980
know do some fancy graphs and charts and

246
00:10:39,940 --> 00:10:43,180
that kind of thing so in terms of the

247
00:10:41,980 --> 00:10:45,160
actual development of this scanner we

248
00:10:43,180 --> 00:10:47,530
were written Python 3 using the IPC

249
00:10:45,160 --> 00:10:50,040
interface and we actually use get for

250
00:10:47,530 --> 00:10:53,170
that which is the Go aetherium

251
00:10:50,040 --> 00:10:55,900
implementation of the EBM so that just

252
00:10:53,170 --> 00:10:59,079
runs on your local machine I believe

253
00:10:55,900 --> 00:11:01,240
it's the IP our pcs IPC flank on gift

254
00:10:59,080 --> 00:11:02,680
you can run quite remember and it just

255
00:11:01,240 --> 00:11:04,390
spins up and I can see interface that

256
00:11:02,680 --> 00:11:07,420
you can directly call using the web web

257
00:11:04,390 --> 00:11:07,870
3 interface for python and that works

258
00:11:07,420 --> 00:11:09,579
really well

259
00:11:07,870 --> 00:11:10,960
you can multi-thread it and it will fly

260
00:11:09,580 --> 00:11:13,810
through Friday the blockchain pretty

261
00:11:10,960 --> 00:11:16,420
quickly as when I think it wasn't

262
00:11:13,810 --> 00:11:18,099
entirely smooth so the etherion

263
00:11:16,420 --> 00:11:21,400
blockchain when we scanned it had over

264
00:11:18,100 --> 00:11:23,470
five million blocks at the time and

265
00:11:21,400 --> 00:11:25,930
that's a lot of data and as we can say

266
00:11:23,470 --> 00:11:28,660
that the hardware can't keep up so what

267
00:11:25,930 --> 00:11:30,160
I found in my initial tests this was the

268
00:11:28,660 --> 00:11:32,560
hardware that I was running the etherion

269
00:11:30,160 --> 00:11:33,670
blockchain on wasn't quick enough and I

270
00:11:32,560 --> 00:11:35,920
did a little bit of research around it

271
00:11:33,670 --> 00:11:38,199
and it turns out that you actually need

272
00:11:35,920 --> 00:11:40,750
an SSD and a fairly fast processor and

273
00:11:38,200 --> 00:11:42,550
internet connection to catch up to and

274
00:11:40,750 --> 00:11:45,430
continue on with the etherion blockchain

275
00:11:42,550 --> 00:11:46,150
syncing and this was my experience your

276
00:11:45,430 --> 00:11:49,870
mileage may vary

277
00:11:46,150 --> 00:11:51,880
I just thought I'd give it give it a

278
00:11:49,870 --> 00:11:56,170
little bit of information but as I've

279
00:11:51,880 --> 00:11:57,550
put there a fast sync which is it's

280
00:11:56,170 --> 00:11:59,560
cutting out a lot of the tree nodes

281
00:11:57,550 --> 00:12:01,839
within there it's about 80 gigabytes in

282
00:11:59,560 --> 00:12:06,969
size I took three days and that was on a

283
00:12:01,840 --> 00:12:12,520
digital ocean VPS with four cores and a

284
00:12:06,970 --> 00:12:14,230
500 gig SSD it took a while so a few

285
00:12:12,520 --> 00:12:15,370
stacks of our blockchain scanning and

286
00:12:14,230 --> 00:12:18,490
like after she read these off cut the

287
00:12:15,370 --> 00:12:20,400
camera off found we found just under 1.5

288
00:12:18,490 --> 00:12:23,560
million contracts on the blockchain and

289
00:12:20,400 --> 00:12:25,390
that's within five million box empty

290
00:12:23,560 --> 00:12:27,699
contracts is five hundred just under

291
00:12:25,390 --> 00:12:29,350
sixty thousand and we can probably put

292
00:12:27,700 --> 00:12:31,120
that down to either self destruction out

293
00:12:29,350 --> 00:12:34,870
of gasps exceptions the outer gasps

294
00:12:31,120 --> 00:12:36,820
exceptions will happen during the XE

295
00:12:34,870 --> 00:12:38,590
could happen during the execution of say

296
00:12:36,820 --> 00:12:40,930
a create a contract creation so what

297
00:12:38,590 --> 00:12:42,810
you'll find is potentially still a

298
00:12:40,930 --> 00:12:45,219
contract creation pushed onto a block

299
00:12:42,810 --> 00:12:48,160
and that ends up with just an empty

300
00:12:45,220 --> 00:12:51,070
contract so what unique contracts of 76

301
00:12:48,160 --> 00:12:53,890
just over 76,000 so what we did is we

302
00:12:51,070 --> 00:12:55,690
took took a hash of the of all of the

303
00:12:53,890 --> 00:12:57,670
contracts within that we found within

304
00:12:55,690 --> 00:12:59,080
the database and then just distinct the

305
00:12:57,670 --> 00:13:00,729
mist at them in another table just so we

306
00:12:59,080 --> 00:13:03,190
could scan those we weren't you

307
00:13:00,730 --> 00:13:05,410
forgetting ourselves the largest

308
00:13:03,190 --> 00:13:08,010
contract we found was all on that just

309
00:13:05,410 --> 00:13:10,420
this this block just over five million

310
00:13:08,010 --> 00:13:11,980
that's a contract hash that I'm sure you

311
00:13:10,420 --> 00:13:14,170
guys are gonna remember why huh

312
00:13:11,980 --> 00:13:16,300
and that was just four forty nine

313
00:13:14,170 --> 00:13:18,099
thousand bytes and then we also got a

314
00:13:16,300 --> 00:13:19,750
most duplicated contractor three hundred

315
00:13:18,100 --> 00:13:21,880
and sixty one thousand total

316
00:13:19,750 --> 00:13:23,470
implementations of this contract

317
00:13:21,880 --> 00:13:24,760
and that was seen at the first block

318
00:13:23,470 --> 00:13:27,010
number of four to four

319
00:13:24,760 --> 00:13:28,360
quadruple one just gives just gives a

320
00:13:27,010 --> 00:13:30,280
little bit of information that the

321
00:13:28,360 --> 00:13:32,410
scanning that we did and what we

322
00:13:30,280 --> 00:13:33,220
actually pulled out I find these stats

323
00:13:32,410 --> 00:13:34,420
quite interesting

324
00:13:33,220 --> 00:13:36,910
we've got a couple of we got a graph

325
00:13:34,420 --> 00:13:39,219
later that shows the vulnerabilities

326
00:13:36,910 --> 00:13:43,120
over time and how they may or may not

327
00:13:39,220 --> 00:13:45,910
increase or decrease just point out as

328
00:13:43,120 --> 00:13:48,450
well the link for the longest contract

329
00:13:45,910 --> 00:13:52,329
that would probably be half due to the

330
00:13:48,450 --> 00:13:54,220
ascii hex that we're storing so

331
00:13:52,330 --> 00:13:56,980
obviously each two characters represents

332
00:13:54,220 --> 00:13:58,780
one byte yeah good point so now we're

333
00:13:56,980 --> 00:14:00,910
going to be introducing the tool that

334
00:13:58,780 --> 00:14:05,860
has been created for the contract

335
00:14:00,910 --> 00:14:08,350
scanning but first of all this is my cat

336
00:14:05,860 --> 00:14:11,260
and she's been helping me do my research

337
00:14:08,350 --> 00:14:13,990
by basically sitting over my laptop and

338
00:14:11,260 --> 00:14:16,569
trying to eat my printouts of the

339
00:14:13,990 --> 00:14:19,300
etherium yellow paper and just being

340
00:14:16,570 --> 00:14:20,530
very helpful so yeah she's just been

341
00:14:19,300 --> 00:14:24,150
helping me do my research

342
00:14:20,530 --> 00:14:24,150
everyone needs a mascot and loves cats

343
00:14:28,260 --> 00:14:37,110
so basically the tool that we have the

344
00:14:33,100 --> 00:14:40,330
name treacle mine one of our colleagues

345
00:14:37,110 --> 00:14:41,860
came up with the name and we couldn't

346
00:14:40,330 --> 00:14:44,890
think of anything better so we've stuck

347
00:14:41,860 --> 00:14:47,620
with that and basically it's an

348
00:14:44,890 --> 00:14:51,760
automated security analysis tool for IBM

349
00:14:47,620 --> 00:14:53,770
byte code it's open source so it's not

350
00:14:51,760 --> 00:14:55,510
open sourced yet but this is something

351
00:14:53,770 --> 00:14:57,280
that we'll be doing in the future and

352
00:14:55,510 --> 00:15:01,210
it'll be released under the GPL to

353
00:14:57,280 --> 00:15:03,850
license and it's basically an extensible

354
00:15:01,210 --> 00:15:06,310
architecture so we want developers to be

355
00:15:03,850 --> 00:15:09,790
able to easily contribute and easily

356
00:15:06,310 --> 00:15:12,250
incorporate this into their own like

357
00:15:09,790 --> 00:15:14,050
development tool chains and any tools

358
00:15:12,250 --> 00:15:18,840
that they're using for part of their

359
00:15:14,050 --> 00:15:22,990
development processes so yeah one thing

360
00:15:18,840 --> 00:15:26,940
it's developed in JavaScript which is

361
00:15:22,990 --> 00:15:30,610
something that I kind of regret it after

362
00:15:26,940 --> 00:15:32,140
but the reasons behind it were because

363
00:15:30,610 --> 00:15:33,190
javascript is going to be quite it's

364
00:15:32,140 --> 00:15:34,949
going to be a language that's very

365
00:15:33,190 --> 00:15:38,490
familiar to

366
00:15:34,950 --> 00:15:41,590
developers of decentralized applications

367
00:15:38,490 --> 00:15:43,420
typically the front ends for these apps

368
00:15:41,590 --> 00:15:47,860
are written in JavaScript and a lot of

369
00:15:43,420 --> 00:15:50,319
the tools and frameworks for the

370
00:15:47,860 --> 00:15:54,040
etherium ecosystem are based around

371
00:15:50,320 --> 00:15:56,350
JavaScript so basically it's gonna be

372
00:15:54,040 --> 00:16:00,370
more accessible to smart contract

373
00:15:56,350 --> 00:16:06,700
developers even if it gives us some

374
00:16:00,370 --> 00:16:10,090
headaches during the process and yes so

375
00:16:06,700 --> 00:16:11,830
it's a completely pure JavaScript like

376
00:16:10,090 --> 00:16:13,660
this is designed there to fit into the

377
00:16:11,830 --> 00:16:16,180
tool chains as I've already said it

378
00:16:13,660 --> 00:16:19,689
completely runs within the browser which

379
00:16:16,180 --> 00:16:21,640
is nice and yes

380
00:16:19,690 --> 00:16:24,640
it's designed to fit into these tool

381
00:16:21,640 --> 00:16:27,610
chains so they can easily during their

382
00:16:24,640 --> 00:16:29,199
development lifecycle they can analyze

383
00:16:27,610 --> 00:16:31,800
the bike code and pick up any issues

384
00:16:29,200 --> 00:16:34,600
that may be there quite quite early on

385
00:16:31,800 --> 00:16:38,199
and it's comprised of three components

386
00:16:34,600 --> 00:16:40,480
currently so we have initially an EVM

387
00:16:38,200 --> 00:16:42,670
disassembler so this basically just

388
00:16:40,480 --> 00:16:45,820
disassembles the bike code and this

389
00:16:42,670 --> 00:16:48,310
pause is out all of the instructions and

390
00:16:45,820 --> 00:16:51,490
all of the basic blocks within that bike

391
00:16:48,310 --> 00:16:54,699
code and then we have a partial EVM

392
00:16:51,490 --> 00:16:57,400
emulation engine so the emulation engine

393
00:16:54,700 --> 00:17:02,350
at the moment it doesn't emulate

394
00:16:57,400 --> 00:17:04,359
everything but we emulate basically all

395
00:17:02,350 --> 00:17:08,470
of the stack manipulation instructions

396
00:17:04,359 --> 00:17:10,899
we emulate these fully we don't emulate

397
00:17:08,470 --> 00:17:15,910
storage currently or memory addressable

398
00:17:10,900 --> 00:17:18,250
space and then we have the vulnerability

399
00:17:15,910 --> 00:17:23,650
scanner which basically fits on it can

400
00:17:18,250 --> 00:17:26,230
plug into the EVM emulator so as we are

401
00:17:23,650 --> 00:17:30,160
running the emulator we can basically do

402
00:17:26,230 --> 00:17:34,690
static and dynamic analysis of the the

403
00:17:30,160 --> 00:17:40,510
opcodes as the there and values that are

404
00:17:34,690 --> 00:17:43,330
placed on top of the stack so just yet

405
00:17:40,510 --> 00:17:46,570
more about the architecture so yeah we

406
00:17:43,330 --> 00:17:48,350
convert obviously the instructions parse

407
00:17:46,570 --> 00:17:52,310
out the byte codes

408
00:17:48,350 --> 00:17:54,379
we emulate the internal evm state we

409
00:17:52,310 --> 00:17:57,169
keep track of variables on the stack and

410
00:17:54,380 --> 00:18:01,640
basically because we're not fully

411
00:17:57,170 --> 00:18:03,220
emulating EVM when we reach a NOC codes

412
00:18:01,640 --> 00:18:05,990
that we want to be able to track these

413
00:18:03,220 --> 00:18:08,390
across the stack when we basically just

414
00:18:05,990 --> 00:18:12,470
have a simple tagging mechanism so if

415
00:18:08,390 --> 00:18:14,660
for example a value gets pushed onto the

416
00:18:12,470 --> 00:18:17,120
stack from a specific opcode so if we

417
00:18:14,660 --> 00:18:20,390
say that the block hash opcode is

418
00:18:17,120 --> 00:18:22,639
executed and that pushes up a block hash

419
00:18:20,390 --> 00:18:24,560
to the stack like in this case we're not

420
00:18:22,640 --> 00:18:26,270
gonna but we're not actually executing a

421
00:18:24,560 --> 00:18:29,500
block so we don't have a real block

422
00:18:26,270 --> 00:18:32,750
cache so we just pushed up a magic value

423
00:18:29,500 --> 00:18:35,660
and we tagged this value to say that

424
00:18:32,750 --> 00:18:37,640
this is come from the block hash opcode

425
00:18:35,660 --> 00:18:40,700
and then we can basically track this

426
00:18:37,640 --> 00:18:43,190
through the execution so then if we do

427
00:18:40,700 --> 00:18:46,190
any luck arithmetic operations on this

428
00:18:43,190 --> 00:18:49,510
opcode we're basically gonna keep track

429
00:18:46,190 --> 00:18:53,540
and we know that the output of this in

430
00:18:49,510 --> 00:18:57,650
operation was basically tainted by this

431
00:18:53,540 --> 00:18:59,030
block cache or this user input and that

432
00:18:57,650 --> 00:19:03,080
that's basically just a summary of like

433
00:18:59,030 --> 00:19:04,370
how we go over the emulation like we're

434
00:19:03,080 --> 00:19:06,050
not going into too much detail we're

435
00:19:04,370 --> 00:19:08,000
more focusing on the actual issues and

436
00:19:06,050 --> 00:19:12,050
the results but yeah we basically

437
00:19:08,000 --> 00:19:16,250
process all of these instructions and

438
00:19:12,050 --> 00:19:18,230
then the plug-in or the it has a plug-in

439
00:19:16,250 --> 00:19:21,830
architecture so once we have the

440
00:19:18,230 --> 00:19:25,130
emulator we can basically register we

441
00:19:21,830 --> 00:19:26,960
can plug in the EVM vulnerability

442
00:19:25,130 --> 00:19:28,910
scanner and within the vulnerability

443
00:19:26,960 --> 00:19:32,780
scanner we can register new detectors or

444
00:19:28,910 --> 00:19:36,920
signatures so yeah we basically just

445
00:19:32,780 --> 00:19:39,560
have a very simple way of doing that so

446
00:19:36,920 --> 00:19:43,190
this is just the the rough skeleton of

447
00:19:39,560 --> 00:19:45,710
the vulnerability scanner and basically

448
00:19:43,190 --> 00:19:48,890
it's very simple we have a register

449
00:19:45,710 --> 00:19:50,830
function register signature function and

450
00:19:48,890 --> 00:19:55,010
this just stores off in an array of

451
00:19:50,830 --> 00:19:58,850
signatures and then during the execution

452
00:19:55,010 --> 00:20:00,160
and the EVM emulation we invoke process

453
00:19:58,850 --> 00:20:02,320
instruction and there

454
00:20:00,160 --> 00:20:04,300
we invoke all of the different

455
00:20:02,320 --> 00:20:06,610
signatures and they can have their own

456
00:20:04,300 --> 00:20:08,889
independent logic and they're completely

457
00:20:06,610 --> 00:20:11,490
separated and that's just that a

458
00:20:08,890 --> 00:20:14,050
high-level how we're implementing this

459
00:20:11,490 --> 00:20:16,270
okay so a big topic at the moment is

460
00:20:14,050 --> 00:20:17,740
definitely responsible disclosure so a

461
00:20:16,270 --> 00:20:19,930
lot of vulnerabilities to get disclosed

462
00:20:17,740 --> 00:20:22,330
and then they're immediately pushed out

463
00:20:19,930 --> 00:20:23,950
onto the web for everybody to see and

464
00:20:22,330 --> 00:20:25,540
the entire community goes what you're

465
00:20:23,950 --> 00:20:31,780
doing that's that's really responsible

466
00:20:25,540 --> 00:20:34,360
and we agree as is apparent

467
00:20:31,780 --> 00:20:36,250
so what we're actually going to say at

468
00:20:34,360 --> 00:20:37,149
the moment is we're not going to tell

469
00:20:36,250 --> 00:20:38,560
you any contracts that have

470
00:20:37,150 --> 00:20:41,020
vulnerabilities we're not going to be

471
00:20:38,560 --> 00:20:42,879
telling you where the front pages exist

472
00:20:41,020 --> 00:20:44,050
in those contracts whilst we do have

473
00:20:42,880 --> 00:20:47,680
that data we're not gonna be publishing

474
00:20:44,050 --> 00:20:49,000
it will publish polishing the tool so

475
00:20:47,680 --> 00:20:50,350
you guys can then discover the

476
00:20:49,000 --> 00:20:51,460
vulnerabilities yourself but we're not

477
00:20:50,350 --> 00:20:54,040
going to be actively publishing that

478
00:20:51,460 --> 00:20:55,990
data purely because we don't think that

479
00:20:54,040 --> 00:20:58,300
would be responsible disclosure purely

480
00:20:55,990 --> 00:21:00,370
because the ethereum blockchain is

481
00:20:58,300 --> 00:21:02,409
immutable so as soon as you push up code

482
00:21:00,370 --> 00:21:04,270
to the etherion blockchain you've got no

483
00:21:02,410 --> 00:21:05,470
way of changing it now there are methods

484
00:21:04,270 --> 00:21:07,180
that are currently being developed to

485
00:21:05,470 --> 00:21:10,780
actually assist in being able to change

486
00:21:07,180 --> 00:21:12,580
code if you using a proxy contract in

487
00:21:10,780 --> 00:21:14,139
which you're able to use that proxy

488
00:21:12,580 --> 00:21:16,120
contract to invoke other contracts on

489
00:21:14,140 --> 00:21:17,920
the chain as you can then like patch

490
00:21:16,120 --> 00:21:20,889
move it around without affecting the

491
00:21:17,920 --> 00:21:22,090
end-user but then you've got a similar

492
00:21:20,890 --> 00:21:23,650
problem before what if a vulnerability

493
00:21:22,090 --> 00:21:25,510
for you find a vulnerability in that

494
00:21:23,650 --> 00:21:29,230
proxy contract and the whole cycle

495
00:21:25,510 --> 00:21:30,790
starts again so we got a question there

496
00:21:29,230 --> 00:21:33,460
it's just sort of a question to the to

497
00:21:30,790 --> 00:21:34,960
the community in it goes in a world

498
00:21:33,460 --> 00:21:37,390
where blockchain tech comes more

499
00:21:34,960 --> 00:21:39,220
widespread how do we as an industry see

500
00:21:37,390 --> 00:21:41,050
a responsible disclosure policy

501
00:21:39,220 --> 00:21:41,980
happening and I think that's really

502
00:21:41,050 --> 00:21:43,389
important to start thinking about

503
00:21:41,980 --> 00:21:45,160
especially within the etherion

504
00:21:43,390 --> 00:21:47,560
blockchain is I think we were discussing

505
00:21:45,160 --> 00:21:49,990
yesterday where one of the cities in

506
00:21:47,560 --> 00:21:52,510
Zurich is X Y or X Witsel and sorry is

507
00:21:49,990 --> 00:21:55,720
starting to use blockchain tech as part

508
00:21:52,510 --> 00:21:57,100
of their voting and doing electronic

509
00:21:55,720 --> 00:21:59,710
voting as we all know is quite an

510
00:21:57,100 --> 00:22:02,199
interesting subject security architects

511
00:21:59,710 --> 00:22:03,760
all over the world have tried States in

512
00:22:02,200 --> 00:22:08,320
America who tried it and definitely

513
00:22:03,760 --> 00:22:10,310
failed and obviously blockchain tech is

514
00:22:08,320 --> 00:22:13,939
the resolution to everything so

515
00:22:10,310 --> 00:22:15,320
we'll see how that goes so as I said no

516
00:22:13,940 --> 00:22:16,790
results would be specifically discussed

517
00:22:15,320 --> 00:22:21,290
it was just gonna be percentages and

518
00:22:16,790 --> 00:22:22,340
numbers from here on out so I'm just

519
00:22:21,290 --> 00:22:26,420
going to dive straight into some of the

520
00:22:22,340 --> 00:22:28,760
results I didn't work cool so as I said

521
00:22:26,420 --> 00:22:30,260
before there was two sets of data about

522
00:22:28,760 --> 00:22:33,800
the unique contracts which we took from

523
00:22:30,260 --> 00:22:36,230
all the contracts again hashed the the

524
00:22:33,800 --> 00:22:38,300
contract code just distinct them and put

525
00:22:36,230 --> 00:22:39,860
them into a new table so we've got two

526
00:22:38,300 --> 00:22:41,450
sets of values we've got though the

527
00:22:39,860 --> 00:22:43,580
percentage of those and the percentage

528
00:22:41,450 --> 00:22:45,290
of untrain so we then took the data that

529
00:22:43,580 --> 00:22:46,399
we've we've got and then applied it to

530
00:22:45,290 --> 00:22:49,010
all of the contracts that are on the

531
00:22:46,400 --> 00:22:51,650
chain so what we can see is unique

532
00:22:49,010 --> 00:22:54,530
contracts that we have it's 63 percent

533
00:22:51,650 --> 00:22:58,280
with vulnerabilities that is pretty

534
00:22:54,530 --> 00:23:00,889
pretty hefty amount we were quite I

535
00:22:58,280 --> 00:23:02,720
don't we were sort of expecting a fairly

536
00:23:00,890 --> 00:23:05,750
high number but we weren't expecting

537
00:23:02,720 --> 00:23:08,180
that so that's the unique contracts so

538
00:23:05,750 --> 00:23:12,040
that's just the contracts on their own

539
00:23:08,180 --> 00:23:14,180
with no dupes and then if we look at the

540
00:23:12,040 --> 00:23:16,280
Unchained contract so everything that is

541
00:23:14,180 --> 00:23:18,590
currently live on the ethereum

542
00:23:16,280 --> 00:23:19,910
blockchain as of May 20 18 which is when

543
00:23:18,590 --> 00:23:21,230
the scan took place so they might have

544
00:23:19,910 --> 00:23:22,730
been self destruct functions to have

545
00:23:21,230 --> 00:23:25,700
been caught on those contracts between

546
00:23:22,730 --> 00:23:29,540
now and then so you know just keep that

547
00:23:25,700 --> 00:23:31,310
in mind we have 30 percent so still a

548
00:23:29,540 --> 00:23:32,570
fair amount of contracts that are

549
00:23:31,310 --> 00:23:33,980
currently live on the blockchain that

550
00:23:32,570 --> 00:23:36,950
have vulnerabilities associated with

551
00:23:33,980 --> 00:23:38,930
them and you know these numbers can be

552
00:23:36,950 --> 00:23:41,720
can be can be spun in any which way you

553
00:23:38,930 --> 00:23:44,480
like but key to know we won't be telling

554
00:23:41,720 --> 00:23:45,590
you where those are so now we're just

555
00:23:44,480 --> 00:23:47,030
going to go into a breakdown with the

556
00:23:45,590 --> 00:23:50,050
vulnerabilities so you guys can actually

557
00:23:47,030 --> 00:23:52,430
sort of know what we looked for

558
00:23:50,050 --> 00:23:54,889
discussions about how we looked for them

559
00:23:52,430 --> 00:23:57,980
and that but before we do that has a

560
00:23:54,890 --> 00:23:59,590
quick graph of the date axis of on the

561
00:23:57,980 --> 00:24:02,180
bottom and then the number of deployed

562
00:23:59,590 --> 00:24:04,399
vulnerable contracts and you can

563
00:24:02,180 --> 00:24:05,870
definitely see a sharp increase in front

564
00:24:04,400 --> 00:24:08,510
of all contracts being deployed into the

565
00:24:05,870 --> 00:24:10,790
blockchain now I mean this is just an

566
00:24:08,510 --> 00:24:12,470
arbitrary graph I mean the ethereum

567
00:24:10,790 --> 00:24:14,750
blockchain was barely known in 2015 I

568
00:24:12,470 --> 00:24:16,100
don't even think that the the feature

569
00:24:14,750 --> 00:24:18,020
for smart contracts have been fully

570
00:24:16,100 --> 00:24:21,790
developed and you can see a steady

571
00:24:18,020 --> 00:24:23,929
increase and then a decrease in April

572
00:24:21,790 --> 00:24:27,559
you know it's an arbitrary graphic

573
00:24:23,929 --> 00:24:28,940
looks nice so I thought I'd give

574
00:24:27,559 --> 00:24:31,460
something a little bit a little bit

575
00:24:28,940 --> 00:24:34,159
interesting to look at cool and I'm just

576
00:24:31,460 --> 00:24:37,580
gonna jump into a bit discussing the the

577
00:24:34,159 --> 00:24:41,299
disco the rat inside your random number

578
00:24:37,580 --> 00:24:42,949
generation sorry yeah so basically like

579
00:24:41,299 --> 00:24:46,730
we looked at a number of different

580
00:24:42,950 --> 00:24:49,490
issues and we have developed signatures

581
00:24:46,730 --> 00:24:52,159
for these as part of the initial proof

582
00:24:49,490 --> 00:24:53,840
of concept of a scanner and one of the

583
00:24:52,159 --> 00:24:57,919
first ones is about a random number

584
00:24:53,840 --> 00:24:59,689
generation so like random number

585
00:24:57,919 --> 00:25:01,279
generation in general is a bit of a

586
00:24:59,690 --> 00:25:03,289
tricky subject in this quite a lot of

587
00:25:01,279 --> 00:25:05,690
cases were insecure a random number

588
00:25:03,289 --> 00:25:09,499
generators have been used and we've had

589
00:25:05,690 --> 00:25:12,649
quite detrimental impact when these have

590
00:25:09,499 --> 00:25:15,070
been exploited and yeah like on the

591
00:25:12,649 --> 00:25:16,969
etherium in a deterministic environment

592
00:25:15,070 --> 00:25:20,869
developing secure random number

593
00:25:16,970 --> 00:25:22,249
generators is really difficult so yeah

594
00:25:20,869 --> 00:25:27,199
this is one thing that we really wanted

595
00:25:22,249 --> 00:25:30,909
to look at and typically there's a few

596
00:25:27,200 --> 00:25:35,539
different ways that developers are

597
00:25:30,909 --> 00:25:38,480
implementing random numbers so primarily

598
00:25:35,539 --> 00:25:40,220
using block hashes or block properties

599
00:25:38,480 --> 00:25:44,509
and then people are also using my

600
00:25:40,220 --> 00:25:49,580
pâtisserie schemes where users commit

601
00:25:44,509 --> 00:25:51,830
and reveal numbers as part of like the

602
00:25:49,580 --> 00:25:53,990
protocol of that contract and then also

603
00:25:51,830 --> 00:25:57,649
using external random numbers and

604
00:25:53,990 --> 00:26:00,230
through Oracle's in the etherium

605
00:25:57,649 --> 00:26:04,189
ecosystem for this at the moment we've

606
00:26:00,230 --> 00:26:06,440
only focused on block properties and

607
00:26:04,190 --> 00:26:08,899
these are quite good in terms of if

608
00:26:06,440 --> 00:26:09,409
you're a developer because you get this

609
00:26:08,899 --> 00:26:11,059
number

610
00:26:09,409 --> 00:26:12,230
immediately like with the other schemes

611
00:26:11,059 --> 00:26:15,080
you're gonna have to wait for a callback

612
00:26:12,230 --> 00:26:16,490
or for other users to interact with the

613
00:26:15,080 --> 00:26:18,730
contract whereas if you're using block

614
00:26:16,490 --> 00:26:22,220
properties you get these random numbers

615
00:26:18,730 --> 00:26:25,730
random immediately and you don't need to

616
00:26:22,220 --> 00:26:28,580
rely on any depart ease so you at least

617
00:26:25,730 --> 00:26:30,950
keep the entire system decentralized you

618
00:26:28,580 --> 00:26:33,590
don't break that but there are other

619
00:26:30,950 --> 00:26:35,980
issues that we can see there's basically

620
00:26:33,590 --> 00:26:37,760
four main properties that we see people

621
00:26:35,980 --> 00:26:40,010
generating

622
00:26:37,760 --> 00:26:44,629
you're using as seeds for sources of

623
00:26:40,010 --> 00:26:45,860
entropy and there's a block number which

624
00:26:44,630 --> 00:26:48,440
is obviously the number of the current

625
00:26:45,860 --> 00:26:51,260
block or a block the coin base and this

626
00:26:48,440 --> 00:26:54,169
is the basically the address where the

627
00:26:51,260 --> 00:26:56,769
payout of the miner goes to the time

628
00:26:54,169 --> 00:27:00,350
stamp so this is the time stamp that the

629
00:26:56,769 --> 00:27:02,330
miner has the times that where the block

630
00:27:00,350 --> 00:27:05,178
is mined and the miner has some control

631
00:27:02,330 --> 00:27:07,070
over this and then also the the block

632
00:27:05,179 --> 00:27:11,299
hash typically the block hash is the

633
00:27:07,070 --> 00:27:13,850
most common one we see and there's an

634
00:27:11,299 --> 00:27:17,600
incorrect assumption if you look online

635
00:27:13,850 --> 00:27:19,629
about when it's safe to use these random

636
00:27:17,600 --> 00:27:22,039
numbers and people assume that only

637
00:27:19,630 --> 00:27:24,679
miners can manipulate these values or

638
00:27:22,039 --> 00:27:27,408
use them for an advantage and this just

639
00:27:24,679 --> 00:27:30,919
isn't the case but here people say that

640
00:27:27,409 --> 00:27:33,320
it's acceptable to do only if the payout

641
00:27:30,919 --> 00:27:35,000
of the contract is less than the block

642
00:27:33,320 --> 00:27:36,950
reward so it doesn't make sense for the

643
00:27:35,000 --> 00:27:40,279
miner to throw away the block reward if

644
00:27:36,950 --> 00:27:45,200
the contract payout is only say half an

645
00:27:40,279 --> 00:27:48,260
IVA whereas in reality smart contracts

646
00:27:45,200 --> 00:27:50,600
can gain these numbers very well because

647
00:27:48,260 --> 00:27:51,980
the the properties that the seeds are

648
00:27:50,600 --> 00:27:56,299
known so they can pre-compute

649
00:27:51,980 --> 00:27:59,059
or compute them at one time this is just

650
00:27:56,299 --> 00:28:01,760
an example of how a random number

651
00:27:59,059 --> 00:28:04,460
generation might look like and we

652
00:28:01,760 --> 00:28:05,750
basically we take the block number so

653
00:28:04,460 --> 00:28:08,450
this is the current block that's being

654
00:28:05,750 --> 00:28:10,940
mined and we take one away from this and

655
00:28:08,450 --> 00:28:13,039
this gives us a block number and then we

656
00:28:10,940 --> 00:28:14,929
basically cool block half and we

657
00:28:13,039 --> 00:28:17,419
retrieve the block hash for that and

658
00:28:14,929 --> 00:28:21,590
then we do a modulus operation on that

659
00:28:17,419 --> 00:28:24,799
after casting it to an integer and

660
00:28:21,590 --> 00:28:27,709
basically this provides us a number

661
00:28:24,799 --> 00:28:31,340
between 0 & 9 in this case which appears

662
00:28:27,710 --> 00:28:32,659
to be random so for each time you run

663
00:28:31,340 --> 00:28:34,039
this the block numbers going to be

664
00:28:32,659 --> 00:28:35,330
increasing and it's going to be

665
00:28:34,039 --> 00:28:39,950
outputting a number which seems

666
00:28:35,330 --> 00:28:41,990
unpredictable whereas like if you were

667
00:28:39,950 --> 00:28:44,360
able to basically if you have a contract

668
00:28:41,990 --> 00:28:47,960
and you make an external call to this

669
00:28:44,360 --> 00:28:49,850
function you're able to predict

670
00:28:47,960 --> 00:28:51,680
what you know what the block numbers

671
00:28:49,850 --> 00:28:54,260
gonna be you're gonna be able to figure

672
00:28:51,680 --> 00:28:55,820
out what this hash is gonna be and then

673
00:28:54,260 --> 00:28:59,980
you can only invoke the vulnerable

674
00:28:55,820 --> 00:29:04,610
contract if it works in your favor so

675
00:28:59,980 --> 00:29:05,630
basically how do we detect this so this

676
00:29:04,610 --> 00:29:07,969
is what it looks like at the bytecode

677
00:29:05,630 --> 00:29:10,580
level so this is just the disassembly of

678
00:29:07,970 --> 00:29:14,360
the evm bytecode and we can see up here

679
00:29:10,580 --> 00:29:17,030
we have a block hash operation and this

680
00:29:14,360 --> 00:29:20,600
basically takes an argument which is the

681
00:29:17,030 --> 00:29:22,910
the block number and it pushes what it

682
00:29:20,600 --> 00:29:26,870
takes that and then it pushes the block

683
00:29:22,910 --> 00:29:28,640
hash to the top of the stack and then

684
00:29:26,870 --> 00:29:31,669
basically what we're going to be looking

685
00:29:28,640 --> 00:29:34,250
for the way that you implement this

686
00:29:31,670 --> 00:29:35,630
random number you take this block cache

687
00:29:34,250 --> 00:29:40,160
and then you use it in a modulus

688
00:29:35,630 --> 00:29:42,860
operation so basically we can test to

689
00:29:40,160 --> 00:29:46,340
just the simple test to say if the

690
00:29:42,860 --> 00:29:48,350
current opcode is modulus and then we

691
00:29:46,340 --> 00:29:51,080
basically take the two arguments for

692
00:29:48,350 --> 00:29:54,770
this modulus operation and then we check

693
00:29:51,080 --> 00:29:57,460
to see if either of the values in these

694
00:29:54,770 --> 00:30:01,340
arguments are tainted by the block cache

695
00:29:57,460 --> 00:30:04,010
and if they do then this is the most

696
00:30:01,340 --> 00:30:06,919
probable cases that they are using this

697
00:30:04,010 --> 00:30:09,140
to generate random numbers and this is

698
00:30:06,920 --> 00:30:14,000
what we see like if you if you look

699
00:30:09,140 --> 00:30:15,530
online this is how this method of

700
00:30:14,000 --> 00:30:19,070
generating numbers looks at the bytecode

701
00:30:15,530 --> 00:30:22,190
level so out of all of the results from

702
00:30:19,070 --> 00:30:24,770
this only naught point 8 percent of the

703
00:30:22,190 --> 00:30:26,600
contracts were vulnerable but then we

704
00:30:24,770 --> 00:30:29,389
still had six hundred and four unique

705
00:30:26,600 --> 00:30:32,990
contracts vulnerable to this insecure

706
00:30:29,390 --> 00:30:35,150
random number generation and give them

707
00:30:32,990 --> 00:30:37,850
that it's gonna be typically used by

708
00:30:35,150 --> 00:30:41,000
games or casinos that there could still

709
00:30:37,850 --> 00:30:43,030
be a quite a potential impact if people

710
00:30:41,000 --> 00:30:48,400
start gaming and trying to cheat these

711
00:30:43,030 --> 00:30:48,399
as they might hold quite a large balance

712
00:30:52,780 --> 00:31:03,680
yeah next yeah next yes oh okay

713
00:31:01,550 --> 00:31:06,050
so with the insecure cool so one of the

714
00:31:03,680 --> 00:31:08,870
other issues that we looked for so

715
00:31:06,050 --> 00:31:11,180
basically in aetherium there you you can

716
00:31:08,870 --> 00:31:13,270
make calls to external contracts and

717
00:31:11,180 --> 00:31:16,340
there's a few ways to do this

718
00:31:13,270 --> 00:31:18,470
solidity provides three ways to do this

719
00:31:16,340 --> 00:31:21,409
which are the address that called

720
00:31:18,470 --> 00:31:24,230
r-value address that send and address

721
00:31:21,410 --> 00:31:27,730
that transfer and yet at the UVM byte

722
00:31:24,230 --> 00:31:31,240
code level these all boil down to a cool

723
00:31:27,730 --> 00:31:33,140
opcode and it's basically the way that

724
00:31:31,240 --> 00:31:35,750
there's some slight differences in the

725
00:31:33,140 --> 00:31:38,030
way they're handled and pop codes that

726
00:31:35,750 --> 00:31:40,520
they generate but the important thing to

727
00:31:38,030 --> 00:31:44,139
note is that all of these methods

728
00:31:40,520 --> 00:31:46,550
transfer execution flow to the recipient

729
00:31:44,140 --> 00:31:50,360
and this might not be an issue if you're

730
00:31:46,550 --> 00:31:52,730
actually passing or transferring to a

731
00:31:50,360 --> 00:31:54,409
account owned by or like an externally

732
00:31:52,730 --> 00:31:56,300
controlled account which is run by

733
00:31:54,410 --> 00:32:02,000
private keys but you have no control

734
00:31:56,300 --> 00:32:06,100
over if this is a contract account for

735
00:32:02,000 --> 00:32:09,680
example so in this case you're providing

736
00:32:06,100 --> 00:32:12,050
your passing execution flow to an

737
00:32:09,680 --> 00:32:15,500
external contract which is potentially

738
00:32:12,050 --> 00:32:18,230
untrusted and this occurs because the

739
00:32:15,500 --> 00:32:22,390
EVM doesn't provide a way to transfer

740
00:32:18,230 --> 00:32:22,390
ether without transferring control flow

741
00:32:22,570 --> 00:32:29,030
so basically one of the issues that

742
00:32:26,690 --> 00:32:31,250
we've looked for is using code or value

743
00:32:29,030 --> 00:32:34,430
and this can typically lead to cases of

744
00:32:31,250 --> 00:32:37,130
Rhian fancy so basically like the DAO

745
00:32:34,430 --> 00:32:41,930
hack this was from a lack of recursive

746
00:32:37,130 --> 00:32:44,690
cool and the it was due to the use of a

747
00:32:41,930 --> 00:32:46,340
called up value and there's a couple of

748
00:32:44,690 --> 00:32:48,620
quirks with this so this function

749
00:32:46,340 --> 00:32:51,860
doesn't propagate exceptions to the rule

750
00:32:48,620 --> 00:32:53,870
to the call in contract in the case of

751
00:32:51,860 --> 00:32:57,350
something failing it just returns true

752
00:32:53,870 --> 00:33:01,310
or false and it also forwards all of the

753
00:32:57,350 --> 00:33:03,500
remaining gas to the recipient so if we

754
00:33:01,310 --> 00:33:05,129
pass the if we make this call to an

755
00:33:03,500 --> 00:33:07,590
external contract

756
00:33:05,130 --> 00:33:09,480
the is gonna show you a code execution

757
00:33:07,590 --> 00:33:11,429
and there's no limit on the amount of

758
00:33:09,480 --> 00:33:15,120
gas or the amount of instructions they

759
00:33:11,430 --> 00:33:17,190
can execute so this is just an example

760
00:33:15,120 --> 00:33:19,679
of the code so here we have just the

761
00:33:17,190 --> 00:33:23,310
withdrawal function and inside here we

762
00:33:19,680 --> 00:33:24,690
do a message sender Dork order value and

763
00:33:23,310 --> 00:33:27,030
this is gonna have this is gonna pass

764
00:33:24,690 --> 00:33:30,000
execution flow over and then just

765
00:33:27,030 --> 00:33:32,610
another example there where we basically

766
00:33:30,000 --> 00:33:34,260
do the same but instead of taking the

767
00:33:32,610 --> 00:33:36,179
amount that we're trying to ignore we

768
00:33:34,260 --> 00:33:38,850
withdraw everything so if we think about

769
00:33:36,180 --> 00:33:42,270
how every entrance II attack might work

770
00:33:38,850 --> 00:33:44,149
basically if we look here we have a

771
00:33:42,270 --> 00:33:46,560
require which is basically just a

772
00:33:44,150 --> 00:33:49,140
conditional statement and this will

773
00:33:46,560 --> 00:33:51,120
throw if this condition isn't met so

774
00:33:49,140 --> 00:33:52,950
we're just making sure that the the

775
00:33:51,120 --> 00:33:54,689
balance of the sender is greater than

776
00:33:52,950 --> 00:33:57,600
zero so we are holding some funds so

777
00:33:54,690 --> 00:34:00,900
that for that sender and then if that's

778
00:33:57,600 --> 00:34:03,510
true we then do a call that value and we

779
00:34:00,900 --> 00:34:06,420
pass over the balance that we hold for

780
00:34:03,510 --> 00:34:10,199
this sender so we would draw all of the

781
00:34:06,420 --> 00:34:13,260
funds and then after this cool we then

782
00:34:10,199 --> 00:34:16,678
set their balance to zero what happens

783
00:34:13,260 --> 00:34:18,929
in the case of a recursive call so if

784
00:34:16,679 --> 00:34:21,480
this gets sent to a another smart

785
00:34:18,929 --> 00:34:24,210
contract we pass control to this smart

786
00:34:21,480 --> 00:34:27,350
contract and then that smart contract

787
00:34:24,210 --> 00:34:33,990
and then recall the withdrawal function

788
00:34:27,350 --> 00:34:39,330
and what happens then so we go into when

789
00:34:33,989 --> 00:34:42,209
we make this call value if the we don't

790
00:34:39,330 --> 00:34:43,139
pass any message data then we go back

791
00:34:42,210 --> 00:34:45,230
through what's called a fallback

792
00:34:43,139 --> 00:34:48,870
function so this is this function

793
00:34:45,230 --> 00:34:52,168
parenthesis and this is where code

794
00:34:48,870 --> 00:34:54,509
starts executing so then we basically go

795
00:34:52,168 --> 00:34:57,450
victim dot withdraw all and that takes

796
00:34:54,510 --> 00:35:00,180
us back into this function and because

797
00:34:57,450 --> 00:35:02,970
we don't update the the contract state

798
00:35:00,180 --> 00:35:05,190
until after this first call returns

799
00:35:02,970 --> 00:35:06,299
successfully or not successfully in this

800
00:35:05,190 --> 00:35:09,900
case because we don't check the return

801
00:35:06,300 --> 00:35:11,970
value but until this call finishes we

802
00:35:09,900 --> 00:35:14,400
can basically this comparator this

803
00:35:11,970 --> 00:35:17,089
statement is gonna still equate to true

804
00:35:14,400 --> 00:35:18,310
and we're just going to keep sending

805
00:35:17,090 --> 00:35:22,150
each

806
00:35:18,310 --> 00:35:25,600
to this address until the there's no

807
00:35:22,150 --> 00:35:29,740
ether left in this wallet and yeah this

808
00:35:25,600 --> 00:35:32,740
is the a contract that you could use to

809
00:35:29,740 --> 00:35:37,720
attack a contract which is vulnerable to

810
00:35:32,740 --> 00:35:39,939
a reentrant C issue so in terms of the

811
00:35:37,720 --> 00:35:43,390
the bytecode level how we can observe

812
00:35:39,940 --> 00:35:45,510
this so obviously all three of these

813
00:35:43,390 --> 00:35:49,359
functions implement the cool function

814
00:35:45,510 --> 00:35:51,880
and the gas limit is basically the

815
00:35:49,360 --> 00:35:55,450
amount of gas the forward in this cool

816
00:35:51,880 --> 00:35:58,930
the address that transfer and address

817
00:35:55,450 --> 00:36:03,460
that send they basically only send 2300

818
00:35:58,930 --> 00:36:05,919
gas and it's not enough for what it does

819
00:36:03,460 --> 00:36:08,980
still can pass the execution flow to the

820
00:36:05,920 --> 00:36:11,230
recipient it's not enough gas to make

821
00:36:08,980 --> 00:36:12,850
another external call and it would only

822
00:36:11,230 --> 00:36:15,550
be enough gas for them to actually log

823
00:36:12,850 --> 00:36:17,290
and have been so it's not gonna it's

824
00:36:15,550 --> 00:36:18,970
considered safe against reentrant C

825
00:36:17,290 --> 00:36:23,590
because they're not going to be able to

826
00:36:18,970 --> 00:36:28,810
do anything malicious whereas before

827
00:36:23,590 --> 00:36:31,300
when you do a call that value on the in

828
00:36:28,810 --> 00:36:32,830
the opcodes basically so we can see that

829
00:36:31,300 --> 00:36:34,960
the first argument of this call is the

830
00:36:32,830 --> 00:36:39,870
gas limit and this gas limit is achieved

831
00:36:34,960 --> 00:36:43,570
by invoking the gas operate opcode so

832
00:36:39,870 --> 00:36:45,790
basically we see this call instruction

833
00:36:43,570 --> 00:36:49,950
or this call opcode and if the first

834
00:36:45,790 --> 00:36:52,720
value on the stack is the result of the

835
00:36:49,950 --> 00:36:57,160
gas opcode then we know that this is a

836
00:36:52,720 --> 00:36:59,830
core value operation so when we looked

837
00:36:57,160 --> 00:37:02,680
at the results of this we found that 54%

838
00:36:59,830 --> 00:37:07,060
of all of the contracts at the time we

839
00:37:02,680 --> 00:37:08,649
ran this were vulnerable to or

840
00:37:07,060 --> 00:37:11,160
potentially vulnerable to re-enter NC

841
00:37:08,650 --> 00:37:14,410
and they were using this core value and

842
00:37:11,160 --> 00:37:16,350
that equated to 440 thousand three

843
00:37:14,410 --> 00:37:22,569
hundred and sixty and unique contracts

844
00:37:16,350 --> 00:37:25,779
on the blockchain sure and then moving

845
00:37:22,570 --> 00:37:28,270
on to an unchecked return value so we

846
00:37:25,780 --> 00:37:30,880
have a function call we just let send

847
00:37:28,270 --> 00:37:32,140
and generally what we're looking at in

848
00:37:30,880 --> 00:37:34,150
here is

849
00:37:32,140 --> 00:37:37,210
any function that is returned back to

850
00:37:34,150 --> 00:37:41,980
the parent contract not being handled

851
00:37:37,210 --> 00:37:43,720
correctly after so here's a quick

852
00:37:41,980 --> 00:37:44,830
snippet of code that kind of gives you

853
00:37:43,720 --> 00:37:47,350
an idea of what we're actually looking

854
00:37:44,830 --> 00:37:51,549
for so in terms of how this would be

855
00:37:47,350 --> 00:37:58,720
executed a malicious user could pass

856
00:37:51,550 --> 00:38:00,220
through an amount so I'm really yeah so

857
00:37:58,720 --> 00:38:03,790
they'll be passed through to another

858
00:38:00,220 --> 00:38:08,980
contract and then upon the next contract

859
00:38:03,790 --> 00:38:11,860
failing so they can send it to a when

860
00:38:08,980 --> 00:38:14,260
we're going with this so basically we've

861
00:38:11,860 --> 00:38:17,340
the uncheck return value like if in our

862
00:38:14,260 --> 00:38:21,940
contract we're doing or withdraw and we

863
00:38:17,340 --> 00:38:24,250
basically send this to the caller if

864
00:38:21,940 --> 00:38:27,880
we're not checking the return value of

865
00:38:24,250 --> 00:38:30,640
this if the if we throw an exception or

866
00:38:27,880 --> 00:38:33,400
say that we are a contract and we don't

867
00:38:30,640 --> 00:38:36,160
implement that basically if the call to

868
00:38:33,400 --> 00:38:38,320
that external contract fails we're not

869
00:38:36,160 --> 00:38:40,120
going to check the return value and then

870
00:38:38,320 --> 00:38:42,160
we're still going to decrease the amount

871
00:38:40,120 --> 00:38:44,290
of balance that we hold even if that

872
00:38:42,160 --> 00:38:47,830
transaction failed so we may end up in

873
00:38:44,290 --> 00:38:50,350
an inconsistent state where the contract

874
00:38:47,830 --> 00:38:52,299
thinks that it's paid out when actually

875
00:38:50,350 --> 00:38:55,930
it hasn't because we're not checking

876
00:38:52,300 --> 00:38:58,540
that return value sure and that we can

877
00:38:55,930 --> 00:39:00,370
start to see the the bytecode here we

878
00:38:58,540 --> 00:39:02,770
can see that the core values been pushed

879
00:39:00,370 --> 00:39:06,490
to the stack and then the actual check

880
00:39:02,770 --> 00:39:08,380
is then performed at this point here so

881
00:39:06,490 --> 00:39:10,830
what we do is then we track the cool

882
00:39:08,380 --> 00:39:13,210
functions tag them on the stack and

883
00:39:10,830 --> 00:39:14,560
actually their location as well and at

884
00:39:13,210 --> 00:39:15,940
the end of the execution we can then see

885
00:39:14,560 --> 00:39:17,770
if it's actually returned as a check

886
00:39:15,940 --> 00:39:20,050
value or not and then we've written this

887
00:39:17,770 --> 00:39:22,360
into a signature and again Skan Skan the

888
00:39:20,050 --> 00:39:24,160
chain and what this is resulted for is

889
00:39:22,360 --> 00:39:26,260
that 14% of unique contracts contain

890
00:39:24,160 --> 00:39:28,420
this run ability which rotates to ten

891
00:39:26,260 --> 00:39:30,490
just over ten thousand just under eleven

892
00:39:28,420 --> 00:39:35,590
thousand contracts sorry that actually

893
00:39:30,490 --> 00:39:36,729
have this this fund ability so yeah and

894
00:39:35,590 --> 00:39:39,610
one of the other issues that we've

895
00:39:36,730 --> 00:39:43,300
looked into so is the use of delegate

896
00:39:39,610 --> 00:39:44,740
call and basically delegate call is kind

897
00:39:43,300 --> 00:39:47,340
of similar to

898
00:39:44,740 --> 00:39:49,779
using coal or apply in JavaScript

899
00:39:47,340 --> 00:39:51,670
basically that we have our DAP user here

900
00:39:49,780 --> 00:39:55,119
and they make a call to a regular smart

901
00:39:51,670 --> 00:39:57,880
contract and inside this smart contract

902
00:39:55,119 --> 00:40:01,119
typically only itself can write to its

903
00:39:57,880 --> 00:40:04,020
contract state but here we basically

904
00:40:01,119 --> 00:40:07,090
have library contracts that we pass

905
00:40:04,020 --> 00:40:09,570
execution to and we allow these library

906
00:40:07,090 --> 00:40:11,920
contracts to write to our internal state

907
00:40:09,570 --> 00:40:14,650
so it's basically just yeah used like

908
00:40:11,920 --> 00:40:18,450
bringing in an internal library and that

909
00:40:14,650 --> 00:40:20,890
we trust that that contract is going to

910
00:40:18,450 --> 00:40:27,339
we trust it to operate on our own

911
00:40:20,890 --> 00:40:31,629
storage and yet if we look back to the

912
00:40:27,340 --> 00:40:34,750
one of the parity hacks this is one of

913
00:40:31,630 --> 00:40:38,080
the this is the full-back function from

914
00:40:34,750 --> 00:40:40,060
there multi-sig wallet contract and if

915
00:40:38,080 --> 00:40:41,770
somebody makes a payment to this wallet

916
00:40:40,060 --> 00:40:44,080
it first just does a check to see if

917
00:40:41,770 --> 00:40:47,110
they're receiving ether or not and if

918
00:40:44,080 --> 00:40:48,640
the message value is yep if they are

919
00:40:47,110 --> 00:40:51,880
sending something then they do a deposit

920
00:40:48,640 --> 00:40:56,350
and if they don't they basically forward

921
00:40:51,880 --> 00:40:59,020
this the message data which is the data

922
00:40:56,350 --> 00:41:01,779
that's sent along with the transaction

923
00:40:59,020 --> 00:41:05,140
and is typically basically the first

924
00:41:01,780 --> 00:41:07,140
four bytes of a hash which represents

925
00:41:05,140 --> 00:41:10,660
the function the public function to cool

926
00:41:07,140 --> 00:41:13,960
so if we're not sending money then we

927
00:41:10,660 --> 00:41:15,819
basically pass this through to the

928
00:41:13,960 --> 00:41:18,609
delegate cool so basically we have a

929
00:41:15,820 --> 00:41:21,940
wallet library and this is an external

930
00:41:18,609 --> 00:41:25,770
contract and it has a function called

931
00:41:21,940 --> 00:41:29,680
delegate call and we basically do a

932
00:41:25,770 --> 00:41:32,710
message dot data we pass in the date of

933
00:41:29,680 --> 00:41:34,720
the was passed to this cool and then

934
00:41:32,710 --> 00:41:37,000
that allows the library contractor

935
00:41:34,720 --> 00:41:40,839
basically look at that but because this

936
00:41:37,000 --> 00:41:43,270
is a controllable by the caller all

937
00:41:40,840 --> 00:41:46,330
public functions in the library are

938
00:41:43,270 --> 00:41:50,980
going to be callable by any user within

939
00:41:46,330 --> 00:41:55,779
the context of that users wallet so that

940
00:41:50,980 --> 00:41:58,480
can lead to dangerous situations and if

941
00:41:55,780 --> 00:42:00,910
we look at parity there was yeah

942
00:41:58,480 --> 00:42:04,450
where somebody killed the the actual

943
00:42:00,910 --> 00:42:07,660
library contract itself and one that

944
00:42:04,450 --> 00:42:10,089
resulted in the theft of funds so

945
00:42:07,660 --> 00:42:12,430
basically how we can detect this we have

946
00:42:10,090 --> 00:42:16,690
this cool data copy and this basically

947
00:42:12,430 --> 00:42:19,210
copies the cool data into memory and

948
00:42:16,690 --> 00:42:22,480
then afterwards we have an EM load which

949
00:42:19,210 --> 00:42:25,060
basically gets this from memory onto the

950
00:42:22,480 --> 00:42:27,520
stack and then then we invoke delegate

951
00:42:25,060 --> 00:42:30,040
cool which is then going to invoke the

952
00:42:27,520 --> 00:42:34,330
external library so we can basically

953
00:42:30,040 --> 00:42:36,490
look for if call data basically if the

954
00:42:34,330 --> 00:42:39,850
data if the input data for the current

955
00:42:36,490 --> 00:42:41,259
call gets copied into memory we know the

956
00:42:39,850 --> 00:42:45,160
location in memory that it gets loaded

957
00:42:41,260 --> 00:42:47,200
into and then we do the EM load we pull

958
00:42:45,160 --> 00:42:49,839
out that beta from the memory so we know

959
00:42:47,200 --> 00:42:54,100
that it was a cool data and then that

960
00:42:49,840 --> 00:42:58,350
gets passed into the cool parameter for

961
00:42:54,100 --> 00:43:00,670
the delegate cool and yes 6% of

962
00:42:58,350 --> 00:43:04,890
functions we saw found to be using

963
00:43:00,670 --> 00:43:07,810
fellow got cool and yeah that equates

964
00:43:04,890 --> 00:43:12,220
4562 of the unique contracts that we

965
00:43:07,810 --> 00:43:14,109
looked at so moving on from so it's all

966
00:43:12,220 --> 00:43:17,250
well and good having this data we now

967
00:43:14,109 --> 00:43:19,600
have percentages knowing what

968
00:43:17,250 --> 00:43:21,730
vulnerabilities exist but what can we do

969
00:43:19,600 --> 00:43:24,279
I suppose this is more of a community

970
00:43:21,730 --> 00:43:25,810
thing than anything but as I mentioned

971
00:43:24,280 --> 00:43:28,270
earlier in the presentation the code is

972
00:43:25,810 --> 00:43:30,600
law I think I mentioned this but on the

973
00:43:28,270 --> 00:43:34,030
theorem so the code is immutable and the

974
00:43:30,600 --> 00:43:35,310
etherion mantra is code is law which is

975
00:43:34,030 --> 00:43:37,150
kind of where they want to go with this

976
00:43:35,310 --> 00:43:38,799
but that makes it really difficult for

977
00:43:37,150 --> 00:43:42,430
when vulnerabilities have been found for

978
00:43:38,800 --> 00:43:44,560
changes to be implemented so what else

979
00:43:42,430 --> 00:43:45,910
can be done well we could look at the

980
00:43:44,560 --> 00:43:47,440
human who's actually developing these

981
00:43:45,910 --> 00:43:51,129
contracts and we can provide education

982
00:43:47,440 --> 00:43:55,390
so the NCC D s which is the distributed

983
00:43:51,130 --> 00:43:59,320
app security program project so this is

984
00:43:55,390 --> 00:44:01,060
the D app the the digit excuse me

985
00:43:59,320 --> 00:44:04,000
distributed application version of the

986
00:44:01,060 --> 00:44:05,560
OWASP the NCC have created open Zepplin

987
00:44:04,000 --> 00:44:07,510
have provided a number of libraries that

988
00:44:05,560 --> 00:44:08,950
are able to be used by developers so

989
00:44:07,510 --> 00:44:11,840
they could just call the open zeppelin

990
00:44:08,950 --> 00:44:14,120
like zeppelin libraries and in this

991
00:44:11,840 --> 00:44:17,020
by which actually provides an online

992
00:44:14,120 --> 00:44:20,779
tool similar to this which will provide

993
00:44:17,020 --> 00:44:23,210
formal verification of smart contracts

994
00:44:20,780 --> 00:44:25,250
and then you can also look at the SDLC

995
00:44:23,210 --> 00:44:27,530
and improve the tooling as part of the

996
00:44:25,250 --> 00:44:29,870
sdse lifecycle so potentially having a

997
00:44:27,530 --> 00:44:32,420
number of applications that provide a

998
00:44:29,870 --> 00:44:34,370
bytecode analysis or static analysis the

999
00:44:32,420 --> 00:44:36,800
code as part of your SDR see workflow

1000
00:44:34,370 --> 00:44:37,210
it's a part of your build or that kind

1001
00:44:36,800 --> 00:44:39,440
of thing

1002
00:44:37,210 --> 00:44:41,090
and remix is definitely going a long way

1003
00:44:39,440 --> 00:44:43,520
to help with this which is the official

1004
00:44:41,090 --> 00:44:46,250
development tool definitely check that

1005
00:44:43,520 --> 00:44:47,840
out if you've not seen it and then just

1006
00:44:46,250 --> 00:44:50,360
into a quick bit of future work I know

1007
00:44:47,840 --> 00:44:51,890
we're running out of time so we're gonna

1008
00:44:50,360 --> 00:44:54,560
definitely continue the work that we

1009
00:44:51,890 --> 00:44:56,509
combine gonna put in more Admiral rules

1010
00:44:54,560 --> 00:44:58,220
for vulnerabilities we're looking at

1011
00:44:56,510 --> 00:45:00,320
implementing what the storage and memory

1012
00:44:58,220 --> 00:45:02,209
in the emulator potentially looking at

1013
00:45:00,320 --> 00:45:04,070
fuzzing to see what we can do

1014
00:45:02,210 --> 00:45:05,810
definitely a dashboard for continual

1015
00:45:04,070 --> 00:45:07,550
scaling of your frame ever watching so

1016
00:45:05,810 --> 00:45:09,650
what we want is a website that we can

1017
00:45:07,550 --> 00:45:11,960
look at that is just gonna continually

1018
00:45:09,650 --> 00:45:13,400
show you stats for vulnerabilities

1019
00:45:11,960 --> 00:45:16,010
having the percentage-wise

1020
00:45:13,400 --> 00:45:19,010
of what's there and then we're also

1021
00:45:16,010 --> 00:45:20,990
looking at a web interface for ease of

1022
00:45:19,010 --> 00:45:21,770
use and reverse engineering so at the

1023
00:45:20,990 --> 00:45:24,350
moment it's just a command-line

1024
00:45:21,770 --> 00:45:27,290
interface that returns a JSON and then

1025
00:45:24,350 --> 00:45:28,759
we can do with that what we please and

1026
00:45:27,290 --> 00:45:30,050
there's just a couple of potential you

1027
00:45:28,760 --> 00:45:32,900
know screenshots of what the tool might

1028
00:45:30,050 --> 00:45:34,640
eventually look like pretty simple put

1029
00:45:32,900 --> 00:45:36,710
in your byte code or a 10 or potentially

1030
00:45:34,640 --> 00:45:39,620
contract address and then it gives you

1031
00:45:36,710 --> 00:45:42,140
your disassembly yeah so this is just

1032
00:45:39,620 --> 00:45:44,900
what it currently looks like but yeah

1033
00:45:42,140 --> 00:45:47,150
we've not integrated all of the security

1034
00:45:44,900 --> 00:45:48,320
and our this the scanner into this bit

1035
00:45:47,150 --> 00:45:50,150
as well

1036
00:45:48,320 --> 00:45:51,320
and we're also just working on the graph

1037
00:45:50,150 --> 00:45:54,740
view at the moment but this will be

1038
00:45:51,320 --> 00:45:56,840
released with the tool and oh yeah you

1039
00:45:54,740 --> 00:45:59,959
can either paste in your wor bytecode or

1040
00:45:56,840 --> 00:46:02,300
a contract address and it will go ahead

1041
00:45:59,960 --> 00:46:05,570
and provide you with an online

1042
00:46:02,300 --> 00:46:08,390
disassembler and perform the run the

1043
00:46:05,570 --> 00:46:10,190
tool against these contracts valium so

1044
00:46:08,390 --> 00:46:12,140
thank you very much we hope you've

1045
00:46:10,190 --> 00:46:14,030
enjoyed our talk found it insightful or

1046
00:46:12,140 --> 00:46:15,560
interesting it will be set with some

1047
00:46:14,030 --> 00:46:16,970
questions I think Tom's going to be

1048
00:46:15,560 --> 00:46:18,860
dealing with we have a little bit of

1049
00:46:16,970 --> 00:46:22,930
time for corn but you guys almost hit

1050
00:46:18,860 --> 00:46:22,930
the limit well done oh yeah

1051
00:46:25,400 --> 00:46:29,130
you guys like to use your timer cool

1052
00:46:27,750 --> 00:46:31,260
okay I just I say thank you this is my

1053
00:46:29,130 --> 00:46:32,580
first time talking so they're flustered

1054
00:46:31,260 --> 00:46:33,900
in the middle there but no it's cool

1055
00:46:32,580 --> 00:46:36,360
thank you very much guys I was really

1056
00:46:33,900 --> 00:46:37,680
really yeah technical very in-depth talk

1057
00:46:36,360 --> 00:46:39,120
and yeah that's what we want to have at

1058
00:46:37,680 --> 00:46:41,669
these kind of conferences obviously like

1059
00:46:39,120 --> 00:46:44,400
yeah really see people showing their

1060
00:46:41,670 --> 00:46:46,800
research on yeah how seemingly insecure

1061
00:46:44,400 --> 00:46:48,120
a lot of contracts are out there anyone

1062
00:46:46,800 --> 00:46:50,220
have any questions quickly we have a

1063
00:46:48,120 --> 00:46:52,049
couple minutes so any specific questions

1064
00:46:50,220 --> 00:46:56,790
anyone has all right awesome

1065
00:46:52,050 --> 00:47:00,240
make it as hard as possible I don't so

1066
00:46:56,790 --> 00:47:04,130
out of all those venerable contracts Oh

1067
00:47:00,240 --> 00:47:07,770
many were auntie Anne Oh many were

1068
00:47:04,130 --> 00:47:10,170
exploitable basically only come that we

1069
00:47:07,770 --> 00:47:11,460
can tie those kind of statics so we

1070
00:47:10,170 --> 00:47:14,610
didn't actually go down into that sort

1071
00:47:11,460 --> 00:47:16,560
of granular level purely because fights

1072
00:47:14,610 --> 00:47:18,270
I could skip back three but there are

1073
00:47:16,560 --> 00:47:20,520
about just off talking like everything

1074
00:47:18,270 --> 00:47:22,500
was 59,000 the empty contracts which

1075
00:47:20,520 --> 00:47:25,140
could have been from out of gas

1076
00:47:22,500 --> 00:47:27,230
exceptions or self destruct functions

1077
00:47:25,140 --> 00:47:29,640
that were in the within the in the code

1078
00:47:27,230 --> 00:47:32,010
but what we didn't do was due to the the

1079
00:47:29,640 --> 00:47:34,799
size of contracts is we took a sliver of

1080
00:47:32,010 --> 00:47:37,500
contracts to ensure that the tool was

1081
00:47:34,800 --> 00:47:39,180
working as intended but what we didn't

1082
00:47:37,500 --> 00:47:40,440
go ahead and do is sort of make a log of

1083
00:47:39,180 --> 00:47:42,060
what was exploitable and what was not

1084
00:47:40,440 --> 00:47:44,090
because then we get into the realms of

1085
00:47:42,060 --> 00:47:45,840
how do we then disclose this information

1086
00:47:44,090 --> 00:47:47,370
obviously not gonna put up on a

1087
00:47:45,840 --> 00:47:49,740
presentation and have out on the world

1088
00:47:47,370 --> 00:47:52,410
because that puts us in a sticky

1089
00:47:49,740 --> 00:47:55,439
situation but definitely we'll be

1090
00:47:52,410 --> 00:47:57,029
looking at that in the future going in

1091
00:47:55,440 --> 00:47:58,680
and taking taking some random contracts

1092
00:47:57,030 --> 00:48:00,870
and working out what what's there and

1093
00:47:58,680 --> 00:48:04,410
what's not apology this is a bit vague

1094
00:48:00,870 --> 00:48:06,630
for an answer but yeah we it's something

1095
00:48:04,410 --> 00:48:08,940
we can't really guarantee I think also

1096
00:48:06,630 --> 00:48:10,050
look we've so like any vulnerability

1097
00:48:08,940 --> 00:48:13,230
scanner like you're never going to

1098
00:48:10,050 --> 00:48:15,090
expect the scanner to provide you like a

1099
00:48:13,230 --> 00:48:17,550
definitive list of which results are

1100
00:48:15,090 --> 00:48:20,070
exploitable like you look at the best

1101
00:48:17,550 --> 00:48:21,930
static analysis out there and a large

1102
00:48:20,070 --> 00:48:24,300
amount of the results as still false

1103
00:48:21,930 --> 00:48:25,919
positives it might match a specific pan

1104
00:48:24,300 --> 00:48:28,830
but there may be other mitigations there

1105
00:48:25,920 --> 00:48:31,440
and without digging into over 70,000

1106
00:48:28,830 --> 00:48:33,180
contracts manually it's going to be

1107
00:48:31,440 --> 00:48:35,120
difficult to provide which ones are are

1108
00:48:33,180 --> 00:48:45,810
specifically exploitable

1109
00:48:35,120 --> 00:48:47,970
any other questions thanks for the nice

1110
00:48:45,810 --> 00:48:50,370
talk you showed this one graph that

1111
00:48:47,970 --> 00:48:52,080
shows the increase of vulnerable

1112
00:48:50,370 --> 00:48:54,540
contracts that have been launched right

1113
00:48:52,080 --> 00:48:56,819
so I've interested in seeing the numbers

1114
00:48:54,540 --> 00:48:59,100
of the overall contracts that have been

1115
00:48:56,820 --> 00:49:02,040
launched in comparison so is it that

1116
00:48:59,100 --> 00:49:04,380
there's more and more contracts like the

1117
00:49:02,040 --> 00:49:07,140
fraction of contracts that's launched is

1118
00:49:04,380 --> 00:49:08,880
it getting more vulnerable or is this

1119
00:49:07,140 --> 00:49:10,560
just a matter of the fact that we are

1120
00:49:08,880 --> 00:49:12,300
seeing more and more contracts overall

1121
00:49:10,560 --> 00:49:13,380
yeah I think it's the second point you

1122
00:49:12,300 --> 00:49:14,670
we're definitely seeing a lot more

1123
00:49:13,380 --> 00:49:18,390
contracts being submitted to the

1124
00:49:14,670 --> 00:49:19,710
blockchain I mean you know how it is so

1125
00:49:18,390 --> 00:49:21,029
for the likes of remix for example gives

1126
00:49:19,710 --> 00:49:24,240
you a fairly simple boilerplate

1127
00:49:21,030 --> 00:49:25,950
contracts people get etherium you know I

1128
00:49:24,240 --> 00:49:27,660
want to start my development that go on

1129
00:49:25,950 --> 00:49:29,250
and they'll just immediately compile and

1130
00:49:27,660 --> 00:49:32,220
push that the boilerplate straight to

1131
00:49:29,250 --> 00:49:34,800
the blockchain so we see you'll see

1132
00:49:32,220 --> 00:49:37,140
quite a spike in contracts that didn't

1133
00:49:34,800 --> 00:49:39,570
really do anything but then for those

1134
00:49:37,140 --> 00:49:41,910
that are vulnerable yeah we are seeing a

1135
00:49:39,570 --> 00:49:43,980
sort of I think I wouldn't say the

1136
00:49:41,910 --> 00:49:47,160
increases percentage proportionate so

1137
00:49:43,980 --> 00:49:49,590
it's staying relatively flat but you do

1138
00:49:47,160 --> 00:49:51,480
get some spikes I mean it's kind of hard

1139
00:49:49,590 --> 00:49:54,140
to say it's kind of you know as the tool

1140
00:49:51,480 --> 00:49:58,680
gets more sorry as the theorem gets more

1141
00:49:54,140 --> 00:50:00,240
popular it's definitely gonna see more

1142
00:49:58,680 --> 00:50:01,589
vulnerabilities but then what's gonna

1143
00:50:00,240 --> 00:50:04,950
see more contracts so the percentage is

1144
00:50:01,590 --> 00:50:06,540
probably lower and the space has seen

1145
00:50:04,950 --> 00:50:09,089
quite a lot of development in security

1146
00:50:06,540 --> 00:50:11,100
tools and knowledge and spreading that

1147
00:50:09,090 --> 00:50:12,420
knowledge which is really great and you

1148
00:50:11,100 --> 00:50:13,589
know talks like this and other

1149
00:50:12,420 --> 00:50:15,510
conferences are definitely helping

1150
00:50:13,590 --> 00:50:17,070
spread the word and definitely getting

1151
00:50:15,510 --> 00:50:20,040
the developers to think in a secure way

1152
00:50:17,070 --> 00:50:22,170
because now immutable code not being

1153
00:50:20,040 --> 00:50:23,640
able to be modified as soon as it's

1154
00:50:22,170 --> 00:50:25,320
there you that's it

1155
00:50:23,640 --> 00:50:28,170
you need you've got a hope you've got to

1156
00:50:25,320 --> 00:50:30,510
make sure that that code is is secure

1157
00:50:28,170 --> 00:50:32,160
and it's not gonna cost your clients or

1158
00:50:30,510 --> 00:50:35,790
customers money at the end of the day I

1159
00:50:32,160 --> 00:50:38,520
think is well like with the the adoption

1160
00:50:35,790 --> 00:50:42,029
of things like open Zeppelin's like

1161
00:50:38,520 --> 00:50:43,440
interfaces for like ERC 20 tokens so

1162
00:50:42,030 --> 00:50:45,720
like that could have had like a

1163
00:50:43,440 --> 00:50:46,900
significant drop in vulnerable contracts

1164
00:50:45,720 --> 00:50:48,910
deployed

1165
00:50:46,900 --> 00:50:51,430
so people previously were implementing

1166
00:50:48,910 --> 00:50:54,730
these standards themselves instead of

1167
00:50:51,430 --> 00:50:57,669
using secure reusable frameworks out

1168
00:50:54,730 --> 00:50:59,819
there but when these people adopt these

1169
00:50:57,670 --> 00:51:02,410
frameworks III imagine that

1170
00:50:59,819 --> 00:51:04,000
vulnerabilities are gonna drop but again

1171
00:51:02,410 --> 00:51:06,399
it does come down to promoting those

1172
00:51:04,000 --> 00:51:08,440
frameworks and having the developers

1173
00:51:06,400 --> 00:51:09,670
know about them so the more we can get

1174
00:51:08,440 --> 00:51:12,700
out there and save developers tailor

1175
00:51:09,670 --> 00:51:15,339
these secure audited libraries exist

1176
00:51:12,700 --> 00:51:16,569
please please use them you know don't

1177
00:51:15,339 --> 00:51:17,950
reinvent the wheel no one goes and

1178
00:51:16,569 --> 00:51:20,558
writes their own hashing algorithm or

1179
00:51:17,950 --> 00:51:21,910
like cryptography because there's plenty

1180
00:51:20,559 --> 00:51:23,410
of clever people that have done it and

1181
00:51:21,910 --> 00:51:25,270
it's been peer reviewed so we should

1182
00:51:23,410 --> 00:51:26,950
definitely promote that sort of mindset

1183
00:51:25,270 --> 00:51:28,029
and it's it's not something to be

1184
00:51:26,950 --> 00:51:30,700
ashamed of that you're using a library

1185
00:51:28,029 --> 00:51:33,279
and you know by all means implement that

1186
00:51:30,700 --> 00:51:35,319
implement the ERC tokens on your own but

1187
00:51:33,279 --> 00:51:36,730
if you push it to a live blockchain and

1188
00:51:35,319 --> 00:51:39,390
actually use it for production data

1189
00:51:36,730 --> 00:51:41,770
you're you're walking a fine line

1190
00:51:39,390 --> 00:51:43,118
cool unfortunate I think we're out of

1191
00:51:41,770 --> 00:51:44,710
time for this one now but thank you once

1192
00:51:43,119 --> 00:51:46,510
more gentlemen it's been very very

1193
00:51:44,710 --> 00:51:48,270
interesting and yeah thank you very much

1194
00:51:46,510 --> 00:51:48,500
once more

1195
00:51:48,270 --> 00:51:52,599
[Music]

1196
00:51:48,500 --> 00:51:52,599
[Applause]

