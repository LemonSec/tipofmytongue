1
00:00:02,990 --> 00:00:09,510
hello Daniel Radice Becker I work for

2
00:00:07,170 --> 00:00:12,360
Swisscom c-cert but this talk is not

3
00:00:09,510 --> 00:00:15,330
about Swisscom I'm presenting private

4
00:00:12,360 --> 00:00:19,259
research he wrote a little tool recently

5
00:00:15,330 --> 00:00:22,410
ex new one to monitor Mac OS for Muller

6
00:00:19,260 --> 00:00:26,160
and intrusions and I'd like to present

7
00:00:22,410 --> 00:00:30,390
that work to you I'd like to start off

8
00:00:26,160 --> 00:00:32,940
with a little quote from Apple Mike OS

9
00:00:30,390 --> 00:00:37,079
doesn't get PC viruses and its built-in

10
00:00:32,940 --> 00:00:38,820
defences help you keep safe from other

11
00:00:37,079 --> 00:00:42,930
malware without the hassle of constant

12
00:00:38,820 --> 00:00:47,519
alerts and sweeps so I guess that's the

13
00:00:42,930 --> 00:00:50,969
end of my talk now but on a more serious

14
00:00:47,520 --> 00:00:54,690
note things have changed I guess and

15
00:00:50,969 --> 00:00:59,730
looking at multi-tier repository of

16
00:00:54,690 --> 00:01:03,780
malware families there's 37 make modern

17
00:00:59,730 --> 00:01:07,530
families for mac OS currently there's

18
00:01:03,780 --> 00:01:10,590
everything from ransomware ad where

19
00:01:07,530 --> 00:01:12,270
there's banking Trojans I've highlighted

20
00:01:10,590 --> 00:01:17,130
those mother families which are

21
00:01:12,270 --> 00:01:20,220
attributed to state actors it's not the

22
00:01:17,130 --> 00:01:22,979
most scientific method to motivate

23
00:01:20,220 --> 00:01:26,189
research like this but I think it's good

24
00:01:22,979 --> 00:01:30,420
enough I feel that a Mac should be the

25
00:01:26,189 --> 00:01:32,220
weakest target in your organization we

26
00:01:30,420 --> 00:01:36,110
can also look at the meter attack

27
00:01:32,220 --> 00:01:39,170
framework it's a interesting resource

28
00:01:36,110 --> 00:01:42,000
cataloging techniques and tactics of

29
00:01:39,170 --> 00:01:43,799
adversaries I will not go through all of

30
00:01:42,000 --> 00:01:47,630
these now in detail I just picked a few

31
00:01:43,799 --> 00:01:49,799
at random which are relevant on Mac OS

32
00:01:47,630 --> 00:01:52,520
you will notice that many of them

33
00:01:49,799 --> 00:01:55,110
involve running command-line utilities

34
00:01:52,520 --> 00:01:57,840
which is something that is very noisy if

35
00:01:55,110 --> 00:02:01,619
you have monitoring similar to sessemann

36
00:01:57,840 --> 00:02:03,600
on Windows so speaking of system a lot

37
00:02:01,619 --> 00:02:06,990
of organizations use this tool on

38
00:02:03,600 --> 00:02:08,239
Windows sysinternals tools from mark

39
00:02:06,990 --> 00:02:11,989
russinovich

40
00:02:08,239 --> 00:02:14,810
very powerful can log a lot of very

41
00:02:11,989 --> 00:02:17,910
interesting information

42
00:02:14,810 --> 00:02:19,580
most notably process creation but also a

43
00:02:17,910 --> 00:02:28,650
lot of other things like driver loads

44
00:02:19,580 --> 00:02:33,480
registry you name it this is an excerpt

45
00:02:28,650 --> 00:02:35,190
of one of these events those of you who

46
00:02:33,480 --> 00:02:38,760
look at malware regularly will know

47
00:02:35,190 --> 00:02:45,060
which one disease I guess anyone care to

48
00:02:38,760 --> 00:02:48,988
guess I heard in three was the solution

49
00:02:45,060 --> 00:02:52,980
to the last question anyway this is Rita

50
00:02:48,989 --> 00:02:56,640
fee banking Trojan which downloads and

51
00:02:52,980 --> 00:03:01,280
installs so cat and torque client and

52
00:02:56,640 --> 00:03:06,839
this is the the persistence that starts

53
00:03:01,280 --> 00:03:08,780
via MSHDA XA the socket which redirects

54
00:03:06,840 --> 00:03:11,069
traffic from the browser to the Tor

55
00:03:08,780 --> 00:03:14,790
client these are things that you can see

56
00:03:11,069 --> 00:03:17,040
in these events so when using these to

57
00:03:14,790 --> 00:03:20,850
monitor large fleets of systems for

58
00:03:17,040 --> 00:03:24,298
malware and intrusions typical setup for

59
00:03:20,850 --> 00:03:27,108
Windows looks like this you deploy

60
00:03:24,299 --> 00:03:31,200
assessment on the endpoints servers

61
00:03:27,109 --> 00:03:33,569
workstations laptops you collect these

62
00:03:31,200 --> 00:03:36,780
events into the local Windows Event log

63
00:03:33,569 --> 00:03:40,649
you forward them somehow to your central

64
00:03:36,780 --> 00:03:42,389
log collection infrastructure and they

65
00:03:40,650 --> 00:03:45,750
end up at some point in analytics

66
00:03:42,389 --> 00:03:49,230
platform where people like me query them

67
00:03:45,750 --> 00:03:52,920
for well to find attackers to find

68
00:03:49,230 --> 00:03:56,819
infected systems to do lock forensics

69
00:03:52,920 --> 00:04:00,750
after a breach it's a very very valuable

70
00:03:56,819 --> 00:04:02,970
tool so assuming you're an organization

71
00:04:00,750 --> 00:04:06,799
that has these capabilities deployed on

72
00:04:02,970 --> 00:04:09,630
Windows we would like something similar

73
00:04:06,799 --> 00:04:12,329
for the Mac right we have all the pieces

74
00:04:09,630 --> 00:04:15,590
already in place the only thing that is

75
00:04:12,329 --> 00:04:19,200
kind of missing is the agent that

76
00:04:15,590 --> 00:04:23,400
produces locks which are similar to

77
00:04:19,200 --> 00:04:26,479
locks produced by system there are

78
00:04:23,400 --> 00:04:26,479
commercial solutions

79
00:04:26,920 --> 00:04:30,550
but they usually come with a lot of

80
00:04:28,780 --> 00:04:32,679
other infrastructure as well and they

81
00:04:30,550 --> 00:04:40,300
don't fit so well into an environment

82
00:04:32,680 --> 00:04:42,490
that you already use salesmen in so I

83
00:04:40,300 --> 00:04:47,320
set out to find a solution to this

84
00:04:42,490 --> 00:04:49,090
problem but before that we need to think

85
00:04:47,320 --> 00:04:51,490
about what we actually want to monitor

86
00:04:49,090 --> 00:04:53,560
when we look at processes and I want to

87
00:04:51,490 --> 00:04:56,410
focus on processes because that's really

88
00:04:53,560 --> 00:04:59,200
the core of a monitoring solution like

89
00:04:56,410 --> 00:05:03,280
this all the other events somehow relate

90
00:04:59,200 --> 00:05:05,020
to events well to processes in the end

91
00:05:03,280 --> 00:05:08,380
that perform certain actions on the

92
00:05:05,020 --> 00:05:10,599
system so in Mac OS situation is maybe

93
00:05:08,380 --> 00:05:15,400
slightly more complicated than what

94
00:05:10,600 --> 00:05:19,270
we're used to from Windows you probably

95
00:05:15,400 --> 00:05:24,150
heard that Mac the Mac kernel is a

96
00:05:19,270 --> 00:05:27,789
combination of Mach and BST and i/o kit

97
00:05:24,150 --> 00:05:30,070
so you have the mark part the lower bit

98
00:05:27,790 --> 00:05:32,290
here which is really the scheduler

99
00:05:30,070 --> 00:05:34,930
that's where the threads live that's

100
00:05:32,290 --> 00:05:38,470
where virtual memory mappings live

101
00:05:34,930 --> 00:05:42,610
that's where IPC live lives the Mach

102
00:05:38,470 --> 00:05:45,400
messaging and then you have the BSD bits

103
00:05:42,610 --> 00:05:47,200
taken from FreeBSD glued on top and they

104
00:05:45,400 --> 00:05:49,419
provide all the things basically that

105
00:05:47,200 --> 00:05:53,020
you see from user space things like

106
00:05:49,420 --> 00:05:56,380
processes things like user IDs the

107
00:05:53,020 --> 00:06:00,370
networking stack file system the unique

108
00:05:56,380 --> 00:06:02,710
security model and you have both parts

109
00:06:00,370 --> 00:06:05,170
of the kernel exposed to userland

110
00:06:02,710 --> 00:06:07,479
through different mechanisms I okay this

111
00:06:05,170 --> 00:06:09,970
just the driver framework that Apple

112
00:06:07,480 --> 00:06:12,340
added to this a more modern way to write

113
00:06:09,970 --> 00:06:15,820
device drivers that's less relevant to

114
00:06:12,340 --> 00:06:18,909
our question here but the thing is that

115
00:06:15,820 --> 00:06:20,860
we have different things that are

116
00:06:18,910 --> 00:06:24,040
similar to processes at different levels

117
00:06:20,860 --> 00:06:27,700
so at the very core we add on the Mach

118
00:06:24,040 --> 00:06:31,540
level we have we have the tasks which is

119
00:06:27,700 --> 00:06:36,400
the entity that Mach uses to repeat

120
00:06:31,540 --> 00:06:39,790
memory mappings and the threads they're

121
00:06:36,400 --> 00:06:40,419
part of these tasks then on the BST

122
00:06:39,790 --> 00:06:43,570
layer

123
00:06:40,420 --> 00:06:48,060
we have processes and finally in the in

124
00:06:43,570 --> 00:06:52,659
user space we have app kit and co-op

125
00:06:48,060 --> 00:06:56,320
applications which are kind of different

126
00:06:52,660 --> 00:06:59,790
entity as well but what we're most

127
00:06:56,320 --> 00:07:03,790
interested in are the actual processes

128
00:06:59,790 --> 00:07:06,420
so luckily there is a one-to-one

129
00:07:03,790 --> 00:07:12,160
relationship between VSD processes and

130
00:07:06,420 --> 00:07:15,000
mark tasks they're just kept in parallel

131
00:07:12,160 --> 00:07:19,270
in the kernel in different structures

132
00:07:15,000 --> 00:07:20,950
when you for example use PS to query the

133
00:07:19,270 --> 00:07:23,469
list of processes

134
00:07:20,950 --> 00:07:26,770
that's that information is taken out of

135
00:07:23,470 --> 00:07:30,580
the bsd part the bsd bookkeeping of

136
00:07:26,770 --> 00:07:34,390
processes whereas the scheduler that

137
00:07:30,580 --> 00:07:34,990
actually runs the code on the CPU uses

138
00:07:34,390 --> 00:07:42,240
the task

139
00:07:34,990 --> 00:07:42,240
David Emmel task list to to do its work

140
00:07:44,760 --> 00:07:51,940
so what we're still looking for a way to

141
00:07:48,610 --> 00:07:56,670
actually monitor or get information

142
00:07:51,940 --> 00:07:56,670
about new processes being started right

143
00:07:56,880 --> 00:08:05,409
so the relevant calls here on a Mac or

144
00:08:00,460 --> 00:08:07,330
fork and exec I guess most of you know

145
00:08:05,410 --> 00:08:11,650
about that it's kind of operating

146
00:08:07,330 --> 00:08:13,930
systems basics then there's the newer

147
00:08:11,650 --> 00:08:17,469
POSIX spawn and then there's the mark

148
00:08:13,930 --> 00:08:20,820
specific tasks create call that is used

149
00:08:17,470 --> 00:08:26,500
to create one of these lower level tasks

150
00:08:20,820 --> 00:08:28,990
I'll just quickly go through them for

151
00:08:26,500 --> 00:08:32,200
candy for card used to create a new

152
00:08:28,990 --> 00:08:35,979
process but they don't load an actual

153
00:08:32,200 --> 00:08:38,940
executable image so what you usually do

154
00:08:35,979 --> 00:08:42,370
to create a new process is you first for

155
00:08:38,940 --> 00:08:45,070
that kind of clones your process as it

156
00:08:42,370 --> 00:08:47,110
is exactly as it is and then when one of

157
00:08:45,070 --> 00:08:51,370
the processes you call exact to load a

158
00:08:47,110 --> 00:08:54,250
new executable image so that's the first

159
00:08:51,370 --> 00:08:56,080
pattern I list here

160
00:08:54,250 --> 00:08:59,050
but that's not the only way to use these

161
00:08:56,080 --> 00:09:02,980
two calls on Windows this is one system

162
00:08:59,050 --> 00:09:07,060
call but on UNIX you and in this regard

163
00:09:02,980 --> 00:09:10,630
the Mac is a UNIX system you can combine

164
00:09:07,060 --> 00:09:14,140
them in different ways so you can exit

165
00:09:10,630 --> 00:09:17,320
twice in a row for example if you run a

166
00:09:14,140 --> 00:09:18,790
system where you get a bash as a login

167
00:09:17,320 --> 00:09:20,830
shell you don't like - but you're not

168
00:09:18,790 --> 00:09:23,349
administrative left the rights to change

169
00:09:20,830 --> 00:09:27,550
your shell maybe you can replace your

170
00:09:23,350 --> 00:09:30,940
shell by execute different shell or you

171
00:09:27,550 --> 00:09:34,240
can fork twice which is the traditional

172
00:09:30,940 --> 00:09:37,320
way to detach from a terminal and start

173
00:09:34,240 --> 00:09:37,320
as a daemon process

174
00:09:37,540 --> 00:09:42,819
there's also patterns relate to network

175
00:09:40,060 --> 00:09:46,810
programming so the traditional way to

176
00:09:42,820 --> 00:09:49,810
write a network server is to fork to

177
00:09:46,810 --> 00:09:55,540
fork your prose or process for every

178
00:09:49,810 --> 00:09:58,109
incoming connection and then more modern

179
00:09:55,540 --> 00:10:03,160
ways well modern this is all pre

180
00:09:58,110 --> 00:10:04,870
multi-threading techniques so people

181
00:10:03,160 --> 00:10:07,500
started optimizing that right in pre

182
00:10:04,870 --> 00:10:10,750
fork so first doing a lot of Forks

183
00:10:07,500 --> 00:10:12,520
having a pool of processes ready so they

184
00:10:10,750 --> 00:10:15,310
don't need to be started when connecting

185
00:10:12,520 --> 00:10:17,319
our connections come in anyway the key

186
00:10:15,310 --> 00:10:19,300
message is we can't just rely on the

187
00:10:17,320 --> 00:10:22,240
fact that there's always fork and exec

188
00:10:19,300 --> 00:10:30,180
in that order used exactly in the way

189
00:10:22,240 --> 00:10:30,180
that we would like them to POSIX spawn

190
00:10:30,510 --> 00:10:35,860
this is a slightly more modern interface

191
00:10:33,490 --> 00:10:39,280
it's kind of like fork and XF in one

192
00:10:35,860 --> 00:10:42,370
system call but it has lots of options

193
00:10:39,280 --> 00:10:45,880
and you can actually use this with

194
00:10:42,370 --> 00:10:49,330
certain options to behave like only x'q

195
00:10:45,880 --> 00:10:51,070
and it has lots of other options which

196
00:10:49,330 --> 00:10:52,570
might be interesting if you do low-level

197
00:10:51,070 --> 00:10:58,120
programming like starting a process

198
00:10:52,570 --> 00:11:02,080
suspended and then finally and luckily

199
00:10:58,120 --> 00:11:03,700
for us there's mark create tasks that

200
00:11:02,080 --> 00:11:05,980
you can also call directly from user

201
00:11:03,700 --> 00:11:08,350
space but luckily it was disabled by

202
00:11:05,980 --> 00:11:10,809
Apple at some point in time

203
00:11:08,350 --> 00:11:12,519
because a lot of things assume that

204
00:11:10,809 --> 00:11:15,699
there is this one-to-one relationship

205
00:11:12,519 --> 00:11:18,790
between a process and the task in the

206
00:11:15,699 --> 00:11:22,269
kernel so under normal circumstances we

207
00:11:18,790 --> 00:11:25,889
can safely assume that it's sufficient

208
00:11:22,269 --> 00:11:28,389
to just monitor processes and not tasks

209
00:11:25,889 --> 00:11:35,860
even though in theory in the kernel they

210
00:11:28,389 --> 00:11:38,619
could exist independently so what do I

211
00:11:35,860 --> 00:11:41,980
want to monitor at process creation what

212
00:11:38,619 --> 00:11:44,019
information do I want for create

213
00:11:41,980 --> 00:11:47,499
processes but I'm really interested in

214
00:11:44,019 --> 00:11:49,269
the image that's loaded executable I'm

215
00:11:47,499 --> 00:11:51,790
interested in the path I'm interested in

216
00:11:49,269 --> 00:11:53,769
the arguments that are used to start it

217
00:11:51,790 --> 00:11:57,309
I'm interested in hashes of the

218
00:11:53,769 --> 00:12:00,549
executable image on disk I'm interested

219
00:11:57,309 --> 00:12:04,329
in the code signature and I'm interested

220
00:12:00,549 --> 00:12:07,720
in which executable image started which

221
00:12:04,329 --> 00:12:11,049
other executable image so not exactly

222
00:12:07,720 --> 00:12:14,319
the process hierarchy but which code

223
00:12:11,049 --> 00:12:17,139
loaded which other codes kinda so this

224
00:12:14,319 --> 00:12:20,829
is something that you could see on a

225
00:12:17,139 --> 00:12:22,509
system but let's say to normal at the

226
00:12:20,829 --> 00:12:24,638
lower part is not exactly normal

227
00:12:22,509 --> 00:12:31,119
behavior the PowerPoint spawns the shell

228
00:12:24,639 --> 00:12:34,589
let us double you get but I want to be

229
00:12:31,119 --> 00:12:42,489
able to see such relationships between

230
00:12:34,589 --> 00:12:43,899
process create operations and just a

231
00:12:42,489 --> 00:12:48,519
little detail on the side there's this

232
00:12:43,899 --> 00:12:51,639
nifty way to run a script by using the

233
00:12:48,519 --> 00:12:53,709
shebang you can put hash exclamation

234
00:12:51,639 --> 00:12:56,169
mark and then interpreter at the top of

235
00:12:53,709 --> 00:12:59,018
a script if you do that you can actually

236
00:12:56,169 --> 00:13:03,459
run the script directly as if it were an

237
00:12:59,019 --> 00:13:05,679
executable that's very normal on a UNIX

238
00:13:03,459 --> 00:13:07,779
system but it's actually the kernel

239
00:13:05,679 --> 00:13:10,689
implementing this feature it's not done

240
00:13:07,779 --> 00:13:12,600
new zealand so the x-axis call is

241
00:13:10,689 --> 00:13:15,730
actually different in the first case

242
00:13:12,600 --> 00:13:17,980
when you run the interpreter explicitly

243
00:13:15,730 --> 00:13:20,439
and then give it the script as an

244
00:13:17,980 --> 00:13:21,250
argument you have an exec on the

245
00:13:20,439 --> 00:13:23,290
interpreter

246
00:13:21,250 --> 00:13:25,930
and in the second case the X Act that

247
00:13:23,290 --> 00:13:28,599
goes into the kernel actually directly

248
00:13:25,930 --> 00:13:30,339
references the script file and then

249
00:13:28,600 --> 00:13:33,399
behind the scenes that kernel are some

250
00:13:30,339 --> 00:13:35,560
dirty tricks and the end result is the

251
00:13:33,399 --> 00:13:40,029
same thing it's the interpreter bin

252
00:13:35,560 --> 00:13:41,339
shell given the script name as an

253
00:13:40,029 --> 00:13:44,920
argument

254
00:13:41,339 --> 00:13:46,389
so from an instant response perspective

255
00:13:44,920 --> 00:13:48,759
I would like to know about the

256
00:13:46,389 --> 00:13:50,620
interpreter and the script and not just

257
00:13:48,759 --> 00:13:58,720
the information that happens to be

258
00:13:50,620 --> 00:14:02,649
passed to exit so I went and looked at

259
00:13:58,720 --> 00:14:04,600
some existing solutions that I would

260
00:14:02,649 --> 00:14:06,129
quickly kind of share with you also

261
00:14:04,600 --> 00:14:09,730
because there are interesting projects

262
00:14:06,129 --> 00:14:13,870
there's Google Santa which is an awesome

263
00:14:09,730 --> 00:14:17,920
project if you can and want to do actual

264
00:14:13,870 --> 00:14:20,230
binary whitelisting on your fleet it has

265
00:14:17,920 --> 00:14:23,979
a kernel module that basically stops

266
00:14:20,230 --> 00:14:25,480
processes from executing until the

267
00:14:23,980 --> 00:14:27,100
daemon that goes with it takes a

268
00:14:25,480 --> 00:14:30,550
decision whether it's okay to launch

269
00:14:27,100 --> 00:14:33,309
that program or not there's a GUI part

270
00:14:30,550 --> 00:14:37,329
and there's the ability to sync policy

271
00:14:33,309 --> 00:14:39,910
with a policy server one very

272
00:14:37,329 --> 00:14:43,420
interesting policy server is based on

273
00:14:39,910 --> 00:14:46,180
social voting so you basically you

274
00:14:43,420 --> 00:14:48,878
crowdsource your decisions whether

275
00:14:46,180 --> 00:14:50,888
binary is okay or if it's malware you

276
00:14:48,879 --> 00:14:53,920
can crowdsource your malware analysis

277
00:14:50,889 --> 00:14:57,670
into the to your employees running your

278
00:14:53,920 --> 00:15:00,509
Mac systems I'm not sure that might work

279
00:14:57,670 --> 00:15:04,599
at Google but for many organizations

280
00:15:00,509 --> 00:15:05,829
perhaps this is not I'm not so sure

281
00:15:04,600 --> 00:15:11,769
about this but it's an interesting

282
00:15:05,829 --> 00:15:14,378
concept but you can also do monitoring

283
00:15:11,769 --> 00:15:16,509
because before you want to block things

284
00:15:14,379 --> 00:15:18,129
on a fleet of Mac systems you need to

285
00:15:16,509 --> 00:15:21,970
know what's actually running on them

286
00:15:18,129 --> 00:15:23,579
already so it does a lot of it can

287
00:15:21,970 --> 00:15:26,439
acquire a lot of interesting data

288
00:15:23,579 --> 00:15:31,329
especially the hashes of the images and

289
00:15:26,439 --> 00:15:33,069
the code signing information however is

290
00:15:31,329 --> 00:15:35,069
not so good at other contexts

291
00:15:33,069 --> 00:15:36,479
information

292
00:15:35,070 --> 00:15:44,240
and one thing I would like to highlight

293
00:15:36,480 --> 00:15:47,310
is the pan PID @xf so consider this code

294
00:15:44,240 --> 00:15:51,810
it's a very simple fork and then exact

295
00:15:47,310 --> 00:15:54,780
combination first we print the PID of

296
00:15:51,810 --> 00:15:57,689
the process calling for and then in the

297
00:15:54,780 --> 00:16:02,449
child process we sleep and then print

298
00:15:57,690 --> 00:16:05,520
the PID the parent PID of the child so

299
00:16:02,450 --> 00:16:07,980
you would expect that the parent PID of

300
00:16:05,520 --> 00:16:12,810
the child at the exact time is the

301
00:16:07,980 --> 00:16:17,100
process that called fork right but it's

302
00:16:12,810 --> 00:16:21,750
actually not this is because while we

303
00:16:17,100 --> 00:16:25,350
sleep and if Clause there while we sleep

304
00:16:21,750 --> 00:16:27,480
the pan process exits and when the

305
00:16:25,350 --> 00:16:30,180
parent process exits the child is left

306
00:16:27,480 --> 00:16:31,860
without the parent and is kind of sent

307
00:16:30,180 --> 00:16:35,910
to the orphanage so it's it gets

308
00:16:31,860 --> 00:16:39,990
repented to process ID 1 to launch the

309
00:16:35,910 --> 00:16:43,610
on a mac so when we just look at the

310
00:16:39,990 --> 00:16:47,270
parent PID at the time when we call exec

311
00:16:43,610 --> 00:16:51,200
we lose some information regarding

312
00:16:47,270 --> 00:16:51,199
relationships between processes

313
00:16:51,560 --> 00:17:02,449
so anyway can Santa solve my problem not

314
00:16:58,770 --> 00:17:04,579
really I wasn't satisfied with it

315
00:17:02,450 --> 00:17:07,230
there's a lot of missing information

316
00:17:04,579 --> 00:17:12,240
it's also provide listing but not really

317
00:17:07,230 --> 00:17:14,550
the perfect solution for monitoring then

318
00:17:12,240 --> 00:17:19,140
a second tool I looked at Facebook

319
00:17:14,550 --> 00:17:22,430
always query so this as well is an

320
00:17:19,140 --> 00:17:25,439
excellent project it's a cross-platform

321
00:17:22,430 --> 00:17:27,630
solution to kind of treat your systems

322
00:17:25,439 --> 00:17:30,360
as a database so you can query pretty

323
00:17:27,630 --> 00:17:32,790
much anything on a system as if it were

324
00:17:30,360 --> 00:17:35,189
a sequel database and that includes

325
00:17:32,790 --> 00:17:41,139
processes and a lot of persistence

326
00:17:35,190 --> 00:17:44,830
mechanisms actually this is an example

327
00:17:41,140 --> 00:17:47,230
so this queer is the table that has all

328
00:17:44,830 --> 00:17:50,379
the currently running processes combines

329
00:17:47,230 --> 00:17:54,040
it with a special table that calculates

330
00:17:50,380 --> 00:17:57,179
hashes from files on disk and this way

331
00:17:54,040 --> 00:18:00,280
we can see the hash of the executables

332
00:17:57,179 --> 00:18:03,280
that the process is currently running

333
00:18:00,280 --> 00:18:06,280
are pointing to we can do the same thing

334
00:18:03,280 --> 00:18:10,090
for code signatures so this is very

335
00:18:06,280 --> 00:18:14,230
interesting however there is a small

336
00:18:10,090 --> 00:18:18,010
problem here we need to consider short

337
00:18:14,230 --> 00:18:19,660
living executable images so on Windows I

338
00:18:18,010 --> 00:18:21,790
don't know if you know that but on

339
00:18:19,660 --> 00:18:24,100
Windows you can't actually under normal

340
00:18:21,790 --> 00:18:27,010
circumstances delete your own executable

341
00:18:24,100 --> 00:18:29,980
image as a process if you do that you

342
00:18:27,010 --> 00:18:32,520
get access denied the file on disk is

343
00:18:29,980 --> 00:18:35,169
locked by windows while it's executing

344
00:18:32,520 --> 00:18:38,020
that's why you have these funny batch

345
00:18:35,169 --> 00:18:41,860
files that you see in malware sometimes

346
00:18:38,020 --> 00:18:47,410
that they use to delete themselves as a

347
00:18:41,860 --> 00:18:49,330
workaround so you can assume that while

348
00:18:47,410 --> 00:18:51,820
it's running you still have to date on

349
00:18:49,330 --> 00:18:56,439
disk whereas on a UNIX you can actually

350
00:18:51,820 --> 00:18:58,360
unlink the executable file from disk as

351
00:18:56,440 --> 00:19:01,299
the first thing you do as an executable

352
00:18:58,360 --> 00:19:04,360
and if you do that you have a process

353
00:19:01,299 --> 00:19:06,668
that has no well that still has the data

354
00:19:04,360 --> 00:19:08,530
on disk that was used to start this

355
00:19:06,669 --> 00:19:10,450
process but you can't access it because

356
00:19:08,530 --> 00:19:14,139
it's not linked in the file system

357
00:19:10,450 --> 00:19:16,330
anymore and you can even write to your

358
00:19:14,140 --> 00:19:19,830
own executable image while you're

359
00:19:16,330 --> 00:19:27,909
running this will not crash your process

360
00:19:19,830 --> 00:19:30,340
at least not immediately so I would when

361
00:19:27,910 --> 00:19:34,299
acquiring I why am I telling you this

362
00:19:30,340 --> 00:19:36,309
when acquiring an image hash or a code

363
00:19:34,299 --> 00:19:38,500
signature information I want to do that

364
00:19:36,309 --> 00:19:40,780
at the exact time of the X I cannot some

365
00:19:38,500 --> 00:19:47,790
point later in time because it could

366
00:19:40,780 --> 00:19:50,410
have changed so back to what was query

367
00:19:47,790 --> 00:19:52,480
it was a bit more difficult to dismiss

368
00:19:50,410 --> 00:19:55,710
the idea of using OS query as a

369
00:19:52,480 --> 00:19:58,980
replacement for this mom

370
00:19:55,710 --> 00:20:01,140
but image hash and code signature

371
00:19:58,980 --> 00:20:04,850
acquisition is unreliable can produce

372
00:20:01,140 --> 00:20:08,450
your own wrong results because of this

373
00:20:04,850 --> 00:20:12,929
timing issue and then there's not really

374
00:20:08,450 --> 00:20:16,860
good image ancestry it's all just parent

375
00:20:12,930 --> 00:20:21,270
PID which is not which is far from from

376
00:20:16,860 --> 00:20:22,679
what I'm interested in and then there's

377
00:20:21,270 --> 00:20:24,450
number of implementation issues

378
00:20:22,680 --> 00:20:28,650
especially with the process out in code

379
00:20:24,450 --> 00:20:31,230
but that's not that would be fixable

380
00:20:28,650 --> 00:20:38,310
so in summary it's a very cool tool but

381
00:20:31,230 --> 00:20:39,990
it doesn't exactly solve my problem so

382
00:20:38,310 --> 00:20:43,200
check the third tool something that's

383
00:20:39,990 --> 00:20:45,650
actually pre-installed on every Mac if

384
00:20:43,200 --> 00:20:48,930
you've done Solaris in your past maybe

385
00:20:45,650 --> 00:20:52,110
you might know the DSM it's available

386
00:20:48,930 --> 00:20:54,870
with the audit framework that's also

387
00:20:52,110 --> 00:20:57,510
available in other platforms Apple

388
00:20:54,870 --> 00:21:01,379
implemented this to achieve Common

389
00:20:57,510 --> 00:21:03,360
Criteria certification basically the

390
00:21:01,380 --> 00:21:05,970
kernel produces audit records for a lot

391
00:21:03,360 --> 00:21:09,080
of low-level events including full

392
00:21:05,970 --> 00:21:13,470
system on assessment sorry full syscall

393
00:21:09,080 --> 00:21:15,810
auditing stores these audit events or

394
00:21:13,470 --> 00:21:18,690
audit records in the kernel where what

395
00:21:15,810 --> 00:21:22,350
teaming gets them and stores them to

396
00:21:18,690 --> 00:21:24,770
disk in a binary format by default this

397
00:21:22,350 --> 00:21:28,679
just locks authentication related

398
00:21:24,770 --> 00:21:33,450
information but it's actually running by

399
00:21:28,680 --> 00:21:36,570
default so when we enable auditing for X

400
00:21:33,450 --> 00:21:38,400
AK here we can see that there's a lot of

401
00:21:36,570 --> 00:21:41,040
interesting information here we have the

402
00:21:38,400 --> 00:21:43,530
arguments we have two paths to the

403
00:21:41,040 --> 00:21:45,710
executable image we have file attributes

404
00:21:43,530 --> 00:21:48,389
of the executable image

405
00:21:45,710 --> 00:21:51,030
unfortunately no hash no code signing

406
00:21:48,390 --> 00:21:53,540
information and we have the subject

407
00:21:51,030 --> 00:21:56,820
which is the process that actually

408
00:21:53,540 --> 00:21:59,790
executed this Cisco but it's very low

409
00:21:56,820 --> 00:22:01,620
level it's really Cisco level you need

410
00:21:59,790 --> 00:22:05,670
to understand the Cisco's to make sense

411
00:22:01,620 --> 00:22:07,800
of this but neat is also that it

412
00:22:05,670 --> 00:22:08,590
includes the IP address that is

413
00:22:07,800 --> 00:22:11,110
associated

414
00:22:08,590 --> 00:22:13,000
with the terminal that this process is

415
00:22:11,110 --> 00:22:15,908
attached to so you can actually see for

416
00:22:13,000 --> 00:22:20,200
remote logins the IP address where this

417
00:22:15,909 --> 00:22:24,700
is coming from so very interesting but

418
00:22:20,200 --> 00:22:26,049
it's kinda not drop-in solution for sis

419
00:22:24,700 --> 00:22:29,080
Mon it's too low level too much

420
00:22:26,049 --> 00:22:32,470
information that would be need for a lot

421
00:22:29,080 --> 00:22:34,629
of post-processing of such records too

422
00:22:32,470 --> 00:22:39,520
to create the context that I'm

423
00:22:34,630 --> 00:22:41,559
interested in and also there's the issue

424
00:22:39,520 --> 00:22:45,760
that it doesn't cover the Mach side of

425
00:22:41,559 --> 00:22:47,950
the kernel as well as the bsd side so

426
00:22:45,760 --> 00:22:51,850
this is not really a direct solution to

427
00:22:47,950 --> 00:22:54,520
the problem so i started thinking about

428
00:22:51,850 --> 00:22:58,209
how to write a tool to solve this

429
00:22:54,520 --> 00:23:00,610
problem and went through a number of AP

430
00:22:58,210 --> 00:23:07,750
is that could be leveraged to achieve

431
00:23:00,610 --> 00:23:11,100
that there sliprock this is apple's API

432
00:23:07,750 --> 00:23:14,020
to into the currently running processes

433
00:23:11,100 --> 00:23:17,010
it doesn't have events so you just see

434
00:23:14,020 --> 00:23:19,870
what's currently running on the system

435
00:23:17,010 --> 00:23:26,110
that can be helpful but it's not a

436
00:23:19,870 --> 00:23:29,250
solution on an applet level there's this

437
00:23:26,110 --> 00:23:35,799
thing called NS workspace did launch

438
00:23:29,250 --> 00:23:38,200
application notification this actually

439
00:23:35,799 --> 00:23:41,049
only covers the the top level in the

440
00:23:38,200 --> 00:23:44,140
schematic that I showed earlier so it

441
00:23:41,049 --> 00:23:46,210
does notify us we can use it to get

442
00:23:44,140 --> 00:23:48,100
notified on application launches but not

443
00:23:46,210 --> 00:23:49,510
for lower level processes that's just

444
00:23:48,100 --> 00:23:54,428
things that you actually click in the

445
00:23:49,510 --> 00:23:58,240
user interface so it's it could be a

446
00:23:54,429 --> 00:24:03,820
partial solution at best so search went

447
00:23:58,240 --> 00:24:06,730
on we have KQ that's an API that was

448
00:24:03,820 --> 00:24:10,210
primarily designed to replace select to

449
00:24:06,730 --> 00:24:13,539
be more scalable than select to scale

450
00:24:10,210 --> 00:24:15,940
network servers to thousands or ten

451
00:24:13,539 --> 00:24:19,270
thousands of open sockets at the time or

452
00:24:15,940 --> 00:24:21,340
open file descriptors or whatever but

453
00:24:19,270 --> 00:24:21,940
you can also use this facility to

454
00:24:21,340 --> 00:24:24,340
monitor

455
00:24:21,940 --> 00:24:27,759
processes and some other things like

456
00:24:24,340 --> 00:24:30,789
vinhos you can attach to a specific

457
00:24:27,759 --> 00:24:33,279
process say I want to be notified when

458
00:24:30,789 --> 00:24:38,500
this pide does a fork exact signal or

459
00:24:33,279 --> 00:24:41,200
exit the problem is there's like no

460
00:24:38,500 --> 00:24:44,049
context almost no context you don't get

461
00:24:41,200 --> 00:24:46,809
any information you just know that this

462
00:24:44,049 --> 00:24:50,970
happened but you don't have information

463
00:24:46,809 --> 00:24:55,389
on it so not so cool

464
00:24:50,970 --> 00:24:59,350
then there's what it pipe that's kind of

465
00:24:55,389 --> 00:25:01,600
the programmable API onto the same

466
00:24:59,350 --> 00:25:05,649
kernel facility that audit daemon uses

467
00:25:01,600 --> 00:25:08,289
to retrieve its audit records so I can

468
00:25:05,649 --> 00:25:10,918
open that device I can tell it which

469
00:25:08,289 --> 00:25:15,009
events I'm interested in from the kernel

470
00:25:10,919 --> 00:25:16,980
and then I get all these events and can

471
00:25:15,009 --> 00:25:20,230
do with them what I want as a process

472
00:25:16,980 --> 00:25:22,269
it's still subject to the global policy

473
00:25:20,230 --> 00:25:25,450
or some aspects of the global auditing

474
00:25:22,269 --> 00:25:27,340
policy that's a bit tricky but otherwise

475
00:25:25,450 --> 00:25:29,259
this is very powerful

476
00:25:27,340 --> 00:25:33,490
the only thing that's missing here is a

477
00:25:29,259 --> 00:25:35,230
reliable way to well you can't acquire

478
00:25:33,490 --> 00:25:41,289
image hashes or code signature

479
00:25:35,230 --> 00:25:44,440
information through this facility I also

480
00:25:41,289 --> 00:25:49,200
looked at DTrace that's also extremely

481
00:25:44,440 --> 00:25:52,419
powerful facility coming from Solaris

482
00:25:49,200 --> 00:25:54,039
you can trace this calls process events

483
00:25:52,419 --> 00:25:56,590
a lot of things in the kernel you can

484
00:25:54,039 --> 00:25:59,980
access kernel internal data structures

485
00:25:56,590 --> 00:26:02,019
with this tool beyond even what you can

486
00:25:59,980 --> 00:26:05,289
do in a kernel extension according to

487
00:26:02,019 --> 00:26:07,720
Apple so it's it's more powerful than

488
00:26:05,289 --> 00:26:10,509
what you're allowed to do as a kernel

489
00:26:07,720 --> 00:26:12,330
extension there's this little

490
00:26:10,509 --> 00:26:15,519
programming language that you can write

491
00:26:12,330 --> 00:26:19,960
traces in and this is an example of how

492
00:26:15,519 --> 00:26:22,240
to run it to get one line of information

493
00:26:19,960 --> 00:26:25,090
for every xx that happened in this case

494
00:26:22,240 --> 00:26:29,200
it just prints the PID so this would be

495
00:26:25,090 --> 00:26:30,850
perfect however Apple broke this when

496
00:26:29,200 --> 00:26:34,029
they introduced system integrity

497
00:26:30,850 --> 00:26:35,290
protection because it leaks too much

498
00:26:34,029 --> 00:26:39,190
information

499
00:26:35,290 --> 00:26:42,580
from the kernel for example to determine

500
00:26:39,190 --> 00:26:46,570
the the random address offset of the

501
00:26:42,580 --> 00:26:48,520
kernel so they removed some capabilities

502
00:26:46,570 --> 00:26:50,740
from this which basically means it's not

503
00:26:48,520 --> 00:26:54,100
as useful as we would like it to be for

504
00:26:50,740 --> 00:26:58,150
this use case in this case I tried to

505
00:26:54,100 --> 00:27:00,639
access the arguments that the kernel has

506
00:26:58,150 --> 00:27:02,700
at the time of exact so the arguments

507
00:27:00,640 --> 00:27:06,820
the process was start with and that

508
00:27:02,700 --> 00:27:09,100
fails you can use it but you need to

509
00:27:06,820 --> 00:27:10,870
disable at least at least parts of

510
00:27:09,100 --> 00:27:13,000
system integrity protection which is not

511
00:27:10,870 --> 00:27:16,840
really an option if you want to deploy

512
00:27:13,000 --> 00:27:18,430
something on a larger scale it's not

513
00:27:16,840 --> 00:27:20,500
really an option for my laptop either

514
00:27:18,430 --> 00:27:22,930
actually

515
00:27:20,500 --> 00:27:25,330
then there's kadiebug another very

516
00:27:22,930 --> 00:27:28,930
powerful facility that you can use from

517
00:27:25,330 --> 00:27:31,600
user space it's intended for debugging

518
00:27:28,930 --> 00:27:34,150
you can attach you can kind of monitor

519
00:27:31,600 --> 00:27:36,490
which functions get entered and left in

520
00:27:34,150 --> 00:27:38,920
the kernel it has access to a lot of

521
00:27:36,490 --> 00:27:44,620
very low-level kernel things including

522
00:27:38,920 --> 00:27:46,930
mark messaging a dynamic loader X PC you

523
00:27:44,620 --> 00:27:50,020
can exit with the trace utility if you

524
00:27:46,930 --> 00:27:52,450
want to play around with this it's used

525
00:27:50,020 --> 00:27:56,530
by a lot a lot of tools by Apple like

526
00:27:52,450 --> 00:27:59,710
instrumentation app it's very low-level

527
00:27:56,530 --> 00:28:02,160
as you can see for the fork it's kind of

528
00:27:59,710 --> 00:28:05,350
you can guess that these are the 2p IDs

529
00:28:02,160 --> 00:28:07,750
but for the exact I'm not so sure what

530
00:28:05,350 --> 00:28:12,820
the information here is what these

531
00:28:07,750 --> 00:28:15,340
addresses translate to and it's very

532
00:28:12,820 --> 00:28:18,909
undocumented but the main problem is

533
00:28:15,340 --> 00:28:21,580
that you there's only one process that

534
00:28:18,910 --> 00:28:24,030
can use this facility at a time so if we

535
00:28:21,580 --> 00:28:26,889
would use this for a monitoring agent

536
00:28:24,030 --> 00:28:34,000
the Apple utilities that use this would

537
00:28:26,890 --> 00:28:36,190
stop working not an option so I went and

538
00:28:34,000 --> 00:28:42,610
looked into ways to solve this problem

539
00:28:36,190 --> 00:28:45,450
in the kernel there's the the better way

540
00:28:42,610 --> 00:28:50,820
to do it is the kernel of authorization

541
00:28:45,450 --> 00:28:50,820
API or KPI kernel programming interface

542
00:28:50,860 --> 00:29:02,449
it does cover execute very well via the

543
00:28:55,520 --> 00:29:04,820
AV node so you can actually get a call

544
00:29:02,450 --> 00:29:08,480
back every time the colonel calls exact

545
00:29:04,820 --> 00:29:11,179
on the V node with all the information

546
00:29:08,480 --> 00:29:15,770
that we're interested in problem is you

547
00:29:11,180 --> 00:29:18,560
can't track fork with this but on the

548
00:29:15,770 --> 00:29:21,379
positive side we can use this to pause

549
00:29:18,560 --> 00:29:23,780
the process and then let it continue

550
00:29:21,380 --> 00:29:26,510
later this is the recommend of official

551
00:29:23,780 --> 00:29:31,240
way to write a non access a V scanner

552
00:29:26,510 --> 00:29:33,710
for the Mac then there's the Mac framer

553
00:29:31,240 --> 00:29:38,780
that's a bit less too many things called

554
00:29:33,710 --> 00:29:43,480
Mac Mac Mac mark and this is Mac meaning

555
00:29:38,780 --> 00:29:46,220
mandatory access control this is a

556
00:29:43,480 --> 00:29:48,530
concept where you stick Mac labels to

557
00:29:46,220 --> 00:29:50,450
different kernel objects and later to

558
00:29:48,530 --> 00:29:53,420
policy decisions based on these Mac

559
00:29:50,450 --> 00:29:57,350
labels this is actually how Apple

560
00:29:53,420 --> 00:30:00,170
implemented their sandboxing feature the

561
00:29:57,350 --> 00:30:01,810
this would be perfect for our purpose it

562
00:30:00,170 --> 00:30:05,030
covers X second Fork

563
00:30:01,810 --> 00:30:06,919
even before and after they happen the

564
00:30:05,030 --> 00:30:09,889
problem is it's not supported KPI

565
00:30:06,920 --> 00:30:13,670
meaning while you can use it in a kernel

566
00:30:09,890 --> 00:30:15,530
extension it's not a binary compatible

567
00:30:13,670 --> 00:30:19,910
or not correct guaranteed to be between

568
00:30:15,530 --> 00:30:21,920
different versions and Apple threatened

569
00:30:19,910 --> 00:30:24,710
to take this API away from kernel

570
00:30:21,920 --> 00:30:32,900
modules at some point so it's not really

571
00:30:24,710 --> 00:30:36,440
a long-term choice and of course we

572
00:30:32,900 --> 00:30:38,600
could just do the bad thing and just

573
00:30:36,440 --> 00:30:42,440
mess with kernel internal things

574
00:30:38,600 --> 00:30:45,080
directly it's doable would be doable for

575
00:30:42,440 --> 00:30:47,330
one version but it's not something that

576
00:30:45,080 --> 00:30:52,159
I would like to maintain or support

577
00:30:47,330 --> 00:30:56,240
across other people's systems so we're

578
00:30:52,160 --> 00:31:00,830
not really an option so I went and wrote

579
00:30:56,240 --> 00:31:04,040
my tool and

580
00:31:00,830 --> 00:31:08,270
this is the result or at least partial

581
00:31:04,040 --> 00:31:11,810
lock of an image exact event so kind of

582
00:31:08,270 --> 00:31:16,220
the equivalent of the process creation

583
00:31:11,810 --> 00:31:19,129
event of sis Mon it has art B it has the

584
00:31:16,220 --> 00:31:21,260
image with hashes code signature

585
00:31:19,130 --> 00:31:24,370
information in this case it's unsigned

586
00:31:21,260 --> 00:31:28,760
it has information on the process which

587
00:31:24,370 --> 00:31:31,840
cost this image to load including the

588
00:31:28,760 --> 00:31:35,510
full history the full ancestry of images

589
00:31:31,840 --> 00:31:41,929
again including hashes and codes and

590
00:31:35,510 --> 00:31:44,240
information this is actually the Mac

591
00:31:41,930 --> 00:31:48,380
version of retv to go with the Windows

592
00:31:44,240 --> 00:31:51,500
version we had before they use the same

593
00:31:48,380 --> 00:31:55,090
tactics on both operating systems they

594
00:31:51,500 --> 00:32:00,050
use oak adhere to redirect traffic to

595
00:31:55,090 --> 00:32:06,730
this onion domain this is the overview

596
00:32:00,050 --> 00:32:06,730
how I did it I mainly use dev audit pipe

597
00:32:06,850 --> 00:32:13,189
because that's the best use space API

598
00:32:09,620 --> 00:32:16,340
most reliable that we could find I could

599
00:32:13,190 --> 00:32:19,010
find and there's an optional kernel

600
00:32:16,340 --> 00:32:22,879
extension it works without the kernel

601
00:32:19,010 --> 00:32:24,410
extension in which case the acquisition

602
00:32:22,880 --> 00:32:27,530
of hashes and code signatures just

603
00:32:24,410 --> 00:32:30,200
happens at a later point in time so we

604
00:32:27,530 --> 00:32:32,660
could be too late but under normal

605
00:32:30,200 --> 00:32:36,200
circumstances you would still be able to

606
00:32:32,660 --> 00:32:38,030
acquire all the information but with the

607
00:32:36,200 --> 00:32:40,280
kernel extension the kernel extension

608
00:32:38,030 --> 00:32:43,310
blocks the process from executing until

609
00:32:40,280 --> 00:32:47,420
the user space utility had time to

610
00:32:43,310 --> 00:32:49,790
acquire all the information it has

611
00:32:47,420 --> 00:32:54,320
configuration kind of similar to this

612
00:32:49,790 --> 00:32:58,240
one but in Apple plist format and it's

613
00:32:54,320 --> 00:33:03,710
able to lock events to as Jason or llamó

614
00:32:58,240 --> 00:33:05,360
currently to file sources lock the

615
00:33:03,710 --> 00:33:07,460
kernel extension is also very useful to

616
00:33:05,360 --> 00:33:10,100
work around a number of box that I found

617
00:33:07,460 --> 00:33:13,310
in Apple's audits framework in the

618
00:33:10,100 --> 00:33:14,540
kernel it sometimes reports things

619
00:33:13,310 --> 00:33:19,010
wrongly

620
00:33:14,540 --> 00:33:22,428
some missing information having a kernel

621
00:33:19,010 --> 00:33:24,650
module helps working around that problem

622
00:33:22,429 --> 00:33:27,290
is it's unsigned so far because Apple is

623
00:33:24,650 --> 00:33:29,179
very restrictive in handing out

624
00:33:27,290 --> 00:33:32,330
certificates which allowed to sign

625
00:33:29,179 --> 00:33:33,860
kernel modules which is good for

626
00:33:32,330 --> 00:33:35,949
security but it's bad if you want to

627
00:33:33,860 --> 00:33:42,830
improve security with the kernel module

628
00:33:35,950 --> 00:33:46,610
I'm working on that the agent currently

629
00:33:42,830 --> 00:33:48,710
has these capabilities there's two event

630
00:33:46,610 --> 00:33:51,229
types which are not super interesting

631
00:33:48,710 --> 00:33:55,460
it's just for monitoring the status of

632
00:33:51,230 --> 00:33:59,420
the agent and some metrics to identify

633
00:33:55,460 --> 00:34:01,429
problems the three lower ones are the

634
00:33:59,420 --> 00:34:05,090
actual useful events that are currently

635
00:34:01,429 --> 00:34:08,210
implemented image execution process

636
00:34:05,090 --> 00:34:12,679
access and launch demon launch agent

637
00:34:08,210 --> 00:34:15,379
edit I will quickly go through them but

638
00:34:12,679 --> 00:34:19,429
we already talked about image execution

639
00:34:15,379 --> 00:34:22,069
so I will just skip this we have event

640
00:34:19,429 --> 00:34:25,250
code 3 that's that's very interesting

641
00:34:22,070 --> 00:34:29,510
one there's this call called

642
00:34:25,250 --> 00:34:33,739
tasks for Pete that you use to go from

643
00:34:29,510 --> 00:34:35,510
the process to the mark task and when

644
00:34:33,739 --> 00:34:38,270
you do this when you receive the send

645
00:34:35,510 --> 00:34:41,119
rights to mark tasks you can actually

646
00:34:38,270 --> 00:34:44,570
modify that tasks memory for example you

647
00:34:41,119 --> 00:34:47,050
can kind it happens also a new debug you

648
00:34:44,570 --> 00:34:49,159
open another process you mess with it

649
00:34:47,050 --> 00:34:52,340
basically it's how you implement

650
00:34:49,159 --> 00:34:56,510
debuggers process following injecting

651
00:34:52,340 --> 00:35:01,790
code all these things that we want to

652
00:34:56,510 --> 00:35:05,000
see on system so this actually this

653
00:35:01,790 --> 00:35:08,119
event actually looks this Cisco Oscar

654
00:35:05,000 --> 00:35:10,760
Pete and Pete trace Petrus is kind of

655
00:35:08,119 --> 00:35:16,690
similar it's very limited on the Mac so

656
00:35:10,760 --> 00:35:22,460
it's not so important but still that's

657
00:35:16,690 --> 00:35:24,920
yeah then we have event code for that

658
00:35:22,460 --> 00:35:27,650
was more kind of a proof of concept for

659
00:35:24,920 --> 00:35:31,480
file based events

660
00:35:27,650 --> 00:35:34,070
this triggers whenever some process ads

661
00:35:31,480 --> 00:35:39,290
launch team no launch agent to one of

662
00:35:34,070 --> 00:35:41,240
these locations it's it doesn't cover

663
00:35:39,290 --> 00:35:43,730
any other persistence methods but a lot

664
00:35:41,240 --> 00:35:51,890
of malware currently does use these so

665
00:35:43,730 --> 00:35:53,540
this is interesting to have so yeah next

666
00:35:51,890 --> 00:35:55,819
steps I would like to further improve

667
00:35:53,540 --> 00:36:00,710
configurability it already has a lot of

668
00:35:55,820 --> 00:36:05,210
or some ways to to whitelist certain

669
00:36:00,710 --> 00:36:07,010
processes to suppress certain locks but

670
00:36:05,210 --> 00:36:09,260
I feel it should be a bit more

671
00:36:07,010 --> 00:36:11,300
configurable even which types of events

672
00:36:09,260 --> 00:36:15,050
you want or you don't want in your

673
00:36:11,300 --> 00:36:18,410
environment and I have been running it

674
00:36:15,050 --> 00:36:20,630
on this laptop for a few months now and

675
00:36:18,410 --> 00:36:23,660
on some other systems for testing I

676
00:36:20,630 --> 00:36:25,850
would like to do large-scale deployment

677
00:36:23,660 --> 00:36:32,210
soon hopefully with the signed kernel

678
00:36:25,850 --> 00:36:35,150
extension and of course it there's lots

679
00:36:32,210 --> 00:36:38,570
of potential to extend it with more

680
00:36:35,150 --> 00:36:42,260
types of events like monitoring the

681
00:36:38,570 --> 00:36:46,370
opening of network sockets something I'd

682
00:36:42,260 --> 00:36:49,610
be interested in is image loads in in a

683
00:36:46,370 --> 00:36:51,980
sense of libraries so to get an event

684
00:36:49,610 --> 00:36:56,300
whenever the kernel load or the dynamic

685
00:36:51,980 --> 00:37:00,970
loader actually sorry loads the library

686
00:36:56,300 --> 00:37:04,300
as part of loading and executable and

687
00:37:00,970 --> 00:37:07,370
some other more specific things like

688
00:37:04,300 --> 00:37:12,010
environment variable based dial-up

689
00:37:07,370 --> 00:37:17,020
injection different log formats impasse

690
00:37:12,010 --> 00:37:19,550
whatever makes different people happy so

691
00:37:17,020 --> 00:37:21,770
this is it I released this today I

692
00:37:19,550 --> 00:37:24,010
uploaded it already to get up you can

693
00:37:21,770 --> 00:37:34,630
play around with it if you're interested

694
00:37:24,010 --> 00:37:34,630
find box hopefully not too many yeah

695
00:37:37,290 --> 00:37:47,400
I would like to open the floor for

696
00:37:38,430 --> 00:37:50,279
questions great thank you very much

697
00:37:47,400 --> 00:37:52,110
Daniel very awesome interesting talk we

698
00:37:50,280 --> 00:37:54,360
have still around five seven minutes for

699
00:37:52,110 --> 00:37:56,010
a Q&A right now so does anyone have any

700
00:37:54,360 --> 00:37:58,040
questions please raise your hand and

701
00:37:56,010 --> 00:38:02,570
I'll come bring the mic to you quickly

702
00:37:58,040 --> 00:38:05,370
awesome crowd participation come on

703
00:38:02,570 --> 00:38:06,990
thank you very much it was a it's an

704
00:38:05,370 --> 00:38:09,420
amazing tool I was waiting for something

705
00:38:06,990 --> 00:38:11,250
like that for ages I had the same pain

706
00:38:09,420 --> 00:38:14,550
points that you went through I

707
00:38:11,250 --> 00:38:16,950
understand your pain do you actually

708
00:38:14,550 --> 00:38:20,580
implement the upstream collection of

709
00:38:16,950 --> 00:38:23,370
logs to say Splunk or any other s I am

710
00:38:20,580 --> 00:38:24,870
solutions is he part of the do you have

711
00:38:23,370 --> 00:38:25,620
an agent that push these logs somewhere

712
00:38:24,870 --> 00:38:32,850
yeah

713
00:38:25,620 --> 00:38:34,710
no the idea is - well I'm more of a

714
00:38:32,850 --> 00:38:37,380
follower of the UNIX philosophy to one

715
00:38:34,710 --> 00:38:39,360
thing and do it right and leave the log

716
00:38:37,380 --> 00:38:42,020
shipping log collection two different

717
00:38:39,360 --> 00:38:44,310
tools which are better at that job so

718
00:38:42,020 --> 00:38:48,180
the tool can lock two different

719
00:38:44,310 --> 00:38:52,560
facilities currently - syslog - files or

720
00:38:48,180 --> 00:38:55,529
- standard output so that should cover a

721
00:38:52,560 --> 00:38:58,259
lot of use cases but it's quite easy to

722
00:38:55,530 --> 00:39:02,790
add a new transport into the code if you

723
00:38:58,260 --> 00:39:05,240
have some kind of agent that wants to

724
00:39:02,790 --> 00:39:09,990
pick up blocks in a different way yeah

725
00:39:05,240 --> 00:39:13,609
but I I use on this system locally

726
00:39:09,990 --> 00:39:16,350
Splunk just from borlaug from files

727
00:39:13,610 --> 00:39:19,260
there's also a sample configuration on

728
00:39:16,350 --> 00:39:23,940
how to pull the log format into Splunk

729
00:39:19,260 --> 00:39:26,640
in the github repository school anyone

730
00:39:23,940 --> 00:39:30,710
else any other questions don't be shy

731
00:39:26,640 --> 00:39:30,710
thank you I'm making me work today

732
00:39:36,809 --> 00:39:40,900
yeah does it have any measurable

733
00:39:39,670 --> 00:39:43,180
performance impact

734
00:39:40,900 --> 00:39:45,849
I mean pausing the process before you

735
00:39:43,180 --> 00:39:52,419
hashed it this would add some latency or

736
00:39:45,849 --> 00:39:53,619
something obviously it does I have some

737
00:39:52,420 --> 00:40:01,270
measurements if you're interested

738
00:39:53,619 --> 00:40:04,720
somewhere yeah so it does but there's a

739
00:40:01,270 --> 00:40:07,150
lot of caching built in so it only needs

740
00:40:04,720 --> 00:40:09,970
to acquire the hash and the signature

741
00:40:07,150 --> 00:40:15,010
information once as long as the file on

742
00:40:09,970 --> 00:40:18,700
disk doesn't change and because you only

743
00:40:15,010 --> 00:40:21,549
run well on this system and I do a lot

744
00:40:18,700 --> 00:40:23,618
of kind of shell activity on this system

745
00:40:21,549 --> 00:40:27,369
there's only like three hundred four

746
00:40:23,619 --> 00:40:31,030
hundred binaries in total that I run

747
00:40:27,369 --> 00:40:34,329
normally so it's not that many you can

748
00:40:31,030 --> 00:40:37,480
easily easily cache that but here are

749
00:40:34,329 --> 00:40:39,240
the timings at the bottom you see the

750
00:40:37,480 --> 00:40:41,740
timings for the cache lookups

751
00:40:39,240 --> 00:40:45,459
in comparison with the actual

752
00:40:41,740 --> 00:40:49,089
acquisition of well either just md5 or

753
00:40:45,460 --> 00:41:00,930
sha-1 or combinations of those four

754
00:40:49,089 --> 00:41:03,640
different sizes of executables the and

755
00:41:00,930 --> 00:41:07,270
obviously it it the time grows the

756
00:41:03,640 --> 00:41:09,848
larger the executable gets the biggest

757
00:41:07,270 --> 00:41:13,109
problem or the biggest impact are large

758
00:41:09,849 --> 00:41:21,390
applications like Microsoft Office

759
00:41:13,109 --> 00:41:28,210
applications that are huge binaries but

760
00:41:21,390 --> 00:41:31,960
yeah there is an impact but I can't

761
00:41:28,210 --> 00:41:37,619
quantify it precisely but personally I

762
00:41:31,960 --> 00:41:39,579
didn't see any impact for my own use

763
00:41:37,619 --> 00:41:43,480
cool you know if that answers the

764
00:41:39,579 --> 00:41:46,750
question but cool any more questions we

765
00:41:43,480 --> 00:41:47,569
still have a little bit more time anyone

766
00:41:46,750 --> 00:41:53,469
else

767
00:41:47,569 --> 00:41:53,469
oh nice

768
00:41:55,180 --> 00:42:00,499
do you have already a roadmap regarding

769
00:41:58,309 --> 00:42:04,699
extension of these tool regarding

770
00:42:00,499 --> 00:42:08,899
network connections roadmap as in at

771
00:42:04,699 --> 00:42:10,039
what day it will be available no it's

772
00:42:08,900 --> 00:42:12,559
ready when it's ready

773
00:42:10,039 --> 00:42:14,779
or someone implements it it's an open

774
00:42:12,559 --> 00:42:16,339
source project it's not something it's

775
00:42:14,779 --> 00:42:21,349
something I do remains in my spare time

776
00:42:16,339 --> 00:42:25,729
so but there's maybe ways to motivate me

777
00:42:21,349 --> 00:42:32,539
to prioritize that if you're interested

778
00:42:25,729 --> 00:42:37,160
in that anyone else any more

779
00:42:32,539 --> 00:42:38,450
No okay thank you very much Daniel yeah

780
00:42:37,160 --> 00:42:43,330
round of applause once more

781
00:42:38,450 --> 00:42:45,390
[Applause]

782
00:42:43,330 --> 00:42:45,390
you

