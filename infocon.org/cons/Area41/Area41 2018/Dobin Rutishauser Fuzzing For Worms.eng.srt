1
00:00:02,449 --> 00:00:07,350
thank you very much for attending here

2
00:00:04,740 --> 00:00:11,670
my talk is about fussing for firms or

3
00:00:07,350 --> 00:00:18,020
about in other words about FL for Linux

4
00:00:11,670 --> 00:00:32,070
network servers so is this working

5
00:00:18,020 --> 00:00:41,849
yes no Murphy's Law so so I'm told

6
00:00:32,070 --> 00:00:50,100
notice how so do you think sorry I will

7
00:00:41,850 --> 00:00:52,680
fix this quickly okay

8
00:00:50,100 --> 00:00:53,610
my name is Toby notice how sir I work at

9
00:00:52,680 --> 00:00:58,019
campus security

10
00:00:53,610 --> 00:01:01,829
I gave several talks previously but on a

11
00:00:58,020 --> 00:01:04,680
smaller size of audience I'm also a

12
00:01:01,829 --> 00:01:07,380
lecturer at the benefit for Schuler some

13
00:01:04,680 --> 00:01:11,760
students are here very good they

14
00:01:07,380 --> 00:01:14,548
followed my call so I will talk I will

15
00:01:11,760 --> 00:01:17,070
be talking about forcing first what we

16
00:01:14,549 --> 00:01:20,220
currently have which is basically mostly

17
00:01:17,070 --> 00:01:23,008
file based for sirs then a bit what I

18
00:01:20,220 --> 00:01:27,298
wanted and this is a network foster I

19
00:01:23,009 --> 00:01:28,770
will try to my make live demo I will

20
00:01:27,299 --> 00:01:31,560
talk a little bit about feedback

21
00:01:28,770 --> 00:01:35,820
reinforcing and discuss the results

22
00:01:31,560 --> 00:01:40,829
afterwards so who knows about AFL

23
00:01:35,820 --> 00:01:45,000
American fossil op that's about 1/3 very

24
00:01:40,829 --> 00:01:48,559
good so on the left you see here that's

25
00:01:45,000 --> 00:01:54,509
how you set up American fossil op FL

26
00:01:48,560 --> 00:01:59,969
it's a file faster here we are facing in

27
00:01:54,509 --> 00:02:01,649
utils or to be precise we delve so all

28
00:01:59,969 --> 00:02:04,699
you have to do is have the source code

29
00:02:01,649 --> 00:02:08,509
of the application you want to fast and

30
00:02:04,700 --> 00:02:11,849
compile it with the AFL compiler then

31
00:02:08,508 --> 00:02:13,359
give an example file this is here in the

32
00:02:11,849 --> 00:02:16,890
example direct in the

33
00:02:13,360 --> 00:02:20,800
a FL in directory and then start fussing

34
00:02:16,890 --> 00:02:24,130
so FL is probably the most known faster

35
00:02:20,800 --> 00:02:27,070
and most widely used in the previous few

36
00:02:24,130 --> 00:02:30,549
years and I think this is mostly because

37
00:02:27,070 --> 00:02:33,400
it is very easy to use so every cook one

38
00:02:30,550 --> 00:02:35,290
can start very quickly and it's giving

39
00:02:33,400 --> 00:02:36,070
useful feedback if you did something

40
00:02:35,290 --> 00:02:38,549
wrong

41
00:02:36,070 --> 00:02:43,299
if you have some wrong settings or

42
00:02:38,550 --> 00:02:46,990
configured it not correctly it's also

43
00:02:43,300 --> 00:02:50,500
very fast it's usually about like two

44
00:02:46,990 --> 00:02:53,620
thousand iterations per second and it

45
00:02:50,500 --> 00:03:00,010
also has code coverage feedback which I

46
00:02:53,620 --> 00:03:03,070
will be talking about later so a FL is

47
00:03:00,010 --> 00:03:06,370
out in several years right now and

48
00:03:03,070 --> 00:03:10,299
everything is basically already fast we

49
00:03:06,370 --> 00:03:14,620
have all the JPEG file parsing libraries

50
00:03:10,300 --> 00:03:16,870
we have sekolah it we have even some

51
00:03:14,620 --> 00:03:19,739
network servers we have TCP dump and

52
00:03:16,870 --> 00:03:23,140
Bioshock and you have like 1000

53
00:03:19,739 --> 00:03:29,380
different auto tools where AFL found

54
00:03:23,140 --> 00:03:30,970
vulnerabilities so I thought that paper

55
00:03:29,380 --> 00:03:34,810
everything is already fast

56
00:03:30,970 --> 00:03:39,010
isn't there something which which is may

57
00:03:34,810 --> 00:03:42,630
be possible to which is not fast already

58
00:03:39,010 --> 00:03:45,548
so much so then I lied my eyes on

59
00:03:42,630 --> 00:03:48,160
forcing network servers you seem to be a

60
00:03:45,549 --> 00:03:52,269
nice little niche where it's not so much

61
00:03:48,160 --> 00:03:54,730
development already so then I mean

62
00:03:52,269 --> 00:03:57,880
forcing network servers and I mean

63
00:03:54,730 --> 00:04:00,640
forcing the data layer so I'm not

64
00:03:57,880 --> 00:04:04,920
forcing TCP or IP or Ethernet or

65
00:04:00,640 --> 00:04:04,920
whatever but really application data

66
00:04:05,280 --> 00:04:12,190
one example is

67
00:04:08,549 --> 00:04:15,120
mqtt protocol I intentionally took this

68
00:04:12,190 --> 00:04:19,959
example why you will see you later

69
00:04:15,120 --> 00:04:22,740
MQTT is often used in IOT frameworks and

70
00:04:19,959 --> 00:04:25,400
IOT devices it's basically just the

71
00:04:22,740 --> 00:04:28,120
publish/subscribe protocol so

72
00:04:25,400 --> 00:04:31,270
you can like subscribe to a temperature

73
00:04:28,120 --> 00:04:36,850
channel and the device is pushed

74
00:04:31,270 --> 00:04:40,609
temperature and then you receive it this

75
00:04:36,850 --> 00:04:43,340
MQTT protocol has like free basic

76
00:04:40,610 --> 00:04:46,820
messages one is connect this is the

77
00:04:43,340 --> 00:04:49,520
first packet sent to the server more or

78
00:04:46,820 --> 00:04:52,370
less with the name of the client then

79
00:04:49,520 --> 00:04:54,889
you can subscribe to a channel and you

80
00:04:52,370 --> 00:05:03,050
can publish a message to a channel which

81
00:04:54,889 --> 00:05:06,260
is pretty simple and easy so basically

82
00:05:03,050 --> 00:05:08,389
the MQTT server has a state machine and

83
00:05:06,260 --> 00:05:11,030
it's looking for packets and if it

84
00:05:08,389 --> 00:05:13,630
receives the connect packet he knows are

85
00:05:11,030 --> 00:05:15,919
now in the state connected he's

86
00:05:13,630 --> 00:05:18,830
receiving another packet may be

87
00:05:15,919 --> 00:05:25,870
subscribed and he's handling this and we

88
00:05:18,830 --> 00:05:29,320
want to fast this MQTT server what

89
00:05:25,870 --> 00:05:34,070
possibilities do we have to perform this

90
00:05:29,320 --> 00:05:37,130
forcing I invented two words for this

91
00:05:34,070 --> 00:05:40,580
or two methods the first method I call

92
00:05:37,130 --> 00:05:43,520
rap and the second method I call we wire

93
00:05:40,580 --> 00:05:48,169
and I will talk very quickly about these

94
00:05:43,520 --> 00:05:51,289
two methods so the first method the

95
00:05:48,169 --> 00:05:54,650
wrapping is basically choose to isolate

96
00:05:51,289 --> 00:05:57,680
the functionality which is performing

97
00:05:54,650 --> 00:06:02,120
the parsing of the MQTT packet in this

98
00:05:57,680 --> 00:06:05,330
case but usually this comes from file

99
00:06:02,120 --> 00:06:10,909
parsing maybe we have a function invert

100
00:06:05,330 --> 00:06:13,760
or whatever called scan docx file for

101
00:06:10,909 --> 00:06:17,630
viruses and then this function we are

102
00:06:13,760 --> 00:06:20,229
able to fast and only this part and

103
00:06:17,630 --> 00:06:23,840
ignore all the rest of the application

104
00:06:20,229 --> 00:06:27,169
this is how it how it is done in lib

105
00:06:23,840 --> 00:06:30,229
foster and then rfl and also in a FL

106
00:06:27,169 --> 00:06:36,279
persistent mode this is usually very

107
00:06:30,229 --> 00:06:38,739
very fast the second or two

108
00:06:36,279 --> 00:06:42,308
discuss abate the problems as you can

109
00:06:38,739 --> 00:06:45,429
see I wrote here pass mqtt packet of

110
00:06:42,309 --> 00:06:47,649
course this doesn't exist in the actual

111
00:06:45,429 --> 00:06:49,989
mangu server it's very very more

112
00:06:47,649 --> 00:06:52,299
complicated and it's not isolated

113
00:06:49,989 --> 00:06:56,049
function like this but it also generates

114
00:06:52,299 --> 00:06:58,089
answers tries to set up networking so

115
00:06:56,049 --> 00:07:04,149
this was not really applicable and I

116
00:06:58,089 --> 00:07:06,099
wanted to force Mongoose MQTT server so

117
00:07:04,149 --> 00:07:10,089
the second method are called rewiring

118
00:07:06,099 --> 00:07:14,860
and this comes from the fact that in

119
00:07:10,089 --> 00:07:17,799
UNIX network socket is basically choose

120
00:07:14,860 --> 00:07:20,979
the socket here it has the number 4 so

121
00:07:17,799 --> 00:07:23,589
it's just an integer and the program

122
00:07:20,979 --> 00:07:27,149
reads and writes to the socket and the

123
00:07:23,589 --> 00:07:31,539
packets go out and arrive at the client

124
00:07:27,149 --> 00:07:33,579
socket so it's easy to see that you can

125
00:07:31,539 --> 00:07:38,199
just replace these networks occurred

126
00:07:33,579 --> 00:07:42,069
with a file socket because then we are

127
00:07:38,199 --> 00:07:44,649
able to use AFL again just write all the

128
00:07:42,069 --> 00:07:47,079
network packets into a file and tell the

129
00:07:44,649 --> 00:07:50,519
MQTT server hey no you are not reading

130
00:07:47,079 --> 00:07:53,889
now from the network but from this file

131
00:07:50,519 --> 00:07:57,189
there's a library which helps doing this

132
00:07:53,889 --> 00:08:02,619
called Prinny which has a dis or

133
00:07:57,189 --> 00:08:05,259
capability i tried this library at mangu

134
00:08:02,619 --> 00:08:09,009
6.8 and it didn't work for hours and

135
00:08:05,259 --> 00:08:13,589
hour hours so I was getting angry and I

136
00:08:09,009 --> 00:08:16,809
made I made it manually and I made the

137
00:08:13,589 --> 00:08:19,419
rewiring basically so that Mongoose is

138
00:08:16,809 --> 00:08:22,569
reading from a file and not from the

139
00:08:19,419 --> 00:08:24,429
network sockets I fasted with a FL and

140
00:08:22,569 --> 00:08:29,949
also got very quickly a stack-based

141
00:08:24,429 --> 00:08:33,759
buffer overflow fun fact I finished

142
00:08:29,949 --> 00:08:36,159
exploit for this on my flight to Def Con

143
00:08:33,759 --> 00:08:38,649
in this 10 hours it was a bit more

144
00:08:36,159 --> 00:08:42,818
complicated and I thought it was like

145
00:08:38,649 --> 00:08:44,850
buffer on the flow but what I realized

146
00:08:42,818 --> 00:08:48,959
here is that it's

147
00:08:44,850 --> 00:08:52,560
took several hours and of patching and

148
00:08:48,959 --> 00:08:55,800
debugging until I had Mongoose that it

149
00:08:52,560 --> 00:09:01,290
was possible so I want to make this a

150
00:08:55,800 --> 00:09:03,569
little bit easier other problems as

151
00:09:01,290 --> 00:09:06,689
maybe some of you already thought about

152
00:09:03,570 --> 00:09:09,410
when looking at my slides is that if we

153
00:09:06,690 --> 00:09:13,760
just bright the packets into a file and

154
00:09:09,410 --> 00:09:17,279
mutate the file the phosphor has no idea

155
00:09:13,760 --> 00:09:20,100
where the packet the limiters are what

156
00:09:17,279 --> 00:09:22,680
are the different packets so it will

157
00:09:20,100 --> 00:09:26,820
just look at it as a file like a JPEG

158
00:09:22,680 --> 00:09:30,149
file for example and mutate it basically

159
00:09:26,820 --> 00:09:34,889
flip bits and look if looking if the

160
00:09:30,149 --> 00:09:38,610
target is crashed the target server will

161
00:09:34,889 --> 00:09:42,120
also read this packets and maybe send an

162
00:09:38,610 --> 00:09:46,079
answer but this answer is going nowhere

163
00:09:42,120 --> 00:09:46,740
the phosphor like AFL doesn't read from

164
00:09:46,079 --> 00:09:49,760
the file

165
00:09:46,740 --> 00:09:54,060
it doesn't have a concept of this and

166
00:09:49,760 --> 00:09:59,399
this can or cannot or can be a problem

167
00:09:54,060 --> 00:10:02,489
but doesn't necessarily need to be so

168
00:09:59,399 --> 00:10:05,670
this is like a sub optimal solution to

169
00:10:02,490 --> 00:10:10,079
use a file based fossil to fossa network

170
00:10:05,670 --> 00:10:14,040
server is there a better way and yeah

171
00:10:10,079 --> 00:10:18,689
yes and no there's another type of a

172
00:10:14,040 --> 00:10:20,910
so-called generational fossil basically

173
00:10:18,690 --> 00:10:23,180
you specify the protocol you want to

174
00:10:20,910 --> 00:10:27,029
force in an XML or something similar

175
00:10:23,180 --> 00:10:30,180
byte for byte then what does the first

176
00:10:27,029 --> 00:10:32,819
packet contains what does the second

177
00:10:30,180 --> 00:10:35,638
packet contain how does it look like and

178
00:10:32,819 --> 00:10:41,010
once you specify the protocol in this

179
00:10:35,639 --> 00:10:44,220
case FTP then the Foster will smartly

180
00:10:41,010 --> 00:10:48,260
generate invalid packet but still more

181
00:10:44,220 --> 00:10:48,260
or less according to the specification

182
00:10:48,620 --> 00:10:54,839
there are several of these fossils

183
00:10:51,260 --> 00:10:58,290
probably the most famous is speech Foss

184
00:10:54,839 --> 00:11:00,839
they also made a company around it and

185
00:10:58,290 --> 00:11:02,459
implementing all these protocols they

186
00:11:00,839 --> 00:11:07,079
call it XML Pits

187
00:11:02,459 --> 00:11:09,358
so they implemented FTP and email and

188
00:11:07,079 --> 00:11:12,949
WEP and probably pretty much everything

189
00:11:09,359 --> 00:11:17,399
even I'm qtt but you have to pay for it

190
00:11:12,949 --> 00:11:19,858
there's also for switch which is based

191
00:11:17,399 --> 00:11:22,739
on Sully which is again based on spike

192
00:11:19,859 --> 00:11:25,499
where you define the protocol in python

193
00:11:22,739 --> 00:11:28,439
more or less and you have tools like

194
00:11:25,499 --> 00:11:31,199
nets OB or pods or which would assist

195
00:11:28,439 --> 00:11:35,969
you with is reversing and we

196
00:11:31,199 --> 00:11:37,829
implementing the protocol but I wanted

197
00:11:35,970 --> 00:11:41,639
to force for example

198
00:11:37,829 --> 00:11:44,638
MQTT but I haven't found any

199
00:11:41,639 --> 00:11:47,759
implementation freely available which I

200
00:11:44,639 --> 00:11:50,429
could use one of these for sirs then I

201
00:11:47,759 --> 00:11:52,949
wanted to force an IRC server and it's

202
00:11:50,429 --> 00:11:56,419
the same like there's no central

203
00:11:52,949 --> 00:11:59,459
repository of this protocol

204
00:11:56,419 --> 00:12:04,889
specification which I can freely use to

205
00:11:59,459 --> 00:12:09,628
do my own forcing so this was about

206
00:12:04,889 --> 00:12:13,259
generators and I realized one important

207
00:12:09,629 --> 00:12:16,799
distinction about network protocols is

208
00:12:13,259 --> 00:12:20,160
that you can split them into stateless

209
00:12:16,799 --> 00:12:22,919
and stateful protocols the stateless

210
00:12:20,160 --> 00:12:27,238
protocols which are surprisingly many

211
00:12:22,919 --> 00:12:30,119
like DNS DHCP and HTTP you basically

212
00:12:27,239 --> 00:12:32,609
just send a packet to the server he

213
00:12:30,119 --> 00:12:35,039
answers you and forgets you completely

214
00:12:32,609 --> 00:12:40,129
every request is completely independent

215
00:12:35,039 --> 00:12:43,949
of the previous one mostly I think this

216
00:12:40,129 --> 00:12:46,409
stateless protocols can be fast pretty

217
00:12:43,949 --> 00:12:50,519
good with a file based for server

218
00:12:46,409 --> 00:12:53,100
because you put the HTTP request into a

219
00:12:50,519 --> 00:12:56,399
file faucet send it to the server and do

220
00:12:53,100 --> 00:12:58,679
it again until the server crashes but

221
00:12:56,399 --> 00:13:02,819
there are also stateful protocols like

222
00:12:58,679 --> 00:13:05,389
the example was mqtt or teamspeak or

223
00:13:02,819 --> 00:13:09,358
whatever where there is a TCP connection

224
00:13:05,389 --> 00:13:11,100
with several packets depending on each

225
00:13:09,359 --> 00:13:16,950
other like the

226
00:13:11,100 --> 00:13:19,490
possession is kind of like a session so

227
00:13:16,950 --> 00:13:22,230
for the stateless protocol protocols

228
00:13:19,490 --> 00:13:24,360
before I created forcing four forms you

229
00:13:22,230 --> 00:13:27,240
could use AFL and for the stateful

230
00:13:24,360 --> 00:13:33,570
protocols peach was basically the best

231
00:13:27,240 --> 00:13:36,390
way to faucet but I'm very lazy I don't

232
00:13:33,570 --> 00:13:38,310
want to patch network servers I don't

233
00:13:36,390 --> 00:13:41,250
want to XML protocols

234
00:13:38,310 --> 00:13:42,709
I just want to perform some fuzzing how

235
00:13:41,250 --> 00:13:47,390
hard can it be

236
00:13:42,710 --> 00:13:52,350
so last year I think of the DEF CON

237
00:13:47,390 --> 00:13:56,670
started to implement ffv forcing forms

238
00:13:52,350 --> 00:14:00,600
and basically to apply the AFL of

239
00:13:56,670 --> 00:14:05,310
approach of mutating packets into

240
00:14:00,600 --> 00:14:08,280
network services so what are the steps

241
00:14:05,310 --> 00:14:12,449
of ffv first I intercept some package

242
00:14:08,280 --> 00:14:14,880
it's basically like providing a example

243
00:14:12,450 --> 00:14:18,840
file like a PDF file if you want to

244
00:14:14,880 --> 00:14:20,880
force Aquabot with AFL then I replay the

245
00:14:18,840 --> 00:14:24,300
data which are intercepted with some

246
00:14:20,880 --> 00:14:27,120
modifications actual forcing I detect

247
00:14:24,300 --> 00:14:30,630
crashes in the server and at the end

248
00:14:27,120 --> 00:14:36,270
maybe make some money with zero days or

249
00:14:30,630 --> 00:14:43,310
CVS or whatever so I make the first

250
00:14:36,270 --> 00:14:43,310
table praise the demo gods and I will

251
00:14:44,570 --> 00:14:56,880
reproduce the Mongoose MQTT 6.8

252
00:14:51,170 --> 00:14:59,939
vulnerability so the Mongoose was quote

253
00:14:56,880 --> 00:15:03,140
I downloaded into Mongoose and checked

254
00:14:59,940 --> 00:15:07,500
out correct version I compiled the

255
00:15:03,140 --> 00:15:10,530
example server of Mongoose and qtt

256
00:15:07,500 --> 00:15:14,280
broker that one and copied into the

257
00:15:10,530 --> 00:15:16,819
binary directory I also have a

258
00:15:14,280 --> 00:15:22,410
configuration file for fuzzing for worms

259
00:15:16,820 --> 00:15:25,910
which basically just specifies let's

260
00:15:22,410 --> 00:15:25,910
make it bigger

261
00:15:26,330 --> 00:15:35,190
where the target is the binary name and

262
00:15:30,690 --> 00:15:41,670
how I give the target ports and bodies

263
00:15:35,190 --> 00:15:49,020
default port then let's intercept some

264
00:15:41,670 --> 00:15:51,930
packets packets so I start interceptor

265
00:15:49,020 --> 00:15:54,270
it's now listening important thousand

266
00:15:51,930 --> 00:15:57,689
and forwards all the packets to the

267
00:15:54,270 --> 00:16:01,230
destination server I downloaded this

268
00:15:57,690 --> 00:16:04,320
cute little MQTT client already prepare

269
00:16:01,230 --> 00:16:07,680
the connection so me as a security

270
00:16:04,320 --> 00:16:10,040
analyst that have no idea about mqtt

271
00:16:07,680 --> 00:16:14,660
just know it's a bit publish/subscribe

272
00:16:10,040 --> 00:16:23,150
so let's subscribe to the topic area 41

273
00:16:14,660 --> 00:16:23,150
and maybe publish something there test

274
00:16:23,450 --> 00:16:33,030
so this appears to look good send some

275
00:16:28,140 --> 00:16:37,980
example messages fine for me

276
00:16:33,030 --> 00:16:48,060
and ffv now stored this packet packets

277
00:16:37,980 --> 00:16:51,360
in a pickle file now so this is

278
00:16:48,060 --> 00:16:56,010
basically just could also save it in

279
00:16:51,360 --> 00:16:59,910
Jason just data which was transmitted so

280
00:16:56,010 --> 00:17:03,930
here's the MQTT connect packet with my

281
00:16:59,910 --> 00:17:06,030
name here is the subscriber quest went

282
00:17:03,930 --> 00:17:09,448
the server also something like yeah you

283
00:17:06,030 --> 00:17:14,849
are now subscribed and I was like

284
00:17:09,449 --> 00:17:22,949
posting test to this topic so looks

285
00:17:14,849 --> 00:17:25,349
reasonable then one important step not

286
00:17:22,949 --> 00:17:28,590
here but usually is to test this

287
00:17:25,349 --> 00:17:31,770
recorded data so now I replayed this

288
00:17:28,590 --> 00:17:35,340
data 32 times and it worked all the time

289
00:17:31,770 --> 00:17:41,070
so this looks like ready for fussing

290
00:17:35,340 --> 00:17:43,199
and I start this like this so after a

291
00:17:41,070 --> 00:17:47,310
few seconds we already identified some

292
00:17:43,200 --> 00:17:51,810
crashes this vulnerability is in the

293
00:17:47,310 --> 00:17:55,110
length field of the MQTT packet if it's

294
00:17:51,810 --> 00:17:57,690
below to dannis buffer on the flow and I

295
00:17:55,110 --> 00:17:58,709
think it mostly detects this

296
00:17:57,690 --> 00:18:01,650
vulnerability

297
00:17:58,710 --> 00:18:11,580
so I'm fussing here with two frets about

298
00:18:01,650 --> 00:18:14,400
four iterations per second old crashes

299
00:18:11,580 --> 00:18:17,220
or the data which generated the crashes

300
00:18:14,400 --> 00:18:19,800
is stored in the directory crashes as

301
00:18:17,220 --> 00:18:29,310
you can see here and it's basically the

302
00:18:19,800 --> 00:18:31,440
same data structure so it's the data

303
00:18:29,310 --> 00:18:37,200
which we recorded

304
00:18:31,440 --> 00:18:41,010
and somewhere we did some fussing yeah

305
00:18:37,200 --> 00:18:43,830
this is the message - so FF we modified

306
00:18:41,010 --> 00:18:47,910
something on this mash message and this

307
00:18:43,830 --> 00:18:51,210
should have led to a crash sadly

308
00:18:47,910 --> 00:18:54,210
Mongoose is very only unreliable it

309
00:18:51,210 --> 00:19:00,150
stops accepting connections of the like

310
00:18:54,210 --> 00:19:03,210
20 connections so I restarted like every

311
00:19:00,150 --> 00:19:05,700
10 connections but then it detects the

312
00:19:03,210 --> 00:19:07,980
crash every 10 connections because when

313
00:19:05,700 --> 00:19:09,920
you kill it then that resinate eyes they

314
00:19:07,980 --> 00:19:14,370
will detect that the buffer is not freed

315
00:19:09,920 --> 00:19:24,180
so we are lucky the first one is a crash

316
00:19:14,370 --> 00:19:26,659
and the autos not really and let's start

317
00:19:24,180 --> 00:19:26,660
this

318
00:19:32,900 --> 00:19:46,950
the server in in the GDB and we play the

319
00:19:42,179 --> 00:20:00,330
file which generated a crash so this was

320
00:19:46,950 --> 00:20:05,450
the one five zero five so and we see in

321
00:20:00,330 --> 00:20:09,090
the gdb it really generated the crash

322
00:20:05,450 --> 00:20:11,610
obviously because I verified it so now

323
00:20:09,090 --> 00:20:13,850
we have the zero day which is not AG and

324
00:20:11,610 --> 00:20:22,709
zero day because they patched it in

325
00:20:13,850 --> 00:20:25,620
Mongoose six point nine if that is

326
00:20:22,710 --> 00:20:28,140
looking quite unimpressive I basically

327
00:20:25,620 --> 00:20:31,620
achieved my goal it should be very easy

328
00:20:28,140 --> 00:20:36,690
and without much trouble to find

329
00:20:31,620 --> 00:20:39,658
vulnerabilities network servers so the

330
00:20:36,690 --> 00:20:42,630
ffv has several stages the first you

331
00:20:39,659 --> 00:20:45,659
have seen we intercept the network data

332
00:20:42,630 --> 00:20:48,600
it's also possible to just capture it

333
00:20:45,659 --> 00:20:51,750
with like TCP dump and convert the pcap

334
00:20:48,600 --> 00:20:55,740
to the pickle file but usually I just

335
00:20:51,750 --> 00:20:58,049
intercepted on the fly we test it if

336
00:20:55,740 --> 00:21:01,169
this intercepted stuff really works we

337
00:20:58,049 --> 00:21:03,990
force it a bit we verify so we don't so

338
00:21:01,169 --> 00:21:06,270
we move to false positives then at the

339
00:21:03,990 --> 00:21:10,080
end we minimize it because if you have

340
00:21:06,270 --> 00:21:12,270
ten thousand crashes then you want to

341
00:21:10,080 --> 00:21:18,689
know the unique ones and at the end I

342
00:21:12,270 --> 00:21:22,429
wrote web GUI maybe I can show it which

343
00:21:18,690 --> 00:21:22,429
is now a bit work-in-progress

344
00:21:22,789 --> 00:21:33,149
well can browse all the crashes which

345
00:21:30,120 --> 00:21:39,030
can be quite large and have all the data

346
00:21:33,149 --> 00:21:45,510
and to start writing an exploit if you

347
00:21:39,030 --> 00:21:49,408
have enough time so so here we have the

348
00:21:45,510 --> 00:21:52,350
normal client our graphical MQTT client

349
00:21:49,409 --> 00:21:54,299
this was thinking it communicates of the

350
00:21:52,350 --> 00:21:57,000
server but it was communicating with

351
00:21:54,299 --> 00:22:01,168
forcing four firms and it wrote all the

352
00:21:57,000 --> 00:22:04,110
data into a file and then afterwards we

353
00:22:01,169 --> 00:22:07,350
imitate the client we read the file read

354
00:22:04,110 --> 00:22:11,039
all the packets select one of the client

355
00:22:07,350 --> 00:22:13,678
packets and mutate a little bit and then

356
00:22:11,039 --> 00:22:16,440
send it all to the server which means we

357
00:22:13,679 --> 00:22:19,320
create a TCP connection sent the first

358
00:22:16,440 --> 00:22:21,570
packet read the answer sent the second

359
00:22:19,320 --> 00:22:23,639
packet with the answer until it's

360
00:22:21,570 --> 00:22:28,950
finished and then we do it again with a

361
00:22:23,640 --> 00:22:32,700
lot of mutation maybe some of you guys

362
00:22:28,950 --> 00:22:35,909
are asking how is this like mutation

363
00:22:32,700 --> 00:22:38,159
performed and I can say I don't care

364
00:22:35,909 --> 00:22:41,870
very much I'm just using Bodom so

365
00:22:38,159 --> 00:22:45,179
everyone is using Rotom so Radames is

366
00:22:41,870 --> 00:22:48,149
what many understand is a fossil it

367
00:22:45,179 --> 00:22:50,190
takes some data and it mutates it and

368
00:22:48,149 --> 00:22:54,989
then we have some different data and

369
00:22:50,190 --> 00:22:57,899
it's very smart detect like XML and auto

370
00:22:54,990 --> 00:23:01,620
file formats and it's doing smart stuff

371
00:22:57,899 --> 00:23:04,469
so it was not it was not necessary to

372
00:23:01,620 --> 00:23:07,979
develop something from my own just use

373
00:23:04,470 --> 00:23:11,490
what on so like everyone one

374
00:23:07,980 --> 00:23:17,690
interestingly hard problem was to detect

375
00:23:11,490 --> 00:23:20,490
crashes so if we send smartly first

376
00:23:17,690 --> 00:23:24,330
packet to the server which makes it

377
00:23:20,490 --> 00:23:26,520
crash and then ask the process hey or

378
00:23:24,330 --> 00:23:27,830
your life then it was always saying yeah

379
00:23:26,520 --> 00:23:31,559
I'm alive

380
00:23:27,830 --> 00:23:34,590
instead of being that I think in Linux

381
00:23:31,559 --> 00:23:38,850
you have some kind of lag or latency

382
00:23:34,590 --> 00:23:41,428
until the process is really identified

383
00:23:38,850 --> 00:23:43,918
as crashed which was very annoying at

384
00:23:41,429 --> 00:23:46,500
the beginning so I thought of a much

385
00:23:43,919 --> 00:23:48,659
smarter way to identify crashes and

386
00:23:46,500 --> 00:23:50,140
basically just if I cannot connect to

387
00:23:48,659 --> 00:23:54,250
the server is poor

388
00:23:50,140 --> 00:23:59,790
pre-crushed and if I cannot connect that

389
00:23:54,250 --> 00:24:04,300
TCP handshake the first state or the

390
00:23:59,790 --> 00:24:09,190
previous iteration probably caused the

391
00:24:04,300 --> 00:24:11,350
crash and if it's crashing after or when

392
00:24:09,190 --> 00:24:15,190
I send a mutated packet and it's

393
00:24:11,350 --> 00:24:18,100
probably because of this packet so this

394
00:24:15,190 --> 00:24:23,140
was finding quite an important

395
00:24:18,100 --> 00:24:25,570
distinction to be made afterwards if the

396
00:24:23,140 --> 00:24:28,320
server's crashed I want some information

397
00:24:25,570 --> 00:24:34,149
it's not very useful just to have like

398
00:24:28,320 --> 00:24:36,550
10,000 Network data replays which make

399
00:24:34,150 --> 00:24:39,460
the server crash but you also have to

400
00:24:36,550 --> 00:24:41,620
have some information I collected a lot

401
00:24:39,460 --> 00:24:44,080
of information but basically what you

402
00:24:41,620 --> 00:24:47,830
really need is the stack trace to know

403
00:24:44,080 --> 00:24:50,980
which function at which line it crashed

404
00:24:47,830 --> 00:24:54,189
and what were the previous functions so

405
00:24:50,980 --> 00:24:58,600
this is also useful then to make the

406
00:24:54,190 --> 00:25:01,150
minimization of all the crashes first I

407
00:24:58,600 --> 00:25:04,030
use the Python p trace library this was

408
00:25:01,150 --> 00:25:09,520
awful it didn't work it crashed it had

409
00:25:04,030 --> 00:25:12,160
bad back traces so then I created the

410
00:25:09,520 --> 00:25:15,400
parser for the tress sanitizer lock

411
00:25:12,160 --> 00:25:18,580
files basically addressed sanitize who

412
00:25:15,400 --> 00:25:22,950
doesn't really sanitize addresses but

413
00:25:18,580 --> 00:25:26,100
adds code so you can identify heap based

414
00:25:22,950 --> 00:25:29,590
buffer overflows and stuff like this

415
00:25:26,100 --> 00:25:32,830
like you've seen before in GDP it makes

416
00:25:29,590 --> 00:25:36,550
beautiful output where exactly the the

417
00:25:32,830 --> 00:25:41,379
overflow happened but this was not for a

418
00:25:36,550 --> 00:25:44,169
stack buffer overflows so now I'm

419
00:25:41,380 --> 00:25:48,130
starting in the verify face I start the

420
00:25:44,170 --> 00:25:50,260
server in GDP and we play the the

421
00:25:48,130 --> 00:25:54,510
network data which made it crash and

422
00:25:50,260 --> 00:25:56,640
then parse the output of gdb and try to

423
00:25:54,510 --> 00:26:00,640
extract the stack trace

424
00:25:56,640 --> 00:26:02,320
so the previous stuff man in the middle

425
00:26:00,640 --> 00:26:06,429
stuff the sand

426
00:26:02,320 --> 00:26:11,230
mutating data was very simple was like

427
00:26:06,429 --> 00:26:13,990
done in four days but like the trouble

428
00:26:11,230 --> 00:26:17,320
was in developing forcing forums more in

429
00:26:13,990 --> 00:26:20,500
other areas like this stack trace

430
00:26:17,320 --> 00:26:22,809
parsing or restarting of the server or

431
00:26:20,500 --> 00:26:28,509
identifying is the server really crashed

432
00:26:22,809 --> 00:26:31,960
or not I like hardware so I bought

433
00:26:28,509 --> 00:26:36,720
myself some CPU power to force a bit

434
00:26:31,960 --> 00:26:39,789
more professionally xeo Nephi from 2012

435
00:26:36,720 --> 00:26:43,419
it has like eight cores so with a hyper

436
00:26:39,789 --> 00:26:47,799
threading 16 frets and in parallel and

437
00:26:43,419 --> 00:26:50,889
32 gigs of ram and this bubble so you

438
00:26:47,799 --> 00:26:54,580
have one here one here so I have like 40

439
00:26:50,889 --> 00:26:57,370
max of cache and 64 gigs of ram and all

440
00:26:54,580 --> 00:27:01,389
this with the CPU coolers and power

441
00:26:57,370 --> 00:27:03,789
supply and the RAM I was like $700 it

442
00:27:01,389 --> 00:27:09,158
was awesome so it just needed the case

443
00:27:03,789 --> 00:27:11,830
and the SSD but sadly what I really

444
00:27:09,159 --> 00:27:14,860
needed was more something like this if

445
00:27:11,830 --> 00:27:18,090
there is if there are really vulnerable

446
00:27:14,860 --> 00:27:20,918
ities and the network service I tested I

447
00:27:18,090 --> 00:27:22,629
identified them very quickly like after

448
00:27:20,919 --> 00:27:24,820
half a minute or a minute

449
00:27:22,629 --> 00:27:31,209
so all this power was not really

450
00:27:24,820 --> 00:27:35,408
necessary but my server was forcing it

451
00:27:31,210 --> 00:27:38,740
heated up my office but somehow I

452
00:27:35,409 --> 00:27:43,649
thought this is not very smart and not a

453
00:27:38,740 --> 00:27:47,889
step closer to a fully automatic AI

454
00:27:43,649 --> 00:27:52,299
which hacks other people or something

455
00:27:47,889 --> 00:27:55,899
like this it's it's just mutating

456
00:27:52,299 --> 00:27:58,750
completely dump the the network traffic

457
00:27:55,899 --> 00:27:59,289
look if the server is crashed and was it

458
00:27:58,750 --> 00:28:04,629
again

459
00:27:59,289 --> 00:28:08,289
but maybe we could make it smarter and

460
00:28:04,629 --> 00:28:10,449
we can make it smarter especially with

461
00:28:08,289 --> 00:28:12,809
this technique with feedback - even

462
00:28:10,450 --> 00:28:12,809
forcing

463
00:28:13,110 --> 00:28:20,699
what we want basically that if we

464
00:28:15,390 --> 00:28:22,830
identify like we for something we

465
00:28:20,700 --> 00:28:27,120
changed some values make he may be

466
00:28:22,830 --> 00:28:31,290
making a number one to a number two and

467
00:28:27,120 --> 00:28:34,919
suddenly we find new functionality we

468
00:28:31,290 --> 00:28:38,540
want to store this this corpus which led

469
00:28:34,920 --> 00:28:43,190
to here x2 so then we can use it as a

470
00:28:38,540 --> 00:28:47,240
basis to continue our fussing maybe find

471
00:28:43,190 --> 00:28:52,049
box much deeper into the program and

472
00:28:47,240 --> 00:28:55,400
explore all the possible states or a

473
00:28:52,049 --> 00:28:58,860
large amount of the possible states and

474
00:28:55,400 --> 00:29:01,200
normal foster adopt foster just mutates

475
00:28:58,860 --> 00:29:06,350
it and maybe it randomly reaches this

476
00:29:01,200 --> 00:29:06,350
location but it's all by accident

477
00:29:08,090 --> 00:29:13,740
usually we don't not only want to do

478
00:29:11,250 --> 00:29:16,710
this on function level but on basic

479
00:29:13,740 --> 00:29:19,890
block level so basic block is what you

480
00:29:16,710 --> 00:29:22,440
always see in either once entered in a

481
00:29:19,890 --> 00:29:24,890
basic block the execution will continue

482
00:29:22,440 --> 00:29:28,320
until the end and then it's again

483
00:29:24,890 --> 00:29:32,429
changing to a new basic block as you can

484
00:29:28,320 --> 00:29:36,659
see here so all the control control flow

485
00:29:32,429 --> 00:29:38,910
is between the basic blocks and every

486
00:29:36,660 --> 00:29:41,370
function consists of at least one basic

487
00:29:38,910 --> 00:29:44,870
block so we can use this to really

488
00:29:41,370 --> 00:29:48,780
explore the whole state of target server

489
00:29:44,870 --> 00:29:55,250
for example here we have a comparison we

490
00:29:48,780 --> 00:30:00,260
have a crash if the input is ABCD and

491
00:29:55,250 --> 00:30:03,690
this was more or less made popular by a

492
00:30:00,260 --> 00:30:09,059
AFL you have this bloom filter here and

493
00:30:03,690 --> 00:30:12,179
if you use AFL GCC the FL compiler the

494
00:30:09,059 --> 00:30:15,178
compiler will add like free lines of

495
00:30:12,179 --> 00:30:21,090
code after each basic block which will

496
00:30:15,179 --> 00:30:23,400
update one value in this bloom filter so

497
00:30:21,090 --> 00:30:25,530
if we reach this basic block it will

498
00:30:23,400 --> 00:30:30,000
write increment this

499
00:30:25,530 --> 00:30:33,200
number here we for some more maybe now

500
00:30:30,000 --> 00:30:37,560
the input at the second place is now B

501
00:30:33,200 --> 00:30:41,250
then it changes this bit or byte to be

502
00:30:37,560 --> 00:30:44,780
more precise and the buzzer will always

503
00:30:41,250 --> 00:30:47,520
send some data to the target program and

504
00:30:44,780 --> 00:30:50,370
compare this bloom filter with the

505
00:30:47,520 --> 00:30:53,430
previous one and if there's one little

506
00:30:50,370 --> 00:30:59,159
difference one more number one the nose

507
00:30:53,430 --> 00:31:05,130
or the input made called a new function

508
00:30:59,160 --> 00:31:08,460
a new basic block in the target and with

509
00:31:05,130 --> 00:31:11,390
this instead of like brute-forcing a

510
00:31:08,460 --> 00:31:17,400
value of 32 bits it is four billion

511
00:31:11,390 --> 00:31:21,530
possibilities you can just have to guess

512
00:31:17,400 --> 00:31:26,010
four times one byte so it's just like

513
00:31:21,530 --> 00:31:28,649
thousand possibilities so it's much more

514
00:31:26,010 --> 00:31:34,170
efficient to search food space with the

515
00:31:28,650 --> 00:31:37,230
feedback to enforcing this will look

516
00:31:34,170 --> 00:31:39,270
like this at the end in the sua squad I

517
00:31:37,230 --> 00:31:41,610
think this was generated with al-kahf

518
00:31:39,270 --> 00:31:44,540
and cheek off bust but it's basically

519
00:31:41,610 --> 00:31:47,219
the same once you have this different

520
00:31:44,540 --> 00:31:50,120
corpuses exercising different

521
00:31:47,220 --> 00:31:54,680
functionality of the program you can

522
00:31:50,120 --> 00:31:58,830
resend all of them and then paint your

523
00:31:54,680 --> 00:32:00,960
sua scott like which if sin which else's

524
00:31:58,830 --> 00:32:04,409
have been reached by the foster and

525
00:32:00,960 --> 00:32:09,660
which one not and then improve the

526
00:32:04,410 --> 00:32:14,580
father or the fussing technique this

527
00:32:09,660 --> 00:32:20,070
method is surprisingly efficient so was

528
00:32:14,580 --> 00:32:23,939
a test with a FL jetpack parser has been

529
00:32:20,070 --> 00:32:27,090
fast with just writing hello into a file

530
00:32:23,940 --> 00:32:31,590
so it's basically just an invalid JPEG

531
00:32:27,090 --> 00:32:34,199
file let AFL run for some time and step

532
00:32:31,590 --> 00:32:38,459
by step it like reverse engineered the

533
00:32:34,200 --> 00:32:39,200
JPEG specifications and it generated

534
00:32:38,460 --> 00:32:43,010
more

535
00:32:39,200 --> 00:32:46,159
less valid images just by brute forcing

536
00:32:43,010 --> 00:32:53,120
it through the search space of the JPEG

537
00:32:46,159 --> 00:32:55,130
parser which i think is pretty cool so I

538
00:32:53,120 --> 00:32:57,049
wanted to have this for fussing for

539
00:32:55,130 --> 00:33:00,350
firms and it was googling a little bit

540
00:32:57,049 --> 00:33:02,929
what is available and I found this page

541
00:33:00,350 --> 00:33:05,899
here from honk Foss where it was a

542
00:33:02,929 --> 00:33:07,490
little bit some explanation what

543
00:33:05,899 --> 00:33:11,239
different functionality you have

544
00:33:07,490 --> 00:33:17,809
nowadays to perform this code coverage

545
00:33:11,240 --> 00:33:21,169
feedback hardware you can use hardware

546
00:33:17,809 --> 00:33:22,399
like inter BTS and Inter PT interpret

547
00:33:21,169 --> 00:33:24,409
East and you are wrong

548
00:33:22,399 --> 00:33:29,979
I think it's available in smaller

549
00:33:24,409 --> 00:33:33,590
skylake and used in ka ka FL to force

550
00:33:29,980 --> 00:33:38,120
operating systems but also all the

551
00:33:33,590 --> 00:33:41,029
current compilers like GCC and clang

552
00:33:38,120 --> 00:33:46,418
already have the support to add this

553
00:33:41,029 --> 00:33:49,279
code coverage mechanism into the quote

554
00:33:46,419 --> 00:33:52,130
so I was inspired a little bit by Hong

555
00:33:49,279 --> 00:33:55,279
Force I started to I think I randomly

556
00:33:52,130 --> 00:33:59,690
selected one of these try to implement

557
00:33:55,279 --> 00:34:04,850
it by myself and copied more and more

558
00:33:59,690 --> 00:34:09,290
court of Hong Cross in 2004 perms until

559
00:34:04,850 --> 00:34:13,429
I realized even if I after weeks or

560
00:34:09,290 --> 00:34:14,060
whatever made it to work still like honk

561
00:34:13,429 --> 00:34:18,079
Foss

562
00:34:14,060 --> 00:34:20,899
from Google is has like all these cool

563
00:34:18,079 --> 00:34:25,129
code coverage techniques and I'm always

564
00:34:20,899 --> 00:34:29,060
lagging behind why am I not using honk

565
00:34:25,129 --> 00:34:34,089
Foss itself by the way is robots wiki

566
00:34:29,060 --> 00:34:38,418
here there are four offer of ogress okay

567
00:34:34,089 --> 00:34:41,389
anyway so basically i instrumentalized

568
00:34:38,418 --> 00:34:47,000
honk Foss that it's not really forcing

569
00:34:41,389 --> 00:34:50,540
but just using it as an Oracle for code

570
00:34:47,000 --> 00:34:53,110
coverage so honk force will observe the

571
00:34:50,540 --> 00:34:56,230
target FF e the communique

572
00:34:53,110 --> 00:34:59,650
honk first via UNIX domain socket and it

573
00:34:56,230 --> 00:35:04,600
will also send networked data directly

574
00:34:59,650 --> 00:35:08,440
to the target very too slow

575
00:35:04,600 --> 00:35:12,430
not too fast so then it's a simple

576
00:35:08,440 --> 00:35:15,010
protocol hønefoss will tell fasting for

577
00:35:12,430 --> 00:35:17,859
varam say please do some forcing forcing

578
00:35:15,010 --> 00:35:21,390
for arms will send mutate data to the

579
00:35:17,860 --> 00:35:24,910
target and honk first we need to say

580
00:35:21,390 --> 00:35:28,270
then this area descent our to the

581
00:35:24,910 --> 00:35:30,759
target know TCP data and then honk force

582
00:35:28,270 --> 00:35:33,610
will say yeah you reached a new basic

583
00:35:30,760 --> 00:35:37,090
block and then forcing for arms will add

584
00:35:33,610 --> 00:35:39,880
what it sends to the corpus or it says

585
00:35:37,090 --> 00:35:43,030
here it's the target is crashed and it's

586
00:35:39,880 --> 00:35:45,400
very good we handle this or most of the

587
00:35:43,030 --> 00:35:51,790
time nothing happens and just saying

588
00:35:45,400 --> 00:35:54,780
again please for some more so this is my

589
00:35:51,790 --> 00:35:54,779
second team

590
00:36:11,989 --> 00:36:19,799
so what patched my vulnerability moo-coo

591
00:36:17,249 --> 00:36:22,229
6.9 and was thinking maybe there are

592
00:36:19,799 --> 00:36:27,779
some more vulnerabilities and of course

593
00:36:22,229 --> 00:36:31,078
there are I already prepared everything

594
00:36:27,779 --> 00:36:34,409
so basically I can just start FFP if

595
00:36:31,079 --> 00:36:38,009
honk mode parameter I have here two

596
00:36:34,409 --> 00:36:41,819
frets it starts with two corpus files

597
00:36:38,009 --> 00:36:46,229
and already in a few seconds I generated

598
00:36:41,819 --> 00:36:52,169
16 Auto corpuses which are depending on

599
00:36:46,229 --> 00:36:59,908
order on to parents and it's quite

600
00:36:52,169 --> 00:37:06,269
interesting to see maybe make this one

601
00:36:59,909 --> 00:37:08,279
big so all the corpuses all the newly

602
00:37:06,269 --> 00:37:12,089
generated files are stored in a file

603
00:37:08,279 --> 00:37:15,809
system and you can see how it's not one

604
00:37:12,089 --> 00:37:20,130
thing so here it was the second message

605
00:37:15,809 --> 00:37:21,239
found a new basic block then first based

606
00:37:20,130 --> 00:37:23,279
on that one

607
00:37:21,239 --> 00:37:25,559
the first message found a new basic

608
00:37:23,279 --> 00:37:27,209
block and so it's going deeper and

609
00:37:25,559 --> 00:37:31,919
deeper and finding more and more

610
00:37:27,209 --> 00:37:36,749
functionality of this MQTT server till I

611
00:37:31,919 --> 00:37:46,709
reach the file name limit of Linux think

612
00:37:36,749 --> 00:37:50,459
it's about 155 characters to speed up a

613
00:37:46,709 --> 00:37:54,509
little bit the most important part

614
00:37:50,459 --> 00:37:57,808
how performant is this thing and it's

615
00:37:54,509 --> 00:38:04,019
not very fast it's about 42 rations per

616
00:37:57,809 --> 00:38:07,619
fret so this includes reading the stored

617
00:38:04,019 --> 00:38:09,868
corpus selecting a message mutated with

618
00:38:07,619 --> 00:38:12,299
rodham so then create the TCP

619
00:38:09,869 --> 00:38:15,809
connections and all the packets read all

620
00:38:12,299 --> 00:38:19,079
the answers and then its next iteration

621
00:38:15,809 --> 00:38:22,650
so an AFL it's usually recommended to

622
00:38:19,079 --> 00:38:23,780
use all of your core count as active

623
00:38:22,650 --> 00:38:27,620
frets

624
00:38:23,780 --> 00:38:31,040
on ffv it's basically the server is just

625
00:38:27,620 --> 00:38:33,680
most of the time setting up and probably

626
00:38:31,040 --> 00:38:36,230
tearing down TCP connections so it's

627
00:38:33,680 --> 00:38:40,100
waiting all the time so can use core

628
00:38:36,230 --> 00:38:43,550
count x to with my machine it's about

629
00:38:40,100 --> 00:38:47,000
two thousand iterations per second which

630
00:38:43,550 --> 00:38:55,010
is about as much as a FL signal for edit

631
00:38:47,000 --> 00:38:57,290
so it's kind of okay but just having at

632
00:38:55,010 --> 00:38:59,660
the beginning ahead is thirty iterations

633
00:38:57,290 --> 00:39:03,560
per second which was very bad so I had

634
00:38:59,660 --> 00:39:06,020
to have multiple fussing processes this

635
00:39:03,560 --> 00:39:08,330
also generated a surprisingly large

636
00:39:06,020 --> 00:39:12,170
problem because you have to tell the

637
00:39:08,330 --> 00:39:15,950
server hey every servant is listened to

638
00:39:12,170 --> 00:39:19,730
on another port not all MQTT service can

639
00:39:15,950 --> 00:39:22,100
listen on port 188 free so some servers

640
00:39:19,730 --> 00:39:25,460
used to be a command line then you have

641
00:39:22,100 --> 00:39:29,210
servers which have configuration files

642
00:39:25,460 --> 00:39:32,420
like IRC servers then it was prepare

643
00:39:29,210 --> 00:39:34,540
like hundred configuration files with

644
00:39:32,420 --> 00:39:37,100
different ports and then give these

645
00:39:34,540 --> 00:39:40,910
specifications in the command line but

646
00:39:37,100 --> 00:39:46,549
all this was very bad and I stole idea

647
00:39:40,910 --> 00:39:53,390
brilliant idea of also honk force and

648
00:39:46,550 --> 00:39:56,360
it's Linux network name spaces as well

649
00:39:53,390 --> 00:39:59,660
as everyone knows network namespaces is

650
00:39:56,360 --> 00:40:03,410
also used in like alexey and alex de and

651
00:39:59,660 --> 00:40:06,069
docker and all that stuff it simulates a

652
00:40:03,410 --> 00:40:08,990
new completely independent independent

653
00:40:06,070 --> 00:40:12,350
network interface for a certain amount

654
00:40:08,990 --> 00:40:14,839
of processes I can say from now on I

655
00:40:12,350 --> 00:40:17,089
want to have a new network names based

656
00:40:14,840 --> 00:40:20,060
and you have your own loopback device

657
00:40:17,090 --> 00:40:23,330
and then you can without having any

658
00:40:20,060 --> 00:40:26,390
configuration changes on the server to

659
00:40:23,330 --> 00:40:31,120
have arbitrarily many servers forcing in

660
00:40:26,390 --> 00:40:33,279
parallel without them killing each other

661
00:40:31,120 --> 00:40:35,210
so we have the master process

662
00:40:33,280 --> 00:40:36,390
communicating with the queue to the

663
00:40:35,210 --> 00:40:38,700
slave which

664
00:40:36,390 --> 00:40:42,269
communicating with UNIX domain socket to

665
00:40:38,700 --> 00:40:45,089
honk force which is via shared memory

666
00:40:42,269 --> 00:40:46,500
getting this code key code coverage of

667
00:40:45,089 --> 00:40:49,288
the server

668
00:40:46,500 --> 00:40:51,930
I sent ECP data to the server and then

669
00:40:49,289 --> 00:40:56,609
sent base which was statistics back to

670
00:40:51,930 --> 00:40:59,549
the master all slaves observed the

671
00:40:56,609 --> 00:41:03,150
corporal's directory so if one of the

672
00:40:59,549 --> 00:41:05,670
slaves find a new input which which

673
00:41:03,150 --> 00:41:08,010
exercises new basic blocks it just

674
00:41:05,670 --> 00:41:11,670
stores it in the directory all the

675
00:41:08,010 --> 00:41:14,789
authors get notified by I notify and

676
00:41:11,670 --> 00:41:20,119
they added to their own corpus and

677
00:41:14,789 --> 00:41:24,500
everyone always have all the possible

678
00:41:20,119 --> 00:41:29,849
states which is pretty cool

679
00:41:24,500 --> 00:41:32,760
so that is how it was working Foster is

680
00:41:29,849 --> 00:41:35,880
only as good as it can produce results

681
00:41:32,760 --> 00:41:38,670
so I tested it a little bit I was a bit

682
00:41:35,880 --> 00:41:41,579
more developing than testing so there

683
00:41:38,670 --> 00:41:43,920
are not so many results but of course I

684
00:41:41,579 --> 00:41:48,420
found found the initial box in Moose

685
00:41:43,920 --> 00:41:53,789
mqtt 6.8 and then in 6.9 I found in deep

686
00:41:48,420 --> 00:41:57,380
coat and all this nice IOT libraries and

687
00:41:53,789 --> 00:42:00,450
usually found the Box pretty fast

688
00:41:57,380 --> 00:42:05,599
they're all available in a docker image

689
00:42:00,450 --> 00:42:07,019
and I didn't had time to notify the

690
00:42:05,599 --> 00:42:09,210
maintainer

691
00:42:07,019 --> 00:42:13,288
so if somebody wants to have some free

692
00:42:09,210 --> 00:42:17,630
CVS can download the docker image do

693
00:42:13,289 --> 00:42:17,630
some forcing and get famous

694
00:42:19,250 --> 00:42:28,829
interestingly like the Mongoose web DNS

695
00:42:22,740 --> 00:42:32,250
and DHCP protocols just fasted for like

696
00:42:28,829 --> 00:42:34,289
half an hour but it was no box and I

697
00:42:32,250 --> 00:42:37,170
think it's also because these are like

698
00:42:34,289 --> 00:42:38,460
simple protocols and easy to test so

699
00:42:37,170 --> 00:42:40,470
without state

700
00:42:38,460 --> 00:42:44,519
maybe someone tested a to get already

701
00:42:40,470 --> 00:42:47,669
with AFL I tried synergy this was awful

702
00:42:44,519 --> 00:42:50,589
it didn't work at all as expected and

703
00:42:47,670 --> 00:42:56,470
surprisingly all the IRCs

704
00:42:50,590 --> 00:42:59,440
I also haven't detected a crash here's

705
00:42:56,470 --> 00:43:01,899
some more statistics so I had a buck I

706
00:42:59,440 --> 00:43:05,320
let it run with eight frets but every

707
00:43:01,900 --> 00:43:07,360
fret just executed one iteration per

708
00:43:05,320 --> 00:43:12,010
seconds we have here eight iterations

709
00:43:07,360 --> 00:43:14,680
per seconds but we still see on the

710
00:43:12,010 --> 00:43:17,620
bottom like this or the amount of basic

711
00:43:14,680 --> 00:43:20,890
blocks of the unique basic blocks we

712
00:43:17,620 --> 00:43:23,920
identified and it's growing slowly but

713
00:43:20,890 --> 00:43:28,960
steadily over a week so I think this was

714
00:43:23,920 --> 00:43:31,720
like one week this is from AFL AFL plot

715
00:43:28,960 --> 00:43:35,170
I made the output of FF econ tab

716
00:43:31,720 --> 00:43:39,480
compatible so I can also make fancy nice

717
00:43:35,170 --> 00:43:44,980
graphs oh yes this was the server

718
00:43:39,480 --> 00:43:49,810
inspire I or CG I first another IOC

719
00:43:44,980 --> 00:43:52,570
server ng ircd here it was working more

720
00:43:49,810 --> 00:43:56,259
properly properly surprising that it

721
00:43:52,570 --> 00:43:58,720
gets slower at the beginning whatever it

722
00:43:56,260 --> 00:44:02,590
was about hundred twenty iterations per

723
00:43:58,720 --> 00:44:05,799
second and also here I reached after two

724
00:44:02,590 --> 00:44:09,160
days about two and a half thousand basic

725
00:44:05,800 --> 00:44:15,580
blocks so it's really crunching through

726
00:44:09,160 --> 00:44:18,790
the search space of the IOC server so

727
00:44:15,580 --> 00:44:21,430
the conclusion forcing forums it can

728
00:44:18,790 --> 00:44:23,800
intercept network data it will

729
00:44:21,430 --> 00:44:26,950
retransmit it with a little bit of

730
00:44:23,800 --> 00:44:35,740
fussing and it's detecting crashes and

731
00:44:26,950 --> 00:44:40,060
new basic blocks the motivation was like

732
00:44:35,740 --> 00:44:42,549
or as I've seen or as I see now it's way

733
00:44:40,060 --> 00:44:44,950
too slow to do some really serious

734
00:44:42,550 --> 00:44:47,350
forcing you want to have performance

735
00:44:44,950 --> 00:44:50,080
like AFL with like ten or twenty

736
00:44:47,350 --> 00:44:53,290
thousand iterations per second which is

737
00:44:50,080 --> 00:44:53,950
like hundred times faster than forcing

738
00:44:53,290 --> 00:44:57,270
for worms

739
00:44:53,950 --> 00:45:01,080
so you find box hundred times quicker

740
00:44:57,270 --> 00:45:02,970
but this will always need some

741
00:45:01,080 --> 00:45:06,020
modification of the

742
00:45:02,970 --> 00:45:09,120
market server some quote modification

743
00:45:06,020 --> 00:45:11,430
debulking in reverse engineering so I

744
00:45:09,120 --> 00:45:15,540
think fussing for verbs is useful at the

745
00:45:11,430 --> 00:45:18,240
beginning just intercept some data start

746
00:45:15,540 --> 00:45:21,930
to fuss it's set up in like ten minutes

747
00:45:18,240 --> 00:45:24,930
and in the four hours which you need to

748
00:45:21,930 --> 00:45:28,410
patch the target to make it AFL contact

749
00:45:24,930 --> 00:45:30,290
compatible maybe for some programs

750
00:45:28,410 --> 00:45:36,720
already found sandbox and you're writing

751
00:45:30,290 --> 00:45:42,420
CVS instead of patching servers Chris

752
00:45:36,720 --> 00:45:45,330
business that always be forcing so if ya

753
00:45:42,420 --> 00:45:47,520
like what I previously said should not

754
00:45:45,330 --> 00:45:50,130
have raised the time always be some

755
00:45:47,520 --> 00:45:53,250
something to Foss maybe you find some

756
00:45:50,130 --> 00:45:56,670
box maybe not even if it's just stupid

757
00:45:53,250 --> 00:46:00,420
Tom Foss or maybe it gets lucky and find

758
00:45:56,670 --> 00:46:03,450
something so the code is on github I'm

759
00:46:00,420 --> 00:46:08,430
on Twitter I write a little bit about

760
00:46:03,450 --> 00:46:11,370
some problems in my blog I also have the

761
00:46:08,430 --> 00:46:15,359
docker container which you can download

762
00:46:11,370 --> 00:46:18,900
and I'm also in reddit on forcing which

763
00:46:15,360 --> 00:46:22,230
is has all the new fussing technologies

764
00:46:18,900 --> 00:46:27,680
but not much discussion so come and say

765
00:46:22,230 --> 00:46:32,310
hi and I think I'm perfectly in time

766
00:46:27,680 --> 00:46:37,419
surprisingly and available for questions

767
00:46:32,310 --> 00:46:37,419
[Applause]

768
00:46:37,780 --> 00:46:42,160
beautiful hey thank you very much you

769
00:46:40,070 --> 00:46:45,200
got to love the Swiss efficiency on that

770
00:46:42,160 --> 00:46:46,640
yeah so we have a final few minutes I

771
00:46:45,200 --> 00:46:49,819
think available for a bit of questions

772
00:46:46,640 --> 00:46:51,650
so does anyone have any questions that

773
00:46:49,820 --> 00:46:53,420
we would like to have I know it's the

774
00:46:51,650 --> 00:46:56,780
last session I know our brains are

775
00:46:53,420 --> 00:46:57,880
probably dead and full of info anyone

776
00:46:56,780 --> 00:47:01,520
anything

777
00:46:57,880 --> 00:47:04,250
No Oh letting you off easy there our

778
00:47:01,520 --> 00:47:07,460
last talk great port with me off words

779
00:47:04,250 --> 00:47:08,690
just fine awesome okay cool hey guys

780
00:47:07,460 --> 00:47:10,910
thank you very much I guess that

781
00:47:08,690 --> 00:47:12,560
concludes all the talks for this year's

782
00:47:10,910 --> 00:47:15,020
con so thank you very much

783
00:47:12,560 --> 00:47:16,849
we still have a final closing ceremony

784
00:47:15,020 --> 00:47:19,400
happening in around ten minutes now so

785
00:47:16,849 --> 00:47:20,660
please don't go away just yet you can

786
00:47:19,400 --> 00:47:22,970
take a little break now grab a

787
00:47:20,660 --> 00:47:24,200
refreshment and then we should meet back

788
00:47:22,970 --> 00:47:26,000
here in around ten minutes for four

789
00:47:24,200 --> 00:47:27,299
o'clock for the closing ceremony thank

790
00:47:26,000 --> 00:47:32,059
you

791
00:47:27,300 --> 00:47:34,119
[Applause]

792
00:47:32,059 --> 00:47:34,119
you

