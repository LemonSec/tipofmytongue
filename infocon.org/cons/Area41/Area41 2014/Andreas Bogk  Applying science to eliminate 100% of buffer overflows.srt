1
00:00:08,670 --> 00:00:11,060
at thank you my name's on this fall

2
00:00:11,060 --> 00:00:12,929
I am

3
00:00:12,929 --> 00:00:14,240
men

4
00:00:14,240 --> 00:00:14,870
forever

5
00:00:14,870 --> 00:00:18,760
I'm also a principal security architect
it here which is Nokia's maps

6
00:00:18,760 --> 00:00:22,040
business and a.m. you know I've

7
00:00:22,040 --> 00:00:25,599
learned about to Buffalo floor smirked
sometime back

8
00:00:25,599 --> 00:00:29,369
nineties and had a fun exporting that

9
00:00:29,369 --> 00:00:34,239
and became old pretty quickly and
apparently for some people it's not and

10
00:00:34,239 --> 00:00:35,470
people are still doing it

11
00:00:35,470 --> 00:00:39,120
I A rather than into researching

12
00:00:39,120 --> 00:00:43,460
what can you do against box set of no
just browsing your souls called

13
00:00:43,460 --> 00:00:49,059
looking at every line tediously poring
over its trying to find all the box

14
00:00:49,059 --> 00:00:52,339
and a.m. at

15
00:00:52,339 --> 00:00:56,429
a sudden as soon realized back then that
I just don't want to write and a

16
00:00:56,429 --> 00:00:57,920
programming language that has

17
00:00:57,920 --> 00:01:01,190
fulfils and that as an architectural
measure

18
00:01:01,190 --> 00:01:04,909
so the approach I'm taking eg against

19
00:01:04,909 --> 00:01:10,130
security problems is fun of trying to
find the root cause of a

20
00:01:10,130 --> 00:01:14,680
classifier abilities and trying to
address that whole class

21
00:01:14,680 --> 00:01:18,120
vulnerabilities advance by choosing the
right architecture your hockey a

22
00:01:18,120 --> 00:01:21,200
software programming language program
design et cetera et cetera

23
00:01:21,200 --> 00:01:27,290
and knowledge sometimes happens that you
actually have to you see

24
00:01:27,290 --> 00:01:32,320
and a recently discovered a line of
interesting research that looks

25
00:01:32,320 --> 00:01:35,980
into what you can do about we'll go to
existing see softer

26
00:01:35,980 --> 00:01:40,620
and I always wondered about that by the
way so I had the chance to talk about

27
00:01:40,620 --> 00:01:41,630
one of the

28
00:01:41,630 --> 00:01:45,400
MC ling which stand at office John
Gilmore a while back

29
00:01:45,400 --> 00:01:50,430
and assume you know you do realize that
you could have written the standard

30
00:01:50,430 --> 00:01:52,610
innovate that buffer overflows wouldn't
happen

31
00:01:52,610 --> 00:01:56,190
and was like yeah but plus the late 70s
and early 80s

32
00:01:56,190 --> 00:01:59,530
computer spend so fasten didn't have
that much RAM

33
00:01:59,530 --> 00:02:02,790
but be carefully designed programming

34
00:02:02,790 --> 00:02:07,300
negligent baby calf resent the standard
innovate that you can write a compiler

35
00:02:07,300 --> 00:02:12,610
that doesn't have any buffer overflows
and still be standards compliant

36
00:02:12,610 --> 00:02:15,849
so that seems like an interesting
approach to me somewhat

37
00:02:15,849 --> 00:02:19,620
for us this week at at what they're
talking about

38
00:02:19,620 --> 00:02:23,659
am you probably all see what the problem

39
00:02:23,659 --> 00:02:26,790
years right anybody

40
00:02:26,790 --> 00:02:30,610
who sees problem isn't that cold anybody
speaking see here in the audience

41
00:02:30,610 --> 00:02:34,420
some

42
00:02:34,420 --> 00:02:38,940
so for those who don't or too lazy to
raise their arm

43
00:02:38,940 --> 00:02:43,069
I just peek at and you have a buffer
humanistic

44
00:02:43,069 --> 00:02:46,750
size 16 characters and be positive
argument

45
00:02:46,750 --> 00:02:49,930
which is a pointer to a character at the
just copy

46
00:02:49,930 --> 00:02:53,220
into that buffer without checking for
the end

47
00:02:53,220 --> 00:02:57,060
so if you put in something year the
return it string

48
00:02:57,060 --> 00:03:00,450
that's longer than 16 characters you
right

49
00:03:00,450 --> 00:03:04,500
into some area of memory a.m. thats

50
00:03:04,500 --> 00:03:07,989
officially undefined and

51
00:03:07,989 --> 00:03:11,730
you all know how that goes if you writes
a across the stack

52
00:03:11,730 --> 00:03:15,209
you have a stake overflow you can write
into the return value

53
00:03:15,209 --> 00:03:18,540
can use that to trigger code execution
you called

54
00:03:18,540 --> 00:03:21,970
which is what you don't want so hechas

55
00:03:21,970 --> 00:03:26,540
gifts situations like that lot of names
called Buffalo of laws that might call

56
00:03:26,540 --> 00:03:27,169
Tzedek

57
00:03:27,169 --> 00:03:30,180
people also depending on what part of
memory overflow

58
00:03:30,180 --> 00:03:34,200
that might even be called integer
overflows although technically

59
00:03:34,200 --> 00:03:37,889
and the or flowing into Joe only breaks
bones protection

60
00:03:37,889 --> 00:03:41,760
and again you have a memory overflow if
you look at the scientific literature

61
00:03:41,760 --> 00:03:44,910
that looks into how to solve those kind
of problems

62
00:03:44,910 --> 00:03:48,480
they call that spatial memory safety

63
00:03:48,480 --> 00:03:51,829
so because you're writing the wrong Park
of

64
00:03:51,829 --> 00:03:56,799
the memory space and it's a very common
problem

65
00:03:56,799 --> 00:04:01,280
you say get problems like that the heart
lead you remember the glutinous

66
00:04:01,280 --> 00:04:06,019
problem from yesterday and the last ten
thousand also see the

67
00:04:06,019 --> 00:04:10,639
entries but that's not all in terms of
memory security right he also has

68
00:04:10,639 --> 00:04:12,269
situations like that

69
00:04:12,269 --> 00:04:17,010
actually and to differences of the same
kind of problem

70
00:04:17,010 --> 00:04:20,820
like and the allocate some is memory

71
00:04:20,820 --> 00:04:25,390
the that its fried and then the exits
that freed memory

72
00:04:25,390 --> 00:04:29,310
and that you have read again actually
two problems here

73
00:04:29,310 --> 00:04:33,490
first one as a use of the free

74
00:04:33,490 --> 00:04:36,820
vulnerabilities I use a part of memory
that already has been freed

75
00:04:36,820 --> 00:04:40,620
along a properly allocated and year

76
00:04:40,620 --> 00:04:44,990
that's a double free I called free again
which also leads to all kinds of

77
00:04:44,990 --> 00:04:45,860
interesting

78
00:04:45,860 --> 00:04:49,350
effects and as it's not a good thing in
general

79
00:04:49,350 --> 00:04:53,360
so before scientists have a name for
that as well

80
00:04:53,360 --> 00:04:56,390
they call that temporal memory safety

81
00:04:56,390 --> 00:04:59,860
because it's the wrong time you access
the memory it might be valid memory at

82
00:04:59,860 --> 00:05:00,570
some point

83
00:05:00,570 --> 00:05:04,010
but the moment you exit isn't might not
get the

84
00:05:04,010 --> 00:05:08,850
might a be no longer and the accessing
memory that's not OK

85
00:05:08,850 --> 00:05:12,950
saw what can you do about it

86
00:05:12,950 --> 00:05:17,590
and one already mentioned use a safe
language

87
00:05:17,590 --> 00:05:21,520
right don't write see that's the great
programming language that's called

88
00:05:21,520 --> 00:05:24,960
not see and yeah

89
00:05:24,960 --> 00:05:28,070
really folks it's there aren't many
reasons left

90
00:05:28,070 --> 00:05:32,190
actually write see so some other things
I can think about is the right thing

91
00:05:32,190 --> 00:05:36,130
a a Michael control and it has only six
thank you a bunch of RAM

92
00:05:36,130 --> 00:05:39,520
that might be a good excuse to you see
instead of writing assembler

93
00:05:39,520 --> 00:05:43,030
and you might send on it on Nov old cold

94
00:05:43,030 --> 00:05:46,400
that you need to maintain that you can
completely rewriting the sensible time

95
00:05:46,400 --> 00:05:47,990
and you have to do with occasions

96
00:05:47,990 --> 00:05:52,250
that's a reason to you see and other
than that

97
00:05:52,250 --> 00:05:55,570
not much exist may be closer to drive us
and Linux but

98
00:05:55,570 --> 00:06:00,440
you know seriously you operating system
that's written in C++ also it doesn't

99
00:06:00,440 --> 00:06:01,850
exist yet but the bill

100
00:06:01,850 --> 00:06:05,440
doesn't exist anymore and they used to
be. when the other which was completely

101
00:06:05,440 --> 00:06:06,060
written this

102
00:06:06,060 --> 00:06:09,700
so that survey alt but you cannot always
take that failed

103
00:06:09,700 --> 00:06:13,500
Sol the next common think people do is

104
00:06:13,500 --> 00:06:17,800
a like mitigations address space layout
randomization

105
00:06:17,800 --> 00:06:21,070
Data Execution Prevention the canneries
and

106
00:06:21,070 --> 00:06:25,160
they all share the same trade they don't
prevent the memory over on

107
00:06:25,160 --> 00:06:29,480
they don't prevent you from writing one
part of memory all they do

108
00:06:29,480 --> 00:06:33,000
is and give you have eight to make

109
00:06:33,000 --> 00:06:36,520
life for the attack up more interesting
right so

110
00:06:36,520 --> 00:06:39,680
and and and in the good old days

111
00:06:39,680 --> 00:06:43,430
the Stack Overflow you would also a
mistake white and the return address

112
00:06:43,430 --> 00:06:46,350
function will return you could jump to
you but found

113
00:06:46,350 --> 00:06:50,520
called execution these days it's a
little harder that might be a sec Henry

114
00:06:50,520 --> 00:06:51,490
in the bay

115
00:06:51,490 --> 00:06:55,020
and your buffet might not be executed
Bulls live to

116
00:06:55,020 --> 00:06:58,420
built abrupt changes but

117
00:06:58,420 --> 00:07:01,730
all those medications have euronews like
the record for a is

118
00:07:01,730 --> 00:07:06,420
are is usually either finding a piece of
memory that doesn't vary

119
00:07:06,420 --> 00:07:10,640
and on Linux have a look at the syscall
entries they all the same page

120
00:07:10,640 --> 00:07:14,070
and they give you enough just to get
going to courses calls that's all you

121
00:07:14,070 --> 00:07:14,910
need is essentially

122
00:07:14,910 --> 00:07:17,950
and are yet

123
00:07:17,950 --> 00:07:22,210
redlener ability that disclose addresses
of memory that you can then again used

124
00:07:22,210 --> 00:07:23,480
to build a rocket is all

125
00:07:23,480 --> 00:07:26,480
at a Texas with DP and mention

126
00:07:26,480 --> 00:07:30,130
operate on oriented programming it just
put up chains

127
00:07:30,130 --> 00:07:33,330
existing call together and call that

128
00:07:33,330 --> 00:07:36,680
by just setting up a proper stick that
changing the

129
00:07:36,680 --> 00:07:39,980
stick point A to point at the right
place and

130
00:07:39,980 --> 00:07:44,010
secondary sick and Sania redlener
ability you find the value of the

131
00:07:44,010 --> 00:07:44,710
cannery

132
00:07:44,710 --> 00:07:49,170
you write the Henry at the right place
me ago there

133
00:07:49,170 --> 00:07:54,120
in situations you don't even need to get
code execution in the traditional sense

134
00:07:54,120 --> 00:07:57,190
ordered to turn a memory over right into
something useful

135
00:07:57,190 --> 00:08:00,810
so I can suggest I was that guy who won
the Microsoft I

136
00:08:00,810 --> 00:08:05,830
11 hacking contest two techniques one of
them he couldn't disclose on stage

137
00:08:05,830 --> 00:08:10,410
so here at 45 slice that they're
completely blurred alt

138
00:08:10,410 --> 00:08:13,890
and he called the technique by two
points strike and

139
00:08:13,890 --> 00:08:18,820
but I recognize the dialogue on one of
the blood all slides and I think I have

140
00:08:18,820 --> 00:08:20,520
a pretty good idea of what's gone

141
00:08:20,520 --> 00:08:22,529
says he might know a.m.

142
00:08:22,529 --> 00:08:26,059
in Internet Explorer yes security
settings

143
00:08:26,059 --> 00:08:29,309
depending on where that piece of
JavaScript

144
00:08:29,309 --> 00:08:32,819
executed is coming from you might be
able to do more

145
00:08:32,819 --> 00:08:37,289
or less things depending on the security
zone your no

146
00:08:37,289 --> 00:08:40,749
what security zone you in is

147
00:08:40,749 --> 00:08:45,029
some piece of memory what is I can find
the bay

148
00:08:45,029 --> 00:08:49,189
to write to that piece memory boom got
nada just

149
00:08:49,189 --> 00:08:53,709
said flag and I can send JavaScript for
Visual Basic for my page

150
00:08:53,709 --> 00:08:57,680
everything's execute at Mile six.
executed code execution

151
00:08:57,680 --> 00:09:02,709
saw all the mitigations there go to
making life more interesting

152
00:09:02,709 --> 00:09:06,670
taken but in the end they don't and

153
00:09:06,670 --> 00:09:09,990
then that's quite a list of

154
00:09:09,990 --> 00:09:13,100
tools you can use to find memory
problems and

155
00:09:13,100 --> 00:09:17,350
I started looking at them in a
systematic way and try to find auto but

156
00:09:17,350 --> 00:09:18,019
they are

157
00:09:18,019 --> 00:09:21,019
what they can do and probably all

158
00:09:21,019 --> 00:09:24,399
fortable long runs what you do is you
instrumental called

159
00:09:24,399 --> 00:09:28,779
dog execute a bill their additional
checks inserted usually based

160
00:09:28,779 --> 00:09:32,899
dark pages and to make sure you're not
quite into memory and it's supposed to

161
00:09:32,899 --> 00:09:37,959
these days you have at memory sanitizers
indecency in LLVM

162
00:09:37,959 --> 00:09:42,370
again said you compile your problem with
special flag run a test since

163
00:09:42,370 --> 00:09:45,439
and tries to find memory

164
00:09:45,439 --> 00:09:49,399
runs thing as both long grind

165
00:09:49,399 --> 00:09:53,029
and the memory sanitizer use

166
00:09:53,029 --> 00:09:57,009
a technique called object-based
verification

167
00:09:57,009 --> 00:10:02,050
and I'm getting two in the second by
that doesn't cover all of the cases

168
00:10:02,050 --> 00:10:05,750
and so the other ones

169
00:10:05,750 --> 00:10:09,920
those are from attends

170
00:10:09,920 --> 00:10:12,740
to I i talked about that the CE

171
00:10:12,740 --> 00:10:16,710
semantics laws you to actually carry
wrong information to check every point

172
00:10:16,710 --> 00:10:17,220
texas

173
00:10:17,220 --> 00:10:20,410
they are still pointing to memory at

174
00:10:20,410 --> 00:10:27,350
come on units is

175
00:10:27,350 --> 00:10:30,880
for talking too long

176
00:10:30,880 --> 00:10:34,680
and so what what they all try to do

177
00:10:34,680 --> 00:10:39,360
s and take the existing C++ standards

178
00:10:39,360 --> 00:10:42,480
and give a different binary
interpretation

179
00:10:42,480 --> 00:10:46,090
to provide safety against and at

180
00:10:46,090 --> 00:10:49,570
all those have certain shortcomings and

181
00:10:49,570 --> 00:10:53,750
I i'm in the state away at the moment
I'd like to focus

182
00:10:53,750 --> 00:10:57,210
on the object-based at this point based
approach

183
00:10:57,210 --> 00:11:00,380
and just so you can follow him
explaining

184
00:11:00,380 --> 00:11:04,200
I'll be showing am see cold

185
00:11:04,200 --> 00:11:07,390
that you the rights black and

186
00:11:07,390 --> 00:11:10,930
all those fancy tools what they're doing
is instrumentation

187
00:11:10,930 --> 00:11:14,710
they insert extra instructions your
binary that check

188
00:11:14,710 --> 00:11:18,990
whether your point to exit smell it or
not that usually happens on

189
00:11:18,990 --> 00:11:23,120
a 7-11 Arlington on intermediate
representation 11 the compiler

190
00:11:23,120 --> 00:11:27,080
but and most people don't speak LVM
interview

191
00:11:27,080 --> 00:11:30,190
representation fluently so I chose to

192
00:11:30,190 --> 00:11:34,000
not just give that as secord

193
00:11:34,000 --> 00:11:38,640
if you see something in red that's
something the compiler or debug to

194
00:11:38,640 --> 00:11:42,790
inserted into the cold and you have to
think about it said local

195
00:11:42,790 --> 00:11:46,020
thats the back and or the optimizer
stage

196
00:11:46,020 --> 00:11:50,870
but I write a sequel taken following
explained saw

197
00:11:50,870 --> 00:11:54,930
the object based approach what men want
us to win what the memory sanitizer

198
00:11:54,930 --> 00:11:57,980
centers doing as

199
00:11:57,980 --> 00:12:01,990
essentially this I I use the pointer
somewhere I dereferencing pointer

200
00:12:01,990 --> 00:12:03,420
either for

201
00:12:03,420 --> 00:12:06,730
for Reid a ride and the code

202
00:12:06,730 --> 00:12:10,519
inserts a check that looks is the
address

203
00:12:10,519 --> 00:12:13,750
poisoned on all if it's poison arose
report

204
00:12:13,750 --> 00:12:18,300
you can think about it as the Met that
for every address in the system just

205
00:12:18,300 --> 00:12:20,740
remembers that is correct the El Cid

206
00:12:20,740 --> 00:12:24,839
solving the problem starts up everything
starts out as being poisoned

207
00:12:24,839 --> 00:12:29,570
you say my love on an area and that part
memory will be clear to me said that's

208
00:12:29,570 --> 00:12:30,880
okay so every excess

209
00:12:30,880 --> 00:12:34,170
in there is OK and then you free the
memory again

210
00:12:34,170 --> 00:12:38,910
again memory is poised this actually
finds box

211
00:12:38,910 --> 00:12:42,839
so if you have never used one right or a
memory sanitize on your sis of

212
00:12:42,839 --> 00:12:47,209
you've probably done something wrong
because and at five bucks if you

213
00:12:47,209 --> 00:12:51,000
a overflow a buffer right and the stuff
will detect

214
00:12:51,000 --> 00:12:55,390
if you exit memory after your freedom
that stuff will detect

215
00:12:55,390 --> 00:12:59,050
but they're obviously situations that
the stuff not detect

216
00:12:59,050 --> 00:13:02,279
and but easy to understand example

217
00:13:02,279 --> 00:13:06,779
is and interest structural safety so I
have a struct

218
00:13:06,779 --> 00:13:10,350
that has ID and an account balance for
my bank

219
00:13:10,350 --> 00:13:13,750
soul that's my account number say

220
00:13:13,750 --> 00:13:18,769
and thats want money I have in my bank
Sol

221
00:13:18,769 --> 00:13:21,899
been allocated structure like that the
complete

222
00:13:21,899 --> 00:13:25,240
things okay so from here to hear

223
00:13:25,240 --> 00:13:29,839
ordinary is marked as no longer poisons
but

224
00:13:29,839 --> 00:13:33,070
if I has a piece of code

225
00:13:33,070 --> 00:13:36,350
that overflows this buffer I'm
overflowing

226
00:13:36,350 --> 00:13:39,990
in a different part of the structure
that still

227
00:13:39,990 --> 00:13:43,550
not pause still properly allocated
memory sold online

228
00:13:43,550 --> 00:13:48,290
want to take that memories in sizable
detected and still I can obviously

229
00:13:48,290 --> 00:13:50,519
exploit that to change the amount of
money

230
00:13:50,519 --> 00:13:54,750
and which I think you agree is a bad
thing saw

231
00:13:54,750 --> 00:13:58,970
limited approach the other approach

232
00:13:58,970 --> 00:14:02,399
for every point that we carry around

233
00:14:02,399 --> 00:14:06,199
you remember the base address of the
object pointed to

234
00:14:06,199 --> 00:14:09,620
beginning and you remember a whole big

235
00:14:09,620 --> 00:14:10,970
the memory area

236
00:14:10,970 --> 00:14:14,620
it is pointing to saw the same ol

237
00:14:14,620 --> 00:14:17,790
often make get back

238
00:14:17,790 --> 00:14:21,160
address 100 and a in all and

239
00:14:21,160 --> 00:14:25,360
21 so we have appointed as 100 if the
base value of 100

240
00:14:25,360 --> 00:14:29,360
India won't have to hunt butanol go to
that point and

241
00:14:29,360 --> 00:14:33,260
at fifty what happens you have a pointer
value of 150

242
00:14:33,260 --> 00:14:36,620
pointing right in the middle of the era
which still has a base

243
00:14:36,620 --> 00:14:41,690
108 bold of two hundred attached say no
it's still a valid point and try to

244
00:14:41,690 --> 00:14:45,800
address it if I add another hundred my
point %uh values 250

245
00:14:45,800 --> 00:14:48,940
basis a hundred bond is 200

246
00:14:48,940 --> 00:14:52,330
Savannah try to right now I know that
this phase

247
00:14:52,330 --> 00:14:56,400
supplied a number of the other tools I
have listed their use

248
00:14:56,400 --> 00:15:00,100
and this pointer based approach at

249
00:15:00,100 --> 00:15:03,420
does have a number of shortcomings so

250
00:15:03,420 --> 00:15:08,150
suddenly your point %uh size changes
which means that you're struck play old

251
00:15:08,150 --> 00:15:08,960
might change

252
00:15:08,960 --> 00:15:12,470
some of the tools implement something
like that

253
00:15:12,470 --> 00:15:17,660
but the only able to translate the whole
c:\program as one big piece

254
00:15:17,660 --> 00:15:21,860
all yes of completes of a sec must be in
one single see file

255
00:15:21,860 --> 00:15:25,730
which obviously translate not being
practically

256
00:15:25,730 --> 00:15:30,280
usable so at look at all that

257
00:15:30,280 --> 00:15:33,950
and the only the a existing project that

258
00:15:33,950 --> 00:15:37,300
fulfilled all the criteria i wanted to
have to actually take that

259
00:15:37,300 --> 00:15:40,400
to a production system lots of on CTS

260
00:15:40,400 --> 00:15:43,580
consists of two parts: obviously cause

261
00:15:43,580 --> 00:15:47,450
on 22 PHD's like that is in academia and

262
00:15:47,450 --> 00:15:51,630
softphones cares about and special and
safety

263
00:15:51,630 --> 00:15:55,080
CTS cuz about temporal safety it uses

264
00:15:55,080 --> 00:15:58,100
that point us so use the model that
keeps track

265
00:15:58,100 --> 00:16:01,290
the basis upon value but its uses
so-called

266
00:16:01,290 --> 00:16:05,300
destroyed had pointers what does that
mean it means that the basic

267
00:16:05,300 --> 00:16:08,720
bold value I kept in a different area of
memory foam

268
00:16:08,720 --> 00:16:12,480
all the rest that means that just
structurally or doesn't change

269
00:16:12,480 --> 00:16:17,250
which is everybody knows with maintain
see problem with its binary data from

270
00:16:17,250 --> 00:16:18,400
disk is a huge

271
00:16:18,400 --> 00:16:18,670
min

272
00:16:18,670 --> 00:16:22,200
if you don't have to adapt structures
that Paul a park in binary

273
00:16:22,200 --> 00:16:27,720
so it's and it's usable for real good
call that if you see struck definitions

274
00:16:27,720 --> 00:16:28,490
to declare by

275
00:16:28,490 --> 00:16:31,940
reform which which is a bad thing but
so-called dust

276
00:16:31,940 --> 00:16:34,950
it comes and that's very interesting

277
00:16:34,950 --> 00:16:38,200
with a proof of correctness and that

278
00:16:38,200 --> 00:16:41,930
it will catch 100 percent of the Buffalo
Phil's so every

279
00:16:41,930 --> 00:16:45,420
type of memory illegal memory
accessibility caught

280
00:16:45,420 --> 00:16:48,940
according to a pretty simple semantic
model

281
00:16:48,940 --> 00:16:52,020
of what pointers and what see so various

282
00:16:52,020 --> 00:16:55,970
at that the catch to it but I'm coming
to that later

283
00:16:55,970 --> 00:16:59,910
and it's implemented as an LVN optimize
up outside

284
00:16:59,910 --> 00:17:03,520
plugs right into the LLVM compiler
everything that's compatible with

285
00:17:03,520 --> 00:17:09,460
the M is compatible the soft on CTS and

286
00:17:09,460 --> 00:17:13,740
yep margins of that

287
00:17:13,740 --> 00:17:17,860
and it supports separate populations we
can keep your old file structure

288
00:17:17,860 --> 00:17:19,130
lightweight structure you can

289
00:17:19,130 --> 00:17:22,290
compile a library yes program

290
00:17:22,290 --> 00:17:28,600
at completely covers all the cases it
meant a source code compatibility you

291
00:17:28,600 --> 00:17:30,280
can just put in sequel their

292
00:17:30,280 --> 00:17:34,540
doesn't need any kind of special
invitation or something and also comes

293
00:17:34,540 --> 00:17:35,050
with the

294
00:17:35,050 --> 00:17:39,240
low overhead saw that's probably one
question you might have

295
00:17:39,240 --> 00:17:42,550
I'm what does low overhead need I
stopped caring role

296
00:17:42,550 --> 00:17:46,260
bigger point us start checking point as
all the time I'd pay

297
00:17:46,260 --> 00:17:49,900
the runtime over right and so turns out
that

298
00:17:49,900 --> 00:17:54,370
yourself get five slow by a factor of
two so you getting hard the speeches of

299
00:17:54,370 --> 00:17:55,320
it before

300
00:17:55,320 --> 00:17:59,560
after turning on that's a phone CTS
model that enables

301
00:17:59,560 --> 00:18:03,820
all the bottles called which i think is
a reasonable trade-off

302
00:18:03,820 --> 00:18:07,210
mine people run that some was written in
Ruby so

303
00:18:07,210 --> 00:18:11,000
performance doesn't seem to be a problem
anymore or just switch on 50 more

304
00:18:11,000 --> 00:18:11,990
instances on

305
00:18:11,990 --> 00:18:16,680
a double yes a I can live with the fact
of two

306
00:18:16,680 --> 00:18:21,000
for not being spotted so

307
00:18:21,000 --> 00:18:23,450
or doesn't look in detail at

308
00:18:23,450 --> 00:18:27,540
already talked about the base in bond
value

309
00:18:27,540 --> 00:18:31,049
had pointer so if you dereferencing
pointer

310
00:18:31,049 --> 00:18:34,120
what the compiler heads is a

311
00:18:34,120 --> 00:18:37,530
a check there pointer value base

312
00:18:37,530 --> 00:18:41,600
bone the size of the object that's the
references hassen

313
00:18:41,600 --> 00:18:44,660
you obviously want to take care of the
size to because he might be at

314
00:18:44,660 --> 00:18:48,150
very last bite the buffer which is still
a valid address

315
00:18:48,150 --> 00:18:52,450
and try to read is 64 bit value alright
to 64 bit value which will trigger a

316
00:18:52,450 --> 00:18:53,610
buffer overflow

317
00:18:53,610 --> 00:18:57,809
salt that needs to be taken into account
and

318
00:18:57,809 --> 00:19:01,110
check this incident like this so if

319
00:19:01,110 --> 00:19:04,240
if the pointer is less than the base
value are

320
00:19:04,240 --> 00:19:07,559
if pointer plus the sizable thing

321
00:19:07,559 --> 00:19:10,799
as about bone value at

322
00:19:10,799 --> 00:19:14,169
you bought so

323
00:19:14,169 --> 00:19:22,340
anybody who sees the problem that

324
00:19:22,340 --> 00:19:26,289
your air human and internets saw

325
00:19:26,289 --> 00:19:29,610
that's a proper they hadn't proven
correct the only proof their

326
00:19:29,610 --> 00:19:33,029
cement model correct that will trigger a
100 percent our butts

327
00:19:33,029 --> 00:19:37,320
properly called the check function they
neglected to find the

328
00:19:37,320 --> 00:19:41,309
integer overflow the check function so
my first contribution to the project was

329
00:19:41,309 --> 00:19:42,610
to actually make it work

330
00:19:42,610 --> 00:19:46,570
by adding a check for you

331
00:19:46,570 --> 00:19:49,570
yet

332
00:19:49,570 --> 00:19:52,640
so don't trust proves

333
00:19:52,640 --> 00:19:59,010
some tests and so the base in bond value
need to come from somewhere

334
00:19:59,010 --> 00:20:02,260
what actually happens inside the VM

335
00:20:02,260 --> 00:20:05,840
IRS that special violence generate its

336
00:20:05,840 --> 00:20:08,990
I have a viable PTR and a

337
00:20:08,990 --> 00:20:12,870
an additional PTI basically a ball and
viable

338
00:20:12,870 --> 00:20:17,159
has generated and initialized pointer
value

339
00:20:17,159 --> 00:20:20,429
and point up to size up there

340
00:20:20,429 --> 00:20:24,340
so I know by by law upon and

341
00:20:24,340 --> 00:20:28,039
if mile okay of course he said bone you
also all

342
00:20:28,039 --> 00:20:31,960
so that the check fails if I ever tried
to exit and I'll point out that carry

343
00:20:31,960 --> 00:20:36,529
a No all that and soul the check your
favorite problem

344
00:20:36,529 --> 00:20:41,049
couple of more I'm situations that we
need to consider

345
00:20:41,049 --> 00:20:44,880
not only half location some steak
location and

346
00:20:44,880 --> 00:20:48,510
the second occasion case a.m. yet again
I take place

347
00:20:48,510 --> 00:20:53,679
at this point that base by take the size
of the object plus the base and getting

348
00:20:53,679 --> 00:20:59,080
its pretty straightforward and

349
00:20:59,080 --> 00:21:02,850
it gets a little bit more interesting
but not by much

350
00:21:02,850 --> 00:21:06,409
if you doing point mythic and

351
00:21:06,409 --> 00:21:10,279
you take the pointer editor to it all
you take the address

352
00:21:10,279 --> 00:21:13,529
often object array which is say

353
00:21:13,529 --> 00:21:18,500
symmetrically and the basic the bone
value to propagate

354
00:21:18,500 --> 00:21:21,610
so the pointer that you're driving the
new pointer from

355
00:21:21,610 --> 00:21:25,549
propagate space its bone value you
pointed

356
00:21:25,549 --> 00:21:28,730
this of course means that and you can do

357
00:21:28,730 --> 00:21:32,799
things that are perfectly legal by the C
stand like can take

358
00:21:32,799 --> 00:21:36,250
a pointer to an Arial size 100 you can
add

359
00:21:36,250 --> 00:21:39,419
300 subject 250 again

360
00:21:39,419 --> 00:21:42,740
and you have an intermediate point out
that doesn't point to a valid memory but

361
00:21:42,740 --> 00:21:46,530
that's totally okay as long as you don't
see references so after all

362
00:21:46,530 --> 00:21:49,940
doing all the pointer arithmetic you end
up back inside the area and then

363
00:21:49,940 --> 00:21:55,429
exit that's okay at yes

364
00:21:55,429 --> 00:21:59,030
a special case and that takes into
account the problem of

365
00:21:59,030 --> 00:22:02,159
into structural overflow so if I take

366
00:22:02,159 --> 00:22:06,100
the address of some object inside some
other object like that

367
00:22:06,100 --> 00:22:10,650
gender struct and I need to do a bit of
Nck collation

368
00:22:10,650 --> 00:22:14,179
to a find the right basic on

369
00:22:14,179 --> 00:22:17,210
you too narrow so you're not just
propagating

370
00:22:17,210 --> 00:22:20,309
from the base point at which is the
complete structure the narrow the

371
00:22:20,309 --> 00:22:21,059
address range

372
00:22:21,059 --> 00:22:24,440
just the object the of to prevent

373
00:22:24,440 --> 00:22:29,350
I'm the overflow case that also works

374
00:22:29,350 --> 00:22:32,480
for you know getting address often
element

375
00:22:32,480 --> 00:22:36,850
inside and area inside instruct you have
to take care of that

376
00:22:36,850 --> 00:22:42,860
so is a problem

377
00:22:42,860 --> 00:22:45,990
as I said he had just joined

378
00:22:45,990 --> 00:22:49,760
set point amala soul when I have a

379
00:22:49,760 --> 00:22:53,200
pointer value in memory and I rights to
it

380
00:22:53,200 --> 00:22:56,610
only writes that single pointer and the
very back

381
00:22:56,610 --> 00:23:00,460
only getting better that point what they
do with the basic bone failure

382
00:23:00,460 --> 00:23:04,240
inside the function they kept that
especially the island's

383
00:23:04,240 --> 00:23:07,280
and if right to point out to

384
00:23:07,280 --> 00:23:10,740
memory I no longer can do that so

385
00:23:10,740 --> 00:23:14,130
what we do is a

386
00:23:14,130 --> 00:23:17,620
men take a pointer read from memory

387
00:23:17,620 --> 00:23:20,360
I A not up

388
00:23:20,360 --> 00:23:24,600
the point at a table and in the table
the base in the bone

389
00:23:24,600 --> 00:23:27,910
values 17 separate data structure like

390
00:23:27,910 --> 00:23:33,130
put in the point to address and getting
back basin of course it looks the other

391
00:23:33,130 --> 00:23:34,080
way around for

392
00:23:34,080 --> 00:23:37,410
storing meta-data to ram moment rights

393
00:23:37,410 --> 00:23:40,970
pointer value somewhere like you and

394
00:23:40,970 --> 00:23:44,750
the basic bone value inside my table a

395
00:23:44,750 --> 00:23:48,150
are initialized the basic bone values
that I carry wrong

396
00:23:48,150 --> 00:23:55,820
from of course that's not terribly
efficient

397
00:23:55,820 --> 00:23:59,710
so implementation you a redneck tree
which is kind of a que

398
00:23:59,710 --> 00:24:04,270
but most of the time it's just better to
keep those values around instead of

399
00:24:04,270 --> 00:24:08,310
storing and touching them again so in
the case of function calls

400
00:24:08,310 --> 00:24:11,350
what happens is that the

401
00:24:11,350 --> 00:24:14,870
functions and I write a function that
takes a point as

402
00:24:14,870 --> 00:24:17,940
argument and the compiler internally
chain

403
00:24:17,940 --> 00:24:22,080
that to a function that takes the
argument

404
00:24:22,080 --> 00:24:25,130
yes means the basic bone values

405
00:24:25,130 --> 00:24:30,030
become extra arguments to the function
for every point the possum called sites

406
00:24:30,030 --> 00:24:33,660
the base in the bond value which I have
around because they have a point

407
00:24:33,660 --> 00:24:39,100
a propagating that function so that
available that saw actually having to

408
00:24:39,100 --> 00:24:42,410
and lookup values in the table is
something that cause

409
00:24:42,410 --> 00:24:47,420
rarely doesn't refute rumors that the
structures happens cell

410
00:24:47,420 --> 00:24:50,590
that couple whose and sear I'm

411
00:24:50,590 --> 00:24:53,820
which I won't go into much detail men
poppy is

412
00:24:53,820 --> 00:24:57,760
and implemented primitive functions side
BMC ft

413
00:24:57,760 --> 00:25:01,120
day you have to detect amen copy call
and

414
00:25:01,120 --> 00:25:05,230
at special checks to that and global
violence need

415
00:25:05,230 --> 00:25:08,450
initialization done obviously and

416
00:25:08,450 --> 00:25:11,510
function pointers need special care

417
00:25:11,510 --> 00:25:15,860
you end up not being able to create
pointers from indigenous

418
00:25:15,860 --> 00:25:19,050
that's a very interesting thing trick
its a

419
00:25:19,050 --> 00:25:22,930
only some people in all these days
because because usually have enough RAM

420
00:25:22,930 --> 00:25:23,850
and computers

421
00:25:23,850 --> 00:25:27,560
these days there's a trick to implement
doubly linked list

422
00:25:27,560 --> 00:25:29,580
using only one point %uh value

423
00:25:29,580 --> 00:25:32,840
for every element that this that's like
this

424
00:25:32,840 --> 00:25:36,610
you have a pointer to the first element
never pointed to the last

425
00:25:36,610 --> 00:25:40,400
element and inside singer feel in

426
00:25:40,400 --> 00:25:43,790
the structure that is the element linked
list you take

427
00:25:43,790 --> 00:25:47,090
for what point or X or the backlog
pointer

428
00:25:47,090 --> 00:25:50,810
so when you coming in from one site you
maintain the pointer

429
00:25:50,810 --> 00:25:55,410
that you can invest X or to value in the
field and you getting

430
00:25:55,410 --> 00:25:58,660
next for 1.0 you said X it connects for

431
00:25:58,660 --> 00:26:02,320
et cetera et cetera the coming in from
the back you can also do that to take

432
00:26:02,320 --> 00:26:03,100
the pointer

433
00:26:03,100 --> 00:26:06,360
points last meant ex Corde in getting

434
00:26:06,360 --> 00:26:09,410
next Picnic Point excellent in at cetera
et cetera et cetera

435
00:26:09,410 --> 00:26:13,550
so new trick unfortunately completely
breaks the stuff so that's one of the

436
00:26:13,550 --> 00:26:15,290
situations that you cannot be put to use

437
00:26:15,290 --> 00:26:18,460
and iight say 30 anyways

438
00:26:18,460 --> 00:26:23,030
using much at you have to a Newcastle
Union sifted

439
00:26:23,030 --> 00:26:26,450
and a box that's all the paper in case
you're interested you can look at

440
00:26:26,450 --> 00:26:30,670
cell the FN

441
00:26:30,670 --> 00:26:34,070
the special case pretty much so for the
Lord's point %uh stores

442
00:26:34,070 --> 00:26:38,060
that point texas the reference for the
Terrapins

443
00:26:38,060 --> 00:26:41,310
right but in only two covers the
temporal case

444
00:26:41,310 --> 00:26:45,020
and the approach MCTS

445
00:26:45,020 --> 00:26:49,270
part responsible for temporal safety
takes is again one of it

446
00:26:49,270 --> 00:26:52,760
pointers so again you've appointed

447
00:26:52,760 --> 00:26:56,310
and you get to your values the key lock
address

448
00:26:56,310 --> 00:26:59,920
the idea your is that the key

449
00:26:59,920 --> 00:27:04,620
is unique every time I call the next few
values and commitments or

450
00:27:04,620 --> 00:27:08,750
for a 3-pointer I remember

451
00:27:08,750 --> 00:27:13,610
a.m. which my luck call that laws by
incrementing a unique value

452
00:27:13,610 --> 00:27:16,800
and i also at that place

453
00:27:16,800 --> 00:27:20,570
memory which is called a lot the end
okay and

454
00:27:20,570 --> 00:27:23,790
i right the key/value to that not
address

455
00:27:23,790 --> 00:27:26,850
and also remembered in this again puny

456
00:27:26,850 --> 00:27:30,120
that so

457
00:27:30,120 --> 00:27:32,770
again at point A to keep around a

458
00:27:32,770 --> 00:27:36,280
index value he keep around a pointer

459
00:27:36,280 --> 00:27:41,150
to some place in memory which we call a
lock the initial is called a key

460
00:27:41,150 --> 00:27:45,310
and the key in the lock are initialized
the same value

461
00:27:45,310 --> 00:27:49,880
on model know when he called free

462
00:27:49,880 --> 00:27:53,970
the crucial part is this year

463
00:27:53,970 --> 00:27:57,260
to the lock address the right is special

464
00:27:57,260 --> 00:28:01,340
invalid key Bay so if you have a point
to our own

465
00:28:01,340 --> 00:28:04,450
somewhere you still have a copy of PTR
some

466
00:28:04,450 --> 00:28:07,870
and it still has the same she value

467
00:28:07,870 --> 00:28:11,480
it still points to the same lock but

468
00:28:11,480 --> 00:28:16,150
at the lot address know we have and
invalid value so

469
00:28:16,150 --> 00:28:19,300
excess 2.0 looks like that

470
00:28:19,300 --> 00:28:23,450
the check and the key is

471
00:28:23,450 --> 00:28:26,720
equal to the value at the lock address

472
00:28:26,720 --> 00:28:31,150
or not which is the case after the call
my lock and they've stopped being the

473
00:28:31,150 --> 00:28:31,670
case

474
00:28:31,670 --> 00:28:35,250
after the call free so in that case

475
00:28:35,250 --> 00:28:38,940
is to people so this allows us to tell

476
00:28:38,940 --> 00:28:43,710
leather a pointer points to some
currently allocated piece of memory

477
00:28:43,710 --> 00:28:47,810
and you can think about situations like

478
00:28:47,810 --> 00:28:51,000
I and putting 3m locating and

479
00:28:51,000 --> 00:28:54,860
object the same size right after wards
thats

480
00:28:54,860 --> 00:28:58,660
comes back send address soul 2.0 value
send address

481
00:28:58,660 --> 00:29:02,620
day now have different keyboards so

482
00:29:02,620 --> 00:29:07,600
and even though the point evaluates the
same in a later excess that memory using

483
00:29:07,600 --> 00:29:08,130
the old

484
00:29:08,130 --> 00:29:13,010
pointer its at the trigger false even
though technically I'm pointing to a

485
00:29:13,010 --> 00:29:14,030
valid memory

486
00:29:14,030 --> 00:29:17,070
of a the rights hi

487
00:29:17,070 --> 00:29:20,710
it's from the wrong time so that aborts

488
00:29:20,710 --> 00:29:23,560
again

489
00:29:23,560 --> 00:29:28,520
the need to propagate the key in the
lock address in case in point arithmetic

490
00:29:28,520 --> 00:29:33,900
sad thing here just copy that and

491
00:29:33,900 --> 00:29:37,060
yet again problem of

492
00:29:37,060 --> 00:29:42,360
I'm below 2.0 from memory you have to
get the key in the lock address from

493
00:29:42,360 --> 00:29:47,870
special table we maintain them and of
course the right to point it to memory

494
00:29:47,870 --> 00:29:51,450
you have to read no the the key in the
lock address

495
00:29:51,450 --> 00:29:54,450
for that point in our table

496
00:29:54,450 --> 00:29:58,680
yeah global seem to be an

497
00:29:58,680 --> 00:30:03,110
law with all this violence in the case
you the just all getting the same

498
00:30:03,110 --> 00:30:10,800
lucky angler will look at this for the
key in there's a catch to that approach

499
00:30:10,800 --> 00:30:14,100
and that this you might remember of the

500
00:30:14,100 --> 00:30:18,530
free is called the lock value is
invalidated

501
00:30:18,530 --> 00:30:21,870
what happens if you have multiple
threads

502
00:30:21,870 --> 00:30:26,480
and you have a let's get scheduled right

503
00:30:26,480 --> 00:30:31,170
between the free and invalidation of the
address you run into the situation

504
00:30:31,170 --> 00:30:34,290
there I'm Akii

505
00:30:34,290 --> 00:30:37,930
value inside the lock still the right
one

506
00:30:37,930 --> 00:30:41,970
but free has already been called saw
threats don't work yet

507
00:30:41,970 --> 00:30:45,440
but frankly shit status evil its

508
00:30:45,440 --> 00:30:50,290
the salsa a lot of subtle boxing
confusion if she ever tried to catch a

509
00:30:50,290 --> 00:30:52,220
race condition you know what I'm talking
about

510
00:30:52,220 --> 00:30:56,120
yes and much for try to trace the memory
corruption

511
00:30:56,120 --> 00:30:59,930
ship family setting Ag know what I'm
talking about there's a reason

512
00:30:59,930 --> 00:31:03,370
like doesn't know shit state between
threats that is that

513
00:31:03,370 --> 00:31:07,590
message passing just much easier to
understand much easier to reason about

514
00:31:07,590 --> 00:31:10,790
the same if you look at former methods
a.m.

515
00:31:10,790 --> 00:31:14,460
its right to verify the correctness of a
program that's

516
00:31:14,460 --> 00:31:17,650
of easy in the singer Freddie case

517
00:31:17,650 --> 00:31:21,400
but in the market for the case you have
to consider the temptation

518
00:31:21,400 --> 00:31:24,990
all instructions all possible
instructions that could be active

519
00:31:24,990 --> 00:31:29,540
the same time in all the threats you get
a minute or explosion of possible states

520
00:31:29,540 --> 00:31:31,539
soul

521
00:31:31,539 --> 00:31:34,809
should say to see and

522
00:31:34,809 --> 00:31:38,339
you might ask is that i've been talking
about the ticket and product performs

523
00:31:38,339 --> 00:31:41,779
for quite some time did i do my own
making and answer is yes I did

524
00:31:41,779 --> 00:31:46,159
did to my phone hacking not only fix
that check also started

525
00:31:46,159 --> 00:31:50,559
at trying to scan the top because it
wasn't too bad the university project

526
00:31:50,559 --> 00:31:53,839
youths have a the

527
00:31:53,839 --> 00:31:58,080
you don't literally Donald a modified
lol the entry

528
00:31:58,080 --> 00:32:02,539
some code has been patched in at that
wasn't even connected to the main

529
00:32:02,539 --> 00:32:05,700
compile a new which came its on top lead
to execute to

530
00:32:05,700 --> 00:32:09,379
that would work on a VM intermediate
representation

531
00:32:09,379 --> 00:32:13,049
files to do its job at what's have

532
00:32:13,049 --> 00:32:18,509
and calls to Lipsy hard cold inside the
compiler plugin

533
00:32:18,509 --> 00:32:22,599
so if you had external libraries that
vannatter instrument

534
00:32:22,599 --> 00:32:26,179
the texts you need to translate between
you know passing the values

535
00:32:26,179 --> 00:32:30,210
one value to the function if you link to
Lipsy expects one that even a pass a

536
00:32:30,210 --> 00:32:30,710
pointer

537
00:32:30,710 --> 00:32:34,019
have to do that some also that 2000

538
00:32:34,019 --> 00:32:39,339
lines long this function names need to
be ready came at runtime lie with the

539
00:32:39,339 --> 00:32:42,979
actually rep that stuff et cetera et
cetera so

540
00:32:42,979 --> 00:32:46,919
and I figured that that is an approach
that would scale

541
00:32:46,919 --> 00:32:51,509
and so implemented a function attributes

542
00:32:51,509 --> 00:32:54,570
that law you for every function to turn
on

543
00:32:54,570 --> 00:32:58,149
and tone of the calling conventions and
turn-on and turn-off

544
00:32:58,149 --> 00:33:01,539
in search of checks that and then

545
00:33:01,539 --> 00:33:05,549
move to free the ISI why because
previous the

546
00:33:05,549 --> 00:33:10,799
a system there executed boats he say
make built world writing compliance

547
00:33:10,799 --> 00:33:15,749
everything from scratch its able it's
possible to compile that using LLVM

548
00:33:15,749 --> 00:33:20,059
from scratch say the code base could
make sure that every single line

549
00:33:20,059 --> 00:33:23,519
would go through and that instrument to
compile the twins

550
00:33:23,519 --> 00:33:25,350
checks for

551
00:33:25,350 --> 00:33:28,410
a bottle everything so the

552
00:33:28,410 --> 00:33:33,850
a I acquired a friend who missed the
previous dnt want that

553
00:33:33,850 --> 00:33:38,370
what to the Lipsy and cemented the
function that needed to be instrumented

554
00:33:38,370 --> 00:33:43,690
like system calls and like its mending
the monologue so because my lip and free

555
00:33:43,690 --> 00:33:45,260
obviously have to do magic things

556
00:33:45,260 --> 00:33:48,690
behind-the-scenes and generate the
values

557
00:33:48,690 --> 00:33:51,830
and that he did be deleted

558
00:33:51,830 --> 00:33:55,140
and on his ass rappers and a

559
00:33:55,140 --> 00:33:58,450
the ended up in the situation you're a
proof-of-concept

560
00:33:58,450 --> 00:34:01,930
no group so they can compile see lottery
and

561
00:34:01,930 --> 00:34:04,940
compile and link it s problem against
let's see library

562
00:34:04,940 --> 00:34:08,740
and run it and successfully

563
00:34:08,740 --> 00:34:11,850
be able to make system called execute
called and

564
00:34:11,850 --> 00:34:15,320
detect of so we have a evoking
proof-of-concept

565
00:34:15,320 --> 00:34:18,910
soul

566
00:34:18,910 --> 00:34:23,790
what I'm to see obviously want to see

567
00:34:23,790 --> 00:34:28,990
that an action yes

568
00:34:28,990 --> 00:34:35,179
that so here we go

569
00:34:35,179 --> 00:34:36,580
the other previously system

570
00:34:36,580 --> 00:34:39,580
a small test program

571
00:34:39,580 --> 00:34:43,090
has problem

572
00:34:43,090 --> 00:34:47,409
as i've seen for yet the buffet size 16
and

573
00:34:47,409 --> 00:34:51,580
argument is possible that function and
the copy that argument

574
00:34:51,580 --> 00:34:54,850
to the buffet with all checking the army
past you

575
00:34:54,850 --> 00:34:58,040
and his main function soulmate

576
00:34:58,040 --> 00:35:02,050
a takes the first month an argument

577
00:35:02,050 --> 00:35:05,470
pass that as an argument to the function
foo which poppies

578
00:35:05,470 --> 00:35:11,500
to the so you can call that

579
00:35:11,500 --> 00:35:16,720
think about what would you expect to
happen if I press return all

580
00:35:16,720 --> 00:35:21,090
so I didn't

581
00:35:21,090 --> 00:35:24,380
at any mother arguments so you you votes

582
00:35:24,380 --> 00:35:28,180
expect the problem to trash because X's
not point to because

583
00:35:28,180 --> 00:35:31,580
X's a non-existing argument from mine
right

584
00:35:31,580 --> 00:35:35,320
saw if I saw that not all be accessing

585
00:35:35,320 --> 00:35:39,060
hockey of monarchy offline as about .2
because interest

586
00:35:39,060 --> 00:35:44,000
oculus should see in our pointer
exception so but instead of a crash

587
00:35:44,000 --> 00:35:47,770
we actually get the debugging output
from soft on CTS

588
00:35:47,770 --> 00:35:50,869
that's quickly detects you have a point

589
00:35:50,869 --> 00:35:54,980
base ball and point you 0 it's not okay
to read that

590
00:35:54,980 --> 00:35:59,490
so from Safety Board iffy to pass

591
00:35:59,490 --> 00:36:03,710
in a small argument that's a football
what would be expected

592
00:36:03,710 --> 00:36:07,420
you would expect naw access to a Cuban

593
00:36:07,420 --> 00:36:11,000
should work right for by 6 buy something

594
00:36:11,000 --> 00:36:14,609
let's say seven form terminating 0 16

595
00:36:14,609 --> 00:36:17,750
you would expect that to simply for at

596
00:36:17,750 --> 00:36:21,510
it's a vigorous saw one expect

597
00:36:21,510 --> 00:36:26,600
what happens be poss a much too long
argument

598
00:36:26,600 --> 00:36:29,380
that again

599
00:36:29,380 --> 00:36:32,790
sup on CTS correctly detect memory
safety violation

600
00:36:32,790 --> 00:36:35,990
and aborts a problem so you're

601
00:36:35,990 --> 00:36:49,660
the most successful okay

602
00:36:49,660 --> 00:36:53,020
so and if you want to look at that
yourself

603
00:36:53,020 --> 00:36:57,190
it's up on get up don't expect to be
able to compile it but not without

604
00:36:57,190 --> 00:37:00,340
asking me again on what precisely to do
because it's still

605
00:37:00,340 --> 00:37:04,500
the better session concert stage and a
number of books

606
00:37:04,500 --> 00:37:07,990
still in there that I'm discussing the
the origin of thought the plugin

607
00:37:07,990 --> 00:37:11,260
and yeah like to use them is

608
00:37:11,260 --> 00:37:15,599
thank goodness for doing that work with
me on FreeBSD and the

609
00:37:15,599 --> 00:37:20,080
cell phone city escort office for a very
quick questions

610
00:37:20,080 --> 00:37:23,710
explained to me everything and for prime
Saskatoon community

611
00:37:23,710 --> 00:37:28,550
so I thanks for listening and if you
have questions I P about

612
00:37:28,550 --> 00:37:37,460
happy to answer them

613
00:37:37,460 --> 00:37:46,740
thank you address you have questions

614
00:37:46,740 --> 00:37:49,150
heavenly view of talk about it

615
00:37:49,150 --> 00:37:52,270
why do you dui dui Hill

616
00:37:52,270 --> 00:37:55,490
p.m. in nineteen TCC TCC

617
00:37:55,490 --> 00:37:58,740
the plant develop moon or

618
00:37:58,740 --> 00:38:02,500
these anyway the bloody well

619
00:38:02,500 --> 00:38:06,900
the plugin was already written for LVM
so that's why I

620
00:38:06,900 --> 00:38:10,200
a kind of had to use

621
00:38:10,200 --> 00:38:14,250
the incident CCC so it would have been a
lot of 2 reviews and GCC

622
00:38:14,250 --> 00:38:17,910
and frankly if you've ever looked at the
in terms of decency and

623
00:38:17,910 --> 00:38:22,070
the you want to use he like absolutely
positively seriously

624
00:38:22,070 --> 00:38:25,180
we have another question here

625
00:38:25,180 --> 00:38:28,310
okay so as far as a

626
00:38:28,310 --> 00:38:31,840
understand weekend avoid exploitation
echo

627
00:38:31,840 --> 00:38:36,170
that would be better to just say

628
00:38:36,170 --> 00:38:39,490
is ratner for example string copy

629
00:38:39,490 --> 00:38:43,420
and from the user that dead offered that
he

630
00:38:43,420 --> 00:38:48,160
forties exceeding that available to her
is that of crashing application

631
00:38:48,160 --> 00:38:52,010
in using Apple usually have

632
00:38:52,010 --> 00:38:57,030
no se very of recovering from detecting
a memory or on so what should you do

633
00:38:57,030 --> 00:38:57,970
just ignore

634
00:38:57,970 --> 00:39:02,450
for something anything so I think just
aborting the problem is the right

635
00:39:02,450 --> 00:39:03,100
solution

636
00:39:03,100 --> 00:39:07,540
so know if it's a demand that run
somewhere you know it

637
00:39:07,540 --> 00:39:10,870
the let in it take care of starting it
again

638
00:39:10,870 --> 00:39:15,630
level or daemon tools so I don't think
you can find in general

639
00:39:15,630 --> 00:39:19,510
you know keep your problem running
solution if you detect

640
00:39:19,510 --> 00:39:22,820
a awful usually better to just the board

641
00:39:22,820 --> 00:39:26,190
you have inconsistent state you

642
00:39:26,190 --> 00:39:30,200
have no idea what that inconsistency
looks like nicely much better

643
00:39:30,200 --> 00:39:38,550
the problems than just three fresh data
more questions

644
00:39:38,550 --> 00:39:41,619
okay so thank you very much yes thank
you all for me

