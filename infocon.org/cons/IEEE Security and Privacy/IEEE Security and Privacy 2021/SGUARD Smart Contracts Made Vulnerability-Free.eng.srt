1
00:00:00,160 --> 00:00:02,560
hello everyone i'm tai from singapore

2
00:00:02,560 --> 00:00:04,240
management university

3
00:00:04,240 --> 00:00:06,560
today i will present our paper asgard

4
00:00:06,560 --> 00:00:08,800
toward facing vulnerable smart contracts

5
00:00:08,800 --> 00:00:11,040
automatically

6
00:00:11,040 --> 00:00:13,280
so this is the outline of my talk first

7
00:00:13,280 --> 00:00:14,719
i will introduce some background

8
00:00:14,719 --> 00:00:16,480
knowledge about a smart contract

9
00:00:16,480 --> 00:00:19,439
second i will give a simple example to

10
00:00:19,439 --> 00:00:21,920
demonstrate overall workflow of sql

11
00:00:21,920 --> 00:00:24,080
first i will clearly explain how the

12
00:00:24,080 --> 00:00:25,279
dependencies are

13
00:00:25,279 --> 00:00:28,080
symbolically analyzed in background so

14
00:00:28,080 --> 00:00:28,720
finally

15
00:00:28,720 --> 00:00:33,279
i conclude my task with a result summary

16
00:00:33,440 --> 00:00:35,520
as you may know the smart contract

17
00:00:35,520 --> 00:00:37,760
program is located on top of ethereum

18
00:00:37,760 --> 00:00:40,000
blockchain to support many financial

19
00:00:40,000 --> 00:00:41,600
application

20
00:00:41,600 --> 00:00:43,600
there are two noticeable properties of

21
00:00:43,600 --> 00:00:45,280
smart contracts are published and

22
00:00:45,280 --> 00:00:46,640
immutable

23
00:00:46,640 --> 00:00:48,879
immutable means that you cannot modify

24
00:00:48,879 --> 00:00:49,840
the source course

25
00:00:49,840 --> 00:00:52,320
of a smart contract if it's a it is

26
00:00:52,320 --> 00:00:54,480
worth deploying to the blockchain

27
00:00:54,480 --> 00:00:57,440
so here's either example smart contract

28
00:00:57,440 --> 00:00:58,320
written in

29
00:00:58,320 --> 00:01:01,520
solidity the syntax is really similar to

30
00:01:01,520 --> 00:01:02,800
javascript

31
00:01:02,800 --> 00:01:05,040
so the hello world smart contract has

32
00:01:05,040 --> 00:01:06,080
two functions

33
00:01:06,080 --> 00:01:08,479
the first function is constructor with

34
00:01:08,479 --> 00:01:10,240
initialized data and the

35
00:01:10,240 --> 00:01:12,799
second function the update install new

36
00:01:12,799 --> 00:01:16,720
string to the global variable message

37
00:01:16,720 --> 00:01:18,720
because smart contracts are subject to

38
00:01:18,720 --> 00:01:20,240
vulnerability

39
00:01:20,240 --> 00:01:22,880
how to have a specific smart contract

40
00:01:22,880 --> 00:01:23,920
deployment

41
00:01:23,920 --> 00:01:26,159
the general workflow is thus we first

42
00:01:26,159 --> 00:01:28,240
scan our smartphone track with variety

43
00:01:28,240 --> 00:01:30,240
of operational security tools

44
00:01:30,240 --> 00:01:33,600
such as algente or as first whenever a

45
00:01:33,600 --> 00:01:34,880
box is discovered

46
00:01:34,880 --> 00:01:37,920
we manually fix it and scan again

47
00:01:37,920 --> 00:01:39,840
to make sure that no bug exists in our

48
00:01:39,840 --> 00:01:41,119
smart contract

49
00:01:41,119 --> 00:01:43,600
so after that step the smart contract is

50
00:01:43,600 --> 00:01:46,479
safe for deployment

51
00:01:46,479 --> 00:01:48,640
however with etc the workflow is changed

52
00:01:48,640 --> 00:01:49,920
a bit first

53
00:01:49,920 --> 00:01:52,960
we locate vulnerabilities

54
00:01:52,960 --> 00:01:55,200
second we generate patches for

55
00:01:55,200 --> 00:01:56,799
vulnerable smart contract

56
00:01:56,799 --> 00:01:58,799
and last we prove that our smart

57
00:01:58,799 --> 00:01:59,920
contract

58
00:01:59,920 --> 00:02:03,040
is safe then the smart contract is now

59
00:02:03,040 --> 00:02:03,600
safe

60
00:02:03,600 --> 00:02:06,799
for the deployment how

61
00:02:06,799 --> 00:02:09,360
how can we do that this is our idea

62
00:02:09,360 --> 00:02:10,239
first

63
00:02:10,239 --> 00:02:12,400
we analyze smart contract at the barcode

64
00:02:12,400 --> 00:02:14,640
level because it's more precise and

65
00:02:14,640 --> 00:02:18,000
analysis based on the source cost

66
00:02:18,000 --> 00:02:20,160
second we fix smart contract at the

67
00:02:20,160 --> 00:02:21,680
source code level

68
00:02:21,680 --> 00:02:24,160
because is it more transparent to user

69
00:02:24,160 --> 00:02:26,560
that will understand our faces

70
00:02:26,560 --> 00:02:29,120
last based on the way we analyze smart

71
00:02:29,120 --> 00:02:31,040
contract we can prove that our fixed

72
00:02:31,040 --> 00:02:33,920
smart contracts are safe

73
00:02:33,920 --> 00:02:37,200
so here the cosmic bit on the left is

74
00:02:37,200 --> 00:02:38,640
the vulnerable smart contract

75
00:02:38,640 --> 00:02:41,840
is designed to give 0.1 ether for the

76
00:02:41,840 --> 00:02:43,519
first five person who called the

77
00:02:43,519 --> 00:02:45,360
function giveaway

78
00:02:45,360 --> 00:02:48,080
however attacker intentionally can call

79
00:02:48,080 --> 00:02:49,280
the function giveaway

80
00:02:49,280 --> 00:02:51,440
more than 8 times to reset the variable

81
00:02:51,440 --> 00:02:52,800
counter to 0

82
00:02:52,800 --> 00:02:56,160
and claim more a theorem this happens

83
00:02:56,160 --> 00:02:58,159
because the variable counters have

84
00:02:58,159 --> 00:03:01,040
thigh of unsigned age which have we can

85
00:03:01,040 --> 00:03:04,800
only handle the value from 0 to 7

86
00:03:04,800 --> 00:03:07,360
on the right is a smart contract fixed

87
00:03:07,360 --> 00:03:08,319
by edgar

88
00:03:08,319 --> 00:03:11,200
basically we wrap the assignment counter

89
00:03:11,200 --> 00:03:12,959
in three by one with a safe math

90
00:03:12,959 --> 00:03:14,480
function goal

91
00:03:14,480 --> 00:03:17,120
and uncertain age which are true an

92
00:03:17,120 --> 00:03:18,560
arrow if there is

93
00:03:18,560 --> 00:03:20,959
an overflow happen to the variable

94
00:03:20,959 --> 00:03:23,360
counter

95
00:03:24,239 --> 00:03:27,599
so we here we show the overall workflow

96
00:03:27,599 --> 00:03:31,760
how we how how to achieve that result

97
00:03:31,760 --> 00:03:34,080
step one we enumerate all possible

98
00:03:34,080 --> 00:03:34,959
traces

99
00:03:34,959 --> 00:03:37,360
from the givens example the vulnerable

100
00:03:37,360 --> 00:03:38,480
smart contract has

101
00:03:38,480 --> 00:03:41,760
two traces tray one goes to the true

102
00:03:41,760 --> 00:03:43,840
brands of the if statement

103
00:03:43,840 --> 00:03:46,640
and tray two goes to the phone brands in

104
00:03:46,640 --> 00:03:47,680
total there are two

105
00:03:47,680 --> 00:03:51,440
traces as shown in the slides

106
00:03:52,080 --> 00:03:55,120
in the second step we find critical in

107
00:03:55,120 --> 00:03:57,959
ethernet code in our cases is a

108
00:03:57,959 --> 00:03:59,280
message.sender.send

109
00:03:59,280 --> 00:04:02,080
from the tray 1 as the backup level is

110
00:04:02,080 --> 00:04:03,040
represented

111
00:04:03,040 --> 00:04:06,560
by the instruction code

112
00:04:06,560 --> 00:04:09,840
step 3 we trace back the control

113
00:04:09,840 --> 00:04:12,080
dependency to detect relevant

114
00:04:12,080 --> 00:04:14,879
statements or expressions in our case

115
00:04:14,879 --> 00:04:16,880
message the center that sends a control

116
00:04:16,880 --> 00:04:17,519
dependent

117
00:04:17,519 --> 00:04:20,959
on the statement if counter less than

118
00:04:20,959 --> 00:04:22,960
phi

119
00:04:22,960 --> 00:04:26,000
so we trace back the data dependency

120
00:04:26,000 --> 00:04:28,720
and we further discovered that the

121
00:04:28,720 --> 00:04:31,040
variable counter is a data dependence on

122
00:04:31,040 --> 00:04:32,639
the assignment counter

123
00:04:32,639 --> 00:04:35,199
assignment counter increase counter

124
00:04:35,199 --> 00:04:36,560
increase by one

125
00:04:36,560 --> 00:04:39,440
is it because it slows data from other

126
00:04:39,440 --> 00:04:41,280
rest

127
00:04:41,280 --> 00:04:44,800
one that is written by the assignment

128
00:04:44,800 --> 00:04:47,919
counter in three by one

129
00:04:48,960 --> 00:04:50,960
step four as the record level the

130
00:04:50,960 --> 00:04:52,880
assignment statements use instruction

131
00:04:52,880 --> 00:04:53,360
add

132
00:04:53,360 --> 00:04:56,240
which may cause overflow so that's it

133
00:04:56,240 --> 00:04:58,000
why we generate phases for this

134
00:04:58,000 --> 00:04:59,600
venerable code

135
00:04:59,600 --> 00:05:02,240
so first we need compressed source map

136
00:05:02,240 --> 00:05:03,919
to identify the line of code

137
00:05:03,919 --> 00:05:06,240
associated with the renderable output

138
00:05:06,240 --> 00:05:07,360
then we travel

139
00:05:07,360 --> 00:05:11,759
the asd 3 to detect the precise location

140
00:05:11,759 --> 00:05:14,720
and if time to wrap the assignment with

141
00:05:14,720 --> 00:05:16,560
our saved math function goal

142
00:05:16,560 --> 00:05:20,320
finally the bug is fixed so let me

143
00:05:20,320 --> 00:05:23,680
summarize our fourth step to fix a fixed

144
00:05:23,680 --> 00:05:24,720
smart contract

145
00:05:24,720 --> 00:05:27,680
first we enumerate all possible traces

146
00:05:27,680 --> 00:05:30,479
second we locate critical instruction

147
00:05:30,479 --> 00:05:32,639
thus we follow dependency to find

148
00:05:32,639 --> 00:05:34,160
vulnerable outputs

149
00:05:34,160 --> 00:05:37,360
last we generate phases for them

150
00:05:37,360 --> 00:05:39,360
so we need both control and data

151
00:05:39,360 --> 00:05:42,080
dependency to generate suitable phases

152
00:05:42,080 --> 00:05:45,199
however building control flow graph is

153
00:05:45,199 --> 00:05:46,639
well-known task

154
00:05:46,639 --> 00:05:49,039
so in this talk i will only introduce

155
00:05:49,039 --> 00:05:50,240
data dependency

156
00:05:50,240 --> 00:05:53,280
analysis at my code level so

157
00:05:53,280 --> 00:05:56,479
here's the definition an output of

158
00:05:56,479 --> 00:05:58,960
js is said to be data dependent on

159
00:05:58,960 --> 00:05:59,759
opcode of

160
00:05:59,759 --> 00:06:03,199
i it is read data data

161
00:06:03,199 --> 00:06:06,160
from location that re that's written by

162
00:06:06,160 --> 00:06:07,280
of course

163
00:06:07,280 --> 00:06:10,400
of i so in ethereum data dependency

164
00:06:10,400 --> 00:06:12,800
comes from three data source

165
00:06:12,800 --> 00:06:16,080
memory stack and storage so given the

166
00:06:16,080 --> 00:06:18,800
structures in the slide this creates an

167
00:06:18,800 --> 00:06:20,000
array with 3

168
00:06:20,000 --> 00:06:23,840
values 10 20 and 30 on memory

169
00:06:23,840 --> 00:06:27,199
the last line puts loads data at index 1

170
00:06:27,199 --> 00:06:30,800
and 8 is to 20. is it clearly that

171
00:06:30,800 --> 00:06:33,680
there is a data dependency from everyone

172
00:06:33,680 --> 00:06:34,240
with the

173
00:06:34,240 --> 00:06:37,280
with its declarations so at the back

174
00:06:37,280 --> 00:06:38,080
course level

175
00:06:38,080 --> 00:06:40,479
the air loss instruction lost data from

176
00:06:40,479 --> 00:06:42,240
memory arrest

177
00:06:42,240 --> 00:06:45,600
a a0 written by the second

178
00:06:45,600 --> 00:06:47,759
main style instruction therefore we can

179
00:06:47,759 --> 00:06:49,680
easily detect data dependency between

180
00:06:49,680 --> 00:06:51,919
them

181
00:06:52,479 --> 00:06:55,680
we have similar things for data short

182
00:06:55,680 --> 00:06:58,560
data storage however for storage

183
00:06:58,560 --> 00:06:59,360
ethereum

184
00:06:59,360 --> 00:07:01,840
by cost you different instructions to

185
00:07:01,840 --> 00:07:03,520
interact with storage

186
00:07:03,520 --> 00:07:07,039
they are athletes and star

187
00:07:07,039 --> 00:07:09,520
detecting data dependency on stack a

188
00:07:09,520 --> 00:07:10,800
non-trivial task

189
00:07:10,800 --> 00:07:13,599
online memory storage data dependency on

190
00:07:13,599 --> 00:07:14,080
stack

191
00:07:14,080 --> 00:07:16,560
is not clearly shown in the simulated

192
00:07:16,560 --> 00:07:17,440
presence

193
00:07:17,440 --> 00:07:19,039
so we have to trace back the stack

194
00:07:19,039 --> 00:07:21,840
position to discover the data dependency

195
00:07:21,840 --> 00:07:25,680
for example the example shows on the

196
00:07:25,680 --> 00:07:26,479
right

197
00:07:26,479 --> 00:07:29,919
so from the edge instruction we trace

198
00:07:29,919 --> 00:07:32,000
back to find the possible stack position

199
00:07:32,000 --> 00:07:33,919
that may affect its value

200
00:07:33,919 --> 00:07:36,560
finally we discovered that the value of

201
00:07:36,560 --> 00:07:37,680
the variable is

202
00:07:37,680 --> 00:07:41,199
a stack position 1 is a part of the

203
00:07:41,199 --> 00:07:44,800
x instruction

204
00:07:44,800 --> 00:07:46,560
so what happens if the symbolic

205
00:07:46,560 --> 00:07:48,479
expressions are too complicated

206
00:07:48,479 --> 00:07:51,280
do they have a data dependency we don't

207
00:07:51,280 --> 00:07:51,840
know

208
00:07:51,840 --> 00:07:54,879
in the case in that case we

209
00:07:54,879 --> 00:07:57,199
are in the case that we are unable

210
00:07:57,199 --> 00:07:58,000
unable to

211
00:07:58,000 --> 00:08:01,039
handle we will apply some heuristics

212
00:08:01,039 --> 00:08:03,039
for example converting a simple

213
00:08:03,039 --> 00:08:06,160
expression to concrete memory ranges

214
00:08:06,160 --> 00:08:08,720
or in the worst day we assume that

215
00:08:08,720 --> 00:08:10,000
writing and reading

216
00:08:10,000 --> 00:08:13,759
allocation are overlapped so finally

217
00:08:13,759 --> 00:08:16,160
for data dependency we come up with an

218
00:08:16,160 --> 00:08:17,680
algorithm that traces back the

219
00:08:17,680 --> 00:08:18,800
dependency across

220
00:08:18,800 --> 00:08:21,199
three different data sources stack

221
00:08:21,199 --> 00:08:23,759
memory and

222
00:08:24,840 --> 00:08:26,000
storage

223
00:08:26,000 --> 00:08:28,879
we pass intel function residency cross

224
00:08:28,879 --> 00:08:30,400
function reagency

225
00:08:30,400 --> 00:08:33,200
dangerous transaction dot origin and

226
00:08:33,200 --> 00:08:34,159
arithmetic

227
00:08:34,159 --> 00:08:36,799
vulnerability so these vulnerabilities

228
00:08:36,799 --> 00:08:39,679
are formally defined in our paper

229
00:08:39,679 --> 00:08:41,679
so according to the way we analyze a

230
00:08:41,679 --> 00:08:44,000
smart contract the fixed smart contract

231
00:08:44,000 --> 00:08:46,720
is safe because all data and control

232
00:08:46,720 --> 00:08:48,240
dependency are captured

233
00:08:48,240 --> 00:08:50,399
all vulnerabilities are discovered our

234
00:08:50,399 --> 00:08:53,680
generated fields are safe

235
00:08:53,680 --> 00:08:56,320
when enumerating all possible traces of

236
00:08:56,320 --> 00:08:57,519
a smart contract

237
00:08:57,519 --> 00:09:00,160
we have to answer a question how many

238
00:09:00,160 --> 00:09:02,560
iterations are sufficient to capture all

239
00:09:02,560 --> 00:09:03,519
dependencies

240
00:09:03,519 --> 00:09:06,720
in a loop even an example is in the

241
00:09:06,720 --> 00:09:07,600
slides

242
00:09:07,600 --> 00:09:10,640
we can prove that with 5 iteration and

243
00:09:10,640 --> 00:09:13,200
are able to capture all dependencies in

244
00:09:13,200 --> 00:09:15,120
the transfer function

245
00:09:15,120 --> 00:09:16,959
is it because there are 5 assignment

246
00:09:16,959 --> 00:09:18,720
statements in the loop

247
00:09:18,720 --> 00:09:21,920
you may read our paper from details

248
00:09:21,920 --> 00:09:22,560
however

249
00:09:22,560 --> 00:09:25,519
for complicated program exact may take

250
00:09:25,519 --> 00:09:26,800
really long time to

251
00:09:26,800 --> 00:09:29,680
enumerate all possible traces due to

252
00:09:29,680 --> 00:09:31,200
past explosions

253
00:09:31,200 --> 00:09:33,120
this problem will be taken into

254
00:09:33,120 --> 00:09:34,240
considerations

255
00:09:34,240 --> 00:09:37,839
in our future project

256
00:09:37,839 --> 00:09:39,839
here i summarized some noticeable

257
00:09:39,839 --> 00:09:41,920
results from our paper

258
00:09:41,920 --> 00:09:43,760
in smart contract there is a trivial

259
00:09:43,760 --> 00:09:46,320
approach to fit integral overflow or

260
00:09:46,320 --> 00:09:47,200
underflow

261
00:09:47,200 --> 00:09:50,160
thus we will wrap any limited of course

262
00:09:50,160 --> 00:09:52,080
with a safe max function call

263
00:09:52,080 --> 00:09:54,399
it is used as the bay line as you can

264
00:09:54,399 --> 00:09:55,920
see it's in the table as a

265
00:09:55,920 --> 00:09:58,160
generate significantly less set match

266
00:09:58,160 --> 00:09:59,200
function goal

267
00:09:59,200 --> 00:10:01,519
than the baseline so for example with

268
00:10:01,519 --> 00:10:02,800
the s instruction

269
00:10:02,800 --> 00:10:05,040
the baseline scenery four times more

270
00:10:05,040 --> 00:10:06,240
safe mass

271
00:10:06,240 --> 00:10:10,000
function code than us so our experience

272
00:10:10,000 --> 00:10:12,240
results also showed us our fixings

273
00:10:12,240 --> 00:10:14,399
approach include low always in terms of

274
00:10:14,399 --> 00:10:15,200
transaction

275
00:10:15,200 --> 00:10:19,200
is introduced additional 15 percentage

276
00:10:19,200 --> 00:10:19,920
of time and

277
00:10:19,920 --> 00:10:23,920
0.8 percentage of gas and 90 percentage

278
00:10:23,920 --> 00:10:24,320
of

279
00:10:24,320 --> 00:10:26,320
fixed smart contracts are fixed within

280
00:10:26,320 --> 00:10:29,200
36 seconds

281
00:10:29,200 --> 00:10:33,839
thanks for watching

