1
00:00:00,799 --> 00:00:03,120
hi welcome to my talk

2
00:00:03,120 --> 00:00:05,759
i will be presenting revealer a tour for

3
00:00:05,759 --> 00:00:07,919
detecting and exploiting regular

4
00:00:07,919 --> 00:00:09,360
expression denial of service

5
00:00:09,360 --> 00:00:11,920
vulnerabilities my name is inc

6
00:00:11,920 --> 00:00:13,759
leo and this work was done in

7
00:00:13,759 --> 00:00:15,200
collaboration with

8
00:00:15,200 --> 00:00:19,039
jiang and wait more so what is redos

9
00:00:19,039 --> 00:00:21,080
here is an example where there is a web

10
00:00:21,080 --> 00:00:22,240
application

11
00:00:22,240 --> 00:00:25,279
accepting user email as input

12
00:00:25,279 --> 00:00:27,199
the server side validates the input

13
00:00:27,199 --> 00:00:28,840
string using a one

14
00:00:28,840 --> 00:00:31,840
regex the vong vargas is parsed by a

15
00:00:31,840 --> 00:00:34,239
worst-case superlinear regex engine

16
00:00:34,239 --> 00:00:36,480
making it possible for some inputs to

17
00:00:36,480 --> 00:00:39,040
trigger superlinear complexity

18
00:00:39,040 --> 00:00:41,440
attackers can use these inputs to set up

19
00:00:41,440 --> 00:00:42,320
algorithmic

20
00:00:42,320 --> 00:00:45,440
complexity service attacks

21
00:00:45,440 --> 00:00:48,320
specifically on the client side a normal

22
00:00:48,320 --> 00:00:51,440
input abc at def.com

23
00:00:51,440 --> 00:00:53,360
can be verified by the server side

24
00:00:53,360 --> 00:00:55,199
immediately

25
00:00:55,199 --> 00:00:58,640
but if a crafted malicious input is sent

26
00:00:58,640 --> 00:01:00,480
the server-side regex engine would

27
00:01:00,480 --> 00:01:02,879
repeatedly match the character a

28
00:01:02,879 --> 00:01:04,640
hanged for long time and last year

29
00:01:04,640 --> 00:01:07,119
denied service

30
00:01:07,119 --> 00:01:09,439
from the prior example we can see that

31
00:01:09,439 --> 00:01:12,320
there are three conditions for redox

32
00:01:12,320 --> 00:01:14,400
the first one is a vulnerable regex

33
00:01:14,400 --> 00:01:15,360
engine

34
00:01:15,360 --> 00:01:18,080
this requirement is easy to satisfy

35
00:01:18,080 --> 00:01:20,080
because the regex engines in many

36
00:01:20,080 --> 00:01:22,240
popular languages are vulnerable

37
00:01:22,240 --> 00:01:27,360
for example java python javascript etc

38
00:01:27,360 --> 00:01:30,079
the second one is one with regex

39
00:01:30,079 --> 00:01:32,079
existing research has shown that

40
00:01:32,079 --> 00:01:34,400
it is common for developers to write one

41
00:01:34,400 --> 00:01:35,439
by regex

42
00:01:35,439 --> 00:01:37,600
because they focus on expressing all

43
00:01:37,600 --> 00:01:38,640
normal inputs

44
00:01:38,640 --> 00:01:40,560
rather than filtering out the malicious

45
00:01:40,560 --> 00:01:42,159
ones besides

46
00:01:42,159 --> 00:01:45,200
regixes have poor readability making it

47
00:01:45,200 --> 00:01:47,600
difficult for the developers to detect

48
00:01:47,600 --> 00:01:50,799
and mitigate such one basis

49
00:01:50,799 --> 00:01:53,520
the third one is malicious input it has

50
00:01:53,520 --> 00:01:55,520
been summarized informally that

51
00:01:55,520 --> 00:01:57,600
malicious input shares common

52
00:01:57,600 --> 00:01:59,119
characteristics

53
00:01:59,119 --> 00:02:01,600
even though reg exists are hard to read

54
00:02:01,600 --> 00:02:04,159
attackers can craft malicious inputs

55
00:02:04,159 --> 00:02:06,799
by a detailed manual analysis with the

56
00:02:06,799 --> 00:02:10,000
help of these characteristics

57
00:02:10,000 --> 00:02:12,319
three types of mitigations are proposed

58
00:02:12,319 --> 00:02:14,480
in response to the three conditions for

59
00:02:14,480 --> 00:02:16,160
redox

60
00:02:16,160 --> 00:02:18,319
the first one is to use a worst case

61
00:02:18,319 --> 00:02:20,080
linear record engine

62
00:02:20,080 --> 00:02:22,640
this solution is fundamental and as a

63
00:02:22,640 --> 00:02:23,440
result

64
00:02:23,440 --> 00:02:25,040
there will be no corresponding

65
00:02:25,040 --> 00:02:27,840
vulnerable regex or malicious input

66
00:02:27,840 --> 00:02:30,160
however it has been proved in theory

67
00:02:30,160 --> 00:02:32,800
that the worst case linear reg extending

68
00:02:32,800 --> 00:02:34,959
must sacrifice the support for some

69
00:02:34,959 --> 00:02:37,440
extended features

70
00:02:37,440 --> 00:02:39,120
the second one is to filter the

71
00:02:39,120 --> 00:02:40,480
malicious input

72
00:02:40,480 --> 00:02:42,640
usually by monitoring its resource

73
00:02:42,640 --> 00:02:44,400
consumption

74
00:02:44,400 --> 00:02:47,599
this methodology brings extra overhead

75
00:02:47,599 --> 00:02:49,840
besides it will be hard to determine a

76
00:02:49,840 --> 00:02:52,879
precise filter boundary

77
00:02:52,879 --> 00:02:55,280
the last one is to detect and replace

78
00:02:55,280 --> 00:02:57,120
one more reg excess

79
00:02:57,120 --> 00:02:59,519
after this mitigation the remaining reg

80
00:02:59,519 --> 00:03:00,159
exits

81
00:03:00,159 --> 00:03:02,640
have no corresponding malicious input

82
00:03:02,640 --> 00:03:05,040
and the risk of redox is completely

83
00:03:05,040 --> 00:03:06,800
eliminated

84
00:03:06,800 --> 00:03:09,519
such mitigation is effective and is

85
00:03:09,519 --> 00:03:11,599
actually the most commonly used one by

86
00:03:11,599 --> 00:03:12,959
the developers

87
00:03:12,959 --> 00:03:15,040
because they can always find another

88
00:03:15,040 --> 00:03:16,840
implementation for their business

89
00:03:16,840 --> 00:03:18,000
requirement

90
00:03:18,000 --> 00:03:20,480
but as we discussed in the last slide

91
00:03:20,480 --> 00:03:22,720
detecting and mitigating one word reg

92
00:03:22,720 --> 00:03:24,480
exists is hard

93
00:03:24,480 --> 00:03:26,799
therefore we want to build an automatic

94
00:03:26,799 --> 00:03:29,280
tool to help the developers identify the

95
00:03:29,280 --> 00:03:30,799
vulnerable reg exists

96
00:03:30,799 --> 00:03:33,040
and understand where the vulnerability

97
00:03:33,040 --> 00:03:34,720
lies

98
00:03:34,720 --> 00:03:37,040
specifically our goal is to model

99
00:03:37,040 --> 00:03:38,159
vulnerable patterns

100
00:03:38,159 --> 00:03:41,440
and generate valid exploits

101
00:03:41,440 --> 00:03:44,480
we face the following challenges

102
00:03:44,480 --> 00:03:47,599
first traditionally people use nfa to

103
00:03:47,599 --> 00:03:50,319
model the classical regular expressions

104
00:03:50,319 --> 00:03:52,000
and some vulnerable patterns are

105
00:03:52,000 --> 00:03:53,599
proposed accordingly

106
00:03:53,599 --> 00:03:56,319
but nfa cannot model the reg exists with

107
00:03:56,319 --> 00:03:58,560
some extended features

108
00:03:58,560 --> 00:04:01,120
for example an fa cannot model this

109
00:04:01,120 --> 00:04:03,360
regex with the extended feature back

110
00:04:03,360 --> 00:04:04,959
reference

111
00:04:04,959 --> 00:04:07,519
using thomson's algorithm we can first

112
00:04:07,519 --> 00:04:09,840
obtain an nfa for the prior a

113
00:04:09,840 --> 00:04:13,920
or b sub expression then we look at the

114
00:04:13,920 --> 00:04:15,599
back reference as a whole

115
00:04:15,599 --> 00:04:19,600
and constructs the nfa to the end state

116
00:04:19,600 --> 00:04:21,918
when we look into the semantics of this

117
00:04:21,918 --> 00:04:22,960
back reference

118
00:04:22,960 --> 00:04:25,360
we find that it equals a when the prior

119
00:04:25,360 --> 00:04:27,440
sub expression matches an a

120
00:04:27,440 --> 00:04:31,040
and equals b otherwise it appears that

121
00:04:31,040 --> 00:04:33,840
we cannot determine its value statically

122
00:04:33,840 --> 00:04:36,320
which goes beyond the expressive power

123
00:04:36,320 --> 00:04:37,919
of an fa

124
00:04:37,919 --> 00:04:40,080
as a result we need a new formal

125
00:04:40,080 --> 00:04:41,840
expression to model the vulnerable

126
00:04:41,840 --> 00:04:43,840
patterns

127
00:04:43,840 --> 00:04:45,919
the other thing is that we need dynamic

128
00:04:45,919 --> 00:04:48,639
analysis to generate valid exploits with

129
00:04:48,639 --> 00:04:50,720
no false positives

130
00:04:50,720 --> 00:04:52,400
it is also because of the noun

131
00:04:52,400 --> 00:04:54,840
determinism of the extended feature

132
00:04:54,840 --> 00:04:56,160
matching

133
00:04:56,160 --> 00:04:58,479
in other words we need to do the exploit

134
00:04:58,479 --> 00:05:02,639
generation along the matching process

135
00:05:03,039 --> 00:05:05,120
in response to the first challenge we

136
00:05:05,120 --> 00:05:08,000
use enfa instead of nfa to model the

137
00:05:08,000 --> 00:05:10,160
vulnerable patterns

138
00:05:10,160 --> 00:05:13,759
nefa was first proposed in an asc 2018

139
00:05:13,759 --> 00:05:14,800
paper

140
00:05:14,800 --> 00:05:17,120
we complete its definition and proposed

141
00:05:17,120 --> 00:05:20,080
vulnerable efa patterns

142
00:05:20,080 --> 00:05:22,080
for the other challenge we developed

143
00:05:22,080 --> 00:05:23,440
revealer

144
00:05:23,440 --> 00:05:25,759
a hybrid analysis tool for detecting

145
00:05:25,759 --> 00:05:26,960
vulnerable patterns

146
00:05:26,960 --> 00:05:30,400
and generate valid exploits the static

147
00:05:30,400 --> 00:05:33,120
analysis in revealer allows us to filter

148
00:05:33,120 --> 00:05:35,840
potential vulnerabilities effectively

149
00:05:35,840 --> 00:05:38,400
the dynamic analysis verifies list of

150
00:05:38,400 --> 00:05:40,720
potential vulnerabilities precisely

151
00:05:40,720 --> 00:05:45,280
and generates valid exploits accordingly

152
00:05:45,360 --> 00:05:48,080
the idea of enfa is to summarize the

153
00:05:48,080 --> 00:05:50,479
similar implementation among several

154
00:05:50,479 --> 00:05:52,560
different languages

155
00:05:52,560 --> 00:05:56,560
specifically java python javascript etc

156
00:05:56,560 --> 00:05:58,960
all use an implementation consists of

157
00:05:58,960 --> 00:05:59,600
nodes

158
00:05:59,600 --> 00:06:02,560
transitions and a stack based dynamic

159
00:06:02,560 --> 00:06:02,960
match

160
00:06:02,960 --> 00:06:06,080
process these commonalities

161
00:06:06,080 --> 00:06:08,080
are the cornerstone of our enfa

162
00:06:08,080 --> 00:06:10,160
definition

163
00:06:10,160 --> 00:06:13,039
the static structure of enfa includes

164
00:06:13,039 --> 00:06:14,560
enf f1 nodes

165
00:06:14,560 --> 00:06:17,120
representing the semantic features and

166
00:06:17,120 --> 00:06:17,840
directing

167
00:06:17,840 --> 00:06:21,039
transitions between these nodes we take

168
00:06:21,039 --> 00:06:24,560
a asterisk b as an example here the

169
00:06:24,560 --> 00:06:26,720
asterisk symbol denotes greedy

170
00:06:26,720 --> 00:06:27,759
quantifier

171
00:06:27,759 --> 00:06:30,000
which is the type of loop in direct

172
00:06:30,000 --> 00:06:31,840
features

173
00:06:31,840 --> 00:06:34,560
we first parse the characters in directs

174
00:06:34,560 --> 00:06:36,400
into enfa notes

175
00:06:36,400 --> 00:06:39,120
including a single character a a greedy

176
00:06:39,120 --> 00:06:40,000
quantifier

177
00:06:40,000 --> 00:06:43,360
and a single character b we then fill in

178
00:06:43,360 --> 00:06:46,319
the corresponding transitions

179
00:06:46,319 --> 00:06:51,039
the enfa adopts a dynamic match process

180
00:06:51,039 --> 00:06:54,080
let's try to match the string aa to the

181
00:06:54,080 --> 00:06:56,560
above enfa

182
00:06:56,560 --> 00:06:59,440
we start from the beginning and go to

183
00:06:59,440 --> 00:07:00,400
the first node

184
00:07:00,400 --> 00:07:03,919
v1 it has two outgoing transitions

185
00:07:03,919 --> 00:07:06,960
one to the v2 and one to the v3

186
00:07:06,960 --> 00:07:10,000
since v1 is a greedy quantifier it has a

187
00:07:10,000 --> 00:07:12,240
higher priority to match more a's

188
00:07:12,240 --> 00:07:17,039
in v2 instead of ending the loop in v3

189
00:07:17,039 --> 00:07:20,400
as a result we arrive at v2 and match

190
00:07:20,400 --> 00:07:24,000
as 0 then we go back to v1

191
00:07:24,000 --> 00:07:27,360
and similarly transit to v2

192
00:07:27,360 --> 00:07:31,039
and match s1 after another round of

193
00:07:31,039 --> 00:07:32,720
transitions to v1

194
00:07:32,720 --> 00:07:36,080
and v2 we notice that the string s

195
00:07:36,080 --> 00:07:39,680
has no remaining character to match v2

196
00:07:39,680 --> 00:07:42,319
therefore we will try v3 instead but

197
00:07:42,319 --> 00:07:43,280
similarly

198
00:07:43,280 --> 00:07:45,440
there is also no remaining character to

199
00:07:45,440 --> 00:07:47,280
match v3

200
00:07:47,280 --> 00:07:49,280
this is where the backtracking takes

201
00:07:49,280 --> 00:07:50,720
place

202
00:07:50,720 --> 00:07:53,440
we would go back to the already matched

203
00:07:53,440 --> 00:07:54,560
s1

204
00:07:54,560 --> 00:07:58,080
and try to match it by v3 this time we

205
00:07:58,080 --> 00:08:01,360
will fail for trying to match a with b

206
00:08:01,360 --> 00:08:02,720
and that will trigger another

207
00:08:02,720 --> 00:08:04,479
backtracking

208
00:08:04,479 --> 00:08:06,800
the entire match process ends with a

209
00:08:06,800 --> 00:08:09,840
failure after we backtrack to s0

210
00:08:09,840 --> 00:08:14,879
and finds that it also fails to match v3

211
00:08:14,879 --> 00:08:17,759
after understanding backtracking let's

212
00:08:17,759 --> 00:08:20,400
look at a simplified example to help

213
00:08:20,400 --> 00:08:23,360
understand the core of redox repeated

214
00:08:23,360 --> 00:08:25,280
backtracking

215
00:08:25,280 --> 00:08:27,440
we use the rounded rectangle to

216
00:08:27,440 --> 00:08:28,960
represent an eif

217
00:08:28,960 --> 00:08:31,360
note and a dashed line for several

218
00:08:31,360 --> 00:08:33,039
length transitions

219
00:08:33,039 --> 00:08:35,519
we add the mesh string of these length

220
00:08:35,519 --> 00:08:36,320
transitions

221
00:08:36,320 --> 00:08:39,599
as an attribute to the dashed line

222
00:08:39,599 --> 00:08:42,399
consider the example here the malicious

223
00:08:42,399 --> 00:08:45,120
input consists of three sections

224
00:08:45,120 --> 00:08:47,839
a prefix as zero which can match from

225
00:08:47,839 --> 00:08:51,000
the beginning to a mysterious node

226
00:08:51,000 --> 00:08:54,000
unrepetition of the attack core s

227
00:08:54,000 --> 00:08:57,200
which can match over the mysterious node

228
00:08:57,200 --> 00:08:59,760
and the suffix s1 which leads to a

229
00:08:59,760 --> 00:09:02,160
matching failure

230
00:09:02,160 --> 00:09:04,320
since the matching would finally fail it

231
00:09:04,320 --> 00:09:06,640
would backtrack to all possible

232
00:09:06,640 --> 00:09:09,040
matches before that and for each attack

233
00:09:09,040 --> 00:09:09,920
or s

234
00:09:09,920 --> 00:09:12,560
it can match either the upper pass or

235
00:09:12,560 --> 00:09:14,240
the lower pass

236
00:09:14,240 --> 00:09:17,040
unrepetition of s would create a large

237
00:09:17,040 --> 00:09:19,120
number of backtracking cases

238
00:09:19,120 --> 00:09:22,560
which appear as repeated backtracking

239
00:09:22,560 --> 00:09:25,279
from the example we can get two criteria

240
00:09:25,279 --> 00:09:27,600
for repeated backtracking

241
00:09:27,600 --> 00:09:29,920
the first one is different match passes

242
00:09:29,920 --> 00:09:33,440
with the same departure and destination

243
00:09:33,440 --> 00:09:35,680
the second one is that there must exist

244
00:09:35,680 --> 00:09:37,760
an attack or s that can match these

245
00:09:37,760 --> 00:09:40,720
different passes

246
00:09:41,200 --> 00:09:43,120
the static vulnerable patterns are

247
00:09:43,120 --> 00:09:46,720
inspired by the following criteria

248
00:09:46,720 --> 00:09:48,880
we first prove that only loops and

249
00:09:48,880 --> 00:09:50,000
branches can form

250
00:09:50,000 --> 00:09:52,000
different matching passes with the same

251
00:09:52,000 --> 00:09:54,080
departure and destination

252
00:09:54,080 --> 00:09:56,320
and then consider their combinations to

253
00:09:56,320 --> 00:09:58,080
get one more patterns

254
00:09:58,080 --> 00:10:01,120
we finally get three runway patterns

255
00:10:01,120 --> 00:10:03,360
loop in loop branch in loop and loop

256
00:10:03,360 --> 00:10:04,959
after loop

257
00:10:04,959 --> 00:10:07,440
the dynamic attack core verification is

258
00:10:07,440 --> 00:10:09,839
inspired by the second criteria

259
00:10:09,839 --> 00:10:12,320
that multiple passes share a mesh string

260
00:10:12,320 --> 00:10:12,880
s

261
00:10:12,880 --> 00:10:16,079
which is the attack core therefore the

262
00:10:16,079 --> 00:10:18,880
exploit generation task can be completed

263
00:10:18,880 --> 00:10:20,720
as follows

264
00:10:20,720 --> 00:10:23,839
first we locate the static patterns

265
00:10:23,839 --> 00:10:26,000
for example let's suppose we find the

266
00:10:26,000 --> 00:10:28,000
loop in loop vulnerable pattern in the

267
00:10:28,000 --> 00:10:29,839
input regex

268
00:10:29,839 --> 00:10:32,480
we would then conduct a dynamic match

269
00:10:32,480 --> 00:10:36,079
generation for this pattern

270
00:10:36,079 --> 00:10:38,480
we will first try to generate the attack

271
00:10:38,480 --> 00:10:39,200
or s

272
00:10:39,200 --> 00:10:42,480
which should match both r1 r2 r3 and r1

273
00:10:42,480 --> 00:10:43,440
r3

274
00:10:43,440 --> 00:10:46,720
and if the generation is successful

275
00:10:46,720 --> 00:10:49,680
we will generate the attack prefix s0 as

276
00:10:49,680 --> 00:10:51,839
a match of r0

277
00:10:51,839 --> 00:10:54,399
and the attack suffix as 1 that fails to

278
00:10:54,399 --> 00:10:56,640
match r1 r2 r3 r4

279
00:10:56,640 --> 00:10:59,680
or r1 r3 r4

280
00:10:59,680 --> 00:11:02,399
the algorithms in general is a lazy

281
00:11:02,399 --> 00:11:04,320
on-demand generation

282
00:11:04,320 --> 00:11:06,640
meaning that we start the original match

283
00:11:06,640 --> 00:11:09,279
process without any concrete input

284
00:11:09,279 --> 00:11:12,000
and conducts the regeneration only when

285
00:11:12,000 --> 00:11:12,880
the algorithm

286
00:11:12,880 --> 00:11:16,079
requires a match to proceed you need to

287
00:11:16,079 --> 00:11:18,160
read the paper for more details about

288
00:11:18,160 --> 00:11:21,279
the generation algorithm

289
00:11:21,279 --> 00:11:25,040
revealer packs everything up the java 8

290
00:11:25,040 --> 00:11:27,279
fragrance engine helps us to transform

291
00:11:27,279 --> 00:11:30,880
the input brackets into an enfa

292
00:11:30,880 --> 00:11:33,360
in this static analysis phase we locate

293
00:11:33,360 --> 00:11:35,279
the static vulnerable patterns in the

294
00:11:35,279 --> 00:11:36,320
enfa

295
00:11:36,320 --> 00:11:37,760
and mark them as potential

296
00:11:37,760 --> 00:11:40,160
vulnerabilities

297
00:11:40,160 --> 00:11:42,399
in the dynamic analysis phase we

298
00:11:42,399 --> 00:11:44,800
validate whether an attack core s

299
00:11:44,800 --> 00:11:47,360
exists for potential vulnerability and

300
00:11:47,360 --> 00:11:48,320
if so

301
00:11:48,320 --> 00:11:50,639
we generate the attack prefix and the

302
00:11:50,639 --> 00:11:53,440
attack suffix accordingly

303
00:11:53,440 --> 00:11:55,920
finally we construct an attack string

304
00:11:55,920 --> 00:11:59,360
and send it to the validator

305
00:11:59,360 --> 00:12:02,399
for the experiment we choose

306
00:12:02,399 --> 00:12:04,959
a specialized father rescuer and two

307
00:12:04,959 --> 00:12:07,279
state-of-the-art static analysis

308
00:12:07,279 --> 00:12:10,959
stores as our baseline we use the same

309
00:12:10,959 --> 00:12:13,920
data set as our baseline rescue

310
00:12:13,920 --> 00:12:18,000
including 29 088 reg axes in total from

311
00:12:18,000 --> 00:12:19,360
different sources

312
00:12:19,360 --> 00:12:21,920
we did separate data preprocessing for

313
00:12:21,920 --> 00:12:24,720
each baseline

314
00:12:24,720 --> 00:12:26,800
according to the number of detected

315
00:12:26,800 --> 00:12:28,560
vulnerabilities

316
00:12:28,560 --> 00:12:32,360
rexploiter detected 63.

317
00:12:32,360 --> 00:12:36,639
rxsr2 detected 112.

318
00:12:36,639 --> 00:12:40,720
rescuer detected 187

319
00:12:40,720 --> 00:12:44,200
revealer detected all the 337

320
00:12:44,200 --> 00:12:45,519
non-vulnerabilities

321
00:12:45,519 --> 00:12:48,160
that other tools can find it also

322
00:12:48,160 --> 00:12:49,079
detected

323
00:12:49,079 --> 00:12:54,000
213 previously unknown vulnerabilities

324
00:12:54,000 --> 00:12:57,279
according to the efficiency revealer is

325
00:12:57,279 --> 00:12:59,680
close to the fastest static analysis

326
00:12:59,680 --> 00:13:00,279
toward

327
00:13:00,279 --> 00:13:04,000
rx6r2 and runs much faster than rescue

328
00:13:04,000 --> 00:13:07,200
and re-exploiter we run

329
00:13:07,200 --> 00:13:09,760
several other experiments to show why

330
00:13:09,760 --> 00:13:12,560
revealer outperforms the others

331
00:13:12,560 --> 00:13:14,639
the first reason is that revealer has

332
00:13:14,639 --> 00:13:16,800
the best support for extended features

333
00:13:16,800 --> 00:13:19,040
by using the enfa

334
00:13:19,040 --> 00:13:20,959
the second reason is that it has the

335
00:13:20,959 --> 00:13:23,360
most comprehensive consideration of

336
00:13:23,360 --> 00:13:24,880
vulnerable patterns

337
00:13:24,880 --> 00:13:27,120
especially when other tools do not

338
00:13:27,120 --> 00:13:29,200
perform well for the loop after loop

339
00:13:29,200 --> 00:13:30,800
cases

340
00:13:30,800 --> 00:13:32,880
the third reason is that static and

341
00:13:32,880 --> 00:13:34,079
dynamic analysis

342
00:13:34,079 --> 00:13:36,800
have different advantages and revealer

343
00:13:36,800 --> 00:13:38,720
success by taking a hybrid

344
00:13:38,720 --> 00:13:42,240
approach we also cross validate the

345
00:13:42,240 --> 00:13:44,720
detected vulnerabilities using brackets

346
00:13:44,720 --> 00:13:48,000
engines other than the java 8 engine

347
00:13:48,000 --> 00:13:50,240
we find that most of these reported

348
00:13:50,240 --> 00:13:52,399
vulnerabilities are true positives

349
00:13:52,399 --> 00:13:56,000
in other reg exchanging as well

350
00:13:56,000 --> 00:13:58,880
to test the real world impact we crawled

351
00:13:58,880 --> 00:14:02,959
a data set containing 178 popular github

352
00:14:02,959 --> 00:14:04,480
projects

353
00:14:04,480 --> 00:14:07,040
we will report the vulnerability if it

354
00:14:07,040 --> 00:14:08,720
can trigger a 10 seconds

355
00:14:08,720 --> 00:14:11,279
timeout in the cross validation with a

356
00:14:11,279 --> 00:14:11,760
max

357
00:14:11,760 --> 00:14:16,800
maximum 128 input length we detected

358
00:14:16,800 --> 00:14:19,040
certain vulnerabilities from the python

359
00:14:19,040 --> 00:14:19,839
projects

360
00:14:19,839 --> 00:14:22,959
and 48 from the javascript projects

361
00:14:22,959 --> 00:14:25,680
actually 16 more than what we reported

362
00:14:25,680 --> 00:14:27,279
in the paper

363
00:14:27,279 --> 00:14:29,279
we already reported all these

364
00:14:29,279 --> 00:14:31,839
vulnerabilities to the corresponding 39

365
00:14:31,839 --> 00:14:32,800
vendors

366
00:14:32,800 --> 00:14:35,440
and 14 of them fixed or verified our

367
00:14:35,440 --> 00:14:37,519
report

368
00:14:37,519 --> 00:14:40,399
in summary we first proposed our

369
00:14:40,399 --> 00:14:42,959
mitigation goal toward redos

370
00:14:42,959 --> 00:14:45,040
which is to model vulnerable patterns

371
00:14:45,040 --> 00:14:47,920
and generate valid exploits

372
00:14:47,920 --> 00:14:50,240
we made two theory contributions to

373
00:14:50,240 --> 00:14:51,760
achieve the goal

374
00:14:51,760 --> 00:14:54,800
including complete the enfa definition

375
00:14:54,800 --> 00:14:58,240
and propose vulnerable nfa patterns

376
00:14:58,240 --> 00:15:01,199
we developed revealer a hybrid analysis

377
00:15:01,199 --> 00:15:03,440
tool for detecting and exploiting

378
00:15:03,440 --> 00:15:06,240
redox vulnerabilities we will make the

379
00:15:06,240 --> 00:15:06,959
source code

380
00:15:06,959 --> 00:15:10,480
available on github thank you for your

381
00:15:10,480 --> 00:15:12,560
attention i would be happy to answer

382
00:15:12,560 --> 00:15:16,000
any questions

