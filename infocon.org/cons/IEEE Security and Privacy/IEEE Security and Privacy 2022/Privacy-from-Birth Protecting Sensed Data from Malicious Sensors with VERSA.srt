1
00:00:00,719 --> 00:00:01,599
uh

2
00:00:01,599 --> 00:00:04,560
hi all uh i'm shashi uh i'm a phd

3
00:00:04,560 --> 00:00:06,879
candidate from university of california

4
00:00:06,879 --> 00:00:07,759
uh

5
00:00:07,759 --> 00:00:09,440
in today's talk we'll be talking about

6
00:00:09,440 --> 00:00:11,920
uh privacy from birth uh this is a joint

7
00:00:11,920 --> 00:00:14,160
effort from ivan sayon who's also a

8
00:00:14,160 --> 00:00:15,519
primary co-author

9
00:00:15,519 --> 00:00:17,760
and jean

10
00:00:17,760 --> 00:00:19,119
okay so

11
00:00:19,119 --> 00:00:22,560
so that today's topic is iot um

12
00:00:22,560 --> 00:00:24,320
so these devices make our lives a

13
00:00:24,320 --> 00:00:26,320
comfortable easier and safer

14
00:00:26,320 --> 00:00:28,480
and they

15
00:00:28,480 --> 00:00:30,400
they easily seamlessly connect us uh to

16
00:00:30,400 --> 00:00:32,640
that outside world via internet

17
00:00:32,640 --> 00:00:34,399
and however any vulnerability within

18
00:00:34,399 --> 00:00:36,320
these devices could lead to coyotes and

19
00:00:36,320 --> 00:00:38,160
uh and especially the things which are

20
00:00:38,160 --> 00:00:41,120
pertaining to human uh privacy of humans

21
00:00:41,120 --> 00:00:44,160
um and if you see here since the last

22
00:00:44,160 --> 00:00:46,079
decade there are multiple attacks

23
00:00:46,079 --> 00:00:48,160
attacks on door locks smart door locks

24
00:00:48,160 --> 00:00:51,680
smart features and cameras

25
00:00:51,680 --> 00:00:53,360
so we might want to be a little scared

26
00:00:53,360 --> 00:00:56,239
about these things

27
00:00:56,640 --> 00:00:58,800
so these devices are ubiquitous they are

28
00:00:58,800 --> 00:01:00,800
present everywhere um and they are

29
00:01:00,800 --> 00:01:02,719
diverse in nature

30
00:01:02,719 --> 00:01:04,720
and they are also growing in number

31
00:01:04,720 --> 00:01:06,880
you we typically see them in houses

32
00:01:06,880 --> 00:01:08,240
offices

33
00:01:08,240 --> 00:01:10,720
public transport industry automation and

34
00:01:10,720 --> 00:01:12,479
automobiles

35
00:01:12,479 --> 00:01:14,880
they perform two or three of uh three

36
00:01:14,880 --> 00:01:16,960
tasks which are like sensing actuation

37
00:01:16,960 --> 00:01:19,360
or controlling both of them sensing is

38
00:01:19,360 --> 00:01:22,159
sensing the ambient temperature and of

39
00:01:22,159 --> 00:01:24,560
ambient environment and actuation is

40
00:01:24,560 --> 00:01:28,159
causing a change in the environment

41
00:01:28,159 --> 00:01:30,720
typically these devices are deployed on

42
00:01:30,720 --> 00:01:33,680
at the low on the edge and they are

43
00:01:33,680 --> 00:01:35,920
in low end spectrum and

44
00:01:35,920 --> 00:01:37,600
you have higher on iot devices or

45
00:01:37,600 --> 00:01:40,479
smartphones controlling them

46
00:01:40,479 --> 00:01:43,680
and we they often perform critical tasks

47
00:01:43,680 --> 00:01:46,799
like for sensing smoke in a house or

48
00:01:46,799 --> 00:01:48,560
they also collect personal information

49
00:01:48,560 --> 00:01:50,320
like your smart watch collects your

50
00:01:50,320 --> 00:01:52,880
heart rate information and

51
00:01:52,880 --> 00:01:54,560
and these because of this importance

52
00:01:54,560 --> 00:01:56,399
they are attractive targets uh for

53
00:01:56,399 --> 00:01:58,880
exploitation

54
00:01:58,880 --> 00:02:01,280
so in this in today's talk we'll focus

55
00:02:01,280 --> 00:02:03,040
more on the low end spectrum of these

56
00:02:03,040 --> 00:02:04,240
iot devices which are the

57
00:02:04,240 --> 00:02:06,399
microcontroller units mcus

58
00:02:06,399 --> 00:02:09,119
um so these these have low cost low

59
00:02:09,119 --> 00:02:12,000
power and they are there of small size

60
00:02:12,000 --> 00:02:13,360
they need to fit everywhere and they

61
00:02:13,360 --> 00:02:15,760
need to consume less battery power um

62
00:02:15,760 --> 00:02:17,680
they have a very low computing power

63
00:02:17,680 --> 00:02:21,200
that is uh they have single core uh

64
00:02:21,200 --> 00:02:23,520
cpus with eight or six bit architectures

65
00:02:23,520 --> 00:02:25,840
and they have eight or eight to six in

66
00:02:25,840 --> 00:02:29,599
or 48 megahertz of frequency and their

67
00:02:29,599 --> 00:02:32,560
memory is less than 128 kilobytes

68
00:02:32,560 --> 00:02:35,040
and the most important trait of these

69
00:02:35,040 --> 00:02:36,720
developers that we be

70
00:02:36,720 --> 00:02:38,400
important for this talk is they have no

71
00:02:38,400 --> 00:02:40,640
security features at all they have no

72
00:02:40,640 --> 00:02:43,440
kernel they have no mpu they have no mmu

73
00:02:43,440 --> 00:02:46,000
not even a hypervisor or a te

74
00:02:46,000 --> 00:02:48,080
and they execute instructions directly

75
00:02:48,080 --> 00:02:50,000
from flash that they had they don't have

76
00:02:50,000 --> 00:02:53,280
any virtualization to load and compute

77
00:02:53,280 --> 00:02:54,640
and

78
00:02:54,640 --> 00:02:56,239
yeah so

79
00:02:56,239 --> 00:02:59,040
examples of such devices are ti ms430

80
00:02:59,040 --> 00:03:02,400
and avr at mega eight

81
00:03:02,879 --> 00:03:04,800
so this is the typical architecture of a

82
00:03:04,800 --> 00:03:08,159
low-end mcu it has the core um which

83
00:03:08,159 --> 00:03:10,159
computes instructions from

84
00:03:10,159 --> 00:03:13,040
programs in the flash and then it has

85
00:03:13,040 --> 00:03:15,200
interpreter logic and dma which work in

86
00:03:15,200 --> 00:03:16,640
parallel with the core

87
00:03:16,640 --> 00:03:19,120
and they connect these are these units

88
00:03:19,120 --> 00:03:21,599
are connected to the memory via memory

89
00:03:21,599 --> 00:03:25,280
bus and ah and this memory uh has a rom

90
00:03:25,280 --> 00:03:27,200
a read-only memory so it contains

91
00:03:27,200 --> 00:03:28,480
bootloader and things like that which

92
00:03:28,480 --> 00:03:30,319
are amber which are embedded at the end

93
00:03:30,319 --> 00:03:32,239
at manufacturing time and then there is

94
00:03:32,239 --> 00:03:34,640
flash where you have the programs and we

95
00:03:34,640 --> 00:03:37,599
have the ram that data memory and then

96
00:03:37,599 --> 00:03:40,159
peripheral regions which contain uh

97
00:03:40,159 --> 00:03:42,080
which does gpio task or any other

98
00:03:42,080 --> 00:03:43,760
peripherals so there are two peripherals

99
00:03:43,760 --> 00:03:46,159
internal and external so the more

100
00:03:46,159 --> 00:03:48,239
interesting part is external where these

101
00:03:48,239 --> 00:03:50,239
devices mcs are connected to the

102
00:03:50,239 --> 00:03:52,400
external sensors like temperature sensor

103
00:03:52,400 --> 00:03:53,840
or leds

104
00:03:53,840 --> 00:03:56,480
so when a sensing happens uh what do you

105
00:03:56,480 --> 00:03:58,400
sensing here sensing is

106
00:03:58,400 --> 00:04:00,959
when when let's say a temperature sensor

107
00:04:00,959 --> 00:04:02,799
gets activated due to

108
00:04:02,799 --> 00:04:04,720
some change in the room temperature then

109
00:04:04,720 --> 00:04:07,680
this sensor will uh understand what's uh

110
00:04:07,680 --> 00:04:09,920
the ambient temperature and it will

111
00:04:09,920 --> 00:04:11,439
convert the information into digital

112
00:04:11,439 --> 00:04:14,159
format and it will be first kept at the

113
00:04:14,159 --> 00:04:15,840
gpio memory

114
00:04:15,840 --> 00:04:18,399
and after this the programs in flash

115
00:04:18,399 --> 00:04:20,238
take it from the gpi memory and starts

116
00:04:20,238 --> 00:04:21,839
com start processing on it or computing

117
00:04:21,839 --> 00:04:23,919
on it so this is how a typical sensing

118
00:04:23,919 --> 00:04:25,040
happens

119
00:04:25,040 --> 00:04:26,160
and

120
00:04:26,160 --> 00:04:29,199
so how to protect privacy of sense data

121
00:04:29,199 --> 00:04:31,120
on these tiny mcus this is the primary

122
00:04:31,120 --> 00:04:32,240
question we'll be answering throughout

123
00:04:32,240 --> 00:04:33,600
the talk

124
00:04:33,600 --> 00:04:36,080
so these are low end mcu's and uh and

125
00:04:36,080 --> 00:04:37,440
they often get sensitive information

126
00:04:37,440 --> 00:04:38,160
like

127
00:04:38,160 --> 00:04:40,639
hard pacemaker for example and

128
00:04:40,639 --> 00:04:42,720
they have no advanced features like tes

129
00:04:42,720 --> 00:04:44,639
or they cannot run fancy crypto like

130
00:04:44,639 --> 00:04:46,479
public cryptography

131
00:04:46,479 --> 00:04:47,680
because they don't have much computing

132
00:04:47,680 --> 00:04:48,639
power

133
00:04:48,639 --> 00:04:51,360
so okay simple idea here would be why

134
00:04:51,360 --> 00:04:53,040
not just encrypt the information and

135
00:04:53,040 --> 00:04:54,960
send it out

136
00:04:54,960 --> 00:04:56,400
so let's say we have

137
00:04:56,400 --> 00:04:58,720
the smartphone and there is uh

138
00:04:58,720 --> 00:05:02,560
a thermostat an example a low-end device

139
00:05:02,560 --> 00:05:04,960
uh and authenticate both the endpoints

140
00:05:04,960 --> 00:05:06,880
after authenticating both the endpoints

141
00:05:06,880 --> 00:05:08,880
uh now collect the sensor data on the

142
00:05:08,880 --> 00:05:11,120
thermostat encrypt it with the key known

143
00:05:11,120 --> 00:05:13,039
to the controller

144
00:05:13,039 --> 00:05:14,880
and send the information back encrypted

145
00:05:14,880 --> 00:05:17,759
information back to the

146
00:05:17,759 --> 00:05:20,880
smartphone understand it so

147
00:05:20,880 --> 00:05:22,240
however

148
00:05:22,240 --> 00:05:24,080
if you zoom into this device it has this

149
00:05:24,080 --> 00:05:26,479
my mcu that is marked in red over there

150
00:05:26,479 --> 00:05:28,479
and then there is led which which takes

151
00:05:28,479 --> 00:05:31,440
the analog information so and this mcu

152
00:05:31,440 --> 00:05:33,919
can uh which has a software which does

153
00:05:33,919 --> 00:05:36,560
the encryption right so and this

154
00:05:36,560 --> 00:05:38,400
software can still be compromised

155
00:05:38,400 --> 00:05:39,840
because there are because there is no

156
00:05:39,840 --> 00:05:42,479
protection for this low-end use

157
00:05:42,479 --> 00:05:43,440
and

158
00:05:43,440 --> 00:05:44,560
yeah so

159
00:05:44,560 --> 00:05:47,120
there are techniques which are

160
00:05:47,120 --> 00:05:49,199
which ensure software integrity on these

161
00:05:49,199 --> 00:05:50,880
low-end devices they are like promoted

162
00:05:50,880 --> 00:05:53,199
station proof execution

163
00:05:53,199 --> 00:05:55,520
several other services however these

164
00:05:55,520 --> 00:05:58,479
services primarily aim to detect if the

165
00:05:58,479 --> 00:06:00,080
software on the device is compromised

166
00:06:00,080 --> 00:06:02,000
but they cannot really prevent

167
00:06:02,000 --> 00:06:03,440
this compromise software to leak

168
00:06:03,440 --> 00:06:04,639
information

169
00:06:04,639 --> 00:06:06,479
so by the time the controller knows that

170
00:06:06,479 --> 00:06:08,240
something is something wrong on the

171
00:06:08,240 --> 00:06:09,440
device

172
00:06:09,440 --> 00:06:11,280
they can be pretty much sure that the

173
00:06:11,280 --> 00:06:13,680
data is already leaked

174
00:06:13,680 --> 00:06:14,560
so

175
00:06:14,560 --> 00:06:16,960
how to guarantee sense of data privacy

176
00:06:16,960 --> 00:06:18,880
even if the com software on the team

177
00:06:18,880 --> 00:06:21,360
these tiny mcus are compromised

178
00:06:21,360 --> 00:06:23,840
so the prior work we just we have seen

179
00:06:23,840 --> 00:06:25,919
we have just seen uh they are based on

180
00:06:25,919 --> 00:06:27,680
detection algorithms or they assume the

181
00:06:27,680 --> 00:06:29,039
software is benign

182
00:06:29,039 --> 00:06:32,319
and there is no e or os to rely upon

183
00:06:32,319 --> 00:06:33,039
so

184
00:06:33,039 --> 00:06:36,160
now we propose privacy from birth so

185
00:06:36,160 --> 00:06:38,560
so how do we define privacy from birth

186
00:06:38,560 --> 00:06:41,280
so all the traces of information of

187
00:06:41,280 --> 00:06:44,080
sensor data from its birth until it

188
00:06:44,080 --> 00:06:45,520
leaves the device they should be

189
00:06:45,520 --> 00:06:46,800
protected

190
00:06:46,800 --> 00:06:48,479
so what do you mean by birth here the

191
00:06:48,479 --> 00:06:50,080
birth is whenever the data becomes

192
00:06:50,080 --> 00:06:52,400
digital that the ambient sensing or the

193
00:06:52,400 --> 00:06:53,919
ambient uh

194
00:06:53,919 --> 00:06:56,160
environment when you uh understand the

195
00:06:56,160 --> 00:06:57,759
stimulus of the environment stimulus and

196
00:06:57,759 --> 00:06:59,440
then you convert analog information to

197
00:06:59,440 --> 00:07:02,319
digital that is where it takes birth and

198
00:07:02,319 --> 00:07:04,880
after that uh it could be tainted at

199
00:07:04,880 --> 00:07:07,360
multiple places within the memory of the

200
00:07:07,360 --> 00:07:08,720
mcu

201
00:07:08,720 --> 00:07:10,720
for example uh

202
00:07:10,720 --> 00:07:12,720
there are two major places that it could

203
00:07:12,720 --> 00:07:14,000
be tainted first one is the gpa

204
00:07:14,000 --> 00:07:16,240
peripheral memory region where it first

205
00:07:16,240 --> 00:07:18,880
originates and there is also another way

206
00:07:18,880 --> 00:07:21,120
of data getting originated here not only

207
00:07:21,120 --> 00:07:23,520
by a gpi memory but there's there's also

208
00:07:23,520 --> 00:07:26,160
adc analog to digital converter

209
00:07:26,160 --> 00:07:28,800
if the analog sensor cannot

210
00:07:28,800 --> 00:07:30,400
does not implement

211
00:07:30,400 --> 00:07:32,160
converting analog to digital information

212
00:07:32,160 --> 00:07:35,039
then the sensors might want to use

213
00:07:35,039 --> 00:07:37,520
adc here which are internal peripherals

214
00:07:37,520 --> 00:07:39,759
and these adc's place the information in

215
00:07:39,759 --> 00:07:41,759
the other peripheral memory region

216
00:07:41,759 --> 00:07:42,800
so

217
00:07:42,800 --> 00:07:45,039
from here on when i say it's gpa memory

218
00:07:45,039 --> 00:07:47,120
it's basically the memory the peripheral

219
00:07:47,120 --> 00:07:48,720
memory which contains which could

220
00:07:48,720 --> 00:07:51,199
potentially contain the information

221
00:07:51,199 --> 00:07:53,599
and the next part uh that the traces of

222
00:07:53,599 --> 00:07:54,960
this information could be found in the

223
00:07:54,960 --> 00:07:56,639
ram where the software reads and

224
00:07:56,639 --> 00:07:58,879
processes on it

225
00:07:58,879 --> 00:07:59,759
so

226
00:07:59,759 --> 00:08:02,080
yeah so what are the goals of pfp the

227
00:08:02,080 --> 00:08:04,879
first goal is to prevent access to gpio

228
00:08:04,879 --> 00:08:07,039
memory region and only allow authorized

229
00:08:07,039 --> 00:08:08,800
software to access it

230
00:08:08,800 --> 00:08:11,599
the second one is ensure safe execution

231
00:08:11,599 --> 00:08:12,960
of the software

232
00:08:12,960 --> 00:08:14,879
make sure that the tracers are also

233
00:08:14,879 --> 00:08:16,800
protected

234
00:08:16,800 --> 00:08:18,800
so how does this achieve data privacy

235
00:08:18,800 --> 00:08:20,000
that is

236
00:08:20,000 --> 00:08:22,639
only the only the owner of the device

237
00:08:22,639 --> 00:08:25,120
who authorize the software

238
00:08:25,120 --> 00:08:27,280
can control what software can actually

239
00:08:27,280 --> 00:08:29,039
read the information

240
00:08:29,039 --> 00:08:31,199
and the next one is if this software can

241
00:08:31,199 --> 00:08:32,240
incr

242
00:08:32,240 --> 00:08:34,000
implement an encryption algorithm and

243
00:08:34,000 --> 00:08:36,399
also you could make sure to erase all

244
00:08:36,399 --> 00:08:38,240
the stack that it used after its

245
00:08:38,240 --> 00:08:40,799
computation at the end then

246
00:08:40,799 --> 00:08:42,799
uh yeah the all the trays are erased and

247
00:08:42,799 --> 00:08:44,800
also they are encrypted so nothing good

248
00:08:44,800 --> 00:08:47,359
can be leaked

249
00:08:47,440 --> 00:08:50,000
and now let's go into versa this is

250
00:08:50,000 --> 00:08:51,680
verified remote sensing authorization

251
00:08:51,680 --> 00:08:53,279
architecture

252
00:08:53,279 --> 00:08:57,040
versa probably implements pfb goals

253
00:08:57,040 --> 00:08:58,640
and it's an hybrid architecture which

254
00:08:58,640 --> 00:09:01,440
has both software and hardware code

255
00:09:01,440 --> 00:09:02,880
components

256
00:09:02,880 --> 00:09:06,800
so if if let's say this is a

257
00:09:06,800 --> 00:09:08,399
typica

258
00:09:08,399 --> 00:09:10,800
short or less condensed architecture of

259
00:09:10,800 --> 00:09:13,440
this mcu then versa has two components

260
00:09:13,440 --> 00:09:15,120
one is the hardware component which sits

261
00:09:15,120 --> 00:09:17,200
in between the core or which sits along

262
00:09:17,200 --> 00:09:19,120
with the core which accessing and

263
00:09:19,120 --> 00:09:21,440
checking the what cpu is doing and also

264
00:09:21,440 --> 00:09:22,880
there is another part of versa sits in

265
00:09:22,880 --> 00:09:24,800
the memory in the rom region

266
00:09:24,800 --> 00:09:26,720
uh which

267
00:09:26,720 --> 00:09:28,800
which also both the software and

268
00:09:28,800 --> 00:09:30,959
hardware components act in tandem to

269
00:09:30,959 --> 00:09:34,880
provide uh protection of sensor data

270
00:09:34,880 --> 00:09:38,080
and uh versus workflow uh so we have

271
00:09:38,080 --> 00:09:40,160
this controller and we have the device

272
00:09:40,160 --> 00:09:42,640
uh where we have the website

273
00:09:42,640 --> 00:09:45,200
versus enabled so

274
00:09:45,200 --> 00:09:47,920
so gpi memory is always logged

275
00:09:47,920 --> 00:09:50,800
by versa hardware that is it does not

276
00:09:50,800 --> 00:09:52,240
allow any software on the device to

277
00:09:52,240 --> 00:09:53,519
access it

278
00:09:53,519 --> 00:09:56,320
so when uh when the controller wants to

279
00:09:56,320 --> 00:09:58,720
read something from this from this

280
00:09:58,720 --> 00:10:01,040
mcu then it will authorize using

281
00:10:01,040 --> 00:10:02,000
authorized

282
00:10:02,000 --> 00:10:03,839
procedure that is to authorize a

283
00:10:03,839 --> 00:10:04,880
software

284
00:10:04,880 --> 00:10:06,640
and it will it will generate something

285
00:10:06,640 --> 00:10:08,079
called as an a token authentication

286
00:10:08,079 --> 00:10:09,360
token

287
00:10:09,360 --> 00:10:11,680
which corresponds to the proper software

288
00:10:11,680 --> 00:10:13,120
this is typically implemented using a

289
00:10:13,120 --> 00:10:15,760
hmac or any attacking algorithm can do

290
00:10:15,760 --> 00:10:16,880
this

291
00:10:16,880 --> 00:10:17,760
and

292
00:10:17,760 --> 00:10:19,360
and this software and the uh

293
00:10:19,360 --> 00:10:21,760
authentication has sent to the

294
00:10:21,760 --> 00:10:23,760
device and software is installed on the

295
00:10:23,760 --> 00:10:24,720
device

296
00:10:24,720 --> 00:10:27,040
so there is also another way of doing it

297
00:10:27,040 --> 00:10:28,959
instead of always sending the software

298
00:10:28,959 --> 00:10:30,560
you can pre-install the software and

299
00:10:30,560 --> 00:10:32,800
make sure whenever you want to use it or

300
00:10:32,800 --> 00:10:34,800
send a new new a token

301
00:10:34,800 --> 00:10:37,519
make sure it is fresh by using a nonce

302
00:10:37,519 --> 00:10:40,240
and once uh it is there uh versa

303
00:10:40,240 --> 00:10:42,399
software component uh implements uh

304
00:10:42,399 --> 00:10:44,800
something called as verify this verify

305
00:10:44,800 --> 00:10:47,760
takes uh the software and the ito can

306
00:10:47,760 --> 00:10:49,440
see whether these two are correspond to

307
00:10:49,440 --> 00:10:50,640
each other

308
00:10:50,640 --> 00:10:51,920
if they are not corresponding to each

309
00:10:51,920 --> 00:10:55,760
other then gpi memory is still logged

310
00:10:55,760 --> 00:10:57,040
but if they are corresponding to each

311
00:10:57,040 --> 00:10:59,360
other then it unlocks the gpi memory for

312
00:10:59,360 --> 00:11:01,040
you to access it or for the software to

313
00:11:01,040 --> 00:11:02,480
access it

314
00:11:02,480 --> 00:11:04,640
and the next one is

315
00:11:04,640 --> 00:11:06,320
we invoke atomic execution of this

316
00:11:06,320 --> 00:11:08,800
software that is we need to make sure

317
00:11:08,800 --> 00:11:10,399
that the software is not disturbed by

318
00:11:10,399 --> 00:11:12,959
any other program on the on the mcu not

319
00:11:12,959 --> 00:11:15,360
even dmas not even interrupts or any

320
00:11:15,360 --> 00:11:18,560
other software and

321
00:11:18,560 --> 00:11:20,320
after computation the software can

322
00:11:20,320 --> 00:11:21,760
choose to encrypt the results and send

323
00:11:21,760 --> 00:11:23,760
back to the controller

324
00:11:23,760 --> 00:11:26,320
so i i say choose here because there

325
00:11:26,320 --> 00:11:28,800
could be some applications where the

326
00:11:28,800 --> 00:11:30,480
controller need not

327
00:11:30,480 --> 00:11:32,240
want to have any results but they could

328
00:11:32,240 --> 00:11:33,760
just have a local

329
00:11:33,760 --> 00:11:35,760
actuation happening for example in a

330
00:11:35,760 --> 00:11:38,240
thermostat you can if you set sweat to

331
00:11:38,240 --> 00:11:40,000
some temperature if the temperature is

332
00:11:40,000 --> 00:11:42,640
below that uh that threshold then the

333
00:11:42,640 --> 00:11:44,480
air conditioning can start heat up it

334
00:11:44,480 --> 00:11:46,320
need not let the controller know all the

335
00:11:46,320 --> 00:11:47,760
time

336
00:11:47,760 --> 00:11:49,839
so yeah this is the basic workflow of

337
00:11:49,839 --> 00:11:50,880
versa

338
00:11:50,880 --> 00:11:51,600
and

339
00:11:51,600 --> 00:11:53,600
now let's uh go into what are the

340
00:11:53,600 --> 00:11:55,040
features of versa

341
00:11:55,040 --> 00:11:56,800
the first one is access control to sense

342
00:11:56,800 --> 00:11:59,360
data that is only authorized software is

343
00:11:59,360 --> 00:12:01,279
allowed to access gpio

344
00:12:01,279 --> 00:12:04,000
and otherwise any other software if

345
00:12:04,000 --> 00:12:06,240
trying to access gpio or any sensor

346
00:12:06,240 --> 00:12:07,680
information

347
00:12:07,680 --> 00:12:09,360
we will reset the device

348
00:12:09,360 --> 00:12:11,120
so we won't we won't allow it by

349
00:12:11,120 --> 00:12:12,880
resetting it any time it does it will

350
00:12:12,880 --> 00:12:14,079
just reset

351
00:12:14,079 --> 00:12:15,600
so this is how we

352
00:12:15,600 --> 00:12:18,079
we maintain this latch

353
00:12:18,079 --> 00:12:20,000
then atomic execution of authorized

354
00:12:20,000 --> 00:12:22,959
software that is no interrupts or dma

355
00:12:22,959 --> 00:12:25,600
are allowed during versa software uh

356
00:12:25,600 --> 00:12:28,000
using authorized software execution

357
00:12:28,000 --> 00:12:30,160
so what could happen is if the if there

358
00:12:30,160 --> 00:12:31,839
are interrupts then you can just

359
00:12:31,839 --> 00:12:33,760
interrupt the execution of the software

360
00:12:33,760 --> 00:12:34,510
and then you can

361
00:12:34,510 --> 00:12:35,839
[Music]

362
00:12:35,839 --> 00:12:37,519
extract secrets from the tainted

363
00:12:37,519 --> 00:12:39,200
information in the stack

364
00:12:39,200 --> 00:12:40,240
so

365
00:12:40,240 --> 00:12:42,480
that shouldn't happen so that's why

366
00:12:42,480 --> 00:12:44,320
versa locks it uh it doesn't allow any

367
00:12:44,320 --> 00:12:45,760
interrupts or dma

368
00:12:45,760 --> 00:12:48,160
and then s need to start from its legal

369
00:12:48,160 --> 00:12:49,279
entry point that is the first

370
00:12:49,279 --> 00:12:51,279
instruction to its legal exit point that

371
00:12:51,279 --> 00:12:53,040
is the last instruction

372
00:12:53,040 --> 00:12:56,000
um and also s must implement

373
00:12:56,000 --> 00:12:57,600
self cleanup protein that erases its

374
00:12:57,600 --> 00:12:59,519
stack after execution

375
00:12:59,519 --> 00:13:01,600
so the reason that we want s to

376
00:13:01,600 --> 00:13:03,120
implement this cleanup protein and not

377
00:13:03,120 --> 00:13:06,880
versa because ah so as uh the developer

378
00:13:06,880 --> 00:13:08,720
who who writes as uh will know how much

379
00:13:08,720 --> 00:13:10,800
stack it uses so it's easy for them to

380
00:13:10,800 --> 00:13:13,440
actually uh go ahead and clean it up but

381
00:13:13,440 --> 00:13:14,639
in on the on the other hand if burst

382
00:13:14,639 --> 00:13:16,000
needs to clean up then you need to clear

383
00:13:16,000 --> 00:13:17,120
the whole

384
00:13:17,120 --> 00:13:19,440
dram and that is huge and that incur a

385
00:13:19,440 --> 00:13:22,560
lot of performance cost

386
00:13:22,560 --> 00:13:25,279
and the other feature of versa is data

387
00:13:25,279 --> 00:13:26,800
eraser at boot

388
00:13:26,800 --> 00:13:27,839
that is

389
00:13:27,839 --> 00:13:29,680
if something happens during any

390
00:13:29,680 --> 00:13:31,760
violation occurs during atomic execution

391
00:13:31,760 --> 00:13:34,480
or during access control then

392
00:13:34,480 --> 00:13:36,160
the way versa act is by resetting the

393
00:13:36,160 --> 00:13:39,040
device that means when whenever you uh

394
00:13:39,040 --> 00:13:41,440
during execution if you reset then

395
00:13:41,440 --> 00:13:43,440
there could be some information in the

396
00:13:43,440 --> 00:13:44,959
stack left over

397
00:13:44,959 --> 00:13:47,600
and when you come back after reboot

398
00:13:47,600 --> 00:13:48,880
the malware on the device can still

399
00:13:48,880 --> 00:13:50,240
access this information and try to

400
00:13:50,240 --> 00:13:52,720
extract some information so so we don't

401
00:13:52,720 --> 00:13:54,320
want that to happen we want to make sure

402
00:13:54,320 --> 00:13:56,880
that the stack is cleaned up

403
00:13:56,880 --> 00:13:58,639
at any point of time so we need to clean

404
00:13:58,639 --> 00:14:00,959
up at boot so make sure there is no

405
00:14:00,959 --> 00:14:03,440
information left

406
00:14:03,440 --> 00:14:05,040
and now the let's talk about some

407
00:14:05,040 --> 00:14:06,959
hardware properties that

408
00:14:06,959 --> 00:14:10,000
we implement on for versa that is let's

409
00:14:10,000 --> 00:14:12,160
say authorized software is placed in

410
00:14:12,160 --> 00:14:13,519
configured memory region called

411
00:14:13,519 --> 00:14:15,680
executable region er

412
00:14:15,680 --> 00:14:16,959
and

413
00:14:16,959 --> 00:14:18,800
and let's say the pc reaches an

414
00:14:18,800 --> 00:14:20,480
instruction called iot

415
00:14:20,480 --> 00:14:23,199
uh when or when the er software in the

416
00:14:23,199 --> 00:14:25,680
er is authorized to access gpio so this

417
00:14:25,680 --> 00:14:27,600
is how we'll get to know that

418
00:14:27,600 --> 00:14:30,000
software is authorized

419
00:14:30,000 --> 00:14:31,360
so versa

420
00:14:31,360 --> 00:14:34,000
resets the device whenever

421
00:14:34,000 --> 00:14:35,680
certain violations occur that that are

422
00:14:35,680 --> 00:14:37,279
these

423
00:14:37,279 --> 00:14:39,760
so we lock gp access by default to every

424
00:14:39,760 --> 00:14:41,760
every software on the device and

425
00:14:41,760 --> 00:14:43,760
unlock gpi access selectively to only

426
00:14:43,760 --> 00:14:45,839
authorize software and that too only

427
00:14:45,839 --> 00:14:48,480
while that software is executing

428
00:14:48,480 --> 00:14:51,279
so these are properties uh i'm

429
00:14:51,279 --> 00:14:53,199
so due in interest of time i won't be

430
00:14:53,199 --> 00:14:54,399
going into detail of these properties

431
00:14:54,399 --> 00:14:55,199
but

432
00:14:55,199 --> 00:14:58,000
the second property here is read gpio

433
00:14:58,000 --> 00:15:01,040
and if the pc is not in er then we reset

434
00:15:01,040 --> 00:15:02,560
yes

435
00:15:02,560 --> 00:15:04,399
so yeah and

436
00:15:04,399 --> 00:15:07,040
atomic execution of the software

437
00:15:07,040 --> 00:15:08,959
so when er is executing there should be

438
00:15:08,959 --> 00:15:11,360
no dma or interrupts occurring

439
00:15:11,360 --> 00:15:13,360
if you occur then you reset

440
00:15:13,360 --> 00:15:15,120
and similarly s need to start for first

441
00:15:15,120 --> 00:15:18,720
instruction and end at last instruction

442
00:15:18,720 --> 00:15:19,680
and

443
00:15:19,680 --> 00:15:22,079
if er is modified at any point of time

444
00:15:22,079 --> 00:15:23,760
or even before

445
00:15:23,760 --> 00:15:26,240
after authorization and before starting

446
00:15:26,240 --> 00:15:29,120
er then that means you are not

447
00:15:29,120 --> 00:15:30,079
authorized

448
00:15:30,079 --> 00:15:32,320
we should not be authorizing a wrong er

449
00:15:32,320 --> 00:15:34,720
so whenever this modification occurs we

450
00:15:34,720 --> 00:15:37,199
revoke access to gpio and we need

451
00:15:37,199 --> 00:15:39,759
re-verification of air again

452
00:15:39,759 --> 00:15:41,360
that is the last property

453
00:15:41,360 --> 00:15:43,759
and so this is a sample state machine

454
00:15:43,759 --> 00:15:46,560
for the the core ones so we started the

455
00:15:46,560 --> 00:15:48,399
initial reset state and we go to lock

456
00:15:48,399 --> 00:15:50,560
state so whenever the authorization hits

457
00:15:50,560 --> 00:15:52,320
we go to unlock state

458
00:15:52,320 --> 00:15:54,240
and then if something happens at this

459
00:15:54,240 --> 00:15:55,759
unlock state if some other property is

460
00:15:55,759 --> 00:15:58,240
trying to read gpio be reset

461
00:15:58,240 --> 00:16:00,000
and as soon as you complete the software

462
00:16:00,000 --> 00:16:03,040
you go back to the lock state

463
00:16:03,920 --> 00:16:05,680
um so this is a form verification

464
00:16:05,680 --> 00:16:08,160
pipeline so we implement versailles in

465
00:16:08,160 --> 00:16:09,759
verilog some say there are several

466
00:16:09,759 --> 00:16:11,839
hardware modules and these hardware

467
00:16:11,839 --> 00:16:13,839
modules adhere to these uh sub

468
00:16:13,839 --> 00:16:15,360
properties that we have seen in the

469
00:16:15,360 --> 00:16:17,040
previous slide

470
00:16:17,040 --> 00:16:19,120
and then there is a machine model which

471
00:16:19,120 --> 00:16:21,680
are we examinize our

472
00:16:21,680 --> 00:16:22,480
the

473
00:16:22,480 --> 00:16:26,000
mcu that we are using and and we plug in

474
00:16:26,000 --> 00:16:27,839
as these these are assumptions and

475
00:16:27,839 --> 00:16:28,959
axioms

476
00:16:28,959 --> 00:16:30,240
about the machine

477
00:16:30,240 --> 00:16:34,079
and then we use a new svm symbolic model

478
00:16:34,079 --> 00:16:36,079
verifier to check whether this verilog

479
00:16:36,079 --> 00:16:38,720
code is uh you know is maintaining all

480
00:16:38,720 --> 00:16:40,720
the properties of these these uh you

481
00:16:40,720 --> 00:16:42,320
know these properties

482
00:16:42,320 --> 00:16:44,720
uh and after that we use spot to

483
00:16:44,720 --> 00:16:46,480
actually make sure that these properties

484
00:16:46,480 --> 00:16:48,800
that we wrote actually mean some

485
00:16:48,800 --> 00:16:50,399
access control gpio or automatic

486
00:16:50,399 --> 00:16:51,759
resolution apps

487
00:16:51,759 --> 00:16:54,079
so this is a two-way proof

488
00:16:54,079 --> 00:16:56,480
and then we use we use we implement a

489
00:16:56,480 --> 00:16:58,160
versa software using hacker's formula

490
00:16:58,160 --> 00:17:00,320
verify library so we get the verify

491
00:17:00,320 --> 00:17:02,000
routine with that so all these things

492
00:17:02,000 --> 00:17:05,599
together form privacy from birth

493
00:17:05,599 --> 00:17:07,679
and implementation versa is built on

494
00:17:07,679 --> 00:17:09,119
open msp

495
00:17:09,119 --> 00:17:10,880
and synthesized and deployed on a basis

496
00:17:10,880 --> 00:17:12,559
three fpga

497
00:17:12,559 --> 00:17:15,280
so we use raised for implementing uh

498
00:17:15,280 --> 00:17:16,559
verify routine which is a formally

499
00:17:16,559 --> 00:17:19,119
verified limited station architecture

500
00:17:19,119 --> 00:17:20,559
and then upper implementation open

501
00:17:20,559 --> 00:17:23,599
sourced at this particular location

502
00:17:23,599 --> 00:17:25,760
so the hardware overhead of bursa is

503
00:17:25,760 --> 00:17:28,319
like this we

504
00:17:28,319 --> 00:17:30,880
so it has 13 percent extra we need

505
00:17:30,880 --> 00:17:32,799
certain person more hardware on openmsp

506
00:17:32,799 --> 00:17:33,600
core

507
00:17:33,600 --> 00:17:35,360
and it has 10 plus more hardware

508
00:17:35,360 --> 00:17:37,520
overhead on braised which was

509
00:17:37,520 --> 00:17:40,160
one of the subroutines that we use

510
00:17:40,160 --> 00:17:43,200
and comparison to other architectures

511
00:17:43,200 --> 00:17:44,840
versa is comparable to other

512
00:17:44,840 --> 00:17:46,799
architectures which are hybrid

513
00:17:46,799 --> 00:17:48,400
architectures both software and hardware

514
00:17:48,400 --> 00:17:49,919
core designs

515
00:17:49,919 --> 00:17:51,360
on the other hand there is tankers which

516
00:17:51,360 --> 00:17:53,760
is very fast compared to all the cyber

517
00:17:53,760 --> 00:17:55,520
architectures but it's purely built on

518
00:17:55,520 --> 00:17:56,559
hardware

519
00:17:56,559 --> 00:17:57,679
so

520
00:17:57,679 --> 00:17:59,760
conclusion is versa hardware road has

521
00:17:59,760 --> 00:18:02,000
come comparable to other hybrid

522
00:18:02,000 --> 00:18:04,080
architectures

523
00:18:04,080 --> 00:18:06,720
so and run time for verify so we

524
00:18:06,720 --> 00:18:08,400
evaluated runtime on verify on three

525
00:18:08,400 --> 00:18:12,960
cases and we saw that it uh so naturally

526
00:18:12,960 --> 00:18:15,679
since the verifies you is implemented

527
00:18:15,679 --> 00:18:17,600
using hmac which

528
00:18:17,600 --> 00:18:20,320
grows the time taking for hmac

529
00:18:20,320 --> 00:18:22,480
implementation grows as the binary size

530
00:18:22,480 --> 00:18:23,600
increases

531
00:18:23,600 --> 00:18:26,960
and that is linear growth

532
00:18:26,960 --> 00:18:28,720
and the main takeaways are like this

533
00:18:28,720 --> 00:18:30,720
privacy from birth uh this is an

534
00:18:30,720 --> 00:18:32,240
end-to-end

535
00:18:32,240 --> 00:18:34,559
privacy assurance architecture for

536
00:18:34,559 --> 00:18:36,080
low-end iots

537
00:18:36,080 --> 00:18:38,880
and we formalize and define pfp in our

538
00:18:38,880 --> 00:18:41,760
paper and there is versa which is which

539
00:18:41,760 --> 00:18:44,559
probably implements uh pfb

540
00:18:44,559 --> 00:18:49,039
uh and it also it basically implements a

541
00:18:49,039 --> 00:18:51,200
minimal formally verified hardware

542
00:18:51,200 --> 00:18:54,000
um and we deploy it on openmsp and it

543
00:18:54,000 --> 00:18:56,480
has 13 percent hardware overhead

544
00:18:56,480 --> 00:18:59,440
so this the paper link and github link

545
00:18:59,440 --> 00:19:01,440
in my contact

546
00:19:01,440 --> 00:19:03,020
all right let's thank the speaker

547
00:19:03,020 --> 00:19:07,679
[Applause]

548
00:19:07,679 --> 00:19:08,799
we have a couple of minutes for

549
00:19:08,799 --> 00:19:11,120
questions

550
00:19:11,360 --> 00:19:13,840
hello general from ohio state university

551
00:19:13,840 --> 00:19:16,240
so very great work i have a question

552
00:19:16,240 --> 00:19:17,280
about

553
00:19:17,280 --> 00:19:19,120
actually it comes about the cost so you

554
00:19:19,120 --> 00:19:20,799
said that you

555
00:19:20,799 --> 00:19:23,520
your product is deployed on

556
00:19:23,520 --> 00:19:24,960
your system is deployed on something

557
00:19:24,960 --> 00:19:28,320
like very low cost mcu so i know in your

558
00:19:28,320 --> 00:19:30,400
implementation you use fpga that's

559
00:19:30,400 --> 00:19:32,000
that's not feasible in phys in

560
00:19:32,000 --> 00:19:34,559
production but how would you feel that

561
00:19:34,559 --> 00:19:36,160
how would you feel about the cost if you

562
00:19:36,160 --> 00:19:38,720
make your system into i6 like those mini

563
00:19:38,720 --> 00:19:39,679
chips

564
00:19:39,679 --> 00:19:42,799
yeah so that's a great question so uh we

565
00:19:42,799 --> 00:19:45,200
implement it on openmsp so this is an

566
00:19:45,200 --> 00:19:47,679
open source architecture of msp which is

567
00:19:47,679 --> 00:19:49,600
from texas instruments

568
00:19:49,600 --> 00:19:52,080
and this openmsp is very close to the

569
00:19:52,080 --> 00:19:55,039
real msp and whatever

570
00:19:55,039 --> 00:19:57,600
additions we have from versa hardware

571
00:19:57,600 --> 00:20:00,559
they need a few more d flip flops and

572
00:20:00,559 --> 00:20:02,960
few more

573
00:20:03,600 --> 00:20:05,840
some hardware components which scale

574
00:20:05,840 --> 00:20:08,640
like or 13 over open msp so whatever

575
00:20:08,640 --> 00:20:10,720
cost is required to

576
00:20:10,720 --> 00:20:13,280
make an open msp chip

577
00:20:13,280 --> 00:20:16,400
if you add 13 13 or 20 uh 13 15 percent

578
00:20:16,400 --> 00:20:19,919
extra on it then you could ah get this

579
00:20:19,919 --> 00:20:21,520
in the real world but

580
00:20:21,520 --> 00:20:24,400
obviously this is a a resource prototype

581
00:20:24,400 --> 00:20:26,960
so if it actually gets into production i

582
00:20:26,960 --> 00:20:28,159
really want to see if it gets into

583
00:20:28,159 --> 00:20:30,400
production but yeah it it might take a

584
00:20:30,400 --> 00:20:34,520
while yeah thank you

585
00:20:34,720 --> 00:20:36,720
hey thanks for your talk alejandro mera

586
00:20:36,720 --> 00:20:39,679
from northeastern university so i would

587
00:20:39,679 --> 00:20:41,280
like to know what are your thoughts

588
00:20:41,280 --> 00:20:43,760
about the applicability of your solution

589
00:20:43,760 --> 00:20:45,440
considering that

590
00:20:45,440 --> 00:20:48,480
these or or these type of security

591
00:20:48,480 --> 00:20:50,799
features are not available and you are

592
00:20:50,799 --> 00:20:52,240
proposing something that is even

593
00:20:52,240 --> 00:20:55,520
academic yeah thank you yeah so yes yeah

594
00:20:55,520 --> 00:20:56,320
so

595
00:20:56,320 --> 00:20:59,280
this research uh is uh targeted for

596
00:20:59,280 --> 00:21:02,000
low-end devices which as you said uh you

597
00:21:02,000 --> 00:21:04,640
we don't get any uh security mechanisms

598
00:21:04,640 --> 00:21:08,400
like mpu or mmu so if if you want if and

599
00:21:08,400 --> 00:21:10,720
these devices do uh do a lot of critical

600
00:21:10,720 --> 00:21:12,480
computations so

601
00:21:12,480 --> 00:21:14,559
if we want security on these devices the

602
00:21:14,559 --> 00:21:16,559
only way to go forward with this is to

603
00:21:16,559 --> 00:21:17,440
either

604
00:21:17,440 --> 00:21:19,760
either use a let's say trust zone enable

605
00:21:19,760 --> 00:21:21,280
devices which are slightly higher and

606
00:21:21,280 --> 00:21:23,360
slightly costlier and then you get all

607
00:21:23,360 --> 00:21:25,360
these things for free or but if you

608
00:21:25,360 --> 00:21:26,880
still want to be in the low end spectrum

609
00:21:26,880 --> 00:21:28,240
and still want to use them there is no

610
00:21:28,240 --> 00:21:31,120
other way except to use this so yeah

611
00:21:31,120 --> 00:21:33,039
it's a trade-off ah i mean currently

612
00:21:33,039 --> 00:21:34,480
they are not available so the only thing

613
00:21:34,480 --> 00:21:36,000
available is trust zone enable devices

614
00:21:36,000 --> 00:21:38,400
for low end so that needs a little more

615
00:21:38,400 --> 00:21:39,280
cost

616
00:21:39,280 --> 00:21:42,559
but this one is has much less cost in

617
00:21:42,559 --> 00:21:44,240
when you put into assembly line and try

618
00:21:44,240 --> 00:21:47,679
and try to manufacture them

619
00:21:48,880 --> 00:21:53,720
all right let's thank the speaker thanks

