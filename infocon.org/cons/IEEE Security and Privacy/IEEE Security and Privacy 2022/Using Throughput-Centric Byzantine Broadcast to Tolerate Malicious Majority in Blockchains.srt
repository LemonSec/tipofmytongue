1
00:00:03,600 --> 00:00:05,359
i'm from national university of

2
00:00:05,359 --> 00:00:07,440
singapore i'm glad to present to you the

3
00:00:07,440 --> 00:00:10,000
work i have done with iphone and pratik

4
00:00:10,000 --> 00:00:12,799
which is to tolerate malicious majority

5
00:00:12,799 --> 00:00:15,280
in blockchains

6
00:00:15,280 --> 00:00:17,600
polarity malicious anniversary is a key

7
00:00:17,600 --> 00:00:20,000
property of many distributed systems

8
00:00:20,000 --> 00:00:21,680
such as blockchains

9
00:00:21,680 --> 00:00:24,400
we offer 254 dollars per half the

10
00:00:24,400 --> 00:00:26,640
fraction of atmospheric power the system

11
00:00:26,640 --> 00:00:28,000
can tolerate

12
00:00:28,000 --> 00:00:29,199
for example

13
00:00:29,199 --> 00:00:31,439
improve of work blockchains such as

14
00:00:31,439 --> 00:00:34,320
bitcoin this f refers to the fraction of

15
00:00:34,320 --> 00:00:36,399
malicious computational power and

16
00:00:36,399 --> 00:00:40,320
bitcoin tolerance f up to 0.5

17
00:00:40,320 --> 00:00:42,559
improve of state blockchains such as

18
00:00:42,559 --> 00:00:44,719
algorithms this app refers to the

19
00:00:44,719 --> 00:00:46,800
fraction of states held by the malicious

20
00:00:46,800 --> 00:00:49,280
nodes and algorithm can tolerate up to

21
00:00:49,280 --> 00:00:50,960
one third

22
00:00:50,960 --> 00:00:52,960
despite blockchains are much faster

23
00:00:52,960 --> 00:00:55,600
today they can only still turret at

24
00:00:55,600 --> 00:00:58,000
below 0.5 which is no better than

25
00:00:58,000 --> 00:01:00,239
bitcoin more than 10 years ago

26
00:01:00,239 --> 00:01:02,559
at the same time there are growing needs

27
00:01:02,559 --> 00:01:04,239
for blockchains to tolerate the lab

28
00:01:04,239 --> 00:01:05,760
above my time

29
00:01:05,760 --> 00:01:08,080
first we have seen adversaries that

30
00:01:08,080 --> 00:01:11,200
actually managed to have alpha 1.5

31
00:01:11,200 --> 00:01:13,200
secondly in many groups of work and

32
00:01:13,200 --> 00:01:15,280
proof of stake blockchains a few

33
00:01:15,280 --> 00:01:18,000
centralized miners control the majority

34
00:01:18,000 --> 00:01:20,159
of mining power or stake

35
00:01:20,159 --> 00:01:24,360
here are some relevant headlines

36
00:01:29,119 --> 00:01:31,439
it is obviously always good to tolerate

37
00:01:31,439 --> 00:01:34,240
the live graph but is it possible at all

38
00:01:34,240 --> 00:01:37,680
to tolerate f larger than 0.5

39
00:01:37,680 --> 00:01:39,439
we quickly comment on this before

40
00:01:39,439 --> 00:01:41,600
proceeding people think it's not

41
00:01:41,600 --> 00:01:43,439
possible because many existing

42
00:01:43,439 --> 00:01:45,280
blockchains build upon presenting

43
00:01:45,280 --> 00:01:47,840
agreements it is true that identity

44
00:01:47,840 --> 00:01:51,200
agreements cannot tolerate at about 0.5

45
00:01:51,200 --> 00:01:53,520
so such blockchains can never deal with

46
00:01:53,520 --> 00:01:55,520
aftermath multiplier

47
00:01:55,520 --> 00:01:57,840
however this limitation does not carry

48
00:01:57,840 --> 00:02:00,320
over to blockchains the reason is

49
00:02:00,320 --> 00:02:03,040
byzantine agreement is a one-shot game

50
00:02:03,040 --> 00:02:05,439
it takes in some input and makes one

51
00:02:05,439 --> 00:02:07,759
decision the protocol need to ensure

52
00:02:07,759 --> 00:02:11,200
that this decision is always good

53
00:02:11,200 --> 00:02:13,840
in contrast a blockchain generates a

54
00:02:13,840 --> 00:02:16,160
sequence of blocks instead of a single

55
00:02:16,160 --> 00:02:18,800
block it is ok for some of the blocks to

56
00:02:18,800 --> 00:02:21,200
be generated by the atmosphere for

57
00:02:21,200 --> 00:02:23,120
example in bitcoin

58
00:02:23,120 --> 00:02:25,360
it is perfectly okay if the adversary

59
00:02:25,360 --> 00:02:27,040
mines some blocks in the final

60
00:02:27,040 --> 00:02:29,360
blockchain

61
00:02:29,360 --> 00:02:31,360
in this work we propose a novel

62
00:02:31,360 --> 00:02:33,360
blockchain called bq

63
00:02:33,360 --> 00:02:36,080
bq is the first blockchain system that

64
00:02:36,080 --> 00:02:38,319
can tolerate a malicious majority while

65
00:02:38,319 --> 00:02:41,200
providing practically useful performance

66
00:02:41,200 --> 00:02:44,319
instead of using presenting agreement pq

67
00:02:44,319 --> 00:02:48,000
uses presentative broadcast as a support

68
00:02:48,000 --> 00:02:50,080
in the present broadcast problem a

69
00:02:50,080 --> 00:02:52,080
publicly known broadcaster wants to

70
00:02:52,080 --> 00:02:54,480
broadcast the block to all nodes

71
00:02:54,480 --> 00:02:56,800
this broadcaster may or may not be

72
00:02:56,800 --> 00:02:58,720
honest

73
00:02:58,720 --> 00:03:01,280
this protocol guarantees two things

74
00:03:01,280 --> 00:03:03,599
first all honest notes will agree our

75
00:03:03,599 --> 00:03:04,959
blog

76
00:03:04,959 --> 00:03:07,599
two if the broadcaster is honest all

77
00:03:07,599 --> 00:03:09,280
honest notes should agree on the

78
00:03:09,280 --> 00:03:11,440
broadcaster's block

79
00:03:11,440 --> 00:03:13,200
different from byzantine agreement

80
00:03:13,200 --> 00:03:15,440
presenting broadcaster is solvable even

81
00:03:15,440 --> 00:03:18,879
when f is above 0.5

82
00:03:18,879 --> 00:03:20,560
one can easily build a blockchain with

83
00:03:20,560 --> 00:03:23,200
byzantine broadcast the system first

84
00:03:23,200 --> 00:03:25,920
chooses a random node as the block poser

85
00:03:25,920 --> 00:03:27,920
to construct a block

86
00:03:27,920 --> 00:03:30,400
next using byzantine broadcast the

87
00:03:30,400 --> 00:03:32,640
proposer disseminated the block

88
00:03:32,640 --> 00:03:34,879
this will then be the next block in the

89
00:03:34,879 --> 00:03:36,159
blockchain

90
00:03:36,159 --> 00:03:38,400
this repeats periodically to add new

91
00:03:38,400 --> 00:03:40,400
blocks into the chain

92
00:03:40,400 --> 00:03:43,360
there is no fog a block is confirmed as

93
00:03:43,360 --> 00:03:45,040
soon as the corresponding presenting

94
00:03:45,040 --> 00:03:48,480
broadcast protocol finishes

95
00:03:48,720 --> 00:03:50,159
it seems that

96
00:03:50,159 --> 00:03:51,920
now we can easily build a blockchain

97
00:03:51,920 --> 00:03:53,519
using byzantine broadcast and the

98
00:03:53,519 --> 00:03:55,280
resulting blockchain will be able to

99
00:03:55,280 --> 00:03:57,760
tolerate f above 0.5

100
00:03:57,760 --> 00:03:59,920
however the key obstacle is that the

101
00:03:59,920 --> 00:04:02,000
resulting blockchain will have very low

102
00:04:02,000 --> 00:04:03,040
throughput

103
00:04:03,040 --> 00:04:05,360
let us clearly define throughput the

104
00:04:05,360 --> 00:04:07,519
throughput of a blockchain is simply the

105
00:04:07,519 --> 00:04:09,599
number of transactions it can process

106
00:04:09,599 --> 00:04:10,720
every second

107
00:04:10,720 --> 00:04:12,959
for example if a blockchain outputs a 10

108
00:04:12,959 --> 00:04:15,360
megabits block every one minutes then we

109
00:04:15,360 --> 00:04:20,639
say its throughput is 167 kbps

110
00:04:20,639 --> 00:04:22,560
there are many existing byzantine

111
00:04:22,560 --> 00:04:24,880
broadcast protocols if we simply use

112
00:04:24,880 --> 00:04:27,199
those protocols to build blockchains the

113
00:04:27,199 --> 00:04:29,440
resulting blockchain will have miserable

114
00:04:29,440 --> 00:04:32,080
throughput for example under our

115
00:04:32,080 --> 00:04:34,000
experiment setting if we use the

116
00:04:34,000 --> 00:04:35,919
well-known dollar strong byzantine

117
00:04:35,919 --> 00:04:37,600
broadcast protocol

118
00:04:37,600 --> 00:04:40,440
the resulting blockchain will only have

119
00:04:40,440 --> 00:04:43,120
0.072 kbps throughput

120
00:04:43,120 --> 00:04:47,600
more examples available in our paper

121
00:04:47,919 --> 00:04:50,400
overcoming this challenge is our central

122
00:04:50,400 --> 00:04:53,280
technical contribution specifically we

123
00:04:53,280 --> 00:04:55,280
propose a novel byzantine broadcast

124
00:04:55,280 --> 00:04:57,520
protocol called overlay bb

125
00:04:57,520 --> 00:05:00,240
that can achieve orders of magnitude

126
00:05:00,240 --> 00:05:02,080
better throughput than existing

127
00:05:02,080 --> 00:05:03,440
protocols

128
00:05:03,440 --> 00:05:06,240
using overlay bb as the core our bq

129
00:05:06,240 --> 00:05:08,000
blockchain can tolerate a malicious

130
00:05:08,000 --> 00:05:10,400
majority while providing practically

131
00:05:10,400 --> 00:05:12,240
usable performance

132
00:05:12,240 --> 00:05:14,560
specifically we have implemented a

133
00:05:14,560 --> 00:05:16,320
research prototype and have run

134
00:05:16,320 --> 00:05:19,919
experiments with 10 000 b cubed nodes

135
00:05:19,919 --> 00:05:23,280
in our experiment with f equal to 0.7

136
00:05:23,280 --> 00:05:26,400
big cube achieves a throughput of 163

137
00:05:26,400 --> 00:05:27,680
kbps

138
00:05:27,680 --> 00:05:30,479
this is more than 2000 times of what

139
00:05:30,479 --> 00:05:32,320
could be achieved using the dollar straw

140
00:05:32,320 --> 00:05:33,759
vertical

141
00:05:33,759 --> 00:05:35,919
this throughput is certainly not on par

142
00:05:35,919 --> 00:05:38,479
with blockchains such as algorand that

143
00:05:38,479 --> 00:05:41,360
can only tolerate a malicious minority

144
00:05:41,360 --> 00:05:43,440
however this throughput is already

145
00:05:43,440 --> 00:05:45,520
practically usable

146
00:05:45,520 --> 00:05:47,120
as a reference point

147
00:05:47,120 --> 00:05:51,440
bitcoin only have 14 kbps input

148
00:05:51,440 --> 00:05:53,680
our paper further explains that b-cube

149
00:05:53,680 --> 00:05:55,360
also offers practically useful

150
00:05:55,360 --> 00:05:57,919
confirmation latency

151
00:05:57,919 --> 00:05:59,680
in the following i will first give the

152
00:05:59,680 --> 00:06:02,319
system an attack model then i will talk

153
00:06:02,319 --> 00:06:04,560
about the design of b-cube and overlay

154
00:06:04,560 --> 00:06:07,039
bb finally i will present the security

155
00:06:07,039 --> 00:06:09,520
analysis and experimental results

156
00:06:09,520 --> 00:06:11,120
to prepare for more technical

157
00:06:11,120 --> 00:06:13,680
discussions we clarify our settings we

158
00:06:13,680 --> 00:06:15,759
consider permissionless settings without

159
00:06:15,759 --> 00:06:18,800
pki each node has a locally generated

160
00:06:18,800 --> 00:06:21,440
public private key pair an unlimited

161
00:06:21,440 --> 00:06:23,840
fraction of those may be malicious the

162
00:06:23,840 --> 00:06:26,240
malicious nodes are fully presented and

163
00:06:26,240 --> 00:06:28,319
may collude with each other

164
00:06:28,319 --> 00:06:30,400
we use proof of stake to deal with civil

165
00:06:30,400 --> 00:06:32,639
attack in the permission setting

166
00:06:32,639 --> 00:06:35,120
specifically we assume there are sticks

167
00:06:35,120 --> 00:06:37,919
or coins in the system such coins can be

168
00:06:37,919 --> 00:06:39,840
created or transferred from one to

169
00:06:39,840 --> 00:06:42,479
another using blockchain transactions

170
00:06:42,479 --> 00:06:45,280
we assume that at any point of time at

171
00:06:45,280 --> 00:06:47,759
most a fraction of the coins are held by

172
00:06:47,759 --> 00:06:49,120
malicious nodes

173
00:06:49,120 --> 00:06:52,400
nodes are connected via overlay network

174
00:06:52,400 --> 00:06:55,199
we assume that the honest nodes form a

175
00:06:55,199 --> 00:06:58,080
connected component of the overlay

176
00:06:58,080 --> 00:07:00,800
let's look at how b cube is constructed

177
00:07:00,800 --> 00:07:02,880
bqb is a blockchain system running on

178
00:07:02,880 --> 00:07:04,880
many nodes it starts with a genesis

179
00:07:04,880 --> 00:07:07,120
block new blocks are added to b-cube

180
00:07:07,120 --> 00:07:09,840
like this bionicly b-cube uses a random

181
00:07:09,840 --> 00:07:11,919
beacon and the beacon in turn chooses

182
00:07:11,919 --> 00:07:14,319
some state the owner of the stake then

183
00:07:14,319 --> 00:07:16,720
becomes the next block proposal and it

184
00:07:16,720 --> 00:07:18,800
proposes the next block

185
00:07:18,800 --> 00:07:20,880
the block proposed block will then be

186
00:07:20,880 --> 00:07:22,800
disseminated to all the other nodes

187
00:07:22,800 --> 00:07:24,880
using overlay bb presenting broadcast

188
00:07:24,880 --> 00:07:26,319
protocol

189
00:07:26,319 --> 00:07:28,800
then each node as the received block to

190
00:07:28,800 --> 00:07:31,039
its local copy of blockchain

191
00:07:31,039 --> 00:07:33,120
this process will repeat to add new

192
00:07:33,120 --> 00:07:35,280
blocks regularly

193
00:07:35,280 --> 00:07:37,599
recall that overlapv ensures that all

194
00:07:37,599 --> 00:07:40,000
nodes receive the same block later we'll

195
00:07:40,000 --> 00:07:42,160
prove the correctness of b cube using

196
00:07:42,160 --> 00:07:44,800
these properties of overlay bb

197
00:07:44,800 --> 00:07:46,879
as overlay bb is the key we will be

198
00:07:46,879 --> 00:07:50,560
focusing our overlay bb going forward

199
00:07:50,560 --> 00:07:53,039
overlap db is built upon some existing

200
00:07:53,039 --> 00:07:55,120
byzantine broadcast protocols so we

201
00:07:55,120 --> 00:07:57,199
review oneself protocol which is the

202
00:07:57,199 --> 00:07:59,840
dollar strong protocol in which we first

203
00:07:59,840 --> 00:08:02,240
show why the existing protocols can only

204
00:08:02,240 --> 00:08:04,319
give very low throughput then we will

205
00:08:04,319 --> 00:08:06,319
demonstrate how overlapping achieves

206
00:08:06,319 --> 00:08:08,240
much higher support

207
00:08:08,240 --> 00:08:10,400
because dollar strong protocol works in

208
00:08:10,400 --> 00:08:11,840
the following way

209
00:08:11,840 --> 00:08:14,479
in round zero broadcaster a sends an

210
00:08:14,479 --> 00:08:16,400
object to all the nodes with each

211
00:08:16,400 --> 00:08:18,400
signature attached as it could be

212
00:08:18,400 --> 00:08:22,000
malicious and only sent to a subset node

213
00:08:22,000 --> 00:08:24,960
for for each node b it may receive the

214
00:08:24,960 --> 00:08:26,960
object in any of the round t

215
00:08:26,960 --> 00:08:29,759
so if it receives the object the object

216
00:08:29,759 --> 00:08:31,919
is dropped if it has less than t

217
00:08:31,919 --> 00:08:33,839
signatures

218
00:08:33,839 --> 00:08:36,559
otherwise b will accept the object and b

219
00:08:36,559 --> 00:08:38,880
will add its own signature to the object

220
00:08:38,880 --> 00:08:41,599
and for the object to everyone

221
00:08:41,599 --> 00:08:43,200
by folding and attaching its own

222
00:08:43,200 --> 00:08:45,680
signature b ensures that all other nodes

223
00:08:45,680 --> 00:08:47,920
will also accept the object

224
00:08:47,920 --> 00:08:49,760
we know that the protocol needs to run

225
00:08:49,760 --> 00:08:53,600
for many rounds for correctness

226
00:08:53,680 --> 00:08:55,839
this algorithm has very low throughput

227
00:08:55,839 --> 00:08:58,480
because each node only uses one round to

228
00:08:58,480 --> 00:09:00,720
transmit the object among all the runs

229
00:09:00,720 --> 00:09:02,399
in the execution

230
00:09:02,399 --> 00:09:04,800
and which one is being utilized is

231
00:09:04,800 --> 00:09:07,200
determined by the adversary

232
00:09:07,200 --> 00:09:09,360
for example if the algorithm runs for

233
00:09:09,360 --> 00:09:11,839
500 rounds all the bandwidth in the

234
00:09:11,839 --> 00:09:17,200
other 499 rounds are not utilized

235
00:09:17,760 --> 00:09:18,640
so

236
00:09:18,640 --> 00:09:20,480
how do we solve this

237
00:09:20,480 --> 00:09:22,959
the immediate naive idea is that maybe

238
00:09:22,959 --> 00:09:25,200
running more broadcast instances just

239
00:09:25,200 --> 00:09:26,800
solve the problem

240
00:09:26,800 --> 00:09:29,200
uh in this illustration we run many

241
00:09:29,200 --> 00:09:31,839
instances instead of single instances

242
00:09:31,839 --> 00:09:34,000
and we see because of this

243
00:09:34,000 --> 00:09:36,320
more runs i've become more or less

244
00:09:36,320 --> 00:09:38,320
become utilized now

245
00:09:38,320 --> 00:09:42,000
so does this solve our problem

246
00:09:42,000 --> 00:09:43,519
actually no

247
00:09:43,519 --> 00:09:46,240
recall that is the adversary who decide

248
00:09:46,240 --> 00:09:49,200
which one is utilizing each instance so

249
00:09:49,200 --> 00:09:51,519
if the adversary aligns all these rounds

250
00:09:51,519 --> 00:09:53,600
in every instance we are back into

251
00:09:53,600 --> 00:09:56,480
square one most rounds are not utilized

252
00:09:56,480 --> 00:09:57,519
again

253
00:09:57,519 --> 00:09:58,240
so

254
00:09:58,240 --> 00:10:01,200
naive parallelization does not solve our

255
00:10:01,200 --> 00:10:02,640
problem

256
00:10:02,640 --> 00:10:04,800
to have a good throughput overlay bb

257
00:10:04,800 --> 00:10:07,440
still uses parallel instances however

258
00:10:07,440 --> 00:10:09,040
how does it deal with the problem we

259
00:10:09,040 --> 00:10:10,320
mentioned earlier

260
00:10:10,320 --> 00:10:12,800
the idea is that when multiple instances

261
00:10:12,800 --> 00:10:15,120
utilize the same round on a single node

262
00:10:15,120 --> 00:10:17,120
the nodes delay the same event in some

263
00:10:17,120 --> 00:10:20,079
instances for example we have two nodes

264
00:10:20,079 --> 00:10:22,880
a and b here in round t a receive the

265
00:10:22,880 --> 00:10:25,440
object in nine instances by right it

266
00:10:25,440 --> 00:10:27,600
will only utilize the round t plus one

267
00:10:27,600 --> 00:10:30,320
by forwarding all the objects at once we

268
00:10:30,320 --> 00:10:32,640
want to make use of more rounds so it

269
00:10:32,640 --> 00:10:35,040
will not send all objects together

270
00:10:35,040 --> 00:10:37,600
instead they only send m1 in the run t

271
00:10:37,600 --> 00:10:39,920
plus 1 and delay other objects

272
00:10:39,920 --> 00:10:42,480
either send m2 in the round t plus 2 and

273
00:10:42,480 --> 00:10:44,160
so on

274
00:10:44,160 --> 00:10:46,000
now the problem is that when they

275
00:10:46,000 --> 00:10:49,040
receive the object in one t each of them

276
00:10:49,040 --> 00:10:52,240
has two signatures when a forward object

277
00:10:52,240 --> 00:10:55,120
attach its own signature m1 will have t

278
00:10:55,120 --> 00:10:57,519
plus one signature and m2 will also have

279
00:10:57,519 --> 00:10:59,200
t plus one signature

280
00:10:59,200 --> 00:11:01,760
recall that in one t plus one we accept

281
00:11:01,760 --> 00:11:03,760
an object if it has t plus one

282
00:11:03,760 --> 00:11:05,680
signatures

283
00:11:05,680 --> 00:11:08,240
and thus m1 will be accepted

284
00:11:08,240 --> 00:11:10,720
however b would require t plus two

285
00:11:10,720 --> 00:11:13,680
signatures in the round t plus two

286
00:11:13,680 --> 00:11:16,800
so b will refuse to accept m2 as the

287
00:11:16,800 --> 00:11:19,279
number of signatures is fundamental to

288
00:11:19,279 --> 00:11:21,440
agreement b cannot just ignore the

289
00:11:21,440 --> 00:11:24,640
signature issue and accept f2

290
00:11:24,640 --> 00:11:28,000
to still make b accept m2 you overlay bb

291
00:11:28,000 --> 00:11:31,040
a will ask b to compensate for the delay

292
00:11:31,040 --> 00:11:33,440
so that m2 is seen as if it were

293
00:11:33,440 --> 00:11:36,880
received in the run t plus 1 with m1

294
00:11:36,880 --> 00:11:39,200
the observation is that it does have the

295
00:11:39,200 --> 00:11:41,760
evidence to convince b because a were

296
00:11:41,760 --> 00:11:44,959
busy sending m1 in the wrong t plus one

297
00:11:44,959 --> 00:11:46,959
this simple compensation would work

298
00:11:46,959 --> 00:11:49,519
online topology unfortunately things

299
00:11:49,519 --> 00:11:52,240
will get complicated in general topology

300
00:11:52,240 --> 00:11:53,839
in the following example we have four

301
00:11:53,839 --> 00:11:57,120
nodes a b c one and c two if one t node

302
00:11:57,120 --> 00:12:00,079
c one sets f1 to a in the next round t

303
00:12:00,079 --> 00:12:03,519
plus one a forward f1 to b and now c2

304
00:12:03,519 --> 00:12:06,399
will also send m1 to a

305
00:12:06,399 --> 00:12:09,279
c1 has no further piece to send to a

306
00:12:09,279 --> 00:12:12,639
next in the round t plus 2 c 2 sends

307
00:12:12,639 --> 00:12:15,760
m2 to a and ask a to compensate as if f2

308
00:12:15,760 --> 00:12:18,399
were received together with m1

309
00:12:18,399 --> 00:12:21,279
in the last round t plus 3 a4 and m2 to

310
00:12:21,279 --> 00:12:24,000
b for correctness a did not need to ask

311
00:12:24,000 --> 00:12:27,040
b to compensate such that m2 is viewed

312
00:12:27,040 --> 00:12:30,240
as if it were received together with m1

313
00:12:30,240 --> 00:12:33,200
however b now sees a gap between m1 and

314
00:12:33,200 --> 00:12:35,360
m2 and b does not know whether a

315
00:12:35,360 --> 00:12:37,440
maliciously added the gap

316
00:12:37,440 --> 00:12:39,360
and doesn't know whether it wants to

317
00:12:39,360 --> 00:12:41,200
compensate for m2

318
00:12:41,200 --> 00:12:43,200
our paper applies theoretical results

319
00:12:43,200 --> 00:12:45,040
from network propagation to build a

320
00:12:45,040 --> 00:12:47,120
mechanism for nodes to properly

321
00:12:47,120 --> 00:12:49,279
compensate for the message delay caused

322
00:12:49,279 --> 00:12:50,800
by propagating multiple pieces

323
00:12:50,800 --> 00:12:53,680
simultaneously please refer to our paper

324
00:12:53,680 --> 00:12:55,200
for the details

325
00:12:55,200 --> 00:12:57,040
delay compensation has some more

326
00:12:57,040 --> 00:12:59,440
challenges overlapping further uses

327
00:12:59,440 --> 00:13:01,360
committee to run faster the

328
00:13:01,360 --> 00:13:03,360
non-committee nodes need to compensate

329
00:13:03,360 --> 00:13:05,040
in different ways from the committee

330
00:13:05,040 --> 00:13:07,839
notes beyond delay compensation there

331
00:13:07,839 --> 00:13:10,000
are other obstacles we need to overcome

332
00:13:10,000 --> 00:13:12,160
i will briefly highlight some on the

333
00:13:12,160 --> 00:13:14,240
overlay network adversary may run an

334
00:13:14,240 --> 00:13:16,399
injection attack on the relaying nodes

335
00:13:16,399 --> 00:13:18,720
to avoid this attack relaying nodes need

336
00:13:18,720 --> 00:13:21,200
to predict how likely the object will be

337
00:13:21,200 --> 00:13:23,440
accepted and then filter objects based

338
00:13:23,440 --> 00:13:25,120
on the prediction

339
00:13:25,120 --> 00:13:27,600
in instance the adversary may broadcast

340
00:13:27,600 --> 00:13:29,920
more than one object and reduces the

341
00:13:29,920 --> 00:13:32,560
throughput to deal with that we require

342
00:13:32,560 --> 00:13:34,320
the adversary or the broadcaster to

343
00:13:34,320 --> 00:13:36,560
commit to one object before the

344
00:13:36,560 --> 00:13:38,079
broadcast

345
00:13:38,079 --> 00:13:40,480
the adversary can buy us the beacon used

346
00:13:40,480 --> 00:13:42,560
in b cubed but we have a normal

347
00:13:42,560 --> 00:13:45,199
mechanism to limit the bias and to avoid

348
00:13:45,199 --> 00:13:48,160
the bias being accumulated across time

349
00:13:48,160 --> 00:13:51,199
we formally analyzed the protocols first

350
00:13:51,199 --> 00:13:53,760
we proved that overlay bb is indeed a

351
00:13:53,760 --> 00:13:55,920
correct presenting broadcast protocol it

352
00:13:55,920 --> 00:13:58,720
gives the standard safety validity and

353
00:13:58,720 --> 00:14:01,519
termination property as long as there is

354
00:14:01,519 --> 00:14:03,040
at least one honest node in the

355
00:14:03,040 --> 00:14:04,240
committee

356
00:14:04,240 --> 00:14:06,399
the b cube is the blockchain builder

357
00:14:06,399 --> 00:14:09,199
part over lab we prove the end-to-end

358
00:14:09,199 --> 00:14:11,360
guarantee of b cube as a blockchain

359
00:14:11,360 --> 00:14:14,639
specifically even under majority failure

360
00:14:14,639 --> 00:14:18,800
b cube satisfies safety and lightness

361
00:14:18,800 --> 00:14:21,600
we implemented bq and we run b-cube as a

362
00:14:21,600 --> 00:14:23,440
real blockchain system our group of

363
00:14:23,440 --> 00:14:26,720
servers in our experiments we run 10 000

364
00:14:26,720 --> 00:14:28,880
b-cube nodes and we configure each node

365
00:14:28,880 --> 00:14:32,480
to use no more than 20 mbps bandwidth

366
00:14:32,480 --> 00:14:34,639
recall that the nodes are connected by

367
00:14:34,639 --> 00:14:35,920
an overlay

368
00:14:35,920 --> 00:14:37,600
the overlay is viewed by each node

369
00:14:37,600 --> 00:14:39,680
forming 20 outgoing adders to other

370
00:14:39,680 --> 00:14:42,319
random nodes

371
00:14:42,800 --> 00:14:45,519
so this figure illustrates eq throughput

372
00:14:45,519 --> 00:14:48,560
with different tolerance level f it

373
00:14:48,560 --> 00:14:50,399
shows that b cube achieves higher

374
00:14:50,399 --> 00:14:52,800
throughput with lower tolerance but even

375
00:14:52,800 --> 00:14:55,519
enter f equal to 0.7 our protocol

376
00:14:55,519 --> 00:15:01,519
achieved a throughput of about 163 kbps

377
00:15:01,600 --> 00:15:03,760
as mentioned before this 2-foot is not

378
00:15:03,760 --> 00:15:05,600
on par with blockchains that can only

379
00:15:05,600 --> 00:15:08,160
tolerate malicious minority

380
00:15:08,160 --> 00:15:10,079
however this throughput is already

381
00:15:10,079 --> 00:15:13,279
practically usable still as a reference

382
00:15:13,279 --> 00:15:15,760
point bitcoin only have 14 kbps

383
00:15:15,760 --> 00:15:17,120
throughput

384
00:15:17,120 --> 00:15:18,959
we also compare with the baseline

385
00:15:18,959 --> 00:15:21,600
protocol where we replace overlay bb

386
00:15:21,600 --> 00:15:23,839
with some best known byzantine broadcast

387
00:15:23,839 --> 00:15:26,399
protocol and we did much better than the

388
00:15:26,399 --> 00:15:28,560
baseline

389
00:15:28,560 --> 00:15:30,800
in conclusion we have proposed the first

390
00:15:30,800 --> 00:15:32,880
blockchain system b cube that can

391
00:15:32,880 --> 00:15:35,360
tolerate malicious presenting failure

392
00:15:35,360 --> 00:15:37,120
while achieving practically usable

393
00:15:37,120 --> 00:15:40,320
performance in experiments bq provides

394
00:15:40,320 --> 00:15:42,639
practically usable performance while

395
00:15:42,639 --> 00:15:45,920
staying robust against f equal 0.7

396
00:15:45,920 --> 00:15:48,079
we formally analyze the security of the

397
00:15:48,079 --> 00:15:51,120
protocol and as a central building block

398
00:15:51,120 --> 00:15:53,600
we propose a novel byzantine broadcast

399
00:15:53,600 --> 00:15:56,399
protocol called overlay bb that provides

400
00:15:56,399 --> 00:15:58,720
orders of magnitude higher throughput

401
00:15:58,720 --> 00:16:02,079
than the state of the arts

402
00:16:05,199 --> 00:16:06,480
good work

403
00:16:06,480 --> 00:16:08,160
any question from the audience already

404
00:16:08,160 --> 00:16:09,680
have

405
00:16:09,680 --> 00:16:12,239
please go ahead

406
00:16:17,600 --> 00:16:21,440
it should work and just get a closer

407
00:16:21,440 --> 00:16:22,639
testing no

408
00:16:22,639 --> 00:16:24,480
yeah this is elaine wren from university

409
00:16:24,480 --> 00:16:25,839
of illinois

410
00:16:25,839 --> 00:16:27,680
um a

411
00:16:27,680 --> 00:16:29,759
problem with a byzantine broadcast is

412
00:16:29,759 --> 00:16:32,079
that while nodes can agree with each

413
00:16:32,079 --> 00:16:32,880
other

414
00:16:32,880 --> 00:16:35,440
they have no way to convince external

415
00:16:35,440 --> 00:16:37,199
users that

416
00:16:37,199 --> 00:16:39,040
they agreed on the right thing right so

417
00:16:39,040 --> 00:16:41,759
how does your system support external

418
00:16:41,759 --> 00:16:44,880
users or like clients

419
00:16:45,120 --> 00:16:46,480
okay

420
00:16:46,480 --> 00:16:48,160
thank you for your question it is a good

421
00:16:48,160 --> 00:16:51,759
question so first of all um

422
00:16:51,759 --> 00:16:52,560
for

423
00:16:52,560 --> 00:16:55,120
for big uh for big users

424
00:16:55,120 --> 00:16:56,720
i mean it's the same

425
00:16:56,720 --> 00:16:59,759
in many uh blockchains if you really

426
00:16:59,759 --> 00:17:01,680
want the security guarantee of the

427
00:17:01,680 --> 00:17:04,640
blockchain you have to run the full note

428
00:17:04,640 --> 00:17:05,919
okay

429
00:17:05,919 --> 00:17:07,439
and because

430
00:17:07,439 --> 00:17:09,760
let's say you mention light nodes and

431
00:17:09,760 --> 00:17:12,240
many blockchain systems if you run a

432
00:17:12,240 --> 00:17:14,720
nice node you

433
00:17:14,720 --> 00:17:16,799
then you need to contact some full node

434
00:17:16,799 --> 00:17:20,160
to retrieve the information and then

435
00:17:20,160 --> 00:17:22,559
kind of your security is at the mercy of

436
00:17:22,559 --> 00:17:24,880
the foothills i know there are

437
00:17:24,880 --> 00:17:29,039
in many blockchain systems there are

438
00:17:29,120 --> 00:17:33,600
easier ways to run live nodes yeah so

439
00:17:33,600 --> 00:17:36,080
uh i mean you

440
00:17:36,080 --> 00:17:38,799
can be cured if i said you you can

441
00:17:38,799 --> 00:17:41,280
choose to run a light node but kind of

442
00:17:41,280 --> 00:17:42,880
you need to

443
00:17:42,880 --> 00:17:45,039
um

444
00:17:45,039 --> 00:17:46,720
you need to

445
00:17:46,720 --> 00:17:49,520
uh choose the correct footnote so-called

446
00:17:49,520 --> 00:17:52,320
and it really depends on how you

447
00:17:52,320 --> 00:17:55,440
we which we know you contact

448
00:17:55,440 --> 00:17:56,480
so

449
00:17:56,480 --> 00:17:59,480
yeah

450
00:18:01,200 --> 00:18:03,440
hi sam from edh zurich i have a

451
00:18:03,440 --> 00:18:05,520
questions about your baseline you said

452
00:18:05,520 --> 00:18:07,280
that

453
00:18:07,280 --> 00:18:09,600
if you instantiate your your best 10

454
00:18:09,600 --> 00:18:11,280
broadcast protocol with something state

455
00:18:11,280 --> 00:18:13,280
of the art you get very bad results in b

456
00:18:13,280 --> 00:18:15,039
coupe i was wondering about the opposite

457
00:18:15,039 --> 00:18:18,240
direction could you use uh overlay bb as

458
00:18:18,240 --> 00:18:20,480
a general bezentine agreement protocol

459
00:18:20,480 --> 00:18:22,240
or are there some technicalities which

460
00:18:22,240 --> 00:18:25,600
are specific to your blockchain

461
00:18:25,600 --> 00:18:26,640
okay

462
00:18:26,640 --> 00:18:29,280
so first you you of course you can use

463
00:18:29,280 --> 00:18:32,640
overlay bb as a standalone um byzantine

464
00:18:32,640 --> 00:18:35,520
broadcast protocol so it is not specific

465
00:18:35,520 --> 00:18:37,600
to blockchain okay

466
00:18:37,600 --> 00:18:39,280
um

467
00:18:39,280 --> 00:18:42,160
yeah i i think that's that's perfect

468
00:18:42,160 --> 00:18:45,120
okay yeah great thanks

469
00:18:46,000 --> 00:18:49,440
hi i'm sarah from uivc so in your

470
00:18:49,440 --> 00:18:51,520
experiments you have used f equals to i

471
00:18:51,520 --> 00:18:54,240
think 0.7 and also the

472
00:18:54,240 --> 00:18:56,880
number of connections is about 20

473
00:18:56,880 --> 00:18:59,200
right so if i see it the number of

474
00:18:59,200 --> 00:19:01,200
connection has to be at least larger

475
00:19:01,200 --> 00:19:02,720
than the fraction of malicious node

476
00:19:02,720 --> 00:19:05,840
otherwise they can possibly like uh

477
00:19:05,840 --> 00:19:07,280
all the connections from honest notes

478
00:19:07,280 --> 00:19:09,120
are bad and then the honest node never

479
00:19:09,120 --> 00:19:10,960
receives any messages

480
00:19:10,960 --> 00:19:12,960
how do you like uh

481
00:19:12,960 --> 00:19:15,760
so uh thank you for your question so

482
00:19:15,760 --> 00:19:16,559
uh

483
00:19:16,559 --> 00:19:18,320
yeah so for first it's not about 10

484
00:19:18,320 --> 00:19:20,799
years about 40 because uh you know for

485
00:19:20,799 --> 00:19:25,639
like 20 hours a week so on average

486
00:19:32,720 --> 00:19:34,400
i understand to where you are coming

487
00:19:34,400 --> 00:19:36,080
from you're saying you're assuming a

488
00:19:36,080 --> 00:19:39,520
certain way of constructing this overlay

489
00:19:39,520 --> 00:19:41,520
for example

490
00:19:41,520 --> 00:19:43,919
maybe you are thinking about

491
00:19:43,919 --> 00:19:46,720
just the randomly formed uh

492
00:19:46,720 --> 00:19:48,799
ongoing edges and the

493
00:19:48,799 --> 00:19:51,840
random for example 70 percent of those

494
00:19:51,840 --> 00:19:53,840
being malicious

495
00:19:53,840 --> 00:19:55,200
i mean

496
00:19:55,200 --> 00:19:56,480
in

497
00:19:56,480 --> 00:19:58,799
practice

498
00:19:58,799 --> 00:20:00,880
i mean there are

499
00:20:00,880 --> 00:20:02,960
there are existing works talking about

500
00:20:02,960 --> 00:20:04,240
how to deal with this kind of

501
00:20:04,240 --> 00:20:06,400
partitioning attack where you want to

502
00:20:06,400 --> 00:20:08,880
ensure not all of your

503
00:20:08,880 --> 00:20:10,159
neighbors

504
00:20:10,159 --> 00:20:11,360
are bad people

505
00:20:11,360 --> 00:20:13,679
and in fact

506
00:20:13,679 --> 00:20:16,000
if if you cannot assume that

507
00:20:16,000 --> 00:20:19,840
i mean even in minority failure case

508
00:20:19,840 --> 00:20:22,320
many blockchains well well also suffer

509
00:20:22,320 --> 00:20:24,080
from partitioning attack

510
00:20:24,080 --> 00:20:25,200
so

511
00:20:25,200 --> 00:20:27,520
um

512
00:20:27,520 --> 00:20:29,760
so so to to answer that question shortly

513
00:20:29,760 --> 00:20:32,960
yes you you need to kind of ensure not

514
00:20:32,960 --> 00:20:35,360
all your neighbors are practiced and how

515
00:20:35,360 --> 00:20:38,960
to ensure that i think

516
00:20:38,960 --> 00:20:42,640
you need to tap on some existing

517
00:20:42,640 --> 00:20:45,679
robust overlay construction works and

518
00:20:45,679 --> 00:20:48,080
i feel it's a little bit orthogonal to

519
00:20:48,080 --> 00:20:50,880
the focus of this paper

520
00:20:50,880 --> 00:20:53,520
okay thanks

521
00:20:54,400 --> 00:20:56,400
oh this is the last question that we are

522
00:20:56,400 --> 00:20:58,320
going to ask

523
00:20:58,320 --> 00:21:01,200
hi this is robert from uc santa barbara

524
00:21:01,200 --> 00:21:04,080
um i was wondering if you have some

525
00:21:04,080 --> 00:21:07,760
intuitions about how throughput is uh

526
00:21:07,760 --> 00:21:10,480
resistant to malicious attacks that in

527
00:21:10,480 --> 00:21:13,520
are intending to reduce the throughput

528
00:21:13,520 --> 00:21:16,720
so it seems that

529
00:21:16,720 --> 00:21:18,320
although you might be able to reach an

530
00:21:18,320 --> 00:21:19,600
agreement it

531
00:21:19,600 --> 00:21:21,200
is a potential that it could come quite

532
00:21:21,200 --> 00:21:23,679
slowly

533
00:21:23,679 --> 00:21:26,080
okay can you be more specific about when

534
00:21:26,080 --> 00:21:27,679
we say

535
00:21:27,679 --> 00:21:30,919
to reduce

536
00:21:34,960 --> 00:21:36,960
a number of participants are malicious

537
00:21:36,960 --> 00:21:39,679
and say they um introduce artificial

538
00:21:39,679 --> 00:21:42,320
delays in their responses or confusion

539
00:21:42,320 --> 00:21:44,159
into the

540
00:21:44,159 --> 00:21:46,799
into the broadcast protocol um do you

541
00:21:46,799 --> 00:21:48,159
have an intuition as to whether your

542
00:21:48,159 --> 00:21:51,039
throughput can remain uh quite high or

543
00:21:51,039 --> 00:21:52,880
whether it would degrade

544
00:21:52,880 --> 00:21:53,760
okay

545
00:21:53,760 --> 00:21:55,600
uh i think i got it

546
00:21:55,600 --> 00:21:57,200
so first

547
00:21:57,200 --> 00:21:59,200
when we report the throughput

548
00:21:59,200 --> 00:22:00,400
uh we

549
00:22:00,400 --> 00:22:02,000
the throughput should hold under the

550
00:22:02,000 --> 00:22:05,039
worst kind of adversary so we we assume

551
00:22:05,039 --> 00:22:08,080
fully presented atmosphere so

552
00:22:08,080 --> 00:22:11,600
any any attack atmosphere may launch

553
00:22:11,600 --> 00:22:13,840
that is the football guarantee we can

554
00:22:13,840 --> 00:22:16,320
get so

555
00:22:16,720 --> 00:22:18,880
having malicious goals

556
00:22:18,880 --> 00:22:22,799
will not reduce the support that that's

557
00:22:22,799 --> 00:22:25,120
thank you

558
00:22:25,440 --> 00:22:28,190
okay let's send a speaker again

559
00:22:28,190 --> 00:22:32,819
[Applause]

