1
00:00:01,020 --> 00:00:04,140
all right thank you

2
00:00:04,140 --> 00:00:07,980
um hi everyone Liz is jumpling I this is

3
00:00:07,980 --> 00:00:10,500
a joy in the work with your teacher from

4
00:00:10,500 --> 00:00:13,019
Penn State yuhang Wu from Northwestern

5
00:00:13,019 --> 00:00:15,540
University don't move from hajjung

6
00:00:15,540 --> 00:00:17,600
University of Science and Technology

7
00:00:17,600 --> 00:00:19,680
changing from George Washington

8
00:00:19,680 --> 00:00:22,020
University seeing using from

9
00:00:22,020 --> 00:00:24,539
Northwestern University and I can't live

10
00:00:24,539 --> 00:00:27,060
from Baidu USA public release work was

11
00:00:27,060 --> 00:00:29,820
was done a value estate when I was an

12
00:00:29,820 --> 00:00:32,219
intern there

13
00:00:32,219 --> 00:00:35,460
so Linux kernel is a piece of software

14
00:00:35,460 --> 00:00:37,879
that has become a part of our daily life

15
00:00:37,879 --> 00:00:41,219
according to a recent statistic 85

16
00:00:41,219 --> 00:00:44,340
percent of smartphones long Linux kernel

17
00:00:44,340 --> 00:00:48,300
around 39 websites are powered by Linux

18
00:00:48,300 --> 00:00:51,360
kernel therefore the security of Linux

19
00:00:51,360 --> 00:00:53,039
kernel is the security of our

20
00:00:53,039 --> 00:00:54,539
infrastructure

21
00:00:54,539 --> 00:00:57,480
however despite Linux kernel is securely

22
00:00:57,480 --> 00:01:01,038
critical it's buggy

23
00:01:02,879 --> 00:01:06,060
so this is a number of bugs found by six

24
00:01:06,060 --> 00:01:08,700
boats which is a continuous passing

25
00:01:08,700 --> 00:01:11,340
platform that runs the kernel fuzzle

26
00:01:11,340 --> 00:01:13,500
in the past four years

27
00:01:13,500 --> 00:01:16,680
it reported around five thousand bucks

28
00:01:16,680 --> 00:01:19,439
among those bucks around 1 000 bucks are

29
00:01:19,439 --> 00:01:21,060
still unfixed

30
00:01:21,060 --> 00:01:23,460
since it's not really hard to find bugs

31
00:01:23,460 --> 00:01:26,640
in Linux kernel you often get exploited

32
00:01:26,640 --> 00:01:29,720
by the hacker community

33
00:01:30,060 --> 00:01:32,159
we successfully demonstrate a local

34
00:01:32,159 --> 00:01:34,079
privilege as collation on the last

35
00:01:34,079 --> 00:01:36,780
latest version of Ubuntu system at least

36
00:01:36,780 --> 00:01:40,040
a Year's pontoon events

37
00:01:41,100 --> 00:01:44,159
with so many bugs in Linux kernel it's

38
00:01:44,159 --> 00:01:46,860
important to know their exploitability

39
00:01:46,860 --> 00:01:49,200
first of all knowing the exploitability

40
00:01:49,200 --> 00:01:51,240
could guide the design of Kernel

41
00:01:51,240 --> 00:01:54,180
hardening based on the observation of

42
00:01:54,180 --> 00:01:56,939
Kernel exploits meaning kernel hardening

43
00:01:56,939 --> 00:01:59,640
are developed to eliminate eliminate the

44
00:01:59,640 --> 00:02:02,219
exploit component

45
00:02:02,219 --> 00:02:04,439
second knowing the exploitability of

46
00:02:04,439 --> 00:02:07,259
bugs promotes bug fix in Upper string

47
00:02:07,259 --> 00:02:10,139
and fixed adoption in a downstream

48
00:02:10,139 --> 00:02:12,780
we have seen many cases that severe a

49
00:02:12,780 --> 00:02:15,120
severe bug being public in a city boat

50
00:02:15,120 --> 00:02:17,040
but not getting enough attention until

51
00:02:17,040 --> 00:02:18,959
being exploited

52
00:02:18,959 --> 00:02:21,420
besides there are also many bugs being

53
00:02:21,420 --> 00:02:24,420
fixed in Upstream kernel but there they

54
00:02:24,420 --> 00:02:26,099
don't notify the downstream vendors

55
00:02:26,099 --> 00:02:28,500
about the exploitability as a result

56
00:02:28,500 --> 00:02:31,319
those silver bugs are ignored and

57
00:02:31,319 --> 00:02:34,019
downstream kernel stays unfixed leaving

58
00:02:34,019 --> 00:02:37,760
the kernel vulnerable to attacks

59
00:02:38,220 --> 00:02:41,099
benefits Google has ACT to promote

60
00:02:41,099 --> 00:02:43,739
research on kernel exploitation from

61
00:02:43,739 --> 00:02:48,019
kctf program Google pays up to 91

62
00:02:48,019 --> 00:02:52,379
330 37 US dollars for exploits in a

63
00:02:52,379 --> 00:02:54,959
vulnerability in this kernel

64
00:02:54,959 --> 00:02:57,300
to assess the exploitability of Kernel

65
00:02:57,300 --> 00:02:59,819
box a straightforward way is to rightly

66
00:02:59,819 --> 00:03:03,260
exploit however this is very hard first

67
00:03:03,260 --> 00:03:06,659
Kono is complex analyzing kernel box

68
00:03:06,659 --> 00:03:09,000
requires expertise

69
00:03:09,000 --> 00:03:12,360
second writing kernel exploits is time

70
00:03:12,360 --> 00:03:15,599
consuming it often takes experts days to

71
00:03:15,599 --> 00:03:18,540
write the proof of concept

72
00:03:18,540 --> 00:03:19,739
therefore

73
00:03:19,739 --> 00:03:22,080
given a large amount of bugs in kernel

74
00:03:22,080 --> 00:03:26,900
it's not realistic to utilize manufo

75
00:03:27,900 --> 00:03:30,900
in practice with security researchers

76
00:03:30,900 --> 00:03:33,420
assess the exploitability of bugs by

77
00:03:33,420 --> 00:03:35,459
approximating the likelihood of

78
00:03:35,459 --> 00:03:38,340
exploitation based on the error behavior

79
00:03:38,340 --> 00:03:39,900
of bugs

80
00:03:39,900 --> 00:03:42,900
in general most error behaviors like use

81
00:03:42,900 --> 00:03:46,080
of the free Autobahn access double three

82
00:03:46,080 --> 00:03:47,580
are exploitable

83
00:03:47,580 --> 00:03:49,920
because let me demonstrate powerful

84
00:03:49,920 --> 00:03:52,379
memory corruption capability to override

85
00:03:52,379 --> 00:03:54,420
critical data

86
00:03:54,420 --> 00:03:56,580
for error behaviors like non-pointer

87
00:03:56,580 --> 00:03:59,580
derivance and general protection fault

88
00:03:59,580 --> 00:04:01,860
they are less likely to be exploitable

89
00:04:01,860 --> 00:04:04,319
since their memory corruption capability

90
00:04:04,319 --> 00:04:05,760
is limited

91
00:04:05,760 --> 00:04:09,480
for error behaviors like warning bugong

92
00:04:09,480 --> 00:04:12,900
and info these are logs from kernel

93
00:04:12,900 --> 00:04:15,239
developer which don't demonstrate memory

94
00:04:15,239 --> 00:04:17,820
corruption capability so they are also

95
00:04:17,820 --> 00:04:19,798
considered as less likely to be

96
00:04:19,798 --> 00:04:21,540
exploitable

97
00:04:21,540 --> 00:04:24,840
and this classic classification aligns

98
00:04:24,840 --> 00:04:28,139
with the CVS score on the types of

99
00:04:28,139 --> 00:04:31,020
vulnerabilities memory corruption bugs

100
00:04:31,020 --> 00:04:34,080
like use auto-free has have highest

101
00:04:34,080 --> 00:04:37,919
serious score while error locks is a

102
00:04:37,919 --> 00:04:40,400
lawyers

103
00:04:41,280 --> 00:04:43,860
this practical approach has been used by

104
00:04:43,860 --> 00:04:46,460
mostly security researchers however

105
00:04:46,460 --> 00:04:49,199
sometimes it might underestimate the

106
00:04:49,199 --> 00:04:50,880
exploitability

107
00:04:50,880 --> 00:04:53,400
because it's possible that the severe

108
00:04:53,400 --> 00:04:56,040
memory corruption bug just doesn't show

109
00:04:56,040 --> 00:04:58,380
memory corruption capability

110
00:04:58,380 --> 00:05:00,419
for example you see a warning error

111
00:05:00,419 --> 00:05:03,479
behavior of a bug indeed is the use of

112
00:05:03,479 --> 00:05:05,520
the three

113
00:05:05,520 --> 00:05:08,100
and it's possible that a severe memory

114
00:05:08,100 --> 00:05:10,500
corruption bug may only show limited

115
00:05:10,500 --> 00:05:13,259
memory corruption capability for example

116
00:05:13,259 --> 00:05:15,780
you wouldn't see a non-pointed reference

117
00:05:15,780 --> 00:05:18,419
Arrow front back which is considered as

118
00:05:18,419 --> 00:05:21,240
less likely to be exploitable but when

119
00:05:21,240 --> 00:05:23,460
you trigger the bug differently it may

120
00:05:23,460 --> 00:05:27,560
show a memory a severe memory corruption

121
00:05:28,020 --> 00:05:30,300
here I want to show a real world example

122
00:05:30,300 --> 00:05:31,919
of a severe bug

123
00:05:31,919 --> 00:05:34,199
the bug was personally found by this

124
00:05:34,199 --> 00:05:37,919
boat and was reported as a warning Arrow

125
00:05:37,919 --> 00:05:40,740
based on the approximation approach the

126
00:05:40,740 --> 00:05:43,139
warning arrow is considered as less

127
00:05:43,139 --> 00:05:45,060
likely to be exploitable

128
00:05:45,060 --> 00:05:47,100
because it doesn't have any memory

129
00:05:47,100 --> 00:05:48,600
corruption capability

130
00:05:48,600 --> 00:05:51,060
in Upstream the Box still got fixed

131
00:05:51,060 --> 00:05:54,479
after a period of time however sometimes

132
00:05:54,479 --> 00:05:56,880
screen vendors didn't part the fix to

133
00:05:56,880 --> 00:05:59,220
their kernel so it was unfixed the email

134
00:05:59,220 --> 00:06:00,900
kernel

135
00:06:00,900 --> 00:06:03,720
and at the time there was no CV assigned

136
00:06:03,720 --> 00:06:06,240
for the buck no discussion and no public

137
00:06:06,240 --> 00:06:08,819
exploit nobody was aware of the

138
00:06:08,819 --> 00:06:11,280
exploitability

139
00:06:11,280 --> 00:06:15,060
until we found its use of the free

140
00:06:15,060 --> 00:06:17,819
Behavior with gravy and developed a

141
00:06:17,819 --> 00:06:20,240
working exploit for it

142
00:06:20,240 --> 00:06:22,560
responsibly describes the exploit

143
00:06:22,560 --> 00:06:25,380
details to Red Hat they acknowledged our

144
00:06:25,380 --> 00:06:28,560
fundings and finally patch their kernel

145
00:06:28,560 --> 00:06:31,199
redhead also helped us notify other

146
00:06:31,199 --> 00:06:34,080
effect vendors and the CV was assigned

147
00:06:34,080 --> 00:06:38,120
for this bug to keep track of it

148
00:06:39,900 --> 00:06:43,259
this tells us that a kernel bug could

149
00:06:43,259 --> 00:06:45,479
have multiple error behaviors

150
00:06:45,479 --> 00:06:48,600
as we can see from Stevie the bug could

151
00:06:48,600 --> 00:06:50,699
have a warning Arrow

152
00:06:50,699 --> 00:06:54,319
and the use of the free Arrow

153
00:06:54,720 --> 00:06:58,259
to illustrate this assuming the red node

154
00:06:58,259 --> 00:07:01,699
is the side of root cause

155
00:07:01,740 --> 00:07:04,380
when it's triggers through Cisco a in a

156
00:07:04,380 --> 00:07:09,180
picture the kernel crash at 11 node

157
00:07:09,180 --> 00:07:11,400
but when the root cause is triggered

158
00:07:11,400 --> 00:07:14,520
from analysis call the kernel crash at a

159
00:07:14,520 --> 00:07:16,620
different place

160
00:07:16,620 --> 00:07:18,840
with different inputs the kernel May

161
00:07:18,840 --> 00:07:22,560
execute on different contacts and crash

162
00:07:22,560 --> 00:07:24,960
at different place which shows different

163
00:07:24,960 --> 00:07:27,979
error behaviors

164
00:07:29,099 --> 00:07:32,160
so giving one Arrow to find other error

165
00:07:32,160 --> 00:07:35,460
behaviors of the bug represent gravy and

166
00:07:35,460 --> 00:07:38,099
object driven kernel buzzer

167
00:07:38,099 --> 00:07:41,759
of the inside is that first the

168
00:07:41,759 --> 00:07:44,340
implementation of Linux kernel is object

169
00:07:44,340 --> 00:07:47,879
oriented following a strict hierarchy in

170
00:07:47,879 --> 00:07:50,819
each layer the data is stored in the

171
00:07:50,819 --> 00:07:52,560
object for their

172
00:07:52,560 --> 00:07:55,080
as you can see in the picture in the

173
00:07:55,080 --> 00:07:57,360
upper layer the data is installed in

174
00:07:57,360 --> 00:07:58,740
obja

175
00:07:58,740 --> 00:08:01,259
while in lower layer the data is stored

176
00:08:01,259 --> 00:08:04,020
in objp

177
00:08:04,020 --> 00:08:06,840
second in order to trigger the root

178
00:08:06,840 --> 00:08:09,780
cause of a bug operations on some kernel

179
00:08:09,780 --> 00:08:11,580
objects are necessary

180
00:08:11,580 --> 00:08:14,699
for instance assuming the red node is

181
00:08:14,699 --> 00:08:16,740
the side of root cause the green node is

182
00:08:16,740 --> 00:08:19,020
the allocation side of the vulnerable

183
00:08:19,020 --> 00:08:20,099
object

184
00:08:20,099 --> 00:08:22,500
to trigger the bug the kernel has to

185
00:08:22,500 --> 00:08:26,240
allocate the vulnerable object first

186
00:08:26,460 --> 00:08:28,800
without allocating the vulnerable object

187
00:08:28,800 --> 00:08:31,319
to set up the contacts the kernel may

188
00:08:31,319 --> 00:08:34,440
actually execute to other parts thus

189
00:08:34,440 --> 00:08:37,260
fail the trigger of the root cause

190
00:08:37,260 --> 00:08:38,458
third

191
00:08:38,458 --> 00:08:41,099
data internal propagates through kernel

192
00:08:41,099 --> 00:08:42,958
objects

193
00:08:42,958 --> 00:08:45,480
assuming that the yellow node is the

194
00:08:45,480 --> 00:08:46,620
side of

195
00:08:46,620 --> 00:08:49,500
the use side of vulnerable object the

196
00:08:49,500 --> 00:08:51,240
data in a vulnerable object can be

197
00:08:51,240 --> 00:08:53,100
propagated to different yellow nodes

198
00:08:53,100 --> 00:08:56,360
within the scope

199
00:08:56,880 --> 00:08:59,760
from a high level point of view giving

200
00:08:59,760 --> 00:09:03,660
giving a error back arrow Behavior

201
00:09:03,660 --> 00:09:05,940
could be starts from the crash inside

202
00:09:05,940 --> 00:09:08,459
and then identify critical kernel

203
00:09:08,459 --> 00:09:11,040
objects to the bug with backward and

204
00:09:11,040 --> 00:09:14,459
Analysis the object identified not only

205
00:09:14,459 --> 00:09:17,940
helps us set not only have the buzzer

206
00:09:17,940 --> 00:09:20,339
set up the contacts needed to trigger

207
00:09:20,339 --> 00:09:22,860
the bug but also Bond the advancing

208
00:09:22,860 --> 00:09:25,200
scope which avoid the faster to explore

209
00:09:25,200 --> 00:09:28,880
codes in a related context

210
00:09:29,760 --> 00:09:32,459
to identify the critical objects to the

211
00:09:32,459 --> 00:09:34,560
kernel back we first identified the

212
00:09:34,560 --> 00:09:37,200
source of the tender analysis a Linux

213
00:09:37,200 --> 00:09:39,899
kernel back many faced Arrow Behavior

214
00:09:39,899 --> 00:09:42,120
because some check conditions are not

215
00:09:42,120 --> 00:09:44,640
satisfied those checks comes around

216
00:09:44,640 --> 00:09:47,160
either from the developer competitor or

217
00:09:47,160 --> 00:09:49,500
that it may remains Union

218
00:09:49,500 --> 00:09:51,720
for example in the left node in left

219
00:09:51,720 --> 00:09:55,260
side it's a wall on check making sure

220
00:09:55,260 --> 00:09:58,080
the work list is empty otherwise the

221
00:09:58,080 --> 00:10:00,180
condition is unsatisfied and kernel

222
00:10:00,180 --> 00:10:01,440
compliance

223
00:10:01,440 --> 00:10:04,500
in the in the right side the compiler

224
00:10:04,500 --> 00:10:06,959
generates the checks before the memory

225
00:10:06,959 --> 00:10:09,300
read and write operation for the source

226
00:10:09,300 --> 00:10:12,360
code in line 2. if the memory access is

227
00:10:12,360 --> 00:10:15,060
legal the kernel also complains

228
00:10:15,060 --> 00:10:18,240
to perform tent analysis we use the

229
00:10:18,240 --> 00:10:20,279
variables in the checking condition as a

230
00:10:20,279 --> 00:10:22,939
tender source

231
00:10:23,100 --> 00:10:25,200
starting from the 10 Source we will tend

232
00:10:25,200 --> 00:10:27,540
to parent structure variables if its

233
00:10:27,540 --> 00:10:30,300
field is tended for example

234
00:10:30,300 --> 00:10:33,540
if the base field is tended the variable

235
00:10:33,540 --> 00:10:36,600
timer will be tinted as well eventually

236
00:10:36,600 --> 00:10:39,480
the 10 will be propagated to variable

237
00:10:39,480 --> 00:10:42,540
API and T value

238
00:10:42,540 --> 00:10:45,000
we also tend to Loop counter if a loop

239
00:10:45,000 --> 00:10:48,000
iterator extended the intuition is that

240
00:10:48,000 --> 00:10:50,940
if there is an overflow in the loop the

241
00:10:50,940 --> 00:10:52,800
loop countermeability issue of causing

242
00:10:52,800 --> 00:10:55,440
this overflow look at the example

243
00:10:55,440 --> 00:10:56,760
function here

244
00:10:56,760 --> 00:10:59,519
in line four there is the Overflow in

245
00:10:59,519 --> 00:11:02,160
the buff buffer array this possibly is

246
00:11:02,160 --> 00:11:06,019
because the loop counter is too large

247
00:11:06,300 --> 00:11:08,940
the 10 analysis is terminated when it

248
00:11:08,940 --> 00:11:11,100
reaches to the definition of 10

249
00:11:11,100 --> 00:11:13,920
variables you also terminate

250
00:11:13,920 --> 00:11:17,100
when there is no colorful function for

251
00:11:17,100 --> 00:11:18,120
example

252
00:11:18,120 --> 00:11:22,519
Cisco entry or interrupting handle

253
00:11:22,920 --> 00:11:26,279
with the analysis discussed before we

254
00:11:26,279 --> 00:11:29,700
will find out many objects however the

255
00:11:29,700 --> 00:11:32,060
analysis will include objects from the

256
00:11:32,060 --> 00:11:35,640
abstraction layer of Kernel which is

257
00:11:35,640 --> 00:11:36,959
very popular

258
00:11:36,959 --> 00:11:38,820
if the object used for the fasting is

259
00:11:38,820 --> 00:11:41,339
very popular it might not be useful for

260
00:11:41,339 --> 00:11:43,920
two bundle buzzing therefore in this

261
00:11:43,920 --> 00:11:46,920
work we first rank the popularity of

262
00:11:46,920 --> 00:11:50,160
objects then we fill out popular objects

263
00:11:50,160 --> 00:11:52,920
for more details of this part please

264
00:11:52,920 --> 00:11:56,000
refer to our paper

265
00:11:56,519 --> 00:12:00,180
with the object on hands we then use you

266
00:12:00,180 --> 00:12:03,360
utilize a customized compiler to

267
00:12:03,360 --> 00:12:05,700
instrument the basic block involved with

268
00:12:05,700 --> 00:12:08,160
the operation of critical objects

269
00:12:08,160 --> 00:12:10,860
the instrumentation will send object

270
00:12:10,860 --> 00:12:12,720
feedback to the puzzle when it's

271
00:12:12,720 --> 00:12:13,800
executed

272
00:12:13,800 --> 00:12:16,620
so in addition to code coverage we also

273
00:12:16,620 --> 00:12:19,320
have object coverage as a feedback to

274
00:12:19,320 --> 00:12:21,060
the fuzzle

275
00:12:21,060 --> 00:12:23,579
different from traditional puzzles the

276
00:12:23,579 --> 00:12:26,820
maximize code coverage gravy maximize

277
00:12:26,820 --> 00:12:29,639
the object coverage during the buzzing

278
00:12:29,639 --> 00:12:31,800
only inputs reaching these sites

279
00:12:31,800 --> 00:12:33,660
containing objects are interesting to

280
00:12:33,660 --> 00:12:36,420
the fuzzle and the fuzzle will try to

281
00:12:36,420 --> 00:12:37,500
find more

282
00:12:37,500 --> 00:12:41,600
coverage or object coverage

283
00:12:43,019 --> 00:12:45,420
to evaluate the Effectiveness and

284
00:12:45,420 --> 00:12:47,279
efficiency of greeby

285
00:12:47,279 --> 00:12:51,180
we we use a 60 kernel box in the Raw

286
00:12:51,180 --> 00:12:53,279
Tour on and this is called for

287
00:12:53,279 --> 00:12:54,480
comparison

288
00:12:54,480 --> 00:12:57,300
after getting the result we utilize menu

289
00:12:57,300 --> 00:13:00,240
efforts to realize the bug

290
00:13:00,240 --> 00:13:03,300
the results are twofold the first part

291
00:13:03,300 --> 00:13:06,300
is the exploitability escalation

292
00:13:06,300 --> 00:13:09,660
in this part we aim to find whether bugs

293
00:13:09,660 --> 00:13:12,360
that originally behave is less likely to

294
00:13:12,360 --> 00:13:14,760
exploit could be turned into behaviors

295
00:13:14,760 --> 00:13:17,220
blowing belonging to likely to be

296
00:13:17,220 --> 00:13:19,380
explored

297
00:13:19,380 --> 00:13:22,079
in the result could be identified 26

298
00:13:22,079 --> 00:13:24,839
bucks with exploitability escalation

299
00:13:24,839 --> 00:13:27,779
forces 4 by 6 color

300
00:13:27,779 --> 00:13:30,240
the second part is to explore more

301
00:13:30,240 --> 00:13:33,000
exploit potential giving a likely to

302
00:13:33,000 --> 00:13:34,440
exploit bug

303
00:13:34,440 --> 00:13:37,079
the use case of this will be like you

304
00:13:37,079 --> 00:13:39,660
see a bug with use of the free read

305
00:13:39,660 --> 00:13:42,660
Behavior you would like to see if there

306
00:13:42,660 --> 00:13:44,940
is any other use of the free red

307
00:13:44,940 --> 00:13:47,760
capability of the bug which provides

308
00:13:47,760 --> 00:13:50,699
stronger primitive for exploitation

309
00:13:50,699 --> 00:13:52,920
in this part will be identified eight

310
00:13:52,920 --> 00:13:55,260
bugs with least potential while six

311
00:13:55,260 --> 00:13:59,060
color only identified one of them

312
00:14:00,240 --> 00:14:02,459
I want to highlight several takeaways

313
00:14:02,459 --> 00:14:03,300
here

314
00:14:03,300 --> 00:14:06,000
first Colonel bug could have multiple

315
00:14:06,000 --> 00:14:08,820
error behaviors in our experiment we

316
00:14:08,820 --> 00:14:12,420
found 34 bugs in our data set our tool

317
00:14:12,420 --> 00:14:14,279
could find at least one additional error

318
00:14:14,279 --> 00:14:15,720
Behavior

319
00:14:15,720 --> 00:14:18,899
second exposing multiviral Behavior

320
00:14:18,899 --> 00:14:20,880
contributes to more precise

321
00:14:20,880 --> 00:14:23,339
exploitability estimation

322
00:14:23,339 --> 00:14:25,920
ex multiplayer Behavior represents

323
00:14:25,920 --> 00:14:28,980
different effects of bugs exposing other

324
00:14:28,980 --> 00:14:31,380
error behaviors help us understand the

325
00:14:31,380 --> 00:14:34,019
worst effect of the bug

326
00:14:34,019 --> 00:14:37,199
third in a comparison to this color we

327
00:14:37,199 --> 00:14:39,000
show that our approach to funding

328
00:14:39,000 --> 00:14:41,220
multiple error behavior is much more

329
00:14:41,220 --> 00:14:44,660
effective and efficient

330
00:14:44,880 --> 00:14:48,240
we have open source our tool so feel

331
00:14:48,240 --> 00:14:50,279
free to try out and feel free to contact

332
00:14:50,279 --> 00:14:53,620
me if you have any questions thank you

333
00:14:53,620 --> 00:14:56,929
[Applause]

334
00:14:59,760 --> 00:15:02,300
questions

335
00:15:10,740 --> 00:15:13,560
hi very interesting talk

336
00:15:13,560 --> 00:15:15,899
um I'm Kyle Zane from Arizona State

337
00:15:15,899 --> 00:15:17,100
University

338
00:15:17,100 --> 00:15:20,459
I have a question about this work

339
00:15:20,459 --> 00:15:21,899
um actually it's a comparison between

340
00:15:21,899 --> 00:15:24,540
this work and a very recent work called

341
00:15:24,540 --> 00:15:27,779
ciscope so both works are trying to find

342
00:15:27,779 --> 00:15:30,240
the different behaviors of it of the

343
00:15:30,240 --> 00:15:33,779
initial uh bug report

344
00:15:33,779 --> 00:15:36,420
I think Cisco Cisco uses another

345
00:15:36,420 --> 00:15:39,839
approach which is uh I'm not going to go

346
00:15:39,839 --> 00:15:41,820
details about that but one of the

347
00:15:41,820 --> 00:15:45,839
approaches basically is saying that

348
00:15:45,839 --> 00:15:46,620
um

349
00:15:46,620 --> 00:15:49,440
the CIS color which is grab is based on

350
00:15:49,440 --> 00:15:52,259
will try to find the first report first

351
00:15:52,259 --> 00:15:53,399
bug report

352
00:15:53,399 --> 00:15:55,740
for example a warning but this is

353
00:15:55,740 --> 00:15:57,899
actually not a good idea when you're

354
00:15:57,899 --> 00:16:00,440
trying to do behavioral exploration

355
00:16:00,440 --> 00:16:03,240
because for example after triggering the

356
00:16:03,240 --> 00:16:04,680
warning it will trigger it for example

357
00:16:04,680 --> 00:16:08,100
yourself very right do you think this

358
00:16:08,100 --> 00:16:11,639
um work is complementary to your work

359
00:16:11,639 --> 00:16:13,740
and maybe combining these two or you can

360
00:16:13,740 --> 00:16:16,560
can give us a better Behavior

361
00:16:16,560 --> 00:16:21,120
exploration tool yeah I think so so one

362
00:16:21,120 --> 00:16:23,820
difference if I remember correctly one

363
00:16:23,820 --> 00:16:26,519
difference between our work with and

364
00:16:26,519 --> 00:16:29,000
their work is they don't

365
00:16:29,000 --> 00:16:32,459
vibrate the input to the bug they don't

366
00:16:32,459 --> 00:16:34,680
they just use the input from the

367
00:16:34,680 --> 00:16:37,019
original report and try to find the true

368
00:16:37,019 --> 00:16:39,839
effects of the input can trigger

369
00:16:39,839 --> 00:16:42,420
so I think that's complementary

370
00:16:42,420 --> 00:16:46,399
to this world thank you so much

371
00:16:49,740 --> 00:16:53,040
hi Crystal Carnegie Mellon um

372
00:16:53,040 --> 00:16:55,800
so you talk about kind of tracing

373
00:16:55,800 --> 00:16:57,959
through the data structures uh the

374
00:16:57,959 --> 00:16:59,399
kernel objects

375
00:16:59,399 --> 00:17:01,500
how do you does that

376
00:17:01,500 --> 00:17:03,120
does your tool automatically discover

377
00:17:03,120 --> 00:17:06,179
that or do you need to tell your tool

378
00:17:06,179 --> 00:17:08,699
about some amount of the structure the

379
00:17:08,699 --> 00:17:10,859
kernel objects before being able to

380
00:17:10,859 --> 00:17:13,140
trace those can you can you

381
00:17:13,140 --> 00:17:15,900
explain that a little bit so we start

382
00:17:15,900 --> 00:17:18,720
from a kernel crash when you crash you

383
00:17:18,720 --> 00:17:21,959
see you can see the crash point where

384
00:17:21,959 --> 00:17:24,240
the crash happens so from the crash

385
00:17:24,240 --> 00:17:27,900
point we extract some variables from the

386
00:17:27,900 --> 00:17:30,240
side and we start from this side and do

387
00:17:30,240 --> 00:17:33,419
a backward 10 analysis to find some

388
00:17:33,419 --> 00:17:35,460
structures

389
00:17:35,460 --> 00:17:37,020
okay so you're just building the

390
00:17:37,020 --> 00:17:39,179
structures from from the crash point and

391
00:17:39,179 --> 00:17:41,400
and the data that's around that crash

392
00:17:41,400 --> 00:17:42,840
Point correct

393
00:17:42,840 --> 00:17:46,280
okay thanks

394
00:17:47,840 --> 00:17:50,280
all right let's thank the speaker again

395
00:17:50,280 --> 00:17:51,860
thank you

396
00:17:51,860 --> 00:17:54,820
[Applause]

