1
00:00:00,480 --> 00:00:02,159
oh let me start

2
00:00:02,159 --> 00:00:03,679
good morning i'm xi jung jung from

3
00:00:03,679 --> 00:00:05,520
university of virginia

4
00:00:05,520 --> 00:00:07,600
i'm going to present our paper sunflower

5
00:00:07,600 --> 00:00:09,840
finder discovering and exploiting logic

6
00:00:09,840 --> 00:00:12,480
flows of a small algorithm

7
00:00:12,480 --> 00:00:14,960
in the near future we may be able to see

8
00:00:14,960 --> 00:00:17,199
the transforms more commonly like this

9
00:00:17,199 --> 00:00:18,640
figure

10
00:00:18,640 --> 00:00:20,800
some robotics utilize individual drones

11
00:00:20,800 --> 00:00:22,400
and they have been developed to conduct

12
00:00:22,400 --> 00:00:25,279
a challenging task in collective way

13
00:00:25,279 --> 00:00:27,359
also drone is already complex and

14
00:00:27,359 --> 00:00:29,519
something more complex

15
00:00:29,519 --> 00:00:31,760
with the complexity a lot of logic flows

16
00:00:31,760 --> 00:00:34,079
can be overlooked and or become hard to

17
00:00:34,079 --> 00:00:35,360
find

18
00:00:35,360 --> 00:00:38,480
so we have worked to systematically find

19
00:00:38,480 --> 00:00:40,960
the logic flows which essentially act as

20
00:00:40,960 --> 00:00:43,280
a software box in swarm algorithm that

21
00:00:43,280 --> 00:00:46,239
adversaries can exploit

22
00:00:46,239 --> 00:00:48,960
in this example we have a sum of four

23
00:00:48,960 --> 00:00:52,000
drones carrying an object using strings

24
00:00:52,000 --> 00:00:53,520
and it's trying to deliver to the

25
00:00:53,520 --> 00:00:54,879
destination

26
00:00:54,879 --> 00:00:57,120
and during this it comes across a moving

27
00:00:57,120 --> 00:00:59,840
obstacle which it tries to avoid

28
00:00:59,840 --> 00:01:02,320
and in the real world experiments we

29
00:01:02,320 --> 00:01:04,879
represent it with another drone

30
00:01:04,879 --> 00:01:07,439
then on adversary controls on external

31
00:01:07,439 --> 00:01:10,840
tectron to fail this delivery

32
00:01:10,840 --> 00:01:14,640
mission so what an adversary does it it

33
00:01:14,640 --> 00:01:16,960
initially flies the electron toward the

34
00:01:16,960 --> 00:01:19,439
incoming victim's form

35
00:01:19,439 --> 00:01:20,640
when it gets

36
00:01:20,640 --> 00:01:22,960
close to this one it essentially puts

37
00:01:22,960 --> 00:01:25,520
the leader drone at an angle that it

38
00:01:25,520 --> 00:01:28,640
crashed into the obstacle

39
00:01:28,640 --> 00:01:29,680
and so

40
00:01:29,680 --> 00:01:32,880
the adversary fails the mission entirely

41
00:01:32,880 --> 00:01:35,040
typically this home algorithm can avoid

42
00:01:35,040 --> 00:01:36,640
obstacles well

43
00:01:36,640 --> 00:01:40,000
however it fails on under this scenario

44
00:01:40,000 --> 00:01:43,040
we want to see what's going on

45
00:01:43,040 --> 00:01:46,159
so logic flow is a software box existing

46
00:01:46,159 --> 00:01:47,680
in the decision-making logic of this

47
00:01:47,680 --> 00:01:49,600
drone or form

48
00:01:49,600 --> 00:01:52,000
the root cause of the previous example

49
00:01:52,000 --> 00:01:54,320
is that this home algorithm's

50
00:01:54,320 --> 00:01:57,119
multi-force handling is knife

51
00:01:57,119 --> 00:01:59,040
for the leader drone there are three

52
00:01:59,040 --> 00:02:01,360
forces applied here

53
00:02:01,360 --> 00:02:03,520
first force is the one used to go

54
00:02:03,520 --> 00:02:06,159
forward to the core

55
00:02:06,159 --> 00:02:08,000
and the second is the force used to

56
00:02:08,000 --> 00:02:09,758
avoid the obstacle

57
00:02:09,758 --> 00:02:12,000
and the third is the force used to avoid

58
00:02:12,000 --> 00:02:14,400
the attack drum

59
00:02:14,400 --> 00:02:16,160
this algorithm computes the final

60
00:02:16,160 --> 00:02:18,480
direction by simply taking the sum of

61
00:02:18,480 --> 00:02:19,520
forces

62
00:02:19,520 --> 00:02:22,239
the issue here is that algorithm doesn't

63
00:02:22,239 --> 00:02:24,080
prioritize well

64
00:02:24,080 --> 00:02:26,720
drawn should focus on

65
00:02:26,720 --> 00:02:29,200
avoiding crash rather than going toward

66
00:02:29,200 --> 00:02:30,560
the goal

67
00:02:30,560 --> 00:02:33,200
so this simple resulting vector leads to

68
00:02:33,200 --> 00:02:34,879
a crash

69
00:02:34,879 --> 00:02:37,040
such type of logic flows are supposed to

70
00:02:37,040 --> 00:02:39,519
be discovered early on so we want to

71
00:02:39,519 --> 00:02:41,440
test swarm algorithm more

72
00:02:41,440 --> 00:02:44,239
to discover logic flows

73
00:02:44,239 --> 00:02:46,160
however testing from algorithm is not

74
00:02:46,160 --> 00:02:47,040
easy

75
00:02:47,040 --> 00:02:50,160
first some is highly dynamic so to test

76
00:02:50,160 --> 00:02:52,879
swarms effectively it's desirable to run

77
00:02:52,879 --> 00:02:55,280
testing under diverse scenarios to cover

78
00:02:55,280 --> 00:02:57,360
various sound behaviors

79
00:02:57,360 --> 00:02:58,400
however

80
00:02:58,400 --> 00:03:00,319
something input space is too large to

81
00:03:00,319 --> 00:03:02,159
cover in practice

82
00:03:02,159 --> 00:03:03,840
coverage-guided protein serves as

83
00:03:03,840 --> 00:03:07,040
similar challenges however some robotics

84
00:03:07,040 --> 00:03:09,440
execution is iterative code coverage

85
00:03:09,440 --> 00:03:11,040
metrics traditionally used in the

86
00:03:11,040 --> 00:03:14,560
folding techniques are not effective

87
00:03:14,560 --> 00:03:16,640
even with a few tests majority of the

88
00:03:16,640 --> 00:03:18,159
code and the branches are quickly

89
00:03:18,159 --> 00:03:20,159
covered without covering diverse

90
00:03:20,159 --> 00:03:21,760
behavior

91
00:03:21,760 --> 00:03:24,319
so we need a metrics that can measure

92
00:03:24,319 --> 00:03:26,879
swarm behavior

93
00:03:26,879 --> 00:03:28,159
so

94
00:03:28,159 --> 00:03:30,159
we introduce the swamp flow finder

95
00:03:30,159 --> 00:03:32,400
zone flow finder is a grey box

96
00:03:32,400 --> 00:03:34,640
floating project testing technique for

97
00:03:34,640 --> 00:03:36,400
some robotics

98
00:03:36,400 --> 00:03:37,680
we introduced

99
00:03:37,680 --> 00:03:40,080
electrons to obtain more diverse zone

100
00:03:40,080 --> 00:03:42,319
behaviors by disrupting the swarm

101
00:03:42,319 --> 00:03:44,080
operation

102
00:03:44,080 --> 00:03:46,319
and we use a noble metric for measuring

103
00:03:46,319 --> 00:03:48,480
a given test effectiveness

104
00:03:48,480 --> 00:03:51,920
let's see how swoon flow finder works

105
00:03:51,920 --> 00:03:54,400
this is an overview of stormflow finder

106
00:03:54,400 --> 00:03:57,200
let's walk through this one by one

107
00:03:57,200 --> 00:04:00,080
so first a sunflow finder takes a target

108
00:04:00,080 --> 00:04:02,080
swarm algorithm and the small mission as

109
00:04:02,080 --> 00:04:03,040
input

110
00:04:03,040 --> 00:04:05,519
and on them it runs on initial tests

111
00:04:05,519 --> 00:04:07,920
with obtectrons

112
00:04:07,920 --> 00:04:08,879
next

113
00:04:08,879 --> 00:04:11,200
if a test mission finishes successfully

114
00:04:11,200 --> 00:04:13,599
it conducts a test evaluation

115
00:04:13,599 --> 00:04:15,439
now this part is the core technique of

116
00:04:15,439 --> 00:04:17,918
the swarm flow finder here execution

117
00:04:17,918 --> 00:04:19,839
perturbation is done using the

118
00:04:19,839 --> 00:04:22,079
counterfactual execution

119
00:04:22,079 --> 00:04:24,080
this will be explained in greater detail

120
00:04:24,080 --> 00:04:26,800
in the upcoming slide

121
00:04:26,800 --> 00:04:28,560
and based on the result of the test

122
00:04:28,560 --> 00:04:31,040
evaluation some flow finder mutates the

123
00:04:31,040 --> 00:04:34,720
current test and continuous testing

124
00:04:34,720 --> 00:04:37,280
if a test leads to a mission failure the

125
00:04:37,280 --> 00:04:39,280
context test configuration is obtained

126
00:04:39,280 --> 00:04:41,759
as output

127
00:04:41,759 --> 00:04:44,320
it repeats this process until it reaches

128
00:04:44,320 --> 00:04:46,720
a predefined timeout

129
00:04:46,720 --> 00:04:50,560
let's take a look each step one by one

130
00:04:50,560 --> 00:04:53,199
on the right side on the right top side

131
00:04:53,199 --> 00:04:56,000
is a minimap of the overview

132
00:04:56,000 --> 00:04:58,000
and the yellow highlighted part is the

133
00:04:58,000 --> 00:05:00,320
test run creation which is the first

134
00:05:00,320 --> 00:05:03,199
step of sound flow finder

135
00:05:03,199 --> 00:05:06,240
let's look at this step test equation

136
00:05:06,240 --> 00:05:09,600
we define test run as two vectors

137
00:05:09,600 --> 00:05:12,560
attack transport is a point in 3d space

138
00:05:12,560 --> 00:05:14,880
where it is spawned

139
00:05:14,880 --> 00:05:18,240
and we have a fourth strategy

140
00:05:18,240 --> 00:05:20,880
that otectron is going to use

141
00:05:20,880 --> 00:05:23,759
one is it pushes back victim drone by

142
00:05:23,759 --> 00:05:25,199
flying against it

143
00:05:25,199 --> 00:05:27,919
the second is it chases a victim drone

144
00:05:27,919 --> 00:05:30,240
to interfere

145
00:05:30,240 --> 00:05:32,720
the other one is a tektron flies between

146
00:05:32,720 --> 00:05:36,000
two victim drones to separate them out

147
00:05:36,000 --> 00:05:38,560
while the last one is it flies around

148
00:05:38,560 --> 00:05:41,360
the victim's home to manipulate it

149
00:05:41,360 --> 00:05:43,759
these are basic strategies we want to

150
00:05:43,759 --> 00:05:46,479
show even with these basic strategies

151
00:05:46,479 --> 00:05:49,360
our technique is effective

152
00:05:49,360 --> 00:05:51,680
digital tech transports as strategies

153
00:05:51,680 --> 00:05:55,199
are the target of mutation

154
00:05:55,199 --> 00:05:57,520
so in the next step for each test

155
00:05:57,520 --> 00:06:00,960
created we execute and evaluate it

156
00:06:00,960 --> 00:06:02,960
to evaluate the effectiveness of each

157
00:06:02,960 --> 00:06:05,039
test we see

158
00:06:05,039 --> 00:06:07,199
if a quantum test quantum attack drawn

159
00:06:07,199 --> 00:06:09,600
supports and strategy resulting in a new

160
00:06:09,600 --> 00:06:12,560
zone behavior we consider it effective

161
00:06:12,560 --> 00:06:15,600
as we have more hope to find new logic

162
00:06:15,600 --> 00:06:18,720
flows from the neutron behavior

163
00:06:18,720 --> 00:06:20,800
then we change our techno support

164
00:06:20,800 --> 00:06:23,520
slightly with the same strategy for the

165
00:06:23,520 --> 00:06:25,120
next test run

166
00:06:25,120 --> 00:06:27,360
because we want to search around the

167
00:06:27,360 --> 00:06:29,360
current test run

168
00:06:29,360 --> 00:06:30,880
for example

169
00:06:30,880 --> 00:06:33,840
when test run test 1 is current run and

170
00:06:33,840 --> 00:06:36,720
it shows us useful behavior

171
00:06:36,720 --> 00:06:39,280
test two is set closely with the same

172
00:06:39,280 --> 00:06:41,120
strategy

173
00:06:41,120 --> 00:06:41,919
but

174
00:06:41,919 --> 00:06:44,000
uh if the contour one shows a similar

175
00:06:44,000 --> 00:06:46,639
behavior we take a big mutation to

176
00:06:46,639 --> 00:06:49,199
induce new behaviors

177
00:06:49,199 --> 00:06:50,800
for example

178
00:06:50,800 --> 00:06:53,360
when tested to show the similar strong

179
00:06:53,360 --> 00:06:57,599
behavior test 3 is away from test 2 with

180
00:06:57,599 --> 00:07:00,000
a different strategy

181
00:07:00,000 --> 00:07:02,960
however our question here is

182
00:07:02,960 --> 00:07:05,840
uh how to know which uh song behavior is

183
00:07:05,840 --> 00:07:09,120
new and which is one behavior is similar

184
00:07:09,120 --> 00:07:11,520
to solve this we need the metric that

185
00:07:11,520 --> 00:07:14,479
can abstract the sound behavior

186
00:07:14,479 --> 00:07:16,639
and for this we introduce the degree of

187
00:07:16,639 --> 00:07:18,639
the cultural contribution which we call

188
00:07:18,639 --> 00:07:21,360
dcc that is based on the counterfactual

189
00:07:21,360 --> 00:07:23,599
causality

190
00:07:23,599 --> 00:07:26,400
let's see what is dcc and how it works

191
00:07:26,400 --> 00:07:28,319
we focus on the impact of external

192
00:07:28,319 --> 00:07:30,639
factors such as obstacles or attack

193
00:07:30,639 --> 00:07:33,039
drones on the victim drone where the

194
00:07:33,039 --> 00:07:35,520
impact can be intuitively measured by

195
00:07:35,520 --> 00:07:38,400
drones reaction to them

196
00:07:38,400 --> 00:07:41,199
we do this by counterfactual causality

197
00:07:41,199 --> 00:07:43,440
which basically captured that

198
00:07:43,440 --> 00:07:45,840
the impact of the impact on b

199
00:07:45,840 --> 00:07:48,639
if a had not occurred

200
00:07:48,639 --> 00:07:51,280
and this causality dependence in swarms

201
00:07:51,280 --> 00:07:52,960
we capture through alternative

202
00:07:52,960 --> 00:07:55,759
executions of with and without external

203
00:07:55,759 --> 00:07:57,360
factors

204
00:07:57,360 --> 00:08:00,639
so let's take a look at this example

205
00:08:00,639 --> 00:08:02,639
on the left side we see the original

206
00:08:02,639 --> 00:08:05,120
execution and on the right side we see

207
00:08:05,120 --> 00:08:07,280
the same alternative execution just

208
00:08:07,280 --> 00:08:09,599
without the obstacle

209
00:08:09,599 --> 00:08:12,639
now the obstacle over here acts as a in

210
00:08:12,639 --> 00:08:15,440
our counterfactual causality

211
00:08:15,440 --> 00:08:18,800
so compared to the original execution

212
00:08:18,800 --> 00:08:20,560
as you can see here removing the

213
00:08:20,560 --> 00:08:22,960
obstacle change the flight path of this

214
00:08:22,960 --> 00:08:24,400
drone

215
00:08:24,400 --> 00:08:26,720
so we captured the impact through this

216
00:08:26,720 --> 00:08:30,879
delta which basically is b

217
00:08:31,280 --> 00:08:34,000
now to compute the dcc we run the

218
00:08:34,000 --> 00:08:36,159
alternative executions for every

219
00:08:36,159 --> 00:08:38,559
external factor

220
00:08:38,559 --> 00:08:41,279
in case of follow one we first run the

221
00:08:41,279 --> 00:08:43,440
original execution

222
00:08:43,440 --> 00:08:45,680
then we remove the

223
00:08:45,680 --> 00:08:48,800
obstacle and run the same execution

224
00:08:48,800 --> 00:08:52,240
from here we get the delta and the story

225
00:08:52,240 --> 00:08:54,560
then we do the same for the leader and

226
00:08:54,560 --> 00:08:56,320
the follower too

227
00:08:56,320 --> 00:08:58,800
and as you can see here we get the

228
00:08:58,800 --> 00:09:00,720
different deltas in each of their

229
00:09:00,720 --> 00:09:02,399
essences

230
00:09:02,399 --> 00:09:05,040
and by storing both of deltas as

231
00:09:05,040 --> 00:09:07,600
aggregated percentages we end up with

232
00:09:07,600 --> 00:09:11,680
the dcc values for the follow one

233
00:09:12,080 --> 00:09:14,320
for each time interval

234
00:09:14,320 --> 00:09:17,120
we get separate dcc values as shown

235
00:09:17,120 --> 00:09:18,800
below

236
00:09:18,800 --> 00:09:20,959
so we accumulate these numbers

237
00:09:20,959 --> 00:09:23,519
throughout the entire summation

238
00:09:23,519 --> 00:09:26,800
so you can find that the worst impact to

239
00:09:26,800 --> 00:09:29,440
follow one is reflected by the light

240
00:09:29,440 --> 00:09:30,800
green region

241
00:09:30,800 --> 00:09:34,000
and also third worst impact is also

242
00:09:34,000 --> 00:09:36,640
shown like this

243
00:09:36,640 --> 00:09:39,839
this dcc stream is for follow one so we

244
00:09:39,839 --> 00:09:43,120
collect this for every drone

245
00:09:43,120 --> 00:09:45,920
we use this dcc as the metric for throne

246
00:09:45,920 --> 00:09:49,200
behavior comparison

247
00:09:49,200 --> 00:09:52,080
now to see how dcc compares with

248
00:09:52,080 --> 00:09:54,720
different executions we use the ncc

249
00:09:54,720 --> 00:09:56,000
value

250
00:09:56,000 --> 00:09:59,120
ncc is basically the normalized cross

251
00:09:59,120 --> 00:10:01,519
correlation which is one of the ways to

252
00:10:01,519 --> 00:10:03,360
compute the similarities between the

253
00:10:03,360 --> 00:10:06,640
data in various fields

254
00:10:06,640 --> 00:10:09,440
so for this example you can see the dcc

255
00:10:09,440 --> 00:10:11,279
of two executions

256
00:10:11,279 --> 00:10:13,440
and as you can see they are quite

257
00:10:13,440 --> 00:10:15,440
different

258
00:10:15,440 --> 00:10:18,079
this difference is reflected by ncc of

259
00:10:18,079 --> 00:10:20,320
0.65

260
00:10:20,320 --> 00:10:23,440
we use the threshold of 0.87 to

261
00:10:23,440 --> 00:10:25,839
categorize whether two executions are

262
00:10:25,839 --> 00:10:28,800
similar or different

263
00:10:28,800 --> 00:10:30,640
while on this example

264
00:10:30,640 --> 00:10:33,279
we again compare dcc with different

265
00:10:33,279 --> 00:10:35,040
executions

266
00:10:35,040 --> 00:10:38,000
so you can see that two graphs are quite

267
00:10:38,000 --> 00:10:39,839
similar

268
00:10:39,839 --> 00:10:43,360
this is reflected by ncc of 0.92

269
00:10:43,360 --> 00:10:45,519
since it's above the threshold we

270
00:10:45,519 --> 00:10:49,200
categorize them as similar

271
00:10:49,279 --> 00:10:51,920
so now to see how it works

272
00:10:51,920 --> 00:10:54,079
we start by finding logic flows in

273
00:10:54,079 --> 00:10:57,120
real-world sum algorithm

274
00:10:57,120 --> 00:10:59,760
and we evaluate the effectiveness of dcc

275
00:10:59,760 --> 00:11:01,440
in fault testing

276
00:11:01,440 --> 00:11:04,079
and for this we compare our approach to

277
00:11:04,079 --> 00:11:06,720
random testing not having any dcc

278
00:11:06,720 --> 00:11:08,000
guidance

279
00:11:08,000 --> 00:11:10,240
so let's start with looking at each of

280
00:11:10,240 --> 00:11:12,959
the four swarm algorithms

281
00:11:12,959 --> 00:11:15,600
for the first algorithm adaptive form

282
00:11:15,600 --> 00:11:19,440
its objective is multi-agent navigating

283
00:11:19,440 --> 00:11:21,040
it has four drones

284
00:11:21,040 --> 00:11:24,320
and we find 20 unique logic floats

285
00:11:24,320 --> 00:11:26,320
we find the six root causes and

286
00:11:26,320 --> 00:11:28,959
potential fixes and all of which are

287
00:11:28,959 --> 00:11:31,680
confirmed by the developer

288
00:11:31,680 --> 00:11:33,920
and for the second algorithm socratic

289
00:11:33,920 --> 00:11:34,800
form

290
00:11:34,800 --> 00:11:37,760
it aims to do a coordinated search

291
00:11:37,760 --> 00:11:39,360
it had eight drones

292
00:11:39,360 --> 00:11:41,920
we find eight logic eight unique logic

293
00:11:41,920 --> 00:11:42,880
flows

294
00:11:42,880 --> 00:11:46,240
and identify four root codes and

295
00:11:46,240 --> 00:11:47,680
fixes

296
00:11:47,680 --> 00:11:49,680
again all of these are also confirmed by

297
00:11:49,680 --> 00:11:51,920
the developer

298
00:11:51,920 --> 00:11:54,079
and shadrow and the pietro's algorithm

299
00:11:54,079 --> 00:11:56,240
conduct conduct distributed target

300
00:11:56,240 --> 00:11:59,360
search mission with 10 and 15 drones

301
00:11:59,360 --> 00:12:00,959
respectively

302
00:12:00,959 --> 00:12:03,279
more details about both algorithms are

303
00:12:03,279 --> 00:12:05,519
in the paper

304
00:12:05,519 --> 00:12:08,079
and for evaluation of the effectiveness

305
00:12:08,079 --> 00:12:09,279
of dcc

306
00:12:09,279 --> 00:12:11,360
we create a random testing approach by

307
00:12:11,360 --> 00:12:14,079
removing dcc based guidance from our

308
00:12:14,079 --> 00:12:15,519
approach

309
00:12:15,519 --> 00:12:16,959
so unlike

310
00:12:16,959 --> 00:12:19,920
some flow finder in this random testing

311
00:12:19,920 --> 00:12:21,519
the only feedback is the execution

312
00:12:21,519 --> 00:12:22,800
wizard

313
00:12:22,800 --> 00:12:25,519
so if a test run result in mission

314
00:12:25,519 --> 00:12:28,639
failure is considered as desirable then

315
00:12:28,639 --> 00:12:30,880
it takes a small delta

316
00:12:30,880 --> 00:12:33,839
but if a mission has no failure it will

317
00:12:33,839 --> 00:12:37,519
test the current test case more

318
00:12:37,519 --> 00:12:39,440
we run the random testing approach and

319
00:12:39,440 --> 00:12:41,760
the swamp flow finder on our evaluated

320
00:12:41,760 --> 00:12:44,720
algorithms for 24 hours to measure the

321
00:12:44,720 --> 00:12:48,000
spatial distribution of the test cases

322
00:12:48,000 --> 00:12:50,240
this is from random testing

323
00:12:50,240 --> 00:12:53,040
and each dot spatial meaning it's

324
00:12:53,040 --> 00:12:54,959
obtectron's initial approach in each

325
00:12:54,959 --> 00:12:56,800
test run

326
00:12:56,800 --> 00:12:59,360
the larger dots means the test cases

327
00:12:59,360 --> 00:13:02,079
show unique zone behavior

328
00:13:02,079 --> 00:13:04,160
while the smaller dots leads to

329
00:13:04,160 --> 00:13:07,360
non-unicos behaviors and each color

330
00:13:07,360 --> 00:13:09,680
means whether the mission is successful

331
00:13:09,680 --> 00:13:12,079
or failed

332
00:13:12,079 --> 00:13:14,399
and this is a special distribution from

333
00:13:14,399 --> 00:13:16,079
swamp flow finder

334
00:13:16,079 --> 00:13:18,240
and this is the victims from the

335
00:13:18,240 --> 00:13:19,920
location

336
00:13:19,920 --> 00:13:21,920
you can see random testing distribution

337
00:13:21,920 --> 00:13:25,120
is way more spread out and it is shaded

338
00:13:25,120 --> 00:13:29,040
area it was one fla flow finder test

339
00:13:29,040 --> 00:13:31,839
from this we observed that our approach

340
00:13:31,839 --> 00:13:34,480
can focus on smaller but more promising

341
00:13:34,480 --> 00:13:36,079
data

342
00:13:36,079 --> 00:13:38,480
and for unique sound behaviors you can

343
00:13:38,480 --> 00:13:40,560
see there are more dots on the zone flow

344
00:13:40,560 --> 00:13:42,800
finder's test cases

345
00:13:42,800 --> 00:13:44,959
it finds two times more unique from

346
00:13:44,959 --> 00:13:48,320
behavior than the random testing

347
00:13:48,320 --> 00:13:50,480
and for mission sales case mission

348
00:13:50,480 --> 00:13:53,440
failure cases we observed that some flow

349
00:13:53,440 --> 00:13:57,440
finder finds 25 more over failures than

350
00:13:57,440 --> 00:13:59,760
random testing

351
00:13:59,760 --> 00:14:02,959
also for the unique dcc value outside of

352
00:14:02,959 --> 00:14:04,959
this gray shade

353
00:14:04,959 --> 00:14:06,800
it seems that random testing find some

354
00:14:06,800 --> 00:14:09,600
unique test values from the places that

355
00:14:09,600 --> 00:14:12,240
our approach did not test

356
00:14:12,240 --> 00:14:14,240
but we manually checked them and find

357
00:14:14,240 --> 00:14:16,399
that they are all variants of the tests

358
00:14:16,399 --> 00:14:19,920
generated by some flow finder

359
00:14:19,920 --> 00:14:20,959
so far

360
00:14:20,959 --> 00:14:23,279
some flow finder finds a total 42 unique

361
00:14:23,279 --> 00:14:25,279
emission failures from four real-world

362
00:14:25,279 --> 00:14:26,639
algorithms

363
00:14:26,639 --> 00:14:28,959
and we identify 15 different root causes

364
00:14:28,959 --> 00:14:30,959
and the potential fixes and they are all

365
00:14:30,959 --> 00:14:33,040
confirmed by the author

366
00:14:33,040 --> 00:14:35,519
also it finds two times more unique gcc

367
00:14:35,519 --> 00:14:38,079
and 25 the more failures than random

368
00:14:38,079 --> 00:14:40,479
testing

369
00:14:42,160 --> 00:14:44,320
this is a case study about finding logic

370
00:14:44,320 --> 00:14:46,720
flows using some flow finder

371
00:14:46,720 --> 00:14:48,639
this mission is from the first algorithm

372
00:14:48,639 --> 00:14:50,800
we used in the evaluation

373
00:14:50,800 --> 00:14:53,440
and this photo showed this example we

374
00:14:53,440 --> 00:14:55,279
reproduced in the lab with the real

375
00:14:55,279 --> 00:14:57,360
world drones

376
00:14:57,360 --> 00:15:00,079
so in this mission four drones are

377
00:15:00,079 --> 00:15:02,800
moving toward the east along the world

378
00:15:02,800 --> 00:15:04,880
and the attackers strategy is pushing

379
00:15:04,880 --> 00:15:07,279
back leader drone

380
00:15:07,279 --> 00:15:09,680
and you can see eutectron is approaching

381
00:15:09,680 --> 00:15:12,000
the throttle leader drone and it pushes

382
00:15:12,000 --> 00:15:13,120
back

383
00:15:13,120 --> 00:15:15,360
because of which one of the follower

384
00:15:15,360 --> 00:15:18,079
crashes into the world

385
00:15:18,079 --> 00:15:20,560
this is because when a tektron pushes

386
00:15:20,560 --> 00:15:22,959
the leader drone the leader drone moves

387
00:15:22,959 --> 00:15:24,959
into a follower 3

388
00:15:24,959 --> 00:15:27,920
and in doing so the follower 3 crash

389
00:15:27,920 --> 00:15:31,519
into the world while avoiding the leader

390
00:15:31,519 --> 00:15:34,639
the root cause here is that that the

391
00:15:34,639 --> 00:15:36,560
leader drone does not consider follower

392
00:15:36,560 --> 00:15:39,120
3 at the external object

393
00:15:39,120 --> 00:15:41,279
we manually check the source code and

394
00:15:41,279 --> 00:15:43,680
find that there is no code to implement

395
00:15:43,680 --> 00:15:45,440
that logic

396
00:15:45,440 --> 00:15:47,920
so to solve this problem we copy and

397
00:15:47,920 --> 00:15:49,920
paste the followers

398
00:15:49,920 --> 00:15:52,639
logic that detects other victim drones

399
00:15:52,639 --> 00:15:54,880
and the developer confirmed the root

400
00:15:54,880 --> 00:15:56,480
cause and fix

401
00:15:56,480 --> 00:15:58,639
and the more case studies can be found

402
00:15:58,639 --> 00:16:00,720
in the paper

403
00:16:00,720 --> 00:16:03,360
to sum up we propose a number of fault

404
00:16:03,360 --> 00:16:05,680
testing approach for some robotics using

405
00:16:05,680 --> 00:16:08,720
a new feedback metric we conduct

406
00:16:08,720 --> 00:16:11,120
evaluation and its results shows our

407
00:16:11,120 --> 00:16:13,120
procedure effective

408
00:16:13,120 --> 00:16:15,600
also all logic flows and potential fixes

409
00:16:15,600 --> 00:16:18,160
are confirmed by authors this is my end

410
00:16:18,160 --> 00:16:20,910
of presentation thank you

411
00:16:20,910 --> 00:16:27,040
[Applause]

412
00:16:27,040 --> 00:16:31,279
all right questions for the drones

413
00:16:35,680 --> 00:16:37,360
hey this was a great talk i was

414
00:16:37,360 --> 00:16:39,199
wondering in coverage guided fuzzing

415
00:16:39,199 --> 00:16:41,839
there is usually a saturation

416
00:16:41,839 --> 00:16:43,759
after some amount of time did you find

417
00:16:43,759 --> 00:16:46,320
similar saturations here

418
00:16:46,320 --> 00:16:48,079
oh yeah

419
00:16:48,079 --> 00:16:51,519
yeah thank you uh for the actually the

420
00:16:51,519 --> 00:16:53,360
main goal of this first testing is

421
00:16:53,360 --> 00:16:55,680
finding a unique sound behaviors which

422
00:16:55,680 --> 00:16:58,720
is a unique dcc values and as you uh

423
00:16:58,720 --> 00:17:01,199
mentioned right before um

424
00:17:01,199 --> 00:17:02,079
we

425
00:17:02,079 --> 00:17:04,160
we observed that

426
00:17:04,160 --> 00:17:05,119
after

427
00:17:05,119 --> 00:17:07,119
around 9 hours

428
00:17:07,119 --> 00:17:07,919
the

429
00:17:07,919 --> 00:17:09,280
number of the

430
00:17:09,280 --> 00:17:12,799
founded unique dcc values are saturated

431
00:17:12,799 --> 00:17:14,000
but in this

432
00:17:14,000 --> 00:17:15,439
evaluation

433
00:17:15,439 --> 00:17:16,160
we

434
00:17:16,160 --> 00:17:19,679
conduct or experiment for 24 hours

435
00:17:19,679 --> 00:17:24,240
for each uh swarm algorithms so uh

436
00:17:24,240 --> 00:17:27,520
yeah saturate after around 10 hours

437
00:17:27,520 --> 00:17:31,039
great thank you yeah thank you

438
00:17:31,280 --> 00:17:33,760
hi very interesting work i have a

439
00:17:33,760 --> 00:17:36,400
question so it seems like your magic dcc

440
00:17:36,400 --> 00:17:38,320
is kind of like measures the deviation

441
00:17:38,320 --> 00:17:40,799
just like the drone from its original

442
00:17:40,799 --> 00:17:41,919
position

443
00:17:41,919 --> 00:17:44,000
i see like in your case study like you

444
00:17:44,000 --> 00:17:45,919
have obstacles how do you like measure

445
00:17:45,919 --> 00:17:47,600
those like

446
00:17:47,600 --> 00:17:49,840
the distance to those obstacles like to

447
00:17:49,840 --> 00:17:52,799
trigger those bugs

448
00:17:54,240 --> 00:17:55,679
okay thanks for

449
00:17:55,679 --> 00:17:57,360
the question so your question is

450
00:17:57,360 --> 00:17:59,919
essentially how do we measure uh

451
00:17:59,919 --> 00:18:02,400
distances from the obstacle from the all

452
00:18:02,400 --> 00:18:04,799
the swarms

453
00:18:04,799 --> 00:18:07,280
so the way we do is not actually

454
00:18:07,280 --> 00:18:08,960
measuring the distance from the

455
00:18:08,960 --> 00:18:12,559
obstacles to the swamps so as you see we

456
00:18:12,559 --> 00:18:14,640
we run those counterfactual executions

457
00:18:14,640 --> 00:18:17,039
and then we see the deltas so we remove

458
00:18:17,039 --> 00:18:18,640
all these obstacles so essentially when

459
00:18:18,640 --> 00:18:20,720
we run the alternative execution we

460
00:18:20,720 --> 00:18:22,559
remove the wall the existence of the

461
00:18:22,559 --> 00:18:24,799
wall and then the swamp will behave

462
00:18:24,799 --> 00:18:26,000
differently

463
00:18:26,000 --> 00:18:27,919
how much it behave different is

464
00:18:27,919 --> 00:18:30,000
essentially the impact of the wall to

465
00:18:30,000 --> 00:18:32,960
the swamp so that is kind of similar to

466
00:18:32,960 --> 00:18:35,120
what you think how we measure the

467
00:18:35,120 --> 00:18:36,240
distance

468
00:18:36,240 --> 00:18:39,039
from the wall to the swamp so yeah we

469
00:18:39,039 --> 00:18:40,880
don't measure the distance but we

470
00:18:40,880 --> 00:18:42,799
measure the impact

471
00:18:42,799 --> 00:18:44,799
of the external object to the swamp's

472
00:18:44,799 --> 00:18:46,320
behavior

473
00:18:46,320 --> 00:18:48,080
so like uh

474
00:18:48,080 --> 00:18:50,160
during the testing so you don't assume

475
00:18:50,160 --> 00:18:52,799
any obstacles just like your measure is

476
00:18:52,799 --> 00:18:53,520
or

477
00:18:53,520 --> 00:18:55,520
deviation from the original position and

478
00:18:55,520 --> 00:18:58,480
then it may like like trigger some bugs

479
00:18:58,480 --> 00:19:01,120
like if i have the obstacle

480
00:19:01,120 --> 00:19:03,039
so uh you remember that we have the

481
00:19:03,039 --> 00:19:04,799
those counterfactual execution uh

482
00:19:04,799 --> 00:19:06,799
counter factor uh execution that the

483
00:19:06,799 --> 00:19:10,640
definition that the if a uh you know

484
00:19:10,640 --> 00:19:12,720
like you know if if

485
00:19:12,720 --> 00:19:15,200
a would not happen if b did not occur

486
00:19:15,200 --> 00:19:17,840
that kind of things and

487
00:19:17,840 --> 00:19:19,679
so when we run those alternative

488
00:19:19,679 --> 00:19:22,480
executions we remove each of those

489
00:19:22,480 --> 00:19:24,480
external factors so

490
00:19:24,480 --> 00:19:27,039
if there is a 10 different for example

491
00:19:27,039 --> 00:19:28,799
external vectors then we run 10

492
00:19:28,799 --> 00:19:31,280
different executions so each

493
00:19:31,280 --> 00:19:33,600
execution will give us the idea of the

494
00:19:33,600 --> 00:19:37,200
impact of each of the external factor

495
00:19:37,200 --> 00:19:39,760
and then we aggregate all of those so uh

496
00:19:39,760 --> 00:19:42,000
it's uh it's it's i think it's a little

497
00:19:42,000 --> 00:19:44,799
bit complicated to understand uh but

498
00:19:44,799 --> 00:19:45,600
the

499
00:19:45,600 --> 00:19:48,960
the the way we do is uh we uh like you

500
00:19:48,960 --> 00:19:51,840
know we run multiple executions and you

501
00:19:51,840 --> 00:19:54,320
know remove one of the vectors at a time

502
00:19:54,320 --> 00:19:56,160
and then try to understand that the

503
00:19:56,160 --> 00:19:57,840
impact and then we aggregate all of

504
00:19:57,840 --> 00:19:59,760
those to understand

505
00:19:59,760 --> 00:20:02,559
the aggregated impact of all the

506
00:20:02,559 --> 00:20:04,159
external factors

507
00:20:04,159 --> 00:20:05,600
to the swamp

508
00:20:05,600 --> 00:20:07,840
thank you

509
00:20:08,000 --> 00:20:08,799
okay

510
00:20:08,799 --> 00:20:13,039
nice stock so um i just understand your

511
00:20:13,039 --> 00:20:14,960
testing assumes there's only one attack

512
00:20:14,960 --> 00:20:16,960
drone if you have two attack drones

513
00:20:16,960 --> 00:20:20,799
would you find additional flaws and

514
00:20:20,799 --> 00:20:22,720
where does your

515
00:20:22,720 --> 00:20:25,200
as you increase the number of attack

516
00:20:25,200 --> 00:20:27,039
drones where does

517
00:20:27,039 --> 00:20:29,520
does everything stop

518
00:20:29,520 --> 00:20:31,440
uh thank you so much so the question is

519
00:20:31,440 --> 00:20:33,600
essentially are we only tested with one

520
00:20:33,600 --> 00:20:35,840
electrons and what what happen if we

521
00:20:35,840 --> 00:20:37,120
have morse

522
00:20:37,120 --> 00:20:39,600
and uh the the answer is of course if we

523
00:20:39,600 --> 00:20:41,919
have more drones then we can uh you know

524
00:20:41,919 --> 00:20:44,159
squeeze more uh but our goal is

525
00:20:44,159 --> 00:20:47,440
essentially try to find the uh most uh

526
00:20:47,440 --> 00:20:49,360
like you know cause effective in

527
00:20:49,360 --> 00:20:51,600
efficient attacks so for example like if

528
00:20:51,600 --> 00:20:53,760
we have a bunch of uh you know swamps

529
00:20:53,760 --> 00:20:56,000
like for example even ten uh drones of

530
00:20:56,000 --> 00:20:58,400
the swamp if we can uh you know wreck

531
00:20:58,400 --> 00:21:00,559
their missions with only one attack

532
00:21:00,559 --> 00:21:02,400
drone that would be really nice

533
00:21:02,400 --> 00:21:04,480
with more actually we test more and then

534
00:21:04,480 --> 00:21:07,280
we find more uh you know the attacks and

535
00:21:07,280 --> 00:21:08,880
it's much easier

536
00:21:08,880 --> 00:21:09,840
but

537
00:21:09,840 --> 00:21:12,320
we want to show that the evil only one

538
00:21:12,320 --> 00:21:14,080
we can find a lot of

539
00:21:14,080 --> 00:21:16,799
you know flows and um yeah

540
00:21:16,799 --> 00:21:17,919
so

541
00:21:17,919 --> 00:21:20,640
yeah yeah so the threat model is a

542
00:21:20,640 --> 00:21:22,799
complicated thing is how much the attack

543
00:21:22,799 --> 00:21:25,120
drones cost versus how much your drones

544
00:21:25,120 --> 00:21:26,240
etc

545
00:21:26,240 --> 00:21:28,480
um if you wanted to do

546
00:21:28,480 --> 00:21:30,720
uh this thing with three attack drones

547
00:21:30,720 --> 00:21:33,280
would you just would be infeasible or

548
00:21:33,280 --> 00:21:34,559
would it just

549
00:21:34,559 --> 00:21:37,039
take a little bit more compute time uh

550
00:21:37,039 --> 00:21:39,200
yeah but much easier if we have more

551
00:21:39,200 --> 00:21:40,960
electrons and then we can actually wreck

552
00:21:40,960 --> 00:21:43,360
it uh much easier much faster and then

553
00:21:43,360 --> 00:21:44,960
much catastrophic

554
00:21:44,960 --> 00:21:46,880
some of those uh you know logic flows

555
00:21:46,880 --> 00:21:48,880
that we find is kind of interesting that

556
00:21:48,880 --> 00:21:50,640
we are not actually wrecking the drones

557
00:21:50,640 --> 00:21:52,159
we don't actually

558
00:21:52,159 --> 00:21:54,240
our goal is not physically harm the

559
00:21:54,240 --> 00:21:56,720
individual swamps but just exploit the

560
00:21:56,720 --> 00:21:58,400
fact that the algorithm has some of the

561
00:21:58,400 --> 00:22:00,080
flows so for example

562
00:22:00,080 --> 00:22:02,080
if we uh you know

563
00:22:02,080 --> 00:22:03,919
push some of those swamps into the

564
00:22:03,919 --> 00:22:06,320
particular direction and then there they

565
00:22:06,320 --> 00:22:08,720
have some of the flows they have to stop

566
00:22:08,720 --> 00:22:10,320
in some places they couldn't make a

567
00:22:10,320 --> 00:22:11,360
progress

568
00:22:11,360 --> 00:22:13,200
without any physical

569
00:22:13,200 --> 00:22:15,919
harm to the actually the victim swarm so

570
00:22:15,919 --> 00:22:17,520
we are kind of looking for that kind of

571
00:22:17,520 --> 00:22:19,520
things and

572
00:22:19,520 --> 00:22:21,360
a lot of reviewers and also a lot of

573
00:22:21,360 --> 00:22:23,039
other researchers when we talk with this

574
00:22:23,039 --> 00:22:24,080
research

575
00:22:24,080 --> 00:22:25,760
their first question is indeed something

576
00:22:25,760 --> 00:22:27,280
like you know you can just

577
00:22:27,280 --> 00:22:29,600
you know attack the physically um you

578
00:22:29,600 --> 00:22:32,240
know but our answer is

579
00:22:32,240 --> 00:22:34,240
uh that's probably

580
00:22:34,240 --> 00:22:36,559
too straightforward and then we want to

581
00:22:36,559 --> 00:22:39,919
look for a more sophisticated and the

582
00:22:39,919 --> 00:22:41,440
stairs the attacks and then cost

583
00:22:41,440 --> 00:22:43,760
effectively he actually was asking about

584
00:22:43,760 --> 00:22:46,159
the computational

585
00:22:46,159 --> 00:22:48,799
power that your analysis takes so if you

586
00:22:48,799 --> 00:22:52,240
add more attack drones do you run out of

587
00:22:52,240 --> 00:22:54,480
it does it the amount of computation

588
00:22:54,480 --> 00:22:56,159
power that you acquire grow

589
00:22:56,159 --> 00:22:59,440
exponentially or just linearly

590
00:22:59,440 --> 00:23:02,240
i see um so that part uh so your

591
00:23:02,240 --> 00:23:04,799
question uh the next question was uh if

592
00:23:04,799 --> 00:23:08,000
we add a more attack drones uh how you

593
00:23:08,000 --> 00:23:10,080
know much more computation that we need

594
00:23:10,080 --> 00:23:12,240
to do to conduct this experiment because

595
00:23:12,240 --> 00:23:14,080
you know we run a lot of experiment

596
00:23:14,080 --> 00:23:15,760
depending on all these 600 vectors

597
00:23:15,760 --> 00:23:17,919
including all these electrons so the

598
00:23:17,919 --> 00:23:20,240
answer is uh

599
00:23:20,240 --> 00:23:22,240
it's not exponential but it's kind of

600
00:23:22,240 --> 00:23:23,840
linearly growing and then we have that

601
00:23:23,840 --> 00:23:25,600
one in the paper it has a little bit of

602
00:23:25,600 --> 00:23:28,159
the equation so it would be great i

603
00:23:28,159 --> 00:23:30,559
believe that one is in the appendix

604
00:23:30,559 --> 00:23:32,400
right yeah we have that one in the

605
00:23:32,400 --> 00:23:34,720
appendix we have some equations how much

606
00:23:34,720 --> 00:23:36,559
electrons and then how much computation

607
00:23:36,559 --> 00:23:39,120
you're going to have and then that's uh

608
00:23:39,120 --> 00:23:41,840
that's the thing yep thank you all right

609
00:23:41,840 --> 00:23:44,080
like a 20 second 30 second question

610
00:23:44,080 --> 00:23:46,400
okay yeah this is great

611
00:23:46,400 --> 00:23:49,279
this is from purdue university

612
00:23:49,279 --> 00:23:50,880
in my understanding if the home

613
00:23:50,880 --> 00:23:52,799
algorithms code of the crash will be

614
00:23:52,799 --> 00:23:55,840
happening but in real world the as far

615
00:23:55,840 --> 00:23:57,840
as i know each drone control software

616
00:23:57,840 --> 00:23:59,919
also equip with their own collision

617
00:23:59,919 --> 00:24:02,960
avoidance algorithm so have you guys

618
00:24:02,960 --> 00:24:05,520
consider such cases yes

619
00:24:05,520 --> 00:24:08,000
this algorithm actually has a two parts

620
00:24:08,000 --> 00:24:10,400
one is the global planning and also swam

621
00:24:10,400 --> 00:24:12,559
algorithm and also the local planning so

622
00:24:12,559 --> 00:24:15,200
it does indeed have their own

623
00:24:15,200 --> 00:24:17,200
logics to uh you know avoid all these

624
00:24:17,200 --> 00:24:20,640
things but we what we find here

625
00:24:20,640 --> 00:24:23,919
exactly this uh bug is uh you know

626
00:24:23,919 --> 00:24:26,480
so they are kind of competitions between

627
00:24:26,480 --> 00:24:28,559
uh the whole the swamp wants to maintain

628
00:24:28,559 --> 00:24:30,400
whatever their goal has and then there

629
00:24:30,400 --> 00:24:32,640
is also the local planning they want to

630
00:24:32,640 --> 00:24:35,760
avoid and in this case those uh swam

631
00:24:35,760 --> 00:24:38,720
algorithm override their local planners

632
00:24:38,720 --> 00:24:41,039
uh the logic so we are looking for that

633
00:24:41,039 --> 00:24:42,799
kind of subtle differences and that's

634
00:24:42,799 --> 00:24:45,039
also why we need to test a lot thank you

635
00:24:45,039 --> 00:24:47,200
thank you

636
00:24:47,200 --> 00:24:49,120
that was a phenomenal talk thank you so

637
00:24:49,120 --> 00:24:50,960
much let's all give it up for young that

638
00:24:50,960 --> 00:24:52,960
was great

639
00:24:52,960 --> 00:24:55,760
all right

