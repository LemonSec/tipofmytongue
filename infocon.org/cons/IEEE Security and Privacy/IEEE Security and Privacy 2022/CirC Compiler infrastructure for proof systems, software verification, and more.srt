1
00:00:00,000 --> 00:00:01,599
[Applause]

2
00:00:01,599 --> 00:00:04,240
thank you indeed i am alex i'm a phd

3
00:00:04,240 --> 00:00:06,160
student at stamford and i actually work

4
00:00:06,160 --> 00:00:08,160
on both cryptography and formal methods

5
00:00:08,160 --> 00:00:09,840
and one of the things i'm excited about

6
00:00:09,840 --> 00:00:11,519
today is that i'm going to get to tell

7
00:00:11,519 --> 00:00:13,679
you about both of those areas so we'll

8
00:00:13,679 --> 00:00:15,519
be talking about cersei which is a

9
00:00:15,519 --> 00:00:17,760
compiler infrastructure that aims to

10
00:00:17,760 --> 00:00:20,240
support both cryptosystems and formal

11
00:00:20,240 --> 00:00:21,600
verification

12
00:00:21,600 --> 00:00:23,039
so let's start by talking about why

13
00:00:23,039 --> 00:00:24,880
cryptosystems need a compiler

14
00:00:24,880 --> 00:00:27,359
infrastructure in the first place

15
00:00:27,359 --> 00:00:28,880
the reason is that essentially most

16
00:00:28,880 --> 00:00:31,279
modern cryptosystems are computers

17
00:00:31,279 --> 00:00:32,960
consider for example multi-party

18
00:00:32,960 --> 00:00:34,399
computation

19
00:00:34,399 --> 00:00:35,920
the classic problem in this space is

20
00:00:35,920 --> 00:00:37,200
that there are two different entities

21
00:00:37,200 --> 00:00:38,960
each of them has an amount of money and

22
00:00:38,960 --> 00:00:40,800
they want to know who amounts whose

23
00:00:40,800 --> 00:00:43,040
amount is bigger without revealing their

24
00:00:43,040 --> 00:00:44,960
amount to the other party

25
00:00:44,960 --> 00:00:47,120
modern mpc protocols can solve this

26
00:00:47,120 --> 00:00:48,399
problem but they can actually do a lot

27
00:00:48,399 --> 00:00:50,399
more in fact they can evaluate any

28
00:00:50,399 --> 00:00:52,239
user-defined function f

29
00:00:52,239 --> 00:00:54,160
over secret data distributed among

30
00:00:54,160 --> 00:00:56,079
multiple parties so long as the user

31
00:00:56,079 --> 00:00:58,079
writes down f in an appropriate

32
00:00:58,079 --> 00:01:00,879
computational representation

33
00:01:00,879 --> 00:01:03,600
since the system is user programmable i

34
00:01:03,600 --> 00:01:05,920
would say it's a computer and it's not

35
00:01:05,920 --> 00:01:07,920
the only cryptosystem like that indeed

36
00:01:07,920 --> 00:01:09,680
fully homomorphic encryption applies

37
00:01:09,680 --> 00:01:12,240
user-defined functions to encrypted data

38
00:01:12,240 --> 00:01:14,560
and zero-knowledge proofs allow one to

39
00:01:14,560 --> 00:01:16,880
show that a user-defined function would

40
00:01:16,880 --> 00:01:19,759
output one on some secret data so since

41
00:01:19,759 --> 00:01:20,720
there are so many different crypto

42
00:01:20,720 --> 00:01:22,880
systems that are user programmable it's

43
00:01:22,880 --> 00:01:24,880
unsurprising that there are a number of

44
00:01:24,880 --> 00:01:27,040
compilers that translate from various

45
00:01:27,040 --> 00:01:28,880
high-level languages to the

46
00:01:28,880 --> 00:01:30,640
representations needed by different

47
00:01:30,640 --> 00:01:32,640
kinds of cryptosystems

48
00:01:32,640 --> 00:01:33,920
i have a bunch of those compilers on the

49
00:01:33,920 --> 00:01:35,840
slide and all of them are good projects

50
00:01:35,840 --> 00:01:37,680
that i respect but they also all fall

51
00:01:37,680 --> 00:01:40,159
short one way or another broadly

52
00:01:40,159 --> 00:01:42,079
speaking the academic projects are often

53
00:01:42,079 --> 00:01:43,840
incomplete or buggy which makes them

54
00:01:43,840 --> 00:01:46,399
hard to use and the industrial projects

55
00:01:46,399 --> 00:01:48,799
in orange are more reliable but they

56
00:01:48,799 --> 00:01:51,119
achieve that reliability by supporting

57
00:01:51,119 --> 00:01:54,000
very bare-bones high-level languages for

58
00:01:54,000 --> 00:01:55,759
example socrates one of the languages

59
00:01:55,759 --> 00:01:57,280
that we'll discuss later doesn't even

60
00:01:57,280 --> 00:01:58,640
allow the programmer to write if

61
00:01:58,640 --> 00:02:00,560
statements

62
00:02:00,560 --> 00:02:03,119
and so a natural question is is why are

63
00:02:03,119 --> 00:02:06,079
compilers in this space falling short

64
00:02:06,079 --> 00:02:07,119
in fact

65
00:02:07,119 --> 00:02:09,598
and uh you know in our in our view the

66
00:02:09,598 --> 00:02:10,878
reason for that is essentially that this

67
00:02:10,878 --> 00:02:12,959
compilation problem is hard

68
00:02:12,959 --> 00:02:14,480
and all these compilers are trying to

69
00:02:14,480 --> 00:02:16,800
solve it on their own

70
00:02:16,800 --> 00:02:18,400
and so a second natural question is

71
00:02:18,400 --> 00:02:19,680
whether or not it's possible for them to

72
00:02:19,680 --> 00:02:21,599
share infrastructure can we build some

73
00:02:21,599 --> 00:02:23,599
kind of llvm style compiler

74
00:02:23,599 --> 00:02:25,520
infrastructure that can be shared among

75
00:02:25,520 --> 00:02:28,319
different compilers in this space

76
00:02:28,319 --> 00:02:30,800
and our proposed answer is yes so i'll

77
00:02:30,800 --> 00:02:32,160
be telling you about cersei which is our

78
00:02:32,160 --> 00:02:34,560
interpretation of that infrastructure

79
00:02:34,560 --> 00:02:36,319
first we'll talk about cersei's design

80
00:02:36,319 --> 00:02:38,000
and computational model so by the end of

81
00:02:38,000 --> 00:02:39,280
the talk you should understand what

82
00:02:39,280 --> 00:02:41,840
kinds of compilation cersei does and

83
00:02:41,840 --> 00:02:44,239
does not aim to support

84
00:02:44,239 --> 00:02:45,680
then we'll talk about cersei's

85
00:02:45,680 --> 00:02:47,360
performance more specifically the

86
00:02:47,360 --> 00:02:49,599
performance of outputs produced by

87
00:02:49,599 --> 00:02:52,080
compilers built using cersei

88
00:02:52,080 --> 00:02:53,360
and finally we'll talk about another way

89
00:02:53,360 --> 00:02:55,200
in which cersei can be useful

90
00:02:55,200 --> 00:02:58,080
namely its potential to enable crossover

91
00:02:58,080 --> 00:02:59,280
opportunities

92
00:02:59,280 --> 00:03:01,440
situations in which multiple cersei

93
00:03:01,440 --> 00:03:02,400
targets

94
00:03:02,400 --> 00:03:04,480
can be combined in the service of some

95
00:03:04,480 --> 00:03:06,319
high-level application that that

96
00:03:06,319 --> 00:03:07,519
probably sounds kind of weird right now

97
00:03:07,519 --> 00:03:08,879
but we'll make it more concrete at the

98
00:03:08,879 --> 00:03:10,400
end of the talk

99
00:03:10,400 --> 00:03:12,400
um so this is our agenda but truth in

100
00:03:12,400 --> 00:03:13,920
advertising i need to say that while

101
00:03:13,920 --> 00:03:16,480
cersei's vision is broad uh this paper

102
00:03:16,480 --> 00:03:18,640
and the talk today focus on just a

103
00:03:18,640 --> 00:03:20,480
subset of possible certainty targets

104
00:03:20,480 --> 00:03:21,760
we'll be talking about zero knowledge

105
00:03:21,760 --> 00:03:24,480
proofs uh smt logical formula and

106
00:03:24,480 --> 00:03:26,159
constrained optimization problems

107
00:03:26,159 --> 00:03:27,599
multi-party computation fully

108
00:03:27,599 --> 00:03:29,360
homomorphic encryption those are ongoing

109
00:03:29,360 --> 00:03:31,599
and future work

110
00:03:31,599 --> 00:03:33,120
okay so let's get into it cersei's

111
00:03:33,120 --> 00:03:34,720
design and computational model to

112
00:03:34,720 --> 00:03:36,239
understand how cersei is designed we

113
00:03:36,239 --> 00:03:38,000
have to understand in some sense what

114
00:03:38,000 --> 00:03:39,920
it's trying to do so let's talk about

115
00:03:39,920 --> 00:03:41,840
what it needs to produce

116
00:03:41,840 --> 00:03:43,200
to first order you should imagine that

117
00:03:43,200 --> 00:03:44,560
these different kinds of cryptosystems

118
00:03:44,560 --> 00:03:47,280
zero knowledge proofs etc expect the

119
00:03:47,280 --> 00:03:48,480
computation to be represented as an

120
00:03:48,480 --> 00:03:50,560
arithmetic circuit so what cersei's

121
00:03:50,560 --> 00:03:51,680
trying to do is produce some kind of

122
00:03:51,680 --> 00:03:53,680
directed acyl clip graph where the

123
00:03:53,680 --> 00:03:55,360
inputs come in from the left and are

124
00:03:55,360 --> 00:03:57,280
connected by wires to gates that perform

125
00:03:57,280 --> 00:03:59,200
some operation in a finite field like

126
00:03:59,200 --> 00:04:01,360
the integers mod p

127
00:04:01,360 --> 00:04:03,200
different backends might support custom

128
00:04:03,200 --> 00:04:04,720
operations you might imagine that zero

129
00:04:04,720 --> 00:04:06,480
knowledge proofs will sometimes support

130
00:04:06,480 --> 00:04:08,159
equality assertions

131
00:04:08,159 --> 00:04:09,360
and different backends will have

132
00:04:09,360 --> 00:04:10,400
different

133
00:04:10,400 --> 00:04:12,959
concrete cost models but to first order

134
00:04:12,959 --> 00:04:14,879
every backend is happier if the circuit

135
00:04:14,879 --> 00:04:17,040
is smaller and so cersei's goal is to

136
00:04:17,040 --> 00:04:19,199
take some high-level input computation

137
00:04:19,199 --> 00:04:20,798
and translate it into an arithmetic

138
00:04:20,798 --> 00:04:22,079
circuit that is equivalent and has

139
00:04:22,079 --> 00:04:24,160
minimal size

140
00:04:24,160 --> 00:04:25,040
and this is actually a pretty

141
00:04:25,040 --> 00:04:26,560
challenging task because high-level

142
00:04:26,560 --> 00:04:28,800
languages including this small snippet

143
00:04:28,800 --> 00:04:30,639
of pseudocode on the left have a number

144
00:04:30,639 --> 00:04:33,280
of features like mutable variables

145
00:04:33,280 --> 00:04:36,000
if statements for loops and more that

146
00:04:36,000 --> 00:04:39,040
don't have natural analogs in a circuit

147
00:04:39,040 --> 00:04:41,280
and so in this compilation pipeline a

148
00:04:41,280 --> 00:04:42,560
lot of transformations have to be

149
00:04:42,560 --> 00:04:44,960
applied variable mutation has to be

150
00:04:44,960 --> 00:04:46,960
eliminated perhaps putting the program

151
00:04:46,960 --> 00:04:49,440
into some kind of ssa form branches have

152
00:04:49,440 --> 00:04:51,120
to be eliminated all paths need to be

153
00:04:51,120 --> 00:04:52,960
explored with side effects appropriately

154
00:04:52,960 --> 00:04:54,000
guarded

155
00:04:54,000 --> 00:04:55,680
loops those don't exist in a circuit so

156
00:04:55,680 --> 00:04:57,280
we'll have to enroll them up to a bound

157
00:04:57,280 --> 00:04:58,880
that comes from an analysis or perhaps

158
00:04:58,880 --> 00:05:00,720
from the programmer and the list just

159
00:05:00,720 --> 00:05:02,240
goes on there are a whole host of

160
00:05:02,240 --> 00:05:03,680
transformations that need to be applied

161
00:05:03,680 --> 00:05:05,600
and noting their complexity and how

162
00:05:05,600 --> 00:05:07,280
numerous they are you can see why

163
00:05:07,280 --> 00:05:09,440
compilers in this space have a hard time

164
00:05:09,440 --> 00:05:10,960
this is harder than compiling c to

165
00:05:10,960 --> 00:05:12,720
assembly

166
00:05:12,720 --> 00:05:14,240
but when my collaborators and i when we

167
00:05:14,240 --> 00:05:16,479
looked at this list we saw we saw cause

168
00:05:16,479 --> 00:05:18,240
for hope because these transformations

169
00:05:18,240 --> 00:05:19,759
are exactly the transformations

170
00:05:19,759 --> 00:05:21,680
performed by something called a bounded

171
00:05:21,680 --> 00:05:23,840
model

172
00:05:23,840 --> 00:05:25,600
for those of you who aren't familiar

173
00:05:25,600 --> 00:05:26,880
bounded model checking is a formal

174
00:05:26,880 --> 00:05:28,880
verification technique where you take a

175
00:05:28,880 --> 00:05:31,120
program and a query about it perhaps you

176
00:05:31,120 --> 00:05:33,120
want to know if there's a use after free

177
00:05:33,120 --> 00:05:34,960
and you translate these objects into a

178
00:05:34,960 --> 00:05:37,680
logical formula like an smt formula that

179
00:05:37,680 --> 00:05:39,759
whose satisfiability is equivalent to

180
00:05:39,759 --> 00:05:41,759
the answer to the query

181
00:05:41,759 --> 00:05:43,680
by solving the formula you can then get

182
00:05:43,680 --> 00:05:45,440
an answer to your query and this

183
00:05:45,440 --> 00:05:47,840
pipeline is the subject of decades of

184
00:05:47,840 --> 00:05:49,440
research but i just want to focus on one

185
00:05:49,440 --> 00:05:50,479
part of it

186
00:05:50,479 --> 00:05:52,160
that white box in the center that

187
00:05:52,160 --> 00:05:54,160
combines the program and the query into

188
00:05:54,160 --> 00:05:58,080
the formula what do we call that

189
00:05:58,240 --> 00:05:59,600
folks in this space call it a bounded

190
00:05:59,600 --> 00:06:01,199
model checker but i would call it a

191
00:06:01,199 --> 00:06:02,639
compiler because its inputs are

192
00:06:02,639 --> 00:06:05,120
computations and its output a logical

193
00:06:05,120 --> 00:06:06,560
formula that's another kind of

194
00:06:06,560 --> 00:06:07,840
computation

195
00:06:07,840 --> 00:06:09,840
and looking at logical formulas as comp

196
00:06:09,840 --> 00:06:12,000
as computations is useful for us because

197
00:06:12,000 --> 00:06:14,080
they share some features with arithmetic

198
00:06:14,080 --> 00:06:15,680
circuits and the kinds of computations

199
00:06:15,680 --> 00:06:18,479
that we're interested in

200
00:06:18,560 --> 00:06:20,400
so namely all these different kinds of

201
00:06:20,400 --> 00:06:23,039
computations logical formulas uh

202
00:06:23,039 --> 00:06:24,160
arithmetic circuits for zero knowledge

203
00:06:24,160 --> 00:06:26,479
proofs etc they're all mutation free

204
00:06:26,479 --> 00:06:29,199
control flow free and of fixed size they

205
00:06:29,199 --> 00:06:30,880
take a certain number of inputs you want

206
00:06:30,880 --> 00:06:32,479
to handle more inputs you need a bigger

207
00:06:32,479 --> 00:06:33,600
circuit

208
00:06:33,600 --> 00:06:35,280
and so these three features they define

209
00:06:35,280 --> 00:06:36,880
the circuit model of computation so

210
00:06:36,880 --> 00:06:38,800
we're looking for a compilative circuits

211
00:06:38,800 --> 00:06:39,759
but we're not just looking for a

212
00:06:39,759 --> 00:06:41,120
compiler to any circuit because there's

213
00:06:41,120 --> 00:06:42,800
another common thread

214
00:06:42,800 --> 00:06:44,000
which is the fact that all of these

215
00:06:44,000 --> 00:06:46,840
domains have variables of restricted

216
00:06:46,840 --> 00:06:49,199
knowledge and what that means depends a

217
00:06:49,199 --> 00:06:51,120
bit on the particular domain

218
00:06:51,120 --> 00:06:52,800
in the case of zero knowledge proofs

219
00:06:52,800 --> 00:06:54,400
there is some secret data that only the

220
00:06:54,400 --> 00:06:56,560
prover knows the verifier doesn't know

221
00:06:56,560 --> 00:06:57,759
it

222
00:06:57,759 --> 00:06:59,919
in the case of logical formulas there

223
00:06:59,919 --> 00:07:01,360
are variables that are existentially

224
00:07:01,360 --> 00:07:03,520
quantified we don't know if values for

225
00:07:03,520 --> 00:07:05,360
those variables exist and we're hoping

226
00:07:05,360 --> 00:07:07,280
that the smt solver or the sat solver

227
00:07:07,280 --> 00:07:10,240
will figure that out for us

228
00:07:10,240 --> 00:07:13,039
and so broadly speaking we refer to

229
00:07:13,039 --> 00:07:14,319
these kinds of knowledge restrictions as

230
00:07:14,319 --> 00:07:16,560
existential quantification perhaps with

231
00:07:16,560 --> 00:07:18,720
some metadata attached that indicates

232
00:07:18,720 --> 00:07:20,560
who knows the value or who is

233
00:07:20,560 --> 00:07:22,560
responsible for finding it

234
00:07:22,560 --> 00:07:24,240
and so we identify as our key

235
00:07:24,240 --> 00:07:25,520
computational abstraction the

236
00:07:25,520 --> 00:07:27,199
existentially quantified circuit that's

237
00:07:27,199 --> 00:07:28,840
what we're trying to compile

238
00:07:28,840 --> 00:07:31,039
to and like i said we're trying to

239
00:07:31,039 --> 00:07:32,960
compile from some high level language

240
00:07:32,960 --> 00:07:34,960
that might include mutation control flow

241
00:07:34,960 --> 00:07:37,919
variable size data et cetera

242
00:07:37,919 --> 00:07:39,520
and so this is you know this is a hard

243
00:07:39,520 --> 00:07:41,440
compilation problem to solve

244
00:07:41,440 --> 00:07:43,360
but the architecture that we use is at

245
00:07:43,360 --> 00:07:45,199
least in my view more or less what you'd

246
00:07:45,199 --> 00:07:46,879
expect there's an intermediate

247
00:07:46,879 --> 00:07:49,759
representation for cir which is a

248
00:07:49,759 --> 00:07:51,120
circuit ir

249
00:07:51,120 --> 00:07:52,560
but it's a circuit ir with a very rich

250
00:07:52,560 --> 00:07:53,919
type system so it has a whole bunch of

251
00:07:53,919 --> 00:07:55,280
different kinds of primitives as well as

252
00:07:55,280 --> 00:07:57,199
six size arrays and tuples

253
00:07:57,199 --> 00:07:59,120
the first stage in the compiler

254
00:07:59,120 --> 00:08:01,199
involves running a front-end extension

255
00:08:01,199 --> 00:08:02,960
that translates from some high-level

256
00:08:02,960 --> 00:08:05,520
language into cerseir

257
00:08:05,520 --> 00:08:08,639
then we take that ir and we transform it

258
00:08:08,639 --> 00:08:10,479
we optimize it we eliminate complex

259
00:08:10,479 --> 00:08:12,720
constructs like the tuples

260
00:08:12,720 --> 00:08:14,000
and then we take the simplified ir and

261
00:08:14,000 --> 00:08:16,560
we give it to a back end that lowers to

262
00:08:16,560 --> 00:08:19,039
the particular eqc that some target

263
00:08:19,039 --> 00:08:20,960
expects

264
00:08:20,960 --> 00:08:22,160
so that's that's the architecture at a

265
00:08:22,160 --> 00:08:23,360
high level but when you look at the two

266
00:08:23,360 --> 00:08:24,639
halves of it the front ends and the back

267
00:08:24,639 --> 00:08:26,240
ends they're not equally difficult to

268
00:08:26,240 --> 00:08:28,479
build the back ends are translating from

269
00:08:28,479 --> 00:08:31,199
one kind of circuit rir to another kind

270
00:08:31,199 --> 00:08:32,880
of circuit so in some sense they're just

271
00:08:32,880 --> 00:08:34,320
remapping types

272
00:08:34,320 --> 00:08:35,839
this isn't so hard to do but what the

273
00:08:35,839 --> 00:08:37,279
front ends are doing is far harder

274
00:08:37,279 --> 00:08:38,559
because they're mapping a high-level

275
00:08:38,559 --> 00:08:40,080
program that might have stateful

276
00:08:40,080 --> 00:08:43,120
semantics mutable variables etc into a

277
00:08:43,120 --> 00:08:45,120
circuit which as we discussed before is

278
00:08:45,120 --> 00:08:46,959
kind of complicated

279
00:08:46,959 --> 00:08:48,880
and so to assist in the construction of

280
00:08:48,880 --> 00:08:51,040
front-ends cersei provides a library

281
00:08:51,040 --> 00:08:53,200
called certify which is essentially a

282
00:08:53,200 --> 00:08:54,959
library for representing stateful

283
00:08:54,959 --> 00:08:58,160
semantics inside of circuits it exposes

284
00:08:58,160 --> 00:09:00,399
an api for interacting with variables

285
00:09:00,399 --> 00:09:01,600
interacting with control flow

286
00:09:01,600 --> 00:09:02,640
interacting with function calls

287
00:09:02,640 --> 00:09:05,360
interacting with stack arrays and when

288
00:09:05,360 --> 00:09:07,920
you use that api to for example write a

289
00:09:07,920 --> 00:09:10,240
variable or read a variable

290
00:09:10,240 --> 00:09:12,320
certify automatically generates chunks

291
00:09:12,320 --> 00:09:14,320
of circir that encode the stateful

292
00:09:14,320 --> 00:09:15,920
semantics of the operation that you just

293
00:09:15,920 --> 00:09:20,240
did in the state-free circuit ir

294
00:09:20,240 --> 00:09:21,920
so circuit is a pretty clever piece of

295
00:09:21,920 --> 00:09:23,440
machinery that's definitely where the

296
00:09:23,440 --> 00:09:25,440
brains of the operation is but it ends

297
00:09:25,440 --> 00:09:26,720
up working and it makes writing

298
00:09:26,720 --> 00:09:28,080
front-ends very easy because you

299
00:09:28,080 --> 00:09:29,120
basically just sort of write an

300
00:09:29,120 --> 00:09:30,720
interpreter for the high-level language

301
00:09:30,720 --> 00:09:32,000
that you're trying to compile but

302
00:09:32,000 --> 00:09:33,680
whenever your interpreter would interact

303
00:09:33,680 --> 00:09:35,279
with its environment

304
00:09:35,279 --> 00:09:37,040
you don't interact with your environment

305
00:09:37,040 --> 00:09:38,640
you interact with certify and it sort of

306
00:09:38,640 --> 00:09:40,240
automatically embeds your environment

307
00:09:40,240 --> 00:09:41,920
into the circuit at least that's how i

308
00:09:41,920 --> 00:09:42,720
think of it when i write these

309
00:09:42,720 --> 00:09:44,480
front-ends

310
00:09:44,480 --> 00:09:46,560
so this is how sourcing works at a high

311
00:09:46,560 --> 00:09:48,800
level but now let's talk about how well

312
00:09:48,800 --> 00:09:51,920
sourcing works what you can do with it

313
00:09:51,920 --> 00:09:52,720
we

314
00:09:52,720 --> 00:09:53,920
did a whole bunch of stuff in the paper

315
00:09:53,920 --> 00:09:55,200
i'll just tell you about one case study

316
00:09:55,200 --> 00:09:56,800
we built a compiler from this language

317
00:09:56,800 --> 00:09:58,720
zocrates to zero knowledge proofs you're

318
00:09:58,720 --> 00:10:00,080
probably not familiar with socrates but

319
00:10:00,080 --> 00:10:01,440
it's this language from the blockchain

320
00:10:01,440 --> 00:10:03,680
community that was designed expressly to

321
00:10:03,680 --> 00:10:05,440
be compiled to zero knowledge proofs

322
00:10:05,440 --> 00:10:08,240
it's a pretty reasonable language and uh

323
00:10:08,240 --> 00:10:09,839
funding for it is ongoing there are

324
00:10:09,839 --> 00:10:11,839
people still working on it uh given the

325
00:10:11,839 --> 00:10:13,440
amount of investment it's unsurprising

326
00:10:13,440 --> 00:10:15,120
that the the compiler itself is a pretty

327
00:10:15,120 --> 00:10:17,279
substantial piece of software the core

328
00:10:17,279 --> 00:10:19,360
of the compiler the optimizer on its own

329
00:10:19,360 --> 00:10:21,279
is 28 000 lines of code and was

330
00:10:21,279 --> 00:10:23,200
developed over quite a while by a whole

331
00:10:23,200 --> 00:10:25,519
host of individuals on the whole this is

332
00:10:25,519 --> 00:10:27,279
this is a good compiler and so our goal

333
00:10:27,279 --> 00:10:28,880
was essentially to replicate the

334
00:10:28,880 --> 00:10:31,120
socrates reference compiler by building

335
00:10:31,120 --> 00:10:32,480
on cersei

336
00:10:32,480 --> 00:10:33,760
we hoped that we would be able to do

337
00:10:33,760 --> 00:10:35,040
that more easily than building the

338
00:10:35,040 --> 00:10:36,480
compiler from scratch because we would

339
00:10:36,480 --> 00:10:37,600
be benefiting from the common

340
00:10:37,600 --> 00:10:39,200
infrastructure

341
00:10:39,200 --> 00:10:40,720
and i think it's safe to say that the

342
00:10:40,720 --> 00:10:42,000
case study exceeded even our

343
00:10:42,000 --> 00:10:43,279
expectations

344
00:10:43,279 --> 00:10:45,279
so we were ultimately able to replicate

345
00:10:45,279 --> 00:10:46,399
the functionality of the dockers

346
00:10:46,399 --> 00:10:48,399
compiler in a mere 700 lines of code in

347
00:10:48,399 --> 00:10:49,680
one week

348
00:10:49,680 --> 00:10:51,440
and despite the fact that

349
00:10:51,440 --> 00:10:52,880
there's a huge reduction in the amount

350
00:10:52,880 --> 00:10:54,800
of engineering effort that went into our

351
00:10:54,800 --> 00:10:56,560
zocret's compiler it actually produces

352
00:10:56,560 --> 00:10:57,839
output that's slightly better than the

353
00:10:57,839 --> 00:10:59,600
original at least that's what we found

354
00:10:59,600 --> 00:11:01,440
on average when we compiled every

355
00:11:01,440 --> 00:11:04,640
program in the zoccrete standard library

356
00:11:04,640 --> 00:11:06,399
so why did this go so well uh you know

357
00:11:06,399 --> 00:11:08,079
it's not because we're smarter it's

358
00:11:08,079 --> 00:11:09,440
because we weren't building a whole

359
00:11:09,440 --> 00:11:10,959
compiler from scratch we were building

360
00:11:10,959 --> 00:11:13,200
on cersei an existing infrastructure so

361
00:11:13,200 --> 00:11:15,200
all we really did was write a front end

362
00:11:15,200 --> 00:11:16,800
to that infrastructure and then the

363
00:11:16,800 --> 00:11:19,519
infrastructure took care of the rest

364
00:11:19,519 --> 00:11:21,200
and so this is this is a good example of

365
00:11:21,200 --> 00:11:22,800
how compiler infrastructure makes it

366
00:11:22,800 --> 00:11:27,040
easy to build very performant compilers

367
00:11:27,040 --> 00:11:28,880
but cersei has other benefits as well

368
00:11:28,880 --> 00:11:30,480
and the the kind of benefit i want to

369
00:11:30,480 --> 00:11:32,320
discuss now is what we call a crossover

370
00:11:32,320 --> 00:11:33,839
opportunity

371
00:11:33,839 --> 00:11:35,040
and so the observation here is that

372
00:11:35,040 --> 00:11:36,959
cersei's different targets you know

373
00:11:36,959 --> 00:11:39,200
they're not arm and x86 they actually

374
00:11:39,200 --> 00:11:40,959
serve very different purposes we've got

375
00:11:40,959 --> 00:11:42,880
a zkp target that can give you private

376
00:11:42,880 --> 00:11:44,399
efficient proofs

377
00:11:44,399 --> 00:11:46,160
we've also got an smt target that can

378
00:11:46,160 --> 00:11:48,240
answer satisfiability queries we've got

379
00:11:48,240 --> 00:11:49,760
an optimization target that i haven't

380
00:11:49,760 --> 00:11:50,880
mentioned before but can solve

381
00:11:50,880 --> 00:11:52,720
constrained optimization problems and

382
00:11:52,720 --> 00:11:54,399
even things like multi-party computation

383
00:11:54,399 --> 00:11:55,920
and fhe they seem like they're in scope

384
00:11:55,920 --> 00:11:57,839
too and so the question is whether or

385
00:11:57,839 --> 00:11:59,360
not there are some applications that

386
00:11:59,360 --> 00:12:01,120
would want to compile to multiple

387
00:12:01,120 --> 00:12:03,200
targets in order to solve some problem

388
00:12:03,200 --> 00:12:04,160
and you know of course the answer to

389
00:12:04,160 --> 00:12:05,760
that question is yes the only limit here

390
00:12:05,760 --> 00:12:07,920
is our creativity so i'll tell you about

391
00:12:07,920 --> 00:12:09,440
one crossover application that we

392
00:12:09,440 --> 00:12:11,200
explored

393
00:12:11,200 --> 00:12:13,360
which is using the smt solver to

394
00:12:13,360 --> 00:12:15,200
optimize a different compilation

395
00:12:15,200 --> 00:12:16,639
pipeline

396
00:12:16,639 --> 00:12:17,519
there are many ways that you might

397
00:12:17,519 --> 00:12:18,880
imagine doing that we explored one

398
00:12:18,880 --> 00:12:20,800
instantiation which is using the smt

399
00:12:20,800 --> 00:12:22,160
solver to figure out how many times to

400
00:12:22,160 --> 00:12:23,440
enroll a loop

401
00:12:23,440 --> 00:12:24,959
as i said earlier when you're compiling

402
00:12:24,959 --> 00:12:26,160
to circuits there are no loops and

403
00:12:26,160 --> 00:12:28,000
circuits so you have to unroll the loops

404
00:12:28,000 --> 00:12:29,920
how many times do you enroll well if you

405
00:12:29,920 --> 00:12:31,360
enroll too many times then you're just

406
00:12:31,360 --> 00:12:32,800
generating a bigger circuit which is a

407
00:12:32,800 --> 00:12:34,399
waste and if you enroll too few times

408
00:12:34,399 --> 00:12:36,240
then you can't model some executions of

409
00:12:36,240 --> 00:12:38,639
the program which is even worse and so

410
00:12:38,639 --> 00:12:39,760
the question here is how do you find the

411
00:12:39,760 --> 00:12:41,279
goldilocks number

412
00:12:41,279 --> 00:12:42,800
um and it turns out you can use an smt

413
00:12:42,800 --> 00:12:44,639
solver to do that essentially you do

414
00:12:44,639 --> 00:12:46,320
that by doing incremental compilation so

415
00:12:46,320 --> 00:12:47,760
you you take your program you start

416
00:12:47,760 --> 00:12:49,519
compiling it you encounter some loop you

417
00:12:49,519 --> 00:12:51,600
enroll it once and then you ask the smt

418
00:12:51,600 --> 00:12:53,279
solver whether there are some inputs to

419
00:12:53,279 --> 00:12:54,560
the program that would cause the loop to

420
00:12:54,560 --> 00:12:56,560
run at least one time and if the smt

421
00:12:56,560 --> 00:12:57,920
server says yes this path is still

422
00:12:57,920 --> 00:13:00,000
feasible you keep going and you enroll

423
00:13:00,000 --> 00:13:01,680
and enroll and enroll and let's say

424
00:13:01,680 --> 00:13:03,440
after the 33rd unrolling the solver

425
00:13:03,440 --> 00:13:04,800
finally comes back to you and says no

426
00:13:04,800 --> 00:13:06,079
there are no inputs that will cause this

427
00:13:06,079 --> 00:13:08,720
loop to run 33 times

428
00:13:08,720 --> 00:13:11,040
at this point you can throw out the 33rd

429
00:13:11,040 --> 00:13:12,560
compilation result take the 30 second

430
00:13:12,560 --> 00:13:14,399
exit the loop finish compiling and

431
00:13:14,399 --> 00:13:15,920
ultimately lower to whatever back end

432
00:13:15,920 --> 00:13:17,040
you actually cared about in the first

433
00:13:17,040 --> 00:13:18,240
place that might be a zero knowledge

434
00:13:18,240 --> 00:13:20,160
proof that might even be producing an

435
00:13:20,160 --> 00:13:22,639
smt formula that encodes a more complex

436
00:13:22,639 --> 00:13:24,160
query about the program that you're

437
00:13:24,160 --> 00:13:25,920
compiling than how many times this loop

438
00:13:25,920 --> 00:13:27,040
runs

439
00:13:27,040 --> 00:13:28,079
but the point is whatever you're doing

440
00:13:28,079 --> 00:13:30,160
you're doing it with a better cir so the

441
00:13:30,160 --> 00:13:31,440
back end is probably going to perform

442
00:13:31,440 --> 00:13:34,000
better

443
00:13:34,000 --> 00:13:35,839
now in theory any compiler can do this

444
00:13:35,839 --> 00:13:38,079
kind of smt-assisted optimization the

445
00:13:38,079 --> 00:13:39,519
only problem is of course getting the

446
00:13:39,519 --> 00:13:41,680
smt solver to understand the compiler's

447
00:13:41,680 --> 00:13:43,519
ir and the cool thing about circuit is

448
00:13:43,519 --> 00:13:44,720
that we get that for free because smtp

449
00:13:44,720 --> 00:13:46,480
is one of our back ends and so rigging

450
00:13:46,480 --> 00:13:48,639
up this pipeline in our c front end took

451
00:13:48,639 --> 00:13:51,680
a mere 18 lines of code

452
00:13:51,680 --> 00:13:53,680
uh which is yeah that's sort of a lot of

453
00:13:53,680 --> 00:13:54,720
fun

454
00:13:54,720 --> 00:13:56,560
okay so this is one of the crossover

455
00:13:56,560 --> 00:13:58,320
applications we explored i also told you

456
00:13:58,320 --> 00:13:59,760
about one of the case studies of course

457
00:13:59,760 --> 00:14:01,600
there's a lot more in the paper we build

458
00:14:01,600 --> 00:14:03,279
other back ends i mentioned this

459
00:14:03,279 --> 00:14:04,959
optimization back end based on integer

460
00:14:04,959 --> 00:14:06,480
linear programs we built other front

461
00:14:06,480 --> 00:14:08,240
ends for a subset of c for a dialectic

462
00:14:08,240 --> 00:14:09,920
data log for a hardware description

463
00:14:09,920 --> 00:14:11,600
language called surcom

464
00:14:11,600 --> 00:14:13,040
we also explore other crossover

465
00:14:13,040 --> 00:14:15,199
applications we use the smt solver to

466
00:14:15,199 --> 00:14:17,120
lint one of our languages

467
00:14:17,120 --> 00:14:19,600
we explore automatic zero knowledge

468
00:14:19,600 --> 00:14:21,360
proofs of exploitability and you know

469
00:14:21,360 --> 00:14:23,519
show that we can trigger an old cve in

470
00:14:23,519 --> 00:14:26,800
openssl in zero knowledge

471
00:14:26,800 --> 00:14:28,720
and you know so the list goes on

472
00:14:28,720 --> 00:14:30,240
of course this is a compiler paper so we

473
00:14:30,240 --> 00:14:32,240
benchmark benchmark and and benchmark

474
00:14:32,240 --> 00:14:33,760
some more we benchmark our compilers

475
00:14:33,760 --> 00:14:34,959
against other people's compilers we

476
00:14:34,959 --> 00:14:36,160
benchmark our compilers against

477
00:14:36,160 --> 00:14:38,800
hand-tuned code we even do benchmarks in

478
00:14:38,800 --> 00:14:40,800
which we verify that our optimizations

479
00:14:40,800 --> 00:14:42,320
are benefiting multiple different

480
00:14:42,320 --> 00:14:43,440
backends ends

481
00:14:43,440 --> 00:14:44,639
so we're sort of verifying that the

482
00:14:44,639 --> 00:14:46,560
common optimizations are are actually

483
00:14:46,560 --> 00:14:47,760
common

484
00:14:47,760 --> 00:14:49,279
which is just sort of a good reality

485
00:14:49,279 --> 00:14:50,399
check

486
00:14:50,399 --> 00:14:51,600
um yeah so that's that's more or less

487
00:14:51,600 --> 00:14:52,959
what you'll find in the paper um but

488
00:14:52,959 --> 00:14:54,160
there's also a lot of ongoing work that

489
00:14:54,160 --> 00:14:55,760
i want to tell you about we've been of

490
00:14:55,760 --> 00:14:57,600
course investigating other extensions to

491
00:14:57,600 --> 00:14:59,440
the compiler we've been developing a

492
00:14:59,440 --> 00:15:00,959
language called z-sharp an extension of

493
00:15:00,959 --> 00:15:02,880
socrates with some partners in industry

494
00:15:02,880 --> 00:15:04,320
who have a commercial application in

495
00:15:04,320 --> 00:15:06,240
mind one of the cool things about z

496
00:15:06,240 --> 00:15:08,160
sharp is that its type system is rich

497
00:15:08,160 --> 00:15:09,279
enough that we actually need an

498
00:15:09,279 --> 00:15:11,680
inference engine and the way that we do

499
00:15:11,680 --> 00:15:13,440
inference rather than writing our own

500
00:15:13,440 --> 00:15:15,440
like uh our own solver is that we kick

501
00:15:15,440 --> 00:15:17,040
it out to the smt solver and have that

502
00:15:17,040 --> 00:15:18,560
do the inference for us which is kind of

503
00:15:18,560 --> 00:15:20,560
cute uh we've also been working on back

504
00:15:20,560 --> 00:15:22,959
ends with folks from carnegie mellon um

505
00:15:22,959 --> 00:15:24,399
for the other crypto systems that i

506
00:15:24,399 --> 00:15:26,240
alluded to earlier and we've been using

507
00:15:26,240 --> 00:15:28,240
those as a platform to do other kinds of

508
00:15:28,240 --> 00:15:29,920
research into how you compile

509
00:15:29,920 --> 00:15:32,560
effectively for those back ends and

510
00:15:32,560 --> 00:15:34,480
there are also other folks not not us

511
00:15:34,480 --> 00:15:36,240
who have been using cersei as a platform

512
00:15:36,240 --> 00:15:38,800
for other kinds of compilation research

513
00:15:38,800 --> 00:15:40,639
so later this year at usenix security

514
00:15:40,639 --> 00:15:42,160
there will be paper by some folks at

515
00:15:42,160 --> 00:15:43,519
university of pennsylvania including

516
00:15:43,519 --> 00:15:44,880
sebastian angel who's in the audience

517
00:15:44,880 --> 00:15:46,079
right now

518
00:15:46,079 --> 00:15:48,959
on how to compile numerical optimization

519
00:15:48,959 --> 00:15:50,639
problems to snarks which is in some

520
00:15:50,639 --> 00:15:52,160
sense totally orthogonal to cersei but

521
00:15:52,160 --> 00:15:54,000
by building on cersei they were able to

522
00:15:54,000 --> 00:15:56,160
get to the research faster than if they

523
00:15:56,160 --> 00:15:58,399
had to build the compiler themselves

524
00:15:58,399 --> 00:15:59,680
and you know we think that real estate

525
00:15:59,680 --> 00:16:00,480
would be a good platform for

526
00:16:00,480 --> 00:16:02,399
investigating other kinds of compilation

527
00:16:02,399 --> 00:16:04,480
problems as well

528
00:16:04,480 --> 00:16:05,839
so basically we're at the end of the

529
00:16:05,839 --> 00:16:07,040
talk here i've been telling you about

530
00:16:07,040 --> 00:16:08,560
cersei this is our common compiler

531
00:16:08,560 --> 00:16:10,320
infrastructure for translating

532
00:16:10,320 --> 00:16:12,399
high-level programs into existentially

533
00:16:12,399 --> 00:16:14,160
quantified circuits such as those used

534
00:16:14,160 --> 00:16:15,920
by crypto systems the key idea here is

535
00:16:15,920 --> 00:16:17,279
that that existentially quantified

536
00:16:17,279 --> 00:16:19,120
circuit we found that cersei makes it

537
00:16:19,120 --> 00:16:20,560
easy to build compilers that perform

538
00:16:20,560 --> 00:16:22,240
well because those compilers benefit

539
00:16:22,240 --> 00:16:24,000
from shared optimizations

540
00:16:24,000 --> 00:16:25,440
and we think that ultimately of course

541
00:16:25,440 --> 00:16:27,120
the most exciting thing is whatever

542
00:16:27,120 --> 00:16:28,639
happens next we're very interested in

543
00:16:28,639 --> 00:16:30,880
new front ends new back ends and i i

544
00:16:30,880 --> 00:16:33,199
cannot emphasize this enough if you are

545
00:16:33,199 --> 00:16:35,199
have bumped into some problem that looks

546
00:16:35,199 --> 00:16:37,680
like a compilation problem in this place

547
00:16:37,680 --> 00:16:39,920
please come talk to us we'd love to hear

548
00:16:39,920 --> 00:16:41,279
about your problem and help you figure

549
00:16:41,279 --> 00:16:42,720
out whether or not cersei would be a

550
00:16:42,720 --> 00:16:44,480
good tool for working on it thank you

551
00:16:44,480 --> 00:16:45,759
very much i'd be honored to take any

552
00:16:45,759 --> 00:16:47,600
questions yeah great thank you for the

553
00:16:47,600 --> 00:16:49,279
wonderful talk yeah thank you for and

554
00:16:49,279 --> 00:16:51,199
mindful talk if you have any question

555
00:16:51,199 --> 00:16:52,880
please use the microphone to ask

556
00:16:52,880 --> 00:16:55,439
questions

557
00:16:57,040 --> 00:16:58,399
all right this scary time from penn

558
00:16:58,399 --> 00:17:00,880
state so i suppose your c subset does

559
00:17:00,880 --> 00:17:03,199
not model the heap right no memory

560
00:17:03,199 --> 00:17:05,839
allocation that kind of things

561
00:17:05,839 --> 00:17:07,439
if you want to extend your

562
00:17:07,439 --> 00:17:10,240
infrastructure to handle that

563
00:17:10,240 --> 00:17:12,720
how hard would that be yeah so yes we

564
00:17:12,720 --> 00:17:15,839
don't support dynamic allocation on the

565
00:17:15,839 --> 00:17:18,480
heap in rc subset we only handle stack

566
00:17:18,480 --> 00:17:20,640
arrays and um we think that that's a

567
00:17:20,640 --> 00:17:22,240
hard compilation like a hard research

568
00:17:22,240 --> 00:17:23,199
question

569
00:17:23,199 --> 00:17:24,079
um

570
00:17:24,079 --> 00:17:25,760
the heap is just a lot more challenging

571
00:17:25,760 --> 00:17:29,439
to reason about okay thank you

572
00:17:30,400 --> 00:17:32,400
uh john saracino cornell

573
00:17:32,400 --> 00:17:33,679
uh

574
00:17:33,679 --> 00:17:35,200
have you thought about verifying the

575
00:17:35,200 --> 00:17:37,360
correctness of cersei

576
00:17:37,360 --> 00:17:39,039
yeah certainly we're very interested in

577
00:17:39,039 --> 00:17:41,200
that um and

578
00:17:41,200 --> 00:17:42,720
uh i mean so

579
00:17:42,720 --> 00:17:44,799
in sort of to first order um this is a

580
00:17:44,799 --> 00:17:45,919
problem that's quite similar to

581
00:17:45,919 --> 00:17:47,520
translation validation or compiler

582
00:17:47,520 --> 00:17:49,360
verification in general and a lot of the

583
00:17:49,360 --> 00:17:51,679
existing techniques should apply uh very

584
00:17:51,679 --> 00:17:53,679
effectively there is one sort of quirk

585
00:17:53,679 --> 00:17:55,520
which is that we are very interested in

586
00:17:55,520 --> 00:17:57,120
these arithmetic circuit back ends which

587
00:17:57,120 --> 00:17:59,039
are defined over finite fields that

588
00:17:59,039 --> 00:18:00,720
existing tools are pretty bad at

589
00:18:00,720 --> 00:18:03,120
reasoning about so smt solvers are

590
00:18:03,120 --> 00:18:04,880
basically hopeless on this we don't

591
00:18:04,880 --> 00:18:06,480
think it has to be that way we think

592
00:18:06,480 --> 00:18:07,919
that with slightly better solver

593
00:18:07,919 --> 00:18:09,120
technology we could make a lot of

594
00:18:09,120 --> 00:18:10,880
progress on that and that's something

595
00:18:10,880 --> 00:18:12,400
that i'm actively working on right now

596
00:18:12,400 --> 00:18:15,520
and very interested in exploring more

597
00:18:15,520 --> 00:18:18,080
cool things

598
00:18:18,480 --> 00:18:20,720
hi great talk i'm andreas kugler from

599
00:18:20,720 --> 00:18:23,280
cleocards university and i wanted to ask

600
00:18:23,280 --> 00:18:25,679
would it be imaginable to use basically

601
00:18:25,679 --> 00:18:30,160
lm vm ir as input for your front other

602
00:18:30,160 --> 00:18:30,880
to

603
00:18:30,880 --> 00:18:33,200
basically fuse those two

604
00:18:33,200 --> 00:18:34,559
like the previous questions this is this

605
00:18:34,559 --> 00:18:37,520
is a great question um and so um the

606
00:18:37,520 --> 00:18:38,880
relationship to lvm is something that we

607
00:18:38,880 --> 00:18:40,799
thought very carefully about um it

608
00:18:40,799 --> 00:18:42,160
certainly is possible you you could

609
00:18:42,160 --> 00:18:44,160
imagine trying to to sort of uh

610
00:18:44,160 --> 00:18:46,559
translate lvmr to source ir but we think

611
00:18:46,559 --> 00:18:48,080
this is quite challenging and the reason

612
00:18:48,080 --> 00:18:49,840
is that llvm is really intrinsically

613
00:18:49,840 --> 00:18:52,080
designed to be compiled to compile

614
00:18:52,080 --> 00:18:54,000
programs destined for ram register

615
00:18:54,000 --> 00:18:55,919
machines which are like very different

616
00:18:55,919 --> 00:18:57,440
from circuits i mean in some sense like

617
00:18:57,440 --> 00:19:00,160
llvm's ir is is sending the design in

618
00:19:00,160 --> 00:19:01,200
the wrong direction and the

619
00:19:01,200 --> 00:19:02,559
optimizations are optimizing in the

620
00:19:02,559 --> 00:19:03,760
wrong direction

621
00:19:03,760 --> 00:19:05,600
and and that's why we decided to sort of

622
00:19:05,600 --> 00:19:07,360
go our own way but you could imagine

623
00:19:07,360 --> 00:19:08,720
making a bridge that's just very

624
00:19:08,720 --> 00:19:10,799
inefficient yeah okay all right great

625
00:19:10,799 --> 00:19:12,400
wonderful i think we need given the time

626
00:19:12,400 --> 00:19:13,760
limit we need to move on to the next

627
00:19:13,760 --> 00:19:15,919
paper uh so if you have an additional

628
00:19:15,919 --> 00:19:17,280
question please

629
00:19:17,280 --> 00:19:19,760
thought of

