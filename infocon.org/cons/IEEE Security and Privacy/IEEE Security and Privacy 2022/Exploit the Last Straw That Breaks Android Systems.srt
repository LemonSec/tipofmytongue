1
00:00:00,000 --> 00:00:01,280
directly

2
00:00:01,280 --> 00:00:03,840
hello everyone i'm kirk liam from fudan

3
00:00:03,840 --> 00:00:06,080
university it's my great honor to

4
00:00:06,080 --> 00:00:08,639
present our work here this paper is the

5
00:00:08,639 --> 00:00:10,880
joint work of the researchers from fudan

6
00:00:10,880 --> 00:00:13,040
university the pennsylvania state

7
00:00:13,040 --> 00:00:16,400
university and the qinghua university

8
00:00:16,400 --> 00:00:19,119
in android system many system services

9
00:00:19,119 --> 00:00:21,039
play a critical role in running

10
00:00:21,039 --> 00:00:23,920
important tasks especially storing user

11
00:00:23,920 --> 00:00:26,480
and the system data for example the

12
00:00:26,480 --> 00:00:28,320
account manager service help

13
00:00:28,320 --> 00:00:30,080
applications save user account

14
00:00:30,080 --> 00:00:33,920
information to avoid repeated login

15
00:00:33,920 --> 00:00:36,480
however the data storing process is

16
00:00:36,480 --> 00:00:38,960
rarely understood in this work we

17
00:00:38,960 --> 00:00:41,360
conduct the first systematic security

18
00:00:41,360 --> 00:00:43,600
study on the data storing process in

19
00:00:43,600 --> 00:00:46,480
android system services

20
00:00:46,480 --> 00:00:48,879
first of all is the inconsistent

21
00:00:48,879 --> 00:00:50,160
lifecycle

22
00:00:50,160 --> 00:00:52,320
android applications send data to server

23
00:00:52,320 --> 00:00:55,600
precise using vendor-based ipc however

24
00:00:55,600 --> 00:00:57,760
the data's lifecycle is inconsistent

25
00:00:57,760 --> 00:00:59,760
between applications and the system

26
00:00:59,760 --> 00:01:00,879
services

27
00:01:00,879 --> 00:01:02,320
there is the time window between the

28
00:01:02,320 --> 00:01:05,119
data storing and the data releasing

29
00:01:05,119 --> 00:01:07,760
specifically applications can freeze the

30
00:01:07,760 --> 00:01:09,920
data and recycle the occupied memory

31
00:01:09,920 --> 00:01:12,320
sources immediately but the server

32
00:01:12,320 --> 00:01:14,880
process will hold the data for long time

33
00:01:14,880 --> 00:01:16,640
in case that it will be used in the

34
00:01:16,640 --> 00:01:17,600
future

35
00:01:17,600 --> 00:01:19,840
in this way applications can make the

36
00:01:19,840 --> 00:01:21,920
server process consume more resources

37
00:01:21,920 --> 00:01:23,520
than themselves

38
00:01:23,520 --> 00:01:26,080
even worse the android system developers

39
00:01:26,080 --> 00:01:27,920
may also be confused about the life

40
00:01:27,920 --> 00:01:30,159
cycle of the data stored in system

41
00:01:30,159 --> 00:01:32,720
server one example is the comments in

42
00:01:32,720 --> 00:01:34,799
android source code the developers

43
00:01:34,799 --> 00:01:37,119
wonder if this should actively reset

44
00:01:37,119 --> 00:01:39,439
recycle the data once the quarter is

45
00:01:39,439 --> 00:01:41,839
died

46
00:01:42,000 --> 00:01:45,280
secondly is the limited memory usage

47
00:01:45,280 --> 00:01:47,600
android enforces site of limitations on

48
00:01:47,600 --> 00:01:50,320
each processes memory sources including

49
00:01:50,320 --> 00:01:53,320
the system server precise for example

50
00:01:53,320 --> 00:01:56,799
512 megabytes for dev cable memory in

51
00:01:56,799 --> 00:01:58,479
android 11.

52
00:01:58,479 --> 00:02:00,640
the exhaustion of these limited memory

53
00:02:00,640 --> 00:02:03,119
resources will risk the attention of

54
00:02:03,119 --> 00:02:05,600
android recovery mechanisms

55
00:02:05,600 --> 00:02:07,840
which are designed to reboot the system

56
00:02:07,840 --> 00:02:10,399
if it runs into an error stage

57
00:02:10,399 --> 00:02:12,879
as a result with the capability of

58
00:02:12,879 --> 00:02:14,720
exhausting map system server memory

59
00:02:14,720 --> 00:02:17,520
resources attackers can control when the

60
00:02:17,520 --> 00:02:20,879
system will run into an error state

61
00:02:20,879 --> 00:02:24,319
lastly is the lack of memory size check

62
00:02:24,319 --> 00:02:26,800
a straightforward way to avoid memory

63
00:02:26,800 --> 00:02:29,200
resource exhaustion is checking the size

64
00:02:29,200 --> 00:02:31,440
of available memory before storing

65
00:02:31,440 --> 00:02:34,879
client data but we found that summer

66
00:02:34,879 --> 00:02:37,280
some memory side checks are incomplete

67
00:02:37,280 --> 00:02:39,840
first of all the design flaws in android

68
00:02:39,840 --> 00:02:42,640
lpc also pose challenges to inverse

69
00:02:42,640 --> 00:02:44,239
memory size checks

70
00:02:44,239 --> 00:02:46,959
as shown in the figure the live function

71
00:02:46,959 --> 00:02:49,360
does not check if the server's available

72
00:02:49,360 --> 00:02:51,920
memory is enough for the commentator

73
00:02:51,920 --> 00:02:54,720
however enforcing such checks needs to

74
00:02:54,720 --> 00:02:57,040
know the exact size of the required

75
00:02:57,040 --> 00:03:00,239
memory that is the server needs to know

76
00:03:00,239 --> 00:03:02,720
the area's length and the size of each

77
00:03:02,720 --> 00:03:06,080
string object unfortunately the size of

78
00:03:06,080 --> 00:03:08,879
each string object is undefined and can

79
00:03:08,879 --> 00:03:11,120
be any in value

80
00:03:11,120 --> 00:03:12,959
after understanding the data storing

81
00:03:12,959 --> 00:03:15,519
process we found a new kind of space dos

82
00:03:15,519 --> 00:03:17,840
attack this attack relies on

83
00:03:17,840 --> 00:03:20,400
continuously injecting data into android

84
00:03:20,400 --> 00:03:22,400
system services which looks like

85
00:03:22,400 --> 00:03:24,720
continuously adding straws on the back

86
00:03:24,720 --> 00:03:26,319
of a camel

87
00:03:26,319 --> 00:03:28,959
therefore we refer to this dos attack as

88
00:03:28,959 --> 00:03:31,599
a straw attack

89
00:03:31,599 --> 00:03:33,360
to detect such vulnerabilities

90
00:03:33,360 --> 00:03:35,680
automatically we need to address several

91
00:03:35,680 --> 00:03:38,080
challenges first no detailed

92
00:03:38,080 --> 00:03:40,480
documentation can tell us how the data

93
00:03:40,480 --> 00:03:42,239
storing mechanisms are designed and

94
00:03:42,239 --> 00:03:43,599
implemented

95
00:03:43,599 --> 00:03:46,000
thus we should cover as many as data

96
00:03:46,000 --> 00:03:48,239
storing instructions as possible

97
00:03:48,239 --> 00:03:50,560
second there are large number of system

98
00:03:50,560 --> 00:03:52,640
service interfaces in android system

99
00:03:52,640 --> 00:03:55,200
with different functionalities we need

100
00:03:55,200 --> 00:03:57,360
to support the testing of different

101
00:03:57,360 --> 00:03:59,840
interfaces with different inputs

102
00:03:59,840 --> 00:04:02,480
last the memory changes of data storage

103
00:04:02,480 --> 00:04:04,560
operations are often started and how to

104
00:04:04,560 --> 00:04:06,879
monitor the operation may be tested

105
00:04:06,879 --> 00:04:09,280
thousands of times hence we should

106
00:04:09,280 --> 00:04:11,439
monitor attack effects in a light weight

107
00:04:11,439 --> 00:04:13,760
but efficiently

108
00:04:13,760 --> 00:04:16,399
in this work we propose drawfire a

109
00:04:16,399 --> 00:04:19,199
directed grip box fuzzing based approach

110
00:04:19,199 --> 00:04:21,680
which combines static and dynamic

111
00:04:21,680 --> 00:04:24,320
analysis to detect and verify strong

112
00:04:24,320 --> 00:04:26,639
vulnerabilities in all android system

113
00:04:26,639 --> 00:04:29,360
services the basic idea is that we can

114
00:04:29,360 --> 00:04:31,680
continuously input data to server

115
00:04:31,680 --> 00:04:34,000
precise and monitor its memory size

116
00:04:34,000 --> 00:04:36,720
change to see if it can release the

117
00:04:36,720 --> 00:04:39,520
injected data timeline

118
00:04:39,520 --> 00:04:42,240
the main contributions of our works are

119
00:04:42,240 --> 00:04:45,360
summarized at these three aspects first

120
00:04:45,360 --> 00:04:48,000
our work is the first to systematically

121
00:04:48,000 --> 00:04:50,000
uncover the straw attacks in android

122
00:04:50,000 --> 00:04:52,400
system as well as revealing the root

123
00:04:52,400 --> 00:04:55,440
causes of this kind of vulnerability and

124
00:04:55,440 --> 00:04:56,880
we design and

125
00:04:56,880 --> 00:04:58,960
implement a novel tool called the straw

126
00:04:58,960 --> 00:05:01,759
father which can automatically locate

127
00:05:01,759 --> 00:05:03,840
and export the vulnerable interfaces in

128
00:05:03,840 --> 00:05:05,280
android services

129
00:05:05,280 --> 00:05:07,039
we evaluate strong further on three

130
00:05:07,039 --> 00:05:09,199
android systems the results show through

131
00:05:09,199 --> 00:05:12,120
further successfully exports

132
00:05:12,120 --> 00:05:14,639
474 vulnerable interfaces in these

133
00:05:14,639 --> 00:05:16,880
systems and achieve various dose

134
00:05:16,880 --> 00:05:19,520
consequences besides we confirm popular

135
00:05:19,520 --> 00:05:21,280
android applications can also suffer

136
00:05:21,280 --> 00:05:23,680
from store attacks

137
00:05:23,680 --> 00:05:25,919
here is the overview architecture of

138
00:05:25,919 --> 00:05:29,280
strawfather and it has five main physics

139
00:05:29,280 --> 00:05:31,440
as shown in this figure

140
00:05:31,440 --> 00:05:34,720
the first phase is static analysis aimed

141
00:05:34,720 --> 00:05:37,360
to locate vulnerability candidates and

142
00:05:37,360 --> 00:05:41,039
generate initial sales for fusing them

143
00:05:41,039 --> 00:05:43,840
specifically we identify containers from

144
00:05:43,840 --> 00:05:45,919
static fields and the fields of

145
00:05:45,919 --> 00:05:48,160
singleton classes which are thought to

146
00:05:48,160 --> 00:05:51,039
have a long life cycle and with level

147
00:05:51,039 --> 00:05:53,280
operations that increase the size of

148
00:05:53,280 --> 00:05:55,600
selected containers as targeted data

149
00:05:55,600 --> 00:05:57,280
storing instructions

150
00:05:57,280 --> 00:05:59,039
then we perform backward control flow

151
00:05:59,039 --> 00:06:01,680
analysis and data flow analysis to

152
00:06:01,680 --> 00:06:04,160
locate the service interfaces that can

153
00:06:04,160 --> 00:06:06,639
inject data to these containers

154
00:06:06,639 --> 00:06:08,800
for the selected subinterfaces we

155
00:06:08,800 --> 00:06:10,960
generate insurances for them by

156
00:06:10,960 --> 00:06:13,199
extracting all branch conditions

157
00:06:13,199 --> 00:06:15,759
checking the code including constants

158
00:06:15,759 --> 00:06:17,840
and the written values of the method

159
00:06:17,840 --> 00:06:19,039
calls

160
00:06:19,039 --> 00:06:22,240
next we test the interfaces and collect

161
00:06:22,240 --> 00:06:24,400
feedback information to evaluate each

162
00:06:24,400 --> 00:06:27,039
seed's quality in a lightweight week in

163
00:06:27,039 --> 00:06:29,199
this phase we focus on the state's

164
00:06:29,199 --> 00:06:31,360
contribution in both exploration and

165
00:06:31,360 --> 00:06:33,360
exploitation

166
00:06:33,360 --> 00:06:35,919
for exploration we evaluate the seed

167
00:06:35,919 --> 00:06:38,240
based on the distance of the execution

168
00:06:38,240 --> 00:06:40,240
trees to the target data storing

169
00:06:40,240 --> 00:06:42,960
instruction specifically we calculate

170
00:06:42,960 --> 00:06:45,520
the probability of reaching fasting

171
00:06:45,520 --> 00:06:48,479
targets for each triggered method we

172
00:06:48,479 --> 00:06:50,639
assign each edge in the call graph with

173
00:06:50,639 --> 00:06:53,520
their reachability probability under the

174
00:06:53,520 --> 00:06:55,280
guidance of cfg

175
00:06:55,280 --> 00:06:59,599
and use the probability as the distance

176
00:06:59,599 --> 00:07:02,319
for exploitation we focus on two types

177
00:07:02,319 --> 00:07:05,039
of memory resources which are hip memory

178
00:07:05,039 --> 00:07:07,440
size and the size of some container

179
00:07:07,440 --> 00:07:10,720
objects with customized checks as shown

180
00:07:10,720 --> 00:07:12,240
in the figure

181
00:07:12,240 --> 00:07:14,720
the key problem here is that each input

182
00:07:14,720 --> 00:07:17,120
data has little influence on the memory

183
00:07:17,120 --> 00:07:19,520
size even smaller than the regular

184
00:07:19,520 --> 00:07:21,759
change of server memory

185
00:07:21,759 --> 00:07:25,360
thus we execute each seat multiple times

186
00:07:25,360 --> 00:07:28,479
to accumulate its influence so that we

187
00:07:28,479 --> 00:07:32,080
can observe the memory size change

188
00:07:32,080 --> 00:07:34,479
after evaluating the seeds we need to

189
00:07:34,479 --> 00:07:36,560
select the high quality seeds for the

190
00:07:36,560 --> 00:07:38,319
next mutation

191
00:07:38,319 --> 00:07:40,800
in general straw farther fever seeds

192
00:07:40,800 --> 00:07:42,639
that get closer to the target in

193
00:07:42,639 --> 00:07:45,759
exploration phase or consume more memory

194
00:07:45,759 --> 00:07:48,160
in exploitation phase but a critical

195
00:07:48,160 --> 00:07:51,120
obstacle here is how to balance the

196
00:07:51,120 --> 00:07:53,360
trade-off between exploration phase and

197
00:07:53,360 --> 00:07:55,120
the exploitation phase

198
00:07:55,120 --> 00:07:57,919
states with higher contribution do not

199
00:07:57,919 --> 00:08:00,479
always explore the target in practice

200
00:08:00,479 --> 00:08:02,160
due to some hard to satisfy past

201
00:08:02,160 --> 00:08:05,120
constraints or hard to exploit targets

202
00:08:05,120 --> 00:08:07,680
traditional fixed time approaches rely

203
00:08:07,680 --> 00:08:09,599
on the empirical

204
00:08:09,599 --> 00:08:12,000
knowledge of the testes program and are

205
00:08:12,000 --> 00:08:14,400
impractical for the numerous

206
00:08:14,400 --> 00:08:16,800
android service interfaces

207
00:08:16,800 --> 00:08:19,440
besides the exploitation in storefront

208
00:08:19,440 --> 00:08:22,479
can be time consuming and it's hard to

209
00:08:22,479 --> 00:08:25,199
determine the exact time needed

210
00:08:25,199 --> 00:08:27,520
thus to balance the trade-off strong

211
00:08:27,520 --> 00:08:30,560
father uses an adaptive strategy to

212
00:08:30,560 --> 00:08:33,039
dynamically step scheduler

213
00:08:33,039 --> 00:08:35,519
specifically strong father evaluated the

214
00:08:35,519 --> 00:08:37,599
cease based on both its contribution and

215
00:08:37,599 --> 00:08:40,320
the selection times

216
00:08:40,320 --> 00:08:43,440
for the selected seats we use different

217
00:08:43,440 --> 00:08:46,000
mutation strategies for exploration

218
00:08:46,000 --> 00:08:49,440
phase and exploitation phase

219
00:08:49,440 --> 00:08:51,600
for the exploration phase

220
00:08:51,600 --> 00:08:54,800
the goal is to reach the farming targets

221
00:08:54,800 --> 00:08:57,680
so we focus on the control flow related

222
00:08:57,680 --> 00:09:00,720
impulse of the tested interfaces in this

223
00:09:00,720 --> 00:09:01,760
stage

224
00:09:01,760 --> 00:09:04,240
for the exploitation phase the goal is

225
00:09:04,240 --> 00:09:06,800
to execute the targets and consume

226
00:09:06,800 --> 00:09:08,399
memory resources

227
00:09:08,399 --> 00:09:10,880
so we only mutate the consumption

228
00:09:10,880 --> 00:09:12,800
related inputs

229
00:09:12,800 --> 00:09:14,320
note that

230
00:09:14,320 --> 00:09:16,800
repeatedly invoking a service interface

231
00:09:16,800 --> 00:09:19,680
with the same impulse may not result in

232
00:09:19,680 --> 00:09:22,240
cumulative consequences due to the

233
00:09:22,240 --> 00:09:25,440
implicit redundancy checks

234
00:09:25,440 --> 00:09:28,320
and we mutate the inputs towards a trend

235
00:09:28,320 --> 00:09:31,920
of enlarging memory size

236
00:09:32,320 --> 00:09:35,440
finally for the exploit generation

237
00:09:35,440 --> 00:09:38,160
as the explorers of strobe bts are

238
00:09:38,160 --> 00:09:40,800
affected by the runtime environment and

239
00:09:40,800 --> 00:09:43,360
the device performance we collect high

240
00:09:43,360 --> 00:09:45,519
quality seats during fighting and

241
00:09:45,519 --> 00:09:48,480
increase the mutation strategy used for

242
00:09:48,480 --> 00:09:50,880
exploitation stage

243
00:09:50,880 --> 00:09:53,279
we evaluated strong further on three

244
00:09:53,279 --> 00:09:56,000
android systems with the latest security

245
00:09:56,000 --> 00:09:58,720
updates as a result straw father

246
00:09:58,720 --> 00:10:02,399
discovers 35 unicorn vulnerabilities and

247
00:10:02,399 --> 00:10:04,120
outputs

248
00:10:04,120 --> 00:10:08,600
673 explores in total which affect

249
00:10:08,600 --> 00:10:11,360
474 service interfaces

250
00:10:11,360 --> 00:10:14,320
to evaluate the effectiveness of our

251
00:10:14,320 --> 00:10:17,200
adaptive strategy we compare it with

252
00:10:17,200 --> 00:10:19,839
fixed time strategy deployed by classic

253
00:10:19,839 --> 00:10:22,560
co-founders like afl google especially

254
00:10:22,560 --> 00:10:25,120
we randomly select 30 explorable

255
00:10:25,120 --> 00:10:27,120
interfaces from our results

256
00:10:27,120 --> 00:10:29,839
and separately runs through further with

257
00:10:29,839 --> 00:10:32,320
adaptive strategy and two fixed time

258
00:10:32,320 --> 00:10:34,000
strategies

259
00:10:34,000 --> 00:10:36,480
the result shows that our adaptive

260
00:10:36,480 --> 00:10:39,279
strategy fans vulnerable interfaces

261
00:10:39,279 --> 00:10:42,320
faster than the fixed times strategy

262
00:10:42,320 --> 00:10:45,360
and successfully identifies all 30

263
00:10:45,360 --> 00:10:47,279
vulnerable interfaces

264
00:10:47,279 --> 00:10:49,360
well fixed time strategy fails to

265
00:10:49,360 --> 00:10:51,839
discover two of them because before

266
00:10:51,839 --> 00:10:53,760
exceeding the timeout

267
00:10:53,760 --> 00:10:56,240
this is because adaptive strategy leaves

268
00:10:56,240 --> 00:10:58,800
more time for exploitation

269
00:10:58,800 --> 00:11:01,360
now we will show our main findings in

270
00:11:01,360 --> 00:11:04,160
the paper this figure visualize the

271
00:11:04,160 --> 00:11:06,320
numbers of affected interfaces per

272
00:11:06,320 --> 00:11:09,440
system service in android 11.

273
00:11:09,440 --> 00:11:12,839
it shows that among the 200 system

274
00:11:12,839 --> 00:11:16,000
services 35 percent of them contain

275
00:11:16,000 --> 00:11:19,279
exploitable interfaces moreover the most

276
00:11:19,279 --> 00:11:21,760
affected interfaces are from a small

277
00:11:21,760 --> 00:11:24,800
site of services

278
00:11:24,800 --> 00:11:26,720
we then analyze the permission

279
00:11:26,720 --> 00:11:28,800
requirements of the explorable

280
00:11:28,800 --> 00:11:30,160
interfaces

281
00:11:30,160 --> 00:11:31,800
we found that

282
00:11:31,800 --> 00:11:35,760
158 of them require system permissions

283
00:11:35,760 --> 00:11:38,000
this is because the vulnerabilities lie

284
00:11:38,000 --> 00:11:40,880
in the destabilization process which are

285
00:11:40,880 --> 00:11:44,880
executed before the permission checks

286
00:11:44,959 --> 00:11:47,519
we further analyze the location of

287
00:11:47,519 --> 00:11:50,160
vulnerable data storing instructions as

288
00:11:50,160 --> 00:11:51,600
shown in the table

289
00:11:51,600 --> 00:11:53,440
though 54

290
00:11:53,440 --> 00:11:55,920
of the vulnerabilities exist in the

291
00:11:55,920 --> 00:11:59,120
particular apis they only affect a small

292
00:11:59,120 --> 00:12:02,240
part of the exploitable interfaces

293
00:12:02,240 --> 00:12:05,760
that is over 90 percent of interfaces

294
00:12:05,760 --> 00:12:08,639
are exploitable because of the flaws in

295
00:12:08,639 --> 00:12:12,560
their desterialization process

296
00:12:12,639 --> 00:12:15,120
to reveal once these vulnerabilities

297
00:12:15,120 --> 00:12:18,079
appear in android we further conduct a

298
00:12:18,079 --> 00:12:20,800
cross-version analysis from android 8 to

299
00:12:20,800 --> 00:12:22,000
11.

300
00:12:22,000 --> 00:12:24,959
it shows that about six percent of the

301
00:12:24,959 --> 00:12:27,839
interfaces are not exploitable when they

302
00:12:27,839 --> 00:12:30,320
are added into android system

303
00:12:30,320 --> 00:12:32,480
which indicates that this is

304
00:12:32,480 --> 00:12:34,399
vulnerabilities are introduced by

305
00:12:34,399 --> 00:12:37,200
functional updates

306
00:12:37,200 --> 00:12:40,800
to understand how strong bts affects

307
00:12:40,800 --> 00:12:43,440
customized versions of android we

308
00:12:43,440 --> 00:12:45,600
additionally collect three android

309
00:12:45,600 --> 00:12:50,160
devices from huawei samsung and vivo

310
00:12:50,160 --> 00:12:52,959
as these vendors forbid users to root

311
00:12:52,959 --> 00:12:55,760
their devices we cannot rerun strong

312
00:12:55,760 --> 00:12:57,680
further on their systems

313
00:12:57,680 --> 00:12:59,839
so we run the exploits generated by

314
00:12:59,839 --> 00:13:03,040
straw father on these devices directly

315
00:13:03,040 --> 00:13:04,320
as a result

316
00:13:04,320 --> 00:13:06,160
almost all vulnerabilities can be

317
00:13:06,160 --> 00:13:09,200
exploited successfully

318
00:13:09,200 --> 00:13:10,880
we further analyze the strong

319
00:13:10,880 --> 00:13:13,440
vulnerabilities about the time it takes

320
00:13:13,440 --> 00:13:16,240
to render the device unusable

321
00:13:16,240 --> 00:13:17,519
as a result

322
00:13:17,519 --> 00:13:19,760
ninety percent of slow vulnerabilities

323
00:13:19,760 --> 00:13:23,200
can be successfully attacked within 78

324
00:13:23,200 --> 00:13:25,200
seconds on average

325
00:13:25,200 --> 00:13:27,279
this time can be further reduced by

326
00:13:27,279 --> 00:13:31,519
leveraging parallel execution

327
00:13:31,519 --> 00:13:34,000
like system services the regular

328
00:13:34,000 --> 00:13:36,959
services in android applications also

329
00:13:36,959 --> 00:13:40,160
need to store the applications on data

330
00:13:40,160 --> 00:13:43,120
we collect 100 top free applications

331
00:13:43,120 --> 00:13:46,240
from google play and find that

332
00:13:46,240 --> 00:13:51,440
76 of them suffer from strobel paintings

333
00:13:51,440 --> 00:13:53,760
here is a vulnerability case that could

334
00:13:53,760 --> 00:13:56,880
lead to a permanent dos attack

335
00:13:56,880 --> 00:13:59,199
account managed service provides an

336
00:13:59,199 --> 00:14:02,079
interface named at account explicitly

337
00:14:02,079 --> 00:14:04,399
that allows applications to store user

338
00:14:04,399 --> 00:14:08,079
accounts to a database in the external

339
00:14:08,079 --> 00:14:10,000
storage of the device

340
00:14:10,000 --> 00:14:12,959
however the interface does not limit the

341
00:14:12,959 --> 00:14:15,519
number of accounts that each application

342
00:14:15,519 --> 00:14:16,800
can add

343
00:14:16,800 --> 00:14:19,519
word still during the start of android

344
00:14:19,519 --> 00:14:21,920
system the system server will

345
00:14:21,920 --> 00:14:23,920
automatically load all the accounts

346
00:14:23,920 --> 00:14:25,920
stored in this database

347
00:14:25,920 --> 00:14:27,519
which exists

348
00:14:27,519 --> 00:14:29,680
the memory limitation

349
00:14:29,680 --> 00:14:32,160
and the system crashes again

350
00:14:32,160 --> 00:14:34,399
finally the android system will fall

351
00:14:34,399 --> 00:14:35,199
into

352
00:14:35,199 --> 00:14:36,880
an endless loop

353
00:14:36,880 --> 00:14:40,160
it continuously reboots and crashes

354
00:14:40,160 --> 00:14:42,720
which is a permanent dos attack to the

355
00:14:42,720 --> 00:14:46,399
device in this paper we conduct the

356
00:14:46,399 --> 00:14:48,880
first systematic study on the scroll

357
00:14:48,880 --> 00:14:50,880
vulnerabilities which can cause

358
00:14:50,880 --> 00:14:54,160
temporary or permanent dos attacks

359
00:14:54,160 --> 00:14:56,399
then we propose draw further against the

360
00:14:56,399 --> 00:14:59,639
problems and discover

361
00:14:59,639 --> 00:15:03,440
474 vulnerable interfaces affecting

362
00:15:03,440 --> 00:15:06,320
35 percent of real-world android system

363
00:15:06,320 --> 00:15:07,760
services

364
00:15:07,760 --> 00:15:10,560
our findings show that more complete

365
00:15:10,560 --> 00:15:12,959
checks for data from applications are

366
00:15:12,959 --> 00:15:15,920
strongly needed

367
00:15:15,920 --> 00:15:17,920
for more detailed information welcome to

368
00:15:17,920 --> 00:15:22,279
read our paper thank you

369
00:15:22,610 --> 00:15:26,399
[Applause]

370
00:15:27,040 --> 00:15:29,040
cuckoo are you online

371
00:15:29,040 --> 00:15:32,160
oh yeah i got here okay great i know

372
00:15:32,160 --> 00:15:33,759
even though we are

373
00:15:33,759 --> 00:15:35,600
already 216 maybe we can still take a

374
00:15:35,600 --> 00:15:36,880
few questions

375
00:15:36,880 --> 00:15:40,399
questions from the audience

376
00:15:40,399 --> 00:15:42,959
um maybe i can ask you a quick question

377
00:15:42,959 --> 00:15:44,160
um

378
00:15:44,160 --> 00:15:46,160
you i think you start a contribution you

379
00:15:46,160 --> 00:15:49,199
talk about um there's apps also

380
00:15:49,199 --> 00:15:50,320
vulnerable to these store

381
00:15:50,320 --> 00:15:52,560
vulnerabilities and uh

382
00:15:52,560 --> 00:15:54,320
your paper mostly focus on the system

383
00:15:54,320 --> 00:15:55,839
service and what's the difference

384
00:15:55,839 --> 00:15:58,399
between these uh apps and the system

385
00:15:58,399 --> 00:16:00,399
service and why apps also vulnerable to

386
00:16:00,399 --> 00:16:02,800
this vulnerability

387
00:16:02,800 --> 00:16:05,519
oh well well thank you for the question

388
00:16:05,519 --> 00:16:07,839
and the applications are also affected

389
00:16:07,839 --> 00:16:10,160
by this kind of vulnerability on the one

390
00:16:10,160 --> 00:16:11,199
hand

391
00:16:11,199 --> 00:16:13,199
applications inherit the vulnerabilities

392
00:16:13,199 --> 00:16:15,680
in android distribution process because

393
00:16:15,680 --> 00:16:17,920
they also use today i want to talk about

394
00:16:17,920 --> 00:16:20,920
our

395
00:16:23,600 --> 00:16:25,519
it's okay

396
00:16:25,519 --> 00:16:27,440
go ahead okay

397
00:16:27,440 --> 00:16:29,360
on the other hand they implement

398
00:16:29,360 --> 00:16:32,160
vulnerable containers in to store class

399
00:16:32,160 --> 00:16:34,079
data but without any limitation and

400
00:16:34,079 --> 00:16:35,279
protection

401
00:16:35,279 --> 00:16:36,480
and

402
00:16:36,480 --> 00:16:37,279
yeah

403
00:16:37,279 --> 00:16:39,759
in this work we only focused on the

404
00:16:39,759 --> 00:16:42,320
with many focus on the system and

405
00:16:42,320 --> 00:16:44,720
we focus on the similarities between

406
00:16:44,720 --> 00:16:46,880
applications and systems as for the

407
00:16:46,880 --> 00:16:49,120
differences we leave that for the later

408
00:16:49,120 --> 00:16:50,639
study

409
00:16:50,639 --> 00:16:53,759
great so any other questions

410
00:16:53,759 --> 00:16:55,759
all right

411
00:16:55,759 --> 00:16:58,399
okay okay so this is draw from purdue

412
00:16:58,399 --> 00:17:00,639
and i wanna follow the professor nin's

413
00:17:00,639 --> 00:17:02,160
questions like

414
00:17:02,160 --> 00:17:03,279
for the

415
00:17:03,279 --> 00:17:06,160
i know the the impact of the vulnerable

416
00:17:06,160 --> 00:17:09,039
in the vulnerability in certain servers

417
00:17:09,039 --> 00:17:11,679
but as you also mentioned that many apps

418
00:17:11,679 --> 00:17:13,520
many user apps contain the strong

419
00:17:13,520 --> 00:17:16,079
vulnerabilities so what's the real-world

420
00:17:16,079 --> 00:17:17,280
impact of

421
00:17:17,280 --> 00:17:20,480
the strong vulnerabilities in you

422
00:17:20,480 --> 00:17:23,919
user app i cannot think about a concrete

423
00:17:23,919 --> 00:17:27,280
case which will do some bad things so

424
00:17:27,280 --> 00:17:31,520
could you give some insight about this

425
00:17:31,520 --> 00:17:32,720
oh well

426
00:17:32,720 --> 00:17:35,190
that's a good question um

427
00:17:35,190 --> 00:17:37,120
[Music]

428
00:17:37,120 --> 00:17:39,440
as i said in the

429
00:17:39,440 --> 00:17:41,280
presentation uh this kind of

430
00:17:41,280 --> 00:17:43,200
vulnerability can

431
00:17:43,200 --> 00:17:45,840
be leveraged by attackers to

432
00:17:45,840 --> 00:17:49,200
inject a large amount of data to the

433
00:17:49,200 --> 00:17:51,760
target process for the application we

434
00:17:51,760 --> 00:17:52,880
can

435
00:17:52,880 --> 00:17:55,120
just

436
00:17:55,120 --> 00:17:57,039
inject the data to the applications

437
00:17:57,039 --> 00:17:59,600
process through the through their

438
00:17:59,600 --> 00:18:02,799
exported components and when they are

439
00:18:02,799 --> 00:18:03,760
running

440
00:18:03,760 --> 00:18:05,679
and we can

441
00:18:05,679 --> 00:18:09,280
let the applications crash

442
00:18:09,280 --> 00:18:10,960
okay so the way

443
00:18:10,960 --> 00:18:13,039
then we can restart the app the other

444
00:18:13,039 --> 00:18:14,640
thing is car

445
00:18:14,640 --> 00:18:15,919
yeah well

446
00:18:15,919 --> 00:18:19,360
for more money for more serious

447
00:18:19,360 --> 00:18:22,400
results the politicians may

448
00:18:22,400 --> 00:18:24,400
not be able to

449
00:18:24,400 --> 00:18:26,080
run normally again

450
00:18:26,080 --> 00:18:27,600
they must

451
00:18:27,600 --> 00:18:30,400
install the applications and

452
00:18:30,400 --> 00:18:31,600
reinstall

453
00:18:31,600 --> 00:18:33,600
the applications

454
00:18:33,600 --> 00:18:35,840
thanks thanks for your answer

455
00:18:35,840 --> 00:18:37,280
all right there's no more questions

456
00:18:37,280 --> 00:18:39,120
let's uh thank all the speakers in this

457
00:18:39,120 --> 00:18:40,710
session

458
00:18:40,710 --> 00:18:43,829
[Applause]

