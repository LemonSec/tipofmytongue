1
00:00:00,240 --> 00:00:02,720
hi thanks and uh i promise i will be on

2
00:00:02,720 --> 00:00:04,000
time so

3
00:00:04,000 --> 00:00:06,319
expect like five to ten minutes late i

4
00:00:06,319 --> 00:00:08,559
think i'm not sure it's time now and uh

5
00:00:08,559 --> 00:00:10,719
so i'm hao jian i'm going to present our

6
00:00:10,719 --> 00:00:13,679
paper peekaboo so a hub-based approach

7
00:00:13,679 --> 00:00:16,000
to enable transparency in data

8
00:00:16,000 --> 00:00:17,920
processing within smart homes this

9
00:00:17,920 --> 00:00:20,000
project is collaborated with graham

10
00:00:20,000 --> 00:00:24,800
david swaron yuvraj and jason

11
00:00:26,160 --> 00:00:28,240
the initial idea of this project is from

12
00:00:28,240 --> 00:00:30,400
a discussion with google nest team

13
00:00:30,400 --> 00:00:32,880
so the team wants to assure users that

14
00:00:32,880 --> 00:00:35,200
they only collect aggregated data such

15
00:00:35,200 --> 00:00:38,239
as the daily average indoor temperature

16
00:00:38,239 --> 00:00:40,000
but when you think about this problem

17
00:00:40,000 --> 00:00:42,160
it's a surprise it's surprisingly hard

18
00:00:42,160 --> 00:00:45,200
to implement because the edge device the

19
00:00:45,200 --> 00:00:47,520
communication and the server are all

20
00:00:47,520 --> 00:00:49,280
black boxes

21
00:00:49,280 --> 00:00:51,360
and the only solution to achieve this

22
00:00:51,360 --> 00:00:54,480
seems to open source the edge device

23
00:00:54,480 --> 00:00:56,559
however even if developers open source

24
00:00:56,559 --> 00:00:59,280
their software who is going to reduce

25
00:00:59,280 --> 00:01:01,440
the source code and verify their program

26
00:01:01,440 --> 00:01:02,640
behavior

27
00:01:02,640 --> 00:01:04,799
so in this talk i will introduce our

28
00:01:04,799 --> 00:01:06,640
solution called peakable towards this

29
00:01:06,640 --> 00:01:09,360
problem and it explains advantages and

30
00:01:09,360 --> 00:01:13,479
the limitations of our approach

31
00:01:14,479 --> 00:01:16,720
so let me start with a simple example so

32
00:01:16,720 --> 00:01:19,280
imagine that a smart tv developer wants

33
00:01:19,280 --> 00:01:21,840
to know how engaging the device is they

34
00:01:21,840 --> 00:01:24,000
want to know how much time the user has

35
00:01:24,000 --> 00:01:26,960
spent on the tv in the past week

36
00:01:26,960 --> 00:01:28,960
most likely today they will collect the

37
00:01:28,960 --> 00:01:31,280
total table of users video watching

38
00:01:31,280 --> 00:01:33,280
history to the cloud

39
00:01:33,280 --> 00:01:35,600
long term competition there and find the

40
00:01:35,600 --> 00:01:38,320
user spends 25 hours per week

41
00:01:38,320 --> 00:01:40,400
but the issue is that while this data is

42
00:01:40,400 --> 00:01:42,720
just from tv it may expose many

43
00:01:42,720 --> 00:01:45,600
unnecessary insights such as

44
00:01:45,600 --> 00:01:47,920
is used at home when do they watch tv

45
00:01:47,920 --> 00:01:52,119
what are users interests

46
00:01:55,439 --> 00:01:57,600
so to mitigate this type of privacy risk

47
00:01:57,600 --> 00:01:59,759
a simple change is developers can

48
00:01:59,759 --> 00:02:02,000
aggregate the data on the tv device

49
00:02:02,000 --> 00:02:04,079
locally and only collect the number like

50
00:02:04,079 --> 00:02:06,240
25 hours per week

51
00:02:06,240 --> 00:02:08,399
and the question we hear we focus here

52
00:02:08,399 --> 00:02:10,959
is how can developers prove to users

53
00:02:10,959 --> 00:02:15,040
that they only collect 25 hours per week

54
00:02:18,000 --> 00:02:20,959
so a strongman solution is to extend

55
00:02:20,959 --> 00:02:23,120
android permission manifest so for

56
00:02:23,120 --> 00:02:25,200
example android tv can have more

57
00:02:25,200 --> 00:02:28,160
fine-grained permissions in the manifest

58
00:02:28,160 --> 00:02:30,319
and then the developers can declare they

59
00:02:30,319 --> 00:02:32,480
want weekly aggregate data or daily

60
00:02:32,480 --> 00:02:34,080
aggregated data

61
00:02:34,080 --> 00:02:36,000
but this will result in numerous

62
00:02:36,000 --> 00:02:38,480
permissions it will be very hard for

63
00:02:38,480 --> 00:02:41,120
google to offer android tv developer to

64
00:02:41,120 --> 00:02:43,200
implement these apis and it would be

65
00:02:43,200 --> 00:02:45,120
also very hard for developers to learn

66
00:02:45,120 --> 00:02:46,800
this api

67
00:02:46,800 --> 00:02:48,640
and for users it will also be very hard

68
00:02:48,640 --> 00:02:51,040
to implement them or to manage them

69
00:02:51,040 --> 00:02:53,760
and how can we do something better

70
00:02:53,760 --> 00:02:55,360
so we have peekaboo

71
00:02:55,360 --> 00:02:57,840
so people have three key ideas

72
00:02:57,840 --> 00:02:59,680
the first is it's a new way for

73
00:02:59,680 --> 00:03:02,000
developers to program pre-processing

74
00:03:02,000 --> 00:03:03,200
functions

75
00:03:03,200 --> 00:03:05,920
so it's instead of letting developers to

76
00:03:05,920 --> 00:03:08,239
write arbitrary code like python or c

77
00:03:08,239 --> 00:03:10,959
plus code the platform builders should

78
00:03:10,959 --> 00:03:13,760
offer a set of fixed set of operators

79
00:03:13,760 --> 00:03:16,400
and here each operator is a trainable

80
00:03:16,400 --> 00:03:18,560
data processing functions

81
00:03:18,560 --> 00:03:21,120
and the program is a stream oriented

82
00:03:21,120 --> 00:03:24,080
pipeline similar to unix pipes

83
00:03:24,080 --> 00:03:25,840
and the picture is a programming

84
00:03:25,840 --> 00:03:28,080
environment we build in pickable and

85
00:03:28,080 --> 00:03:30,480
here the app developer can drag the

86
00:03:30,480 --> 00:03:33,760
operators from left connect them into a

87
00:03:33,760 --> 00:03:36,159
pipeline and configure the properties of

88
00:03:36,159 --> 00:03:38,560
each operator

89
00:03:38,560 --> 00:03:41,519
and second the app developers can export

90
00:03:41,519 --> 00:03:44,400
the program as a text-based manifest

91
00:03:44,400 --> 00:03:47,040
the text-based manifest this describes

92
00:03:47,040 --> 00:03:49,760
how the app developer wants to like

93
00:03:49,760 --> 00:03:52,080
crack users data the manifest here

94
00:03:52,080 --> 00:03:55,120
describes they want to measure device

95
00:03:55,120 --> 00:03:57,519
engagement and here the manifest pulls

96
00:03:57,519 --> 00:04:00,319
the data from the tv device each week

97
00:04:00,319 --> 00:04:02,959
aggregate the data and post results to

98
00:04:02,959 --> 00:04:05,360
the cloud

99
00:04:06,560 --> 00:04:08,799
and finally a trusted in-home hub will

100
00:04:08,799 --> 00:04:11,519
mediate between the edge devices and the

101
00:04:11,519 --> 00:04:12,879
cloud servers

102
00:04:12,879 --> 00:04:15,439
the hub has a set of pre-loaded

103
00:04:15,439 --> 00:04:17,680
implementations so when the hub loads

104
00:04:17,680 --> 00:04:20,399
the manifest it maps all the operators

105
00:04:20,399 --> 00:04:23,120
to the specific implementation

106
00:04:23,120 --> 00:04:24,960
and based on operator properties and

107
00:04:24,960 --> 00:04:27,680
then assemble a pre-processing pipeline

108
00:04:27,680 --> 00:04:29,759
based on the manifest

109
00:04:29,759 --> 00:04:32,600
and here the many the pipeline will pro

110
00:04:32,600 --> 00:04:35,440
pre-process the complete video watch

111
00:04:35,440 --> 00:04:39,840
history into a numeric value

112
00:04:41,280 --> 00:04:43,520
so in summary the smart home hub store

113
00:04:43,520 --> 00:04:45,919
creates a programming environment and

114
00:04:45,919 --> 00:04:48,240
offers a fixed set of operators

115
00:04:48,240 --> 00:04:50,320
the app developer then creates a

116
00:04:50,320 --> 00:04:52,639
pre-processing pipeline by constructing

117
00:04:52,639 --> 00:04:55,280
a set of by constructing a pipeline

118
00:04:55,280 --> 00:04:57,040
using these operators

119
00:04:57,040 --> 00:04:59,280
and finally the long time will load the

120
00:04:59,280 --> 00:05:03,520
manifest and create the actual program

121
00:05:04,240 --> 00:05:06,639
so in the future the smart home app

122
00:05:06,639 --> 00:05:08,960
store all these apps will be simple text

123
00:05:08,960 --> 00:05:10,479
with manifest

124
00:05:10,479 --> 00:05:12,880
once a user install a new app the hub

125
00:05:12,880 --> 00:05:15,199
will load a new manifest create a

126
00:05:15,199 --> 00:05:16,960
pipeline based on

127
00:05:16,960 --> 00:05:20,080
between the edge device and the cloud

128
00:05:20,080 --> 00:05:22,240
notice the hub device is a local device

129
00:05:22,240 --> 00:05:23,680
in your home

130
00:05:23,680 --> 00:05:26,240
so it can be your future like wi-fi

131
00:05:26,240 --> 00:05:27,600
router

132
00:05:27,600 --> 00:05:29,280
through pickable the hub now became

133
00:05:29,280 --> 00:05:32,160
something a new type of privacy firewall

134
00:05:32,160 --> 00:05:34,320
and a base and which will filter data

135
00:05:34,320 --> 00:05:36,240
based on the manifest declared by

136
00:05:36,240 --> 00:05:39,240
developers

137
00:05:41,120 --> 00:05:43,039
so the design of pickable is motivated

138
00:05:43,039 --> 00:05:44,560
by two insights

139
00:05:44,560 --> 00:05:46,960
so first app developers they must

140
00:05:46,960 --> 00:05:49,360
declare intended data collection

141
00:05:49,360 --> 00:05:53,120
behavior in text based manifest so this

142
00:05:53,120 --> 00:05:54,800
leads to two fundamental differences

143
00:05:54,800 --> 00:05:56,880
between peekaboo and a traditional

144
00:05:56,880 --> 00:05:57,919
firewall

145
00:05:57,919 --> 00:06:00,560
first it is a white list only system

146
00:06:00,560 --> 00:06:02,160
this is feasible because the

147
00:06:02,160 --> 00:06:04,720
functionality of iot devices are much

148
00:06:04,720 --> 00:06:07,919
simpler than pc or mobile mobile phone

149
00:06:07,919 --> 00:06:10,639
it's unnecessary for these iot devices

150
00:06:10,639 --> 00:06:14,400
to have general purpose network access

151
00:06:14,400 --> 00:06:15,280
second

152
00:06:15,280 --> 00:06:17,840
developers are involved in the process

153
00:06:17,840 --> 00:06:19,600
instead of letting the firewall to

154
00:06:19,600 --> 00:06:22,160
figure out which network request is is

155
00:06:22,160 --> 00:06:24,319
legitimate or not

156
00:06:24,319 --> 00:06:26,639
people explicitly ask developers to

157
00:06:26,639 --> 00:06:29,120
declare why do they want to collect data

158
00:06:29,120 --> 00:06:32,800
and what data granularity they want

159
00:06:33,440 --> 00:06:35,360
and the second insight is that most

160
00:06:35,360 --> 00:06:37,360
smart home applications they do not

161
00:06:37,360 --> 00:06:39,280
really need raw data

162
00:06:39,280 --> 00:06:41,840
we collect over 200 smart home id

163
00:06:41,840 --> 00:06:44,319
smartphone ideas and analyze how these

164
00:06:44,319 --> 00:06:46,479
applications can be implemented in the

165
00:06:46,479 --> 00:06:47,759
real world

166
00:06:47,759 --> 00:06:48,960
and indeed

167
00:06:48,960 --> 00:06:51,039
among all these applications less than a

168
00:06:51,039 --> 00:06:53,759
quarter of them really need raw data for

169
00:06:53,759 --> 00:06:55,680
example imagine if we want to have an

170
00:06:55,680 --> 00:06:58,160
application called hello visitor that

171
00:06:58,160 --> 00:07:00,400
you can install on your video adobe

172
00:07:00,400 --> 00:07:02,800
the app wants to recognize the person in

173
00:07:02,800 --> 00:07:05,120
front of the video w but they only need

174
00:07:05,120 --> 00:07:06,639
a face image

175
00:07:06,639 --> 00:07:09,520
or if we want to use alexa to compute

176
00:07:09,520 --> 00:07:11,759
the noise level the device can do it

177
00:07:11,759 --> 00:07:16,199
without sending the data to the cloud

178
00:07:16,479 --> 00:07:18,240
so here comes like a main difference

179
00:07:18,240 --> 00:07:19,680
between peekaboo and a traditional

180
00:07:19,680 --> 00:07:21,919
firewall is peakable does not simply

181
00:07:21,919 --> 00:07:24,880
allow or deny a traffic request

182
00:07:24,880 --> 00:07:27,680
it also pre-process the data to mitigate

183
00:07:27,680 --> 00:07:30,080
all the potential privacy risks so for

184
00:07:30,080 --> 00:07:32,800
example here the hub can pre-process the

185
00:07:32,800 --> 00:07:33,759
complete

186
00:07:33,759 --> 00:07:38,080
video watch history into a numeric value

187
00:07:38,080 --> 00:07:40,080
so to recap there are two main

188
00:07:40,080 --> 00:07:41,680
differences between peakable and a

189
00:07:41,680 --> 00:07:44,000
traditional firewall so first it allows

190
00:07:44,000 --> 00:07:46,639
white listed network requests declared

191
00:07:46,639 --> 00:07:48,080
by developers

192
00:07:48,080 --> 00:07:50,879
and second it pre-processed users data

193
00:07:50,879 --> 00:07:54,560
to mitigate privacy risks

194
00:07:54,960 --> 00:07:56,879
now i will dive into the system to

195
00:07:56,879 --> 00:07:59,120
explain how system works

196
00:07:59,120 --> 00:08:01,280
we assume that the edge devices will

197
00:08:01,280 --> 00:08:03,680
have some form of device api

198
00:08:03,680 --> 00:08:06,160
we create a few device drivers to wrap

199
00:08:06,160 --> 00:08:08,960
up these device apis and prepare them

200
00:08:08,960 --> 00:08:12,240
into a unified data model

201
00:08:12,240 --> 00:08:14,160
there are five types of data streams in

202
00:08:14,160 --> 00:08:15,599
peekaboo

203
00:08:15,599 --> 00:08:18,960
video image audio tabular and scalar

204
00:08:18,960 --> 00:08:19,919
value

205
00:08:19,919 --> 00:08:21,759
and the unique design of peakable is

206
00:08:21,759 --> 00:08:24,000
that we only have a fixed set of

207
00:08:24,000 --> 00:08:25,759
operators

208
00:08:25,759 --> 00:08:29,680
in total we only have 16 operators

209
00:08:29,680 --> 00:08:32,880
the operator idea is inspired by sql

210
00:08:32,880 --> 00:08:34,958
database query language when we think

211
00:08:34,958 --> 00:08:37,599
about this a slack operator in database

212
00:08:37,599 --> 00:08:40,399
it just selects a low from a table

213
00:08:40,399 --> 00:08:42,958
but if we zoom out the id of operators

214
00:08:42,958 --> 00:08:45,839
can be data agnostic for example we can

215
00:08:45,839 --> 00:08:48,720
also select a face from an image

216
00:08:48,720 --> 00:08:50,560
for select we always want to select some

217
00:08:50,560 --> 00:08:55,560
partial content from the raw data

218
00:08:55,760 --> 00:08:58,560
the specific behavior of an operator is

219
00:08:58,560 --> 00:09:00,160
determined by the properties of the

220
00:09:00,160 --> 00:09:01,279
operator

221
00:09:01,279 --> 00:09:03,600
for example if the property of the slack

222
00:09:03,600 --> 00:09:05,920
operator is low the runtime will map the

223
00:09:05,920 --> 00:09:08,000
operator to the low selection

224
00:09:08,000 --> 00:09:10,480
implementation or if the property is

225
00:09:10,480 --> 00:09:12,480
fixed the runtime will map it to the

226
00:09:12,480 --> 00:09:14,560
image cropping one

227
00:09:14,560 --> 00:09:15,839
although there might be multiple

228
00:09:15,839 --> 00:09:18,560
implementation of the same operator but

229
00:09:18,560 --> 00:09:20,959
the input and output semantics would be

230
00:09:20,959 --> 00:09:23,839
consistent because these semantics are

231
00:09:23,839 --> 00:09:27,120
determined by the verb like itself

232
00:09:27,120 --> 00:09:29,360
so using these operators to organize

233
00:09:29,360 --> 00:09:31,440
this implementation can make it much

234
00:09:31,440 --> 00:09:35,560
easier to analyze the program

235
00:09:36,560 --> 00:09:38,959
so notice that the hub will not be a

236
00:09:38,959 --> 00:09:40,720
huge library of pre-loaded

237
00:09:40,720 --> 00:09:43,519
implementations we only need some very

238
00:09:43,519 --> 00:09:45,519
simple and common standard

239
00:09:45,519 --> 00:09:47,360
pre-processing algorithms such as phase

240
00:09:47,360 --> 00:09:50,160
detection tabular aggregation and the

241
00:09:50,160 --> 00:09:53,200
philosophy here is this simple and basic

242
00:09:53,200 --> 00:09:54,880
pre-processing functions can improve

243
00:09:54,880 --> 00:09:56,480
privacy a lot

244
00:09:56,480 --> 00:09:58,880
we only need to process the data into

245
00:09:58,880 --> 00:10:02,480
less privacy invasive format

246
00:10:02,880 --> 00:10:04,399
we then build a system

247
00:10:04,399 --> 00:10:06,079
using like a set of hardware and

248
00:10:06,079 --> 00:10:08,560
software to test our design we build a

249
00:10:08,560 --> 00:10:10,800
physical hub using raspberry pi and a

250
00:10:10,800 --> 00:10:14,480
google usb tpu we also build many smart

251
00:10:14,480 --> 00:10:16,800
home edge devices that are compatible to

252
00:10:16,800 --> 00:10:19,279
the picobrew protocol and we use aws to

253
00:10:19,279 --> 00:10:22,720
host our back-end service

254
00:10:22,800 --> 00:10:25,120
we then implemented these operators in

255
00:10:25,120 --> 00:10:27,600
node.js packages and created and

256
00:10:27,600 --> 00:10:30,320
programming ide and developers drivers

257
00:10:30,320 --> 00:10:32,079
and 23 like preloaded operator

258
00:10:32,079 --> 00:10:34,320
implementations

259
00:10:34,320 --> 00:10:36,480
using this hardware and software we are

260
00:10:36,480 --> 00:10:39,279
able to implement over 200 smart home

261
00:10:39,279 --> 00:10:43,519
applications which i mentioned earlier

262
00:10:43,760 --> 00:10:45,839
so since many manifests can be reused

263
00:10:45,839 --> 00:10:48,000
across different scenarios we finally

264
00:10:48,000 --> 00:10:50,560
implement 68 manifests to cover all

265
00:10:50,560 --> 00:10:52,399
these 200

266
00:10:52,399 --> 00:10:53,680
scenarios

267
00:10:53,680 --> 00:10:56,079
and this manifests can support various

268
00:10:56,079 --> 00:10:58,560
types of data processing

269
00:10:58,560 --> 00:10:59,839
and the example i used in the

270
00:10:59,839 --> 00:11:01,680
presentation are the simple ones so due

271
00:11:01,680 --> 00:11:03,440
to the time limit i will not cover the

272
00:11:03,440 --> 00:11:05,440
most sophisticated one please check them

273
00:11:05,440 --> 00:11:07,360
in my paper

274
00:11:07,360 --> 00:11:09,839
among all these scenarios only three

275
00:11:09,839 --> 00:11:12,480
which is at the bottom is always in raw

276
00:11:12,480 --> 00:11:13,519
data

277
00:11:13,519 --> 00:11:15,680
and for this case developers can simply

278
00:11:15,680 --> 00:11:18,079
connect the poor operator to a

279
00:11:18,079 --> 00:11:19,519
post operator

280
00:11:19,519 --> 00:11:20,240
so

281
00:11:20,240 --> 00:11:21,680
although it does not really offer any

282
00:11:21,680 --> 00:11:23,680
data minimizations here but it makes the

283
00:11:23,680 --> 00:11:27,279
data collection more transparent

284
00:11:27,680 --> 00:11:29,519
we are using some lower end hardware to

285
00:11:29,519 --> 00:11:31,279
build as a whole prototype but the

286
00:11:31,279 --> 00:11:32,880
system performance is efficient is

287
00:11:32,880 --> 00:11:35,440
sufficient to support a typical home

288
00:11:35,440 --> 00:11:38,000
our a prototype can do 25 inference

289
00:11:38,000 --> 00:11:40,399
tasks per second and can do 100

290
00:11:40,399 --> 00:11:42,480
filtering tasks per second and

291
00:11:42,480 --> 00:11:44,320
it introduces a latency between one

292
00:11:44,320 --> 00:11:47,760
millisecond to 80 milliseconds

293
00:11:49,440 --> 00:11:51,839
and remember that we also mentioned as a

294
00:11:51,839 --> 00:11:53,519
few like standard and common

295
00:11:53,519 --> 00:11:55,839
pre-processing algorithms can mitigate

296
00:11:55,839 --> 00:11:58,320
many privacy risks we also run a few

297
00:11:58,320 --> 00:12:00,880
utility privacy tradeoff for example

298
00:12:00,880 --> 00:12:02,800
for example if we insert a noisify

299
00:12:02,800 --> 00:12:05,600
operator for a speech assistant

300
00:12:05,600 --> 00:12:07,680
and we can break the speaker recognition

301
00:12:07,680 --> 00:12:10,000
completely while the speech recognition

302
00:12:10,000 --> 00:12:14,000
accuracy only dropped by two percent

303
00:12:14,560 --> 00:12:16,880
and we also show the tools to developers

304
00:12:16,880 --> 00:12:19,360
and to see if z can learn the api and

305
00:12:19,360 --> 00:12:21,680
the builders manifest quickly we show

306
00:12:21,680 --> 00:12:23,519
developers a few example task

307
00:12:23,519 --> 00:12:24,560
descriptions

308
00:12:24,560 --> 00:12:26,160
and as a programming environment and

309
00:12:26,160 --> 00:12:27,440
unit tests

310
00:12:27,440 --> 00:12:29,680
all developers can learn the api quickly

311
00:12:29,680 --> 00:12:32,320
and spend 6 to 15 minutes to author and

312
00:12:32,320 --> 00:12:34,959
manifest

313
00:12:35,360 --> 00:12:37,040
pickable offers a few important

314
00:12:37,040 --> 00:12:39,760
advantages which is not possible before

315
00:12:39,760 --> 00:12:42,079
the first is now the manifesto can

316
00:12:42,079 --> 00:12:44,480
enforce the data collection behavior

317
00:12:44,480 --> 00:12:46,320
and developer can only collect the data

318
00:12:46,320 --> 00:12:48,880
they specified in the manifest

319
00:12:48,880 --> 00:12:50,639
none of the algorithm or implementation

320
00:12:50,639 --> 00:12:53,040
will be proprietary so the app store can

321
00:12:53,040 --> 00:12:54,800
just make that manifest public to

322
00:12:54,800 --> 00:12:56,000
everyone

323
00:12:56,000 --> 00:12:57,519
and this would make all the data

324
00:12:57,519 --> 00:12:59,440
collection behavior transparent and

325
00:12:59,440 --> 00:13:01,440
whilst the device and

326
00:13:01,440 --> 00:13:05,440
the server would still be proprietary

327
00:13:05,519 --> 00:13:07,360
today large develop large players like

328
00:13:07,360 --> 00:13:10,399
amazon or agnes samsung they only they

329
00:13:10,399 --> 00:13:12,959
can develop their own privacy features

330
00:13:12,959 --> 00:13:14,800
but a big challenge is for these small

331
00:13:14,800 --> 00:13:16,880
developers they have no resource to

332
00:13:16,880 --> 00:13:19,360
build all these privacy features

333
00:13:19,360 --> 00:13:21,279
and what's worse is even if we push

334
00:13:21,279 --> 00:13:23,519
everyone to build their privacy features

335
00:13:23,519 --> 00:13:25,839
it will be very hard for end users

336
00:13:25,839 --> 00:13:27,279
because they have to face all these

337
00:13:27,279 --> 00:13:30,160
distributed interfaces with inconsistent

338
00:13:30,160 --> 00:13:32,719
semantics

339
00:13:32,959 --> 00:13:35,519
and the idea here is peekaboo can

340
00:13:35,519 --> 00:13:37,760
approach this diameter by offering a set

341
00:13:37,760 --> 00:13:40,079
of independent features through the hub

342
00:13:40,079 --> 00:13:41,600
itself

343
00:13:41,600 --> 00:13:43,199
since we only have a small set of

344
00:13:43,199 --> 00:13:45,120
operators and each operator has

345
00:13:45,120 --> 00:13:47,040
predefined semantics

346
00:13:47,040 --> 00:13:49,199
it would be much easier to analyze this

347
00:13:49,199 --> 00:13:52,000
manifest using some simple algorithms

348
00:13:52,000 --> 00:13:54,000
for example i developed a futuristic

349
00:13:54,000 --> 00:13:57,199
based method to turn any manifest into a

350
00:13:57,199 --> 00:13:59,360
privacy nutrition label

351
00:13:59,360 --> 00:14:01,519
but today all these privacy nutrition

352
00:14:01,519 --> 00:14:03,120
labels they have to be they are

353
00:14:03,120 --> 00:14:05,680
self-reported by developers there is no

354
00:14:05,680 --> 00:14:07,839
way to enforce their behavior

355
00:14:07,839 --> 00:14:10,320
but in trust the peak of protocol allows

356
00:14:10,320 --> 00:14:12,240
us to generate all these privacy

357
00:14:12,240 --> 00:14:14,399
nutrition labels automatically and they

358
00:14:14,399 --> 00:14:18,560
always reflect the actual data practice

359
00:14:18,560 --> 00:14:20,399
further we can even make this privacy

360
00:14:20,399 --> 00:14:23,360
nutrition label dynamic and interactive

361
00:14:23,360 --> 00:14:25,440
by editing some of the fields

362
00:14:25,440 --> 00:14:27,519
for example one feature i built can

363
00:14:27,519 --> 00:14:31,360
modify the property of the the inject

364
00:14:31,360 --> 00:14:34,000
operator and insert a noisified operator

365
00:14:34,000 --> 00:14:36,240
between the aggregate and the post

366
00:14:36,240 --> 00:14:38,720
duration so by doing so the app will

367
00:14:38,720 --> 00:14:40,079
only send

368
00:14:40,079 --> 00:14:42,320
like monthly aggregated data rather than

369
00:14:42,320 --> 00:14:44,560
weekly aggregated data and now

370
00:14:44,560 --> 00:14:46,320
developers can get these privacy

371
00:14:46,320 --> 00:14:48,240
features for free because we only need

372
00:14:48,240 --> 00:14:50,240
to build this feature once

373
00:14:50,240 --> 00:14:52,560
and users can manage their privacy in a

374
00:14:52,560 --> 00:14:56,719
centralized and unified manner

375
00:14:57,680 --> 00:14:58,480
so

376
00:14:58,480 --> 00:15:00,320
this is a little bit intimidating data

377
00:15:00,320 --> 00:15:02,320
because we have no animation now

378
00:15:02,320 --> 00:15:05,120
so once adopted this design pattern can

379
00:15:05,120 --> 00:15:07,199
potentially create a new type of privacy

380
00:15:07,199 --> 00:15:08,560
ecosystem

381
00:15:08,560 --> 00:15:11,600
regulators like ftc gdpr they can easily

382
00:15:11,600 --> 00:15:13,360
find out

383
00:15:13,360 --> 00:15:15,360
financial better privacy practices since

384
00:15:15,360 --> 00:15:16,639
the data collection behavior is

385
00:15:16,639 --> 00:15:19,360
transparent and easy to analyze

386
00:15:19,360 --> 00:15:21,360
and privacy editable case can rank as

387
00:15:21,360 --> 00:15:23,519
the app developers to tell you tell

388
00:15:23,519 --> 00:15:26,000
users who is the good developer

389
00:15:26,000 --> 00:15:27,680
and all these small developers they will

390
00:15:27,680 --> 00:15:29,519
be able to get independent privacy

391
00:15:29,519 --> 00:15:31,600
features for free

392
00:15:31,600 --> 00:15:32,800
and finally

393
00:15:32,800 --> 00:15:36,079
users can trust this device because

394
00:15:36,079 --> 00:15:38,079
this architecture will enforce the data

395
00:15:38,079 --> 00:15:39,600
collection behavior

396
00:15:39,600 --> 00:15:41,759
and finally for users they will have

397
00:15:41,759 --> 00:15:44,399
like centralized and unified data

398
00:15:44,399 --> 00:15:46,639
privacy management and they can also

399
00:15:46,639 --> 00:15:48,800
enforce their control to all these iot

400
00:15:48,800 --> 00:15:51,279
devices

401
00:15:51,759 --> 00:15:52,800
so

402
00:15:52,800 --> 00:15:54,720
now i want to conclude my talk the whole

403
00:15:54,720 --> 00:15:57,759
takeaway of my talk is one idea

404
00:15:57,759 --> 00:16:00,480
so traditionally we developed this api

405
00:16:00,480 --> 00:16:03,279
using the permission or a uil and allow

406
00:16:03,279 --> 00:16:06,399
developers to query the data through it

407
00:16:06,399 --> 00:16:08,880
and peekaboo advocates a new design

408
00:16:08,880 --> 00:16:11,440
that is the system developers such as

409
00:16:11,440 --> 00:16:13,199
appstore they can offer a set of

410
00:16:13,199 --> 00:16:16,240
operators to design the api

411
00:16:16,240 --> 00:16:17,839
and app developers can change these

412
00:16:17,839 --> 00:16:19,920
operators into a graph

413
00:16:19,920 --> 00:16:22,800
before they access the data by doing so

414
00:16:22,800 --> 00:16:24,720
platform builders they can offer

415
00:16:24,720 --> 00:16:26,720
fine-grained data access with less

416
00:16:26,720 --> 00:16:27,680
efforts

417
00:16:27,680 --> 00:16:29,839
and app developers can learn the api

418
00:16:29,839 --> 00:16:32,880
quickly and it's much easier to analyze

419
00:16:32,880 --> 00:16:36,839
all this data collection behavior

420
00:16:37,759 --> 00:16:39,759
so to some extent peekaboo is a new type

421
00:16:39,759 --> 00:16:42,079
of domain specific language architecture

422
00:16:42,079 --> 00:16:44,560
whereas a manifest is a program and as

423
00:16:44,560 --> 00:16:47,120
operators zip became the language and at

424
00:16:47,120 --> 00:16:49,920
the runtime is a compiler that simply

425
00:16:49,920 --> 00:16:52,560
assembles this pack pre loaded

426
00:16:52,560 --> 00:16:54,959
implementation like unix pipes

427
00:16:54,959 --> 00:16:56,639
and there are two important implications

428
00:16:56,639 --> 00:16:59,279
of peekaboo which is the computation

429
00:16:59,279 --> 00:17:01,839
there needs to be repetitive and we can

430
00:17:01,839 --> 00:17:05,199
absolutely abstract them into a fixed

431
00:17:05,199 --> 00:17:07,280
set of operators

432
00:17:07,280 --> 00:17:09,280
and only have a few preloaded

433
00:17:09,280 --> 00:17:10,640
implementations

434
00:17:10,640 --> 00:17:12,319
and we also need to build a trusted

435
00:17:12,319 --> 00:17:14,559
runtime

436
00:17:14,559 --> 00:17:16,720
so one example

437
00:17:16,720 --> 00:17:17,679
is

438
00:17:17,679 --> 00:17:19,359
the zoom example

439
00:17:19,359 --> 00:17:21,280
so today like zoom actually can access

440
00:17:21,280 --> 00:17:23,439
all your google calendar information

441
00:17:23,439 --> 00:17:25,439
but also what does they need is only the

442
00:17:25,439 --> 00:17:28,559
calendar events that contain a zoom link

443
00:17:28,559 --> 00:17:30,559
and how can we fix that

444
00:17:30,559 --> 00:17:32,720
so in the future google should offer the

445
00:17:32,720 --> 00:17:34,320
api

446
00:17:34,320 --> 00:17:36,160
with a set of operators

447
00:17:36,160 --> 00:17:38,720
and zoom should alter their data access

448
00:17:38,720 --> 00:17:41,440
in a manifest and upload the manifest to

449
00:17:41,440 --> 00:17:43,600
google to get access there

450
00:17:43,600 --> 00:17:45,600
by doing so

451
00:17:45,600 --> 00:17:47,600
zoom will only be able to access the

452
00:17:47,600 --> 00:17:51,120
events that contain assumed link

453
00:17:51,120 --> 00:17:53,760
so with that i want to conclude the talk

454
00:17:53,760 --> 00:17:54,640
and

455
00:17:54,640 --> 00:17:56,910
i will any questions

456
00:17:56,910 --> 00:18:02,880
[Applause]

457
00:18:02,880 --> 00:18:05,360
uh thank you uh great talk

458
00:18:05,360 --> 00:18:08,080
uh i was wondering how would you go

459
00:18:08,080 --> 00:18:10,240
about backward compatibility for example

460
00:18:10,240 --> 00:18:11,679
a lot of apps that have already been

461
00:18:11,679 --> 00:18:13,760
built would you expect developers to

462
00:18:13,760 --> 00:18:16,559
update their apps to support peekaboo

463
00:18:16,559 --> 00:18:19,280
um yes that's um i would say currently

464
00:18:19,280 --> 00:18:20,960
we do not think too much about back

465
00:18:20,960 --> 00:18:23,280
compatibility at this moment and that's

466
00:18:23,280 --> 00:18:25,200
why we are working with smart home first

467
00:18:25,200 --> 00:18:26,960
because we do not have a smart home app

468
00:18:26,960 --> 00:18:29,440
store yet so it's a good opportunity for

469
00:18:29,440 --> 00:18:30,799
us to do this

470
00:18:30,799 --> 00:18:34,000
but in the future i will see see

471
00:18:34,000 --> 00:18:36,240
android also wants to adopt this

472
00:18:36,240 --> 00:18:38,160
and z can extend the information

473
00:18:38,160 --> 00:18:40,640
manifest like step by step rather than

474
00:18:40,640 --> 00:18:42,799
to have all the things that manifested

475
00:18:42,799 --> 00:18:44,720
at one time they can replace some of the

476
00:18:44,720 --> 00:18:46,640
permission with the graph like a

477
00:18:46,640 --> 00:18:48,000
representation

478
00:18:48,000 --> 00:18:50,080
and to kind of mitigate mitigate the

479
00:18:50,080 --> 00:18:52,559
back probability issue

480
00:18:52,559 --> 00:18:56,160
thank you no problem

481
00:18:56,160 --> 00:18:59,039
nathan dunham rice um great talk really

482
00:18:59,039 --> 00:19:03,840
exciting so my main interest concern is

483
00:19:03,840 --> 00:19:05,840
how you deal with unexpected events

484
00:19:05,840 --> 00:19:07,600
right so it's nice to think a white list

485
00:19:07,600 --> 00:19:10,000
is great you know you get this cross

486
00:19:10,000 --> 00:19:11,840
product uh you know the complexity here

487
00:19:11,840 --> 00:19:13,360
is going to be like somewhere in cubed

488
00:19:13,360 --> 00:19:15,360
or something right yes and so i'm

489
00:19:15,360 --> 00:19:17,600
wondering what you think uh is going to

490
00:19:17,600 --> 00:19:18,720
happen when you get a lot of

491
00:19:18,720 --> 00:19:20,240
interactions when you don't anticipate

492
00:19:20,240 --> 00:19:23,120
what's going on yes so they do exist

493
00:19:23,120 --> 00:19:24,960
like see someone really want to invent

494
00:19:24,960 --> 00:19:27,440
some innovative way to build this

495
00:19:27,440 --> 00:19:28,640
application

496
00:19:28,640 --> 00:19:31,120
and for this type of application so we

497
00:19:31,120 --> 00:19:33,600
will see like have this like the kind of

498
00:19:33,600 --> 00:19:35,840
backdoor approach and people just get

499
00:19:35,840 --> 00:19:37,919
the data and send forward the data to

500
00:19:37,919 --> 00:19:39,440
the cloud

501
00:19:39,440 --> 00:19:41,440
so by doing so there is no operator

502
00:19:41,440 --> 00:19:43,120
involved in this case

503
00:19:43,120 --> 00:19:44,960
but the whole idea is like when we make

504
00:19:44,960 --> 00:19:46,400
all this data collection behavior

505
00:19:46,400 --> 00:19:47,679
transparent

506
00:19:47,679 --> 00:19:50,240
so we can encourage people more to use

507
00:19:50,240 --> 00:19:52,160
this more fine-grained access rather

508
00:19:52,160 --> 00:19:54,640
than using this all nothing api

509
00:19:54,640 --> 00:19:56,160
okay did i answer my question so i think

510
00:19:56,160 --> 00:19:58,720
what you're saying is you have

511
00:19:58,720 --> 00:19:59,520
a

512
00:19:59,520 --> 00:20:02,799
distributed tracing and monitoring layer

513
00:20:02,799 --> 00:20:05,280
that represents every object

514
00:20:05,280 --> 00:20:07,440
and then every different type of device

515
00:20:07,440 --> 00:20:09,679
and then you would trace everything yes

516
00:20:09,679 --> 00:20:11,039
and then that would go to some system

517
00:20:11,039 --> 00:20:12,480
that can then consolidate and say oh

518
00:20:12,480 --> 00:20:13,840
we've seen this many things and now that

519
00:20:13,840 --> 00:20:16,559
we can use that to make our policies yes

520
00:20:16,559 --> 00:20:18,799
and but as a policy is for us it's more

521
00:20:18,799 --> 00:20:21,360
likely for people to specify these

522
00:20:21,360 --> 00:20:24,400
policies in operators

523
00:20:24,400 --> 00:20:27,679
okay awesome thank you so much

524
00:20:28,720 --> 00:20:30,559
hello you want to try from uw medicine

525
00:20:30,559 --> 00:20:32,799
uh very interesting talk so i have one

526
00:20:32,799 --> 00:20:34,799
question so like how do you derive the

527
00:20:34,799 --> 00:20:36,640
set of operators

528
00:20:36,640 --> 00:20:37,360
like

529
00:20:37,360 --> 00:20:38,640
what kind of

530
00:20:38,640 --> 00:20:40,799
criteria did you choose to select the

531
00:20:40,799 --> 00:20:44,080
operators i see so you mean what type so

532
00:20:44,080 --> 00:20:46,159
i would say i guess operators are

533
00:20:46,159 --> 00:20:47,600
basically the semantics you are talking

534
00:20:47,600 --> 00:20:49,520
about the pre-loaded implementations on

535
00:20:49,520 --> 00:20:50,640
the hub

536
00:20:50,640 --> 00:20:52,559
is my understanding oh yeah yeah yeah

537
00:20:52,559 --> 00:20:55,760
yeah that's a very nice question so

538
00:20:55,760 --> 00:20:57,600
there are a few criterias to select this

539
00:20:57,600 --> 00:20:59,760
like implant but first is it's not

540
00:20:59,760 --> 00:21:01,600
really a static scene people can

541
00:21:01,600 --> 00:21:03,360
dynamically add a new

542
00:21:03,360 --> 00:21:05,120
kind of like a preloaded implementation

543
00:21:05,120 --> 00:21:07,840
just like android like os version

544
00:21:07,840 --> 00:21:10,320
but for the implementation to be placed

545
00:21:10,320 --> 00:21:12,320
on the hub there are a few criterias one

546
00:21:12,320 --> 00:21:13,039
is

547
00:21:13,039 --> 00:21:15,520
it needs to be non-proprietary

548
00:21:15,520 --> 00:21:17,360
so for example tabular aggregation is

549
00:21:17,360 --> 00:21:19,760
just a few lines of code and the second

550
00:21:19,760 --> 00:21:21,919
is it should be common enough and which

551
00:21:21,919 --> 00:21:23,760
is commonly used by different

552
00:21:23,760 --> 00:21:25,039
applications

553
00:21:25,039 --> 00:21:26,799
and the third one is it also needs to be

554
00:21:26,799 --> 00:21:29,600
lightweight because the hub itself is

555
00:21:29,600 --> 00:21:32,559
local they will not have like large

556
00:21:32,559 --> 00:21:34,080
computing powers

557
00:21:34,080 --> 00:21:36,080
and so we have some lightweight

558
00:21:36,080 --> 00:21:38,159
computing on the hub this will be able

559
00:21:38,159 --> 00:21:40,400
to handle all these pre-processing and

560
00:21:40,400 --> 00:21:43,039
in our people we actually enumerated

561
00:21:43,039 --> 00:21:44,960
a table like of all these like

562
00:21:44,960 --> 00:21:47,120
pre-processing opportunities we we

563
00:21:47,120 --> 00:21:48,080
explore

564
00:21:48,080 --> 00:21:53,080
in the in the system thank you very much

