1
00:00:01,839 --> 00:00:04,000
yeah thank you for the kind introduction

2
00:00:04,000 --> 00:00:06,960
um again i will present our work about

3
00:00:06,960 --> 00:00:09,040
finding and exploiting cpu features

4
00:00:09,040 --> 00:00:11,200
using msr templating

5
00:00:11,200 --> 00:00:13,599
so today i'm going to show you first of

6
00:00:13,599 --> 00:00:15,839
all a bit of motivation why this would

7
00:00:15,839 --> 00:00:17,760
make sense and why we need it in general

8
00:00:17,760 --> 00:00:19,520
and overall in this paper we built a

9
00:00:19,520 --> 00:00:23,119
framework to even also classify msrs and

10
00:00:23,119 --> 00:00:25,599
find the effects on instructions and

11
00:00:25,599 --> 00:00:27,279
finally i will convince you with a few

12
00:00:27,279 --> 00:00:28,960
case studies why this framework is

13
00:00:28,960 --> 00:00:31,039
actually usable and why the findings

14
00:00:31,039 --> 00:00:34,239
have security implement implications on

15
00:00:34,239 --> 00:00:35,680
modern systems

16
00:00:35,680 --> 00:00:37,040
so let's start off with a bit of

17
00:00:37,040 --> 00:00:38,879
motivation so what are actually these

18
00:00:38,879 --> 00:00:40,960
model specific registers so you can

19
00:00:40,960 --> 00:00:43,120
think of a model specific register as an

20
00:00:43,120 --> 00:00:45,200
interface to the actual cpus

21
00:00:45,200 --> 00:00:47,600
implementation so like an api

22
00:00:47,600 --> 00:00:49,920
and usually these registers are 64 bit

23
00:00:49,920 --> 00:00:53,039
wide and they live at exist in a 32-bit

24
00:00:53,039 --> 00:00:54,960
address space so you can imagine that

25
00:00:54,960 --> 00:00:57,280
there are quite a lot of configuration

26
00:00:57,280 --> 00:00:59,680
options on a modern cpu

27
00:00:59,680 --> 00:01:02,000
furthermore usually the documented in

28
00:01:02,000 --> 00:01:04,559
these manuals we know the intel's volume

29
00:01:04,559 --> 00:01:06,560
4 manual which basically has these huge

30
00:01:06,560 --> 00:01:09,360
tables in there documenting the bits of

31
00:01:09,360 --> 00:01:11,840
the actual msrs however due to the shear

32
00:01:11,840 --> 00:01:14,159
size and some different constraints some

33
00:01:14,159 --> 00:01:16,560
of these msrs are usually not documented

34
00:01:16,560 --> 00:01:18,799
or only documentation is only available

35
00:01:18,799 --> 00:01:20,799
to specific vendors

36
00:01:20,799 --> 00:01:21,600
so

37
00:01:21,600 --> 00:01:23,920
the general motivation of this paper was

38
00:01:23,920 --> 00:01:26,799
to find msr bits and detect their

39
00:01:26,799 --> 00:01:28,720
influences on the microarray actual

40
00:01:28,720 --> 00:01:31,280
behavior of certain instructions

41
00:01:31,280 --> 00:01:33,920
furthermore as we've seen due to recent

42
00:01:33,920 --> 00:01:36,240
microarchitectural attacks or spectra

43
00:01:36,240 --> 00:01:38,000
meltdown and algae's mds sampling

44
00:01:38,000 --> 00:01:41,119
variants we have seen that micro

45
00:01:41,119 --> 00:01:44,320
batches often add additional msrs which

46
00:01:44,320 --> 00:01:46,640
expose some configuration options to the

47
00:01:46,640 --> 00:01:48,560
operating system in order to give the

48
00:01:48,560 --> 00:01:50,960
operating system some way of configuring

49
00:01:50,960 --> 00:01:53,520
the actual mitigation

50
00:01:53,520 --> 00:01:55,840
and finally as we've seen in the past

51
00:01:55,840 --> 00:01:58,159
there was previous work from thomas

52
00:01:58,159 --> 00:01:59,360
thomas at

53
00:01:59,360 --> 00:02:01,040
domes on its own

54
00:02:01,040 --> 00:02:03,600
and basically found that there was an

55
00:02:03,600 --> 00:02:05,360
msr which enabled a completely new

56
00:02:05,360 --> 00:02:07,840
instruction set on the certain cpu so

57
00:02:07,840 --> 00:02:09,520
that's basically the motivation why we

58
00:02:09,520 --> 00:02:11,599
wanted to look deeper into this huge

59
00:02:11,599 --> 00:02:14,160
address space of the samsungs

60
00:02:14,160 --> 00:02:15,200
so

61
00:02:15,200 --> 00:02:16,959
um

62
00:02:16,959 --> 00:02:19,040
so in the paper we built this framework

63
00:02:19,040 --> 00:02:21,520
so the framework is split into two main

64
00:02:21,520 --> 00:02:23,280
parts we have on the left side we have

65
00:02:23,280 --> 00:02:25,360
this detection mechanism and on the

66
00:02:25,360 --> 00:02:26,879
right side we have this classification

67
00:02:26,879 --> 00:02:28,959
part the main part of the framework

68
00:02:28,959 --> 00:02:31,599
itself is the msr scanning part

69
00:02:31,599 --> 00:02:34,000
we use basically these two instructions

70
00:02:34,000 --> 00:02:37,519
which are on each cpu to access these

71
00:02:37,519 --> 00:02:39,760
msrs so we have to read msr instruction

72
00:02:39,760 --> 00:02:42,000
to read an msr and we have to write them

73
00:02:42,000 --> 00:02:44,160
as our instruction to write a specific

74
00:02:44,160 --> 00:02:47,040
msr on that address if we now combine

75
00:02:47,040 --> 00:02:48,800
these two

76
00:02:48,800 --> 00:02:51,599
instructions and the property that if

77
00:02:51,599 --> 00:02:53,040
this operation is not permitted on a

78
00:02:53,040 --> 00:02:55,599
given msr we can basically scan the

79
00:02:55,599 --> 00:02:57,599
complete 32-bit address base and

80
00:02:57,599 --> 00:02:59,920
furthermore also detect which of these

81
00:02:59,920 --> 00:03:02,239
msrs are rewritable or read and

82
00:03:02,239 --> 00:03:05,680
writeable or simply not present

83
00:03:05,680 --> 00:03:06,560
so

84
00:03:06,560 --> 00:03:08,400
after the step we have a complete list

85
00:03:08,400 --> 00:03:10,640
of all the msrs available

86
00:03:10,640 --> 00:03:12,400
and then we wanted to focus a bit more

87
00:03:12,400 --> 00:03:14,480
on this documented and undocumented

88
00:03:14,480 --> 00:03:17,200
aspect so what we did there is we built

89
00:03:17,200 --> 00:03:18,400
an

90
00:03:18,400 --> 00:03:20,800
official document browser so we use the

91
00:03:20,800 --> 00:03:22,400
official documentation available to the

92
00:03:22,400 --> 00:03:24,959
public domain and build a byten script

93
00:03:24,959 --> 00:03:26,959
that can basically extract these data

94
00:03:26,959 --> 00:03:29,120
structures we see in these pdfs and

95
00:03:29,120 --> 00:03:30,959
after this step we have further

96
00:03:30,959 --> 00:03:33,280
granulised the list of msrs and split

97
00:03:33,280 --> 00:03:35,120
them into documented msrs and

98
00:03:35,120 --> 00:03:37,280
undocumented msrs

99
00:03:37,280 --> 00:03:38,959
we then focused a lot more on these

100
00:03:38,959 --> 00:03:41,760
undocumented msrs and more precisely on

101
00:03:41,760 --> 00:03:44,640
so-called we named them dynamic msrs so

102
00:03:44,640 --> 00:03:47,760
dynamic msrs you can think of as an msr

103
00:03:47,760 --> 00:03:50,480
which exposes a sensor value think of a

104
00:03:50,480 --> 00:03:51,920
thermal reading

105
00:03:51,920 --> 00:03:53,760
energy reading or something like that so

106
00:03:53,760 --> 00:03:56,000
basically a time continuous signal which

107
00:03:56,000 --> 00:03:57,439
is changing

108
00:03:57,439 --> 00:03:59,040
and since we know how to deal with

109
00:03:59,040 --> 00:04:00,879
time-continuous signals we can use

110
00:04:00,879 --> 00:04:02,400
signal processing like a correlation

111
00:04:02,400 --> 00:04:05,920
analysis to find documented msrs which

112
00:04:05,920 --> 00:04:08,640
correlate with these signals and that

113
00:04:08,640 --> 00:04:11,519
will basically give us an estimate or a

114
00:04:11,519 --> 00:04:13,519
hint to what the actual signal is

115
00:04:13,519 --> 00:04:14,640
exposing

116
00:04:14,640 --> 00:04:16,720
for example we can see that we found an

117
00:04:16,720 --> 00:04:19,759
msr which is highly correlating to

118
00:04:19,759 --> 00:04:22,720
monotonic counters so our guess is that

119
00:04:22,720 --> 00:04:25,600
this msr is also exposing a monotonic

120
00:04:25,600 --> 00:04:27,280
counter

121
00:04:27,280 --> 00:04:29,280
so after this step of the framework we

122
00:04:29,280 --> 00:04:31,759
have now a complete list for each

123
00:04:31,759 --> 00:04:34,160
undocumented dynamic msrs which some

124
00:04:34,160 --> 00:04:36,000
candidates which are highly correlating

125
00:04:36,000 --> 00:04:38,479
to are some source hints of the actual

126
00:04:38,479 --> 00:04:40,639
signal

127
00:04:40,639 --> 00:04:42,479
in the next phase of the framework we

128
00:04:42,479 --> 00:04:44,320
then focused on the second group which

129
00:04:44,320 --> 00:04:47,759
is remaining these are the static um

130
00:04:47,759 --> 00:04:50,560
the static msrs so static msrs are

131
00:04:50,560 --> 00:04:52,080
basically the opposite they are

132
00:04:52,080 --> 00:04:54,000
unchanging and there the assumption we

133
00:04:54,000 --> 00:04:56,960
had was that static msrs expose

134
00:04:56,960 --> 00:04:58,639
configuration bits so since

135
00:04:58,639 --> 00:05:01,360
configuration bits are not fluctuating

136
00:05:01,360 --> 00:05:03,440
or not changing that often in a normal

137
00:05:03,440 --> 00:05:04,960
cpu

138
00:05:04,960 --> 00:05:07,759
these are usually static

139
00:05:07,759 --> 00:05:09,840
okay so and now as i mentioned in the

140
00:05:09,840 --> 00:05:12,080
beginning the goal was to find the

141
00:05:12,080 --> 00:05:14,479
influences of these certain bits to a

142
00:05:14,479 --> 00:05:17,199
given instruction so how can we do this

143
00:05:17,199 --> 00:05:19,680
we basically execute the given

144
00:05:19,680 --> 00:05:22,080
instruction once without changing the

145
00:05:22,080 --> 00:05:24,720
bit in an msr and then we execute the

146
00:05:24,720 --> 00:05:26,960
instruction again with the flip bit and

147
00:05:26,960 --> 00:05:28,080
the msr

148
00:05:28,080 --> 00:05:30,000
and there we use a cool feature of

149
00:05:30,000 --> 00:05:31,919
modern cpus the so-called performance

150
00:05:31,919 --> 00:05:34,000
monitoring counters so these performance

151
00:05:34,000 --> 00:05:35,520
monitoring counters are basically an

152
00:05:35,520 --> 00:05:37,360
interface to the microarchitectural

153
00:05:37,360 --> 00:05:39,759
world of the cpu you can configure them

154
00:05:39,759 --> 00:05:41,680
and you can record certain events on the

155
00:05:41,680 --> 00:05:44,080
cpu and then we simply make a difference

156
00:05:44,080 --> 00:05:46,400
between these two executions and see if

157
00:05:46,400 --> 00:05:48,560
we have a significant difference in the

158
00:05:48,560 --> 00:05:50,479
performance counter readings when

159
00:05:50,479 --> 00:05:52,400
flipping that specific bit or more

160
00:05:52,400 --> 00:05:54,320
precisely more often more than one

161
00:05:54,320 --> 00:05:55,840
specific bit

162
00:05:55,840 --> 00:05:57,680
if we don't analyze this bmc difference

163
00:05:57,680 --> 00:05:59,280
we can simply report

164
00:05:59,280 --> 00:06:01,360
this bit as influencing a certain

165
00:06:01,360 --> 00:06:03,520
instruction and we can find these

166
00:06:03,520 --> 00:06:05,600
instructions

167
00:06:05,600 --> 00:06:07,440
and for the final step of the framework

168
00:06:07,440 --> 00:06:09,360
we then wanted to focus a bit more on

169
00:06:09,360 --> 00:06:12,000
the search base itself and if you you

170
00:06:12,000 --> 00:06:14,800
you might know the bios is one of the

171
00:06:14,800 --> 00:06:16,000
places where you have the most

172
00:06:16,000 --> 00:06:18,960
configuration options for your cpu so

173
00:06:18,960 --> 00:06:20,880
here we had the idea that we wanted to

174
00:06:20,880 --> 00:06:22,240
extend the search space for the

175
00:06:22,240 --> 00:06:24,880
framework by simply changing a bios

176
00:06:24,880 --> 00:06:27,120
feature feature in bios

177
00:06:27,120 --> 00:06:30,400
which usually has more documentation

178
00:06:30,400 --> 00:06:33,039
as you think of biases which have which

179
00:06:33,039 --> 00:06:34,880
are feature-rich bios's they usually

180
00:06:34,880 --> 00:06:37,680
have more options for a certain cpu then

181
00:06:37,680 --> 00:06:39,919
they're actually maybe documented in a

182
00:06:39,919 --> 00:06:42,800
manual so the idea was to flip a bios

183
00:06:42,800 --> 00:06:45,520
feature and then trace the difference to

184
00:06:45,520 --> 00:06:47,759
specific msrs and basically get an

185
00:06:47,759 --> 00:06:50,800
insight to what this bios feature

186
00:06:50,800 --> 00:06:52,560
actually uses in the background which

187
00:06:52,560 --> 00:06:54,639
msr's affected and furthermore we can

188
00:06:54,639 --> 00:06:56,000
also combine it with the remaining

189
00:06:56,000 --> 00:06:57,759
framework to actually see if it affects

190
00:06:57,759 --> 00:06:59,599
some instructions

191
00:06:59,599 --> 00:07:01,599
so to just summarize the framework which

192
00:07:01,599 --> 00:07:04,000
the framework is capable of we can first

193
00:07:04,000 --> 00:07:05,840
search the complete address space and

194
00:07:05,840 --> 00:07:08,960
find each available msr we can find

195
00:07:08,960 --> 00:07:12,000
dynamic msrs and the source hints or

196
00:07:12,000 --> 00:07:14,400
correlating documented msrs to get an

197
00:07:14,400 --> 00:07:17,199
insight on what this signal is actually

198
00:07:17,199 --> 00:07:19,280
which um

199
00:07:19,280 --> 00:07:22,000
what this msi is actually exposing

200
00:07:22,000 --> 00:07:24,560
and finally for static msrs we can trace

201
00:07:24,560 --> 00:07:26,400
their configuration bits back to certain

202
00:07:26,400 --> 00:07:27,759
instructions

203
00:07:27,759 --> 00:07:30,319
and for buyers we can track which msrs

204
00:07:30,319 --> 00:07:32,639
are actually affected

205
00:07:32,639 --> 00:07:34,800
yeah so after we built this framework we

206
00:07:34,800 --> 00:07:36,800
wanted to motivate and

207
00:07:36,800 --> 00:07:39,280
show that you can actually find security

208
00:07:39,280 --> 00:07:41,039
vulnerability

209
00:07:41,039 --> 00:07:41,840
sorry

210
00:07:41,840 --> 00:07:44,319
which can actually find msrs which has

211
00:07:44,319 --> 00:07:47,039
an effect on system security we did that

212
00:07:47,039 --> 00:07:49,440
in six case studies and we have both um

213
00:07:49,440 --> 00:07:51,360
attack case studies and more defensive

214
00:07:51,360 --> 00:07:53,520
case studies and interestingly as we

215
00:07:53,520 --> 00:07:56,000
heard in the talk before the brief

216
00:07:56,000 --> 00:07:57,759
brief software prefetch instructions can

217
00:07:57,759 --> 00:08:00,400
actually be used for certain attacks

218
00:08:00,400 --> 00:08:02,160
here we focus more on amd systems so it

219
00:08:02,160 --> 00:08:03,599
doesn't directly correlate to the

220
00:08:03,599 --> 00:08:06,160
previous talk but you can also think of

221
00:08:06,160 --> 00:08:08,240
refresh-based attacks in some sense like

222
00:08:08,240 --> 00:08:10,720
um in in the regards of like a kernel

223
00:08:10,720 --> 00:08:12,720
address-based layout randomization break

224
00:08:12,720 --> 00:08:15,440
so on the left we see a virtual address

225
00:08:15,440 --> 00:08:17,520
based layout and the box is marking

226
00:08:17,520 --> 00:08:18,960
where the kernel resides in virtual

227
00:08:18,960 --> 00:08:20,720
address space if you now use the

228
00:08:20,720 --> 00:08:22,479
prefetch side channel we see a dynamic

229
00:08:22,479 --> 00:08:24,840
difference where the kernel is actually

230
00:08:24,840 --> 00:08:27,599
located and we see a clear signal at the

231
00:08:27,599 --> 00:08:29,599
position 88

232
00:08:29,599 --> 00:08:31,840
so we can now use the framework to

233
00:08:31,840 --> 00:08:34,080
search for configuration bits which

234
00:08:34,080 --> 00:08:36,159
influence the prefetch instruction

235
00:08:36,159 --> 00:08:38,559
and on amd systems we found actually an

236
00:08:38,559 --> 00:08:40,399
msr which basically

237
00:08:40,399 --> 00:08:42,559
changed the load dispatch counter by

238
00:08:42,559 --> 00:08:44,080
exactly one

239
00:08:44,080 --> 00:08:46,320
interestingly a prefetch should usually

240
00:08:46,320 --> 00:08:48,880
perform exactly one load so we argued

241
00:08:48,880 --> 00:08:51,279
that these bits basically disable the

242
00:08:51,279 --> 00:08:52,800
prefetch instructions

243
00:08:52,800 --> 00:08:54,800
we can then test the brief the case lab

244
00:08:54,800 --> 00:08:57,040
break from before and we can see with

245
00:08:57,040 --> 00:08:59,120
disabled prefetch instructions we no

246
00:08:59,120 --> 00:09:01,440
longer see a signal at the specific

247
00:09:01,440 --> 00:09:04,080
offset so basically we have mitigated

248
00:09:04,080 --> 00:09:06,080
prefetch software software based

249
00:09:06,080 --> 00:09:08,240
prefetch case casella breaks on amd

250
00:09:08,240 --> 00:09:09,440
systems

251
00:09:09,440 --> 00:09:12,480
overall only one percent of um binaries

252
00:09:12,480 --> 00:09:14,880
on a debian installation use actual

253
00:09:14,880 --> 00:09:16,720
prefix instructions this is also

254
00:09:16,720 --> 00:09:19,040
reflected in the spec benchmark so there

255
00:09:19,040 --> 00:09:21,200
is no real overhead however keep in mind

256
00:09:21,200 --> 00:09:22,959
that there might be some

257
00:09:22,959 --> 00:09:24,560
applications which highly rely on

258
00:09:24,560 --> 00:09:26,080
prefetch instructions which are not

259
00:09:26,080 --> 00:09:29,040
reflected in that case study

260
00:09:29,040 --> 00:09:31,279
for the next case study we focused a lot

261
00:09:31,279 --> 00:09:34,320
on this asi instruction set so the as9

262
00:09:34,320 --> 00:09:36,080
instruction set is basically the

263
00:09:36,080 --> 00:09:38,240
hardware implementation a side channel

264
00:09:38,240 --> 00:09:40,800
resistant implementation of aes on

265
00:09:40,800 --> 00:09:42,560
modern hardware

266
00:09:42,560 --> 00:09:44,480
more specifically we focused on a lock

267
00:09:44,480 --> 00:09:47,360
bit a lock bit is a bit which usually

268
00:09:47,360 --> 00:09:49,200
gets set after the configuration is

269
00:09:49,200 --> 00:09:51,440
finished by the bios and then it

270
00:09:51,440 --> 00:09:53,440
prevents further modification of a

271
00:09:53,440 --> 00:09:55,040
specific feature

272
00:09:55,040 --> 00:09:56,720
however if we now move to a more

273
00:09:56,720 --> 00:09:58,640
advanced thread model let's say the hdx

274
00:09:58,640 --> 00:10:01,519
thread model we can basically flash

275
00:10:01,519 --> 00:10:03,040
flush

276
00:10:03,040 --> 00:10:07,599
flash sorry we flush the flash just

277
00:10:07,760 --> 00:10:10,399
too much prefetch in the stock sorry so

278
00:10:10,399 --> 00:10:12,720
we flush the bios and basically remove

279
00:10:12,720 --> 00:10:14,880
this protection and then we gain a

280
00:10:14,880 --> 00:10:18,399
primitive we gain the ability to disable

281
00:10:18,399 --> 00:10:21,360
as9 the as9 instruction set during the

282
00:10:21,360 --> 00:10:24,160
sjx execution exactly once

283
00:10:24,160 --> 00:10:25,600
and now you might think what can i do

284
00:10:25,600 --> 00:10:27,360
with that but if you now take a look at

285
00:10:27,360 --> 00:10:29,760
the mtls library which basically has a

286
00:10:29,760 --> 00:10:32,880
side channel resistant mutation of asn i

287
00:10:32,880 --> 00:10:34,480
which is usually often used in

288
00:10:34,480 --> 00:10:36,959
microcontrollers or low embedded systems

289
00:10:36,959 --> 00:10:39,040
and we bring it to sgx we can see

290
00:10:39,040 --> 00:10:41,200
exactly this pattern we're looking for

291
00:10:41,200 --> 00:10:43,600
first it tries to verify if aside is

292
00:10:43,600 --> 00:10:46,160
available and if it's unavailable and we

293
00:10:46,160 --> 00:10:48,320
basically use single stepping or some

294
00:10:48,320 --> 00:10:50,880
different um way to basically interrupt

295
00:10:50,880 --> 00:10:53,120
an enclave at this point we can then

296
00:10:53,120 --> 00:10:56,240
disable as9 at this check and force the

297
00:10:56,240 --> 00:10:58,480
cryptographic library to fall back to t

298
00:10:58,480 --> 00:11:00,800
table implementation and as you all

299
00:11:00,800 --> 00:11:03,200
might know detail implementations have

300
00:11:03,200 --> 00:11:05,120
an effect on cache and you can recover

301
00:11:05,120 --> 00:11:07,680
that so we simulated a last primary

302
00:11:07,680 --> 00:11:09,519
probe attack on the last level cache

303
00:11:09,519 --> 00:11:11,360
since we understand model and we can

304
00:11:11,360 --> 00:11:13,360
actually see the two different keys

305
00:11:13,360 --> 00:11:15,360
unexpectedly have two different cache

306
00:11:15,360 --> 00:11:17,360
access traces we then showed in the

307
00:11:17,360 --> 00:11:19,360
paper that we can build a sub solver and

308
00:11:19,360 --> 00:11:21,519
simply recover the full key based on

309
00:11:21,519 --> 00:11:24,079
this attack

310
00:11:24,720 --> 00:11:26,480
so for our next case study we focused a

311
00:11:26,480 --> 00:11:28,880
bit more on mitigation of existing

312
00:11:28,880 --> 00:11:31,040
attacks so there's this crosstalk attack

313
00:11:31,040 --> 00:11:32,959
i can't go into much detail what you

314
00:11:32,959 --> 00:11:34,959
have done so how it actually works but

315
00:11:34,959 --> 00:11:37,600
it just leaks random numbers generated

316
00:11:37,600 --> 00:11:38,959
on a cpu

317
00:11:38,959 --> 00:11:40,079
so

318
00:11:40,079 --> 00:11:41,600
for this talk we just focus on the

319
00:11:41,600 --> 00:11:43,920
unprivileged use case and since uh for

320
00:11:43,920 --> 00:11:45,440
the unprivileged use case and basically

321
00:11:45,440 --> 00:11:47,680
we evaluated the leakage capabilities of

322
00:11:47,680 --> 00:11:50,240
crosstalk attack and we can see that we

323
00:11:50,240 --> 00:11:52,399
need to either dispute the instruction

324
00:11:52,399 --> 00:11:55,360
or rdc instruction to leak this randomly

325
00:11:55,360 --> 00:11:57,279
generated data and we can see that the

326
00:11:57,279 --> 00:11:59,360
cpu at the instruction is way more

327
00:11:59,360 --> 00:12:01,600
effective in leaking the actual data so

328
00:12:01,600 --> 00:12:03,839
we can leak 88 percent of the generated

329
00:12:03,839 --> 00:12:06,000
random bytes with the cpu destruction

330
00:12:06,000 --> 00:12:07,839
but only 0.4

331
00:12:07,839 --> 00:12:10,880
percent of the bytes generated

332
00:12:10,880 --> 00:12:12,720
generated by eiran when leaking with

333
00:12:12,720 --> 00:12:14,000
receipt

334
00:12:14,000 --> 00:12:16,160
so we then use again our framework to

335
00:12:16,160 --> 00:12:18,399
basically search for configuration bits

336
00:12:18,399 --> 00:12:20,959
which influence the security instruction

337
00:12:20,959 --> 00:12:23,440
and interestingly we found one we found

338
00:12:23,440 --> 00:12:26,959
a cpu msr bit which basically converted

339
00:12:26,959 --> 00:12:28,959
the cpuid instruction to trap

340
00:12:28,959 --> 00:12:30,160
instruction

341
00:12:30,160 --> 00:12:31,680
this does mean that you can no longer

342
00:12:31,680 --> 00:12:34,480
execute cpuid um as you would

343
00:12:34,480 --> 00:12:36,959
usually but instead it or it always

344
00:12:36,959 --> 00:12:38,639
falls when you execute it

345
00:12:38,639 --> 00:12:41,279
we can then basically build a kernel um

346
00:12:41,279 --> 00:12:42,959
where we can build a kernel module to

347
00:12:42,959 --> 00:12:45,680
basically catch these faults and emulate

348
00:12:45,680 --> 00:12:48,000
the beauty on a system

349
00:12:48,000 --> 00:12:49,600
what have we achieved what can be

350
00:12:49,600 --> 00:12:51,200
achieved with that we can basically

351
00:12:51,200 --> 00:12:54,240
remove the cpuid primitive from this

352
00:12:54,240 --> 00:12:56,160
unprivileged attacker and harden the

353
00:12:56,160 --> 00:12:57,839
system against

354
00:12:57,839 --> 00:13:00,480
the crosstalk attack by around by factor

355
00:13:00,480 --> 00:13:02,959
200.

356
00:13:04,000 --> 00:13:05,680
for the for the next case study we then

357
00:13:05,680 --> 00:13:07,920
focused a lot on hypervisors

358
00:13:07,920 --> 00:13:09,600
due to the nature of the hypervisor they

359
00:13:09,600 --> 00:13:11,360
have to closely interact with the

360
00:13:11,360 --> 00:13:13,839
hardware and basically emulate a lot of

361
00:13:13,839 --> 00:13:15,760
features for the guest since the guest

362
00:13:15,760 --> 00:13:18,880
expects a classical hardware to run on

363
00:13:18,880 --> 00:13:21,279
more interestingly the xen hypervisor

364
00:13:21,279 --> 00:13:23,920
implemented the so-called deny list for

365
00:13:23,920 --> 00:13:26,399
msr accesses due to the nature of a

366
00:13:26,399 --> 00:13:29,279
denialist undocumented msrs are not

367
00:13:29,279 --> 00:13:31,279
present in the denialist and the xan

368
00:13:31,279 --> 00:13:34,240
hypervisor simply allowed read access to

369
00:13:34,240 --> 00:13:37,200
undocumented msrs so if you use rdmsr in

370
00:13:37,200 --> 00:13:39,440
the guest first the hypervisor checks if

371
00:13:39,440 --> 00:13:40,560
it's allowed

372
00:13:40,560 --> 00:13:43,440
and if if it's undocumented or unknown

373
00:13:43,440 --> 00:13:45,279
it simply forwards it to the hardware

374
00:13:45,279 --> 00:13:47,600
and basically returns the actual value

375
00:13:47,600 --> 00:13:48,639
of

376
00:13:48,639 --> 00:13:51,680
of the msr and if you remember closely

377
00:13:51,680 --> 00:13:53,519
this msr we're reading here is exactly

378
00:13:53,519 --> 00:13:56,000
the msr which was highly correlating to

379
00:13:56,000 --> 00:13:58,560
this timing msrs so basically we can

380
00:13:58,560 --> 00:14:02,399
enable a new timer in a in a guest

381
00:14:02,399 --> 00:14:05,360
even if the the hypervisor implements

382
00:14:05,360 --> 00:14:08,320
some sort of hardening against

383
00:14:08,320 --> 00:14:10,320
timing based attacks we can then use

384
00:14:10,320 --> 00:14:11,760
this timer to distinguish cast fields

385
00:14:11,760 --> 00:14:13,760
from transmissions again and basically

386
00:14:13,760 --> 00:14:15,680
re-enable the four-shield attack in such

387
00:14:15,680 --> 00:14:17,680
highly restricted environments and

388
00:14:17,680 --> 00:14:19,760
finally we can achieve a leakage rate of

389
00:14:19,760 --> 00:14:21,839
200 bytes per sec approximately 200

390
00:14:21,839 --> 00:14:23,279
bytes per second

391
00:14:23,279 --> 00:14:24,959
and one of the most interesting case

392
00:14:24,959 --> 00:14:27,199
studies was that we can similar to the

393
00:14:27,199 --> 00:14:29,120
instruction behavior analysis we can

394
00:14:29,120 --> 00:14:31,680
also use the framework to basically give

395
00:14:31,680 --> 00:14:34,320
microcode batches so for instance we

396
00:14:34,320 --> 00:14:36,480
install a microcode update we monitor

397
00:14:36,480 --> 00:14:39,040
all the msrs and then we update the

398
00:14:39,040 --> 00:14:41,839
microcode and see which msrs are newly

399
00:14:41,839 --> 00:14:44,800
added and also which msr which

400
00:14:44,800 --> 00:14:47,040
instructions were affected by dsms are

401
00:14:47,040 --> 00:14:47,920
bits

402
00:14:47,920 --> 00:14:50,240
why is this important because we have

403
00:14:50,240 --> 00:14:52,480
seen a few cases where these microcode

404
00:14:52,480 --> 00:14:54,079
updates are usually deployed months

405
00:14:54,079 --> 00:14:55,920
before the public disclosure meaning

406
00:14:55,920 --> 00:14:56,839
that an

407
00:14:56,839 --> 00:14:58,399
adversary

408
00:14:58,399 --> 00:15:00,959
can get an advantage or a long time span

409
00:15:00,959 --> 00:15:03,360
to reverse engineer the actual effect of

410
00:15:03,360 --> 00:15:05,199
the mitigation and that already brings

411
00:15:05,199 --> 00:15:07,279
me to the conclusion so this framework

412
00:15:07,279 --> 00:15:08,800
is available

413
00:15:08,800 --> 00:15:10,560
on this github link

414
00:15:10,560 --> 00:15:12,480
i've shown you a few case studies where

415
00:15:12,480 --> 00:15:13,920
we use this framework to show that

416
00:15:13,920 --> 00:15:16,480
they're actually msrs which can affect

417
00:15:16,480 --> 00:15:18,240
um security in a positive sense to build

418
00:15:18,240 --> 00:15:21,199
new defenses and also this msrs can open

419
00:15:21,199 --> 00:15:23,839
the attack vectors and for more details

420
00:15:23,839 --> 00:15:25,839
and main monitors on case studies please

421
00:15:25,839 --> 00:15:27,920
read the paper the qr code is actually

422
00:15:27,920 --> 00:15:30,320
working so thank you and i'm open for

423
00:15:30,320 --> 00:15:31,550
questions

424
00:15:31,550 --> 00:15:37,759
[Applause]

425
00:15:37,759 --> 00:15:39,680
thank you for the talk i'll start with a

426
00:15:39,680 --> 00:15:42,480
question from the uh online from another

427
00:15:42,480 --> 00:15:44,959
question yanyon cars asks

428
00:15:44,959 --> 00:15:47,519
couldn't an msr value change influence

429
00:15:47,519 --> 00:15:49,600
an instruction in a different way that

430
00:15:49,600 --> 00:15:51,680
is not visible in performance counters

431
00:15:51,680 --> 00:15:54,079
yes totally you can think of we focused

432
00:15:54,079 --> 00:15:56,240
on more on microarchitectural effects

433
00:15:56,240 --> 00:15:57,680
but you can also think of architectural

434
00:15:57,680 --> 00:15:59,199
effects like the rounding behavior of

435
00:15:59,199 --> 00:16:00,959
floating point instruction is actually i

436
00:16:00,959 --> 00:16:03,199
think configurable was some msrs and

437
00:16:03,199 --> 00:16:04,639
there you have an architectural change

438
00:16:04,639 --> 00:16:06,240
we won't detect in the micro hydration

439
00:16:06,240 --> 00:16:07,279
behavior

440
00:16:07,279 --> 00:16:09,600
so this is out it was a bit out of scope

441
00:16:09,600 --> 00:16:11,920
for for that frequently thanks

442
00:16:11,920 --> 00:16:14,560
hey uh great talk um

443
00:16:14,560 --> 00:16:16,959
interesting work i just have like uh two

444
00:16:16,959 --> 00:16:19,279
small questions is one is uh did you

445
00:16:19,279 --> 00:16:21,199
notice when you were um

446
00:16:21,199 --> 00:16:22,480
kind of playing with the msr

447
00:16:22,480 --> 00:16:24,800
configurations if they affected the

448
00:16:24,800 --> 00:16:27,839
behavior of the pmcs and

449
00:16:27,839 --> 00:16:30,480
how you then use that to monitor

450
00:16:30,480 --> 00:16:33,199
the effect on the instruction

451
00:16:33,199 --> 00:16:34,720
yet a best example is basically the

452
00:16:34,720 --> 00:16:37,040
brief instruction use case we basically

453
00:16:37,040 --> 00:16:38,800
flipped one bit and suddenly we saw a

454
00:16:38,800 --> 00:16:40,560
decrease in the load counter for the

455
00:16:40,560 --> 00:16:42,240
prefetch instructions

456
00:16:42,240 --> 00:16:44,560
oh okay okay okay so so basically you

457
00:16:44,560 --> 00:16:46,160
first flip the bit then you record and

458
00:16:46,160 --> 00:16:47,759
then you diff and suddenly you see a

459
00:16:47,759 --> 00:16:49,120
significant difference so you usually

460
00:16:49,120 --> 00:16:50,880
have a few fluctuations here which you

461
00:16:50,880 --> 00:16:52,240
can get rid of if you execute it

462
00:16:52,240 --> 00:16:54,079
multiple times i actually was referring

463
00:16:54,079 --> 00:16:56,320
to the behavior of the pmc itself so you

464
00:16:56,320 --> 00:16:58,399
use the ms to configure their behavior

465
00:16:58,399 --> 00:17:00,399
yeah yeah they actually notice that

466
00:17:00,399 --> 00:17:02,000
yes

467
00:17:02,000 --> 00:17:05,359
ms pmc actually configure it via msrs so

468
00:17:05,359 --> 00:17:06,400
you have to exclude them because

469
00:17:06,400 --> 00:17:08,160
otherwise you're fussing your own

470
00:17:08,160 --> 00:17:09,599
monitoring framework yeah and you didn't

471
00:17:09,599 --> 00:17:12,319
find any undocumented

472
00:17:12,319 --> 00:17:14,160
okay and the second one is um did you

473
00:17:14,160 --> 00:17:15,599
think or do you think there's any

474
00:17:15,599 --> 00:17:18,079
opportunity to evaluate how like the msr

475
00:17:18,079 --> 00:17:20,079
configuration registers might affect

476
00:17:20,079 --> 00:17:22,720
memory like the layout of memory with

477
00:17:22,720 --> 00:17:24,640
respect as opposed to just focusing on

478
00:17:24,640 --> 00:17:26,880
instructions you know so like in arms

479
00:17:26,880 --> 00:17:28,480
style processors there's configuration

480
00:17:28,480 --> 00:17:30,720
registers where we'll basically invert

481
00:17:30,720 --> 00:17:33,200
the order right of how memory is whether

482
00:17:33,200 --> 00:17:36,640
msb lsb i guess you could also i'm not

483
00:17:36,640 --> 00:17:38,480
sure if it's reflected as you said in

484
00:17:38,480 --> 00:17:40,640
the pmcs but if it is you would detect

485
00:17:40,640 --> 00:17:42,799
it or as already here but i guess there

486
00:17:42,799 --> 00:17:44,640
might be some extent

487
00:17:44,640 --> 00:17:45,919
you might have to think about a

488
00:17:45,919 --> 00:17:47,360
benchmark where you can see a difference

489
00:17:47,360 --> 00:17:48,559
and then just replace the performance

490
00:17:48,559 --> 00:17:50,160
counter with the difference detection

491
00:17:50,160 --> 00:17:53,039
and it should basically work

492
00:17:53,039 --> 00:17:55,280
sure

493
00:17:55,840 --> 00:17:58,240
hi uh thanks for the work and the talk

494
00:17:58,240 --> 00:18:01,440
uh there are like a lot of msr register

495
00:18:01,440 --> 00:18:03,360
and each one contains a lot of bits so

496
00:18:03,360 --> 00:18:05,840
how do you realistically uh try to flip

497
00:18:05,840 --> 00:18:07,919
each bits and that's the super cross

498
00:18:07,919 --> 00:18:09,760
register and all the content that's

499
00:18:09,760 --> 00:18:10,559
that's

500
00:18:10,559 --> 00:18:12,160
basically a lot of focus on the paper is

501
00:18:12,160 --> 00:18:14,559
to optimize that so uh first of all you

502
00:18:14,559 --> 00:18:15,679
can for the search base you can't

503
00:18:15,679 --> 00:18:17,280
parallelize it with the course it's a

504
00:18:17,280 --> 00:18:19,840
native idea uh i would refer you to the

505
00:18:19,840 --> 00:18:22,080
paper for the more details but basically

506
00:18:22,080 --> 00:18:23,760
we also used like an optimization

507
00:18:23,760 --> 00:18:25,919
approach so we had like a limited bound

508
00:18:25,919 --> 00:18:27,760
for they're also like enum fields for

509
00:18:27,760 --> 00:18:29,520
msrs usually don't have single bits you

510
00:18:29,520 --> 00:18:31,440
have like four bits defining something

511
00:18:31,440 --> 00:18:33,280
and actually we said that these are

512
00:18:33,280 --> 00:18:34,960
independent of each other and then you

513
00:18:34,960 --> 00:18:37,360
can just use 16 writes to msr to test

514
00:18:37,360 --> 00:18:40,080
everything and yeah they're way more

515
00:18:40,080 --> 00:18:42,640
details in the paper so okay and if i

516
00:18:42,640 --> 00:18:44,559
have time for one more question

517
00:18:44,559 --> 00:18:46,640
so there are also a lot of undocumented

518
00:18:46,640 --> 00:18:48,640
msr

519
00:18:48,640 --> 00:18:51,679
how much msr did you manage to classify

520
00:18:51,679 --> 00:18:53,039
and uh

521
00:18:53,039 --> 00:18:54,480
on the commented side

522
00:18:54,480 --> 00:18:57,360
so i have one additional slide for that

523
00:18:57,360 --> 00:18:58,480
so that's actually the table in the

524
00:18:58,480 --> 00:19:00,640
paper it's way too complex to describe

525
00:19:00,640 --> 00:19:03,039
what we found around imd has a lot of

526
00:19:03,039 --> 00:19:05,840
msrs which have um

527
00:19:05,840 --> 00:19:08,000
we have today um the small caveat here

528
00:19:08,000 --> 00:19:09,760
is that most of the msrs are just read

529
00:19:09,760 --> 00:19:11,440
and writeable but they ignore everything

530
00:19:11,440 --> 00:19:12,720
so you can write to them if you read it

531
00:19:12,720 --> 00:19:15,120
back it doesn't make any sense uh thing

532
00:19:15,120 --> 00:19:17,280
for the msrs which are more uh have a

533
00:19:17,280 --> 00:19:18,880
dynamic effect or a similar effect we

534
00:19:18,880 --> 00:19:20,240
described it in the paper but there was

535
00:19:20,240 --> 00:19:21,919
nothing interesting so nothing

536
00:19:21,919 --> 00:19:23,760
interesting we could find there might be

537
00:19:23,760 --> 00:19:26,080
some more effects it's a huge search

538
00:19:26,080 --> 00:19:28,559
base we focus on this six case studies

539
00:19:28,559 --> 00:19:30,000
we could fit in the paper and in the

540
00:19:30,000 --> 00:19:33,600
time frame okay thank you very much sure

541
00:19:33,600 --> 00:19:36,450
thank you very much uh thanks

542
00:19:36,450 --> 00:19:39,840
[Applause]

543
00:19:39,840 --> 00:19:41,918
you

