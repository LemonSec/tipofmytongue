1
00:00:01,760 --> 00:00:03,918
hi my name is max von hippel and today

2
00:00:03,919 --> 00:00:05,520
i'm going to be presenting automated

3
00:00:05,520 --> 00:00:07,359
attack synthesis by extracting finite

4
00:00:07,359 --> 00:00:08,639
state machines from protocol

5
00:00:08,639 --> 00:00:10,639
specification documents this work was a

6
00:00:10,639 --> 00:00:12,480
collaboration with maria

7
00:00:12,480 --> 00:00:14,799
lenoir pacheco at purdue who recently

8
00:00:14,799 --> 00:00:16,960
graduated her advisor dan goldwasser

9
00:00:16,960 --> 00:00:19,039
also at purdue another student from my

10
00:00:19,039 --> 00:00:19,840
lab

11
00:00:19,840 --> 00:00:22,000
ben weintraub and our joint advisor

12
00:00:22,000 --> 00:00:24,640
christine anita

13
00:00:24,640 --> 00:00:25,680
today we're going to be talking about

14
00:00:25,680 --> 00:00:27,680
the internet the internet runs on

15
00:00:27,680 --> 00:00:30,240
protocols and the idea is that if two

16
00:00:30,240 --> 00:00:32,159
computers on a network are running the

17
00:00:32,159 --> 00:00:33,600
same protocol this gives them a shared

18
00:00:33,600 --> 00:00:35,120
language by which they can communicate

19
00:00:35,120 --> 00:00:36,960
and examples of protocols include tcp

20
00:00:36,960 --> 00:00:40,079
udp dccp etc i have pictured here the

21
00:00:40,079 --> 00:00:42,719
arpa network in december 1969 arguably

22
00:00:42,719 --> 00:00:44,640
the original internet at the time there

23
00:00:44,640 --> 00:00:46,559
were four computers networked together

24
00:00:46,559 --> 00:00:47,840
but the internet has grown a little bit

25
00:00:47,840 --> 00:00:50,000
since this picture was drawn

26
00:00:50,000 --> 00:00:52,480
each protocol pier on the internet runs

27
00:00:52,480 --> 00:00:53,199
a

28
00:00:53,199 --> 00:00:54,480
an instance

29
00:00:54,480 --> 00:00:56,239
of the program implementing the protocol

30
00:00:56,239 --> 00:00:57,840
they're using to communicate and this is

31
00:00:57,840 --> 00:00:59,520
usually described with a formalism that

32
00:00:59,520 --> 00:01:01,280
we call a finite state machine a finite

33
00:01:01,280 --> 00:01:02,879
state machine is a directed graph where

34
00:01:02,879 --> 00:01:05,600
the nodes represent states in the

35
00:01:05,600 --> 00:01:08,640
protocol logic and transitions or edges

36
00:01:08,640 --> 00:01:10,159
are changes in state these often

37
00:01:10,159 --> 00:01:11,600
correspond with some event like sending

38
00:01:11,600 --> 00:01:12,799
or receiving a message or having a

39
00:01:12,799 --> 00:01:14,479
timeout

40
00:01:14,479 --> 00:01:16,799
in general we can find attacks against

41
00:01:16,799 --> 00:01:19,280
vulnerabilities in or flaws in

42
00:01:19,280 --> 00:01:21,119
these types of protocols by analyzing

43
00:01:21,119 --> 00:01:23,360
their finite state machines so we'd like

44
00:01:23,360 --> 00:01:25,200
the finite state machine to have kind of

45
00:01:25,200 --> 00:01:26,960
enough resolution that by analyzing it

46
00:01:26,960 --> 00:01:28,000
we can understand whether or not the

47
00:01:28,000 --> 00:01:29,680
protocol achieves this intended purpose

48
00:01:29,680 --> 00:01:32,240
at least abstractly

49
00:01:32,240 --> 00:01:34,479
in my lab also ben's lab at northeastern

50
00:01:34,479 --> 00:01:36,560
under christina rotaro

51
00:01:36,560 --> 00:01:39,200
we specialize in in building automated

52
00:01:39,200 --> 00:01:40,799
attack discovery tools so what we do as

53
00:01:40,799 --> 00:01:42,479
a group is that we build tools which

54
00:01:42,479 --> 00:01:43,920
usually take a finite state machine

55
00:01:43,920 --> 00:01:45,759
model as an input and they're guided by

56
00:01:45,759 --> 00:01:47,520
that model defined and attacked against

57
00:01:47,520 --> 00:01:49,360
the protocol perhaps using formal

58
00:01:49,360 --> 00:01:51,600
methods such as korg which is a tool

59
00:01:51,600 --> 00:01:52,640
i'll be using today and which i

60
00:01:52,640 --> 00:01:54,720
presented at safe comp in 2020 that i

61
00:01:54,720 --> 00:01:56,960
authored or maybe not using formal

62
00:01:56,960 --> 00:01:59,439
methods like snake or tcpone which were

63
00:01:59,439 --> 00:02:00,719
done by a previous member of our lab

64
00:02:00,719 --> 00:02:02,079
samuel giro

65
00:02:02,079 --> 00:02:04,240
and which won best paper awards but such

66
00:02:04,240 --> 00:02:05,920
tools require a protocol finite state

67
00:02:05,920 --> 00:02:07,600
machine in order to guide the search for

68
00:02:07,600 --> 00:02:09,119
an attack so the question becomes where

69
00:02:09,119 --> 00:02:11,280
can we find one of these state machines

70
00:02:11,280 --> 00:02:12,640
and and that's something we'll be

71
00:02:12,640 --> 00:02:14,959
working on today in this presentation

72
00:02:14,959 --> 00:02:16,800
so one potential source of information

73
00:02:16,800 --> 00:02:18,879
from which we might find the data we

74
00:02:18,879 --> 00:02:20,480
need to construct a finite state machine

75
00:02:20,480 --> 00:02:21,680
would be what's called a request for

76
00:02:21,680 --> 00:02:24,239
comments document or rfc rfcs provide

77
00:02:24,239 --> 00:02:25,920
specifications and organizational notes

78
00:02:25,920 --> 00:02:27,520
for the internet they're produced by the

79
00:02:27,520 --> 00:02:29,040
internet engineering task force which is

80
00:02:29,040 --> 00:02:30,080
associated with the united states

81
00:02:30,080 --> 00:02:31,519
government and they describe the main

82
00:02:31,519 --> 00:02:33,360
internet protocols and pros here i have

83
00:02:33,360 --> 00:02:35,920
pictured a screenshot from the dccp rfc

84
00:02:35,920 --> 00:02:37,040
and you can see what i mean when i say

85
00:02:37,040 --> 00:02:39,280
pros is plain english documentation so

86
00:02:39,280 --> 00:02:40,959
this is not you know in my dream we'd

87
00:02:40,959 --> 00:02:42,560
have like or agda or something but

88
00:02:42,560 --> 00:02:43,920
that's not what we actually have we have

89
00:02:43,920 --> 00:02:45,040
english documentation of how the

90
00:02:45,040 --> 00:02:46,720
protocol works

91
00:02:46,720 --> 00:02:47,920
an alternative place to look for

92
00:02:47,920 --> 00:02:49,120
information would be in an actual

93
00:02:49,120 --> 00:02:51,040
implementation so i might look at some

94
00:02:51,040 --> 00:02:52,640
implementation in a language like c or c

95
00:02:52,640 --> 00:02:54,480
plus plus or go and try to extract a

96
00:02:54,480 --> 00:02:56,080
finite state machine from this

97
00:02:56,080 --> 00:02:57,920
such implementations are manually

98
00:02:57,920 --> 00:02:59,360
derived from requests for comments

99
00:02:59,360 --> 00:03:01,040
documents but they don't necessarily

100
00:03:01,040 --> 00:03:02,640
contain all the information from an rfc

101
00:03:02,640 --> 00:03:03,680
because there might be optional

102
00:03:03,680 --> 00:03:05,840
functionality that they don't contain

103
00:03:05,840 --> 00:03:07,200
and they contain some information not

104
00:03:07,200 --> 00:03:09,040
found in the rfc such as what you might

105
00:03:09,040 --> 00:03:10,879
call folklore knowledge or domain

106
00:03:10,879 --> 00:03:12,560
expertise

107
00:03:12,560 --> 00:03:14,000
so we have two sources of information

108
00:03:14,000 --> 00:03:16,480
where we might look to find a protocol

109
00:03:16,480 --> 00:03:18,159
fsm in order to use one of our tools to

110
00:03:18,159 --> 00:03:20,319
study the fsm and find flaws and the

111
00:03:20,319 --> 00:03:21,760
first would be the code and there's

112
00:03:21,760 --> 00:03:22,879
actually quite a lot of work that does

113
00:03:22,879 --> 00:03:24,159
this in fact i imagine there are

114
00:03:24,159 --> 00:03:25,519
probably numerous papers at this

115
00:03:25,519 --> 00:03:27,120
conference this week that do this type

116
00:03:27,120 --> 00:03:29,599
of thing and such papers might do static

117
00:03:29,599 --> 00:03:30,959
or dynamic analysis they might run the

118
00:03:30,959 --> 00:03:33,280
code and study the traces or do any

119
00:03:33,280 --> 00:03:34,879
number of other things so that's a very

120
00:03:34,879 --> 00:03:36,159
well studied and very interesting

121
00:03:36,159 --> 00:03:38,239
problem but another problem would be to

122
00:03:38,239 --> 00:03:40,080
extract a finite state machine directly

123
00:03:40,080 --> 00:03:41,840
from the specification document which

124
00:03:41,840 --> 00:03:43,760
might be an rfc or something else and to

125
00:03:43,760 --> 00:03:45,360
the best of our knowledge nobody prior

126
00:03:45,360 --> 00:03:47,200
to this work has ever fully extracted a

127
00:03:47,200 --> 00:03:48,720
finite state machine of a protocol or

128
00:03:48,720 --> 00:03:50,799
even attempted to do so really from just

129
00:03:50,799 --> 00:03:52,400
a protocol specification document in

130
00:03:52,400 --> 00:03:53,680
plain english so that's what we're going

131
00:03:53,680 --> 00:03:54,959
to try and do today

132
00:03:54,959 --> 00:03:56,319
so we'll ask two questions and we'll

133
00:03:56,319 --> 00:03:57,760
answer both affirmatively and the first

134
00:03:57,760 --> 00:04:00,159
question is can we automatically extract

135
00:04:00,159 --> 00:04:01,920
uh protocol finite state machine from

136
00:04:01,920 --> 00:04:03,760
just this english language pro

137
00:04:03,760 --> 00:04:05,680
specification document in our case a

138
00:04:05,680 --> 00:04:07,360
request for comments document

139
00:04:07,360 --> 00:04:09,280
and the second question is uh when we

140
00:04:09,280 --> 00:04:11,200
extract this fsm we kind of want to know

141
00:04:11,200 --> 00:04:13,120
like is it correct somehow and and sort

142
00:04:13,120 --> 00:04:14,640
of it's difficult to define what this

143
00:04:14,640 --> 00:04:16,238
means so for us it's going to mean is

144
00:04:16,238 --> 00:04:17,839
the fsm good enough to do something

145
00:04:17,839 --> 00:04:19,918
useful and we believe something useful

146
00:04:19,918 --> 00:04:21,040
means using it for a real world

147
00:04:21,040 --> 00:04:22,560
application our application will be

148
00:04:22,560 --> 00:04:24,960
attack synthesis but we we claim that

149
00:04:24,960 --> 00:04:26,240
any number of other applications might

150
00:04:26,240 --> 00:04:28,400
work as well

151
00:04:28,400 --> 00:04:30,080
we face numerous challenges when working

152
00:04:30,080 --> 00:04:30,960
on this

153
00:04:30,960 --> 00:04:32,080
and the first challenge is that there

154
00:04:32,080 --> 00:04:33,759
really is no one-to-one mapping between

155
00:04:33,759 --> 00:04:35,919
text and what we call canonical fsm or

156
00:04:35,919 --> 00:04:37,440
in other words the fsm that an expert

157
00:04:37,440 --> 00:04:39,120
would write by hand based off a reading

158
00:04:39,120 --> 00:04:40,639
of the rfc

159
00:04:40,639 --> 00:04:43,600
in fact when when such fsms are created

160
00:04:43,600 --> 00:04:45,520
they require a lot of domain expertise

161
00:04:45,520 --> 00:04:47,360
and careful human reading because the

162
00:04:47,360 --> 00:04:48,800
english language text is inherently

163
00:04:48,800 --> 00:04:50,800
ambiguous

164
00:04:50,800 --> 00:04:53,759
the second problem is is that rfcs

165
00:04:53,759 --> 00:04:55,360
specifically will contain many omissions

166
00:04:55,360 --> 00:04:57,360
mistakes and ambiguities here we have a

167
00:04:57,360 --> 00:04:59,199
quote where um

168
00:04:59,199 --> 00:05:00,720
if you read the quote carefully it would

169
00:05:00,720 --> 00:05:02,160
imply the existence of a transition from

170
00:05:02,160 --> 00:05:04,639
part open to open uh upon receipt of a

171
00:05:04,639 --> 00:05:06,240
dccp closed message but of course there

172
00:05:06,240 --> 00:05:07,919
is no such transition so this is an

173
00:05:07,919 --> 00:05:10,400
english language ambiguity it's made

174
00:05:10,400 --> 00:05:11,840
clear to the expert when they read the

175
00:05:11,840 --> 00:05:13,280
document but it is frankly an ambiguity

176
00:05:13,280 --> 00:05:14,639
in the text and such ambiguities and

177
00:05:14,639 --> 00:05:16,639
omissions exist in many rfcs in our

178
00:05:16,639 --> 00:05:18,400
experience

179
00:05:18,400 --> 00:05:20,080
third off-the-shelf natural language

180
00:05:20,080 --> 00:05:21,280
processing techniques are simply not

181
00:05:21,280 --> 00:05:22,800
suitable generally speaking such

182
00:05:22,800 --> 00:05:24,800
techniques are trained on newswire text

183
00:05:24,800 --> 00:05:26,880
or other types of perhaps you might say

184
00:05:26,880 --> 00:05:29,120
more natural language um but but we

185
00:05:29,120 --> 00:05:30,479
really need to have something that knows

186
00:05:30,479 --> 00:05:32,160
how to read technical language and

187
00:05:32,160 --> 00:05:33,520
technical language is inherently

188
00:05:33,520 --> 00:05:36,240
different from from natural language

189
00:05:36,240 --> 00:05:37,840
and so we can't really use something

190
00:05:37,840 --> 00:05:39,120
totally off the shelf and achieve good

191
00:05:39,120 --> 00:05:40,479
results

192
00:05:40,479 --> 00:05:41,759
fourth and finally there's a lot of

193
00:05:41,759 --> 00:05:43,600
variation in the language and structure

194
00:05:43,600 --> 00:05:45,120
of different rfc documents they're

195
00:05:45,120 --> 00:05:46,240
authored by different people using

196
00:05:46,240 --> 00:05:47,440
different styles there's no kind of

197
00:05:47,440 --> 00:05:49,600
standardized way to write an rfc and so

198
00:05:49,600 --> 00:05:50,880
um something that works really well on

199
00:05:50,880 --> 00:05:52,160
one rfc might not work that well on

200
00:05:52,160 --> 00:05:53,120
another and this creates another

201
00:05:53,120 --> 00:05:54,720
challenge for us

202
00:05:54,720 --> 00:05:56,720
we take a four-step approach the first

203
00:05:56,720 --> 00:05:58,479
step is to create a technical language

204
00:05:58,479 --> 00:06:00,639
embedding which captures various

205
00:06:00,639 --> 00:06:02,240
interesting or important features of the

206
00:06:02,240 --> 00:06:04,000
language that we want to describe and

207
00:06:04,000 --> 00:06:06,080
we'll talk about this more subsequently

208
00:06:06,080 --> 00:06:09,120
the second step is to read the rfc and

209
00:06:09,120 --> 00:06:10,720
extract a representation of it using our

210
00:06:10,720 --> 00:06:12,319
technical language embedding using a

211
00:06:12,319 --> 00:06:14,560
zero-shot approach which means that

212
00:06:14,560 --> 00:06:16,319
when we apply our approach to some test

213
00:06:16,319 --> 00:06:17,919
data that test data was never observed

214
00:06:17,919 --> 00:06:19,600
at the training time so it's it's uh

215
00:06:19,600 --> 00:06:20,800
there's kind of no cheating in some

216
00:06:20,800 --> 00:06:22,880
sense um

217
00:06:22,880 --> 00:06:25,039
but this uh this extracted intermediary

218
00:06:25,039 --> 00:06:26,800
representation we're not done yet it

219
00:06:26,800 --> 00:06:28,880
doesn't actually contain a model it just

220
00:06:28,880 --> 00:06:30,479
contains information in some sense about

221
00:06:30,479 --> 00:06:32,160
how to read the document so now it's

222
00:06:32,160 --> 00:06:33,680
time to read the document we do so and

223
00:06:33,680 --> 00:06:35,520
we extract a finite state machine from

224
00:06:35,520 --> 00:06:37,680
the intermediary representation

225
00:06:37,680 --> 00:06:39,120
fourth and finally we have a finite

226
00:06:39,120 --> 00:06:40,319
state machine we want to know is it good

227
00:06:40,319 --> 00:06:42,000
for anything so we do something with it

228
00:06:42,000 --> 00:06:43,520
namely attack synthesis and i'll be

229
00:06:43,520 --> 00:06:44,639
going over each of these steps in more

230
00:06:44,639 --> 00:06:45,840
detail

231
00:06:45,840 --> 00:06:47,280
so step one is learning the technical

232
00:06:47,280 --> 00:06:48,639
language embedding we use a

233
00:06:48,639 --> 00:06:50,319
contextualized representation called

234
00:06:50,319 --> 00:06:53,280
bert and the basic concept is that the

235
00:06:53,280 --> 00:06:55,280
meaning of a word is based not only of

236
00:06:55,280 --> 00:06:56,720
its kind of strict definition but also

237
00:06:56,720 --> 00:06:58,479
its context in this case the word reset

238
00:06:58,479 --> 00:06:59,680
means a different thing depending on the

239
00:06:59,680 --> 00:07:01,759
words that surround it so bert takes

240
00:07:01,759 --> 00:07:03,520
into account not just the word but also

241
00:07:03,520 --> 00:07:06,080
the context it resides in uh we train

242
00:07:06,080 --> 00:07:07,759
our model on uh

243
00:07:07,759 --> 00:07:09,759
9 000 well approximately 9 000 documents

244
00:07:09,759 --> 00:07:13,440
and approximately 500 million words

245
00:07:13,440 --> 00:07:15,280
so an example of what our embedding

246
00:07:15,280 --> 00:07:16,800
might look like

247
00:07:16,800 --> 00:07:18,800
is maybe useful or more useful than just

248
00:07:18,800 --> 00:07:20,800
purely technical statements about it so

249
00:07:20,800 --> 00:07:22,240
let's look at this example text here we

250
00:07:22,240 --> 00:07:23,360
have

251
00:07:23,360 --> 00:07:25,599
some text from the dccp rfc and we want

252
00:07:25,599 --> 00:07:26,960
to take this and annotate it in some

253
00:07:26,960 --> 00:07:28,319
richer ways so we can use it for

254
00:07:28,319 --> 00:07:29,520
something useful

255
00:07:29,520 --> 00:07:30,960
we're going to do so with a grammar our

256
00:07:30,960 --> 00:07:32,319
grammar will consist first of all of

257
00:07:32,319 --> 00:07:33,840
definition tags which define states

258
00:07:33,840 --> 00:07:35,520
events etc

259
00:07:35,520 --> 00:07:36,960
second we'll have reference tags which

260
00:07:36,960 --> 00:07:38,160
track references to things that we

261
00:07:38,160 --> 00:07:39,759
defined previously using our definition

262
00:07:39,759 --> 00:07:40,960
tags

263
00:07:40,960 --> 00:07:42,240
third we'll have state machine tags

264
00:07:42,240 --> 00:07:43,440
these are arguably the most important

265
00:07:43,440 --> 00:07:45,440
tags on our grammar they describe for

266
00:07:45,440 --> 00:07:47,120
instance the transitions within a state

267
00:07:47,120 --> 00:07:48,479
machine

268
00:07:48,479 --> 00:07:50,000
fourth and finally we have control flow

269
00:07:50,000 --> 00:07:52,240
tags which in some sense capture if then

270
00:07:52,240 --> 00:07:53,599
else type structure in the document

271
00:07:53,599 --> 00:07:55,440
itself or kind of the control flow of

272
00:07:55,440 --> 00:07:57,520
the language of the document

273
00:07:57,520 --> 00:07:59,199
so here's that quote from before but now

274
00:07:59,199 --> 00:08:01,039
structured according to our xml on the

275
00:08:01,039 --> 00:08:02,479
outermost layer we have a control block

276
00:08:02,479 --> 00:08:03,759
which is going to scope our search it

277
00:08:03,759 --> 00:08:05,599
says essentially all the important logic

278
00:08:05,599 --> 00:08:07,039
for this thing you're trying to extract

279
00:08:07,039 --> 00:08:09,599
is within this chunk of text

280
00:08:09,599 --> 00:08:11,120
second we have a transition block which

281
00:08:11,120 --> 00:08:12,639
contains the source state where the

282
00:08:12,639 --> 00:08:14,400
transition begins and the target state

283
00:08:14,400 --> 00:08:16,160
where the transition goes to

284
00:08:16,160 --> 00:08:18,560
third we have the event which triggers

285
00:08:18,560 --> 00:08:20,400
the transition which in this case is the

286
00:08:20,400 --> 00:08:22,240
receipt of the message with identifier

287
00:08:22,240 --> 00:08:23,759
two meaning when we had the def state

288
00:08:23,759 --> 00:08:26,560
for it is id was two so we need a way to

289
00:08:26,560 --> 00:08:28,240
go from plain text to something that

290
00:08:28,240 --> 00:08:30,080
looks like this

291
00:08:30,080 --> 00:08:31,360
we have two approaches to do this the

292
00:08:31,360 --> 00:08:32,958
first is a linear conditional random

293
00:08:32,958 --> 00:08:35,279
fields model or linear crf the linear

294
00:08:35,279 --> 00:08:37,360
serif first splits the text into chunks

295
00:08:37,360 --> 00:08:39,039
it then extracts features these features

296
00:08:39,039 --> 00:08:40,799
are things like capitalization patterns

297
00:08:40,799 --> 00:08:42,240
the existence of different mathematical

298
00:08:42,240 --> 00:08:44,159
formulae et cetera

299
00:08:44,159 --> 00:08:45,839
and then it feeds those feature vectors

300
00:08:45,839 --> 00:08:47,920
into a linear crf model i'm not going to

301
00:08:47,920 --> 00:08:49,279
get into the model in detail but it

302
00:08:49,279 --> 00:08:50,800
builds on the markovian assumption that

303
00:08:50,800 --> 00:08:52,720
the next state is entirely predicated on

304
00:08:52,720 --> 00:08:54,399
the previous state

305
00:08:54,399 --> 00:08:56,560
we also try a neural equivalent of the

306
00:08:56,560 --> 00:08:58,800
linear crf model so something that is

307
00:08:58,800 --> 00:09:00,800
very morally similar to the linear crf

308
00:09:00,800 --> 00:09:02,080
but is based off a neural network

309
00:09:02,080 --> 00:09:06,000
architecture and we call that neural crf

310
00:09:06,080 --> 00:09:10,399
we evaluate on a number of rfcs and we

311
00:09:10,399 --> 00:09:12,640
find that both our linear crf and neural

312
00:09:12,640 --> 00:09:16,640
crf models do a better job extracting

313
00:09:16,640 --> 00:09:18,880
intermediary representation than a

314
00:09:18,880 --> 00:09:20,640
purely heuristic rule-based method which

315
00:09:20,640 --> 00:09:22,240
is what we'd expect we also find that

316
00:09:22,240 --> 00:09:24,240
the neural crf model does slightly

317
00:09:24,240 --> 00:09:26,080
better than the linear one and we'll see

318
00:09:26,080 --> 00:09:27,519
in general in this presentation that our

319
00:09:27,519 --> 00:09:28,800
neural model slightly outperforms our

320
00:09:28,800 --> 00:09:30,880
linear model

321
00:09:30,880 --> 00:09:32,880
so we've now explained how to some

322
00:09:32,880 --> 00:09:34,560
extent we generate this intermediary

323
00:09:34,560 --> 00:09:36,320
representation this structured xml that

324
00:09:36,320 --> 00:09:37,920
tells you how to read the document now

325
00:09:37,920 --> 00:09:39,200
we want to do something interesting with

326
00:09:39,200 --> 00:09:40,160
it

327
00:09:40,160 --> 00:09:41,760
and the first step is going to be to

328
00:09:41,760 --> 00:09:44,000
take this and read it in order to get a

329
00:09:44,000 --> 00:09:45,120
state machine to get states and

330
00:09:45,120 --> 00:09:47,440
transitions like this one

331
00:09:47,440 --> 00:09:49,519
so we use a purely heuristic extraction

332
00:09:49,519 --> 00:09:51,760
algorithm and our extraction algorithm

333
00:09:51,760 --> 00:09:54,000
was really designed with tcp and dccp

334
00:09:54,000 --> 00:09:56,080
rfcs in mind although it should

335
00:09:56,080 --> 00:09:58,399
generalize to other rfc documents

336
00:09:58,399 --> 00:10:00,080
essentially we search lower in the xml

337
00:10:00,080 --> 00:10:02,720
for targets higher for sources and we

338
00:10:02,720 --> 00:10:04,079
have some smart ways to do things like

339
00:10:04,079 --> 00:10:06,640
handle set complement in in sentences uh

340
00:10:06,640 --> 00:10:09,279
and in the end we may find um uh quite a

341
00:10:09,279 --> 00:10:10,640
few transitions and and then we use some

342
00:10:10,640 --> 00:10:11,920
heuristics to filter out the ones that

343
00:10:11,920 --> 00:10:14,399
we think are perhaps noise uh and and

344
00:10:14,399 --> 00:10:15,920
these are just based off our experience

345
00:10:15,920 --> 00:10:18,560
working with those rfcs

346
00:10:18,560 --> 00:10:20,480
so we evaluate on the transmission

347
00:10:20,480 --> 00:10:22,320
control protocol and

348
00:10:22,320 --> 00:10:24,160
we introduced this idea of a gold

349
00:10:24,160 --> 00:10:25,680
intermediary representation which is one

350
00:10:25,680 --> 00:10:28,000
where we simply annotate the document by

351
00:10:28,000 --> 00:10:29,519
hand so in theory the annotations are

352
00:10:29,519 --> 00:10:31,040
perfect and we compare that to what we

353
00:10:31,040 --> 00:10:32,399
get with the linear neural

354
00:10:32,399 --> 00:10:34,160
uh sorry linear crf and neural crf

355
00:10:34,160 --> 00:10:35,920
models um we have this very interesting

356
00:10:35,920 --> 00:10:37,120
result tcp that although the

357
00:10:37,120 --> 00:10:38,560
intermediary representations we get from

358
00:10:38,560 --> 00:10:40,399
the linear and neural models differ the

359
00:10:40,399 --> 00:10:41,839
actual extracted fsms are going to be

360
00:10:41,839 --> 00:10:44,480
identical which is kind of funny

361
00:10:44,480 --> 00:10:45,760
we define a transition as being

362
00:10:45,760 --> 00:10:47,519
approximately correct if the start and

363
00:10:47,519 --> 00:10:48,800
end states are correct and at least one

364
00:10:48,800 --> 00:10:51,920
event is correct and we find that um we

365
00:10:51,920 --> 00:10:52,800
we get

366
00:10:52,800 --> 00:10:55,360
most of the uh

367
00:10:55,360 --> 00:10:56,800
transitions approximately correct but

368
00:10:56,800 --> 00:10:57,920
there's quite a few incorrect

369
00:10:57,920 --> 00:10:59,440
transitions in addition in the cases of

370
00:10:59,440 --> 00:11:01,040
the linear crop and neural crf and our

371
00:11:01,040 --> 00:11:02,720
results with dcp are

372
00:11:02,720 --> 00:11:05,600
dccp are reasonably similar

373
00:11:05,600 --> 00:11:07,120
in contrast with gold

374
00:11:07,120 --> 00:11:08,640
very few transitions are incorrect which

375
00:11:08,640 --> 00:11:11,360
is what you'd expect

376
00:11:11,519 --> 00:11:12,880
we'd like to know though why do we get

377
00:11:12,880 --> 00:11:14,079
so many incorrect transitions right i

378
00:11:14,079 --> 00:11:15,040
mean this is sort of a fundamental

379
00:11:15,040 --> 00:11:17,040
limitation so why does this happen

380
00:11:17,040 --> 00:11:19,040
so with the gold intermediary

381
00:11:19,040 --> 00:11:21,120
representation everything all the

382
00:11:21,120 --> 00:11:22,640
incorrectness is due to omissions or

383
00:11:22,640 --> 00:11:24,160
ambiguities in the text which makes

384
00:11:24,160 --> 00:11:25,519
sense because theoretically the

385
00:11:25,519 --> 00:11:27,360
annotations are perfect however with the

386
00:11:27,360 --> 00:11:28,959
linear crf with rules and neural cf with

387
00:11:28,959 --> 00:11:29,920
rules

388
00:11:29,920 --> 00:11:31,680
this substantial majority of errors are

389
00:11:31,680 --> 00:11:33,760
caused by prediction errors the dccp

390
00:11:33,760 --> 00:11:35,040
results are similar but they also

391
00:11:35,040 --> 00:11:36,079
contain some extraction error and

392
00:11:36,079 --> 00:11:38,240
post-processing error

393
00:11:38,240 --> 00:11:39,680
finally we have an extracted finite

394
00:11:39,680 --> 00:11:41,279
state machine and now we're going to do

395
00:11:41,279 --> 00:11:42,640
something useful with it so we've shown

396
00:11:42,640 --> 00:11:44,240
you that we get a machine i've said that

397
00:11:44,240 --> 00:11:45,760
it may have some errors in it and you

398
00:11:45,760 --> 00:11:46,880
might be thinking well with all those

399
00:11:46,880 --> 00:11:48,079
errors can you still do something with

400
00:11:48,079 --> 00:11:49,440
it and the answer's going to be yes and

401
00:11:49,440 --> 00:11:51,680
now that's that's what we'll show so as

402
00:11:51,680 --> 00:11:53,839
our representative application we use

403
00:11:53,839 --> 00:11:55,200
korg which is an automated attack

404
00:11:55,200 --> 00:11:56,639
synthesis tool that i authored and

405
00:11:56,639 --> 00:11:59,120
published at safe comp in 2020. um quark

406
00:11:59,120 --> 00:12:01,040
takes it as input the extracted finite

407
00:12:01,040 --> 00:12:02,880
state machine which we just went over as

408
00:12:02,880 --> 00:12:04,959
well as a linear temporal logic property

409
00:12:04,959 --> 00:12:06,800
that we write manually based off a close

410
00:12:06,800 --> 00:12:08,839
reading of the rfc document

411
00:12:08,839 --> 00:12:11,839
um i wrote these properties with ben

412
00:12:11,839 --> 00:12:13,279
weintraub which is one of the other

413
00:12:13,279 --> 00:12:15,279
authors on this this project

414
00:12:15,279 --> 00:12:17,200
those properties plus the model are fed

415
00:12:17,200 --> 00:12:19,760
to korg korg then generates essentially

416
00:12:19,760 --> 00:12:21,680
a system capturing two protocol peers

417
00:12:21,680 --> 00:12:23,519
communicating over a vulnerable channel

418
00:12:23,519 --> 00:12:25,040
and the the channel has a sort of

419
00:12:25,040 --> 00:12:26,560
non-deterministic vulnerability it's

420
00:12:26,560 --> 00:12:28,160
sort of underspecified

421
00:12:28,160 --> 00:12:29,279
and under some assumptions which are

422
00:12:29,279 --> 00:12:30,480
given in the paper it asks the spin

423
00:12:30,480 --> 00:12:32,320
model checker will the system satisfy

424
00:12:32,320 --> 00:12:33,760
the correctness properties

425
00:12:33,760 --> 00:12:35,519
in the likely event that

426
00:12:35,519 --> 00:12:36,639
the system does not satisfy the

427
00:12:36,639 --> 00:12:37,920
correctness properties the spin model

428
00:12:37,920 --> 00:12:39,839
checker will find a counter example uh

429
00:12:39,839 --> 00:12:41,519
which is a sequence of events in which

430
00:12:41,519 --> 00:12:43,279
one of the properties fails it hands it

431
00:12:43,279 --> 00:12:45,120
back to korg korg then generates an

432
00:12:45,120 --> 00:12:46,959
attacker program which simply replays

433
00:12:46,959 --> 00:12:49,360
that counter example it's quite simple

434
00:12:49,360 --> 00:12:51,279
if you provide core with a canonical fsm

435
00:12:51,279 --> 00:12:52,959
one that you wrote by hand it will test

436
00:12:52,959 --> 00:12:54,800
the attack to see if it works but you

437
00:12:54,800 --> 00:12:55,920
know in principle if you're using a

438
00:12:55,920 --> 00:12:58,160
technique you probably don't have that

439
00:12:58,160 --> 00:13:00,399
we do two case studies tcp and dccp for

440
00:13:00,399 --> 00:13:02,320
time we'll only mention tcp

441
00:13:02,320 --> 00:13:04,480
for tcp we have four properties the

442
00:13:04,480 --> 00:13:06,399
first three come from my cork paper the

443
00:13:06,399 --> 00:13:08,800
safe paper in 2020 and the fourth ben

444
00:13:08,800 --> 00:13:10,240
weintraub wrote based off of a close

445
00:13:10,240 --> 00:13:12,399
reading of the uh request for comments

446
00:13:12,399 --> 00:13:14,560
document and we have a canonical fsm uh

447
00:13:14,560 --> 00:13:16,160
which i wrote it's very similar to the

448
00:13:16,160 --> 00:13:17,600
one that i used in the court paper but

449
00:13:17,600 --> 00:13:19,120
with some slight modifications to better

450
00:13:19,120 --> 00:13:22,320
support or setup for this paper

451
00:13:22,320 --> 00:13:24,880
okay so in terms of results with tcp

452
00:13:24,880 --> 00:13:27,120
only the first property turns out to be

453
00:13:27,120 --> 00:13:29,519
useful with any of our extracted fsms

454
00:13:29,519 --> 00:13:30,959
for generating attacks and we discuss

455
00:13:30,959 --> 00:13:32,480
why in the paper

456
00:13:32,480 --> 00:13:34,079
we find very few attacks but all of them

457
00:13:34,079 --> 00:13:36,079
are confirmed against the canonical fsm

458
00:13:36,079 --> 00:13:37,200
meaning that they are true positives

459
00:13:37,200 --> 00:13:39,839
they actually work um and because we

460
00:13:39,839 --> 00:13:41,279
have identical fsms with the linear

461
00:13:41,279 --> 00:13:43,360
neural models for tcp we get identical

462
00:13:43,360 --> 00:13:46,079
results in the case of dccp the results

463
00:13:46,079 --> 00:13:47,760
are somewhat different

464
00:13:47,760 --> 00:13:49,360
across the gold linear and neural rf

465
00:13:49,360 --> 00:13:50,959
models we find attacks with numerous

466
00:13:50,959 --> 00:13:52,160
properties

467
00:13:52,160 --> 00:13:52,880
but

468
00:13:52,880 --> 00:13:53,839
there's two things that are interesting

469
00:13:53,839 --> 00:13:55,279
here the first is that we find many more

470
00:13:55,279 --> 00:13:58,000
attacks with dccp than we do with tcp

471
00:13:58,000 --> 00:13:58,800
and

472
00:13:58,800 --> 00:14:00,399
and yet many of those attacks are false

473
00:14:00,399 --> 00:14:02,560
positives so you'll see that

474
00:14:02,560 --> 00:14:04,000
many of them are called unconfirmed so

475
00:14:04,000 --> 00:14:05,360
they don't actually work against the

476
00:14:05,360 --> 00:14:07,199
canonical state machine the second thing

477
00:14:07,199 --> 00:14:08,320
that's interesting is that we actually

478
00:14:08,320 --> 00:14:09,760
find more attacks using linear and

479
00:14:09,760 --> 00:14:11,519
neural than we do using gold which is

480
00:14:11,519 --> 00:14:12,880
quite interesting

481
00:14:12,880 --> 00:14:14,000
and this seems to be kind of a

482
00:14:14,000 --> 00:14:16,079
complicated signal to noise trade-off

483
00:14:16,079 --> 00:14:17,199
type of thing and we discussed this more

484
00:14:17,199 --> 00:14:18,399
in the paper i'm also happy to take

485
00:14:18,399 --> 00:14:19,839
questions about it

486
00:14:19,839 --> 00:14:21,040
so you may ask like what are these

487
00:14:21,040 --> 00:14:22,320
attacks right you say you find attacks

488
00:14:22,320 --> 00:14:24,160
what do those attacks look like

489
00:14:24,160 --> 00:14:26,079
one example for tcp would be injecting a

490
00:14:26,079 --> 00:14:27,519
single acknowledgement into one of the

491
00:14:27,519 --> 00:14:28,639
peers during

492
00:14:28,639 --> 00:14:30,320
the establishment routine which can

493
00:14:30,320 --> 00:14:31,760
potentially cause a de-synchronization

494
00:14:31,760 --> 00:14:32,800
although it's not guaranteed to it

495
00:14:32,800 --> 00:14:34,320
depends on some non-deterministic

496
00:14:34,320 --> 00:14:35,360
decisions

497
00:14:35,360 --> 00:14:36,639
this is a reproduction of a result from

498
00:14:36,639 --> 00:14:38,880
the court paper in the case of dccp an

499
00:14:38,880 --> 00:14:40,399
example attack would be one of the

500
00:14:40,399 --> 00:14:42,000
elaborately spoofs each pier to guide

501
00:14:42,000 --> 00:14:43,519
the other into closed rec

502
00:14:43,519 --> 00:14:45,360
there's no closed rec close rec state

503
00:14:45,360 --> 00:14:46,880
because there's no active active tear

504
00:14:46,880 --> 00:14:48,639
down in dccp so this is an incorrect

505
00:14:48,639 --> 00:14:49,600
behavior

506
00:14:49,600 --> 00:14:50,880
and we define an attack as something

507
00:14:50,880 --> 00:14:52,399
that induces an incorrect behavior and

508
00:14:52,399 --> 00:14:53,839
we actually find multiple variations on

509
00:14:53,839 --> 00:14:55,519
this theme which is because we use a

510
00:14:55,519 --> 00:14:57,040
model checker and the model checker is

511
00:14:57,040 --> 00:14:58,240
kind of based off graph search so it's

512
00:14:58,240 --> 00:15:00,480
going to find maybe multiple paths to

513
00:15:00,480 --> 00:15:02,320
similar outcomes so we find that we

514
00:15:02,320 --> 00:15:04,000
might generate half a dozen attacks that

515
00:15:04,000 --> 00:15:06,000
are quite similar but programmatically

516
00:15:06,000 --> 00:15:08,240
different but do the same thing

517
00:15:08,240 --> 00:15:10,320
so in conclusion we asked two questions

518
00:15:10,320 --> 00:15:12,480
could we extract fsm from rfcs and could

519
00:15:12,480 --> 00:15:13,760
we do anything useful with them the

520
00:15:13,760 --> 00:15:15,360
answer was yes we could extract fsms but

521
00:15:15,360 --> 00:15:16,480
they might have some errors so we call

522
00:15:16,480 --> 00:15:18,320
them partial fsms and yes we could do

523
00:15:18,320 --> 00:15:19,680
something useful with them but depending

524
00:15:19,680 --> 00:15:21,440
on the protocol we may have more or less

525
00:15:21,440 --> 00:15:23,600
success in terms of generating attacks

526
00:15:23,600 --> 00:15:24,880
however we confirm many of our attacks

527
00:15:24,880 --> 00:15:27,120
using a handwritten canonical fsm all of

528
00:15:27,120 --> 00:15:28,560
our code a docker file to reproduce

529
00:15:28,560 --> 00:15:30,240
every single one of our results uh

530
00:15:30,240 --> 00:15:32,000
detailed documentation

531
00:15:32,000 --> 00:15:33,519
extensive tutorial on using our code and

532
00:15:33,519 --> 00:15:34,639
detailed error analysis are all

533
00:15:34,639 --> 00:15:37,040
available on github and more results are

534
00:15:37,040 --> 00:15:38,160
in the paper with that i'll take any

535
00:15:38,160 --> 00:15:40,640
questions thank you very much

536
00:15:40,640 --> 00:15:47,529
[Applause]

537
00:15:52,639 --> 00:15:54,240
awesome thank you very much max so i

538
00:15:54,240 --> 00:15:56,399
just got a message from uh from our

539
00:15:56,399 --> 00:15:58,639
program chairs that uh we we should try

540
00:15:58,639 --> 00:16:00,959
our best to conclude this session by the

541
00:16:00,959 --> 00:16:03,279
original planned uh end time because the

542
00:16:03,279 --> 00:16:05,279
online platform will kill will kill

543
00:16:05,279 --> 00:16:06,480
their connection

544
00:16:06,480 --> 00:16:08,720
uh at

545
00:16:08,720 --> 00:16:10,639
10 50 a.m

546
00:16:10,639 --> 00:16:12,480
sharp you know this is not what we would

547
00:16:12,480 --> 00:16:14,560
expect in 2022 but here here we are so

548
00:16:14,560 --> 00:16:17,279
what can we do uh because because of

549
00:16:17,279 --> 00:16:19,600
that we will need to keep our uh

550
00:16:19,600 --> 00:16:21,199
question and answer sessions kind of

551
00:16:21,199 --> 00:16:23,759
short so if you have questions please

552
00:16:23,759 --> 00:16:25,680
line up behind

553
00:16:25,680 --> 00:16:28,079
behind the microphone i will take

554
00:16:28,079 --> 00:16:30,000
maybe two questions from from on-site

555
00:16:30,000 --> 00:16:32,160
and then two from the online

556
00:16:32,160 --> 00:16:34,079
so since no one is there i'm going to

557
00:16:34,079 --> 00:16:35,360
start from the online questions there

558
00:16:35,360 --> 00:16:37,120
are a lot by the way you know impressive

559
00:16:37,120 --> 00:16:38,320
work this is why people are asking

560
00:16:38,320 --> 00:16:39,440
questions

561
00:16:39,440 --> 00:16:40,480
so

562
00:16:40,480 --> 00:16:42,959
the first one uh can you please provide

563
00:16:42,959 --> 00:16:45,199
some insights in terms of why the linear

564
00:16:45,199 --> 00:16:48,480
and uh neural identical uh neural fs

565
00:16:48,480 --> 00:16:51,199
amps are identical yeah i i think it has

566
00:16:51,199 --> 00:16:52,880
to do with our heuristic extraction

567
00:16:52,880 --> 00:16:54,959
algorithm um so

568
00:16:54,959 --> 00:16:56,480
i think that essentially the differences

569
00:16:56,480 --> 00:16:58,639
in the intermediary representations were

570
00:16:58,639 --> 00:17:00,959
things that are uh

571
00:17:00,959 --> 00:17:02,880
are not meaningful in terms of our

572
00:17:02,880 --> 00:17:05,039
extraction algorithm and by the way uh

573
00:17:05,039 --> 00:17:06,240
for people watching this i think that

574
00:17:06,240 --> 00:17:07,359
our extraction algorithm is one of the

575
00:17:07,359 --> 00:17:08,720
easiest things to improve on for what we

576
00:17:08,720 --> 00:17:10,400
did so i would encourage anybody who

577
00:17:10,400 --> 00:17:11,760
wants to work on this type of thing to

578
00:17:11,760 --> 00:17:13,599
think about maybe how to improve on the

579
00:17:13,599 --> 00:17:16,240
extraction algorithm

580
00:17:16,240 --> 00:17:18,799
awesome thank you no no questions from

581
00:17:18,799 --> 00:17:22,160
on-site okay so uh the next question um

582
00:17:22,160 --> 00:17:24,559
does your research also analyze figures

583
00:17:24,559 --> 00:17:26,400
uh and or diagrams in this

584
00:17:26,400 --> 00:17:27,839
specifications

585
00:17:27,839 --> 00:17:29,440
no that's a great question um we

586
00:17:29,440 --> 00:17:30,400
discussed it it's actually an

587
00:17:30,400 --> 00:17:32,720
interesting problem in nlp to kind of

588
00:17:32,720 --> 00:17:34,720
richly understand what what diagrams

589
00:17:34,720 --> 00:17:35,520
mean

590
00:17:35,520 --> 00:17:37,200
at one point i played around with a

591
00:17:37,200 --> 00:17:38,640
little hacky script that would extract

592
00:17:38,640 --> 00:17:40,960
an fsm from an ascii diagram but it's

593
00:17:40,960 --> 00:17:42,400
hard to generalize something such a

594
00:17:42,400 --> 00:17:44,320
thing in a really scientific manner

595
00:17:44,320 --> 00:17:45,360
especially when you can have many

596
00:17:45,360 --> 00:17:46,960
different types of diagrams like control

597
00:17:46,960 --> 00:17:48,320
flow charts and stuff like this but it

598
00:17:48,320 --> 00:17:50,320
is an interesting problem for sure

599
00:17:50,320 --> 00:17:52,480
awesome fancy uh no more questions from

600
00:17:52,480 --> 00:17:54,480
on-site

601
00:17:54,480 --> 00:17:55,440
three

602
00:17:55,440 --> 00:17:57,440
two okay one

603
00:17:57,440 --> 00:18:00,480
awesome i'm sorry two uh more

604
00:18:00,480 --> 00:18:02,960
to people who are asking questions um

605
00:18:02,960 --> 00:18:05,039
on helping so if you can can you please

606
00:18:05,039 --> 00:18:06,240
attend to those questions afterwards

607
00:18:06,240 --> 00:18:07,520
absolutely thank you very much thank you

608
00:18:07,520 --> 00:18:09,500
very much

609
00:18:09,500 --> 00:18:11,759
[Applause]

