1
00:00:00,399 --> 00:00:01,199
great

2
00:00:01,199 --> 00:00:03,439
okay hello everyone my name is yusuf and

3
00:00:03,439 --> 00:00:05,200
i'll be presenting spec hammer combining

4
00:00:05,200 --> 00:00:06,480
spectre and roarhammer for new

5
00:00:06,480 --> 00:00:08,400
speculative attacks this work was done

6
00:00:08,400 --> 00:00:10,639
in collaboration with andrew kong ingop

7
00:00:10,639 --> 00:00:14,400
kang daniel genkin and congression

8
00:00:14,400 --> 00:00:16,960
so

9
00:00:16,960 --> 00:00:19,600
as we just heard the specter attacks

10
00:00:19,600 --> 00:00:21,279
revealed a new class of attacks

11
00:00:21,279 --> 00:00:23,359
demonstrating the inherent insecurity of

12
00:00:23,359 --> 00:00:25,680
speculative execution showing how branch

13
00:00:25,680 --> 00:00:27,760
prediction can be exploited in order to

14
00:00:27,760 --> 00:00:29,840
arbitrarily leak values from the

15
00:00:29,840 --> 00:00:32,238
victim's address space

16
00:00:32,238 --> 00:00:34,239
for example let's assume the following

17
00:00:34,239 --> 00:00:36,079
behavior and victim code

18
00:00:36,079 --> 00:00:37,520
a nested are accessed within a

19
00:00:37,520 --> 00:00:39,440
conditional statement where the attacker

20
00:00:39,440 --> 00:00:42,079
has control over the variable x

21
00:00:42,079 --> 00:00:43,440
and we might think that all of our

22
00:00:43,440 --> 00:00:45,760
accesses must be inbounds because this

23
00:00:45,760 --> 00:00:47,280
conditional statement acts as a bounce

24
00:00:47,280 --> 00:00:48,559
check

25
00:00:48,559 --> 00:00:50,480
but specter showed that we can send in

26
00:00:50,480 --> 00:00:52,320
values of x that will train the branch

27
00:00:52,320 --> 00:00:54,640
predictor to predict that the next value

28
00:00:54,640 --> 00:00:56,079
of x will be in bounds and that the

29
00:00:56,079 --> 00:00:59,520
branch should be taken from here we can

30
00:00:59,520 --> 00:01:02,160
send in an out of bounds value of x

31
00:01:02,160 --> 00:01:03,359
causing us to enter a state of

32
00:01:03,359 --> 00:01:05,280
speculative execution allowing us to

33
00:01:05,280 --> 00:01:08,000
touch this out-of-bound secret data

34
00:01:08,000 --> 00:01:09,600
here the secret will be used to index

35
00:01:09,600 --> 00:01:11,040
into another array

36
00:01:11,040 --> 00:01:12,479
and we might be thinking that this is

37
00:01:12,479 --> 00:01:14,000
clearly a misprediction so everything

38
00:01:14,000 --> 00:01:15,600
will be undone

39
00:01:15,600 --> 00:01:16,880
but spectre showed that there are

40
00:01:16,880 --> 00:01:18,799
microarchitectural side effects that

41
00:01:18,799 --> 00:01:20,400
will remain even after we resolve the

42
00:01:20,400 --> 00:01:21,360
branch

43
00:01:21,360 --> 00:01:23,920
in particular data will be pulled from

44
00:01:23,920 --> 00:01:26,159
this array into the cache and now we

45
00:01:26,159 --> 00:01:27,600
have secret dependent data sitting in

46
00:01:27,600 --> 00:01:29,040
the cache

47
00:01:29,040 --> 00:01:31,520
and once we resolve the branch

48
00:01:31,520 --> 00:01:33,200
all the other accesses will be undone

49
00:01:33,200 --> 00:01:34,960
and nothing will be committed but the

50
00:01:34,960 --> 00:01:36,960
data will remain there in the cache

51
00:01:36,960 --> 00:01:39,439
from here we can use a side channel

52
00:01:39,439 --> 00:01:41,119
where we access different lines in the

53
00:01:41,119 --> 00:01:42,240
cache

54
00:01:42,240 --> 00:01:44,720
timing our accesses and the timing

55
00:01:44,720 --> 00:01:46,640
differences will reveal which addresses

56
00:01:46,640 --> 00:01:48,640
were recently accessed

57
00:01:48,640 --> 00:01:50,240
and since our most recent access was

58
00:01:50,240 --> 00:01:52,000
dependent on secret data this can be

59
00:01:52,000 --> 00:01:54,720
used to retrieve the secret showing how

60
00:01:54,720 --> 00:01:55,920
branch prediction allows us to

61
00:01:55,920 --> 00:01:57,920
arbitrarily read memory in the victim's

62
00:01:57,920 --> 00:01:59,759
address space

63
00:01:59,759 --> 00:02:02,159
now while this is powerful spectre does

64
00:02:02,159 --> 00:02:03,920
have a key limitation and that it

65
00:02:03,920 --> 00:02:05,520
requires the attacker to control the

66
00:02:05,520 --> 00:02:06,880
variable x

67
00:02:06,880 --> 00:02:09,520
for example suppose there is a gadget in

68
00:02:09,520 --> 00:02:11,599
the linux kernel that we want to exploit

69
00:02:11,599 --> 00:02:14,239
to arbitrarily read kernel values

70
00:02:14,239 --> 00:02:16,160
we require a syscall that allows us to

71
00:02:16,160 --> 00:02:18,640
pass in values of x as an argument to

72
00:02:18,640 --> 00:02:20,959
the syscall so that we can manipulate

73
00:02:20,959 --> 00:02:23,200
this gadget to arbitrarily read these

74
00:02:23,200 --> 00:02:24,959
values and target the secrets we want to

75
00:02:24,959 --> 00:02:26,959
target

76
00:02:26,959 --> 00:02:28,720
the reason why this is a limitation is

77
00:02:28,720 --> 00:02:30,800
that it allows for defenses that target

78
00:02:30,800 --> 00:02:32,480
this particular behavior

79
00:02:32,480 --> 00:02:34,879
as taint tracking defenses can look for

80
00:02:34,879 --> 00:02:36,480
cases where x is coming from an

81
00:02:36,480 --> 00:02:38,879
untrusted source and prevent speculation

82
00:02:38,879 --> 00:02:41,120
from occurring on this code for example

83
00:02:41,120 --> 00:02:42,879
by adding offenses

84
00:02:42,879 --> 00:02:45,360
and serializing the code

85
00:02:45,360 --> 00:02:46,319
now

86
00:02:46,319 --> 00:02:48,640
there are other cases of code in the

87
00:02:48,640 --> 00:02:51,680
kernel that we might be able to exploit

88
00:02:51,680 --> 00:02:54,319
as they contain this nested or access

89
00:02:54,319 --> 00:02:56,400
behavior within a conditional statement

90
00:02:56,400 --> 00:02:58,000
but the problem here is that other

91
00:02:58,000 --> 00:02:59,599
variables are completely controlled by

92
00:02:59,599 --> 00:03:01,440
the kernel they're considered completely

93
00:03:01,440 --> 00:03:03,360
trustworthy and we can't abuse them to

94
00:03:03,360 --> 00:03:05,760
arbitrarily target values in the kernel

95
00:03:05,760 --> 00:03:08,239
to leak them via specter

96
00:03:08,239 --> 00:03:10,560
and so we have no way of directly

97
00:03:10,560 --> 00:03:13,040
exploiting them for arbitrary reads

98
00:03:13,040 --> 00:03:14,560
what would be quite nice would be if we

99
00:03:14,560 --> 00:03:16,159
had a way to write to these kernel

100
00:03:16,159 --> 00:03:18,319
variables indirectly even though we

101
00:03:18,319 --> 00:03:20,239
aren't privileged users

102
00:03:20,239 --> 00:03:21,599
and it turns out there is another

103
00:03:21,599 --> 00:03:22,879
vulnerability that will let us do

104
00:03:22,879 --> 00:03:25,120
exactly that called row hammer

105
00:03:25,120 --> 00:03:27,040
this allows us to flip bits in memory

106
00:03:27,040 --> 00:03:29,040
that we don't have access to by rapidly

107
00:03:29,040 --> 00:03:31,680
accessing addresses that we do control

108
00:03:31,680 --> 00:03:33,280
and this paper explores what happens

109
00:03:33,280 --> 00:03:35,040
when we combine these two attacks and

110
00:03:35,040 --> 00:03:36,560
how we can use this to create a more

111
00:03:36,560 --> 00:03:39,040
flexible spectre attack

112
00:03:39,040 --> 00:03:40,400
so before i go into that i'll give a

113
00:03:40,400 --> 00:03:42,319
quick overview of row hammer

114
00:03:42,319 --> 00:03:44,080
this vulnerability takes advantage of

115
00:03:44,080 --> 00:03:45,760
the nature of d-ray

116
00:03:45,760 --> 00:03:47,599
in particular a dram array consists of

117
00:03:47,599 --> 00:03:50,080
many cells that each use a capacitor to

118
00:03:50,080 --> 00:03:51,920
store a bit value

119
00:03:51,920 --> 00:03:53,920
for example a fully charged capacitor

120
00:03:53,920 --> 00:03:55,360
might store a 1 and a discharge

121
00:03:55,360 --> 00:03:58,400
capacitor might store 0 or vice versa

122
00:03:58,400 --> 00:04:01,439
and any time we want to access dram

123
00:04:01,439 --> 00:04:04,560
we're going to temporarily discharge

124
00:04:04,560 --> 00:04:07,040
all the values in the capacitors in the

125
00:04:07,040 --> 00:04:08,959
corresponding row and then that charge

126
00:04:08,959 --> 00:04:10,959
will be immediately restored

127
00:04:10,959 --> 00:04:12,720
rowhammer will abuse this effect in

128
00:04:12,720 --> 00:04:15,200
order to flip this in the adjacent rows

129
00:04:15,200 --> 00:04:17,600
in particular if we alternate our axises

130
00:04:17,600 --> 00:04:20,000
between two rows that pinch a particular

131
00:04:20,000 --> 00:04:22,160
victim roll that we're targeting

132
00:04:22,160 --> 00:04:23,759
we're going to rapidly discharge and

133
00:04:23,759 --> 00:04:26,160
recharge these capacitors to the point

134
00:04:26,160 --> 00:04:28,160
that we will accelerate the leakage rate

135
00:04:28,160 --> 00:04:30,000
and adjacent capacitors

136
00:04:30,000 --> 00:04:31,440
and pull their charge below their

137
00:04:31,440 --> 00:04:34,240
threshold value flipping their value

138
00:04:34,240 --> 00:04:37,919
from one to zero or vice versa

139
00:04:37,919 --> 00:04:40,880
and so we can rapidly access rows in

140
00:04:40,880 --> 00:04:42,880
memory to hammer victim rows and flip

141
00:04:42,880 --> 00:04:44,639
their bits

142
00:04:44,639 --> 00:04:46,400
so now we would like to use this to

143
00:04:46,400 --> 00:04:48,240
execute a specter attack

144
00:04:48,240 --> 00:04:50,639
even without direct control over x so we

145
00:04:50,639 --> 00:04:52,240
assume similar behavior to what we had

146
00:04:52,240 --> 00:04:54,400
before this nested or excess within the

147
00:04:54,400 --> 00:04:56,000
conditional statement this time the

148
00:04:56,000 --> 00:04:58,639
attacker does not control x

149
00:04:58,639 --> 00:04:59,520
and

150
00:04:59,520 --> 00:05:01,280
we assume that if we call this victim

151
00:05:01,280 --> 00:05:02,639
enough times

152
00:05:02,639 --> 00:05:04,639
inbound values of x will be used

153
00:05:04,639 --> 00:05:05,759
frequently enough that the branch

154
00:05:05,759 --> 00:05:07,360
predictor will naturally be trained to

155
00:05:07,360 --> 00:05:09,039
predict that the next value of x will be

156
00:05:09,039 --> 00:05:10,639
in bounds as well and that the branch

157
00:05:10,639 --> 00:05:12,000
should be taken

158
00:05:12,000 --> 00:05:14,960
so for example suppose at some moment x

159
00:05:14,960 --> 00:05:16,720
is equal to 2

160
00:05:16,720 --> 00:05:19,039
and from here we want to hammer x to

161
00:05:19,039 --> 00:05:20,240
flip a bit

162
00:05:20,240 --> 00:05:23,360
and point us to the secret value

163
00:05:23,360 --> 00:05:24,720
and since the branch predictor has been

164
00:05:24,720 --> 00:05:25,840
trained we'll enter a state of

165
00:05:25,840 --> 00:05:27,520
speculative execution

166
00:05:27,520 --> 00:05:29,840
where a secret value is used to index

167
00:05:29,840 --> 00:05:31,440
into another array

168
00:05:31,440 --> 00:05:33,199
this value gets pulled into the cache

169
00:05:33,199 --> 00:05:34,720
and just like before we have secret

170
00:05:34,720 --> 00:05:36,320
dependent data sitting in the cache that

171
00:05:36,320 --> 00:05:38,000
will remain there even after the branch

172
00:05:38,000 --> 00:05:39,280
is resolved

173
00:05:39,280 --> 00:05:42,320
showing how we can run a spectre like

174
00:05:42,320 --> 00:05:43,840
exploit

175
00:05:43,840 --> 00:05:45,440
even when we don't have control over x

176
00:05:45,440 --> 00:05:48,320
thanks to row hammer

177
00:05:49,919 --> 00:05:50,800
so

178
00:05:50,800 --> 00:05:53,199
we ran a proof of concept attack

179
00:05:53,199 --> 00:05:55,440
where we controlled

180
00:05:55,440 --> 00:05:56,880
a thread

181
00:05:56,880 --> 00:05:58,319
that spawned a victim thread that

182
00:05:58,319 --> 00:06:00,240
contained this code of the nest editor

183
00:06:00,240 --> 00:06:02,160
access within the conditional statement

184
00:06:02,160 --> 00:06:04,000
and the attacker thread had no way of

185
00:06:04,000 --> 00:06:06,560
directly modifying the value of x

186
00:06:06,560 --> 00:06:07,759
so we

187
00:06:07,759 --> 00:06:10,560
use this to leak a stack canary since we

188
00:06:10,560 --> 00:06:12,160
just needed to flip a bit that pointed

189
00:06:12,160 --> 00:06:14,160
us just past the bounds of the stack

190
00:06:14,160 --> 00:06:16,080
that these arrays resided on leading us

191
00:06:16,080 --> 00:06:18,080
to point to the canary and we showed how

192
00:06:18,080 --> 00:06:20,080
we could leak this canary with 100

193
00:06:20,080 --> 00:06:22,720
accurate leakage at a rate of 8 bits per

194
00:06:22,720 --> 00:06:24,800
second

195
00:06:24,800 --> 00:06:25,600
now

196
00:06:25,600 --> 00:06:27,600
you might have noticed a key limitation

197
00:06:27,600 --> 00:06:29,440
with this which is that while we can

198
00:06:29,440 --> 00:06:31,039
point past the bounds of these arrays

199
00:06:31,039 --> 00:06:33,759
and target things like stack canaries

200
00:06:33,759 --> 00:06:36,000
we can only flip one bit at a time and

201
00:06:36,000 --> 00:06:37,919
so it becomes difficult to arbitrarily

202
00:06:37,919 --> 00:06:40,240
target data in victim memory

203
00:06:40,240 --> 00:06:41,840
in particular suppose that we flip this

204
00:06:41,840 --> 00:06:44,960
bit to point to this value a

205
00:06:44,960 --> 00:06:46,400
and now we want to leak a new value in

206
00:06:46,400 --> 00:06:48,319
memory so the first thing we have to do

207
00:06:48,319 --> 00:06:49,759
is find a new bit flip which will take

208
00:06:49,759 --> 00:06:50,639
time

209
00:06:50,639 --> 00:06:52,400
and additionally we can only flip the

210
00:06:52,400 --> 00:06:54,160
next most significant bit or the next

211
00:06:54,160 --> 00:06:56,240
least significant bit which is going to

212
00:06:56,240 --> 00:06:58,800
point to some distance away from a

213
00:06:58,800 --> 00:07:00,479
some power of 2 away

214
00:07:00,479 --> 00:07:01,919
and the next level you want to leak has

215
00:07:01,919 --> 00:07:03,919
to be another even more significant bit

216
00:07:03,919 --> 00:07:04,880
and we're going to be pushed even

217
00:07:04,880 --> 00:07:06,800
farther away and these distances will

218
00:07:06,800 --> 00:07:08,319
continue to increase

219
00:07:08,319 --> 00:07:10,400
every new bit we flip

220
00:07:10,400 --> 00:07:12,479
so there are gaps in what we can target

221
00:07:12,479 --> 00:07:14,240
and we don't have the same flexibility

222
00:07:14,240 --> 00:07:16,560
that spectre gave us of arbitrarily

223
00:07:16,560 --> 00:07:18,479
targeting any value in memory that we

224
00:07:18,479 --> 00:07:20,639
want to leak

225
00:07:20,639 --> 00:07:22,800
so to get around this issue we devised

226
00:07:22,800 --> 00:07:24,319
the triple gadget

227
00:07:24,319 --> 00:07:26,400
which has similar behavior to what we

228
00:07:26,400 --> 00:07:28,319
saw before except now we have a triple

229
00:07:28,319 --> 00:07:30,000
necessary access consisting of three

230
00:07:30,000 --> 00:07:32,080
arrays rather than two and just like

231
00:07:32,080 --> 00:07:34,080
before it's in a conditional statement

232
00:07:34,080 --> 00:07:38,000
where we have no direct control over x

233
00:07:38,000 --> 00:07:39,680
and the goal here is to show how we can

234
00:07:39,680 --> 00:07:41,599
use just one row hammer bit flip in

235
00:07:41,599 --> 00:07:43,840
order to arbitrarily target any value in

236
00:07:43,840 --> 00:07:45,360
victim memory

237
00:07:45,360 --> 00:07:47,120
so we begin like before where we call

238
00:07:47,120 --> 00:07:48,960
this victim code enough times to

239
00:07:48,960 --> 00:07:50,479
naturally train the branch predictor to

240
00:07:50,479 --> 00:07:52,800
predict that x will be in bounds

241
00:07:52,800 --> 00:07:55,199
and suppose again x is equal to 2.

242
00:07:55,199 --> 00:07:56,720
we'll now use row hammer to flip a bit

243
00:07:56,720 --> 00:07:58,800
and point out of bounds but instead of

244
00:07:58,800 --> 00:08:00,960
targeting the secret directly we want to

245
00:08:00,960 --> 00:08:03,199
target data that we control

246
00:08:03,199 --> 00:08:05,360
and we can set this value to be whatever

247
00:08:05,360 --> 00:08:06,960
we need such that when it's used to

248
00:08:06,960 --> 00:08:08,800
index into the next array

249
00:08:08,800 --> 00:08:11,199
it will point to the secret that we want

250
00:08:11,199 --> 00:08:12,560
to target

251
00:08:12,560 --> 00:08:14,240
and now just like before the secret is

252
00:08:14,240 --> 00:08:16,479
used to nx into another array

253
00:08:16,479 --> 00:08:18,240
this data will get pulled into the cache

254
00:08:18,240 --> 00:08:20,000
secret dependent data remaining in the

255
00:08:20,000 --> 00:08:21,520
cache allows us to leak it via side

256
00:08:21,520 --> 00:08:23,039
channel

257
00:08:23,039 --> 00:08:25,120
and so the advantage here is that we

258
00:08:25,120 --> 00:08:26,800
don't need to flip bits to point this

259
00:08:26,800 --> 00:08:29,039
directly to our secrets we just need a

260
00:08:29,039 --> 00:08:30,720
flip that will point us from the region

261
00:08:30,720 --> 00:08:33,360
of memory we should be inside of

262
00:08:33,360 --> 00:08:35,039
to this region of memory that contains

263
00:08:35,039 --> 00:08:37,039
data that we control

264
00:08:37,039 --> 00:08:39,440
and from here we can modify this value

265
00:08:39,440 --> 00:08:41,679
to point wherever memory we want

266
00:08:41,679 --> 00:08:43,519
allowing us to precisely target any

267
00:08:43,519 --> 00:08:46,320
value we want to leak

268
00:08:46,320 --> 00:08:48,720
now even this has a limitation which is

269
00:08:48,720 --> 00:08:50,720
that we do need a specific bit flip in

270
00:08:50,720 --> 00:08:52,399
order to get this to work

271
00:08:52,399 --> 00:08:54,399
for example using a simplified example

272
00:08:54,399 --> 00:08:55,920
where we're targeting the kernel and we

273
00:08:55,920 --> 00:08:58,560
have a gadget that resides in the kernel

274
00:08:58,560 --> 00:09:00,320
and say that we want to cause a bit flip

275
00:09:00,320 --> 00:09:02,000
that will point us to data that we

276
00:09:02,000 --> 00:09:04,160
control in user space

277
00:09:04,160 --> 00:09:06,000
so for example we might need to flip bit

278
00:09:06,000 --> 00:09:08,560
45 in order to

279
00:09:08,560 --> 00:09:10,080
reach this data

280
00:09:10,080 --> 00:09:12,320
the reason why this is a limitation

281
00:09:12,320 --> 00:09:13,519
is that

282
00:09:13,519 --> 00:09:15,839
rowhammer tends to vary from dim to dim

283
00:09:15,839 --> 00:09:17,440
and so different addresses will be

284
00:09:17,440 --> 00:09:19,279
vulnerable on different dimms even if

285
00:09:19,279 --> 00:09:21,360
they're of the same model maker

286
00:09:21,360 --> 00:09:22,720
manufacturer

287
00:09:22,720 --> 00:09:24,720
and so you just have to hammer many many

288
00:09:24,720 --> 00:09:28,080
addresses on whatever dim your victim is

289
00:09:28,080 --> 00:09:29,680
in order to find where the bit flips you

290
00:09:29,680 --> 00:09:32,000
need are and to find the flip at the

291
00:09:32,000 --> 00:09:34,160
particular address and offset that you

292
00:09:34,160 --> 00:09:36,640
need

293
00:09:36,640 --> 00:09:37,839
and so

294
00:09:37,839 --> 00:09:40,320
at this point we attempted to hammer the

295
00:09:40,320 --> 00:09:41,680
dims that we had

296
00:09:41,680 --> 00:09:43,760
in order to try

297
00:09:43,760 --> 00:09:46,560
finding the flips that we needed

298
00:09:46,560 --> 00:09:48,560
but it took a prohibitively long amount

299
00:09:48,560 --> 00:09:50,800
of time to find these flips

300
00:09:50,800 --> 00:09:52,000
and so we thought that it wouldn't be

301
00:09:52,000 --> 00:09:54,160
practical to mount this attack

302
00:09:54,160 --> 00:09:55,760
and so at this point we noticed a key

303
00:09:55,760 --> 00:09:58,160
oversight in existing code

304
00:09:58,160 --> 00:10:00,320
that was masking many of the flips that

305
00:10:00,320 --> 00:10:02,399
were actually happening in memory in

306
00:10:02,399 --> 00:10:04,640
particular uh what the prior work would

307
00:10:04,640 --> 00:10:06,640
do on the prior procedures and the code

308
00:10:06,640 --> 00:10:08,240
attached to this prior work

309
00:10:08,240 --> 00:10:10,240
it would begin by initializing memory uh

310
00:10:10,240 --> 00:10:12,160
with all zeros or all ones

311
00:10:12,160 --> 00:10:13,600
which would cause this data to get

312
00:10:13,600 --> 00:10:15,760
pulled into the cache

313
00:10:15,760 --> 00:10:18,000
and from here

314
00:10:18,000 --> 00:10:19,680
we then hammer memory to induce split

315
00:10:19,680 --> 00:10:21,519
flips in dram

316
00:10:21,519 --> 00:10:23,360
and then we want to read memory to look

317
00:10:23,360 --> 00:10:24,880
for our flips so in this case we

318
00:10:24,880 --> 00:10:26,560
initialize with all zeros so if we see

319
00:10:26,560 --> 00:10:28,240
any ones we know we had a flip and we

320
00:10:28,240 --> 00:10:30,560
know that that address is flippy

321
00:10:30,560 --> 00:10:32,480
in this case we only see zero so i guess

322
00:10:32,480 --> 00:10:33,839
we didn't have any flips and we'll just

323
00:10:33,839 --> 00:10:34,800
move on

324
00:10:34,800 --> 00:10:36,800
and there lies the problem in the prior

325
00:10:36,800 --> 00:10:39,040
work which is that all of this

326
00:10:39,040 --> 00:10:41,200
initialized data written to memory sits

327
00:10:41,200 --> 00:10:43,279
in the cache and when we come to read

328
00:10:43,279 --> 00:10:45,120
memory to check for our flips we're just

329
00:10:45,120 --> 00:10:47,920
checking our cached initialization data

330
00:10:47,920 --> 00:10:48,880
so

331
00:10:48,880 --> 00:10:50,959
we end up missing flips

332
00:10:50,959 --> 00:10:53,120
so we made a simple modification where

333
00:10:53,120 --> 00:10:55,519
we initialize memory again by writing

334
00:10:55,519 --> 00:10:57,760
all zeros in this case causing this data

335
00:10:57,760 --> 00:10:59,600
to get pulled into the cache

336
00:10:59,600 --> 00:11:00,959
now we flush

337
00:11:00,959 --> 00:11:02,800
these values pushing them back into

338
00:11:02,800 --> 00:11:04,880
memory ensuring that our next axis will

339
00:11:04,880 --> 00:11:06,320
be a cache miss

340
00:11:06,320 --> 00:11:08,000
we do our hammering to induce our bit

341
00:11:08,000 --> 00:11:09,760
flips

342
00:11:09,760 --> 00:11:11,440
and now when we read memory to check for

343
00:11:11,440 --> 00:11:14,399
flips we're going to have a cache miss

344
00:11:14,399 --> 00:11:16,000
ensuring that we can see any flips that

345
00:11:16,000 --> 00:11:17,600
happen in dram

346
00:11:17,600 --> 00:11:19,920
and so we ran some tests on our dimms

347
00:11:19,920 --> 00:11:21,680
using prior work and using our own

348
00:11:21,680 --> 00:11:24,240
modified code over a two hour period and

349
00:11:24,240 --> 00:11:25,839
counting the number of unique addresses

350
00:11:25,839 --> 00:11:27,519
that had bit flips

351
00:11:27,519 --> 00:11:29,040
on the

352
00:11:29,040 --> 00:11:32,560
prior work we were able to find 38 flips

353
00:11:32,560 --> 00:11:34,240
over two hours and when we added these

354
00:11:34,240 --> 00:11:36,560
cash flushes we found over 11 000 flips

355
00:11:36,560 --> 00:11:38,320
within the same time window

356
00:11:38,320 --> 00:11:39,920
and so this showed that the dims that we

357
00:11:39,920 --> 00:11:41,120
were working with were way more

358
00:11:41,120 --> 00:11:42,320
vulnerable to rowhammer than we

359
00:11:42,320 --> 00:11:46,800
initially thought all thanks to this

360
00:11:46,800 --> 00:11:48,399
cash flushing issue

361
00:11:48,399 --> 00:11:50,399
we ran this test on multiple dimms ddr3

362
00:11:50,399 --> 00:11:52,639
and ddr4 and we found similar results in

363
00:11:52,639 --> 00:11:54,959
all cases you can see the full table in

364
00:11:54,959 --> 00:11:56,720
the paper

365
00:11:56,720 --> 00:11:58,399
so at this point now we have plenty of

366
00:11:58,399 --> 00:12:00,800
flips to work with and so we're ready to

367
00:12:00,800 --> 00:12:02,800
run a triple gadget proof of concept

368
00:12:02,800 --> 00:12:03,680
attack

369
00:12:03,680 --> 00:12:05,519
in this case we added a syscall to the

370
00:12:05,519 --> 00:12:07,120
linux kernel that contained this triple

371
00:12:07,120 --> 00:12:08,560
gadget behavior

372
00:12:08,560 --> 00:12:11,360
and our goal was to dump kernel data

373
00:12:11,360 --> 00:12:13,040
and so again we call this this call

374
00:12:13,040 --> 00:12:14,240
enough times to train the branch

375
00:12:14,240 --> 00:12:15,839
predictor as needed

376
00:12:15,839 --> 00:12:18,240
and from here we flip a bit that's going

377
00:12:18,240 --> 00:12:20,800
to point us to data that we control

378
00:12:20,800 --> 00:12:22,720
this attacker control data then points

379
00:12:22,720 --> 00:12:24,959
to the secret as we described before and

380
00:12:24,959 --> 00:12:27,360
then secret index to array

381
00:12:27,360 --> 00:12:28,959
that will cause secret dependent data to

382
00:12:28,959 --> 00:12:30,399
be pulled into the cache the cache side

383
00:12:30,399 --> 00:12:33,120
channel gives us our secret

384
00:12:33,120 --> 00:12:35,279
and the goal here was to leak a string

385
00:12:35,279 --> 00:12:37,600
that sat as a global variable outside of

386
00:12:37,600 --> 00:12:39,519
the bounds of these arrays we're able to

387
00:12:39,519 --> 00:12:42,000
leak values from this string with 100

388
00:12:42,000 --> 00:12:44,560
accuracy at a rate of 24 bits per second

389
00:12:44,560 --> 00:12:48,240
on ddr3 and 6 bits per minute on ddr4

390
00:12:48,240 --> 00:12:49,360
so

391
00:12:49,360 --> 00:12:51,360
now the question remains of how does

392
00:12:51,360 --> 00:12:52,959
this affect the presence of gadgets in

393
00:12:52,959 --> 00:12:54,639
real world code

394
00:12:54,639 --> 00:12:56,959
so we used an early gadget search tool

395
00:12:56,959 --> 00:12:59,360
that was an extension of smash which was

396
00:12:59,360 --> 00:13:01,760
a tool designed to find security bugs in

397
00:13:01,760 --> 00:13:03,680
the linux kernel

398
00:13:03,680 --> 00:13:06,560
and this tool finds gadgets by looking

399
00:13:06,560 --> 00:13:08,480
for snippets of code where there are

400
00:13:08,480 --> 00:13:10,240
nested array accesses

401
00:13:10,240 --> 00:13:13,120
where an unprivileged user has control

402
00:13:13,120 --> 00:13:14,800
over the value x

403
00:13:14,800 --> 00:13:16,720
we extended this tool to look for triple

404
00:13:16,720 --> 00:13:18,079
gadgets with the same condition of

405
00:13:18,079 --> 00:13:19,680
controlling x

406
00:13:19,680 --> 00:13:21,360
as well as

407
00:13:21,360 --> 00:13:24,240
double gadgets where this variable was

408
00:13:24,240 --> 00:13:26,320
unmodifiable by unprivileged users so in

409
00:13:26,320 --> 00:13:28,000
this case the variable a

410
00:13:28,000 --> 00:13:29,600
and triple gadgets with the same

411
00:13:29,600 --> 00:13:31,839
unmodifiable condition

412
00:13:31,839 --> 00:13:34,320
so the tool reported in the case of

413
00:13:34,320 --> 00:13:36,720
these user modifiable gadgets 100 double

414
00:13:36,720 --> 00:13:38,720
gadgets and two triple gadgets

415
00:13:38,720 --> 00:13:40,480
and when we remove this restriction that

416
00:13:40,480 --> 00:13:43,120
the attacker has to control the variable

417
00:13:43,120 --> 00:13:45,120
this number increased to 20 000 double

418
00:13:45,120 --> 00:13:47,600
gadgets and 170 triple gadgets

419
00:13:47,600 --> 00:13:49,760
now this was an early tool

420
00:13:49,760 --> 00:13:51,680
and so it is prone to produce false

421
00:13:51,680 --> 00:13:53,680
positives but at the same time we don't

422
00:13:53,680 --> 00:13:55,120
take this number as a ceiling of the

423
00:13:55,120 --> 00:13:56,560
number of gadgets

424
00:13:56,560 --> 00:13:59,600
that are newly exploitable in the kernel

425
00:13:59,600 --> 00:14:00,639
as

426
00:14:00,639 --> 00:14:02,240
we were able to find false negatives as

427
00:14:02,240 --> 00:14:03,040
well

428
00:14:03,040 --> 00:14:04,959
so we checked the linux kernel code by

429
00:14:04,959 --> 00:14:07,279
hand and quickly found a case in page

430
00:14:07,279 --> 00:14:09,920
alec c which is responsible for handling

431
00:14:09,920 --> 00:14:13,120
physical page allocation in the kernel

432
00:14:13,120 --> 00:14:16,079
and in this case we have a triple nested

433
00:14:16,079 --> 00:14:17,519
pointed reference

434
00:14:17,519 --> 00:14:19,279
where this struct pointer here gets

435
00:14:19,279 --> 00:14:20,560
dereferenced

436
00:14:20,560 --> 00:14:22,240
and the result of that the reference is

437
00:14:22,240 --> 00:14:24,079
used for another dereference and the

438
00:14:24,079 --> 00:14:26,720
result of that is used as an array index

439
00:14:26,720 --> 00:14:27,839
variable

440
00:14:27,839 --> 00:14:29,680
and so as far as spectre is concerned

441
00:14:29,680 --> 00:14:31,839
this triple nested point to dereference

442
00:14:31,839 --> 00:14:33,839
is the exact same as a triple nested

443
00:14:33,839 --> 00:14:35,040
array access

444
00:14:35,040 --> 00:14:37,199
and we did indeed verify that if we

445
00:14:37,199 --> 00:14:39,199
could flip this value here

446
00:14:39,199 --> 00:14:40,480
we can

447
00:14:40,480 --> 00:14:42,560
use this vector leakage to target

448
00:14:42,560 --> 00:14:46,320
arbitrary values in the linux kernel

449
00:14:46,320 --> 00:14:47,839
and so

450
00:14:47,839 --> 00:14:50,320
this shows that we need the

451
00:14:50,320 --> 00:14:52,160
development of a tool that can more

452
00:14:52,160 --> 00:14:53,680
precisely find these gadgets that are

453
00:14:53,680 --> 00:14:54,880
exploitable

454
00:14:54,880 --> 00:14:56,399
and we leave the development of such a

455
00:14:56,399 --> 00:14:58,720
tool for future work

456
00:14:58,720 --> 00:15:00,959
so in conclusion we relaxed a key

457
00:15:00,959 --> 00:15:02,720
requirement of specter v1 that the

458
00:15:02,720 --> 00:15:04,800
attacker has to have control over the

459
00:15:04,800 --> 00:15:06,720
array offset variable

460
00:15:06,720 --> 00:15:08,240
this led us to find new gadgets in the

461
00:15:08,240 --> 00:15:10,079
kernel and we demonstrated proof of

462
00:15:10,079 --> 00:15:12,320
concept attacks with leakage rates of 24

463
00:15:12,320 --> 00:15:15,360
bits per second and 6 bits per minute

464
00:15:15,360 --> 00:15:18,720
we also found an oversight in existing

465
00:15:18,720 --> 00:15:21,040
row hammer work that was masking many of

466
00:15:21,040 --> 00:15:22,160
the bit flips that were occurring in

467
00:15:22,160 --> 00:15:23,760
dram

468
00:15:23,760 --> 00:15:25,360
and finally while i didn't discuss it in

469
00:15:25,360 --> 00:15:26,399
this presentation

470
00:15:26,399 --> 00:15:28,160
in the paper we show a new kernel stack

471
00:15:28,160 --> 00:15:30,399
massaging technique that we use to flip

472
00:15:30,399 --> 00:15:32,959
bits in the kernel stack

473
00:15:32,959 --> 00:15:34,720
and while this was required for this

474
00:15:34,720 --> 00:15:36,560
attack this could be useful for any

475
00:15:36,560 --> 00:15:38,320
future or hammer work that also wants to

476
00:15:38,320 --> 00:15:40,880
target kernel stack variables

477
00:15:40,880 --> 00:15:43,199
thank you for your time and attention

478
00:15:43,199 --> 00:15:44,960
are there any questions

479
00:15:44,960 --> 00:15:51,600
[Applause]

480
00:15:51,600 --> 00:15:52,839
all right any

481
00:15:52,839 --> 00:15:55,199
questions okay we have a couple of three

482
00:15:55,199 --> 00:15:58,000
questions okay

483
00:15:58,480 --> 00:16:00,959
hi andrew myers from cornell so this is

484
00:16:00,959 --> 00:16:02,240
uh pretty fun

485
00:16:02,240 --> 00:16:03,519
um

486
00:16:03,519 --> 00:16:04,959
the you've reported that you found new

487
00:16:04,959 --> 00:16:06,800
kernel gadgets but then you said you had

488
00:16:06,800 --> 00:16:09,759
false positives yes did you think about

489
00:16:09,759 --> 00:16:11,519
randomly sampling them so you get a

490
00:16:11,519 --> 00:16:12,880
confidence interval on the number of

491
00:16:12,880 --> 00:16:15,440
kernel gadgets uh no we did not randomly

492
00:16:15,440 --> 00:16:18,320
sample them um we did just make attempts

493
00:16:18,320 --> 00:16:20,160
at exploiting them

494
00:16:20,160 --> 00:16:22,320
and most of the ones that we ran into

495
00:16:22,320 --> 00:16:23,600
there were specific issues that

496
00:16:23,600 --> 00:16:26,000
prevented from running exploits on them

497
00:16:26,000 --> 00:16:27,759
and we decided that we would just need a

498
00:16:27,759 --> 00:16:30,240
better tool in order to

499
00:16:30,240 --> 00:16:32,399
find gadgets that we could exploit

500
00:16:32,399 --> 00:16:34,240
and it seems that

501
00:16:34,240 --> 00:16:35,920
developing such a tool is still an open

502
00:16:35,920 --> 00:16:38,639
problem and so we leave that for future

503
00:16:38,639 --> 00:16:41,279
work okay

504
00:16:44,480 --> 00:16:46,720
thank you for your amazing

505
00:16:46,720 --> 00:16:47,519
talk

506
00:16:47,519 --> 00:16:50,240
i had this question how are you ensuring

507
00:16:50,240 --> 00:16:53,040
uh that x is sandwiched between two

508
00:16:53,040 --> 00:16:55,120
aggressor rows also

509
00:16:55,120 --> 00:16:58,160
how are you ensuring that x is in a

510
00:16:58,160 --> 00:17:00,800
vulnerable location of the demo yes so

511
00:17:00,800 --> 00:17:02,959
the one word answer is memory massaging

512
00:17:02,959 --> 00:17:04,640
which was a big component of the attack

513
00:17:04,640 --> 00:17:07,359
and of the paper

514
00:17:07,359 --> 00:17:10,400
the quick answer

515
00:17:10,400 --> 00:17:13,039
i'll try to explain it quickly is uh

516
00:17:13,039 --> 00:17:14,079
that

517
00:17:14,079 --> 00:17:16,880
you start by hammering many addresses

518
00:17:16,880 --> 00:17:19,520
and you're going to find an address that

519
00:17:19,520 --> 00:17:22,079
flips when you control two addresses

520
00:17:22,079 --> 00:17:24,079
and so at that point you know that you

521
00:17:24,079 --> 00:17:25,679
have this flippy page that you can

522
00:17:25,679 --> 00:17:27,199
reasonably produce

523
00:17:27,199 --> 00:17:28,640
bit flips in

524
00:17:28,640 --> 00:17:31,760
and now you need to

525
00:17:31,760 --> 00:17:34,480
get the victim to use that flippy page

526
00:17:34,480 --> 00:17:36,160
and keep control over your aggressor

527
00:17:36,160 --> 00:17:37,679
pages so that when you hammer them you

528
00:17:37,679 --> 00:17:40,160
can induce flips in that victim variable

529
00:17:40,160 --> 00:17:41,360
and so

530
00:17:41,360 --> 00:17:43,679
you would like to force the victim

531
00:17:43,679 --> 00:17:44,840
to

532
00:17:44,840 --> 00:17:46,400
uh

533
00:17:46,400 --> 00:17:48,080
allocate that page when you unmap it

534
00:17:48,080 --> 00:17:50,400
from memory the problem is that the pool

535
00:17:50,400 --> 00:17:52,640
of free pages is full of free pages and

536
00:17:52,640 --> 00:17:54,400
so there's a low chance that it's going

537
00:17:54,400 --> 00:17:57,280
to grab that 150 page so the basic idea

538
00:17:57,280 --> 00:17:59,679
is that you strip memory of all of the

539
00:17:59,679 --> 00:18:02,320
free pages and only free that one flippy

540
00:18:02,320 --> 00:18:04,400
page so that next time when you force

541
00:18:04,400 --> 00:18:06,240
the victim to make its allocation it

542
00:18:06,240 --> 00:18:08,080
will grab that flippy page and then when

543
00:18:08,080 --> 00:18:09,200
you hammer

544
00:18:09,200 --> 00:18:11,200
the pages that you do control you can do

545
00:18:11,200 --> 00:18:13,120
slips in that variable

546
00:18:13,120 --> 00:18:15,039
quick question there aren't you leaving

547
00:18:15,039 --> 00:18:17,600
a footprint kind of thing by allocating

548
00:18:17,600 --> 00:18:20,559
so many pages for the attacker yeah so

549
00:18:20,559 --> 00:18:22,799
we we did demonstrate um our proof of

550
00:18:22,799 --> 00:18:25,440
concepts with nothing else running and

551
00:18:25,440 --> 00:18:26,640
um

552
00:18:26,640 --> 00:18:28,000
assuming that

553
00:18:28,000 --> 00:18:29,360
nothing was going to try to track the

554
00:18:29,360 --> 00:18:31,120
suspicious behavior of many pages being

555
00:18:31,120 --> 00:18:33,840
allocated so that is a good point um we

556
00:18:33,840 --> 00:18:36,559
don't account for that in this work but

557
00:18:36,559 --> 00:18:38,480
maybe future memory massaging procedures

558
00:18:38,480 --> 00:18:40,559
could explore something that's more

559
00:18:40,559 --> 00:18:44,320
discreet thank you yep

560
00:18:45,679 --> 00:18:47,760
hey thanks for the great talk uh anish

561
00:18:47,760 --> 00:18:50,640
from georgia tech so uh i noticed that

562
00:18:50,640 --> 00:18:51,440
the

563
00:18:51,440 --> 00:18:52,960
rate of

564
00:18:52,960 --> 00:18:54,799
the bandwidth of your attack was higher

565
00:18:54,799 --> 00:18:57,600
on ddr3 compared to ddr4 even though

566
00:18:57,600 --> 00:18:59,520
from what we know ddr4 is usually more

567
00:18:59,520 --> 00:19:01,440
vulnerable so do you have any insights

568
00:19:01,440 --> 00:19:05,760
on why that might be yeah so on ddr4 we

569
00:19:05,760 --> 00:19:06,510
based our

570
00:19:06,510 --> 00:19:08,320
[Music]

571
00:19:08,320 --> 00:19:10,880
technique on trespass which uses a

572
00:19:10,880 --> 00:19:13,200
multi-sided raw hammering approach

573
00:19:13,200 --> 00:19:15,520
and on our dimms we need a 10-sided

574
00:19:15,520 --> 00:19:18,320
hammering to induce split flips

575
00:19:18,320 --> 00:19:21,440
and so there's a race condition when

576
00:19:21,440 --> 00:19:23,440
combining our hammer inspector which is

577
00:19:23,440 --> 00:19:24,960
that the wrench could be resolved before

578
00:19:24,960 --> 00:19:27,039
you have the chance to flip bits and so

579
00:19:27,039 --> 00:19:29,360
sometimes we would run our attack and we

580
00:19:29,360 --> 00:19:30,559
wouldn't see anything on the side

581
00:19:30,559 --> 00:19:31,600
channel

582
00:19:31,600 --> 00:19:32,960
and so we would have to run it

583
00:19:32,960 --> 00:19:35,200
repeatedly before we could observe the

584
00:19:35,200 --> 00:19:37,600
leakage and so those repeated runs made

585
00:19:37,600 --> 00:19:39,200
it so that we could leak data at a

586
00:19:39,200 --> 00:19:40,480
slower rate

587
00:19:40,480 --> 00:19:43,760
yeah that that makes sense

588
00:19:43,760 --> 00:19:45,600
uh yeah thank you for the great talk i

589
00:19:45,600 --> 00:19:47,760
was wondering in the threat model where

590
00:19:47,760 --> 00:19:50,080
an attacker is able to induce bits to

591
00:19:50,080 --> 00:19:54,000
flip right what is the reasoning to use

592
00:19:54,000 --> 00:19:57,919
spectra as a vector instead of different

593
00:19:57,919 --> 00:19:59,520
ways of attacking right like the pt

594
00:19:59,520 --> 00:20:01,039
exploit or

595
00:20:01,039 --> 00:20:03,360
binary etc uh so

596
00:20:03,360 --> 00:20:06,000
for example if you want to target linux

597
00:20:06,000 --> 00:20:07,919
kernel code like this and you induce

598
00:20:07,919 --> 00:20:09,679
this bit flip

599
00:20:09,679 --> 00:20:10,720
you

600
00:20:10,720 --> 00:20:12,400
end up with behavior in many cases that

601
00:20:12,400 --> 00:20:14,000
will just crash the kernel for example

602
00:20:14,000 --> 00:20:15,360
if this is trying to allocate physical

603
00:20:15,360 --> 00:20:18,720
pages and it points somewhere crazy then

604
00:20:18,720 --> 00:20:20,880
the kernel will panic and crash

605
00:20:20,880 --> 00:20:22,640
so if you hide it inside of this

606
00:20:22,640 --> 00:20:24,720
misprediction then you have the freedom

607
00:20:24,720 --> 00:20:26,720
to do whatever you want as long as you

608
00:20:26,720 --> 00:20:28,400
can fit it within that window and still

609
00:20:28,400 --> 00:20:29,919
exit gracefully

610
00:20:29,919 --> 00:20:31,679
okay i understand so the concept is that

611
00:20:31,679 --> 00:20:33,919
vector gives us a more reliable maybe

612
00:20:33,919 --> 00:20:37,600
more less detectable way of exploiting

613
00:20:37,600 --> 00:20:39,200
less detectable but also just more

614
00:20:39,200 --> 00:20:41,200
flexibility in that you can grab these

615
00:20:41,200 --> 00:20:43,200
values without causing a kernel crash if

616
00:20:43,200 --> 00:20:44,960
you are targeting the kernel for example

617
00:20:44,960 --> 00:20:47,360
okay thank you very much

618
00:20:47,360 --> 00:20:48,799
all right let's thank our speaker once

619
00:20:48,799 --> 00:20:51,799
again

