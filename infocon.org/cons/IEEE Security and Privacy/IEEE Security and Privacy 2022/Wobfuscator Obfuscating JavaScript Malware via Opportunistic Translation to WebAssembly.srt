1
00:00:00,880 --> 00:00:05,040
so hello everyone my name is alan romano

2
00:00:05,359 --> 00:00:07,120
i'm a fourth year phd student from the

3
00:00:07,120 --> 00:00:08,960
university at buffalo

4
00:00:08,960 --> 00:00:11,440
i'll be presenting our work waffy skater

5
00:00:11,440 --> 00:00:13,280
obfuscating javascript malware via

6
00:00:13,280 --> 00:00:16,079
opportunistic translation to webassembly

7
00:00:16,079 --> 00:00:17,520
this work was done in collaboration with

8
00:00:17,520 --> 00:00:19,840
daniel lehmann and michael prattle of

9
00:00:19,840 --> 00:00:21,680
the university of stuttgart

10
00:00:21,680 --> 00:00:25,680
as well as with my advisor waihong wong

11
00:00:27,920 --> 00:00:29,439
there are many dangers that web users

12
00:00:29,439 --> 00:00:30,560
face

13
00:00:30,560 --> 00:00:32,719
websites can harbor drive-by downloaders

14
00:00:32,719 --> 00:00:36,719
cryptominers and phishing attacks

15
00:00:38,320 --> 00:00:40,559
as a result an active area of static

16
00:00:40,559 --> 00:00:42,000
research

17
00:00:42,000 --> 00:00:43,440
of research has been static malware

18
00:00:43,440 --> 00:00:44,399
detection

19
00:00:44,399 --> 00:00:46,480
which analyzes files to identify

20
00:00:46,480 --> 00:00:48,800
malicious behavior patterns

21
00:00:48,800 --> 00:00:51,440
these data detectors can warn about

22
00:00:51,440 --> 00:00:53,280
potential dangers before the files are

23
00:00:53,280 --> 00:00:55,840
executed

24
00:00:56,079 --> 00:00:58,320
as a response attackers try to hide the

25
00:00:58,320 --> 00:01:00,399
maliciousness of their scripts using

26
00:01:00,399 --> 00:01:03,440
obfuscation techniques

27
00:01:04,080 --> 00:01:05,680
there are several obfuscation techniques

28
00:01:05,680 --> 00:01:08,080
for javascript including identify

29
00:01:08,080 --> 00:01:11,040
renaming and dead code injection

30
00:01:11,040 --> 00:01:12,560
but all of these techniques only

31
00:01:12,560 --> 00:01:15,119
transform the malware within the bounds

32
00:01:15,119 --> 00:01:17,360
of the javascript language

33
00:01:17,360 --> 00:01:19,200
while javascript has historically been

34
00:01:19,200 --> 00:01:20,799
the only standard language for web

35
00:01:20,799 --> 00:01:21,920
applications

36
00:01:21,920 --> 00:01:23,520
this is no longer the case with the

37
00:01:23,520 --> 00:01:26,640
introduction of webassembly

38
00:01:26,640 --> 00:01:28,479
webassembly presents new opportunities

39
00:01:28,479 --> 00:01:31,280
for those designing web attacks

40
00:01:31,280 --> 00:01:32,560
what if they could use this new web

41
00:01:32,560 --> 00:01:34,960
standard to obfuscate malware files

42
00:01:34,960 --> 00:01:36,640
beyond the limits of the javascript

43
00:01:36,640 --> 00:01:39,040
language

44
00:01:39,360 --> 00:01:41,680
for those unfamiliar webassembly is a

45
00:01:41,680 --> 00:01:44,159
new client-side web programming language

46
00:01:44,159 --> 00:01:46,159
that aims to enable high-performance

47
00:01:46,159 --> 00:01:49,920
computations at near native speeds

48
00:01:49,920 --> 00:01:52,000
the standard defines a bytecode format

49
00:01:52,000 --> 00:01:54,399
that serves as a compilation target for

50
00:01:54,399 --> 00:01:57,280
compiled languages such as c c plus plus

51
00:01:57,280 --> 00:01:59,759
and rust

52
00:01:59,920 --> 00:02:02,320
since 2017 all of the major browsers

53
00:02:02,320 --> 00:02:05,439
have added support for it

54
00:02:05,680 --> 00:02:08,399
we leverage webassembly in our tool

55
00:02:08,399 --> 00:02:10,000
waffy skater

56
00:02:10,000 --> 00:02:12,560
waffy skater is a tool that opera that

57
00:02:12,560 --> 00:02:14,959
translates javascript code into

58
00:02:14,959 --> 00:02:16,879
webassembly

59
00:02:16,879 --> 00:02:19,200
we show that waffles gator is effective

60
00:02:19,200 --> 00:02:20,720
activating learning based

61
00:02:20,720 --> 00:02:23,920
state-of-the-art malware detectors

62
00:02:23,920 --> 00:02:25,200
we also show that it preserves the

63
00:02:25,200 --> 00:02:27,440
original semantics of the code and

64
00:02:27,440 --> 00:02:29,760
imposes little overhead

65
00:02:29,760 --> 00:02:31,200
we hope that our work helps motivate

66
00:02:31,200 --> 00:02:33,280
future efforts in designing

67
00:02:33,280 --> 00:02:37,400
cross-language malware detection

68
00:02:37,680 --> 00:02:40,000
so although we use javascript to one

69
00:02:40,000 --> 00:02:41,519
assembly translation

70
00:02:41,519 --> 00:02:44,160
we note that in general a broad approach

71
00:02:44,160 --> 00:02:46,480
is practically impossible

72
00:02:46,480 --> 00:02:47,599
this is due to the fundamental

73
00:02:47,599 --> 00:02:49,840
differences in the two languages

74
00:02:49,840 --> 00:02:51,920
namely in their type systems and their

75
00:02:51,920 --> 00:02:55,280
access to the web apis

76
00:02:55,280 --> 00:02:57,519
for these reasons we instead rely on an

77
00:02:57,519 --> 00:03:00,319
approach of opportunistic translation

78
00:03:00,319 --> 00:03:01,360
that is

79
00:03:01,360 --> 00:03:03,519
we only translate javascript code if

80
00:03:03,519 --> 00:03:05,760
it's relevant for detecting malicious

81
00:03:05,760 --> 00:03:06,640
code

82
00:03:06,640 --> 00:03:09,120
and it can be translated to webassembly

83
00:03:09,120 --> 00:03:12,480
in a semantics preserving way

84
00:03:13,599 --> 00:03:15,519
to understand how waffle skater works

85
00:03:15,519 --> 00:03:18,239
i'll present a high level overview

86
00:03:18,239 --> 00:03:21,120
given a malicious javascript file first

87
00:03:21,120 --> 00:03:23,040
the file is parsed into an abstract

88
00:03:23,040 --> 00:03:25,200
syntax tree

89
00:03:25,200 --> 00:03:27,599
second this asus reversed to find

90
00:03:27,599 --> 00:03:29,519
potential translation sites where our

91
00:03:29,519 --> 00:03:32,799
transformations can be applied

92
00:03:32,799 --> 00:03:35,519
finally the identified sites are

93
00:03:35,519 --> 00:03:38,480
rewritten to webassembly and the ast is

94
00:03:38,480 --> 00:03:40,319
rewritten to use this new translated

95
00:03:40,319 --> 00:03:41,440
code

96
00:03:41,440 --> 00:03:43,200
the output is the rewritten javascript

97
00:03:43,200 --> 00:03:47,280
file and the webassembly modules

98
00:03:47,280 --> 00:03:49,200
the core of our approach lies in our

99
00:03:49,200 --> 00:03:50,959
transformation techniques

100
00:03:50,959 --> 00:03:52,879
or transformation rules

101
00:03:52,879 --> 00:03:55,680
each rule consists of three parts

102
00:03:55,680 --> 00:03:57,040
a set of code locations where a

103
00:03:57,040 --> 00:03:59,760
transformation can be applied

104
00:03:59,760 --> 00:04:01,439
a transformation function that maps

105
00:04:01,439 --> 00:04:03,280
javascript code to equivalent javascript

106
00:04:03,280 --> 00:04:05,760
and webassembly code

107
00:04:05,760 --> 00:04:07,280
and a precondition

108
00:04:07,280 --> 00:04:08,879
expressed as a predicate on the code

109
00:04:08,879 --> 00:04:11,439
location and its surrounding contexts

110
00:04:11,439 --> 00:04:12,959
to ensure that the semantics of the

111
00:04:12,959 --> 00:04:16,399
program remain unchanged

112
00:04:17,040 --> 00:04:18,720
we define seven of these transformation

113
00:04:18,720 --> 00:04:22,320
rules and they fall into three groups

114
00:04:22,320 --> 00:04:24,479
the first group obfuscates data literals

115
00:04:24,479 --> 00:04:26,400
that pattern-based detectors use as

116
00:04:26,400 --> 00:04:28,880
lexical signatures

117
00:04:28,880 --> 00:04:30,560
the second group obfuscates function

118
00:04:30,560 --> 00:04:33,680
calls that ast-based detectors use as

119
00:04:33,680 --> 00:04:36,320
calling contexts

120
00:04:36,320 --> 00:04:38,639
in this group the first rule targets

121
00:04:38,639 --> 00:04:40,479
function calls with names typically used

122
00:04:40,479 --> 00:04:43,440
in malware such as eval

123
00:04:43,440 --> 00:04:45,120
the second rule targets general

124
00:04:45,120 --> 00:04:47,040
javascript function calls

125
00:04:47,040 --> 00:04:49,040
we developed two versions of this rule

126
00:04:49,040 --> 00:04:51,120
where version a is compatible with the

127
00:04:51,120 --> 00:04:53,520
mbp release of webassembly but it can't

128
00:04:53,520 --> 00:04:56,479
support calls with return values while

129
00:04:56,479 --> 00:04:58,080
version b

130
00:04:58,080 --> 00:04:59,680
requires the reference types language

131
00:04:59,680 --> 00:05:03,919
proposal and does support return values

132
00:05:04,240 --> 00:05:06,240
the third group obfuscates control flow

133
00:05:06,240 --> 00:05:08,560
constructs to remove this information

134
00:05:08,560 --> 00:05:11,120
from use by detectors

135
00:05:11,120 --> 00:05:12,080
i'll present three of these

136
00:05:12,080 --> 00:05:15,680
transformation rules in depth

137
00:05:16,479 --> 00:05:18,880
the transformation rule t1 aims to

138
00:05:18,880 --> 00:05:20,800
remove the signatures expected by

139
00:05:20,800 --> 00:05:23,759
embedded code detectors

140
00:05:23,759 --> 00:05:25,759
rule targets literal ast nodes with

141
00:05:25,759 --> 00:05:27,840
string values

142
00:05:27,840 --> 00:05:29,440
and the transformation moves during

143
00:05:29,440 --> 00:05:31,120
literals into the data sections of

144
00:05:31,120 --> 00:05:33,759
webassembly

145
00:05:33,840 --> 00:05:36,320
the precondition excludes

146
00:05:36,320 --> 00:05:38,560
locations where functions calls can't

147
00:05:38,560 --> 00:05:40,240
replace string literals

148
00:05:40,240 --> 00:05:44,479
namely in import and require statements

149
00:05:45,280 --> 00:05:47,039
the transformation rule t4 call

150
00:05:47,039 --> 00:05:48,240
expression a

151
00:05:48,240 --> 00:05:50,320
aims to modify the calling context used

152
00:05:50,320 --> 00:05:53,120
by ast based detectors

153
00:05:53,120 --> 00:05:54,800
this rule is applied to call expression

154
00:05:54,800 --> 00:05:55,840
nodes

155
00:05:55,840 --> 00:05:57,520
and it works by converting the original

156
00:05:57,520 --> 00:05:59,199
javascript function call into a

157
00:05:59,199 --> 00:06:02,319
webassembly export call

158
00:06:02,639 --> 00:06:04,479
this rule excludes calls that have

159
00:06:04,479 --> 00:06:07,120
return values this is because in order

160
00:06:07,120 --> 00:06:09,199
to support support and arbitrary data

161
00:06:09,199 --> 00:06:11,039
value we would need a general way to

162
00:06:11,039 --> 00:06:13,120
represent all possible javascript data

163
00:06:13,120 --> 00:06:15,199
types using only the four primitives of

164
00:06:15,199 --> 00:06:20,000
webassembly which is a non-trivial task

165
00:06:20,000 --> 00:06:23,199
the rules t5 if statement aims to remove

166
00:06:23,199 --> 00:06:24,880
this control flow information from the

167
00:06:24,880 --> 00:06:27,520
javascript file

168
00:06:27,520 --> 00:06:29,199
this transformation targets if statement

169
00:06:29,199 --> 00:06:30,240
nodes

170
00:06:30,240 --> 00:06:32,240
and it works by wrapping the if and else

171
00:06:32,240 --> 00:06:34,560
branches of the original statement with

172
00:06:34,560 --> 00:06:36,000
anonymous functions

173
00:06:36,000 --> 00:06:37,759
and then moving their execution from

174
00:06:37,759 --> 00:06:41,120
javascript to webassembly

175
00:06:41,120 --> 00:06:43,680
this rule can be applied to ethos blocks

176
00:06:43,680 --> 00:06:45,759
that contain certain keywords such as

177
00:06:45,759 --> 00:06:48,880
break continue and return as doing so

178
00:06:48,880 --> 00:06:50,880
could break the syntax or the semantics

179
00:06:50,880 --> 00:06:53,039
of the program

180
00:06:53,039 --> 00:06:54,960
now present a code example showing our

181
00:06:54,960 --> 00:06:58,159
transformations in action

182
00:06:58,720 --> 00:07:00,400
here's the javascript code snippet from

183
00:07:00,400 --> 00:07:02,960
a non-mounted tracker this code snippet

184
00:07:02,960 --> 00:07:04,800
sends the user's browser cookie to some

185
00:07:04,800 --> 00:07:06,720
malicious server

186
00:07:06,720 --> 00:07:08,800
wafflesgator first identifies places

187
00:07:08,800 --> 00:07:11,280
where the transformations are applicable

188
00:07:11,280 --> 00:07:12,800
it begins by identifying the string

189
00:07:12,800 --> 00:07:14,000
literals

190
00:07:14,000 --> 00:07:16,080
then the general function calls and

191
00:07:16,080 --> 00:07:19,199
finally the if statement

192
00:07:19,199 --> 00:07:20,880
of executor then begins applying the

193
00:07:20,880 --> 00:07:23,680
transformations

194
00:07:24,160 --> 00:07:26,240
the string literals are the first moved

195
00:07:26,240 --> 00:07:28,479
over to the webassembly module

196
00:07:28,479 --> 00:07:30,080
this is done by blooming the strings

197
00:07:30,080 --> 00:07:32,160
into the data section of the webassembly

198
00:07:32,160 --> 00:07:33,520
module

199
00:07:33,520 --> 00:07:35,120
the data section defines the initial

200
00:07:35,120 --> 00:07:37,360
data that's used and available to the

201
00:07:37,360 --> 00:07:40,720
module when it's first instantiated

202
00:07:40,720 --> 00:07:42,400
the starting index of each string in

203
00:07:42,400 --> 00:07:44,240
this memory is stored as a global

204
00:07:44,240 --> 00:07:46,479
variable which are accessible across the

205
00:07:46,479 --> 00:07:47,759
entire module

206
00:07:47,759 --> 00:07:50,879
and can be exported to javascript

207
00:07:50,879 --> 00:07:53,919
on the js side we use a helper function

208
00:07:53,919 --> 00:07:56,080
load string to reconstruct the string

209
00:07:56,080 --> 00:07:58,560
literals from the assembly give given

210
00:07:58,560 --> 00:08:01,520
the string indices

211
00:08:02,879 --> 00:08:04,639
next waffle skater moves the original

212
00:08:04,639 --> 00:08:06,800
function call of a pen child

213
00:08:06,800 --> 00:08:08,879
into an imported function

214
00:08:08,879 --> 00:08:11,120
call import

215
00:08:11,120 --> 00:08:13,440
in the web summary module we also define

216
00:08:13,440 --> 00:08:15,840
an export function call func that simply

217
00:08:15,840 --> 00:08:18,879
calls this call import

218
00:08:18,879 --> 00:08:20,479
in the javascript side

219
00:08:20,479 --> 00:08:22,639
we replace the original function call

220
00:08:22,639 --> 00:08:23,599
site

221
00:08:23,599 --> 00:08:25,520
with an anonymous function block that

222
00:08:25,520 --> 00:08:27,440
does three things

223
00:08:27,440 --> 00:08:30,000
it instantiates the webassembly module

224
00:08:30,000 --> 00:08:31,840
with an import object containing the

225
00:08:31,840 --> 00:08:34,880
original call to a pen child

226
00:08:34,880 --> 00:08:36,479
it calls the exported webassembly

227
00:08:36,479 --> 00:08:39,360
function call func

228
00:08:39,679 --> 00:08:40,640
and

229
00:08:40,640 --> 00:08:42,000
it invokes the anonymous function

230
00:08:42,000 --> 00:08:44,399
wrapper that wraps everything to trigger

231
00:08:44,399 --> 00:08:47,120
the execution

232
00:08:47,680 --> 00:08:52,080
finally the if statement is transformed

233
00:08:52,080 --> 00:08:54,080
in the webassembly code we define two

234
00:08:54,080 --> 00:08:55,440
import functions

235
00:08:55,440 --> 00:08:58,640
if if import and else import

236
00:08:58,640 --> 00:09:00,640
these functions wrap the if and the else

237
00:09:00,640 --> 00:09:01,680
branches

238
00:09:01,680 --> 00:09:04,959
of the original if statement

239
00:09:05,519 --> 00:09:07,680
the webassembly code also defines the

240
00:09:07,680 --> 00:09:09,920
export function if thunk

241
00:09:09,920 --> 00:09:12,399
this function uses the if instruction to

242
00:09:12,399 --> 00:09:15,760
call if import if the condition is true

243
00:09:15,760 --> 00:09:17,760
and else import if the condition is

244
00:09:17,760 --> 00:09:20,080
false

245
00:09:20,160 --> 00:09:21,920
in the javascript side similar to the

246
00:09:21,920 --> 00:09:23,440
function transformation

247
00:09:23,440 --> 00:09:25,120
the original site of the if statement is

248
00:09:25,120 --> 00:09:27,200
replaced with an anonymous function

249
00:09:27,200 --> 00:09:28,399
block that

250
00:09:28,399 --> 00:09:31,120
instantiates the module

251
00:09:31,120 --> 00:09:34,480
calls the exported webassembly function

252
00:09:34,480 --> 00:09:36,240
and invokes the anonymous wrapper that

253
00:09:36,240 --> 00:09:38,000
wraps everything

254
00:09:38,000 --> 00:09:40,160
the difference here is that the export

255
00:09:40,160 --> 00:09:41,600
function takes in the original if

256
00:09:41,600 --> 00:09:43,440
statement condition as a function

257
00:09:43,440 --> 00:09:44,959
parameter

258
00:09:44,959 --> 00:09:47,120
if the condition is true a one is passed

259
00:09:47,120 --> 00:09:47,920
in

260
00:09:47,920 --> 00:09:50,560
otherwise a zero is passed in

261
00:09:50,560 --> 00:09:52,160
this allows the webassembly's if

262
00:09:52,160 --> 00:09:54,720
instruction to execute the appropriate

263
00:09:54,720 --> 00:09:57,440
import function

264
00:09:58,160 --> 00:09:59,200
after applying all of our

265
00:09:59,200 --> 00:10:01,040
transformations here we have the final

266
00:10:01,040 --> 00:10:03,120
output with the reaver in javascript

267
00:10:03,120 --> 00:10:07,120
file and the new web assembly modules

268
00:10:07,680 --> 00:10:09,680
we evaluate our tool along three

269
00:10:09,680 --> 00:10:11,600
dimensions

270
00:10:11,600 --> 00:10:13,519
first we show that waffle skater is

271
00:10:13,519 --> 00:10:15,839
effective activating state-of-the-art

272
00:10:15,839 --> 00:10:18,959
learning based static malware detectors

273
00:10:18,959 --> 00:10:20,880
we also show that it can outperform

274
00:10:20,880 --> 00:10:24,399
existing obfuscators as well

275
00:10:24,880 --> 00:10:26,560
second we validate our claim that

276
00:10:26,560 --> 00:10:29,040
wafflezuker preserves code semantics and

277
00:10:29,040 --> 00:10:30,320
we do this by leveraging the

278
00:10:30,320 --> 00:10:32,640
comprehensive test suites of six widely

279
00:10:32,640 --> 00:10:35,839
used javascript projects

280
00:10:36,240 --> 00:10:38,000
finally we show that wi-fi skater is

281
00:10:38,000 --> 00:10:40,079
efficient both in terms of its runtime

282
00:10:40,079 --> 00:10:43,839
overhead and its code size increase

283
00:10:43,839 --> 00:10:45,800
for this talk i'll focus on the

284
00:10:45,800 --> 00:10:47,360
effectiveness activating

285
00:10:47,360 --> 00:10:50,560
state-of-the-art detectors

286
00:10:51,680 --> 00:10:53,519
to train and test the detectors we

287
00:10:53,519 --> 00:10:56,480
construct a data set of over 149 000

288
00:10:56,480 --> 00:10:59,120
benign javascript samples and over 43

289
00:10:59,120 --> 00:11:00,959
thousand malicious javascript script

290
00:11:00,959 --> 00:11:05,199
samples coming from several data sets

291
00:11:05,440 --> 00:11:08,000
we evaluate waffle skater on four

292
00:11:08,000 --> 00:11:09,920
state-of-the-art learning based static

293
00:11:09,920 --> 00:11:11,519
malware detectors

294
00:11:11,519 --> 00:11:13,760
these detectors include cujo which

295
00:11:13,760 --> 00:11:15,440
performs a lexical analysis on the

296
00:11:15,440 --> 00:11:17,440
tokens of javascript files

297
00:11:17,440 --> 00:11:19,440
zazzle which performs a syntactic

298
00:11:19,440 --> 00:11:20,560
analysis

299
00:11:20,560 --> 00:11:23,279
on javascript asts

300
00:11:23,279 --> 00:11:25,440
just which performs a syntactic analysis

301
00:11:25,440 --> 00:11:28,160
of engrams of javascript ast syntactic

302
00:11:28,160 --> 00:11:29,279
units

303
00:11:29,279 --> 00:11:31,600
and jstop which performs syntactic

304
00:11:31,600 --> 00:11:33,839
control flow and data flow analyses

305
00:11:33,839 --> 00:11:36,399
using two feature extraction modes

306
00:11:36,399 --> 00:11:38,480
the engrams mode constructs n-grams from

307
00:11:38,480 --> 00:11:41,040
the javascript asts and the values modes

308
00:11:41,040 --> 00:11:43,200
constructs identify pairs of identifier

309
00:11:43,200 --> 00:11:46,160
values and their context used

310
00:11:46,160 --> 00:11:47,680
for this tool we focus on the

311
00:11:47,680 --> 00:11:50,399
performance of both of these modes

312
00:11:50,399 --> 00:11:52,240
since wafflesgator aims to reduce the

313
00:11:52,240 --> 00:11:54,000
ability of these detectors to detect

314
00:11:54,000 --> 00:11:56,079
malicious samples we focus on the

315
00:11:56,079 --> 00:11:59,519
reduction in the recall rates

316
00:12:00,000 --> 00:12:01,440
this figure shows how waffle skater

317
00:12:01,440 --> 00:12:03,920
affects the recall of each detector

318
00:12:03,920 --> 00:12:05,760
the purple bars show

319
00:12:05,760 --> 00:12:07,519
the detector's recall on the

320
00:12:07,519 --> 00:12:09,680
unobfuscated data set which serves as

321
00:12:09,680 --> 00:12:11,600
our baseline

322
00:12:11,600 --> 00:12:13,920
the red bars show the detectors recall

323
00:12:13,920 --> 00:12:16,800
after applying our obfuscations

324
00:12:16,800 --> 00:12:18,160
here we apply all seven of our

325
00:12:18,160 --> 00:12:21,040
transformations with t4a being used of

326
00:12:21,040 --> 00:12:22,639
the two versions

327
00:12:22,639 --> 00:12:24,639
as we can see wi-fi skater greatly

328
00:12:24,639 --> 00:12:26,240
reduces the recall on most of these

329
00:12:26,240 --> 00:12:28,800
detectors

330
00:12:29,040 --> 00:12:31,040
we also show the recall of the malware

331
00:12:31,040 --> 00:12:33,120
detectors under different configurations

332
00:12:33,120 --> 00:12:35,519
of our transformations

333
00:12:35,519 --> 00:12:36,800
the first row

334
00:12:36,800 --> 00:12:38,320
shows the baseline results of these

335
00:12:38,320 --> 00:12:40,240
detectors

336
00:12:40,240 --> 00:12:42,639
this middle part shows the results after

337
00:12:42,639 --> 00:12:45,440
applying an individual transformation

338
00:12:45,440 --> 00:12:47,360
on the samples

339
00:12:47,360 --> 00:12:49,760
and the third row shows the recall rates

340
00:12:49,760 --> 00:12:51,120
after applying a combination of our

341
00:12:51,120 --> 00:12:53,040
transformations

342
00:12:53,040 --> 00:12:54,800
as we can see

343
00:12:54,800 --> 00:12:56,880
different techniques work best against

344
00:12:56,880 --> 00:12:59,360
different detectors

345
00:12:59,360 --> 00:13:02,160
for example the rule t1 performs best

346
00:13:02,160 --> 00:13:04,839
against cujo zazzle and jstop in values

347
00:13:04,839 --> 00:13:06,399
mode

348
00:13:06,399 --> 00:13:10,560
the rule t4a performs best against just

349
00:13:10,560 --> 00:13:13,040
and the rule t4b performs best against

350
00:13:13,040 --> 00:13:17,839
jstop in values mode or in engrams mode

351
00:13:18,160 --> 00:13:19,519
now we'll discuss a few mitigation

352
00:13:19,519 --> 00:13:21,120
strategies that can counter our waffle

353
00:13:21,120 --> 00:13:22,720
skater tool

354
00:13:22,720 --> 00:13:24,720
the first strategy is to use dynamic

355
00:13:24,720 --> 00:13:26,800
analysis based malware detection

356
00:13:26,800 --> 00:13:28,160
and this is because waffy scooter

357
00:13:28,160 --> 00:13:29,680
doesn't impact the general runtime

358
00:13:29,680 --> 00:13:31,920
characteristics of the program

359
00:13:31,920 --> 00:13:33,839
however these detectors often impose a

360
00:13:33,839 --> 00:13:36,000
non-negligible overhead that makes them

361
00:13:36,000 --> 00:13:37,680
unappealing when looking to replace

362
00:13:37,680 --> 00:13:39,680
static detectors

363
00:13:39,680 --> 00:13:41,600
the second strategy is to disable

364
00:13:41,600 --> 00:13:43,199
webassembly entirely

365
00:13:43,199 --> 00:13:45,519
but this strategy seems extreme and

366
00:13:45,519 --> 00:13:47,120
infeasible as well as some of the

367
00:13:47,120 --> 00:13:49,279
adoption grows

368
00:13:49,279 --> 00:13:51,760
the third strategy is to jointly analyze

369
00:13:51,760 --> 00:13:53,760
javascript and webassembly which would

370
00:13:53,760 --> 00:13:56,000
reason about how data and control flows

371
00:13:56,000 --> 00:13:58,160
between the two languages

372
00:13:58,160 --> 00:13:59,839
we're not aware of any detector that

373
00:13:59,839 --> 00:14:01,680
does this but we hope that our work

374
00:14:01,680 --> 00:14:04,000
raises awareness that such an analysis

375
00:14:04,000 --> 00:14:06,720
would be useful

376
00:14:07,360 --> 00:14:09,040
our work is closely related to existing

377
00:14:09,040 --> 00:14:10,800
work on obfuscation studies and

378
00:14:10,800 --> 00:14:11,839
techniques

379
00:14:11,839 --> 00:14:14,800
malware detection obfuscation detection

380
00:14:14,800 --> 00:14:18,560
and webassembly and its security

381
00:14:18,880 --> 00:14:21,680
in conclusion we developed officegator a

382
00:14:21,680 --> 00:14:23,600
code obfuscation technique built on a

383
00:14:23,600 --> 00:14:25,440
set of transformation rules that

384
00:14:25,440 --> 00:14:27,279
opportunistically translates javascript

385
00:14:27,279 --> 00:14:29,680
code into webassembly

386
00:14:29,680 --> 00:14:31,360
we show that waffle skater is effective

387
00:14:31,360 --> 00:14:32,560
against state-of-the-art malware

388
00:14:32,560 --> 00:14:34,800
detectors in addition to preserving code

389
00:14:34,800 --> 00:14:36,959
semantics and with little additional

390
00:14:36,959 --> 00:14:38,880
overhead

391
00:14:38,880 --> 00:14:40,399
we hope that our work helps motivate

392
00:14:40,399 --> 00:14:41,920
future effort in detecting

393
00:14:41,920 --> 00:14:44,240
cross-language malware

394
00:14:44,240 --> 00:14:45,519
thank you for your time and i look

395
00:14:45,519 --> 00:14:47,350
forward to answering your questions

396
00:14:47,350 --> 00:14:54,880
[Applause]

397
00:14:54,880 --> 00:14:56,959
go ahead okay yeah thanks for this

398
00:14:56,959 --> 00:14:59,040
interesting talk uh you you were talking

399
00:14:59,040 --> 00:15:00,800
about the mitigations a bit i was just

400
00:15:00,800 --> 00:15:02,399
wondering which steps did you take in

401
00:15:02,399 --> 00:15:04,000
order to ensure that your tool is not

402
00:15:04,000 --> 00:15:06,000
used by malicious actors right now did

403
00:15:06,000 --> 00:15:08,720
you collaborate with these developers of

404
00:15:08,720 --> 00:15:10,959
the malware analysis tools or or what

405
00:15:10,959 --> 00:15:12,880
are your thoughts on this

406
00:15:12,880 --> 00:15:15,199
so our current um technique is that

407
00:15:15,199 --> 00:15:18,240
we're not currently sharing the code

408
00:15:18,240 --> 00:15:19,519
until

409
00:15:19,519 --> 00:15:22,000
we feel confident that either defenses

410
00:15:22,000 --> 00:15:23,360
are on the way

411
00:15:23,360 --> 00:15:24,480
or

412
00:15:24,480 --> 00:15:26,639
enough time has passed after this talk

413
00:15:26,639 --> 00:15:27,839
that people are starting to think about

414
00:15:27,839 --> 00:15:28,560
it

415
00:15:28,560 --> 00:15:30,399
um

416
00:15:30,399 --> 00:15:32,800
yeah we just don't feel confident uh

417
00:15:32,800 --> 00:15:34,639
just making this code publicly available

418
00:15:34,639 --> 00:15:36,560
currently yeah it will be interesting to

419
00:15:36,560 --> 00:15:38,399
see how easy this is to re-implement

420
00:15:38,399 --> 00:15:42,959
based on your paper but yeah yeah thanks

421
00:15:42,959 --> 00:15:45,120
uh hi nicholas from sispa um very

422
00:15:45,120 --> 00:15:47,040
interesting work um

423
00:15:47,040 --> 00:15:48,560
one question

424
00:15:48,560 --> 00:15:49,920
a trivial

425
00:15:49,920 --> 00:15:51,680
way to detect the samples

426
00:15:51,680 --> 00:15:52,880
is you should look at some of the

427
00:15:52,880 --> 00:15:55,279
signatures that you call into web

428
00:15:55,279 --> 00:15:56,639
assembly right so it's like the one

429
00:15:56,639 --> 00:15:58,079
regex thing

430
00:15:58,079 --> 00:16:00,000
i'm wondering is there a way for you to

431
00:16:00,000 --> 00:16:01,279
obfuscate

432
00:16:01,279 --> 00:16:03,360
the presence of warp for skater in the

433
00:16:03,360 --> 00:16:06,160
javascript space

434
00:16:07,279 --> 00:16:09,040
in general there should be ways to

435
00:16:09,040 --> 00:16:12,240
obfuscate uh waffle skater one

436
00:16:12,240 --> 00:16:14,079
uh kind of simple strategy that comes to

437
00:16:14,079 --> 00:16:14,880
mind

438
00:16:14,880 --> 00:16:15,600
is

439
00:16:15,600 --> 00:16:17,360
applying javascript obfuscation

440
00:16:17,360 --> 00:16:19,600
techniques on the output waffle skated

441
00:16:19,600 --> 00:16:21,120
sample

442
00:16:21,120 --> 00:16:23,600
and in general the

443
00:16:23,600 --> 00:16:25,279
instantiation methods are kind of the

444
00:16:25,279 --> 00:16:27,120
limiting factors of these javascript

445
00:16:27,120 --> 00:16:28,160
samples

446
00:16:28,160 --> 00:16:31,199
but if you can get clever enough about

447
00:16:31,199 --> 00:16:32,880
where you put these

448
00:16:32,880 --> 00:16:34,880
webassembly instantiation methods

449
00:16:34,880 --> 00:16:36,880
then you could possibly change where

450
00:16:36,880 --> 00:16:38,079
these

451
00:16:38,079 --> 00:16:39,040
or how

452
00:16:39,040 --> 00:16:41,440
these obfuscated samples look like and

453
00:16:41,440 --> 00:16:42,480
with the

454
00:16:42,480 --> 00:16:44,800
webassembly reference type proposal

455
00:16:44,800 --> 00:16:47,680
this can allow these

456
00:16:47,680 --> 00:16:50,160
instantiation methods to vary a lot more

457
00:16:50,160 --> 00:16:52,160
because we're not restricted to

458
00:16:52,160 --> 00:16:54,000
simply having these large blocks of

459
00:16:54,000 --> 00:16:56,480
codes injected into it it can be a lot

460
00:16:56,480 --> 00:16:57,680
more flexible

461
00:16:57,680 --> 00:17:00,000
okay but maybe also that solves the

462
00:17:00,000 --> 00:17:02,079
previous problem right you can release

463
00:17:02,079 --> 00:17:04,160
your source code but tell av vendors hey

464
00:17:04,160 --> 00:17:05,760
here's the signature just build this in

465
00:17:05,760 --> 00:17:07,439
and you will detect web for skater

466
00:17:07,439 --> 00:17:10,160
assuming there is no benign use cases

467
00:17:10,160 --> 00:17:13,039
so maybe that's of the conundrum

468
00:17:13,039 --> 00:17:13,919
um

469
00:17:13,919 --> 00:17:14,799
yes

470
00:17:14,799 --> 00:17:16,079
we could

471
00:17:16,079 --> 00:17:18,640
we hope that uh

472
00:17:18,640 --> 00:17:22,640
detect the defenses can build um

473
00:17:22,640 --> 00:17:24,799
kind of signature-based detection honor

474
00:17:24,799 --> 00:17:25,839
tool

475
00:17:25,839 --> 00:17:27,760
uh that would be a great defensive

476
00:17:27,760 --> 00:17:30,320
strategy for this technique but we still

477
00:17:30,320 --> 00:17:32,960
propose this technique to show that

478
00:17:32,960 --> 00:17:34,400
people could take

479
00:17:34,400 --> 00:17:36,559
advantage of this webassembly language

480
00:17:36,559 --> 00:17:38,640
that's available on all major web

481
00:17:38,640 --> 00:17:41,039
browsers

482
00:17:42,160 --> 00:17:44,320
first thanks for the nice talk i have

483
00:17:44,320 --> 00:17:46,480
two questions about the evaluation

484
00:17:46,480 --> 00:17:48,880
first i'm curious whether when you were

485
00:17:48,880 --> 00:17:51,360
evaluating the effectiveness of the

486
00:17:51,360 --> 00:17:53,840
learning based classifiers on watfu

487
00:17:53,840 --> 00:17:55,280
scatterer's output

488
00:17:55,280 --> 00:17:59,039
did you retrain the classifiers on a

489
00:17:59,039 --> 00:18:00,960
data set that included

490
00:18:00,960 --> 00:18:02,559
output from obfuscator or did you try to

491
00:18:02,559 --> 00:18:05,520
use the original model

492
00:18:05,679 --> 00:18:08,400
um well in the evaluation we used the

493
00:18:08,400 --> 00:18:11,200
original models

494
00:18:11,360 --> 00:18:13,039
and

495
00:18:13,039 --> 00:18:15,039
we use the original models for the

496
00:18:15,039 --> 00:18:17,120
baseline results yeah and the original

497
00:18:17,120 --> 00:18:19,200
models for the evaluation okay that

498
00:18:19,200 --> 00:18:20,799
makes sense and then also i was curious

499
00:18:20,799 --> 00:18:22,320
um it's not very important because the

500
00:18:22,320 --> 00:18:24,640
the runtime overhead was so low but i'm

501
00:18:24,640 --> 00:18:26,240
curious whether you dug into what the

502
00:18:26,240 --> 00:18:29,280
source of the runtime overhead was

503
00:18:29,280 --> 00:18:31,200
um most of the runtime overhead comes

504
00:18:31,200 --> 00:18:32,559
from the context switching from

505
00:18:32,559 --> 00:18:34,720
webassembly in javascript

506
00:18:34,720 --> 00:18:36,720
because we

507
00:18:36,720 --> 00:18:38,320
rely on a lot a lot of these

508
00:18:38,320 --> 00:18:39,679
transformations rely on these import

509
00:18:39,679 --> 00:18:42,559
functions they naturally

510
00:18:42,559 --> 00:18:44,799
invoke javascript and webassembly kind

511
00:18:44,799 --> 00:18:48,799
of back to back and forth and this is um

512
00:18:48,799 --> 00:18:51,200
kind of expensive in browsers of course

513
00:18:51,200 --> 00:18:53,440
thanks

514
00:18:53,520 --> 00:18:55,760
thanks this was a great talk um i wanted

515
00:18:55,760 --> 00:18:58,000
to ask during the evaluation i think

516
00:18:58,000 --> 00:19:01,039
there was one of the uh detectors that

517
00:19:01,039 --> 00:19:03,679
was pretty successful right zazzle

518
00:19:03,679 --> 00:19:05,440
um and i'm wondering if you have any

519
00:19:05,440 --> 00:19:07,200
conjecture as to why that one was more

520
00:19:07,200 --> 00:19:08,799
successful than the others

521
00:19:08,799 --> 00:19:10,400
so we think that

522
00:19:10,400 --> 00:19:12,480
zozle performs well against our

523
00:19:12,480 --> 00:19:15,440
application because it looks a lot at

524
00:19:15,440 --> 00:19:17,600
identifier names

525
00:19:17,600 --> 00:19:19,360
and our transformations don't really

526
00:19:19,360 --> 00:19:23,039
target these identifier names so

527
00:19:23,039 --> 00:19:25,520
as much as control flow has moved to

528
00:19:25,520 --> 00:19:27,200
the webassembly the identifier names

529
00:19:27,200 --> 00:19:30,880
still remain in javascript so we plan in

530
00:19:30,880 --> 00:19:32,400
future work to kind of look at

531
00:19:32,400 --> 00:19:33,679
transformations that would move these

532
00:19:33,679 --> 00:19:36,720
function names into the website module

533
00:19:36,720 --> 00:19:38,480
and we hope that that would uh work

534
00:19:38,480 --> 00:19:40,320
against the style better cool thank you

535
00:19:40,320 --> 00:19:42,799
very much thank you

536
00:19:42,799 --> 00:19:45,679
omar university of washington uh

537
00:19:45,679 --> 00:19:47,200
a lot of

538
00:19:47,200 --> 00:19:49,360
transformations that you do could they

539
00:19:49,360 --> 00:19:51,760
be treated as obfuscation by

540
00:19:51,760 --> 00:19:53,200
a lot of these tools and that's why they

541
00:19:53,200 --> 00:19:54,559
are failing

542
00:19:54,559 --> 00:19:56,640
and any particular reason you did not

543
00:19:56,640 --> 00:19:57,440
try

544
00:19:57,440 --> 00:19:59,919
dynamic analysis tools

545
00:19:59,919 --> 00:20:02,080
uh could you repeat that so the first

546
00:20:02,080 --> 00:20:03,600
question is

547
00:20:03,600 --> 00:20:05,440
a lot of transformations that you do

548
00:20:05,440 --> 00:20:07,840
could they be treated as obfuscations by

549
00:20:07,840 --> 00:20:10,400
these static analysis tools

550
00:20:10,400 --> 00:20:12,159
um

551
00:20:12,159 --> 00:20:13,520
and maybe that's why i didn't perform

552
00:20:13,520 --> 00:20:14,880
well

553
00:20:14,880 --> 00:20:16,640
so

554
00:20:16,640 --> 00:20:17,520
they

555
00:20:17,520 --> 00:20:20,080
they are um

556
00:20:20,080 --> 00:20:21,679
are you saying that these detectors

557
00:20:21,679 --> 00:20:22,720
should

558
00:20:22,720 --> 00:20:24,799
treat them as obfuscations

559
00:20:24,799 --> 00:20:26,159
maybe they're thinking that that's

560
00:20:26,159 --> 00:20:27,679
obfuscation because you're adding a lot

561
00:20:27,679 --> 00:20:29,520
more code in addition to the simple

562
00:20:29,520 --> 00:20:31,440
function that you had initially so maybe

563
00:20:31,440 --> 00:20:32,799
they're getting confused because of the

564
00:20:32,799 --> 00:20:34,799
obfuscation and it doesn't necessarily

565
00:20:34,799 --> 00:20:36,080
have anything to do with the web

566
00:20:36,080 --> 00:20:37,760
assembly

567
00:20:37,760 --> 00:20:40,799
yes so that is um part of the

568
00:20:40,799 --> 00:20:43,200
effectiveness of waffle skater it's that

569
00:20:43,200 --> 00:20:45,440
we're

570
00:20:45,440 --> 00:20:46,720
changing

571
00:20:46,720 --> 00:20:48,960
not only the well we're changing the

572
00:20:48,960 --> 00:20:51,120
control flow but we're

573
00:20:51,120 --> 00:20:53,919
um adding this additional kind of

574
00:20:53,919 --> 00:20:55,840
indirection to the javascript file as

575
00:20:55,840 --> 00:20:56,799
well

576
00:20:56,799 --> 00:20:58,480
an example is our function called

577
00:20:58,480 --> 00:21:00,640
transformation so in a high level it's

578
00:21:00,640 --> 00:21:02,240
moving a function call to a function

579
00:21:02,240 --> 00:21:03,919
call right but the difference here is

580
00:21:03,919 --> 00:21:06,240
that the function call

581
00:21:06,240 --> 00:21:07,360
is a lot more different than the

582
00:21:07,360 --> 00:21:10,080
original function call which the ast

583
00:21:10,080 --> 00:21:11,520
base detectors that look at the calling

584
00:21:11,520 --> 00:21:14,159
context would get confused on

585
00:21:14,159 --> 00:21:16,320
got it and any reason you did not try

586
00:21:16,320 --> 00:21:17,840
any dynamic analysis tools because i'm

587
00:21:17,840 --> 00:21:19,600
assuming that a lot of this analysis is

588
00:21:19,600 --> 00:21:20,960
offline

589
00:21:20,960 --> 00:21:22,240
um we

590
00:21:22,240 --> 00:21:25,280
specifically target static detectors

591
00:21:25,280 --> 00:21:26,000
um

592
00:21:26,000 --> 00:21:28,080
because we don't

593
00:21:28,080 --> 00:21:31,200
think that dynamic detectors would get

594
00:21:31,200 --> 00:21:34,320
tripped up on our waffle skater tool

595
00:21:34,320 --> 00:21:36,880
um web secure does a lot to the file

596
00:21:36,880 --> 00:21:39,600
syntax but it doesn't change uh which

597
00:21:39,600 --> 00:21:41,200
functions are

598
00:21:41,200 --> 00:21:42,480
indicated

599
00:21:42,480 --> 00:21:45,039
which functions are used so if a dynamic

600
00:21:45,039 --> 00:21:46,640
detector is looking at some certain

601
00:21:46,640 --> 00:21:49,120
function it will still probably

602
00:21:49,120 --> 00:21:51,120
read this function

603
00:21:51,120 --> 00:21:54,479
thank you thank you so much nice work

604
00:21:55,520 --> 00:21:57,520
if i understand correctly your tool will

605
00:21:57,520 --> 00:21:59,840
induce a ton of context switching could

606
00:21:59,840 --> 00:22:01,600
this be used to detect the presence of

607
00:22:01,600 --> 00:22:02,960
your tool because i assume this is

608
00:22:02,960 --> 00:22:05,200
highly unusual

609
00:22:05,200 --> 00:22:07,039
yes um

610
00:22:07,039 --> 00:22:09,120
so the context switching that bubbles

611
00:22:09,120 --> 00:22:13,200
only does in our tool is uh unusual in

612
00:22:13,200 --> 00:22:15,360
that it jumps back and forth a lot

613
00:22:15,360 --> 00:22:17,039
um

614
00:22:17,039 --> 00:22:20,559
but this could be changed uh just by how

615
00:22:20,559 --> 00:22:22,640
many transformations you apply

616
00:22:22,640 --> 00:22:24,240
if an attacker really wants they could

617
00:22:24,240 --> 00:22:26,159
play around with these configurations

618
00:22:26,159 --> 00:22:27,760
and also

619
00:22:27,760 --> 00:22:31,919
the jumping back and forth from assembly

620
00:22:31,919 --> 00:22:33,280
might not be

621
00:22:33,280 --> 00:22:36,080
that unusual if we're looking at a

622
00:22:36,080 --> 00:22:38,840
utility library if it's performing

623
00:22:38,840 --> 00:22:40,799
either grammar

624
00:22:40,799 --> 00:22:42,960
changing or arithmetic

625
00:22:42,960 --> 00:22:45,360
utilities which that they're we're doing

626
00:22:45,360 --> 00:22:47,679
in the real world now then these may

627
00:22:47,679 --> 00:22:49,280
also jump back and forth a lot and then

628
00:22:49,280 --> 00:22:51,360
an attacker could try to model this

629
00:22:51,360 --> 00:22:53,600
pattern in waffle skater makes sense

630
00:22:53,600 --> 00:22:54,480
thanks

631
00:22:54,480 --> 00:22:56,640
thanks okay so let's take the speaker

632
00:22:56,640 --> 00:22:59,640
again

