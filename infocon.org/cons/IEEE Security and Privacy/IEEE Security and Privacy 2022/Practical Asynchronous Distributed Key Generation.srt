1
00:00:00,080 --> 00:00:03,280
come again yes thank you again and

2
00:00:03,280 --> 00:00:04,799
i'll talk about now practical

3
00:00:04,799 --> 00:00:06,560
asynchronous distributed key generation

4
00:00:06,560 --> 00:00:09,120
protocol this is joint work with tom

5
00:00:09,120 --> 00:00:12,000
jalon andrew and ling from uiuc and left

6
00:00:12,000 --> 00:00:14,719
race from ist austria

7
00:00:14,719 --> 00:00:16,239
so this is kind of related to the

8
00:00:16,239 --> 00:00:18,640
previous talk as well

9
00:00:18,640 --> 00:00:20,560
this is the brief outline of my talk

10
00:00:20,560 --> 00:00:22,800
i'll first define the problem statement

11
00:00:22,800 --> 00:00:25,039
and give some background it'll be nice

12
00:00:25,039 --> 00:00:27,840
overview of consensus in general and

13
00:00:27,840 --> 00:00:29,439
i'll briefly talk about summary of

14
00:00:29,439 --> 00:00:31,359
results the main ideas and the

15
00:00:31,359 --> 00:00:35,360
evaluation and also some open problems

16
00:00:35,360 --> 00:00:37,120
awesome let's get started so

17
00:00:37,120 --> 00:00:39,040
asynchronous distributed key generation

18
00:00:39,040 --> 00:00:41,040
or a dkg is this problem which is

19
00:00:41,040 --> 00:00:43,680
parameterized by n t and l

20
00:00:43,680 --> 00:00:45,440
as you might have guessed n is the total

21
00:00:45,440 --> 00:00:47,840
number of nodes where n t is the maximum

22
00:00:47,840 --> 00:00:49,680
number of faulty nodes here we assume

23
00:00:49,680 --> 00:00:53,039
that t is up to one third and l is the

24
00:00:53,039 --> 00:00:55,600
reconstruction threshold of a secret

25
00:00:55,600 --> 00:00:57,600
well i'll explain what it is so this is

26
00:00:57,600 --> 00:00:59,359
the protocol among endnotes where up to

27
00:00:59,359 --> 00:01:00,399
one third of the nodes could be

28
00:01:00,399 --> 00:01:01,920
malicious

29
00:01:01,920 --> 00:01:03,760
such that at the end of the protocol

30
00:01:03,760 --> 00:01:05,760
every on every node outputs a common

31
00:01:05,760 --> 00:01:08,080
public key

32
00:01:08,080 --> 00:01:09,680
every node outputs a common public key

33
00:01:09,680 --> 00:01:11,119
pk

34
00:01:11,119 --> 00:01:12,799
and a secret share

35
00:01:12,799 --> 00:01:14,560
we have seen samishika sharing a secret

36
00:01:14,560 --> 00:01:18,080
share of the secret z so every node does

37
00:01:18,080 --> 00:01:19,680
that they have a common public key but

38
00:01:19,680 --> 00:01:21,920
they have an individual share

39
00:01:21,920 --> 00:01:24,880
we want to bootstrap such systems

40
00:01:24,880 --> 00:01:27,600
where gi's are n comma l threshold

41
00:01:27,600 --> 00:01:31,839
secret share of the secret z

42
00:01:32,479 --> 00:01:34,720
our system model for this paper is this

43
00:01:34,720 --> 00:01:36,400
we consider asynchronous systems where

44
00:01:36,400 --> 00:01:37,520
network

45
00:01:37,520 --> 00:01:39,680
network bounds could be unbounded but

46
00:01:39,680 --> 00:01:41,520
messages will eventually get delivered

47
00:01:41,520 --> 00:01:42,960
this is slightly

48
00:01:42,960 --> 00:01:47,119
more robust model than partial synchrony

49
00:01:47,119 --> 00:01:48,880
and we have setup in terms of setup

50
00:01:48,880 --> 00:01:50,640
requirements we again is on public key

51
00:01:50,640 --> 00:01:53,840
infrastructure and common random string

52
00:01:53,840 --> 00:01:56,560
so asynchronous dkg has or in dkg in

53
00:01:56,560 --> 00:01:58,799
general has many applications first is

54
00:01:58,799 --> 00:02:01,040
threshold signatures they are used in

55
00:02:01,040 --> 00:02:03,600
lots of like efficiency reasons in

56
00:02:03,600 --> 00:02:05,119
consensus algorithm like state machine

57
00:02:05,119 --> 00:02:07,200
replications they are also used in

58
00:02:07,200 --> 00:02:08,479
threshold wallets

59
00:02:08,479 --> 00:02:09,280
they're

60
00:02:09,280 --> 00:02:10,959
they they can be they can be used to

61
00:02:10,959 --> 00:02:12,720
bootstrap threshold encryption system

62
00:02:12,720 --> 00:02:14,400
and also randomness because we have seen

63
00:02:14,400 --> 00:02:15,440
there are many applications of

64
00:02:15,440 --> 00:02:17,040
randomness beacon as well i want to

65
00:02:17,040 --> 00:02:20,319
mention the cks05 example we have seen

66
00:02:20,319 --> 00:02:22,800
actually assumes dkg and then they do

67
00:02:22,800 --> 00:02:25,520
the rest of the thing

68
00:02:26,480 --> 00:02:28,560
i'll talk about background so we have

69
00:02:28,560 --> 00:02:29,840
seen threshold secret sharing in the

70
00:02:29,840 --> 00:02:31,760
last talk so i'll not go into this we

71
00:02:31,760 --> 00:02:34,400
have also seen verifiable secret sharing

72
00:02:34,400 --> 00:02:36,160
what we need in this paper is something

73
00:02:36,160 --> 00:02:37,680
called asynchronous complete secret

74
00:02:37,680 --> 00:02:40,000
sharing which is verifiable asynchronous

75
00:02:40,000 --> 00:02:41,599
variant of verifiable sql sharing with

76
00:02:41,599 --> 00:02:44,000
some extra extra properties for this

77
00:02:44,000 --> 00:02:46,080
talk we don't have to know the exact

78
00:02:46,080 --> 00:02:48,720
differences but you can think of that as

79
00:02:48,720 --> 00:02:50,480
asynchronous variant of verifiable sql

80
00:02:50,480 --> 00:02:52,640
sharing

81
00:02:52,640 --> 00:02:54,959
we need some other primitives one is

82
00:02:54,959 --> 00:02:56,319
reliable broadcast this is one of the

83
00:02:56,319 --> 00:02:58,000
classic primitives in asynchronous

84
00:02:58,000 --> 00:03:00,319
consensus and this is defined as follows

85
00:03:00,319 --> 00:03:03,360
so we have a dealer that has a message m

86
00:03:03,360 --> 00:03:05,680
and we want to run a protocol rbc on the

87
00:03:05,680 --> 00:03:07,599
message so that every node outputs the

88
00:03:07,599 --> 00:03:10,879
message at there in the protocol

89
00:03:10,879 --> 00:03:12,640
note the simple schemes where dealers

90
00:03:12,640 --> 00:03:15,120
simply multicast a message to everybody

91
00:03:15,120 --> 00:03:17,680
won't work in case of malicious dealer

92
00:03:17,680 --> 00:03:19,120
because a malicious dealer may send

93
00:03:19,120 --> 00:03:21,120
different message to different nodes and

94
00:03:21,120 --> 00:03:23,280
sometimes may not send any message at

95
00:03:23,280 --> 00:03:25,680
all so we want to broadcast primitive

96
00:03:25,680 --> 00:03:27,519
which is robust again malicious field

97
00:03:27,519 --> 00:03:30,400
against malicious failures

98
00:03:30,400 --> 00:03:32,480
more formally rbc requires these

99
00:03:32,480 --> 00:03:34,959
properties first is agreement it says if

100
00:03:34,959 --> 00:03:37,599
two honest node outputs a message they

101
00:03:37,599 --> 00:03:40,080
should output the same message

102
00:03:40,080 --> 00:03:42,080
we also need validity that says if the

103
00:03:42,080 --> 00:03:44,239
dealer is honest then at the end of the

104
00:03:44,239 --> 00:03:46,080
broadcast everybody outputs dealer's

105
00:03:46,080 --> 00:03:47,599
message so intuitively this is very

106
00:03:47,599 --> 00:03:50,080
similar to your first basic notion of

107
00:03:50,080 --> 00:03:52,000
broadcast that you can imagine

108
00:03:52,000 --> 00:03:54,319
and also need totality that says either

109
00:03:54,319 --> 00:03:56,080
all honest note outputs

110
00:03:56,080 --> 00:03:58,840
or nobody like everybody stays

111
00:03:58,840 --> 00:04:01,120
undecided this is slightly weaker than

112
00:04:01,120 --> 00:04:02,959
termination strong termination where

113
00:04:02,959 --> 00:04:04,640
everybody needs to always output we'll

114
00:04:04,640 --> 00:04:07,200
see what that is in the next slides

115
00:04:07,200 --> 00:04:09,439
so you also need asynchronous binary

116
00:04:09,439 --> 00:04:10,560
agreement

117
00:04:10,560 --> 00:04:12,319
which is a single bit asynchronous

118
00:04:12,319 --> 00:04:14,799
consensus protocol pictorially this is

119
00:04:14,799 --> 00:04:17,120
what it looked like looks like we have

120
00:04:17,120 --> 00:04:19,358
four nodes here everybody has a bit b1

121
00:04:19,358 --> 00:04:21,279
up to b4 one of the node could be

122
00:04:21,279 --> 00:04:24,320
malicious so they run a asynchronous

123
00:04:24,320 --> 00:04:25,840
binary agreement protocol or aba

124
00:04:25,840 --> 00:04:27,759
protocol so that at the end of the day

125
00:04:27,759 --> 00:04:30,720
protocol everybody outputs a bit

126
00:04:30,720 --> 00:04:33,040
we again want some properties first is

127
00:04:33,040 --> 00:04:34,960
agreement that says if two honest node

128
00:04:34,960 --> 00:04:37,120
outputs bit they should output the same

129
00:04:37,120 --> 00:04:38,960
bit always

130
00:04:38,960 --> 00:04:41,199
and the validity notion says if all

131
00:04:41,199 --> 00:04:43,360
honest nodes started with the common bit

132
00:04:43,360 --> 00:04:45,840
let's say b here then the aba protocol

133
00:04:45,840 --> 00:04:47,040
should output

134
00:04:47,040 --> 00:04:50,000
the same bit b

135
00:04:50,000 --> 00:04:51,840
and the third is termination it says the

136
00:04:51,840 --> 00:04:53,680
ava will eventually

137
00:04:53,680 --> 00:04:55,040
terminate doesn't matter what the

138
00:04:55,040 --> 00:04:56,639
adversary does the av should always

139
00:04:56,639 --> 00:04:58,080
terminate

140
00:04:58,080 --> 00:04:59,600
this is these are the properties that we

141
00:04:59,600 --> 00:05:01,440
want

142
00:05:01,440 --> 00:05:03,680
but for aba there is a very classic

143
00:05:03,680 --> 00:05:05,440
strong impossibility results that says

144
00:05:05,440 --> 00:05:07,360
deterministic consensus asynchronous

145
00:05:07,360 --> 00:05:09,759
consensus is impossible

146
00:05:09,759 --> 00:05:12,400
so aba is a single bit consensus even

147
00:05:12,400 --> 00:05:14,080
this is impossible in deterministic

148
00:05:14,080 --> 00:05:15,520
scenarios

149
00:05:15,520 --> 00:05:17,440
the way people get around this is to use

150
00:05:17,440 --> 00:05:19,199
a common coin to randomize this protocol

151
00:05:19,199 --> 00:05:20,400
so that they can

152
00:05:20,400 --> 00:05:23,360
with with a very like a

153
00:05:23,360 --> 00:05:24,960
strong probability

154
00:05:24,960 --> 00:05:29,039
the term the aba protocol terminates

155
00:05:29,440 --> 00:05:31,520
so this is the existing landscape of

156
00:05:31,520 --> 00:05:33,199
asynchronous distributed key generation

157
00:05:33,199 --> 00:05:35,840
protocol the first leakage protocol

158
00:05:35,840 --> 00:05:37,840
which is non-synchronous was from 2008

159
00:05:37,840 --> 00:05:40,000
which is in partial synchrony they again

160
00:05:40,000 --> 00:05:41,280
have very high communication costs

161
00:05:41,280 --> 00:05:43,680
copper and and to the fourth

162
00:05:43,680 --> 00:05:46,240
and round complexities order end rounds

163
00:05:46,240 --> 00:05:48,720
recall n is the number number of parties

164
00:05:48,720 --> 00:05:52,720
there was a recent work at ccs2019

165
00:05:52,720 --> 00:05:55,360
that is fully asynchronous but still has

166
00:05:55,360 --> 00:05:56,720
the same communication cost there are

167
00:05:56,720 --> 00:05:59,440
few follow-ups so last year

168
00:05:59,440 --> 00:06:01,120
they get good communication costs and

169
00:06:01,120 --> 00:06:03,120
also good round complexity but they have

170
00:06:03,120 --> 00:06:04,800
this issue where secret key is a group

171
00:06:04,800 --> 00:06:06,240
groupon group element this is a

172
00:06:06,240 --> 00:06:07,360
certainty

173
00:06:07,360 --> 00:06:09,919
what this prevents us from using this

174
00:06:09,919 --> 00:06:12,560
dkg with off the shelf like a threshold

175
00:06:12,560 --> 00:06:14,240
signature scheme like bls throttle

176
00:06:14,240 --> 00:06:16,240
signature scheme or like

177
00:06:16,240 --> 00:06:17,440
those kind of things so these are not

178
00:06:17,440 --> 00:06:20,080
very suitable for applications

179
00:06:20,080 --> 00:06:22,240
so what we want is a general purpose

180
00:06:22,240 --> 00:06:24,639
asynchronous dkg and this is what we get

181
00:06:24,639 --> 00:06:26,479
in our paper that has a communication

182
00:06:26,479 --> 00:06:28,560
cost of kappa and cube copper again is

183
00:06:28,560 --> 00:06:31,120
the security parameter and it takes our

184
00:06:31,120 --> 00:06:33,840
login rounds in expectation and also

185
00:06:33,840 --> 00:06:36,400
again assumes ddh r0 and pk in the

186
00:06:36,400 --> 00:06:38,720
standard crs model

187
00:06:38,720 --> 00:06:40,960
note that although we need order log n

188
00:06:40,960 --> 00:06:43,120
round expectation if the network behaves

189
00:06:43,120 --> 00:06:45,360
synchronously we get order one rounds in

190
00:06:45,360 --> 00:06:48,360
practice

191
00:06:49,680 --> 00:06:51,919
so we our paper says we are practical

192
00:06:51,919 --> 00:06:54,400
asynchronous dkg protocol so i just want

193
00:06:54,400 --> 00:06:56,880
to briefly highlight for example yeah

194
00:06:56,880 --> 00:06:59,840
for with 128 nodes if we want to run dkg

195
00:06:59,840 --> 00:07:01,440
our single threaded python

196
00:07:01,440 --> 00:07:03,680
implementation takes about

197
00:07:03,680 --> 00:07:06,319
50 seconds but there if we parallelize

198
00:07:06,319 --> 00:07:08,240
we can still get uh we will get much

199
00:07:08,240 --> 00:07:10,639
better i hope but i still feel there for

200
00:07:10,639 --> 00:07:12,479
certain parameters if the threshold is

201
00:07:12,479 --> 00:07:14,639
high the schemes still require a lot of

202
00:07:14,639 --> 00:07:15,919
work so there are a lot of scope for

203
00:07:15,919 --> 00:07:18,080
improving the dkg scheme at least either

204
00:07:18,080 --> 00:07:19,759
theoretically and also

205
00:07:19,759 --> 00:07:22,319
practically

206
00:07:23,039 --> 00:07:25,440
while designing a adkg we also designed

207
00:07:25,440 --> 00:07:27,120
something called another primitive which

208
00:07:27,120 --> 00:07:28,639
is asynchronous complete secret sharing

209
00:07:28,639 --> 00:07:31,120
for random secret so there are other

210
00:07:31,120 --> 00:07:33,599
protocols which have good communication

211
00:07:33,599 --> 00:07:35,840
cost like kappa and square and order n

212
00:07:35,840 --> 00:07:37,520
computation per node

213
00:07:37,520 --> 00:07:40,800
but these rogues have a css

214
00:07:40,800 --> 00:07:43,039
they which are not homomorphic and we

215
00:07:43,039 --> 00:07:44,960
crucially use this homomorphism property

216
00:07:44,960 --> 00:07:47,840
for our asynchronous dkg so to get that

217
00:07:47,840 --> 00:07:49,440
we have to design a new asynchronous

218
00:07:49,440 --> 00:07:50,879
complete sequel sharing protocol that

219
00:07:50,879 --> 00:07:52,560
maintains this com old communication

220
00:07:52,560 --> 00:07:54,400
cost and computation and also

221
00:07:54,400 --> 00:07:55,840
additionally provides

222
00:07:55,840 --> 00:07:57,520
homomorphism

223
00:07:57,520 --> 00:08:00,319
to to do so we end up paying like we i

224
00:08:00,319 --> 00:08:02,160
have to use like dcr decisional

225
00:08:02,160 --> 00:08:04,080
composite residue assumption we don't

226
00:08:04,080 --> 00:08:05,199
know how to do

227
00:08:05,199 --> 00:08:08,080
get these properties from ddh

228
00:08:08,080 --> 00:08:10,080
and this that's some good open problem

229
00:08:10,080 --> 00:08:12,319
to work on

230
00:08:12,319 --> 00:08:14,800
so let's now look at how generally dkg

231
00:08:14,800 --> 00:08:16,560
constructions work so this is the

232
00:08:16,560 --> 00:08:19,440
general dkg framework it it's same in

233
00:08:19,440 --> 00:08:20,800
synchrony asynchrony and partial

234
00:08:20,800 --> 00:08:22,720
synchrony as well

235
00:08:22,720 --> 00:08:25,120
so what happens is each node

236
00:08:25,120 --> 00:08:27,280
samples a random secret and shares it

237
00:08:27,280 --> 00:08:29,599
with using a verifiable secret sharing

238
00:08:29,599 --> 00:08:32,159
every node will do the same

239
00:08:32,159 --> 00:08:35,279
then what we do is at the end of the

240
00:08:35,279 --> 00:08:37,039
secret sharing phase

241
00:08:37,039 --> 00:08:38,719
nodes run a consensus algorithm to

242
00:08:38,719 --> 00:08:42,719
decide which vss terminated correctly

243
00:08:42,719 --> 00:08:44,480
and once they agree on the set of

244
00:08:44,480 --> 00:08:47,440
correct vss they simply add the

245
00:08:47,440 --> 00:08:49,200
corresponding secret and that's the

246
00:08:49,200 --> 00:08:51,519
secret key and the public key is g to

247
00:08:51,519 --> 00:08:53,519
the secret key and the consensus

248
00:08:53,519 --> 00:08:55,200
algorithm has to ensure

249
00:08:55,200 --> 00:08:57,760
oh okay sorry i am already one slide

250
00:08:57,760 --> 00:08:59,360
ahead so the consensus algorithm has to

251
00:08:59,360 --> 00:09:00,880
ensure that there are at least t plus

252
00:09:00,880 --> 00:09:03,120
one vs secrets you are

253
00:09:03,120 --> 00:09:04,640
introducing

254
00:09:04,640 --> 00:09:07,600
in the random secret final secret key

255
00:09:07,600 --> 00:09:09,680
as you have seen there is we have seen

256
00:09:09,680 --> 00:09:11,760
the impossibility impossibility result

257
00:09:11,760 --> 00:09:13,120
in asynchrony the deterministic

258
00:09:13,120 --> 00:09:15,839
consensus is impossible

259
00:09:15,839 --> 00:09:17,440
and more

260
00:09:17,440 --> 00:09:19,440
in more detail what happens is

261
00:09:19,440 --> 00:09:21,760
the asynchronous consensus oftentimes

262
00:09:21,760 --> 00:09:23,600
depends on common coin

263
00:09:23,600 --> 00:09:24,959
and

264
00:09:24,959 --> 00:09:26,640
here um

265
00:09:26,640 --> 00:09:28,160
and the common the way we generate

266
00:09:28,160 --> 00:09:29,600
common coin

267
00:09:29,600 --> 00:09:32,000
they typically require asynchronous dkg

268
00:09:32,000 --> 00:09:34,080
as a trusted set of phase and here we

269
00:09:34,080 --> 00:09:36,720
see that asynchronous dkg indeed depends

270
00:09:36,720 --> 00:09:39,440
on uh requires consensus so we see a

271
00:09:39,440 --> 00:09:41,120
circularity here and

272
00:09:41,120 --> 00:09:43,440
most of the work in asynchronous ekg

273
00:09:43,440 --> 00:09:45,279
goes in here like how do you get this

274
00:09:45,279 --> 00:09:47,680
circularity break this circularity and

275
00:09:47,680 --> 00:09:49,680
this is what i'll focus most in most of

276
00:09:49,680 --> 00:09:51,839
my talk

277
00:09:51,839 --> 00:09:54,320
so this is our approach in general so we

278
00:09:54,320 --> 00:09:56,720
have n equal to three t plus one

279
00:09:56,720 --> 00:09:59,040
we have four phases again sharing key

280
00:09:59,040 --> 00:10:02,160
proposal agreement and key derivation

281
00:10:02,160 --> 00:10:03,920
i'll mostly focus on the agreement phase

282
00:10:03,920 --> 00:10:05,440
because that's the most interesting part

283
00:10:05,440 --> 00:10:06,560
of our

284
00:10:06,560 --> 00:10:08,800
protocol

285
00:10:08,800 --> 00:10:11,040
sharing phases as usual

286
00:10:11,040 --> 00:10:13,920
everybody samples a random secret and

287
00:10:13,920 --> 00:10:16,480
they share the random secret using acss

288
00:10:16,480 --> 00:10:18,160
asynchronous complete sql sharing which

289
00:10:18,160 --> 00:10:19,760
has slightly stronger properties than

290
00:10:19,760 --> 00:10:22,640
vss or abs

291
00:10:22,640 --> 00:10:25,360
then this acs terminate we are working

292
00:10:25,360 --> 00:10:27,040
in asynchrony so it might happen that

293
00:10:27,040 --> 00:10:28,959
this acss instances terminate in

294
00:10:28,959 --> 00:10:30,480
different orders at different nodes

295
00:10:30,480 --> 00:10:32,079
because we have no bounce on message

296
00:10:32,079 --> 00:10:33,839
delays they made they might see

297
00:10:33,839 --> 00:10:36,000
different order in how this acs

298
00:10:36,000 --> 00:10:37,120
terminates

299
00:10:37,120 --> 00:10:39,120
let's say

300
00:10:39,120 --> 00:10:41,200
at node one acss one and three

301
00:10:41,200 --> 00:10:43,040
terminates node two two and three and

302
00:10:43,040 --> 00:10:44,560
node three one and three so they have

303
00:10:44,560 --> 00:10:46,399
different view on which acs is

304
00:10:46,399 --> 00:10:49,519
terminated so this is the sharing phase

305
00:10:49,519 --> 00:10:51,360
then we have this key proposal phase

306
00:10:51,360 --> 00:10:52,959
which is an extra step that we

307
00:10:52,959 --> 00:10:54,800
introduced where

308
00:10:54,800 --> 00:10:57,120
each node then reliably broadcast

309
00:10:57,120 --> 00:10:59,440
the set of ac cells that terminated at

310
00:10:59,440 --> 00:11:02,240
that particular node for example node 1

311
00:11:02,240 --> 00:11:04,399
will reliably broadcast t1 node 2 will

312
00:11:04,399 --> 00:11:06,160
drive your broadcast this set t2 and

313
00:11:06,160 --> 00:11:08,959
similarly t3

314
00:11:08,959 --> 00:11:11,200
then again due to asynchrony this

315
00:11:11,200 --> 00:11:12,800
reliable broadcast instances may

316
00:11:12,800 --> 00:11:14,959
terminate in different order and at

317
00:11:14,959 --> 00:11:16,880
different latencies

318
00:11:16,880 --> 00:11:19,120
so what these node does then they just

319
00:11:19,120 --> 00:11:21,760
create a vector now instead of a set of

320
00:11:21,760 --> 00:11:24,160
all the rbc instances that terminated at

321
00:11:24,160 --> 00:11:26,160
those nodes for example

322
00:11:26,160 --> 00:11:29,120
node one will create this vector t1 t2

323
00:11:29,120 --> 00:11:30,800
that means these two are reliable

324
00:11:30,800 --> 00:11:32,959
broadcast terminated at node one and the

325
00:11:32,959 --> 00:11:34,800
remaining two are yet to terminate they

326
00:11:34,800 --> 00:11:37,680
are undecided on that similarly node two

327
00:11:37,680 --> 00:11:38,560
here

328
00:11:38,560 --> 00:11:41,360
rbc two and rbc3 terminates so node 2

329
00:11:41,360 --> 00:11:43,920
has these two nonzero non-bought values

330
00:11:43,920 --> 00:11:46,640
and other bot values so this is the key

331
00:11:46,640 --> 00:11:49,600
proposal phase in our protocol

332
00:11:49,600 --> 00:11:52,320
then we go on to the agreement phase

333
00:11:52,320 --> 00:11:54,079
now instead of running a single

334
00:11:54,079 --> 00:11:56,480
consensus algorithm we now run in our

335
00:11:56,480 --> 00:11:58,320
paper n parallel

336
00:11:58,320 --> 00:12:00,959
binary agreement protocols and here the

337
00:12:00,959 --> 00:12:02,800
ith binary agreement protocol wants to

338
00:12:02,800 --> 00:12:03,839
decide

339
00:12:03,839 --> 00:12:05,760
whether the

340
00:12:05,760 --> 00:12:08,639
ith rbc terminated successfully or not

341
00:12:08,639 --> 00:12:11,200
so since there are total n rbcs we need

342
00:12:11,200 --> 00:12:14,240
n abs

343
00:12:14,399 --> 00:12:17,120
in this aba protocol a node this is how

344
00:12:17,120 --> 00:12:20,320
a node inputs values for all rbcs that

345
00:12:20,320 --> 00:12:22,240
terminated at that particular node it

346
00:12:22,240 --> 00:12:25,519
inputs one so here at node one t1 and t2

347
00:12:25,519 --> 00:12:28,240
terminated so they it inputs one to aba1

348
00:12:28,240 --> 00:12:30,959
and aba2 and it avoids inputting

349
00:12:30,959 --> 00:12:33,279
anything to the remaining abs and this

350
00:12:33,279 --> 00:12:36,240
is for a technical reason

351
00:12:36,240 --> 00:12:38,399
similarly node two inputs one two a b a

352
00:12:38,399 --> 00:12:40,240
two and a b a three n

353
00:12:40,240 --> 00:12:41,839
does not input anything

354
00:12:41,839 --> 00:12:43,600
in the remaining abs node three also

355
00:12:43,600 --> 00:12:45,279
does the same

356
00:12:45,279 --> 00:12:48,000
now but now i'm cheating right we cannot

357
00:12:48,000 --> 00:12:49,760
simply run the aba protocol because we

358
00:12:49,760 --> 00:12:51,440
have no way of generating common coin

359
00:12:51,440 --> 00:12:53,519
and we have seen this circularity issues

360
00:12:53,519 --> 00:12:55,519
and this is one thing that we should

361
00:12:55,519 --> 00:12:57,120
take away from our talk is how we

362
00:12:57,120 --> 00:12:59,680
address this issue and the main idea is

363
00:12:59,680 --> 00:13:02,800
so we have this ti's sets which are set

364
00:13:02,800 --> 00:13:04,800
of acss synthesis that terminated at

365
00:13:04,800 --> 00:13:06,720
that particular node and if we ensure

366
00:13:06,720 --> 00:13:09,040
this acs this set is large let's say

367
00:13:09,040 --> 00:13:11,120
contains more than t plus one

368
00:13:11,120 --> 00:13:14,320
um shares then we can use we use this

369
00:13:14,320 --> 00:13:16,320
ti to generate common coin for that

370
00:13:16,320 --> 00:13:19,200
particular aba for example we for aba1

371
00:13:19,200 --> 00:13:22,079
we use this t1 as a source of entropy

372
00:13:22,079 --> 00:13:24,160
like we use this d1 to generate common

373
00:13:24,160 --> 00:13:27,279
coin for aba1 similarly d2 for a common

374
00:13:27,279 --> 00:13:29,680
coin to generate common coin for aba 2

375
00:13:29,680 --> 00:13:31,279
and

376
00:13:31,279 --> 00:13:32,959
same as t3

377
00:13:32,959 --> 00:13:35,200
this is how i address this circularity

378
00:13:35,200 --> 00:13:36,800
issue but there is also one more

379
00:13:36,800 --> 00:13:38,000
subtlety

380
00:13:38,000 --> 00:13:39,920
what if there are no ti's for certain

381
00:13:39,920 --> 00:13:41,279
eye for example

382
00:13:41,279 --> 00:13:42,399
here

383
00:13:42,399 --> 00:13:45,440
for aba 4 the fourth node is malicious

384
00:13:45,440 --> 00:13:47,600
so it did not rbc reliability broadcast

385
00:13:47,600 --> 00:13:49,600
anything so there is no

386
00:13:49,600 --> 00:13:52,800
no ti for this aba 4. so how will this

387
00:13:52,800 --> 00:13:54,959
aba 4 terminate so this is one thing

388
00:13:54,959 --> 00:13:56,639
that we have to address and we'll come

389
00:13:56,639 --> 00:13:59,440
back to this later

390
00:13:59,680 --> 00:14:00,880
let's say

391
00:14:00,880 --> 00:14:03,279
the good abas which are aba one two and

392
00:14:03,279 --> 00:14:05,360
three among them aba two terminated with

393
00:14:05,360 --> 00:14:06,800
one

394
00:14:06,800 --> 00:14:09,519
then the node once one of the aba

395
00:14:09,519 --> 00:14:11,920
terminates with one the node inputs zero

396
00:14:11,920 --> 00:14:13,920
to the remaining abs so node one now

397
00:14:13,920 --> 00:14:16,800
inputs zero to aba 3 and aba 4

398
00:14:16,800 --> 00:14:20,479
node 2 and node 3 also does the same

399
00:14:21,199 --> 00:14:23,199
let's say first three a b is terminated

400
00:14:23,199 --> 00:14:24,880
two of them outputted one and one of

401
00:14:24,880 --> 00:14:27,920
them output outputs zero

402
00:14:27,920 --> 00:14:29,680
now we come back to this problem again

403
00:14:29,680 --> 00:14:33,040
there are no ti's for aba four how do we

404
00:14:33,040 --> 00:14:35,040
ensure this avf fourth aba will also

405
00:14:35,040 --> 00:14:37,199
terminate so this is our another

406
00:14:37,199 --> 00:14:38,880
important observation we observe that

407
00:14:38,880 --> 00:14:41,199
this we call good case coin free and

408
00:14:41,199 --> 00:14:42,720
this is the property we observe that

409
00:14:42,720 --> 00:14:45,120
this flp impossibility applies when

410
00:14:45,120 --> 00:14:47,440
honest nodes have different inputs

411
00:14:47,440 --> 00:14:49,199
and the certainty here is that if all

412
00:14:49,199 --> 00:14:51,440
honest nodes start with the same input

413
00:14:51,440 --> 00:14:53,199
then an aba can terminate

414
00:14:53,199 --> 00:14:54,800
deterministically without using any

415
00:14:54,800 --> 00:14:57,199
common coin now let's look at

416
00:14:57,199 --> 00:14:59,600
four since there are no ti's all honest

417
00:14:59,600 --> 00:15:02,320
node will input zero to the fourth aba

418
00:15:02,320 --> 00:15:03,839
as a result this fourth able

419
00:15:03,839 --> 00:15:06,560
deterministically output zero and hence

420
00:15:06,560 --> 00:15:08,560
we can run this finish this aba without

421
00:15:08,560 --> 00:15:10,560
using any common coin and this lets us

422
00:15:10,560 --> 00:15:12,959
go beyond the fact that there is no ti

423
00:15:12,959 --> 00:15:14,800
for the fourth avi like t4 for the

424
00:15:14,800 --> 00:15:17,440
fourth ab this is another subtle

425
00:15:17,440 --> 00:15:21,120
crucial observation of our paper

426
00:15:21,360 --> 00:15:23,120
and finally we have this key derivation

427
00:15:23,120 --> 00:15:24,959
phase where we looked at all the abas

428
00:15:24,959 --> 00:15:27,519
that terminated with one and just take

429
00:15:27,519 --> 00:15:29,440
the union or any deterministic function

430
00:15:29,440 --> 00:15:31,120
of their key sets

431
00:15:31,120 --> 00:15:34,000
and then derive the secret key as like

432
00:15:34,000 --> 00:15:36,320
here the union set is one two three so

433
00:15:36,320 --> 00:15:38,959
the secret key is s1 plus s2 plus s3 and

434
00:15:38,959 --> 00:15:40,800
the public key is h to the h trace to

435
00:15:40,800 --> 00:15:43,439
the secret key

436
00:15:43,920 --> 00:15:46,480
so we also implement our protocol we do

437
00:15:46,480 --> 00:15:48,320
a single threaded python implementation

438
00:15:48,320 --> 00:15:49,839
this is more of a proof of concept

439
00:15:49,839 --> 00:15:51,519
implementation

440
00:15:51,519 --> 00:15:54,240
and we we use a rust implementation for

441
00:15:54,240 --> 00:15:57,279
elliptic curve operation

442
00:15:57,519 --> 00:15:59,600
our our implementation supports both

443
00:15:59,600 --> 00:16:02,880
curve 25519 and bls 12 381 elliptic

444
00:16:02,880 --> 00:16:05,759
curves we we do this because the later

445
00:16:05,759 --> 00:16:07,360
supports pairing and bls threshold

446
00:16:07,360 --> 00:16:09,199
signatures uses pairing so we thought if

447
00:16:09,199 --> 00:16:10,959
we want to use if you want to use our

448
00:16:10,959 --> 00:16:13,519
dkg for pairing based signatures it

449
00:16:13,519 --> 00:16:15,759
might might well it should support

450
00:16:15,759 --> 00:16:18,079
pairing based curves

451
00:16:18,079 --> 00:16:19,680
our protocol can support any

452
00:16:19,680 --> 00:16:21,839
reconstruction threshold from t plus 1

453
00:16:21,839 --> 00:16:24,079
to n minus t and a reconstruction

454
00:16:24,079 --> 00:16:25,759
threshold of n minus t is very important

455
00:16:25,759 --> 00:16:27,440
for efficiency in state machine

456
00:16:27,440 --> 00:16:29,920
application protocol such as

457
00:16:29,920 --> 00:16:31,759
hot stuff

458
00:16:31,759 --> 00:16:34,160
we evaluate our protocol using awcc2 and

459
00:16:34,160 --> 00:16:37,440
synthesis and our code is public here

460
00:16:37,440 --> 00:16:38,800
let's look at our evaluations we have

461
00:16:38,800 --> 00:16:42,399
looked at the runtime with 128 nodes we

462
00:16:42,399 --> 00:16:44,399
can for low threshold where the

463
00:16:44,399 --> 00:16:46,160
threshold is t plus one

464
00:16:46,160 --> 00:16:48,880
we we only take about 45 seconds to run

465
00:16:48,880 --> 00:16:51,040
80 kg but with high threshold even with

466
00:16:51,040 --> 00:16:53,120
64 node our runtime single threaded

467
00:16:53,120 --> 00:16:55,279
runtime score beyond 150 seconds we'll

468
00:16:55,279 --> 00:16:56,639
see the reason

469
00:16:56,639 --> 00:16:59,839
in in a slide later

470
00:16:59,839 --> 00:17:01,360
we also

471
00:17:01,360 --> 00:17:03,279
measured the bandwidth users

472
00:17:03,279 --> 00:17:06,240
and so with 128 nodes with low threshold

473
00:17:06,240 --> 00:17:08,240
per node bandwidth uses is about 12

474
00:17:08,240 --> 00:17:10,160
megabytes this is still high and there

475
00:17:10,160 --> 00:17:12,720
we feel we can improve this

476
00:17:12,720 --> 00:17:15,280
with lots of optimization

477
00:17:15,280 --> 00:17:16,240
so the

478
00:17:16,240 --> 00:17:19,439
high run time of our dkg is due to

479
00:17:19,439 --> 00:17:21,760
the competition cost of a css phase that

480
00:17:21,760 --> 00:17:23,439
we use

481
00:17:23,439 --> 00:17:25,760
we for low threshold we use this asus

482
00:17:25,760 --> 00:17:26,959
from

483
00:17:26,959 --> 00:17:29,039
our ccs paper

484
00:17:29,039 --> 00:17:30,799
and for high threshold we use our new

485
00:17:30,799 --> 00:17:32,960
acs protocol

486
00:17:32,960 --> 00:17:35,120
and here the computation cost if you see

487
00:17:35,120 --> 00:17:36,559
with high threshold

488
00:17:36,559 --> 00:17:39,200
with n equals to 64 the competition cost

489
00:17:39,200 --> 00:17:42,400
of acs itself is like 125 seconds and

490
00:17:42,400 --> 00:17:45,280
that's why we get 150 seconds of time

491
00:17:45,280 --> 00:17:48,000
because the access cost takes longer and

492
00:17:48,000 --> 00:17:49,520
the remaining custom

493
00:17:49,520 --> 00:17:52,160
reasonably efficient

494
00:17:52,160 --> 00:17:54,480
so in summary we have a new adkg

495
00:17:54,480 --> 00:17:56,559
protocol with communication cost of

496
00:17:56,559 --> 00:17:59,280
kappa and cube and computation per node

497
00:17:59,280 --> 00:18:01,600
worst case computation order and cube

498
00:18:01,600 --> 00:18:03,679
but in practice we see order n square

499
00:18:03,679 --> 00:18:04,400
for

500
00:18:04,400 --> 00:18:06,400
some technical reasons we also have

501
00:18:06,400 --> 00:18:08,480
round complexity of order log n

502
00:18:08,480 --> 00:18:10,480
we also have a new homomorphic high

503
00:18:10,480 --> 00:18:13,039
threshold acs scheme

504
00:18:13,039 --> 00:18:14,640
our implementation is the first

505
00:18:14,640 --> 00:18:17,120
asynchronous dkg implementation

506
00:18:17,120 --> 00:18:19,440
there are lots of open problems again

507
00:18:19,440 --> 00:18:21,679
one is to one crucial open problem is to

508
00:18:21,679 --> 00:18:23,760
improve the high threshold css scheme

509
00:18:23,760 --> 00:18:25,280
because that's kind of the bottleneck in

510
00:18:25,280 --> 00:18:27,360
our dkg protocol

511
00:18:27,360 --> 00:18:28,960
and also they reduce the worst case

512
00:18:28,960 --> 00:18:31,120
round complexity to order one there are

513
00:18:31,120 --> 00:18:32,720
some theoretical ways of doing it if

514
00:18:32,720 --> 00:18:34,080
you're interested i can talk about it

515
00:18:34,080 --> 00:18:36,960
later but i i like if there are some

516
00:18:36,960 --> 00:18:38,640
cleaner ways of doing getting these

517
00:18:38,640 --> 00:18:39,919
results

518
00:18:39,919 --> 00:18:41,520
and also reduce the worst case

519
00:18:41,520 --> 00:18:43,440
computation cost to order n square now

520
00:18:43,440 --> 00:18:45,280
in in practice we see our n square but

521
00:18:45,280 --> 00:18:46,880
in the worst case it can still be order

522
00:18:46,880 --> 00:18:48,240
n cubed

523
00:18:48,240 --> 00:18:51,360
and also for atkg we don't know lower

524
00:18:51,360 --> 00:18:52,799
bound results and it will be interesting

525
00:18:52,799 --> 00:18:54,880
to see if we can get some lower bound

526
00:18:54,880 --> 00:18:57,280
results for our paper for

527
00:18:57,280 --> 00:19:00,000
80kg primitive in general

528
00:19:00,000 --> 00:19:02,160
and also one of the interesting problem

529
00:19:02,160 --> 00:19:04,480
would be to implement it in like a more

530
00:19:04,480 --> 00:19:06,000
robust and multi-threaded way and see

531
00:19:06,000 --> 00:19:08,720
what will be the actual performance

532
00:19:08,720 --> 00:19:11,280
and again here are a list of my

533
00:19:11,280 --> 00:19:13,840
collaborators and ling is also here if

534
00:19:13,840 --> 00:19:15,760
you have any question you can ask me or

535
00:19:15,760 --> 00:19:19,130
my advisor and thank you again

536
00:19:19,130 --> 00:19:23,440
[Applause]

537
00:19:23,440 --> 00:19:26,160
okay thank you suraf and again we have

538
00:19:26,160 --> 00:19:30,120
time for a few questions

539
00:19:38,240 --> 00:19:40,240
um thanks for the talk it's just to

540
00:19:40,240 --> 00:19:43,039
clarify so the login round

541
00:19:43,039 --> 00:19:44,720
time comes from the fact that you need

542
00:19:44,720 --> 00:19:47,600
to wait for these byzantine agreements

543
00:19:47,600 --> 00:19:50,000
to finish and each one takes expected

544
00:19:50,000 --> 00:19:53,280
constant yes yeah okay so can you break

545
00:19:53,280 --> 00:19:56,000
down the communication in cube like

546
00:19:56,000 --> 00:19:58,080
which piece comes from which component

547
00:19:58,080 --> 00:20:00,799
why is there the communication product

548
00:20:00,799 --> 00:20:01,760
like

549
00:20:01,760 --> 00:20:04,320
which piece contributes to the n-cube

550
00:20:04,320 --> 00:20:06,799
complexity so

551
00:20:06,799 --> 00:20:08,000
now here

552
00:20:08,000 --> 00:20:10,799
all the pieces even these each acss is n

553
00:20:10,799 --> 00:20:12,960
square so we run n a css in parallel so

554
00:20:12,960 --> 00:20:15,840
it's n cube even if each rbc is n square

555
00:20:15,840 --> 00:20:16,880
so and

556
00:20:16,880 --> 00:20:19,840
rbc is similarly abs each a n square so

557
00:20:19,840 --> 00:20:21,760
we get n cube so

558
00:20:21,760 --> 00:20:23,919
it seems really hard to me that we can

559
00:20:23,919 --> 00:20:26,240
get beyond this n cube bounce

560
00:20:26,240 --> 00:20:27,919
but i i don't know any lower bounds as

561
00:20:27,919 --> 00:20:29,039
well yeah

562
00:20:29,039 --> 00:20:32,280
thank you

563
00:20:34,799 --> 00:20:38,320
okay any more questions

564
00:20:39,679 --> 00:20:42,559
if not we are done with the first to

565
00:20:42,559 --> 00:20:43,440
talk

566
00:20:43,440 --> 00:20:45,160
thanks a lot so love

567
00:20:45,160 --> 00:20:49,319
[Applause]

