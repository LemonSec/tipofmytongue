1
00:00:00,410 --> 00:00:05,220
<font color="#E5E5E5">Thanks I'm Karthik this is work joint</font>

2
00:00:03,479 --> 00:00:17,460
work with a bunch<font color="#E5E5E5"> of photos from a bunch</font>

3
00:00:05,220 --> 00:00:19,859
<font color="#E5E5E5">of places</font><font color="#CCCCCC"> alright that's good alright so</font>

4
00:00:17,460 --> 00:00:20,910
I've got a not too much time so I'll try

5
00:00:19,859 --> 00:00:23,009
to give you a sense of what you've been

6
00:00:20,910 --> 00:00:24,720
doing<font color="#E5E5E5"> and what you done for this work</font>

7
00:00:23,009 --> 00:00:26,369
but I'd also encourage you to go<font color="#E5E5E5"> to that</font>

8
00:00:24,720 --> 00:00:28,079
website over there smack TLS<font color="#E5E5E5"> calm it's</font>

9
00:00:26,369 --> 00:00:29,400
got some fun demo videos that you might

10
00:00:28,079 --> 00:00:33,060
enjoy watching perhaps<font color="#E5E5E5"> more than</font>

11
00:00:29,400 --> 00:00:35,040
listening to me<font color="#E5E5E5"> alright so the problem</font>

12
00:00:33,060 --> 00:00:37,410
is trying to<font color="#E5E5E5"> address here is how to</font>

13
00:00:35,040 --> 00:00:39,420
implement correctly agile cryptographic

14
00:00:37,410 --> 00:00:42,510
protocols by which I mean protocols like

15
00:00:39,420 --> 00:00:43,830
TLS SSH<font color="#CCCCCC"> Ike which are really</font><font color="#E5E5E5"> not</font>

16
00:00:42,510 --> 00:00:45,449
protocols in themselves but protocol

17
00:00:43,830 --> 00:00:47,430
frameworks because they allow the client

18
00:00:45,450 --> 00:00:49,320
and<font color="#E5E5E5"> the server to negotiate a large</font>

19
00:00:47,430 --> 00:00:50,790
variety of crypto parameters you can you

20
00:00:49,320 --> 00:00:52,410
can negotiate what key exchange we're

21
00:00:50,790 --> 00:00:53,730
going to use what encryption scheme we

22
00:00:52,410 --> 00:00:55,410
are going to use<font color="#E5E5E5"> what an authentication</font>

23
00:00:53,730 --> 00:00:57,599
mechanism you're going to use in the

24
00:00:55,410 --> 00:00:58,680
protocol while we are<font color="#E5E5E5"> running it</font><font color="#CCCCCC"> all</font>

25
00:00:57,600 --> 00:01:00,480
<font color="#CCCCCC">right so how do you implement these</font>

26
00:00:58,680 --> 00:01:02,550
correctly and what goes wrong if<font color="#CCCCCC"> you</font>

27
00:01:00,480 --> 00:01:03,900
don't do<font color="#E5E5E5"> it correctly the protocols</font><font color="#CCCCCC"> I'm</font>

28
00:01:02,550 --> 00:01:05,280
<font color="#E5E5E5">going to look at today is transport</font>

29
00:01:03,900 --> 00:01:08,880
layer security we all know this as the

30
00:01:05,280 --> 00:01:10,229
protocol behind HTTPS it's old protocol

31
00:01:08,880 --> 00:01:12,030
more than 20 years<font color="#E5E5E5"> old many many</font>

32
00:01:10,229 --> 00:01:13,710
versions and this is important because

33
00:01:12,030 --> 00:01:16,289
it means that the protocol and<font color="#E5E5E5"> its</font>

34
00:01:13,710 --> 00:01:17,999
implementations have a ton of churn so

35
00:01:16,289 --> 00:01:20,159
there's new features coming in and old

36
00:01:17,999 --> 00:01:21,420
features getting obsolete and sometimes

37
00:01:20,159 --> 00:01:23,999
there's a lot of legacy features that

38
00:01:21,420 --> 00:01:25,740
you have to deal with there are dozens

39
00:01:23,999 --> 00:01:27,539
of implementations which<font color="#E5E5E5"> I discover to</font>

40
00:01:25,740 --> 00:01:29,999
my surprise<font color="#E5E5E5"> when doing this work and</font>

41
00:01:27,539 --> 00:01:31,740
there are many<font color="#E5E5E5"> security theorems nice</font>

42
00:01:29,999 --> 00:01:33,810
security theorems except that the

43
00:01:31,740 --> 00:01:35,100
security theorems often are not for the

44
00:01:33,810 --> 00:01:37,020
artifacts that we care about which is

45
00:01:35,100 --> 00:01:38,669
<font color="#CCCCCC">the implementations so some of this work</font>

46
00:01:37,020 --> 00:01:40,560
is<font color="#E5E5E5"> really going</font><font color="#CCCCCC"> to try</font><font color="#E5E5E5"> to figure out</font>

47
00:01:38,670 --> 00:01:42,749
<font color="#E5E5E5">what is there in the space between what</font>

48
00:01:40,560 --> 00:01:45,659
is proved and what we<font color="#CCCCCC"> actually want to</font>

49
00:01:42,749 --> 00:01:47,929
run what are implementations so the

50
00:01:45,659 --> 00:01:50,039
protocol itself is well I think<font color="#E5E5E5"> we've</font>

51
00:01:47,929 --> 00:01:51,149
seen it<font color="#E5E5E5"> in many places but it's good to</font>

52
00:01:50,039 --> 00:01:52,619
<font color="#E5E5E5">kind of look at the structure this</font>

53
00:01:51,149 --> 00:01:54,119
begins with a negotiation phase called

54
00:01:52,619 --> 00:01:56,130
hello where the client<font color="#E5E5E5"> and the server</font>

55
00:01:54,119 --> 00:01:58,679
agree upon what protocol<font color="#E5E5E5"> they going to</font>

56
00:01:56,130 --> 00:02:00,630
run then there<font color="#CCCCCC"> is a key exchange phase</font>

57
00:01:58,679 --> 00:02:02,939
where the two parties contribute key

58
00:02:00,630 --> 00:02:04,889
materials in order to get session Keys

59
00:02:02,939 --> 00:02:06,898
set up and then there<font color="#CCCCCC"> is a key</font>

60
00:02:04,889 --> 00:02:08,250
confirmation phase called finished where

61
00:02:06,899 --> 00:02:10,019
the<font color="#E5E5E5"> client and the server kind of</font>

62
00:02:08,250 --> 00:02:11,670
exchanged the entire transcript to make

63
00:02:10,019 --> 00:02:13,740
sure they are<font color="#E5E5E5"> both on the same</font><font color="#CCCCCC"> page and</font>

64
00:02:11,670 --> 00:02:15,660
then they start encrypting data towards

65
00:02:13,740 --> 00:02:17,850
each other so this<font color="#CCCCCC"> is a very sort</font><font color="#E5E5E5"> of</font>

66
00:02:15,660 --> 00:02:19,470
uniform framework and there are<font color="#CCCCCC"> many</font>

67
00:02:17,850 --> 00:02:21,150
different instantiations of it so the

68
00:02:19,470 --> 00:02:22,859
most common one for<font color="#CCCCCC"> example might be you</font>

69
00:02:21,150 --> 00:02:24,720
might want to do RSA key transport in

70
00:02:22,860 --> 00:02:26,580
which case in the middle chem phase the

71
00:02:24,720 --> 00:02:27,990
authenticated key exchange phase the

72
00:02:26,580 --> 00:02:29,910
client is going to encrypt something for

73
00:02:27,990 --> 00:02:31,320
the server and send it over or you might

74
00:02:29,910 --> 00:02:33,140
want<font color="#CCCCCC"> to do a few Hellman basically</font>

75
00:02:31,320 --> 00:02:35,190
exchange in which case the rest of the

76
00:02:33,140 --> 00:02:37,230
framework doesn't change<font color="#E5E5E5"> it's pretty</font>

77
00:02:35,190 --> 00:02:38,790
uniform it's just that in the middle in

78
00:02:37,230 --> 00:02:40,140
the<font color="#E5E5E5"> chem phase we decide to do something</font>

79
00:02:38,790 --> 00:02:42,060
<font color="#E5E5E5">else which is that we do a proper</font>

80
00:02:40,140 --> 00:02:43,799
diffie-hellman key exchange so this just

81
00:02:42,060 --> 00:02:45,150
to illustrate that there's a large part

82
00:02:43,800 --> 00:02:46,920
of<font color="#E5E5E5"> the protocol framework which is</font>

83
00:02:45,150 --> 00:02:49,020
shared and some bits you<font color="#CCCCCC"> can pull out</font>

84
00:02:46,920 --> 00:02:50,070
and replace with others and this is

85
00:02:49,020 --> 00:02:52,470
where the kind of<font color="#E5E5E5"> the composition</font>

86
00:02:50,070 --> 00:02:54,600
question<font color="#E5E5E5"> starts coming in so suppose</font><font color="#CCCCCC"> i</font>

87
00:02:52,470 --> 00:02:55,740
<font color="#CCCCCC">wrote that state machine for for the RSA</font>

88
00:02:54,600 --> 00:02:56,910
key exchange which is the one on the

89
00:02:55,740 --> 00:02:58,770
Left which is like a sequence of

90
00:02:56,910 --> 00:03:00,240
messages<font color="#E5E5E5"> that I expect to</font><font color="#CCCCCC"> send and</font>

91
00:02:58,770 --> 00:03:01,260
receive and I write another state

92
00:03:00,240 --> 00:03:03,240
machine for<font color="#E5E5E5"> the diffie-hellman key</font>

93
00:03:01,260 --> 00:03:04,920
exchange in<font color="#E5E5E5"> the middle you'll see that</font>

94
00:03:03,240 --> 00:03:06,390
most of the messages<font color="#E5E5E5"> look similar the</font>

95
00:03:04,920 --> 00:03:07,739
only real difference is that there's one

96
00:03:06,390 --> 00:03:09,540
<font color="#E5E5E5">extra message the server key exchange</font>

97
00:03:07,740 --> 00:03:10,920
message which is a which is<font color="#E5E5E5"> the one</font><font color="#CCCCCC"> in</font>

98
00:03:09,540 --> 00:03:13,679
the Oval if you are sitting at<font color="#E5E5E5"> the back</font>

99
00:03:10,920 --> 00:03:16,470
which is new in the defilement key

100
00:03:13,680 --> 00:03:17,790
exchange so we can<font color="#E5E5E5"> really share a lot of</font>

101
00:03:16,470 --> 00:03:20,609
<font color="#CCCCCC">the processing code for the different</font>

102
00:03:17,790 --> 00:03:22,859
messages and that's what you know mostly

103
00:03:20,610 --> 00:03:24,540
TLS implementations do so to combine

104
00:03:22,860 --> 00:03:26,460
those two state machines one way of

105
00:03:24,540 --> 00:03:27,660
doing this is well<font color="#E5E5E5"> okay what you're</font>

106
00:03:26,460 --> 00:03:29,160
going to do is keep the<font color="#E5E5E5"> same tape</font>

107
00:03:27,660 --> 00:03:31,230
machine with one conditional branch

108
00:03:29,160 --> 00:03:32,850
after the server certificate if it is

109
00:03:31,230 --> 00:03:34,049
our essay i'm going to skip the silver

110
00:03:32,850 --> 00:03:36,060
key exchange otherwise<font color="#E5E5E5"> i'm going to go</font>

111
00:03:34,050 --> 00:03:37,800
straight to so<font color="#E5E5E5"> this is a very simple</font>

112
00:03:36,060 --> 00:03:41,160
example<font color="#E5E5E5"> of just the two of the most</font>

113
00:03:37,800 --> 00:03:42,510
common key exchanges in TLS but<font color="#E5E5E5"> this is</font>

114
00:03:41,160 --> 00:03:43,560
kind of illustrative because<font color="#CCCCCC"> you'll see</font>

115
00:03:42,510 --> 00:03:45,780
that even though this seems quite

116
00:03:43,560 --> 00:03:48,060
obvious many people<font color="#CCCCCC"> get this</font><font color="#E5E5E5"> particular</font>

117
00:03:45,780 --> 00:03:51,390
bit wrong<font color="#E5E5E5"> okay and that leads to lots of</font>

118
00:03:48,060 --> 00:03:53,040
attacks so in<font color="#E5E5E5"> general of course on</font><font color="#CCCCCC"> the</font>

119
00:03:51,390 --> 00:03:54,390
web there<font color="#E5E5E5"> are lot other features of TLS</font>

120
00:03:53,040 --> 00:03:55,769
so the state machine looks a little bit

121
00:03:54,390 --> 00:03:57,779
<font color="#E5E5E5">more like the one on the one on the</font>

122
00:03:55,770 --> 00:03:59,460
right side<font color="#E5E5E5"> of this thing the details are</font>

123
00:03:57,780 --> 00:04:01,050
not important the interesting thing is

124
00:03:59,460 --> 00:04:02,460
<font color="#E5E5E5">lots of branches but there's no loops</font>

125
00:04:01,050 --> 00:04:05,100
it's kind of a fairly<font color="#E5E5E5"> simple state</font>

126
00:04:02,460 --> 00:04:07,650
machine so what we did a few years ago

127
00:04:05,100 --> 00:04:09,989
was<font color="#CCCCCC"> to implement this protocol which is</font>

128
00:04:07,650 --> 00:04:11,490
our essay and DHE in a resumption and so

129
00:04:09,990 --> 00:04:13,860
on in this reference implementation

130
00:04:11,490 --> 00:04:15,360
called me TLS and we proved it secure we

131
00:04:13,860 --> 00:04:16,440
proved it secure both for functional

132
00:04:15,360 --> 00:04:18,709
correctness as well as for cryptographic

133
00:04:16,440 --> 00:04:22,140
security we publish it at<font color="#CCCCCC"> Oakland here</font>

134
00:04:18,709 --> 00:04:24,390
and then a<font color="#E5E5E5"> follow-up at crypto and you</font>

135
00:04:22,140 --> 00:04:25,740
can go look at<font color="#CCCCCC"> that coat over there but</font>

136
00:04:24,390 --> 00:04:27,000
the<font color="#E5E5E5"> thing is this is about reference</font>

137
00:04:25,740 --> 00:04:28,050
code written in

138
00:04:27,000 --> 00:04:30,020
which is a functional programming

139
00:04:28,050 --> 00:04:32,220
language it doesn't really apply to

140
00:04:30,020 --> 00:04:34,020
openssl which is the code that most

141
00:04:32,220 --> 00:04:35,790
people care about so but could we use

142
00:04:34,020 --> 00:04:38,640
the<font color="#CCCCCC"> same</font><font color="#E5E5E5"> kind of techniques to to</font>

143
00:04:35,790 --> 00:04:40,170
<font color="#E5E5E5">actually verify all of openssl so that's</font>

144
00:04:38,640 --> 00:04:42,690
kind of a natural next<font color="#E5E5E5"> question to ask</font>

145
00:04:40,170 --> 00:04:44,520
and it's a scary question to ask because

146
00:04:42,690 --> 00:04:46,620
if you look<font color="#E5E5E5"> at</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> openssl state machine</font>

147
00:04:44,520 --> 00:04:48,210
it's way more complex than what even I

148
00:04:46,620 --> 00:04:50,220
showed you in the last slide because

149
00:04:48,210 --> 00:04:52,289
<font color="#E5E5E5">openssl does not just support the things</font>

150
00:04:50,220 --> 00:04:53,700
<font color="#CCCCCC">I showed</font><font color="#E5E5E5"> you before it supports a ton of</font>

151
00:04:52,290 --> 00:04:55,380
<font color="#E5E5E5">other features some</font><font color="#CCCCCC"> of which are for</font>

152
00:04:53,700 --> 00:04:58,500
legacy reasons some of which are for

153
00:04:55,380 --> 00:04:59,760
niche applications and so on and you

154
00:04:58,500 --> 00:05:02,100
might say well let's just forget about

155
00:04:59,760 --> 00:05:03,960
these useless things we just<font color="#E5E5E5"> care about</font>

156
00:05:02,100 --> 00:05:06,330
the ones used on the web so why<font color="#E5E5E5"> not just</font>

157
00:05:03,960 --> 00:05:08,549
verify the part of the<font color="#E5E5E5"> openssl that does</font>

158
00:05:06,330 --> 00:05:10,530
does web browser<font color="#CCCCCC"> I used by web browsers</font>

159
00:05:08,550 --> 00:05:14,310
and web servers but we can't do<font color="#CCCCCC"> that</font>

160
00:05:10,530 --> 00:05:16,169
because this the code for these weird

161
00:05:14,310 --> 00:05:17,790
let's say key changes is actually

162
00:05:16,169 --> 00:05:19,440
sharing a lot of the<font color="#E5E5E5"> cord with the code</font>

163
00:05:17,790 --> 00:05:21,090
for<font color="#E5E5E5"> the ones that we care about not only</font>

164
00:05:19,440 --> 00:05:23,040
that even the<font color="#CCCCCC"> long term keys in some</font>

165
00:05:21,090 --> 00:05:24,929
cases are<font color="#E5E5E5"> actually shared across them so</font>

166
00:05:23,040 --> 00:05:26,970
it's not<font color="#E5E5E5"> so easy to address this problem</font>

167
00:05:24,930 --> 00:05:28,320
straight off so I'm<font color="#E5E5E5"> going to step back a</font>

168
00:05:26,970 --> 00:05:29,850
little i'm going to say let's forget

169
00:05:28,320 --> 00:05:31,860
about the scary machine let's ask a

170
00:05:29,850 --> 00:05:35,250
simpler question just for the web

171
00:05:31,860 --> 00:05:37,530
configurations does open SSL satisfy or

172
00:05:35,250 --> 00:05:39,030
conform with the state machine i showed

173
00:05:37,530 --> 00:05:40,469
you<font color="#E5E5E5"> before that have proved correct that</font>

174
00:05:39,030 --> 00:05:43,020
here all kinds of nice proofs for from

175
00:05:40,470 --> 00:05:45,450
various cryptographers so to do this we

176
00:05:43,020 --> 00:05:47,609
build a fuzzing framework<font color="#CCCCCC"> okay it's a</font>

177
00:05:45,450 --> 00:05:49,650
specification based testing framework we

178
00:05:47,610 --> 00:05:51,419
took our reference implementation me TLS

179
00:05:49,650 --> 00:05:52,890
on top of a tree builder a testing

180
00:05:51,419 --> 00:05:54,630
framework and we used it to generate

181
00:05:52,890 --> 00:05:56,550
tons of<font color="#E5E5E5"> non-conforming traces and</font>

182
00:05:54,630 --> 00:05:57,840
executed them against various TLS

183
00:05:56,550 --> 00:05:59,729
clients and servers to see<font color="#E5E5E5"> whether or</font>

184
00:05:57,840 --> 00:06:02,909
<font color="#CCCCCC">not they do the same state machine that</font>

185
00:05:59,729 --> 00:06:04,680
we do and why not and of course what we

186
00:06:02,910 --> 00:06:06,870
found that was that there were tons in

187
00:06:04,680 --> 00:06:09,570
terms of bugs so what do I mean<font color="#CCCCCC"> by a bug</font>

188
00:06:06,870 --> 00:06:13,260
a bug is an unexpected state transition

189
00:06:09,570 --> 00:06:14,760
in where either your client<font color="#CCCCCC"> or server is</font>

190
00:06:13,260 --> 00:06:17,159
accepting a message it's<font color="#E5E5E5"> not supposed to</font>

191
00:06:14,760 --> 00:06:18,450
accept or<font color="#E5E5E5"> its allowing a message to be</font>

192
00:06:17,160 --> 00:06:20,400
skipped which you should not allow to be

193
00:06:18,450 --> 00:06:22,530
skip so on the<font color="#CCCCCC"> right hand side that is</font>

194
00:06:20,400 --> 00:06:25,140
<font color="#E5E5E5">the state machine for openssl as we</font>

195
00:06:22,530 --> 00:06:27,359
discovered by testing which involves all

196
00:06:25,140 --> 00:06:29,039
the red arrows are those where the

197
00:06:27,360 --> 00:06:31,020
client<font color="#CCCCCC"> is allowing extra transitions</font>

198
00:06:29,040 --> 00:06:32,220
which it should not be allowing and on

199
00:06:31,020 --> 00:06:34,260
the<font color="#E5E5E5"> the green ones of the server</font>

200
00:06:32,220 --> 00:06:37,169
allowing extra transitions and a lot<font color="#E5E5E5"> of</font>

201
00:06:34,260 --> 00:06:38,969
these are actually exploitable so we had

202
00:06:37,169 --> 00:06:40,469
<font color="#E5E5E5">CV so many of these libraries but you</font>

203
00:06:38,970 --> 00:06:42,480
have to ask a kind of

204
00:06:40,470 --> 00:06:45,360
<font color="#CCCCCC">high level question we found bugs in</font>

205
00:06:42,480 --> 00:06:47,760
almost all the<font color="#E5E5E5"> implementations we tested</font>

206
00:06:45,360 --> 00:06:48,960
yeah so where are all these bugs coming

207
00:06:47,760 --> 00:06:50,760
from what is the what is the core reason

208
00:06:48,960 --> 00:06:52,770
behind them in all these independent

209
00:06:50,760 --> 00:06:54,539
pieces of code and is it because they're

210
00:06:52,770 --> 00:06:56,549
not exploitable is I mean<font color="#E5E5E5"> I have they've</font>

211
00:06:54,540 --> 00:07:01,140
been there forever so how come they have

212
00:06:56,550 --> 00:07:03,300
not been<font color="#CCCCCC"> found before so what we would</font>

213
00:07:01,140 --> 00:07:04,830
point our finger at is actually the<font color="#CCCCCC"> TLS</font>

214
00:07:03,300 --> 00:07:06,210
<font color="#CCCCCC">back because the Taylor</font><font color="#E5E5E5"> spec actually</font>

215
00:07:04,830 --> 00:07:08,400
does not tell you what the state machine

216
00:07:06,210 --> 00:07:10,620
is it defines the protocol as a ladder

217
00:07:08,400 --> 00:07:12,929
diagram with optional messages so the

218
00:07:10,620 --> 00:07:14,940
thing in<font color="#E5E5E5"> the little little sort of</font>

219
00:07:12,930 --> 00:07:16,560
diamond there is there<font color="#E5E5E5"> are these things</font>

220
00:07:14,940 --> 00:07:18,450
<font color="#E5E5E5">which are marked to the star which are</font>

221
00:07:16,560 --> 00:07:20,490
supposed to be optional which means you

222
00:07:18,450 --> 00:07:21,750
can skip them but it doesn't<font color="#CCCCCC"> say under</font>

223
00:07:20,490 --> 00:07:23,880
what conditions you can skip them and

224
00:07:21,750 --> 00:07:24,990
the idea<font color="#CCCCCC"> is at the</font><font color="#E5E5E5"> end of the handshake</font>

225
00:07:23,880 --> 00:07:27,120
well anyway the client and<font color="#E5E5E5"> the server</font>

226
00:07:24,990 --> 00:07:28,800
will exchange a transcript so maybe will

227
00:07:27,120 --> 00:07:30,510
detect any witnesses that have happened

228
00:07:28,800 --> 00:07:33,150
at that<font color="#E5E5E5"> point but</font><font color="#CCCCCC"> this</font><font color="#E5E5E5"> is not entirely</font>

229
00:07:30,510 --> 00:07:36,030
true because<font color="#CCCCCC"> ok let's</font><font color="#E5E5E5"> start from the</font>

230
00:07:33,150 --> 00:07:37,710
from the<font color="#E5E5E5"> from the optional message style</font>

231
00:07:36,030 --> 00:07:39,929
and see how would we how would the

232
00:07:37,710 --> 00:07:42,030
client<font color="#E5E5E5"> and server implemented so this is</font>

233
00:07:39,930 --> 00:07:44,460
<font color="#E5E5E5">how we decided to compose RSA and DSA</font>

234
00:07:42,030 --> 00:07:46,229
<font color="#CCCCCC">Chi earlier but if you use the optional</font>

235
00:07:44,460 --> 00:07:48,570
message style what many implementations

236
00:07:46,230 --> 00:07:50,220
do is in fact what they say is well

237
00:07:48,570 --> 00:07:51,510
server key exchange is optional which

238
00:07:50,220 --> 00:07:53,460
means that<font color="#E5E5E5"> the server gets to decide</font>

239
00:07:51,510 --> 00:07:55,710
whether or<font color="#E5E5E5"> not it's going to send it and</font>

240
00:07:53,460 --> 00:07:58,799
the client has to just deal with it this

241
00:07:55,710 --> 00:08:00,210
is sort of a weird version of postures

242
00:07:58,800 --> 00:08:02,640
principal value where the<font color="#E5E5E5"> client is</font>

243
00:08:00,210 --> 00:08:04,830
willing to accept a lot of<font color="#E5E5E5"> things</font><font color="#CCCCCC"> that</font>

244
00:08:02,640 --> 00:08:06,570
the server might do which be liberal in

245
00:08:04,830 --> 00:08:08,909
what the server does but there are<font color="#E5E5E5"> two</font>

246
00:08:06,570 --> 00:08:10,320
dangerous cases of course so suppose I'm

247
00:08:08,910 --> 00:08:11,610
doing a regular RSA key exchange but

248
00:08:10,320 --> 00:08:14,219
there's not supposed to be a server key

249
00:08:11,610 --> 00:08:16,290
exchange message now what if I get one

250
00:08:14,220 --> 00:08:17,760
what am I going<font color="#E5E5E5"> to do similarly in a DHE</font>

251
00:08:16,290 --> 00:08:19,110
exchange but<font color="#E5E5E5"> I expect a server key</font>

252
00:08:17,760 --> 00:08:21,090
exchange message if I don't get one what

253
00:08:19,110 --> 00:08:22,380
am I going<font color="#E5E5E5"> to do ideally you would just</font>

254
00:08:21,090 --> 00:08:24,869
close the connection you'd say no this

255
00:08:22,380 --> 00:08:27,180
is no good but in fact in reality lots

256
00:08:24,870 --> 00:08:29,040
of clients accept the connection do

257
00:08:27,180 --> 00:08:30,330
unexpected crypto computations and then

258
00:08:29,040 --> 00:08:34,110
completely<font color="#E5E5E5"> break the security of the</font>

259
00:08:30,330 --> 00:08:36,929
connection because of that so here's one

260
00:08:34,110 --> 00:08:38,640
example it's against Java so suppose<font color="#E5E5E5"> you</font>

261
00:08:36,929 --> 00:08:40,770
<font color="#E5E5E5">wanted to impersonate google com to a</font>

262
00:08:38,640 --> 00:08:43,049
<font color="#E5E5E5">Java client what you would do is let it</font>

263
00:08:40,770 --> 00:08:45,210
connect<font color="#E5E5E5"> to you give you give it</font><font color="#CCCCCC"> Google</font>

264
00:08:43,049 --> 00:08:46,680
certificate then because you don't have

265
00:08:45,210 --> 00:08:48,240
Google's private key you cannot actually

266
00:08:46,680 --> 00:08:50,130
send the server key exchange message it

267
00:08:48,240 --> 00:08:52,890
requires a signature so what we just

268
00:08:50,130 --> 00:08:54,060
<font color="#E5E5E5">skip it we skip the next message we skip</font>

269
00:08:52,890 --> 00:08:56,010
the next message we skipped an

270
00:08:54,060 --> 00:08:57,510
message we skip all the way we skip the

271
00:08:56,010 --> 00:08:58,770
CCS message which says let's start

272
00:08:57,510 --> 00:09:01,980
encrypting we don't want to encrypt

273
00:08:58,770 --> 00:09:04,020
let's skip that too but but we have<font color="#CCCCCC"> to</font>

274
00:09:01,980 --> 00:09:05,730
finish the<font color="#E5E5E5"> handshake and we haven't done</font>

275
00:09:04,020 --> 00:09:07,620
any of the key exchange so there<font color="#E5E5E5"> is no</font>

276
00:09:05,730 --> 00:09:10,170
keys to finish the handshake with but

277
00:09:07,620 --> 00:09:13,200
hey let's use all<font color="#E5E5E5"> zeros right and maybe</font>

278
00:09:10,170 --> 00:09:14,729
Java will accept any 12 so so now you

279
00:09:13,200 --> 00:09:17,100
can start exchanging application data

280
00:09:14,730 --> 00:09:18,480
completely unencrypted which means that

281
00:09:17,100 --> 00:09:20,279
<font color="#E5E5E5">from the time Java has started</font>

282
00:09:18,480 --> 00:09:22,950
supporting the<font color="#E5E5E5"> Oracle</font><font color="#CCCCCC"> Jace's see the sun</font>

283
00:09:20,279 --> 00:09:25,920
jdk has started doing TLS from that

284
00:09:22,950 --> 00:09:28,020
point on till<font color="#E5E5E5"> March of this year java</font>

285
00:09:25,920 --> 00:09:30,029
clients offered no confidentiality and

286
00:09:28,020 --> 00:09:32,430
no integrity against a network attacker

287
00:09:30,029 --> 00:09:34,110
<font color="#CCCCCC">zero</font><font color="#E5E5E5"> ok and you might say this is weird</font>

288
00:09:32,430 --> 00:09:35,550
you<font color="#CCCCCC"> know</font><font color="#E5E5E5"> this</font><font color="#CCCCCC"> is just maybe</font><font color="#E5E5E5"> this is just</font>

289
00:09:34,110 --> 00:09:38,130
Java right this is like four different

290
00:09:35,550 --> 00:09:39,150
state machine bugs but we found similar

291
00:09:38,130 --> 00:09:40,470
bugs and at least three other

292
00:09:39,150 --> 00:09:43,020
implementations so there is something

293
00:09:40,470 --> 00:09:45,930
symptomatic hear about how how these

294
00:09:43,020 --> 00:09:47,250
things are implemented then you might

295
00:09:45,930 --> 00:09:49,050
say<font color="#CCCCCC"> well</font><font color="#E5E5E5"> ok that's because you skipped</font>

296
00:09:47,250 --> 00:09:50,400
messages but if you inject a new message

297
00:09:49,050 --> 00:09:53,430
like a server key exchange message when

298
00:09:50,400 --> 00:09:55,020
it's<font color="#E5E5E5"> not expected like an RSA that is an</font>

299
00:09:53,430 --> 00:09:57,420
unexpected new message I<font color="#E5E5E5"> will definitely</font>

300
00:09:55,020 --> 00:09:59,880
reject that but no we<font color="#E5E5E5"> won't because</font>

301
00:09:57,420 --> 00:10:03,329
there is a single export RSA right so

302
00:09:59,880 --> 00:10:05,280
TLS 1.0 and the<font color="#CCCCCC"> 1990s because of export</font>

303
00:10:03,330 --> 00:10:08,160
restrictions on cryptography introduced

304
00:10:05,280 --> 00:10:10,439
us these export cipher suites which were

305
00:10:08,160 --> 00:10:12,959
limited to at most 512 bits for a

306
00:10:10,440 --> 00:10:15,690
symmetric<font color="#E5E5E5"> ease about the</font><font color="#CCCCCC"> fireman and not</font>

307
00:10:12,960 --> 00:10:16,710
a<font color="#CCCCCC"> sickies which and these keys so what</font>

308
00:10:15,690 --> 00:10:18,390
would happen is you connect to<font color="#E5E5E5"> a server</font>

309
00:10:16,710 --> 00:10:20,580
with RSA it said oh you're connecting

310
00:10:18,390 --> 00:10:22,650
from outside the US<font color="#E5E5E5"> so what I'm going to</font>

311
00:10:20,580 --> 00:10:24,870
do is I'm going<font color="#E5E5E5"> to generate a I'm going</font>

312
00:10:22,650 --> 00:10:26,130
to use my 512 bit key and I'm going<font color="#E5E5E5"> to</font>

313
00:10:24,870 --> 00:10:27,810
send it to you in a server key exchange

314
00:10:26,130 --> 00:10:31,710
<font color="#E5E5E5">and</font><font color="#CCCCCC"> I'm going</font><font color="#E5E5E5"> to sign</font><font color="#CCCCCC"> it with my regular</font>

315
00:10:27,810 --> 00:10:33,239
to run 2048-bit key and now this 512-bit

316
00:10:31,710 --> 00:10:34,890
keys are known to<font color="#CCCCCC"> be like really really</font>

317
00:10:33,240 --> 00:10:36,750
obsolete I mean the NSA thought they

318
00:10:34,890 --> 00:10:39,900
could break this in the<font color="#E5E5E5"> 1990s that's why</font>

319
00:10:36,750 --> 00:10:42,209
they introduces this regulation anyway

320
00:10:39,900 --> 00:10:44,819
and it's known<font color="#CCCCCC"> to be broken even for</font>

321
00:10:42,209 --> 00:10:46,319
academic since 2000 so it's deprecated

322
00:10:44,820 --> 00:10:48,270
nobody<font color="#E5E5E5"> uses it none of the</font><font color="#CCCCCC"> browser's</font>

323
00:10:46,320 --> 00:10:50,610
offer it openssl doesn't offer it by

324
00:10:48,270 --> 00:10:52,829
<font color="#CCCCCC">default as a client so</font><font color="#E5E5E5"> really it should</font>

325
00:10:50,610 --> 00:10:54,029
this is dead code right but it's still

326
00:10:52,830 --> 00:10:55,470
there it's<font color="#E5E5E5"> still there in all the</font>

327
00:10:54,029 --> 00:10:57,420
libraries that is code to handle this

328
00:10:55,470 --> 00:10:59,490
extra message and you can make<font color="#E5E5E5"> it live</font>

329
00:10:57,420 --> 00:11:01,410
code if<font color="#E5E5E5"> you send a server key exchange</font>

330
00:10:59,490 --> 00:11:03,060
message during our essay which is

331
00:11:01,410 --> 00:11:04,560
unexpected but if you send it this piece

332
00:11:03,060 --> 00:11:06,329
<font color="#E5E5E5">of dead code which</font><font color="#CCCCCC"> is still living</font><font color="#E5E5E5"> in</font>

333
00:11:04,560 --> 00:11:08,420
there for 15 years<font color="#CCCCCC"> after being</font>

334
00:11:06,330 --> 00:11:10,649
deprecated will get activated

335
00:11:08,420 --> 00:11:12,329
this results in a nice man in the middle

336
00:11:10,649 --> 00:11:14,790
attack we call it freak for factoring

337
00:11:12,330 --> 00:11:17,160
<font color="#E5E5E5">odyssey export keys and</font><font color="#CCCCCC"> the attack is</font>

338
00:11:14,790 --> 00:11:19,439
basically it requires it's a man in the

339
00:11:17,160 --> 00:11:21,420
<font color="#E5E5E5">middle so he's a good client a buggy</font>

340
00:11:19,440 --> 00:11:23,850
client who accepts our key exchange

341
00:11:21,420 --> 00:11:26,519
messages in<font color="#E5E5E5"> RSA is trying to connect to</font>

342
00:11:23,850 --> 00:11:28,290
a buggy server which supports RSA export

343
00:11:26,519 --> 00:11:29,579
and in the<font color="#E5E5E5"> middle the man in the middle</font>

344
00:11:28,290 --> 00:11:31,589
is what he's going to do is going<font color="#E5E5E5"> to let</font>

345
00:11:29,579 --> 00:11:35,010
the connection go through but downgraded

346
00:11:31,589 --> 00:11:36,269
to RSA export break the 512 bit key and

347
00:11:35,010 --> 00:11:38,430
then<font color="#E5E5E5"> take over the connection and</font>

348
00:11:36,269 --> 00:11:40,140
therefore impersonate the server there

349
00:11:38,430 --> 00:11:41,880
are so<font color="#E5E5E5"> many preconditions to this you</font>

350
00:11:40,140 --> 00:11:44,540
need to<font color="#CCCCCC"> have a buggy server buggy client</font>

351
00:11:41,880 --> 00:11:46,290
you need to be able to break the key but

352
00:11:44,540 --> 00:11:48,000
unfortunately all of<font color="#E5E5E5"> this is fairly easy</font>

353
00:11:46,290 --> 00:11:49,589
so the<font color="#CCCCCC"> set</font><font color="#E5E5E5"> map guys at the University</font>

354
00:11:48,000 --> 00:11:51,510
<font color="#E5E5E5">Michigan did a internet white study they</font>

355
00:11:49,589 --> 00:11:53,370
found thirty-seven percent of browser

356
00:11:51,510 --> 00:11:55,620
<font color="#CCCCCC">trusted servers out there still support</font>

357
00:11:53,370 --> 00:11:57,660
RSA export so this was<font color="#E5E5E5"> considered</font>

358
00:11:55,620 --> 00:12:00,180
vaguely safe because nobody asks for it

359
00:11:57,660 --> 00:12:04,170
right so if nobody asks for it it never

360
00:12:00,180 --> 00:12:06,120
gets used so it's<font color="#E5E5E5"> okay and factoring</font>

361
00:12:04,170 --> 00:12:08,729
well and these sites included some nice

362
00:12:06,120 --> 00:12:12,839
<font color="#CCCCCC">high-profile sites like the NSA and NHS</font>

363
00:12:08,730 --> 00:12:14,279
<font color="#E5E5E5">PC and then the next</font><font color="#CCCCCC"> step</font><font color="#E5E5E5"> is well how</font>

364
00:12:12,839 --> 00:12:15,810
can<font color="#E5E5E5"> you factor these keys that's</font>

365
00:12:14,279 --> 00:12:17,279
probably requires government level

366
00:12:15,810 --> 00:12:20,069
strength right<font color="#E5E5E5"> but 512-bit key is a</font>

367
00:12:17,279 --> 00:12:22,709
trivial now so Nadia<font color="#CCCCCC"> henninger showed us</font>

368
00:12:20,070 --> 00:12:25,110
that she could take keys from us and

369
00:12:22,709 --> 00:12:27,420
break it in about 12 hours on Amazon ec2

370
00:12:25,110 --> 00:12:28,829
for a cost of hundred dollars and this

371
00:12:27,420 --> 00:12:30,660
is actually<font color="#E5E5E5"> useful because these keys</font>

372
00:12:28,829 --> 00:12:31,920
are reused by servers until they

373
00:12:30,660 --> 00:12:35,160
rebooted so they could<font color="#E5E5E5"> be alive for</font>

374
00:12:31,920 --> 00:12:37,260
weeks and the last step<font color="#CCCCCC"> is well ok ok</font>

375
00:12:35,160 --> 00:12:38,790
you found one bug in openssl surely

376
00:12:37,260 --> 00:12:40,260
that's<font color="#E5E5E5"> not the end of the road but I</font>

377
00:12:38,790 --> 00:12:42,209
said no no this is not just one bug and

378
00:12:40,260 --> 00:12:44,760
open<font color="#CCCCCC"> to sell this bug this exact same</font>

379
00:12:42,209 --> 00:12:46,439
bug was an open SSL an IBM jsse in

380
00:12:44,760 --> 00:12:48,329
Microsoft<font color="#E5E5E5"> s channel</font><font color="#CCCCCC"> and Apple secure</font>

381
00:12:46,440 --> 00:12:52,320
transport so it<font color="#E5E5E5"> just seems to be like</font>

382
00:12:48,329 --> 00:12:54,810
everywhere so there were<font color="#E5E5E5"> cv is for all</font>

383
00:12:52,320 --> 00:12:56,660
<font color="#CCCCCC">of these things issued because well the</font>

384
00:12:54,810 --> 00:13:01,229
client was buggy the server was buggy

385
00:12:56,660 --> 00:13:04,649
the keys were breakable and it leads us

386
00:13:01,230 --> 00:13:06,269
to<font color="#E5E5E5"> ask the question ok so let's see well</font>

387
00:13:04,649 --> 00:13:09,000
can you do better you know<font color="#E5E5E5"> can we</font>

388
00:13:06,269 --> 00:13:10,980
actually prove something about our

389
00:13:09,000 --> 00:13:13,620
implementation rather than sort of

390
00:13:10,980 --> 00:13:15,720
relying on some<font color="#E5E5E5"> short-term mitigations</font>

391
00:13:13,620 --> 00:13:17,190
to avoid attacks so all of this all of

392
00:13:15,720 --> 00:13:19,350
these<font color="#E5E5E5"> problems i showed you i was</font>

393
00:13:17,190 --> 00:13:21,120
discussing these attacks come because

394
00:13:19,350 --> 00:13:22,740
the state machine is not correct

395
00:13:21,120 --> 00:13:24,690
<font color="#E5E5E5">our bugs in it we know what the state</font>

396
00:13:22,740 --> 00:13:26,610
machine is supposed to do everybody who

397
00:13:24,690 --> 00:13:28,080
knows TLS will agree that certain of

398
00:13:26,610 --> 00:13:30,089
these traces should not be accepted but

399
00:13:28,080 --> 00:13:31,680
they are so how difficult would it be to

400
00:13:30,089 --> 00:13:33,720
take<font color="#CCCCCC"> something like this the openssl</font>

401
00:13:31,680 --> 00:13:38,579
code prove that it's actually conforms

402
00:13:33,720 --> 00:13:40,529
to its state machine so what this<font color="#E5E5E5"> is</font>

403
00:13:38,580 --> 00:13:43,830
<font color="#E5E5E5">what we did one of her students what he</font>

404
00:13:40,529 --> 00:13:45,089
did was he took the openssl code he

405
00:13:43,830 --> 00:13:47,070
extracted out the client<font color="#CCCCCC"> and server</font>

406
00:13:45,089 --> 00:13:48,600
state machines which were actually quite

407
00:13:47,070 --> 00:13:51,150
<font color="#E5E5E5">a bit of a mess because they have to</font>

408
00:13:48,600 --> 00:13:53,370
deal<font color="#E5E5E5"> with all</font><font color="#CCCCCC"> kinds of protocol versions</font>

409
00:13:51,150 --> 00:13:54,750
extensions their<font color="#E5E5E5"> various optional</font>

410
00:13:53,370 --> 00:13:56,490
features<font color="#E5E5E5"> their various experimental</font>

411
00:13:54,750 --> 00:13:58,380
features and what he did was they

412
00:13:56,490 --> 00:13:59,700
rewrote the code it doesn't increase the

413
00:13:58,380 --> 00:14:01,320
code size<font color="#E5E5E5"> actually just sort of cleaned</font>

414
00:13:59,700 --> 00:14:04,680
it up read out the<font color="#CCCCCC"> corner over 750 lines</font>

415
00:14:01,320 --> 00:14:06,540
of<font color="#CCCCCC"> C and added to</font><font color="#E5E5E5"> it about 40 and 60</font>

416
00:14:04,680 --> 00:14:08,699
lines of specification and he's 460

417
00:14:06,540 --> 00:14:09,870
lines basically<font color="#CCCCCC"> we're encoding the state</font>

418
00:14:08,700 --> 00:14:11,760
machine that I just showed you in the

419
00:14:09,870 --> 00:14:14,490
previous slide looks horrible but it<font color="#E5E5E5"> it</font>

420
00:14:11,760 --> 00:14:17,040
is kind of fairly easy to to formalize

421
00:14:14,490 --> 00:14:19,170
and this formal specification was very

422
00:14:17,040 --> 00:14:21,569
close<font color="#CCCCCC"> to what we did we already</font><font color="#E5E5E5"> had used</font>

423
00:14:19,170 --> 00:14:22,740
<font color="#E5E5E5">for me TLS when we were proving the the</font>

424
00:14:21,570 --> 00:14:24,750
security of it so<font color="#CCCCCC"> we have high</font>

425
00:14:22,740 --> 00:14:27,630
confidence that this spec<font color="#CCCCCC"> that you wrote</font>

426
00:14:24,750 --> 00:14:31,860
for for open SSL is actually the right

427
00:14:27,630 --> 00:14:33,570
one then we use this tool called framesi

428
00:14:31,860 --> 00:14:35,640
but there<font color="#E5E5E5"> are many other tools for</font>

429
00:14:33,570 --> 00:14:37,620
verifying<font color="#CCCCCC"> C code against logical specs</font>

430
00:14:35,640 --> 00:14:40,140
we just<font color="#CCCCCC"> happened to use this one</font><font color="#E5E5E5"> and we</font>

431
00:14:37,620 --> 00:14:42,360
could<font color="#E5E5E5"> prove that this openssl state</font>

432
00:14:40,140 --> 00:14:44,550
machine the core bit of open SSL does

433
00:14:42,360 --> 00:14:46,670
satisfy the<font color="#E5E5E5"> dust implement the right</font>

434
00:14:44,550 --> 00:14:49,199
state machine so<font color="#CCCCCC"> we could do that and</font>

435
00:14:46,670 --> 00:14:50,760
this<font color="#E5E5E5"> took about one month of effort from</font>

436
00:14:49,200 --> 00:14:52,050
a PhD students there's no reason to

437
00:14:50,760 --> 00:14:54,689
<font color="#E5E5E5">think that this is sort of out of reach</font>

438
00:14:52,050 --> 00:14:57,689
for for for production developers and so

439
00:14:54,690 --> 00:14:59,850
on and the big advantages well you do

440
00:14:57,690 --> 00:15:02,160
<font color="#E5E5E5">this once you eliminate all the state</font>

441
00:14:59,850 --> 00:15:03,540
machine bugs in openssl in one fell

442
00:15:02,160 --> 00:15:04,880
swoop while state machine bugs of the

443
00:15:03,540 --> 00:15:06,719
category<font color="#CCCCCC"> that</font><font color="#E5E5E5"> I've been discussing and</font>

444
00:15:04,880 --> 00:15:10,529
really there is no impact on performance

445
00:15:06,720 --> 00:15:15,990
so we<font color="#E5E5E5"> tested it we did there was</font><font color="#CCCCCC"> haha</font>

446
00:15:10,529 --> 00:15:18,990
there<font color="#E5E5E5"> was no measurable impact so I'm</font>

447
00:15:15,990 --> 00:15:21,500
<font color="#E5E5E5">going to conclude and the conclusions</font>

448
00:15:18,990 --> 00:15:23,760
that we have from<font color="#E5E5E5"> this work is that</font>

449
00:15:21,500 --> 00:15:27,740
<font color="#E5E5E5">first of all cryptographic protocol</font>

450
00:15:23,760 --> 00:15:31,350
testing to our surprise<font color="#E5E5E5"> is is hard and</font>

451
00:15:27,740 --> 00:15:33,209
an easy at the<font color="#E5E5E5"> same time so I mean we</font>

452
00:15:31,350 --> 00:15:35,110
did something fairly naive right when we

453
00:15:33,209 --> 00:15:36,760
did<font color="#CCCCCC"> okay it's a specification based test</font>

454
00:15:35,110 --> 00:15:38,350
framework but really in the end you

455
00:15:36,760 --> 00:15:41,200
could<font color="#E5E5E5"> just think of it as fuzzing and we</font>

456
00:15:38,350 --> 00:15:42,760
found dozens of bugs so we shouldn't<font color="#CCCCCC"> be</font>

457
00:15:41,200 --> 00:15:43,870
doing this<font color="#CCCCCC"> its protocol developers it</font>

458
00:15:42,760 --> 00:15:46,420
should be doing this<font color="#E5E5E5"> and we need to kind</font>

459
00:15:43,870 --> 00:15:48,810
<font color="#E5E5E5">of figure out a way of making this more</font>

460
00:15:46,420 --> 00:15:51,880
part of a part of the testing

461
00:15:48,810 --> 00:15:53,319
methodology there is a<font color="#E5E5E5"> smiths that open</font>

462
00:15:51,880 --> 00:15:55,740
source code because tons of people are

463
00:15:53,320 --> 00:15:58,720
looking<font color="#CCCCCC"> at it is less vulnerable to</font>

464
00:15:55,740 --> 00:15:59,980
attack but I<font color="#E5E5E5"> think all of these</font><font color="#CCCCCC"> various</font>

465
00:15:58,720 --> 00:16:02,680
problems that people have found in the

466
00:15:59,980 --> 00:16:05,620
last few years on openssl falsify<font color="#CCCCCC"> TSA's</font>

467
00:16:02,680 --> 00:16:07,359
so just having tons<font color="#E5E5E5"> of people looking at</font>

468
00:16:05,620 --> 00:16:09,070
code doesn't help when the bugs could be

469
00:16:07,360 --> 00:16:11,050
fairly subtle security and crypto

470
00:16:09,070 --> 00:16:12,610
related bugs those things<font color="#E5E5E5"> don't seem to</font>

471
00:16:11,050 --> 00:16:16,000
shake out they seem<font color="#CCCCCC"> to</font><font color="#E5E5E5"> lie in there for</font>

472
00:16:12,610 --> 00:16:18,040
years look on the bright<font color="#CCCCCC"> side I think</font>

473
00:16:16,000 --> 00:16:21,070
the thing<font color="#CCCCCC"> the approach we would advocate</font>

474
00:16:18,040 --> 00:16:22,630
is rather than trying to fuzz things and

475
00:16:21,070 --> 00:16:23,920
so on the you might be you might have

476
00:16:22,630 --> 00:16:25,839
better mileage if you actually try<font color="#E5E5E5"> to</font>

477
00:16:23,920 --> 00:16:27,459
verify<font color="#E5E5E5"> your production code directly</font>

478
00:16:25,839 --> 00:16:29,050
we've shown that<font color="#E5E5E5"> you can do this for a</font>

479
00:16:27,459 --> 00:16:31,479
small tiny bit of open SSL it's

480
00:16:29,050 --> 00:16:33,310
certainly not<font color="#E5E5E5"> all of it but it's a good</font>

481
00:16:31,480 --> 00:16:35,380
first<font color="#CCCCCC"> step and I think</font><font color="#E5E5E5"> our experience</font>

482
00:16:33,310 --> 00:16:36,729
with me TLS also encourages us that you

483
00:16:35,380 --> 00:16:40,329
can actually do serious proofs about

484
00:16:36,730 --> 00:16:43,870
running code of crypto protocols and the

485
00:16:40,329 --> 00:16:46,779
last sort of bit is is the cautionary

486
00:16:43,870 --> 00:16:48,640
tale of freak freak the attack occurs

487
00:16:46,779 --> 00:16:50,620
because there is a export ciphers that

488
00:16:48,640 --> 00:16:53,649
were introduced to deliberately weaken

489
00:16:50,620 --> 00:16:56,260
crypto 20 years ago<font color="#E5E5E5"> or 15 16 years ago</font>

490
00:16:53,649 --> 00:16:58,510
and there is no<font color="#E5E5E5"> reason for these tool to</font>

491
00:16:56,260 --> 00:16:59,769
live on but they do so there is<font color="#CCCCCC"> a</font>

492
00:16:58,510 --> 00:17:01,420
cautionary<font color="#CCCCCC"> tale for deliberately</font>

493
00:16:59,769 --> 00:17:02,890
beginning cryptography for<font color="#E5E5E5"> short-term</font>

494
00:17:01,420 --> 00:17:06,428
gains because it turns out that these

495
00:17:02,890 --> 00:17:08,319
things<font color="#E5E5E5"> live on forever so I'm at the end</font>

496
00:17:06,429 --> 00:17:10,439
of<font color="#E5E5E5"> my talk and I'm happy to take</font>

497
00:17:08,319 --> 00:17:10,438
questions

498
00:17:20,890 --> 00:17:26,380
so I believe<font color="#E5E5E5"> everyone has addressed the</font>

499
00:17:23,269 --> 00:17:29,450
<font color="#CCCCCC">freak vulnerability but have have the</font>

500
00:17:26,380 --> 00:17:32,330
vendors you've talked to address the

501
00:17:29,450 --> 00:17:37,850
broader state machine vulnerabilities

502
00:17:32,330 --> 00:17:41,269
that you found so yes so it depends on

503
00:17:37,850 --> 00:17:42,860
on the vendor<font color="#E5E5E5"> namely</font><font color="#CCCCCC"> so the ones that</font>

504
00:17:41,269 --> 00:17:44,360
are immediately<font color="#E5E5E5"> exploitable where you</font>

505
00:17:42,860 --> 00:17:46,219
can show that you can<font color="#E5E5E5"> actually break it</font>

506
00:17:44,360 --> 00:17:48,439
completely they get fixed very quickly

507
00:17:46,220 --> 00:17:51,139
but there could be lots of weirdnesses

508
00:17:48,440 --> 00:17:52,940
in the state machine which which sort of

509
00:17:51,139 --> 00:17:56,269
lead to a crash later or<font color="#E5E5E5"> something which</font>

510
00:17:52,940 --> 00:17:59,149
don't really lead to fulfill and those

511
00:17:56,269 --> 00:18:01,039
ones sometimes<font color="#E5E5E5"> just people don't want to</font>

512
00:17:59,149 --> 00:18:02,268
fix them because it takes too much

513
00:18:01,039 --> 00:18:05,840
effort because might break something

514
00:18:02,269 --> 00:18:07,460
else they don't know and so on so the

515
00:18:05,840 --> 00:18:09,860
<font color="#E5E5E5">Java state machine for example it has</font>

516
00:18:07,460 --> 00:18:11,330
fixed the vulnerability I showed you but

517
00:18:09,860 --> 00:18:14,418
it still has lots of witnesses in that I

518
00:18:11,330 --> 00:18:20,240
think it might it might well lead to

519
00:18:14,419 --> 00:18:22,899
<font color="#E5E5E5">other attacks I'm wondering</font><font color="#CCCCCC"> if you could</font>

520
00:18:20,240 --> 00:18:25,639
reduce the<font color="#E5E5E5"> burden on developers of</font>

521
00:18:22,899 --> 00:18:27,649
verification even further but instead<font color="#CCCCCC"> of</font>

522
00:18:25,639 --> 00:18:30,229
trying to<font color="#E5E5E5"> fully verify the state machine</font>

523
00:18:27,649 --> 00:18:31,969
just verify the simpler property that

524
00:18:30,230 --> 00:18:34,190
the finished message can't be skipped

525
00:18:31,970 --> 00:18:35,870
because<font color="#E5E5E5"> part of the design of the</font>

526
00:18:34,190 --> 00:18:38,269
protocol the intent was the finished

527
00:18:35,870 --> 00:18:41,059
message conveys this hash of<font color="#CCCCCC"> the</font>

528
00:18:38,269 --> 00:18:43,460
transcript and if you have if you don't

529
00:18:41,059 --> 00:18:46,428
have any weak key exchange algorithms

530
00:18:43,460 --> 00:18:49,549
and if the finished message can't be

531
00:18:46,429 --> 00:18:52,789
skipped then hopefully man-in-the-middle

532
00:18:49,549 --> 00:18:53,929
attacks will<font color="#CCCCCC"> be prevented</font><font color="#E5E5E5"> so could you</font>

533
00:18:52,789 --> 00:18:55,700
get you know I don't<font color="#E5E5E5"> know eighty percent</font>

534
00:18:53,929 --> 00:18:57,620
of<font color="#E5E5E5"> the benefit or something by</font><font color="#CCCCCC"> just</font>

535
00:18:55,700 --> 00:18:59,929
verifying some simpler property like

536
00:18:57,620 --> 00:19:02,199
that right so that that comes back<font color="#CCCCCC"> to</font>

537
00:18:59,929 --> 00:19:04,820
the question of actually how the<font color="#E5E5E5"> openssl</font>

538
00:19:02,200 --> 00:19:07,070
state<font color="#CCCCCC"> machine covered a lot of</font><font color="#E5E5E5"> things</font>

539
00:19:04,820 --> 00:19:08,510
that<font color="#E5E5E5"> we didn't really know or will it</font>

540
00:19:07,070 --> 00:19:11,809
really believe would be secure for

541
00:19:08,510 --> 00:19:14,419
example so finished is a good<font color="#E5E5E5"> technique</font>

542
00:19:11,809 --> 00:19:18,049
for matching conversations as long as

543
00:19:14,419 --> 00:19:19,610
all the key exchanges we support our at

544
00:19:18,049 --> 00:19:22,220
least have a basic level of security if

545
00:19:19,610 --> 00:19:23,899
even one of them like RSA export does

546
00:19:22,220 --> 00:19:26,539
not have the required level of security

547
00:19:23,899 --> 00:19:28,100
we finish this too late by the new

548
00:19:26,539 --> 00:19:28,850
already<font color="#E5E5E5"> the handshake has already been</font>

549
00:19:28,100 --> 00:19:30,500
broken

550
00:19:28,850 --> 00:19:32,600
so in fact some of<font color="#E5E5E5"> the attacks that we</font>

551
00:19:30,500 --> 00:19:36,980
had worth of that form and the others

552
00:19:32,600 --> 00:19:38,270
were were were also<font color="#E5E5E5"> bypassing finished</font>

553
00:19:36,980 --> 00:19:40,790
in a certain way because finish only

554
00:19:38,270 --> 00:19:43,070
says you<font color="#E5E5E5"> and I agree</font><font color="#CCCCCC"> on what we received</font>

555
00:19:40,790 --> 00:19:45,139
doesn't say that<font color="#CCCCCC"> what we received</font>

556
00:19:43,070 --> 00:19:48,050
actually conforms to any valid trace of

557
00:19:45,140 --> 00:19:49,910
<font color="#E5E5E5">SSL so in Java I was able to send a</font>

558
00:19:48,050 --> 00:19:51,919
finished message but i only had done two

559
00:19:49,910 --> 00:19:53,390
messages in the whole trace and it said

560
00:19:51,920 --> 00:19:55,520
yes<font color="#CCCCCC"> i have</font><font color="#E5E5E5"> these two you have these two</font>

561
00:19:53,390 --> 00:19:56,600
and we're<font color="#E5E5E5"> done but it's not</font><font color="#CCCCCC"> just that it</font>

562
00:19:55,520 --> 00:19:58,340
has with those two<font color="#E5E5E5"> and they have to</font><font color="#CCCCCC"> be</font>

563
00:19:56,600 --> 00:20:03,260
the right to messages<font color="#CCCCCC"> safety that</font><font color="#E5E5E5"> we</font>

564
00:19:58,340 --> 00:20:05,060
<font color="#E5E5E5">agree on all right so I had a quick</font>

565
00:20:03,260 --> 00:20:06,890
<font color="#CCCCCC">question so everyone somehow people</font>

566
00:20:05,060 --> 00:20:08,960
propose<font color="#E5E5E5"> n way programming as a way to</font>

567
00:20:06,890 --> 00:20:10,400
try and cut down on security bugs so you

568
00:20:08,960 --> 00:20:12,410
have n different teams of programmers

569
00:20:10,400 --> 00:20:14,150
implementing some against some common

570
00:20:12,410 --> 00:20:16,160
reference framework so would you<font color="#E5E5E5"> take</font>

571
00:20:14,150 --> 00:20:17,150
this as an example<font color="#E5E5E5"> of why that's not</font>

572
00:20:16,160 --> 00:20:19,070
going to work or is this just a

573
00:20:17,150 --> 00:20:22,270
particularly you know Harry piece of

574
00:20:19,070 --> 00:20:24,500
code to<font color="#E5E5E5"> write and not representative I</font>

575
00:20:22,270 --> 00:20:26,030
actually don't<font color="#CCCCCC"> have a very good answer</font>

576
00:20:24,500 --> 00:20:29,150
for this I<font color="#E5E5E5"> mean I've asked people as to</font>

577
00:20:26,030 --> 00:20:33,160
why these bugs<font color="#E5E5E5"> of some of these bugs</font>

578
00:20:29,150 --> 00:20:35,390
appeared in such disparate code bases

579
00:20:33,160 --> 00:20:38,720
some of them closed source some of them

580
00:20:35,390 --> 00:20:40,940
open source and and I don't really have

581
00:20:38,720 --> 00:20:42,620
a very<font color="#E5E5E5"> good idea why my gap my best</font>

582
00:20:40,940 --> 00:20:43,820
guess was because they read the standard

583
00:20:42,620 --> 00:20:45,770
all reverie<font color="#CCCCCC"> widget at the standard</font><font color="#E5E5E5"> in</font>

584
00:20:43,820 --> 00:20:47,510
<font color="#CCCCCC">the same way my second best guess is</font>

585
00:20:45,770 --> 00:20:51,050
that everybody copied<font color="#CCCCCC"> openssl</font><font color="#E5E5E5"> or</font>

586
00:20:47,510 --> 00:20:52,730
something like that but we don't know

587
00:20:51,050 --> 00:20:55,610
and it's a good<font color="#E5E5E5"> question actually</font>

588
00:20:52,730 --> 00:20:58,210
it'sit's yeah all right let's uh thank

589
00:20:55,610 --> 00:20:58,209
<font color="#CCCCCC">Karthik again</font>

