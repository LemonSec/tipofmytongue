1
00:00:00,120 --> 00:00:05,339
thank you Tom<font color="#CCCCCC"> for</font><font color="#E5E5E5"> the introduction and</font>

2
00:00:02,479 --> 00:00:07,859
this is work<font color="#CCCCCC"> that I've done with the</font>

3
00:00:05,339 --> 00:00:10,200
fanfare<font color="#E5E5E5"> you</font><font color="#CCCCCC"> changi</font><font color="#E5E5E5"> you're not either and</font>

4
00:00:07,859 --> 00:00:13,230
<font color="#CCCCCC">Ruben Lee and it is last level cache</font>

5
00:00:10,200 --> 00:00:16,230
side-channel attack<font color="#E5E5E5"> and if the title</font>

6
00:00:13,230 --> 00:00:18,150
sounds<font color="#E5E5E5"> very similar to the</font><font color="#CCCCCC"> previous talk</font>

7
00:00:16,230 --> 00:00:20,699
that's no coincidence

8
00:00:18,150 --> 00:00:24,720
we<font color="#CCCCCC"> worked independently and found</font>

9
00:00:20,699 --> 00:00:26,999
basically the same attack<font color="#E5E5E5"> so we are</font>

10
00:00:24,720 --> 00:00:30,630
going<font color="#E5E5E5"> to hear some similar things</font><font color="#CCCCCC"> and</font>

11
00:00:26,999 --> 00:00:32,820
some different and so<font color="#E5E5E5"> motivation</font><font color="#CCCCCC"> as we</font>

12
00:00:30,630 --> 00:00:34,589
said is clouds and clouds<font color="#CCCCCC"> we know are</font>

13
00:00:32,820 --> 00:00:36,930
<font color="#E5E5E5">not made of droplet</font><font color="#CCCCCC"> of waters we have</font>

14
00:00:34,590 --> 00:00:39,140
virtual<font color="#CCCCCC"> machines and</font><font color="#E5E5E5"> clouds and we have</font>

15
00:00:36,930 --> 00:00:42,180
the<font color="#CCCCCC"> Apple</font><font color="#E5E5E5"> hypervisor that supposedly</font>

16
00:00:39,140 --> 00:00:44,430
keep a<font color="#CCCCCC"> highly virtual machines isolated</font>

17
00:00:42,180 --> 00:00:46,740
from each<font color="#E5E5E5"> other but because the virtual</font>

18
00:00:44,430 --> 00:00:48,480
<font color="#E5E5E5">machines share the same hardware there</font>

19
00:00:46,740 --> 00:00:51,000
is a potential for<font color="#E5E5E5"> side channels between</font>

20
00:00:48,480 --> 00:00:55,769
<font color="#E5E5E5">them and this has been known to be</font><font color="#CCCCCC"> a</font>

21
00:00:51,000 --> 00:00:58,230
<font color="#E5E5E5">problem for problem side channels has</font>

22
00:00:55,770 --> 00:01:00,560
been known for<font color="#CCCCCC"> over ten years and in</font>

23
00:00:58,230 --> 00:01:04,319
recent<font color="#E5E5E5"> years we've</font><font color="#CCCCCC"> seen the problem in a</font>

24
00:01:00,560 --> 00:01:05,460
virtualization<font color="#E5E5E5"> environment now we are</font>

25
00:01:04,319 --> 00:01:08,339
interested<font color="#CCCCCC"> in last level cache</font>

26
00:01:05,459 --> 00:01:12,089
side-channel attacks<font color="#CCCCCC"> and the reason is</font>

27
00:01:08,340 --> 00:01:16,170
<font color="#CCCCCC">as Gorka said the last</font><font color="#E5E5E5"> level cache is</font>

28
00:01:12,090 --> 00:01:17,819
shared<font color="#CCCCCC"> so</font><font color="#E5E5E5"> I must pray last and most</font>

29
00:01:16,170 --> 00:01:19,770
<font color="#E5E5E5">side-channel attacks that applied</font>

30
00:01:17,819 --> 00:01:21,749
against the cache in<font color="#CCCCCC"> the past were on l1</font>

31
00:01:19,770 --> 00:01:24,770
<font color="#E5E5E5">and then we need either hyper trade</font>

32
00:01:21,749 --> 00:01:27,899
<font color="#CCCCCC">hyper threading in the core or a</font>

33
00:01:24,770 --> 00:01:31,499
<font color="#E5E5E5">schedule exploit schedule of weaknesses</font>

34
00:01:27,899 --> 00:01:33,659
and<font color="#E5E5E5"> the only last level cache attack the</font>

35
00:01:31,499 --> 00:01:36,929
<font color="#E5E5E5">flash</font><font color="#CCCCCC"> reload requires memory duplication</font>

36
00:01:33,659 --> 00:01:39,479
and both these are easily mitigated

37
00:01:36,929 --> 00:01:41,219
<font color="#E5E5E5">clouds tend not to provide to use hyper</font>

38
00:01:39,479 --> 00:01:44,729
threading and they do not provide a

39
00:01:41,219 --> 00:01:46,199
shared memory so<font color="#CCCCCC"> a page</font><font color="#E5E5E5"> duplication so</font>

40
00:01:44,729 --> 00:01:48,659
our attack does not have these

41
00:01:46,200 --> 00:01:50,579
restrictions<font color="#E5E5E5"> and in addition to the</font>

42
00:01:48,659 --> 00:01:52,020
previous attack our attack is<font color="#E5E5E5"> often does</font>

43
00:01:50,579 --> 00:01:55,350
<font color="#E5E5E5">not require synchronization between the</font>

44
00:01:52,020 --> 00:01:57,959
attacker<font color="#CCCCCC"> and the victim so a bit about</font>

45
00:01:55,350 --> 00:02:01,469
cache structure and the hardware cache

46
00:01:57,959 --> 00:02:04,799
is a small<font color="#CCCCCC"> Bank of memory and stores</font>

47
00:02:01,469 --> 00:02:07,169
unique code lines and arranges the

48
00:02:04,799 --> 00:02:09,119
multiple sets<font color="#CCCCCC"> each of them consists of</font>

49
00:02:07,170 --> 00:02:12,180
multiple ways the number of ways is

50
00:02:09,119 --> 00:02:13,110
fixed in each set and we have<font color="#CCCCCC"> the memory</font>

51
00:02:12,180 --> 00:02:15,150
and<font color="#E5E5E5"> memory</font>

52
00:02:13,110 --> 00:02:19,260
<font color="#CCCCCC">Maps</font><font color="#E5E5E5"> into the</font><font color="#CCCCCC"> cash so that each memory</font>

53
00:02:15,150 --> 00:02:21,270
line goes to<font color="#CCCCCC"> a cash set and each</font><font color="#E5E5E5"> memory</font>

54
00:02:19,260 --> 00:02:22,950
<font color="#CCCCCC">elegant line can go into one of the way</font>

55
00:02:21,270 --> 00:02:24,390
to any of the ways of<font color="#E5E5E5"> the sketch</font><font color="#CCCCCC"> that</font>

56
00:02:22,950 --> 00:02:26,369
but we<font color="#E5E5E5"> don't know which way it will go</font>

57
00:02:24,390 --> 00:02:30,179
<font color="#E5E5E5">but you've got</font><font color="#CCCCCC"> one of the ways in this</font>

58
00:02:26,370 --> 00:02:32,940
specific<font color="#E5E5E5"> cash set now this structure has</font>

59
00:02:30,180 --> 00:02:34,820
<font color="#CCCCCC">been</font><font color="#E5E5E5"> explained exploited</font><font color="#CCCCCC"> as a</font><font color="#E5E5E5"> side</font>

60
00:02:32,940 --> 00:02:38,280
channel with a prime probe attack<font color="#CCCCCC"> I</font>

61
00:02:34,820 --> 00:02:40,260
<font color="#E5E5E5">develop incidentally by two different</font>

62
00:02:38,280 --> 00:02:43,410
groups they independently at the same

63
00:02:40,260 --> 00:02:45,780
time<font color="#CCCCCC"> an</font><font color="#E5E5E5"> attack works like</font><font color="#CCCCCC"> that the</font>

64
00:02:43,410 --> 00:02:48,209
attacker chooses the buffer cache size

65
00:02:45,780 --> 00:02:50,490
buffer of memory the attacker<font color="#E5E5E5"> then</font>

66
00:02:48,209 --> 00:02:52,530
accesses<font color="#E5E5E5"> this memory in this buffer so</font>

67
00:02:50,490 --> 00:02:55,620
this buffer is now in the cache the

68
00:02:52,530 --> 00:02:58,410
attacker knows where<font color="#E5E5E5"> they catch what the</font>

69
00:02:55,620 --> 00:03:00,030
cache state is when the victim<font color="#E5E5E5"> executes</font>

70
00:02:58,410 --> 00:03:02,790
the victim accesses<font color="#E5E5E5"> some memory and</font>

71
00:03:00,030 --> 00:03:05,220
replaces memory in the cache the

72
00:03:02,790 --> 00:03:09,150
attacker now can measure the access time

73
00:03:05,220 --> 00:03:10,950
to its own buffer and for cache sets for

74
00:03:09,150 --> 00:03:13,080
memory lines that reside in cache that

75
00:03:10,950 --> 00:03:15,869
that has not been accessed by the<font color="#CCCCCC"> victim</font>

76
00:03:13,080 --> 00:03:17,280
the access will<font color="#CCCCCC"> be fast because</font><font color="#E5E5E5"> the</font>

77
00:03:15,870 --> 00:03:19,500
attacker will<font color="#E5E5E5"> get all the</font><font color="#CCCCCC"> information</font>

78
00:03:17,280 --> 00:03:21,330
<font color="#E5E5E5">from the cache for cash lines that come</font>

79
00:03:19,500 --> 00:03:23,370
from<font color="#E5E5E5"> that the victim has accessed the</font>

80
00:03:21,330 --> 00:03:25,470
<font color="#E5E5E5">access will be slow so</font><font color="#CCCCCC"> the attacker can</font>

81
00:03:23,370 --> 00:03:27,450
distinguish between<font color="#E5E5E5"> cache</font><font color="#CCCCCC"> said the</font>

82
00:03:25,470 --> 00:03:29,730
victim<font color="#E5E5E5"> has access and</font><font color="#CCCCCC"> cache</font><font color="#E5E5E5"> that the</font>

83
00:03:27,450 --> 00:03:31,440
victim has<font color="#E5E5E5"> not accessed and from that it</font>

84
00:03:29,730 --> 00:03:34,920
<font color="#CCCCCC">can the attacker</font><font color="#E5E5E5"> can infer</font><font color="#CCCCCC"> information</font>

85
00:03:31,440 --> 00:03:36,570
about what the victim has done in the

86
00:03:34,920 --> 00:03:38,548
<font color="#E5E5E5">ten</font><font color="#CCCCCC"> years that have passed</font><font color="#E5E5E5"> since this</font>

87
00:03:36,570 --> 00:03:39,810
<font color="#E5E5E5">attack these attacks were published</font><font color="#CCCCCC"> we</font>

88
00:03:38,549 --> 00:03:41,430
haven't seen<font color="#E5E5E5"> side channel attacks</font>

89
00:03:39,810 --> 00:03:42,690
against last<font color="#E5E5E5"> level cache or if we</font>

90
00:03:41,430 --> 00:03:45,030
<font color="#E5E5E5">haven't seen the prime probe attack</font>

91
00:03:42,690 --> 00:03:46,260
against the last level cache and the

92
00:03:45,030 --> 00:03:48,690
reason is that there are several

93
00:03:46,260 --> 00:03:50,970
challenges<font color="#E5E5E5"> that prevent or makes this</font>

94
00:03:48,690 --> 00:03:52,680
talk a bit more<font color="#E5E5E5"> difficult the first</font>

95
00:03:50,970 --> 00:03:55,590
challenge<font color="#CCCCCC"> is the</font><font color="#E5E5E5"> large last level cache</font>

96
00:03:52,680 --> 00:03:58,290
is larger and<font color="#E5E5E5"> slower than the l1 so</font>

97
00:03:55,590 --> 00:04:00,500
<font color="#E5E5E5">prime so we doing a prime probe cycle on</font>

98
00:03:58,290 --> 00:04:04,380
during last level cache is much slower

99
00:04:00,500 --> 00:04:07,590
<font color="#E5E5E5">the second challenge is</font><font color="#CCCCCC"> that we have</font>

100
00:04:04,380 --> 00:04:10,890
<font color="#E5E5E5">difficulty of mapping the memory our</font>

101
00:04:07,590 --> 00:04:12,209
memory into the cache sets the reasons

102
00:04:10,890 --> 00:04:15,328
for<font color="#CCCCCC"> that there are two reasons</font><font color="#E5E5E5"> for</font><font color="#CCCCCC"> that</font>

103
00:04:12,209 --> 00:04:17,940
first is virtual memory as<font color="#CCCCCC"> khoka showed</font>

104
00:04:15,329 --> 00:04:19,890
and doesn't he hides information about

105
00:04:17,940 --> 00:04:22,200
the cache<font color="#E5E5E5"> set index and the other is</font>

106
00:04:19,890 --> 00:04:24,090
<font color="#E5E5E5">that the in current until the</font>

107
00:04:22,200 --> 00:04:25,479
architecture<font color="#CCCCCC"> that divides the cache into</font>

108
00:04:24,090 --> 00:04:28,630
slices it uses an

109
00:04:25,480 --> 00:04:30,640
<font color="#CCCCCC">- function we don't</font><font color="#E5E5E5"> know it</font><font color="#CCCCCC"> and the last</font>

110
00:04:28,630 --> 00:04:33,400
challenge is the visibility<font color="#CCCCCC"> of the</font>

111
00:04:30,640 --> 00:04:35,530
victim memory access<font color="#CCCCCC"> if the higher level</font>

112
00:04:33,400 --> 00:04:38,409
caches do their job<font color="#E5E5E5"> then victim access</font>

113
00:04:35,530 --> 00:04:40,090
they when<font color="#CCCCCC"> 50 memory accesses will mostly</font>

114
00:04:38,410 --> 00:04:41,650
be served from<font color="#CCCCCC"> the higher-level</font><font color="#E5E5E5"> caches</font>

115
00:04:40,090 --> 00:04:43,479
<font color="#E5E5E5">and not from</font><font color="#CCCCCC"> the last level cache so</font>

116
00:04:41,650 --> 00:04:47,650
even if we can monitor<font color="#CCCCCC"> the last level</font>

117
00:04:43,480 --> 00:04:50,470
cache we will not see the victim axis so

118
00:04:47,650 --> 00:04:53,080
how we address<font color="#E5E5E5"> these to address the</font>

119
00:04:50,470 --> 00:04:54,880
first challenge we first probe we probe

120
00:04:53,080 --> 00:04:59,800
only selected cache<font color="#E5E5E5"> that's not the whole</font>

121
00:04:54,880 --> 00:05:02,590
cache<font color="#E5E5E5"> it time for the second for virtual</font>

122
00:04:59,800 --> 00:05:04,090
<font color="#E5E5E5">memory we use large pages same as go I</font>

123
00:05:02,590 --> 00:05:06,729
will not<font color="#E5E5E5"> go over that in my talk because</font>

124
00:05:04,090 --> 00:05:11,340
<font color="#E5E5E5">it will be really repeating Gorkhas</font>

125
00:05:06,730 --> 00:05:13,690
<font color="#CCCCCC">table and for a DLC slices we</font>

126
00:05:11,340 --> 00:05:15,460
empirically determined the mapping<font color="#E5E5E5"> we</font>

127
00:05:13,690 --> 00:05:18,690
just probe the cache to<font color="#CCCCCC"> find the mapping</font>

128
00:05:15,460 --> 00:05:19,930
<font color="#CCCCCC">between memory</font><font color="#E5E5E5"> to the cache slices</font><font color="#CCCCCC"> a</font>

129
00:05:18,690 --> 00:05:21,670
<font color="#E5E5E5">Intel</font>

130
00:05:19,930 --> 00:05:24,040
fortunately takes care of the last

131
00:05:21,670 --> 00:05:25,990
<font color="#E5E5E5">problem</font><font color="#CCCCCC"> the last level cache in Intel is</font>

132
00:05:24,040 --> 00:05:28,420
inclusive<font color="#E5E5E5"> so it means that it is</font><font color="#CCCCCC"> a</font>

133
00:05:25,990 --> 00:05:30,700
superset<font color="#E5E5E5"> of what happens to the contents</font>

134
00:05:28,420 --> 00:05:32,200
<font color="#CCCCCC">of the</font><font color="#E5E5E5"> higher-level caches so</font><font color="#CCCCCC"> if we</font>

135
00:05:30,700 --> 00:05:34,120
evict data from the last level cache

136
00:05:32,200 --> 00:05:36,010
<font color="#E5E5E5">that data is also evicted from the</font>

137
00:05:34,120 --> 00:05:38,530
<font color="#CCCCCC">higher-level caches and any access to</font>

138
00:05:36,010 --> 00:05:42,849
<font color="#E5E5E5">these care to the</font><font color="#CCCCCC"> that data will be</font>

139
00:05:38,530 --> 00:05:45,479
visible in the last<font color="#E5E5E5"> level cache so for</font>

140
00:05:42,850 --> 00:05:48,340
the first<font color="#E5E5E5"> problem slow</font><font color="#CCCCCC"> last level cache</font>

141
00:05:45,480 --> 00:05:51,310
<font color="#E5E5E5">we have some typical timing access</font>

142
00:05:48,340 --> 00:05:55,479
timing to the caches this is Intel i5

143
00:05:51,310 --> 00:06:00,370
processor the l1 cache<font color="#E5E5E5"> is 32 kilobytes</font>

144
00:05:55,480 --> 00:06:03,340
<font color="#E5E5E5">we can scan it in 2048 cycles the last</font>

145
00:06:00,370 --> 00:06:05,350
level cache is relatively small<font color="#E5E5E5"> 86</font>

146
00:06:03,340 --> 00:06:07,150
megabytes<font color="#E5E5E5"> and we need three million</font>

147
00:06:05,350 --> 00:06:09,010
cycles to scan it so we have three

148
00:06:07,150 --> 00:06:14,620
orders<font color="#E5E5E5"> of</font><font color="#CCCCCC"> magnitude difference</font><font color="#E5E5E5"> inside in</font>

149
00:06:09,010 --> 00:06:17,050
probe time the if we look at typical

150
00:06:14,620 --> 00:06:19,240
<font color="#CCCCCC">public key operations they take</font><font color="#E5E5E5"> several</font>

151
00:06:17,050 --> 00:06:22,750
<font color="#E5E5E5">thousands to several tens of thousands</font>

152
00:06:19,240 --> 00:06:24,430
cycles<font color="#E5E5E5"> so if our probe resolution</font><font color="#CCCCCC"> three</font>

153
00:06:22,750 --> 00:06:27,330
million cycles<font color="#E5E5E5"> there is no chance that</font>

154
00:06:24,430 --> 00:06:30,100
<font color="#E5E5E5">we will be able to</font><font color="#CCCCCC"> distinguish between</font>

155
00:06:27,330 --> 00:06:32,979
individual operations<font color="#E5E5E5"> so what</font><font color="#CCCCCC"> can</font><font color="#E5E5E5"> we</font>

156
00:06:30,100 --> 00:06:35,380
can't work that<font color="#E5E5E5"> way and on the</font><font color="#CCCCCC"> other</font>

157
00:06:32,980 --> 00:06:37,630
hand probing a single set<font color="#E5E5E5"> in the</font><font color="#CCCCCC"> middle</font>

158
00:06:35,380 --> 00:06:38,790
last level cache is still fast and we

159
00:06:37,630 --> 00:06:41,580
can<font color="#CCCCCC"> them with the most</font>

160
00:06:38,790 --> 00:06:45,780
<font color="#E5E5E5">rated it by implementing a cover channel</font>

161
00:06:41,580 --> 00:06:48,719
between<font color="#E5E5E5"> VMs using probing by probably</font>

162
00:06:45,780 --> 00:06:50,729
<font color="#CCCCCC">being to two cache sets and we get a</font>

163
00:06:48,720 --> 00:06:53,670
bandwidth<font color="#CCCCCC"> of 1.2 megabits per second</font>

164
00:06:50,730 --> 00:06:57,900
which is<font color="#CCCCCC"> six times faster than</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> best</font>

165
00:06:53,670 --> 00:07:01,680
<font color="#E5E5E5">known last level cache attack until now</font>

166
00:06:57,900 --> 00:07:03,450
I was solution to the to the cache the

167
00:07:01,680 --> 00:07:05,880
size of caches<font color="#CCCCCC"> that we probe one or few</font>

168
00:07:03,450 --> 00:07:08,670
cache sets at the<font color="#E5E5E5"> time and instead of</font>

169
00:07:05,880 --> 00:07:12,600
<font color="#E5E5E5">looking</font><font color="#CCCCCC"> at</font><font color="#E5E5E5"> at the cache footprint that</font>

170
00:07:08,670 --> 00:07:15,180
the victim<font color="#CCCCCC"> leaves we look at the</font>

171
00:07:12,600 --> 00:07:19,110
temporal access patterns<font color="#CCCCCC"> over the these</font>

172
00:07:15,180 --> 00:07:21,360
few cases that<font color="#E5E5E5"> we probe second issue was</font>

173
00:07:19,110 --> 00:07:22,860
<font color="#E5E5E5">the largest pages that we said with I'm</font>

174
00:07:21,360 --> 00:07:25,260
not going to talk about<font color="#E5E5E5"> so I'm moving</font>

175
00:07:22,860 --> 00:07:27,900
<font color="#E5E5E5">directly to the last layer to last level</font>

176
00:07:25,260 --> 00:07:30,690
cache slices the problem is that the

177
00:07:27,900 --> 00:07:32,909
cache is the<font color="#E5E5E5"> inter last level cache</font>

178
00:07:30,690 --> 00:07:35,550
designed with multiple slices we have

179
00:07:32,910 --> 00:07:37,860
one slice per core and in this example<font color="#CCCCCC"> I</font>

180
00:07:35,550 --> 00:07:41,820
have<font color="#E5E5E5"> two slices</font><font color="#CCCCCC"> a great slice</font><font color="#E5E5E5"> one which</font>

181
00:07:37,860 --> 00:07:43,920
is gray slice<font color="#E5E5E5"> zero white and memory is</font>

182
00:07:41,820 --> 00:07:46,409
mapped the memory still maps to cache

183
00:07:43,920 --> 00:07:49,110
sets on these slices<font color="#E5E5E5"> but the decision</font>

184
00:07:46,410 --> 00:07:51,710
which slice it goes to is done based<font color="#E5E5E5"> on</font>

185
00:07:49,110 --> 00:07:55,830
some hash function that<font color="#CCCCCC"> Intel does not</font>

186
00:07:51,710 --> 00:07:58,099
publish for that have to<font color="#E5E5E5"> be effective we</font>

187
00:07:55,830 --> 00:08:00,390
need<font color="#E5E5E5"> to find memory lines that go to</font>

188
00:07:58,100 --> 00:08:03,600
<font color="#E5E5E5">specific slides to catch to the same</font>

189
00:08:00,390 --> 00:08:06,870
cache<font color="#CCCCCC"> set in a specific slice so the way</font>

190
00:08:03,600 --> 00:08:09,150
we do it is we build a pool<font color="#E5E5E5"> of memory of</font>

191
00:08:06,870 --> 00:08:11,820
memory lines that go that exactly

192
00:08:09,150 --> 00:08:14,849
<font color="#CCCCCC">exactly cover a single cache let overall</font>

193
00:08:11,820 --> 00:08:16,860
<font color="#E5E5E5">this all the slices</font><font color="#CCCCCC"> and we do it</font>

194
00:08:14,850 --> 00:08:19,950
iteratively we start with an empty<font color="#E5E5E5"> pool</font>

195
00:08:16,860 --> 00:08:23,040
and then we pick a candidate try to see

196
00:08:19,950 --> 00:08:24,810
if we<font color="#E5E5E5"> can edit to</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> pool without over</font>

197
00:08:23,040 --> 00:08:29,340
without overflowing one of the<font color="#CCCCCC"> slices</font>

198
00:08:24,810 --> 00:08:31,290
<font color="#E5E5E5">and to do</font><font color="#CCCCCC"> it we just probe it</font><font color="#E5E5E5"> so the way</font>

199
00:08:29,340 --> 00:08:34,020
we do it<font color="#CCCCCC"> from for example if we have</font>

200
00:08:31,290 --> 00:08:35,820
this<font color="#CCCCCC"> as the</font><font color="#E5E5E5"> current pool and we can see</font>

201
00:08:34,020 --> 00:08:37,890
<font color="#CCCCCC">hopefully we can see</font><font color="#E5E5E5"> that it has three</font>

202
00:08:35,820 --> 00:08:41,010
entries in the in slice one and two in

203
00:08:37,890 --> 00:08:43,289
slice<font color="#CCCCCC"> zero and we have some candidate we</font>

204
00:08:41,010 --> 00:08:45,990
access that candidate and<font color="#CCCCCC"> that brings it</font>

205
00:08:43,289 --> 00:08:49,099
to<font color="#CCCCCC"> the cache</font><font color="#E5E5E5"> and then we</font><font color="#CCCCCC"> access all the</font>

206
00:08:45,990 --> 00:08:52,120
memory lines in the a in our<font color="#E5E5E5"> buffer and</font>

207
00:08:49,100 --> 00:08:53,770
if the the case

208
00:08:52,120 --> 00:08:56,800
specific<font color="#CCCCCC"> slice</font><font color="#E5E5E5"> that this candidate is</font><font color="#CCCCCC"> in</font>

209
00:08:53,770 --> 00:08:59,800
<font color="#CCCCCC">is not full in the in the pool</font><font color="#E5E5E5"> then we</font>

210
00:08:56,800 --> 00:09:02,650
it will<font color="#E5E5E5"> remain the</font><font color="#CCCCCC"> cache</font><font color="#E5E5E5"> on the others</font>

211
00:08:59,800 --> 00:09:04,959
now if you pick<font color="#CCCCCC"> another a candidate</font><font color="#E5E5E5"> it</font>

212
00:09:02,650 --> 00:09:07,120
will go to slice one and when we access

213
00:09:04,960 --> 00:09:09,490
<font color="#CCCCCC">the our</font><font color="#E5E5E5"> but our pool</font><font color="#CCCCCC"> it will evict that</font>

214
00:09:07,120 --> 00:09:10,990
candidate<font color="#E5E5E5"> so now we have two</font>

215
00:09:09,490 --> 00:09:12,520
<font color="#E5E5E5">possibilities either the candidate</font>

216
00:09:10,990 --> 00:09:13,720
remains in the cache<font color="#E5E5E5"> or it is not in the</font>

217
00:09:12,520 --> 00:09:15,550
cache and<font color="#CCCCCC"> we can distinguish between</font>

218
00:09:13,720 --> 00:09:17,800
these<font color="#E5E5E5"> two</font><font color="#CCCCCC"> by measuring the time it</font><font color="#E5E5E5"> takes</font>

219
00:09:15,550 --> 00:09:19,180
<font color="#CCCCCC">us to access</font><font color="#E5E5E5"> this candidate if it is</font>

220
00:09:17,800 --> 00:09:20,949
still<font color="#CCCCCC"> in the cache</font><font color="#E5E5E5"> we can add it to the</font>

221
00:09:19,180 --> 00:09:22,569
pool<font color="#E5E5E5"> if it is not in the cache we know</font>

222
00:09:20,950 --> 00:09:24,670
that we can't edit and<font color="#E5E5E5"> we go to another</font>

223
00:09:22,570 --> 00:09:27,250
<font color="#E5E5E5">event pick another candidate when the</font>

224
00:09:24,670 --> 00:09:30,579
pool is when the pool is full then<font color="#CCCCCC"> we</font>

225
00:09:27,250 --> 00:09:32,140
can<font color="#E5E5E5"> ask a partition it into slices</font><font color="#CCCCCC"> we</font>

226
00:09:30,580 --> 00:09:33,850
can do it the same<font color="#CCCCCC"> way</font><font color="#E5E5E5"> we</font><font color="#CCCCCC"> just pick a</font>

227
00:09:32,140 --> 00:09:35,529
candidate<font color="#E5E5E5"> and see conflicts with the</font>

228
00:09:33,850 --> 00:09:38,560
pool when we start removing<font color="#CCCCCC"> elements</font>

229
00:09:35,529 --> 00:09:41,560
from the pool<font color="#E5E5E5"> so we are able to create</font>

230
00:09:38,560 --> 00:09:45,219
<font color="#E5E5E5">the eviction sets for every cache set</font>

231
00:09:41,560 --> 00:09:47,529
for every<font color="#E5E5E5"> cache slice that leads to the</font>

232
00:09:45,220 --> 00:09:49,089
attack strategy<font color="#E5E5E5"> what we do is we</font>

233
00:09:47,529 --> 00:09:51,850
<font color="#CCCCCC">actually find</font><font color="#E5E5E5"> these and then we start</font>

234
00:09:49,089 --> 00:09:54,820
<font color="#E5E5E5">searching these cache sets</font><font color="#CCCCCC"> - for</font>

235
00:09:51,850 --> 00:09:57,610
temporal patterns that we expect from

236
00:09:54,820 --> 00:10:00,130
the victim and the example that<font color="#CCCCCC"> I'll</font>

237
00:09:57,610 --> 00:10:01,900
<font color="#E5E5E5">show here is the use</font><font color="#CCCCCC"> of fine a first</font>

238
00:10:00,130 --> 00:10:04,120
example I'll show is how we find<font color="#E5E5E5"> the</font>

239
00:10:01,900 --> 00:10:06,459
square code in when attacking square

240
00:10:04,120 --> 00:10:08,589
<font color="#E5E5E5">multiply exponentiation this is an old</font>

241
00:10:06,459 --> 00:10:12,520
version of<font color="#CCCCCC"> mu PG I'll show that in</font><font color="#E5E5E5"> later</font>

242
00:10:08,589 --> 00:10:15,310
version of<font color="#E5E5E5"> loci G later so they do not</font>

243
00:10:12,520 --> 00:10:17,829
<font color="#CCCCCC">be g1 413 use</font><font color="#E5E5E5"> square multiply we know</font>

244
00:10:15,310 --> 00:10:19,630
that the algorithm does<font color="#E5E5E5"> is a squaring</font>

245
00:10:17,830 --> 00:10:21,910
and the exponentiation does squaring

246
00:10:19,630 --> 00:10:23,140
then modular reduction and then if the

247
00:10:21,910 --> 00:10:25,900
bit is<font color="#E5E5E5"> set it will also do</font>

248
00:10:23,140 --> 00:10:27,459
<font color="#E5E5E5">multiplication and modular reduction so</font>

249
00:10:25,900 --> 00:10:29,980
<font color="#E5E5E5">the part of the behavior that we expect</font>

250
00:10:27,459 --> 00:10:32,800
<font color="#E5E5E5">from the span square line is that short</font>

251
00:10:29,980 --> 00:10:35,260
<font color="#CCCCCC">bursts of activity when we do the square</font>

252
00:10:32,800 --> 00:10:39,310
then there will be some<font color="#CCCCCC"> inactivity for</font>

253
00:10:35,260 --> 00:10:42,490
<font color="#E5E5E5">the modular reduction and if the bit is</font>

254
00:10:39,310 --> 00:10:43,900
<font color="#CCCCCC">set then the interval of inactivity in</font>

255
00:10:42,490 --> 00:10:45,820
this square cache line will be a bit

256
00:10:43,900 --> 00:10:47,560
longer because it will take<font color="#CCCCCC"> we'll need</font>

257
00:10:45,820 --> 00:10:51,700
to do the multiply introduced after

258
00:10:47,560 --> 00:10:55,329
<font color="#CCCCCC">square use so in the diagram</font><font color="#E5E5E5"> we showed</font>

259
00:10:51,700 --> 00:10:57,250
<font color="#E5E5E5">we have some example of probes of cache</font>

260
00:10:55,330 --> 00:10:59,650
sets and we see<font color="#E5E5E5"> that some cache sets are</font>

261
00:10:57,250 --> 00:11:01,930
<font color="#E5E5E5">not active</font><font color="#CCCCCC"> and white</font><font color="#E5E5E5"> is not active black</font>

262
00:10:59,650 --> 00:11:03,910
is active we see<font color="#E5E5E5"> that some cache sets</font>

263
00:11:01,930 --> 00:11:05,709
are almost always<font color="#E5E5E5"> actives</font><font color="#CCCCCC"> and other</font>

264
00:11:03,910 --> 00:11:08,530
social shows some sporadic

265
00:11:05,710 --> 00:11:11,410
<font color="#E5E5E5">access and if we highlight one specific</font>

266
00:11:08,530 --> 00:11:13,839
<font color="#CCCCCC">cache line there the blue line we can</font>

267
00:11:11,410 --> 00:11:17,920
see<font color="#CCCCCC"> that we have the activity that</font><font color="#E5E5E5"> we</font>

268
00:11:13,840 --> 00:11:20,100
expect from the<font color="#E5E5E5"> square casual and we</font>

269
00:11:17,920 --> 00:11:23,170
have<font color="#CCCCCC"> burst of activity is appeared by a</font>

270
00:11:20,100 --> 00:11:25,360
two sizes<font color="#E5E5E5"> of intervals and</font><font color="#CCCCCC"> we can now</font>

271
00:11:23,170 --> 00:11:28,750
start reading the data<font color="#CCCCCC"> on the exponent</font>

272
00:11:25,360 --> 00:11:31,210
<font color="#CCCCCC">from</font><font color="#E5E5E5"> this data the first we have</font><font color="#CCCCCC"> Square</font>

273
00:11:28,750 --> 00:11:32,800
and modular reduction so and that's

274
00:11:31,210 --> 00:11:35,620
<font color="#E5E5E5">followed by another square so we know</font>

275
00:11:32,800 --> 00:11:37,510
that<font color="#CCCCCC"> this bit</font><font color="#E5E5E5"> was zero and then we have</font>

276
00:11:35,620 --> 00:11:40,330
the same pattern<font color="#E5E5E5"> again Square and short</font>

277
00:11:37,510 --> 00:11:41,860
interval and<font color="#E5E5E5"> zero then we have a large</font>

278
00:11:40,330 --> 00:11:44,260
interval so we<font color="#E5E5E5"> probably had a</font>

279
00:11:41,860 --> 00:11:46,990
multiplication<font color="#E5E5E5"> in the middle so the bit</font>

280
00:11:44,260 --> 00:11:49,689
is<font color="#E5E5E5"> 1 and we can continue and we get the</font>

281
00:11:46,990 --> 00:11:52,000
<font color="#CCCCCC">bits there and if we</font><font color="#E5E5E5"> do this</font><font color="#CCCCCC"> over the</font>

282
00:11:49,690 --> 00:11:54,130
<font color="#E5E5E5">whole exponentiation</font><font color="#CCCCCC"> we find the</font>

283
00:11:52,000 --> 00:11:59,980
<font color="#CCCCCC">exponent</font><font color="#E5E5E5"> and that's the private key and</font>

284
00:11:54,130 --> 00:12:02,490
we've broken this the encryption when we

285
00:11:59,980 --> 00:12:06,090
move to<font color="#E5E5E5"> a</font><font color="#CCCCCC"> newer version</font><font color="#E5E5E5"> of a</font><font color="#CCCCCC"> you know</font><font color="#E5E5E5"> PG</font>

286
00:12:02,490 --> 00:12:09,310
low PG<font color="#CCCCCC"> one for 18 uses</font><font color="#E5E5E5"> sliding-window</font>

287
00:12:06,090 --> 00:12:11,830
<font color="#E5E5E5">pronunciation this was the current</font>

288
00:12:09,310 --> 00:12:13,030
<font color="#E5E5E5">version when we did this</font><font color="#CCCCCC"> attack and the</font>

289
00:12:11,830 --> 00:12:15,370
main<font color="#CCCCCC"> differences</font><font color="#E5E5E5"> from</font><font color="#CCCCCC"> Square and</font>

290
00:12:13,030 --> 00:12:18,790
multiply is that to protect against the

291
00:12:15,370 --> 00:12:20,290
a flash reload<font color="#CCCCCC"> attack no PG</font><font color="#E5E5E5"> changed the</font>

292
00:12:18,790 --> 00:12:21,910
<font color="#E5E5E5">implementation of square they don't use</font>

293
00:12:20,290 --> 00:12:24,069
<font color="#E5E5E5">dedicated implemented instead they</font>

294
00:12:21,910 --> 00:12:26,079
multiply a number by itself<font color="#CCCCCC"> so it is</font>

295
00:12:24,070 --> 00:12:29,500
always it always<font color="#E5E5E5"> uses multiplications</font>

296
00:12:26,080 --> 00:12:31,750
<font color="#E5E5E5">and instead</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> having just one value</font>

297
00:12:29,500 --> 00:12:34,180
that<font color="#E5E5E5"> it can multiply when it does no</font>

298
00:12:31,750 --> 00:12:36,190
duplication it<font color="#CCCCCC"> precomputed pre-compute</font>

299
00:12:34,180 --> 00:12:38,709
<font color="#E5E5E5">eight</font><font color="#CCCCCC"> values that are</font><font color="#E5E5E5"> store in table and</font>

300
00:12:36,190 --> 00:12:41,260
it<font color="#E5E5E5"> uses the right one when when it needs</font>

301
00:12:38,710 --> 00:12:43,090
<font color="#CCCCCC">a I will not go into the details</font><font color="#E5E5E5"> of</font><font color="#CCCCCC"> how</font>

302
00:12:41,260 --> 00:12:47,580
and<font color="#CCCCCC"> why the sliding window works</font><font color="#E5E5E5"> that's</font>

303
00:12:43,090 --> 00:12:51,220
just the what we need to know<font color="#CCCCCC"> about it</font>

304
00:12:47,580 --> 00:12:53,200
now this presents several<font color="#E5E5E5"> new challenges</font>

305
00:12:51,220 --> 00:12:55,930
first<font color="#E5E5E5"> is that the multiplier table is</font>

306
00:12:53,200 --> 00:12:57,400
dynamically allocated so not only we

307
00:12:55,930 --> 00:12:59,560
<font color="#CCCCCC">don't know which cash set each</font>

308
00:12:57,400 --> 00:13:02,079
<font color="#CCCCCC">multiplier is in these changes between</font>

309
00:12:59,560 --> 00:13:04,089
exponentiation so each explanation<font color="#E5E5E5"> the</font>

310
00:13:02,080 --> 00:13:07,510
table will<font color="#CCCCCC"> be in different a memory</font>

311
00:13:04,090 --> 00:13:10,600
<font color="#CCCCCC">location and different</font><font color="#E5E5E5"> cache sets the</font>

312
00:13:07,510 --> 00:13:11,560
other problem is that memory<font color="#CCCCCC"> multiply</font>

313
00:13:10,600 --> 00:13:13,630
use is sparse

314
00:13:11,560 --> 00:13:15,219
<font color="#E5E5E5">irregular and we</font><font color="#CCCCCC"> actually don't know</font><font color="#E5E5E5"> the</font>

315
00:13:13,630 --> 00:13:16,570
actually the access pattern<font color="#E5E5E5"> because if</font>

316
00:13:15,220 --> 00:13:17,130
we knew the access<font color="#CCCCCC"> pattern we</font><font color="#E5E5E5"> could've</font>

317
00:13:16,570 --> 00:13:20,820
recovered

318
00:13:17,130 --> 00:13:22,980
<font color="#E5E5E5">key to begin with so we have a very weak</font>

319
00:13:20,820 --> 00:13:25,320
signal there and we don't<font color="#CCCCCC"> know</font><font color="#E5E5E5"> what the</font>

320
00:13:22,980 --> 00:13:26,670
signal looked like<font color="#E5E5E5"> and the last problem</font>

321
00:13:25,320 --> 00:13:29,880
<font color="#E5E5E5">is that we cannot distinguish between</font>

322
00:13:26,670 --> 00:13:32,969
<font color="#E5E5E5">squares and multiplications</font><font color="#CCCCCC"> so what do</font>

323
00:13:29,880 --> 00:13:34,680
we<font color="#E5E5E5"> do first we find the multiplication</font>

324
00:13:32,970 --> 00:13:37,580
<font color="#CCCCCC">code</font><font color="#E5E5E5"> we know how to do that it's the</font>

325
00:13:34,680 --> 00:13:41,699
same<font color="#E5E5E5"> as we</font><font color="#CCCCCC"> found the square code in the</font>

326
00:13:37,580 --> 00:13:44,370
previous attack and if we look here<font color="#CCCCCC"> we</font>

327
00:13:41,700 --> 00:13:45,870
find that<font color="#E5E5E5"> in this code and we</font><font color="#CCCCCC"> we</font><font color="#E5E5E5"> saw we</font>

328
00:13:44,370 --> 00:13:47,880
shall<font color="#E5E5E5"> with</font><font color="#CCCCCC"> sees the access that it will</font>

329
00:13:45,870 --> 00:13:49,890
always be multiplied or do use<font color="#E5E5E5"> multiply</font>

330
00:13:47,880 --> 00:13:52,530
<font color="#CCCCCC">induce</font><font color="#E5E5E5"> because there are no</font><font color="#CCCCCC"> squares</font><font color="#E5E5E5"> in</font>

331
00:13:49,890 --> 00:13:54,660
between<font color="#E5E5E5"> so the access is very regular</font>

332
00:13:52,530 --> 00:13:57,209
<font color="#CCCCCC">and this doesn't give us any information</font>

333
00:13:54,660 --> 00:14:00,329
<font color="#CCCCCC">about the key</font><font color="#E5E5E5"> because we knew it will be</font>

334
00:13:57,210 --> 00:14:02,460
<font color="#CCCCCC">multiplying separated by reduce but what</font>

335
00:14:00,330 --> 00:14:06,360
it does tell<font color="#E5E5E5"> us it tells us</font><font color="#CCCCCC"> that at</font>

336
00:14:02,460 --> 00:14:07,830
around<font color="#E5E5E5"> time 50 the exponentiation</font>

337
00:14:06,360 --> 00:14:09,840
started because we didn't have<font color="#E5E5E5"> any</font>

338
00:14:07,830 --> 00:14:11,820
multiplication<font color="#E5E5E5"> before that and we can</font>

339
00:14:09,840 --> 00:14:14,370
tell when each multiplication is taking

340
00:14:11,820 --> 00:14:18,180
<font color="#E5E5E5">place so now the</font><font color="#CCCCCC"> only thing that we need</font>

341
00:14:14,370 --> 00:14:19,920
<font color="#CCCCCC">to do is find</font><font color="#E5E5E5"> the multipliers what we do</font>

342
00:14:18,180 --> 00:14:21,780
know about the multipliers is the at

343
00:14:19,920 --> 00:14:24,300
exactly<font color="#E5E5E5"> when we use the same key the</font>

344
00:14:21,780 --> 00:14:26,600
access<font color="#E5E5E5"> pattern repeats across</font>

345
00:14:24,300 --> 00:14:29,189
<font color="#CCCCCC">pronounciation so if a multiplier</font>

346
00:14:26,600 --> 00:14:31,380
specific multiplier is used in the third

347
00:14:29,190 --> 00:14:33,870
multiplication<font color="#E5E5E5"> it will always be used in</font>

348
00:14:31,380 --> 00:14:35,939
the third multiplication so<font color="#E5E5E5"> we know that</font>

349
00:14:33,870 --> 00:14:37,830
<font color="#CCCCCC">we have some a temporal access pattern</font>

350
00:14:35,940 --> 00:14:42,150
<font color="#E5E5E5">that we need to find we don't know what</font>

351
00:14:37,830 --> 00:14:43,800
the pattern is but it exists<font color="#E5E5E5"> the way to</font>

352
00:14:42,150 --> 00:14:45,930
find patterns<font color="#E5E5E5"> that we don't know about</font>

353
00:14:43,800 --> 00:14:47,849
<font color="#E5E5E5">what they</font><font color="#CCCCCC"> are is we collect enough</font>

354
00:14:45,930 --> 00:14:50,250
patterns<font color="#E5E5E5"> and then we try</font><font color="#CCCCCC"> to cluster them</font>

355
00:14:47,850 --> 00:14:53,100
<font color="#CCCCCC">will search</font><font color="#E5E5E5"> for similarities so that's</font>

356
00:14:50,250 --> 00:14:58,350
exactly<font color="#E5E5E5"> what we do we collect long</font>

357
00:14:53,100 --> 00:14:59,850
traces that tell us both that<font color="#E5E5E5"> for both</font>

358
00:14:58,350 --> 00:15:03,120
<font color="#E5E5E5">the multiplication line and some</font>

359
00:14:59,850 --> 00:15:04,380
arbitrary<font color="#CCCCCC"> cash like cash assets</font><font color="#E5E5E5"> we want</font>

360
00:15:03,120 --> 00:15:06,060
the multiplication set to know<font color="#E5E5E5"> when</font>

361
00:15:04,380 --> 00:15:09,450
multiplication take place and then we

362
00:15:06,060 --> 00:15:12,060
can<font color="#E5E5E5"> tell and we can see when the victim</font>

363
00:15:09,450 --> 00:15:13,260
when the<font color="#E5E5E5"> cash that</font><font color="#CCCCCC"> it when</font><font color="#E5E5E5"> this came the</font>

364
00:15:12,060 --> 00:15:16,709
<font color="#E5E5E5">other cash that is used during</font>

365
00:15:13,260 --> 00:15:21,300
multiplication so<font color="#E5E5E5"> we collect this a huge</font>

366
00:15:16,710 --> 00:15:23,160
<font color="#E5E5E5">number of these traces and we run a</font>

367
00:15:21,300 --> 00:15:25,170
clustering<font color="#E5E5E5"> algorithm based on the</font><font color="#CCCCCC"> added</font>

368
00:15:23,160 --> 00:15:26,730
distance between them<font color="#E5E5E5"> and we get</font>

369
00:15:25,170 --> 00:15:30,089
<font color="#E5E5E5">something</font><font color="#CCCCCC"> like this</font><font color="#E5E5E5"> this</font><font color="#CCCCCC"> is a single</font>

370
00:15:26,730 --> 00:15:31,139
<font color="#E5E5E5">class there</font><font color="#CCCCCC"> so we have each row is a</font>

371
00:15:30,089 --> 00:15:34,790
trace of<font color="#E5E5E5"> an exponent</font>

372
00:15:31,139 --> 00:15:37,709
creation<font color="#E5E5E5"> and the horizontal</font><font color="#CCCCCC"> line</font><font color="#E5E5E5"> is the</font>

373
00:15:34,790 --> 00:15:40,349
multiplications in this or<font color="#CCCCCC"> a exponent in</font>

374
00:15:37,709 --> 00:15:42,388
<font color="#CCCCCC">the exponentiation</font><font color="#E5E5E5"> and the line is dark</font>

375
00:15:40,350 --> 00:15:44,759
is the position is dark if in that

376
00:15:42,389 --> 00:15:47,850
exponentiation<font color="#CCCCCC"> we</font><font color="#E5E5E5"> saw activity in that</font>

377
00:15:44,759 --> 00:15:50,429
<font color="#CCCCCC">cache set</font><font color="#E5E5E5"> okay in the cache set during</font>

378
00:15:47,850 --> 00:15:51,959
<font color="#E5E5E5">the multiplication and from here we</font><font color="#CCCCCC"> can</font>

379
00:15:50,429 --> 00:15:53,809
see<font color="#E5E5E5"> that we have pattern we</font><font color="#CCCCCC"> have the</font>

380
00:15:51,959 --> 00:15:57,209
each vertical<font color="#E5E5E5"> line which tells</font><font color="#CCCCCC"> us that</font>

381
00:15:53,809 --> 00:15:59,368
and<font color="#CCCCCC"> around that position</font><font color="#E5E5E5"> probably we had</font>

382
00:15:57,209 --> 00:16:00,779
we probably had multiplication there are

383
00:15:59,369 --> 00:16:02,009
some<font color="#E5E5E5"> arrows in the attack</font><font color="#CCCCCC"> but we can</font>

384
00:16:00,779 --> 00:16:04,109
clear and we can filter them easily

385
00:16:02,009 --> 00:16:06,660
<font color="#E5E5E5">because there aren't appear in one</font>

386
00:16:04,109 --> 00:16:08,809
explanation<font color="#E5E5E5"> not in others and we can</font>

387
00:16:06,660 --> 00:16:11,459
compare<font color="#CCCCCC"> these data to the ground</font><font color="#E5E5E5"> truth</font>

388
00:16:08,809 --> 00:16:13,980
<font color="#E5E5E5">we have that</font><font color="#CCCCCC"> one</font><font color="#E5E5E5"> truth and we see that</font>

389
00:16:11,459 --> 00:16:15,988
it<font color="#E5E5E5"> really matches we actually can say</font>

390
00:16:13,980 --> 00:16:17,279
which of<font color="#E5E5E5"> the multipliers this is because</font>

391
00:16:15,989 --> 00:16:19,889
the multiplier<font color="#E5E5E5"> is accessing the</font>

392
00:16:17,279 --> 00:16:22,109
pre-computation when it is computed<font color="#E5E5E5"> it's</font>

393
00:16:19,889 --> 00:16:24,119
<font color="#CCCCCC">a</font><font color="#E5E5E5"> fixed position</font><font color="#CCCCCC"> so this</font><font color="#E5E5E5"> allows us</font><font color="#CCCCCC"> to</font>

394
00:16:22,109 --> 00:16:25,649
<font color="#CCCCCC">find the the multiplier wouldn't look</font><font color="#E5E5E5"> at</font>

395
00:16:24,119 --> 00:16:27,359
<font color="#E5E5E5">the all the clusters</font><font color="#CCCCCC"> to find the</font><font color="#E5E5E5"> eight</font>

396
00:16:25,649 --> 00:16:32,249
multipliers<font color="#E5E5E5"> and we can recover the whole</font>

397
00:16:27,359 --> 00:16:35,220
key<font color="#E5E5E5"> from</font><font color="#CCCCCC"> that in summary we have cross</font>

398
00:16:32,249 --> 00:16:38,009
<font color="#CCCCCC">vm a cross kora synchronous attack on</font>

399
00:16:35,220 --> 00:16:41,639
two implementations<font color="#CCCCCC"> of exponentiation</font><font color="#E5E5E5"> in</font>

400
00:16:38,009 --> 00:16:43,499
two of different<font color="#CCCCCC"> versions no PG</font><font color="#E5E5E5"> the</font>

401
00:16:41,639 --> 00:16:49,169
square<font color="#E5E5E5"> and multiply which has been used</font>

402
00:16:43,499 --> 00:16:50,879
by<font color="#CCCCCC"> zhang and we had in we attack in less</font>

403
00:16:49,169 --> 00:16:54,660
than one minute compared<font color="#CCCCCC"> to</font><font color="#E5E5E5"> six hours</font>

404
00:16:50,879 --> 00:16:56,399
<font color="#CCCCCC">that the</font><font color="#E5E5E5"> attack took</font><font color="#CCCCCC"> a previously this</font>

405
00:16:54,660 --> 00:16:58,999
<font color="#E5E5E5">is</font><font color="#CCCCCC"> still slower than flash</font><font color="#E5E5E5"> reload attack</font>

406
00:16:56,399 --> 00:17:02,129
but<font color="#CCCCCC"> unlike flash reload we don't need</font>

407
00:16:58,999 --> 00:17:03,779
<font color="#E5E5E5">duplication we have the attack on the</font>

408
00:17:02,129 --> 00:17:05,220
<font color="#E5E5E5">sliding window this one takes much</font>

409
00:17:03,779 --> 00:17:07,529
longer<font color="#E5E5E5"> because</font><font color="#CCCCCC"> we need to collect much</font>

410
00:17:05,220 --> 00:17:09,240
more data so we collect data<font color="#E5E5E5"> for 12</font>

411
00:17:07,529 --> 00:17:11,459
minutes then we do the clustering<font color="#E5E5E5"> and we</font>

412
00:17:09,240 --> 00:17:14,299
need some more manual processing to fix

413
00:17:11,459 --> 00:17:17,730
the errors in<font color="#CCCCCC"> the clustering</font><font color="#E5E5E5"> but we</font>

414
00:17:14,299 --> 00:17:20,429
achieve full key<font color="#E5E5E5"> recovery in total less</font>

415
00:17:17,730 --> 00:17:22,559
than 25<font color="#E5E5E5"> minutes this is something that</font>

416
00:17:20,429 --> 00:17:24,120
was<font color="#E5E5E5"> simply not feasible with</font><font color="#CCCCCC"> flash</font>

417
00:17:22,559 --> 00:17:25,888
reload<font color="#CCCCCC"> because it uses data that is</font>

418
00:17:24,119 --> 00:17:27,479
created dynamically<font color="#CCCCCC"> a flash reload needs</font>

419
00:17:25,888 --> 00:17:31,799
the duplication<font color="#E5E5E5"> doesn't happen with</font>

420
00:17:27,480 --> 00:17:34,649
without<font color="#CCCCCC"> the</font><font color="#E5E5E5"> duplication so to conclude</font>

421
00:17:31,799 --> 00:17:37,889
<font color="#E5E5E5">we have a practical side channel attack</font>

422
00:17:34,649 --> 00:17:39,658
that on the<font color="#E5E5E5"> last level cache this</font><font color="#CCCCCC"> stack</font>

423
00:17:37,889 --> 00:17:43,500
<font color="#CCCCCC">is synchronous</font><font color="#E5E5E5"> it is cross core and</font>

424
00:17:39,659 --> 00:17:44,380
cross<font color="#CCCCCC"> VM a we have a new attack strategy</font>

425
00:17:43,500 --> 00:17:46,360
that we

426
00:17:44,380 --> 00:17:48,790
search for temporal patterns<font color="#E5E5E5"> rather than</font>

427
00:17:46,360 --> 00:17:51,280
looking<font color="#CCCCCC"> for the special footprint that</font>

428
00:17:48,790 --> 00:17:52,990
<font color="#E5E5E5">the victim leaves in the cache we use</font>

429
00:17:51,280 --> 00:17:55,210
large pages to find<font color="#E5E5E5"> the mapping of</font>

430
00:17:52,990 --> 00:17:56,920
memory lines to cache sets and we have a

431
00:17:55,210 --> 00:17:59,350
new algorithm<font color="#E5E5E5"> that</font><font color="#CCCCCC"> map's these cash</font>

432
00:17:56,920 --> 00:18:01,180
assets into slight<font color="#CCCCCC"> 'el partition these</font>

433
00:17:59,350 --> 00:18:04,810
set into it into<font color="#E5E5E5"> slices</font>

434
00:18:01,180 --> 00:18:07,930
without knowing the<font color="#E5E5E5"> actual value we</font>

435
00:18:04,810 --> 00:18:09,820
<font color="#E5E5E5">implemented a best cover channel six</font>

436
00:18:07,930 --> 00:18:12,400
times faster<font color="#CCCCCC"> than</font><font color="#E5E5E5"> previous a cover</font>

437
00:18:09,820 --> 00:18:16,270
channel and last level cache<font color="#E5E5E5"> and we</font>

438
00:18:12,400 --> 00:18:19,420
<font color="#E5E5E5">identified and</font><font color="#CCCCCC"> helped fix a but a</font>

439
00:18:16,270 --> 00:18:21,250
vulnerability<font color="#CCCCCC"> name in the new PG now</font>

440
00:18:19,420 --> 00:18:24,490
before I take<font color="#CCCCCC"> questions I would</font><font color="#E5E5E5"> like to</font>

441
00:18:21,250 --> 00:18:27,910
<font color="#E5E5E5">invite my joint first author of funky</font>

442
00:18:24,490 --> 00:18:31,930
new she's a senior PhD student<font color="#E5E5E5"> in</font><font color="#CCCCCC"> the</font>

443
00:18:27,910 --> 00:18:33,010
Princeton<font color="#E5E5E5"> and they with that out thank</font>

444
00:18:31,930 --> 00:18:36,030
<font color="#E5E5E5">you for your attention</font>

445
00:18:33,010 --> 00:18:36,030
<font color="#CCCCCC">and I'm happy to</font><font color="#E5E5E5"> answer questions</font>

446
00:18:41,030 --> 00:18:45,810
but in the interest<font color="#E5E5E5"> of fairness I'll ask</font>

447
00:18:44,550 --> 00:18:48,780
you<font color="#E5E5E5"> the same question</font><font color="#CCCCCC"> ask the last</font>

448
00:18:45,810 --> 00:18:50,820
speaker such as what<font color="#CCCCCC"> is the workload and</font>

449
00:18:48,780 --> 00:18:52,500
<font color="#CCCCCC">was there anything</font><font color="#E5E5E5"> running this besides</font>

450
00:18:50,820 --> 00:18:56,580
<font color="#E5E5E5">the measurement in</font><font color="#CCCCCC"> spice</font><font color="#E5E5E5"> most policies</font>

451
00:18:52,500 --> 00:18:59,390
<font color="#CCCCCC">ok</font><font color="#E5E5E5"> we didn't try to make things really</font>

452
00:18:56,580 --> 00:19:03,030
quiet but<font color="#E5E5E5"> we didn't run anything but the</font>

453
00:18:59,390 --> 00:19:05,820
two virtual<font color="#E5E5E5"> machines</font><font color="#CCCCCC"> we do see</font><font color="#E5E5E5"> some</font>

454
00:19:03,030 --> 00:19:07,350
system noise but we don't know<font color="#E5E5E5"> whether</font>

455
00:19:05,820 --> 00:19:12,510
the attack will work in presence of

456
00:19:07,350 --> 00:19:14,639
<font color="#E5E5E5">noise so</font><font color="#CCCCCC"> I guess I have</font><font color="#E5E5E5"> to repeat my</font>

457
00:19:12,510 --> 00:19:18,620
previous question<font color="#CCCCCC"> to that did you try it</font>

458
00:19:14,640 --> 00:19:21,060
on Amazon<font color="#CCCCCC"> I would like to answer the</font>

459
00:19:18,620 --> 00:19:23,360
<font color="#CCCCCC">same answer but no we</font><font color="#E5E5E5"> haven't tried and</font>

460
00:19:21,060 --> 00:19:26,879
it's not<font color="#CCCCCC"> only</font><font color="#E5E5E5"> in that paper</font>

461
00:19:23,360 --> 00:19:30,290
<font color="#E5E5E5">ok all right why don't</font><font color="#CCCCCC"> we thank the</font>

462
00:19:26,880 --> 00:19:30,290
speakers and the authors and

