1
00:00:01,399 --> 00:00:05,880
right indeed I'm Robert Watson I would

2
00:00:03,929 --> 00:00:06,990
list the<font color="#E5E5E5"> long list of quarters but</font>

3
00:00:05,880 --> 00:00:10,110
unfortunately<font color="#E5E5E5"> that would go</font><font color="#CCCCCC"> on for</font><font color="#E5E5E5"> a</font>

4
00:00:06,990 --> 00:00:11,370
<font color="#E5E5E5">while</font><font color="#CCCCCC"> I'm joined by co-authors from SRA</font>

5
00:00:10,110 --> 00:00:13,259
<font color="#CCCCCC">international University of Cambridge</font>

6
00:00:11,370 --> 00:00:16,439
<font color="#CCCCCC">Memorial University of Newfoundland</font>

7
00:00:13,259 --> 00:00:19,170
<font color="#E5E5E5">Google and UCL in London</font><font color="#CCCCCC"> this has been</font>

8
00:00:16,440 --> 00:00:20,580
thus far<font color="#CCCCCC"> a</font><font color="#E5E5E5"> five-year project</font><font color="#CCCCCC"> and if you</font>

9
00:00:19,170 --> 00:00:22,410
divide<font color="#E5E5E5"> the number</font><font color="#CCCCCC"> of minutes</font><font color="#E5E5E5"> of this</font>

10
00:00:20,580 --> 00:00:25,139
<font color="#E5E5E5">talk by five your</font><font color="#CCCCCC"> discoverer get</font><font color="#E5E5E5"> two to</font>

11
00:00:22,410 --> 00:00:27,480
<font color="#E5E5E5">three minutes per</font><font color="#CCCCCC"> year of research there</font>

12
00:00:25,140 --> 00:00:29,970
you are right<font color="#E5E5E5"> so I'm going to talk to</font>

13
00:00:27,480 --> 00:00:31,769
you about<font color="#E5E5E5"> cherry in architecture to</font>

14
00:00:29,970 --> 00:00:34,140
support<font color="#E5E5E5"> scalable compartmentalization</font>

15
00:00:31,769 --> 00:00:36,440
<font color="#E5E5E5">but to do that I first need to tell you</font>

16
00:00:34,140 --> 00:00:38,370
or<font color="#E5E5E5"> perhaps remind you about what</font>

17
00:00:36,440 --> 00:00:41,430
compartmentalization is<font color="#E5E5E5"> and why we do it</font>

18
00:00:38,370 --> 00:00:43,169
<font color="#CCCCCC">so software compartmentalization is a</font>

19
00:00:41,430 --> 00:00:44,850
mitigation<font color="#E5E5E5"> technique by which we</font>

20
00:00:43,170 --> 00:00:47,100
decompose software into isolated

21
00:00:44,850 --> 00:00:49,140
components and we delegate<font color="#E5E5E5"> to each of</font>

22
00:00:47,100 --> 00:00:51,210
those<font color="#E5E5E5"> components</font><font color="#CCCCCC"> only the rights they</font>

23
00:00:49,140 --> 00:00:52,920
require<font color="#CCCCCC"> to operate so motivated by the</font>

24
00:00:51,210 --> 00:00:54,390
principle<font color="#CCCCCC"> of least privilege the idea</font>

25
00:00:52,920 --> 00:00:55,440
there is that<font color="#E5E5E5"> when there is a</font>

26
00:00:54,390 --> 00:00:56,879
<font color="#CCCCCC">vulnerability and one of these</font>

27
00:00:55,440 --> 00:00:58,800
<font color="#CCCCCC">components the attacker is going</font><font color="#E5E5E5"> to gain</font>

28
00:00:56,879 --> 00:01:00,449
<font color="#CCCCCC">some</font><font color="#E5E5E5"> privileges in the system but not</font>

29
00:00:58,800 --> 00:01:02,038
all privileges<font color="#E5E5E5"> and this is a</font><font color="#CCCCCC"> widely</font>

30
00:01:00,449 --> 00:01:04,110
<font color="#CCCCCC">believed deployed software technique in</font>

31
00:01:02,039 --> 00:01:10,320
practice although<font color="#E5E5E5"> perhaps not as widely</font>

32
00:01:04,110 --> 00:01:11,400
as<font color="#E5E5E5"> we might like yeah</font><font color="#CCCCCC"> I have the same</font>

33
00:01:10,320 --> 00:01:13,169
<font color="#E5E5E5">problem</font><font color="#CCCCCC"> there all the speakers have you</font>

34
00:01:11,400 --> 00:01:17,070
can't easily see what it<font color="#E5E5E5"> is</font><font color="#CCCCCC"> up</font><font color="#E5E5E5"> on the</font>

35
00:01:13,170 --> 00:01:18,630
<font color="#E5E5E5">screen</font><font color="#CCCCCC"> so one of</font><font color="#E5E5E5"> the problems</font><font color="#CCCCCC"> that we</font>

36
00:01:17,070 --> 00:01:20,658
have<font color="#CCCCCC"> with software compartmentalization</font>

37
00:01:18,630 --> 00:01:23,220
<font color="#CCCCCC">is that there is</font><font color="#E5E5E5"> actually no single</font>

38
00:01:20,659 --> 00:01:25,439
compartmentalization

39
00:01:23,220 --> 00:01:27,810
no single compartmentalization we often

40
00:01:25,439 --> 00:01:28,919
speak of an application<font color="#E5E5E5"> as being simply</font>

41
00:01:27,810 --> 00:01:30,899
privileged separated or

42
00:01:28,920 --> 00:01:32,700
compartmentalized<font color="#CCCCCC"> but</font><font color="#E5E5E5"> actually you get a</font>

43
00:01:30,899 --> 00:01:34,560
range of design choices and trade-offs

44
00:01:32,700 --> 00:01:36,060
between performance<font color="#CCCCCC"> security and</font>

45
00:01:34,560 --> 00:01:37,860
complexity so if we want to<font color="#E5E5E5"> increase</font>

46
00:01:36,060 --> 00:01:39,840
<font color="#CCCCCC">security by making the</font>

47
00:01:37,860 --> 00:01:41,579
<font color="#CCCCCC">compartmentalization more granular</font><font color="#E5E5E5"> we're</font>

48
00:01:39,840 --> 00:01:45,060
going to have to pay a cost<font color="#E5E5E5"> in terms of</font>

49
00:01:41,579 --> 00:01:46,439
complexity<font color="#E5E5E5"> and performance</font><font color="#CCCCCC"> so an example</font>

50
00:01:45,060 --> 00:01:48,840
<font color="#E5E5E5">of this might be</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> Google is chromium</font>

51
00:01:46,439 --> 00:01:49,529
web browser<font color="#E5E5E5"> if you have chromium rain</font>

52
00:01:48,840 --> 00:01:51,630
then you're going<font color="#E5E5E5"> to be having</font>

53
00:01:49,530 --> 00:01:54,360
<font color="#E5E5E5">sandboxing going on different tabs are</font>

54
00:01:51,630 --> 00:01:55,770
running in different<font color="#E5E5E5"> sand boxes</font><font color="#CCCCCC"> but</font>

55
00:01:54,360 --> 00:01:57,390
we're<font color="#E5E5E5"> going to pay some architectural</font>

56
00:01:55,770 --> 00:01:59,360
costs and software costs in order<font color="#E5E5E5"> to</font>

57
00:01:57,390 --> 00:02:02,310
have that<font color="#E5E5E5"> we could have more granular</font>

58
00:01:59,360 --> 00:02:03,869
compartmentalization if we wanted<font color="#E5E5E5"> but</font><font color="#CCCCCC"> we</font>

59
00:02:02,310 --> 00:02:05,490
<font color="#CCCCCC">would then pay a great deal of</font>

60
00:02:03,869 --> 00:02:07,170
<font color="#E5E5E5">additional performance costs and it</font>

61
00:02:05,490 --> 00:02:09,930
turns<font color="#E5E5E5"> out a lot of this performance cost</font>

62
00:02:07,170 --> 00:02:11,550
<font color="#E5E5E5">comes out of the process</font><font color="#CCCCCC"> model</font><font color="#E5E5E5"> that</font>

63
00:02:09,930 --> 00:02:14,100
we're implementing compartmentalization

64
00:02:11,550 --> 00:02:14,849
with so there are really two costs<font color="#E5E5E5"> that</font>

65
00:02:14,100 --> 00:02:17,370
are in

66
00:02:14,849 --> 00:02:18,480
the first is<font color="#E5E5E5"> a performance cost that</font>

67
00:02:17,370 --> 00:02:20,640
<font color="#E5E5E5">comes out of</font><font color="#CCCCCC"> the hardware software</font>

68
00:02:18,480 --> 00:02:22,619
interface and the process model<font color="#E5E5E5"> so when</font>

69
00:02:20,640 --> 00:02:24,328
you create<font color="#E5E5E5"> processes you pay the cost in</font>

70
00:02:22,620 --> 00:02:26,370
memory for page tables and for memory

71
00:02:24,329 --> 00:02:28,379
access to them on every virtual address

72
00:02:26,370 --> 00:02:29,970
access<font color="#E5E5E5"> and then we have a translation</font>

73
00:02:28,379 --> 00:02:31,828
lookaside buffer<font color="#CCCCCC"> that's going to cache</font>

74
00:02:29,970 --> 00:02:33,420
the most frequently used mappings<font color="#E5E5E5"> and</font>

75
00:02:31,829 --> 00:02:35,340
one of the<font color="#E5E5E5"> problems of the TLB is not</font>

76
00:02:33,420 --> 00:02:36,750
<font color="#E5E5E5">only is it</font><font color="#CCCCCC"> a very expensive hardware</font>

77
00:02:35,340 --> 00:02:38,730
<font color="#CCCCCC">structure</font><font color="#E5E5E5"> it's an associative structure</font>

78
00:02:36,750 --> 00:02:40,680
but<font color="#E5E5E5"> also it's quite bounded in size when</font>

79
00:02:38,730 --> 00:02:41,849
we start to compartmentalize<font color="#E5E5E5"> software</font>

80
00:02:40,680 --> 00:02:43,829
we're going to have<font color="#E5E5E5"> more shared memory</font>

81
00:02:41,849 --> 00:02:46,048
we actually get multiple entries in<font color="#CCCCCC"> that</font>

82
00:02:43,829 --> 00:02:47,760
cash for<font color="#CCCCCC"> each underlying physical</font><font color="#E5E5E5"> page</font>

83
00:02:46,049 --> 00:02:50,370
of<font color="#E5E5E5"> memory that's being accessed so there</font>

84
00:02:47,760 --> 00:02:52,319
is a nasty scalability problem<font color="#E5E5E5"> and</font>

85
00:02:50,370 --> 00:02:53,099
second of<font color="#E5E5E5"> all we have a problem with</font>

86
00:02:52,319 --> 00:02:54,929
<font color="#CCCCCC">programmability</font>

87
00:02:53,099 --> 00:02:56,548
which<font color="#E5E5E5"> is that we force programmers to</font>

88
00:02:54,930 --> 00:02:57,780
work with multiple<font color="#E5E5E5"> address spaces at a</font>

89
00:02:56,549 --> 00:02:59,459
time which makes it<font color="#E5E5E5"> quite hard</font><font color="#CCCCCC"> to</font>

90
00:02:57,780 --> 00:03:01,470
difficult<font color="#E5E5E5"> right hard to write</font><font color="#CCCCCC"> software</font>

91
00:02:59,459 --> 00:03:03,450
and debug<font color="#E5E5E5"> it but we also force them</font><font color="#CCCCCC"> to</font>

92
00:03:01,470 --> 00:03:04,769
make<font color="#E5E5E5"> these compartments communicate with</font>

93
00:03:03,450 --> 00:03:06,510
each other using<font color="#CCCCCC"> inter</font><font color="#E5E5E5"> process</font>

94
00:03:04,769 --> 00:03:08,639
communication<font color="#E5E5E5"> which is sort of often</font>

95
00:03:06,510 --> 00:03:10,290
<font color="#CCCCCC">message-passing sometimes blend of</font>

96
00:03:08,639 --> 00:03:12,389
message passing<font color="#CCCCCC"> in shared memory but</font>

97
00:03:10,290 --> 00:03:14,638
<font color="#E5E5E5">either way is quite hard to debug and</font>

98
00:03:12,389 --> 00:03:16,620
understand and<font color="#E5E5E5"> if you've</font><font color="#CCCCCC"> used RPC will</font>

99
00:03:14,639 --> 00:03:19,650
probably have suffered<font color="#CCCCCC"> with the authors</font>

100
00:03:16,620 --> 00:03:20,849
<font color="#CCCCCC">of many of these</font><font color="#E5E5E5"> applications these kind</font>

101
00:03:19,650 --> 00:03:22,290
of problems<font color="#E5E5E5"> show up when we use</font>

102
00:03:20,849 --> 00:03:24,268
compartmentalize applications<font color="#E5E5E5"> today</font>

103
00:03:22,290 --> 00:03:25,918
quite visibly<font color="#E5E5E5"> if you use Chrome and you</font>

104
00:03:24,269 --> 00:03:27,209
<font color="#E5E5E5">have sandbox tabs you'll discover that</font>

105
00:03:25,919 --> 00:03:28,769
<font color="#E5E5E5">as you increase the number</font><font color="#CCCCCC"> of tabs</font>

106
00:03:27,209 --> 00:03:30,629
eventually chrome decides<font color="#E5E5E5"> that the</font>

107
00:03:28,769 --> 00:03:32,129
performance overhead<font color="#E5E5E5"> is excessive scaled</font>

108
00:03:30,629 --> 00:03:34,379
to<font color="#CCCCCC"> the hardware available on the machine</font>

109
00:03:32,129 --> 00:03:36,268
and<font color="#E5E5E5"> will start combining different tabs</font>

110
00:03:34,379 --> 00:03:38,069
<font color="#E5E5E5">in the same</font><font color="#CCCCCC"> sound boxes which goes</font>

111
00:03:36,269 --> 00:03:40,079
defeats the purpose in many ways of

112
00:03:38,069 --> 00:03:42,388
having granular<font color="#CCCCCC"> sound boxing</font><font color="#E5E5E5"> and that is</font>

113
00:03:40,079 --> 00:03:44,010
a direct<font color="#CCCCCC"> result</font><font color="#E5E5E5"> of the design choices</font>

114
00:03:42,389 --> 00:03:45,959
that<font color="#CCCCCC"> are present in hardware</font><font color="#E5E5E5"> and</font>

115
00:03:44,010 --> 00:03:47,849
<font color="#E5E5E5">low-level software so if we would like</font>

116
00:03:45,959 --> 00:03:49,500
to<font color="#E5E5E5"> promote more granularity in</font>

117
00:03:47,849 --> 00:03:51,149
<font color="#E5E5E5">compartmentalization</font><font color="#CCCCCC"> which would give us</font>

118
00:03:49,500 --> 00:03:53,159
more resilience to exploited

119
00:03:51,150 --> 00:03:54,870
vulnerabilities<font color="#CCCCCC"> then we would really</font>

120
00:03:53,159 --> 00:03:56,370
like<font color="#CCCCCC"> to be able</font><font color="#E5E5E5"> to have many more of</font>

121
00:03:54,870 --> 00:03:58,769
<font color="#E5E5E5">these compartments so might ask the</font>

122
00:03:56,370 --> 00:04:00,810
<font color="#CCCCCC">question</font><font color="#E5E5E5"> how could we accomplish</font><font color="#CCCCCC"> that</font>

123
00:03:58,769 --> 00:04:02,609
<font color="#E5E5E5">using architectural features give you</font>

124
00:04:00,810 --> 00:04:03,449
another example<font color="#CCCCCC"> in my previous slide</font>

125
00:04:02,609 --> 00:04:06,120
<font color="#CCCCCC">when I told you</font><font color="#E5E5E5"> about</font>

126
00:04:03,449 --> 00:04:08,699
compartmentalization<font color="#CCCCCC"> I showed you</font><font color="#E5E5E5"> the</font>

127
00:04:06,120 --> 00:04:10,919
<font color="#CCCCCC">Gion zip application in</font><font color="#E5E5E5"> UNIX which</font>

128
00:04:08,699 --> 00:04:12,780
normally runs in a<font color="#CCCCCC"> single process</font><font color="#E5E5E5"> when</font>

129
00:04:10,919 --> 00:04:14,669
we compartmentalize it we break<font color="#E5E5E5"> it into</font>

130
00:04:12,780 --> 00:04:15,930
<font color="#CCCCCC">multiple processes we learn something</font>

131
00:04:14,669 --> 00:04:18,269
<font color="#CCCCCC">interesting when we were doing that</font>

132
00:04:15,930 --> 00:04:19,349
which is<font color="#CCCCCC"> that gzip</font><font color="#E5E5E5"> as an application</font>

133
00:04:18,269 --> 00:04:21,269
compartmentalised

134
00:04:19,349 --> 00:04:22,979
very efficiently and<font color="#E5E5E5"> very well since</font>

135
00:04:21,269 --> 00:04:25,050
<font color="#CCCCCC">it's higher level</font><font color="#E5E5E5"> api's</font><font color="#CCCCCC"> use file</font>

136
00:04:22,979 --> 00:04:27,539
descriptors which are easily delegated

137
00:04:25,050 --> 00:04:28,320
using conventional<font color="#E5E5E5"> process model but if</font>

138
00:04:27,539 --> 00:04:29,820
we wanted<font color="#CCCCCC"> to</font><font color="#E5E5E5"> put the</font>

139
00:04:28,320 --> 00:04:31,560
<font color="#E5E5E5">apartment realization where it was most</font>

140
00:04:29,820 --> 00:04:33,630
necessary<font color="#CCCCCC"> which is say we'd like to put</font>

141
00:04:31,560 --> 00:04:35,280
<font color="#E5E5E5">it in the</font><font color="#CCCCCC"> Zed live library which suffers</font>

142
00:04:33,630 --> 00:04:37,320
<font color="#E5E5E5">most of the vulnerabilities</font><font color="#CCCCCC"> that way if</font>

143
00:04:35,280 --> 00:04:38,820
we compartmentalize<font color="#CCCCCC"> Zed Lib every</font>

144
00:04:37,320 --> 00:04:40,590
<font color="#E5E5E5">application would benefit from the</font>

145
00:04:38,820 --> 00:04:41,909
compartmentalization<font color="#CCCCCC"> we couldn't do that</font>

146
00:04:40,590 --> 00:04:44,880
<font color="#E5E5E5">and it was for both</font><font color="#CCCCCC"> of these reasons</font>

147
00:04:41,910 --> 00:04:46,290
which is to say<font color="#E5E5E5"> the library interfaces</font>

148
00:04:44,880 --> 00:04:48,390
were not suitable<font color="#CCCCCC"> for use with</font>

149
00:04:46,290 --> 00:04:49,980
<font color="#CCCCCC">inter-process communication and the</font>

150
00:04:48,390 --> 00:04:54,060
<font color="#E5E5E5">program of</font><font color="#CCCCCC"> those</font><font color="#E5E5E5"> Liebman challenges were</font>

151
00:04:49,980 --> 00:04:56,040
substantial so<font color="#E5E5E5"> that's the next</font><font color="#CCCCCC"> slide</font><font color="#E5E5E5"> so</font>

152
00:04:54,060 --> 00:04:57,570
<font color="#CCCCCC">over the last couple</font><font color="#E5E5E5"> of years we've</font>

153
00:04:56,040 --> 00:05:00,480
published a number of papers on the

154
00:04:57,570 --> 00:05:02,310
<font color="#CCCCCC">Cherry capability model</font><font color="#E5E5E5"> so in 2014 we</font>

155
00:05:00,480 --> 00:05:04,590
published a<font color="#E5E5E5"> paper at</font><font color="#CCCCCC"> iske</font><font color="#E5E5E5"> on a</font>

156
00:05:02,310 --> 00:05:06,510
<font color="#CCCCCC">fine-grained</font><font color="#E5E5E5"> in address space memory</font>

157
00:05:04,590 --> 00:05:08,190
protection model based on<font color="#E5E5E5"> the idea of</font>

158
00:05:06,510 --> 00:05:10,530
capabilities so<font color="#E5E5E5"> you may remember that a</font>

159
00:05:08,190 --> 00:05:12,390
capability<font color="#E5E5E5"> is a token</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> authority</font><font color="#CCCCCC"> and</font>

160
00:05:10,530 --> 00:05:13,679
writing grants and delegates rights and

161
00:05:12,390 --> 00:05:16,409
if you don't have the capability<font color="#CCCCCC"> you</font>

162
00:05:13,680 --> 00:05:19,050
<font color="#E5E5E5">can't construct it so</font><font color="#CCCCCC"> what</font><font color="#E5E5E5"> we did was we</font>

163
00:05:16,410 --> 00:05:21,000
<font color="#E5E5E5">implemented within address spaces the</font>

164
00:05:19,050 --> 00:05:23,190
ability to<font color="#E5E5E5"> use capabilities instead of</font>

165
00:05:21,000 --> 00:05:24,900
pointers<font color="#E5E5E5"> to reference data and this gave</font>

166
00:05:23,190 --> 00:05:26,880
us some very<font color="#E5E5E5"> strong protection</font>

167
00:05:24,900 --> 00:05:29,190
properties in<font color="#E5E5E5"> particular we gradually</font>

168
00:05:26,880 --> 00:05:30,810
shifted pointers out of the general

169
00:05:29,190 --> 00:05:33,090
<font color="#E5E5E5">purpose register file and into a</font>

170
00:05:30,810 --> 00:05:35,220
capability register file that offered

171
00:05:33,090 --> 00:05:37,169
monotonic decreases in rights and other

172
00:05:35,220 --> 00:05:39,150
capability<font color="#CCCCCC"> light properties and we also</font>

173
00:05:37,170 --> 00:05:40,860
<font color="#E5E5E5">provided</font><font color="#CCCCCC"> tagged</font><font color="#E5E5E5"> memory that allows</font>

174
00:05:39,150 --> 00:05:43,710
capabilities to maintain their integrity

175
00:05:40,860 --> 00:05:45,420
<font color="#E5E5E5">when stored outside of</font><font color="#CCCCCC"> the register file</font>

176
00:05:43,710 --> 00:05:47,400
in<font color="#E5E5E5"> RAM and we got from this among other</font>

177
00:05:45,420 --> 00:05:49,080
<font color="#CCCCCC">things integrity protection</font><font color="#E5E5E5"> for pointers</font>

178
00:05:47,400 --> 00:05:50,909
themselves<font color="#E5E5E5"> extremely strong integrity</font>

179
00:05:49,080 --> 00:05:52,740
protection<font color="#CCCCCC"> a measure of control flow</font>

180
00:05:50,910 --> 00:05:55,320
integrity<font color="#CCCCCC"> because we can also use these</font>

181
00:05:52,740 --> 00:05:57,600
<font color="#CCCCCC">capabilities for jump targets and return</font>

182
00:05:55,320 --> 00:05:59,070
addresses<font color="#E5E5E5"> and so on and also bounds</font>

183
00:05:57,600 --> 00:06:00,720
<font color="#CCCCCC">checking so the ability</font><font color="#E5E5E5"> to prevent</font>

184
00:05:59,070 --> 00:06:03,480
<font color="#CCCCCC">overflows or buffers and</font><font color="#E5E5E5"> a variety of</font>

185
00:06:00,720 --> 00:06:05,040
related<font color="#CCCCCC"> types</font><font color="#E5E5E5"> of problems the real</font>

186
00:06:03,480 --> 00:06:06,960
contribution in the paper though is the

187
00:06:05,040 --> 00:06:08,910
hybridization<font color="#CCCCCC"> with the memory management</font>

188
00:06:06,960 --> 00:06:10,890
unit which is to say this model composes

189
00:06:08,910 --> 00:06:12,600
very nicely with a virtual<font color="#CCCCCC"> address based</font>

190
00:06:10,890 --> 00:06:15,030
model so this allows<font color="#CCCCCC"> us</font><font color="#E5E5E5"> to experiment</font>

191
00:06:12,600 --> 00:06:17,100
with capability system designs<font color="#E5E5E5"> within a</font>

192
00:06:15,030 --> 00:06:19,770
conventional architectural design or

193
00:06:17,100 --> 00:06:21,120
operating<font color="#CCCCCC"> system design this</font><font color="#E5E5E5"> spring we</font>

194
00:06:19,770 --> 00:06:22,890
published another paper and<font color="#E5E5E5"> this was on</font>

195
00:06:21,120 --> 00:06:25,020
using the C programming language

196
00:06:22,890 --> 00:06:27,060
capabilities which<font color="#CCCCCC"> is to say asking the</font>

197
00:06:25,020 --> 00:06:28,680
<font color="#CCCCCC">compiled compiler to generate capability</font>

198
00:06:27,060 --> 00:06:30,060
instructions<font color="#E5E5E5"> and use capabilities</font>

199
00:06:28,680 --> 00:06:31,980
instead of using general-purpose

200
00:06:30,060 --> 00:06:34,380
registers<font color="#CCCCCC"> so we were able to have</font>

201
00:06:31,980 --> 00:06:35,880
existing C code structures map into a

202
00:06:34,380 --> 00:06:37,169
very<font color="#CCCCCC"> fine-grained memory protection</font>

203
00:06:35,880 --> 00:06:39,659
model with a high<font color="#CCCCCC"> level of compatibility</font>

204
00:06:37,169 --> 00:06:41,669
<font color="#CCCCCC">and to do that</font><font color="#E5E5E5"> we had</font><font color="#CCCCCC"> to merge ideas</font>

205
00:06:39,660 --> 00:06:42,120
from fat pointers which have to with the

206
00:06:41,669 --> 00:06:44,639
<font color="#E5E5E5">fact that</font>

207
00:06:42,120 --> 00:06:46,530
see a<font color="#CCCCCC"> pointer</font><font color="#E5E5E5"> may range throughout the</font>

208
00:06:44,639 --> 00:06:48,600
bounds or<font color="#E5E5E5"> paps in fact beyond the bounds</font>

209
00:06:46,530 --> 00:06:51,388
that<font color="#E5E5E5"> are present for the buffer that</font>

210
00:06:48,600 --> 00:06:52,560
<font color="#E5E5E5">it's in and maybe come back in again</font><font color="#CCCCCC"> and</font>

211
00:06:51,389 --> 00:06:54,750
<font color="#E5E5E5">we need to merge those with capabilities</font>

212
00:06:52,560 --> 00:06:56,400
<font color="#CCCCCC">to</font><font color="#E5E5E5"> get the strong integrity properties</font>

213
00:06:54,750 --> 00:06:57,510
so we<font color="#CCCCCC"> were able to use a compiler</font><font color="#E5E5E5"> to</font>

214
00:06:56,400 --> 00:06:58,969
<font color="#E5E5E5">generate these and of course we're now</font>

215
00:06:57,510 --> 00:07:01,139
<font color="#CCCCCC">able to run with</font><font color="#E5E5E5"> these on top of</font><font color="#CCCCCC"> cherry</font>

216
00:06:58,970 --> 00:07:02,750
<font color="#E5E5E5">which really begs the question if</font>

217
00:07:01,139 --> 00:07:05,460
existing fine-grained

218
00:07:02,750 --> 00:07:07,110
compartmentalization<font color="#E5E5E5"> is based on memory</font>

219
00:07:05,460 --> 00:07:08,969
protection using<font color="#E5E5E5"> the</font><font color="#CCCCCC"> LM you</font><font color="#E5E5E5"> can we</font>

220
00:07:07,110 --> 00:07:11,490
construct similar kinds of<font color="#E5E5E5"> structures</font>

221
00:07:08,970 --> 00:07:13,110
using<font color="#E5E5E5"> the capability model within</font>

222
00:07:11,490 --> 00:07:14,880
address spaces<font color="#E5E5E5"> which might be a better</font>

223
00:07:13,110 --> 00:07:16,590
way<font color="#CCCCCC"> to accomplish fine-grained</font>

224
00:07:14,880 --> 00:07:19,560
compartmentalization<font color="#E5E5E5"> within an</font>

225
00:07:16,590 --> 00:07:20,549
<font color="#CCCCCC">application so I suppose</font><font color="#E5E5E5"> it begs the</font>

226
00:07:19,560 --> 00:07:22,020
<font color="#E5E5E5">question and the answer</font><font color="#CCCCCC"> is unfortunately</font>

227
00:07:20,550 --> 00:07:24,330
<font color="#CCCCCC">obviously</font><font color="#E5E5E5"> we wouldn't have written the</font>

228
00:07:22,020 --> 00:07:25,530
<font color="#E5E5E5">paper so let's</font><font color="#CCCCCC"> take a look through</font><font color="#E5E5E5"> a</font>

229
00:07:24,330 --> 00:07:27,990
<font color="#E5E5E5">couple of the differences between</font>

230
00:07:25,530 --> 00:07:29,580
virtual memory and capabilities but as I

231
00:07:27,990 --> 00:07:31,410
tell<font color="#CCCCCC"> you about these</font><font color="#E5E5E5"> differences which</font>

232
00:07:29,580 --> 00:07:33,359
you<font color="#E5E5E5"> remember that in</font><font color="#CCCCCC"> Cherry</font><font color="#E5E5E5"> we can do</font>

233
00:07:31,410 --> 00:07:34,740
both<font color="#CCCCCC"> which is to say whenever we find a</font>

234
00:07:33,360 --> 00:07:36,690
<font color="#E5E5E5">memory protection problem or a</font>

235
00:07:34,740 --> 00:07:38,430
compartmentalization problem we're going

236
00:07:36,690 --> 00:07:40,410
<font color="#E5E5E5">to pick one</font><font color="#CCCCCC"> of these two technologies or</font>

237
00:07:38,430 --> 00:07:43,229
perhaps combine them to<font color="#E5E5E5"> accomplish our</font>

238
00:07:40,410 --> 00:07:44,850
goals<font color="#CCCCCC"> so the first question</font><font color="#E5E5E5"> we have to</font>

239
00:07:43,229 --> 00:07:46,380
ask<font color="#CCCCCC"> for the two</font><font color="#E5E5E5"> different models is what</font>

240
00:07:44,850 --> 00:07:48,599
can they predict<font color="#E5E5E5"> what are they good at</font>

241
00:07:46,380 --> 00:07:50,280
protecting<font color="#E5E5E5"> well virtual memory</font><font color="#CCCCCC"> is good</font>

242
00:07:48,599 --> 00:07:52,860
at protecting virtual addresses which is

243
00:07:50,280 --> 00:07:54,989
to say the underlying storage<font color="#E5E5E5"> of data</font>

244
00:07:52,860 --> 00:07:57,060
<font color="#E5E5E5">inside an address space it does so at a</font>

245
00:07:54,990 --> 00:07:59,520
very<font color="#E5E5E5"> coarse granularity that of pages</font>

246
00:07:57,060 --> 00:08:01,289
<font color="#CCCCCC">the capability model allows us to</font>

247
00:07:59,520 --> 00:08:02,849
<font color="#E5E5E5">protect the references to data rather</font>

248
00:08:01,289 --> 00:08:04,409
than<font color="#CCCCCC"> the</font><font color="#E5E5E5"> underlying storage of data and</font>

249
00:08:02,849 --> 00:08:06,000
<font color="#E5E5E5">this turns out to</font><font color="#CCCCCC"> be quite programmer</font>

250
00:08:04,410 --> 00:08:07,380
<font color="#CCCCCC">friendly because often you take a</font>

251
00:08:06,000 --> 00:08:09,180
reference<font color="#CCCCCC"> to an object you pass the</font>

252
00:08:07,380 --> 00:08:10,320
references around<font color="#E5E5E5"> you want to limit what</font>

253
00:08:09,180 --> 00:08:11,760
they can do perhaps this one is a

254
00:08:10,320 --> 00:08:13,349
read-only reference<font color="#E5E5E5"> whereas the other</font>

255
00:08:11,760 --> 00:08:15,479
one is<font color="#E5E5E5"> a modifiable reference or maybe</font>

256
00:08:13,349 --> 00:08:17,940
we will subset access to a portion<font color="#CCCCCC"> of</font>

257
00:08:15,479 --> 00:08:19,710
memory<font color="#E5E5E5"> so with</font><font color="#CCCCCC"> capabilities we can use</font>

258
00:08:17,940 --> 00:08:21,570
them to<font color="#CCCCCC"> describe</font><font color="#E5E5E5"> C code and data</font>

259
00:08:19,710 --> 00:08:23,520
structures<font color="#CCCCCC"> so much more focused at</font><font color="#E5E5E5"> the</font>

260
00:08:21,570 --> 00:08:25,050
internals of<font color="#CCCCCC"> an application whereas</font>

261
00:08:23,520 --> 00:08:26,820
paging is focused<font color="#E5E5E5"> on the overall</font>

262
00:08:25,050 --> 00:08:29,220
<font color="#E5E5E5">structure and virtualization of the</font>

263
00:08:26,820 --> 00:08:30,599
application on the hardware<font color="#CCCCCC"> side we</font>

264
00:08:29,220 --> 00:08:32,969
retain access<font color="#E5E5E5"> to a memory management</font>

265
00:08:30,599 --> 00:08:35,159
<font color="#CCCCCC">unit and</font><font color="#E5E5E5"> a TLB</font><font color="#CCCCCC"> sort of conventions</font><font color="#E5E5E5"> of</font>

266
00:08:32,969 --> 00:08:37,469
virtual<font color="#E5E5E5"> memory and virtual addressing as</font>

267
00:08:35,159 --> 00:08:39,479
I described<font color="#CCCCCC"> on the capability system</font>

268
00:08:37,469 --> 00:08:41,010
side we have capability registers which

269
00:08:39,479 --> 00:08:43,080
are going<font color="#E5E5E5"> to gradually displace</font>

270
00:08:41,010 --> 00:08:45,240
general-purpose registers<font color="#E5E5E5"> as the storage</font>

271
00:08:43,080 --> 00:08:47,010
<font color="#E5E5E5">for pointers and we also make use of tag</font>

272
00:08:45,240 --> 00:08:48,959
memory<font color="#E5E5E5"> which comes at a small but</font>

273
00:08:47,010 --> 00:08:53,100
measurable<font color="#E5E5E5"> overhead so we use a</font><font color="#CCCCCC"> one bit</font>

274
00:08:48,959 --> 00:08:54,599
tag for every 256 bits of<font color="#E5E5E5"> memory all of</font>

275
00:08:53,100 --> 00:08:55,950
these systems<font color="#CCCCCC"> come with costs on</font><font color="#E5E5E5"> the</font>

276
00:08:54,600 --> 00:08:57,450
virtual<font color="#E5E5E5"> memory side we</font>

277
00:08:55,950 --> 00:08:59,460
<font color="#CCCCCC">and have the forgotten cost</font><font color="#E5E5E5"> of the</font>

278
00:08:57,450 --> 00:09:01,680
virtual memory subsystem<font color="#CCCCCC"> so for example</font>

279
00:08:59,460 --> 00:09:03,900
not<font color="#CCCCCC"> just the hardware cost of the TLB</font>

280
00:09:01,680 --> 00:09:05,969
but<font color="#CCCCCC"> also quite large page tables in</font>

281
00:09:03,900 --> 00:09:07,770
memory<font color="#CCCCCC"> continuously lookups and</font><font color="#E5E5E5"> also on</font>

282
00:09:05,970 --> 00:09:09,240
multiprocessor systems<font color="#E5E5E5"> we have to</font>

283
00:09:07,770 --> 00:09:10,829
perform<font color="#CCCCCC"> inter processor interrupts in</font>

284
00:09:09,240 --> 00:09:13,290
order to<font color="#CCCCCC"> revoke memory on reverse on</font>

285
00:09:10,830 --> 00:09:15,090
remote processes on the<font color="#CCCCCC"> capability side</font>

286
00:09:13,290 --> 00:09:17,069
<font color="#E5E5E5">we're going</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> incur a</font><font color="#CCCCCC"> per Poynter</font>

287
00:09:15,090 --> 00:09:19,050
overhead<font color="#CCCCCC"> so fairly measurable in terms</font>

288
00:09:17,070 --> 00:09:20,790
of cache footprint and so on and we're

289
00:09:19,050 --> 00:09:22,199
also implicitly<font color="#CCCCCC"> going to take an</font>

290
00:09:20,790 --> 00:09:23,670
additional<font color="#CCCCCC"> cost in context switching</font>

291
00:09:22,200 --> 00:09:26,400
because<font color="#E5E5E5"> we have to preserve this</font>

292
00:09:23,670 --> 00:09:27,599
additional<font color="#E5E5E5"> state so that was the work we</font>

293
00:09:26,400 --> 00:09:29,430
<font color="#CCCCCC">had presented in our previous</font><font color="#E5E5E5"> papers</font>

294
00:09:27,600 --> 00:09:31,340
what we add to<font color="#CCCCCC"> it in this paper</font><font color="#E5E5E5"> is</font>

295
00:09:29,430 --> 00:09:34,079
applying<font color="#E5E5E5"> the ideas to</font>

296
00:09:31,340 --> 00:09:35,850
compartmentalization itself<font color="#E5E5E5"> so virtual</font>

297
00:09:34,080 --> 00:09:37,370
memory is<font color="#E5E5E5"> quite good at maintaining</font>

298
00:09:35,850 --> 00:09:39,600
maybe tens or even hundreds of

299
00:09:37,370 --> 00:09:41,130
simultaneously active processes which I

300
00:09:39,600 --> 00:09:42,540
mean processes<font color="#E5E5E5"> that are continuously</font>

301
00:09:41,130 --> 00:09:44,070
<font color="#E5E5E5">running</font><font color="#CCCCCC"> and contexts</font><font color="#E5E5E5"> and switching</font>

302
00:09:42,540 --> 00:09:46,920
between<font color="#CCCCCC"> them</font><font color="#E5E5E5"> but at some point you're</font>

303
00:09:44,070 --> 00:09:48,120
<font color="#CCCCCC">TLB runs out of</font><font color="#E5E5E5"> juice with a capability</font>

304
00:09:46,920 --> 00:09:50,010
<font color="#CCCCCC">model we</font><font color="#E5E5E5"> would like to</font><font color="#CCCCCC"> be able</font><font color="#E5E5E5"> to</font>

305
00:09:48,120 --> 00:09:52,020
maintain thousands or tens of thousands

306
00:09:50,010 --> 00:09:54,090
of compartments one for every image<font color="#E5E5E5"> read</font>

307
00:09:52,020 --> 00:09:56,010
<font color="#E5E5E5">into your</font><font color="#CCCCCC"> web browser right</font><font color="#E5E5E5"> entering and</font>

308
00:09:54,090 --> 00:09:58,410
exiting it every time we process an

309
00:09:56,010 --> 00:10:00,240
additional row of pixels<font color="#E5E5E5"> for domain</font>

310
00:09:58,410 --> 00:10:01,110
<font color="#CCCCCC">crossing</font><font color="#E5E5E5"> conventional systems use inter</font>

311
00:10:00,240 --> 00:10:02,010
process communication

312
00:10:01,110 --> 00:10:03,360
I've already<font color="#E5E5E5"> told you</font><font color="#CCCCCC"> that is</font>

313
00:10:02,010 --> 00:10:05,100
problematic<font color="#CCCCCC"> from a programming</font>

314
00:10:03,360 --> 00:10:07,410
<font color="#E5E5E5">perspective we're going to model our</font>

315
00:10:05,100 --> 00:10:09,030
invocation<font color="#E5E5E5"> system on function calls try</font>

316
00:10:07,410 --> 00:10:10,980
to have a<font color="#E5E5E5"> constant overhead on the cost</font>

317
00:10:09,030 --> 00:10:12,240
of a traditional<font color="#E5E5E5"> function</font><font color="#CCCCCC"> call</font><font color="#E5E5E5"> and then</font>

318
00:10:10,980 --> 00:10:13,710
finally they have quite<font color="#CCCCCC"> different</font>

319
00:10:12,240 --> 00:10:15,720
optimization goals<font color="#E5E5E5"> that the focus of</font>

320
00:10:13,710 --> 00:10:17,670
virtual memory<font color="#CCCCCC"> is really</font><font color="#E5E5E5"> full a solution</font>

321
00:10:15,720 --> 00:10:19,320
and full<font color="#CCCCCC"> virtualization of</font><font color="#E5E5E5"> a system</font>

322
00:10:17,670 --> 00:10:21,000
we're interested in<font color="#E5E5E5"> a model that is</font>

323
00:10:19,320 --> 00:10:22,830
promoting memory sharing which is<font color="#E5E5E5"> to say</font>

324
00:10:21,000 --> 00:10:24,450
lots of memory moving back and forth

325
00:10:22,830 --> 00:10:26,130
<font color="#E5E5E5">between components so across library</font>

326
00:10:24,450 --> 00:10:27,960
interfaces and<font color="#E5E5E5"> so on and extremely</font>

327
00:10:26,130 --> 00:10:30,060
<font color="#E5E5E5">frequent domain transitions on the order</font>

328
00:10:27,960 --> 00:10:33,210
of<font color="#CCCCCC"> magnitude of function</font><font color="#E5E5E5"> calls so an</font>

329
00:10:30,060 --> 00:10:34,170
ambitious set<font color="#CCCCCC"> of goals</font><font color="#E5E5E5"> wants to talk to</font>

330
00:10:33,210 --> 00:10:35,910
you<font color="#E5E5E5"> briefly about how we're going to</font>

331
00:10:34,170 --> 00:10:37,349
approach<font color="#CCCCCC"> this</font><font color="#E5E5E5"> from an operating system</font>

332
00:10:35,910 --> 00:10:39,689
perspective<font color="#CCCCCC"> which is</font><font color="#E5E5E5"> the really the</font>

333
00:10:37,350 --> 00:10:40,800
focus of this talk<font color="#CCCCCC"> so in a conventional</font>

334
00:10:39,690 --> 00:10:42,870
system<font color="#E5E5E5"> you might have a memory</font>

335
00:10:40,800 --> 00:10:44,880
management<font color="#E5E5E5"> unit</font><font color="#CCCCCC"> a set of</font><font color="#E5E5E5"> processes able</font>

336
00:10:42,870 --> 00:10:46,380
to run applications<font color="#CCCCCC"> they linked against</font>

337
00:10:44,880 --> 00:10:48,420
<font color="#CCCCCC">libraries and so on all in</font><font color="#E5E5E5"> the same</font>

338
00:10:46,380 --> 00:10:49,620
<font color="#CCCCCC">address space</font><font color="#E5E5E5"> we're going to continue</font><font color="#CCCCCC"> to</font>

339
00:10:48,420 --> 00:10:50,939
<font color="#E5E5E5">support that</font><font color="#CCCCCC"> on the left end</font><font color="#E5E5E5"> of the</font>

340
00:10:49,620 --> 00:10:52,680
<font color="#E5E5E5">scale and they were now going to allow</font>

341
00:10:50,940 --> 00:10:54,180
you<font color="#CCCCCC"> to have libraries</font><font color="#E5E5E5"> that</font><font color="#CCCCCC"> make use of</font>

342
00:10:52,680 --> 00:10:55,859
<font color="#CCCCCC">fine grained memory protection and</font>

343
00:10:54,180 --> 00:10:57,630
compartmentalization internally

344
00:10:55,860 --> 00:10:59,100
<font color="#E5E5E5">invisible to the surrounding application</font>

345
00:10:57,630 --> 00:11:00,720
<font color="#E5E5E5">this is going to allow us to deploy</font>

346
00:10:59,100 --> 00:11:03,150
compartmentalization in libraries like

347
00:11:00,720 --> 00:11:05,070
Lib<font color="#CCCCCC"> King or Zed Lib transparently to the</font>

348
00:11:03,150 --> 00:11:06,750
consuming applications at a binary<font color="#CCCCCC"> level</font>

349
00:11:05,070 --> 00:11:08,730
which means<font color="#E5E5E5"> that if you have existing</font>

350
00:11:06,750 --> 00:11:09,750
<font color="#CCCCCC">for example Android apps that are</font><font color="#E5E5E5"> using</font>

351
00:11:08,730 --> 00:11:11,250
native code libraries

352
00:11:09,750 --> 00:11:13,590
shipped by the vendor you<font color="#CCCCCC"> the vendor</font>

353
00:11:11,250 --> 00:11:15,450
<font color="#CCCCCC">today</font><font color="#E5E5E5"> Google could in fact deploy these</font>

354
00:11:13,590 --> 00:11:16,740
features internally<font color="#E5E5E5"> without affecting</font>

355
00:11:15,450 --> 00:11:18,960
the binary structure<font color="#E5E5E5"> of the calling</font>

356
00:11:16,740 --> 00:11:21,120
<font color="#E5E5E5">application</font><font color="#CCCCCC"> if we move a</font><font color="#E5E5E5"> little bit</font>

357
00:11:18,960 --> 00:11:22,500
<font color="#E5E5E5">further along the spectrum</font><font color="#CCCCCC"> we're able</font><font color="#E5E5E5"> to</font>

358
00:11:21,120 --> 00:11:24,240
use what we call a pure capability

359
00:11:22,500 --> 00:11:26,250
application one linked<font color="#E5E5E5"> and compiled to</font>

360
00:11:24,240 --> 00:11:28,020
run entirely using capabilities<font color="#E5E5E5"> fine</font>

361
00:11:26,250 --> 00:11:29,490
<font color="#E5E5E5">grained memory protection and so on</font><font color="#CCCCCC"> but</font>

362
00:11:28,020 --> 00:11:31,680
<font color="#E5E5E5">we're going</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> allow you to run existing</font>

363
00:11:29,490 --> 00:11:34,170
<font color="#E5E5E5">binary compatible libraries inside</font><font color="#CCCCCC"> of</font>

364
00:11:31,680 --> 00:11:35,550
sound boxes inside the process<font color="#E5E5E5"> so we're</font>

365
00:11:34,170 --> 00:11:37,740
going to<font color="#E5E5E5"> be</font><font color="#CCCCCC"> able to support legacy</font>

366
00:11:35,550 --> 00:11:39,990
<font color="#CCCCCC">binary only libraries that</font><font color="#E5E5E5"> may be made</font>

367
00:11:37,740 --> 00:11:41,790
available by vendors<font color="#CCCCCC"> cherry can also</font>

368
00:11:39,990 --> 00:11:43,920
support<font color="#E5E5E5"> one more model which is to move</font>

369
00:11:41,790 --> 00:11:45,719
to a complete capability system approach

370
00:11:43,920 --> 00:11:47,250
where we have a single<font color="#E5E5E5"> virtual address</font>

371
00:11:45,720 --> 00:11:48,840
space spanning the entire<font color="#E5E5E5"> system and</font>

372
00:11:47,250 --> 00:11:54,030
<font color="#E5E5E5">again we're able to run both pure</font>

373
00:11:48,840 --> 00:11:55,590
capability code and also legacy code so

374
00:11:54,030 --> 00:11:56,790
I should tell<font color="#CCCCCC"> you briefly</font><font color="#E5E5E5"> about these</font>

375
00:11:55,590 --> 00:11:58,500
capabilities<font color="#E5E5E5"> since they're the</font>

376
00:11:56,790 --> 00:12:01,380
underpinning for<font color="#E5E5E5"> all of this so on our</font>

377
00:11:58,500 --> 00:12:03,450
prior papers we've described a 256 bit

378
00:12:01,380 --> 00:12:05,220
architectural capability which<font color="#CCCCCC"> is say</font>

379
00:12:03,450 --> 00:12:07,440
the<font color="#CCCCCC"> instruction</font><font color="#E5E5E5"> set exposes this as a</font>

380
00:12:05,220 --> 00:12:10,410
set of 64-bit values and permissions and

381
00:12:07,440 --> 00:12:12,360
so on capabilities are references<font color="#CCCCCC"> to</font>

382
00:12:10,410 --> 00:12:14,069
data there<font color="#CCCCCC"> are lot like pointers</font><font color="#E5E5E5"> only</font>

383
00:12:12,360 --> 00:12:16,080
not<font color="#CCCCCC"> only do they have a pointer in them</font>

384
00:12:14,070 --> 00:12:17,760
but<font color="#E5E5E5"> they also have a base and a link so</font>

385
00:12:16,080 --> 00:12:19,890
they were able<font color="#E5E5E5"> to describe bounded</font>

386
00:12:17,760 --> 00:12:21,450
regions of memory<font color="#CCCCCC"> and in</font><font color="#E5E5E5"> the prior work</font>

387
00:12:19,890 --> 00:12:23,220
we've described<font color="#E5E5E5"> this</font><font color="#CCCCCC"> as a monotonic</font>

388
00:12:21,450 --> 00:12:24,990
model which is to say<font color="#E5E5E5"> you were able to</font>

389
00:12:23,220 --> 00:12:26,310
take<font color="#E5E5E5"> your capability and reduce the</font>

390
00:12:24,990 --> 00:12:28,080
things it refers to but you're not<font color="#E5E5E5"> able</font>

391
00:12:26,310 --> 00:12:29,819
to expand them you can read<font color="#CCCCCC"> arrive</font>

392
00:12:28,080 --> 00:12:31,440
capabilities<font color="#E5E5E5"> from another</font><font color="#CCCCCC"> capability</font>

393
00:12:29,820 --> 00:12:33,870
with more<font color="#E5E5E5"> writes but you can't simply</font>

394
00:12:31,440 --> 00:12:35,540
take<font color="#CCCCCC"> a capability</font><font color="#E5E5E5"> and expand it and this</font>

395
00:12:33,870 --> 00:12:38,880
is<font color="#E5E5E5"> sufficient for</font><font color="#CCCCCC"> us to start building</font>

396
00:12:35,540 --> 00:12:40,199
strong compartmentalization on top<font color="#E5E5E5"> one</font>

397
00:12:38,880 --> 00:12:41,880
more<font color="#E5E5E5"> bit you</font><font color="#CCCCCC"> should know about</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> that</font>

398
00:12:40,200 --> 00:12:43,320
is<font color="#CCCCCC"> the tag bit this tells</font><font color="#E5E5E5"> us if the</font>

399
00:12:41,880 --> 00:12:44,490
<font color="#E5E5E5">integrity of the capability is being</font>

400
00:12:43,320 --> 00:12:46,140
maintained if you do<font color="#CCCCCC"> anything that</font>

401
00:12:44,490 --> 00:12:47,640
<font color="#CCCCCC">violates the integrity of the capability</font>

402
00:12:46,140 --> 00:12:49,110
<font color="#E5E5E5">we're going to clear the tag bit</font><font color="#CCCCCC"> which</font>

403
00:12:47,640 --> 00:12:53,699
means it can no longer<font color="#E5E5E5"> be</font><font color="#CCCCCC"> T referenced</font>

404
00:12:49,110 --> 00:12:54,810
or in the new model invoked so we're

405
00:12:53,700 --> 00:12:55,920
gonna add another bit which is<font color="#E5E5E5"> the</font>

406
00:12:54,810 --> 00:12:57,900
sealed bit it's<font color="#E5E5E5"> gonna take our</font>

407
00:12:55,920 --> 00:12:59,729
monotonicity properties and now give us

408
00:12:57,900 --> 00:13:01,770
the<font color="#CCCCCC"> ability to</font><font color="#E5E5E5"> say this entire contents</font>

409
00:12:59,730 --> 00:13:03,570
of<font color="#E5E5E5"> this capability</font><font color="#CCCCCC"> can</font><font color="#E5E5E5"> no longer be</font>

410
00:13:01,770 --> 00:13:05,280
modified<font color="#E5E5E5"> this is going to allow us to</font>

411
00:13:03,570 --> 00:13:06,600
<font color="#E5E5E5">implement encapsulation so you have a</font>

412
00:13:05,280 --> 00:13:08,550
<font color="#E5E5E5">reference to</font><font color="#CCCCCC"> an object</font><font color="#E5E5E5"> you're no longer</font>

413
00:13:06,600 --> 00:13:10,230
allowed to manipulate<font color="#E5E5E5"> the reference it</font>

414
00:13:08,550 --> 00:13:12,540
has been sealed so you can't dereference

415
00:13:10,230 --> 00:13:14,280
it we're also going to<font color="#E5E5E5"> add a new object</font>

416
00:13:12,540 --> 00:13:16,410
type this<font color="#E5E5E5"> is going to allow us</font><font color="#CCCCCC"> to take</font>

417
00:13:14,280 --> 00:13:18,510
code capabilities and data capabilities

418
00:13:16,410 --> 00:13:20,040
and atomically bundle them together so

419
00:13:18,510 --> 00:13:22,230
that<font color="#CCCCCC"> if we</font><font color="#E5E5E5"> have an invocation mechanism</font>

420
00:13:20,040 --> 00:13:23,819
invoking an object we can now specify

421
00:13:22,230 --> 00:13:26,220
the<font color="#CCCCCC"> two in</font>

422
00:13:23,820 --> 00:13:27,240
and then finally we're gonna<font color="#E5E5E5"> have a</font>

423
00:13:26,220 --> 00:13:29,399
hardware<font color="#E5E5E5"> optimized</font>

424
00:13:27,240 --> 00:13:31,140
cool and return instruction set<font color="#E5E5E5"> that are</font>

425
00:13:29,399 --> 00:13:32,790
going<font color="#E5E5E5"> to perform</font><font color="#CCCCCC"> some number of</font><font color="#E5E5E5"> checks</font>

426
00:13:31,140 --> 00:13:34,649
<font color="#CCCCCC">in hardware but at the end of the day</font>

427
00:13:32,790 --> 00:13:37,020
throw an exception<font color="#CCCCCC"> to</font><font color="#E5E5E5"> software to</font><font color="#CCCCCC"> allow</font>

428
00:13:34,649 --> 00:13:38,850
it<font color="#CCCCCC"> to provide</font><font color="#E5E5E5"> software to</font><font color="#CCCCCC"> my</font><font color="#E5E5E5"> defined</font>

429
00:13:37,020 --> 00:13:40,589
portions<font color="#E5E5E5"> of the domain transition</font>

430
00:13:38,850 --> 00:13:42,390
mechanism<font color="#CCCCCC"> and all of this as I said is</font>

431
00:13:40,589 --> 00:13:43,890
<font color="#CCCCCC">with respect to a virtual address</font><font color="#E5E5E5"> space</font>

432
00:13:42,390 --> 00:13:48,089
<font color="#E5E5E5">so</font><font color="#CCCCCC"> these are the</font><font color="#E5E5E5"> parameters</font><font color="#CCCCCC"> we need to</font>

433
00:13:43,890 --> 00:13:49,620
<font color="#CCCCCC">perform</font><font color="#E5E5E5"> compartmentalization we're going</font>

434
00:13:48,089 --> 00:13:51,930
to set<font color="#E5E5E5"> up the virtual address space</font>

435
00:13:49,620 --> 00:13:58,320
<font color="#CCCCCC">which</font><font color="#E5E5E5"> is the center or a vertical bar</font>

436
00:13:51,930 --> 00:13:59,279
they're working laser pointer<font color="#E5E5E5"> this</font>

437
00:13:58,320 --> 00:14:00,990
<font color="#E5E5E5">temporal bar is the virtual address</font>

438
00:13:59,279 --> 00:14:03,029
<font color="#E5E5E5">space on the left hand side and on the</font>

439
00:14:00,990 --> 00:14:04,170
right hand<font color="#CCCCCC"> side we</font><font color="#E5E5E5"> have two capability</font>

440
00:14:03,029 --> 00:14:06,060
<font color="#E5E5E5">of register files they're going to be</font>

441
00:14:04,170 --> 00:14:07,770
associated<font color="#CCCCCC"> with threads</font><font color="#E5E5E5"> each thread as</font>

442
00:14:06,060 --> 00:14:09,779
with<font color="#CCCCCC"> general-purpose registers will</font><font color="#E5E5E5"> have</font>

443
00:14:07,770 --> 00:14:11,490
its own capability registers and they

444
00:14:09,779 --> 00:14:13,380
define the effective protection domain

445
00:14:11,490 --> 00:14:15,510
that's implemented<font color="#E5E5E5"> we're gonna use this</font>

446
00:14:13,380 --> 00:14:16,980
to implement an object capability<font color="#CCCCCC"> model</font>

447
00:14:15,510 --> 00:14:18,750
<font color="#E5E5E5">which is to say we're</font><font color="#CCCCCC"> going</font><font color="#E5E5E5"> to have</font>

448
00:14:16,980 --> 00:14:20,730
objects in an object-oriented sense

449
00:14:18,750 --> 00:14:22,410
<font color="#E5E5E5">referred to by capabilities we can then</font>

450
00:14:20,730 --> 00:14:23,520
delegate them around and<font color="#E5E5E5"> invoke them and</font>

451
00:14:22,410 --> 00:14:25,290
so on<font color="#CCCCCC"> and when</font><font color="#E5E5E5"> we use the word</font>

452
00:14:23,520 --> 00:14:28,410
<font color="#E5E5E5">encapsulation</font><font color="#CCCCCC"> that is the</font><font color="#E5E5E5"> kind of</font>

453
00:14:25,290 --> 00:14:30,779
encapsulation<font color="#CCCCCC"> that we mean when we start</font>

454
00:14:28,410 --> 00:14:32,130
up<font color="#E5E5E5"> a process our lib carry library and</font>

455
00:14:30,779 --> 00:14:34,170
user space is<font color="#E5E5E5"> going to be able to load</font>

456
00:14:32,130 --> 00:14:35,579
and<font color="#CCCCCC"> link additional classes and it's</font>

457
00:14:34,170 --> 00:14:37,199
going<font color="#E5E5E5"> to be able to instantiate objects</font>

458
00:14:35,579 --> 00:14:39,209
but unlike conventional language runtime

459
00:14:37,200 --> 00:14:41,010
objects<font color="#CCCCCC"> in</font><font color="#E5E5E5"> C++</font><font color="#CCCCCC"> these are going to</font><font color="#E5E5E5"> be</font>

460
00:14:39,209 --> 00:14:43,380
compartmentalized<font color="#CCCCCC"> using the capability</font>

461
00:14:41,010 --> 00:14:44,640
model<font color="#E5E5E5"> so I've</font><font color="#CCCCCC"> mentioned every thread is</font>

462
00:14:43,380 --> 00:14:46,110
<font color="#CCCCCC">going to have a capability register</font><font color="#E5E5E5"> file</font>

463
00:14:44,640 --> 00:14:49,050
this is going to<font color="#E5E5E5"> describe its current</font>

464
00:14:46,110 --> 00:14:50,430
protection demand when we perform domain

465
00:14:49,050 --> 00:14:51,750
transition<font color="#E5E5E5"> we're gonna do it within</font>

466
00:14:50,430 --> 00:14:53,430
threads so we're<font color="#E5E5E5"> not gonna have to enter</font>

467
00:14:51,750 --> 00:14:54,839
the scheduler or<font color="#E5E5E5"> do a number of other</font>

468
00:14:53,430 --> 00:14:56,459
complicated kernel functions we're just

469
00:14:54,839 --> 00:14:57,750
going to transform<font color="#E5E5E5"> the register file</font><font color="#CCCCCC"> and</font>

470
00:14:56,459 --> 00:14:59,880
what we're<font color="#E5E5E5"> going</font><font color="#CCCCCC"> to do is we're going to</font>

471
00:14:57,750 --> 00:15:02,190
unwrap these sealed capabilities using

472
00:14:59,880 --> 00:15:03,990
<font color="#CCCCCC">the kernels privileges allowing us to</font>

473
00:15:02,190 --> 00:15:08,100
<font color="#E5E5E5">transition between mutually distrusting</font>

474
00:15:03,990 --> 00:15:09,600
<font color="#E5E5E5">domains in user space</font><font color="#CCCCCC"> as</font><font color="#E5E5E5"> I said we're</font>

475
00:15:08,100 --> 00:15:10,620
<font color="#E5E5E5">going to use an exception facility which</font>

476
00:15:09,600 --> 00:15:12,240
is<font color="#E5E5E5"> today it's gonna be</font><font color="#CCCCCC"> partially</font>

477
00:15:10,620 --> 00:15:13,920
<font color="#E5E5E5">software-defined but the most expensive</font>

478
00:15:12,240 --> 00:15:15,300
bits of this structure<font color="#E5E5E5"> are going to be</font>

479
00:15:13,920 --> 00:15:16,920
things<font color="#CCCCCC"> that we can do in hardware such</font>

480
00:15:15,300 --> 00:15:18,750
as<font color="#E5E5E5"> checking permissions on capabilities</font>

481
00:15:16,920 --> 00:15:21,149
unsealing and so on<font color="#E5E5E5"> we're gonna try to</font>

482
00:15:18,750 --> 00:15:23,010
leave to software<font color="#CCCCCC"> as only</font><font color="#E5E5E5"> memory access</font>

483
00:15:21,149 --> 00:15:25,290
we use a risk model<font color="#CCCCCC"> and we don't want</font><font color="#E5E5E5"> to</font>

484
00:15:23,010 --> 00:15:28,649
combine<font color="#CCCCCC"> various kinds</font><font color="#E5E5E5"> of operations with</font>

485
00:15:25,290 --> 00:15:30,000
memory access in our cherry<font color="#CCCCCC"> bsd model we</font>

486
00:15:28,649 --> 00:15:31,770
implement something<font color="#E5E5E5"> called a trusted</font>

487
00:15:30,000 --> 00:15:33,320
stack<font color="#E5E5E5"> which is a</font><font color="#CCCCCC"> call stack</font><font color="#E5E5E5"> of all the</font>

488
00:15:31,770 --> 00:15:36,390
invitations<font color="#CCCCCC"> we've gone through so far</font>

489
00:15:33,320 --> 00:15:37,260
<font color="#E5E5E5">and then we could actually implement</font>

490
00:15:36,390 --> 00:15:39,360
many other

491
00:15:37,260 --> 00:15:40,920
different kinds<font color="#CCCCCC"> of security models so we</font>

492
00:15:39,360 --> 00:15:42,720
<font color="#E5E5E5">provide a synchronous call return</font>

493
00:15:40,920 --> 00:15:44,490
mechanism<font color="#CCCCCC"> but if you wanted to you could</font>

494
00:15:42,720 --> 00:15:48,030
<font color="#E5E5E5">do an</font><font color="#CCCCCC"> asynchronous model perhaps</font><font color="#E5E5E5"> based</font>

495
00:15:44,490 --> 00:15:50,070
<font color="#E5E5E5">on closures so let me show you an</font>

496
00:15:48,030 --> 00:15:52,110
<font color="#CCCCCC">example</font><font color="#E5E5E5"> of this so normally when we</font>

497
00:15:50,070 --> 00:15:54,180
<font color="#CCCCCC">answer</font><font color="#E5E5E5"> the process when it first starts</font>

498
00:15:52,110 --> 00:15:55,860
up we're<font color="#E5E5E5"> going</font><font color="#CCCCCC"> to rant the code ambient</font>

499
00:15:54,180 --> 00:15:56,819
<font color="#CCCCCC">Authority for its address space which is</font>

500
00:15:55,860 --> 00:15:58,380
to say it's<font color="#E5E5E5"> going</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> be able to run</font>

501
00:15:56,820 --> 00:16:00,750
using regular in this case MIPS

502
00:15:58,380 --> 00:16:03,300
instructions<font color="#E5E5E5"> and then begin to</font><font color="#CCCCCC"> setup</font>

503
00:16:00,750 --> 00:16:05,100
<font color="#CCCCCC">security</font><font color="#E5E5E5"> demands</font><font color="#CCCCCC"> we're going to be able</font>

504
00:16:03,300 --> 00:16:06,660
<font color="#E5E5E5">to make synchronous function like calls</font>

505
00:16:05,100 --> 00:16:08,610
<font color="#E5E5E5">into various objects that we've</font>

506
00:16:06,660 --> 00:16:09,930
instantiated using<font color="#E5E5E5"> Lib cherry and</font><font color="#CCCCCC"> when</font>

507
00:16:08,610 --> 00:16:12,090
we do that<font color="#E5E5E5"> we perform a</font><font color="#CCCCCC"> C call</font>

508
00:16:09,930 --> 00:16:14,370
instruction<font color="#E5E5E5"> takes us into the object</font>

509
00:16:12,090 --> 00:16:15,960
which runs without any privilege or only

510
00:16:14,370 --> 00:16:17,790
the privileges we delegate<font color="#E5E5E5"> to it and</font>

511
00:16:15,960 --> 00:16:19,200
then if it needs<font color="#E5E5E5"> to it could call in to</font>

512
00:16:17,790 --> 00:16:21,810
<font color="#E5E5E5">other objects</font><font color="#CCCCCC"> so this is a recursive</font>

513
00:16:19,200 --> 00:16:23,310
model<font color="#E5E5E5"> and we can also call back into an</font>

514
00:16:21,810 --> 00:16:25,260
ambient object which can then perform

515
00:16:23,310 --> 00:16:27,479
system<font color="#E5E5E5"> calls so we allow access to</font>

516
00:16:25,260 --> 00:16:29,850
kernel facilities<font color="#E5E5E5"> only from outside of</font>

517
00:16:27,480 --> 00:16:31,080
compartmentalised<font color="#E5E5E5"> code so one of the</font>

518
00:16:29,850 --> 00:16:33,300
things that has to<font color="#CCCCCC"> happen</font><font color="#E5E5E5"> under the hood</font>

519
00:16:31,080 --> 00:16:36,450
is that the<font color="#E5E5E5"> compiler has to clear unused</font>

520
00:16:33,300 --> 00:16:37,560
registers<font color="#E5E5E5"> in the</font><font color="#CCCCCC"> function signatures</font><font color="#E5E5E5"> so</font>

521
00:16:36,450 --> 00:16:38,940
<font color="#E5E5E5">that we don't accidentally leak</font>

522
00:16:37,560 --> 00:16:40,589
information between the caller<font color="#CCCCCC"> and the</font>

523
00:16:38,940 --> 00:16:41,880
<font color="#CCCCCC">callee we can't rely on the underlying</font>

524
00:16:40,590 --> 00:16:43,170
<font color="#CCCCCC">hardware to do this because</font><font color="#E5E5E5"> it doesn't</font>

525
00:16:41,880 --> 00:16:44,430
know what the function signatures are

526
00:16:43,170 --> 00:16:46,290
<font color="#E5E5E5">all right we have to clear unused</font>

527
00:16:44,430 --> 00:16:49,949
argument registers and unused<font color="#E5E5E5"> return</font>

528
00:16:46,290 --> 00:16:52,170
registers all of this can occur at

529
00:16:49,950 --> 00:16:53,160
effectively a constant<font color="#E5E5E5"> overhead to</font>

530
00:16:52,170 --> 00:16:54,510
functional<font color="#CCCCCC"> call off so we're going</font><font color="#E5E5E5"> to</font>

531
00:16:53,160 --> 00:16:56,040
take an<font color="#CCCCCC"> additional exception we're gonna</font>

532
00:16:54,510 --> 00:16:59,160
run a<font color="#CCCCCC"> few more instructions</font><font color="#E5E5E5"> but they're</font>

533
00:16:56,040 --> 00:17:01,110
relatively lightweight<font color="#E5E5E5"> so we have built</font>

534
00:16:59,160 --> 00:17:02,760
a hardware software prototype of<font color="#E5E5E5"> this so</font>

535
00:17:01,110 --> 00:17:05,130
we<font color="#E5E5E5"> implemented using the blue speck</font>

536
00:17:02,760 --> 00:17:06,959
<font color="#E5E5E5">hardware description language a 64-bit</font>

537
00:17:05,130 --> 00:17:09,390
pipeline processor<font color="#E5E5E5"> and we're using the</font>

538
00:17:06,959 --> 00:17:10,740
64-bit<font color="#E5E5E5"> MIPS is</font><font color="#CCCCCC"> a we also have our</font><font color="#E5E5E5"> cherry</font>

539
00:17:09,390 --> 00:17:13,079
extensions to it

540
00:17:10,740 --> 00:17:14,880
it is<font color="#CCCCCC"> immature</font><font color="#E5E5E5"> but small process which</font>

541
00:17:13,079 --> 00:17:16,740
to say it is<font color="#E5E5E5"> not</font><font color="#CCCCCC"> superscalar</font><font color="#E5E5E5"> but it does</font>

542
00:17:14,880 --> 00:17:18,600
have a memory<font color="#CCCCCC"> management unit in l1 and</font>

543
00:17:16,740 --> 00:17:19,800
l2 caches<font color="#CCCCCC"> it is comparable to</font><font color="#E5E5E5"> the</font>

544
00:17:18,599 --> 00:17:21,839
processes you will<font color="#E5E5E5"> find in small</font>

545
00:17:19,800 --> 00:17:23,369
<font color="#E5E5E5">embedded devices and we synthesized this</font>

546
00:17:21,839 --> 00:17:26,520
at<font color="#E5E5E5"> about a hundred megahertz</font><font color="#CCCCCC"> on an</font>

547
00:17:23,369 --> 00:17:28,379
off-the-shelf<font color="#E5E5E5"> Altair FPGA we've</font><font color="#CCCCCC"> also</font>

548
00:17:26,520 --> 00:17:30,570
have a complete<font color="#CCCCCC"> software stack on top of</font>

549
00:17:28,380 --> 00:17:32,160
this<font color="#E5E5E5"> we've modified the</font><font color="#CCCCCC"> freebsd</font>

550
00:17:30,570 --> 00:17:33,960
operating system to support<font color="#CCCCCC"> fine-grained</font>

551
00:17:32,160 --> 00:17:35,310
memory protection inside processes the

552
00:17:33,960 --> 00:17:36,090
domains which we<font color="#E5E5E5"> model debugging</font>

553
00:17:35,310 --> 00:17:38,550
features and so on

554
00:17:36,090 --> 00:17:40,800
<font color="#E5E5E5">we've also modified our compiler clang</font>

555
00:17:38,550 --> 00:17:42,480
<font color="#E5E5E5">in</font><font color="#CCCCCC"> LLVM to generate chary instructions</font>

556
00:17:40,800 --> 00:17:44,490
for memory access<font color="#E5E5E5"> using a variety of</font>

557
00:17:42,480 --> 00:17:46,350
<font color="#CCCCCC">abis and then we've adapted a number of</font>

558
00:17:44,490 --> 00:17:48,270
<font color="#E5E5E5">applications to</font><font color="#CCCCCC"> use these</font><font color="#E5E5E5"> features which</font>

559
00:17:46,350 --> 00:17:49,949
we use<font color="#CCCCCC"> for the purposes of evaluation</font>

560
00:17:48,270 --> 00:17:51,090
<font color="#CCCCCC">and</font><font color="#E5E5E5"> we've also released what all this is</font>

561
00:17:49,950 --> 00:17:52,440
open source<font color="#CCCCCC"> on our</font><font color="#E5E5E5"> website</font>

562
00:17:51,090 --> 00:17:54,330
<font color="#E5E5E5">so if you wish to</font><font color="#CCCCCC"> look at the reference</font>

563
00:17:52,440 --> 00:17:57,330
design<font color="#CCCCCC"> in hardware and</font><font color="#E5E5E5"> software</font><font color="#CCCCCC"> you're</font>

564
00:17:54,330 --> 00:17:58,320
welcome<font color="#E5E5E5"> to do that</font><font color="#CCCCCC"> I only have a couple</font>

565
00:17:57,330 --> 00:17:59,999
<font color="#CCCCCC">of minutes remaining so I'll just tell</font>

566
00:17:58,320 --> 00:18:02,460
you very<font color="#E5E5E5"> briefly about the performance</font>

567
00:17:59,999 --> 00:18:05,100
characteristics<font color="#CCCCCC"> so our goal was</font><font color="#E5E5E5"> to try</font>

568
00:18:02,460 --> 00:18:07,409
and<font color="#E5E5E5"> provide extremely low cost domain</font>

569
00:18:05,100 --> 00:18:09,990
switches<font color="#E5E5E5"> and also provide Excalibur leti</font>

570
00:18:07,409 --> 00:18:11,299
on the number of<font color="#E5E5E5"> sand boxes or objects</font>

571
00:18:09,990 --> 00:18:13,529
<font color="#CCCCCC">that were able to</font><font color="#E5E5E5"> instantiate at once</font>

572
00:18:11,299 --> 00:18:17,820
<font color="#CCCCCC">this</font><font color="#E5E5E5"> may be the bit where I do have</font><font color="#CCCCCC"> to</font>

573
00:18:13,529 --> 00:18:19,499
use the<font color="#CCCCCC"> laser</font><font color="#E5E5E5"> pointer well if you look</font>

574
00:18:17,820 --> 00:18:20,970
at the bottom<font color="#CCCCCC"> two rows</font><font color="#E5E5E5"> here</font><font color="#CCCCCC"> what we've</font>

575
00:18:19,499 --> 00:18:23,070
done it for<font color="#CCCCCC"> the purposes</font><font color="#E5E5E5"> of</font><font color="#CCCCCC"> this graph</font>

576
00:18:20,970 --> 00:18:24,749
<font color="#E5E5E5">is normalized things with respect to</font>

577
00:18:23,070 --> 00:18:26,820
<font color="#E5E5E5">normal function to ordinary function</font>

578
00:18:24,749 --> 00:18:29,340
call cost<font color="#E5E5E5"> which is</font><font color="#CCCCCC"> a small</font><font color="#E5E5E5"> number of</font>

579
00:18:26,820 --> 00:18:31,259
cycles in the sort of<font color="#E5E5E5"> six two dozen</font>

580
00:18:29,340 --> 00:18:33,149
range depending<font color="#E5E5E5"> on static relations and</font>

581
00:18:31,259 --> 00:18:35,399
so<font color="#E5E5E5"> on the bottom green line here</font><font color="#CCCCCC"> is</font>

582
00:18:33,149 --> 00:18:38,189
<font color="#E5E5E5">cherry object capability invocation</font>

583
00:18:35,399 --> 00:18:39,809
<font color="#CCCCCC">which is to say we are</font><font color="#E5E5E5"> at all times</font>

584
00:18:38,190 --> 00:18:41,519
within<font color="#E5E5E5"> an order of magnitude</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> the cost</font>

585
00:18:39,809 --> 00:18:43,649
of function call<font color="#E5E5E5"> and often closer than</font>

586
00:18:41,519 --> 00:18:45,690
<font color="#E5E5E5">that as you move up the cost in the</font>

587
00:18:43,649 --> 00:18:48,178
graph<font color="#E5E5E5"> so these are</font><font color="#CCCCCC"> cycles on the y-axis</font>

588
00:18:45,690 --> 00:18:50,759
linearly<font color="#CCCCCC"> you hit a series</font><font color="#E5E5E5"> of function</font>

589
00:18:48,179 --> 00:18:52,710
<font color="#E5E5E5">calls which are done using the UNIX IPC</font>

590
00:18:50,759 --> 00:18:54,299
mechanisms but using shared memory

591
00:18:52,710 --> 00:18:56,220
explicitly<font color="#E5E5E5"> using</font><font color="#CCCCCC"> the paging mechanism</font>

592
00:18:54,299 --> 00:18:58,830
and then<font color="#E5E5E5"> we move</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> the top</font><font color="#CCCCCC"> of the graph</font>

593
00:18:56,220 --> 00:19:00,929
<font color="#E5E5E5">we have using traditional unix IPC</font>

594
00:18:58,830 --> 00:19:03,330
<font color="#E5E5E5">without using shared memory facilities</font>

595
00:19:00,929 --> 00:19:04,830
<font color="#CCCCCC">they what x-axis on this graph is</font><font color="#E5E5E5"> the</font>

596
00:19:03,330 --> 00:19:06,539
<font color="#E5E5E5">payload which is to say the amount of</font>

597
00:19:04,830 --> 00:19:06,899
data<font color="#E5E5E5"> being</font><font color="#CCCCCC"> shared by the caller and the</font>

598
00:19:06,539 --> 00:19:08,490
callee

599
00:19:06,899 --> 00:19:10,168
of course the left side is interesting

600
00:19:08,490 --> 00:19:11,850
because<font color="#E5E5E5"> this has</font><font color="#CCCCCC"> to do with the absolute</font>

601
00:19:10,169 --> 00:19:13,440
minimum cost we can<font color="#E5E5E5"> get away with this</font>

602
00:19:11,850 --> 00:19:15,629
is the<font color="#E5E5E5"> no op call where</font><font color="#CCCCCC"> we are paying</font>

603
00:19:13,440 --> 00:19:17,100
only invocation overhead and the

604
00:19:15,629 --> 00:19:18,959
<font color="#CCCCCC">right-hand</font><font color="#E5E5E5"> side as we shift out is as</font>

605
00:19:17,100 --> 00:19:20,129
buffer<font color="#CCCCCC"> sizes increased and of course the</font>

606
00:19:18,960 --> 00:19:22,409
<font color="#E5E5E5">interesting observation is that</font><font color="#CCCCCC"> we</font>

607
00:19:20,129 --> 00:19:24,178
effectively<font color="#E5E5E5"> have a linear cost over a</font>

608
00:19:22,409 --> 00:19:25,950
normal<font color="#E5E5E5"> function call on the right hand</font>

609
00:19:24,179 --> 00:19:28,559
<font color="#E5E5E5">side as TLB space runs around you see</font>

610
00:19:25,950 --> 00:19:30,330
the<font color="#CCCCCC"> variance</font><font color="#E5E5E5"> kick up but roughly the</font>

611
00:19:28,559 --> 00:19:31,860
<font color="#E5E5E5">same scale everything</font><font color="#CCCCCC"> else is at least</font>

612
00:19:30,330 --> 00:19:33,629
an order<font color="#CCCCCC"> of magnitude up but in some</font>

613
00:19:31,860 --> 00:19:36,959
cases it simply<font color="#E5E5E5"> disappears from the</font>

614
00:19:33,629 --> 00:19:41,850
graph so we accomplished<font color="#E5E5E5"> our goal</font><font color="#CCCCCC"> in</font>

615
00:19:36,960 --> 00:19:43,499
terms of rapid domain switching<font color="#E5E5E5"> once you</font>

616
00:19:41,850 --> 00:19:45,059
to mention<font color="#CCCCCC"> very briefly</font><font color="#E5E5E5"> a couple</font><font color="#CCCCCC"> of</font>

617
00:19:43,499 --> 00:19:46,679
implications<font color="#CCCCCC"> for</font><font color="#E5E5E5"> application structure</font>

618
00:19:45,059 --> 00:19:49,379
<font color="#E5E5E5">once you have the ability to perform</font>

619
00:19:46,679 --> 00:19:50,820
<font color="#CCCCCC">extremely fast domain switching so we've</font>

620
00:19:49,379 --> 00:19:52,320
restored<font color="#E5E5E5"> the single address based</font>

621
00:19:50,820 --> 00:19:54,029
programming model which<font color="#E5E5E5"> mean program is</font>

622
00:19:52,320 --> 00:19:56,129
now work with pointers<font color="#E5E5E5"> and so on</font><font color="#CCCCCC"> in</font>

623
00:19:54,029 --> 00:19:57,840
<font color="#E5E5E5">there C language programs this means</font>

624
00:19:56,129 --> 00:19:59,789
they can<font color="#CCCCCC"> easily debug them reason</font><font color="#E5E5E5"> about</font>

625
00:19:57,840 --> 00:20:01,590
their<font color="#E5E5E5"> behaviour</font><font color="#CCCCCC"> and so on we also use a</font>

626
00:19:59,789 --> 00:20:03,360
referential<font color="#E5E5E5"> integrity model which it</font>

627
00:20:01,590 --> 00:20:05,010
matches the programmer model for how you

628
00:20:03,360 --> 00:20:07,229
use<font color="#CCCCCC"> these oddities</font>

629
00:20:05,010 --> 00:20:09,030
and<font color="#E5E5E5"> is a relatively modest programmer</font>

630
00:20:07,230 --> 00:20:10,320
cost<font color="#E5E5E5"> in order to insert these protection</font>

631
00:20:09,030 --> 00:20:13,590
domain boundaries we're<font color="#CCCCCC"> able to label</font>

632
00:20:10,320 --> 00:20:15,419
functions as this is a<font color="#CCCCCC"> cool</font><font color="#E5E5E5"> gate</font><font color="#CCCCCC"> this</font>

633
00:20:13,590 --> 00:20:17,220
structure supports mutual distrust<font color="#E5E5E5"> and</font>

634
00:20:15,420 --> 00:20:18,600
it has an extremely<font color="#E5E5E5"> low constant</font>

635
00:20:17,220 --> 00:20:20,310
overhead<font color="#E5E5E5"> so we're</font><font color="#CCCCCC"> able to perform</font>

636
00:20:18,600 --> 00:20:22,620
interactions that would for<font color="#CCCCCC"> support for</font>

637
00:20:20,310 --> 00:20:24,330
example<font color="#E5E5E5"> extremely granular microkernel</font>

638
00:20:22,620 --> 00:20:25,649
decomposition<font color="#E5E5E5"> of conventional operating</font>

639
00:20:24,330 --> 00:20:28,139
system kernels if we chose<font color="#CCCCCC"> to pursue</font>

640
00:20:25,650 --> 00:20:30,300
<font color="#E5E5E5">that there of course some downsides or</font>

641
00:20:28,140 --> 00:20:31,770
at least some challenges<font color="#CCCCCC"> if one of them</font>

642
00:20:30,300 --> 00:20:33,389
is that it is<font color="#E5E5E5"> still hard to</font>

643
00:20:31,770 --> 00:20:34,860
<font color="#E5E5E5">compartmentalize applications it</font><font color="#CCCCCC"> is much</font>

644
00:20:33,390 --> 00:20:36,390
easier<font color="#CCCCCC"> to program them they perform well</font>

645
00:20:34,860 --> 00:20:37,979
<font color="#E5E5E5">but somebody has to reason</font><font color="#CCCCCC"> about the</font>

646
00:20:36,390 --> 00:20:39,720
security<font color="#E5E5E5"> implications</font><font color="#CCCCCC"> of shared</font><font color="#E5E5E5"> memory</font>

647
00:20:37,980 --> 00:20:41,670
and interacting components<font color="#E5E5E5"> we can't take</font>

648
00:20:39,720 --> 00:20:43,620
<font color="#E5E5E5">that work away just by improving the</font>

649
00:20:41,670 --> 00:20:45,480
hardware but we can make<font color="#E5E5E5"> it possible to</font>

650
00:20:43,620 --> 00:20:48,570
scale up<font color="#E5E5E5"> the use of compartmentalization</font>

651
00:20:45,480 --> 00:20:50,040
dramatically<font color="#CCCCCC"> it is also the case</font><font color="#E5E5E5"> that</font>

652
00:20:48,570 --> 00:20:51,389
<font color="#CCCCCC">you now potentially</font><font color="#E5E5E5"> have more shared</font>

653
00:20:50,040 --> 00:20:53,760
memory so<font color="#CCCCCC"> high-performance</font>

654
00:20:51,390 --> 00:20:55,770
compartmentalised applications do use

655
00:20:53,760 --> 00:20:57,240
memory sharing<font color="#E5E5E5"> but lower performance</font>

656
00:20:55,770 --> 00:20:59,010
ones tend not to and reasoning<font color="#CCCCCC"> about</font>

657
00:20:57,240 --> 00:21:00,960
shared memory<font color="#E5E5E5"> versus</font><font color="#CCCCCC"> master passing is</font>

658
00:20:59,010 --> 00:21:03,480
quite a different experience<font color="#CCCCCC"> couple of</font>

659
00:21:00,960 --> 00:21:05,550
other comments<font color="#CCCCCC"> the capability overhead</font>

660
00:21:03,480 --> 00:21:06,810
is measurable<font color="#CCCCCC"> we do actually grow the</font>

661
00:21:05,550 --> 00:21:09,030
<font color="#E5E5E5">size of the pointer this is something</font>

662
00:21:06,810 --> 00:21:10,320
that<font color="#E5E5E5"> has</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> be managed and mitigated and</font>

663
00:21:09,030 --> 00:21:13,080
there are subtleties and how you

664
00:21:10,320 --> 00:21:14,669
structure code and of course<font color="#E5E5E5"> by</font>

665
00:21:13,080 --> 00:21:16,409
introducing<font color="#E5E5E5"> more sharing we actually</font>

666
00:21:14,670 --> 00:21:17,970
emphasize<font color="#E5E5E5"> some other security problems</font>

667
00:21:16,410 --> 00:21:19,320
such<font color="#CCCCCC"> as the possibility of</font><font color="#E5E5E5"> side channel</font>

668
00:21:17,970 --> 00:21:22,640
<font color="#E5E5E5">attacks which have to</font><font color="#CCCCCC"> be</font><font color="#E5E5E5"> considered</font>

669
00:21:19,320 --> 00:21:24,840
separately from this<font color="#E5E5E5"> is a level approach</font>

670
00:21:22,640 --> 00:21:26,460
so let me<font color="#E5E5E5"> just conclude by saying that</font>

671
00:21:24,840 --> 00:21:28,320
<font color="#E5E5E5">we've implemented we describe as a</font>

672
00:21:26,460 --> 00:21:30,240
hybrid object capability system which is

673
00:21:28,320 --> 00:21:31,740
to<font color="#CCCCCC"> say</font><font color="#E5E5E5"> we're able to run this within the</font>

674
00:21:30,240 --> 00:21:33,270
context<font color="#E5E5E5"> of existing operating system</font>

675
00:21:31,740 --> 00:21:35,370
designs with only modest changes<font color="#E5E5E5"> to</font>

676
00:21:33,270 --> 00:21:37,110
hardware<font color="#E5E5E5"> that it integrates very nicely</font>

677
00:21:35,370 --> 00:21:38,340
with the existing models that<font color="#CCCCCC"> we were</font>

678
00:21:37,110 --> 00:21:40,229
able to do<font color="#E5E5E5"> it any way</font><font color="#CCCCCC"> that is friendly</font>

679
00:21:38,340 --> 00:21:42,149
<font color="#E5E5E5">to</font><font color="#CCCCCC"> C language programs</font><font color="#E5E5E5"> and shift away</font>

680
00:21:40,230 --> 00:21:44,070
from quite hard<font color="#E5E5E5"> to use inter process</font>

681
00:21:42,150 --> 00:21:45,480
communication<font color="#E5E5E5"> and we are able</font><font color="#CCCCCC"> to realize</font>

682
00:21:44,070 --> 00:21:46,679
literally orders of magnitude

683
00:21:45,480 --> 00:21:48,720
performance improvements for

684
00:21:46,680 --> 00:21:50,370
<font color="#E5E5E5">compartmentalised designs and I'll just</font>

685
00:21:48,720 --> 00:21:51,600
conclude<font color="#CCCCCC"> by saying we do have an open</font>

686
00:21:50,370 --> 00:21:53,580
<font color="#E5E5E5">source reference implementation and a</font>

687
00:21:51,600 --> 00:21:56,990
complete<font color="#E5E5E5"> description of RSA up on our</font>

688
00:21:53,580 --> 00:21:56,990
<font color="#E5E5E5">website thank you very much</font>

