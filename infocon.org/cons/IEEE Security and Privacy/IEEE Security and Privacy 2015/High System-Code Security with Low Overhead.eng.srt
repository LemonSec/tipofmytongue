1
00:00:00,130 --> 00:00:06,460
<font color="#E5E5E5">I'm here</font><font color="#CCCCCC"> to talk</font><font color="#E5E5E5"> about hi system called</font>

2
00:00:03,489 --> 00:00:08,950
security and low overhead and this is

3
00:00:06,460 --> 00:00:11,440
joint work with my colleague<font color="#E5E5E5"> Vladimir</font>

4
00:00:08,950 --> 00:00:14,018
<font color="#E5E5E5">Kuznetsov and our</font><font color="#CCCCCC"> adviser George gondia</font>

5
00:00:11,440 --> 00:00:16,050
dbf file as<font color="#E5E5E5"> well as Johannes kinder from</font>

6
00:00:14,019 --> 00:00:19,839
your royal holloway university of london

7
00:00:16,050 --> 00:00:21,939
and we are interested in<font color="#E5E5E5"> hi system</font>

8
00:00:19,839 --> 00:00:25,448
called security<font color="#E5E5E5"> because we use a lot of</font>

9
00:00:21,939 --> 00:00:27,669
systems code and it's<font color="#CCCCCC"> dangerous and for</font>

10
00:00:25,449 --> 00:00:30,720
<font color="#CCCCCC">example a single memory access that goes</font>

11
00:00:27,669 --> 00:00:34,180
wrong can have dramatic consequences

12
00:00:30,720 --> 00:00:37,150
like in<font color="#E5E5E5"> the case of open itself about a</font>

13
00:00:34,180 --> 00:00:40,420
year ago and this was a single memory

14
00:00:37,150 --> 00:00:42,400
access but there are<font color="#CCCCCC"> really literally</font>

15
00:00:40,420 --> 00:00:46,150
tens of thousands of memory accesses in

16
00:00:42,400 --> 00:00:49,480
openssl and you know we've heard about

17
00:00:46,150 --> 00:00:50,830
<font color="#E5E5E5">this buffer overflow way too much you</font>

18
00:00:49,480 --> 00:00:53,140
would like to<font color="#E5E5E5"> move</font><font color="#CCCCCC"> to a more interesting</font>

19
00:00:50,830 --> 00:00:56,320
research like the<font color="#CCCCCC"> SSL research from</font>

20
00:00:53,140 --> 00:00:59,200
yesterday so is there<font color="#CCCCCC"> a way to once and</font>

21
00:00:56,320 --> 00:01:01,480
<font color="#E5E5E5">for all get rid</font><font color="#CCCCCC"> of all these</font><font color="#E5E5E5"> problems</font>

22
00:00:59,200 --> 00:01:06,460
with memory accesses and other<font color="#E5E5E5"> low-level</font>

23
00:01:01,480 --> 00:01:08,880
<font color="#E5E5E5">issues and we are advocating a way to</font>

24
00:01:06,460 --> 00:01:13,240
solve these problems using sanity checks

25
00:01:08,880 --> 00:01:16,359
these are runtime checks and<font color="#CCCCCC"> I'll give</font>

26
00:01:13,240 --> 00:01:18,969
you an example<font color="#E5E5E5"> if you have here a point</font>

27
00:01:16,359 --> 00:01:21,999
of<font color="#CCCCCC"> your reference and you could protect</font>

28
00:01:18,969 --> 00:01:24,399
this dereference by adding a check<font color="#E5E5E5"> just</font>

29
00:01:21,999 --> 00:01:26,530
<font color="#E5E5E5">before the dereference to verify that</font>

30
00:01:24,399 --> 00:01:28,689
the address<font color="#CCCCCC"> is valid and if it happens</font>

31
00:01:26,530 --> 00:01:32,109
<font color="#CCCCCC">to be out of</font><font color="#E5E5E5"> bounds</font><font color="#CCCCCC"> it would report the</font>

32
00:01:28,689 --> 00:01:34,059
error and about the program so note that

33
00:01:32,109 --> 00:01:35,919
<font color="#E5E5E5">aborting the program is in this case the</font>

34
00:01:34,060 --> 00:01:38,289
only safe thing that you can do<font color="#E5E5E5"> because</font>

35
00:01:35,920 --> 00:01:42,130
if you were to continue arbitrary bad

36
00:01:38,289 --> 00:01:44,170
things can happen now we like sanity

37
00:01:42,130 --> 00:01:46,899
checks because they can<font color="#CCCCCC"> be added</font>

38
00:01:44,170 --> 00:01:48,340
automatically at compilation time so

39
00:01:46,899 --> 00:01:49,959
there are<font color="#CCCCCC"> a number of good tools like</font>

40
00:01:48,340 --> 00:01:52,139
address sanitizer that will generate

41
00:01:49,959 --> 00:01:54,880
checks like you see on the<font color="#E5E5E5"> screen and</font>

42
00:01:52,139 --> 00:02:00,158
they also don't need the source code<font color="#E5E5E5"> to</font>

43
00:01:54,880 --> 00:02:03,158
be modified<font color="#E5E5E5"> in any way there's just one</font>

44
00:02:00,159 --> 00:02:04,959
<font color="#CCCCCC">issue with sanity checks which is</font><font color="#E5E5E5"> that</font>

45
00:02:03,159 --> 00:02:07,270
our system code is very performance

46
00:02:04,959 --> 00:02:09,880
sensitive so people<font color="#CCCCCC"> usually are not</font>

47
00:02:07,270 --> 00:02:12,019
<font color="#E5E5E5">willing</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> pay a high overhead for these</font>

48
00:02:09,880 --> 00:02:15,019
checks

49
00:02:12,020 --> 00:02:17,420
and the table<font color="#E5E5E5"> here shows a number of</font>

50
00:02:15,020 --> 00:02:20,180
popular tools to generate sanity checks

51
00:02:17,420 --> 00:02:22,339
together with their overhead and you can

52
00:02:20,180 --> 00:02:26,180
see that<font color="#E5E5E5"> they</font><font color="#CCCCCC"> all add seventy percent or</font>

53
00:02:22,340 --> 00:02:28,850
more to the runtime of<font color="#E5E5E5"> your software so</font>

54
00:02:26,180 --> 00:02:31,760
sanity checks are a bit like plate armor

55
00:02:28,850 --> 00:02:35,870
it provides really strong protection but

56
00:02:31,760 --> 00:02:38,660
it's also heavy this<font color="#E5E5E5"> is actually why</font>

57
00:02:35,870 --> 00:02:40,100
people are using sanity checks quite

58
00:02:38,660 --> 00:02:42,560
extensively during testing and

59
00:02:40,100 --> 00:02:45,769
development but they turn them off in

60
00:02:42,560 --> 00:02:49,790
production builds now the<font color="#E5E5E5"> question of</font>

61
00:02:45,770 --> 00:02:52,640
our<font color="#E5E5E5"> work is can we take away the</font>

62
00:02:49,790 --> 00:02:54,560
overhead of sanity checks in order to

63
00:02:52,640 --> 00:02:57,950
enable people to use them in production

64
00:02:54,560 --> 00:03:02,900
and surprisingly the answer is yes<font color="#E5E5E5"> and</font>

65
00:02:57,950 --> 00:03:06,230
here is why our inside is that all the

66
00:03:02,900 --> 00:03:09,110
sanity checks are not all equal in fact

67
00:03:06,230 --> 00:03:11,989
most<font color="#E5E5E5"> of the overhead comes from only a</font>

68
00:03:09,110 --> 00:03:14,450
few checks these are checks during hot

69
00:03:11,990 --> 00:03:17,290
part of your program does they are

70
00:03:14,450 --> 00:03:20,269
executed very often and are expensive on

71
00:03:17,290 --> 00:03:22,370
the other hand most of the protection

72
00:03:20,270 --> 00:03:25,280
that users get comes from checks that

73
00:03:22,370 --> 00:03:32,030
are cheap because<font color="#CCCCCC"> they are in cold parts</font>

74
00:03:25,280 --> 00:03:35,000
of the program this inside is the rock

75
00:03:32,030 --> 00:03:37,580
on<font color="#E5E5E5"> which we build our approach so our</font>

76
00:03:35,000 --> 00:03:40,070
approach starts with the user and allows

77
00:03:37,580 --> 00:03:43,010
the user to choose their overhead budget

78
00:03:40,070 --> 00:03:44,750
which is the amount of<font color="#E5E5E5"> runtime they are</font>

79
00:03:43,010 --> 00:03:47,480
willing<font color="#CCCCCC"> to</font><font color="#E5E5E5"> invest into checks that</font>

80
00:03:44,750 --> 00:03:51,290
protect them this is usually a low

81
00:03:47,480 --> 00:03:52,940
number like<font color="#E5E5E5"> five percent but then we</font>

82
00:03:51,290 --> 00:03:55,299
build<font color="#E5E5E5"> a system that automatically</font>

83
00:03:52,940 --> 00:03:58,040
identifies the sanity checks in software

84
00:03:55,300 --> 00:04:01,250
measures the cost of every single<font color="#E5E5E5"> check</font>

85
00:03:58,040 --> 00:04:04,160
and also then selects just as many

86
00:04:01,250 --> 00:04:08,750
checks as possible while respecting the

87
00:04:04,160 --> 00:04:11,000
budget that<font color="#E5E5E5"> the user specified we call</font>

88
00:04:08,750 --> 00:04:13,790
our approach ASAP because it<font color="#E5E5E5"> generates</font>

89
00:04:11,000 --> 00:04:17,140
software that's<font color="#E5E5E5"> as safe as possible for</font>

90
00:04:13,790 --> 00:04:17,140
a given overhead budget

91
00:04:19,050 --> 00:04:25,630
now the result of using<font color="#E5E5E5"> a sap is rather</font>

92
00:04:22,420 --> 00:04:27,970
surprising we<font color="#E5E5E5"> perform some measurements</font>

93
00:04:25,630 --> 00:04:30,520
on a number of benchmarks from the spec

94
00:04:27,970 --> 00:04:32,170
and phoronix benchmark suits and we

95
00:04:30,520 --> 00:04:36,370
measured both the overhead of

96
00:04:32,170 --> 00:04:38,710
instrumentation as well as the amount of

97
00:04:36,370 --> 00:04:40,600
protection that<font color="#CCCCCC"> you can get we measured</font>

98
00:04:38,710 --> 00:04:42,640
<font color="#CCCCCC">the fraction of critical operations in a</font>

99
00:04:40,600 --> 00:04:47,530
program that<font color="#CCCCCC"> are protected by checks and</font>

100
00:04:42,640 --> 00:04:49,599
call this the sanity level and when you

101
00:04:47,530 --> 00:04:54,489
do this you obtain a curve that's very

102
00:04:49,600 --> 00:04:57,130
skewed like here this means that there

103
00:04:54,490 --> 00:04:59,320
are indeed there's indeed<font color="#E5E5E5"> a large</font>

104
00:04:57,130 --> 00:05:01,390
<font color="#CCCCCC">fraction of the protection that</font><font color="#E5E5E5"> is very</font>

105
00:04:59,320 --> 00:05:04,599
cheap and comes at almost no performance

106
00:05:01,390 --> 00:05:06,700
cost on the other<font color="#E5E5E5"> hand if users want a</font>

107
00:05:04,600 --> 00:05:08,350
hundred percent protection they also

108
00:05:06,700 --> 00:05:10,300
have<font color="#CCCCCC"> to enable a few checks that are</font>

109
00:05:08,350 --> 00:05:14,980
very expensive and costs overhead to

110
00:05:10,300 --> 00:05:18,370
quickly grow using ASAP a user could now

111
00:05:14,980 --> 00:05:20,950
choose any point on this<font color="#E5E5E5"> performance and</font>

112
00:05:18,370 --> 00:05:23,950
security<font color="#E5E5E5"> trade-off and for</font><font color="#CCCCCC"> example a</font>

113
00:05:20,950 --> 00:05:25,900
user on a five percent budget can obtain

114
00:05:23,950 --> 00:05:31,570
about<font color="#CCCCCC"> eighty-seven percent</font><font color="#E5E5E5"> of the</font>

115
00:05:25,900 --> 00:05:34,030
protection I've gave you the principle

116
00:05:31,570 --> 00:05:36,550
<font color="#CCCCCC">behind ASAP and I am</font><font color="#E5E5E5"> next going to</font>

117
00:05:34,030 --> 00:05:38,530
<font color="#CCCCCC">present our design and discuss some of</font>

118
00:05:36,550 --> 00:05:41,440
the key algorithms that make a<font color="#CCCCCC"> SUP work</font>

119
00:05:38,530 --> 00:05:46,900
<font color="#E5E5E5">I will also show more</font><font color="#CCCCCC"> results in more</font>

120
00:05:41,440 --> 00:05:50,740
detail now we designed<font color="#E5E5E5"> a SAP to</font><font color="#CCCCCC"> be built</font>

121
00:05:46,900 --> 00:05:52,179
into<font color="#E5E5E5"> the compile compiler in our case</font>

122
00:05:50,740 --> 00:05:55,660
it's implemented using the LLVM compiler

123
00:05:52,180 --> 00:05:58,180
framework this choice makes ASAP fairly

124
00:05:55,660 --> 00:05:59,830
easy<font color="#CCCCCC"> to use users essentially need to</font>

125
00:05:58,180 --> 00:06:02,170
set their c compiler and<font color="#E5E5E5"> cflags</font>

126
00:05:59,830 --> 00:06:05,020
environment variables and everything

127
00:06:02,170 --> 00:06:06,850
else happens automatically we also

128
00:06:05,020 --> 00:06:09,250
carefully built ASAP so<font color="#CCCCCC"> that it's</font>

129
00:06:06,850 --> 00:06:11,950
compatible<font color="#E5E5E5"> with many</font><font color="#CCCCCC"> different tools</font>

130
00:06:09,250 --> 00:06:13,720
<font color="#E5E5E5">that add sanity checks and also things</font>

131
00:06:11,950 --> 00:06:16,630
like parallel compilation or shared

132
00:06:13,720 --> 00:06:19,630
libraries Aesop has three main

133
00:06:16,630 --> 00:06:22,780
components namely to identify sanity

134
00:06:19,630 --> 00:06:26,320
checks in programs a profiler to measure

135
00:06:22,780 --> 00:06:28,090
the checks<font color="#CCCCCC"> cost and also</font><font color="#E5E5E5"> an optimizer to</font>

136
00:06:26,320 --> 00:06:29,520
select the optimal set of checks<font color="#CCCCCC"> for a</font>

137
00:06:28,090 --> 00:06:34,289
given budget

138
00:06:29,520 --> 00:06:37,378
a user uses ASAP just<font color="#E5E5E5"> like a regular</font>

139
00:06:34,289 --> 00:06:40,620
compiler<font color="#CCCCCC"> that generates a binary that's</font>

140
00:06:37,379 --> 00:06:43,020
protected using checks<font color="#E5E5E5"> a sub would in</font>

141
00:06:40,620 --> 00:06:45,599
addition store the intermediate outputs

142
00:06:43,020 --> 00:06:47,789
of the compiler in our case this is

143
00:06:45,599 --> 00:06:51,300
files in the<font color="#CCCCCC"> llvm intermediate</font>

144
00:06:47,789 --> 00:06:53,669
representation it uses this output to

145
00:06:51,300 --> 00:06:56,639
generate variants of the program so in a

146
00:06:53,669 --> 00:06:59,340
second step the<font color="#E5E5E5"> ASAP profiler generates</font>

147
00:06:56,639 --> 00:07:02,940
an executable that<font color="#E5E5E5"> contains extra code</font>

148
00:06:59,340 --> 00:07:04,770
to measure performance users can run

149
00:07:02,940 --> 00:07:06,840
this executable against the workload<font color="#CCCCCC"> of</font>

150
00:07:04,770 --> 00:07:09,299
their choice and when they do it

151
00:07:06,840 --> 00:07:13,919
computes the cost of each of the sanity

152
00:07:09,300 --> 00:07:16,560
checks<font color="#CCCCCC"> aesop uses this cost as well as</font>

153
00:07:13,919 --> 00:07:19,620
the<font color="#CCCCCC"> user-specified</font><font color="#E5E5E5"> budget in order to</font>

154
00:07:16,560 --> 00:07:21,599
generate an optimized program that

155
00:07:19,620 --> 00:07:23,669
contains just those checks that provide

156
00:07:21,599 --> 00:07:29,580
most<font color="#E5E5E5"> protection while fitting in the</font>

157
00:07:23,669 --> 00:07:35,068
budget we are next going<font color="#E5E5E5"> to look at some</font>

158
00:07:29,580 --> 00:07:37,770
<font color="#CCCCCC">of</font><font color="#E5E5E5"> the key algorithms in ASAP ASAP is</font>

159
00:07:35,069 --> 00:07:40,349
this black<font color="#E5E5E5"> box that generates</font><font color="#CCCCCC"> vast</font>

160
00:07:37,770 --> 00:07:44,400
protected programs and it contains a

161
00:07:40,349 --> 00:07:46,139
number of important parts and<font color="#E5E5E5"> I'll have</font>

162
00:07:44,400 --> 00:07:47,818
<font color="#E5E5E5">to refer you to the paper for many of</font>

163
00:07:46,139 --> 00:07:50,009
these for example on<font color="#E5E5E5"> how a sub</font>

164
00:07:47,819 --> 00:07:54,180
identifies checks or how to select the

165
00:07:50,009 --> 00:07:57,210
good profiling workload um I'm going<font color="#E5E5E5"> to</font>

166
00:07:54,180 --> 00:07:59,940
<font color="#E5E5E5">just focus on two of the points here</font>

167
00:07:57,210 --> 00:08:02,609
namely<font color="#E5E5E5"> how ASAP measures the cost of</font>

168
00:07:59,940 --> 00:08:07,409
checks and how it quantifies protection

169
00:08:02,610 --> 00:08:09,389
in other words can users trust ASAP to

170
00:08:07,409 --> 00:08:12,960
<font color="#E5E5E5">really select the checks that consume</font>

171
00:08:09,389 --> 00:08:16,050
the least amount of CPU cycles and also

172
00:08:12,960 --> 00:08:21,210
<font color="#E5E5E5">if ASAP gives you a certain protection</font>

173
00:08:16,050 --> 00:08:23,069
level what does this really mean let's

174
00:08:21,210 --> 00:08:25,469
discuss how ASAP measures the cost of

175
00:08:23,069 --> 00:08:27,180
checks this<font color="#E5E5E5"> is again the sanity check</font>

176
00:08:25,469 --> 00:08:29,729
example from the beginning<font color="#E5E5E5"> of my</font>

177
00:08:27,180 --> 00:08:33,149
presentation in order<font color="#CCCCCC"> to measure its</font>

178
00:08:29,729 --> 00:08:36,750
<font color="#CCCCCC">costs ASAP would in a first step insert</font>

179
00:08:33,149 --> 00:08:38,880
profile encounters into the program this

180
00:08:36,750 --> 00:08:40,440
happens during compilation and uses the

181
00:08:38,880 --> 00:08:43,580
same existing profiling in thrush

182
00:08:40,440 --> 00:08:46,230
lecture that's present inside a vm

183
00:08:43,580 --> 00:08:48,120
ASAP adds one counter to every basic

184
00:08:46,230 --> 00:08:50,160
block on the<font color="#E5E5E5"> probe of</font><font color="#CCCCCC"> the program and</font>

185
00:08:48,120 --> 00:08:53,910
this<font color="#E5E5E5"> get incremented while the program</font>

186
00:08:50,160 --> 00:08:55,740
runs and thanks to<font color="#E5E5E5"> that it allows ASAP</font>

187
00:08:53,910 --> 00:08:57,449
to see exactly<font color="#E5E5E5"> how often every</font>

188
00:08:55,740 --> 00:09:03,000
instruction in program has<font color="#CCCCCC"> been executed</font>

189
00:08:57,450 --> 00:09:06,450
<font color="#E5E5E5">a sub also identifies the instructions</font>

190
00:09:03,000 --> 00:09:09,150
that<font color="#E5E5E5"> belong to sanity check and it uses</font>

191
00:09:06,450 --> 00:09:12,470
a static cost model to essentially

192
00:09:09,150 --> 00:09:14,939
convert instructions into<font color="#E5E5E5"> CPU cycles</font>

193
00:09:12,470 --> 00:09:17,100
this is also<font color="#CCCCCC"> the</font><font color="#E5E5E5"> same model that</font>

194
00:09:14,940 --> 00:09:21,810
compilers traditionally used for

195
00:09:17,100 --> 00:09:24,630
optimizations with all this data ASAP

196
00:09:21,810 --> 00:09:27,359
can now compute the cost for every<font color="#E5E5E5"> check</font>

197
00:09:24,630 --> 00:09:30,030
it<font color="#E5E5E5"> multiplies the number of times an</font>

198
00:09:27,360 --> 00:09:32,250
instruction is executed with the number

199
00:09:30,030 --> 00:09:34,890
of cycles and instruct and such an

200
00:09:32,250 --> 00:09:38,040
execution takes and it sums up these

201
00:09:34,890 --> 00:09:43,680
numbers<font color="#CCCCCC"> over all the instructions</font><font color="#E5E5E5"> in a</font>

202
00:09:38,040 --> 00:09:46,199
sanity check this gives a precise cost

203
00:09:43,680 --> 00:09:47,729
measured in CPU cycles and in<font color="#E5E5E5"> practice</font>

204
00:09:46,200 --> 00:09:49,410
we found<font color="#E5E5E5"> that this works very well to</font>

205
00:09:47,730 --> 00:09:51,390
distinguish both the checks that<font color="#CCCCCC"> are</font>

206
00:09:49,410 --> 00:09:57,410
cheap and the checks that<font color="#CCCCCC"> are</font><font color="#E5E5E5"> expensive</font>

207
00:09:51,390 --> 00:10:00,930
so<font color="#CCCCCC"> next I</font><font color="#E5E5E5"> want to talk about security if</font>

208
00:09:57,410 --> 00:10:03,329
ASAP and gives you a certain protection

209
00:10:00,930 --> 00:10:07,800
level what does<font color="#E5E5E5"> this really mean for</font>

210
00:10:03,330 --> 00:10:10,110
your security now a sub quantifies the

211
00:10:07,800 --> 00:10:13,490
protection that it gives you using the

212
00:10:10,110 --> 00:10:16,170
sanity level this is the fraction of the

213
00:10:13,490 --> 00:10:19,350
critical operations in the program that

214
00:10:16,170 --> 00:10:21,180
are protected using a check however what

215
00:10:19,350 --> 00:10:24,240
<font color="#CCCCCC">we would rather like to know from a</font>

216
00:10:21,180 --> 00:10:26,790
management perspective is the effective

217
00:10:24,240 --> 00:10:28,950
protection level in terms of bugs or

218
00:10:26,790 --> 00:10:32,640
vulnerabilities or security incidents

219
00:10:28,950 --> 00:10:35,700
that we are now protected against our

220
00:10:32,640 --> 00:10:38,400
methodology to<font color="#E5E5E5"> rewrite these two</font>

221
00:10:35,700 --> 00:10:41,130
quantities is to look at existing known

222
00:10:38,400 --> 00:10:43,079
bugs and vulnerabilities and measure<font color="#E5E5E5"> how</font>

223
00:10:41,130 --> 00:10:47,550
many<font color="#E5E5E5"> of them are effectively prevented</font>

224
00:10:43,080 --> 00:10:50,520
at a given sanity level our first

225
00:10:47,550 --> 00:10:52,140
experiment to do so in<font color="#CCCCCC"> a first</font>

226
00:10:50,520 --> 00:10:55,590
<font color="#CCCCCC">experiment we looked at the source</font><font color="#E5E5E5"> code</font>

227
00:10:52,140 --> 00:10:56,499
of<font color="#CCCCCC"> the Python interpreter and we defined</font>

228
00:10:55,590 --> 00:10:58,689
as a bug

229
00:10:56,499 --> 00:11:03,339
each line of code that<font color="#E5E5E5"> has changed</font>

230
00:10:58,689 --> 00:11:05,199
<font color="#E5E5E5">between the versions 2.71 and 2.78 so no</font>

231
00:11:03,339 --> 00:11:07,839
new features have been added<font color="#E5E5E5"> between</font>

232
00:11:05,199 --> 00:11:15,189
these versions so each line that changed

233
00:11:07,839 --> 00:11:17,229
was previously buggy we then measure for

234
00:11:15,189 --> 00:11:19,748
a given sanity level how many<font color="#E5E5E5"> of these</font>

235
00:11:17,229 --> 00:11:25,299
buggy lines are protected using sanity

236
00:11:19,749 --> 00:11:27,669
checks here are the results for example

237
00:11:25,299 --> 00:11:30,159
you<font color="#E5E5E5"> can see</font><font color="#CCCCCC"> that at a sanity level of</font>

238
00:11:27,669 --> 00:11:32,109
eighty-seven percent effectively

239
00:11:30,159 --> 00:11:36,369
ninety-one percent of the bugs are

240
00:11:32,109 --> 00:11:38,409
protected more<font color="#CCCCCC"> generally the red line</font>

241
00:11:36,369 --> 00:11:41,769
that shows the effective protection is

242
00:11:38,409 --> 00:11:44,468
always above the diagonal so this means

243
00:11:41,769 --> 00:11:46,809
that the sanity level is a lower<font color="#E5E5E5"> bound</font>

244
00:11:44,469 --> 00:11:52,809
on the<font color="#E5E5E5"> effective protection that users</font>

245
00:11:46,809 --> 00:11:54,848
can get we also performed more

246
00:11:52,809 --> 00:11:58,029
experiments where we looked at known

247
00:11:54,849 --> 00:12:00,939
bugs we looked at bugs in Python or<font color="#CCCCCC"> open</font>

248
00:11:58,029 --> 00:12:03,069
<font color="#CCCCCC">SSL but also in scientific benchmarks</font>

249
00:12:00,939 --> 00:12:06,789
like the ripe buffer overflow benchmarks

250
00:12:03,069 --> 00:12:09,699
and we found a<font color="#E5E5E5"> number of locations where</font>

251
00:12:06,789 --> 00:12:12,189
the buffer overflows occurred and in all

252
00:12:09,699 --> 00:12:14,949
those<font color="#E5E5E5"> locations that we looked at they</font>

253
00:12:12,189 --> 00:12:19,809
were in cold code where they can<font color="#CCCCCC"> be</font>

254
00:12:14,949 --> 00:12:22,589
protected<font color="#E5E5E5"> by cheap checks we also looked</font>

255
00:12:19,809 --> 00:12:25,598
at vulnerabilities from the<font color="#CCCCCC"> CVE database</font>

256
00:12:22,589 --> 00:12:28,449
so we systematically analyzed all the

257
00:12:25,599 --> 00:12:30,909
memory safety vulnerabilities from 2014

258
00:12:28,449 --> 00:12:33,969
for which we could get<font color="#E5E5E5"> the source code</font>

259
00:12:30,909 --> 00:12:37,659
and a patch and the location of the

260
00:12:33,970 --> 00:12:40,059
<font color="#E5E5E5">error there were 145 vulnerabilities</font>

261
00:12:37,659 --> 00:12:42,399
that satisfy<font color="#E5E5E5"> this criteria and we found</font>

262
00:12:40,059 --> 00:12:47,108
<font color="#E5E5E5">that eighty-three percent of these were</font>

263
00:12:42,399 --> 00:12:48,939
located in cold code now it's hardened

264
00:12:47,109 --> 00:12:51,539
probably dangerous to draw conclusions

265
00:12:48,939 --> 00:12:54,608
about security from these<font color="#CCCCCC"> experiments</font>

266
00:12:51,539 --> 00:12:57,609
but<font color="#E5E5E5"> all these experiments indicate that</font>

267
00:12:54,609 --> 00:13:01,589
checks that are in cold code<font color="#E5E5E5"> actually do</font>

268
00:12:57,609 --> 00:13:01,589
provide real value for protection

269
00:13:04,250 --> 00:13:13,740
next as promised<font color="#E5E5E5"> I'll show some more</font>

270
00:13:07,500 --> 00:13:16,380
results about ASA on this graph here<font color="#CCCCCC"> you</font>

271
00:13:13,740 --> 00:13:19,980
can see the overhead that we measured on

272
00:13:16,380 --> 00:13:21,660
the spec benchmarks when adding the

273
00:13:19,980 --> 00:13:25,170
sanity checks generated by address

274
00:13:21,660 --> 00:13:27,120
sanitizer tool as you can see address

275
00:13:25,170 --> 00:13:29,819
sanitizer has a rather high overhead

276
00:13:27,120 --> 00:13:33,110
it's<font color="#E5E5E5"> usually above fifty percent and</font>

277
00:13:29,820 --> 00:13:36,960
sometimes<font color="#CCCCCC"> even above one-hundred percent</font>

278
00:13:33,110 --> 00:13:39,390
now using ASAP users could now reduce

279
00:13:36,960 --> 00:13:43,590
this overhead by choosing a slightly

280
00:13:39,390 --> 00:13:45,780
lower sanity<font color="#CCCCCC"> level so here you can see</font>

281
00:13:43,590 --> 00:13:49,140
<font color="#CCCCCC">the</font><font color="#E5E5E5"> overhead for a sanity level of</font>

282
00:13:45,780 --> 00:13:51,750
ninety-five percent so all the red parts

283
00:13:49,140 --> 00:13:54,449
in this figure our CPU cycles that be

284
00:13:51,750 --> 00:14:01,050
safe by<font color="#E5E5E5"> reducing the production by</font><font color="#CCCCCC"> five</font>

285
00:13:54,450 --> 00:14:03,150
<font color="#CCCCCC">percent users who want even lower</font>

286
00:14:01,050 --> 00:14:05,939
overhead can reduce the protection level

287
00:14:03,150 --> 00:14:09,930
further so here<font color="#E5E5E5"> is the result for ninety</font>

288
00:14:05,940 --> 00:14:13,460
percent protect sanity level<font color="#E5E5E5"> and here it</font>

289
00:14:09,930 --> 00:14:16,189
is for<font color="#E5E5E5"> a sanity level of eighty percent</font>

290
00:14:13,460 --> 00:14:18,930
now I would like<font color="#CCCCCC"> to highlight two things</font>

291
00:14:16,190 --> 00:14:22,470
the first is that<font color="#E5E5E5"> for some benchmarks</font>

292
00:14:18,930 --> 00:14:24,030
there is still residual overhead and we

293
00:14:22,470 --> 00:14:26,250
<font color="#E5E5E5">found that this is actually overhead</font>

294
00:14:24,030 --> 00:14:28,350
that<font color="#E5E5E5"> is not you two checks but due to</font>

295
00:14:26,250 --> 00:14:31,220
other things that address analyzer does

296
00:14:28,350 --> 00:14:36,030
like changes to the memory allocator or

297
00:14:31,220 --> 00:14:38,160
effects on the instruction caches now

298
00:14:36,030 --> 00:14:41,100
address analyzer was not built with<font color="#CCCCCC"> a</font>

299
00:14:38,160 --> 00:14:43,410
<font color="#CCCCCC">SUP in mind so we think that some of</font>

300
00:14:41,100 --> 00:14:45,720
<font color="#E5E5E5">these causes for residual overhead could</font>

301
00:14:43,410 --> 00:14:49,740
be addressed with the future

302
00:14:45,720 --> 00:14:52,560
instrumentation tools for the other

303
00:14:49,740 --> 00:14:54,750
benchmarks the overheads are now well

304
00:14:52,560 --> 00:14:57,810
within a range that<font color="#CCCCCC"> people would be</font>

305
00:14:54,750 --> 00:14:59,490
willing to pay during production so we

306
00:14:57,810 --> 00:15:04,339
can<font color="#E5E5E5"> conclude</font><font color="#CCCCCC"> that ASAP effectively</font>

307
00:14:59,490 --> 00:15:04,340
<font color="#E5E5E5">provides high protection at low overhead</font>

308
00:15:06,649 --> 00:15:12,499
I will<font color="#E5E5E5"> conclude by saying that runtime</font>

309
00:15:10,399 --> 00:15:16,850
checks are a great way to protect

310
00:15:12,499 --> 00:15:19,220
software their cost is high but we found

311
00:15:16,850 --> 00:15:22,069
<font color="#E5E5E5">that</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> cost usually comes</font><font color="#CCCCCC"> from just</font><font color="#E5E5E5"> a</font>

312
00:15:19,220 --> 00:15:24,259
few checks that are<font color="#E5E5E5"> expensive on the</font>

313
00:15:22,069 --> 00:15:28,009
other hand most of the protection comes

314
00:15:24,259 --> 00:15:30,470
from<font color="#CCCCCC"> check stood are cheap so we</font><font color="#E5E5E5"> built</font>

315
00:15:28,009 --> 00:15:32,600
ASAP a tool that allows the user to

316
00:15:30,470 --> 00:15:36,980
specify how much overhead they're

317
00:15:32,600 --> 00:15:39,319
willing to pay<font color="#E5E5E5"> and creates an executable</font>

318
00:15:36,980 --> 00:15:42,470
<font color="#CCCCCC">that provides maximum protection for</font>

319
00:15:39,319 --> 00:15:45,979
that overhead budget with ASAP

320
00:15:42,470 --> 00:15:48,050
protection no longer has a high cost so

321
00:15:45,980 --> 00:15:50,389
I would encourage you<font color="#E5E5E5"> to go to our</font>

322
00:15:48,050 --> 00:15:53,420
<font color="#E5E5E5">website download the open-source version</font>

323
00:15:50,389 --> 00:16:03,079
of ASAP and try it out to<font color="#E5E5E5"> protect your</font>

324
00:15:53,420 --> 00:16:10,610
software thank you<font color="#E5E5E5"> okay we have time for</font>

325
00:16:03,079 --> 00:16:11,748
<font color="#CCCCCC">a few questions Vanguard from UIC</font><font color="#E5E5E5"> I have</font>

326
00:16:10,610 --> 00:16:14,689
a couple<font color="#E5E5E5"> of questions the first question</font>

327
00:16:11,749 --> 00:16:16,790
is more of a clarification the I didn't

328
00:16:14,689 --> 00:16:18,980
quite<font color="#CCCCCC"> catch whether the definition</font><font color="#E5E5E5"> of</font>

329
00:16:16,790 --> 00:16:20,899
sanity level is a static measure or is

330
00:16:18,980 --> 00:16:22,939
it a dynamic measure you know is it

331
00:16:20,899 --> 00:16:25,929
based on your profiles or is it based on

332
00:16:22,939 --> 00:16:28,509
some analysis of that you do of<font color="#E5E5E5"> the code</font>

333
00:16:25,929 --> 00:16:32,050
<font color="#E5E5E5">okay so this is a static measure</font>

334
00:16:28,509 --> 00:16:34,699
essentially you look at the<font color="#CCCCCC"> program and</font>

335
00:16:32,050 --> 00:16:36,589
in the program there are many

336
00:16:34,699 --> 00:16:38,029
instructions that are potentially

337
00:16:36,589 --> 00:16:41,179
dangerous like memory access

338
00:16:38,029 --> 00:16:44,389
instructions like loads and all of these

339
00:16:41,179 --> 00:16:47,240
<font color="#E5E5E5">could be protected by a check if you use</font>

340
00:16:44,389 --> 00:16:49,339
a systematic tool and now we define us

341
00:16:47,240 --> 00:16:51,129
to sanity level the fraction of these

342
00:16:49,339 --> 00:16:53,990
checks that are effectively present

343
00:16:51,129 --> 00:16:58,209
present in the optimized version that

344
00:16:53,990 --> 00:17:00,379
ASAP generates does that<font color="#E5E5E5"> make sense yes</font>

345
00:16:58,209 --> 00:17:04,099
my other question is I'm somewhat

346
00:17:00,379 --> 00:17:07,399
surprised that you have not factored the

347
00:17:04,099 --> 00:17:10,099
influence of you know input on any of

348
00:17:07,398 --> 00:17:11,779
this because there are essentially many

349
00:17:10,099 --> 00:17:14,270
checks that can be done on a program

350
00:17:11,779 --> 00:17:16,460
where the user input will not have any

351
00:17:14,270 --> 00:17:18,500
influence and therefore

352
00:17:16,460 --> 00:17:20,180
you know so the real bugs that are

353
00:17:18,500 --> 00:17:24,440
exploitable are ones that can be

354
00:17:20,180 --> 00:17:26,360
influenced by user input so but I don't

355
00:17:24,440 --> 00:17:30,910
see<font color="#CCCCCC"> that in your you know trade-offs oh</font>

356
00:17:26,359 --> 00:17:34,399
and yes so I think<font color="#E5E5E5"> this is</font><font color="#CCCCCC"> a great point</font>

357
00:17:30,910 --> 00:17:37,130
so what we do is we look at each check

358
00:17:34,400 --> 00:17:39,200
and we select them or not purely based

359
00:17:37,130 --> 00:17:41,180
on their<font color="#E5E5E5"> cost and what you're saying is</font>

360
00:17:39,200 --> 00:17:43,690
that you could also select checks based

361
00:17:41,180 --> 00:17:46,550
on their merit or based on whether the

362
00:17:43,690 --> 00:17:51,320
operation that I protect has input

363
00:17:46,550 --> 00:17:54,169
dependent data or so right and now what

364
00:17:51,320 --> 00:17:56,929
we do is yeah we decide purely based on

365
00:17:54,170 --> 00:17:59,060
their<font color="#E5E5E5"> cost and we show in the graph</font>

366
00:17:56,930 --> 00:18:01,280
about Python or so that this is actually

367
00:17:59,060 --> 00:18:04,399
a conservative assumption in some sense

368
00:18:01,280 --> 00:18:07,550
in that checks that are cheap tend to

369
00:18:04,400 --> 00:18:11,630
have a slightly higher impact for

370
00:18:07,550 --> 00:18:13,669
protection than text are expensive<font color="#CCCCCC"> but</font>

371
00:18:11,630 --> 00:18:16,910
it is also somewhat counter and do do to

372
00:18:13,670 --> 00:18:20,420
<font color="#CCCCCC">me there are no we can take this out</font>

373
00:18:16,910 --> 00:18:22,790
yeah thank you<font color="#E5E5E5"> wait with pleasure hi</font>

374
00:18:20,420 --> 00:18:26,270
there Trent Jagger Penn<font color="#CCCCCC"> State nice talk</font>

375
00:18:22,790 --> 00:18:29,240
I wanted<font color="#E5E5E5"> to explore this hot path cold</font>

376
00:18:26,270 --> 00:18:31,639
path thing a<font color="#E5E5E5"> little bit so so the notion</font>

377
00:18:29,240 --> 00:18:34,520
i mean i think<font color="#E5E5E5"> we've also experienced</font>

378
00:18:31,640 --> 00:18:36,740
that cold paths often or where where<font color="#CCCCCC"> the</font>

379
00:18:34,520 --> 00:18:40,550
bugs are now where the vulnerabilities

380
00:18:36,740 --> 00:18:43,250
are now but<font color="#E5E5E5"> i guess what i was wondering</font>

381
00:18:40,550 --> 00:18:44,840
is did<font color="#E5E5E5"> you explore</font><font color="#CCCCCC"> i mean it seems that</font>

382
00:18:43,250 --> 00:18:47,570
on the hot paths people might already

383
00:18:44,840 --> 00:18:50,510
have added sanity checks into the code

384
00:18:47,570 --> 00:18:52,429
manually on the hot paths in order to

385
00:18:50,510 --> 00:18:55,010
you know defend things because they've

386
00:18:52,430 --> 00:18:56,360
already seen these paths be run several

387
00:18:55,010 --> 00:18:58,790
times and so forth and so<font color="#CCCCCC"> i was</font>

388
00:18:56,360 --> 00:19:01,070
wondering if your analysis looked for

389
00:18:58,790 --> 00:19:04,370
existing sanity checks that were already

390
00:19:01,070 --> 00:19:06,710
<font color="#E5E5E5">in the code and in some sense maybe you</font>

391
00:19:04,370 --> 00:19:09,979
know you might you know improve or

392
00:19:06,710 --> 00:19:11,300
verify or you know replace<font color="#CCCCCC"> the sanity</font>

393
00:19:09,980 --> 00:19:13,490
checks that are there with better ones

394
00:19:11,300 --> 00:19:15,770
with at very low cost in that Sun so I

395
00:19:13,490 --> 00:19:17,800
just wondering if this intuition was

396
00:19:15,770 --> 00:19:21,970
consistent and if you had thought<font color="#E5E5E5"> about</font>

397
00:19:17,800 --> 00:19:24,500
looking at the existing checks yeah so

398
00:19:21,970 --> 00:19:26,960
there are<font color="#CCCCCC"> a couple of elements</font><font color="#E5E5E5"> to the</font>

399
00:19:24,500 --> 00:19:28,430
answer and the first is that yeah our

400
00:19:26,960 --> 00:19:29,720
tool does work with for example

401
00:19:28,430 --> 00:19:32,270
assertions that

402
00:19:29,720 --> 00:19:34,250
<font color="#CCCCCC">bella</font><font color="#E5E5E5"> purrs manually put in the it</font>

403
00:19:32,270 --> 00:19:40,040
recognizes them just like any other type

404
00:19:34,250 --> 00:19:43,400
of sanity<font color="#E5E5E5"> check and also users have some</font>

405
00:19:40,040 --> 00:19:45,080
control over like which parts<font color="#E5E5E5"> of the</font>

406
00:19:43,400 --> 00:19:47,930
program are hot and which are called if

407
00:19:45,080 --> 00:19:51,530
they if they select their training

408
00:19:47,930 --> 00:19:53,090
workload and accordingly so we have

409
00:19:51,530 --> 00:19:55,220
quite a lot<font color="#CCCCCC"> of information about</font><font color="#E5E5E5"> that in</font>

410
00:19:53,090 --> 00:19:57,409
the paper<font color="#E5E5E5"> for example we explored what</font>

411
00:19:55,220 --> 00:19:59,810
happens if users use their test suit as

412
00:19:57,410 --> 00:20:02,060
a profiling workload because that would

413
00:19:59,810 --> 00:20:05,540
automatically stress the parts that are

414
00:20:02,060 --> 00:20:07,970
well tested more and<font color="#E5E5E5"> removed more checks</font>

415
00:20:05,540 --> 00:20:10,580
from the<font color="#E5E5E5"> well tested parts does that</font>

416
00:20:07,970 --> 00:20:13,820
make sense so so you were looking at

417
00:20:10,580 --> 00:20:17,570
existing sanity checks it yes yes we do

418
00:20:13,820 --> 00:20:20,090
yeah thanks please try to<font color="#E5E5E5"> keep it short</font>

419
00:20:17,570 --> 00:20:22,700
<font color="#E5E5E5">to schedule sure so I guess address</font>

420
00:20:20,090 --> 00:20:24,620
sanitizers a debugging tool and you're

421
00:20:22,700 --> 00:20:27,230
promoting this as a mitigation technique

422
00:20:24,620 --> 00:20:28,699
<font color="#E5E5E5">I guess some previous talks a zine</font>

423
00:20:27,230 --> 00:20:30,290
suggested that one has to be quite

424
00:20:28,700 --> 00:20:32,570
careful when designing mitigation

425
00:20:30,290 --> 00:20:34,610
techniques be resistant to attacks I my

426
00:20:32,570 --> 00:20:36,169
take is that you know bounds checking

427
00:20:34,610 --> 00:20:37,969
and so on is a pretty sensible thing to

428
00:20:36,170 --> 00:20:39,320
do and helps both with debugging and

429
00:20:37,970 --> 00:20:41,780
with security but have you spotted any

430
00:20:39,320 --> 00:20:43,490
differences between some of the more

431
00:20:41,780 --> 00:20:45,410
interesting you know<font color="#E5E5E5"> and more</font>

432
00:20:43,490 --> 00:20:46,460
adversarial centered mitigation

433
00:20:45,410 --> 00:20:47,930
techniques and the kind of debugging

434
00:20:46,460 --> 00:20:52,100
techniques that are present in Andres

435
00:20:47,930 --> 00:20:54,380
sanitizer so yes<font color="#E5E5E5"> this is true and I want</font>

436
00:20:52,100 --> 00:20:56,179
to<font color="#E5E5E5"> say that we actually did test our</font>

437
00:20:54,380 --> 00:20:59,330
tool also with something like<font color="#E5E5E5"> soft bound</font>

438
00:20:56,180 --> 00:21:03,590
which is a more security focused way to

439
00:20:59,330 --> 00:21:06,290
add bounced checks and also in the CD

440
00:21:03,590 --> 00:21:08,179
study that we did and we looked at all

441
00:21:06,290 --> 00:21:11,050
these vulnerabilities and we found<font color="#E5E5E5"> that</font>

442
00:21:08,180 --> 00:21:13,820
for<font color="#CCCCCC"> about</font><font color="#E5E5E5"> four out of five we could tell</font>

443
00:21:11,050 --> 00:21:17,120
with some precision where the overflow

444
00:21:13,820 --> 00:21:19,159
would occur and what object and this was

445
00:21:17,120 --> 00:21:20,959
and whether it was an overflow that<font color="#CCCCCC"> was</font>

446
00:21:19,160 --> 00:21:22,430
just linear which would be caught by a

447
00:21:20,960 --> 00:21:24,440
something like address sanitizer or

448
00:21:22,430 --> 00:21:26,600
whether it was a more complex thing and

449
00:21:24,440 --> 00:21:30,140
we found<font color="#CCCCCC"> that</font><font color="#E5E5E5"> yeah in about four of out</font>

450
00:21:26,600 --> 00:21:31,610
of five cases even unsound protection

451
00:21:30,140 --> 00:21:35,240
like address sanitizer would probably

452
00:21:31,610 --> 00:21:37,510
have helped<font color="#CCCCCC"> Thanks</font><font color="#E5E5E5"> ok let's thank</font><font color="#CCCCCC"> the</font>

453
00:21:35,240 --> 00:21:37,510
speaker

