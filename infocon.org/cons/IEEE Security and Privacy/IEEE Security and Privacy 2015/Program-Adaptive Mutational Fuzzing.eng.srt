1
00:00:00,060 --> 00:00:05,310
thank you for the introduction<font color="#E5E5E5"> and</font>

2
00:00:01,890 --> 00:00:06,239
<font color="#CCCCCC">welcome to my talk this is a joint work</font>

3
00:00:05,310 --> 00:00:08,760
with<font color="#E5E5E5"> maverick</font>

4
00:00:06,240 --> 00:00:11,070
and David Bromley today I'm going<font color="#E5E5E5"> to</font>

5
00:00:08,760 --> 00:00:13,799
talk about<font color="#E5E5E5"> my research about mutational</font>

6
00:00:11,070 --> 00:00:15,509
<font color="#E5E5E5">fuzzy mutational fuzzing is an effective</font>

7
00:00:13,799 --> 00:00:17,789
<font color="#E5E5E5">software testing technique for finding</font>

8
00:00:15,509 --> 00:00:20,340
<font color="#E5E5E5">security</font><font color="#CCCCCC"> browsing cost software such as</font>

9
00:00:17,789 --> 00:00:22,949
follows<font color="#E5E5E5"> we often call this technique as</font>

10
00:00:20,340 --> 00:00:25,289
blackbox<font color="#CCCCCC"> mutation or fuzzing because we</font>

11
00:00:22,949 --> 00:00:27,269
consider the program<font color="#E5E5E5"> as the black box</font>

12
00:00:25,289 --> 00:00:29,400
<font color="#E5E5E5">which means we do not</font><font color="#CCCCCC"> look</font><font color="#E5E5E5"> at the</font>

13
00:00:27,269 --> 00:00:32,430
internals of<font color="#CCCCCC"> the</font><font color="#E5E5E5"> program the way it</font>

14
00:00:29,400 --> 00:00:34,920
works is<font color="#CCCCCC"> to iteratively run</font><font color="#E5E5E5"> this program</font>

15
00:00:32,430 --> 00:00:37,079
with a series of<font color="#E5E5E5"> different inputs and</font>

16
00:00:34,920 --> 00:00:39,000
observe the outputs and if the<font color="#E5E5E5"> program</font>

17
00:00:37,079 --> 00:00:42,510
crashes<font color="#E5E5E5"> then we know</font><font color="#CCCCCC"> that the</font>

18
00:00:39,000 --> 00:00:44,489
<font color="#E5E5E5">corresponding input is buggy</font><font color="#CCCCCC"> input we</font>

19
00:00:42,510 --> 00:00:46,920
say mutational fuzzing because we

20
00:00:44,489 --> 00:00:49,530
generate test inputs by mutating<font color="#E5E5E5"> as</font>

21
00:00:46,920 --> 00:00:50,309
given<font color="#E5E5E5"> C which is typically a</font>

22
00:00:49,530 --> 00:00:53,129
<font color="#CCCCCC">well-structured</font>

23
00:00:50,309 --> 00:00:55,468
input as we can<font color="#E5E5E5"> imagine the</font>

24
00:00:53,129 --> 00:00:57,750
effectiveness effectiveness of fuzzing

25
00:00:55,469 --> 00:01:00,510
largely depends on how we generate those

26
00:00:57,750 --> 00:01:02,460
test inputs<font color="#E5E5E5"> because some inputs may</font>

27
00:01:00,510 --> 00:01:05,399
trigger lots of software<font color="#E5E5E5"> bugs whereas</font>

28
00:01:02,460 --> 00:01:07,080
some other bugs may not therefore in

29
00:01:05,400 --> 00:01:10,439
this<font color="#E5E5E5"> project our</font><font color="#CCCCCC"> goal is to generate</font>

30
00:01:07,080 --> 00:01:12,869
<font color="#E5E5E5">test inputs from seed in such a way</font><font color="#CCCCCC"> that</font>

31
00:01:10,439 --> 00:01:15,899
maximizes the<font color="#CCCCCC"> number of bugs found for a</font>

32
00:01:12,869 --> 00:01:17,759
given limited resources<font color="#CCCCCC"> for</font><font color="#E5E5E5"> example one</font>

33
00:01:15,900 --> 00:01:19,770
of<font color="#CCCCCC"> our previous</font><font color="#E5E5E5"> works in this line of</font>

34
00:01:17,759 --> 00:01:22,140
research<font color="#CCCCCC"> showed that selecting good</font>

35
00:01:19,770 --> 00:01:24,210
seeds matters by selecting a good seed

36
00:01:22,140 --> 00:01:26,970
we can generate<font color="#E5E5E5"> good set of test inputs</font>

37
00:01:24,210 --> 00:01:29,850
<font color="#E5E5E5">therefore that that triggers a</font><font color="#CCCCCC"> lots of</font>

38
00:01:26,970 --> 00:01:31,710
software<font color="#E5E5E5"> bugs and similarly selecting</font><font color="#CCCCCC"> a</font>

39
00:01:29,850 --> 00:01:34,500
<font color="#E5E5E5">good mutation strategy also matters</font>

40
00:01:31,710 --> 00:01:37,020
given the same seed different mutation

41
00:01:34,500 --> 00:01:40,020
strategies will result in different<font color="#CCCCCC"> sets</font>

42
00:01:37,020 --> 00:01:41,970
<font color="#E5E5E5">of test inputs therefore it is a common</font>

43
00:01:40,020 --> 00:01:44,850
practice<font color="#CCCCCC"> for mutation of others to</font>

44
00:01:41,970 --> 00:01:46,770
employ various different mutation

45
00:01:44,850 --> 00:01:48,960
strategies based on their own heuristics

46
00:01:46,770 --> 00:01:51,090
<font color="#E5E5E5">for</font><font color="#CCCCCC"> example a FL which is the</font>

47
00:01:48,960 --> 00:01:54,809
<font color="#CCCCCC">state-of-the-art</font><font color="#E5E5E5"> mutational</font><font color="#CCCCCC"> fuzzer uses</font>

48
00:01:51,090 --> 00:01:56,579
<font color="#E5E5E5">20</font><font color="#CCCCCC"> different mutation strategies</font><font color="#E5E5E5"> BFF and</font>

49
00:01:54,810 --> 00:01:58,469
these<font color="#E5E5E5"> of which are also very popular</font>

50
00:01:56,579 --> 00:02:02,369
<font color="#E5E5E5">mutation</font><font color="#CCCCCC"> or fuzzers they employ their</font>

51
00:01:58,469 --> 00:02:05,520
own mutation strategies however<font color="#CCCCCC"> when you</font>

52
00:02:02,369 --> 00:02:07,710
if you notice<font color="#E5E5E5"> that all these different</font>

53
00:02:05,520 --> 00:02:08,970
mutation<font color="#E5E5E5"> officers use the exact same</font>

54
00:02:07,710 --> 00:02:12,269
common

55
00:02:08,970 --> 00:02:13,890
<font color="#E5E5E5">pip strategy from</font><font color="#CCCCCC"> Biff flipping the bit</font>

56
00:02:12,270 --> 00:02:17,550
flipping based mutations

57
00:02:13,890 --> 00:02:19,829
is very<font color="#E5E5E5"> simple</font><font color="#CCCCCC"> yet</font><font color="#E5E5E5"> popular technique the</font>

58
00:02:17,550 --> 00:02:22,290
idea is to take a<font color="#CCCCCC"> seed</font><font color="#E5E5E5"> and generate test</font>

59
00:02:19,830 --> 00:02:25,290
inputs by flipping<font color="#E5E5E5"> several bit positions</font>

60
00:02:22,290 --> 00:02:28,769
from<font color="#CCCCCC"> the seed</font><font color="#E5E5E5"> although it looks very</font>

61
00:02:25,290 --> 00:02:30,510
simple<font color="#CCCCCC"> it is surprisingly</font><font color="#E5E5E5"> effective in</font>

62
00:02:28,770 --> 00:02:32,750
practice<font color="#CCCCCC"> and</font><font color="#E5E5E5"> therefore it is used</font><font color="#CCCCCC"> by</font>

63
00:02:30,510 --> 00:02:35,280
<font color="#CCCCCC">many practical fuzzers as</font><font color="#E5E5E5"> I mentioned</font>

64
00:02:32,750 --> 00:02:37,980
<font color="#E5E5E5">however there is one</font><font color="#CCCCCC"> issue in using this</font>

65
00:02:35,280 --> 00:02:40,860
particular<font color="#E5E5E5"> strategy namely we need to</font>

66
00:02:37,980 --> 00:02:44,280
know how many bit positions from from

67
00:02:40,860 --> 00:02:45,989
the seed to<font color="#E5E5E5"> foot</font><font color="#CCCCCC"> this</font><font color="#E5E5E5"> is important</font>

68
00:02:44,280 --> 00:02:48,090
<font color="#CCCCCC">because we will get totally different</font>

69
00:02:45,989 --> 00:02:51,180
sets of test inputs by flipping

70
00:02:48,090 --> 00:02:53,760
different numbers of<font color="#E5E5E5"> bits of the seed in</font>

71
00:02:51,180 --> 00:02:55,820
fact several mutational<font color="#CCCCCC"> fuzzers even</font>

72
00:02:53,760 --> 00:02:58,470
employ an additional<font color="#CCCCCC"> parameter called</font>

73
00:02:55,820 --> 00:03:01,380
<font color="#E5E5E5">mutation ratio to control this</font>

74
00:02:58,470 --> 00:03:03,810
<font color="#CCCCCC">particular number</font><font color="#E5E5E5"> so in this in this</font>

75
00:03:01,380 --> 00:03:06,030
case the<font color="#CCCCCC"> question becomes which mutation</font>

76
00:03:03,810 --> 00:03:09,540
<font color="#E5E5E5">ratio should we use</font><font color="#CCCCCC"> to generate</font><font color="#E5E5E5"> test</font>

77
00:03:06,030 --> 00:03:11,880
inputs there are several<font color="#CCCCCC"> of previous</font>

78
00:03:09,540 --> 00:03:14,670
approaches to tackle this challenge<font color="#E5E5E5"> the</font>

79
00:03:11,880 --> 00:03:17,070
first<font color="#E5E5E5"> approach is to try several</font>

80
00:03:14,670 --> 00:03:21,450
<font color="#CCCCCC">different mutation ratios first</font><font color="#E5E5E5"> to learn</font>

81
00:03:17,070 --> 00:03:24,600
which ratio works best<font color="#E5E5E5"> but as you can</font>

82
00:03:21,450 --> 00:03:28,380
<font color="#E5E5E5">imagine</font><font color="#CCCCCC"> this</font><font color="#E5E5E5"> approach requires lots of</font>

83
00:03:24,600 --> 00:03:30,900
unnecessary trials and<font color="#CCCCCC"> the selection of</font>

84
00:03:28,380 --> 00:03:34,709
<font color="#E5E5E5">different mutation ratios to try is</font>

85
00:03:30,900 --> 00:03:37,170
based on<font color="#CCCCCC"> arbitrary decision the second</font>

86
00:03:34,709 --> 00:03:39,360
<font color="#E5E5E5">approach is to</font><font color="#CCCCCC"> use a single mutation</font>

87
00:03:37,170 --> 00:03:42,089
ratio regardless of the<font color="#E5E5E5"> program</font><font color="#CCCCCC"> and the</font>

88
00:03:39,360 --> 00:03:43,709
<font color="#E5E5E5">test which may work for</font><font color="#CCCCCC"> some programs</font>

89
00:03:42,090 --> 00:03:46,590
but<font color="#E5E5E5"> this is not a general approach</font>

90
00:03:43,709 --> 00:03:49,500
because good mutation ratios differ for

91
00:03:46,590 --> 00:03:52,500
different<font color="#E5E5E5"> programs</font><font color="#CCCCCC"> in</font><font color="#E5E5E5"> this project we</font>

92
00:03:49,500 --> 00:03:54,720
<font color="#E5E5E5">propose a novel approach that tackles</font>

93
00:03:52,500 --> 00:03:57,120
both of these problems<font color="#E5E5E5"> by directly</font>

94
00:03:54,720 --> 00:04:00,030
inferring a good mutation ratio for a

95
00:03:57,120 --> 00:04:01,709
given program<font color="#E5E5E5"> and a seat therefore our</font>

96
00:04:00,030 --> 00:04:04,739
approach does not<font color="#E5E5E5"> require any learning</font>

97
00:04:01,709 --> 00:04:07,200
process and it is program adaptive<font color="#E5E5E5"> at</font><font color="#CCCCCC"> a</font>

98
00:04:04,739 --> 00:04:09,959
<font color="#CCCCCC">high level our system called sim first</font>

99
00:04:07,200 --> 00:04:12,268
arrives<font color="#CCCCCC"> a mutation ratio</font><font color="#E5E5E5"> from a white</font>

100
00:04:09,959 --> 00:04:15,180
box analysis and we use this mutation

101
00:04:12,269 --> 00:04:18,930
ratio to run classic black box mutation

102
00:04:15,180 --> 00:04:21,180
or fuzzing to find box so the key

103
00:04:18,930 --> 00:04:24,390
challenge here is<font color="#CCCCCC"> to infer a good</font>

104
00:04:21,180 --> 00:04:27,570
mutation ratio<font color="#CCCCCC"> our from the white box</font>

105
00:04:24,390 --> 00:04:30,090
analysis in our system we perform

106
00:04:27,570 --> 00:04:31,980
<font color="#CCCCCC">a</font><font color="#E5E5E5"> three step</font><font color="#CCCCCC"> approach to</font><font color="#E5E5E5"> tackle this</font>

107
00:04:30,090 --> 00:04:34,229
challenge<font color="#CCCCCC"> the first step is to construct</font>

108
00:04:31,980 --> 00:04:36,870
<font color="#E5E5E5">a formula representing the fuzzing</font>

109
00:04:34,230 --> 00:04:40,530
efficiency<font color="#E5E5E5"> which</font><font color="#CCCCCC"> is the probability of</font>

110
00:04:36,870 --> 00:04:42,870
seeing crashing impacts we start from

111
00:04:40,530 --> 00:04:45,479
the following observation crashing

112
00:04:42,870 --> 00:04:47,640
inputs derived from the same seed<font color="#E5E5E5"> share</font>

113
00:04:45,480 --> 00:04:49,410
some common patterns<font color="#E5E5E5"> the suppose we're</font>

114
00:04:47,640 --> 00:04:52,020
giving a PNG<font color="#E5E5E5"> file as a seed</font>

115
00:04:49,410 --> 00:04:54,810
since<font color="#E5E5E5"> synthesis is a</font><font color="#CCCCCC"> well-structured</font>

116
00:04:52,020 --> 00:04:58,140
input<font color="#E5E5E5"> this file consists of several data</font>

117
00:04:54,810 --> 00:05:00,210
fields as as you can see here<font color="#E5E5E5"> and we're</font>

118
00:04:58,140 --> 00:05:02,789
<font color="#E5E5E5">going to use</font><font color="#CCCCCC"> a red rectangle</font><font color="#E5E5E5"> here to</font>

119
00:05:00,210 --> 00:05:05,280
represent<font color="#E5E5E5"> a bit position that is flicked</font>

120
00:05:02,790 --> 00:05:07,230
<font color="#E5E5E5">from the seed and by flipping several</font><font color="#CCCCCC"> B</font>

121
00:05:05,280 --> 00:05:15,390
<font color="#E5E5E5">positions of the seed we can generate</font>

122
00:05:07,230 --> 00:05:17,430
test inputs<font color="#E5E5E5"> as follows and and out of</font>

123
00:05:15,390 --> 00:05:19,770
those<font color="#CCCCCC"> four test cases that we generated</font>

124
00:05:17,430 --> 00:05:21,960
<font color="#E5E5E5">we</font><font color="#CCCCCC"> assumed that</font><font color="#E5E5E5"> only two of them are</font>

125
00:05:19,770 --> 00:05:23,580
crashing inputs<font color="#E5E5E5"> and from these test</font>

126
00:05:21,960 --> 00:05:27,390
inputs we<font color="#CCCCCC"> observed the following</font>

127
00:05:23,580 --> 00:05:30,180
patterns first the - crashing inputs

128
00:05:27,390 --> 00:05:32,669
<font color="#E5E5E5">have the same</font><font color="#CCCCCC"> flipped</font><font color="#E5E5E5"> positions</font><font color="#CCCCCC"> in fact</font>

129
00:05:30,180 --> 00:05:34,800
there is<font color="#CCCCCC"> only one</font><font color="#E5E5E5"> common the position</font>

130
00:05:32,670 --> 00:05:36,690
that is flipped<font color="#E5E5E5"> in both crashing impacts</font>

131
00:05:34,800 --> 00:05:39,660
and if you look at the third test case

132
00:05:36,690 --> 00:05:42,540
<font color="#CCCCCC">that we</font><font color="#E5E5E5"> generated we can regenerate this</font>

133
00:05:39,660 --> 00:05:44,550
input<font color="#E5E5E5"> by flipping just one</font><font color="#CCCCCC"> Vectis</font><font color="#E5E5E5"> which</font>

134
00:05:42,540 --> 00:05:47,310
means this<font color="#CCCCCC"> particular bit position is</font>

135
00:05:44,550 --> 00:05:49,770
really<font color="#E5E5E5"> critical to find out crashing</font>

136
00:05:47,310 --> 00:05:53,070
input<font color="#E5E5E5"> however when you look at the last</font>

137
00:05:49,770 --> 00:05:55,229
test case<font color="#CCCCCC"> that we generated this</font><font color="#E5E5E5"> input</font>

138
00:05:53,070 --> 00:05:57,360
also<font color="#E5E5E5"> has exactly the same flipped bit</font>

139
00:05:55,230 --> 00:05:59,670
position<font color="#E5E5E5"> but this input does not crash</font>

140
00:05:57,360 --> 00:06:01,860
the program<font color="#E5E5E5"> the reason is because there</font>

141
00:05:59,670 --> 00:06:04,860
are other<font color="#CCCCCC"> with positions that must not</font>

142
00:06:01,860 --> 00:06:07,440
be flipped<font color="#CCCCCC"> to</font><font color="#E5E5E5"> trigger the crash for</font>

143
00:06:04,860 --> 00:06:09,750
example<font color="#CCCCCC"> in this particular case we flip</font>

144
00:06:07,440 --> 00:06:12,930
a bit from the magic value<font color="#E5E5E5"> of the PNG</font>

145
00:06:09,750 --> 00:06:15,240
<font color="#E5E5E5">and and since we modify the magic value</font>

146
00:06:12,930 --> 00:06:18,450
<font color="#E5E5E5">of the PNG file no matter what value you</font>

147
00:06:15,240 --> 00:06:20,190
have<font color="#E5E5E5"> in this input this</font><font color="#CCCCCC"> input</font><font color="#E5E5E5"> will</font><font color="#CCCCCC"> be</font>

148
00:06:18,450 --> 00:06:22,050
rejected<font color="#E5E5E5"> from</font><font color="#CCCCCC"> the program because the</font>

149
00:06:20,190 --> 00:06:25,020
program will think<font color="#CCCCCC"> that</font><font color="#E5E5E5"> this is not</font><font color="#CCCCCC"> a</font>

150
00:06:22,050 --> 00:06:27,990
valid PNG file from these observations

151
00:06:25,020 --> 00:06:30,390
<font color="#CCCCCC">we</font><font color="#E5E5E5"> notice that there are two kinds of</font>

152
00:06:27,990 --> 00:06:32,820
<font color="#E5E5E5">critical bit positions there are bit</font>

153
00:06:30,390 --> 00:06:34,740
positions that must be flipped<font color="#E5E5E5"> in order</font>

154
00:06:32,820 --> 00:06:38,700
to trigger the crash which we call

155
00:06:34,740 --> 00:06:42,350
minimum<font color="#E5E5E5"> buggy bits</font><font color="#CCCCCC"> at and we use</font><font color="#E5E5E5"> small B</font>

156
00:06:38,700 --> 00:06:45,659
to denote<font color="#E5E5E5"> the cardinality of the</font><font color="#CCCCCC"> size</font>

157
00:06:42,350 --> 00:06:48,330
<font color="#E5E5E5">the second kinds is the bits that must</font>

158
00:06:45,660 --> 00:06:50,430
not be<font color="#E5E5E5"> flit and we are going to use</font>

159
00:06:48,330 --> 00:06:52,919
small e to denote the number<font color="#E5E5E5"> of bits</font>

160
00:06:50,430 --> 00:06:55,290
that<font color="#E5E5E5"> must not be flipped and since both</font>

161
00:06:52,919 --> 00:06:57,599
<font color="#CCCCCC">be bits and a bits are critical to</font>

162
00:06:55,290 --> 00:07:00,330
trigger the crash we are going to define

163
00:06:57,600 --> 00:07:03,419
the<font color="#CCCCCC"> number of crash critical bits D</font>

164
00:07:00,330 --> 00:07:05,969
which<font color="#E5E5E5"> is essentially P plus</font><font color="#CCCCCC"> e we also</font>

165
00:07:03,419 --> 00:07:08,789
use<font color="#CCCCCC"> an to</font><font color="#E5E5E5"> denote a total number of bit</font>

166
00:07:05,970 --> 00:07:11,639
positions of the seat and<font color="#E5E5E5"> use R</font><font color="#CCCCCC"> to</font>

167
00:07:08,790 --> 00:07:14,010
denote<font color="#E5E5E5"> the mutation ratio and in our</font>

168
00:07:11,639 --> 00:07:16,169
model<font color="#CCCCCC"> our mutation</font><font color="#E5E5E5"> of</font><font color="#CCCCCC"> buzzer will</font>

169
00:07:14,010 --> 00:07:18,800
generate<font color="#E5E5E5"> test inputs by flipping and</font>

170
00:07:16,169 --> 00:07:21,930
times<font color="#CCCCCC"> our different</font><font color="#E5E5E5"> positions from the</font><font color="#CCCCCC"> C</font>

171
00:07:18,800 --> 00:07:24,030
now using all these previous definitions

172
00:07:21,930 --> 00:07:26,220
and model we can now define the<font color="#E5E5E5"> fuzzing</font>

173
00:07:24,030 --> 00:07:28,859
efficiency which is<font color="#CCCCCC"> the</font><font color="#E5E5E5"> probability</font><font color="#CCCCCC"> of</font>

174
00:07:26,220 --> 00:07:29,250
seeing<font color="#E5E5E5"> crashing inputs from</font><font color="#CCCCCC"> mutational</font>

175
00:07:28,860 --> 00:07:31,800
fuzzy

176
00:07:29,250 --> 00:07:33,539
<font color="#CCCCCC">in fact this probability follows a</font>

177
00:07:31,800 --> 00:07:37,530
classic multivariate hypergeometric

178
00:07:33,539 --> 00:07:39,599
distribution<font color="#E5E5E5"> which essentially represent</font>

179
00:07:37,530 --> 00:07:41,909
the number of attainable<font color="#E5E5E5"> crashing inputs</font>

180
00:07:39,600 --> 00:07:45,600
divided by the<font color="#E5E5E5"> number of all</font><font color="#CCCCCC"> possible</font>

181
00:07:41,910 --> 00:07:47,250
taste test<font color="#E5E5E5"> cases now that we formulated</font>

182
00:07:45,600 --> 00:07:49,860
the fuzzing efficiency we need to

183
00:07:47,250 --> 00:07:52,260
perform<font color="#E5E5E5"> the second step which is to</font>

184
00:07:49,860 --> 00:07:56,160
<font color="#E5E5E5">represent an optimal mutation ratio with</font>

185
00:07:52,260 --> 00:07:57,990
respect<font color="#CCCCCC"> to B and D in fact</font><font color="#E5E5E5"> we can</font>

186
00:07:56,160 --> 00:08:01,169
achieve<font color="#E5E5E5"> this by modeling the problem</font>

187
00:07:57,990 --> 00:08:03,090
with NLP<font color="#CCCCCC"> non linear programming problem</font>

188
00:08:01,169 --> 00:08:05,820
where the goal<font color="#CCCCCC"> is to maximize the</font>

189
00:08:03,090 --> 00:08:09,270
fuzzing efficiency subject to some

190
00:08:05,820 --> 00:08:11,520
reality constraints<font color="#E5E5E5"> and by solving this</font>

191
00:08:09,270 --> 00:08:14,130
NLP problem we can derive<font color="#E5E5E5"> the</font><font color="#CCCCCC"> following</font>

192
00:08:11,520 --> 00:08:17,780
formula representing an optimal mutation

193
00:08:14,130 --> 00:08:21,450
ratio<font color="#E5E5E5"> R with</font><font color="#CCCCCC"> respect</font><font color="#E5E5E5"> to B T and</font><font color="#CCCCCC"> N and</font>

194
00:08:17,780 --> 00:08:26,388
since n is known<font color="#E5E5E5"> from the seed we only</font>

195
00:08:21,450 --> 00:08:28,860
need to estimate<font color="#E5E5E5"> the value</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> B and D</font>

196
00:08:26,389 --> 00:08:31,830
unfortunately<font color="#CCCCCC"> though</font><font color="#E5E5E5"> the values of B and</font>

197
00:08:28,860 --> 00:08:33,930
<font color="#E5E5E5">D are not known prior to fuzzing because</font>

198
00:08:31,830 --> 00:08:36,270
there are<font color="#E5E5E5"> specific to a bug in a</font>

199
00:08:33,929 --> 00:08:39,150
specific<font color="#E5E5E5"> program</font><font color="#CCCCCC"> so we need to somehow</font>

200
00:08:36,270 --> 00:08:42,299
<font color="#E5E5E5">estimate these</font><font color="#CCCCCC"> values from</font><font color="#E5E5E5"> the program</font>

201
00:08:39,150 --> 00:08:43,829
under<font color="#E5E5E5"> test which is the last step of our</font>

202
00:08:42,299 --> 00:08:47,339
approach we<font color="#E5E5E5"> want to estimate</font><font color="#CCCCCC"> these</font>

203
00:08:43,830 --> 00:08:51,030
<font color="#CCCCCC">values to infer a good mutation ratio</font>

204
00:08:47,339 --> 00:08:53,640
for a given program<font color="#E5E5E5"> and a seat recall</font>

205
00:08:51,030 --> 00:08:54,709
<font color="#E5E5E5">from the previous example I showed you</font>

206
00:08:53,640 --> 00:08:56,960
<font color="#CCCCCC">that</font><font color="#E5E5E5"> there are</font><font color="#CCCCCC"> two</font>

207
00:08:54,710 --> 00:08:58,880
kinds of<font color="#E5E5E5"> critical bit positions there</font>

208
00:08:56,960 --> 00:09:01,490
are bits that must be flipped<font color="#E5E5E5"> and there</font>

209
00:08:58,880 --> 00:09:03,020
are bits<font color="#E5E5E5"> that must not be flipped we</font>

210
00:09:01,490 --> 00:09:05,180
<font color="#CCCCCC">notice that there is a certain</font>

211
00:09:03,020 --> 00:09:08,210
<font color="#CCCCCC">relationship between these two</font><font color="#E5E5E5"> kinds of</font>

212
00:09:05,180 --> 00:09:11,839
bits<font color="#CCCCCC"> if we let the two kinds</font><font color="#E5E5E5"> of bits as</font>

213
00:09:08,210 --> 00:09:14,000
x and y respectively<font color="#E5E5E5"> then we know</font><font color="#CCCCCC"> that</font>

214
00:09:11,840 --> 00:09:18,380
there must<font color="#CCCCCC"> be a control flow that tracks</font>

215
00:09:14,000 --> 00:09:20,510
<font color="#E5E5E5">the value of x as follows and depending</font>

216
00:09:18,380 --> 00:09:23,840
<font color="#E5E5E5">on the values</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> x the program should</font>

217
00:09:20,510 --> 00:09:26,600
either crash or<font color="#CCCCCC"> not and since the value</font>

218
00:09:23,840 --> 00:09:28,490
of<font color="#CCCCCC"> Y</font><font color="#E5E5E5"> also affects the program crash here</font>

219
00:09:26,600 --> 00:09:32,600
there must<font color="#E5E5E5"> be another conditional that</font>

220
00:09:28,490 --> 00:09:34,900
checks<font color="#E5E5E5"> the value of y we typically say</font>

221
00:09:32,600 --> 00:09:37,400
the second conditional statement here is

222
00:09:34,900 --> 00:09:40,340
<font color="#E5E5E5">control dependent on the first</font>

223
00:09:37,400 --> 00:09:43,610
conditional statement and we and<font color="#CCCCCC"> we</font>

224
00:09:40,340 --> 00:09:45,590
generalize<font color="#CCCCCC"> this notion</font><font color="#E5E5E5"> of control</font>

225
00:09:43,610 --> 00:09:48,080
dependence<font color="#CCCCCC"> to represent the dependence</font>

226
00:09:45,590 --> 00:09:51,380
<font color="#CCCCCC">relationship between input bit positions</font>

227
00:09:48,080 --> 00:09:53,570
in this example<font color="#E5E5E5"> X is dependent on the</font>

228
00:09:51,380 --> 00:09:56,420
position<font color="#CCCCCC"> Y because the value</font><font color="#E5E5E5"> of y</font>

229
00:09:53,570 --> 00:09:59,690
determines whether the value of x will

230
00:09:56,420 --> 00:10:02,000
be read in the second<font color="#CCCCCC"> condition we call</font>

231
00:09:59,690 --> 00:10:04,910
such a relationship<font color="#CCCCCC"> as input bit</font>

232
00:10:02,000 --> 00:10:09,380
dependence and we formally<font color="#CCCCCC"> define this</font>

233
00:10:04,910 --> 00:10:11,209
concept<font color="#CCCCCC"> in</font><font color="#E5E5E5"> our paper we</font><font color="#CCCCCC"> can compute</font>

234
00:10:09,380 --> 00:10:14,540
input<font color="#E5E5E5"> bit dependence of a program</font>

235
00:10:11,210 --> 00:10:17,420
execution<font color="#E5E5E5"> using our white box analysis</font>

236
00:10:14,540 --> 00:10:20,000
as follows<font color="#E5E5E5"> first we instrument a program</font>

237
00:10:17,420 --> 00:10:23,000
execution<font color="#CCCCCC"> and for every program</font>

238
00:10:20,000 --> 00:10:26,420
<font color="#E5E5E5">expression in the execution we compute a</font>

239
00:10:23,000 --> 00:10:27,980
set of relevant<font color="#E5E5E5"> input bits and finally</font>

240
00:10:26,420 --> 00:10:30,260
for every conditional branch<font color="#E5E5E5"> that we</font>

241
00:10:27,980 --> 00:10:32,450
encounter<font color="#E5E5E5"> during the execution we</font>

242
00:10:30,260 --> 00:10:34,790
statically expand a control<font color="#E5E5E5"> flow graph</font>

243
00:10:32,450 --> 00:10:39,260
to<font color="#E5E5E5"> compute the dependence between the</font>

244
00:10:34,790 --> 00:10:41,599
input bit positions input bit dependence

245
00:10:39,260 --> 00:10:45,319
allows us to<font color="#E5E5E5"> compute</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> number of</font>

246
00:10:41,600 --> 00:10:48,800
<font color="#E5E5E5">critical bits</font><font color="#CCCCCC"> D of any bit</font><font color="#E5E5E5"> aniseed which</font>

247
00:10:45,320 --> 00:10:51,830
<font color="#E5E5E5">led us</font><font color="#CCCCCC"> to define the average value of</font>

248
00:10:48,800 --> 00:10:55,490
the over<font color="#E5E5E5"> all possible subsets of input</font>

249
00:10:51,830 --> 00:10:56,150
bits and we are going to<font color="#E5E5E5"> denote</font><font color="#CCCCCC"> it as</font><font color="#E5E5E5"> d</font>

250
00:10:55,490 --> 00:10:58,430
bar

251
00:10:56,150 --> 00:11:01,160
and notice here<font color="#CCCCCC"> that</font><font color="#E5E5E5"> we can compute this</font>

252
00:10:58,430 --> 00:11:04,370
average<font color="#E5E5E5"> d bar without even knowing the</font>

253
00:11:01,160 --> 00:11:05,719
actual<font color="#CCCCCC"> minimum doggett bit sets</font><font color="#E5E5E5"> so in</font>

254
00:11:04,370 --> 00:11:08,300
<font color="#E5E5E5">this paper we</font><font color="#CCCCCC"> use the following</font>

255
00:11:05,720 --> 00:11:08,690
heuristics that estimates the<font color="#CCCCCC"> value of</font>

256
00:11:08,300 --> 00:11:11,260
the

257
00:11:08,690 --> 00:11:14,630
with the multiplication<font color="#CCCCCC"> of average</font>

258
00:11:11,260 --> 00:11:17,990
average<font color="#CCCCCC"> D</font><font color="#E5E5E5"> bar and B this heuristic</font>

259
00:11:14,630 --> 00:11:20,630
<font color="#E5E5E5">assumes the</font><font color="#CCCCCC"> value of D linearly depends</font>

260
00:11:17,990 --> 00:11:23,600
on the value<font color="#E5E5E5"> of</font><font color="#CCCCCC"> B and</font><font color="#E5E5E5"> this allows</font><font color="#CCCCCC"> us to</font>

261
00:11:20,630 --> 00:11:26,390
<font color="#E5E5E5">simplify the</font><font color="#CCCCCC"> formula as follows and</font>

262
00:11:23,600 --> 00:11:28,490
therefore all we need to<font color="#E5E5E5"> do here is to</font>

263
00:11:26,390 --> 00:11:31,699
compute the<font color="#CCCCCC"> D bar from our</font><font color="#E5E5E5"> white box</font>

264
00:11:28,490 --> 00:11:36,080
analysis and estimate<font color="#E5E5E5"> a good mutation</font>

265
00:11:31,700 --> 00:11:39,350
ratio for a given program<font color="#E5E5E5"> and a seat to</font>

266
00:11:36,080 --> 00:11:41,510
evaluate<font color="#E5E5E5"> our system we obtained</font><font color="#CCCCCC"> 8/8</font>

267
00:11:39,350 --> 00:11:44,390
applications<font color="#E5E5E5"> from our one of our</font>

268
00:11:41,510 --> 00:11:48,460
previous works and we<font color="#E5E5E5"> fuzz these</font>

269
00:11:44,390 --> 00:11:51,410
applications for 8,000<font color="#CCCCCC"> hours of</font><font color="#E5E5E5"> CPU time</font>

270
00:11:48,460 --> 00:11:53,560
more specifically we use thousand

271
00:11:51,410 --> 00:11:57,469
different<font color="#E5E5E5"> mutation ratios ranging from</font>

272
00:11:53,560 --> 00:12:00,920
<font color="#E5E5E5">0.001 to</font><font color="#CCCCCC"> 1</font><font color="#E5E5E5"> to collect grant ground check</font>

273
00:11:57,470 --> 00:12:03,110
ground truth data<font color="#E5E5E5"> and in this paper we</font>

274
00:12:00,920 --> 00:12:06,170
report the number<font color="#CCCCCC"> of</font><font color="#E5E5E5"> bugs found after</font>

275
00:12:03,110 --> 00:12:08,240
triaging<font color="#E5E5E5"> crashes with our technique</font>

276
00:12:06,170 --> 00:12:11,990
called safe<font color="#CCCCCC"> stock cache which is similar</font>

277
00:12:08,240 --> 00:12:14,840
to the heuristic based<font color="#E5E5E5"> on stack cache</font>

278
00:12:11,990 --> 00:12:17,840
technique<font color="#E5E5E5"> for more details please</font><font color="#CCCCCC"> refer</font>

279
00:12:14,840 --> 00:12:20,810
to our paper<font color="#CCCCCC"> the collected ground truth</font>

280
00:12:17,840 --> 00:12:24,530
<font color="#E5E5E5">for the program ABC MTPs looks as</font>

281
00:12:20,810 --> 00:12:26,780
follows<font color="#E5E5E5"> the ax axis here is thousand</font>

282
00:12:24,530 --> 00:12:29,300
different<font color="#E5E5E5"> mutation ratios and y axis</font>

283
00:12:26,780 --> 00:12:31,760
here<font color="#CCCCCC"> is</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> number</font><font color="#E5E5E5"> of number of bugs</font>

284
00:12:29,300 --> 00:12:33,740
found for each different<font color="#E5E5E5"> mutation ratio</font>

285
00:12:31,760 --> 00:12:36,710
and<font color="#CCCCCC"> you can see that there is</font><font color="#E5E5E5"> a clear</font>

286
00:12:33,740 --> 00:12:40,160
trend for fuzzing efficiency depending

287
00:12:36,710 --> 00:12:42,530
on the value of mutation ratio so the

288
00:12:40,160 --> 00:12:46,760
first question<font color="#CCCCCC"> that</font><font color="#E5E5E5"> we want to answer is</font>

289
00:12:42,530 --> 00:12:49,370
how close<font color="#CCCCCC"> our mutation ratios obtained</font>

290
00:12:46,760 --> 00:12:53,660
from<font color="#CCCCCC"> senses compared to empirically</font>

291
00:12:49,370 --> 00:12:56,800
optimal mutation ratios so these graphs

292
00:12:53,660 --> 00:12:59,810
show<font color="#CCCCCC"> the comparison</font><font color="#E5E5E5"> the dashed line here</font>

293
00:12:56,800 --> 00:13:02,329
<font color="#CCCCCC">indicate</font><font color="#E5E5E5"> the ratios derived from</font>

294
00:12:59,810 --> 00:13:04,670
<font color="#CCCCCC">synthesis and the blue lines</font><font color="#E5E5E5"> here show</font>

295
00:13:02,330 --> 00:13:07,850
<font color="#E5E5E5">the ground truth for each of different</font>

296
00:13:04,670 --> 00:13:12,410
programs<font color="#CCCCCC"> as you can see the prediction</font>

297
00:13:07,850 --> 00:13:14,420
<font color="#CCCCCC">and the empirical</font><font color="#E5E5E5"> was close and this is</font>

298
00:13:12,410 --> 00:13:16,610
also<font color="#E5E5E5"> the</font><font color="#CCCCCC"> case for other programs and we</font>

299
00:13:14,420 --> 00:13:19,400
<font color="#E5E5E5">also observe</font><font color="#CCCCCC"> the similar trend in this</font>

300
00:13:16,610 --> 00:13:21,529
case as a result the<font color="#CCCCCC"> average difference</font>

301
00:13:19,400 --> 00:13:23,990
<font color="#E5E5E5">between ratios obtained by</font>

302
00:13:21,529 --> 00:13:29,899
<font color="#CCCCCC">sym first and empirical of the mole</font>

303
00:13:23,990 --> 00:13:34,579
ratio was just 0.017 now we're<font color="#E5E5E5"> going</font><font color="#CCCCCC"> to</font>

304
00:13:29,899 --> 00:13:38,959
compare our<font color="#E5E5E5"> system against BFF and ziza</font>

305
00:13:34,579 --> 00:13:41,239
<font color="#CCCCCC">which are famous</font><font color="#E5E5E5"> mutational fuzzers we</font>

306
00:13:38,959 --> 00:13:43,518
ran fuzzing for one hour<font color="#E5E5E5"> each of the</font>

307
00:13:41,240 --> 00:13:47,389
programs and computed<font color="#CCCCCC"> the</font><font color="#E5E5E5"> number</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> bugs</font>

308
00:13:43,519 --> 00:13:49,790
<font color="#CCCCCC">found</font><font color="#E5E5E5"> the red bar</font><font color="#CCCCCC"> here represents sim</font>

309
00:13:47,389 --> 00:13:52,670
<font color="#CCCCCC">fuss</font><font color="#E5E5E5"> and as you can</font><font color="#CCCCCC"> see it</font><font color="#E5E5E5"> prevails</font>

310
00:13:49,790 --> 00:13:56,660
<font color="#E5E5E5">other fuzzers in most cases in total</font>

311
00:13:52,670 --> 00:14:04,449
symphysis<font color="#E5E5E5"> find</font><font color="#CCCCCC"> 3 7.2</font><font color="#E5E5E5"> percent more bugs</font>

312
00:13:56,660 --> 00:14:04,449
<font color="#E5E5E5">than BFF and</font><font color="#CCCCCC"> 55.3% more bugs than Ziza</font>

313
00:14:05,019 --> 00:14:12,019
finally we also applied our technique to

314
00:14:08,689 --> 00:14:13,009
<font color="#CCCCCC">AFL again AFL is the</font><font color="#E5E5E5"> state of the art</font>

315
00:14:12,019 --> 00:14:17,269
mutational<font color="#E5E5E5"> fuzzer</font>

316
00:14:13,009 --> 00:14:19,879
and in order<font color="#CCCCCC"> to do this experiment we</font>

317
00:14:17,269 --> 00:14:23,240
replaced bit flipping based mutation

318
00:14:19,879 --> 00:14:26,059
algorithm of AFL<font color="#E5E5E5"> with our own algorithm</font>

319
00:14:23,240 --> 00:14:29,269
<font color="#E5E5E5">with our synthesis all our own algorithm</font>

320
00:14:26,059 --> 00:14:34,490
<font color="#CCCCCC">and ran both original AFL</font><font color="#E5E5E5"> and modified</font>

321
00:14:29,269 --> 00:14:36,319
al AFL for for 24 hours first we tested

322
00:14:34,490 --> 00:14:38,629
the code<font color="#E5E5E5"> coverage difference between</font>

323
00:14:36,319 --> 00:14:42,769
between<font color="#E5E5E5"> the two so the red line here</font>

324
00:14:38,629 --> 00:14:45,259
<font color="#E5E5E5">shows represent the modified AFL and</font><font color="#CCCCCC"> the</font>

325
00:14:42,769 --> 00:14:48,500
<font color="#E5E5E5">blue line shows</font><font color="#CCCCCC"> the coverage code</font>

326
00:14:45,259 --> 00:14:51,589
coverage for unmodified AFF and as you

327
00:14:48,500 --> 00:14:57,079
can<font color="#CCCCCC"> see the code</font><font color="#E5E5E5"> coverage of our</font>

328
00:14:51,589 --> 00:15:00,230
modified AFL was was improved compared

329
00:14:57,079 --> 00:15:02,059
<font color="#E5E5E5">to the original AFL the second</font>

330
00:15:00,230 --> 00:15:04,519
comparison that<font color="#E5E5E5"> we</font><font color="#CCCCCC"> performed is</font><font color="#E5E5E5"> the</font>

331
00:15:02,059 --> 00:15:10,189
number<font color="#CCCCCC"> of</font><font color="#E5E5E5"> bugs found for both cases and</font>

332
00:15:04,519 --> 00:15:12,889
as a result modified AFL found<font color="#CCCCCC"> 18.5%</font>

333
00:15:10,189 --> 00:15:15,290
<font color="#E5E5E5">more balls than original AFL and we</font>

334
00:15:12,889 --> 00:15:17,420
conclude that<font color="#CCCCCC"> our technique and</font><font color="#E5E5E5"> also</font>

335
00:15:15,290 --> 00:15:20,509
improve the state-of-the-art mutation of

336
00:15:17,420 --> 00:15:22,519
<font color="#E5E5E5">others there are many more</font><font color="#CCCCCC"> details that</font>

337
00:15:20,509 --> 00:15:25,040
<font color="#CCCCCC">I could not discuss duties of time limit</font>

338
00:15:22,519 --> 00:15:27,860
so please<font color="#E5E5E5"> refer to our paper if you</font><font color="#CCCCCC"> are</font>

339
00:15:25,040 --> 00:15:30,410
interested and finally we<font color="#E5E5E5"> also open our</font>

340
00:15:27,860 --> 00:15:34,009
source<font color="#CCCCCC"> code to boost future researchers</font>

341
00:15:30,410 --> 00:15:34,920
<font color="#CCCCCC">so please refer to our paper</font><font color="#E5E5E5"> for more</font>

342
00:15:34,009 --> 00:15:39,449
details

343
00:15:34,920 --> 00:15:41,699
in conclusion we showed<font color="#E5E5E5"> that</font><font color="#CCCCCC"> selecting a</font>

344
00:15:39,449 --> 00:15:45,019
good mutation ratio is crucial and

345
00:15:41,699 --> 00:15:48,118
mutational<font color="#E5E5E5"> fussing and as a result we</font>

346
00:15:45,019 --> 00:15:50,279
devised an algorithm to leverage<font color="#E5E5E5"> a white</font>

347
00:15:48,119 --> 00:15:52,439
box analysis to<font color="#E5E5E5"> estimate a good</font>

348
00:15:50,279 --> 00:15:56,279
parameter which is mutation ratio for

349
00:15:52,439 --> 00:16:00,709
black box mutation<font color="#CCCCCC"> or fussing</font><font color="#E5E5E5"> with that</font>

350
00:15:56,279 --> 00:16:00,709
thank<font color="#E5E5E5"> you</font><font color="#CCCCCC"> very much and I'm happy</font><font color="#E5E5E5"> to</font>

351
00:16:05,660 --> 00:16:12,930
so thanks a kill we have<font color="#E5E5E5"> time for a</font>

352
00:16:08,070 --> 00:16:14,910
couple questions hello<font color="#E5E5E5"> Julia</font><font color="#CCCCCC"> Vanek from</font>

353
00:16:12,930 --> 00:16:18,630
Bloomberg<font color="#CCCCCC"> um I wonder if you try to</font>

354
00:16:14,910 --> 00:16:22,260
combine you work with tormented

355
00:16:18,630 --> 00:16:25,800
<font color="#E5E5E5">exploitation my work with</font><font color="#CCCCCC"> Oh automated</font>

356
00:16:22,260 --> 00:16:27,930
exploitation for example<font color="#E5E5E5"> whether you you</font>

357
00:16:25,800 --> 00:16:30,000
know how many bugs you found were

358
00:16:27,930 --> 00:16:33,989
actually exploitable<font color="#CCCCCC"> how many were not</font>

359
00:16:30,000 --> 00:16:35,660
<font color="#E5E5E5">haunted</font><font color="#CCCCCC"> references etc that's</font><font color="#E5E5E5"> a very</font>

360
00:16:33,990 --> 00:16:40,170
<font color="#E5E5E5">good question so</font><font color="#CCCCCC"> the question was can</font>

361
00:16:35,660 --> 00:16:42,930
<font color="#E5E5E5">the I apply our automatic</font><font color="#CCCCCC"> explosive</font>

362
00:16:40,170 --> 00:16:45,900
generation technique for along<font color="#E5E5E5"> with this</font>

363
00:16:42,930 --> 00:16:49,589
line of<font color="#CCCCCC"> work actually we did not</font><font color="#E5E5E5"> try it</font>

364
00:16:45,900 --> 00:16:50,939
<font color="#E5E5E5">but it's a very</font><font color="#CCCCCC"> good idea and</font><font color="#E5E5E5"> this is</font>

365
00:16:49,590 --> 00:16:57,570
going<font color="#E5E5E5"> to</font><font color="#CCCCCC"> be a very interesting future</font>

366
00:16:50,940 --> 00:16:59,760
<font color="#E5E5E5">work I think yes hi I'm Jonas from epfl</font>

367
00:16:57,570 --> 00:17:04,020
<font color="#E5E5E5">and there's one thing I didn't</font>

368
00:16:59,760 --> 00:17:05,940
understand it and it's you seem to kind

369
00:17:04,020 --> 00:17:08,760
of throw away a<font color="#E5E5E5"> lot of the data that you</font>

370
00:17:05,940 --> 00:17:11,150
find in that<font color="#E5E5E5"> you identify all these bits</font>

371
00:17:08,760 --> 00:17:14,699
that<font color="#E5E5E5"> the father should not change and</font>

372
00:17:11,150 --> 00:17:17,160
then<font color="#E5E5E5"> you say okay</font><font color="#CCCCCC"> Allah we don't use</font>

373
00:17:14,699 --> 00:17:19,920
that<font color="#E5E5E5"> data we just like count the bits</font>

374
00:17:17,160 --> 00:17:21,449
but what would happen<font color="#CCCCCC"> if you actually</font>

375
00:17:19,920 --> 00:17:23,580
sort<font color="#E5E5E5"> of prevented the father from</font>

376
00:17:21,449 --> 00:17:29,570
changing all<font color="#E5E5E5"> these data dependent bits</font>

377
00:17:23,579 --> 00:17:33,899
and only like so I<font color="#E5E5E5"> think the question</font><font color="#CCCCCC"> is</font>

378
00:17:29,570 --> 00:17:37,830
why<font color="#CCCCCC"> why don't we try to</font><font color="#E5E5E5"> find</font><font color="#CCCCCC"> a specific</font>

379
00:17:33,900 --> 00:17:40,260
<font color="#E5E5E5">position of of a seed that we want to</font>

380
00:17:37,830 --> 00:17:42,810
modify and<font color="#E5E5E5"> we don't want to modify yes</font>

381
00:17:40,260 --> 00:17:45,060
exactly right<font color="#CCCCCC"> so I mean that's</font><font color="#E5E5E5"> a very</font>

382
00:17:42,810 --> 00:17:46,379
very<font color="#CCCCCC"> interesting question and</font><font color="#E5E5E5"> it's a</font>

383
00:17:45,060 --> 00:17:48,030
<font color="#CCCCCC">very interesting direction as</font><font color="#E5E5E5"> well and</font>

384
00:17:46,380 --> 00:17:50,690
<font color="#E5E5E5">actually if you think about it if you</font>

385
00:17:48,030 --> 00:17:53,580
<font color="#CCCCCC">think about grammar</font><font color="#E5E5E5"> based buzzing</font>

386
00:17:50,690 --> 00:17:55,470
usually people came up<font color="#CCCCCC"> with a</font><font color="#E5E5E5"> template</font>

387
00:17:53,580 --> 00:17:57,240
that<font color="#E5E5E5"> says hey we want</font><font color="#CCCCCC"> to fast this</font>

388
00:17:55,470 --> 00:18:00,870
particular part and<font color="#E5E5E5"> just the type of</font>

389
00:17:57,240 --> 00:18:03,930
<font color="#E5E5E5">this is integer</font><font color="#CCCCCC"> and this is a string and</font>

390
00:18:00,870 --> 00:18:06,209
<font color="#E5E5E5">so on and so forth</font><font color="#CCCCCC"> so automatically</font>

391
00:18:03,930 --> 00:18:07,590
finding those kind<font color="#E5E5E5"> of template is also</font>

392
00:18:06,210 --> 00:18:09,750
very interesting<font color="#E5E5E5"> research and</font>

393
00:18:07,590 --> 00:18:12,929
potentially we can extend this work to

394
00:18:09,750 --> 00:18:14,930
handle this<font color="#E5E5E5"> case but we currently we do</font>

395
00:18:12,930 --> 00:18:18,090
<font color="#E5E5E5">not handle that case our model only</font>

396
00:18:14,930 --> 00:18:22,200
<font color="#E5E5E5">consider the</font><font color="#CCCCCC"> bits flipping based</font>

397
00:18:18,090 --> 00:18:24,539
mutation strategy<font color="#E5E5E5"> okay thank you yeah</font>

398
00:18:22,200 --> 00:18:26,850
so<font color="#E5E5E5"> juan caballero from in there so what</font>

399
00:18:24,539 --> 00:18:28,799
<font color="#CCCCCC">institute so following on that that</font><font color="#E5E5E5"> you</font>

400
00:18:26,850 --> 00:18:31,139
just<font color="#E5E5E5"> answer right I mean so very</font><font color="#CCCCCC"> suit</font>

401
00:18:28,799 --> 00:18:33,720
<font color="#E5E5E5">years of research saying mutational</font>

402
00:18:31,140 --> 00:18:36,000
<font color="#CCCCCC">fasten</font><font color="#E5E5E5"> it just doesn't get get deep</font>

403
00:18:33,720 --> 00:18:37,320
<font color="#CCCCCC">enough into the</font><font color="#E5E5E5"> programs right so which</font>

404
00:18:36,000 --> 00:18:39,299
<font color="#CCCCCC">propose things</font><font color="#E5E5E5"> like grammar based</font>

405
00:18:37,320 --> 00:18:42,330
<font color="#E5E5E5">fashion right and that's actually widely</font>

406
00:18:39,299 --> 00:18:44,190
used<font color="#E5E5E5"> right we have things I can call it</font>

407
00:18:42,330 --> 00:18:46,470
fashion<font color="#CCCCCC"> but here you're only</font><font color="#E5E5E5"> comparing</font>

408
00:18:44,190 --> 00:18:47,789
light to the basic<font color="#CCCCCC"> rotational fashion</font>

409
00:18:46,470 --> 00:18:52,890
<font color="#E5E5E5">that</font><font color="#CCCCCC"> doesn't seem like a very</font><font color="#E5E5E5"> fair</font>

410
00:18:47,789 --> 00:18:55,529
comparison<font color="#CCCCCC"> tone sure</font><font color="#E5E5E5"> so well you can say</font>

411
00:18:52,890 --> 00:18:57,809
<font color="#E5E5E5">that you know grammar based is grammar</font>

412
00:18:55,529 --> 00:18:59,880
based buzzing can find more deep bugs

413
00:18:57,809 --> 00:19:03,289
than you know<font color="#CCCCCC"> bit bit flipping based</font>

414
00:18:59,880 --> 00:19:05,850
fuzzy but actually if you<font color="#CCCCCC"> look at</font><font color="#E5E5E5"> the</font>

415
00:19:03,289 --> 00:19:09,658
the<font color="#E5E5E5"> box</font><font color="#CCCCCC"> the crashes that we</font><font color="#E5E5E5"> found</font>

416
00:19:05,850 --> 00:19:14,340
<font color="#E5E5E5">actually</font><font color="#CCCCCC"> we tried all you know regular</font>

417
00:19:09,659 --> 00:19:16,679
file parsers like you know mp3 file gif

418
00:19:14,340 --> 00:19:20,730
file which doesn't<font color="#CCCCCC"> make</font><font color="#E5E5E5"> sense</font><font color="#CCCCCC"> that you</font>

419
00:19:16,679 --> 00:19:24,210
know we<font color="#CCCCCC"> have without</font><font color="#E5E5E5"> grammar based</font>

420
00:19:20,730 --> 00:19:26,610
buzzing and by just<font color="#CCCCCC"> flipping has some</font>

421
00:19:24,210 --> 00:19:28,409
bit positions how can you find crashes

422
00:19:26,610 --> 00:19:33,000
<font color="#E5E5E5">but actually that's what happened in our</font>

423
00:19:28,409 --> 00:19:36,929
<font color="#CCCCCC">dataset and applying this technique to</font>

424
00:19:33,000 --> 00:19:39,419
you know more different data set or

425
00:19:36,929 --> 00:19:40,890
large data set is going<font color="#CCCCCC"> to</font><font color="#E5E5E5"> be our</font><font color="#CCCCCC"> future</font>

426
00:19:39,419 --> 00:19:42,179
work right what is not clear<font color="#CCCCCC"> there is</font>

427
00:19:40,890 --> 00:19:43,830
<font color="#CCCCCC">that you are actually fast in any</font>

428
00:19:42,179 --> 00:19:46,289
program that<font color="#E5E5E5"> has already been like</font>

429
00:19:43,830 --> 00:19:47,610
significantly fast<font color="#E5E5E5"> right see you get a</font>

430
00:19:46,289 --> 00:19:49,320
new program you're always gonna find

431
00:19:47,610 --> 00:19:51,539
bugs<font color="#CCCCCC"> but the question is like</font><font color="#E5E5E5"> whether</font>

432
00:19:49,320 --> 00:19:53,010
you get<font color="#CCCCCC"> a</font><font color="#E5E5E5"> program and the has already</font>

433
00:19:51,539 --> 00:19:54,330
been applied<font color="#E5E5E5"> with other techniques and</font>

434
00:19:53,010 --> 00:19:56,039
something like<font color="#E5E5E5"> mutational fashion is</font>

435
00:19:54,330 --> 00:19:57,360
<font color="#E5E5E5">still gonna be able to</font><font color="#CCCCCC"> find</font><font color="#E5E5E5"> bugs that</font>

436
00:19:56,039 --> 00:20:03,929
were<font color="#CCCCCC"> them found</font><font color="#E5E5E5"> before by other</font>

437
00:19:57,360 --> 00:20:05,639
<font color="#E5E5E5">techniques so I mean it's not clear that</font>

438
00:20:03,929 --> 00:20:07,620
<font color="#E5E5E5">the programs</font><font color="#CCCCCC"> that you actually have in</font>

439
00:20:05,640 --> 00:20:09,809
<font color="#CCCCCC">your data set they've already been fast</font>

440
00:20:07,620 --> 00:20:12,899
<font color="#E5E5E5">with other non mutational</font>

441
00:20:09,809 --> 00:20:14,490
<font color="#E5E5E5">techniques right so that would actually</font>

442
00:20:12,899 --> 00:20:16,830
<font color="#E5E5E5">be very</font><font color="#CCCCCC"> good</font><font color="#E5E5E5"> you're actually able</font><font color="#CCCCCC"> to</font>

443
00:20:14,490 --> 00:20:18,990
find that you can't find new bugs<font color="#E5E5E5"> with a</font>

444
00:20:16,830 --> 00:20:20,520
simple technique on programs that

445
00:20:18,990 --> 00:20:21,809
<font color="#CCCCCC">actually you've</font><font color="#E5E5E5"> apply more complex the</font>

446
00:20:20,520 --> 00:20:23,580
<font color="#E5E5E5">next then that would definitely</font>

447
00:20:21,809 --> 00:20:28,230
<font color="#E5E5E5">demonstrate it but this programs is not</font>

448
00:20:23,580 --> 00:20:31,250
<font color="#E5E5E5">clear doc has been done I guess</font>

449
00:20:28,230 --> 00:20:31,250
<font color="#E5E5E5">okay so your cash</font>

450
00:20:32,640 --> 00:20:36,690
it's not so you're saying it's not clear

451
00:20:34,559 --> 00:20:39,330
whether this program<font color="#CCCCCC"> is representative</font>

452
00:20:36,690 --> 00:20:40,140
<font color="#E5E5E5">is that what</font><font color="#CCCCCC"> you're asking right in some</font>

453
00:20:39,330 --> 00:20:44,658
sense yes

454
00:20:40,140 --> 00:20:47,760
okay<font color="#E5E5E5"> so sure so this program is actually</font>

455
00:20:44,659 --> 00:20:49,500
as I<font color="#CCCCCC"> said we</font><font color="#E5E5E5"> obtained this set of</font>

456
00:20:47,760 --> 00:20:52,169
programs from what from one of<font color="#E5E5E5"> our</font>

457
00:20:49,500 --> 00:20:54,659
<font color="#E5E5E5">previous our work and the</font><font color="#CCCCCC"> reason why we</font>

458
00:20:52,169 --> 00:20:56,760
selected<font color="#E5E5E5"> this program is because we know</font>

459
00:20:54,659 --> 00:20:58,710
<font color="#CCCCCC">that we can crush this program and we</font>

460
00:20:56,760 --> 00:21:02,279
<font color="#CCCCCC">can collect</font><font color="#E5E5E5"> the ground truth data and</font>

461
00:20:58,710 --> 00:21:05,940
that was a main<font color="#E5E5E5"> reason why we</font><font color="#CCCCCC"> chose this</font>

462
00:21:02,279 --> 00:21:08,070
program<font color="#E5E5E5"> and for that for</font><font color="#CCCCCC"> that reason</font><font color="#E5E5E5"> we</font>

463
00:21:05,940 --> 00:21:11,549
<font color="#E5E5E5">actually opened our source</font><font color="#CCCCCC"> code and data</font>

464
00:21:08,070 --> 00:21:14,870
set for further research<font color="#E5E5E5"> so people can</font>

465
00:21:11,549 --> 00:21:17,908
you<font color="#CCCCCC"> know use our data set and code</font><font color="#E5E5E5"> to</font>

466
00:21:14,870 --> 00:21:19,979
apply this<font color="#E5E5E5"> technique for other programs</font>

467
00:21:17,909 --> 00:21:22,190
as well okay thank you thanks uncle

468
00:21:19,980 --> 00:21:22,190
again

