1
00:00:00,000 --> 00:00:05,040
thank you welcome um this is work that

2
00:00:03,090 --> 00:00:06,600
was done collaboration with my wonderful

3
00:00:05,040 --> 00:00:10,820
collaborators Christopher Liebchen

4
00:00:06,600 --> 00:00:13,889
andreja<font color="#CCCCCC"> masuku</font><font color="#E5E5E5"> Lucas</font><font color="#CCCCCC"> toffee pair</font><font color="#E5E5E5"> Larson</font>

5
00:00:10,820 --> 00:00:16,230
<font color="#CCCCCC">adres edit sadeghi Stefan</font><font color="#E5E5E5"> brune dollar</font>

6
00:00:13,889 --> 00:00:19,980
and Michael Franz both from tu<font color="#CCCCCC"> Darmstadt</font>

7
00:00:16,230 --> 00:00:21,570
and UC Irvine my institution so first of

8
00:00:19,980 --> 00:00:24,390
<font color="#E5E5E5">all why do we need to listen to another</font>

9
00:00:21,570 --> 00:00:26,539
talk on code randomization targeting

10
00:00:24,390 --> 00:00:29,130
defending against code reuse attacks

11
00:00:26,539 --> 00:00:31,080
well it turns<font color="#CCCCCC"> out that the existing</font>

12
00:00:29,130 --> 00:00:34,050
solutions don't entirely meet the goals

13
00:00:31,080 --> 00:00:36,449
that we set out for this project we of

14
00:00:34,050 --> 00:00:38,040
course want something that is secure we

15
00:00:36,450 --> 00:00:40,530
want to protect<font color="#E5E5E5"> prevent code reuse</font>

16
00:00:38,040 --> 00:00:42,360
attacks such as the return orange in

17
00:00:40,530 --> 00:00:44,670
programming attack or jump oriented

18
00:00:42,360 --> 00:00:48,030
programming however we also want to

19
00:00:44,670 --> 00:00:49,890
prevent state-of-the-art<font color="#CCCCCC"> wrap attacks</font>

20
00:00:48,030 --> 00:00:52,379
using memory disclosure such as the

21
00:00:49,890 --> 00:00:54,570
jatropha<font color="#CCCCCC"> tak from</font><font color="#E5E5E5"> two years ago these</font>

22
00:00:52,379 --> 00:00:57,269
attacks allow the attacker to

23
00:00:54,570 --> 00:00:59,730
arbitrarily disclose memory<font color="#CCCCCC"> after it has</font>

24
00:00:57,270 --> 00:01:03,270
been randomized and thus bypass most

25
00:00:59,730 --> 00:01:05,518
existing code randomization we also want

26
00:01:03,270 --> 00:01:07,500
a system that is comprehensive we want

27
00:01:05,519 --> 00:01:09,510
to protect<font color="#E5E5E5"> the entire application both</font>

28
00:01:07,500 --> 00:01:11,520
all<font color="#E5E5E5"> ahead of time compiled code is any</font>

29
00:01:09,510 --> 00:01:14,180
as well as any dynamically generated

30
00:01:11,520 --> 00:01:16,860
code we want to protect<font color="#E5E5E5"> real browsers</font>

31
00:01:14,180 --> 00:01:18,390
these memory disclosure attacks target

32
00:01:16,860 --> 00:01:20,850
browsers primarily where we have a

33
00:01:18,390 --> 00:01:23,130
scripting context and thus we want

34
00:01:20,850 --> 00:01:24,720
<font color="#E5E5E5">something that can</font><font color="#CCCCCC"> protect a real world</font>

35
00:01:23,130 --> 00:01:27,390
state-of-the-art browser that you all

36
00:01:24,720 --> 00:01:29,009
use and of course<font color="#E5E5E5"> we want something in</font>

37
00:01:27,390 --> 00:01:31,950
as<font color="#E5E5E5"> fast no one's going to use our</font>

38
00:01:29,009 --> 00:01:33,420
techniques and less there fast enough<font color="#E5E5E5"> so</font>

39
00:01:31,950 --> 00:01:36,150
just a<font color="#CCCCCC"> little bit of background on the</font>

40
00:01:33,420 --> 00:01:37,920
assumptions that<font color="#E5E5E5"> we make we assume that</font>

41
00:01:36,150 --> 00:01:41,009
<font color="#E5E5E5">there's a couple defenses in place that</font>

42
00:01:37,920 --> 00:01:44,640
are widely used<font color="#E5E5E5"> in practice first of all</font>

43
00:01:41,009 --> 00:01:47,939
we assume that<font color="#CCCCCC"> we have DEP or writable</font><font color="#E5E5E5"> X</font>

44
00:01:44,640 --> 00:01:50,159
or executable memory this this prevents

45
00:01:47,939 --> 00:01:52,829
the attacker from injecting malicious

46
00:01:50,159 --> 00:01:56,189
code into<font color="#CCCCCC"> the pro into the program</font>

47
00:01:52,829 --> 00:02:00,689
address space to run as good second we

48
00:01:56,189 --> 00:02:03,029
assume<font color="#CCCCCC"> that a SLR is in place a SLR maps</font>

49
00:02:00,689 --> 00:02:05,490
each program segment at a randomized

50
00:02:03,030 --> 00:02:08,068
base offset but as we'll see in a<font color="#CCCCCC"> few</font>

51
00:02:05,490 --> 00:02:12,319
moments this is by no means enough<font color="#CCCCCC"> to</font>

52
00:02:08,068 --> 00:02:14,459
prevent code reuse attacks secondly we

53
00:02:12,319 --> 00:02:16,440
assume a very advanced

54
00:02:14,460 --> 00:02:18,450
<font color="#E5E5E5">her model we assume an attack model</font>

55
00:02:16,440 --> 00:02:20,579
where the attacker can disclose and read

56
00:02:18,450 --> 00:02:23,310
any readable memory in the<font color="#E5E5E5"> program</font>

57
00:02:20,580 --> 00:02:25,290
address space the attacker can write to

58
00:02:23,310 --> 00:02:28,080
any data locations that are writable by

59
00:02:25,290 --> 00:02:30,120
the program and we<font color="#E5E5E5"> assume the attacker</font>

60
00:02:28,080 --> 00:02:32,940
has the ability to perform arbitrary

61
00:02:30,120 --> 00:02:37,460
computation<font color="#E5E5E5"> on the target for example</font>

62
00:02:32,940 --> 00:02:41,280
with javascript in the browser context

63
00:02:37,460 --> 00:02:44,070
so let's give a brief history<font color="#CCCCCC"> of how</font>

64
00:02:41,280 --> 00:02:46,860
have memory disclosure attacks and code

65
00:02:44,070 --> 00:02:49,200
rias attacks<font color="#E5E5E5"> evolved first of all to</font>

66
00:02:46,860 --> 00:02:52,290
bypass a SLR attackers started

67
00:02:49,200 --> 00:02:54,540
disclosing a single code pointer so

68
00:02:52,290 --> 00:02:56,670
since SLR<font color="#CCCCCC"> only randomizes the base</font>

69
00:02:54,540 --> 00:02:58,980
<font color="#E5E5E5">address of the program the</font><font color="#CCCCCC"> attacker</font>

70
00:02:56,670 --> 00:03:01,559
needs to disclose a single code pointer

71
00:02:58,980 --> 00:03:05,280
in the program<font color="#E5E5E5"> and then can relocate the</font>

72
00:03:01,560 --> 00:03:07,730
return oriented programming attack to

73
00:03:05,280 --> 00:03:10,650
adjust<font color="#CCCCCC"> for this randomized base offset</font>

74
00:03:07,730 --> 00:03:12,679
we can prevent this and from proposed in

75
00:03:10,650 --> 00:03:15,240
many different works by using

76
00:03:12,680 --> 00:03:17,430
<font color="#CCCCCC">fine-grained randomization so the</font>

77
00:03:15,240 --> 00:03:19,710
problem<font color="#E5E5E5"> with</font><font color="#CCCCCC"> the SLR is</font><font color="#E5E5E5"> its randomizing</font>

78
00:03:17,430 --> 00:03:22,410
<font color="#CCCCCC">at a very coarse grain granularity the</font>

79
00:03:19,710 --> 00:03:23,880
entire program code segment if we

80
00:03:22,410 --> 00:03:26,130
instead randomized at a finer

81
00:03:23,880 --> 00:03:28,590
granularity say function or basic block

82
00:03:26,130 --> 00:03:30,990
or even the instruction level we can

83
00:03:28,590 --> 00:03:36,240
prevent disclosure of a single pointer

84
00:03:30,990 --> 00:03:38,370
from bypassing our defenses well<font color="#E5E5E5"> to to</font>

85
00:03:36,240 --> 00:03:43,110
mitigate or to get around this this

86
00:03:38,370 --> 00:03:46,140
defense snow at all proposed get<font color="#E5E5E5"> robbed</font>

87
00:03:43,110 --> 00:03:49,500
which uses direct what we term direct

88
00:03:46,140 --> 00:03:51,839
code disclosure the attack reads the

89
00:03:49,500 --> 00:03:54,510
application code after<font color="#CCCCCC"> it has been</font>

90
00:03:51,840 --> 00:03:57,030
randomized and then builds a<font color="#CCCCCC"> wrap attack</font>

91
00:03:54,510 --> 00:04:00,660
on the fly to target this specifically

92
00:03:57,030 --> 00:04:02,400
randomized version turns out<font color="#E5E5E5"> there's a</font>

93
00:04:00,660 --> 00:04:06,270
very nice conceptual way to prevent this

94
00:04:02,400 --> 00:04:07,590
prevent reads to code pages normally the

95
00:04:06,270 --> 00:04:10,170
program doesn't need to read its own

96
00:04:07,590 --> 00:04:13,200
code and so if<font color="#E5E5E5"> we can enforce execute</font>

97
00:04:10,170 --> 00:04:14,760
only memory we can prevent a<font color="#CCCCCC"> JIT Rob</font>

98
00:04:13,200 --> 00:04:16,709
style memory disclosure where the

99
00:04:14,760 --> 00:04:20,880
attacker discloses<font color="#E5E5E5"> the code pages</font>

100
00:04:16,709 --> 00:04:23,940
directly however this isn't the end of

101
00:04:20,880 --> 00:04:26,400
<font color="#E5E5E5">the story there's still code pointers in</font>

102
00:04:23,940 --> 00:04:27,780
readable data that point into this

103
00:04:26,400 --> 00:04:29,760
execute only memory

104
00:04:27,780 --> 00:04:32,099
so if we<font color="#E5E5E5"> have execute only memory the</font>

105
00:04:29,760 --> 00:04:35,039
attacker can still derive some

106
00:04:32,100 --> 00:04:37,080
information<font color="#CCCCCC"> about the code layout that</font>

107
00:04:35,040 --> 00:04:39,480
<font color="#E5E5E5">has been randomized we call this</font><font color="#CCCCCC"> the</font>

108
00:04:37,080 --> 00:04:41,430
indirect code disclosure and it was

109
00:04:39,480 --> 00:04:44,040
shown the<font color="#CCCCCC"> ISO meron the attack style</font>

110
00:04:41,430 --> 00:04:46,130
part of<font color="#E5E5E5"> iso marron from ndss this year</font>

111
00:04:44,040 --> 00:04:48,270
<font color="#CCCCCC">I'll talk a little bit more</font><font color="#E5E5E5"> about</font>

112
00:04:46,130 --> 00:04:50,820
indirect<font color="#E5E5E5"> Co disclosure in a moment as</font>

113
00:04:48,270 --> 00:04:52,229
well as our novel defense against

114
00:04:50,820 --> 00:04:55,139
indirect code disclosure which we term

115
00:04:52,230 --> 00:04:57,060
code pointer hiding briefly we transform

116
00:04:55,139 --> 00:04:58,919
code pointers to make them opaque to the

117
00:04:57,060 --> 00:05:01,710
attacker so the attacker gains no

118
00:04:58,919 --> 00:05:05,460
knowledge of the real program layout

119
00:05:01,710 --> 00:05:07,049
from code pointers to summarize<font color="#E5E5E5"> we have</font>

120
00:05:05,460 --> 00:05:09,210
two types<font color="#E5E5E5"> of memory disclosure we want</font>

121
00:05:07,050 --> 00:05:10,860
to prevent direct code disclosure where

122
00:05:09,210 --> 00:05:13,020
we read<font color="#CCCCCC"> the code pages directly an</font>

123
00:05:10,860 --> 00:05:14,880
indirect code disclosure where the

124
00:05:13,020 --> 00:05:17,960
attacker gains some knowledge about the

125
00:05:14,880 --> 00:05:20,159
code layout from readable code pointers

126
00:05:17,960 --> 00:05:22,500
first how do we prevent directo

127
00:05:20,160 --> 00:05:24,360
disclosure as I said<font color="#E5E5E5"> execute only memory</font>

128
00:05:22,500 --> 00:05:26,460
does a great job of this there's been

129
00:05:24,360 --> 00:05:28,500
two previous implementations but they

130
00:05:26,460 --> 00:05:31,680
don't entirely meet our goals so we have

131
00:05:28,500 --> 00:05:33,840
a new system to fully enforce execute

132
00:05:31,680 --> 00:05:37,710
only memory permissions on current

133
00:05:33,840 --> 00:05:40,500
state-of-the-art x86 hardware to do<font color="#E5E5E5"> this</font>

134
00:05:37,710 --> 00:05:43,979
we need<font color="#CCCCCC"> to</font><font color="#E5E5E5"> back up a little bit and look</font>

135
00:05:40,500 --> 00:05:45,780
at how virtual addresses are protected

136
00:05:43,979 --> 00:05:48,270
<font color="#E5E5E5">and translated to physical memory</font>

137
00:05:45,780 --> 00:05:51,539
addresses this is normally done through

138
00:05:48,270 --> 00:05:53,250
the<font color="#E5E5E5"> page table in x86 we have a page</font>

139
00:05:51,539 --> 00:05:55,469
table that translates virtual<font color="#E5E5E5"> addresses</font>

140
00:05:53,250 --> 00:05:58,020
to physical addresses and implements

141
00:05:55,470 --> 00:06:00,900
memory protections so we can implement

142
00:05:58,020 --> 00:06:03,599
the non-executable protection so<font color="#CCCCCC"> that</font>

143
00:06:00,900 --> 00:06:06,810
data a pages are not executable however

144
00:06:03,600 --> 00:06:09,240
on<font color="#CCCCCC"> intel execute implies a read</font>

145
00:06:06,810 --> 00:06:11,760
permission so we can't have separate

146
00:06:09,240 --> 00:06:13,919
control over read and execute so that we

147
00:06:11,760 --> 00:06:17,219
get execute only memory that<font color="#E5E5E5"> is not</font>

148
00:06:13,919 --> 00:06:19,080
readable however taking a look closer

149
00:06:17,220 --> 00:06:21,150
look<font color="#E5E5E5"> into the anthill manual we</font>

150
00:06:19,080 --> 00:06:23,729
discovered that<font color="#CCCCCC"> a virtual Vic station</font>

151
00:06:21,150 --> 00:06:26,219
virtualization extension the extended

152
00:06:23,729 --> 00:06:28,800
page tables actually allows us to

153
00:06:26,220 --> 00:06:31,770
independently control the read bit for a

154
00:06:28,800 --> 00:06:33,060
page and the execute bit it turns out

155
00:06:31,770 --> 00:06:36,479
that they implemented this is part of

156
00:06:33,060 --> 00:06:39,330
the<font color="#CCCCCC"> vmx extensions and what the</font>

157
00:06:36,479 --> 00:06:41,400
processor enforces in hardware for

158
00:06:39,330 --> 00:06:44,310
memory pages is actually the inner side

159
00:06:41,400 --> 00:06:47,698
of the page table permissions and the

160
00:06:44,310 --> 00:06:50,400
extended page table permissions thus by

161
00:06:47,699 --> 00:06:53,340
setting the execute flag in the extended

162
00:06:50,400 --> 00:06:55,229
page table and not the read flag we can

163
00:06:53,340 --> 00:06:59,130
get these green code pages that the

164
00:06:55,229 --> 00:07:01,440
attacker is able to execute but cannot

165
00:06:59,130 --> 00:07:02,850
read this is what we want we want<font color="#E5E5E5"> the</font>

166
00:07:01,440 --> 00:07:04,800
program<font color="#CCCCCC"> to be able</font><font color="#E5E5E5"> to execute its own</font>

167
00:07:02,850 --> 00:07:07,500
code we<font color="#E5E5E5"> don't want the program</font><font color="#CCCCCC"> to be</font>

168
00:07:04,800 --> 00:07:10,500
able<font color="#E5E5E5"> to read its own code we don't</font>

169
00:07:07,500 --> 00:07:14,789
<font color="#E5E5E5">modify data pages at all they're simply</font>

170
00:07:10,500 --> 00:07:16,710
left to read<font color="#E5E5E5"> right as normal so</font><font color="#CCCCCC"> on to</font>

171
00:07:14,789 --> 00:07:18,479
the second type<font color="#CCCCCC"> of memory disclosure the</font>

172
00:07:16,710 --> 00:07:21,120
indirect disclosure attack now why is

173
00:07:18,479 --> 00:07:22,740
this dangerous so the attacker can read

174
00:07:21,120 --> 00:07:25,020
code pointers that<font color="#CCCCCC"> are located in</font>

175
00:07:22,740 --> 00:07:28,080
readable memory now let's assume that<font color="#E5E5E5"> we</font>

176
00:07:25,020 --> 00:07:30,150
<font color="#CCCCCC">have a somewhat medium ish grained</font>

177
00:07:28,080 --> 00:07:33,539
randomization let's say we<font color="#E5E5E5"> permute the</font>

178
00:07:30,150 --> 00:07:35,310
order of functions in<font color="#CCCCCC"> the program this</font>

179
00:07:33,539 --> 00:07:37,800
is a<font color="#E5E5E5"> very efficient way we can also</font>

180
00:07:35,310 --> 00:07:39,270
permute the order of pages so<font color="#CCCCCC"> that we</font>

181
00:07:37,800 --> 00:07:43,830
get memory sharing still this has<font color="#E5E5E5"> been</font>

182
00:07:39,270 --> 00:07:45,359
demonstrated<font color="#E5E5E5"> previously but it means</font>

183
00:07:43,830 --> 00:07:48,030
that<font color="#E5E5E5"> the indirect disclosure attack is</font>

184
00:07:45,360 --> 00:07:50,820
actually very malicious what the

185
00:07:48,030 --> 00:07:53,099
attacker could do is by<font color="#E5E5E5"> reading code</font>

186
00:07:50,820 --> 00:07:55,710
pointers into<font color="#CCCCCC"> these functions he can</font>

187
00:07:53,099 --> 00:07:57,630
then disclose the contents of individual

188
00:07:55,710 --> 00:08:00,330
functions since we don't<font color="#E5E5E5"> randomize</font>

189
00:07:57,630 --> 00:08:03,479
inside the function the attacker can

190
00:08:00,330 --> 00:08:06,300
then reuse any gadgets inside a<font color="#CCCCCC"> function</font>

191
00:08:03,479 --> 00:08:09,139
that<font color="#E5E5E5"> he has a code pointer to as the</font>

192
00:08:06,300 --> 00:08:11,699
<font color="#E5E5E5">co-op attack from just before showed</font>

193
00:08:09,139 --> 00:08:13,620
there's lots<font color="#E5E5E5"> of code pointers sitting</font>

194
00:08:11,699 --> 00:08:15,780
around in data that the attacker can

195
00:08:13,620 --> 00:08:17,940
read so we need to protect<font color="#E5E5E5"> these code</font>

196
00:08:15,780 --> 00:08:20,820
pointers from giving the attacker access

197
00:08:17,940 --> 00:08:24,479
to the gadget locations inside these

198
00:08:20,820 --> 00:08:27,060
functions that we randomized we do this

199
00:08:24,479 --> 00:08:29,729
with a technique we call code pointer

200
00:08:27,060 --> 00:08:31,919
hiding now we reached into the<font color="#E5E5E5"> bag of</font>

201
00:08:29,729 --> 00:08:35,338
computer science tricks and pulled out

202
00:08:31,919 --> 00:08:38,699
add a layer of indirection we simply

203
00:08:35,339 --> 00:08:42,110
rewrite all code pointers<font color="#CCCCCC"> that point to</font>

204
00:08:38,700 --> 00:08:45,480
executable pages through what we call

205
00:08:42,110 --> 00:08:48,240
trampolines now these trampolines are

206
00:08:45,480 --> 00:08:50,430
simply direct jumps to the original

207
00:08:48,240 --> 00:08:52,709
destination so we can take function

208
00:08:50,430 --> 00:08:55,170
pointers and point them to a trampoline

209
00:08:52,709 --> 00:08:57,510
that then jumps to the original function

210
00:08:55,170 --> 00:09:00,029
we take return addresses and point them

211
00:08:57,510 --> 00:09:03,870
to a trampoline<font color="#CCCCCC"> the points that jumps to</font>

212
00:09:00,029 --> 00:09:05,250
the original call site however<font color="#CCCCCC"> the</font>

213
00:09:03,870 --> 00:09:07,709
important thing to<font color="#E5E5E5"> note</font><font color="#CCCCCC"> about these</font>

214
00:09:05,250 --> 00:09:09,480
trampolines is that we can store them in

215
00:09:07,709 --> 00:09:11,819
execute only memories so the attacker

216
00:09:09,480 --> 00:09:14,639
can't disclose the real target address

217
00:09:11,820 --> 00:09:17,220
he reads the function pointer sees only

218
00:09:14,639 --> 00:09:19,170
a trampoline address we can randomize

219
00:09:17,220 --> 00:09:20,639
the trampolines independently so we can

220
00:09:19,170 --> 00:09:22,620
permute the order of all the trampolines

221
00:09:20,639 --> 00:09:25,050
in the program and thus<font color="#E5E5E5"> the attacker</font>

222
00:09:22,620 --> 00:09:27,990
gains no information from a code pointer

223
00:09:25,050 --> 00:09:29,849
about the real target of that code

224
00:09:27,990 --> 00:09:32,100
pointer now it's important to<font color="#E5E5E5"> note</font><font color="#CCCCCC"> that</font>

225
00:09:29,850 --> 00:09:33,810
the attacker can still execute these

226
00:09:32,100 --> 00:09:35,070
code pointers we have to allow this

227
00:09:33,810 --> 00:09:36,268
because<font color="#E5E5E5"> this</font><font color="#CCCCCC"> is the correct</font>

228
00:09:35,070 --> 00:09:37,769
functionality for the<font color="#CCCCCC"> program the</font>

229
00:09:36,269 --> 00:09:40,529
<font color="#E5E5E5">program needs to be</font><font color="#CCCCCC"> able to dereference</font>

230
00:09:37,769 --> 00:09:42,029
and execute a function pointer but it

231
00:09:40,529 --> 00:09:43,560
<font color="#E5E5E5">doesn't need to be able to read</font><font color="#CCCCCC"> the</font>

232
00:09:42,029 --> 00:09:46,439
destination<font color="#E5E5E5"> of the function pointer in</font>

233
00:09:43,560 --> 00:09:48,899
order<font color="#CCCCCC"> to do so we have some extra</font>

234
00:09:46,440 --> 00:09:53,010
mitigations to prevent reuse of

235
00:09:48,899 --> 00:09:55,079
trampolines as well so summing up we

236
00:09:53,010 --> 00:09:57,630
<font color="#CCCCCC">introduced execute only memory and we</font>

237
00:09:55,079 --> 00:10:00,569
<font color="#E5E5E5">introduce code pointer hiding how do we</font>

238
00:09:57,630 --> 00:10:03,630
do this well we modified the<font color="#CCCCCC"> lvm</font>

239
00:10:00,570 --> 00:10:06,060
compiler infrastructure to do three

240
00:10:03,630 --> 00:10:09,540
<font color="#CCCCCC">things really we needed to separate code</font>

241
00:10:06,060 --> 00:10:11,819
from data so if we embed readable data

242
00:10:09,540 --> 00:10:13,769
into code pages this works on legacy

243
00:10:11,820 --> 00:10:15,839
hardware on legacy x86 hardware of

244
00:10:13,769 --> 00:10:17,550
course but<font color="#E5E5E5"> we need to prevent the</font>

245
00:10:15,839 --> 00:10:19,380
compiler from doing this so we simply

246
00:10:17,550 --> 00:10:23,519
make sure the compiler never omits data

247
00:10:19,380 --> 00:10:25,769
into a code page easy<font color="#E5E5E5"> enough then we use</font>

248
00:10:23,519 --> 00:10:27,750
<font color="#CCCCCC">the compiler to them you perform</font>

249
00:10:25,769 --> 00:10:29,370
fine-grain randomization in our

250
00:10:27,750 --> 00:10:33,000
<font color="#CCCCCC">implementation we used function</font>

251
00:10:29,370 --> 00:10:35,040
reordering so we randomize the ordering

252
00:10:33,000 --> 00:10:37,740
of the<font color="#E5E5E5"> functions in the program we also</font>

253
00:10:35,040 --> 00:10:40,860
perform register allocation and stacks

254
00:10:37,740 --> 00:10:42,500
save slot read randomization you can

255
00:10:40,860 --> 00:10:44,640
find the details<font color="#E5E5E5"> for these in the paper</font>

256
00:10:42,500 --> 00:10:46,829
but<font color="#CCCCCC"> it's important</font><font color="#E5E5E5"> to note that our</font>

257
00:10:44,640 --> 00:10:48,120
techniques are not<font color="#E5E5E5"> married to these</font>

258
00:10:46,829 --> 00:10:50,550
particular<font color="#E5E5E5"> fine grained code</font>

259
00:10:48,120 --> 00:10:52,019
randomizations we just depend on some

260
00:10:50,550 --> 00:10:54,750
fine grain randomization<font color="#E5E5E5"> and we</font>

261
00:10:52,019 --> 00:10:56,220
evaluated with these and finally we

262
00:10:54,750 --> 00:11:00,089
implement code pointer hiding in the

263
00:10:56,220 --> 00:11:03,149
elephant compiler we rewrite all code

264
00:11:00,089 --> 00:11:06,420
pointer address assignments so

265
00:11:03,149 --> 00:11:08,760
assignments to code assignments to code

266
00:11:06,420 --> 00:11:11,490
addresses<font color="#E5E5E5"> into pointers to then</font>

267
00:11:08,760 --> 00:11:15,689
two instead point two trampolines these

268
00:11:11,490 --> 00:11:18,090
direct jumps at<font color="#E5E5E5"> runtime we take what we</font>

269
00:11:15,690 --> 00:11:20,280
call a redacted program a redacted

270
00:11:18,090 --> 00:11:23,480
application that we compiled using our

271
00:11:20,280 --> 00:11:26,490
modified compiler and we implement

272
00:11:23,480 --> 00:11:28,740
<font color="#E5E5E5">execute only memory and hardware now as</font>

273
00:11:26,490 --> 00:11:30,960
I mentioned we<font color="#CCCCCC"> need the extended page</font>

274
00:11:28,740 --> 00:11:33,390
table virtualization<font color="#E5E5E5"> feature to</font>

275
00:11:30,960 --> 00:11:36,720
implement<font color="#E5E5E5"> execute only memory on current</font>

276
00:11:33,390 --> 00:11:39,600
Intel systems to do this we implemented

277
00:11:36,720 --> 00:11:42,270
a extremely<font color="#E5E5E5"> thin hypervisor that only</font>

278
00:11:39,600 --> 00:11:45,480
enables the<font color="#CCCCCC"> epd feature and sets up and</font>

279
00:11:42,270 --> 00:11:48,000
execute only memory it simply passes

280
00:11:45,480 --> 00:11:49,530
through all other information from the

281
00:11:48,000 --> 00:11:52,770
operating system on to the physical

282
00:11:49,530 --> 00:11:55,890
hardware we also wrote a Linux kernel

283
00:11:52,770 --> 00:11:58,290
driver to interact with<font color="#E5E5E5"> the existing</font>

284
00:11:55,890 --> 00:12:01,050
<font color="#E5E5E5">page tables and the extended page tables</font>

285
00:11:58,290 --> 00:12:03,209
in order to when an application requests

286
00:12:01,050 --> 00:12:05,280
a page we map with execute only

287
00:12:03,210 --> 00:12:08,280
permissions it actually<font color="#CCCCCC"> gets executed</font>

288
00:12:05,280 --> 00:12:10,439
only permissions we interact fully with

289
00:12:08,280 --> 00:12:11,939
legacy applications if the legacy

290
00:12:10,440 --> 00:12:15,060
application was not compiled with our

291
00:12:11,940 --> 00:12:16,680
redactor compiler it will request read

292
00:12:15,060 --> 00:12:21,599
and execute permissions for its code

293
00:12:16,680 --> 00:12:24,000
<font color="#E5E5E5">segment and we allow this as normal we</font>

294
00:12:21,600 --> 00:12:26,220
also wanted a comprehensive<font color="#CCCCCC"> solution in</font>

295
00:12:24,000 --> 00:12:28,500
the beginning<font color="#E5E5E5"> I mentioned</font><font color="#CCCCCC"> that we target</font>

296
00:12:26,220 --> 00:12:30,720
browsers the JIT<font color="#E5E5E5"> Rob attack targets</font>

297
00:12:28,500 --> 00:12:34,290
browsers and what do browsers do

298
00:12:30,720 --> 00:12:37,110
browsers implement<font color="#CCCCCC"> JavaScript all major</font>

299
00:12:34,290 --> 00:12:39,569
browser vendors implement<font color="#CCCCCC"> javascript by</font>

300
00:12:37,110 --> 00:12:42,000
using a JIT compiler what<font color="#E5E5E5"> this does is</font>

301
00:12:39,570 --> 00:12:44,730
it<font color="#E5E5E5"> takes high level JavaScript code and</font>

302
00:12:42,000 --> 00:12:48,350
at runtime generates native machine code

303
00:12:44,730 --> 00:12:51,120
to implement this<font color="#CCCCCC"> JavaScript semantics</font>

304
00:12:48,350 --> 00:12:53,520
these these compilers present some

305
00:12:51,120 --> 00:12:56,250
unique challenges when we want<font color="#E5E5E5"> to use</font>

306
00:12:53,520 --> 00:12:59,010
execute only memory since they they

307
00:12:56,250 --> 00:13:00,630
don't normally<font color="#E5E5E5"> emit code in fact they</font>

308
00:12:59,010 --> 00:13:04,020
usually emit code that's read write and

309
00:13:00,630 --> 00:13:06,870
execute so this is<font color="#CCCCCC"> a problem</font><font color="#E5E5E5"> the JIT</font>

310
00:13:04,020 --> 00:13:09,210
compiler in our case v8 assumes mutable

311
00:13:06,870 --> 00:13:11,670
code it needs to be able<font color="#E5E5E5"> to change the</font>

312
00:13:09,210 --> 00:13:13,650
code frequently however we really don't

313
00:13:11,670 --> 00:13:15,150
want the code to<font color="#CCCCCC"> be</font><font color="#E5E5E5"> mapped as both</font>

314
00:13:13,650 --> 00:13:16,500
readable and executable and<font color="#E5E5E5"> we</font>

315
00:13:15,150 --> 00:13:19,319
definitely<font color="#CCCCCC"> don't want</font><font color="#E5E5E5"> to be mapped</font>

316
00:13:16,500 --> 00:13:21,720
writable and executable so we solve this

317
00:13:19,320 --> 00:13:22,590
by actually alternating usage between a

318
00:13:21,720 --> 00:13:25,110
mutable mapping

319
00:13:22,590 --> 00:13:27,290
<font color="#CCCCCC">and it executes only mapping when the</font>

320
00:13:25,110 --> 00:13:30,690
trick compiler needs treated pages data

321
00:13:27,290 --> 00:13:32,819
we map it read write and when it needs

322
00:13:30,690 --> 00:13:34,920
to<font color="#CCCCCC"> create a page is code we remap it as</font>

323
00:13:32,820 --> 00:13:37,140
execute only you can see the details in

324
00:13:34,920 --> 00:13:39,599
this for<font color="#E5E5E5"> this in the paper we actually</font>

325
00:13:37,140 --> 00:13:42,840
<font color="#CCCCCC">were able to do this very efficiently by</font>

326
00:13:39,600 --> 00:13:45,810
actually having to EPT mappings a legacy

327
00:13:42,840 --> 00:13:47,730
mapping that allows read write and

328
00:13:45,810 --> 00:13:50,160
execute only mapping and we can switch

329
00:13:47,730 --> 00:13:51,840
between these two efficiently you can

330
00:13:50,160 --> 00:13:54,810
also see the paper for<font color="#E5E5E5"> more details on</font>

331
00:13:51,840 --> 00:13:56,610
other challenges that we<font color="#E5E5E5"> ran into when</font>

332
00:13:54,810 --> 00:13:59,430
implementing JIT support so we actually

333
00:13:56,610 --> 00:14:02,700
modified the v8 JavaScript JIT in<font color="#CCCCCC"> chrome</font>

334
00:13:59,430 --> 00:14:06,689
in order to<font color="#CCCCCC"> support execute only memory</font>

335
00:14:02,700 --> 00:14:09,150
fully so of course as all good system

336
00:14:06,690 --> 00:14:10,680
security researchers must must do we

337
00:14:09,150 --> 00:14:14,160
need<font color="#E5E5E5"> to evaluate the performance of</font><font color="#CCCCCC"> our</font>

338
00:14:10,680 --> 00:14:15,989
system we evaluate inspect CPU 2006 the

339
00:14:14,160 --> 00:14:19,230
standard benchmark suite compute

340
00:14:15,990 --> 00:14:21,390
intensive benchmarks and this allows us

341
00:14:19,230 --> 00:14:24,570
<font color="#E5E5E5">to compare a solution to other competing</font>

342
00:14:21,390 --> 00:14:25,949
solutions but<font color="#E5E5E5"> as I mentioned</font><font color="#CCCCCC"> we want a</font>

343
00:14:24,570 --> 00:14:27,420
comprehensive protection we want

344
00:14:25,950 --> 00:14:30,090
<font color="#E5E5E5">something that works in the real world</font>

345
00:14:27,420 --> 00:14:32,579
in order<font color="#CCCCCC"> to do this we need to</font><font color="#E5E5E5"> target a</font>

346
00:14:30,090 --> 00:14:34,920
<font color="#CCCCCC">real-world</font><font color="#E5E5E5"> state-of-the-art browser so</font>

347
00:14:32,580 --> 00:14:36,780
what did<font color="#CCCCCC"> we do we took Chrome we</font>

348
00:14:34,920 --> 00:14:38,339
compiled it with our protections and we

349
00:14:36,780 --> 00:14:40,339
defend all of the Chrome<font color="#CCCCCC"> browser that</font>

350
00:14:38,340 --> 00:14:44,730
many of you are running<font color="#E5E5E5"> on your laptops</font>

351
00:14:40,340 --> 00:14:46,530
we we simply modify the build system a

352
00:14:44,730 --> 00:14:48,990
<font color="#CCCCCC">little bit to a use our new special</font>

353
00:14:46,530 --> 00:14:52,260
compiler we then ran it on top<font color="#CCCCCC"> of our</font>

354
00:14:48,990 --> 00:14:54,540
execute only environment and protected

355
00:14:52,260 --> 00:14:57,150
all of chromium and its associated v8

356
00:14:54,540 --> 00:15:00,060
JavaScript engine you<font color="#E5E5E5"> can see the paper</font>

357
00:14:57,150 --> 00:15:02,430
for more details on this we evaluate<font color="#CCCCCC"> the</font>

358
00:15:00,060 --> 00:15:04,680
performance of v8 as well as the

359
00:15:02,430 --> 00:15:06,270
performance of chrome itself we found

360
00:15:04,680 --> 00:15:08,569
the performance to be very similar<font color="#CCCCCC"> to</font>

361
00:15:06,270 --> 00:15:12,540
that of spec which I will actually<font color="#E5E5E5"> show</font>

362
00:15:08,570 --> 00:15:14,190
so for spec we evaluated<font color="#E5E5E5"> our performance</font>

363
00:15:12,540 --> 00:15:17,760
and<font color="#E5E5E5"> I'll zoom in on the geometric mean</font>

364
00:15:14,190 --> 00:15:21,510
here<font color="#CCCCCC"> you can see on the right the pink</font>

365
00:15:17,760 --> 00:15:24,840
bar is our full redactor system we incur

366
00:15:21,510 --> 00:15:27,330
and overhead about 6.4 percent over the

367
00:15:24,840 --> 00:15:29,130
unmodified baseline but it's interesting

368
00:15:27,330 --> 00:15:30,870
to<font color="#CCCCCC"> note that</font><font color="#E5E5E5"> most of this overhead</font>

369
00:15:29,130 --> 00:15:33,360
actually comes from<font color="#E5E5E5"> the code pointer</font>

370
00:15:30,870 --> 00:15:35,790
hiding component so on the left and

371
00:15:33,360 --> 00:15:36,420
light blue we have code pointer hiding

372
00:15:35,790 --> 00:15:38,490
which as I'm

373
00:15:36,420 --> 00:15:40,170
to refresh your memory protects against

374
00:15:38,490 --> 00:15:42,209
indirect disclosure not direct

375
00:15:40,170 --> 00:15:44,760
disclosure and this<font color="#CCCCCC"> costs about four</font>

376
00:15:42,209 --> 00:15:46,739
percent so in the middle in the<font color="#CCCCCC"> light</font>

377
00:15:44,760 --> 00:15:48,839
green you can<font color="#E5E5E5"> see the performance</font>

378
00:15:46,740 --> 00:15:53,250
results for just implementing execute

379
00:15:48,839 --> 00:15:55,829
only memory in<font color="#CCCCCC"> Hardware on x86 cost a</font>

380
00:15:53,250 --> 00:15:59,459
little over two percent so in total our

381
00:15:55,829 --> 00:16:00,930
overheads<font color="#CCCCCC"> 6.4 percent but a large</font>

382
00:15:59,459 --> 00:16:03,768
component<font color="#E5E5E5"> of that is our novel</font>

383
00:16:00,930 --> 00:16:06,989
protections against indirect disclosure

384
00:16:03,769 --> 00:16:10,050
in conclusion we've presented redactor

385
00:16:06,990 --> 00:16:11,820
which is the first completely Hardware

386
00:16:10,050 --> 00:16:14,899
enforced execute only memory protection

387
00:16:11,820 --> 00:16:17,430
so you can run on today's x86 processors

388
00:16:14,899 --> 00:16:19,639
we're also<font color="#E5E5E5"> the first solution protect</font>

389
00:16:17,430 --> 00:16:22,529
against both direct<font color="#E5E5E5"> code disclosure</font>

390
00:16:19,639 --> 00:16:24,540
reading code pages and indirect code

391
00:16:22,529 --> 00:16:26,339
disclosure reading readable code

392
00:16:24,540 --> 00:16:29,000
pointers that gain gain the attacker

393
00:16:26,339 --> 00:16:31,949
information about the code layout and

394
00:16:29,000 --> 00:16:35,310
finally we are comprehensive we protect

395
00:16:31,949 --> 00:16:37,979
the entire Chrome browser as well<font color="#CCCCCC"> as jet</font>

396
00:16:35,310 --> 00:16:40,160
compiled code thank you I welcome<font color="#CCCCCC"> any</font>

397
00:16:37,980 --> 00:16:40,160
questions

398
00:16:50,030 --> 00:16:55,860
so what are<font color="#CCCCCC"> the attack vector is still</font>

399
00:16:52,800 --> 00:16:59,459
left<font color="#E5E5E5"> the architecture we don't really</font>

400
00:16:55,860 --> 00:17:01,410
handle side channels so that's that's an

401
00:16:59,460 --> 00:17:03,900
<font color="#CCCCCC">open problem and I think side channels</font>

402
00:17:01,410 --> 00:17:06,450
are a very hard problem as we saw in

403
00:17:03,900 --> 00:17:08,700
previous sessions here that's that's a

404
00:17:06,450 --> 00:17:12,180
very valid thing so<font color="#E5E5E5"> that's that would be</font>

405
00:17:08,700 --> 00:17:16,980
one thing I<font color="#CCCCCC"> would say but yes pyre</font>

406
00:17:12,180 --> 00:17:20,160
<font color="#CCCCCC">Purdue Great Auk love it the how would</font>

407
00:17:16,980 --> 00:17:24,030
<font color="#E5E5E5">you protect against reusing complete</font>

408
00:17:20,160 --> 00:17:26,070
functions as my gadgets that are known

409
00:17:24,030 --> 00:17:29,129
to<font color="#CCCCCC"> be taken somewhere else in</font><font color="#E5E5E5"> the code</font>

410
00:17:26,069 --> 00:17:31,770
where you have to insert these these

411
00:17:29,130 --> 00:17:32,940
trampolines anyways and<font color="#CCCCCC"> you</font><font color="#E5E5E5"> mentioned</font>

412
00:17:31,770 --> 00:17:35,400
something along the lines that you

413
00:17:32,940 --> 00:17:39,150
prohibit the use of trampolines can you

414
00:17:35,400 --> 00:17:41,910
elaborate on that sure sure we do not

415
00:17:39,150 --> 00:17:44,010
prohibit reusing hold functions however

416
00:17:41,910 --> 00:17:45,840
to reuse a whole function under our

417
00:17:44,010 --> 00:17:49,140
system you first have to disclose a code

418
00:17:45,840 --> 00:17:51,270
born so you need<font color="#E5E5E5"> to have the code</font>

419
00:17:49,140 --> 00:17:53,700
pointer that you want pointing<font color="#CCCCCC"> to the</font>

420
00:17:51,270 --> 00:17:56,160
function you want<font color="#E5E5E5"> to reuse in many cases</font>

421
00:17:53,700 --> 00:18:00,090
you<font color="#CCCCCC"> can do this we do not protect</font>

422
00:17:56,160 --> 00:18:02,090
against this as is we only what I

423
00:18:00,090 --> 00:18:04,709
mentioned with protecting trampolines is

424
00:18:02,090 --> 00:18:07,260
trampolines are not useful for gadgets

425
00:18:04,710 --> 00:18:09,090
themselves so you can<font color="#E5E5E5"> get the address of</font>

426
00:18:07,260 --> 00:18:10,830
a trampoline but the trampoline is

427
00:18:09,090 --> 00:18:13,139
simply a single instruction and we

428
00:18:10,830 --> 00:18:15,449
<font color="#CCCCCC">randomize that layout to ensure that you</font>

429
00:18:13,140 --> 00:18:17,640
cannot reuse a gadget inside that direct

430
00:18:15,450 --> 00:18:23,970
jump but yes you can still do full

431
00:18:17,640 --> 00:18:26,460
function reuse that's<font color="#E5E5E5"> future work there</font>

432
00:18:23,970 --> 00:18:28,860
no<font color="#CCCCCC"> other questions</font><font color="#E5E5E5"> um you mentioned for</font>

433
00:18:26,460 --> 00:18:31,260
<font color="#CCCCCC">the pointer hiding itself as the highest</font>

434
00:18:28,860 --> 00:18:32,610
overhead probably for the<font color="#E5E5E5"> return</font>

435
00:18:31,260 --> 00:18:34,320
instructions where you have to<font color="#E5E5E5"> go</font>

436
00:18:32,610 --> 00:18:36,689
through additional in direction so you

437
00:18:34,320 --> 00:18:38,879
look at other<font color="#E5E5E5"> instruction sequences</font>

438
00:18:36,690 --> 00:18:41,190
removing the return instruction and

439
00:18:38,880 --> 00:18:43,680
possibly using an indirect jump or

440
00:18:41,190 --> 00:18:46,590
something<font color="#CCCCCC"> like that very good question</font>

441
00:18:43,680 --> 00:18:48,810
we have not investigated this my

442
00:18:46,590 --> 00:18:49,980
intuition would be that this on<font color="#E5E5E5"> Intel</font>

443
00:18:48,810 --> 00:18:52,950
hardware this would actually be

444
00:18:49,980 --> 00:18:55,590
problematic because until implements a

445
00:18:52,950 --> 00:18:56,440
hidden returned restack so they call rat

446
00:18:55,590 --> 00:18:59,260
pairs

447
00:18:56,440 --> 00:19:02,740
<font color="#CCCCCC">are fast so I actually</font><font color="#E5E5E5"> expect that to be</font>

448
00:18:59,260 --> 00:19:05,830
slower than our current solution we do

449
00:19:02,740 --> 00:19:08,290
allow the call<font color="#E5E5E5"> ret stack to function as</font>

450
00:19:05,830 --> 00:19:09,520
<font color="#E5E5E5">Dom but yes you have to do an extra</font>

451
00:19:08,290 --> 00:19:12,250
layer of indirection and it turns out

452
00:19:09,520 --> 00:19:15,420
most of this overhead is actually from

453
00:19:12,250 --> 00:19:18,520
the code cache the instruction cache we

454
00:19:15,420 --> 00:19:20,620
we add trampolines this purpose pollutes

455
00:19:18,520 --> 00:19:25,660
the instruction cache resulting in more

456
00:19:20,620 --> 00:19:28,229
instruction cache misses thank you<font color="#E5E5E5"> thank</font>

457
00:19:25,660 --> 00:19:28,230
you pick her again

