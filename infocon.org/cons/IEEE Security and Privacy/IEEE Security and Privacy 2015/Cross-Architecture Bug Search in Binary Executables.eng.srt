1
00:00:00,000 --> 00:00:03,870
well first of all thanks for the kind

2
00:00:02,100 --> 00:00:05,490
introduction and thanks to<font color="#CCCCCC"> all of you</font>

3
00:00:03,870 --> 00:00:06,899
for showing up this early in<font color="#E5E5E5"> the morning</font>

4
00:00:05,490 --> 00:00:08,280
I know it's<font color="#E5E5E5"> always a bit over there to</font>

5
00:00:06,899 --> 00:00:10,500
give a talk right after the closing

6
00:00:08,280 --> 00:00:13,590
remarks so I really appreciate<font color="#E5E5E5"> your</font>

7
00:00:10,500 --> 00:00:15,809
coming here um I'm going<font color="#E5E5E5"> to present a</font>

8
00:00:13,590 --> 00:00:18,689
set work on back search in binary

9
00:00:15,809 --> 00:00:21,210
software which works cross architecture

10
00:00:18,690 --> 00:00:23,070
and I'm going to<font color="#E5E5E5"> wait</font><font color="#CCCCCC"> for the</font><font color="#E5E5E5"> first</font>

11
00:00:21,210 --> 00:00:25,340
slide show up before I actually start

12
00:00:23,070 --> 00:00:25,340
the talk

13
00:00:34,910 --> 00:00:42,739
okay that<font color="#E5E5E5"> works um asset I'm going to</font>

14
00:00:40,880 --> 00:00:45,320
present my work it's of<font color="#E5E5E5"> course not my</font>

15
00:00:42,739 --> 00:00:47,660
work all alone um I've done it with some

16
00:00:45,320 --> 00:00:49,640
colleagues of mine namely be hard<font color="#CCCCCC"> kimani</font>

17
00:00:47,660 --> 00:00:51,650
<font color="#CCCCCC">robot garlic</font><font color="#E5E5E5"> Christian also and my</font>

18
00:00:49,640 --> 00:00:53,269
professor toss notes unfortunately

19
00:00:51,650 --> 00:00:56,300
Christian also is not at the rural

20
00:00:53,269 --> 00:00:57,800
university anymore he switched to sis

21
00:00:56,300 --> 00:00:59,209
Bowens island which<font color="#CCCCCC"> I forgot</font><font color="#E5E5E5"> to mention</font>

22
00:00:57,800 --> 00:01:02,000
on the side so<font color="#E5E5E5"> I should really mention</font>

23
00:00:59,210 --> 00:01:03,530
it here but all of them are actually in

24
00:01:02,000 --> 00:01:04,910
the audience<font color="#E5E5E5"> so if you happen</font><font color="#CCCCCC"> to like</font>

25
00:01:03,530 --> 00:01:06,380
this<font color="#E5E5E5"> little piece of work please make</font>

26
00:01:04,910 --> 00:01:09,500
sure to tell them about<font color="#E5E5E5"> it too i'd</font>

27
00:01:06,380 --> 00:01:11,420
really appreciate that so asshat cross

28
00:01:09,500 --> 00:01:14,330
architecture back search<font color="#CCCCCC"> um if you ever</font>

29
00:01:11,420 --> 00:01:16,100
feel a little bit lost in this talk just

30
00:01:14,330 --> 00:01:18,500
remember that the key ingredient of it

31
00:01:16,100 --> 00:01:20,660
is a code similarity metric which

32
00:01:18,500 --> 00:01:22,820
happens to work across CPU architectures

33
00:01:20,660 --> 00:01:24,679
so if you ask<font color="#CCCCCC"> yourself well why are we</font>

34
00:01:22,820 --> 00:01:33,649
doing all this pre-processing stuff it's

35
00:01:24,680 --> 00:01:36,369
to set up this a key ingredient they are

36
00:01:33,649 --> 00:01:36,369
slightly out of sync

37
00:01:40,330 --> 00:01:44,340
we can<font color="#E5E5E5"> probably get that fixed right</font>

38
00:01:50,340 --> 00:01:55,979
okay here<font color="#E5E5E5"> we go key ingredient called</font>

39
00:01:52,950 --> 00:01:57,600
similarity metric asset if you are

40
00:01:55,979 --> 00:01:59,310
asking yourself why<font color="#CCCCCC"> are doing all this</font>

41
00:01:57,600 --> 00:02:01,350
pre-processing is it to set up this

42
00:01:59,310 --> 00:02:03,179
constantly are geometric if you don't

43
00:02:01,350 --> 00:02:04,699
know how we are<font color="#E5E5E5"> looking for bugs again</font>

44
00:02:03,179 --> 00:02:07,229
it's with that code similarity metric

45
00:02:04,700 --> 00:02:09,299
the basic workflow all over what we are

46
00:02:07,229 --> 00:02:13,140
doing is you shall is a<font color="#E5E5E5"> binary in either</font>

47
00:02:09,299 --> 00:02:15,390
x86 or<font color="#CCCCCC"> MIPS or arm and obfuscate it that</font>

48
00:02:13,140 --> 00:02:17,548
is you pinpoint us<font color="#CCCCCC"> to</font><font color="#E5E5E5"> the exact back</font>

49
00:02:15,390 --> 00:02:20,309
location and then you give us another

50
00:02:17,549 --> 00:02:23,340
binary and we try we will try to refined

51
00:02:20,310 --> 00:02:26,130
the same or very similar back in that

52
00:02:23,340 --> 00:02:29,130
binary which may be compiled for another

53
00:02:26,130 --> 00:02:31,290
architecture so and the basic assumption

54
00:02:29,130 --> 00:02:33,120
with finding bugs with Col similarity is

55
00:02:31,290 --> 00:02:35,730
that we know what a specific buck

56
00:02:33,120 --> 00:02:37,110
instance looks like we try to find a

57
00:02:35,730 --> 00:02:40,530
piece of code which looks<font color="#CCCCCC"> pretty similar</font>

58
00:02:37,110 --> 00:02:42,030
to<font color="#E5E5E5"> that and well then it is</font><font color="#CCCCCC"> likely to</font>

59
00:02:40,530 --> 00:02:43,920
contain the same bug and<font color="#CCCCCC"> the reason for</font>

60
00:02:42,030 --> 00:02:45,780
that<font color="#CCCCCC"> is mainly because the reason</font><font color="#E5E5E5"> for</font>

61
00:02:43,920 --> 00:02:47,760
the code<font color="#E5E5E5"> pieces being similar is that</font>

62
00:02:45,780 --> 00:02:49,620
programs are lazy they will copy and

63
00:02:47,760 --> 00:02:51,989
paste code and that<font color="#CCCCCC"> means they will also</font>

64
00:02:49,620 --> 00:02:53,700
copy and paste bucks they may adapt<font color="#E5E5E5"> them</font>

65
00:02:51,989 --> 00:02:55,829
slide into the situation which is<font color="#E5E5E5"> why we</font>

66
00:02:53,700 --> 00:02:59,069
not<font color="#E5E5E5"> only find the same box but actually</font>

67
00:02:55,829 --> 00:03:01,260
sometimes similar backs so i'll<font color="#E5E5E5"> start</font>

68
00:02:59,069 --> 00:03:03,298
with not<font color="#CCCCCC"> all work but actually with</font>

69
00:03:01,260 --> 00:03:04,920
somebody else's work and<font color="#E5E5E5"> that's for two</font>

70
00:03:03,299 --> 00:03:06,690
reasons first of all because it really

71
00:03:04,920 --> 00:03:08,130
inspired what we did second of all

72
00:03:06,690 --> 00:03:09,750
because<font color="#CCCCCC"> i really like that</font><font color="#E5E5E5"> overview</font>

73
00:03:08,130 --> 00:03:12,690
graphic that they have and that allows

74
00:03:09,750 --> 00:03:14,340
me to<font color="#E5E5E5"> include in my talk so I'm talking</font>

75
00:03:12,690 --> 00:03:16,530
<font color="#CCCCCC">about generalized vulnerability</font>

76
00:03:14,340 --> 00:03:18,840
extrapolation using abstract syntax

77
00:03:16,530 --> 00:03:20,639
trees it's worked by 5am Iguchi at all

78
00:03:18,840 --> 00:03:22,950
who is also in the<font color="#E5E5E5"> in this room as far</font>

79
00:03:20,639 --> 00:03:24,750
as<font color="#CCCCCC"> I know and what they do is they</font>

80
00:03:22,950 --> 00:03:26,819
analyze some source code and the

81
00:03:24,750 --> 00:03:28,530
resulting abstracts industry abstract

82
00:03:26,819 --> 00:03:31,768
syntax tree is embedded into a vector

83
00:03:28,530 --> 00:03:34,799
<font color="#CCCCCC">space and then they use the metric of</font>

84
00:03:31,769 --> 00:03:36,560
this vector space to find similar<font color="#E5E5E5"> code</font>

85
00:03:34,799 --> 00:03:38,970
vectors and if one of<font color="#E5E5E5"> them happens to</font>

86
00:03:36,560 --> 00:03:40,709
happens to be known to<font color="#E5E5E5"> be a bug it's</font>

87
00:03:38,970 --> 00:03:44,459
likely<font color="#CCCCCC"> that the other ones may also be</font>

88
00:03:40,709 --> 00:03:47,669
bugging so um what do we actually want

89
00:03:44,459 --> 00:03:49,650
to<font color="#E5E5E5"> do it's um so</font><font color="#CCCCCC"> that worked for me</font>

90
00:03:47,669 --> 00:03:51,750
<font color="#E5E5E5">mostly means that they abstract from</font>

91
00:03:49,650 --> 00:03:55,590
back classes<font color="#E5E5E5"> which may sometimes be hard</font>

92
00:03:51,750 --> 00:03:58,590
to use are in practice<font color="#CCCCCC"> actually so what</font>

93
00:03:55,590 --> 00:04:00,860
they do instead is um they and we focus

94
00:03:58,590 --> 00:04:03,750
<font color="#E5E5E5">on single bug instances</font>

95
00:04:00,860 --> 00:04:05,310
second of all we want to focus on

96
00:04:03,750 --> 00:04:07,040
something like nearest neighbor search

97
00:04:05,310 --> 00:04:08,519
actually we<font color="#E5E5E5"> don't do any fancy</font>

98
00:04:07,040 --> 00:04:10,260
clustering or something like that

99
00:04:08,519 --> 00:04:12,569
because<font color="#E5E5E5"> what we actually</font><font color="#CCCCCC"> just want to do</font>

100
00:04:10,260 --> 00:04:16,289
is to find out<font color="#E5E5E5"> if two pieces of code are</font>

101
00:04:12,569 --> 00:04:18,139
similar to each other third we want to

102
00:04:16,289 --> 00:04:21,690
do it not on source code or non-binary

103
00:04:18,139 --> 00:04:23,729
and all that we do actually<font color="#CCCCCC"> has</font>

104
00:04:21,690 --> 00:04:25,500
<font color="#CCCCCC">sub-function granularity because that is</font>

105
00:04:23,729 --> 00:04:27,389
very important for back search if you

106
00:04:25,500 --> 00:04:30,210
think about it if<font color="#CCCCCC"> you know what a piece</font>

107
00:04:27,389 --> 00:04:31,680
of code that<font color="#E5E5E5"> as a bug looks like it</font>

108
00:04:30,210 --> 00:04:33,090
would<font color="#CCCCCC"> be really</font><font color="#E5E5E5"> cool to find that not</font>

109
00:04:31,680 --> 00:04:34,680
<font color="#CCCCCC">only in the function that it's in but</font>

110
00:04:33,090 --> 00:04:37,080
actually also in another function and

111
00:04:34,680 --> 00:04:39,660
<font color="#CCCCCC">that requires sub-function granularity</font>

112
00:04:37,080 --> 00:04:42,030
and last of all we would like to<font color="#E5E5E5"> focus</font>

113
00:04:39,660 --> 00:04:44,490
more on the semantics and the<font color="#E5E5E5"> structure</font>

114
00:04:42,030 --> 00:04:48,119
of<font color="#E5E5E5"> the code than on any symbolic or</font>

115
00:04:44,490 --> 00:04:50,430
syntax information so and no it really

116
00:04:48,120 --> 00:04:51,599
starts with what we<font color="#CCCCCC"> actually did so we</font>

117
00:04:50,430 --> 00:04:53,820
start<font color="#CCCCCC"> off with an intermediate</font>

118
00:04:51,599 --> 00:04:56,280
representation as set you give us an

119
00:04:53,820 --> 00:04:57,810
office skating binary be it x86 or are

120
00:04:56,280 --> 00:05:00,239
more moves that's the<font color="#CCCCCC"> architectures</font>

121
00:04:57,810 --> 00:05:02,520
<font color="#CCCCCC">which</font><font color="#E5E5E5"> support so far and then we use the</font>

122
00:05:00,240 --> 00:05:06,479
<font color="#CCCCCC">VEX intermediate representation most</font>

123
00:05:02,520 --> 00:05:10,469
known for the wall grind memory checking

124
00:05:06,479 --> 00:05:12,389
framework and that's<font color="#CCCCCC"> IR is</font><font color="#E5E5E5"> usually used</font>

125
00:05:10,470 --> 00:05:14,460
for dynamic analysis and we kind of

126
00:05:12,389 --> 00:05:16,889
<font color="#E5E5E5">missed use it for static analysis which</font>

127
00:05:14,460 --> 00:05:19,409
gives an onset of problems but we<font color="#E5E5E5"> also</font>

128
00:05:16,889 --> 00:05:21,990
had to modify it heavily to abstract

129
00:05:19,409 --> 00:05:24,810
from some<font color="#CCCCCC"> architecture specific let's</font>

130
00:05:21,990 --> 00:05:27,690
call<font color="#CCCCCC"> it idioms so to say and what we</font>

131
00:05:24,810 --> 00:05:30,510
then do is we use basic blocks as our

132
00:05:27,690 --> 00:05:34,310
let's say single<font color="#E5E5E5"> building block and for</font>

133
00:05:30,510 --> 00:05:38,099
each basic block we try to accumulate

134
00:05:34,310 --> 00:05:41,789
the effect this our basic block has on a

135
00:05:38,099 --> 00:05:44,159
specific register or memory location so

136
00:05:41,789 --> 00:05:47,120
we accumulate<font color="#CCCCCC"> all the little of XIR</font>

137
00:05:44,159 --> 00:05:49,979
instructions that have that specific

138
00:05:47,120 --> 00:05:52,949
register as target and we got a big big

139
00:05:49,979 --> 00:05:55,080
expression that explains what happens to

140
00:05:52,949 --> 00:05:57,930
this register or memory location in that

141
00:05:55,080 --> 00:06:00,090
<font color="#E5E5E5">basic block when you execute it we pipe</font>

142
00:05:57,930 --> 00:06:01,650
all that into<font color="#CCCCCC"> z3 and that is only</font><font color="#E5E5E5"> to get</font>

143
00:06:00,090 --> 00:06:04,830
<font color="#E5E5E5">a nice simple as expression out of it</font>

144
00:06:01,650 --> 00:06:06,448
and to simplify it a little bit so as

145
00:06:04,830 --> 00:06:08,940
<font color="#E5E5E5">you can see on the</font><font color="#CCCCCC"> bottom we start off</font>

146
00:06:06,449 --> 00:06:11,490
with some assembly code in<font color="#E5E5E5"> this case</font><font color="#CCCCCC"> our</font>

147
00:06:08,940 --> 00:06:13,120
it's<font color="#E5E5E5"> just something that reads of a</font>

148
00:06:11,490 --> 00:06:14,979
<font color="#E5E5E5">memory location and incremental calendar</font>

149
00:06:13,120 --> 00:06:17,139
and you can see that the<font color="#E5E5E5"> assembly</font>

150
00:06:14,979 --> 00:06:18,789
instructions are kind of different they

151
00:06:17,139 --> 00:06:20,830
differ in<font color="#E5E5E5"> the number of registers in</font>

152
00:06:18,790 --> 00:06:22,120
there actually<font color="#E5E5E5"> x86 only has one</font>

153
00:06:20,830 --> 00:06:24,669
instruction for doing both<font color="#CCCCCC"> of those</font>

154
00:06:22,120 --> 00:06:26,620
tasks and the intermediate residents

155
00:06:24,669 --> 00:06:30,900
have representation already looks kind

156
00:06:26,620 --> 00:06:32,979
of similar so um but these are complex

157
00:06:30,900 --> 00:06:35,349
assignment formulas as we call them a

158
00:06:32,979 --> 00:06:37,389
kind<font color="#E5E5E5"> of hard to compare to each other</font>

159
00:06:35,350 --> 00:06:39,550
what you can usually do is you can<font color="#E5E5E5"> use</font>

160
00:06:37,389 --> 00:06:41,949
<font color="#E5E5E5">some unifying approach or something</font>

161
00:06:39,550 --> 00:06:43,720
which will tell you if they are equal or

162
00:06:41,949 --> 00:06:45,840
not but that<font color="#CCCCCC"> is really</font><font color="#E5E5E5"> not what we want</font>

163
00:06:43,720 --> 00:06:48,760
we<font color="#CCCCCC"> want some kind of scaling gradual</font>

164
00:06:45,840 --> 00:06:52,179
similarity measurement so what we did

165
00:06:48,760 --> 00:06:55,449
was we<font color="#E5E5E5"> sampled which means that we</font>

166
00:06:52,180 --> 00:06:57,910
generate a random input vector execute

167
00:06:55,449 --> 00:07:00,789
the basic block on that<font color="#CCCCCC"> input vector</font>

168
00:06:57,910 --> 00:07:02,800
which gives us an output vector so and

169
00:07:00,789 --> 00:07:04,780
we do that<font color="#CCCCCC"> for a lot</font><font color="#E5E5E5"> of inputs and that</font>

170
00:07:02,800 --> 00:07:08,260
really<font color="#E5E5E5"> gives us some kind of point wise</font>

171
00:07:04,780 --> 00:07:11,289
semantics of this basic block and now

172
00:07:08,260 --> 00:07:14,070
the reason the reason<font color="#CCCCCC"> while we do that</font>

173
00:07:11,289 --> 00:07:17,590
<font color="#E5E5E5">is that similar basic blocks are kind of</font>

174
00:07:14,070 --> 00:07:20,260
exposed to share<font color="#E5E5E5"> in these input output</font>

175
00:07:17,590 --> 00:07:22,150
vectors these<font color="#CCCCCC"> input-output pairs and the</font>

176
00:07:20,260 --> 00:07:25,090
more they share the more similar they

177
00:07:22,150 --> 00:07:28,419
<font color="#CCCCCC">are now from those assignment formulas</font>

178
00:07:25,090 --> 00:07:31,539
we have got a big big set of I au pairs

179
00:07:28,419 --> 00:07:33,940
basically and that<font color="#E5E5E5"> isn't optimal either</font>

180
00:07:31,539 --> 00:07:35,740
um because to compare them you have<font color="#CCCCCC"> to</font>

181
00:07:33,940 --> 00:07:37,180
do<font color="#E5E5E5"> something</font><font color="#CCCCCC"> like whatever the jack our</font>

182
00:07:35,740 --> 00:07:41,139
index or something like that which<font color="#E5E5E5"> is</font>

183
00:07:37,180 --> 00:07:43,750
<font color="#E5E5E5">pretty pretty costly actually so we came</font>

184
00:07:41,139 --> 00:07:46,180
up<font color="#E5E5E5"> with another step which is to use</font>

185
00:07:43,750 --> 00:07:47,349
locally sensitive hashes and those

186
00:07:46,180 --> 00:07:50,530
<font color="#E5E5E5">little things have a nice little</font>

187
00:07:47,349 --> 00:07:52,030
<font color="#E5E5E5">property which means that the similarity</font>

188
00:07:50,530 --> 00:07:54,909
of the hashed object is actually

189
00:07:52,030 --> 00:07:57,219
represented by the hash which is not

190
00:07:54,910 --> 00:07:59,770
similar to cryptographic<font color="#CCCCCC"> heathers hashes</font>

191
00:07:57,220 --> 00:08:02,020
for example and<font color="#CCCCCC"> that allows us to save</font>

192
00:07:59,770 --> 00:08:04,799
one hash per basic block instead of all

193
00:08:02,020 --> 00:08:07,599
the big big list of input-output pairs

194
00:08:04,800 --> 00:08:08,800
so that's in the end we can compare<font color="#E5E5E5"> two</font>

195
00:08:07,599 --> 00:08:10,659
basic blocks actually<font color="#E5E5E5"> find out how</font>

196
00:08:08,800 --> 00:08:14,770
similar they<font color="#CCCCCC"> are just by comparing this</font>

197
00:08:10,660 --> 00:08:17,410
one little hash so and<font color="#E5E5E5"> now</font><font color="#CCCCCC"> or that we've</font>

198
00:08:14,770 --> 00:08:19,479
done that we can<font color="#CCCCCC"> actually go to how to</font>

199
00:08:17,410 --> 00:08:22,180
find it back with that we start off<font color="#E5E5E5"> with</font>

200
00:08:19,479 --> 00:08:23,950
a bug signature in an hour case<font color="#E5E5E5"> back</font>

201
00:08:22,180 --> 00:08:24,770
signature which is<font color="#E5E5E5"> just a catchy label</font>

202
00:08:23,950 --> 00:08:27,110
we need it

203
00:08:24,770 --> 00:08:30,740
just a piece of code it is<font color="#E5E5E5"> not as</font>

204
00:08:27,110 --> 00:08:32,149
abstracted as for example arm in network

205
00:08:30,740 --> 00:08:33,409
intrusion detection systems or something

206
00:08:32,149 --> 00:08:34,909
where it's a glorified reg ex or

207
00:08:33,409 --> 00:08:38,029
something<font color="#CCCCCC"> it's just a piece of code</font>

208
00:08:34,909 --> 00:08:41,360
that's it and back signature in<font color="#CCCCCC"> a sense</font>

209
00:08:38,029 --> 00:08:44,660
should contain the back and a little<font color="#E5E5E5"> bit</font>

210
00:08:41,360 --> 00:08:46,010
of discriminatory context but as set

211
00:08:44,660 --> 00:08:48,170
it's just a<font color="#E5E5E5"> piece of code it's not</font>

212
00:08:46,010 --> 00:08:51,439
structurally different from the target

213
00:08:48,170 --> 00:08:54,380
program we look for we look in for the

214
00:08:51,440 --> 00:08:56,540
back signature so the<font color="#E5E5E5"> next step is to</font>

215
00:08:54,380 --> 00:08:59,779
<font color="#E5E5E5">find some starting points we start off</font>

216
00:08:56,540 --> 00:09:02,300
with a single basic block in the

217
00:08:59,779 --> 00:09:03,770
<font color="#E5E5E5">signature and try to find a good basic</font>

218
00:09:02,300 --> 00:09:06,380
block level match in the<font color="#E5E5E5"> target program</font>

219
00:09:03,770 --> 00:09:08,569
just to know where<font color="#CCCCCC"> we have to like start</font>

220
00:09:06,380 --> 00:09:12,709
searching for a full signature spanning

221
00:09:08,570 --> 00:09:13,970
match and that asset gives us some

222
00:09:12,709 --> 00:09:15,380
starting points and a starting point is

223
00:09:13,970 --> 00:09:17,360
somewhat<font color="#E5E5E5"> of</font><font color="#CCCCCC"> a misleading term because</font>

224
00:09:15,380 --> 00:09:18,800
it's actually<font color="#CCCCCC"> a pair of points</font><font color="#E5E5E5"> one in</font>

225
00:09:17,360 --> 00:09:20,570
the signature and one in<font color="#CCCCCC"> the target</font>

226
00:09:18,800 --> 00:09:22,279
<font color="#E5E5E5">program you can see</font><font color="#CCCCCC"> that in the big big</font>

227
00:09:20,570 --> 00:09:23,420
picture at the bottom asset we start

228
00:09:22,279 --> 00:09:25,730
with<font color="#CCCCCC"> the signature and the target</font>

229
00:09:23,420 --> 00:09:28,399
program try to find some starting points

230
00:09:25,730 --> 00:09:31,520
and the second part<font color="#E5E5E5"> of that picture is</font>

231
00:09:28,399 --> 00:09:34,070
actually<font color="#E5E5E5"> done on this slide so now we do</font>

232
00:09:31,520 --> 00:09:35,510
have<font color="#E5E5E5"> these starting points and what we</font>

233
00:09:34,070 --> 00:09:37,760
then do is some what we call in<font color="#E5E5E5"> the</font>

234
00:09:35,510 --> 00:09:39,050
paper<font color="#CCCCCC"> bastid broadening and it just</font>

235
00:09:37,760 --> 00:09:42,670
means that we explore the neighborhood

236
00:09:39,050 --> 00:09:45,890
around these two<font color="#E5E5E5"> already matched blocks</font>

237
00:09:42,670 --> 00:09:47,870
and broaden the match with the next best

238
00:09:45,890 --> 00:09:49,339
candidate we can find so<font color="#E5E5E5"> I try to</font>

239
00:09:47,870 --> 00:09:51,709
<font color="#E5E5E5">explain it with the picture at the</font>

240
00:09:49,339 --> 00:09:53,600
bottom on the left you always see the

241
00:09:51,709 --> 00:09:56,510
source program the bug signature on the

242
00:09:53,600 --> 00:09:58,760
right you see the target program and big

243
00:09:56,510 --> 00:10:00,680
black arrow represents that two basic

244
00:09:58,760 --> 00:10:02,300
blocks are already matched now at first

245
00:10:00,680 --> 00:10:04,699
<font color="#E5E5E5">only the starting point Paris matched</font>

246
00:10:02,300 --> 00:10:06,800
and what I<font color="#E5E5E5"> should mention next is that</font>

247
00:10:04,700 --> 00:10:09,020
the similarity in that picture is

248
00:10:06,800 --> 00:10:10,880
represented by the number of edges so

249
00:10:09,020 --> 00:10:12,470
the more similar the number of edges<font color="#E5E5E5"> is</font>

250
00:10:10,880 --> 00:10:14,450
the more similar the basic blocks in

251
00:10:12,470 --> 00:10:16,220
that example should be so as you can

252
00:10:14,450 --> 00:10:17,690
maybe see there's two triangular blocks

253
00:10:16,220 --> 00:10:21,320
in the<font color="#E5E5E5"> immediate neighborhood of the</font>

254
00:10:17,690 --> 00:10:23,600
already matched block and that<font color="#E5E5E5"> is the</font>

255
00:10:21,320 --> 00:10:25,070
next best<font color="#CCCCCC"> mesh so we</font><font color="#E5E5E5"> fix that one and in</font>

256
00:10:23,600 --> 00:10:29,420
the picture in<font color="#E5E5E5"> the middle we get that</font>

257
00:10:25,070 --> 00:10:31,490
next big black arrow and we do that

258
00:10:29,420 --> 00:10:33,560
incrementally until we have got a full

259
00:10:31,490 --> 00:10:37,010
signature spanning match in the<font color="#E5E5E5"> target</font>

260
00:10:33,560 --> 00:10:38,719
program this bassett broadening is a

261
00:10:37,010 --> 00:10:41,270
greedy method but it's locally optimal

262
00:10:38,720 --> 00:10:45,110
so with<font color="#CCCCCC"> all the neighboring nodes we</font>

263
00:10:41,270 --> 00:10:47,089
have we actually look for a arm for a

264
00:10:45,110 --> 00:10:49,310
full matching that spans all of them and

265
00:10:47,089 --> 00:10:56,449
try to<font color="#E5E5E5"> find the optimum of that at each</font>

266
00:10:49,310 --> 00:10:58,430
local point there we go so next we did

267
00:10:56,449 --> 00:11:01,099
some sanity checks and what we<font color="#E5E5E5"> did</font><font color="#CCCCCC"> was</font>

268
00:10:58,430 --> 00:11:03,560
we<font color="#E5E5E5"> try to match functions now a big big</font>

269
00:11:01,100 --> 00:11:07,100
big disclaimer function matching is not

270
00:11:03,560 --> 00:11:09,229
our basic use case<font color="#CCCCCC"> a set we want some</font>

271
00:11:07,100 --> 00:11:11,180
sub function granularity but for that

272
00:11:09,230 --> 00:11:14,180
<font color="#CCCCCC">you have to come up with some sub</font>

273
00:11:11,180 --> 00:11:15,649
function<font color="#CCCCCC"> or signatures and we really</font>

274
00:11:14,180 --> 00:11:18,079
don't have an automated way to do that

275
00:11:15,649 --> 00:11:19,579
so the only way to convince you that

276
00:11:18,079 --> 00:11:21,319
it's<font color="#E5E5E5"> not our clever choice of a</font>

277
00:11:19,579 --> 00:11:23,569
signature<font color="#E5E5E5"> that makes the match work is</font>

278
00:11:21,320 --> 00:11:24,890
well just to use the whole function so

279
00:11:23,570 --> 00:11:26,930
please keep that in mind function

280
00:11:24,890 --> 00:11:29,959
machine is not our full use case we did

281
00:11:26,930 --> 00:11:31,219
not optimized for that and actually

282
00:11:29,959 --> 00:11:34,910
there would be some very simple

283
00:11:31,220 --> 00:11:38,540
improvements to increase alarm function

284
00:11:34,910 --> 00:11:41,270
matching or scorn so<font color="#E5E5E5"> to say and a set</font>

285
00:11:38,540 --> 00:11:42,949
our framework supports x86 and mips an

286
00:11:41,270 --> 00:11:45,980
arm so it's quite natural that you can

287
00:11:42,949 --> 00:11:49,910
compare x86 code to x86 code which would

288
00:11:45,980 --> 00:11:51,949
be armed comparing code for multiple

289
00:11:49,910 --> 00:11:53,569
architectures but it actually turns out

290
00:11:51,949 --> 00:11:57,199
that we<font color="#E5E5E5"> can do a little bit more we can</font>

291
00:11:53,569 --> 00:11:59,689
compare a code similarity from x86 to

292
00:11:57,199 --> 00:12:02,149
let say nips so we can do it cross cpr

293
00:11:59,690 --> 00:12:05,630
<font color="#CCCCCC">cpu architecture and it still</font><font color="#E5E5E5"> works</font>

294
00:12:02,149 --> 00:12:07,220
pretty well it also works reasonably

295
00:12:05,630 --> 00:12:11,060
well for different compilers or

296
00:12:07,220 --> 00:12:14,060
different optimization levels and as you

297
00:12:11,060 --> 00:12:17,869
might imagine the less similar the code

298
00:12:14,060 --> 00:12:20,180
gets the moralists transformed like by

299
00:12:17,870 --> 00:12:21,350
let's say switching the OS switching the

300
00:12:20,180 --> 00:12:23,770
<font color="#CCCCCC">compiler switch in the optimization</font>

301
00:12:21,350 --> 00:12:26,660
level or switching the<font color="#E5E5E5"> cpu architecture</font>

302
00:12:23,770 --> 00:12:29,300
the less simulate will be so naturally

303
00:12:26,660 --> 00:12:31,430
the quality decreases somewhat but it

304
00:12:29,300 --> 00:12:33,380
doesn't decrease as much as you maybe

305
00:12:31,430 --> 00:12:35,060
will think and it doesn't decrease as

306
00:12:33,380 --> 00:12:37,880
much as to make<font color="#E5E5E5"> the whole technique</font>

307
00:12:35,060 --> 00:12:40,369
pointless well on the bottom<font color="#CCCCCC"> you can see</font>

308
00:12:37,880 --> 00:12:43,339
a little bit of<font color="#CCCCCC"> that cross architecture</font>

309
00:12:40,370 --> 00:12:46,040
matching where we plotted the rank of

310
00:12:43,339 --> 00:12:47,500
the true positive in like the ranking we

311
00:12:46,040 --> 00:12:49,990
computed before we

312
00:12:47,500 --> 00:12:52,240
the sound up differences of the best

313
00:12:49,990 --> 00:12:55,540
match we had we just<font color="#E5E5E5"> sort them by the</font>

314
00:12:52,240 --> 00:12:57,070
similarity basically and on the same

315
00:12:55,540 --> 00:12:59,110
architecture and even<font color="#E5E5E5"> on cross</font>

316
00:12:57,070 --> 00:13:01,570
architecture we can achieve pretty good

317
00:12:59,110 --> 00:13:03,760
matching rates at that point on the

318
00:13:01,570 --> 00:13:05,760
bottom right you can well maybe not see

319
00:13:03,760 --> 00:13:09,670
but retrace with what i'm going to say

320
00:13:05,760 --> 00:13:10,960
our experiments regarding different

321
00:13:09,670 --> 00:13:13,150
compiler optimization levels we took

322
00:13:10,960 --> 00:13:15,010
three compilers compile a piece of code

323
00:13:13,150 --> 00:13:17,650
with four different optimization levels

324
00:13:15,010 --> 00:13:19,660
and<font color="#CCCCCC"> the darker a pixel is the batter</font><font color="#E5E5E5"> the</font>

325
00:13:17,650 --> 00:13:22,150
match is and you can probably<font color="#E5E5E5"> see that</font>

326
00:13:19,660 --> 00:13:24,360
<font color="#E5E5E5">four different compilers the old zero</font>

327
00:13:22,150 --> 00:13:26,560
optimization level looks<font color="#E5E5E5"> pretty similar</font>

328
00:13:24,360 --> 00:13:27,910
working<font color="#E5E5E5"> on the same compiler works a bit</font>

329
00:13:26,560 --> 00:13:30,280
a little bit<font color="#E5E5E5"> better than switching it</font>

330
00:13:27,910 --> 00:13:31,900
GCC on GCC works still pretty reasonable

331
00:13:30,280 --> 00:13:35,290
and stuff like that all in that one to

332
00:13:31,900 --> 00:13:36,850
<font color="#CCCCCC">the picture none of that we've</font><font color="#E5E5E5"> done the</font>

333
00:13:35,290 --> 00:13:38,949
sanity stuff let's go back to<font color="#CCCCCC"> back</font>

334
00:13:36,850 --> 00:13:41,680
finding not<font color="#E5E5E5"> that that's not sane or</font>

335
00:13:38,950 --> 00:13:43,810
anything but so we go back<font color="#CCCCCC"> to</font><font color="#E5E5E5"> it so</font>

336
00:13:41,680 --> 00:13:46,660
these are<font color="#CCCCCC"> just some examples we</font><font color="#E5E5E5"> have a</font>

337
00:13:43,810 --> 00:13:49,989
few more in the<font color="#E5E5E5"> paper but first of all</font>

338
00:13:46,660 --> 00:13:52,810
um we took our the<font color="#E5E5E5"> openssl the heartbeat</font>

339
00:13:49,990 --> 00:13:55,030
in famous<font color="#E5E5E5"> one and try to find it cross</font>

340
00:13:52,810 --> 00:13:57,819
architecture so you let me remind you

341
00:13:55,030 --> 00:14:00,939
again you show us the piece of buggy

342
00:13:57,820 --> 00:14:03,339
code in an x86 binary and we are able to

343
00:14:00,940 --> 00:14:06,610
<font color="#CCCCCC">find it in an arm binary or even in the</font>

344
00:14:03,339 --> 00:14:09,370
<font color="#CCCCCC">mips router firmware as you</font><font color="#E5E5E5"> can see</font><font color="#CCCCCC"> on</font>

345
00:14:06,610 --> 00:14:12,130
the<font color="#E5E5E5"> bottom left where we always search</font>

346
00:14:09,370 --> 00:14:14,650
from arm to another architecture or from

347
00:14:12,130 --> 00:14:17,230
mips to another architecture x86 didn't

348
00:14:14,650 --> 00:14:20,530
fit on the slide as you may or may not

349
00:14:17,230 --> 00:14:23,170
know there's actually too vulnerable

350
00:14:20,530 --> 00:14:24,790
functions to heartbleed vulnerable

351
00:14:23,170 --> 00:14:26,380
functions at least there may be more

352
00:14:24,790 --> 00:14:30,430
other vulnerabilities and<font color="#E5E5E5"> open SSL and</font>

353
00:14:26,380 --> 00:14:32,589
those are the cases for TLS and<font color="#CCCCCC"> dtls we</font>

354
00:14:30,430 --> 00:14:37,660
use both both of them<font color="#E5E5E5"> as signatures and</font>

355
00:14:32,589 --> 00:14:39,220
so we also get like 22 matches to match

356
00:14:37,660 --> 00:14:40,569
rankings for the two vulnerable

357
00:14:39,220 --> 00:14:42,040
functions and as you can see in the

358
00:14:40,570 --> 00:14:46,960
table<font color="#E5E5E5"> they are ranked pretty much</font>

359
00:14:42,040 --> 00:14:49,630
perfectly even across architectures we

360
00:14:46,960 --> 00:14:52,050
also like did us the same examples on

361
00:14:49,630 --> 00:14:55,180
busybox vulnerabilities and on the

362
00:14:52,050 --> 00:14:57,609
circum back door which we<font color="#E5E5E5"> found in</font>

363
00:14:55,180 --> 00:14:59,589
closed source router firmware which is

364
00:14:57,610 --> 00:15:01,310
pretty cool but<font color="#E5E5E5"> the question that</font>

365
00:14:59,589 --> 00:15:03,080
<font color="#E5E5E5">remains is since all</font>

366
00:15:01,310 --> 00:15:05,660
<font color="#E5E5E5">our algorithms do is give you a ranking</font>

367
00:15:03,080 --> 00:15:08,600
ranked by similarity whether most

368
00:15:05,660 --> 00:15:10,219
similar matches are at the<font color="#E5E5E5"> very top even</font>

369
00:15:08,600 --> 00:15:12,410
if you find a pretty good<font color="#E5E5E5"> match like the</font>

370
00:15:10,220 --> 00:15:14,930
similarity of values of pre far apart

371
00:15:12,410 --> 00:15:17,390
from the next base hit is it actually a

372
00:15:14,930 --> 00:15:21,050
true positive and the set answer is we

373
00:15:17,390 --> 00:15:24,140
can't tell because all we do is find

374
00:15:21,050 --> 00:15:25,880
some local similarity to find out if the

375
00:15:24,140 --> 00:15:27,860
piece<font color="#CCCCCC"> of code is actually vulnerable you</font>

376
00:15:25,880 --> 00:15:29,360
have to do a lot more than<font color="#CCCCCC"> that</font><font color="#E5E5E5"> you</font><font color="#CCCCCC"> have</font>

377
00:15:27,860 --> 00:15:31,220
to find out how to get to that position

378
00:15:29,360 --> 00:15:33,230
and how to fulfill all the necessary

379
00:15:31,220 --> 00:15:34,910
preconditions<font color="#CCCCCC"> that</font><font color="#E5E5E5"> the path conditions</font>

380
00:15:33,230 --> 00:15:37,339
to get to that point and<font color="#E5E5E5"> to</font><font color="#CCCCCC"> actually</font>

381
00:15:34,910 --> 00:15:40,969
trigger the vulnerability we can do<font color="#E5E5E5"> that</font>

382
00:15:37,339 --> 00:15:43,850
at that point and let me give you a nice

383
00:15:40,970 --> 00:15:45,650
example for that it's patch code a lot

384
00:15:43,850 --> 00:15:47,540
of patch code is actually<font color="#E5E5E5"> just a piece</font>

385
00:15:45,650 --> 00:15:49,250
of vulnerable code surrounded by<font color="#CCCCCC"> a guard</font>

386
00:15:47,540 --> 00:15:52,459
statement and the guard statement

387
00:15:49,250 --> 00:15:55,220
basically says the path condition can

388
00:15:52,460 --> 00:15:58,160
never be mad but still a localized code

389
00:15:55,220 --> 00:15:59,750
similarity metric that finds this piece

390
00:15:58,160 --> 00:16:02,000
in the middle<font color="#E5E5E5"> as being similar is</font>

391
00:15:59,750 --> 00:16:05,600
perfectly<font color="#CCCCCC"> fine right that's its purpose</font>

392
00:16:02,000 --> 00:16:08,839
still this back can never be vulnerable

393
00:16:05,600 --> 00:16:10,910
which is a little<font color="#CCCCCC"> bit problematic but a</font>

394
00:16:08,839 --> 00:16:13,190
sad for<font color="#CCCCCC"> that special case of patch code</font>

395
00:16:10,910 --> 00:16:16,430
um I try to make<font color="#E5E5E5"> a little improvement</font><font color="#CCCCCC"> to</font>

396
00:16:13,190 --> 00:16:18,170
that you can just give<font color="#E5E5E5"> them that you</font>

397
00:16:16,430 --> 00:16:20,239
already<font color="#E5E5E5"> know that the code can be patch</font>

398
00:16:18,170 --> 00:16:23,180
and that you know the patch use two

399
00:16:20,240 --> 00:16:27,200
signatures<font color="#E5E5E5"> so you once try to find a</font>

400
00:16:23,180 --> 00:16:29,329
match for<font color="#CCCCCC"> the patch signature and if the</font>

401
00:16:27,200 --> 00:16:31,760
functioning question is more similar to

402
00:16:29,330 --> 00:16:33,680
the patched back signature than to<font color="#E5E5E5"> the</font>

403
00:16:31,760 --> 00:16:35,240
<font color="#E5E5E5">unpatch one it's likely</font><font color="#CCCCCC"> that it's also</font>

404
00:16:33,680 --> 00:16:37,760
patched if it's the other way around

405
00:16:35,240 --> 00:16:39,380
well you're in luck maybe<font color="#E5E5E5"> you find a</font>

406
00:16:37,760 --> 00:16:41,810
vulnerability but that is something that

407
00:16:39,380 --> 00:16:44,930
<font color="#E5E5E5">is really up for an expert to decide</font>

408
00:16:41,810 --> 00:16:51,829
it's just a hint<font color="#CCCCCC"> in the right direction</font>

409
00:16:44,930 --> 00:16:54,920
at this point you go so arm in summary

410
00:16:51,830 --> 00:16:57,110
um we work on binaries no source code

411
00:16:54,920 --> 00:16:59,449
also moves required we have a very

412
00:16:57,110 --> 00:17:03,080
<font color="#E5E5E5">fine-grained a sub function granularity</font>

413
00:16:59,450 --> 00:17:05,179
code similarity metric and by using that

414
00:17:03,080 --> 00:17:07,550
code similarity metric with the bug

415
00:17:05,179 --> 00:17:09,500
signature as input we can actually<font color="#CCCCCC"> use</font>

416
00:17:07,550 --> 00:17:11,119
that<font color="#E5E5E5"> for back search and maybe the</font>

417
00:17:09,500 --> 00:17:13,730
coolest thing which<font color="#CCCCCC"> is why it's at the</font>

418
00:17:11,119 --> 00:17:14,599
top<font color="#E5E5E5"> we can do so across architectures so</font>

419
00:17:13,730 --> 00:17:19,309
from X

420
00:17:14,599 --> 00:17:21,889
62 maps of from x86 or<font color="#E5E5E5"> MIPS or arm to</font>

421
00:17:19,309 --> 00:17:25,490
any of the other architectures that

422
00:17:21,890 --> 00:17:27,770
still works reasonably well so in the

423
00:17:25,490 --> 00:17:34,580
<font color="#E5E5E5">end we come up with cross architecture</font>

424
00:17:27,770 --> 00:17:38,090
back search in binary software and that

425
00:17:34,580 --> 00:17:48,850
<font color="#E5E5E5">concludes my talk and I'd be delighted</font>

426
00:17:38,090 --> 00:17:48,850
<font color="#E5E5E5">to answer all your questions</font><font color="#CCCCCC"> Thanks</font>

427
00:17:49,570 --> 00:17:58,399
doesn't have<font color="#CCCCCC"> to</font><font color="#E5E5E5"> be about this I'll</font>

428
00:17:51,559 --> 00:18:00,740
answer hey Alex am from<font color="#E5E5E5"> Qualcomm so it</font>

429
00:17:58,400 --> 00:18:02,780
<font color="#E5E5E5">seems like sort of your work you have to</font>

430
00:18:00,740 --> 00:18:04,789
have a bug that you're<font color="#CCCCCC"> looking for so</font>

431
00:18:02,780 --> 00:18:07,340
it's a targeted match have you looked at

432
00:18:04,789 --> 00:18:08,510
sort<font color="#E5E5E5"> of more open-ended basically then</font>

433
00:18:07,340 --> 00:18:09,770
diff kind of a thing here are two

434
00:18:08,510 --> 00:18:11,270
binaries you know in different

435
00:18:09,770 --> 00:18:14,120
architecture shown me similarities

436
00:18:11,270 --> 00:18:15,559
between the asset function etching is

437
00:18:14,120 --> 00:18:18,289
not our thing which is<font color="#E5E5E5"> what Ben if</font>

438
00:18:15,559 --> 00:18:20,389
<font color="#E5E5E5">usually does and we really try to focus</font>

439
00:18:18,289 --> 00:18:22,850
on box we already know about<font color="#E5E5E5"> but which</font>

440
00:18:20,390 --> 00:18:23,990
aren't fixed yet so we try to forget

441
00:18:22,850 --> 00:18:25,580
about<font color="#E5E5E5"> all the new ones who don't know</font>

442
00:18:23,990 --> 00:18:29,960
about yet it would be cool to have those

443
00:18:25,580 --> 00:18:32,240
that we know about actually fixed our

444
00:18:29,960 --> 00:18:34,190
back extrapolation capabilities are

445
00:18:32,240 --> 00:18:36,289
unfortunately less good than what you

446
00:18:34,190 --> 00:18:38,960
can<font color="#E5E5E5"> achieve in source code so we</font><font color="#CCCCCC"> are</font>

447
00:18:36,289 --> 00:18:40,908
more<font color="#CCCCCC"> likely to find actually this the</font>

448
00:18:38,960 --> 00:18:42,650
same bug in another situation then

449
00:18:40,909 --> 00:18:50,000
actually find a different<font color="#E5E5E5"> box so the</font>

450
00:18:42,650 --> 00:18:51,890
same thanks you're welcome hi<font color="#CCCCCC"> oh this</font><font color="#E5E5E5"> is</font>

451
00:18:50,000 --> 00:18:53,870
fish from UCSB and I think your work is

452
00:18:51,890 --> 00:18:56,570
very interesting and the thing that<font color="#CCCCCC"> is</font>

453
00:18:53,870 --> 00:18:58,070
you can you can arm compare functions

454
00:18:56,570 --> 00:18:59,990
across architectures are pretty

455
00:18:58,070 --> 00:19:02,000
promising one thing I want<font color="#CCCCCC"> to ask is</font>

456
00:18:59,990 --> 00:19:04,220
that forearm especially forearm they

457
00:19:02,000 --> 00:19:06,350
have a lot of like conditional operation

458
00:19:04,220 --> 00:19:08,270
operations basically means like a lot of

459
00:19:06,350 --> 00:19:10,340
<font color="#E5E5E5">the instructions are conditional like</font>

460
00:19:08,270 --> 00:19:12,340
they sometimes there are executed

461
00:19:10,340 --> 00:19:15,049
sometimes are not based on context and

462
00:19:12,340 --> 00:19:18,230
our experiment we see actually a lot of

463
00:19:15,049 --> 00:19:20,150
<font color="#E5E5E5">those on but I mean arm you see you see</font>

464
00:19:18,230 --> 00:19:22,150
many more basic blocks and other

465
00:19:20,150 --> 00:19:25,850
architectures because because<font color="#CCCCCC"> of those</font>

466
00:19:22,150 --> 00:19:26,900
conditional condition operations and how

467
00:19:25,850 --> 00:19:27,530
are you going to deal with<font color="#E5E5E5"> that if</font><font color="#CCCCCC"> you</font>

468
00:19:26,900 --> 00:19:30,740
are comparing

469
00:19:27,530 --> 00:19:32,030
<font color="#E5E5E5">them like based on basic blocks and</font>

470
00:19:30,740 --> 00:19:34,220
another question is that oh I'm sorry

471
00:19:32,030 --> 00:19:36,050
another concern is that I<font color="#E5E5E5"> think a rather</font>

472
00:19:34,220 --> 00:19:38,780
paper and then you talk<font color="#CCCCCC"> about how</font><font color="#E5E5E5"> to</font>

473
00:19:36,050 --> 00:19:40,520
pick on the range of the values for

474
00:19:38,780 --> 00:19:41,690
sampling and is from<font color="#E5E5E5"> minus one thousand</font>

475
00:19:40,520 --> 00:19:44,510
two<font color="#E5E5E5"> one thousand is there any special</font>

476
00:19:41,690 --> 00:19:46,880
meanings of that and if not what what is

477
00:19:44,510 --> 00:19:49,700
a<font color="#E5E5E5"> good way</font><font color="#CCCCCC"> to pick the arm sampling</font>

478
00:19:46,880 --> 00:19:51,560
ranges for relatives thank you<font color="#CCCCCC"> okay</font><font color="#E5E5E5"> I'll</font>

479
00:19:49,700 --> 00:19:54,050
start with<font color="#E5E5E5"> the second question which</font>

480
00:19:51,560 --> 00:19:57,320
concerns the range of the values we put

481
00:19:54,050 --> 00:19:59,870
into<font color="#CCCCCC"> it um we experimented a little bit</font>

482
00:19:57,320 --> 00:20:01,310
about<font color="#CCCCCC"> it we wanted to get like a pretty</font>

483
00:19:59,870 --> 00:20:03,949
dance field so we didn't want to<font color="#E5E5E5"> have a</font>

484
00:20:01,310 --> 00:20:06,500
lot of sparse values in it but apart

485
00:20:03,950 --> 00:20:08,840
<font color="#CCCCCC">from that we</font><font color="#E5E5E5"> simply chose the number and</font>

486
00:20:06,500 --> 00:20:11,150
went with it and acid worked reasonably

487
00:20:08,840 --> 00:20:14,990
well we kept it that's basically<font color="#E5E5E5"> if</font>

488
00:20:11,150 --> 00:20:16,700
there's no special<font color="#CCCCCC"> meaning to it to the</font>

489
00:20:14,990 --> 00:20:18,850
first answer we<font color="#E5E5E5"> actually found out that</font>

490
00:20:16,700 --> 00:20:22,400
<font color="#E5E5E5">MIPS has by far the most basic blocks</font>

491
00:20:18,850 --> 00:20:24,949
and that<font color="#E5E5E5"> actually x86 and arm are more</font>

492
00:20:22,400 --> 00:20:26,540
similar than x86 to<font color="#CCCCCC"> MIPS or arm to move</font>

493
00:20:24,950 --> 00:20:29,150
Scott so if you ever asked yourself as

494
00:20:26,540 --> 00:20:33,460
arm is still the risk environment most

495
00:20:29,150 --> 00:20:37,040
likely<font color="#CCCCCC"> not concerning the conditional</font>

496
00:20:33,460 --> 00:20:39,800
instructions on arm we can<font color="#E5E5E5"> just sample</font>

497
00:20:37,040 --> 00:20:43,159
so we can see a sampling value as an

498
00:20:39,800 --> 00:20:45,050
input to that binary condition so if you

499
00:20:43,160 --> 00:20:46,700
just sample it a little bit that

500
00:20:45,050 --> 00:20:49,010
conditionality will reflect in<font color="#CCCCCC"> the</font>

501
00:20:46,700 --> 00:20:53,510
output values I hope that<font color="#E5E5E5"> answers</font><font color="#CCCCCC"> your</font>

502
00:20:49,010 --> 00:20:58,820
questions awesome thanks welcome hey I'm

503
00:20:53,510 --> 00:21:00,530
yawn from UC Santa Barbara um from your

504
00:20:58,820 --> 00:21:02,870
paper I gather<font color="#CCCCCC"> that part of your</font>

505
00:21:00,530 --> 00:21:04,580
accuracy drop aside from compiler

506
00:21:02,870 --> 00:21:09,229
optimizations so forth is the cross

507
00:21:04,580 --> 00:21:12,860
architecture part yeah and did<font color="#CCCCCC"> you look</font>

508
00:21:09,230 --> 00:21:15,050
into maybe grabbing samples of different

509
00:21:12,860 --> 00:21:16,699
source code for example compiling it for

510
00:21:15,050 --> 00:21:21,230
different architectures and doing an

511
00:21:16,700 --> 00:21:23,660
inner architecture bug search just just

512
00:21:21,230 --> 00:21:25,820
single architecture but since you have

513
00:21:23,660 --> 00:21:27,830
<font color="#E5E5E5">so I'll give you a partial</font><font color="#CCCCCC"> answer and</font>

514
00:21:25,820 --> 00:21:31,070
<font color="#E5E5E5">then ask it to rephrase what what came</font>

515
00:21:27,830 --> 00:21:33,020
after that because um so in all our

516
00:21:31,070 --> 00:21:34,700
experiments except the<font color="#E5E5E5"> one for different</font>

517
00:21:33,020 --> 00:21:36,770
optimization levels we<font color="#E5E5E5"> actually took</font>

518
00:21:34,700 --> 00:21:38,360
code we found in the<font color="#CCCCCC"> wild as it is I</font>

519
00:21:36,770 --> 00:21:40,010
<font color="#CCCCCC">don't</font><font color="#E5E5E5"> know what compiler so they used</font>

520
00:21:38,360 --> 00:21:40,879
right if they happen to use a similar

521
00:21:40,010 --> 00:21:42,650
one

522
00:21:40,880 --> 00:21:45,380
the better for us but I<font color="#E5E5E5"> really don't</font>

523
00:21:42,650 --> 00:21:48,650
know we haven't<font color="#CCCCCC"> checked that that given</font>

524
00:21:45,380 --> 00:21:50,120
please answer please refresh a question

525
00:21:48,650 --> 00:21:52,130
regarding the inner architecture thing I

526
00:21:50,120 --> 00:21:55,280
didn't quite get that so yes if<font color="#E5E5E5"> you look</font>

527
00:21:52,130 --> 00:21:57,350
at code in the wild and you look at MIPS

528
00:21:55,280 --> 00:21:58,820
router code right and you<font color="#E5E5E5"> know some is</font>

529
00:21:57,350 --> 00:22:02,689
vulnerable and then you look at other

530
00:21:58,820 --> 00:22:04,460
<font color="#E5E5E5">MIPS routers to check against them right</font>

531
00:22:02,690 --> 00:22:06,470
instead<font color="#CCCCCC"> of looking</font><font color="#E5E5E5"> for arm routers</font>

532
00:22:04,460 --> 00:22:09,920
because there's plenty of you know arm

533
00:22:06,470 --> 00:22:11,660
code to check on code against ok yeah so

534
00:22:09,920 --> 00:22:15,350
I<font color="#E5E5E5"> guess the question is do you feel that</font>

535
00:22:11,660 --> 00:22:18,680
the cross architecture part is needed or

536
00:22:15,350 --> 00:22:20,419
so in theory what let's say you have the

537
00:22:18,680 --> 00:22:22,730
source code right and you have it for

538
00:22:20,420 --> 00:22:24,260
<font color="#E5E5E5">usually compiled for x86 and you want to</font>

539
00:22:22,730 --> 00:22:26,990
see if<font color="#CCCCCC"> that specific back in the source</font>

540
00:22:24,260 --> 00:22:28,910
code<font color="#E5E5E5"> is also in some MIPS road or</font>

541
00:22:26,990 --> 00:22:30,590
whatever code right what you could do is

542
00:22:28,910 --> 00:22:32,900
just compile the source code to myths

543
00:22:30,590 --> 00:22:34,850
and then check<font color="#CCCCCC"> mips to get snips but you</font>

544
00:22:32,900 --> 00:22:38,500
<font color="#E5E5E5">don't always have the sauce go do you so</font>

545
00:22:34,850 --> 00:22:38,500
that simply doesn't work cool

