1
00:00:00,260 --> 00:00:05,370
what can<font color="#E5E5E5"> we do to build more secure</font>

2
00:00:02,429 --> 00:00:08,189
systems of course the research

3
00:00:05,370 --> 00:00:10,260
literature researchers and many people

4
00:00:08,189 --> 00:00:11,519
<font color="#E5E5E5">in this room have tried to come up with</font>

5
00:00:10,260 --> 00:00:14,730
lots of different answers for this

6
00:00:11,519 --> 00:00:16,079
question over the years but here<font color="#E5E5E5"> alektra</font>

7
00:00:14,730 --> 00:00:18,300
focus our attention on one particular

8
00:00:16,079 --> 00:00:22,589
class of mechanisms for improving

9
00:00:18,300 --> 00:00:24,539
security reference monitors so the<font color="#E5E5E5"> idea</font>

10
00:00:22,590 --> 00:00:26,400
is conceptually very simple we have some

11
00:00:24,539 --> 00:00:29,220
system that is running<font color="#E5E5E5"> some computation</font>

12
00:00:26,400 --> 00:00:30,570
to make it more<font color="#CCCCCC"> secure we're going</font><font color="#E5E5E5"> to</font>

13
00:00:29,220 --> 00:00:33,149
<font color="#E5E5E5">add a</font><font color="#CCCCCC"> new component into the mix of</font><font color="#E5E5E5"> the</font>

14
00:00:30,570 --> 00:00:35,309
monitor which is going<font color="#E5E5E5"> to inspect each</font>

15
00:00:33,149 --> 00:00:37,710
action that our system tries to perform

16
00:00:35,309 --> 00:00:39,660
to decide whether it's<font color="#E5E5E5"> safe or not so</font>

17
00:00:37,710 --> 00:00:41,670
it's usually going to allow or system to

18
00:00:39,660 --> 00:00:43,230
do its thing but it might<font color="#CCCCCC"> be the</font><font color="#E5E5E5"> case</font>

19
00:00:41,670 --> 00:00:45,420
that it detects that the system is about

20
00:00:43,230 --> 00:00:47,160
to do something dangerous in which case

21
00:00:45,420 --> 00:00:51,149
it will just intervene to pervade

22
00:00:47,160 --> 00:00:52,620
greater harm from happening reference

23
00:00:51,149 --> 00:00:54,480
monitors are great they<font color="#E5E5E5"> have many</font>

24
00:00:52,620 --> 00:00:57,360
benefits but they do suffer from one

25
00:00:54,480 --> 00:01:00,180
pass key problem and this problem is

26
00:00:57,360 --> 00:01:02,760
<font color="#E5E5E5">that they're usually various level this</font>

27
00:01:00,180 --> 00:01:05,459
often happens because these monitors are

28
00:01:02,760 --> 00:01:07,798
implemented in software which has led

29
00:01:05,459 --> 00:01:09,298
some researchers to wonder well maybe we

30
00:01:07,799 --> 00:01:12,600
can<font color="#CCCCCC"> make these</font><font color="#E5E5E5"> things faster by adding</font>

31
00:01:09,299 --> 00:01:15,270
some<font color="#CCCCCC"> hardware support for them right so</font>

32
00:01:12,600 --> 00:01:17,039
now our picture looks<font color="#CCCCCC"> like this instead</font>

33
00:01:15,270 --> 00:01:18,929
<font color="#E5E5E5">of having an extra layer software to</font>

34
00:01:17,040 --> 00:01:21,540
implement or monitor will have a program

35
00:01:18,930 --> 00:01:22,950
directly into the hardware<font color="#E5E5E5"> and because</font>

36
00:01:21,540 --> 00:01:25,200
our system does not<font color="#E5E5E5"> suffer from the</font>

37
00:01:22,950 --> 00:01:27,000
extra software overhead anymore it can

38
00:01:25,200 --> 00:01:31,200
do much more than what it used to be

39
00:01:27,000 --> 00:01:33,210
able<font color="#E5E5E5"> to with a software monitor so this</font>

40
00:01:31,200 --> 00:01:35,970
<font color="#CCCCCC">is great but now we run into another</font>

41
00:01:33,210 --> 00:01:38,548
drawback which is that<font color="#E5E5E5"> Harbor is much</font>

42
00:01:35,970 --> 00:01:41,729
harder to redesign and redeploy than

43
00:01:38,549 --> 00:01:43,229
software so if we do if we come up<font color="#CCCCCC"> with</font>

44
00:01:41,729 --> 00:01:45,179
special hardware support for a

45
00:01:43,229 --> 00:01:47,939
particular monitor that is hardwired

46
00:01:45,180 --> 00:01:50,130
into<font color="#E5E5E5"> our system we may have adequate</font>

47
00:01:47,939 --> 00:01:52,559
support for defending yourself against a

48
00:01:50,130 --> 00:01:54,960
particular class<font color="#E5E5E5"> of threats but tomorrow</font>

49
00:01:52,560 --> 00:01:58,469
a new<font color="#CCCCCC"> class of attacks will show up and</font>

50
00:01:54,960 --> 00:02:01,770
will render our mechanism useless right

51
00:01:58,469 --> 00:02:05,399
so this is<font color="#CCCCCC"> not very good the</font><font color="#E5E5E5"> scenario is</font>

52
00:02:01,770 --> 00:02:07,259
what motivated us to work on this idea

53
00:02:05,399 --> 00:02:09,860
<font color="#CCCCCC">of micro policies that I'm here</font><font color="#E5E5E5"> to tell</font>

54
00:02:07,259 --> 00:02:09,860
you<font color="#CCCCCC"> about today</font>

55
00:02:10,550 --> 00:02:16,820
the micro policies are programming model

56
00:02:13,280 --> 00:02:19,010
for reference monitors that is<font color="#CCCCCC"> designed</font>

57
00:02:16,820 --> 00:02:22,549
to be flexible and capable<font color="#E5E5E5"> of delivering</font>

58
00:02:19,010 --> 00:02:24,590
concrete security guarantees but it can

59
00:02:22,550 --> 00:02:28,400
also be efficiently executed with some

60
00:02:24,590 --> 00:02:30,680
special hardware support<font color="#E5E5E5"> you're in this</font>

61
00:02:28,400 --> 00:02:32,720
paper we<font color="#E5E5E5"> present this micro policy</font>

62
00:02:30,680 --> 00:02:34,790
programming model and evaluated under

63
00:02:32,720 --> 00:02:37,460
the three design goals that I just<font color="#E5E5E5"> laid</font>

64
00:02:34,790 --> 00:02:40,040
out but you demonstrated the mechanism

65
00:02:37,460 --> 00:02:42,890
is flexible we show how we can use it<font color="#E5E5E5"> to</font>

66
00:02:40,040 --> 00:02:44,150
program a diverse set of<font color="#E5E5E5"> four policies</font>

67
00:02:42,890 --> 00:02:48,559
that have received attention of the

68
00:02:44,150 --> 00:02:50,270
research literature once we do this you

69
00:02:48,560 --> 00:02:51,950
might ask yourself but wait a second you

70
00:02:50,270 --> 00:02:54,440
just introduced this programming model

71
00:02:51,950 --> 00:02:55,880
you program all<font color="#CCCCCC"> of these policies how do</font>

72
00:02:54,440 --> 00:02:58,850
you<font color="#E5E5E5"> know that you</font><font color="#CCCCCC"> got these policies</font>

73
00:02:55,880 --> 00:03:01,010
right how do you know how they're

74
00:02:58,850 --> 00:03:03,430
improving the security of your system

75
00:03:01,010 --> 00:03:06,140
well to<font color="#E5E5E5"> answer this</font><font color="#CCCCCC"> question we</font>

76
00:03:03,430 --> 00:03:07,970
formalize the micro policy programming

77
00:03:06,140 --> 00:03:09,529
model using the proof assistant and

78
00:03:07,970 --> 00:03:11,510
then use the formalization should

79
00:03:09,530 --> 00:03:13,700
elaborate micro policy specifications

80
00:03:11,510 --> 00:03:15,769
for each of the micro policies that we

81
00:03:13,700 --> 00:03:18,799
implemented connecting one to the other

82
00:03:15,770 --> 00:03:21,650
via a machine check proof this machine

83
00:03:18,800 --> 00:03:23,660
check proof ensures that each micro

84
00:03:21,650 --> 00:03:25,220
policy implementation is capable of

85
00:03:23,660 --> 00:03:26,840
delivering the security guarantees

86
00:03:25,220 --> 00:03:30,410
embodied in<font color="#CCCCCC"> the corresponding</font>

87
00:03:26,840 --> 00:03:33,620
specification as for<font color="#E5E5E5"> the last design</font>

88
00:03:30,410 --> 00:03:36,230
goal performance we<font color="#E5E5E5"> present a formal</font>

89
00:03:33,620 --> 00:03:38,030
model of a harder extension that<font color="#E5E5E5"> is</font>

90
00:03:36,230 --> 00:03:40,100
designed<font color="#E5E5E5"> to accelerate this programming</font>

91
00:03:38,030 --> 00:03:41,360
model which we call the pump for a

92
00:03:40,100 --> 00:03:44,209
programmable unit for metadata

93
00:03:41,360 --> 00:03:46,520
processing and although we<font color="#E5E5E5"> do not</font>

94
00:03:44,209 --> 00:03:48,830
evaluate the performance of the pump in

95
00:03:46,520 --> 00:03:51,130
this paper I should<font color="#E5E5E5"> let</font><font color="#CCCCCC"> you know that we</font>

96
00:03:48,830 --> 00:03:53,330
have many collaborators working in

97
00:03:51,130 --> 00:03:56,090
improving the<font color="#E5E5E5"> design of the pump</font><font color="#CCCCCC"> in</font>

98
00:03:53,330 --> 00:03:57,160
testing it on benchmarks so if you're

99
00:03:56,090 --> 00:03:59,930
<font color="#CCCCCC">interested in</font><font color="#E5E5E5"> learning more about</font>

100
00:03:57,160 --> 00:04:01,520
<font color="#E5E5E5">microarchitecture details simulations</font>

101
00:03:59,930 --> 00:04:04,190
and performance figures I can refer to<font color="#CCCCCC"> a</font>

102
00:04:01,520 --> 00:04:06,380
recent<font color="#CCCCCC"> S Plus 2015 paper where we showed</font>

103
00:04:04,190 --> 00:04:09,410
that micro policies can be accelerated

104
00:04:06,380 --> 00:04:13,190
using the pump and executed with runtime

105
00:04:09,410 --> 00:04:15,140
overhead of less than<font color="#E5E5E5"> ten percent so</font>

106
00:04:13,190 --> 00:04:18,048
what exactly<font color="#E5E5E5"> is this programming model</font>

107
00:04:15,140 --> 00:04:20,060
that have been talking<font color="#CCCCCC"> about well when</font>

108
00:04:18,048 --> 00:04:22,700
you're programming reference monitors

109
00:04:20,060 --> 00:04:23,990
generally you<font color="#CCCCCC"> can</font><font color="#E5E5E5"> allow yourself to</font>

110
00:04:22,700 --> 00:04:26,569
inspect the<font color="#CCCCCC"> program's</font>

111
00:04:23,990 --> 00:04:28,490
<font color="#E5E5E5">in arbitrary ways right this is good</font>

112
00:04:26,569 --> 00:04:30,229
<font color="#E5E5E5">because it means that there's lots of</font>

113
00:04:28,490 --> 00:04:32,180
things that we can implement using

114
00:04:30,229 --> 00:04:33,560
reference monitors but<font color="#E5E5E5"> it does mean that</font>

115
00:04:32,180 --> 00:04:35,810
if we're trying to come up with a fish

116
00:04:33,560 --> 00:04:37,490
and harder support for it this will be

117
00:04:35,810 --> 00:04:40,610
much harder because the model is just

118
00:04:37,490 --> 00:04:42,949
too general so with micro policies will

119
00:04:40,610 --> 00:04:45,340
be willing to<font color="#E5E5E5"> trade in some expressive</font>

120
00:04:42,949 --> 00:04:47,300
power to make our lives easier when

121
00:04:45,340 --> 00:04:50,359
officially supporting these things in

122
00:04:47,300 --> 00:04:54,860
<font color="#E5E5E5">hardware and the</font><font color="#CCCCCC"> way micro policies work</font>

123
00:04:50,360 --> 00:04:56,509
is with this<font color="#CCCCCC"> idea of computing on</font>

124
00:04:54,860 --> 00:04:58,699
metadata associated with the program

125
00:04:56,509 --> 00:05:01,400
they're monitoring now let me<font color="#CCCCCC"> explain</font>

126
00:04:58,699 --> 00:05:03,020
what I mean by this so suppose that I

127
00:05:01,400 --> 00:05:06,020
have a processor that<font color="#CCCCCC"> has some internal</font>

128
00:05:03,020 --> 00:05:07,940
state as set of registers as a memory

129
00:05:06,020 --> 00:05:10,340
with a program<font color="#E5E5E5"> that is running and a</font>

130
00:05:07,940 --> 00:05:12,500
program counter so in the micro policies

131
00:05:10,340 --> 00:05:13,880
world each piece<font color="#CCCCCC"> of data in the system</font>

132
00:05:12,500 --> 00:05:16,430
<font color="#CCCCCC">is going</font><font color="#E5E5E5"> to be enriched with the</font>

133
00:05:13,880 --> 00:05:20,030
metadata tag that describes the space of

134
00:05:16,430 --> 00:05:22,099
<font color="#E5E5E5">that is somehow as far as the user level</font>

135
00:05:20,030 --> 00:05:24,770
code is concerned this tag is

136
00:05:22,099 --> 00:05:26,840
indivisible from the corresponding

137
00:05:24,770 --> 00:05:30,560
payload part so the user level code

138
00:05:26,840 --> 00:05:34,669
cannot separately address these tags

139
00:05:30,560 --> 00:05:36,409
cannot inspect them in any way the only

140
00:05:34,669 --> 00:05:38,659
part of<font color="#E5E5E5"> the system</font><font color="#CCCCCC"> that is allowed</font><font color="#E5E5E5"> to</font>

141
00:05:36,409 --> 00:05:41,150
interact with<font color="#E5E5E5"> these tags directly is our</font>

142
00:05:38,659 --> 00:05:43,849
monitor and this monitor is supplied by

143
00:05:41,150 --> 00:05:46,370
<font color="#E5E5E5">a policy designer as a piece of code</font>

144
00:05:43,849 --> 00:05:49,340
that<font color="#CCCCCC"> is going to analyze these tags in</font>

145
00:05:46,370 --> 00:05:50,930
some way<font color="#E5E5E5"> and it's up</font><font color="#CCCCCC"> to the monitor</font>

146
00:05:49,340 --> 00:05:54,169
effectively to decide<font color="#CCCCCC"> whether these tags</font>

147
00:05:50,930 --> 00:05:56,960
mean I should emphasize here that when

148
00:05:54,169 --> 00:05:58,669
doing so we give designers lots of

149
00:05:56,960 --> 00:06:00,500
freedom<font color="#CCCCCC"> to decide whether these tags me</font>

150
00:05:58,669 --> 00:06:02,810
because at the implementation level

151
00:06:00,500 --> 00:06:05,479
these tags are actually pointer sized

152
00:06:02,810 --> 00:06:08,030
words which<font color="#CCCCCC"> mean that</font><font color="#E5E5E5"> can that</font><font color="#CCCCCC"> they can</font>

153
00:06:05,479 --> 00:06:10,900
be used<font color="#E5E5E5"> to reference arbitrarily complex</font>

154
00:06:08,030 --> 00:06:13,580
data structures in memory for instance

155
00:06:10,900 --> 00:06:15,409
so what does<font color="#E5E5E5"> this monitor do well</font>

156
00:06:13,580 --> 00:06:17,359
suppose that we try<font color="#CCCCCC"> to execute some</font>

157
00:06:15,409 --> 00:06:19,219
instruction in our program first so we

158
00:06:17,360 --> 00:06:21,919
could<font color="#E5E5E5"> be trying to add two registers r1</font>

159
00:06:19,219 --> 00:06:25,190
and r2 and put their result in<font color="#E5E5E5"> our three</font>

160
00:06:21,919 --> 00:06:28,460
hour monitor is going to look at<font color="#E5E5E5"> the</font>

161
00:06:25,190 --> 00:06:31,219
tags<font color="#CCCCCC"> that are related</font><font color="#E5E5E5"> to this particular</font>

162
00:06:28,460 --> 00:06:33,260
instruction so is going<font color="#E5E5E5"> to analyze the</font>

163
00:06:31,219 --> 00:06:34,339
tag on<font color="#E5E5E5"> the program counter it's going to</font>

164
00:06:33,260 --> 00:06:35,690
<font color="#E5E5E5">look at the tag on the current</font>

165
00:06:34,339 --> 00:06:37,760
instruction that we're executing and

166
00:06:35,690 --> 00:06:39,290
it's going<font color="#E5E5E5"> to look at all the tags</font>

167
00:06:37,760 --> 00:06:41,690
of the arguments<font color="#CCCCCC"> that this instruction</font>

168
00:06:39,290 --> 00:06:43,310
might take and slowly based on this

169
00:06:41,690 --> 00:06:45,730
information is going<font color="#E5E5E5"> to decide what to</font>

170
00:06:43,310 --> 00:06:48,470
do so it could<font color="#CCCCCC"> be the</font><font color="#E5E5E5"> case for instance</font>

171
00:06:45,730 --> 00:06:50,060
that our monitor allows this operation

172
00:06:48,470 --> 00:06:53,150
to happen in which<font color="#E5E5E5"> case it will produce</font>

173
00:06:50,060 --> 00:06:56,540
a set of tags to be used on the results

174
00:06:53,150 --> 00:06:58,310
of this instruction so we'll have<font color="#E5E5E5"> a new</font>

175
00:06:56,540 --> 00:06:59,870
program counter in the next cycle so

176
00:06:58,310 --> 00:07:01,700
we'll update the tag on<font color="#E5E5E5"> the program</font>

177
00:06:59,870 --> 00:07:04,910
counter and we just destroyed a new

178
00:07:01,700 --> 00:07:06,200
Valley on our three the result of<font color="#CCCCCC"> our</font>

179
00:07:04,910 --> 00:07:08,810
some so we're going to<font color="#CCCCCC"> update the tag of</font>

180
00:07:06,200 --> 00:07:11,270
<font color="#E5E5E5">that too but again it could also be the</font>

181
00:07:08,810 --> 00:07:13,100
case<font color="#E5E5E5"> that upon inspecting these tags are</font>

182
00:07:11,270 --> 00:07:15,740
monitor decides that we're<font color="#E5E5E5"> about to do</font>

183
00:07:13,100 --> 00:07:18,650
something<font color="#E5E5E5"> dangerous and it prevents this</font>

184
00:07:15,740 --> 00:07:20,960
dangerous thing from happening so now

185
00:07:18,650 --> 00:07:23,120
<font color="#CCCCCC">that we have a</font><font color="#E5E5E5"> high</font><font color="#CCCCCC"> level ad of how this</font>

186
00:07:20,960 --> 00:07:26,060
programming model works let's turn our

187
00:07:23,120 --> 00:07:27,710
attention<font color="#CCCCCC"> to our design goals first</font>

188
00:07:26,060 --> 00:07:30,230
thing that we wanted to<font color="#E5E5E5"> know is is this</font>

189
00:07:27,710 --> 00:07:33,020
thing actually flexible well to answer

190
00:07:30,230 --> 00:07:34,940
<font color="#E5E5E5">this question in this paper we</font><font color="#CCCCCC"> show how</font>

191
00:07:33,020 --> 00:07:37,250
we can use this mechanism to implement a

192
00:07:34,940 --> 00:07:38,930
diverse set of four interesting policies

193
00:07:37,250 --> 00:07:41,180
so we have a micro policies

194
00:07:38,930 --> 00:07:43,160
implementation for doing control<font color="#E5E5E5"> flow</font>

195
00:07:41,180 --> 00:07:44,480
<font color="#E5E5E5">integrity we have a micro policy</font>

196
00:07:43,160 --> 00:07:46,640
implementation for doing software

197
00:07:44,480 --> 00:07:49,160
compartmentalization inspired<font color="#E5E5E5"> by wha B's</font>

198
00:07:46,640 --> 00:07:51,500
model and software fault isolation we

199
00:07:49,160 --> 00:07:53,240
have a micro policy for doing memory

200
00:07:51,500 --> 00:07:55,580
safety of dynamically allocated heap

201
00:07:53,240 --> 00:07:59,390
regions and also a memory safety for

202
00:07:55,580 --> 00:08:01,070
doing dynamic ceiling and because we're

203
00:07:59,390 --> 00:08:03,260
able to implement all of<font color="#E5E5E5"> those with</font>

204
00:08:01,070 --> 00:08:06,320
micro policies mechanism this makes it

205
00:08:03,260 --> 00:08:09,200
leaves us very confident in how flexible

206
00:08:06,320 --> 00:08:12,050
this mechanism is to give you an idea<font color="#E5E5E5"> of</font>

207
00:08:09,200 --> 00:08:15,560
how<font color="#E5E5E5"> this works let's consider how</font><font color="#CCCCCC"> we can</font>

208
00:08:12,050 --> 00:08:18,320
use this to implement a micro policy

209
00:08:15,560 --> 00:08:20,480
control<font color="#E5E5E5"> for integrity so the first</font>

210
00:08:18,320 --> 00:08:23,180
observation that we have is that because

211
00:08:20,480 --> 00:08:25,010
<font color="#E5E5E5">we have these tags in memory we're</font>

212
00:08:23,180 --> 00:08:27,230
<font color="#CCCCCC">already able to</font><font color="#E5E5E5"> differentiate code from</font>

213
00:08:25,010 --> 00:08:29,180
data assume<font color="#CCCCCC"> they have</font><font color="#E5E5E5"> some trusted</font>

214
00:08:27,230 --> 00:08:31,280
loader that<font color="#E5E5E5"> upon loading the program is</font>

215
00:08:29,180 --> 00:08:32,570
able to mark all the<font color="#E5E5E5"> words in memory</font>

216
00:08:31,280 --> 00:08:34,760
that correspond to the code of our

217
00:08:32,570 --> 00:08:37,760
program s code and<font color="#E5E5E5"> everything else is</font>

218
00:08:34,760 --> 00:08:40,069
data and because our monitor has this

219
00:08:37,760 --> 00:08:41,990
information available it can already

220
00:08:40,070 --> 00:08:44,390
implement some interesting policies on

221
00:08:41,990 --> 00:08:46,760
that so for<font color="#E5E5E5"> instance if our monitor sees</font>

222
00:08:44,390 --> 00:08:49,490
that the current tag on the instruction

223
00:08:46,760 --> 00:08:50,360
is data is going<font color="#E5E5E5"> to halt the program</font>

224
00:08:49,490 --> 00:08:51,440
because of this means that

225
00:08:50,360 --> 00:08:54,110
we're<font color="#E5E5E5"> trying to execute that which</font>

226
00:08:51,440 --> 00:08:55,970
shouldn't be loud and we could also

227
00:08:54,110 --> 00:08:57,670
stipulate that when trying to store to a

228
00:08:55,970 --> 00:09:00,170
memory location that is marked as<font color="#E5E5E5"> code</font>

229
00:08:57,670 --> 00:09:01,399
we're also going to halt the process

230
00:09:00,170 --> 00:09:04,550
because<font color="#CCCCCC"> we shouldn't be</font><font color="#E5E5E5"> allowed to</font>

231
00:09:01,399 --> 00:09:06,050
overwrite code because these tags can be

232
00:09:04,550 --> 00:09:08,359
arbitrarily rich we can do much more

233
00:09:06,050 --> 00:09:10,130
than this right so suppose they have

234
00:09:08,360 --> 00:09:13,010
some control flow graph for this program

235
00:09:10,130 --> 00:09:15,230
that we're executing it could be for

236
00:09:13,010 --> 00:09:18,980
instance the<font color="#E5E5E5"> result of the compiler</font><font color="#CCCCCC"> that</font>

237
00:09:15,230 --> 00:09:20,540
produced the binary for the program what

238
00:09:18,980 --> 00:09:22,279
we do<font color="#E5E5E5"> with that is that we're going to</font>

239
00:09:20,540 --> 00:09:23,990
<font color="#E5E5E5">take note identifier is the correspond</font>

240
00:09:22,279 --> 00:09:26,630
to each note in this control photograph

241
00:09:23,990 --> 00:09:30,339
we're going<font color="#CCCCCC"> to associate these nodes to</font>

242
00:09:26,630 --> 00:09:32,180
the tags in our instructions

243
00:09:30,339 --> 00:09:33,709
additionally we're going to mark the

244
00:09:32,180 --> 00:09:36,050
program counter with the identifier of

245
00:09:33,709 --> 00:09:38,660
the last instruction that we executed

246
00:09:36,050 --> 00:09:41,899
because once we do this our monitor has

247
00:09:38,660 --> 00:09:43,490
all the information<font color="#E5E5E5"> it needs to see</font>

248
00:09:41,899 --> 00:09:46,490
which edge in this control flow graph

249
00:09:43,490 --> 00:09:49,399
are trying to traverse so for<font color="#E5E5E5"> instance</font>

250
00:09:46,490 --> 00:09:52,339
if Ramona to detect is that the current

251
00:09:49,399 --> 00:09:54,740
PC tag is<font color="#CCCCCC"> four and that</font><font color="#E5E5E5"> the current</font>

252
00:09:52,339 --> 00:09:56,480
instruction tag is code five this means

253
00:09:54,740 --> 00:09:58,670
according to our convention that we're

254
00:09:56,480 --> 00:10:00,500
trying<font color="#E5E5E5"> to go from four to five and this</font>

255
00:09:58,670 --> 00:10:02,930
is<font color="#E5E5E5"> okay because it is in our control</font>

256
00:10:00,500 --> 00:10:05,240
<font color="#CCCCCC">flow graph but if we try to do something</font>

257
00:10:02,930 --> 00:10:07,339
<font color="#E5E5E5">else as the result of some programming</font>

258
00:10:05,240 --> 00:10:09,529
error or some attack like going from one

259
00:10:07,339 --> 00:10:11,180
to five our monitor will be able<font color="#E5E5E5"> to say</font>

260
00:10:09,529 --> 00:10:15,829
that<font color="#CCCCCC"> this is</font><font color="#E5E5E5"> not okay because this is</font>

261
00:10:11,180 --> 00:10:18,529
not part<font color="#E5E5E5"> of the control flow graph so</font>

262
00:10:15,829 --> 00:10:20,689
good we've answer the question of

263
00:10:18,529 --> 00:10:22,550
flexibility but<font color="#E5E5E5"> now we have these</font>

264
00:10:20,690 --> 00:10:25,399
policies that are implemented with these

265
00:10:22,550 --> 00:10:27,680
tag analysis and how do we<font color="#E5E5E5"> know</font><font color="#CCCCCC"> that</font>

266
00:10:25,399 --> 00:10:29,060
they are correct<font color="#E5E5E5"> how do we</font><font color="#CCCCCC"> know</font><font color="#E5E5E5"> how</font>

267
00:10:27,680 --> 00:10:32,420
they're improving the security of our

268
00:10:29,060 --> 00:10:33,619
system well as I mentioned<font color="#CCCCCC"> before we're</font>

269
00:10:32,420 --> 00:10:35,540
going to use this interesting who will

270
00:10:33,620 --> 00:10:37,490
call<font color="#E5E5E5"> the Rufus system which if</font>

271
00:10:35,540 --> 00:10:38,930
you're not familiar with you can think

272
00:10:37,490 --> 00:10:41,089
<font color="#E5E5E5">of as being a programming language for</font>

273
00:10:38,930 --> 00:10:42,649
mathematics so you can use it<font color="#E5E5E5"> to write</font>

274
00:10:41,089 --> 00:10:45,800
<font color="#CCCCCC">down precise mathematical definitions</font>

275
00:10:42,649 --> 00:10:47,390
and prove things about them this paper

276
00:10:45,800 --> 00:10:49,370
uses the programming language to define

277
00:10:47,390 --> 00:10:52,279
what the micro policy programming model

278
00:10:49,370 --> 00:10:54,350
is so our definition looks like this we

279
00:10:52,279 --> 00:10:56,449
start by<font color="#E5E5E5"> defining a simplified RISC</font>

280
00:10:54,350 --> 00:10:58,010
<font color="#CCCCCC">processer whose features are supposed to</font>

281
00:10:56,449 --> 00:10:59,359
be representative of common RISC

282
00:10:58,010 --> 00:11:02,000
processors that you find out there in

283
00:10:59,360 --> 00:11:03,020
the market like a mips or an alpha for

284
00:11:02,000 --> 00:11:08,840
instance

285
00:11:03,020 --> 00:11:11,930
and then we<font color="#E5E5E5"> don't you enrich the data</font>

286
00:11:08,840 --> 00:11:14,960
pieces of this processor with tags and a

287
00:11:11,930 --> 00:11:16,969
monitor<font color="#CCCCCC"> that are</font><font color="#E5E5E5"> defined by the user the</font>

288
00:11:14,960 --> 00:11:20,450
micro policy designer which work as I

289
00:11:16,970 --> 00:11:24,170
explained before when supplying these

290
00:11:20,450 --> 00:11:26,510
tags the policy designer is going to use

291
00:11:24,170 --> 00:11:27,290
arbitrary programs which are

292
00:11:26,510 --> 00:11:29,689
written in this very<font color="#E5E5E5"> high-level</font>

293
00:11:27,290 --> 00:11:32,270
<font color="#E5E5E5">functional programming language and this</font>

294
00:11:29,690 --> 00:11:34,850
is good because<font color="#CCCCCC"> it gives the policy</font>

295
00:11:32,270 --> 00:11:37,220
designer a lot of freedom<font color="#E5E5E5"> to describe</font>

296
00:11:34,850 --> 00:11:39,200
their policy and reason about them so

297
00:11:37,220 --> 00:11:41,000
for<font color="#E5E5E5"> instance on the screen there is an</font>

298
00:11:39,200 --> 00:11:42,440
excerpt of a piece of<font color="#E5E5E5"> code that you</font>

299
00:11:41,000 --> 00:11:43,880
could<font color="#CCCCCC"> use to implement a simplified</font>

300
00:11:42,440 --> 00:11:46,760
version<font color="#CCCCCC"> of the control for integrity</font>

301
00:11:43,880 --> 00:11:49,160
micro policies that I just<font color="#E5E5E5"> mentioned we</font>

302
00:11:46,760 --> 00:11:51,260
redefine a data type of tags to be used

303
00:11:49,160 --> 00:11:53,000
in memory along with<font color="#CCCCCC"> the function</font>

304
00:11:51,260 --> 00:11:56,540
operating of those tags to decide

305
00:11:53,000 --> 00:12:00,050
whether a given machine step is allowed

306
00:11:56,540 --> 00:12:01,370
or<font color="#CCCCCC"> not and once you have these policies</font>

307
00:12:00,050 --> 00:12:04,370
implemented we can turn our attention to

308
00:12:01,370 --> 00:12:06,260
their specifications right these

309
00:12:04,370 --> 00:12:09,290
specifications are ultimately going to

310
00:12:06,260 --> 00:12:11,480
give our threat model for this<font color="#E5E5E5"> system</font>

311
00:12:09,290 --> 00:12:13,400
sonar model we<font color="#CCCCCC"> have we typically</font>

312
00:12:11,480 --> 00:12:16,040
consider that the attacker controls the

313
00:12:13,400 --> 00:12:18,140
input to our system<font color="#CCCCCC"> but does not have</font>

314
00:12:16,040 --> 00:12:21,319
any physical access to the machine where

315
00:12:18,140 --> 00:12:22,400
the<font color="#E5E5E5"> program is running I should also let</font>

316
00:12:21,320 --> 00:12:24,550
you know that there<font color="#CCCCCC"> are a few things</font>

317
00:12:22,400 --> 00:12:27,020
<font color="#E5E5E5">that we don't model in this</font>

318
00:12:24,550 --> 00:12:29,089
<font color="#E5E5E5">formalization so we don't for instance</font>

319
00:12:27,020 --> 00:12:31,610
consider erratic DMA controllers we

320
00:12:29,090 --> 00:12:33,770
don't consider timing issues but

321
00:12:31,610 --> 00:12:35,990
anything else<font color="#E5E5E5"> the fits within this model</font>

322
00:12:33,770 --> 00:12:39,230
you can reason about and formulate as a

323
00:12:35,990 --> 00:12:40,940
micro policy specification to figure out

324
00:12:39,230 --> 00:12:44,480
what your policy is buying in terms of

325
00:12:40,940 --> 00:12:46,370
security so what do<font color="#CCCCCC"> we do in this paper</font>

326
00:12:44,480 --> 00:12:49,460
well we<font color="#CCCCCC"> usually consider specifications</font>

327
00:12:46,370 --> 00:12:51,320
of this forum we elaborate a higher

328
00:12:49,460 --> 00:12:54,410
level abstract machine that is<font color="#E5E5E5"> supposed</font>

329
00:12:51,320 --> 00:12:55,820
to embody a more structure programming

330
00:12:54,410 --> 00:12:57,770
model than just bare bones assembly

331
00:12:55,820 --> 00:13:00,290
programming and then we show that this

332
00:12:57,770 --> 00:13:03,860
higher level machine can be<font color="#E5E5E5"> implemented</font>

333
00:13:00,290 --> 00:13:05,660
by particular<font color="#E5E5E5"> micro policies so for</font>

334
00:13:03,860 --> 00:13:09,440
instance<font color="#E5E5E5"> I mentioned that we have this</font>

335
00:13:05,660 --> 00:13:12,280
micro policy for doing memory safety we

336
00:13:09,440 --> 00:13:15,080
could<font color="#E5E5E5"> implement an abstract machine</font>

337
00:13:12,280 --> 00:13:16,850
where pointers and integers are not

338
00:13:15,080 --> 00:13:17,209
interchangeable they're different data

339
00:13:16,850 --> 00:13:19,429
type

340
00:13:17,209 --> 00:13:22,040
and a pointer can only be used<font color="#CCCCCC"> to acts</font>

341
00:13:19,429 --> 00:13:25,550
as a certain region of memory<font color="#CCCCCC"> that has</font>

342
00:13:22,040 --> 00:13:27,860
the capability for<font color="#E5E5E5"> if we go off bounds</font>

343
00:13:25,550 --> 00:13:29,359
and try to access some other region of

344
00:13:27,860 --> 00:13:30,800
memory<font color="#E5E5E5"> or machine will be</font><font color="#CCCCCC"> able</font><font color="#E5E5E5"> to detect</font>

345
00:13:29,360 --> 00:13:35,360
this and prevent an attack from

346
00:13:30,800 --> 00:13:37,849
happening and<font color="#CCCCCC"> then we're able to show</font>

347
00:13:35,360 --> 00:13:39,110
<font color="#CCCCCC">that this abstract machine that is more</font>

348
00:13:37,850 --> 00:13:40,699
structured than just assembly

349
00:13:39,110 --> 00:13:43,160
programming is indeed implemented by

350
00:13:40,699 --> 00:13:44,779
remember safety micro policy we could

351
00:13:43,160 --> 00:13:47,059
also consider other forms of

352
00:13:44,779 --> 00:13:49,279
specification so for<font color="#CCCCCC"> instance for our</font>

353
00:13:47,059 --> 00:13:51,759
control<font color="#CCCCCC"> flow integrity micro policy were</font>

354
00:13:49,279 --> 00:13:54,800
<font color="#E5E5E5">able to show</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> it gives similar</font>

355
00:13:51,759 --> 00:13:58,100
security guarantees than those given by

356
00:13:54,800 --> 00:14:00,979
a<font color="#E5E5E5"> body</font><font color="#CCCCCC"> cfi property which roughly states</font>

357
00:13:58,100 --> 00:14:02,779
that a program is always going to

358
00:14:00,980 --> 00:14:04,639
execute within its control flow graph

359
00:14:02,779 --> 00:14:07,309
even in<font color="#E5E5E5"> the presence of an attacker that</font>

360
00:14:04,639 --> 00:14:14,149
<font color="#CCCCCC">is able</font><font color="#E5E5E5"> to change data bits in arbitrary</font>

361
00:14:07,309 --> 00:14:18,350
ways non deterministically so that's it

362
00:14:14,149 --> 00:14:19,699
<font color="#CCCCCC">for security if what I wanted</font><font color="#E5E5E5"> you</font><font color="#CCCCCC"> to</font>

363
00:14:18,350 --> 00:14:21,259
take<font color="#E5E5E5"> away from this endeavor is that</font>

364
00:14:19,699 --> 00:14:23,628
with a little<font color="#E5E5E5"> bit of careful design we</font>

365
00:14:21,259 --> 00:14:25,639
can come up<font color="#CCCCCC"> with a programming model for</font>

366
00:14:23,629 --> 00:14:28,339
any expressive<font color="#CCCCCC"> high level policies for</font>

367
00:14:25,639 --> 00:14:30,649
security of<font color="#E5E5E5"> low level code and because</font>

368
00:14:28,339 --> 00:14:32,689
this<font color="#E5E5E5"> model is based on a model for</font>

369
00:14:30,649 --> 00:14:37,040
hardware acceleration we can<font color="#E5E5E5"> do this</font>

370
00:14:32,689 --> 00:14:39,410
with reasonable overheads needless to

371
00:14:37,040 --> 00:14:41,029
say in this talk I've only mentioned the

372
00:14:39,410 --> 00:14:42,709
tip of the<font color="#CCCCCC"> iceberg of the</font><font color="#E5E5E5"> work</font><font color="#CCCCCC"> that</font>

373
00:14:41,029 --> 00:14:44,540
we've done this paper so if you're

374
00:14:42,709 --> 00:14:46,368
interested<font color="#CCCCCC"> in</font><font color="#E5E5E5"> learning more about it</font>

375
00:14:44,540 --> 00:14:48,199
such as details of the micro policies

376
00:14:46,369 --> 00:14:50,240
we've implemented of the programming

377
00:14:48,199 --> 00:14:51,469
model of the formal proofs you can have

378
00:14:50,240 --> 00:14:53,480
a<font color="#E5E5E5"> look at the paper to learn more</font><font color="#CCCCCC"> about</font>

379
00:14:51,470 --> 00:14:55,610
this you'll also find there a

380
00:14:53,480 --> 00:14:57,799
description of the formal model of this

381
00:14:55,610 --> 00:14:59,480
<font color="#E5E5E5">Hardware extension of the pump that we</font>

382
00:14:57,799 --> 00:15:03,199
used to accelerate these micro policies

383
00:14:59,480 --> 00:15:04,519
as well<font color="#CCCCCC"> as a proof that the pump can be</font>

384
00:15:03,199 --> 00:15:06,799
<font color="#E5E5E5">used in a way that cannot be</font>

385
00:15:04,519 --> 00:15:09,379
circumvented by the user so the pump

386
00:15:06,799 --> 00:15:11,899
itself is capable of enforcing its own

387
00:15:09,379 --> 00:15:13,519
protection all of our source code is

388
00:15:11,899 --> 00:15:15,410
available on github if you want to have

389
00:15:13,519 --> 00:15:16,699
a look at it or maybe build some micro

390
00:15:15,410 --> 00:15:22,149
policies off your own and prove them

391
00:15:16,699 --> 00:15:24,709
correct I would<font color="#CCCCCC"> like to conclude my talk</font>

392
00:15:22,149 --> 00:15:26,600
with a few things we've been working on

393
00:15:24,709 --> 00:15:27,949
so we've been considering how to

394
00:15:26,600 --> 00:15:30,290
implement more policies<font color="#E5E5E5"> with those</font>

395
00:15:27,949 --> 00:15:32,329
mechanism in some use cases

396
00:15:30,290 --> 00:15:33,319
in particular we would like<font color="#CCCCCC"> to see how</font>

397
00:15:32,329 --> 00:15:35,180
we can use the compartmentalization

398
00:15:33,320 --> 00:15:37,339
<font color="#E5E5E5">micro policy that we've developed to</font>

399
00:15:35,180 --> 00:15:39,829
build an operating system that is

400
00:15:37,339 --> 00:15:41,750
compartmentalized let you develop a

401
00:15:39,829 --> 00:15:43,399
theory of policy composition that<font color="#CCCCCC"> would</font>

402
00:15:41,750 --> 00:15:45,470
allow users to combine different

403
00:15:43,399 --> 00:15:48,350
policies and the guarantees that are

404
00:15:45,470 --> 00:15:50,180
proven about these policies and we'd

405
00:15:48,350 --> 00:15:52,399
also like to improve the guarantees that

406
00:15:50,180 --> 00:15:54,649
we get from this formal model by scaling

407
00:15:52,399 --> 00:15:56,060
our processor model at furia why I say

408
00:15:54,649 --> 00:15:58,639
<font color="#E5E5E5">that's what's actually going to be</font>

409
00:15:56,060 --> 00:16:00,800
deployed and be able to<font color="#E5E5E5"> verify actual</font>

410
00:15:58,639 --> 00:16:03,290
machine code implementations of<font color="#E5E5E5"> the</font>

411
00:16:00,800 --> 00:16:06,500
policies<font color="#CCCCCC"> that we have connecting them to</font>

412
00:16:03,290 --> 00:16:09,110
their more higher level model to get all

413
00:16:06,500 --> 00:16:11,540
the guarantees down to the machine code

414
00:16:09,110 --> 00:16:22,209
level and<font color="#CCCCCC"> that</font><font color="#E5E5E5"> concludes</font><font color="#CCCCCC"> my talk thank</font>

415
00:16:11,540 --> 00:16:22,209
you very much also<font color="#E5E5E5"> time</font><font color="#CCCCCC"> for questions so</font>

416
00:16:24,850 --> 00:16:31,339
<font color="#CCCCCC">you show me that you're based on risk</font>

417
00:16:28,940 --> 00:16:33,829
model say that I feel want to use this

418
00:16:31,339 --> 00:16:44,209
ice 86 what part of the proof I can

419
00:16:33,829 --> 00:16:47,149
<font color="#E5E5E5">reuse from your platform let's see so I</font>

420
00:16:44,209 --> 00:16:50,920
think the the harder part would be

421
00:16:47,149 --> 00:16:53,779
adapting the lower level layer because

422
00:16:50,920 --> 00:16:55,550
there's a lot<font color="#CCCCCC"> of assumptions that we</font>

423
00:16:53,779 --> 00:16:57,529
have there that are specific to risk for

424
00:16:55,550 --> 00:17:01,849
instance working with fixed with

425
00:16:57,529 --> 00:17:03,649
instructions and but beyond that point

426
00:17:01,850 --> 00:17:06,860
we actually have a refinement proof that

427
00:17:03,649 --> 00:17:09,669
shows<font color="#CCCCCC"> that there's a sort so to speak</font>

428
00:17:06,859 --> 00:17:12,770
higher level programming model that can

429
00:17:09,669 --> 00:17:16,520
can be implemented by<font color="#E5E5E5"> this machine so if</font>

430
00:17:12,770 --> 00:17:18,470
we<font color="#CCCCCC"> were able to use something more x86</font>

431
00:17:16,520 --> 00:17:20,418
like at the bottom layer and still build

432
00:17:18,470 --> 00:17:24,110
a refinement proof you'll be able to<font color="#E5E5E5"> use</font>

433
00:17:20,419 --> 00:17:28,540
<font color="#CCCCCC">all the all the specification proofs</font>

434
00:17:24,109 --> 00:17:28,540
that you have for the older policies

435
00:17:29,380 --> 00:17:35,980
hello Sam Weber at SEI so you said that

436
00:17:33,350 --> 00:17:39,408
your technique was<font color="#E5E5E5"> going to be very fast</font>

437
00:17:35,980 --> 00:17:41,900
but and sometimes<font color="#CCCCCC"> your takes could be</font>

438
00:17:39,409 --> 00:17:44,060
pointers to complex data structures

439
00:17:41,900 --> 00:17:46,370
<font color="#CCCCCC">I would</font><font color="#E5E5E5"> imagine that</font><font color="#CCCCCC"> the more complex</font>

440
00:17:44,060 --> 00:17:48,560
operations you do on kind<font color="#E5E5E5"> of data</font>

441
00:17:46,370 --> 00:17:53,540
structures yes they'll be high

442
00:17:48,560 --> 00:17:54,740
performance impact indeed so we're<font color="#CCCCCC"> still</font>

443
00:17:53,540 --> 00:17:56,510
exploring the performance

444
00:17:54,740 --> 00:17:57,920
characteristics<font color="#CCCCCC"> of the pump we know that</font>

445
00:17:56,510 --> 00:18:00,260
it works well for a given set of

446
00:17:57,920 --> 00:18:02,270
policies but we<font color="#E5E5E5"> obviously have no way of</font>

447
00:18:00,260 --> 00:18:04,940
knowing how<font color="#CCCCCC"> well it performs on more</font>

448
00:18:02,270 --> 00:18:07,010
complicated policies so presumably there

449
00:18:04,940 --> 00:18:08,810
will still be some work involved some

450
00:18:07,010 --> 00:18:11,120
creativity involved in coming up with

451
00:18:08,810 --> 00:18:14,270
efficient policies even in the presence

452
00:18:11,120 --> 00:18:16,879
of this hardware acceleration<font color="#CCCCCC"> okay so if</font>

453
00:18:14,270 --> 00:18:18,230
you still limit your policies to things

454
00:18:16,880 --> 00:18:23,180
<font color="#E5E5E5">that require just one level of</font>

455
00:18:18,230 --> 00:18:25,040
indirection are you still fast well we

456
00:18:23,180 --> 00:18:26,780
don't have<font color="#CCCCCC"> a clear answer for that yet</font>

457
00:18:25,040 --> 00:18:28,760
we do have policies that<font color="#E5E5E5"> use data</font>

458
00:18:26,780 --> 00:18:30,379
structures in memory and those seem to

459
00:18:28,760 --> 00:18:32,930
perform well<font color="#E5E5E5"> but if you start to build</font>

460
00:18:30,380 --> 00:18:34,370
arbitrarily complex data structures then

461
00:18:32,930 --> 00:18:43,750
maybe<font color="#E5E5E5"> you're secure but maybe not</font><font color="#CCCCCC"> as</font>

462
00:18:34,370 --> 00:18:43,750
fast yes

463
00:18:44,460 --> 00:18:50,380
it's important<font color="#E5E5E5"> to</font><font color="#CCCCCC"> recognize that</font><font color="#E5E5E5"> the</font>

464
00:18:46,780 --> 00:18:52,930
that the fast path where you hid in the

465
00:18:50,380 --> 00:18:55,810
<font color="#E5E5E5">cache doesn't involve following any in</font>

466
00:18:52,930 --> 00:18:57,970
directions so in the past case you're

467
00:18:55,810 --> 00:19:00,639
<font color="#CCCCCC">just looking at the at the at the</font>

468
00:18:57,970 --> 00:19:04,030
<font color="#E5E5E5">pointer which is what's stored in the</font>

469
00:19:00,640 --> 00:19:05,530
tag and and manipulating those only<font color="#CCCCCC"> when</font>

470
00:19:04,030 --> 00:19:08,620
you miss in the cache do you have to

471
00:19:05,530 --> 00:19:15,639
follow pointers and examine memory

472
00:19:08,620 --> 00:19:16,449
structures so I<font color="#E5E5E5"> preferred to come under</font>

473
00:19:15,640 --> 00:19:17,980
that the interesting<font color="#E5E5E5"> question</font>

474
00:19:16,450 --> 00:19:20,020
<font color="#E5E5E5">aeropostale they were the working set</font>

475
00:19:17,980 --> 00:19:21,490
for that cash is and what you do in

476
00:19:20,020 --> 00:19:23,139
terms of policies that<font color="#E5E5E5"> was never</font><font color="#CCCCCC"> flowed</font>

477
00:19:21,490 --> 00:19:26,950
my actual question has to do<font color="#CCCCCC"> with</font>

478
00:19:23,140 --> 00:19:28,180
composition of policies is it the

479
00:19:26,950 --> 00:19:29,920
composition<font color="#CCCCCC"> of the policies you've</font>

480
00:19:28,180 --> 00:19:31,870
explored always coherent does it ever

481
00:19:29,920 --> 00:19:34,210
run you into situations where you<font color="#E5E5E5"> lose</font>

482
00:19:31,870 --> 00:19:36,040
security properties you want or you lose

483
00:19:34,210 --> 00:19:37,690
program functional properties you want

484
00:19:36,040 --> 00:19:40,120
well that's<font color="#CCCCCC"> exactly what makes</font>

485
00:19:37,690 --> 00:19:41,770
<font color="#E5E5E5">composition hard I agree so there's</font>

486
00:19:40,120 --> 00:19:44,219
<font color="#E5E5E5">always a naive way in which again</font>

487
00:19:41,770 --> 00:19:46,450
compose the policies which is you just

488
00:19:44,220 --> 00:19:48,340
<font color="#CCCCCC">combine that all the text together</font><font color="#E5E5E5"> in a</font>

489
00:19:46,450 --> 00:19:51,700
big couple and you try<font color="#E5E5E5"> to enforce those</font>

490
00:19:48,340 --> 00:19:54,550
<font color="#CCCCCC">Hyman taneously but maybe for instance</font>

491
00:19:51,700 --> 00:19:57,760
<font color="#CCCCCC">if you try</font><font color="#E5E5E5"> to combine say information</font>

492
00:19:54,550 --> 00:20:00,280
flow control with a memory safety policy

493
00:19:57,760 --> 00:20:02,320
then the information<font color="#CCCCCC"> flow bits might</font>

494
00:20:00,280 --> 00:20:04,120
sorry the memory safety bits might

495
00:20:02,320 --> 00:20:06,040
interfere with<font color="#CCCCCC"> the information flow</font>

496
00:20:04,120 --> 00:20:08,290
control bits and then<font color="#E5E5E5"> you might lose</font>

497
00:20:06,040 --> 00:20:09,760
some guarantees so it's it's important

498
00:20:08,290 --> 00:20:12,010
to figure out how to combine these

499
00:20:09,760 --> 00:20:14,290
policies<font color="#E5E5E5"> and right now it doesn't</font><font color="#CCCCCC"> seem</font>

500
00:20:12,010 --> 00:20:16,150
very trivial yeah i mean this little

501
00:20:14,290 --> 00:20:18,460
experience showing that arbitrarily

502
00:20:16,150 --> 00:20:19,960
atom-smashing policies lead to fail open

503
00:20:18,460 --> 00:20:21,880
problems<font color="#CCCCCC"> in security and it'll be nice</font>

504
00:20:19,960 --> 00:20:23,950
<font color="#CCCCCC">to as part of your proofs about this</font>

505
00:20:21,880 --> 00:20:25,240
proved that compositions have overall

506
00:20:23,950 --> 00:20:27,640
properties you want to if<font color="#CCCCCC"> only we knew</font>

507
00:20:25,240 --> 00:20:30,070
what they were yeah and do you

508
00:20:27,640 --> 00:20:31,810
anticipate that software would ever hit

509
00:20:30,070 --> 00:20:33,879
cases when it would violate the policies

510
00:20:31,810 --> 00:20:36,100
described in a non exploit situation or

511
00:20:33,880 --> 00:20:38,380
is it really<font color="#E5E5E5"> you anticipate people write</font>

512
00:20:36,100 --> 00:20:39,730
software they may prove or otherwise

513
00:20:38,380 --> 00:20:41,320
reason about some properties of idiot

514
00:20:39,730 --> 00:20:44,560
runs and<font color="#CCCCCC"> you never hit the exception</font>

515
00:20:41,320 --> 00:20:45,760
case where the policy fails<font color="#E5E5E5"> I'm sorry</font>

516
00:20:44,560 --> 00:20:47,020
can you repeat the<font color="#CCCCCC"> question please so</font>

517
00:20:45,760 --> 00:20:48,100
you can just<font color="#E5E5E5"> if you have a set of</font>

518
00:20:47,020 --> 00:20:50,500
constraining policies such as

519
00:20:48,100 --> 00:20:52,120
information flow and CSI<font color="#E5E5E5"> and so on you</font>

520
00:20:50,500 --> 00:20:53,920
might ideally think yourself if<font color="#E5E5E5"> this is</font>

521
00:20:52,120 --> 00:20:55,629
exploit mitigation than in normal

522
00:20:53,920 --> 00:20:55,960
operation you would never<font color="#E5E5E5"> violate any of</font>

523
00:20:55,630 --> 00:20:57,280
<font color="#E5E5E5">these</font>

524
00:20:55,960 --> 00:20:58,810
aussies and therefore your software

525
00:20:57,280 --> 00:21:00,370
would run as though the policies weren't

526
00:20:58,810 --> 00:21:02,050
being enforced in hardware which is to

527
00:21:00,370 --> 00:21:04,209
say you know they are enforced but

528
00:21:02,050 --> 00:21:06,399
nothing changes<font color="#CCCCCC"> the software control</font>

529
00:21:04,210 --> 00:21:07,660
flow or fail stops the system but if

530
00:21:06,400 --> 00:21:09,850
<font color="#E5E5E5">you're exploited then you might fail</font>

531
00:21:07,660 --> 00:21:11,380
stop or have some<font color="#E5E5E5"> exceptional case do</font>

532
00:21:09,850 --> 00:21:12,939
you envision that there would ever be

533
00:21:11,380 --> 00:21:14,680
exceptional cases and failures that

534
00:21:12,940 --> 00:21:16,480
might happen in normal operation or is

535
00:21:14,680 --> 00:21:17,740
this really just<font color="#E5E5E5"> kind of a seat belt and</font>

536
00:21:16,480 --> 00:21:19,300
then when something goes wrong the seat

537
00:21:17,740 --> 00:21:24,790
belt suddenly stops the behavior<font color="#CCCCCC"> that</font>

538
00:21:19,300 --> 00:21:25,899
you're uninterested in so I'm<font color="#E5E5E5"> not</font><font color="#CCCCCC"> sure I</font>

539
00:21:24,790 --> 00:21:28,080
understand the question very well you

540
00:21:25,900 --> 00:21:30,700
have maybe we can take this offline

541
00:21:28,080 --> 00:21:33,270
since speaker<font color="#E5E5E5"> again oh you can please</font>

542
00:21:30,700 --> 00:21:33,270
jump in

