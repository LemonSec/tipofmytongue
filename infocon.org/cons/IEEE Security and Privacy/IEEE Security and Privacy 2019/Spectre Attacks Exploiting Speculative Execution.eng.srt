1
00:00:08,610 --> 00:00:12,870
so this is kind of a hard talk to give

2
00:00:11,160 --> 00:00:14,520
because most if not all of you have

3
00:00:12,870 --> 00:00:16,079
probably already heard about the results

4
00:00:14,520 --> 00:00:17,939
so I'm going to go fairly quickly

5
00:00:16,079 --> 00:00:19,770
through one of the variations but not go

6
00:00:17,939 --> 00:00:21,119
into details about things you probably

7
00:00:19,770 --> 00:00:22,740
heard about and spend a little more of

8
00:00:21,119 --> 00:00:26,070
the time talking about sort of the

9
00:00:22,740 --> 00:00:27,930
ramifications in the context of Spectre

10
00:00:26,070 --> 00:00:30,000
I'm Paul Kocher I also wanted to

11
00:00:27,930 --> 00:00:34,260
highlight Jan Horne he actually reported

12
00:00:30,000 --> 00:00:35,610
this issue first to Intel and but didn't

13
00:00:34,260 --> 00:00:37,680
want to be first in the paper isn't here

14
00:00:35,610 --> 00:00:39,239
presenting but if anybody sort of should

15
00:00:37,680 --> 00:00:45,120
be listed first it probably ought to be

16
00:00:39,239 --> 00:00:47,489
him so let's so that if we sort of look

17
00:00:45,120 --> 00:00:49,589
back in sort of the history of making

18
00:00:47,489 --> 00:00:50,640
computers fast um there were some early

19
00:00:49,589 --> 00:00:53,100
years where it was actually really easy

20
00:00:50,640 --> 00:00:55,440
you'd basically crank your clock rate up

21
00:00:53,100 --> 00:00:57,570
and you would end up getting your

22
00:00:55,440 --> 00:00:59,549
computer to run faster and faster and

23
00:00:57,570 --> 00:01:01,920
actually everything kind of got faster

24
00:00:59,549 --> 00:01:03,690
at the same sort of proportion so your

25
00:01:01,920 --> 00:01:05,670
worst case performance and your best

26
00:01:03,690 --> 00:01:09,060
case performance they were all gaining

27
00:01:05,670 --> 00:01:11,340
in performance but about 2004 or so

28
00:01:09,060 --> 00:01:12,780
maybe a little after we we pretty came

29
00:01:11,340 --> 00:01:14,390
pretty much came to the wall when it

30
00:01:12,780 --> 00:01:17,580
came to clock rates somewhere in that

31
00:01:14,390 --> 00:01:18,990
three and a half to five gigahertz range

32
00:01:17,580 --> 00:01:20,580
and maybe we can squeeze a little bit

33
00:01:18,990 --> 00:01:24,000
past that but that's about where things

34
00:01:20,580 --> 00:01:26,580
max out and another sort of fundamental

35
00:01:24,000 --> 00:01:28,920
problem that we've run into is around

36
00:01:26,580 --> 00:01:30,720
memory speeds Layton sees just haven't

37
00:01:28,920 --> 00:01:32,190
gotten substantially better again their

38
00:01:30,720 --> 00:01:34,410
incremental improvements but I think

39
00:01:32,190 --> 00:01:35,910
transformative um so if you look at

40
00:01:34,410 --> 00:01:38,158
what's been going on in performance

41
00:01:35,910 --> 00:01:40,170
gains in the last couple of decades a

42
00:01:38,159 --> 00:01:42,000
lot of the focus has been on ways of

43
00:01:40,170 --> 00:01:45,540
making things run faster in the average

44
00:01:42,000 --> 00:01:47,370
case and this means things like caches

45
00:01:45,540 --> 00:01:49,770
it means techniques like speculative

46
00:01:47,370 --> 00:01:51,960
execution means things like finding

47
00:01:49,770 --> 00:01:54,149
creative ways to compress your memory so

48
00:01:51,960 --> 00:01:56,309
that you use less resources or less time

49
00:01:54,150 --> 00:01:57,330
to do something useful so what I sort of

50
00:01:56,310 --> 00:01:59,610
think about this from a security

51
00:01:57,330 --> 00:02:02,190
perspective it basically means that when

52
00:01:59,610 --> 00:02:05,250
I look at things this entire area of

53
00:02:02,190 --> 00:02:06,870
research around doing computer

54
00:02:05,250 --> 00:02:09,209
architecture has essentially become the

55
00:02:06,870 --> 00:02:12,870
world of creating brand-new side-channel

56
00:02:09,209 --> 00:02:14,489
attacks and almost any optimization that

57
00:02:12,870 --> 00:02:16,890
you can think of that makes your best

58
00:02:14,489 --> 00:02:18,750
case run a little faster leaves the

59
00:02:16,890 --> 00:02:22,079
worst case the same leave some kind of

60
00:02:18,750 --> 00:02:23,490
side channel in between so in this

61
00:02:22,080 --> 00:02:25,950
with the focus on speculative execution

62
00:02:23,490 --> 00:02:27,960
which is one of these performances

63
00:02:25,950 --> 00:02:30,299
increasing techniques and their others

64
00:02:27,960 --> 00:02:32,640
as well like using pipelining and such

65
00:02:30,300 --> 00:02:34,230
but the idea of speculation is super

66
00:02:32,640 --> 00:02:36,929
simple it's been known for decades and

67
00:02:34,230 --> 00:02:39,929
it's basically a way of taking hardware

68
00:02:36,930 --> 00:02:42,390
which works in parallel and using it to

69
00:02:39,930 --> 00:02:44,550
efficiently or quickly run a program

70
00:02:42,390 --> 00:02:46,350
which is organized as a series of linear

71
00:02:44,550 --> 00:02:47,730
steps the way that most programmers

72
00:02:46,350 --> 00:02:50,790
think so you've got this series of

73
00:02:47,730 --> 00:02:52,649
instructions you don't risk necessarily

74
00:02:50,790 --> 00:02:54,060
know given a whole bunch of instructions

75
00:02:52,650 --> 00:02:57,210
which ones will interact with each other

76
00:02:54,060 --> 00:02:59,010
or exactly how it's all going to work

77
00:02:57,210 --> 00:03:00,960
out but you can start or try to start

78
00:02:59,010 --> 00:03:02,850
work on something even before you're

79
00:03:00,960 --> 00:03:04,770
certain about whether you're going to

80
00:03:02,850 --> 00:03:06,120
need the end result and if you guess

81
00:03:04,770 --> 00:03:08,220
right you'll go faster if you guess

82
00:03:06,120 --> 00:03:09,960
wrong you'll guess you'll be back where

83
00:03:08,220 --> 00:03:12,000
you started so speculation we're gonna

84
00:03:09,960 --> 00:03:13,650
start a likely task early and then clean

85
00:03:12,000 --> 00:03:15,840
up our errors so if I have a very simple

86
00:03:13,650 --> 00:03:17,220
piece of code like if x equals 1 and

87
00:03:15,840 --> 00:03:20,190
I'll do one thing otherwise I'll do

88
00:03:17,220 --> 00:03:22,470
something else if the value of X is not

89
00:03:20,190 --> 00:03:25,200
in them in the cache I'm going to sit

90
00:03:22,470 --> 00:03:27,060
for a couple of hundred clock cycles if

91
00:03:25,200 --> 00:03:29,519
I'm the processor waiting for this value

92
00:03:27,060 --> 00:03:31,020
to come in from DRAM because DRAM as I

93
00:03:29,520 --> 00:03:33,780
said before is really really slow

94
00:03:31,020 --> 00:03:36,090
compared to processors so we've got this

95
00:03:33,780 --> 00:03:37,470
long delay and the naive thing to do

96
00:03:36,090 --> 00:03:39,510
will be just to sit there if you're the

97
00:03:37,470 --> 00:03:42,800
processor and wait for X to arrive the

98
00:03:39,510 --> 00:03:46,470
optimized thing to do is to basically

99
00:03:42,800 --> 00:03:49,110
keep a copy of all of my registers at

100
00:03:46,470 --> 00:03:51,090
this point where I'm waiting for X but

101
00:03:49,110 --> 00:03:52,860
proceed using a branch predictor and

102
00:03:51,090 --> 00:03:54,209
whatever path the branch predictor

103
00:03:52,860 --> 00:03:55,620
thinks is most likely and branch

104
00:03:54,209 --> 00:03:58,320
predictors work pretty well like there

105
00:03:55,620 --> 00:04:00,600
should well be on 90% correct in their

106
00:03:58,320 --> 00:04:01,799
predictions so it will predict for

107
00:04:00,600 --> 00:04:04,290
example that this statement will be true

108
00:04:01,800 --> 00:04:06,360
and well then I can start work on ABC

109
00:04:04,290 --> 00:04:08,700
before I know for sure if it's true

110
00:04:06,360 --> 00:04:10,020
eventually the memory responds I get my

111
00:04:08,700 --> 00:04:12,329
value I can check to see whether I

112
00:04:10,020 --> 00:04:14,250
guessed correctly if I guess correctly I

113
00:04:12,330 --> 00:04:16,080
win on performance if I guess wrong I

114
00:04:14,250 --> 00:04:17,940
basically go back to all right and

115
00:04:16,079 --> 00:04:20,450
execute correctly but there's not really

116
00:04:17,940 --> 00:04:22,680
any performance cost in doing that so

117
00:04:20,450 --> 00:04:24,930
this is kind of a guess right and you

118
00:04:22,680 --> 00:04:28,200
win guess wrong and there's no cost from

119
00:04:24,930 --> 00:04:30,180
a performance perspective a parallel

120
00:04:28,200 --> 00:04:33,450
thing that I'm going to talk about

121
00:04:30,180 --> 00:04:35,159
briefly is fault attacks so there have

122
00:04:33,450 --> 00:04:37,529
been a number of papers here one

123
00:04:35,159 --> 00:04:39,899
Binet D'Amelio Lipton from quite a while

124
00:04:37,529 --> 00:04:41,729
ago as well as just a lot of practical

125
00:04:39,899 --> 00:04:44,159
work like if you look at what pay TV

126
00:04:41,729 --> 00:04:46,318
hackers do to break the security systems

127
00:04:44,159 --> 00:04:48,839
in the cards that you are used to

128
00:04:46,319 --> 00:04:52,050
protect satellite services or video game

129
00:04:48,839 --> 00:04:55,110
hackers they are very adept at basically

130
00:04:52,050 --> 00:04:56,669
taking a correct program inducing the

131
00:04:55,110 --> 00:04:59,369
processor to make an error at some

132
00:04:56,669 --> 00:05:01,529
usually carefully timed location during

133
00:04:59,369 --> 00:05:03,839
the execution resulting in a different

134
00:05:01,529 --> 00:05:05,159
programming executing so common thing

135
00:05:03,839 --> 00:05:06,659
that you'll get is you'll induce a

136
00:05:05,159 --> 00:05:08,129
glitch an instruction will effectively

137
00:05:06,659 --> 00:05:09,740
work like and no op but there are other

138
00:05:08,129 --> 00:05:12,959
things that a glitch can do as well so

139
00:05:09,740 --> 00:05:14,399
as an adversary by choosing where to put

140
00:05:12,959 --> 00:05:16,830
these glitches I can basically rewrite

141
00:05:14,399 --> 00:05:18,779
the program that was originally correct

142
00:05:16,830 --> 00:05:22,139
and secure into a different program

143
00:05:18,779 --> 00:05:23,580
which contains errors and I've spent an

144
00:05:22,139 --> 00:05:26,219
embarrassed and a large amount of time

145
00:05:23,580 --> 00:05:27,479
and let in labs basically torturing like

146
00:05:26,219 --> 00:05:30,300
a processors to make them make mistakes

147
00:05:27,479 --> 00:05:31,469
and what you pretty quickly learn when

148
00:05:30,300 --> 00:05:33,839
you've done this for a while is if you

149
00:05:31,469 --> 00:05:36,719
can come up with really any kind of an

150
00:05:33,839 --> 00:05:38,759
error that will change some instruction

151
00:05:36,719 --> 00:05:40,259
by choosing when you induce these errors

152
00:05:38,759 --> 00:05:41,819
and how you induce them you could turn

153
00:05:40,259 --> 00:05:45,869
any program into something that's

154
00:05:41,819 --> 00:05:47,459
exploitable so just a there may be some

155
00:05:45,869 --> 00:05:49,319
crazy exception where you can't do that

156
00:05:47,459 --> 00:05:51,389
but I have yet to see a prostitute where

157
00:05:49,319 --> 00:05:54,329
I could glitch the thing and not and

158
00:05:51,389 --> 00:05:55,259
break it so when Mike Hamburg I don't

159
00:05:54,329 --> 00:05:56,490
know if he's here but he was one of

160
00:05:55,259 --> 00:05:57,659
these a researcher at cryptography

161
00:05:56,490 --> 00:05:59,999
research asked me the question about

162
00:05:57,659 --> 00:06:02,519
whether speculative execution was an OK

163
00:05:59,999 --> 00:06:04,379
thing to do in processors as somebody

164
00:06:02,519 --> 00:06:06,990
who's done glitch attacks this kind of

165
00:06:04,379 --> 00:06:08,610
made my stomach feel a little something

166
00:06:06,990 --> 00:06:10,979
more other in it because basically this

167
00:06:08,610 --> 00:06:13,289
is like the CPU has its own fault attack

168
00:06:10,979 --> 00:06:14,998
Hardware built into it I don't need to

169
00:06:13,289 --> 00:06:16,860
go and take an analogue thing to monkey

170
00:06:14,999 --> 00:06:19,079
with the clock lot line I don't have to

171
00:06:16,860 --> 00:06:21,539
do any of that stuff is already there

172
00:06:19,079 --> 00:06:23,849
and there's a little nuance in that it's

173
00:06:21,539 --> 00:06:25,709
gonna try to delete the errors but as

174
00:06:23,849 --> 00:06:27,269
somebody who's worked on side channel

175
00:06:25,709 --> 00:06:29,039
attacks and even done attacks where you

176
00:06:27,269 --> 00:06:30,779
combine a glitch and then you measure

177
00:06:29,039 --> 00:06:32,369
the power consumption of the thing after

178
00:06:30,779 --> 00:06:33,869
the glitch to get some information that

179
00:06:32,369 --> 00:06:35,759
you wouldn't get directly from the

180
00:06:33,869 --> 00:06:37,169
normal power consumption the idea that

181
00:06:35,759 --> 00:06:38,550
all the stuff was there and I can just

182
00:06:37,169 --> 00:06:40,198
use any of the hidden the covert

183
00:06:38,550 --> 00:06:43,050
channels that have been known about

184
00:06:40,199 --> 00:06:45,389
again since well before I was born

185
00:06:43,050 --> 00:06:46,949
to exfiltrate information from this

186
00:06:45,389 --> 00:06:48,269
incorrect execution

187
00:06:46,949 --> 00:06:48,550
into some place where I can do something

188
00:06:48,269 --> 00:06:50,920
with

189
00:06:48,550 --> 00:06:52,840
it seemed almost too good to be true if

190
00:06:50,920 --> 00:06:55,090
I was wearing an attack hat but as I

191
00:06:52,840 --> 00:06:56,830
think we all know now that's exactly

192
00:06:55,090 --> 00:06:58,869
what's going on in our performance

193
00:06:56,830 --> 00:07:00,219
optimized micro processors so I'm going

194
00:06:58,870 --> 00:07:01,750
to quickly run through the variant one

195
00:07:00,220 --> 00:07:03,190
of the the attack I'm not going to go

196
00:07:01,750 --> 00:07:06,970
through through the others just because

197
00:07:03,190 --> 00:07:09,790
of time here so the basic context for a

198
00:07:06,970 --> 00:07:11,680
typical sort of variant one Spectre

199
00:07:09,790 --> 00:07:14,230
attack is that there's some code that's

200
00:07:11,680 --> 00:07:15,940
going to run in a trusted context where

201
00:07:14,230 --> 00:07:17,890
an adversary maybe can control some

202
00:07:15,940 --> 00:07:19,690
input into it so in this example here

203
00:07:17,890 --> 00:07:22,060
I've got a little snippet of code where

204
00:07:19,690 --> 00:07:23,700
there's a a index coming in that the

205
00:07:22,060 --> 00:07:25,900
adversary might be able to supply

206
00:07:23,700 --> 00:07:27,969
there's a bounds check at the beginning

207
00:07:25,900 --> 00:07:30,250
where it's going to be compared against

208
00:07:27,970 --> 00:07:33,520
a size limit we're assuming axe is

209
00:07:30,250 --> 00:07:37,060
unsigned and endure under just sort of

210
00:07:33,520 --> 00:07:38,740
normal in order execution this second

211
00:07:37,060 --> 00:07:40,660
line of my piece of code that computes Y

212
00:07:38,740 --> 00:07:43,180
is never going to be executed if X is

213
00:07:40,660 --> 00:07:45,010
out of bounds the adversary in this case

214
00:07:43,180 --> 00:07:47,680
we're also going to assume as configure

215
00:07:45,010 --> 00:07:50,380
the cache into a particular set of

216
00:07:47,680 --> 00:07:51,610
states this is not necessarily the only

217
00:07:50,380 --> 00:07:52,900
way to make it work but it's makes it

218
00:07:51,610 --> 00:07:54,340
easy to understand so we're going to

219
00:07:52,900 --> 00:07:56,739
assume here that the size of the array

220
00:07:54,340 --> 00:07:58,690
is a variable in memory which is not in

221
00:07:56,740 --> 00:08:01,210
the cache we'll also assume that the

222
00:07:58,690 --> 00:08:03,040
array too and is completely not in the

223
00:08:01,210 --> 00:08:06,070
cache but there is some secret sitting

224
00:08:03,040 --> 00:08:07,990
in memory out of bounds from array one

225
00:08:06,070 --> 00:08:12,610
which is in the cache that the adversary

226
00:08:07,990 --> 00:08:14,140
would like to find so when the other

227
00:08:12,610 --> 00:08:15,670
thing that the adversary wants to do is

228
00:08:14,140 --> 00:08:16,780
to train the branch predictor so that it

229
00:08:15,670 --> 00:08:18,610
will assume what the if statement is

230
00:08:16,780 --> 00:08:21,909
true so call it a couple times with

231
00:08:18,610 --> 00:08:23,410
inbounds values of X not a big deal so

232
00:08:21,910 --> 00:08:25,360
what happens when we call this now is

233
00:08:23,410 --> 00:08:27,640
the adversary and we provide a value of

234
00:08:25,360 --> 00:08:30,010
x which is way out of bounds to billions

235
00:08:27,640 --> 00:08:31,750
we're at whatever we want just basically

236
00:08:30,010 --> 00:08:33,730
we're gonna supply the difference from a

237
00:08:31,750 --> 00:08:35,110
start of array one base to the thing

238
00:08:33,730 --> 00:08:36,520
that we would like to read out of memory

239
00:08:35,110 --> 00:08:38,560
so we're gonna do an out of bounds read

240
00:08:36,520 --> 00:08:40,059
here which is not supposed to be allowed

241
00:08:38,559 --> 00:08:41,709
because of our if statement the

242
00:08:40,059 --> 00:08:43,329
processor then comes along and it wants

243
00:08:41,710 --> 00:08:46,090
to check whether we're in bounds so it

244
00:08:43,330 --> 00:08:47,290
tries to load array one size for memory

245
00:08:46,090 --> 00:08:49,120
but that's going to take a long time

246
00:08:47,290 --> 00:08:51,400
gonna take a couple hundred clock cycles

247
00:08:49,120 --> 00:08:53,920
we're just going to be sitting here if

248
00:08:51,400 --> 00:08:55,090
we have an inorder processor but all of

249
00:08:53,920 --> 00:08:56,560
our fast processors now adieu

250
00:08:55,090 --> 00:08:58,960
speculative executions so they basically

251
00:08:56,560 --> 00:09:01,359
just blast on through that if statement

252
00:08:58,960 --> 00:09:02,799
as though it were just you know

253
00:09:01,360 --> 00:09:04,329
kind of a casual thing doesn't matter

254
00:09:02,799 --> 00:09:06,519
probably doesn't matter for security

255
00:09:04,329 --> 00:09:07,809
right we'll keep on going predict this

256
00:09:06,519 --> 00:09:09,819
if statement is going to be true because

257
00:09:07,809 --> 00:09:13,238
it was last time we're going to then

258
00:09:09,819 --> 00:09:15,790
read from array1 base plus X with our

259
00:09:13,239 --> 00:09:17,079
out of bounds X so we're now doing an

260
00:09:15,790 --> 00:09:19,089
out of bounds memory read now as a

261
00:09:17,079 --> 00:09:21,969
security person this is the point where

262
00:09:19,089 --> 00:09:23,619
I kind of would argue that we are having

263
00:09:21,970 --> 00:09:26,319
a security violation this should not

264
00:09:23,619 --> 00:09:27,699
occur but this is exactly what the

265
00:09:26,319 --> 00:09:30,399
processor will do and in fact it will

266
00:09:27,699 --> 00:09:32,618
then go read the secret byte that we are

267
00:09:30,399 --> 00:09:35,860
trying to leak as the adversary it will

268
00:09:32,619 --> 00:09:37,449
then it use that as an index to multiply

269
00:09:35,860 --> 00:09:40,029
about after multiplying by 512 was then

270
00:09:37,449 --> 00:09:42,279
index into array to the processor will

271
00:09:40,029 --> 00:09:44,170
then load that value from memory or

272
00:09:42,279 --> 00:09:46,480
start loading that value from memory it

273
00:09:44,170 --> 00:09:49,868
will actually get put into the cache as

274
00:09:46,480 --> 00:09:51,730
well and eventually after a whole bunch

275
00:09:49,869 --> 00:09:53,679
of this goes on hundreds of instructions

276
00:09:51,730 --> 00:09:55,959
execute perhaps the processor will

277
00:09:53,679 --> 00:09:58,029
realize that it made a mistake that the

278
00:09:55,959 --> 00:09:59,920
if statement actually was false and it

279
00:09:58,029 --> 00:10:01,839
will rewind all of the register contents

280
00:09:59,920 --> 00:10:03,988
back to where they were before and

281
00:10:01,839 --> 00:10:06,309
proceed as though the if wasn't true

282
00:10:03,989 --> 00:10:08,589
much later however when the adversary

283
00:10:06,309 --> 00:10:11,259
gets control of the processor again we

284
00:10:08,589 --> 00:10:12,850
can go back and we can simply time how

285
00:10:11,259 --> 00:10:15,369
long it takes to read each element out

286
00:10:12,850 --> 00:10:16,929
of array two and one of them is going to

287
00:10:15,369 --> 00:10:18,759
read fast and it's the one that

288
00:10:16,929 --> 00:10:21,160
identifies the secret byte that we were

289
00:10:18,759 --> 00:10:23,319
trying to read there are lots and lots

290
00:10:21,160 --> 00:10:25,629
and lots of variations to this kind of a

291
00:10:23,319 --> 00:10:27,729
theme though you can for example here

292
00:10:25,629 --> 00:10:29,379
the way that the leak occurs it's the

293
00:10:27,730 --> 00:10:30,970
change in the cache but if the processor

294
00:10:29,379 --> 00:10:33,189
doesn't actually change the cash flows

295
00:10:30,970 --> 00:10:35,019
running speculatively the timing of

296
00:10:33,189 --> 00:10:36,939
other speculative things can adjust the

297
00:10:35,019 --> 00:10:38,439
time of when something else that I can

298
00:10:36,939 --> 00:10:40,059
observe occur there's any kind of a

299
00:10:38,439 --> 00:10:42,819
covert channel between the speculative

300
00:10:40,059 --> 00:10:44,049
world and the adversaries world that

301
00:10:42,819 --> 00:10:45,849
gives you what you need to make the

302
00:10:44,049 --> 00:10:47,439
attack work so if you kind of think

303
00:10:45,850 --> 00:10:49,059
about what the the sort of world of

304
00:10:47,439 --> 00:10:50,469
variations here looks like there are a

305
00:10:49,059 --> 00:10:52,600
whole bunch of different speculation

306
00:10:50,470 --> 00:10:54,759
scenarios that go on inside processors I

307
00:10:52,600 --> 00:10:55,839
continue to be discovering these as I

308
00:10:54,759 --> 00:10:58,360
read the papers that have been coming

309
00:10:55,839 --> 00:11:00,339
out I'm not a microprocessor guru in

310
00:10:58,360 --> 00:11:01,989
fact the first exploit code for this I

311
00:11:00,339 --> 00:11:04,239
wrote on a piece of paper while sitting

312
00:11:01,989 --> 00:11:05,829
in a conference session I'm just

313
00:11:04,239 --> 00:11:08,230
thinking well this should work if if

314
00:11:05,829 --> 00:11:09,638
this thing does what speculative

315
00:11:08,230 --> 00:11:11,679
execution says and surely they know

316
00:11:09,639 --> 00:11:12,939
better but now they're right so so the

317
00:11:11,679 --> 00:11:15,130
first step then is is you've got a

318
00:11:12,939 --> 00:11:16,689
cyclic speculation scenario there's

319
00:11:15,130 --> 00:11:20,050
then some kind of a probably safe

320
00:11:16,690 --> 00:11:22,330
computation that becomes unsafe when

321
00:11:20,050 --> 00:11:24,189
it's run with these errors the second

322
00:11:22,330 --> 00:11:26,260
part of the attack there's a process

323
00:11:24,190 --> 00:11:28,330
than of inducing the speculation with

324
00:11:26,260 --> 00:11:30,130
the desired error and it turns out there

325
00:11:28,330 --> 00:11:31,900
are lots of ways that as an adversary

326
00:11:30,130 --> 00:11:33,790
you can miss train processors you can

327
00:11:31,900 --> 00:11:35,170
change the ways that caches are

328
00:11:33,790 --> 00:11:37,420
configured you can make a lot of these

329
00:11:35,170 --> 00:11:40,839
optimizations work in ways that are

330
00:11:37,420 --> 00:11:42,640
again beneficial they're beneficial for

331
00:11:40,840 --> 00:11:45,160
secure performance in the average case

332
00:11:42,640 --> 00:11:46,780
but not necessarily good for security in

333
00:11:45,160 --> 00:11:48,579
the pathological cases that an adversary

334
00:11:46,780 --> 00:11:50,230
might introduce we don't have some

335
00:11:48,580 --> 00:11:52,030
side-channel there are lots and lots of

336
00:11:50,230 --> 00:11:53,620
side channels in our modern chips and

337
00:11:52,030 --> 00:11:56,050
then some kind of detection and a leak

338
00:11:53,620 --> 00:11:57,460
and analysis process so they've already

339
00:11:56,050 --> 00:12:00,790
been a whole bunch of related results

340
00:11:57,460 --> 00:12:02,110
and there will be I think some at this

341
00:12:00,790 --> 00:12:03,880
conference some of the conference's and

342
00:12:02,110 --> 00:12:05,590
they're going to be more I'm aware of

343
00:12:03,880 --> 00:12:07,360
results that are still under embargo I'm

344
00:12:05,590 --> 00:12:09,130
aware of more things coming and I'm sure

345
00:12:07,360 --> 00:12:10,990
there are lots of things they're sort of

346
00:12:09,130 --> 00:12:13,540
variations on this theme that are going

347
00:12:10,990 --> 00:12:14,530
to be identified in the years ahead one

348
00:12:13,540 --> 00:12:15,939
of the interesting things that came from

349
00:12:14,530 --> 00:12:19,510
this was it was I was talking with

350
00:12:15,940 --> 00:12:21,160
processor a processor architect and I

351
00:12:19,510 --> 00:12:22,750
used the word bug to describe it and

352
00:12:21,160 --> 00:12:25,719
this person actually got kind of annoyed

353
00:12:22,750 --> 00:12:26,920
with me sort of realized well why would

354
00:12:25,720 --> 00:12:28,600
this person get annoyed when I called it

355
00:12:26,920 --> 00:12:30,729
a bug because the reason was that

356
00:12:28,600 --> 00:12:31,630
everything's working properly the branch

357
00:12:30,730 --> 00:12:33,520
predictors are working properly

358
00:12:31,630 --> 00:12:35,800
speculative execution is unwinding the

359
00:12:33,520 --> 00:12:39,340
state correctly you know the reads are

360
00:12:35,800 --> 00:12:40,870
fetching things that at least the victim

361
00:12:39,340 --> 00:12:42,700
process is allowed to read that we have

362
00:12:40,870 --> 00:12:44,110
lots of interrupts process security

363
00:12:42,700 --> 00:12:46,150
boundaries of the processor isn't aware

364
00:12:44,110 --> 00:12:47,890
about we've known about covert channels

365
00:12:46,150 --> 00:12:49,150
and so forth and everything is

366
00:12:47,890 --> 00:12:52,180
completely compliant with the

367
00:12:49,150 --> 00:12:53,800
specifications and so the idea that you

368
00:12:52,180 --> 00:12:55,540
are being criticized for doing something

369
00:12:53,800 --> 00:12:58,900
where you comply with the specifications

370
00:12:55,540 --> 00:13:00,520
struck this person is kind of unfair but

371
00:12:58,900 --> 00:13:02,740
I actually would argue that if it's not

372
00:13:00,520 --> 00:13:04,930
a bug it's a symptom and it's a symptom

373
00:13:02,740 --> 00:13:06,520
at first of something wrong with those

374
00:13:04,930 --> 00:13:08,890
specifications the contract between

375
00:13:06,520 --> 00:13:10,420
hardware and software is fundamentally

376
00:13:08,890 --> 00:13:13,240
broken right now and we're going to be

377
00:13:10,420 --> 00:13:15,370
learning more over the next months and

378
00:13:13,240 --> 00:13:18,550
years about how badly broken that

379
00:13:15,370 --> 00:13:21,070
contract is but the sort of root of it

380
00:13:18,550 --> 00:13:22,359
the root problem is that the guarantees

381
00:13:21,070 --> 00:13:24,490
that the hardware provides are

382
00:13:22,360 --> 00:13:26,830
fundamentally insufficient for security

383
00:13:24,490 --> 00:13:29,240
you cannot build the systems that we're

384
00:13:26,830 --> 00:13:31,700
building today relying only on

385
00:13:29,240 --> 00:13:33,350
those assumptions which means that and

386
00:13:31,700 --> 00:13:34,700
really the way those assumptions are

387
00:13:33,350 --> 00:13:36,380
written or those guarantees are written

388
00:13:34,700 --> 00:13:38,180
right now there's no guarantees really

389
00:13:36,380 --> 00:13:40,910
anything is kept secret even from other

390
00:13:38,180 --> 00:13:42,739
processes much less intra of process

391
00:13:40,910 --> 00:13:44,240
security domains which are critical for

392
00:13:42,740 --> 00:13:46,070
a lot of the different applications that

393
00:13:44,240 --> 00:13:48,230
are getting built right now so if you're

394
00:13:46,070 --> 00:13:49,550
a software developer you either shut

395
00:13:48,230 --> 00:13:50,600
down your business and you go home and

396
00:13:49,550 --> 00:13:52,399
you decide that you're not going to do

397
00:13:50,600 --> 00:13:53,839
anything or you just make a bunch of

398
00:13:52,399 --> 00:13:55,610
educated guesses and you kind of hope

399
00:13:53,839 --> 00:13:57,470
that they're right and maybe you do some

400
00:13:55,610 --> 00:13:59,660
experiments on the current hardware to

401
00:13:57,470 --> 00:14:02,450
test those but you have absolutely no

402
00:13:59,660 --> 00:14:04,370
confidence that a you're even truly

403
00:14:02,450 --> 00:14:06,740
right in all of the pathological cases

404
00:14:04,370 --> 00:14:08,750
an adversary might introduce and even

405
00:14:06,740 --> 00:14:10,250
worse the next hardware may come up with

406
00:14:08,750 --> 00:14:12,200
the great new memory compression

407
00:14:10,250 --> 00:14:13,490
whatchamacallit thing which creates a

408
00:14:12,200 --> 00:14:15,790
whole bunch of new side channels and

409
00:14:13,490 --> 00:14:17,600
makes the software that you wrote now

410
00:14:15,790 --> 00:14:20,240
catastrophic lis insecure when it's

411
00:14:17,600 --> 00:14:22,399
actually being used by your users so as

412
00:14:20,240 --> 00:14:24,230
research topics go one of the most

413
00:14:22,399 --> 00:14:26,209
important in security right now is the

414
00:14:24,230 --> 00:14:29,029
question of what kinds of guarantees

415
00:14:26,209 --> 00:14:31,489
should architecture architectures

416
00:14:29,029 --> 00:14:33,680
actually provide to the software and the

417
00:14:31,490 --> 00:14:35,920
minimum requirement is that you have

418
00:14:33,680 --> 00:14:40,189
something that is sufficient for

419
00:14:35,920 --> 00:14:42,680
idealized perfect software to be sort of

420
00:14:40,190 --> 00:14:46,490
secure in some kind of a vaguely

421
00:14:42,680 --> 00:14:47,750
defensible sense that's not really what

422
00:14:46,490 --> 00:14:48,829
we need though we actually something

423
00:14:47,750 --> 00:14:50,810
more than that we need something where

424
00:14:48,829 --> 00:14:52,370
we sort of minimize the likelihood that

425
00:14:50,810 --> 00:14:54,439
we're going to have a problem and that

426
00:14:52,370 --> 00:14:56,180
means actually putting into the equation

427
00:14:54,440 --> 00:14:57,440
realistic assumptions about how all of

428
00:14:56,180 --> 00:15:00,649
the engineering of the hardware and the

429
00:14:57,440 --> 00:15:02,149
software get done and I'm going to sort

430
00:15:00,649 --> 00:15:04,070
of beat on this speculation barrier

431
00:15:02,149 --> 00:15:06,200
instructions for about 30 seconds here I

432
00:15:04,070 --> 00:15:07,760
mean the response to the example I gave

433
00:15:06,200 --> 00:15:09,980
before variant one from prostitute

434
00:15:07,760 --> 00:15:12,410
vendors so far is largely put elephants

435
00:15:09,980 --> 00:15:13,790
or csdb instructions into your code at

436
00:15:12,410 --> 00:15:15,620
the places where something might go

437
00:15:13,790 --> 00:15:17,839
wrong and you're supposed to as a

438
00:15:15,620 --> 00:15:20,510
high-level language programmer working

439
00:15:17,839 --> 00:15:22,730
in some language that will compile down

440
00:15:20,510 --> 00:15:26,810
maybe through a JIT and so forth into

441
00:15:22,730 --> 00:15:29,959
some low-level instruction put these in

442
00:15:26,810 --> 00:15:31,369
somehow and knowing where to put them is

443
00:15:29,959 --> 00:15:32,510
kind of impossible but if you put them

444
00:15:31,370 --> 00:15:35,570
everywhere you completely destroy

445
00:15:32,510 --> 00:15:38,569
security and even messier you've got

446
00:15:35,570 --> 00:15:39,800
these intra process scenarios where you

447
00:15:38,570 --> 00:15:41,910
may have a language where you'd like to

448
00:15:39,800 --> 00:15:44,459
have some kind of safety where you

449
00:15:41,910 --> 00:15:46,589
and trust that when I call my D you know

450
00:15:44,460 --> 00:15:47,910
decrypt function or my compressed image

451
00:15:46,590 --> 00:15:49,830
function that it won't steal all the

452
00:15:47,910 --> 00:15:53,630
data out of my process memory space but

453
00:15:49,830 --> 00:15:57,120
I can't really know that if I don't have

454
00:15:53,630 --> 00:15:58,770
L fences everywhere that I need in this

455
00:15:57,120 --> 00:16:00,630
other library that perhaps even somebody

456
00:15:58,770 --> 00:16:02,400
else compiled so huge mess right now and

457
00:16:00,630 --> 00:16:04,890
we need to figure out a solution to that

458
00:16:02,400 --> 00:16:06,510
mess if we'd like to be able to build

459
00:16:04,890 --> 00:16:09,000
really nice beautiful things on top of

460
00:16:06,510 --> 00:16:10,170
these foundations and then you can put

461
00:16:09,000 --> 00:16:11,370
the challenge on top of that of dealing

462
00:16:10,170 --> 00:16:13,439
with performance power legacy

463
00:16:11,370 --> 00:16:15,390
compatibility diarrhea and so forth so

464
00:16:13,440 --> 00:16:16,740
the even bigger symptom here is that

465
00:16:15,390 --> 00:16:20,189
we've let complexity just go absolutely

466
00:16:16,740 --> 00:16:22,590
nuts in our system so the history of

467
00:16:20,190 --> 00:16:24,510
scaling it used to be that security to

468
00:16:22,590 --> 00:16:25,980
do economically was this big and the

469
00:16:24,510 --> 00:16:27,840
performance gains were economically this

470
00:16:25,980 --> 00:16:29,280
important so everything you could do to

471
00:16:27,840 --> 00:16:31,710
help performance was the right thing to

472
00:16:29,280 --> 00:16:34,230
do economically for the bulk of users

473
00:16:31,710 --> 00:16:35,880
we're no longer there security is a more

474
00:16:34,230 --> 00:16:38,040
than trillion dollar your problem and

475
00:16:35,880 --> 00:16:39,390
the performance gains for many

476
00:16:38,040 --> 00:16:40,980
applications are kind of irrelevant

477
00:16:39,390 --> 00:16:42,530
because the computers are fast enough

478
00:16:40,980 --> 00:16:44,670
especially for these older applications

479
00:16:42,530 --> 00:16:46,709
so the balance is shifted where

480
00:16:44,670 --> 00:16:48,719
performance matters less than security

481
00:16:46,710 --> 00:16:50,280
now and I'm people are even saying this

482
00:16:48,720 --> 00:16:53,250
outside of security conferences it's

483
00:16:50,280 --> 00:16:55,380
great but our mindsets have a big

484
00:16:53,250 --> 00:16:57,630
latency I mean I if you if you look at

485
00:16:55,380 --> 00:16:59,490
computer architecture papers they don't

486
00:16:57,630 --> 00:17:01,710
talk about security you look at security

487
00:16:59,490 --> 00:17:03,690
papers and their expend huge amounts of

488
00:17:01,710 --> 00:17:06,000
time agonizing over the 2% performance

489
00:17:03,690 --> 00:17:07,860
hit that they wouldn't do so we are sort

490
00:17:06,000 --> 00:17:10,410
of our mindsets are wrong the leadership

491
00:17:07,859 --> 00:17:12,839
was built build their careers in the old

492
00:17:10,410 --> 00:17:14,100
world companies built their success in

493
00:17:12,839 --> 00:17:16,500
the old world we have a lot of changing

494
00:17:14,099 --> 00:17:18,119
to make but we need I think to build

495
00:17:16,500 --> 00:17:19,920
different designs for performance and

496
00:17:18,119 --> 00:17:21,689
security I think we can put them in the

497
00:17:19,920 --> 00:17:24,300
same die if we want to so you can have

498
00:17:21,690 --> 00:17:27,210
safe slower safer but slower places to

499
00:17:24,300 --> 00:17:28,860
run your code and perhaps a faster but

500
00:17:27,210 --> 00:17:31,050
more dangerous ones but we need to

501
00:17:28,860 --> 00:17:32,490
figure this out and this is an enormous

502
00:17:31,050 --> 00:17:35,700
research problem but I hope some of you

503
00:17:32,490 --> 00:17:37,650
will embrace all right I am out of time

504
00:17:35,700 --> 00:17:40,310
so I can take questions for just a

505
00:17:37,650 --> 00:17:40,310
couple of minutes here

506
00:17:44,559 --> 00:17:49,549
Peter all right we have some time few

507
00:17:47,749 --> 00:17:50,809
minutes for questions as you're doing

508
00:17:49,549 --> 00:17:53,809
please state your name and affiliation

509
00:17:50,809 --> 00:17:56,178
your my Minister I an old-world story

510
00:17:53,809 --> 00:17:58,009
for you in 1980 at the very first

511
00:17:56,179 --> 00:18:00,950
conference Hilda Faust who was the

512
00:17:58,009 --> 00:18:02,919
director of research for NSA and a

513
00:18:00,950 --> 00:18:05,809
remarkably wonderful person who

514
00:18:02,919 --> 00:18:09,169
contributed greatly to the community was

515
00:18:05,809 --> 00:18:10,908
asked about covert channels she said and

516
00:18:09,169 --> 00:18:15,399
she had of course worried about them a

517
00:18:10,909 --> 00:18:18,710
great deal inside of the agency I think

518
00:18:15,399 --> 00:18:22,850
that Cobra channels are the she would

519
00:18:18,710 --> 00:18:25,789
have used the term low-hanging fruit I'm

520
00:18:22,850 --> 00:18:29,928
sorry she would have used them sorry I

521
00:18:25,789 --> 00:18:34,340
bust that she commented that there's so

522
00:18:29,929 --> 00:18:36,470
much other low-hanging fruit that it is

523
00:18:34,340 --> 00:18:38,678
almost worthless to worry about covert

524
00:18:36,470 --> 00:18:41,629
channels that was that was 40 years ago

525
00:18:38,679 --> 00:18:43,039
my question to you is is the clean slate

526
00:18:41,629 --> 00:18:44,719
architecture question if you were

527
00:18:43,039 --> 00:18:50,029
starting all over today in building

528
00:18:44,720 --> 00:18:51,289
processors what would you do but I think

529
00:18:50,029 --> 00:18:52,730
you shouldn't even start with say

530
00:18:51,289 --> 00:18:54,408
building process of building processors

531
00:18:52,730 --> 00:18:55,850
and the kernel around them and I think

532
00:18:54,409 --> 00:18:58,639
that right the question is what should

533
00:18:55,850 --> 00:18:59,899
the TCB look like the minimum set of

534
00:18:58,639 --> 00:19:02,238
thing the set of things that your

535
00:18:59,899 --> 00:19:04,959
security depends on and I think we need

536
00:19:02,239 --> 00:19:07,369
a environments where we can bootstrap

537
00:19:04,960 --> 00:19:09,230
really high assurance security or at

538
00:19:07,369 --> 00:19:11,119
least low probability of failure

539
00:19:09,230 --> 00:19:13,669
environments for low performance use

540
00:19:11,119 --> 00:19:16,220
cases like reading email approving wire

541
00:19:13,669 --> 00:19:17,629
transfers holding your your crypto

542
00:19:16,220 --> 00:19:18,889
currencies whatever the things you've

543
00:19:17,629 --> 00:19:20,418
got that are there's a whole bunch of

544
00:19:18,889 --> 00:19:24,019
these tasks that you used to be able to

545
00:19:20,419 --> 00:19:25,730
do on an offline PC you where you know a

546
00:19:24,019 --> 00:19:27,350
machine from 10 years ago is fast enough

547
00:19:25,730 --> 00:19:28,580
and we have a pretty good sense of what

548
00:19:27,350 --> 00:19:30,379
the building blocks we need for these

549
00:19:28,580 --> 00:19:32,809
kinds of architectures might look like

550
00:19:30,379 --> 00:19:34,428
we have ideas of what encrypted memory

551
00:19:32,809 --> 00:19:37,570
might look like like what might look

552
00:19:34,429 --> 00:19:40,970
like we can we have ideas of what

553
00:19:37,570 --> 00:19:43,039
processors with defined timing or

554
00:19:40,970 --> 00:19:45,080
certain you make rules about what is

555
00:19:43,039 --> 00:19:46,669
allowed to affect timing what isn't your

556
00:19:45,080 --> 00:19:48,379
contact switches look very different if

557
00:19:46,669 --> 00:19:49,970
you care about security it's not how

558
00:19:48,379 --> 00:19:53,019
little information can I touch but how

559
00:19:49,970 --> 00:19:55,430
can I zero eyes huge chunks of my

560
00:19:53,019 --> 00:19:57,920
circuitry so there's a bunch of proper

561
00:19:55,430 --> 00:19:59,510
that certainly we don't have in our

562
00:19:57,920 --> 00:20:02,270
current processors that could be put

563
00:19:59,510 --> 00:20:04,250
into these the good news we also have is

564
00:20:02,270 --> 00:20:05,810
that transistors are super super cheap

565
00:20:04,250 --> 00:20:07,910
right now and they're going to even

566
00:20:05,810 --> 00:20:09,889
continue to get cheaper so the idea of

567
00:20:07,910 --> 00:20:11,780
putting a small enough processor that

568
00:20:09,890 --> 00:20:14,240
our brains can kind of comprehend to

569
00:20:11,780 --> 00:20:16,250
them onto the die with these sort of

570
00:20:14,240 --> 00:20:18,680
monstrous many billion transistor

571
00:20:16,250 --> 00:20:21,890
processors isn't a cost issue it's

572
00:20:18,680 --> 00:20:23,630
really just a ideas and effort and

573
00:20:21,890 --> 00:20:26,360
one-time investment kind of things I

574
00:20:23,630 --> 00:20:28,370
think it is a problem where we can do a

575
00:20:26,360 --> 00:20:30,139
much better job now we may screw that up

576
00:20:28,370 --> 00:20:32,540
and then find that we need to do yet

577
00:20:30,140 --> 00:20:34,040
another more secure environment and

578
00:20:32,540 --> 00:20:35,629
maybe some series of these things that

579
00:20:34,040 --> 00:20:37,550
get built over the years but we've got

580
00:20:35,630 --> 00:20:39,140
to start somewhere and we're not going

581
00:20:37,550 --> 00:20:40,700
to get from where we are to somewhere

582
00:20:39,140 --> 00:20:42,800
better by trying harder because

583
00:20:40,700 --> 00:20:44,720
complexities introducing problems faster

584
00:20:42,800 --> 00:20:46,610
than we're fixing them so and we're also

585
00:20:44,720 --> 00:20:48,470
just so overwhelmed with complexity

586
00:20:46,610 --> 00:20:49,879
we're never going to have tools that can

587
00:20:48,470 --> 00:20:51,500
really reason about that and our brains

588
00:20:49,880 --> 00:20:54,080
can't either so we've got to sort of

589
00:20:51,500 --> 00:20:56,090
step back build something simpler try to

590
00:20:54,080 --> 00:20:57,740
understand what its properties are try

591
00:20:56,090 --> 00:20:59,600
to get it used for useful things and

592
00:20:57,740 --> 00:21:02,750
then let the world kind of evolve from

593
00:20:59,600 --> 00:21:03,860
there it's my hope about something that

594
00:21:02,750 --> 00:21:06,910
might work all right

595
00:21:03,860 --> 00:21:10,270
let's thank our speaker one more time

596
00:21:06,910 --> 00:21:10,270
thank you very much

