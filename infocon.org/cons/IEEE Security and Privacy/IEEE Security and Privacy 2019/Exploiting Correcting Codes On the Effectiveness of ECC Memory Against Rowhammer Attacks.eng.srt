1
00:00:09,730 --> 00:00:14,230
hello everyone I'm Nisshin and today

2
00:00:12,430 --> 00:00:16,000
I'll be talking about

3
00:00:14,230 --> 00:00:17,950
we can exploit error correction codes

4
00:00:16,000 --> 00:00:22,150
basically how we can still run a row

5
00:00:17,950 --> 00:00:24,730
hammer attack on ECC memory actually the

6
00:00:22,150 --> 00:00:28,598
story is about how I spent my past let's

7
00:00:24,730 --> 00:00:30,880
say two years and what is the yeah the

8
00:00:28,599 --> 00:00:33,370
thing with the series needles and what

9
00:00:30,880 --> 00:00:35,530
is my life I'm not sure if I had no life

10
00:00:33,370 --> 00:00:39,218
but anyways the Internet is right most

11
00:00:35,530 --> 00:00:41,860
of the times yeah so row hammer we all

12
00:00:39,219 --> 00:00:45,040
know that row hammer causes bits to flip

13
00:00:41,860 --> 00:00:47,050
that's like the canonical example that

14
00:00:45,040 --> 00:00:49,300
we can use to trigger this bit flip we

15
00:00:47,050 --> 00:00:51,640
also know that there are lots of

16
00:00:49,300 --> 00:00:53,500
exploits already written and people

17
00:00:51,640 --> 00:00:55,810
people show how we can escalate

18
00:00:53,500 --> 00:00:59,079
privileges or how we can escape

19
00:00:55,810 --> 00:01:02,590
sandboxes again we can also like

20
00:00:59,079 --> 00:01:05,079
compromise confidentiality and also the

21
00:01:02,590 --> 00:01:08,320
row hammer attack was shown to work on

22
00:01:05,078 --> 00:01:10,899
desktop computers on phones and even we

23
00:01:08,320 --> 00:01:14,110
could trigger bit lips in in GPUs and we

24
00:01:10,899 --> 00:01:16,840
can do so even from over the network so

25
00:01:14,110 --> 00:01:20,409
this is all previous work however

26
00:01:16,840 --> 00:01:23,350
everything every previous work so far

27
00:01:20,409 --> 00:01:25,240
was working on non server memory so the

28
00:01:23,350 --> 00:01:28,479
question is what is so special about

29
00:01:25,240 --> 00:01:30,969
server memory and this is where is EC

30
00:01:28,479 --> 00:01:33,789
ployed comes into play so ECC ploy it is

31
00:01:30,969 --> 00:01:35,949
a row hammer exploit that will work on

32
00:01:33,789 --> 00:01:38,889
server memory server memory has a

33
00:01:35,950 --> 00:01:41,229
special capability most of the times and

34
00:01:38,889 --> 00:01:44,259
that is it can correct some of the bits

35
00:01:41,229 --> 00:01:48,369
some of the bit lips it does so by using

36
00:01:44,259 --> 00:01:51,819
a extra chip that stores this control or

37
00:01:48,369 --> 00:01:55,600
redundant bit so ECC ployed aims this

38
00:01:51,819 --> 00:01:57,939
this type of memory this is the overview

39
00:01:55,600 --> 00:02:01,029
of my talk I'll try to do some

40
00:01:57,939 --> 00:02:04,839
challenges for pulling the row hammer

41
00:02:01,029 --> 00:02:07,060
attack on ECC memory I'll I also argue

42
00:02:04,840 --> 00:02:09,819
why single bit tips are still important

43
00:02:07,060 --> 00:02:15,310
for for ECC memory and how we can build

44
00:02:09,818 --> 00:02:18,220
upon the single bit clips to launch the

45
00:02:15,310 --> 00:02:20,860
final attack and lastly I'm going to

46
00:02:18,220 --> 00:02:22,930
show how we reverse engineer some some

47
00:02:20,860 --> 00:02:25,629
ECC functions that are implemented in

48
00:02:22,930 --> 00:02:28,330
hardware and of course I have to talk

49
00:02:25,629 --> 00:02:31,329
about the results now

50
00:02:28,330 --> 00:02:33,939
as I said yeah in CC just correct some

51
00:02:31,330 --> 00:02:36,310
of the bit list right but so what makes

52
00:02:33,939 --> 00:02:38,828
then the exploitation of a CC memory is

53
00:02:36,310 --> 00:02:41,500
so difficult in practice we just need

54
00:02:38,829 --> 00:02:44,709
more bit lips that should be that should

55
00:02:41,500 --> 00:02:47,980
be the strategy right well it turns out

56
00:02:44,709 --> 00:02:50,860
that morbid lips makes the life harder

57
00:02:47,980 --> 00:02:54,819
for us and also it could be dangerous to

58
00:02:50,860 --> 00:02:57,250
get too many big lips at some point in

59
00:02:54,819 --> 00:03:00,429
short the odds are against us so for

60
00:02:57,250 --> 00:03:02,049
example it's very easy to get one bit to

61
00:03:00,430 --> 00:03:05,260
flip there are so many bits that are

62
00:03:02,049 --> 00:03:07,629
flipping there are so many 1 bits that

63
00:03:05,260 --> 00:03:10,420
are flipping but it's very difficult to

64
00:03:07,629 --> 00:03:14,230
get the same more than more or 3 bits

65
00:03:10,420 --> 00:03:17,559
that that flip so this is this is the

66
00:03:14,230 --> 00:03:20,738
probability of of encountering this

67
00:03:17,560 --> 00:03:23,109
these cases so let's see what what

68
00:03:20,739 --> 00:03:26,200
happens when one bit is flipped so one

69
00:03:23,109 --> 00:03:28,840
bit when one with changes in memory any

70
00:03:26,200 --> 00:03:30,399
CC function out there will be able to

71
00:03:28,840 --> 00:03:32,260
correct it right because it stands for

72
00:03:30,400 --> 00:03:34,829
error correction code and at least it

73
00:03:32,260 --> 00:03:39,310
should do something for at least one bit

74
00:03:34,829 --> 00:03:41,230
if two bits are are flipped then this

75
00:03:39,310 --> 00:03:46,510
could be a potential uncorrectable error

76
00:03:41,230 --> 00:03:48,849
and potentially the and the machine if

77
00:03:46,510 --> 00:03:50,828
it detects this this potentially

78
00:03:48,849 --> 00:03:52,929
uncorrectable error then the machine

79
00:03:50,829 --> 00:03:58,030
would crash or at least the process that

80
00:03:52,930 --> 00:04:01,120
causes the the uncorrectable error will

81
00:03:58,030 --> 00:04:03,370
have to crash so countermeasure has to

82
00:04:01,120 --> 00:04:06,879
be taking has has to be taken by the

83
00:04:03,370 --> 00:04:09,190
host if more bits are flipping then this

84
00:04:06,879 --> 00:04:11,409
error becomes it could be a potentially

85
00:04:09,190 --> 00:04:14,290
uncorrectable one and potentially

86
00:04:11,409 --> 00:04:17,469
undetectable so we have we have a chance

87
00:04:14,290 --> 00:04:18,940
there to go let's say undetected so I

88
00:04:17,470 --> 00:04:20,799
have mentioned the word potentially

89
00:04:18,940 --> 00:04:24,190
several times in this slide and the

90
00:04:20,798 --> 00:04:26,969
reason for doing so is that some of the

91
00:04:24,190 --> 00:04:29,770
details some of these details are very

92
00:04:26,970 --> 00:04:32,500
implementation specific so not all of

93
00:04:29,770 --> 00:04:34,690
the for example not all three bits that

94
00:04:32,500 --> 00:04:38,770
are sleeping can be corrected some of

95
00:04:34,690 --> 00:04:42,099
them are just not detected right and

96
00:04:38,770 --> 00:04:44,620
this is basically the yeah to put in in

97
00:04:42,099 --> 00:04:45,669
the Rope row hammer context one bit if

98
00:04:44,620 --> 00:04:47,379
we sleep one bit

99
00:04:45,669 --> 00:04:49,599
then this is kind of useless for Oh

100
00:04:47,379 --> 00:04:54,370
hammer we cannot exploit a bit that was

101
00:04:49,599 --> 00:04:57,370
corrected to two bit if two bits are

102
00:04:54,370 --> 00:04:59,770
flipping then the machine crash and the

103
00:04:57,370 --> 00:05:02,770
machine will crash and actually this is

104
00:04:59,770 --> 00:05:04,990
just a denial of service attack and to

105
00:05:02,770 --> 00:05:07,330
date this was the this is the state of

106
00:05:04,990 --> 00:05:10,240
the art so we kind of know that row

107
00:05:07,330 --> 00:05:14,020
hammer on ECC memory will cause a denial

108
00:05:10,240 --> 00:05:17,849
of service attack and this is this is

109
00:05:14,020 --> 00:05:20,318
our baseline so easy support coming in

110
00:05:17,849 --> 00:05:22,690
comes here in place and upgrade this

111
00:05:20,319 --> 00:05:26,440
denial of service attack to a powerful

112
00:05:22,690 --> 00:05:30,819
attack we we managed to cause

113
00:05:26,440 --> 00:05:32,949
undetectable undetectable bit flips thus

114
00:05:30,819 --> 00:05:38,229
these are like silent error corruption

115
00:05:32,949 --> 00:05:40,900
silent silent memory corruption right so

116
00:05:38,229 --> 00:05:45,068
this is what sec plate does let's see

117
00:05:40,900 --> 00:05:47,469
how let's see how how it works

118
00:05:45,069 --> 00:05:49,780
well the question is how we can get from

119
00:05:47,469 --> 00:05:52,120
one bit flip to three bit flips

120
00:05:49,780 --> 00:05:55,239
without causing these crashes so without

121
00:05:52,120 --> 00:05:58,240
having to two-bit flips by the way here

122
00:05:55,240 --> 00:06:00,669
I'm using one two or three but in in

123
00:05:58,240 --> 00:06:03,310
practice it really depends on how HCC is

124
00:06:00,669 --> 00:06:06,789
implemented and these are some let's say

125
00:06:03,310 --> 00:06:09,190
some example guarantees that it can be

126
00:06:06,789 --> 00:06:11,318
that if you see can give but I'm going

127
00:06:09,190 --> 00:06:14,560
to stick with these these numbers now

128
00:06:11,319 --> 00:06:16,750
for simplicity right so the question is

129
00:06:14,560 --> 00:06:19,330
how do you get from one to three bit

130
00:06:16,750 --> 00:06:22,000
flips well

131
00:06:19,330 --> 00:06:25,448
we devised a strategy which roughly has

132
00:06:22,000 --> 00:06:27,969
two steps first we gather single bit

133
00:06:25,449 --> 00:06:30,849
flip so we gather a set of single bit

134
00:06:27,969 --> 00:06:34,900
flips we can do so by by row hammering

135
00:06:30,849 --> 00:06:37,539
and then we try to combine or pick some

136
00:06:34,900 --> 00:06:40,690
combination from this set of bit flips

137
00:06:37,539 --> 00:06:42,669
and see how many of these or which one

138
00:06:40,690 --> 00:06:46,120
of them the combination will cause a

139
00:06:42,669 --> 00:06:48,820
silent corruption basically the ECC

140
00:06:46,120 --> 00:06:49,950
function will return the same value for

141
00:06:48,820 --> 00:06:52,440
the original

142
00:06:49,950 --> 00:06:55,440
and but also for the corrupted data so

143
00:06:52,440 --> 00:06:58,170
this is in a nutshell the attack now

144
00:06:55,440 --> 00:07:00,840
let's look up some some challenges so

145
00:06:58,170 --> 00:07:06,780
I'll talk about about getting these

146
00:07:00,840 --> 00:07:10,169
single bit flips so so we can cause a

147
00:07:06,780 --> 00:07:12,000
single we we want to cost just exactly a

148
00:07:10,170 --> 00:07:15,510
single bit slip if we would cause to

149
00:07:12,000 --> 00:07:19,110
that the the machine will crash and of

150
00:07:15,510 --> 00:07:21,000
course the exploit would be detected the

151
00:07:19,110 --> 00:07:24,000
way to do this is to piggyback on the

152
00:07:21,000 --> 00:07:26,940
fact that most of the bit flips they do

153
00:07:24,000 --> 00:07:31,290
have a direction of flipping so let's

154
00:07:26,940 --> 00:07:37,050
say if a bit only flips from from 1 to 0

155
00:07:31,290 --> 00:07:38,670
and if that bit flip has the 0 as the

156
00:07:37,050 --> 00:07:41,700
original value then the bit wouldn't

157
00:07:38,670 --> 00:07:44,340
flip back so the idea is to mask at the

158
00:07:41,700 --> 00:07:47,400
time or to unmask at the time a bit of a

159
00:07:44,340 --> 00:07:49,710
target so in that example we we have the

160
00:07:47,400 --> 00:07:52,169
two agressor rows and we have the victim

161
00:07:49,710 --> 00:07:56,099
arrow in between and we just want to

162
00:07:52,170 --> 00:07:58,890
test if the bit that has the value 0 has

163
00:07:56,100 --> 00:08:02,040
a bit tip or not good sleep or not we do

164
00:07:58,890 --> 00:08:04,260
this for the first bit in a row and then

165
00:08:02,040 --> 00:08:07,920
we move on to the other two the other

166
00:08:04,260 --> 00:08:10,349
bits in the individual row and so forth

167
00:08:07,920 --> 00:08:14,700
right so right now we have a way to

168
00:08:10,350 --> 00:08:17,220
cause - cause exactly one bit but any I

169
00:08:14,700 --> 00:08:19,229
said that ECC will correct at least one

170
00:08:17,220 --> 00:08:23,580
bit rip so the next challenge would be

171
00:08:19,230 --> 00:08:25,440
to see how we can observe that our bit

172
00:08:23,580 --> 00:08:29,820
candidate is actually a bit sleep or not

173
00:08:25,440 --> 00:08:31,620
and I think every every every speaker

174
00:08:29,820 --> 00:08:33,450
before me mentioned side channels yes

175
00:08:31,620 --> 00:08:36,419
side channels are everywhere including

176
00:08:33,450 --> 00:08:39,590
in the error correction hardware

177
00:08:36,419 --> 00:08:44,339
including either error correction harder

178
00:08:39,590 --> 00:08:46,890
so you can imagine that when when bit

179
00:08:44,340 --> 00:08:50,010
flip is corrected there's little slow

180
00:08:46,890 --> 00:08:52,470
path that is taken and this path has or

181
00:08:50,010 --> 00:08:54,980
error path in the hardware and this path

182
00:08:52,470 --> 00:08:57,870
will have a performance on the memory

183
00:08:54,980 --> 00:09:01,550
accesses so for example here we have

184
00:08:57,870 --> 00:09:04,550
five instances of off bit flips the

185
00:09:01,550 --> 00:09:06,680
the the y-axis measures the the

186
00:09:04,550 --> 00:09:08,689
performance basically the number of

187
00:09:06,680 --> 00:09:12,260
cycles it takes to access the memory and

188
00:09:08,690 --> 00:09:14,870
the x-axis is just a offset inside the

189
00:09:12,260 --> 00:09:17,450
row that we test for for bit flips so

190
00:09:14,870 --> 00:09:20,210
it's a its word offset right and we can

191
00:09:17,450 --> 00:09:22,430
clearly see the distinctions between the

192
00:09:20,210 --> 00:09:24,590
distinction between normal execution and

193
00:09:22,430 --> 00:09:25,699
some of those Peaks actually it turns

194
00:09:24,590 --> 00:09:30,110
out that those Peaks

195
00:09:25,700 --> 00:09:32,120
we we had a way to to to check where the

196
00:09:30,110 --> 00:09:36,530
bit leap happened actually those peak

197
00:09:32,120 --> 00:09:40,730
Peaks they do correspond to to a bit

198
00:09:36,530 --> 00:09:43,069
being corrected by by the hardware right

199
00:09:40,730 --> 00:09:45,170
so I talked about how we can get the

200
00:09:43,070 --> 00:09:47,360
single bit flips but let's see how we

201
00:09:45,170 --> 00:09:50,900
can combine them to cause this silent

202
00:09:47,360 --> 00:09:53,930
seven corruptions again the goal of this

203
00:09:50,900 --> 00:09:57,199
step would be to combine some of the bit

204
00:09:53,930 --> 00:10:01,790
tips such that the ECC function will

205
00:09:57,200 --> 00:10:03,530
return let's say a sim the same value so

206
00:10:01,790 --> 00:10:06,079
if it's the same value as the data not

207
00:10:03,530 --> 00:10:08,030
being corrupted then this will be a

208
00:10:06,080 --> 00:10:10,570
silent corruption and this is what we

209
00:10:08,030 --> 00:10:13,550
are looking for furthermore you can

210
00:10:10,570 --> 00:10:15,980
think about if you see that it does not

211
00:10:13,550 --> 00:10:18,829
correct any bit flips but actually the

212
00:10:15,980 --> 00:10:24,500
the bits that are being corrected there

213
00:10:18,830 --> 00:10:28,670
also depend on their position so it ECC

214
00:10:24,500 --> 00:10:31,700
would not correct any any any bit flips

215
00:10:28,670 --> 00:10:34,550
but let's say it will correct first

216
00:10:31,700 --> 00:10:37,790
second and third but then if the bit

217
00:10:34,550 --> 00:10:40,490
flips are actually mapped let's say the

218
00:10:37,790 --> 00:10:42,680
first one and then we have two bytes and

219
00:10:40,490 --> 00:10:44,570
then another bit flip deserve maybe it's

220
00:10:42,680 --> 00:10:46,430
not it's not corrected and all of these

221
00:10:44,570 --> 00:10:50,260
details are very much implementation

222
00:10:46,430 --> 00:10:53,089
specific in addition there's not much

223
00:10:50,260 --> 00:10:55,970
this this implementation which is very

224
00:10:53,090 --> 00:10:57,770
tight very much tied to harder it's not

225
00:10:55,970 --> 00:11:00,440
something public so it's very hard to

226
00:10:57,770 --> 00:11:03,590
get some documentation about it usually

227
00:11:00,440 --> 00:11:05,450
you get some guarantees like it's a sec

228
00:11:03,590 --> 00:11:08,030
dead-like implementation but not more

229
00:11:05,450 --> 00:11:10,280
than that so as I said there's not much

230
00:11:08,030 --> 00:11:13,379
documentation out there so what can we

231
00:11:10,280 --> 00:11:15,119
do our our approach was to do

232
00:11:13,379 --> 00:11:17,699
to reverse-engineer some SEC

233
00:11:15,119 --> 00:11:21,359
implementations that are out there

234
00:11:17,699 --> 00:11:23,689
we started at observation that if we

235
00:11:21,359 --> 00:11:27,660
have access to error correction errors

236
00:11:23,689 --> 00:11:30,089
in this settlement terminology these are

237
00:11:27,660 --> 00:11:32,339
called syndromes these errors these

238
00:11:30,089 --> 00:11:34,739
intermediate results are actually

239
00:11:32,339 --> 00:11:37,319
revealing information about the ACC

240
00:11:34,739 --> 00:11:40,319
implementation we had two approaches

241
00:11:37,319 --> 00:11:43,289
here one based on fault injection you

242
00:11:40,319 --> 00:11:44,998
know it with some needles and one with a

243
00:11:43,289 --> 00:11:47,899
cold boot attack in this talk I'm going

244
00:11:44,999 --> 00:11:52,199
to just focus on the fourteen gyptian

245
00:11:47,899 --> 00:11:55,829
part so what happens when the CPU writes

246
00:11:52,199 --> 00:11:59,878
some data to to memory the memory

247
00:11:55,829 --> 00:12:02,638
controller will add will compute the ACC

248
00:11:59,879 --> 00:12:05,939
of this data and then it will store the

249
00:12:02,639 --> 00:12:08,669
ACC bits along next to the data in this

250
00:12:05,939 --> 00:12:12,299
let's say in a separate chip there on

251
00:12:08,669 --> 00:12:13,978
the memory nowadays the memory

252
00:12:12,299 --> 00:12:16,589
controller and the CPU are actually on

253
00:12:13,979 --> 00:12:20,100
the same on the same chip so what

254
00:12:16,589 --> 00:12:21,869
happens when the CPU reads the data the

255
00:12:20,100 --> 00:12:25,769
memory cover will also read this control

256
00:12:21,869 --> 00:12:28,499
bit it will compute the ACC function on

257
00:12:25,769 --> 00:12:30,839
the data that it received it will

258
00:12:28,499 --> 00:12:34,499
compare the computed ECC with the one

259
00:12:30,839 --> 00:12:37,649
that it expects so with sorry the one

260
00:12:34,499 --> 00:12:40,949
that expect we will compare it and

261
00:12:37,649 --> 00:12:43,709
compare it with the control bits that

262
00:12:40,949 --> 00:12:45,269
were stored in memory if this these two

263
00:12:43,709 --> 00:12:47,248
results are the same then there's no

264
00:12:45,269 --> 00:12:49,379
error but otherwise if the results are

265
00:12:47,249 --> 00:12:51,299
different then it means that someone or

266
00:12:49,379 --> 00:12:53,549
something changed the data while the

267
00:12:51,299 --> 00:12:56,189
data was stored in memory and most of

268
00:12:53,549 --> 00:12:59,789
the times these these errors these

269
00:12:56,189 --> 00:13:01,829
results are very useful to ensure

270
00:12:59,789 --> 00:13:04,169
reliability availability and

271
00:13:01,829 --> 00:13:05,789
serviceability for four servers so

272
00:13:04,169 --> 00:13:08,999
therefore these results are somewhere

273
00:13:05,789 --> 00:13:12,239
saved for let's say later processing as

274
00:13:08,999 --> 00:13:13,679
if your memory would be about on the

275
00:13:12,239 --> 00:13:15,359
verge of crashing then you would get

276
00:13:13,679 --> 00:13:17,669
lots of errors and then you can send

277
00:13:15,359 --> 00:13:22,409
someone to maybe replace replace the

278
00:13:17,669 --> 00:13:24,929
memory there our idea was to cause able

279
00:13:22,409 --> 00:13:26,079
to explicitly cause disease and we did

280
00:13:24,929 --> 00:13:31,800
so using

281
00:13:26,079 --> 00:13:34,868
a fault injection approach we physically

282
00:13:31,800 --> 00:13:37,209
injected errors by shorting some signals

283
00:13:34,869 --> 00:13:39,309
on the memory bus with the custom to

284
00:13:37,209 --> 00:13:43,179
sense probe that we built with a needle

285
00:13:39,309 --> 00:13:45,850
yes that is a syringe needle and yeah it

286
00:13:43,179 --> 00:13:48,220
was fun to build that that probe at

287
00:13:45,850 --> 00:13:51,670
least so the idea is that we we caused

288
00:13:48,220 --> 00:13:54,670
this error on purpose and then we gather

289
00:13:51,670 --> 00:13:57,939
this data that we can use to reverse

290
00:13:54,670 --> 00:14:02,049
engineer the ECC function all of the

291
00:13:57,939 --> 00:14:04,179
details on how this all of the

292
00:14:02,049 --> 00:14:09,279
mathematical explanation of this is is

293
00:14:04,179 --> 00:14:11,920
in the paper now I would I think I yeah

294
00:14:09,279 --> 00:14:13,449
I covered the how to get beef lips and

295
00:14:11,920 --> 00:14:16,089
how to reverse in your day CC function

296
00:14:13,449 --> 00:14:18,758
now let's look on how ECC ployed

297
00:14:16,089 --> 00:14:21,910
actually works first in the first step

298
00:14:18,759 --> 00:14:25,629
attacker would recover a sec function he

299
00:14:21,910 --> 00:14:27,910
can do this offline by having a server

300
00:14:25,629 --> 00:14:30,369
or a target machine that is very similar

301
00:14:27,910 --> 00:14:33,459
to the one that she wants to target once

302
00:14:30,369 --> 00:14:35,529
he knows this the CCC function he can

303
00:14:33,459 --> 00:14:37,899
move to the two templating the memory

304
00:14:35,529 --> 00:14:40,179
this is like an online phase where he

305
00:14:37,899 --> 00:14:44,139
avoids crashes by triggering single

306
00:14:40,179 --> 00:14:45,160
single bit flips he then combines this

307
00:14:44,139 --> 00:14:47,499
single bit flips

308
00:14:45,160 --> 00:14:50,259
according to the ECC function that he

309
00:14:47,499 --> 00:14:53,079
just fingerprinted and it combines the

310
00:14:50,259 --> 00:14:55,029
single bishops in such that they become

311
00:14:53,079 --> 00:14:57,699
undetectable and silent silent

312
00:14:55,029 --> 00:14:59,499
corruptions then we have the messaging

313
00:14:57,699 --> 00:15:01,240
the memory which is just releasing the

314
00:14:59,499 --> 00:15:03,579
victim row with the with the bit flips

315
00:15:01,240 --> 00:15:04,809
to the operating system charge that the

316
00:15:03,579 --> 00:15:07,479
operating system would learn some

317
00:15:04,809 --> 00:15:09,368
interesting data and then finally we ran

318
00:15:07,480 --> 00:15:13,089
the exploit the last two steps are

319
00:15:09,369 --> 00:15:16,179
exactly the same as the canonical ECC

320
00:15:13,089 --> 00:15:18,399
exploit now so how long does it take

321
00:15:16,179 --> 00:15:20,319
does it takes two does it take to

322
00:15:18,399 --> 00:15:25,059
template the ECC memory for Rho hammer

323
00:15:20,319 --> 00:15:27,309
so on our setup we're at the beginning

324
00:15:25,059 --> 00:15:29,589
we had a perfect side-channel meaning

325
00:15:27,309 --> 00:15:34,509
that we could pinpoint which bit flipped

326
00:15:29,589 --> 00:15:37,980
within a row we got 32 minutes for a

327
00:15:34,509 --> 00:15:40,070
page table a page table attack or

328
00:15:37,980 --> 00:15:42,529
similar results for a four

329
00:15:40,070 --> 00:15:45,529
for a tag that was changing bits in in

330
00:15:42,529 --> 00:15:49,070
some binaries and also there's another

331
00:15:45,529 --> 00:15:52,490
attack that was changing a bit in in a

332
00:15:49,070 --> 00:15:55,759
key this run in two hours so this was

333
00:15:52,490 --> 00:15:58,490
just a templating phase whereas the

334
00:15:55,759 --> 00:16:03,139
original the canonical exploit where you

335
00:15:58,490 --> 00:16:06,259
can just directly observe this this the

336
00:16:03,139 --> 00:16:08,779
bit flip runs almost almost instant but

337
00:16:06,259 --> 00:16:11,019
typically you only can guess which word

338
00:16:08,779 --> 00:16:13,880
actually contains a bit flip during

339
00:16:11,019 --> 00:16:17,509
inside the row so this one can take like

340
00:16:13,880 --> 00:16:20,149
19 hours or even three days on Allen

341
00:16:17,509 --> 00:16:25,459
Road systems so this was this is our set

342
00:16:20,149 --> 00:16:27,410
up that had yeah some some some bit lip

343
00:16:25,459 --> 00:16:30,439
so it's also dependent on the on the

344
00:16:27,410 --> 00:16:32,449
memory to conclude my talk error

345
00:16:30,440 --> 00:16:36,519
correcting codes are actually just only

346
00:16:32,449 --> 00:16:36,519
slowing down the row hammer attacks

347
00:16:41,450 --> 00:16:45,919
[Applause]

348
00:16:46,509 --> 00:16:58,519
any questions come to the center we have

349
00:16:50,660 --> 00:17:00,860
a taker come on down hi Alex Olynyk from

350
00:16:58,519 --> 00:17:03,560
Boston University thank you for the talk

351
00:17:00,860 --> 00:17:06,349
so with ECC memory you you're sort of in

352
00:17:03,560 --> 00:17:10,129
a privileged position because ECC memory

353
00:17:06,349 --> 00:17:11,539
can detect single bid flips you talked

354
00:17:10,130 --> 00:17:12,799
about the length of these attacks do you

355
00:17:11,539 --> 00:17:14,900
think that one defense could be

356
00:17:12,799 --> 00:17:16,939
detecting abner now abnormalities a

357
00:17:14,900 --> 00:17:19,689
number of single bit Corrections and

358
00:17:16,939 --> 00:17:25,549
sort of stopping the attack in progress

359
00:17:19,689 --> 00:17:27,709
before you reach the end result I don't

360
00:17:25,549 --> 00:17:29,090
have any data on this I'm not sure how

361
00:17:27,709 --> 00:17:32,240
easy it would be to differentiate

362
00:17:29,090 --> 00:17:34,280
between normal anomaly and not but one

363
00:17:32,240 --> 00:17:37,220
thing is for sure the ACC was designed

364
00:17:34,280 --> 00:17:38,750
for let's say random random bits so

365
00:17:37,220 --> 00:17:42,250
probably if we look at the distribution

366
00:17:38,750 --> 00:17:44,929
of bit flips the normal ones are

367
00:17:42,250 --> 00:17:47,270
distributed throughout the the memory

368
00:17:44,929 --> 00:17:49,549
whereas these ones that you use in the

369
00:17:47,270 --> 00:17:52,070
attacker are very much like focused on

370
00:17:49,549 --> 00:17:55,070
let's say one area or one bank and

371
00:17:52,070 --> 00:17:57,470
something like that so I guess there

372
00:17:55,070 --> 00:18:01,520
could be a way to to just piggyback on

373
00:17:57,470 --> 00:18:03,200
these ECC errors but but I'm not really

374
00:18:01,520 --> 00:18:06,679
sure how much of this you can do online

375
00:18:03,200 --> 00:18:08,539
so well the well the attack happens so

376
00:18:06,679 --> 00:18:10,669
imagine that or you already have a side

377
00:18:08,539 --> 00:18:12,950
child if you start processing his see

378
00:18:10,669 --> 00:18:15,710
errors in real time then probably this

379
00:18:12,950 --> 00:18:18,320
satchel will actually be even worse so

380
00:18:15,710 --> 00:18:21,470
I'm not sure what is the the best way to

381
00:18:18,320 --> 00:18:23,149
if this is the best way to defend there

382
00:18:21,470 --> 00:18:26,900
are other Hardware defenses out there

383
00:18:23,150 --> 00:18:36,279
that may or may not help against against

384
00:18:26,900 --> 00:18:41,270
roarhammer attacks okay

385
00:18:36,279 --> 00:18:44,419
um so yeah I'm not sure how that

386
00:18:41,270 --> 00:18:47,210
actually works but let me yeah please

387
00:18:44,419 --> 00:18:49,159
use the microphone the question or

388
00:18:47,210 --> 00:18:51,140
statement was they are very efficient

389
00:18:49,159 --> 00:18:52,760
bursts error correcting codes and

390
00:18:51,140 --> 00:18:54,679
obviously in brohamer attack you're

391
00:18:52,760 --> 00:18:56,840
creating a burst of errors so that may

392
00:18:54,679 --> 00:18:58,039
use may be useful but it sounds like

393
00:18:56,840 --> 00:18:59,949
that was heading towards an offline

394
00:18:58,039 --> 00:19:04,879
conversation as opposed to an online

395
00:18:59,950 --> 00:19:07,610
yeah I guess so one last guru right from

396
00:19:04,880 --> 00:19:09,320
Georgia Tech I I'm curious why there's a

397
00:19:07,610 --> 00:19:11,809
latency difference when there's a

398
00:19:09,320 --> 00:19:13,700
correction because typically ECC at

399
00:19:11,809 --> 00:19:16,129
least the segment codes are fairly

400
00:19:13,700 --> 00:19:18,830
simple to calculate maybe a couple of

401
00:19:16,130 --> 00:19:20,000
cycles to correct I wonder if the

402
00:19:18,830 --> 00:19:21,830
latency difference largely due to

403
00:19:20,000 --> 00:19:26,929
reporting mechanism or locking

404
00:19:21,830 --> 00:19:29,779
mechanisms for the errors i we have not

405
00:19:26,929 --> 00:19:32,480
investigated exactly but one of the main

406
00:19:29,779 --> 00:19:35,149
reasons is that there's are some times

407
00:19:32,480 --> 00:19:37,100
reported right away so they are either

408
00:19:35,149 --> 00:19:39,168
logged at let's say the former level or

409
00:19:37,100 --> 00:19:41,719
either even up to the operating system

410
00:19:39,169 --> 00:19:44,840
so it could be that there's some machine

411
00:19:41,720 --> 00:19:47,149
check going on and that is a very brutal

412
00:19:44,840 --> 00:19:50,240
event for the whole CPU and you can

413
00:19:47,149 --> 00:19:53,120
detect this but even in this case the

414
00:19:50,240 --> 00:19:56,870
errors were only logged at the system at

415
00:19:53,120 --> 00:19:57,379
the let's say the former level so I

416
00:19:56,870 --> 00:20:01,939
think

417
00:19:57,380 --> 00:20:03,860
logging plays a major role here alright

418
00:20:01,940 --> 00:20:08,809
let's take our speaker

419
00:20:03,860 --> 00:20:08,809
[Applause]

