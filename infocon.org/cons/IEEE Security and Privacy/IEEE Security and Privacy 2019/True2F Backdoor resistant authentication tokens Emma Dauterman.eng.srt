1
00:00:08,570 --> 00:00:13,969
thank you okay so I'm gonna be talking

2
00:00:11,600 --> 00:00:14,930
today about true to f our system for

3
00:00:13,969 --> 00:00:17,810
back door assists and authentication

4
00:00:14,930 --> 00:00:19,400
tokens this work was done at Stanford at

5
00:00:17,810 --> 00:00:21,770
Google with Henry Corrigan Gibbs

6
00:00:19,400 --> 00:00:24,738
David Massey era's Dan Bonet and Dom

7
00:00:21,770 --> 00:00:26,630
Rizzo so as you probably all aware

8
00:00:24,739 --> 00:00:28,279
Hardware authentication tokens are

9
00:00:26,630 --> 00:00:30,470
particularly effective form of second

10
00:00:28,279 --> 00:00:33,380
factor authentication with you to F

11
00:00:30,470 --> 00:00:35,000
tokens being especially popular since

12
00:00:33,380 --> 00:00:36,739
Google mandated over a year ago that all

13
00:00:35,000 --> 00:00:38,420
its employees use these security keys

14
00:00:36,739 --> 00:00:39,769
they haven't discovered a single

15
00:00:38,420 --> 00:00:41,900
instance of corporate credential theft

16
00:00:39,770 --> 00:00:45,050
showing just how effective these tokens

17
00:00:41,900 --> 00:00:47,510
are so the you to have protocol runs in

18
00:00:45,050 --> 00:00:49,519
two stages so the first stage

19
00:00:47,510 --> 00:00:51,230
registration is run when a user wants to

20
00:00:49,520 --> 00:00:53,480
associate their token with some account

21
00:00:51,230 --> 00:00:55,640
so the server sends some identifiers to

22
00:00:53,480 --> 00:00:58,220
the token the token then generates some

23
00:00:55,640 --> 00:01:00,350
server specific ECDSA key pair and sends

24
00:00:58,220 --> 00:01:03,379
the corresponding public key back to the

25
00:01:00,350 --> 00:01:05,329
server the second stage authentication

26
00:01:03,380 --> 00:01:07,250
is run when a user wants to log in to

27
00:01:05,328 --> 00:01:08,839
their account so the server sends some

28
00:01:07,250 --> 00:01:10,790
identifiers along with the challenge to

29
00:01:08,840 --> 00:01:12,170
the token the token scientist challenge

30
00:01:10,790 --> 00:01:14,240
using the key parrot generated

31
00:01:12,170 --> 00:01:17,150
registration and set the signature back

32
00:01:14,240 --> 00:01:18,679
to the server for verification so in

33
00:01:17,150 --> 00:01:20,300
this way each web provides a really

34
00:01:18,680 --> 00:01:23,150
strong defense against phishing attacks

35
00:01:20,300 --> 00:01:24,798
as well as browser compromise so in

36
00:01:23,150 --> 00:01:26,390
particular even if from malware takes

37
00:01:24,799 --> 00:01:28,850
over your browser it can't authenticate

38
00:01:26,390 --> 00:01:30,350
without interacting with the token we

39
00:01:28,850 --> 00:01:32,179
get this really strong defense against

40
00:01:30,350 --> 00:01:34,449
external adversaries because only the

41
00:01:32,180 --> 00:01:36,650
token knows the cryptographic secrets

42
00:01:34,450 --> 00:01:39,380
but what about vulnerabilities in the

43
00:01:36,650 --> 00:01:42,200
token itself so we might not be entirely

44
00:01:39,380 --> 00:01:44,030
caught entirely comfortable trusting the

45
00:01:42,200 --> 00:01:45,130
token with our cryptographic secrets for

46
00:01:44,030 --> 00:01:48,080
two reasons

47
00:01:45,130 --> 00:01:50,960
so first the token might have some

48
00:01:48,080 --> 00:01:54,189
implementation bugs and second it might

49
00:01:50,960 --> 00:01:56,089
be subject to supply chain tampering

50
00:01:54,189 --> 00:01:59,119
implementation bugs are a very real

51
00:01:56,090 --> 00:02:00,350
problem so in 2017 a bug was discovered

52
00:01:59,119 --> 00:02:01,970
in the infinii on random number

53
00:02:00,350 --> 00:02:04,429
generator which affected a wide variety

54
00:02:01,970 --> 00:02:07,700
of products including Estonian smart

55
00:02:04,430 --> 00:02:11,420
cards chrome TPMS and the ubk PGP

56
00:02:07,700 --> 00:02:12,739
functionality just last week abuzz a bug

57
00:02:11,420 --> 00:02:15,200
was discovered in the Google Titan

58
00:02:12,739 --> 00:02:17,299
security key Bluetooth stack and all

59
00:02:15,200 --> 00:02:20,950
these bugs just show just how fragile

60
00:02:17,299 --> 00:02:20,950
these secure Hardware elements are

61
00:02:21,099 --> 00:02:24,700
supply chain tampering is another

62
00:02:22,540 --> 00:02:26,319
problem we know from the Snowden leaks

63
00:02:24,700 --> 00:02:28,869
that these types of supply chain attacks

64
00:02:26,319 --> 00:02:30,939
actually happen on your left you can see

65
00:02:28,870 --> 00:02:33,189
a photo of the NSA installing implants

66
00:02:30,939 --> 00:02:34,659
and Cisco routers and we know that users

67
00:02:33,189 --> 00:02:37,209
are actually concerned about these types

68
00:02:34,659 --> 00:02:38,409
of supply chain attacks last summer when

69
00:02:37,209 --> 00:02:39,969
Google released the tightened security

70
00:02:38,409 --> 00:02:41,560
key there were calls for greater

71
00:02:39,969 --> 00:02:43,870
transparency into the supply chain

72
00:02:41,560 --> 00:02:45,730
process so not only do these attacks

73
00:02:43,870 --> 00:02:48,849
actually happen users are actually

74
00:02:45,730 --> 00:02:51,010
concerned about them as well so to

75
00:02:48,849 --> 00:02:52,810
address both these security threats we

76
00:02:51,010 --> 00:02:54,638
introduced true to us which present

77
00:02:52,810 --> 00:02:56,739
which provides the same protections it's

78
00:02:54,639 --> 00:02:59,919
used to a while additionally protecting

79
00:02:56,739 --> 00:03:02,079
against faulty tokens so just as in the

80
00:02:59,919 --> 00:03:04,359
case of q2f true to us addresses the

81
00:03:02,079 --> 00:03:05,650
case where the browsers malicious so the

82
00:03:04,359 --> 00:03:08,129
browser doesn't learn any secrets

83
00:03:05,650 --> 00:03:10,780
through its interactions with the token

84
00:03:08,129 --> 00:03:13,268
however true to F additionally protects

85
00:03:10,780 --> 00:03:15,489
against faulty tokens so to address the

86
00:03:13,269 --> 00:03:17,199
case where the token is malicious the

87
00:03:15,489 --> 00:03:18,969
browser enforces the correct behavior of

88
00:03:17,199 --> 00:03:20,650
the token to prevent the token from

89
00:03:18,969 --> 00:03:23,439
leaking secrets through protocol

90
00:03:20,650 --> 00:03:24,879
messages so in this way true trap

91
00:03:23,439 --> 00:03:26,769
addresses the case where either the

92
00:03:24,879 --> 00:03:29,978
browser's malicious or the token is

93
00:03:26,769 --> 00:03:32,799
malicious so we have three primary

94
00:03:29,979 --> 00:03:35,109
design goals so the first is to augment

95
00:03:32,799 --> 00:03:36,939
u2f provide a strong protection against

96
00:03:35,109 --> 00:03:38,829
faulty tokens so you want to have the

97
00:03:36,939 --> 00:03:42,009
same protections as u2f even if the

98
00:03:38,829 --> 00:03:42,759
token is buggy or backdoored second we

99
00:03:42,009 --> 00:03:44,798
want to do this in a way that's

100
00:03:42,759 --> 00:03:46,540
backwards compatible with existing u2f

101
00:03:44,799 --> 00:03:49,180
servers so this should only require

102
00:03:46,540 --> 00:03:50,828
changes to the token and the browser but

103
00:03:49,180 --> 00:03:52,389
not the server and this is important for

104
00:03:50,829 --> 00:03:53,709
real-world deployment as it's not very

105
00:03:52,389 --> 00:03:55,780
feasible to go out and change every

106
00:03:53,709 --> 00:03:58,509
single server running the u2f standard

107
00:03:55,780 --> 00:04:00,400
i'm finally we want this to be practical

108
00:03:58,509 --> 00:04:01,839
on commodity hardware tokens and we

109
00:04:00,400 --> 00:04:03,870
implemented and evaluated us on Google

110
00:04:01,840 --> 00:04:06,459
Hardware I'll be showing you that later

111
00:04:03,870 --> 00:04:07,719
so to achieve these three goals we

112
00:04:06,459 --> 00:04:10,509
adopted the following two design

113
00:04:07,719 --> 00:04:11,858
principles so first both the browser and

114
00:04:10,509 --> 00:04:13,659
the token should contribute randomness

115
00:04:11,859 --> 00:04:15,099
to the protocol and this prevents the

116
00:04:13,659 --> 00:04:18,039
token from using some bad source of

117
00:04:15,099 --> 00:04:19,810
randomness second the browsers should be

118
00:04:18,039 --> 00:04:22,060
able to verify all deterministic token

119
00:04:19,810 --> 00:04:23,590
operations and this is important so that

120
00:04:22,060 --> 00:04:27,250
so that the browser can check the tokens

121
00:04:23,590 --> 00:04:28,989
behavior so as I mentioned we also

122
00:04:27,250 --> 00:04:30,340
implemented this on Google Hardware and

123
00:04:28,990 --> 00:04:32,159
I'll be showing you the evaluation

124
00:04:30,340 --> 00:04:34,570
results at the end of this talk

125
00:04:32,159 --> 00:04:36,640
so the u2f protocol has two

126
00:04:34,570 --> 00:04:38,650
and it's true to us we're gonna add an

127
00:04:36,640 --> 00:04:40,360
additional step initialization which we

128
00:04:38,650 --> 00:04:43,060
run after purchasing into the token and

129
00:04:40,360 --> 00:04:44,560
before registering with any site we're

130
00:04:43,060 --> 00:04:47,830
also going to modify the registration

131
00:04:44,560 --> 00:04:49,150
and authentication steps I'm going to

132
00:04:47,830 --> 00:04:49,870
walk through to these protocol steps and

133
00:04:49,150 --> 00:04:52,299
I'm going to start off with

134
00:04:49,870 --> 00:04:53,830
initialization and here the idea is that

135
00:04:52,300 --> 00:04:57,460
both the browser and the token should

136
00:04:53,830 --> 00:04:59,320
contribute randomness to the protocol so

137
00:04:57,460 --> 00:05:00,520
at a high level in initialization we

138
00:04:59,320 --> 00:05:02,080
want to run some collaborative key

139
00:05:00,520 --> 00:05:04,120
generation protocol between the token

140
00:05:02,080 --> 00:05:05,710
and the browser at the end of which the

141
00:05:04,120 --> 00:05:07,180
token holds the master secret key and

142
00:05:05,710 --> 00:05:09,489
the browser holds them at the

143
00:05:07,180 --> 00:05:10,810
corresponding master public key it's

144
00:05:09,490 --> 00:05:12,400
important that we generate this key pair

145
00:05:10,810 --> 00:05:13,720
collaboratively so we don't want the

146
00:05:12,400 --> 00:05:15,159
token to generate this on its own

147
00:05:13,720 --> 00:05:17,290
because the token can be using some bad

148
00:05:15,160 --> 00:05:18,610
source of randomness and we also don't

149
00:05:17,290 --> 00:05:19,870
want the browser to be generating it on

150
00:05:18,610 --> 00:05:21,490
its own either because we don't want the

151
00:05:19,870 --> 00:05:23,410
browser to ever know this master secret

152
00:05:21,490 --> 00:05:25,630
key this is why we need collaborative

153
00:05:23,410 --> 00:05:27,160
key generation so you want the following

154
00:05:25,630 --> 00:05:29,770
two properties from this protocol

155
00:05:27,160 --> 00:05:31,300
so first the token shouldn't be able to

156
00:05:29,770 --> 00:05:33,580
bias the master public key that the

157
00:05:31,300 --> 00:05:34,930
protocol produces this is important if

158
00:05:33,580 --> 00:05:38,080
the token has some bad source of

159
00:05:34,930 --> 00:05:39,670
randomness and second the browser should

160
00:05:38,080 --> 00:05:40,120
learn nothing about this master secret

161
00:05:39,670 --> 00:05:41,860
key

162
00:05:40,120 --> 00:05:44,260
so the cryptographic secrets should

163
00:05:41,860 --> 00:05:45,430
remain entirely on the token it's

164
00:05:44,260 --> 00:05:47,680
actually a protocol that already does

165
00:05:45,430 --> 00:05:49,450
this by Corgi gets it out however it's

166
00:05:47,680 --> 00:05:51,220
pretty slow on the small embedded device

167
00:05:49,450 --> 00:05:52,539
that we're working with and so we

168
00:05:51,220 --> 00:05:54,910
present a protocol that reduces the

169
00:05:52,540 --> 00:05:56,860
number of operations by about 3x in

170
00:05:54,910 --> 00:05:59,350
comparison to their protocol which

171
00:05:56,860 --> 00:06:00,220
greatly improves the performance and you

172
00:05:59,350 --> 00:06:01,900
can I'm not going to go through the

173
00:06:00,220 --> 00:06:04,590
protocol in detail right now we can see

174
00:06:01,900 --> 00:06:07,659
our paper for details if you're curious

175
00:06:04,590 --> 00:06:09,940
so that's initialization I'm not going

176
00:06:07,660 --> 00:06:11,140
to move on to registration and here the

177
00:06:09,940 --> 00:06:12,880
idea is that the browser should be able

178
00:06:11,140 --> 00:06:16,570
to verify all the terminus stick token

179
00:06:12,880 --> 00:06:18,340
operations so just as a reminder in u2f

180
00:06:16,570 --> 00:06:20,349
registration the server sends some

181
00:06:18,340 --> 00:06:22,450
identifier to the token the token then

182
00:06:20,350 --> 00:06:24,310
generates some server specific ECDSA key

183
00:06:22,450 --> 00:06:27,820
pair and sends the corresponding public

184
00:06:24,310 --> 00:06:29,590
key back to the server so we can imagine

185
00:06:27,820 --> 00:06:32,409
some implementation bugs that undermine

186
00:06:29,590 --> 00:06:33,880
the security registration so for example

187
00:06:32,410 --> 00:06:35,860
the token could generate this key pair

188
00:06:33,880 --> 00:06:37,990
using some weak source of randomness so

189
00:06:35,860 --> 00:06:39,550
now if the attacker has this public key

190
00:06:37,990 --> 00:06:43,060
they're actually able to learn the

191
00:06:39,550 --> 00:06:44,710
original secret key we can also imagine

192
00:06:43,060 --> 00:06:45,310
supply chain tampering undermining this

193
00:06:44,710 --> 00:06:46,989
stuff

194
00:06:45,310 --> 00:06:48,670
so let's say so much hacker who

195
00:06:46,990 --> 00:06:51,490
manufactured your token is able to get

196
00:06:48,670 --> 00:06:53,139
you to register at Eagle comm so now the

197
00:06:51,490 --> 00:06:55,210
token is going to choose some public key

198
00:06:53,139 --> 00:06:56,500
for Eagle comm that hides information

199
00:06:55,210 --> 00:06:58,870
about the secret key for another site

200
00:06:56,500 --> 00:07:01,360
maybe the secret key for github comm it

201
00:06:58,870 --> 00:07:03,310
sends this bad public key back to the

202
00:07:01,360 --> 00:07:05,290
server and the server is now able to

203
00:07:03,310 --> 00:07:07,750
extract information about the secret key

204
00:07:05,290 --> 00:07:10,180
from github comm from this bad public

205
00:07:07,750 --> 00:07:11,860
key that it receives so in this way the

206
00:07:10,180 --> 00:07:13,510
token is managed to exfiltrate secrets

207
00:07:11,860 --> 00:07:16,750
that were never supposed to leave the

208
00:07:13,510 --> 00:07:18,849
token so to address both these security

209
00:07:16,750 --> 00:07:20,830
threats we introduced this new mechanism

210
00:07:18,850 --> 00:07:23,230
we call verifiable identity families or

211
00:07:20,830 --> 00:07:24,640
vis and these the IAF's are going to

212
00:07:23,230 --> 00:07:27,400
leverage the master key pair that we

213
00:07:24,640 --> 00:07:28,659
generated at initialization so you might

214
00:07:27,400 --> 00:07:30,039
be wondering well why can't we just use

215
00:07:28,660 --> 00:07:31,180
the same collaborative key generation

216
00:07:30,040 --> 00:07:33,760
mechanism that we used for

217
00:07:31,180 --> 00:07:35,110
initialization well the problem here is

218
00:07:33,760 --> 00:07:36,729
that these tokens have a very small

219
00:07:35,110 --> 00:07:38,020
amount of storage space and we don't

220
00:07:36,729 --> 00:07:39,940
want to bound the number of sites that

221
00:07:38,020 --> 00:07:41,260
you can register with and so we want to

222
00:07:39,940 --> 00:07:42,820
be able to Joyride this key pair

223
00:07:41,260 --> 00:07:45,039
whenever we need it instead of storing

224
00:07:42,820 --> 00:07:47,200
the secret key on the token and these

225
00:07:45,040 --> 00:07:49,540
vif allow us to drive super specific key

226
00:07:47,200 --> 00:07:52,030
pairs in a deterministic and verifiable

227
00:07:49,540 --> 00:07:53,320
way from the single master key pair it's

228
00:07:52,030 --> 00:07:55,330
also important that these key pairs are

229
00:07:53,320 --> 00:07:59,260
server specific provide unlink ability

230
00:07:55,330 --> 00:08:00,789
between sites so in our paper we

231
00:07:59,260 --> 00:08:02,950
formally prove that these VI FS are

232
00:08:00,789 --> 00:08:04,870
unique verifiable on linkable and

233
00:08:02,950 --> 00:08:06,909
unforgeable i'm not going to go into the

234
00:08:04,870 --> 00:08:07,810
details about these definitions now but

235
00:08:06,910 --> 00:08:10,350
i'll show how the simplified

236
00:08:07,810 --> 00:08:12,550
construction achieves these properties

237
00:08:10,350 --> 00:08:14,620
and so now i'm gonna walk through a

238
00:08:12,550 --> 00:08:17,050
simplified weak version of the vif

239
00:08:14,620 --> 00:08:18,789
construction i'll hint at why this is

240
00:08:17,050 --> 00:08:20,979
weak and why we need the focus and what

241
00:08:18,789 --> 00:08:22,419
the full construction the paper looks

242
00:08:20,979 --> 00:08:24,669
like although again check out the paper

243
00:08:22,419 --> 00:08:27,310
for details so here we're going to use

244
00:08:24,669 --> 00:08:29,830
some group G a prime order Q in this

245
00:08:27,310 --> 00:08:31,570
case the nest p226 curve and we're going

246
00:08:29,830 --> 00:08:33,010
and I'm going to rewrite the master

247
00:08:31,570 --> 00:08:36,069
secret key token in the master public

248
00:08:33,010 --> 00:08:39,370
key on the browser as X on the token and

249
00:08:36,070 --> 00:08:40,839
big X or GD X on the browser we're then

250
00:08:39,370 --> 00:08:43,089
going to use these values to compute

251
00:08:40,839 --> 00:08:45,730
this key K which is just the hash of big

252
00:08:43,089 --> 00:08:48,430
x and so now I'm gonna walk through the

253
00:08:45,730 --> 00:08:50,589
simplified protocol so here the server

254
00:08:48,430 --> 00:08:52,030
sends some identifiers to the token the

255
00:08:50,589 --> 00:08:54,070
token then computes this value alpha

256
00:08:52,030 --> 00:08:56,560
which is just the PRF key with K of the

257
00:08:54,070 --> 00:08:58,070
server identifier the token is then able

258
00:08:56,560 --> 00:09:00,560
to compute the server specific seeker

259
00:08:58,070 --> 00:09:02,510
key which is just alpha times X and the

260
00:09:00,560 --> 00:09:05,510
server specific public key which is GD

261
00:09:02,510 --> 00:09:07,520
alpha times X the token sends his public

262
00:09:05,510 --> 00:09:09,380
key back to the browser the browser can

263
00:09:07,520 --> 00:09:10,910
then also compete alpha and check that

264
00:09:09,380 --> 00:09:12,620
the public key correctly incorporates

265
00:09:10,910 --> 00:09:15,079
alpha so the public key should be of the

266
00:09:12,620 --> 00:09:16,640
form big X to the Alpha if this is the

267
00:09:15,080 --> 00:09:18,560
case the browser knows that this public

268
00:09:16,640 --> 00:09:21,680
key was correctly formed and so can send

269
00:09:18,560 --> 00:09:23,989
it back to the server so the first

270
00:09:21,680 --> 00:09:25,099
property we wanted is uniqueness so the

271
00:09:23,990 --> 00:09:28,010
token should be able to produce the

272
00:09:25,100 --> 00:09:29,570
unique key pair for this site and here

273
00:09:28,010 --> 00:09:31,850
we get this property because this value

274
00:09:29,570 --> 00:09:33,530
alpha is unique for every server just

275
00:09:31,850 --> 00:09:38,060
the PRF key both K of the server

276
00:09:33,530 --> 00:09:40,189
identifier the second property we wanted

277
00:09:38,060 --> 00:09:41,540
is verifiability so the token should be

278
00:09:40,190 --> 00:09:43,130
able to prove to the browser that the

279
00:09:41,540 --> 00:09:45,620
public key it receives is really the

280
00:09:43,130 --> 00:09:46,910
unique public key for that site and we

281
00:09:45,620 --> 00:09:49,010
get this property because the browser is

282
00:09:46,910 --> 00:09:50,990
also able to compute alpha and check

283
00:09:49,010 --> 00:09:54,710
that the that the public key is derived

284
00:09:50,990 --> 00:09:56,540
using this value alpha third we want

285
00:09:54,710 --> 00:09:57,800
unforgeable 'ti so the browser shouldn't

286
00:09:56,540 --> 00:09:58,699
be able to forge a signature under the

287
00:09:57,800 --> 00:10:02,180
public key it receives

288
00:09:58,700 --> 00:10:05,420
we prove this formally in the paper and

289
00:10:02,180 --> 00:10:06,859
finally we want this notion of we from

290
00:10:05,420 --> 00:10:08,839
this simplified construction we get this

291
00:10:06,860 --> 00:10:10,130
notion of weak on link ability so the

292
00:10:08,840 --> 00:10:11,750
server shouldn't be able to distinguish

293
00:10:10,130 --> 00:10:14,180
the public key it receives from a random

294
00:10:11,750 --> 00:10:15,650
ECDSA public key and we get this

295
00:10:14,180 --> 00:10:17,390
property because the server doesn't have

296
00:10:15,650 --> 00:10:19,310
this key K and so can't compute alpha

297
00:10:17,390 --> 00:10:21,140
and see that the public key it receives

298
00:10:19,310 --> 00:10:23,839
are all derived from the same master key

299
00:10:21,140 --> 00:10:25,970
pair however this simplified

300
00:10:23,840 --> 00:10:28,130
construction does not provide full and

301
00:10:25,970 --> 00:10:29,990
link ability we define this more

302
00:10:28,130 --> 00:10:31,100
formally in our paper but informally

303
00:10:29,990 --> 00:10:32,570
this just means that the browser

304
00:10:31,100 --> 00:10:34,100
shouldn't be able to generate public

305
00:10:32,570 --> 00:10:35,810
keys without interacting with the token

306
00:10:34,100 --> 00:10:37,280
and so the full construction they

307
00:10:35,810 --> 00:10:38,510
presented the paper uses verifiable

308
00:10:37,280 --> 00:10:42,470
random functions to provide this

309
00:10:38,510 --> 00:10:44,390
property so that's initialization

310
00:10:42,470 --> 00:10:46,430
registration I'm now going to move on to

311
00:10:44,390 --> 00:10:47,960
authentication and here the idea is that

312
00:10:46,430 --> 00:10:51,229
both the browser and the token should

313
00:10:47,960 --> 00:10:52,550
contribute randomness to the protocol so

314
00:10:51,230 --> 00:10:54,260
just as a reminder in you to have

315
00:10:52,550 --> 00:10:55,729
authentication the server sent some

316
00:10:54,260 --> 00:10:57,290
identifiers along with the challenge to

317
00:10:55,730 --> 00:10:58,850
the token the token is then going to

318
00:10:57,290 --> 00:11:00,920
sign this challenge using the key pair

319
00:10:58,850 --> 00:11:02,600
generated at registration and send the

320
00:11:00,920 --> 00:11:05,660
corresponding signature back to the

321
00:11:02,600 --> 00:11:07,100
server for verification so we can

322
00:11:05,660 --> 00:11:09,040
imagine the implementation bugs that

323
00:11:07,100 --> 00:11:11,270
undermine the security of authentication

324
00:11:09,040 --> 00:11:13,219
so for example the token could

325
00:11:11,270 --> 00:11:14,870
choose signing nonce with a weak source

326
00:11:13,220 --> 00:11:17,000
of randomness and so with enough of

327
00:11:14,870 --> 00:11:18,620
these signatures an adversary can

328
00:11:17,000 --> 00:11:22,310
actually recover the original signing

329
00:11:18,620 --> 00:11:24,680
key we can also imagine supply chain

330
00:11:22,310 --> 00:11:26,180
tampering undermining this step so for

331
00:11:24,680 --> 00:11:28,310
example the token could hide the secret

332
00:11:26,180 --> 00:11:29,839
key for another site in the signature

333
00:11:28,310 --> 00:11:32,479
and this is possible because there's

334
00:11:29,840 --> 00:11:35,510
randomness chosen by the signer in ECDSA

335
00:11:32,480 --> 00:11:37,490
signatures and so both of these would

336
00:11:35,510 --> 00:11:39,590
not be problems um if we can use some

337
00:11:37,490 --> 00:11:42,440
unique signature scheme like BLS or our

338
00:11:39,590 --> 00:11:44,090
safe full domain hash however we're tied

339
00:11:42,440 --> 00:11:46,190
to ECDSA to maintain backwards

340
00:11:44,090 --> 00:11:47,990
compatibility with existing u2f web

341
00:11:46,190 --> 00:11:49,370
servers and so we need some way of

342
00:11:47,990 --> 00:11:52,100
controlling the randomness and these

343
00:11:49,370 --> 00:11:53,870
ECDSA signatures into it and so to do

344
00:11:52,100 --> 00:11:56,600
this we introduce this new mechanism we

345
00:11:53,870 --> 00:11:58,130
call firewall ECDSA signatures based on

346
00:11:56,600 --> 00:12:00,680
previous work on some cryptographic

347
00:11:58,130 --> 00:12:02,450
rivers firewalls so I'm not going to go

348
00:12:00,680 --> 00:12:04,819
through the construction detail but it's

349
00:12:02,450 --> 00:12:06,680
motivated by the following two ideas so

350
00:12:04,820 --> 00:12:08,120
first the token in the browser should

351
00:12:06,680 --> 00:12:10,310
use collaborative key generation to

352
00:12:08,120 --> 00:12:12,520
generate some signing knots and then

353
00:12:10,310 --> 00:12:14,930
second to handle ECDSA malleability

354
00:12:12,520 --> 00:12:16,520
signature should be reran demised by the

355
00:12:14,930 --> 00:12:18,020
browser so the token can't leak

356
00:12:16,520 --> 00:12:20,270
information through which signature it

357
00:12:18,020 --> 00:12:21,740
chooses to send you can see the paper

358
00:12:20,270 --> 00:12:23,750
for details this is based on previous

359
00:12:21,740 --> 00:12:27,800
work on subliminal free and submergent

360
00:12:23,750 --> 00:12:28,850
resistant signature schemes so gone

361
00:12:27,800 --> 00:12:30,140
through all the truth graph protocol

362
00:12:28,850 --> 00:12:31,460
steps now there's some other

363
00:12:30,140 --> 00:12:33,080
contributions in the paper I don't have

364
00:12:31,460 --> 00:12:34,760
time to discuss now including

365
00:12:33,080 --> 00:12:37,310
cryptographic optimizations tailored

366
00:12:34,760 --> 00:12:38,540
specifically to the token hardware and a

367
00:12:37,310 --> 00:12:41,170
flash optimized data structure for

368
00:12:38,540 --> 00:12:43,069
storing u2f authentication counters I

369
00:12:41,170 --> 00:12:45,439
just want to touch on one implementation

370
00:12:43,070 --> 00:12:47,270
note as well so you two F doesn't

371
00:12:45,440 --> 00:12:49,760
require the browser to keep track of any

372
00:12:47,270 --> 00:12:51,110
state however true to have does require

373
00:12:49,760 --> 00:12:52,970
the browser should know this master

374
00:12:51,110 --> 00:12:55,580
public key to check the tokens correct

375
00:12:52,970 --> 00:12:57,350
behavior this then introduces the

376
00:12:55,580 --> 00:12:58,970
problem of well what happens if you're

377
00:12:57,350 --> 00:13:01,520
using one u2 F key with multiple

378
00:12:58,970 --> 00:13:02,930
browsers so one simple way to do it to

379
00:13:01,520 --> 00:13:04,939
address this is every time you plug in

380
00:13:02,930 --> 00:13:06,739
the token the token just gives us master

381
00:13:04,940 --> 00:13:08,240
public key to the browser and this

382
00:13:06,740 --> 00:13:10,010
provides some basic protection against

383
00:13:08,240 --> 00:13:11,660
implementation bugs but isn't very

384
00:13:10,010 --> 00:13:12,980
satisfying if you have a malicious token

385
00:13:11,660 --> 00:13:15,680
as I could just give the wrong master

386
00:13:12,980 --> 00:13:17,060
public key value and so a stronger

387
00:13:15,680 --> 00:13:18,829
solution would be to actually sync this

388
00:13:17,060 --> 00:13:21,260
master public key across browser

389
00:13:18,830 --> 00:13:23,540
instances

390
00:13:21,260 --> 00:13:26,090
so we also implemented true 2f on Google

391
00:13:23,540 --> 00:13:27,800
Hardware on your left you can see Google

392
00:13:26,090 --> 00:13:29,090
development board running true 2f that's

393
00:13:27,800 --> 00:13:30,859
where we got the evaluation number sent

394
00:13:29,090 --> 00:13:32,570
about to show you and on your right you

395
00:13:30,860 --> 00:13:33,950
can see a Google production USB token

396
00:13:32,570 --> 00:13:35,210
with the same hardware specs not

397
00:13:33,950 --> 00:13:37,580
currently running true to us but capable

398
00:13:35,210 --> 00:13:38,780
of running it in the future I mean so

399
00:13:37,580 --> 00:13:40,550
we've when we first started evaluating

400
00:13:38,780 --> 00:13:41,930
true 2f we knew that there would be some

401
00:13:40,550 --> 00:13:44,209
overhead in comparison to traditional

402
00:13:41,930 --> 00:13:48,140
you to us and so our goal was to reduce

403
00:13:44,210 --> 00:13:49,220
this overhead as much as possible and so

404
00:13:48,140 --> 00:13:51,560
here you can see the authentication

405
00:13:49,220 --> 00:13:53,570
protocol latency and we can see without

406
00:13:51,560 --> 00:13:55,489
any optimizations true 2f is pretty

407
00:13:53,570 --> 00:13:56,990
expensive in comparison to original u2f

408
00:13:55,490 --> 00:13:58,670
so four hundred and forty six

409
00:13:56,990 --> 00:14:01,580
milliseconds in comparison to 23

410
00:13:58,670 --> 00:14:03,380
milliseconds however as we introduced a

411
00:14:01,580 --> 00:14:05,900
variety of optimizations we can actually

412
00:14:03,380 --> 00:14:08,510
reduce this overhead to 57 milliseconds

413
00:14:05,900 --> 00:14:10,550
in comparison to 23 milliseconds so true

414
00:14:08,510 --> 00:14:13,490
to up is only about 2.5 times slower

415
00:14:10,550 --> 00:14:14,750
than traditional u2f registration looks

416
00:14:13,490 --> 00:14:16,280
pretty similar I'm just focusing on

417
00:14:14,750 --> 00:14:19,700
sonication here because it's the common

418
00:14:16,280 --> 00:14:22,040
case we were also curious what latency

419
00:14:19,700 --> 00:14:23,090
the actual end user experienced so here

420
00:14:22,040 --> 00:14:24,740
we measured the time from when the

421
00:14:23,090 --> 00:14:26,930
browser received some requests to when

422
00:14:24,740 --> 00:14:28,070
the browser's able to respond I mean II

423
00:14:26,930 --> 00:14:31,099
found that the user doesn't actually

424
00:14:28,070 --> 00:14:32,570
experience this 2.5 X slowed down a lot

425
00:14:31,100 --> 00:14:34,070
of time is being spent in the browser

426
00:14:32,570 --> 00:14:35,810
middleware as opposed to doing the

427
00:14:34,070 --> 00:14:37,700
crypto on the browser and on the token

428
00:14:35,810 --> 00:14:39,949
and so the end user is actually only

429
00:14:37,700 --> 00:14:42,620
experiencing an additional 20 to 30

430
00:14:39,950 --> 00:14:45,020
milliseconds of delay and so true troves

431
00:14:42,620 --> 00:14:47,360
only about 12 to 16 percent slower than

432
00:14:45,020 --> 00:14:48,560
traditionally TF it's also important to

433
00:14:47,360 --> 00:14:50,660
note that normally have to tap these

434
00:14:48,560 --> 00:14:52,400
tokens and we instrumented the tokens to

435
00:14:50,660 --> 00:14:56,120
not require this touch for the for these

436
00:14:52,400 --> 00:14:57,170
tests so in conclusion true to F shows

437
00:14:56,120 --> 00:14:59,270
that we don't need to settle for

438
00:14:57,170 --> 00:15:00,800
untrustworthy hardware true to F

439
00:14:59,270 --> 00:15:02,990
augments you to F provide a strong

440
00:15:00,800 --> 00:15:04,280
protection against backdoor tokens in a

441
00:15:02,990 --> 00:15:06,950
way that's backwards compatible with

442
00:15:04,280 --> 00:15:08,720
existing you to apps web servers true to

443
00:15:06,950 --> 00:15:10,810
F is also practical deploy and then it's

444
00:15:08,720 --> 00:15:13,010
performant on commodity hardware tokens

445
00:15:10,810 --> 00:15:13,459
we'd love to get true to F out to real

446
00:15:13,010 --> 00:15:15,050
users

447
00:15:13,460 --> 00:15:16,490
we've talked a little bit with the phyto

448
00:15:15,050 --> 00:15:18,859
standards body which is responsible for

449
00:15:16,490 --> 00:15:20,420
the Ute web standard and we love any

450
00:15:18,860 --> 00:15:22,370
help getting true to f out real users

451
00:15:20,420 --> 00:15:24,589
you can see the paper link and the code

452
00:15:22,370 --> 00:15:25,770
are all online thank you and I'll take

453
00:15:24,590 --> 00:15:34,350
any questions

454
00:15:25,770 --> 00:15:34,350
[Applause]

455
00:15:44,310 --> 00:15:50,709
it is hello hi it's mark of Corvus from

456
00:15:48,430 --> 00:15:52,359
Universal Fatima so great work I think

457
00:15:50,709 --> 00:15:55,569
especially the backward compatibility is

458
00:15:52,360 --> 00:15:59,350
it's very useful so I have one question

459
00:15:55,570 --> 00:16:01,740
so if you if you well it's it's like

460
00:15:59,350 --> 00:16:04,269
comment so I think there's still some

461
00:16:01,740 --> 00:16:06,610
some trust in the device because if the

462
00:16:04,269 --> 00:16:07,899
master secret key would be available to

463
00:16:06,610 --> 00:16:10,660
attack her of course there would be no

464
00:16:07,899 --> 00:16:12,339
security so one question is if you would

465
00:16:10,660 --> 00:16:13,810
be willing to give up this backward

466
00:16:12,339 --> 00:16:16,269
compatibility could you could you

467
00:16:13,810 --> 00:16:18,430
potentially do better so we actually

468
00:16:16,269 --> 00:16:19,870
don't so the token does not come pre

469
00:16:18,430 --> 00:16:21,279
initialize with this master secret key

470
00:16:19,870 --> 00:16:22,269
so once you get this token you can

471
00:16:21,279 --> 00:16:24,790
actually run this initialization

472
00:16:22,269 --> 00:16:26,260
procedure and our pretend our protocol

473
00:16:24,790 --> 00:16:27,610
guarantees that the token can't leak

474
00:16:26,260 --> 00:16:28,930
information through these protocol

475
00:16:27,610 --> 00:16:30,880
messages the token is no way to

476
00:16:28,930 --> 00:16:33,729
exfiltrate this master secret key Oh

477
00:16:30,880 --> 00:16:36,279
guarantee that that there isn't some

478
00:16:33,730 --> 00:16:39,279
kind of biased randomness used for the

479
00:16:36,279 --> 00:16:40,870
master secret key so actually I didn't

480
00:16:39,279 --> 00:16:42,790
show the protocol here but it's actually

481
00:16:40,870 --> 00:16:44,050
using randomness from both the token and

482
00:16:42,790 --> 00:16:45,430
the browser and so at the end of this

483
00:16:44,050 --> 00:16:47,019
protocol the token is holding some

484
00:16:45,430 --> 00:16:48,640
master secret key and the browser's

485
00:16:47,019 --> 00:16:50,649
holding some corresponding master public

486
00:16:48,640 --> 00:16:52,120
key and so if you're curious you can

487
00:16:50,649 --> 00:16:54,190
check out the paper for how we do that

488
00:16:52,120 --> 00:16:55,510
but actually it ensures that it's using

489
00:16:54,190 --> 00:16:56,949
randomness from both so it can't use

490
00:16:55,510 --> 00:17:02,620
some bad source of randomness that's a

491
00:16:56,949 --> 00:17:04,629
great question I have a question do you

492
00:17:02,620 --> 00:17:07,780
have a sense for whether true 2f would

493
00:17:04,630 --> 00:17:11,679
have defeated the recent Bluetooth

494
00:17:07,780 --> 00:17:13,689
attack that Google disclosed yeah so the

495
00:17:11,679 --> 00:17:15,160
Bluetooth attack was related

496
00:17:13,689 --> 00:17:18,939
specifically to the Bluetooth stack so

497
00:17:15,160 --> 00:17:21,250
it didn't affect the USB and NFC tokens

498
00:17:18,939 --> 00:17:24,600
and so I don't think it would have

499
00:17:21,250 --> 00:17:28,270
affected that too to my knowledge

500
00:17:24,599 --> 00:17:29,559
because it was related to because

501
00:17:28,270 --> 00:17:30,940
because it was related specifically to

502
00:17:29,559 --> 00:17:32,290
the Bluetooth stack as opposed to like

503
00:17:30,940 --> 00:17:34,559
the protocol messages that were being

504
00:17:32,290 --> 00:17:34,559
sent

505
00:17:41,779 --> 00:17:48,600
so I have a question about how you think

506
00:17:45,929 --> 00:17:51,750
about plugging this protential II

507
00:17:48,600 --> 00:17:53,010
untrusted device into an USB port this

508
00:17:51,750 --> 00:17:55,230
is a great question

509
00:17:53,010 --> 00:17:58,200
and that's yeah that's a that's a great

510
00:17:55,230 --> 00:18:00,029
question so yeah obviously you know

511
00:17:58,200 --> 00:18:03,840
plugging in and potentially untrusted

512
00:18:00,029 --> 00:18:06,330
device into USB port is like already a

513
00:18:03,840 --> 00:18:07,769
problem and we consider our work to be

514
00:18:06,330 --> 00:18:10,049
sort of orthogonal to those types of

515
00:18:07,769 --> 00:18:12,090
problems and we're looking specifically

516
00:18:10,049 --> 00:18:13,470
at protocol messages and making sure

517
00:18:12,090 --> 00:18:14,459
that you can't leak information through

518
00:18:13,470 --> 00:18:16,049
the protocol messages and we think

519
00:18:14,460 --> 00:18:18,779
there's like a lot of other great work

520
00:18:16,049 --> 00:18:21,960
on trying to make it safer to plug in

521
00:18:18,779 --> 00:18:24,240
these USB devices and so we we discuss

522
00:18:21,960 --> 00:18:25,380
them that related work in the paper but

523
00:18:24,240 --> 00:18:26,519
that's not specifically what we're

524
00:18:25,380 --> 00:18:28,230
focused on right now although that's

525
00:18:26,519 --> 00:18:31,340
you're totally right that's a really

526
00:18:28,230 --> 00:18:31,340
very real problem

527
00:18:35,770 --> 00:18:40,160
very basic question is there a way to

528
00:18:38,390 --> 00:18:43,429
distinguish if someone has sent you a

529
00:18:40,160 --> 00:18:45,650
YouTube F token or a true-to-life token

530
00:18:43,429 --> 00:18:47,360
like if I think I'm buying a 2 2 F and

531
00:18:45,650 --> 00:18:50,780
then someone just swaps it out with a

532
00:18:47,360 --> 00:18:53,389
compromise you - yes this is more this

533
00:18:50,780 --> 00:18:54,678
would be you would need support for this

534
00:18:53,390 --> 00:18:56,179
in the browser to give sort of some

535
00:18:54,679 --> 00:18:57,740
indication that you're using some you

536
00:18:56,179 --> 00:18:59,480
know the browser things that has some

537
00:18:57,740 --> 00:19:01,549
true 2f token and so it's doing all the

538
00:18:59,480 --> 00:19:03,830
checking correctly and it's not you know

539
00:19:01,549 --> 00:19:05,090
just switching to you to F that's a

540
00:19:03,830 --> 00:19:06,799
great question I think that would be you

541
00:19:05,090 --> 00:19:12,168
know that would be an implementation

542
00:19:06,799 --> 00:19:14,300
consideration yeah all right let's think

543
00:19:12,169 --> 00:19:18,589
oh my god

544
00:19:14,300 --> 00:19:18,589
[Applause]

