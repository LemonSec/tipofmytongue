1
00:00:08,590 --> 00:00:14,830
okay good morning everyone thank you

2
00:00:11,080 --> 00:00:16,100
Abby for the introduction so let me give

3
00:00:14,830 --> 00:00:20,240
you a first

4
00:00:16,100 --> 00:00:22,520
the context first so what is npc what is

5
00:00:20,240 --> 00:00:24,049
this all about well in MPC we try to

6
00:00:22,520 --> 00:00:27,110
solve the following problem

7
00:00:24,050 --> 00:00:29,630
so in MPC we have several parties to 3

8
00:00:27,110 --> 00:00:31,550
in this case I'm just shown for and they

9
00:00:29,630 --> 00:00:33,830
want to compute a function in such a way

10
00:00:31,550 --> 00:00:35,030
that only the output of this function is

11
00:00:33,830 --> 00:00:37,699
revealed to the parties and nothing

12
00:00:35,030 --> 00:00:38,989
about the input is is revealed so this

13
00:00:37,700 --> 00:00:41,420
can be done for example with a trusted

14
00:00:38,989 --> 00:00:43,400
party if each one of the four parties

15
00:00:41,420 --> 00:00:45,489
send their input and then the trusted

16
00:00:43,400 --> 00:00:50,000
party promises only to reveal the output

17
00:00:45,489 --> 00:00:51,470
so that's of course doable but stress

18
00:00:50,000 --> 00:00:52,820
privacy aware people we would like to

19
00:00:51,470 --> 00:00:55,010
remove trusted parties from the world

20
00:00:52,820 --> 00:00:56,360
and then an NPC what we want to do

21
00:00:55,010 --> 00:00:58,460
instead is to have like a similar

22
00:00:56,360 --> 00:01:00,080
behavior but involving only

23
00:00:58,460 --> 00:01:04,370
point-to-point communication between the

24
00:01:00,080 --> 00:01:06,560
parts okay so MPC is quite an old

25
00:01:04,370 --> 00:01:09,860
problem it comes like from the 80s and

26
00:01:06,560 --> 00:01:12,530
if you want to compute it circuits over

27
00:01:09,860 --> 00:01:13,850
f2 then there are some approaches to do

28
00:01:12,530 --> 00:01:15,580
that for example carpet circles which is

29
00:01:13,850 --> 00:01:18,020
one of the first solutions to this or

30
00:01:15,580 --> 00:01:20,119
BMR which is the generalization to

31
00:01:18,020 --> 00:01:21,679
multiple parties you also have G M W and

32
00:01:20,119 --> 00:01:22,850
so on and there are many more more

33
00:01:21,680 --> 00:01:25,520
modern ones because these are actually

34
00:01:22,850 --> 00:01:28,460
quite old oh if you want to compute a

35
00:01:25,520 --> 00:01:30,679
circuit actually RFP over the field of

36
00:01:28,460 --> 00:01:32,390
integers modulo P where P is a prime do

37
00:01:30,680 --> 00:01:36,740
you have other set of solutions like

38
00:01:32,390 --> 00:01:40,130
with also VW speeds a mascot and also

39
00:01:36,740 --> 00:01:43,009
many more but when you want to focus on

40
00:01:40,130 --> 00:01:45,048
computing over on a circuit that is

41
00:01:43,009 --> 00:01:47,719
integers modulo a number that is not a

42
00:01:45,049 --> 00:01:49,609
prime for example 2 to the K 2 today is

43
00:01:47,719 --> 00:01:51,919
some number then there are not so many

44
00:01:49,609 --> 00:01:55,038
solutions like there are some there is

45
00:01:51,920 --> 00:01:58,310
for example a bit ABY 3 or there is a

46
00:01:55,039 --> 00:02:01,369
shair mind and also like a compiler from

47
00:01:58,310 --> 00:02:03,770
crypto 18% of a buy down card at all but

48
00:02:01,369 --> 00:02:05,960
for the dishonest majority is sending an

49
00:02:03,770 --> 00:02:08,060
active security specifically there is

50
00:02:05,960 --> 00:02:09,919
only one solution which is this a work

51
00:02:08,060 --> 00:02:13,840
called spits ok by cramming it all at

52
00:02:09,919 --> 00:02:15,679
crypto 18 now ways there is only one

53
00:02:13,840 --> 00:02:17,630
when there are so many in the other

54
00:02:15,680 --> 00:02:20,510
setting well the ring is actually quite

55
00:02:17,630 --> 00:02:22,010
a complex structure so a ring I feel

56
00:02:20,510 --> 00:02:23,929
this ring but not every ring gets a

57
00:02:22,010 --> 00:02:26,600
field sorry I field it's a ring but not

58
00:02:23,930 --> 00:02:29,000
every ring is fill yeah so it's because

59
00:02:26,600 --> 00:02:30,470
the rings may have elements that are not

60
00:02:29,000 --> 00:02:31,850
invertable for example and there are

61
00:02:30,470 --> 00:02:33,500
like a lot of weird things going on and

62
00:02:31,850 --> 00:02:37,190
that complicates the design of protocols

63
00:02:33,500 --> 00:02:40,670
and if it's so hard and why would you

64
00:02:37,190 --> 00:02:41,810
actually want to computer them well

65
00:02:40,670 --> 00:02:43,190
there should be some benefits on

66
00:02:41,810 --> 00:02:46,130
computer practice rings and like the

67
00:02:43,190 --> 00:02:49,100
first one that comes to mind is we'll

68
00:02:46,130 --> 00:02:50,660
set K to be 64 okay to be 32 I know

69
00:02:49,100 --> 00:02:51,590
you're computing non-native data types

70
00:02:50,660 --> 00:02:52,850
and that's amazing because then

71
00:02:51,590 --> 00:02:54,980
everything should be at least

72
00:02:52,850 --> 00:02:59,930
intuitively faster like when it comes to

73
00:02:54,980 --> 00:03:01,369
computation and also like our programs

74
00:02:59,930 --> 00:03:03,260
already if you write a program in C or

75
00:03:01,370 --> 00:03:04,790
in Java or whatever the programming

76
00:03:03,260 --> 00:03:07,670
language you're probably already aware

77
00:03:04,790 --> 00:03:09,590
of overflows modulo two to the 64

78
00:03:07,670 --> 00:03:11,600
you're already programming taking this

79
00:03:09,590 --> 00:03:12,980
into account so there should be like at

80
00:03:11,600 --> 00:03:14,780
least intuitively like an easy

81
00:03:12,980 --> 00:03:19,160
compilation from these programs to npc

82
00:03:14,780 --> 00:03:21,050
programs and also something that we do a

83
00:03:19,160 --> 00:03:22,730
lot of in MPC and for example that can

84
00:03:21,050 --> 00:03:24,050
be seen in the world of AP y3 is that

85
00:03:22,730 --> 00:03:26,179
you have to convert a lot from

86
00:03:24,050 --> 00:03:28,550
arithmetic sharings to binary sharings

87
00:03:26,180 --> 00:03:30,230
because some things are cool to do with

88
00:03:28,550 --> 00:03:31,730
automatic shares like at Asia's

89
00:03:30,230 --> 00:03:33,440
multiplications and so on but when it

90
00:03:31,730 --> 00:03:35,450
comes like to flow control having like

91
00:03:33,440 --> 00:03:37,370
if statements and so on you need to go

92
00:03:35,450 --> 00:03:39,738
at the level of bits and then it because

93
00:03:37,370 --> 00:03:41,060
I mean it becomes a bit hard so if

94
00:03:39,739 --> 00:03:42,830
you're working module powers of 2 it

95
00:03:41,060 --> 00:03:44,930
makes sense and this again intuitively

96
00:03:42,830 --> 00:03:49,459
that this is like more compatible with

97
00:03:44,930 --> 00:03:52,430
binary computation so what do we do in

98
00:03:49,459 --> 00:03:54,709
this work well in this work we develop

99
00:03:52,430 --> 00:03:57,440
new primitives for this type of

100
00:03:54,709 --> 00:04:00,049
computation so we expanded its 2k

101
00:03:57,440 --> 00:04:01,820
protocol with a lot of primitives for

102
00:04:00,049 --> 00:04:05,060
for example secure sonication

103
00:04:01,820 --> 00:04:06,320
comparison equality check and so on this

104
00:04:05,060 --> 00:04:08,150
is super important because specifically

105
00:04:06,320 --> 00:04:09,380
protocol only comes with basic addition

106
00:04:08,150 --> 00:04:10,760
and multiplication and of course in

107
00:04:09,380 --> 00:04:12,739
practice if you want to use one of these

108
00:04:10,760 --> 00:04:16,130
protocols you would like to have much

109
00:04:12,739 --> 00:04:18,769
more primitive than just that we also

110
00:04:16,130 --> 00:04:20,839
implement the protocol we provide an

111
00:04:18,769 --> 00:04:23,180
implementation in in fresco which is a

112
00:04:20,839 --> 00:04:25,159
jabber framework for NPC and the cool

113
00:04:23,180 --> 00:04:27,890
thing about this framework is that it

114
00:04:25,160 --> 00:04:29,780
already has speeds implemented in it and

115
00:04:27,890 --> 00:04:31,729
also mascot which are protocols that

116
00:04:29,780 --> 00:04:33,049
work over field so by implementing our

117
00:04:31,729 --> 00:04:34,909
protocol there we can get like a clearer

118
00:04:33,050 --> 00:04:36,740
and clearer comparison between the two

119
00:04:34,910 --> 00:04:39,620
that is fair so like the results are

120
00:04:36,740 --> 00:04:41,790
actually very meaningful and the main

121
00:04:39,620 --> 00:04:43,440
point is that we indeed get some

122
00:04:41,790 --> 00:04:45,540
improvements with respect to protocols

123
00:04:43,440 --> 00:04:48,480
over fields we will discuss that later

124
00:04:45,540 --> 00:04:49,770
on in more detail and now that we have

125
00:04:48,480 --> 00:04:51,120
like of course all these set of

126
00:04:49,770 --> 00:04:52,830
primitives and all this protocol and so

127
00:04:51,120 --> 00:04:55,530
on what do we use it for we just strive

128
00:04:52,830 --> 00:04:58,080
let's use let's apply it to secure

129
00:04:55,530 --> 00:04:59,429
machine learning so we apply the

130
00:04:58,080 --> 00:05:01,050
protocol to the secure valuation of

131
00:04:59,430 --> 00:05:03,090
decision trees and also support vector

132
00:05:01,050 --> 00:05:06,720
machines and I'm going to discuss that

133
00:05:03,090 --> 00:05:09,539
later on at the end of the talk so we

134
00:05:06,720 --> 00:05:10,620
have to in order to present our results

135
00:05:09,540 --> 00:05:12,450
of course we need to talk a little bit

136
00:05:10,620 --> 00:05:15,410
about the underlying protocol that we

137
00:05:12,450 --> 00:05:17,729
base our work on and this is spits okay

138
00:05:15,410 --> 00:05:21,300
so it is it spits 2k about is very

139
00:05:17,730 --> 00:05:22,740
similar to speed and the core feature of

140
00:05:21,300 --> 00:05:24,780
any of these protocols for this Honus

141
00:05:22,740 --> 00:05:26,970
maturity or any secretion based protocol

142
00:05:24,780 --> 00:05:29,820
is what we call like secret sharing

143
00:05:26,970 --> 00:05:32,370
scheme or like authentically secure

144
00:05:29,820 --> 00:05:33,810
sharing so basically you have like a way

145
00:05:32,370 --> 00:05:36,240
of sharing your data among the parties

146
00:05:33,810 --> 00:05:37,500
and then you go through the circuit

147
00:05:36,240 --> 00:05:38,910
maintaining the environment of the

148
00:05:37,500 --> 00:05:40,680
secrecy area and then at the identity

149
00:05:38,910 --> 00:05:42,600
and you reveal the result and this is

150
00:05:40,680 --> 00:05:45,960
like a basic layout that many protocols

151
00:05:42,600 --> 00:05:48,740
follow and it spits okay the secretion

152
00:05:45,960 --> 00:05:52,049
scheme works as follows so to share X

153
00:05:48,740 --> 00:05:54,330
which is an integer model to the K and

154
00:05:52,050 --> 00:05:55,800
we denote this by this we proceed as

155
00:05:54,330 --> 00:05:58,890
follows so each part is going to have

156
00:05:55,800 --> 00:06:00,960
like an additive share of X but it's not

157
00:05:58,890 --> 00:06:02,909
really an additive share of X it's an

158
00:06:00,960 --> 00:06:05,039
additive share of X Prime this notation

159
00:06:02,910 --> 00:06:06,660
by the way means that these two things

160
00:06:05,040 --> 00:06:08,220
are congruent modulo two today the

161
00:06:06,660 --> 00:06:10,530
number that is here so this is going to

162
00:06:08,220 --> 00:06:12,090
be the security parameter and each part

163
00:06:10,530 --> 00:06:15,539
is going to have a negative share of X

164
00:06:12,090 --> 00:06:17,450
prime where X prime is not X but it's

165
00:06:15,540 --> 00:06:19,680
congruent to X modulo the lower K bits

166
00:06:17,450 --> 00:06:21,210
so that's pretty similar to spins in

167
00:06:19,680 --> 00:06:24,600
species is just the same except that

168
00:06:21,210 --> 00:06:26,370
here instead of X prime we have X now so

169
00:06:24,600 --> 00:06:28,080
all parts have added additive shares but

170
00:06:26,370 --> 00:06:29,610
they also have additive shares of a key

171
00:06:28,080 --> 00:06:31,169
which is going to be global for the

172
00:06:29,610 --> 00:06:34,470
whole computation of the circuit and

173
00:06:31,170 --> 00:06:37,500
also random and they also have additive

174
00:06:34,470 --> 00:06:41,160
shares of a Mac of X prime where the

175
00:06:37,500 --> 00:06:42,420
match is alpha the key times X prime so

176
00:06:41,160 --> 00:06:44,460
this is this is the secret sharing

177
00:06:42,420 --> 00:06:47,790
scheme again very similar to they want

178
00:06:44,460 --> 00:06:49,440
use in other protocols and now once you

179
00:06:47,790 --> 00:06:50,760
have a secretion scheme going to from

180
00:06:49,440 --> 00:06:52,440
there to a protocol is actually like

181
00:06:50,760 --> 00:06:53,900
this is the template the template that

182
00:06:52,440 --> 00:06:56,600
has been used for for large

183
00:06:53,900 --> 00:06:59,210
which is you first need to distribute

184
00:06:56,600 --> 00:07:01,040
your inputs so this you do just by

185
00:06:59,210 --> 00:07:03,469
masking your own input with a random

186
00:07:01,040 --> 00:07:04,789
value that you know and also the parties

187
00:07:03,470 --> 00:07:07,070
have shares of this random value did you

188
00:07:04,789 --> 00:07:08,900
process it somehow and I'm going to get

189
00:07:07,070 --> 00:07:10,759
into the details of the processing and

190
00:07:08,900 --> 00:07:13,130
then G you broadcast this value and

191
00:07:10,759 --> 00:07:14,900
everybody can do can undo the mask with

192
00:07:13,130 --> 00:07:17,479
their shares so now everybody has the

193
00:07:14,900 --> 00:07:19,099
shares of the input edition gates are

194
00:07:17,479 --> 00:07:20,710
computed locally because the secret

195
00:07:19,100 --> 00:07:23,060
sharing scheme is additively homomorphic

196
00:07:20,710 --> 00:07:25,419
for multiplication gates we have this

197
00:07:23,060 --> 00:07:27,620
nice trick by Bieber it all the way from

198
00:07:25,419 --> 00:07:30,320
and what you see multiplication triples

199
00:07:27,620 --> 00:07:32,240
which is you process a triple where C is

200
00:07:30,320 --> 00:07:34,909
the product of a and B and then you can

201
00:07:32,240 --> 00:07:36,949
actually open the difference of XNA the

202
00:07:34,910 --> 00:07:38,660
difference of Y and B and do this take

203
00:07:36,949 --> 00:07:39,860
this linear combination and you can

204
00:07:38,660 --> 00:07:42,520
check that indeed this gives you X

205
00:07:39,860 --> 00:07:46,610
shares of X Y so very standard a

206
00:07:42,520 --> 00:07:48,620
approach to getting pissing now again

207
00:07:46,610 --> 00:07:50,030
only additional multiplication we would

208
00:07:48,620 --> 00:07:52,970
like to have more products on top of it

209
00:07:50,030 --> 00:07:56,419
so let me introduce the sum of the

210
00:07:52,970 --> 00:07:58,760
primitives that were introduced so this

211
00:07:56,419 --> 00:08:00,409
is sort of the road map or the or the

212
00:07:58,760 --> 00:08:02,240
map like half of the things that we

213
00:08:00,410 --> 00:08:03,889
introduced in this work I would like to

214
00:08:02,240 --> 00:08:06,440
throw your attention in this particular

215
00:08:03,889 --> 00:08:08,810
column so this is the like the core

216
00:08:06,440 --> 00:08:09,860
primitives that we need for any further

217
00:08:08,810 --> 00:08:12,919
protocol to work at all

218
00:08:09,860 --> 00:08:14,300
so we have the normal triples that we

219
00:08:12,919 --> 00:08:19,130
generate using spits okay there is

220
00:08:14,300 --> 00:08:21,409
nothing new yet we also have triples

221
00:08:19,130 --> 00:08:24,889
that are not suited to K but c2 so

222
00:08:21,409 --> 00:08:26,419
binary triples also obtainable B this

223
00:08:24,889 --> 00:08:28,099
fits okay but we show one optimization

224
00:08:26,419 --> 00:08:29,599
about how to get them with another type

225
00:08:28,099 --> 00:08:32,450
of triples not going to discuss this in

226
00:08:29,599 --> 00:08:33,860
the talk but well we also will be

227
00:08:32,450 --> 00:08:36,650
introducing this work is the generation

228
00:08:33,860 --> 00:08:37,969
of random bits so share values that you

229
00:08:36,650 --> 00:08:41,088
know that the underlying value is either

230
00:08:37,969 --> 00:08:42,320
0 or 1 nothing else so that turns out to

231
00:08:41,089 --> 00:08:44,570
be a very important primitive as I

232
00:08:42,320 --> 00:08:46,520
hopefully will convince you later on and

233
00:08:44,570 --> 00:08:48,529
also we also have shares conversions

234
00:08:46,520 --> 00:08:51,740
from binary shares to arithmetic shares

235
00:08:48,529 --> 00:08:53,270
and back now in this column we can see

236
00:08:51,740 --> 00:08:56,000
sort of the primitives that we introduce

237
00:08:53,270 --> 00:08:57,620
so we have truncation which is very

238
00:08:56,000 --> 00:09:00,290
important for fixed point arithmetic and

239
00:08:57,620 --> 00:09:01,610
we also have bit decomposition so you

240
00:09:00,290 --> 00:09:04,400
have several values you want to get

241
00:09:01,610 --> 00:09:06,440
shares of the bits we have a quality

242
00:09:04,400 --> 00:09:07,180
check the the extraction of the most

243
00:09:06,440 --> 00:09:09,670
significant bit we

244
00:09:07,180 --> 00:09:12,310
is equivalent to comparing two numbers

245
00:09:09,670 --> 00:09:13,569
inequality we have also another

246
00:09:12,310 --> 00:09:15,760
inequality but it's like bitwise

247
00:09:13,570 --> 00:09:18,040
inequality and then finally obtaining

248
00:09:15,760 --> 00:09:21,790
the carry bit of an addition there are

249
00:09:18,040 --> 00:09:23,110
primitives for being able to get more

250
00:09:21,790 --> 00:09:25,390
applications for these type of protocols

251
00:09:23,110 --> 00:09:27,700
and if we show that you can apply these

252
00:09:25,390 --> 00:09:29,260
guys and use them for SVM's

253
00:09:27,700 --> 00:09:31,000
for the evaluation of support vector

254
00:09:29,260 --> 00:09:33,340
machines and also for decision trees and

255
00:09:31,000 --> 00:09:34,750
of course it the time limitations I

256
00:09:33,340 --> 00:09:37,090
won't be able to cover them all so I'm

257
00:09:34,750 --> 00:09:38,650
mostly going to focus on the generation

258
00:09:37,090 --> 00:09:40,270
of random bits the share conversions the

259
00:09:38,650 --> 00:09:41,860
bit decomposition and then finally

260
00:09:40,270 --> 00:09:43,990
talked a little bit about the benchmarks

261
00:09:41,860 --> 00:09:47,920
on the last three under the applications

262
00:09:43,990 --> 00:09:49,480
so let's begin with generation of random

263
00:09:47,920 --> 00:09:51,490
bits so very important primitive again

264
00:09:49,480 --> 00:09:53,290
like once you get this primitive to work

265
00:09:51,490 --> 00:09:55,780
pretty much all the other primitives

266
00:09:53,290 --> 00:09:59,469
follows relatively directly from from

267
00:09:55,780 --> 00:10:01,089
the generation of it's so this is not

268
00:09:59,470 --> 00:10:03,220
the actual protocol this is the ideal

269
00:10:01,090 --> 00:10:04,420
protocol this is how you will like this

270
00:10:03,220 --> 00:10:07,840
protocol to look like or more precisely

271
00:10:04,420 --> 00:10:09,310
how it has been done before so do your

272
00:10:07,840 --> 00:10:10,630
work in over links and you say let's try

273
00:10:09,310 --> 00:10:12,359
the same thing over fields and see if it

274
00:10:10,630 --> 00:10:14,650
works so over feels it looks like this

275
00:10:12,360 --> 00:10:17,620
first you sample a random element and

276
00:10:14,650 --> 00:10:20,319
then just square it and you open the

277
00:10:17,620 --> 00:10:21,880
square intuitively like the square gets

278
00:10:20,320 --> 00:10:24,610
rid of the sign so you lost all

279
00:10:21,880 --> 00:10:26,439
information about the sign so therefore

280
00:10:24,610 --> 00:10:29,140
it's okay to open the square and the

281
00:10:26,440 --> 00:10:31,480
sign is going to be like orbit so you

282
00:10:29,140 --> 00:10:33,370
open a and then you let C be some square

283
00:10:31,480 --> 00:10:35,020
root of a is let's say the negative one

284
00:10:33,370 --> 00:10:36,460
or the positive one any anyone it does

285
00:10:35,020 --> 00:10:39,730
any any of them it doesn't really matter

286
00:10:36,460 --> 00:10:41,590
and then you compute D to be C inverse

287
00:10:39,730 --> 00:10:44,080
times R so if you square this guy here

288
00:10:41,590 --> 00:10:46,060
gives you a times R squared sorry a

289
00:10:44,080 --> 00:10:49,180
inverse times R squared so a inverse

290
00:10:46,060 --> 00:10:50,709
times a which is one so D is a square

291
00:10:49,180 --> 00:10:53,469
root of one and we all know that square

292
00:10:50,710 --> 00:10:55,690
root of one or only minus one one so now

293
00:10:53,470 --> 00:10:58,480
these random element which is basically

294
00:10:55,690 --> 00:11:00,370
the sine of r that's pretty much what it

295
00:10:58,480 --> 00:11:02,710
is so is there a minus one or plus one

296
00:11:00,370 --> 00:11:04,560
and then you want to map it to either 0

297
00:11:02,710 --> 00:11:07,150
or 1 so this is just a simple affine

298
00:11:04,560 --> 00:11:08,800
transformation you take you add 1 and

299
00:11:07,150 --> 00:11:12,459
then you get 0 or 2 and then you divide

300
00:11:08,800 --> 00:11:16,689
by 2 to get 0 or 1 and these should be a

301
00:11:12,460 --> 00:11:19,320
random bit so this should work but

302
00:11:16,690 --> 00:11:20,730
unfortunately it does not work and

303
00:11:19,320 --> 00:11:23,580
hopefully dress but it may be some

304
00:11:20,730 --> 00:11:26,820
places which it doesn't work over rinks

305
00:11:23,580 --> 00:11:29,070
it doesn't work in these places so first

306
00:11:26,820 --> 00:11:31,140
of all let's take the inverse of C a

307
00:11:29,070 --> 00:11:33,150
multiplied by R well who guarantees is

308
00:11:31,140 --> 00:11:35,040
that c is invertible because over rings

309
00:11:33,150 --> 00:11:35,840
we may have some elements that are not

310
00:11:35,040 --> 00:11:37,740
invertible at all

311
00:11:35,840 --> 00:11:39,150
specifically over this ring even

312
00:11:37,740 --> 00:11:42,830
elements are not invertible

313
00:11:39,150 --> 00:11:45,209
so this step requires some care also

314
00:11:42,830 --> 00:11:46,890
like if these are random square root of

315
00:11:45,210 --> 00:11:48,930
1 then it has to be either minus 1 or

316
00:11:46,890 --> 00:11:50,880
plus 1 that's also not true over rings

317
00:11:48,930 --> 00:11:53,910
so there are some polynomials that have

318
00:11:50,880 --> 00:11:55,560
many more roots than their degree so in

319
00:11:53,910 --> 00:11:58,530
this case this is not necessarily true

320
00:11:55,560 --> 00:12:00,989
and finally like when you divide by 2

321
00:11:58,530 --> 00:12:03,870
here like dividing by 2 is again not

322
00:12:00,990 --> 00:12:06,290
trivial over the ring so what do we do

323
00:12:03,870 --> 00:12:09,090
how do we overcome these issues

324
00:12:06,290 --> 00:12:11,390
well three main things so first of all

325
00:12:09,090 --> 00:12:14,580
we're going to increase the model a bit

326
00:12:11,390 --> 00:12:15,720
is we're going to sample our model to

327
00:12:14,580 --> 00:12:19,410
take a pass through and hopefully I'm

328
00:12:15,720 --> 00:12:22,260
going to see why this is useful we also

329
00:12:19,410 --> 00:12:23,280
going to ensure that it's odd I this is

330
00:12:22,260 --> 00:12:25,080
going to be super straightforward

331
00:12:23,280 --> 00:12:26,910
because you just take any random number

332
00:12:25,080 --> 00:12:31,020
multiplied by 2 and at 1 then you get a

333
00:12:26,910 --> 00:12:32,880
random odd number you square it you open

334
00:12:31,020 --> 00:12:35,750
it everything looks the same so far

335
00:12:32,880 --> 00:12:38,939
let's see be some square root of it same

336
00:12:35,750 --> 00:12:42,090
let's define D to be this guy which is

337
00:12:38,940 --> 00:12:43,320
again a square root of 1 so everything

338
00:12:42,090 --> 00:12:45,590
looks the same so far but now the

339
00:12:43,320 --> 00:12:47,730
difference is that we have this

340
00:12:45,590 --> 00:12:49,800
mathematical theorem which says that if

341
00:12:47,730 --> 00:12:51,720
d is a square root of 1 model to take a

342
00:12:49,800 --> 00:12:55,229
pursue then maybe t is not minus 1 or

343
00:12:51,720 --> 00:12:57,270
plus 1 but it's not so far from that so

344
00:12:55,230 --> 00:12:59,400
it's minus 1 plus 1 or minus 1 plus 2 to

345
00:12:57,270 --> 00:13:01,740
the k plus 1 or plus 1 plus 2 to the k

346
00:12:59,400 --> 00:13:04,260
plus 1 in particular if you take modulo

347
00:13:01,740 --> 00:13:05,880
2 to the k plus 1 of D then you end up

348
00:13:04,260 --> 00:13:08,880
with something that is indeed minus 1 or

349
00:13:05,880 --> 00:13:11,730
plus 1 because these guys here just go

350
00:13:08,880 --> 00:13:13,710
away so that's what we do that's that's

351
00:13:11,730 --> 00:13:15,510
the first bit in the modulus that we

352
00:13:13,710 --> 00:13:18,840
lose is if we go from two to the k plus

353
00:13:15,510 --> 00:13:20,520
2 to 2 to the k plus 1 so we get it that

354
00:13:18,840 --> 00:13:22,920
indeed is indeed between minus 1 and

355
00:13:20,520 --> 00:13:23,310
plus 1 and then finally when you divide

356
00:13:22,920 --> 00:13:25,650
by 2

357
00:13:23,310 --> 00:13:27,359
well it turns out that you can divide by

358
00:13:25,650 --> 00:13:30,010
2 if you know that the value is even

359
00:13:27,360 --> 00:13:32,320
like if you have an even value

360
00:13:30,010 --> 00:13:33,819
and you divide by two you lose one bit

361
00:13:32,320 --> 00:13:36,730
in the modulus but you still can divide

362
00:13:33,820 --> 00:13:40,090
by two for this to work all the parties

363
00:13:36,730 --> 00:13:42,250
can they must have shares that are even

364
00:13:40,090 --> 00:13:45,370
so that like every party can locally

365
00:13:42,250 --> 00:13:47,080
divide by 3 but because of the way the

366
00:13:45,370 --> 00:13:49,060
things are set up this is indeed the

367
00:13:47,080 --> 00:13:51,130
case so here this division is actually

368
00:13:49,060 --> 00:13:52,660
possible and this takes one bit from

369
00:13:51,130 --> 00:13:55,150
them from the exponent so instead of

370
00:13:52,660 --> 00:13:56,380
being 2 to the K + 1 is 2 to the K so

371
00:13:55,150 --> 00:13:58,990
that's why we have to start with two

372
00:13:56,380 --> 00:14:00,700
bits more and with this we end up with

373
00:13:58,990 --> 00:14:05,110
like a share bit which is precisely what

374
00:14:00,700 --> 00:14:06,610
we need it now what is this wait is this

375
00:14:05,110 --> 00:14:07,990
useful at all as I mentioned like it's a

376
00:14:06,610 --> 00:14:09,580
core primitive we use it for a lot of

377
00:14:07,990 --> 00:14:12,550
things and in particular we use it for

378
00:14:09,580 --> 00:14:14,740
share compressions so Michelle

379
00:14:12,550 --> 00:14:16,000
compositions I mean like what you

380
00:14:14,740 --> 00:14:18,130
obtained in the previous protocol is a

381
00:14:16,000 --> 00:14:20,130
bit but it's by the shares a very large

382
00:14:18,130 --> 00:14:22,810
there are genetic values are super large

383
00:14:20,130 --> 00:14:24,640
so what we want is like maybe to operate

384
00:14:22,810 --> 00:14:27,250
on a smaller shares like their shares of

385
00:14:24,640 --> 00:14:29,770
a bit but the shares are also smaller so

386
00:14:27,250 --> 00:14:31,960
the way we do it is I mean to convert

387
00:14:29,770 --> 00:14:32,860
from arithmetic to to binary it turns

388
00:14:31,960 --> 00:14:34,900
out that this is something you can do

389
00:14:32,860 --> 00:14:38,320
local and it's all fine but you then

390
00:14:34,900 --> 00:14:40,569
need to go back to the original so this

391
00:14:38,320 --> 00:14:43,150
is done by this so to convert from

392
00:14:40,570 --> 00:14:45,370
binary to arithmetic choose sample a

393
00:14:43,150 --> 00:14:48,819
random bit just like we show just like a

394
00:14:45,370 --> 00:14:50,490
show table or and then this random bit

395
00:14:48,820 --> 00:14:54,370
you convert it to binary just like here

396
00:14:50,490 --> 00:14:56,830
do you use it as a mask for to mask the

397
00:14:54,370 --> 00:14:58,720
bit that you want to convert and now you

398
00:14:56,830 --> 00:15:01,150
can open this this guy because well it

399
00:14:58,720 --> 00:15:03,520
gets masked by this R and then you undo

400
00:15:01,150 --> 00:15:04,660
the mask but with the other share with

401
00:15:03,520 --> 00:15:06,850
the share you care about so here I'm

402
00:15:04,660 --> 00:15:09,219
excellent be with R and here Amex

403
00:15:06,850 --> 00:15:11,290
soaring it again but now with arithmetic

404
00:15:09,220 --> 00:15:13,450
values and now the sharing I end up with

405
00:15:11,290 --> 00:15:15,130
at the end is arithmetic so we have

406
00:15:13,450 --> 00:15:16,270
share conversions and that's pretty good

407
00:15:15,130 --> 00:15:18,040
because this allows you to compute

408
00:15:16,270 --> 00:15:19,600
binary circuits but on binary shares

409
00:15:18,040 --> 00:15:20,770
instead of using arithmetic shares and

410
00:15:19,600 --> 00:15:22,270
this is something I'm going to

411
00:15:20,770 --> 00:15:24,370
illustrate here with a bit decomposition

412
00:15:22,270 --> 00:15:26,829
protocol so in the bit decomposition

413
00:15:24,370 --> 00:15:30,070
protocol you have shares of our

414
00:15:26,830 --> 00:15:34,390
somebody and you want to get shares of

415
00:15:30,070 --> 00:15:36,280
the bits of this value this is pretty

416
00:15:34,390 --> 00:15:39,689
standard over fields you just basically

417
00:15:36,280 --> 00:15:41,829
get a lot of shares of bits you

418
00:15:39,690 --> 00:15:44,350
construct the value represented by

419
00:15:41,830 --> 00:15:48,280
Pizza just this guy you use these are to

420
00:15:44,350 --> 00:15:51,400
mask X you open the mask version of X so

421
00:15:48,280 --> 00:15:53,350
far so good and now the thing that you

422
00:15:51,400 --> 00:15:55,750
usually do is that you undo undo the

423
00:15:53,350 --> 00:15:57,250
mask but with a binary circuit this is

424
00:15:55,750 --> 00:15:59,320
the standard way of doing it or fields

425
00:15:57,250 --> 00:16:01,600
but here we can do something extra

426
00:15:59,320 --> 00:16:04,000
something very nice which is instead of

427
00:16:01,600 --> 00:16:06,610
undoing the mask which means adding our

428
00:16:04,000 --> 00:16:09,760
to the B decomposition of a will first

429
00:16:06,610 --> 00:16:11,560
convert our two bits so the circuit that

430
00:16:09,760 --> 00:16:14,860
we compute here this binary circuit

431
00:16:11,560 --> 00:16:16,449
which is public value public bits and

432
00:16:14,860 --> 00:16:17,800
this share values actually it's very

433
00:16:16,450 --> 00:16:19,510
small like the shares are smaller

434
00:16:17,800 --> 00:16:20,859
because you are only sending binary

435
00:16:19,510 --> 00:16:23,260
shares instead of sending full

436
00:16:20,860 --> 00:16:24,640
arithmetic shares and this is the main

437
00:16:23,260 --> 00:16:25,960
difference of this protocol with us with

438
00:16:24,640 --> 00:16:27,610
two other protocols and then finally you

439
00:16:25,960 --> 00:16:29,110
get shares of the bits which you can you

440
00:16:27,610 --> 00:16:33,730
can compare two arithmetic share see if

441
00:16:29,110 --> 00:16:35,830
you need so this is a the main benefit

442
00:16:33,730 --> 00:16:37,270
of use of working over the ring is is

443
00:16:35,830 --> 00:16:39,540
this particular line here is that you

444
00:16:37,270 --> 00:16:41,620
can run the protocol over binary shares

445
00:16:39,540 --> 00:16:44,829
all the other protocols for all the same

446
00:16:41,620 --> 00:16:46,800
template so finally I just want to

447
00:16:44,830 --> 00:16:50,260
discuss super quickly the implementation

448
00:16:46,800 --> 00:16:54,310
benchmarks that we have so again it's

449
00:16:50,260 --> 00:16:56,439
fresco framework is Java and we can

450
00:16:54,310 --> 00:16:58,300
compare speeds and speeds okay in the

451
00:16:56,440 --> 00:16:59,980
same setup which is of course very very

452
00:16:58,300 --> 00:17:01,900
nice and I would like to focus your

453
00:16:59,980 --> 00:17:03,850
attention on this particular column

454
00:17:01,900 --> 00:17:06,160
which is the factor improvement between

455
00:17:03,850 --> 00:17:09,130
speeds to K and speeds this particular

456
00:17:06,160 --> 00:17:10,449
table is for the online phase of just

457
00:17:09,130 --> 00:17:11,920
running a bunch of multiplications

458
00:17:10,449 --> 00:17:13,350
likely the throughput as many

459
00:17:11,920 --> 00:17:16,540
multiplications you can do per second

460
00:17:13,349 --> 00:17:17,919
equality tests and comparison and the

461
00:17:16,540 --> 00:17:19,810
main point and Sigma here it is a

462
00:17:17,920 --> 00:17:21,310
statistical security parameter the main

463
00:17:19,810 --> 00:17:23,079
point is that we can get like a factor

464
00:17:21,310 --> 00:17:26,198
of roughly 5 improvement with respect to

465
00:17:23,079 --> 00:17:27,458
speeds and this is a very nice and we

466
00:17:26,199 --> 00:17:29,680
conjecture of course that this comes

467
00:17:27,459 --> 00:17:31,210
from the improvement of local

468
00:17:29,680 --> 00:17:32,950
computation but on top of that we have

469
00:17:31,210 --> 00:17:36,130
less communication because of our

470
00:17:32,950 --> 00:17:38,650
smaller shares this comes this is say

471
00:17:36,130 --> 00:17:40,330
about micro benchmarks but again as I

472
00:17:38,650 --> 00:17:42,730
mentioned we also did some evaluations

473
00:17:40,330 --> 00:17:45,280
on support vector machines so we see

474
00:17:42,730 --> 00:17:46,990
again we have a factor column here and a

475
00:17:45,280 --> 00:17:49,030
factor column here and we see that the

476
00:17:46,990 --> 00:17:51,920
improvement actually goes between 2 up

477
00:17:49,030 --> 00:17:53,690
to 5 times roughly

478
00:17:51,920 --> 00:17:55,700
where is this improvement coming from

479
00:17:53,690 --> 00:17:57,800
again we can see that as the number of

480
00:17:55,700 --> 00:17:59,480
classes increase the improvement also

481
00:17:57,800 --> 00:18:01,520
increase and again if you batch

482
00:17:59,480 --> 00:18:04,850
communication so if you do several

483
00:18:01,520 --> 00:18:07,070
executions of the same model in parallel

484
00:18:04,850 --> 00:18:08,959
it's actually better the improvement why

485
00:18:07,070 --> 00:18:10,639
is that the more number of classes you

486
00:18:08,960 --> 00:18:13,220
have the more comparisons you have to

487
00:18:10,640 --> 00:18:14,720
run so we again we have better

488
00:18:13,220 --> 00:18:17,690
comparisons protocols so this indeed

489
00:18:14,720 --> 00:18:19,340
proves that or this shows that having a

490
00:18:17,690 --> 00:18:22,420
better comparison protocol has an impact

491
00:18:19,340 --> 00:18:26,449
on this particular type of a executions

492
00:18:22,420 --> 00:18:29,840
same for decision trees the depth gets

493
00:18:26,450 --> 00:18:32,060
larger the better the factor becomes the

494
00:18:29,840 --> 00:18:34,129
depth the factor so again you like

495
00:18:32,060 --> 00:18:37,010
having a better comparison protocol in d

496
00:18:34,130 --> 00:18:38,810
it has an impact and I didn't mention

497
00:18:37,010 --> 00:18:40,820
anything about the pre-processing

498
00:18:38,810 --> 00:18:42,710
because the speeds okay is not so good

499
00:18:40,820 --> 00:18:45,139
for the pre-processing unfortunately and

500
00:18:42,710 --> 00:18:48,500
it is because we have larger shares so

501
00:18:45,140 --> 00:18:50,960
very quickly red line is overdrive the

502
00:18:48,500 --> 00:18:53,750
state-of-the-art red line is spits okay

503
00:18:50,960 --> 00:18:56,840
so with the barest of network or logic

504
00:18:53,750 --> 00:18:59,150
with a1 network we have like we we don't

505
00:18:56,840 --> 00:19:01,010
have a very much very good field this is

506
00:18:59,150 --> 00:19:02,390
because like then the communication is

507
00:19:01,010 --> 00:19:04,250
the bound that you need to have your

508
00:19:02,390 --> 00:19:06,560
network bound and you really want to

509
00:19:04,250 --> 00:19:09,650
like to have a protocol it's very

510
00:19:06,560 --> 00:19:11,179
internal communication as the network

511
00:19:09,650 --> 00:19:13,640
becomes faster we can see that if you

512
00:19:11,180 --> 00:19:16,640
have a 10 Gbps a network so al and then

513
00:19:13,640 --> 00:19:18,560
you can actually catch overdrive because

514
00:19:16,640 --> 00:19:22,160
we are not network bound any more than

515
00:19:18,560 --> 00:19:25,250
we can become communication bound so to

516
00:19:22,160 --> 00:19:26,630
conclude what we show here is an

517
00:19:25,250 --> 00:19:27,800
implementation or we discuss an

518
00:19:26,630 --> 00:19:29,540
implementation of the speed circuit

519
00:19:27,800 --> 00:19:31,220
protocol and also some practical

520
00:19:29,540 --> 00:19:33,530
primitives for computation over this

521
00:19:31,220 --> 00:19:35,720
type of links we saw that there is

522
00:19:33,530 --> 00:19:37,190
roughly a five fold improvement on the

523
00:19:35,720 --> 00:19:40,040
computation on the under running time

524
00:19:37,190 --> 00:19:41,930
but also we like I didn't mention this

525
00:19:40,040 --> 00:19:44,270
in the slides but we have an 85 fold

526
00:19:41,930 --> 00:19:45,980
reduction in the communication costs so

527
00:19:44,270 --> 00:19:47,990
again we have circuits that are binary

528
00:19:45,980 --> 00:19:50,240
so there are much faster and as future

529
00:19:47,990 --> 00:19:51,290
work it would be nice of course to close

530
00:19:50,240 --> 00:19:52,910
the gap in the pre-processing the

531
00:19:51,290 --> 00:19:54,860
proposition spits ok is not so good so

532
00:19:52,910 --> 00:19:56,720
it would be nice to to close the gap

533
00:19:54,860 --> 00:19:57,919
here and finally we have all this set of

534
00:19:56,720 --> 00:20:00,200
tools or the set of primitives that we

535
00:19:57,920 --> 00:20:01,160
would like to use so of course if anyone

536
00:20:00,200 --> 00:20:02,900
wants to think about any more

537
00:20:01,160 --> 00:20:04,160
applications of these this is a great

538
00:20:02,900 --> 00:20:07,650
feature line of research

539
00:20:04,160 --> 00:20:11,650
with that I conclude thank you so much

540
00:20:07,650 --> 00:20:19,430
[Applause]

541
00:20:11,650 --> 00:20:21,800
any questions I have one question so

542
00:20:19,430 --> 00:20:23,600
this I consider your method of creating

543
00:20:21,800 --> 00:20:25,970
bits sort of like the method of routes

544
00:20:23,600 --> 00:20:27,439
taking routes essentially does it

545
00:20:25,970 --> 00:20:30,440
generalize if you wanted to pick let's

546
00:20:27,440 --> 00:20:32,240
say instead of 1 or 2 like 1 2 3 or 1 2

547
00:20:30,440 --> 00:20:34,940
P or something like that by taking sort

548
00:20:32,240 --> 00:20:38,000
of have you thought about that yeah so

549
00:20:34,940 --> 00:20:39,590
so I guess another question is what for

550
00:20:38,000 --> 00:20:41,480
first of all but like even if you have

551
00:20:39,590 --> 00:20:43,129
like a like a clear application for that

552
00:20:41,480 --> 00:20:45,620
I don't think it generalizes because

553
00:20:43,130 --> 00:20:48,080
this method requires like I mean you're

554
00:20:45,620 --> 00:20:50,090
using the sign and the sign is like a

555
00:20:48,080 --> 00:20:52,699
binary thing either negative or positive

556
00:20:50,090 --> 00:20:54,320
so I'm not aware of any generalization

557
00:20:52,700 --> 00:20:55,790
of it it may be the case that there

558
00:20:54,320 --> 00:20:57,800
isn't like a property that is not binary

559
00:20:55,790 --> 00:20:59,690
and you can use it but I'm not sure that

560
00:20:57,800 --> 00:21:00,800
like you can do it easily but it's an

561
00:20:59,690 --> 00:21:05,720
interesting question if you have an

562
00:21:00,800 --> 00:21:08,240
application for that University of

563
00:21:05,720 --> 00:21:13,190
Pennsylvania brief technical question in

564
00:21:08,240 --> 00:21:15,850
your creation of the bit protocol how do

565
00:21:13,190 --> 00:21:24,290
you do the modding out by 2 to the K

566
00:21:15,850 --> 00:21:27,469
yeah those in your protocol for creating

567
00:21:24,290 --> 00:21:28,970
shares of bits yep in the last phase so

568
00:21:27,470 --> 00:21:33,080
you have these four different square

569
00:21:28,970 --> 00:21:35,060
roots and two of them have like this two

570
00:21:33,080 --> 00:21:37,639
to the cage and so you might have I to

571
00:21:35,060 --> 00:21:39,980
it okay so how do you do the modding out

572
00:21:37,640 --> 00:21:42,590
right isn't right okay so our same

573
00:21:39,980 --> 00:21:44,390
scheme works in such a way that like

574
00:21:42,590 --> 00:21:47,720
it's very nice this property that when

575
00:21:44,390 --> 00:21:49,550
the part is locally like reduce it the

576
00:21:47,720 --> 00:21:51,620
effect is of reducing like the actions

577
00:21:49,550 --> 00:21:53,330
here so if you want to take model or

578
00:21:51,620 --> 00:21:54,860
something from the share as long as it's

579
00:21:53,330 --> 00:21:59,629
a part of two then you can do it just by

580
00:21:54,860 --> 00:22:00,969
reducing locally okay let's thank the

581
00:21:59,630 --> 00:22:02,400
speaker

582
00:22:00,970 --> 00:22:02,580
[Applause]

583
00:22:02,400 --> 00:22:05,710
you

584
00:22:02,580 --> 00:22:05,710
[Applause]

