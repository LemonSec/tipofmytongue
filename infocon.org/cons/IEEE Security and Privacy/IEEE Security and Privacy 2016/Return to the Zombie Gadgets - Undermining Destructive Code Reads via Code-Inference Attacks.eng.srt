1
00:00:00,000 --> 00:00:03,810
thank you for<font color="#E5E5E5"> the introduction again my</font>

2
00:00:02,190 --> 00:00:06,270
name is<font color="#E5E5E5"> kevin snow and today i want to</font>

3
00:00:03,810 --> 00:00:08,490
tell<font color="#E5E5E5"> you about the return to the zombie</font>

4
00:00:06,270 --> 00:00:12,300
gadgets and this is work that<font color="#E5E5E5"> i did</font>

5
00:00:08,490 --> 00:00:14,160
along with Roman<font color="#E5E5E5"> Roman</font><font color="#CCCCCC"> rogowski who is</font>

6
00:00:12,300 --> 00:00:15,690
<font color="#E5E5E5">actually an undergraduate sophomore at</font>

7
00:00:14,160 --> 00:00:17,550
the University of North Carolina<font color="#E5E5E5"> Chapel</font>

8
00:00:15,690 --> 00:00:20,279
Hill he actually did a lot of the low

9
00:00:17,550 --> 00:00:22,470
level<font color="#E5E5E5"> analysis and implementation work</font>

10
00:00:20,279 --> 00:00:24,600
in this project also worked with Fabian

11
00:00:22,470 --> 00:00:27,060
<font color="#CCCCCC">man</font><font color="#E5E5E5"> rose at unc-chapel Hill as well as</font>

12
00:00:24,600 --> 00:00:29,760
yon<font color="#E5E5E5"> Warner at the renaissance computing</font>

13
00:00:27,060 --> 00:00:32,729
institute which is co-located with unc

14
00:00:29,760 --> 00:00:37,170
as well as<font color="#E5E5E5"> hangjun coo and mcallister</font>

15
00:00:32,729 --> 00:00:43,610
<font color="#E5E5E5">Kanakis at stony brook university so as</font>

16
00:00:37,170 --> 00:00:43,610
I'm sure most of you guys are see here

17
00:00:44,510 --> 00:00:49,199
seems to up there we go so as I'm sure

18
00:00:47,370 --> 00:00:51,480
most of you guys are<font color="#E5E5E5"> already aware over</font>

19
00:00:49,200 --> 00:00:54,570
the past 10 15 years probably longer

20
00:00:51,480 --> 00:00:57,148
there's been this back and forth between

21
00:00:54,570 --> 00:00:59,430
attacker and defender where they're

22
00:00:57,149 --> 00:01:01,829
constantly one-upping each other and in

23
00:00:59,430 --> 00:01:03,510
the current snapshot of that battle the

24
00:01:01,829 --> 00:01:05,729
most widely exploited applications are

25
00:01:03,510 --> 00:01:07,259
these really complex web browser

26
00:01:05,729 --> 00:01:09,450
applications and document reader

27
00:01:07,260 --> 00:01:11,189
applications<font color="#CCCCCC"> with which all give the</font>

28
00:01:09,450 --> 00:01:14,310
<font color="#E5E5E5">attacker these embedded scripting</font>

29
00:01:11,189 --> 00:01:16,110
facilities to help to help<font color="#E5E5E5"> the attacker</font>

30
00:01:14,310 --> 00:01:19,229
create ever increasingly sophisticated

31
00:01:16,110 --> 00:01:21,630
attacks now while widely deployed

32
00:01:19,229 --> 00:01:25,259
defenses already prevent an attacker

33
00:01:21,630 --> 00:01:28,289
from directly injecting their weaponized

34
00:01:25,259 --> 00:01:32,130
code into the<font color="#E5E5E5"> process that</font><font color="#CCCCCC"> they're</font>

35
00:01:28,290 --> 00:01:34,140
exploiting the attackers have taken a

36
00:01:32,130 --> 00:01:36,060
different<font color="#CCCCCC"> strategy in the last five or</font>

37
00:01:34,140 --> 00:01:38,130
<font color="#E5E5E5">so years of instead of directly</font>

38
00:01:36,060 --> 00:01:40,290
injecting injecting their code they are

39
00:01:38,130 --> 00:01:41,908
reusing bits and pieces<font color="#CCCCCC"> of code that</font>

40
00:01:40,290 --> 00:01:43,860
already exists in the application and

41
00:01:41,909 --> 00:01:45,479
what's called a code reuse strategy and

42
00:01:43,860 --> 00:01:46,740
they're<font color="#E5E5E5"> using the embedded scripting</font>

43
00:01:45,479 --> 00:01:51,899
facilities that help them with this

44
00:01:46,740 --> 00:01:53,460
attack so just quickly what so just

45
00:01:51,899 --> 00:01:56,430
quickly the way<font color="#E5E5E5"> I like to explain these</font>

46
00:01:53,460 --> 00:02:00,030
<font color="#CCCCCC">Kadri's attacks is with this newspaper</font>

47
00:01:56,430 --> 00:02:02,130
<font color="#CCCCCC">article example so the author the author</font>

48
00:02:00,030 --> 00:02:03,600
of<font color="#E5E5E5"> this article intended for us to</font><font color="#CCCCCC"> read</font>

49
00:02:02,130 --> 00:02:06,089
this article straight through<font color="#CCCCCC"> and learn</font>

50
00:02:03,600 --> 00:02:09,299
about daily blog tips but<font color="#E5E5E5"> instead what</font>

51
00:02:06,090 --> 00:02:10,950
we could do is circle various words and

52
00:02:09,300 --> 00:02:12,330
letters individually in this newspaper

53
00:02:10,949 --> 00:02:14,250
<font color="#E5E5E5">article</font>

54
00:02:12,330 --> 00:02:16,470
and chain all of these selections

55
00:02:14,250 --> 00:02:18,270
together to form a new<font color="#E5E5E5"> message a message</font>

56
00:02:16,470 --> 00:02:20,670
that the author didn't originally intend

57
00:02:18,270 --> 00:02:22,860
for us to learn in this<font color="#E5E5E5"> example we've</font>

58
00:02:20,670 --> 00:02:24,780
chained together letters that form the

59
00:02:22,860 --> 00:02:27,150
phrase return oriented programming and

60
00:02:24,780 --> 00:02:29,820
this is the name for<font color="#CCCCCC"> the main technical</font>

61
00:02:27,150 --> 00:02:31,860
tactic that attackers are using today<font color="#E5E5E5"> to</font>

62
00:02:29,820 --> 00:02:34,920
implement their code reuse attacks and

63
00:02:31,860 --> 00:02:37,170
so in applications it works much<font color="#E5E5E5"> the</font>

64
00:02:34,920 --> 00:02:40,649
same<font color="#CCCCCC"> way as in that newspaper article</font>

65
00:02:37,170 --> 00:02:43,380
example so instead of paragraphs and

66
00:02:40,650 --> 00:02:45,420
words and letters we have libraries and

67
00:02:43,380 --> 00:02:48,060
functions inside those libraries and

68
00:02:45,420 --> 00:02:50,820
instructions inside those functions and

69
00:02:48,060 --> 00:02:52,920
short sequences of instructions followed

70
00:02:50,820 --> 00:02:56,640
by a return instruction are generally

71
00:02:52,920 --> 00:02:58,769
<font color="#E5E5E5">called gadgets and so instead</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> the</font>

72
00:02:56,640 --> 00:03:00,510
attacker highlighting and selecting

73
00:02:58,770 --> 00:03:02,670
various words and letters the attacker

74
00:03:00,510 --> 00:03:04,890
provides as input to<font color="#E5E5E5"> the program a</font>

75
00:03:02,670 --> 00:03:07,530
series of gadget pointers and then

76
00:03:04,890 --> 00:03:09,089
redirects the program control flow to

77
00:03:07,530 --> 00:03:11,970
point to<font color="#CCCCCC"> the beginning of</font><font color="#E5E5E5"> the series of</font>

78
00:03:09,090 --> 00:03:13,740
gadget pointers and takes control of the

79
00:03:11,970 --> 00:03:16,620
program flow such that when a function

80
00:03:13,740 --> 00:03:18,360
is returned from the first return

81
00:03:16,620 --> 00:03:20,790
address provided by the attackers popped

82
00:03:18,360 --> 00:03:22,760
off the stack the short sequence of

83
00:03:20,790 --> 00:03:25,230
instructions in the gadget is executed

84
00:03:22,760 --> 00:03:27,209
followed<font color="#CCCCCC"> by a return which has the</font>

85
00:03:25,230 --> 00:03:28,679
effect<font color="#E5E5E5"> of popping the next value off the</font>

86
00:03:27,209 --> 00:03:30,840
stack the<font color="#E5E5E5"> attacker provided and</font>

87
00:03:28,680 --> 00:03:33,000
executing the second gadget<font color="#E5E5E5"> and this</font>

88
00:03:30,840 --> 00:03:34,920
process can<font color="#E5E5E5"> continue on for any number</font>

89
00:03:33,000 --> 00:03:37,470
of gadgets until the attacker has

90
00:03:34,920 --> 00:03:41,190
accomplished whatever their intended

91
00:03:37,470 --> 00:03:43,350
malicious actions are so fortunately

92
00:03:41,190 --> 00:03:44,579
there's been a defense called address

93
00:03:43,350 --> 00:03:46,560
space layout randomization that's been

94
00:03:44,580 --> 00:03:48,600
around for<font color="#CCCCCC"> quite some time</font><font color="#E5E5E5"> that does a</font>

95
00:03:46,560 --> 00:03:50,630
pretty good job of mitigating this code

96
00:03:48,600 --> 00:03:53,010
<font color="#E5E5E5">riu strategy the way this works is</font>

97
00:03:50,630 --> 00:03:55,739
between two different runs of the same

98
00:03:53,010 --> 00:03:57,660
application the program segment so the

99
00:03:55,739 --> 00:04:00,209
stack the heat all the<font color="#E5E5E5"> libraries and the</font>

100
00:03:57,660 --> 00:04:02,430
main program executable are essentially

101
00:04:00,209 --> 00:04:04,140
moved up and down in memory<font color="#CCCCCC"> so between</font>

102
00:04:02,430 --> 00:04:06,840
<font color="#E5E5E5">two different runs of the same program</font>

103
00:04:04,140 --> 00:04:09,298
the memory layout is different so this

104
00:04:06,840 --> 00:04:11,070
has the effect of the attacker is no

105
00:04:09,299 --> 00:04:13,340
<font color="#E5E5E5">longer able to know ahead of time where</font>

106
00:04:11,070 --> 00:04:15,750
those gadgets are located at in memory

107
00:04:13,340 --> 00:04:18,000
unfortunately there's a fairly<font color="#E5E5E5"> simple</font>

108
00:04:15,750 --> 00:04:19,829
attack that attackers have been<font color="#E5E5E5"> using in</font>

109
00:04:18,000 --> 00:04:21,149
the last five<font color="#CCCCCC"> years or so called</font><font color="#E5E5E5"> a</font>

110
00:04:19,829 --> 00:04:22,560
memory<font color="#E5E5E5"> disclose your attack that gets</font>

111
00:04:21,149 --> 00:04:24,750
around this address space layout

112
00:04:22,560 --> 00:04:26,500
randomization essentially<font color="#E5E5E5"> D randomizes</font>

113
00:04:24,750 --> 00:04:28,720
memory by using

114
00:04:26,500 --> 00:04:30,700
memory disclosure to read the value of a

115
00:04:28,720 --> 00:04:33,340
function pointer off the heap and then

116
00:04:30,700 --> 00:04:35,080
<font color="#E5E5E5">because the libraries themselves are</font>

117
00:04:33,340 --> 00:04:37,179
moved around memory as a whole and

118
00:04:35,080 --> 00:04:38,979
functions within those libraries are not

119
00:04:37,180 --> 00:04:40,990
randomized if the attacker knows the

120
00:04:38,980 --> 00:04:42,580
address<font color="#CCCCCC"> of a single function inside of a</font>

121
00:04:40,990 --> 00:04:44,440
<font color="#E5E5E5">library well then they automatically</font>

122
00:04:42,580 --> 00:04:46,930
know the addresses<font color="#E5E5E5"> of all</font><font color="#CCCCCC"> the other</font>

123
00:04:44,440 --> 00:04:48,700
<font color="#E5E5E5">functions within that library and hence</font>

124
00:04:46,930 --> 00:04:51,790
all<font color="#CCCCCC"> the other gadgets with in all those</font>

125
00:04:48,700 --> 00:04:54,159
functions so to help with this problem

126
00:04:51,790 --> 00:04:55,780
researchers have tried to<font color="#E5E5E5"> create</font>

127
00:04:54,160 --> 00:04:58,210
enhanced versions of address<font color="#CCCCCC"> space</font>

128
00:04:55,780 --> 00:05:00,669
layout randomizations in general<font color="#CCCCCC"> this</font><font color="#E5E5E5"> is</font>

129
00:04:58,210 --> 00:05:03,039
called<font color="#E5E5E5"> fine-grained aslr and the idea</font>

130
00:05:00,669 --> 00:05:04,599
<font color="#E5E5E5">here is to not only move entire</font>

131
00:05:03,040 --> 00:05:07,270
libraries up and down but<font color="#E5E5E5"> to also</font>

132
00:05:04,600 --> 00:05:09,580
randomize the location of functions

133
00:05:07,270 --> 00:05:11,500
within those libraries and the basic

134
00:05:09,580 --> 00:05:13,479
blocks within those functions and even

135
00:05:11,500 --> 00:05:15,550
instructions inside those basic blocks

136
00:05:13,480 --> 00:05:18,040
and sometimes<font color="#E5E5E5"> the registers used in</font>

137
00:05:15,550 --> 00:05:19,990
those instructions and there's been a

138
00:05:18,040 --> 00:05:21,730
whole bunch of<font color="#E5E5E5"> different proposals for</font>

139
00:05:19,990 --> 00:05:23,320
how to implement<font color="#CCCCCC"> fine grained ASLR over</font>

140
00:05:21,730 --> 00:05:25,330
the years but they all essentially

141
00:05:23,320 --> 00:05:26,710
mitigate<font color="#E5E5E5"> this single memory disclosure</font>

142
00:05:25,330 --> 00:05:30,159
attack that<font color="#CCCCCC"> I described in the last</font>

143
00:05:26,710 --> 00:05:32,260
<font color="#E5E5E5">slide so at this point we</font><font color="#CCCCCC"> have</font>

144
00:05:30,160 --> 00:05:34,479
application memory that's been totally

145
00:05:32,260 --> 00:05:36,849
randomized but we can't<font color="#CCCCCC"> forget that</font><font color="#E5E5E5"> the</font>

146
00:05:34,479 --> 00:05:38,469
attacker is launching their attack from

147
00:05:36,850 --> 00:05:40,240
a script<font color="#E5E5E5"> that's supported in the</font>

148
00:05:38,470 --> 00:05:43,240
application they're exploiting so so

149
00:05:40,240 --> 00:05:45,010
like a<font color="#CCCCCC"> JavaScript in a web browser so</font>

150
00:05:43,240 --> 00:05:46,450
<font color="#E5E5E5">unfortunately the attacker is not</font>

151
00:05:45,010 --> 00:05:48,310
<font color="#E5E5E5">restricted to using this memory</font>

152
00:05:46,450 --> 00:05:50,919
disclosure vulnerability a single<font color="#E5E5E5"> time</font>

153
00:05:48,310 --> 00:05:52,450
they<font color="#CCCCCC"> can actually repeatedly use this</font>

154
00:05:50,919 --> 00:05:54,580
memory disclosure vulnerability<font color="#CCCCCC"> for</font>

155
00:05:52,450 --> 00:05:56,800
example by leaking an initial an initial

156
00:05:54,580 --> 00:05:58,900
function<font color="#E5E5E5"> pointer all the code that that</font>

157
00:05:56,800 --> 00:06:00,610
function pointer points to then scraping

158
00:05:58,900 --> 00:06:02,710
all the pointers off of that code page

159
00:06:00,610 --> 00:06:04,990
and so on recursively until they've

160
00:06:02,710 --> 00:06:06,969
mapped out all<font color="#E5E5E5"> of program memory and all</font>

161
00:06:04,990 --> 00:06:10,150
the gadgets within the pages they've

162
00:06:06,970 --> 00:06:12,130
disclosed so the attacker at runtime can

163
00:06:10,150 --> 00:06:13,539
find all the gadgets in memory even<font color="#CCCCCC"> when</font>

164
00:06:12,130 --> 00:06:15,790
program memory has been<font color="#CCCCCC"> finally</font>

165
00:06:13,540 --> 00:06:17,080
randomized then within<font color="#E5E5E5"> their script they</font>

166
00:06:15,790 --> 00:06:20,169
can take all those gadgets and

167
00:06:17,080 --> 00:06:22,000
automatically compile a payload composed

168
00:06:20,169 --> 00:06:24,250
of a<font color="#E5E5E5"> sequence of gadget pointers to</font>

169
00:06:22,000 --> 00:06:26,080
implement their malicious logic and then

170
00:06:24,250 --> 00:06:29,800
redirect program control flow to point

171
00:06:26,080 --> 00:06:32,020
to that payload so fortunately over the

172
00:06:29,800 --> 00:06:34,300
<font color="#E5E5E5">last few years there's been a whole slew</font>

173
00:06:32,020 --> 00:06:37,169
of<font color="#E5E5E5"> Defense's designed to mitigate the</font>

174
00:06:34,300 --> 00:06:40,480
sort<font color="#E5E5E5"> of multiple memory disclosure</font>

175
00:06:37,169 --> 00:06:41,979
exploit scenario in general they

176
00:06:40,480 --> 00:06:43,420
can be broken down<font color="#CCCCCC"> into one of two</font>

177
00:06:41,980 --> 00:06:46,420
<font color="#E5E5E5">different categories defenses that</font>

178
00:06:43,420 --> 00:06:48,520
attempt to<font color="#E5E5E5"> prevent either the the</font>

179
00:06:46,420 --> 00:06:50,830
mapping<font color="#E5E5E5"> of program memory or the</font>

180
00:06:48,520 --> 00:06:53,169
disclosure<font color="#CCCCCC"> of the actual data at that</font>

181
00:06:50,830 --> 00:06:55,930
memory so so defenses that mitigate the

182
00:06:53,170 --> 00:06:57,310
<font color="#CCCCCC">the step one the</font><font color="#E5E5E5"> read step and then you</font>

183
00:06:55,930 --> 00:07:00,010
have<font color="#E5E5E5"> another set of defenses that</font>

184
00:06:57,310 --> 00:07:02,050
attempt<font color="#CCCCCC"> to mitigate the exploit at the</font>

185
00:07:00,010 --> 00:07:04,030
execute step so assuming the attacker is

186
00:07:02,050 --> 00:07:05,470
able to find the gadgets and build their

187
00:07:04,030 --> 00:07:07,539
payload we want to stop<font color="#CCCCCC"> the actual</font>

188
00:07:05,470 --> 00:07:09,550
execution from happening for example

189
00:07:07,540 --> 00:07:12,250
with the last presentation<font color="#E5E5E5"> control flow</font>

190
00:07:09,550 --> 00:07:13,480
integrity falls into this category so

191
00:07:12,250 --> 00:07:15,520
I'm<font color="#E5E5E5"> not going to go</font><font color="#CCCCCC"> over all the</font>

192
00:07:13,480 --> 00:07:17,230
<font color="#CCCCCC">defenses that</font><font color="#E5E5E5"> have been proposed in the</font>

193
00:07:15,520 --> 00:07:19,659
last few years there's way too many to

194
00:07:17,230 --> 00:07:21,760
do that in this talk but what we became

195
00:07:19,660 --> 00:07:23,980
interested<font color="#CCCCCC"> in is of all the defenses</font>

196
00:07:21,760 --> 00:07:26,320
that have been proposed out there what

197
00:07:23,980 --> 00:07:28,420
defenses are have<font color="#CCCCCC"> been proposed</font><font color="#E5E5E5"> that are</font>

198
00:07:26,320 --> 00:07:31,120
actually binary compatible defenses that

199
00:07:28,420 --> 00:07:33,220
are usable right now not just<font color="#CCCCCC"> for toy</font>

200
00:07:31,120 --> 00:07:35,290
applications but for really complex

201
00:07:33,220 --> 00:07:39,100
applications like<font color="#E5E5E5"> the chrome web browser</font>

202
00:07:35,290 --> 00:07:41,410
or<font color="#E5E5E5"> adobe acrobat essentially we want we</font>

203
00:07:39,100 --> 00:07:43,810
want<font color="#E5E5E5"> to find a mitigation that is binary</font>

204
00:07:41,410 --> 00:07:46,530
compatible so it doesn't<font color="#E5E5E5"> require the use</font>

205
00:07:43,810 --> 00:07:49,870
of any source code or compiler level

206
00:07:46,530 --> 00:07:51,460
instrumentation it supports modules so

207
00:07:49,870 --> 00:07:53,860
dynamically loaded libraries are

208
00:07:51,460 --> 00:07:56,380
supported requires no human intervention

209
00:07:53,860 --> 00:07:58,060
whatsoever so it's a mitigation that's

210
00:07:56,380 --> 00:07:59,950
completely transparent to the user and

211
00:07:58,060 --> 00:08:02,260
to be usable it really needs<font color="#E5E5E5"> to have</font>

212
00:07:59,950 --> 00:08:04,330
negligible overhead so so around five

213
00:08:02,260 --> 00:08:07,270
percent or less of runtime performance

214
00:08:04,330 --> 00:08:08,590
overhead so when we looked at<font color="#E5E5E5"> all the</font>

215
00:08:07,270 --> 00:08:11,049
<font color="#CCCCCC">defenses that were</font><font color="#E5E5E5"> out there</font>

216
00:08:08,590 --> 00:08:13,210
unfortunately nothing met all of these

217
00:08:11,050 --> 00:08:14,770
requirements that we imposed there's a

218
00:08:13,210 --> 00:08:16,659
lot<font color="#CCCCCC"> of Defense's out there that do a</font>

219
00:08:14,770 --> 00:08:18,580
<font color="#CCCCCC">great job of enforcing really strong</font>

220
00:08:16,660 --> 00:08:21,070
security policies but<font color="#E5E5E5"> they have the</font>

221
00:08:18,580 --> 00:08:22,990
requirement of<font color="#E5E5E5"> the being embedded at the</font>

222
00:08:21,070 --> 00:08:24,880
compiler level requiring<font color="#E5E5E5"> access the</font>

223
00:08:22,990 --> 00:08:26,890
source code or requiring debug

224
00:08:24,880 --> 00:08:28,900
information so that's one direction a

225
00:08:26,890 --> 00:08:31,360
lot of defenses are taking now on the

226
00:08:28,900 --> 00:08:32,860
other<font color="#E5E5E5"> hand you</font><font color="#CCCCCC"> have defenses that are</font>

227
00:08:31,360 --> 00:08:35,740
trying<font color="#E5E5E5"> to be compatible</font><font color="#CCCCCC"> with</font>

228
00:08:32,860 --> 00:08:39,039
applications like<font color="#E5E5E5"> the last</font><font color="#CCCCCC"> cfi defense</font>

229
00:08:35,740 --> 00:08:40,720
but the<font color="#CCCCCC"> problem for</font><font color="#E5E5E5"> us with with this</font>

230
00:08:39,039 --> 00:08:44,500
sort of defense is that in order to be

231
00:08:40,720 --> 00:08:47,440
binary compatible without using source

232
00:08:44,500 --> 00:08:49,720
code all these defenses require a large

233
00:08:47,440 --> 00:08:51,250
amount of static program analysis and we

234
00:08:49,720 --> 00:08:53,170
know that static program analysis is

235
00:08:51,250 --> 00:08:54,910
actually an undecidable problem

236
00:08:53,170 --> 00:08:57,310
so what you'll see with a lot<font color="#CCCCCC"> of these</font>

237
00:08:54,910 --> 00:08:59,290
solutions is that they'll try to take a

238
00:08:57,310 --> 00:09:00,939
very<font color="#E5E5E5"> very conservative approach to</font>

239
00:08:59,290 --> 00:09:02,829
analyzing the binaries to ensure<font color="#CCCCCC"> that</font>

240
00:09:00,940 --> 00:09:04,120
they're not instrumenting the program in

241
00:09:02,829 --> 00:09:06,430
a way that's going<font color="#E5E5E5"> to going to break</font>

242
00:09:04,120 --> 00:09:07,870
compatibility at some point while you're

243
00:09:06,430 --> 00:09:10,269
running the program while you're running

244
00:09:07,870 --> 00:09:11,920
just up a<font color="#CCCCCC"> nine process and as a result</font>

245
00:09:10,269 --> 00:09:14,889
of taking that conservative approach

246
00:09:11,920 --> 00:09:19,719
you're also you<font color="#E5E5E5"> also have this trade-off</font>

247
00:09:14,889 --> 00:09:21,250
of security in that as in that you're

248
00:09:19,720 --> 00:09:22,839
<font color="#E5E5E5">going to miss certain points of</font>

249
00:09:21,250 --> 00:09:26,199
instrumentation in the program which can

250
00:09:22,839 --> 00:09:27,550
reduce the overall enforcement of the

251
00:09:26,199 --> 00:09:30,219
security policy you're trying to achieve

252
00:09:27,550 --> 00:09:32,050
then you also have defenses that are

253
00:09:30,220 --> 00:09:34,870
<font color="#E5E5E5">trying to implement something called</font>

254
00:09:32,050 --> 00:09:36,819
execute only memory and the<font color="#CCCCCC"> idea here is</font>

255
00:09:34,870 --> 00:09:38,980
that in these multiple memory disclosure

256
00:09:36,820 --> 00:09:41,680
attacks the attacker needs to be<font color="#CCCCCC"> able to</font>

257
00:09:38,980 --> 00:09:45,730
read process memory to find the gadgets

258
00:09:41,680 --> 00:09:48,189
so the idea<font color="#E5E5E5"> is that well ok we have code</font>

259
00:09:45,730 --> 00:09:50,380
code should not have data<font color="#CCCCCC"> in it</font><font color="#E5E5E5"> so</font><font color="#CCCCCC"> we</font>

260
00:09:48,190 --> 00:09:53,529
should<font color="#CCCCCC"> be</font><font color="#E5E5E5"> able to mark every code region</font>

261
00:09:50,380 --> 00:09:55,839
as non readable make it executes only

262
00:09:53,529 --> 00:09:57,910
and so<font color="#E5E5E5"> this works for some small</font>

263
00:09:55,839 --> 00:09:59,769
applications but if you look at larger

264
00:09:57,910 --> 00:10:02,860
applications what you actually find is

265
00:09:59,769 --> 00:10:05,649
that data is very very commonly mixed in

266
00:10:02,860 --> 00:10:08,740
with code inside the code section so for

267
00:10:05,649 --> 00:10:10,390
example you'll see function imports and

268
00:10:08,740 --> 00:10:15,190
exports embedded in the code section

269
00:10:10,390 --> 00:10:16,959
you'll see local local static function

270
00:10:15,190 --> 00:10:20,620
variables embedded right next to

271
00:10:16,959 --> 00:10:23,170
function code you'll see a switch jump

272
00:10:20,620 --> 00:10:26,140
tables<font color="#E5E5E5"> also embedded among a few other</font>

273
00:10:23,170 --> 00:10:27,880
examples so we sort of went down this

274
00:10:26,140 --> 00:10:29,920
path of trying to figure<font color="#CCCCCC"> out a</font>

275
00:10:27,880 --> 00:10:31,689
mitigation that<font color="#CCCCCC"> we could build that sort</font>

276
00:10:29,920 --> 00:10:34,029
<font color="#CCCCCC">of</font><font color="#E5E5E5"> takes into account this problem of</font>

277
00:10:31,690 --> 00:10:36,120
<font color="#E5E5E5">mixed code and data so we made</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> Opera</font>

278
00:10:34,029 --> 00:10:39,130
the observation that<font color="#E5E5E5"> a normal program</font>

279
00:10:36,120 --> 00:10:41,980
operation data in the code section is

280
00:10:39,130 --> 00:10:43,689
red but it should never be executed

281
00:10:41,980 --> 00:10:46,390
after it is red because it's either data

282
00:10:43,690 --> 00:10:49,779
or its code in normal benign program

283
00:10:46,390 --> 00:10:52,360
execution so the<font color="#E5E5E5"> idea we had is maybe we</font>

284
00:10:49,779 --> 00:10:54,250
can come up<font color="#CCCCCC"> with some policy where if</font>

285
00:10:52,360 --> 00:10:57,069
code section data is previously read

286
00:10:54,250 --> 00:11:01,569
then we<font color="#E5E5E5"> want to deny the subsequent</font>

287
00:10:57,069 --> 00:11:03,969
execution of any bites that were read so

288
00:11:01,569 --> 00:11:06,010
at a really high level view here's<font color="#E5E5E5"> the</font>

289
00:11:03,970 --> 00:11:07,900
system that we implemented to

290
00:11:06,010 --> 00:11:10,650
to enforce this policy and we called it

291
00:11:07,900 --> 00:11:13,240
the no execute after<font color="#E5E5E5"> read or near</font>

292
00:11:10,650 --> 00:11:15,939
mitigation and essentially we divide

293
00:11:13,240 --> 00:11:18,340
memory into two different pieces we have

294
00:11:15,940 --> 00:11:20,650
<font color="#E5E5E5">a read view of memory so anytime a read</font>

295
00:11:18,340 --> 00:11:22,480
access occurs the application is

296
00:11:20,650 --> 00:11:24,760
presented<font color="#CCCCCC"> with the data in the read view</font>

297
00:11:22,480 --> 00:11:26,620
and we have an<font color="#CCCCCC"> X of you execute view</font>

298
00:11:24,760 --> 00:11:28,840
that's presented whenever an execution

299
00:11:26,620 --> 00:11:31,930
happens so if<font color="#E5E5E5"> we look at how this works</font>

300
00:11:28,840 --> 00:11:34,030
when a multiple memory disclosure attack

301
00:11:31,930 --> 00:11:36,849
is occurring the attacker has their

302
00:11:34,030 --> 00:11:39,819
script they're using memory disclosure

303
00:11:36,850 --> 00:11:41,470
vulnerabilities to read all the code in

304
00:11:39,820 --> 00:11:43,090
the code section this takes them to the

305
00:11:41,470 --> 00:11:45,130
read view because they're reading code

306
00:11:43,090 --> 00:11:47,020
sections and so they would<font color="#CCCCCC"> actually</font>

307
00:11:45,130 --> 00:11:48,910
retrieve all<font color="#CCCCCC"> the gadgets in the code</font>

308
00:11:47,020 --> 00:11:51,189
section this mitigation wouldn't stop

309
00:11:48,910 --> 00:11:54,760
that but every time there's a read in

310
00:11:51,190 --> 00:11:57,160
the read view we modified the execute

311
00:11:54,760 --> 00:11:59,980
view to replace whatever bites were red

312
00:11:57,160 --> 00:12:01,390
with a<font color="#CCCCCC"> one-bite halt instruction and so</font>

313
00:11:59,980 --> 00:12:06,040
<font color="#E5E5E5">this has the effect of when the attacker</font>

314
00:12:01,390 --> 00:12:07,600
comes back and tries to execute<font color="#CCCCCC"> bytes</font>

315
00:12:06,040 --> 00:12:09,010
that they had previously disclosed the

316
00:12:07,600 --> 00:12:11,320
whole<font color="#CCCCCC"> instructions going to be executed</font>

317
00:12:09,010 --> 00:12:13,090
<font color="#CCCCCC">the program's going to crash and that</font>

318
00:12:11,320 --> 00:12:16,480
<font color="#E5E5E5">prevents their malicious actions from</font>

319
00:12:13,090 --> 00:12:19,090
occurring so we combined this no execute

320
00:12:16,480 --> 00:12:21,010
after read primitive with a fine-grained

321
00:12:19,090 --> 00:12:24,220
randomization scheme that works at a

322
00:12:21,010 --> 00:12:27,400
binary compatible way and did some

323
00:12:24,220 --> 00:12:29,440
experiments wrote a paper up and then we

324
00:12:27,400 --> 00:12:31,300
solve at someone that<font color="#E5E5E5"> actually just</font>

325
00:12:29,440 --> 00:12:33,880
published this paper at TCS this last

326
00:12:31,300 --> 00:12:35,859
year with the exact<font color="#CCCCCC"> same</font><font color="#E5E5E5"> idea so this</font>

327
00:12:33,880 --> 00:12:38,470
was haizen by throwing memory disclosure

328
00:12:35,860 --> 00:12:39,820
attacks using destructive reads we went

329
00:12:38,470 --> 00:12:41,830
<font color="#E5E5E5">back and</font><font color="#CCCCCC"> forth</font><font color="#E5E5E5"> with the authors of this</font>

330
00:12:39,820 --> 00:12:43,960
paper a<font color="#E5E5E5"> little bit and they kindly</font>

331
00:12:41,830 --> 00:12:46,360
informed us that our solution near was

332
00:12:43,960 --> 00:12:47,740
just a bit too far<font color="#E5E5E5"> and it's true we took</font>

333
00:12:46,360 --> 00:12:50,410
a little<font color="#E5E5E5"> too long getting it out the</font>

334
00:12:47,740 --> 00:12:52,510
door so<font color="#CCCCCC"> that was that but then we</font>

335
00:12:50,410 --> 00:12:55,360
<font color="#CCCCCC">actually had a whole new perspective on</font>

336
00:12:52,510 --> 00:12:57,460
this mitigation after seeing someone

337
00:12:55,360 --> 00:12:58,870
else's instantiation of it we<font color="#E5E5E5"> thought</font>

338
00:12:57,460 --> 00:13:01,660
<font color="#CCCCCC">about this</font><font color="#E5E5E5"> now from a completely</font>

339
00:12:58,870 --> 00:13:04,270
adversarial point of view<font color="#E5E5E5"> and so now we</font>

340
00:13:01,660 --> 00:13:06,069
changed<font color="#CCCCCC"> our question to does destructive</font>

341
00:13:04,270 --> 00:13:08,040
code reads actually provide a viable

342
00:13:06,070 --> 00:13:10,300
defense for commodity applications and

343
00:13:08,040 --> 00:13:12,069
think I'm thinking<font color="#CCCCCC"> about it in</font><font color="#E5E5E5"> this new</font>

344
00:13:10,300 --> 00:13:14,020
way we actually<font color="#E5E5E5"> thought of three</font>

345
00:13:12,070 --> 00:13:16,180
implicit assumptions that we have made

346
00:13:14,020 --> 00:13:18,550
<font color="#E5E5E5">in our work and the other guys had made</font>

347
00:13:16,180 --> 00:13:19,390
in their work<font color="#CCCCCC"> that it was never thought</font>

348
00:13:18,550 --> 00:13:21,130
of

349
00:13:19,390 --> 00:13:23,530
designing the mitigation that<font color="#CCCCCC"> was never</font>

350
00:13:21,130 --> 00:13:26,320
discussed<font color="#E5E5E5"> in either of the papers and</font>

351
00:13:23,530 --> 00:13:28,230
then second we found<font color="#E5E5E5"> that we</font><font color="#CCCCCC"> could</font>

352
00:13:26,320 --> 00:13:30,640
actually<font color="#E5E5E5"> break all</font><font color="#CCCCCC"> of these implicit</font>

353
00:13:28,230 --> 00:13:33,700
assumptions and actually completely

354
00:13:30,640 --> 00:13:36,220
undermine this new defense and third we

355
00:13:33,700 --> 00:13:38,110
<font color="#E5E5E5">think</font><font color="#CCCCCC"> that one of these implicit</font>

356
00:13:36,220 --> 00:13:41,680
assumptions that we broke relating to

357
00:13:38,110 --> 00:13:43,540
the ability to infer code in<font color="#E5E5E5"> fine</font>

358
00:13:41,680 --> 00:13:46,000
<font color="#E5E5E5">grained</font><font color="#CCCCCC"> aslr schemes might actually be</font>

359
00:13:43,540 --> 00:13:48,250
applicable<font color="#E5E5E5"> to defeating other types of</font>

360
00:13:46,000 --> 00:13:50,350
mitigations that that<font color="#E5E5E5"> sort of blindly</font>

361
00:13:48,250 --> 00:13:52,840
combined<font color="#CCCCCC"> fine-grained ASLR schemes with</font>

362
00:13:50,350 --> 00:13:55,780
with whatever they're added mitigation

363
00:13:52,840 --> 00:13:58,450
is so jumping<font color="#E5E5E5"> into some of these</font>

364
00:13:55,780 --> 00:14:00,400
implicit assumptions that we<font color="#E5E5E5"> found the</font>

365
00:13:58,450 --> 00:14:01,960
<font color="#E5E5E5">first one is</font><font color="#CCCCCC"> a code singularity</font>

366
00:14:00,400 --> 00:14:04,689
assumption basically we are<font color="#E5E5E5"> asking the</font>

367
00:14:01,960 --> 00:14:06,670
question does duplicate code exists in

368
00:14:04,690 --> 00:14:08,700
memory because if duplicate code does

369
00:14:06,670 --> 00:14:11,050
exist in memory what we could do is

370
00:14:08,700 --> 00:14:13,270
disclosed and destroy the first copy of

371
00:14:11,050 --> 00:14:15,339
code and then just adjust all of our

372
00:14:13,270 --> 00:14:17,410
gadget offsets to point to<font color="#CCCCCC"> the second</font>

373
00:14:15,340 --> 00:14:19,570
copy of the code and then we would

374
00:14:17,410 --> 00:14:21,670
essentially be executing the second set

375
00:14:19,570 --> 00:14:23,590
of gadgets with the<font color="#CCCCCC"> information we</font>

376
00:14:21,670 --> 00:14:26,740
learned from<font color="#E5E5E5"> the originally destroyed</font>

377
00:14:23,590 --> 00:14:29,680
gadgets and so we found that this is

378
00:14:26,740 --> 00:14:31,420
<font color="#E5E5E5">actually possible in practice if you</font>

379
00:14:29,680 --> 00:14:33,489
think about<font color="#E5E5E5"> all the</font><font color="#CCCCCC"> browsers they all</font>

380
00:14:31,420 --> 00:14:34,990
have JavaScript engines in them and I

381
00:14:33,490 --> 00:14:38,380
<font color="#E5E5E5">think all of the</font><font color="#CCCCCC"> browser's these days</font>

382
00:14:34,990 --> 00:14:40,660
<font color="#E5E5E5">have just in time compilation engines so</font>

383
00:14:38,380 --> 00:14:43,420
what we did is we generated a large

384
00:14:40,660 --> 00:14:45,699
random bit of JavaScript and we

385
00:14:43,420 --> 00:14:48,189
evaluated it several times in a loop and

386
00:14:45,700 --> 00:14:49,810
so<font color="#E5E5E5"> this had the effect of forcing the</font>

387
00:14:48,190 --> 00:14:53,550
JIT compilation engine to create

388
00:14:49,810 --> 00:14:56,410
multiple regions in memory each with

389
00:14:53,550 --> 00:14:58,750
exactly the same or a similar copy of

390
00:14:56,410 --> 00:15:00,819
this native<font color="#CCCCCC"> jit code that was compiled</font>

391
00:14:58,750 --> 00:15:02,800
then we used our memory disclosure to

392
00:15:00,820 --> 00:15:04,870
follow a chain of pointers to arrive at

393
00:15:02,800 --> 00:15:06,880
the first jetted code region we

394
00:15:04,870 --> 00:15:08,590
disclosed all<font color="#E5E5E5"> that code which destroyed</font>

395
00:15:06,880 --> 00:15:10,300
it in the process but that's<font color="#E5E5E5"> okay</font>

396
00:15:08,590 --> 00:15:13,360
because we never executed that code

397
00:15:10,300 --> 00:15:15,099
again then we followed the second series

398
00:15:13,360 --> 00:15:16,630
<font color="#CCCCCC">of pointers to get to the second jaded</font>

399
00:15:15,100 --> 00:15:19,180
code region which is the same<font color="#CCCCCC"> as the</font>

400
00:15:16,630 --> 00:15:23,410
first<font color="#E5E5E5"> one adjusted our payload offsets</font>

401
00:15:19,180 --> 00:15:25,209
and executed the gadgets so that was the

402
00:15:23,410 --> 00:15:27,160
first attack the second question<font color="#E5E5E5"> we</font>

403
00:15:25,210 --> 00:15:29,470
asked<font color="#E5E5E5"> or the second implicit assumption</font>

404
00:15:27,160 --> 00:15:31,480
is code persistence so we ask the

405
00:15:29,470 --> 00:15:33,670
question does transient code

406
00:15:31,480 --> 00:15:36,010
<font color="#E5E5E5">exists in application memory over time</font>

407
00:15:33,670 --> 00:15:38,380
and<font color="#E5E5E5"> the</font><font color="#CCCCCC"> easiest way to</font><font color="#E5E5E5"> think about this</font>

408
00:15:36,010 --> 00:15:40,630
<font color="#E5E5E5">is with dynamically loaded libraries for</font>

409
00:15:38,380 --> 00:15:42,720
example say at T 0 we have this

410
00:15:40,630 --> 00:15:45,220
application with three libraries loaded

411
00:15:42,720 --> 00:15:48,010
what we can do is use our memory

412
00:15:45,220 --> 00:15:51,220
disclosure to read and destroy the<font color="#E5E5E5"> first</font>

413
00:15:48,010 --> 00:15:54,819
library then if we could somehow force

414
00:15:51,220 --> 00:15:56,709
unload this library then somehow force

415
00:15:54,820 --> 00:15:59,680
reload the library we would have a fresh

416
00:15:56,709 --> 00:16:01,449
copy of all<font color="#E5E5E5"> the gadgets that we have</font>

417
00:15:59,680 --> 00:16:04,899
previously<font color="#E5E5E5"> disclosed we will be able to</font>

418
00:16:01,449 --> 00:16:07,029
execute these zombie gadgets and so it

419
00:16:04,899 --> 00:16:09,910
turns out this was<font color="#E5E5E5"> actually pretty easy</font>

420
00:16:07,029 --> 00:16:11,050
to figure out<font color="#E5E5E5"> how to do in practice what</font>

421
00:16:09,910 --> 00:16:14,649
<font color="#CCCCCC">we</font><font color="#E5E5E5"> did is we had a little bit of</font>

422
00:16:11,050 --> 00:16:16,750
JavaScript<font color="#CCCCCC"> that called this create WebGL</font>

423
00:16:14,649 --> 00:16:19,449
object function and this was<font color="#CCCCCC"> in</font><font color="#E5E5E5"> Internet</font>

424
00:16:16,750 --> 00:16:21,310
<font color="#E5E5E5">Explorer in this example and this loaded</font>

425
00:16:19,449 --> 00:16:24,729
the direct3d library which was needed<font color="#CCCCCC"> to</font>

426
00:16:21,310 --> 00:16:27,099
implement the WebGL functionality then

427
00:16:24,730 --> 00:16:28,930
we<font color="#E5E5E5"> use our memory disclosure to read it</font>

428
00:16:27,100 --> 00:16:31,360
all in so destroyed the entire library

429
00:16:28,930 --> 00:16:33,279
and then we tried to force unload the

430
00:16:31,360 --> 00:16:35,500
library by setting our canvas object to

431
00:16:33,279 --> 00:16:36,790
know and reloading the page so

432
00:16:35,500 --> 00:16:40,329
essentially we're trying to get rid<font color="#CCCCCC"> of</font>

433
00:16:36,790 --> 00:16:42,069
all<font color="#E5E5E5"> the references to this library so we</font>

434
00:16:40,329 --> 00:16:44,410
unloaded the library no actually we

435
00:16:42,069 --> 00:16:46,329
crashed the program every time we tried

436
00:16:44,410 --> 00:16:48,250
this and so actually what happened here

437
00:16:46,329 --> 00:16:51,370
is that<font color="#CCCCCC"> when we set the canvas object to</font>

438
00:16:48,250 --> 00:16:53,110
null the destructor function was being

439
00:16:51,370 --> 00:16:55,480
executed every time which we had

440
00:16:53,110 --> 00:16:57,760
<font color="#E5E5E5">previously disclosed and hence destroyed</font>

441
00:16:55,480 --> 00:16:59,920
so we had to add one extra step to this

442
00:16:57,760 --> 00:17:04,179
that we call responsible disclosure

443
00:16:59,920 --> 00:17:05,709
we're in an offline step we traced

444
00:17:04,179 --> 00:17:07,720
through all the functions that<font color="#E5E5E5"> are</font>

445
00:17:05,709 --> 00:17:09,970
actually executed during normal benign

446
00:17:07,720 --> 00:17:12,130
program execution and<font color="#E5E5E5"> we</font><font color="#CCCCCC"> whitelist all</font>

447
00:17:09,970 --> 00:17:14,650
those so we don't disclose them after<font color="#E5E5E5"> we</font>

448
00:17:12,130 --> 00:17:17,169
did that<font color="#E5E5E5"> we did our reload and the</font>

449
00:17:14,650 --> 00:17:18,939
<font color="#E5E5E5">library unloaded then we reloaded</font><font color="#CCCCCC"> the</font>

450
00:17:17,169 --> 00:17:21,040
library by creating another object and

451
00:17:18,939 --> 00:17:23,559
we implemented our control flow

452
00:17:21,040 --> 00:17:25,780
hijacking attack from there we're also

453
00:17:23,559 --> 00:17:28,690
able<font color="#E5E5E5"> to do this with multiple browser</font>

454
00:17:25,780 --> 00:17:31,418
process tabs because in recent security

455
00:17:28,690 --> 00:17:32,770
architectures<font color="#CCCCCC"> for browsers each tab is</font>

456
00:17:31,419 --> 00:17:34,960
created a new process so it could

457
00:17:32,770 --> 00:17:36,549
actually disclosed the entire memory of

458
00:17:34,960 --> 00:17:38,230
one process and then communicate all the

459
00:17:36,549 --> 00:17:41,379
gadgets to the second process and

460
00:17:38,230 --> 00:17:44,320
execute our gadgets from there so the

461
00:17:41,380 --> 00:17:45,310
last the last implicit assumption we

462
00:17:44,320 --> 00:17:47,439
looked at was this code

463
00:17:45,310 --> 00:17:49,510
<font color="#E5E5E5">association property basically we looked</font>

464
00:17:47,440 --> 00:17:51,430
at fine-grained randomization schemes

465
00:17:49,510 --> 00:17:54,340
that worked<font color="#E5E5E5"> out a binary compatible</font>

466
00:17:51,430 --> 00:17:55,540
level and we<font color="#E5E5E5"> asked the question well we</font>

467
00:17:54,340 --> 00:17:57,340
asked several questions but the one I

468
00:17:55,540 --> 00:17:59,290
want<font color="#E5E5E5"> to cover in this talk is the</font>

469
00:17:57,340 --> 00:18:01,389
question of does a function prologue and

470
00:17:59,290 --> 00:18:04,120
form us anything about<font color="#E5E5E5"> the function</font>

471
00:18:01,390 --> 00:18:06,580
epilogue so this<font color="#CCCCCC"> is just one of a whole</font>

472
00:18:04,120 --> 00:18:08,560
bunch of code transformations that are

473
00:18:06,580 --> 00:18:10,240
<font color="#E5E5E5">possible at the binary level and this</font>

474
00:18:08,560 --> 00:18:13,540
one's called the register preserving

475
00:18:10,240 --> 00:18:15,790
code reordering transformation the idea

476
00:18:13,540 --> 00:18:17,830
here<font color="#CCCCCC"> is on the Left we have</font><font color="#E5E5E5"> a function</font>

477
00:18:15,790 --> 00:18:19,510
the instructions in a function in the

478
00:18:17,830 --> 00:18:21,550
prologue of that function we're saving a

479
00:18:19,510 --> 00:18:23,980
few registers it's a pretty common

480
00:18:21,550 --> 00:18:25,480
operation then at the end of that

481
00:18:23,980 --> 00:18:27,850
function we're restoring the value of

482
00:18:25,480 --> 00:18:30,580
those registers so the transformation<font color="#CCCCCC"> is</font>

483
00:18:27,850 --> 00:18:34,000
just shuffling around the order<font color="#CCCCCC"> that we</font>

484
00:18:30,580 --> 00:18:36,419
save and restore registers in but

485
00:18:34,000 --> 00:18:39,130
thinking<font color="#CCCCCC"> about this</font><font color="#E5E5E5"> in terms of a</font>

486
00:18:36,420 --> 00:18:42,550
destructive<font color="#E5E5E5"> code reads if we disclose</font>

487
00:18:39,130 --> 00:18:44,260
only the first couple<font color="#E5E5E5"> of push values</font>

488
00:18:42,550 --> 00:18:46,000
that actually tells us what the third

489
00:18:44,260 --> 00:18:47,860
push value is because we know in this

490
00:18:46,000 --> 00:18:49,630
<font color="#E5E5E5">function that there's only three</font>

491
00:18:47,860 --> 00:18:52,179
registers being stored but<font color="#E5E5E5"> on top of</font>

492
00:18:49,630 --> 00:18:53,680
that we know<font color="#E5E5E5"> that at the</font><font color="#CCCCCC"> end of the</font>

493
00:18:52,180 --> 00:18:55,630
function these registers have to be

494
00:18:53,680 --> 00:18:58,090
restored<font color="#E5E5E5"> in reverse order that they were</font>

495
00:18:55,630 --> 00:18:59,290
pushed so by disclosing only a couple of

496
00:18:58,090 --> 00:19:00,550
instructions at<font color="#E5E5E5"> the beginning of a</font>

497
00:18:59,290 --> 00:19:03,190
function we can<font color="#E5E5E5"> infer all the</font>

498
00:19:00,550 --> 00:19:04,629
instructions at the<font color="#E5E5E5"> end and and disclose</font>

499
00:19:03,190 --> 00:19:09,610
the gadgets without actually reading

500
00:19:04,630 --> 00:19:11,620
them so just<font color="#CCCCCC"> to sum things up we looked</font>

501
00:19:09,610 --> 00:19:13,540
at three different attacks with three

502
00:19:11,620 --> 00:19:15,159
different implicit assumptions the first

503
00:19:13,540 --> 00:19:17,260
attack using the jaded code regions

504
00:19:15,160 --> 00:19:19,510
since we can generate as much jetted

505
00:19:17,260 --> 00:19:22,629
code as we want<font color="#E5E5E5"> distracted code reads</font>

506
00:19:19,510 --> 00:19:24,670
provided no no reduction in the

507
00:19:22,630 --> 00:19:27,940
percentage of gadgets in the code

508
00:19:24,670 --> 00:19:31,480
persistence implicit assumption since we

509
00:19:27,940 --> 00:19:33,190
had to only avoid the the gadgets that

510
00:19:31,480 --> 00:19:36,040
were executed during normal program

511
00:19:33,190 --> 00:19:37,150
benign execution that accounted for only

512
00:19:36,040 --> 00:19:38,620
about thirty<font color="#CCCCCC"> percent of the total</font>

513
00:19:37,150 --> 00:19:41,820
gadgets we could disclose<font color="#E5E5E5"> and then</font>

514
00:19:38,620 --> 00:19:44,379
combining all of our code and ferns

515
00:19:41,820 --> 00:19:45,970
techniques we're<font color="#E5E5E5"> able to disclose still</font>

516
00:19:44,380 --> 00:19:47,950
ninety percent of the gadgets<font color="#CCCCCC"> that were</font>

517
00:19:45,970 --> 00:19:50,620
originally<font color="#CCCCCC"> available so I'm just going</font>

518
00:19:47,950 --> 00:19:52,210
to leave<font color="#E5E5E5"> a few high-level takeaways up</font>

519
00:19:50,620 --> 00:19:54,489
here for you I want to<font color="#E5E5E5"> encourage you all</font>

520
00:19:52,210 --> 00:19:57,720
to read the paper and I'll<font color="#E5E5E5"> take any</font>

521
00:19:54,490 --> 00:19:57,720
questions now I'm giving signals

522
00:20:02,789 --> 00:20:17,919
we have time for one very quick question

523
00:20:05,649 --> 00:20:19,959
may be quick so yeah thanks a lot<font color="#E5E5E5"> for</font>

524
00:20:17,919 --> 00:20:22,269
the very interesting talk um do you

525
00:20:19,960 --> 00:20:24,549
think<font color="#E5E5E5"> that there are you use cases where</font>

526
00:20:22,269 --> 00:20:26,259
we can use destructive code reads or

527
00:20:24,549 --> 00:20:28,600
does it make<font color="#CCCCCC"> sense</font><font color="#E5E5E5"> to throw away this</font>

528
00:20:26,259 --> 00:20:31,029
primitive and don't follow this path

529
00:20:28,600 --> 00:20:33,998
anymore I think there's probably things

530
00:20:31,029 --> 00:20:35,230
we can do to I think if we just think

531
00:20:33,999 --> 00:20:37,659
about some<font color="#E5E5E5"> of these assumptions there's</font>

532
00:20:35,230 --> 00:20:39,820
probably ways that we can implement

533
00:20:37,659 --> 00:20:42,220
additional defenses on top of it<font color="#CCCCCC"> I I do</font>

534
00:20:39,820 --> 00:20:43,539
have a few ideas for it I don't think

535
00:20:42,220 --> 00:20:45,309
<font color="#E5E5E5">I'll disclose it in both in this whole</font>

536
00:20:43,539 --> 00:20:47,429
room but we can talk afterwards if you

537
00:20:45,309 --> 00:20:47,428
want

