1
00:00:00,060 --> 00:00:07,140
thank you<font color="#E5E5E5"> so my name</font><font color="#CCCCCC"> is giorgia Rios and</font>

2
00:00:03,950 --> 00:00:09,809
<font color="#E5E5E5">I'm going to present our</font><font color="#CCCCCC"> work called</font>

3
00:00:07,140 --> 00:00:12,268
<font color="#E5E5E5">Bakken block towards formal</font><font color="#CCCCCC"> black</font><font color="#E5E5E5"> box</font>

4
00:00:09,809 --> 00:00:14,730
analysis of sanitizers and<font color="#E5E5E5"> filters this</font>

5
00:00:12,269 --> 00:00:17,910
<font color="#CCCCCC">join work</font><font color="#E5E5E5"> with young</font><font color="#CCCCCC"> styles from</font>

6
00:00:14,730 --> 00:00:19,740
<font color="#CCCCCC">university of athens</font><font color="#E5E5E5"> my</font><font color="#CCCCCC"> adviser</font><font color="#E5E5E5"> Angeles</font>

7
00:00:17,910 --> 00:00:21,570
<font color="#E5E5E5">Karamat is from Columbia</font><font color="#CCCCCC"> University and</font>

8
00:00:19,740 --> 00:00:25,109
<font color="#E5E5E5">Dajjal</font><font color="#CCCCCC"> Scala's</font><font color="#E5E5E5"> from University of</font>

9
00:00:21,570 --> 00:00:26,939
Edinburgh<font color="#CCCCCC"> so the</font><font color="#E5E5E5"> motivation of our talk</font>

10
00:00:25,109 --> 00:00:28,769
is that sanitizers<font color="#CCCCCC"> and filters</font><font color="#E5E5E5"> are</font>

11
00:00:26,939 --> 00:00:31,920
fundamental building blocks of securing

12
00:00:28,769 --> 00:00:33,360
and applications<font color="#E5E5E5"> so think about any code</font>

13
00:00:31,920 --> 00:00:35,940
injection attack like cross-site

14
00:00:33,360 --> 00:00:38,160
scripting<font color="#E5E5E5"> SQL injection</font><font color="#CCCCCC"> one of the most</font>

15
00:00:35,940 --> 00:00:40,559
basic ways of defending<font color="#E5E5E5"> against those</font>

16
00:00:38,160 --> 00:00:43,050
attacks is<font color="#E5E5E5"> to take an untrusted empanada</font>

17
00:00:40,559 --> 00:00:45,809
<font color="#E5E5E5">if they're sanitized it that is turn it</font>

18
00:00:43,050 --> 00:00:49,949
into a trusted one or reject it<font color="#E5E5E5"> if it's</font>

19
00:00:45,809 --> 00:00:51,449
deemed malicious<font color="#E5E5E5"> and many times it is</font>

20
00:00:49,950 --> 00:00:52,949
necessary<font color="#E5E5E5"> when we analyze such</font>

21
00:00:51,449 --> 00:00:55,710
applications to do it in a black box

22
00:00:52,949 --> 00:00:57,809
<font color="#CCCCCC">MANET so</font><font color="#E5E5E5"> we do it without access to</font><font color="#CCCCCC"> the</font>

23
00:00:55,710 --> 00:00:59,579
<font color="#E5E5E5">source code</font><font color="#CCCCCC"> and there are multiple</font>

24
00:00:57,809 --> 00:01:03,089
<font color="#E5E5E5">reasons for that it might be a policy</font>

25
00:00:59,579 --> 00:01:05,189
case<font color="#E5E5E5"> just like in penetration testing or</font>

26
00:01:03,090 --> 00:01:07,439
it might be<font color="#CCCCCC"> too expensive to</font><font color="#E5E5E5"> gain access</font>

27
00:01:05,188 --> 00:01:10,439
<font color="#E5E5E5">to the source code</font><font color="#CCCCCC"> an example of that is</font>

28
00:01:07,439 --> 00:01:12,630
like<font color="#E5E5E5"> hardware testing an important</font>

29
00:01:10,439 --> 00:01:14,339
property<font color="#CCCCCC"> of filters is that often they</font>

30
00:01:12,630 --> 00:01:18,179
have<font color="#E5E5E5"> to be simple</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> they have to be</font>

31
00:01:14,340 --> 00:01:20,400
fast<font color="#CCCCCC"> because they we sanitize a lot of</font>

32
00:01:18,180 --> 00:01:22,740
<font color="#CCCCCC">input so we</font><font color="#E5E5E5"> have to do it in a quick</font>

33
00:01:20,400 --> 00:01:26,130
manner<font color="#CCCCCC"> so this give us the opportunity</font>

34
00:01:22,740 --> 00:01:28,770
<font color="#CCCCCC">to model these functions as formal</font>

35
00:01:26,130 --> 00:01:29,970
models like automata<font color="#CCCCCC"> and on this talk I</font>

36
00:01:28,770 --> 00:01:32,220
will<font color="#E5E5E5"> focus on a regular expression</font>

37
00:01:29,970 --> 00:01:35,640
<font color="#E5E5E5">filters however in our paper we have</font>

38
00:01:32,220 --> 00:01:38,820
many<font color="#E5E5E5"> results on sanitizers</font><font color="#CCCCCC"> - so what our</font>

39
00:01:35,640 --> 00:01:41,189
<font color="#E5E5E5">regular expression filters regular</font>

40
00:01:38,820 --> 00:01:42,929
expression filters work as follows they

41
00:01:41,189 --> 00:01:44,789
take an input<font color="#E5E5E5"> and they pass it</font><font color="#CCCCCC"> through a</font>

42
00:01:42,930 --> 00:01:47,070
regular<font color="#CCCCCC"> expression if a match is found</font>

43
00:01:44,790 --> 00:01:49,799
<font color="#E5E5E5">they could reject the input as malicious</font>

44
00:01:47,070 --> 00:01:52,770
and they used to<font color="#E5E5E5"> be widely employed for</font>

45
00:01:49,799 --> 00:01:54,540
defending against<font color="#CCCCCC"> attacks however</font><font color="#E5E5E5"> they</font>

46
00:01:52,770 --> 00:01:57,689
turned out not<font color="#CCCCCC"> to be</font><font color="#E5E5E5"> very robust by</font>

47
00:01:54,540 --> 00:02:00,930
themselves and<font color="#E5E5E5"> as us from now on</font><font color="#CCCCCC"> they</font>

48
00:01:57,689 --> 00:02:02,939
mostly<font color="#E5E5E5"> used as parts of larger software</font>

49
00:02:00,930 --> 00:02:04,649
packages such as web application

50
00:02:02,939 --> 00:02:07,139
firewalls intrusion detection systems

51
00:02:04,649 --> 00:02:09,090
and others and an important property<font color="#CCCCCC"> of</font>

52
00:02:07,140 --> 00:02:11,280
regular expression filters is<font color="#CCCCCC"> that</font><font color="#E5E5E5"> there</font>

53
00:02:09,090 --> 00:02:13,080
we can represent them as deterministic

54
00:02:11,280 --> 00:02:15,360
<font color="#E5E5E5">finite state automata</font>

55
00:02:13,080 --> 00:02:17,280
so the<font color="#E5E5E5"> fundamental question</font><font color="#CCCCCC"> that we</font>

56
00:02:15,360 --> 00:02:19,500
<font color="#E5E5E5">would like to</font><font color="#CCCCCC"> address is can we</font>

57
00:02:17,280 --> 00:02:21,510
<font color="#E5E5E5">efficiently in</font><font color="#CCCCCC"> fare such filter can we</font>

58
00:02:19,500 --> 00:02:23,490
learn the<font color="#E5E5E5"> structure of such filters</font><font color="#CCCCCC"> by</font>

59
00:02:21,510 --> 00:02:25,170
<font color="#E5E5E5">querying them and to</font><font color="#CCCCCC"> address this</font>

60
00:02:23,490 --> 00:02:27,780
question<font color="#E5E5E5"> we</font><font color="#CCCCCC"> have to take a look at a</font>

61
00:02:25,170 --> 00:02:30,440
specific<font color="#CCCCCC"> learning model called</font><font color="#E5E5E5"> exact</font>

62
00:02:27,780 --> 00:02:33,210
learning from queries<font color="#E5E5E5"> so in that model</font>

63
00:02:30,440 --> 00:02:35,310
<font color="#E5E5E5">it's an active learning model in which</font><font color="#CCCCCC"> a</font>

64
00:02:33,210 --> 00:02:37,110
learning algorithm<font color="#CCCCCC"> is</font><font color="#E5E5E5"> able to actively</font>

65
00:02:35,310 --> 00:02:40,080
query the target machine<font color="#E5E5E5"> the target</font>

66
00:02:37,110 --> 00:02:42,180
automaton with two types<font color="#E5E5E5"> of queries the</font>

67
00:02:40,080 --> 00:02:45,390
first type is<font color="#CCCCCC"> called a membership query</font>

68
00:02:42,180 --> 00:02:47,040
<font color="#E5E5E5">in that query we</font><font color="#CCCCCC"> sent a string and input</font>

69
00:02:45,390 --> 00:02:48,929
to the<font color="#CCCCCC"> machine and we get back whether</font>

70
00:02:47,040 --> 00:02:50,220
that input is accepted<font color="#E5E5E5"> or rejected by</font>

71
00:02:48,930 --> 00:02:52,260
<font color="#E5E5E5">the target automaton</font>

72
00:02:50,220 --> 00:02:54,960
on the second type<font color="#CCCCCC"> of queries more</font>

73
00:02:52,260 --> 00:02:57,929
<font color="#E5E5E5">complicated we sent in a model a</font>

74
00:02:54,960 --> 00:02:59,460
hypothesis<font color="#CCCCCC"> that we learned and then the</font>

75
00:02:57,930 --> 00:03:01,860
query will answer<font color="#E5E5E5"> back if that</font>

76
00:02:59,460 --> 00:03:03,450
hypothesis is<font color="#CCCCCC"> correct and</font><font color="#E5E5E5"> if it is not</font>

77
00:03:01,860 --> 00:03:05,130
it<font color="#CCCCCC"> will give us</font><font color="#E5E5E5"> an input in with the</font>

78
00:03:03,450 --> 00:03:09,929
hypothesis<font color="#CCCCCC"> and the target</font><font color="#E5E5E5"> machine are</font>

79
00:03:05,130 --> 00:03:11,250
behaving differently<font color="#E5E5E5"> so in that space in</font>

80
00:03:09,930 --> 00:03:13,230
that<font color="#E5E5E5"> model</font><font color="#CCCCCC"> that is a very popular</font>

81
00:03:11,250 --> 00:03:15,240
algorithm for<font color="#E5E5E5"> learning deterministic</font>

82
00:03:13,230 --> 00:03:18,000
finite state automata which<font color="#CCCCCC"> cause the</font>

83
00:03:15,240 --> 00:03:20,330
<font color="#E5E5E5">allstar algorithm that algorithm works</font>

84
00:03:18,000 --> 00:03:22,709
as follows<font color="#E5E5E5"> we first</font><font color="#CCCCCC"> started with our</font>

85
00:03:20,330 --> 00:03:25,590
<font color="#CCCCCC">initial hypothesis being an initial</font>

86
00:03:22,709 --> 00:03:28,080
<font color="#E5E5E5">state just a simple state and afterwards</font>

87
00:03:25,590 --> 00:03:30,209
<font color="#E5E5E5">we will test all transitions from that</font>

88
00:03:28,080 --> 00:03:33,239
state and see where they<font color="#CCCCCC"> are going</font><font color="#E5E5E5"> and</font>

89
00:03:30,209 --> 00:03:34,980
there<font color="#E5E5E5"> is a way to do that and at some</font>

90
00:03:33,239 --> 00:03:38,520
point we will come<font color="#E5E5E5"> up with a</font><font color="#CCCCCC"> valid</font>

91
00:03:34,980 --> 00:03:40,440
hypothesis a valid automaton<font color="#E5E5E5"> and when we</font>

92
00:03:38,520 --> 00:03:42,270
do<font color="#E5E5E5"> that we will test</font><font color="#CCCCCC"> that automaton for</font>

93
00:03:40,440 --> 00:03:45,420
equivalence we will do an equivalence

94
00:03:42,270 --> 00:03:47,400
query<font color="#E5E5E5"> with that hypothesis and the</font>

95
00:03:45,420 --> 00:03:49,890
counter<font color="#E5E5E5"> example that we will get if the</font>

96
00:03:47,400 --> 00:03:52,080
<font color="#E5E5E5">hypothesis</font><font color="#CCCCCC"> incorrect</font><font color="#E5E5E5"> will provide us</font>

97
00:03:49,890 --> 00:03:54,510
access<font color="#CCCCCC"> to fair there undiscovered states</font>

98
00:03:52,080 --> 00:03:56,459
in the target machine<font color="#CCCCCC"> and this way</font>

99
00:03:54,510 --> 00:03:59,730
eventually<font color="#CCCCCC"> we will</font><font color="#E5E5E5"> come up</font><font color="#CCCCCC"> with the</font>

100
00:03:56,459 --> 00:04:03,060
correct hypothesis correct automaton<font color="#E5E5E5"> and</font>

101
00:03:59,730 --> 00:04:04,890
<font color="#CCCCCC">leading will terminate</font><font color="#E5E5E5"> now notice</font><font color="#CCCCCC"> that</font>

102
00:04:03,060 --> 00:04:06,780
since we check all transitions from<font color="#E5E5E5"> each</font>

103
00:04:04,890 --> 00:04:09,450
state this is a really inefficient<font color="#E5E5E5"> to do</font>

104
00:04:06,780 --> 00:04:11,040
for large alphabets<font color="#E5E5E5"> if we have a large</font>

105
00:04:09,450 --> 00:04:13,320
number<font color="#CCCCCC"> of symbols</font><font color="#E5E5E5"> and regular</font>

106
00:04:11,040 --> 00:04:14,700
<font color="#CCCCCC">expressions usually have a very large</font>

107
00:04:13,320 --> 00:04:17,730
number<font color="#E5E5E5"> of</font><font color="#CCCCCC"> symbols they could the range</font>

108
00:04:14,700 --> 00:04:19,500
across<font color="#CCCCCC"> the whole</font><font color="#E5E5E5"> unicode set so we want</font>

109
00:04:17,730 --> 00:04:22,140
<font color="#CCCCCC">something that works</font><font color="#E5E5E5"> with large</font>

110
00:04:19,500 --> 00:04:24,240
alphabets<font color="#E5E5E5"> and to do that we examined</font>

111
00:04:22,140 --> 00:04:26,370
<font color="#E5E5E5">what is called symbolic finite state</font>

112
00:04:24,240 --> 00:04:28,320
automata<font color="#CCCCCC"> or SFA for cert</font>

113
00:04:26,370 --> 00:04:30,270
and symbolic automata<font color="#E5E5E5"> while classical</font>

114
00:04:28,320 --> 00:04:32,820
automata have to explicitly<font color="#CCCCCC"> state its</font>

115
00:04:30,270 --> 00:04:35,130
<font color="#E5E5E5">transition in symbolic automata</font><font color="#CCCCCC"> we</font><font color="#E5E5E5"> group</font>

116
00:04:32,820 --> 00:04:37,159
transitions into predicates<font color="#E5E5E5"> and this</font>

117
00:04:35,130 --> 00:04:41,010
predicates<font color="#CCCCCC"> which we call guards are</font>

118
00:04:37,160 --> 00:04:43,260
basically sets of<font color="#E5E5E5"> symbols that</font><font color="#CCCCCC"> are</font>

119
00:04:41,010 --> 00:04:45,120
<font color="#E5E5E5">grouped into a single transition so this</font>

120
00:04:43,260 --> 00:04:46,979
looks<font color="#E5E5E5"> like it exactly addresses our</font>

121
00:04:45,120 --> 00:04:49,440
problem it compresses<font color="#E5E5E5"> the transitions</font>

122
00:04:46,979 --> 00:04:51,030
into a single<font color="#E5E5E5"> transition so what we</font>

123
00:04:49,440 --> 00:04:53,520
would<font color="#CCCCCC"> like to</font><font color="#E5E5E5"> do is to use symbolic</font>

124
00:04:51,030 --> 00:04:56,159
automata<font color="#E5E5E5"> to infer our regular expression</font>

125
00:04:53,520 --> 00:04:58,440
filters but in order<font color="#CCCCCC"> to do that we had</font>

126
00:04:56,160 --> 00:05:00,600
<font color="#E5E5E5">to address a number</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> challenges the</font>

127
00:04:58,440 --> 00:05:02,340
<font color="#E5E5E5">first and</font><font color="#CCCCCC"> foremost fundamental challenge</font>

128
00:05:00,600 --> 00:05:05,280
is<font color="#CCCCCC"> that the alphabet might be infinite</font>

129
00:05:02,340 --> 00:05:08,299
<font color="#CCCCCC">so there is no way that we can</font>

130
00:05:05,280 --> 00:05:10,830
<font color="#CCCCCC">explicitly test</font><font color="#E5E5E5"> all transitions</font><font color="#CCCCCC"> and</font>

131
00:05:08,300 --> 00:05:12,600
<font color="#E5E5E5">furthermore whenever we want to do an</font>

132
00:05:10,830 --> 00:05:15,510
equivalence query and we get back<font color="#CCCCCC"> a</font>

133
00:05:12,600 --> 00:05:18,240
counter example<font color="#CCCCCC"> we don't we cannot</font>

134
00:05:15,510 --> 00:05:20,159
assume now that that counter example is

135
00:05:18,240 --> 00:05:22,260
due to an undiscovered<font color="#CCCCCC"> state as before</font>

136
00:05:20,160 --> 00:05:25,979
but it might beat you to a<font color="#CCCCCC"> wrong</font>

137
00:05:22,260 --> 00:05:28,199
guard that<font color="#CCCCCC"> we generated</font><font color="#E5E5E5"> so we came</font><font color="#CCCCCC"> up</font>

138
00:05:25,979 --> 00:05:30,479
<font color="#CCCCCC">with an algorithm in order to learn</font>

139
00:05:28,199 --> 00:05:33,750
symbolic automata<font color="#CCCCCC"> and this</font><font color="#E5E5E5"> algorithm</font>

140
00:05:30,479 --> 00:05:37,860
works as follows<font color="#E5E5E5"> again we start with an</font>

141
00:05:33,750 --> 00:05:40,080
<font color="#CCCCCC">initial state</font><font color="#E5E5E5"> and we</font><font color="#CCCCCC"> don't test all</font>

142
00:05:37,860 --> 00:05:42,930
transitions we test a sample<font color="#CCCCCC"> of</font>

143
00:05:40,080 --> 00:05:46,020
transitions so we might test<font color="#E5E5E5"> two symbols</font>

144
00:05:42,930 --> 00:05:49,200
say and then this sample<font color="#E5E5E5"> will</font><font color="#CCCCCC"> be fed</font>

145
00:05:46,020 --> 00:05:50,969
<font color="#E5E5E5">into a new algorithm called</font><font color="#CCCCCC"> guards an</font>

146
00:05:49,200 --> 00:05:53,460
algorithm which<font color="#E5E5E5"> will basically take</font>

147
00:05:50,970 --> 00:05:55,380
these samples<font color="#CCCCCC"> as a training set and</font><font color="#E5E5E5"> it</font>

148
00:05:53,460 --> 00:05:59,310
will produce<font color="#CCCCCC"> the guards for</font><font color="#E5E5E5"> that</font>

149
00:05:55,380 --> 00:06:02,099
specific state<font color="#E5E5E5"> and this way we will</font>

150
00:05:59,310 --> 00:06:04,520
generate<font color="#E5E5E5"> hypotheses and after that when</font>

151
00:06:02,099 --> 00:06:07,830
<font color="#CCCCCC">we check the hypothesis for equivalence</font>

152
00:06:04,520 --> 00:06:10,409
we came up with<font color="#CCCCCC"> a novel</font><font color="#E5E5E5"> counter example</font>

153
00:06:07,830 --> 00:06:12,060
processing method that<font color="#E5E5E5"> basically can't</font>

154
00:06:10,410 --> 00:06:14,039
distinguish between<font color="#E5E5E5"> the two cases</font><font color="#CCCCCC"> that I</font>

155
00:06:12,060 --> 00:06:16,860
mentioned<font color="#CCCCCC"> before</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> first we can</font>

156
00:06:14,039 --> 00:06:19,409
eventually<font color="#E5E5E5"> learn the target automaton as</font>

157
00:06:16,860 --> 00:06:21,840
a symbolic automaton<font color="#E5E5E5"> and this is</font>

158
00:06:19,410 --> 00:06:23,580
guaranteed<font color="#E5E5E5"> always to converge into the</font>

159
00:06:21,840 --> 00:06:25,469
correct automaton<font color="#E5E5E5"> under some natural</font>

160
00:06:23,580 --> 00:06:29,760
assumptions of the<font color="#E5E5E5"> guard generation</font>

161
00:06:25,470 --> 00:06:31,650
algorithm so given this algorithm<font color="#E5E5E5"> the</font>

162
00:06:29,760 --> 00:06:34,890
next question that we<font color="#E5E5E5"> have to ask is how</font>

163
00:06:31,650 --> 00:06:37,590
realistic is the learning model<font color="#CCCCCC"> that</font>

164
00:06:34,890 --> 00:06:39,360
we've built<font color="#CCCCCC"> our algorithm on so is</font>

165
00:06:37,590 --> 00:06:39,919
exactly<font color="#CCCCCC"> Dean from</font><font color="#E5E5E5"> queries a realistic</font>

166
00:06:39,360 --> 00:06:43,560
<font color="#CCCCCC">model</font>

167
00:06:39,919 --> 00:06:45,090
so let's have<font color="#E5E5E5"> a closer look at</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> in</font>

168
00:06:43,560 --> 00:06:46,530
exact learning from queries as we said

169
00:06:45,090 --> 00:06:49,320
we<font color="#CCCCCC"> can do two types of queries</font>

170
00:06:46,530 --> 00:06:51,330
membership queries<font color="#E5E5E5"> in which case in a</font>

171
00:06:49,320 --> 00:06:53,310
practical setting<font color="#E5E5E5"> we can simply test</font>

172
00:06:51,330 --> 00:06:56,340
whether a<font color="#CCCCCC"> specific input is accepted or</font>

173
00:06:53,310 --> 00:06:57,930
<font color="#E5E5E5">rejected by the target filter and then</font>

174
00:06:56,340 --> 00:07:00,210
we have to do<font color="#CCCCCC"> equivalence queries and</font>

175
00:06:57,930 --> 00:07:02,070
that's a<font color="#CCCCCC"> problem</font><font color="#E5E5E5"> because there is no way</font>

176
00:07:00,210 --> 00:07:04,169
without<font color="#CCCCCC"> having an exact</font><font color="#E5E5E5"> knowledge of the</font>

177
00:07:02,070 --> 00:07:06,210
filter to answer that question

178
00:07:04,169 --> 00:07:08,130
however by<font color="#CCCCCC"> definition of</font><font color="#E5E5E5"> the problem we</font>

179
00:07:06,210 --> 00:07:10,859
don't<font color="#E5E5E5"> have that knowledge</font><font color="#CCCCCC"> so what do</font><font color="#E5E5E5"> we</font>

180
00:07:08,130 --> 00:07:13,229
do about<font color="#E5E5E5"> that in order to solve this</font>

181
00:07:10,860 --> 00:07:15,540
<font color="#CCCCCC">problem efficiently</font><font color="#E5E5E5"> we slightly</font><font color="#CCCCCC"> modified</font>

182
00:07:13,229 --> 00:07:19,460
our<font color="#E5E5E5"> problem in what we called grammar</font>

183
00:07:15,540 --> 00:07:22,440
oriented filter auditing<font color="#E5E5E5"> in that problem</font>

184
00:07:19,460 --> 00:07:25,859
which<font color="#CCCCCC"> is</font><font color="#E5E5E5"> I will also refer to</font><font color="#CCCCCC"> us gopher</font>

185
00:07:22,440 --> 00:07:27,229
<font color="#CCCCCC">4/3 we</font><font color="#E5E5E5"> have an attacker which wants</font><font color="#CCCCCC"> to</font>

186
00:07:25,860 --> 00:07:29,550
obtain<font color="#E5E5E5"> some confidential</font><font color="#CCCCCC"> information</font>

187
00:07:27,229 --> 00:07:31,740
<font color="#CCCCCC">that</font><font color="#E5E5E5"> attacker is in possession of a</font>

188
00:07:29,550 --> 00:07:34,620
context-free grammar<font color="#E5E5E5"> G</font><font color="#CCCCCC"> that context-free</font>

189
00:07:31,740 --> 00:07:36,690
grammar is<font color="#E5E5E5"> defining a set of</font><font color="#CCCCCC"> attacks so</font>

190
00:07:34,620 --> 00:07:39,440
<font color="#E5E5E5">you can imagine that that context-free</font>

191
00:07:36,690 --> 00:07:42,120
grammar might have some<font color="#CCCCCC"> JavaScript code</font>

192
00:07:39,440 --> 00:07:44,460
definitions or for cross-site scripting

193
00:07:42,120 --> 00:07:48,240
or some<font color="#E5E5E5"> SQL code for SQL injection and</font>

194
00:07:44,460 --> 00:07:50,250
now we have a filter<font color="#E5E5E5"> protecting the</font>

195
00:07:48,240 --> 00:07:53,090
confidential information<font color="#E5E5E5"> and that filter</font>

196
00:07:50,250 --> 00:07:56,250
works by having<font color="#CCCCCC"> a regular</font><font color="#E5E5E5"> expression</font><font color="#CCCCCC"> and</font>

197
00:07:53,090 --> 00:07:59,159
basically whenever<font color="#E5E5E5"> the attacker sends in</font>

198
00:07:56,250 --> 00:08:01,350
an input to the application the filter

199
00:07:59,160 --> 00:08:02,880
will check if<font color="#CCCCCC"> that input matches the</font>

200
00:08:01,350 --> 00:08:07,289
regular expression and it will either

201
00:08:02,880 --> 00:08:10,770
<font color="#E5E5E5">reject it</font><font color="#CCCCCC"> or it will</font><font color="#E5E5E5"> detect the normal</font>

202
00:08:07,289 --> 00:08:13,349
output so the goal of<font color="#CCCCCC"> the attacker is to</font>

203
00:08:10,770 --> 00:08:16,080
<font color="#E5E5E5">find the string</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> belongs to the set</font>

204
00:08:13,350 --> 00:08:18,510
of attacks<font color="#CCCCCC"> that belongs</font><font color="#E5E5E5"> to his</font>

205
00:08:16,080 --> 00:08:21,719
context-free grammar but does not being

206
00:08:18,510 --> 00:08:23,430
rejected by<font color="#E5E5E5"> the filter and even if we</font>

207
00:08:21,720 --> 00:08:25,200
know the size of<font color="#E5E5E5"> the target regular</font>

208
00:08:23,430 --> 00:08:26,669
expression<font color="#E5E5E5"> this may require an</font>

209
00:08:25,200 --> 00:08:29,039
exponential number<font color="#CCCCCC"> of queries in</font><font color="#E5E5E5"> the</font>

210
00:08:26,669 --> 00:08:31,400
worst case<font color="#CCCCCC"> so how</font><font color="#E5E5E5"> are we going to solve</font>

211
00:08:29,039 --> 00:08:35,069
this problem<font color="#CCCCCC"> in practice is as follows</font>

212
00:08:31,400 --> 00:08:36,958
<font color="#E5E5E5">in an ideal world where we had both the</font>

213
00:08:35,070 --> 00:08:39,570
context-free grammar G and the target

214
00:08:36,958 --> 00:08:41,458
filter<font color="#E5E5E5"> F we could just compute the set</font>

215
00:08:39,570 --> 00:08:43,409
of strings<font color="#E5E5E5"> that is not rejected</font><font color="#CCCCCC"> by the</font>

216
00:08:41,458 --> 00:08:45,689
filter that<font color="#E5E5E5"> is a complement of the</font>

217
00:08:43,409 --> 00:08:47,430
filter F<font color="#E5E5E5"> and then using</font><font color="#CCCCCC"> some simple</font>

218
00:08:45,690 --> 00:08:49,140
automata theory algorithms<font color="#CCCCCC"> we can</font>

219
00:08:47,430 --> 00:08:51,300
<font color="#E5E5E5">compute the</font><font color="#CCCCCC"> intersection of</font><font color="#E5E5E5"> the grammar</font>

220
00:08:49,140 --> 00:08:52,150
with the filter and check if there is

221
00:08:51,300 --> 00:08:54,310
any string

222
00:08:52,150 --> 00:08:56,160
that bypasses<font color="#E5E5E5"> a filter from the grammar</font>

223
00:08:54,310 --> 00:08:58,599
so this can all be<font color="#E5E5E5"> done</font><font color="#CCCCCC"> efficiently</font>

224
00:08:56,160 --> 00:09:02,230
<font color="#CCCCCC">however in</font><font color="#E5E5E5"> practice the filter is not</font>

225
00:08:58,600 --> 00:09:04,480
available<font color="#E5E5E5"> as we said so what we did what</font>

226
00:09:02,230 --> 00:09:06,910
we can do is that<font color="#CCCCCC"> we</font><font color="#E5E5E5"> can infer a model</font>

227
00:09:04,480 --> 00:09:09,790
for the filter and use that<font color="#E5E5E5"> instead of</font>

228
00:09:06,910 --> 00:09:10,420
<font color="#E5E5E5">the</font><font color="#CCCCCC"> actual filter</font><font color="#E5E5E5"> so let's see how this</font>

229
00:09:09,790 --> 00:09:13,449
works

230
00:09:10,420 --> 00:09:15,390
so we have our same<font color="#E5E5E5"> setting but now our</font>

231
00:09:13,450 --> 00:09:19,260
<font color="#E5E5E5">attacker is also equipped with the</font>

232
00:09:15,390 --> 00:09:21,760
symbolic<font color="#CCCCCC"> automata learning algorithm</font><font color="#E5E5E5"> and</font>

233
00:09:19,260 --> 00:09:23,950
he has to be able<font color="#E5E5E5"> to perform</font><font color="#CCCCCC"> the two</font>

234
00:09:21,760 --> 00:09:25,810
types<font color="#E5E5E5"> of queries</font><font color="#CCCCCC"> that we mentioned so a</font>

235
00:09:23,950 --> 00:09:29,050
membership query as we already<font color="#E5E5E5"> mentioned</font>

236
00:09:25,810 --> 00:09:30,910
<font color="#E5E5E5">is simply sending that particular string</font>

237
00:09:29,050 --> 00:09:33,280
that we want<font color="#CCCCCC"> to</font><font color="#E5E5E5"> query in and testing if</font>

238
00:09:30,910 --> 00:09:37,030
it is being rejected by<font color="#E5E5E5"> the filter or</font>

239
00:09:33,280 --> 00:09:40,600
not now when the algorithm produces

240
00:09:37,030 --> 00:09:42,939
<font color="#CCCCCC">hypotheses we simply do the algorithm</font>

241
00:09:40,600 --> 00:09:45,580
<font color="#E5E5E5">not with the actual</font><font color="#CCCCCC"> filter so we</font><font color="#E5E5E5"> try to</font>

242
00:09:42,940 --> 00:09:48,070
see if there<font color="#CCCCCC"> is an attack that bypasses</font>

243
00:09:45,580 --> 00:09:50,290
<font color="#E5E5E5">the hypothesis not the actual filter and</font>

244
00:09:48,070 --> 00:09:52,750
if we don't<font color="#E5E5E5"> find such an attack we</font>

245
00:09:50,290 --> 00:09:53,230
terminate the algorithm and we stop

246
00:09:52,750 --> 00:09:56,260
there

247
00:09:53,230 --> 00:09:58,900
<font color="#E5E5E5">however if we find</font><font color="#CCCCCC"> such an attack then</font>

248
00:09:56,260 --> 00:10:03,430
we send it<font color="#CCCCCC"> to the target server</font><font color="#E5E5E5"> if that</font>

249
00:09:58,900 --> 00:10:05,949
attack<font color="#E5E5E5"> is rejected then notice that this</font>

250
00:10:03,430 --> 00:10:08,380
<font color="#CCCCCC">is a counter example for hypothesis</font>

251
00:10:05,950 --> 00:10:10,750
because by<font color="#E5E5E5"> design this attack should</font>

252
00:10:08,380 --> 00:10:12,820
bypass<font color="#E5E5E5"> the</font><font color="#CCCCCC"> filter and</font><font color="#E5E5E5"> thus it bypasses</font>

253
00:10:10,750 --> 00:10:15,790
<font color="#E5E5E5">the model and</font><font color="#CCCCCC"> facets</font><font color="#E5E5E5"> should</font><font color="#CCCCCC"> bypass the</font>

254
00:10:12,820 --> 00:10:17,740
target filter<font color="#E5E5E5"> if the attack actually</font>

255
00:10:15,790 --> 00:10:19,300
bypasses<font color="#CCCCCC"> a</font><font color="#E5E5E5"> target filter then we</font>

256
00:10:17,740 --> 00:10:23,980
<font color="#E5E5E5">basically want because we solve the</font>

257
00:10:19,300 --> 00:10:27,099
problem<font color="#E5E5E5"> positively so this allows</font><font color="#CCCCCC"> us to</font>

258
00:10:23,980 --> 00:10:30,100
<font color="#CCCCCC">actually implement</font><font color="#E5E5E5"> equivalence</font><font color="#CCCCCC"> oracles</font>

259
00:10:27,100 --> 00:10:32,280
<font color="#E5E5E5">with a single membership query and of</font>

260
00:10:30,100 --> 00:10:35,530
course it is not<font color="#E5E5E5"> a complete solution but</font>

261
00:10:32,280 --> 00:10:38,740
soon I will talk<font color="#E5E5E5"> about how efficient it</font>

262
00:10:35,530 --> 00:10:41,020
<font color="#E5E5E5">is in an practical setting so going into</font>

263
00:10:38,740 --> 00:10:42,940
the<font color="#CCCCCC"> evaluation</font><font color="#E5E5E5"> of this algorithms we</font>

264
00:10:41,020 --> 00:10:45,250
<font color="#CCCCCC">have to decide how are we</font><font color="#E5E5E5"> going to</font>

265
00:10:42,940 --> 00:10:46,960
evaluate them and<font color="#E5E5E5"> we chose 15</font><font color="#CCCCCC"> a regular</font>

266
00:10:45,250 --> 00:10:49,420
expression<font color="#CCCCCC"> filter</font><font color="#E5E5E5"> from popular web</font>

267
00:10:46,960 --> 00:10:52,840
application firewalls<font color="#E5E5E5"> these filters have</font>

268
00:10:49,420 --> 00:10:55,689
a range of sizes both regarding<font color="#CCCCCC"> States</font>

269
00:10:52,840 --> 00:10:57,790
and<font color="#E5E5E5"> transitions</font><font color="#CCCCCC"> and for</font><font color="#E5E5E5"> an alphabet size</font>

270
00:10:55,690 --> 00:11:00,280
we chose an alphabet size<font color="#E5E5E5"> of 92 symbols</font>

271
00:10:57,790 --> 00:11:03,550
which contains most printable ASCII

272
00:11:00,280 --> 00:11:05,990
characters and therefore we are<font color="#CCCCCC"> able to</font>

273
00:11:03,550 --> 00:11:08,449
express<font color="#E5E5E5"> a large range of attacks</font>

274
00:11:05,990 --> 00:11:11,570
this<font color="#E5E5E5"> alphabet and the first</font><font color="#CCCCCC"> question we</font>

275
00:11:08,450 --> 00:11:13,370
<font color="#E5E5E5">will ask is how efficient is SFA</font>

276
00:11:11,570 --> 00:11:14,839
<font color="#E5E5E5">learning</font><font color="#CCCCCC"> clearing symbolic</font><font color="#E5E5E5"> automata</font>

277
00:11:13,370 --> 00:11:19,790
<font color="#E5E5E5">versus</font><font color="#CCCCCC"> learning deterministic finite</font>

278
00:11:14,839 --> 00:11:21,649
state<font color="#CCCCCC"> automata and it is it is</font>

279
00:11:19,790 --> 00:11:23,660
<font color="#E5E5E5">surprising</font><font color="#CCCCCC"> that we found that we had</font>

280
00:11:21,649 --> 00:11:26,470
like huge increases in<font color="#E5E5E5"> the number of</font>

281
00:11:23,660 --> 00:11:29,959
<font color="#E5E5E5">queries so we noticed</font><font color="#CCCCCC"> that on average</font>

282
00:11:26,470 --> 00:11:32,950
SFA learning with<font color="#E5E5E5"> require 15 times less</font>

283
00:11:29,959 --> 00:11:35,180
queries on<font color="#CCCCCC"> the classical DFA algorithm</font>

284
00:11:32,950 --> 00:11:36,709
however we have an increase<font color="#CCCCCC"> in</font><font color="#E5E5E5"> the</font>

285
00:11:35,180 --> 00:11:39,680
equivalence queries that they're being

286
00:11:36,709 --> 00:11:41,449
used<font color="#E5E5E5"> because we have to</font><font color="#CCCCCC"> also take</font><font color="#E5E5E5"> into</font>

287
00:11:39,680 --> 00:11:44,300
<font color="#E5E5E5">account wrong transitions being</font>

288
00:11:41,450 --> 00:11:45,890
generated<font color="#E5E5E5"> and an important point here</font><font color="#CCCCCC"> is</font>

289
00:11:44,300 --> 00:11:49,670
that the<font color="#CCCCCC"> speed-up is not a simple</font>

290
00:11:45,890 --> 00:11:53,569
function<font color="#E5E5E5"> of the automaton size and going</font>

291
00:11:49,670 --> 00:11:56,420
next<font color="#CCCCCC"> I would like to also point out that</font>

292
00:11:53,570 --> 00:11:59,060
<font color="#E5E5E5">the DFA algorithm is prohibitive to use</font>

293
00:11:56,420 --> 00:12:01,660
over<font color="#E5E5E5"> the network for even automata with</font>

294
00:11:59,060 --> 00:12:05,149
around<font color="#E5E5E5"> 150</font><font color="#CCCCCC"> states</font><font color="#E5E5E5"> it would require</font>

295
00:12:01,660 --> 00:12:07,010
around 2.5 million algorithms<font color="#E5E5E5"> so having</font>

296
00:12:05,149 --> 00:12:09,350
a speed-up<font color="#CCCCCC"> in that case is</font><font color="#E5E5E5"> very</font>

297
00:12:07,010 --> 00:12:11,420
important<font color="#E5E5E5"> for the practical setting of</font>

298
00:12:09,350 --> 00:12:13,880
the problem next we would<font color="#CCCCCC"> like to</font>

299
00:12:11,420 --> 00:12:16,130
<font color="#E5E5E5">evaluate</font><font color="#CCCCCC"> our grammar oriented filter</font>

300
00:12:13,880 --> 00:12:17,899
auditing algorithm and the first

301
00:12:16,130 --> 00:12:19,579
experiment we performed is we<font color="#E5E5E5"> assumed</font>

302
00:12:17,899 --> 00:12:22,459
<font color="#CCCCCC">that the grammar does not contain</font><font color="#E5E5E5"> a</font>

303
00:12:19,579 --> 00:12:24,620
<font color="#E5E5E5">string that bypasses the filter at that</font>

304
00:12:22,459 --> 00:12:26,209
case we<font color="#E5E5E5"> would like our algorithm to</font>

305
00:12:24,620 --> 00:12:28,490
provide<font color="#CCCCCC"> the good</font><font color="#E5E5E5"> approximation to</font>

306
00:12:26,209 --> 00:12:29,839
actually function<font color="#CCCCCC"> as an equivalent Sadiq</font>

307
00:12:28,490 --> 00:12:31,520
<font color="#CCCCCC">Allah provide us with a good</font>

308
00:12:29,839 --> 00:12:34,899
approximation<font color="#E5E5E5"> of the target filter an</font>

309
00:12:31,520 --> 00:12:37,189
important question<font color="#E5E5E5"> here is what is the</font>

310
00:12:34,899 --> 00:12:39,500
correct grammar to use for<font color="#E5E5E5"> that</font>

311
00:12:37,190 --> 00:12:41,540
algorithm<font color="#E5E5E5"> and we chose to</font><font color="#CCCCCC"> use</font><font color="#E5E5E5"> us an</font>

312
00:12:39,500 --> 00:12:44,270
attack grammar the filter<font color="#E5E5E5"> itself the</font>

313
00:12:41,540 --> 00:12:47,029
<font color="#E5E5E5">reason to do that</font><font color="#CCCCCC"> is that</font><font color="#E5E5E5"> basically the</font>

314
00:12:44,270 --> 00:12:49,040
filter<font color="#E5E5E5"> itself is intuitively a maximal</font>

315
00:12:47,029 --> 00:12:53,720
set that does not contain a bypass for

316
00:12:49,040 --> 00:12:55,279
<font color="#CCCCCC">the filter so if you</font><font color="#E5E5E5"> think about it</font><font color="#CCCCCC"> the</font>

317
00:12:53,720 --> 00:12:56,899
filter<font color="#CCCCCC"> itself contains all the</font>

318
00:12:55,279 --> 00:12:59,000
information<font color="#CCCCCC"> that</font><font color="#E5E5E5"> we need in order to</font>

319
00:12:56,899 --> 00:13:01,040
infer<font color="#CCCCCC"> that algate filter but does not</font>

320
00:12:59,000 --> 00:13:05,329
contain<font color="#CCCCCC"> any string that will bypass a</font>

321
00:13:01,040 --> 00:13:07,370
<font color="#E5E5E5">filter so in this setting we found that</font>

322
00:13:05,329 --> 00:13:09,290
<font color="#E5E5E5">learning using classifying the context</font>

323
00:13:07,370 --> 00:13:12,860
of grammar<font color="#E5E5E5"> and</font><font color="#CCCCCC"> indeed filter auditing</font>

324
00:13:09,290 --> 00:13:15,949
<font color="#E5E5E5">gave us even further increases in the</font>

325
00:13:12,860 --> 00:13:19,490
<font color="#E5E5E5">speed-up gains in our</font><font color="#CCCCCC"> setting so we have</font>

326
00:13:15,949 --> 00:13:21,649
<font color="#CCCCCC">on average 35</font><font color="#E5E5E5"> times less queries</font>

327
00:13:19,490 --> 00:13:24,230
and in terms of<font color="#CCCCCC"> states recovered from</font>

328
00:13:21,649 --> 00:13:27,710
the target filters we saw<font color="#E5E5E5"> that both the</font>

329
00:13:24,230 --> 00:13:30,560
DFA<font color="#CCCCCC"> and the SFA have similar</font><font color="#E5E5E5"> States</font>

330
00:13:27,710 --> 00:13:33,470
recovered so we<font color="#CCCCCC"> SDF a recovered two</font>

331
00:13:30,560 --> 00:13:35,209
<font color="#E5E5E5">percent more queries on SFA and that's</font>

332
00:13:33,470 --> 00:13:39,320
because it basically brute force is all

333
00:13:35,210 --> 00:13:41,990
transitions<font color="#E5E5E5"> but that's in the trade</font><font color="#CCCCCC"> of</font>

334
00:13:39,320 --> 00:13:44,180
<font color="#CCCCCC">their is that</font><font color="#E5E5E5"> we have to look to use 35</font>

335
00:13:41,990 --> 00:13:48,380
times<font color="#E5E5E5"> more queries which is basically</font>

336
00:13:44,180 --> 00:13:52,060
<font color="#CCCCCC">impractical and a final</font><font color="#E5E5E5"> point</font><font color="#CCCCCC"> that I</font>

337
00:13:48,380 --> 00:13:54,380
would<font color="#CCCCCC"> like to say here is basically if</font>

338
00:13:52,060 --> 00:13:56,359
that grammar oriented<font color="#E5E5E5"> filtering</font>

339
00:13:54,380 --> 00:13:58,850
algorithm can be<font color="#CCCCCC"> used in order to</font><font color="#E5E5E5"> evade</font>

340
00:13:56,360 --> 00:14:01,790
web application firewalls<font color="#CCCCCC"> so for that</font>

341
00:13:58,850 --> 00:14:03,920
setting<font color="#CCCCCC"> we handcrafted</font><font color="#E5E5E5"> the grammar with</font>

342
00:14:01,790 --> 00:14:08,360
valid suffixes<font color="#E5E5E5"> of SQL</font><font color="#CCCCCC"> statements so you</font>

343
00:14:03,920 --> 00:14:10,729
can think<font color="#E5E5E5"> of an SQL statement that is</font>

344
00:14:08,360 --> 00:14:13,520
valid<font color="#E5E5E5"> and then what what can we do after</font>

345
00:14:10,730 --> 00:14:15,529
<font color="#CCCCCC">a</font><font color="#E5E5E5"> point</font><font color="#CCCCCC"> to like complete the statement</font>

346
00:14:13,520 --> 00:14:18,160
<font color="#CCCCCC">with valid suffixes and that basically</font>

347
00:14:15,529 --> 00:14:20,899
simulates an SQL<font color="#CCCCCC"> injection attacks</font><font color="#E5E5E5"> and</font>

348
00:14:18,160 --> 00:14:22,819
what we did is that<font color="#CCCCCC"> we tested</font><font color="#E5E5E5"> our</font>

349
00:14:20,899 --> 00:14:24,709
algorithm<font color="#E5E5E5"> against live installation so</font>

350
00:14:22,820 --> 00:14:26,900
we didn't test it against<font color="#E5E5E5"> individual</font>

351
00:14:24,709 --> 00:14:28,640
regular expression filters but against

352
00:14:26,900 --> 00:14:31,310
live installations of<font color="#E5E5E5"> mod</font><font color="#CCCCCC"> security</font><font color="#E5E5E5"> and</font>

353
00:14:28,640 --> 00:14:33,140
PHP ideas which are two<font color="#CCCCCC"> very popular</font><font color="#E5E5E5"> web</font>

354
00:14:31,310 --> 00:14:34,670
application firewalls<font color="#E5E5E5"> and I want to</font>

355
00:14:33,140 --> 00:14:37,400
point out here<font color="#E5E5E5"> that both of these</font>

356
00:14:34,670 --> 00:14:40,550
systems<font color="#E5E5E5"> include</font><font color="#CCCCCC"> non irregular anomaly</font>

357
00:14:37,400 --> 00:14:44,180
detection components so it's not<font color="#CCCCCC"> that we</font>

358
00:14:40,550 --> 00:14:46,160
have a purely<font color="#E5E5E5"> regular system here and we</font>

359
00:14:44,180 --> 00:14:49,130
were<font color="#CCCCCC"> able to find bypasses for</font><font color="#E5E5E5"> both</font>

360
00:14:46,160 --> 00:14:52,969
firewalls we found an authentication

361
00:14:49,130 --> 00:14:55,250
bypass using the like operator<font color="#CCCCCC"> and we</font>

362
00:14:52,970 --> 00:14:59,029
also find an attack which can<font color="#E5E5E5"> be used to</font>

363
00:14:55,250 --> 00:15:00,680
<font color="#E5E5E5">retrieve</font><font color="#CCCCCC"> data and both of these attacks</font>

364
00:14:59,029 --> 00:15:07,339
were acknowledged by<font color="#E5E5E5"> the mod security</font>

365
00:15:00,680 --> 00:15:09,949
team so to conclude<font color="#E5E5E5"> SFA's symbolic</font>

366
00:15:07,339 --> 00:15:12,020
<font color="#CCCCCC">finite automata provide a nice way to</font>

367
00:15:09,950 --> 00:15:15,079
infer regular expression filters by

368
00:15:12,020 --> 00:15:18,649
avoiding<font color="#CCCCCC"> brute</font><font color="#E5E5E5"> forcing transitions while</font>

369
00:15:15,079 --> 00:15:21,859
learning<font color="#CCCCCC"> and</font><font color="#E5E5E5"> also we found</font><font color="#CCCCCC"> out that the</font>

370
00:15:18,649 --> 00:15:24,740
same algorithms can provide insights<font color="#E5E5E5"> for</font>

371
00:15:21,860 --> 00:15:26,930
non regular systems<font color="#E5E5E5"> so while we cannot</font>

372
00:15:24,740 --> 00:15:28,910
so that they can learn these systems

373
00:15:26,930 --> 00:15:31,189
completely<font color="#E5E5E5"> this is impossible</font><font color="#CCCCCC"> if they</font>

374
00:15:28,910 --> 00:15:32,899
are non<font color="#CCCCCC"> irregular they can provide nice</font>

375
00:15:31,190 --> 00:15:36,829
approximations we can which<font color="#CCCCCC"> can</font>

376
00:15:32,899 --> 00:15:38,360
used<font color="#E5E5E5"> for practical attacks also</font><font color="#CCCCCC"> we also</font>

377
00:15:36,829 --> 00:15:39,589
like<font color="#CCCCCC"> to point out again that we have</font>

378
00:15:38,360 --> 00:15:41,990
<font color="#CCCCCC">similar techniques derived for</font>

379
00:15:39,589 --> 00:15:44,149
sanitizers<font color="#CCCCCC"> that is functions that take</font>

380
00:15:41,990 --> 00:15:47,660
the input and convert it to a non

381
00:15:44,149 --> 00:15:49,699
malicious input<font color="#E5E5E5"> and also there is</font><font color="#CCCCCC"> a</font>

382
00:15:47,660 --> 00:15:52,160
large space<font color="#CCCCCC"> for</font><font color="#E5E5E5"> future work in this area</font>

383
00:15:49,699 --> 00:15:54,019
<font color="#CCCCCC">so our garden algorithm the algorithm</font>

384
00:15:52,160 --> 00:15:55,759
<font color="#CCCCCC">that actually learns the transitions is</font>

385
00:15:54,019 --> 00:15:58,100
a very simple heuristic<font color="#E5E5E5"> for regular</font>

386
00:15:55,759 --> 00:15:59,869
<font color="#CCCCCC">expressions and we were able</font><font color="#E5E5E5"> to gain</font>

387
00:15:58,100 --> 00:16:02,449
huge speed<font color="#CCCCCC"> ups this way</font>

388
00:15:59,869 --> 00:16:03,920
however we<font color="#CCCCCC"> believe</font><font color="#E5E5E5"> that there many other</font>

389
00:16:02,449 --> 00:16:07,309
<font color="#CCCCCC">things</font><font color="#E5E5E5"> that one could do in that</font><font color="#CCCCCC"> area</font>

390
00:16:03,920 --> 00:16:10,849
<font color="#CCCCCC">and finally I should</font><font color="#E5E5E5"> say that we</font>

391
00:16:07,309 --> 00:16:13,160
envision the context of<font color="#E5E5E5"> our algorithms</font>

392
00:16:10,850 --> 00:16:16,519
to<font color="#CCCCCC"> be in assisted black</font><font color="#E5E5E5"> box testing</font>

393
00:16:13,160 --> 00:16:18,259
<font color="#E5E5E5">rather than a point-and-shoot tool so</font>

394
00:16:16,519 --> 00:16:21,790
<font color="#E5E5E5">even we are in</font><font color="#CCCCCC"> V</font><font color="#E5E5E5"> attacks that I</font>

395
00:16:18,259 --> 00:16:24,769
presented<font color="#E5E5E5"> we basically obtained an</font>

396
00:16:21,790 --> 00:16:26,509
abstract valid statement in a

397
00:16:24,769 --> 00:16:28,730
context-free grammar<font color="#E5E5E5"> but this then</font>

398
00:16:26,509 --> 00:16:30,290
<font color="#E5E5E5">should be</font><font color="#CCCCCC"> converted in a concrete attack</font>

399
00:16:28,730 --> 00:16:32,990
and<font color="#E5E5E5"> this is something</font><font color="#CCCCCC"> that an auditor</font>

400
00:16:30,290 --> 00:16:35,719
should<font color="#CCCCCC"> do by himself and</font><font color="#E5E5E5"> also we expect</font>

401
00:16:32,990 --> 00:16:37,610
<font color="#CCCCCC">if the models that</font><font color="#E5E5E5"> we are</font><font color="#CCCCCC"> algorithm is</font>

402
00:16:35,720 --> 00:16:40,850
in fair are<font color="#E5E5E5"> inaccurate in case we don't</font>

403
00:16:37,610 --> 00:16:42,410
<font color="#E5E5E5">find and find an attack then we expect</font>

404
00:16:40,850 --> 00:16:44,389
the auditor<font color="#E5E5E5"> to be able</font><font color="#CCCCCC"> to inspect this</font>

405
00:16:42,410 --> 00:16:46,490
models<font color="#E5E5E5"> when they are converted back</font><font color="#CCCCCC"> to</font>

406
00:16:44,389 --> 00:16:48,649
regular<font color="#CCCCCC"> expressions</font><font color="#E5E5E5"> and may be correct</font>

407
00:16:46,490 --> 00:16:51,709
and inaccuracies<font color="#E5E5E5"> and</font><font color="#CCCCCC"> further assist the</font>

408
00:16:48,649 --> 00:16:53,120
algorithm to proceed<font color="#E5E5E5"> and with that I</font>

409
00:16:51,709 --> 00:16:54,888
would<font color="#E5E5E5"> like</font><font color="#CCCCCC"> to thank you all</font><font color="#E5E5E5"> for</font><font color="#CCCCCC"> your</font>

410
00:16:53,120 --> 00:16:58,809
attention<font color="#E5E5E5"> and I</font><font color="#CCCCCC"> will take any questions</font>

411
00:16:54,889 --> 00:16:58,809
now<font color="#CCCCCC"> ok</font>

412
00:17:01,240 --> 00:17:08,900
<font color="#E5E5E5">some questions hello</font>

413
00:17:05,300 --> 00:17:11,000
really interesting<font color="#CCCCCC"> work I'm curious it</font>

414
00:17:08,900 --> 00:17:14,750
seems like some<font color="#E5E5E5"> of your DFAS are quite</font>

415
00:17:11,000 --> 00:17:17,390
small like<font color="#E5E5E5"> 16 20</font><font color="#CCCCCC"> states did you actually</font>

416
00:17:14,750 --> 00:17:19,880
take a look at the model inferred<font color="#E5E5E5"> and</font>

417
00:17:17,390 --> 00:17:22,250
try to determine<font color="#CCCCCC"> if it was</font><font color="#E5E5E5"> being</font>

418
00:17:19,880 --> 00:17:24,910
minimized<font color="#E5E5E5"> or if there's a correspondence</font>

419
00:17:22,250 --> 00:17:27,980
<font color="#CCCCCC">it's a common</font><font color="#E5E5E5"> thing in DFA learning so</font>

420
00:17:24,910 --> 00:17:30,740
this algorithm<font color="#E5E5E5"> basically the DFA and the</font>

421
00:17:27,980 --> 00:17:32,660
<font color="#CCCCCC">SFA learning</font><font color="#E5E5E5"> algorithm they will infer</font>

422
00:17:30,740 --> 00:17:34,520
minimal<font color="#E5E5E5"> automata so the DFA learning</font>

423
00:17:32,660 --> 00:17:37,270
algorithm when it will infer an

424
00:17:34,520 --> 00:17:40,820
<font color="#CCCCCC">automaton an automaton will be minimal</font>

425
00:17:37,270 --> 00:17:42,560
so if you're talking<font color="#E5E5E5"> about the expect so</font>

426
00:17:40,820 --> 00:17:44,450
in our experiment like not in the

427
00:17:42,560 --> 00:17:47,090
grammar oriented filter auditing setting

428
00:17:44,450 --> 00:17:48,740
but in the<font color="#E5E5E5"> original setting we simulated</font>

429
00:17:47,090 --> 00:17:51,050
equivalence queries<font color="#E5E5E5"> to actually count</font>

430
00:17:48,740 --> 00:17:52,550
the total<font color="#CCCCCC"> number of queries used by both</font>

431
00:17:51,050 --> 00:17:54,980
<font color="#E5E5E5">algorithms so at that setting</font><font color="#CCCCCC"> we</font>

432
00:17:52,550 --> 00:17:56,810
actually inferred that<font color="#CCCCCC"> you know</font><font color="#E5E5E5"> we start</font>

433
00:17:54,980 --> 00:17:59,360
whenever we had the<font color="#E5E5E5"> correct hypothesis</font>

434
00:17:56,810 --> 00:18:01,580
so we knew<font color="#CCCCCC"> that the automata infer that</font>

435
00:17:59,360 --> 00:18:04,070
both minimal and correct<font color="#CCCCCC"> I meant more</font>

436
00:18:01,580 --> 00:18:07,159
actually just looking at the regular

437
00:18:04,070 --> 00:18:08,960
<font color="#E5E5E5">looking at the actual picture</font><font color="#CCCCCC"> oh</font><font color="#E5E5E5"> I mean</font>

438
00:18:07,160 --> 00:18:10,760
<font color="#E5E5E5">we did that but for some very small</font>

439
00:18:08,960 --> 00:18:12,620
automata like you know<font color="#CCCCCC"> 10</font><font color="#E5E5E5"> states or</font>

440
00:18:10,760 --> 00:18:14,600
something<font color="#E5E5E5"> like</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> so that's very</font>

441
00:18:12,620 --> 00:18:16,909
usually very simple pattern matching

442
00:18:14,600 --> 00:18:18,980
they<font color="#E5E5E5"> will match a string or something so</font>

443
00:18:16,910 --> 00:18:21,200
what were you what was your<font color="#CCCCCC"> question on</font>

444
00:18:18,980 --> 00:18:22,430
<font color="#CCCCCC">that if they look minimal</font><font color="#E5E5E5"> or if they</font>

445
00:18:21,200 --> 00:18:24,050
look<font color="#E5E5E5"> the</font><font color="#CCCCCC"> same</font><font color="#E5E5E5"> if you're actually</font>

446
00:18:22,430 --> 00:18:25,970
<font color="#E5E5E5">learning the same regular expression</font>

447
00:18:24,050 --> 00:18:28,159
<font color="#CCCCCC">that</font><font color="#E5E5E5"> the person had</font><font color="#CCCCCC"> implemented</font><font color="#E5E5E5"> to do</font>

448
00:18:25,970 --> 00:18:30,140
either sanitization<font color="#E5E5E5"> so we didn't convert</font>

449
00:18:28,160 --> 00:18:31,790
it back to regular<font color="#E5E5E5"> expression we</font><font color="#CCCCCC"> just</font>

450
00:18:30,140 --> 00:18:33,290
<font color="#E5E5E5">learned the automata so if you want to</font>

451
00:18:31,790 --> 00:18:34,700
<font color="#E5E5E5">convert back</font><font color="#CCCCCC"> to a regular expression</font>

452
00:18:33,290 --> 00:18:36,770
that's a different problem<font color="#CCCCCC"> and solves a</font>

453
00:18:34,700 --> 00:18:39,920
hard<font color="#E5E5E5"> problem so you have to address that</font>

454
00:18:36,770 --> 00:18:42,290
<font color="#E5E5E5">you can do it but it might blow</font><font color="#CCCCCC"> up so</font>

455
00:18:39,920 --> 00:18:45,370
<font color="#E5E5E5">learning a minimal</font><font color="#CCCCCC"> irregular expression</font>

456
00:18:42,290 --> 00:18:45,370
is a very hard<font color="#CCCCCC"> problem</font>

