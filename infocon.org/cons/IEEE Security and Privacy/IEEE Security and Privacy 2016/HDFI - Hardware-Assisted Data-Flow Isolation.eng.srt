1
00:00:02,120 --> 00:00:11,149
thanks for the introduction<font color="#E5E5E5"> and hit the</font>

2
00:00:04,970 --> 00:00:13,639
microphone working<font color="#E5E5E5"> okay hello yes so</font>

3
00:00:11,150 --> 00:00:15,769
today I'm going<font color="#CCCCCC"> to introduce Hardware</font><font color="#E5E5E5"> a</font>

4
00:00:13,639 --> 00:00:17,509
<font color="#CCCCCC">City dataflow isolation this</font><font color="#E5E5E5"> is</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> joint</font>

5
00:00:15,769 --> 00:00:20,210
work<font color="#CCCCCC"> with Georgia Tech and the</font><font color="#E5E5E5"> Seoul</font>

6
00:00:17,509 --> 00:00:21,890
<font color="#E5E5E5">National</font><font color="#CCCCCC"> University so in this work</font>

7
00:00:20,210 --> 00:00:24,050
<font color="#CCCCCC">while focusing is memory corruption</font>

8
00:00:21,890 --> 00:00:27,140
vulnerabilities<font color="#E5E5E5"> and due to the</font>

9
00:00:24,050 --> 00:00:29,119
popularity<font color="#E5E5E5"> of</font><font color="#CCCCCC"> CNC prosper programs</font><font color="#E5E5E5"> and</font>

10
00:00:27,140 --> 00:00:31,040
especially<font color="#E5E5E5"> in daily use the large</font>

11
00:00:29,119 --> 00:00:33,380
programs like kernels of browsers

12
00:00:31,040 --> 00:00:34,730
memory<font color="#E5E5E5"> option</font><font color="#CCCCCC"> monopolies is very common</font>

13
00:00:33,380 --> 00:00:37,370
at the same time memory corruption

14
00:00:34,730 --> 00:00:38,870
vulnerability is highly exploitable<font color="#E5E5E5"> they</font>

15
00:00:37,370 --> 00:00:41,809
can<font color="#CCCCCC"> usually lead to arbitrary memory</font>

16
00:00:38,870 --> 00:00:43,998
code execution<font color="#E5E5E5"> so for this reason</font><font color="#CCCCCC"> they</font>

17
00:00:41,809 --> 00:00:46,160
are<font color="#E5E5E5"> one</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> the most widely exploited a</font>

18
00:00:43,999 --> 00:00:48,409
<font color="#E5E5E5">vulnerability type and according</font><font color="#CCCCCC"> to the</font>

19
00:00:46,160 --> 00:00:51,260
status to<font color="#E5E5E5"> get from Microsoft memory</font>

20
00:00:48,409 --> 00:00:54,079
<font color="#CCCCCC">corruption</font><font color="#E5E5E5"> vulnerability is the dominant</font>

21
00:00:51,260 --> 00:00:57,140
root cause for remote code execution on

22
00:00:54,079 --> 00:00:58,519
windows so it's understand how memory

23
00:00:57,140 --> 00:01:01,999
corruption vulnerabilities<font color="#E5E5E5"> can be</font>

24
00:00:58,519 --> 00:01:04,158
exploited<font color="#E5E5E5"> and prevented let's use this</font>

25
00:01:01,999 --> 00:01:07,370
very simple<font color="#CCCCCC"> Stack Overflow example as a</font>

26
00:01:04,159 --> 00:01:11,120
running example<font color="#E5E5E5"> as we can see</font><font color="#CCCCCC"> our the</font>

27
00:01:07,370 --> 00:01:12,950
program<font color="#E5E5E5"> at the left side has a stack</font>

28
00:01:11,120 --> 00:01:15,250
overflow vulnerability and the

29
00:01:12,950 --> 00:01:18,260
<font color="#E5E5E5">corresponding assembly is on the bottom</font>

30
00:01:15,250 --> 00:01:21,110
<font color="#E5E5E5">said at line</font><font color="#CCCCCC"> 2 we allocate a new</font><font color="#E5E5E5"> buffer</font>

31
00:01:18,260 --> 00:01:24,290
<font color="#CCCCCC">and at line 3</font><font color="#E5E5E5"> we'll push the return</font>

32
00:01:21,110 --> 00:01:27,920
address<font color="#E5E5E5"> on</font><font color="#CCCCCC"> the stack at line 6 when we</font>

33
00:01:24,290 --> 00:01:29,510
<font color="#E5E5E5">called the string copy if the passing</font>

34
00:01:27,920 --> 00:01:31,910
argument is large enough<font color="#CCCCCC"> or</font><font color="#E5E5E5"> we can</font>

35
00:01:29,510 --> 00:01:35,210
offload the buffer and<font color="#E5E5E5"> compromise the</font>

36
00:01:31,910 --> 00:01:36,560
return dress and finally if attacker can

37
00:01:35,210 --> 00:01:38,690
control the<font color="#E5E5E5"> return to</font><font color="#CCCCCC"> rest</font><font color="#E5E5E5"> they can</font>

38
00:01:36,560 --> 00:01:40,550
leverage is to launch a variety of

39
00:01:38,690 --> 00:01:42,230
<font color="#E5E5E5">different kind of attack including like</font>

40
00:01:40,550 --> 00:01:45,740
code injection and the return<font color="#CCCCCC"> order</font><font color="#E5E5E5"> to</font>

41
00:01:42,230 --> 00:01:48,110
programming so are there how many

42
00:01:45,740 --> 00:01:50,600
<font color="#E5E5E5">defense mechanism being proposed</font><font color="#CCCCCC"> to</font>

43
00:01:48,110 --> 00:01:52,340
defense<font color="#E5E5E5"> to this kind of attack for</font>

44
00:01:50,600 --> 00:01:53,929
<font color="#CCCCCC">examples</font><font color="#E5E5E5"> the most widely used one is</font>

45
00:01:52,340 --> 00:01:55,670
called stack<font color="#CCCCCC"> guard was that cookie which</font>

46
00:01:53,930 --> 00:01:58,040
<font color="#E5E5E5">inserts a camera value</font><font color="#CCCCCC"> between</font><font color="#E5E5E5"> the</font>

47
00:01:55,670 --> 00:01:59,840
buffer<font color="#CCCCCC"> and the return address so if</font>

48
00:01:58,040 --> 00:02:02,690
<font color="#E5E5E5">awful happens this camera will be</font>

49
00:01:59,840 --> 00:02:06,200
corrupted<font color="#CCCCCC"> and then attack will be</font>

50
00:02:02,690 --> 00:02:08,329
<font color="#CCCCCC">detected</font><font color="#E5E5E5"> unfortunately if attackers can</font>

51
00:02:06,200 --> 00:02:10,640
directly write to any<font color="#E5E5E5"> given value</font><font color="#CCCCCC"> or</font>

52
00:02:08,330 --> 00:02:12,319
address or if there is<font color="#E5E5E5"> an information</font>

53
00:02:10,639 --> 00:02:15,349
leak vulnerability<font color="#CCCCCC"> this</font><font color="#E5E5E5"> defense</font>

54
00:02:12,319 --> 00:02:17,060
mechanism can<font color="#E5E5E5"> be easily bypassed or turn</font>

55
00:02:15,349 --> 00:02:19,010
<font color="#E5E5E5">ative</font><font color="#CCCCCC"> Lee we can also try to encrypt the</font>

56
00:02:17,060 --> 00:02:20,689
return address even if attacker can

57
00:02:19,010 --> 00:02:22,999
compromise<font color="#E5E5E5"> this return address they</font>

58
00:02:20,689 --> 00:02:24,590
cannot control<font color="#E5E5E5"> the decrypted value the</font>

59
00:02:22,999 --> 00:02:26,420
<font color="#E5E5E5">Challenger here is how to do key</font>

60
00:02:24,590 --> 00:02:29,390
management<font color="#E5E5E5"> basically if</font><font color="#CCCCCC"> we ever reuse</font>

61
00:02:26,420 --> 00:02:31,219
the encryption key then the encryption

62
00:02:29,390 --> 00:02:33,920
scheme can be<font color="#CCCCCC"> broken</font><font color="#E5E5E5"> and attacker will</font>

63
00:02:31,219 --> 00:02:36,379
win again finally we can also try<font color="#CCCCCC"> to</font>

64
00:02:33,920 --> 00:02:38,238
relocate the return address to another

65
00:02:36,379 --> 00:02:40,518
stack and isolate to use in<font color="#E5E5E5"> different</font>

66
00:02:38,239 --> 00:02:43,790
approaches including<font color="#E5E5E5"> software based and</font>

67
00:02:40,519 --> 00:02:46,879
the hardware based however this shadow

68
00:02:43,790 --> 00:02:49,069
stack<font color="#E5E5E5"> also has many limitations for</font>

69
00:02:46,879 --> 00:02:52,069
software<font color="#E5E5E5"> based our shadow</font><font color="#CCCCCC"> sects the</font>

70
00:02:49,069 --> 00:02:54,828
major limitation now is that in 64-bit

71
00:02:52,069 --> 00:02:58,638
<font color="#E5E5E5">word will execute isolation mechanism</font>

72
00:02:54,829 --> 00:03:01,700
basically<font color="#E5E5E5"> in the segmentation in x86 is</font>

73
00:02:58,639 --> 00:03:05,480
<font color="#E5E5E5">going in 64-bit and access domain is</font>

74
00:03:01,700 --> 00:03:07,819
<font color="#E5E5E5">also going in 64-bit ARM processors as a</font>

75
00:03:05,480 --> 00:03:09,319
result for<font color="#E5E5E5"> security solutions we</font><font color="#CCCCCC"> have to</font>

76
00:03:07,819 --> 00:03:12,018
choose<font color="#E5E5E5"> between efficiency and the</font>

77
00:03:09,319 --> 00:03:14,779
security so for<font color="#CCCCCC"> solutions that opt for</font>

78
00:03:12,019 --> 00:03:17,090
security such as<font color="#E5E5E5"> using masking or</font>

79
00:03:14,779 --> 00:03:20,120
virtual<font color="#E5E5E5"> trespass isolation they are</font>

80
00:03:17,090 --> 00:03:22,189
secure<font color="#E5E5E5"> but they are slow</font><font color="#CCCCCC"> on</font><font color="#E5E5E5"> the other</font>

81
00:03:20,120 --> 00:03:24,950
hand for solutions<font color="#CCCCCC"> that</font><font color="#E5E5E5"> opt for</font>

82
00:03:22,189 --> 00:03:28,010
<font color="#CCCCCC">efficiencies such as</font><font color="#E5E5E5"> using random based</font>

83
00:03:24,950 --> 00:03:30,589
isolation they are<font color="#E5E5E5"> efficient but has</font>

84
00:03:28,010 --> 00:03:32,328
been proven<font color="#E5E5E5"> to be broken</font><font color="#CCCCCC"> for hardware</font>

85
00:03:30,590 --> 00:03:35,919
based the shadow<font color="#CCCCCC"> stacks the problem is</font>

86
00:03:32,329 --> 00:03:38,180
flexibility<font color="#E5E5E5"> so existing or proposed</font>

87
00:03:35,919 --> 00:03:39,769
<font color="#E5E5E5">hardware</font><font color="#CCCCCC"> based the shadow stack has</font>

88
00:03:38,180 --> 00:03:40,909
problem supporting features like a

89
00:03:39,769 --> 00:03:43,489
second plant jump

90
00:03:40,909 --> 00:03:46,578
<font color="#E5E5E5">deep recursing and sometimes kernel</font>

91
00:03:43,489 --> 00:03:48,980
stacks<font color="#E5E5E5"> and because they are specialized</font>

92
00:03:46,579 --> 00:03:52,730
<font color="#CCCCCC">to</font><font color="#E5E5E5"> protect only the return address</font><font color="#CCCCCC"> it's</font>

93
00:03:48,980 --> 00:03:54,679
very hard for<font color="#CCCCCC"> them to read you utilize</font>

94
00:03:52,730 --> 00:03:59,659
them<font color="#E5E5E5"> to protect other types of data such</font>

95
00:03:54,680 --> 00:04:01,909
<font color="#E5E5E5">as other pointers or non control data in</font>

96
00:03:59,659 --> 00:04:04,129
<font color="#E5E5E5">addition</font><font color="#CCCCCC"> the data shattering itself</font><font color="#E5E5E5"> also</font>

97
00:04:01,909 --> 00:04:05,480
at the additional overhead<font color="#CCCCCC"> it</font><font color="#E5E5E5"> breaks the</font>

98
00:04:04,129 --> 00:04:07,340
data locality

99
00:04:05,480 --> 00:04:09,469
<font color="#E5E5E5">requires additional steps to look up the</font>

100
00:04:07,340 --> 00:04:11,629
shadow data<font color="#E5E5E5"> all across</font><font color="#CCCCCC"> reserved</font>

101
00:04:09,469 --> 00:04:14,689
<font color="#E5E5E5">registers at the same time there</font><font color="#CCCCCC"> is</font><font color="#E5E5E5"> an</font>

102
00:04:11,629 --> 00:04:16,849
unavoidable<font color="#E5E5E5"> memory overhead so to</font>

103
00:04:14,689 --> 00:04:19,279
<font color="#E5E5E5">overcome these limitations we propose</font>

104
00:04:16,850 --> 00:04:21,919
<font color="#CCCCCC">each dfi as a hard well enforced</font>

105
00:04:19,279 --> 00:04:24,409
isolation mechanism<font color="#CCCCCC"> hdf is both secure</font>

106
00:04:21,918 --> 00:04:26,389
<font color="#CCCCCC">and efficient</font><font color="#E5E5E5"> at the same time we</font>

107
00:04:24,410 --> 00:04:27,810
designed to be a generic<font color="#E5E5E5"> our data</font>

108
00:04:26,389 --> 00:04:30,090
isolation mechanisms

109
00:04:27,810 --> 00:04:32,250
it's very<font color="#E5E5E5"> flexible and as showing our</font>

110
00:04:30,090 --> 00:04:34,229
paper we can<font color="#E5E5E5"> utilize the interview the</font>

111
00:04:32,250 --> 00:04:38,100
different kinds of security model and

112
00:04:34,230 --> 00:04:40,230
applications we<font color="#E5E5E5"> also</font><font color="#CCCCCC"> designs TFI to be</font>

113
00:04:38,100 --> 00:04:43,440
fine grandma says really<font color="#CCCCCC"> eliminates as a</font>

114
00:04:40,230 --> 00:04:47,100
<font color="#E5E5E5">need</font><font color="#CCCCCC"> for data chattering finally to ease</font>

115
00:04:43,440 --> 00:04:48,900
the<font color="#E5E5E5"> adoption in practice we try</font><font color="#CCCCCC"> to turn</font>

116
00:04:47,100 --> 00:04:53,010
our design also<font color="#E5E5E5"> try to minimize</font><font color="#CCCCCC"> the</font>

117
00:04:48,900 --> 00:04:55,289
hardware changes so<font color="#CCCCCC"> hdf</font><font color="#E5E5E5"> is inspired by</font>

118
00:04:53,010 --> 00:04:58,440
<font color="#E5E5E5">the data flow</font><font color="#CCCCCC"> integral work published in</font>

119
00:04:55,290 --> 00:05:00,389
USD l6 base is<font color="#E5E5E5"> similar to control flow</font>

120
00:04:58,440 --> 00:05:02,700
integrity our data flow integrity

121
00:05:00,389 --> 00:05:05,370
enforces the runtime data flow should

122
00:05:02,700 --> 00:05:08,250
not<font color="#CCCCCC"> deviate from</font><font color="#E5E5E5"> the model generated</font>

123
00:05:05,370 --> 00:05:10,950
from static analysis to enforce<font color="#CCCCCC"> that d</font>

124
00:05:08,250 --> 00:05:13,979
fi first assigns every<font color="#E5E5E5"> right instruction</font>

125
00:05:10,950 --> 00:05:17,250
<font color="#E5E5E5">ID and then it extends the memory model</font>

126
00:05:13,979 --> 00:05:19,020
to record the idea<font color="#E5E5E5"> of</font><font color="#CCCCCC"> last writer for</font>

127
00:05:17,250 --> 00:05:21,389
example if when we push<font color="#CCCCCC"> the return</font>

128
00:05:19,020 --> 00:05:23,549
address<font color="#CCCCCC"> on</font><font color="#E5E5E5"> to the stack we will modify</font>

129
00:05:21,389 --> 00:05:27,389
the croissant attack to record the last

130
00:05:23,550 --> 00:05:29,310
writer is<font color="#CCCCCC"> say line 3 and</font><font color="#E5E5E5"> if there is a</font>

131
00:05:27,389 --> 00:05:34,560
<font color="#CCCCCC">buffer overflow</font><font color="#E5E5E5"> happens</font><font color="#CCCCCC"> we were</font><font color="#E5E5E5"> record</font>

132
00:05:29,310 --> 00:05:38,880
<font color="#E5E5E5">that</font><font color="#CCCCCC"> other</font><font color="#E5E5E5"> pod</font><font color="#CCCCCC"> the last right</font><font color="#E5E5E5"> actually</font>

133
00:05:34,560 --> 00:05:40,440
<font color="#CCCCCC">the</font><font color="#E5E5E5"> line 6 sorry for and then at</font><font color="#CCCCCC"> every</font>

134
00:05:38,880 --> 00:05:42,719
load instruction we<font color="#CCCCCC"> will check whether</font>

135
00:05:40,440 --> 00:05:45,930
<font color="#CCCCCC">the</font><font color="#E5E5E5"> last writer is within the allowed</font>

136
00:05:42,720 --> 00:05:48,060
set for<font color="#E5E5E5"> example in this example the</font><font color="#CCCCCC"> only</font>

137
00:05:45,930 --> 00:05:50,070
a lot of<font color="#E5E5E5"> right instructions that</font><font color="#CCCCCC"> to over</font>

138
00:05:48,060 --> 00:05:52,860
<font color="#CCCCCC">to write the</font><font color="#E5E5E5"> retail address would be</font>

139
00:05:50,070 --> 00:05:54,570
<font color="#CCCCCC">lined sweet and if overflow happens</font><font color="#E5E5E5"> we</font>

140
00:05:52,860 --> 00:05:56,729
<font color="#E5E5E5">would detect that and the exception will</font>

141
00:05:54,570 --> 00:05:57,889
<font color="#CCCCCC">be generated and</font><font color="#E5E5E5"> the attack will be</font>

142
00:05:56,729 --> 00:06:00,810
<font color="#E5E5E5">prevented</font>

143
00:05:57,889 --> 00:06:03,479
so<font color="#E5E5E5"> each</font><font color="#CCCCCC"> TFI includes two parts of</font>

144
00:06:00,810 --> 00:06:05,100
extensions first<font color="#E5E5E5"> is I see extensions so</font>

145
00:06:03,479 --> 00:06:07,590
we extend is a memory model to include

146
00:06:05,100 --> 00:06:10,740
<font color="#E5E5E5">for one additional attack for every</font>

147
00:06:07,590 --> 00:06:13,859
<font color="#CCCCCC">machine word however</font><font color="#E5E5E5"> instead of trying</font>

148
00:06:10,740 --> 00:06:16,320
to support<font color="#E5E5E5"> arbitrary length of tag we</font>

149
00:06:13,860 --> 00:06:19,229
<font color="#E5E5E5">only</font><font color="#CCCCCC"> for we found that in real</font>

150
00:06:16,320 --> 00:06:20,669
applications<font color="#E5E5E5"> one</font><font color="#CCCCCC"> P</font><font color="#E5E5E5"> attack is enough so</font>

151
00:06:19,229 --> 00:06:22,830
<font color="#CCCCCC">our company implementation we only</font>

152
00:06:20,669 --> 00:06:24,810
support won't be attack<font color="#CCCCCC"> we also are</font>

153
00:06:22,830 --> 00:06:27,389
introduced<font color="#CCCCCC"> the three new instructions to</font>

154
00:06:24,810 --> 00:06:29,130
manipulate and<font color="#CCCCCC"> chaffed attack store</font><font color="#E5E5E5"> and</font>

155
00:06:27,389 --> 00:06:31,380
set<font color="#E5E5E5"> one</font><font color="#CCCCCC"> are we all store value to the</font>

156
00:06:29,130 --> 00:06:33,360
memory and<font color="#E5E5E5"> autonomically</font><font color="#CCCCCC"> steps attack to</font>

157
00:06:31,380 --> 00:06:35,190
one load and check<font color="#CCCCCC"> 0 a check if the</font>

158
00:06:33,360 --> 00:06:37,650
<font color="#CCCCCC">attack is 0 and load</font><font color="#E5E5E5"> and check</font><font color="#CCCCCC"> 1 will</font>

159
00:06:35,190 --> 00:06:40,590
check if<font color="#E5E5E5"> the</font><font color="#CCCCCC"> tag is 1 so we don't</font><font color="#E5E5E5"> have</font>

160
00:06:37,650 --> 00:06:41,549
explicit<font color="#E5E5E5"> our load</font><font color="#CCCCCC"> and store</font><font color="#E5E5E5"> and set to 0</font>

161
00:06:40,590 --> 00:06:43,799
instruction<font color="#E5E5E5"> in</font>

162
00:06:41,550 --> 00:06:46,080
we modified<font color="#CCCCCC"> the traditional</font><font color="#E5E5E5"> original</font>

163
00:06:43,800 --> 00:06:48,390
<font color="#CCCCCC">store instruction to</font><font color="#E5E5E5"> impress three</font><font color="#CCCCCC"> sets</font>

164
00:06:46,080 --> 00:06:49,680
<font color="#E5E5E5">attack to zero and</font><font color="#CCCCCC"> for loading</font>

165
00:06:48,390 --> 00:06:51,750
instruction we didn't change any

166
00:06:49,680 --> 00:06:55,680
semantic it so we can<font color="#CCCCCC"> be backward</font>

167
00:06:51,750 --> 00:06:58,500
<font color="#CCCCCC">compatible with existing boundaries so</font>

168
00:06:55,680 --> 00:07:00,420
<font color="#CCCCCC">hardware</font><font color="#E5E5E5"> our extensions our main</font>

169
00:06:58,500 --> 00:07:02,400
modification is between the main

170
00:07:00,420 --> 00:07:04,320
processor<font color="#E5E5E5"> crawl and the external memory</font>

171
00:07:02,400 --> 00:07:07,710
<font color="#E5E5E5">we extended the cache</font><font color="#CCCCCC"> line to include</font>

172
00:07:04,320 --> 00:07:09,980
<font color="#CCCCCC">additional attack bits so as to</font><font color="#E5E5E5"> support</font>

173
00:07:07,710 --> 00:07:13,710
our new instructions and reuse existing

174
00:07:09,980 --> 00:07:16,500
<font color="#CCCCCC">category coherent inter connect and well</font>

175
00:07:13,710 --> 00:07:20,520
because we cannot extend tag to memory

176
00:07:16,500 --> 00:07:23,340
<font color="#CCCCCC">which is</font><font color="#E5E5E5"> DRM we also basically</font><font color="#CCCCCC"> store</font><font color="#E5E5E5"> all</font>

177
00:07:20,520 --> 00:07:25,200
the<font color="#CCCCCC"> tack we're seeing a big bitmap</font>

178
00:07:23,340 --> 00:07:28,200
called tag table and<font color="#CCCCCC"> introduced this</font>

179
00:07:25,200 --> 00:07:30,030
memory tagger to duplex<font color="#CCCCCC"> the memory</font>

180
00:07:28,200 --> 00:07:33,420
<font color="#E5E5E5">access to be one date access and one</font>

181
00:07:30,030 --> 00:07:36,840
<font color="#CCCCCC">tack access however</font><font color="#E5E5E5"> if we naively</font>

182
00:07:33,420 --> 00:07:38,550
implement this<font color="#E5E5E5"> it will introduce to high</font>

183
00:07:36,840 --> 00:07:41,280
performance<font color="#CCCCCC"> overhead because we</font><font color="#E5E5E5"> doubled</font>

184
00:07:38,550 --> 00:07:43,440
the<font color="#E5E5E5"> memory access to reduce the overhead</font>

185
00:07:41,280 --> 00:07:45,330
to introduce three<font color="#E5E5E5"> optimization</font>

186
00:07:43,440 --> 00:07:47,940
<font color="#E5E5E5">techniques first is</font><font color="#CCCCCC"> we introduced the</font>

187
00:07:45,330 --> 00:07:51,150
tag cache in<font color="#E5E5E5"> the memory tagger to it so</font>

188
00:07:47,940 --> 00:07:53,640
as to exploit the locality<font color="#CCCCCC"> of memory</font>

189
00:07:51,150 --> 00:07:55,830
access the second one is called<font color="#E5E5E5"> attack</font>

190
00:07:53,640 --> 00:07:58,560
value<font color="#CCCCCC"> pit</font><font color="#E5E5E5"> it's based on the observation</font>

191
00:07:55,830 --> 00:08:00,060
that<font color="#E5E5E5"> in during normal executions most</font>

192
00:07:58,560 --> 00:08:02,520
loading<font color="#E5E5E5"> instruction will not check the</font>

193
00:08:00,060 --> 00:08:05,010
<font color="#CCCCCC">tag so when we refuelings a cache line</font>

194
00:08:02,520 --> 00:08:08,099
we don't<font color="#E5E5E5"> always needs</font><font color="#CCCCCC"> to fill up with a</font>

195
00:08:05,010 --> 00:08:10,260
valid attack and the last one is called

196
00:08:08,100 --> 00:08:12,000
the<font color="#E5E5E5"> meta tag table this based on top</font>

197
00:08:10,260 --> 00:08:15,240
<font color="#CCCCCC">observation that the only normal</font>

198
00:08:12,000 --> 00:08:18,150
<font color="#E5E5E5">experience of the beats in detectable</font>

199
00:08:15,240 --> 00:08:20,490
will actually be<font color="#CCCCCC"> zero</font><font color="#E5E5E5"> so if the the line</font>

200
00:08:18,150 --> 00:08:22,859
of the<font color="#E5E5E5"> tag table is or</font><font color="#CCCCCC"> zero we will</font><font color="#E5E5E5"> just</font>

201
00:08:20,490 --> 00:08:26,670
don't load it from the<font color="#CCCCCC"> memory or don't</font>

202
00:08:22,860 --> 00:08:28,050
rewrite it back to memory so<font color="#CCCCCC"> having</font><font color="#E5E5E5"> this</font>

203
00:08:26,670 --> 00:08:30,600
new feature that<font color="#CCCCCC"> let's go back to our</font>

204
00:08:28,050 --> 00:08:32,400
<font color="#E5E5E5">stack overflow example and see</font><font color="#CCCCCC"> how we</font>

205
00:08:30,600 --> 00:08:34,890
can<font color="#CCCCCC"> use this</font><font color="#E5E5E5"> terrify to defeat the</font>

206
00:08:32,400 --> 00:08:37,140
attack the<font color="#E5E5E5"> implementation is</font><font color="#CCCCCC"> actually</font>

207
00:08:34,890 --> 00:08:38,760
quite<font color="#CCCCCC"> simple we just enforce one simple</font>

208
00:08:37,140 --> 00:08:41,939
<font color="#E5E5E5">policy that is the return address should</font>

209
00:08:38,760 --> 00:08:44,069
always be<font color="#CCCCCC"> half tech zero</font><font color="#E5E5E5"> and this can be</font>

210
00:08:41,940 --> 00:08:46,230
easily<font color="#E5E5E5"> enforced by using as the set</font><font color="#CCCCCC"> 1 to</font>

211
00:08:44,070 --> 00:08:48,770
<font color="#E5E5E5">store the return address to memory and</font>

212
00:08:46,230 --> 00:08:50,820
when loading it always<font color="#E5E5E5"> use</font><font color="#CCCCCC"> LD check 1</font>

213
00:08:48,770 --> 00:08:52,920
compared to existing hardware based

214
00:08:50,820 --> 00:08:54,870
shadow stack our implementation<font color="#E5E5E5"> is very</font>

215
00:08:52,920 --> 00:08:55,349
<font color="#E5E5E5">simple and it's</font><font color="#CCCCCC"> very flexible can</font>

216
00:08:54,870 --> 00:08:57,630
support

217
00:08:55,350 --> 00:08:59,670
all these features<font color="#CCCCCC"> like</font><font color="#E5E5E5"> contacts</font><font color="#CCCCCC"> saving</font>

218
00:08:57,630 --> 00:09:02,430
<font color="#E5E5E5">restoring deeper</font><font color="#CCCCCC"> christian modified the</font>

219
00:08:59,670 --> 00:09:04,680
return address and<font color="#E5E5E5"> the kernel stack so</font>

220
00:09:02,430 --> 00:09:07,319
<font color="#CCCCCC">besides a returns protection to</font>

221
00:09:04,680 --> 00:09:09,780
<font color="#E5E5E5">demonstrate the flexibility of</font><font color="#CCCCCC"> hcf i</font><font color="#E5E5E5"> way</font>

222
00:09:07,320 --> 00:09:12,390
<font color="#E5E5E5">also implemented the</font><font color="#CCCCCC"> rights of other</font>

223
00:09:09,780 --> 00:09:14,550
security applications including<font color="#E5E5E5"> our</font>

224
00:09:12,390 --> 00:09:16,439
<font color="#CCCCCC">vtable protection and code</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> pointer</font>

225
00:09:14,550 --> 00:09:19,439
separation which protected the control

226
00:09:16,440 --> 00:09:21,720
data<font color="#E5E5E5"> and standardized a library</font>

227
00:09:19,440 --> 00:09:24,030
<font color="#CCCCCC">enhancement and the data are on the</font>

228
00:09:21,720 --> 00:09:26,280
<font color="#CCCCCC">colonel protection we protected our the</font>

229
00:09:24,030 --> 00:09:27,750
<font color="#E5E5E5">integrity of non control data we also</font>

230
00:09:26,280 --> 00:09:30,300
have one<font color="#E5E5E5"> demonstration</font><font color="#CCCCCC"> and how</font><font color="#E5E5E5"> to</font>

231
00:09:27,750 --> 00:09:32,670
utilize<font color="#E5E5E5"> its terrified to prevent</font>

232
00:09:30,300 --> 00:09:39,420
<font color="#E5E5E5">information</font><font color="#CCCCCC"> leaks such as the heartbleed</font>

233
00:09:32,670 --> 00:09:42,030
attack<font color="#E5E5E5"> so we implemented</font><font color="#CCCCCC"> HD fi based on</font>

234
00:09:39,420 --> 00:09:43,829
<font color="#E5E5E5">a risk 5 rocket code generator with</font>

235
00:09:42,030 --> 00:09:48,470
about two hundred<font color="#E5E5E5"> and two thousand lines</font>

236
00:09:43,830 --> 00:09:50,880
of code<font color="#E5E5E5"> and instantiate it on the</font><font color="#CCCCCC"> xenyx</font>

237
00:09:48,470 --> 00:09:52,740
fpga board for evaluation for the

238
00:09:50,880 --> 00:09:55,200
<font color="#E5E5E5">software side we modify the to chain to</font>

239
00:09:52,740 --> 00:09:57,870
recognize our new instructions and hand

240
00:09:55,200 --> 00:09:59,520
our new exceptions<font color="#E5E5E5"> and for security</font>

241
00:09:57,870 --> 00:10:03,960
applications the implementation is quite

242
00:09:59,520 --> 00:10:06,240
simple<font color="#CCCCCC"> i were talk</font><font color="#E5E5E5"> more later</font><font color="#CCCCCC"> so for</font>

243
00:10:03,960 --> 00:10:08,610
evaluation we focused on three parts the

244
00:10:06,240 --> 00:10:11,760
first part<font color="#E5E5E5"> is the</font><font color="#CCCCCC"> effect needs</font><font color="#E5E5E5"> of our of</font>

245
00:10:08,610 --> 00:10:14,520
our optimizations<font color="#CCCCCC"> as shown in</font><font color="#E5E5E5"> this table</font>

246
00:10:11,760 --> 00:10:16,260
<font color="#E5E5E5">when combining all three optimizations</font>

247
00:10:14,520 --> 00:10:17,819
the runtime performance overhead

248
00:10:16,260 --> 00:10:20,100
introduced by this<font color="#E5E5E5"> new heart</font><font color="#CCCCCC"> of each</font>

249
00:10:17,820 --> 00:10:24,540
hardware feature<font color="#E5E5E5"> ESP is actually</font><font color="#CCCCCC"> in</font>

250
00:10:20,100 --> 00:10:27,150
negligible<font color="#E5E5E5"> at the second in second</font>

251
00:10:24,540 --> 00:10:29,910
evaluation we are very<font color="#E5E5E5"> the security</font>

252
00:10:27,150 --> 00:10:32,880
mechanism<font color="#E5E5E5"> we build with some synthesized</font>

253
00:10:29,910 --> 00:10:36,800
attack way<font color="#E5E5E5"> beaut and as radar shows so</font>

254
00:10:32,880 --> 00:10:39,630
we cannot defeat all these<font color="#E5E5E5"> attacks</font>

255
00:10:36,800 --> 00:10:41,729
finally and<font color="#E5E5E5"> most importantly we</font><font color="#CCCCCC"> evaluate</font>

256
00:10:39,630 --> 00:10:43,860
how<font color="#CCCCCC"> each dfi can change existing</font>

257
00:10:41,730 --> 00:10:46,500
security solutions from<font color="#CCCCCC"> our</font><font color="#E5E5E5"> fourth</font>

258
00:10:43,860 --> 00:10:49,140
aspects<font color="#E5E5E5"> firstly security so basically</font>

259
00:10:46,500 --> 00:10:53,390
being<font color="#CCCCCC"> hardware and</font><font color="#E5E5E5"> forced isolation</font>

260
00:10:49,140 --> 00:10:57,090
mechanism<font color="#CCCCCC"> or the security guarantee</font>

261
00:10:53,390 --> 00:10:59,220
<font color="#CCCCCC">based on hdf</font><font color="#E5E5E5"> is much better than most of</font>

262
00:10:57,090 --> 00:11:01,890
the pure software<font color="#CCCCCC"> piece that our</font>

263
00:10:59,220 --> 00:11:04,620
isolation<font color="#E5E5E5"> mechanism the cinema is the</font>

264
00:11:01,890 --> 00:11:05,910
simplicity<font color="#E5E5E5"> basically by eliminating the</font>

265
00:11:04,620 --> 00:11:08,580
<font color="#CCCCCC">need for data shadowing</font>

266
00:11:05,910 --> 00:11:09,000
this<font color="#E5E5E5"> application build upon</font><font color="#CCCCCC"> HTF is much</font>

267
00:11:08,580 --> 00:11:11,430
simpler

268
00:11:09,000 --> 00:11:14,040
for example our<font color="#E5E5E5"> return address</font>

269
00:11:11,430 --> 00:11:15,420
protections application is way simpler

270
00:11:14,040 --> 00:11:18,120
than existing shadow stack

271
00:11:15,420 --> 00:11:21,000
implementations<font color="#CCCCCC"> and the third why's our</font>

272
00:11:18,120 --> 00:11:23,300
usability<font color="#E5E5E5"> what</font><font color="#CCCCCC"> you very evaluate it how</font>

273
00:11:21,000 --> 00:11:28,079
easy<font color="#E5E5E5"> it is to implement a new or</font>

274
00:11:23,300 --> 00:11:31,378
existing<font color="#CCCCCC"> a port existing security</font>

275
00:11:28,079 --> 00:11:34,349
solution<font color="#E5E5E5"> to to PhD</font><font color="#CCCCCC"> fi based assuming the</font>

276
00:11:31,379 --> 00:11:36,060
table the effort is quite minimal<font color="#CCCCCC"> so for</font>

277
00:11:34,350 --> 00:11:38,670
<font color="#E5E5E5">example to implement shadow stack way</font>

278
00:11:36,060 --> 00:11:43,949
only<font color="#E5E5E5"> like modified the four lines of</font>

279
00:11:38,670 --> 00:11:47,819
<font color="#CCCCCC">coding</font><font color="#E5E5E5"> LVM</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> etc finally also</font>

280
00:11:43,949 --> 00:11:49,740
<font color="#E5E5E5">evaluated the efficiency of hdf5 based</font>

281
00:11:47,819 --> 00:11:52,680
solutions and and we can<font color="#E5E5E5"> see</font><font color="#CCCCCC"> the</font>

282
00:11:49,740 --> 00:11:54,680
performance<font color="#E5E5E5"> number</font><font color="#CCCCCC"> is</font><font color="#E5E5E5"> quite good the</font>

283
00:11:52,680 --> 00:11:57,149
only<font color="#E5E5E5"> exception is Fortran based</font>

284
00:11:54,680 --> 00:11:59,638
solutions because<font color="#CCCCCC"> of</font><font color="#E5E5E5"> the immaturity of</font>

285
00:11:57,149 --> 00:12:02,490
<font color="#E5E5E5">the current to chain we can</font><font color="#CCCCCC"> only</font><font color="#E5E5E5"> compile</font>

286
00:11:59,639 --> 00:12:05,220
<font color="#E5E5E5">with zero and the being order execution</font>

287
00:12:02,490 --> 00:12:06,750
<font color="#CCCCCC">our core</font><font color="#E5E5E5"> it's were quite sensitive our</font>

288
00:12:05,220 --> 00:12:11,100
current implementation is very<font color="#E5E5E5"> sensitive</font>

289
00:12:06,750 --> 00:12:14,779
to<font color="#E5E5E5"> compiler optimizations that we all</font>

290
00:12:11,100 --> 00:12:14,779
and any questions

291
00:12:20,509 --> 00:12:24,049
any questions

292
00:12:29,380 --> 00:12:36,910
can hear me<font color="#E5E5E5"> yes thank you</font><font color="#CCCCCC"> I agree this</font>

293
00:12:33,580 --> 00:12:38,560
<font color="#CCCCCC">would</font><font color="#E5E5E5"> work really great for x86 but in a</font>

294
00:12:36,910 --> 00:12:41,620
more modern<font color="#E5E5E5"> instruction set like arm</font>

295
00:12:38,560 --> 00:12:43,750
<font color="#E5E5E5">many return addresses never find their</font>

296
00:12:41,620 --> 00:12:46,540
way to memory<font color="#E5E5E5"> they sit in the link</font>

297
00:12:43,750 --> 00:12:48,970
registers can you protect those as well

298
00:12:46,540 --> 00:12:50,980
<font color="#E5E5E5">oh yes I think our economy</font>

299
00:12:48,970 --> 00:12:54,550
implementation actually<font color="#E5E5E5"> based on risk</font>

300
00:12:50,980 --> 00:12:56,050
based architecture<font color="#E5E5E5"> so that's probably</font>

301
00:12:54,550 --> 00:12:58,060
<font color="#E5E5E5">you didn't know this stuff but</font><font color="#CCCCCC"> actually</font>

302
00:12:56,050 --> 00:13:00,400
<font color="#CCCCCC">in the example we showed the stack</font>

303
00:12:58,060 --> 00:13:04,209
overflow<font color="#CCCCCC"> well using the stack is</font>

304
00:13:00,400 --> 00:13:08,260
starting to the memory using a<font color="#E5E5E5"> st-link</font>

305
00:13:04,210 --> 00:13:10,930
<font color="#CCCCCC">register to</font><font color="#E5E5E5"> the stack</font><font color="#CCCCCC"> so actually we can</font>

306
00:13:08,260 --> 00:13:13,120
actually<font color="#E5E5E5"> this our our card invitation</font>

307
00:13:10,930 --> 00:13:16,000
actually is more like arm and<font color="#CCCCCC"> risk-based</font>

308
00:13:13,120 --> 00:13:23,440
and often<font color="#CCCCCC"> using Pusha</font><font color="#E5E5E5"> using</font><font color="#CCCCCC"> our call</font><font color="#E5E5E5"> and</font>

309
00:13:16,000 --> 00:13:25,270
like written very well<font color="#E5E5E5"> so we function on</font>

310
00:13:23,440 --> 00:13:28,990
an instruction set with a link register

311
00:13:25,270 --> 00:13:31,540
never stores the return<font color="#E5E5E5"> address but once</font>

312
00:13:28,990 --> 00:13:33,820
you have like link<font color="#CCCCCC"> register is</font><font color="#E5E5E5"> that you</font>

313
00:13:31,540 --> 00:13:35,620
when<font color="#E5E5E5"> you call you you put the return</font>

314
00:13:33,820 --> 00:13:37,690
address into the<font color="#E5E5E5"> link register but if we</font>

315
00:13:35,620 --> 00:13:39,670
have<font color="#CCCCCC"> an if you're not the tail call if</font>

316
00:13:37,690 --> 00:13:41,530
<font color="#E5E5E5">you're not in the last call right if you</font>

317
00:13:39,670 --> 00:13:44,170
have to call again<font color="#E5E5E5"> right the link</font>

318
00:13:41,530 --> 00:13:45,730
register then will be modified<font color="#E5E5E5"> so before</font>

319
00:13:44,170 --> 00:13:47,860
that<font color="#E5E5E5"> call use do you have to push</font><font color="#CCCCCC"> any</font>

320
00:13:45,730 --> 00:13:49,840
<font color="#E5E5E5">credits down to the reality of dynamic</font>

321
00:13:47,860 --> 00:13:54,870
execution<font color="#E5E5E5"> is everything's in a leaf</font>

322
00:13:49,840 --> 00:13:58,120
function that's where the dynamic I I<font color="#E5E5E5"> I</font>

323
00:13:54,870 --> 00:13:59,830
think<font color="#E5E5E5"> I couldn't agree with</font><font color="#CCCCCC"> that based</font>

324
00:13:58,120 --> 00:14:02,470
on<font color="#CCCCCC"> my experience and all the programs</font>

325
00:13:59,830 --> 00:14:05,080
<font color="#E5E5E5">are compiled</font><font color="#CCCCCC"> or</font><font color="#E5E5E5"> tested they</font><font color="#CCCCCC"> always say</font>

326
00:14:02,470 --> 00:14:07,390
<font color="#CCCCCC">blink registers</font><font color="#E5E5E5"> to the</font><font color="#CCCCCC"> static if they</font>

327
00:14:05,080 --> 00:14:08,860
call additional functions<font color="#E5E5E5"> but most of</font>

328
00:14:07,390 --> 00:14:10,290
the time is in<font color="#CCCCCC"> the lead functions</font>

329
00:14:08,860 --> 00:14:12,690
otherwise you'd be calling functions

330
00:14:10,290 --> 00:14:17,699
more than you would<font color="#E5E5E5"> be executing yes</font>

331
00:14:12,690 --> 00:14:21,630
yeah yeah thank you on this<font color="#E5E5E5"> side</font>

332
00:14:17,700 --> 00:14:23,590
<font color="#CCCCCC">question yeah</font><font color="#E5E5E5"> so where does</font><font color="#CCCCCC"> your</font>

333
00:14:21,630 --> 00:14:25,090
overhead come from I wasn't quite<font color="#E5E5E5"> sure</font>

334
00:14:23,590 --> 00:14:27,310
where you're<font color="#CCCCCC"> generating all this</font>

335
00:14:25,090 --> 00:14:29,020
performance overhead so<font color="#E5E5E5"> are the</font>

336
00:14:27,310 --> 00:14:31,660
performance over<font color="#E5E5E5"> here</font><font color="#CCCCCC"> days compared to</font>

337
00:14:29,020 --> 00:14:33,610
<font color="#CCCCCC">the unmodified</font><font color="#E5E5E5"> hardware so because</font><font color="#CCCCCC"> in</font>

338
00:14:31,660 --> 00:14:35,620
this new<font color="#E5E5E5"> hardware we need to fetch</font><font color="#CCCCCC"> two</font>

339
00:14:33,610 --> 00:14:37,510
for example<font color="#E5E5E5"> especially we need to fetch</font>

340
00:14:35,620 --> 00:14:40,330
the additional attack bit from the<font color="#E5E5E5"> tag</font>

341
00:14:37,510 --> 00:14:41,800
table so that's<font color="#E5E5E5"> the the man over here we</font>

342
00:14:40,330 --> 00:14:43,320
<font color="#CCCCCC">are the men</font><font color="#E5E5E5"> over here comes from because</font>

343
00:14:41,800 --> 00:14:46,719
we cannot<font color="#E5E5E5"> have</font>

344
00:14:43,320 --> 00:14:48,639
<font color="#E5E5E5">the</font><font color="#CCCCCC"> deer em to</font><font color="#E5E5E5"> be</font><font color="#CCCCCC"> tact</font><font color="#E5E5E5"> so for every</font>

345
00:14:46,720 --> 00:14:55,870
memory<font color="#E5E5E5"> obsess that we have to duplicate</font>

346
00:14:48,639 --> 00:14:58,029
<font color="#CCCCCC">this memories</font><font color="#E5E5E5"> sauce off overhead yes so</font>

347
00:14:55,870 --> 00:15:00,790
on<font color="#E5E5E5"> your slides you said you gave a</font>

348
00:14:58,029 --> 00:15:03,149
number<font color="#CCCCCC"> of different uses that this extra</font>

349
00:15:00,790 --> 00:15:05,500
take bit can be<font color="#E5E5E5"> used for yes</font><font color="#CCCCCC"> are</font><font color="#E5E5E5"> those</font>

350
00:15:03,149 --> 00:15:10,029
uses actually compatible<font color="#CCCCCC"> with each other</font>

351
00:15:05,500 --> 00:15:13,990
<font color="#E5E5E5">and if not then how do you deal with the</font>

352
00:15:10,029 --> 00:15:15,639
fact<font color="#E5E5E5"> that one and compile might be used</font>

353
00:15:13,990 --> 00:15:17,680
to<font color="#E5E5E5"> take bit for one purpose and</font><font color="#CCCCCC"> then</font>

354
00:15:15,639 --> 00:15:20,699
some other bit<font color="#E5E5E5"> of code is compiled</font>

355
00:15:17,680 --> 00:15:26,469
separately<font color="#E5E5E5"> and uses it for</font><font color="#CCCCCC"> a several</font>

356
00:15:20,699 --> 00:15:28,810
separate use so basically they<font color="#CCCCCC"> are I</font>

357
00:15:26,470 --> 00:15:32,170
<font color="#CCCCCC">think</font><font color="#E5E5E5"> they are compatible basically the</font>

358
00:15:28,810 --> 00:15:34,420
thing is we we use each<font color="#CCCCCC"> dfi to tag</font>

359
00:15:32,170 --> 00:15:36,399
sensitive data<font color="#E5E5E5"> and all sensitive data</font>

360
00:15:34,420 --> 00:15:38,529
will have<font color="#CCCCCC"> different meanings for example</font>

361
00:15:36,399 --> 00:15:40,389
return address will never overlap with

362
00:15:38,529 --> 00:15:42,519
for example<font color="#CCCCCC"> way table</font><font color="#E5E5E5"> pointers or</font>

363
00:15:40,389 --> 00:15:45,130
function pointers or return address will

364
00:15:42,519 --> 00:15:48,040
never overlap with say a UID in the

365
00:15:45,130 --> 00:15:49,990
kernel<font color="#E5E5E5"> so in so in that way if you look</font>

366
00:15:48,040 --> 00:15:51,849
at the look at<font color="#E5E5E5"> the memory you will say</font>

367
00:15:49,990 --> 00:15:54,220
<font color="#CCCCCC">ok all the sensitive</font><font color="#E5E5E5"> data they will be</font>

368
00:15:51,850 --> 00:15:57,130
<font color="#CCCCCC">disjoint and so all</font><font color="#E5E5E5"> these applications</font>

369
00:15:54,220 --> 00:16:01,180
<font color="#CCCCCC">can be combined together</font><font color="#E5E5E5"> to they will</font>

370
00:15:57,130 --> 00:16:03,819
<font color="#E5E5E5">not affect each other well I mean</font>

371
00:16:01,180 --> 00:16:06,459
couldn't it return address yeah

372
00:16:03,819 --> 00:16:07,899
overwritten by some code<font color="#CCCCCC"> that it</font><font color="#E5E5E5"> thinks</font>

373
00:16:06,459 --> 00:16:08,949
it's right<font color="#E5E5E5"> in</font><font color="#CCCCCC"> their crypto key or</font>

374
00:16:07,899 --> 00:16:11,470
<font color="#E5E5E5">something like that</font><font color="#CCCCCC"> which you also</font>

375
00:16:08,949 --> 00:16:14,199
<font color="#E5E5E5">consider sensitive yes so I think if you</font>

376
00:16:11,470 --> 00:16:14,769
mentioning that<font color="#CCCCCC"> I think I have a Wong oh</font>

377
00:16:14,199 --> 00:16:20,349
sorry

378
00:16:14,769 --> 00:16:22,690
ah could<font color="#CCCCCC"> you go</font><font color="#E5E5E5"> to one slides</font><font color="#CCCCCC"> more or</font>

379
00:16:20,350 --> 00:16:25,449
maybe so I have actually<font color="#CCCCCC"> have a backup</font>

380
00:16:22,690 --> 00:16:28,120
slides<font color="#E5E5E5"> talking about this so all this is</font>

381
00:16:25,449 --> 00:16:30,479
based on<font color="#CCCCCC"> dfi</font><font color="#E5E5E5"> so the thing is we have</font><font color="#CCCCCC"> to</font>

382
00:16:28,120 --> 00:16:33,220
rely on the<font color="#E5E5E5"> data</font><font color="#CCCCCC"> for analysis so</font>

383
00:16:30,480 --> 00:16:37,480
<font color="#CCCCCC">basically we need</font><font color="#E5E5E5"> to be able to control</font>

384
00:16:33,220 --> 00:16:40,690
<font color="#CCCCCC">whether the pointer points to so if so</font>

385
00:16:37,480 --> 00:16:41,980
therefore to defeat I think to handle

386
00:16:40,690 --> 00:16:44,199
the case<font color="#E5E5E5"> you are mentioning to you we</font>

387
00:16:41,980 --> 00:16:47,139
need to<font color="#E5E5E5"> probably need additional our</font>

388
00:16:44,199 --> 00:16:49,510
runtime<font color="#E5E5E5"> our memory safety enforcement to</font>

389
00:16:47,139 --> 00:16:51,279
<font color="#CCCCCC">make sure that ok</font><font color="#E5E5E5"> I you have this</font>

390
00:16:49,510 --> 00:16:52,930
instruction and<font color="#CCCCCC"> you want to write it to</font>

391
00:16:51,279 --> 00:16:54,519
<font color="#E5E5E5">a</font><font color="#CCCCCC"> target we need to make sure that</font><font color="#E5E5E5"> the</font>

392
00:16:52,930 --> 00:16:55,969
target<font color="#E5E5E5"> actually</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> target you want to</font>

393
00:16:54,519 --> 00:16:58,160
rise<font color="#CCCCCC"> to the</font>

394
00:16:55,970 --> 00:17:00,199
this answer<font color="#E5E5E5"> your</font><font color="#CCCCCC"> question</font><font color="#E5E5E5"> so for example</font>

395
00:16:58,160 --> 00:17:02,149
you<font color="#E5E5E5"> have a you have a constructor</font>

396
00:17:00,199 --> 00:17:03,920
<font color="#CCCCCC">attacker may tries to use this</font>

397
00:17:02,149 --> 00:17:07,609
constructor to overwrite the<font color="#CCCCCC"> return</font>

398
00:17:03,920 --> 00:17:11,119
address by over writing<font color="#E5E5E5"> a return address</font>

399
00:17:07,609 --> 00:17:12,829
<font color="#E5E5E5">with a</font><font color="#CCCCCC"> v-taper pointer but in the in</font>

400
00:17:11,119 --> 00:17:15,879
<font color="#E5E5E5">that</font><font color="#CCCCCC"> case we</font><font color="#E5E5E5"> probably will need the</font>

401
00:17:12,829 --> 00:17:18,438
additional runtime memory safety

402
00:17:15,880 --> 00:17:21,500
mechanism to prevent<font color="#E5E5E5"> such cases and</font>

403
00:17:18,439 --> 00:17:25,850
<font color="#E5E5E5">actually our word orange</font><font color="#CCCCCC"> not go for hdf</font>

404
00:17:21,500 --> 00:17:28,580
<font color="#CCCCCC">i is to be assisting memory safety</font>

405
00:17:25,849 --> 00:17:30,740
mechanisms such as<font color="#CCCCCC"> MPX to achieve</font>

406
00:17:28,580 --> 00:17:33,168
selective protection so we<font color="#E5E5E5"> only</font><font color="#CCCCCC"> need to</font>

407
00:17:30,740 --> 00:17:35,480
isolate some more important sensitive

408
00:17:33,169 --> 00:17:39,559
data and<font color="#E5E5E5"> applies memory safety</font><font color="#CCCCCC"> only to</font>

409
00:17:35,480 --> 00:17:41,539
those kind of data<font color="#CCCCCC"> okay and I also</font>

410
00:17:39,559 --> 00:17:43,149
noticed<font color="#E5E5E5"> that</font><font color="#CCCCCC"> on your performance</font>

411
00:17:41,539 --> 00:17:45,260
overhead chart there<font color="#CCCCCC"> seem to be</font><font color="#E5E5E5"> one</font>

412
00:17:43,150 --> 00:17:47,510
performance over here which<font color="#CCCCCC"> was</font><font color="#E5E5E5"> negative</font>

413
00:17:45,260 --> 00:17:49,539
<font color="#CCCCCC">oh that's</font><font color="#E5E5E5"> I think it's supposed back</font>

414
00:17:47,510 --> 00:17:52,580
it's there's<font color="#CCCCCC"> some natural fluctuations</font>

415
00:17:49,539 --> 00:17:55,150
<font color="#E5E5E5">like one or I think one percent is</font>

416
00:17:52,580 --> 00:17:57,559
<font color="#CCCCCC">within the</font><font color="#E5E5E5"> standard deviation so it's</font>

417
00:17:55,150 --> 00:18:00,799
basically<font color="#E5E5E5"> I don't think it's quite</font>

418
00:17:57,559 --> 00:18:03,250
<font color="#E5E5E5">meaningful it's just the result of a one</font>

419
00:18:00,799 --> 00:18:03,250
test case

