1
00:00:00,030 --> 00:00:05,250
so what can<font color="#CCCCCC"> we do</font><font color="#E5E5E5"> about malicious</font>

2
00:00:02,939 --> 00:00:07,649
hardware manufacturers so<font color="#E5E5E5"> imagine that</font>

3
00:00:05,250 --> 00:00:09,389
we're going<font color="#E5E5E5"> to</font><font color="#CCCCCC"> design a chip</font><font color="#E5E5E5"> that's safe</font>

4
00:00:07,649 --> 00:00:10,920
for encrypting<font color="#E5E5E5"> telephone conversations</font>

5
00:00:09,389 --> 00:00:13,139
<font color="#E5E5E5">and then we're going to outsource its</font>

6
00:00:10,920 --> 00:00:15,570
<font color="#E5E5E5">manufacturer to a fab</font><font color="#CCCCCC"> a company</font><font color="#E5E5E5"> that</font>

7
00:00:13,139 --> 00:00:17,310
builds integrated circuits<font color="#E5E5E5"> well if the</font>

8
00:00:15,570 --> 00:00:19,020
fab is<font color="#CCCCCC"> malicious</font><font color="#E5E5E5"> it can build a chip</font>

9
00:00:17,310 --> 00:00:20,820
with a<font color="#E5E5E5"> backdoor in it and what</font><font color="#CCCCCC"> that</font>

10
00:00:19,020 --> 00:00:22,740
<font color="#E5E5E5">means is that</font><font color="#CCCCCC"> maybe a third party will</font>

11
00:00:20,820 --> 00:00:25,140
be able to listen to<font color="#E5E5E5"> our conversations</font>

12
00:00:22,740 --> 00:00:26,909
<font color="#E5E5E5">now this is a serious problem</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> US</font>

13
00:00:25,140 --> 00:00:28,830
Department of<font color="#E5E5E5"> Defense</font><font color="#CCCCCC"> has a program for</font>

14
00:00:26,910 --> 00:00:31,920
trustworthy manufacturing that uses

15
00:00:28,830 --> 00:00:34,079
<font color="#E5E5E5">onshore fabs chains of custody and even</font>

16
00:00:31,920 --> 00:00:35,700
background checks and clearances<font color="#E5E5E5"> and if</font>

17
00:00:34,079 --> 00:00:38,399
all<font color="#E5E5E5"> that sounds like a pain it's because</font>

18
00:00:35,700 --> 00:00:41,340
<font color="#CCCCCC">it is but as we saw in the exciting a to</font>

19
00:00:38,399 --> 00:00:44,700
work<font color="#E5E5E5"> fabs can insert malicious hardware</font>

20
00:00:41,340 --> 00:00:46,500
<font color="#CCCCCC">and then it's</font><font color="#E5E5E5"> very hard</font><font color="#CCCCCC"> to detect it</font><font color="#E5E5E5"> so</font>

21
00:00:44,700 --> 00:00:48,390
what<font color="#E5E5E5"> that means is that</font><font color="#CCCCCC"> essentially</font>

22
00:00:46,500 --> 00:00:51,809
trusted manufacturing is the<font color="#CCCCCC"> only way</font><font color="#E5E5E5"> to</font>

23
00:00:48,390 --> 00:00:54,090
get strong guarantees<font color="#E5E5E5"> still trusted</font>

24
00:00:51,809 --> 00:00:55,739
manufacturing is no panacea<font color="#E5E5E5"> for</font><font color="#CCCCCC"> one</font>

25
00:00:54,090 --> 00:00:58,350
there<font color="#E5E5E5"> are only five countries in</font><font color="#CCCCCC"> the</font>

26
00:00:55,739 --> 00:01:00,180
<font color="#E5E5E5">world that have advanced fabs onshore</font>

27
00:00:58,350 --> 00:01:03,960
<font color="#E5E5E5">and building a new one would take</font>

28
00:01:00,180 --> 00:01:05,519
billions<font color="#E5E5E5"> of dollars and years of</font><font color="#CCCCCC"> R&D so</font>

29
00:01:03,960 --> 00:01:07,380
that means that say the government of

30
00:01:05,519 --> 00:01:09,180
<font color="#E5E5E5">India wants</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> build this encrypted chip</font>

31
00:01:07,380 --> 00:01:11,100
at an onshore fab they're going<font color="#E5E5E5"> to have</font>

32
00:01:09,180 --> 00:01:13,320
to use sort<font color="#E5E5E5"> of early 90s vintage</font>

33
00:01:11,100 --> 00:01:15,720
technology and what that<font color="#E5E5E5"> means is that</font>

34
00:01:13,320 --> 00:01:17,429
they might be<font color="#E5E5E5"> behind the cutting edge by</font>

35
00:01:15,720 --> 00:01:19,470
up to<font color="#E5E5E5"> eight orders of magnitude if we</font>

36
00:01:17,430 --> 00:01:22,560
<font color="#E5E5E5">take into account speed</font><font color="#CCCCCC"> and area and</font>

37
00:01:19,470 --> 00:01:24,390
<font color="#CCCCCC">energy</font><font color="#E5E5E5"> consumption so</font><font color="#CCCCCC"> my co-authors</font><font color="#E5E5E5"> I</font>

38
00:01:22,560 --> 00:01:25,710
looked at this and<font color="#CCCCCC"> we said how can we</font>

39
00:01:24,390 --> 00:01:27,509
<font color="#E5E5E5">make this cheaper how can we make</font>

40
00:01:25,710 --> 00:01:29,669
trustworthy chips more cheaply<font color="#CCCCCC"> and it</font>

41
00:01:27,509 --> 00:01:31,829
seemed<font color="#E5E5E5"> to us like we would be</font><font color="#CCCCCC"> able</font><font color="#E5E5E5"> to</font>

42
00:01:29,670 --> 00:01:33,960
use a probabilistic proof system<font color="#E5E5E5"> to do</font>

43
00:01:31,829 --> 00:01:36,059
so so here's what I<font color="#E5E5E5"> mean so imagine that</font>

44
00:01:33,960 --> 00:01:38,309
<font color="#E5E5E5">instead</font><font color="#CCCCCC"> of designing</font><font color="#E5E5E5"> a single chip that</font>

45
00:01:36,060 --> 00:01:40,259
executes<font color="#CCCCCC"> F that's</font><font color="#E5E5E5"> our computation we're</font>

46
00:01:38,310 --> 00:01:41,970
going to<font color="#E5E5E5"> design two chips one that will</font>

47
00:01:40,259 --> 00:01:43,680
call approver<font color="#E5E5E5"> and then</font><font color="#CCCCCC"> one that</font><font color="#E5E5E5"> we'll</font>

48
00:01:41,970 --> 00:01:46,110
call<font color="#E5E5E5"> a verifier and then we'll send</font>

49
00:01:43,680 --> 00:01:48,869
<font color="#E5E5E5">those designs to two different fabs the</font>

50
00:01:46,110 --> 00:01:51,329
prover will go to an untrusted but very

51
00:01:48,869 --> 00:01:53,670
fast<font color="#E5E5E5"> fat and the verifier will go to a</font>

52
00:01:51,329 --> 00:01:55,289
trusted<font color="#CCCCCC"> but slower</font><font color="#E5E5E5"> fat and then once the</font>

53
00:01:53,670 --> 00:01:57,299
two chips are built<font color="#E5E5E5"> they're going to be</font>

54
00:01:55,290 --> 00:01:59,369
put together<font color="#E5E5E5"> into a single</font><font color="#CCCCCC"> device and</font>

55
00:01:57,299 --> 00:02:01,229
then that<font color="#E5E5E5"> device is what we install into</font>

56
00:01:59,369 --> 00:02:03,450
the system<font color="#E5E5E5"> so then when we</font><font color="#CCCCCC"> want to run a</font>

57
00:02:01,229 --> 00:02:05,820
computation<font color="#E5E5E5"> we send the very the</font>

58
00:02:03,450 --> 00:02:07,290
verifier inside the device and input and

59
00:02:05,820 --> 00:02:09,840
then it forwards that input<font color="#E5E5E5"> to</font><font color="#CCCCCC"> the</font>

60
00:02:07,290 --> 00:02:12,120
prover and it gets back a response<font color="#CCCCCC"> plus</font>

61
00:02:09,840 --> 00:02:12,870
a proof that<font color="#E5E5E5"> the response was computed</font>

62
00:02:12,120 --> 00:02:14,489
<font color="#E5E5E5">correctly</font>

63
00:02:12,870 --> 00:02:17,400
and then the verifier checks that and

64
00:02:14,489 --> 00:02:20,069
outputs<font color="#E5E5E5"> the</font><font color="#CCCCCC"> result now this whole setup</font>

65
00:02:17,400 --> 00:02:22,650
<font color="#E5E5E5">makes sense</font><font color="#CCCCCC"> if the cost of</font><font color="#E5E5E5"> the verifier</font>

66
00:02:20,069 --> 00:02:24,958
plus the prover chip is less than it

67
00:02:22,650 --> 00:02:26,940
<font color="#E5E5E5">would have cost to just build</font><font color="#CCCCCC"> F</font><font color="#E5E5E5"> our</font>

68
00:02:24,959 --> 00:02:29,310
initial computation in<font color="#E5E5E5"> the trusted</font>

69
00:02:26,940 --> 00:02:32,010
foundry to<font color="#E5E5E5"> begin with and there's reason</font>

70
00:02:29,310 --> 00:02:33,569
to<font color="#E5E5E5"> hope that</font><font color="#CCCCCC"> this is</font><font color="#E5E5E5"> the case</font><font color="#CCCCCC"> so</font><font color="#E5E5E5"> theory</font>

71
00:02:32,010 --> 00:02:35,970
tells us<font color="#E5E5E5"> that at least asymptotically</font>

72
00:02:33,569 --> 00:02:37,768
<font color="#E5E5E5">the verifier should be</font><font color="#CCCCCC"> able</font><font color="#E5E5E5"> to save work</font>

73
00:02:35,970 --> 00:02:40,290
compared<font color="#E5E5E5"> to just executing the</font>

74
00:02:37,769 --> 00:02:42,720
computation<font color="#E5E5E5"> and even though in these</font>

75
00:02:40,290 --> 00:02:44,849
systems<font color="#E5E5E5"> the prover has massive overheads</font>

76
00:02:42,720 --> 00:02:48,269
<font color="#E5E5E5">as we saw with</font><font color="#CCCCCC"> Cinderella a couple days</font>

77
00:02:44,849 --> 00:02:50,069
<font color="#E5E5E5">ago we hope that you know because the</font>

78
00:02:48,269 --> 00:02:52,560
prover is<font color="#E5E5E5"> built in this untrusted</font>

79
00:02:50,069 --> 00:02:55,708
extremely powerful fat that can offset

80
00:02:52,560 --> 00:02:57,690
some<font color="#CCCCCC"> of</font><font color="#E5E5E5"> that overhead</font><font color="#CCCCCC"> still there</font><font color="#E5E5E5"> are</font>

81
00:02:55,709 --> 00:02:59,099
<font color="#E5E5E5">some</font><font color="#CCCCCC"> challenges here</font><font color="#E5E5E5"> first it's not</font>

82
00:02:57,690 --> 00:03:00,720
enough to say that the<font color="#E5E5E5"> running</font><font color="#CCCCCC"> time is</font>

83
00:02:59,099 --> 00:03:02,608
<font color="#E5E5E5">faster</font><font color="#CCCCCC"> we also need to worry about</font>

84
00:03:00,720 --> 00:03:04,560
<font color="#CCCCCC">hardware things like energy and</font><font color="#E5E5E5"> chip</font>

85
00:03:02,609 --> 00:03:06,239
area<font color="#E5E5E5"> and we need to actually be able to</font>

86
00:03:04,560 --> 00:03:08,879
build the circuit<font color="#CCCCCC"> which means we need a</font>

87
00:03:06,239 --> 00:03:10,739
tight digital circuit design<font color="#CCCCCC"> and</font><font color="#E5E5E5"> finally</font>

88
00:03:08,879 --> 00:03:13,768
the verifier needs to save work

89
00:03:10,739 --> 00:03:15,239
concretely<font color="#E5E5E5"> not just asymptotically for</font>

90
00:03:13,769 --> 00:03:17,609
problem sizes<font color="#E5E5E5"> that we</font><font color="#CCCCCC"> actually care</font>

91
00:03:15,239 --> 00:03:20,489
about so we sat<font color="#E5E5E5"> down and we built this</font>

92
00:03:17,609 --> 00:03:22,349
system<font color="#E5E5E5"> that we call zebra</font><font color="#CCCCCC"> and I'm happy</font>

93
00:03:20,489 --> 00:03:24,630
<font color="#CCCCCC">to tell</font><font color="#E5E5E5"> you that that we've won it's</font>

94
00:03:22,349 --> 00:03:26,819
over trusted chips<font color="#CCCCCC"> are that's it</font><font color="#E5E5E5"> we've</font>

95
00:03:24,630 --> 00:03:29,430
got them<font color="#CCCCCC"> no that's a lie that's a lie</font>

96
00:03:26,819 --> 00:03:31,530
I'm sorry so really we have<font color="#E5E5E5"> a hardware</font>

97
00:03:29,430 --> 00:03:34,319
design that sometimes saves costs

98
00:03:31,530 --> 00:03:35,910
compared to just building<font color="#E5E5E5"> F in a trusted</font>

99
00:03:34,319 --> 00:03:38,040
foundry<font color="#E5E5E5"> and for the rest of the talk I'm</font>

100
00:03:35,910 --> 00:03:39,510
<font color="#CCCCCC">going to tell you when we</font><font color="#E5E5E5"> win and how</font>

101
00:03:38,040 --> 00:03:41,760
and when we don't

102
00:03:39,510 --> 00:03:44,190
so zebra is built on top of

103
00:03:41,760 --> 00:03:47,160
probabilistic proof systems in these

104
00:03:44,190 --> 00:03:49,319
systems<font color="#E5E5E5"> the computation is expressed as</font>

105
00:03:47,160 --> 00:03:51,329
an<font color="#E5E5E5"> arithmetic circuit and the arithmetic</font>

106
00:03:49,319 --> 00:03:53,849
circuit is constructed such that<font color="#E5E5E5"> it's</font>

107
00:03:51,329 --> 00:03:56,040
satisfiability is<font color="#E5E5E5"> tantamount to correct</font>

108
00:03:53,849 --> 00:03:58,198
<font color="#E5E5E5">execution of the computation so what</font>

109
00:03:56,040 --> 00:04:00,239
this<font color="#CCCCCC"> means is that the provers job is</font>

110
00:03:58,199 --> 00:04:02,609
just<font color="#E5E5E5"> to convince the verifier that there</font>

111
00:04:00,239 --> 00:04:04,260
exists a satisfying<font color="#E5E5E5"> assignment</font><font color="#CCCCCC"> now in</font>

112
00:04:02,609 --> 00:04:05,940
terms of machinery<font color="#E5E5E5"> for the</font><font color="#CCCCCC"> proved er to</font>

113
00:04:04,260 --> 00:04:08,849
do so there's kind of two strands<font color="#E5E5E5"> in the</font>

114
00:04:05,940 --> 00:04:10,470
<font color="#E5E5E5">systems work one uses arguments and</font>

115
00:04:08,849 --> 00:04:12,290
<font color="#E5E5E5">these are systems like SATA or Pinocchio</font>

116
00:04:10,470 --> 00:04:14,400
and<font color="#CCCCCC"> lib</font><font color="#E5E5E5"> start arguments</font><font color="#CCCCCC"> are sort of</font>

117
00:04:12,290 --> 00:04:16,320
computationally sound proofs<font color="#E5E5E5"> and the</font>

118
00:04:14,400 --> 00:04:17,880
other uses interactive proofs which are

119
00:04:16,320 --> 00:04:19,918
a kind<font color="#E5E5E5"> of probabilistic</font><font color="#CCCCCC"> cross</font>

120
00:04:17,880 --> 00:04:22,800
<font color="#CCCCCC">examination and systems here like</font>

121
00:04:19,918 --> 00:04:24,810
muggles<font color="#E5E5E5"> and CMT</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> allspice now systems</font>

122
00:04:22,800 --> 00:04:27,030
based on<font color="#E5E5E5"> arguments have much more</font>

123
00:04:24,810 --> 00:04:28,410
generality<font color="#CCCCCC"> this is because interactive</font>

124
00:04:27,030 --> 00:04:30,479
proof based systems<font color="#CCCCCC"> sort</font><font color="#E5E5E5"> of place</font>

125
00:04:28,410 --> 00:04:32,610
<font color="#CCCCCC">restrictions</font><font color="#E5E5E5"> on the arithmetic circuit</font>

126
00:04:30,480 --> 00:04:34,770
<font color="#E5E5E5">and in addition because there's little</font>

127
00:04:32,610 --> 00:04:36,330
<font color="#E5E5E5">or no interaction in the argument based</font>

128
00:04:34,770 --> 00:04:38,460
systems they have<font color="#E5E5E5"> much less</font>

129
00:04:36,330 --> 00:04:40,890
<font color="#CCCCCC">communication cost than interactive</font>

130
00:04:38,460 --> 00:04:43,500
proofs<font color="#E5E5E5"> so it seems</font><font color="#CCCCCC"> like an obvious</font>

131
00:04:40,890 --> 00:04:45,719
<font color="#E5E5E5">choice that we would just build zebra on</font>

132
00:04:43,500 --> 00:04:48,300
top of arguments and we started to do

133
00:04:45,720 --> 00:04:50,910
<font color="#E5E5E5">that and then we figured something out</font>

134
00:04:48,300 --> 00:04:53,130
<font color="#E5E5E5">it seemed like these argument protocols</font>

135
00:04:50,910 --> 00:04:54,650
didn't really map very well<font color="#E5E5E5"> to the kind</font>

136
00:04:53,130 --> 00:04:56,700
of hardware<font color="#CCCCCC"> that</font><font color="#E5E5E5"> we would need</font><font color="#CCCCCC"> to design</font>

137
00:04:54,650 --> 00:04:58,169
at the end of the talk<font color="#CCCCCC"> we'll tell you a</font>

138
00:04:56,700 --> 00:04:59,610
little<font color="#E5E5E5"> bit</font><font color="#CCCCCC"> more about that</font><font color="#E5E5E5"> but right</font><font color="#CCCCCC"> now</font>

139
00:04:58,170 --> 00:05:01,680
I'll tell you<font color="#E5E5E5"> how</font><font color="#CCCCCC"> we</font><font color="#E5E5E5"> found that</font>

140
00:04:59,610 --> 00:05:06,300
interactive proofs did map to hardware

141
00:05:01,680 --> 00:05:07,860
and how we built that hardware so<font color="#E5E5E5"> zebra</font>

142
00:05:06,300 --> 00:05:10,980
builds on top<font color="#CCCCCC"> of the interactive proof</font>

143
00:05:07,860 --> 00:05:13,650
protocols from<font color="#CCCCCC"> GK our</font><font color="#E5E5E5"> CMT and allspice</font>

144
00:05:10,980 --> 00:05:15,660
<font color="#CCCCCC">and</font><font color="#E5E5E5"> so in these protocols the arithmetic</font>

145
00:05:13,650 --> 00:05:17,609
<font color="#E5E5E5">circuit needs to be layered</font><font color="#CCCCCC"> what that</font>

146
00:05:15,660 --> 00:05:19,050
means is that the inputs go to a first

147
00:05:17,610 --> 00:05:21,810
set of<font color="#E5E5E5"> gates whose outputs go to a</font>

148
00:05:19,050 --> 00:05:23,669
second set<font color="#E5E5E5"> of gates etc</font><font color="#CCCCCC"> this</font><font color="#E5E5E5"> is an</font>

149
00:05:21,810 --> 00:05:25,919
example<font color="#E5E5E5"> of a layer</font><font color="#CCCCCC"> 2 arithmetic circuit</font>

150
00:05:23,669 --> 00:05:27,419
<font color="#E5E5E5">this is</font><font color="#CCCCCC"> a single double and</font><font color="#E5E5E5"> add step</font>

151
00:05:25,919 --> 00:05:29,370
from elliptic curve point multiplication

152
00:05:27,419 --> 00:05:31,530
<font color="#CCCCCC">and</font><font color="#E5E5E5"> I want you to know that</font><font color="#CCCCCC"> this is not</font>

153
00:05:29,370 --> 00:05:33,720
a the physical circuit that we would

154
00:05:31,530 --> 00:05:35,880
build in silicon<font color="#E5E5E5"> this</font><font color="#CCCCCC"> is an abstract</font>

155
00:05:33,720 --> 00:05:37,169
representation<font color="#E5E5E5"> of the computation so</font>

156
00:05:35,880 --> 00:05:39,000
remember what<font color="#E5E5E5"> we said was that the</font>

157
00:05:37,169 --> 00:05:41,070
verifier hands<font color="#E5E5E5"> an input to the prover</font>

158
00:05:39,000 --> 00:05:43,020
<font color="#E5E5E5">and then the prover evaluates the</font>

159
00:05:41,070 --> 00:05:45,780
<font color="#CCCCCC">arithmetic circuit and returns an output</font>

160
00:05:43,020 --> 00:05:47,789
<font color="#CCCCCC">to the verifier and now the verifier and</font>

161
00:05:45,780 --> 00:05:49,830
the provers start to interact<font color="#E5E5E5"> so the</font>

162
00:05:47,790 --> 00:05:52,020
verifier asks the prover some questions

163
00:05:49,830 --> 00:05:53,940
<font color="#CCCCCC">about the last layer of</font><font color="#E5E5E5"> the circuit and</font>

164
00:05:52,020 --> 00:05:55,919
if the provers answers are all

165
00:05:53,940 --> 00:05:58,290
consistent<font color="#CCCCCC"> then the</font><font color="#E5E5E5"> the proof the</font>

166
00:05:55,919 --> 00:05:59,130
verifier<font color="#CCCCCC"> is convinced that the output</font>

167
00:05:58,290 --> 00:06:01,320
was correct

168
00:05:59,130 --> 00:06:03,870
just in case the prover was honest about

169
00:06:01,320 --> 00:06:06,090
<font color="#E5E5E5">the second last layer of</font><font color="#CCCCCC"> the circuit</font><font color="#E5E5E5"> so</font>

170
00:06:03,870 --> 00:06:08,400
now how does the verifier<font color="#E5E5E5"> learn that</font>

171
00:06:06,090 --> 00:06:10,020
well it engages the prover in another

172
00:06:08,400 --> 00:06:11,849
interaction<font color="#E5E5E5"> and that gives it a</font>

173
00:06:10,020 --> 00:06:14,370
<font color="#CCCCCC">statement about the</font><font color="#E5E5E5"> previous layer so</font>

174
00:06:11,850 --> 00:06:16,140
this<font color="#E5E5E5"> continues until the verifier</font><font color="#CCCCCC"> is</font>

175
00:06:14,370 --> 00:06:17,880
holding a statement<font color="#E5E5E5"> about the inputs to</font>

176
00:06:16,140 --> 00:06:20,310
<font color="#CCCCCC">the circuit</font><font color="#E5E5E5"> well it knows those inputs</font>

177
00:06:17,880 --> 00:06:22,740
<font color="#CCCCCC">so now I can</font><font color="#E5E5E5"> just check that check the</font>

178
00:06:20,310 --> 00:06:23,610
consistency<font color="#CCCCCC"> and if the prover was honest</font>

179
00:06:22,740 --> 00:06:26,010
about all of this

180
00:06:23,610 --> 00:06:27,960
then the verifier<font color="#CCCCCC"> is convinced now at</font>

181
00:06:26,010 --> 00:06:29,130
each layer<font color="#E5E5E5"> of</font><font color="#CCCCCC"> the circuit</font><font color="#E5E5E5"> the verifier</font>

182
00:06:27,960 --> 00:06:30,900
needs to ask a number<font color="#CCCCCC"> of questions</font>

183
00:06:29,130 --> 00:06:33,450
<font color="#E5E5E5">that's sort of logarithmic in the number</font>

184
00:06:30,900 --> 00:06:35,729
of<font color="#E5E5E5"> gates</font><font color="#CCCCCC"> at that layer</font><font color="#E5E5E5"> so what we want</font>

185
00:06:33,450 --> 00:06:37,940
<font color="#E5E5E5">is a circuit that's wide and not too</font>

186
00:06:35,729 --> 00:06:40,159
deep so that the verifier can save work

187
00:06:37,940 --> 00:06:41,660
<font color="#E5E5E5">so remember we're building the</font>

188
00:06:40,160 --> 00:06:44,270
hardware and so intuitively it seems

189
00:06:41,660 --> 00:06:45,860
<font color="#CCCCCC">like what we want is to</font><font color="#E5E5E5"> paralyze this</font>

190
00:06:44,270 --> 00:06:47,690
<font color="#E5E5E5">and in particular you might ask well</font>

191
00:06:45,860 --> 00:06:49,820
look we're we're executing<font color="#E5E5E5"> these layers</font>

192
00:06:47,690 --> 00:06:51,200
<font color="#E5E5E5">all you know at different</font><font color="#CCCCCC"> times</font><font color="#E5E5E5"> so maybe</font>

193
00:06:49,820 --> 00:06:53,150
we<font color="#E5E5E5"> could</font><font color="#CCCCCC"> just</font><font color="#E5E5E5"> run them</font><font color="#CCCCCC"> all at once and</font>

194
00:06:51,200 --> 00:06:55,460
unfortunately<font color="#CCCCCC"> that</font><font color="#E5E5E5"> doesn't work and the</font>

195
00:06:53,150 --> 00:06:57,169
reason<font color="#CCCCCC"> is the verifier needs to ask the</font>

196
00:06:55,460 --> 00:06:59,960
<font color="#E5E5E5">prover questions in the right order</font><font color="#CCCCCC"> or</font>

197
00:06:57,170 --> 00:07:01,460
<font color="#CCCCCC">else the prover can cheat</font><font color="#E5E5E5"> so in zebra we</font>

198
00:06:59,960 --> 00:07:04,039
do something slightly<font color="#CCCCCC"> different</font><font color="#E5E5E5"> and that</font>

199
00:07:01,460 --> 00:07:05,840
<font color="#E5E5E5">is we pipeline the execution let me show</font>

200
00:07:04,040 --> 00:07:07,880
you what I mean<font color="#CCCCCC"> so</font><font color="#E5E5E5"> imagine that the</font>

201
00:07:05,840 --> 00:07:09,739
verifier and the prover<font color="#E5E5E5"> are interacting</font>

202
00:07:07,880 --> 00:07:11,900
about the output<font color="#CCCCCC"> layer of some</font>

203
00:07:09,740 --> 00:07:14,240
computation now at the same<font color="#E5E5E5"> time the</font>

204
00:07:11,900 --> 00:07:16,489
prover can deliver a new result to the

205
00:07:14,240 --> 00:07:17,750
verifier now once the verifier improver

206
00:07:16,490 --> 00:07:20,000
are finished<font color="#CCCCCC"> and with</font><font color="#E5E5E5"> that first</font>

207
00:07:17,750 --> 00:07:21,800
computation<font color="#E5E5E5"> they move on to this the</font>

208
00:07:20,000 --> 00:07:24,200
second layer of<font color="#E5E5E5"> the first computation</font>

209
00:07:21,800 --> 00:07:26,300
<font color="#CCCCCC">and now they can start to interact</font><font color="#E5E5E5"> about</font>

210
00:07:24,200 --> 00:07:29,420
the second computations<font color="#E5E5E5"> output layer and</font>

211
00:07:26,300 --> 00:07:30,800
the prover can deliver a third result<font color="#E5E5E5"> so</font>

212
00:07:29,420 --> 00:07:33,020
you<font color="#E5E5E5"> can see how this</font><font color="#CCCCCC"> process could</font>

213
00:07:30,800 --> 00:07:34,820
continue<font color="#CCCCCC"> until the pipeline is full and</font>

214
00:07:33,020 --> 00:07:36,859
now the verifier and the prover<font color="#E5E5E5"> are</font>

215
00:07:34,820 --> 00:07:38,900
interacting about every layer<font color="#CCCCCC"> of the</font>

216
00:07:36,860 --> 00:07:41,810
circuit simultaneously but they're doing

217
00:07:38,900 --> 00:07:43,909
<font color="#CCCCCC">so</font><font color="#E5E5E5"> over different computations and it</font>

218
00:07:41,810 --> 00:07:46,750
only takes them the time<font color="#E5E5E5"> of interaction</font>

219
00:07:43,910 --> 00:07:49,490
for<font color="#CCCCCC"> a single layer to complete a proof</font>

220
00:07:46,750 --> 00:07:51,350
<font color="#CCCCCC">so this is one example of</font><font color="#E5E5E5"> the kind of</font>

221
00:07:49,490 --> 00:07:53,120
design approaches that we took in zebra

222
00:07:51,350 --> 00:07:54,920
<font color="#CCCCCC">we extracted parallelism from the</font>

223
00:07:53,120 --> 00:07:57,140
protocol<font color="#E5E5E5"> another of one of our</font>

224
00:07:54,920 --> 00:07:58,820
approaches was to exploit locality<font color="#E5E5E5"> and</font>

225
00:07:57,140 --> 00:08:01,340
what I<font color="#E5E5E5"> mean by that is we wanted to</font>

226
00:07:58,820 --> 00:08:03,370
avoid things like<font color="#E5E5E5"> using</font><font color="#CCCCCC"> Ram because</font><font color="#E5E5E5"> Ram</font>

227
00:08:01,340 --> 00:08:05,780
is a bottleneck<font color="#CCCCCC"> to</font><font color="#E5E5E5"> the computation so</font>

228
00:08:03,370 --> 00:08:07,190
<font color="#E5E5E5">instead remember we're building custom</font>

229
00:08:05,780 --> 00:08:09,679
<font color="#CCCCCC">Hardware here so we're not</font><font color="#E5E5E5"> stuck with</font>

230
00:08:07,190 --> 00:08:11,900
<font color="#E5E5E5">this sort of fetch decode execute model</font>

231
00:08:09,680 --> 00:08:15,200
of a<font color="#CCCCCC"> cpu</font><font color="#E5E5E5"> we were able</font><font color="#CCCCCC"> to map</font><font color="#E5E5E5"> the</font>

232
00:08:11,900 --> 00:08:17,000
hardware to the<font color="#E5E5E5"> flow of data through the</font>

233
00:08:15,200 --> 00:08:19,669
computation<font color="#CCCCCC"> and in that way we</font><font color="#E5E5E5"> could</font>

234
00:08:17,000 --> 00:08:21,560
<font color="#CCCCCC">avoid this kind of bottlenecks</font><font color="#E5E5E5"> and the</font>

235
00:08:19,669 --> 00:08:23,810
final one<font color="#CCCCCC"> of our</font><font color="#E5E5E5"> high-level design</font>

236
00:08:21,560 --> 00:08:26,720
approaches was to reduce reuse and

237
00:08:23,810 --> 00:08:28,490
<font color="#E5E5E5">recycle</font><font color="#CCCCCC"> what I mean</font><font color="#E5E5E5"> is we reduced the</font>

238
00:08:26,720 --> 00:08:30,590
<font color="#CCCCCC">amount of computation we needed to do by</font>

239
00:08:28,490 --> 00:08:32,870
remembering previously computed results

240
00:08:30,590 --> 00:08:35,209
and then reusing them later<font color="#E5E5E5"> and we were</font>

241
00:08:32,870 --> 00:08:36,830
able<font color="#CCCCCC"> to recycle the same circuit to</font>

242
00:08:35,210 --> 00:08:39,020
achieve different<font color="#E5E5E5"> tasks during the</font>

243
00:08:36,830 --> 00:08:41,330
computation<font color="#CCCCCC"> so these are kind of some</font>

244
00:08:39,020 --> 00:08:42,890
<font color="#E5E5E5">circuit level optimizations and</font>

245
00:08:41,330 --> 00:08:44,690
observations<font color="#CCCCCC"> that we had to make and</font>

246
00:08:42,890 --> 00:08:46,760
there were also some<font color="#E5E5E5"> sort</font><font color="#CCCCCC"> of system</font>

247
00:08:44,690 --> 00:08:48,650
level challenges so one of<font color="#E5E5E5"> those is</font>

248
00:08:46,760 --> 00:08:50,089
remember<font color="#E5E5E5"> this is an interactive protocol</font>

249
00:08:48,650 --> 00:08:53,300
so<font color="#E5E5E5"> that means that the verifier of the</font>

250
00:08:50,089 --> 00:08:53,840
prover talked a lot and<font color="#CCCCCC"> just building</font>

251
00:08:53,300 --> 00:08:55,790
naive

252
00:08:53,840 --> 00:08:58,940
<font color="#CCCCCC">- chips and having them talk</font><font color="#E5E5E5"> would be</font>

253
00:08:55,790 --> 00:09:00,500
<font color="#E5E5E5">very costly so instead we say well we</font>

254
00:08:58,940 --> 00:09:02,270
should<font color="#E5E5E5"> use this technique called 3d</font>

255
00:09:00,500 --> 00:09:03,650
integration where we stack the two

256
00:09:02,270 --> 00:09:05,780
devices<font color="#CCCCCC"> one on the other</font><font color="#E5E5E5"> and this</font>

257
00:09:03,650 --> 00:09:08,930
reduces considerably<font color="#CCCCCC"> the cost of</font><font color="#E5E5E5"> that</font>

258
00:09:05,780 --> 00:09:10,490
communication<font color="#E5E5E5"> the other limitation</font><font color="#CCCCCC"> that</font>

259
00:09:08,930 --> 00:09:12,530
I'll<font color="#E5E5E5"> talk</font><font color="#CCCCCC"> about is one that we inherit</font>

260
00:09:10,490 --> 00:09:15,530
from<font color="#CCCCCC"> the protocol</font><font color="#E5E5E5"> itself and that is</font>

261
00:09:12,530 --> 00:09:17,329
that the verifier needs some help<font color="#E5E5E5"> in the</font>

262
00:09:15,530 --> 00:09:19,819
<font color="#E5E5E5">form of an input independent</font>

263
00:09:17,330 --> 00:09:23,210
pre-computation<font color="#CCCCCC"> in order to save work</font>

264
00:09:19,820 --> 00:09:25,250
now<font color="#E5E5E5"> in in zebra we stipulate that we</font>

265
00:09:23,210 --> 00:09:27,650
should build many chips at once<font color="#E5E5E5"> and then</font>

266
00:09:25,250 --> 00:09:29,120
share the pre computations among them to

267
00:09:27,650 --> 00:09:29,990
<font color="#E5E5E5">amortize the cost of that</font>

268
00:09:29,120 --> 00:09:32,570
<font color="#CCCCCC">pre-computation</font>

269
00:09:29,990 --> 00:09:34,610
<font color="#E5E5E5">these are a couple of the challenges in</font>

270
00:09:32,570 --> 00:09:36,350
at the architectural<font color="#E5E5E5"> level we talk about</font>

271
00:09:34,610 --> 00:09:37,940
<font color="#E5E5E5">others in the paper</font><font color="#CCCCCC"> so now we've</font><font color="#E5E5E5"> seen</font>

272
00:09:36,350 --> 00:09:39,080
<font color="#E5E5E5">some</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> the circuit</font><font color="#CCCCCC"> design stuff and</font>

273
00:09:37,940 --> 00:09:40,640
we've seen some<font color="#CCCCCC"> of the architectural</font>

274
00:09:39,080 --> 00:09:42,890
challenges<font color="#CCCCCC"> let's take a look at the</font>

275
00:09:40,640 --> 00:09:44,960
evaluation but first what did we<font color="#E5E5E5"> built</font>

276
00:09:42,890 --> 00:09:46,520
well we implemented a compiler that<font color="#E5E5E5"> goes</font>

277
00:09:44,960 --> 00:09:48,800
from<font color="#E5E5E5"> a high-level</font><font color="#CCCCCC"> description</font><font color="#E5E5E5"> of an</font>

278
00:09:46,520 --> 00:09:50,600
arithmetic circuit to synthesizable<font color="#E5E5E5"> very</font>

279
00:09:48,800 --> 00:09:52,189
log<font color="#CCCCCC"> four approver</font><font color="#E5E5E5"> and then we also</font>

280
00:09:50,600 --> 00:09:54,290
designed two different verifier

281
00:09:52,190 --> 00:09:56,300
implementations<font color="#E5E5E5"> one for a hardware</font>

282
00:09:54,290 --> 00:09:58,069
<font color="#E5E5E5">verifier and</font><font color="#CCCCCC"> véra log and the other</font>

283
00:09:56,300 --> 00:10:00,890
first<font color="#E5E5E5"> software verifier say running on a</font>

284
00:09:58,070 --> 00:10:02,840
trusted<font color="#E5E5E5"> cpu that</font><font color="#CCCCCC"> ones in C++</font><font color="#E5E5E5"> and then we</font>

285
00:10:00,890 --> 00:10:04,250
wrote some sort of support<font color="#CCCCCC"> software that</font>

286
00:10:02,840 --> 00:10:07,010
helped with the pre computations<font color="#E5E5E5"> and</font>

287
00:10:04,250 --> 00:10:08,630
made the simulations<font color="#CCCCCC"> run faster</font><font color="#E5E5E5"> and then</font>

288
00:10:07,010 --> 00:10:10,819
we started<font color="#CCCCCC"> running simulations</font><font color="#E5E5E5"> and wow</font>

289
00:10:08,630 --> 00:10:12,650
this thing it worked it looked great<font color="#E5E5E5"> but</font>

290
00:10:10,820 --> 00:10:13,880
<font color="#CCCCCC">remember the point here wasn't</font><font color="#E5E5E5"> it just</font>

291
00:10:12,650 --> 00:10:15,770
<font color="#E5E5E5">to make something that worked and</font>

292
00:10:13,880 --> 00:10:16,970
generated a<font color="#E5E5E5"> bunch of proofs the point</font>

293
00:10:15,770 --> 00:10:19,460
was to build something<font color="#CCCCCC"> where the</font>

294
00:10:16,970 --> 00:10:21,590
verifier plus the prover was cheaper

295
00:10:19,460 --> 00:10:23,570
than<font color="#E5E5E5"> just building F in the trusted</font>

296
00:10:21,590 --> 00:10:25,670
technology<font color="#CCCCCC"> and so that's our baseline</font>

297
00:10:23,570 --> 00:10:27,320
<font color="#E5E5E5">imagine we have</font><font color="#CCCCCC"> some computation</font><font color="#E5E5E5"> we're</font>

298
00:10:25,670 --> 00:10:29,209
going to build in the trusted technology

299
00:10:27,320 --> 00:10:31,580
<font color="#CCCCCC">or simulate in the trusted technology</font>

300
00:10:29,210 --> 00:10:32,990
<font color="#CCCCCC">the direct implementation of F</font><font color="#E5E5E5"> and</font>

301
00:10:31,580 --> 00:10:35,420
compare<font color="#CCCCCC"> that to</font><font color="#E5E5E5"> the costs of the</font>

302
00:10:32,990 --> 00:10:37,310
verifier and the prover in terms of

303
00:10:35,420 --> 00:10:39,349
costs what I mean is the energy<font color="#CCCCCC"> that it</font>

304
00:10:37,310 --> 00:10:41,510
takes to<font color="#CCCCCC"> execute a computation which</font>

305
00:10:39,350 --> 00:10:43,730
sort of relates to<font color="#CCCCCC"> the online costs of</font>

306
00:10:41,510 --> 00:10:45,920
zebra in the in the paper we also<font color="#CCCCCC"> talk</font>

307
00:10:43,730 --> 00:10:48,530
<font color="#E5E5E5">about chip size per unit throughput</font>

308
00:10:45,920 --> 00:10:51,560
which sort of maps to the<font color="#E5E5E5"> manufacturing</font>

309
00:10:48,530 --> 00:10:53,209
cost<font color="#E5E5E5"> at a given</font><font color="#CCCCCC"> performance level now in</font>

310
00:10:51,560 --> 00:10:54,949
terms of these measurements<font color="#CCCCCC"> the way that</font>

311
00:10:53,210 --> 00:10:56,840
we did them is with circuit synthesis

312
00:10:54,950 --> 00:10:58,760
and simulation with published chip

313
00:10:56,840 --> 00:11:00,410
designs and with CMOS scaling models and

314
00:10:58,760 --> 00:11:02,300
we were<font color="#E5E5E5"> careful to account for sort of</font>

315
00:11:00,410 --> 00:11:04,219
<font color="#E5E5E5">all of</font><font color="#CCCCCC"> the costs that</font><font color="#E5E5E5"> the verifier and</font>

316
00:11:02,300 --> 00:11:06,500
the prover incurred during the

317
00:11:04,220 --> 00:11:07,170
computation<font color="#CCCCCC"> and then we imposed some</font>

318
00:11:06,500 --> 00:11:09,000
practical

319
00:11:07,170 --> 00:11:11,189
constraints<font color="#E5E5E5"> we said the trusted fab</font>

320
00:11:09,000 --> 00:11:13,050
needs to be<font color="#E5E5E5"> 350 nanometers and the</font>

321
00:11:11,190 --> 00:11:15,570
<font color="#E5E5E5">untrusted fab should be seven nanometers</font>

322
00:11:13,050 --> 00:11:18,479
<font color="#E5E5E5">and 350 nanometers is sort of 1997</font>

323
00:11:15,570 --> 00:11:20,610
technology so<font color="#CCCCCC"> thinking upend TM to seven</font>

324
00:11:18,480 --> 00:11:22,019
nanometers is according to<font color="#CCCCCC"> TSM see</font><font color="#E5E5E5"> who's</font>

325
00:11:20,610 --> 00:11:23,660
sort of the<font color="#E5E5E5"> biggest integrated circuit</font>

326
00:11:22,019 --> 00:11:26,430
manufacturer in the<font color="#CCCCCC"> world this</font><font color="#E5E5E5"> is</font><font color="#CCCCCC"> a</font>

327
00:11:23,660 --> 00:11:27,870
<font color="#E5E5E5">2017-2018 kind of technology so what</font>

328
00:11:26,430 --> 00:11:29,910
<font color="#E5E5E5">that means is that there's a 20-year gap</font>

329
00:11:27,870 --> 00:11:32,550
between the trusted and the untrusted

330
00:11:29,910 --> 00:11:34,620
<font color="#E5E5E5">fab</font><font color="#CCCCCC"> in the paper we also talked about</font>

331
00:11:32,550 --> 00:11:36,660
<font color="#E5E5E5">other gaps and see how</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> affects the</font>

332
00:11:34,620 --> 00:11:38,790
performance<font color="#E5E5E5"> and finally we impose these</font>

333
00:11:36,660 --> 00:11:40,319
sort of practical constraints<font color="#E5E5E5"> we say</font>

334
00:11:38,790 --> 00:11:42,060
well the chip can't be too big because

335
00:11:40,320 --> 00:11:43,949
<font color="#E5E5E5">otherwise</font><font color="#CCCCCC"> we otherwise</font><font color="#E5E5E5"> we can't build it</font>

336
00:11:42,060 --> 00:11:46,109
and it can't dissipate too much power

337
00:11:43,949 --> 00:11:48,479
<font color="#E5E5E5">because otherwise it just melts all</font>

338
00:11:46,110 --> 00:11:49,620
right<font color="#E5E5E5"> so what are our FS what do we what</font>

339
00:11:48,480 --> 00:11:50,940
do we actually<font color="#E5E5E5"> build well the first</font>

340
00:11:49,620 --> 00:11:52,740
application<font color="#E5E5E5"> is the number theoretic</font>

341
00:11:50,940 --> 00:11:54,750
transform<font color="#E5E5E5"> this is a fast</font><font color="#CCCCCC"> fourier</font>

342
00:11:52,740 --> 00:11:56,070
<font color="#CCCCCC">transform</font><font color="#E5E5E5"> over</font><font color="#CCCCCC"> a finite</font><font color="#E5E5E5"> field and it's</font>

343
00:11:54,750 --> 00:11:58,589
it's used<font color="#E5E5E5"> for example in computer</font>

344
00:11:56,070 --> 00:12:02,040
<font color="#CCCCCC">algebra to say multiply huge integers or</font>

345
00:11:58,589 --> 00:12:04,560
polynomials<font color="#E5E5E5"> so this graph</font><font color="#CCCCCC"> shows us the</font>

346
00:12:02,040 --> 00:12:07,319
<font color="#CCCCCC">ratio of the energy for the baseline</font><font color="#E5E5E5"> to</font>

347
00:12:04,560 --> 00:12:09,268
<font color="#E5E5E5">the energy in that zebra uses so higher</font>

348
00:12:07,320 --> 00:12:11,190
is<font color="#CCCCCC"> better here</font><font color="#E5E5E5"> and what we see is</font><font color="#CCCCCC"> that</font>

349
00:12:09,269 --> 00:12:13,589
we kind<font color="#E5E5E5"> of have two regions</font><font color="#CCCCCC"> one where</font>

350
00:12:11,190 --> 00:12:16,890
zebra wins for large<font color="#E5E5E5"> computation say</font>

351
00:12:13,589 --> 00:12:18,600
above<font color="#E5E5E5"> ntt size of couple hundred and one</font>

352
00:12:16,890 --> 00:12:20,399
where we<font color="#CCCCCC"> don't win</font><font color="#E5E5E5"> for small</font>

353
00:12:18,600 --> 00:12:22,829
computations<font color="#E5E5E5"> and this kind of makes</font>

354
00:12:20,399 --> 00:12:24,959
<font color="#CCCCCC">sense because there's some overhead for</font>

355
00:12:22,829 --> 00:12:26,370
participating<font color="#E5E5E5"> in the protocol and until</font>

356
00:12:24,959 --> 00:12:29,459
the computation is large enough the

357
00:12:26,370 --> 00:12:31,620
savings<font color="#E5E5E5"> don't swamp out that overhead so</font>

358
00:12:29,459 --> 00:12:33,689
the second baseline<font color="#CCCCCC"> is elliptic curve</font>

359
00:12:31,620 --> 00:12:35,610
point<font color="#E5E5E5"> multiplication over a curve 255</font>

360
00:12:33,690 --> 00:12:37,050
<font color="#E5E5E5">1/9 which is a commonly used elliptic</font>

361
00:12:35,610 --> 00:12:38,790
curve and remember point multiplication

362
00:12:37,050 --> 00:12:40,649
<font color="#E5E5E5">is sort of this primitive that's used</font>

363
00:12:38,790 --> 00:12:43,980
for<font color="#E5E5E5"> say EC dih and ECDSA</font>

364
00:12:40,649 --> 00:12:46,740
<font color="#CCCCCC">okay</font><font color="#E5E5E5"> so again here</font><font color="#CCCCCC"> we see a similar</font>

365
00:12:43,980 --> 00:12:48,480
result<font color="#E5E5E5"> where there's a</font><font color="#CCCCCC"> redeem where the</font>

366
00:12:46,740 --> 00:12:50,490
computation the number of<font color="#E5E5E5"> computations</font>

367
00:12:48,480 --> 00:12:53,160
is too small<font color="#E5E5E5"> and there's a regime where</font>

368
00:12:50,490 --> 00:12:55,589
<font color="#CCCCCC">the computation is big enough</font><font color="#E5E5E5"> that zebra</font>

369
00:12:53,160 --> 00:12:57,480
<font color="#E5E5E5">saves and here we see that's</font><font color="#CCCCCC"> about for a</font>

370
00:12:55,589 --> 00:13:00,839
hundred or so<font color="#E5E5E5"> parallel point</font>

371
00:12:57,480 --> 00:13:02,819
multiplications<font color="#E5E5E5"> all right so we've seen</font>

372
00:13:00,839 --> 00:13:06,300
<font color="#E5E5E5">some performance stuff and now it's time</font>

373
00:13:02,819 --> 00:13:07,889
to<font color="#E5E5E5"> go back to</font><font color="#CCCCCC"> that pesky sometimes so we</font>

374
00:13:06,300 --> 00:13:10,800
started out<font color="#CCCCCC"> looking for this way of</font>

375
00:13:07,889 --> 00:13:12,690
replacing<font color="#E5E5E5"> trusted fabs with something</font>

376
00:13:10,800 --> 00:13:14,339
else<font color="#E5E5E5"> something cheaper and the question</font>

377
00:13:12,690 --> 00:13:18,089
is<font color="#E5E5E5"> like do we get there</font><font color="#CCCCCC"> are we there yet</font>

378
00:13:14,339 --> 00:13:19,360
<font color="#CCCCCC">well</font><font color="#E5E5E5"> so zebra applies in some kind of</font>

379
00:13:18,089 --> 00:13:21,459
limited range

380
00:13:19,360 --> 00:13:23,649
<font color="#E5E5E5">first of all we need as we saw a wide</font>

381
00:13:21,459 --> 00:13:25,839
gap<font color="#CCCCCC"> between the technology of</font><font color="#E5E5E5"> the prover</font>

382
00:13:23,649 --> 00:13:27,970
and the technology of the verifier<font color="#E5E5E5"> and</font>

383
00:13:25,839 --> 00:13:30,459
we second we have to<font color="#CCCCCC"> amortize these pre</font>

384
00:13:27,970 --> 00:13:32,860
computations<font color="#E5E5E5"> over</font><font color="#CCCCCC"> many instances of</font>

385
00:13:30,459 --> 00:13:35,050
zebra<font color="#CCCCCC"> and the computation</font><font color="#E5E5E5"> needs to be</font>

386
00:13:32,860 --> 00:13:37,149
large in<font color="#E5E5E5"> order for the verifier to save</font>

387
00:13:35,050 --> 00:13:38,859
work<font color="#E5E5E5"> it needs</font><font color="#CCCCCC"> to be efficient when</font>

388
00:13:37,149 --> 00:13:40,930
expressed as an arithmetic<font color="#CCCCCC"> circuit which</font>

389
00:13:38,860 --> 00:13:43,329
kind of<font color="#E5E5E5"> rules out things</font><font color="#CCCCCC"> like</font><font color="#E5E5E5"> low level</font>

390
00:13:40,930 --> 00:13:46,000
bitwise operations<font color="#E5E5E5"> and it needs to be</font>

391
00:13:43,329 --> 00:13:47,979
layered shallow and deterministic<font color="#E5E5E5"> which</font>

392
00:13:46,000 --> 00:13:50,320
rules out things like<font color="#E5E5E5"> RAM and complex</font>

393
00:13:47,980 --> 00:13:53,170
control flow<font color="#E5E5E5"> so where do these</font>

394
00:13:50,320 --> 00:13:55,360
restrictions<font color="#E5E5E5"> come from well the</font><font color="#CCCCCC"> first</font>

395
00:13:53,170 --> 00:13:57,550
four restrictions are common to

396
00:13:55,360 --> 00:14:00,700
essentially all built proof based

397
00:13:57,550 --> 00:14:02,620
systems so for<font color="#CCCCCC"> example the</font><font color="#E5E5E5"> the need for</font>

398
00:14:00,700 --> 00:14:04,630
<font color="#E5E5E5">a large gap between the prover and the</font>

399
00:14:02,620 --> 00:14:06,700
verifier is essentially the same<font color="#E5E5E5"> thing</font>

400
00:14:04,630 --> 00:14:08,200
as saying well the prover has<font color="#E5E5E5"> massive</font>

401
00:14:06,700 --> 00:14:10,870
overheads when it could when it executes

402
00:14:08,200 --> 00:14:12,850
<font color="#E5E5E5">these computations and in terms of</font>

403
00:14:10,870 --> 00:14:14,560
needing<font color="#E5E5E5"> a very large computation to save</font>

404
00:14:12,850 --> 00:14:16,720
work<font color="#E5E5E5"> well a careful reading of the</font>

405
00:14:14,560 --> 00:14:18,790
literature<font color="#CCCCCC"> shows that even systems that</font>

406
00:14:16,720 --> 00:14:21,430
only<font color="#E5E5E5"> try to save work for the verifier</font>

407
00:14:18,790 --> 00:14:23,410
have trouble breaking<font color="#E5E5E5"> even unless the</font>

408
00:14:21,430 --> 00:14:27,250
computations are essentially as large as

409
00:14:23,410 --> 00:14:28,930
the system can<font color="#E5E5E5"> handle but the last the</font>

410
00:14:27,250 --> 00:14:30,760
last<font color="#E5E5E5"> restriction</font><font color="#CCCCCC"> that we need</font><font color="#E5E5E5"> this</font>

411
00:14:28,930 --> 00:14:32,410
layered shallow deterministic arithmetic

412
00:14:30,760 --> 00:14:34,420
circuit<font color="#E5E5E5"> that comes from the fact that</font>

413
00:14:32,410 --> 00:14:36,760
we're using interactive proofs<font color="#E5E5E5"> rather</font>

414
00:14:34,420 --> 00:14:38,949
than argument systems<font color="#CCCCCC"> and so now we come</font>

415
00:14:36,760 --> 00:14:41,319
back<font color="#CCCCCC"> to this question how was</font><font color="#E5E5E5"> it that</font><font color="#CCCCCC"> we</font>

416
00:14:38,949 --> 00:14:44,079
didn't use<font color="#CCCCCC"> an argument system like sitar</font>

417
00:14:41,320 --> 00:14:45,880
<font color="#CCCCCC">or Pinocchio or Lib snark</font><font color="#E5E5E5"> well we</font>

418
00:14:44,079 --> 00:14:47,739
started<font color="#E5E5E5"> out looking</font><font color="#CCCCCC"> at those systems</font><font color="#E5E5E5"> and</font>

419
00:14:45,880 --> 00:14:49,149
we said look it seems like<font color="#E5E5E5"> this</font><font color="#CCCCCC"> should</font>

420
00:14:47,740 --> 00:14:51,070
work<font color="#E5E5E5"> right we should be able to</font><font color="#CCCCCC"> get two</font>

421
00:14:49,149 --> 00:14:53,260
parallel eyes all<font color="#CCCCCC"> of these pieces of the</font>

422
00:14:51,070 --> 00:14:55,209
computation in very nice ways<font color="#E5E5E5"> but</font>

423
00:14:53,260 --> 00:14:57,310
remember we had these other two design

424
00:14:55,209 --> 00:14:59,859
principles we needed to exploit locality

425
00:14:57,310 --> 00:15:02,109
and we<font color="#E5E5E5"> needed</font><font color="#CCCCCC"> to reuse and this is where</font>

426
00:14:59,860 --> 00:15:04,449
we ran<font color="#CCCCCC"> into trouble</font><font color="#E5E5E5"> so for example in</font>

427
00:15:02,110 --> 00:15:06,279
the interactive proofs what we saw was

428
00:15:04,449 --> 00:15:07,120
that<font color="#E5E5E5"> we the prover needs to work one</font>

429
00:15:06,279 --> 00:15:09,820
layer at a time

430
00:15:07,120 --> 00:15:12,160
<font color="#CCCCCC">in these argument systems</font><font color="#E5E5E5"> the prover</font>

431
00:15:09,820 --> 00:15:13,870
works over the entire arithmetic circuit

432
00:15:12,160 --> 00:15:16,630
at once<font color="#E5E5E5"> and that means that we lose</font>

433
00:15:13,870 --> 00:15:18,430
locality and in these argument systems

434
00:15:16,630 --> 00:15:20,439
the prover needs to do a<font color="#CCCCCC"> public-key</font>

435
00:15:18,430 --> 00:15:22,209
<font color="#E5E5E5">operation for</font><font color="#CCCCCC"> every date in the</font>

436
00:15:20,440 --> 00:15:23,980
<font color="#CCCCCC">arithmetic circuit and that means that</font>

437
00:15:22,209 --> 00:15:25,989
we need<font color="#E5E5E5"> these</font><font color="#CCCCCC"> high performance crypto</font>

438
00:15:23,980 --> 00:15:28,390
primitives<font color="#CCCCCC"> in order</font><font color="#E5E5E5"> to get good</font>

439
00:15:25,990 --> 00:15:30,430
<font color="#CCCCCC">performance and that means</font><font color="#E5E5E5"> that we can't</font>

440
00:15:28,390 --> 00:15:32,130
share those circuits with other pieces

441
00:15:30,430 --> 00:15:34,349
of<font color="#E5E5E5"> the computation so</font>

442
00:15:32,130 --> 00:15:36,780
we did have parallelism<font color="#E5E5E5"> we didn't have</font>

443
00:15:34,350 --> 00:15:38,760
locality or<font color="#E5E5E5"> reuse and this is what</font>

444
00:15:36,780 --> 00:15:40,530
tripped us up<font color="#E5E5E5"> now I want to be clear</font>

445
00:15:38,760 --> 00:15:42,210
<font color="#E5E5E5">here that I'm not claiming that this is</font>

446
00:15:40,530 --> 00:15:44,040
a fundamental<font color="#CCCCCC"> thing these</font><font color="#E5E5E5"> are just</font>

447
00:15:42,210 --> 00:15:45,690
<font color="#E5E5E5">problems that we ran into and didn't see</font>

448
00:15:44,040 --> 00:15:48,630
a good solution<font color="#CCCCCC"> for</font><font color="#E5E5E5"> and we think that</font>

449
00:15:45,690 --> 00:15:51,060
<font color="#CCCCCC">this</font><font color="#E5E5E5"> is exciting</font><font color="#CCCCCC"> future work so let's</font>

450
00:15:48,630 --> 00:15:53,610
recap<font color="#E5E5E5"> we described a new approach to</font>

451
00:15:51,060 --> 00:15:56,189
<font color="#E5E5E5">building trustworthy Hardware under this</font>

452
00:15:53,610 --> 00:15:57,690
strong threat model<font color="#E5E5E5"> and we built</font>

453
00:15:56,190 --> 00:15:59,550
<font color="#E5E5E5">essentially the first Hardware</font>

454
00:15:57,690 --> 00:16:02,070
implementation of a probabilistic proof

455
00:15:59,550 --> 00:16:04,530
<font color="#CCCCCC">system</font><font color="#E5E5E5"> but the system has some</font>

456
00:16:02,070 --> 00:16:06,300
limitations<font color="#E5E5E5"> first the improvements</font>

457
00:16:04,530 --> 00:16:08,819
compared to the baseline are modest<font color="#E5E5E5"> and</font>

458
00:16:06,300 --> 00:16:10,410
second there's<font color="#E5E5E5"> this limitation in</font><font color="#CCCCCC"> terms</font>

459
00:16:08,820 --> 00:16:13,140
of the applicability that<font color="#E5E5E5"> we've just</font>

460
00:16:10,410 --> 00:16:16,439
discussed still we think<font color="#CCCCCC"> that this</font><font color="#E5E5E5"> is</font>

461
00:16:13,140 --> 00:16:18,630
<font color="#E5E5E5">maybe a cool new approach for a building</font>

462
00:16:16,440 --> 00:16:20,340
trustworthy<font color="#CCCCCC"> Hardware and we're hopeful</font>

463
00:16:18,630 --> 00:16:22,850
that<font color="#E5E5E5"> future work will</font><font color="#CCCCCC"> make the</font>

464
00:16:20,340 --> 00:16:24,810
verifiable<font color="#E5E5E5"> Asics model truly practical</font>

465
00:16:22,850 --> 00:16:27,350
<font color="#E5E5E5">with that I'm happy to take</font><font color="#CCCCCC"> any</font>

466
00:16:24,810 --> 00:16:27,349
<font color="#CCCCCC">questions</font>

467
00:16:38,089 --> 00:16:44,329
fascinating of<font color="#CCCCCC"> metics Michigan</font><font color="#E5E5E5"> a</font><font color="#CCCCCC"> to</font>

468
00:16:40,850 --> 00:16:46,759
paper<font color="#E5E5E5"> how's it going yeah I love this</font>

469
00:16:44,329 --> 00:16:48,258
I'm interested as well<font color="#E5E5E5"> in dynamic</font>

470
00:16:46,759 --> 00:16:49,759
verification of<font color="#E5E5E5"> hardware I think this is</font>

471
00:16:48,259 --> 00:16:51,920
a<font color="#E5E5E5"> fascinating take I didn't think</font><font color="#CCCCCC"> go</font>

472
00:16:49,759 --> 00:16:54,620
<font color="#E5E5E5">before it so it's great some kind of</font>

473
00:16:51,920 --> 00:16:56,240
practical questions<font color="#CCCCCC"> sure so you're</font><font color="#E5E5E5"> one</font>

474
00:16:54,620 --> 00:16:59,120
<font color="#CCCCCC">example seemed to</font><font color="#E5E5E5"> be a purely</font>

475
00:16:56,240 --> 00:17:00,560
combinational circuit<font color="#CCCCCC"> do you see any</font>

476
00:16:59,120 --> 00:17:02,810
challenges which houses<font color="#E5E5E5"> would you'd</font>

477
00:17:00,560 --> 00:17:04,520
expect if I<font color="#E5E5E5"> introduced</font><font color="#CCCCCC"> eight have a</font>

478
00:17:02,810 --> 00:17:06,829
sequential circuit<font color="#E5E5E5"> right so this</font><font color="#CCCCCC"> is a</font>

479
00:17:04,520 --> 00:17:08,089
<font color="#E5E5E5">good question remember I think</font><font color="#CCCCCC"> maybe</font><font color="#E5E5E5"> I</font>

480
00:17:06,829 --> 00:17:10,159
went<font color="#E5E5E5"> through this a little</font><font color="#CCCCCC"> quickly but</font>

481
00:17:08,089 --> 00:17:12,859
there's this restriction<font color="#E5E5E5"> in</font><font color="#CCCCCC"> the model</font>

482
00:17:10,160 --> 00:17:14,780
<font color="#E5E5E5">using interactive proofs where</font><font color="#CCCCCC"> RAM based</font>

483
00:17:12,859 --> 00:17:17,750
computations are kind of<font color="#E5E5E5"> a sticky thing</font>

484
00:17:14,780 --> 00:17:20,629
so that's that's<font color="#CCCCCC"> kind of an</font><font color="#E5E5E5"> issue with</font>

485
00:17:17,750 --> 00:17:22,459
<font color="#E5E5E5">the interactive proof based approach but</font>

486
00:17:20,630 --> 00:17:23,809
I want to sort<font color="#CCCCCC"> of back</font><font color="#E5E5E5"> up for a second</font>

487
00:17:22,459 --> 00:17:26,000
<font color="#E5E5E5">and</font><font color="#CCCCCC"> make clear that remember what I</font>

488
00:17:23,809 --> 00:17:27,829
<font color="#E5E5E5">showed</font><font color="#CCCCCC"> that circuit that was that's not</font>

489
00:17:26,000 --> 00:17:29,570
<font color="#CCCCCC">the sort</font><font color="#E5E5E5"> of that's not the physical</font>

490
00:17:27,829 --> 00:17:31,490
circuit so we inside<font color="#E5E5E5"> the</font><font color="#CCCCCC"> physical</font>

491
00:17:29,570 --> 00:17:33,918
<font color="#E5E5E5">circuit there is state but the</font>

492
00:17:31,490 --> 00:17:36,350
computation the representation<font color="#E5E5E5"> needs to</font>

493
00:17:33,919 --> 00:17:38,270
be unrolled<font color="#E5E5E5"> into</font><font color="#CCCCCC"> this arithmetic</font><font color="#E5E5E5"> circuit</font>

494
00:17:36,350 --> 00:17:40,908
with no state for all<font color="#E5E5E5"> of these systems</font>

495
00:17:38,270 --> 00:17:44,629
this is<font color="#CCCCCC"> a restriction of the system</font><font color="#E5E5E5"> okay</font>

496
00:17:40,909 --> 00:17:46,040
<font color="#CCCCCC">and also you're heavily</font><font color="#E5E5E5"> pipeline you</font>

497
00:17:44,630 --> 00:17:47,600
rely on pipelining to make things more

498
00:17:46,040 --> 00:17:50,840
efficient<font color="#E5E5E5"> so if you could imagine</font>

499
00:17:47,600 --> 00:17:52,668
applying<font color="#CCCCCC"> this to a intel</font><font color="#E5E5E5"> class processor</font>

500
00:17:50,840 --> 00:17:56,000
<font color="#E5E5E5">that already has</font><font color="#CCCCCC"> twenty</font><font color="#E5E5E5"> stages of</font>

501
00:17:52,669 --> 00:17:57,440
pipeline<font color="#E5E5E5"> and branch mispredictions if</font>

502
00:17:56,000 --> 00:18:01,730
did you roll<font color="#E5E5E5"> back everything clear at</font>

503
00:17:57,440 --> 00:18:04,309
the pipeline<font color="#CCCCCC"> could</font><font color="#E5E5E5"> you imagine clocking</font>

504
00:18:01,730 --> 00:18:05,210
processes<font color="#CCCCCC"> are at 20 gigahertz to you</font>

505
00:18:04,309 --> 00:18:07,129
know get the same kind of throughput

506
00:18:05,210 --> 00:18:09,470
<font color="#CCCCCC">that we get from those processors but</font>

507
00:18:07,130 --> 00:18:11,150
<font color="#E5E5E5">being pipelined to</font><font color="#CCCCCC"> match your</font>

508
00:18:09,470 --> 00:18:13,340
verification<font color="#E5E5E5"> system yeah that's a that's</font>

509
00:18:11,150 --> 00:18:15,740
a super fair question<font color="#CCCCCC"> i think</font><font color="#E5E5E5"> what we</font>

510
00:18:13,340 --> 00:18:17,120
saw is<font color="#E5E5E5"> maybe the kinds of computations</font>

511
00:18:15,740 --> 00:18:19,909
that that we're<font color="#E5E5E5"> really worrying about</font>

512
00:18:17,120 --> 00:18:21,590
<font color="#E5E5E5">right now are</font><font color="#CCCCCC"> a few orders</font><font color="#E5E5E5"> of magnitude</font>

513
00:18:19,909 --> 00:18:23,659
away in terms<font color="#E5E5E5"> of complexity from</font>

514
00:18:21,590 --> 00:18:25,879
something like<font color="#E5E5E5"> a full processor now in</font>

515
00:18:23,659 --> 00:18:28,450
the<font color="#E5E5E5"> literature</font><font color="#CCCCCC"> there's some very nice</font>

516
00:18:25,880 --> 00:18:31,790
work<font color="#E5E5E5"> on verifying the execution</font><font color="#CCCCCC"> of</font>

517
00:18:28,450 --> 00:18:34,340
processors<font color="#CCCCCC"> but</font><font color="#E5E5E5"> in that model that</font><font color="#CCCCCC"> the</font>

518
00:18:31,790 --> 00:18:36,559
processor<font color="#E5E5E5"> is even</font><font color="#CCCCCC"> there like quite a you</font>

519
00:18:34,340 --> 00:18:40,158
know like a very<font color="#CCCCCC"> stripped-down kind of</font>

520
00:18:36,559 --> 00:18:42,610
RISC processor and yeah so I think the

521
00:18:40,159 --> 00:18:45,490
<font color="#E5E5E5">the high level answer is</font>

522
00:18:42,610 --> 00:18:47,350
this is this is kind of a<font color="#E5E5E5"> little far</font>

523
00:18:45,490 --> 00:18:48,549
<font color="#E5E5E5">away from the ability to do something</font>

524
00:18:47,350 --> 00:18:50,919
like<font color="#E5E5E5"> a processor where there are a lot</font>

525
00:18:48,549 --> 00:18:53,200
of like<font color="#E5E5E5"> low-level bitwise operations</font><font color="#CCCCCC"> and</font>

526
00:18:50,920 --> 00:18:54,700
sort<font color="#CCCCCC"> of a lot</font><font color="#E5E5E5"> of internal state for as</font>

527
00:18:53,200 --> 00:19:00,790
you said branch prediction and<font color="#E5E5E5"> this sort</font>

528
00:18:54,700 --> 00:19:02,290
of thing hi I'm<font color="#E5E5E5"> Karina from MSR first of</font>

529
00:19:00,790 --> 00:19:06,190
<font color="#E5E5E5">all congratulations for your excellent</font>

530
00:19:02,290 --> 00:19:09,639
<font color="#E5E5E5">work and well-deserved award</font><font color="#CCCCCC"> I have one</font>

531
00:19:06,190 --> 00:19:10,929
question<font color="#CCCCCC"> so your presentation got me</font>

532
00:19:09,640 --> 00:19:12,880
thinking since you are using<font color="#E5E5E5"> an</font>

533
00:19:10,929 --> 00:19:15,960
<font color="#E5E5E5">interactive system</font><font color="#CCCCCC"> to which</font><font color="#E5E5E5"> extent</font><font color="#CCCCCC"> do</font>

534
00:19:12,880 --> 00:19:19,900
you<font color="#CCCCCC"> think you could have general-purpose</font>

535
00:19:15,960 --> 00:19:23,110
<font color="#E5E5E5">verification</font><font color="#CCCCCC"> chip instead</font><font color="#E5E5E5"> of I think</font><font color="#CCCCCC"> to</font>

536
00:19:19,900 --> 00:19:25,840
<font color="#E5E5E5">build the custom-made</font><font color="#CCCCCC"> chips for all kind</font>

537
00:19:23,110 --> 00:19:27,280
of oh so you're asking let me make sure

538
00:19:25,840 --> 00:19:29,918
I understand the question<font color="#E5E5E5"> is could we</font>

539
00:19:27,280 --> 00:19:32,139
<font color="#E5E5E5">use a general-purpose verifier chip to</font>

540
00:19:29,919 --> 00:19:34,059
work<font color="#E5E5E5"> with different provers yes exactly</font>

541
00:19:32,140 --> 00:19:36,010
yeah the<font color="#E5E5E5"> answer to that is yes there's</font>

542
00:19:34,059 --> 00:19:38,620
no doubt<font color="#CCCCCC"> so in the paper we talked about</font>

543
00:19:36,010 --> 00:19:40,450
<font color="#CCCCCC">this a little bit</font><font color="#E5E5E5"> so the way</font><font color="#CCCCCC"> that we the</font>

544
00:19:38,620 --> 00:19:44,168
<font color="#CCCCCC">the particulars of the design</font><font color="#E5E5E5"> that we</font>

545
00:19:40,450 --> 00:19:45,970
have allow sort of for a<font color="#E5E5E5"> change in the</font>

546
00:19:44,169 --> 00:19:48,160
particulars<font color="#CCCCCC"> of the computation</font><font color="#E5E5E5"> but not</font>

547
00:19:45,970 --> 00:19:49,750
the shape<font color="#CCCCCC"> of the computation but</font><font color="#E5E5E5"> even</font>

548
00:19:48,160 --> 00:19:51,250
<font color="#E5E5E5">that's not a fundamental limitation you</font>

549
00:19:49,750 --> 00:19:53,890
could imagine building a verifier<font color="#CCCCCC"> in</font>

550
00:19:51,250 --> 00:19:55,660
such a way that<font color="#E5E5E5"> it</font><font color="#CCCCCC"> takes as as sort of</font>

551
00:19:53,890 --> 00:19:57,910
<font color="#CCCCCC">part of</font><font color="#E5E5E5"> its input here's the shape of</font>

552
00:19:55,660 --> 00:19:59,290
<font color="#E5E5E5">the circuit here's the pre computations</font>

553
00:19:57,910 --> 00:20:04,169
that<font color="#E5E5E5"> go along</font><font color="#CCCCCC"> with</font><font color="#E5E5E5"> it and yes it</font><font color="#CCCCCC"> can</font>

554
00:19:59,290 --> 00:20:04,168
verify<font color="#E5E5E5"> essentially any any computation</font>

