1
00:00:07,560 --> 00:00:13,379
hello everyone<font color="#CCCCCC"> I'm</font>

2
00:00:10,680 --> 00:00:16,410
Ireland<font color="#CCCCCC"> today and</font>

3
00:00:13,380 --> 00:00:18,860
our paper<font color="#CCCCCC"> Veeran</font><font color="#E5E5E5"> foster verifiable run</font>

4
00:00:16,410 --> 00:00:22,230
this program independent<font color="#E5E5E5"> pre-processing</font>

5
00:00:18,860 --> 00:00:26,700
<font color="#CCCCCC">this is a joint work</font><font color="#E5E5E5"> with</font><font color="#CCCCCC"> 10 new Johnson</font>

6
00:00:22,230 --> 00:00:27,990
<font color="#CCCCCC">dimitra's and Bobby's so in this paper</font>

7
00:00:26,700 --> 00:00:30,290
<font color="#E5E5E5">we are considering the following</font>

8
00:00:27,990 --> 00:00:32,790
<font color="#E5E5E5">scenario where there is a</font>

9
00:00:30,290 --> 00:00:36,390
computationally weak user who wants to

10
00:00:32,790 --> 00:00:38,670
delegate the computation<font color="#E5E5E5"> of a program P</font>

11
00:00:36,390 --> 00:00:41,640
on a<font color="#E5E5E5"> particular data X to a powerful</font>

12
00:00:38,670 --> 00:00:44,340
server and receives<font color="#E5E5E5"> the result P of X</font>

13
00:00:41,640 --> 00:00:46,950
and this scenario has a lot<font color="#E5E5E5"> of</font>

14
00:00:44,340 --> 00:00:50,250
applications in practice<font color="#E5E5E5"> especially</font><font color="#CCCCCC"> with</font>

15
00:00:46,950 --> 00:00:52,740
the fast growth of<font color="#E5E5E5"> car computing so</font>

16
00:00:50,250 --> 00:00:54,600
right now there are many cloud service

17
00:00:52,740 --> 00:00:57,300
providers like<font color="#E5E5E5"> Google Amazon and</font>

18
00:00:54,600 --> 00:00:59,910
Microsoft and all of us<font color="#E5E5E5"> are using their</font>

19
00:00:57,300 --> 00:01:03,629
services delegating our data and

20
00:00:59,910 --> 00:01:06,560
computations<font color="#CCCCCC"> to the cloud</font><font color="#E5E5E5"> computing</font>

21
00:01:03,630 --> 00:01:08,610
provides<font color="#E5E5E5"> a lot of</font><font color="#CCCCCC"> benefits such as</font>

22
00:01:06,560 --> 00:01:10,710
reducing<font color="#E5E5E5"> the local computational</font>

23
00:01:08,610 --> 00:01:12,960
resources<font color="#CCCCCC"> and</font><font color="#E5E5E5"> also the effort</font><font color="#CCCCCC"> to</font>

24
00:01:10,710 --> 00:01:15,419
maintain<font color="#E5E5E5"> the local servers but in this</font>

25
00:01:12,960 --> 00:01:17,850
<font color="#E5E5E5">scenario</font><font color="#CCCCCC"> it also raises some security</font>

26
00:01:15,420 --> 00:01:20,640
concerns<font color="#CCCCCC"> and one of these concerns</font><font color="#E5E5E5"> is</font>

27
00:01:17,850 --> 00:01:23,100
called integrity<font color="#E5E5E5"> namely how can you</font>

28
00:01:20,640 --> 00:01:25,499
guarantee<font color="#CCCCCC"> that the results returned by</font>

29
00:01:23,100 --> 00:01:29,609
this<font color="#E5E5E5"> server is correctly computed by</font>

30
00:01:25,499 --> 00:01:31,589
this<font color="#E5E5E5"> program</font><font color="#CCCCCC"> on</font><font color="#E5E5E5"> the data so a</font>

31
00:01:29,609 --> 00:01:34,639
cryptographic solution to<font color="#E5E5E5"> this integrity</font>

32
00:01:31,590 --> 00:01:37,109
<font color="#E5E5E5">problem is called verifiable computation</font>

33
00:01:34,639 --> 00:01:39,210
so in verifiable<font color="#CCCCCC"> compeition we call this</font>

34
00:01:37,109 --> 00:01:41,669
user as the verifier<font color="#E5E5E5"> and called server</font>

35
00:01:39,210 --> 00:01:44,189
as approver<font color="#E5E5E5"> and</font><font color="#CCCCCC"> verifiable compeition</font>

36
00:01:41,670 --> 00:01:47,880
<font color="#E5E5E5">asks the prover to further attach a</font>

37
00:01:44,189 --> 00:01:51,208
proof<font color="#E5E5E5"> to this result and allows the</font>

38
00:01:47,880 --> 00:01:54,119
verifier to validate the correctness of

39
00:01:51,209 --> 00:01:56,609
the results using the test proof and the

40
00:01:54,119 --> 00:01:58,649
security guarantee is that<font color="#E5E5E5"> even if this</font>

41
00:01:56,609 --> 00:02:00,359
<font color="#E5E5E5">proved or is malicious which means he</font>

42
00:01:58,649 --> 00:02:02,520
<font color="#CCCCCC">could do whatever he wants it is</font>

43
00:02:00,359 --> 00:02:04,408
infeasible for<font color="#E5E5E5"> the prover to return a</font>

44
00:02:02,520 --> 00:02:06,630
wrong<font color="#CCCCCC"> result</font><font color="#E5E5E5"> and still pass the</font>

45
00:02:04,409 --> 00:02:10,920
<font color="#CCCCCC">verification so this is the security</font>

46
00:02:06,630 --> 00:02:13,470
<font color="#CCCCCC">model of verifiable computation however</font>

47
00:02:10,919 --> 00:02:16,170
this is actually<font color="#CCCCCC"> the best model we hope</font>

48
00:02:13,470 --> 00:02:18,000
to achieve<font color="#E5E5E5"> but in most existing</font>

49
00:02:16,170 --> 00:02:20,429
solutions because<font color="#CCCCCC"> of</font><font color="#E5E5E5"> the efficiency</font>

50
00:02:18,000 --> 00:02:24,060
reasons<font color="#E5E5E5"> we also require the</font><font color="#CCCCCC"> existence of</font>

51
00:02:20,430 --> 00:02:26,970
<font color="#E5E5E5">this preprocessor who is responsible to</font>

52
00:02:24,060 --> 00:02:28,890
do<font color="#CCCCCC"> a setup phase</font><font color="#E5E5E5"> and send some public</font>

53
00:02:26,970 --> 00:02:31,590
parameters to the verifier and<font color="#E5E5E5"> the</font>

54
00:02:28,890 --> 00:02:35,940
<font color="#E5E5E5">prover before the whole execution</font><font color="#CCCCCC"> of the</font>

55
00:02:31,590 --> 00:02:37,530
verifiable computation in verifiable

56
00:02:35,940 --> 00:02:40,680
competition they<font color="#E5E5E5"> are interested in the</font>

57
00:02:37,530 --> 00:02:43,230
following<font color="#E5E5E5"> efficiency measures first we</font>

58
00:02:40,680 --> 00:02:45,870
have<font color="#E5E5E5"> set up time which is a time for the</font>

59
00:02:43,230 --> 00:02:48,119
<font color="#E5E5E5">pre-processing phase and then we have</font>

60
00:02:45,870 --> 00:02:49,890
proved time and<font color="#CCCCCC"> proof ram memory</font><font color="#E5E5E5"> which</font>

61
00:02:48,120 --> 00:02:52,610
<font color="#CCCCCC">is</font><font color="#E5E5E5"> the overhead we introduced on the</font>

62
00:02:49,890 --> 00:02:55,649
<font color="#CCCCCC">prover</font><font color="#E5E5E5"> site to generate this proof and</font>

63
00:02:52,610 --> 00:02:59,400
then we have proof size and verification

64
00:02:55,650 --> 00:03:01,620
time for your information<font color="#E5E5E5"> using existing</font>

65
00:02:59,400 --> 00:03:03,300
techniques we<font color="#CCCCCC"> can already achieve very</font>

66
00:03:01,620 --> 00:03:06,510
good verification time and the proof

67
00:03:03,300 --> 00:03:10,130
size but you<font color="#CCCCCC"> really the</font><font color="#E5E5E5"> bottleneck is on</font>

68
00:03:06,510 --> 00:03:12,390
<font color="#E5E5E5">this prove your time and memory usage</font>

69
00:03:10,130 --> 00:03:14,459
<font color="#E5E5E5">namely in order for the prover to</font>

70
00:03:12,390 --> 00:03:16,230
generate this proof<font color="#E5E5E5"> we need to</font><font color="#CCCCCC"> introduce</font>

71
00:03:14,459 --> 00:03:18,870
an overhead of six to eight others

72
00:03:16,230 --> 00:03:20,280
magnitude<font color="#CCCCCC"> on this prover side compared</font>

73
00:03:18,870 --> 00:03:22,080
to merely running<font color="#E5E5E5"> the computation and</font>

74
00:03:20,280 --> 00:03:26,070
<font color="#E5E5E5">this is the major part we are trying</font><font color="#CCCCCC"> to</font>

75
00:03:22,080 --> 00:03:28,530
<font color="#E5E5E5">improve in our work in addition the</font>

76
00:03:26,070 --> 00:03:30,840
scope of our paper is as name indicates

77
00:03:28,530 --> 00:03:33,810
we are trying<font color="#E5E5E5"> to support validating</font>

78
00:03:30,840 --> 00:03:35,970
arbitrary programs that use the<font color="#CCCCCC"> very far</font>

79
00:03:33,810 --> 00:03:38,190
wants to check in the random access

80
00:03:35,970 --> 00:03:40,530
memory machine model and this<font color="#E5E5E5"> is called</font>

81
00:03:38,190 --> 00:03:45,030
generic verifiable condition on<font color="#CCCCCC"> Ram</font>

82
00:03:40,530 --> 00:03:46,739
programs so the prior work in the

83
00:03:45,030 --> 00:03:48,269
literature of<font color="#CCCCCC"> where fiber</font><font color="#E5E5E5"> run can be</font>

84
00:03:46,739 --> 00:03:50,640
<font color="#E5E5E5">roughly classified into two</font><font color="#CCCCCC"> categories</font>

85
00:03:48,269 --> 00:03:55,290
<font color="#E5E5E5">and the first category</font><font color="#CCCCCC"> is called</font><font color="#E5E5E5"> a</font>

86
00:03:50,640 --> 00:03:57,600
program dependent pre-processing it

87
00:03:55,290 --> 00:04:00,810
requires the program to<font color="#CCCCCC"> be known ahead</font>

88
00:03:57,600 --> 00:04:02,579
of time by the<font color="#E5E5E5"> preprocessor</font><font color="#CCCCCC"> to generate</font>

89
00:04:00,810 --> 00:04:04,470
the public parameters<font color="#E5E5E5"> and the public</font>

90
00:04:02,580 --> 00:04:06,870
parameters<font color="#E5E5E5"> depends on this particular</font>

91
00:04:04,470 --> 00:04:09,570
program<font color="#E5E5E5"> and the word</font><font color="#CCCCCC"> fair can only use</font>

92
00:04:06,870 --> 00:04:11,010
it to<font color="#CCCCCC"> validate the same program</font><font color="#E5E5E5"> but</font>

93
00:04:09,570 --> 00:04:14,730
<font color="#E5E5E5">potentially running on</font><font color="#CCCCCC"> different data</font>

94
00:04:11,010 --> 00:04:17,940
<font color="#CCCCCC">and because</font><font color="#E5E5E5"> the program</font><font color="#CCCCCC"> is known ahead</font>

95
00:04:14,730 --> 00:04:19,940
of time<font color="#CCCCCC"> usually</font><font color="#E5E5E5"> the program dependent</font>

96
00:04:17,940 --> 00:04:23,520
<font color="#E5E5E5">pre-processing systems can achieve</font>

97
00:04:19,940 --> 00:04:25,380
relatively better<font color="#CCCCCC"> proved efficiency but</font>

98
00:04:23,520 --> 00:04:27,659
<font color="#E5E5E5">if the word</font><font color="#CCCCCC"> are wants to validate</font>

99
00:04:25,380 --> 00:04:29,550
another program she needs to run the

100
00:04:27,660 --> 00:04:33,600
<font color="#CCCCCC">pre-processing</font><font color="#E5E5E5"> again which is very</font>

101
00:04:29,550 --> 00:04:35,250
expensive and must be<font color="#E5E5E5"> trusted the second</font>

102
00:04:33,600 --> 00:04:38,220
category is<font color="#E5E5E5"> called program independent</font>

103
00:04:35,250 --> 00:04:40,440
pre-processing<font color="#E5E5E5"> mean that the processor</font>

104
00:04:38,220 --> 00:04:42,690
only<font color="#E5E5E5"> needs to do one-time</font><font color="#CCCCCC"> setup</font>

105
00:04:40,440 --> 00:04:46,490
and later the verifier can use it to

106
00:04:42,690 --> 00:04:50,040
validate<font color="#E5E5E5"> arbitrary programs on any data</font>

107
00:04:46,490 --> 00:04:51,990
<font color="#E5E5E5">but because</font><font color="#CCCCCC"> of this generality the</font>

108
00:04:50,040 --> 00:04:54,030
<font color="#CCCCCC">poorest efficiency is much worse</font>

109
00:04:51,990 --> 00:04:57,330
<font color="#E5E5E5">compared to those systems with program</font>

110
00:04:54,030 --> 00:05:00,479
dependent<font color="#CCCCCC"> set up</font><font color="#E5E5E5"> so the major</font>

111
00:04:57,330 --> 00:05:02,490
contributing our paper we are<font color="#E5E5E5"> trying to</font>

112
00:05:00,480 --> 00:05:05,340
propose<font color="#E5E5E5"> a new</font><font color="#CCCCCC"> construction called Viren</font>

113
00:05:02,490 --> 00:05:07,470
<font color="#E5E5E5">that achieves the best of both so our</font>

114
00:05:05,340 --> 00:05:09,630
solution<font color="#E5E5E5"> is in this category of program</font>

115
00:05:07,470 --> 00:05:11,820
independent pre-processing<font color="#E5E5E5"> mean that we</font>

116
00:05:09,630 --> 00:05:14,460
only need<font color="#CCCCCC"> one time set up a later can be</font>

117
00:05:11,820 --> 00:05:16,860
<font color="#E5E5E5">used to validate arbitrary programs but</font>

118
00:05:14,460 --> 00:05:19,859
in the<font color="#E5E5E5"> meantime we improve the poor time</font>

119
00:05:16,860 --> 00:05:22,290
by around<font color="#E5E5E5"> one order</font><font color="#CCCCCC"> of magnitude</font>

120
00:05:19,860 --> 00:05:25,020
compared to<font color="#CCCCCC"> existing systems whereas</font>

121
00:05:22,290 --> 00:05:26,670
program<font color="#CCCCCC"> independent set up and this</font><font color="#E5E5E5"> is</font>

122
00:05:25,020 --> 00:05:28,680
actually comparable<font color="#E5E5E5"> to and sometimes</font>

123
00:05:26,670 --> 00:05:32,160
<font color="#E5E5E5">even faster</font><font color="#CCCCCC"> than those systems is</font>

124
00:05:28,680 --> 00:05:33,840
program dependent set up<font color="#E5E5E5"> in addition we</font>

125
00:05:32,160 --> 00:05:35,760
also<font color="#E5E5E5"> improved the memory usage</font><font color="#CCCCCC"> on the</font>

126
00:05:33,840 --> 00:05:41,460
<font color="#CCCCCC">poor side by around</font><font color="#E5E5E5"> two orders of</font>

127
00:05:35,760 --> 00:05:43,680
<font color="#E5E5E5">magnitude so next I want to show</font><font color="#CCCCCC"> you a</font>

128
00:05:41,460 --> 00:05:47,460
little<font color="#E5E5E5"> more details about the verifiable</font>

129
00:05:43,680 --> 00:05:49,830
run constructions so for all the

130
00:05:47,460 --> 00:05:52,020
existing solutions<font color="#CCCCCC"> unworkable run</font>

131
00:05:49,830 --> 00:05:55,380
<font color="#E5E5E5">including</font><font color="#CCCCCC"> ours</font><font color="#E5E5E5"> we are all</font><font color="#CCCCCC"> following this</font>

132
00:05:52,020 --> 00:05:58,229
<font color="#CCCCCC">two-step perdón</font><font color="#E5E5E5"> in the first step we are</font>

133
00:05:55,380 --> 00:06:01,110
<font color="#E5E5E5">going to</font><font color="#CCCCCC"> construct a circuit that checks</font>

134
00:05:58,230 --> 00:06:04,530
<font color="#E5E5E5">the correct execution of a particular</font>

135
00:06:01,110 --> 00:06:06,630
run program<font color="#CCCCCC"> more form is speaking the</font>

136
00:06:04,530 --> 00:06:10,169
circuit takes the program as the input

137
00:06:06,630 --> 00:06:13,020
<font color="#CCCCCC">together with the data acts</font><font color="#E5E5E5"> and acclaim</font>

138
00:06:10,169 --> 00:06:15,750
<font color="#E5E5E5">the result</font><font color="#CCCCCC"> Y</font><font color="#E5E5E5"> outputs</font><font color="#CCCCCC"> one if and only if</font>

139
00:06:13,020 --> 00:06:19,710
<font color="#E5E5E5">Y is the correct result of executing</font><font color="#CCCCCC"> the</font>

140
00:06:15,750 --> 00:06:22,050
program P on the input X and<font color="#E5E5E5"> we call</font>

141
00:06:19,710 --> 00:06:23,760
this part the front<font color="#E5E5E5"> end and the reason</font>

142
00:06:22,050 --> 00:06:27,780
why the beauty in this front end is

143
00:06:23,760 --> 00:06:30,000
<font color="#E5E5E5">because we have a many great prior work</font>

144
00:06:27,780 --> 00:06:32,400
in the literature<font color="#CCCCCC"> of</font><font color="#E5E5E5"> our</font><font color="#CCCCCC"> fabrication</font>

145
00:06:30,000 --> 00:06:34,620
<font color="#CCCCCC">that</font><font color="#E5E5E5"> we use</font><font color="#CCCCCC"> a very</font><font color="#E5E5E5"> efficient systems for</font>

146
00:06:32,400 --> 00:06:37,650
validating<font color="#E5E5E5"> the outputs of a circuit and</font>

147
00:06:34,620 --> 00:06:40,230
we can actually<font color="#E5E5E5"> use</font><font color="#CCCCCC"> one of</font><font color="#E5E5E5"> these things</font>

148
00:06:37,650 --> 00:06:42,479
<font color="#E5E5E5">one of these schemes to build a</font><font color="#CCCCCC"> back-end</font>

149
00:06:40,230 --> 00:06:43,919
<font color="#CCCCCC">on</font><font color="#E5E5E5"> this particular circuit in this way</font>

150
00:06:42,480 --> 00:06:47,040
we can<font color="#E5E5E5"> construct a verifiable</font><font color="#CCCCCC"> Ram</font>

151
00:06:43,919 --> 00:06:50,340
<font color="#E5E5E5">construction because the result the</font>

152
00:06:47,040 --> 00:06:53,820
verify received from the<font color="#E5E5E5"> prover must be</font>

153
00:06:50,340 --> 00:06:55,859
correct<font color="#CCCCCC"> if this circuit office</font><font color="#E5E5E5"> one</font>

154
00:06:53,820 --> 00:06:59,940
so this is the<font color="#CCCCCC"> two-step purling behalf</font>

155
00:06:55,860 --> 00:07:01,590
in the verifiable<font color="#CCCCCC"> Ram constructions so</font>

156
00:06:59,940 --> 00:07:07,410
in this talk<font color="#CCCCCC"> I'm going to focus</font><font color="#E5E5E5"> more on</font>

157
00:07:01,590 --> 00:07:09,119
<font color="#E5E5E5">explaining the</font><font color="#CCCCCC"> front-end so now let's</font>

158
00:07:07,410 --> 00:07:10,620
think<font color="#E5E5E5"> how can we be the</font><font color="#CCCCCC"> front end</font><font color="#E5E5E5"> how to</font>

159
00:07:09,120 --> 00:07:13,740
build a circuit to validate the

160
00:07:10,620 --> 00:07:15,420
execution of a<font color="#CCCCCC"> ram</font><font color="#E5E5E5"> program that means</font>

161
00:07:13,740 --> 00:07:18,270
<font color="#CCCCCC">you think about</font><font color="#E5E5E5"> how the run program</font>

162
00:07:15,420 --> 00:07:20,820
actually works<font color="#E5E5E5"> right</font><font color="#CCCCCC"> so basically we</font>

163
00:07:18,270 --> 00:07:23,190
have a<font color="#E5E5E5"> CPU which contains a state of</font>

164
00:07:20,820 --> 00:07:25,130
several registers a program counter<font color="#E5E5E5"> a</font>

165
00:07:23,190 --> 00:07:29,310
bunch<font color="#E5E5E5"> of flags and so on and so forth</font>

166
00:07:25,130 --> 00:07:31,680
and for<font color="#CCCCCC"> a</font><font color="#E5E5E5"> particular</font><font color="#CCCCCC"> Ram program think</font>

167
00:07:29,310 --> 00:07:33,990
about like assembly code with<font color="#E5E5E5"> a bunch of</font>

168
00:07:31,680 --> 00:07:37,200
instructions<font color="#CCCCCC"> the CPU is going to read</font>

169
00:07:33,990 --> 00:07:39,210
<font color="#E5E5E5">the</font><font color="#CCCCCC"> first</font><font color="#E5E5E5"> instruction to the addition in</font>

170
00:07:37,200 --> 00:07:40,890
<font color="#E5E5E5">this case adding the values in</font><font color="#CCCCCC"> two</font>

171
00:07:39,210 --> 00:07:42,890
registers for<font color="#CCCCCC"> the result in the</font><font color="#E5E5E5"> first</font>

172
00:07:40,890 --> 00:07:46,349
register and moves to the<font color="#CCCCCC"> next state</font>

173
00:07:42,890 --> 00:07:47,820
<font color="#E5E5E5">okay and similarly the</font><font color="#CCCCCC"> CPI</font><font color="#E5E5E5"> is going to</font>

174
00:07:46,350 --> 00:07:49,440
read the<font color="#E5E5E5"> next instruction to</font><font color="#CCCCCC"> the</font>

175
00:07:47,820 --> 00:07:52,800
<font color="#CCCCCC">multiplication and moves the next state</font>

176
00:07:49,440 --> 00:07:54,870
<font color="#CCCCCC">and here for jump</font><font color="#E5E5E5"> the CPU is</font><font color="#CCCCCC"> going to</font>

177
00:07:52,800 --> 00:07:58,290
<font color="#CCCCCC">change the program</font><font color="#E5E5E5"> counter</font><font color="#CCCCCC"> and moves to</font>

178
00:07:54,870 --> 00:08:01,500
the<font color="#CCCCCC"> next state so and so forth until the</font>

179
00:07:58,290 --> 00:08:04,290
end of the program execution<font color="#E5E5E5"> this is</font>

180
00:08:01,500 --> 00:08:07,920
roughly<font color="#E5E5E5"> how our</font><font color="#CCCCCC"> computer works and in</font>

181
00:08:04,290 --> 00:08:12,240
this way the CPU<font color="#E5E5E5"> is going to produce a</font>

182
00:08:07,920 --> 00:08:15,150
sequence<font color="#E5E5E5"> of the states like this so now</font>

183
00:08:12,240 --> 00:08:19,890
for simplicity<font color="#E5E5E5"> let's say users data is</font>

184
00:08:15,150 --> 00:08:22,560
inside the first CPU<font color="#E5E5E5"> state and the</font>

185
00:08:19,890 --> 00:08:25,950
result of this<font color="#E5E5E5"> program execution is in</font>

186
00:08:22,560 --> 00:08:27,840
the last CPU state<font color="#E5E5E5"> this is just for the</font>

187
00:08:25,950 --> 00:08:29,820
<font color="#E5E5E5">simplicity of explanation and we</font>

188
00:08:27,840 --> 00:08:32,970
<font color="#E5E5E5">actually support much larger inputs and</font>

189
00:08:29,820 --> 00:08:35,220
outputs<font color="#CCCCCC"> a ton</font><font color="#E5E5E5"> in a single CPU</font><font color="#CCCCCC"> state but</font>

190
00:08:32,970 --> 00:08:38,130
let's assume it is in the first and<font color="#CCCCCC"> last</font>

191
00:08:35,220 --> 00:08:40,770
date<font color="#E5E5E5"> like this</font><font color="#CCCCCC"> then we can construct a</font>

192
00:08:38,130 --> 00:08:43,110
circuit to validate execution of a run

193
00:08:40,770 --> 00:08:45,810
program like this so this circuit

194
00:08:43,110 --> 00:08:48,480
contains many copies of a small CPU

195
00:08:45,810 --> 00:08:50,430
circuit and each copy is responsible to

196
00:08:48,480 --> 00:08:54,150
check<font color="#E5E5E5"> that</font><font color="#CCCCCC"> the two constructive states</font>

197
00:08:50,430 --> 00:08:56,760
are correctly computed<font color="#CCCCCC"> okay and in this</font>

198
00:08:54,150 --> 00:09:00,000
way the<font color="#CCCCCC"> CPU that the whole circuit is</font>

199
00:08:56,760 --> 00:09:02,160
<font color="#E5E5E5">going to</font><font color="#CCCCCC"> op1 if and only if the program</font>

200
00:09:00,000 --> 00:09:03,690
execution is correct<font color="#E5E5E5"> because if there's</font>

201
00:09:02,160 --> 00:09:04,469
anything wrong<font color="#CCCCCC"> in the middle of</font><font color="#E5E5E5"> the</font>

202
00:09:03,690 --> 00:09:06,630
execution

203
00:09:04,470 --> 00:09:07,020
once they it will<font color="#E5E5E5"> not be consistent with</font>

204
00:09:06,630 --> 00:09:09,000
the pre

205
00:09:07,020 --> 00:09:13,020
this one and<font color="#CCCCCC"> that trigger copy will</font>

206
00:09:09,000 --> 00:09:14,790
report an error and then for this

207
00:09:13,020 --> 00:09:16,890
particular<font color="#E5E5E5"> circuit the verifier is going</font>

208
00:09:14,790 --> 00:09:20,550
to<font color="#E5E5E5"> improve the program that</font><font color="#CCCCCC"> inputs acts</font>

209
00:09:16,890 --> 00:09:23,850
<font color="#E5E5E5">and also the result received from the</font>

210
00:09:20,550 --> 00:09:26,219
prover and the<font color="#E5E5E5"> prover is responsible to</font>

211
00:09:23,850 --> 00:09:28,110
<font color="#CCCCCC">feed in all the other states</font><font color="#E5E5E5"> in</font><font color="#CCCCCC"> this</font>

212
00:09:26,220 --> 00:09:29,760
sequence<font color="#E5E5E5"> and the good thing about this</font>

213
00:09:28,110 --> 00:09:31,410
construction<font color="#E5E5E5"> is</font><font color="#CCCCCC"> the prover does not</font><font color="#E5E5E5"> need</font>

214
00:09:29,760 --> 00:09:34,319
to send the whole thing back to<font color="#CCCCCC"> the</font>

215
00:09:31,410 --> 00:09:37,140
<font color="#CCCCCC">verifier</font><font color="#E5E5E5"> the prover just proves that</font>

216
00:09:34,320 --> 00:09:40,410
<font color="#E5E5E5">there exists such such type</font><font color="#CCCCCC"> of sequence</font>

217
00:09:37,140 --> 00:09:42,350
<font color="#E5E5E5">that satisfy the circuit and this is a</font>

218
00:09:40,410 --> 00:09:46,589
simplified<font color="#CCCCCC"> version</font><font color="#E5E5E5"> of the existing</font>

219
00:09:42,350 --> 00:09:49,830
<font color="#CCCCCC">front-end for</font><font color="#E5E5E5"> where fiber</font><font color="#CCCCCC"> Ram one thing</font>

220
00:09:46,590 --> 00:09:51,420
<font color="#E5E5E5">I omit here is to be precise the</font><font color="#CCCCCC"> CPU</font>

221
00:09:49,830 --> 00:09:53,820
also needs to<font color="#CCCCCC"> interact with</font><font color="#E5E5E5"> the memory</font>

222
00:09:51,420 --> 00:09:55,650
and is actually<font color="#E5E5E5"> much harder to construct</font>

223
00:09:53,820 --> 00:09:58,200
a circuit to validate the memory<font color="#CCCCCC"> write</font>

224
00:09:55,650 --> 00:10:01,439
and memory read and in one<font color="#E5E5E5"> of the prior</font>

225
00:09:58,200 --> 00:10:03,750
work<font color="#E5E5E5"> they construct a very elegant</font>

226
00:10:01,440 --> 00:10:06,210
<font color="#E5E5E5">circuit to check the memory consistency</font>

227
00:10:03,750 --> 00:10:11,040
<font color="#E5E5E5">but I'm not going to</font><font color="#CCCCCC"> present the</font><font color="#E5E5E5"> details</font>

228
00:10:06,210 --> 00:10:13,320
in<font color="#E5E5E5"> this talk so using this</font><font color="#CCCCCC"> front-end</font>

229
00:10:11,040 --> 00:10:17,329
<font color="#E5E5E5">there is actually a trade-off in the</font>

230
00:10:13,320 --> 00:10:21,120
existing work<font color="#E5E5E5"> between the</font><font color="#CCCCCC"> two categories</font>

231
00:10:17,330 --> 00:10:25,290
<font color="#E5E5E5">so if we</font><font color="#CCCCCC"> zoom in to one of the</font><font color="#E5E5E5"> one copy</font>

232
00:10:21,120 --> 00:10:26,660
of<font color="#E5E5E5"> this CPU circuit in one case if you</font>

233
00:10:25,290 --> 00:10:29,339
<font color="#E5E5E5">want the</font><font color="#CCCCCC"> program independent</font>

234
00:10:26,660 --> 00:10:33,480
<font color="#E5E5E5">pre-processing which means the program</font>

235
00:10:29,340 --> 00:10:35,640
<font color="#E5E5E5">is not known ahead of time then</font><font color="#CCCCCC"> we this</font>

236
00:10:33,480 --> 00:10:37,920
small<font color="#CCCCCC"> CPU circuit</font><font color="#E5E5E5"> must be responsible</font>

237
00:10:35,640 --> 00:10:39,930
<font color="#CCCCCC">for all possible CPI instructions</font>

238
00:10:37,920 --> 00:10:42,060
<font color="#E5E5E5">because</font><font color="#CCCCCC"> you have no</font><font color="#E5E5E5"> idea which one will</font>

239
00:10:39,930 --> 00:10:44,150
be<font color="#CCCCCC"> executed during</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> runtime because</font>

240
00:10:42,060 --> 00:10:47,160
you don't know the program ahead of time

241
00:10:44,150 --> 00:10:49,490
<font color="#E5E5E5">that's why this small CPU circuit is</font>

242
00:10:47,160 --> 00:10:51,959
actually consists of<font color="#E5E5E5"> all possible</font>

243
00:10:49,490 --> 00:10:55,590
<font color="#CCCCCC">instructions side-by-side and the</font><font color="#E5E5E5"> size</font>

244
00:10:51,960 --> 00:10:58,290
of the circuit is larger<font color="#CCCCCC"> on</font><font color="#E5E5E5"> the other</font>

245
00:10:55,590 --> 00:11:01,080
hand if the program<font color="#E5E5E5"> is fixed ahead of</font>

246
00:10:58,290 --> 00:11:03,750
time then<font color="#CCCCCC"> we can do some optimizations</font>

247
00:11:01,080 --> 00:11:06,240
<font color="#CCCCCC">to identify one or possible</font><font color="#E5E5E5"> sibling</font>

248
00:11:03,750 --> 00:11:08,250
instructions<font color="#E5E5E5"> at each step so let's</font><font color="#CCCCCC"> say</font>

249
00:11:06,240 --> 00:11:11,070
<font color="#E5E5E5">that if you know your program is going</font>

250
00:11:08,250 --> 00:11:13,110
to run<font color="#E5E5E5"> addition in the first step no</font>

251
00:11:11,070 --> 00:11:14,550
matter<font color="#E5E5E5"> what you input you</font><font color="#CCCCCC"> have then</font><font color="#E5E5E5"> you</font>

252
00:11:13,110 --> 00:11:17,010
only need<font color="#CCCCCC"> to construct the circuit</font><font color="#E5E5E5"> for</font>

253
00:11:14,550 --> 00:11:19,199
addition at the<font color="#E5E5E5"> first step in this way</font>

254
00:11:17,010 --> 00:11:20,370
the circuit is much smaller compared to

255
00:11:19,200 --> 00:11:22,890
<font color="#E5E5E5">the first case</font>

256
00:11:20,370 --> 00:11:25,890
but the drawback is<font color="#CCCCCC"> that the circuit can</font>

257
00:11:22,890 --> 00:11:27,870
only validate one particular<font color="#E5E5E5"> program</font><font color="#CCCCCC"> if</font>

258
00:11:25,890 --> 00:11:29,850
you change the program the behavior will

259
00:11:27,870 --> 00:11:32,190
be different<font color="#E5E5E5"> and your circuit is not</font>

260
00:11:29,850 --> 00:11:35,490
valid anymore<font color="#CCCCCC"> that's</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> trade off in</font>

261
00:11:32,190 --> 00:11:38,640
the existing<font color="#E5E5E5"> two category of work so in</font>

262
00:11:35,490 --> 00:11:41,160
our paper<font color="#CCCCCC"> we</font><font color="#E5E5E5"> propose a new construction</font>

263
00:11:38,640 --> 00:11:42,930
of the<font color="#CCCCCC"> front-end and the key idea of</font><font color="#E5E5E5"> our</font>

264
00:11:41,160 --> 00:11:45,300
construction<font color="#CCCCCC"> is we are going to generate</font>

265
00:11:42,930 --> 00:11:48,000
<font color="#CCCCCC">this circuit</font><font color="#E5E5E5"> on the fly after the</font>

266
00:11:45,300 --> 00:11:50,790
<font color="#E5E5E5">execution of the program so let's</font><font color="#CCCCCC"> say</font>

267
00:11:48,000 --> 00:11:53,339
after some pre-processing phase that<font color="#CCCCCC"> is</font>

268
00:11:50,790 --> 00:11:55,829
independent of the<font color="#E5E5E5"> program the verifier</font>

269
00:11:53,339 --> 00:11:58,140
<font color="#CCCCCC">comes up with a particular</font><font color="#E5E5E5"> run program</font>

270
00:11:55,830 --> 00:12:00,570
and the input<font color="#E5E5E5"> send it to the prover and</font>

271
00:11:58,140 --> 00:12:02,580
with this program<font color="#CCCCCC"> and the input the</font>

272
00:12:00,570 --> 00:12:05,130
prover can produce exactly<font color="#CCCCCC"> the whole</font>

273
00:12:02,580 --> 00:12:07,890
sequence of the state I know exactly

274
00:12:05,130 --> 00:12:10,080
which instruction is<font color="#CCCCCC"> executed</font><font color="#E5E5E5"> because</font>

275
00:12:07,890 --> 00:12:13,529
<font color="#CCCCCC">the</font><font color="#E5E5E5"> program and the data are all fixed</font>

276
00:12:10,080 --> 00:12:15,720
<font color="#E5E5E5">this</font><font color="#CCCCCC"> thing is deterministic</font><font color="#E5E5E5"> but now the</font>

277
00:12:13,529 --> 00:12:17,700
challenge<font color="#E5E5E5"> is how</font><font color="#CCCCCC"> does the prover</font>

278
00:12:15,720 --> 00:12:19,410
communicate this<font color="#CCCCCC"> information back</font><font color="#E5E5E5"> to the</font>

279
00:12:17,700 --> 00:12:22,260
verifier<font color="#E5E5E5"> right how</font><font color="#CCCCCC"> does the</font><font color="#E5E5E5"> BER fire</font>

280
00:12:19,410 --> 00:12:24,240
knows what circuit and validating if you

281
00:12:22,260 --> 00:12:27,420
send the whole thing back to the were

282
00:12:24,240 --> 00:12:30,440
<font color="#CCCCCC">fireside is</font><font color="#E5E5E5"> simply too big</font><font color="#CCCCCC"> it's as</font><font color="#E5E5E5"> big</font>

283
00:12:27,420 --> 00:12:33,150
<font color="#CCCCCC">as the running time of the program</font><font color="#E5E5E5"> and</font>

284
00:12:30,440 --> 00:12:35,070
so if you send this whole thing back to

285
00:12:33,150 --> 00:12:37,949
<font color="#E5E5E5">the</font><font color="#CCCCCC"> verifier is actually slower than</font>

286
00:12:35,070 --> 00:12:40,070
running<font color="#E5E5E5"> the</font><font color="#CCCCCC"> whole thing on on her own so</font>

287
00:12:37,950 --> 00:12:42,779
this whole thing is meaningless

288
00:12:40,070 --> 00:12:45,180
so in our paper<font color="#E5E5E5"> we propose a way to</font>

289
00:12:42,779 --> 00:12:47,850
solve<font color="#E5E5E5"> this</font><font color="#CCCCCC"> problem so we are going</font><font color="#E5E5E5"> to</font>

290
00:12:45,180 --> 00:12:51,829
<font color="#E5E5E5">arrange this</font><font color="#CCCCCC"> States by their instruction</font>

291
00:12:47,850 --> 00:12:54,570
type<font color="#E5E5E5"> okay so after</font><font color="#CCCCCC"> that we observe that</font>

292
00:12:51,830 --> 00:12:57,150
the same type of instructions will<font color="#CCCCCC"> be</font>

293
00:12:54,570 --> 00:12:58,529
packed together<font color="#CCCCCC"> and for example the</font>

294
00:12:57,150 --> 00:13:00,120
<font color="#E5E5E5">first whole battery</font><font color="#CCCCCC"> will</font><font color="#E5E5E5"> all be</font>

295
00:12:58,529 --> 00:13:01,950
<font color="#CCCCCC">additions followed by all</font>

296
00:13:00,120 --> 00:13:05,130
multiplications<font color="#E5E5E5"> and then all memory</font>

297
00:13:01,950 --> 00:13:07,020
loads<font color="#E5E5E5"> all</font><font color="#CCCCCC"> jams</font><font color="#E5E5E5"> and so and so forth so it</font>

298
00:13:05,130 --> 00:13:09,209
is much simpler<font color="#CCCCCC"> for the prover to send</font>

299
00:13:07,020 --> 00:13:12,029
the information<font color="#E5E5E5"> back to the verifier the</font>

300
00:13:09,209 --> 00:13:13,709
prover can simply send one number to

301
00:13:12,029 --> 00:13:15,660
represent<font color="#E5E5E5"> how</font><font color="#CCCCCC"> many times each</font>

302
00:13:13,709 --> 00:13:19,050
instruction<font color="#E5E5E5"> is executed during the whole</font>

303
00:13:15,660 --> 00:13:20,699
program<font color="#E5E5E5"> right so in this way the prune</font>

304
00:13:19,050 --> 00:13:23,250
is<font color="#E5E5E5"> only to send one value per</font>

305
00:13:20,700 --> 00:13:25,430
instruction back to the<font color="#E5E5E5"> client and the</font>

306
00:13:23,250 --> 00:13:27,570
verifier can use this information<font color="#E5E5E5"> to</font>

307
00:13:25,430 --> 00:13:31,349
<font color="#E5E5E5">construct a circuit on the fly</font>

308
00:13:27,570 --> 00:13:33,710
<font color="#CCCCCC">efficiently</font><font color="#E5E5E5"> and succinctly and the final</font>

309
00:13:31,350 --> 00:13:35,750
piece<font color="#CCCCCC"> of the circuit is means</font>

310
00:13:33,710 --> 00:13:38,120
guarantee that this new sequence of

311
00:13:35,750 --> 00:13:40,340
<font color="#E5E5E5">states is consistent with original</font>

312
00:13:38,120 --> 00:13:42,410
sequence<font color="#E5E5E5"> ordered by the execution time</font>

313
00:13:40,340 --> 00:13:44,300
<font color="#E5E5E5">so finally we are going to construct the</font>

314
00:13:42,410 --> 00:13:46,069
circuit<font color="#CCCCCC"> to check</font><font color="#E5E5E5"> that</font><font color="#CCCCCC"> there these</font><font color="#E5E5E5"> two</font>

315
00:13:44,300 --> 00:13:49,160
<font color="#CCCCCC">sequences are permutations</font><font color="#E5E5E5"> with each</font>

316
00:13:46,070 --> 00:13:52,310
other<font color="#E5E5E5"> and that completes the whole front</font>

317
00:13:49,160 --> 00:13:54,770
end of our work with this information

318
00:13:52,310 --> 00:13:57,079
<font color="#CCCCCC">the verifier can run the back end with</font>

319
00:13:54,770 --> 00:14:00,500
the prover to prove that<font color="#E5E5E5"> the circuit</font>

320
00:13:57,080 --> 00:14:02,540
<font color="#CCCCCC">will</font><font color="#E5E5E5"> up one on the result P of X the</font>

321
00:14:00,500 --> 00:14:04,070
prover sent to me and this<font color="#CCCCCC"> guarantees</font>

322
00:14:02,540 --> 00:14:07,849
that<font color="#CCCCCC"> the result of</font><font color="#E5E5E5"> the program is</font>

323
00:14:04,070 --> 00:14:09,470
correctly<font color="#E5E5E5"> computed and observe that</font>

324
00:14:07,850 --> 00:14:11,060
during the whole process<font color="#CCCCCC"> the</font><font color="#E5E5E5"> verifier</font>

325
00:14:09,470 --> 00:14:12,680
never receives anything that is

326
00:14:11,060 --> 00:14:15,650
proportional<font color="#CCCCCC"> to</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> length of the</font>

327
00:14:12,680 --> 00:14:17,510
program<font color="#E5E5E5"> everything is constant or the</font>

328
00:14:15,650 --> 00:14:18,860
<font color="#E5E5E5">same as</font><font color="#CCCCCC"> the number of</font><font color="#E5E5E5"> instructions no</font>

329
00:14:17,510 --> 00:14:23,540
matter how long<font color="#E5E5E5"> your program is</font>

330
00:14:18,860 --> 00:14:25,760
executing so finally we also have some

331
00:14:23,540 --> 00:14:27,740
improvements<font color="#CCCCCC"> on</font><font color="#E5E5E5"> the back end</font><font color="#CCCCCC"> so we need</font>

332
00:14:25,760 --> 00:14:29,660
to choose<font color="#E5E5E5"> the</font><font color="#CCCCCC"> correct</font><font color="#E5E5E5"> back end</font><font color="#CCCCCC"> that is</font>

333
00:14:27,740 --> 00:14:31,850
suitable<font color="#E5E5E5"> for our application namely</font><font color="#CCCCCC"> that</font>

334
00:14:29,660 --> 00:14:34,370
<font color="#E5E5E5">we do</font><font color="#CCCCCC"> not</font><font color="#E5E5E5"> want the circuit to be fixed</font>

335
00:14:31,850 --> 00:14:37,880
ahead<font color="#CCCCCC"> of time so</font><font color="#E5E5E5"> we replace the back end</font>

336
00:14:34,370 --> 00:14:40,070
in the existing work there's a different

337
00:14:37,880 --> 00:14:41,990
<font color="#CCCCCC">construction that was proposed in last</font>

338
00:14:40,070 --> 00:14:43,850
year's Auckland<font color="#E5E5E5"> and the</font><font color="#CCCCCC"> key</font><font color="#E5E5E5"> difference</font>

339
00:14:41,990 --> 00:14:45,890
is<font color="#CCCCCC"> that it requires a circuit</font>

340
00:14:43,850 --> 00:14:47,840
independent<font color="#CCCCCC"> setup phase</font><font color="#E5E5E5"> so that</font><font color="#CCCCCC"> we can</font>

341
00:14:45,890 --> 00:14:51,110
generate<font color="#E5E5E5"> the circuit on the fly without</font>

342
00:14:47,840 --> 00:14:54,100
a separate pre-processing<font color="#CCCCCC"> and we also</font>

343
00:14:51,110 --> 00:14:56,990
have some improvements<font color="#CCCCCC"> on this back end</font>

344
00:14:54,100 --> 00:14:59,270
we construct<font color="#CCCCCC"> linear time</font><font color="#E5E5E5"> verify the</font>

345
00:14:56,990 --> 00:15:01,730
polynomial delegation part and also make

346
00:14:59,270 --> 00:15:03,410
the<font color="#E5E5E5"> interactive proof part more</font>

347
00:15:01,730 --> 00:15:05,270
efficient for<font color="#E5E5E5"> the front end we</font><font color="#CCCCCC"> are</font>

348
00:15:03,410 --> 00:15:06,650
building and you<font color="#E5E5E5"> can refer to our paper</font>

349
00:15:05,270 --> 00:15:11,120
for more details about<font color="#CCCCCC"> these</font>

350
00:15:06,650 --> 00:15:12,459
<font color="#E5E5E5">improvements so finally I just want to</font>

351
00:15:11,120 --> 00:15:15,140
<font color="#E5E5E5">quickly show some experimental results</font>

352
00:15:12,460 --> 00:15:16,760
<font color="#CCCCCC">so we implement our system and these</font><font color="#E5E5E5"> two</font>

353
00:15:15,140 --> 00:15:19,370
figures<font color="#E5E5E5"> shows the comparison there's</font>

354
00:15:16,760 --> 00:15:22,069
existing systems with in program

355
00:15:19,370 --> 00:15:25,010
independent pre-processing<font color="#E5E5E5"> as you can</font>

356
00:15:22,070 --> 00:15:27,440
see on the first figure<font color="#E5E5E5"> we improved the</font>

357
00:15:25,010 --> 00:15:30,170
prover time by around<font color="#E5E5E5"> night times</font>

358
00:15:27,440 --> 00:15:31,520
compared<font color="#E5E5E5"> to the best system so far</font>

359
00:15:30,170 --> 00:15:35,060
called one tiny<font color="#E5E5E5"> one in</font><font color="#CCCCCC"> terms</font><font color="#E5E5E5"> of</font>

360
00:15:31,520 --> 00:15:36,680
<font color="#E5E5E5">efficiency in addition on</font><font color="#CCCCCC"> the second</font>

361
00:15:35,060 --> 00:15:39,439
figure we show that we<font color="#CCCCCC"> can reduce</font><font color="#E5E5E5"> the</font>

362
00:15:36,680 --> 00:15:42,050
<font color="#CCCCCC">memory</font><font color="#E5E5E5"> usage on a truer side by 120</font>

363
00:15:39,440 --> 00:15:44,750
<font color="#E5E5E5">times which enables to support</font>

364
00:15:42,050 --> 00:15:46,410
validating a program that is much larger

365
00:15:44,750 --> 00:15:48,750
<font color="#E5E5E5">than before</font>

366
00:15:46,410 --> 00:15:51,269
or running<font color="#E5E5E5"> on the same machine so we can</font>

367
00:15:48,750 --> 00:15:54,300
achieve<font color="#E5E5E5"> validating</font><font color="#CCCCCC"> Ram program up to</font><font color="#E5E5E5"> two</font>

368
00:15:51,269 --> 00:15:58,199
million CPU cycles<font color="#E5E5E5"> versus 332</font><font color="#CCCCCC"> K as</font>

369
00:15:54,300 --> 00:16:01,979
before in addition we<font color="#E5E5E5"> also run we also</font>

370
00:15:58,199 --> 00:16:04,560
test a<font color="#E5E5E5"> bunch of many</font><font color="#CCCCCC"> Ram programs like</font>

371
00:16:01,980 --> 00:16:07,050
porn in tracing<font color="#CCCCCC"> mergesort stream search</font>

372
00:16:04,560 --> 00:16:10,410
and matrix multiplication<font color="#E5E5E5"> and we show</font>

373
00:16:07,050 --> 00:16:11,939
that<font color="#E5E5E5"> in terms of</font><font color="#CCCCCC"> per time again we are</font>

374
00:16:10,410 --> 00:16:13,980
faster than one<font color="#E5E5E5"> tiny</font><font color="#CCCCCC"> one and even</font>

375
00:16:11,939 --> 00:16:16,920
<font color="#E5E5E5">compared</font><font color="#CCCCCC"> to a system that requires</font>

376
00:16:13,980 --> 00:16:18,329
<font color="#CCCCCC">program dependent setup bethey</font><font color="#E5E5E5"> we</font>

377
00:16:16,920 --> 00:16:20,729
<font color="#E5E5E5">actually the performance is comparable</font>

378
00:16:18,329 --> 00:16:22,969
<font color="#E5E5E5">and</font><font color="#CCCCCC"> sometimes faster than this system</font>

379
00:16:20,730 --> 00:16:25,500
and remember<font color="#E5E5E5"> this system requires</font><font color="#CCCCCC"> a</font>

380
00:16:22,970 --> 00:16:28,649
separate<font color="#CCCCCC"> setup phase for each</font><font color="#E5E5E5"> program</font>

381
00:16:25,500 --> 00:16:30,180
you want<font color="#E5E5E5"> to run and we also have some</font>

382
00:16:28,649 --> 00:16:32,069
other optimizations for<font color="#E5E5E5"> Poligrip</font>

383
00:16:30,180 --> 00:16:33,810
programs to get<font color="#E5E5E5"> some additional speed up</font>

384
00:16:32,069 --> 00:16:36,810
and<font color="#E5E5E5"> you can refer to the paper for more</font>

385
00:16:33,810 --> 00:16:40,290
details and<font color="#CCCCCC"> finally we do have some</font>

386
00:16:36,810 --> 00:16:43,170
drawbacks<font color="#CCCCCC"> we do increase the proof size</font>

387
00:16:40,290 --> 00:16:44,879
and the verification time but as I<font color="#CCCCCC"> said</font>

388
00:16:43,170 --> 00:16:48,000
these are<font color="#CCCCCC"> URI not</font><font color="#E5E5E5"> born acts of the</font>

389
00:16:44,879 --> 00:16:50,759
system so we<font color="#CCCCCC"> can still reach less than</font>

390
00:16:48,000 --> 00:16:52,019
<font color="#E5E5E5">200 kilobytes of the true size and less</font>

391
00:16:50,759 --> 00:16:55,019
than 100<font color="#CCCCCC"> milliseconds</font><font color="#E5E5E5"> of the</font>

392
00:16:52,019 --> 00:16:56,870
verification<font color="#CCCCCC"> time</font><font color="#E5E5E5"> on all instances we</font>

393
00:16:55,019 --> 00:16:59,670
are<font color="#E5E5E5"> running</font><font color="#CCCCCC"> forever program program and</font>

394
00:16:56,870 --> 00:17:02,430
finally this work on<font color="#E5E5E5"> its</font><font color="#CCCCCC"> own does not</font>

395
00:16:59,670 --> 00:17:04,168
<font color="#E5E5E5">support zero</font><font color="#CCCCCC"> knowledge but we are</font>

396
00:17:02,430 --> 00:17:06,780
working towards making zero knowledge

397
00:17:04,169 --> 00:17:08,730
<font color="#E5E5E5">and you can take a look at our paper on</font>

398
00:17:06,780 --> 00:17:11,399
ePrint<font color="#E5E5E5"> and actually the paper in the</font>

399
00:17:08,730 --> 00:17:14,669
next<font color="#E5E5E5"> next talk is going to give a</font><font color="#CCCCCC"> zero</font>

400
00:17:11,400 --> 00:17:16,289
<font color="#E5E5E5">knowledge version of the back end</font><font color="#CCCCCC"> to sum</font>

401
00:17:14,669 --> 00:17:18,390
up in this<font color="#E5E5E5"> paper we proposed the</font>

402
00:17:16,289 --> 00:17:20,099
construction for<font color="#CCCCCC"> where fiber run that</font>

403
00:17:18,390 --> 00:17:22,829
requires program independent

404
00:17:20,099 --> 00:17:24,719
<font color="#CCCCCC">pre-processing</font><font color="#E5E5E5"> we have optimizations</font>

405
00:17:22,829 --> 00:17:27,658
both on the front<font color="#CCCCCC"> end and the back end</font>

406
00:17:24,720 --> 00:17:29,850
<font color="#E5E5E5">and also the implement whole system may</font>

407
00:17:27,659 --> 00:17:32,250
show that it<font color="#CCCCCC"> is one other one</font><font color="#E5E5E5"> two orders</font>

408
00:17:29,850 --> 00:17:35,189
of magnitude<font color="#CCCCCC"> better in terms of tour</font>

409
00:17:32,250 --> 00:17:37,430
time and memory<font color="#CCCCCC"> usage so that's all my</font>

410
00:17:35,190 --> 00:17:42,239
talk<font color="#CCCCCC"> thank you</font>

411
00:17:37,430 --> 00:17:42,239
[Applause]

412
00:17:48,490 --> 00:17:52,820
<font color="#CCCCCC">um please</font><font color="#E5E5E5"> come up to the microphone if</font>

413
00:17:51,110 --> 00:17:54,590
<font color="#E5E5E5">you have questions</font><font color="#CCCCCC"> and I remind you</font><font color="#E5E5E5"> that</font>

414
00:17:52,820 --> 00:17:57,020
if you<font color="#E5E5E5"> can state your name and</font>

415
00:17:54,590 --> 00:17:58,429
affiliation<font color="#CCCCCC"> before the question since</font>

416
00:17:57,020 --> 00:18:01,070
<font color="#E5E5E5">this is the choreography session it's</font>

417
00:17:58,430 --> 00:18:03,170
also<font color="#E5E5E5"> okay to state a hash of your</font>

418
00:18:01,070 --> 00:18:07,790
identity instead<font color="#E5E5E5"> if you prefer to keep</font>

419
00:18:03,170 --> 00:18:12,710
anonymous<font color="#E5E5E5"> so come up with questions let</font>

420
00:18:07,790 --> 00:18:14,389
<font color="#CCCCCC">me start with a</font><font color="#E5E5E5"> question so I I didn't</font>

421
00:18:12,710 --> 00:18:16,730
quite understand how when<font color="#E5E5E5"> you connect</font>

422
00:18:14,390 --> 00:18:18,920
the<font color="#CCCCCC"> sub-circuits that now you the the</font>

423
00:18:16,730 --> 00:18:21,410
verifier just has a count of<font color="#E5E5E5"> them they</font>

424
00:18:18,920 --> 00:18:22,910
know that the prover executed them and

425
00:18:21,410 --> 00:18:25,130
corrected that connected<font color="#E5E5E5"> them with the</font>

426
00:18:22,910 --> 00:18:31,580
inputs in the correct<font color="#CCCCCC"> way is there a way</font>

427
00:18:25,130 --> 00:18:35,480
to<font color="#E5E5E5"> ensure that</font><font color="#CCCCCC"> provided the</font><font color="#E5E5E5"> right inputs</font>

428
00:18:31,580 --> 00:18:38,540
<font color="#E5E5E5">and executed the sub circuits in the way</font>

429
00:18:35,480 --> 00:18:40,880
that the function required actually that

430
00:18:38,540 --> 00:18:44,030
<font color="#E5E5E5">that is related to the back end</font><font color="#CCCCCC"> because</font>

431
00:18:40,880 --> 00:18:46,550
the back ends of this like a different

432
00:18:44,030 --> 00:18:48,379
<font color="#CCCCCC">back end requires only</font><font color="#E5E5E5"> the verifier</font>

433
00:18:46,550 --> 00:18:50,600
knows<font color="#CCCCCC"> a</font><font color="#E5E5E5"> succinct description of the</font>

434
00:18:48,380 --> 00:18:53,390
circuit<font color="#CCCCCC"> maybe how many</font><font color="#E5E5E5"> copies do we have</font>

435
00:18:50,600 --> 00:18:55,189
and the<font color="#E5E5E5"> connection</font><font color="#CCCCCC"> within each small</font>

436
00:18:53,390 --> 00:18:58,820
copy<font color="#E5E5E5"> of the CPU circuit and that's</font>

437
00:18:55,190 --> 00:19:00,830
enough for<font color="#CCCCCC"> the verifier to talk to the</font>

438
00:18:58,820 --> 00:19:07,189
prover and make sure that the result

439
00:19:00,830 --> 00:19:10,370
produced<font color="#E5E5E5"> by the circuit is correct</font><font color="#CCCCCC"> okay</font>

440
00:19:07,190 --> 00:19:12,320
<font color="#CCCCCC">one more</font><font color="#E5E5E5"> question so that and I think</font>

441
00:19:10,370 --> 00:19:14,000
<font color="#CCCCCC">you you hinted getting towards this at</font>

442
00:19:12,320 --> 00:19:15,080
the end<font color="#E5E5E5"> of the talk but one</font><font color="#CCCCCC"> of the</font>

443
00:19:14,000 --> 00:19:17,420
things that really really<font color="#E5E5E5"> makes these</font>

444
00:19:15,080 --> 00:19:20,060
kinds of systems<font color="#CCCCCC"> or a compelling</font><font color="#E5E5E5"> is if</font>

445
00:19:17,420 --> 00:19:21,470
there can<font color="#E5E5E5"> be</font><font color="#CCCCCC"> private data for the prover</font>

446
00:19:20,060 --> 00:19:25,220
that's part of the function<font color="#CCCCCC"> you're</font>

447
00:19:21,470 --> 00:19:27,140
computing as well<font color="#CCCCCC"> can</font><font color="#E5E5E5"> this construction</font>

448
00:19:25,220 --> 00:19:29,360
can you imagine<font color="#E5E5E5"> extending it to support</font>

449
00:19:27,140 --> 00:19:31,430
that yes that's<font color="#E5E5E5"> a</font><font color="#CCCCCC"> very</font><font color="#E5E5E5"> good point so as</font>

450
00:19:29,360 --> 00:19:33,020
I said we actually<font color="#CCCCCC"> already</font><font color="#E5E5E5"> posted</font><font color="#CCCCCC"> the</font>

451
00:19:31,430 --> 00:19:35,150
zero knowledge version of the<font color="#E5E5E5"> back end</font>

452
00:19:33,020 --> 00:19:37,730
<font color="#E5E5E5">meaning</font><font color="#CCCCCC"> that the circuit itself can be</font>

453
00:19:35,150 --> 00:19:39,110
made<font color="#E5E5E5"> zero</font><font color="#CCCCCC"> knowledge but our front</font><font color="#E5E5E5"> and</font>

454
00:19:37,730 --> 00:19:41,120
we'll<font color="#CCCCCC"> leave</font><font color="#E5E5E5"> some extra</font><font color="#CCCCCC"> information</font>

455
00:19:39,110 --> 00:19:44,060
<font color="#E5E5E5">because the optimization we are doing</font>

456
00:19:41,120 --> 00:19:45,969
the prover needs to send back how<font color="#CCCCCC"> many</font>

457
00:19:44,060 --> 00:19:48,830
times each instruction is executed

458
00:19:45,970 --> 00:19:50,420
<font color="#CCCCCC">during the program and this sometimes</font>

459
00:19:48,830 --> 00:19:52,460
<font color="#E5E5E5">could</font><font color="#CCCCCC"> be sensitive</font><font color="#E5E5E5"> for particular</font>

460
00:19:50,420 --> 00:19:54,590
programs<font color="#E5E5E5"> so if you want</font><font color="#CCCCCC"> food zero</font>

461
00:19:52,460 --> 00:19:56,620
<font color="#E5E5E5">knowledge you can still use the</font><font color="#CCCCCC"> old</font>

462
00:19:54,590 --> 00:19:59,360
version<font color="#E5E5E5"> of</font><font color="#CCCCCC"> the reduction meaning</font><font color="#E5E5E5"> that</font>

463
00:19:56,620 --> 00:20:01,699
like you just<font color="#CCCCCC"> give an upper bound of all</font>

464
00:19:59,360 --> 00:20:02,090
possible instructions<font color="#E5E5E5"> and that's still</font>

465
00:20:01,700 --> 00:20:06,140
good

466
00:20:02,090 --> 00:20:08,179
the proficiency will be a<font color="#E5E5E5"> little slower</font>

467
00:20:06,140 --> 00:20:09,920
<font color="#E5E5E5">but this can gives you a trade of in</font>

468
00:20:08,180 --> 00:20:12,620
terms of zero knowledge<font color="#E5E5E5"> that leaks no</font>

469
00:20:09,920 --> 00:20:14,980
information<font color="#E5E5E5"> okay so let's thank you ping</font>

470
00:20:12,620 --> 00:20:14,979
<font color="#E5E5E5">again</font>

