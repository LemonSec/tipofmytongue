1
00:00:07,580 --> 00:00:13,120
so<font color="#CCCCCC"> bulletproof is joint work with</font>

2
00:00:10,820 --> 00:00:14,990
Jonathan brutal

3
00:00:13,120 --> 00:00:20,169
<font color="#E5E5E5">dan</font><font color="#CCCCCC"> Bonet and Andrew</font>

4
00:00:14,990 --> 00:00:23,660
<font color="#E5E5E5">grack for</font><font color="#CCCCCC"> Bitcoin core developers</font><font color="#E5E5E5"> so</font>

5
00:00:20,170 --> 00:00:26,810
consider a Bitcoin transaction or most

6
00:00:23,660 --> 00:00:28,580
<font color="#E5E5E5">cryptocurrency transactions and they</font>

7
00:00:26,810 --> 00:00:30,799
have this<font color="#E5E5E5"> sort of format where</font><font color="#CCCCCC"> you have</font>

8
00:00:28,580 --> 00:00:33,949
some inputs to the transactions and some

9
00:00:30,800 --> 00:00:36,830
outputs to<font color="#CCCCCC"> the transaction</font><font color="#E5E5E5"> and you can</font>

10
00:00:33,949 --> 00:00:39,199
see that<font color="#E5E5E5"> one important quality</font><font color="#CCCCCC"> of an</font>

11
00:00:36,830 --> 00:00:41,839
input<font color="#E5E5E5"> of a Bitcoin transaction is that</font>

12
00:00:39,199 --> 00:00:43,760
the inputs<font color="#E5E5E5"> are greater than the outputs</font>

13
00:00:41,839 --> 00:00:45,140
<font color="#E5E5E5">and that is important</font><font color="#CCCCCC"> because no new</font>

14
00:00:43,760 --> 00:00:47,799
money should be<font color="#E5E5E5"> created and it turns</font>

15
00:00:45,140 --> 00:00:50,330
<font color="#E5E5E5">actually there should</font><font color="#CCCCCC"> be no inflation</font><font color="#E5E5E5"> so</font>

16
00:00:47,799 --> 00:00:51,440
and the inputs<font color="#E5E5E5"> here on the left and the</font>

17
00:00:50,330 --> 00:00:53,180
outputs are on the right<font color="#E5E5E5"> and the</font>

18
00:00:51,440 --> 00:00:55,070
difference is actually the the fees

19
00:00:53,180 --> 00:00:57,080
between<font color="#E5E5E5"> the difference between the</font>

20
00:00:55,070 --> 00:00:58,760
inputs and<font color="#E5E5E5"> the outputs</font><font color="#CCCCCC"> are the fees that</font>

21
00:00:57,080 --> 00:01:01,460
are paid<font color="#CCCCCC"> to the miners to validate the</font>

22
00:00:58,760 --> 00:01:04,519
transaction<font color="#CCCCCC"> so how does a miner validate</font>

23
00:01:01,460 --> 00:01:07,549
a<font color="#CCCCCC"> transaction</font><font color="#E5E5E5"> well a miner or any sort</font>

24
00:01:04,519 --> 00:01:09,020
<font color="#E5E5E5">of full node can validate a Bitcoin</font>

25
00:01:07,549 --> 00:01:10,970
transaction by checking<font color="#E5E5E5"> that</font><font color="#CCCCCC"> the</font>

26
00:01:09,020 --> 00:01:13,490
signatures are correct<font color="#CCCCCC"> so a person was</font>

27
00:01:10,970 --> 00:01:15,650
authorized<font color="#E5E5E5"> to spend the money secondly</font>

28
00:01:13,490 --> 00:01:18,350
<font color="#E5E5E5">that the inputs are unspent so you</font>

29
00:01:15,650 --> 00:01:20,780
cannot spend the same money<font color="#E5E5E5"> twice and</font>

30
00:01:18,350 --> 00:01:22,939
then thirdly that<font color="#CCCCCC"> the sum of</font><font color="#E5E5E5"> the inputs</font>

31
00:01:20,780 --> 00:01:26,960
<font color="#E5E5E5">is equal to the sum of the outputs plus</font>

32
00:01:22,939 --> 00:01:28,908
the fees<font color="#E5E5E5"> and the problem with a Bitcoin</font>

33
00:01:26,960 --> 00:01:31,130
<font color="#E5E5E5">transaction is that the transaction</font>

34
00:01:28,909 --> 00:01:33,710
amounts are available in the clear<font color="#E5E5E5"> so</font>

35
00:01:31,130 --> 00:01:35,899
what does that mean it<font color="#CCCCCC"> means that</font><font color="#E5E5E5"> well</font>

36
00:01:33,710 --> 00:01:37,579
<font color="#E5E5E5">there's also other</font><font color="#CCCCCC"> information like the</font>

37
00:01:35,899 --> 00:01:39,979
payer<font color="#CCCCCC"> and the payee</font><font color="#E5E5E5"> that are available</font>

38
00:01:37,579 --> 00:01:42,889
<font color="#CCCCCC">but what does this</font><font color="#E5E5E5"> mean it</font><font color="#CCCCCC"> means that</font><font color="#E5E5E5"> if</font>

39
00:01:39,979 --> 00:01:45,049
<font color="#CCCCCC">I receive my salary</font><font color="#E5E5E5"> in Bitcoin then</font>

40
00:01:42,890 --> 00:01:49,039
everybody can see what my salary<font color="#CCCCCC"> is it</font>

41
00:01:45,049 --> 00:01:51,200
is and additionally if I'm<font color="#E5E5E5"> saying</font><font color="#CCCCCC"> assign</font>

42
00:01:49,039 --> 00:01:54,049
I'm buying supplies<font color="#E5E5E5"> for my company</font>

43
00:01:51,200 --> 00:01:55,880
everybody<font color="#CCCCCC"> will</font><font color="#E5E5E5"> be able to see how much</font>

44
00:01:54,049 --> 00:01:58,159
I'm paying<font color="#E5E5E5"> for these supplies so if I</font>

45
00:01:55,880 --> 00:02:00,170
you<font color="#E5E5E5"> know buy tires as for it then</font>

46
00:01:58,159 --> 00:02:01,880
everybody<font color="#E5E5E5"> will be able to tell how much</font>

47
00:02:00,170 --> 00:02:03,409
<font color="#E5E5E5">I'm a my paying for these tires and</font>

48
00:02:01,880 --> 00:02:05,359
<font color="#CCCCCC">these are important business secrets</font>

49
00:02:03,409 --> 00:02:10,009
that you would not<font color="#E5E5E5"> want to have on</font><font color="#CCCCCC"> a</font>

50
00:02:05,359 --> 00:02:13,269
public ledger like a blockchain<font color="#E5E5E5"> so and</font>

51
00:02:10,008 --> 00:02:15,200
<font color="#E5E5E5">this</font><font color="#CCCCCC"> is at least the the</font>

52
00:02:13,270 --> 00:02:17,569
preventing that for the transaction

53
00:02:15,200 --> 00:02:20,230
amounts<font color="#E5E5E5"> of public the idea is called a</font>

54
00:02:17,569 --> 00:02:23,359
confidential transaction<font color="#CCCCCC"> so how can we</font>

55
00:02:20,230 --> 00:02:24,619
hide these transaction amounts we use

56
00:02:23,360 --> 00:02:27,440
something<font color="#E5E5E5"> called a cryptographic</font>

57
00:02:24,620 --> 00:02:28,180
commitment or specifically a<font color="#CCCCCC"> Patterson</font>

58
00:02:27,440 --> 00:02:30,579
commitment

59
00:02:28,180 --> 00:02:32,260
and it has the two<font color="#CCCCCC"> properties that it is</font>

60
00:02:30,579 --> 00:02:34,510
hiding<font color="#E5E5E5"> it doesn't reveal what the</font>

61
00:02:32,260 --> 00:02:36,250
amounts are and it is<font color="#CCCCCC"> also binding so</font>

62
00:02:34,510 --> 00:02:39,129
once I committed to<font color="#CCCCCC"> a value</font><font color="#E5E5E5"> I cannot</font>

63
00:02:36,250 --> 00:02:41,379
open it to<font color="#E5E5E5"> another value later the</font>

64
00:02:39,129 --> 00:02:43,060
problem is if this transaction<font color="#E5E5E5"> now has</font>

65
00:02:41,379 --> 00:02:44,858
committed values I just<font color="#E5E5E5"> said the amounts</font>

66
00:02:43,060 --> 00:02:47,469
are hidden well how do you check this

67
00:02:44,859 --> 00:02:49,260
condition<font color="#CCCCCC"> that the inputs are equal to</font>

68
00:02:47,469 --> 00:02:51,250
the outputs plus the fees<font color="#E5E5E5"> and</font>

69
00:02:49,260 --> 00:02:53,530
additionally there's a second condition

70
00:02:51,250 --> 00:02:55,359
<font color="#CCCCCC">that I didn't mention before</font><font color="#E5E5E5"> is you have</font>

71
00:02:53,530 --> 00:02:57,609
to check that<font color="#E5E5E5"> all of the outputs are</font>

72
00:02:55,359 --> 00:02:59,079
positive right that not one<font color="#CCCCCC"> of the</font>

73
00:02:57,609 --> 00:03:00,879
outputs<font color="#CCCCCC"> is negative and</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> other one is</font>

74
00:02:59,079 --> 00:03:02,470
much larger and this actually turns<font color="#E5E5E5"> out</font>

75
00:03:00,879 --> 00:03:02,980
<font color="#CCCCCC">to be the more difficult</font><font color="#E5E5E5"> condition to</font>

76
00:03:02,470 --> 00:03:07,090
<font color="#E5E5E5">check</font>

77
00:03:02,980 --> 00:03:09,730
so what cryptography comes to the rescue

78
00:03:07,090 --> 00:03:11,829
<font color="#E5E5E5">we can do this using a non interactive</font>

79
00:03:09,730 --> 00:03:15,909
zero knowledge proof of knowledge<font color="#E5E5E5"> so</font>

80
00:03:11,829 --> 00:03:17,799
<font color="#E5E5E5">Peggy approver can can use a common</font>

81
00:03:15,909 --> 00:03:19,689
reference string that<font color="#CCCCCC"> is</font><font color="#E5E5E5"> available to</font>

82
00:03:17,799 --> 00:03:23,109
both the prover and the verifier and

83
00:03:19,689 --> 00:03:24,790
create a proof that<font color="#E5E5E5"> the committed</font><font color="#CCCCCC"> value</font>

84
00:03:23,109 --> 00:03:26,859
that she<font color="#E5E5E5"> committed to is actually</font>

85
00:03:24,790 --> 00:03:28,840
<font color="#E5E5E5">positive</font><font color="#CCCCCC"> there's</font><font color="#E5E5E5"> this say</font><font color="#CCCCCC"> there</font><font color="#E5E5E5"> the</font>

86
00:03:26,859 --> 00:03:31,239
proof<font color="#CCCCCC"> for the output and</font><font color="#E5E5E5"> Victor or</font>

87
00:03:28,840 --> 00:03:33,310
anybody can check the proof for<font color="#E5E5E5"> this</font>

88
00:03:31,239 --> 00:03:35,109
<font color="#CCCCCC">commitment</font><font color="#E5E5E5"> and be convinced</font><font color="#CCCCCC"> that the</font>

89
00:03:33,310 --> 00:03:38,290
value X that<font color="#CCCCCC"> was committed to</font><font color="#E5E5E5"> is</font>

90
00:03:35,109 --> 00:03:40,120
positive but<font color="#E5E5E5"> the it's zero</font><font color="#CCCCCC"> knowledge and</font>

91
00:03:38,290 --> 00:03:43,179
that Victor<font color="#CCCCCC"> doesn't learn any</font><font color="#E5E5E5"> other</font>

92
00:03:40,120 --> 00:03:46,269
information<font color="#CCCCCC"> than the fact</font><font color="#E5E5E5"> that the value</font>

93
00:03:43,180 --> 00:03:48,959
X is<font color="#CCCCCC"> positive</font><font color="#E5E5E5"> so Victor</font><font color="#CCCCCC"> most importantly</font>

94
00:03:46,269 --> 00:03:53,109
doesn't<font color="#E5E5E5"> learn what the precise amount is</font>

95
00:03:48,959 --> 00:03:55,569
so these and this<font color="#CCCCCC"> concrete sin area is</font>

96
00:03:53,109 --> 00:03:58,919
called a range proof<font color="#E5E5E5"> because</font><font color="#CCCCCC"> I proving</font>

97
00:03:55,569 --> 00:04:01,659
that a<font color="#E5E5E5"> number is in a small range and</font>

98
00:03:58,919 --> 00:04:05,049
which implies<font color="#CCCCCC"> that there's no overflow</font>

99
00:04:01,659 --> 00:04:07,810
<font color="#E5E5E5">as possible so currently the the range</font>

100
00:04:05,049 --> 00:04:10,150
proofs that<font color="#E5E5E5"> are used are so-called based</font>

101
00:04:07,810 --> 00:04:12,340
on<font color="#E5E5E5"> something</font><font color="#CCCCCC"> called</font><font color="#E5E5E5"> a</font><font color="#CCCCCC"> Sigma protocol and</font>

102
00:04:10,150 --> 00:04:15,909
<font color="#E5E5E5">they're linear</font><font color="#CCCCCC"> sized and what that means</font>

103
00:04:12,340 --> 00:04:17,949
<font color="#E5E5E5">is they're linear in the bit size the</font>

104
00:04:15,909 --> 00:04:20,469
bit length of the range<font color="#E5E5E5"> so if I want to</font>

105
00:04:17,949 --> 00:04:23,199
<font color="#E5E5E5">prove that my number has is between 0</font>

106
00:04:20,470 --> 00:04:26,620
<font color="#E5E5E5">and</font><font color="#CCCCCC"> 2 to the</font><font color="#E5E5E5"> 64 minus 1 then I have to</font>

107
00:04:23,199 --> 00:04:28,360
use<font color="#E5E5E5"> something</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> is about 64 elements</font>

108
00:04:26,620 --> 00:04:30,099
or something that is linear<font color="#E5E5E5"> in 64</font>

109
00:04:28,360 --> 00:04:32,770
elements<font color="#E5E5E5"> and this turns out to</font><font color="#CCCCCC"> be</font>

110
00:04:30,099 --> 00:04:34,990
roughly<font color="#E5E5E5"> 4 kilobytes</font><font color="#CCCCCC"> and even with some</font>

111
00:04:32,770 --> 00:04:37,180
recent optimization the nice thing about

112
00:04:34,990 --> 00:04:39,550
Sigma protocols is they don't<font color="#E5E5E5"> have they</font>

113
00:04:37,180 --> 00:04:41,080
have<font color="#E5E5E5"> no trusted set up</font><font color="#CCCCCC"> and there's some</font>

114
00:04:39,550 --> 00:04:41,650
proof systems that are much more

115
00:04:41,080 --> 00:04:43,930
efficient

116
00:04:41,650 --> 00:04:45,460
<font color="#E5E5E5">like snarks but they unfortunately rely</font>

117
00:04:43,930 --> 00:04:47,290
on<font color="#E5E5E5"> something called a trusted setup</font>

118
00:04:45,460 --> 00:04:50,440
where party creates a proving key and a

119
00:04:47,290 --> 00:04:54,520
verification<font color="#E5E5E5"> key and the problem is if</font>

120
00:04:50,440 --> 00:04:56,889
this was done<font color="#E5E5E5"> maliciously</font><font color="#CCCCCC"> then someone</font>

121
00:04:54,520 --> 00:04:59,349
can<font color="#E5E5E5"> create fake proofs so proofs about</font>

122
00:04:56,889 --> 00:05:02,050
<font color="#E5E5E5">statements that aren't actually true</font><font color="#CCCCCC"> so</font>

123
00:04:59,350 --> 00:05:03,910
<font color="#E5E5E5">the signal protocols</font><font color="#CCCCCC"> that do</font><font color="#E5E5E5"> not have a</font>

124
00:05:02,050 --> 00:05:06,220
trusted to<font color="#CCCCCC"> setup but are</font><font color="#E5E5E5"> relatively</font>

125
00:05:03,910 --> 00:05:08,440
<font color="#E5E5E5">quite large and actually prohibitively</font>

126
00:05:06,220 --> 00:05:10,150
large<font color="#E5E5E5"> probably to implement such a</font>

127
00:05:08,440 --> 00:05:13,150
system or implement confidential

128
00:05:10,150 --> 00:05:15,340
transactions practice so this<font color="#E5E5E5"> is where</font>

129
00:05:13,150 --> 00:05:18,520
we<font color="#CCCCCC"> introduce</font><font color="#E5E5E5"> bulletproof so bullet</font>

130
00:05:15,340 --> 00:05:20,349
proofs are built on previous<font color="#E5E5E5"> work from</font>

131
00:05:18,520 --> 00:05:25,180
UCL that was published<font color="#E5E5E5"> at here at crypt</font>

132
00:05:20,350 --> 00:05:27,280
16 and they use a<font color="#CCCCCC"> so called</font><font color="#E5E5E5"> inner</font>

133
00:05:25,180 --> 00:05:29,770
product argument and when we improve the

134
00:05:27,280 --> 00:05:32,469
inner product argument from the<font color="#CCCCCC"> Buddha</font>

135
00:05:29,770 --> 00:05:32,889
<font color="#CCCCCC">Liddell paper</font><font color="#E5E5E5"> so what is this</font><font color="#CCCCCC"> inner</font>

136
00:05:32,470 --> 00:05:35,740
product

137
00:05:32,889 --> 00:05:40,060
argument<font color="#E5E5E5"> well it's</font><font color="#CCCCCC"> the proof that say I</font>

138
00:05:35,740 --> 00:05:43,210
have a hash<font color="#CCCCCC"> to two vectors a and B</font><font color="#E5E5E5"> and a</font>

139
00:05:40,060 --> 00:05:46,660
scalar C and it<font color="#E5E5E5"> is a proof</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> the</font>

140
00:05:43,210 --> 00:05:50,229
inner product between a<font color="#E5E5E5"> and B is this</font>

141
00:05:46,660 --> 00:05:52,840
value C but the important property of<font color="#E5E5E5"> it</font>

142
00:05:50,229 --> 00:05:55,210
is that it is<font color="#E5E5E5"> logarithmic in the size of</font>

143
00:05:52,840 --> 00:05:57,580
the vector<font color="#E5E5E5"> so to convince you that this</font>

144
00:05:55,210 --> 00:06:00,789
statement is<font color="#CCCCCC"> true I only</font><font color="#E5E5E5"> need to send</font>

145
00:05:57,580 --> 00:06:04,440
you to log n cryptographic<font color="#E5E5E5"> elements so</font>

146
00:06:00,789 --> 00:06:08,800
<font color="#CCCCCC">these elements are 32 bytes</font><font color="#E5E5E5"> if you use</font>

147
00:06:04,440 --> 00:06:10,750
128-bit security and this improves from

148
00:06:08,800 --> 00:06:16,000
<font color="#E5E5E5">the previous version which was</font><font color="#CCCCCC"> 6 log</font><font color="#E5E5E5"> N</font>

149
00:06:10,750 --> 00:06:18,430
and we also enable proofs<font color="#CCCCCC"> on committed</font>

150
00:06:16,000 --> 00:06:19,960
value<font color="#E5E5E5"> so right if you remember what I</font>

151
00:06:18,430 --> 00:06:21,639
<font color="#E5E5E5">showed you previously in the</font>

152
00:06:19,960 --> 00:06:23,979
confidential transaction<font color="#CCCCCC"> I have to prove</font>

153
00:06:21,639 --> 00:06:27,340
<font color="#CCCCCC">that</font><font color="#E5E5E5"> the value X which I was previously</font>

154
00:06:23,979 --> 00:06:29,229
<font color="#CCCCCC">committed to is in some range and I can</font>

155
00:06:27,340 --> 00:06:32,138
now<font color="#CCCCCC"> directly do a</font><font color="#E5E5E5"> proof on that</font>

156
00:06:29,229 --> 00:06:34,599
<font color="#E5E5E5">statement rather than implementing say</font>

157
00:06:32,139 --> 00:06:37,510
the commitment algorithm or<font color="#CCCCCC"> the opening</font>

158
00:06:34,599 --> 00:06:39,010
algorithm<font color="#E5E5E5"> in my proof system it also</font>

159
00:06:37,510 --> 00:06:41,770
only relies on the discrete<font color="#E5E5E5"> logarithm</font>

160
00:06:39,010 --> 00:06:45,430
assumption<font color="#E5E5E5"> and doesn't have a trusted</font>

161
00:06:41,770 --> 00:06:49,870
set up and<font color="#E5E5E5"> over</font><font color="#CCCCCC"> all this leads to a</font>

162
00:06:45,430 --> 00:06:52,240
range proof which<font color="#CCCCCC"> is 2 log n plus 9</font>

163
00:06:49,870 --> 00:06:53,930
<font color="#CCCCCC">elements for a range proof where n is</font>

164
00:06:52,240 --> 00:06:56,750
<font color="#E5E5E5">the</font><font color="#CCCCCC"> number of bits in the</font>

165
00:06:53,930 --> 00:06:59,060
range again but<font color="#E5E5E5"> bulletproof doesn't only</font>

166
00:06:56,750 --> 00:07:01,880
<font color="#E5E5E5">work for range proofs</font><font color="#CCCCCC"> you can do</font><font color="#E5E5E5"> sort</font><font color="#CCCCCC"> of</font>

167
00:06:59,060 --> 00:07:04,669
arbitrary approves<font color="#E5E5E5"> arbitrary proofs for</font>

168
00:07:01,880 --> 00:07:06,979
<font color="#E5E5E5">arbitrary functions which are formulated</font>

169
00:07:04,669 --> 00:07:08,750
as<font color="#E5E5E5"> arithmetic circuits so circuits with</font>

170
00:07:06,979 --> 00:07:11,840
<font color="#E5E5E5">multiplication and addition gates and</font>

171
00:07:08,750 --> 00:07:14,419
<font color="#E5E5E5">they're the the proof size also improves</font>

172
00:07:11,840 --> 00:07:17,060
<font color="#E5E5E5">from the previous scheme the Bulls game</font>

173
00:07:14,419 --> 00:07:19,549
with and<font color="#CCCCCC"> is</font><font color="#E5E5E5"> to log also scales with</font><font color="#CCCCCC"> two</font>

174
00:07:17,060 --> 00:07:23,330
log n where n is<font color="#CCCCCC"> the</font><font color="#E5E5E5"> number of</font>

175
00:07:19,550 --> 00:07:25,370
multiplication gates so let's compare

176
00:07:23,330 --> 00:07:28,370
what does this look like well for a

177
00:07:25,370 --> 00:07:30,080
single 64-bit range proof<font color="#E5E5E5"> now suddenly</font>

178
00:07:28,370 --> 00:07:33,110
the proofs<font color="#CCCCCC"> aren't</font><font color="#E5E5E5"> four kilobytes anymore</font>

179
00:07:30,080 --> 00:07:35,359
<font color="#E5E5E5">there are</font><font color="#CCCCCC"> six</font><font color="#E5E5E5"> hundred</font><font color="#CCCCCC"> seventy bytes but</font>

180
00:07:33,110 --> 00:07:37,430
the nice<font color="#CCCCCC"> thing is</font><font color="#E5E5E5"> that a</font><font color="#CCCCCC"> transaction is</font>

181
00:07:35,360 --> 00:07:39,440
I showed you before it usually has

182
00:07:37,430 --> 00:07:42,320
multiple outputs right<font color="#E5E5E5"> I</font><font color="#CCCCCC"> send some money</font>

183
00:07:39,440 --> 00:07:45,560
<font color="#E5E5E5">to</font><font color="#CCCCCC"> to a friend of</font><font color="#E5E5E5"> mine and then I send</font>

184
00:07:42,320 --> 00:07:48,650
some money<font color="#CCCCCC"> the change goes back to me so</font>

185
00:07:45,560 --> 00:07:50,630
if I have two<font color="#E5E5E5"> outputs I can</font><font color="#CCCCCC"> actually</font>

186
00:07:48,650 --> 00:07:53,479
create a<font color="#E5E5E5"> so-called aggregated range</font>

187
00:07:50,630 --> 00:07:55,699
proof<font color="#E5E5E5"> so I create a proof for these two</font>

188
00:07:53,479 --> 00:07:57,919
commitments<font color="#E5E5E5"> that both of them are in the</font>

189
00:07:55,699 --> 00:08:00,169
right<font color="#E5E5E5"> range and then the proof says</font>

190
00:07:57,919 --> 00:08:03,979
because<font color="#CCCCCC"> of</font><font color="#E5E5E5"> the logarithmic scaling only</font>

191
00:08:00,169 --> 00:08:05,719
goes<font color="#CCCCCC"> up by 64 bytes</font><font color="#E5E5E5"> versus the old range</font>

192
00:08:03,979 --> 00:08:08,060
proof which scale<font color="#CCCCCC"> linearly</font><font color="#E5E5E5"> and and we</font>

193
00:08:05,720 --> 00:08:08,510
can extend<font color="#E5E5E5"> this game for</font><font color="#CCCCCC"> ten range</font>

194
00:08:08,060 --> 00:08:11,060
proofs

195
00:08:08,510 --> 00:08:13,820
now suddenly it's still less than<font color="#CCCCCC"> a</font>

196
00:08:11,060 --> 00:08:17,210
kilobyte for bullet proofs<font color="#E5E5E5"> but much</font>

197
00:08:13,820 --> 00:08:18,740
<font color="#CCCCCC">larger for these old range</font><font color="#E5E5E5"> proofs and I</font>

198
00:08:17,210 --> 00:08:20,539
also show<font color="#CCCCCC"> snarks here which have</font>

199
00:08:18,740 --> 00:08:22,610
<font color="#CCCCCC">actually constant size proof so they</font>

200
00:08:20,539 --> 00:08:30,259
<font color="#E5E5E5">even better but again they have this</font>

201
00:08:22,610 --> 00:08:34,099
downside of a trusted<font color="#E5E5E5"> set up and so how</font>

202
00:08:30,259 --> 00:08:36,440
do we<font color="#E5E5E5"> get these transactions with large</font>

203
00:08:34,099 --> 00:08:38,839
sort of where we have a large number of

204
00:08:36,440 --> 00:08:40,789
outputs right like sometimes maybe<font color="#E5E5E5"> for</font>

205
00:08:38,839 --> 00:08:42,800
Christmas<font color="#CCCCCC"> I'm sending all my</font><font color="#E5E5E5"> relatives</font>

206
00:08:40,789 --> 00:08:44,360
<font color="#E5E5E5">some</font><font color="#CCCCCC"> Bitcoin and</font><font color="#E5E5E5"> I have a large number</font>

207
00:08:42,799 --> 00:08:45,859
of<font color="#E5E5E5"> outputs in the transactions but</font>

208
00:08:44,360 --> 00:08:49,100
<font color="#E5E5E5">usually transactions have more like two</font>

209
00:08:45,860 --> 00:08:50,570
or three outputs<font color="#E5E5E5"> well what is common</font>

210
00:08:49,100 --> 00:08:53,899
though is<font color="#CCCCCC"> that there are multiple</font><font color="#E5E5E5"> people</font>

211
00:08:50,570 --> 00:08:55,279
<font color="#CCCCCC">that want</font><font color="#E5E5E5"> to create that all want to</font>

212
00:08:53,899 --> 00:08:59,050
<font color="#E5E5E5">create an individual Bitcoin</font>

213
00:08:55,279 --> 00:09:01,450
transactions and say we have the

214
00:08:59,050 --> 00:09:03,280
we have these<font color="#CCCCCC"> Peggy's here</font><font color="#E5E5E5"> who all want</font>

215
00:09:01,450 --> 00:09:05,800
to prove<font color="#CCCCCC"> that their bit content section</font>

216
00:09:03,280 --> 00:09:08,189
is valid<font color="#CCCCCC"> so they all want to</font><font color="#E5E5E5"> prove that</font>

217
00:09:05,800 --> 00:09:11,680
<font color="#CCCCCC">their commitments are in a</font><font color="#E5E5E5"> certain range</font>

218
00:09:08,190 --> 00:09:13,120
<font color="#E5E5E5">so but they don't want to reveal the</font>

219
00:09:11,680 --> 00:09:16,060
secrets<font color="#CCCCCC"> to each other</font><font color="#E5E5E5"> right they don't</font>

220
00:09:13,120 --> 00:09:17,800
want to tell the other<font color="#E5E5E5"> Peggy what</font><font color="#CCCCCC"> their</font>

221
00:09:16,060 --> 00:09:19,180
how much<font color="#E5E5E5"> they're exactly they're sending</font>

222
00:09:17,800 --> 00:09:21,069
so how<font color="#CCCCCC"> can they do that</font>

223
00:09:19,180 --> 00:09:22,930
well the trivia solution is they can

224
00:09:21,070 --> 00:09:24,760
just concatenate their proofs<font color="#E5E5E5"> but</font>

225
00:09:22,930 --> 00:09:27,579
there's<font color="#CCCCCC"> actually a</font><font color="#E5E5E5"> better solution here</font>

226
00:09:24,760 --> 00:09:30,689
with bullet proof we designed a

227
00:09:27,580 --> 00:09:33,370
<font color="#E5E5E5">so-called multi-party computation</font><font color="#CCCCCC"> MPC a</font>

228
00:09:30,690 --> 00:09:35,710
custom<font color="#E5E5E5"> and PC not not a generic one</font>

229
00:09:33,370 --> 00:09:37,780
<font color="#E5E5E5">which allows these</font><font color="#CCCCCC"> Peggy's to interact</font>

230
00:09:35,710 --> 00:09:41,320
with<font color="#CCCCCC"> each other</font><font color="#E5E5E5"> and create a single</font>

231
00:09:37,780 --> 00:09:43,839
proof<font color="#E5E5E5"> for their joint statement and this</font>

232
00:09:41,320 --> 00:09:46,210
this works if the statement<font color="#E5E5E5"> is of the</font>

233
00:09:43,840 --> 00:09:48,520
form that that<font color="#E5E5E5"> each party wants to prove</font>

234
00:09:46,210 --> 00:09:50,470
<font color="#CCCCCC">something and the Oval a statement is</font>

235
00:09:48,520 --> 00:09:52,840
the conjunction of<font color="#CCCCCC"> the individual party</font>

236
00:09:50,470 --> 00:09:55,330
statements<font color="#E5E5E5"> so for example for</font><font color="#CCCCCC"> a range</font>

237
00:09:52,840 --> 00:09:58,270
proof we if we have n range proofs for n

238
00:09:55,330 --> 00:10:00,580
provers then they can<font color="#E5E5E5"> use this NPC to</font>

239
00:09:58,270 --> 00:10:02,680
create one<font color="#E5E5E5"> singers proof and here again</font>

240
00:10:00,580 --> 00:10:05,970
the logarithmic scaling of the<font color="#E5E5E5"> proof</font>

241
00:10:02,680 --> 00:10:11,920
<font color="#E5E5E5">makes this a very worthwhile thing</font><font color="#CCCCCC"> to do</font>

242
00:10:05,970 --> 00:10:13,860
so<font color="#E5E5E5"> the protocol has a logarithmic number</font>

243
00:10:11,920 --> 00:10:16,209
of rounds and<font color="#E5E5E5"> a logarithmic number</font>

244
00:10:13,860 --> 00:10:18,460
communication but rounds are actually

245
00:10:16,210 --> 00:10:21,250
very important expensive<font color="#E5E5E5"> or the</font>

246
00:10:18,460 --> 00:10:22,900
communication<font color="#E5E5E5"> is very expensive complex</font>

247
00:10:21,250 --> 00:10:25,240
so there's also another variant<font color="#E5E5E5"> of the</font>

248
00:10:22,900 --> 00:10:28,840
<font color="#E5E5E5">protocol with</font><font color="#CCCCCC"> only three rounds</font><font color="#E5E5E5"> but a</font>

249
00:10:25,240 --> 00:10:31,510
lot more<font color="#CCCCCC"> communication cost and so what</font>

250
00:10:28,840 --> 00:10:34,150
is the<font color="#E5E5E5"> the overall evaluation of</font><font color="#CCCCCC"> this</font>

251
00:10:31,510 --> 00:10:35,860
scheme<font color="#E5E5E5"> well the overall</font><font color="#CCCCCC"> evaluation of</font>

252
00:10:34,150 --> 00:10:37,720
<font color="#E5E5E5">the scheme for for confidential</font>

253
00:10:35,860 --> 00:10:41,950
transactions our main<font color="#CCCCCC"> application is</font>

254
00:10:37,720 --> 00:10:44,950
<font color="#CCCCCC">that we have</font><font color="#E5E5E5"> 670</font><font color="#CCCCCC"> bite range proofs</font>

255
00:10:41,950 --> 00:10:46,630
instead of<font color="#CCCCCC"> 4 kilobytes previously and if</font>

256
00:10:44,950 --> 00:10:49,630
<font color="#CCCCCC">you have two proofs this is better and</font>

257
00:10:46,630 --> 00:10:52,540
the larger we go this again you know<font color="#E5E5E5"> for</font>

258
00:10:49,630 --> 00:10:54,340
<font color="#E5E5E5">16 range proofs</font><font color="#CCCCCC"> we have we're still</font>

259
00:10:52,540 --> 00:10:56,050
under a kilobyte where's the 61

260
00:10:54,340 --> 00:10:58,270
kilobytes for<font color="#E5E5E5"> the previous system and</font>

261
00:10:56,050 --> 00:11:00,849
the nice<font color="#CCCCCC"> thing is to if we say want to</font>

262
00:10:58,270 --> 00:11:04,689
double<font color="#CCCCCC"> the print</font><font color="#E5E5E5"> precision this only</font>

263
00:11:00,850 --> 00:11:06,820
again<font color="#CCCCCC"> add</font><font color="#E5E5E5"> 64 bytes and overall if we</font>

264
00:11:04,690 --> 00:11:08,950
look at the current<font color="#CCCCCC"> UTX all</font><font color="#E5E5E5"> set and do</font>

265
00:11:06,820 --> 00:11:11,920
not assume any change of user behavior

266
00:11:08,950 --> 00:11:12,579
in Bitcoin this would shrink the size of

267
00:11:11,920 --> 00:11:16,809
<font color="#E5E5E5">the the</font>

268
00:11:12,579 --> 00:11:19,660
<font color="#CCCCCC">ut-oh</font><font color="#E5E5E5"> set by about a factor of</font><font color="#CCCCCC"> 10 with</font>

269
00:11:16,809 --> 00:11:22,449
<font color="#CCCCCC">respect</font><font color="#E5E5E5"> to when as opposed to if they</font>

270
00:11:19,660 --> 00:11:25,509
had<font color="#CCCCCC"> used the old range proof and there's</font>

271
00:11:22,449 --> 00:11:27,939
<font color="#E5E5E5">this simple protocol for users to to</font>

272
00:11:25,509 --> 00:11:32,889
combine their transactions<font color="#E5E5E5"> which is</font>

273
00:11:27,939 --> 00:11:36,009
called a coin join protocol so<font color="#E5E5E5"> monaro</font>

274
00:11:32,889 --> 00:11:39,610
<font color="#E5E5E5">which is privacy or occurrence</font>

275
00:11:36,009 --> 00:11:42,639
<font color="#E5E5E5">cryptocurrency that is has some sort of</font>

276
00:11:39,610 --> 00:11:44,230
<font color="#E5E5E5">stronger privacy preachers is actually</font>

277
00:11:42,639 --> 00:11:48,129
<font color="#E5E5E5">planning to implement bulletproof and</font>

278
00:11:44,230 --> 00:11:50,019
they say<font color="#CCCCCC"> bottom line</font><font color="#E5E5E5"> bull approves are</font>

279
00:11:48,129 --> 00:11:51,850
awesome they work the fees are lower and

280
00:11:50,019 --> 00:11:56,170
they're moving<font color="#CCCCCC"> into test</font><font color="#E5E5E5"> net so we're</font>

281
00:11:51,850 --> 00:11:59,350
very excited about<font color="#CCCCCC"> that</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> i also want</font>

282
00:11:56,170 --> 00:12:00,729
to but<font color="#CCCCCC"> bullet proofs do not</font><font color="#E5E5E5"> only work</font>

283
00:11:59,350 --> 00:12:03,459
for range proofs they are generally

284
00:12:00,730 --> 00:12:06,970
applicable or general proof systems for

285
00:12:03,459 --> 00:12:08,859
arithmetic<font color="#E5E5E5"> circuits so let's compare</font>

286
00:12:06,970 --> 00:12:11,980
them again<font color="#E5E5E5"> to some some other proof</font>

287
00:12:08,860 --> 00:12:14,559
systems<font color="#E5E5E5"> so for example</font><font color="#CCCCCC"> again snart's</font>

288
00:12:11,980 --> 00:12:17,110
the<font color="#CCCCCC"> proofs eyes are very</font><font color="#E5E5E5"> short they're</font>

289
00:12:14,559 --> 00:12:20,019
constant<font color="#E5E5E5"> but again there are</font><font color="#CCCCCC"> a lot of</font>

290
00:12:17,110 --> 00:12:22,089
rhythmic scaling means that for sort of

291
00:12:20,019 --> 00:12:24,069
most proof sizes that would be

292
00:12:22,089 --> 00:12:26,589
considered<font color="#CCCCCC"> reasonable the proof state</font>

293
00:12:24,069 --> 00:12:28,748
under two kilobytes<font color="#CCCCCC"> and this is in</font>

294
00:12:26,589 --> 00:12:30,910
<font color="#E5E5E5">contrast to another proof system called</font>

295
00:12:28,749 --> 00:12:33,339
<font color="#CCCCCC">starix which also</font><font color="#E5E5E5"> doesn't</font><font color="#CCCCCC"> have a trusted</font>

296
00:12:30,910 --> 00:12:35,350
<font color="#E5E5E5">set up where the proofs are over</font><font color="#CCCCCC"> two</font>

297
00:12:33,339 --> 00:12:37,329
<font color="#CCCCCC">hundred</font><font color="#E5E5E5"> kilobytes even though it also</font>

298
00:12:35,350 --> 00:12:41,860
has logarithmic scaling or a log squared

299
00:12:37,329 --> 00:12:44,888
scaling<font color="#E5E5E5"> and so</font><font color="#CCCCCC"> i also want to highlight</font>

300
00:12:41,860 --> 00:12:48,449
<font color="#E5E5E5">so zero cash which is another</font>

301
00:12:44,889 --> 00:12:51,040
cryptocurrency with the the<font color="#E5E5E5"> strongest</font>

302
00:12:48,449 --> 00:12:54,790
privacy properties which uses<font color="#CCCCCC"> snarks</font>

303
00:12:51,040 --> 00:12:57,009
right now<font color="#E5E5E5"> if you they they're using a</font>

304
00:12:54,790 --> 00:12:58,868
new circuit so if we use bullet proofs

305
00:12:57,009 --> 00:13:02,199
that transactions would<font color="#E5E5E5"> be about</font><font color="#CCCCCC"> 1.3</font>

306
00:12:58,869 --> 00:13:04,929
kilobytes<font color="#E5E5E5"> however the the other big</font>

307
00:13:02,199 --> 00:13:07,959
downside<font color="#CCCCCC"> vs. snarks</font><font color="#E5E5E5"> why can't they just</font>

308
00:13:04,929 --> 00:13:09,488
<font color="#E5E5E5">switch</font><font color="#CCCCCC"> to that or one one thing is</font>

309
00:13:07,959 --> 00:13:11,258
obviously yeah the<font color="#E5E5E5"> transaction size</font>

310
00:13:09,489 --> 00:13:13,809
would be<font color="#E5E5E5"> bigger but the other downside</font>

311
00:13:11,259 --> 00:13:16,029
<font color="#CCCCCC">is that</font><font color="#E5E5E5"> the verification time for bull</font>

312
00:13:13,809 --> 00:13:18,939
approves<font color="#E5E5E5"> is linear in the size of the</font>

313
00:13:16,029 --> 00:13:20,740
circuit asymptotically<font color="#E5E5E5"> versus</font><font color="#CCCCCC"> for</font><font color="#E5E5E5"> snarks</font>

314
00:13:18,939 --> 00:13:23,230
where the verification time is<font color="#CCCCCC"> constant</font>

315
00:13:20,740 --> 00:13:24,939
<font color="#E5E5E5">so in practice that was mean that the</font>

316
00:13:23,230 --> 00:13:26,020
<font color="#CCCCCC">verification is about a</font><font color="#E5E5E5"> factor of</font><font color="#CCCCCC"> ten</font>

317
00:13:24,939 --> 00:13:29,279
slower

318
00:13:26,020 --> 00:13:31,439
and let's talk<font color="#E5E5E5"> about some</font><font color="#CCCCCC"> other</font>

319
00:13:29,279 --> 00:13:35,560
applications for<font color="#E5E5E5"> bulletproof</font>

320
00:13:31,440 --> 00:13:39,100
so one applications are<font color="#E5E5E5"> so-called proofs</font>

321
00:13:35,560 --> 00:13:42,130
of<font color="#E5E5E5"> solvency or provisions and which was</font>

322
00:13:39,100 --> 00:13:44,440
a<font color="#E5E5E5"> paper in 2015 presented</font><font color="#CCCCCC"> at CCS and the</font>

323
00:13:42,130 --> 00:13:46,270
idea is is that Bitcoin exchanges or

324
00:13:44,440 --> 00:13:49,480
<font color="#E5E5E5">Bitcoin banks can prove that</font><font color="#CCCCCC"> they're</font>

325
00:13:46,270 --> 00:13:50,890
solvent<font color="#E5E5E5"> without revealing why they're</font>

326
00:13:49,480 --> 00:13:52,570
solvent so they don't have to<font color="#CCCCCC"> reveal</font>

327
00:13:50,890 --> 00:13:55,750
what<font color="#CCCCCC"> Bitcoin addresses they own they</font>

328
00:13:52,570 --> 00:13:57,700
don't<font color="#E5E5E5"> have to reveal how much each</font>

329
00:13:55,750 --> 00:13:58,870
customer<font color="#CCCCCC"> has or how much money they even</font>

330
00:13:57,700 --> 00:14:00,940
have in<font color="#CCCCCC"> total but they can prove</font><font color="#E5E5E5"> that</font>

331
00:13:58,870 --> 00:14:03,160
<font color="#CCCCCC">they're solvent and with</font><font color="#E5E5E5"> bullet</font><font color="#CCCCCC"> proof</font>

332
00:14:00,940 --> 00:14:05,740
the the the size of this<font color="#E5E5E5"> protocol would</font>

333
00:14:03,160 --> 00:14:07,899
go down from 18 gigabytes to<font color="#E5E5E5"> 62</font>

334
00:14:05,740 --> 00:14:10,209
megabytes<font color="#E5E5E5"> so quite a drastic change here</font>

335
00:14:07,899 --> 00:14:12,670
another applications are<font color="#E5E5E5"> so-called</font>

336
00:14:10,209 --> 00:14:15,609
<font color="#E5E5E5">verifiable shuffles where multiple</font>

337
00:14:12,670 --> 00:14:17,770
parties<font color="#E5E5E5"> have multiple messages and they</font>

338
00:14:15,610 --> 00:14:20,920
go through something<font color="#CCCCCC"> called a</font><font color="#E5E5E5"> mix net</font>

339
00:14:17,770 --> 00:14:23,890
<font color="#E5E5E5">and as part of this mix net protocol</font>

340
00:14:20,920 --> 00:14:27,250
every party needs<font color="#E5E5E5"> to provide a proof</font>

341
00:14:23,890 --> 00:14:29,890
<font color="#E5E5E5">that sort of n inputs are equal to n</font>

342
00:14:27,250 --> 00:14:32,260
outputs<font color="#E5E5E5"> and that they were shuffled</font>

343
00:14:29,890 --> 00:14:33,819
correctly so<font color="#CCCCCC"> that you have two lists of</font>

344
00:14:32,260 --> 00:14:35,920
commitments and you want to prove that

345
00:14:33,820 --> 00:14:40,300
<font color="#CCCCCC">sort of</font><font color="#E5E5E5"> the same values we're committed</font>

346
00:14:35,920 --> 00:14:42,579
to<font color="#E5E5E5"> in both of these commitments and with</font>

347
00:14:40,300 --> 00:14:45,459
bull approves this seems to<font color="#CCCCCC"> be</font><font color="#E5E5E5"> the first</font>

348
00:14:42,579 --> 00:14:47,140
logarithmic sized<font color="#E5E5E5"> verifiable shuffle</font>

349
00:14:45,459 --> 00:14:49,839
without<font color="#CCCCCC"> it doesn't have a trusted set up</font>

350
00:14:47,140 --> 00:14:52,390
and we also implemented<font color="#E5E5E5"> bullet proof</font>

351
00:14:49,839 --> 00:14:56,649
into the the Bitcoin<font color="#E5E5E5"> cryptographic</font>

352
00:14:52,390 --> 00:14:58,959
library we spend a<font color="#CCCCCC"> lot of</font><font color="#E5E5E5"> our time on</font>

353
00:14:56,649 --> 00:15:02,050
optimizing<font color="#E5E5E5"> the verifier and it turns out</font>

354
00:14:58,959 --> 00:15:04,899
now that<font color="#CCCCCC"> Shane company or chain Inc has</font>

355
00:15:02,050 --> 00:15:08,050
has done<font color="#CCCCCC"> a newer implementation and in</font>

356
00:15:04,899 --> 00:15:10,750
rust<font color="#E5E5E5"> and they use avx2 and curve</font><font color="#CCCCCC"> 25.9</font>

357
00:15:08,050 --> 00:15:12,130
<font color="#E5E5E5">and that one seems to be even faster</font><font color="#CCCCCC"> so</font>

358
00:15:10,750 --> 00:15:15,579
we're actually quite<font color="#E5E5E5"> happy about the</font>

359
00:15:12,130 --> 00:15:17,770
competition<font color="#E5E5E5"> there and but one thing we</font>

360
00:15:15,579 --> 00:15:19,959
did<font color="#E5E5E5"> in the in the verification is we try</font>

361
00:15:17,770 --> 00:15:22,360
<font color="#E5E5E5">to make the verification as efficient as</font>

362
00:15:19,959 --> 00:15:25,589
<font color="#CCCCCC">possible</font><font color="#E5E5E5"> so we took our fairly complex</font>

363
00:15:22,360 --> 00:15:27,970
<font color="#CCCCCC">verifier protocol and boiled it down to</font>

364
00:15:25,589 --> 00:15:30,910
<font color="#E5E5E5">basically just a single multi</font>

365
00:15:27,970 --> 00:15:34,180
exponentiation<font color="#E5E5E5"> so these X's</font><font color="#CCCCCC"> here are</font>

366
00:15:30,910 --> 00:15:37,990
elements from the<font color="#CCCCCC"> Prai</font><font color="#E5E5E5"> derived from the</font>

367
00:15:34,180 --> 00:15:39,819
proof and again<font color="#CCCCCC"> write the</font><font color="#E5E5E5"> proof is</font>

368
00:15:37,990 --> 00:15:41,920
<font color="#E5E5E5">logarithmic size but you</font>

369
00:15:39,820 --> 00:15:43,690
expand<font color="#E5E5E5"> the proof into a linear number of</font>

370
00:15:41,920 --> 00:15:46,660
elements so that's where the

371
00:15:43,690 --> 00:15:48,400
verification is linear and then you just

372
00:15:46,660 --> 00:15:52,420
have to check the single<font color="#E5E5E5"> exploration</font>

373
00:15:48,400 --> 00:15:55,360
equation<font color="#CCCCCC"> where which is</font><font color="#E5E5E5"> called a multi</font>

374
00:15:52,420 --> 00:15:59,079
exponentiation<font color="#E5E5E5"> so why does this help us</font>

375
00:15:55,360 --> 00:16:02,050
<font color="#E5E5E5">we'll say we want to check two proofs</font><font color="#CCCCCC"> so</font>

376
00:15:59,080 --> 00:16:04,750
we have which<font color="#E5E5E5"> means we have to check</font>

377
00:16:02,050 --> 00:16:07,030
these two different<font color="#CCCCCC"> equations</font><font color="#E5E5E5"> okay</font><font color="#CCCCCC"> and</font>

378
00:16:04,750 --> 00:16:10,810
but<font color="#E5E5E5"> what we can do is we can</font><font color="#CCCCCC"> use</font><font color="#E5E5E5"> this</font>

379
00:16:07,030 --> 00:16:13,270
sort of this old trick<font color="#CCCCCC"> to</font><font color="#E5E5E5"> called a batch</font>

380
00:16:10,810 --> 00:16:15,699
verification to combine these<font color="#E5E5E5"> two</font>

381
00:16:13,270 --> 00:16:18,250
verifications<font color="#CCCCCC"> by just</font><font color="#E5E5E5"> taking a random</font>

382
00:16:15,700 --> 00:16:20,890
linear combination<font color="#E5E5E5"> of them into</font><font color="#CCCCCC"> one big</font>

383
00:16:18,250 --> 00:16:22,780
multi exponentiation<font color="#E5E5E5"> and because the</font>

384
00:16:20,890 --> 00:16:25,270
exponentiation part is a lot<font color="#E5E5E5"> more</font>

385
00:16:22,780 --> 00:16:29,140
expensive<font color="#E5E5E5"> than</font><font color="#CCCCCC"> the scalar operation</font><font color="#E5E5E5"> this</font>

386
00:16:25,270 --> 00:16:31,540
<font color="#E5E5E5">will give us a big win because it means</font>

387
00:16:29,140 --> 00:16:34,030
that verifying the first proof<font color="#CCCCCC"> say this</font>

388
00:16:31,540 --> 00:16:36,160
is<font color="#E5E5E5"> for to range proofs is 6.2</font>

389
00:16:34,030 --> 00:16:40,020
milliseconds<font color="#E5E5E5"> but then each additional</font>

390
00:16:36,160 --> 00:16:42,430
proof is more<font color="#E5E5E5"> than a factor</font><font color="#CCCCCC"> of 10 faster</font>

391
00:16:40,020 --> 00:16:45,520
because again right we<font color="#CCCCCC"> only have to do</font>

392
00:16:42,430 --> 00:16:46,959
<font color="#CCCCCC">additional almost</font><font color="#E5E5E5"> only the additional</font>

393
00:16:45,520 --> 00:16:49,780
<font color="#E5E5E5">operations are almost only scale</font>

394
00:16:46,960 --> 00:16:53,590
operations<font color="#E5E5E5"> so what does this look</font><font color="#CCCCCC"> like</font>

395
00:16:49,780 --> 00:16:56,319
<font color="#E5E5E5">so</font><font color="#CCCCCC"> i plotted here the the proof time</font><font color="#E5E5E5"> the</font>

396
00:16:53,590 --> 00:16:58,660
on a<font color="#E5E5E5"> log-log scale the verification time</font>

397
00:16:56,320 --> 00:17:01,360
and the batch verification time and as a

398
00:16:58,660 --> 00:17:05,260
benchmark<font color="#E5E5E5"> on our system</font><font color="#CCCCCC"> i also plotted</font>

399
00:17:01,360 --> 00:17:07,660
<font color="#E5E5E5">how much does it take to verify</font><font color="#CCCCCC"> n n</font>

400
00:17:05,260 --> 00:17:08,920
ECDSA signatures which is what you would

401
00:17:07,660 --> 00:17:12,310
<font color="#E5E5E5">have</font><font color="#CCCCCC"> to currently</font><font color="#E5E5E5"> do in</font><font color="#CCCCCC"> a Bitcoin</font>

402
00:17:08,920 --> 00:17:14,560
<font color="#E5E5E5">transaction so and on the</font><font color="#CCCCCC"> x-axis we have</font>

403
00:17:12,310 --> 00:17:15,970
the number<font color="#E5E5E5"> of range proofs the number of</font>

404
00:17:14,560 --> 00:17:18,458
<font color="#CCCCCC">aggregate range posts that are we aware</font>

405
00:17:15,970 --> 00:17:23,589
<font color="#CCCCCC">from and it turns out</font><font color="#E5E5E5"> that from starting</font>

406
00:17:18,459 --> 00:17:27,939
<font color="#E5E5E5">from</font><font color="#CCCCCC"> about 1616 range proofs</font><font color="#E5E5E5"> batch and</font>

407
00:17:23,589 --> 00:17:29,679
into one single proof<font color="#CCCCCC"> verifying</font><font color="#E5E5E5"> six</font>

408
00:17:27,939 --> 00:17:33,910
<font color="#E5E5E5">improve is about as</font><font color="#CCCCCC"> expensive as</font>

409
00:17:29,680 --> 00:17:35,290
verifying<font color="#CCCCCC"> 16 ECDSA</font><font color="#E5E5E5"> signature so if you</font>

410
00:17:33,910 --> 00:17:37,210
have a system there it<font color="#CCCCCC"> isn't actually</font>

411
00:17:35,290 --> 00:17:40,399
<font color="#E5E5E5">that much more expensive where it's</font>

412
00:17:37,210 --> 00:17:43,039
almost<font color="#E5E5E5"> the same cost as</font>

413
00:17:40,400 --> 00:17:47,419
the the old Bitcoin system<font color="#E5E5E5"> where people</font>

414
00:17:43,039 --> 00:17:49,549
have to verify<font color="#E5E5E5"> ECDSA signatures and I</font>

415
00:17:47,419 --> 00:17:51,799
also have a small comparison<font color="#CCCCCC"> to</font><font color="#E5E5E5"> two</font>

416
00:17:49,549 --> 00:17:53,360
other proof systems and and you know the

417
00:17:51,799 --> 00:17:55,309
<font color="#E5E5E5">space is getting</font><font color="#CCCCCC"> large</font><font color="#E5E5E5"> and there's a lot</font>

418
00:17:53,360 --> 00:17:57,379
<font color="#CCCCCC">of</font><font color="#E5E5E5"> exciting development happening here</font>

419
00:17:55,309 --> 00:17:59,059
and and the core<font color="#E5E5E5"> properties of</font><font color="#CCCCCC"> bulu</font>

420
00:17:57,380 --> 00:18:00,950
<font color="#E5E5E5">proves where it improves is that that</font>

421
00:17:59,059 --> 00:18:03,799
there's these are really short proofs

422
00:18:00,950 --> 00:18:06,230
with no<font color="#E5E5E5"> trusted</font><font color="#CCCCCC"> setup and the downside</font>

423
00:18:03,799 --> 00:18:08,480
though are that<font color="#CCCCCC"> it uses has a linear</font>

424
00:18:06,230 --> 00:18:09,650
verification time<font color="#E5E5E5"> so for really</font><font color="#CCCCCC"> large</font>

425
00:18:08,480 --> 00:18:11,390
circuits and world

426
00:18:09,650 --> 00:18:13,990
<font color="#CCCCCC">the verification time we'll get</font>

427
00:18:11,390 --> 00:18:16,820
prohibitively large and it<font color="#E5E5E5"> uses publicly</font>

428
00:18:13,990 --> 00:18:21,049
public key crypto which means that

429
00:18:16,820 --> 00:18:23,360
there's<font color="#CCCCCC"> other it it</font><font color="#E5E5E5"> uses discrete log</font>

430
00:18:21,049 --> 00:18:25,490
<font color="#CCCCCC">base crypto which means that it is not</font>

431
00:18:23,360 --> 00:18:28,729
secured against quantum computers unlike

432
00:18:25,490 --> 00:18:31,600
something something<font color="#E5E5E5"> like a</font><font color="#CCCCCC"> Stark which</font>

433
00:18:28,730 --> 00:18:36,260
<font color="#CCCCCC">has a other downsides like the larger</font>

434
00:18:31,600 --> 00:18:37,969
<font color="#E5E5E5">proofs in practice and and the important</font>

435
00:18:36,260 --> 00:18:40,580
<font color="#E5E5E5">thing</font><font color="#CCCCCC"> to remember there's something</font>

436
00:18:37,970 --> 00:18:42,679
missing is<font color="#CCCCCC"> that</font><font color="#E5E5E5"> there</font><font color="#CCCCCC"> there's the space</font>

437
00:18:40,580 --> 00:18:45,350
is developing and there's many the<font color="#E5E5E5"> the</font>

438
00:18:42,679 --> 00:18:47,780
<font color="#E5E5E5">trade-offs are very high dimensional</font><font color="#CCCCCC"> and</font>

439
00:18:45,350 --> 00:18:50,719
there's really no clear<font color="#E5E5E5"> winner here</font><font color="#CCCCCC"> and</font>

440
00:18:47,780 --> 00:18:53,090
for<font color="#E5E5E5"> example</font><font color="#CCCCCC"> on Wednesday we will</font><font color="#E5E5E5"> see</font><font color="#CCCCCC"> two</font>

441
00:18:50,720 --> 00:18:55,429
more talks on higher<font color="#CCCCCC"> x and and vram</font>

442
00:18:53,090 --> 00:18:57,500
which provide other trade-offs in in

443
00:18:55,429 --> 00:18:59,059
this high<font color="#CCCCCC"> dimensional space and it</font>

444
00:18:57,500 --> 00:19:01,460
<font color="#E5E5E5">really depends on your application which</font>

445
00:18:59,059 --> 00:19:03,889
proof<font color="#CCCCCC"> system is the best and you can</font>

446
00:19:01,460 --> 00:19:06,150
check<font color="#E5E5E5"> out</font><font color="#CCCCCC"> our paper on this URL</font><font color="#E5E5E5"> thank</font>

447
00:19:03,890 --> 00:19:10,939
you<font color="#E5E5E5"> very much</font>

448
00:19:06,150 --> 00:19:10,939
[Applause]

449
00:19:15,840 --> 00:19:21,330
thanks for your talk<font color="#CCCCCC"> so I maybe miss</font>

450
00:19:18,990 --> 00:19:23,520
this but when you do the batching for

451
00:19:21,330 --> 00:19:25,740
verification<font color="#CCCCCC"> is this proofs coming from</font>

452
00:19:23,520 --> 00:19:28,350
the same<font color="#CCCCCC"> proven or can you batch proofs</font>

453
00:19:25,740 --> 00:19:30,000
<font color="#E5E5E5">from different</font><font color="#CCCCCC"> progress no a very good</font>

454
00:19:28,350 --> 00:19:31,439
question<font color="#CCCCCC"> no</font><font color="#E5E5E5"> you can batch proofs from</font>

455
00:19:30,000 --> 00:19:33,560
different provers and actually you can

456
00:19:31,440 --> 00:19:36,360
even batch proofs for different

457
00:19:33,560 --> 00:19:37,919
statements as long as they're roughly<font color="#E5E5E5"> of</font>

458
00:19:36,360 --> 00:19:40,409
the<font color="#CCCCCC"> same length</font><font color="#E5E5E5"> or if they</font><font color="#CCCCCC"> are the same</font>

459
00:19:37,920 --> 00:19:42,720
length<font color="#E5E5E5"> because the generators are fixed</font>

460
00:19:40,410 --> 00:19:45,030
in the in the common reference strings

461
00:19:42,720 --> 00:19:47,400
and and are<font color="#E5E5E5"> always the same for all</font>

462
00:19:45,030 --> 00:19:49,050
parties and<font color="#CCCCCC"> the only thing that changes</font>

463
00:19:47,400 --> 00:19:51,630
are the exponents<font color="#E5E5E5"> so that's why you can</font>

464
00:19:49,050 --> 00:19:54,180
<font color="#CCCCCC">use the batch verification trick even</font>

465
00:19:51,630 --> 00:20:01,920
<font color="#CCCCCC">for different provers</font><font color="#E5E5E5"> or even for</font>

466
00:19:54,180 --> 00:20:13,140
<font color="#CCCCCC">different statements no this is a purely</font>

467
00:20:01,920 --> 00:20:15,510
verifier<font color="#CCCCCC"> side so the verification is</font>

468
00:20:13,140 --> 00:20:18,330
still linear<font color="#E5E5E5"> however now it's a linear</font>

469
00:20:15,510 --> 00:20:20,250
number of scalar operations<font color="#E5E5E5"> and only</font>

470
00:20:18,330 --> 00:20:23,520
basically<font color="#CCCCCC"> a logarithmic</font><font color="#E5E5E5"> number of crypto</font>

471
00:20:20,250 --> 00:20:25,050
operations versus if you<font color="#E5E5E5"> just verify</font>

472
00:20:23,520 --> 00:20:31,290
them normally it's a linear<font color="#E5E5E5"> number of</font>

473
00:20:25,050 --> 00:20:35,030
crypto operations<font color="#CCCCCC"> you go back about</font>

474
00:20:31,290 --> 00:20:37,830
three slides<font color="#E5E5E5"> I cannot do that but maybe</font>

475
00:20:35,030 --> 00:20:40,950
see the slide where<font color="#CCCCCC"> you have the two</font>

476
00:20:37,830 --> 00:20:44,790
products<font color="#CCCCCC"> equal to one mapped into</font><font color="#E5E5E5"> the</font>

477
00:20:40,950 --> 00:20:46,830
one<font color="#CCCCCC"> the one</font><font color="#E5E5E5"> that the</font><font color="#CCCCCC"> BET's verification</font>

478
00:20:44,790 --> 00:20:48,629
yeah<font color="#CCCCCC"> the left side implies the right</font>

479
00:20:46,830 --> 00:20:50,399
side the<font color="#CCCCCC"> right side does not</font><font color="#E5E5E5"> imply the</font>

480
00:20:48,630 --> 00:20:54,150
left side<font color="#E5E5E5"> that is a very good point</font>

481
00:20:50,400 --> 00:20:56,310
<font color="#E5E5E5">however if the sort of the randomness is</font>

482
00:20:54,150 --> 00:20:58,230
drawn from a large enough space the

483
00:20:56,310 --> 00:21:00,169
probability that<font color="#E5E5E5"> the right side will</font><font color="#CCCCCC"> not</font>

484
00:20:58,230 --> 00:21:02,760
imply<font color="#E5E5E5"> that the left side it's inversely</font>

485
00:21:00,170 --> 00:21:04,710
proportional<font color="#CCCCCC"> to sort of the space</font><font color="#E5E5E5"> where</font>

486
00:21:02,760 --> 00:21:06,750
you're drawing<font color="#CCCCCC"> your random</font><font color="#E5E5E5"> scalar off</font>

487
00:21:04,710 --> 00:21:09,900
maybe<font color="#E5E5E5"> we can talk about</font><font color="#CCCCCC"> it so</font><font color="#E5E5E5"> okay thank</font>

488
00:21:06,750 --> 00:21:11,030
<font color="#CCCCCC">you okay we can only make time for one</font>

489
00:21:09,900 --> 00:21:16,080
more question

490
00:21:11,030 --> 00:21:19,139
hello<font color="#E5E5E5"> State University</font><font color="#CCCCCC"> so also</font><font color="#E5E5E5"> a great</font>

491
00:21:16,080 --> 00:21:21,659
work just a question about so<font color="#CCCCCC"> order</font><font color="#E5E5E5"> any</font>

492
00:21:19,140 --> 00:21:24,030
of<font color="#E5E5E5"> proofs that operate in the lattice</font>

493
00:21:21,660 --> 00:21:25,770
<font color="#CCCCCC">domaine because there are lots of</font><font color="#E5E5E5"> a</font>

494
00:21:24,030 --> 00:21:28,440
digital<font color="#E5E5E5"> signature develops that are</font>

495
00:21:25,770 --> 00:21:30,120
based on<font color="#CCCCCC"> future</font><font color="#E5E5E5"> transform</font><font color="#CCCCCC"> mm-hmm</font>

496
00:21:28,440 --> 00:21:32,610
lattices so do we see<font color="#CCCCCC"> that</font><font color="#E5E5E5"> these</font>

497
00:21:30,120 --> 00:21:34,350
techniques<font color="#E5E5E5"> are kind of extendable or</font>

498
00:21:32,610 --> 00:21:37,229
applicable to lattices so that that

499
00:21:34,350 --> 00:21:40,169
could<font color="#E5E5E5"> take it off</font><font color="#CCCCCC"> for security</font><font color="#E5E5E5"> yeah that</font>

500
00:21:37,230 --> 00:21:42,420
is a<font color="#E5E5E5"> very interesting question the</font>

501
00:21:40,170 --> 00:21:44,340
question<font color="#E5E5E5"> is or the technical challenge</font>

502
00:21:42,420 --> 00:21:47,010
is whether you can find<font color="#E5E5E5"> sort of find a</font>

503
00:21:44,340 --> 00:21:49,139
<font color="#CCCCCC">commitment system or a</font><font color="#E5E5E5"> commitment scheme</font>

504
00:21:47,010 --> 00:21:51,540
that<font color="#E5E5E5"> has the same properties as these</font>

505
00:21:49,140 --> 00:21:54,030
discrete log based commitments in the

506
00:21:51,540 --> 00:21:55,889
<font color="#E5E5E5">lattice setting but there's no sort of</font>

507
00:21:54,030 --> 00:21:56,340
fundamental reason why<font color="#CCCCCC"> this</font><font color="#E5E5E5"> isn't</font>

508
00:21:55,890 --> 00:21:57,840
possible

509
00:21:56,340 --> 00:22:01,889
okay<font color="#E5E5E5"> but yeah it's an interesting</font>

510
00:21:57,840 --> 00:22:04,399
question<font color="#E5E5E5"> yeah thank you okay let's thank</font>

511
00:22:01,890 --> 00:22:04,400
<font color="#CCCCCC">the speaker again</font>

