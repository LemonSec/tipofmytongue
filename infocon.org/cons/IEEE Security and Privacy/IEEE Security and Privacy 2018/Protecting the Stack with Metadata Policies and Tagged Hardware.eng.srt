1
00:00:07,730 --> 00:00:12,810
now testing

2
00:00:10,620 --> 00:00:14,950
<font color="#E5E5E5">all right yes thank</font><font color="#CCCCCC"> you</font><font color="#E5E5E5"> my name is Nick</font>

3
00:00:12,810 --> 00:00:17,080
<font color="#E5E5E5">Rustler I'm presenting protecting</font>

4
00:00:14,950 --> 00:00:19,210
meditative policies<font color="#E5E5E5"> and tagged</font><font color="#CCCCCC"> hardware</font>

5
00:00:17,080 --> 00:00:22,659
this<font color="#E5E5E5"> is joint work with my</font><font color="#CCCCCC"> adviser Andre</font>

6
00:00:19,210 --> 00:00:25,390
<font color="#E5E5E5">de</font><font color="#CCCCCC"> Haan</font><font color="#E5E5E5"> okay I'll start</font><font color="#CCCCCC"> with an overview</font>

7
00:00:22,660 --> 00:00:27,160
of<font color="#E5E5E5"> the research we know that the call</font>

8
00:00:25,390 --> 00:00:29,410
stack is a vulnerable system component

9
00:00:27,160 --> 00:00:31,150
lots of critical<font color="#CCCCCC"> software today</font><font color="#E5E5E5"> such as</font>

10
00:00:29,410 --> 00:00:32,830
<font color="#E5E5E5">operating systems and device drivers</font><font color="#CCCCCC"> are</font>

11
00:00:31,150 --> 00:00:35,739
written in<font color="#CCCCCC"> low-level</font><font color="#E5E5E5"> memory unsafe</font>

12
00:00:32,830 --> 00:00:37,300
languages like C there are lightweight

13
00:00:35,739 --> 00:00:39,279
<font color="#E5E5E5">defenses for the stack</font><font color="#CCCCCC"> such as stack</font>

14
00:00:37,300 --> 00:00:40,599
Canaries<font color="#E5E5E5"> these imposed only a few</font>

15
00:00:39,280 --> 00:00:42,489
percent overhead<font color="#E5E5E5"> and so they're widely</font>

16
00:00:40,600 --> 00:00:45,100
<font color="#E5E5E5">deployed</font><font color="#CCCCCC"> but they're insufficient</font><font color="#E5E5E5"> and</font>

17
00:00:42,489 --> 00:00:46,720
actually protecting the stack there are

18
00:00:45,100 --> 00:00:48,699
some<font color="#E5E5E5"> heavyweight mechanisms such</font><font color="#CCCCCC"> as full</font>

19
00:00:46,720 --> 00:00:50,440
software memory safety<font color="#E5E5E5"> these provide us</font>

20
00:00:48,699 --> 00:00:52,170
with good security properties but

21
00:00:50,440 --> 00:00:54,489
they're too slow to be used in practice

22
00:00:52,170 --> 00:00:56,170
<font color="#E5E5E5">and this work we look at creating</font><font color="#CCCCCC"> stack</font>

23
00:00:54,489 --> 00:00:59,979
protection policies for<font color="#E5E5E5"> a</font>

24
00:00:56,170 --> 00:01:01,210
<font color="#CCCCCC">general-purpose tagged architecture we</font>

25
00:00:59,979 --> 00:01:02,710
find that we can<font color="#E5E5E5"> provide object level</font>

26
00:01:01,210 --> 00:01:04,420
<font color="#E5E5E5">protection</font><font color="#CCCCCC"> and we can optimize their</font>

27
00:01:02,710 --> 00:01:08,760
policies to<font color="#CCCCCC"> only impose a three or four</font>

28
00:01:04,420 --> 00:01:10,990
percent overhead<font color="#CCCCCC"> our key optimizations</font>

29
00:01:08,760 --> 00:01:13,090
<font color="#CCCCCC">allow us</font><font color="#E5E5E5"> to remove the need to</font>

30
00:01:10,990 --> 00:01:15,039
proactively<font color="#E5E5E5"> tag and then clear stack</font>

31
00:01:13,090 --> 00:01:17,890
memory<font color="#CCCCCC"> and we'll see exactly</font><font color="#E5E5E5"> how this</font>

32
00:01:15,040 --> 00:01:19,719
<font color="#E5E5E5">works and what it means later on as now</font>

33
00:01:17,890 --> 00:01:21,909
<font color="#CCCCCC">on for the TAC as it</font><font color="#E5E5E5"> outline for the</font>

34
00:01:19,719 --> 00:01:23,408
talk<font color="#CCCCCC"> I'll remind</font><font color="#E5E5E5"> you about</font><font color="#CCCCCC"> what the call</font>

35
00:01:21,909 --> 00:01:25,149
stack is how it works and<font color="#CCCCCC"> how its</font>

36
00:01:23,409 --> 00:01:26,890
attacked<font color="#CCCCCC"> although</font><font color="#E5E5E5"> an introduce</font><font color="#CCCCCC"> our</font>

37
00:01:25,149 --> 00:01:28,960
tagged architecture which we call the

38
00:01:26,890 --> 00:01:32,170
pump well then see how<font color="#E5E5E5"> we can use</font><font color="#CCCCCC"> the</font>

39
00:01:28,960 --> 00:01:33,788
pump to protect the stack<font color="#CCCCCC"> then we'll</font><font color="#E5E5E5"> get</font>

40
00:01:32,170 --> 00:01:35,170
<font color="#E5E5E5">some</font><font color="#CCCCCC"> results performance results and</font>

41
00:01:33,789 --> 00:01:37,859
some optimizations to<font color="#E5E5E5"> make the policy</font>

42
00:01:35,170 --> 00:01:40,240
run faster<font color="#E5E5E5"> and lastly</font><font color="#CCCCCC"> we will summarize</font>

43
00:01:37,859 --> 00:01:42,460
<font color="#CCCCCC">okay so some background about the call</font>

44
00:01:40,240 --> 00:01:43,600
stack the call stack is simply a data

45
00:01:42,460 --> 00:01:46,029
structure<font color="#CCCCCC"> for maintaining the</font>

46
00:01:43,600 --> 00:01:47,408
abstraction<font color="#E5E5E5"> of a function call each time</font>

47
00:01:46,030 --> 00:01:49,060
a function<font color="#E5E5E5"> is called our program will</font>

48
00:01:47,409 --> 00:01:54,039
push a<font color="#CCCCCC"> new stack frame</font><font color="#E5E5E5"> onto</font><font color="#CCCCCC"> the top of</font>

49
00:01:49,060 --> 00:01:55,479
<font color="#CCCCCC">the existing stack</font><font color="#E5E5E5"> the program the stack</font>

50
00:01:54,039 --> 00:01:57,369
frame<font color="#CCCCCC"> will serve a</font><font color="#E5E5E5"> few purposes</font><font color="#CCCCCC"> a</font>

51
00:01:55,479 --> 00:01:59,259
function of allocate space for<font color="#CCCCCC"> its local</font>

52
00:01:57,369 --> 00:02:01,359
<font color="#CCCCCC">variables the return</font><font color="#E5E5E5"> address of the</font>

53
00:01:59,259 --> 00:02:03,569
function<font color="#CCCCCC"> passed arguments spilled</font>

54
00:02:01,359 --> 00:02:06,280
registers and a few other<font color="#CCCCCC"> things as well</font>

55
00:02:03,569 --> 00:02:09,369
<font color="#E5E5E5">let's look at an example of the stack</font>

56
00:02:06,280 --> 00:02:10,840
<font color="#CCCCCC">memory</font><font color="#E5E5E5"> while a function is is running so</font>

57
00:02:09,369 --> 00:02:13,300
on the Left<font color="#E5E5E5"> there's a simple</font><font color="#CCCCCC"> function f</font>

58
00:02:10,840 --> 00:02:15,780
it takes a and<font color="#E5E5E5"> B I feel like I have a</font>

59
00:02:13,300 --> 00:02:15,780
lot<font color="#CCCCCC"> of echo</font>

60
00:02:16,670 --> 00:02:21,230
there's a function<font color="#CCCCCC"> f it</font><font color="#E5E5E5"> takes a and B</font>

61
00:02:18,409 --> 00:02:23,209
and returns<font color="#E5E5E5"> a squared plus B below that</font>

62
00:02:21,230 --> 00:02:26,030
there's a main<font color="#E5E5E5"> function that calls</font><font color="#CCCCCC"> F</font>

63
00:02:23,209 --> 00:02:28,250
simply passing in some arguments let's

64
00:02:26,030 --> 00:02:30,200
assume that our main<font color="#E5E5E5"> function is</font><font color="#CCCCCC"> already</font>

65
00:02:28,250 --> 00:02:32,599
<font color="#E5E5E5">running main</font><font color="#CCCCCC"> we'll have allocated</font><font color="#E5E5E5"> space</font>

66
00:02:30,200 --> 00:02:34,069
for its local<font color="#CCCCCC"> variables</font><font color="#E5E5E5"> x and y as well</font>

67
00:02:32,599 --> 00:02:37,099
<font color="#E5E5E5">as its frame pointer and its return</font>

68
00:02:34,069 --> 00:02:39,018
address when main calls<font color="#CCCCCC"> f this causes f</font>

69
00:02:37,099 --> 00:02:41,358
to push a<font color="#E5E5E5"> new stack frame</font><font color="#CCCCCC"> onto the top</font>

70
00:02:39,019 --> 00:02:43,310
of<font color="#CCCCCC"> the stack f will</font><font color="#E5E5E5"> allocate space</font><font color="#CCCCCC"> for</font>

71
00:02:41,359 --> 00:02:44,689
<font color="#CCCCCC">its local</font><font color="#E5E5E5"> variable results as well as</font>

72
00:02:43,310 --> 00:02:46,819
its return address<font color="#E5E5E5"> and</font><font color="#CCCCCC"> its frame pointer</font>

73
00:02:44,689 --> 00:02:48,739
<font color="#E5E5E5">the frame point the return address</font>

74
00:02:46,819 --> 00:02:51,140
belonging<font color="#CCCCCC"> to</font><font color="#E5E5E5"> F points back into main</font>

75
00:02:48,739 --> 00:02:52,879
when F is finished<font color="#E5E5E5"> running it releases</font>

76
00:02:51,140 --> 00:02:55,190
its stack frame<font color="#E5E5E5"> and follows its return</font>

77
00:02:52,879 --> 00:02:57,470
address<font color="#E5E5E5"> and control resumes back in main</font>

78
00:02:55,190 --> 00:03:00,409
<font color="#E5E5E5">we're now back to where we started</font><font color="#CCCCCC"> after</font>

79
00:02:57,470 --> 00:03:02,720
<font color="#CCCCCC">having called F so to remind</font><font color="#E5E5E5"> you</font><font color="#CCCCCC"> about</font>

80
00:03:00,409 --> 00:03:04,819
how a classic stack stack<font color="#E5E5E5"> attack works</font>

81
00:03:02,720 --> 00:03:06,950
let's<font color="#E5E5E5"> look at a simple buffer overflow</font>

82
00:03:04,819 --> 00:03:08,599
on the Left I've shown<font color="#E5E5E5"> you a vulnerable</font>

83
00:03:06,950 --> 00:03:10,849
<font color="#CCCCCC">C function and on the right I've shown</font>

84
00:03:08,599 --> 00:03:12,980
its corresponding stack frame vulnerable

85
00:03:10,849 --> 00:03:15,470
copies from<font color="#E5E5E5"> the car</font><font color="#CCCCCC"> start input into a</font>

86
00:03:12,980 --> 00:03:17,268
<font color="#E5E5E5">local buffer of length 8 if more</font><font color="#CCCCCC"> than 8</font>

87
00:03:15,470 --> 00:03:18,889
bytes of input are provided we the

88
00:03:17,269 --> 00:03:20,449
program will copy<font color="#E5E5E5"> off the end of buff</font>

89
00:03:18,889 --> 00:03:22,129
and<font color="#CCCCCC"> onto whatever</font><font color="#E5E5E5"> happens to be</font><font color="#CCCCCC"> an X in</font>

90
00:03:20,449 --> 00:03:24,290
memory which in this case is a frame

91
00:03:22,129 --> 00:03:25,399
pointer and the return address this

92
00:03:24,290 --> 00:03:27,379
allows an<font color="#CCCCCC"> attacker with to override</font>

93
00:03:25,400 --> 00:03:29,629
<font color="#E5E5E5">their return address and</font><font color="#CCCCCC"> then later</font>

94
00:03:27,379 --> 00:03:31,160
hijack<font color="#E5E5E5"> control flow well when the</font>

95
00:03:29,629 --> 00:03:33,590
program<font color="#CCCCCC"> goes</font><font color="#E5E5E5"> to use the tampered return</font>

96
00:03:31,160 --> 00:03:35,870
address recall<font color="#E5E5E5"> that</font><font color="#CCCCCC"> all these</font><font color="#E5E5E5"> other</font>

97
00:03:33,590 --> 00:03:37,459
things end up<font color="#E5E5E5"> on the stack as</font><font color="#CCCCCC"> well</font><font color="#E5E5E5"> the</font>

98
00:03:35,870 --> 00:03:40,190
other<font color="#CCCCCC"> local</font><font color="#E5E5E5"> variables spelled registers</font>

99
00:03:37,459 --> 00:03:44,449
arguments and these can also<font color="#E5E5E5"> I'll be</font>

100
00:03:40,190 --> 00:03:46,190
overwritten to mount attacks as well<font color="#E5E5E5"> we</font>

101
00:03:44,449 --> 00:03:48,590
note<font color="#E5E5E5"> that an attacker will hijack</font>

102
00:03:46,190 --> 00:03:50,090
<font color="#E5E5E5">instructions</font><font color="#CCCCCC"> or pointers to access the</font>

103
00:03:48,590 --> 00:03:54,620
wrong stack objects<font color="#CCCCCC"> when they're doing</font>

104
00:03:50,090 --> 00:03:55,519
<font color="#E5E5E5">an attack like this and so from a from a</font>

105
00:03:54,620 --> 00:03:57,530
<font color="#E5E5E5">security perspective</font>

106
00:03:55,519 --> 00:04:00,019
wouldn't it be useful<font color="#E5E5E5"> if the stack was</font>

107
00:03:57,530 --> 00:04:01,639
<font color="#E5E5E5">labeled what if we knew something</font><font color="#CCCCCC"> about</font>

108
00:04:00,019 --> 00:04:03,859
each of the words<font color="#E5E5E5"> stored in our stack</font>

109
00:04:01,639 --> 00:04:05,480
<font color="#CCCCCC">memory on the</font><font color="#E5E5E5"> Left I've shown the</font>

110
00:04:03,859 --> 00:04:07,459
vulnerable<font color="#CCCCCC"> C function</font><font color="#E5E5E5"> from before as</font>

111
00:04:05,480 --> 00:04:09,500
well<font color="#E5E5E5"> as some dummy functions that simply</font>

112
00:04:07,459 --> 00:04:12,590
call this function<font color="#E5E5E5"> and on the right</font><font color="#CCCCCC"> I've</font>

113
00:04:09,500 --> 00:04:14,150
shown a stack<font color="#CCCCCC"> memory so what if we could</font>

114
00:04:12,590 --> 00:04:16,608
assign a color to<font color="#CCCCCC"> each one</font><font color="#E5E5E5"> of our</font>

115
00:04:14,150 --> 00:04:19,340
<font color="#CCCCCC">functions that</font><font color="#E5E5E5"> might look</font><font color="#CCCCCC"> something like</font>

116
00:04:16,608 --> 00:04:22,039
this we now have a green function<font color="#CCCCCC"> a blue</font>

117
00:04:19,339 --> 00:04:23,150
<font color="#E5E5E5">function and a red</font><font color="#CCCCCC"> function</font><font color="#E5E5E5"> and then</font>

118
00:04:22,039 --> 00:04:24,650
what if<font color="#E5E5E5"> you took our functions could</font>

119
00:04:23,150 --> 00:04:27,010
<font color="#E5E5E5">color the</font><font color="#CCCCCC"> memory</font><font color="#E5E5E5"> that they allocated</font>

120
00:04:24,650 --> 00:04:29,150
with their corresponding<font color="#CCCCCC"> function colors</font>

121
00:04:27,010 --> 00:04:31,430
our stack might look<font color="#E5E5E5"> something like</font>

122
00:04:29,150 --> 00:04:32,810
<font color="#E5E5E5">this abstractly</font><font color="#CCCCCC"> speaking we can see how</font>

123
00:04:31,430 --> 00:04:35,240
this<font color="#E5E5E5"> might</font><font color="#CCCCCC"> be useful for coarse-grained</font>

124
00:04:32,810 --> 00:04:36,860
<font color="#E5E5E5">frame level</font><font color="#CCCCCC"> protection policies perhaps</font>

125
00:04:35,240 --> 00:04:39,110
now we could detect if a green buffer

126
00:04:36,860 --> 00:04:41,780
overflows its frame<font color="#E5E5E5"> and writes</font><font color="#CCCCCC"> into</font><font color="#E5E5E5"> some</font>

127
00:04:39,110 --> 00:04:44,210
blue memory if our labeling was more

128
00:04:41,780 --> 00:04:46,190
precise<font color="#E5E5E5"> that is we knew not</font><font color="#CCCCCC"> only which</font>

129
00:04:44,210 --> 00:04:48,049
function allocated<font color="#E5E5E5"> a piece of memory the</font>

130
00:04:46,190 --> 00:04:49,640
<font color="#CCCCCC">loci of</font><font color="#E5E5E5"> the objects was stored</font><font color="#CCCCCC"> there we</font>

131
00:04:48,050 --> 00:04:50,720
might have something<font color="#CCCCCC"> like this and</font><font color="#E5E5E5"> we</font>

132
00:04:49,640 --> 00:04:53,330
<font color="#E5E5E5">can see how this might provide the</font>

133
00:04:50,720 --> 00:04:55,150
footing for<font color="#E5E5E5"> more precise protection to</font>

134
00:04:53,330 --> 00:04:57,469
make<font color="#E5E5E5"> use of all these labels</font>

135
00:04:55,150 --> 00:04:59,960
what if our instructions and<font color="#E5E5E5"> our</font>

136
00:04:57,470 --> 00:05:01,160
pointers were<font color="#E5E5E5"> labeled as well so perhaps</font>

137
00:04:59,960 --> 00:05:03,320
we could say<font color="#CCCCCC"> things like</font><font color="#E5E5E5"> this</font>

138
00:05:01,160 --> 00:05:05,480
instruction<font color="#E5E5E5"> stores a blue return address</font>

139
00:05:03,320 --> 00:05:07,310
this in memory<font color="#E5E5E5"> word now contains the</font>

140
00:05:05,480 --> 00:05:09,350
blue return address<font color="#E5E5E5"> and</font><font color="#CCCCCC"> this instruction</font>

141
00:05:07,310 --> 00:05:12,050
<font color="#E5E5E5">should load specifically a blue return</font>

142
00:05:09,350 --> 00:05:15,860
address<font color="#CCCCCC"> or this pointer is a pointer to</font>

143
00:05:12,050 --> 00:05:17,780
a green array called buff<font color="#E5E5E5"> so this policy</font>

144
00:05:15,860 --> 00:05:19,850
<font color="#E5E5E5">is one of the three policies that we</font>

145
00:05:17,780 --> 00:05:21,409
look at in<font color="#E5E5E5"> the paper and the rest of the</font>

146
00:05:19,850 --> 00:05:23,030
talk I'll focus<font color="#E5E5E5"> on just this policy</font>

147
00:05:21,410 --> 00:05:25,160
we'll see how we can<font color="#E5E5E5"> define a more</font>

148
00:05:23,030 --> 00:05:26,150
precisely and then enforce it<font color="#E5E5E5"> and</font>

149
00:05:25,160 --> 00:05:28,160
accelerate it with the tagged

150
00:05:26,150 --> 00:05:29,419
architecture and then<font color="#E5E5E5"> we'll optimize it</font>

151
00:05:28,160 --> 00:05:32,060
<font color="#CCCCCC">so don't</font><font color="#E5E5E5"> leave those</font><font color="#CCCCCC"> our</font><font color="#E5E5E5"> programs down</font>

152
00:05:29,420 --> 00:05:33,650
by a few percent<font color="#E5E5E5"> with that I'll take</font><font color="#CCCCCC"> a</font>

153
00:05:32,060 --> 00:05:34,820
step back and look at<font color="#E5E5E5"> the tagged</font>

154
00:05:33,650 --> 00:05:37,940
architecture they were going to

155
00:05:34,820 --> 00:05:39,860
implement<font color="#E5E5E5"> this policy on top of our</font>

156
00:05:37,940 --> 00:05:41,930
tagged architecture is called the pump

157
00:05:39,860 --> 00:05:45,470
<font color="#E5E5E5">this is short for the programmable unit</font>

158
00:05:41,930 --> 00:05:47,990
for metadata<font color="#CCCCCC"> processing so a normal</font><font color="#E5E5E5"> CPU</font>

159
00:05:45,470 --> 00:05:51,890
has some amount<font color="#E5E5E5"> of state shown in blue</font>

160
00:05:47,990 --> 00:05:53,300
such as registers a<font color="#E5E5E5"> B</font><font color="#CCCCCC"> C</font><font color="#E5E5E5"> and D a program</font>

161
00:05:51,890 --> 00:05:56,090
counter<font color="#E5E5E5"> it tells us where I rat in our</font>

162
00:05:53,300 --> 00:05:58,100
program and a memory and our tagged

163
00:05:56,090 --> 00:06:00,950
architecture we extend each of these

164
00:05:58,100 --> 00:06:04,120
<font color="#E5E5E5">pieces of</font><font color="#CCCCCC"> State with</font><font color="#E5E5E5"> the tag shown in</font>

165
00:06:00,950 --> 00:06:06,979
green when<font color="#E5E5E5"> the CPU is running a</font><font color="#CCCCCC"> program</font>

166
00:06:04,120 --> 00:06:09,770
such as<font color="#E5E5E5"> this one we will check each</font>

167
00:06:06,980 --> 00:06:13,340
instruction against a tag based<font color="#CCCCCC"> security</font>

168
00:06:09,770 --> 00:06:15,260
monitor shown here the inputs to<font color="#CCCCCC"> the</font>

169
00:06:13,340 --> 00:06:17,419
security monitor<font color="#E5E5E5"> are all of the tags</font>

170
00:06:15,260 --> 00:06:19,580
<font color="#E5E5E5">that are relevant for this instruction</font>

171
00:06:17,420 --> 00:06:23,270
in this<font color="#E5E5E5"> case that's the tags on the</font>

172
00:06:19,580 --> 00:06:25,940
operands a and B will also<font color="#E5E5E5"> take in the</font>

173
00:06:23,270 --> 00:06:27,740
tag on<font color="#E5E5E5"> the program counter this</font>

174
00:06:25,940 --> 00:06:29,660
instruction itself<font color="#E5E5E5"> lives somewhere</font><font color="#CCCCCC"> in</font>

175
00:06:27,740 --> 00:06:31,880
memory<font color="#E5E5E5"> and so</font><font color="#CCCCCC"> we'll take</font><font color="#E5E5E5"> in the tag on</font>

176
00:06:29,660 --> 00:06:33,770
<font color="#E5E5E5">the instruction and then lastly the</font>

177
00:06:31,880 --> 00:06:36,680
opcode of the instruction will<font color="#CCCCCC"> be an</font>

178
00:06:33,770 --> 00:06:39,380
input<font color="#CCCCCC"> as well and turn the security</font>

179
00:06:36,680 --> 00:06:41,780
monitor now computes a<font color="#CCCCCC"> function of</font><font color="#E5E5E5"> five</font>

180
00:06:39,380 --> 00:06:43,009
inputs<font color="#E5E5E5"> which are the arrows shown to</font>

181
00:06:41,780 --> 00:06:45,529
decide if the operation<font color="#E5E5E5"> should</font>

182
00:06:43,009 --> 00:06:47,330
<font color="#CCCCCC">aloud or</font><font color="#E5E5E5"> not if it decides yes the</font>

183
00:06:45,529 --> 00:06:48,650
operation should<font color="#CCCCCC"> be allowed you must</font>

184
00:06:47,330 --> 00:06:50,808
provide a tag for the result of the

185
00:06:48,650 --> 00:06:54,229
operation<font color="#E5E5E5"> which in this case would go on</font>

186
00:06:50,809 --> 00:06:55,279
the tag<font color="#CCCCCC"> unregister</font><font color="#E5E5E5"> see in our</font>

187
00:06:54,229 --> 00:06:57,619
architecture<font color="#E5E5E5"> and its corresponding</font>

188
00:06:55,279 --> 00:06:59,629
programming model policies are written

189
00:06:57,619 --> 00:07:01,939
<font color="#CCCCCC">in software</font><font color="#E5E5E5"> that</font><font color="#CCCCCC"> is the security monitor</font>

190
00:06:59,629 --> 00:07:03,800
<font color="#CCCCCC">is</font><font color="#E5E5E5"> just a program the hardware</font>

191
00:07:01,939 --> 00:07:05,360
accelerates the security monitor by

192
00:07:03,800 --> 00:07:07,249
<font color="#E5E5E5">caching a subset of the recently</font>

193
00:07:05,360 --> 00:07:09,499
encountered<font color="#E5E5E5"> rules in a hardware cache</font>

194
00:07:07,249 --> 00:07:12,619
where<font color="#CCCCCC"> a</font><font color="#E5E5E5"> rule is just a set</font><font color="#CCCCCC"> of the inputs</font>

195
00:07:09,499 --> 00:07:14,899
and<font color="#E5E5E5"> the output in the case of a cache</font>

196
00:07:12,619 --> 00:07:16,939
hit<font color="#CCCCCC"> we can then check</font><font color="#E5E5E5"> the policy and a</font>

197
00:07:14,899 --> 00:07:19,449
single cycle<font color="#E5E5E5"> without slowing</font><font color="#CCCCCC"> or stalling</font>

198
00:07:16,939 --> 00:07:21,499
the CPU at all

199
00:07:19,449 --> 00:07:23,599
there are optimizations<font color="#CCCCCC"> that can</font>

200
00:07:21,499 --> 00:07:25,189
drastically<font color="#E5E5E5"> reduce the area and energy</font>

201
00:07:23,599 --> 00:07:27,139
overheads associated with adding<font color="#E5E5E5"> all</font>

202
00:07:25,189 --> 00:07:28,399
these<font color="#E5E5E5"> tags on to our chip I'll refer you</font>

203
00:07:27,139 --> 00:07:30,199
<font color="#E5E5E5">to the</font><font color="#CCCCCC"> paper</font><font color="#E5E5E5"> site here from our</font>

204
00:07:28,399 --> 00:07:33,529
information<font color="#CCCCCC"> about the optimizations and</font>

205
00:07:30,199 --> 00:07:35,870
the architecture prior work has shown

206
00:07:33,529 --> 00:07:37,550
how<font color="#E5E5E5"> this architecture can express an</font>

207
00:07:35,870 --> 00:07:39,559
<font color="#E5E5E5">accelerate a range of security</font><font color="#CCCCCC"> policies</font>

208
00:07:37,550 --> 00:07:41,839
<font color="#CCCCCC">these include taint tracking control</font>

209
00:07:39,559 --> 00:07:44,389
flow integrity type safety<font color="#E5E5E5"> peep safety</font>

210
00:07:41,839 --> 00:07:46,369
information flow control and<font color="#E5E5E5"> others the</font>

211
00:07:44,389 --> 00:07:47,839
contribution<font color="#E5E5E5"> of this paper is</font><font color="#CCCCCC"> looking at</font>

212
00:07:46,369 --> 00:07:49,819
how<font color="#E5E5E5"> we can protect the stack with this</font>

213
00:07:47,839 --> 00:07:51,199
architecture<font color="#CCCCCC"> our stack</font><font color="#E5E5E5"> policies end up</font>

214
00:07:49,819 --> 00:07:53,680
being some of<font color="#E5E5E5"> our more involved policies</font>

215
00:07:51,199 --> 00:07:56,389
and they bring<font color="#E5E5E5"> up some new</font><font color="#CCCCCC"> challenges</font>

216
00:07:53,680 --> 00:07:58,789
okay well now tie this back to<font color="#CCCCCC"> looking</font>

217
00:07:56,389 --> 00:08:01,159
<font color="#E5E5E5">at the stack labeling that we</font><font color="#CCCCCC"> talked</font><font color="#E5E5E5"> to</font>

218
00:07:58,789 --> 00:08:02,419
looked at a few<font color="#E5E5E5"> slides ago so we have</font>

219
00:08:01,159 --> 00:08:03,860
<font color="#E5E5E5">this architecture it provides us with</font>

220
00:08:02,419 --> 00:08:05,599
the tag on every word of data in the

221
00:08:03,860 --> 00:08:07,099
system<font color="#E5E5E5"> we</font><font color="#CCCCCC"> can write rules to describe</font>

222
00:08:05,599 --> 00:08:08,808
<font color="#E5E5E5">what operations are allowed and what the</font>

223
00:08:07,099 --> 00:08:10,099
results are<font color="#E5E5E5"> and we have some hardware</font>

224
00:08:08,809 --> 00:08:12,529
<font color="#E5E5E5">that will remember the rules that we've</font>

225
00:08:10,099 --> 00:08:14,269
encountered<font color="#E5E5E5"> on the</font><font color="#CCCCCC"> Left</font><font color="#E5E5E5"> I've shown a</font>

226
00:08:12,529 --> 00:08:16,969
simple program it is trying<font color="#E5E5E5"> to write to</font>

227
00:08:14,269 --> 00:08:19,849
<font color="#CCCCCC">a local variable</font><font color="#E5E5E5"> X and on the</font><font color="#CCCCCC"> right</font><font color="#E5E5E5"> I've</font>

228
00:08:16,969 --> 00:08:21,919
shown a stack frame of how I<font color="#E5E5E5"> did the</font>

229
00:08:19,849 --> 00:08:23,300
instruction that's doing a store and<font color="#E5E5E5"> we</font>

230
00:08:21,919 --> 00:08:25,459
can see<font color="#E5E5E5"> that X is at the top</font><font color="#CCCCCC"> of the</font>

231
00:08:23,300 --> 00:08:26,749
stack on the<font color="#CCCCCC"> right so we can</font><font color="#E5E5E5"> now</font>

232
00:08:25,459 --> 00:08:28,309
communicate the intent of<font color="#E5E5E5"> this</font>

233
00:08:26,749 --> 00:08:30,800
instruction<font color="#E5E5E5"> that is it should write</font>

234
00:08:28,309 --> 00:08:33,289
specifically to this<font color="#E5E5E5"> red X</font><font color="#CCCCCC"> by placing a</font>

235
00:08:30,800 --> 00:08:36,229
tag<font color="#E5E5E5"> on the instruction we can then write</font>

236
00:08:33,289 --> 00:08:39,919
a rule that says if the instruction tag

237
00:08:36,229 --> 00:08:42,800
is store<font color="#E5E5E5"> red X and the memory tag is red</font>

238
00:08:39,919 --> 00:08:45,290
X then<font color="#CCCCCC"> this operation is allowed and the</font>

239
00:08:42,799 --> 00:08:48,680
result is<font color="#CCCCCC"> that the tag</font><font color="#E5E5E5"> should</font><font color="#CCCCCC"> remain red</font>

240
00:08:45,290 --> 00:08:51,019
<font color="#E5E5E5">X our software can</font><font color="#CCCCCC"> be written more</font>

241
00:08:48,680 --> 00:08:53,420
generally we<font color="#E5E5E5"> can</font><font color="#CCCCCC"> say if the instruction</font>

242
00:08:51,019 --> 00:08:55,290
tag is to<font color="#E5E5E5"> store some color C containing</font>

243
00:08:53,420 --> 00:08:57,180
<font color="#E5E5E5">some object identifier and</font>

244
00:08:55,290 --> 00:08:59,520
and the memory tag is<font color="#E5E5E5"> colored</font><font color="#CCCCCC"> see and</font>

245
00:08:57,180 --> 00:09:01,319
contains object<font color="#CCCCCC"> n then the operation is</font>

246
00:08:59,520 --> 00:09:03,150
allowed and<font color="#E5E5E5"> the result is</font><font color="#CCCCCC"> that the</font><font color="#E5E5E5"> tag</font>

247
00:09:01,320 --> 00:09:06,600
<font color="#E5E5E5">should remain colored C containing</font>

248
00:09:03,150 --> 00:09:08,579
<font color="#E5E5E5">object</font><font color="#CCCCCC"> n so what does a violation look</font>

249
00:09:06,600 --> 00:09:09,840
like<font color="#E5E5E5"> if we try</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> take this instruction</font>

250
00:09:08,580 --> 00:09:11,880
<font color="#E5E5E5">and write to a different</font><font color="#CCCCCC"> item on the</font>

251
00:09:09,840 --> 00:09:14,520
<font color="#E5E5E5">stack such as the return address in the</font>

252
00:09:11,880 --> 00:09:16,860
frame below<font color="#E5E5E5"> well the instruction tag is</font>

253
00:09:14,520 --> 00:09:18,780
store red X but the memory tag is blue

254
00:09:16,860 --> 00:09:20,640
return address<font color="#E5E5E5"> this does not match the</font>

255
00:09:18,780 --> 00:09:23,730
<font color="#CCCCCC">above rule</font><font color="#E5E5E5"> and we can terminate the</font>

256
00:09:20,640 --> 00:09:26,400
<font color="#E5E5E5">program</font><font color="#CCCCCC"> okay so with this we can see how</font>

257
00:09:23,730 --> 00:09:27,510
we can check a stack access what else do

258
00:09:26,400 --> 00:09:29,910
we<font color="#E5E5E5"> need to finish building out this</font>

259
00:09:27,510 --> 00:09:31,920
policy<font color="#CCCCCC"> well for</font><font color="#E5E5E5"> one we've assumed up to</font>

260
00:09:29,910 --> 00:09:34,650
now<font color="#E5E5E5"> that the stack was already tagged we</font>

261
00:09:31,920 --> 00:09:36,959
have to tag the stack to do that we add

262
00:09:34,650 --> 00:09:39,720
instructions into<font color="#CCCCCC"> the Prolog</font><font color="#E5E5E5"> that tag</font>

263
00:09:36,960 --> 00:09:41,970
the<font color="#CCCCCC"> e allocated frame these instructions</font>

264
00:09:39,720 --> 00:09:44,370
get<font color="#E5E5E5"> a special tag</font><font color="#CCCCCC"> set mem</font><font color="#E5E5E5"> that allows</font>

265
00:09:41,970 --> 00:09:46,170
them<font color="#E5E5E5"> to claim unused memory in general</font>

266
00:09:44,370 --> 00:09:48,360
<font color="#CCCCCC">we'll maintain this invariant</font><font color="#E5E5E5"> the unused</font>

267
00:09:46,170 --> 00:09:51,750
<font color="#E5E5E5">second memory has a tag a special tag</font>

268
00:09:48,360 --> 00:09:54,600
empty stack<font color="#E5E5E5"> so at this we can tag our</font>

269
00:09:51,750 --> 00:09:55,950
stack frame we now need some rules<font color="#E5E5E5"> they</font>

270
00:09:54,600 --> 00:09:59,010
<font color="#E5E5E5">can describe all the valid ways that</font>

271
00:09:55,950 --> 00:10:01,650
stack memory<font color="#E5E5E5"> might be used one such way</font>

272
00:09:59,010 --> 00:10:03,720
is by offsetting in the frame pointer to

273
00:10:01,650 --> 00:10:06,000
access a scalar local we saw how<font color="#E5E5E5"> this</font>

274
00:10:03,720 --> 00:10:08,130
works on<font color="#E5E5E5"> the last slide remember you can</font>

275
00:10:06,000 --> 00:10:09,660
also be accessed<font color="#CCCCCC"> through pointers to</font>

276
00:10:08,130 --> 00:10:11,670
capture this kind<font color="#E5E5E5"> of access we tagged</font>

277
00:10:09,660 --> 00:10:13,560
the instructions<font color="#CCCCCC"> they</font><font color="#E5E5E5"> create pointers in</font>

278
00:10:11,670 --> 00:10:15,270
such a way<font color="#CCCCCC"> that the pointer produced has</font>

279
00:10:13,560 --> 00:10:16,680
the correct<font color="#E5E5E5"> label on it</font><font color="#CCCCCC"> and then there</font>

280
00:10:15,270 --> 00:10:18,569
<font color="#E5E5E5">are rules that allow you to use pointers</font>

281
00:10:16,680 --> 00:10:20,780
to access<font color="#E5E5E5"> memory if the tag on the</font>

282
00:10:18,570 --> 00:10:23,040
pointer matches the tag on<font color="#E5E5E5"> the memory</font><font color="#CCCCCC"> a</font>

283
00:10:20,780 --> 00:10:25,439
last<font color="#E5E5E5"> kind of access that we see on the</font>

284
00:10:23,040 --> 00:10:27,120
stack is arguments arguments are a

285
00:10:25,440 --> 00:10:28,770
special case and<font color="#E5E5E5"> at they're owned by one</font>

286
00:10:27,120 --> 00:10:31,050
function or one color and they're

287
00:10:28,770 --> 00:10:32,880
accessed by a different<font color="#E5E5E5"> color the way</font>

288
00:10:31,050 --> 00:10:34,800
that we check<font color="#CCCCCC"> that</font><font color="#E5E5E5"> arguments are</font>

289
00:10:32,880 --> 00:10:36,439
accessed by<font color="#CCCCCC"> the intended consumer those</font>

290
00:10:34,800 --> 00:10:38,520
details are<font color="#CCCCCC"> in the paper</font>

291
00:10:36,440 --> 00:10:40,920
lastly we<font color="#E5E5E5"> have</font><font color="#CCCCCC"> to clean up our stack</font>

292
00:10:38,520 --> 00:10:42,240
<font color="#CCCCCC">memory when we return to do this</font><font color="#E5E5E5"> just</font>

293
00:10:40,920 --> 00:10:43,800
<font color="#E5E5E5">like in the epilogue we</font><font color="#CCCCCC"> add new</font>

294
00:10:42,240 --> 00:10:45,690
instructions here<font color="#E5E5E5"> and these have a</font>

295
00:10:43,800 --> 00:10:47,130
special tag clear mem<font color="#E5E5E5"> that allows us to</font>

296
00:10:45,690 --> 00:10:50,420
<font color="#E5E5E5">release the frame that's owned by this</font>

297
00:10:47,130 --> 00:10:52,620
function<font color="#CCCCCC"> and set it back to</font><font color="#E5E5E5"> empty stack</font>

298
00:10:50,420 --> 00:10:55,160
<font color="#CCCCCC">ok with this we've seen the complete</font>

299
00:10:52,620 --> 00:10:57,720
policy and we can<font color="#E5E5E5"> look at some</font><font color="#CCCCCC"> results</font>

300
00:10:55,160 --> 00:11:00,000
so we simulate a<font color="#CCCCCC"> tag processor with an</font>

301
00:10:57,720 --> 00:11:02,040
<font color="#CCCCCC">inorder five-stage</font><font color="#E5E5E5"> pipeline we use gem 5</font>

302
00:11:00,000 --> 00:11:03,270
for performance<font color="#CCCCCC"> statistics and we</font>

303
00:11:02,040 --> 00:11:06,420
measure our overheads on the spec

304
00:11:03,270 --> 00:11:08,340
benchmarks here<font color="#E5E5E5"> are the results there's</font>

305
00:11:06,420 --> 00:11:08,699
a performance results there's<font color="#CCCCCC"> 1 bar for</font>

306
00:11:08,340 --> 00:11:10,620
each bench

307
00:11:08,700 --> 00:11:12,540
mark showing<font color="#E5E5E5"> the overhead any other</font><font color="#CCCCCC"> head</font>

308
00:11:10,620 --> 00:11:14,850
is broken<font color="#E5E5E5"> down into components</font>

309
00:11:12,540 --> 00:11:18,180
the average overhead for<font color="#E5E5E5"> this</font><font color="#CCCCCC"> naive an</font>

310
00:11:14,850 --> 00:11:19,590
implementation is about<font color="#CCCCCC"> 12% the yellow</font>

311
00:11:18,180 --> 00:11:21,780
<font color="#E5E5E5">here corresponds to the miss handler</font>

312
00:11:19,590 --> 00:11:24,240
<font color="#E5E5E5">this is the software</font><font color="#CCCCCC"> that runs whenever</font>

313
00:11:21,780 --> 00:11:25,230
we take<font color="#E5E5E5"> a</font><font color="#CCCCCC"> Miss in our rule cache</font><font color="#E5E5E5"> we can</font>

314
00:11:24,240 --> 00:11:27,240
see that<font color="#E5E5E5"> this is a very small</font>

315
00:11:25,230 --> 00:11:29,850
contribution<font color="#E5E5E5"> of the overhead this is</font>

316
00:11:27,240 --> 00:11:32,040
because the rules for<font color="#E5E5E5"> this policy</font><font color="#CCCCCC"> are</font>

317
00:11:29,850 --> 00:11:34,290
<font color="#E5E5E5">very</font><font color="#CCCCCC"> cacheable</font><font color="#E5E5E5"> the number of rules we</font>

318
00:11:32,040 --> 00:11:35,430
need<font color="#E5E5E5"> depends on the number</font><font color="#CCCCCC"> of functions</font>

319
00:11:34,290 --> 00:11:37,260
<font color="#CCCCCC">that there aren't</font><font color="#E5E5E5"> the number of colors</font>

320
00:11:35,430 --> 00:11:39,479
<font color="#CCCCCC">that there</font><font color="#E5E5E5"> are we find that there are</font>

321
00:11:37,260 --> 00:11:41,130
<font color="#E5E5E5">about 2,500</font><font color="#CCCCCC"> functions</font><font color="#E5E5E5"> on average in the</font>

322
00:11:39,480 --> 00:11:42,450
spec benchmarks<font color="#CCCCCC"> these are compiled with</font>

323
00:11:41,130 --> 00:11:44,610
- static so these are including<font color="#CCCCCC"> all the</font>

324
00:11:42,450 --> 00:11:46,290
libraries<font color="#E5E5E5"> the only about 400 are used</font>

325
00:11:44,610 --> 00:11:47,610
<font color="#E5E5E5">and only about 90 functions are active</font>

326
00:11:46,290 --> 00:11:49,860
in the working<font color="#E5E5E5"> set so the benchmarks</font>

327
00:11:47,610 --> 00:11:51,480
once they reach reach steady state<font color="#E5E5E5"> this</font>

328
00:11:49,860 --> 00:11:53,160
means the rules are quite<font color="#CCCCCC"> cacheable we</font>

329
00:11:51,480 --> 00:11:54,900
encounter<font color="#E5E5E5"> a function foo we</font><font color="#CCCCCC"> cache all</font>

330
00:11:53,160 --> 00:11:56,219
the rules<font color="#CCCCCC"> that</font><font color="#E5E5E5"> we need for foo the next</font>

331
00:11:54,900 --> 00:11:57,390
time we see foo we already have<font color="#E5E5E5"> those</font>

332
00:11:56,220 --> 00:12:00,870
rules cached<font color="#E5E5E5"> and we don't need to</font>

333
00:11:57,390 --> 00:12:03,420
<font color="#E5E5E5">consult the policy software</font><font color="#CCCCCC"> ok</font><font color="#E5E5E5"> so the</font>

334
00:12:00,870 --> 00:12:05,250
largest cost<font color="#E5E5E5"> we can see shown in blue is</font>

335
00:12:03,420 --> 00:12:07,439
the instructions that<font color="#E5E5E5"> are adding to tag</font>

336
00:12:05,250 --> 00:12:09,240
and then clear stack memory<font color="#E5E5E5"> for example</font>

337
00:12:07,440 --> 00:12:10,470
<font color="#CCCCCC">we can</font><font color="#E5E5E5"> look at string and we can see</font>

338
00:12:09,240 --> 00:12:14,160
that<font color="#E5E5E5"> there's quite a large overhead</font><font color="#CCCCCC"> just</font>

339
00:12:10,470 --> 00:12:15,990
<font color="#CCCCCC">for this one source</font><font color="#E5E5E5"> of overhead</font><font color="#CCCCCC"> ok so</font>

340
00:12:14,160 --> 00:12:17,760
the largest<font color="#E5E5E5"> cost we noted</font><font color="#CCCCCC"> was tagging</font>

341
00:12:15,990 --> 00:12:19,530
stack memory<font color="#E5E5E5"> the worst offender is</font>

342
00:12:17,760 --> 00:12:21,569
<font color="#CCCCCC">Chiang</font><font color="#E5E5E5"> there's a large</font><font color="#CCCCCC"> 60</font><font color="#E5E5E5"> percent</font>

343
00:12:19,530 --> 00:12:24,420
overhead<font color="#CCCCCC"> just for keeping</font><font color="#E5E5E5"> its</font><font color="#CCCCCC"> tits stack</font>

344
00:12:21,570 --> 00:12:26,760
memory tagged<font color="#E5E5E5"> so</font><font color="#CCCCCC"> what's going</font><font color="#E5E5E5"> on here</font>

345
00:12:24,420 --> 00:12:28,949
<font color="#E5E5E5">Chiang is</font><font color="#CCCCCC"> a chess-playing benchmark and</font>

346
00:12:26,760 --> 00:12:31,260
rapidly allocates large 16 kilobyte

347
00:12:28,950 --> 00:12:33,270
frames<font color="#E5E5E5"> these frames contain a buffer and</font>

348
00:12:31,260 --> 00:12:35,340
the buffer is sized<font color="#E5E5E5"> for the worst case</font>

349
00:12:33,270 --> 00:12:37,199
number of chess moves that we might find

350
00:12:35,340 --> 00:12:38,490
<font color="#E5E5E5">but in the common case so much smaller</font>

351
00:12:37,200 --> 00:12:40,230
number is<font color="#CCCCCC"> actually found there's a lot</font>

352
00:12:38,490 --> 00:12:41,340
of pruning<font color="#E5E5E5"> and so most</font><font color="#CCCCCC"> of the memory</font>

353
00:12:40,230 --> 00:12:44,340
goes unused

354
00:12:41,340 --> 00:12:45,660
but our policies still have to tag<font color="#E5E5E5"> these</font>

355
00:12:44,340 --> 00:12:48,600
large frames<font color="#E5E5E5"> in the</font><font color="#CCCCCC"> Prolog and then</font>

356
00:12:45,660 --> 00:12:49,890
clear them<font color="#E5E5E5"> on again in the epilogues we</font>

357
00:12:48,600 --> 00:12:51,300
find that most<font color="#E5E5E5"> other benchmarks with</font>

358
00:12:49,890 --> 00:12:53,130
high overheads had a similar<font color="#E5E5E5"> root cause</font>

359
00:12:51,300 --> 00:12:55,380
that<font color="#CCCCCC"> is they're allocating more stack</font>

360
00:12:53,130 --> 00:12:57,120
memory<font color="#E5E5E5"> than they actually need we</font>

361
00:12:55,380 --> 00:12:58,680
attribute this to the fact that

362
00:12:57,120 --> 00:13:00,540
programmers<font color="#E5E5E5"> know that on most</font><font color="#CCCCCC"> systems</font>

363
00:12:58,680 --> 00:13:02,099
the stack memory<font color="#CCCCCC"> is cheap of 1 to</font>

364
00:13:00,540 --> 00:13:04,770
allocate<font color="#CCCCCC"> and the way the programmers</font>

365
00:13:02,100 --> 00:13:08,040
program is they<font color="#E5E5E5"> take advantage of this</font>

366
00:13:04,770 --> 00:13:09,360
fact however<font color="#E5E5E5"> we're making allocations</font>

367
00:13:08,040 --> 00:13:11,040
cost<font color="#E5E5E5"> o of n we're asymptotically</font>

368
00:13:09,360 --> 00:13:12,870
changing the speed of stack allocations

369
00:13:11,040 --> 00:13:16,110
and so this can cause some performance

370
00:13:12,870 --> 00:13:18,060
problems so a natural<font color="#E5E5E5"> question is do we</font>

371
00:13:16,110 --> 00:13:19,710
<font color="#E5E5E5">really</font><font color="#CCCCCC"> need</font><font color="#E5E5E5"> to proactively tag our whole</font>

372
00:13:18,060 --> 00:13:21,939
stack frames in the<font color="#CCCCCC"> Prolog</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> then</font>

373
00:13:19,710 --> 00:13:24,740
clear them<font color="#E5E5E5"> out later in the</font><font color="#CCCCCC"> epilogue</font>

374
00:13:21,940 --> 00:13:26,630
instead<font color="#E5E5E5"> what if we're lazy we look at</font>

375
00:13:24,740 --> 00:13:28,520
two different<font color="#CCCCCC"> kinds</font><font color="#E5E5E5"> of laziness</font><font color="#CCCCCC"> one of</font>

376
00:13:26,630 --> 00:13:30,350
them<font color="#E5E5E5"> would call lazy tagging with lazy</font>

377
00:13:28,520 --> 00:13:32,660
tagging we don't tag memory<font color="#E5E5E5"> in the</font>

378
00:13:30,350 --> 00:13:34,520
prologue<font color="#E5E5E5"> and instead we allow the first</font>

379
00:13:32,660 --> 00:13:36,439
writer<font color="#CCCCCC"> to</font><font color="#E5E5E5"> claim any any memory words</font>

380
00:13:34,520 --> 00:13:38,180
<font color="#CCCCCC">tagged empty stack and they'll update</font>

381
00:13:36,440 --> 00:13:40,160
<font color="#E5E5E5">the word with the tag of the writer at</font>

382
00:13:38,180 --> 00:13:41,900
the<font color="#E5E5E5"> time at the right occurs in other</font>

383
00:13:40,160 --> 00:13:43,670
words were combining<font color="#E5E5E5"> the initial tagging</font>

384
00:13:41,900 --> 00:13:45,410
<font color="#E5E5E5">with the first program right to that</font>

385
00:13:43,670 --> 00:13:46,969
memory word<font color="#E5E5E5"> so we don't bother tagging</font>

386
00:13:45,410 --> 00:13:50,240
something if we're not actually<font color="#E5E5E5"> going to</font>

387
00:13:46,970 --> 00:13:51,800
<font color="#CCCCCC">use it with this optimization</font><font color="#E5E5E5"> we still</font>

388
00:13:50,240 --> 00:13:53,150
<font color="#E5E5E5">keep the whole cleanup loop and the</font>

389
00:13:51,800 --> 00:13:55,069
epilogue is to maintain the invariant to

390
00:13:53,150 --> 00:13:57,620
<font color="#E5E5E5">the unused memory remains tagged empty</font>

391
00:13:55,070 --> 00:13:58,880
stack and this allows us<font color="#E5E5E5"> to move out</font>

392
00:13:57,620 --> 00:14:00,350
<font color="#CCCCCC">half the overhead most of the other head</font>

393
00:13:58,880 --> 00:14:01,520
came from the<font color="#CCCCCC"> tacking and clearing and</font>

394
00:14:00,350 --> 00:14:04,400
we<font color="#E5E5E5"> can get rid of out half of it with</font>

395
00:14:01,520 --> 00:14:06,020
<font color="#E5E5E5">this optimization</font><font color="#CCCCCC"> it turns out that we</font>

396
00:14:04,400 --> 00:14:08,630
can take laziness one step further and

397
00:14:06,020 --> 00:14:11,060
<font color="#E5E5E5">we also look at lazy clearing with lazy</font>

398
00:14:08,630 --> 00:14:14,210
<font color="#CCCCCC">clearing we also don't tag memory</font><font color="#E5E5E5"> we</font>

399
00:14:11,060 --> 00:14:15,650
don't clear memory and the epilogues<font color="#E5E5E5"> now</font>

400
00:14:14,210 --> 00:14:17,030
<font color="#E5E5E5">but the rules we've seen so</font><font color="#CCCCCC"> far</font><font color="#E5E5E5"> this</font>

401
00:14:15,650 --> 00:14:18,829
would cause<font color="#CCCCCC"> problems</font><font color="#E5E5E5"> this means the</font>

402
00:14:17,030 --> 00:14:21,110
function returns<font color="#E5E5E5"> it leaves</font><font color="#CCCCCC"> its tagged</font>

403
00:14:18,830 --> 00:14:22,520
<font color="#E5E5E5">frame still on the stack and</font><font color="#CCCCCC"> the next</font>

404
00:14:21,110 --> 00:14:24,080
<font color="#E5E5E5">function which goes to run will use the</font>

405
00:14:22,520 --> 00:14:26,660
same memory and it'll try<font color="#CCCCCC"> to write to</font>

406
00:14:24,080 --> 00:14:28,850
that<font color="#CCCCCC"> memory but now</font><font color="#E5E5E5"> that's the tag of</font>

407
00:14:26,660 --> 00:14:30,350
the last<font color="#CCCCCC"> function is still</font><font color="#E5E5E5"> there and so</font>

408
00:14:28,850 --> 00:14:33,350
with<font color="#E5E5E5"> this optimization</font><font color="#CCCCCC"> we allow all</font>

409
00:14:30,350 --> 00:14:35,180
rights to succeed and if we only check

410
00:14:33,350 --> 00:14:38,030
on reads that<font color="#E5E5E5"> the tag</font><font color="#CCCCCC"> that we read is</font>

411
00:14:35,180 --> 00:14:40,400
the tag<font color="#CCCCCC"> that we</font><font color="#E5E5E5"> expect it to read so if</font>

412
00:14:38,030 --> 00:14:42,470
all<font color="#CCCCCC"> writes can succeed</font><font color="#E5E5E5"> what happens when</font>

413
00:14:40,400 --> 00:14:44,630
a buffer<font color="#E5E5E5"> overflows the return address</font>

414
00:14:42,470 --> 00:14:45,980
well the<font color="#CCCCCC"> writes allowed to succeed</font><font color="#E5E5E5"> but</font>

415
00:14:44,630 --> 00:14:48,230
<font color="#E5E5E5">the return address which used to have</font><font color="#CCCCCC"> a</font>

416
00:14:45,980 --> 00:14:49,460
tag like blue return address<font color="#E5E5E5"> takes on</font>

417
00:14:48,230 --> 00:14:51,320
the tag of<font color="#E5E5E5"> the writer which is something</font>

418
00:14:49,460 --> 00:14:53,030
<font color="#CCCCCC">like green buff and then later when we</font>

419
00:14:51,320 --> 00:14:54,590
go to load the return address we<font color="#E5E5E5"> can</font>

420
00:14:53,030 --> 00:14:57,020
tell that<font color="#E5E5E5"> the</font><font color="#CCCCCC"> tack</font><font color="#E5E5E5"> is changed and</font>

421
00:14:54,590 --> 00:14:58,580
something has gone wrong<font color="#CCCCCC"> now there</font><font color="#E5E5E5"> is</font>

422
00:14:57,020 --> 00:15:00,350
with this<font color="#E5E5E5"> optimization we're only</font>

423
00:14:58,580 --> 00:15:02,210
enforcing a<font color="#CCCCCC"> dataflow</font><font color="#E5E5E5"> integrity property</font>

424
00:15:00,350 --> 00:15:03,590
<font color="#E5E5E5">when we go to read something we can tell</font>

425
00:15:02,210 --> 00:15:06,350
if<font color="#E5E5E5"> those bits didn't come from the place</font>

426
00:15:03,590 --> 00:15:07,610
<font color="#CCCCCC">that they were supposed to okay</font><font color="#E5E5E5"> how much</font>

427
00:15:06,350 --> 00:15:10,190
benefit do we<font color="#E5E5E5"> get from this laziness</font>

428
00:15:07,610 --> 00:15:11,540
<font color="#CCCCCC">I've</font><font color="#E5E5E5"> shown in the</font><font color="#CCCCCC"> baseline in green the</font>

429
00:15:10,190 --> 00:15:13,040
performance with just lazy tagging in

430
00:15:11,540 --> 00:15:14,870
blue<font color="#E5E5E5"> and the combined effects of lazy</font>

431
00:15:13,040 --> 00:15:17,420
tagging and lazy clearing and yellow

432
00:15:14,870 --> 00:15:19,810
together<font color="#CCCCCC"> these bring the overheads from</font>

433
00:15:17,420 --> 00:15:21,829
about<font color="#E5E5E5"> twelve</font><font color="#CCCCCC"> percent down 23.6%</font>

434
00:15:19,810 --> 00:15:23,329
there's one more<font color="#E5E5E5"> optimization we look at</font>

435
00:15:21,830 --> 00:15:25,310
in<font color="#CCCCCC"> the paper where we consider adding a</font>

436
00:15:23,330 --> 00:15:26,960
new instruction<font color="#E5E5E5"> to the architecture it</font>

437
00:15:25,310 --> 00:15:28,520
allows it to tag or clear<font color="#CCCCCC"> a whole cache</font>

438
00:15:26,960 --> 00:15:28,910
line at a time<font color="#CCCCCC"> instead of just one</font><font color="#E5E5E5"> word</font>

439
00:15:28,520 --> 00:15:30,470
at a time

440
00:15:28,910 --> 00:15:31,490
this doesn't asymptotically change

441
00:15:30,470 --> 00:15:32,360
<font color="#CCCCCC">anything that it gives you about a</font>

442
00:15:31,490 --> 00:15:34,580
constant of 8x

443
00:15:32,360 --> 00:15:34,970
speed-up<font color="#E5E5E5"> this is an alternative</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> the</font>

444
00:15:34,580 --> 00:15:36,710
lazy

445
00:15:34,970 --> 00:15:38,480
- the<font color="#E5E5E5"> lazy policies or it can be</font>

446
00:15:36,710 --> 00:15:40,030
combined with lazy tagging and those

447
00:15:38,480 --> 00:15:42,620
details<font color="#CCCCCC"> and results are</font><font color="#E5E5E5"> in the paper</font>

448
00:15:40,030 --> 00:15:43,939
<font color="#E5E5E5">okay to summarize current stack</font>

449
00:15:42,620 --> 00:15:45,800
protection mechanisms are either too

450
00:15:43,940 --> 00:15:47,990
weak such as Canaries<font color="#E5E5E5"> or too expensive</font>

451
00:15:45,800 --> 00:15:49,400
full software memory safety<font color="#CCCCCC"> and so</font>

452
00:15:47,990 --> 00:15:50,780
people<font color="#E5E5E5"> have</font><font color="#CCCCCC"> looked hardware solutions</font><font color="#E5E5E5"> in</font>

453
00:15:49,400 --> 00:15:52,790
this<font color="#E5E5E5"> work we create stack protection</font>

454
00:15:50,780 --> 00:15:54,500
policies for<font color="#CCCCCC"> this</font><font color="#E5E5E5"> general purpose tagged</font>

455
00:15:52,790 --> 00:15:57,439
architecture and we find<font color="#E5E5E5"> that we can</font>

456
00:15:54,500 --> 00:15:58,940
enforce object level<font color="#CCCCCC"> protection we find</font>

457
00:15:57,440 --> 00:16:00,680
that lazy<font color="#E5E5E5"> versions of the policies can</font>

458
00:15:58,940 --> 00:16:02,420
reduce<font color="#CCCCCC"> the overheads down to</font><font color="#E5E5E5"> a down</font>

459
00:16:00,680 --> 00:16:03,829
twenty three or<font color="#CCCCCC"> four</font><font color="#E5E5E5"> percent so tagged</font>

460
00:16:02,420 --> 00:16:06,740
architectures are<font color="#CCCCCC"> a good match for</font><font color="#E5E5E5"> these</font>

461
00:16:03,830 --> 00:16:08,330
<font color="#E5E5E5">data flow integrity style policies and</font>

462
00:16:06,740 --> 00:16:09,890
<font color="#E5E5E5">this talk I only looked at one policy</font>

463
00:16:08,330 --> 00:16:11,690
which we call<font color="#E5E5E5"> static authorities in the</font>

464
00:16:09,890 --> 00:16:13,069
paper but there's some<font color="#E5E5E5"> other policies in</font>

465
00:16:11,690 --> 00:16:16,750
the paper also<font color="#E5E5E5"> so you can check those</font>

466
00:16:13,070 --> 00:16:16,750
out<font color="#E5E5E5"> and thank</font><font color="#CCCCCC"> you</font><font color="#E5E5E5"> for listening</font>

467
00:16:21,250 --> 00:16:25,000
<font color="#CCCCCC">alright questions</font>

468
00:16:36,740 --> 00:16:44,970
<font color="#CCCCCC">a nice piece of work</font><font color="#E5E5E5"> certainly and a lot</font>

469
00:16:40,439 --> 00:16:50,129
<font color="#E5E5E5">of detail</font><font color="#CCCCCC"> so my question though is to</font>

470
00:16:44,970 --> 00:16:55,439
ask you as now an<font color="#E5E5E5"> expert in this this</font>

471
00:16:50,129 --> 00:17:01,589
aspect of software security<font color="#E5E5E5"> why is this</font>

472
00:16:55,439 --> 00:17:04,199
problem<font color="#E5E5E5"> so hard it is I believe 30 years</font>

473
00:17:01,589 --> 00:17:06,600
since<font color="#E5E5E5"> I woke up one morning and found</font>

474
00:17:04,199 --> 00:17:09,150
that the entire internet which was<font color="#CCCCCC"> fewer</font>

475
00:17:06,599 --> 00:17:12,539
than<font color="#CCCCCC"> 10,000 machines at the</font><font color="#E5E5E5"> time had</font>

476
00:17:09,150 --> 00:17:14,250
<font color="#CCCCCC">been taken</font><font color="#E5E5E5"> down in part by stack</font>

477
00:17:12,539 --> 00:17:16,890
smashing

478
00:17:14,250 --> 00:17:19,169
I don't think a year has gone<font color="#CCCCCC"> by that</font><font color="#E5E5E5"> I</font>

479
00:17:16,890 --> 00:17:23,579
have not heard<font color="#E5E5E5"> of a new solution to this</font>

480
00:17:19,169 --> 00:17:26,280
<font color="#CCCCCC">problem all that time</font><font color="#E5E5E5"> 20 years</font><font color="#CCCCCC"> after</font>

481
00:17:23,579 --> 00:17:29,928
<font color="#CCCCCC">that happened I wrote a rest perspective</font>

482
00:17:26,280 --> 00:17:33,480
about<font color="#E5E5E5"> it and I looked at cert and buffer</font>

483
00:17:29,929 --> 00:17:36,929
and buffer overflows<font color="#CCCCCC"> were</font><font color="#E5E5E5"> the main thing</font>

484
00:17:33,480 --> 00:17:40,770
not stack<font color="#CCCCCC"> but still it's</font><font color="#E5E5E5"> the general</font>

485
00:17:36,929 --> 00:17:41,940
principle<font color="#E5E5E5"> why is this problem</font><font color="#CCCCCC"> so very</font>

486
00:17:40,770 --> 00:17:44,070
<font color="#E5E5E5">very hard</font>

487
00:17:41,940 --> 00:17:47,010
now that you've looked at it<font color="#E5E5E5"> why do we</font>

488
00:17:44,070 --> 00:17:49,260
have to keep solving<font color="#E5E5E5"> it can you tell us</font>

489
00:17:47,010 --> 00:17:54,658
who<font color="#CCCCCC"> you are and in general</font><font color="#E5E5E5"> please tell</font>

490
00:17:49,260 --> 00:17:55,679
us<font color="#E5E5E5"> your names I'm</font><font color="#CCCCCC"> Hillary I yeah</font><font color="#E5E5E5"> I don't</font>

491
00:17:54,659 --> 00:17:57,450
<font color="#E5E5E5">think</font><font color="#CCCCCC"> everything</font><font color="#E5E5E5"> particularly insightful</font>

492
00:17:55,679 --> 00:17:59,370
<font color="#CCCCCC">so there's we have a ton of legacy</font>

493
00:17:57,450 --> 00:18:01,140
software<font color="#CCCCCC"> that's written</font><font color="#E5E5E5"> in these memory</font>

494
00:17:59,370 --> 00:18:03,389
unsafe languages and so<font color="#CCCCCC"> we're there's a</font>

495
00:18:01,140 --> 00:18:05,669
huge<font color="#E5E5E5"> amount of software out</font><font color="#CCCCCC"> there I</font>

496
00:18:03,390 --> 00:18:07,110
guess in<font color="#CCCCCC"> general there's checking every</font>

497
00:18:05,669 --> 00:18:08,820
memory<font color="#CCCCCC"> access and</font><font color="#E5E5E5"> software as a little</font>

498
00:18:07,110 --> 00:18:10,770
overhead<font color="#E5E5E5"> and so solutions that are only</font>

499
00:18:08,820 --> 00:18:13,620
software<font color="#CCCCCC"> base</font><font color="#E5E5E5"> software based are gonna</font>

500
00:18:10,770 --> 00:18:15,600
be too expensive<font color="#CCCCCC"> to be used and there's</font>

501
00:18:13,620 --> 00:18:18,178
<font color="#CCCCCC">yes and so there's a number</font><font color="#E5E5E5"> of</font><font color="#CCCCCC"> different</font>

502
00:18:15,600 --> 00:18:19,590
<font color="#CCCCCC">hardware</font><font color="#E5E5E5"> ways to</font><font color="#CCCCCC"> accelerate this which</font>

503
00:18:18,179 --> 00:18:20,990
<font color="#CCCCCC">is like hardware support for bounds</font>

504
00:18:19,590 --> 00:18:22,649
checking and that's one possibility

505
00:18:20,990 --> 00:18:23,850
architecture can express a lot<font color="#E5E5E5"> of</font>

506
00:18:22,650 --> 00:18:25,980
different kinds of policies<font color="#CCCCCC"> and so we're</font>

507
00:18:23,850 --> 00:18:27,480
<font color="#E5E5E5">kind of heading in that direction but</font>

508
00:18:25,980 --> 00:18:30,450
yeah I don't<font color="#CCCCCC"> think I have any magic</font>

509
00:18:27,480 --> 00:18:32,750
answer<font color="#CCCCCC"> swing but please find a magic</font>

510
00:18:30,450 --> 00:18:32,750
answer

511
00:18:40,080 --> 00:18:46,120
<font color="#E5E5E5">I'm</font><font color="#CCCCCC"> dead</font><font color="#E5E5E5"> from Google</font><font color="#CCCCCC"> how do you handle</font>

512
00:18:43,300 --> 00:18:47,950
tagging of recursive functions because

513
00:18:46,120 --> 00:18:49,719
especially<font color="#E5E5E5"> with that lazy</font><font color="#CCCCCC"> write it seems</font>

514
00:18:47,950 --> 00:18:52,150
like the function should<font color="#CCCCCC"> be</font><font color="#E5E5E5"> able to</font>

515
00:18:49,720 --> 00:18:55,270
overwrite the<font color="#CCCCCC"> return address and</font><font color="#E5E5E5"> still</font>

516
00:18:52,150 --> 00:18:56,200
be<font color="#CCCCCC"> counted as okay so in this</font><font color="#E5E5E5"> policy</font>

517
00:18:55,270 --> 00:18:57,550
<font color="#E5E5E5">there's like all right there's one</font>

518
00:18:56,200 --> 00:18:58,510
<font color="#E5E5E5">function there's one color for each</font>

519
00:18:57,550 --> 00:18:59,770
function<font color="#E5E5E5"> and so if there's multiple</font>

520
00:18:58,510 --> 00:19:00,160
instances of the<font color="#CCCCCC"> same function</font><font color="#E5E5E5"> of the</font>

521
00:18:59,770 --> 00:19:01,990
<font color="#E5E5E5">stack</font>

522
00:19:00,160 --> 00:19:03,520
<font color="#CCCCCC">they all the same color</font><font color="#E5E5E5"> and so then you</font>

523
00:19:01,990 --> 00:19:04,690
<font color="#CCCCCC">can</font><font color="#E5E5E5"> write if you have a pointer to</font><font color="#CCCCCC"> a</font>

524
00:19:03,520 --> 00:19:05,770
green<font color="#E5E5E5"> buffer you can write to any of you</font>

525
00:19:04,690 --> 00:19:06,850
buff<font color="#E5E5E5"> and if there's multiple green</font>

526
00:19:05,770 --> 00:19:08,650
<font color="#CCCCCC">Bluffs my stack you can</font><font color="#E5E5E5"> write in it as</font>

527
00:19:06,850 --> 00:19:10,240
there are<font color="#E5E5E5"> other</font><font color="#CCCCCC"> policies we look at in</font>

528
00:19:08,650 --> 00:19:12,820
<font color="#E5E5E5">the paper where</font><font color="#CCCCCC"> we do more isolation by</font>

529
00:19:10,240 --> 00:19:14,260
instances and so<font color="#CCCCCC"> basically we're</font><font color="#E5E5E5"> we're</font>

530
00:19:12,820 --> 00:19:15,669
<font color="#CCCCCC">trying to</font><font color="#E5E5E5"> take</font><font color="#CCCCCC"> advantage of</font><font color="#E5E5E5"> a of the</font>

531
00:19:14,260 --> 00:19:17,620
cache and<font color="#CCCCCC"> so</font><font color="#E5E5E5"> we're trying to reuse our</font>

532
00:19:15,670 --> 00:19:19,240
rules and so we're looking<font color="#CCCCCC"> at trading</font>

533
00:19:17,620 --> 00:19:20,229
<font color="#E5E5E5">off between security</font><font color="#CCCCCC"> and performance</font><font color="#E5E5E5"> and</font>

534
00:19:19,240 --> 00:19:21,790
there's a few<font color="#E5E5E5"> ways you can</font><font color="#CCCCCC"> do that</font>

535
00:19:20,230 --> 00:19:24,010
<font color="#E5E5E5">there's another policy where we we use</font>

536
00:19:21,790 --> 00:19:25,870
depth<font color="#E5E5E5"> instead</font><font color="#CCCCCC"> on this this</font><font color="#E5E5E5"> this would</font>

537
00:19:24,010 --> 00:19:26,650
give you protection against recursion so

538
00:19:25,870 --> 00:19:30,040
there's some<font color="#E5E5E5"> of the things you can do</font>

539
00:19:26,650 --> 00:19:32,860
that<font color="#E5E5E5"> that but cool thank you hi this is</font>

540
00:19:30,040 --> 00:19:34,840
Salman from internal<font color="#E5E5E5"> apps so I'm sorry I</font>

541
00:19:32,860 --> 00:19:37,750
haven't<font color="#E5E5E5"> read your paper but if you are</font>

542
00:19:34,840 --> 00:19:39,790
thinking of hardware support for tagging

543
00:19:37,750 --> 00:19:43,090
full cache line so how do you envision

544
00:19:39,790 --> 00:19:45,159
to like protect local<font color="#E5E5E5"> variables first</font>

545
00:19:43,090 --> 00:19:48,490
<font color="#E5E5E5">fewer pipes like one</font><font color="#CCCCCC"> bars</font><font color="#E5E5E5"> two parts</font><font color="#CCCCCC"> this</font>

546
00:19:45,160 --> 00:19:50,290
kind of<font color="#CCCCCC"> thing</font><font color="#E5E5E5"> so I won one option is</font>

547
00:19:48,490 --> 00:19:51,580
padding and so that allows you<font color="#E5E5E5"> to place</font>

548
00:19:50,290 --> 00:19:54,940
<font color="#E5E5E5">a tagging</font><font color="#CCCCCC"> Hulbert it only have one thing</font>

549
00:19:51,580 --> 00:19:56,919
<font color="#E5E5E5">in</font><font color="#CCCCCC"> that word you can also have rules and</font>

550
00:19:54,940 --> 00:19:59,770
your rules can take like a byte input so

551
00:19:56,920 --> 00:20:01,270
you can<font color="#E5E5E5"> see which which thing you're</font>

552
00:19:59,770 --> 00:20:03,070
accessing and so out of sub<font color="#E5E5E5"> route agz</font>

553
00:20:01,270 --> 00:20:03,580
kind of like<font color="#E5E5E5"> eight byte words but</font><font color="#CCCCCC"> for by</font>

554
00:20:03,070 --> 00:20:04,810
tags

555
00:20:03,580 --> 00:20:06,280
you could have whether you acting the

556
00:20:04,810 --> 00:20:07,899
first or<font color="#E5E5E5"> the second word as another</font>

557
00:20:06,280 --> 00:20:10,540
<font color="#E5E5E5">input into your</font><font color="#CCCCCC"> old</font><font color="#E5E5E5"> cache and so that</font>

558
00:20:07,900 --> 00:20:13,090
<font color="#CCCCCC">can allow you to</font><font color="#E5E5E5"> to support that and</font>

559
00:20:10,540 --> 00:20:17,020
then the software that<font color="#E5E5E5"> runs can can</font>

560
00:20:13,090 --> 00:20:18,580
check to<font color="#CCCCCC"> see</font><font color="#E5E5E5"> yeah yeah I can see there</font>

561
00:20:17,020 --> 00:20:22,000
<font color="#E5E5E5">will be like much</font><font color="#CCCCCC"> overhead but we can</font>

562
00:20:18,580 --> 00:20:25,290
talk<font color="#E5E5E5"> offline okay thanks</font><font color="#CCCCCC"> all</font><font color="#E5E5E5"> right we're</font>

563
00:20:22,000 --> 00:20:25,290
<font color="#CCCCCC">out of time let's think of again</font>

