1
00:00:07,720 --> 00:00:12,940
hello everyone

2
00:00:10,720 --> 00:00:15,400
<font color="#CCCCCC">snark</font><font color="#E5E5E5"> framework for efficient verifiable</font>

3
00:00:12,940 --> 00:00:18,790
computation<font color="#E5E5E5"> this is joint work with my</font>

4
00:00:15,400 --> 00:00:19,900
<font color="#CCCCCC">advisors</font><font color="#E5E5E5"> Bobby's and</font><font color="#CCCCCC"> Elaine so we have</font>

5
00:00:18,790 --> 00:00:21,310
the<font color="#E5E5E5"> same setting of verifiable</font>

6
00:00:19,900 --> 00:00:23,470
<font color="#CCCCCC">computation</font><font color="#E5E5E5"> and the stock were</font><font color="#CCCCCC"> and</font>

7
00:00:21,310 --> 00:00:25,470
untrusted where a client<font color="#CCCCCC"> outsources the</font>

8
00:00:23,470 --> 00:00:27,880
computation to some untrusted party and

9
00:00:25,470 --> 00:00:30,790
this untrusted party is<font color="#E5E5E5"> supposed to</font>

10
00:00:27,880 --> 00:00:32,560
<font color="#E5E5E5">evaluate or run the computation along</font>

11
00:00:30,790 --> 00:00:35,140
with some secret<font color="#E5E5E5"> input</font><font color="#CCCCCC"> returning the</font>

12
00:00:32,560 --> 00:00:37,450
results back along<font color="#E5E5E5"> with the proof to the</font>

13
00:00:35,140 --> 00:00:38,680
verifier<font color="#E5E5E5"> and thankfully during the past</font>

14
00:00:37,450 --> 00:00:40,720
decade<font color="#E5E5E5"> there have been orders of</font>

15
00:00:38,680 --> 00:00:43,810
magnitude and different and all aspects

16
00:00:40,720 --> 00:00:45,280
of performance<font color="#CCCCCC"> and we have now efficient</font>

17
00:00:43,810 --> 00:00:49,360
constructions<font color="#E5E5E5"> and implementations for</font>

18
00:00:45,280 --> 00:00:50,890
what's called<font color="#E5E5E5"> Zika</font><font color="#CCCCCC"> snort which also like</font>

19
00:00:49,360 --> 00:00:52,960
which enabled us<font color="#E5E5E5"> to get</font><font color="#CCCCCC"> very short</font>

20
00:00:50,890 --> 00:00:55,870
proofs and minimal verification times

21
00:00:52,960 --> 00:00:57,820
under certain<font color="#E5E5E5"> assumptions and this</font>

22
00:00:55,870 --> 00:00:59,849
enabled a<font color="#CCCCCC"> lot of</font><font color="#E5E5E5"> practical applications</font>

23
00:00:57,820 --> 00:01:03,360
are spending different areas including

24
00:00:59,850 --> 00:01:07,630
<font color="#CCCCCC">cryptocurrency</font><font color="#E5E5E5"> certificate verification</font>

25
00:01:03,360 --> 00:01:10,360
and<font color="#CCCCCC"> address algorithms and also image</font>

26
00:01:07,630 --> 00:01:12,399
authentication and in this talk we're

27
00:01:10,360 --> 00:01:14,800
<font color="#E5E5E5">going to focus on one part of this is</font>

28
00:01:12,400 --> 00:01:16,330
the<font color="#E5E5E5"> acuity based pre-processing Zika</font>

29
00:01:14,800 --> 00:01:18,039
<font color="#E5E5E5">starts which is</font><font color="#CCCCCC"> the one that was used</font>

30
00:01:16,330 --> 00:01:21,940
<font color="#CCCCCC">for many</font><font color="#E5E5E5"> of the practical applications</font>

31
00:01:18,040 --> 00:01:24,760
<font color="#CCCCCC">basically</font><font color="#E5E5E5"> how like basically we're going</font>

32
00:01:21,940 --> 00:01:27,220
<font color="#E5E5E5">to focus on its front end basically how</font>

33
00:01:24,760 --> 00:01:30,250
we can use such construction<font color="#E5E5E5"> so</font>

34
00:01:27,220 --> 00:01:32,140
typically the computation to be verified

35
00:01:30,250 --> 00:01:34,210
is being expressed<font color="#E5E5E5"> in</font><font color="#CCCCCC"> high-level</font><font color="#E5E5E5"> program</font>

36
00:01:32,140 --> 00:01:36,250
and then<font color="#E5E5E5"> it gets compiled to some kind</font>

37
00:01:34,210 --> 00:01:37,990
of<font color="#E5E5E5"> analytic circuit or a set of</font>

38
00:01:36,250 --> 00:01:40,930
quadratic<font color="#CCCCCC"> constrains</font><font color="#E5E5E5"> over a finite field</font>

39
00:01:37,990 --> 00:01:43,929
and this step<font color="#E5E5E5"> has to be done carefully</font>

40
00:01:40,930 --> 00:01:45,760
because the the approvers time depends

41
00:01:43,930 --> 00:01:47,500
and in a quasi<font color="#E5E5E5"> linear manner on the</font>

42
00:01:45,760 --> 00:01:49,900
<font color="#E5E5E5">number of constraints or multiplication</font>

43
00:01:47,500 --> 00:01:52,090
gates in<font color="#CCCCCC"> the circuit</font><font color="#E5E5E5"> and what makes this</font>

44
00:01:49,900 --> 00:01:54,580
problem<font color="#CCCCCC"> interesting is that this has a</font>

45
00:01:52,090 --> 00:01:56,500
different<font color="#CCCCCC"> cost model than what we are</font>

46
00:01:54,580 --> 00:01:58,060
used to in typical programs so for

47
00:01:56,500 --> 00:02:01,840
example bitwise operations are<font color="#CCCCCC"> very</font>

48
00:01:58,060 --> 00:02:04,420
expensive<font color="#E5E5E5"> and in comparison like</font>

49
00:02:01,840 --> 00:02:06,460
<font color="#E5E5E5">multiplication of circuit unknowns is</font>

50
00:02:04,420 --> 00:02:09,299
much more expensive<font color="#E5E5E5"> compared to</font>

51
00:02:06,460 --> 00:02:12,640
multiplication<font color="#E5E5E5"> by constants for example</font>

52
00:02:09,299 --> 00:02:14,769
and currently there<font color="#CCCCCC"> are two ways where</font>

53
00:02:12,640 --> 00:02:17,409
we can<font color="#E5E5E5"> express computations a</font><font color="#CCCCCC"> circuit</font>

54
00:02:14,769 --> 00:02:20,110
<font color="#E5E5E5">one way is high level compilers which</font>

55
00:02:17,409 --> 00:02:21,739
can be categorized<font color="#CCCCCC"> into</font><font color="#E5E5E5"> classes one</font>

56
00:02:20,110 --> 00:02:26,330
<font color="#E5E5E5">class is the program</font>

57
00:02:21,740 --> 00:02:28,400
<font color="#CCCCCC">static compilers</font><font color="#E5E5E5"> in this program</font>

58
00:02:26,330 --> 00:02:29,990
specific compilers<font color="#E5E5E5"> the like there is a</font>

59
00:02:28,400 --> 00:02:32,180
different circuit generated by<font color="#E5E5E5"> every</font>

60
00:02:29,990 --> 00:02:34,010
program and there have<font color="#CCCCCC"> been a lot of</font>

61
00:02:32,180 --> 00:02:36,110
interesting<font color="#CCCCCC"> works in this</font><font color="#E5E5E5"> area like</font>

62
00:02:34,010 --> 00:02:38,269
<font color="#E5E5E5">every compiler was providing different</font>

63
00:02:36,110 --> 00:02:39,890
optimizations<font color="#E5E5E5"> there's also the concept</font>

64
00:02:38,270 --> 00:02:42,080
<font color="#CCCCCC">of the universal circuit generators</font>

65
00:02:39,890 --> 00:02:43,130
<font color="#E5E5E5">which is provides very interesting</font>

66
00:02:42,080 --> 00:02:46,280
properties in terms of<font color="#E5E5E5"> the</font>

67
00:02:43,130 --> 00:02:48,890
expressiveness<font color="#CCCCCC"> and the capabilities of</font>

68
00:02:46,280 --> 00:02:50,750
runtime<font color="#CCCCCC"> cogeneration but it has less</font>

69
00:02:48,890 --> 00:02:54,410
efficiency compared<font color="#CCCCCC"> to the program</font>

70
00:02:50,750 --> 00:02:55,820
<font color="#CCCCCC">specific compilers</font><font color="#E5E5E5"> the other one is the</font>

71
00:02:54,410 --> 00:02:57,829
<font color="#E5E5E5">low-level libraries or the manual</font>

72
00:02:55,820 --> 00:02:59,840
libraries which the programmer<font color="#E5E5E5"> has to</font>

73
00:02:57,830 --> 00:03:02,030
<font color="#E5E5E5">construct the gadgets manually and write</font>

74
00:02:59,840 --> 00:03:04,280
the constraints manually and<font color="#CCCCCC"> these</font>

75
00:03:02,030 --> 00:03:06,620
low-level libraries are preferred in

76
00:03:04,280 --> 00:03:09,860
when we write<font color="#E5E5E5"> performance critical</font>

77
00:03:06,620 --> 00:03:11,840
<font color="#CCCCCC">applications</font><font color="#E5E5E5"> and basically to choose</font>

78
00:03:09,860 --> 00:03:13,670
between both of<font color="#CCCCCC"> these kinds it's</font>

79
00:03:11,840 --> 00:03:16,190
basically trade-off between the group

80
00:03:13,670 --> 00:03:17,359
programmers<font color="#E5E5E5"> effort</font><font color="#CCCCCC"> and performance for</font>

81
00:03:16,190 --> 00:03:18,710
<font color="#E5E5E5">many of the performance</font><font color="#CCCCCC"> critical</font>

82
00:03:17,360 --> 00:03:24,170
applications the low-level libraries

83
00:03:18,710 --> 00:03:26,870
were actually used<font color="#CCCCCC"> ok so the goals of</font>

84
00:03:24,170 --> 00:03:28,880
<font color="#CCCCCC">the xes nark is that can we minimize</font><font color="#E5E5E5"> the</font>

85
00:03:26,870 --> 00:03:30,380
programmers effort and<font color="#CCCCCC"> at the same</font><font color="#E5E5E5"> time</font>

86
00:03:28,880 --> 00:03:32,210
<font color="#E5E5E5">get get more efficient circuits</font>

87
00:03:30,380 --> 00:03:34,850
basically in the designer space we would

88
00:03:32,210 --> 00:03:37,190
<font color="#E5E5E5">like</font><font color="#CCCCCC"> to be in this shape we would like</font>

89
00:03:34,850 --> 00:03:38,450
<font color="#CCCCCC">to improve the circuit size and at the</font>

90
00:03:37,190 --> 00:03:40,250
same<font color="#E5E5E5"> time make the programming</font>

91
00:03:38,450 --> 00:03:42,679
<font color="#CCCCCC">high-level or easier for the programmer</font>

92
00:03:40,250 --> 00:03:45,710
<font color="#E5E5E5">so that we can make writing</font><font color="#CCCCCC"> applications</font>

93
00:03:42,680 --> 00:03:47,090
faster<font color="#E5E5E5"> and more easier</font><font color="#CCCCCC"> and also</font><font color="#E5E5E5"> can we</font>

94
00:03:45,710 --> 00:03:49,640
develop<font color="#E5E5E5"> more efficient circuits for</font>

95
00:03:47,090 --> 00:03:50,890
frequent operations mainly<font color="#CCCCCC"> we would like</font>

96
00:03:49,640 --> 00:03:53,390
to<font color="#CCCCCC"> focus</font><font color="#E5E5E5"> on cryptographic applications</font>

97
00:03:50,890 --> 00:03:54,559
<font color="#E5E5E5">because all the applications almost</font><font color="#CCCCCC"> all</font>

98
00:03:53,390 --> 00:03:55,820
the applications<font color="#CCCCCC"> that are shown in</font><font color="#E5E5E5"> the</font>

99
00:03:54,560 --> 00:03:58,370
<font color="#E5E5E5">first fight have a cryptographic</font>

100
00:03:55,820 --> 00:04:00,530
<font color="#E5E5E5">component in the</font><font color="#CCCCCC"> circuit</font><font color="#E5E5E5"> because what</font>

101
00:03:58,370 --> 00:04:01,940
makes<font color="#CCCCCC"> syke</font><font color="#E5E5E5"> snarks attractive for many</font>

102
00:04:00,530 --> 00:04:03,710
application<font color="#CCCCCC"> i believe is</font><font color="#E5E5E5"> the zero</font>

103
00:04:01,940 --> 00:04:06,170
knowledge aspect which means that there

104
00:04:03,710 --> 00:04:07,610
<font color="#E5E5E5">will be some zero</font><font color="#CCCCCC"> knowledge</font><font color="#E5E5E5"> or some</font>

105
00:04:06,170 --> 00:04:09,739
cryptographic gadgets in the circuit

106
00:04:07,610 --> 00:04:11,540
like<font color="#E5E5E5"> verifying hashes or signatures or</font>

107
00:04:09,740 --> 00:04:13,160
encryption so we would like to<font color="#CCCCCC"> focus</font>

108
00:04:11,540 --> 00:04:14,959
specifically on making techniques or

109
00:04:13,160 --> 00:04:17,450
development for these<font color="#CCCCCC"> applications</font>

110
00:04:14,960 --> 00:04:18,320
easier<font color="#E5E5E5"> and also we are not limited to</font>

111
00:04:17,450 --> 00:04:19,909
<font color="#CCCCCC">that we're</font><font color="#E5E5E5"> going to provide</font>

112
00:04:18,320 --> 00:04:23,270
optimizations<font color="#CCCCCC"> for random memory access</font>

113
00:04:19,910 --> 00:04:25,880
applications as we're<font color="#E5E5E5"> going</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> see here</font>

114
00:04:23,270 --> 00:04:27,409
<font color="#E5E5E5">in the figure</font><font color="#CCCCCC"> I just actually</font><font color="#E5E5E5"> in our</font>

115
00:04:25,880 --> 00:04:28,880
benchmarks<font color="#CCCCCC"> we're going to show that our</font>

116
00:04:27,410 --> 00:04:31,310
tool can get to the manual

117
00:04:28,880 --> 00:04:34,180
implementation or for example<font color="#CCCCCC"> for</font>

118
00:04:31,310 --> 00:04:36,730
sha-256<font color="#E5E5E5"> and RSA we're actually</font>

119
00:04:34,180 --> 00:04:38,620
I can achieve the efficiency of

120
00:04:36,730 --> 00:04:40,540
<font color="#CCCCCC">low-level but in</font><font color="#E5E5E5"> general we can't make a</font>

121
00:04:38,620 --> 00:04:44,440
statement<font color="#E5E5E5"> like this</font><font color="#CCCCCC"> or</font><font color="#E5E5E5"> like we can't say</font>

122
00:04:40,540 --> 00:04:45,610
that it's<font color="#CCCCCC"> always the manual level - or</font>

123
00:04:44,440 --> 00:04:49,510
like the<font color="#E5E5E5"> low-level thoughts are going</font>

124
00:04:45,610 --> 00:04:51,280
<font color="#CCCCCC">always to be better so</font><font color="#E5E5E5"> it was</font><font color="#CCCCCC"> our look</font>

125
00:04:49,510 --> 00:04:52,690
<font color="#CCCCCC">our</font><font color="#E5E5E5"> at our motivation so the previous</font>

126
00:04:51,280 --> 00:04:54,190
high<font color="#CCCCCC"> level compilers</font><font color="#E5E5E5"> provides very</font>

127
00:04:52,690 --> 00:04:56,500
useful features and optimizations

128
00:04:54,190 --> 00:05:01,090
<font color="#E5E5E5">however I believe that there are a few</font>

129
00:04:56,500 --> 00:05:03,100
<font color="#CCCCCC">things missing</font><font color="#E5E5E5"> before making these used</font>

130
00:05:01,090 --> 00:05:05,530
widely<font color="#E5E5E5"> so the first is</font><font color="#CCCCCC"> that the</font><font color="#E5E5E5"> sight of</font>

131
00:05:03,100 --> 00:05:07,150
<font color="#E5E5E5">the size of the circuit output is often</font>

132
00:05:05,530 --> 00:05:09,219
larger than the manually developed

133
00:05:07,150 --> 00:05:11,859
circuit additionally it requires

134
00:05:09,220 --> 00:05:14,020
extensive<font color="#E5E5E5"> programming background or like</font>

135
00:05:11,860 --> 00:05:17,470
knowledge<font color="#E5E5E5"> of how the underlying</font><font color="#CCCCCC"> syke</font>

136
00:05:14,020 --> 00:05:19,510
snarks circuit works<font color="#E5E5E5"> so the programmer</font>

137
00:05:17,470 --> 00:05:22,030
is<font color="#E5E5E5"> still responsible</font><font color="#CCCCCC"> for many decisions</font>

138
00:05:19,510 --> 00:05:22,690
for example choosing<font color="#E5E5E5"> which like what</font>

139
00:05:22,030 --> 00:05:23,799
<font color="#E5E5E5">system memory</font>

140
00:05:22,690 --> 00:05:25,120
what is the efficient<font color="#CCCCCC"> memory</font>

141
00:05:23,800 --> 00:05:26,830
representation<font color="#E5E5E5"> based on the memory</font>

142
00:05:25,120 --> 00:05:28,330
workload<font color="#E5E5E5"> also the programmer is</font>

143
00:05:26,830 --> 00:05:31,060
<font color="#CCCCCC">responsible for tracking bit with</font>

144
00:05:28,330 --> 00:05:33,070
avoiding overflows and also add adding

145
00:05:31,060 --> 00:05:36,310
casting statements in<font color="#CCCCCC"> non-trivial</font>

146
00:05:33,070 --> 00:05:37,690
locations and for some applications as

147
00:05:36,310 --> 00:05:39,610
we're going<font color="#E5E5E5"> to show</font><font color="#CCCCCC"> next using</font>

148
00:05:37,690 --> 00:05:41,440
<font color="#E5E5E5">high-level compilers this actually is</font>

149
00:05:39,610 --> 00:05:43,570
<font color="#E5E5E5">going to require more effort and</font>

150
00:05:41,440 --> 00:05:44,890
background as low-level<font color="#E5E5E5"> tools and this</font>

151
00:05:43,570 --> 00:05:47,050
application<font color="#CCCCCC"> that I'm going to show is</font>

152
00:05:44,890 --> 00:05:48,940
actually<font color="#E5E5E5"> a bit in two papers like one of</font>

153
00:05:47,050 --> 00:05:51,130
them is<font color="#CCCCCC"> in is totally independent so</font>

154
00:05:48,940 --> 00:05:53,320
<font color="#E5E5E5">these applications are not just side</font>

155
00:05:51,130 --> 00:05:54,460
cases<font color="#E5E5E5"> so let's see like let's say we</font>

156
00:05:53,320 --> 00:05:56,860
<font color="#E5E5E5">would like</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> do some finite field</font>

157
00:05:54,460 --> 00:05:59,049
operations and<font color="#CCCCCC"> non native fields and if</font>

158
00:05:56,860 --> 00:06:01,440
<font color="#CCCCCC">a</font><font color="#E5E5E5"> that's different from the field that</font>

159
00:05:59,050 --> 00:06:03,700
where the<font color="#E5E5E5"> seek is not</font><font color="#CCCCCC"> a circuit operate</font>

160
00:06:01,440 --> 00:06:05,800
so let's say we have<font color="#CCCCCC"> two elliptic curve</font>

161
00:06:03,700 --> 00:06:07,810
points over a different<font color="#CCCCCC"> field</font><font color="#E5E5E5"> and we</font>

162
00:06:05,800 --> 00:06:11,560
would like<font color="#CCCCCC"> to</font><font color="#E5E5E5"> apply the addition formula</font>

163
00:06:07,810 --> 00:06:14,530
of<font color="#E5E5E5"> in</font><font color="#CCCCCC"> assuming</font><font color="#E5E5E5"> all the error checks have</font>

164
00:06:11,560 --> 00:06:15,880
<font color="#E5E5E5">been have been made so in order to do</font>

165
00:06:14,530 --> 00:06:17,950
this<font color="#E5E5E5"> currently using high-level</font>

166
00:06:15,880 --> 00:06:19,210
compilers or manual level tools<font color="#E5E5E5"> the</font>

167
00:06:17,950 --> 00:06:21,520
programmer<font color="#E5E5E5"> will have to do the following</font>

168
00:06:19,210 --> 00:06:23,289
<font color="#E5E5E5">since this field is large the programmer</font>

169
00:06:21,520 --> 00:06:24,969
<font color="#E5E5E5">will have to divide every element into</font>

170
00:06:23,290 --> 00:06:27,100
multiple chunks<font color="#CCCCCC"> it's choosing</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> bed</font>

171
00:06:24,970 --> 00:06:28,450
weights of every<font color="#E5E5E5"> chunk here is like as</font>

172
00:06:27,100 --> 00:06:30,720
we show<font color="#CCCCCC"> in the paper is</font><font color="#E5E5E5"> non-trivial</font>

173
00:06:28,450 --> 00:06:34,030
<font color="#E5E5E5">like it matters than the efficiency and</font>

174
00:06:30,720 --> 00:06:34,990
of course the security<font color="#CCCCCC"> and</font><font color="#E5E5E5"> the</font>

175
00:06:34,030 --> 00:06:36,789
programmer<font color="#E5E5E5"> will have to implement</font>

176
00:06:34,990 --> 00:06:39,070
subtraction manually this typically

177
00:06:36,790 --> 00:06:40,990
<font color="#E5E5E5">involves adding some auxiliary constants</font>

178
00:06:39,070 --> 00:06:43,120
<font color="#E5E5E5">choosing very chosen very carefully and</font>

179
00:06:40,990 --> 00:06:45,370
then there<font color="#E5E5E5"> will be a division</font><font color="#CCCCCC"> operation</font>

180
00:06:43,120 --> 00:06:46,430
done manually as well<font color="#E5E5E5"> this requires</font>

181
00:06:45,370 --> 00:06:48,320
<font color="#CCCCCC">knowledge of 90</font>

182
00:06:46,430 --> 00:06:50,630
<font color="#E5E5E5">nezam in order to</font><font color="#CCCCCC"> ride the securely and</font>

183
00:06:48,320 --> 00:06:52,940
<font color="#E5E5E5">all there will be multiplication later</font>

184
00:06:50,630 --> 00:06:55,460
which<font color="#E5E5E5"> is going to</font><font color="#CCCCCC"> increase the bit</font><font color="#E5E5E5"> width</font>

185
00:06:52,940 --> 00:06:57,230
of these of these<font color="#CCCCCC"> elements and the</font>

186
00:06:55,460 --> 00:06:59,900
programmer<font color="#E5E5E5"> will be responsible for for</font>

187
00:06:57,230 --> 00:07:02,000
<font color="#E5E5E5">choosing when to reduce or like to do</font>

188
00:06:59,900 --> 00:07:04,520
<font color="#E5E5E5">mod operations to reduce the length of</font>

189
00:07:02,000 --> 00:07:06,200
these<font color="#E5E5E5"> elements</font><font color="#CCCCCC"> so as we see here this is</font>

190
00:07:04,520 --> 00:07:07,820
a very complicated circuit there are

191
00:07:06,200 --> 00:07:09,590
many<font color="#E5E5E5"> decisions by the programmer and</font><font color="#CCCCCC"> the</font>

192
00:07:07,820 --> 00:07:11,630
visibility<font color="#E5E5E5"> is good the complexity is</font>

193
00:07:09,590 --> 00:07:14,539
going to be<font color="#E5E5E5"> visible in both low level</font>

194
00:07:11,630 --> 00:07:16,520
<font color="#E5E5E5">and</font><font color="#CCCCCC"> high level implementations so to</font>

195
00:07:14,540 --> 00:07:18,770
give you<font color="#E5E5E5"> like what</font><font color="#CCCCCC"> X J's naka tries to</font>

196
00:07:16,520 --> 00:07:20,210
do is<font color="#E5E5E5"> to introduce</font><font color="#CCCCCC"> parameterized</font><font color="#E5E5E5"> native</font>

197
00:07:18,770 --> 00:07:22,099
types and automates all<font color="#E5E5E5"> of these</font>

198
00:07:20,210 --> 00:07:23,989
<font color="#E5E5E5">decisions well even having more</font>

199
00:07:22,100 --> 00:07:26,810
efficient circuits than before so

200
00:07:23,990 --> 00:07:29,660
basically in our code<font color="#E5E5E5"> like to show the</font>

201
00:07:26,810 --> 00:07:31,400
code<font color="#E5E5E5"> that for adding the points and in</font>

202
00:07:29,660 --> 00:07:33,680
our frame<font color="#CCCCCC"> of the programmer would point</font>

203
00:07:31,400 --> 00:07:36,979
<font color="#CCCCCC">is going</font><font color="#E5E5E5"> to write code like this it's</font>

204
00:07:33,680 --> 00:07:38,630
<font color="#E5E5E5">basically it's like the actual equations</font>

205
00:07:36,980 --> 00:07:39,950
and I have to emphasize<font color="#E5E5E5"> here</font><font color="#CCCCCC"> that this</font>

206
00:07:38,630 --> 00:07:42,350
<font color="#E5E5E5">is not hard to code it for a</font><font color="#CCCCCC"> certain</font>

207
00:07:39,950 --> 00:07:45,080
field<font color="#E5E5E5"> actually the programmer can define</font>

208
00:07:42,350 --> 00:07:46,790
whatever<font color="#CCCCCC"> field he'd like to move to</font><font color="#E5E5E5"> the</font>

209
00:07:45,080 --> 00:07:48,919
circuit<font color="#CCCCCC"> to operate on and then during</font>

210
00:07:46,790 --> 00:07:51,530
the<font color="#CCCCCC"> editing</font><font color="#E5E5E5"> during and the framework the</font>

211
00:07:48,920 --> 00:07:56,630
programmer<font color="#E5E5E5"> can choose which field</font><font color="#CCCCCC"> he'd</font>

212
00:07:51,530 --> 00:07:57,859
<font color="#E5E5E5">like to</font><font color="#CCCCCC"> do variables to be n and here as</font>

213
00:07:56,630 --> 00:07:59,900
you<font color="#E5E5E5"> see if the programmer</font><font color="#CCCCCC"> can define</font>

214
00:07:57,860 --> 00:08:01,250
long<font color="#E5E5E5"> fields short fields or</font><font color="#CCCCCC"> even</font><font color="#E5E5E5"> work</font><font color="#CCCCCC"> on</font>

215
00:07:59,900 --> 00:08:04,760
the native and<font color="#E5E5E5"> the</font><font color="#CCCCCC"> backend</font>

216
00:08:01,250 --> 00:08:06,140
<font color="#E5E5E5">its implementation</font><font color="#CCCCCC"> according to the</font>

217
00:08:04,760 --> 00:08:08,650
circuit structure and according<font color="#CCCCCC"> to the</font>

218
00:08:06,140 --> 00:08:11,120
fields that<font color="#E5E5E5"> the programmer is working on</font>

219
00:08:08,650 --> 00:08:13,760
<font color="#CCCCCC">ok so the outline</font><font color="#E5E5E5"> of a traditional the</font>

220
00:08:11,120 --> 00:08:15,020
programmer writes the code<font color="#E5E5E5"> and in our</font>

221
00:08:13,760 --> 00:08:17,390
<font color="#CCCCCC">equation arc extension which is</font>

222
00:08:15,020 --> 00:08:19,609
<font color="#E5E5E5">developed as a Java extension on top of</font>

223
00:08:17,390 --> 00:08:22,490
the<font color="#CCCCCC"> JetBrains NBS framework and it gets</font>

224
00:08:19,610 --> 00:08:24,200
<font color="#E5E5E5">type</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> check in the front end and it</font>

225
00:08:22,490 --> 00:08:26,900
gets transformed<font color="#CCCCCC"> to a java code</font><font color="#E5E5E5"> that</font>

226
00:08:24,200 --> 00:08:29,000
generates the circuit and then in the

227
00:08:26,900 --> 00:08:32,449
back end before<font color="#E5E5E5"> we</font><font color="#CCCCCC"> do or generate any</font>

228
00:08:29,000 --> 00:08:34,250
constraints we do like initially<font color="#CCCCCC"> a</font>

229
00:08:32,450 --> 00:08:36,380
complete analysis phase of the circuit

230
00:08:34,250 --> 00:08:37,789
<font color="#CCCCCC">to study how every variables are being</font>

231
00:08:36,380 --> 00:08:40,100
used what are the parameters and so<font color="#CCCCCC"> on</font>

232
00:08:37,789 --> 00:08:41,870
and then in the second phase<font color="#CCCCCC"> we generate</font>

233
00:08:40,100 --> 00:08:43,730
the circuit and then after we generate

234
00:08:41,870 --> 00:08:46,460
the circuit<font color="#CCCCCC"> we'll even apply more</font>

235
00:08:43,730 --> 00:08:48,170
optimizations one part like one key

236
00:08:46,460 --> 00:08:50,330
point<font color="#CCCCCC"> here is that we</font><font color="#E5E5E5"> implemented all</font>

237
00:08:48,170 --> 00:08:51,709
the<font color="#E5E5E5"> steps from the high level code to</font>

238
00:08:50,330 --> 00:08:53,630
the circuit generation in order<font color="#CCCCCC"> to be</font>

239
00:08:51,710 --> 00:08:55,700
<font color="#CCCCCC">able to keep</font><font color="#E5E5E5"> track of the programmers</font>

240
00:08:53,630 --> 00:08:59,970
intention and be able<font color="#CCCCCC"> to make</font><font color="#E5E5E5"> better</font>

241
00:08:55,700 --> 00:09:02,440
decisions<font color="#CCCCCC"> under the hood</font><font color="#E5E5E5"> we</font><font color="#CCCCCC"> have</font>

242
00:08:59,970 --> 00:09:04,420
so<font color="#E5E5E5"> and for the</font><font color="#CCCCCC"> backend we implemented</font>

243
00:09:02,440 --> 00:09:06,850
<font color="#E5E5E5">optimizations for both short and long</font>

244
00:09:04,420 --> 00:09:08,589
integer operations<font color="#E5E5E5"> also we have a new</font>

245
00:09:06,850 --> 00:09:13,780
optimization for<font color="#E5E5E5"> read-only static memory</font>

246
00:09:08,590 --> 00:09:16,480
which which helps for techniques like

247
00:09:13,780 --> 00:09:18,370
the the<font color="#E5E5E5"> sbox which are based in</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> es</font>

248
00:09:16,480 --> 00:09:19,900
<font color="#E5E5E5">and also Greek on pre computed</font>

249
00:09:18,370 --> 00:09:22,090
computations which could appear<font color="#CCCCCC"> in</font>

250
00:09:19,900 --> 00:09:23,709
<font color="#CCCCCC">floating-point operations when we store</font>

251
00:09:22,090 --> 00:09:27,220
or like because it's expensive sometimes

252
00:09:23,710 --> 00:09:29,440
<font color="#E5E5E5">to do many</font><font color="#CCCCCC"> other like operations in the</font>

253
00:09:27,220 --> 00:09:31,180
circuit so<font color="#CCCCCC"> we</font><font color="#E5E5E5"> can</font><font color="#CCCCCC"> recompute them and</font>

254
00:09:29,440 --> 00:09:33,460
store<font color="#E5E5E5"> them</font><font color="#CCCCCC"> in</font><font color="#E5E5E5"> read only memories and</font>

255
00:09:31,180 --> 00:09:35,579
also<font color="#CCCCCC"> we do automated identification of</font>

256
00:09:33,460 --> 00:09:38,170
the efficient<font color="#CCCCCC"> memory representation and</font>

257
00:09:35,580 --> 00:09:39,370
also we do in order<font color="#CCCCCC"> to reduce the model</font>

258
00:09:38,170 --> 00:09:41,349
number of multiplication gates or

259
00:09:39,370 --> 00:09:43,240
constraints even<font color="#CCCCCC"> further</font><font color="#E5E5E5"> we apply</font>

260
00:09:41,350 --> 00:09:44,980
multivariate polynomial minimization we

261
00:09:43,240 --> 00:09:47,440
have implemented the version that that's

262
00:09:44,980 --> 00:09:50,470
customized for the<font color="#CCCCCC"> QA be based ZK snarks</font>

263
00:09:47,440 --> 00:09:51,610
in terms of the<font color="#CCCCCC"> front-end</font><font color="#E5E5E5"> it's currently</font>

264
00:09:50,470 --> 00:09:53,380
as I said developed at the Java

265
00:09:51,610 --> 00:09:55,630
extension using the<font color="#CCCCCC"> JetBrains MVS</font>

266
00:09:53,380 --> 00:09:57,730
framework<font color="#CCCCCC"> it provides parameterize types</font>

267
00:09:55,630 --> 00:10:00,820
for long integer and short integer<font color="#E5E5E5"> and</font>

268
00:09:57,730 --> 00:10:02,500
for field operations<font color="#CCCCCC"> as well</font><font color="#E5E5E5"> it has the</font>

269
00:10:00,820 --> 00:10:03,940
complexity of the<font color="#CCCCCC"> backend</font><font color="#E5E5E5"> implementation</font>

270
00:10:02,500 --> 00:10:06,010
and enables a<font color="#CCCCCC"> better use of</font>

271
00:10:03,940 --> 00:10:07,720
non-determinism<font color="#E5E5E5"> which has basically</font><font color="#CCCCCC"> have</font>

272
00:10:06,010 --> 00:10:10,450
<font color="#E5E5E5">to set the values of external witnesses</font>

273
00:10:07,720 --> 00:10:11,860
<font color="#E5E5E5">in the same</font><font color="#CCCCCC"> environment and we also have</font>

274
00:10:10,450 --> 00:10:14,170
custom<font color="#CCCCCC"> IDE</font><font color="#E5E5E5"> supports so we give</font>

275
00:10:11,860 --> 00:10:16,720
<font color="#CCCCCC">optimisation hence interactively that</font>

276
00:10:14,170 --> 00:10:18,640
are customized<font color="#CCCCCC"> to the to the start</font><font color="#E5E5E5"> and</font>

277
00:10:16,720 --> 00:10:20,500
<font color="#CCCCCC">we have error checking for for the new</font>

278
00:10:18,640 --> 00:10:22,360
type system one<font color="#E5E5E5"> limitation for this</font>

279
00:10:20,500 --> 00:10:23,680
<font color="#E5E5E5">though is that it requires development</font>

280
00:10:22,360 --> 00:10:25,870
to be done in this<font color="#E5E5E5"> framework which would</font>

281
00:10:23,680 --> 00:10:30,130
require<font color="#E5E5E5"> the users in the beginning to</font>

282
00:10:25,870 --> 00:10:31,600
get<font color="#CCCCCC"> familiar with the environment ok so</font>

283
00:10:30,130 --> 00:10:33,070
I'm going<font color="#CCCCCC"> to select just</font><font color="#E5E5E5"> a couple of</font>

284
00:10:31,600 --> 00:10:34,780
<font color="#E5E5E5">points of these for the sake of time to</font>

285
00:10:33,070 --> 00:10:36,850
talk about<font color="#E5E5E5"> one point</font><font color="#CCCCCC"> of the</font><font color="#E5E5E5"> random</font>

286
00:10:34,780 --> 00:10:38,829
memory access like what we do to improve

287
00:10:36,850 --> 00:10:40,960
<font color="#E5E5E5">so basically for the read-only static</font>

288
00:10:38,830 --> 00:10:42,940
memory which given an element of<font color="#E5E5E5"> hard</font>

289
00:10:40,960 --> 00:10:46,330
<font color="#E5E5E5">coded values and unknown</font><font color="#CCCCCC"> index are</font>

290
00:10:42,940 --> 00:10:49,780
during runtime return the value at<font color="#E5E5E5"> the</font>

291
00:10:46,330 --> 00:10:52,330
specific<font color="#E5E5E5"> index</font><font color="#CCCCCC"> so basically the</font>

292
00:10:49,780 --> 00:10:54,100
currently<font color="#E5E5E5"> available ways to do it</font><font color="#CCCCCC"> are</font>

293
00:10:52,330 --> 00:10:57,340
either<font color="#E5E5E5"> murk of trees or to do a linear</font>

294
00:10:54,100 --> 00:10:59,230
scan or to use a permutation network<font color="#E5E5E5"> and</font>

295
00:10:57,340 --> 00:11:01,270
in the paper we<font color="#CCCCCC"> describe a new</font>

296
00:10:59,230 --> 00:11:03,310
optimization<font color="#CCCCCC"> that is specific to the</font>

297
00:11:01,270 --> 00:11:06,880
cost model<font color="#E5E5E5"> of the key will be</font><font color="#CCCCCC"> basic</font>

298
00:11:03,310 --> 00:11:10,099
<font color="#E5E5E5">start mainly it it relies on</font><font color="#CCCCCC"> the on that</font>

299
00:11:06,880 --> 00:11:12,589
<font color="#CCCCCC">the multiplication by constants are</font>

300
00:11:10,100 --> 00:11:15,410
our<font color="#E5E5E5"> sheep and also it relies on</font>

301
00:11:12,589 --> 00:11:17,209
<font color="#CCCCCC">non-determinism and it it's based on</font>

302
00:11:15,410 --> 00:11:18,829
<font color="#E5E5E5">dividing or partitioning this array and</font>

303
00:11:17,209 --> 00:11:21,229
the square<font color="#E5E5E5"> root of n stood partitions</font>

304
00:11:18,829 --> 00:11:23,810
where we construct a linear<font color="#CCCCCC"> system of</font>

305
00:11:21,230 --> 00:11:25,790
flying for<font color="#E5E5E5"> every partition and then in</font>

306
00:11:23,810 --> 00:11:28,130
the circuit we just check a membership

307
00:11:25,790 --> 00:11:33,410
by<font color="#E5E5E5"> checking whether the</font><font color="#CCCCCC"> solution</font>

308
00:11:28,130 --> 00:11:35,420
provided by by the prover like belongs

309
00:11:33,410 --> 00:11:37,730
to one of<font color="#CCCCCC"> these square root of n</font><font color="#E5E5E5"> linear</font>

310
00:11:35,420 --> 00:11:42,949
systems<font color="#CCCCCC"> in in comparison with earlier</font>

311
00:11:37,730 --> 00:11:44,899
work<font color="#CCCCCC"> this scheme</font><font color="#E5E5E5"> is as you see it it</font>

312
00:11:42,949 --> 00:11:46,579
<font color="#E5E5E5">doesn't</font><font color="#CCCCCC"> look from this table that it's</font>

313
00:11:44,899 --> 00:11:47,990
more efficient<font color="#E5E5E5"> actually asymptotically</font>

314
00:11:46,579 --> 00:11:50,000
speaking of the murk<font color="#E5E5E5"> of</font><font color="#CCCCCC"> tree is more</font>

315
00:11:47,990 --> 00:11:52,399
efficient<font color="#E5E5E5"> but as we're going</font><font color="#CCCCCC"> to see</font><font color="#E5E5E5"> when</font>

316
00:11:50,000 --> 00:11:55,699
<font color="#CCCCCC">we speak completely or if I wait or like</font>

317
00:11:52,399 --> 00:11:57,560
get the actual value for constants<font color="#E5E5E5"> it's</font>

318
00:11:55,699 --> 00:11:59,779
actually<font color="#E5E5E5"> better than all of these</font>

319
00:11:57,560 --> 00:12:03,560
schemes<font color="#CCCCCC"> when the size of</font><font color="#E5E5E5"> the memory is</font><font color="#CCCCCC"> a</font>

320
00:11:59,779 --> 00:12:05,480
small and for any memory access or like

321
00:12:03,560 --> 00:12:06,949
for<font color="#E5E5E5"> any number of accesses so</font><font color="#CCCCCC"> for</font>

322
00:12:05,480 --> 00:12:08,750
<font color="#E5E5E5">example it's better than in the very</font>

323
00:12:06,949 --> 00:12:10,160
first part<font color="#E5E5E5"> it's it's better than the</font>

324
00:12:08,750 --> 00:12:13,130
<font color="#E5E5E5">nearest one it's better than the linear</font>

325
00:12:10,160 --> 00:12:15,439
<font color="#E5E5E5">scan and later is better than the</font>

326
00:12:13,130 --> 00:12:17,149
optimized permutation<font color="#CCCCCC"> network</font><font color="#E5E5E5"> and I have</font>

327
00:12:15,440 --> 00:12:18,800
to say the<font color="#CCCCCC"> the current compilers don't</font>

328
00:12:17,149 --> 00:12:20,990
use the<font color="#CCCCCC"> both mice prepetition network</font>

329
00:12:18,800 --> 00:12:24,979
but we<font color="#CCCCCC"> just</font><font color="#E5E5E5"> included here for fairness</font>

330
00:12:20,990 --> 00:12:26,990
<font color="#E5E5E5">of comparison also</font><font color="#CCCCCC"> we use what we call a</font>

331
00:12:24,980 --> 00:12:28,819
smart<font color="#E5E5E5"> memory structure so basically</font>

332
00:12:26,990 --> 00:12:32,360
based<font color="#CCCCCC"> on</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> workload of</font><font color="#E5E5E5"> the program we</font>

333
00:12:28,819 --> 00:12:35,000
identify which which memory<font color="#E5E5E5"> algorithm to</font>

334
00:12:32,360 --> 00:12:36,980
use<font color="#CCCCCC"> treat like</font><font color="#E5E5E5"> like to represent the</font>

335
00:12:35,000 --> 00:12:38,899
memory accesses and<font color="#E5E5E5"> so basically we have</font>

336
00:12:36,980 --> 00:12:41,569
<font color="#CCCCCC">three possible memory algorithms</font>

337
00:12:38,899 --> 00:12:43,160
<font color="#E5E5E5">including the</font><font color="#CCCCCC"> the linear scan the</font>

338
00:12:41,569 --> 00:12:44,959
routing networks and our read-only

339
00:12:43,160 --> 00:12:47,959
memory technique and we decide what's

340
00:12:44,959 --> 00:12:49,638
best based<font color="#E5E5E5"> on the program analyzing the</font>

341
00:12:47,959 --> 00:12:51,319
program<font color="#CCCCCC"> and I have to say that we don't</font>

342
00:12:49,639 --> 00:12:53,569
<font color="#E5E5E5">group all the memory accesses into just</font>

343
00:12:51,319 --> 00:12:55,760
one memory we have to study every memory

344
00:12:53,569 --> 00:12:56,839
separately and this gives us a more

345
00:12:55,760 --> 00:12:59,060
efficient representation<font color="#CCCCCC"> for</font>

346
00:12:56,839 --> 00:13:01,160
<font color="#E5E5E5">object-oriented programs so XJ snark</font>

347
00:12:59,060 --> 00:13:04,219
provides the<font color="#CCCCCC"> ability to write the</font>

348
00:13:01,160 --> 00:13:06,620
programmers to<font color="#E5E5E5"> write different class</font>

349
00:13:04,220 --> 00:13:09,079
definitions and the programmer<font color="#CCCCCC"> can call</font>

350
00:13:06,620 --> 00:13:11,509
methods<font color="#CCCCCC"> on references that</font><font color="#E5E5E5"> are</font><font color="#CCCCCC"> unknown</font>

351
00:13:09,079 --> 00:13:13,399
<font color="#E5E5E5">during</font><font color="#CCCCCC"> runtime in order</font><font color="#E5E5E5"> to implement</font>

352
00:13:11,509 --> 00:13:16,550
<font color="#E5E5E5">this efficiently we found that every</font>

353
00:13:13,399 --> 00:13:18,410
class<font color="#CCCCCC"> has</font><font color="#E5E5E5"> to every</font><font color="#CCCCCC"> class definition has</font>

354
00:13:16,550 --> 00:13:21,769
<font color="#CCCCCC">to have</font><font color="#E5E5E5"> a smart memory structure for</font>

355
00:13:18,410 --> 00:13:23,430
<font color="#E5E5E5">each of its attributes also</font><font color="#CCCCCC"> we as</font>

356
00:13:21,769 --> 00:13:25,649
another feature we<font color="#CCCCCC"> have what we</font>

357
00:13:23,430 --> 00:13:27,390
external code blocks which actually

358
00:13:25,649 --> 00:13:29,820
enables<font color="#E5E5E5"> the programmer</font><font color="#CCCCCC"> to make</font><font color="#E5E5E5"> use of</font>

359
00:13:27,390 --> 00:13:31,740
the non-deterministic<font color="#E5E5E5"> of the</font><font color="#CCCCCC"> Zika starts</font>

360
00:13:29,820 --> 00:13:33,720
so basically let's say if<font color="#E5E5E5"> we'd like to</font>

361
00:13:31,740 --> 00:13:36,330
<font color="#CCCCCC">write a sorting code</font><font color="#E5E5E5"> we don't</font><font color="#CCCCCC"> need</font><font color="#E5E5E5"> any</font>

362
00:13:33,720 --> 00:13:38,700
<font color="#E5E5E5">more to write short code as and as in</font>

363
00:13:36,330 --> 00:13:40,290
the<font color="#CCCCCC"> previous work we actually can define</font>

364
00:13:38,700 --> 00:13:43,800
the code<font color="#E5E5E5"> this way the the programmer can</font>

365
00:13:40,290 --> 00:13:45,510
<font color="#E5E5E5">say that the sorted array is</font><font color="#CCCCCC"> going to be</font>

366
00:13:43,800 --> 00:13:47,099
a witness<font color="#E5E5E5"> and then we have an external</font>

367
00:13:45,510 --> 00:13:49,100
code block that<font color="#CCCCCC"> is going to be</font>

368
00:13:47,100 --> 00:13:51,630
<font color="#E5E5E5">completely executed outside the circuit</font>

369
00:13:49,100 --> 00:13:53,700
in this<font color="#CCCCCC"> case for example</font><font color="#E5E5E5"> the the</font>

370
00:13:51,630 --> 00:13:55,500
programmer can<font color="#CCCCCC"> call any Java library</font><font color="#E5E5E5"> to</font>

371
00:13:53,700 --> 00:13:57,450
like to sort and<font color="#E5E5E5"> then figure</font><font color="#CCCCCC"> out</font><font color="#E5E5E5"> how the</font>

372
00:13:55,500 --> 00:13:59,250
elements are<font color="#CCCCCC"> going</font><font color="#E5E5E5"> to be met and then in</font>

373
00:13:57,450 --> 00:14:00,899
the circuit itself<font color="#CCCCCC"> we're going to verify</font>

374
00:13:59,250 --> 00:14:03,450
<font color="#CCCCCC">the permutation that the English and the</font>

375
00:14:00,899 --> 00:14:06,120
<font color="#CCCCCC">Albus</font><font color="#E5E5E5"> are similar and we just verify the</font>

376
00:14:03,450 --> 00:14:08,360
<font color="#CCCCCC">sort in condition okay</font><font color="#E5E5E5"> this is actually</font>

377
00:14:06,120 --> 00:14:10,680
going to result<font color="#CCCCCC"> in two more</font><font color="#E5E5E5"> efficient</font>

378
00:14:08,360 --> 00:14:11,940
Serkis time before and<font color="#CCCCCC"> I have to say</font>

379
00:14:10,680 --> 00:14:15,510
that there's verify permutation<font color="#E5E5E5"> is</font>

380
00:14:11,940 --> 00:14:17,010
actually a high level of code<font color="#CCCCCC"> or an</font>

381
00:14:15,510 --> 00:14:18,510
instruction<font color="#CCCCCC"> in</font><font color="#E5E5E5"> our program so that the</font>

382
00:14:17,010 --> 00:14:20,520
programmer<font color="#E5E5E5"> doesn't have to get into</font>

383
00:14:18,510 --> 00:14:24,360
writing switches or<font color="#CCCCCC"> sitting witnesses</font>

384
00:14:20,520 --> 00:14:27,209
and so on<font color="#E5E5E5"> okay</font><font color="#CCCCCC"> so in terms of</font><font color="#E5E5E5"> evaluation</font>

385
00:14:24,360 --> 00:14:29,339
we evaluated into<font color="#CCCCCC"> multiple contexts so</font>

386
00:14:27,209 --> 00:14:31,920
in<font color="#E5E5E5"> comparison or for cryptographic</font>

387
00:14:29,339 --> 00:14:35,430
primitives<font color="#E5E5E5"> we compared with other</font>

388
00:14:31,920 --> 00:14:38,969
<font color="#E5E5E5">compilers for sha-256 and RSA and es for</font>

389
00:14:35,430 --> 00:14:42,120
all of them we show that our<font color="#E5E5E5"> circuits</font>

390
00:14:38,970 --> 00:14:44,029
are<font color="#CCCCCC"> our more concise</font><font color="#E5E5E5"> and in more in in</font>

391
00:14:42,120 --> 00:14:47,370
some cases<font color="#E5E5E5"> well that it does not require</font>

392
00:14:44,029 --> 00:14:49,320
high programming<font color="#E5E5E5"> effort and for for for</font>

393
00:14:47,370 --> 00:14:51,660
this<font color="#E5E5E5"> table for the sha-256 and the RSA</font>

394
00:14:49,320 --> 00:14:53,700
our implementation<font color="#CCCCCC"> actually match the</font>

395
00:14:51,660 --> 00:14:56,760
<font color="#E5E5E5">manual implementation for this version</font>

396
00:14:53,700 --> 00:14:58,110
though the es does not but for our most

397
00:14:56,760 --> 00:14:59,370
recent<font color="#E5E5E5"> version of the code that we</font>

398
00:14:58,110 --> 00:15:02,130
posted we<font color="#E5E5E5"> matched the manual on</font>

399
00:14:59,370 --> 00:15:03,930
<font color="#CCCCCC">permutation</font><font color="#E5E5E5"> for es as well and to give</font>

400
00:15:02,130 --> 00:15:07,140
you also a sense<font color="#E5E5E5"> of why these things are</font>

401
00:15:03,930 --> 00:15:08,550
useful<font color="#CCCCCC"> so here we compare</font><font color="#E5E5E5"> what would be</font>

402
00:15:07,140 --> 00:15:10,680
the proof time and the proving key size

403
00:15:08,550 --> 00:15:12,420
and the memory<font color="#E5E5E5"> usage when we apply our</font>

404
00:15:10,680 --> 00:15:15,000
<font color="#E5E5E5">optimizations so for example for the AES</font>

405
00:15:12,420 --> 00:15:17,790
when we apply it<font color="#E5E5E5"> for a 300 block circuit</font>

406
00:15:15,000 --> 00:15:19,410
we we see here optimizations<font color="#CCCCCC"> on all of</font>

407
00:15:17,790 --> 00:15:21,209
the<font color="#E5E5E5"> different aspects including the</font>

408
00:15:19,410 --> 00:15:25,529
proof time the proving key size and the

409
00:15:21,209 --> 00:15:27,689
memory usage also<font color="#CCCCCC"> for the random memory</font>

410
00:15:25,529 --> 00:15:30,300
access applications<font color="#E5E5E5"> we show here okay so</font>

411
00:15:27,690 --> 00:15:31,680
<font color="#E5E5E5">we have two options either to write just</font>

412
00:15:30,300 --> 00:15:34,740
for<font color="#CCCCCC"> fairness of comparison to write</font>

413
00:15:31,680 --> 00:15:36,630
<font color="#E5E5E5">merge sort code on our</font><font color="#CCCCCC"> accession arc</font><font color="#E5E5E5"> and</font>

414
00:15:34,740 --> 00:15:38,340
in<font color="#E5E5E5"> this case we also perform</font>

415
00:15:36,630 --> 00:15:40,380
previous work<font color="#E5E5E5"> this is due to</font><font color="#CCCCCC"> the</font>

416
00:15:38,340 --> 00:15:43,110
adaptive memory<font color="#E5E5E5"> techniques that we have</font>

417
00:15:40,380 --> 00:15:44,760
<font color="#E5E5E5">and other low level optimizations</font><font color="#CCCCCC"> and if</font>

418
00:15:43,110 --> 00:15:47,100
the programmer chooses to use<font color="#E5E5E5"> the</font>

419
00:15:44,760 --> 00:15:49,470
permutation verifier<font color="#CCCCCC"> to</font><font color="#E5E5E5"> to get better</font>

420
00:15:47,100 --> 00:15:51,810
numbers<font color="#E5E5E5"> or like to write the sorting as</font>

421
00:15:49,470 --> 00:15:55,400
as in the example that I<font color="#CCCCCC"> show it</font>

422
00:15:51,810 --> 00:15:57,449
actually gets orders<font color="#E5E5E5"> of magnitude</font><font color="#CCCCCC"> better</font>

423
00:15:55,400 --> 00:15:58,579
additionally we've chosen one of<font color="#E5E5E5"> the</font>

424
00:15:57,450 --> 00:16:01,590
applications that were developed

425
00:15:58,580 --> 00:16:04,770
<font color="#CCCCCC">manually and we wrote</font><font color="#E5E5E5"> it using our</font>

426
00:16:01,590 --> 00:16:07,530
application<font color="#CCCCCC"> or our</font><font color="#E5E5E5"> X a snark and here we</font>

427
00:16:04,770 --> 00:16:10,380
<font color="#CCCCCC">show that our framework was able to get</font>

428
00:16:07,530 --> 00:16:12,240
<font color="#E5E5E5">to the manual implementation of of the</font>

429
00:16:10,380 --> 00:16:14,160
zero cash<font color="#CCCCCC"> I'm not going</font><font color="#E5E5E5"> to say it beats</font>

430
00:16:12,240 --> 00:16:16,140
<font color="#E5E5E5">the manual implementation because it's</font>

431
00:16:14,160 --> 00:16:17,790
it's it's always<font color="#E5E5E5"> possible</font><font color="#CCCCCC"> to modify</font><font color="#E5E5E5"> any</font>

432
00:16:16,140 --> 00:16:20,010
manual implementation to be better but

433
00:16:17,790 --> 00:16:25,560
at least we can now<font color="#CCCCCC"> take manual like</font>

434
00:16:20,010 --> 00:16:30,990
<font color="#E5E5E5">automated tools to reach manual manually</font>

435
00:16:25,560 --> 00:16:32,189
<font color="#CCCCCC">develop tools</font><font color="#E5E5E5"> for some applications</font><font color="#CCCCCC"> ok</font>

436
00:16:30,990 --> 00:16:34,410
so in terms<font color="#E5E5E5"> of the limitations and in</font>

437
00:16:32,190 --> 00:16:35,970
the future work we blend we to integrate

438
00:16:34,410 --> 00:16:37,920
other optimizations<font color="#E5E5E5"> till this point we</font>

439
00:16:35,970 --> 00:16:40,260
are<font color="#E5E5E5"> also considering other applications</font>

440
00:16:37,920 --> 00:16:42,000
and including more optimizations<font color="#E5E5E5"> we plan</font>

441
00:16:40,260 --> 00:16:43,050
to integrate<font color="#CCCCCC"> with other front-ends we</font>

442
00:16:42,000 --> 00:16:45,090
would like<font color="#CCCCCC"> to customize the</font>

443
00:16:43,050 --> 00:16:46,770
optimizations for<font color="#E5E5E5"> other the it's not</font>

444
00:16:45,090 --> 00:16:48,930
<font color="#E5E5E5">constructions we've seen in this</font>

445
00:16:46,770 --> 00:16:50,210
conference multiple other backends<font color="#E5E5E5"> so we</font>

446
00:16:48,930 --> 00:16:53,250
would<font color="#E5E5E5"> like to as</font><font color="#CCCCCC"> well to</font><font color="#E5E5E5"> make our</font>

447
00:16:50,210 --> 00:16:54,900
optimizations<font color="#E5E5E5"> compatible and we would</font>

448
00:16:53,250 --> 00:16:56,940
like also to do automated<font color="#E5E5E5"> testing for</font>

449
00:16:54,900 --> 00:16:59,189
missing<font color="#E5E5E5"> or incorrect constraints because</font>

450
00:16:56,940 --> 00:17:00,450
it's easy or it's relatively easy<font color="#E5E5E5"> to</font>

451
00:16:59,190 --> 00:17:02,340
check the correctness of this of the

452
00:17:00,450 --> 00:17:05,880
circuit but how<font color="#CCCCCC"> can we make sure that</font>

453
00:17:02,340 --> 00:17:07,170
any<font color="#E5E5E5"> of the constraints</font><font color="#CCCCCC"> have not</font><font color="#E5E5E5"> been or</font>

454
00:17:05,880 --> 00:17:08,780
like we need to<font color="#E5E5E5"> make</font><font color="#CCCCCC"> sure</font><font color="#E5E5E5"> that all the</font>

455
00:17:07,170 --> 00:17:11,220
<font color="#E5E5E5">constraints have been written correctly</font>

456
00:17:08,780 --> 00:17:12,689
so<font color="#CCCCCC"> we have made the partial release</font>

457
00:17:11,220 --> 00:17:13,980
<font color="#CCCCCC">actually snark</font><font color="#E5E5E5"> on github and more</font>

458
00:17:12,689 --> 00:17:15,390
improvements and refinements are going

459
00:17:13,980 --> 00:17:18,089
to be posted<font color="#E5E5E5"> and we've posted the</font>

460
00:17:15,390 --> 00:17:20,640
<font color="#E5E5E5">manually developed of to my circuit or</font>

461
00:17:18,089 --> 00:17:23,938
gadgets as well and the our<font color="#E5E5E5"> manually</font>

462
00:17:20,640 --> 00:17:25,860
developed library with that I'm going<font color="#CCCCCC"> to</font>

463
00:17:23,939 --> 00:17:28,419
conclude<font color="#CCCCCC"> my talk thank you and</font><font color="#E5E5E5"> please</font>

464
00:17:25,859 --> 00:17:38,439
<font color="#CCCCCC">you know if you have</font><font color="#E5E5E5"> questions</font>

465
00:17:28,419 --> 00:17:41,200
<font color="#CCCCCC">I</font><font color="#E5E5E5"> thank you for your talk</font><font color="#CCCCCC"> also</font><font color="#E5E5E5"> thank you</font>

466
00:17:38,440 --> 00:17:44,859
for referring<font color="#CCCCCC"> to our work as QA base QA</font>

467
00:17:41,200 --> 00:17:48,220
<font color="#CCCCCC">p based not linear PC P based so my</font>

468
00:17:44,859 --> 00:17:51,789
question is there have been<font color="#E5E5E5"> all kinds of</font>

469
00:17:48,220 --> 00:17:55,169
gadgets<font color="#E5E5E5"> that optimize the representation</font>

470
00:17:51,789 --> 00:17:57,820
of different<font color="#E5E5E5"> sub circuits as a quadratic</font>

471
00:17:55,169 --> 00:17:59,919
<font color="#E5E5E5">arithmetic problems is it easy</font><font color="#CCCCCC"> to</font>

472
00:17:57,820 --> 00:18:02,080
integrate<font color="#E5E5E5"> in your framework new</font>

473
00:17:59,919 --> 00:18:05,019
potential gadgets<font color="#CCCCCC"> that people might be</font>

474
00:18:02,080 --> 00:18:07,739
<font color="#CCCCCC">coming up with</font><font color="#E5E5E5"> okay so let's say if I</font>

475
00:18:05,019 --> 00:18:11,289
like if my<font color="#CCCCCC"> ex additionally does not</font>

476
00:18:07,739 --> 00:18:12,039
implement a certain gadget<font color="#E5E5E5"> in a most</font>

477
00:18:11,289 --> 00:18:15,100
efficient way

478
00:18:12,039 --> 00:18:18,039
like we provide like the programmer can

479
00:18:15,100 --> 00:18:19,809
<font color="#E5E5E5">actually develop or like do the manual</font>

480
00:18:18,039 --> 00:18:21,970
development and in<font color="#E5E5E5"> the framework itself</font>

481
00:18:19,809 --> 00:18:23,408
<font color="#E5E5E5">so we basically provide the programmer</font>

482
00:18:21,970 --> 00:18:25,419
<font color="#CCCCCC">to be able to</font><font color="#E5E5E5"> define these external</font>

483
00:18:23,409 --> 00:18:27,220
<font color="#CCCCCC">witnesses which actually looks like the</font>

484
00:18:25,419 --> 00:18:30,009
manually developed<font color="#CCCCCC"> order like</font><font color="#E5E5E5"> manual</font>

485
00:18:27,220 --> 00:18:31,419
<font color="#E5E5E5">development exactly so the programmer</font>

486
00:18:30,009 --> 00:18:34,450
would still be able<font color="#CCCCCC"> to</font><font color="#E5E5E5"> integrate these</font>

487
00:18:31,419 --> 00:18:36,519
<font color="#CCCCCC">gadgets or you're asking about okay</font><font color="#E5E5E5"> so</font>

488
00:18:34,450 --> 00:18:38,109
if the<font color="#CCCCCC"> question is</font><font color="#E5E5E5"> about if there is a</font>

489
00:18:36,519 --> 00:18:40,929
<font color="#CCCCCC">hard-coded gadget that we would like to</font>

490
00:18:38,109 --> 00:18:42,639
integrate directly<font color="#CCCCCC"> and our framework</font><font color="#E5E5E5"> we</font>

491
00:18:40,929 --> 00:18:44,529
currently<font color="#E5E5E5"> don't support this but it's</font>

492
00:18:42,639 --> 00:18:46,709
possible in<font color="#CCCCCC"> the</font><font color="#E5E5E5"> future that</font><font color="#CCCCCC"> that we can</font>

493
00:18:44,529 --> 00:18:46,710
do it

494
00:18:50,200 --> 00:18:56,119
let's<font color="#E5E5E5"> think I met</font><font color="#CCCCCC"> again thank</font><font color="#E5E5E5"> you</font>

495
00:18:53,350 --> 00:18:56,119
[Applause]

