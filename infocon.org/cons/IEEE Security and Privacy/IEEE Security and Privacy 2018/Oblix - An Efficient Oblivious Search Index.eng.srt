1
00:00:07,560 --> 00:00:12,829
thank you hi everyone<font color="#CCCCCC"> I'm platic and I'm</font>

2
00:00:11,160 --> 00:00:14,930
presenting

3
00:00:12,830 --> 00:00:17,810
<font color="#E5E5E5">oblivia search index this is joint work</font>

4
00:00:14,930 --> 00:00:22,009
with<font color="#CCCCCC"> Trisha Gerry</font><font color="#E5E5E5"> Alessandro and</font><font color="#CCCCCC"> Raluca</font>

5
00:00:17,810 --> 00:00:23,390
at<font color="#E5E5E5"> Berkeley</font><font color="#CCCCCC"> okay so today's search</font>

6
00:00:22,009 --> 00:00:25,490
indices are<font color="#CCCCCC"> used</font><font color="#E5E5E5"> for all</font><font color="#CCCCCC"> kinds of</font>

7
00:00:23,390 --> 00:00:27,290
applications<font color="#CCCCCC"> the normal architecture for</font>

8
00:00:25,490 --> 00:00:29,029
<font color="#E5E5E5">this is that</font><font color="#CCCCCC"> you have a</font><font color="#E5E5E5"> client who</font>

9
00:00:27,290 --> 00:00:30,859
outsources the index to some remote

10
00:00:29,029 --> 00:00:33,980
server<font color="#CCCCCC"> so that they can later make</font>

11
00:00:30,859 --> 00:00:35,480
<font color="#CCCCCC">queries and get back the result</font><font color="#E5E5E5"> however</font>

12
00:00:33,980 --> 00:00:38,029
<font color="#E5E5E5">these indices are often used to store</font>

13
00:00:35,480 --> 00:00:39,739
<font color="#E5E5E5">sensitive data and if the server becomes</font>

14
00:00:38,030 --> 00:00:41,780
compromised<font color="#E5E5E5"> then the attacker can learn</font>

15
00:00:39,739 --> 00:00:43,669
not<font color="#CCCCCC"> only the contents of the index but</font>

16
00:00:41,780 --> 00:00:46,699
<font color="#E5E5E5">also the queries</font><font color="#CCCCCC"> that the client is</font>

17
00:00:43,670 --> 00:00:49,070
<font color="#E5E5E5">making so over the past 20 years has</font>

18
00:00:46,699 --> 00:00:51,229
been<font color="#CCCCCC"> a lot of</font><font color="#E5E5E5"> work on performing search</font>

19
00:00:49,070 --> 00:00:53,269
of encrypted data and the general

20
00:00:51,229 --> 00:00:56,180
architecture<font color="#CCCCCC"> a paradigm of these works</font>

21
00:00:53,269 --> 00:00:57,650
is that the client has a secret key<font color="#CCCCCC"> and</font>

22
00:00:56,180 --> 00:00:59,269
they use this<font color="#E5E5E5"> to encrypt the index</font>

23
00:00:57,650 --> 00:01:01,549
<font color="#CCCCCC">before uploading it to</font><font color="#E5E5E5"> the server</font><font color="#CCCCCC"> and</font>

24
00:00:59,269 --> 00:01:04,400
they can make later<font color="#E5E5E5"> encrypted queries</font>

25
00:01:01,549 --> 00:01:06,289
and get<font color="#E5E5E5"> back in cryptid results however</font>

26
00:01:04,400 --> 00:01:08,690
<font color="#CCCCCC">one problem with almost</font><font color="#E5E5E5"> all efficient</font>

27
00:01:06,290 --> 00:01:10,850
solutions in<font color="#E5E5E5"> this space is that the</font>

28
00:01:08,690 --> 00:01:12,740
<font color="#CCCCCC">leaked access patterns</font><font color="#E5E5E5"> water access</font>

29
00:01:10,850 --> 00:01:14,750
patterns<font color="#E5E5E5"> well basically they leak to the</font>

30
00:01:12,740 --> 00:01:17,509
adversary<font color="#E5E5E5"> which location</font><font color="#CCCCCC"> and the index</font>

31
00:01:14,750 --> 00:01:19,040
<font color="#E5E5E5">is accessed in response to a query so</font>

32
00:01:17,510 --> 00:01:20,990
for<font color="#E5E5E5"> example if I make the same query</font>

33
00:01:19,040 --> 00:01:22,670
twice then the adversary sees<font color="#E5E5E5"> at the</font>

34
00:01:20,990 --> 00:01:24,619
same location<font color="#CCCCCC"> and</font><font color="#E5E5E5"> the index is accessed</font>

35
00:01:22,670 --> 00:01:26,720
twice and then in<font color="#E5E5E5"> first that the same</font>

36
00:01:24,620 --> 00:01:29,660
query was made this is<font color="#E5E5E5"> without breaking</font>

37
00:01:26,720 --> 00:01:31,220
the encryption scheme in<font color="#E5E5E5"> any way</font><font color="#CCCCCC"> a bunch</font>

38
00:01:29,660 --> 00:01:33,050
<font color="#E5E5E5">of works of the past five years have</font>

39
00:01:31,220 --> 00:01:34,820
used<font color="#E5E5E5"> this leakage to recover not only</font>

40
00:01:33,050 --> 00:01:39,259
query contents but also the contents

41
00:01:34,820 --> 00:01:40,789
contents of the index<font color="#CCCCCC"> okay so one</font>

42
00:01:39,260 --> 00:01:43,520
<font color="#E5E5E5">potential solution for this is to</font><font color="#CCCCCC"> use</font>

43
00:01:40,790 --> 00:01:45,500
oblivious<font color="#CCCCCC"> RAM oblivious Ram basically</font>

44
00:01:43,520 --> 00:01:47,089
allows you to<font color="#E5E5E5"> make these encrypted</font>

45
00:01:45,500 --> 00:01:49,370
<font color="#E5E5E5">queries</font><font color="#CCCCCC"> without revealing</font><font color="#E5E5E5"> to</font><font color="#CCCCCC"> the</font>

46
00:01:47,090 --> 00:01:50,900
adversary which location was accessed<font color="#E5E5E5"> it</font>

47
00:01:49,370 --> 00:01:53,900
looks as<font color="#CCCCCC"> if you were</font><font color="#E5E5E5"> accessing a random</font>

48
00:01:50,900 --> 00:01:55,760
<font color="#E5E5E5">item the</font><font color="#CCCCCC"> National question now is</font>

49
00:01:53,900 --> 00:01:59,330
whether we can<font color="#CCCCCC"> use oblivious ran to get</font>

50
00:01:55,760 --> 00:02:01,760
<font color="#CCCCCC">secure search indices but</font><font color="#E5E5E5"> we immediately</font>

51
00:01:59,330 --> 00:02:03,408
run in some problems the first<font color="#E5E5E5"> is that</font>

52
00:02:01,760 --> 00:02:05,600
even the most efficient state<font color="#E5E5E5"> of the our</font>

53
00:02:03,409 --> 00:02:07,190
schemes today require a<font color="#E5E5E5"> number of rounds</font>

54
00:02:05,600 --> 00:02:10,579
<font color="#E5E5E5">of interaction and have a high bandwidth</font>

55
00:02:07,190 --> 00:02:12,290
overhead the second issue is<font color="#CCCCCC"> that Oram</font>

56
00:02:10,580 --> 00:02:15,230
is in some sense inherently single user

57
00:02:12,290 --> 00:02:16,548
each the client has a single key<font color="#CCCCCC"> and</font>

58
00:02:15,230 --> 00:02:17,959
they don't really<font color="#E5E5E5"> want</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> share this</font>

59
00:02:16,549 --> 00:02:20,060
with<font color="#CCCCCC"> other users because they might not</font>

60
00:02:17,959 --> 00:02:22,790
<font color="#CCCCCC">trust them for example if you use or am</font>

61
00:02:20,060 --> 00:02:26,780
in a big web app or anybody can<font color="#E5E5E5"> be can</font>

62
00:02:22,790 --> 00:02:27,060
sign up<font color="#E5E5E5"> as a user</font><font color="#CCCCCC"> ok</font><font color="#E5E5E5"> so what we do in</font>

63
00:02:26,780 --> 00:02:29,220
all

64
00:02:27,060 --> 00:02:32,430
is construct an efficient oblivious

65
00:02:29,220 --> 00:02:35,550
index that is low latency has low

66
00:02:32,430 --> 00:02:37,980
bandwidth supports<font color="#E5E5E5"> multiple users and</font>

67
00:02:35,550 --> 00:02:39,630
also<font color="#CCCCCC"> supports inserts and deletes</font><font color="#E5E5E5"> we</font>

68
00:02:37,980 --> 00:02:41,340
achieve this<font color="#E5E5E5"> by a combination of</font>

69
00:02:39,630 --> 00:02:43,350
hardware<font color="#CCCCCC"> enclaves as well as new</font>

70
00:02:41,340 --> 00:02:44,640
oblivious algorithms that<font color="#E5E5E5"> leverage the</font>

71
00:02:43,350 --> 00:02:48,030
<font color="#CCCCCC">enclaves as</font><font color="#E5E5E5"> well as fix their</font>

72
00:02:44,640 --> 00:02:51,000
shortcomings<font color="#CCCCCC"> ok so let's quickly recap</font>

73
00:02:48,030 --> 00:02:53,700
what<font color="#E5E5E5"> hardware enclaves do they basically</font>

74
00:02:51,000 --> 00:02:55,920
allow<font color="#E5E5E5"> a user to outsource execution of</font>

75
00:02:53,700 --> 00:02:58,679
<font color="#E5E5E5">their program</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> some possibly malicious</font>

76
00:02:55,920 --> 00:02:59,940
remote server<font color="#E5E5E5"> in such a way that the</font>

77
00:02:58,680 --> 00:03:02,490
adversary doesn't<font color="#E5E5E5"> learn</font><font color="#CCCCCC"> information</font>

78
00:02:59,940 --> 00:03:05,670
<font color="#CCCCCC">about the program execution</font><font color="#E5E5E5"> so in more</font>

79
00:03:02,490 --> 00:03:08,220
<font color="#E5E5E5">detail</font><font color="#CCCCCC"> the user is able</font><font color="#E5E5E5"> to establish</font>

80
00:03:05,670 --> 00:03:09,720
<font color="#E5E5E5">some secure channel with the Enclave and</font>

81
00:03:08,220 --> 00:03:11,790
<font color="#E5E5E5">they can then send the program and</font><font color="#CCCCCC"> data</font>

82
00:03:09,720 --> 00:03:14,340
<font color="#CCCCCC">over this channel</font><font color="#E5E5E5"> The Enclave runs the</font>

83
00:03:11,790 --> 00:03:15,900
program<font color="#CCCCCC"> and sends back the result the</font>

84
00:03:14,340 --> 00:03:17,970
<font color="#E5E5E5">guarantee</font><font color="#CCCCCC"> that these</font><font color="#E5E5E5"> enclaves</font><font color="#CCCCCC"> can claim</font>

85
00:03:15,900 --> 00:03:21,120
to<font color="#CCCCCC"> provide</font><font color="#E5E5E5"> is that the attacker only</font>

86
00:03:17,970 --> 00:03:23,459
sees encrypted data and this is achieved

87
00:03:21,120 --> 00:03:26,640
by<font color="#CCCCCC"> having all the information</font><font color="#E5E5E5"> touched by</font>

88
00:03:23,459 --> 00:03:29,640
the program be<font color="#CCCCCC"> encrypted by a secret key</font>

89
00:03:26,640 --> 00:03:31,470
that<font color="#E5E5E5"> lives in the Enclave so this seems</font>

90
00:03:29,640 --> 00:03:33,000
too good to<font color="#E5E5E5"> be</font><font color="#CCCCCC"> true</font><font color="#E5E5E5"> right this solves</font>

91
00:03:31,470 --> 00:03:35,010
all the cryptographic<font color="#E5E5E5"> problems that we</font>

92
00:03:33,000 --> 00:03:38,310
faced<font color="#E5E5E5"> over the past</font><font color="#CCCCCC"> thirty years and</font>

93
00:03:35,010 --> 00:03:40,230
indeed modern<font color="#E5E5E5"> our lives have a drawback</font>

94
00:03:38,310 --> 00:03:42,540
<font color="#CCCCCC">they all suffer from some kind of size</font>

95
00:03:40,230 --> 00:03:44,609
<font color="#CCCCCC">and leakage one in particular that's</font>

96
00:03:42,540 --> 00:03:47,040
problematic<font color="#CCCCCC"> for us is that</font><font color="#E5E5E5"> enclaves leak</font>

97
00:03:44,610 --> 00:03:48,390
<font color="#E5E5E5">memory access patterns what this means</font>

98
00:03:47,040 --> 00:03:51,690
is that when the running program

99
00:03:48,390 --> 00:03:53,130
accesses some location<font color="#E5E5E5"> in</font><font color="#CCCCCC"> memory the</font>

100
00:03:51,690 --> 00:03:55,350
adversary can see which locations are

101
00:03:53,130 --> 00:03:56,970
accessed it can't see the contents of

102
00:03:55,350 --> 00:03:58,950
the memory<font color="#CCCCCC"> but it does know which</font>

103
00:03:56,970 --> 00:04:00,480
locations are accessed<font color="#E5E5E5"> and a bunch of</font>

104
00:03:58,950 --> 00:04:02,670
works of<font color="#E5E5E5"> the past</font><font color="#CCCCCC"> three years</font><font color="#E5E5E5"> have</font>

105
00:04:00,480 --> 00:04:04,518
exploited<font color="#E5E5E5"> this leakage to recover the</font>

106
00:04:02,670 --> 00:04:07,649
secrets<font color="#E5E5E5"> of the running program</font>

107
00:04:04,519 --> 00:04:11,070
<font color="#CCCCCC">ok so let's</font><font color="#E5E5E5"> put aside</font><font color="#CCCCCC"> for a moment</font><font color="#E5E5E5"> this</font>

108
00:04:07,650 --> 00:04:12,600
leakage<font color="#E5E5E5"> and see how we can</font><font color="#CCCCCC"> use these</font>

109
00:04:11,070 --> 00:04:15,600
enclaves<font color="#E5E5E5"> to solve the problems with</font>

110
00:04:12,600 --> 00:04:17,790
<font color="#CCCCCC">Aurra</font><font color="#E5E5E5"> we saw earlier</font><font color="#CCCCCC"> a key idea</font><font color="#E5E5E5"> is to</font>

111
00:04:15,600 --> 00:04:21,238
just run the<font color="#CCCCCC"> Oram client inside an</font>

112
00:04:17,790 --> 00:04:22,560
<font color="#CCCCCC">enclave</font><font color="#E5E5E5"> so now in this setup</font><font color="#CCCCCC"> there's or</font>

113
00:04:21,238 --> 00:04:26,729
<font color="#CCCCCC">I'm client running in</font><font color="#E5E5E5"> an enclave by the</font>

114
00:04:22,560 --> 00:04:28,919
server<font color="#E5E5E5"> and when a user makes a query the</font>

115
00:04:26,729 --> 00:04:31,200
on the client interacts with the index

116
00:04:28,919 --> 00:04:32,570
that's<font color="#E5E5E5"> living in server memory and sends</font>

117
00:04:31,200 --> 00:04:36,060
back<font color="#CCCCCC"> the</font><font color="#E5E5E5"> result to the user</font>

118
00:04:32,570 --> 00:04:37,800
<font color="#E5E5E5">this also problems earlier because for</font>

119
00:04:36,060 --> 00:04:39,539
example<font color="#E5E5E5"> we get low latency and bandwidth</font>

120
00:04:37,800 --> 00:04:39,820
because now there's<font color="#E5E5E5"> no interaction of at</font>

121
00:04:39,539 --> 00:04:41,560
all

122
00:04:39,820 --> 00:04:43,599
occurring over<font color="#E5E5E5"> the network all the</font>

123
00:04:41,560 --> 00:04:46,060
interaction is between<font color="#E5E5E5"> the</font><font color="#CCCCCC"> Enclave</font><font color="#E5E5E5"> and</font>

124
00:04:43,600 --> 00:04:47,890
the server's memory we also get<font color="#E5E5E5"> easy</font>

125
00:04:46,060 --> 00:04:49,120
support for multiple<font color="#CCCCCC"> users</font><font color="#E5E5E5"> because now</font>

126
00:04:47,890 --> 00:04:51,909
all<font color="#E5E5E5"> the different users can interact</font>

127
00:04:49,120 --> 00:04:53,710
<font color="#CCCCCC">with just one Enclave</font><font color="#E5E5E5"> which can enforce</font>

128
00:04:51,910 --> 00:04:55,840
the relevant access control policies

129
00:04:53,710 --> 00:05:00,580
<font color="#E5E5E5">without having to store any secret state</font>

130
00:04:55,840 --> 00:05:02,409
at any of the<font color="#CCCCCC"> users okay but here's</font>

131
00:05:00,580 --> 00:05:05,859
where<font color="#CCCCCC"> the side channel leakage comes</font>

132
00:05:02,410 --> 00:05:08,170
back to bite us<font color="#E5E5E5"> om is formulated in the</font>

133
00:05:05,860 --> 00:05:10,000
model where the Orem client lives at the

134
00:05:08,170 --> 00:05:11,500
<font color="#E5E5E5">user's</font><font color="#CCCCCC"> device and the adversary can't</font>

135
00:05:10,000 --> 00:05:14,380
see the inner<font color="#E5E5E5"> workings of this device</font>

136
00:05:11,500 --> 00:05:16,390
however<font color="#E5E5E5"> what we've done</font><font color="#CCCCCC"> now is taken the</font>

137
00:05:14,380 --> 00:05:18,520
client and put it in an<font color="#E5E5E5"> enclave and the</font>

138
00:05:16,390 --> 00:05:20,680
adversary can observe<font color="#E5E5E5"> the internal</font>

139
00:05:18,520 --> 00:05:23,620
lattices<font color="#CCCCCC"> of the client to its internal</font>

140
00:05:20,680 --> 00:05:25,390
data structures<font color="#CCCCCC"> to see how this</font><font color="#E5E5E5"> is a</font>

141
00:05:23,620 --> 00:05:28,570
problem<font color="#CCCCCC"> let's</font><font color="#E5E5E5"> look at a concrete or an</font>

142
00:05:25,390 --> 00:05:31,090
protocol namely path or am so in path

143
00:05:28,570 --> 00:05:32,830
<font color="#E5E5E5">Orem items are arranged in buckets and</font>

144
00:05:31,090 --> 00:05:39,099
these buckets themselves are arranged in

145
00:05:32,830 --> 00:05:40,570
<font color="#E5E5E5">the form</font><font color="#CCCCCC"> of a binary tree</font><font color="#E5E5E5"> and each item</font>

146
00:05:39,100 --> 00:05:41,830
<font color="#E5E5E5">is associated with the path in the</font>

147
00:05:40,570 --> 00:05:47,230
binary<font color="#E5E5E5"> tree</font><font color="#CCCCCC"> and lives in one</font><font color="#E5E5E5"> of the</font>

148
00:05:41,830 --> 00:05:49,719
buckets<font color="#E5E5E5"> along this path</font><font color="#CCCCCC"> so this</font><font color="#E5E5E5"> big know</font>

149
00:05:47,230 --> 00:05:51,220
that for a second now this mapping

150
00:05:49,720 --> 00:05:53,320
between items<font color="#CCCCCC"> to path is called</font><font color="#E5E5E5"> a</font>

151
00:05:51,220 --> 00:05:56,890
position map and usually it lives inside

152
00:05:53,320 --> 00:05:58,510
<font color="#E5E5E5">the Orem client</font><font color="#CCCCCC"> but there are various</font>

153
00:05:56,890 --> 00:05:59,979
<font color="#E5E5E5">techniques such as recursion or</font>

154
00:05:58,510 --> 00:06:02,710
oblivious data structures<font color="#CCCCCC"> that allow one</font>

155
00:05:59,980 --> 00:06:03,700
<font color="#CCCCCC">to get rid</font><font color="#E5E5E5"> of the position map without</font>

156
00:06:02,710 --> 00:06:06,609
<font color="#CCCCCC">having to worry</font><font color="#E5E5E5"> about</font>

157
00:06:03,700 --> 00:06:10,030
yeah but I'm too worried about it<font color="#E5E5E5"> so how</font>

158
00:06:06,610 --> 00:06:11,590
<font color="#CCCCCC">paths that they started</font><font color="#E5E5E5"> sorry the data</font>

159
00:06:10,030 --> 00:06:13,599
structure that<font color="#CCCCCC"> we do worry about is</font>

160
00:06:11,590 --> 00:06:17,530
called<font color="#E5E5E5"> the stash and this temporarily</font>

161
00:06:13,600 --> 00:06:19,240
holds<font color="#CCCCCC"> items between accesses so how</font>

162
00:06:17,530 --> 00:06:21,190
<font color="#E5E5E5">paths</font><font color="#CCCCCC"> or</font><font color="#E5E5E5"> a</font><font color="#CCCCCC"> much Eve's obliviousness</font><font color="#E5E5E5"> is</font>

163
00:06:19,240 --> 00:06:24,460
by enforcing<font color="#E5E5E5"> that whenever</font><font color="#CCCCCC"> I read an</font>

164
00:06:21,190 --> 00:06:27,010
<font color="#E5E5E5">item I have</font><font color="#CCCCCC"> to assign</font><font color="#E5E5E5"> it</font><font color="#CCCCCC"> to a new</font>

165
00:06:24,460 --> 00:06:29,289
different uniformly random path this

166
00:06:27,010 --> 00:06:30,820
ensures that now when I make<font color="#E5E5E5"> an access</font>

167
00:06:29,290 --> 00:06:32,380
for<font color="#E5E5E5"> the same</font><font color="#CCCCCC"> item twice</font><font color="#E5E5E5"> I'm not</font><font color="#CCCCCC"> to</font>

168
00:06:30,820 --> 00:06:34,740
saying independent parts and the

169
00:06:32,380 --> 00:06:37,690
adversary can't make any correlations

170
00:06:34,740 --> 00:06:41,260
<font color="#E5E5E5">okay so let's see how you can actually</font>

171
00:06:37,690 --> 00:06:42,820
read and write items in<font color="#E5E5E5"> path Orem so</font>

172
00:06:41,260 --> 00:06:44,920
let's say we found out that the item

173
00:06:42,820 --> 00:06:46,960
<font color="#E5E5E5">that we want</font><font color="#CCCCCC"> lives on path to</font><font color="#E5E5E5"> what we do</font>

174
00:06:44,920 --> 00:06:49,480
is we fetch path<font color="#CCCCCC"> two and add it to the</font>

175
00:06:46,960 --> 00:06:51,130
stash this is a data dependent process

176
00:06:49,480 --> 00:06:53,180
because the locations in the stash that

177
00:06:51,130 --> 00:06:54,800
<font color="#E5E5E5">we access depend on the contents</font>

178
00:06:53,180 --> 00:06:58,550
the past as well as<font color="#E5E5E5"> the item that we're</font>

179
00:06:54,800 --> 00:07:00,020
looking<font color="#E5E5E5"> at so</font><font color="#CCCCCC"> this is a data dependent</font>

180
00:06:58,550 --> 00:07:01,669
and<font color="#E5E5E5"> this gets even worse because now we</font>

181
00:07:00,020 --> 00:07:03,620
have to<font color="#CCCCCC"> look in</font><font color="#E5E5E5"> the stash to find the</font>

182
00:07:01,669 --> 00:07:07,639
item that<font color="#CCCCCC"> you want</font><font color="#E5E5E5"> to return to the user</font>

183
00:07:03,620 --> 00:07:09,080
so<font color="#CCCCCC"> rights are data dependent</font><font color="#E5E5E5"> what about</font>

184
00:07:07,639 --> 00:07:11,330
I mean sorry reads the data dependent

185
00:07:09,080 --> 00:07:12,949
what about rights in<font color="#E5E5E5"> rights</font><font color="#CCCCCC"> you</font>

186
00:07:11,330 --> 00:07:14,750
<font color="#CCCCCC">basically conduct this process in</font>

187
00:07:12,949 --> 00:07:16,759
Reverse we look in the stash and try to

188
00:07:14,750 --> 00:07:18,320
construct buckets for the path that

189
00:07:16,759 --> 00:07:23,360
<font color="#CCCCCC">we're writing back</font><font color="#E5E5E5"> this is again data</font>

190
00:07:18,320 --> 00:07:24,800
dependent<font color="#E5E5E5"> okay so what we want</font><font color="#CCCCCC"> is</font><font color="#E5E5E5"> W</font>

191
00:07:23,360 --> 00:07:26,960
oblivious algorithms and this is the

192
00:07:24,800 --> 00:07:29,570
notion that<font color="#E5E5E5"> we introduced this roughly</font>

193
00:07:26,960 --> 00:07:31,820
means that whatever<font color="#CCCCCC"> internal accesses</font>

194
00:07:29,570 --> 00:07:34,789
the<font color="#CCCCCC"> Orem client makes to its</font><font color="#E5E5E5"> internal</font>

195
00:07:31,820 --> 00:07:37,130
<font color="#CCCCCC">structures</font><font color="#E5E5E5"> are data independent in our</font>

196
00:07:34,789 --> 00:07:40,520
case the<font color="#E5E5E5"> memory or the do structures</font>

197
00:07:37,130 --> 00:07:42,139
live<font color="#E5E5E5"> within the Enclave okay so let's</font>

198
00:07:40,520 --> 00:07:45,469
here's a road map of<font color="#CCCCCC"> how</font><font color="#E5E5E5"> objects builds</font>

199
00:07:42,139 --> 00:07:47,810
upon constructs and builds upon W

200
00:07:45,470 --> 00:07:51,740
oblivious algorithms<font color="#E5E5E5"> first we construct</font>

201
00:07:47,810 --> 00:07:53,780
W oblivious<font color="#CCCCCC"> path</font><font color="#E5E5E5"> Ora or path</font><font color="#CCCCCC"> durum next</font>

202
00:07:51,740 --> 00:07:54,979
on top of this we construct W oblivious

203
00:07:53,780 --> 00:07:57,080
data structures<font color="#CCCCCC"> to</font><font color="#E5E5E5"> get rid of the</font>

204
00:07:54,979 --> 00:07:58,520
position map and finally we construct

205
00:07:57,080 --> 00:08:01,550
objects by constructing<font color="#CCCCCC"> a doubly</font>

206
00:07:58,520 --> 00:08:02,960
oblivious index on top of this in the

207
00:08:01,550 --> 00:08:05,330
rest of<font color="#CCCCCC"> this talk</font><font color="#E5E5E5"> I'm going to focus on</font>

208
00:08:02,960 --> 00:08:06,560
<font color="#E5E5E5">path Durham for</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> other thing for</font><font color="#CCCCCC"> the</font>

209
00:08:05,330 --> 00:08:10,639
<font color="#E5E5E5">other two</font><font color="#CCCCCC"> I recommend you look</font><font color="#E5E5E5"> at the</font>

210
00:08:06,560 --> 00:08:15,349
paper<font color="#E5E5E5"> okay so let's see how we can make</font>

211
00:08:10,639 --> 00:08:17,539
<font color="#E5E5E5">path or am oblivious</font><font color="#CCCCCC"> or w oblivious the</font>

212
00:08:15,349 --> 00:08:19,550
simplest way to do this is to<font color="#CCCCCC"> make all</font>

213
00:08:17,539 --> 00:08:21,800
stash accesses linear scans these

214
00:08:19,550 --> 00:08:24,050
inherently become data independent now

215
00:08:21,800 --> 00:08:26,120
<font color="#E5E5E5">however</font><font color="#CCCCCC"> this is lacking</font><font color="#E5E5E5"> in terms of</font>

216
00:08:24,050 --> 00:08:28,190
performance<font color="#CCCCCC"> if you have n items then</font>

217
00:08:26,120 --> 00:08:30,139
<font color="#CCCCCC">path or M says the stash size is log n</font>

218
00:08:28,190 --> 00:08:33,679
<font color="#E5E5E5">and then the complexity of a single</font>

219
00:08:30,139 --> 00:08:35,570
access<font color="#E5E5E5"> particular the</font><font color="#CCCCCC"> write</font><font color="#E5E5E5"> becomes the</font>

220
00:08:33,679 --> 00:08:37,458
stash size times<font color="#CCCCCC"> the path length and</font>

221
00:08:35,570 --> 00:08:42,680
<font color="#E5E5E5">this is quadratic in the star size or</font>

222
00:08:37,458 --> 00:08:45,170
<font color="#E5E5E5">off</font><font color="#CCCCCC"> logs whether we improve upon this by</font>

223
00:08:42,679 --> 00:08:47,930
making<font color="#E5E5E5"> a key observation</font><font color="#CCCCCC"> the idea is</font>

224
00:08:45,170 --> 00:08:49,760
that<font color="#E5E5E5"> when you read a path you get not</font>

225
00:08:47,930 --> 00:08:52,489
only the item that<font color="#E5E5E5"> you wanted but also</font>

226
00:08:49,760 --> 00:08:55,910
these<font color="#E5E5E5"> other items</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> are irrelevant</font><font color="#CCCCCC"> to</font>

227
00:08:52,490 --> 00:08:58,250
your<font color="#E5E5E5"> query for the more you're only</font>

228
00:08:55,910 --> 00:09:00,319
<font color="#E5E5E5">really reassigning the single item</font><font color="#CCCCCC"> that</font>

229
00:08:58,250 --> 00:09:02,089
<font color="#CCCCCC">he requested all the other items already</font>

230
00:09:00,320 --> 00:09:04,610
live in<font color="#E5E5E5"> the correct buckets so we don't</font>

231
00:09:02,089 --> 00:09:06,560
need to<font color="#E5E5E5"> reassign them we take advantage</font>

232
00:09:04,610 --> 00:09:07,480
<font color="#CCCCCC">of this by splitting</font><font color="#E5E5E5"> the stash into two</font>

233
00:09:06,560 --> 00:09:11,449
paths

234
00:09:07,480 --> 00:09:13,820
the first called blocks<font color="#E5E5E5"> holds only those</font>

235
00:09:11,450 --> 00:09:15,130
items<font color="#CCCCCC"> that we specifically</font><font color="#E5E5E5"> requested not</font>

236
00:09:13,820 --> 00:09:17,389
the extraneous ones

237
00:09:15,130 --> 00:09:21,200
whereas buckets holds these extraneous

238
00:09:17,389 --> 00:09:23,209
items<font color="#E5E5E5"> and the key</font><font color="#CCCCCC"> observation is that</font>

239
00:09:21,200 --> 00:09:24,010
<font color="#E5E5E5">the size of buckets is much</font><font color="#CCCCCC"> greater</font><font color="#E5E5E5"> than</font>

240
00:09:23,209 --> 00:09:26,569
the<font color="#E5E5E5"> size of blocks</font>

241
00:09:24,010 --> 00:09:28,069
besides the buckets is log n which is

242
00:09:26,570 --> 00:09:29,810
the<font color="#E5E5E5"> size of the path whereas blocks</font>

243
00:09:28,070 --> 00:09:32,329
consists of one<font color="#CCCCCC"> or two items that</font><font color="#E5E5E5"> you</font>

244
00:09:29,810 --> 00:09:34,849
specifically requested so let's see how

245
00:09:32,329 --> 00:09:38,149
<font color="#E5E5E5">you can perform a read in this new</font>

246
00:09:34,850 --> 00:09:40,430
architecture<font color="#CCCCCC"> as before we</font><font color="#E5E5E5"> get the part</font>

247
00:09:38,149 --> 00:09:42,829
<font color="#E5E5E5">from the server</font><font color="#CCCCCC"> but before</font><font color="#E5E5E5"> we insert it</font>

248
00:09:40,430 --> 00:09:45,410
into<font color="#E5E5E5"> our stash we scan the path and</font>

249
00:09:42,829 --> 00:09:48,199
replace the<font color="#CCCCCC"> item that we wanted with a</font>

250
00:09:45,410 --> 00:09:50,380
dummy item this<font color="#E5E5E5"> is</font><font color="#CCCCCC"> data independent</font>

251
00:09:48,199 --> 00:09:53,870
because we're<font color="#E5E5E5"> doing this via linear scan</font>

252
00:09:50,380 --> 00:09:56,149
<font color="#E5E5E5">next we take this explicit explicitly</font>

253
00:09:53,870 --> 00:09:57,860
requested<font color="#E5E5E5"> item and added</font><font color="#CCCCCC"> to blocks</font><font color="#E5E5E5"> again</font>

254
00:09:56,149 --> 00:10:01,339
we are<font color="#E5E5E5"> linear scan so this is again data</font>

255
00:09:57,860 --> 00:10:03,529
dependent next we<font color="#E5E5E5"> add this modified path</font>

256
00:10:01,339 --> 00:10:05,269
to buckets<font color="#E5E5E5"> but this step doesn't have to</font>

257
00:10:03,529 --> 00:10:06,680
be done in a data independent manner

258
00:10:05,269 --> 00:10:11,000
<font color="#E5E5E5">because the adversary</font><font color="#CCCCCC"> knows exactly</font>

259
00:10:06,680 --> 00:10:12,680
which buckets<font color="#E5E5E5"> be requested finally to</font>

260
00:10:11,000 --> 00:10:15,230
<font color="#CCCCCC">return the item to the user we scan</font>

261
00:10:12,680 --> 00:10:17,839
<font color="#E5E5E5">blocks again and return the item this</font><font color="#CCCCCC"> is</font>

262
00:10:15,230 --> 00:10:20,269
<font color="#E5E5E5">again data independent</font><font color="#CCCCCC"> ok so this</font><font color="#E5E5E5"> is</font>

263
00:10:17,839 --> 00:10:23,480
good we've made reads data independent

264
00:10:20,269 --> 00:10:26,510
<font color="#E5E5E5">what about right</font><font color="#CCCCCC"> backs</font><font color="#E5E5E5"> so the idea is</font>

265
00:10:23,480 --> 00:10:29,930
not<font color="#E5E5E5"> too complex</font><font color="#CCCCCC"> what we do is for each</font>

266
00:10:26,510 --> 00:10:31,250
<font color="#E5E5E5">item in blocks we have</font><font color="#CCCCCC"> to rescan the</font>

267
00:10:29,930 --> 00:10:35,420
<font color="#E5E5E5">platter</font><font color="#CCCCCC"> to writing</font><font color="#E5E5E5"> back</font><font color="#CCCCCC"> and figure out</font>

268
00:10:31,250 --> 00:10:38,420
which bucket<font color="#CCCCCC"> the block can fit in this</font>

269
00:10:35,420 --> 00:10:40,219
gives us a time complexity<font color="#CCCCCC"> of size of</font>

270
00:10:38,420 --> 00:10:42,079
blocks<font color="#E5E5E5"> time size of buckets which is</font>

271
00:10:40,220 --> 00:10:44,720
much better<font color="#E5E5E5"> than the naive</font><font color="#CCCCCC"> version which</font>

272
00:10:42,079 --> 00:10:48,439
has complexity<font color="#E5E5E5"> size of buckets squared</font>

273
00:10:44,720 --> 00:10:50,029
and this<font color="#CCCCCC"> is</font><font color="#E5E5E5"> also data independent</font><font color="#CCCCCC"> ok so</font>

274
00:10:48,440 --> 00:10:52,069
now<font color="#E5E5E5"> the good we've made raids and writes</font>

275
00:10:50,029 --> 00:10:54,230
data independent but let's see<font color="#CCCCCC"> if</font><font color="#E5E5E5"> we can</font>

276
00:10:52,069 --> 00:10:56,060
<font color="#E5E5E5">improve the performance more and how we</font>

277
00:10:54,230 --> 00:10:59,260
do<font color="#E5E5E5"> this is by getting rid of linear</font>

278
00:10:56,060 --> 00:11:01,219
scans inside<font color="#CCCCCC"> right backs instead we</font><font color="#E5E5E5"> use</font>

279
00:10:59,260 --> 00:11:05,120
<font color="#E5E5E5">cleverly designed oblivious</font><font color="#CCCCCC"> thoughts</font>

280
00:11:01,220 --> 00:11:07,660
<font color="#E5E5E5">which ensure that the items</font><font color="#CCCCCC"> and blocks</font>

281
00:11:05,120 --> 00:11:10,880
<font color="#E5E5E5">go into the relevant empty slots</font>

282
00:11:07,660 --> 00:11:13,370
<font color="#E5E5E5">efficiently so let's see how this</font>

283
00:11:10,880 --> 00:11:15,980
improves our<font color="#CCCCCC"> runtime so if you have a</font>

284
00:11:13,370 --> 00:11:18,319
stash<font color="#E5E5E5"> size s then the naive algorithm</font>

285
00:11:15,980 --> 00:11:20,779
has as I said<font color="#E5E5E5"> runtime quadratic in s</font>

286
00:11:18,319 --> 00:11:22,819
over squared but<font color="#E5E5E5"> obliques has time</font>

287
00:11:20,779 --> 00:11:24,980
takes time<font color="#CCCCCC"> s</font><font color="#E5E5E5"> log sweaters which is just</font>

288
00:11:22,820 --> 00:11:26,930
<font color="#CCCCCC">quasi-linear and this is reflected in</font>

289
00:11:24,980 --> 00:11:29,329
<font color="#CCCCCC">our evaluation so be implemented and</font>

290
00:11:26,930 --> 00:11:31,519
evaluated this where we see that for a

291
00:11:29,329 --> 00:11:34,040
single<font color="#E5E5E5"> read</font><font color="#CCCCCC"> plus write</font><font color="#E5E5E5"> when the Durham</font>

292
00:11:31,519 --> 00:11:36,019
is operating<font color="#CCCCCC"> and recursive mode takes</font>

293
00:11:34,040 --> 00:11:40,430
two milliseconds for naive<font color="#E5E5E5"> but only 0.5</font>

294
00:11:36,019 --> 00:11:42,620
milliseconds for objects for the move we

295
00:11:40,430 --> 00:11:44,449
also designed a new algorithm<font color="#E5E5E5"> for</font>

296
00:11:42,620 --> 00:11:47,560
initializing<font color="#E5E5E5"> the index for</font><font color="#CCCCCC"> loading data</font>

297
00:11:44,449 --> 00:11:50,029
<font color="#E5E5E5">into it because an ID method of just</font>

298
00:11:47,560 --> 00:11:52,670
performing a read<font color="#CCCCCC"> plus write for every</font>

299
00:11:50,029 --> 00:11:55,490
item<font color="#CCCCCC"> that we want to insert is way too</font>

300
00:11:52,670 --> 00:11:58,790
slow<font color="#CCCCCC"> it takes</font><font color="#E5E5E5"> over</font><font color="#CCCCCC"> ten</font><font color="#E5E5E5"> minutes for even</font>

301
00:11:55,490 --> 00:12:00,910
small like<font color="#CCCCCC"> 65,000</font><font color="#E5E5E5"> items and since our</font>

302
00:11:58,790 --> 00:12:03,980
experiments<font color="#CCCCCC"> we wanted to evaluate</font>

303
00:12:00,910 --> 00:12:05,779
obliques on millions<font color="#E5E5E5"> of items</font><font color="#CCCCCC"> this would</font>

304
00:12:03,980 --> 00:12:08,389
just<font color="#E5E5E5"> have been infeasible so we designed</font>

305
00:12:05,779 --> 00:12:09,980
a new algorithm that takes<font color="#E5E5E5"> only two</font>

306
00:12:08,389 --> 00:12:14,300
seconds to<font color="#CCCCCC"> perform this initialization</font>

307
00:12:09,980 --> 00:12:17,000
<font color="#E5E5E5">and this yeah so we have a the gap grows</font>

308
00:12:14,300 --> 00:12:21,949
even<font color="#E5E5E5"> further as the number of items we</font>

309
00:12:17,000 --> 00:12:24,260
insert increases<font color="#E5E5E5"> okay so now we've</font>

310
00:12:21,949 --> 00:12:26,000
<font color="#E5E5E5">discussed objects in our paper we also</font>

311
00:12:24,260 --> 00:12:28,699
evaluated objects<font color="#E5E5E5"> and three applications</font>

312
00:12:26,000 --> 00:12:30,139
<font color="#CCCCCC">and in this</font><font color="#E5E5E5"> and the rest of the talk I'm</font>

313
00:12:28,699 --> 00:12:34,670
<font color="#CCCCCC">going to talk about one specific</font><font color="#E5E5E5"> one</font>

314
00:12:30,139 --> 00:12:36,459
namely signal contact discovery<font color="#E5E5E5"> okay so</font>

315
00:12:34,670 --> 00:12:39,319
<font color="#E5E5E5">signal is a secure messaging app and</font>

316
00:12:36,459 --> 00:12:43,339
when<font color="#CCCCCC"> users sign</font><font color="#E5E5E5"> up for signal they have</font>

317
00:12:39,319 --> 00:12:45,800
to discover which of their which of the

318
00:12:43,339 --> 00:12:48,589
contacts are<font color="#CCCCCC"> also signal users currently</font>

319
00:12:45,800 --> 00:12:51,079
<font color="#E5E5E5">how signal does this is by having</font><font color="#CCCCCC"> the</font>

320
00:12:48,589 --> 00:12:53,300
users upload their contact list<font color="#E5E5E5"> to an</font>

321
00:12:51,079 --> 00:12:55,219
<font color="#E5E5E5">enclave on their servers</font><font color="#CCCCCC"> the Enclave</font>

322
00:12:53,300 --> 00:13:00,260
then for each contact in the users list

323
00:12:55,220 --> 00:13:01,519
<font color="#CCCCCC">scans the list of signal users and finds</font>

324
00:13:00,260 --> 00:13:05,750
the intersection and<font color="#E5E5E5"> sends it back to</font>

325
00:13:01,519 --> 00:13:07,970
<font color="#CCCCCC">the to the</font><font color="#E5E5E5"> client to</font><font color="#CCCCCC"> the new user</font><font color="#E5E5E5"> this</font>

326
00:13:05,750 --> 00:13:09,649
is linear in the<font color="#E5E5E5"> runtime of the database</font>

327
00:13:07,970 --> 00:13:12,139
in the size of<font color="#E5E5E5"> the database</font><font color="#CCCCCC"> as well as</font>

328
00:13:09,649 --> 00:13:13,550
the size<font color="#E5E5E5"> of the contact list since</font>

329
00:13:12,139 --> 00:13:16,940
objects has better performance

330
00:13:13,550 --> 00:13:20,689
it only takes logarithmic<font color="#E5E5E5"> asides of the</font>

331
00:13:16,940 --> 00:13:23,269
<font color="#E5E5E5">users database and the size of the sorry</font>

332
00:13:20,690 --> 00:13:25,069
<font color="#E5E5E5">signal user database we decided to</font>

333
00:13:23,269 --> 00:13:27,829
perform<font color="#E5E5E5"> the search using objects and</font>

334
00:13:25,069 --> 00:13:30,579
evaluate<font color="#E5E5E5"> how</font><font color="#CCCCCC"> long it takes what</font><font color="#E5E5E5"> we found</font>

335
00:13:27,829 --> 00:13:33,140
is that<font color="#E5E5E5"> for for an initial</font><font color="#CCCCCC"> sign up</font>

336
00:13:30,579 --> 00:13:34,250
signal signals approach is already

337
00:13:33,140 --> 00:13:36,080
slower than

338
00:13:34,250 --> 00:13:39,260
this<font color="#E5E5E5"> is approach for only 18 million</font>

339
00:13:36,080 --> 00:13:41,090
users<font color="#E5E5E5"> even</font><font color="#CCCCCC"> better in</font><font color="#E5E5E5"> the steady state</font>

340
00:13:39,260 --> 00:13:43,280
case of when a user has<font color="#CCCCCC"> already signed</font>

341
00:13:41,090 --> 00:13:45,280
<font color="#E5E5E5">up and they're only adding a new contact</font>

342
00:13:43,280 --> 00:13:47,900
to<font color="#E5E5E5"> their list</font>

343
00:13:45,280 --> 00:13:51,560
our approach<font color="#E5E5E5"> obliques is already better</font>

344
00:13:47,900 --> 00:13:54,890
<font color="#E5E5E5">than signals approach for just 500,000</font>

345
00:13:51,560 --> 00:14:01,250
<font color="#E5E5E5">users and this gap only grows as more</font>

346
00:13:54,890 --> 00:14:06,110
users<font color="#CCCCCC"> join the</font><font color="#E5E5E5"> system</font><font color="#CCCCCC"> ok yes so in</font>

347
00:14:01,250 --> 00:14:07,910
conclusion I presented objects which<font color="#E5E5E5"> is</font>

348
00:14:06,110 --> 00:14:12,380
<font color="#CCCCCC">inefficient oblivious search index I</font><font color="#E5E5E5"> me</font>

349
00:14:07,910 --> 00:14:15,199
demonstrated its application<font color="#CCCCCC"> to its we</font>

350
00:14:12,380 --> 00:14:27,860
applied it to<font color="#E5E5E5"> three applications all</font>

351
00:14:15,200 --> 00:14:30,830
right<font color="#E5E5E5"> thank you we have some time</font><font color="#CCCCCC"> to for</font>

352
00:14:27,860 --> 00:14:32,890
a few questions<font color="#CCCCCC"> any question from</font><font color="#E5E5E5"> the</font>

353
00:14:30,830 --> 00:14:32,890
audience

354
00:14:33,130 --> 00:14:38,750
well I<font color="#E5E5E5"> can start with a question</font>

355
00:14:36,320 --> 00:14:41,300
do<font color="#CCCCCC"> you want to take this opportunity to</font>

356
00:14:38,750 --> 00:14:43,730
compare<font color="#E5E5E5"> we</font><font color="#CCCCCC"> want take</font><font color="#E5E5E5"> the opportunity to</font>

357
00:14:41,300 --> 00:14:46,370
compare a<font color="#E5E5E5"> little</font><font color="#CCCCCC"> bit with</font><font color="#E5E5E5"> zero trees</font>

358
00:14:43,730 --> 00:14:52,820
which was a paper publishing and<font color="#E5E5E5"> the SS</font>

359
00:14:46,370 --> 00:14:54,290
<font color="#E5E5E5">it's 2018</font><font color="#CCCCCC"> yes oh and ESS also has</font><font color="#E5E5E5"> W</font>

360
00:14:52,820 --> 00:14:56,839
oblivious path or and they don't call it

361
00:14:54,290 --> 00:14:58,370
<font color="#E5E5E5">as such but they</font><font color="#CCCCCC"> employ</font><font color="#E5E5E5"> the linear scan</font>

362
00:14:56,839 --> 00:15:01,100
strategy the<font color="#CCCCCC"> naive version that I</font>

363
00:14:58,370 --> 00:15:02,870
introduced<font color="#CCCCCC"> in the in the talk</font><font color="#E5E5E5"> so their</font>

364
00:15:01,100 --> 00:15:05,000
performance is<font color="#CCCCCC"> over squared on the stash</font>

365
00:15:02,870 --> 00:15:07,280
size and actually the numbers that<font color="#E5E5E5"> are</font>

366
00:15:05,000 --> 00:15:11,360
compared against on the in the valuation

367
00:15:07,280 --> 00:15:13,880
for<font color="#E5E5E5"> optics are against zero trace and so</font>

368
00:15:11,360 --> 00:15:16,160
they also implemented<font color="#E5E5E5"> circuit</font><font color="#CCCCCC"> Aram but</font>

369
00:15:13,880 --> 00:15:17,570
we found<font color="#E5E5E5"> that our implementation of W</font>

370
00:15:16,160 --> 00:15:21,880
oblivious<font color="#CCCCCC"> ram is already faster than</font>

371
00:15:17,570 --> 00:15:25,490
circuit around<font color="#CCCCCC"> as</font><font color="#E5E5E5"> well okay thank you</font>

372
00:15:21,880 --> 00:15:37,010
yeah hello<font color="#CCCCCC"> actually</font><font color="#E5E5E5"> I was from Oregon</font>

373
00:15:25,490 --> 00:15:38,630
State University<font color="#CCCCCC"> to even improve the</font>

374
00:15:37,010 --> 00:15:42,020
benefits of what you have done<font color="#CCCCCC"> with Pat</font>

375
00:15:38,630 --> 00:15:43,580
<font color="#CCCCCC">oh</font><font color="#E5E5E5"> yes certainly possible one thing to</font>

376
00:15:42,020 --> 00:15:46,069
keep in mind<font color="#E5E5E5"> is that circuit</font><font color="#CCCCCC"> Aram was</font>

377
00:15:43,580 --> 00:15:47,960
formulated<font color="#E5E5E5"> in</font><font color="#CCCCCC"> the model</font><font color="#E5E5E5"> for MPC where</font>

378
00:15:46,070 --> 00:15:49,880
the cost of computation is much higher

379
00:15:47,960 --> 00:15:51,770
than the cost of communication so what

380
00:15:49,880 --> 00:15:56,390
<font color="#E5E5E5">circular</font><font color="#CCCCCC"> RAM does</font><font color="#E5E5E5"> is you have I</font><font color="#CCCCCC"> think to</font>

381
00:15:51,770 --> 00:15:57,290
iOS<font color="#CCCCCC"> per logical access</font><font color="#E5E5E5"> but in our model</font>

382
00:15:56,390 --> 00:15:58,850
<font color="#E5E5E5">we're running in an</font><font color="#CCCCCC"> autoclave</font>

383
00:15:57,290 --> 00:16:00,290
<font color="#E5E5E5">computation is like super cheap</font>

384
00:15:58,850 --> 00:16:03,710
it's just native execution so the cost

385
00:16:00,290 --> 00:16:05,870
of<font color="#CCCCCC"> i/o goes up relatively so it's</font>

386
00:16:03,710 --> 00:16:08,150
certainly<font color="#E5E5E5"> possible that we could apply</font>

387
00:16:05,870 --> 00:16:09,470
techniques<font color="#E5E5E5"> to circuit or Ram as well but</font>

388
00:16:08,150 --> 00:16:11,959
I'm<font color="#E5E5E5"> not sure if like the performance</font>

389
00:16:09,470 --> 00:16:14,240
would improve and when we<font color="#CCCCCC"> compared</font><font color="#E5E5E5"> it</font>

390
00:16:11,960 --> 00:16:15,620
against<font color="#E5E5E5"> zero trace which does implement</font>

391
00:16:14,240 --> 00:16:18,140
circuit<font color="#CCCCCC"> around we found</font><font color="#E5E5E5"> that our</font>

392
00:16:15,620 --> 00:16:19,400
approach<font color="#E5E5E5"> was still faster than the</font>

393
00:16:18,140 --> 00:16:22,069
circuit<font color="#CCCCCC"> or Ram</font><font color="#E5E5E5"> that they implemented</font>

394
00:16:19,400 --> 00:16:24,260
<font color="#E5E5E5">okay and one last question is so you are</font>

395
00:16:22,070 --> 00:16:28,130
also using<font color="#E5E5E5"> your</font><font color="#CCCCCC"> mouse to use your model</font>

396
00:16:24,260 --> 00:16:30,319
with access control what kind of data

397
00:16:28,130 --> 00:16:32,120
structure<font color="#CCCCCC"> do you have used and how did</font>

398
00:16:30,320 --> 00:16:34,700
you throw<font color="#CCCCCC"> and/or am on</font><font color="#E5E5E5"> that access</font>

399
00:16:32,120 --> 00:16:36,020
<font color="#E5E5E5">control data structure because I don't</font>

400
00:16:34,700 --> 00:16:40,240
know if you store your access control

401
00:16:36,020 --> 00:16:44,030
data structure in in<font color="#E5E5E5"> claim or outside</font>

402
00:16:40,240 --> 00:16:45,920
how did you handle<font color="#E5E5E5"> Oram on that so we</font>

403
00:16:44,030 --> 00:16:47,959
just<font color="#E5E5E5"> enforce access controls inside the</font>

404
00:16:45,920 --> 00:16:50,120
Enclave Enclave is responsible for<font color="#E5E5E5"> the</font>

405
00:16:47,960 --> 00:16:51,710
access control policies<font color="#E5E5E5"> you just write</font>

406
00:16:50,120 --> 00:16:53,360
<font color="#E5E5E5">your</font><font color="#CCCCCC"> native code and</font><font color="#E5E5E5"> execute it inside</font>

407
00:16:51,710 --> 00:16:55,220
the Enclave I see<font color="#E5E5E5"> we don't</font><font color="#CCCCCC"> have</font>

408
00:16:53,360 --> 00:16:56,960
additional cryptography on top it it

409
00:16:55,220 --> 00:16:58,430
might<font color="#E5E5E5"> be</font><font color="#CCCCCC"> possible to layer it but</font><font color="#E5E5E5"> we</font>

410
00:16:56,960 --> 00:17:04,220
didn't consider<font color="#CCCCCC"> it in this in</font><font color="#E5E5E5"> this work</font>

411
00:16:58,430 --> 00:17:05,599
<font color="#E5E5E5">I see</font><font color="#CCCCCC"> okay thank you thank you question</font>

412
00:17:04,220 --> 00:17:07,940
about<font color="#E5E5E5"> the overheads</font>

413
00:17:05,599 --> 00:17:10,040
<font color="#E5E5E5">wait where's the the the bottleneck is</font>

414
00:17:07,940 --> 00:17:11,630
it have<font color="#E5E5E5"> you compared the W oblivious</font>

415
00:17:10,040 --> 00:17:14,690
with your previous<font color="#CCCCCC"> one is the bottleneck</font>

416
00:17:11,630 --> 00:17:18,410
<font color="#E5E5E5">in the the scanning you are introducing</font>

417
00:17:14,690 --> 00:17:21,410
or is it<font color="#CCCCCC"> in the</font><font color="#E5E5E5"> so there's two overheads</font>

418
00:17:18,410 --> 00:17:23,510
the first<font color="#E5E5E5"> parameter uses its own</font>

419
00:17:21,410 --> 00:17:26,209
overhead<font color="#CCCCCC"> because you were reading these</font>

420
00:17:23,510 --> 00:17:28,040
additional items and you also have you

421
00:17:26,209 --> 00:17:29,600
<font color="#CCCCCC">can't like</font><font color="#E5E5E5"> really get high throughput</font>

422
00:17:28,040 --> 00:17:31,430
<font color="#E5E5E5">because there's not much concurrency</font>

423
00:17:29,600 --> 00:17:33,889
inherent in path or am there's one

424
00:17:31,430 --> 00:17:35,720
therapy<font color="#E5E5E5"> but compared to</font><font color="#CCCCCC"> pass or M our</font>

425
00:17:33,890 --> 00:17:38,630
system is also<font color="#CCCCCC"> a bit slower because we</font>

426
00:17:35,720 --> 00:17:40,550
have this we can't make data dependent

427
00:17:38,630 --> 00:17:42,530
accesses within the Enclave

428
00:17:40,550 --> 00:17:45,470
but that overhead is negligible compared

429
00:17:42,530 --> 00:17:51,050
<font color="#CCCCCC">to the cost of path or</font><font color="#E5E5E5"> M itself yeah</font>

430
00:17:45,470 --> 00:17:52,430
thank you<font color="#E5E5E5"> okay let's stand up Proteus</font>

431
00:17:51,050 --> 00:17:55,089
again thank you

432
00:17:52,430 --> 00:17:55,089
[Applause]

