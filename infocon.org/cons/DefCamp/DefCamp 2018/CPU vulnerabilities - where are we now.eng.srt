1
00:00:01,159 --> 00:00:08,730
remember the<font color="#E5E5E5"> first of January or the</font>

2
00:00:05,370 --> 00:00:11,490
second of January<font color="#E5E5E5"> for me this year began</font>

3
00:00:08,730 --> 00:00:16,859
<font color="#CCCCCC">with the huge news</font><font color="#E5E5E5"> online</font><font color="#CCCCCC"> I'm</font><font color="#E5E5E5"> sure</font>

4
00:00:11,490 --> 00:00:20,340
everybody here noticed it<font color="#E5E5E5"> some huge</font><font color="#CCCCCC"> CPU</font>

5
00:00:16,859 --> 00:00:23,699
vulnerabilities were published and my

6
00:00:20,340 --> 00:00:26,460
first reaction was oh my god<font color="#CCCCCC"> what to do</font>

7
00:00:23,699 --> 00:00:32,160
<font color="#E5E5E5">do I have to throw all my</font><font color="#CCCCCC"> computer's</font>

8
00:00:26,460 --> 00:00:35,660
away<font color="#E5E5E5"> are all my CPUs here vulnerable so</font>

9
00:00:32,159 --> 00:00:38,370
for<font color="#E5E5E5"> example is this AMD sempron CPU here</font>

10
00:00:35,660 --> 00:00:41,250
<font color="#E5E5E5">vulnerable yes it is</font>

11
00:00:38,370 --> 00:00:46,379
<font color="#E5E5E5">vulnerable to any kind of specter attack</font>

12
00:00:41,250 --> 00:00:47,309
<font color="#E5E5E5">or at least to most of them is this</font>

13
00:00:46,379 --> 00:00:53,610
Intel i5

14
00:00:47,309 --> 00:00:56,218
bull<font color="#E5E5E5"> nerado yes it is so I went to the</font>

15
00:00:53,610 --> 00:00:59,579
basement to<font color="#CCCCCC"> look into my old computer</font>

16
00:00:56,219 --> 00:01:01,350
stuff<font color="#E5E5E5"> and see if I can find a CPU that's</font>

17
00:00:59,579 --> 00:01:04,140
not<font color="#CCCCCC"> vulnerable because</font><font color="#E5E5E5"> I really wanted</font>

18
00:01:01,350 --> 00:01:08,100
to<font color="#E5E5E5"> make</font><font color="#CCCCCC"> sure I'm not the victim of some</font>

19
00:01:04,140 --> 00:01:14,840
meltdown or<font color="#CCCCCC"> specter attack</font><font color="#E5E5E5"> and I found</font>

20
00:01:08,100 --> 00:01:19,130
this<font color="#E5E5E5"> one it's an it's an X it's an AI</font>

21
00:01:14,840 --> 00:01:22,820
486 from oh my god

22
00:01:19,130 --> 00:01:30,020
98<font color="#CCCCCC"> the year I was</font><font color="#E5E5E5"> born so I don't really</font>

23
00:01:22,820 --> 00:01:31,169
can use this so what happened so far<font color="#CCCCCC"> in</font>

24
00:01:30,020 --> 00:01:34,500
January

25
00:01:31,170 --> 00:01:40,290
these attacks become known in February

26
00:01:34,500 --> 00:01:43,710
there were the first reports of<font color="#CCCCCC"> malware</font>

27
00:01:40,290 --> 00:01:45,960
<font color="#E5E5E5">that already experimentally</font><font color="#CCCCCC"> tries</font><font color="#E5E5E5"> to</font>

28
00:01:43,710 --> 00:01:48,780
exploit these vulnerabilities<font color="#CCCCCC"> and we</font>

29
00:01:45,960 --> 00:01:52,199
didn't had by that time<font color="#E5E5E5"> proper</font>

30
00:01:48,780 --> 00:01:56,990
<font color="#CCCCCC">mitigations available and stable</font><font color="#E5E5E5"> in a</font>

31
00:01:52,200 --> 00:01:59,810
stable<font color="#CCCCCC"> way so the rest of the year a</font>

32
00:01:56,990 --> 00:02:04,169
bunch of<font color="#E5E5E5"> other</font><font color="#CCCCCC"> vulnerabilities</font><font color="#E5E5E5"> secured</font>

33
00:01:59,810 --> 00:02:07,649
so all of them are based on<font color="#E5E5E5"> the same</font>

34
00:02:04,170 --> 00:02:10,410
idea<font color="#E5E5E5"> of speculative execution</font><font color="#CCCCCC"> and hyper</font>

35
00:02:07,649 --> 00:02:12,210
<font color="#CCCCCC">threading the features that</font><font color="#E5E5E5"> make our</font>

36
00:02:10,410 --> 00:02:14,730
CPUs

37
00:02:12,210 --> 00:02:19,380
<font color="#E5E5E5">as fast as they are today</font><font color="#CCCCCC"> otherwise we</font>

38
00:02:14,730 --> 00:02:21,660
would be<font color="#E5E5E5"> back in</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> 90s</font><font color="#CCCCCC"> and right here</font>

39
00:02:19,380 --> 00:02:24,840
right<font color="#CCCCCC"> here</font><font color="#E5E5E5"> when I came here I had to</font>

40
00:02:21,660 --> 00:02:27,810
adapt my slides because<font color="#E5E5E5"> another it</font>

41
00:02:24,840 --> 00:02:31,800
<font color="#CCCCCC">bright was found it has not</font><font color="#E5E5E5"> yet the name</font>

42
00:02:27,810 --> 00:02:33,420
it's familiar to<font color="#CCCCCC"> Specter</font><font color="#E5E5E5"> and I haven't</font>

43
00:02:31,800 --> 00:02:37,050
had time<font color="#CCCCCC"> to</font><font color="#E5E5E5"> look into it</font>

44
00:02:33,420 --> 00:02:40,290
but we do need<font color="#E5E5E5"> to expect more such</font>

45
00:02:37,050 --> 00:02:42,480
vulnerabilities in the next few years<font color="#CCCCCC"> so</font>

46
00:02:40,290 --> 00:02:45,239
<font color="#CCCCCC">I really think they will accompany us</font>

47
00:02:42,480 --> 00:02:47,519
<font color="#CCCCCC">for a long time</font><font color="#E5E5E5"> because</font><font color="#CCCCCC"> that's of their</font>

48
00:02:45,240 --> 00:02:51,960
nature of their<font color="#E5E5E5"> hardware attacks which</font>

49
00:02:47,520 --> 00:02:54,480
cannot be<font color="#CCCCCC"> easily fixed</font><font color="#E5E5E5"> by software so</font>

50
00:02:51,960 --> 00:02:55,830
what is the impact<font color="#E5E5E5"> what can we do what</font>

51
00:02:54,480 --> 00:02:59,190
can attackers do with these

52
00:02:55,830 --> 00:03:02,160
vulnerabilities<font color="#E5E5E5"> first of all they allow</font>

53
00:02:59,190 --> 00:03:05,520
to extract arbitrary data for local

54
00:03:02,160 --> 00:03:07,620
attackers<font color="#E5E5E5"> that's not such a bad thing</font>

55
00:03:05,520 --> 00:03:11,600
<font color="#E5E5E5">because you still</font><font color="#CCCCCC"> need to have</font><font color="#E5E5E5"> localized</font>

56
00:03:07,620 --> 00:03:14,460
local killed execution on that<font color="#CCCCCC"> machine</font>

57
00:03:11,600 --> 00:03:18,299
but<font color="#E5E5E5"> there are proof-of-concept exploits</font>

58
00:03:14,460 --> 00:03:21,330
<font color="#E5E5E5">which exploit these attacks and these</font>

59
00:03:18,300 --> 00:03:23,730
<font color="#E5E5E5">vulnerabilities from JavaScript</font><font color="#CCCCCC"> so when</font>

60
00:03:21,330 --> 00:03:28,110
you go<font color="#E5E5E5"> to some websites it's pretty easy</font>

61
00:03:23,730 --> 00:03:33,899
to<font color="#E5E5E5"> inject some code by just by just</font>

62
00:03:28,110 --> 00:03:37,740
buying some advertising stuff and people

63
00:03:33,900 --> 00:03:39,800
load<font color="#E5E5E5"> your JavaScript code</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> worst of</font>

64
00:03:37,740 --> 00:03:42,480
all there is a<font color="#CCCCCC"> proof-of-concept</font>

65
00:03:39,800 --> 00:03:46,440
<font color="#E5E5E5">implementation that shows we can extract</font>

66
00:03:42,480 --> 00:03:48,959
<font color="#E5E5E5">data via CPU vulnerabilities via the</font>

67
00:03:46,440 --> 00:03:52,680
<font color="#CCCCCC">network so really remotely that's</font>

68
00:03:48,960 --> 00:03:56,850
possible so oh my god can<font color="#E5E5E5"> we trust the</font>

69
00:03:52,680 --> 00:04:03,240
memory can be trust our CPUs<font color="#CCCCCC"> or do we</font>

70
00:03:56,850 --> 00:04:07,230
<font color="#CCCCCC">have to go back to this old 486 who can</font>

71
00:04:03,240 --> 00:04:10,890
feel safe<font color="#E5E5E5"> well literally and practically</font>

72
00:04:07,230 --> 00:04:13,109
nobody<font color="#E5E5E5"> using modern computers</font><font color="#CCCCCC"> because</font>

73
00:04:10,890 --> 00:04:15,929
all of the of these computers use

74
00:04:13,110 --> 00:04:17,850
speculative execution<font color="#E5E5E5"> and</font><font color="#CCCCCC"> hyper varying</font>

75
00:04:15,930 --> 00:04:21,260
techniques<font color="#CCCCCC"> which make them so</font><font color="#E5E5E5"> fast but</font>

76
00:04:17,850 --> 00:04:24,300
<font color="#CCCCCC">also in</font><font color="#E5E5E5"> terms of data disclosure</font>

77
00:04:21,260 --> 00:04:25,530
<font color="#E5E5E5">insecure because</font><font color="#CCCCCC"> it's hardware</font><font color="#E5E5E5"> we're</font>

78
00:04:24,300 --> 00:04:29,910
dealing with heart of

79
00:04:25,530 --> 00:04:32,489
letís<font color="#E5E5E5"> any operating system</font><font color="#CCCCCC"> is affected</font>

80
00:04:29,910 --> 00:04:36,540
and any kind of computer because most of

81
00:04:32,490 --> 00:04:38,880
them are<font color="#E5E5E5"> used</font><font color="#CCCCCC"> arm AMD or Intel chips or</font>

82
00:04:36,540 --> 00:04:41,970
whatever<font color="#E5E5E5"> but even</font><font color="#CCCCCC"> your architecture is</font>

83
00:04:38,880 --> 00:04:46,290
like risk<font color="#CCCCCC"> 5a vulnerable to specter</font>

84
00:04:41,970 --> 00:04:48,389
attack<font color="#CCCCCC"> so the only thing we can</font><font color="#E5E5E5"> do is we</font>

85
00:04:46,290 --> 00:04:53,910
can't really<font color="#E5E5E5"> trust the memory so don't</font>

86
00:04:48,389 --> 00:04:57,450
trust the memory how can we fix CPU

87
00:04:53,910 --> 00:04:59,100
vulnerabilities<font color="#E5E5E5"> well we can throw all</font>

88
00:04:57,450 --> 00:05:02,280
our computers away all our

89
00:04:59,100 --> 00:05:06,240
infrastructure<font color="#CCCCCC"> that would be one</font><font color="#E5E5E5"> way but</font>

90
00:05:02,280 --> 00:05:09,840
we need reliable<font color="#CCCCCC"> replacements</font><font color="#E5E5E5"> and nobody</font>

91
00:05:06,240 --> 00:05:14,100
<font color="#E5E5E5">can guarantee</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> new fixes are really</font>

92
00:05:09,840 --> 00:05:17,849
out there<font color="#E5E5E5"> and are really working so we</font>

93
00:05:14,100 --> 00:05:20,790
need to find<font color="#E5E5E5"> software solutions so the</font>

94
00:05:17,850 --> 00:05:23,729
question I<font color="#E5E5E5"> asked myself is can</font><font color="#CCCCCC"> be fixed</font>

95
00:05:20,790 --> 00:05:26,880
<font color="#E5E5E5">this by using software</font><font color="#CCCCCC"> and I did some</font>

96
00:05:23,729 --> 00:05:30,960
research what how software<font color="#E5E5E5"> can fix</font>

97
00:05:26,880 --> 00:05:33,270
<font color="#CCCCCC">Hardware</font><font color="#E5E5E5"> errors</font><font color="#CCCCCC"> and this is where I this</font>

98
00:05:30,960 --> 00:05:36,450
is where<font color="#CCCCCC"> I landed</font><font color="#E5E5E5"> what I found</font><font color="#CCCCCC"> the</font>

99
00:05:33,270 --> 00:05:38,490
Hubble telescope<font color="#CCCCCC"> when they shatter when</font>

100
00:05:36,450 --> 00:05:44,000
they sent the Hubble telescope to space

101
00:05:38,490 --> 00:05:47,700
in the<font color="#E5E5E5"> mid 90s</font><font color="#CCCCCC"> they used a wrong mirror</font>

102
00:05:44,000 --> 00:05:51,180
so millions of dollars just<font color="#E5E5E5"> fired away</font>

103
00:05:47,700 --> 00:05:53,940
<font color="#E5E5E5">because there is a wrong mirror in this</font>

104
00:05:51,180 --> 00:05:55,190
in this telescope<font color="#CCCCCC"> the data is complete</font>

105
00:05:53,940 --> 00:05:59,160
<font color="#E5E5E5">completely useless</font>

106
00:05:55,190 --> 00:06:02,039
well what what did NASA engineers do the

107
00:05:59,160 --> 00:06:05,280
error is constant so we<font color="#CCCCCC"> can so they</font>

108
00:06:02,039 --> 00:06:08,400
<font color="#CCCCCC">wrote software that fixes</font><font color="#E5E5E5"> these error so</font>

109
00:06:05,280 --> 00:06:11,849
<font color="#E5E5E5">we can expect that software can fix and</font>

110
00:06:08,400 --> 00:06:18,060
prevent hardware attacks and have the

111
00:06:11,850 --> 00:06:21,300
vulnerabilities<font color="#E5E5E5"> as I said</font><font color="#CCCCCC"> before</font><font color="#E5E5E5"> remote</font>

112
00:06:18,060 --> 00:06:24,630
attacks are<font color="#CCCCCC"> possible</font><font color="#E5E5E5"> however their taxes</font>

113
00:06:21,300 --> 00:06:27,620
still have luckily some limitations

114
00:06:24,630 --> 00:06:31,590
<font color="#E5E5E5">first of all they</font><font color="#CCCCCC"> are very</font><font color="#E5E5E5"> difficult</font>

115
00:06:27,620 --> 00:06:35,220
<font color="#E5E5E5">many of these attacks just work</font><font color="#CCCCCC"> in the</font>

116
00:06:31,590 --> 00:06:38,400
<font color="#CCCCCC">laboratory from conditions and typically</font>

117
00:06:35,220 --> 00:06:39,840
<font color="#CCCCCC">usually in a average company Network</font>

118
00:06:38,400 --> 00:06:41,489
normal attack where

119
00:06:39,840 --> 00:06:43,888
just<font color="#CCCCCC"> conventional attack roaches like</font>

120
00:06:41,490 --> 00:06:47,400
<font color="#CCCCCC">offer overflows and all that stuff</font><font color="#E5E5E5"> you</font>

121
00:06:43,889 --> 00:06:53,160
<font color="#E5E5E5">guys</font><font color="#CCCCCC"> knows of</font><font color="#E5E5E5"> no</font><font color="#CCCCCC"> about these are much</font>

122
00:06:47,400 --> 00:06:55,530
more easier so and via<font color="#E5E5E5"> the network</font><font color="#CCCCCC"> how</font>

123
00:06:53,160 --> 00:06:58,500
do they work<font color="#CCCCCC"> over network</font><font color="#E5E5E5"> just under</font>

124
00:06:55,530 --> 00:07:01,469
laboratory conditions<font color="#CCCCCC"> not</font><font color="#E5E5E5"> really</font>

125
00:06:58,500 --> 00:07:03,690
<font color="#E5E5E5">reliable you need a tank</font><font color="#CCCCCC"> gigabyte line</font>

126
00:07:01,470 --> 00:07:05,880
and everything<font color="#CCCCCC"> directly connected the</font>

127
00:07:03,690 --> 00:07:08,790
timing<font color="#CCCCCC"> behavior must</font><font color="#E5E5E5"> be really</font>

128
00:07:05,880 --> 00:07:12,090
predictable<font color="#E5E5E5"> and really constant but</font>

129
00:07:08,790 --> 00:07:15,180
<font color="#CCCCCC">however it works</font><font color="#E5E5E5"> and the second factor</font>

130
00:07:12,090 --> 00:07:18,299
<font color="#CCCCCC">is</font><font color="#E5E5E5"> it's really really</font><font color="#CCCCCC"> slow only 15 bit</font>

131
00:07:15,180 --> 00:07:21,750
per hour on average but still<font color="#E5E5E5"> in the</font>

132
00:07:18,300 --> 00:07:25,729
local network<font color="#CCCCCC"> or via a very constant</font>

133
00:07:21,750 --> 00:07:31,020
internet connection<font color="#CCCCCC"> we could</font><font color="#E5E5E5"> extract</font><font color="#CCCCCC"> a</font>

134
00:07:25,729 --> 00:07:36,450
256 bit<font color="#CCCCCC"> key</font><font color="#E5E5E5"> in about</font><font color="#CCCCCC"> 7</font><font color="#E5E5E5"> 17 hours so</font>

135
00:07:31,020 --> 00:07:38,419
that's<font color="#E5E5E5"> not really acceptable and luckily</font>

136
00:07:36,450 --> 00:07:41,729
there are mitigations on the way

137
00:07:38,419 --> 00:07:44,430
<font color="#E5E5E5">operating system vendors</font><font color="#CCCCCC"> I mean in this</font>

138
00:07:41,729 --> 00:07:47,909
<font color="#CCCCCC">case</font><font color="#E5E5E5"> is Mac Windows Linux FreeBSD NetBSD</font>

139
00:07:44,430 --> 00:07:52,460
OpenBSD just any operating<font color="#E5E5E5"> system that</font>

140
00:07:47,910 --> 00:07:55,680
that<font color="#E5E5E5"> you expect to be used in a company</font>

141
00:07:52,460 --> 00:07:58,200
implemented mitigations from some of

142
00:07:55,680 --> 00:08:03,240
these<font color="#CCCCCC"> such analytics and cover general</font>

143
00:07:58,200 --> 00:08:08,430
attacks and part part of<font color="#E5E5E5"> the some</font><font color="#CCCCCC"> of</font>

144
00:08:03,240 --> 00:08:11,789
these mitigations<font color="#E5E5E5"> are not in the</font>

145
00:08:08,430 --> 00:08:14,099
operating<font color="#E5E5E5"> system but in the microcode of</font>

146
00:08:11,789 --> 00:08:16,669
the CPUs

147
00:08:14,099 --> 00:08:20,250
so there are firmware updates<font color="#E5E5E5"> which some</font>

148
00:08:16,669 --> 00:08:22,680
<font color="#E5E5E5">sometimes needs special handling because</font>

149
00:08:20,250 --> 00:08:25,260
not every operating<font color="#E5E5E5"> system does apply</font>

150
00:08:22,680 --> 00:08:28,169
them automatically<font color="#CCCCCC"> windows update</font><font color="#E5E5E5"> and</font>

151
00:08:25,260 --> 00:08:31,020
make updates<font color="#CCCCCC"> to them</font><font color="#E5E5E5"> so in these cases</font>

152
00:08:28,169 --> 00:08:33,390
you're safe but<font color="#CCCCCC"> on servers for example</font>

153
00:08:31,020 --> 00:08:35,490
you<font color="#E5E5E5"> need to be really careful that you</font>

154
00:08:33,390 --> 00:08:41,729
when updating<font color="#E5E5E5"> the</font><font color="#CCCCCC"> software that you</font>

155
00:08:35,490 --> 00:08:44,159
unable to micro code updates so a<font color="#E5E5E5"> short</font>

156
00:08:41,729 --> 00:08:48,810
<font color="#E5E5E5">overview about all these attacks and</font>

157
00:08:44,159 --> 00:08:50,569
available fixes<font color="#CCCCCC"> and how they work</font><font color="#E5E5E5"> I'm</font>

158
00:08:48,810 --> 00:08:54,079
not<font color="#CCCCCC"> going through all of them in detail</font>

159
00:08:50,570 --> 00:08:56,870
<font color="#E5E5E5">but all these which are orange</font>

160
00:08:54,080 --> 00:09:00,590
are not<font color="#E5E5E5"> really reliable fixes or have</font>

161
00:08:56,870 --> 00:09:04,760
<font color="#E5E5E5">serious performance issues for example</font>

162
00:09:00,590 --> 00:09:08,260
<font color="#CCCCCC">the spectre v2 attack</font><font color="#E5E5E5"> there is</font><font color="#CCCCCC"> a really</font>

163
00:09:04,760 --> 00:09:11,330
good defense<font color="#E5E5E5"> the red</font><font color="#CCCCCC"> line defends by</font>

164
00:09:08,260 --> 00:09:13,790
<font color="#E5E5E5">developed by Google that's really really</font>

165
00:09:11,330 --> 00:09:16,700
a great<font color="#E5E5E5"> defense and Google you used it</font>

166
00:09:13,790 --> 00:09:19,160
way long before meltdown<font color="#CCCCCC"> inspected</font><font color="#E5E5E5"> and</font>

167
00:09:16,700 --> 00:09:22,490
known publicly because<font color="#E5E5E5"> googling you</font>

168
00:09:19,160 --> 00:09:24,610
about these<font color="#CCCCCC"> vulnerabilities before and</font>

169
00:09:22,490 --> 00:09:27,770
they tested<font color="#E5E5E5"> it for half a year</font><font color="#CCCCCC"> and</font>

170
00:09:24,610 --> 00:09:30,800
<font color="#E5E5E5">perfectly works in the Google cloud but</font>

171
00:09:27,770 --> 00:09:34,520
Microsoft<font color="#E5E5E5"> tried to adapt it for Windows</font>

172
00:09:30,800 --> 00:09:37,280
and have until managed to<font color="#CCCCCC"> implement it</font>

173
00:09:34,520 --> 00:09:40,550
as<font color="#E5E5E5"> stable and state and on Windows it</font>

174
00:09:37,280 --> 00:09:42,650
has just about<font color="#CCCCCC"> 30 percent</font><font color="#E5E5E5"> of performance</font>

175
00:09:40,550 --> 00:09:44,959
impact<font color="#E5E5E5"> so this is the reason</font><font color="#CCCCCC"> why it's</font>

176
00:09:42,650 --> 00:09:47,660
not<font color="#E5E5E5"> yet implemented in Windows in the</font>

177
00:09:44,960 --> 00:09:52,790
within the<font color="#E5E5E5"> visual C++ compiler</font><font color="#CCCCCC"> or</font><font color="#E5E5E5"> C</font>

178
00:09:47,660 --> 00:09:56,360
compiler and still<font color="#E5E5E5"> even though we have</font>

179
00:09:52,790 --> 00:09:59,150
many defenses we can't really<font color="#E5E5E5"> know what</font>

180
00:09:56,360 --> 00:10:02,570
else we<font color="#E5E5E5"> must expect because side-channel</font>

181
00:09:59,150 --> 00:10:05,000
attacks are not not have not been

182
00:10:02,570 --> 00:10:09,050
<font color="#E5E5E5">considered</font><font color="#CCCCCC"> in</font><font color="#E5E5E5"> the design</font><font color="#CCCCCC"> of modern</font><font color="#E5E5E5"> CPUs</font>

183
00:10:05,000 --> 00:10:11,840
we must expect that more<font color="#E5E5E5"> of such attacks</font>

184
00:10:09,050 --> 00:10:16,490
will come so again<font color="#E5E5E5"> don't trust the</font>

185
00:10:11,840 --> 00:10:26,960
memory so how do<font color="#CCCCCC"> CPU vulnerabilities</font>

186
00:10:16,490 --> 00:10:29,150
work first some<font color="#E5E5E5"> basic terms there are</font>

187
00:10:26,960 --> 00:10:31,150
two important types of attacks

188
00:10:29,150 --> 00:10:34,130
<font color="#E5E5E5">the first one is</font><font color="#CCCCCC"> side-channel</font><font color="#E5E5E5"> attacks</font>

189
00:10:31,150 --> 00:10:38,150
<font color="#CCCCCC">what is the side channel</font><font color="#E5E5E5"> attack it's a</font>

190
00:10:34,130 --> 00:10:40,910
passive attack just extracting data in

191
00:10:38,150 --> 00:10:43,760
some way that<font color="#E5E5E5"> is not in Excel intended</font>

192
00:10:40,910 --> 00:10:45,829
<font color="#E5E5E5">one example is observing the caching</font>

193
00:10:43,760 --> 00:10:50,030
behavior<font color="#E5E5E5"> is something in the cache or</font>

194
00:10:45,830 --> 00:10:53,060
<font color="#CCCCCC">not or even</font><font color="#E5E5E5"> acoustic analysis so you can</font>

195
00:10:50,030 --> 00:10:54,980
<font color="#E5E5E5">really</font><font color="#CCCCCC"> literally</font><font color="#E5E5E5"> listen to CPUs and</font>

196
00:10:53,060 --> 00:10:57,920
based<font color="#E5E5E5"> on the acoustic</font><font color="#CCCCCC"> information you</font>

197
00:10:54,980 --> 00:11:02,300
get extract the keys of course<font color="#E5E5E5"> in such</font>

198
00:10:57,920 --> 00:11:04,880
cases<font color="#CCCCCC"> you need to be physically at at</font>

199
00:11:02,300 --> 00:11:06,770
the location<font color="#E5E5E5"> you</font><font color="#CCCCCC"> want attack</font><font color="#E5E5E5"> but I could</font>

200
00:11:04,880 --> 00:11:07,490
listen to<font color="#E5E5E5"> all</font><font color="#CCCCCC"> your CPUs and if you're</font>

201
00:11:06,770 --> 00:11:10,220
right

202
00:11:07,490 --> 00:11:12,649
and I might<font color="#CCCCCC"> be</font><font color="#E5E5E5"> able to extract some some</font>

203
00:11:10,220 --> 00:11:16,490
<font color="#CCCCCC">keys from here at the stage I don't do</font>

204
00:11:12,649 --> 00:11:19,550
it don't worry<font color="#CCCCCC"> and the other type of</font>

205
00:11:16,490 --> 00:11:22,430
<font color="#E5E5E5">attack is a</font><font color="#CCCCCC"> covered</font><font color="#E5E5E5"> channel the huge</font>

206
00:11:19,550 --> 00:11:24,890
difference from between<font color="#E5E5E5"> side channel</font>

207
00:11:22,430 --> 00:11:30,020
<font color="#E5E5E5">attacks and covered channel a Texas that</font>

208
00:11:24,890 --> 00:11:33,500
<font color="#CCCCCC">cavity</font><font color="#E5E5E5"> channels are active</font><font color="#CCCCCC"> so you abuse</font>

209
00:11:30,020 --> 00:11:36,050
<font color="#E5E5E5">some some computer system to get</font>

210
00:11:33,500 --> 00:11:40,040
<font color="#CCCCCC">information via a channel</font><font color="#E5E5E5"> that is not</font>

211
00:11:36,050 --> 00:11:43,219
intended for data communication or<font color="#E5E5E5"> put</font>

212
00:11:40,040 --> 00:11:47,089
data transfer<font color="#E5E5E5"> a classical</font><font color="#CCCCCC"> example is a</font>

213
00:11:43,220 --> 00:11:50,720
Trojan horse<font color="#E5E5E5"> where some attack were some</font>

214
00:11:47,089 --> 00:11:53,209
attacker<font color="#E5E5E5"> loads data or sends data in a</font>

215
00:11:50,720 --> 00:11:55,700
way not intended by system administrator

216
00:11:53,209 --> 00:12:00,109
<font color="#E5E5E5">or by the people who operate that system</font>

217
00:11:55,700 --> 00:12:02,899
<font color="#E5E5E5">and the bad thing is</font><font color="#CCCCCC"> you can craft from</font>

218
00:12:00,110 --> 00:12:04,790
<font color="#E5E5E5">side channel attacks you can craft have</font>

219
00:12:02,899 --> 00:12:10,100
a<font color="#E5E5E5"> channel attacks which allowed to</font>

220
00:12:04,790 --> 00:12:14,390
extract data another basic how do they

221
00:12:10,100 --> 00:12:16,970
work<font color="#CCCCCC"> in in</font><font color="#E5E5E5"> detail most of you guys here</font>

222
00:12:14,390 --> 00:12:19,630
know<font color="#E5E5E5"> that's the CPU and the</font><font color="#CCCCCC"> RAM module</font>

223
00:12:16,970 --> 00:12:23,420
and they are<font color="#E5E5E5"> connected by</font><font color="#CCCCCC"> a by a bus and</font>

224
00:12:19,630 --> 00:12:27,230
before the CPU can do any operations on

225
00:12:23,420 --> 00:12:29,899
on the data it first must to address the

226
00:12:27,230 --> 00:12:33,680
data so<font color="#CCCCCC"> that it can be loaded</font><font color="#E5E5E5"> from</font><font color="#CCCCCC"> RAM</font>

227
00:12:29,899 --> 00:12:38,870
and then it's<font color="#E5E5E5"> transferred transferred</font>

228
00:12:33,680 --> 00:12:42,890
into the<font color="#E5E5E5"> CPU and operations are done on</font>

229
00:12:38,870 --> 00:12:45,560
<font color="#E5E5E5">the data in the CPU and of course it's</font>

230
00:12:42,890 --> 00:12:47,870
<font color="#CCCCCC">very efficient to cache data that is</font>

231
00:12:45,560 --> 00:12:50,660
operate<font color="#E5E5E5"> that is operated in the seat a</font>

232
00:12:47,870 --> 00:12:53,870
CPU caching means that frequently used

233
00:12:50,660 --> 00:12:56,899
data is stored<font color="#E5E5E5"> in the CPU so it hasn't</font>

234
00:12:53,870 --> 00:12:59,480
<font color="#CCCCCC">hasn't</font><font color="#E5E5E5"> it's not necessary to load it</font>

235
00:12:56,899 --> 00:13:03,800
from the<font color="#E5E5E5"> RAM module</font><font color="#CCCCCC"> a classical example</font>

236
00:12:59,480 --> 00:13:07,040
for caching is<font color="#CCCCCC"> saw</font><font color="#E5E5E5"> sort like you have in</font>

237
00:13:03,800 --> 00:13:09,500
your kitchen<font color="#E5E5E5"> because</font><font color="#CCCCCC"> you don't use salt</font>

238
00:13:07,040 --> 00:13:11,959
<font color="#E5E5E5">frequently when you cook and</font><font color="#CCCCCC"> you don't</font>

239
00:13:09,500 --> 00:13:14,240
run<font color="#CCCCCC"> to the supermarket each time you add</font>

240
00:13:11,959 --> 00:13:17,410
salt<font color="#E5E5E5"> to some</font><font color="#CCCCCC"> meal you cook so it's</font>

241
00:13:14,240 --> 00:13:17,410
cached in your kitchen

242
00:13:18,700 --> 00:13:25,030
as I mentioned before<font color="#CCCCCC"> hyper-threading is</font>

243
00:13:22,060 --> 00:13:29,709
one of the features that make modern

244
00:13:25,030 --> 00:13:31,780
<font color="#CCCCCC">CPUs</font><font color="#E5E5E5"> so effective and so fast but still</font>

245
00:13:29,710 --> 00:13:33,730
vulnerable<font color="#CCCCCC"> I'm going to give you a</font>

246
00:13:31,780 --> 00:13:37,350
<font color="#E5E5E5">high-level overview about hyper</font>

247
00:13:33,730 --> 00:13:41,260
threading so<font color="#E5E5E5"> imagine a</font><font color="#CCCCCC"> single-core CPU</font>

248
00:13:37,350 --> 00:13:44,970
<font color="#CCCCCC">where just</font><font color="#E5E5E5"> one</font><font color="#CCCCCC"> program</font><font color="#E5E5E5"> a process can run</font>

249
00:13:41,260 --> 00:13:48,819
at the at the normal at once

250
00:13:44,970 --> 00:13:53,080
so one<font color="#CCCCCC"> processes were executing with</font>

251
00:13:48,820 --> 00:13:57,550
some<font color="#E5E5E5"> instructions and the CPU processes</font>

252
00:13:53,080 --> 00:14:00,760
these instructions<font color="#E5E5E5"> however</font><font color="#CCCCCC"> it's can't</font>

253
00:13:57,550 --> 00:14:03,370
because only one process is allowed<font color="#E5E5E5"> we</font>

254
00:14:00,760 --> 00:14:06,220
can there are<font color="#E5E5E5"> many parts of this bit of</font>

255
00:14:03,370 --> 00:14:11,410
<font color="#CCCCCC">the CPU which do not work</font><font color="#E5E5E5"> during these</font>

256
00:14:06,220 --> 00:14:14,550
instructions<font color="#E5E5E5"> they are</font><font color="#CCCCCC"> their idle</font><font color="#E5E5E5"> so what</font>

257
00:14:11,410 --> 00:14:17,770
is hyper threading<font color="#E5E5E5"> it's a virtual</font>

258
00:14:14,550 --> 00:14:21,069
implementation of two CPU cores<font color="#E5E5E5"> so the</font>

259
00:14:17,770 --> 00:14:24,160
<font color="#CCCCCC">operating systems</font><font color="#E5E5E5"> can send</font><font color="#CCCCCC"> two processes</font>

260
00:14:21,070 --> 00:14:27,400
at once but<font color="#CCCCCC"> just in one CPU</font><font color="#E5E5E5"> and</font>

261
00:14:24,160 --> 00:14:31,930
obviously this improves<font color="#E5E5E5"> the usage of the</font>

262
00:14:27,400 --> 00:14:36,579
of the of the<font color="#E5E5E5"> other CPUs parts which are</font>

263
00:14:31,930 --> 00:14:38,439
<font color="#E5E5E5">not which are not needed to process the</font>

264
00:14:36,580 --> 00:14:42,600
<font color="#CCCCCC">data</font><font color="#E5E5E5"> from process once so they can be</font>

265
00:14:38,440 --> 00:14:48,810
processed<font color="#E5E5E5"> in</font><font color="#CCCCCC"> advance</font><font color="#E5E5E5"> using</font><font color="#CCCCCC"> only one core</font>

266
00:14:42,600 --> 00:14:52,840
but but yeah so the bad thing is<font color="#CCCCCC"> if</font>

267
00:14:48,810 --> 00:14:57,670
process<font color="#CCCCCC"> two is malicious it can trick</font>

268
00:14:52,840 --> 00:15:00,820
the CPU to access<font color="#E5E5E5"> the data from process</font>

269
00:14:57,670 --> 00:15:03,099
one this is basically why hyper

270
00:15:00,820 --> 00:15:07,540
threading is a threat<font color="#E5E5E5"> for modern in</font>

271
00:15:03,100 --> 00:15:09,490
modern CPUs because one process can<font color="#E5E5E5"> spy</font>

272
00:15:07,540 --> 00:15:12,849
on<font color="#E5E5E5"> each other</font><font color="#CCCCCC"> I'm going to explain this</font>

273
00:15:09,490 --> 00:15:15,940
more in detail<font color="#E5E5E5"> but first I'm going to</font>

274
00:15:12,850 --> 00:15:19,060
<font color="#E5E5E5">explain speculative execution the other</font>

275
00:15:15,940 --> 00:15:21,030
attack vector and<font color="#CCCCCC"> pays for side channel</font>

276
00:15:19,060 --> 00:15:24,359
<font color="#CCCCCC">attacks and cover channel attacks like</font>

277
00:15:21,030 --> 00:15:28,420
we know them today

278
00:15:24,360 --> 00:15:31,340
so again<font color="#E5E5E5"> process</font><font color="#CCCCCC"> one is executing on one</font>

279
00:15:28,420 --> 00:15:33,319
CPU<font color="#E5E5E5"> with just a single core</font>

280
00:15:31,340 --> 00:15:36,290
and you might<font color="#E5E5E5"> have</font><font color="#CCCCCC"> noticed a difference</font>

281
00:15:33,320 --> 00:15:39,380
at<font color="#CCCCCC"> that slide there are some</font>

282
00:15:36,290 --> 00:15:41,660
instructions<font color="#E5E5E5"> missing the CPU is idle</font>

283
00:15:39,380 --> 00:15:43,460
<font color="#CCCCCC">because some data has to be loaded or</font>

284
00:15:41,660 --> 00:15:46,939
because it needs<font color="#E5E5E5"> to fetch</font><font color="#CCCCCC"> instruction</font>

285
00:15:43,460 --> 00:15:50,600
<font color="#CCCCCC">form from somewhere else</font><font color="#E5E5E5"> so it has no</font>

286
00:15:46,940 --> 00:15:54,080
<font color="#E5E5E5">information</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> process so what does the</font>

287
00:15:50,600 --> 00:15:58,040
CPU do when when<font color="#E5E5E5"> hyper threading is</font>

288
00:15:54,080 --> 00:15:59,780
enabled<font color="#E5E5E5"> it processes another process</font><font color="#CCCCCC"> and</font>

289
00:15:58,040 --> 00:16:03,219
they run next<font color="#E5E5E5"> to each other on one</font>

290
00:15:59,780 --> 00:16:06,170
single core<font color="#E5E5E5"> exit using all the</font>

291
00:16:03,220 --> 00:16:10,820
<font color="#E5E5E5">instructions and operation</font><font color="#CCCCCC"> unit stats</font>

292
00:16:06,170 --> 00:16:14,060
<font color="#E5E5E5">that</font><font color="#CCCCCC"> are available so in</font><font color="#E5E5E5"> order to fill</font>

293
00:16:10,820 --> 00:16:17,240
that gap<font color="#E5E5E5"> here in process one when</font>

294
00:16:14,060 --> 00:16:19,280
nothing<font color="#E5E5E5"> is executed the</font><font color="#CCCCCC"> see oh yeah and</font>

295
00:16:17,240 --> 00:16:24,290
obviously<font color="#E5E5E5"> everything is stored in the</font>

296
00:16:19,280 --> 00:16:26,660
cache of these two processes<font color="#E5E5E5"> so what</font>

297
00:16:24,290 --> 00:16:31,189
does the<font color="#E5E5E5"> CPU do in order</font><font color="#CCCCCC"> to fill that</font>

298
00:16:26,660 --> 00:16:35,560
<font color="#CCCCCC">gap it speculates it</font><font color="#E5E5E5"> guesses and it</font>

299
00:16:31,190 --> 00:16:38,330
observes what operations are done in

300
00:16:35,560 --> 00:16:41,959
during during<font color="#CCCCCC"> the execution</font><font color="#E5E5E5"> and so</font><font color="#CCCCCC"> it</font>

301
00:16:38,330 --> 00:16:44,390
executes them speculatively<font color="#E5E5E5"> and in case</font>

302
00:16:41,960 --> 00:16:46,450
the it was wrong<font color="#CCCCCC"> it just throws the</font>

303
00:16:44,390 --> 00:16:51,170
results away and like nothing<font color="#E5E5E5"> happens</font>

304
00:16:46,450 --> 00:16:54,080
but in<font color="#E5E5E5"> general a speculation helps to</font>

305
00:16:51,170 --> 00:16:57,589
make<font color="#E5E5E5"> modern CPUs really efficient and</font>

306
00:16:54,080 --> 00:16:59,720
really really fast<font color="#E5E5E5"> because</font><font color="#CCCCCC"> we just can</font>

307
00:16:57,590 --> 00:17:03,560
guess what we're doing<font color="#CCCCCC"> a real-world</font>

308
00:16:59,720 --> 00:17:06,560
example for this<font color="#E5E5E5"> is consider a door your</font>

309
00:17:03,560 --> 00:17:09,139
door at home you open<font color="#E5E5E5"> you are used to it</font>

310
00:17:06,560 --> 00:17:11,389
<font color="#E5E5E5">that it's usually opened so you don't</font>

311
00:17:09,140 --> 00:17:13,880
fetch in your pocket and get your key

312
00:17:11,390 --> 00:17:16,190
out every time<font color="#E5E5E5"> because because</font><font color="#CCCCCC"> you're</font>

313
00:17:13,880 --> 00:17:18,950
<font color="#E5E5E5">used to that it's open so you just</font><font color="#CCCCCC"> open</font>

314
00:17:16,190 --> 00:17:21,200
the<font color="#CCCCCC"> door and in the second step when</font>

315
00:17:18,950 --> 00:17:23,630
<font color="#CCCCCC">you've noticed and it's closed</font><font color="#E5E5E5"> which is</font>

316
00:17:21,200 --> 00:17:25,850
seldomly the case<font color="#E5E5E5"> then you do the</font>

317
00:17:23,630 --> 00:17:28,670
cumbersome process of fetching<font color="#CCCCCC"> your</font><font color="#E5E5E5"> key</font>

318
00:17:25,849 --> 00:17:34,010
out<font color="#CCCCCC"> of your pocket</font><font color="#E5E5E5"> so this is basically</font>

319
00:17:28,670 --> 00:17:37,720
the same what modern<font color="#E5E5E5"> CPUs do so and</font>

320
00:17:34,010 --> 00:17:42,410
again<font color="#E5E5E5"> if there is one malicious process</font>

321
00:17:37,720 --> 00:17:45,190
they can<font color="#E5E5E5"> trick the CPU in a way that it</font>

322
00:17:42,410 --> 00:17:48,310
predicts<font color="#CCCCCC"> a false data</font>

323
00:17:45,190 --> 00:17:52,140
data that should not be<font color="#E5E5E5"> processed and to</font>

324
00:17:48,310 --> 00:17:57,090
access<font color="#CCCCCC"> data that really</font><font color="#E5E5E5"> should</font><font color="#CCCCCC"> not be</font>

325
00:17:52,140 --> 00:18:02,020
accessed so obviously then<font color="#CCCCCC"> the CPU</font>

326
00:17:57,090 --> 00:18:04,720
speculatively<font color="#CCCCCC"> execute fetches some data</font>

327
00:18:02,020 --> 00:18:07,810
that<font color="#CCCCCC"> is not</font><font color="#E5E5E5"> intended to and it gets</font>

328
00:18:04,720 --> 00:18:10,510
loaded<font color="#E5E5E5"> into the caches and from the</font>

329
00:18:07,810 --> 00:18:16,990
caches<font color="#E5E5E5"> our malicious process</font><font color="#CCCCCC"> too can</font>

330
00:18:10,510 --> 00:18:19,210
extract the data<font color="#E5E5E5"> again so take a sip of</font>

331
00:18:16,990 --> 00:18:21,850
coffee or something<font color="#CCCCCC"> because we're going</font>

332
00:18:19,210 --> 00:18:31,930
<font color="#CCCCCC">through</font><font color="#E5E5E5"> meltdown right</font><font color="#CCCCCC"> now at a higher</font>

333
00:18:21,850 --> 00:18:36,060
<font color="#CCCCCC">level the base for meltdown is the same</font>

334
00:18:31,930 --> 00:18:39,700
as for almost all<font color="#E5E5E5"> Spectre attacks</font>

335
00:18:36,060 --> 00:18:42,639
<font color="#E5E5E5">because the first thing when I ask when</font>

336
00:18:39,700 --> 00:18:45,490
I saw about these when I read through

337
00:18:42,640 --> 00:18:49,060
<font color="#E5E5E5">these papers papers is</font><font color="#CCCCCC"> okay</font><font color="#E5E5E5"> we have four</font>

338
00:18:45,490 --> 00:18:52,780
data of a foreign process in the cache

339
00:18:49,060 --> 00:18:54,520
<font color="#E5E5E5">we have a reproducible way to get it to</font>

340
00:18:52,780 --> 00:18:58,420
get<font color="#E5E5E5"> foreign data in the cache but</font><font color="#CCCCCC"> how to</font>

341
00:18:54,520 --> 00:19:04,270
<font color="#E5E5E5">extract it</font><font color="#CCCCCC"> from the cache</font><font color="#E5E5E5"> so the first</font>

342
00:18:58,420 --> 00:19:06,940
the<font color="#CCCCCC"> first step is we access data at</font><font color="#E5E5E5"> the</font>

343
00:19:04,270 --> 00:19:11,139
at an illegal address the data we want

344
00:19:06,940 --> 00:19:14,730
<font color="#CCCCCC">to extract extract and speculatively</font>

345
00:19:11,140 --> 00:19:18,160
<font color="#E5E5E5">this code</font><font color="#CCCCCC"> gets it gets executed because</font>

346
00:19:14,730 --> 00:19:20,590
<font color="#E5E5E5">the all the memory accesses before</font><font color="#CCCCCC"> were</font>

347
00:19:18,160 --> 00:19:26,230
<font color="#E5E5E5">just regular and for this reason the</font><font color="#CCCCCC"> cpu</font>

348
00:19:20,590 --> 00:19:27,520
exact<font color="#E5E5E5"> except things there is the next</font>

349
00:19:26,230 --> 00:19:29,950
instructions and the next fetch

350
00:19:27,520 --> 00:19:33,970
instruction will<font color="#CCCCCC"> be legal as well so it</font>

351
00:19:29,950 --> 00:19:37,990
just<font color="#E5E5E5"> executes them once we have that</font>

352
00:19:33,970 --> 00:19:42,190
data loaded into the CPU we craft a

353
00:19:37,990 --> 00:19:45,810
memory address from<font color="#CCCCCC"> that data from</font><font color="#E5E5E5"> the</font>

354
00:19:42,190 --> 00:19:52,030
secret<font color="#E5E5E5"> data this is just done by</font>

355
00:19:45,810 --> 00:19:54,940
shifting<font color="#E5E5E5"> it</font><font color="#CCCCCC"> 12 bits to the</font><font color="#E5E5E5"> left so we</font>

356
00:19:52,030 --> 00:19:57,970
then have a memory address that depends

357
00:19:54,940 --> 00:19:58,990
on the<font color="#CCCCCC"> data we want to</font><font color="#E5E5E5"> extract on the</font>

358
00:19:57,970 --> 00:20:04,270
data of<font color="#CCCCCC"> the</font><font color="#E5E5E5"> four</font>

359
00:19:58,990 --> 00:20:06,850
process so then we load this address a

360
00:20:04,270 --> 00:20:11,040
which we constructed<font color="#E5E5E5"> from the data we</font>

361
00:20:06,850 --> 00:20:15,969
want<font color="#CCCCCC"> to address and our program crashes</font>

362
00:20:11,040 --> 00:20:18,460
<font color="#E5E5E5">why because the CPU noticed there was an</font>

363
00:20:15,970 --> 00:20:21,540
illegal memory access<font color="#CCCCCC"> I have to end this</font>

364
00:20:18,460 --> 00:20:26,380
this progress<font color="#E5E5E5"> this process immediately</font>

365
00:20:21,540 --> 00:20:28,800
<font color="#E5E5E5">however you can work around these is</font>

366
00:20:26,380 --> 00:20:33,010
memory checks<font color="#E5E5E5"> the most common and</font>

367
00:20:28,800 --> 00:20:35,110
intuitive way is to to do many<font color="#E5E5E5"> Forks of</font>

368
00:20:33,010 --> 00:20:38,320
<font color="#E5E5E5">the process so the parent process dies</font>

369
00:20:35,110 --> 00:20:41,889
<font color="#E5E5E5">but all the child processes continue to</font>

370
00:20:38,320 --> 00:20:47,200
execute<font color="#E5E5E5"> there are other there</font><font color="#CCCCCC"> are other</font>

371
00:20:41,890 --> 00:20:50,380
very sophisticated ways<font color="#E5E5E5"> using features</font>

372
00:20:47,200 --> 00:20:55,030
of some specific<font color="#E5E5E5"> CPUs but the fork model</font>

373
00:20:50,380 --> 00:21:00,010
works on most operating systems<font color="#E5E5E5"> and then</font>

374
00:20:55,030 --> 00:21:04,710
<font color="#E5E5E5">we probe</font><font color="#CCCCCC"> the access time to the data aim</font>

375
00:21:00,010 --> 00:21:08,500
to learn if it is cached<font color="#E5E5E5"> remember a is</font>

376
00:21:04,710 --> 00:21:13,330
the data stored at<font color="#CCCCCC"> the location with</font>

377
00:21:08,500 --> 00:21:16,980
address a is in<font color="#E5E5E5"> the cache because we</font>

378
00:21:13,330 --> 00:21:22,149
loaded it<font color="#E5E5E5"> and the</font><font color="#CCCCCC"> address aid depends on</font>

379
00:21:16,980 --> 00:21:26,520
data we want to extract<font color="#E5E5E5"> and then we</font>

380
00:21:22,150 --> 00:21:31,540
iterate<font color="#E5E5E5"> some part of the memory and</font>

381
00:21:26,520 --> 00:21:35,830
<font color="#E5E5E5">probe if this address a is in is</font><font color="#CCCCCC"> in the</font>

382
00:21:31,540 --> 00:21:40,570
cache<font color="#E5E5E5"> and if it is in the cache</font><font color="#CCCCCC"> we know</font>

383
00:21:35,830 --> 00:21:43,870
we just<font color="#E5E5E5"> accessed that address a and C</font>

384
00:21:40,570 --> 00:21:47,260
<font color="#E5E5E5">and learn that it's in the cache</font><font color="#CCCCCC"> so all</font>

385
00:21:43,870 --> 00:21:53,860
we need<font color="#CCCCCC"> to do then is to construct of</font>

386
00:21:47,260 --> 00:21:57,460
the to reconstruct the data<font color="#E5E5E5"> D by by</font>

387
00:21:53,860 --> 00:22:00,790
using address<font color="#E5E5E5"> a because a depends</font><font color="#CCCCCC"> on the</font>

388
00:21:57,460 --> 00:22:03,190
data D we want<font color="#E5E5E5"> to</font><font color="#CCCCCC"> extract</font><font color="#E5E5E5"> so we just</font>

389
00:22:00,790 --> 00:22:06,460
need<font color="#CCCCCC"> to undo the shift operations and</font>

390
00:22:03,190 --> 00:22:09,340
have the original that the original

391
00:22:06,460 --> 00:22:12,040
bytes<font color="#E5E5E5"> again and you can do this in total</font>

392
00:22:09,340 --> 00:22:12,580
<font color="#CCCCCC">with</font><font color="#E5E5E5"> meltdown to get to read the whole</font>

393
00:22:12,040 --> 00:22:17,019
<font color="#E5E5E5">memory</font>

394
00:22:12,580 --> 00:22:23,230
in about 500<font color="#E5E5E5"> kilobits so really per</font>

395
00:22:17,019 --> 00:22:26,769
second so<font color="#E5E5E5"> that's really really fast</font><font color="#CCCCCC"> so</font>

396
00:22:23,230 --> 00:22:31,059
how can you<font color="#E5E5E5"> protect yourself against CPU</font>

397
00:22:26,769 --> 00:22:32,380
vulnerabilities as always<font color="#E5E5E5"> applying</font>

398
00:22:31,059 --> 00:22:34,928
security updates

399
00:22:32,380 --> 00:22:37,360
I really must<font color="#E5E5E5"> stress that like every</font>

400
00:22:34,929 --> 00:22:40,450
security researcher and really make sure

401
00:22:37,360 --> 00:22:43,689
that<font color="#CCCCCC"> micro code updates from Intel from</font>

402
00:22:40,450 --> 00:22:48,850
A&E from<font color="#CCCCCC"> armed</font><font color="#E5E5E5"> are also in are also</font>

403
00:22:43,690 --> 00:22:51,549
applied and again<font color="#E5E5E5"> don't trust the memory</font>

404
00:22:48,850 --> 00:22:53,379
when<font color="#E5E5E5"> you keep secrets into memory there</font>

405
00:22:51,549 --> 00:22:55,149
might be some<font color="#CCCCCC"> side-channel and</font><font color="#E5E5E5"> color</font>

406
00:22:53,380 --> 00:22:59,649
<font color="#E5E5E5">channels</font><font color="#CCCCCC"> attack that we don't know yet</font>

407
00:22:55,149 --> 00:23:02,229
<font color="#CCCCCC">and that so</font><font color="#E5E5E5"> the best way is</font><font color="#CCCCCC"> to get rid</font>

408
00:22:59,649 --> 00:23:04,870
of critical data in<font color="#CCCCCC"> memory</font><font color="#E5E5E5"> as fast as</font>

409
00:23:02,230 --> 00:23:09,130
possible<font color="#E5E5E5"> of course that's not always</font>

410
00:23:04,870 --> 00:23:11,049
possible<font color="#CCCCCC"> imagine</font><font color="#E5E5E5"> you frequent</font><font color="#CCCCCC"> a web</font>

411
00:23:09,130 --> 00:23:14,019
server with many many accesses with

412
00:23:11,049 --> 00:23:16,899
implementing<font color="#CCCCCC"> HTTPS of course the key has</font>

413
00:23:14,019 --> 00:23:20,080
to<font color="#CCCCCC"> be in memory</font><font color="#E5E5E5"> but in case</font><font color="#CCCCCC"> of an SSH a</font>

414
00:23:16,899 --> 00:23:22,870
SSH server for<font color="#CCCCCC"> example where</font><font color="#E5E5E5"> you just</font>

415
00:23:20,080 --> 00:23:25,779
log in one day

416
00:23:22,870 --> 00:23:28,719
it's possible<font color="#E5E5E5"> to unload the key from</font>

417
00:23:25,779 --> 00:23:30,760
memory until the next time you log in<font color="#E5E5E5"> so</font>

418
00:23:28,720 --> 00:23:33,370
in<font color="#E5E5E5"> the meantime it cannot be extracted</font>

419
00:23:30,760 --> 00:23:38,830
<font color="#E5E5E5">from memory this is actually what what</font>

420
00:23:33,370 --> 00:23:42,428
SSH do does so and<font color="#E5E5E5"> for programmers</font>

421
00:23:38,830 --> 00:23:46,600
<font color="#CCCCCC">overwrite critical data</font><font color="#E5E5E5"> as soon as</font><font color="#CCCCCC"> as</font>

422
00:23:42,429 --> 00:23:51,850
possible<font color="#E5E5E5"> how to do that in C there is</font><font color="#CCCCCC"> a</font>

423
00:23:46,600 --> 00:23:53,949
function from<font color="#E5E5E5"> open from</font><font color="#CCCCCC"> OpenBSD</font><font color="#E5E5E5"> but it's</font>

424
00:23:51,850 --> 00:23:56,039
also<font color="#CCCCCC"> available in the in the new Lipsy</font>

425
00:23:53,950 --> 00:24:01,510
<font color="#E5E5E5">and therefore on linux and</font><font color="#CCCCCC"> freebsd</font>

426
00:23:56,039 --> 00:24:03,580
implements it as well which guarantee

427
00:24:01,510 --> 00:24:06,240
which guarantees that the data vanishes

428
00:24:03,580 --> 00:24:08,740
<font color="#E5E5E5">from memory or at least it tries to</font>

429
00:24:06,240 --> 00:24:13,240
guarantee<font color="#CCCCCC"> that</font><font color="#E5E5E5"> because there might still</font>

430
00:24:08,740 --> 00:24:15,789
be some some stuff or some parts of the

431
00:24:13,240 --> 00:24:18,309
data in some hidden in some compiler

432
00:24:15,789 --> 00:24:22,059
optimizations or on this back or

433
00:24:18,309 --> 00:24:24,580
somewhere<font color="#CCCCCC"> on the heap</font><font color="#E5E5E5"> but at least for</font>

434
00:24:22,059 --> 00:24:26,350
GCC<font color="#E5E5E5"> and</font><font color="#CCCCCC"> facili it can</font><font color="#E5E5E5"> really guarantee</font>

435
00:24:24,580 --> 00:24:28,809
that<font color="#E5E5E5"> this data is</font>

436
00:24:26,350 --> 00:24:33,490
overwritten<font color="#E5E5E5"> as fast as possible by this</font>

437
00:24:28,809 --> 00:24:37,649
<font color="#E5E5E5">C function in Java or actually</font>

438
00:24:33,490 --> 00:24:41,110
recommends to overwrite character to

439
00:24:37,650 --> 00:24:45,429
<font color="#CCCCCC">override passwords</font><font color="#E5E5E5"> using a character</font>

440
00:24:41,110 --> 00:24:48,219
<font color="#E5E5E5">arrays every proper Java function which</font>

441
00:24:45,429 --> 00:24:51,370
is dealing<font color="#CCCCCC"> with passwords returns char</font>

442
00:24:48,220 --> 00:24:55,600
character arrays byte arrays and not

443
00:24:51,370 --> 00:24:57,760
objects why<font color="#E5E5E5"> because with a character</font>

444
00:24:55,600 --> 00:25:00,760
array<font color="#E5E5E5"> you don't have the overhead</font><font color="#CCCCCC"> of</font>

445
00:24:57,760 --> 00:25:03,789
objects all around<font color="#CCCCCC"> so</font><font color="#E5E5E5"> just the data that</font>

446
00:25:00,760 --> 00:25:07,900
can be<font color="#E5E5E5"> one by one translated to binary</font>

447
00:25:03,789 --> 00:25:09,730
<font color="#E5E5E5">data into into the assembly so you in</font>

448
00:25:07,900 --> 00:25:12,280
<font color="#E5E5E5">veneer a Java programmer and dealing</font>

449
00:25:09,730 --> 00:25:15,700
with<font color="#E5E5E5"> passwords use character arrays and</font>

450
00:25:12,280 --> 00:25:18,039
<font color="#E5E5E5">override the password</font><font color="#CCCCCC"> sear it as soon as</font>

451
00:25:15,700 --> 00:25:22,030
<font color="#CCCCCC">soon as you don't</font><font color="#E5E5E5"> need it anymore this</font>

452
00:25:18,039 --> 00:25:26,770
is also<font color="#E5E5E5"> border x4 recommends for</font><font color="#CCCCCC"> peyten</font>

453
00:25:22,030 --> 00:25:30,309
<font color="#E5E5E5">go and other languages there are not</font>

454
00:25:26,770 --> 00:25:32,650
really solutions<font color="#CCCCCC"> why because strings are</font>

455
00:25:30,309 --> 00:25:34,720
immutable<font color="#CCCCCC"> and cannot change and</font><font color="#E5E5E5"> when you</font>

456
00:25:32,650 --> 00:25:39,610
override them there is and immediately

457
00:25:34,720 --> 00:25:44,470
<font color="#E5E5E5">there</font><font color="#CCCCCC"> is a copy done immediately and</font><font color="#E5E5E5"> the</font>

458
00:25:39,610 --> 00:25:46,600
rest of the old string is is taken care

459
00:25:44,470 --> 00:25:48,789
<font color="#E5E5E5">of by the garbage collector</font><font color="#CCCCCC"> which can be</font>

460
00:25:46,600 --> 00:25:52,360
triggered<font color="#CCCCCC"> manually but</font><font color="#E5E5E5"> you can't get rid</font>

461
00:25:48,789 --> 00:25:55,900
of<font color="#E5E5E5"> it immediately</font><font color="#CCCCCC"> it might be still bad</font>

462
00:25:52,360 --> 00:26:00,039
enough for<font color="#CCCCCC"> a side channel</font><font color="#E5E5E5"> so there is</font>

463
00:25:55,900 --> 00:26:05,650
not<font color="#E5E5E5"> really</font><font color="#CCCCCC"> a good solution for</font><font color="#E5E5E5"> this at</font>

464
00:26:00,039 --> 00:26:11,049
the at the<font color="#E5E5E5"> moment yeah this was already</font>

465
00:26:05,650 --> 00:26:13,690
the first part I am<font color="#E5E5E5"> on purpose left some</font>

466
00:26:11,049 --> 00:26:15,970
time for for questions which I'm very

467
00:26:13,690 --> 00:26:24,190
<font color="#CCCCCC">happy to answer yeah I</font><font color="#E5E5E5"> already see a</font>

468
00:26:15,970 --> 00:26:27,070
<font color="#CCCCCC">question I didn't</font><font color="#E5E5E5"> go the part about how</font>

469
00:26:24,190 --> 00:26:28,990
the data<font color="#E5E5E5"> translates to the address and</font>

470
00:26:27,070 --> 00:26:31,928
address<font color="#E5E5E5"> back to data</font>

471
00:26:28,990 --> 00:26:34,600
<font color="#CCCCCC">I know it's shifting by</font><font color="#E5E5E5"> 12 bits but why</font>

472
00:26:31,929 --> 00:26:37,690
what was the<font color="#E5E5E5"> underlying relationship</font>

473
00:26:34,600 --> 00:26:39,480
between the two okay I have some<font color="#E5E5E5"> backup</font>

474
00:26:37,690 --> 00:26:42,570
slides for these<font color="#CCCCCC"> four</font>

475
00:26:39,480 --> 00:26:45,960
for that that's the that's the assembly

476
00:26:42,570 --> 00:26:52,050
<font color="#CCCCCC">code</font><font color="#E5E5E5"> off of meltdown so we have one huge</font>

477
00:26:45,960 --> 00:26:57,690
<font color="#E5E5E5">array of of</font><font color="#CCCCCC"> the size page</font><font color="#E5E5E5"> size</font><font color="#CCCCCC"> times</font>

478
00:26:52,050 --> 00:27:01,379
<font color="#CCCCCC">bite</font><font color="#E5E5E5"> size so imagine like usually</font><font color="#CCCCCC"> if the</font>

479
00:26:57,690 --> 00:27:06,350
page size<font color="#CCCCCC"> is 4 K 4 kilo</font><font color="#E5E5E5"> 4 kilobytes and</font>

480
00:27:01,380 --> 00:27:14,630
<font color="#E5E5E5">you're extracting one byte so page size</font>

481
00:27:06,350 --> 00:27:23,730
page size 4096<font color="#CCCCCC"> x</font><font color="#E5E5E5"> 2 286 dv8 bytes and</font>

482
00:27:14,630 --> 00:27:30,930
then you access the you access the<font color="#E5E5E5"> the</font>

483
00:27:23,730 --> 00:27:34,140
data<font color="#E5E5E5"> shift it and load</font><font color="#CCCCCC"> that data to that</font>

484
00:27:30,930 --> 00:27:37,760
array to<font color="#CCCCCC"> that huge array and by the</font>

485
00:27:34,140 --> 00:27:41,060
index of the array<font color="#CCCCCC"> you</font><font color="#E5E5E5"> can you can</font>

486
00:27:37,760 --> 00:27:44,480
<font color="#E5E5E5">conclude</font><font color="#CCCCCC"> with back</font><font color="#E5E5E5"> to the data that</font>

487
00:27:41,060 --> 00:27:49,080
<font color="#CCCCCC">isn't in the</font><font color="#E5E5E5"> byte because it's really</font>

488
00:27:44,480 --> 00:27:53,750
for each<font color="#E5E5E5"> possible for each possible</font>

489
00:27:49,080 --> 00:27:56,340
<font color="#E5E5E5">value of the byte there is one array</font>

490
00:27:53,750 --> 00:28:00,030
does this answer your question<font color="#CCCCCC"> so</font>

491
00:27:56,340 --> 00:28:03,990
basically I<font color="#E5E5E5"> have to</font><font color="#CCCCCC"> reveal</font><font color="#E5E5E5"> this memory</font>

492
00:28:00,030 --> 00:28:07,790
area before<font color="#E5E5E5"> no it must it must be empty</font>

493
00:28:03,990 --> 00:28:13,290
so you can probe which one is not<font color="#CCCCCC"> zero</font>

494
00:28:07,790 --> 00:28:16,740
<font color="#E5E5E5">okay thanks a lot</font><font color="#CCCCCC"> yeah you can</font><font color="#E5E5E5"> just cast</font>

495
00:28:13,290 --> 00:28:18,990
this this later on<font color="#E5E5E5"> it's it's tough and</font>

496
00:28:16,740 --> 00:28:31,430
it takes some time<font color="#E5E5E5"> thank you</font>

497
00:28:18,990 --> 00:28:34,440
there are any other questions<font color="#E5E5E5"> so so</font>

498
00:28:31,430 --> 00:28:38,970
there are so many service which are

499
00:28:34,440 --> 00:28:41,640
<font color="#E5E5E5">running and have a lot of uptime so can</font>

500
00:28:38,970 --> 00:28:45,900
<font color="#E5E5E5">can those batches or micro codes be</font>

501
00:28:41,640 --> 00:28:47,790
applied during or<font color="#CCCCCC"> is there down time</font>

502
00:28:45,900 --> 00:28:50,500
needed for<font color="#E5E5E5"> them to</font>

503
00:28:47,790 --> 00:28:53,139
unfortunately yes<font color="#CCCCCC"> because you need when</font>

504
00:28:50,500 --> 00:28:55,270
you update<font color="#E5E5E5"> the firmware of the CPU it's</font>

505
00:28:53,140 --> 00:28:56,860
absolutely necessary to<font color="#E5E5E5"> rebuild the</font>

506
00:28:55,270 --> 00:28:59,800
operating system because<font color="#E5E5E5"> you cannot</font>

507
00:28:56,860 --> 00:29:03,100
<font color="#E5E5E5">really change you cannot easily change</font>

508
00:28:59,800 --> 00:29:06,070
the instruction<font color="#E5E5E5"> set the instructions for</font>

509
00:29:03,100 --> 00:29:10,689
<font color="#E5E5E5">the operating</font><font color="#CCCCCC"> system</font><font color="#E5E5E5"> during during</font>

510
00:29:06,070 --> 00:29:19,870
<font color="#CCCCCC">runtime that's unfortunately</font><font color="#E5E5E5"> not really</font>

511
00:29:10,690 --> 00:29:25,630
possible all<font color="#E5E5E5"> right we have another one</font>

512
00:29:19,870 --> 00:29:28,629
<font color="#CCCCCC">here so that in</font><font color="#E5E5E5"> your slides you</font><font color="#CCCCCC"> referred</font>

513
00:29:25,630 --> 00:29:31,480
<font color="#CCCCCC">about hyper threading yes is that all</font>

514
00:29:28,630 --> 00:29:34,900
symmetric<font color="#E5E5E5"> multi threading or just the</font>

515
00:29:31,480 --> 00:29:37,230
intern implementation because the MD IBM

516
00:29:34,900 --> 00:29:41,220
also<font color="#E5E5E5"> have symmetric multiprocessing</font>

517
00:29:37,230 --> 00:29:44,490
<font color="#E5E5E5">multi-threading actually it's not really</font>

518
00:29:41,220 --> 00:29:47,680
<font color="#E5E5E5">my teeth reading but it's the</font>

519
00:29:44,490 --> 00:29:50,620
simultaneously operation of two

520
00:29:47,680 --> 00:29:53,410
processes<font color="#CCCCCC"> in one core</font><font color="#E5E5E5"> so the problem is</font>

521
00:29:50,620 --> 00:29:55,989
<font color="#E5E5E5">that</font><font color="#CCCCCC"> they share one core</font><font color="#E5E5E5"> and it really</font>

522
00:29:53,410 --> 00:29:59,320
depends on<font color="#E5E5E5"> the on the attack which CPU</font>

523
00:29:55,990 --> 00:30:02,200
is vulnerable<font color="#E5E5E5"> for many attacks that</font><font color="#CCCCCC"> are</font>

524
00:29:59,320 --> 00:30:04,510
just well<font color="#CCCCCC"> I've just worked</font><font color="#E5E5E5"> on in Intel</font>

525
00:30:02,200 --> 00:30:07,450
architectures but some just<font color="#CCCCCC"> work only on</font>

526
00:30:04,510 --> 00:30:10,240
on<font color="#CCCCCC"> arms so</font><font color="#E5E5E5"> you really</font><font color="#CCCCCC"> need to</font><font color="#E5E5E5"> depend on</font>

527
00:30:07,450 --> 00:30:13,150
the specific CPU and from my experience

528
00:30:10,240 --> 00:30:16,530
<font color="#CCCCCC">I can tell that</font><font color="#E5E5E5"> most the researchers</font>

529
00:30:13,150 --> 00:30:20,410
focus on Intel because Intel is huge and

530
00:30:16,530 --> 00:30:23,379
larger than AMD<font color="#CCCCCC"> so I</font><font color="#E5E5E5"> wouldn't expect to</font>

531
00:30:20,410 --> 00:30:27,150
<font color="#CCCCCC">be safe with with</font><font color="#E5E5E5"> arm just because there</font>

532
00:30:23,380 --> 00:30:33,640
<font color="#E5E5E5">are less vulnerabilities found</font><font color="#CCCCCC"> Thanks</font>

533
00:30:27,150 --> 00:30:36,820
thank you<font color="#CCCCCC"> okay so we have</font><font color="#E5E5E5"> some questions</font>

534
00:30:33,640 --> 00:30:40,120
<font color="#E5E5E5">so we have this gentleman here then</font><font color="#CCCCCC"> and</font>

535
00:30:36,820 --> 00:30:48,820
then there<font color="#E5E5E5"> okay so well as my colleague</font>

536
00:30:40,120 --> 00:30:50,260
to help you so if you can help so how

537
00:30:48,820 --> 00:30:52,990
about<font color="#CCCCCC"> the cloud infrastructure is</font>

538
00:30:50,260 --> 00:30:54,250
vulnerable<font color="#CCCCCC"> to this kind of attack</font><font color="#E5E5E5"> so I'm</font>

539
00:30:52,990 --> 00:30:57,400
just wondering you mentioned here that

540
00:30:54,250 --> 00:30:59,799
<font color="#CCCCCC">Google mitigate somehow the</font>

541
00:30:57,400 --> 00:31:02,530
the meltdown attack how about Amazon or

542
00:30:59,799 --> 00:31:04,809
<font color="#CCCCCC">other cloud provider</font><font color="#E5E5E5"> they do they have</font>

543
00:31:02,530 --> 00:31:07,780
this solution<font color="#E5E5E5"> in place for such as</font>

544
00:31:04,809 --> 00:31:12,580
attacks<font color="#E5E5E5"> well Google has for their</font>

545
00:31:07,780 --> 00:31:15,610
infrastructure<font color="#CCCCCC"> yes</font><font color="#E5E5E5"> the others I'm not</font><font color="#CCCCCC"> so</font>

546
00:31:12,580 --> 00:31:19,178
sure<font color="#E5E5E5"> it depends many of these attacks</font>

547
00:31:15,610 --> 00:31:21,908
<font color="#CCCCCC">don't</font><font color="#E5E5E5"> really work reliably on virtual</font>

548
00:31:19,179 --> 00:31:26,530
CPUs so if you're at some cloud provider

549
00:31:21,909 --> 00:31:28,570
using virtual virtual<font color="#CCCCCC"> hardware the</font>

550
00:31:26,530 --> 00:31:31,480
timing<font color="#CCCCCC"> behavior is</font><font color="#E5E5E5"> different and it</font>

551
00:31:28,570 --> 00:31:35,678
might<font color="#E5E5E5"> be more sophisticated for</font>

552
00:31:31,480 --> 00:31:38,740
attackers to<font color="#E5E5E5"> to learn that but for the</font>

553
00:31:35,679 --> 00:31:42,250
<font color="#E5E5E5">hosts for the host machines that hosts</font>

554
00:31:38,740 --> 00:31:44,169
all<font color="#CCCCCC"> the virtualization stuff</font><font color="#E5E5E5"> they need</font>

555
00:31:42,250 --> 00:31:47,049
<font color="#CCCCCC">micro code updates and therefore</font>

556
00:31:44,169 --> 00:31:50,020
downtime so there is not<font color="#CCCCCC"> really a fix</font>

557
00:31:47,049 --> 00:31:53,139
<font color="#E5E5E5">I'm aware of I mean there</font><font color="#CCCCCC"> are there are</font>

558
00:31:50,020 --> 00:31:54,730
ideas<font color="#E5E5E5"> but there are not really solutions</font>

559
00:31:53,140 --> 00:31:59,200
without<font color="#E5E5E5"> for existing infrastructure</font>

560
00:31:54,730 --> 00:32:02,280
<font color="#CCCCCC">without downtime</font><font color="#E5E5E5"> does is answer your</font>

561
00:31:59,200 --> 00:32:02,280
question yes<font color="#E5E5E5"> thank you</font>

562
00:32:06,580 --> 00:32:12,280
so from your<font color="#CCCCCC"> description I guess it</font>

563
00:32:10,610 --> 00:32:14,209
should be enough<font color="#E5E5E5"> to turn off</font>

564
00:32:12,280 --> 00:32:18,590
<font color="#E5E5E5">hyper-threading so instead of having</font>

565
00:32:14,210 --> 00:32:20,390
<font color="#E5E5E5">eight threads</font><font color="#CCCCCC"> I would be back to</font><font color="#E5E5E5"> four</font>

566
00:32:18,590 --> 00:32:22,820
threads because<font color="#E5E5E5"> I have four physical</font>

567
00:32:20,390 --> 00:32:26,900
<font color="#E5E5E5">course is it really enough</font><font color="#CCCCCC"> to prevent</font>

568
00:32:22,820 --> 00:32:31,129
this attacks<font color="#CCCCCC"> not any kind of attack</font><font color="#E5E5E5"> but</font>

569
00:32:26,900 --> 00:32:33,680
some but as a<font color="#E5E5E5"> result for obviously</font>

570
00:32:31,130 --> 00:32:35,780
<font color="#CCCCCC">what's the scenario for attack between</font>

571
00:32:33,680 --> 00:32:38,320
<font color="#E5E5E5">the physical course how can</font><font color="#CCCCCC"> this even</font>

572
00:32:35,780 --> 00:32:38,320
<font color="#E5E5E5">happen</font>

573
00:32:38,420 --> 00:32:47,930
this can happen<font color="#E5E5E5"> because on typically x86</font>

574
00:32:44,120 --> 00:32:51,800
<font color="#E5E5E5">CPUs the l3 cache cache is</font><font color="#CCCCCC"> shared among</font>

575
00:32:47,930 --> 00:32:54,710
all<font color="#CCCCCC"> CPU cores</font><font color="#E5E5E5"> and therefore you have you</font>

576
00:32:51,800 --> 00:32:57,680
have the<font color="#E5E5E5"> vector l1 cache and l2 cache</font>

577
00:32:54,710 --> 00:32:59,720
<font color="#E5E5E5">are per CPU there is no way I'm aware of</font>

578
00:32:57,680 --> 00:33:02,450
<font color="#E5E5E5">where you can extract data but if you</font>

579
00:32:59,720 --> 00:33:05,660
<font color="#CCCCCC">manage to</font><font color="#E5E5E5"> get the</font><font color="#CCCCCC"> timing and wait until</font>

580
00:33:02,450 --> 00:33:08,480
the cache data goes back<font color="#CCCCCC"> to level 3 to</font>

581
00:33:05,660 --> 00:33:13,720
layer 3 then you<font color="#E5E5E5"> can also access it from</font>

582
00:33:08,480 --> 00:33:13,720
another<font color="#E5E5E5"> CPU thanks so much thank you</font>

583
00:33:14,140 --> 00:33:25,780
you said about some<font color="#CCCCCC"> fixes in the</font>

584
00:33:17,660 --> 00:33:28,820
compilers yes commander<font color="#E5E5E5"> latest compilers</font>

585
00:33:25,780 --> 00:33:32,780
<font color="#CCCCCC">what if the application is compiled with</font>

586
00:33:28,820 --> 00:33:35,510
the latest version of compiler<font color="#E5E5E5"> and of</font>

587
00:33:32,780 --> 00:33:40,520
course an application<font color="#E5E5E5"> with another</font>

588
00:33:35,510 --> 00:33:43,879
version<font color="#E5E5E5"> well the compiler protections</font>

589
00:33:40,520 --> 00:33:46,700
protect the software that was compiled

590
00:33:43,880 --> 00:33:48,920
with the software<font color="#E5E5E5"> so</font><font color="#CCCCCC"> the the threat</font>

591
00:33:46,700 --> 00:33:50,570
model<font color="#CCCCCC"> is always that</font><font color="#E5E5E5"> the attacker can do</font>

592
00:33:48,920 --> 00:33:53,290
with his compiler or her compiler

593
00:33:50,570 --> 00:33:59,149
whatever whatever whatever they want

594
00:33:53,290 --> 00:34:02,690
<font color="#E5E5E5">so in</font><font color="#CCCCCC"> this case the the</font><font color="#E5E5E5"> the compiler</font>

595
00:33:59,150 --> 00:34:05,270
<font color="#E5E5E5">fixes just protectors the software that</font>

596
00:34:02,690 --> 00:34:07,240
<font color="#CCCCCC">is come</font><font color="#E5E5E5"> that is compiled with it does</font>

597
00:34:05,270 --> 00:34:10,400
this answer your<font color="#E5E5E5"> question</font><font color="#CCCCCC"> yes</font>

598
00:34:07,240 --> 00:34:12,168
interesting<font color="#CCCCCC"> most mean if it deserves</font><font color="#E5E5E5"> to</font>

599
00:34:10,400 --> 00:34:15,950
compile the<font color="#CCCCCC"> application with</font><font color="#E5E5E5"> the latest</font>

600
00:34:12,168 --> 00:34:18,230
compiler<font color="#CCCCCC"> yes that's that's</font><font color="#E5E5E5"> in general</font><font color="#CCCCCC"> a</font>

601
00:34:15,949 --> 00:34:19,759
<font color="#E5E5E5">good idea but you really have to</font><font color="#CCCCCC"> be</font>

602
00:34:18,230 --> 00:34:21,469
focused<font color="#E5E5E5"> on the</font>

603
00:34:19,760 --> 00:34:27,409
on<font color="#CCCCCC"> the on the</font><font color="#E5E5E5"> flags where you translate</font>

604
00:34:21,469 --> 00:34:29,870
it<font color="#CCCCCC"> I'm I'm</font><font color="#E5E5E5"> not</font><font color="#CCCCCC"> sure if if the red pole</font>

605
00:34:27,409 --> 00:34:32,570
<font color="#CCCCCC">line defense I mentioned before</font><font color="#E5E5E5"> is</font>

606
00:34:29,870 --> 00:34:35,060
already in the default in the default

607
00:34:32,570 --> 00:34:37,220
<font color="#CCCCCC">implementation of any of any compiler</font>

608
00:34:35,060 --> 00:34:38,929
there are<font color="#CCCCCC"> patch sets of course yeah</font><font color="#E5E5E5"> but</font>

609
00:34:37,219 --> 00:34:41,449
I'm not<font color="#E5E5E5"> sure and it's definitely not</font>

610
00:34:38,929 --> 00:34:51,500
enabled<font color="#CCCCCC"> by</font><font color="#E5E5E5"> default</font><font color="#CCCCCC"> because it's still</font>

611
00:34:41,449 --> 00:34:55,270
cannot<font color="#CCCCCC"> well-tested</font><font color="#E5E5E5"> think</font><font color="#CCCCCC"> okay okay hi so</font>

612
00:34:51,500 --> 00:34:58,550
suppose<font color="#CCCCCC"> you</font><font color="#E5E5E5"> have many VMs on one machine</font>

613
00:34:55,270 --> 00:35:03,080
<font color="#CCCCCC">can you read the memory of one</font><font color="#E5E5E5"> VM</font>

614
00:34:58,550 --> 00:35:06,620
<font color="#CCCCCC">through another</font><font color="#E5E5E5"> if</font><font color="#CCCCCC"> it get physically</font>

615
00:35:03,080 --> 00:35:10,190
executed on<font color="#CCCCCC"> the same core then</font><font color="#E5E5E5"> yes no</font>

616
00:35:06,620 --> 00:35:12,410
problem<font color="#CCCCCC"> well it's it's not</font><font color="#E5E5E5"> that easy</font>

617
00:35:10,190 --> 00:35:14,390
<font color="#E5E5E5">so convened remember conventional</font>

618
00:35:12,410 --> 00:35:17,960
attacks are<font color="#E5E5E5"> still easier way more easier</font>

619
00:35:14,390 --> 00:35:20,240
<font color="#E5E5E5">but it's it's possible</font><font color="#CCCCCC"> and some of these</font>

620
00:35:17,960 --> 00:35:23,660
attacks<font color="#E5E5E5"> are also from virtual machine to</font>

621
00:35:20,240 --> 00:35:27,020
virtual machine<font color="#CCCCCC"> okay I have</font><font color="#E5E5E5"> almost the</font>

622
00:35:23,660 --> 00:35:28,730
same question<font color="#E5E5E5"> but about containers so it</font>

623
00:35:27,020 --> 00:35:31,160
should<font color="#CCCCCC"> be</font><font color="#E5E5E5"> more easier actually</font><font color="#CCCCCC"> for</font>

624
00:35:28,730 --> 00:35:33,410
containers I think then<font color="#E5E5E5"> the</font><font color="#CCCCCC"> virtual</font>

625
00:35:31,160 --> 00:35:35,930
<font color="#E5E5E5">machine</font><font color="#CCCCCC"> is I think yes because</font><font color="#E5E5E5"> they</font><font color="#CCCCCC"> run</font>

626
00:35:33,410 --> 00:35:37,690
<font color="#E5E5E5">on the run on the same</font><font color="#CCCCCC"> con and in</font><font color="#E5E5E5"> the</font>

627
00:35:35,930 --> 00:35:40,190
same<font color="#E5E5E5"> physical address</font><font color="#CCCCCC"> space the</font>

628
00:35:37,690 --> 00:35:49,190
operating system uses and therefore

629
00:35:40,190 --> 00:35:54,230
therefore yeah<font color="#E5E5E5"> okay so are we</font><font color="#CCCCCC"> good to</font>

630
00:35:49,190 --> 00:35:55,810
<font color="#E5E5E5">take want to have time I'm here thank</font>

631
00:35:54,230 --> 00:35:57,920
you

632
00:35:55,810 --> 00:36:01,009
from what I understood you based your

633
00:35:57,920 --> 00:36:02,600
attack on speculatively<font color="#E5E5E5"> getting the data</font>

634
00:36:01,010 --> 00:36:04,760
<font color="#E5E5E5">are computing an address from it and</font>

635
00:36:02,600 --> 00:36:06,350
doing a memory<font color="#E5E5E5"> access from it what</font>

636
00:36:04,760 --> 00:36:08,840
guarantees you that<font color="#E5E5E5"> you can speculate if</font>

637
00:36:06,350 --> 00:36:10,850
<font color="#CCCCCC">we execute</font><font color="#E5E5E5"> both getting the data and</font>

638
00:36:08,840 --> 00:36:14,270
computing<font color="#E5E5E5"> the address and doing the</font>

639
00:36:10,850 --> 00:36:16,610
access so what happens if the CPU

640
00:36:14,270 --> 00:36:20,420
<font color="#CCCCCC">rollbacks your instructions before</font><font color="#E5E5E5"> you</font>

641
00:36:16,610 --> 00:36:23,390
actually get to do the<font color="#E5E5E5"> memory access the</font>

642
00:36:20,420 --> 00:36:27,050
answer is pretty pretty simple<font color="#CCCCCC"> and</font>

643
00:36:23,390 --> 00:36:29,779
intuitive<font color="#E5E5E5"> you just try try again</font><font color="#CCCCCC"> okay</font>

644
00:36:27,050 --> 00:36:32,369
but how<font color="#CCCCCC"> many tries you to do do it</font>

645
00:36:29,780 --> 00:36:36,390
<font color="#CCCCCC">before you are sure that you</font>

646
00:36:32,369 --> 00:36:38,160
<font color="#CCCCCC">I've done all the instructions depends</font>

647
00:36:36,390 --> 00:36:40,469
<font color="#E5E5E5">on the load</font><font color="#CCCCCC"> and how many processes are</font>

648
00:36:38,160 --> 00:36:42,930
running<font color="#E5E5E5"> if there is a huge pressure on</font>

649
00:36:40,469 --> 00:36:45,150
<font color="#CCCCCC">the application many and the cache is</font>

650
00:36:42,930 --> 00:36:48,118
reloaded<font color="#E5E5E5"> and unloaded very frequently</font>

651
00:36:45,150 --> 00:36:50,640
<font color="#E5E5E5">and flashed very frequently or and</font>

652
00:36:48,119 --> 00:36:54,989
evicted very frequently then the chances

653
00:36:50,640 --> 00:36:57,390
might be view might be less but if there

654
00:36:54,989 --> 00:36:59,789
is an an idol and Idol system then the

655
00:36:57,390 --> 00:37:02,308
<font color="#CCCCCC">timing behavior</font><font color="#E5E5E5"> is pretty pretty</font>

656
00:36:59,789 --> 00:37:10,130
predictable<font color="#CCCCCC"> okay that's his answer your</font>

657
00:37:02,309 --> 00:37:12,559
question<font color="#E5E5E5"> yes thank you okay</font><font color="#CCCCCC"> thank you</font>

658
00:37:10,130 --> 00:37:22,950
other<font color="#CCCCCC"> questions</font>

659
00:37:12,559 --> 00:37:25,200
<font color="#CCCCCC">okay please do you see</font><font color="#E5E5E5"> hardware</font>

660
00:37:22,950 --> 00:37:27,269
solutions<font color="#E5E5E5"> coming to market</font><font color="#CCCCCC"> anytime soon</font>

661
00:37:25,200 --> 00:37:29,968
considering a lot of the infrastructure

662
00:37:27,269 --> 00:37:31,499
nowadays is especially<font color="#E5E5E5"> for small</font>

663
00:37:29,969 --> 00:37:33,749
companies<font color="#CCCCCC"> is shift to their own</font>

664
00:37:31,499 --> 00:37:37,279
<font color="#E5E5E5">garbage-collected languages but you</font>

665
00:37:33,749 --> 00:37:40,979
<font color="#E5E5E5">don't have</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> solution for this</font><font color="#CCCCCC"> yes I</font>

666
00:37:37,279 --> 00:37:42,900
<font color="#CCCCCC">expected because you Intel Intel is huge</font>

667
00:37:40,979 --> 00:37:45,149
and now they are aware<font color="#CCCCCC"> of</font><font color="#E5E5E5"> these this</font>

668
00:37:42,900 --> 00:37:48,779
kind<font color="#E5E5E5"> of attack and it's obviously a new</font>

669
00:37:45,150 --> 00:37:51,509
selling factor so I expect<font color="#E5E5E5"> I really</font>

670
00:37:48,779 --> 00:37:54,410
expected<font color="#E5E5E5"> yeah</font><font color="#CCCCCC"> and there is the the</font>

671
00:37:51,509 --> 00:37:58,729
<font color="#E5E5E5">latest Intel CPU design already has</font>

672
00:37:54,410 --> 00:38:01,848
protections for some<font color="#CCCCCC"> Spectre attacks</font>

673
00:37:58,729 --> 00:38:01,848
<font color="#E5E5E5">thank you</font>

674
00:38:06,090 --> 00:38:15,610
<font color="#E5E5E5">okay so um that's</font><font color="#CCCCCC"> about Scholl alright</font>

675
00:38:13,030 --> 00:38:17,530
<font color="#E5E5E5">so thank you so</font><font color="#CCCCCC"> much my own for being</font>

676
00:38:15,610 --> 00:38:19,300
patient<font color="#CCCCCC"> and answer all</font><font color="#E5E5E5"> the questions it</font>

677
00:38:17,530 --> 00:38:21,820
was<font color="#CCCCCC"> a very interesting presentation I</font>

678
00:38:19,300 --> 00:38:24,880
think<font color="#CCCCCC"> you are later on a panel that will</font>

679
00:38:21,820 --> 00:38:27,760
approach<font color="#CCCCCC"> almost the same subject</font><font color="#E5E5E5"> so you</font>

680
00:38:24,880 --> 00:38:31,320
can find<font color="#E5E5E5"> out more later or like in an</font>

681
00:38:27,760 --> 00:38:33,230
<font color="#E5E5E5">hour and a half so thank you again for</font>

682
00:38:31,320 --> 00:38:40,420
<font color="#CCCCCC">being just arose</font>

683
00:38:33,230 --> 00:38:40,420
[Applause]

