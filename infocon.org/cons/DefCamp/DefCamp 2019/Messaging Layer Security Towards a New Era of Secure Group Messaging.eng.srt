1
00:00:00,030 --> 00:00:19,619
good morning thank you for coming I see

2
00:00:04,140 --> 00:00:21,930
a few more people coming in all right so

3
00:00:19,619 --> 00:00:26,730
today I'll be talking about MLS

4
00:00:21,930 --> 00:00:29,939
messaging layer security and to give you

5
00:00:26,730 --> 00:00:32,219
a bit of context immediately MLS is a

6
00:00:29,939 --> 00:00:37,890
new protocol for end-to-end encrypted

7
00:00:32,219 --> 00:00:43,410
messaging and it is also an ITF working

8
00:00:37,890 --> 00:00:46,170
group and the question is why is this

9
00:00:43,410 --> 00:00:51,929
important now and this is what I'm going

10
00:00:46,170 --> 00:00:54,870
to focus on during the talk to introduce

11
00:00:51,930 --> 00:00:57,829
myself quickly my name is Rafa Robert I

12
00:00:54,870 --> 00:01:01,099
work for wire which is a secure

13
00:00:57,829 --> 00:01:03,510
messaging and collaboration platform

14
00:01:01,100 --> 00:01:07,110
it's open source which uses end-to-end

15
00:01:03,510 --> 00:01:10,619
encryption and I've been working there

16
00:01:07,110 --> 00:01:18,090
pretty much since day one when he was

17
00:01:10,619 --> 00:01:21,479
founded back in 2012 and Weyer is one of

18
00:01:18,090 --> 00:01:26,909
the companies that is part of this ITF

19
00:01:21,479 --> 00:01:31,079
working group for MLS it co initiated

20
00:01:26,909 --> 00:01:35,579
the idea back in 2016 but it's not the

21
00:01:31,079 --> 00:01:37,470
only company that takes part there so we

22
00:01:35,579 --> 00:01:40,559
have a number of other companies you

23
00:01:37,470 --> 00:01:44,039
might recognize here and most

24
00:01:40,560 --> 00:01:47,220
importantly we also have a number of

25
00:01:44,040 --> 00:01:49,409
universities who take part in that

26
00:01:47,220 --> 00:01:52,429
working group which is very important

27
00:01:49,409 --> 00:01:52,430
for new protocols

28
00:01:54,689 --> 00:02:00,329
so first we're going to briefly look at

29
00:01:57,390 --> 00:02:07,049
the current status of where we are today

30
00:02:00,329 --> 00:02:09,329
with secure messaging so we have a lot

31
00:02:07,049 --> 00:02:14,849
of secure messaging apps today and some

32
00:02:09,330 --> 00:02:17,400
of you probably use some of them some of

33
00:02:14,849 --> 00:02:20,488
them use very similar protocols but

34
00:02:17,400 --> 00:02:22,709
others arts are different but all of

35
00:02:20,489 --> 00:02:26,670
them more or less try to solve the same

36
00:02:22,709 --> 00:02:29,640
problem at the end of the day and what

37
00:02:26,670 --> 00:02:31,290
is problematic is that because the

38
00:02:29,640 --> 00:02:34,048
protocols are different and the details

39
00:02:31,290 --> 00:02:36,239
are different the the levels of analysis

40
00:02:34,049 --> 00:02:39,329
are also really different across

41
00:02:36,239 --> 00:02:44,099
different messengers and most of them

42
00:02:39,329 --> 00:02:46,410
maintain their own libraries and so we

43
00:02:44,099 --> 00:02:48,149
we have a bit of a zoo of different

44
00:02:46,410 --> 00:02:53,930
security levels of different security

45
00:02:48,150 --> 00:02:58,340
properties and if we take a step back

46
00:02:53,930 --> 00:03:01,370
and look a bit at the history of

47
00:02:58,340 --> 00:03:04,769
security properties in secure messaging

48
00:03:01,370 --> 00:03:08,190
so it really became popular in the 90s

49
00:03:04,769 --> 00:03:11,430
with PGP today we have open PGP as well

50
00:03:08,190 --> 00:03:14,669
as mime for end-to-end encryption for

51
00:03:11,430 --> 00:03:16,410
emails and the two properties that were

52
00:03:14,669 --> 00:03:19,639
introduced back then where

53
00:03:16,410 --> 00:03:21,930
confidentiality and authenticity

54
00:03:19,639 --> 00:03:24,630
confidentiality is simple it simply

55
00:03:21,930 --> 00:03:25,940
means things are encrypted third parties

56
00:03:24,630 --> 00:03:29,970
cannot look into it

57
00:03:25,940 --> 00:03:31,560
authenticity means you know who sent it

58
00:03:29,970 --> 00:03:35,250
you know who encrypted it or you know

59
00:03:31,560 --> 00:03:39,109
who signed it so this is the base layer

60
00:03:35,250 --> 00:03:43,500
of end-to-end encryption these days

61
00:03:39,109 --> 00:03:48,569
later on there was the off-the-record

62
00:03:43,500 --> 00:03:52,220
protocol I think around 2005 that added

63
00:03:48,569 --> 00:03:57,560
two new properties forward secrecy and

64
00:03:52,220 --> 00:04:00,720
deniability forward secrecy means that

65
00:03:57,560 --> 00:04:04,259
messages that were encrypted in the

66
00:04:00,720 --> 00:04:07,440
past's can no longer be decrypted in the

67
00:04:04,259 --> 00:04:08,429
future if there is a compromise an

68
00:04:07,440 --> 00:04:10,739
attacker gets on key

69
00:04:08,430 --> 00:04:13,590
material that key material is not good

70
00:04:10,739 --> 00:04:18,000
enough to decrypt all of the messages

71
00:04:13,590 --> 00:04:22,259
from the past deniability is a very

72
00:04:18,000 --> 00:04:24,300
controversial property whenever I speak

73
00:04:22,259 --> 00:04:26,100
about it there about 50 percent of the

74
00:04:24,300 --> 00:04:28,139
people who say that it's a very

75
00:04:26,100 --> 00:04:29,490
important one to have that was

76
00:04:28,139 --> 00:04:30,600
absolutely necessary

77
00:04:29,490 --> 00:04:34,199
others say that it's absolutely

78
00:04:30,600 --> 00:04:36,990
unnecessary it's it's very divisive and

79
00:04:34,199 --> 00:04:40,949
what it means essentially on different

80
00:04:36,990 --> 00:04:43,560
levels the idea is that messages for

81
00:04:40,949 --> 00:04:45,840
example can be authenticated in a way

82
00:04:43,560 --> 00:04:47,550
that the recipient understands that

83
00:04:45,840 --> 00:04:51,530
they're authenticated but the recipient

84
00:04:47,550 --> 00:04:54,060
can approve it to a third party that

85
00:04:51,530 --> 00:04:55,979
message was authored by a certain person

86
00:04:54,060 --> 00:04:58,830
and then there are more fine grained

87
00:04:55,979 --> 00:05:00,630
levels of deniability for example it

88
00:04:58,830 --> 00:05:06,479
could be deniable that a conversation

89
00:05:00,630 --> 00:05:08,340
ever happened as a whole and so this was

90
00:05:06,479 --> 00:05:11,460
really coined by you have the record

91
00:05:08,340 --> 00:05:17,539
protocol and and they split up

92
00:05:11,460 --> 00:05:19,680
deniability in in even more levels and

93
00:05:17,539 --> 00:05:22,680
then we have the double ratchet

94
00:05:19,680 --> 00:05:28,289
algorithm with which is the basis for

95
00:05:22,680 --> 00:05:30,990
the signal protocol these days and that

96
00:05:28,289 --> 00:05:33,510
is essentially an adaptation of what the

97
00:05:30,990 --> 00:05:36,180
of the red record protocol did in terms

98
00:05:33,510 --> 00:05:38,460
of security guarantees and it also

99
00:05:36,180 --> 00:05:41,280
introduced a new one which was called

100
00:05:38,460 --> 00:05:43,830
future secrecy and these days that is

101
00:05:41,280 --> 00:05:47,130
mostly referred to as post compromised

102
00:05:43,830 --> 00:05:49,020
security in academic circles the term is

103
00:05:47,130 --> 00:05:51,570
a little more telling what this is about

104
00:05:49,020 --> 00:05:54,960
so you can think of it as the exact

105
00:05:51,570 --> 00:05:58,050
opposite of forward secrecy where we

106
00:05:54,960 --> 00:05:59,729
care about messages from the past with

107
00:05:58,050 --> 00:06:01,680
future secrecy or post compromised

108
00:05:59,729 --> 00:06:04,469
security it's about the future as the

109
00:06:01,680 --> 00:06:06,509
name says and the question there is once

110
00:06:04,470 --> 00:06:10,500
a compromise has happened of an endpoint

111
00:06:06,509 --> 00:06:13,889
is there a way to recover from that on

112
00:06:10,500 --> 00:06:18,050
the same device and if yes then you do

113
00:06:13,889 --> 00:06:18,050
have post compromised security

114
00:06:21,540 --> 00:06:27,510
so what about groups because all of the

115
00:06:28,110 --> 00:06:31,240
protocols I've talked about so far

116
00:06:30,130 --> 00:06:33,610
they're for one-to-one communication

117
00:06:31,240 --> 00:06:36,280
email of course I mean you can send an

118
00:06:33,610 --> 00:06:38,290
email to more than one person but you

119
00:06:36,280 --> 00:06:40,059
will have to encrypt it individually and

120
00:06:38,290 --> 00:06:42,550
the same is true for the other record

121
00:06:40,060 --> 00:06:47,080
protocol and also for the signal

122
00:06:42,550 --> 00:06:51,250
protocol but the reality is we use

123
00:06:47,080 --> 00:06:53,380
messaging in groups a lot even in a one

124
00:06:51,250 --> 00:06:55,300
to one context if you have more than one

125
00:06:53,380 --> 00:07:00,340
device to some extent that is already a

126
00:06:55,300 --> 00:07:03,130
group of devices now and the practical

127
00:07:00,340 --> 00:07:06,179
problem here is that pairwise protocols

128
00:07:03,130 --> 00:07:09,940
as we call these one-to-one protocols

129
00:07:06,180 --> 00:07:12,400
they cannot just be extended so that

130
00:07:09,940 --> 00:07:15,490
they can be used in groups you cannot

131
00:07:12,400 --> 00:07:18,849
just add more endpoints to the - you

132
00:07:15,490 --> 00:07:20,110
already have so you have to resort to

133
00:07:18,850 --> 00:07:26,650
something else to address that

134
00:07:20,110 --> 00:07:29,110
particular problem and so what typically

135
00:07:26,650 --> 00:07:31,030
happens for example in the case of

136
00:07:29,110 --> 00:07:34,990
signal or in the case of wire and other

137
00:07:31,030 --> 00:07:37,000
messengers the pairwise channels they're

138
00:07:34,990 --> 00:07:39,310
being superposed to simulate a group so

139
00:07:37,000 --> 00:07:40,930
what that means is that if you send a

140
00:07:39,310 --> 00:07:42,520
message in a group you individually

141
00:07:40,930 --> 00:07:44,890
encrypt it to every recipient in the

142
00:07:42,520 --> 00:07:47,380
group or even worse you individually

143
00:07:44,890 --> 00:07:50,169
encrypt it to every device of every

144
00:07:47,380 --> 00:07:55,090
recipient in the group so that is not

145
00:07:50,169 --> 00:07:56,890
very efficient and so it might be that

146
00:07:55,090 --> 00:07:58,630
at the end of the day because of these

147
00:07:56,890 --> 00:08:00,280
efficiency problems you might go for a

148
00:07:58,630 --> 00:08:02,830
trade-off between security properties

149
00:08:00,280 --> 00:08:08,859
and scalability and we're going to look

150
00:08:02,830 --> 00:08:11,320
into that in more detail later so when

151
00:08:08,860 --> 00:08:15,220
you create a group on top of pairwise

152
00:08:11,320 --> 00:08:17,229
protocols you do that at a level that is

153
00:08:15,220 --> 00:08:20,950
really above the the initial protocol

154
00:08:17,229 --> 00:08:23,110
level and so every messenger does this

155
00:08:20,950 --> 00:08:27,130
differently even if a messenger uses the

156
00:08:23,110 --> 00:08:28,900
same layer underneath for example there

157
00:08:27,130 --> 00:08:30,490
is a number of messengers now using the

158
00:08:28,900 --> 00:08:32,309
signal protocol like whatsapp and

159
00:08:30,490 --> 00:08:35,159
Facebook

160
00:08:32,309 --> 00:08:39,478
and others what they do with groups on

161
00:08:35,159 --> 00:08:41,520
top of that is extremely proprietary so

162
00:08:39,479 --> 00:08:42,959
you have this layer of the secure

163
00:08:41,520 --> 00:08:45,930
one-to-one protocol and then you have

164
00:08:42,958 --> 00:08:52,140
this group management layer on top of

165
00:08:45,930 --> 00:08:55,500
that and the the the one-to-one protocol

166
00:08:52,140 --> 00:08:57,959
is often quite well analyzed again in

167
00:08:55,500 --> 00:09:01,050
the case of signal that is true out of

168
00:08:57,959 --> 00:09:02,939
other protocols has bins and scrutiny

169
00:09:01,050 --> 00:09:04,500
also in academia but the group

170
00:09:02,940 --> 00:09:11,040
management layer is typically not

171
00:09:04,500 --> 00:09:12,440
routinized at all so if we go back to

172
00:09:11,040 --> 00:09:17,160
this idea of having a trade-off between

173
00:09:12,440 --> 00:09:20,580
security properties and good scalability

174
00:09:17,160 --> 00:09:25,529
if we try to have a very simple chart

175
00:09:20,580 --> 00:09:27,420
here PGP would be in the lower left

176
00:09:25,529 --> 00:09:29,160
corner because it doesn't really have

177
00:09:27,420 --> 00:09:33,240
modern security it doesn't have forward

178
00:09:29,160 --> 00:09:35,699
security or sorry forward secrecy or

179
00:09:33,240 --> 00:09:40,709
post compromised security and it doesn't

180
00:09:35,700 --> 00:09:44,610
scale well then there are these

181
00:09:40,709 --> 00:09:47,040
messengers that are based on protocols

182
00:09:44,610 --> 00:09:50,670
that are more modern in a one-to-one

183
00:09:47,040 --> 00:09:52,439
setting and we call this client fan-out

184
00:09:50,670 --> 00:09:56,010
because it's a client fanning out the

185
00:09:52,440 --> 00:09:57,630
same message to all of the recipients so

186
00:09:56,010 --> 00:10:01,439
they have modern security guarantees but

187
00:09:57,630 --> 00:10:03,089
they still don't care very well and then

188
00:10:01,440 --> 00:10:06,690
we have a concept called sender keys

189
00:10:03,089 --> 00:10:10,620
which in a way it's in an adaptation of

190
00:10:06,690 --> 00:10:13,470
the signal protocol it's a hack used by

191
00:10:10,620 --> 00:10:17,459
whatsapp for example by facebook

192
00:10:13,470 --> 00:10:21,240
messenger also by matrix and the idea

193
00:10:17,459 --> 00:10:25,380
there is that they try to improve the

194
00:10:21,240 --> 00:10:26,850
efficiency a bit by sending out an

195
00:10:25,380 --> 00:10:31,230
encryption key to everybody in the group

196
00:10:26,850 --> 00:10:32,730
and using that key to encrypt future

197
00:10:31,230 --> 00:10:34,140
messages so that they don't have to

198
00:10:32,730 --> 00:10:36,899
individually encrypt them they can only

199
00:10:34,140 --> 00:10:39,569
do it once but sending out the key is

200
00:10:36,899 --> 00:10:41,400
still very expensive so you gain a bit

201
00:10:39,570 --> 00:10:43,829
of efficiency

202
00:10:41,400 --> 00:10:44,560
once you only send out messages but the

203
00:10:43,829 --> 00:10:46,270
setup is Dilek

204
00:10:44,560 --> 00:10:47,709
pensive so this is somewhere in the

205
00:10:46,270 --> 00:10:49,449
middle

206
00:10:47,710 --> 00:10:51,730
it's carrots a little better than the

207
00:10:49,450 --> 00:10:55,180
rice but the security is not that right

208
00:10:51,730 --> 00:10:56,920
anymore because you tend to not rotate

209
00:10:55,180 --> 00:11:00,760
keys are only rotate keys when it's

210
00:10:56,920 --> 00:11:04,750
absolutely necessary because it is still

211
00:11:00,760 --> 00:11:07,180
expensive so the the obvious question is

212
00:11:04,750 --> 00:11:08,620
could we have anything in the upper

213
00:11:07,180 --> 00:11:10,150
right corner here something that has

214
00:11:08,620 --> 00:11:17,080
very modern security but that also

215
00:11:10,150 --> 00:11:20,230
scales well in larger groups so what

216
00:11:17,080 --> 00:11:24,060
what would be the objective so if we say

217
00:11:20,230 --> 00:11:26,940
okay let's do a new messaging protocol

218
00:11:24,060 --> 00:11:30,550
what would we like to be in that

219
00:11:26,940 --> 00:11:32,560
protocol what if we were to write up a

220
00:11:30,550 --> 00:11:35,920
wish list what should be on that wish

221
00:11:32,560 --> 00:11:38,140
list so if we start with the security

222
00:11:35,920 --> 00:11:40,000
properties of course we want

223
00:11:38,140 --> 00:11:42,520
confidentiality and authenticity that's

224
00:11:40,000 --> 00:11:46,000
a strict minimum obviously we want

225
00:11:42,520 --> 00:11:51,760
forward secrecy we want post compromised

226
00:11:46,000 --> 00:11:54,700
security it sounds easy but this is

227
00:11:51,760 --> 00:11:58,000
really what makes things actually quite

228
00:11:54,700 --> 00:11:59,860
difficult to have that we want in AI

229
00:11:58,000 --> 00:12:02,230
ability as I said it's a very divisive

230
00:11:59,860 --> 00:12:07,990
thing so maybe we want it just

231
00:12:02,230 --> 00:12:11,620
optionally not for everybody and then we

232
00:12:07,990 --> 00:12:13,480
also want groups and and we could come

233
00:12:11,620 --> 00:12:15,040
up with some new security properties so

234
00:12:13,480 --> 00:12:19,750
for example in a group it would be nice

235
00:12:15,040 --> 00:12:22,719
to have authentication of members in a

236
00:12:19,750 --> 00:12:25,030
group because right now if you recall

237
00:12:22,720 --> 00:12:27,430
this group management layer the way most

238
00:12:25,030 --> 00:12:29,290
messengers work is that there is no

239
00:12:27,430 --> 00:12:33,069
particular guarantee that all the

240
00:12:29,290 --> 00:12:39,849
clients in a group see the same set of

241
00:12:33,070 --> 00:12:42,370
members and so you you either trust with

242
00:12:39,850 --> 00:12:45,250
what other members in the group told you

243
00:12:42,370 --> 00:12:46,390
or you trust a server for example but

244
00:12:45,250 --> 00:12:48,700
you don't have any cryptographic

245
00:12:46,390 --> 00:12:50,800
guarantee of who's really in the group

246
00:12:48,700 --> 00:12:53,980
and when you receive a message for

247
00:12:50,800 --> 00:12:56,030
example you you cannot tell for sure who

248
00:12:53,980 --> 00:12:59,600
this message was encrypted

249
00:12:56,030 --> 00:13:06,740
for except for yourself so there's some

250
00:12:59,600 --> 00:13:10,210
room for improvement here clearly so

251
00:13:06,740 --> 00:13:12,920
what else do we want that is maybe not

252
00:13:10,210 --> 00:13:15,380
security related strictly speaking when

253
00:13:12,920 --> 00:13:17,689
we do a protocol so we wanted to be

254
00:13:15,380 --> 00:13:19,130
asynchronous and this is what made all

255
00:13:17,690 --> 00:13:22,820
the difference between the

256
00:13:19,130 --> 00:13:25,850
off-the-record protocol and what we now

257
00:13:22,820 --> 00:13:29,540
know as the signal protocol the of the

258
00:13:25,850 --> 00:13:31,220
record protocol was designed to be in an

259
00:13:29,540 --> 00:13:34,040
online session if you remember the old

260
00:13:31,220 --> 00:13:35,390
days of Skype for example both sides had

261
00:13:34,040 --> 00:13:39,890
to be online at the same time for

262
00:13:35,390 --> 00:13:42,439
messages to arrive and so this is not

263
00:13:39,890 --> 00:13:43,910
something that works anymore in the

264
00:13:42,440 --> 00:13:45,290
world of smart phones because smart

265
00:13:43,910 --> 00:13:47,540
phones are sometimes online sometimes

266
00:13:45,290 --> 00:13:49,959
offline sometimes you think you're

267
00:13:47,540 --> 00:13:52,490
online but you're not really online so

268
00:13:49,960 --> 00:13:55,000
things have to be I synchronous here

269
00:13:52,490 --> 00:13:58,850
cannot wait for people to come online

270
00:13:55,000 --> 00:14:01,280
another prominent example is in telegram

271
00:13:58,850 --> 00:14:02,840
for example when you go for these secret

272
00:14:01,280 --> 00:14:04,240
conversations where there is actually

273
00:14:02,840 --> 00:14:07,670
some sort of end-to-end encryption

274
00:14:04,240 --> 00:14:09,410
taking place you have to wait for the

275
00:14:07,670 --> 00:14:12,709
other party to come online first before

276
00:14:09,410 --> 00:14:16,910
you can initiate such a chat so that's

277
00:14:12,710 --> 00:14:18,590
not a great user experience of course we

278
00:14:16,910 --> 00:14:20,510
want groups so we want support for large

279
00:14:18,590 --> 00:14:23,210
and dynamic groups dynamic meaning

280
00:14:20,510 --> 00:14:26,150
people can come and go frequently and we

281
00:14:23,210 --> 00:14:28,640
want that to scale efficiently we also

282
00:14:26,150 --> 00:14:31,459
want multi device support because the

283
00:14:28,640 --> 00:14:36,439
reality is most of us have more than one

284
00:14:31,460 --> 00:14:40,310
device we use for messaging we would

285
00:14:36,440 --> 00:14:42,620
also like to not be tied necessarily to

286
00:14:40,310 --> 00:14:44,689
only one service provider for messaging

287
00:14:42,620 --> 00:14:48,530
it would be nice if the protocol would

288
00:14:44,690 --> 00:14:51,530
inherently support more than one server

289
00:14:48,530 --> 00:14:56,600
or more than one service and this is

290
00:14:51,530 --> 00:14:58,520
generally known as Federation and last

291
00:14:56,600 --> 00:15:01,490
but not least we want this to be usable

292
00:14:58,520 --> 00:15:02,960
so we don't we don't want an academic

293
00:15:01,490 --> 00:15:05,680
effort that looks really good on paper

294
00:15:02,960 --> 00:15:07,820
but that cannot be implemented because

295
00:15:05,680 --> 00:15:09,099
somebody made some assumption that

296
00:15:07,820 --> 00:15:12,430
doesn't really hold in the

297
00:15:09,100 --> 00:15:15,790
real-world so this part is really

298
00:15:12,430 --> 00:15:18,640
important so that a new protocol can

299
00:15:15,790 --> 00:15:21,160
actually be a replacement for either

300
00:15:18,640 --> 00:15:26,530
nothing or whatever was used previously

301
00:15:21,160 --> 00:15:28,449
in messengers what else could we wish

302
00:15:26,530 --> 00:15:32,709
for since we have the liberty of coming

303
00:15:28,450 --> 00:15:35,710
up with wishes here it should be an open

304
00:15:32,710 --> 00:15:37,540
standard the specification should be

305
00:15:35,710 --> 00:15:40,360
there for everybody to read for

306
00:15:37,540 --> 00:15:43,510
everybody to implement that and and for

307
00:15:40,360 --> 00:15:49,840
everybody to criticize as well and to

308
00:15:43,510 --> 00:15:51,640
analyze that's very important and the

309
00:15:49,840 --> 00:15:53,710
other thing is that if if you don't want

310
00:15:51,640 --> 00:15:55,540
to implement something yourself there

311
00:15:53,710 --> 00:15:59,680
should be enough libraries you can use

312
00:15:55,540 --> 00:16:01,360
and we've a great example there is TLS

313
00:15:59,680 --> 00:16:04,060
for example so TLS is an open standard

314
00:16:01,360 --> 00:16:05,710
anybody can implement it but typically

315
00:16:04,060 --> 00:16:07,479
what most developers will do at the end

316
00:16:05,710 --> 00:16:11,380
of the day they're gonna pick a library

317
00:16:07,480 --> 00:16:15,280
that they like and are going to use that

318
00:16:11,380 --> 00:16:18,850
so this is also important and I already

319
00:16:15,280 --> 00:16:20,589
mentioned the security analysis this is

320
00:16:18,850 --> 00:16:26,290
something relatively new in the design

321
00:16:20,590 --> 00:16:28,750
of protocols so far it used to be the

322
00:16:26,290 --> 00:16:33,040
case that after protocol was created the

323
00:16:28,750 --> 00:16:34,960
security was analyzed afterwards then it

324
00:16:33,040 --> 00:16:37,469
became a little more frequent that

325
00:16:34,960 --> 00:16:42,030
during the design phase of a protocol

326
00:16:37,470 --> 00:16:44,770
academic consideration was already

327
00:16:42,030 --> 00:16:50,380
accounted for and a great example there

328
00:16:44,770 --> 00:16:53,350
is TLS 1.3 where developers have worked

329
00:16:50,380 --> 00:16:56,320
hand-in-hand with academia to come up

330
00:16:53,350 --> 00:17:00,420
with her protocol and to have a security

331
00:16:56,320 --> 00:17:00,420
analysis during the design phase already

332
00:17:02,880 --> 00:17:07,990
so now let's talk a bit more about MLS

333
00:17:05,319 --> 00:17:10,780
and and see if you know MLS could

334
00:17:07,990 --> 00:17:13,450
potentially be the answer to this wish

335
00:17:10,780 --> 00:17:18,490
list and these questions a very brief

336
00:17:13,450 --> 00:17:21,340
overview of the history in 2015 an

337
00:17:18,490 --> 00:17:22,750
academic paper was published by the

338
00:17:21,339 --> 00:17:26,530
University of Oxford and

339
00:17:22,750 --> 00:17:28,329
Facebook and they thought about solving

340
00:17:26,530 --> 00:17:31,450
the problem of having more efficient

341
00:17:28,329 --> 00:17:34,870
messaging in very large groups and came

342
00:17:31,450 --> 00:17:37,540
up with the idea of using binary trees

343
00:17:34,870 --> 00:17:40,300
for that so art stands for asynchronous

344
00:17:37,540 --> 00:17:44,740
ratcheting trees so there was a first

345
00:17:40,300 --> 00:17:47,860
foray on the scientific level in 2016 a

346
00:17:44,740 --> 00:17:50,290
number of company gathered actually at

347
00:17:47,860 --> 00:17:52,179
the wire office incidentally and and

348
00:17:50,290 --> 00:17:53,770
they all agreed that there is a problem

349
00:17:52,180 --> 00:17:55,420
with messaging we we need an open

350
00:17:53,770 --> 00:18:00,250
standard and we needed to be more

351
00:17:55,420 --> 00:18:04,450
efficient and so a little less than two

352
00:18:00,250 --> 00:18:07,630
years later in March 2018 at the ITF in

353
00:18:04,450 --> 00:18:11,260
London there was the birds of a feather

354
00:18:07,630 --> 00:18:14,980
meeting which is the inception of an ITF

355
00:18:11,260 --> 00:18:19,840
working group and it became officially a

356
00:18:14,980 --> 00:18:22,750
working group in May 2018 and ever since

357
00:18:19,840 --> 00:18:25,240
they've been regular meetings so there

358
00:18:22,750 --> 00:18:27,760
are some analogies between MLS and TLS

359
00:18:25,240 --> 00:18:29,470
no no the name the idea is to take all

360
00:18:27,760 --> 00:18:31,480
the good ideas from the the design

361
00:18:29,470 --> 00:18:34,960
process of TLS and to also apply that to

362
00:18:31,480 --> 00:18:37,630
MLS so conceptually if we look at the

363
00:18:34,960 --> 00:18:40,690
scope of TLS we have a certain transport

364
00:18:37,630 --> 00:18:44,920
layer over which previously we would

365
00:18:40,690 --> 00:18:49,780
send message content like HTTP SMTP sip

366
00:18:44,920 --> 00:18:52,090
at cetera and and TLS fits right in

367
00:18:49,780 --> 00:18:58,480
there and add security you were

368
00:18:52,090 --> 00:19:01,060
previously there was no security and it

369
00:18:58,480 --> 00:19:03,190
has one interface essentially and that

370
00:19:01,060 --> 00:19:05,020
is for authentication so you all know

371
00:19:03,190 --> 00:19:08,650
that from TLS there are certificates you

372
00:19:05,020 --> 00:19:11,800
can verify them there's certificate

373
00:19:08,650 --> 00:19:15,490
authorities so there is in a more

374
00:19:11,800 --> 00:19:19,510
abstract term there is a PKI and that is

375
00:19:15,490 --> 00:19:22,120
the interface to TLS and so we want MLS

376
00:19:19,510 --> 00:19:24,970
to be similar in a way that we have a

377
00:19:22,120 --> 00:19:27,040
base layer where we now take TLS or at

378
00:19:24,970 --> 00:19:28,450
least something similar where we have

379
00:19:27,040 --> 00:19:30,580
some transport encryption between

380
00:19:28,450 --> 00:19:32,200
clients and servers but it's not

381
00:19:30,580 --> 00:19:34,000
end-to-end yet then we have some

382
00:19:32,200 --> 00:19:36,309
application layer on top of that for

383
00:19:34,000 --> 00:19:39,580
typically messages but it could be five

384
00:19:36,309 --> 00:19:42,668
the other other things and so we want

385
00:19:39,580 --> 00:19:44,259
MLS to to fit right in there just like

386
00:19:42,669 --> 00:19:46,690
the a-listers we have the security

387
00:19:44,259 --> 00:19:52,470
protocol and we have a similar interface

388
00:19:46,690 --> 00:19:55,899
for an authentication service which

389
00:19:52,470 --> 00:19:59,259
again like TLS is a little outside so

390
00:19:55,899 --> 00:20:01,840
certificates are not part of TLS they

391
00:19:59,259 --> 00:20:04,619
live next to TLS conceptually and we

392
00:20:01,840 --> 00:20:08,559
want to have the same distinction here

393
00:20:04,619 --> 00:20:10,509
so that on the on the server side of MLS

394
00:20:08,559 --> 00:20:12,549
we only have two components there is one

395
00:20:10,509 --> 00:20:14,830
authentication service which is not

396
00:20:12,549 --> 00:20:16,720
particularly specified how it works the

397
00:20:14,830 --> 00:20:19,269
the whole idea is that it can provide

398
00:20:16,720 --> 00:20:22,119
some authenticity for users so users

399
00:20:19,269 --> 00:20:25,019
could have signing keys certificates

400
00:20:22,119 --> 00:20:28,029
that that's really up to the application

401
00:20:25,019 --> 00:20:30,519
and then there is a delivery service and

402
00:20:28,029 --> 00:20:34,149
the delivery service is really just a

403
00:20:30,519 --> 00:20:36,669
coordinator of messages so users can

404
00:20:34,149 --> 00:20:39,699
have multiple clients and we have some

405
00:20:36,669 --> 00:20:41,289
sort of a bus where messages are sent

406
00:20:39,700 --> 00:20:44,679
from a client to a server and the server

407
00:20:41,289 --> 00:20:47,099
fans them out and and that's pretty much

408
00:20:44,679 --> 00:20:50,679
all that is happening on the server side

409
00:20:47,099 --> 00:20:53,470
but there are also a lot of differences

410
00:20:50,679 --> 00:20:55,450
between MLS and TLS so for example TLS

411
00:20:53,470 --> 00:20:57,970
is a conceptually a client-server

412
00:20:55,450 --> 00:21:01,359
protocol so we have two endpoints in MLS

413
00:20:57,970 --> 00:21:04,239
we have a lot of endpoints it's designed

414
00:21:01,359 --> 00:21:06,249
for groups and we also have very

415
00:21:04,239 --> 00:21:10,570
long-lived sessions TLS sessions are

416
00:21:06,249 --> 00:21:12,519
typically very short a few seconds but

417
00:21:10,570 --> 00:21:15,720
here we could have sessions in a group

418
00:21:12,519 --> 00:21:18,039
that can last for months or years even

419
00:21:15,720 --> 00:21:22,029
we also have a lot of mobile devices

420
00:21:18,039 --> 00:21:25,629
involved and we have to design for that

421
00:21:22,029 --> 00:21:28,629
and and the scope here is really for

422
00:21:25,629 --> 00:21:29,949
human to human communication whereas TLS

423
00:21:28,629 --> 00:21:31,748
is actually a machine to machine

424
00:21:29,950 --> 00:21:34,389
communication where there is no human

425
00:21:31,749 --> 00:21:37,019
interaction needed as such unless unless

426
00:21:34,389 --> 00:21:41,580
you have served signed certificates

427
00:21:37,019 --> 00:21:44,409
probably all have had that situation and

428
00:21:41,580 --> 00:21:46,658
so what what's really different here is

429
00:21:44,409 --> 00:21:49,420
that the probability that a member gets

430
00:21:46,659 --> 00:21:51,040
compromised during one of these really

431
00:21:49,420 --> 00:21:54,460
lived sessions of MLS is a lot higher

432
00:21:51,040 --> 00:22:04,180
than with TLS so this is something that

433
00:21:54,460 --> 00:22:05,830
we need to account for so going back to

434
00:22:04,180 --> 00:22:08,890
fort secrecy and post compromised

435
00:22:05,830 --> 00:22:11,439
security to put that in maybe more

436
00:22:08,890 --> 00:22:13,330
understandable terms if we assume that

437
00:22:11,440 --> 00:22:19,150
at some point an endpoint will get

438
00:22:13,330 --> 00:22:20,770
compromised we afford a security that

439
00:22:19,150 --> 00:22:24,580
will protect whatever happened before

440
00:22:20,770 --> 00:22:27,639
the compromise and then we have post

441
00:22:24,580 --> 00:22:30,340
compromised security that tries to cover

442
00:22:27,640 --> 00:22:34,360
whatever happens afterwards and and so

443
00:22:30,340 --> 00:22:36,580
this is this is newer conceptually

444
00:22:34,360 --> 00:22:38,770
because the idea here is that an

445
00:22:36,580 --> 00:22:41,530
endpoint gets compromised once it's not

446
00:22:38,770 --> 00:22:43,840
a permanent compromise so for example

447
00:22:41,530 --> 00:22:46,360
somebody has access to a computer once

448
00:22:43,840 --> 00:22:49,179
or gets you know goods that finds a hard

449
00:22:46,360 --> 00:22:50,919
drive gets a copy of that it's a copy of

450
00:22:49,180 --> 00:22:55,390
all of the cryptographic material that

451
00:22:50,920 --> 00:22:57,280
is on the endpoint but we want the

452
00:22:55,390 --> 00:22:59,350
endpoint to be able to recover from such

453
00:22:57,280 --> 00:23:01,870
a compromise and we want to keep this

454
00:22:59,350 --> 00:23:05,469
window around the compromise as small as

455
00:23:01,870 --> 00:23:09,340
possible so that an attacker if they

456
00:23:05,470 --> 00:23:12,250
ever get their hands on key material

457
00:23:09,340 --> 00:23:13,840
that the damage they can do is as

458
00:23:12,250 --> 00:23:18,180
limited as possible

459
00:23:13,840 --> 00:23:22,929
and the very obvious answer here is to

460
00:23:18,180 --> 00:23:28,330
rotate keys as frequently as possible so

461
00:23:22,930 --> 00:23:30,550
if we try to decompose the the evolution

462
00:23:28,330 --> 00:23:32,169
of a group chat into sections for

463
00:23:30,550 --> 00:23:34,419
example so imagine analyst creates a

464
00:23:32,170 --> 00:23:37,840
group is Bob and then starting a group

465
00:23:34,420 --> 00:23:39,160
of two and and we call this an epoch so

466
00:23:37,840 --> 00:23:44,100
we don't know how long that will last

467
00:23:39,160 --> 00:23:47,590
but we we try to divide time into a box

468
00:23:44,100 --> 00:23:49,689
that are separated by a certain event so

469
00:23:47,590 --> 00:23:52,360
an event could be Alice adds Charlie to

470
00:23:49,690 --> 00:23:59,130
the group now and so this initiates a

471
00:23:52,360 --> 00:24:01,590
new epoch or Bob updates a key for

472
00:23:59,130 --> 00:24:06,659
inside the group or Alice removes

473
00:24:01,590 --> 00:24:09,840
Charlie so for every epoch we want fresh

474
00:24:06,659 --> 00:24:12,630
key material at the very least so that

475
00:24:09,840 --> 00:24:16,379
means that between epoch three and four

476
00:24:12,630 --> 00:24:19,080
for example when Alice removes Charlie

477
00:24:16,380 --> 00:24:21,840
in epoch for the key material that we

478
00:24:19,080 --> 00:24:23,340
use will not be known to Charlie anymore

479
00:24:21,840 --> 00:24:26,010
because Charlie has been removed and

480
00:24:23,340 --> 00:24:29,520
likewise be between epoch one and epoch

481
00:24:26,010 --> 00:24:31,980
- when Alice adds Charlie Charlie should

482
00:24:29,520 --> 00:24:34,020
not have access to the key material

483
00:24:31,980 --> 00:24:35,700
using epoch one because that was

484
00:24:34,020 --> 00:24:40,559
specific to the conversation between

485
00:24:35,700 --> 00:24:42,059
Alice and Bob but we can we can even be

486
00:24:40,559 --> 00:24:45,539
more fine-grained than that and if we

487
00:24:42,059 --> 00:24:48,779
zoom in to epoch one for example we

488
00:24:45,539 --> 00:24:51,090
would also like every message to be to

489
00:24:48,779 --> 00:24:53,340
have its own key essentially within the

490
00:24:51,090 --> 00:24:55,320
epoch and the idea here is that both

491
00:24:53,340 --> 00:24:59,279
Alice and Bob were the only members at

492
00:24:55,320 --> 00:25:01,279
that time have the same key material in

493
00:24:59,279 --> 00:25:03,419
that they could derive the same keys

494
00:25:01,279 --> 00:25:06,390
independently on their side and then

495
00:25:03,419 --> 00:25:09,090
they can use this key 1 2 3 it's a try

496
00:25:06,390 --> 00:25:11,570
to encrypt the messages they're going to

497
00:25:09,090 --> 00:25:14,820
exchange an epoch one

498
00:25:11,570 --> 00:25:16,590
so before we start before we can

499
00:25:14,820 --> 00:25:18,990
initialize secure communication we

500
00:25:16,590 --> 00:25:21,330
always need some initial key material we

501
00:25:18,990 --> 00:25:24,120
know that from PGP signal has a concept

502
00:25:21,330 --> 00:25:26,210
of pre keys certain mls we call them in

503
00:25:24,120 --> 00:25:29,250
it keys and their keys that are

504
00:25:26,210 --> 00:25:31,620
published ahead of time by clients that

505
00:25:29,250 --> 00:25:34,190
can be retrieved to the delivery service

506
00:25:31,620 --> 00:25:39,059
and are generally available to initiate

507
00:25:34,190 --> 00:25:41,010
a secure session so they contain

508
00:25:39,059 --> 00:25:43,830
credentials and any public key more or

509
00:25:41,010 --> 00:25:47,190
less and and some more metadata that is

510
00:25:43,830 --> 00:25:49,529
relevant this part is not particularly

511
00:25:47,190 --> 00:25:52,799
new what is really new is the core

512
00:25:49,529 --> 00:25:54,659
protocol of MLS it started with art and

513
00:25:52,799 --> 00:25:57,210
synchronous ratcheting trees and then we

514
00:25:54,659 --> 00:26:00,000
moved on to a concept designed at INRIA

515
00:25:57,210 --> 00:26:02,250
and Paris called tree chem which is

516
00:26:00,000 --> 00:26:05,309
similar in the sense that we also have

517
00:26:02,250 --> 00:26:07,500
binary trees here which we use for

518
00:26:05,309 --> 00:26:09,029
efficiency and we'll see why in just a

519
00:26:07,500 --> 00:26:11,340
minute

520
00:26:09,029 --> 00:26:13,860
but it is a lot more flexible

521
00:26:11,340 --> 00:26:16,560
than art so art was not really designed

522
00:26:13,860 --> 00:26:18,780
for dynamic groups it was there was no

523
00:26:16,560 --> 00:26:21,899
clear mechanism of how you can add and

524
00:26:18,780 --> 00:26:23,550
remove people which in the real world is

525
00:26:21,900 --> 00:26:26,640
of course a problem because you don't

526
00:26:23,550 --> 00:26:31,050
just create one static group forever you

527
00:26:26,640 --> 00:26:35,840
want to add and remove people so we

528
00:26:31,050 --> 00:26:39,270
start by having a binary tree and

529
00:26:35,840 --> 00:26:42,990
putting all the members from A to F at

530
00:26:39,270 --> 00:26:44,160
the bottom which we call the leaves of a

531
00:26:42,990 --> 00:26:45,990
tree so if you've never seen a binary

532
00:26:44,160 --> 00:26:47,490
tree before there trees but upside down

533
00:26:45,990 --> 00:26:51,510
so the leaves at the bottom and the root

534
00:26:47,490 --> 00:26:54,480
is at the top and essentially we are we

535
00:26:51,510 --> 00:26:56,820
just take the these init Keys we have

536
00:26:54,480 --> 00:27:00,810
and put them there and then we can see

537
00:26:56,820 --> 00:27:02,639
what we do with that and we have these

538
00:27:00,810 --> 00:27:06,750
intermediate nodes above that and at the

539
00:27:02,640 --> 00:27:09,330
very top we have the root and there is

540
00:27:06,750 --> 00:27:13,920
one invariant that we define and the

541
00:27:09,330 --> 00:27:17,939
invariant is that every member at the

542
00:27:13,920 --> 00:27:20,880
leaves knows the secrets that are stored

543
00:27:17,940 --> 00:27:23,190
in the nodes above them so in this

544
00:27:20,880 --> 00:27:25,650
instance a for example we know the

545
00:27:23,190 --> 00:27:29,310
secret that is stored in G in J and

546
00:27:25,650 --> 00:27:33,900
finally in K again this is just the

547
00:27:29,310 --> 00:27:38,220
definition at this point and we define

548
00:27:33,900 --> 00:27:40,200
that K the root is essentially a group

549
00:27:38,220 --> 00:27:44,730
secret known to everybody because

550
00:27:40,200 --> 00:27:56,130
everybody should know that as as per

551
00:27:44,730 --> 00:27:59,510
this secrecy invariant so if we follow

552
00:27:56,130 --> 00:28:02,370
up with that we get a very nice property

553
00:27:59,510 --> 00:28:08,160
here and that is that we have subgroups

554
00:28:02,370 --> 00:28:10,949
in the tree so we have intermediate

555
00:28:08,160 --> 00:28:12,660
nodes that have children and since all

556
00:28:10,950 --> 00:28:14,940
the children know the secret of the

557
00:28:12,660 --> 00:28:17,100
intermediary node what we can do is we

558
00:28:14,940 --> 00:28:19,920
can encrypt secrets to an intermediary

559
00:28:17,100 --> 00:28:22,500
node so for example if we wanted to send

560
00:28:19,920 --> 00:28:23,909
a secret to C and B we don't have to do

561
00:28:22,500 --> 00:28:26,639
that individually anymore

562
00:28:23,909 --> 00:28:29,489
we can send the secret to H and then C

563
00:28:26,639 --> 00:28:33,238
and D can decrypt that through you know

564
00:28:29,489 --> 00:28:34,799
cam mechanism for example so we've we've

565
00:28:33,239 --> 00:28:37,739
already become more efficient here and

566
00:28:34,799 --> 00:28:40,408
then likewise with J we send a secret to

567
00:28:37,739 --> 00:28:43,409
J we have effectively sent a secret to a

568
00:28:40,409 --> 00:28:45,509
B C and D and of course if we send it to

569
00:28:43,409 --> 00:28:47,429
K we send it to everybody so we have

570
00:28:45,509 --> 00:28:53,699
subgroups and which is extremely

571
00:28:47,429 --> 00:28:56,069
practical to be more efficient and of

572
00:28:53,699 --> 00:28:58,709
course the the private key of the root K

573
00:28:56,069 --> 00:29:02,249
here is known to everybody at any given

574
00:28:58,709 --> 00:29:04,859
time so now we need some abstract

575
00:29:02,249 --> 00:29:06,239
operations to work in groups and one and

576
00:29:04,859 --> 00:29:08,609
they're very intuitive so one is you

577
00:29:06,239 --> 00:29:10,289
create a group you add a member you

578
00:29:08,609 --> 00:29:11,728
remove a member and then there is one

579
00:29:10,289 --> 00:29:13,679
that is a little less intuitive it's

580
00:29:11,729 --> 00:29:15,719
called an update and the idea here is

581
00:29:13,679 --> 00:29:20,249
that we update the key material in the

582
00:29:15,719 --> 00:29:22,440
tree in particular in K so that we can

583
00:29:20,249 --> 00:29:30,089
get some freshness have some fresh ki

584
00:29:22,440 --> 00:29:36,029
material for the group so let's look at

585
00:29:30,089 --> 00:29:39,408
this mechanism first for update so

586
00:29:36,029 --> 00:29:42,329
imagine F wants to update the group key

587
00:29:39,409 --> 00:29:44,940
in order to reduce this this window

588
00:29:42,329 --> 00:29:49,229
around the compromised or the potential

589
00:29:44,940 --> 00:29:54,089
compromise so what F does it generates a

590
00:29:49,229 --> 00:29:56,639
fresh leaf key in red here and then it

591
00:29:54,089 --> 00:29:59,698
takes the secret of that and it will

592
00:29:56,639 --> 00:30:02,639
literally hash it and store the hash in

593
00:29:59,699 --> 00:30:05,849
I and hash it again and store that in K

594
00:30:02,639 --> 00:30:07,918
and so the path from F to K we call that

595
00:30:05,849 --> 00:30:12,208
the direct path because it's its direct

596
00:30:07,919 --> 00:30:14,789
from F to the root so what happened now

597
00:30:12,209 --> 00:30:19,229
is that we have a new group secret in K

598
00:30:14,789 --> 00:30:21,089
that is whatever was in F hashed a

599
00:30:19,229 --> 00:30:25,079
number of times depending on on how tall

600
00:30:21,089 --> 00:30:27,269
the tree is so f is fine with that but

601
00:30:25,079 --> 00:30:29,969
nobody else knows about it so what we

602
00:30:27,269 --> 00:30:31,559
need to do now is to tell the rest of

603
00:30:29,969 --> 00:30:33,929
the group with the new group secret is

604
00:30:31,559 --> 00:30:36,359
we could of course tell everybody

605
00:30:33,929 --> 00:30:37,260
individually but that would not be

606
00:30:36,359 --> 00:30:39,330
efficient so what

607
00:30:37,260 --> 00:30:42,750
we do instead is we reuse these

608
00:30:39,330 --> 00:30:45,960
subgroups so next to the direct path in

609
00:30:42,750 --> 00:30:50,790
orange here there is another path in

610
00:30:45,960 --> 00:30:53,850
blue which is the siblings of the orange

611
00:30:50,790 --> 00:30:56,250
path so sibling is when you have nodes

612
00:30:53,850 --> 00:30:59,040
in a tree that have two children then

613
00:30:56,250 --> 00:31:03,300
these two children are siblings to each

614
00:30:59,040 --> 00:31:06,950
other so J is a sibling of I and E is a

615
00:31:03,300 --> 00:31:11,100
sibling of F so all we need to do now is

616
00:31:06,950 --> 00:31:13,950
to encrypt these new secrets to E and J

617
00:31:11,100 --> 00:31:15,709
and that means that we have effectively

618
00:31:13,950 --> 00:31:20,630
encrypted it to everybody in the group

619
00:31:15,710 --> 00:31:20,630
so the blue path is called the crow path

620
00:31:25,400 --> 00:31:31,320
so it's it's a little complicated when

621
00:31:29,550 --> 00:31:32,580
Sita for the first time but after a

622
00:31:31,320 --> 00:31:36,450
while it starts to make a lot of sense

623
00:31:32,580 --> 00:31:37,949
and so we when we create a group we

624
00:31:36,450 --> 00:31:42,210
create it with a completely empty tree

625
00:31:37,950 --> 00:31:44,250
where we only populate the leaves and so

626
00:31:42,210 --> 00:31:45,840
the problem we have here is that this is

627
00:31:44,250 --> 00:31:47,790
not very efficient because we don't have

628
00:31:45,840 --> 00:31:51,570
these sub groups to encrypt to so

629
00:31:47,790 --> 00:31:54,270
initially we have to do operations again

630
00:31:51,570 --> 00:31:57,899
individually to all n members of the

631
00:31:54,270 --> 00:32:01,280
group but we can very quickly make it

632
00:31:57,900 --> 00:32:05,730
more efficient by actually having each

633
00:32:01,280 --> 00:32:07,590
leaf or each member do an update and as

634
00:32:05,730 --> 00:32:10,230
they do so they will populate their

635
00:32:07,590 --> 00:32:13,560
direct path all the way to the top and

636
00:32:10,230 --> 00:32:15,870
if just a few of them do that then the

637
00:32:13,560 --> 00:32:18,480
the top of the tree gets populated very

638
00:32:15,870 --> 00:32:24,330
quickly and you can again use these sub

639
00:32:18,480 --> 00:32:29,190
groups to reach a lot of members so when

640
00:32:24,330 --> 00:32:34,310
we want to add a member to the group we

641
00:32:29,190 --> 00:32:37,140
add their init keys at the leaves and

642
00:32:34,310 --> 00:32:42,240
then they in turn when they come online

643
00:32:37,140 --> 00:32:44,220
they will update so what if we want to

644
00:32:42,240 --> 00:32:50,310
remove somebody from a tree so we want

645
00:32:44,220 --> 00:32:50,790
to remove D now so and a wants to do

646
00:32:50,310 --> 00:32:53,010
that

647
00:32:50,790 --> 00:32:56,129
so Ellie sends a message to the rest of

648
00:32:53,010 --> 00:32:58,710
the group or 12 actually everybody

649
00:32:56,130 --> 00:33:04,410
including these saying we want to remove

650
00:32:58,710 --> 00:33:07,560
D or I want to remove D and so what we

651
00:33:04,410 --> 00:33:10,860
do now is that we have to erase some

652
00:33:07,560 --> 00:33:12,419
nodes here because there is a secrecy

653
00:33:10,860 --> 00:33:14,969
invariant that says that everybody

654
00:33:12,420 --> 00:33:17,610
should know the secret on their direct

655
00:33:14,970 --> 00:33:19,950
path now since we removed D D is not

656
00:33:17,610 --> 00:33:21,540
allowed to know anything anymore so we

657
00:33:19,950 --> 00:33:27,420
need to delete everything that is above

658
00:33:21,540 --> 00:33:30,840
D and once that's the case we have

659
00:33:27,420 --> 00:33:32,970
effectively evicted D but we've also

660
00:33:30,840 --> 00:33:34,470
destroyed the tree a little bit and made

661
00:33:32,970 --> 00:33:37,080
it less efficient so what happens here

662
00:33:34,470 --> 00:33:38,880
is that we we don't have a whole group

663
00:33:37,080 --> 00:33:41,939
anymore we have a bunch of subgroups so

664
00:33:38,880 --> 00:33:44,610
we have subgroup G with a and B in it we

665
00:33:41,940 --> 00:33:49,230
have C which is its own group and we

666
00:33:44,610 --> 00:33:52,949
have I which has en F in it and in order

667
00:33:49,230 --> 00:33:56,100
to restore the efficiency here we need

668
00:33:52,950 --> 00:33:59,550
an update again so ideally C would would

669
00:33:56,100 --> 00:34:01,980
do a key rotation if C was online and

670
00:33:59,550 --> 00:34:04,110
that would restore everything except for

671
00:34:01,980 --> 00:34:06,930
the leaf node of Dean and and the whole

672
00:34:04,110 --> 00:34:08,370
thing would be efficient again but it

673
00:34:06,930 --> 00:34:09,780
doesn't matter it could also be anybody

674
00:34:08,370 --> 00:34:12,389
else in the group in this case it would

675
00:34:09,780 --> 00:34:14,850
be a because a was the one who initiated

676
00:34:12,389 --> 00:34:19,139
the deletion and so when a does an

677
00:34:14,850 --> 00:34:26,790
update then all the nodes above a will

678
00:34:19,139 --> 00:34:29,850
have values again so we have two types

679
00:34:26,790 --> 00:34:33,029
of messages in MLS one is the control

680
00:34:29,850 --> 00:34:34,350
messages and these are the the messages

681
00:34:33,030 --> 00:34:36,720
that actually control these base

682
00:34:34,350 --> 00:34:40,469
operations like create add update and

683
00:34:36,719 --> 00:34:42,719
remove and so the protocol mandates that

684
00:34:40,469 --> 00:34:44,790
these messages have to be in a certain

685
00:34:42,719 --> 00:34:47,060
order because it does make a difference

686
00:34:44,790 --> 00:34:50,969
whether you add someone first or remove

687
00:34:47,060 --> 00:34:53,429
somebody else first and also

688
00:34:50,969 --> 00:34:57,540
cryptographically this is necessary

689
00:34:53,429 --> 00:35:00,750
because not all operations can be

690
00:34:57,540 --> 00:35:02,790
commuted and then we have what you

691
00:35:00,750 --> 00:35:04,510
actually suspect in a messaging protocol

692
00:35:02,790 --> 00:35:06,970
we have application messages

693
00:35:04,510 --> 00:35:10,300
typically text messages but could be

694
00:35:06,970 --> 00:35:13,120
anything else and those don't have to

695
00:35:10,300 --> 00:35:14,970
have this strict order we can be a

696
00:35:13,120 --> 00:35:17,859
little more relaxed there because

697
00:35:14,970 --> 00:35:19,629
they're per sender so first of all the

698
00:35:17,860 --> 00:35:21,460
order only needs to be there percent it

699
00:35:19,630 --> 00:35:23,530
doesn't matter if two people speak at

700
00:35:21,460 --> 00:35:28,260
the same time in a group that their

701
00:35:23,530 --> 00:35:31,930
messages are not going to interfere and

702
00:35:28,260 --> 00:35:33,790
whereas on the percenter side we just

703
00:35:31,930 --> 00:35:35,529
need to make sure that they're not

704
00:35:33,790 --> 00:35:40,680
completely out of order but we can

705
00:35:35,530 --> 00:35:45,640
tolerate a little bit of confusion there

706
00:35:40,680 --> 00:35:47,649
and so how do we ensure that the global

707
00:35:45,640 --> 00:35:50,500
order is guaranteed for the handshake

708
00:35:47,650 --> 00:35:52,030
messages so this conceptually happens on

709
00:35:50,500 --> 00:35:54,580
the delivery service meaning on the

710
00:35:52,030 --> 00:35:56,260
server side so this is the one job the

711
00:35:54,580 --> 00:35:59,710
the delivery service really has to do

712
00:35:56,260 --> 00:36:01,840
and that is to make sure that there is

713
00:35:59,710 --> 00:36:04,630
no race condition between two members of

714
00:36:01,840 --> 00:36:07,810
a group trying to issue a handshake

715
00:36:04,630 --> 00:36:11,290
message so we need that conflict to be

716
00:36:07,810 --> 00:36:16,060
resolved and there has to be a winner

717
00:36:11,290 --> 00:36:17,590
and a loser and if we go back to the

718
00:36:16,060 --> 00:36:21,610
efficiency problem a little bit so this

719
00:36:17,590 --> 00:36:23,680
conceptually is what what a full mesh

720
00:36:21,610 --> 00:36:26,350
looks like if we superpose this

721
00:36:23,680 --> 00:36:28,960
one-to-one connections so this is the

722
00:36:26,350 --> 00:36:31,180
worst case that that we don't ever want

723
00:36:28,960 --> 00:36:33,550
so in pairwise sending I already

724
00:36:31,180 --> 00:36:35,919
mentioned it briefly before if we send

725
00:36:33,550 --> 00:36:38,440
out a message we send it out n times in

726
00:36:35,920 --> 00:36:42,250
a group of n members or n 9-1

727
00:36:38,440 --> 00:36:45,340
if we have the sender keys efficiency

728
00:36:42,250 --> 00:36:48,820
optimization then we send out the

729
00:36:45,340 --> 00:36:51,220
encryption keys in ofn and after that we

730
00:36:48,820 --> 00:36:53,680
can reuse it so that actual messages can

731
00:36:51,220 --> 00:36:56,890
be sent out in oh of one and that is

732
00:36:53,680 --> 00:36:58,870
quite efficient the problem here is that

733
00:36:56,890 --> 00:37:01,540
if somebody leaves a group everybody

734
00:36:58,870 --> 00:37:03,580
else has to regenerate a new key for

735
00:37:01,540 --> 00:37:05,890
themselves because you don't want the

736
00:37:03,580 --> 00:37:07,870
the member who left the group to be able

737
00:37:05,890 --> 00:37:09,339
to still decrypt messages obviously so

738
00:37:07,870 --> 00:37:11,020
we need to rotate the key and this is

739
00:37:09,340 --> 00:37:13,470
actually an over N squared which is

740
00:37:11,020 --> 00:37:13,470
really bad

741
00:37:17,160 --> 00:37:22,359
so to give you a comparison with a

742
00:37:20,470 --> 00:37:24,129
ridiculously large group just to make it

743
00:37:22,359 --> 00:37:25,540
a little more dramatic

744
00:37:24,130 --> 00:37:28,570
imagine you have a group of a hundred

745
00:37:25,540 --> 00:37:30,580
thousand members and you want to send

746
00:37:28,570 --> 00:37:34,420
out a message that is one kilobyte in

747
00:37:30,580 --> 00:37:35,859
size so with pairwise protocols you have

748
00:37:34,420 --> 00:37:37,930
a hundred thousand cryptographic

749
00:37:35,859 --> 00:37:41,619
operations like diffie-hellman and

750
00:37:37,930 --> 00:37:43,600
symmetric encryption to do that and and

751
00:37:41,619 --> 00:37:46,450
the payload for this one message will be

752
00:37:43,600 --> 00:37:49,240
hundred megabytes so this is not gonna

753
00:37:46,450 --> 00:37:54,430
work of course on an old Android phone

754
00:37:49,240 --> 00:37:56,350
on a 2g network with MLS since the whole

755
00:37:54,430 --> 00:37:58,750
thing is now logarithmic we have exactly

756
00:37:56,350 --> 00:38:02,319
17 operations for the same group size

757
00:37:58,750 --> 00:38:03,910
and a payload of only 17 kilobytes so

758
00:38:02,320 --> 00:38:09,130
this might actually work on the old

759
00:38:03,910 --> 00:38:12,549
Android phone and if we look at that on

760
00:38:09,130 --> 00:38:14,440
a chart to compare things so client

761
00:38:12,550 --> 00:38:17,260
fan-out is always constant in the group

762
00:38:14,440 --> 00:38:19,960
size and n that's the gray bars the

763
00:38:17,260 --> 00:38:21,910
sender keys they're very efficient in

764
00:38:19,960 --> 00:38:24,820
the last section and the message sending

765
00:38:21,910 --> 00:38:26,618
they do that in oh of one but for

766
00:38:24,820 --> 00:38:28,300
removing someone or creating a group

767
00:38:26,619 --> 00:38:30,520
they're very very inefficient because

768
00:38:28,300 --> 00:38:34,090
they can go all the way to N squared

769
00:38:30,520 --> 00:38:37,150
actually and so the idea for MLS was to

770
00:38:34,090 --> 00:38:41,020
consistently be more efficient than

771
00:38:37,150 --> 00:38:44,970
either client fanart or sender keys so

772
00:38:41,020 --> 00:38:48,609
that adding someone is really fast

773
00:38:44,970 --> 00:38:51,250
updating keys will depend on how

774
00:38:48,609 --> 00:38:54,090
populated the tree is removing as well

775
00:38:51,250 --> 00:38:57,340
so we're somewhere in between o of 1 and

776
00:38:54,090 --> 00:39:01,450
O of N and again sending out a message

777
00:38:57,340 --> 00:39:03,520
is super fast with MLS and we never go

778
00:39:01,450 --> 00:39:08,100
beyond the o of n that is really the

779
00:39:03,520 --> 00:39:11,740
worst case so end-to-end encryption

780
00:39:08,100 --> 00:39:14,890
encrypts the content of data and so we

781
00:39:11,740 --> 00:39:16,629
all we talked about was the protection

782
00:39:14,890 --> 00:39:18,879
of the the actual content and the data

783
00:39:16,630 --> 00:39:20,650
so in the context of a messaging

784
00:39:18,880 --> 00:39:22,630
protocol the questions are so important

785
00:39:20,650 --> 00:39:24,520
what do we do with metadata how much do

786
00:39:22,630 --> 00:39:27,170
we have how much do we need actually and

787
00:39:24,520 --> 00:39:32,780
if so how do we protect it

788
00:39:27,170 --> 00:39:35,660
and so we we should distinguish between

789
00:39:32,780 --> 00:39:38,480
two kinds of metadata one is observable

790
00:39:35,660 --> 00:39:40,460
metadata which is traffic patterns for

791
00:39:38,480 --> 00:39:41,900
example if you have a view of the

792
00:39:40,460 --> 00:39:44,260
network you can see who is sending

793
00:39:41,900 --> 00:39:47,420
messages to who at which frequency etc

794
00:39:44,260 --> 00:39:49,280
how big they are and then their

795
00:39:47,420 --> 00:39:51,470
persistent metadata so persistent

796
00:39:49,280 --> 00:39:54,290
metadata is metadata that is typically

797
00:39:51,470 --> 00:39:58,730
on a server or at the very least on the

798
00:39:54,290 --> 00:40:01,670
client side so observable metadata that

799
00:39:58,730 --> 00:40:04,850
is out of scope for secure messaging

800
00:40:01,670 --> 00:40:06,740
protocol because it's not something you

801
00:40:04,850 --> 00:40:07,880
can resolve at the protocol layer it's

802
00:40:06,740 --> 00:40:09,500
something you resolve on the

803
00:40:07,880 --> 00:40:14,450
architectural layer with for example

804
00:40:09,500 --> 00:40:17,510
Onion Routing tor mix Nets so this

805
00:40:14,450 --> 00:40:19,490
cannot be in the scope of MLS persistent

806
00:40:17,510 --> 00:40:21,260
metadata however that is much more

807
00:40:19,490 --> 00:40:26,750
interesting because we we can put that

808
00:40:21,260 --> 00:40:29,330
in scope and so typically servers will

809
00:40:26,750 --> 00:40:34,190
keep messages in queues until clients

810
00:40:29,330 --> 00:40:36,440
have fetched them but we don't need the

811
00:40:34,190 --> 00:40:38,330
server to know who the sender is of a

812
00:40:36,440 --> 00:40:42,560
message long term all the server needs

813
00:40:38,330 --> 00:40:44,240
to know is in which queue to put it and

814
00:40:42,560 --> 00:40:48,350
then we can complete your fifth gate who

815
00:40:44,240 --> 00:40:52,189
actually sent it we can also have

816
00:40:48,350 --> 00:40:55,220
arbitrary padding so that messages all

817
00:40:52,190 --> 00:40:57,230
look the same size for example so that

818
00:40:55,220 --> 00:40:59,450
server cannot really tell what kind of

819
00:40:57,230 --> 00:41:01,340
messages it was whether somebody has

820
00:40:59,450 --> 00:41:04,700
been added to a group or removed or

821
00:41:01,340 --> 00:41:07,970
whether it was an update so we have a

822
00:41:04,700 --> 00:41:10,220
layered approach here where the metadata

823
00:41:07,970 --> 00:41:12,049
is really just in header one and that

824
00:41:10,220 --> 00:41:14,270
can be seen and that is just the

825
00:41:12,050 --> 00:41:17,540
destination of a message but everything

826
00:41:14,270 --> 00:41:21,650
else we can actually encrypt that so

827
00:41:17,540 --> 00:41:23,060
that only clients can decrypt it so in

828
00:41:21,650 --> 00:41:24,800
the header two you would have the the

829
00:41:23,060 --> 00:41:27,440
sender of the message then the message

830
00:41:24,800 --> 00:41:31,820
itself and we can like I said add some

831
00:41:27,440 --> 00:41:32,870
arbitrary padding deniability which we

832
00:41:31,820 --> 00:41:35,010
want to do

833
00:41:32,870 --> 00:41:36,440
optionally

834
00:41:35,010 --> 00:41:39,800
[Music]

835
00:41:36,440 --> 00:41:42,320
so messages need to be signed in MLS for

836
00:41:39,800 --> 00:41:47,450
authenticity because we have one group

837
00:41:42,320 --> 00:41:52,730
key now and if everybody encrypts under

838
00:41:47,450 --> 00:41:54,439
the same group key wasn't planned then

839
00:41:52,730 --> 00:41:56,810
you cannot distinguish who the sender is

840
00:41:54,440 --> 00:42:00,200
actually any more so you need a digital

841
00:41:56,810 --> 00:42:04,130
signature to be sure who sent a message

842
00:42:00,200 --> 00:42:06,020
in the first place so for that you you

843
00:42:04,130 --> 00:42:07,850
need identity keys of course and and

844
00:42:06,020 --> 00:42:09,800
that sort of breaks deniability if you

845
00:42:07,850 --> 00:42:11,779
have this signature so what we can do

846
00:42:09,800 --> 00:42:14,900
instead is we can send these identity

847
00:42:11,780 --> 00:42:17,540
keys over a one to one denial channel so

848
00:42:14,900 --> 00:42:20,060
that the recipient clearly knows whose

849
00:42:17,540 --> 00:42:21,680
identity key it is but cannot prove it

850
00:42:20,060 --> 00:42:23,930
to a third party because the channel

851
00:42:21,680 --> 00:42:27,259
over which they receive the key is

852
00:42:23,930 --> 00:42:29,480
itself deniable and then we can through

853
00:42:27,260 --> 00:42:31,880
that mechanism we can make text messages

854
00:42:29,480 --> 00:42:35,810
become deniable or even the

855
00:42:31,880 --> 00:42:39,800
participation in a group and all of that

856
00:42:35,810 --> 00:42:41,570
can be done optionally and of course

857
00:42:39,800 --> 00:42:44,000
like I said before the messages are

858
00:42:41,570 --> 00:42:46,310
encrypted under a group key additionally

859
00:42:44,000 --> 00:42:48,190
so a server which is one of this

860
00:42:46,310 --> 00:42:50,660
potential third parties cannot really

861
00:42:48,190 --> 00:42:52,940
look at any signatures either

862
00:42:50,660 --> 00:42:58,790
even if ephemeral ones or deniable ones

863
00:42:52,940 --> 00:43:01,190
I also mentioned Federation and I will

864
00:42:58,790 --> 00:43:04,790
briefly go into this on a very high

865
00:43:01,190 --> 00:43:06,470
level so what what needs to be done if

866
00:43:04,790 --> 00:43:09,259
we don't want to be tied to just one

867
00:43:06,470 --> 00:43:13,339
delivery service we have this very hard

868
00:43:09,260 --> 00:43:15,380
requirement that handshake messages this

869
00:43:13,340 --> 00:43:17,390
control message need to be ordered and

870
00:43:15,380 --> 00:43:19,370
this is really the only problem we have

871
00:43:17,390 --> 00:43:22,100
to solve here so if we can distribute

872
00:43:19,370 --> 00:43:24,770
this problem over more than one delivery

873
00:43:22,100 --> 00:43:28,220
service we actually have some kind of

874
00:43:24,770 --> 00:43:29,810
Federation so imagine if you have more

875
00:43:28,220 --> 00:43:35,419
than one delivery service here in this

876
00:43:29,810 --> 00:43:37,400
case three the idea is that there can be

877
00:43:35,420 --> 00:43:39,560
two levels of Federation's a very simple

878
00:43:37,400 --> 00:43:42,800
one without any particular redundancy so

879
00:43:39,560 --> 00:43:44,360
for any group conversation you you pick

880
00:43:42,800 --> 00:43:46,400
one of the delivery services who is

881
00:43:44,360 --> 00:43:48,080
going to be responsible for that

882
00:43:46,400 --> 00:43:49,850
particular group conversation and who's

883
00:43:48,080 --> 00:43:54,259
going to be responsible for the

884
00:43:49,850 --> 00:43:57,130
message ordering and in a more advanced

885
00:43:54,260 --> 00:43:59,810
concept it could be some redundancy were

886
00:43:57,130 --> 00:44:05,930
this responsibility could be transferred

887
00:43:59,810 --> 00:44:07,190
to another delivery service in the end I

888
00:44:05,930 --> 00:44:10,040
want to talk a little bit about business

889
00:44:07,190 --> 00:44:12,920
messaging as well because so far what I

890
00:44:10,040 --> 00:44:14,930
said is both applicable to consumer

891
00:44:12,920 --> 00:44:17,540
messengers and business messengers and

892
00:44:14,930 --> 00:44:19,370
the reality is today that there is a lot

893
00:44:17,540 --> 00:44:22,070
more messaging going on inside of

894
00:44:19,370 --> 00:44:23,660
companies simply because people are used

895
00:44:22,070 --> 00:44:24,800
to messaging in their private life and

896
00:44:23,660 --> 00:44:27,859
they want to bring that into their

897
00:44:24,800 --> 00:44:29,420
business life there is an increasing

898
00:44:27,860 --> 00:44:31,760
number of people who don't want to rely

899
00:44:29,420 --> 00:44:33,280
on emails anymore because it's just an

900
00:44:31,760 --> 00:44:36,940
old technology

901
00:44:33,280 --> 00:44:40,850
so really Millennials are a problem here

902
00:44:36,940 --> 00:44:43,670
for them emails is like fax for other

903
00:44:40,850 --> 00:44:49,069
generations but I think that's a that's

904
00:44:43,670 --> 00:44:52,010
a good evolution so the the problem with

905
00:44:49,070 --> 00:44:53,810
business messaging however is that there

906
00:44:52,010 --> 00:44:58,690
are a few more restrictions that apply

907
00:44:53,810 --> 00:44:58,690
compared to consumer messaging and

908
00:44:59,290 --> 00:45:04,100
despite the fact that the users really

909
00:45:01,490 --> 00:45:06,589
want the same sort of experience so one

910
00:45:04,100 --> 00:45:08,299
is the encryption challenge which we've

911
00:45:06,590 --> 00:45:10,400
covered now extensively and that is a

912
00:45:08,300 --> 00:45:12,740
problem that it doesn't scale while in

913
00:45:10,400 --> 00:45:14,540
large groups so far so this is why

914
00:45:12,740 --> 00:45:16,700
businesses are very hesitant to

915
00:45:14,540 --> 00:45:20,529
introduce messengers that are end-to-end

916
00:45:16,700 --> 00:45:23,390
encrypted because of efficiency reasons

917
00:45:20,530 --> 00:45:27,710
the other aspect is the the future

918
00:45:23,390 --> 00:45:31,339
challenge so business messengers these

919
00:45:27,710 --> 00:45:33,650
days they don't really federate which is

920
00:45:31,340 --> 00:45:36,380
a problem so there are silos and then

921
00:45:33,650 --> 00:45:37,850
people will still use emails because

922
00:45:36,380 --> 00:45:40,670
everybody has an email address you can

923
00:45:37,850 --> 00:45:42,830
reach almost everybody over email so

924
00:45:40,670 --> 00:45:44,780
this becomes more and more of a

925
00:45:42,830 --> 00:45:48,290
requirement that messengers are actually

926
00:45:44,780 --> 00:45:53,630
able to federate across organizations

927
00:45:48,290 --> 00:45:55,610
across companies so if we want to

928
00:45:53,630 --> 00:45:57,380
summarize now what we said in the

929
00:45:55,610 --> 00:46:00,049
beginning with a wish list

930
00:45:57,380 --> 00:46:01,969
I think MLS become

931
00:46:00,049 --> 00:46:06,259
really close to what we want to have

932
00:46:01,969 --> 00:46:09,259
here so it's aiming to be a new standard

933
00:46:06,259 --> 00:46:13,219
for secure messaging especially in large

934
00:46:09,259 --> 00:46:15,259
groups it should have these modern

935
00:46:13,219 --> 00:46:18,189
security properties like forward

936
00:46:15,259 --> 00:46:21,469
security and post compromised security

937
00:46:18,189 --> 00:46:25,788
it should be robust usable and have an

938
00:46:21,469 --> 00:46:28,429
open specification so since it's an IETF

939
00:46:25,789 --> 00:46:30,499
working group all of that is available

940
00:46:28,429 --> 00:46:33,439
online of course it's being discussed on

941
00:46:30,499 --> 00:46:35,629
a mailing list there is an architecture

942
00:46:33,439 --> 00:46:40,819
document and most importantly a protocol

943
00:46:35,630 --> 00:46:43,640
document and the easy entry point here

944
00:46:40,819 --> 00:46:46,699
is this website messaging layer security

945
00:46:43,640 --> 00:46:49,219
that rocks which points at the ITF

946
00:46:46,699 --> 00:46:52,759
website etc where you can find all of

947
00:46:49,219 --> 00:46:54,769
the documentation and that pretty much

948
00:46:52,759 --> 00:47:00,799
concludes my talk for today thank you

949
00:46:54,769 --> 00:47:08,499
very much thank you or fair okay we have

950
00:47:00,799 --> 00:47:08,499
questions okay

951
00:47:10,790 --> 00:47:16,830
hello thank you for the presentation

952
00:47:14,010 --> 00:47:20,880
my question is because you're rotating

953
00:47:16,830 --> 00:47:23,910
the keys for for each event what

954
00:47:20,880 --> 00:47:27,480
happened with the messages that was sent

955
00:47:23,910 --> 00:47:30,720
in a past event for example if a new

956
00:47:27,480 --> 00:47:34,170
member come to the do group he or she

957
00:47:30,720 --> 00:47:37,500
can they creep the past messages because

958
00:47:34,170 --> 00:47:41,250
it's another key right if you want to

959
00:47:37,500 --> 00:47:44,130
share information from a group the past

960
00:47:41,250 --> 00:47:47,520
information you can't this is a problem

961
00:47:44,130 --> 00:47:49,020
now right so this is not solved at the

962
00:47:47,520 --> 00:47:51,480
protocol layer you're absolutely right

963
00:47:49,020 --> 00:47:55,050
about that because this is simply a

964
00:47:51,480 --> 00:47:56,610
consequence of having forward secrecy so

965
00:47:55,050 --> 00:47:58,350
the idea here is that the protocol

966
00:47:56,610 --> 00:48:00,360
itself should be the most secure and

967
00:47:58,350 --> 00:48:03,600
then you can build something on top of

968
00:48:00,360 --> 00:48:05,760
the protocol to share the history and to

969
00:48:03,600 --> 00:48:07,350
relax the forward secrecy a little bit

970
00:48:05,760 --> 00:48:10,100
if that is what you want to do in your

971
00:48:07,350 --> 00:48:13,710
application in the end okay so is there

972
00:48:10,100 --> 00:48:17,089
duty of the upward layer to conserve the

973
00:48:13,710 --> 00:48:21,900
message or share it yes these protocol

974
00:48:17,090 --> 00:48:25,530
acts only in that network let's say only

975
00:48:21,900 --> 00:48:28,020
to transport the message not to in side

976
00:48:25,530 --> 00:48:29,430
it on the application exactly so we

977
00:48:28,020 --> 00:48:30,840
distinguish between the protocol layer

978
00:48:29,430 --> 00:48:32,279
and the application layer and the

979
00:48:30,840 --> 00:48:34,710
application layer will be very different

980
00:48:32,280 --> 00:48:36,150
for different apps and so this is not

981
00:48:34,710 --> 00:48:37,920
something we would like to standardize

982
00:48:36,150 --> 00:48:39,870
because it's not gonna make a lot of

983
00:48:37,920 --> 00:48:42,330
sense and at the protocol layer we want

984
00:48:39,870 --> 00:48:44,279
to be as secure and and as restrictive

985
00:48:42,330 --> 00:48:46,830
as possible because it's always easier

986
00:48:44,280 --> 00:48:48,300
to relax that under layer above but the

987
00:48:46,830 --> 00:48:50,190
opposite is very difficult if the

988
00:48:48,300 --> 00:48:52,170
underlying layer is not secure you

989
00:48:50,190 --> 00:48:55,850
cannot just both on the security on top

990
00:48:52,170 --> 00:49:01,040
of that okay thank you

991
00:48:55,850 --> 00:49:01,040
Thanks any other questions

992
00:49:03,920 --> 00:49:12,339
what a silent crowd all right okay yes

993
00:49:15,880 --> 00:49:22,779
hello in the beginning of your

994
00:49:19,220 --> 00:49:25,640
presentation you presented some

995
00:49:22,779 --> 00:49:28,609
messaging application actually all of us

996
00:49:25,640 --> 00:49:32,118
are using some what's up and telegrams

997
00:49:28,609 --> 00:49:34,009
and so on my question is in your opinion

998
00:49:32,119 --> 00:49:35,319
which is the most secure and which is

999
00:49:34,010 --> 00:49:37,849
less secure

1000
00:49:35,319 --> 00:49:42,500
well I'm very very biased I work for

1001
00:49:37,849 --> 00:49:44,630
wire so he tried to actually be as

1002
00:49:42,500 --> 00:49:48,460
secure as possible in the space of a

1003
00:49:44,630 --> 00:49:51,549
collaboration messenger but they are

1004
00:49:48,460 --> 00:49:54,349
excellent websites I think one is secure

1005
00:49:51,549 --> 00:49:58,309
messaging calm secure messaging apps

1006
00:49:54,349 --> 00:50:00,589
calm sorry so somebody made the effort

1007
00:49:58,309 --> 00:50:02,539
of going through all the so-called

1008
00:50:00,589 --> 00:50:04,788
secure messengers and looking in detail

1009
00:50:02,539 --> 00:50:07,970
at the properties and the promises and

1010
00:50:04,789 --> 00:50:12,200
whether they're kept or not so that

1011
00:50:07,970 --> 00:50:24,319
would be a good starting point to yeah

1012
00:50:12,200 --> 00:50:24,950
to compare thank you one more I think it

1013
00:50:24,319 --> 00:50:27,740
for duck

1014
00:50:24,950 --> 00:50:30,529
so is there a study done on where's the

1015
00:50:27,740 --> 00:50:32,750
breaking point for normal transfer

1016
00:50:30,529 --> 00:50:36,319
technology versus this one like smaller

1017
00:50:32,750 --> 00:50:39,410
groups under 10 or under 100 people is

1018
00:50:36,319 --> 00:50:42,710
no longer reliable to use this just

1019
00:50:39,410 --> 00:50:46,098
because of the key changes so yeah I

1020
00:50:42,710 --> 00:50:47,839
mean the the bigger the group gets the

1021
00:50:46,099 --> 00:50:50,150
more expensive it yet so there is not

1022
00:50:47,839 --> 00:50:51,230
one specific number where this is it's

1023
00:50:50,150 --> 00:50:54,529
hard but I can tell you from my

1024
00:50:51,230 --> 00:50:56,269
experience at wire for example we have

1025
00:50:54,529 --> 00:50:58,039
been increasing the group size over time

1026
00:50:56,269 --> 00:51:01,549
and I think right now it's about 500

1027
00:50:58,039 --> 00:51:03,259
members in in one group that we can

1028
00:51:01,549 --> 00:51:05,299
still accommodate for but it just makes

1029
00:51:03,259 --> 00:51:06,849
things slower so the question is where

1030
00:51:05,299 --> 00:51:10,700
is the pain point on the user side

1031
00:51:06,849 --> 00:51:13,099
essentially and and clearly we cannot do

1032
00:51:10,700 --> 00:51:15,189
thousands or tens of thousands with

1033
00:51:13,099 --> 00:51:17,210
pairwise protocols but that's very clear

1034
00:51:15,190 --> 00:51:20,210
simply because the payload is going to

1035
00:51:17,210 --> 00:51:23,119
increase even if the processor is fast

1036
00:51:20,210 --> 00:51:25,190
enough film yeah but the question is is

1037
00:51:23,119 --> 00:51:28,369
there point where they're similar in

1038
00:51:25,190 --> 00:51:30,950
speed so to what groups I should use

1039
00:51:28,369 --> 00:51:32,299
conventional rather to switching well

1040
00:51:30,950 --> 00:51:35,808
there are similar and speed for the

1041
00:51:32,299 --> 00:51:38,900
one-to-one groups and even as soon as

1042
00:51:35,809 --> 00:51:42,380
you have three in a group already MLS is

1043
00:51:38,900 --> 00:51:46,670
designed to already be faster okay cool

1044
00:51:42,380 --> 00:51:50,089
Thanks all right folks thank you so much

1045
00:51:46,670 --> 00:51:51,859
any other questions you can talk with

1046
00:51:50,089 --> 00:51:54,700
Rafael during the breaks thank you so

1047
00:51:51,859 --> 00:51:58,299
much Rafael for your talk thank you

1048
00:51:54,700 --> 00:51:58,299
[Applause]

