1
00:00:00,030 --> 00:00:04,710
good morning to everyone my name is

2
00:00:02,190 --> 00:00:06,330
Adrian I like to come up with completed

3
00:00:04,710 --> 00:00:09,300
presentation titles that are hard to

4
00:00:06,330 --> 00:00:11,610
follow so I will talking about how you

5
00:00:09,300 --> 00:00:13,259
can emulate Linux malware like sabina

6
00:00:11,610 --> 00:00:14,910
said and this is my approach using

7
00:00:13,259 --> 00:00:17,970
something called the unicorn emulator

8
00:00:14,910 --> 00:00:19,350
framework if any of that is unknown to

9
00:00:17,970 --> 00:00:23,029
you i'll try to explain as we go along

10
00:00:19,350 --> 00:00:26,070
so I hope you enjoy the presentation

11
00:00:23,029 --> 00:00:27,869
like I said I'm a security researcher I

12
00:00:26,070 --> 00:00:31,170
work with excels application and threat

13
00:00:27,869 --> 00:00:33,450
intelligence team I work with sandboxing

14
00:00:31,170 --> 00:00:35,190
phishing you know look on the newest and

15
00:00:33,450 --> 00:00:38,219
coolest exploits try to track of them in

16
00:00:35,190 --> 00:00:39,930
our honey pots and stuff like that and a

17
00:00:38,219 --> 00:00:43,230
lot of work that we do relies on

18
00:00:39,930 --> 00:00:45,620
automating stuff so this POC that I'll

19
00:00:43,230 --> 00:00:49,019
try to explain about is something that's

20
00:00:45,620 --> 00:00:51,300
aiming to automate as much of the

21
00:00:49,020 --> 00:00:53,100
malware analysis work that we do up into

22
00:00:51,300 --> 00:00:55,379
one point you can follow me on Twitter

23
00:00:53,100 --> 00:00:59,760
we also have a blog there's sometimes

24
00:00:55,379 --> 00:01:01,050
blog on and I'll try to keep the content

25
00:00:59,760 --> 00:01:03,930
short since this is a short presentation

26
00:01:01,050 --> 00:01:06,090
I'll just come up with how the why and

27
00:01:03,930 --> 00:01:11,520
show you some examples of how things

28
00:01:06,090 --> 00:01:12,869
work when trying to do this so if you're

29
00:01:11,520 --> 00:01:14,610
unfamiliar with malware packing

30
00:01:12,869 --> 00:01:16,439
basically the idea is to wrap your

31
00:01:14,610 --> 00:01:18,330
malware that might get detected by

32
00:01:16,439 --> 00:01:21,449
antivirus products inside some sort of

33
00:01:18,330 --> 00:01:23,520
shady box so you'll have the original

34
00:01:21,450 --> 00:01:25,350
malware binary it's wrapped inside a

35
00:01:23,520 --> 00:01:27,710
separate executable that is going to add

36
00:01:25,350 --> 00:01:30,270
a packet you know uncompress it

37
00:01:27,710 --> 00:01:32,369
unencrypted it and then execute it and

38
00:01:30,270 --> 00:01:35,189
this all happens on run time when you

39
00:01:32,369 --> 00:01:37,200
execute the new binary it's going to

40
00:01:35,189 --> 00:01:40,770
unpack the contents in memory and then

41
00:01:37,200 --> 00:01:42,420
execute the original so we might be

42
00:01:40,770 --> 00:01:44,548
asking why someone would do that since

43
00:01:42,420 --> 00:01:47,310
it's just looks like adding complexity

44
00:01:44,549 --> 00:01:49,710
well the reason is antivirus products

45
00:01:47,310 --> 00:01:51,570
and security products in general rely on

46
00:01:49,710 --> 00:01:53,460
signatures they do different types of

47
00:01:51,570 --> 00:01:54,829
analysis and one of these types is

48
00:01:53,460 --> 00:01:57,419
called static analysis for example

49
00:01:54,829 --> 00:01:59,460
looking for interesting strings inside a

50
00:01:57,420 --> 00:02:01,469
binary looking for important functions

51
00:01:59,460 --> 00:02:03,539
looking for the anything that can be

52
00:02:01,469 --> 00:02:06,869
analyzed without executing the binary

53
00:02:03,540 --> 00:02:09,060
itself in this case this is a DDoS bot

54
00:02:06,869 --> 00:02:11,430
that I also showed last year and these

55
00:02:09,060 --> 00:02:13,350
are some of its commands that you can

56
00:02:11,430 --> 00:02:16,470
see in clear text just by analyzed

57
00:02:13,350 --> 00:02:18,690
the binary just by looking at it when

58
00:02:16,470 --> 00:02:20,310
you pack the malware you just get random

59
00:02:18,690 --> 00:02:22,170
strings you can't find the original

60
00:02:20,310 --> 00:02:24,630
anymore so that way you lose an

61
00:02:22,170 --> 00:02:29,970
indicator for the antivirus or anything

62
00:02:24,630 --> 00:02:31,769
to be able to detect so there are many

63
00:02:29,970 --> 00:02:33,359
ways of doing packing you can find

64
00:02:31,770 --> 00:02:35,910
off-the-shelf Packers you can find

65
00:02:33,360 --> 00:02:37,620
open-source stuff the common de facto -

66
00:02:35,910 --> 00:02:41,790
right now with the Linux malware seems

67
00:02:37,620 --> 00:02:44,100
to be upx nucleus is an open source tool

68
00:02:41,790 --> 00:02:45,929
it has a nice decompression option that

69
00:02:44,100 --> 00:02:48,840
but with somewhere can easily be

70
00:02:45,930 --> 00:02:50,850
bypassed hindering analysis there are

71
00:02:48,840 --> 00:02:54,210
other options of tools open source

72
00:02:50,850 --> 00:02:55,769
commercial IBM protect we have unpacking

73
00:02:54,210 --> 00:03:00,120
tools for some we have unpacking

74
00:02:55,770 --> 00:03:02,730
strategies for others and you also have

75
00:03:00,120 --> 00:03:04,110
custom Packers someone writing their own

76
00:03:02,730 --> 00:03:06,209
Packer from scratch

77
00:03:04,110 --> 00:03:07,230
someone modifying an open source tools

78
00:03:06,210 --> 00:03:09,810
such as upx

79
00:03:07,230 --> 00:03:12,989
and unpacking these generally require

80
00:03:09,810 --> 00:03:14,640
some sort of manual labor if you want to

81
00:03:12,990 --> 00:03:16,440
simply unpack without executing the

82
00:03:14,640 --> 00:03:18,149
binary and you need someone who's pretty

83
00:03:16,440 --> 00:03:20,430
good at using a debugger no some

84
00:03:18,150 --> 00:03:22,530
knowledge of assembly know something of

85
00:03:20,430 --> 00:03:25,170
the internals of how binaries generally

86
00:03:22,530 --> 00:03:27,330
work so like I said I try to automate

87
00:03:25,170 --> 00:03:31,589
stuff and I was looking into how you can

88
00:03:27,330 --> 00:03:33,240
automate this the simplest and most

89
00:03:31,590 --> 00:03:35,910
direct way to do that is to use a

90
00:03:33,240 --> 00:03:37,830
sandbox that means executing the malware

91
00:03:35,910 --> 00:03:40,170
or the malware candidate you know

92
00:03:37,830 --> 00:03:41,880
suspicious sample inside the virtual

93
00:03:40,170 --> 00:03:43,709
machine generally you use a virtual

94
00:03:41,880 --> 00:03:45,960
machine that you have a clean state for

95
00:03:43,710 --> 00:03:48,270
you would restore it to a clean state

96
00:03:45,960 --> 00:03:49,860
you would execute the malware the

97
00:03:48,270 --> 00:03:52,650
machine is finally monitored and you can

98
00:03:49,860 --> 00:03:55,170
see what happens during execution and

99
00:03:52,650 --> 00:03:57,300
this is pretty hard to customize because

100
00:03:55,170 --> 00:03:59,220
you have to add more monitoring tools as

101
00:03:57,300 --> 00:04:01,860
things go about the tools themselves

102
00:03:59,220 --> 00:04:04,260
might get detected by the malicious

103
00:04:01,860 --> 00:04:06,540
author on execution and the malware

104
00:04:04,260 --> 00:04:08,399
stops running and this is pretty

105
00:04:06,540 --> 00:04:09,690
expensive you sometimes have to wait for

106
00:04:08,400 --> 00:04:12,300
a couple of minutes until everything

107
00:04:09,690 --> 00:04:14,640
goes you also have trouble scaling

108
00:04:12,300 --> 00:04:16,440
because I need to add one more package

109
00:04:14,640 --> 00:04:18,450
to my virtual machine then I need to

110
00:04:16,440 --> 00:04:21,478
deploy a VM template on a lot of sandbox

111
00:04:18,450 --> 00:04:24,200
boxes so that easily becomes you know

112
00:04:21,478 --> 00:04:26,539
hard to customize

113
00:04:24,200 --> 00:04:30,050
leaders have been used for some time the

114
00:04:26,540 --> 00:04:32,600
go-to tool so far was ki-moon which is

115
00:04:30,050 --> 00:04:34,070
an eye simulator but it tests the same

116
00:04:32,600 --> 00:04:36,530
limitation of being pretty hard to

117
00:04:34,070 --> 00:04:38,420
customize so it's written in C code you

118
00:04:36,530 --> 00:04:41,809
have to do some recompiling you have to

119
00:04:38,420 --> 00:04:45,470
do a lot of pretty hard labor to be able

120
00:04:41,810 --> 00:04:47,960
to customize it and someone also

121
00:04:45,470 --> 00:04:50,570
suggested we could overload the Linux

122
00:04:47,960 --> 00:04:53,390
system called table I'll explain what

123
00:04:50,570 --> 00:04:55,969
system calls are familiar basically just

124
00:04:53,390 --> 00:04:57,710
overloading some default services that

125
00:04:55,970 --> 00:05:00,260
Linux would provide and then tracking

126
00:04:57,710 --> 00:05:02,180
and seeing what happens and this is as

127
00:05:00,260 --> 00:05:05,300
hard to customize in as anything since

128
00:05:02,180 --> 00:05:07,250
it requires recompiling modifying kernel

129
00:05:05,300 --> 00:05:09,530
modules reloading kernel modules and

130
00:05:07,250 --> 00:05:13,160
stuff like that so again it seemed hard

131
00:05:09,530 --> 00:05:14,900
I don't want to take this approach so

132
00:05:13,160 --> 00:05:15,920
I'm teeny unicorn you can see a unicorn

133
00:05:14,900 --> 00:05:18,679
over there

134
00:05:15,920 --> 00:05:20,150
what's unicorn at some point some people

135
00:05:18,680 --> 00:05:22,820
started working on three frameworks

136
00:05:20,150 --> 00:05:25,039
called capstone Keystone and unicorn

137
00:05:22,820 --> 00:05:28,310
they're used for assembly

138
00:05:25,040 --> 00:05:30,050
disassembly of binary code and unicorn

139
00:05:28,310 --> 00:05:32,810
is an emulator that means it's able to

140
00:05:30,050 --> 00:05:37,250
take CPU instructions and execute them

141
00:05:32,810 --> 00:05:38,930
as would happen on the real-life CPU so

142
00:05:37,250 --> 00:05:40,670
that's the starting point for this we

143
00:05:38,930 --> 00:05:45,170
have something that's able to execute CP

144
00:05:40,670 --> 00:05:47,450
instructions in a binary and at first it

145
00:05:45,170 --> 00:05:49,280
seemed kinda easy what do you have to do

146
00:05:47,450 --> 00:05:51,710
it to execute a binary you just take it

147
00:05:49,280 --> 00:05:52,130
load into memory then execute nice and

148
00:05:51,710 --> 00:05:54,500
easy

149
00:05:52,130 --> 00:05:57,200
should actually become easier as time

150
00:05:54,500 --> 00:05:59,750
goes by the reality of any research trip

151
00:05:57,200 --> 00:06:03,710
is something like this unfortunately but

152
00:05:59,750 --> 00:06:05,720
it's also fun so the reason for that is

153
00:06:03,710 --> 00:06:07,849
that things get a bit more complicated

154
00:06:05,720 --> 00:06:10,730
the operating system when executing a

155
00:06:07,850 --> 00:06:13,250
binary does a lot more work behind the

156
00:06:10,730 --> 00:06:15,470
scenes then we are aware basically it

157
00:06:13,250 --> 00:06:17,780
loads it into RAM it would allocate the

158
00:06:15,470 --> 00:06:20,360
CPU time which we don't have to worry

159
00:06:17,780 --> 00:06:22,250
about when doing emulation it would the

160
00:06:20,360 --> 00:06:24,080
cpu will execute instructions and that's

161
00:06:22,250 --> 00:06:26,210
the part that Unicorn does for us it's

162
00:06:24,080 --> 00:06:27,590
able to do all of that and then the

163
00:06:26,210 --> 00:06:29,299
application is going from time to time

164
00:06:27,590 --> 00:06:30,979
to us for different services from the

165
00:06:29,300 --> 00:06:31,550
operating system like asking for more

166
00:06:30,980 --> 00:06:33,650
memory

167
00:06:31,550 --> 00:06:37,010
asking for writing to a file reading

168
00:06:33,650 --> 00:06:38,000
from a file and stuff like that so the

169
00:06:37,010 --> 00:06:40,670
middle part

170
00:06:38,000 --> 00:06:42,080
unicorn helps us with but parts 1 and 3

171
00:06:40,670 --> 00:06:48,080
the ones on the left and right we have

172
00:06:42,080 --> 00:06:50,870
to do them on on our own so how would

173
00:06:48,080 --> 00:06:53,030
you load a binary into memory oh if you

174
00:06:50,870 --> 00:06:55,790
start searching online you'll find some

175
00:06:53,030 --> 00:06:58,070
information about how Linux elf binaries

176
00:06:55,790 --> 00:07:00,710
are loaded you find that they have some

177
00:06:58,070 --> 00:07:04,760
mappings this is an example of a mapping

178
00:07:00,710 --> 00:07:07,039
mapping the file contents to memory for

179
00:07:04,760 --> 00:07:09,050
example this part here says that you

180
00:07:07,040 --> 00:07:12,020
should go to the beginning of the file

181
00:07:09,050 --> 00:07:14,290
grab so many bytes and then load them

182
00:07:12,020 --> 00:07:17,510
into memory maybe at a specific address

183
00:07:14,290 --> 00:07:19,790
allocating as many bytes for it you can

184
00:07:17,510 --> 00:07:21,680
also have different types of mappings

185
00:07:19,790 --> 00:07:23,840
such as this one that has a lot of zeros

186
00:07:21,680 --> 00:07:25,790
on the file part and that's the reason

187
00:07:23,840 --> 00:07:27,830
there's nothing being loaded from the

188
00:07:25,790 --> 00:07:30,230
original file when loading into memory

189
00:07:27,830 --> 00:07:32,060
it basically says I'm going to need this

190
00:07:30,230 --> 00:07:34,640
much memory I know I will need it at

191
00:07:32,060 --> 00:07:36,260
some point but just you know load it

192
00:07:34,640 --> 00:07:39,890
whatever and I will simply overwrite it

193
00:07:36,260 --> 00:07:42,560
and use it as time goes by so after you

194
00:07:39,890 --> 00:07:45,370
do this you after I understand this the

195
00:07:42,560 --> 00:07:48,229
burn loading part becomes pretty easy

196
00:07:45,370 --> 00:07:50,210
then we have the part on the right those

197
00:07:48,229 --> 00:07:52,400
are the operating system services and

198
00:07:50,210 --> 00:07:54,700
this is done by system calls I know how

199
00:07:52,400 --> 00:07:57,109
many of you have looked into this part

200
00:07:54,700 --> 00:07:58,669
basically what happens is when you need

201
00:07:57,110 --> 00:08:01,040
something fill up the operating system

202
00:07:58,669 --> 00:08:02,840
the CPU is going to have a special

203
00:08:01,040 --> 00:08:07,520
instruction this is an example from

204
00:08:02,840 --> 00:08:09,710
Intel and AMD x86 64 architectures where

205
00:08:07,520 --> 00:08:11,180
you have a Cisco instruction and before

206
00:08:09,710 --> 00:08:13,280
this is call instruction you pass some

207
00:08:11,180 --> 00:08:16,970
parameters in this case is the value 1

208
00:08:13,280 --> 00:08:19,400
in one of the CPU registers there's a

209
00:08:16,970 --> 00:08:21,260
nice table that you can find for Linux

210
00:08:19,400 --> 00:08:24,049
and for any operating system that says

211
00:08:21,260 --> 00:08:25,640
in this case value number 1 is a system

212
00:08:24,050 --> 00:08:27,440
write command so this would be an

213
00:08:25,640 --> 00:08:29,330
attempt to write to a file it also

214
00:08:27,440 --> 00:08:31,580
receives other parameters because it has

215
00:08:29,330 --> 00:08:33,620
to know which file to write to what it's

216
00:08:31,580 --> 00:08:35,929
writing to how many bytes to write you

217
00:08:33,620 --> 00:08:37,370
and stuff like that and this is

218
00:08:35,929 --> 00:08:39,739
something that you have to do manually

219
00:08:37,370 --> 00:08:43,339
unicorn allows you to do that by hooking

220
00:08:39,740 --> 00:08:45,290
the system call function and once you

221
00:08:43,339 --> 00:08:46,910
can look it look at the register values

222
00:08:45,290 --> 00:08:51,110
you know what you do to emulate the

223
00:08:46,910 --> 00:08:53,780
system call and your emulator

224
00:08:51,110 --> 00:08:54,410
so I said unicorn helps us with CPU

225
00:08:53,780 --> 00:08:56,420
execution

226
00:08:54,410 --> 00:08:58,490
what's cool about unicorn is the fact

227
00:08:56,420 --> 00:09:00,140
that it's got bindings for different

228
00:08:58,490 --> 00:09:01,910
languages I give you the example of

229
00:09:00,140 --> 00:09:04,580
Kimen which basically is a lot of C code

230
00:09:01,910 --> 00:09:06,980
you have to go with C unicorn is highly

231
00:09:04,580 --> 00:09:08,960
easy to customize it's got bindings for

232
00:09:06,980 --> 00:09:11,150
different languages my de facto language

233
00:09:08,960 --> 00:09:13,280
is Python and you can easily bind a lot

234
00:09:11,150 --> 00:09:14,410
of the stuff and execute and do

235
00:09:13,280 --> 00:09:17,810
everything in Python

236
00:09:14,410 --> 00:09:19,790
once you identify an entry point for the

237
00:09:17,810 --> 00:09:22,040
file once you've done the binary

238
00:09:19,790 --> 00:09:25,069
reloading part you just have to specify

239
00:09:22,040 --> 00:09:27,020
the entry point and then do unicorn mu

240
00:09:25,070 --> 00:09:29,360
start start emulating and it will start

241
00:09:27,020 --> 00:09:32,120
executing instructions up until the

242
00:09:29,360 --> 00:09:35,090
point it can no longer do that you also

243
00:09:32,120 --> 00:09:37,550
have nice and easy access to writing

244
00:09:35,090 --> 00:09:39,080
memory reading memory writing registries

245
00:09:37,550 --> 00:09:42,109
and everything so you can do it with

246
00:09:39,080 --> 00:09:43,520
just a couple of helper functions just a

247
00:09:42,110 --> 00:09:45,470
couple of lines of Python to do

248
00:09:43,520 --> 00:09:50,180
everything you need at any point that

249
00:09:45,470 --> 00:09:53,060
you need so with that knowledge I've

250
00:09:50,180 --> 00:09:55,430
loaded the binary I'm so happy I can now

251
00:09:53,060 --> 00:09:58,040
start the emulation this is an example

252
00:09:55,430 --> 00:10:01,609
from a piece of simple C code that just

253
00:09:58,040 --> 00:10:05,050
printed test the word test I should see

254
00:10:01,610 --> 00:10:09,310
this working and it completely crashes

255
00:10:05,050 --> 00:10:12,290
not so happy then then I realized why

256
00:10:09,310 --> 00:10:15,739
real-life applications need more memory

257
00:10:12,290 --> 00:10:17,719
than they were designed because for

258
00:10:15,740 --> 00:10:20,390
example you have one C file that's going

259
00:10:17,720 --> 00:10:21,920
to you know the binary will just read

260
00:10:20,390 --> 00:10:23,510
contents from a file maybe write

261
00:10:21,920 --> 00:10:25,280
something write a couple of numbers it

262
00:10:23,510 --> 00:10:27,260
doesn't know how many how much data you

263
00:10:25,280 --> 00:10:29,000
need to write so at some point it will

264
00:10:27,260 --> 00:10:33,080
need more and more memory to be able to

265
00:10:29,000 --> 00:10:34,910
do that so of course we have system

266
00:10:33,080 --> 00:10:36,740
calls for that like I said the operating

267
00:10:34,910 --> 00:10:38,839
system ensures memory management and

268
00:10:36,740 --> 00:10:40,310
everything there's a map there's break

269
00:10:38,840 --> 00:10:45,110
each of them gets used in different

270
00:10:40,310 --> 00:10:47,510
contexts and you have to also emulate

271
00:10:45,110 --> 00:10:49,220
these so these are about the basic

272
00:10:47,510 --> 00:10:53,600
system calls that you need to be able to

273
00:10:49,220 --> 00:10:56,000
handle for foreign on unpacker but once

274
00:10:53,600 --> 00:10:58,130
you have memory management you also have

275
00:10:56,000 --> 00:10:59,930
to do some sort of memory manager thing

276
00:10:58,130 --> 00:11:02,030
similar to what the operating system

277
00:10:59,930 --> 00:11:03,800
does and this is where it might get a

278
00:11:02,030 --> 00:11:04,319
bit tricky because you basically have to

279
00:11:03,800 --> 00:11:05,699
emulate

280
00:11:04,320 --> 00:11:08,130
from the stuff that the Linux memory

281
00:11:05,700 --> 00:11:10,140
allocator does behind the scenes that's

282
00:11:08,130 --> 00:11:11,790
not extremely well documented but again

283
00:11:10,140 --> 00:11:15,030
you can find some hints some examples

284
00:11:11,790 --> 00:11:17,040
online and with a bit of just basic

285
00:11:15,030 --> 00:11:23,970
arithmetic stuff seems to go along

286
00:11:17,040 --> 00:11:26,550
pretty well so like I said I will run

287
00:11:23,970 --> 00:11:29,760
you through a couple of examples first

288
00:11:26,550 --> 00:11:32,040
of all you px I said you px is the go-to

289
00:11:29,760 --> 00:11:35,280
tool right now for backing Linux

290
00:11:32,040 --> 00:11:37,650
binaries the it's used a lot for like

291
00:11:35,280 --> 00:11:39,329
IOT malware for stuff like that because

292
00:11:37,650 --> 00:11:41,280
it's got a pretty nice and low

293
00:11:39,330 --> 00:11:43,530
fingerprint so it's not very operating

294
00:11:41,280 --> 00:11:45,480
system intensive it doesn't use too much

295
00:11:43,530 --> 00:11:48,420
CPU doesn't use too much everything it

296
00:11:45,480 --> 00:11:50,400
also reduces the size of binary and it's

297
00:11:48,420 --> 00:11:52,410
nice and open source you can easily take

298
00:11:50,400 --> 00:11:54,510
it reuse it maybe even customize it

299
00:11:52,410 --> 00:11:55,530
change something inside to hinder and

300
00:11:54,510 --> 00:11:58,230
analysts work

301
00:11:55,530 --> 00:12:01,079
I also have three packers that I found

302
00:11:58,230 --> 00:12:03,090
on github basically well I dug them up

303
00:12:01,080 --> 00:12:04,860
from a presentation that seemed pretty

304
00:12:03,090 --> 00:12:06,690
cool and interesting with the stuff that

305
00:12:04,860 --> 00:12:09,570
they do I decided to give those a shot

306
00:12:06,690 --> 00:12:11,430
because once you are able to handle a

307
00:12:09,570 --> 00:12:13,560
couple of packers you should generally

308
00:12:11,430 --> 00:12:16,020
be able to handle about any type of

309
00:12:13,560 --> 00:12:18,180
packing that malware uses you might run

310
00:12:16,020 --> 00:12:20,610
into some special cases but normally you

311
00:12:18,180 --> 00:12:22,380
would have when automating large-scale

312
00:12:20,610 --> 00:12:25,020
stuff most of the things will just work

313
00:12:22,380 --> 00:12:28,380
an altar is showing an example of a

314
00:12:25,020 --> 00:12:30,180
malware sample we're not necessarily the

315
00:12:28,380 --> 00:12:32,490
packing part and unpacking part is

316
00:12:30,180 --> 00:12:34,380
interesting but just the fact that you

317
00:12:32,490 --> 00:12:37,380
can gather more and more info from

318
00:12:34,380 --> 00:12:39,240
emulation and if you're wondering how it

319
00:12:37,380 --> 00:12:41,040
shows those three packers I said I found

320
00:12:39,240 --> 00:12:44,940
them in a presentation it's from a

321
00:12:41,040 --> 00:12:48,209
presentation at radar icon by UNIX

322
00:12:44,940 --> 00:12:50,010
freaks JP one of the people behind the

323
00:12:48,210 --> 00:12:52,830
malware muzzled I project if you have

324
00:12:50,010 --> 00:12:54,569
ever heard about it if not basically

325
00:12:52,830 --> 00:12:57,000
there's some people people who have been

326
00:12:54,570 --> 00:12:59,310
tracking Linux binaries Linux malware

327
00:12:57,000 --> 00:13:01,290
for a good number of years now they know

328
00:12:59,310 --> 00:13:02,160
a lot of things about what attackers do

329
00:13:01,290 --> 00:13:05,569
and things like that

330
00:13:02,160 --> 00:13:08,130
and at some point looked into how

331
00:13:05,570 --> 00:13:10,560
malware authors back their malware and

332
00:13:08,130 --> 00:13:12,360
how you can actually get about to seeing

333
00:13:10,560 --> 00:13:14,579
what the Executive Board does during

334
00:13:12,360 --> 00:13:16,680
your analysis and when one of those

335
00:13:14,580 --> 00:13:17,230
slides is just said okay so these are

336
00:13:16,680 --> 00:13:19,120
some

337
00:13:17,230 --> 00:13:21,070
packers I found online and I said okay

338
00:13:19,120 --> 00:13:23,380
cool Packers and interesting if I can

339
00:13:21,070 --> 00:13:28,240
unpack a cool binary then I should be

340
00:13:23,380 --> 00:13:29,710
able to unpack everything right so the

341
00:13:28,240 --> 00:13:31,330
first example is upx

342
00:13:29,710 --> 00:13:33,910
where I decided to make things a bit

343
00:13:31,330 --> 00:13:35,470
harder because upx like I said just has

344
00:13:33,910 --> 00:13:37,890
a decompression command that you can use

345
00:13:35,470 --> 00:13:40,330
and there is a simple way to bypass that

346
00:13:37,890 --> 00:13:42,460
basically at the beginning of a binary

347
00:13:40,330 --> 00:13:44,200
that's been packed by upx there's a

348
00:13:42,460 --> 00:13:47,680
header the header contains the strings

349
00:13:44,200 --> 00:13:50,080
the string upx exclamation mark if that

350
00:13:47,680 --> 00:13:52,689
marker gets ruined in any way like

351
00:13:50,080 --> 00:13:56,050
substituted by four random bytes ABC

352
00:13:52,690 --> 00:13:58,330
question mark in my example upx will no

353
00:13:56,050 --> 00:13:59,709
longer be able to uncompress it will

354
00:13:58,330 --> 00:14:01,690
give you a nicer message like this

355
00:13:59,710 --> 00:14:05,080
answer I can't unpack this because it

356
00:14:01,690 --> 00:14:08,070
seems to be corrupt so that's what I did

357
00:14:05,080 --> 00:14:12,250
I took a test file in this case it was

358
00:14:08,070 --> 00:14:14,830
the Linux LS binary I packed it with upx

359
00:14:12,250 --> 00:14:17,590
and then you know tested that it still

360
00:14:14,830 --> 00:14:21,820
worked modify the header again tested at

361
00:14:17,590 --> 00:14:23,370
work and then tried emulating it do you

362
00:14:21,820 --> 00:14:25,630
think it worked

363
00:14:23,370 --> 00:14:30,040
nobody has any idea of course it worked

364
00:14:25,630 --> 00:14:32,290
out whereas it wouldn't be here first

365
00:14:30,040 --> 00:14:34,990
things first make sure that you cannot

366
00:14:32,290 --> 00:14:36,880
find the original strings inside that's

367
00:14:34,990 --> 00:14:39,340
the lesson I learned the hard way so

368
00:14:36,880 --> 00:14:41,680
basically if you do LS minus minus help

369
00:14:39,340 --> 00:14:43,240
is going to tell you usage whatever is

370
00:14:41,680 --> 00:14:45,640
going to tell you some stuff I just

371
00:14:43,240 --> 00:14:47,320
check that there's the strings no longer

372
00:14:45,640 --> 00:14:50,110
appear inside the binary that's been

373
00:14:47,320 --> 00:14:52,780
packed after that

374
00:14:50,110 --> 00:14:53,950
I emulated it and at one point emulation

375
00:14:52,780 --> 00:14:55,839
can all take you so far

376
00:14:53,950 --> 00:14:58,060
stuff will crash and at that point I

377
00:14:55,840 --> 00:15:00,520
just had unicorn dump of the memory two

378
00:14:58,060 --> 00:15:01,989
separate files and just use the grep to

379
00:15:00,520 --> 00:15:03,640
search for the strings and you can see

380
00:15:01,990 --> 00:15:05,740
the usage strings over there so

381
00:15:03,640 --> 00:15:08,199
basically what happened emulation

382
00:15:05,740 --> 00:15:10,510
managed to get the unpacked version into

383
00:15:08,200 --> 00:15:12,070
memory and at that point I dumped the

384
00:15:10,510 --> 00:15:13,360
memory and had access to the original

385
00:15:12,070 --> 00:15:16,930
malware contents

386
00:15:13,360 --> 00:15:19,420
well Ellis in this case not malware so

387
00:15:16,930 --> 00:15:22,900
the upx example works it also works with

388
00:15:19,420 --> 00:15:25,420
minor modifications until the next one

389
00:15:22,900 --> 00:15:27,220
the next tool this is one of the cool

390
00:15:25,420 --> 00:15:28,959
Packers is called Packer elf you can

391
00:15:27,220 --> 00:15:31,690
find it on github

392
00:15:28,960 --> 00:15:35,770
it's got support for 64-bit binaries

393
00:15:31,690 --> 00:15:37,480
which I was interested in and I tried

394
00:15:35,770 --> 00:15:40,600
using getting emulating it and my

395
00:15:37,480 --> 00:15:42,339
emulator crashed and after about one day

396
00:15:40,600 --> 00:15:45,250
of the bugging I realized why it crashed

397
00:15:42,339 --> 00:15:47,920
to the recent crashes that the Packer

398
00:15:45,250 --> 00:15:49,420
seems to crash itself so basically the

399
00:15:47,920 --> 00:15:51,550
stuff that I would pack wouldn't even

400
00:15:49,420 --> 00:15:54,069
execute outside of the emulator on plain

401
00:15:51,550 --> 00:15:55,870
old Linux so like I said research goes

402
00:15:54,070 --> 00:15:58,420
up and down up and down up and down if

403
00:15:55,870 --> 00:16:00,010
this was one of the downs I gave up on

404
00:15:58,420 --> 00:16:02,110
this since if you can't use it to pack

405
00:16:00,010 --> 00:16:05,290
an executor of malware I don't see any

406
00:16:02,110 --> 00:16:07,210
point in analyzing it so I went to the

407
00:16:05,290 --> 00:16:10,329
next one the next one is called elf

408
00:16:07,210 --> 00:16:10,839
packer this one I needed a new target

409
00:16:10,330 --> 00:16:13,060
for it

410
00:16:10,839 --> 00:16:16,510
it's just simple code that would print

411
00:16:13,060 --> 00:16:18,369
Adrienne was here bad idea to use test

412
00:16:16,510 --> 00:16:20,350
as the keyword you're searching for with

413
00:16:18,370 --> 00:16:23,050
statically compiled binaries very bad

414
00:16:20,350 --> 00:16:25,360
idea why need a statically compiled

415
00:16:23,050 --> 00:16:27,910
binary was the fact that the way of

416
00:16:25,360 --> 00:16:30,339
Packer was is by creating a code cave

417
00:16:27,910 --> 00:16:32,800
just looks for a large number of null

418
00:16:30,339 --> 00:16:35,050
bytes inside the original file and then

419
00:16:32,800 --> 00:16:36,910
it's going to overwrite them and set the

420
00:16:35,050 --> 00:16:38,319
entry point of the binary to that add it

421
00:16:36,910 --> 00:16:39,939
into one of those addresses so it's

422
00:16:38,320 --> 00:16:43,120
going to start execution from a section

423
00:16:39,940 --> 00:16:44,800
that was originally null bytes that's

424
00:16:43,120 --> 00:16:47,170
why you have to do static compilation

425
00:16:44,800 --> 00:16:50,529
together have a good chance of finding a

426
00:16:47,170 --> 00:16:52,810
lot of no bytes in memory and with that

427
00:16:50,529 --> 00:16:55,029
I did the exact same thing emulator the

428
00:16:52,810 --> 00:16:58,500
binary lo and behold the string was in

429
00:16:55,029 --> 00:17:01,870
there I was very happy until a typo

430
00:16:58,500 --> 00:17:04,089
brought me to this thing so because of a

431
00:17:01,870 --> 00:17:06,760
typo I saw that oh look I have the

432
00:17:04,089 --> 00:17:08,409
string in clear text inside the original

433
00:17:06,760 --> 00:17:12,929
file basically I did not unpack anything

434
00:17:08,410 --> 00:17:16,209
what's going on here so back to that

435
00:17:12,929 --> 00:17:17,800
documentation part it actually said as I

436
00:17:16,209 --> 00:17:21,250
read the documentation completely I

437
00:17:17,800 --> 00:17:23,559
don't think anyone does that but it only

438
00:17:21,250 --> 00:17:27,369
does encryption of the text section of a

439
00:17:23,559 --> 00:17:29,290
binary so one binary will probably have

440
00:17:27,369 --> 00:17:31,300
code sections it may also have data

441
00:17:29,290 --> 00:17:33,120
sections and static strings like this

442
00:17:31,300 --> 00:17:36,750
one will go into the data section and

443
00:17:33,120 --> 00:17:39,340
elf Packer only packs the code part

444
00:17:36,750 --> 00:17:40,960
unfortunately so in this case you can't

445
00:17:39,340 --> 00:17:41,559
if you're trying to read some malware in

446
00:17:40,960 --> 00:17:43,629
packet you

447
00:17:41,559 --> 00:17:45,100
something like health Packer I would

448
00:17:43,629 --> 00:17:46,539
recommend against it because it's going

449
00:17:45,100 --> 00:17:48,870
to live a lot of things hanging around

450
00:17:46,539 --> 00:17:48,870
in clear-text

451
00:17:49,710 --> 00:17:54,070
so my third target of opportunity that

452
00:17:52,419 --> 00:17:55,629
seemed the coolest is called midget pack

453
00:17:54,070 --> 00:17:57,100
and midget pack seemed interesting

454
00:17:55,629 --> 00:17:59,168
because instead of just doing like

455
00:17:57,100 --> 00:18:01,959
simples or instructions or stuff like

456
00:17:59,169 --> 00:18:03,909
that it actually did cryptography like

457
00:18:01,960 --> 00:18:06,399
good cryptography you can see the list

458
00:18:03,909 --> 00:18:07,929
of algorithm there I went with the

459
00:18:06,399 --> 00:18:10,389
password based version you can also

460
00:18:07,929 --> 00:18:12,220
specify a key file for decrypting on

461
00:18:10,389 --> 00:18:14,408
execution I went with password based

462
00:18:12,220 --> 00:18:16,450
basically because I was a bit lazy and

463
00:18:14,409 --> 00:18:20,799
didn't want to mess up with a separate

464
00:18:16,450 --> 00:18:23,499
key file first thing first make sure

465
00:18:20,799 --> 00:18:25,658
that the strings actually get encrypted

466
00:18:23,499 --> 00:18:28,659
okay like I said I learned that the hard

467
00:18:25,659 --> 00:18:30,940
way then went about doing the same thing

468
00:18:28,659 --> 00:18:34,809
emulated binary dumped the memory and

469
00:18:30,940 --> 00:18:36,940
the string appears in clear text and if

470
00:18:34,809 --> 00:18:38,769
you you might be wondering okay but this

471
00:18:36,940 --> 00:18:40,659
is cryptography cryptography generally

472
00:18:38,769 --> 00:18:42,669
moves about pretty slowly you have a lot

473
00:18:40,659 --> 00:18:44,649
of CPU instructions being executed on

474
00:18:42,669 --> 00:18:46,840
and on and on some of them were pretty

475
00:18:44,649 --> 00:18:48,998
slow compared to others like basics or

476
00:18:46,840 --> 00:18:51,490
how fast does this work

477
00:18:48,999 --> 00:18:54,460
well my first attempt needed an

478
00:18:51,490 --> 00:18:56,409
overnight run then I discovered I had

479
00:18:54,460 --> 00:18:57,970
actually used a nice debugging feature

480
00:18:56,409 --> 00:19:00,399
in unicorn which allows you to hook

481
00:18:57,970 --> 00:19:02,440
stuff onto every CPU instruction and it

482
00:19:00,399 --> 00:19:04,869
was just incrementing a basic counter by

483
00:19:02,440 --> 00:19:07,299
one once I was able to figure that out

484
00:19:04,869 --> 00:19:09,970
and commented that line it actually ran

485
00:19:07,299 --> 00:19:11,740
in about two to three seconds that's as

486
00:19:09,970 --> 00:19:12,999
that's about as fast as you can get

487
00:19:11,740 --> 00:19:15,129
especially since we're dealing with

488
00:19:12,999 --> 00:19:17,919
cryptography stuff if it was just one of

489
00:19:15,129 --> 00:19:19,658
those simple Zoar Packers it moves blitz

490
00:19:17,919 --> 00:19:21,669
emulation apparently seems to have gone

491
00:19:19,659 --> 00:19:23,619
a far away I know how many of you have

492
00:19:21,669 --> 00:19:26,740
used an emulator like box or chemo or

493
00:19:23,619 --> 00:19:28,149
anything before but there unicorn is

494
00:19:26,740 --> 00:19:34,509
actually doing a pretty good and fast

495
00:19:28,149 --> 00:19:36,489
job at executing these and onto the

496
00:19:34,509 --> 00:19:38,049
malware sample with a malware sample I

497
00:19:36,490 --> 00:19:41,200
didn't focus so much on the packing like

498
00:19:38,049 --> 00:19:43,960
I said now that I know I'm able to feed

499
00:19:41,200 --> 00:19:46,029
general Packers I would like to see what

500
00:19:43,960 --> 00:19:49,330
how can you use this for more analysis

501
00:19:46,029 --> 00:19:51,070
and the idea is system calls again

502
00:19:49,330 --> 00:19:53,110
because anything that malware needs to

503
00:19:51,070 --> 00:19:54,600
do is going to devise system calls

504
00:19:53,110 --> 00:19:56,939
so just by hooking those you

505
00:19:54,600 --> 00:19:58,439
see took some interesting system calls

506
00:19:56,940 --> 00:20:00,150
and see what happens and this is an

507
00:19:58,440 --> 00:20:03,809
example from one of the many Murray

508
00:20:00,150 --> 00:20:05,789
binaries that exist in the wild which is

509
00:20:03,809 --> 00:20:09,510
actually opening a socket and trying to

510
00:20:05,789 --> 00:20:12,000
connect you 8 8 8 8 you all know that IP

511
00:20:09,510 --> 00:20:13,740
RK is the Google Public DNS server and

512
00:20:12,000 --> 00:20:16,440
this is a behavior that's been spotted

513
00:20:13,740 --> 00:20:18,360
and some of the more modern and modified

514
00:20:16,440 --> 00:20:20,549
Mareike phones where they would try to

515
00:20:18,360 --> 00:20:23,100
connect to 8 8 8 8 basically just

516
00:20:20,549 --> 00:20:24,960
checking if they do have an internet

517
00:20:23,100 --> 00:20:26,490
connection available and if they do have

518
00:20:24,960 --> 00:20:28,559
an internet connection available they

519
00:20:26,490 --> 00:20:30,150
say ok this is not a sandbox machine I'm

520
00:20:28,559 --> 00:20:32,240
just going to continue executing and

521
00:20:30,150 --> 00:20:35,789
actually doing the malicious part now

522
00:20:32,240 --> 00:20:38,490
and you can actually see this using an

523
00:20:35,789 --> 00:20:40,110
emulator and you can go forth and look

524
00:20:38,490 --> 00:20:43,080
into more system calls and then you can

525
00:20:40,110 --> 00:20:47,100
see it also binding to a socket and

526
00:20:43,080 --> 00:20:49,020
starting listening on a port so just

527
00:20:47,100 --> 00:20:50,730
with a simple Python script that's able

528
00:20:49,020 --> 00:20:52,710
to handle a couple of general cases you

529
00:20:50,730 --> 00:20:56,280
get to the point where I can say this

530
00:20:52,710 --> 00:20:58,950
binary over here does a connection check

531
00:20:56,280 --> 00:21:01,530
and then goes about listening on of on a

532
00:20:58,950 --> 00:21:03,750
port it's probably a backdoor it might

533
00:21:01,530 --> 00:21:05,700
be trying to host malware and spread it

534
00:21:03,750 --> 00:21:07,470
around for other people to use or

535
00:21:05,700 --> 00:21:09,750
whatever most likely a backdoor I would

536
00:21:07,470 --> 00:21:13,230
say I haven't looked into it much more

537
00:21:09,750 --> 00:21:15,030
than that but like I said it's useful

538
00:21:13,230 --> 00:21:16,919
info it's very useful info when you're

539
00:21:15,030 --> 00:21:17,879
trying to analyze a binary first and you

540
00:21:16,919 --> 00:21:19,559
don't have too much information

541
00:21:17,880 --> 00:21:25,049
especially because of the layers of

542
00:21:19,559 --> 00:21:26,700
packing that get added to it so in

543
00:21:25,049 --> 00:21:28,549
conclusion I would say that the

544
00:21:26,700 --> 00:21:31,049
emulation approach is worth it

545
00:21:28,549 --> 00:21:33,330
people have been using it for some time

546
00:21:31,049 --> 00:21:35,129
but it does have it it did have its

547
00:21:33,330 --> 00:21:36,928
limitations right now with something

548
00:21:35,130 --> 00:21:38,970
else easy to use as unicorn you can

549
00:21:36,929 --> 00:21:42,330
easily do more and more advanced

550
00:21:38,970 --> 00:21:44,340
analysis at scale using this the

551
00:21:42,330 --> 00:21:45,840
information you gather is useful I mean

552
00:21:44,340 --> 00:21:48,780
for me it's very useful to be able to

553
00:21:45,840 --> 00:21:51,270
get a foothold on what's going to happen

554
00:21:48,780 --> 00:21:53,280
on execution I might decide to send back

555
00:21:51,270 --> 00:21:55,049
this sample I might decide to say okay

556
00:21:53,280 --> 00:21:57,360
this is clearly something bad I don't

557
00:21:55,049 --> 00:21:58,950
care I'm not looking into it anymore but

558
00:21:57,360 --> 00:22:01,020
you can just use it for a couple you

559
00:21:58,950 --> 00:22:02,790
know two or three seconds run can

560
00:22:01,020 --> 00:22:05,750
actually get you a lot of info that you

561
00:22:02,790 --> 00:22:08,470
can then use for more advanced analysis

562
00:22:05,750 --> 00:22:11,980
it's pretty easy to custom

563
00:22:08,470 --> 00:22:15,370
so everything that I presented here is

564
00:22:11,980 --> 00:22:18,100
just about one or two hundred lines of

565
00:22:15,370 --> 00:22:20,199
Python code that's about all it takes

566
00:22:18,100 --> 00:22:22,270
after you do install a couple of package

567
00:22:20,200 --> 00:22:27,220
dependencies it's like two hundred lines

568
00:22:22,270 --> 00:22:29,290
of code that's that's awesome to me like

569
00:22:27,220 --> 00:22:31,360
I said it's fast it's fast and it is

570
00:22:29,290 --> 00:22:32,860
very easy to deploy scale because you're

571
00:22:31,360 --> 00:22:36,340
basically just installing a Python

572
00:22:32,860 --> 00:22:40,899
package wherever you want to try and do

573
00:22:36,340 --> 00:22:42,309
the simulation and research is fun it's

574
00:22:40,900 --> 00:22:44,169
a nice game of ups and downs and

575
00:22:42,309 --> 00:22:47,200
everything but at the end I found it to

576
00:22:44,169 --> 00:22:49,480
be incredibly enjoyable worth it and if

577
00:22:47,200 --> 00:22:51,490
you people are not doing any sort of

578
00:22:49,480 --> 00:22:53,260
research on your own now I highly

579
00:22:51,490 --> 00:22:55,210
encourage you to do it because it's

580
00:22:53,260 --> 00:22:57,250
actually an enjoyable activity and I

581
00:22:55,210 --> 00:22:58,780
think you'll like it and I think more

582
00:22:57,250 --> 00:23:03,010
value we'll get at it to the world that

583
00:22:58,780 --> 00:23:07,510
way and that's about it for me if you

584
00:23:03,010 --> 00:23:09,400
guys have any questions keep in mind

585
00:23:07,510 --> 00:23:12,400
that for every question we take we're

586
00:23:09,400 --> 00:23:16,000
also offering goodies yes and we have

587
00:23:12,400 --> 00:23:18,970
asked the question in another speakers

588
00:23:16,000 --> 00:23:20,770
presentation sure we have two

589
00:23:18,970 --> 00:23:23,470
microphones that we'd like to offer to

590
00:23:20,770 --> 00:23:26,010
people in the audience yes the person

591
00:23:23,470 --> 00:23:26,010
over there

592
00:23:39,530 --> 00:23:48,178
it's the song yes unicorn thing is

593
00:23:44,220 --> 00:23:50,100
actually a framework yeah you can just

594
00:23:48,179 --> 00:23:52,289
don't let it out the internet it's open

595
00:23:50,100 --> 00:23:54,360
source don't get hub right yeah you can

596
00:23:52,289 --> 00:23:57,750
find it on github I think you can just

597
00:23:54,360 --> 00:23:59,820
do pip install unicorn on any box I

598
00:23:57,750 --> 00:24:01,409
think it's a bit more I think I had to

599
00:23:59,820 --> 00:24:05,030
do some more work for Python 3 or

600
00:24:01,409 --> 00:24:05,030
something like that but that's about it

601
00:24:07,520 --> 00:24:11,549
we're not using it for production right

602
00:24:09,900 --> 00:24:14,429
now so this is abuse he only started

603
00:24:11,549 --> 00:24:16,470
some time ago I did some work on it but

604
00:24:14,429 --> 00:24:17,850
it's still in a QC phase it's able to do

605
00:24:16,470 --> 00:24:20,760
quite a lot of things more than I

606
00:24:17,850 --> 00:24:26,668
expected actually but hopefully we'll be

607
00:24:20,760 --> 00:24:30,390
able to use it one day you can Google

608
00:24:26,669 --> 00:24:30,860
unicornia first thank you results may

609
00:24:30,390 --> 00:24:40,200
vary

610
00:24:30,860 --> 00:24:43,229
yeah hello you mentioned before the

611
00:24:40,200 --> 00:24:44,789
honey pots yes can you tell us what type

612
00:24:43,230 --> 00:24:48,419
of honey pots are using to capture

613
00:24:44,789 --> 00:24:50,220
malware well we're using both open

614
00:24:48,419 --> 00:24:53,100
source stuff that you would find online

615
00:24:50,220 --> 00:24:54,929
like diony uh you know the regular honey

616
00:24:53,100 --> 00:24:57,539
pots that you can use we also have some

617
00:24:54,929 --> 00:25:01,919
stuff that we developed on our own for

618
00:24:57,539 --> 00:25:04,408
different kinds of things and we we have

619
00:25:01,919 --> 00:25:06,330
a lot of different ones so we have like

620
00:25:04,409 --> 00:25:08,340
padania for us and being a couple of

621
00:25:06,330 --> 00:25:10,309
other protocols we have web honey pots

622
00:25:08,340 --> 00:25:12,750
we have some which are targeted at

623
00:25:10,309 --> 00:25:15,149
custom exploits for different cell types

624
00:25:12,750 --> 00:25:18,120
of systems so basically when something

625
00:25:15,150 --> 00:25:19,590
comes about and seems to be dangerous to

626
00:25:18,120 --> 00:25:21,899
a lot of systems that scare we try to

627
00:25:19,590 --> 00:25:23,639
create a honeypot for it as simple as

628
00:25:21,900 --> 00:25:25,169
possible just drop a Python script that

629
00:25:23,640 --> 00:25:30,450
binds to a port and says okay I'm

630
00:25:25,169 --> 00:25:36,299
vulnerable exploit me hi and thank you

631
00:25:30,450 --> 00:25:39,539
for the presentation so you showed us on

632
00:25:36,299 --> 00:25:43,470
earth see on RC compile the program on I

633
00:25:39,539 --> 00:25:46,110
guess it was an Intel CPU yeah does this

634
00:25:43,470 --> 00:25:49,809
work also on an IR m or meeps

635
00:25:46,110 --> 00:25:52,418
cpu so my peers here right now know

636
00:25:49,809 --> 00:25:54,668
I want to expand on it I judge myself in

637
00:25:52,419 --> 00:25:57,340
the fact that the people doing clinics

638
00:25:54,669 --> 00:25:58,809
malware right now they supply binaries

639
00:25:57,340 --> 00:26:00,699
for a lot of different architectures

640
00:25:58,809 --> 00:26:03,219
they supply them for a lot of different

641
00:26:00,700 --> 00:26:05,739
ones if we need to get a couple of

642
00:26:03,219 --> 00:26:07,479
modifications but unicorn is able to do

643
00:26:05,739 --> 00:26:08,679
that without a problem so it supports a

644
00:26:07,479 --> 00:26:11,859
lot of different things

645
00:26:08,679 --> 00:26:14,200
the only thing would be you know like

646
00:26:11,859 --> 00:26:15,939
doing it on Linux is easier than doing

647
00:26:14,200 --> 00:26:17,619
other Windows I guess because windows

648
00:26:15,940 --> 00:26:19,840
miners are a bit more convoluted to

649
00:26:17,619 --> 00:26:22,359
execute on everything yes but you can

650
00:26:19,840 --> 00:26:24,959
definitely use unicorn for MIPS and arm

651
00:26:22,359 --> 00:26:27,129
and everything like that okay thank you

652
00:26:24,960 --> 00:26:29,889
let's take some questions from another

653
00:26:27,129 --> 00:26:35,580
part of the audience let's take it from

654
00:26:29,889 --> 00:26:35,580
the left I guess not

655
00:26:45,390 --> 00:26:53,570
I was wondering if the time efficient

656
00:26:48,780 --> 00:26:57,750
efficiency that you mentioned could be

657
00:26:53,570 --> 00:27:03,510
worth to be used in real-time file

658
00:26:57,750 --> 00:27:04,430
content analysis I actually don't think

659
00:27:03,510 --> 00:27:07,740
so

660
00:27:04,430 --> 00:27:10,410
basically I know when you right-click

661
00:27:07,740 --> 00:27:13,200
something go scan this file or something

662
00:27:10,410 --> 00:27:16,170
it's kind of it would take handle all of

663
00:27:13,200 --> 00:27:17,910
a long time and if you have real-time

664
00:27:16,170 --> 00:27:18,960
analysis okay you don't have to right

665
00:27:17,910 --> 00:27:20,940
click on everything but when I

666
00:27:18,960 --> 00:27:23,250
double-click the binary on my system I

667
00:27:20,940 --> 00:27:25,260
would expect it to just start and I'm

668
00:27:23,250 --> 00:27:27,900
adding a one two three second delay over

669
00:27:25,260 --> 00:27:29,940
that the thing is what happens with

670
00:27:27,900 --> 00:27:31,350
antivirus products now it's been going

671
00:27:29,940 --> 00:27:33,480
on for a good number of years now they

672
00:27:31,350 --> 00:27:36,270
do some sort of limited sandboxes inside

673
00:27:33,480 --> 00:27:37,640
for analysis so this is not I don't

674
00:27:36,270 --> 00:27:39,750
think this would necessarily be

675
00:27:37,640 --> 00:27:42,120
efficient you know for an endpoint

676
00:27:39,750 --> 00:27:44,460
security product but when you do offline

677
00:27:42,120 --> 00:27:46,409
processing of stuff and try to do it at

678
00:27:44,460 --> 00:27:51,540
scale it's I think it's definitely worth

679
00:27:46,410 --> 00:27:56,070
it so basically the this model should be

680
00:27:51,540 --> 00:27:57,300
used only for static punctual analysis

681
00:27:56,070 --> 00:27:59,159
of the files yeah

682
00:27:57,300 --> 00:28:02,070
it's used for a system like ours which

683
00:27:59,160 --> 00:28:03,600
does a lot of offline online processing

684
00:28:02,070 --> 00:28:05,370
but well it's more like offline

685
00:28:03,600 --> 00:28:07,590
processing since we do it in the cloud

686
00:28:05,370 --> 00:28:10,850
whether the stuff that we're able to

687
00:28:07,590 --> 00:28:13,980
crawl and find in honey pots okay thanks

688
00:28:10,850 --> 00:28:17,389
one last question let's take one from

689
00:28:13,980 --> 00:28:17,390
the other side of the audience please

690
00:28:22,490 --> 00:28:29,280
hi my question would be related to the

691
00:28:26,970 --> 00:28:32,520
fact that okay you Nicole Metasploit any

692
00:28:29,280 --> 00:28:35,220
kind of free framework it's adding a

693
00:28:32,520 --> 00:28:38,820
little a specific pattern to the files

694
00:28:35,220 --> 00:28:41,940
so also the signature so you basically

695
00:28:38,820 --> 00:28:44,370
run those malware instructions in memory

696
00:28:41,940 --> 00:28:47,730
if you plan in the future to have a

697
00:28:44,370 --> 00:28:50,219
research on how to do it on with files

698
00:28:47,730 --> 00:28:53,760
written on the harddrive except the

699
00:28:50,220 --> 00:28:58,470
obvious version of encrypting it if you

700
00:28:53,760 --> 00:29:00,900
plan to do that well not necessarily

701
00:28:58,470 --> 00:29:03,690
because like I said the stuff we work

702
00:29:00,900 --> 00:29:05,370
with most of the time is just stuff that

703
00:29:03,690 --> 00:29:08,789
we get and we send to our back-end

704
00:29:05,370 --> 00:29:10,559
processing system so basically when we

705
00:29:08,789 --> 00:29:12,840
get something in a honeypot we know it's

706
00:29:10,559 --> 00:29:15,090
likely I mean who is going to upload

707
00:29:12,840 --> 00:29:17,549
windows calculator when doing an RC

708
00:29:15,090 --> 00:29:19,770
against a honeypot right it's most

709
00:29:17,549 --> 00:29:21,870
likely malware we just try to find if

710
00:29:19,770 --> 00:29:26,730
it's malware if it's interesting how it

711
00:29:21,870 --> 00:29:28,530
behaves and stuff like that static

712
00:29:26,730 --> 00:29:30,210
analysis we also do dynamic and

713
00:29:28,530 --> 00:29:36,000
sometimes like in this case you need

714
00:29:30,210 --> 00:29:38,250
something that moves well in between all

715
00:29:36,000 --> 00:29:41,390
right Thank You Adrian for this awesome

716
00:29:38,250 --> 00:29:41,390
presentation thank you

