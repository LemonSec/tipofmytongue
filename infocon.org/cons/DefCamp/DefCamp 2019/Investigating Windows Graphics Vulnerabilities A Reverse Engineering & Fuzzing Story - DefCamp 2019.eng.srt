1
00:00:00,030 --> 00:00:04,350
hello everyone my name is Radha mone

2
00:00:01,920 --> 00:00:05,460
Lucario I'm a security research engineer

3
00:00:04,350 --> 00:00:07,439
at except application and threat

4
00:00:05,460 --> 00:00:09,809
intelligence this is my second time here

5
00:00:07,440 --> 00:00:13,740
at deaf camp and I'm hoping that

6
00:00:09,809 --> 00:00:15,870
everyone has as much fun as I do for

7
00:00:13,740 --> 00:00:18,060
today I'm going to take five irritation

8
00:00:15,870 --> 00:00:26,159
with one of the project that I've been

9
00:00:18,060 --> 00:00:28,970
working at this year so as a security

10
00:00:26,160 --> 00:00:31,289
researcher one of my tasks is to

11
00:00:28,970 --> 00:00:33,750
investigate vulnerabilities in different

12
00:00:31,289 --> 00:00:35,670
kinds of application some of them have

13
00:00:33,750 --> 00:00:38,390
proof of concepts attached to it for

14
00:00:35,670 --> 00:00:40,800
example some of the vulnerabilities have

15
00:00:38,390 --> 00:00:42,780
an exploit published on exploit EB

16
00:00:40,800 --> 00:00:44,339
everyone knows about exploit EB and if

17
00:00:42,780 --> 00:00:45,930
you want to tamper with that exploit you

18
00:00:44,340 --> 00:00:47,930
can simply take the exploit download it

19
00:00:45,930 --> 00:00:51,059
install the vulnerable application and

20
00:00:47,930 --> 00:00:53,280
have fun on your own and see what's

21
00:00:51,059 --> 00:00:55,410
going on with that application with that

22
00:00:53,280 --> 00:00:57,180
vulnerability but what do you do when

23
00:00:55,410 --> 00:01:00,449
you do not have a proof of concept an

24
00:00:57,180 --> 00:01:02,850
exploit for it moreover what do you do

25
00:01:00,449 --> 00:01:04,649
when you don't even have the application

26
00:01:02,850 --> 00:01:06,869
the source code available how do you

27
00:01:04,650 --> 00:01:09,260
investigate those vulnerabilities the

28
00:01:06,869 --> 00:01:12,090
aim of this presentation is to give a

29
00:01:09,260 --> 00:01:14,299
full walkthrough or comprehensive well

30
00:01:12,090 --> 00:01:17,189
true on how would you go about

31
00:01:14,299 --> 00:01:21,720
investigating investigate investigating

32
00:01:17,189 --> 00:01:23,729
these exact cases but before that little

33
00:01:21,720 --> 00:01:30,810
was some words about the Windows

34
00:01:23,729 --> 00:01:33,180
security ecosystem so how many of you

35
00:01:30,810 --> 00:01:35,280
heard about blue chip is a more recent

36
00:01:33,180 --> 00:01:39,560
one please raise your hand a lot of

37
00:01:35,280 --> 00:01:39,560
hands why are you smiling

38
00:01:40,229 --> 00:01:45,689
what about eternal blue this is older

39
00:01:43,290 --> 00:01:48,119
one okay there's clearly a lot of

40
00:01:45,689 --> 00:01:50,008
interest for Windows application and

41
00:01:48,119 --> 00:01:51,659
with those services and lot of security

42
00:01:50,009 --> 00:01:54,360
researchers independent or working at a

43
00:01:51,659 --> 00:01:56,390
company or even people that are trying

44
00:01:54,360 --> 00:02:01,560
to do bad stuff are looking into them

45
00:01:56,390 --> 00:02:03,869
only this year a recorded feature which

46
00:02:01,560 --> 00:02:09,420
is a threat intelligence provider come

47
00:02:03,869 --> 00:02:11,879
up with this this report that the top

48
00:02:09,419 --> 00:02:13,349
ten most exploited vulnerabilities from

49
00:02:11,879 --> 00:02:13,950
the past year were vulnerabilities

50
00:02:13,349 --> 00:02:19,470
actually

51
00:02:13,950 --> 00:02:21,899
in Microsoft Office you just to convince

52
00:02:19,470 --> 00:02:24,000
what to convince or yourself of that you

53
00:02:21,900 --> 00:02:25,080
just have to go on the CV details and

54
00:02:24,000 --> 00:02:26,550
take a look at the number of

55
00:02:25,080 --> 00:02:28,760
vulnerabilities that were showing up in

56
00:02:26,550 --> 00:02:31,950
the Microsoft products for example in

57
00:02:28,760 --> 00:02:34,079
2017 more than 700 of them and this year

58
00:02:31,950 --> 00:02:38,849
about 700 so it's clearly a lot of

59
00:02:34,080 --> 00:02:40,860
interest what's happening when the

60
00:02:38,849 --> 00:02:42,720
Microsoft Research Center or develop

61
00:02:40,860 --> 00:02:44,940
developers working they're discovering a

62
00:02:42,720 --> 00:02:47,609
vulnerability way well they after the

63
00:02:44,940 --> 00:02:50,700
they release a patch they also give away

64
00:02:47,610 --> 00:02:53,880
a security advisory that contains

65
00:02:50,700 --> 00:02:57,089
generic information for example what

66
00:02:53,880 --> 00:02:58,769
kind of vulnerabilities is this taking

67
00:02:57,090 --> 00:03:01,230
place there may be that I confusion

68
00:02:58,769 --> 00:03:03,480
maybe it's a buffer overflow what is the

69
00:03:01,230 --> 00:03:06,268
actual component that is vulnerable for

70
00:03:03,480 --> 00:03:08,970
example it's a service or this GDI

71
00:03:06,269 --> 00:03:10,739
or it's something else the result they

72
00:03:08,970 --> 00:03:12,690
also give a link of obviously to the

73
00:03:10,739 --> 00:03:14,459
patch and you can download it and that's

74
00:03:12,690 --> 00:03:16,109
pretty much it they don't have many

75
00:03:14,459 --> 00:03:20,180
information to start with if you want to

76
00:03:16,110 --> 00:03:22,380
investigate such a vulnerability so I

77
00:03:20,180 --> 00:03:23,489
started looking at the vulnerabilities

78
00:03:22,380 --> 00:03:25,470
that were showing up in Microsoft

79
00:03:23,489 --> 00:03:28,139
products this year and a whole lot of

80
00:03:25,470 --> 00:03:30,060
them started show up in GDI as I didn't

81
00:03:28,139 --> 00:03:33,150
know anything about the GDI whatsoever I

82
00:03:30,060 --> 00:03:34,609
got curious and I started looking into a

83
00:03:33,150 --> 00:03:38,030
certain one of them

84
00:03:34,609 --> 00:03:42,510
GDI stands for graphics device interface

85
00:03:38,030 --> 00:03:45,870
it's a Windows component that allows you

86
00:03:42,510 --> 00:03:47,630
to render fonts and draw shapes and

87
00:03:45,870 --> 00:03:50,760
handle palette and so on

88
00:03:47,630 --> 00:03:52,829
it's its job it's not to render windows

89
00:03:50,760 --> 00:03:56,328
forms that it's taking care button

90
00:03:52,829 --> 00:04:00,959
that's taking care of by another windows

91
00:03:56,329 --> 00:04:03,090
component which is called user 32 if you

92
00:04:00,959 --> 00:04:04,440
a GDI provides an application

93
00:04:03,090 --> 00:04:06,389
programming interface which you can use

94
00:04:04,440 --> 00:04:08,190
to do these kinds of operation you just

95
00:04:06,389 --> 00:04:12,209
have to grab a handle to the window

96
00:04:08,190 --> 00:04:13,859
which is called device device context

97
00:04:12,209 --> 00:04:15,630
then you just do different kinds of

98
00:04:13,859 --> 00:04:18,750
operation then that will get displayed

99
00:04:15,630 --> 00:04:22,650
on that specific window for example we

100
00:04:18,750 --> 00:04:26,070
can draw images you can do rectangles

101
00:04:22,650 --> 00:04:27,508
you can display fonts as I said what

102
00:04:26,070 --> 00:04:34,560
happens

103
00:04:27,509 --> 00:04:36,849
beyond the API let's see so this is a

104
00:04:34,560 --> 00:04:40,060
oversimplified architecture of the GDI

105
00:04:36,849 --> 00:04:43,240
component on one side on the user mode

106
00:04:40,060 --> 00:04:44,979
we have the user mode the GDI this has

107
00:04:43,240 --> 00:04:48,940
been around since the beginning of

108
00:04:44,979 --> 00:04:50,740
Windows it provides you one API that you

109
00:04:48,940 --> 00:04:53,979
can use in order to this kind of

110
00:04:50,740 --> 00:04:56,500
operation starting with Windows XP an

111
00:04:53,979 --> 00:04:57,878
extension to the original in GDI has

112
00:04:56,500 --> 00:05:01,599
been introduced this is fully developed

113
00:04:57,879 --> 00:05:03,370
in C++ his name is GDI plus and it's

114
00:05:01,599 --> 00:05:06,310
kind of an extension of the original in

115
00:05:03,370 --> 00:05:08,979
GDI it provides support for different

116
00:05:06,310 --> 00:05:12,190
image file formats such as proprietary

117
00:05:08,979 --> 00:05:14,860
windows file formats being enhanced

118
00:05:12,190 --> 00:05:17,530
media file formats or windows metafile

119
00:05:14,860 --> 00:05:19,870
formats and it can also give you the

120
00:05:17,530 --> 00:05:23,799
ability to do different kind of graphic

121
00:05:19,870 --> 00:05:27,069
operations so when you're doing an API

122
00:05:23,800 --> 00:05:29,830
call that gets handled by the kernel

123
00:05:27,069 --> 00:05:33,550
mode win32 KDOT sees and that acts like

124
00:05:29,830 --> 00:05:35,770
a router which will will send the

125
00:05:33,550 --> 00:05:37,330
request originating from the api to they

126
00:05:35,770 --> 00:05:41,020
actually driver that will do the heavy

127
00:05:37,330 --> 00:05:43,330
lifting and as you can see the drivers

128
00:05:41,020 --> 00:05:46,479
are placed in the kernel mode and this

129
00:05:43,330 --> 00:05:49,210
is by design started with starting with

130
00:05:46,479 --> 00:05:50,949
Windows NT Microsoft decided that it's a

131
00:05:49,210 --> 00:05:53,710
good idea to move the kernel drivers

132
00:05:50,949 --> 00:05:56,830
from the GDI drivers from the user space

133
00:05:53,710 --> 00:05:58,299
to kernel space they said that they did

134
00:05:56,830 --> 00:06:00,669
that in order to improve graphical

135
00:05:58,300 --> 00:06:02,830
performance and no security implication

136
00:06:00,669 --> 00:06:03,580
will take will have will happen

137
00:06:02,830 --> 00:06:06,449
whatsoever

138
00:06:03,580 --> 00:06:09,279
it's a funny article you can read it but

139
00:06:06,449 --> 00:06:13,029
there is a security implication because

140
00:06:09,279 --> 00:06:14,229
if a certain graphic operation is is

141
00:06:13,029 --> 00:06:17,050
done in the wrong way in if it's

142
00:06:14,229 --> 00:06:18,849
vulnerable then you this can lead to a

143
00:06:17,050 --> 00:06:21,120
weird case of privilege escalation of

144
00:06:18,849 --> 00:06:21,120
course

145
00:06:25,240 --> 00:06:30,490
let's try with both hands and the

146
00:06:27,850 --> 00:06:33,310
attackers saw an opportunity in this

147
00:06:30,490 --> 00:06:35,020
situation and as a result they started

148
00:06:33,310 --> 00:06:36,580
looking to the GDI and it turns out the

149
00:06:35,020 --> 00:06:39,940
total vulnerabilities in Windows GDI

150
00:06:36,580 --> 00:06:44,020
where is in malware campaigns and if

151
00:06:39,940 --> 00:06:45,370
you're thinking that GDI has been

152
00:06:44,020 --> 00:06:46,750
thoroughly investigated then you are

153
00:06:45,370 --> 00:06:48,840
wrong because only this year more than

154
00:06:46,750 --> 00:06:52,360
30 vulnerabilities were affecting

155
00:06:48,840 --> 00:06:54,669
graphics device interface so how how can

156
00:06:52,360 --> 00:06:56,949
an attacker abuse such kind of abilities

157
00:06:54,669 --> 00:06:59,198
well there are lot of clients obviously

158
00:06:56,949 --> 00:07:02,470
GDI is a very important fundamental

159
00:06:59,199 --> 00:07:06,280
module to Windows for example Microsoft

160
00:07:02,470 --> 00:07:08,530
Office is using it you can insert proper

161
00:07:06,280 --> 00:07:11,500
PI proprietary windows file formats for

162
00:07:08,530 --> 00:07:14,138
example enhanced media files or meta

163
00:07:11,500 --> 00:07:16,120
files and that will get rendered using

164
00:07:14,139 --> 00:07:18,699
this module and so if the mall the

165
00:07:16,120 --> 00:07:21,699
module is vulnerable then this Europe

166
00:07:18,699 --> 00:07:24,009
attack entry point or you can use a

167
00:07:21,699 --> 00:07:26,949
brown browser you can attack by this way

168
00:07:24,009 --> 00:07:28,539
you can insert certain meta file into a

169
00:07:26,949 --> 00:07:30,580
JavaScript and that will get parsed

170
00:07:28,539 --> 00:07:33,280
using the vulnerable module and again

171
00:07:30,580 --> 00:07:38,590
you can it's pretty much game over and

172
00:07:33,280 --> 00:07:42,270
up Adobe Reader is using GDI p-- edge as

173
00:07:38,590 --> 00:07:42,270
well so there is a large attack surface

174
00:07:42,539 --> 00:07:47,860
as I said I started looking into GDI

175
00:07:46,090 --> 00:07:50,349
vulnerabilities and I just picked one of

176
00:07:47,860 --> 00:07:53,349
them at random

177
00:07:50,349 --> 00:07:55,539
again up investigating and looking at

178
00:07:53,349 --> 00:07:57,729
the security report provided by

179
00:07:55,539 --> 00:07:59,860
Microsoft you don't have to main

180
00:07:57,729 --> 00:08:01,840
information I just know that it's a

181
00:07:59,860 --> 00:08:03,880
critical hip overflow vulnerability and

182
00:08:01,840 --> 00:08:07,570
it could lead to remote code execution

183
00:08:03,880 --> 00:08:10,509
in certain scenarios I also know that it

184
00:08:07,570 --> 00:08:13,860
affects GDI plus the DLL and after I'd

185
00:08:10,509 --> 00:08:17,020
done a little bit more investigation I

186
00:08:13,860 --> 00:08:18,880
have stumbled upon on Cydia is read the

187
00:08:17,020 --> 00:08:20,620
initiative report that give me this

188
00:08:18,880 --> 00:08:22,900
another critical piece of information

189
00:08:20,620 --> 00:08:25,270
that the vulnerability is located within

190
00:08:22,900 --> 00:08:28,060
the metal that is named the rotated

191
00:08:25,270 --> 00:08:29,590
stretch PLT this turns out to be a very

192
00:08:28,060 --> 00:08:34,059
useful information in the investigation

193
00:08:29,590 --> 00:08:35,620
to follow of course there is no POC

194
00:08:34,059 --> 00:08:38,189
otherwise this presentation I have too

195
00:08:35,620 --> 00:08:38,190
much sense really

196
00:08:39,490 --> 00:08:43,549
okay

197
00:08:40,669 --> 00:08:45,529
so what can you do well usually you

198
00:08:43,549 --> 00:08:47,269
start with batch dipping petrol dipping

199
00:08:45,529 --> 00:08:50,420
is definitely not a new technique it has

200
00:08:47,269 --> 00:08:53,120
been a while since it was employed for

201
00:08:50,420 --> 00:08:56,870
the first time it basically allows you

202
00:08:53,120 --> 00:09:00,019
to compare two different executables to

203
00:08:56,870 --> 00:09:01,459
the basic block level and they and it

204
00:09:00,019 --> 00:09:04,399
allows you to look at the differences

205
00:09:01,459 --> 00:09:06,410
and understand what has been patched and

206
00:09:04,399 --> 00:09:09,140
how it has been patched so it's a very

207
00:09:06,410 --> 00:09:11,149
useful tool because not only that you

208
00:09:09,140 --> 00:09:13,519
can inspect the patch but if you look at

209
00:09:11,149 --> 00:09:16,810
the target enough time then you can gain

210
00:09:13,519 --> 00:09:20,060
insight about where are the critical

211
00:09:16,810 --> 00:09:23,540
locations within that application where

212
00:09:20,060 --> 00:09:26,959
the problems arise and also how is the

213
00:09:23,540 --> 00:09:30,050
development team targeting and deal with

214
00:09:26,959 --> 00:09:31,819
these kinds of issues so a lot of people

215
00:09:30,050 --> 00:09:35,469
are using bean dip to look in a lot of

216
00:09:31,820 --> 00:09:35,470
application for a larger amount of time

217
00:09:36,670 --> 00:09:40,550
how would you go about page dipping well

218
00:09:39,019 --> 00:09:42,500
there are certain steps and a pretty

219
00:09:40,550 --> 00:09:44,510
straightforward you will take two

220
00:09:42,500 --> 00:09:46,209
consecutive patches when you're talking

221
00:09:44,510 --> 00:09:49,010
about Windows dispatches are really

222
00:09:46,209 --> 00:09:51,500
cabinet files and cabinet cabinet files

223
00:09:49,010 --> 00:09:52,970
all fully fledged the zip archives you

224
00:09:51,500 --> 00:09:56,870
would extract those archives and you

225
00:09:52,970 --> 00:09:59,149
take the file of interest from them then

226
00:09:56,870 --> 00:10:01,250
you import those files in either and let

227
00:09:59,149 --> 00:10:03,680
it in let either on its initial analysis

228
00:10:01,250 --> 00:10:07,190
on both files then you would run the

229
00:10:03,680 --> 00:10:09,349
bhindi plug-in bin diff is a has a

230
00:10:07,190 --> 00:10:11,149
plugin that allows you to integrate it

231
00:10:09,350 --> 00:10:13,459
with Ida and will do exactly that will

232
00:10:11,149 --> 00:10:23,029
compare though those bot files at the

233
00:10:13,459 --> 00:10:25,670
basic block level and you will start it

234
00:10:23,029 --> 00:10:27,829
stopped work one second and you would

235
00:10:25,670 --> 00:10:29,209
respect the differences so this is

236
00:10:27,829 --> 00:10:31,370
exactly what I have done I have taken

237
00:10:29,209 --> 00:10:34,279
two files what you want to do any of the

238
00:10:31,370 --> 00:10:36,140
patch dipping try to find two files that

239
00:10:34,279 --> 00:10:38,060
are very close as a version one to each

240
00:10:36,140 --> 00:10:39,199
other because you want obviously to

241
00:10:38,060 --> 00:10:44,359
limit the amount of code that you want

242
00:10:39,199 --> 00:10:45,979
to look into import them in Ida Ida will

243
00:10:44,360 --> 00:10:47,540
run analysis then you start up in this

244
00:10:45,980 --> 00:10:50,639
plugin and load behold this is the

245
00:10:47,540 --> 00:10:53,110
output of the actual bean dip

246
00:10:50,639 --> 00:10:54,999
so the important columns that you want

247
00:10:53,110 --> 00:10:57,279
to look at is the similarity column

248
00:10:54,999 --> 00:10:59,589
confidence and primary and secondary

249
00:10:57,279 --> 00:11:02,110
name primary and secondary name will

250
00:10:59,589 --> 00:11:04,810
give you the names of the functions that

251
00:11:02,110 --> 00:11:08,019
have certain differences in them and as

252
00:11:04,810 --> 00:11:10,059
we can see our method is located there

253
00:11:08,019 --> 00:11:12,309
the Dorota it is straight to BLT which

254
00:11:10,059 --> 00:11:14,230
is a good sign because it means that we

255
00:11:12,309 --> 00:11:16,660
have the right files and we comparing

256
00:11:14,230 --> 00:11:21,899
what we have what what it has to be

257
00:11:16,660 --> 00:11:26,579
compared ok so we are seeing that it's a

258
00:11:21,899 --> 00:11:29,220
pretty big difference like 99 6% and

259
00:11:26,579 --> 00:11:32,998
let's start investigating what the

260
00:11:29,220 --> 00:11:36,129
actual issues are

261
00:11:32,999 --> 00:11:38,339
ok so VIN diff also has this interesting

262
00:11:36,129 --> 00:11:40,990
functionality that it allows you to see

263
00:11:38,339 --> 00:11:42,819
both methods the vulnerable and the page

264
00:11:40,990 --> 00:11:46,569
one side by side at the basic block

265
00:11:42,819 --> 00:11:49,540
level and you can get on a hunch where

266
00:11:46,569 --> 00:11:52,689
the actual vulnerable code reaction sees

267
00:11:49,540 --> 00:11:54,939
in the code R so let us zoom into that

268
00:11:52,689 --> 00:11:56,589
part where there seems to be some

269
00:11:54,939 --> 00:12:07,629
differences and find out what happens

270
00:11:56,589 --> 00:12:10,089
there ok so this is our the the

271
00:12:07,629 --> 00:12:12,220
functions the patched one with green and

272
00:12:10,089 --> 00:12:17,980
the vulnerable the vulnerable method in

273
00:12:12,220 --> 00:12:24,430
the unpatched dll with red what do you

274
00:12:17,980 --> 00:12:27,430
think that the issue is so my first

275
00:12:24,430 --> 00:12:32,790
hunch is that there is a classic case of

276
00:12:27,430 --> 00:12:35,859
memory corruption because of the because

277
00:12:32,790 --> 00:12:39,000
because of the unsafe copy of mem copy

278
00:12:35,860 --> 00:12:42,429
operation so what can we do with this

279
00:12:39,000 --> 00:12:45,009
well if you somehow can gain control of

280
00:12:42,429 --> 00:12:46,870
the source buffer and the size that will

281
00:12:45,009 --> 00:12:49,360
get that will get copied into the

282
00:12:46,870 --> 00:12:51,819
destination buffer then we will produce

283
00:12:49,360 --> 00:12:54,129
an overflow to the to the destination

284
00:12:51,819 --> 00:12:56,589
buffer that will hopefully overwrite

285
00:12:54,129 --> 00:12:58,809
some structures in the memory such as

286
00:12:56,589 --> 00:13:02,319
structured exception handling on Windows

287
00:12:58,809 --> 00:13:03,550
or some other code pointers and by

288
00:13:02,319 --> 00:13:07,000
overwriting that weak

289
00:13:03,550 --> 00:13:09,310
and we can obtain the control of the IP

290
00:13:07,000 --> 00:13:11,560
the instruction pointer and hijack the

291
00:13:09,310 --> 00:13:13,689
control flow of the application let's

292
00:13:11,560 --> 00:13:22,540
see if that is indeed the issue by

293
00:13:13,690 --> 00:13:24,640
looking at the patch code okay this is

294
00:13:22,540 --> 00:13:26,589
the patch code so they indeed added a

295
00:13:24,640 --> 00:13:28,930
form of sanitization before the mem copy

296
00:13:26,589 --> 00:13:31,180
operation they are looking at the size

297
00:13:28,930 --> 00:13:33,459
and if that is bigger than a certain

298
00:13:31,180 --> 00:13:35,620
amount then the destination buffer is

299
00:13:33,459 --> 00:13:37,268
going to be allocated with that exact

300
00:13:35,620 --> 00:13:39,640
size so now the source buffer and the

301
00:13:37,269 --> 00:13:44,920
destination buffer is are of the same

302
00:13:39,640 --> 00:13:48,100
size so this seems okay to me at the

303
00:13:44,920 --> 00:13:51,519
first look but what happens if we make

304
00:13:48,100 --> 00:13:54,459
an allocation with we'd make a big

305
00:13:51,519 --> 00:13:56,140
allocation I mean maybe the size and

306
00:13:54,459 --> 00:13:58,779
this nation buffer at the source buffer

307
00:13:56,140 --> 00:14:01,360
are still in our control right maybe we

308
00:13:58,779 --> 00:14:03,490
can somehow bypass dispatch and make a

309
00:14:01,360 --> 00:14:05,829
great allocation and create a denial of

310
00:14:03,490 --> 00:14:08,320
service condition because we do not have

311
00:14:05,829 --> 00:14:11,109
an upper limit how much can how much can

312
00:14:08,320 --> 00:14:18,820
we allocate it really is this a blunder

313
00:14:11,110 --> 00:14:20,649
from the Microsoft team well it kind of

314
00:14:18,820 --> 00:14:24,130
it turns out that it isn't a blunder

315
00:14:20,649 --> 00:14:26,800
they've they've included a method in the

316
00:14:24,130 --> 00:14:30,670
patched dll which is called sanitizing

317
00:14:26,800 --> 00:14:32,920
and expand buffers and thus the method

318
00:14:30,670 --> 00:14:35,140
does exactly that it kind of takes care

319
00:14:32,920 --> 00:14:36,910
of the allocation and make sure that

320
00:14:35,140 --> 00:14:39,730
there are made within certain boundaries

321
00:14:36,910 --> 00:14:42,730
so we cannot really bypass the deep edge

322
00:14:39,730 --> 00:14:45,550
and everything seems okay so far but at

323
00:14:42,730 --> 00:14:46,930
least we know what the issue is so what

324
00:14:45,550 --> 00:14:49,270
can we do now what can we do with this

325
00:14:46,930 --> 00:14:52,630
piece of information we know that there

326
00:14:49,270 --> 00:14:54,640
is it can lead to remote code execution

327
00:14:52,630 --> 00:14:56,649
and we see that we can gain somehow

328
00:14:54,640 --> 00:14:59,470
control what we need to find a way to

329
00:14:56,649 --> 00:15:01,000
reach that certain piece of code and ID

330
00:14:59,470 --> 00:15:03,130
up of offers you this interesting

331
00:15:01,000 --> 00:15:05,230
functionality which is called X

332
00:15:03,130 --> 00:15:08,050
references - and this practically allows

333
00:15:05,230 --> 00:15:09,850
you to to see all the methods that will

334
00:15:08,050 --> 00:15:11,740
eventually call the method of interest

335
00:15:09,850 --> 00:15:14,199
so at the base we have our vulnerable

336
00:15:11,740 --> 00:15:16,540
method and what are in the top of the

337
00:15:14,199 --> 00:15:17,550
tree are the method that we are maybe

338
00:15:16,540 --> 00:15:22,730
interesting to

339
00:15:17,550 --> 00:15:25,709
to to to invoke in a certain way so

340
00:15:22,730 --> 00:15:26,970
after I have investigated each method it

341
00:15:25,709 --> 00:15:29,040
turns out that they are not external

342
00:15:26,970 --> 00:15:30,690
methods so there is not a direct API

343
00:15:29,040 --> 00:15:33,599
that we can invoke that will lead to one

344
00:15:30,690 --> 00:15:35,010
of those so we kind of have to continue

345
00:15:33,600 --> 00:15:40,290
with our investigation in go further

346
00:15:35,010 --> 00:15:43,410
with the reverse with the reversing so

347
00:15:40,290 --> 00:15:45,510
I've noticed that all these methods have

348
00:15:43,410 --> 00:15:47,850
a certain name this seems they they seem

349
00:15:45,510 --> 00:15:49,500
to be handlers for something so I've

350
00:15:47,850 --> 00:15:56,100
started wandering the Honda their

351
00:15:49,500 --> 00:15:58,380
handlers for what exactly it turns out

352
00:15:56,100 --> 00:16:00,390
that they are handlers for specific

353
00:15:58,380 --> 00:16:02,910
Windows proprietary file format which is

354
00:16:00,390 --> 00:16:06,180
called EMF enhanced media file so

355
00:16:02,910 --> 00:16:08,399
enhanced media file is nothing really

356
00:16:06,180 --> 00:16:10,829
than a representation of a graphical

357
00:16:08,399 --> 00:16:14,279
image and how this representation takes

358
00:16:10,829 --> 00:16:16,439
place well let's say that we want to

359
00:16:14,279 --> 00:16:19,290
draw a rectangle that is filled with the

360
00:16:16,440 --> 00:16:21,149
green color and it's rotated like 45

361
00:16:19,290 --> 00:16:23,279
degrees to the left or to the right if

362
00:16:21,149 --> 00:16:25,790
you want to represent that in an EMF

363
00:16:23,279 --> 00:16:28,350
file then we'll have a record for the

364
00:16:25,790 --> 00:16:31,110
rectangle for the polyline then we'll

365
00:16:28,350 --> 00:16:33,570
have a record that specifies the green

366
00:16:31,110 --> 00:16:35,790
color and then we'll have a record that

367
00:16:33,570 --> 00:16:37,680
specifies the rotation operation so we

368
00:16:35,790 --> 00:16:39,810
have three records chained together and

369
00:16:37,680 --> 00:16:44,010
that everything that there is to eat in

370
00:16:39,810 --> 00:16:46,829
hence media file format so it it seems

371
00:16:44,010 --> 00:16:48,390
that there are records that have to be

372
00:16:46,829 --> 00:16:50,569
handled somehow and I've started

373
00:16:48,390 --> 00:16:54,420
thinking that this handlers have to be

374
00:16:50,570 --> 00:16:56,250
in there in the in the DLL so I've tried

375
00:16:54,420 --> 00:16:57,750
to see if there are groups on how when

376
00:16:56,250 --> 00:17:00,500
it turns out that all the handlers that

377
00:16:57,750 --> 00:17:03,839
we see earlier in that Cole tree are

378
00:17:00,500 --> 00:17:06,980
practically indexes in an array and the

379
00:17:03,839 --> 00:17:06,980
array is called

380
00:17:16,280 --> 00:17:35,190
okay do you have another one and the

381
00:17:31,410 --> 00:17:37,100
array is called the drawing orders and

382
00:17:35,190 --> 00:17:39,630
[Music]

383
00:17:37,100 --> 00:17:43,980
right now we have to somehow trigger

384
00:17:39,630 --> 00:17:47,039
this this this handlers so we continue

385
00:17:43,980 --> 00:17:49,760
with our investigation how we can how

386
00:17:47,039 --> 00:18:01,169
can we trigger a driving order operation

387
00:17:49,760 --> 00:18:03,179
again we inspect the DLL okay if we

388
00:18:01,169 --> 00:18:05,669
inspect the DLL we can see that a

389
00:18:03,179 --> 00:18:09,179
drawing of order operation is going to

390
00:18:05,669 --> 00:18:15,530
happen if this method is called beepers

391
00:18:09,179 --> 00:18:15,530
win32 metafile still not working

392
00:18:42,980 --> 00:18:47,600
it's not working maybe if I go this way

393
00:18:48,860 --> 00:18:57,959
okay seems to be better okay so this is

394
00:18:55,679 --> 00:19:00,870
the method that eventually call the

395
00:18:57,960 --> 00:19:03,390
drawing order array in this method be

396
00:19:00,870 --> 00:19:04,678
parsed in 32 meta file we have a

397
00:19:03,390 --> 00:19:08,400
reference to that array that contains

398
00:19:04,679 --> 00:19:10,350
the whole drawing operations so now what

399
00:19:08,400 --> 00:19:13,800
we have to do is to find a way to call

400
00:19:10,350 --> 00:19:15,780
this method again we make use of the X

401
00:19:13,800 --> 00:19:24,090
reference X references to either

402
00:19:15,780 --> 00:19:26,490
functionality so at the bases be percent

403
00:19:24,090 --> 00:19:29,609
thirty-two meta file and it seems that

404
00:19:26,490 --> 00:19:29,609
[Music]

405
00:19:30,050 --> 00:19:37,559
this method EMF to vmf bits will

406
00:19:34,650 --> 00:19:39,360
eventually call that method and after I

407
00:19:37,559 --> 00:19:43,410
have taken a look at this method it

408
00:19:39,360 --> 00:19:46,830
turns out that is an external one so we

409
00:19:43,410 --> 00:19:49,940
kind of have our target but let's make a

410
00:19:46,830 --> 00:19:53,309
summary of what we have learned so far

411
00:19:49,940 --> 00:19:55,230
so the B parts win32 meta file will call

412
00:19:53,309 --> 00:19:57,889
all vulnerable method wrote it is three

413
00:19:55,230 --> 00:20:00,330
to BLT but this will only happen if we

414
00:19:57,890 --> 00:20:03,330
include in the file that we are serve as

415
00:20:00,330 --> 00:20:12,899
an input a specific record straight to

416
00:20:03,330 --> 00:20:18,449
BLT record okay and this is not working

417
00:20:12,900 --> 00:20:20,250
so I need to find a way to call this

418
00:20:18,450 --> 00:20:23,940
method and I know that its external so

419
00:20:20,250 --> 00:20:26,640
now what do I do I take a look at the

420
00:20:23,940 --> 00:20:29,220
Microsoft documentation and it turns out

421
00:20:26,640 --> 00:20:32,250
that this method be parsed win32 meta

422
00:20:29,220 --> 00:20:36,450
file is actually a part of the meta file

423
00:20:32,250 --> 00:20:38,460
class so I do have a way to call make an

424
00:20:36,450 --> 00:20:40,290
API call and hopefully that will reach

425
00:20:38,460 --> 00:20:47,100
the vulnerable code that is of interests

426
00:20:40,290 --> 00:20:50,330
for us so let's try to do that if this

427
00:20:47,100 --> 00:20:50,330
thing with let me

428
00:20:51,200 --> 00:20:59,790
okay so what is our hope here we are

429
00:20:56,880 --> 00:21:02,400
trying to make that call the API call

430
00:20:59,790 --> 00:21:06,600
DMF to the MF it's to call our noble

431
00:21:02,400 --> 00:21:07,860
method and produce a crash and I've

432
00:21:06,600 --> 00:21:10,379
started thinking how was this

433
00:21:07,860 --> 00:21:12,120
vulnerability discovered well as you as

434
00:21:10,380 --> 00:21:14,490
you could see earlier there were a lot

435
00:21:12,120 --> 00:21:16,260
of methods that we that did internal

436
00:21:14,490 --> 00:21:20,790
call other methods and they had a lot of

437
00:21:16,260 --> 00:21:22,309
arguments and this pretty much seems

438
00:21:20,790 --> 00:21:25,409
[Music]

439
00:21:22,309 --> 00:21:28,740
it's it's a good indication that the

440
00:21:25,410 --> 00:21:30,900
vulnerability was found with fuzzing so

441
00:21:28,740 --> 00:21:32,309
what I've tried to do is I've tried to

442
00:21:30,900 --> 00:21:35,549
kind of reverse fuzzing this

443
00:21:32,309 --> 00:21:37,799
vulnerability and try to come up with a

444
00:21:35,549 --> 00:21:38,360
crash for it let's see how that god how

445
00:21:37,799 --> 00:21:43,020
that went

446
00:21:38,360 --> 00:21:47,520
so fighting is about coming with

447
00:21:43,020 --> 00:21:49,080
interesting inputs and with and we are

448
00:21:47,520 --> 00:21:52,740
hoping that interesting interesting

449
00:21:49,080 --> 00:21:55,320
inputs will lead to with to a crash and

450
00:21:52,740 --> 00:21:58,470
to a situation that the developer didn't

451
00:21:55,320 --> 00:22:02,280
handled correctly and it's useful both

452
00:21:58,470 --> 00:22:07,080
for the security researcher and both for

453
00:22:02,280 --> 00:22:10,200
the developer there are multiple ways to

454
00:22:07,080 --> 00:22:12,449
classify and classify fuzzing strategies

455
00:22:10,200 --> 00:22:14,820
but the one that I like the most is

456
00:22:12,450 --> 00:22:18,950
evolutionary based fuzzing versus

457
00:22:14,820 --> 00:22:18,950
generational generational based fuzzing

458
00:22:19,130 --> 00:22:25,980
evolutionary based fuzzing is about

459
00:22:21,380 --> 00:22:29,940
using genetic algorithms using genetic

460
00:22:25,980 --> 00:22:33,570
algorithms in order to create a better

461
00:22:29,940 --> 00:22:35,580
code coverage so you're hoping that the

462
00:22:33,570 --> 00:22:37,620
genetic algorithm will use mutation

463
00:22:35,580 --> 00:22:39,270
strategies and those mutation strategies

464
00:22:37,620 --> 00:22:41,370
will this will lead to a better coverage

465
00:22:39,270 --> 00:22:43,799
on the other side we have the

466
00:22:41,370 --> 00:22:45,870
generational based fuzzing and this is

467
00:22:43,799 --> 00:22:49,049
about coming with a grammar for that

468
00:22:45,870 --> 00:22:51,649
specific input that will give the father

469
00:22:49,049 --> 00:22:53,910
some kind of input awareness and

470
00:22:51,650 --> 00:22:55,110
hopefully that will reach further into

471
00:22:53,910 --> 00:23:00,300
the code it will find more interesting

472
00:22:55,110 --> 00:23:02,729
behavior from my investigation I've used

473
00:23:00,300 --> 00:23:05,520
the win AFL father

474
00:23:02,730 --> 00:23:08,850
which is a tool built by Google project

475
00:23:05,520 --> 00:23:11,160
zero it is actually for of work from the

476
00:23:08,850 --> 00:23:13,280
original tool created by Michaels that

477
00:23:11,160 --> 00:23:18,200
have ski a Google security researcher

478
00:23:13,280 --> 00:23:21,120
AFL so as you've heard earlier in

479
00:23:18,200 --> 00:23:22,470
alexandra duchenko's presentation is the

480
00:23:21,120 --> 00:23:24,330
tool to go and are trying to find

481
00:23:22,470 --> 00:23:33,140
vulnerabilities and it has a huge huge

482
00:23:24,330 --> 00:23:36,120
trophy case ok now i will give some tips

483
00:23:33,140 --> 00:23:37,830
for using FL in case you'll want to

484
00:23:36,120 --> 00:23:40,320
start tampering with it

485
00:23:37,830 --> 00:23:43,760
first first tip is to understand the

486
00:23:40,320 --> 00:23:46,980
target really take a lot of time and

487
00:23:43,760 --> 00:23:48,930
look at the ways that you can use that

488
00:23:46,980 --> 00:23:50,310
API for example if you're facing an API

489
00:23:48,930 --> 00:23:52,920
you look at the source code look at the

490
00:23:50,310 --> 00:23:54,659
examples some of the application also

491
00:23:52,920 --> 00:23:57,420
provides a test for it and that is a

492
00:23:54,660 --> 00:23:59,490
good place to look at when you're trying

493
00:23:57,420 --> 00:24:01,800
to understand what you can false and try

494
00:23:59,490 --> 00:24:05,190
to concentrate your efforts at first

495
00:24:01,800 --> 00:24:08,220
that conversion operation at

496
00:24:05,190 --> 00:24:10,980
initialization and so on another tip

497
00:24:08,220 --> 00:24:12,600
would be to come up with small samples

498
00:24:10,980 --> 00:24:14,640
that you would fit the file further at

499
00:24:12,600 --> 00:24:16,500
the beginning because you want to

500
00:24:14,640 --> 00:24:18,690
your father to be as fast as possible

501
00:24:16,500 --> 00:24:21,120
and if your initial test case is big

502
00:24:18,690 --> 00:24:24,270
then the processing will take a larger

503
00:24:21,120 --> 00:24:26,550
amount of time and that will slow your

504
00:24:24,270 --> 00:24:28,200
father and you don't want that but also

505
00:24:26,550 --> 00:24:30,690
you want a lot of samples that will

506
00:24:28,200 --> 00:24:32,220
create a larger coverage initially to

507
00:24:30,690 --> 00:24:38,820
make sure that you have a lot of places

508
00:24:32,220 --> 00:24:40,560
to start looking at another thing that

509
00:24:38,820 --> 00:24:43,200
you can do is to run the father from the

510
00:24:40,560 --> 00:24:45,510
RAM disk that will allow the father to

511
00:24:43,200 --> 00:24:47,850
read the samples directly from RAM and

512
00:24:45,510 --> 00:24:49,560
we will deny the overhead produced by

513
00:24:47,850 --> 00:24:51,540
reading them from the AK from the disk

514
00:24:49,560 --> 00:24:53,929
and you can also make use of the

515
00:24:51,540 --> 00:24:56,760
master/slave feature that AFL provides

516
00:24:53,930 --> 00:24:59,310
if you start multiple instances of

517
00:24:56,760 --> 00:25:02,220
fuzzing in parallel then the slaves can

518
00:24:59,310 --> 00:25:03,750
communicate with the master and they can

519
00:25:02,220 --> 00:25:06,300
communicate and exchange fuzzing

520
00:25:03,750 --> 00:25:10,010
strategies and that will create a better

521
00:25:06,300 --> 00:25:10,010
coverage in a faster amount of time

522
00:25:12,750 --> 00:25:18,720
use a dictionary a dictionary is a way

523
00:25:16,140 --> 00:25:20,700
that you can instruct the father to use

524
00:25:18,720 --> 00:25:22,950
certain strings to insert when there

525
00:25:20,700 --> 00:25:26,400
when the father is trying to use

526
00:25:22,950 --> 00:25:29,220
mutation strategies and even better an

527
00:25:26,400 --> 00:25:32,299
even better strategy would be to use FL

528
00:25:29,220 --> 00:25:36,059
smart with a law which allows you to

529
00:25:32,299 --> 00:25:37,710
specify a grammar and this will

530
00:25:36,059 --> 00:25:42,270
hopefully provide a better coverage in a

531
00:25:37,710 --> 00:25:43,559
faster amount of time another thing to

532
00:25:42,270 --> 00:25:45,600
look at is you have to watch the

533
00:25:43,559 --> 00:25:48,090
coverage so the coverage is an

534
00:25:45,600 --> 00:25:51,689
asymptotic curve at a certain point the

535
00:25:48,090 --> 00:25:54,299
coverage will not become as big as fast

536
00:25:51,690 --> 00:25:56,309
so when the coverage starts to slow down

537
00:25:54,299 --> 00:25:57,809
you won't get a certain amount of

538
00:25:56,309 --> 00:25:59,820
increase in a small amount of time you'd

539
00:25:57,809 --> 00:26:02,100
want to stop the father and come up with

540
00:25:59,820 --> 00:26:09,030
new samples and new on your new phasing

541
00:26:02,100 --> 00:26:12,959
strategies okay so let's set up the

542
00:26:09,030 --> 00:26:14,460
fuzzing campaign we have to write a

543
00:26:12,960 --> 00:26:15,960
harness which is essentially a piece of

544
00:26:14,460 --> 00:26:18,809
code that makes the call to the actual

545
00:26:15,960 --> 00:26:21,480
API that we saw earlier through our

546
00:26:18,809 --> 00:26:24,658
reverse engineering phase then we have

547
00:26:21,480 --> 00:26:26,039
to provide instrumentation in order for

548
00:26:24,659 --> 00:26:27,570
father to know what the coverage is

549
00:26:26,039 --> 00:26:29,850
there are multiple ways that you can

550
00:26:27,570 --> 00:26:32,100
make or you can employ instrumentation

551
00:26:29,850 --> 00:26:34,559
in Windows but the one that I have used

552
00:26:32,100 --> 00:26:36,178
and I'm familiar with is dynamo i/o then

553
00:26:34,559 --> 00:26:38,490
Amaro is the runtime instrumentation

554
00:26:36,179 --> 00:26:41,490
framework and what this will do it will

555
00:26:38,490 --> 00:26:43,530
insert certain op codes into at runtime

556
00:26:41,490 --> 00:26:46,140
into the binary that is running and that

557
00:26:43,530 --> 00:26:49,320
will inform the father about the code

558
00:26:46,140 --> 00:26:50,789
coverage in that situation and if that

559
00:26:49,320 --> 00:26:52,350
specific sample that you give it at

560
00:26:50,789 --> 00:26:54,570
input will provide a better coverage

561
00:26:52,350 --> 00:26:56,428
then FL father we know that that is the

562
00:26:54,570 --> 00:27:00,330
right mutation strategy and we will

563
00:26:56,429 --> 00:27:03,030
enforce that further on I also have to

564
00:27:00,330 --> 00:27:06,570
come up with test cases so we have to

565
00:27:03,030 --> 00:27:08,610
come up with initial EMF files that that

566
00:27:06,570 --> 00:27:14,129
the father will use and we'll start

567
00:27:08,610 --> 00:27:16,020
investigating we also have to set up the

568
00:27:14,130 --> 00:27:20,280
father and start fighting let's see how

569
00:27:16,020 --> 00:27:23,190
that goes so this is the harness at the

570
00:27:20,280 --> 00:27:24,960
beginning we have to open from the

571
00:27:23,190 --> 00:27:26,640
command line the file and after that

572
00:27:24,960 --> 00:27:28,800
we'll make the API

573
00:27:26,640 --> 00:27:35,220
that we discovered earlier fun in the

574
00:27:28,800 --> 00:27:37,050
Windows documentation after that we have

575
00:27:35,220 --> 00:27:38,640
to generate the initial samples and

576
00:27:37,050 --> 00:27:41,730
again we can make use of the GDI

577
00:27:38,640 --> 00:27:44,130
application programming interface as we

578
00:27:41,730 --> 00:27:45,840
as we saw earlier our vulnerable method

579
00:27:44,130 --> 00:27:49,200
has a chance to be called only if we

580
00:27:45,840 --> 00:27:53,040
provide a certain record type and we

581
00:27:49,200 --> 00:28:00,360
will create our files in such a manner

582
00:27:53,040 --> 00:28:01,590
that will include such a record another

583
00:28:00,360 --> 00:28:05,790
thing that you want to do when you're

584
00:28:01,590 --> 00:28:08,520
doing fuzzing is tween to try to limit

585
00:28:05,790 --> 00:28:10,710
the number of samples that you're

586
00:28:08,520 --> 00:28:12,780
feeding the feeding the father if you're

587
00:28:10,710 --> 00:28:15,330
not doing that and if the samples are

588
00:28:12,780 --> 00:28:19,200
pretty similar then your father will

589
00:28:15,330 --> 00:28:21,330
waste useful CPU cycles on samples that

590
00:28:19,200 --> 00:28:23,430
are not contributing to the code

591
00:28:21,330 --> 00:28:25,500
coverage very much and there is a tool

592
00:28:23,430 --> 00:28:27,840
that allows you to do exactly that it

593
00:28:25,500 --> 00:28:29,430
will take each sample and you would look

594
00:28:27,840 --> 00:28:31,740
at the code coverage that it produces

595
00:28:29,430 --> 00:28:33,210
and if the code coverage is similar for

596
00:28:31,740 --> 00:28:34,710
two consecutive samples it will

597
00:28:33,210 --> 00:28:39,510
eliminate the dose from the initial

598
00:28:34,710 --> 00:28:42,360
corpus so from initial 32 test cases

599
00:28:39,510 --> 00:28:52,770
that they come up with using this tool I

600
00:28:42,360 --> 00:28:55,439
have only 15 samples left ok softer I've

601
00:28:52,770 --> 00:28:57,780
started the father I have waited a day

602
00:28:55,440 --> 00:29:01,170
and a few more hours and it seems that

603
00:28:57,780 --> 00:29:03,450
my father is behaving pretty nice I have

604
00:29:01,170 --> 00:29:06,870
already have more DNA tech crashes and

605
00:29:03,450 --> 00:29:08,610
the speed is pretty good so I'm happy

606
00:29:06,870 --> 00:29:12,689
about those crashes and I want to

607
00:29:08,610 --> 00:29:13,800
investigate them and after another I

608
00:29:12,690 --> 00:29:15,630
have seen that the coverage isn't

609
00:29:13,800 --> 00:29:19,950
increasing very much I have decided to

610
00:29:15,630 --> 00:29:22,590
stop it and investigate the crashes the

611
00:29:19,950 --> 00:29:24,780
father behaved so well that my antivirus

612
00:29:22,590 --> 00:29:27,300
antivirus thought that the generated

613
00:29:24,780 --> 00:29:30,720
crashes are more aware when I've started

614
00:29:27,300 --> 00:29:33,810
the trying them the antivirus started

615
00:29:30,720 --> 00:29:35,910
complaining and it give it gave these

616
00:29:33,810 --> 00:29:37,649
pop-ups that I've infected with

617
00:29:35,910 --> 00:29:40,170
bloodhound so this would be an

618
00:29:37,650 --> 00:29:42,210
interesting research how

619
00:29:40,170 --> 00:29:49,200
to foil Windows signature using genetic

620
00:29:42,210 --> 00:29:51,960
algorithms after going through the

621
00:29:49,200 --> 00:29:54,510
crashes one of them grasped my attention

622
00:29:51,960 --> 00:29:56,310
it turns out that it is in the exact

623
00:29:54,510 --> 00:29:58,650
same method that I was trying to

624
00:29:56,310 --> 00:30:03,389
investigate so this might be a possible

625
00:29:58,650 --> 00:30:06,330
valid finding so I took this sample that

626
00:30:03,390 --> 00:30:09,000
the the fuzzing campaign produced it and

627
00:30:06,330 --> 00:30:14,879
I started looking into it we using the

628
00:30:09,000 --> 00:30:17,550
debugger so as you can see the call

629
00:30:14,880 --> 00:30:20,160
stack is pretty big no way a security

630
00:30:17,550 --> 00:30:23,760
researcher could go to such a large

631
00:30:20,160 --> 00:30:26,010
amount of code in a small amount of time

632
00:30:23,760 --> 00:30:26,960
and come up with this just by code

633
00:30:26,010 --> 00:30:30,840
analysis

634
00:30:26,960 --> 00:30:35,250
so probably the vulnerability was found

635
00:30:30,840 --> 00:30:37,679
using fuzzing another thing that you can

636
00:30:35,250 --> 00:30:40,640
observe is that the crash produces in

637
00:30:37,680 --> 00:30:43,050
the exact same place as we seen in the

638
00:30:40,640 --> 00:30:44,940
disassembly and after the mem copy

639
00:30:43,050 --> 00:30:51,629
operation right so this is a valid

640
00:30:44,940 --> 00:30:53,130
finding there is this plugin for the

641
00:30:51,630 --> 00:30:55,470
windows debugger which is called

642
00:30:53,130 --> 00:30:59,100
exploitable this essentially looks at

643
00:30:55,470 --> 00:31:01,020
the at the memory state after the crash

644
00:30:59,100 --> 00:31:03,120
produces and using certain have read

645
00:31:01,020 --> 00:31:05,160
every sticks it declares whether if the

646
00:31:03,120 --> 00:31:08,760
vulnerability is exploited or not you

647
00:31:05,160 --> 00:31:13,770
can use this plug-in to make your to

648
00:31:08,760 --> 00:31:15,870
make a better triage of the crashes when

649
00:31:13,770 --> 00:31:17,970
I've started my fuzzing campaign I've

650
00:31:15,870 --> 00:31:19,679
decided not to look only for the

651
00:31:17,970 --> 00:31:21,300
specific vulnerability so I have tried

652
00:31:19,680 --> 00:31:24,840
to come up with an initial test case

653
00:31:21,300 --> 00:31:28,590
that would produce as better coverage as

654
00:31:24,840 --> 00:31:30,270
possible so like I used different EMF

655
00:31:28,590 --> 00:31:33,209
files with different type of records and

656
00:31:30,270 --> 00:31:34,530
look into the crashes I've observed that

657
00:31:33,210 --> 00:31:37,380
there are crashes that were produced in

658
00:31:34,530 --> 00:31:42,960
different libraries and for different

659
00:31:37,380 --> 00:31:45,210
methods and it turns out that some of

660
00:31:42,960 --> 00:31:47,250
the methods work of some of the crashes

661
00:31:45,210 --> 00:31:49,500
were correlated with other CBS as well

662
00:31:47,250 --> 00:31:51,060
with other crashes and there were five

663
00:31:49,500 --> 00:31:52,980
more crashes that I couldn't correlate

664
00:31:51,060 --> 00:31:53,820
with anything else so I've decided to

665
00:31:52,980 --> 00:31:56,880
send those crash

666
00:31:53,820 --> 00:32:00,450
to Microsoft and they assigned to a null

667
00:31:56,880 --> 00:32:03,290
pointer dereference this box for for

668
00:32:00,450 --> 00:32:06,450
those findings two of them were valid

669
00:32:03,290 --> 00:32:08,610
I've also put the harness function that

670
00:32:06,450 --> 00:32:11,520
I've used for phasing online we can find

671
00:32:08,610 --> 00:32:13,439
it out find it on my repository online

672
00:32:11,520 --> 00:32:15,570
and you can go ahead and try some

673
00:32:13,440 --> 00:32:17,310
phasing on your own for more details you

674
00:32:15,570 --> 00:32:19,110
can contact me on Twitter this was not

675
00:32:17,310 --> 00:32:21,379
my presentation and thank you for your

676
00:32:19,110 --> 00:32:21,379
attention

677
00:32:21,420 --> 00:32:30,650
[Applause]

678
00:32:26,840 --> 00:32:30,649
any questions from the audience

679
00:32:36,020 --> 00:32:40,500
- what targets do you have in mind what

680
00:32:39,060 --> 00:32:43,639
do you want to achieve more specifically

681
00:32:40,500 --> 00:32:47,280
oh I have a lot of targets believe me

682
00:32:43,640 --> 00:32:50,640
trying to follow the JavaScript engine

683
00:32:47,280 --> 00:32:52,170
of edge of Firefox I'm working with my

684
00:32:50,640 --> 00:32:54,390
colleague Danielle and we're trying to

685
00:32:52,170 --> 00:33:00,020
come up with a father now we have a lot

686
00:32:54,390 --> 00:33:00,020
of projects in mind any other questions

687
00:33:05,630 --> 00:33:24,440
hello congratulation for the speech and

688
00:33:22,370 --> 00:33:36,428
I want to get better at investigating

689
00:33:24,440 --> 00:33:39,650
those the second you mean my research

690
00:33:36,429 --> 00:33:41,900
yes we can take this off the scene and

691
00:33:39,650 --> 00:33:43,370
discuss I have a lot of resources to

692
00:33:41,900 --> 00:33:46,100
share if anyone is interested please

693
00:33:43,370 --> 00:33:49,370
reach to me I actually had a hard time

694
00:33:46,100 --> 00:33:52,549
putting together all the resources out

695
00:33:49,370 --> 00:33:54,939
there on fuzzing and try to come better

696
00:33:52,549 --> 00:33:57,590
at this on my own so if you anyone knows

697
00:33:54,940 --> 00:33:59,419
more about it please reach to me and we

698
00:33:57,590 --> 00:34:00,649
can discuss it further thank you very

699
00:33:59,419 --> 00:34:10,010
much thank you

700
00:34:00,650 --> 00:34:13,310
any other questions over there I thank

701
00:34:10,010 --> 00:34:18,429
you for your presentation gi+ library is

702
00:34:13,310 --> 00:34:22,190
used only in office it's used in general

703
00:34:18,429 --> 00:34:24,500
well you know GDI clients can use both

704
00:34:22,190 --> 00:34:26,570
win gd-r gd-r pass interchangeably there

705
00:34:24,500 --> 00:34:29,719
are no rule for that you can use any of

706
00:34:26,570 --> 00:34:32,359
the exported functions but from my

707
00:34:29,719 --> 00:34:35,810
knowledge Microsoft Office employees

708
00:34:32,359 --> 00:34:37,819
most of the generally only GDI + methods

709
00:34:35,810 --> 00:34:42,500
because they are optimized for a better

710
00:34:37,820 --> 00:34:49,639
render speed rendering speed thank you

711
00:34:42,500 --> 00:34:51,050
any other questions hi I don't have a

712
00:34:49,639 --> 00:34:53,389
simpler question did you start

713
00:34:51,050 --> 00:34:55,609
exploiting these crushes oh I'm not that

714
00:34:53,389 --> 00:34:59,470
good yet actually I'm the level of

715
00:34:55,609 --> 00:35:01,580
exploiting structured exception handling

716
00:34:59,470 --> 00:35:06,368
structure I mean that those kind of

717
00:35:01,580 --> 00:35:06,369
overflows so I am at the beginning okay

718
00:35:09,580 --> 00:35:12,759
all right

719
00:35:16,220 --> 00:35:23,230
do you know if you can use fuzzing for

720
00:35:19,910 --> 00:35:31,790
anything other than buffer overflows

721
00:35:23,230 --> 00:35:33,829
this is quite a good question you can in

722
00:35:31,790 --> 00:35:37,520
general you can use fuzzing only to find

723
00:35:33,829 --> 00:35:40,190
issues that will lead to to memory

724
00:35:37,520 --> 00:35:42,500
corruption but there are ways to find

725
00:35:40,190 --> 00:35:47,030
other vulnerabilities for example you

726
00:35:42,500 --> 00:35:49,490
can fight type confusion bugs or you can

727
00:35:47,030 --> 00:35:52,700
use for example on Linux you can employ

728
00:35:49,490 --> 00:35:54,560
different sanitizers for example address

729
00:35:52,700 --> 00:35:58,040
sanitizer asan or undefined behavior

730
00:35:54,560 --> 00:36:01,220
sanitizer which what this sanitizer it

731
00:35:58,040 --> 00:36:02,569
essentially does essentially do is they

732
00:36:01,220 --> 00:36:05,959
will crash the application when a

733
00:36:02,569 --> 00:36:08,180
certain kind of bug is happening and so

734
00:36:05,960 --> 00:36:09,770
if you're compiling your application

735
00:36:08,180 --> 00:36:11,299
using this sanitizer you have a good

736
00:36:09,770 --> 00:36:12,950
child chance to find out the

737
00:36:11,300 --> 00:36:14,540
vulnerabilities as well because

738
00:36:12,950 --> 00:36:19,149
eventually the application will crash

739
00:36:14,540 --> 00:36:19,150
and you can start from that point onward

740
00:36:19,930 --> 00:36:39,040
aren't there any questions left did you

741
00:36:33,050 --> 00:36:44,119
find this were only user space crashes

742
00:36:39,040 --> 00:36:47,329
thank you thank you all right if there

743
00:36:44,119 --> 00:36:53,720
are no further questions I spoke too

744
00:36:47,329 --> 00:36:56,440
soon my question is at some point you

745
00:36:53,720 --> 00:36:58,848
have to look at the coverage for your

746
00:36:56,440 --> 00:37:01,430
first binary to see if you're making

747
00:36:58,849 --> 00:37:04,690
progress do you have recommendations for

748
00:37:01,430 --> 00:37:08,390
tools that let you see visually how

749
00:37:04,690 --> 00:37:11,060
where your coverage is offending into

750
00:37:08,390 --> 00:37:12,828
the binary FL provides you multiple

751
00:37:11,060 --> 00:37:15,078
scripts then you can actually see the

752
00:37:12,829 --> 00:37:17,270
evolution of the coverage in a graphic

753
00:37:15,079 --> 00:37:20,300
so you will see the exact curve the

754
00:37:17,270 --> 00:37:21,619
exact asymptote being drawn and you can

755
00:37:20,300 --> 00:37:23,450
just take a look at that curve and

756
00:37:21,619 --> 00:37:25,640
decide when to stop at a certain point

757
00:37:23,450 --> 00:37:28,089
the father will not make any progress

758
00:37:25,640 --> 00:37:28,089
and

759
00:37:32,840 --> 00:37:40,090
okay I was thinking of being able to see

760
00:37:37,040 --> 00:37:42,620
which places which functions in your

761
00:37:40,090 --> 00:37:42,920
disassembly are being hit and which are

762
00:37:42,620 --> 00:37:44,930
not

763
00:37:42,920 --> 00:37:46,670
oh there is a a nice tool for it it's

764
00:37:44,930 --> 00:37:50,210
called the bug ID it's an opera source

765
00:37:46,670 --> 00:37:52,670
an open-source tool with what this tool

766
00:37:50,210 --> 00:37:55,610
does it's an Ida plug-in - it's an

767
00:37:52,670 --> 00:37:57,380
either plugin and you will take you will

768
00:37:55,610 --> 00:37:59,690
take the samples and you would run them

769
00:37:57,380 --> 00:38:01,400
through bug ID and you will it will tell

770
00:37:59,690 --> 00:38:03,290
you essentially what is the degree of

771
00:38:01,400 --> 00:38:04,340
coverage and for what methods so it does

772
00:38:03,290 --> 00:38:09,380
exactly what you want

773
00:38:04,340 --> 00:38:12,200
check out the bug ID and it's it's what

774
00:38:09,380 --> 00:38:15,310
you need all right thank you everyone

775
00:38:12,200 --> 00:38:15,310
thank you rod thank you

