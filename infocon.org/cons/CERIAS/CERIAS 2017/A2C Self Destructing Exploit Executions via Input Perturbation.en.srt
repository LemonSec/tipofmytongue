1
00:00:05,870 --> 00:00:11,870
okay so hello everybody welcome to

2
00:00:09,830 --> 00:00:15,530
next in the series of serious seminar

3
00:00:11,870 --> 00:00:17,720
talks for spring semester 2017 so today

4
00:00:15,530 --> 00:00:21,110
we have again somebody from local we

5
00:00:17,720 --> 00:00:23,270
have Jean V young lee kuan from computer

6
00:00:21,110 --> 00:00:25,490
science department he's a PhD student

7
00:00:23,270 --> 00:00:28,990
here in couple design department working

8
00:00:25,490 --> 00:00:32,540
with dong myung-su and Jang Yoo sang and

9
00:00:28,990 --> 00:00:34,250
he typically works on system security in

10
00:00:32,540 --> 00:00:36,949
particularly he's interested in looking

11
00:00:34,250 --> 00:00:38,330
using static analysis and tools which

12
00:00:36,949 --> 00:00:43,309
are coming from the software security

13
00:00:38,330 --> 00:00:44,720
you think that took to find flaws and so

14
00:00:43,309 --> 00:00:46,820
were coming the issues that we see

15
00:00:44,720 --> 00:00:49,640
typically in the system security today

16
00:00:46,820 --> 00:00:52,549
he's going to talk about a to see their

17
00:00:49,640 --> 00:00:53,900
a new project which next week is going

18
00:00:52,549 --> 00:00:56,449
to appear at India is one of the

19
00:00:53,900 --> 00:00:58,850
top-tier conferences in security and he

20
00:00:56,449 --> 00:01:01,809
agreed to give a talk about that before

21
00:00:58,850 --> 00:01:01,809
moving on to there so

22
00:01:06,659 --> 00:01:14,880
oh thank you and a afternoon my name is

23
00:01:13,049 --> 00:01:17,640
Yao Ming Quan and today I'm gonna

24
00:01:14,880 --> 00:01:19,679
present a to see self-destructing

25
00:01:17,640 --> 00:01:22,039
exploit execution spear input

26
00:01:19,679 --> 00:01:24,240
perturbation this is a joint work with

27
00:01:22,039 --> 00:01:26,030
Purdue University and University of

28
00:01:24,240 --> 00:01:29,789
Georgia

29
00:01:26,030 --> 00:01:32,459
so this winter we has quite a nice

30
00:01:29,789 --> 00:01:34,409
winter but in the securities the weather

31
00:01:32,459 --> 00:01:37,579
is quite bad we have so many

32
00:01:34,409 --> 00:01:40,379
vulnerabilities every day coming up so

33
00:01:37,579 --> 00:01:42,719
essentially we are living in a world of

34
00:01:40,379 --> 00:01:47,700
vulnerabilities just to name a few pop

35
00:01:42,719 --> 00:01:50,339
overflow in Kedah overflow ROP use depth

36
00:01:47,700 --> 00:01:52,500
of free hip spring type confusion there

37
00:01:50,340 --> 00:01:55,979
are so many attacks and so different

38
00:01:52,500 --> 00:01:57,780
ways to break the systems but we

39
00:01:55,979 --> 00:02:00,119
shouldn't be that depressed because we

40
00:01:57,780 --> 00:02:02,789
have also good guys there are so many

41
00:02:00,119 --> 00:02:06,239
protections to we have so many antivirus

42
00:02:02,789 --> 00:02:09,449
systems and hi Mario softwares and also

43
00:02:06,239 --> 00:02:14,790
from research communities we have bound

44
00:02:09,449 --> 00:02:18,599
checker CFI dfi and a lot of shellcode

45
00:02:14,790 --> 00:02:20,519
detection techniques and ASR all but

46
00:02:18,599 --> 00:02:23,518
here the problem is whether all these

47
00:02:20,519 --> 00:02:27,090
protections now we are safe to use our

48
00:02:23,519 --> 00:02:31,620
computers definitely we will know the

49
00:02:27,090 --> 00:02:35,489
answer is not great so we try to ask the

50
00:02:31,620 --> 00:02:38,310
question why why all these or not enough

51
00:02:35,489 --> 00:02:41,760
so we analyze all these existing

52
00:02:38,310 --> 00:02:46,680
techniques we come up with the answers

53
00:02:41,760 --> 00:02:49,019
to these questions so first we find out

54
00:02:46,680 --> 00:02:51,359
that a lot of great protections they

55
00:02:49,019 --> 00:02:55,169
have so many overheads so we cannot just

56
00:02:51,359 --> 00:02:58,410
simply apply these protections and the

57
00:02:55,169 --> 00:03:01,769
second reason is there are tech defenses

58
00:02:58,410 --> 00:03:03,180
that is specific to our tech surfaces so

59
00:03:01,769 --> 00:03:06,060
then we always know that attackers

60
00:03:03,180 --> 00:03:09,389
always find a way to break and avoid

61
00:03:06,060 --> 00:03:12,150
circumvent these attacks with specific

62
00:03:09,389 --> 00:03:13,980
defenses and later we also find that

63
00:03:12,150 --> 00:03:16,650
there are simply too large attack

64
00:03:13,980 --> 00:03:18,600
surfaces even though we prevent all the

65
00:03:16,650 --> 00:03:20,430
known attacks we see that attackers

66
00:03:18,600 --> 00:03:23,599
always come up with a new idea

67
00:03:20,430 --> 00:03:26,549
to attack the system so we say

68
00:03:23,599 --> 00:03:31,260
preventing no method may not last long

69
00:03:26,549 --> 00:03:34,140
so naturally these limitations of the

70
00:03:31,260 --> 00:03:38,548
existing systems lead us to have a new

71
00:03:34,140 --> 00:03:40,379
goal for our solution so first we want

72
00:03:38,549 --> 00:03:43,530
to have low overhead so that it can be

73
00:03:40,379 --> 00:03:46,170
practical and the second one in one is

74
00:03:43,530 --> 00:03:47,670
we need to have a general protection so

75
00:03:46,170 --> 00:03:50,429
we should not rely on any specific

76
00:03:47,670 --> 00:03:54,298
attack method to come up with the

77
00:03:50,430 --> 00:03:58,500
protection so that with our system we

78
00:03:54,299 --> 00:04:01,139
can potentially prevent a new attack

79
00:03:58,500 --> 00:04:04,169
method which we don't even know now and

80
00:04:01,139 --> 00:04:08,069
also we want to be complimentary because

81
00:04:04,169 --> 00:04:10,200
even though we are doing really hard one

82
00:04:08,069 --> 00:04:12,719
simple system cannot prevent everything

83
00:04:10,200 --> 00:04:14,668
so we want to be prevent the system with

84
00:04:12,719 --> 00:04:21,719
other great protection so the

85
00:04:14,669 --> 00:04:24,180
compatibility is our major goal so we

86
00:04:21,720 --> 00:04:27,750
were thinking how we can come up with a

87
00:04:24,180 --> 00:04:30,300
solution with these very nice goals and

88
00:04:27,750 --> 00:04:33,150
we started from analyzing bunch of

89
00:04:30,300 --> 00:04:35,760
attacks in detail and we find that in

90
00:04:33,150 --> 00:04:37,820
most attacks attackers need to inject

91
00:04:35,760 --> 00:04:39,870
malicious payload which they want to

92
00:04:37,820 --> 00:04:43,560
execute some of the sequence of

93
00:04:39,870 --> 00:04:47,130
operation and we find by analyzing a lot

94
00:04:43,560 --> 00:04:50,520
of exploits they are a very fragile let

95
00:04:47,130 --> 00:04:53,909
me show you an example here we have an

96
00:04:50,520 --> 00:04:56,880
attacker and a program and we find that

97
00:04:53,909 --> 00:04:59,039
most time they send first malicious

98
00:04:56,880 --> 00:05:02,370
input to trigger some vulnerability to

99
00:04:59,039 --> 00:05:04,860
break the software and then once they

100
00:05:02,370 --> 00:05:07,889
trigger that exploit I mean it trigger

101
00:05:04,860 --> 00:05:10,320
that vulnerability they later send the

102
00:05:07,889 --> 00:05:12,120
payload which is a set of operation they

103
00:05:10,320 --> 00:05:16,199
won't execute for example they want to

104
00:05:12,120 --> 00:05:18,990
open a network like a port so that they

105
00:05:16,199 --> 00:05:23,000
can connect them later excuse of

106
00:05:18,990 --> 00:05:25,650
malicious it commands then we see

107
00:05:23,000 --> 00:05:27,599
analyze this payload here is an example

108
00:05:25,650 --> 00:05:30,060
of the payload on the left side is the

109
00:05:27,599 --> 00:05:34,289
hex code of this payload on the right

110
00:05:30,060 --> 00:05:38,009
side it is a instruction way

111
00:05:34,289 --> 00:05:40,139
nation of this hex code essentially this

112
00:05:38,009 --> 00:05:42,899
like a hex code numbers when you put

113
00:05:40,139 --> 00:05:45,659
into the computer the CPU will see this

114
00:05:42,899 --> 00:05:50,430
instruction and do this command

115
00:05:45,659 --> 00:05:54,449
execution so as we told that this is

116
00:05:50,430 --> 00:05:56,759
these payloads are so fragile so even

117
00:05:54,449 --> 00:05:59,009
very little computation on this one

118
00:05:56,759 --> 00:06:01,199
any mutation on this one will break the

119
00:05:59,009 --> 00:06:08,479
semantics of this payload very

120
00:06:01,199 --> 00:06:13,919
completely so here we apply XOR with a a

121
00:06:08,479 --> 00:06:18,688
then this is the reserve here you see

122
00:06:13,919 --> 00:06:20,609
like the first number 31 becomes 9b and

123
00:06:18,689 --> 00:06:23,129
all the following numbers are change it

124
00:06:20,610 --> 00:06:26,879
more importantly you see it on the right

125
00:06:23,129 --> 00:06:29,399
side when the CPU sees this change it

126
00:06:26,879 --> 00:06:31,649
payload it will show you will see

127
00:06:29,399 --> 00:06:35,419
totally different instructions so you

128
00:06:31,649 --> 00:06:37,860
see this payload is totally broken and

129
00:06:35,419 --> 00:06:43,469
attackers cannot achieve their goals

130
00:06:37,860 --> 00:06:46,680
what they intended first so we build a

131
00:06:43,469 --> 00:06:50,669
system on top of this observation here

132
00:06:46,680 --> 00:06:52,319
is the high-level idea of our system the

133
00:06:50,669 --> 00:06:55,558
program execution first start with the

134
00:06:52,319 --> 00:07:01,789
inputs and whenever we get inputs we

135
00:06:55,559 --> 00:07:01,789
encode so that we get encoded input and

136
00:07:01,879 --> 00:07:07,800
when the program and then the program

137
00:07:05,069 --> 00:07:11,339
will repeat is encoded input and when

138
00:07:07,800 --> 00:07:13,589
our attacker wants to execute their

139
00:07:11,339 --> 00:07:15,269
exploit the payload is already encoded

140
00:07:13,589 --> 00:07:19,919
as we just saw in the previous page

141
00:07:15,269 --> 00:07:23,099
slide so the attack will fail but this

142
00:07:19,919 --> 00:07:25,229
you may have some question that what if

143
00:07:23,099 --> 00:07:27,979
they want to actually read the input and

144
00:07:25,229 --> 00:07:32,219
process something so when the program

145
00:07:27,979 --> 00:07:34,469
executes a p9 request then we actually

146
00:07:32,219 --> 00:07:41,719
decode the inputs for that request and

147
00:07:34,469 --> 00:07:45,300
then the program behaved correctly so

148
00:07:41,719 --> 00:07:47,909
because I just show you how we break the

149
00:07:45,300 --> 00:07:50,540
exploit now I want to explain

150
00:07:47,910 --> 00:07:53,940
how we guarantee the p9 execution is

151
00:07:50,540 --> 00:07:57,480
correct so let me start with a simple

152
00:07:53,940 --> 00:08:01,170
input is a HTTP request with the post

153
00:07:57,480 --> 00:08:04,740
and the path of this request is indexed

154
00:08:01,170 --> 00:08:08,670
at PHP and there is a HTTP version

155
00:08:04,740 --> 00:08:13,740
specified this request and before it

156
00:08:08,670 --> 00:08:17,670
gets read by the program reversing code

157
00:08:13,740 --> 00:08:21,060
input so here we see I just do simple -

158
00:08:17,670 --> 00:08:26,130
you you see that like a pea becomes all

159
00:08:21,060 --> 00:08:28,680
because P minus 1 in s code is o and all

160
00:08:26,130 --> 00:08:32,240
the following inputs are we just apply

161
00:08:28,680 --> 00:08:36,030
all the - and operation on each byte and

162
00:08:32,240 --> 00:08:37,500
the web server gets this input and of

163
00:08:36,030 --> 00:08:40,650
course they want to parse and process

164
00:08:37,500 --> 00:08:44,310
input to generate outputs then we will -

165
00:08:40,650 --> 00:08:46,980
decoding for this web server so when it

166
00:08:44,310 --> 00:08:51,030
wants to some operations on it we first

167
00:08:46,980 --> 00:08:53,240
take the encoded input and when it wants

168
00:08:51,030 --> 00:08:56,490
to understand what's the command of this

169
00:08:53,240 --> 00:08:58,620
HTTP request then they want to leave the

170
00:08:56,490 --> 00:09:00,690
first full byte of the weakest then we

171
00:08:58,620 --> 00:09:03,330
just take the full byte and decode and

172
00:09:00,690 --> 00:09:05,460
give it back to the web server so the

173
00:09:03,330 --> 00:09:10,350
web server can operate correctly and it

174
00:09:05,460 --> 00:09:17,040
does for path also for the version of

175
00:09:10,350 --> 00:09:19,230
the HTTP protocol now it gets all the

176
00:09:17,040 --> 00:09:22,500
correct inputs and produce correct

177
00:09:19,230 --> 00:09:27,690
outputs even though we encode these

178
00:09:22,500 --> 00:09:29,940
inputs so may be naturally you may have

179
00:09:27,690 --> 00:09:34,770
some question because we definitely

180
00:09:29,940 --> 00:09:37,770
decode some inputs here and the question

181
00:09:34,770 --> 00:09:39,480
may be why the pillows are not decoded

182
00:09:37,770 --> 00:09:42,449
even though some inputs are decoded for

183
00:09:39,480 --> 00:09:46,550
dp9 execution so here is our cast I mean

184
00:09:42,450 --> 00:09:49,080
answer so the first thing is we actually

185
00:09:46,550 --> 00:09:51,510
decode based on the program's intention

186
00:09:49,080 --> 00:09:53,850
means that we respect the program's

187
00:09:51,510 --> 00:09:56,970
original intention of how they use the

188
00:09:53,850 --> 00:09:59,970
data so we statically analyze a program

189
00:09:56,970 --> 00:10:01,710
and because when the inputs are used by

190
00:09:59,970 --> 00:10:07,200
the program as the

191
00:10:01,710 --> 00:10:09,960
in handy dater so you may think of there

192
00:10:07,200 --> 00:10:12,870
is no program I mean it's quite strong

193
00:10:09,960 --> 00:10:15,720
but there's not much program that takes

194
00:10:12,870 --> 00:10:18,630
input from the outside and try to cast

195
00:10:15,720 --> 00:10:21,780
this input as an instruction of the CPU

196
00:10:18,630 --> 00:10:27,180
and just execute that sounds like a like

197
00:10:21,780 --> 00:10:30,270
a back door so that also echoes our

198
00:10:27,180 --> 00:10:32,489
second point these malicious payloads

199
00:10:30,270 --> 00:10:35,910
are actually not supposed to be executed

200
00:10:32,490 --> 00:10:38,280
by the original program so what we do is

201
00:10:35,910 --> 00:10:41,550
we do not put decoding musics for this

202
00:10:38,280 --> 00:10:45,380
unintended execution but we do decode

203
00:10:41,550 --> 00:10:48,750
for intended program execution

204
00:10:45,380 --> 00:10:51,930
so all these two points actually came

205
00:10:48,750 --> 00:10:57,450
from an assumption that inputs should be

206
00:10:51,930 --> 00:11:00,120
data not the code so A to C our system

207
00:10:57,450 --> 00:11:04,530
allows the inputs to be excessive access

208
00:11:00,120 --> 00:11:07,290
it as in handy types of data but it will

209
00:11:04,530 --> 00:11:11,670
break the code execution which is

210
00:11:07,290 --> 00:11:17,939
unintended types of data when it gets

211
00:11:11,670 --> 00:11:23,849
injected and exploited so let me explain

212
00:11:17,940 --> 00:11:27,030
our system its overview so we first get

213
00:11:23,850 --> 00:11:29,640
the original program and then we do

214
00:11:27,030 --> 00:11:32,610
static program analysis the program

215
00:11:29,640 --> 00:11:35,310
analysis part consists of two parts one

216
00:11:32,610 --> 00:11:37,980
is constraint solving and our static

217
00:11:35,310 --> 00:11:41,459
analysis this one is quite complex we

218
00:11:37,980 --> 00:11:43,950
will get into the details very soon so

219
00:11:41,460 --> 00:11:46,890
that's why we use constraint server

220
00:11:43,950 --> 00:11:49,460
which is g3 from Microsoft and during

221
00:11:46,890 --> 00:11:52,770
the state of analysis we use our VM and

222
00:11:49,460 --> 00:11:54,780
then after this program analysis part we

223
00:11:52,770 --> 00:11:58,140
get the instrumented program has

224
00:11:54,780 --> 00:11:59,970
encoding and decoding functions and then

225
00:11:58,140 --> 00:12:03,170
we also need to have the runtime support

226
00:11:59,970 --> 00:12:10,260
to execute these encoding and decoding

227
00:12:03,170 --> 00:12:11,310
functions so let's start from a static

228
00:12:10,260 --> 00:12:13,920
analysis

229
00:12:11,310 --> 00:12:15,209
constraint serving part of the program

230
00:12:13,920 --> 00:12:17,699
analysis

231
00:12:15,209 --> 00:12:21,508
we first need to answer when to decode

232
00:12:17,699 --> 00:12:23,779
and encode maybe the first question is a

233
00:12:21,509 --> 00:12:26,970
little bit simple when to encode is

234
00:12:23,779 --> 00:12:30,149
fairly simple we just say encode any

235
00:12:26,970 --> 00:12:33,089
incoming untrusted sources a library

236
00:12:30,149 --> 00:12:35,399
level for example if a program received

237
00:12:33,089 --> 00:12:37,800
some untrusted buffer from outside from

238
00:12:35,399 --> 00:12:40,139
network then we just encode everything

239
00:12:37,800 --> 00:12:42,839
if the program reads some untrusted

240
00:12:40,139 --> 00:12:46,920
files we also encode everything but the

241
00:12:42,839 --> 00:12:49,290
problem is when to decode intuitively we

242
00:12:46,920 --> 00:12:53,179
can say we can decode when the encoded

243
00:12:49,290 --> 00:12:57,748
values are used but we soon encounter

244
00:12:53,179 --> 00:13:01,619
these questioned programs take the input

245
00:12:57,749 --> 00:13:04,730
and process and then do some computation

246
00:13:01,619 --> 00:13:07,769
and then process outputs then if the

247
00:13:04,730 --> 00:13:11,069
program do some computation on these

248
00:13:07,769 --> 00:13:14,449
values then it generate new values do we

249
00:13:11,069 --> 00:13:18,118
need to encode these values again or not

250
00:13:14,449 --> 00:13:20,969
so this is actually fairly hard question

251
00:13:18,119 --> 00:13:23,519
to answer so to answer this question we

252
00:13:20,970 --> 00:13:25,529
first analyze the program and what they

253
00:13:23,519 --> 00:13:28,709
are really doing here is a small example

254
00:13:25,529 --> 00:13:31,009
that a program takes input do some

255
00:13:28,709 --> 00:13:34,349
computation and then generate outputs

256
00:13:31,009 --> 00:13:36,990
usually programs takes input sometimes

257
00:13:34,350 --> 00:13:40,829
it copies here and there around because

258
00:13:36,990 --> 00:13:44,069
you need to say fragment inputs for

259
00:13:40,829 --> 00:13:48,508
different proposed and sometimes program

260
00:13:44,069 --> 00:13:50,279
convert some of the characters to into

261
00:13:48,509 --> 00:13:54,269
another type of characters for example

262
00:13:50,279 --> 00:13:56,850
some programs take an ASCII code and

263
00:13:54,269 --> 00:14:04,110
convert it to the Unicode or vice-versa

264
00:13:56,850 --> 00:14:06,929
and the other types of operations like

265
00:14:04,110 --> 00:14:10,170
read and compare essentially this one is

266
00:14:06,929 --> 00:14:12,529
a common operations in the parsing so

267
00:14:10,170 --> 00:14:15,299
you first read the input and then have a

268
00:14:12,529 --> 00:14:17,369
predicate like if statement and then do

269
00:14:15,299 --> 00:14:20,639
something depending on the input and

270
00:14:17,369 --> 00:14:22,889
also some a lot of programs too like a

271
00:14:20,639 --> 00:14:26,249
caste inputs and do a lot of computation

272
00:14:22,889 --> 00:14:28,529
for example encryption like mathematic

273
00:14:26,249 --> 00:14:31,469
programs

274
00:14:28,529 --> 00:14:34,379
but in our context because we are

275
00:14:31,469 --> 00:14:38,099
assuming that inputs could be malicious

276
00:14:34,379 --> 00:14:40,319
we need to think about if we decode in

277
00:14:38,099 --> 00:14:42,629
this kind of operation whether this is

278
00:14:40,319 --> 00:14:45,269
safe definitely the first one copy

279
00:14:42,629 --> 00:14:47,989
operation is now safe because copy

280
00:14:45,269 --> 00:14:50,819
doesn't change anything so if we decode

281
00:14:47,989 --> 00:14:52,469
operation at top copy operations then

282
00:14:50,819 --> 00:14:55,409
essentially we are helping the attackers

283
00:14:52,469 --> 00:14:56,899
we just get the input encoded and decode

284
00:14:55,409 --> 00:14:59,099
at the right time

285
00:14:56,899 --> 00:15:01,859
but the conversion is a little bit

286
00:14:59,099 --> 00:15:04,139
difficult to answer because there are

287
00:15:01,859 --> 00:15:07,679
quite simple conversions but also there

288
00:15:04,139 --> 00:15:11,819
are quite complex conversions actually

289
00:15:07,679 --> 00:15:15,689
there is a papers like a lot of people

290
00:15:11,819 --> 00:15:17,639
think thought that Unicode can break a

291
00:15:15,689 --> 00:15:20,309
lot of shellcode because when you think

292
00:15:17,639 --> 00:15:22,859
about the Unicode Unicode always not

293
00:15:20,309 --> 00:15:25,649
always but for English letters you need

294
00:15:22,859 --> 00:15:28,289
to always have zeros in every other

295
00:15:25,649 --> 00:15:30,329
bytes people think that you will break a

296
00:15:28,289 --> 00:15:34,289
lot of shellcode but there is also a lot

297
00:15:30,329 --> 00:15:38,279
of papers on it saying that with these

298
00:15:34,289 --> 00:15:41,970
kind of restrictions on numbers you can

299
00:15:38,279 --> 00:15:44,339
still generate useful shellcode so this

300
00:15:41,970 --> 00:15:47,249
one is quite difficult to answer so

301
00:15:44,339 --> 00:15:50,069
let's move on and there is a region part

302
00:15:47,249 --> 00:15:52,169
I read in compare which is parts this

303
00:15:50,069 --> 00:15:54,929
one is fairly simple to say because when

304
00:15:52,169 --> 00:15:57,629
they compare actually they made a small

305
00:15:54,929 --> 00:16:00,899
copy of big chunk of the buffer and then

306
00:15:57,629 --> 00:16:03,869
they compare and then after comparison

307
00:16:00,899 --> 00:16:06,569
soon they disposed the data so we are

308
00:16:03,869 --> 00:16:08,699
saying this is safe to decode so we have

309
00:16:06,569 --> 00:16:12,299
quick answer here and also the

310
00:16:08,699 --> 00:16:13,858
computation this is also similar case of

311
00:16:12,299 --> 00:16:17,279
the conversion there are simple

312
00:16:13,859 --> 00:16:19,679
computation that we may see it as a copy

313
00:16:17,279 --> 00:16:22,470
or they are a very complex computation

314
00:16:19,679 --> 00:16:28,289
which is hard to know whether is safe to

315
00:16:22,470 --> 00:16:32,929
decode or not so essentially now we

316
00:16:28,289 --> 00:16:36,479
focus on these two complex cases and we

317
00:16:32,929 --> 00:16:39,509
conclude that answer discussion is

318
00:16:36,479 --> 00:16:42,430
essentially we answer the question of

319
00:16:39,509 --> 00:16:45,370
can attacker control the reserve

320
00:16:42,430 --> 00:16:47,650
the computation for example if the

321
00:16:45,370 --> 00:16:51,430
attacker send a and after the

322
00:16:47,650 --> 00:16:54,730
computation they get X and if you attack

323
00:16:51,430 --> 00:16:57,969
us send B and after the computation they

324
00:16:54,730 --> 00:17:03,610
get Y that means that if attacker knows

325
00:16:57,970 --> 00:17:06,190
if a will get result of X if we get Y

326
00:17:03,610 --> 00:17:09,250
then he will prepare their shellcode

327
00:17:06,190 --> 00:17:11,320
beforehand so that even after the

328
00:17:09,250 --> 00:17:13,900
computation their shellcode will get the

329
00:17:11,319 --> 00:17:16,510
right format so in this case we think

330
00:17:13,900 --> 00:17:19,089
that this computation is not safe to

331
00:17:16,510 --> 00:17:20,890
decode because as you can see after the

332
00:17:19,089 --> 00:17:29,889
computation attackers will have control

333
00:17:20,890 --> 00:17:32,980
over the data but this case if attackers

334
00:17:29,890 --> 00:17:36,310
and a and it gets one if your taker send

335
00:17:32,980 --> 00:17:39,160
B it also gets one no matter you send

336
00:17:36,310 --> 00:17:41,110
you get always one in this case pretty

337
00:17:39,160 --> 00:17:43,510
much we are you can say this is safe

338
00:17:41,110 --> 00:17:45,429
because even though technology operation

339
00:17:43,510 --> 00:17:48,010
attacker may not leverage this one to

340
00:17:45,430 --> 00:17:56,440
construct because all attacker can have

341
00:17:48,010 --> 00:18:00,250
is just single number one so the problem

342
00:17:56,440 --> 00:18:03,280
is even though these are there were two

343
00:18:00,250 --> 00:18:05,380
examples we don't know keep on a

344
00:18:03,280 --> 00:18:08,860
computation we don't know which one is

345
00:18:05,380 --> 00:18:11,530
the case so we're not sure so then we

346
00:18:08,860 --> 00:18:14,320
need to ask somebody so we try to ask

347
00:18:11,530 --> 00:18:16,210
the constraint solver to answer this

348
00:18:14,320 --> 00:18:19,899
question constraint server is

349
00:18:16,210 --> 00:18:22,720
essentially a system you keep a lot of

350
00:18:19,900 --> 00:18:25,360
conditions and ask them whether this

351
00:18:22,720 --> 00:18:27,820
condition satisfied or not then they

352
00:18:25,360 --> 00:18:31,090
will do a bunch of computation and give

353
00:18:27,820 --> 00:18:34,419
you give you an answer so here is a

354
00:18:31,090 --> 00:18:38,649
small program example that we want to

355
00:18:34,420 --> 00:18:42,850
know whether this computation is

356
00:18:38,650 --> 00:18:48,520
controllable or not so you see m7 and

357
00:18:42,850 --> 00:18:51,820
IMG and NPR IMG and NPR are developers

358
00:18:48,520 --> 00:18:54,070
that attacker can control and m7 is the

359
00:18:51,820 --> 00:18:55,000
result of the computation computation is

360
00:18:54,070 --> 00:18:56,980
fairly simple

361
00:18:55,000 --> 00:19:00,039
it just

362
00:18:56,980 --> 00:19:07,990
IMG - NPR and assign the reserve to the

363
00:19:00,039 --> 00:19:11,889
m7 right and one important thing is you

364
00:19:07,990 --> 00:19:14,559
need to notice that here m7 is unsigned

365
00:19:11,889 --> 00:19:19,360
in which is full byte in most operating

366
00:19:14,559 --> 00:19:22,029
system and IMG and MPR are unsigned

367
00:19:19,360 --> 00:19:24,789
short which is 2 byte so let's keep that

368
00:19:22,029 --> 00:19:27,880
in mind and see what happens

369
00:19:24,789 --> 00:19:29,879
so to ask the constraint solver we

370
00:19:27,880 --> 00:19:32,500
actually need to change the program

371
00:19:29,880 --> 00:19:36,419
language to the language that constraint

372
00:19:32,500 --> 00:19:40,659
solver can understand so now we want to

373
00:19:36,419 --> 00:19:43,450
model this line 6 the computation to the

374
00:19:40,659 --> 00:19:45,159
constraint solver language this is an

375
00:19:43,450 --> 00:19:48,639
example of constraint server language

376
00:19:45,159 --> 00:19:51,700
the first we model the computation is

377
00:19:48,639 --> 00:19:58,240
fairly simple it's the same operations

378
00:19:51,700 --> 00:20:02,200
it just - does IMG - NPR equals m 7 and

379
00:19:58,240 --> 00:20:05,620
then we also keep the the range of the

380
00:20:02,200 --> 00:20:09,100
value remember that we have IMG an NPR

381
00:20:05,620 --> 00:20:14,969
are unsigned short so we give the range

382
00:20:09,100 --> 00:20:21,340
of unsigned short which is 0 to 65535

383
00:20:14,970 --> 00:20:24,549
and then finally we give the condition

384
00:20:21,340 --> 00:20:28,389
that whether the research m7 can be a

385
00:20:24,549 --> 00:20:34,960
payload here the payload is array of

386
00:20:28,389 --> 00:20:36,399
giant data which we collected from a lot

387
00:20:34,960 --> 00:20:39,190
of different website which is

388
00:20:36,399 --> 00:20:42,239
essentially representing a shellcode Rob

389
00:20:39,190 --> 00:20:45,010
Gossett's binary code any possible

390
00:20:42,240 --> 00:20:47,529
random numbers we collect these data

391
00:20:45,010 --> 00:20:51,250
from all kinds of different sources and

392
00:20:47,529 --> 00:20:56,760
made a 1.4 gigabyte a large payload pool

393
00:20:51,250 --> 00:20:59,919
and we compare this data concrete data

394
00:20:56,760 --> 00:21:02,470
with this condition and then we throw

395
00:20:59,919 --> 00:21:04,659
this operation to the constraint server

396
00:21:02,470 --> 00:21:07,299
and wait for the answers and constraints

397
00:21:04,659 --> 00:21:09,450
constraints also say yes or no then we

398
00:21:07,299 --> 00:21:13,320
take this answer to

399
00:21:09,450 --> 00:21:17,220
answer the question so essentially we

400
00:21:13,320 --> 00:21:19,980
use Microsoft g3 server and we get a

401
00:21:17,220 --> 00:21:23,190
payload from internet like exploit

402
00:21:19,980 --> 00:21:26,100
database meta exploit shared storm org

403
00:21:23,190 --> 00:21:30,750
and a lot of Rob Carter tools from own

404
00:21:26,100 --> 00:21:32,668
we run on existing binaries and also we

405
00:21:30,750 --> 00:21:35,779
generate a lot of random numbers using

406
00:21:32,669 --> 00:21:40,649
random generator and also with decompile

407
00:21:35,779 --> 00:21:44,899
all existing Linux binaries on my

408
00:21:40,649 --> 00:21:53,610
computer and then put into the giant

409
00:21:44,899 --> 00:21:57,029
payload pool so we asked a constraint

410
00:21:53,610 --> 00:21:58,709
server and if the these are kind of

411
00:21:57,029 --> 00:21:59,580
answers that we can get from the

412
00:21:58,710 --> 00:22:03,029
constraint server

413
00:21:59,580 --> 00:22:05,699
the first one is SAT set means that it

414
00:22:03,029 --> 00:22:08,279
steadies variable that means given that

415
00:22:05,700 --> 00:22:11,760
condition an attacker can construct the

416
00:22:08,279 --> 00:22:14,429
payload through this computation so in

417
00:22:11,760 --> 00:22:17,970
this case obviously attackers have

418
00:22:14,429 --> 00:22:19,889
control and the timeout means that we

419
00:22:17,970 --> 00:22:21,210
runs constraint servers and the

420
00:22:19,889 --> 00:22:23,879
constraint solver try to compute

421
00:22:21,210 --> 00:22:28,289
something but it took too much too long

422
00:22:23,880 --> 00:22:32,760
time and then we didn't get the answer

423
00:22:28,289 --> 00:22:35,220
in like a few minutes so then it we say

424
00:22:32,760 --> 00:22:37,379
is a timeout means that we actually

425
00:22:35,220 --> 00:22:40,679
don't know so we take the conservative

426
00:22:37,380 --> 00:22:42,750
position saying that maybe attacker can

427
00:22:40,679 --> 00:22:44,519
control unknown also means that

428
00:22:42,750 --> 00:22:47,159
constraint server think that the

429
00:22:44,519 --> 00:22:51,960
computation is too complex and some of

430
00:22:47,159 --> 00:22:54,419
the like a computation is not modeled in

431
00:22:51,960 --> 00:22:56,669
the constraint server so they say I

432
00:22:54,419 --> 00:22:59,490
cannot solve this problem so we also

433
00:22:56,669 --> 00:23:01,649
take the conservative position and say

434
00:22:59,490 --> 00:23:05,159
I'll take our main control because they

435
00:23:01,649 --> 00:23:08,070
don't know but there are some cases that

436
00:23:05,159 --> 00:23:09,029
say that for sure given that your

437
00:23:08,070 --> 00:23:11,490
payload pool

438
00:23:09,029 --> 00:23:13,500
we cannot attackers cannot generate

439
00:23:11,490 --> 00:23:15,870
meaningful payload after this

440
00:23:13,500 --> 00:23:18,720
computation so then in this case they

441
00:23:15,870 --> 00:23:20,820
returned unset then we say ok this is

442
00:23:18,720 --> 00:23:23,090
the safe computation after this

443
00:23:20,820 --> 00:23:32,570
computation the payload is

444
00:23:23,090 --> 00:23:34,310
broken so now we can come back this so

445
00:23:32,570 --> 00:23:36,139
my question is but then there can be

446
00:23:34,310 --> 00:23:40,639
some legitimate program where it will

447
00:23:36,140 --> 00:23:43,160
feel right you may not be able to there

448
00:23:40,640 --> 00:23:45,470
will be legitimate program and then when

449
00:23:43,160 --> 00:23:48,260
you get them basically you won't be able

450
00:23:45,470 --> 00:23:51,340
to make them working because you make

451
00:23:48,260 --> 00:23:54,980
the attackers payload filled right right

452
00:23:51,340 --> 00:23:56,540
so there also some false negative or I

453
00:23:54,980 --> 00:23:58,040
don't know how you call it that there

454
00:23:56,540 --> 00:24:01,420
are some legitimate code which are not

455
00:23:58,040 --> 00:24:05,600
attacker code and they won't succeed

456
00:24:01,420 --> 00:24:08,330
actually the answer is like a weak aren

457
00:24:05,600 --> 00:24:11,750
t 59 executions correctness of 59

458
00:24:08,330 --> 00:24:13,159
executions so there's no breaking no but

459
00:24:11,750 --> 00:24:15,590
there is a difference between benign and

460
00:24:13,160 --> 00:24:17,060
legitimate right benign dozen legitimate

461
00:24:15,590 --> 00:24:19,310
with everything which is possible even

462
00:24:17,060 --> 00:24:21,379
attackers instructions are one which are

463
00:24:19,310 --> 00:24:23,149
possible in your system right he just

464
00:24:21,380 --> 00:24:28,750
but they are malicious but they are

465
00:24:23,150 --> 00:24:31,610
still correct instructions right or I

466
00:24:28,750 --> 00:24:35,510
mean how you make sure what's not clear

467
00:24:31,610 --> 00:24:39,050
to me is how you make sure that that

468
00:24:35,510 --> 00:24:40,490
some are you sure that the there are

469
00:24:39,050 --> 00:24:44,000
some correct programs which will not

470
00:24:40,490 --> 00:24:46,550
fail in this way so this is actually

471
00:24:44,000 --> 00:24:49,250
complete computing decoding frontier is

472
00:24:46,550 --> 00:24:51,860
we want to know which computation is

473
00:24:49,250 --> 00:24:53,900
fairly complex enough so that attacker

474
00:24:51,860 --> 00:24:57,979
cannot gain the control over this one

475
00:24:53,900 --> 00:25:01,880
but guaranteeing correct execution is

476
00:24:57,980 --> 00:25:04,610
more about how we can completely find a

477
00:25:01,880 --> 00:25:06,800
maker because we blindly encode all the

478
00:25:04,610 --> 00:25:10,639
inputs we need to find all the cases

479
00:25:06,800 --> 00:25:12,590
that inputs is used so that one is done

480
00:25:10,640 --> 00:25:15,080
in the state of analysis which will be

481
00:25:12,590 --> 00:25:19,250
covered a little bit later this one is

482
00:25:15,080 --> 00:25:22,189
just right the the first problem is

483
00:25:19,250 --> 00:25:23,930
actually without this decoding frontier

484
00:25:22,190 --> 00:25:25,850
what we can do is we just encode

485
00:25:23,930 --> 00:25:28,130
everything and decode everything but

486
00:25:25,850 --> 00:25:32,780
that incurs a lot of overhead so what we

487
00:25:28,130 --> 00:25:34,880
want to see was because the inputs are

488
00:25:32,780 --> 00:25:37,070
going through some computation and then

489
00:25:34,880 --> 00:25:39,620
soon it will be

490
00:25:37,070 --> 00:25:42,289
difficulty exploit then we are saying

491
00:25:39,620 --> 00:25:44,779
that we may not need to decode

492
00:25:42,289 --> 00:25:46,908
everywhere we may just cut here and

493
00:25:44,779 --> 00:25:49,309
forget about all this complex

494
00:25:46,909 --> 00:25:59,720
computation to save the overhead and

495
00:25:49,309 --> 00:26:03,399
make it practical so now we can come

496
00:25:59,720 --> 00:26:05,870
back to this question and can answer

497
00:26:03,399 --> 00:26:10,370
which one is safe which one is not safe

498
00:26:05,870 --> 00:26:13,399
so indeed we find that some of the

499
00:26:10,370 --> 00:26:15,979
conversions are actually exploitable if

500
00:26:13,399 --> 00:26:18,500
they know how they convert input to

501
00:26:15,980 --> 00:26:20,840
another in another values they can

502
00:26:18,500 --> 00:26:23,960
prepare the payload in a very smart way

503
00:26:20,840 --> 00:26:26,840
so that after the conversion it still

504
00:26:23,960 --> 00:26:29,799
has malicious payload and also some

505
00:26:26,840 --> 00:26:33,590
simple computation for example like + 1

506
00:26:29,799 --> 00:26:35,629
x 2 these are if attacker knows that

507
00:26:33,590 --> 00:26:38,149
computation beforehand they also can

508
00:26:35,629 --> 00:26:42,408
prepare this payload so that you can

509
00:26:38,149 --> 00:26:44,989
survive after the computation but we

510
00:26:42,409 --> 00:26:47,720
also find certain complex computations

511
00:26:44,990 --> 00:26:49,789
after the computation they don't they

512
00:26:47,720 --> 00:26:54,610
have no access to generate some

513
00:26:49,789 --> 00:26:59,149
meaningful things so here we have three

514
00:26:54,610 --> 00:27:01,279
exploitable - fairly safe so then we

515
00:26:59,149 --> 00:27:03,289
define it as a decoding frontier

516
00:27:01,279 --> 00:27:05,360
decoding frontier is essentially a

517
00:27:03,289 --> 00:27:08,019
computation that is fairly complex

518
00:27:05,360 --> 00:27:14,600
enough so that after this computation

519
00:27:08,019 --> 00:27:16,190
attackers lost their control so we find

520
00:27:14,600 --> 00:27:18,500
this decoding frontier using a

521
00:27:16,190 --> 00:27:20,720
constraint server and before this

522
00:27:18,500 --> 00:27:23,409
decoding frontier we define the program

523
00:27:20,720 --> 00:27:26,570
space before this decoding frontier has

524
00:27:23,409 --> 00:27:29,990
an exploitable space meaning that in

525
00:27:26,570 --> 00:27:32,570
this space still attacker has much of

526
00:27:29,990 --> 00:27:36,169
control and after this decoding frontier

527
00:27:32,570 --> 00:27:38,870
we say program space data ours in this

528
00:27:36,169 --> 00:27:43,330
space is fairly safe so it's fine to

529
00:27:38,870 --> 00:27:43,330
decode and let it go

530
00:27:45,550 --> 00:27:52,220
so now using these all the answers from

531
00:27:49,070 --> 00:27:54,740
a constraint server we try to enforce

532
00:27:52,220 --> 00:27:58,910
our encoding and decoding scheme using

533
00:27:54,740 --> 00:28:01,070
static analysis so we use LLVM and the

534
00:27:58,910 --> 00:28:03,940
first question here is how we come up

535
00:28:01,070 --> 00:28:07,610
with decoding and encoding sets

536
00:28:03,940 --> 00:28:11,540
essentially means the places we want to

537
00:28:07,610 --> 00:28:14,060
decode the places we want to encode so

538
00:28:11,540 --> 00:28:17,300
as we covered previously encoding set is

539
00:28:14,060 --> 00:28:19,490
a little bit simple so we just encode

540
00:28:17,300 --> 00:28:21,260
every incoming on trust untrusted

541
00:28:19,490 --> 00:28:23,480
sources that library codes for example

542
00:28:21,260 --> 00:28:26,210
like receive from networks read from

543
00:28:23,480 --> 00:28:28,250
untrusted files and the decoding set

544
00:28:26,210 --> 00:28:32,360
here we have a little bit clearer answer

545
00:28:28,250 --> 00:28:34,580
that we decode whenever encoded values

546
00:28:32,360 --> 00:28:38,449
are used so that it will not break any

547
00:28:34,580 --> 00:28:41,179
laser made functionality and here we

548
00:28:38,450 --> 00:28:44,630
have one more further optimization is

549
00:28:41,180 --> 00:28:46,880
that we can decode inputs permanently at

550
00:28:44,630 --> 00:28:48,920
the decoding frontier so after the

551
00:28:46,880 --> 00:28:51,200
decoding frontier the execution is

552
00:28:48,920 --> 00:28:53,930
exactly the same the original program we

553
00:28:51,200 --> 00:29:00,650
don't interfere any execution beyond the

554
00:28:53,930 --> 00:29:02,750
decoding frontier so we use context flow

555
00:29:00,650 --> 00:29:05,630
and feel sensitive static analysis which

556
00:29:02,750 --> 00:29:09,680
is quite very complex to finding these

557
00:29:05,630 --> 00:29:12,530
decoding and encoding sets so this

558
00:29:09,680 --> 00:29:14,000
guarantee p9 execution and resilient

559
00:29:12,530 --> 00:29:18,800
inputs will be processed correctly

560
00:29:14,000 --> 00:29:21,680
without causing any crashes so let me

561
00:29:18,800 --> 00:29:24,020
explain how we instrument we have this

562
00:29:21,680 --> 00:29:28,880
little program it first received some

563
00:29:24,020 --> 00:29:33,020
info from untrusted Network so there is

564
00:29:28,880 --> 00:29:36,080
an untrusted buffer will hold network

565
00:29:33,020 --> 00:29:39,410
data and later we have a predicate that

566
00:29:36,080 --> 00:29:41,720
compared a contents of the buffer with

567
00:29:39,410 --> 00:29:45,580
the constant and later we also have mem

568
00:29:41,720 --> 00:29:50,360
compare function with this

569
00:29:45,580 --> 00:29:51,830
so first right after it gets our data

570
00:29:50,360 --> 00:29:55,129
from the network we just encode the

571
00:29:51,830 --> 00:29:57,800
buffer and the second one when it

572
00:29:55,130 --> 00:29:59,000
compared which is used by the program we

573
00:29:57,800 --> 00:30:02,059
decode these

574
00:29:59,000 --> 00:30:06,710
exact buffer and then the computation

575
00:30:02,059 --> 00:30:11,899
with this constant will be succeed and

576
00:30:06,710 --> 00:30:15,940
also we do decoding at mem copy so this

577
00:30:11,900 --> 00:30:22,820
will make the lesson brain execution

578
00:30:15,940 --> 00:30:24,320
correctly but we find a problem of just

579
00:30:22,820 --> 00:30:26,418
enforcing the things here is another

580
00:30:24,320 --> 00:30:28,820
example we have one more statement

581
00:30:26,419 --> 00:30:32,600
within the predicate which is mem copy

582
00:30:28,820 --> 00:30:35,470
and what it does is put the constant

583
00:30:32,600 --> 00:30:39,340
into the untrusted popper so now we see

584
00:30:35,470 --> 00:30:43,700
what happens in here if we enforce our

585
00:30:39,340 --> 00:30:47,330
instrumentation here at the last line

586
00:30:43,700 --> 00:30:49,610
the mem Cup when compared we can see

587
00:30:47,330 --> 00:30:52,330
that this untrusted popper actually come

588
00:30:49,610 --> 00:30:55,789
from this receive from the network or

589
00:30:52,330 --> 00:31:00,500
this constant so then let's think about

590
00:30:55,789 --> 00:31:02,990
what happened so if we just decode on

591
00:31:00,500 --> 00:31:05,090
trusty popper like a pliantly

592
00:31:02,990 --> 00:31:09,559
then it will break the functionality

593
00:31:05,090 --> 00:31:11,510
when it has the constant constant string

594
00:31:09,559 --> 00:31:13,668
because constant string is not encoded

595
00:31:11,510 --> 00:31:17,270
if we decode it then you will have some

596
00:31:13,669 --> 00:31:22,429
weird values and then the comparison

597
00:31:17,270 --> 00:31:24,650
will result different outcomes but if he

598
00:31:22,429 --> 00:31:27,470
not decode is on trust buffer then he

599
00:31:24,650 --> 00:31:32,679
will break the value it will break the

600
00:31:27,470 --> 00:31:36,049
program when the value is from receive

601
00:31:32,679 --> 00:31:38,659
so here our answer is we also encode the

602
00:31:36,049 --> 00:31:41,299
constant so then now we can see that

603
00:31:38,659 --> 00:31:45,440
decoding blindly untrusted popper will

604
00:31:41,299 --> 00:31:49,490
not break any in any context so this is

605
00:31:45,440 --> 00:31:51,919
how we will change the our

606
00:31:49,490 --> 00:31:54,440
instrumentation so we encode the

607
00:31:51,919 --> 00:31:57,140
constant in the mem copy so in any

608
00:31:54,440 --> 00:31:59,679
context unchurched buffer is always

609
00:31:57,140 --> 00:31:59,679
encoded

610
00:32:01,860 --> 00:32:08,820
so now we come back to these basic

611
00:32:05,519 --> 00:32:10,590
questions that how we come up how we

612
00:32:08,820 --> 00:32:13,850
know all the encoding says all the

613
00:32:10,590 --> 00:32:17,760
decoding sets so now we have more

614
00:32:13,850 --> 00:32:21,000
precise answers we encode in incoming

615
00:32:17,760 --> 00:32:24,960
all untrusted incoming sources and

616
00:32:21,000 --> 00:32:27,149
library calls and we also encode all the

617
00:32:24,960 --> 00:32:32,100
constant they can be written to any of

618
00:32:27,149 --> 00:32:34,110
already encoded buffers and the decoding

619
00:32:32,100 --> 00:32:36,840
is the same answer we decode when the

620
00:32:34,110 --> 00:32:38,580
encoded values are used and one more

621
00:32:36,840 --> 00:32:44,519
optimization is we can decode

622
00:32:38,580 --> 00:32:47,490
permanently at the decoding frontier so

623
00:32:44,519 --> 00:32:50,279
now I will show a little example of how

624
00:32:47,490 --> 00:32:53,760
we prevent our opiate X essentially ROP

625
00:32:50,279 --> 00:32:57,240
attacks is you corrupt the stacks and

626
00:32:53,760 --> 00:33:02,760
you corrupt return address of the in the

627
00:32:57,240 --> 00:33:06,210
stack so that actor is exploited then

628
00:33:02,760 --> 00:33:11,100
your control flow will go somewhere that

629
00:33:06,210 --> 00:33:15,169
attacker wants to go so here we have a

630
00:33:11,100 --> 00:33:18,510
local variable as the size is 255 and

631
00:33:15,169 --> 00:33:20,880
there is a loop and within the loop

632
00:33:18,510 --> 00:33:26,600
there is a function that returns a

633
00:33:20,880 --> 00:33:30,240
string and this string is which is TMP

634
00:33:26,600 --> 00:33:32,340
can be controlled by the attacker and as

635
00:33:30,240 --> 00:33:35,549
you can see right next line we have a

636
00:33:32,340 --> 00:33:38,549
predicate and it's used it's compared

637
00:33:35,549 --> 00:33:42,470
with the constant so that to guarantee

638
00:33:38,549 --> 00:33:49,559
the correct execution we decode here and

639
00:33:42,470 --> 00:33:53,010
the next line is a like STR CA T means

640
00:33:49,559 --> 00:33:55,080
that concatenation of the string because

641
00:33:53,010 --> 00:33:57,750
this one is copy operation we do not

642
00:33:55,080 --> 00:34:02,360
decode the TMP and now we see what

643
00:33:57,750 --> 00:34:05,639
happens when it when it is exploited

644
00:34:02,360 --> 00:34:09,569
here is Rob Gossett that is injected

645
00:34:05,639 --> 00:34:13,139
into the system essentially Rob Gossett

646
00:34:09,570 --> 00:34:15,030
is on address that points to somewhere

647
00:34:13,139 --> 00:34:16,950
in your program that

648
00:34:15,030 --> 00:34:20,419
that holds some meaningful instruction

649
00:34:16,949 --> 00:34:23,580
and as well else the return instruction

650
00:34:20,418 --> 00:34:26,929
so we can see here the first rough-cut

651
00:34:23,580 --> 00:34:29,340
it points to a move instruction and also

652
00:34:26,929 --> 00:34:31,770
return instruction is just followed and

653
00:34:29,340 --> 00:34:34,409
there is another rob Gossett another

654
00:34:31,770 --> 00:34:37,650
move instruction and also return so

655
00:34:34,409 --> 00:34:41,340
simply we also do XOR operation on this

656
00:34:37,650 --> 00:34:43,350
guy and then we get this as you can see

657
00:34:41,340 --> 00:34:45,690
the addresses is totally different and

658
00:34:43,350 --> 00:34:48,900
it doesn't even points to valid

659
00:34:45,690 --> 00:34:51,540
addresses so as soon as this one is

660
00:34:48,900 --> 00:34:54,179
exploited and try to execute this rob

661
00:34:51,540 --> 00:34:57,180
Gossett it will just jump to somewhere

662
00:34:54,179 --> 00:35:03,740
random addresses and will fail will

663
00:34:57,180 --> 00:35:11,190
crash the program so now I will show

664
00:35:03,740 --> 00:35:14,759
some of the variation Richard and this

665
00:35:11,190 --> 00:35:18,780
is the performance crap of our a to see

666
00:35:14,760 --> 00:35:21,800
and we evaluate first 18 vulnerable

667
00:35:18,780 --> 00:35:25,230
applications and we use fairly a large

668
00:35:21,800 --> 00:35:29,880
inputs to test and as you can see here

669
00:35:25,230 --> 00:35:32,100
we have around like 6.6 percent of the

670
00:35:29,880 --> 00:35:34,410
overhead and some of the program we have

671
00:35:32,100 --> 00:35:37,110
a little bit more operate close to 10%

672
00:35:34,410 --> 00:35:40,410
which is like a patch or some XML

673
00:35:37,110 --> 00:35:43,410
parsers these applications that has a

674
00:35:40,410 --> 00:35:46,859
lot of intense operation on inputs we

675
00:35:43,410 --> 00:35:51,060
because we decode more it has a little

676
00:35:46,860 --> 00:35:52,980
bit more overhead and this is the

677
00:35:51,060 --> 00:35:56,580
performance evaluation from the spec

678
00:35:52,980 --> 00:36:00,300
2006 we get a little bit worse we has

679
00:35:56,580 --> 00:36:03,779
around we have around like 8% of the

680
00:36:00,300 --> 00:36:07,680
overhead and there is one program which

681
00:36:03,780 --> 00:36:10,500
is like over 14 is a per bench so we

682
00:36:07,680 --> 00:36:13,319
found found that if the program actually

683
00:36:10,500 --> 00:36:16,700
used input all over its execution then

684
00:36:13,320 --> 00:36:19,230
it actually disrupt much more like a

685
00:36:16,700 --> 00:36:22,140
computation during the co execution and

686
00:36:19,230 --> 00:36:26,700
we also see some of the programs like MC

687
00:36:22,140 --> 00:36:28,970
F or leave quantum these are very fast

688
00:36:26,700 --> 00:36:33,680
because and then we analyze

689
00:36:28,970 --> 00:36:35,689
why and we saw that these programs first

690
00:36:33,680 --> 00:36:38,149
they read the input and they transform

691
00:36:35,690 --> 00:36:40,520
all of them into some primitive values

692
00:36:38,150 --> 00:36:43,130
and then later they do hold a lot of

693
00:36:40,520 --> 00:36:45,500
computation without obsessing original

694
00:36:43,130 --> 00:36:49,070
inputs at all so essentially they have

695
00:36:45,500 --> 00:36:50,990
very like a thin layer of processing

696
00:36:49,070 --> 00:36:55,700
inputs and converting inputs so that

697
00:36:50,990 --> 00:36:59,509
attacker cannot exploit right like a

698
00:36:55,700 --> 00:37:03,859
very few steps of the execution and then

699
00:36:59,510 --> 00:37:06,140
a whole other executions are like just

700
00:37:03,859 --> 00:37:13,009
fewer computation after the input

701
00:37:06,140 --> 00:37:17,529
processing and we also evaluate

702
00:37:13,010 --> 00:37:20,869
effectiveness of of our tool so we

703
00:37:17,530 --> 00:37:26,420
tested 23 different exploit on 18

704
00:37:20,869 --> 00:37:31,070
programs and we prepare 100 palos 50 is

705
00:37:26,420 --> 00:37:34,270
a shellcode 50s our rob Gossett for each

706
00:37:31,070 --> 00:37:39,920
program any run and see what happens and

707
00:37:34,270 --> 00:37:42,980
we just apply XOR with a a on these

708
00:37:39,920 --> 00:37:46,820
malicious payload and we found that for

709
00:37:42,980 --> 00:37:51,010
the shellcode which is a sequence

710
00:37:46,820 --> 00:37:54,200
sequence of the hex code represent to

711
00:37:51,010 --> 00:37:57,260
representing these x86 instructions for

712
00:37:54,200 --> 00:37:59,919
these kind of payloads we see that after

713
00:37:57,260 --> 00:38:02,630
our computation after our mutation only

714
00:37:59,920 --> 00:38:05,810
three or full instruction can be

715
00:38:02,630 --> 00:38:08,780
executed but something very important to

716
00:38:05,810 --> 00:38:11,060
say is that even though they can execute

717
00:38:08,780 --> 00:38:14,859
three or four instructions these are

718
00:38:11,060 --> 00:38:18,339
very different from what they are like

719
00:38:14,859 --> 00:38:22,160
what the attacker really wants that

720
00:38:18,339 --> 00:38:24,500
wants to execute as we saw in the first

721
00:38:22,160 --> 00:38:26,359
few slides we saw that the first one was

722
00:38:24,500 --> 00:38:28,099
XOR EAX EBX

723
00:38:26,359 --> 00:38:30,740
that's what the attacker wants to

724
00:38:28,099 --> 00:38:33,800
execute but after the mutation we see

725
00:38:30,740 --> 00:38:36,348
like F wait about the floating-point

726
00:38:33,800 --> 00:38:40,580
computation which attacker has no idea

727
00:38:36,349 --> 00:38:42,319
what they want to do so and also we

728
00:38:40,580 --> 00:38:47,140
evaluate one

729
00:38:42,319 --> 00:38:50,719
of rock artists and we saw we see only

730
00:38:47,140 --> 00:39:03,219
0.1 average number of blockages are

731
00:38:50,719 --> 00:39:07,219
executed and this is the richer sure

732
00:39:03,219 --> 00:39:11,930
yeah so in this you are doing XOR with

733
00:39:07,219 --> 00:39:13,880
zero with a next is that is there any

734
00:39:11,930 --> 00:39:17,328
particular reason because if you are

735
00:39:13,880 --> 00:39:19,279
fixing that value then attacker knows

736
00:39:17,329 --> 00:39:21,529
that this is a job where you are really

737
00:39:19,279 --> 00:39:22,489
using and they can exploit that sure

738
00:39:21,529 --> 00:39:27,979
sure

739
00:39:22,489 --> 00:39:30,949
this I just pick X like a a a just for

740
00:39:27,979 --> 00:39:32,959
the right for the sake of presentation

741
00:39:30,949 --> 00:39:37,940
actually we are having a lot of

742
00:39:32,959 --> 00:39:40,129
different like like keys and essentially

743
00:39:37,940 --> 00:39:43,069
we are using like one-time pad encoding

744
00:39:40,130 --> 00:39:46,789
so we prepare punch or punch of a

745
00:39:43,069 --> 00:39:48,650
one-time pad like encoding case before

746
00:39:46,789 --> 00:39:51,680
the execution and then during the long

747
00:39:48,650 --> 00:39:54,799
time actually we pick randomly one of

748
00:39:51,680 --> 00:39:59,779
them so right actually we will also

749
00:39:54,799 --> 00:40:03,949
cover at later like a slice as uh right

750
00:39:59,779 --> 00:40:08,089
there was actually a quite a big problem

751
00:40:03,949 --> 00:40:11,140
right a critical question for this paper

752
00:40:08,089 --> 00:40:11,140
for a long time

753
00:40:14,390 --> 00:40:21,859
so here is the variation on our decoding

754
00:40:17,420 --> 00:40:24,590
frontier computation right we look all

755
00:40:21,860 --> 00:40:26,870
the decoding frontier computation from

756
00:40:24,590 --> 00:40:30,280
the constraint servers and then we found

757
00:40:26,870 --> 00:40:34,640
that among these all the test state

758
00:40:30,280 --> 00:40:41,030
computations using constraint server 71

759
00:40:34,640 --> 00:40:43,970
percent that we questioned were indeed a

760
00:40:41,030 --> 00:40:47,450
decoding frontier means that in the

761
00:40:43,970 --> 00:40:49,279
program's actually we have more complex

762
00:40:47,450 --> 00:40:51,740
computations so that we can forget about

763
00:40:49,280 --> 00:40:55,190
the security after this computation and

764
00:40:51,740 --> 00:40:58,819
only 29% is controllable so that means

765
00:40:55,190 --> 00:41:01,550
that we need to track the inputs further

766
00:40:58,820 --> 00:41:05,540
at that point to see we're decoding

767
00:41:01,550 --> 00:41:09,920
frontier so this echoes our assumptions

768
00:41:05,540 --> 00:41:12,230
that exploit space is quite small so it

769
00:41:09,920 --> 00:41:14,750
means that inputs are quickly parsed and

770
00:41:12,230 --> 00:41:18,860
do not usually propagate deeply into a

771
00:41:14,750 --> 00:41:24,470
program so because the exploits space is

772
00:41:18,860 --> 00:41:27,290
not huge our like performance is quite

773
00:41:24,470 --> 00:41:34,040
not bad quite good we achieve quite good

774
00:41:27,290 --> 00:41:37,550
overhead so here is some discussions on

775
00:41:34,040 --> 00:41:40,279
our limitation so we can also think

776
00:41:37,550 --> 00:41:42,610
think about attacks in post exploit

777
00:41:40,280 --> 00:41:45,140
spaces even though I argue a lot about

778
00:41:42,610 --> 00:41:49,600
after decoding frontier is safe we are

779
00:41:45,140 --> 00:41:52,430
fine but because we are using the

780
00:41:49,600 --> 00:41:56,180
payload pools that we collected here and

781
00:41:52,430 --> 00:41:58,850
there and also right because we are

782
00:41:56,180 --> 00:42:01,850
using this large pool or payload we

783
00:41:58,850 --> 00:42:07,339
collected if an attacker come up with a

784
00:42:01,850 --> 00:42:10,640
very smart way to very different from

785
00:42:07,340 --> 00:42:12,560
what we have seen how they the way of

786
00:42:10,640 --> 00:42:15,140
constructing the shellcode then maybe

787
00:42:12,560 --> 00:42:19,310
our constraints or BER computation is

788
00:42:15,140 --> 00:42:23,330
incorrect and also it is we are when we

789
00:42:19,310 --> 00:42:27,569
are testing we are testing of 16 bytes

790
00:42:23,330 --> 00:42:31,680
because we think that is fairly as

791
00:42:27,569 --> 00:42:34,400
more size of the shellcode but if

792
00:42:31,680 --> 00:42:38,609
attacker can construct very powerful

793
00:42:34,400 --> 00:42:42,690
attacks less than 16 byte we may be in

794
00:42:38,609 --> 00:42:46,288
trouble and the other one is just the

795
00:42:42,690 --> 00:42:48,479
question asked is about the memory

796
00:42:46,289 --> 00:42:51,390
disclosure so let's say if an attacker

797
00:42:48,479 --> 00:42:53,578
can access all my memory data and they

798
00:42:51,390 --> 00:42:55,469
can even know what I'm doing they can

799
00:42:53,579 --> 00:42:58,799
even know what kind of encoding key what

800
00:42:55,469 --> 00:43:01,229
I have used for example by leaking the

801
00:42:58,799 --> 00:43:04,410
previous popper encoded several times

802
00:43:01,229 --> 00:43:06,479
maybe you know what I'm you you can

803
00:43:04,410 --> 00:43:08,190
infer what what kind of key that I have

804
00:43:06,479 --> 00:43:10,979
used to encode the popper because the

805
00:43:08,190 --> 00:43:14,609
attacker knows what data they sent it

806
00:43:10,979 --> 00:43:19,439
and then attacker also can now see how

807
00:43:14,609 --> 00:43:21,719
it is to encode it so the thing is

808
00:43:19,440 --> 00:43:24,239
because we are using a different

809
00:43:21,719 --> 00:43:27,089
dictionary different encoding key every

810
00:43:24,239 --> 00:43:29,309
time we get a new input knowing the

811
00:43:27,089 --> 00:43:33,299
previous encoding key does not help you

812
00:43:29,309 --> 00:43:35,369
to attack next time because you don't

813
00:43:33,299 --> 00:43:42,329
know what what kind of key we were gonna

814
00:43:35,369 --> 00:43:46,229
pick so we have a lot of a lot of

815
00:43:42,329 --> 00:43:49,019
related works it has a bunch of bunch of

816
00:43:46,229 --> 00:43:52,140
CFI it is several years and also

817
00:43:49,019 --> 00:43:54,808
malicious payload detections a lot of

818
00:43:52,140 --> 00:43:57,029
address randomization and a lot of

819
00:43:54,809 --> 00:44:04,680
bounds checking and these are all great

820
00:43:57,029 --> 00:44:07,319
tools the key point of our solution is

821
00:44:04,680 --> 00:44:09,808
we are trying to attack a different

822
00:44:07,319 --> 00:44:12,180
perspective for example CFI try to focus

823
00:44:09,809 --> 00:44:14,430
on the control flow they need to enforce

824
00:44:12,180 --> 00:44:17,190
they want to enforce whether the program

825
00:44:14,430 --> 00:44:19,198
goes the right way and marwah payload

826
00:44:17,190 --> 00:44:20,719
detection they use machine learnings and

827
00:44:19,199 --> 00:44:25,410
try to see the patterns and

828
00:44:20,719 --> 00:44:27,599
randomization they need to disrupt these

829
00:44:25,410 --> 00:44:29,910
address spaces so that attacker if

830
00:44:27,599 --> 00:44:33,329
attacker has some strong assumption on

831
00:44:29,910 --> 00:44:35,359
the layout and they cannot read out this

832
00:44:33,329 --> 00:44:41,220
address randomization they cannot

833
00:44:35,359 --> 00:44:43,680
prepare the payload we are essentially

834
00:44:41,220 --> 00:44:47,098
trying to attack on the different

835
00:44:43,680 --> 00:44:50,310
perspective which is from the data so

836
00:44:47,099 --> 00:44:53,730
what we are doing is we encode all the

837
00:44:50,310 --> 00:44:55,529
inputs and then try to decode at when

838
00:44:53,730 --> 00:44:58,109
the program is lazy main you want to use

839
00:44:55,530 --> 00:45:01,290
these guys and then we decode but we

840
00:44:58,109 --> 00:45:04,619
think that most of attacks happens they

841
00:45:01,290 --> 00:45:08,190
break the Assumption break the intention

842
00:45:04,619 --> 00:45:11,940
of the original program so we are

843
00:45:08,190 --> 00:45:17,640
attacking dead points so here is the

844
00:45:11,940 --> 00:45:21,960
conclusion of our talk we provide a

845
00:45:17,640 --> 00:45:23,819
represent a to see which is which

846
00:45:21,960 --> 00:45:25,710
provides a general protection against

847
00:45:23,819 --> 00:45:27,750
the wide spectrum of payload the

848
00:45:25,710 --> 00:45:30,990
injection attacks even maybe we can

849
00:45:27,750 --> 00:45:35,069
prevent some unknown attack surfaces and

850
00:45:30,990 --> 00:45:39,149
the way we do is we encode all inputs

851
00:45:35,069 --> 00:45:43,670
from untrusted sources and then we

852
00:45:39,150 --> 00:45:48,510
decode right before when they are used

853
00:45:43,670 --> 00:45:51,180
so that we can correctly guarantee the

854
00:45:48,510 --> 00:45:54,329
executions but we break malicious

855
00:45:51,180 --> 00:45:59,368
payload because it does not go where the

856
00:45:54,329 --> 00:46:01,980
program intended to use and we also

857
00:45:59,369 --> 00:46:09,510
prevent payload injection with a fairly

858
00:46:01,980 --> 00:46:13,740
low overhead around 7% thanks for

859
00:46:09,510 --> 00:46:17,810
listening and this is the end of the

860
00:46:13,740 --> 00:46:23,770
talk and if you have any questions

861
00:46:17,810 --> 00:46:23,770
[Applause]

862
00:46:25,020 --> 00:46:34,090
okay so let me start then continuing

863
00:46:32,170 --> 00:46:36,760
from what he asked and you actually that

864
00:46:34,090 --> 00:46:38,890
showed our the luring team so you assume

865
00:46:36,760 --> 00:46:40,960
that there you keep on changing keys but

866
00:46:38,890 --> 00:46:42,940
you know for the one-time pad the key

867
00:46:40,960 --> 00:46:45,790
challenge is that the more you use it

868
00:46:42,940 --> 00:46:47,770
you should not reuse the key so they

869
00:46:45,790 --> 00:46:50,290
took a speck what if somebody decide to

870
00:46:47,770 --> 00:46:51,550
reverse engineer your program then they

871
00:46:50,290 --> 00:46:54,070
will be able to know what is the next

872
00:46:51,550 --> 00:46:56,680
key that you're going to use okay let's

873
00:46:54,070 --> 00:46:59,500
say you using that adversarial access to

874
00:46:56,680 --> 00:47:01,930
the copy of the program and then you can

875
00:46:59,500 --> 00:47:03,550
reverse engineer possibly to find out

876
00:47:01,930 --> 00:47:06,250
what what is the next is that getting

877
00:47:03,550 --> 00:47:08,230
used okay and the second thing is even

878
00:47:06,250 --> 00:47:11,230
in that let's see if that's not allowed

879
00:47:08,230 --> 00:47:13,000
to the adversary you are going to there

880
00:47:11,230 --> 00:47:16,060
is only this much key that you can store

881
00:47:13,000 --> 00:47:19,480
after let's say using running this

882
00:47:16,060 --> 00:47:21,670
program for 1 million times then you are

883
00:47:19,480 --> 00:47:23,470
exhausted the way that is available to

884
00:47:21,670 --> 00:47:25,150
you and your going to use back again the

885
00:47:23,470 --> 00:47:29,439
key that is used for the first time

886
00:47:25,150 --> 00:47:36,580
that's true so any thoughts on both any

887
00:47:29,440 --> 00:47:38,800
of this question right I would say like

888
00:47:36,580 --> 00:47:41,140
in practice is difficult to actually

889
00:47:38,800 --> 00:47:43,720
predict like a random generator how they

890
00:47:41,140 --> 00:47:47,279
make a cave the random I mean how the

891
00:47:43,720 --> 00:47:50,740
random generator returns numbers maybe

892
00:47:47,280 --> 00:47:53,530
right maybe we can use better random

893
00:47:50,740 --> 00:47:55,779
generator so that is it will make the

894
00:47:53,530 --> 00:47:58,480
maker guessing the next input

895
00:47:55,780 --> 00:48:01,420
different I mean difficult and you're

896
00:47:58,480 --> 00:48:04,150
another one is because we have I mean

897
00:48:01,420 --> 00:48:06,640
ideally we can have the infinite number

898
00:48:04,150 --> 00:48:08,500
of like one-time pad but of course in

899
00:48:06,640 --> 00:48:13,299
practice is impossible so we need to

900
00:48:08,500 --> 00:48:17,550
store some like a concrete number of

901
00:48:13,300 --> 00:48:20,200
things so maybe I think is a good way to

902
00:48:17,550 --> 00:48:22,270
enhance the security of in this case is

903
00:48:20,200 --> 00:48:26,919
maybe we can like a restart the program

904
00:48:22,270 --> 00:48:30,580
or right time to time so that right

905
00:48:26,920 --> 00:48:32,680
after a few like a few hours maybe right

906
00:48:30,580 --> 00:48:37,509
you can repress your OD

907
00:48:32,680 --> 00:48:40,000
right one-time pad so that let's say on

908
00:48:37,510 --> 00:48:42,850
attacker like a guess an idea in like

909
00:48:40,000 --> 00:48:44,680
this morning and they have analyzed and

910
00:48:42,850 --> 00:48:46,270
they come up with a nice idea and try to

911
00:48:44,680 --> 00:48:50,140
attack on the afternoon and then now

912
00:48:46,270 --> 00:48:55,140
they see whole different system I think

913
00:48:50,140 --> 00:48:55,140
that one can be very easily done

914
00:49:13,400 --> 00:49:15,460
you

