1
00:00:03,250 --> 00:00:07,509
enjoyed that so we're going to move on

2
00:00:05,590 --> 00:00:09,400
and try to get ourselves back on

3
00:00:07,509 --> 00:00:10,150
schedule so we can continue on with the

4
00:00:09,400 --> 00:00:13,059
rest of the day

5
00:00:10,150 --> 00:00:14,980
and I'd like to introduce our next Tech

6
00:00:13,059 --> 00:00:16,750
Talk which is Professor Jeremiah blocky

7
00:00:14,980 --> 00:00:19,450
also from computer science department

8
00:00:16,750 --> 00:00:33,280
and I'll just turn the mic over to him

9
00:00:19,450 --> 00:00:35,829
an interest of time and let him go there

10
00:00:33,280 --> 00:00:36,879
we go all right all right now everyone

11
00:00:35,829 --> 00:00:40,570
can hear me all right

12
00:00:36,879 --> 00:00:42,099
so I think I'm a new professor here at

13
00:00:40,570 --> 00:00:44,800
in the computer science department at

14
00:00:42,100 --> 00:00:46,749
Purdue excited to tell you today about

15
00:00:44,800 --> 00:00:51,788
memory hard functions in their

16
00:00:46,749 --> 00:00:53,979
application to password hashing so as a

17
00:00:51,789 --> 00:00:57,639
motivating example let's think about how

18
00:00:53,979 --> 00:01:00,248
passwords are stored online so suppose

19
00:00:57,639 --> 00:01:02,249
that you register for an account here

20
00:01:00,249 --> 00:01:05,470
I'm registering for an account

21
00:01:02,249 --> 00:01:07,900
PlayStation comm with the password one

22
00:01:05,470 --> 00:01:10,570
two three four five six okay that's not

23
00:01:07,900 --> 00:01:13,050
my actual password but for example we're

24
00:01:10,570 --> 00:01:16,570
go we'll go with it so what does

25
00:01:13,050 --> 00:01:18,580
playstation store on their server well

26
00:01:16,570 --> 00:01:21,220
as the example shows playstation is

27
00:01:18,580 --> 00:01:26,890
going to store a record that includes my

28
00:01:21,220 --> 00:01:30,880
username a salt value and a garbled hash

29
00:01:26,890 --> 00:01:32,710
value so this garbled hash value is

30
00:01:30,880 --> 00:01:35,050
computed using a cryptographic hash

31
00:01:32,710 --> 00:01:37,750
function in this example the sha-1 hash

32
00:01:35,050 --> 00:01:39,610
function and this hash function is

33
00:01:37,750 --> 00:01:41,740
applied to my password with the salt

34
00:01:39,610 --> 00:01:43,510
appended to it and they'll store this

35
00:01:41,740 --> 00:01:46,119
random looking string on there on their

36
00:01:43,510 --> 00:01:47,980
server later if I want to authenticate

37
00:01:46,120 --> 00:01:49,870
so I'll send them a username I'll send

38
00:01:47,980 --> 00:01:51,850
them my password again they're going to

39
00:01:49,870 --> 00:01:53,170
regard all my password and just check to

40
00:01:51,850 --> 00:01:55,000
make sure that this garbled string

41
00:01:53,170 --> 00:01:58,210
matches what they've already stored on

42
00:01:55,000 --> 00:02:02,440
the server alright so that sounds like a

43
00:01:58,210 --> 00:02:05,009
nice picture but unfortunately data

44
00:02:02,440 --> 00:02:08,169
breaches occur so sometimes due to

45
00:02:05,010 --> 00:02:10,269
programmer error you know server

46
00:02:08,169 --> 00:02:12,579
misconfigurations an attacker is able to

47
00:02:10,269 --> 00:02:14,980
break into the server and actually steal

48
00:02:12,580 --> 00:02:16,810
this cryptographic cache file and at

49
00:02:14,980 --> 00:02:19,030
this point the hack

50
00:02:16,810 --> 00:02:21,010
I can attempt as many guesses offline as

51
00:02:19,030 --> 00:02:23,319
they they would like there's no way to

52
00:02:21,010 --> 00:02:25,090
rate limit them in particular the

53
00:02:23,319 --> 00:02:28,089
attacker can you know rent time on a

54
00:02:25,090 --> 00:02:30,160
supercomputer he can load a dictionary

55
00:02:28,090 --> 00:02:32,440
of popular password guesses and he can

56
00:02:30,160 --> 00:02:35,019
just hash each password guess one after

57
00:02:32,440 --> 00:02:37,840
one comparing the hash to this hash

58
00:02:35,019 --> 00:02:41,739
record on file and as soon as he finds a

59
00:02:37,840 --> 00:02:44,830
match he's found my password all right

60
00:02:41,739 --> 00:02:46,450
well the defense might seem like might

61
00:02:44,830 --> 00:02:49,950
seem simple don't allow an attacker to

62
00:02:46,450 --> 00:02:52,089
break in and steal this this hash file

63
00:02:49,950 --> 00:02:56,619
unfortunately that seems to be easier

64
00:02:52,090 --> 00:02:58,690
said than done and this is a slide that

65
00:02:56,620 --> 00:03:01,780
my students have affectionately become

66
00:02:58,690 --> 00:03:04,209
referring to as dr. block east wall of

67
00:03:01,780 --> 00:03:09,790
shame hopefully your organization isn't

68
00:03:04,209 --> 00:03:12,610
isn't on here but over time this wall

69
00:03:09,790 --> 00:03:14,470
has grown and grown so I used to be able

70
00:03:12,610 --> 00:03:17,349
to say that breaches have affected

71
00:03:14,470 --> 00:03:18,970
millions of users now we can actually

72
00:03:17,349 --> 00:03:22,238
claim that these breaches have affected

73
00:03:18,970 --> 00:03:27,340
billions of user accounts in particular

74
00:03:22,239 --> 00:03:29,200
Yahoo was breached twice a few years ago

75
00:03:27,340 --> 00:03:33,190
though we only found a found out about

76
00:03:29,200 --> 00:03:36,010
it in 2016 this one breach affected over

77
00:03:33,190 --> 00:03:38,440
a billion user accounts similarly the

78
00:03:36,010 --> 00:03:40,720
breach at Adult Friend Finder affected

79
00:03:38,440 --> 00:03:42,819
about half a billion accounts the

80
00:03:40,720 --> 00:03:45,190
breached out link LinkedIn affected over

81
00:03:42,819 --> 00:03:48,578
a hundred million users so these are

82
00:03:45,190 --> 00:03:51,670
massive wide-scale data breaches all

83
00:03:48,579 --> 00:03:54,760
right so it's a common problem and it's

84
00:03:51,670 --> 00:03:56,950
also a dangerous problem so if you go on

85
00:03:54,760 --> 00:03:59,980
amazon.com right now and search for the

86
00:03:56,950 --> 00:04:02,108
ant liner f9 you'll find this machine

87
00:03:59,980 --> 00:04:04,569
here and here are the steps for the

88
00:04:02,109 --> 00:04:09,120
machine I want to highlight one

89
00:04:04,569 --> 00:04:11,230
particular stat here 14 th per second

90
00:04:09,120 --> 00:04:13,359
now that might seem a little bit

91
00:04:11,230 --> 00:04:16,329
confusing but what the th stands for is

92
00:04:13,359 --> 00:04:20,380
tarah hashes per second so this machine

93
00:04:16,329 --> 00:04:23,169
is able to compute 14 trillion sha-256

94
00:04:20,380 --> 00:04:26,849
hashes per second now this machine is

95
00:04:23,169 --> 00:04:29,229
intended for Bitcoin Bitcoin mining but

96
00:04:26,849 --> 00:04:30,580
for all intents and purposes it could be

97
00:04:29,229 --> 00:04:34,300
adapted to be

98
00:04:30,580 --> 00:04:35,800
for password cracking as well now this

99
00:04:34,300 --> 00:04:38,590
machine is also not terribly expensive

100
00:04:35,800 --> 00:04:40,330
you have two thousand dollars sitting

101
00:04:38,590 --> 00:04:43,349
around you could go on Amazon right now

102
00:04:40,330 --> 00:04:46,300
and buy one

103
00:04:43,349 --> 00:04:48,878
further complicating this problem is the

104
00:04:46,300 --> 00:04:51,219
matter of password selection users are

105
00:04:48,879 --> 00:04:53,650
not known for selecting particularly

106
00:04:51,219 --> 00:04:56,800
strong passwords as this word cloud

107
00:04:53,650 --> 00:04:59,109
might suggest in fact data breaches show

108
00:04:56,800 --> 00:05:01,840
that you know oftentimes the most

109
00:04:59,110 --> 00:05:04,030
popular password usually its password or

110
00:05:01,840 --> 00:05:05,440
one two three four five six or sometimes

111
00:05:04,030 --> 00:05:08,559
if you require numbers and letters

112
00:05:05,440 --> 00:05:10,990
password one often times the most

113
00:05:08,560 --> 00:05:15,340
popular password is used by about 1% of

114
00:05:10,990 --> 00:05:17,469
the population all right so so this

115
00:05:15,340 --> 00:05:20,289
motivates the goal of increasing cost

116
00:05:17,469 --> 00:05:22,750
for the attacker typically it's a good

117
00:05:20,289 --> 00:05:25,960
thing if a cryptographic algorithm can

118
00:05:22,750 --> 00:05:28,090
be executed very quickly on hardware for

119
00:05:25,960 --> 00:05:30,638
password hashing that's not such a great

120
00:05:28,090 --> 00:05:32,679
property if an attacker can try 14

121
00:05:30,639 --> 00:05:34,990
trillion guesses per second he's going

122
00:05:32,680 --> 00:05:38,620
to crack most user accounts in a

123
00:05:34,990 --> 00:05:41,919
fraction of a second so the goal is can

124
00:05:38,620 --> 00:05:45,039
we actually design a function that by

125
00:05:41,919 --> 00:05:47,740
design costs a lot for the attacker to

126
00:05:45,039 --> 00:05:49,419
compute so the attacker can't just sit

127
00:05:47,740 --> 00:05:51,520
there and enumerate through millions or

128
00:05:49,419 --> 00:05:54,339
billions of password guesses can we make

129
00:05:51,520 --> 00:05:56,620
this process expensive so that you know

130
00:05:54,339 --> 00:05:58,750
searching through a large dictionary

131
00:05:56,620 --> 00:06:05,620
becomes economically infeasible for an

132
00:05:58,750 --> 00:06:07,509
attacker all right so well there are one

133
00:06:05,620 --> 00:06:08,889
of the classical approaches to to

134
00:06:07,509 --> 00:06:11,860
addressing this problem it's called hash

135
00:06:08,889 --> 00:06:13,740
iteration and our two popular password

136
00:06:11,860 --> 00:06:18,219
hash functions that take this approach

137
00:06:13,740 --> 00:06:21,669
bcrypt and pbkdf2 that's password-based

138
00:06:18,219 --> 00:06:24,520
key derivation function so bcrypt was

139
00:06:21,669 --> 00:06:27,940
used by Ashley Madison Yahoo and Dropbox

140
00:06:24,520 --> 00:06:29,799
when they got breached and pbkdf2 was

141
00:06:27,940 --> 00:06:32,879
being used by LastPass when they got

142
00:06:29,800 --> 00:06:38,889
breached so just as an example

143
00:06:32,879 --> 00:06:41,020
what does pbkdf2 do so LastPass was

144
00:06:38,889 --> 00:06:43,900
basically iterating the sha-256 hash

145
00:06:41,020 --> 00:06:45,539
function a hundred thousand times

146
00:06:43,900 --> 00:06:48,489
instead of computing this function once

147
00:06:45,540 --> 00:06:50,139
you compute this function and then you'd

148
00:06:48,490 --> 00:06:51,729
garbled the garbled result and then you

149
00:06:50,139 --> 00:06:53,259
garbled the garbled results again and

150
00:06:51,729 --> 00:06:56,110
you repeat a hundred thousand times

151
00:06:53,259 --> 00:06:59,320
until you get some super garbled results

152
00:06:56,110 --> 00:07:02,380
and that's your final final string all

153
00:06:59,320 --> 00:07:05,860
right so this is a hundred thousand shot

154
00:07:02,380 --> 00:07:08,590
256 compilations computations just to

155
00:07:05,860 --> 00:07:11,669
compute the password hash alright that

156
00:07:08,590 --> 00:07:17,049
seems like it might be might be useful

157
00:07:11,669 --> 00:07:18,580
but unfortunately it still doesn't put a

158
00:07:17,050 --> 00:07:23,110
significant dent in the problem in

159
00:07:18,580 --> 00:07:25,300
particular using stats from Bitcoin

160
00:07:23,110 --> 00:07:28,539
mining pools you can estimate that the

161
00:07:25,300 --> 00:07:30,039
cost of computing a billion password

162
00:07:28,539 --> 00:07:32,650
guesses

163
00:07:30,039 --> 00:07:35,860
would be about one dollar on customized

164
00:07:32,650 --> 00:07:39,250
Hardware even after they've iterated

165
00:07:35,860 --> 00:07:41,979
this hash function 100,000 times all

166
00:07:39,250 --> 00:07:45,669
right so this suggests a pretty major

167
00:07:41,979 --> 00:07:47,919
challenge right so over time the cost of

168
00:07:45,669 --> 00:07:51,580
computing hash functions like sha-256

169
00:07:47,919 --> 00:07:54,880
have just dropped dramatically alright

170
00:07:51,580 --> 00:07:56,770
and of course you know you might try to

171
00:07:54,880 --> 00:07:59,289
just okay well let's increase the number

172
00:07:56,770 --> 00:08:01,448
of hash iterations over time well that's

173
00:07:59,289 --> 00:08:02,740
not such a great solution because you

174
00:08:01,449 --> 00:08:05,560
have to be able to compute this function

175
00:08:02,740 --> 00:08:07,090
on a sequential machine and if you

176
00:08:05,560 --> 00:08:10,360
increase the number of patch iterations

177
00:08:07,090 --> 00:08:11,710
you're increasing delay time so you're

178
00:08:10,360 --> 00:08:14,830
increasing the time that a user would

179
00:08:11,710 --> 00:08:19,330
need to wait to to check whether

180
00:08:14,830 --> 00:08:21,448
authentication was successful or not so

181
00:08:19,330 --> 00:08:25,090
you know over time you know positive

182
00:08:21,449 --> 00:08:27,430
sha-256 is dropped dramatically user

183
00:08:25,090 --> 00:08:31,109
patience hasn't been improving much over

184
00:08:27,430 --> 00:08:34,719
time that's seems to be fairly static

185
00:08:31,110 --> 00:08:36,870
alright so so our goal is to develop a

186
00:08:34,719 --> 00:08:39,370
moderately expensive hash function and

187
00:08:36,870 --> 00:08:42,130
we have two seemingly contradictory

188
00:08:39,370 --> 00:08:45,190
goals here we want to function that's

189
00:08:42,130 --> 00:08:47,230
fast on your PC so if you want to

190
00:08:45,190 --> 00:08:48,850
compute this function on your PC you can

191
00:08:47,230 --> 00:08:51,550
compute it in under a second and

192
00:08:48,850 --> 00:08:53,620
authenticate and we also want to have

193
00:08:51,550 --> 00:08:55,810
the property that even if the attacker

194
00:08:53,620 --> 00:08:57,430
can build customized Hardware like an

195
00:08:55,810 --> 00:08:58,989
application-specific integrated

196
00:08:57,430 --> 00:09:00,969
circuit it's still going to be

197
00:08:58,990 --> 00:09:03,160
prohibitively expensive for the attacker

198
00:09:00,970 --> 00:09:07,089
to attempt millions or billions of

199
00:09:03,160 --> 00:09:09,939
password guesses alright that that might

200
00:09:07,089 --> 00:09:13,089
seem like an impossible goal but

201
00:09:09,940 --> 00:09:16,600
fortunately there's one one trick that

202
00:09:13,089 --> 00:09:19,089
we have that that we can use to address

203
00:09:16,600 --> 00:09:21,970
this prop problem and that's a memory

204
00:09:19,089 --> 00:09:24,100
card functions so intuitively a memory

205
00:09:21,970 --> 00:09:26,080
hard function is a function whose

206
00:09:24,100 --> 00:09:29,140
computation costs are dominated by

207
00:09:26,080 --> 00:09:30,880
memory costs so if you think back to top

208
00:09:29,140 --> 00:09:33,310
or base key derivation function where we

209
00:09:30,880 --> 00:09:35,980
are just you know computing sha-256

210
00:09:33,310 --> 00:09:39,880
100,000 times effectively we're locking

211
00:09:35,980 --> 00:09:41,529
up a tiny core on a on a circuit for you

212
00:09:39,880 --> 00:09:44,920
know a fraction of a second to do that

213
00:09:41,529 --> 00:09:48,040
computation if instead we have a

214
00:09:44,920 --> 00:09:50,110
function whose computation requires lots

215
00:09:48,040 --> 00:09:51,939
and lots of memory then we're requiring

216
00:09:50,110 --> 00:09:54,459
the attacker not just to lock up a tiny

217
00:09:51,940 --> 00:09:56,770
core on the circuit but also we're

218
00:09:54,459 --> 00:09:59,859
requiring the attacker to lock up a very

219
00:09:56,770 --> 00:10:03,579
large block of memory and this is

220
00:09:59,860 --> 00:10:05,830
expensive so our goal here is to force

221
00:10:03,580 --> 00:10:07,510
the attacker to lock up large amounts of

222
00:10:05,830 --> 00:10:12,790
memory for the duration of his

223
00:10:07,510 --> 00:10:14,500
computation and this implies that the

224
00:10:12,790 --> 00:10:18,219
function would be expensive even on

225
00:10:14,500 --> 00:10:20,830
customized Hardware you can improve you

226
00:10:18,220 --> 00:10:22,779
know computation of sha-256 on a on a

227
00:10:20,830 --> 00:10:25,150
customized circuit

228
00:10:22,779 --> 00:10:27,339
you can't dramatically improve memory

229
00:10:25,150 --> 00:10:31,510
latency or memory size on a custom

230
00:10:27,339 --> 00:10:33,370
circuit all right so this is the

231
00:10:31,510 --> 00:10:36,580
approach taken by top route hashing

232
00:10:33,370 --> 00:10:39,870
algorithms like f crypt so s crypt was

233
00:10:36,580 --> 00:10:42,279
proposed by first of all back in 2009

234
00:10:39,870 --> 00:10:45,190
unfortunately s crypt is also vulnerable

235
00:10:42,279 --> 00:10:48,990
to side channel attacks what this means

236
00:10:45,190 --> 00:10:51,310
is s crypt accesses vättern

237
00:10:48,990 --> 00:10:53,709
accesses memory in a way that's

238
00:10:51,310 --> 00:10:56,520
dependent on the user's password this

239
00:10:53,709 --> 00:10:59,500
means that if you're running a process

240
00:10:56,520 --> 00:11:00,899
concurrently on on the same computer

241
00:10:59,500 --> 00:11:03,010
while F script is being computed

242
00:11:00,899 --> 00:11:04,899
potentially that memory access pattern

243
00:11:03,010 --> 00:11:06,339
that you can infer it's leaking

244
00:11:04,899 --> 00:11:09,279
sensitive information about the user's

245
00:11:06,339 --> 00:11:10,750
password so this is not a great property

246
00:11:09,279 --> 00:11:15,520
for a password hashing algorithm

247
00:11:10,750 --> 00:11:17,560
to have so that motivates the need for

248
00:11:15,520 --> 00:11:19,960
something called data independent memory

249
00:11:17,560 --> 00:11:22,540
hard functions and basically data

250
00:11:19,960 --> 00:11:23,980
independent memory heart function is a

251
00:11:22,540 --> 00:11:25,390
memory hard function that's not

252
00:11:23,980 --> 00:11:28,380
vulnerable to these side-channel attacks

253
00:11:25,390 --> 00:11:31,780
in particular the memory access pattern

254
00:11:28,380 --> 00:11:33,970
will not depend on the sensitive input

255
00:11:31,780 --> 00:11:36,520
in this case the users password so an

256
00:11:33,970 --> 00:11:37,960
attacker who learns this memory access

257
00:11:36,520 --> 00:11:44,890
pattern won't actually learn any

258
00:11:37,960 --> 00:11:48,280
information about your password ok so a

259
00:11:44,890 --> 00:11:50,230
few years ago there was a competition

260
00:11:48,280 --> 00:11:51,910
called the password hashing competition

261
00:11:50,230 --> 00:11:54,130
and the goal of the password hashing

262
00:11:51,910 --> 00:11:56,520
competition was to create the next

263
00:11:54,130 --> 00:11:59,050
generation password hashing algorithm

264
00:11:56,520 --> 00:12:02,650
and thanks to this competition we now

265
00:11:59,050 --> 00:12:05,199
have a large number of candidates a few

266
00:12:02,650 --> 00:12:07,270
of the prominent ones include Katina a

267
00:12:05,200 --> 00:12:10,080
candidate that received special

268
00:12:07,270 --> 00:12:13,770
recognition from the competition judges

269
00:12:10,080 --> 00:12:16,540
there are a few variants of Katina

270
00:12:13,770 --> 00:12:19,510
dragonfly' double butterfly we're not

271
00:12:16,540 --> 00:12:21,670
going to discuss the differences our

272
00:12:19,510 --> 00:12:25,150
gone to is also a particularly notable

273
00:12:21,670 --> 00:12:28,650
candidate in particular argon 2 won the

274
00:12:25,150 --> 00:12:30,939
competition and argon 2 is a clip

275
00:12:28,650 --> 00:12:34,740
equipped with a data independent mode

276
00:12:30,940 --> 00:12:37,180
called argon 2i which is what the

277
00:12:34,740 --> 00:12:40,420
authors of argon 2 originally

278
00:12:37,180 --> 00:12:42,910
recommended for password hashing they've

279
00:12:40,420 --> 00:12:45,120
changed their recommendations now for

280
00:12:42,910 --> 00:12:47,800
reasons that we'll see later in the talk

281
00:12:45,120 --> 00:12:50,740
and finally some researchers out of

282
00:12:47,800 --> 00:12:53,140
Stanford proposed variant called balloon

283
00:12:50,740 --> 00:12:54,820
hashing which is fairly similar to argon

284
00:12:53,140 --> 00:13:00,189
2 and spirit with a few small

285
00:12:54,820 --> 00:13:02,140
differences alright so this motivates

286
00:13:00,190 --> 00:13:04,120
the question uh you know are these

287
00:13:02,140 --> 00:13:07,780
memory hard functions actually secure do

288
00:13:04,120 --> 00:13:09,790
they actually if you use these memory

289
00:13:07,780 --> 00:13:11,740
card functions for password hashing is

290
00:13:09,790 --> 00:13:14,650
it actually cost prohibitive for an

291
00:13:11,740 --> 00:13:19,510
attacker to you know try millions or

292
00:13:14,650 --> 00:13:21,670
billions of password guesses so before

293
00:13:19,510 --> 00:13:24,350
we answer that question let me formally

294
00:13:21,670 --> 00:13:27,500
introduce what a memory card function is

295
00:13:24,350 --> 00:13:31,779
so here we have an underlying hash

296
00:13:27,500 --> 00:13:34,370
function think of sha-1 sha-256 sha-3

297
00:13:31,779 --> 00:13:37,220
which in our analysis will model as a

298
00:13:34,370 --> 00:13:39,710
random Oracle and we have a directed

299
00:13:37,220 --> 00:13:43,190
acyclic graph G which encodes data

300
00:13:39,710 --> 00:13:44,870
dependencies so to specify a function

301
00:13:43,190 --> 00:13:46,910
all I need to do is specify an

302
00:13:44,870 --> 00:13:50,120
underlying hash function like sha-3 and

303
00:13:46,910 --> 00:13:52,279
a graph G and now the input to the

304
00:13:50,120 --> 00:13:55,400
function is password in the false as

305
00:13:52,279 --> 00:13:57,770
usual and now each node in this graph is

306
00:13:55,400 --> 00:13:59,449
assigned a label the label of the first

307
00:13:57,770 --> 00:14:01,550
node is just the hash of the password in

308
00:13:59,450 --> 00:14:04,430
the fault and the label of an interior

309
00:14:01,550 --> 00:14:05,599
node is just a hash of the labels of its

310
00:14:04,430 --> 00:14:07,579
parents

311
00:14:05,600 --> 00:14:10,339
so this directed acyclic graph tells us

312
00:14:07,580 --> 00:14:12,050
how different values depend on each

313
00:14:10,339 --> 00:14:14,630
other during computation so in

314
00:14:12,050 --> 00:14:16,279
particular to compute label 3 before you

315
00:14:14,630 --> 00:14:19,790
can compute label 3 you first need to

316
00:14:16,279 --> 00:14:21,650
know label 2 and label 1 finally the

317
00:14:19,790 --> 00:14:23,870
output of this graph is just labels the

318
00:14:21,650 --> 00:14:25,670
last node so to compute the output of

319
00:14:23,870 --> 00:14:27,770
the graph you have to compute the value

320
00:14:25,670 --> 00:14:28,969
of this last node to compute the value

321
00:14:27,770 --> 00:14:30,949
of this last node you have to compute

322
00:14:28,970 --> 00:14:33,200
the value of nodes 2 & 3 and then to

323
00:14:30,950 --> 00:14:36,440
compute the values from nodes 3 & 2 you

324
00:14:33,200 --> 00:14:38,089
need to compute the value of node 1 all

325
00:14:36,440 --> 00:14:41,890
right so to think about computing these

326
00:14:38,089 --> 00:14:44,089
functions we can actually introduce the

327
00:14:41,890 --> 00:14:47,360
simplifying abstraction called graft

328
00:14:44,089 --> 00:14:50,089
Ebeling so graph doubling is just a game

329
00:14:47,360 --> 00:14:52,040
played on the graph and in this game

330
00:14:50,089 --> 00:14:55,490
you're allowed to place a table on the

331
00:14:52,040 --> 00:14:58,490
graph at time I if during the previous

332
00:14:55,490 --> 00:15:01,279
round you had troubles on all of ice all

333
00:14:58,490 --> 00:15:03,410
that nodes parents so initially we have

334
00:15:01,279 --> 00:15:06,920
no pebbles on the graph so that means

335
00:15:03,410 --> 00:15:08,719
that we can place a pebble on node 1 and

336
00:15:06,920 --> 00:15:11,329
in the real world this means that we're

337
00:15:08,720 --> 00:15:13,790
computing label 1 and scoring this data

338
00:15:11,330 --> 00:15:16,100
value in memory all right well now that

339
00:15:13,790 --> 00:15:18,650
we have a pebble on node 1 we can place

340
00:15:16,100 --> 00:15:21,589
a pup 1 no 2 because we have a pebble on

341
00:15:18,650 --> 00:15:24,199
its parent so we'll place a couple on

342
00:15:21,589 --> 00:15:26,930
node 2 and keep a pebble on node 1 this

343
00:15:24,200 --> 00:15:30,339
means that we've computed label 2 and

344
00:15:26,930 --> 00:15:33,709
we're scoring labels 1 and 2 in memory

345
00:15:30,339 --> 00:15:36,280
so we can continue continue this process

346
00:15:33,709 --> 00:15:37,790
compute label 3 compute label 4

347
00:15:36,280 --> 00:15:39,829
eventually we play

348
00:15:37,790 --> 00:15:41,870
Table one note 5 and at this point we're

349
00:15:39,830 --> 00:15:45,800
finished

350
00:15:41,870 --> 00:15:47,750
so in fact you know everything I talked

351
00:15:45,800 --> 00:15:51,020
about from here on out is just going to

352
00:15:47,750 --> 00:15:53,330
be in a language of graph bubbling but

353
00:15:51,020 --> 00:15:55,819
don't worry graph doubling is actually

354
00:15:53,330 --> 00:15:59,870
equivalent to computing this memory

355
00:15:55,820 --> 00:16:03,800
heart function so how do we measure the

356
00:15:59,870 --> 00:16:05,960
cost of a peb wing well we use the

357
00:16:03,800 --> 00:16:08,180
notion of cumulative complexity so

358
00:16:05,960 --> 00:16:10,700
cumulative complexity is just the sum

359
00:16:08,180 --> 00:16:13,160
over time of the number of pebbles on

360
00:16:10,700 --> 00:16:15,560
the graph at each point in time all

361
00:16:13,160 --> 00:16:17,420
right so this is telling us how much

362
00:16:15,560 --> 00:16:19,579
space the attacker has to allocate and

363
00:16:17,420 --> 00:16:23,240
how long he has to allocate that space

364
00:16:19,580 --> 00:16:26,630
for and the nice thing about this cost

365
00:16:23,240 --> 00:16:27,920
measure is that it amortizes so if you

366
00:16:26,630 --> 00:16:29,510
know pebble in this graph once

367
00:16:27,920 --> 00:16:32,569
corresponds to checking one password

368
00:16:29,510 --> 00:16:33,950
guess if you want to check two password

369
00:16:32,570 --> 00:16:36,830
guesses you have two pebble this graph

370
00:16:33,950 --> 00:16:39,350
one graph twice and the cost of pebble

371
00:16:36,830 --> 00:16:41,330
is graphed twice is two times the cost

372
00:16:39,350 --> 00:16:42,770
of publicness graph once so that means

373
00:16:41,330 --> 00:16:45,380
that the attacker wants to you know

374
00:16:42,770 --> 00:16:46,939
check 2,000 guesses its costs are a

375
00:16:45,380 --> 00:16:50,900
thousand times the cost of computing

376
00:16:46,940 --> 00:16:53,810
this function once so the cumulative

377
00:16:50,900 --> 00:16:56,150
cost of public this graph in our example

378
00:16:53,810 --> 00:16:57,650
is just seven because at the first point

379
00:16:56,150 --> 00:16:59,180
in time I have one tap on the graph and

380
00:16:57,650 --> 00:17:01,430
two pebbles and one pebble and two

381
00:16:59,180 --> 00:17:06,200
pebbles and one pebble so if I sum these

382
00:17:01,430 --> 00:17:10,069
all up the total cost is is seven all

383
00:17:06,200 --> 00:17:12,410
right so so the goal of designing a

384
00:17:10,069 --> 00:17:15,619
secure memory heart function essentially

385
00:17:12,410 --> 00:17:17,930
boils down to to finding a graph with

386
00:17:15,619 --> 00:17:20,419
two desirable properties so find a graph

387
00:17:17,930 --> 00:17:23,930
G with the property that has constant in

388
00:17:20,420 --> 00:17:27,290
degree and the property that for any

389
00:17:23,930 --> 00:17:30,530
public of G the cost of this tablet

390
00:17:27,290 --> 00:17:33,920
scales as N squared divided by tau for

391
00:17:30,530 --> 00:17:37,220
some small constant tau now why do we

392
00:17:33,920 --> 00:17:41,150
want these properties well the running

393
00:17:37,220 --> 00:17:42,320
time is n times Delta minus one so if we

394
00:17:41,150 --> 00:17:44,150
want to actually compute this function

395
00:17:42,320 --> 00:17:47,419
the running time is n times Delta minus

396
00:17:44,150 --> 00:17:51,650
one so we want the property that this

397
00:17:47,420 --> 00:17:53,960
graph has has small in degree

398
00:17:51,650 --> 00:17:55,520
so that you know this we can actually

399
00:17:53,960 --> 00:17:59,360
compute this function quickly on a

400
00:17:55,520 --> 00:18:00,680
sequential computer we also want the

401
00:17:59,360 --> 00:18:05,179
cumulative cost to be as large as

402
00:18:00,680 --> 00:18:08,780
possible so that we can maximize an

403
00:18:05,180 --> 00:18:11,120
attackers cost right we want this cost

404
00:18:08,780 --> 00:18:13,280
to be as large as N squared because n is

405
00:18:11,120 --> 00:18:15,379
the users running time so within a fixed

406
00:18:13,280 --> 00:18:18,139
running time we want to maximize costs

407
00:18:15,380 --> 00:18:21,110
for the attacker so this is the best we

408
00:18:18,140 --> 00:18:25,250
can hope we can hope for is a quadratic

409
00:18:21,110 --> 00:18:27,199
cost so if if you run for one second the

410
00:18:25,250 --> 00:18:29,060
best you can hope for is cost that scale

411
00:18:27,200 --> 00:18:34,640
quadratically in the in the number of

412
00:18:29,060 --> 00:18:36,590
steps all right and what we can show is

413
00:18:34,640 --> 00:18:38,660
that there's a combinatorial property on

414
00:18:36,590 --> 00:18:41,419
graphs called depth robustness that

415
00:18:38,660 --> 00:18:44,180
fully characterizes secure memory hard

416
00:18:41,420 --> 00:18:46,490
functions in particular depth robustness

417
00:18:44,180 --> 00:18:49,040
is necessary and sufficient for a secure

418
00:18:46,490 --> 00:18:51,080
memory hard function what this means is

419
00:18:49,040 --> 00:18:53,030
that if your graph is not depth robust

420
00:18:51,080 --> 00:18:55,520
there exists an attack on your memory

421
00:18:53,030 --> 00:18:57,110
hard function and if your graph is depth

422
00:18:55,520 --> 00:19:02,030
robust then we can rule out the

423
00:18:57,110 --> 00:19:04,939
possibility of any attack so okay what

424
00:19:02,030 --> 00:19:07,129
is this key property depth robustness

425
00:19:04,940 --> 00:19:10,580
well to define depth robustness

426
00:19:07,130 --> 00:19:13,160
let me introduce its opposite depth

427
00:19:10,580 --> 00:19:16,340
reducibility so we say that a graph is

428
00:19:13,160 --> 00:19:19,100
ET reducible if there's a small subset

429
00:19:16,340 --> 00:19:21,770
of vertices such that by deleting these

430
00:19:19,100 --> 00:19:25,490
vertices the longest pass in the

431
00:19:21,770 --> 00:19:28,040
remaining graph is short so here's an

432
00:19:25,490 --> 00:19:29,780
example of a 1/2 reducible graph that

433
00:19:28,040 --> 00:19:33,080
means that we can reduce we can delete

434
00:19:29,780 --> 00:19:35,450
one vertices from the graph and after

435
00:19:33,080 --> 00:19:38,330
deleting this one vertice the longest

436
00:19:35,450 --> 00:19:41,450
remaining path will have length two so

437
00:19:38,330 --> 00:19:43,850
there's a proof by by inspection delete

438
00:19:41,450 --> 00:19:46,400
the node 3 and clearly any remaining

439
00:19:43,850 --> 00:19:49,699
path in this graph has length 2 so this

440
00:19:46,400 --> 00:19:51,920
graph is 1/2 reducible of course if a

441
00:19:49,700 --> 00:19:57,740
graph is not reducible we say that it's

442
00:19:51,920 --> 00:19:59,870
depth robust so the first theorem that

443
00:19:57,740 --> 00:20:02,990
we've managed to prove is that depth

444
00:19:59,870 --> 00:20:05,209
robustness is a necessary condition for

445
00:20:02,990 --> 00:20:07,159
a secure memory hard function

446
00:20:05,210 --> 00:20:09,020
in particular if your memory heart

447
00:20:07,159 --> 00:20:12,169
function is not based on a depth robust

448
00:20:09,020 --> 00:20:13,879
graph then there is an attack and in

449
00:20:12,169 --> 00:20:16,399
particular the cumulative cost of

450
00:20:13,880 --> 00:20:17,840
publicness graph is not going to be N

451
00:20:16,399 --> 00:20:21,168
squared it's going to be something

452
00:20:17,840 --> 00:20:24,110
smaller so in particular if it's depth

453
00:20:21,169 --> 00:20:26,500
reducible and ie the number of nodes

454
00:20:24,110 --> 00:20:29,178
that you delete is smaller than N and D

455
00:20:26,500 --> 00:20:31,549
length of the longest path in the

456
00:20:29,179 --> 00:20:33,289
remaining graph is smaller than n then

457
00:20:31,549 --> 00:20:34,970
the cost of publicness graph is also

458
00:20:33,289 --> 00:20:38,330
going to be smaller than N squared which

459
00:20:34,970 --> 00:20:42,070
is what we want so if you're an attacker

460
00:20:38,330 --> 00:20:44,090
the natural question is our existing

461
00:20:42,070 --> 00:20:46,549
candidates for memory heart functions

462
00:20:44,090 --> 00:20:51,379
memory heart functions actually based on

463
00:20:46,549 --> 00:20:53,450
depth robust eggs and the answer is one

464
00:20:51,380 --> 00:20:55,370
that's unfortunate but might make an

465
00:20:53,450 --> 00:20:59,630
attacker happy the answer is a

466
00:20:55,370 --> 00:21:02,418
resounding no so we looked at Catina are

467
00:20:59,630 --> 00:21:05,360
gone to both the older version and the

468
00:21:02,419 --> 00:21:07,610
newest version and in every case these

469
00:21:05,360 --> 00:21:10,250
graphs are depth reducible

470
00:21:07,610 --> 00:21:12,139
so in particular argon or Kitaen is

471
00:21:10,250 --> 00:21:15,730
depth reducible and we can find a peb

472
00:21:12,140 --> 00:21:17,899
ling with cost n to the one point six to

473
00:21:15,730 --> 00:21:19,940
the specific number there is not

474
00:21:17,899 --> 00:21:22,129
important but notice that this is much

475
00:21:19,940 --> 00:21:24,039
smaller than N squared which is the cost

476
00:21:22,130 --> 00:21:27,620
that we were hoping for

477
00:21:24,039 --> 00:21:30,169
similarly balloon hashing and the older

478
00:21:27,620 --> 00:21:33,139
version of argon two I they do a little

479
00:21:30,169 --> 00:21:35,960
bit better but the cost is still n to

480
00:21:33,140 --> 00:21:37,970
the one point seven one which is still a

481
00:21:35,960 --> 00:21:39,020
much smaller than N squared the cost

482
00:21:37,970 --> 00:21:43,580
that we were hoping to achieve

483
00:21:39,020 --> 00:21:47,779
and finally argon to I the latest

484
00:21:43,580 --> 00:21:50,360
version of argon to I it's also depth

485
00:21:47,779 --> 00:21:52,940
reducible it's a little bit better than

486
00:21:50,360 --> 00:21:55,250
the old version but so we can still get

487
00:21:52,940 --> 00:21:57,770
an attack with complexity n to the one

488
00:21:55,250 --> 00:22:00,559
point seven seven again much smaller

489
00:21:57,770 --> 00:22:03,230
than N squared the quadratic down that

490
00:22:00,559 --> 00:22:06,049
we were hoping for and I should add

491
00:22:03,230 --> 00:22:08,299
should observe that similar results hold

492
00:22:06,049 --> 00:22:09,950
for most of the other known data

493
00:22:08,299 --> 00:22:14,260
independent memory heart functions that

494
00:22:09,950 --> 00:22:19,040
that have been proposed all right so

495
00:22:14,260 --> 00:22:23,090
that's perhaps a depressing picture but

496
00:22:19,040 --> 00:22:25,909
the news isn't the news isn't all bad

497
00:22:23,090 --> 00:22:28,159
so we now actually have a way to

498
00:22:25,910 --> 00:22:30,530
construct secure memory hard functions

499
00:22:28,160 --> 00:22:32,270
in particular we now know that depth

500
00:22:30,530 --> 00:22:34,850
robustness is not only necessary for

501
00:22:32,270 --> 00:22:38,120
secure memory card functions is also

502
00:22:34,850 --> 00:22:40,310
sufficient so if your graph is eg depth

503
00:22:38,120 --> 00:22:42,860
robust then we can prove that any public

504
00:22:40,310 --> 00:22:46,159
of this graph has cost at least e times

505
00:22:42,860 --> 00:22:49,129
D so if E and D are both you know close

506
00:22:46,160 --> 00:22:51,620
to n then the cumulative cost of your

507
00:22:49,130 --> 00:22:55,190
peb lining is close to N squared all

508
00:22:51,620 --> 00:22:57,649
right in particular this immediately

509
00:22:55,190 --> 00:23:00,590
implies that there exists a constant in

510
00:22:57,650 --> 00:23:03,440
degree graph with cumulative cost that

511
00:23:00,590 --> 00:23:07,399
scales as N squared over log n so not

512
00:23:03,440 --> 00:23:10,880
not perfect but pretty close to N

513
00:23:07,400 --> 00:23:13,820
squared and I should note that the best

514
00:23:10,880 --> 00:23:16,460
previous results due to almond and

515
00:23:13,820 --> 00:23:19,850
Serban echo achieved the bound of N

516
00:23:16,460 --> 00:23:21,770
squared over log to the ten times n now

517
00:23:19,850 --> 00:23:24,219
that's nice in theory but in practice

518
00:23:21,770 --> 00:23:27,560
this log to the ten term is

519
00:23:24,220 --> 00:23:31,090
astronomically large so in practice this

520
00:23:27,560 --> 00:23:34,399
bound is actually not not meaningful and

521
00:23:31,090 --> 00:23:37,220
finally I'll note that so we also have a

522
00:23:34,400 --> 00:23:38,810
matching upper bound so in an asymptotic

523
00:23:37,220 --> 00:23:42,020
sense this is actually the best you can

524
00:23:38,810 --> 00:23:43,610
hope for you can hope to get a memory

525
00:23:42,020 --> 00:23:46,820
hard function that has complexity N

526
00:23:43,610 --> 00:23:48,909
squared over log n but if you demand

527
00:23:46,820 --> 00:23:52,070
that your graph has constant in degree

528
00:23:48,910 --> 00:23:54,790
then you can't really can't do can't do

529
00:23:52,070 --> 00:23:54,790
any better than this

530
00:23:55,490 --> 00:24:03,170
so in in summary some recommendations a

531
00:24:01,000 --> 00:24:05,960
bcrypt and password-based key derivation

532
00:24:03,170 --> 00:24:08,630
function are no longer sufficient for

533
00:24:05,960 --> 00:24:10,280
password hashing so if your organization

534
00:24:08,630 --> 00:24:11,870
is using either of these functions I

535
00:24:10,280 --> 00:24:15,620
would highly recommend upgrading your

536
00:24:11,870 --> 00:24:18,020
password hashing algorithm argon 2i is

537
00:24:15,620 --> 00:24:19,629
an improvement over B crypt and

538
00:24:18,020 --> 00:24:22,460
password-based key derivation function

539
00:24:19,630 --> 00:24:27,950
but as we've seen there's still some

540
00:24:22,460 --> 00:24:30,320
flaws so I should note that in the last

541
00:24:27,950 --> 00:24:32,180
month the authors of argon to have

542
00:24:30,320 --> 00:24:34,730
actually changed their recommendation

543
00:24:32,180 --> 00:24:36,530
so they're no longer recommending the

544
00:24:34,730 --> 00:24:38,540
data independent mode of argon for

545
00:24:36,530 --> 00:24:40,310
password hashing the room they're

546
00:24:38,540 --> 00:24:43,220
recommending a variant called argon to

547
00:24:40,310 --> 00:24:45,080
ID basically what this mode does is it

548
00:24:43,220 --> 00:24:46,850
runs half the time and data independent

549
00:24:45,080 --> 00:24:49,280
mode and then it switches over to data

550
00:24:46,850 --> 00:24:51,709
dependent mode so what this means is

551
00:24:49,280 --> 00:24:53,420
that if there are no side channel

552
00:24:51,710 --> 00:24:56,720
attacks then it resists our public

553
00:24:53,420 --> 00:24:59,900
attack because it runs in data dependent

554
00:24:56,720 --> 00:25:02,390
mode for half the time and if there are

555
00:24:59,900 --> 00:25:06,290
side channel attacks then security

556
00:25:02,390 --> 00:25:07,700
reduces down to argon to I so it kind of

557
00:25:06,290 --> 00:25:09,230
gets the best of both worlds

558
00:25:07,700 --> 00:25:11,870
though it would still be nice to have a

559
00:25:09,230 --> 00:25:17,540
function that's fully data independent

560
00:25:11,870 --> 00:25:19,760
and has complexity close to N squared so

561
00:25:17,540 --> 00:25:22,730
currently the construction we have is

562
00:25:19,760 --> 00:25:24,970
it's theoretical but I believe we're

563
00:25:22,730 --> 00:25:27,710
close to actually producing a practical

564
00:25:24,970 --> 00:25:32,030
candidate for a per memory heart

565
00:25:27,710 --> 00:25:33,740
function with provable security so look

566
00:25:32,030 --> 00:25:37,070
for improvements in the near future

567
00:25:33,740 --> 00:25:41,330
using these tools of depth depth robust

568
00:25:37,070 --> 00:25:43,720
graphs all right so thank you I'll take

569
00:25:41,330 --> 00:25:43,720
any questions

570
00:25:45,430 --> 00:25:50,650
[Music]

571
00:25:51,429 --> 00:25:59,349
I have a quick question are the newer

572
00:25:57,399 --> 00:26:01,330
algorithms you talked about available in

573
00:25:59,349 --> 00:26:04,629
standard software libraries or what is

574
00:26:01,330 --> 00:26:06,339
the status of that yeah argon 2 is is

575
00:26:04,629 --> 00:26:10,330
publicly available if you search for

576
00:26:06,339 --> 00:26:13,178
argon two just on Google you can find

577
00:26:10,330 --> 00:26:15,549
find their library it's being considered

578
00:26:13,179 --> 00:26:18,309
for standardization by the internet

579
00:26:15,549 --> 00:26:21,809
research task force so the libraries

580
00:26:18,309 --> 00:26:25,149
public if you want to use it go for it

581
00:26:21,809 --> 00:26:28,389
like I said I would recommend using

582
00:26:25,149 --> 00:26:29,498
argon to ID because it's kind of the

583
00:26:28,389 --> 00:26:32,529
best of both worlds

584
00:26:29,499 --> 00:26:34,690
if you can resist i channel attacks or

585
00:26:32,529 --> 00:26:36,759
eliminate side-channel attacks then

586
00:26:34,690 --> 00:26:38,200
there's no known attacks and even if

587
00:26:36,759 --> 00:26:40,479
there are side channel attacks that

588
00:26:38,200 --> 00:26:46,509
least as good as argon two I in that in

589
00:26:40,479 --> 00:26:48,580
that case ok professor Bakke thank you

590
00:26:46,509 --> 00:26:49,350
so much for taking time to talk to us

591
00:26:48,580 --> 00:26:53,500
today

592
00:26:49,350 --> 00:26:53,500
[Applause]

593
00:26:58,370 --> 00:27:00,429
you

