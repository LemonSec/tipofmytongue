1
00:00:03,330 --> 00:00:10,049
are a student whether a you are a

2
00:00:05,850 --> 00:00:12,480
student at Purdue Findlay Taylor Valpo

3
00:00:10,049 --> 00:00:16,580
IU or any of the other universities who

4
00:00:12,480 --> 00:00:16,580
have students here hold your hands up

5
00:00:16,640 --> 00:00:22,680
people who are looking to hire students

6
00:00:21,230 --> 00:00:25,320
there they are

7
00:00:22,680 --> 00:00:28,948
yeah some of them are now waving a

8
00:00:25,320 --> 00:00:31,050
little more vigorously all right I'm

9
00:00:28,949 --> 00:00:33,930
students as well if you're a Taylor

10
00:00:31,050 --> 00:00:35,519
University student your professor

11
00:00:33,930 --> 00:00:37,680
professor Stanley wanted me to remind

12
00:00:35,519 --> 00:00:41,549
you that he has eyes in the room

13
00:00:37,680 --> 00:00:43,019
don't embarrass him he didn't really say

14
00:00:41,549 --> 00:00:44,940
that but Danny's a friend so I thought

15
00:00:43,019 --> 00:00:47,280
I'd throw that out with that we'd like

16
00:00:44,940 --> 00:00:51,570
to move along to our next point on our

17
00:00:47,280 --> 00:00:53,430
agenda which is our first panel

18
00:00:51,570 --> 00:00:55,199
discussion of the day so security

19
00:00:53,430 --> 00:00:57,989
through formal methods and secure

20
00:00:55,199 --> 00:01:02,250
architectures the idea for this panel

21
00:00:57,989 --> 00:01:04,378
came up that to two things we were

22
00:01:02,250 --> 00:01:06,570
Raytheon reached out to us and said they

23
00:01:04,379 --> 00:01:07,950
were holding an internal technology

24
00:01:06,570 --> 00:01:10,649
summit want to know if we had anybody

25
00:01:07,950 --> 00:01:12,600
working in the area a few years earlier

26
00:01:10,650 --> 00:01:14,610
one of our partners at the time Rockwell

27
00:01:12,600 --> 00:01:16,559
Collins have said but you guys should be

28
00:01:14,610 --> 00:01:19,020
doing more in this area formal methods

29
00:01:16,560 --> 00:01:20,640
and secure architectures because we're

30
00:01:19,020 --> 00:01:22,860
really interested in this we looked

31
00:01:20,640 --> 00:01:23,910
around and we're doing a little bit but

32
00:01:22,860 --> 00:01:26,370
it will haven't caught on

33
00:01:23,910 --> 00:01:28,020
well when Raytheon called just this last

34
00:01:26,370 --> 00:01:29,460
year and said I do and I said you know I

35
00:01:28,020 --> 00:01:30,479
know we have a few people they're doing

36
00:01:29,460 --> 00:01:31,979
some really cool stuff

37
00:01:30,480 --> 00:01:33,900
but it took the opportunity for me to

38
00:01:31,980 --> 00:01:35,400
blast out to our faculty said hey have

39
00:01:33,900 --> 00:01:37,650
you got to think that something that's

40
00:01:35,400 --> 00:01:40,650
relevant to this space let me know and I

41
00:01:37,650 --> 00:01:43,020
was bombarded by our faculty many of

42
00:01:40,650 --> 00:01:44,460
them new faculty had joined serious and

43
00:01:43,020 --> 00:01:46,408
come to Purdue in just the last two

44
00:01:44,460 --> 00:01:47,940
three years who are doing some

45
00:01:46,409 --> 00:01:49,560
unbelievably really cool things and I

46
00:01:47,940 --> 00:01:51,720
said okay we need to we need to

47
00:01:49,560 --> 00:01:53,760
highlight what we're doing because this

48
00:01:51,720 --> 00:01:55,710
is an emerging area for ourselves but

49
00:01:53,760 --> 00:01:57,990
also is in an area of growing interested

50
00:01:55,710 --> 00:02:00,449
within the industry and if staff had

51
00:01:57,990 --> 00:02:02,158
said it had its highlight it kind of

52
00:02:00,450 --> 00:02:03,299
went away and now people are realizing

53
00:02:02,159 --> 00:02:05,640
there are some lessons to be learned

54
00:02:03,299 --> 00:02:08,640
from formal methods as well so I'm

55
00:02:05,640 --> 00:02:12,709
excited to be an audience member for

56
00:02:08,639 --> 00:02:14,429
this we do have one one disappointment

57
00:02:12,709 --> 00:02:15,780
unfortunately we've all seen on the

58
00:02:14,430 --> 00:02:17,220
television last couple of days that

59
00:02:15,780 --> 00:02:18,840
travel schedules

60
00:02:17,220 --> 00:02:20,250
the airlines have are going through some

61
00:02:18,840 --> 00:02:22,200
difficulties right now so one of our

62
00:02:20,250 --> 00:02:24,600
panelists is not able to join us today

63
00:02:22,200 --> 00:02:26,670
but that will mean that

64
00:02:24,600 --> 00:02:29,820
will Beall give each one of our

65
00:02:26,670 --> 00:02:31,649
panelists an extra 30 seconds do you

66
00:02:29,820 --> 00:02:34,530
present to present your thoughts before

67
00:02:31,650 --> 00:02:36,990
we take Q&A so with that I'd like to

68
00:02:34,530 --> 00:02:39,090
bring up our panel moderator who is one

69
00:02:36,990 --> 00:02:41,610
of these one of these Purdue faculty

70
00:02:39,090 --> 00:02:45,570
members who is working in this area

71
00:02:41,610 --> 00:02:48,410
a Prius fellow a longtime faculty member

72
00:02:45,570 --> 00:02:50,370
and a great friend and one of our

73
00:02:48,410 --> 00:02:56,220
technology leaders within serious

74
00:02:50,370 --> 00:02:57,510
faculty professor Suribachi sorb good

75
00:02:56,220 --> 00:03:00,090
morning to you all

76
00:02:57,510 --> 00:03:02,100
my name is Sora Bakshi I'm the moderator

77
00:03:00,090 --> 00:03:04,680
for this panel which is looking to look

78
00:03:02,100 --> 00:03:07,530
at how do you use formal methods and

79
00:03:04,680 --> 00:03:11,250
secure architecture in the field of

80
00:03:07,530 --> 00:03:14,490
security we have three panelists with us

81
00:03:11,250 --> 00:03:17,460
Ben Delaware Roopa shimanto and Matt

82
00:03:14,490 --> 00:03:19,710
building Ben and Roop char from Purdue

83
00:03:17,460 --> 00:03:22,620
University and matt is from rockwell

84
00:03:19,710 --> 00:03:25,080
collins so I'll give a short bio for

85
00:03:22,620 --> 00:03:28,260
each of our panelists and then kick off

86
00:03:25,080 --> 00:03:30,000
with some opening remarks so Ben

87
00:03:28,260 --> 00:03:34,230
received his PhD in computer science

88
00:03:30,000 --> 00:03:36,540
from UT Austin working with Professor

89
00:03:34,230 --> 00:03:38,310
William cook he then worked as a

90
00:03:36,540 --> 00:03:40,850
research scientist in the programming

91
00:03:38,310 --> 00:03:43,950
languages and verification group at MIT

92
00:03:40,850 --> 00:03:45,720
until fall 2016 when we were very happy

93
00:03:43,950 --> 00:03:48,750
to have him join us here as an assistant

94
00:03:45,720 --> 00:03:50,250
professor his research is on the design

95
00:03:48,750 --> 00:03:53,160
and implementation of programming

96
00:03:50,250 --> 00:03:56,040
languages and tools that provide higher

97
00:03:53,160 --> 00:03:59,790
assurance and lower effort through the

98
00:03:56,040 --> 00:04:01,650
use of mechanized theorem provers Roop

99
00:03:59,790 --> 00:04:04,079
Shah isn't also an assistant professor

100
00:04:01,650 --> 00:04:06,989
here at Purdue her research focuses on

101
00:04:04,080 --> 00:04:09,630
building reliable and efficient programs

102
00:04:06,989 --> 00:04:12,840
using formal methods and programming

103
00:04:09,630 --> 00:04:14,970
language principles and her work has had

104
00:04:12,840 --> 00:04:16,709
applications in a wide variety of

105
00:04:14,970 --> 00:04:19,560
domains including concurrent systems

106
00:04:16,709 --> 00:04:22,440
software probabilistic in cyber physical

107
00:04:19,560 --> 00:04:24,660
systems and educational technology for

108
00:04:22,440 --> 00:04:27,570
programming courses she also did her PhD

109
00:04:24,660 --> 00:04:29,760
from UT Austin working with Allen

110
00:04:27,570 --> 00:04:30,930
Emerson and Vijaya Gert and then from

111
00:04:29,760 --> 00:04:32,630
2014 to 20

112
00:04:30,930 --> 00:04:35,789
sixteen she was a postdoctoral

113
00:04:32,630 --> 00:04:39,030
researcher at the Institute of Science

114
00:04:35,789 --> 00:04:40,830
and Technology in Vienna Austria dr.

115
00:04:39,030 --> 00:04:42,859
Matt wildung is a principal research

116
00:04:40,830 --> 00:04:46,349
group manager in the rockwell collins

117
00:04:42,860 --> 00:04:49,080
advanced technology center he received

118
00:04:46,350 --> 00:04:52,020
his PhD in computer science also from UT

119
00:04:49,080 --> 00:04:56,550
Austin for full disclosure I did not

120
00:04:52,020 --> 00:05:00,090
receive my PhD from UT Austin and he

121
00:04:56,550 --> 00:05:02,220
joined rockwell collins in 1996 he has

122
00:05:00,090 --> 00:05:04,109
worked on many high-confidence efforts

123
00:05:02,220 --> 00:05:07,710
such as the machine check formal method

124
00:05:04,110 --> 00:05:09,419
analysis of the am p7 microprocessor

125
00:05:07,710 --> 00:05:12,210
which has been critical to lots of

126
00:05:09,419 --> 00:05:14,639
rockwell collins products he currently

127
00:05:12,210 --> 00:05:17,280
leads the trusted systems research group

128
00:05:14,639 --> 00:05:22,530
which collaborates with various product

129
00:05:17,280 --> 00:05:25,138
groups within rockwell collins so let me

130
00:05:22,530 --> 00:05:27,000
start off by giving you some of my

131
00:05:25,139 --> 00:05:29,009
thoughts I am NOT an expert in the area

132
00:05:27,000 --> 00:05:31,830
of formal methods so I would love to

133
00:05:29,009 --> 00:05:33,930
hear our experts knock down some of the

134
00:05:31,830 --> 00:05:34,409
strom and I have for the use of formal

135
00:05:33,930 --> 00:05:38,030
methods

136
00:05:34,410 --> 00:05:42,449
so basically formal methods to me

137
00:05:38,030 --> 00:05:45,059
enables that you can reason from logical

138
00:05:42,449 --> 00:05:47,400
or mathematical specifications of the

139
00:05:45,060 --> 00:05:51,300
behaviors of computing devices or

140
00:05:47,400 --> 00:05:52,710
processes and if you use it right you

141
00:05:51,300 --> 00:05:57,780
would be able to provide a rigorous

142
00:05:52,710 --> 00:05:59,669
proof for that the system behavior will

143
00:05:57,780 --> 00:06:02,309
meet some desirable properties for

144
00:05:59,669 --> 00:06:05,039
example your program does not crash when

145
00:06:02,310 --> 00:06:07,620
you pass it this set of inputs or your

146
00:06:05,039 --> 00:06:10,590
program terminates under these kinds of

147
00:06:07,620 --> 00:06:12,539
environmental conditions there are lots

148
00:06:10,590 --> 00:06:15,530
of exemplars where formal methods have

149
00:06:12,539 --> 00:06:18,300
found use for example you could think of

150
00:06:15,530 --> 00:06:20,190
contemporary cryptography relying on

151
00:06:18,300 --> 00:06:23,340
formal methods in a broad sense of the

152
00:06:20,190 --> 00:06:25,590
term synthesis of secure programs as

153
00:06:23,340 --> 00:06:27,479
well as these correct by construction

154
00:06:25,590 --> 00:06:32,520
methods for example zero knowledge proof

155
00:06:27,479 --> 00:06:34,560
also use formal methods and the area has

156
00:06:32,520 --> 00:06:36,030
developed a mature set of tools and is

157
00:06:34,560 --> 00:06:39,120
found wide application in various

158
00:06:36,030 --> 00:06:41,539
domains such as verification of Hardware

159
00:06:39,120 --> 00:06:43,760
verification of embedded systems and

160
00:06:41,539 --> 00:06:46,849
testing of software

161
00:06:43,760 --> 00:06:49,070
and what about secure architecture just

162
00:06:46,850 --> 00:06:50,810
like when we start to construct a

163
00:06:49,070 --> 00:06:53,150
building we don't just go off and start

164
00:06:50,810 --> 00:06:54,950
pouring concrete we start off by

165
00:06:53,150 --> 00:06:56,599
creating a blueprint so in a very

166
00:06:54,950 --> 00:06:59,090
simplistic view of the world you could

167
00:06:56,600 --> 00:07:00,830
think of your system first of all you

168
00:06:59,090 --> 00:07:02,750
sit down and define an architecture for

169
00:07:00,830 --> 00:07:05,150
your system then you come up with the

170
00:07:02,750 --> 00:07:06,800
detailed design for your system leading

171
00:07:05,150 --> 00:07:08,719
on to the implementation followed by

172
00:07:06,800 --> 00:07:11,060
testing and verification so the

173
00:07:08,720 --> 00:07:13,160
architecture lets you make explicit what

174
00:07:11,060 --> 00:07:15,230
are the security goals of your system

175
00:07:13,160 --> 00:07:16,730
what is the adversary model that your

176
00:07:15,230 --> 00:07:19,400
system is supposed to be able to

177
00:07:16,730 --> 00:07:21,410
tolerate and it also importantly

178
00:07:19,400 --> 00:07:23,479
illuminates the dependencies that your

179
00:07:21,410 --> 00:07:25,670
system or infrastructure has on other

180
00:07:23,480 --> 00:07:27,620
infrastructures for example what are the

181
00:07:25,670 --> 00:07:29,660
trust relationships between the various

182
00:07:27,620 --> 00:07:31,670
principles you have in your system or

183
00:07:29,660 --> 00:07:33,380
what are the trust relationships between

184
00:07:31,670 --> 00:07:35,390
the various subsystems that you have

185
00:07:33,380 --> 00:07:37,159
that you're relying on what are the

186
00:07:35,390 --> 00:07:40,130
control and data flows that can go

187
00:07:37,160 --> 00:07:41,750
across infrastructures and even on the

188
00:07:40,130 --> 00:07:43,430
personal side of things how would you

189
00:07:41,750 --> 00:07:45,680
allocate personnel for different

190
00:07:43,430 --> 00:07:47,900
subsystems in your overall system

191
00:07:45,680 --> 00:07:49,730
sitting down and thinking about the

192
00:07:47,900 --> 00:07:51,880
architecture of your system hopefully

193
00:07:49,730 --> 00:07:54,650
lets you make these kinds of decisions

194
00:07:51,880 --> 00:07:56,540
so I have one slide on why you would

195
00:07:54,650 --> 00:07:57,890
want to use them for security and then

196
00:07:56,540 --> 00:07:59,900
one slide on why you would absolutely

197
00:07:57,890 --> 00:08:02,090
want to run away from them if you want

198
00:07:59,900 --> 00:08:03,620
to build secure systems and it's in the

199
00:08:02,090 --> 00:08:05,989
second one that I would love to hear

200
00:08:03,620 --> 00:08:08,120
from our panelists how to break down

201
00:08:05,990 --> 00:08:11,240
those Dromund so in terms of formal

202
00:08:08,120 --> 00:08:13,220
methods to me they give you the hope

203
00:08:11,240 --> 00:08:15,440
that you could break out of this

204
00:08:13,220 --> 00:08:17,720
perennial cat-and-mouse game between the

205
00:08:15,440 --> 00:08:19,460
adversaries and the defenders where the

206
00:08:17,720 --> 00:08:21,350
adversaries come up with a new kind of

207
00:08:19,460 --> 00:08:23,419
attack technique you build in a new kind

208
00:08:21,350 --> 00:08:26,630
of a defense technique and this game

209
00:08:23,420 --> 00:08:28,490
goes on and on the side of privacy when

210
00:08:26,630 --> 00:08:31,640
we talk about privacy guarantees too

211
00:08:28,490 --> 00:08:34,159
often we think of it as a very very

212
00:08:31,640 --> 00:08:35,900
fuzzy kind of a concept but when you say

213
00:08:34,159 --> 00:08:37,699
when you say the word guarantee it

214
00:08:35,900 --> 00:08:39,709
really should mean that guarantees and

215
00:08:37,700 --> 00:08:41,720
formal methods if they're properly

216
00:08:39,710 --> 00:08:45,170
applied could help you get toward these

217
00:08:41,720 --> 00:08:47,030
kinds of guarantees and there have been

218
00:08:45,170 --> 00:08:48,860
a very rich set of verification tools

219
00:08:47,030 --> 00:08:51,560
that have been developed that are being

220
00:08:48,860 --> 00:08:53,330
developed so I think the field is coming

221
00:08:51,560 --> 00:08:54,949
to a point or has already come to a

222
00:08:53,330 --> 00:08:57,290
point where it can be applied on real

223
00:08:54,950 --> 00:08:58,639
systems in terms of the secure

224
00:08:57,290 --> 00:09:01,219
textured I think there are certain

225
00:08:58,639 --> 00:09:03,800
fairly solid reasons for why you would

226
00:09:01,220 --> 00:09:06,110
want to use them in building reliable or

227
00:09:03,800 --> 00:09:07,969
secure systems it brings the necessary

228
00:09:06,110 --> 00:09:10,490
rigor to your design process so you

229
00:09:07,970 --> 00:09:13,220
don't just start off by pouring concrete

230
00:09:10,490 --> 00:09:14,750
rather you start off by laying down what

231
00:09:13,220 --> 00:09:16,370
are the design principles that your

232
00:09:14,750 --> 00:09:19,040
design and then your implementation

233
00:09:16,370 --> 00:09:21,110
needs to follow it can importantly help

234
00:09:19,040 --> 00:09:22,790
align the business processes with the

235
00:09:21,110 --> 00:09:25,009
security processes which is oftentimes

236
00:09:22,790 --> 00:09:26,509
the problem in the security world where

237
00:09:25,009 --> 00:09:28,310
you can come up with the best techniques

238
00:09:26,509 --> 00:09:30,529
in the world if it's not adopted within

239
00:09:28,310 --> 00:09:32,989
your enterprise you don't get very far

240
00:09:30,529 --> 00:09:35,449
and it can be a pathway to the

241
00:09:32,990 --> 00:09:37,639
application of formal methods so these

242
00:09:35,449 --> 00:09:39,649
are my high-level thoughts about why you

243
00:09:37,639 --> 00:09:41,360
would want to use them for security and

244
00:09:39,649 --> 00:09:42,980
here are the reasons why you should

245
00:09:41,360 --> 00:09:45,319
absolutely run away from them if you

246
00:09:42,980 --> 00:09:49,399
want to build secure systems and these

247
00:09:45,319 --> 00:09:52,069
are straumann the the easy

248
00:09:49,399 --> 00:09:53,959
these are easy criticisms to level

249
00:09:52,069 --> 00:09:56,389
against formal methods that it needs too

250
00:09:53,959 --> 00:09:58,399
much experience you need a PhD and a

251
00:09:56,389 --> 00:10:02,480
long PhD at that to be able to apply

252
00:09:58,399 --> 00:10:04,550
formal methods the tools often are not

253
00:10:02,480 --> 00:10:06,740
mature enough they work when you apply

254
00:10:04,550 --> 00:10:09,109
them at small scales but they break when

255
00:10:06,740 --> 00:10:11,420
you apply at large scales they give you

256
00:10:09,110 --> 00:10:14,420
too many false positives they cannot

257
00:10:11,420 --> 00:10:16,399
handle dynamic data sources so these are

258
00:10:14,420 --> 00:10:18,800
all the reasons why you really cannot

259
00:10:16,399 --> 00:10:20,149
apply them to real systems and the

260
00:10:18,800 --> 00:10:21,859
single probably the single most

261
00:10:20,149 --> 00:10:24,079
important factor is it lengthens your

262
00:10:21,860 --> 00:10:26,180
development time so it postpones when

263
00:10:24,079 --> 00:10:28,519
you can ship your product in the case of

264
00:10:26,180 --> 00:10:30,160
secure architecture it needs several

265
00:10:28,519 --> 00:10:32,180
people to sit down and talk and

266
00:10:30,160 --> 00:10:34,100
engineers never want to sit down and

267
00:10:32,180 --> 00:10:36,170
talk especially when the payoffs are

268
00:10:34,100 --> 00:10:37,940
very far off into the future why would

269
00:10:36,170 --> 00:10:39,560
we agree on a secure architecture when

270
00:10:37,940 --> 00:10:42,079
we won't actually see the payoff for

271
00:10:39,560 --> 00:10:44,599
five ten years down the line it needs

272
00:10:42,079 --> 00:10:46,489
too much expertise again the security

273
00:10:44,600 --> 00:10:50,389
groups may not always have expertise in

274
00:10:46,490 --> 00:10:52,699
in building secure architectures and the

275
00:10:50,389 --> 00:10:55,519
development time again the same same

276
00:10:52,699 --> 00:10:58,579
argument for not using as not using

277
00:10:55,519 --> 00:11:03,319
formal methods with that I will stop and

278
00:10:58,579 --> 00:11:04,790
I will let our panelists go Ben Delaware

279
00:11:03,319 --> 00:11:08,750
would be the first one who would start

280
00:11:04,790 --> 00:11:10,069
off and then we'll have after all the

281
00:11:08,750 --> 00:11:10,490
panelists are done with their opening

282
00:11:10,069 --> 00:11:12,740
statement

283
00:11:10,490 --> 00:11:17,540
we will have hopefully an interesting

284
00:11:12,740 --> 00:11:19,970
Q&A and discussion session okay there we

285
00:11:17,540 --> 00:11:22,130
go okay right so the prompt was what

286
00:11:19,970 --> 00:11:23,990
what is holding an adoption of formal

287
00:11:22,130 --> 00:11:26,120
methods back in industry and I think the

288
00:11:23,990 --> 00:11:27,649
answer there is was alluded to as you

289
00:11:26,120 --> 00:11:30,380
know the standard argument that the

290
00:11:27,649 --> 00:11:33,110
costs of deploying that you know formal

291
00:11:30,380 --> 00:11:35,000
methods to verify our software outweighs

292
00:11:33,110 --> 00:11:37,250
the benefit or at least this is sort of

293
00:11:35,000 --> 00:11:40,550
been prevailing wisdom for four years

294
00:11:37,250 --> 00:11:42,290
now and so I would argue that the

295
00:11:40,550 --> 00:11:43,520
benefits of formal methods are pretty

296
00:11:42,290 --> 00:11:47,420
clear and I'm going to draw an analogy

297
00:11:43,520 --> 00:11:49,640
here that if you go out to build the

298
00:11:47,420 --> 00:11:51,649
boat right the promise of formal methods

299
00:11:49,640 --> 00:11:53,060
is that we can formally show that this

300
00:11:51,649 --> 00:11:55,070
boat is not going to have any links

301
00:11:53,060 --> 00:11:56,930
leaks in it before we you know throw it

302
00:11:55,070 --> 00:11:58,520
in the water so the common paradigm

303
00:11:56,930 --> 00:12:00,859
right now is you know maybe you have a

304
00:11:58,520 --> 00:12:02,930
blueprint for your boat and you throw

305
00:12:00,860 --> 00:12:04,220
some people at it but you don't have

306
00:12:02,930 --> 00:12:06,260
time to put it in the water you don't

307
00:12:04,220 --> 00:12:08,480
have a proper testing you know a pool

308
00:12:06,260 --> 00:12:10,490
that to test it in so you get a hose out

309
00:12:08,480 --> 00:12:11,990
and you send some you know unlucky

310
00:12:10,490 --> 00:12:14,000
interns to sort of spray some water on

311
00:12:11,990 --> 00:12:15,350
outside of the hole the hole and

312
00:12:14,000 --> 00:12:16,700
hopefully you'll find some leaks long

313
00:12:15,350 --> 00:12:17,720
the way you'll patch them up you'll say

314
00:12:16,700 --> 00:12:20,300
good enough and you'll throw it in the

315
00:12:17,720 --> 00:12:21,920
water and hope the boat doesn't sink and

316
00:12:20,300 --> 00:12:24,380
if you know you just you know discover

317
00:12:21,920 --> 00:12:26,390
any holes along the way when the boats

318
00:12:24,380 --> 00:12:28,730
out to sea well you'll patch and pray

319
00:12:26,390 --> 00:12:30,949
it's a standard approach and what the

320
00:12:28,730 --> 00:12:33,110
promise of formal methods is or the

321
00:12:30,950 --> 00:12:34,660
promised benefit is that no we can

322
00:12:33,110 --> 00:12:36,680
verify once and for all with

323
00:12:34,660 --> 00:12:38,029
mathematical certainty that you put this

324
00:12:36,680 --> 00:12:40,069
boat in the water and it will not have

325
00:12:38,029 --> 00:12:42,500
any holes you've completely reduced it

326
00:12:40,070 --> 00:12:45,320
attack service to someone shooting a

327
00:12:42,500 --> 00:12:47,149
torpedo at it for example okay so this

328
00:12:45,320 --> 00:12:49,459
is the benefit you know high assurance

329
00:12:47,149 --> 00:12:51,440
software of course the costs are pretty

330
00:12:49,459 --> 00:12:53,329
clear - as was also alluded to in the

331
00:12:51,440 --> 00:12:55,070
introduction or at least the perceived

332
00:12:53,329 --> 00:12:57,770
costs are clear so the first of these of

333
00:12:55,070 --> 00:12:59,720
course is that you know not every boat

334
00:12:57,770 --> 00:13:01,310
is worth verifying right you know there

335
00:12:59,720 --> 00:13:03,110
is a lot of effort involved in

336
00:13:01,310 --> 00:13:05,750
developing proofs for these systems and

337
00:13:03,110 --> 00:13:07,370
patching this cheap so if we have a toy

338
00:13:05,750 --> 00:13:09,410
boat and we're going to deploy it in the

339
00:13:07,370 --> 00:13:12,290
put the tub who cares if it springs a

340
00:13:09,410 --> 00:13:14,270
leak you know I you can have the parent

341
00:13:12,290 --> 00:13:15,949
patch it up hopefully the kid might

342
00:13:14,270 --> 00:13:17,990
happily just pull it all the water dump

343
00:13:15,950 --> 00:13:19,339
out dump it out hopefully not on the

344
00:13:17,990 --> 00:13:21,620
floor and then keep playing with it

345
00:13:19,339 --> 00:13:24,140
right so our formal methods really worth

346
00:13:21,620 --> 00:13:27,440
the effort the other

347
00:13:24,140 --> 00:13:28,550
is just the terms of scale right there

348
00:13:27,440 --> 00:13:30,380
have been a lot of concerns about how

349
00:13:28,550 --> 00:13:31,760
these methods scale to realistic systems

350
00:13:30,380 --> 00:13:34,400
and so you're either forced with

351
00:13:31,760 --> 00:13:36,530
reasoning about say 20 programs or you

352
00:13:34,400 --> 00:13:38,000
model the program some sort of blurry

353
00:13:36,530 --> 00:13:40,579
approximation of what you're actually

354
00:13:38,000 --> 00:13:44,080
want to formally verify and show us

355
00:13:40,580 --> 00:13:46,640
secure and now you have a gap between

356
00:13:44,080 --> 00:13:48,200
the model that you have in the software

357
00:13:46,640 --> 00:13:50,390
you deploy and the staff of course is a

358
00:13:48,200 --> 00:13:51,740
convenient attack vector for people so

359
00:13:50,390 --> 00:13:54,260
there's a real question of how we scale

360
00:13:51,740 --> 00:13:57,080
formal methods to what we actually

361
00:13:54,260 --> 00:13:59,780
wanted you know verify or guarantee is

362
00:13:57,080 --> 00:14:00,980
correct and then finally as again this

363
00:13:59,780 --> 00:14:03,140
is one of the big ones that you need

364
00:14:00,980 --> 00:14:05,300
arguably some degree of expertise to use

365
00:14:03,140 --> 00:14:07,040
these systems right you need a PhD in

366
00:14:05,300 --> 00:14:11,209
computer science apparently from UT

367
00:14:07,040 --> 00:14:14,240
Austin in order to work with these work

368
00:14:11,210 --> 00:14:16,460
with these systems okay so I would say

369
00:14:14,240 --> 00:14:17,630
that this perception of costs well you

370
00:14:16,460 --> 00:14:20,060
know realistic is uh

371
00:14:17,630 --> 00:14:21,470
are not as the costs are not as clear as

372
00:14:20,060 --> 00:14:24,650
I've just laid them out they weren't

373
00:14:21,470 --> 00:14:26,030
clear but you know they're medicating

374
00:14:24,650 --> 00:14:28,640
factors that have you know come into

375
00:14:26,030 --> 00:14:30,920
play in the past say five ten years so

376
00:14:28,640 --> 00:14:34,160
on the effort of course

377
00:14:30,920 --> 00:14:36,770
who cares if your web app crashes right

378
00:14:34,160 --> 00:14:38,600
that's okay we can reboot it but what

379
00:14:36,770 --> 00:14:41,030
happens if your car crashes right that's

380
00:14:38,600 --> 00:14:43,550
a little bit more a little bit more

381
00:14:41,030 --> 00:14:45,560
dangerous and patching patching the bug

382
00:14:43,550 --> 00:14:46,969
is not going to you know let the genie

383
00:14:45,560 --> 00:14:49,250
put the genie back in the bottle once

384
00:14:46,970 --> 00:14:51,200
the bugs are out in a while additionally

385
00:14:49,250 --> 00:14:53,060
even for Tory programs if the web app is

386
00:14:51,200 --> 00:14:54,380
connected to other subsystems and say

387
00:14:53,060 --> 00:14:57,290
the internet of things to throw out a

388
00:14:54,380 --> 00:14:59,420
buzz word well we can hack this easily

389
00:14:57,290 --> 00:15:01,160
this web app and have it start sending

390
00:14:59,420 --> 00:15:02,599
carefully-crafted malicious practic

391
00:15:01,160 --> 00:15:03,170
state can bring down your entire house

392
00:15:02,600 --> 00:15:05,360
right

393
00:15:03,170 --> 00:15:08,630
I suspect it's only a matter of time

394
00:15:05,360 --> 00:15:10,220
until we see someone you know send

395
00:15:08,630 --> 00:15:11,689
someone put someone out of house and

396
00:15:10,220 --> 00:15:12,200
home by turning on the nest and you know

397
00:15:11,690 --> 00:15:14,030
blast

398
00:15:12,200 --> 00:15:17,390
air conditioning all the time or

399
00:15:14,030 --> 00:15:21,050
something like that so even seemingly

400
00:15:17,390 --> 00:15:22,670
trivial trivial applications or software

401
00:15:21,050 --> 00:15:25,040
it now becomes important to make sure

402
00:15:22,670 --> 00:15:27,469
they're secure and once in some sense so

403
00:15:25,040 --> 00:15:28,790
they can't affect other components of

404
00:15:27,470 --> 00:15:31,130
course the other issue is scale is a

405
00:15:28,790 --> 00:15:33,620
little too before we've got this

406
00:15:31,130 --> 00:15:35,689
formalism gap and the good news there is

407
00:15:33,620 --> 00:15:38,060
that we've really we really can verify

408
00:15:35,690 --> 00:15:38,360
realistic programs now thanks to the

409
00:15:38,060 --> 00:15:40,309
power

410
00:15:38,360 --> 00:15:42,799
mores law we have more powerful

411
00:15:40,309 --> 00:15:44,600
reasoning systems that can scale to very

412
00:15:42,799 --> 00:15:45,920
large program so we've developed mature

413
00:15:44,600 --> 00:15:48,290
technologies that can reason about

414
00:15:45,920 --> 00:15:50,748
programs down to the last byte we can

415
00:15:48,290 --> 00:15:52,790
actually verify formally the code that

416
00:15:50,749 --> 00:15:54,679
we are deploying on the machine and we

417
00:15:52,790 --> 00:15:56,299
can verify the machines themselves so

418
00:15:54,679 --> 00:15:58,189
that we can have a proof that the code

419
00:15:56,299 --> 00:15:59,779
that actually gets executed does exactly

420
00:15:58,189 --> 00:16:01,849
what we wanted and there have been

421
00:15:59,779 --> 00:16:03,049
several really powerful examples of

422
00:16:01,850 --> 00:16:05,959
realistic systems that have been

423
00:16:03,049 --> 00:16:08,089
verified using formal methods and

424
00:16:05,959 --> 00:16:10,368
machine check proof there's the cop cert

425
00:16:08,089 --> 00:16:13,009
verified compiler which is a real C

426
00:16:10,369 --> 00:16:15,529
compiler that produces the proof that

427
00:16:13,009 --> 00:16:17,540
the code that you stick on the code that

428
00:16:15,529 --> 00:16:19,100
you output behaves exactly like the code

429
00:16:17,540 --> 00:16:20,420
that you put in at the beginning that is

430
00:16:19,100 --> 00:16:22,749
the compiler doesn't introduce any

431
00:16:20,420 --> 00:16:24,829
semantic errors there's the SEO for

432
00:16:22,749 --> 00:16:26,269
verified micro corner where we have

433
00:16:24,829 --> 00:16:29,359
strong guarantees about isolation

434
00:16:26,269 --> 00:16:33,860
between the the components and Microsoft

435
00:16:29,360 --> 00:16:36,019
is developing a verified HTTP HTTP stack

436
00:16:33,860 --> 00:16:37,279
using formal methods called project

437
00:16:36,019 --> 00:16:39,499
efforts and there are many other

438
00:16:37,279 --> 00:16:41,689
examples out there so we have shown that

439
00:16:39,499 --> 00:16:44,660
we can now scale these to realistic

440
00:16:41,689 --> 00:16:45,679
systems and of course the expertise

441
00:16:44,660 --> 00:16:48,769
question is easy we just need more

442
00:16:45,679 --> 00:16:50,509
people to come grad school so you need a

443
00:16:48,769 --> 00:16:51,309
PhD in computer science so get a PhD in

444
00:16:50,509 --> 00:16:55,100
computer science

445
00:16:51,309 --> 00:16:56,839
well maybe not I think the argument here

446
00:16:55,100 --> 00:16:58,549
is that now we've developed these

447
00:16:56,839 --> 00:16:59,720
technologies and mature enough that we

448
00:16:58,549 --> 00:17:02,509
can actually stand on the shoulders of

449
00:16:59,720 --> 00:17:04,039
giants right if you you don't need to be

450
00:17:02,509 --> 00:17:06,110
an expert in formal methods to use a

451
00:17:04,039 --> 00:17:07,879
certified compiler but you get the

452
00:17:06,109 --> 00:17:10,398
guarantees about the you know the code

453
00:17:07,880 --> 00:17:13,220
it produces similarly if you want strong

454
00:17:10,398 --> 00:17:14,418
proofs about isolation and your embedded

455
00:17:13,220 --> 00:17:16,309
system you can use this verified

456
00:17:14,419 --> 00:17:20,029
microkernel and you get you know a

457
00:17:16,309 --> 00:17:21,980
stronger security guarantee and on top

458
00:17:20,029 --> 00:17:23,779
of that as I said before you know people

459
00:17:21,980 --> 00:17:26,120
in the you know and the PhD or just act

460
00:17:23,779 --> 00:17:28,580
in in grad school or in academia are

461
00:17:26,119 --> 00:17:30,889
actively working to develop better tools

462
00:17:28,580 --> 00:17:32,240
that you can use at lower cost you know

463
00:17:30,889 --> 00:17:34,129
there are a lot of work in synthesis

464
00:17:32,240 --> 00:17:35,000
where we are developing systems where

465
00:17:34,130 --> 00:17:37,519
you can just write down the

466
00:17:35,000 --> 00:17:39,889
specification and now you actually the

467
00:17:37,519 --> 00:17:42,470
system will produce a program with a

468
00:17:39,889 --> 00:17:45,080
proof that it's correct so we're

469
00:17:42,470 --> 00:17:47,090
lowering the cost of entry to the system

470
00:17:45,080 --> 00:17:48,620
is getting lower and lower to the point

471
00:17:47,090 --> 00:17:50,510
where you can just use sort of

472
00:17:48,620 --> 00:17:52,129
off-the-shelf technologies you know

473
00:17:50,510 --> 00:17:53,810
write a sign off and say formal

474
00:17:52,130 --> 00:17:56,360
inside and you have a stronger more

475
00:17:53,810 --> 00:17:58,070
secure system so those are my straw men

476
00:17:56,360 --> 00:17:59,840
I've knocked them down and waiting for

477
00:17:58,070 --> 00:18:04,280
some better attacks during the panel

478
00:17:59,840 --> 00:18:06,560
discussion so as I noted what what did I

479
00:18:04,280 --> 00:18:08,090
say was holding formal methods adoption

480
00:18:06,560 --> 00:18:09,980
back well I think that there's this

481
00:18:08,090 --> 00:18:13,760
perception that the costs outweigh the

482
00:18:09,980 --> 00:18:15,320
benefits and the the scale is slowly

483
00:18:13,760 --> 00:18:16,580
tilting the other way where the benefits

484
00:18:15,320 --> 00:18:21,730
of these systems are starting outweigh

485
00:18:16,580 --> 00:18:21,730
the cost thank you

486
00:18:22,220 --> 00:18:28,049
[Applause]

487
00:18:54,410 --> 00:19:00,500
okay so I'm very happy to hear a Ben's

488
00:18:57,620 --> 00:19:02,270
talk because it gives great introduction

489
00:19:00,500 --> 00:19:03,830
to what I am going to say I have pretty

490
00:19:02,270 --> 00:19:05,560
much the same points to make

491
00:19:03,830 --> 00:19:08,780
except I'll probably use a little bit

492
00:19:05,560 --> 00:19:13,270
more detail based on what he introduced

493
00:19:08,780 --> 00:19:16,730
so I have taken the liberty to in the

494
00:19:13,270 --> 00:19:18,680
title of the panel bit more liberally

495
00:19:16,730 --> 00:19:21,290
I'm just going to talk about following

496
00:19:18,680 --> 00:19:24,320
methods and security I am NOT an expert

497
00:19:21,290 --> 00:19:25,670
in security but I am an expert in formal

498
00:19:24,320 --> 00:19:29,540
methods and I want to tell you a little

499
00:19:25,670 --> 00:19:32,540
bit more about what formal methods mean

500
00:19:29,540 --> 00:19:36,740
what they are able to achieve today and

501
00:19:32,540 --> 00:19:40,129
what I think the community agrees on the

502
00:19:36,740 --> 00:19:42,320
challenges that industrial deployment or

503
00:19:40,130 --> 00:19:46,940
formal methods for security applications

504
00:19:42,320 --> 00:19:51,320
anything so let's start with the bird's

505
00:19:46,940 --> 00:19:53,930
eye view so this is essentially what Ben

506
00:19:51,320 --> 00:19:57,350
was talking about with his ship and boat

507
00:19:53,930 --> 00:20:00,620
example so this is this is what is

508
00:19:57,350 --> 00:20:03,490
typically done for ensuring software

509
00:20:00,620 --> 00:20:06,739
reliability across the board in many

510
00:20:03,490 --> 00:20:08,510
industries so this is this is

511
00:20:06,740 --> 00:20:11,060
essentially the testing approach so

512
00:20:08,510 --> 00:20:14,530
developers would write a program and

513
00:20:11,060 --> 00:20:17,840
then either the developer or due to

514
00:20:14,530 --> 00:20:20,240
ancient wisdom there would be some

515
00:20:17,840 --> 00:20:23,600
informal specification of what the

516
00:20:20,240 --> 00:20:27,140
program is supposed to do or some set of

517
00:20:23,600 --> 00:20:29,990
test cases which are used then to check

518
00:20:27,140 --> 00:20:32,770
if the program is correct so there is

519
00:20:29,990 --> 00:20:35,290
this testing phase we're starting with a

520
00:20:32,770 --> 00:20:37,490
software program and some informal

521
00:20:35,290 --> 00:20:39,800
knowledge of what the program is

522
00:20:37,490 --> 00:20:41,810
supposed to do there is a process of

523
00:20:39,800 --> 00:20:44,780
checking if the program is correct so

524
00:20:41,810 --> 00:20:47,540
you just run the program using your test

525
00:20:44,780 --> 00:20:50,240
inputs and check if the outputs are what

526
00:20:47,540 --> 00:20:52,850
you expect them to be so well if these

527
00:20:50,240 --> 00:20:54,920
tests if your program passes these tests

528
00:20:52,850 --> 00:20:57,860
then you just declare the program to be

529
00:20:54,920 --> 00:21:00,020
correct okay and if these tests fail

530
00:20:57,860 --> 00:21:02,840
then you start an iterative loop of

531
00:21:00,020 --> 00:21:06,139
basically debugging and repairing the

532
00:21:02,840 --> 00:21:08,209
program until you are satisfied with

533
00:21:06,140 --> 00:21:11,419
what you

534
00:21:08,210 --> 00:21:13,580
the testing phase gives you so until you

535
00:21:11,419 --> 00:21:15,259
have your program has passed all the

536
00:21:13,580 --> 00:21:18,649
tests for instance and then you declare

537
00:21:15,259 --> 00:21:22,399
the program to be correct so this is the

538
00:21:18,649 --> 00:21:25,279
testing approach and there is a famous

539
00:21:22,399 --> 00:21:27,918
court by a famous person that some of

540
00:21:25,279 --> 00:21:29,919
you might have heard of who also spent

541
00:21:27,919 --> 00:21:34,519
time at UT Austin

542
00:21:29,919 --> 00:21:36,440
so Dykstra said I identified very

543
00:21:34,519 --> 00:21:38,360
appropriately the program testing can be

544
00:21:36,440 --> 00:21:40,940
quite effective for showing the presence

545
00:21:38,360 --> 00:21:43,549
of bunts but is hopelessly inadequate

546
00:21:40,940 --> 00:21:45,080
for showing their absence okay so if you

547
00:21:43,549 --> 00:21:48,139
are interested in verifying or

548
00:21:45,080 --> 00:21:50,629
guaranteeing that a program is correct

549
00:21:48,139 --> 00:21:53,658
this testing approach is not going to

550
00:21:50,629 --> 00:21:59,539
help you provide such guarantees okay

551
00:21:53,659 --> 00:22:02,240
because when you have declared this

552
00:21:59,539 --> 00:22:04,429
program to be correct it is correct

553
00:22:02,240 --> 00:22:07,879
according to your set of test cases or

554
00:22:04,429 --> 00:22:11,179
some informal specification and and that

555
00:22:07,879 --> 00:22:15,139
is not a formal notion of correctness so

556
00:22:11,179 --> 00:22:17,840
what are a typical development cycle

557
00:22:15,139 --> 00:22:21,709
that is enhanced with the use of formal

558
00:22:17,840 --> 00:22:23,629
methods is going to look like this so

559
00:22:21,710 --> 00:22:25,669
you again start with a program and

560
00:22:23,629 --> 00:22:28,689
instead of having an informal

561
00:22:25,669 --> 00:22:32,470
specification or test cases you are

562
00:22:28,690 --> 00:22:35,200
formally articulate what the

563
00:22:32,470 --> 00:22:38,809
specification of your program should be

564
00:22:35,200 --> 00:22:42,080
using some mathematical logic okay so

565
00:22:38,809 --> 00:22:44,450
think of this as a very precise and

566
00:22:42,080 --> 00:22:46,999
mathematical description of what your

567
00:22:44,450 --> 00:22:50,840
software or what your system is supposed

568
00:22:46,999 --> 00:22:54,289
to do and then instead of testing you

569
00:22:50,840 --> 00:22:57,590
employ formal verification techniques to

570
00:22:54,289 --> 00:22:59,658
check if your program satisfies the

571
00:22:57,590 --> 00:23:02,029
specification okay

572
00:22:59,659 --> 00:23:03,950
so what we have I mean I am NOT going

573
00:23:02,029 --> 00:23:06,590
into detail here but what we have done

574
00:23:03,950 --> 00:23:09,379
with these changes is essentially

575
00:23:06,590 --> 00:23:12,590
introduce a lot of mathematics based

576
00:23:09,379 --> 00:23:15,320
position into specifying the proper

577
00:23:12,590 --> 00:23:18,129
system property and as well to checking

578
00:23:15,320 --> 00:23:22,010
if the system satisfies the property and

579
00:23:18,129 --> 00:23:25,189
then are in more recent years

580
00:23:22,010 --> 00:23:27,770
these process these parts of the program

581
00:23:25,190 --> 00:23:30,170
development cycle which are done by

582
00:23:27,770 --> 00:23:33,050
programmers or by human developers

583
00:23:30,170 --> 00:23:39,010
themselves are also or are also being

584
00:23:33,050 --> 00:23:41,870
replaced with automated techniques so

585
00:23:39,010 --> 00:23:44,060
this whole so that this whole loop ends

586
00:23:41,870 --> 00:23:46,939
up being automated because a human

587
00:23:44,060 --> 00:23:49,879
programmer can make mistakes and

588
00:23:46,940 --> 00:23:52,100
similarly a human debugger may also make

589
00:23:49,880 --> 00:23:54,500
mistakes so in fixing a particular error

590
00:23:52,100 --> 00:23:58,760
a human debugger may introduce more

591
00:23:54,500 --> 00:24:01,490
errors so formalizing and automating

592
00:23:58,760 --> 00:24:04,370
these parts of the development cycle are

593
00:24:01,490 --> 00:24:09,200
also crucial in ensuring our program

594
00:24:04,370 --> 00:24:11,449
correctness so now when you have gone

595
00:24:09,200 --> 00:24:14,000
through this iterative development cycle

596
00:24:11,450 --> 00:24:16,280
and the program verification engine says

597
00:24:14,000 --> 00:24:18,710
that your program is correct you can

598
00:24:16,280 --> 00:24:21,950
indeed declare that the program is

599
00:24:18,710 --> 00:24:24,680
correct okay so let me just mention one

600
00:24:21,950 --> 00:24:27,260
caveat I think sort of and when both

601
00:24:24,680 --> 00:24:29,450
mentioned this thing about hundred

602
00:24:27,260 --> 00:24:33,290
percent guarantees of system correctness

603
00:24:29,450 --> 00:24:35,510
okay I I just want to clarify that there

604
00:24:33,290 --> 00:24:38,330
is no such thing as a hundred percent

605
00:24:35,510 --> 00:24:40,580
guarantee of system correctness so we

606
00:24:38,330 --> 00:24:43,730
are going to this is going to help us

607
00:24:40,580 --> 00:24:46,760
build software and systems that is far

608
00:24:43,730 --> 00:24:49,730
more correct or far more secure than

609
00:24:46,760 --> 00:24:52,190
what traditional testing based a human

610
00:24:49,730 --> 00:24:53,840
driven approaches can but there is no

611
00:24:52,190 --> 00:24:56,300
such thing as a hundred percent

612
00:24:53,840 --> 00:24:58,429
guarantee that's because somebody has to

613
00:24:56,300 --> 00:25:00,470
come up with this formal specification

614
00:24:58,430 --> 00:25:02,500
somebody has to implement this

615
00:25:00,470 --> 00:25:05,240
verification engine and there can be

616
00:25:02,500 --> 00:25:08,890
incompleteness and errors at all of

617
00:25:05,240 --> 00:25:12,350
these stages of the verification process

618
00:25:08,890 --> 00:25:14,450
so that's that's that's an enhancement

619
00:25:12,350 --> 00:25:17,050
of the typical program development cycle

620
00:25:14,450 --> 00:25:21,110
with formal methods here is another

621
00:25:17,050 --> 00:25:23,960
approach that one can take to develop

622
00:25:21,110 --> 00:25:26,540
direct programs so this is the program

623
00:25:23,960 --> 00:25:30,220
synthesis or the program completion

624
00:25:26,540 --> 00:25:33,560
paradigm where I am just showing you one

625
00:25:30,220 --> 00:25:35,779
instantiation of this paradigm where you

626
00:25:33,560 --> 00:25:38,450
can have a programmer just write up

627
00:25:35,779 --> 00:25:40,399
program leaving out a lot of the

628
00:25:38,450 --> 00:25:45,889
trickier details of writing the program

629
00:25:40,399 --> 00:25:47,959
and then uh you feed a synthesis engine

630
00:25:45,889 --> 00:25:50,689
this partial program and the formal

631
00:25:47,960 --> 00:25:53,149
specification and the synthesis engine

632
00:25:50,690 --> 00:25:55,969
automatically generates a program that

633
00:25:53,149 --> 00:25:58,218
is correct by completion or correct by

634
00:25:55,969 --> 00:26:01,519
construction okay so this is the promise

635
00:25:58,219 --> 00:26:04,399
of program synthesis where you eliminate

636
00:26:01,519 --> 00:26:06,289
this iterative cycle of checking if a

637
00:26:04,399 --> 00:26:07,689
program is correct then debugging and

638
00:26:06,289 --> 00:26:12,529
repairing and then doing it again

639
00:26:07,690 --> 00:26:14,539
instead you just have a programmer write

640
00:26:12,529 --> 00:26:17,599
what the programmer can write best so

641
00:26:14,539 --> 00:26:19,669
this partial program can can capture the

642
00:26:17,599 --> 00:26:22,519
best human intuition that a programmer

643
00:26:19,669 --> 00:26:26,239
can bring in whereas the synthesis

644
00:26:22,519 --> 00:26:30,759
engine can take care of the tricky dirty

645
00:26:26,239 --> 00:26:33,919
details that humans usually fail at and

646
00:26:30,759 --> 00:26:37,460
together we can have a program that is

647
00:26:33,919 --> 00:26:40,659
correct and in our context secure so

648
00:26:37,460 --> 00:26:44,210
that's that was a bird's eye view of

649
00:26:40,659 --> 00:26:46,609
formal methods in general and here are

650
00:26:44,210 --> 00:26:48,289
here's just some terminology that I'm

651
00:26:46,609 --> 00:26:50,689
going to throw at you in so you have

652
00:26:48,289 --> 00:26:53,089
something to talk about after this panel

653
00:26:50,690 --> 00:26:56,509
so these are the three different classes

654
00:26:53,089 --> 00:26:58,789
of formal methods broadly speaking there

655
00:26:56,509 --> 00:27:00,589
is a deductive verification based on

656
00:26:58,789 --> 00:27:02,629
theorem proving and been talked about

657
00:27:00,589 --> 00:27:04,639
some of this there is also model

658
00:27:02,629 --> 00:27:06,709
checking and abstract interpretation or

659
00:27:04,639 --> 00:27:10,369
static analysis and some of these

660
00:27:06,710 --> 00:27:15,729
methods are more automated than others

661
00:27:10,369 --> 00:27:17,869
some of them are more of X and L more

662
00:27:15,729 --> 00:27:18,769
let's say they're just more expressive

663
00:27:17,869 --> 00:27:22,459
than others

664
00:27:18,769 --> 00:27:24,979
so III really I'll come back to this

665
00:27:22,460 --> 00:27:29,809
later but there is an argument against

666
00:27:24,979 --> 00:27:32,809
formal methods that it requires PhD to

667
00:27:29,809 --> 00:27:34,279
deploy but a lot of these techniques

668
00:27:32,809 --> 00:27:35,690
such as model checking and abstract

669
00:27:34,279 --> 00:27:37,729
interpretation based techniques they

670
00:27:35,690 --> 00:27:40,729
will require a PhD to develop tools

671
00:27:37,729 --> 00:27:46,279
based on these but users don't need PhDs

672
00:27:40,729 --> 00:27:48,990
ok users of theorem proving and engines

673
00:27:46,279 --> 00:27:52,230
and proof assistants may require

674
00:27:48,990 --> 00:27:55,710
in most cases but not all formal methods

675
00:27:52,230 --> 00:27:58,980
really require expertise in that

676
00:27:55,710 --> 00:28:01,679
particular line and these are various

677
00:27:58,980 --> 00:28:04,679
underlying tools that many of these

678
00:28:01,679 --> 00:28:08,550
formal methods use in order to complete

679
00:28:04,679 --> 00:28:09,860
the verification loop and let's not go

680
00:28:08,550 --> 00:28:14,879
there

681
00:28:09,860 --> 00:28:18,959
so another argument is that formal

682
00:28:14,880 --> 00:28:21,090
methods hasn't really scaled hasn't

683
00:28:18,960 --> 00:28:26,010
really achieved much it's an academic

684
00:28:21,090 --> 00:28:29,399
Enterprise and here is a list that I was

685
00:28:26,010 --> 00:28:32,610
able to dig up in about 10 or 15 minutes

686
00:28:29,400 --> 00:28:34,500
of searching on Google some of them are

687
00:28:32,610 --> 00:28:38,159
of course very well known and I also

688
00:28:34,500 --> 00:28:41,670
have Rockwell Collins up there and this

689
00:28:38,160 --> 00:28:44,220
is really a non exhaustive but hopefully

690
00:28:41,670 --> 00:28:46,200
representative list of success stories

691
00:28:44,220 --> 00:28:48,360
of formal methods one of my senior

692
00:28:46,200 --> 00:28:50,610
colleagues who is at Amazon who's

693
00:28:48,360 --> 00:28:53,000
leading our formal verification effort

694
00:28:50,610 --> 00:28:56,070
at Amazon Web Services he had just

695
00:28:53,000 --> 00:28:57,870
posted a question on Facebook asking his

696
00:28:56,070 --> 00:28:59,610
colleagues from academia and industry to

697
00:28:57,870 --> 00:29:02,428
talk about success stories of industrial

698
00:28:59,610 --> 00:29:04,949
development of formal methods and that

699
00:29:02,429 --> 00:29:09,450
was one popular post so most of this is

700
00:29:04,950 --> 00:29:14,040
actually drawn from that post so that

701
00:29:09,450 --> 00:29:16,200
for instance Rockwell Collins has done a

702
00:29:14,040 --> 00:29:18,300
formal verification of a certain

703
00:29:16,200 --> 00:29:20,640
microprocessors partition management

704
00:29:18,300 --> 00:29:23,700
which is used in a wide variety of

705
00:29:20,640 --> 00:29:27,840
products including - cryptographic

706
00:29:23,700 --> 00:29:30,570
products then Intel has among the

707
00:29:27,840 --> 00:29:32,220
largest formal verification teams in the

708
00:29:30,570 --> 00:29:35,520
group and this was of course triggered

709
00:29:32,220 --> 00:29:37,260
by the infamous Pentium floating point

710
00:29:35,520 --> 00:29:41,070
division bug which cost them half a

711
00:29:37,260 --> 00:29:43,230
billion dollars so what it would take I

712
00:29:41,070 --> 00:29:45,510
mean sometimes bugs are what it takes

713
00:29:43,230 --> 00:29:48,240
for industrial adoption of expensive

714
00:29:45,510 --> 00:29:50,040
techniques then I'm actually not going

715
00:29:48,240 --> 00:29:55,230
to go through all this but you can see

716
00:29:50,040 --> 00:30:01,899
that flight control software grain

717
00:29:55,230 --> 00:30:05,810
networks Mars the NASA Mars rover then

718
00:30:01,900 --> 00:30:10,240
then of course various units the

719
00:30:05,810 --> 00:30:12,379
arithmetic and logical units across many

720
00:30:10,240 --> 00:30:16,220
companies working in the microprocessor

721
00:30:12,380 --> 00:30:19,010
industry all have employed formal

722
00:30:16,220 --> 00:30:22,250
verification techniques to ensure our

723
00:30:19,010 --> 00:30:23,900
reliability and here I have in this one

724
00:30:22,250 --> 00:30:27,230
line I particularly want you to notice

725
00:30:23,900 --> 00:30:29,570
this one bullet I have here where there

726
00:30:27,230 --> 00:30:31,190
are a bunch of companies so many of the

727
00:30:29,570 --> 00:30:33,530
companies in the microprocessor industry

728
00:30:31,190 --> 00:30:37,010
starting from Apple or an arm or

729
00:30:33,530 --> 00:30:40,100
Softbank and VDI IBM Oracle have been

730
00:30:37,010 --> 00:30:46,250
using formal verification to verify

731
00:30:40,100 --> 00:30:48,379
their RTL for years now so uh so this

732
00:30:46,250 --> 00:30:51,770
hopefully refutes this argument about

733
00:30:48,380 --> 00:30:55,870
where our formal methods used okay and I

734
00:30:51,770 --> 00:30:59,210
repeat this is a non exhaustive list so

735
00:30:55,870 --> 00:31:01,489
this is again another view of what I had

736
00:30:59,210 --> 00:31:04,580
on the slide in case people at the back

737
00:31:01,490 --> 00:31:08,180
couldn't read so these are whatever is

738
00:31:04,580 --> 00:31:11,149
up here either is a provider of formal

739
00:31:08,180 --> 00:31:13,400
methods technology or is a user of

740
00:31:11,150 --> 00:31:16,100
formal methods technology or has a

741
00:31:13,400 --> 00:31:20,900
formal verification team within the

742
00:31:16,100 --> 00:31:23,659
company itself okay so so there is

743
00:31:20,900 --> 00:31:27,670
definitely vast industrial adoption of

744
00:31:23,660 --> 00:31:27,670
formal methods in the industry already

745
00:31:28,240 --> 00:31:34,130
and here are some of the some specific

746
00:31:32,480 --> 00:31:36,370
points that refute some of the common

747
00:31:34,130 --> 00:31:38,930
arguments so I've already mentioned this

748
00:31:36,370 --> 00:31:41,540
formula this does not always require a

749
00:31:38,930 --> 00:31:44,450
PhD many of the techniques are automated

750
00:31:41,540 --> 00:31:47,990
or semi-automated formal methods does

751
00:31:44,450 --> 00:31:50,480
not necessarily require an understanding

752
00:31:47,990 --> 00:31:53,330
of the source code to which it's applied

753
00:31:50,480 --> 00:31:55,640
to which it's applied because a lot of

754
00:31:53,330 --> 00:31:58,520
these techniques are applicable at the

755
00:31:55,640 --> 00:32:01,550
binary level then you do not always

756
00:31:58,520 --> 00:32:03,590
require the user to provide very precise

757
00:32:01,550 --> 00:32:05,510
mathematical formal specifications many

758
00:32:03,590 --> 00:32:08,060
of these tools will work with some

759
00:32:05,510 --> 00:32:09,950
default specifications such as they will

760
00:32:08,060 --> 00:32:12,110
give you guarantees against buffer

761
00:32:09,950 --> 00:32:15,470
overflows memory leaks race conditions

762
00:32:12,110 --> 00:32:21,258
and so on and they are scalable as

763
00:32:15,470 --> 00:32:23,659
the previous slides hopefully showed so

764
00:32:21,259 --> 00:32:25,070
I think many of the old challenges that

765
00:32:23,659 --> 00:32:26,480
we have been talking about about

766
00:32:25,070 --> 00:32:29,000
industrial adoption of formal methods

767
00:32:26,480 --> 00:32:33,379
are moot but there are a couple of

768
00:32:29,000 --> 00:32:36,019
challenges that that are more new age so

769
00:32:33,379 --> 00:32:38,149
we have complex systems and we really

770
00:32:36,019 --> 00:32:40,580
need to provide guarantees that span the

771
00:32:38,149 --> 00:32:42,350
entire stack of the whole system which

772
00:32:40,580 --> 00:32:44,408
can involve guarantees that go across

773
00:32:42,350 --> 00:32:46,519
hardware operating systems applications

774
00:32:44,409 --> 00:32:49,610
networking and distributed systems and

775
00:32:46,519 --> 00:32:52,460
so on and just looking at one piece of

776
00:32:49,610 --> 00:32:54,428
the whole stack in isolation may not be

777
00:32:52,460 --> 00:32:56,720
sufficient we also need the right

778
00:32:54,429 --> 00:33:00,320
abstractions that are needed to forints

779
00:32:56,720 --> 00:33:03,470
to for both the programmer and the user

780
00:33:00,320 --> 00:33:05,269
and some of this some of these

781
00:33:03,470 --> 00:33:07,789
challenges have been discussed and

782
00:33:05,269 --> 00:33:10,639
identified in a recent NSF workshop on

783
00:33:07,789 --> 00:33:13,700
formal methods for security which just

784
00:33:10,639 --> 00:33:15,740
again goes to illustrate how how

785
00:33:13,700 --> 00:33:17,809
everyone seems to be recognizing the

786
00:33:15,740 --> 00:33:21,669
value of formal methods for security

787
00:33:17,809 --> 00:33:21,668
that's my spiel thank you

788
00:33:22,730 --> 00:33:27,569
[Applause]

789
00:33:39,299 --> 00:33:42,509
that's it

790
00:33:54,230 --> 00:34:00,300
hello I'm Matt Wilding and I am the

791
00:33:58,200 --> 00:34:03,900
manager of the trusted Systems Group at

792
00:34:00,300 --> 00:34:06,720
Rockwell Collins and has already been

793
00:34:03,900 --> 00:34:08,760
told to you five or six times I have a

794
00:34:06,720 --> 00:34:14,310
PhD in computer science from the

795
00:34:08,760 --> 00:34:17,700
University of Texas at Austin so our

796
00:34:14,310 --> 00:34:18,899
group Rockwell Collins is a large

797
00:34:17,699 --> 00:34:21,330
company

798
00:34:18,899 --> 00:34:25,020
it makes commercial aviation products

799
00:34:21,330 --> 00:34:28,290
and also has a large military business

800
00:34:25,020 --> 00:34:30,540
and with a separate Technology Center

801
00:34:28,290 --> 00:34:32,610
that does research and development and

802
00:34:30,540 --> 00:34:34,350
it has 11 groups in it and one of them

803
00:34:32,610 --> 00:34:36,889
is the trusted Systems Group which does

804
00:34:34,350 --> 00:34:40,469
a lot of formal methods work

805
00:34:36,889 --> 00:34:45,230
specifically applying it to the broad

806
00:34:40,469 --> 00:34:45,230
portfolio of Rockwell Collins products

807
00:34:45,800 --> 00:34:50,960
so what I thought I would do is I would

808
00:34:48,300 --> 00:34:54,869
talk about two examples where we've used

809
00:34:50,960 --> 00:34:59,030
formal methods in a in a in a in a

810
00:34:54,869 --> 00:35:03,920
useful way one was already mentioned

811
00:34:59,030 --> 00:35:07,109
what we've done is we built a

812
00:35:03,920 --> 00:35:08,940
microprocessor that had security built

813
00:35:07,109 --> 00:35:12,259
into the microarchitecture of the

814
00:35:08,940 --> 00:35:14,430
microprocessor is called the amp 7g and

815
00:35:12,260 --> 00:35:16,580
it's kind of cool when you can build

816
00:35:14,430 --> 00:35:22,020
your own micro processors to do things

817
00:35:16,580 --> 00:35:26,000
as we were able to do and what we did is

818
00:35:22,020 --> 00:35:28,890
we we took the microarchitecture of the

819
00:35:26,000 --> 00:35:33,540
I'm getting some feedback is this are

820
00:35:28,890 --> 00:35:35,310
you able to hear me okay what we did is

821
00:35:33,540 --> 00:35:37,800
we took the microarchitecture of the

822
00:35:35,310 --> 00:35:41,549
microprocessor and the micro code that

823
00:35:37,800 --> 00:35:44,100
runs in trusted trusted mode and we

824
00:35:41,550 --> 00:35:47,520
modeled all that in a very detailed way

825
00:35:44,100 --> 00:35:49,319
and we're able to prove that in fact the

826
00:35:47,520 --> 00:35:51,450
information flows in the microprocessor

827
00:35:49,320 --> 00:35:54,119
exactly what you'd expect and that's

828
00:35:51,450 --> 00:35:59,700
characterized by this by this theorem

829
00:35:54,119 --> 00:36:02,970
that we this theorem that we proved

830
00:35:59,700 --> 00:36:05,808
about the processor that's come to be

831
00:36:02,970 --> 00:36:11,200
known as the GWD correctness theorem

832
00:36:05,809 --> 00:36:14,119
and by doing this proof we were able to

833
00:36:11,200 --> 00:36:16,040
come to a claim that the processor does

834
00:36:14,119 --> 00:36:18,619
exactly what we said it was was supposed

835
00:36:16,040 --> 00:36:21,079
to do and we were able to do our proofs

836
00:36:18,619 --> 00:36:23,059
in a way that all the proofs were able

837
00:36:21,079 --> 00:36:27,710
to be checked by a mechanical theorem

838
00:36:23,059 --> 00:36:29,869
prover what we were able to do then of

839
00:36:27,710 --> 00:36:32,030
course you don't it's a wonderful and

840
00:36:29,869 --> 00:36:34,339
electoral challenge to to prove

841
00:36:32,030 --> 00:36:36,380
something about a microprocessor but

842
00:36:34,339 --> 00:36:39,259
really what you want to do is you want

843
00:36:36,380 --> 00:36:44,319
to be able to then use that processor in

844
00:36:39,260 --> 00:36:46,220
a in a in a larger system and one

845
00:36:44,319 --> 00:36:47,839
application of this processor was

846
00:36:46,220 --> 00:36:50,209
already mentioned about cryptographic

847
00:36:47,839 --> 00:36:53,509
systems we've also built a high

848
00:36:50,210 --> 00:36:56,329
assurance Network guards that use that

849
00:36:53,510 --> 00:37:01,040
secure processor as well so we were able

850
00:36:56,329 --> 00:37:03,140
to take this theorem and design a high

851
00:37:01,040 --> 00:37:04,910
assurance guard which what it does is it

852
00:37:03,140 --> 00:37:07,250
checks to make sure that messages are

853
00:37:04,910 --> 00:37:10,180
flowing between networks in a way that's

854
00:37:07,250 --> 00:37:13,579
only that's authorized and by using the

855
00:37:10,180 --> 00:37:15,078
formally verified microprocessor we're

856
00:37:13,579 --> 00:37:17,390
able to build a system that we have

857
00:37:15,079 --> 00:37:19,160
really high confidence that it's going

858
00:37:17,390 --> 00:37:21,740
to do exactly what we say it's going to

859
00:37:19,160 --> 00:37:23,930
do and not only that but all the

860
00:37:21,740 --> 00:37:25,459
evidence that we have to show that the

861
00:37:23,930 --> 00:37:29,180
system works the way it's supposed to

862
00:37:25,460 --> 00:37:31,730
work is checked by a computer program

863
00:37:29,180 --> 00:37:33,618
which we can provide people that want to

864
00:37:31,730 --> 00:37:35,599
evaluate our system and say hey you can

865
00:37:33,619 --> 00:37:38,290
you can generate these proofs yourself

866
00:37:35,599 --> 00:37:40,819
look here's the theorem that we proved

867
00:37:38,290 --> 00:37:43,160
go off and generate the proofs yourself

868
00:37:40,819 --> 00:37:46,400
using a tool of your own devising if you

869
00:37:43,160 --> 00:37:48,950
like so that's one example where we've

870
00:37:46,400 --> 00:37:53,599
used formal methods in a product

871
00:37:48,950 --> 00:37:54,950
development a second example is one is a

872
00:37:53,599 --> 00:37:58,880
project that we're actually just

873
00:37:54,950 --> 00:38:04,040
finishing it's it's sponsored by DARPA

874
00:37:58,880 --> 00:38:08,890
and and what we've done is is we've

875
00:38:04,040 --> 00:38:11,900
shown the secure security aspects of

876
00:38:08,890 --> 00:38:14,359
different vehicles so going back to this

877
00:38:11,900 --> 00:38:18,440
earlier example we're very proud of this

878
00:38:14,359 --> 00:38:19,009
theorem it's key to this to this larger

879
00:38:18,440 --> 00:38:23,740
system

880
00:38:19,010 --> 00:38:26,090
where it does network guard work but

881
00:38:23,740 --> 00:38:28,520
there's really sort of no formal

882
00:38:26,090 --> 00:38:32,780
connection between the architecture of

883
00:38:28,520 --> 00:38:34,370
this larger system and the theorem that

884
00:38:32,780 --> 00:38:37,100
we proved about the microprocessor

885
00:38:34,370 --> 00:38:41,089
that's sort of the policeman of this of

886
00:38:37,100 --> 00:38:44,000
this architecture so completely verified

887
00:38:41,090 --> 00:38:47,750
mechanically verified formal methods

888
00:38:44,000 --> 00:38:51,170
proved theorem that's at the heart of

889
00:38:47,750 --> 00:38:55,430
the system but in formal paper based

890
00:38:51,170 --> 00:38:57,920
system architecture that exploits this

891
00:38:55,430 --> 00:39:00,109
theorem what we'd like to do is we'd

892
00:38:57,920 --> 00:39:02,150
like to be able to describe system

893
00:39:00,110 --> 00:39:03,850
architectures and a more rigorous way as

894
00:39:02,150 --> 00:39:08,510
well

895
00:39:03,850 --> 00:39:11,180
and we've we are doing more and more of

896
00:39:08,510 --> 00:39:14,410
that kind of work as well so in this

897
00:39:11,180 --> 00:39:17,149
case what we're we're using is our

898
00:39:14,410 --> 00:39:18,980
architectural description languages to

899
00:39:17,150 --> 00:39:23,930
describe in a very precise mathematical

900
00:39:18,980 --> 00:39:27,940
way the architecture of a system and and

901
00:39:23,930 --> 00:39:30,950
then map that down to a secure platform

902
00:39:27,940 --> 00:39:33,650
before we use that microprocessor in

903
00:39:30,950 --> 00:39:36,620
this example we used we're using an

904
00:39:33,650 --> 00:39:38,240
operating system that's been that's had

905
00:39:36,620 --> 00:39:43,220
more formal methods applied to it to

906
00:39:38,240 --> 00:39:45,620
show that it's error-free and what we're

907
00:39:43,220 --> 00:39:47,899
doing is then taking this larger system

908
00:39:45,620 --> 00:39:50,359
architecture mapping it down in a very

909
00:39:47,900 --> 00:39:54,770
rigorous mathematical way to show that

910
00:39:50,360 --> 00:39:58,880
in fact the system is is correct in at

911
00:39:54,770 --> 00:40:01,400
least in some aspects in this world of

912
00:39:58,880 --> 00:40:03,620
security it's what you end up doing is

913
00:40:01,400 --> 00:40:05,990
you can do all the mathematics that you

914
00:40:03,620 --> 00:40:07,339
like but in the end what you really need

915
00:40:05,990 --> 00:40:09,620
to do is you need to hand it off to

916
00:40:07,340 --> 00:40:11,450
somebody who can try to find out that

917
00:40:09,620 --> 00:40:12,560
there that you you missed something you

918
00:40:11,450 --> 00:40:15,589
did something wrong

919
00:40:12,560 --> 00:40:18,320
sure enough of the red team that looked

920
00:40:15,590 --> 00:40:20,780
at these at these at this at these

921
00:40:18,320 --> 00:40:23,060
systems that we did we're not able to

922
00:40:20,780 --> 00:40:26,000
find any cyber vulnerabilities in in the

923
00:40:23,060 --> 00:40:27,710
overall system which as somebody who

924
00:40:26,000 --> 00:40:30,110
worked on the project famously observed

925
00:40:27,710 --> 00:40:31,490
which is really great because if they

926
00:40:30,110 --> 00:40:31,940
had found something then that would have

927
00:40:31,490 --> 00:40:34,100
been met

928
00:40:31,940 --> 00:40:38,210
Maddox was wrong and and that would have

929
00:40:34,100 --> 00:40:40,339
been bad for all of us one of the

930
00:40:38,210 --> 00:40:45,010
questions that we got asked to think

931
00:40:40,340 --> 00:40:49,490
about was what do you think the biggest

932
00:40:45,010 --> 00:40:51,140
hurdle is to more and more adoption of

933
00:40:49,490 --> 00:40:54,919
these kinds of techniques in these sorts

934
00:40:51,140 --> 00:40:57,620
of systems and I think I think that the

935
00:40:54,920 --> 00:41:00,370
biggest thing that's in our way is the

936
00:40:57,620 --> 00:41:03,109
lack of these kinds of industrial scale

937
00:41:00,370 --> 00:41:05,029
applications the more we do of these the

938
00:41:03,110 --> 00:41:06,740
better we get at them and the more

939
00:41:05,030 --> 00:41:08,570
obvious it is to people that want to

940
00:41:06,740 --> 00:41:11,120
build these systems that this is the

941
00:41:08,570 --> 00:41:14,870
right approach to building complex

942
00:41:11,120 --> 00:41:16,640
systems and if I can take the moderator

943
00:41:14,870 --> 00:41:19,910
lets me because I know we're going into

944
00:41:16,640 --> 00:41:24,859
a question time but I'd like to take

945
00:41:19,910 --> 00:41:27,049
three more minutes and say how do you

946
00:41:24,860 --> 00:41:29,330
know and sort of made me general to Hill

947
00:41:27,050 --> 00:41:32,450
inspired me to to give you this list

948
00:41:29,330 --> 00:41:35,090
because it's a list of four things that

949
00:41:32,450 --> 00:41:37,819
will help you determine whether or not

950
00:41:35,090 --> 00:41:40,910
formal methods is the right thing to be

951
00:41:37,820 --> 00:41:43,030
applying in a particular context it's

952
00:41:40,910 --> 00:41:47,359
four questions you have to ask yourself

953
00:41:43,030 --> 00:41:51,290
first question is does anybody really

954
00:41:47,360 --> 00:41:53,090
care about the theorem that you're going

955
00:41:51,290 --> 00:41:55,640
to prove in the case of our

956
00:41:53,090 --> 00:41:57,410
microprocessor yeah we carried a lot in

957
00:41:55,640 --> 00:41:59,390
the case of the cyber resilience of

958
00:41:57,410 --> 00:42:00,620
these vehicles yeah we care a lot but

959
00:41:59,390 --> 00:42:04,009
you really have to ask yourself do you

960
00:42:00,620 --> 00:42:08,210
really do you really care the second

961
00:42:04,010 --> 00:42:11,090
question is can you state precisely what

962
00:42:08,210 --> 00:42:15,920
property it is that you want to show

963
00:42:11,090 --> 00:42:17,750
about the system seems like it's a

964
00:42:15,920 --> 00:42:20,510
little harder than people you might

965
00:42:17,750 --> 00:42:22,460
think at first if you ask people what

966
00:42:20,510 --> 00:42:25,400
property they want of their system and

967
00:42:22,460 --> 00:42:26,570
it's a it's an airplane they might say

968
00:42:25,400 --> 00:42:28,400
well I don't want it to crash into a

969
00:42:26,570 --> 00:42:29,780
mountain well that's that's not precise

970
00:42:28,400 --> 00:42:32,390
enough you need to tell me precisely

971
00:42:29,780 --> 00:42:35,030
what it is you want to have true of it

972
00:42:32,390 --> 00:42:39,710
can you describe what property you want

973
00:42:35,030 --> 00:42:44,270
thirdly do you have a model of the

974
00:42:39,710 --> 00:42:46,480
underlying system that is truly the

975
00:42:44,270 --> 00:42:49,730
system that you are built

976
00:42:46,480 --> 00:42:52,849
mamie you're gonna reason directly about

977
00:42:49,730 --> 00:42:54,440
the the code or the hardware design do

978
00:42:52,849 --> 00:42:57,230
you really believe that when you get

979
00:42:54,440 --> 00:42:59,119
done proving your theorem that you say

980
00:42:57,230 --> 00:43:01,730
you care about that you say is an

981
00:42:59,119 --> 00:43:04,640
important theorem that it's really about

982
00:43:01,730 --> 00:43:07,580
something that is that is really the

983
00:43:04,640 --> 00:43:08,960
physical thing that you want that's the

984
00:43:07,580 --> 00:43:10,880
third question you have to ask yourself

985
00:43:08,960 --> 00:43:14,990
and the fourth question you have to ask

986
00:43:10,880 --> 00:43:19,340
yourself is is it the case that you have

987
00:43:14,990 --> 00:43:22,729
a tool supported or somehow plausibly

988
00:43:19,340 --> 00:43:24,830
practical way of relating the property

989
00:43:22,730 --> 00:43:26,900
to the model of the system underneath

990
00:43:24,830 --> 00:43:28,279
you have to be able to answer all four

991
00:43:26,900 --> 00:43:33,830
of those questions if they're all yes

992
00:43:28,280 --> 00:43:35,150
then formal methods is for you but if

993
00:43:33,830 --> 00:43:37,040
the answer to any of those questions is

994
00:43:35,150 --> 00:43:41,000
no then you probably have to think of

995
00:43:37,040 --> 00:43:44,750
some other way to do this problem and

996
00:43:41,000 --> 00:43:47,320
that's all I wanted to say I should let

997
00:43:44,750 --> 00:43:47,320
the moderator

998
00:43:47,950 --> 00:43:55,368
[Applause]

999
00:43:52,990 --> 00:43:57,680
we have eight minutes four minutes

1000
00:43:55,369 --> 00:44:00,440
please keep your questions brief and

1001
00:43:57,680 --> 00:44:02,509
we'll try and the answers brief - so we

1002
00:44:00,440 --> 00:44:11,119
will try to run through as many as we

1003
00:44:02,510 --> 00:44:14,450
can please come to the microphone I'm

1004
00:44:11,119 --> 00:44:16,340
Fred sho lime working on securing agile

1005
00:44:14,450 --> 00:44:18,830
devops pipeline so it's kind of

1006
00:44:16,340 --> 00:44:21,320
interested in this my question is is the

1007
00:44:18,830 --> 00:44:24,290
claim of formal methods that without

1008
00:44:21,320 --> 00:44:26,270
knowing what the input or abuse cases

1009
00:44:24,290 --> 00:44:29,000
are you can determine that the software

1010
00:44:26,270 --> 00:44:31,190
is indeed secure or do you need a clear

1011
00:44:29,000 --> 00:44:33,560
definition of what you know the abuse

1012
00:44:31,190 --> 00:44:35,480
cases are that might attack the

1013
00:44:33,560 --> 00:44:55,520
particular software that you're that

1014
00:44:35,480 --> 00:44:59,930
you're analyzing so clear as Matt

1015
00:44:55,520 --> 00:45:02,270
suggested clear idea what your security

1016
00:44:59,930 --> 00:45:04,490
property is as long as you know what

1017
00:45:02,270 --> 00:45:05,359
that is you can verify it against any

1018
00:45:04,490 --> 00:45:08,720
use case

1019
00:45:05,359 --> 00:45:09,590
all possible and check that so there

1020
00:45:08,720 --> 00:45:11,930
could be something you haven't

1021
00:45:09,590 --> 00:45:15,500
considered and indeed this is where

1022
00:45:11,930 --> 00:45:16,850
formal verification is useful this thing

1023
00:45:15,500 --> 00:45:19,520
that you didn't capture in a test case

1024
00:45:16,850 --> 00:45:23,240
will be covered by the theorem assuming

1025
00:45:19,520 --> 00:45:28,790
that your property accurately captures

1026
00:45:23,240 --> 00:45:32,540
your security requirements just to add

1027
00:45:28,790 --> 00:45:34,190
to that if you are unable to come up

1028
00:45:32,540 --> 00:45:38,390
with a precise description of your

1029
00:45:34,190 --> 00:45:40,760
security property you can also go a long

1030
00:45:38,390 --> 00:45:43,629
way by deploying some static analysis

1031
00:45:40,760 --> 00:45:46,430
tools which can for instance check

1032
00:45:43,630 --> 00:45:48,770
buffer overflow errors or memory leaks

1033
00:45:46,430 --> 00:45:51,618
which are some of the primary primary

1034
00:45:48,770 --> 00:45:53,359
reasons for security vulnerabilities so

1035
00:45:51,619 --> 00:45:56,060
you even if you are unable to come up

1036
00:45:53,359 --> 00:46:00,730
with a formal characterization of your

1037
00:45:56,060 --> 00:46:00,730
property you can still go a long way

1038
00:46:11,170 --> 00:46:19,850
hello I'm Pascal vignette for zoo I hear

1039
00:46:16,910 --> 00:46:21,710
I hear what you're saying that you can

1040
00:46:19,850 --> 00:46:24,890
prove that your system will behave

1041
00:46:21,710 --> 00:46:28,670
exactly as you're specified but what I

1042
00:46:24,890 --> 00:46:30,620
want to hear at the end of that that it

1043
00:46:28,670 --> 00:46:36,070
will do what you specified but it will

1044
00:46:30,620 --> 00:46:40,040
not do anything else and can you

1045
00:46:36,070 --> 00:46:42,500
enlighten me as to what I need to

1046
00:46:40,040 --> 00:46:44,270
specify there do I need to specify all

1047
00:46:42,500 --> 00:46:47,420
the things that I don't want to see

1048
00:46:44,270 --> 00:46:54,800
happen or do I just need to specify what

1049
00:46:47,420 --> 00:46:56,900
I want to see happen so it's a it's it's

1050
00:46:54,800 --> 00:47:00,650
kind of hard you know formal methods is

1051
00:46:56,900 --> 00:47:06,740
more of a buzzword than it is a precise

1052
00:47:00,650 --> 00:47:12,170
technology and it I think the right way

1053
00:47:06,740 --> 00:47:14,359
to think about this is that that you get

1054
00:47:12,170 --> 00:47:18,080
to describe the property that you want

1055
00:47:14,360 --> 00:47:21,200
and be able to do a proof about it but

1056
00:47:18,080 --> 00:47:23,600
but that property is just anything you

1057
00:47:21,200 --> 00:47:26,569
can write down anything that you can

1058
00:47:23,600 --> 00:47:30,279
actually get to to a proof about so if

1059
00:47:26,570 --> 00:47:33,680
you want to for example that I showed

1060
00:47:30,280 --> 00:47:36,830
take the this maybe the simpler example

1061
00:47:33,680 --> 00:47:39,710
of a microprocessor that it's describing

1062
00:47:36,830 --> 00:47:43,240
exactly the information flows that are

1063
00:47:39,710 --> 00:47:46,430
that are on that processor and it's

1064
00:47:43,240 --> 00:47:48,950
exhaustively so anything that is in

1065
00:47:46,430 --> 00:47:52,480
violation of that of those information

1066
00:47:48,950 --> 00:47:55,399
flows is is precluded by that theorem

1067
00:47:52,480 --> 00:47:57,770
from from happening so that's really

1068
00:47:55,400 --> 00:47:59,210
kind of more typically with security

1069
00:47:57,770 --> 00:48:01,400
properties you're more interested in

1070
00:47:59,210 --> 00:48:05,090
what doesn't happen as opposed to what

1071
00:48:01,400 --> 00:48:06,710
does happen so so hopefully that's

1072
00:48:05,090 --> 00:48:08,870
responsive to your question I'll make

1073
00:48:06,710 --> 00:48:11,990
one other observation when trying when

1074
00:48:08,870 --> 00:48:12,980
trying to explain using formal methods

1075
00:48:11,990 --> 00:48:16,819
to

1076
00:48:12,980 --> 00:48:20,930
product engineers one thing that I found

1077
00:48:16,820 --> 00:48:23,150
has been helpful is is your you can tell

1078
00:48:20,930 --> 00:48:25,460
them that you're adding you're adding

1079
00:48:23,150 --> 00:48:27,530
one word to their vocabulary as they

1080
00:48:25,460 --> 00:48:31,130
write their requirements and that word

1081
00:48:27,530 --> 00:48:34,099
is not write a product a product

1082
00:48:31,130 --> 00:48:40,579
engineer a system engineer typically is

1083
00:48:34,099 --> 00:48:42,500
not allowed to say this property not

1084
00:48:40,579 --> 00:48:44,329
ought to use the word not in their

1085
00:48:42,500 --> 00:48:47,420
requirements and the reason why they

1086
00:48:44,329 --> 00:48:50,570
can't say the word not is because that

1087
00:48:47,420 --> 00:48:56,210
requirement becomes untestable if you

1088
00:48:50,570 --> 00:49:00,190
say you will not generate the number 12

1089
00:48:56,210 --> 00:49:02,720
as an output well how do you test that

1090
00:49:00,190 --> 00:49:06,800
so a system engineer has been trained

1091
00:49:02,720 --> 00:49:08,328
from I'll say from birth to do not write

1092
00:49:06,800 --> 00:49:12,079
requirements that that have that

1093
00:49:08,329 --> 00:49:13,880
property when when you allow them not to

1094
00:49:12,079 --> 00:49:16,670
test things but as opposed to use

1095
00:49:13,880 --> 00:49:19,190
analysis you now allow them to add that

1096
00:49:16,670 --> 00:49:21,440
word to the to a requirement and and

1097
00:49:19,190 --> 00:49:23,030
that's a that's a that's a wonderful

1098
00:49:21,440 --> 00:49:26,599
moment when they realize that they can

1099
00:49:23,030 --> 00:49:29,540
make that change so again a quick

1100
00:49:26,599 --> 00:49:31,369
addendum to that so the answer to your

1101
00:49:29,540 --> 00:49:33,560
question is one might need to specify

1102
00:49:31,369 --> 00:49:35,960
both classes of properties and in fact

1103
00:49:33,560 --> 00:49:37,849
there are phrase names associated with

1104
00:49:35,960 --> 00:49:41,240
both classes of properties so safety

1105
00:49:37,849 --> 00:49:42,710
properties are properties that that

1106
00:49:41,240 --> 00:49:45,140
essentially specify the kinds of

1107
00:49:42,710 --> 00:49:50,599
behaviors you do not want the system to

1108
00:49:45,140 --> 00:49:53,060
have so a system is safe if it does not

1109
00:49:50,599 --> 00:49:54,950
violate the safety properties okay and

1110
00:49:53,060 --> 00:49:56,750
there are other classes of properties

1111
00:49:54,950 --> 00:49:58,970
called lightness properties or progress

1112
00:49:56,750 --> 00:50:00,920
properties where you specify that you

1113
00:49:58,970 --> 00:50:04,149
want something good to eventually happen

1114
00:50:00,920 --> 00:50:06,589
and this may not be true often for

1115
00:50:04,150 --> 00:50:08,690
security properties but in the broader

1116
00:50:06,589 --> 00:50:10,520
class of correctness properties both of

1117
00:50:08,690 --> 00:50:14,560
these properties play an important role

1118
00:50:10,520 --> 00:50:14,560
in specifying reliability

1119
00:50:14,599 --> 00:50:21,339
I think we have time for two quick

1120
00:50:17,539 --> 00:50:23,930
questions then okay Chris Clifton Perdue

1121
00:50:21,339 --> 00:50:25,849
one of my favorite examples of formal

1122
00:50:23,930 --> 00:50:29,989
designs probably predates several people

1123
00:50:25,849 --> 00:50:32,150
of the room was the AT&T 5e switch which

1124
00:50:29,989 --> 00:50:34,970
they used formal methods in design of a

1125
00:50:32,150 --> 00:50:37,130
real industrial scale product they had

1126
00:50:34,970 --> 00:50:39,799
one advantage that many companies today

1127
00:50:37,130 --> 00:50:41,869
don't have they weren't really worried

1128
00:50:39,799 --> 00:50:44,900
about someone beating them to market and

1129
00:50:41,869 --> 00:50:46,970
my question is I mean if your cost of

1130
00:50:44,900 --> 00:50:50,180
being beat to market is the entire cost

1131
00:50:46,970 --> 00:50:51,709
of the company and you can't look at

1132
00:50:50,180 --> 00:50:55,129
formal methods if they're gonna slow you

1133
00:50:51,710 --> 00:50:58,099
down to what extent are we able to

1134
00:50:55,130 --> 00:51:00,769
measure or give examples of the impact

1135
00:50:58,099 --> 00:51:03,559
on development time of formal methods

1136
00:51:00,769 --> 00:51:09,258
and show where it saves us where it

1137
00:51:03,559 --> 00:51:11,089
speeds things up well I can I can give

1138
00:51:09,259 --> 00:51:14,269
you at least one example I I keep go

1139
00:51:11,089 --> 00:51:18,140
harkening back to the to the processor

1140
00:51:14,269 --> 00:51:21,769
example the day we completed the the

1141
00:51:18,140 --> 00:51:24,319
proofs of it and then ran things through

1142
00:51:21,769 --> 00:51:27,288
there was a bunch of government people

1143
00:51:24,319 --> 00:51:28,430
that that then did an evaluation and

1144
00:51:27,289 --> 00:51:31,700
made sure that we've done the proofs

1145
00:51:28,430 --> 00:51:34,640
properly etc and I was able to very

1146
00:51:31,700 --> 00:51:37,390
happily report to the person that was

1147
00:51:34,640 --> 00:51:41,269
responsible for the large program that

1148
00:51:37,390 --> 00:51:47,479
that we had succeeded he was

1149
00:51:41,269 --> 00:51:50,089
surprisingly not happy and it took me a

1150
00:51:47,479 --> 00:51:52,399
day or two to figure out why and the

1151
00:51:50,089 --> 00:51:55,160
reason why was because we were not the

1152
00:51:52,400 --> 00:51:56,719
long pole on that process as soon as we

1153
00:51:55,160 --> 00:51:58,670
were done then it became clear that

1154
00:51:56,719 --> 00:52:01,249
there were other issues in the system

1155
00:51:58,670 --> 00:52:05,239
and and I would say this is just broadly

1156
00:52:01,249 --> 00:52:09,339
speaking that that I have I haven't seen

1157
00:52:05,239 --> 00:52:11,839
a delay introduced by doing analysis

1158
00:52:09,339 --> 00:52:15,589
there's usually other things that are

1159
00:52:11,839 --> 00:52:19,430
that are there gating large system

1160
00:52:15,589 --> 00:52:23,630
developments that's I'm only using based

1161
00:52:19,430 --> 00:52:26,419
on a few samples sample points but I in

1162
00:52:23,630 --> 00:52:27,450
my heart I don't think that doing this

1163
00:52:26,420 --> 00:52:30,750
kind of analysis

1164
00:52:27,450 --> 00:52:32,879
it will be the long pole typically in a

1165
00:52:30,750 --> 00:52:35,309
big in a pretty big product design I

1166
00:52:32,880 --> 00:52:36,809
would agree with you on the analysis I

1167
00:52:35,309 --> 00:52:39,390
would be more concerned about the

1168
00:52:36,809 --> 00:52:41,190
requirements specification at the level

1169
00:52:39,390 --> 00:52:45,750
you need in order to do that analysis

1170
00:52:41,190 --> 00:52:48,000
what does that cost we build

1171
00:52:45,750 --> 00:52:50,609
requirements for well I'm only talking

1172
00:52:48,000 --> 00:52:52,559
about the industry that I'm in but we

1173
00:52:50,609 --> 00:52:55,920
build requirements for all these systems

1174
00:52:52,559 --> 00:52:58,710
routinely so that already is it's

1175
00:52:55,920 --> 00:53:07,200
already is the case that we we need to

1176
00:52:58,710 --> 00:53:08,369
incur that cost I'm sure Molly

1177
00:53:07,200 --> 00:53:10,529
Chatterjee from video

1178
00:53:08,369 --> 00:53:13,859
so looks like formal methods have been

1179
00:53:10,530 --> 00:53:16,260
tipped the scale for cases bare safety

1180
00:53:13,859 --> 00:53:18,598
is a criteria major criteria so what's

1181
00:53:16,260 --> 00:53:20,280
really tipping the scale for use cases

1182
00:53:18,599 --> 00:53:21,000
where you know it's not really safety

1183
00:53:20,280 --> 00:53:23,280
critical

1184
00:53:21,000 --> 00:53:29,309
so what's tipping the scale there in

1185
00:53:23,280 --> 00:53:31,410
today's world so I think my security is

1186
00:53:29,309 --> 00:53:33,630
a concern and if people can pull off the

1187
00:53:31,410 --> 00:53:35,940
shelf secured by design components I

1188
00:53:33,630 --> 00:53:38,960
think that's driving it so if you can

1189
00:53:35,940 --> 00:53:41,369
have this security like if you

1190
00:53:38,960 --> 00:53:43,640
developing some autonomous vo : you can

1191
00:53:41,369 --> 00:53:46,500
just pull up SEL for off-the-shelf well

1192
00:53:43,640 --> 00:53:51,299
there's a win right security baked in

1193
00:53:46,500 --> 00:53:53,730
for free case is very you know safety is

1194
00:53:51,299 --> 00:53:55,349
not that critical it has the scale being

1195
00:53:53,730 --> 00:53:57,450
tipped and what is tipping the scale

1196
00:53:55,349 --> 00:54:00,480
factors right security is always a

1197
00:53:57,450 --> 00:54:01,859
concern you know and for me if someone

1198
00:54:00,480 --> 00:54:04,079
breaks your system and they steal credit

1199
00:54:01,859 --> 00:54:08,549
cards that again the genie is out of the

1200
00:54:04,079 --> 00:54:09,750
bottle so and I argue it I think this

1201
00:54:08,549 --> 00:54:11,069
you know the world is more

1202
00:54:09,750 --> 00:54:14,420
interconnected and so there are more

1203
00:54:11,069 --> 00:54:18,210
opportunities for G needs to be released

1204
00:54:14,420 --> 00:54:20,400
so I will wrap up with what I think is

1205
00:54:18,210 --> 00:54:22,770
the single biggest takeaway from each of

1206
00:54:20,400 --> 00:54:24,839
the panelists so with respect to Ben's

1207
00:54:22,770 --> 00:54:27,450
comments it was enlightening to me that

1208
00:54:24,839 --> 00:54:29,009
the costs are now the benefits are

1209
00:54:27,450 --> 00:54:30,660
beginning to outweigh the cause for

1210
00:54:29,010 --> 00:54:32,609
formal verification because we're able

1211
00:54:30,660 --> 00:54:35,480
to stand on the shoulders of giants

1212
00:54:32,609 --> 00:54:37,828
Roop Shah had a very nice flow of

1213
00:54:35,480 --> 00:54:38,520
software development and how you can

1214
00:54:37,829 --> 00:54:41,520
increment

1215
00:54:38,520 --> 00:54:44,160
put in formal methods so by having the

1216
00:54:41,520 --> 00:54:46,560
specification be done formally she also

1217
00:54:44,160 --> 00:54:48,960
has me worried because I thought a

1218
00:54:46,560 --> 00:54:51,210
software engineer graduate from a place

1219
00:54:48,960 --> 00:54:53,520
like Purdue you had a guaranteed job but

1220
00:54:51,210 --> 00:54:55,500
she said programs are going to start

1221
00:54:53,520 --> 00:54:59,490
writing programs and debugging programs

1222
00:54:55,500 --> 00:55:01,590
and then Matt had these four very

1223
00:54:59,490 --> 00:55:03,779
fundamental questions that he asked

1224
00:55:01,590 --> 00:55:06,930
which will allow us to figure out a

1225
00:55:03,780 --> 00:55:09,740
formal verification is the right thing

1226
00:55:06,930 --> 00:55:11,819
to use for a particular system and

1227
00:55:09,740 --> 00:55:12,779
here's the question you had all been

1228
00:55:11,820 --> 00:55:15,810
dying to ask

1229
00:55:12,780 --> 00:55:18,150
nobody asked which school do you have to

1230
00:55:15,810 --> 00:55:20,369
graduate from apart from UT Austin and

1231
00:55:18,150 --> 00:55:21,510
still be on this panel that happens to

1232
00:55:20,369 --> 00:55:24,680
the University of Illinois

1233
00:55:21,510 --> 00:55:30,500
urbana-champaign thank you

1234
00:55:24,680 --> 00:55:30,500
[Applause]

1235
00:55:38,510 --> 00:55:40,570
you

