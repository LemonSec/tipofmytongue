1
00:00:19,529 --> 00:00:25,080
good afternoon so let's get started so

2
00:00:21,510 --> 00:00:28,019
welcome to the weekly serious security

3
00:00:25,080 --> 00:00:30,060
seminar today it's my great pleasure to

4
00:00:28,019 --> 00:00:31,859
introduce professor Adam Bates from the

5
00:00:30,060 --> 00:00:34,860
University of Illinois at

6
00:00:31,859 --> 00:00:36,450
urbana-champaign adam is an assistant

7
00:00:34,860 --> 00:00:39,480
professor in the computer science

8
00:00:36,450 --> 00:00:42,390
department at UIUC he received his PhD

9
00:00:39,480 --> 00:00:44,910
from the University of Florida where he

10
00:00:42,390 --> 00:00:46,530
was advised by Professor Kevin Butler in

11
00:00:44,910 --> 00:00:47,940
the study of computer systems in

12
00:00:46,530 --> 00:00:49,890
cybersecurity

13
00:00:47,940 --> 00:00:53,370
Alan has conducted research on a variety

14
00:00:49,890 --> 00:00:56,149
of security topics including ssl/tls

15
00:00:53,370 --> 00:00:58,500
car computing USB attack vectors

16
00:00:56,149 --> 00:01:01,079
financial services and telephony

17
00:00:58,500 --> 00:01:03,500
infrastructure he's best known for his

18
00:01:01,079 --> 00:01:05,820
work in the area of data provenance

19
00:01:03,500 --> 00:01:10,140
particularly the construction of secure

20
00:01:05,820 --> 00:01:11,789
provenance aware systems great thank you

21
00:01:10,140 --> 00:01:14,070
well thanks so much I'm young it's a

22
00:01:11,790 --> 00:01:15,420
real pleasure to be here today I think

23
00:01:14,070 --> 00:01:17,309
that you know the work that comes out of

24
00:01:15,420 --> 00:01:19,080
the serious lab is you know work that I

25
00:01:17,310 --> 00:01:20,550
probably pay attention to just about as

26
00:01:19,080 --> 00:01:22,110
much if not more than you know anywhere

27
00:01:20,550 --> 00:01:23,789
anywhere else in the country so it's

28
00:01:22,110 --> 00:01:25,670
great to be here to tell you about some

29
00:01:23,790 --> 00:01:27,570
of the things that I've been working on

30
00:01:25,670 --> 00:01:29,730
so today I'm going to be talking to you

31
00:01:27,570 --> 00:01:33,660
about some of my recent work in the area

32
00:01:29,730 --> 00:01:35,370
of secure data provenance and so most of

33
00:01:33,660 --> 00:01:37,590
the room are probably wondering you know

34
00:01:35,370 --> 00:01:38,670
what is data provenance and hopefully I

35
00:01:37,590 --> 00:01:42,740
can get Vint you that it's quite

36
00:01:38,670 --> 00:01:45,000
important so in 2012 there was this

37
00:01:42,740 --> 00:01:46,440
Massachusetts drug testing laboratory

38
00:01:45,000 --> 00:01:48,870
they did a lot of work for court-ordered

39
00:01:46,440 --> 00:01:51,030
drug tests and they found that two of

40
00:01:48,870 --> 00:01:52,380
their lab technicians were they've been

41
00:01:51,030 --> 00:01:55,170
arrested for tampering with these

42
00:01:52,380 --> 00:01:56,729
court-ordered drug tests so in the

43
00:01:55,170 --> 00:02:00,030
aftermath the lab couldn't even say with

44
00:01:56,730 --> 00:02:01,410
certainty which of these test results

45
00:02:00,030 --> 00:02:02,970
had been tampered with by these corrupt

46
00:02:01,410 --> 00:02:06,929
technicians which called into question

47
00:02:02,970 --> 00:02:10,470
the authenticity of all of their results

48
00:02:06,930 --> 00:02:13,349
and with it over 40,000 drug-related

49
00:02:10,470 --> 00:02:15,090
convictions so in this situation it was

50
00:02:13,349 --> 00:02:17,939
actually a lack of data provenance that

51
00:02:15,090 --> 00:02:19,110
led to this disastrous results data

52
00:02:17,939 --> 00:02:20,970
provenance is

53
00:02:19,110 --> 00:02:23,580
metadata that's generated by a computer

54
00:02:20,970 --> 00:02:26,190
system that describes the history of the

55
00:02:23,580 --> 00:02:27,900
processing tasks its performs so we can

56
00:02:26,190 --> 00:02:30,270
look at an object's data provenance to

57
00:02:27,900 --> 00:02:32,070
determine how that data object came to

58
00:02:30,270 --> 00:02:35,070
exist in its present state which allows

59
00:02:32,070 --> 00:02:37,859
us to reason about its value or its or

60
00:02:35,070 --> 00:02:38,880
its integrity so in this case the

61
00:02:37,860 --> 00:02:41,820
provenance could have been used to

62
00:02:38,880 --> 00:02:43,620
identify those drug tests that had been

63
00:02:41,820 --> 00:02:45,750
tampered with or perhaps even more

64
00:02:43,620 --> 00:02:48,420
importantly those tests that hadn't been

65
00:02:45,750 --> 00:02:50,190
tampered with so we're probably not

66
00:02:48,420 --> 00:02:51,750
going to be able to see this very easily

67
00:02:50,190 --> 00:02:53,520
from where you're standing right here

68
00:02:51,750 --> 00:02:56,850
but you know here's an example of how we

69
00:02:53,520 --> 00:02:58,230
might model one of these provenance the

70
00:02:56,850 --> 00:03:00,420
provenance of these objects in the form

71
00:02:58,230 --> 00:03:02,340
of a relation graph so what we can see

72
00:03:00,420 --> 00:03:04,850
here is that we're starting with two

73
00:03:02,340 --> 00:03:07,470
samples a lab sample a and lab sample B

74
00:03:04,850 --> 00:03:10,140
in this next column we can see that they

75
00:03:07,470 --> 00:03:11,880
were both subjected to legitimate data

76
00:03:10,140 --> 00:03:14,160
processing results by one of our

77
00:03:11,880 --> 00:03:17,010
trustworthy technicians to produce a

78
00:03:14,160 --> 00:03:18,510
clean result a and a clean result B at

79
00:03:17,010 --> 00:03:20,489
this point though one of the corrupt

80
00:03:18,510 --> 00:03:22,140
technicians actually opened up the the

81
00:03:20,490 --> 00:03:23,580
second result with a text editor in

82
00:03:22,140 --> 00:03:25,708
order to generate one of these forged

83
00:03:23,580 --> 00:03:27,540
results so if we'd have this data

84
00:03:25,709 --> 00:03:28,890
provenance the case of the the drug

85
00:03:27,540 --> 00:03:31,019
testing facility we would have been able

86
00:03:28,890 --> 00:03:35,040
to say you know convictions based on

87
00:03:31,019 --> 00:03:37,590
results a are still legitimate whereas

88
00:03:35,040 --> 00:03:40,410
those with results B they need to be you

89
00:03:37,590 --> 00:03:42,720
know brought back into court slightly

90
00:03:40,410 --> 00:03:45,359
more recent result or slightly more

91
00:03:42,720 --> 00:03:48,840
recent motivation example why on earth

92
00:03:45,360 --> 00:03:52,110
did the DN C allow twenty thousand of

93
00:03:48,840 --> 00:03:55,050
their sensitive emails to leave their

94
00:03:52,110 --> 00:03:56,790
corporate network and fly out into the

95
00:03:55,050 --> 00:04:00,090
ether to some unknown domain in a

96
00:03:56,790 --> 00:04:01,739
foreign country right well you know the

97
00:04:00,090 --> 00:04:03,720
answer to this is complex and kind of

98
00:04:01,739 --> 00:04:05,250
spans multiple layers of computer

99
00:04:03,720 --> 00:04:08,670
security challenges but one of them is

100
00:04:05,250 --> 00:04:11,070
that you know our our network security

101
00:04:08,670 --> 00:04:13,768
functions today they don't really have

102
00:04:11,070 --> 00:04:15,870
the context necessary in order to

103
00:04:13,769 --> 00:04:18,720
examine a network packet and make a

104
00:04:15,870 --> 00:04:20,130
highly contextual decision like you know

105
00:04:18,720 --> 00:04:22,860
where did this packet come from what

106
00:04:20,130 --> 00:04:24,479
data is inside of this packet so

107
00:04:22,860 --> 00:04:26,250
provenance can provide this type of

108
00:04:24,479 --> 00:04:30,900
context and it's going to play a crucial

109
00:04:26,250 --> 00:04:32,280
role in future security mechanisms data

110
00:04:30,900 --> 00:04:34,650
provenance is effective

111
00:04:32,280 --> 00:04:36,750
of use in virtually any scenario where a

112
00:04:34,650 --> 00:04:39,750
context-sensitive decision needs to be

113
00:04:36,750 --> 00:04:42,120
made about a piece of data we might

114
00:04:39,750 --> 00:04:44,340
imagine that are actually in fact

115
00:04:42,120 --> 00:04:45,930
provenance is a strategic priority for

116
00:04:44,340 --> 00:04:48,960
the Department of Homeland Security in

117
00:04:45,930 --> 00:04:51,930
various health industries for DARPA and

118
00:04:48,960 --> 00:04:53,729
for national laboratories but just

119
00:04:51,930 --> 00:04:55,860
having this information isn't enough

120
00:04:53,730 --> 00:04:58,410
right we also need to be able to secure

121
00:04:55,860 --> 00:05:00,780
it if if these lab technicians that were

122
00:04:58,410 --> 00:05:03,360
already untrustworthy or these hackers

123
00:05:00,780 --> 00:05:04,890
are able to break into these machines it

124
00:05:03,360 --> 00:05:06,510
would surely follow that they would also

125
00:05:04,890 --> 00:05:08,400
attempt to hide their tracks by

126
00:05:06,510 --> 00:05:10,909
tampering with these these records right

127
00:05:08,400 --> 00:05:13,260
so it's important that we have a way of

128
00:05:10,910 --> 00:05:14,970
establishing trust in the correctness of

129
00:05:13,260 --> 00:05:16,950
this data provenance that we're

130
00:05:14,970 --> 00:05:19,050
collecting we also need to make sure

131
00:05:16,950 --> 00:05:21,229
that these provenance aware mechanisms

132
00:05:19,050 --> 00:05:24,570
are performant right that they're

133
00:05:21,230 --> 00:05:27,120
they're imposing a minimal overhead on

134
00:05:24,570 --> 00:05:29,010
our systems by only collecting the

135
00:05:27,120 --> 00:05:32,190
context we need while minimizing the

136
00:05:29,010 --> 00:05:33,719
capture of unnecessary information so

137
00:05:32,190 --> 00:05:35,460
today I want to talk to you about two of

138
00:05:33,720 --> 00:05:37,880
the systems that I've recently developed

139
00:05:35,460 --> 00:05:40,049
that address some key challenges

140
00:05:37,880 --> 00:05:42,900
specifically in the area of efficient

141
00:05:40,050 --> 00:05:44,820
and accurate accurate capture of this

142
00:05:42,900 --> 00:05:46,710
data provenance first I'm going to be

143
00:05:44,820 --> 00:05:48,900
talking to you about a mechanism that we

144
00:05:46,710 --> 00:05:51,930
introduced to dramatically reduce the

145
00:05:48,900 --> 00:05:54,870
the storage costs of collecting this

146
00:05:51,930 --> 00:05:56,640
fine-grained audit data through the

147
00:05:54,870 --> 00:05:59,430
introduction of a policy based

148
00:05:56,640 --> 00:06:02,099
compression mechanism and then

149
00:05:59,430 --> 00:06:03,600
subsequently I'm going to show you even

150
00:06:02,100 --> 00:06:05,039
if we're collecting this information a

151
00:06:03,600 --> 00:06:06,930
certain layer like at the operating

152
00:06:05,039 --> 00:06:08,550
system there's there's important things

153
00:06:06,930 --> 00:06:10,410
that are happening at other layers of

154
00:06:08,550 --> 00:06:12,000
our architecture that we also need

155
00:06:10,410 --> 00:06:14,850
context about and so we actually need a

156
00:06:12,000 --> 00:06:16,530
way to fuse provenance that's being

157
00:06:14,850 --> 00:06:18,419
captured from different sources and so

158
00:06:16,530 --> 00:06:21,150
I'll show you how we took the example of

159
00:06:18,419 --> 00:06:23,520
a very complex web service and

160
00:06:21,150 --> 00:06:25,469
introduced provenance functions without

161
00:06:23,520 --> 00:06:28,469
requiring any modification to the web

162
00:06:25,470 --> 00:06:31,350
service itself so before we delve into

163
00:06:28,470 --> 00:06:33,750
all that a bit more background on on

164
00:06:31,350 --> 00:06:36,000
what data provenance is as I mentioned

165
00:06:33,750 --> 00:06:38,370
it's metadata that describes the history

166
00:06:36,000 --> 00:06:40,560
of an object as it's being processed on

167
00:06:38,370 --> 00:06:42,630
the computing system this history

168
00:06:40,560 --> 00:06:44,640
details what's happened to the object

169
00:06:42,630 --> 00:06:45,900
from the time it was created in

170
00:06:44,640 --> 00:06:49,409
including how it

171
00:06:45,900 --> 00:06:50,820
came to exist in its present state so as

172
00:06:49,410 --> 00:06:53,250
I showed you before we can model

173
00:06:50,820 --> 00:06:55,219
provenance as a relationship graph and

174
00:06:53,250 --> 00:06:58,680
we have a highly simplistic one here

175
00:06:55,220 --> 00:07:01,229
there's there's three principal objects

176
00:06:58,680 --> 00:07:03,449
and our graphs these vertices are

177
00:07:01,229 --> 00:07:05,400
entities which would represent various

178
00:07:03,449 --> 00:07:08,910
kinds of data objects like files or

179
00:07:05,400 --> 00:07:11,370
sockets activities or processes and then

180
00:07:08,910 --> 00:07:13,800
also agents so what we see here in this

181
00:07:11,370 --> 00:07:16,860
graph is that this is the provenance of

182
00:07:13,800 --> 00:07:20,190
a file called output it was generated by

183
00:07:16,860 --> 00:07:21,750
some process which read into input files

184
00:07:20,190 --> 00:07:25,620
and you know by the way it was

185
00:07:21,750 --> 00:07:28,979
controlled by a particular user so as I

186
00:07:25,620 --> 00:07:31,770
mentioned having this information is one

187
00:07:28,979 --> 00:07:35,820
thing but the ability to secure it is is

188
00:07:31,770 --> 00:07:38,159
highly important given its value it

189
00:07:35,820 --> 00:07:40,669
naturally follows that data provenance

190
00:07:38,160 --> 00:07:43,500
is a ripe candidate for attack and so

191
00:07:40,669 --> 00:07:45,630
one sort of defining characteristics of

192
00:07:43,500 --> 00:07:48,660
my work in this space is that I think

193
00:07:45,630 --> 00:07:50,909
about collecting this information in the

194
00:07:48,660 --> 00:07:53,280
context of an attacker that's gained

195
00:07:50,910 --> 00:07:55,169
access to our system is aware that this

196
00:07:53,280 --> 00:07:57,150
you know this incriminating information

197
00:07:55,169 --> 00:08:01,380
is being collected about their activity

198
00:07:57,150 --> 00:08:03,599
just therefore trying to to mess with

199
00:08:01,380 --> 00:08:05,400
that right they could just attempt to

200
00:08:03,599 --> 00:08:07,500
disable the mechanism that's recording

201
00:08:05,400 --> 00:08:09,810
this data provenance avoid taking

202
00:08:07,500 --> 00:08:12,240
certain actions on the system in order

203
00:08:09,810 --> 00:08:14,639
to remain invisible to this mechanism or

204
00:08:12,240 --> 00:08:16,710
they could even attempt to inject

205
00:08:14,639 --> 00:08:19,139
uncertainty into our records in some way

206
00:08:16,710 --> 00:08:20,580
shape or form so I'm not going to talk

207
00:08:19,139 --> 00:08:22,830
about it at length today because I'd

208
00:08:20,580 --> 00:08:24,960
like to talk about some newer stuff but

209
00:08:22,830 --> 00:08:27,719
in Prior work I introduced a provenance

210
00:08:24,960 --> 00:08:29,969
collection mechanism that can reliably

211
00:08:27,720 --> 00:08:32,219
collect this data provenance in the

212
00:08:29,970 --> 00:08:35,099
presence of such an attacker called

213
00:08:32,219 --> 00:08:36,570
Linux provenance modules and for our

214
00:08:35,099 --> 00:08:38,520
purposes today you know all we need to

215
00:08:36,570 --> 00:08:40,800
understand is that this is an extension

216
00:08:38,520 --> 00:08:43,468
to the Linux operating system that

217
00:08:40,799 --> 00:08:46,589
establishes a provenance layer within

218
00:08:43,469 --> 00:08:48,270
within the system so that anytime either

219
00:08:46,589 --> 00:08:50,400
something in user space or something in

220
00:08:48,270 --> 00:08:52,620
kernel space attempts to perform any

221
00:08:50,400 --> 00:08:54,000
task that that then manipulates a

222
00:08:52,620 --> 00:08:55,920
principal kernel object

223
00:08:54,000 --> 00:08:58,899
you know virtually anything we can think

224
00:08:55,920 --> 00:09:01,610
of like files packets processes

225
00:08:58,899 --> 00:09:02,120
you know disk partitions so on and so

226
00:09:01,610 --> 00:09:04,180
forth

227
00:09:02,120 --> 00:09:06,470
we're able to record a record of it and

228
00:09:04,180 --> 00:09:09,290
so effectively what this provenance

229
00:09:06,470 --> 00:09:11,449
layer does is that it just pumps out a

230
00:09:09,290 --> 00:09:13,519
stream of information from the kernel

231
00:09:11,449 --> 00:09:16,219
which we can think of this like an ultra

232
00:09:13,519 --> 00:09:18,170
fine grained audit log and then this

233
00:09:16,220 --> 00:09:20,420
architecture and user space it processes

234
00:09:18,170 --> 00:09:23,180
it into these really nice relationship

235
00:09:20,420 --> 00:09:27,649
graphs that succinctly describe what it

236
00:09:23,180 --> 00:09:30,620
is that's happening in the system so you

237
00:09:27,649 --> 00:09:33,110
know we created this system we we proved

238
00:09:30,620 --> 00:09:35,120
that it had certain security properties

239
00:09:33,110 --> 00:09:37,639
that prevent it from being tampered with

240
00:09:35,120 --> 00:09:38,810
by that attacker I have backup slides if

241
00:09:37,639 --> 00:09:41,509
you want to ask me more questions about

242
00:09:38,810 --> 00:09:42,979
that that's fine but we also we

243
00:09:41,509 --> 00:09:44,720
evaluated we found that we could

244
00:09:42,980 --> 00:09:46,430
actually collect this information really

245
00:09:44,720 --> 00:09:47,720
quickly like without messing with the

246
00:09:46,430 --> 00:09:50,000
system's performance at all

247
00:09:47,720 --> 00:09:51,680
in fact under realistic workloads we

248
00:09:50,000 --> 00:09:52,880
could collect this this provenance

249
00:09:51,680 --> 00:09:54,888
information with just three percent

250
00:09:52,880 --> 00:09:57,500
overhead right so you know almost

251
00:09:54,889 --> 00:10:00,380
negligible not quite then we could also

252
00:09:57,500 --> 00:10:02,540
you know perform certain tricks to query

253
00:10:00,380 --> 00:10:04,759
this information really quickly on the

254
00:10:02,540 --> 00:10:07,160
order of milliseconds so even if I had

255
00:10:04,759 --> 00:10:09,199
you know these these massive files of

256
00:10:07,160 --> 00:10:11,209
days and days worth of system activity I

257
00:10:09,199 --> 00:10:14,149
could actually represent that in such a

258
00:10:11,209 --> 00:10:15,560
way that I could very quickly say well

259
00:10:14,149 --> 00:10:17,180
you know what's what's the provenance of

260
00:10:15,560 --> 00:10:19,459
this particular file and that would

261
00:10:17,180 --> 00:10:21,920
output that information so that would

262
00:10:19,459 --> 00:10:23,359
mean that as an administrator I'd be

263
00:10:21,920 --> 00:10:25,910
able to quickly figure out what's going

264
00:10:23,360 --> 00:10:28,370
on in my system there was one problem

265
00:10:25,910 --> 00:10:30,350
though and that's something that the

266
00:10:28,370 --> 00:10:31,730
serious lab has spent a lot of time

267
00:10:30,350 --> 00:10:33,139
thinking about and it's also one of the

268
00:10:31,730 --> 00:10:35,689
core challenges of what I'm going to be

269
00:10:33,139 --> 00:10:39,139
trying to answer today if we looked at

270
00:10:35,689 --> 00:10:42,589
the the storage overhead of what this

271
00:10:39,139 --> 00:10:48,319
system introduces it's quite awful right

272
00:10:42,589 --> 00:10:51,769
so this is a a 10 minute capture using

273
00:10:48,319 --> 00:10:55,459
this LPM system using a couple of

274
00:10:51,769 --> 00:10:56,779
different backends so in the let's see

275
00:10:55,459 --> 00:10:58,670
we were compiling a kernel and then

276
00:10:56,779 --> 00:11:00,920
recording the provenance of that kernel

277
00:10:58,670 --> 00:11:03,139
as it was being created so in the worst

278
00:11:00,920 --> 00:11:06,170
case if we just took that entire stream

279
00:11:03,139 --> 00:11:08,510
of information here and put it in a data

280
00:11:06,170 --> 00:11:12,050
file that generated four and a half

281
00:11:08,510 --> 00:11:12,480
gigabytes of log information in the

282
00:11:12,050 --> 00:11:15,180
course of

283
00:11:12,480 --> 00:11:17,040
minutes now now even you know with our

284
00:11:15,180 --> 00:11:20,399
naive solutions to the storage problem

285
00:11:17,040 --> 00:11:21,870
it wasn't quite that bad so we were able

286
00:11:20,399 --> 00:11:25,260
to you know we could sort in a zip file

287
00:11:21,870 --> 00:11:26,820
and all that redundancy goes away the I

288
00:11:25,260 --> 00:11:28,620
bragged about the speed with which you

289
00:11:26,820 --> 00:11:30,959
could query you know that's on the order

290
00:11:28,620 --> 00:11:33,449
of you know maybe 20 percent storage

291
00:11:30,959 --> 00:11:34,529
cost but this is obviously still a huge

292
00:11:33,449 --> 00:11:36,660
problem if we want to start thinking

293
00:11:34,529 --> 00:11:46,050
about recording this information for

294
00:11:36,660 --> 00:11:49,920
days weeks months yeah this is fancy

295
00:11:46,050 --> 00:11:51,920
just uh it does the there's a three

296
00:11:49,920 --> 00:11:55,589
percent overhead it costs that you

297
00:11:51,920 --> 00:11:58,769
quoted include the cost of compressing

298
00:11:55,589 --> 00:12:02,430
your data stream yeah yeah okay so that

299
00:11:58,769 --> 00:12:05,850
ends up not being a bottleneck okay the

300
00:12:02,430 --> 00:12:07,769
the actual cost of interposing what

301
00:12:05,850 --> 00:12:09,300
we're actually doing is we've got a hook

302
00:12:07,769 --> 00:12:11,279
architecture under the hood here that's

303
00:12:09,300 --> 00:12:14,219
interposing and all these different call

304
00:12:11,279 --> 00:12:15,870
paths in the kernel to pop the context

305
00:12:14,220 --> 00:12:18,690
read what's going on and then sort of

306
00:12:15,870 --> 00:12:21,630
pipe this out via a relatively efficient

307
00:12:18,690 --> 00:12:24,180
Linux kernel really yeah so that

308
00:12:21,630 --> 00:12:26,490
includes the storage cost but you know

309
00:12:24,180 --> 00:12:28,050
if we let's say I think I've got it

310
00:12:26,490 --> 00:12:31,709
jotted down you know if we imagine that

311
00:12:28,050 --> 00:12:34,709
this was the the amount that we need to

312
00:12:31,709 --> 00:12:38,339
store over the course of ten minutes

313
00:12:34,709 --> 00:12:40,050
then let's see that's 650 gigabytes in a

314
00:12:38,339 --> 00:12:43,319
day that's four and a half terabytes in

315
00:12:40,050 --> 00:12:45,000
a week so this raw cost of storage

316
00:12:43,319 --> 00:12:47,699
threatens to seriously undermine the

317
00:12:45,000 --> 00:12:49,350
usefulness of this information data

318
00:12:47,699 --> 00:12:51,359
provenance is difficult to store and

319
00:12:49,350 --> 00:12:55,410
it's difficult to process quickly once

320
00:12:51,360 --> 00:12:58,290
it once it grows up so we could improve

321
00:12:55,410 --> 00:12:59,300
that a bit by using a number of

322
00:12:58,290 --> 00:13:02,790
different tactics that have been

323
00:12:59,300 --> 00:13:05,040
proposed coming out of Purdue you know

324
00:13:02,790 --> 00:13:06,899
we could we could find ways to further

325
00:13:05,040 --> 00:13:09,329
compress the log we could filter events

326
00:13:06,899 --> 00:13:11,790
that don't contain any useful

327
00:13:09,329 --> 00:13:13,319
information like maybe so like temporary

328
00:13:11,790 --> 00:13:15,180
files would be an example of something

329
00:13:13,319 --> 00:13:16,680
that you know no one really cares what

330
00:13:15,180 --> 00:13:18,269
happened with that temporary file if it

331
00:13:16,680 --> 00:13:19,920
was created by one process and no one

332
00:13:18,269 --> 00:13:22,649
else ever read it so we could cut those

333
00:13:19,920 --> 00:13:25,800
things out but even in the presence of

334
00:13:22,649 --> 00:13:28,079
those techniques we're still going to

335
00:13:25,800 --> 00:13:31,649
be logging gigabytes of Providence a day

336
00:13:28,079 --> 00:13:34,008
over time so here's what I find to be

337
00:13:31,649 --> 00:13:36,420
the most frustrating thing about that

338
00:13:34,009 --> 00:13:38,569
let's take a look at you know what is it

339
00:13:36,420 --> 00:13:41,279
that's in these massive Providence logs

340
00:13:38,569 --> 00:13:42,988
in particular with the Linux provenance

341
00:13:41,279 --> 00:13:45,089
modules we're collecting Providence over

342
00:13:42,989 --> 00:13:49,110
every single thing that happens in the

343
00:13:45,089 --> 00:13:50,670
system from boot time onwards and so we

344
00:13:49,110 --> 00:13:53,279
actually have this massive relationship

345
00:13:50,670 --> 00:13:56,279
graph that stems from a single node in

346
00:13:53,279 --> 00:13:59,579
the system but if we imagine that word

347
00:13:56,279 --> 00:14:02,009
administrator that's trying to deploy a

348
00:13:59,579 --> 00:14:03,859
server or a you know a container or

349
00:14:02,009 --> 00:14:06,809
whatever else for a particular purpose

350
00:14:03,860 --> 00:14:08,160
let's say it's a web server odds are

351
00:14:06,809 --> 00:14:09,809
we're only ever really going to be

352
00:14:08,160 --> 00:14:12,269
interested about the things that

353
00:14:09,809 --> 00:14:13,939
actually pertain to you know to the

354
00:14:12,269 --> 00:14:17,040
intended use of the machine right

355
00:14:13,939 --> 00:14:19,079
meanwhile we've got you know cron jobs

356
00:14:17,040 --> 00:14:21,269
running in the background and you know

357
00:14:19,079 --> 00:14:23,248
other sorts of system noise the startup

358
00:14:21,269 --> 00:14:24,899
process you know all the things addicted

359
00:14:23,249 --> 00:14:27,509
that don't actually inform our Apache

360
00:14:24,899 --> 00:14:29,819
web server we really only care about you

361
00:14:27,509 --> 00:14:32,040
know our web server maybe a helper

362
00:14:29,819 --> 00:14:34,378
application like HD access that provides

363
00:14:32,040 --> 00:14:37,829
all four Apache maybe a database

364
00:14:34,379 --> 00:14:40,110
back-end things like that so optimally

365
00:14:37,829 --> 00:14:42,540
we'd be able to store you know just the

366
00:14:40,110 --> 00:14:44,189
information that we care about but throw

367
00:14:42,540 --> 00:14:47,099
out all of the other information that we

368
00:14:44,189 --> 00:14:48,660
need well we run into a problem here and

369
00:14:47,100 --> 00:14:50,309
this has to do with one of those

370
00:14:48,660 --> 00:14:52,379
security properties I glossed over when

371
00:14:50,309 --> 00:14:54,480
I talked about LPM and that's you know

372
00:14:52,379 --> 00:14:56,309
the matter of completeness when we

373
00:14:54,480 --> 00:14:58,649
collect this information we want to make

374
00:14:56,309 --> 00:15:00,179
sure that we have a authoritative record

375
00:14:58,649 --> 00:15:02,160
of everything that ever happened with

376
00:15:00,179 --> 00:15:05,220
regards to this particular system object

377
00:15:02,160 --> 00:15:07,529
so if we say well I only care about the

378
00:15:05,220 --> 00:15:09,209
things that Apache does what happens if

379
00:15:07,529 --> 00:15:11,519
Apache does something we don't expect

380
00:15:09,209 --> 00:15:15,268
right you know it's a long-running

381
00:15:11,519 --> 00:15:17,160
program eventually it decides to read it

382
00:15:15,269 --> 00:15:19,639
an object from somewhere else in the

383
00:15:17,160 --> 00:15:22,559
system right maybe this is actually a

384
00:15:19,639 --> 00:15:24,329
you know an unauthorized file access you

385
00:15:22,559 --> 00:15:26,160
know some bug in Apache and so it's red

386
00:15:24,329 --> 00:15:28,439
it's red a file that we didn't expect it

387
00:15:26,160 --> 00:15:30,089
to unless we were recording the

388
00:15:28,439 --> 00:15:32,219
provenance of this particular node the

389
00:15:30,089 --> 00:15:34,110
entire time then we'd be in real trouble

390
00:15:32,220 --> 00:15:35,879
here because we no longer have an

391
00:15:34,110 --> 00:15:38,040
authoritative forensic leave valid

392
00:15:35,879 --> 00:15:39,060
description of what it was that Apache

393
00:15:38,040 --> 00:15:41,880
was doing on this

394
00:15:39,060 --> 00:15:44,219
so it ends up being quite difficult to

395
00:15:41,880 --> 00:15:47,520
sort of prune out what we think of is

396
00:15:44,220 --> 00:15:49,260
uninteresting information because we

397
00:15:47,520 --> 00:15:51,030
can't make a definitive statement about

398
00:15:49,260 --> 00:15:53,580
what might eventually be interesting

399
00:15:51,030 --> 00:15:55,470
later on in the system so if we're going

400
00:15:53,580 --> 00:15:58,140
to start selectively recording this

401
00:15:55,470 --> 00:16:00,420
information in order to save space we

402
00:15:58,140 --> 00:16:02,430
need to have some idea about the future

403
00:16:00,420 --> 00:16:03,719
events that are going to happen in order

404
00:16:02,430 --> 00:16:06,300
to maintain some assurance of

405
00:16:03,720 --> 00:16:07,680
completeness so the first you know

406
00:16:06,300 --> 00:16:09,900
fundamental challenge I want to talk to

407
00:16:07,680 --> 00:16:12,599
you about today is it's just that is

408
00:16:09,900 --> 00:16:15,780
there a way that we can collect a

409
00:16:12,600 --> 00:16:18,060
complete a complete description of one

410
00:16:15,780 --> 00:16:21,170
applications activity while safely

411
00:16:18,060 --> 00:16:24,569
ignoring that of other system activities

412
00:16:21,170 --> 00:16:26,760
so it turns out there is we propose that

413
00:16:24,570 --> 00:16:29,310
mandatory access control provides

414
00:16:26,760 --> 00:16:31,920
exactly an environment in which this

415
00:16:29,310 --> 00:16:34,199
challenge can be overcome in a Mac

416
00:16:31,920 --> 00:16:36,569
enabled system every object - signed a

417
00:16:34,200 --> 00:16:38,370
security label and there's a policy that

418
00:16:36,570 --> 00:16:40,500
dictates the permissible interactions

419
00:16:38,370 --> 00:16:43,260
between those different system objects

420
00:16:40,500 --> 00:16:45,360
so if we can figure out a set of system

421
00:16:43,260 --> 00:16:48,930
labels that can appear within an

422
00:16:45,360 --> 00:16:51,030
applications provenance history and only

423
00:16:48,930 --> 00:16:52,890
require collect provenance for objects

424
00:16:51,030 --> 00:16:54,630
that are assigned that label we should

425
00:16:52,890 --> 00:16:56,490
be able to safely filter out the

426
00:16:54,630 --> 00:16:59,280
provenance of any other things that are

427
00:16:56,490 --> 00:17:01,560
happening in the system so this figure

428
00:16:59,280 --> 00:17:04,079
on the screen here provides an intuition

429
00:17:01,560 --> 00:17:06,990
of you know what it is that we're

430
00:17:04,079 --> 00:17:08,310
proposing here as I showed you down here

431
00:17:06,990 --> 00:17:09,660
we've got you know another sample

432
00:17:08,310 --> 00:17:11,099
provenance graph that shows some

433
00:17:09,660 --> 00:17:13,020
relationships between different objects

434
00:17:11,099 --> 00:17:15,480
in the system but we can also take a

435
00:17:13,020 --> 00:17:18,480
security policy and model it as an

436
00:17:15,480 --> 00:17:20,220
information flow graph so as provenance

437
00:17:18,480 --> 00:17:22,079
is a history of what happens in a system

438
00:17:20,220 --> 00:17:24,060
an information flow graph can be thought

439
00:17:22,079 --> 00:17:26,040
of it's like a future of permissible

440
00:17:24,060 --> 00:17:28,590
actions on the system and we can

441
00:17:26,040 --> 00:17:30,960
actually overlay the information flow

442
00:17:28,590 --> 00:17:32,429
graph onto the history of events in

443
00:17:30,960 --> 00:17:34,710
order to make informed decisions about

444
00:17:32,430 --> 00:17:36,990
what it is that we need to collect on

445
00:17:34,710 --> 00:17:38,700
the system so you know in other words

446
00:17:36,990 --> 00:17:40,980
we're going to analyze the relationships

447
00:17:38,700 --> 00:17:43,200
that exist within the information flow

448
00:17:40,980 --> 00:17:45,150
plane in order to filter out the

449
00:17:43,200 --> 00:17:47,880
activity of what are effectively

450
00:17:45,150 --> 00:17:52,410
unreachable objects in the provenance

451
00:17:47,880 --> 00:17:52,950
plane so using the Linux Providence

452
00:17:52,410 --> 00:17:55,170
modules

453
00:17:52,950 --> 00:17:58,440
framework unsurprisingly it's modular

454
00:17:55,170 --> 00:18:00,330
right we we implemented a mechanism that

455
00:17:58,440 --> 00:18:09,870
enables this functionality that we call

456
00:18:00,330 --> 00:18:13,110
provenance walls yeah here we go do you

457
00:18:09,870 --> 00:18:15,120
assume that the system has not been

458
00:18:13,110 --> 00:18:16,919
compromised because if I understand

459
00:18:15,120 --> 00:18:19,219
correctly if the system has been

460
00:18:16,920 --> 00:18:22,050
compromised then some of the Mac policy

461
00:18:19,220 --> 00:18:24,120
enforcement may not be working properly

462
00:18:22,050 --> 00:18:26,340
and then you start to see kind of

463
00:18:24,120 --> 00:18:28,979
information flow going rampant or going

464
00:18:26,340 --> 00:18:30,470
out of their regular pattern right but

465
00:18:28,980 --> 00:18:35,390
that's exactly the moment when we need

466
00:18:30,470 --> 00:18:35,390
problems yeah yeah so the question was

467
00:18:35,510 --> 00:18:41,310
effectively are we trusting the kernel

468
00:18:37,740 --> 00:18:43,640
exactly so why exactly or any peer read

469
00:18:41,310 --> 00:18:46,020
any of the offices that are running

470
00:18:43,640 --> 00:18:48,090
right as my typing comfortable so I

471
00:18:46,020 --> 00:18:52,970
would argue that you know probably one

472
00:18:48,090 --> 00:18:55,320
of the one of the primary reasons for

473
00:18:52,970 --> 00:18:57,870
enabling mandatory access control is to

474
00:18:55,320 --> 00:19:00,510
assure kernel integrity right so by no

475
00:18:57,870 --> 00:19:05,639
means right kind of a situation yeah I

476
00:19:00,510 --> 00:19:09,780
guess so so the the the issue of

477
00:19:05,640 --> 00:19:11,340
providing a 100% correct security policy

478
00:19:09,780 --> 00:19:13,620
is somewhat our thuggin all to the work

479
00:19:11,340 --> 00:19:16,459
but you know what what does mandatory

480
00:19:13,620 --> 00:19:20,580
access control bias normally well it

481
00:19:16,460 --> 00:19:22,590
hopefully buys us kernel integrity right

482
00:19:20,580 --> 00:19:24,270
certainly like a full-featured Linux

483
00:19:22,590 --> 00:19:26,879
security module like selinux you know

484
00:19:24,270 --> 00:19:28,860
has a as a default policy that is

485
00:19:26,880 --> 00:19:31,590
somewhat permissive in user space but

486
00:19:28,860 --> 00:19:33,629
it's supposed to harden anything related

487
00:19:31,590 --> 00:19:35,659
to interactions with kernel subjects and

488
00:19:33,630 --> 00:19:38,520
kernel objects and then an additional

489
00:19:35,660 --> 00:19:40,260
additionally and selinux applications

490
00:19:38,520 --> 00:19:42,030
can define their own policies to permit

491
00:19:40,260 --> 00:19:43,740
what's supposed to be happening on the

492
00:19:42,030 --> 00:19:47,250
system creating these subdomains of

493
00:19:43,740 --> 00:19:49,290
system activity so there's sort of two

494
00:19:47,250 --> 00:19:51,480
concerns that the Mac is trying to solve

495
00:19:49,290 --> 00:19:54,270
for us both of both of which are least

496
00:19:51,480 --> 00:19:55,740
privileged in the end so we certainly

497
00:19:54,270 --> 00:19:58,139
want to make sure that our kernel isn't

498
00:19:55,740 --> 00:19:59,430
compromised and it is indeed game over

499
00:19:58,140 --> 00:20:02,070
if that's the case but another thing

500
00:19:59,430 --> 00:20:04,410
that we want one arm under mandatory

501
00:20:02,070 --> 00:20:05,990
access control to enable is least

502
00:20:04,410 --> 00:20:08,480
privilege in user space you know

503
00:20:05,990 --> 00:20:11,030
Apache is compromised it should only be

504
00:20:08,480 --> 00:20:12,860
able to do things that Apache supposed

505
00:20:11,030 --> 00:20:14,510
to do it shouldn't be able to interact

506
00:20:12,860 --> 00:20:15,800
with the rest of the system now if

507
00:20:14,510 --> 00:20:17,450
something really important like Apache

508
00:20:15,800 --> 00:20:19,428
is compromised there's all sorts of bad

509
00:20:17,450 --> 00:20:21,230
things that can happen within you know

510
00:20:19,429 --> 00:20:22,910
the the confined space that Apaches

511
00:20:21,230 --> 00:20:26,420
permitted so we still care about the

512
00:20:22,910 --> 00:20:27,530
provenance of that mechanism but so I

513
00:20:26,420 --> 00:20:29,720
guess that's a long answer to your

514
00:20:27,530 --> 00:20:32,389
question you know in short yeah we're

515
00:20:29,720 --> 00:20:35,000
we're assuming that the kernels correct

516
00:20:32,390 --> 00:20:37,040
at the time of installation we do want

517
00:20:35,000 --> 00:20:40,220
to account for attacks on kernel

518
00:20:37,040 --> 00:20:41,659
integrity but you know our leveraging on

519
00:20:40,220 --> 00:20:44,150
past work is you know effectively how we

520
00:20:41,660 --> 00:20:46,160
do that right so here's here's another

521
00:20:44,150 --> 00:20:49,250
look at what LPM kind of looks like

522
00:20:46,160 --> 00:20:50,960
under the hood we have effectively a

523
00:20:49,250 --> 00:20:53,650
second reference monitor on the system

524
00:20:50,960 --> 00:20:56,450
where things are happening in user space

525
00:20:53,650 --> 00:20:58,250
if the security mechanisms and the

526
00:20:56,450 --> 00:21:00,559
kernel allow it then we're going to

527
00:20:58,250 --> 00:21:03,980
record provenance for that operation

528
00:21:00,559 --> 00:21:05,570
before it occurs and in store it so what

529
00:21:03,980 --> 00:21:07,760
provenance walls does it's sort of Bad's

530
00:21:05,570 --> 00:21:09,230
you know what I'm going to slightly

531
00:21:07,760 --> 00:21:10,760
inappropriately call a training face

532
00:21:09,230 --> 00:21:13,610
because there's no machine learning here

533
00:21:10,760 --> 00:21:15,530
but so we have a policy generator for

534
00:21:13,610 --> 00:21:18,050
for data provenance that takes his input

535
00:21:15,530 --> 00:21:20,420
the security policy of the system oops

536
00:21:18,050 --> 00:21:22,159
our screen and then also a minimal

537
00:21:20,420 --> 00:21:24,080
amount of administrator preference

538
00:21:22,160 --> 00:21:25,700
something like you know what application

539
00:21:24,080 --> 00:21:27,830
is it that I care about on the system

540
00:21:25,700 --> 00:21:29,600
so given the security policy and the

541
00:21:27,830 --> 00:21:31,428
administrator's preferences we generate

542
00:21:29,600 --> 00:21:34,250
a provenance policy that's loaded into

543
00:21:31,429 --> 00:21:37,040
the kernel and at that point whenever a

544
00:21:34,250 --> 00:21:40,309
new event occurs the provenance monitor

545
00:21:37,040 --> 00:21:41,840
is going to pop the security contexts of

546
00:21:40,309 --> 00:21:43,820
the objects involved in that event

547
00:21:41,840 --> 00:21:47,120
decide whether or not they match the

548
00:21:43,820 --> 00:21:49,070
prop of the provenance policy and if and

549
00:21:47,120 --> 00:21:50,780
only if that is the case when we

550
00:21:49,070 --> 00:21:54,500
generate a new event otherwise the

551
00:21:50,780 --> 00:21:57,410
provenance monitor takes no action all

552
00:21:54,500 --> 00:21:59,510
right so that's the that's the goal of

553
00:21:57,410 --> 00:22:02,300
the system now we need to figure out

554
00:21:59,510 --> 00:22:04,070
like how do we actually you know do this

555
00:22:02,300 --> 00:22:05,690
what what is formally the goal that

556
00:22:04,070 --> 00:22:08,240
we're trying to provide when we say I

557
00:22:05,690 --> 00:22:11,150
want to collect everything I need and in

558
00:22:08,240 --> 00:22:12,950
depth nothing that I don't so for that

559
00:22:11,150 --> 00:22:14,570
we're going to need to introduce a

560
00:22:12,950 --> 00:22:16,760
little bit of notation and define a

561
00:22:14,570 --> 00:22:18,310
couple of you know formal formal

562
00:22:16,760 --> 00:22:20,710
properties so

563
00:22:18,310 --> 00:22:23,889
let's see what we got here let's say e

564
00:22:20,710 --> 00:22:26,890
is the set of all event tuples that that

565
00:22:23,890 --> 00:22:31,140
happen in the system G is a provenance

566
00:22:26,890 --> 00:22:34,210
graph that describes the execution of e

567
00:22:31,140 --> 00:22:35,830
now I is a subset of E and those are the

568
00:22:34,210 --> 00:22:37,630
things that the administrator actually

569
00:22:35,830 --> 00:22:39,100
cares about so we might imagine you know

570
00:22:37,630 --> 00:22:41,170
all of the event tuples that inform

571
00:22:39,100 --> 00:22:43,480
Apache and then finally we have a

572
00:22:41,170 --> 00:22:45,820
provenance function P which is

573
00:22:43,480 --> 00:22:48,250
effectively a query it returns all of

574
00:22:45,820 --> 00:22:51,370
the events in G that pertain to the

575
00:22:48,250 --> 00:22:54,190
history of a particular object so before

576
00:22:51,370 --> 00:22:58,060
our goal was was completeness for every

577
00:22:54,190 --> 00:23:01,300
object X that we can find in our set of

578
00:22:58,060 --> 00:23:03,429
two event tuples we need to return all

579
00:23:01,300 --> 00:23:06,700
of the other events that pertain to that

580
00:23:03,430 --> 00:23:10,090
particular object we can begin to relax

581
00:23:06,700 --> 00:23:12,430
that by saying okay if you're an object

582
00:23:10,090 --> 00:23:14,919
X that appears in the set of events that

583
00:23:12,430 --> 00:23:17,140
I actually care about then we need to

584
00:23:14,920 --> 00:23:19,540
return everything unbe time undefined

585
00:23:17,140 --> 00:23:21,010
behavior if you're not in the set I and

586
00:23:19,540 --> 00:23:23,950
then what we're striving for with

587
00:23:21,010 --> 00:23:26,050
provenance walls if you are in the set

588
00:23:23,950 --> 00:23:28,420
of interesting things return everything

589
00:23:26,050 --> 00:23:32,110
if you are not in the set of interesting

590
00:23:28,420 --> 00:23:34,810
things then returned nothing all right

591
00:23:32,110 --> 00:23:37,600
so given that definition we now need a

592
00:23:34,810 --> 00:23:39,760
means of partitioning the set of Mac

593
00:23:37,600 --> 00:23:42,939
labels so that for particular target

594
00:23:39,760 --> 00:23:46,720
application s the policy satisfies this

595
00:23:42,940 --> 00:23:48,580
property of minimal completeness so as I

596
00:23:46,720 --> 00:23:51,550
pointed to our solution involves

597
00:23:48,580 --> 00:23:53,199
analyzing the system security policy in

598
00:23:51,550 --> 00:23:55,570
order to identify a set of security

599
00:23:53,200 --> 00:23:57,520
labels that constitute target

600
00:23:55,570 --> 00:24:01,480
applications trusted computing base or

601
00:23:57,520 --> 00:24:03,879
tcp so the TCB can be thought of as the

602
00:24:01,480 --> 00:24:06,700
set of objects upon which a given

603
00:24:03,880 --> 00:24:08,530
application depends and intuitively if

604
00:24:06,700 --> 00:24:10,180
we collect provenance for every single

605
00:24:08,530 --> 00:24:12,430
objects that within an applications

606
00:24:10,180 --> 00:24:14,860
trusted computing base we should have a

607
00:24:12,430 --> 00:24:20,110
complete description of that particular

608
00:24:14,860 --> 00:24:23,889
applications history all right so here's

609
00:24:20,110 --> 00:24:26,139
our solution for that we need to this is

610
00:24:23,890 --> 00:24:28,240
our solution for for calculating this

611
00:24:26,140 --> 00:24:29,920
trusted computing base first we have a

612
00:24:28,240 --> 00:24:30,850
security policy and all of the

613
00:24:29,920 --> 00:24:33,250
associated mandatory

614
00:24:30,850 --> 00:24:36,699
access control labels which we'll call L

615
00:24:33,250 --> 00:24:39,070
we have a target subject s so first we

616
00:24:36,700 --> 00:24:40,690
identify all of the subjects on the

617
00:24:39,070 --> 00:24:43,510
system that can write to the kernel

618
00:24:40,690 --> 00:24:45,310
again if you can write to my operating

619
00:24:43,510 --> 00:24:47,050
system I necessarily need to trust you

620
00:24:45,310 --> 00:24:50,050
so all of our kernel writers are

621
00:24:47,050 --> 00:24:52,870
included in our list of interested

622
00:24:50,050 --> 00:24:54,700
subjects we also have all of the

623
00:24:52,870 --> 00:24:57,639
subjects in the system that can write to

624
00:24:54,700 --> 00:24:59,290
my target applications executable again

625
00:24:57,640 --> 00:25:01,870
if you can overwrite my application

626
00:24:59,290 --> 00:25:04,020
binary then I necessarily need to

627
00:25:01,870 --> 00:25:07,870
include you in my trusted computing base

628
00:25:04,020 --> 00:25:10,030
and then finally we have T sub H which

629
00:25:07,870 --> 00:25:12,580
is the set of subjects that can write to

630
00:25:10,030 --> 00:25:15,490
my helper applications so you'll recall

631
00:25:12,580 --> 00:25:18,010
I used in my example Apache Apache Lee

632
00:25:15,490 --> 00:25:19,900
Apache actually identifies additional

633
00:25:18,010 --> 00:25:22,960
applications and subjects within its

634
00:25:19,900 --> 00:25:25,300
policy such as HT access which says you

635
00:25:22,960 --> 00:25:27,030
know this is a different entity but I

636
00:25:25,300 --> 00:25:29,860
depend on it and so we need to identify

637
00:25:27,030 --> 00:25:31,030
all of the subjects that can write to

638
00:25:29,860 --> 00:25:33,490
those helper applications

639
00:25:31,030 --> 00:25:37,090
what is the granularity of subjects are

640
00:25:33,490 --> 00:25:41,890
they processes or threats or could be

641
00:25:37,090 --> 00:25:46,060
something even smaller so a a what is

642
00:25:41,890 --> 00:25:50,260
the granularity of subjects so they are

643
00:25:46,060 --> 00:25:51,610
mapped to processes right can they can

644
00:25:50,260 --> 00:25:54,879
they be mapped at individual threads

645
00:25:51,610 --> 00:25:57,580
like I'm not sure okay

646
00:25:54,880 --> 00:26:00,190
I'd have to go look at the process

647
00:25:57,580 --> 00:26:01,899
control block remember so yeah but we're

648
00:26:00,190 --> 00:26:04,720
in the order of process substance

649
00:26:01,900 --> 00:26:06,550
basically a user will be associated with

650
00:26:04,720 --> 00:26:09,520
a particular security context and when

651
00:26:06,550 --> 00:26:10,870
that user invoked something the the

652
00:26:09,520 --> 00:26:12,820
subject label is passed on to the

653
00:26:10,870 --> 00:26:14,350
application so it's not a one-to-one

654
00:26:12,820 --> 00:26:16,149
mapping a process could run with

655
00:26:14,350 --> 00:26:18,699
different you know security labels at

656
00:26:16,150 --> 00:26:21,700
different times obviously so so these

657
00:26:18,700 --> 00:26:24,640
three groups of writers combines form

658
00:26:21,700 --> 00:26:26,830
our set of trusted subjects so to

659
00:26:24,640 --> 00:26:30,340
identify all the objects on the system

660
00:26:26,830 --> 00:26:32,500
that we trust we go through we take the

661
00:26:30,340 --> 00:26:34,990
set of untrusted subjects on the system

662
00:26:32,500 --> 00:26:37,060
and we say if none of the untrusted

663
00:26:34,990 --> 00:26:39,820
subjects can write to you then you're a

664
00:26:37,060 --> 00:26:41,320
trusted object so that gives us a

665
00:26:39,820 --> 00:26:42,760
trusted computing base which is the

666
00:26:41,320 --> 00:26:43,120
union of all the trusted subjects in the

667
00:26:42,760 --> 00:26:44,530
system

668
00:26:43,120 --> 00:26:47,379
all the trusted objects in the system

669
00:26:44,530 --> 00:26:49,360
and despite this complexity you know I

670
00:26:47,380 --> 00:26:50,770
did mention a human earlier this is

671
00:26:49,360 --> 00:26:52,990
actually the only thing that we need

672
00:26:50,770 --> 00:26:55,930
from the administrator if you can tell

673
00:26:52,990 --> 00:26:59,140
us the application that you care about

674
00:26:55,930 --> 00:27:02,440
aka the subject that you care about then

675
00:26:59,140 --> 00:27:03,880
we can identify procedurally the entire

676
00:27:02,440 --> 00:27:05,830
trusted computing base of that

677
00:27:03,880 --> 00:27:10,630
particular application by mining the

678
00:27:05,830 --> 00:27:12,389
policy so we took the system and we

679
00:27:10,630 --> 00:27:14,650
deployed it against a variety of

680
00:27:12,390 --> 00:27:17,350
applications in order to figure out what

681
00:27:14,650 --> 00:27:18,780
was going on we first considered three

682
00:27:17,350 --> 00:27:21,580
different sort of forensic investigation

683
00:27:18,780 --> 00:27:23,950
scenarios where an attack has occurred

684
00:27:21,580 --> 00:27:26,230
and an investigator wishes to attribute

685
00:27:23,950 --> 00:27:29,860
that attack to a certain agent in the

686
00:27:26,230 --> 00:27:32,559
system so for each of these cases a web

687
00:27:29,860 --> 00:27:35,229
server an FTP server and a database

688
00:27:32,559 --> 00:27:39,399
management server we went on to exploit

689
00:27:35,230 --> 00:27:42,640
DB comm and found a working exploit for

690
00:27:39,400 --> 00:27:44,830
that attack as well as the selinux

691
00:27:42,640 --> 00:27:46,929
security policy associated with each of

692
00:27:44,830 --> 00:27:49,240
these applications and then we turned

693
00:27:46,929 --> 00:27:51,370
that exploit into a workload by

694
00:27:49,240 --> 00:27:54,460
interspersing it with hundreds to

695
00:27:51,370 --> 00:27:55,570
thousands of legitimate requests we also

696
00:27:54,460 --> 00:27:57,010
considered a fundamentally different

697
00:27:55,570 --> 00:28:00,250
scenario which we thought might be

698
00:27:57,010 --> 00:28:01,780
pretty cool relevant to that of managing

699
00:28:00,250 --> 00:28:04,600
and monitoring a cloud computing

700
00:28:01,780 --> 00:28:06,639
infrastructure so here an administrator

701
00:28:04,600 --> 00:28:08,439
might wish to sort of monitor the

702
00:28:06,640 --> 00:28:11,200
configuration of their host machines

703
00:28:08,440 --> 00:28:12,880
without capturing all of the activity

704
00:28:11,200 --> 00:28:15,820
that was being generated by the guests

705
00:28:12,880 --> 00:28:17,470
in the system running within VMs since

706
00:28:15,820 --> 00:28:19,659
the VMS are isolated from the host

707
00:28:17,470 --> 00:28:24,610
through virtualization we were able to

708
00:28:19,660 --> 00:28:26,490
take the kaymu KBM policy and minimally

709
00:28:24,610 --> 00:28:29,229
modify it in order to create a

710
00:28:26,490 --> 00:28:33,210
provenance policy that represents the

711
00:28:29,230 --> 00:28:35,470
scenario and then within the vm reran a

712
00:28:33,210 --> 00:28:38,140
postmark benchmark in order to identify

713
00:28:35,470 --> 00:28:40,740
what was going on all right so here are

714
00:28:38,140 --> 00:28:40,740
results

715
00:28:40,780 --> 00:28:43,840
and so what we're effectively seeing in

716
00:28:42,580 --> 00:28:46,570
each of these domains is it's kind of a

717
00:28:43,840 --> 00:28:48,520
mixed bag in all of the forensic

718
00:28:46,570 --> 00:28:50,260
scenarios the amount with which we're

719
00:28:48,520 --> 00:28:54,730
able to reduce the size of these logs

720
00:28:50,260 --> 00:28:57,580
varied from 32 percent to almost 60

721
00:28:54,730 --> 00:28:59,410
percent in the case of the cloud

722
00:28:57,580 --> 00:29:02,490
provider though we're able to reduce the

723
00:28:59,410 --> 00:29:06,370
size of the provenance log by 90 percent

724
00:29:02,490 --> 00:29:07,570
effectively what this says is that we

725
00:29:06,370 --> 00:29:09,760
have a first of all we have a highly

726
00:29:07,570 --> 00:29:11,050
sort of domain-specific mechanism for

727
00:29:09,760 --> 00:29:12,940
savings

728
00:29:11,050 --> 00:29:14,649
it's your use case is going to depend on

729
00:29:12,940 --> 00:29:17,320
whether or not this is going to be a

730
00:29:14,650 --> 00:29:20,080
good tool for you to use in the cases of

731
00:29:17,320 --> 00:29:22,060
the forensics investigations the web

732
00:29:20,080 --> 00:29:24,550
server the FTP server and the sequel

733
00:29:22,060 --> 00:29:26,020
server that was what we cared about so

734
00:29:24,550 --> 00:29:27,850
it's not surprising that we weren't able

735
00:29:26,020 --> 00:29:31,180
to get dramatic reduction because we

736
00:29:27,850 --> 00:29:33,159
said pay attention to these things and

737
00:29:31,180 --> 00:29:34,450
so you know the background noise in the

738
00:29:33,160 --> 00:29:36,520
system was the only thing we were able

739
00:29:34,450 --> 00:29:38,430
to filter out and in some cases that was

740
00:29:36,520 --> 00:29:40,720
only a minority of what was taking place

741
00:29:38,430 --> 00:29:42,540
in the case of the cloud provider we

742
00:29:40,720 --> 00:29:44,860
actually identified a scenario in which

743
00:29:42,540 --> 00:29:46,450
the thing we cared about was actually

744
00:29:44,860 --> 00:29:49,120
generating a minimal footprint on the

745
00:29:46,450 --> 00:29:51,520
system and so we were able to see a lot

746
00:29:49,120 --> 00:29:55,090
of savings as a result of deploying this

747
00:29:51,520 --> 00:29:56,889
policy reduction technique so I'll

748
00:29:55,090 --> 00:29:59,320
mention it again here before you have to

749
00:29:56,890 --> 00:30:03,130
leave you know the cool thing about this

750
00:29:59,320 --> 00:30:06,129
is that this is a this can be easily

751
00:30:03,130 --> 00:30:07,960
composed with any of the other methods

752
00:30:06,130 --> 00:30:10,720
for reducing provenance costs that we've

753
00:30:07,960 --> 00:30:12,460
seen you know we're not making we're not

754
00:30:10,720 --> 00:30:14,710
leveraging any knowledge about common

755
00:30:12,460 --> 00:30:18,460
data processing paradigms like something

756
00:30:14,710 --> 00:30:20,650
like log GC would we're not we're not

757
00:30:18,460 --> 00:30:22,450
leveraging information about the

758
00:30:20,650 --> 00:30:25,810
internal semantics of a program like

759
00:30:22,450 --> 00:30:27,130
execution partitioning does right so you

760
00:30:25,810 --> 00:30:28,600
know the good news is while this isn't

761
00:30:27,130 --> 00:30:30,850
the total this isn't the total solution

762
00:30:28,600 --> 00:30:32,350
to our problems it plays very nicely

763
00:30:30,850 --> 00:30:36,189
with some of the other things that are

764
00:30:32,350 --> 00:30:37,330
appearing in the literature now cool so

765
00:30:36,190 --> 00:30:39,880
now I'm going to pivot and talk about

766
00:30:37,330 --> 00:30:41,949
the the second piece of work if you'd

767
00:30:39,880 --> 00:30:47,560
like to step out now I see it's about

768
00:30:41,950 --> 00:30:49,330
five o'clock okay okay great good so you

769
00:30:47,560 --> 00:30:51,330
know I've talked about using web

770
00:30:49,330 --> 00:30:54,070
applications as a motivating scenario

771
00:30:51,330 --> 00:30:54,809
throughout this talk thus far but

772
00:30:54,070 --> 00:30:57,210
there's there's a

773
00:30:54,809 --> 00:30:58,529
another pretty significant problem if

774
00:30:57,210 --> 00:31:02,730
we're trying to capture the provenance

775
00:30:58,529 --> 00:31:06,539
of a web server so what we have here is

776
00:31:02,730 --> 00:31:09,419
kind of a dummy workflow for a web

777
00:31:06,539 --> 00:31:11,999
application we've got lots of clients

778
00:31:09,419 --> 00:31:13,350
connecting the web server has some

779
00:31:11,999 --> 00:31:15,840
number of worker threads that are

780
00:31:13,350 --> 00:31:18,090
happening we've got J workers here but

781
00:31:15,840 --> 00:31:20,129
then this is you know a stateful web

782
00:31:18,090 --> 00:31:21,269
service so it's actually performing a

783
00:31:20,129 --> 00:31:24,389
lot of communication to a database

784
00:31:21,269 --> 00:31:25,590
back-end as well so you know let's let's

785
00:31:24,389 --> 00:31:27,590
think about what the provenance of an

786
00:31:25,590 --> 00:31:30,990
individual web request might look like

787
00:31:27,590 --> 00:31:32,879
you know I'm client I I send a request

788
00:31:30,990 --> 00:31:33,749
to you know facebook.com or what have

789
00:31:32,879 --> 00:31:37,289
you

790
00:31:33,749 --> 00:31:39,539
Facebook process the requests queries

791
00:31:37,289 --> 00:31:44,340
some datastore and sends me back some

792
00:31:39,539 --> 00:31:45,419
results so we might expect that our our

793
00:31:44,340 --> 00:31:48,928
provenance would look something like

794
00:31:45,419 --> 00:31:50,070
this right the the web application

795
00:31:48,929 --> 00:31:53,340
received my response

796
00:31:50,070 --> 00:31:55,769
it used some information that was

797
00:31:53,340 --> 00:31:57,360
provided by the database and then I'm

798
00:31:55,769 --> 00:31:58,379
sorry received my response at use some

799
00:31:57,360 --> 00:31:59,879
information that was provided by the

800
00:31:58,379 --> 00:32:03,090
database and then it sent me back a web

801
00:31:59,879 --> 00:32:05,100
response right so there's a problem here

802
00:32:03,090 --> 00:32:07,799
and it has to do with a semantic gap

803
00:32:05,100 --> 00:32:10,649
that exists between the operating system

804
00:32:07,799 --> 00:32:13,080
and user space this is actually what the

805
00:32:10,649 --> 00:32:16,139
provenance would look like because we

806
00:32:13,080 --> 00:32:19,189
have a whole lot of different clients

807
00:32:16,139 --> 00:32:22,320
connecting to this particular web server

808
00:32:19,190 --> 00:32:23,879
client I is if we don't understand

809
00:32:22,320 --> 00:32:25,889
what's happening under the hood in this

810
00:32:23,879 --> 00:32:27,959
web service we end up in a scenario

811
00:32:25,889 --> 00:32:30,539
where we have to conservatively assume

812
00:32:27,960 --> 00:32:33,450
that this response the response to

813
00:32:30,539 --> 00:32:35,158
client I is actually dependent on all of

814
00:32:33,450 --> 00:32:38,610
the other work that the web server did

815
00:32:35,159 --> 00:32:40,889
previously so this this this general

816
00:32:38,610 --> 00:32:44,008
problem is delightfully called a

817
00:32:40,889 --> 00:32:47,070
dependency explosion right so we've got

818
00:32:44,009 --> 00:32:49,230
all of these different all of these

819
00:32:47,070 --> 00:32:51,809
different relationships that exist in

820
00:32:49,230 --> 00:32:54,149
the provenance of this particular web

821
00:32:51,809 --> 00:32:56,908
web app it's not actually true this is

822
00:32:54,149 --> 00:32:59,820
off this is a false dependency and also

823
00:32:56,909 --> 00:33:02,820
it makes these results almost completely

824
00:32:59,820 --> 00:33:05,369
unusable and so that was a toy scenario

825
00:33:02,820 --> 00:33:07,799
right this problem only gets worse as

826
00:33:05,369 --> 00:33:08,520
our applications get more and more

827
00:33:07,799 --> 00:33:13,110
complex

828
00:33:08,520 --> 00:33:16,980
so you know what we have here is a AWS

829
00:33:13,110 --> 00:33:19,409
based or an ec2 based web app service

830
00:33:16,980 --> 00:33:21,570
and we can see or perhaps we can't see

831
00:33:19,410 --> 00:33:25,140
that you know within this figure we have

832
00:33:21,570 --> 00:33:26,820
load balancers and application servers

833
00:33:25,140 --> 00:33:28,500
we have a number of different database

834
00:33:26,820 --> 00:33:32,070
backends and we also have a test

835
00:33:28,500 --> 00:33:33,780
environment that the the serve the users

836
00:33:32,070 --> 00:33:36,480
of the developers of the service are

837
00:33:33,780 --> 00:33:39,629
using and so you know as we think about

838
00:33:36,480 --> 00:33:41,280
this dependency explosion problem if we

839
00:33:39,630 --> 00:33:43,740
if we took this work throw and sent it

840
00:33:41,280 --> 00:33:45,720
through a realistic work application we

841
00:33:43,740 --> 00:33:47,940
would just have a completely unusable

842
00:33:45,720 --> 00:33:50,070
record of that that individual rep

843
00:33:47,940 --> 00:33:51,450
request that would basically span the

844
00:33:50,070 --> 00:33:54,360
history of everything that's happened in

845
00:33:51,450 --> 00:33:56,640
the system so so this semantic gap

846
00:33:54,360 --> 00:33:58,979
problem is real at least a false

847
00:33:56,640 --> 00:34:01,140
provenance and it very much threatens to

848
00:33:58,980 --> 00:34:02,340
undermine the usefulness of these things

849
00:34:01,140 --> 00:34:05,580
that we're doing within the operating

850
00:34:02,340 --> 00:34:07,230
system so there's a lot of different

851
00:34:05,580 --> 00:34:09,239
solutions to this problem and some of

852
00:34:07,230 --> 00:34:13,080
them have been proposed by dong-young

853
00:34:09,239 --> 00:34:14,520
and in the group here it's serious we

854
00:34:13,080 --> 00:34:16,619
could instrument the application to make

855
00:34:14,520 --> 00:34:19,649
it provenance aware would be one which

856
00:34:16,619 --> 00:34:22,379
one straightforward thing to do right

857
00:34:19,649 --> 00:34:25,350
so for example in the case of Apache we

858
00:34:22,379 --> 00:34:27,239
could let us to ask Apache to let us

859
00:34:25,350 --> 00:34:29,368
know every single time it's starting to

860
00:34:27,239 --> 00:34:31,138
field a new request and that would allow

861
00:34:29,369 --> 00:34:32,909
us to decompose those individual web

862
00:34:31,139 --> 00:34:34,649
requests into autonomous units of work

863
00:34:32,909 --> 00:34:36,000
right so that's so that's something

864
00:34:34,649 --> 00:34:37,949
that's come out of here you know using

865
00:34:36,000 --> 00:34:41,639
program analysis and transformation and

866
00:34:37,949 --> 00:34:42,989
it's really great but you know

867
00:34:41,639 --> 00:34:45,330
especially when we think about this

868
00:34:42,989 --> 00:34:46,859
environment you know we don't have the

869
00:34:45,330 --> 00:34:49,500
source code for all of these different

870
00:34:46,859 --> 00:34:51,750
web components right this is all owned

871
00:34:49,500 --> 00:34:53,550
by different developers they might not

872
00:34:51,750 --> 00:34:55,409
be particularly interested in helping us

873
00:34:53,550 --> 00:34:57,869
get this fine-grained audit information

874
00:34:55,409 --> 00:35:00,630
that we want to it might violate some

875
00:34:57,869 --> 00:35:04,980
license somewhere for us to instrument

876
00:35:00,630 --> 00:35:06,540
the code in a certain way so what while

877
00:35:04,980 --> 00:35:08,190
those approaches are promising we wanted

878
00:35:06,540 --> 00:35:10,560
to adopt a slightly different usage

879
00:35:08,190 --> 00:35:13,920
model where we assumed that we didn't

880
00:35:10,560 --> 00:35:16,290
have any developer cooperation we didn't

881
00:35:13,920 --> 00:35:18,390
have access to source code and we didn't

882
00:35:16,290 --> 00:35:20,730
want to instrument any applications so

883
00:35:18,390 --> 00:35:21,710
we basically wanted our web service to

884
00:35:20,730 --> 00:35:27,109
work

885
00:35:21,710 --> 00:35:29,839
exactly is it used to without without us

886
00:35:27,109 --> 00:35:32,109
having to intercede on anything in

887
00:35:29,839 --> 00:35:34,730
practice so so this leads us to our

888
00:35:32,109 --> 00:35:36,799
second challenge of the day that I want

889
00:35:34,730 --> 00:35:38,690
to tackle with you is it possible to

890
00:35:36,800 --> 00:35:41,570
observe these application-specific

891
00:35:38,690 --> 00:35:45,380
workflows without actually needing to

892
00:35:41,570 --> 00:35:47,720
modify the application so thinking back

893
00:35:45,380 --> 00:35:51,890
to this sort of cloud-based scenario we

894
00:35:47,720 --> 00:35:54,709
thought people layer on security

895
00:35:51,890 --> 00:35:56,210
solutions to networks all the time right

896
00:35:54,710 --> 00:35:59,000
you know that's that's what our

897
00:35:56,210 --> 00:36:00,560
firewalls are and our IDs and all these

898
00:35:59,000 --> 00:36:01,570
different sort of security oriented

899
00:36:00,560 --> 00:36:05,630
middleboxes

900
00:36:01,570 --> 00:36:07,010
can we take this into this the similar

901
00:36:05,630 --> 00:36:09,200
concept of network function

902
00:36:07,010 --> 00:36:11,089
virtualization and then apply that to

903
00:36:09,200 --> 00:36:13,759
the the auditing problem as well in

904
00:36:11,089 --> 00:36:16,009
order to piece together this and so

905
00:36:13,760 --> 00:36:17,960
that's exactly what we did we we

906
00:36:16,010 --> 00:36:19,730
proposed that let's introduce some

907
00:36:17,960 --> 00:36:22,190
network provenance functions to go

908
00:36:19,730 --> 00:36:25,040
alongside our security functions and

909
00:36:22,190 --> 00:36:28,820
what these n PFS do you know the core

910
00:36:25,040 --> 00:36:30,619
insight is that an operating system

911
00:36:28,820 --> 00:36:32,180
under the hood you know it can't easily

912
00:36:30,619 --> 00:36:35,170
make sense of the internal state of an

913
00:36:32,180 --> 00:36:38,750
application but it is relatively easy to

914
00:36:35,170 --> 00:36:40,280
interpose on communications between

915
00:36:38,750 --> 00:36:42,080
different components in the system

916
00:36:40,280 --> 00:36:46,730
through you know different kinds of IPC

917
00:36:42,080 --> 00:36:49,580
or network proxies and since so many of

918
00:36:46,730 --> 00:36:52,310
these protocols that are being used to

919
00:36:49,580 --> 00:36:54,380
communicate between components is moving

920
00:36:52,310 --> 00:36:55,759
in moving in the direction of

921
00:36:54,380 --> 00:36:58,970
standardization you know we've got all

922
00:36:55,760 --> 00:37:01,400
these ubiquitous protocols like HTTP and

923
00:36:58,970 --> 00:37:03,709
sequel and different types of message

924
00:37:01,400 --> 00:37:06,109
passing protocols it actually be pretty

925
00:37:03,710 --> 00:37:07,790
straightforward to parse those in order

926
00:37:06,109 --> 00:37:09,348
to extract the the ways in which

927
00:37:07,790 --> 00:37:11,509
different components are communicating

928
00:37:09,349 --> 00:37:13,220
with each other and so if we're able to

929
00:37:11,510 --> 00:37:15,589
understand what the communications are

930
00:37:13,220 --> 00:37:16,910
we can then generate provenance that

931
00:37:15,589 --> 00:37:20,330
describes the interactions between

932
00:37:16,910 --> 00:37:24,980
components so in order to enable this

933
00:37:20,330 --> 00:37:26,810
we're going to introduce this box here

934
00:37:24,980 --> 00:37:29,089
oranges oranges the things that we've

935
00:37:26,810 --> 00:37:30,710
messed with so we have our LPM

936
00:37:29,089 --> 00:37:33,080
provenance modules in the operating

937
00:37:30,710 --> 00:37:35,269
system but between components so that we

938
00:37:33,080 --> 00:37:37,640
don't have to manipulate the actual app

939
00:37:35,269 --> 00:37:39,828
ocation of the actual database we're

940
00:37:37,640 --> 00:37:44,118
going to implement an explicit forward

941
00:37:39,829 --> 00:37:46,519
proxy that basically interposes on the

942
00:37:44,119 --> 00:37:48,709
traffic it parses the communication and

943
00:37:46,519 --> 00:37:51,558
then it generates provenance and we can

944
00:37:48,709 --> 00:37:53,209
spread these proxies all over our web

945
00:37:51,559 --> 00:37:56,630
service and have all of that information

946
00:37:53,209 --> 00:38:00,219
aggregated into an individual provenance

947
00:37:56,630 --> 00:38:02,089
datastore so what we did was we

948
00:38:00,219 --> 00:38:04,999
performed a little bit of minimal

949
00:38:02,089 --> 00:38:07,328
modification to the web server but not

950
00:38:04,999 --> 00:38:10,158
the application in order to facilitate

951
00:38:07,329 --> 00:38:11,869
execution partitioning and then for the

952
00:38:10,159 --> 00:38:13,909
rest we applied these proxies to

953
00:38:11,869 --> 00:38:15,709
interpose on components in order to

954
00:38:13,909 --> 00:38:18,679
figure out the ways that they're

955
00:38:15,709 --> 00:38:21,348
communicating with one another so here's

956
00:38:18,679 --> 00:38:23,259
a here's a example of how this how this

957
00:38:21,349 --> 00:38:25,729
workflow might be modified

958
00:38:23,259 --> 00:38:28,989
just like before we have an incoming Rev

959
00:38:25,729 --> 00:38:31,368
request that reaches our web server a

960
00:38:28,989 --> 00:38:33,109
single line of code inside of our web

961
00:38:31,369 --> 00:38:36,259
server before the application code is

962
00:38:33,109 --> 00:38:39,319
reach notifies our provenance record

963
00:38:36,259 --> 00:38:42,289
that a new unit of work has started the

964
00:38:39,319 --> 00:38:44,179
application you know parses the request

965
00:38:42,289 --> 00:38:46,249
and then sends a request out to the

966
00:38:44,179 --> 00:38:49,479
database which is intercepted by a

967
00:38:46,249 --> 00:38:51,589
database capture agent that in turn

968
00:38:49,479 --> 00:38:54,169
generates more provenance instead of fed

969
00:38:51,589 --> 00:38:56,449
into our provenance store it checks the

970
00:38:54,169 --> 00:38:58,339
return values of the database and then

971
00:38:56,449 --> 00:39:00,439
when we reach the web server again we

972
00:38:58,339 --> 00:39:02,719
notify our provenance store that this

973
00:39:00,439 --> 00:39:04,368
particular unit of work is ended so now

974
00:39:02,719 --> 00:39:06,739
we've been able to partition the

975
00:39:04,369 --> 00:39:09,289
execution of the server and moreover

976
00:39:06,739 --> 00:39:11,059
we're able to connect provide link

977
00:39:09,289 --> 00:39:13,999
ability between the different

978
00:39:11,059 --> 00:39:17,119
application components in our system all

979
00:39:13,999 --> 00:39:20,089
right so just a couple examples of what

980
00:39:17,119 --> 00:39:22,099
these what these network provenance

981
00:39:20,089 --> 00:39:23,869
functions actually do so let's take a

982
00:39:22,099 --> 00:39:26,659
look at you know how would we parse a

983
00:39:23,869 --> 00:39:29,989
sequel request in order to turn it into

984
00:39:26,659 --> 00:39:32,359
a provenance record so here let's see we

985
00:39:29,989 --> 00:39:34,880
have a select statement where we look at

986
00:39:32,359 --> 00:39:37,669
the employee ID the first name and last

987
00:39:34,880 --> 00:39:39,409
name of the employee the table where

988
00:39:37,669 --> 00:39:41,479
this information is coming from and then

989
00:39:39,409 --> 00:39:46,339
we filter our results based on other

990
00:39:41,479 --> 00:39:48,618
salary so we take the sequel query and

991
00:39:46,339 --> 00:39:48,830
then use a bison grammar to turn it into

992
00:39:48,619 --> 00:39:51,860
a

993
00:39:48,830 --> 00:39:53,960
parse tree right and it's very easy to

994
00:39:51,860 --> 00:39:55,760
see that all of the different data

995
00:39:53,960 --> 00:39:59,930
entities exist in the leaves of this

996
00:39:55,760 --> 00:40:01,310
parse tree here so our take on this is

997
00:39:59,930 --> 00:40:03,770
that obviously we want to have a record

998
00:40:01,310 --> 00:40:05,120
of the explicit data accesses that are

999
00:40:03,770 --> 00:40:08,150
happening you know like the values that

1000
00:40:05,120 --> 00:40:10,490
are being returned so we're going to

1001
00:40:08,150 --> 00:40:12,950
definitely create a record that the

1002
00:40:10,490 --> 00:40:14,390
employees ID field of the employees

1003
00:40:12,950 --> 00:40:15,799
table was accessed that the first and

1004
00:40:14,390 --> 00:40:19,790
last names field that the employees

1005
00:40:15,800 --> 00:40:21,800
table was accessed but then also we have

1006
00:40:19,790 --> 00:40:23,360
this filter function here so even though

1007
00:40:21,800 --> 00:40:24,890
we're not returning the salary we're

1008
00:40:23,360 --> 00:40:27,260
clearly leaking information about the

1009
00:40:24,890 --> 00:40:28,879
contents of the salary field right so

1010
00:40:27,260 --> 00:40:32,360
our solution to this was to extend the

1011
00:40:28,880 --> 00:40:35,030
provenance grammar to refer to these as

1012
00:40:32,360 --> 00:40:37,310
implicit data accesses and then in the

1013
00:40:35,030 --> 00:40:38,780
case of ephemeral constants and things

1014
00:40:37,310 --> 00:40:40,580
like that we don't record it at all

1015
00:40:38,780 --> 00:40:41,570
because we assume that that doesn't

1016
00:40:40,580 --> 00:40:44,630
really contain any meaningful

1017
00:40:41,570 --> 00:40:47,120
information so so based on this sort of

1018
00:40:44,630 --> 00:40:49,640
labeling we can then create a provenance

1019
00:40:47,120 --> 00:40:53,120
graph that says alright this select

1020
00:40:49,640 --> 00:40:55,549
statement made use of these three fields

1021
00:40:53,120 --> 00:40:58,580
it made implicit use of this particular

1022
00:40:55,550 --> 00:41:00,770
field and then all of these tables were

1023
00:40:58,580 --> 00:41:04,310
a member of all of these fields were a

1024
00:41:00,770 --> 00:41:05,570
member of the employees table and so you

1025
00:41:04,310 --> 00:41:07,430
know we can take that intuition and

1026
00:41:05,570 --> 00:41:09,410
apply it to a number of different

1027
00:41:07,430 --> 00:41:10,730
protocols basically any form of

1028
00:41:09,410 --> 00:41:13,190
structured data we can apply these

1029
00:41:10,730 --> 00:41:16,280
tricks to write so you know in the case

1030
00:41:13,190 --> 00:41:20,120
of some soap encoded remote procedure

1031
00:41:16,280 --> 00:41:22,070
calls again we can sort of look at the

1032
00:41:20,120 --> 00:41:24,740
body of the soap envelope in order to

1033
00:41:22,070 --> 00:41:28,850
infer what sorts of relationships exist

1034
00:41:24,740 --> 00:41:30,589
within this particular request alright

1035
00:41:28,850 --> 00:41:32,779
so we went ahead and implemented this

1036
00:41:30,590 --> 00:41:34,880
system this is a bit of a more complex

1037
00:41:32,780 --> 00:41:36,590
deployment for the different

1038
00:41:34,880 --> 00:41:38,750
applications we were continuing to

1039
00:41:36,590 --> 00:41:41,990
collect information within the operating

1040
00:41:38,750 --> 00:41:45,350
system so LPM is still out here we

1041
00:41:41,990 --> 00:41:47,990
deploy these this virtualized provenance

1042
00:41:45,350 --> 00:41:49,730
collection functions as I mentioned we

1043
00:41:47,990 --> 00:41:51,229
made a small modification to the Apache

1044
00:41:49,730 --> 00:41:54,890
web server since we didn't have

1045
00:41:51,230 --> 00:41:56,600
dong-young source code rather than uses

1046
00:41:54,890 --> 00:41:58,190
automated tool we just added a couple

1047
00:41:56,600 --> 00:42:00,020
lines of code and by a couple I mean

1048
00:41:58,190 --> 00:42:01,930
less than five so that's how

1049
00:42:00,020 --> 00:42:04,930
straightforward it was to buy us the

1050
00:42:01,930 --> 00:42:07,118
execution partitioning step and then we

1051
00:42:04,930 --> 00:42:09,220
have this provenance recorder that

1052
00:42:07,119 --> 00:42:11,099
maintains an in-memory graph of the

1053
00:42:09,220 --> 00:42:14,740
provenance of these different objects

1054
00:42:11,099 --> 00:42:17,430
all right so we tested the overhead of

1055
00:42:14,740 --> 00:42:20,259
this system against a bunch of different

1056
00:42:17,430 --> 00:42:22,390
realistic web service workloads we used

1057
00:42:20,260 --> 00:42:26,680
sort of the iconic Dell DVD store

1058
00:42:22,390 --> 00:42:29,109
benchmark rubies and wiki bench which is

1059
00:42:26,680 --> 00:42:31,690
you know what uh the what Wikimedia or

1060
00:42:29,109 --> 00:42:33,098
WikiLeaks is based off of and so in

1061
00:42:31,690 --> 00:42:36,750
spite of the fact that we're performing

1062
00:42:33,099 --> 00:42:39,910
this pretty invasive interposition on

1063
00:42:36,750 --> 00:42:41,500
these inter component communications it

1064
00:42:39,910 --> 00:42:43,299
turns out we're still able to impose a

1065
00:42:41,500 --> 00:42:46,510
relatively modest overhead on these

1066
00:42:43,300 --> 00:42:50,670
different web services just 11% and and

1067
00:42:46,510 --> 00:42:52,569
overhead on these realistic workloads so

1068
00:42:50,670 --> 00:42:54,369
you know there's an argument to be made

1069
00:42:52,569 --> 00:42:57,339
that we can use these network provenance

1070
00:42:54,369 --> 00:42:59,710
functions in order to compose a sort of

1071
00:42:57,339 --> 00:43:01,540
complete holistic view of what's

1072
00:42:59,710 --> 00:43:04,420
happening in these complex systems where

1073
00:43:01,540 --> 00:43:07,058
we don't have access to the code so what

1074
00:43:04,420 --> 00:43:09,640
does that exactly buy us

1075
00:43:07,059 --> 00:43:13,119
well one as I mentioned if we think

1076
00:43:09,640 --> 00:43:14,230
about a sequel injection attack there's

1077
00:43:13,119 --> 00:43:15,940
actually a couple different things

1078
00:43:14,230 --> 00:43:19,059
happening here right so a successful

1079
00:43:15,940 --> 00:43:22,270
sequel injection attack but you know a

1080
00:43:19,059 --> 00:43:25,020
packet is received by a web server some

1081
00:43:22,270 --> 00:43:28,299
sort of mal crafted input successfully

1082
00:43:25,020 --> 00:43:31,270
bypasses the Sanitation logic of the web

1083
00:43:28,299 --> 00:43:33,309
application and then it reaches the

1084
00:43:31,270 --> 00:43:35,319
back-end database in you know where a

1085
00:43:33,309 --> 00:43:37,690
sequel request is you know been reformed

1086
00:43:35,319 --> 00:43:40,420
in the clear so web server web

1087
00:43:37,690 --> 00:43:42,040
application database we usually need to

1088
00:43:40,420 --> 00:43:44,020
understand the provenance of all these

1089
00:43:42,040 --> 00:43:46,299
different entities in order to explain

1090
00:43:44,020 --> 00:43:50,290
the attack succinctly and so this is

1091
00:43:46,299 --> 00:43:53,460
what the network provenance functions by

1092
00:43:50,290 --> 00:43:55,630
us we can identify that a particular

1093
00:43:53,460 --> 00:43:57,760
httpd worker was associated with a

1094
00:43:55,630 --> 00:44:01,450
particular network input at a given

1095
00:43:57,760 --> 00:44:04,210
moment and then using the proxies we're

1096
00:44:01,450 --> 00:44:06,660
able to link that to the contents of the

1097
00:44:04,210 --> 00:44:10,540
sequel request so we can see here that

1098
00:44:06,660 --> 00:44:14,540
well httpd worker read in a request from

1099
00:44:10,540 --> 00:44:17,150
a particular remote host and in the ends

1100
00:44:14,540 --> 00:44:19,820
it accessed some information about our

1101
00:44:17,150 --> 00:44:22,550
credit cards right so it would be

1102
00:44:19,820 --> 00:44:26,390
relatively easy thinking back to the DNC

1103
00:44:22,550 --> 00:44:28,760
example to make a rule such as I don't

1104
00:44:26,390 --> 00:44:31,400
know much about this my system but I

1105
00:44:28,760 --> 00:44:34,160
know that you know PCI data I should

1106
00:44:31,400 --> 00:44:36,619
only be flowing to the visa network and

1107
00:44:34,160 --> 00:44:38,029
therefore if this goes to any IP address

1108
00:44:36,619 --> 00:44:40,880
that's not associated with the visa

1109
00:44:38,030 --> 00:44:43,040
Network I know something's up right so

1110
00:44:40,880 --> 00:44:45,980
we can use this to sort of perform data

1111
00:44:43,040 --> 00:44:48,680
loss prevention within the system I get

1112
00:44:45,980 --> 00:44:52,250
another example anybody anyone remember

1113
00:44:48,680 --> 00:44:56,210
what image tragic was it was a pretty

1114
00:44:52,250 --> 00:44:59,570
big pretty big deal so image magic is

1115
00:44:56,210 --> 00:45:03,320
this ludicrously pervasive image

1116
00:44:59,570 --> 00:45:05,540
processing library that's you know

1117
00:45:03,320 --> 00:45:07,100
basically the back end of everything

1118
00:45:05,540 --> 00:45:10,009
that happens on Linux in terms of

1119
00:45:07,100 --> 00:45:11,569
manipulating files or posting files so

1120
00:45:10,010 --> 00:45:14,180
it's a it's common in a lot of different

1121
00:45:11,570 --> 00:45:15,410
web services and you know in spite of

1122
00:45:14,180 --> 00:45:18,259
the fact that it's been around for

1123
00:45:15,410 --> 00:45:20,899
decades someone figured out that if you

1124
00:45:18,260 --> 00:45:25,490
send it in mal crafted input that looks

1125
00:45:20,900 --> 00:45:27,290
like this I think this is a PNG file or

1126
00:45:25,490 --> 00:45:29,720
something like that you can basically

1127
00:45:27,290 --> 00:45:31,490
perform arbitrary code execution so I

1128
00:45:29,720 --> 00:45:32,930
think this was a hot thing in like 2014

1129
00:45:31,490 --> 00:45:36,799
it's it's a little dated but it's still

1130
00:45:32,930 --> 00:45:38,600
relevant and so again you know the

1131
00:45:36,800 --> 00:45:40,790
problem here is that we were dealing

1132
00:45:38,600 --> 00:45:43,609
with some application specific semantics

1133
00:45:40,790 --> 00:45:45,440
like image magic we're also dealing with

1134
00:45:43,609 --> 00:45:48,950
the aftermath where someone's able to

1135
00:45:45,440 --> 00:45:50,660
drop the shell install rachelle on the

1136
00:45:48,950 --> 00:45:54,500
machine and do all these system commands

1137
00:45:50,660 --> 00:45:56,859
and so using this network provenance

1138
00:45:54,500 --> 00:45:59,390
virtualization thing in tandem with

1139
00:45:56,859 --> 00:46:01,549
operating system monitoring we can

1140
00:45:59,390 --> 00:46:05,420
reconstruct this very succinct

1141
00:46:01,550 --> 00:46:09,619
explanation of what happened within this

1142
00:46:05,420 --> 00:46:12,800
cross layer attack we see an HTTP

1143
00:46:09,619 --> 00:46:17,600
request I was used by one particular

1144
00:46:12,800 --> 00:46:21,140
Apache worker this is the normal

1145
00:46:17,600 --> 00:46:25,460
operation of Lib magic or sorry image

1146
00:46:21,140 --> 00:46:28,200
magic rather and then when we upload our

1147
00:46:25,460 --> 00:46:29,790
sh JPEG all of a sudden we dropped

1148
00:46:28,200 --> 00:46:32,160
hsiao and we do a bunch of nasty stuff

1149
00:46:29,790 --> 00:46:36,060
so again we could make a pretty simple

1150
00:46:32,160 --> 00:46:38,279
rule about you know how how Apache is

1151
00:46:36,060 --> 00:46:40,529
allowed to use the exec or the system

1152
00:46:38,280 --> 00:46:41,849
system call right and then you know if

1153
00:46:40,530 --> 00:46:44,640
we see that

1154
00:46:41,849 --> 00:46:46,500
oh it's using curl or it's using a bash

1155
00:46:44,640 --> 00:46:47,970
I don't think it should be doing that we

1156
00:46:46,500 --> 00:46:51,900
can sort of procedurally stop these

1157
00:46:47,970 --> 00:46:55,799
attacks in their tracks alright so I'm

1158
00:46:51,900 --> 00:46:56,849
gonna do it on time three minutes five

1159
00:46:55,800 --> 00:46:59,400
minutes all right

1160
00:46:56,849 --> 00:47:02,730
wrapping up hopefully I've shown you

1161
00:46:59,400 --> 00:47:05,540
today that provenance collection is a

1162
00:47:02,730 --> 00:47:07,380
good idea right it allows us

1163
00:47:05,540 --> 00:47:09,810
transparency into the nature of these

1164
00:47:07,380 --> 00:47:11,550
various system intrusions and especially

1165
00:47:09,810 --> 00:47:13,440
as we abandoned the idea of perfect

1166
00:47:11,550 --> 00:47:15,570
security and move into this world where

1167
00:47:13,440 --> 00:47:17,820
you know eventually a powerful attacker

1168
00:47:15,570 --> 00:47:19,320
will get in no matter what it becomes

1169
00:47:17,820 --> 00:47:21,150
really important for us to understand

1170
00:47:19,320 --> 00:47:23,670
what's happening in a system in any

1171
00:47:21,150 --> 00:47:25,560
given moment so hopefully I've shown you

1172
00:47:23,670 --> 00:47:27,630
that not only is data provenance

1173
00:47:25,560 --> 00:47:29,328
important but also that we can perform

1174
00:47:27,630 --> 00:47:33,750
various tricks to scope

1175
00:47:29,329 --> 00:47:35,069
our data collection by leveraging for

1176
00:47:33,750 --> 00:47:37,920
knowledge about how the system is going

1177
00:47:35,069 --> 00:47:39,750
to be used and also that we can sort of

1178
00:47:37,920 --> 00:47:41,069
compose data provenance that's being

1179
00:47:39,750 --> 00:47:44,390
collected all of these different sources

1180
00:47:41,069 --> 00:47:47,310
in order to solve higher-level problems

1181
00:47:44,390 --> 00:47:49,020
what's next for me I think there's all

1182
00:47:47,310 --> 00:47:50,970
sorts of domains where this

1183
00:47:49,020 --> 00:47:52,290
functionality is desperately needed and

1184
00:47:50,970 --> 00:47:54,410
so I'm looking into some more

1185
00:47:52,290 --> 00:47:57,420
domain-specific challenges their

1186
00:47:54,410 --> 00:48:00,240
containers are a thing they're very

1187
00:47:57,420 --> 00:48:01,530
important oddly enough the security

1188
00:48:00,240 --> 00:48:03,240
community doesn't seem to be all that

1189
00:48:01,530 --> 00:48:06,030
interested in them because they're

1190
00:48:03,240 --> 00:48:07,740
basically over glorified root right it's

1191
00:48:06,030 --> 00:48:11,099
you know the isolation is not impressive

1192
00:48:07,740 --> 00:48:12,540
but the the fact that people are using

1193
00:48:11,099 --> 00:48:14,670
them regardless of what the security

1194
00:48:12,540 --> 00:48:17,339
community thinks that's a reason to take

1195
00:48:14,670 --> 00:48:19,589
note so you know we have these massive

1196
00:48:17,339 --> 00:48:21,839
container clusters now that people are

1197
00:48:19,589 --> 00:48:24,210
using in order to design these very same

1198
00:48:21,839 --> 00:48:26,279
web services how can we create

1199
00:48:24,210 --> 00:48:28,530
provenance based solutions to scale the

1200
00:48:26,280 --> 00:48:30,240
to meet the demand of security concerns

1201
00:48:28,530 --> 00:48:33,480
in these kinds of data centers you know

1202
00:48:30,240 --> 00:48:35,729
what if what if the manager of my doctor

1203
00:48:33,480 --> 00:48:37,050
swarm wants to have a succinct

1204
00:48:35,730 --> 00:48:39,089
explanation in the form of data

1205
00:48:37,050 --> 00:48:39,880
provenance of literally everything

1206
00:48:39,089 --> 00:48:41,890
that's happening in the

1207
00:48:39,880 --> 00:48:43,960
data center at once clearly there's more

1208
00:48:41,890 --> 00:48:45,000
work to be done here there's also a few

1209
00:48:43,960 --> 00:48:47,289
opportunities

1210
00:48:45,000 --> 00:48:49,750
unlike wise in the Internet of Things

1211
00:48:47,289 --> 00:48:51,940
we've got sort of unique problems we've

1212
00:48:49,750 --> 00:48:53,920
got this heterogeneous computing

1213
00:48:51,940 --> 00:48:55,809
environment where again we've got all

1214
00:48:53,920 --> 00:48:58,150
these proprietary closed source systems

1215
00:48:55,809 --> 00:49:00,789
I can't jump in and replace the kernel

1216
00:48:58,150 --> 00:49:01,390
for my light bulb or something like that

1217
00:49:00,789 --> 00:49:03,309
right

1218
00:49:01,390 --> 00:49:04,930
you know surely you know a couple of

1219
00:49:03,309 --> 00:49:07,029
dedicated grad students could do it in

1220
00:49:04,930 --> 00:49:08,109
the lab but you know what what meaning

1221
00:49:07,029 --> 00:49:10,150
is that going to have like no one's

1222
00:49:08,109 --> 00:49:12,430
going to use you know my provenance of

1223
00:49:10,150 --> 00:49:15,130
where light bulb right so the challenge

1224
00:49:12,430 --> 00:49:16,720
then becomes how do we how do we record

1225
00:49:15,130 --> 00:49:19,410
this type of information in a system

1226
00:49:16,720 --> 00:49:21,669
where everything's closed source

1227
00:49:19,410 --> 00:49:24,308
nothing's running on the same platform

1228
00:49:21,670 --> 00:49:26,680
and by the way we might have you know

1229
00:49:24,309 --> 00:49:28,539
four or five different radio interfaces

1230
00:49:26,680 --> 00:49:30,640
in a single device you know Wi-Fi

1231
00:49:28,539 --> 00:49:31,839
Bluetooth ZigBee z-wave so on and so

1232
00:49:30,640 --> 00:49:33,308
forth there's there's all these

1233
00:49:31,839 --> 00:49:36,788
different channels that could be used

1234
00:49:33,309 --> 00:49:39,220
for attackers in such a system and then

1235
00:49:36,789 --> 00:49:40,690
moreover since we're cyber physical you

1236
00:49:39,220 --> 00:49:42,368
know how do we incorporate notions of

1237
00:49:40,690 --> 00:49:43,690
locality into all of this you know I

1238
00:49:42,369 --> 00:49:46,000
might have an attacker with physical

1239
00:49:43,690 --> 00:49:47,289
access to my home that's driving through

1240
00:49:46,000 --> 00:49:49,150
the neighborhood or that's you know

1241
00:49:47,289 --> 00:49:51,670
attacking over the Internet through

1242
00:49:49,150 --> 00:49:53,650
traditional means so there is there's a

1243
00:49:51,670 --> 00:49:55,240
lot of you know exciting things to

1244
00:49:53,650 --> 00:49:59,259
tackle in this area of making

1245
00:49:55,240 --> 00:50:00,669
transparent systems with that you know

1246
00:49:59,259 --> 00:50:03,190
this work wouldn't be possible without

1247
00:50:00,670 --> 00:50:05,619
my student logy at the University of

1248
00:50:03,190 --> 00:50:08,349
Illinois some of my collaborators from

1249
00:50:05,619 --> 00:50:09,670
Penn State and Lincoln and my adviser

1250
00:50:08,349 --> 00:50:13,509
Kevin Butler and colleagues at the

1251
00:50:09,670 --> 00:50:14,950
University of Florida much of the code

1252
00:50:13,509 --> 00:50:17,859
that I discussed today is available

1253
00:50:14,950 --> 00:50:19,538
online at Linux provenance org so you

1254
00:50:17,859 --> 00:50:20,890
know if you've got some course project

1255
00:50:19,539 --> 00:50:23,349
coming up in the fall and you'd like to

1256
00:50:20,890 --> 00:50:26,759
mess with this feel free with that I'll

1257
00:50:23,349 --> 00:50:26,759
take any questions thanks for your time

1258
00:50:29,459 --> 00:50:44,440
yeah I'm always going to forget that the

1259
00:50:40,469 --> 00:50:48,849
this provenance their this data

1260
00:50:44,440 --> 00:50:55,259
provenance is is stored locally on the

1261
00:50:48,849 --> 00:50:58,359
what that Providence like dispatcher

1262
00:50:55,259 --> 00:51:00,430
right either that's in like the local

1263
00:50:58,359 --> 00:51:02,589
computer or in the case of the cloud

1264
00:51:00,430 --> 00:51:03,578
cloud environment you have a separate

1265
00:51:02,589 --> 00:51:13,499
machine hmm

1266
00:51:03,579 --> 00:51:17,049
great is a an attacker an attacker could

1267
00:51:13,499 --> 00:51:22,930
like if they're if they're given X it if

1268
00:51:17,049 --> 00:51:27,038
they're allowed to execute arbitrary it

1269
00:51:22,930 --> 00:51:29,410
arbitrary commands right they could that

1270
00:51:27,039 --> 00:51:32,229
the attacker could erase this Providence

1271
00:51:29,410 --> 00:51:34,229
information right true so you know

1272
00:51:32,229 --> 00:51:36,339
there's well there's a couple things

1273
00:51:34,229 --> 00:51:37,419
part of this has to do with the fact

1274
00:51:36,339 --> 00:51:40,630
that I didn't want to spend an entire

1275
00:51:37,420 --> 00:51:43,719
day talking about LPM it's like it's

1276
00:51:40,630 --> 00:51:46,089
secure trust me so so yeah we think

1277
00:51:43,719 --> 00:51:48,400
about in a single host environment what

1278
00:51:46,089 --> 00:51:50,558
we need in order to do that the good

1279
00:51:48,400 --> 00:51:52,029
news is so first of all we are assuming

1280
00:51:50,559 --> 00:51:55,809
that mandatory access controls like

1281
00:51:52,029 --> 00:51:57,190
selinux are enabled in order to ensure

1282
00:51:55,809 --> 00:51:59,499
that you know nothing in user space

1283
00:51:57,190 --> 00:52:02,440
except for the actual trusted computing

1284
00:51:59,499 --> 00:52:04,479
base of LPM can interact with our

1285
00:52:02,440 --> 00:52:06,069
components in user space like our data

1286
00:52:04,479 --> 00:52:07,930
store or this datum and that's you know

1287
00:52:06,069 --> 00:52:09,699
receiving things from the kernel it's

1288
00:52:07,930 --> 00:52:11,709
such a simple workflow that it's very

1289
00:52:09,699 --> 00:52:14,259
easy to protect right so it's like a ten

1290
00:52:11,709 --> 00:52:16,269
line I see Linux policy that says you

1291
00:52:14,259 --> 00:52:18,430
know nothing else in user space can mess

1292
00:52:16,269 --> 00:52:20,430
with this so since it's not Network

1293
00:52:18,430 --> 00:52:22,930
facing we have a pretty reasonable

1294
00:52:20,430 --> 00:52:25,690
although not a verifiable guarantee that

1295
00:52:22,930 --> 00:52:28,299
we should expect these things to operate

1296
00:52:25,690 --> 00:52:30,640
unperturbed in this case we're we're

1297
00:52:28,299 --> 00:52:33,249
introducing these network facing middle

1298
00:52:30,640 --> 00:52:35,319
boxes things are a little dicey ER and

1299
00:52:33,249 --> 00:52:36,299
we we don't fully have an account for

1300
00:52:35,319 --> 00:52:38,519
that

1301
00:52:36,299 --> 00:52:39,779
you know the closest hand-wavy argument

1302
00:52:38,519 --> 00:52:43,169
i could provide to you is that these

1303
00:52:39,779 --> 00:52:44,549
things are I think this one's on the

1304
00:52:43,169 --> 00:52:46,049
order of a couple thousand lines of code

1305
00:52:44,549 --> 00:52:48,329
and this one's on the order of like five

1306
00:52:46,049 --> 00:52:51,329
hundred lines of code so there's not

1307
00:52:48,329 --> 00:52:53,639
there's not too much room for a you know

1308
00:52:51,329 --> 00:52:55,289
we could conceivably sort of formally

1309
00:52:53,639 --> 00:52:57,659
verify these although I had no intention

1310
00:52:55,289 --> 00:52:59,309
of doing so right so you know we could

1311
00:52:57,659 --> 00:53:02,669
we could take a look at this and make it

1312
00:52:59,309 --> 00:53:05,399
a look at hardness pretty the attacker

1313
00:53:02,669 --> 00:53:08,209
could could modify it could modify the

1314
00:53:05,399 --> 00:53:11,699
stuff so it to throw you know people

1315
00:53:08,209 --> 00:53:14,428
forensics forensics off the trail of

1316
00:53:11,699 --> 00:53:19,319
like they could put they sounds like it

1317
00:53:14,429 --> 00:53:21,599
sounds like potentially you know if if

1318
00:53:19,319 --> 00:53:25,589
someone just you know wipes out your

1319
00:53:21,599 --> 00:53:26,759
your your database that you're storing

1320
00:53:25,589 --> 00:53:30,058
all the stuff and that's pretty obvious

1321
00:53:26,759 --> 00:53:34,169
but someone could perhaps modify modify

1322
00:53:30,059 --> 00:53:36,509
the existing provenance information so

1323
00:53:34,169 --> 00:53:38,489
that it hides the fact that the stuff

1324
00:53:36,509 --> 00:53:40,649
was modified right yeah that's I mean

1325
00:53:38,489 --> 00:53:41,759
that's a that's a huge concern and so

1326
00:53:40,649 --> 00:53:43,348
that's what we're trying to account for

1327
00:53:41,759 --> 00:53:45,419
with these different security guarantees

1328
00:53:43,349 --> 00:53:48,119
so we have an answer for that in the

1329
00:53:45,419 --> 00:53:49,888
single host environment effectively the

1330
00:53:48,119 --> 00:53:52,499
only way for you to manipulate the log

1331
00:53:49,889 --> 00:53:54,269
is to actually perform an action so it's

1332
00:53:52,499 --> 00:53:55,919
not really manipulation there's not a

1333
00:53:54,269 --> 00:53:58,138
way for them to you know claim they did

1334
00:53:55,919 --> 00:54:01,199
something that they didn't because of

1335
00:53:58,139 --> 00:54:03,209
the way that we're interposing on kernel

1336
00:54:01,199 --> 00:54:04,979
operations the only way that something

1337
00:54:03,209 --> 00:54:08,848
winds up in the log is if it actually

1338
00:54:04,979 --> 00:54:10,529
occurred so if you inject a bunch of

1339
00:54:08,849 --> 00:54:12,929
noise to make it confusing as to what

1340
00:54:10,529 --> 00:54:15,089
your intent was like you know we yeah we

1341
00:54:12,929 --> 00:54:16,199
need to account for that but also we

1342
00:54:15,089 --> 00:54:17,578
would still have an accurate description

1343
00:54:16,199 --> 00:54:21,719
of what it was that you were doing

1344
00:54:17,579 --> 00:54:24,119
similarly here we're we're assuming that

1345
00:54:21,719 --> 00:54:26,399
we've enforced some sort of some Network

1346
00:54:24,119 --> 00:54:29,189
flow rules such that the database can't

1347
00:54:26,399 --> 00:54:30,868
be by that the the middle box can't be

1348
00:54:29,189 --> 00:54:33,178
bypassed in order to reach the database

1349
00:54:30,869 --> 00:54:35,189
right so that we should have an accurate

1350
00:54:33,179 --> 00:54:37,889
description of the events that happened

1351
00:54:35,189 --> 00:54:41,038
what it would cryptographic signatures

1352
00:54:37,889 --> 00:54:43,169
of the of the Providence data with that

1353
00:54:41,039 --> 00:54:47,189
it with that L so that's something else

1354
00:54:43,169 --> 00:54:49,180
that we've looked at so in particular if

1355
00:54:47,189 --> 00:54:50,799
we you know if

1356
00:54:49,180 --> 00:54:52,538
we're not relying on this core root of

1357
00:54:50,799 --> 00:54:53,740
trust which is the operating system and

1358
00:54:52,539 --> 00:54:56,020
there's arguments for you not wanting to

1359
00:54:53,740 --> 00:54:57,939
do that we might want you know for in an

1360
00:54:56,020 --> 00:54:59,770
environment where we have a network data

1361
00:54:57,940 --> 00:55:03,460
center and we assume that anything's

1362
00:54:59,770 --> 00:55:05,559
subject to Byzantine faults some some of

1363
00:55:03,460 --> 00:55:07,119
my collaborators have shown that you can

1364
00:55:05,559 --> 00:55:08,799
actually get some pretty good guarantees

1365
00:55:07,119 --> 00:55:10,539
through using a message commitment

1366
00:55:08,799 --> 00:55:13,538
protocol which signs up on every packet

1367
00:55:10,539 --> 00:55:15,220
and as long as there was at least one

1368
00:55:13,539 --> 00:55:17,799
remaining good note in the system that

1369
00:55:15,220 --> 00:55:19,629
saw what the bad node did then you can

1370
00:55:17,799 --> 00:55:20,950
still figure out that you know something

1371
00:55:19,630 --> 00:55:22,119
bad is going on in your network so yeah

1372
00:55:20,950 --> 00:55:24,788
that's something else that uh that's

1373
00:55:22,119 --> 00:55:28,690
that's happening in the field yeah cool

1374
00:55:24,789 --> 00:55:30,369
any other questions great thanks for

1375
00:55:28,690 --> 00:55:32,849
your time everyone suppose you're

1376
00:55:30,369 --> 00:55:32,849
speaking with you

1377
00:55:42,609 --> 00:55:44,670
you

