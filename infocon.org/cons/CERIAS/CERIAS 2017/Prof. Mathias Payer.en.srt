1
00:00:04,540 --> 00:00:11,139
our speaker is Mattias payer Mattias is

2
00:00:08,620 --> 00:00:12,969
a brilliant professor in computer

3
00:00:11,139 --> 00:00:15,940
science to go along with all the rest of

4
00:00:12,970 --> 00:00:18,359
the brilliant faculty we have so we will

5
00:00:15,940 --> 00:00:20,999
get him started in just a second and

6
00:00:18,359 --> 00:00:29,079
appreciate your attention and we'll

7
00:00:20,999 --> 00:00:31,119
continue on citize I I know I'm standing

8
00:00:29,079 --> 00:00:33,130
between you and lunch but I hope I can

9
00:00:31,119 --> 00:00:35,740
still make it interesting and worthwhile

10
00:00:33,130 --> 00:00:39,010
for you to listen to me this will be a

11
00:00:35,740 --> 00:00:41,410
more technical talk as cherry introduced

12
00:00:39,010 --> 00:00:43,780
me I'm Matthias Pryor I'm faculty here

13
00:00:41,410 --> 00:00:46,929
at Purdue and a TS Department and

14
00:00:43,780 --> 00:00:48,880
affiliated with Sirius and my group we

15
00:00:46,930 --> 00:00:51,100
are protecting applications in the

16
00:00:48,880 --> 00:00:53,020
presence of vulnerabilities so this is

17
00:00:51,100 --> 00:00:55,480
an interesting and slightly different

18
00:00:53,020 --> 00:00:57,900
approach from what we heard before so in

19
00:00:55,480 --> 00:01:01,059
comparison what antivirus systems or

20
00:00:57,900 --> 00:01:04,119
tripwire do they detect the modification

21
00:01:01,060 --> 00:01:07,090
of files or they detect if there's some

22
00:01:04,119 --> 00:01:09,520
integrity violation what we are focusing

23
00:01:07,090 --> 00:01:12,550
on is on the other hand we detect an

24
00:01:09,520 --> 00:01:14,619
active exploit before the attacker can

25
00:01:12,550 --> 00:01:16,810
actually do any harm if you think about

26
00:01:14,620 --> 00:01:18,700
it if the attacker is modifying files or

27
00:01:16,810 --> 00:01:20,380
modifying data on your system

28
00:01:18,700 --> 00:01:23,290
the attacker already has a set of

29
00:01:20,380 --> 00:01:24,310
capabilities you might need these

30
00:01:23,290 --> 00:01:26,350
additional checks and they are

31
00:01:24,310 --> 00:01:29,110
complementing the work that we do but we

32
00:01:26,350 --> 00:01:32,190
protect an active exploitation before

33
00:01:29,110 --> 00:01:35,770
the attacker gets any computational

34
00:01:32,190 --> 00:01:40,229
guarantees or can do any harm on your

35
00:01:35,770 --> 00:01:43,770
system the a lot of the work is done by

36
00:01:40,229 --> 00:01:46,330
the students in my group and I would

37
00:01:43,770 --> 00:01:48,369
redirect all the praise to them so

38
00:01:46,330 --> 00:01:50,260
there's 12 awesome students working in

39
00:01:48,369 --> 00:01:52,810
different forms of both compiler based

40
00:01:50,260 --> 00:01:54,790
and binary-only based mechanisms where

41
00:01:52,810 --> 00:01:56,590
we try to complement these if you think

42
00:01:54,790 --> 00:02:00,700
about it if you develop defense

43
00:01:56,590 --> 00:02:02,890
mechanisms if you work on a compiler you

44
00:02:00,700 --> 00:02:04,299
get more information you get source code

45
00:02:02,890 --> 00:02:06,700
you get all these other capabilities

46
00:02:04,299 --> 00:02:09,519
that you can work on but there's always

47
00:02:06,700 --> 00:02:10,810
this one single binary or library that

48
00:02:09,519 --> 00:02:13,180
you are using there is a custom

49
00:02:10,810 --> 00:02:15,400
off-the-shelf library so for an

50
00:02:13,180 --> 00:02:16,959
effective and efficient solution you

51
00:02:15,400 --> 00:02:18,909
have to support both

52
00:02:16,959 --> 00:02:22,239
and actually support the binary-only

53
00:02:18,909 --> 00:02:24,849
solutions that's all for this talk here

54
00:02:22,239 --> 00:02:26,349
I wanted to use the time to tell you a

55
00:02:24,849 --> 00:02:28,000
little bit about control flow hi

56
00:02:26,349 --> 00:02:30,488
checking at different forms of attacks

57
00:02:28,000 --> 00:02:32,409
and we've looked at defense mechanisms

58
00:02:30,489 --> 00:02:34,750
that we have deployed on our systems and

59
00:02:32,409 --> 00:02:37,388
you likely know address space layout

60
00:02:34,750 --> 00:02:40,060
randomization or aslr data execution

61
00:02:37,389 --> 00:02:41,739
prevention or DEP and stack canneries

62
00:02:40,060 --> 00:02:43,689
which are common defense mechanisms that

63
00:02:41,739 --> 00:02:47,069
have been deployed in our systems over

64
00:02:43,689 --> 00:02:49,989
the last 10 or 15 years and we've made

65
00:02:47,069 --> 00:02:51,970
likely some progress but can we quantify

66
00:02:49,989 --> 00:02:54,220
the process how much harder is it now

67
00:02:51,970 --> 00:02:56,379
for an attacker to gain some form of

68
00:02:54,220 --> 00:02:59,409
code execution capabilities in our

69
00:02:56,379 --> 00:03:01,418
system and it see if you look around and

70
00:02:59,409 --> 00:03:03,608
if you read the news there's pretty much

71
00:03:01,419 --> 00:03:05,799
bugs everywhere in our system and

72
00:03:03,609 --> 00:03:07,629
they're being exploited again and again

73
00:03:05,799 --> 00:03:10,030
and again and it's really hard to

74
00:03:07,629 --> 00:03:12,370
quantify to know or to see if you're

75
00:03:10,030 --> 00:03:16,120
actually making any progress at all and

76
00:03:12,370 --> 00:03:18,579
we try to look into this and on one hand

77
00:03:16,120 --> 00:03:20,919
quantify the progress that we are making

78
00:03:18,579 --> 00:03:23,560
and on the other hand try to figure out

79
00:03:20,919 --> 00:03:25,540
what kind of next defense mechanisms

80
00:03:23,560 --> 00:03:30,430
we'll use in our systems on a broad

81
00:03:25,540 --> 00:03:32,260
scale well in my research group we are

82
00:03:30,430 --> 00:03:34,629
developing the next generation of

83
00:03:32,260 --> 00:03:36,548
defenses we'll focus more on defenses

84
00:03:34,629 --> 00:03:38,198
here that are on the verge of being

85
00:03:36,549 --> 00:03:40,419
deployed but I will still give you a

86
00:03:38,199 --> 00:03:43,030
peek into some of these future defenses

87
00:03:40,419 --> 00:03:45,669
as we go on the pictures I'm showing

88
00:03:43,030 --> 00:03:47,799
here are from a recent from the recent

89
00:03:45,669 --> 00:03:51,099
point to own competition that showed

90
00:03:47,799 --> 00:03:53,139
that Microsoft edge has been poned 15

91
00:03:51,099 --> 00:03:55,689
times Microsoft Windows has been

92
00:03:53,139 --> 00:03:57,639
exploited a good 20 times and so on and

93
00:03:55,689 --> 00:03:59,918
they're bugs pretty much everywhere so

94
00:03:57,639 --> 00:04:02,040
in the example here we see that there's

95
00:03:59,919 --> 00:04:05,470
a calculator that has been popped on a

96
00:04:02,040 --> 00:04:10,629
MacBook Air and the hackers received

97
00:04:05,470 --> 00:04:13,299
additional fame for controlling the LED

98
00:04:10,629 --> 00:04:15,459
keyboard as well and scrolling a message

99
00:04:13,299 --> 00:04:18,849
you have been hacked by the group of

100
00:04:15,459 --> 00:04:21,488
people that is that there's Ubuntu

101
00:04:18,849 --> 00:04:23,409
system that has been exploited as well

102
00:04:21,488 --> 00:04:25,388
popping up a calculator showing that an

103
00:04:23,409 --> 00:04:27,460
exploit has successfully triggered and

104
00:04:25,389 --> 00:04:30,370
the attacker got code execution

105
00:04:27,460 --> 00:04:33,609
there's Microsoft Windows

106
00:04:30,370 --> 00:04:34,840
running Windows 10 with a with an open

107
00:04:33,610 --> 00:04:38,139
shell where the attackers would

108
00:04:34,840 --> 00:04:41,560
compromise it and also are a more

109
00:04:38,139 --> 00:04:44,340
interesting bug you see here VMware

110
00:04:41,560 --> 00:04:46,780
image or VMware instance that runs

111
00:04:44,340 --> 00:04:49,179
browser and the attackers first

112
00:04:46,780 --> 00:04:51,130
compromised the browser in a second step

113
00:04:49,180 --> 00:04:53,740
compromise the Windows operating system

114
00:04:51,130 --> 00:04:57,400
and then the third step compromised the

115
00:04:53,740 --> 00:05:00,280
VMware instance to pop to gain control

116
00:04:57,400 --> 00:05:02,710
over all the running running servers so

117
00:05:00,280 --> 00:05:05,799
is it hopeless is everything we have

118
00:05:02,710 --> 00:05:09,310
deployed not effective or are we

119
00:05:05,800 --> 00:05:11,199
actually making progress and let me go

120
00:05:09,310 --> 00:05:14,139
into detail for the question that I just

121
00:05:11,199 --> 00:05:17,139
asked there's strength in memory safety

122
00:05:14,139 --> 00:05:19,510
errors especially all these exploits are

123
00:05:17,139 --> 00:05:21,580
being used rely on some form of memory

124
00:05:19,510 --> 00:05:23,860
corruption at one point in time memory

125
00:05:21,580 --> 00:05:26,500
corruption is if you're thinking C or

126
00:05:23,860 --> 00:05:28,750
C++ some type safety violation or some

127
00:05:26,500 --> 00:05:31,750
memory safety violation if you read out

128
00:05:28,750 --> 00:05:33,669
of bounds if you have a function pointer

129
00:05:31,750 --> 00:05:36,970
that is not being used in the right way

130
00:05:33,669 --> 00:05:39,969
or if you have any other corruption that

131
00:05:36,970 --> 00:05:42,520
is happening and here this is worked by

132
00:05:39,970 --> 00:05:46,630
victor von neumann at friar university

133
00:05:42,520 --> 00:05:48,820
in amsterdam he plotted the cold of

134
00:05:46,630 --> 00:05:51,010
vulnerabilities and exploits that were

135
00:05:48,820 --> 00:05:54,639
reported over the last 16 years and we

136
00:05:51,010 --> 00:05:57,849
can see trends how they change and how

137
00:05:54,639 --> 00:05:59,260
they develop over time so we see there's

138
00:05:57,849 --> 00:06:01,960
different groups for maturing

139
00:05:59,260 --> 00:06:03,610
vulnerabilities pointer vulnerabilities

140
00:06:01,960 --> 00:06:05,710
with some form of pointer modifications

141
00:06:03,610 --> 00:06:06,910
integral vulnerabilities heap

142
00:06:05,710 --> 00:06:08,789
vulnerabilities and snack

143
00:06:06,910 --> 00:06:13,030
vulnerabilities and we see that around

144
00:06:08,789 --> 00:06:15,039
2006 2008 there was a huge peak in stack

145
00:06:13,030 --> 00:06:17,020
based vulnerabilities I mean saw a large

146
00:06:15,039 --> 00:06:18,760
amount of exploits and conveniently

147
00:06:17,020 --> 00:06:21,520
right around that time we started

148
00:06:18,760 --> 00:06:23,949
deploying data execution prevention and

149
00:06:21,520 --> 00:06:25,570
stack Canaries on a white scale and you

150
00:06:23,949 --> 00:06:27,550
see that all these stack based attacks

151
00:06:25,570 --> 00:06:29,590
have been taking off since sensitive

152
00:06:27,550 --> 00:06:31,660
the attacks are actually affected our

153
00:06:29,590 --> 00:06:34,690
defenses are effective against the

154
00:06:31,660 --> 00:06:37,510
attacks and if you look at what kind of

155
00:06:34,690 --> 00:06:40,030
exploits are being used nowadays it's

156
00:06:37,510 --> 00:06:43,039
mostly heat based exploits use after

157
00:06:40,030 --> 00:06:45,049
free different forms of

158
00:06:43,039 --> 00:06:47,330
is up to three constellations where

159
00:06:45,050 --> 00:06:48,979
different memory objects are used again

160
00:06:47,330 --> 00:06:52,099
after they have been freed at a later

161
00:06:48,979 --> 00:06:55,339
point in time so can we say that

162
00:06:52,099 --> 00:06:59,688
software is unsafe and insecure at any

163
00:06:55,339 --> 00:07:01,759
time in ghent what we are using on our

164
00:06:59,689 --> 00:07:05,719
systems we have pretty much everything

165
00:07:01,759 --> 00:07:07,520
implemented in c and c++ and tnt plus

166
00:07:05,719 --> 00:07:10,339
starts our programming languages that

167
00:07:07,520 --> 00:07:12,438
create type safety and memory safety for

168
00:07:10,339 --> 00:07:15,139
let's just say some potential of

169
00:07:12,439 --> 00:07:17,389
performance that you can gain you likely

170
00:07:15,139 --> 00:07:20,240
don't want to write your highly critical

171
00:07:17,389 --> 00:07:24,830
program in a high-level language like

172
00:07:20,240 --> 00:07:27,460
Java or something else and to get the

173
00:07:24,830 --> 00:07:30,438
most performance out of it

174
00:07:27,460 --> 00:07:34,219
unfortunately the systems that we have

175
00:07:30,439 --> 00:07:35,719
are too complex and too big to formally

176
00:07:34,219 --> 00:07:38,509
verify and you've likely been at the

177
00:07:35,719 --> 00:07:40,909
panel yesterday about formal methods and

178
00:07:38,509 --> 00:07:42,619
formal verification by it but I strongly

179
00:07:40,909 --> 00:07:44,808
believe that we should do as much formal

180
00:07:42,619 --> 00:07:46,039
verification as we can there's just too

181
00:07:44,809 --> 00:07:48,289
much code out there to protect

182
00:07:46,039 --> 00:07:51,020
everything we have that's why we need to

183
00:07:48,289 --> 00:07:53,688
have some form of defenses to protect

184
00:07:51,020 --> 00:07:55,729
the integrity and availability of our

185
00:07:53,689 --> 00:07:58,039
systems and data even in the presence of

186
00:07:55,729 --> 00:07:59,889
vulnerabilities because if you think

187
00:07:58,039 --> 00:08:03,188
about it

188
00:07:59,889 --> 00:08:06,830
for one piece of software Google Chrome

189
00:08:03,189 --> 00:08:10,550
has 76 million lines of code

190
00:08:06,830 --> 00:08:14,508
this is a humongous beast this is all

191
00:08:10,550 --> 00:08:16,789
implemented in C++ and while Google has

192
00:08:14,509 --> 00:08:20,959
very strong coding standards and

193
00:08:16,789 --> 00:08:23,389
enforces code reviews testing fuzzing

194
00:08:20,959 --> 00:08:26,870
and so on there's still a large amount

195
00:08:23,389 --> 00:08:29,269
of vulnerabilities in these product but

196
00:08:26,870 --> 00:08:31,069
it such as Google Chrome that you are

197
00:08:29,269 --> 00:08:33,198
running with T 76 million lines of code

198
00:08:31,069 --> 00:08:35,360
but in addition to that you are using

199
00:08:33,198 --> 00:08:37,279
the let's say the standard library -

200
00:08:35,360 --> 00:08:40,789
let's see and the Linux kernel which

201
00:08:37,279 --> 00:08:42,469
adds another bunch of code so even if

202
00:08:40,789 --> 00:08:45,680
you're running your safe system let's

203
00:08:42,469 --> 00:08:49,220
say you say I'll program everything in a

204
00:08:45,680 --> 00:08:50,870
safe way we'll do Python or Java but

205
00:08:49,220 --> 00:08:53,000
still the runtime system that you are

206
00:08:50,870 --> 00:08:55,339
using for Python and Java is implemented

207
00:08:53,000 --> 00:08:56,840
in c and c++ and it relies on the

208
00:08:55,339 --> 00:08:59,180
standard libraries on your system

209
00:08:56,840 --> 00:09:01,520
and on your operating system kernel and

210
00:08:59,180 --> 00:09:03,500
on the hypervisor in addition to that so

211
00:09:01,520 --> 00:09:05,090
you're building the trust of your system

212
00:09:03,500 --> 00:09:06,740
on all these other systems that are

213
00:09:05,090 --> 00:09:10,580
implemented with a low-level language

214
00:09:06,740 --> 00:09:13,010
and as we know the next vulnerability is

215
00:09:10,580 --> 00:09:17,839
shipped out ahead to bite us and we are

216
00:09:13,010 --> 00:09:20,720
now in a in a time where vulnerability

217
00:09:17,839 --> 00:09:26,180
scale and can be used to compromise a

218
00:09:20,720 --> 00:09:28,820
large amount of systems so you might ask

219
00:09:26,180 --> 00:09:32,180
yourself how do attackers get onto our

220
00:09:28,820 --> 00:09:34,520
systems and most of the exploits rely on

221
00:09:32,180 --> 00:09:36,890
some form of control flow hijack attack

222
00:09:34,520 --> 00:09:39,079
so the attacker gained some form of code

223
00:09:36,890 --> 00:09:41,089
execution capabilities where the

224
00:09:39,080 --> 00:09:45,170
attacker tries to execute arbitrary code

225
00:09:41,089 --> 00:09:46,850
on top of your system and many of you

226
00:09:45,170 --> 00:09:49,640
will likely know the code injection

227
00:09:46,850 --> 00:09:52,850
scenario where the attacker inject new

228
00:09:49,640 --> 00:09:57,319
code into the process this is a simple

229
00:09:52,850 --> 00:09:59,270
scenario that uses a memory corruption

230
00:09:57,320 --> 00:10:01,010
to set up the initial attack and the

231
00:09:59,270 --> 00:10:03,430
attacker overrides either some part of

232
00:10:01,010 --> 00:10:06,650
the heap or some part of the stack and

233
00:10:03,430 --> 00:10:09,770
in the second step redirect the control

234
00:10:06,650 --> 00:10:11,810
flow from the executing program hood is

235
00:10:09,770 --> 00:10:16,100
newly inject the data that is then

236
00:10:11,810 --> 00:10:20,599
interpreted as data all attacks until

237
00:10:16,100 --> 00:10:22,430
around 2005 followed this principle but

238
00:10:20,600 --> 00:10:24,410
we have introduced a large amount of

239
00:10:22,430 --> 00:10:26,959
defense mechanisms we as a security

240
00:10:24,410 --> 00:10:31,550
community not not V azzam in my group

241
00:10:26,960 --> 00:10:33,470
but these defenses protect against these

242
00:10:31,550 --> 00:10:36,800
attack vector so this is no longer a

243
00:10:33,470 --> 00:10:39,650
thing attacks has become much more

244
00:10:36,800 --> 00:10:43,699
complicated and attackers have resorted

245
00:10:39,650 --> 00:10:46,520
to a form of code reuse so instead of

246
00:10:43,700 --> 00:10:48,350
injecting new code because this is no

247
00:10:46,520 --> 00:10:50,660
longer possible giving the defenses that

248
00:10:48,350 --> 00:10:53,779
you have attackers have to reuse

249
00:10:50,660 --> 00:10:56,600
existing pieces of the code think of it

250
00:10:53,779 --> 00:10:58,370
as a jigsaw puzzle you have all the

251
00:10:56,600 --> 00:11:01,370
existing code of your application and

252
00:10:58,370 --> 00:11:03,650
you're grabbing little pieces of your

253
00:11:01,370 --> 00:11:06,410
application and then stitching them

254
00:11:03,650 --> 00:11:09,740
together in a new way that then executes

255
00:11:06,410 --> 00:11:10,760
the attackers desired behavior and a

256
00:11:09,740 --> 00:11:13,160
code reuse attack

257
00:11:10,760 --> 00:11:15,439
works with an additional step it's kind

258
00:11:13,160 --> 00:11:16,910
of similar to the code injection attack

259
00:11:15,440 --> 00:11:19,010
that I described earlier

260
00:11:16,910 --> 00:11:21,560
an attacker first has to find the

261
00:11:19,010 --> 00:11:24,380
addresses of sketches think again of the

262
00:11:21,560 --> 00:11:26,839
jigsaw analogy they're trying to scan

263
00:11:24,380 --> 00:11:29,510
the code to find different forms of

264
00:11:26,839 --> 00:11:32,389
pieces of codes that can be stitched

265
00:11:29,510 --> 00:11:35,689
together to then execute the attackers

266
00:11:32,389 --> 00:11:37,010
desired behavior the second step the

267
00:11:35,690 --> 00:11:39,380
attack of forces the memory corruption

268
00:11:37,010 --> 00:11:42,110
similar to the first attack and set up

269
00:11:39,380 --> 00:11:44,269
the individual data in a third step

270
00:11:42,110 --> 00:11:46,910
redirect the control flow to get your

271
00:11:44,269 --> 00:11:48,980
chain there's currently no active

272
00:11:46,910 --> 00:11:52,339
defense that we have that protects

273
00:11:48,980 --> 00:11:54,980
against this form of attack on the other

274
00:11:52,339 --> 00:11:57,829
hand there's a mechanism that is on the

275
00:11:54,980 --> 00:12:00,529
verge of being deployed and it's called

276
00:11:57,829 --> 00:12:03,649
control flow integrity that then protect

277
00:12:00,529 --> 00:12:05,329
against these forms of attacks a quick

278
00:12:03,649 --> 00:12:07,750
question who of you has already heard of

279
00:12:05,329 --> 00:12:11,599
control flow integrity a show of hand

280
00:12:07,750 --> 00:12:13,880
actually a whole bunch of people did you

281
00:12:11,600 --> 00:12:16,779
use a product control flow integrity

282
00:12:13,880 --> 00:12:19,459
product in your systems to use the

283
00:12:16,779 --> 00:12:24,079
microsoft visual studio control flow

284
00:12:19,459 --> 00:12:29,540
guard anybody using that anybody using

285
00:12:24,079 --> 00:12:33,430
the LLVM CFI one person two persons that

286
00:12:29,540 --> 00:12:33,430
are both my students that's interesting

287
00:12:33,579 --> 00:12:40,010
anybody else anybody using cf fine

288
00:12:35,959 --> 00:12:42,170
practice so far not yet

289
00:12:40,010 --> 00:12:43,880
but this is this is the defense

290
00:12:42,170 --> 00:12:47,000
mechanism that is on the verge of being

291
00:12:43,880 --> 00:12:48,800
deployed so you all will you see if I

292
00:12:47,000 --> 00:12:51,860
I'm going to tell you in the future

293
00:12:48,800 --> 00:12:56,779
right now security products or compilers

294
00:12:51,860 --> 00:13:00,290
have TFI mechanisms that are available

295
00:12:56,779 --> 00:13:03,649
you simply need to switch a compiler

296
00:13:00,290 --> 00:13:06,620
flag on and then use this defense

297
00:13:03,649 --> 00:13:08,750
mechanism in practice so it's easy to

298
00:13:06,620 --> 00:13:11,779
deploy even on existing code bases you

299
00:13:08,750 --> 00:13:14,240
simply switch flag and then you are

300
00:13:11,779 --> 00:13:15,829
protected for the others that didn't

301
00:13:14,240 --> 00:13:18,319
raise the hand you might ask what is

302
00:13:15,829 --> 00:13:21,199
control flow integrity so control flow

303
00:13:18,319 --> 00:13:24,290
integrity tries to precisely limit the

304
00:13:21,199 --> 00:13:26,419
control flow of your application

305
00:13:24,290 --> 00:13:28,759
to the set of control flows that are

306
00:13:26,419 --> 00:13:31,489
well known and can be statically

307
00:13:28,759 --> 00:13:33,470
determined so you restrict the programs

308
00:13:31,489 --> 00:13:36,879
dynamic control flow so it can be

309
00:13:33,470 --> 00:13:39,169
executed at runtime to whatever is

310
00:13:36,879 --> 00:13:40,910
intended by the programmers you're

311
00:13:39,169 --> 00:13:42,859
trying to get closer to the programmer

312
00:13:40,910 --> 00:13:45,049
intention with this mechanism it

313
00:13:42,859 --> 00:13:47,660
requires a static analysis that figures

314
00:13:45,049 --> 00:13:50,269
out all the valid targets for each in

315
00:13:47,660 --> 00:13:51,978
their controls work transfer limit the

316
00:13:50,269 --> 00:13:53,929
amount of targets that can be used at

317
00:13:51,979 --> 00:13:57,470
one time to the set of static term

318
00:13:53,929 --> 00:13:59,209
targets and then a dynamic enforcement

319
00:13:57,470 --> 00:14:02,179
mechanism that executes this actual

320
00:13:59,209 --> 00:14:06,858
check and we distinguish between two

321
00:14:02,179 --> 00:14:09,319
kind of edges the forward edge and the

322
00:14:06,859 --> 00:14:11,660
backward edge a forward edge is for

323
00:14:09,319 --> 00:14:14,209
example of function calls and these are

324
00:14:11,660 --> 00:14:17,959
indirect function calls for example a

325
00:14:14,209 --> 00:14:20,779
function pointer in C or a virtual call

326
00:14:17,959 --> 00:14:23,029
in C++ they're focusing on systems

327
00:14:20,779 --> 00:14:24,709
languages like C and C++ here because

328
00:14:23,029 --> 00:14:26,539
they are on one hand the ones that are

329
00:14:24,709 --> 00:14:27,618
most used for all the software and on

330
00:14:26,539 --> 00:14:28,970
the other hand the ones that are most

331
00:14:27,619 --> 00:14:30,799
exploitable for these kind of

332
00:14:28,970 --> 00:14:32,660
vulnerabilities and the backward edge is

333
00:14:30,799 --> 00:14:34,779
any function return like the return

334
00:14:32,660 --> 00:14:39,079
instruction pointer on the stack and

335
00:14:34,779 --> 00:14:40,939
we've looked at all the research that

336
00:14:39,079 --> 00:14:42,649
has been published over the last couple

337
00:14:40,939 --> 00:14:45,649
of years so this is a highly active

338
00:14:42,649 --> 00:14:48,019
research area over the last 15 years and

339
00:14:45,649 --> 00:14:50,529
it's slowly the research is slowly

340
00:14:48,019 --> 00:14:53,539
winding down as we are progressing into

341
00:14:50,529 --> 00:14:55,819
active products that are used on a wider

342
00:14:53,539 --> 00:14:58,220
scale and there have been 60 plus

343
00:14:55,819 --> 00:15:00,559
research papers at top conferences that

344
00:14:58,220 --> 00:15:02,509
publish different aspect of CFI

345
00:15:00,559 --> 00:15:05,238
mechanisms and it's an immensely complex

346
00:15:02,509 --> 00:15:07,189
topic so we figured we look at all these

347
00:15:05,239 --> 00:15:09,019
mechanisms and try to figure out what

348
00:15:07,189 --> 00:15:12,049
their actual differences are are your

349
00:15:09,019 --> 00:15:13,220
opportunities for deployment that we can

350
00:15:12,049 --> 00:15:15,858
make it easier are there opportunities

351
00:15:13,220 --> 00:15:17,989
for optimization are there opportunities

352
00:15:15,859 --> 00:15:19,789
for higher precision to get more

353
00:15:17,989 --> 00:15:21,709
guarantees and I'll try to tell you a

354
00:15:19,789 --> 00:15:26,539
little bit about these aspects that we

355
00:15:21,709 --> 00:15:28,368
looked at but let me first start with

356
00:15:26,539 --> 00:15:31,100
what control flow integrity actually

357
00:15:28,369 --> 00:15:33,439
does so for each indirect control flow

358
00:15:31,100 --> 00:15:36,439
transfer we figure out the set of

359
00:15:33,439 --> 00:15:38,150
allowed targets so if you have a call

360
00:15:36,439 --> 00:15:40,520
through a function pointer or

361
00:15:38,150 --> 00:15:43,340
virtual call we through the static

362
00:15:40,520 --> 00:15:45,199
analysis remembered Jesus these are the

363
00:15:43,340 --> 00:15:47,570
only targets that are allowed to

364
00:15:45,200 --> 00:15:50,720
transfer control to all the other

365
00:15:47,570 --> 00:15:54,770
targets we'll raise an error now how do

366
00:15:50,720 --> 00:15:56,990
we do this if you think about the free

367
00:15:54,770 --> 00:15:59,030
program or a C++ program at one point in

368
00:15:56,990 --> 00:16:01,490
time it will be compiled down into a

369
00:15:59,030 --> 00:16:03,560
machine code program and the computer

370
00:16:01,490 --> 00:16:07,580
CPU doesn't care where you're

371
00:16:03,560 --> 00:16:10,339
transferring control to the C the CPU

372
00:16:07,580 --> 00:16:11,780
does not have any semantics on what

373
00:16:10,340 --> 00:16:14,720
targets are being allowed or not allowed

374
00:16:11,780 --> 00:16:17,480
so if you have an indirect function call

375
00:16:14,720 --> 00:16:20,150
or a function return if you're returning

376
00:16:17,480 --> 00:16:23,060
from a function you can reach or the CPU

377
00:16:20,150 --> 00:16:27,800
is happy to transfer control flow to any

378
00:16:23,060 --> 00:16:30,439
addressable byte in memory right so this

379
00:16:27,800 --> 00:16:32,660
is this is this gives the attacker a

380
00:16:30,440 --> 00:16:35,210
large amount of different targets so

381
00:16:32,660 --> 00:16:38,689
what does see if I do it restricts those

382
00:16:35,210 --> 00:16:43,160
targets instead of just following this

383
00:16:38,690 --> 00:16:46,190
transfer we verify the integrity of the

384
00:16:43,160 --> 00:16:50,000
function pointer before we use it to

385
00:16:46,190 --> 00:16:51,680
transfer control so we add during the

386
00:16:50,000 --> 00:16:53,630
compilation or during the binary

387
00:16:51,680 --> 00:16:56,180
rewriting we add an additional check

388
00:16:53,630 --> 00:16:58,700
that says check the current value of

389
00:16:56,180 --> 00:17:01,699
this function pointer to see if it is in

390
00:16:58,700 --> 00:17:04,100
the set of valid target if it is not in

391
00:17:01,700 --> 00:17:06,530
the set of valid target we will stop the

392
00:17:04,099 --> 00:17:09,409
execution of the program and we'll do

393
00:17:06,530 --> 00:17:12,859
the same for the return instruction and

394
00:17:09,410 --> 00:17:15,290
limited to a benign caller so you are

395
00:17:12,859 --> 00:17:20,329
only allowed to call the return to v9

396
00:17:15,290 --> 00:17:23,869
caller of the of this function so the

397
00:17:20,329 --> 00:17:26,000
attacker may still corrupt memory but

398
00:17:23,869 --> 00:17:28,760
whenever we do a control flow transfer

399
00:17:26,000 --> 00:17:30,320
we will verify the code pointers before

400
00:17:28,760 --> 00:17:32,660
they are actually used

401
00:17:30,320 --> 00:17:36,620
we protect against any illegal

402
00:17:32,660 --> 00:17:41,300
modifications often the CFI does provide

403
00:17:36,620 --> 00:17:43,189
some incremental security the advantages

404
00:17:41,300 --> 00:17:45,770
it can be implemented at very low

405
00:17:43,190 --> 00:17:49,270
overhead but it gives us integrity of

406
00:17:45,770 --> 00:17:51,280
the control flow if

407
00:17:49,270 --> 00:17:53,139
look at the different TFI mechanisms the

408
00:17:51,280 --> 00:17:56,770
strengths of the CFI the precision

409
00:17:53,140 --> 00:17:59,440
depends on the power of the analysis

410
00:17:56,770 --> 00:18:01,510
how small are gives targeted if you

411
00:17:59,440 --> 00:18:03,340
think about it you can implement a CFI

412
00:18:01,510 --> 00:18:05,710
mechanism that is highly imprecise that

413
00:18:03,340 --> 00:18:07,720
we will just allow any single function

414
00:18:05,710 --> 00:18:10,090
that is out there and this is precisely

415
00:18:07,720 --> 00:18:12,940
what coarse-grained TFI mechanisms do

416
00:18:10,090 --> 00:18:14,860
they say we will allow you to transfer

417
00:18:12,940 --> 00:18:17,350
control to any function this is still

418
00:18:14,860 --> 00:18:20,830
better than transferring control to any

419
00:18:17,350 --> 00:18:23,709
arbitrary executable fight in your

420
00:18:20,830 --> 00:18:25,600
memory instead of having a target set of

421
00:18:23,710 --> 00:18:28,150
every single executable by t as a

422
00:18:25,600 --> 00:18:30,520
targeted of every function this reduces

423
00:18:28,150 --> 00:18:32,290
the attack surface or you can have a

424
00:18:30,520 --> 00:18:34,780
fine-grained mechanism that further

425
00:18:32,290 --> 00:18:37,980
reduces the attack surface to a smaller

426
00:18:34,780 --> 00:18:40,810
set and we'll get into detail for that

427
00:18:37,980 --> 00:18:43,630
so we evaluated all these different TFI

428
00:18:40,810 --> 00:18:46,600
mechanisms using a qualitative analysis

429
00:18:43,630 --> 00:18:50,080
and we distinguish them according to

430
00:18:46,600 --> 00:18:51,490
what kind of transfers they allow and I

431
00:18:50,080 --> 00:18:54,520
have a simple example and I hope it's

432
00:18:51,490 --> 00:18:57,760
readable in the back that where we are

433
00:18:54,520 --> 00:19:01,030
using they're using C++ here we allocate

434
00:18:57,760 --> 00:19:03,940
a new object and of type a and we then

435
00:19:01,030 --> 00:19:07,080
do a virtual dispatch to function foo

436
00:19:03,940 --> 00:19:10,930
and function food takes two parameters

437
00:19:07,080 --> 00:19:13,929
integer B and integer C now the question

438
00:19:10,930 --> 00:19:18,190
we ask ourselves for CFI mechanism what

439
00:19:13,930 --> 00:19:22,240
kind of targets are reachable without C

440
00:19:18,190 --> 00:19:24,190
fi any addressable byte is reachable so

441
00:19:22,240 --> 00:19:27,820
any CFI mechanism will protect us

442
00:19:24,190 --> 00:19:30,880
against reaching an arbitrary byte there

443
00:19:27,820 --> 00:19:33,340
are other CFI mechanisms that check for

444
00:19:30,880 --> 00:19:35,170
the guarantee so this function here has

445
00:19:33,340 --> 00:19:37,540
a different number of argument so

446
00:19:35,170 --> 00:19:40,720
there's a class of TFI mechanisms that

447
00:19:37,540 --> 00:19:42,399
checks the argument such a class of CFI

448
00:19:40,720 --> 00:19:44,920
mechanism to checks the return value

449
00:19:42,400 --> 00:19:48,850
avoid is different from an int and we

450
00:19:44,920 --> 00:19:51,190
expect that it returns an int there's if

451
00:19:48,850 --> 00:19:54,520
I mechanism to check this is a C

452
00:19:51,190 --> 00:19:57,270
function while we are doing a C++ style

453
00:19:54,520 --> 00:19:59,740
dispatch so we can remove this function

454
00:19:57,270 --> 00:20:03,100
there are other mechanisms that say hey

455
00:19:59,740 --> 00:20:05,590
this is a C++ function but B

456
00:20:03,100 --> 00:20:07,780
is not related to Class A therefore

457
00:20:05,590 --> 00:20:12,399
there's no valid way how we could

458
00:20:07,780 --> 00:20:14,250
dispatch over here and there's other

459
00:20:12,400 --> 00:20:17,280
precision

460
00:20:14,250 --> 00:20:19,600
details that can further detect

461
00:20:17,280 --> 00:20:22,928
fine-grain class higher key differences

462
00:20:19,600 --> 00:20:27,850
and hopefully you will only have one

463
00:20:22,929 --> 00:20:29,740
single class that remains so we looked

464
00:20:27,850 --> 00:20:33,428
through these 5060 different research

465
00:20:29,740 --> 00:20:35,620
papers and try to distill it into some

466
00:20:33,429 --> 00:20:38,230
form of spider plots that give you some

467
00:20:35,620 --> 00:20:40,360
intuitive answer about the security

468
00:20:38,230 --> 00:20:43,270
guarantees of the different TFI

469
00:20:40,360 --> 00:20:46,539
mechanisms and intuitively the larger

470
00:20:43,270 --> 00:20:49,210
the size of the spider plot the higher

471
00:20:46,539 --> 00:20:51,850
the security gains that you get and this

472
00:20:49,210 --> 00:20:53,770
is some qualitative analysis that gives

473
00:20:51,850 --> 00:20:55,990
you an intuition of the different

474
00:20:53,770 --> 00:20:58,030
mechanisms and in our paper we have one

475
00:20:55,990 --> 00:21:00,220
and a half pages of all these different

476
00:20:58,030 --> 00:21:03,668
mechanisms and compare them against each

477
00:21:00,220 --> 00:21:05,919
other so we compare for the different

478
00:21:03,669 --> 00:21:07,630
control flows they support the precision

479
00:21:05,919 --> 00:21:11,110
of the forward edge the precision of the

480
00:21:07,630 --> 00:21:14,679
backward edge the reported performance

481
00:21:11,110 --> 00:21:18,250
and the quantitative security guarantees

482
00:21:14,679 --> 00:21:20,440
that they give and what we learned is we

483
00:21:18,250 --> 00:21:22,330
as a security community and this goes

484
00:21:20,440 --> 00:21:25,500
back to the panel from yesterday we are

485
00:21:22,330 --> 00:21:29,139
doing a terrible job at actually

486
00:21:25,500 --> 00:21:32,110
quantifying and telling people what kind

487
00:21:29,140 --> 00:21:34,120
of static analysis we are using most of

488
00:21:32,110 --> 00:21:36,789
these papers focused heavily on

489
00:21:34,120 --> 00:21:38,199
performance and in the end all of these

490
00:21:36,789 --> 00:21:40,600
papers have similar comparable

491
00:21:38,200 --> 00:21:42,669
performance and what we would like to

492
00:21:40,600 --> 00:21:45,158
know is what kind of security guarantees

493
00:21:42,669 --> 00:21:46,600
does it give you only if we know both

494
00:21:45,159 --> 00:21:49,150
the security guarantees and the

495
00:21:46,600 --> 00:21:51,039
performance overhead we can assess if it

496
00:21:49,150 --> 00:21:53,650
is actually worthwhile to deploy these

497
00:21:51,039 --> 00:21:55,780
defenses so we have to know both factors

498
00:21:53,650 --> 00:21:57,460
performance overhead and security

499
00:21:55,780 --> 00:21:59,830
guarantees because maybe in a higher

500
00:21:57,460 --> 00:22:01,840
security environment we are more

501
00:21:59,830 --> 00:22:04,689
sensitive in my own you are willing to

502
00:22:01,840 --> 00:22:07,030
pay more of the overhead cost compared

503
00:22:04,690 --> 00:22:09,850
to a low security environment you have

504
00:22:07,030 --> 00:22:11,678
to distinguish between those and there's

505
00:22:09,850 --> 00:22:13,719
also a set of existing quantitative

506
00:22:11,679 --> 00:22:16,510
mechanism like the average indirect

507
00:22:13,720 --> 00:22:17,180
target reduction which did not really

508
00:22:16,510 --> 00:22:21,980
work out

509
00:22:17,180 --> 00:22:24,200
because the they pretty much counted how

510
00:22:21,980 --> 00:22:27,290
much they reduced the attack surface

511
00:22:24,200 --> 00:22:29,690
from reaching any arbitrary location and

512
00:22:27,290 --> 00:22:32,090
it is the average sum over all the

513
00:22:29,690 --> 00:22:35,720
indirect control flow transfer locations

514
00:22:32,090 --> 00:22:37,639
divided by the number of bytes that are

515
00:22:35,720 --> 00:22:39,500
addressable and if you think about it

516
00:22:37,640 --> 00:22:42,410
this metric if you only look at the

517
00:22:39,500 --> 00:22:45,530
let's see the standard library and you

518
00:22:42,410 --> 00:22:47,810
allow any exported function to be

519
00:22:45,530 --> 00:22:50,690
reached you already get an air value

520
00:22:47,810 --> 00:22:55,610
this is the old metric of 99.9 percent

521
00:22:50,690 --> 00:22:57,290
and we have shown that such a TFI

522
00:22:55,610 --> 00:22:59,330
mechanism can still be exploited and

523
00:22:57,290 --> 00:23:00,830
there have been a set of blackhat Hawks

524
00:22:59,330 --> 00:23:04,159
and other kind of talks that showed it

525
00:23:00,830 --> 00:23:08,260
with was this was not powerful enough so

526
00:23:04,160 --> 00:23:12,020
what we did is we actually try to

527
00:23:08,260 --> 00:23:15,800
compare mechanisms on a more realistic

528
00:23:12,020 --> 00:23:17,960
scale so we compared actual mechanisms

529
00:23:15,800 --> 00:23:20,870
against each other on the same hardware

530
00:23:17,960 --> 00:23:22,940
on the same machine with the same

531
00:23:20,870 --> 00:23:24,889
benchmarks so you can actually compare

532
00:23:22,940 --> 00:23:27,560
these different mechanisms something

533
00:23:24,890 --> 00:23:29,240
that other the papers the research

534
00:23:27,560 --> 00:23:31,669
papers has not yet done yet so we

535
00:23:29,240 --> 00:23:33,620
introduce new quantitative metrics the

536
00:23:31,670 --> 00:23:39,470
number of the equivalence classes and

537
00:23:33,620 --> 00:23:43,489
the size of the largest class now if you

538
00:23:39,470 --> 00:23:44,810
look at this and this is likely a little

539
00:23:43,490 --> 00:23:47,300
bit overwhelming so let me walk you

540
00:23:44,810 --> 00:23:51,230
through this through this figure we

541
00:23:47,300 --> 00:23:53,090
measured the classes the size of the

542
00:23:51,230 --> 00:23:54,470
classes and the differences in the

543
00:23:53,090 --> 00:23:57,350
classes what we are showing here are

544
00:23:54,470 --> 00:23:59,060
spider plots for the different

545
00:23:57,350 --> 00:24:04,639
mechanisms that we have evaluated on a

546
00:23:59,060 --> 00:24:07,340
logarithmic scale and the red bar shows

547
00:24:04,640 --> 00:24:09,290
the average amount of allowed transfers

548
00:24:07,340 --> 00:24:13,909
on a per control flow transfer location

549
00:24:09,290 --> 00:24:17,389
the bar shows the 25 and 75 percentile

550
00:24:13,910 --> 00:24:22,160
of the of the target set and the

551
00:24:17,390 --> 00:24:25,640
whiskers shows the individual outliers

552
00:24:22,160 --> 00:24:30,170
so what we see here is a visual

553
00:24:25,640 --> 00:24:31,130
representation of how tight the static

554
00:24:30,170 --> 00:24:33,080
analysis is

555
00:24:31,130 --> 00:24:35,750
allowing us to compare the static

556
00:24:33,080 --> 00:24:39,168
analysis against each other in addition

557
00:24:35,750 --> 00:24:42,289
to that we have a dynamic bar that shows

558
00:24:39,169 --> 00:24:44,510
what is actually used at run time so the

559
00:24:42,289 --> 00:24:47,120
closer we are to this dynamic bar the

560
00:24:44,510 --> 00:24:49,580
higher the security game also what we

561
00:24:47,120 --> 00:24:53,149
see there's several mechanisms that have

562
00:24:49,580 --> 00:24:57,500
a couple of locations where they are

563
00:24:53,150 --> 00:24:59,750
allowing more than a thousand target so

564
00:24:57,500 --> 00:25:02,900
an attacker if you put on your attacker

565
00:24:59,750 --> 00:25:06,409
hat an attacker would try to figure out

566
00:25:02,900 --> 00:25:09,559
which locations are imprecise where is

567
00:25:06,409 --> 00:25:13,750
your dynamic analysis sailing and then

568
00:25:09,559 --> 00:25:16,190
pick these locations to attack the

569
00:25:13,750 --> 00:25:19,820
application so this still gives the

570
00:25:16,190 --> 00:25:22,600
attacker some opportunity but we see

571
00:25:19,820 --> 00:25:24,649
that sometimes even one single location

572
00:25:22,600 --> 00:25:26,480
dynamically uses a large amount of

573
00:25:24,650 --> 00:25:29,630
different target so there's a trade-off

574
00:25:26,480 --> 00:25:32,659
of how precise we can actually get for

575
00:25:29,630 --> 00:25:35,350
this mechanism we also looked at the

576
00:25:32,659 --> 00:25:37,370
number of equivalent classes so how many

577
00:25:35,350 --> 00:25:40,070
individual classes should you have

578
00:25:37,370 --> 00:25:41,928
remember an equivalence classes ideally

579
00:25:40,070 --> 00:25:44,480
you have one equivalent class for each

580
00:25:41,929 --> 00:25:46,400
indirect control flow transfer curl and

581
00:25:44,480 --> 00:25:48,200
class meaning for each indirect control

582
00:25:46,400 --> 00:25:51,049
flow transfer that you have for each

583
00:25:48,200 --> 00:25:53,780
virtual call you remember this virtual

584
00:25:51,049 --> 00:25:56,000
call has this exact set of targets all

585
00:25:53,780 --> 00:25:58,309
the mechanisms that we looked at merged

586
00:25:56,000 --> 00:26:00,770
these set so they have been reusing the

587
00:25:58,309 --> 00:26:03,470
set either for performance constraints

588
00:26:00,770 --> 00:26:05,450
or for other kind of optimizations so

589
00:26:03,470 --> 00:26:10,370
they don't have individual sets and

590
00:26:05,450 --> 00:26:12,890
often have a lower number of equivalent

591
00:26:10,370 --> 00:26:14,809
classes which leads to some ambiguity

592
00:26:12,890 --> 00:26:18,590
and additional attack surface for the

593
00:26:14,809 --> 00:26:20,600
attacker so I talked a lot about the

594
00:26:18,590 --> 00:26:23,000
forward edge for indirect calls and

595
00:26:20,600 --> 00:26:26,030
virtual dispatch but what what about the

596
00:26:23,000 --> 00:26:28,760
return instruction return instructions

597
00:26:26,030 --> 00:26:30,799
push a valid return instruction target

598
00:26:28,760 --> 00:26:32,900
on the stack and it can be overwritten

599
00:26:30,799 --> 00:26:35,450
through a simple buffer overflow and

600
00:26:32,900 --> 00:26:37,429
what we figured out is that defenses

601
00:26:35,450 --> 00:26:39,860
without any form of stack integrity are

602
00:26:37,429 --> 00:26:43,400
inherently broken so we need to protect

603
00:26:39,860 --> 00:26:44,840
the stack as well and we have actually

604
00:26:43,400 --> 00:26:47,090
developed the defense making

605
00:26:44,840 --> 00:26:51,918
that has now made it into LLVM as well

606
00:26:47,090 --> 00:26:53,840
which is not yet actively being used but

607
00:26:51,919 --> 00:26:56,510
again this is only a compiler switch

608
00:26:53,840 --> 00:26:58,760
that you can activate to get stronger

609
00:26:56,510 --> 00:27:00,799
defenses in the future if you think

610
00:26:58,760 --> 00:27:04,940
about the attack let's say you have two

611
00:27:00,799 --> 00:27:08,779
calls to bar to the same function now as

612
00:27:04,940 --> 00:27:11,240
an attacker in the second call to bar

613
00:27:08,779 --> 00:27:13,340
you can override the return instruction

614
00:27:11,240 --> 00:27:15,260
pointer and instead of returning to this

615
00:27:13,340 --> 00:27:17,330
location here you're returning to this

616
00:27:15,260 --> 00:27:19,970
location and the attacker has already

617
00:27:17,330 --> 00:27:22,250
implemented a loop if there's some

618
00:27:19,970 --> 00:27:24,350
computation inside here that the

619
00:27:22,250 --> 00:27:28,130
attacker can modify the attacker gains

620
00:27:24,350 --> 00:27:30,889
some computational capability so we have

621
00:27:28,130 --> 00:27:32,750
to use some form of stack integrity some

622
00:27:30,890 --> 00:27:34,399
mechanism that enforces deck integrity

623
00:27:32,750 --> 00:27:36,500
so the attacker is restricted to

624
00:27:34,399 --> 00:27:39,979
arbitrary targets on the stack and

625
00:27:36,500 --> 00:27:41,960
cannot arbitrarily swap and loop through

626
00:27:39,980 --> 00:27:45,820
different targets but each target can

627
00:27:41,960 --> 00:27:49,820
only be called once and in sequence so

628
00:27:45,820 --> 00:27:52,520
this concludes my part about TFI CFI is

629
00:27:49,820 --> 00:27:54,529
the mechanism that you all will use in

630
00:27:52,520 --> 00:27:56,899
the future in the product you develop

631
00:27:54,529 --> 00:27:59,960
and it's as simple as switching on a

632
00:27:56,899 --> 00:28:02,449
compiler flag but you would also like to

633
00:27:59,960 --> 00:28:04,220
take at least one or two minutes to talk

634
00:28:02,450 --> 00:28:06,770
about an other upcoming problem

635
00:28:04,220 --> 00:28:09,230
especially as we are moving towards

636
00:28:06,770 --> 00:28:11,750
larger and larger applications pipe

637
00:28:09,230 --> 00:28:13,970
safety is becoming a very pressing

638
00:28:11,750 --> 00:28:17,480
concern and we need to figure out a

639
00:28:13,970 --> 00:28:19,429
mechanism to protect our systems in the

640
00:28:17,480 --> 00:28:23,169
presence of type safety vulnerabilities

641
00:28:19,429 --> 00:28:26,770
type violations and most of you will be

642
00:28:23,169 --> 00:28:30,049
programming in C++ in industry which is

643
00:28:26,770 --> 00:28:32,570
inherent inherently prone to this kind

644
00:28:30,049 --> 00:28:34,190
of type safety vulnerabilities and we

645
00:28:32,570 --> 00:28:37,580
are working actively working on

646
00:28:34,190 --> 00:28:39,590
solutions for that there all will all

647
00:28:37,580 --> 00:28:42,320
hopefully end up in some form of

648
00:28:39,590 --> 00:28:43,970
compiler at one point in time the type

649
00:28:42,320 --> 00:28:45,740
confusion vulnerability and this is

650
00:28:43,970 --> 00:28:48,710
exactly what is being used to compromise

651
00:28:45,740 --> 00:28:51,260
chrome edge Firefox all these browsers

652
00:28:48,710 --> 00:28:53,690
out there on a day to day basis type

653
00:28:51,260 --> 00:28:56,990
Confucius confusion arises through

654
00:28:53,690 --> 00:28:58,340
illegal down costs so for example

655
00:28:56,990 --> 00:29:00,080
converting a base class

656
00:28:58,340 --> 00:29:02,990
pointer to a derived cloth and has a

657
00:29:00,080 --> 00:29:05,178
short example here that illustrates this

658
00:29:02,990 --> 00:29:09,470
problem we have two classes Class B and

659
00:29:05,179 --> 00:29:13,549
Class V whereas V is the derived class

660
00:29:09,470 --> 00:29:16,220
of P so G specializes Class B Class B

661
00:29:13,549 --> 00:29:18,679
only has an integer food while Class B

662
00:29:16,220 --> 00:29:22,760
has an additional integer and a virtual

663
00:29:18,679 --> 00:29:26,539
call for example - and the problem that

664
00:29:22,760 --> 00:29:29,600
we are seeing is that initially a class

665
00:29:26,539 --> 00:29:32,480
of type B has been allocated which only

666
00:29:29,600 --> 00:29:36,219
allocates the small memory area here but

667
00:29:32,480 --> 00:29:40,309
then at a later point a static cost to

668
00:29:36,220 --> 00:29:43,700
the object happens and the D pointer

669
00:29:40,309 --> 00:29:46,129
then ends up being here and whatever is

670
00:29:43,700 --> 00:29:48,919
in memory and these other locations is

671
00:29:46,130 --> 00:29:51,380
being used instead and this is what

672
00:29:48,919 --> 00:29:53,090
attackers use to compromise all our

673
00:29:51,380 --> 00:29:55,730
current software in these different

674
00:29:53,090 --> 00:29:58,039
different mechanisms so we are working

675
00:29:55,730 --> 00:30:00,500
on protecting against such

676
00:29:58,039 --> 00:30:03,140
vulnerabilities and obviously low

677
00:30:00,500 --> 00:30:05,779
overhead otherwise these mechanisms will

678
00:30:03,140 --> 00:30:08,419
not be deployed in practice so what we

679
00:30:05,779 --> 00:30:11,179
do is we replace through a compiler

680
00:30:08,419 --> 00:30:13,340
based analysis each instance of a static

681
00:30:11,179 --> 00:30:17,390
cost which is the source of the problem

682
00:30:13,340 --> 00:30:20,330
here with a runtime check so static cost

683
00:30:17,390 --> 00:30:21,950
for a come for a programmer super simple

684
00:30:20,330 --> 00:30:23,960
right it just tells the compiler hey I

685
00:30:21,950 --> 00:30:25,490
want you to call this object from this

686
00:30:23,960 --> 00:30:27,260
cloth into the object of that clock

687
00:30:25,490 --> 00:30:29,360
there is no check whatsoever and you can

688
00:30:27,260 --> 00:30:33,260
cause from any object or any other

689
00:30:29,360 --> 00:30:35,719
object and everything is fine so we

690
00:30:33,260 --> 00:30:38,960
replace this compile time check with a

691
00:30:35,720 --> 00:30:42,700
runtime check it forces us to track the

692
00:30:38,960 --> 00:30:46,039
type of each individual object but we

693
00:30:42,700 --> 00:30:48,799
can through this mechanism enforce type

694
00:30:46,039 --> 00:30:50,720
safety for c++ and ensure that we are

695
00:30:48,799 --> 00:30:52,879
protected against these forms of

696
00:30:50,720 --> 00:30:54,860
vulnerabilities at low overhead and we

697
00:30:52,880 --> 00:30:56,510
have one publication that I mentioned

698
00:30:54,860 --> 00:30:59,120
here but there's other work ongoing

699
00:30:56,510 --> 00:31:02,539
where we further reduce the overhead and

700
00:30:59,120 --> 00:31:05,000
increase the precision so let me

701
00:31:02,539 --> 00:31:08,179
conclude let's get back to the question

702
00:31:05,000 --> 00:31:11,870
that I asked visually are we making

703
00:31:08,179 --> 00:31:14,299
progress and to sin

704
00:31:11,870 --> 00:31:17,719
I started to talk by giving a set of

705
00:31:14,299 --> 00:31:20,720
examples of the pone to own competition

706
00:31:17,720 --> 00:31:23,809
from this year and I'm ending the talk

707
00:31:20,720 --> 00:31:28,250
with two pictures that compare ponchione

708
00:31:23,809 --> 00:31:31,490
in 2007 and county-owned in 2017 ten

709
00:31:28,250 --> 00:31:34,520
years later have we made progress ten

710
00:31:31,490 --> 00:31:36,740
years ago it was a one-man show one

711
00:31:34,520 --> 00:31:40,190
single person compromised the system

712
00:31:36,740 --> 00:31:42,740
nowadays we have teams of 20 to 25

713
00:31:40,190 --> 00:31:45,350
people that compromised the system so

714
00:31:42,740 --> 00:31:47,990
yes we are making progress exploitation

715
00:31:45,350 --> 00:31:51,080
has gotten much harder and requires a

716
00:31:47,990 --> 00:31:53,480
large team of highly skilled people that

717
00:31:51,080 --> 00:31:56,928
actually figure out all these

718
00:31:53,480 --> 00:31:59,809
dependencies and generate these complete

719
00:31:56,929 --> 00:32:02,029
exploit so yes we are making progress

720
00:31:59,809 --> 00:32:04,840
attacks are much harder and require

721
00:32:02,029 --> 00:32:07,490
large teams not just single-player and

722
00:32:04,840 --> 00:32:10,580
TFI the mechanism that I talked to you

723
00:32:07,490 --> 00:32:14,510
make attacks even harder and much harder

724
00:32:10,580 --> 00:32:16,309
nowadays some attack surface remains so

725
00:32:14,510 --> 00:32:19,908
this is not the end but it is something

726
00:32:16,309 --> 00:32:22,220
that further at an order of magnitude of

727
00:32:19,909 --> 00:32:25,640
different of difficulty for the attacker

728
00:32:22,220 --> 00:32:27,980
and we can use stack integrity data

729
00:32:25,640 --> 00:32:31,820
execution prevention ASLR and so on as

730
00:32:27,980 --> 00:32:34,429
complementary mechanisms ongoing work as

731
00:32:31,820 --> 00:32:38,330
a community we have to work on precision

732
00:32:34,429 --> 00:32:40,490
for CFI to increase the effectiveness we

733
00:32:38,330 --> 00:32:43,100
have to work on type safety and ideally

734
00:32:40,490 --> 00:32:45,620
at one point in time in memory safety

735
00:32:43,100 --> 00:32:48,899
with that I would like to end my talk

736
00:32:45,620 --> 00:32:57,599
and ask if there any questions thank

737
00:32:48,900 --> 00:32:57,599
[Applause]

738
00:32:58,590 --> 00:33:08,049
how applicable is GFI to interpreted

739
00:33:02,590 --> 00:33:14,019
languages like PHP this is a wonderful

740
00:33:08,049 --> 00:33:14,408
question thank you and I try to tone it

741
00:33:14,019 --> 00:33:17,529
down

742
00:33:14,409 --> 00:33:19,960
so CFI gives you additional protection

743
00:33:17,529 --> 00:33:22,179
makes attacks harder and your question

744
00:33:19,960 --> 00:33:24,220
is excellent how effective is it in a

745
00:33:22,179 --> 00:33:26,529
presence of an interpreter like an

746
00:33:24,220 --> 00:33:28,779
interpreter allows you allows the

747
00:33:26,529 --> 00:33:30,669
attackers through data only attacks to

748
00:33:28,779 --> 00:33:33,700
stitch together a new program that is

749
00:33:30,669 --> 00:33:36,190
then being interpreted now with the

750
00:33:33,700 --> 00:33:38,350
difference without GFI the attacker

751
00:33:36,190 --> 00:33:39,999
would simply inject code and execute

752
00:33:38,350 --> 00:33:42,850
arbitrary system called

753
00:33:39,999 --> 00:33:45,879
an arbitrary command with GFI the

754
00:33:42,850 --> 00:33:48,459
attacker is restricted to modifying the

755
00:33:45,879 --> 00:33:51,428
actual code that is then interpreted by

756
00:33:48,460 --> 00:33:54,129
the interpreter let's make these let's

757
00:33:51,429 --> 00:33:56,470
make the Java example that supports Java

758
00:33:54,129 --> 00:33:58,090
security modules so you are restricted

759
00:33:56,470 --> 00:34:00,519
to the Java security modules that you

760
00:33:58,090 --> 00:34:02,649
have restricting the code that you can

761
00:34:00,519 --> 00:34:04,690
actually execute so it still gives you

762
00:34:02,649 --> 00:34:07,090
some additional guarantees the attacker

763
00:34:04,690 --> 00:34:08,859
is then restricted to the interpreted

764
00:34:07,090 --> 00:34:11,440
language and not to the machine code

765
00:34:08,859 --> 00:34:14,078
language also the attack gets much

766
00:34:11,440 --> 00:34:16,809
harder because the attacker has to work

767
00:34:14,079 --> 00:34:19,419
on the machine code on the interpreted

768
00:34:16,809 --> 00:34:22,780
language basis so then try to escalate

769
00:34:19,418 --> 00:34:25,569
privileges accordingly and as I said CFI

770
00:34:22,780 --> 00:34:28,690
is not a panic panic here you have to

771
00:34:25,569 --> 00:34:31,089
you likely use additional system called

772
00:34:28,690 --> 00:34:34,149
filtering system called policies other

773
00:34:31,089 --> 00:34:39,879
integrity mechanisms as well put it on

774
00:34:34,149 --> 00:34:42,460
to your question or less okay I'm

775
00:34:39,879 --> 00:34:44,500
wondering how does the Intel control

776
00:34:42,460 --> 00:34:45,970
flow enhancement technology fit into

777
00:34:44,500 --> 00:34:46,540
kind of the big picture of what you're

778
00:34:45,969 --> 00:34:49,058
talking about

779
00:34:46,540 --> 00:34:52,540
wonderful question thank you yeah the

780
00:34:49,059 --> 00:34:55,740
for Intel CT for those that don't know

781
00:34:52,540 --> 00:34:58,630
it is a hardware implementation of CFI

782
00:34:55,739 --> 00:35:00,279
let me split this question into two

783
00:34:58,630 --> 00:35:02,650
components the forward edge and the

784
00:35:00,280 --> 00:35:05,470
backward edge interestingly for the

785
00:35:02,650 --> 00:35:08,060
backward edge Intel CT implements a

786
00:35:05,470 --> 00:35:10,250
precise shadow stack this is

787
00:35:08,060 --> 00:35:15,290
wonderful this is exactly what we need

788
00:35:10,250 --> 00:35:17,630
to get stack integrity so I guess in the

789
00:35:15,290 --> 00:35:19,550
future we will all use intel CIT on

790
00:35:17,630 --> 00:35:20,900
Intel machines for the backward edge

791
00:35:19,550 --> 00:35:24,080
because it gives a strong stack

792
00:35:20,900 --> 00:35:26,480
integrity at negligible overhead this is

793
00:35:24,080 --> 00:35:30,290
perfect for the forward edge the

794
00:35:26,480 --> 00:35:34,150
precision is rather loose so Intel CT

795
00:35:30,290 --> 00:35:38,240
allows you to tag functions that are a

796
00:35:34,150 --> 00:35:41,390
valid target with a specific let's say

797
00:35:38,240 --> 00:35:43,370
some form of tag right and then any

798
00:35:41,390 --> 00:35:46,520
indirect control transfer is allowed to

799
00:35:43,370 --> 00:35:48,470
reach any of these tag functions which

800
00:35:46,520 --> 00:35:51,200
is highly imprecise this is again this

801
00:35:48,470 --> 00:35:53,990
single target set mechanism which is

802
00:35:51,200 --> 00:35:56,210
pretty much the same as Microsoft uses

803
00:35:53,990 --> 00:35:58,459
in their control flow guard so this is

804
00:35:56,210 --> 00:36:00,230
likely to weak in practice to be

805
00:35:58,460 --> 00:36:02,900
effective so it makes the attack

806
00:36:00,230 --> 00:36:05,660
somewhat harder but doesn't stop an

807
00:36:02,900 --> 00:36:07,490
attacker and I've near we're close to

808
00:36:05,660 --> 00:36:10,640
where see if I can go on a precision

809
00:36:07,490 --> 00:36:12,680
basis so people will likely use it as

810
00:36:10,640 --> 00:36:17,029
advantage of Intel CPUs that is very

811
00:36:12,680 --> 00:36:20,210
fast so people may use it for the

812
00:36:17,030 --> 00:36:21,770
forward edge in low security context and

813
00:36:20,210 --> 00:36:24,290
in the backward edge for pretty much

814
00:36:21,770 --> 00:36:26,660
every single context for the forward

815
00:36:24,290 --> 00:36:29,090
edge people will likely switch to more

816
00:36:26,660 --> 00:36:31,310
precise solutions that give you stronger

817
00:36:29,090 --> 00:36:33,620
guarantees which are hard to accomplish

818
00:36:31,310 --> 00:36:35,540
on a hardware level so Intel did as much

819
00:36:33,620 --> 00:36:37,460
as they could without significantly

820
00:36:35,540 --> 00:36:40,220
complicating the underlying hardware

821
00:36:37,460 --> 00:36:42,490
design good question thank you all right

822
00:36:40,220 --> 00:36:42,490
thank you

823
00:36:47,750 --> 00:36:49,810
you

