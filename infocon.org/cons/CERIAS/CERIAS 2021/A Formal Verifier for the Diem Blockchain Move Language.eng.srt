1
00:00:00,080 --> 00:00:03,120
hello everyone uh who's tuned in uh

2
00:00:03,120 --> 00:00:06,160
either to the live presentation or to

3
00:00:06,160 --> 00:00:10,240
the uh uh recorded version of this

4
00:00:10,240 --> 00:00:13,200
we're pleased to have in this week's

5
00:00:13,200 --> 00:00:14,320
seminar

6
00:00:14,320 --> 00:00:17,440
uh dr david dill and uh

7
00:00:17,440 --> 00:00:20,560
he has a distinguished career uh

8
00:00:20,560 --> 00:00:23,840
in academia and now in industry

9
00:00:23,840 --> 00:00:25,680
he's he's well known for working in a

10
00:00:25,680 --> 00:00:26,880
number of areas

11
00:00:26,880 --> 00:00:29,439
including some formal aspects of

12
00:00:29,439 --> 00:00:30,320
computing

13
00:00:30,320 --> 00:00:33,040
and another area where i know him very

14
00:00:33,040 --> 00:00:33,360
well

15
00:00:33,360 --> 00:00:35,920
is the work that he's put into helping

16
00:00:35,920 --> 00:00:37,280
make sure that

17
00:00:37,280 --> 00:00:41,600
voting is conducted securely and safely

18
00:00:41,600 --> 00:00:43,840
he's going to talk to us today about a

19
00:00:43,840 --> 00:00:45,760
formal verifier

20
00:00:45,760 --> 00:00:48,640
for blockchain language and formal

21
00:00:48,640 --> 00:00:50,399
verification has some

22
00:00:50,399 --> 00:00:52,480
deep connections to potentially making

23
00:00:52,480 --> 00:00:54,160
systems more secure

24
00:00:54,160 --> 00:00:57,199
and more trustworthy as we go along if

25
00:00:57,199 --> 00:00:57,680
you have

26
00:00:57,680 --> 00:01:00,800
questions please put them in the q a and

27
00:01:00,800 --> 00:01:01,199
uh

28
00:01:01,199 --> 00:01:03,840
david will uh be checking that from time

29
00:01:03,840 --> 00:01:05,840
to time to answer the questions

30
00:01:05,840 --> 00:01:08,479
and at the end of his talk as well so

31
00:01:08,479 --> 00:01:10,479
without further ado

32
00:01:10,479 --> 00:01:14,320
the esteemed dr david dill uh thank you

33
00:01:14,320 --> 00:01:16,080
uh as an administrative thing it's

34
00:01:16,080 --> 00:01:18,400
difficult for me to check the q a while

35
00:01:18,400 --> 00:01:19,840
using powerpoint here

36
00:01:19,840 --> 00:01:22,720
so uh if we could appoint someone say

37
00:01:22,720 --> 00:01:23,600
staff

38
00:01:23,600 --> 00:01:26,799
to interrupt me if there's a question

39
00:01:26,799 --> 00:01:27,840
pending

40
00:01:27,840 --> 00:01:31,119
then then i'll be able to address it

41
00:01:31,119 --> 00:01:32,960
i'm especially interested in questions

42
00:01:32,960 --> 00:01:35,600
as i i was mentioning earlier

43
00:01:35,600 --> 00:01:38,320
i have given versions of this talk

44
00:01:38,320 --> 00:01:39,360
mostly to

45
00:01:39,360 --> 00:01:41,360
audiences that are quite familiar with

46
00:01:41,360 --> 00:01:42,960
formal verification

47
00:01:42,960 --> 00:01:44,560
i don't want it to go over people's

48
00:01:44,560 --> 00:01:46,320
heads so

49
00:01:46,320 --> 00:01:48,960
i'm especially interested in hearing

50
00:01:48,960 --> 00:01:50,720
questions if you feel

51
00:01:50,720 --> 00:01:53,280
that i've left you behind because it

52
00:01:53,280 --> 00:01:54,960
wouldn't take me too long to explain the

53
00:01:54,960 --> 00:01:56,240
basics of anything

54
00:01:56,240 --> 00:01:59,600
to get everybody uh able to understand

55
00:01:59,600 --> 00:02:01,280
the rest of the talk or at least so i

56
00:02:01,280 --> 00:02:02,880
believe

57
00:02:02,880 --> 00:02:04,320
anyway thank you for inviting me to

58
00:02:04,320 --> 00:02:06,240
speak today i'm a blockchain researcher

59
00:02:06,240 --> 00:02:08,639
for novi which is a facebook company

60
00:02:08,639 --> 00:02:10,959
that develops applications for the dm

61
00:02:10,959 --> 00:02:12,319
blockchain

62
00:02:12,319 --> 00:02:14,080
the research i'm presenting today is one

63
00:02:14,080 --> 00:02:16,080
of novi's contributions to the

64
00:02:16,080 --> 00:02:17,520
blockchain

65
00:02:17,520 --> 00:02:20,239
so you may have heard in the news the

66
00:02:20,239 --> 00:02:22,480
term the libra blockchain

67
00:02:22,480 --> 00:02:25,440
over the last couple of years the

68
00:02:25,440 --> 00:02:27,760
formerly libra association changed its

69
00:02:27,760 --> 00:02:29,840
name from libra to dm

70
00:02:29,840 --> 00:02:31,599
last december and so that's why i'm

71
00:02:31,599 --> 00:02:33,519
talking about the dm blockchain

72
00:02:33,519 --> 00:02:36,480
now so the work i'll describe today is

73
00:02:36,480 --> 00:02:37,599
the results of

74
00:02:37,599 --> 00:02:40,720
the efforts of many people so i hope

75
00:02:40,720 --> 00:02:42,560
that i provided some vision i did some

76
00:02:42,560 --> 00:02:44,959
of the work but it's mostly other people

77
00:02:44,959 --> 00:02:47,760
on the on the project um there's a

78
00:02:47,760 --> 00:02:49,440
prover team that's had

79
00:02:49,440 --> 00:02:52,480
some some people moving in and out but

80
00:02:52,480 --> 00:02:52,800
there's

81
00:02:52,800 --> 00:02:56,319
a core team of uh four or five people

82
00:02:56,319 --> 00:02:58,080
some other people who've dropped in for

83
00:02:58,080 --> 00:03:00,560
a while worked on some aspects of it

84
00:03:00,560 --> 00:03:03,599
and several different interns that have

85
00:03:03,599 --> 00:03:05,120
done good work in the project over the

86
00:03:05,120 --> 00:03:06,480
last couple of years

87
00:03:06,480 --> 00:03:08,959
there's also a team for doing the move

88
00:03:08,959 --> 00:03:09,760
language

89
00:03:09,760 --> 00:03:11,440
we call it the move platform because it

90
00:03:11,440 --> 00:03:13,440
consists of the language design

91
00:03:13,440 --> 00:03:15,599
the usual compiler stuff a virtual

92
00:03:15,599 --> 00:03:17,120
machine and

93
00:03:17,120 --> 00:03:19,120
code to interface the virtual machine to

94
00:03:19,120 --> 00:03:20,959
the rest of the blockchain

95
00:03:20,959 --> 00:03:22,480
and so of course they've had their own

96
00:03:22,480 --> 00:03:24,480
interns so it's

97
00:03:24,480 --> 00:03:27,680
more people that i can actually name in

98
00:03:27,680 --> 00:03:32,319
the talk here

99
00:03:32,319 --> 00:03:35,360
uh let's see here good

100
00:03:35,360 --> 00:03:37,280
um so first i wanted to say a few words

101
00:03:37,280 --> 00:03:38,959
about what dm is

102
00:03:38,959 --> 00:03:41,920
so it's a payment system it's a

103
00:03:41,920 --> 00:03:43,599
blockchain and hopefully

104
00:03:43,599 --> 00:03:45,040
at some point in the future we can

105
00:03:45,040 --> 00:03:47,599
expand it to be a broader range of

106
00:03:47,599 --> 00:03:49,440
financial services and maybe even other

107
00:03:49,440 --> 00:03:51,440
services

108
00:03:51,440 --> 00:03:53,840
novi is one of many organizations that

109
00:03:53,840 --> 00:03:55,280
will build applications for this

110
00:03:55,280 --> 00:03:57,360
blockchain or so is our vision

111
00:03:57,360 --> 00:03:59,599
and the first novi application will be a

112
00:03:59,599 --> 00:04:00,560
digital wallet

113
00:04:00,560 --> 00:04:02,239
so we'll have a payment system and

114
00:04:02,239 --> 00:04:03,920
you'll be able to use this wallet to

115
00:04:03,920 --> 00:04:07,200
store and transfer funds

116
00:04:08,640 --> 00:04:11,920
good so the dm association

117
00:04:11,920 --> 00:04:14,319
exists so that facebook doesn't control

118
00:04:14,319 --> 00:04:15,760
this it's uh

119
00:04:15,760 --> 00:04:17,918
dm the dm blockchain is sort of like the

120
00:04:17,918 --> 00:04:19,839
interstate highway system

121
00:04:19,839 --> 00:04:23,759
and uh applications on it are like

122
00:04:23,759 --> 00:04:25,600
trucks that are trucking goods or have

123
00:04:25,600 --> 00:04:28,240
businesses that rely on that road system

124
00:04:28,240 --> 00:04:32,080
so the d we have 7 27 dm association

125
00:04:32,080 --> 00:04:32,800
members

126
00:04:32,800 --> 00:04:34,960
and they are global companies venture

127
00:04:34,960 --> 00:04:37,440
funds non-governmental organizations

128
00:04:37,440 --> 00:04:40,479
etc and so we've got diverse people

129
00:04:40,479 --> 00:04:42,800
group of people some of whom are very

130
00:04:42,800 --> 00:04:44,160
interested in providing financial

131
00:04:44,160 --> 00:04:45,199
services

132
00:04:45,199 --> 00:04:48,320
others of which are constituency for

133
00:04:48,320 --> 00:04:50,400
consid representing a constituency of

134
00:04:50,400 --> 00:04:54,239
people who need financial services

135
00:04:55,520 --> 00:04:57,040
in the talk i'll be presenting some

136
00:04:57,040 --> 00:04:59,280
background on

137
00:04:59,280 --> 00:05:01,520
basic questions like what's a blockchain

138
00:05:01,520 --> 00:05:04,240
and what are smart contracts

139
00:05:04,240 --> 00:05:06,800
i'll then talk about the move prover

140
00:05:06,800 --> 00:05:08,240
which is the main topic

141
00:05:08,240 --> 00:05:10,880
of today i'll talk about using approver

142
00:05:10,880 --> 00:05:13,280
particularly writing specifications

143
00:05:13,280 --> 00:05:15,199
i'll type talk about a particularly

144
00:05:15,199 --> 00:05:17,360
novel aspect of the prover

145
00:05:17,360 --> 00:05:19,440
and i'll make some which is the memory

146
00:05:19,440 --> 00:05:20,880
model and i'll have some concluding

147
00:05:20,880 --> 00:05:24,000
remarks to summarize

148
00:05:24,000 --> 00:05:27,039
so why are we doing this a blockchain

149
00:05:27,039 --> 00:05:29,360
is a high assurance system for several

150
00:05:29,360 --> 00:05:30,320
reasons

151
00:05:30,320 --> 00:05:33,759
there are large assets at stake

152
00:05:33,759 --> 00:05:36,320
but it's a little worse than say a bank

153
00:05:36,320 --> 00:05:37,840
or the stock market where there are also

154
00:05:37,840 --> 00:05:39,520
assets at stake

155
00:05:39,520 --> 00:05:42,320
transactions on a blockchain are ideally

156
00:05:42,320 --> 00:05:43,360
irreversible

157
00:05:43,360 --> 00:05:45,680
now in reality they can be reversed but

158
00:05:45,680 --> 00:05:46,880
it's difficult

159
00:05:46,880 --> 00:05:49,919
and there's some reputational cost it's

160
00:05:49,919 --> 00:05:52,160
you know embarrassing if you find

161
00:05:52,160 --> 00:05:54,320
yourself having to reverse a transaction

162
00:05:54,320 --> 00:05:56,479
so it's more important than many

163
00:05:56,479 --> 00:05:58,160
applications that we get things right

164
00:05:58,160 --> 00:06:00,800
and we get the code right

165
00:06:00,800 --> 00:06:03,440
the blockchain may be targeted by highly

166
00:06:03,440 --> 00:06:04,199
motivated

167
00:06:04,199 --> 00:06:07,039
well-resourced adversaries um there was

168
00:06:07,039 --> 00:06:08,560
a story at one point

169
00:06:08,560 --> 00:06:10,960
that north korea was funding weapons of

170
00:06:10,960 --> 00:06:13,600
mass destruction by cryptocurrency fraud

171
00:06:13,600 --> 00:06:15,680
so we would prefer not to be involved in

172
00:06:15,680 --> 00:06:17,120
that

173
00:06:17,120 --> 00:06:19,440
to say the least and so already hundreds

174
00:06:19,440 --> 00:06:21,199
of millions of dollars in losses have

175
00:06:21,199 --> 00:06:22,080
occurred

176
00:06:22,080 --> 00:06:24,880
from bugs and other blockchains more

177
00:06:24,880 --> 00:06:26,240
losses from bugs and wallets and

178
00:06:26,240 --> 00:06:27,759
whatever i'm just talking about the core

179
00:06:27,759 --> 00:06:28,720
blockchain

180
00:06:28,720 --> 00:06:32,160
technology that stores the results

181
00:06:32,160 --> 00:06:34,000
of stories accounts and the results of

182
00:06:34,000 --> 00:06:37,280
transferring funds etc

183
00:06:37,280 --> 00:06:40,560
so we've got a bad track record and um

184
00:06:40,560 --> 00:06:42,880
in the in the blockchain world and so

185
00:06:42,880 --> 00:06:44,400
it's very clear that we need to do

186
00:06:44,400 --> 00:06:46,400
something about it

187
00:06:46,400 --> 00:06:48,240
so the move prover is an effort to

188
00:06:48,240 --> 00:06:50,240
address these concerns

189
00:06:50,240 --> 00:06:52,080
it's a formal verification tool for

190
00:06:52,080 --> 00:06:55,280
smart contracts on the dm blockchain

191
00:06:55,280 --> 00:06:57,759
so i'll concede that it's a work in

192
00:06:57,759 --> 00:06:59,919
progress so it's improving over time

193
00:06:59,919 --> 00:07:01,919
we've met some initial goals but it's by

194
00:07:01,919 --> 00:07:03,599
no means complete

195
00:07:03,599 --> 00:07:06,639
and so this is a status

196
00:07:06,639 --> 00:07:10,240
report on how it's going in some sense

197
00:07:10,240 --> 00:07:11,440
and i'm going to treat it as an

198
00:07:11,440 --> 00:07:13,520
engineering project it's not really a

199
00:07:13,520 --> 00:07:15,199
collection of research results it's a

200
00:07:15,199 --> 00:07:16,800
real piece of software that's going to

201
00:07:16,800 --> 00:07:17,919
do real work

202
00:07:17,919 --> 00:07:19,919
we hope we'll be writing more papers we

203
00:07:19,919 --> 00:07:21,680
expect to be but

204
00:07:21,680 --> 00:07:23,680
this presentation is really about a

205
00:07:23,680 --> 00:07:25,919
practical artifact

206
00:07:25,919 --> 00:07:28,639
the system is 100 open source and is

207
00:07:28,639 --> 00:07:30,639
available on github at the

208
00:07:30,639 --> 00:07:34,880
under dm and so here are our goals some

209
00:07:34,880 --> 00:07:37,039
of which we've actually met

210
00:07:37,039 --> 00:07:39,120
we want to allow complete specification

211
00:07:39,120 --> 00:07:40,720
of functional properties of smart

212
00:07:40,720 --> 00:07:43,440
contracts and by functional properties

213
00:07:43,440 --> 00:07:46,479
i'm excluding things like performance

214
00:07:46,479 --> 00:07:48,560
you know timing things or

215
00:07:48,560 --> 00:07:50,400
things that are probabilistic so

216
00:07:50,400 --> 00:07:52,000
basically you have functions

217
00:07:52,000 --> 00:07:54,560
that change the state or at pre or post

218
00:07:54,560 --> 00:07:56,000
conditions you have properties that are

219
00:07:56,000 --> 00:07:57,039
true over time

220
00:07:57,039 --> 00:07:58,160
they can be written as logical

221
00:07:58,160 --> 00:08:00,639
properties

222
00:08:01,199 --> 00:08:05,759
um the status of that is that

223
00:08:05,759 --> 00:08:07,919
we can't say that we we have complete

224
00:08:07,919 --> 00:08:09,520
specifications but we've actually got

225
00:08:09,520 --> 00:08:11,440
extensive specifications of the system

226
00:08:11,440 --> 00:08:12,080
that we're

227
00:08:12,080 --> 00:08:16,080
expecting to deploy we'd like to enable

228
00:08:16,080 --> 00:08:18,160
fully automatic verification

229
00:08:18,160 --> 00:08:21,520
that the code implementing something

230
00:08:21,520 --> 00:08:25,360
meets its formal specifications

231
00:08:25,360 --> 00:08:27,520
and we'd like it to run only a little

232
00:08:27,520 --> 00:08:28,960
slower than a compiler

233
00:08:28,960 --> 00:08:30,960
this is in contrast to some efforts in

234
00:08:30,960 --> 00:08:32,240
formal verification

235
00:08:32,240 --> 00:08:34,719
which involve basically proof checking

236
00:08:34,719 --> 00:08:36,399
so it's an interactive system

237
00:08:36,399 --> 00:08:38,399
where a user enters a detailed proof of

238
00:08:38,399 --> 00:08:40,559
correctness of the system and

239
00:08:40,559 --> 00:08:43,120
the proof system checks that the

240
00:08:43,120 --> 00:08:43,919
approver hasn't

241
00:08:43,919 --> 00:08:45,760
that the user hasn't made any errors in

242
00:08:45,760 --> 00:08:47,120
generating that proof

243
00:08:47,120 --> 00:08:48,720
so this is another part of the design

244
00:08:48,720 --> 00:08:50,480
space for formal verifiers

245
00:08:50,480 --> 00:08:54,959
which is automatic proof

246
00:08:54,959 --> 00:08:58,720
the system right now can re-verify after

247
00:08:58,720 --> 00:08:59,519
every change

248
00:08:59,519 --> 00:09:01,920
in a smart contract interactively so the

249
00:09:01,920 --> 00:09:03,040
idea is you're writing your smart

250
00:09:03,040 --> 00:09:04,000
contract

251
00:09:04,000 --> 00:09:07,040
you change something you can recheck the

252
00:09:07,040 --> 00:09:08,640
specifications automatically very

253
00:09:08,640 --> 00:09:09,760
quickly

254
00:09:09,760 --> 00:09:12,959
and also in continuous integration so

255
00:09:12,959 --> 00:09:14,959
i'm embarrassed to say that once i

256
00:09:14,959 --> 00:09:17,360
left the ivory tower and joined the real

257
00:09:17,360 --> 00:09:18,240
world

258
00:09:18,240 --> 00:09:20,560
i learned that the way companies work is

259
00:09:20,560 --> 00:09:22,480
with large software assistance

260
00:09:22,480 --> 00:09:24,640
is that every time new code is checked

261
00:09:24,640 --> 00:09:25,839
into the system

262
00:09:25,839 --> 00:09:28,880
a series of tests runs automatically and

263
00:09:28,880 --> 00:09:30,880
normally people wouldn't think that

264
00:09:30,880 --> 00:09:32,880
formal verification would be fast enough

265
00:09:32,880 --> 00:09:34,720
or reliable enough that you could run it

266
00:09:34,720 --> 00:09:36,240
as part of that process but we do it

267
00:09:36,240 --> 00:09:37,040
routinely

268
00:09:37,040 --> 00:09:38,959
every time we put in new code the formal

269
00:09:38,959 --> 00:09:42,399
verifier runs on everything

270
00:09:42,399 --> 00:09:45,120
so a formal verification is hard this is

271
00:09:45,120 --> 00:09:46,640
one of my research findings having

272
00:09:46,640 --> 00:09:48,480
worked in the field something like 35 or

273
00:09:48,480 --> 00:09:51,279
40 years now and

274
00:09:51,279 --> 00:09:54,000
there have been many disappointments and

275
00:09:54,000 --> 00:09:54,800
so

276
00:09:54,800 --> 00:09:56,560
i had to stop and think when i was

277
00:09:56,560 --> 00:09:58,240
starting this project of why don't i

278
00:09:58,240 --> 00:10:00,720
expect this to be a disappointment and

279
00:10:00,720 --> 00:10:01,760
there are several reasons

280
00:10:01,760 --> 00:10:03,360
one of them is we're starting with a

281
00:10:03,360 --> 00:10:05,360
clean slate slate if you decide that

282
00:10:05,360 --> 00:10:06,560
you're going to build a formal verifier

283
00:10:06,560 --> 00:10:07,279
for java

284
00:10:07,279 --> 00:10:08,959
which would be a very useful thing

285
00:10:08,959 --> 00:10:10,959
you're going to be

286
00:10:10,959 --> 00:10:14,399
have masses of existing java code a

287
00:10:14,399 --> 00:10:17,519
massive java programming environment

288
00:10:17,519 --> 00:10:19,200
a language that was not designed

289
00:10:19,200 --> 00:10:21,040
specifically for verification

290
00:10:21,040 --> 00:10:23,279
etc you're going to have a hard job but

291
00:10:23,279 --> 00:10:24,560
we're starting with

292
00:10:24,560 --> 00:10:27,600
a blank slate where we can optimize

293
00:10:27,600 --> 00:10:31,279
to make formal verification doable

294
00:10:31,279 --> 00:10:32,880
so we can avoid some of the problems or

295
00:10:32,880 --> 00:10:34,160
we think we can avoid them with

296
00:10:34,160 --> 00:10:36,399
verifying traditional software

297
00:10:36,399 --> 00:10:38,079
so one thing is that developers don't

298
00:10:38,079 --> 00:10:39,680
expect to write specifications they

299
00:10:39,680 --> 00:10:40,079
write

300
00:10:40,079 --> 00:10:41,920
millions of lines of codes with no

301
00:10:41,920 --> 00:10:43,440
formal specifications

302
00:10:43,440 --> 00:10:45,920
we have a system that requires separate

303
00:10:45,920 --> 00:10:46,880
specifications

304
00:10:46,880 --> 00:10:48,880
in addition to the code it's like

305
00:10:48,880 --> 00:10:50,720
assertions of various kinds

306
00:10:50,720 --> 00:10:52,720
and we're just going to have the

307
00:10:52,720 --> 00:10:54,720
expectation that those will be written

308
00:10:54,720 --> 00:10:56,480
with a smart contract and maybe it will

309
00:10:56,480 --> 00:10:58,480
be required at some point before

310
00:10:58,480 --> 00:11:00,000
somebody could put a smart contract

311
00:11:00,000 --> 00:11:02,000
on our blockchain that decision has not

312
00:11:02,000 --> 00:11:04,640
been made yet

313
00:11:04,800 --> 00:11:06,720
in general programming languages are too

314
00:11:06,720 --> 00:11:08,880
complex and ill-defined

315
00:11:08,880 --> 00:11:12,079
to verify you need your writing logical

316
00:11:12,079 --> 00:11:13,360
specifications you need to know

317
00:11:13,360 --> 00:11:14,320
precisely

318
00:11:14,320 --> 00:11:15,920
what every construct in the programming

319
00:11:15,920 --> 00:11:18,240
language does and often that work has

320
00:11:18,240 --> 00:11:20,000
not been done

321
00:11:20,000 --> 00:11:21,279
another problem with programming

322
00:11:21,279 --> 00:11:22,560
languages which i didn't put on this

323
00:11:22,560 --> 00:11:24,240
slide is that they have large native

324
00:11:24,240 --> 00:11:25,200
libraries often

325
00:11:25,200 --> 00:11:29,839
and those are especially hard to model

326
00:11:29,920 --> 00:11:32,560
in our case while we haven't been as

327
00:11:32,560 --> 00:11:34,320
careful about formal semantics of our

328
00:11:34,320 --> 00:11:35,120
languages

329
00:11:35,120 --> 00:11:37,200
as perhaps we should have been it is

330
00:11:37,200 --> 00:11:38,880
well defined and we understand it very

331
00:11:38,880 --> 00:11:40,240
well

332
00:11:40,240 --> 00:11:41,519
another problem in the traditional

333
00:11:41,519 --> 00:11:43,600
software world is that programs are too

334
00:11:43,600 --> 00:11:45,839
big and complex really to verify

335
00:11:45,839 --> 00:11:47,440
one of the advantages of working in a

336
00:11:47,440 --> 00:11:49,519
smart contract area for blockchains is

337
00:11:49,519 --> 00:11:51,440
that smart contracts are generally

338
00:11:51,440 --> 00:11:54,800
simple compared with ordinary software

339
00:11:54,800 --> 00:11:56,639
and finally in the real world and this

340
00:11:56,639 --> 00:11:58,000
was a sad discovery

341
00:11:58,000 --> 00:12:01,200
for me many years ago people often don't

342
00:12:01,200 --> 00:12:02,560
care that much about bugs

343
00:12:02,560 --> 00:12:04,160
even when they really should because

344
00:12:04,160 --> 00:12:06,720
they haven't they're kind of in denial

345
00:12:06,720 --> 00:12:08,560
about the costs and risks incurred by

346
00:12:08,560 --> 00:12:10,320
those bugs and so they don't put enough

347
00:12:10,320 --> 00:12:11,680
effort into avoiding them

348
00:12:11,680 --> 00:12:13,760
in fact some commercial tools for

349
00:12:13,760 --> 00:12:15,360
checking software the most important

350
00:12:15,360 --> 00:12:16,480
thing is to figure out how to

351
00:12:16,480 --> 00:12:18,639
rank all the reports so that people can

352
00:12:18,639 --> 00:12:20,320
fix the worst bugs because they don't

353
00:12:20,320 --> 00:12:23,920
even care about fixing all of the books

354
00:12:23,920 --> 00:12:24,320
so

355
00:12:24,320 --> 00:12:26,480
we care i'm not sure what else to what

356
00:12:26,480 --> 00:12:28,079
more to say about that

357
00:12:28,079 --> 00:12:30,480
so we're going to the happy situation

358
00:12:30,480 --> 00:12:32,160
where we can co-design

359
00:12:32,160 --> 00:12:35,600
our tools including the formal verifier

360
00:12:35,600 --> 00:12:37,920
also the programming style for writing

361
00:12:37,920 --> 00:12:39,279
smart contracts

362
00:12:39,279 --> 00:12:41,600
and the verification methodology to try

363
00:12:41,600 --> 00:12:42,800
to

364
00:12:42,800 --> 00:12:45,600
optimize the conditions for success of

365
00:12:45,600 --> 00:12:48,639
formal verification

366
00:12:50,160 --> 00:12:52,240
so i'm going to pause for a moment and

367
00:12:52,240 --> 00:12:53,600
see does

368
00:12:53,600 --> 00:12:55,040
everybody feel like they know what i'm

369
00:12:55,040 --> 00:12:57,279
talking about with formal verification

370
00:12:57,279 --> 00:12:59,760
etc

371
00:13:02,959 --> 00:13:05,760
um so we'll see some examples of

372
00:13:05,760 --> 00:13:06,959
specifications and

373
00:13:06,959 --> 00:13:08,240
hopefully that will make it more

374
00:13:08,240 --> 00:13:10,320
concrete um if everybody's

375
00:13:10,320 --> 00:13:14,399
happy with to just have me proceed now

376
00:13:14,399 --> 00:13:16,320
so you know there's a lot to know about

377
00:13:16,320 --> 00:13:17,600
blockchains and

378
00:13:17,600 --> 00:13:21,040
here is the minimum that we need to know

379
00:13:21,040 --> 00:13:24,079
a blockchain is a sequence of states

380
00:13:24,079 --> 00:13:25,839
the states might be very large it's

381
00:13:25,839 --> 00:13:27,519
essentially a complete database of

382
00:13:27,519 --> 00:13:29,040
accounts and

383
00:13:29,040 --> 00:13:31,839
maybe various things that various other

384
00:13:31,839 --> 00:13:33,760
things that have been stored it could be

385
00:13:33,760 --> 00:13:36,160
an archive for information

386
00:13:36,160 --> 00:13:39,600
and uh transactions

387
00:13:39,600 --> 00:13:42,880
are program uh

388
00:13:42,880 --> 00:13:45,600
program executions that update one

389
00:13:45,600 --> 00:13:47,199
blockchain state to create the next

390
00:13:47,199 --> 00:13:48,560
blockchain state

391
00:13:48,560 --> 00:13:51,360
so in the diagram here i've drawn a

392
00:13:51,360 --> 00:13:53,199
sequence of alternating states and

393
00:13:53,199 --> 00:13:54,160
transactions

394
00:13:54,160 --> 00:13:55,920
the transactions are what change one

395
00:13:55,920 --> 00:13:58,800
state to the next

396
00:13:58,800 --> 00:14:01,120
a smart contract the idea started off as

397
00:14:01,120 --> 00:14:02,160
being a

398
00:14:02,160 --> 00:14:05,600
precise legal contract written in code

399
00:14:05,600 --> 00:14:08,639
but nowadays it really just means a

400
00:14:08,639 --> 00:14:10,480
code that implements a transaction so

401
00:14:10,480 --> 00:14:14,000
it's code that updates the blockchain

402
00:14:14,000 --> 00:14:16,240
transactions are atomic so they either

403
00:14:16,240 --> 00:14:18,000
run to completion or they don't change

404
00:14:18,000 --> 00:14:19,120
the state at all

405
00:14:19,120 --> 00:14:20,720
you don't get partial changes in the

406
00:14:20,720 --> 00:14:22,160
state in these systems

407
00:14:22,160 --> 00:14:25,279
particularly not in ours and uh

408
00:14:25,279 --> 00:14:27,120
that i'm shading the truth a little bit

409
00:14:27,120 --> 00:14:29,120
here because a transaction

410
00:14:29,120 --> 00:14:31,120
the user who submits a transaction has

411
00:14:31,120 --> 00:14:33,120
to pay for the computation

412
00:14:33,120 --> 00:14:35,279
that's something usually called gas and

413
00:14:35,279 --> 00:14:36,560
so a user will

414
00:14:36,560 --> 00:14:39,199
find that their account balance has been

415
00:14:39,199 --> 00:14:40,880
decreased a little bit even if they have

416
00:14:40,880 --> 00:14:42,480
a failed transaction

417
00:14:42,480 --> 00:14:44,079
we're not modeling that in this system

418
00:14:44,079 --> 00:14:47,279
we've chosen not to do so

419
00:14:47,279 --> 00:14:48,800
so let's look at the blockchain state in

420
00:14:48,800 --> 00:14:51,680
a little more detail

421
00:14:52,480 --> 00:14:55,120
so in our system the blockchain state is

422
00:14:55,120 --> 00:14:56,160
a tree

423
00:14:56,160 --> 00:14:59,839
and the or maybe a forest

424
00:14:59,839 --> 00:15:02,399
and the roots of the trees are numerical

425
00:15:02,399 --> 00:15:04,480
addresses

426
00:15:04,480 --> 00:15:06,639
so these are large numbers and at a

427
00:15:06,639 --> 00:15:08,079
particular address

428
00:15:08,079 --> 00:15:11,120
you can publish an instance of a type

429
00:15:11,120 --> 00:15:14,079
so these types are generally records

430
00:15:14,079 --> 00:15:15,440
they're structs

431
00:15:15,440 --> 00:15:17,120
and so in the example that i'm

432
00:15:17,120 --> 00:15:18,639
displaying here

433
00:15:18,639 --> 00:15:22,000
address two has a publish struct of type

434
00:15:22,000 --> 00:15:24,720
dm account so you can have zero or one

435
00:15:24,720 --> 00:15:26,560
instances of every type

436
00:15:26,560 --> 00:15:28,160
published at a particular address you

437
00:15:28,160 --> 00:15:29,519
can't have more than one instance of a

438
00:15:29,519 --> 00:15:31,600
type published there

439
00:15:31,600 --> 00:15:34,480
so in our system a dm account has quite

440
00:15:34,480 --> 00:15:35,920
a few fields

441
00:15:35,920 --> 00:15:38,639
there are two of them shown here one is

442
00:15:38,639 --> 00:15:40,000
an authentication key

443
00:15:40,000 --> 00:15:42,079
which is essentially a string a vector

444
00:15:42,079 --> 00:15:43,279
of bytes

445
00:15:43,279 --> 00:15:46,160
another one is the sequence number so

446
00:15:46,160 --> 00:15:47,120
sequences

447
00:15:47,120 --> 00:15:50,240
are submitted by they're signed by

448
00:15:50,240 --> 00:15:52,639
accounts the signatures correspond to

449
00:15:52,639 --> 00:15:54,000
individual addresses

450
00:15:54,000 --> 00:15:55,759
and there's a sequence number for each

451
00:15:55,759 --> 00:15:58,240
address for the

452
00:15:58,240 --> 00:16:01,199
transactions that originate at that

453
00:16:01,199 --> 00:16:02,399
address that are assigned by that

454
00:16:02,399 --> 00:16:03,440
address and so this

455
00:16:03,440 --> 00:16:05,040
the sequence number is maintained in the

456
00:16:05,040 --> 00:16:07,680
dm account

457
00:16:07,680 --> 00:16:09,199
we have other things that are published

458
00:16:09,199 --> 00:16:11,040
at addresses in our system

459
00:16:11,040 --> 00:16:13,680
one of those things is a balance now our

460
00:16:13,680 --> 00:16:14,800
language has

461
00:16:14,800 --> 00:16:17,680
type parameters so in this case balance

462
00:16:17,680 --> 00:16:18,959
is a generic struct

463
00:16:18,959 --> 00:16:21,040
which is parameterized by a currency

464
00:16:21,040 --> 00:16:23,120
type and one of the currency types in

465
00:16:23,120 --> 00:16:25,839
our system is xdx

466
00:16:25,839 --> 00:16:27,839
a balanced struct has a field also

467
00:16:27,839 --> 00:16:28,959
called balance

468
00:16:28,959 --> 00:16:31,120
and that field contains a coin struct

469
00:16:31,120 --> 00:16:33,279
which is also parameterized by the

470
00:16:33,279 --> 00:16:36,240
currency the coin struct just has a

471
00:16:36,240 --> 00:16:38,000
value in it which is the amount of

472
00:16:38,000 --> 00:16:38,560
currency

473
00:16:38,560 --> 00:16:40,000
represented by the coin maybe the

474
00:16:40,000 --> 00:16:41,519
denomination if you want to think of it

475
00:16:41,519 --> 00:16:42,480
that way

476
00:16:42,480 --> 00:16:46,639
and that's a 64-bit unsigned integer

477
00:16:46,639 --> 00:16:49,440
you can have multiple currencies so i

478
00:16:49,440 --> 00:16:51,199
said you can't publish the same type

479
00:16:51,199 --> 00:16:52,480
twice but in this case it's a

480
00:16:52,480 --> 00:16:54,320
parameterized type with different

481
00:16:54,320 --> 00:16:56,240
type parameters so we can also have a

482
00:16:56,240 --> 00:16:58,160
balance with the

483
00:16:58,160 --> 00:17:01,279
currency type xus published that

484
00:17:01,279 --> 00:17:03,680
of course has a balanced field which is

485
00:17:03,680 --> 00:17:06,000
also a coin parameterized by xus which

486
00:17:06,000 --> 00:17:06,959
has its own

487
00:17:06,959 --> 00:17:09,919
value field

488
00:17:11,679 --> 00:17:13,359
so i'd like to talk a bit about the move

489
00:17:13,359 --> 00:17:15,359
programming language this was invented

490
00:17:15,359 --> 00:17:17,039
at novi

491
00:17:17,039 --> 00:17:18,799
and so it's a program language for

492
00:17:18,799 --> 00:17:20,160
programming language for implementing

493
00:17:20,160 --> 00:17:22,720
smart contracts on the dm blockchain

494
00:17:22,720 --> 00:17:26,559
i'll mention that the dm blockchain

495
00:17:26,559 --> 00:17:28,319
there could be other blockchains or

496
00:17:28,319 --> 00:17:29,919
we're looking at broader applications of

497
00:17:29,919 --> 00:17:31,280
the move programming language but

498
00:17:31,280 --> 00:17:32,480
initially

499
00:17:32,480 --> 00:17:33,919
we're planning to target the dm

500
00:17:33,919 --> 00:17:35,840
blockchain

501
00:17:35,840 --> 00:17:38,559
so move is designed for safety for

502
00:17:38,559 --> 00:17:41,440
applications like a blockchain

503
00:17:41,440 --> 00:17:43,760
so and this is also based on a sad

504
00:17:43,760 --> 00:17:44,640
experience of

505
00:17:44,640 --> 00:17:46,240
other blockchains using less safe

506
00:17:46,240 --> 00:17:48,799
languages so in move

507
00:17:48,799 --> 00:17:50,960
the modules can only call modules that

508
00:17:50,960 --> 00:17:52,320
already exist

509
00:17:52,320 --> 00:17:54,320
so the dependency graph of modules has

510
00:17:54,320 --> 00:17:57,200
to be acyclic

511
00:17:57,840 --> 00:17:59,200
other blockchain languages have

512
00:17:59,200 --> 00:18:01,200
reentrancy issues so you can have a

513
00:18:01,200 --> 00:18:03,520
smart contract that calls a function

514
00:18:03,520 --> 00:18:05,760
another smart contract that other smart

515
00:18:05,760 --> 00:18:08,320
contract can recursively call back

516
00:18:08,320 --> 00:18:10,000
to the function that called it and there

517
00:18:10,000 --> 00:18:12,000
have been millions and millions of

518
00:18:12,000 --> 00:18:13,520
dollars stolen and lost

519
00:18:13,520 --> 00:18:16,240
because of problems like this so we just

520
00:18:16,240 --> 00:18:18,880
don't allow that

521
00:18:19,280 --> 00:18:22,240
and we have a special type of structure

522
00:18:22,240 --> 00:18:23,840
called a resource type

523
00:18:23,840 --> 00:18:27,679
which models physical assets and so

524
00:18:27,679 --> 00:18:29,600
what that means is in type theory this

525
00:18:29,600 --> 00:18:30,960
is a linear type

526
00:18:30,960 --> 00:18:33,600
it's a type that cannot be deleted or

527
00:18:33,600 --> 00:18:35,440
duplicated except by the module that

528
00:18:35,440 --> 00:18:36,640
defines the type

529
00:18:36,640 --> 00:18:39,039
so for example you can represent a coin

530
00:18:39,039 --> 00:18:40,400
you could have a module

531
00:18:40,400 --> 00:18:42,799
that creates a coin returns have a

532
00:18:42,799 --> 00:18:44,400
function in that module that creates a

533
00:18:44,400 --> 00:18:45,679
coin and returns it

534
00:18:45,679 --> 00:18:47,760
and then other modules can only pass the

535
00:18:47,760 --> 00:18:49,360
coin around they can't delete it

536
00:18:49,360 --> 00:18:53,199
or accidentally lose it or copy it

537
00:18:53,679 --> 00:18:56,080
the move language has limited expressive

538
00:18:56,080 --> 00:18:58,240
power this may seem like a bad thing but

539
00:18:58,240 --> 00:18:59,760
if you're trying to analyze or

540
00:18:59,760 --> 00:19:03,360
particularly formally verify a piece of

541
00:19:03,360 --> 00:19:05,600
software your ability to do that is

542
00:19:05,600 --> 00:19:07,440
inversely proportional to the expressive

543
00:19:07,440 --> 00:19:08,640
power of the language

544
00:19:08,640 --> 00:19:10,480
so what you'd like is language just

545
00:19:10,480 --> 00:19:12,000
strong enough to say what you need to

546
00:19:12,000 --> 00:19:12,799
say

547
00:19:12,799 --> 00:19:14,559
and that means you'll be able to

548
00:19:14,559 --> 00:19:16,640
maximize your ability to verify

549
00:19:16,640 --> 00:19:20,559
properties of programs in that language

550
00:19:20,880 --> 00:19:22,799
compilation of move is a traditional

551
00:19:22,799 --> 00:19:24,559
looking process you start with a move

552
00:19:24,559 --> 00:19:26,080
source program you put it through a

553
00:19:26,080 --> 00:19:27,120
compiler

554
00:19:27,120 --> 00:19:30,000
and that generates in our case bytecode

555
00:19:30,000 --> 00:19:30,799
which

556
00:19:30,799 --> 00:19:35,760
is is not directly machine code the um

557
00:19:35,760 --> 00:19:37,840
therefore like java we have a bytecode

558
00:19:37,840 --> 00:19:39,679
verifier that does semantic checks on

559
00:19:39,679 --> 00:19:40,480
the bytecode

560
00:19:40,480 --> 00:19:42,400
the compiler also does cement the same

561
00:19:42,400 --> 00:19:44,480
semantics checks in order to be able to

562
00:19:44,480 --> 00:19:46,559
report errors intelligently to the user

563
00:19:46,559 --> 00:19:46,880
who

564
00:19:46,880 --> 00:19:49,360
needs to fix the program but we're

565
00:19:49,360 --> 00:19:50,240
relying

566
00:19:50,240 --> 00:19:54,000
on the semantic checks that are done

567
00:19:54,000 --> 00:19:56,320
on the bytecode itself because we don't

568
00:19:56,320 --> 00:19:57,919
want to have to trust the compiler

569
00:19:57,919 --> 00:19:59,440
we'd like to remove the compiler from

570
00:19:59,440 --> 00:20:01,200
the trusted computing base

571
00:20:01,200 --> 00:20:03,200
and just rely on the properties of the

572
00:20:03,200 --> 00:20:04,480
bytecode itself

573
00:20:04,480 --> 00:20:05,840
because it's the byte codes that are

574
00:20:05,840 --> 00:20:07,760
deployed on the blockchain so there's a

575
00:20:07,760 --> 00:20:09,440
separate bytecode verifier

576
00:20:09,440 --> 00:20:10,880
i want to make clear that even though

577
00:20:10,880 --> 00:20:13,280
i'm using the v word for the bytecode

578
00:20:13,280 --> 00:20:14,159
verifier

579
00:20:14,159 --> 00:20:16,559
it is not a formal verifier i'm just

580
00:20:16,559 --> 00:20:17,919
we're just using the same

581
00:20:17,919 --> 00:20:20,480
terminology that's been handed down to

582
00:20:20,480 --> 00:20:22,720
us from other languages like java

583
00:20:22,720 --> 00:20:24,880
it's a semantic checker that runs in

584
00:20:24,880 --> 00:20:27,840
polynomial time

585
00:20:28,559 --> 00:20:32,559
um good so as a matter of architecture

586
00:20:32,559 --> 00:20:36,400
and just to security and sanity

587
00:20:36,400 --> 00:20:38,240
we want we have a policy that every

588
00:20:38,240 --> 00:20:39,760
change or almost every change in the

589
00:20:39,760 --> 00:20:41,280
blockchain state goes through the move

590
00:20:41,280 --> 00:20:43,679
virtual machine

591
00:20:43,679 --> 00:20:46,400
so blockchain state at any point in time

592
00:20:46,400 --> 00:20:48,080
as a database that we're updating

593
00:20:48,080 --> 00:20:50,400
reading and writing and so what we want

594
00:20:50,400 --> 00:20:51,760
is that the thing that does the reading

595
00:20:51,760 --> 00:20:53,520
and writing to that database is the move

596
00:20:53,520 --> 00:20:55,840
virtual machine

597
00:20:55,840 --> 00:20:59,120
the move virtual machine

598
00:20:59,440 --> 00:21:01,760
executes transaction scripts which are

599
00:21:01,760 --> 00:21:02,799
written in the move

600
00:21:02,799 --> 00:21:04,880
language actually the bytecode for the

601
00:21:04,880 --> 00:21:06,559
move language

602
00:21:06,559 --> 00:21:10,000
and those scripts can call library

603
00:21:10,000 --> 00:21:10,880
functions

604
00:21:10,880 --> 00:21:13,919
which are on modules also written in

605
00:21:13,919 --> 00:21:16,480
in the move bytecode language which are

606
00:21:16,480 --> 00:21:19,600
stored in the blockchain

607
00:21:20,640 --> 00:21:22,320
all of the basic functionality of the

608
00:21:22,320 --> 00:21:23,919
blockchain is implemented in smart

609
00:21:23,919 --> 00:21:24,960
contracts

610
00:21:24,960 --> 00:21:28,000
so that includes the currencies

611
00:21:28,000 --> 00:21:30,640
concepts such as accounts and things to

612
00:21:30,640 --> 00:21:31,840
say

613
00:21:31,840 --> 00:21:33,760
the access control rules associated with

614
00:21:33,760 --> 00:21:35,280
the accounts

615
00:21:35,280 --> 00:21:38,559
and lots of other stuff

616
00:21:39,919 --> 00:21:41,760
so let's talk about the move prover main

617
00:21:41,760 --> 00:21:43,200
topic of this

618
00:21:43,200 --> 00:21:46,480
talk so it's a formal specification

619
00:21:46,480 --> 00:21:48,320
and verification system for move

620
00:21:48,320 --> 00:21:49,520
programs

621
00:21:49,520 --> 00:21:52,880
so uh uses you know basic ideas from

622
00:21:52,880 --> 00:21:56,159
the late 1960s i guess by papers from

623
00:21:56,159 --> 00:21:57,440
floyd and horror

624
00:21:57,440 --> 00:21:59,679
both of whom got touring awards for this

625
00:21:59,679 --> 00:22:02,480
this and other work

626
00:22:02,480 --> 00:22:05,520
so it involves annotating

627
00:22:05,520 --> 00:22:07,840
programs with explicit specifications

628
00:22:07,840 --> 00:22:09,679
especially pre and post conditions for

629
00:22:09,679 --> 00:22:10,960
individual functions

630
00:22:10,960 --> 00:22:13,039
although we've extended that some but

631
00:22:13,039 --> 00:22:15,360
we're using the the approach that was

632
00:22:15,360 --> 00:22:17,280
proposed way back then it's just that

633
00:22:17,280 --> 00:22:19,360
because we've got better technology now

634
00:22:19,360 --> 00:22:22,320
we can automate it

635
00:22:22,559 --> 00:22:24,080
so specifications are written in a

636
00:22:24,080 --> 00:22:26,159
mathematically precise language it's

637
00:22:26,159 --> 00:22:26,960
logic

638
00:22:26,960 --> 00:22:28,640
it looks like the move language but it's

639
00:22:28,640 --> 00:22:30,880
a distinct language

640
00:22:30,880 --> 00:22:32,480
specifications are separate from

641
00:22:32,480 --> 00:22:34,000
implementations

642
00:22:34,000 --> 00:22:36,000
so the idea is that the specifications

643
00:22:36,000 --> 00:22:38,240
explicitly capture the intent of the

644
00:22:38,240 --> 00:22:38,880
user

645
00:22:38,880 --> 00:22:40,320
there are some requirements of the

646
00:22:40,320 --> 00:22:41,919
system and those requirements

647
00:22:41,919 --> 00:22:45,039
are implemented by developers and

648
00:22:45,039 --> 00:22:46,960
the way that the developer is

649
00:22:46,960 --> 00:22:48,320
implementing those requirements is

650
00:22:48,320 --> 00:22:49,600
supposed to be captured

651
00:22:49,600 --> 00:22:51,280
in a specification which is at least

652
00:22:51,280 --> 00:22:52,960
somewhat independent of the code in the

653
00:22:52,960 --> 00:22:55,280
system

654
00:22:55,280 --> 00:22:57,039
so for the process of formal

655
00:22:57,039 --> 00:22:58,880
verification is proving

656
00:22:58,880 --> 00:23:01,200
automatically that a move program

657
00:23:01,200 --> 00:23:03,039
satisfies the specification for all

658
00:23:03,039 --> 00:23:03,679
inputs

659
00:23:03,679 --> 00:23:06,840
in all states so formal verification is

660
00:23:06,840 --> 00:23:08,240
certainly

661
00:23:08,240 --> 00:23:10,960
uh testing on steroids or something so

662
00:23:10,960 --> 00:23:12,400
with testing you always have to worry

663
00:23:12,400 --> 00:23:13,120
about

664
00:23:13,120 --> 00:23:14,960
what testing your test coverage what

665
00:23:14,960 --> 00:23:17,679
test inputs are there what state was you

666
00:23:17,679 --> 00:23:19,200
were you in what assumptions do you make

667
00:23:19,200 --> 00:23:20,240
about the state

668
00:23:20,240 --> 00:23:23,120
when you test and formal verification is

669
00:23:23,120 --> 00:23:24,400
all possible inputs

670
00:23:24,400 --> 00:23:27,679
and in all possible states

671
00:23:30,320 --> 00:23:32,320
so our goal is to prove correctness not

672
00:23:32,320 --> 00:23:34,159
to hunt for bugs so this is a

673
00:23:34,159 --> 00:23:35,840
subtle point and it actually took me a

674
00:23:35,840 --> 00:23:37,679
little while to realize that i shifted

675
00:23:37,679 --> 00:23:38,799
gears

676
00:23:38,799 --> 00:23:41,039
early in my career i started trying to

677
00:23:41,039 --> 00:23:42,559
prove that things were correct

678
00:23:42,559 --> 00:23:45,679
and what i discovered is that

679
00:23:45,679 --> 00:23:47,200
hunting for bugs is sort of more

680
00:23:47,200 --> 00:23:48,640
satisfying so if you want to write a

681
00:23:48,640 --> 00:23:49,440
paper

682
00:23:49,440 --> 00:23:51,760
saying you found a bug in somebody's

683
00:23:51,760 --> 00:23:54,080
seemingly obviously correct design

684
00:23:54,080 --> 00:23:56,320
was kind of more impressive than saying

685
00:23:56,320 --> 00:23:58,159
yep the seemingly correct design was

686
00:23:58,159 --> 00:23:59,200
correct

687
00:23:59,200 --> 00:24:02,080
and in particular the designer of that

688
00:24:02,080 --> 00:24:04,559
artifact that you're formally verifying

689
00:24:04,559 --> 00:24:06,080
is more impressed because of course they

690
00:24:06,080 --> 00:24:07,039
thought it was correct when they

691
00:24:07,039 --> 00:24:08,080
designed it

692
00:24:08,080 --> 00:24:11,919
and hearing about a bug in the design is

693
00:24:11,919 --> 00:24:13,840
much more surprising to them and i said

694
00:24:13,840 --> 00:24:16,159
impress they're not necessarily pleased

695
00:24:16,159 --> 00:24:17,840
but at least you get your their

696
00:24:17,840 --> 00:24:19,919
attention if you can find a bug in

697
00:24:19,919 --> 00:24:21,760
something that

698
00:24:21,760 --> 00:24:24,080
they thought was correct in our case

699
00:24:24,080 --> 00:24:25,520
we're looking at

700
00:24:25,520 --> 00:24:28,559
providing high assurance right so we

701
00:24:28,559 --> 00:24:29,279
want to

702
00:24:29,279 --> 00:24:30,840
develop more confidence in the

703
00:24:30,840 --> 00:24:33,440
correctness and

704
00:24:33,440 --> 00:24:35,440
lack of security vulnerabilities in our

705
00:24:35,440 --> 00:24:37,919
code so

706
00:24:37,919 --> 00:24:39,600
our goal is actually to show that it's

707
00:24:39,600 --> 00:24:40,960
correct we

708
00:24:40,960 --> 00:24:42,799
expect that we'll find bugs and we have

709
00:24:42,799 --> 00:24:45,039
found bugs but that's not the measure of

710
00:24:45,039 --> 00:24:47,440
success the measure of success is

711
00:24:47,440 --> 00:24:49,440
hard to quantify but it's how thoroughly

712
00:24:49,440 --> 00:24:51,039
we specified the thing

713
00:24:51,039 --> 00:24:52,559
are we able to verify all our

714
00:24:52,559 --> 00:24:54,240
specifications and

715
00:24:54,240 --> 00:24:56,159
can we use that information to persuade

716
00:24:56,159 --> 00:24:58,559
people such as auditors or whatever that

717
00:24:58,559 --> 00:24:59,840
they should have more confidence in

718
00:24:59,840 --> 00:25:01,520
their code than they would have had we

719
00:25:01,520 --> 00:25:04,400
not done all that work

720
00:25:06,400 --> 00:25:08,799
so let's talk about the how

721
00:25:08,799 --> 00:25:10,480
specification works

722
00:25:10,480 --> 00:25:11,919
specification is one of the hardest

723
00:25:11,919 --> 00:25:13,760
problems in verification verification is

724
00:25:13,760 --> 00:25:15,440
a field with many heart problems many

725
00:25:15,440 --> 00:25:15,840
other

726
00:25:15,840 --> 00:25:18,559
computational complexity problems but

727
00:25:18,559 --> 00:25:19,200
one of the

728
00:25:19,200 --> 00:25:22,400
ones that's received less work you know

729
00:25:22,400 --> 00:25:24,400
it's a fuzzy problem it hasn't been

730
00:25:24,400 --> 00:25:25,919
worked on as much as the other problems

731
00:25:25,919 --> 00:25:27,200
and it's one that i'm greatly worried

732
00:25:27,200 --> 00:25:29,279
about is how to ensure the completeness

733
00:25:29,279 --> 00:25:32,000
and correctness of the specifications

734
00:25:32,000 --> 00:25:33,600
so errors in the specification are

735
00:25:33,600 --> 00:25:35,440
dangerous in several ways

736
00:25:35,440 --> 00:25:37,039
of course there are false positives

737
00:25:37,039 --> 00:25:38,799
which are bogus error reports they don't

738
00:25:38,799 --> 00:25:39,919
represent rep

739
00:25:39,919 --> 00:25:42,159
real bugs but they're annoying and they

740
00:25:42,159 --> 00:25:43,440
require debugging

741
00:25:43,440 --> 00:25:45,840
either the code or the spec i'm sorry if

742
00:25:45,840 --> 00:25:47,120
it's a false positive it requires

743
00:25:47,120 --> 00:25:48,640
debugging the spec the problem is you

744
00:25:48,640 --> 00:25:50,640
have a wrong spec

745
00:25:50,640 --> 00:25:52,400
that's okay to at some extent you know

746
00:25:52,400 --> 00:25:54,320
you should expect to have to debug your

747
00:25:54,320 --> 00:25:55,360
specs

748
00:25:55,360 --> 00:25:57,360
but you don't want to waste too much

749
00:25:57,360 --> 00:25:59,120
time dealing with silly errors that

750
00:25:59,120 --> 00:26:00,720
aren't real

751
00:26:00,720 --> 00:26:03,279
more dangerous are false negatives so

752
00:26:03,279 --> 00:26:03,919
because we're

753
00:26:03,919 --> 00:26:06,240
interested in proving correctness we

754
00:26:06,240 --> 00:26:07,279
want to go for

755
00:26:07,279 --> 00:26:09,600
completeness of our specs and

756
00:26:09,600 --> 00:26:10,640
completeness of

757
00:26:10,640 --> 00:26:12,480
the algorithms in the verifier we do not

758
00:26:12,480 --> 00:26:13,840
want to miss errors

759
00:26:13,840 --> 00:26:15,919
or security vulnerabilities because that

760
00:26:15,919 --> 00:26:17,440
could be much more serious

761
00:26:17,440 --> 00:26:21,120
in the context where we're applying this

762
00:26:21,440 --> 00:26:23,919
so one of the ways we we're still

763
00:26:23,919 --> 00:26:24,880
working on the problem with

764
00:26:24,880 --> 00:26:26,559
specification completeness

765
00:26:26,559 --> 00:26:28,559
but one of the ways the simple things we

766
00:26:28,559 --> 00:26:30,159
can do is enable users to write

767
00:26:30,159 --> 00:26:31,279
specifications

768
00:26:31,279 --> 00:26:33,919
in their most obviously correct form so

769
00:26:33,919 --> 00:26:35,600
a lot of work and formal verification

770
00:26:35,600 --> 00:26:37,200
including work that i've done

771
00:26:37,200 --> 00:26:38,960
involves clever encoding of

772
00:26:38,960 --> 00:26:40,960
specifications to make it possible to

773
00:26:40,960 --> 00:26:42,400
solve the problem at all

774
00:26:42,400 --> 00:26:44,240
we'd like to avoid those clever

775
00:26:44,240 --> 00:26:45,760
encodings and have people just write

776
00:26:45,760 --> 00:26:46,400
logic

777
00:26:46,400 --> 00:26:49,679
so sometimes it's a challenge to get to

778
00:26:49,679 --> 00:26:51,440
learn enough logic to do this

779
00:26:51,440 --> 00:26:52,960
but once you know the logic you should

780
00:26:52,960 --> 00:26:55,120
be able to take something you've

781
00:26:55,120 --> 00:26:57,039
said in english that's a correctness

782
00:26:57,039 --> 00:26:58,640
property and write it down

783
00:26:58,640 --> 00:27:00,799
in a logical form that you know is

784
00:27:00,799 --> 00:27:03,200
pretty much what you expected

785
00:27:03,200 --> 00:27:05,120
so one of the things here is we use

786
00:27:05,120 --> 00:27:08,400
quantifiers for all x there exist sex

787
00:27:08,400 --> 00:27:11,760
freely in our language a lot of work and

788
00:27:11,760 --> 00:27:13,360
formal verification has gone into

789
00:27:13,360 --> 00:27:15,200
avoiding quantifiers because you end up

790
00:27:15,200 --> 00:27:17,200
with an undecidable problem if you use

791
00:27:17,200 --> 00:27:18,000
them

792
00:27:18,000 --> 00:27:19,520
but we just had to bite the bullet and

793
00:27:19,520 --> 00:27:22,960
do that for clarity

794
00:27:22,960 --> 00:27:24,720
uh you will see some examples of those

795
00:27:24,720 --> 00:27:27,440
later in the talk

796
00:27:27,520 --> 00:27:30,880
so here's what the stages that

797
00:27:30,880 --> 00:27:35,600
processing a verification task look like

798
00:27:35,600 --> 00:27:39,200
so you start with move source code um

799
00:27:39,200 --> 00:27:42,960
here and that gets parsed in a typical

800
00:27:42,960 --> 00:27:43,840
way

801
00:27:43,840 --> 00:27:45,679
to pull out the specifications which are

802
00:27:45,679 --> 00:27:47,279
right now mingled with the source code

803
00:27:47,279 --> 00:27:48,000
we're thinking about

804
00:27:48,000 --> 00:27:49,360
separating them but we haven't made that

805
00:27:49,360 --> 00:27:52,000
decision yet

806
00:27:52,159 --> 00:27:53,760
the source code also goes to the move

807
00:27:53,760 --> 00:27:55,200
compiler

808
00:27:55,200 --> 00:27:58,640
which produces bytecode so at this point

809
00:27:58,640 --> 00:28:00,720
we've got

810
00:28:00,720 --> 00:28:02,240
abstract syntax tree for the

811
00:28:02,240 --> 00:28:04,080
specification bytecode for the actual

812
00:28:04,080 --> 00:28:05,600
code

813
00:28:05,600 --> 00:28:08,320
and then we process that to pull out all

814
00:28:08,320 --> 00:28:10,320
the useful information put it in various

815
00:28:10,320 --> 00:28:13,360
tables and structures etc

816
00:28:13,360 --> 00:28:14,840
then we go through another stage of

817
00:28:14,840 --> 00:28:17,360
translation that generates

818
00:28:17,360 --> 00:28:19,919
boogie code boogie i'll talk about

819
00:28:19,919 --> 00:28:20,799
shortly

820
00:28:20,799 --> 00:28:23,039
it is a system from microsoft that

821
00:28:23,039 --> 00:28:24,960
defines a language it's an intermediate

822
00:28:24,960 --> 00:28:26,480
language for verification

823
00:28:26,480 --> 00:28:28,720
which makes it easier to go from a real

824
00:28:28,720 --> 00:28:30,240
programming language

825
00:28:30,240 --> 00:28:32,799
to logic puzzles that can be solved by

826
00:28:32,799 --> 00:28:34,159
the logic solver

827
00:28:34,159 --> 00:28:35,840
so boogie will translate something that

828
00:28:35,840 --> 00:28:37,840
looks like an imperative language

829
00:28:37,840 --> 00:28:41,279
to logic expressions that can be solved

830
00:28:41,279 --> 00:28:42,720
with smt solvers

831
00:28:42,720 --> 00:28:46,080
so smt solvers are one of the advances

832
00:28:46,080 --> 00:28:47,840
of perhaps the major advance over the

833
00:28:47,840 --> 00:28:49,440
last 20 years that makes this whole

834
00:28:49,440 --> 00:28:49,840
thing

835
00:28:49,840 --> 00:28:52,240
possible so the ability to solve large

836
00:28:52,240 --> 00:28:54,960
large logic problems

837
00:28:54,960 --> 00:28:58,480
automatically so uh if an snt if there's

838
00:28:58,480 --> 00:29:00,000
a bug in your program

839
00:29:00,000 --> 00:29:03,520
the smt solver will produce a counter

840
00:29:03,520 --> 00:29:05,840
example that to the the property you're

841
00:29:05,840 --> 00:29:07,360
trying to prove so that will be an

842
00:29:07,360 --> 00:29:08,399
example

843
00:29:08,399 --> 00:29:10,640
of some state where the property and

844
00:29:10,640 --> 00:29:12,559
inputs where the property is not does

845
00:29:12,559 --> 00:29:13,919
not hold

846
00:29:13,919 --> 00:29:16,480
but it's going to be in the funny s t

847
00:29:16,480 --> 00:29:17,600
language

848
00:29:17,600 --> 00:29:19,760
and so when you have a tool change like

849
00:29:19,760 --> 00:29:21,760
this you need a forward path

850
00:29:21,760 --> 00:29:23,840
to do the processing and get the answer

851
00:29:23,840 --> 00:29:24,960
to your question

852
00:29:24,960 --> 00:29:28,480
and then you need a backward pass to

853
00:29:28,480 --> 00:29:30,880
take whatever diagnostics you get from

854
00:29:30,880 --> 00:29:32,720
tools further down the chain

855
00:29:32,720 --> 00:29:34,399
and translate them into things that are

856
00:29:34,399 --> 00:29:36,640
understandable by tools further up the

857
00:29:36,640 --> 00:29:40,159
chain so we've got the move language the

858
00:29:40,159 --> 00:29:42,640
boogie translator and the smt solver

859
00:29:42,640 --> 00:29:46,240
we get an example counter example an smt

860
00:29:46,240 --> 00:29:49,360
uh notation we need to back translate

861
00:29:49,360 --> 00:29:49,760
that

862
00:29:49,760 --> 00:29:52,799
into a notation that

863
00:29:52,799 --> 00:29:55,279
corresponds to the boogie intermediate

864
00:29:55,279 --> 00:29:56,320
representation

865
00:29:56,320 --> 00:29:58,159
that this back translation is largely

866
00:29:58,159 --> 00:29:59,760
done by boogie

867
00:29:59,760 --> 00:30:01,360
and then we need to back translate that

868
00:30:01,360 --> 00:30:03,039
further to something that some

869
00:30:03,039 --> 00:30:04,559
somebody is looking something that

870
00:30:04,559 --> 00:30:06,880
someone who is looking at the move code

871
00:30:06,880 --> 00:30:10,640
can understand and so that involves

872
00:30:10,640 --> 00:30:13,120
some code to parse the results of boogie

873
00:30:13,120 --> 00:30:14,640
and translate them back into an

874
00:30:14,640 --> 00:30:16,000
understandable example

875
00:30:16,000 --> 00:30:18,000
and it also involves putting a lot of

876
00:30:18,000 --> 00:30:19,520
bookkeeping stuff in the boogie

877
00:30:19,520 --> 00:30:21,440
translation so we can actually

878
00:30:21,440 --> 00:30:23,919
do that mapping back to line numbers and

879
00:30:23,919 --> 00:30:27,360
things like that in the original code

880
00:30:29,279 --> 00:30:31,600
i'll mention that in a lot of the work

881
00:30:31,600 --> 00:30:33,520
of formal verification

882
00:30:33,520 --> 00:30:36,080
this ability to debug has kind of been

883
00:30:36,080 --> 00:30:38,399
neglected but it's of course critical

884
00:30:38,399 --> 00:30:40,799
if you're most of the time when you run

885
00:30:40,799 --> 00:30:42,559
the verifier a new code

886
00:30:42,559 --> 00:30:44,080
you find a problem just like running a

887
00:30:44,080 --> 00:30:45,520
compiler and if you couldn't get good

888
00:30:45,520 --> 00:30:47,200
error messages out of compiler

889
00:30:47,200 --> 00:30:49,120
it would really reduce your productivity

890
00:30:49,120 --> 00:30:50,320
so we're trying to solve the same

891
00:30:50,320 --> 00:30:53,678
problem for a formal verifier

892
00:30:54,799 --> 00:30:56,559
so i'll talk a little bit about boogie

893
00:30:56,559 --> 00:30:58,320
it was developed in microsoft as an

894
00:30:58,320 --> 00:31:00,320
intermediate language for verification

895
00:31:00,320 --> 00:31:02,799
so it's between the program level and

896
00:31:02,799 --> 00:31:04,159
the s smt solver

897
00:31:04,159 --> 00:31:06,000
so characteristics of this is it looks

898
00:31:06,000 --> 00:31:07,760
approximately like a simple imperative

899
00:31:07,760 --> 00:31:08,480
language

900
00:31:08,480 --> 00:31:10,960
it has procedures with procedure like

901
00:31:10,960 --> 00:31:11,919
semantics

902
00:31:11,919 --> 00:31:15,120
it has assignment which update a

903
00:31:15,120 --> 00:31:18,000
state and it has data structures that

904
00:31:18,000 --> 00:31:19,120
are based in the theories that are

905
00:31:19,120 --> 00:31:21,279
provided in smt solvers so

906
00:31:21,279 --> 00:31:24,240
that includes integers arrays uh real

907
00:31:24,240 --> 00:31:25,279
numbers

908
00:31:25,279 --> 00:31:27,279
uh recursive data structures that sort

909
00:31:27,279 --> 00:31:29,519
of thing

910
00:31:29,519 --> 00:31:32,159
okay and so we have a problem of how to

911
00:31:32,159 --> 00:31:33,200
translate

912
00:31:33,200 --> 00:31:35,039
bytecodes from the move bytecode

913
00:31:35,039 --> 00:31:36,799
language to the

914
00:31:36,799 --> 00:31:38,640
boogie input so we can feed it into the

915
00:31:38,640 --> 00:31:40,399
boogie translator

916
00:31:40,399 --> 00:31:42,480
and the way we do that is we implement

917
00:31:42,480 --> 00:31:43,840
each bytecode instruction

918
00:31:43,840 --> 00:31:46,799
as a boogie procedure and then when we

919
00:31:46,799 --> 00:31:48,640
translate a bytecode program it looks

920
00:31:48,640 --> 00:31:49,440
like

921
00:31:49,440 --> 00:31:51,120
it's boogie code this is just a sequence

922
00:31:51,120 --> 00:31:52,480
of procedure calls

923
00:31:52,480 --> 00:31:54,880
to implement each of the individual

924
00:31:54,880 --> 00:31:55,760
instructions

925
00:31:55,760 --> 00:32:00,720
in the bytecode program

926
00:32:00,720 --> 00:32:04,000
um so a complete translation involves

927
00:32:04,000 --> 00:32:05,919
taking the specifications and converting

928
00:32:05,919 --> 00:32:08,000
them into assumptions and assertions and

929
00:32:08,000 --> 00:32:08,799
boogie

930
00:32:08,799 --> 00:32:11,679
so an assumption is logically an

931
00:32:11,679 --> 00:32:13,760
assumption is something you can

932
00:32:13,760 --> 00:32:17,679
use to complete a proof and the

933
00:32:17,679 --> 00:32:20,159
logic analyzer doesn't check that the

934
00:32:20,159 --> 00:32:22,080
assumption is true so when you put it in

935
00:32:22,080 --> 00:32:23,679
there better be something that's true

936
00:32:23,679 --> 00:32:26,480
or that you've proved elsewhere and the

937
00:32:26,480 --> 00:32:27,840
assertions are things that need to be

938
00:32:27,840 --> 00:32:28,320
proved

939
00:32:28,320 --> 00:32:31,360
so those are the actual uh results of

940
00:32:31,360 --> 00:32:34,080
verification

941
00:32:34,880 --> 00:32:36,240
i'm going to pause for a moment because

942
00:32:36,240 --> 00:32:39,360
there's a garbage truck making noise

943
00:32:39,360 --> 00:32:44,000
okay there is please

944
00:32:44,000 --> 00:32:46,880
and the question is is move touring

945
00:32:46,880 --> 00:32:49,360
complete

946
00:32:49,679 --> 00:32:52,960
yes um

947
00:32:52,960 --> 00:32:55,840
so it doesn't you know turing

948
00:32:55,840 --> 00:32:57,679
completeness is always tricky so there's

949
00:32:57,679 --> 00:32:59,519
some subtleties to that that we're not

950
00:32:59,519 --> 00:33:02,559
relying on okay so first of all any real

951
00:33:02,559 --> 00:33:04,480
programming language is is actually

952
00:33:04,480 --> 00:33:06,480
finite state uh

953
00:33:06,480 --> 00:33:08,880
when implemented but that's useless

954
00:33:08,880 --> 00:33:10,640
because they're just some astronomically

955
00:33:10,640 --> 00:33:11,039
many

956
00:33:11,039 --> 00:33:12,480
states that it's easier to consider

957
00:33:12,480 --> 00:33:14,080
things to be infinite

958
00:33:14,080 --> 00:33:17,120
uh more particularly in blockchains

959
00:33:17,120 --> 00:33:18,480
there's a gas limit

960
00:33:18,480 --> 00:33:21,039
right so when you submit a transaction

961
00:33:21,039 --> 00:33:22,640
you have to give a bound on the amount

962
00:33:22,640 --> 00:33:23,600
of resources

963
00:33:23,600 --> 00:33:26,399
so that's puts a bound on any loops or

964
00:33:26,399 --> 00:33:27,840
infinite recursion

965
00:33:27,840 --> 00:33:31,519
so it has to stop and um

966
00:33:31,519 --> 00:33:33,039
what that means is that rather than

967
00:33:33,039 --> 00:33:35,039
going into an infinite loop

968
00:33:35,039 --> 00:33:36,559
uh something with that looks like an

969
00:33:36,559 --> 00:33:38,640
infinite loop will burn up all the gas

970
00:33:38,640 --> 00:33:41,600
that's available and then abort

971
00:33:41,600 --> 00:33:43,600
but we're not taking advantage of that

972
00:33:43,600 --> 00:33:45,200
property either

973
00:33:45,200 --> 00:33:48,720
so we're uh we're

974
00:33:48,720 --> 00:33:49,840
kind of dealing with the turing

975
00:33:49,840 --> 00:33:52,320
completeness in practice we don't have

976
00:33:52,320 --> 00:33:53,840
that many loops in these contracts we

977
00:33:53,840 --> 00:33:55,519
have some for loops almost all of which

978
00:33:55,519 --> 00:33:57,200
are doing linear search

979
00:33:57,200 --> 00:34:00,399
i think in various forms and so we

980
00:34:00,399 --> 00:34:01,919
you know painfully write the loop and

981
00:34:01,919 --> 00:34:03,840
variance necessary to verify those

982
00:34:03,840 --> 00:34:04,559
things

983
00:34:04,559 --> 00:34:06,559
and we haven't done any proofs of

984
00:34:06,559 --> 00:34:07,600
termination

985
00:34:07,600 --> 00:34:09,440
which would in this case be proofs that

986
00:34:09,440 --> 00:34:11,760
you don't run out of gas and abort

987
00:34:11,760 --> 00:34:13,679
so those are all problems we should

988
00:34:13,679 --> 00:34:15,040
solve but

989
00:34:15,040 --> 00:34:17,918
that's where we are now anyway the

990
00:34:17,918 --> 00:34:19,199
language

991
00:34:19,199 --> 00:34:21,440
while limited in expressiveness is still

992
00:34:21,440 --> 00:34:24,159
touring complete

993
00:34:24,320 --> 00:34:28,000
are there more questions that's all so

994
00:34:28,000 --> 00:34:28,960
far

995
00:34:28,960 --> 00:34:30,560
okay good i hope that means that people

996
00:34:30,560 --> 00:34:32,800
are understanding

997
00:34:32,800 --> 00:34:34,639
so let's talk about using the prover so

998
00:34:34,639 --> 00:34:36,239
this will make some things concrete that

999
00:34:36,239 --> 00:34:37,040
i've been

1000
00:34:37,040 --> 00:34:39,520
waving my hands about so let's look at a

1001
00:34:39,520 --> 00:34:40,800
particular example

1002
00:34:40,800 --> 00:34:43,199
of a fragment of a state so in this

1003
00:34:43,199 --> 00:34:44,320
state

1004
00:34:44,320 --> 00:34:48,079
uh i've got things happening at address

1005
00:34:48,079 --> 00:34:51,119
two and

1006
00:34:51,119 --> 00:34:53,280
it has a dm account object published

1007
00:34:53,280 --> 00:34:57,359
there uh as in a previous example

1008
00:34:57,359 --> 00:35:00,560
but um i'm also showing a different

1009
00:35:00,560 --> 00:35:02,079
structure that it has

1010
00:35:02,079 --> 00:35:04,800
published called a role id so this is a

1011
00:35:04,800 --> 00:35:06,640
struct that's used in access control in

1012
00:35:06,640 --> 00:35:07,680
our system

1013
00:35:07,680 --> 00:35:09,599
which is something we've verified pretty

1014
00:35:09,599 --> 00:35:10,960
thoroughly

1015
00:35:10,960 --> 00:35:13,839
so a role id is basically just an

1016
00:35:13,839 --> 00:35:15,520
enumerated type this small set of

1017
00:35:15,520 --> 00:35:17,599
integers representing different roles

1018
00:35:17,599 --> 00:35:19,760
including something that corresponds to

1019
00:35:19,760 --> 00:35:21,040
kind of the route account in an

1020
00:35:21,040 --> 00:35:23,440
operating system called dm root

1021
00:35:23,440 --> 00:35:27,119
uh treasury compliance is one of them

1022
00:35:27,119 --> 00:35:31,040
which in um

1023
00:35:31,040 --> 00:35:32,880
is kind of responsible for making sure

1024
00:35:32,880 --> 00:35:35,520
we we follow the rules in our treasury

1025
00:35:35,520 --> 00:35:38,560
and uh there are some other other roles

1026
00:35:38,560 --> 00:35:44,960
there as well excuse me while i play

1027
00:35:44,960 --> 00:35:45,839
with my uh

1028
00:35:45,839 --> 00:35:49,200
airpod here okay so um

1029
00:35:49,200 --> 00:35:50,880
if we wanted one of the things we can do

1030
00:35:50,880 --> 00:35:52,880
in our specification language

1031
00:35:52,880 --> 00:35:54,880
is ask whether something is published at

1032
00:35:54,880 --> 00:35:56,160
a particular address

1033
00:35:56,160 --> 00:35:57,520
so remember that i said that you can

1034
00:35:57,520 --> 00:35:59,920
have zero or one instances

1035
00:35:59,920 --> 00:36:03,040
of a uh struct published at a given

1036
00:36:03,040 --> 00:36:04,400
address and so we'd like to know if that

1037
00:36:04,400 --> 00:36:06,000
number is zero or one

1038
00:36:06,000 --> 00:36:09,200
so the construct in our language to do

1039
00:36:09,200 --> 00:36:09,520
that

1040
00:36:09,520 --> 00:36:12,560
is called exists and then it takes a

1041
00:36:12,560 --> 00:36:14,480
parameter for the type of thing that

1042
00:36:14,480 --> 00:36:15,760
might be published

1043
00:36:15,760 --> 00:36:17,520
and the address and this returns a

1044
00:36:17,520 --> 00:36:19,520
boolean value

1045
00:36:19,520 --> 00:36:21,680
exists here is not a quantifier this is

1046
00:36:21,680 --> 00:36:23,119
just whether something is published or

1047
00:36:23,119 --> 00:36:23,520
not

1048
00:36:23,520 --> 00:36:25,680
it's maybe suboptimal naming but that's

1049
00:36:25,680 --> 00:36:28,160
what we have

1050
00:36:28,160 --> 00:36:29,440
sometimes you would like to know what

1051
00:36:29,440 --> 00:36:31,440
values are actually there

1052
00:36:31,440 --> 00:36:33,200
and for that we have another construct

1053
00:36:33,200 --> 00:36:34,720
called global

1054
00:36:34,720 --> 00:36:37,040
which also takes a type parameter and an

1055
00:36:37,040 --> 00:36:37,760
address

1056
00:36:37,760 --> 00:36:39,440
so what it does is find the struct

1057
00:36:39,440 --> 00:36:41,119
that's published at that address

1058
00:36:41,119 --> 00:36:43,119
once you find the thing at that address

1059
00:36:43,119 --> 00:36:45,359
you can start accessing fields

1060
00:36:45,359 --> 00:36:48,000
and indexing into vectors and that sort

1061
00:36:48,000 --> 00:36:48,640
of thing

1062
00:36:48,640 --> 00:36:51,839
using the usual notation so in this case

1063
00:36:51,839 --> 00:36:55,440
i we are getting

1064
00:36:55,440 --> 00:36:57,760
the roll id struct that is published at

1065
00:36:57,760 --> 00:36:58,960
address two

1066
00:36:58,960 --> 00:37:01,520
and accessing the role id field which is

1067
00:37:01,520 --> 00:37:03,119
just an integer and then we could make

1068
00:37:03,119 --> 00:37:04,960
assertions about that like is it greater

1069
00:37:04,960 --> 00:37:09,839
than 15 or something like that

1070
00:37:10,800 --> 00:37:13,599
for specifications there's a classical

1071
00:37:13,599 --> 00:37:14,960
thing from

1072
00:37:14,960 --> 00:37:17,839
 logic called a post condition and

1073
00:37:17,839 --> 00:37:18,400
so

1074
00:37:18,400 --> 00:37:21,119
we have specifications for individual

1075
00:37:21,119 --> 00:37:22,560
procedures

1076
00:37:22,560 --> 00:37:25,280
and this is one of them so this is

1077
00:37:25,280 --> 00:37:26,720
something that is supposed to be true

1078
00:37:26,720 --> 00:37:28,960
after the procedure

1079
00:37:28,960 --> 00:37:30,400
in these things it's convenient to be

1080
00:37:30,400 --> 00:37:33,599
able to find out about

1081
00:37:33,599 --> 00:37:35,839
values of parameters or things that were

1082
00:37:35,839 --> 00:37:37,440
true just before the procedure was

1083
00:37:37,440 --> 00:37:39,359
called two and so so there are ways of

1084
00:37:39,359 --> 00:37:41,359
doing that

1085
00:37:41,359 --> 00:37:44,000
so all of our specifications are

1086
00:37:44,000 --> 00:37:45,760
enclosed in special blocks

1087
00:37:45,760 --> 00:37:47,599
so they're mixed in with a source code

1088
00:37:47,599 --> 00:37:49,440
but they're put in these blocks so we

1089
00:37:49,440 --> 00:37:50,079
can distinguish

1090
00:37:50,079 --> 00:37:53,520
them for the source code so here i have

1091
00:37:53,520 --> 00:37:55,599
a function called publish parent vasp

1092
00:37:55,599 --> 00:37:56,240
credential

1093
00:37:56,240 --> 00:37:58,320
vasp is a special type of account that

1094
00:37:58,320 --> 00:37:59,520
can hold money

1095
00:37:59,520 --> 00:38:01,359
it has several parameters one of which

1096
00:38:01,359 --> 00:38:03,359
is an address addr

1097
00:38:03,359 --> 00:38:05,680
so it's out it's it's a function that

1098
00:38:05,680 --> 00:38:06,880
causes

1099
00:38:06,880 --> 00:38:08,720
uh one of these credentials to be

1100
00:38:08,720 --> 00:38:10,960
published at a particular address

1101
00:38:10,960 --> 00:38:13,040
so i won't show the code but i'll show

1102
00:38:13,040 --> 00:38:15,280
the specification

1103
00:38:15,280 --> 00:38:17,040
um this is not exactly what's in our

1104
00:38:17,040 --> 00:38:18,800
system that's more elaborate but this is

1105
00:38:18,800 --> 00:38:20,400
a simplified version

1106
00:38:20,400 --> 00:38:22,160
so one of the post conditions is after

1107
00:38:22,160 --> 00:38:24,320
you publish a vast credential

1108
00:38:24,320 --> 00:38:27,440
there is now a vest is called parent

1109
00:38:27,440 --> 00:38:28,640
vasp is the type

1110
00:38:28,640 --> 00:38:32,160
for the vascular credential that exists

1111
00:38:32,160 --> 00:38:34,400
it is now published at the specified

1112
00:38:34,400 --> 00:38:35,200
address

1113
00:38:35,200 --> 00:38:36,800
so if this function is successful that

1114
00:38:36,800 --> 00:38:38,880
post condition will apply right after

1115
00:38:38,880 --> 00:38:40,480
the function returns or at the point of

1116
00:38:40,480 --> 00:38:41,680
return

1117
00:38:41,680 --> 00:38:45,599
and then when something is initially

1118
00:38:45,599 --> 00:38:47,119
published

1119
00:38:47,119 --> 00:38:49,440
then the number of children will be zero

1120
00:38:49,440 --> 00:38:51,599
so a parent vasp can have some child

1121
00:38:51,599 --> 00:38:52,880
basts underneath it

1122
00:38:52,880 --> 00:38:54,960
and but when it's when the parent vasp

1123
00:38:54,960 --> 00:38:58,400
is born it doesn't have children yet

1124
00:38:59,760 --> 00:39:03,200
another type of post condition is uh

1125
00:39:03,200 --> 00:39:06,240
called aborts if and

1126
00:39:06,240 --> 00:39:09,280
um boarding is uh kind of a different

1127
00:39:09,280 --> 00:39:10,480
thing in

1128
00:39:10,480 --> 00:39:12,880
blockchain programs smart contracts so

1129
00:39:12,880 --> 00:39:14,000
instead of runtime errors

1130
00:39:14,000 --> 00:39:17,040
or exceptions move programs abort and so

1131
00:39:17,040 --> 00:39:18,720
runtime error would typically be an

1132
00:39:18,720 --> 00:39:20,160
integer overflow but

1133
00:39:20,160 --> 00:39:23,040
the move program quits and backs out of

1134
00:39:23,040 --> 00:39:24,800
everything it's done so it goes back to

1135
00:39:24,800 --> 00:39:27,520
the previous state

1136
00:39:27,760 --> 00:39:31,440
so i just said that so uh programs are

1137
00:39:31,440 --> 00:39:32,480
supposed to abort

1138
00:39:32,480 --> 00:39:34,160
under some conditions so we like to be

1139
00:39:34,160 --> 00:39:36,480
able to specify this

1140
00:39:36,480 --> 00:39:38,800
so a verifier should not report an

1141
00:39:38,800 --> 00:39:41,119
expected abort as an error so if you

1142
00:39:41,119 --> 00:39:42,000
expect an abort to

1143
00:39:42,000 --> 00:39:43,440
happen when you code the thing up you

1144
00:39:43,440 --> 00:39:44,800
don't want the verifier telling you

1145
00:39:44,800 --> 00:39:45,760
that's a problem

1146
00:39:45,760 --> 00:39:49,040
because it's not um but an unexpected

1147
00:39:49,040 --> 00:39:51,119
abort is an error

1148
00:39:51,119 --> 00:39:53,520
also if you expect an abort to happen

1149
00:39:53,520 --> 00:39:54,640
and it does not occur

1150
00:39:54,640 --> 00:39:56,160
that is also an error that you want to

1151
00:39:56,160 --> 00:39:59,200
know about so the abortive specification

1152
00:39:59,200 --> 00:40:01,280
captures the programmers expectations

1153
00:40:01,280 --> 00:40:03,280
about aborting

1154
00:40:03,280 --> 00:40:06,720
here's an example so uh this is access

1155
00:40:06,720 --> 00:40:07,920
control

1156
00:40:07,920 --> 00:40:10,240
so apparent fast can only be created by

1157
00:40:10,240 --> 00:40:11,359
an account with a

1158
00:40:11,359 --> 00:40:13,760
treasury compliance role so we can

1159
00:40:13,760 --> 00:40:15,520
specify that in imports if

1160
00:40:15,520 --> 00:40:18,560
this is enforced by a boarding if the

1161
00:40:18,560 --> 00:40:20,480
uh creating account does not have this

1162
00:40:20,480 --> 00:40:22,319
treasury compliance enroll

1163
00:40:22,319 --> 00:40:25,599
so he says say it aborts if

1164
00:40:25,599 --> 00:40:27,760
we get the role id of the creator

1165
00:40:27,760 --> 00:40:29,520
address which is another argument to

1166
00:40:29,520 --> 00:40:31,520
create parent vasp account

1167
00:40:31,520 --> 00:40:33,520
and if that is not equal to a defined

1168
00:40:33,520 --> 00:40:35,359
constant which is treasury compliance

1169
00:40:35,359 --> 00:40:36,880
role id now i have to back

1170
00:40:36,880 --> 00:40:40,400
up okay treasury compliance role id

1171
00:40:40,400 --> 00:40:43,760
then we abort and we provide a

1172
00:40:43,760 --> 00:40:45,280
diagnostic to the

1173
00:40:45,280 --> 00:40:46,880
unfortunate person who sent that

1174
00:40:46,880 --> 00:40:48,480
transaction which says

1175
00:40:48,480 --> 00:40:50,720
that it requires a role a particular

1176
00:40:50,720 --> 00:40:52,640
role to execute and that requirement was

1177
00:40:52,640 --> 00:40:55,118
not met

1178
00:40:55,680 --> 00:40:57,520
so we we can specify these abort

1179
00:40:57,520 --> 00:40:59,040
conditions and

1180
00:40:59,040 --> 00:41:01,520
uh unless you turn the feature off it

1181
00:41:01,520 --> 00:41:03,200
will the approver will check

1182
00:41:03,200 --> 00:41:05,200
that your abort conditions are complete

1183
00:41:05,200 --> 00:41:08,560
you've covered every possibility

1184
00:41:08,960 --> 00:41:10,240
so those are what i call local

1185
00:41:10,240 --> 00:41:11,920
specifications they're associated with

1186
00:41:11,920 --> 00:41:12,720
individual

1187
00:41:12,720 --> 00:41:15,760
procedures global specifications

1188
00:41:15,760 --> 00:41:17,839
the global specifications are frequently

1189
00:41:17,839 --> 00:41:19,040
more important

1190
00:41:19,040 --> 00:41:20,880
and so those involve multiple functions

1191
00:41:20,880 --> 00:41:22,319
and they involve properties of the

1192
00:41:22,319 --> 00:41:24,880
global state

1193
00:41:24,880 --> 00:41:27,280
so they talk about change or lack of

1194
00:41:27,280 --> 00:41:28,319
change over time

1195
00:41:28,319 --> 00:41:30,000
so in a sense they're temporal

1196
00:41:30,000 --> 00:41:31,359
properties

1197
00:41:31,359 --> 00:41:32,720
so we have two kinds of global

1198
00:41:32,720 --> 00:41:34,720
properties we have global invariants

1199
00:41:34,720 --> 00:41:36,400
which are properties that are guaranteed

1200
00:41:36,400 --> 00:41:39,119
to be true for all time

1201
00:41:39,119 --> 00:41:41,119
and we have two stated variants which

1202
00:41:41,119 --> 00:41:42,800
are properties that compare the previous

1203
00:41:42,800 --> 00:41:44,160
and the current state

1204
00:41:44,160 --> 00:41:47,520
after a single instruction so here's an

1205
00:41:47,520 --> 00:41:49,359
example of a global invariant

1206
00:41:49,359 --> 00:41:51,200
we want to say that every address has a

1207
00:41:51,200 --> 00:41:53,119
d that that has a dm account

1208
00:41:53,119 --> 00:41:55,599
also has a role id the role ids are used

1209
00:41:55,599 --> 00:41:57,119
for access control so you should never

1210
00:41:57,119 --> 00:41:58,400
have a dm account that doesn't have a

1211
00:41:58,400 --> 00:42:00,240
role id

1212
00:42:00,240 --> 00:42:02,000
and so we can write that in our language

1213
00:42:02,000 --> 00:42:04,560
by saying spec module so that means this

1214
00:42:04,560 --> 00:42:06,160
applies for the entire module

1215
00:42:06,160 --> 00:42:09,040
all of the procedures in the code in in

1216
00:42:09,040 --> 00:42:10,160
the module

1217
00:42:10,160 --> 00:42:12,480
and we say it's a global invariant we

1218
00:42:12,480 --> 00:42:14,319
say here's a universal quantifier

1219
00:42:14,319 --> 00:42:17,520
so for every address if

1220
00:42:17,520 --> 00:42:19,599
there is a dm account published at that

1221
00:42:19,599 --> 00:42:21,680
address then there's a role id published

1222
00:42:21,680 --> 00:42:23,760
at that address also

1223
00:42:23,760 --> 00:42:26,800
so uh there are uh you know

1224
00:42:26,800 --> 00:42:29,200
effectively infinitely many addresses so

1225
00:42:29,200 --> 00:42:31,520
this is uh

1226
00:42:31,520 --> 00:42:33,599
this is something the prover can prove

1227
00:42:33,599 --> 00:42:35,280
because it sees how you've

1228
00:42:35,280 --> 00:42:37,359
changed the addresses if this invariant

1229
00:42:37,359 --> 00:42:38,319
is true

1230
00:42:38,319 --> 00:42:41,119
before an instruction is executed then

1231
00:42:41,119 --> 00:42:43,359
you're just

1232
00:42:43,359 --> 00:42:45,440
publishing a dm account at one place and

1233
00:42:45,440 --> 00:42:46,720
so it can check there that you have the

1234
00:42:46,720 --> 00:42:47,920
rule id already

1235
00:42:47,920 --> 00:42:49,920
when you publish that new dm account if

1236
00:42:49,920 --> 00:42:51,440
it was true for all addresses except the

1237
00:42:51,440 --> 00:42:52,560
one you just changed

1238
00:42:52,560 --> 00:42:53,839
then it will continue to be for all

1239
00:42:53,839 --> 00:42:56,799
addresses after that

1240
00:42:57,359 --> 00:42:58,720
here's an example of a two-state

1241
00:42:58,720 --> 00:43:01,599
invariant so they can refer to pre

1242
00:43:01,599 --> 00:43:03,680
and post states of a state change so the

1243
00:43:03,680 --> 00:43:06,560
state before and after an instruction

1244
00:43:06,560 --> 00:43:08,720
and so you can i'll give you an example

1245
00:43:08,720 --> 00:43:10,319
that i think is surprisingly expressive

1246
00:43:10,319 --> 00:43:12,640
for something so simple so we say once a

1247
00:43:12,640 --> 00:43:14,400
role id is stored in an address

1248
00:43:14,400 --> 00:43:17,520
it never changes so you

1249
00:43:17,520 --> 00:43:19,359
you define the role it stays the same

1250
00:43:19,359 --> 00:43:20,560
forever

1251
00:43:20,560 --> 00:43:22,000
so we write that as a two-state

1252
00:43:22,000 --> 00:43:24,480
invariant where we say for every address

1253
00:43:24,480 --> 00:43:27,839
if in the previous state there existed a

1254
00:43:27,839 --> 00:43:28,960
role id

1255
00:43:28,960 --> 00:43:32,560
at that address then in the next state

1256
00:43:32,560 --> 00:43:34,240
in the current state there will continue

1257
00:43:34,240 --> 00:43:36,319
to exist a role id there

1258
00:43:36,319 --> 00:43:38,720
furthermore the value of the role id

1259
00:43:38,720 --> 00:43:40,400
field of that role id

1260
00:43:40,400 --> 00:43:42,640
is going to be equal to the value in the

1261
00:43:42,640 --> 00:43:43,599
previous

1262
00:43:43,599 --> 00:43:45,599
state so it says it can't possibly

1263
00:43:45,599 --> 00:43:47,359
change once the thing is defined

1264
00:43:47,359 --> 00:43:49,680
it continues forever because this is

1265
00:43:49,680 --> 00:43:51,119
going to hold for

1266
00:43:51,119 --> 00:43:55,839
every state in the blockchain

1267
00:43:56,319 --> 00:43:59,440
um so i'd like to talk where i'm running

1268
00:43:59,440 --> 00:44:02,720
um i want to

1269
00:44:02,720 --> 00:44:04,160
wrap up pretty quickly so i'll talk

1270
00:44:04,160 --> 00:44:06,640
quickly about one novelty of what we're

1271
00:44:06,640 --> 00:44:09,599
doing which is how we handle memory

1272
00:44:09,599 --> 00:44:11,760
so one of the big problems in static

1273
00:44:11,760 --> 00:44:13,440
analysis and formal verification is

1274
00:44:13,440 --> 00:44:16,880
dealing with aliasing and memory

1275
00:44:16,880 --> 00:44:19,440
and the problem there is basically if

1276
00:44:19,440 --> 00:44:20,800
you have a bunch of pointers flying

1277
00:44:20,800 --> 00:44:22,160
around that could point to the same

1278
00:44:22,160 --> 00:44:23,520
memory location

1279
00:44:23,520 --> 00:44:25,280
you have to do your proof under

1280
00:44:25,280 --> 00:44:27,119
considering all the possibilities of

1281
00:44:27,119 --> 00:44:28,160
maybe these

1282
00:44:28,160 --> 00:44:30,319
two maybe two pointers point to the same

1283
00:44:30,319 --> 00:44:31,599
thing or maybe not

1284
00:44:31,599 --> 00:44:33,280
if you have a hundred pointers that's

1285
00:44:33,280 --> 00:44:34,880
that's a lot of pairs of pointers that

1286
00:44:34,880 --> 00:44:37,119
you have to reason about

1287
00:44:37,119 --> 00:44:39,920
and so this can result in a combination

1288
00:44:39,920 --> 00:44:41,920
combinatorial explosion of possible

1289
00:44:41,920 --> 00:44:44,560
aliasing relationships

1290
00:44:44,560 --> 00:44:47,200
and the typical approach which i've used

1291
00:44:47,200 --> 00:44:48,640
in previous systems

1292
00:44:48,640 --> 00:44:50,800
is to model memory as just a big array

1293
00:44:50,800 --> 00:44:52,079
and model pointers

1294
00:44:52,079 --> 00:44:54,560
as indices into that array and so you

1295
00:44:54,560 --> 00:44:55,680
get deeply nested

1296
00:44:55,680 --> 00:44:58,400
array store expressions every time you

1297
00:44:58,400 --> 00:44:58,960
update

1298
00:44:58,960 --> 00:45:01,119
an array you're building up a bigger and

1299
00:45:01,119 --> 00:45:02,079
bigger expression

1300
00:45:02,079 --> 00:45:04,800
and you can get massive trees of if then

1301
00:45:04,800 --> 00:45:06,560
else is covering all possibilities of

1302
00:45:06,560 --> 00:45:07,200
whether

1303
00:45:07,200 --> 00:45:09,839
pairs of things are equal or not and

1304
00:45:09,839 --> 00:45:10,640
that

1305
00:45:10,640 --> 00:45:13,760
causes computational burdens

1306
00:45:13,760 --> 00:45:16,160
so in move we can avoid aliasing because

1307
00:45:16,160 --> 00:45:18,000
of the restrictions in the language

1308
00:45:18,000 --> 00:45:19,839
memory is tree structured we have

1309
00:45:19,839 --> 00:45:21,520
records of records of records

1310
00:45:21,520 --> 00:45:23,440
we can't store memory references in

1311
00:45:23,440 --> 00:45:25,520
memory we can't have pointers to subtree

1312
00:45:25,520 --> 00:45:26,880
stored in memory

1313
00:45:26,880 --> 00:45:28,880
so those can only be stored on the stack

1314
00:45:28,880 --> 00:45:30,960
and so the actual state

1315
00:45:30,960 --> 00:45:34,000
is a tree not a

1316
00:45:34,000 --> 00:45:36,880
directed graph

1317
00:45:37,440 --> 00:45:40,560
and we also have this very strict static

1318
00:45:40,560 --> 00:45:42,319
analysis thing called the borrow checker

1319
00:45:42,319 --> 00:45:43,040
like it's

1320
00:45:43,040 --> 00:45:45,280
an extended type checker that strictly

1321
00:45:45,280 --> 00:45:47,359
forbids combinations of references that

1322
00:45:47,359 --> 00:45:49,040
result in aliens

1323
00:45:49,040 --> 00:45:50,800
in particular if you have a mutable

1324
00:45:50,800 --> 00:45:52,240
reference which allows you to change

1325
00:45:52,240 --> 00:45:52,880
something

1326
00:45:52,880 --> 00:45:54,880
there can't be any other references to

1327
00:45:54,880 --> 00:45:58,560
the same thing mutable or immutable

1328
00:45:58,640 --> 00:46:00,319
so this essentially means even though we

1329
00:46:00,319 --> 00:46:02,319
have these references

1330
00:46:02,319 --> 00:46:05,280
we can use copy semantics so this is

1331
00:46:05,280 --> 00:46:05,760
what it

1332
00:46:05,760 --> 00:46:07,920
looks like conceptually in the prover

1333
00:46:07,920 --> 00:46:08,960
suppose you have

1334
00:46:08,960 --> 00:46:11,680
a data structure it has a subtree that's

1335
00:46:11,680 --> 00:46:13,119
another data structure and you have

1336
00:46:13,119 --> 00:46:14,000
immutable reference

1337
00:46:14,000 --> 00:46:16,319
to that other data structure suppose you

1338
00:46:16,319 --> 00:46:17,839
have a function that takes that mutable

1339
00:46:17,839 --> 00:46:19,760
reference

1340
00:46:19,760 --> 00:46:21,440
then you can kind of ignore the rest of

1341
00:46:21,440 --> 00:46:23,440
the tree copy

1342
00:46:23,440 --> 00:46:25,119
imagine you have a copy and parameter

1343
00:46:25,119 --> 00:46:27,359
for the subtree t2

1344
00:46:27,359 --> 00:46:28,720
your function f can make whatever

1345
00:46:28,720 --> 00:46:30,400
changes it's going to make to produce a

1346
00:46:30,400 --> 00:46:31,760
modified tree

1347
00:46:31,760 --> 00:46:33,599
and then we can pretend that just gets

1348
00:46:33,599 --> 00:46:34,960
copied back

1349
00:46:34,960 --> 00:46:38,079
to the original t1 so that

1350
00:46:38,079 --> 00:46:40,480
simplifies our verification task let's

1351
00:46:40,480 --> 00:46:41,680
so

1352
00:46:41,680 --> 00:46:43,760
first of all that the reason we can get

1353
00:46:43,760 --> 00:46:45,200
away with this is that there's no way

1354
00:46:45,200 --> 00:46:46,480
you can write move code that can

1355
00:46:46,480 --> 00:46:48,240
distinguish this

1356
00:46:48,240 --> 00:46:50,160
way of doing things from just making the

1357
00:46:50,160 --> 00:46:51,680
modification in place

1358
00:46:51,680 --> 00:46:56,240
in t2 t1 okay and the advantage to us

1359
00:46:56,240 --> 00:46:58,240
is that it greatly simplifies the

1360
00:46:58,240 --> 00:47:01,200
verification task

1361
00:47:01,520 --> 00:47:03,680
so it eliminates this combinatorial

1362
00:47:03,680 --> 00:47:06,560
explosion of aliasing possibilities

1363
00:47:06,560 --> 00:47:08,400
and it greatly simplifies framing so

1364
00:47:08,400 --> 00:47:10,079
framing is is

1365
00:47:10,079 --> 00:47:11,680
you in addition to specifying what

1366
00:47:11,680 --> 00:47:13,119
changes when you call a function you

1367
00:47:13,119 --> 00:47:15,119
have to specify what doesn't change

1368
00:47:15,119 --> 00:47:16,400
and you don't want to write that

1369
00:47:16,400 --> 00:47:18,400
explicitly you want to be able to infer

1370
00:47:18,400 --> 00:47:18,960
it

1371
00:47:18,960 --> 00:47:21,040
and so because we know we're just copied

1372
00:47:21,040 --> 00:47:22,079
in a small

1373
00:47:22,079 --> 00:47:24,160
part of a tree or something that we know

1374
00:47:24,160 --> 00:47:26,000
nothing else changed it makes it easier

1375
00:47:26,000 --> 00:47:27,599
to infer what does not change

1376
00:47:27,599 --> 00:47:30,880
when a function is called and so

1377
00:47:30,880 --> 00:47:32,880
it basically gives us the convenience of

1378
00:47:32,880 --> 00:47:34,720
imperative programming

1379
00:47:34,720 --> 00:47:36,160
with some of the advantages of

1380
00:47:36,160 --> 00:47:38,960
functional programming

1381
00:47:38,960 --> 00:47:41,280
so i'll wrap up now i should mention

1382
00:47:41,280 --> 00:47:42,720
that there are similar projects and

1383
00:47:42,720 --> 00:47:44,160
they're good projects

1384
00:47:44,160 --> 00:47:46,160
and they um there are many efforts to

1385
00:47:46,160 --> 00:47:48,000
verify stuff on blockchains i'll talk

1386
00:47:48,000 --> 00:47:48,640
about

1387
00:47:48,640 --> 00:47:50,000
things that are most similar to what

1388
00:47:50,000 --> 00:47:52,400
we're doing so verifying smart contracts

1389
00:47:52,400 --> 00:47:53,920
on a blockchain

1390
00:47:53,920 --> 00:47:55,839
doing automatic verification based on

1391
00:47:55,839 --> 00:47:58,960
these logic solvers called smt solvers

1392
00:47:58,960 --> 00:48:01,680
and so one of them is verisol which has

1393
00:48:01,680 --> 00:48:04,079
been developed at microsoft research

1394
00:48:04,079 --> 00:48:07,280
another one is soul c verify at uh

1395
00:48:07,280 --> 00:48:10,079
sri international and the third one is

1396
00:48:10,079 --> 00:48:11,280
satora

1397
00:48:11,280 --> 00:48:13,040
which is a startup with proprietary

1398
00:48:13,040 --> 00:48:14,559
technology so

1399
00:48:14,559 --> 00:48:17,040
um but i believe it's pretty much the

1400
00:48:17,040 --> 00:48:17,599
same

1401
00:48:17,599 --> 00:48:20,079
general approach so the differences

1402
00:48:20,079 --> 00:48:21,599
between these and our system is that

1403
00:48:21,599 --> 00:48:22,880
they're based on the solidity

1404
00:48:22,880 --> 00:48:24,160
programming language

1405
00:48:24,160 --> 00:48:26,880
that runs in the ethereum blockchain so

1406
00:48:26,880 --> 00:48:28,319
the issues in solidity are very

1407
00:48:28,319 --> 00:48:30,079
different from the issues and move

1408
00:48:30,079 --> 00:48:32,240
and honestly we took solidity as an

1409
00:48:32,240 --> 00:48:34,079
example of things not to do

1410
00:48:34,079 --> 00:48:36,079
because it's very hard to verify and

1411
00:48:36,079 --> 00:48:37,839
there have been a lot of damaging bugs

1412
00:48:37,839 --> 00:48:41,520
in solidity code on ethereum

1413
00:48:42,160 --> 00:48:44,079
so basically we've got an easier job and

1414
00:48:44,079 --> 00:48:45,680
maybe we're able to do more because of

1415
00:48:45,680 --> 00:48:46,400
that

1416
00:48:46,400 --> 00:48:47,920
the current status of the project is

1417
00:48:47,920 --> 00:48:48,960
that we've written extensive

1418
00:48:48,960 --> 00:48:50,319
specifications

1419
00:48:50,319 --> 00:48:53,599
for um the code we expect to deploy as

1420
00:48:53,599 --> 00:48:55,119
part of the dm blockchain so that

1421
00:48:55,119 --> 00:48:56,880
includes the move standard library

1422
00:48:56,880 --> 00:48:58,480
and something called the dm framework

1423
00:48:58,480 --> 00:48:59,760
which is all the contracts that

1424
00:48:59,760 --> 00:49:02,240
basically do everything

1425
00:49:02,240 --> 00:49:04,079
so we specified and verified all the

1426
00:49:04,079 --> 00:49:05,760
access control requirements

1427
00:49:05,760 --> 00:49:07,599
which were separately documented in

1428
00:49:07,599 --> 00:49:08,960
something called dip2

1429
00:49:08,960 --> 00:49:10,880
and so this was a document to explain to

1430
00:49:10,880 --> 00:49:12,559
lawyers and other engineers

1431
00:49:12,559 --> 00:49:14,240
how our access control was going to work

1432
00:49:14,240 --> 00:49:15,359
and we could start with those

1433
00:49:15,359 --> 00:49:16,240
requirements

1434
00:49:16,240 --> 00:49:17,920
to just code them up in our language and

1435
00:49:17,920 --> 00:49:19,599
prove that all of them were true

1436
00:49:19,599 --> 00:49:23,520
we found some bugs doing that process

1437
00:49:23,760 --> 00:49:26,800
so we also specified and verified the

1438
00:49:26,800 --> 00:49:28,240
apis

1439
00:49:28,240 --> 00:49:30,319
of our transaction scripts so

1440
00:49:30,319 --> 00:49:32,480
particularly the abort conditions so

1441
00:49:32,480 --> 00:49:34,480
we found some places where the

1442
00:49:34,480 --> 00:49:36,079
documentation forgot to mention some

1443
00:49:36,079 --> 00:49:37,040
possible aborts

1444
00:49:37,040 --> 00:49:38,240
or mentioned aborts that couldn't

1445
00:49:38,240 --> 00:49:40,079
actually occur

1446
00:49:40,079 --> 00:49:41,920
and many many other properties various

1447
00:49:41,920 --> 00:49:43,200
things that programmers thought should

1448
00:49:43,200 --> 00:49:45,839
be true

1449
00:49:45,920 --> 00:49:47,520
all of our specifications verify

1450
00:49:47,520 --> 00:49:49,920
completely automatically at this time

1451
00:49:49,920 --> 00:49:54,000
and it's 30 seconds or less per module

1452
00:49:54,000 --> 00:49:56,000
formal verification is automatically run

1453
00:49:56,000 --> 00:49:57,680
during continuous integration whenever

1454
00:49:57,680 --> 00:49:59,280
we check in code

1455
00:49:59,280 --> 00:50:00,880
and if you're curious it's all out there

1456
00:50:00,880 --> 00:50:03,280
in this repository on github

1457
00:50:03,280 --> 00:50:05,040
in the language subdirectory that

1458
00:50:05,040 --> 00:50:06,480
includes all of the code for the

1459
00:50:06,480 --> 00:50:07,760
transaction scripts

1460
00:50:07,760 --> 00:50:13,359
our specifications and the prover tool

1461
00:50:13,359 --> 00:50:15,040
um we've got the approver out there

1462
00:50:15,040 --> 00:50:17,520
we're not supporting it for general use

1463
00:50:17,520 --> 00:50:19,359
because we're busy making sure we can

1464
00:50:19,359 --> 00:50:21,200
use it uh first

1465
00:50:21,200 --> 00:50:22,800
but maybe next year we'll be able to do

1466
00:50:22,800 --> 00:50:24,240
that

1467
00:50:24,240 --> 00:50:26,559
the system is rapidly evolving so that's

1468
00:50:26,559 --> 00:50:27,760
another reason we don't want to

1469
00:50:27,760 --> 00:50:28,640
encourage

1470
00:50:28,640 --> 00:50:32,960
people outside dm to use it

1471
00:50:33,040 --> 00:50:34,800
okay so the next challenge i think with

1472
00:50:34,800 --> 00:50:36,720
approver is to try to maximize the cos

1473
00:50:36,720 --> 00:50:39,359
the benefit while minimizing the cost so

1474
00:50:39,359 --> 00:50:41,119
we've proved that we can do it we've not

1475
00:50:41,119 --> 00:50:42,400
proved that

1476
00:50:42,400 --> 00:50:44,240
it's kind of worse work that is cost

1477
00:50:44,240 --> 00:50:46,240
effective to use it so we need to

1478
00:50:46,240 --> 00:50:48,160
make it more usable basically and make

1479
00:50:48,160 --> 00:50:50,240
users more productive

1480
00:50:50,240 --> 00:50:51,920
so we've got a lot of specifications

1481
00:50:51,920 --> 00:50:54,000
there that aren't going to detect

1482
00:50:54,000 --> 00:50:55,520
errors they just make the approver run

1483
00:50:55,520 --> 00:50:57,280
faster so we'd like to infer those

1484
00:50:57,280 --> 00:50:58,880
automatically

1485
00:50:58,880 --> 00:51:00,400
and we'd like to have better debugging

1486
00:51:00,400 --> 00:51:02,480
when people run into problems although

1487
00:51:02,480 --> 00:51:04,319
that situation has gotten a lot better

1488
00:51:04,319 --> 00:51:07,359
over the last few months

1489
00:51:07,599 --> 00:51:09,280
there's a research problem of inventing

1490
00:51:09,280 --> 00:51:10,800
tools to check for the correctness and

1491
00:51:10,800 --> 00:51:12,559
completeness of specifications

1492
00:51:12,559 --> 00:51:14,000
i think that's something that lots of

1493
00:51:14,000 --> 00:51:15,280
people could look at in lots of

1494
00:51:15,280 --> 00:51:16,960
different contexts

1495
00:51:16,960 --> 00:51:18,800
it's been a neglected research topic in

1496
00:51:18,800 --> 00:51:20,480
this field and there are many other

1497
00:51:20,480 --> 00:51:21,839
engineering improvements that we would

1498
00:51:21,839 --> 00:51:24,400
like to make

1499
00:51:24,400 --> 00:51:28,640
so at that point uh i can wrap up

1500
00:51:28,640 --> 00:51:32,319
so move programs smart contracts hit the

1501
00:51:32,319 --> 00:51:33,760
sweet spot for formal verification for

1502
00:51:33,760 --> 00:51:35,359
the reasons i cited earlier

1503
00:51:35,359 --> 00:51:37,599
impacts of bugs can be very bad so it's

1504
00:51:37,599 --> 00:51:39,680
worth doing move programs are relatively

1505
00:51:39,680 --> 00:51:41,280
simple so it's not as hard as it would

1506
00:51:41,280 --> 00:51:42,000
be with c

1507
00:51:42,000 --> 00:51:44,720
plus starting with clean slate makes the

1508
00:51:44,720 --> 00:51:46,559
problem easier than it would be

1509
00:51:46,559 --> 00:51:48,640
our approach is a highly automated floyd

1510
00:51:48,640 --> 00:51:50,079
horror verification

1511
00:51:50,079 --> 00:51:53,520
method and

1512
00:51:53,520 --> 00:51:55,280
move in the dm blockchain create some

1513
00:51:55,280 --> 00:51:57,839
unique issues and opportunities

1514
00:51:57,839 --> 00:52:00,079
so with that i'll wrap up and say thank

1515
00:52:00,079 --> 00:52:01,599
you i'm sorry i went

1516
00:52:01,599 --> 00:52:03,040
about five minutes longer than i

1517
00:52:03,040 --> 00:52:05,040
expected to but i hope we have some time

1518
00:52:05,040 --> 00:52:07,599
for questions

1519
00:52:07,680 --> 00:52:11,280
thank you david that was a very uh

1520
00:52:11,280 --> 00:52:14,640
clear presentation i think i don't see

1521
00:52:14,640 --> 00:52:17,599
oh there's a question are you still

1522
00:52:17,599 --> 00:52:18,079
using

1523
00:52:18,079 --> 00:52:21,680
rust yes so the system is written in

1524
00:52:21,680 --> 00:52:22,240
rust

1525
00:52:22,240 --> 00:52:25,359
now we're using uh boogie for which

1526
00:52:25,359 --> 00:52:27,680
we're using some external software so

1527
00:52:27,680 --> 00:52:30,559
big boogie is written in uh

1528
00:52:30,559 --> 00:52:34,319
net uh c-sharp or something and uh

1529
00:52:34,319 --> 00:52:36,480
the smt solvers are written in c-sharp

1530
00:52:36,480 --> 00:52:38,960
or c plus plus

1531
00:52:38,960 --> 00:52:42,240
but our code is written in rust

1532
00:52:43,520 --> 00:52:44,960
i don't see another question immediately

1533
00:52:44,960 --> 00:52:47,359
there but i'll ask one um

1534
00:52:47,359 --> 00:52:49,440
i i think one of the interesting

1535
00:52:49,440 --> 00:52:50,960
promises of

1536
00:52:50,960 --> 00:52:54,400
uh formal methods are generally for

1537
00:52:54,400 --> 00:52:55,760
better security

1538
00:52:55,760 --> 00:52:58,800
not simply blockchain and blockchain

1539
00:52:58,800 --> 00:53:00,800
really i think has more limited uses

1540
00:53:00,800 --> 00:53:02,240
that are being

1541
00:53:02,240 --> 00:53:06,160
advertised but how

1542
00:53:06,160 --> 00:53:08,720
how well does some of your lessons from

1543
00:53:08,720 --> 00:53:11,200
this generalize to other software

1544
00:53:11,200 --> 00:53:14,960
including process control uh real-time

1545
00:53:14,960 --> 00:53:16,000
secure

1546
00:53:16,000 --> 00:53:20,000
uh concerns and and otherwise

1547
00:53:20,960 --> 00:53:24,319
you know having done this uh except for

1548
00:53:24,319 --> 00:53:24,960
my

1549
00:53:24,960 --> 00:53:28,559
uh advancing age

1550
00:53:28,559 --> 00:53:30,480
it would be great to go back to to some

1551
00:53:30,480 --> 00:53:32,319
of those problems and apply what we've

1552
00:53:32,319 --> 00:53:32,960
learned

1553
00:53:32,960 --> 00:53:34,480
i'll tell you what i think is the major

1554
00:53:34,480 --> 00:53:36,240
barrier i mean there's been a lot of

1555
00:53:36,240 --> 00:53:37,839
work on formal verification of these

1556
00:53:37,839 --> 00:53:39,520
kinds of systems

1557
00:53:39,520 --> 00:53:41,440
and i really think you know i knew it

1558
00:53:41,440 --> 00:53:43,119
was going to be a benefit to be starting

1559
00:53:43,119 --> 00:53:45,599
with a clean slate but i i realized how

1560
00:53:45,599 --> 00:53:47,760
important it really was once we got into

1561
00:53:47,760 --> 00:53:48,880
the project

1562
00:53:48,880 --> 00:53:51,440
you know there is so much legacy code

1563
00:53:51,440 --> 00:53:53,599
and

1564
00:53:53,599 --> 00:53:56,400
working with people's programming

1565
00:53:56,400 --> 00:53:57,359
languages

1566
00:53:57,359 --> 00:54:01,359
development practices and

1567
00:54:01,520 --> 00:54:03,200
the existing systems that were not

1568
00:54:03,200 --> 00:54:05,200
designed for verification

1569
00:54:05,200 --> 00:54:09,040
is a huge problem so verification is

1570
00:54:09,040 --> 00:54:10,800
the hardest problem in this space a

1571
00:54:10,800 --> 00:54:13,200
formal verification

1572
00:54:13,200 --> 00:54:16,079
and so i think you need to optimize

1573
00:54:16,079 --> 00:54:17,119
everything else

1574
00:54:17,119 --> 00:54:18,720
if you want to have formally verified

1575
00:54:18,720 --> 00:54:20,720
systems you need to optimize everything

1576
00:54:20,720 --> 00:54:22,079
else to make the systems formally

1577
00:54:22,079 --> 00:54:23,280
verifiable

1578
00:54:23,280 --> 00:54:26,640
and so it's difficult to adapt

1579
00:54:26,640 --> 00:54:29,040
other people's tools that were not

1580
00:54:29,040 --> 00:54:31,200
designed with that in mind

1581
00:54:31,200 --> 00:54:33,200
to work so i think you can you can try

1582
00:54:33,200 --> 00:54:34,400
to evolve them

1583
00:54:34,400 --> 00:54:36,000
and people have done that particularly

1584
00:54:36,000 --> 00:54:37,200
you know i'm very familiar with the

1585
00:54:37,200 --> 00:54:38,000
hardware world

1586
00:54:38,000 --> 00:54:40,559
or at least the hardware world of over a

1587
00:54:40,559 --> 00:54:41,599
decade ago

1588
00:54:41,599 --> 00:54:43,760
and there the idea was to take languages

1589
00:54:43,760 --> 00:54:45,280
that were written for synthesis of

1590
00:54:45,280 --> 00:54:47,359
hardware and simulation of hardware

1591
00:54:47,359 --> 00:54:49,280
and defined subsets of them that could

1592
00:54:49,280 --> 00:54:51,119
be used for verification

1593
00:54:51,119 --> 00:54:53,599
so you can adapt existing languages but

1594
00:54:53,599 --> 00:54:55,359
there is a chicken and egg problem

1595
00:54:55,359 --> 00:54:57,040
right if people don't realize the value

1596
00:54:57,040 --> 00:54:58,400
of verification

1597
00:54:58,400 --> 00:55:00,720
or they haven't seen a demonstration

1598
00:55:00,720 --> 00:55:02,240
that it can actually work

1599
00:55:02,240 --> 00:55:04,240
then it's hard to get them to motivate

1600
00:55:04,240 --> 00:55:06,160
making the extensive changes that are

1601
00:55:06,160 --> 00:55:08,559
necessary to really support it

1602
00:55:08,559 --> 00:55:11,920
so uh i would say that the route to

1603
00:55:11,920 --> 00:55:14,000
formally verified control systems for

1604
00:55:14,000 --> 00:55:14,960
example

1605
00:55:14,960 --> 00:55:18,240
would involve a long iteration of people

1606
00:55:18,240 --> 00:55:20,000
trying to build verification systems

1607
00:55:20,000 --> 00:55:22,480
and then people modifying the languages

1608
00:55:22,480 --> 00:55:24,240
or making new languages

1609
00:55:24,240 --> 00:55:26,720
to be more verifiable so i think you

1610
00:55:26,720 --> 00:55:28,000
have to do what we're doing

1611
00:55:28,000 --> 00:55:30,240
which is co-designing the languages the

1612
00:55:30,240 --> 00:55:32,480
programming methodology

1613
00:55:32,480 --> 00:55:34,559
requirements methodology which i haven't

1614
00:55:34,559 --> 00:55:36,240
really talked about here but we've

1615
00:55:36,240 --> 00:55:38,400
kind of neglected and we're going to be

1616
00:55:38,400 --> 00:55:40,480
paying more attention to in the future

1617
00:55:40,480 --> 00:55:43,119
and the formal verification tools so

1618
00:55:43,119 --> 00:55:44,799
this is a really a grand challenge

1619
00:55:44,799 --> 00:55:47,599
problem and we should not underestimate

1620
00:55:47,599 --> 00:55:48,880
the difficulty of it

1621
00:55:48,880 --> 00:55:50,720
but i think it's needed to be able to

1622
00:55:50,720 --> 00:55:52,000
formally verify stuff

1623
00:55:52,000 --> 00:55:55,280
and i believe it's feasible at least

1624
00:55:55,280 --> 00:55:56,880
technically if we can

1625
00:55:56,880 --> 00:55:59,760
get all the planets aligned great thank

1626
00:55:59,760 --> 00:56:00,079
you

1627
00:56:00,079 --> 00:56:02,559
um we do have a question here what

1628
00:56:02,559 --> 00:56:06,480
guarantees the uniqueness of addresses

1629
00:56:07,599 --> 00:56:10,640
um in what sense so the addresses are

1630
00:56:10,640 --> 00:56:11,359
numbers

1631
00:56:11,359 --> 00:56:13,440
and different numbers are different but

1632
00:56:13,440 --> 00:56:14,720
that's a flippant

1633
00:56:14,720 --> 00:56:18,640
answer so um ah so so maybe it's

1634
00:56:18,640 --> 00:56:20,640
it you know the most important thing

1635
00:56:20,640 --> 00:56:22,160
published in an address

1636
00:56:22,160 --> 00:56:24,960
is an account so that's a struct so you

1637
00:56:24,960 --> 00:56:26,319
can't publish more than once

1638
00:56:26,319 --> 00:56:28,640
one account as an address if you try to

1639
00:56:28,640 --> 00:56:30,000
publish something at an address

1640
00:56:30,000 --> 00:56:31,200
and there's already something published

1641
00:56:31,200 --> 00:56:33,119
there of exactly the same type the

1642
00:56:33,119 --> 00:56:34,880
transaction aborts

1643
00:56:34,880 --> 00:56:37,440
and so what that guarantees that the

1644
00:56:37,440 --> 00:56:39,520
first creator of an account

1645
00:56:39,520 --> 00:56:43,599
owns the account and nobody else can

1646
00:56:43,599 --> 00:56:45,280
set another account there does that

1647
00:56:45,280 --> 00:56:47,920
answer the question

1648
00:56:49,680 --> 00:56:52,079
uh i'll need the question or to respond

1649
00:56:52,079 --> 00:56:53,839
to that maybe in the chat

1650
00:56:53,839 --> 00:56:57,200
did that respond yes thank you

1651
00:56:57,200 --> 00:57:01,280
okay and that exhausts both

1652
00:57:01,280 --> 00:57:04,240
the questions and the time we've set

1653
00:57:04,240 --> 00:57:05,359
aside

1654
00:57:05,359 --> 00:57:08,480
thank you so much for visiting us today

1655
00:57:08,480 --> 00:57:12,160
and uh providing the talk it's it's uh

1656
00:57:12,160 --> 00:57:14,640
refreshing to hear

1657
00:57:14,640 --> 00:57:17,040
um and hopefully we'll get you to visit

1658
00:57:17,040 --> 00:57:18,559
us in person at some time

1659
00:57:18,559 --> 00:57:20,079
yeah yeah i was gonna mention that so

1660
00:57:20,079 --> 00:57:22,319
thank you for inviting me here

1661
00:57:22,319 --> 00:57:24,079
you know it's efficient to do these

1662
00:57:24,079 --> 00:57:26,559
talks from my home office and whatever

1663
00:57:26,559 --> 00:57:29,760
but uh i've you know been invited to

1664
00:57:29,760 --> 00:57:30,799
give talks

1665
00:57:30,799 --> 00:57:32,559
to various universities when i was a

1666
00:57:32,559 --> 00:57:34,000
professor and whatever

1667
00:57:34,000 --> 00:57:36,559
and i always loved having those visits

1668
00:57:36,559 --> 00:57:37,520
where you could talk to other

1669
00:57:37,520 --> 00:57:38,319
researchers

1670
00:57:38,319 --> 00:57:40,000
you know just talk about my work of

1671
00:57:40,000 --> 00:57:41,520
course but find out what other people

1672
00:57:41,520 --> 00:57:42,319
are doing

1673
00:57:42,319 --> 00:57:44,079
find out how they run their departments

1674
00:57:44,079 --> 00:57:45,359
and uh

1675
00:57:45,359 --> 00:57:47,040
you know what's happening there and that

1676
00:57:47,040 --> 00:57:48,480
sort of thing so

1677
00:57:48,480 --> 00:57:51,520
uh exchange professional notes on on

1678
00:57:51,520 --> 00:57:53,119
everything so those kinds of visits are

1679
00:57:53,119 --> 00:57:54,640
really wonderful and it's

1680
00:57:54,640 --> 00:57:56,799
i'm hoping we can get done with covid so

1681
00:57:56,799 --> 00:57:59,359
we can restart that kind of activity

1682
00:57:59,359 --> 00:58:02,000
yeah i very much agreed with that so

1683
00:58:02,000 --> 00:58:02,880
thank you again

1684
00:58:02,880 --> 00:58:04,559
and we look forward to talking to you at

1685
00:58:04,559 --> 00:58:06,880
a future time for everybody who's

1686
00:58:06,880 --> 00:58:10,880
on the call we have another one of these

1687
00:58:10,880 --> 00:58:14,400
uh next wednesday

1688
00:58:14,400 --> 00:58:17,760
nissar minimum from nyu will be

1689
00:58:17,760 --> 00:58:21,599
our speaker and until then have

1690
00:58:21,599 --> 00:58:37,839
have a good week and stay safe

1691
00:58:38,480 --> 00:58:40,559
you

