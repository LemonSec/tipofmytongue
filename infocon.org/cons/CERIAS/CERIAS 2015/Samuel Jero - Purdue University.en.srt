1
00:00:30,210 --> 00:00:35,610
he's a PhD student currently with a

2
00:00:32,399 --> 00:00:37,379
professor me to retire and today is

3
00:00:35,610 --> 00:00:39,809
going to present some of his recent work

4
00:00:37,379 --> 00:00:42,690
on automated attack discovery in

5
00:00:39,809 --> 00:00:45,570
transport protocols and this paper just

6
00:00:42,690 --> 00:00:47,909
recently won the best paper award at DSN

7
00:00:45,570 --> 00:00:51,180
2015 which is a top cyber security

8
00:00:47,909 --> 00:00:54,239
conference so take it away Sam Thank You

9
00:00:51,180 --> 00:00:56,370
Brendan for that introduction so yeah my

10
00:00:54,239 --> 00:00:59,300
name is Samuel dro I'm a PhD student

11
00:00:56,370 --> 00:01:02,070
here today I'm talking about my work on

12
00:00:59,300 --> 00:01:04,349
automated a tech discovery and transport

13
00:01:02,070 --> 00:01:06,899
protocol implementations by leveraging

14
00:01:04,349 --> 00:01:08,610
the protocols state machine I should

15
00:01:06,899 --> 00:01:11,640
mention that this is joint work with

16
00:01:08,610 --> 00:01:17,940
hyung Lee who's now at Google and my

17
00:01:11,640 --> 00:01:20,670
adviser christina nerrit aru so yeah the

18
00:01:17,940 --> 00:01:22,979
motivation for this work is that network

19
00:01:20,670 --> 00:01:25,649
transport protocols form a crucial

20
00:01:22,979 --> 00:01:28,170
component of today's internet underlying

21
00:01:25,649 --> 00:01:31,500
a large majority of the applications

22
00:01:28,170 --> 00:01:34,759
that we use every day from web browsing

23
00:01:31,500 --> 00:01:37,950
to email instant messaging file transfer

24
00:01:34,759 --> 00:01:41,040
and many others additionally the

25
00:01:37,950 --> 00:01:43,619
security protocols like TLS that we use

26
00:01:41,040 --> 00:01:46,200
for secure communication also rely on

27
00:01:43,619 --> 00:01:48,930
these transport protocols and the

28
00:01:46,200 --> 00:01:50,549
guarantees they provide and even the

29
00:01:48,930 --> 00:01:52,740
network infrastructure protocols like

30
00:01:50,549 --> 00:01:55,049
BGP that keep the internet functioning

31
00:01:52,740 --> 00:01:58,229
correctly rely on these transport

32
00:01:55,049 --> 00:02:01,049
protocols this then leads to a second

33
00:01:58,229 --> 00:02:02,820
component or characteristic of these

34
00:02:01,049 --> 00:02:05,610
protocols which is that there are

35
00:02:02,820 --> 00:02:08,130
numerous implementations of them pretty

36
00:02:05,610 --> 00:02:10,470
much any network connected device you

37
00:02:08,130 --> 00:02:14,640
can imagine your traditional desktop

38
00:02:10,470 --> 00:02:16,880
devices running Windows OS X Linux your

39
00:02:14,640 --> 00:02:20,339
mobile devices running iOS and Android

40
00:02:16,880 --> 00:02:22,650
your servers BSD solaris even your

41
00:02:20,340 --> 00:02:25,230
hypervisors routers and the embedded

42
00:02:22,650 --> 00:02:27,540
devices you forgot you have all will

43
00:02:25,230 --> 00:02:30,780
have an implementation of some transport

44
00:02:27,540 --> 00:02:32,489
protocol on them however there is a

45
00:02:30,780 --> 00:02:35,489
third characteristic of these protocols

46
00:02:32,489 --> 00:02:38,699
that we want to look at today which is

47
00:02:35,489 --> 00:02:41,910
that they're incredibly bugging this

48
00:02:38,699 --> 00:02:43,740
figure shows the attacks recorded in the

49
00:02:41,910 --> 00:02:46,799
academic literature on

50
00:02:43,740 --> 00:02:49,530
single transport protocol tcp you'll

51
00:02:46,800 --> 00:02:51,420
notice that they span some 30 years of

52
00:02:49,530 --> 00:02:53,490
time and that there are a couple of

53
00:02:51,420 --> 00:02:56,640
these attacks that have been

54
00:02:53,490 --> 00:02:59,640
rediscovered 10 or 15 years after the

55
00:02:56,640 --> 00:03:03,149
fact as still being relevant to

56
00:02:59,640 --> 00:03:05,100
implementations at the time I'd also

57
00:03:03,150 --> 00:03:08,340
point out that these are only attacks in

58
00:03:05,100 --> 00:03:11,730
the academic literature if you look at

59
00:03:08,340 --> 00:03:14,370
the run-of-the-mill vulnerabilities

60
00:03:11,730 --> 00:03:16,590
reported in the implementations it gets

61
00:03:14,370 --> 00:03:19,530
mussed much worse these are

62
00:03:16,590 --> 00:03:21,210
vulnerabilities reported to the National

63
00:03:19,530 --> 00:03:23,220
vulnerability database for TCP

64
00:03:21,210 --> 00:03:27,420
implementations over just the last few

65
00:03:23,220 --> 00:03:32,370
years so this should of course beg the

66
00:03:27,420 --> 00:03:34,530
question why why after 30 ish years do

67
00:03:32,370 --> 00:03:38,670
we still have buggy TCP implementations

68
00:03:34,530 --> 00:03:40,650
why is it so hard to correctly implement

69
00:03:38,670 --> 00:03:44,280
these protocols and there are a number

70
00:03:40,650 --> 00:03:45,930
of reasons for that the first of these

71
00:03:44,280 --> 00:03:48,380
is that there are many designs and

72
00:03:45,930 --> 00:03:50,400
variations particularly for TCP and

73
00:03:48,380 --> 00:03:53,549
especially its congestion control

74
00:03:50,400 --> 00:03:55,470
algorithms there's just a number of

75
00:03:53,550 --> 00:03:57,900
different algorithms that have been

76
00:03:55,470 --> 00:04:00,990
proposed over the years in fact if you

77
00:03:57,900 --> 00:04:02,820
look at trying to implement TCP you'll

78
00:04:00,990 --> 00:04:05,490
find that there are over 20 rfcs that

79
00:04:02,820 --> 00:04:07,920
define components variations or features

80
00:04:05,490 --> 00:04:11,010
of the protocol and of course this is

81
00:04:07,920 --> 00:04:12,390
beside the hundreds of implementations

82
00:04:11,010 --> 00:04:16,048
of these protocols that I mentioned a

83
00:04:12,390 --> 00:04:17,669
moment ago additionally transport

84
00:04:16,048 --> 00:04:20,329
protocols are typically trying to solve

85
00:04:17,670 --> 00:04:22,590
fairly complex goals things like

86
00:04:20,329 --> 00:04:25,260
reliability which is going to require

87
00:04:22,590 --> 00:04:28,229
sequence numbers and acknowledgments as

88
00:04:25,260 --> 00:04:30,750
well as timeouts and retransmissions in

89
00:04:28,230 --> 00:04:32,520
order delivery congestion control which

90
00:04:30,750 --> 00:04:35,520
is a whole huge research area in its own

91
00:04:32,520 --> 00:04:40,169
right and a number of others that I'll

92
00:04:35,520 --> 00:04:41,969
mention in a few minutes further these

93
00:04:40,170 --> 00:04:44,610
implementations are typically written in

94
00:04:41,970 --> 00:04:47,250
low-level languages like C and as part

95
00:04:44,610 --> 00:04:48,900
of the operating systems meaning that

96
00:04:47,250 --> 00:04:51,750
they're highly efficient but fairly

97
00:04:48,900 --> 00:04:56,219
error-prone and then of course because

98
00:04:51,750 --> 00:05:00,070
most of us like to have the fastest

99
00:04:56,220 --> 00:05:02,410
most optimized networks these network

100
00:05:00,070 --> 00:05:06,010
protocol implementations are typically

101
00:05:02,410 --> 00:05:07,810
highly optimized for performance often

102
00:05:06,010 --> 00:05:10,120
in at the e at the cost of ease of

103
00:05:07,810 --> 00:05:15,010
understanding and maintenance further

104
00:05:10,120 --> 00:05:17,590
increasing the probability of bugs so at

105
00:05:15,010 --> 00:05:19,270
this point we should be asking well what

106
00:05:17,590 --> 00:05:20,979
are the current methods for testing

107
00:05:19,270 --> 00:05:23,440
these protocols how do we currently try

108
00:05:20,980 --> 00:05:26,020
to find bugs and vulnerabilities in

109
00:05:23,440 --> 00:05:27,900
these implementations and there are a

110
00:05:26,020 --> 00:05:30,820
number of different methods in use today

111
00:05:27,900 --> 00:05:33,789
the most common of these are developer

112
00:05:30,820 --> 00:05:36,040
test suites which are tests manually

113
00:05:33,790 --> 00:05:37,480
written by developers to make sure their

114
00:05:36,040 --> 00:05:41,290
implementations are functioning

115
00:05:37,480 --> 00:05:44,140
correctly unfortunately they tend to be

116
00:05:41,290 --> 00:05:45,850
fairly ad-hoc and focused on benign

117
00:05:44,140 --> 00:05:49,840
scenarios and basic protocol

118
00:05:45,850 --> 00:05:52,330
functionality another testing method is

119
00:05:49,840 --> 00:05:55,479
fuzzing which attempts to find crashes

120
00:05:52,330 --> 00:05:59,320
by subjecting implementations to random

121
00:05:55,480 --> 00:06:01,330
inputs unfortunately the use of

122
00:05:59,320 --> 00:06:02,820
randomness makes it very difficult to

123
00:06:01,330 --> 00:06:05,169
cover the entire protocol and

124
00:06:02,820 --> 00:06:06,849
particularly to reach deep protocol

125
00:06:05,170 --> 00:06:11,410
states that require multiple

126
00:06:06,850 --> 00:06:13,240
interactions with the protocol another

127
00:06:11,410 --> 00:06:15,970
testing method today is a tool called

128
00:06:13,240 --> 00:06:18,850
max which is designed to automatically

129
00:06:15,970 --> 00:06:22,930
find manipulation attacks by using

130
00:06:18,850 --> 00:06:25,330
symbolic execution unfortunately it

131
00:06:22,930 --> 00:06:27,670
requires the user to have access to the

132
00:06:25,330 --> 00:06:30,250
source code to have the source code

133
00:06:27,670 --> 00:06:32,470
written in C and to be able to select

134
00:06:30,250 --> 00:06:34,690
particular lines of code that may be

135
00:06:32,470 --> 00:06:37,030
vulnerable that max can then attempt to

136
00:06:34,690 --> 00:06:39,460
repeatedly execute to drive the

137
00:06:37,030 --> 00:06:40,690
execution toward those lines this

138
00:06:39,460 --> 00:06:43,150
severely limits the number of

139
00:06:40,690 --> 00:06:47,350
implementations to which max can be

140
00:06:43,150 --> 00:06:51,609
applied another testing method today is

141
00:06:47,350 --> 00:06:54,160
turret published in I cdcs 2014 which is

142
00:06:51,610 --> 00:06:56,980
designed to find performance attacks on

143
00:06:54,160 --> 00:07:01,350
distributed systems by using a greedy

144
00:06:56,980 --> 00:07:03,760
message based modification algorithm

145
00:07:01,350 --> 00:07:06,190
unfortunately this greedy search

146
00:07:03,760 --> 00:07:08,090
strategy does not work well for

147
00:07:06,190 --> 00:07:09,889
transport protocols

148
00:07:08,090 --> 00:07:11,750
and we'd really like to be able to find

149
00:07:09,889 --> 00:07:15,490
more than just performance attacks

150
00:07:11,750 --> 00:07:18,020
against these protocols things like

151
00:07:15,490 --> 00:07:21,770
resource exhaustion tax or fairness

152
00:07:18,020 --> 00:07:23,719
attacks things of that nature so we're

153
00:07:21,770 --> 00:07:26,299
left asking the question how do we

154
00:07:23,720 --> 00:07:28,090
automatically test unmodified

155
00:07:26,300 --> 00:07:32,060
implementations of transport protocols

156
00:07:28,090 --> 00:07:34,729
in a systematic manner and our answer to

157
00:07:32,060 --> 00:07:37,520
that question is snake for a state-based

158
00:07:34,729 --> 00:07:39,760
network attack Explorer which is able to

159
00:07:37,520 --> 00:07:42,919
test unmodified protocol implementations

160
00:07:39,760 --> 00:07:45,530
using message based attacks and defined

161
00:07:42,919 --> 00:07:49,010
performance resource exhaustion and

162
00:07:45,530 --> 00:07:50,539
fairness attacks we leverage the

163
00:07:49,010 --> 00:07:52,430
protocols state machine to enable

164
00:07:50,540 --> 00:07:55,340
efficient and systematic testing and

165
00:07:52,430 --> 00:07:58,220
we're ultimately able to find five new

166
00:07:55,340 --> 00:08:00,679
and four known attacks in five protocol

167
00:07:58,220 --> 00:08:04,760
implementations of two protocols in four

168
00:08:00,680 --> 00:08:06,470
different operating systems so at this

169
00:08:04,760 --> 00:08:09,139
point I spent a few minutes giving you

170
00:08:06,470 --> 00:08:11,510
some background into our motivation for

171
00:08:09,139 --> 00:08:13,400
this work we're now going to look at

172
00:08:11,510 --> 00:08:15,919
transport protocols in a little bit more

173
00:08:13,400 --> 00:08:17,989
detail before diving into the design and

174
00:08:15,919 --> 00:08:20,359
implementation of our system some

175
00:08:17,990 --> 00:08:23,150
evaluation and results and then a brief

176
00:08:20,360 --> 00:08:24,830
summary by the way I should mention if

177
00:08:23,150 --> 00:08:29,840
there are questions feel free to

178
00:08:24,830 --> 00:08:33,559
interrupt me at any point in time so

179
00:08:29,840 --> 00:08:35,000
transport protocols we talked a little

180
00:08:33,559 --> 00:08:38,598
bit about transport protocols already

181
00:08:35,000 --> 00:08:39,940
we've said that they are heavily

182
00:08:38,599 --> 00:08:42,800
utilized on the Internet today that

183
00:08:39,940 --> 00:08:45,170
there are numerous implementations of

184
00:08:42,799 --> 00:08:46,729
them and we've looked at a few of the

185
00:08:45,170 --> 00:08:49,490
complexities involved in their

186
00:08:46,730 --> 00:08:51,770
implementation however more formally

187
00:08:49,490 --> 00:08:54,230
transport protocols are responsible for

188
00:08:51,770 --> 00:08:57,829
end-to-end communication in the network

189
00:08:54,230 --> 00:09:00,110
that is for moving data from an

190
00:08:57,830 --> 00:09:03,740
application and host a to an application

191
00:09:00,110 --> 00:09:06,430
and host be they also typically provide

192
00:09:03,740 --> 00:09:09,620
a number of guarantees to applications

193
00:09:06,430 --> 00:09:11,359
things like reliability which in stores

194
00:09:09,620 --> 00:09:14,000
that data will eventually the data that

195
00:09:11,360 --> 00:09:16,400
is sent will eventually be received even

196
00:09:14,000 --> 00:09:19,070
if it was dropped in the network and

197
00:09:16,400 --> 00:09:22,000
needs to be retransmitted this requires

198
00:09:19,070 --> 00:09:24,040
sequence numbers acknowledgments as well

199
00:09:22,000 --> 00:09:26,890
time outs of retransmissions and we'll

200
00:09:24,040 --> 00:09:31,569
talk about one method for doing that in

201
00:09:26,890 --> 00:09:33,580
a few minutes closely related to

202
00:09:31,570 --> 00:09:36,370
reliability is the idea in order

203
00:09:33,580 --> 00:09:38,350
delivery which ensures that data that is

204
00:09:36,370 --> 00:09:40,540
sent will eventually be received in the

205
00:09:38,350 --> 00:09:43,300
same order that it was sent even if the

206
00:09:40,540 --> 00:09:46,449
network reorders the data in the

207
00:09:43,300 --> 00:09:50,709
meantime another common guarantee is

208
00:09:46,450 --> 00:09:52,990
flow control which is designed to

209
00:09:50,710 --> 00:09:55,540
prevent the sender from over running the

210
00:09:52,990 --> 00:09:58,150
receiver and is typically implemented by

211
00:09:55,540 --> 00:10:00,310
specifying a window of data that the

212
00:09:58,150 --> 00:10:02,620
sender is able to or that the receiver

213
00:10:00,310 --> 00:10:05,880
is able to receive and preventing the

214
00:10:02,620 --> 00:10:09,880
sender from over running that window

215
00:10:05,880 --> 00:10:12,280
then there's congestion control which is

216
00:10:09,880 --> 00:10:14,560
designed to prevent congestion collapse

217
00:10:12,280 --> 00:10:17,170
in the network where the network becomes

218
00:10:14,560 --> 00:10:18,790
so overloaded it spends all of its time

219
00:10:17,170 --> 00:10:21,120
sending data that's going to eventually

220
00:10:18,790 --> 00:10:24,180
be dropped resulting in catastrophic

221
00:10:21,120 --> 00:10:27,970
drop and application level performance

222
00:10:24,180 --> 00:10:30,130
and I should point out that there are

223
00:10:27,970 --> 00:10:33,100
more than 13 RFC's the deal with

224
00:10:30,130 --> 00:10:35,620
congestion control for TCP alone this is

225
00:10:33,100 --> 00:10:37,720
a very complex research area will look

226
00:10:35,620 --> 00:10:40,780
in a little bit more detail in a moment

227
00:10:37,720 --> 00:10:43,330
or two closely related to congestion

228
00:10:40,780 --> 00:10:45,550
control is fairness which is the idea

229
00:10:43,330 --> 00:10:47,710
that if you have two flows competing for

230
00:10:45,550 --> 00:10:49,240
bandwidth on a bottleneck link they

231
00:10:47,710 --> 00:10:53,200
should share that bandwidth roughly

232
00:10:49,240 --> 00:10:56,470
equally in order to provide these

233
00:10:53,200 --> 00:10:58,570
guarantees these protocols need to be

234
00:10:56,470 --> 00:10:59,920
able to maintain state which means

235
00:10:58,570 --> 00:11:03,130
they're going to need to be connection

236
00:10:59,920 --> 00:11:04,630
oriented and this means that the data

237
00:11:03,130 --> 00:11:07,630
transfer is broken down into three

238
00:11:04,630 --> 00:11:12,160
phases first a connection establishment

239
00:11:07,630 --> 00:11:16,689
phase with the two sides synchronize

240
00:11:12,160 --> 00:11:18,430
their state and then a data transfer

241
00:11:16,690 --> 00:11:20,620
phase where the actual data is

242
00:11:18,430 --> 00:11:22,870
transferred and finally a connection

243
00:11:20,620 --> 00:11:24,730
teardown phase where the two sides agree

244
00:11:22,870 --> 00:11:29,200
they're done sending data and release

245
00:11:24,730 --> 00:11:31,300
this any state they set up to help make

246
00:11:29,200 --> 00:11:35,329
this a little bit more concrete we're

247
00:11:31,300 --> 00:11:37,128
going to look at the look at TCP or the

248
00:11:35,329 --> 00:11:40,969
mission control protocol in a little bit

249
00:11:37,129 --> 00:11:42,290
more detail this is the most common

250
00:11:40,970 --> 00:11:46,670
transport protocol and use on the

251
00:11:42,290 --> 00:11:49,309
internet today you'll notice in this

252
00:11:46,670 --> 00:11:50,868
diagram that we have that I've

253
00:11:49,309 --> 00:11:54,040
highlighted each of the different stages

254
00:11:50,869 --> 00:11:56,209
of the protocol that I mentioned before

255
00:11:54,040 --> 00:11:58,309
so we start with the connection

256
00:11:56,209 --> 00:12:00,729
establishment phase with the client

257
00:11:58,309 --> 00:12:04,189
sending a syn packet to the server

258
00:12:00,730 --> 00:12:07,730
containing option containing connection

259
00:12:04,189 --> 00:12:09,819
options and its sequence number the

260
00:12:07,730 --> 00:12:13,100
server responds with a syn ACK packet

261
00:12:09,819 --> 00:12:15,170
and its various options and sequence

262
00:12:13,100 --> 00:12:17,420
number which the client then

263
00:12:15,170 --> 00:12:19,849
acknowledges at this point the

264
00:12:17,420 --> 00:12:21,649
connection is established both sides

265
00:12:19,850 --> 00:12:24,410
have exchanged sequence numbers and

266
00:12:21,649 --> 00:12:28,730
created any shared state necessary for

267
00:12:24,410 --> 00:12:32,439
the connection the client is then able

268
00:12:28,730 --> 00:12:34,939
can then begin to send its data any

269
00:12:32,439 --> 00:12:38,029
packet in the data transfer phase has

270
00:12:34,939 --> 00:12:42,079
the act flag set so you'll notice that

271
00:12:38,029 --> 00:12:45,049
all of these packets have ack however

272
00:12:42,079 --> 00:12:46,669
some of these packets contain data and

273
00:12:45,049 --> 00:12:49,669
some of them are just pure

274
00:12:46,669 --> 00:12:51,980
acknowledgments without any data so what

275
00:12:49,669 --> 00:12:54,949
we see here is we see the client sending

276
00:12:51,980 --> 00:12:56,269
two packets of data to the server the

277
00:12:54,949 --> 00:12:57,799
server responds with a PR

278
00:12:56,269 --> 00:12:59,829
acknowledgement saying yes I got that

279
00:12:57,799 --> 00:13:02,480
data you don't need to retransmit it and

280
00:12:59,829 --> 00:13:04,160
then in this particular example the

281
00:13:02,480 --> 00:13:06,350
server sends two packets of data to the

282
00:13:04,160 --> 00:13:09,618
client which the client acknowledges and

283
00:13:06,350 --> 00:13:12,589
says yes I got that at this point the

284
00:13:09,619 --> 00:13:15,499
data transfer phase is done the client

285
00:13:12,589 --> 00:13:18,350
can initiate connection termination by

286
00:13:15,499 --> 00:13:20,689
sending a fin packet saying that it's

287
00:13:18,350 --> 00:13:22,610
done sending data the server

288
00:13:20,689 --> 00:13:25,459
acknowledges that with the finak packet

289
00:13:22,610 --> 00:13:28,189
and the client finishes the process by

290
00:13:25,459 --> 00:13:30,529
acknowledging that at at this point the

291
00:13:28,189 --> 00:13:35,480
connection is complete all the state can

292
00:13:30,529 --> 00:13:38,119
be released will now look at a couple of

293
00:13:35,480 --> 00:13:40,549
the guarantees that TCP provides in a

294
00:13:38,119 --> 00:13:43,459
little bit more detail the first of

295
00:13:40,549 --> 00:13:48,040
these is reliability which we've talked

296
00:13:43,459 --> 00:13:51,709
about already provides the

297
00:13:48,040 --> 00:13:53,150
it allows the sender or it ensures the

298
00:13:51,710 --> 00:13:56,450
data that sent will eventually be

299
00:13:53,150 --> 00:13:58,040
received and requires sequence numbers

300
00:13:56,450 --> 00:14:00,890
acknowledgments timeout and

301
00:13:58,040 --> 00:14:04,010
retransmissions so the way this works is

302
00:14:00,890 --> 00:14:05,630
that tcp conceptually labels each byte

303
00:14:04,010 --> 00:14:08,450
of data to be sent with a sequence

304
00:14:05,630 --> 00:14:10,939
number and then each packet contains the

305
00:14:08,450 --> 00:14:14,300
sequence number of the first byte of

306
00:14:10,940 --> 00:14:16,510
data in that packet and most packets

307
00:14:14,300 --> 00:14:19,520
containing acknowledge number

308
00:14:16,510 --> 00:14:22,400
acknowledge or indicating the next byte

309
00:14:19,520 --> 00:14:24,800
of data that is expected so all data

310
00:14:22,400 --> 00:14:27,400
prior to that point has is has been

311
00:14:24,800 --> 00:14:31,550
received correctly and is acknowledged

312
00:14:27,400 --> 00:14:34,310
whenever a packet is sent than TCP

313
00:14:31,550 --> 00:14:36,109
starts a timer and if that data is

314
00:14:34,310 --> 00:14:39,260
successfully acknowledged the timer can

315
00:14:36,110 --> 00:14:41,180
be stopped if the timer ever expires it

316
00:14:39,260 --> 00:14:42,950
means we didn't getting not an

317
00:14:41,180 --> 00:14:45,469
acknowledgement in time and we can

318
00:14:42,950 --> 00:14:48,290
retransmit the data there's an example

319
00:14:45,470 --> 00:14:53,060
here on the right that help that may

320
00:14:48,290 --> 00:14:55,130
help to illustrate this another

321
00:14:53,060 --> 00:14:58,910
guarantee that TCC provides that we'll

322
00:14:55,130 --> 00:15:00,830
look at is congestion control we've said

323
00:14:58,910 --> 00:15:06,020
that congestion control is designed to

324
00:15:00,830 --> 00:15:08,510
avoid a heavily overloaded network that

325
00:15:06,020 --> 00:15:12,680
results in drops in application level

326
00:15:08,510 --> 00:15:15,140
throughput tcp assumes that packet

327
00:15:12,680 --> 00:15:18,620
losses indicate congestion which means

328
00:15:15,140 --> 00:15:22,699
that too it should slow down as a result

329
00:15:18,620 --> 00:15:24,820
of that the particular scheme that TCP

330
00:15:22,700 --> 00:15:27,589
uses is called additive increase

331
00:15:24,820 --> 00:15:30,680
multiplicative decrease which means that

332
00:15:27,589 --> 00:15:33,320
in normal operation TCP will slowly

333
00:15:30,680 --> 00:15:36,829
increase its sending rate one packet per

334
00:15:33,320 --> 00:15:38,870
round trip and on a packet loss

335
00:15:36,830 --> 00:15:40,839
indicating congestion it will

336
00:15:38,870 --> 00:15:44,660
exponentially decrease its sending rate

337
00:15:40,839 --> 00:15:46,670
by cutting it in half resulting in a

338
00:15:44,660 --> 00:15:51,500
sawtooth pattern like you see on this

339
00:15:46,670 --> 00:15:53,779
slide okay so now we've looked at

340
00:15:51,500 --> 00:15:57,530
transport protocols in a little bit more

341
00:15:53,779 --> 00:15:59,600
detail we've looked at TCP in particular

342
00:15:57,530 --> 00:16:01,250
and as an example of these protocols and

343
00:15:59,600 --> 00:16:04,790
some of the complexities

344
00:16:01,250 --> 00:16:07,790
involved in their implementation now we

345
00:16:04,790 --> 00:16:13,219
want to look at security and tcp and why

346
00:16:07,790 --> 00:16:15,170
we why we care basically so it turns out

347
00:16:13,220 --> 00:16:18,080
that the majority of internet traffic

348
00:16:15,170 --> 00:16:21,589
relies on TCP which means that any

349
00:16:18,080 --> 00:16:24,140
attacks on this protocol will affect a

350
00:16:21,590 --> 00:16:27,470
massive number of services and huge

351
00:16:24,140 --> 00:16:31,189
quantities of traffic so web brought web

352
00:16:27,470 --> 00:16:35,360
servers email servers instant message

353
00:16:31,190 --> 00:16:41,230
clients file transfer SSH would all be

354
00:16:35,360 --> 00:16:43,610
impacted by attacks against TCP further

355
00:16:41,230 --> 00:16:46,040
the majority of network connected

356
00:16:43,610 --> 00:16:48,590
devices have an implementation of TCP as

357
00:16:46,040 --> 00:16:51,170
the most popular transport protocol on

358
00:16:48,590 --> 00:16:54,520
the internet which means that things

359
00:16:51,170 --> 00:16:57,439
like rarely updated embedded devices are

360
00:16:54,520 --> 00:17:00,410
almost almost certainly listening on at

361
00:16:57,440 --> 00:17:03,080
least some TCP port if you can exploit

362
00:17:00,410 --> 00:17:06,069
said TCP implementation you get access

363
00:17:03,080 --> 00:17:08,720
to said rarely updated embedded device

364
00:17:06,069 --> 00:17:10,459
similarly high value servers and core

365
00:17:08,720 --> 00:17:12,890
internet routers also have

366
00:17:10,459 --> 00:17:18,829
implementations of TCP meaning that

367
00:17:12,890 --> 00:17:21,170
exploits can be very powerful further

368
00:17:18,829 --> 00:17:25,520
the secure communication protocols like

369
00:17:21,170 --> 00:17:28,700
TLS and ssh rely on tcp and it turns out

370
00:17:25,520 --> 00:17:31,820
that in some instances breaking tcp can

371
00:17:28,700 --> 00:17:34,760
break these protocols particular example

372
00:17:31,820 --> 00:17:36,590
that is the TLS truncation attack which

373
00:17:34,760 --> 00:17:39,910
I've Illustrated at the bottom of the

374
00:17:36,590 --> 00:17:43,459
slide the idea here is that you have a

375
00:17:39,910 --> 00:17:47,330
secure connection to a web server with

376
00:17:43,460 --> 00:17:50,060
standard TLS plus tcp running on top of

377
00:17:47,330 --> 00:17:53,270
TCP and then you go to try to log out of

378
00:17:50,060 --> 00:17:55,460
this website unfortunately there's an

379
00:17:53,270 --> 00:17:57,860
attacker in the middle that sends a tcp

380
00:17:55,460 --> 00:18:00,140
reset packet terminates the tcp

381
00:17:57,860 --> 00:18:02,149
connection by implication the TLS

382
00:18:00,140 --> 00:18:05,960
connection that's running on top of TCP

383
00:18:02,150 --> 00:18:07,970
and it appears to the client as if

384
00:18:05,960 --> 00:18:10,730
they're successfully logged out when in

385
00:18:07,970 --> 00:18:14,420
fact their credentials are still valid

386
00:18:10,730 --> 00:18:14,990
if this client is say a shared public

387
00:18:14,420 --> 00:18:22,420
computer

388
00:18:14,990 --> 00:18:25,400
this can have major consequences okay so

389
00:18:22,420 --> 00:18:28,730
we're now going to take a look at one

390
00:18:25,400 --> 00:18:31,460
attack against TCP to help clarify what

391
00:18:28,730 --> 00:18:33,860
these attacks can look like this is the

392
00:18:31,460 --> 00:18:36,110
TCP close wait resource exhaustion

393
00:18:33,860 --> 00:18:39,678
attack it is an actual attack against

394
00:18:36,110 --> 00:18:43,389
TCP that we found using snake and that

395
00:18:39,679 --> 00:18:46,370
was previously unknown in the literature

396
00:18:43,390 --> 00:18:48,520
this attack allows a client to force a

397
00:18:46,370 --> 00:18:52,879
server to keep socket state around for

398
00:18:48,520 --> 00:18:56,420
13 or 30 minutes tying valuable memory

399
00:18:52,880 --> 00:19:00,410
and socket resources the way the attack

400
00:18:56,420 --> 00:19:02,600
works is that a client connects to some

401
00:19:00,410 --> 00:19:05,870
server requests a large data transfer I

402
00:19:02,600 --> 00:19:08,840
think an HTTP file download then the

403
00:19:05,870 --> 00:19:11,059
client application exits and the clients

404
00:19:08,840 --> 00:19:13,699
TCP implementation is supposed to

405
00:19:11,059 --> 00:19:15,950
respond to all future data from the

406
00:19:13,700 --> 00:19:18,950
server with reset packets as specified

407
00:19:15,950 --> 00:19:22,059
by the TCP specification if however

408
00:19:18,950 --> 00:19:24,880
those recent packets are dropped

409
00:19:22,059 --> 00:19:27,800
invalidated or simply not sent at all

410
00:19:24,880 --> 00:19:29,540
then to the server it will appear as

411
00:19:27,800 --> 00:19:33,230
though an entire window of data has been

412
00:19:29,540 --> 00:19:35,928
lost and the server will back off and

413
00:19:33,230 --> 00:19:40,280
temp to retransmit which will of course

414
00:19:35,929 --> 00:19:42,650
never succeed the Linux implementation

415
00:19:40,280 --> 00:19:45,170
of TCP will continue this process for

416
00:19:42,650 --> 00:19:48,650
between 13 and 30 minutes depending on

417
00:19:45,170 --> 00:19:54,320
the round-trip time before finally

418
00:19:48,650 --> 00:19:57,080
giving up in unclean ly terminating the

419
00:19:54,320 --> 00:19:59,240
connection and releasing resources this

420
00:19:57,080 --> 00:20:01,428
13 2 30 minutes gives an attacker plenty

421
00:19:59,240 --> 00:20:04,160
of time to repeat this attack hundreds

422
00:20:01,429 --> 00:20:07,929
or thousands of times using up all

423
00:20:04,160 --> 00:20:10,250
available system resources and

424
00:20:07,929 --> 00:20:12,350
potentially taking down the server or at

425
00:20:10,250 --> 00:20:17,000
very least denying access to legitimate

426
00:20:12,350 --> 00:20:19,669
clients ok so we've now looked at

427
00:20:17,000 --> 00:20:22,490
transfer protocols we've looked at TCP

428
00:20:19,670 --> 00:20:25,340
in detail we've looked at an example

429
00:20:22,490 --> 00:20:26,780
attack on this protocol so now we want

430
00:20:25,340 --> 00:20:28,490
to step back a moment and think about

431
00:20:26,780 --> 00:20:30,770
the general types

432
00:20:28,490 --> 00:20:33,830
of attackers that might be interested in

433
00:20:30,770 --> 00:20:36,429
attacking transfer protocols we consider

434
00:20:33,830 --> 00:20:40,399
two types of attackers in this work

435
00:20:36,429 --> 00:20:42,170
first malicious clients which our

436
00:20:40,400 --> 00:20:45,530
attacker is that a tech attempt to

437
00:20:42,170 --> 00:20:49,010
connect to some target server either to

438
00:20:45,530 --> 00:20:50,960
attempt to exhaust its resources or to

439
00:20:49,010 --> 00:20:52,820
gain more than their fair share of

440
00:20:50,960 --> 00:20:54,620
network bandwidth relative to some

441
00:20:52,820 --> 00:20:57,770
competing connection some form of

442
00:20:54,620 --> 00:20:59,780
fairness attack the TCP close wait

443
00:20:57,770 --> 00:21:02,960
resource a Gaussian attack I just

444
00:20:59,780 --> 00:21:06,350
mentioned falls into this category the

445
00:21:02,960 --> 00:21:09,140
other category of attacks is by off path

446
00:21:06,350 --> 00:21:11,059
attackers and these are attacks where

447
00:21:09,140 --> 00:21:13,190
the attacker attempts to inject data

448
00:21:11,059 --> 00:21:15,889
into some target connection between a

449
00:21:13,190 --> 00:21:18,559
client and a server either to prevent

450
00:21:15,890 --> 00:21:20,120
that connection entirely or to degrade

451
00:21:18,559 --> 00:21:26,300
its throughput and therefore its

452
00:21:20,120 --> 00:21:29,270
usefulness ok so the question we now

453
00:21:26,300 --> 00:21:31,639
want to consider is how do I go about

454
00:21:29,270 --> 00:21:36,020
finding these type of attacks in an

455
00:21:31,640 --> 00:21:38,740
automated manner the solution to that is

456
00:21:36,020 --> 00:21:42,500
some form of attack injection scheme

457
00:21:38,740 --> 00:21:45,320
that is we want to identify points where

458
00:21:42,500 --> 00:21:48,080
we can insert some form of message based

459
00:21:45,320 --> 00:21:49,760
attacks into our test scenario to

460
00:21:48,080 --> 00:21:54,260
attempt to find attacks on these

461
00:21:49,760 --> 00:21:56,450
protocols note that the intact injection

462
00:21:54,260 --> 00:21:58,879
scheme that we pick will impact both the

463
00:21:56,450 --> 00:22:02,900
practicality and effectiveness of our

464
00:21:58,880 --> 00:22:05,090
testing practicality because systematic

465
00:22:02,900 --> 00:22:06,860
exhaustive testing is going to need to

466
00:22:05,090 --> 00:22:08,649
test all of these attack injection

467
00:22:06,860 --> 00:22:12,439
points which means there need to be

468
00:22:08,650 --> 00:22:14,960
relatively few of them and effectiveness

469
00:22:12,440 --> 00:22:17,150
because our testing is only going to

470
00:22:14,960 --> 00:22:19,280
find vulnerabilities that occur as a

471
00:22:17,150 --> 00:22:22,330
result to injecting or message based

472
00:22:19,280 --> 00:22:25,760
attacks at these attack injection points

473
00:22:22,330 --> 00:22:28,370
with that in mind then one possible

474
00:22:25,760 --> 00:22:31,610
attack injection scheme is packets end

475
00:22:28,370 --> 00:22:34,010
based attack injection the idea here is

476
00:22:31,610 --> 00:22:35,719
that for each packet we're going to

477
00:22:34,010 --> 00:22:39,620
inject each of our message based attacks

478
00:22:35,720 --> 00:22:41,190
at each packet send are the benefits of

479
00:22:39,620 --> 00:22:43,590
this approach or that it's

480
00:22:41,190 --> 00:22:45,780
simple and easy-to-implement the

481
00:22:43,590 --> 00:22:48,000
downsides are that it doesn't support

482
00:22:45,780 --> 00:22:50,220
injecting new packets into the network

483
00:22:48,000 --> 00:22:52,170
so while we can easily modify existing

484
00:22:50,220 --> 00:22:54,960
packets in our connection we can't

485
00:22:52,170 --> 00:22:56,850
inject new ones which means we will be

486
00:22:54,960 --> 00:22:59,160
unable to find the entire category of

487
00:22:56,850 --> 00:23:01,709
off path attacks that I mentioned a

488
00:22:59,160 --> 00:23:03,810
moment ago additionally as I've

489
00:23:01,710 --> 00:23:06,240
currently specified it this only

490
00:23:03,810 --> 00:23:08,520
considers modifying a single packet

491
00:23:06,240 --> 00:23:10,680
profess protest so if we're modify

492
00:23:08,520 --> 00:23:13,560
packet to we can't also modify packet

493
00:23:10,680 --> 00:23:15,630
three for instance this means we'll be

494
00:23:13,560 --> 00:23:17,669
unable to find the TCP close rate

495
00:23:15,630 --> 00:23:20,310
resource exhaustion attack that I

496
00:23:17,670 --> 00:23:24,660
mentioned because that attack requires

497
00:23:20,310 --> 00:23:26,639
modifying multiple reset packets however

498
00:23:24,660 --> 00:23:28,890
it turns out that's not a huge

499
00:23:26,640 --> 00:23:31,350
limitation here because even as I

500
00:23:28,890 --> 00:23:34,950
specified it packets end based attack

501
00:23:31,350 --> 00:23:37,230
injection simply isn't scalable our

502
00:23:34,950 --> 00:23:41,100
two-minute tcp tests to generate about

503
00:23:37,230 --> 00:23:44,430
13,000 packets which would take us 956

504
00:23:41,100 --> 00:23:47,669
days of computation to test fairly

505
00:23:44,430 --> 00:23:49,650
impractical in addition as I just

506
00:23:47,670 --> 00:23:52,110
mentioned packets in based attack

507
00:23:49,650 --> 00:23:54,690
injection mrs. this entire category of

508
00:23:52,110 --> 00:23:59,699
off path attacks that we'd really like

509
00:23:54,690 --> 00:24:02,580
to be able to find so to help help with

510
00:23:59,700 --> 00:24:05,820
that we can consider time-based attack

511
00:24:02,580 --> 00:24:08,010
injection the idea here is that every n

512
00:24:05,820 --> 00:24:10,260
seconds we're going to inject each

513
00:24:08,010 --> 00:24:13,050
message based attack and observe the

514
00:24:10,260 --> 00:24:14,970
result where n represents some trade-off

515
00:24:13,050 --> 00:24:17,879
between the scalability and the coverage

516
00:24:14,970 --> 00:24:19,980
of our casting and about the smallest

517
00:24:17,880 --> 00:24:23,510
value for n mate that makes sense is the

518
00:24:19,980 --> 00:24:26,100
time to transmit a minimum size packet

519
00:24:23,510 --> 00:24:27,870
the benefits of this approach are that

520
00:24:26,100 --> 00:24:30,870
it supports injecting new packets into

521
00:24:27,870 --> 00:24:32,879
the network so we can find that category

522
00:24:30,870 --> 00:24:36,060
of off path attacks that I talked about

523
00:24:32,880 --> 00:24:38,930
the downsides are again we're only

524
00:24:36,060 --> 00:24:41,639
considering applying a single

525
00:24:38,930 --> 00:24:44,850
modification or packet modification or

526
00:24:41,640 --> 00:24:47,010
injection port protest which means we

527
00:24:44,850 --> 00:24:50,699
still can't find the TCP close wait

528
00:24:47,010 --> 00:24:53,970
resource absorption attack however again

529
00:24:50,700 --> 00:24:54,809
this is not a huge limitation because

530
00:24:53,970 --> 00:24:57,330
even as I

531
00:24:54,809 --> 00:25:00,029
specified it time-based attack injection

532
00:24:57,330 --> 00:25:04,769
can't achieve good scalability and high

533
00:25:00,029 --> 00:25:09,090
coverage if we pick a small value for n

534
00:25:04,769 --> 00:25:12,120
for high coverage like five microseconds

535
00:25:09,090 --> 00:25:14,908
in this particular test we ended up with

536
00:25:12,120 --> 00:25:17,789
12 million possible injection points

537
00:25:14,909 --> 00:25:22,830
which will take us 24 million hours to

538
00:25:17,789 --> 00:25:24,840
test which is fairly impractical since

539
00:25:22,830 --> 00:25:26,370
then both packets M based attack

540
00:25:24,840 --> 00:25:29,759
injection and time-based attack

541
00:25:26,370 --> 00:25:32,508
injection are impractical we proposed

542
00:25:29,759 --> 00:25:34,799
protocol state machine attack injection

543
00:25:32,509 --> 00:25:37,379
which leverages the protocol state

544
00:25:34,799 --> 00:25:41,820
machine to provide improved scalability

545
00:25:37,379 --> 00:25:45,649
and coverage on the right hand side of

546
00:25:41,820 --> 00:25:47,639
this figure I is TCPS state machine

547
00:25:45,649 --> 00:25:50,939
you'll note that the state machine

548
00:25:47,639 --> 00:25:52,949
identifies key protocol areas so the top

549
00:25:50,940 --> 00:25:56,610
several states are the connection

550
00:25:52,950 --> 00:25:59,549
establishment phase that I mentioned the

551
00:25:56,610 --> 00:26:02,248
established state in green on in this

552
00:25:59,549 --> 00:26:04,860
figure is the dented transfer phase and

553
00:26:02,249 --> 00:26:08,340
then the bottom several states are the

554
00:26:04,860 --> 00:26:11,639
connection termination phase the key

555
00:26:08,340 --> 00:26:14,610
idea here is that similar packet types

556
00:26:11,639 --> 00:26:17,519
received in the same state often result

557
00:26:14,610 --> 00:26:19,799
in similar actions so an acknowledgement

558
00:26:17,519 --> 00:26:22,529
packet received in the established state

559
00:26:19,799 --> 00:26:24,929
will always result in resetting the

560
00:26:22,529 --> 00:26:28,350
retransmission timer and sending new

561
00:26:24,929 --> 00:26:30,570
data if new data is available however in

562
00:26:28,350 --> 00:26:32,879
the sim received state or the last act

563
00:26:30,570 --> 00:26:34,619
state very different things happen on

564
00:26:32,879 --> 00:26:38,668
the reception of an acknowledgement

565
00:26:34,619 --> 00:26:40,379
packet so what we attempt to do is to

566
00:26:38,669 --> 00:26:43,519
combine the protocol state and the

567
00:26:40,379 --> 00:26:46,408
packet type for our attack injection

568
00:26:43,519 --> 00:26:49,169
specifically we consider the protocol

569
00:26:46,409 --> 00:26:51,419
state and packet type pairs and apply

570
00:26:49,169 --> 00:26:55,529
each are a message based attacks to each

571
00:26:51,419 --> 00:26:57,990
of these pairs the benefits of this

572
00:26:55,529 --> 00:27:00,899
approach are that it's scalable it takes

573
00:26:57,990 --> 00:27:03,960
us about 300 hours to test and

574
00:27:00,899 --> 00:27:08,668
implementation of a transfer protocol

575
00:27:03,960 --> 00:27:10,679
with this grant method and we can apply

576
00:27:08,669 --> 00:27:13,409
tax to more than just a single packet at

577
00:27:10,679 --> 00:27:16,019
a time enabling us to find in fact we

578
00:27:13,409 --> 00:27:19,200
did find the TCP close weight resource

579
00:27:16,019 --> 00:27:21,179
exhaustion attack the downsides of this

580
00:27:19,200 --> 00:27:24,330
approach are that it assumes the same

581
00:27:21,179 --> 00:27:26,909
machine is available in practice this

582
00:27:24,330 --> 00:27:29,249
turns out to not be a huge issue because

583
00:27:26,909 --> 00:27:31,289
for most transfer protocols the state

584
00:27:29,249 --> 00:27:35,299
machine is explicitly specified in the

585
00:27:31,289 --> 00:27:38,100
protocols RFC specification document

586
00:27:35,299 --> 00:27:40,590
usually as an ASCII art diagram that's

587
00:27:38,100 --> 00:27:44,939
easy to convert into the representation

588
00:27:40,590 --> 00:27:46,199
that we use we also need to assume the

589
00:27:44,940 --> 00:27:49,320
state machine is implemented correctly

590
00:27:46,200 --> 00:27:51,149
by the implementation under test again

591
00:27:49,320 --> 00:27:56,249
in practice this turned out to not be a

592
00:27:51,149 --> 00:27:58,350
huge issue because a state machine

593
00:27:56,249 --> 00:28:01,710
that's implemented incorrectly usually

594
00:27:58,350 --> 00:28:04,649
results in interoperability or basic

595
00:28:01,710 --> 00:28:07,799
protocol functionality bugs develop that

596
00:28:04,649 --> 00:28:13,139
a developer test suite is designed to

597
00:28:07,799 --> 00:28:15,480
find to detect ok so protocol state

598
00:28:13,139 --> 00:28:20,309
machine attack injection forms the core

599
00:28:15,480 --> 00:28:22,799
of our snake attack finding tool snake

600
00:28:20,309 --> 00:28:26,249
is divided two components a controller

601
00:28:22,799 --> 00:28:28,049
and an executor the controller takes as

602
00:28:26,249 --> 00:28:30,600
input the packet formats and protocols

603
00:28:28,049 --> 00:28:33,090
state machine and uses protocol state

604
00:28:30,600 --> 00:28:36,899
machine attack injection to generate a

605
00:28:33,090 --> 00:28:39,299
number of strategies to test these are

606
00:28:36,899 --> 00:28:42,809
then sent to the executor or executors

607
00:28:39,299 --> 00:28:48,330
to attempt to test and determine whether

608
00:28:42,809 --> 00:28:50,489
there are actual tax involved we run our

609
00:28:48,330 --> 00:28:52,470
unmodified implementations protocol

610
00:28:50,489 --> 00:28:54,480
implementations in virtual machines and

611
00:28:52,470 --> 00:28:57,090
connect these virtual machines to an

612
00:28:54,480 --> 00:28:58,649
emulated network in front of one of

613
00:28:57,090 --> 00:29:01,080
these virtual machines we placed a

614
00:28:58,649 --> 00:29:04,139
malicious proxy that performs our attack

615
00:29:01,080 --> 00:29:06,139
injection this proxy supports a number

616
00:29:04,139 --> 00:29:08,580
of different basic message attacks

617
00:29:06,139 --> 00:29:11,850
things like dropping duplicating

618
00:29:08,580 --> 00:29:14,460
delaying modifying packets or injecting

619
00:29:11,850 --> 00:29:16,469
new packets singly or in sequence we'll

620
00:29:14,460 --> 00:29:19,139
talk more about the message attacks and

621
00:29:16,470 --> 00:29:21,480
why we chose these messages acts in more

622
00:29:19,139 --> 00:29:24,729
detail in a few minutes

623
00:29:21,480 --> 00:29:27,100
however are malicious proxy also has a

624
00:29:24,730 --> 00:29:30,250
component that tracks the protocol state

625
00:29:27,100 --> 00:29:33,908
of both sides of the target connection

626
00:29:30,250 --> 00:29:36,270
of the connection because we need to do

627
00:29:33,909 --> 00:29:38,559
this in order to be able to perform

628
00:29:36,270 --> 00:29:40,450
protocol state machine attack injection

629
00:29:38,559 --> 00:29:43,080
we need to know what state both sides of

630
00:29:40,450 --> 00:29:46,480
the connections are connection are in

631
00:29:43,080 --> 00:29:48,879
and to do that we're going to track the

632
00:29:46,480 --> 00:29:50,380
package that the endpoints exchange can

633
00:29:48,880 --> 00:29:55,419
compare that with the protocol state

634
00:29:50,380 --> 00:29:57,220
machine okay so during testing or we

635
00:29:55,419 --> 00:29:59,650
collect performance and resource usage

636
00:29:57,220 --> 00:30:02,950
information to be able to identify

637
00:29:59,650 --> 00:30:06,340
attacks specifically we declare our

638
00:30:02,950 --> 00:30:08,919
attacks successful if we observe unfair

639
00:30:06,340 --> 00:30:12,129
competition between the flows in our

640
00:30:08,919 --> 00:30:14,669
test which is to say that we observe

641
00:30:12,130 --> 00:30:17,770
throughput that's above or below the

642
00:30:14,669 --> 00:30:21,039
competing flows by more than a factor of

643
00:30:17,770 --> 00:30:22,570
two we also declare an attack successful

644
00:30:21,039 --> 00:30:25,390
if we observe that there are source

645
00:30:22,570 --> 00:30:27,570
server resources that are not released

646
00:30:25,390 --> 00:30:30,280
properly at the end of our tests

647
00:30:27,570 --> 00:30:36,158
indicating a potential resource

648
00:30:30,280 --> 00:30:39,610
exhaustion attack okay so the message

649
00:30:36,159 --> 00:30:42,870
based attacks that we use we developed

650
00:30:39,610 --> 00:30:45,219
by through a careful examination of

651
00:30:42,870 --> 00:30:49,418
literature on existing attacks on these

652
00:30:45,220 --> 00:30:54,059
protocols the first of these is to

653
00:30:49,419 --> 00:30:56,559
simply drop packets this particular

654
00:30:54,059 --> 00:31:00,600
action will tend to expose bugs in

655
00:30:56,559 --> 00:31:03,820
reliability or in order delivery of

656
00:31:00,600 --> 00:31:07,270
transport protocols under test we can

657
00:31:03,820 --> 00:31:10,090
also duplicate packets which will tend

658
00:31:07,270 --> 00:31:14,350
to expose bugs in fairness or congestion

659
00:31:10,090 --> 00:31:17,620
control on Melissa proxy can also has

660
00:31:14,350 --> 00:31:19,750
the ability to delay packets which will

661
00:31:17,620 --> 00:31:23,049
caused reordering and possibly

662
00:31:19,750 --> 00:31:24,789
retransmission and also interferes with

663
00:31:23,049 --> 00:31:27,549
the round-trip time estimation

664
00:31:24,789 --> 00:31:30,280
algorithms that form part of the

665
00:31:27,549 --> 00:31:32,620
reliability component of many transport

666
00:31:30,280 --> 00:31:35,190
protocols which means that it tends to

667
00:31:32,620 --> 00:31:39,659
expose bugs with reliability in

668
00:31:35,190 --> 00:31:42,120
in order delivery another message based

669
00:31:39,660 --> 00:31:45,360
attacks that we included attack that we

670
00:31:42,120 --> 00:31:48,209
included in our malicious proxies the

671
00:31:45,360 --> 00:31:50,909
ability to batch packets together that

672
00:31:48,210 --> 00:31:53,460
is to collect a bunch of packets for a

673
00:31:50,910 --> 00:31:57,140
couple seconds and then send all those

674
00:31:53,460 --> 00:32:00,330
packets out is it a single large burst

675
00:31:57,140 --> 00:32:02,640
this is ten is likely to cause issues

676
00:32:00,330 --> 00:32:05,280
with fairness and congestion control

677
00:32:02,640 --> 00:32:07,950
algorithms of various transport

678
00:32:05,280 --> 00:32:11,550
protocols in fact there are a couple of

679
00:32:07,950 --> 00:32:16,380
published attacks on TCP that operate in

680
00:32:11,550 --> 00:32:19,290
a manner similar to this we are we can

681
00:32:16,380 --> 00:32:22,020
also modify or lie about all of the

682
00:32:19,290 --> 00:32:25,620
packet fields in the packets are

683
00:32:22,020 --> 00:32:28,470
malicious proxy intercepts we can either

684
00:32:25,620 --> 00:32:31,830
set minimum maximum or random field

685
00:32:28,470 --> 00:32:34,650
values or modify the existing field

686
00:32:31,830 --> 00:32:37,080
values in these packets and this will

687
00:32:34,650 --> 00:32:38,730
tend to expose bugs in packet validation

688
00:32:37,080 --> 00:32:42,270
logic across pretty much the entire

689
00:32:38,730 --> 00:32:45,000
protocol it's a very very powerful

690
00:32:42,270 --> 00:32:48,930
action that has that can have very

691
00:32:45,000 --> 00:32:51,120
diverse consequences our malicious proxy

692
00:32:48,930 --> 00:32:54,960
is also capable of injecting packets

693
00:32:51,120 --> 00:32:58,580
into the network we can inject single

694
00:32:54,960 --> 00:33:01,740
packets using the inject action and

695
00:32:58,580 --> 00:33:04,169
doing this is typically to target the

696
00:33:01,740 --> 00:33:06,960
handling of invalid or unexpected

697
00:33:04,170 --> 00:33:10,110
sequences of packets so for instance for

698
00:33:06,960 --> 00:33:12,390
TCP we might consider thee we might

699
00:33:10,110 --> 00:33:16,080
consider a packet with the sin fin and

700
00:33:12,390 --> 00:33:18,690
act Flags all set this would be a packet

701
00:33:16,080 --> 00:33:20,520
that starts a connection terminates a

702
00:33:18,690 --> 00:33:23,160
connection and acknowledges data in the

703
00:33:20,520 --> 00:33:35,870
connection which is clearly an invalid

704
00:33:23,160 --> 00:33:38,750
combination the final message attack

705
00:33:35,870 --> 00:33:42,330
then are malicious proxies Forks is

706
00:33:38,750 --> 00:33:46,290
called hit sequence window and it's

707
00:33:42,330 --> 00:33:48,559
designed to inject many packets into the

708
00:33:46,290 --> 00:33:50,629
connection with sequence numbers that's

709
00:33:48,559 --> 00:33:53,299
and the entire possible sequence range

710
00:33:50,629 --> 00:33:56,748
and it attempt to find attacks that are

711
00:33:53,299 --> 00:34:01,009
similar to known reset or sin reset

712
00:33:56,749 --> 00:34:03,679
attacks on TCP basically these attacks

713
00:34:01,009 --> 00:34:07,129
are conducted by off path attackers who

714
00:34:03,679 --> 00:34:10,550
spoof control packets into a target

715
00:34:07,129 --> 00:34:16,279
connection with the result of the

716
00:34:10,550 --> 00:34:19,040
connection is terminated ok so now we've

717
00:34:16,280 --> 00:34:21,530
looked a lot at the design of snake and

718
00:34:19,040 --> 00:34:24,379
at the particular message based attacks

719
00:34:21,530 --> 00:34:26,690
that we implemented with our militia

720
00:34:24,379 --> 00:34:29,799
proxy now I want to take just a moment

721
00:34:26,690 --> 00:34:32,089
to talk about the art implementation

722
00:34:29,800 --> 00:34:35,270
I've mentioned before that snake is

723
00:34:32,089 --> 00:34:38,989
divided into two components a controller

724
00:34:35,270 --> 00:34:40,940
and an executor the reason for doing

725
00:34:38,989 --> 00:34:42,828
this is that it enables effective

726
00:34:40,940 --> 00:34:48,020
paralyzation of our testing strategies

727
00:34:42,829 --> 00:34:51,530
so we can run many executors on multiple

728
00:34:48,020 --> 00:34:53,509
machines to quickly test the different

729
00:34:51,530 --> 00:34:57,160
possible attack strategies that our

730
00:34:53,510 --> 00:34:59,690
controller generates the executor itself

731
00:34:57,160 --> 00:35:02,328
consists of a perl script to coordinate

732
00:34:59,690 --> 00:35:04,849
our virtual machines our emulated

733
00:35:02,329 --> 00:35:08,420
network and our malicious proxy and the

734
00:35:04,849 --> 00:35:12,140
malicious proxy is built into ns3 which

735
00:35:08,420 --> 00:35:14,060
we use for our emulated network I should

736
00:35:12,140 --> 00:35:16,730
also note that our implementation

737
00:35:14,060 --> 00:35:18,380
requires two inputs from the user first

738
00:35:16,730 --> 00:35:20,750
a description of the packet formats

739
00:35:18,380 --> 00:35:23,300
written in a simple language that looks

740
00:35:20,750 --> 00:35:25,069
a lot like see structures and a

741
00:35:23,300 --> 00:35:27,140
description of the protocols state

742
00:35:25,069 --> 00:35:33,500
machine written in the dot graph

743
00:35:27,140 --> 00:35:38,390
language for our evaluation we tested to

744
00:35:33,500 --> 00:35:40,750
transport protocols tcp and DC CP DC CP

745
00:35:38,390 --> 00:35:44,629
is a relatively new transport protocol

746
00:35:40,750 --> 00:35:47,869
designed for use in real-time video or

747
00:35:44,630 --> 00:35:49,430
VoIP applications we tested five

748
00:35:47,869 --> 00:35:51,650
implementations in four different

749
00:35:49,430 --> 00:35:55,730
operating systems of these protocols in

750
00:35:51,650 --> 00:36:01,150
Linux 30 Linux 313 windows 95 and

751
00:35:55,730 --> 00:36:01,150
windows 8.1 yes

752
00:36:01,430 --> 00:36:08,190
so windows 95 because we figured we'd be

753
00:36:05,700 --> 00:36:11,839
able to find a number of bugs in Windows

754
00:36:08,190 --> 00:36:15,000
95 so we figured that would be a good

755
00:36:11,839 --> 00:36:19,170
implication to be able to test to show

756
00:36:15,000 --> 00:36:20,819
that we can effectively find bugs in

757
00:36:19,170 --> 00:36:25,170
particular there are there are a number

758
00:36:20,819 --> 00:36:27,450
of well-known TCP attacks that Windows

759
00:36:25,170 --> 00:36:30,539
95 being an older operating system is

760
00:36:27,450 --> 00:36:32,328
vulnerable to that some of the new

761
00:36:30,539 --> 00:36:36,809
operating systems however already fixed

762
00:36:32,329 --> 00:36:38,940
so it gives us a historical test point a

763
00:36:36,809 --> 00:36:44,010
historical data point it's what the way

764
00:36:38,940 --> 00:36:47,849
to put it protocol state machine attack

765
00:36:44,010 --> 00:36:52,559
injection found 5500 attacks against TCP

766
00:36:47,849 --> 00:36:54,869
and 4500 attacks against a CCP our total

767
00:36:52,559 --> 00:36:59,579
testing time / implementation was about

768
00:36:54,869 --> 00:37:01,470
60 hours which was using 5 executors

769
00:36:59,579 --> 00:37:04,680
running in parallel to test our attack

770
00:37:01,470 --> 00:37:07,618
strategies and we ultimately found 9

771
00:37:04,680 --> 00:37:09,618
vulnerabilities five of them up

772
00:37:07,619 --> 00:37:11,849
previously unknown in the literature

773
00:37:09,619 --> 00:37:14,069
we've already looked at one of these

774
00:37:11,849 --> 00:37:16,349
attacks the TCP closed wait resource

775
00:37:14,069 --> 00:37:18,299
exhaustion attack this was a new

776
00:37:16,349 --> 00:37:22,559
previously unknown attack that we found

777
00:37:18,299 --> 00:37:25,680
using snake one of the other new attacks

778
00:37:22,559 --> 00:37:30,470
that snake found is the DC CP request

779
00:37:25,680 --> 00:37:33,629
connection termination attack this is

780
00:37:30,470 --> 00:37:35,700
attack where an off path attacker can

781
00:37:33,630 --> 00:37:37,559
terminate the connection if you can

782
00:37:35,700 --> 00:37:43,169
guess roughly when that connection will

783
00:37:37,559 --> 00:37:46,589
be initiated the way the attack works is

784
00:37:43,170 --> 00:37:49,500
that on initiating a connection a client

785
00:37:46,589 --> 00:37:52,920
sends a request packet and moves to the

786
00:37:49,500 --> 00:37:55,980
request state and in this state the only

787
00:37:52,920 --> 00:37:59,789
valid packets the only valid response is

788
00:37:55,980 --> 00:38:02,730
a response packet and importantly the

789
00:37:59,789 --> 00:38:05,490
Linux implementation of DC CP performs

790
00:38:02,730 --> 00:38:07,559
this packet type check before it checks

791
00:38:05,490 --> 00:38:08,910
the act number in the received packet

792
00:38:07,559 --> 00:38:12,569
and the acknowledgement number in that

793
00:38:08,910 --> 00:38:13,770
packet which means that an attacker can

794
00:38:12,569 --> 00:38:17,370
simply

795
00:38:13,770 --> 00:38:19,080
and any non response packet after the

796
00:38:17,370 --> 00:38:20,819
client has send it to request packet and

797
00:38:19,080 --> 00:38:25,819
before the server's response packet

798
00:38:20,820 --> 00:38:25,820
arrives and the connection will be reset

799
00:38:26,510 --> 00:38:32,690
another of the attacks that we found is

800
00:38:29,100 --> 00:38:35,460
the tcp duplicate act spoofing attack

801
00:38:32,690 --> 00:38:40,500
this is a previously known attack as

802
00:38:35,460 --> 00:38:42,810
discovered by savage in 1999 and this

803
00:38:40,500 --> 00:38:45,150
attack allows clients to gain more than

804
00:38:42,810 --> 00:38:49,170
their fair share of bandwidth due to

805
00:38:45,150 --> 00:38:52,290
overlay naive servers the way this

806
00:38:49,170 --> 00:38:54,150
attack works is that if you call

807
00:38:52,290 --> 00:38:58,620
previously from our discussion of tcp

808
00:38:54,150 --> 00:39:01,290
when a when either the climber or server

809
00:38:58,620 --> 00:39:04,830
receives data they need they will need

810
00:39:01,290 --> 00:39:06,300
to acknowledge that data however if

811
00:39:04,830 --> 00:39:09,120
instead of just sending a single

812
00:39:06,300 --> 00:39:10,940
acknowledgement the client in this kit

813
00:39:09,120 --> 00:39:12,839
in this case the client can send

814
00:39:10,940 --> 00:39:14,820
duplicate acknowledgments can send

815
00:39:12,840 --> 00:39:17,910
multiple acknowledgments some of which

816
00:39:14,820 --> 00:39:19,920
are duplicated and then the server on

817
00:39:17,910 --> 00:39:21,180
its side doesn't check for these

818
00:39:19,920 --> 00:39:23,580
acknowledgments that have been

819
00:39:21,180 --> 00:39:26,129
duplicated with the result that the

820
00:39:23,580 --> 00:39:28,620
server will increase its sending respect

821
00:39:26,130 --> 00:39:31,170
rate in response to these duplicate

822
00:39:28,620 --> 00:39:33,210
acknowledgments allowing the client to

823
00:39:31,170 --> 00:39:38,550
gain much more than its fair share of

824
00:39:33,210 --> 00:39:42,200
bandwidth in our tests snake was able to

825
00:39:38,550 --> 00:39:47,070
achieve throughput of our factor of five

826
00:39:42,200 --> 00:39:51,270
over the competing connection against a

827
00:39:47,070 --> 00:39:52,800
windows 95 server using this attack to

828
00:39:51,270 --> 00:39:57,330
your question this is one of those

829
00:39:52,800 --> 00:39:58,830
attacks that was discovered in 99 so

830
00:39:57,330 --> 00:40:02,160
almost all of the modern implementations

831
00:39:58,830 --> 00:40:05,279
have fixed it but windows 95 being so

832
00:40:02,160 --> 00:40:07,770
old this attack we can still find who is

833
00:40:05,280 --> 00:40:12,740
still or the windows 95 implementation

834
00:40:07,770 --> 00:40:15,390
of TCP still exhibits this attack I

835
00:40:12,740 --> 00:40:18,479
won't cover the rest of the attacks that

836
00:40:15,390 --> 00:40:21,779
we found in detail I'll just briefly

837
00:40:18,480 --> 00:40:24,570
show a summary here but I will point out

838
00:40:21,780 --> 00:40:26,850
that we found attacks in all the

839
00:40:24,570 --> 00:40:30,180
protocols that we tested as well

840
00:40:26,850 --> 00:40:32,430
all of the implementations and that our

841
00:40:30,180 --> 00:40:36,359
attacks cover a fairly wide range of

842
00:40:32,430 --> 00:40:39,240
impacts from silver denial of service to

843
00:40:36,360 --> 00:40:44,760
fairness issues to client denial service

844
00:40:39,240 --> 00:40:48,240
or connection termination so in

845
00:40:44,760 --> 00:40:50,670
conclusion then we've proposed a new

846
00:40:48,240 --> 00:40:53,189
efficient technique for automatic

847
00:40:50,670 --> 00:40:55,140
systematic testing of transport protocol

848
00:40:53,190 --> 00:40:57,630
implementations by leveraging the

849
00:40:55,140 --> 00:40:59,580
protocol assistant state machine and we

850
00:40:57,630 --> 00:41:01,740
have implemented this technique in snake

851
00:40:59,580 --> 00:41:04,110
and applied it to five implementations

852
00:41:01,740 --> 00:41:06,839
of to transfer protocols in for

853
00:41:04,110 --> 00:41:08,910
operating systems finding nine attacks

854
00:41:06,840 --> 00:41:12,150
five of which we believe to be

855
00:41:08,910 --> 00:41:14,580
previously unknown with that that

856
00:41:12,150 --> 00:41:17,040
concludes my presentation and I'd be

857
00:41:14,580 --> 00:41:31,500
happy to take any questions now thank

858
00:41:17,040 --> 00:41:40,740
you questions yes the transport layers

859
00:41:31,500 --> 00:41:42,630
pretty low level protocols so we've

860
00:41:40,740 --> 00:41:46,979
considered that a little bit actually

861
00:41:42,630 --> 00:41:50,010
this work we've almost gone the other

862
00:41:46,980 --> 00:41:52,140
direction actually so turret that I

863
00:41:50,010 --> 00:41:55,920
mentioned in talking about other testing

864
00:41:52,140 --> 00:41:58,290
strategies is actually a system

865
00:41:55,920 --> 00:42:00,030
developed by Christina and I would have

866
00:41:58,290 --> 00:42:02,700
heard other grad students who has

867
00:42:00,030 --> 00:42:04,830
graduated at this point looking at

868
00:42:02,700 --> 00:42:10,500
application level distributed systems

869
00:42:04,830 --> 00:42:12,960
protocols so moving to sneak then we've

870
00:42:10,500 --> 00:42:17,120
actually come down a level with that

871
00:42:12,960 --> 00:42:21,380
said we are considering applying similar

872
00:42:17,120 --> 00:42:23,520
approaches to other other protocols like

873
00:42:21,380 --> 00:42:29,270
open flow is one that we're looking at

874
00:42:23,520 --> 00:42:29,270
for Sdn systems other questions

875
00:42:33,470 --> 00:42:39,120
yes I'm sorry could you push the green

876
00:42:37,380 --> 00:42:41,490
button on that microphone there that

877
00:42:39,120 --> 00:42:45,120
would get you thank you sure you

878
00:42:41,490 --> 00:42:49,560
mentioned like 5500 successful I think

879
00:42:45,120 --> 00:42:51,630
it was DC CP attacks and so you're

880
00:42:49,560 --> 00:42:54,140
probably thinking of this number here

881
00:42:51,630 --> 00:42:56,760
correct those are the number of

882
00:42:54,140 --> 00:43:00,290
strategies or possible attacks that we

883
00:42:56,760 --> 00:43:04,670
tested successful attacks we found three

884
00:43:00,290 --> 00:43:04,670
here okay thanks

885
00:43:15,390 --> 00:43:22,440
okay if there are no no I guess we got

886
00:43:18,359 --> 00:43:27,170
one more question Amy so on the denial

887
00:43:22,440 --> 00:43:30,210
of service impact ones where those like

888
00:43:27,170 --> 00:43:33,119
min the middle or whatever your term was

889
00:43:30,210 --> 00:43:36,779
for the cliq that the non proxy attacker

890
00:43:33,119 --> 00:43:43,369
client you had so off at all cats oh

891
00:43:36,779 --> 00:43:48,839
yeah yeah um so several of these let me

892
00:43:43,369 --> 00:43:50,819
let me think here the DCC p request

893
00:43:48,839 --> 00:43:53,910
termination attack the bottom of the

894
00:43:50,819 --> 00:43:56,730
slide is an off path attack both of the

895
00:43:53,910 --> 00:44:00,470
reset tcp you reset and sim reset

896
00:43:56,730 --> 00:44:00,470
attacks those are both off path attacks

897
00:44:01,220 --> 00:44:06,419
do they all require like the guessing

898
00:44:03,599 --> 00:44:09,180
like the one that you showed a little

899
00:44:06,420 --> 00:44:11,819
bit of chance or yes yes in essence

900
00:44:09,180 --> 00:44:14,098
these are all in that situation the

901
00:44:11,819 --> 00:44:18,720
attacker is basically blind so okay they

902
00:44:14,099 --> 00:44:21,210
have to guess or you're essentially it's

903
00:44:18,720 --> 00:44:23,549
the attacks rely on spoofing enough

904
00:44:21,210 --> 00:44:32,039
packets that you you are statistically

905
00:44:23,549 --> 00:44:34,829
right okay okay if there are no further

906
00:44:32,039 --> 00:44:37,910
questions and thank you very much this

907
00:44:34,829 --> 00:44:37,910
concludes today's seminar

908
00:44:51,140 --> 00:44:53,200
you

