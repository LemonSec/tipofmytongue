1
00:00:21,170 --> 00:00:25,130
stand by 30 seconds

2
00:00:53,980 --> 00:01:00,500
good afternoon welcome to the serious

3
00:00:57,050 --> 00:01:04,459
security seminar today it's my pleasure

4
00:01:00,500 --> 00:01:06,560
to introduce young-hee kwan-yuen he is a

5
00:01:04,459 --> 00:01:09,139
PhD student in the Department of

6
00:01:06,560 --> 00:01:12,010
Computer Science at Purdue his research

7
00:01:09,140 --> 00:01:14,780
interests include but not limited to

8
00:01:12,010 --> 00:01:17,510
dynamic and Static binary program

9
00:01:14,780 --> 00:01:20,000
analysis reverse engineering and

10
00:01:17,510 --> 00:01:22,790
assistant security and he's focusing on

11
00:01:20,000 --> 00:01:25,340
solving security and debugging problems

12
00:01:22,790 --> 00:01:27,290
using dynamic binary analysis

13
00:01:25,340 --> 00:01:30,890
translation and transformation

14
00:01:27,290 --> 00:01:33,350
techniques he's a recipient of the 6th

15
00:01:30,890 --> 00:01:38,000
soft distinguished paper award and the

16
00:01:33,350 --> 00:01:39,919
best paper award from ase 2013 that is

17
00:01:38,000 --> 00:01:45,830
the conference on automated software

18
00:01:39,920 --> 00:01:47,840
engineering hello thanks for attending

19
00:01:45,830 --> 00:01:51,350
this talk today I'm going to talk about

20
00:01:47,840 --> 00:01:53,210
a p2c understanding output data fires

21
00:01:51,350 --> 00:01:57,679
we're on the fly transformation from

22
00:01:53,210 --> 00:01:59,658
producer to consumer execution this work

23
00:01:57,680 --> 00:02:03,380
is a joint work with sra international

24
00:01:59,659 --> 00:02:08,330
and cisco systems and i was presented at

25
00:02:03,380 --> 00:02:11,720
ndss this year and let me start with a

26
00:02:08,330 --> 00:02:16,070
simple question what is the program and

27
00:02:11,720 --> 00:02:18,800
what they do so it's simple and it's

28
00:02:16,070 --> 00:02:22,609
easy question you can find the answers

29
00:02:18,800 --> 00:02:25,549
from the slide very quickly so the

30
00:02:22,610 --> 00:02:28,280
program just take inputs and process it

31
00:02:25,549 --> 00:02:30,769
and outputs and the computer programs

32
00:02:28,280 --> 00:02:33,260
generate a lot of outputs and some of

33
00:02:30,769 --> 00:02:36,920
them stored on to the fires and some of

34
00:02:33,260 --> 00:02:39,829
them are sent out to other computers

35
00:02:36,920 --> 00:02:42,530
through the networks but here is the

36
00:02:39,830 --> 00:02:45,890
question do we really know what kind of

37
00:02:42,530 --> 00:02:48,650
data are stored to or send out to the

38
00:02:45,890 --> 00:02:54,170
other computers the answer is

39
00:02:48,650 --> 00:02:58,420
unfortunately no for example many of you

40
00:02:54,170 --> 00:03:01,760
see these kind of windows in many cases

41
00:02:58,420 --> 00:03:02,958
that is when some program crashed they

42
00:03:01,760 --> 00:03:04,160
say that they're going to send some

43
00:03:02,959 --> 00:03:05,990
information they're going to collect

44
00:03:04,160 --> 00:03:09,140
some information and send

45
00:03:05,990 --> 00:03:11,900
these two their servers to investigate

46
00:03:09,140 --> 00:03:15,579
the crash later but do we really know

47
00:03:11,900 --> 00:03:21,440
what kind of data they really collect

48
00:03:15,580 --> 00:03:24,320
sure no so the understanding unknown

49
00:03:21,440 --> 00:03:27,500
data virus or net on messages is a

50
00:03:24,320 --> 00:03:32,750
prominent security challenge and let me

51
00:03:27,500 --> 00:03:35,570
keep your concrete example so a user

52
00:03:32,750 --> 00:03:39,500
download and install some few freeware

53
00:03:35,570 --> 00:03:41,750
programs and use it for wire and weeks

54
00:03:39,500 --> 00:03:44,950
later he found some mysterious binary

55
00:03:41,750 --> 00:03:47,960
fires in his computer and sure

56
00:03:44,950 --> 00:03:50,600
intuitively it is mysterious binary

57
00:03:47,960 --> 00:03:53,180
fires you can think of they are

58
00:03:50,600 --> 00:03:55,850
generated by this one of the pier

59
00:03:53,180 --> 00:03:59,420
programs but you don't know really who

60
00:03:55,850 --> 00:04:01,340
create these files so without audit

61
00:03:59,420 --> 00:04:03,589
logging and monitoring systems is

62
00:04:01,340 --> 00:04:07,480
difficult to answer these following two

63
00:04:03,590 --> 00:04:11,120
questions first to create these fires or

64
00:04:07,480 --> 00:04:14,359
whether do they contain actual private

65
00:04:11,120 --> 00:04:17,120
data for example private personal

66
00:04:14,360 --> 00:04:21,650
profile or content list or keystroke

67
00:04:17,120 --> 00:04:25,070
that you don't want to share and again

68
00:04:21,649 --> 00:04:27,260
these mysterious mysterious binary

69
00:04:25,070 --> 00:04:31,370
buyers are just finery so without

70
00:04:27,260 --> 00:04:33,890
knowing the data structures in the virus

71
00:04:31,370 --> 00:04:36,470
if you can just open these files on the

72
00:04:33,890 --> 00:04:39,289
hex editors or you can see it's just

73
00:04:36,470 --> 00:04:45,250
sequence of the hex so you don't really

74
00:04:39,290 --> 00:04:48,470
have chance to understand the data fires

75
00:04:45,250 --> 00:04:52,160
this problem is actually has been there

76
00:04:48,470 --> 00:04:54,100
for a long time so there are many input

77
00:04:52,160 --> 00:04:58,640
format reverse engineering techniques

78
00:04:54,100 --> 00:05:00,880
based on consumer programs such as a

79
00:04:58,640 --> 00:05:04,490
prospect and chimney and the word and

80
00:05:00,880 --> 00:05:06,340
here I want to first define consumer

81
00:05:04,490 --> 00:05:08,990
programs and the producer programs

82
00:05:06,340 --> 00:05:11,450
consumer programs are the programs that

83
00:05:08,990 --> 00:05:13,940
we and understand the input buyers

84
00:05:11,450 --> 00:05:19,469
producer programs are the programs that

85
00:05:13,940 --> 00:05:22,650
generates such input fires so

86
00:05:19,470 --> 00:05:25,050
the key idea behind the input format

87
00:05:22,650 --> 00:05:27,750
reverse engineering techniques is that

88
00:05:25,050 --> 00:05:30,120
they monitor the execution of consumer

89
00:05:27,750 --> 00:05:32,670
programs and they analyze the execution

90
00:05:30,120 --> 00:05:37,800
to understand how the fires or messages

91
00:05:32,670 --> 00:05:41,280
are parsed in the consumer program so

92
00:05:37,800 --> 00:05:44,130
let me give you an example we have fire

93
00:05:41,280 --> 00:05:46,650
that we want to analyze on the left side

94
00:05:44,130 --> 00:05:48,510
and the program the consumer program

95
00:05:46,650 --> 00:05:51,510
they read and understand the file on the

96
00:05:48,510 --> 00:05:55,289
right side so it the consumer program

97
00:05:51,510 --> 00:05:58,140
first call every to read a field normal

98
00:05:55,290 --> 00:06:01,500
file the field contains a string James

99
00:05:58,140 --> 00:06:04,140
here and later at the program cause

100
00:06:01,500 --> 00:06:06,030
string copy function and one of the

101
00:06:04,140 --> 00:06:08,580
parameter is the proper we just read

102
00:06:06,030 --> 00:06:11,219
from five so at this point we know that

103
00:06:08,580 --> 00:06:14,789
the proper actually a string type and

104
00:06:11,220 --> 00:06:17,490
then we propagate back this information

105
00:06:14,790 --> 00:06:20,460
to the fire field so at this point we

106
00:06:17,490 --> 00:06:23,550
know that the fire field that the field

107
00:06:20,460 --> 00:06:27,000
from the fire is a string type so this

108
00:06:23,550 --> 00:06:30,930
is how the existing input form a reverse

109
00:06:27,000 --> 00:06:33,590
engineering technique works but here we

110
00:06:30,930 --> 00:06:39,050
have the problem because they require

111
00:06:33,590 --> 00:06:42,239
the consumer programs but unfortunately

112
00:06:39,050 --> 00:06:44,610
we don't have consumer programs in many

113
00:06:42,240 --> 00:06:46,740
cases in practice so what if we don't

114
00:06:44,610 --> 00:06:48,870
have the consumer programs and we only

115
00:06:46,740 --> 00:06:52,740
have the producer program let me give

116
00:06:48,870 --> 00:06:55,470
you an example and in case of the

117
00:06:52,740 --> 00:06:56,910
Barnett command and control protocol we

118
00:06:55,470 --> 00:07:00,210
don't have consumer program on the

119
00:06:56,910 --> 00:07:02,729
victim machine so we only have a

120
00:07:00,210 --> 00:07:05,489
producer program on the victim machine

121
00:07:02,729 --> 00:07:07,950
and the producer collects some of your

122
00:07:05,490 --> 00:07:10,620
data and they generate some unknown

123
00:07:07,950 --> 00:07:13,050
metal messages and send to the attackers

124
00:07:10,620 --> 00:07:16,460
machine the consumer program that can

125
00:07:13,050 --> 00:07:19,160
read and understand the network message

126
00:07:16,460 --> 00:07:21,000
exist on the attackers machine

127
00:07:19,160 --> 00:07:23,729
unfortunately we don't have the access

128
00:07:21,000 --> 00:07:25,919
to the attackers machine so the problem

129
00:07:23,729 --> 00:07:29,280
here really comes down to how to

130
00:07:25,919 --> 00:07:33,950
understand such unknown network messages

131
00:07:29,280 --> 00:07:33,950
without having consumer programs

132
00:07:34,259 --> 00:07:42,880
before I talk about the p 2z program I

133
00:07:38,889 --> 00:07:45,610
want to first talk about an observation

134
00:07:42,880 --> 00:07:50,050
that motivated our work so paper

135
00:07:45,610 --> 00:07:52,570
published it in FSC 2011 the tighter is

136
00:07:50,050 --> 00:07:56,289
checking compliments of a producer and a

137
00:07:52,570 --> 00:08:01,169
consumer they proposed us an observation

138
00:07:56,289 --> 00:08:04,360
that a producer and consumer a symmetric

139
00:08:01,169 --> 00:08:06,460
they use this observation to show that

140
00:08:04,360 --> 00:08:09,190
the correctness of the producer can be

141
00:08:06,460 --> 00:08:11,530
verified by checking its components to

142
00:08:09,190 --> 00:08:14,139
corresponding consumer basically what it

143
00:08:11,530 --> 00:08:15,940
means is if you want to check the

144
00:08:14,139 --> 00:08:17,770
correctness of the producer you can just

145
00:08:15,940 --> 00:08:20,260
monitor the execution of the consumer

146
00:08:17,770 --> 00:08:22,240
and just looking for how it accurately

147
00:08:20,260 --> 00:08:24,820
follows the corresponding consumers

148
00:08:22,240 --> 00:08:31,660
logic if they are match it then we can

149
00:08:24,820 --> 00:08:34,088
say that we don't have the bug here let

150
00:08:31,660 --> 00:08:36,640
me give you an example here so we have a

151
00:08:34,089 --> 00:08:39,190
pair of producer and consumer program

152
00:08:36,640 --> 00:08:42,279
and the producer depending on the

153
00:08:39,190 --> 00:08:44,709
predicate outcome at line number two it

154
00:08:42,279 --> 00:08:47,800
may generate just one field output or

155
00:08:44,709 --> 00:08:51,910
three build output so it may generate

156
00:08:47,800 --> 00:08:55,209
the spooling or cooling doubling and as

157
00:08:51,910 --> 00:08:59,890
you can see the consumer follows exact

158
00:08:55,209 --> 00:09:02,020
same blue a line number eight I first

159
00:08:59,890 --> 00:09:06,400
read the first view which is bling and

160
00:09:02,020 --> 00:09:09,339
then it did determine whether it goes to

161
00:09:06,400 --> 00:09:12,730
read two more views or not so as you can

162
00:09:09,339 --> 00:09:15,160
see these two a consumer producer follow

163
00:09:12,730 --> 00:09:18,339
the same rule which which means that

164
00:09:15,160 --> 00:09:21,120
they are correct and there is no bug but

165
00:09:18,339 --> 00:09:28,420
here still they require a set of

166
00:09:21,120 --> 00:09:32,350
producer and consumer and we have in our

167
00:09:28,420 --> 00:09:35,110
setting we don't have the consumer but

168
00:09:32,350 --> 00:09:39,160
these were actually inspired us to come

169
00:09:35,110 --> 00:09:41,140
up with a new idea which is how about

170
00:09:39,160 --> 00:09:45,490
just one the producer to create consumer

171
00:09:41,140 --> 00:09:50,520
if we don't have the consumer available

172
00:09:45,490 --> 00:09:54,010
and now we try to run the program and

173
00:09:50,520 --> 00:09:57,010
try to transform the producer execution

174
00:09:54,010 --> 00:09:59,560
to consumer execution and now encounter

175
00:09:57,010 --> 00:10:03,160
a huge problem which is you don't know

176
00:09:59,560 --> 00:10:05,829
how to run these programs so as you can

177
00:10:03,160 --> 00:10:07,719
imagine just executing the producer just

178
00:10:05,830 --> 00:10:10,630
executing a program without proper input

179
00:10:07,720 --> 00:10:14,980
images one and do something little seem

180
00:10:10,630 --> 00:10:16,990
simple and the script and sure they

181
00:10:14,980 --> 00:10:20,170
don't create a fire which we want to

182
00:10:16,990 --> 00:10:23,080
analyze it and as you can see I I have a

183
00:10:20,170 --> 00:10:26,709
picture of a simple abstraction of the

184
00:10:23,080 --> 00:10:30,100
program and the program has sponsor

185
00:10:26,709 --> 00:10:32,439
functions and depending on the input you

186
00:10:30,100 --> 00:10:36,700
may execute few functions and just get

187
00:10:32,440 --> 00:10:39,490
in here I mark redbox as one that

188
00:10:36,700 --> 00:10:41,260
executed and it shows that without the

189
00:10:39,490 --> 00:10:43,270
proper input we just execute one piece

190
00:10:41,260 --> 00:10:46,450
of code and it does not execute the

191
00:10:43,270 --> 00:10:48,640
produced fire function which we want to

192
00:10:46,450 --> 00:10:53,800
analyze and this is actually a

193
00:10:48,640 --> 00:10:57,100
fundamental problem of dynamic analysis

194
00:10:53,800 --> 00:10:58,899
which is a coverage problem so here is

195
00:10:57,100 --> 00:11:04,020
the big question how we solve this

196
00:10:58,899 --> 00:11:04,020
problem anyone can suggest

197
00:11:13,800 --> 00:11:21,760
so you may think of try to find like a

198
00:11:19,540 --> 00:11:26,439
lot of different inputs to drive the

199
00:11:21,760 --> 00:11:29,170
execution something like that all right

200
00:11:26,440 --> 00:11:31,680
so this is actually a huge problem and

201
00:11:29,170 --> 00:11:34,959
it's really so difficult to solve and

202
00:11:31,680 --> 00:11:37,959
there are some static analysis to try to

203
00:11:34,960 --> 00:11:40,480
find all kinds of inputs so that they

204
00:11:37,960 --> 00:11:43,570
execute all kinds of the program code

205
00:11:40,480 --> 00:11:49,000
but they are not as successful in

206
00:11:43,570 --> 00:11:52,090
practice so here our audio 2 comes to

207
00:11:49,000 --> 00:11:54,670
the rescue we have we have been

208
00:11:52,090 --> 00:11:59,590
developed a first execution engine code

209
00:11:54,670 --> 00:12:02,050
experts and the experts can explore all

210
00:11:59,590 --> 00:12:05,890
the possible paths without inputs and

211
00:12:02,050 --> 00:12:07,569
during the execution entering is during

212
00:12:05,890 --> 00:12:09,970
its exploration of the all possible

213
00:12:07,570 --> 00:12:13,360
paths it generates random inputs on

214
00:12:09,970 --> 00:12:15,850
demand and also it recovers from any

215
00:12:13,360 --> 00:12:19,330
folds during the execution so now as you

216
00:12:15,850 --> 00:12:21,940
can see thanks to the experts we can

217
00:12:19,330 --> 00:12:29,350
execute all kinds of D functions without

218
00:12:21,940 --> 00:12:32,410
requiring any inputs all right now i'm

219
00:12:29,350 --> 00:12:39,160
going to introduce beta basic idea of

220
00:12:32,410 --> 00:12:40,810
the p to see here we have unknown

221
00:12:39,160 --> 00:12:44,589
message or file that we want to analyze

222
00:12:40,810 --> 00:12:47,770
and a set of potential producers so our

223
00:12:44,590 --> 00:12:49,510
setting is we we have some messages or

224
00:12:47,770 --> 00:12:51,310
fire that we want to analyze what we

225
00:12:49,510 --> 00:12:54,160
don't know and it is previously

226
00:12:51,310 --> 00:12:56,619
generated so we actually don't know

227
00:12:54,160 --> 00:12:59,079
whether each program is generated and

228
00:12:56,620 --> 00:13:01,750
the potential producer is should not I

229
00:12:59,080 --> 00:13:04,980
mean it it does not need to be just one

230
00:13:01,750 --> 00:13:09,730
program we can have set of programs that

231
00:13:04,980 --> 00:13:13,780
as I showed the first example it could

232
00:13:09,730 --> 00:13:15,940
be of you freeware programs and then we

233
00:13:13,780 --> 00:13:18,880
feed the potential producer to the

234
00:13:15,940 --> 00:13:22,780
experts and during experts explore all

235
00:13:18,880 --> 00:13:24,850
the execution paths it try to find

236
00:13:22,780 --> 00:13:27,520
the execution paths that contain file

237
00:13:24,850 --> 00:13:29,530
open for write operation which

238
00:13:27,520 --> 00:13:35,340
essentially means produced executions

239
00:13:29,530 --> 00:13:37,990
and with these producer producer

240
00:13:35,340 --> 00:13:39,820
executions and we feed the producer

241
00:13:37,990 --> 00:13:41,860
executions and the unknown file or

242
00:13:39,820 --> 00:13:46,600
message we want to understand to the pit

243
00:13:41,860 --> 00:13:50,050
to see and Pete to see a trend generate

244
00:13:46,600 --> 00:13:52,570
transform the consumer execution once we

245
00:13:50,050 --> 00:13:55,000
have the transformed consumer execution

246
00:13:52,570 --> 00:13:57,760
we can just use the existing 10 analysis

247
00:13:55,000 --> 00:14:01,150
tools to understand the fire format as

248
00:13:57,760 --> 00:14:06,040
well as the type information of each

249
00:14:01,150 --> 00:14:07,630
field in the five so here I want to

250
00:14:06,040 --> 00:14:10,630
point out that the pig is different

251
00:14:07,630 --> 00:14:14,080
between our work and all the previous

252
00:14:10,630 --> 00:14:16,000
work is that we just directly work on

253
00:14:14,080 --> 00:14:17,920
the potential producer programs and we

254
00:14:16,000 --> 00:14:20,470
don't require any consumers and any

255
00:14:17,920 --> 00:14:29,189
input to drive even the producer

256
00:14:20,470 --> 00:14:32,410
executions all right so let me explain

257
00:14:29,190 --> 00:14:37,660
some how the pit to see actually works

258
00:14:32,410 --> 00:14:40,719
in detail here we have a non binary file

259
00:14:37,660 --> 00:14:44,079
we want to analyze as you can see is it

260
00:14:40,720 --> 00:14:45,850
kind of contains some five integer at

261
00:14:44,080 --> 00:14:49,800
the beginning and the next two fields

262
00:14:45,850 --> 00:14:52,390
contains strings and integers game and

263
00:14:49,800 --> 00:14:54,670
this is actually how this fire is

264
00:14:52,390 --> 00:14:56,830
generated we have a producer program it

265
00:14:54,670 --> 00:15:00,599
looks a little bit complex so I'm going

266
00:14:56,830 --> 00:15:04,660
to explain it line by line so first

267
00:15:00,600 --> 00:15:07,870
first line it tried to open a file which

268
00:15:04,660 --> 00:15:11,260
is essentially the unknown vibe and line

269
00:15:07,870 --> 00:15:15,910
number two it calculate the account

270
00:15:11,260 --> 00:15:23,350
number and a line number three it assign

271
00:15:15,910 --> 00:15:27,339
some constant value and a line number

272
00:15:23,350 --> 00:15:32,160
for it try to write the magic variable

273
00:15:27,340 --> 00:15:32,160
the magic video is actually the

274
00:15:33,850 --> 00:15:40,750
the signature of the fire is as if if

275
00:15:37,660 --> 00:15:42,579
you think about like PE fires at the

276
00:15:40,750 --> 00:15:45,730
very beginning of the peopie it is

277
00:15:42,579 --> 00:15:49,930
always MZ which is constant it's telling

278
00:15:45,730 --> 00:15:52,060
that this file is a certain type and Li

279
00:15:49,930 --> 00:15:53,680
number 5 you try to write the account

280
00:15:52,060 --> 00:15:56,529
number that is actually calculated at

281
00:15:53,680 --> 00:16:00,310
line number 2 and line number six to

282
00:15:56,529 --> 00:16:03,399
eight also try to calculate some numbers

283
00:16:00,310 --> 00:16:07,500
and the strings and a line number 98

284
00:16:03,399 --> 00:16:11,050
rights right the size of the header and

285
00:16:07,500 --> 00:16:14,589
line number 10 is just storing this D

286
00:16:11,050 --> 00:16:17,880
header and but please see that the size

287
00:16:14,589 --> 00:16:23,430
of that F write operation is stored

288
00:16:17,880 --> 00:16:23,430
right people at nine number nine and

289
00:16:24,240 --> 00:16:30,360
line number 11 we have a loop and the

290
00:16:27,430 --> 00:16:34,540
loop depends on the account number and

291
00:16:30,360 --> 00:16:37,240
it will store number of account

292
00:16:34,540 --> 00:16:39,639
structures at the end so this part is

293
00:16:37,240 --> 00:16:45,550
actually constructed the first it has a

294
00:16:39,639 --> 00:16:47,439
signature and the second is the number

295
00:16:45,550 --> 00:16:49,750
of accounts structures in this file and

296
00:16:47,439 --> 00:16:57,130
the third field is the size of the

297
00:16:49,750 --> 00:16:58,569
header right but the problem here is we

298
00:16:57,130 --> 00:17:01,600
don't really know how to run the

299
00:16:58,569 --> 00:17:04,119
producer so we use x-force to run the

300
00:17:01,600 --> 00:17:06,610
producer execution but the first

301
00:17:04,119 --> 00:17:10,000
execution does not really generate the

302
00:17:06,609 --> 00:17:12,010
same unknown data file that is since the

303
00:17:10,000 --> 00:17:16,709
x-force does not take any inputs it

304
00:17:12,010 --> 00:17:20,439
generate it just randomly generate the

305
00:17:16,709 --> 00:17:22,689
inputs on demand for example at line

306
00:17:20,439 --> 00:17:25,750
number two instead of calculating the

307
00:17:22,689 --> 00:17:28,329
account number it generates just random

308
00:17:25,750 --> 00:17:32,110
number two and just assign it and line

309
00:17:28,329 --> 00:17:34,750
number six seven eight it happens also

310
00:17:32,110 --> 00:17:37,090
the same way line number six it

311
00:17:34,750 --> 00:17:39,520
generates on random string and assign it

312
00:17:37,090 --> 00:17:42,220
to the name field of the header

313
00:17:39,520 --> 00:17:43,990
structure and line number seven it also

314
00:17:42,220 --> 00:17:47,169
generates on random number two and

315
00:17:43,990 --> 00:17:51,999
assign it so

316
00:17:47,169 --> 00:17:54,519
this is actually the fire generated by

317
00:17:51,999 --> 00:17:57,039
the first execution as you can see these

318
00:17:54,519 --> 00:17:59,529
two unknown file and file generated by

319
00:17:57,039 --> 00:18:02,859
the first execution are different and I

320
00:17:59,529 --> 00:18:14,889
marked a different field of between two

321
00:18:02,859 --> 00:18:19,149
fires with the red boxes so as you can

322
00:18:14,889 --> 00:18:21,039
see it has to field the first field are

323
00:18:19,149 --> 00:18:23,889
the same because it's just constant and

324
00:18:21,039 --> 00:18:25,929
this next field the number of account is

325
00:18:23,889 --> 00:18:29,080
different and the size of header is also

326
00:18:25,929 --> 00:18:31,149
different and there's a strings are also

327
00:18:29,080 --> 00:18:35,168
different in header structures and

328
00:18:31,149 --> 00:18:38,139
account structures to in here the

329
00:18:35,169 --> 00:18:40,269
biggest problem is actually we have

330
00:18:38,139 --> 00:18:42,580
different size of the header because

331
00:18:40,269 --> 00:18:45,970
that size of the header is used in line

332
00:18:42,580 --> 00:18:48,070
number 10 to store the header and it

333
00:18:45,970 --> 00:18:54,429
determines the size of the header in the

334
00:18:48,070 --> 00:18:58,269
file we will have all like misaligned

335
00:18:54,429 --> 00:19:01,600
account with misaligned account

336
00:18:58,269 --> 00:19:05,679
structures in these outcomes so if we

337
00:19:01,600 --> 00:19:07,539
use paint analysis to analyze that first

338
00:19:05,679 --> 00:19:10,419
execution to understand your known file

339
00:19:07,539 --> 00:19:12,850
all the type information we get right

340
00:19:10,419 --> 00:19:17,739
after the header including some of the

341
00:19:12,850 --> 00:19:19,988
field in the header are incorrect and

342
00:19:17,739 --> 00:19:22,450
also we can see that the file generated

343
00:19:19,989 --> 00:19:26,109
by the first execution is a little bit

344
00:19:22,450 --> 00:19:28,570
smaller than unknown file so the last

345
00:19:26,109 --> 00:19:30,519
view field in the unknown file does not

346
00:19:28,570 --> 00:19:32,350
really have the corresponding part in

347
00:19:30,519 --> 00:19:36,460
device generated by the first execution

348
00:19:32,350 --> 00:19:39,939
so even again even if we just use the

349
00:19:36,460 --> 00:19:43,529
hand analysis to analyze at the first

350
00:19:39,940 --> 00:19:47,019
execution we don't have no idea how to

351
00:19:43,529 --> 00:19:49,320
match this last few field in the unknown

352
00:19:47,019 --> 00:19:49,320
part

353
00:19:50,700 --> 00:20:01,110
so now I'm going to talk about how we

354
00:19:55,380 --> 00:20:03,360
solve this problem we have we have the

355
00:20:01,110 --> 00:20:04,770
producer program program on the left

356
00:20:03,360 --> 00:20:07,530
side and the consumer program on the

357
00:20:04,770 --> 00:20:10,410
right side the basic idea of the P to

358
00:20:07,530 --> 00:20:12,870
see is we try to find all the write

359
00:20:10,410 --> 00:20:17,610
operation and try to transform it into

360
00:20:12,870 --> 00:20:22,050
this metric read operation so let's

361
00:20:17,610 --> 00:20:24,929
beginning from the first line and when

362
00:20:22,050 --> 00:20:27,450
the producer try to open a file to write

363
00:20:24,930 --> 00:20:30,530
something we transform it to the

364
00:20:27,450 --> 00:20:35,460
symmetric read operation which is f open

365
00:20:30,530 --> 00:20:38,670
for read and the file that this F open

366
00:20:35,460 --> 00:20:41,700
function will read is not if I generated

367
00:20:38,670 --> 00:20:44,610
by the first execution is the file that

368
00:20:41,700 --> 00:20:47,930
we want to analyze so it's going to open

369
00:20:44,610 --> 00:20:52,530
the unknown file and see what happens

370
00:20:47,930 --> 00:20:55,430
next and it executes line number two and

371
00:20:52,530 --> 00:20:58,770
nine number three since we are using the

372
00:20:55,430 --> 00:21:00,600
experts to drive this execution at line

373
00:20:58,770 --> 00:21:03,000
number two instead of calculating the

374
00:21:00,600 --> 00:21:07,590
account number we assign random variable

375
00:21:03,000 --> 00:21:09,270
random random number two and line number

376
00:21:07,590 --> 00:21:12,209
three is just constant so it doesn't

377
00:21:09,270 --> 00:21:15,389
change and a line number four instead of

378
00:21:12,210 --> 00:21:18,600
writing something to the fire we do a

379
00:21:15,390 --> 00:21:21,470
symmetric read operation so it read the

380
00:21:18,600 --> 00:21:24,330
first field from the unknown file and

381
00:21:21,470 --> 00:21:27,120
since the first field is just constant

382
00:21:24,330 --> 00:21:29,189
it doesn't really matter and I line

383
00:21:27,120 --> 00:21:34,050
number five we do also this metric read

384
00:21:29,190 --> 00:21:37,950
operation and now we read the account

385
00:21:34,050 --> 00:21:40,440
number so let's see that a line number

386
00:21:37,950 --> 00:21:43,860
two we actually assign a random number

387
00:21:40,440 --> 00:21:46,200
two but here we read the second field of

388
00:21:43,860 --> 00:21:48,090
the unknown part and then the account

389
00:21:46,200 --> 00:21:53,520
number at right after the line number

390
00:21:48,090 --> 00:21:55,949
five is becoming verified so this is

391
00:21:53,520 --> 00:21:58,590
actually correcting the program state to

392
00:21:55,950 --> 00:22:01,590
drive this consumer execution correctly

393
00:21:58,590 --> 00:22:03,980
so let's see what this actually affect

394
00:22:01,590 --> 00:22:07,080
to the rest of the execution

395
00:22:03,980 --> 00:22:09,660
after that it also excute line number

396
00:22:07,080 --> 00:22:11,850
six seven eight and during the execution

397
00:22:09,660 --> 00:22:15,150
it generates some random values and

398
00:22:11,850 --> 00:22:17,159
assign it like some random strings to

399
00:22:15,150 --> 00:22:21,050
the Heather name and random number to

400
00:22:17,160 --> 00:22:24,690
the account number two and a line number

401
00:22:21,050 --> 00:22:29,310
nine we also do the symmetric read

402
00:22:24,690 --> 00:22:33,450
operation and now it reads size variable

403
00:22:29,310 --> 00:22:39,290
and this symmetry operation will read

404
00:22:33,450 --> 00:22:42,000
the third field of the unknown file

405
00:22:39,290 --> 00:22:45,420
since we just generate the random values

406
00:22:42,000 --> 00:22:48,360
during line number six seven eight the

407
00:22:45,420 --> 00:22:50,970
size is actually calculated hex hex

408
00:22:48,360 --> 00:22:54,659
number a but this is incorrect because

409
00:22:50,970 --> 00:22:59,430
in the unknown file the rear size of

410
00:22:54,660 --> 00:23:02,070
that header is 15 so at the line number

411
00:22:59,430 --> 00:23:04,770
nine the symmetric read operation will

412
00:23:02,070 --> 00:23:08,129
correct this problem so it reads the

413
00:23:04,770 --> 00:23:12,060
third field which is 15 and assign it to

414
00:23:08,130 --> 00:23:14,280
the size variable and line number 10 we

415
00:23:12,060 --> 00:23:16,889
also do the symmetric read and now we

416
00:23:14,280 --> 00:23:19,230
try to read the header and since we have

417
00:23:16,890 --> 00:23:23,610
corrected the size variable n nine

418
00:23:19,230 --> 00:23:25,410
number nine now we can now the consumer

419
00:23:23,610 --> 00:23:31,770
transform the consumer execution can

420
00:23:25,410 --> 00:23:34,080
correctly read the header and after that

421
00:23:31,770 --> 00:23:36,480
we have aloof and the number of

422
00:23:34,080 --> 00:23:40,199
iteration of this loop depends on the

423
00:23:36,480 --> 00:23:42,300
account number and let's see that first

424
00:23:40,200 --> 00:23:44,670
the account number initially has the

425
00:23:42,300 --> 00:23:48,090
random number two but a line number five

426
00:23:44,670 --> 00:23:50,190
we have redeep symmetric read and

427
00:23:48,090 --> 00:23:52,679
correct the account number and that

428
00:23:50,190 --> 00:23:57,360
actually propagated to the line number

429
00:23:52,680 --> 00:24:00,840
11 so we have now correct number of loop

430
00:23:57,360 --> 00:24:03,629
and then line number 12 we're going to

431
00:24:00,840 --> 00:24:07,679
iterate it and read the account

432
00:24:03,630 --> 00:24:11,160
structures this is unkind of nice

433
00:24:07,680 --> 00:24:13,170
example that we successfully transform a

434
00:24:11,160 --> 00:24:16,860
producer execution to consumer execution

435
00:24:13,170 --> 00:24:17,760
at the end of this execution where we

436
00:24:16,860 --> 00:24:20,429
can see that

437
00:24:17,760 --> 00:24:22,620
all the unknown fires are actually

438
00:24:20,430 --> 00:24:32,610
consumed and we reach the end of the

439
00:24:22,620 --> 00:24:43,860
file point of the unknown fire so any

440
00:24:32,610 --> 00:24:46,409
questions so far all right but the life

441
00:24:43,860 --> 00:24:49,500
is not that easy so sure there are many

442
00:24:46,410 --> 00:24:53,640
practical challenges we have observed

443
00:24:49,500 --> 00:24:55,920
many complex programs and here we

444
00:24:53,640 --> 00:25:00,450
identify a bunch of programs and

445
00:24:55,920 --> 00:25:03,060
formulate it as a one problem so we

446
00:25:00,450 --> 00:25:04,980
found a lot of programs actually there

447
00:25:03,060 --> 00:25:07,889
are some so many cases that symmetric

448
00:25:04,980 --> 00:25:10,440
read operation do not really help that

449
00:25:07,890 --> 00:25:12,990
is even though we do the symmetric read

450
00:25:10,440 --> 00:25:17,130
operation to the every write operation

451
00:25:12,990 --> 00:25:22,620
it does not help to drive the execution

452
00:25:17,130 --> 00:25:24,270
correctly this is because the symmetric

453
00:25:22,620 --> 00:25:26,520
read let's say that there are two

454
00:25:24,270 --> 00:25:29,220
symmetric read operation they are

455
00:25:26,520 --> 00:25:31,770
actually related but day since they do

456
00:25:29,220 --> 00:25:36,000
not have explicit dependence it is

457
00:25:31,770 --> 00:25:38,040
really really difficult to identify so

458
00:25:36,000 --> 00:25:40,350
let me give you an example we have a

459
00:25:38,040 --> 00:25:44,550
producer program here on the left side

460
00:25:40,350 --> 00:25:46,939
and the transformed consumer program on

461
00:25:44,550 --> 00:25:50,190
the right side let's look at the

462
00:25:46,940 --> 00:25:53,990
producer program first it bursts open

463
00:25:50,190 --> 00:25:56,190
the virus and try to calculate the

464
00:25:53,990 --> 00:25:58,800
length of the string at line number

465
00:25:56,190 --> 00:26:02,190
three and it stores the length of the

466
00:25:58,800 --> 00:26:04,409
string to the to a variable and a line

467
00:26:02,190 --> 00:26:06,960
number five is going to store but the

468
00:26:04,410 --> 00:26:08,990
problem here is a line number six when

469
00:26:06,960 --> 00:26:13,550
it's toward the popper contents it

470
00:26:08,990 --> 00:26:17,580
recalculate the size of the string again

471
00:26:13,550 --> 00:26:20,310
so just for human just looking at this

472
00:26:17,580 --> 00:26:22,980
code you can see that I assured this

473
00:26:20,310 --> 00:26:25,649
first store the length of the string and

474
00:26:22,980 --> 00:26:29,550
then store the string according to the

475
00:26:25,650 --> 00:26:30,900
code but for the program it is kind of

476
00:26:29,550 --> 00:26:33,270
difficult to

477
00:26:30,900 --> 00:26:35,820
come up with this idea because they

478
00:26:33,270 --> 00:26:38,310
don't have explicit dependence between

479
00:26:35,820 --> 00:26:40,950
line number five or six so let's see

480
00:26:38,310 --> 00:26:43,260
what happens when we apply symmetric

481
00:26:40,950 --> 00:26:45,140
read operation in this program so the

482
00:26:43,260 --> 00:26:51,510
consumer program follows the same

483
00:26:45,140 --> 00:26:54,210
sequence alignment is same and at line

484
00:26:51,510 --> 00:26:56,670
number three it tried to calculate the

485
00:26:54,210 --> 00:26:59,220
length of the string but since we use

486
00:26:56,670 --> 00:27:01,410
the first execution the proper contents

487
00:26:59,220 --> 00:27:05,010
is not the correct one it just have

488
00:27:01,410 --> 00:27:08,220
random buffer so sure the length is

489
00:27:05,010 --> 00:27:11,100
incorrect but align number five since it

490
00:27:08,220 --> 00:27:12,960
tried to read the length of the popper

491
00:27:11,100 --> 00:27:16,560
from the unknown file is going to

492
00:27:12,960 --> 00:27:18,960
correct that variable mi number five but

493
00:27:16,560 --> 00:27:23,310
this correction does not have a line

494
00:27:18,960 --> 00:27:26,570
number six because because a line number

495
00:27:23,310 --> 00:27:29,070
six at the symmetric read operation is

496
00:27:26,570 --> 00:27:30,899
going to recalculate the length of the

497
00:27:29,070 --> 00:27:34,919
string using string lengths with the

498
00:27:30,900 --> 00:27:37,530
buffer so allein number six it will read

499
00:27:34,920 --> 00:27:40,770
different number of bytes which is

500
00:27:37,530 --> 00:27:44,580
incorrect and that actually makes all

501
00:27:40,770 --> 00:27:56,129
the next symmetric read operation

502
00:27:44,580 --> 00:28:01,370
incorrect so does anyone can can anyone

503
00:27:56,130 --> 00:28:01,370
suggest how to solve this problem

504
00:28:07,759 --> 00:28:18,419
alright so to solve this problem we try

505
00:28:15,600 --> 00:28:20,789
to find the original definition of the

506
00:28:18,419 --> 00:28:24,029
variables and when we need to correct

507
00:28:20,789 --> 00:28:28,889
the variable from the unknown fire we

508
00:28:24,029 --> 00:28:32,330
try to propagate try to correct the

509
00:28:28,889 --> 00:28:35,428
original definition of the variables and

510
00:28:32,330 --> 00:28:39,239
make it like make it propagating

511
00:28:35,429 --> 00:28:40,919
naturally so we call this finding the

512
00:28:39,239 --> 00:28:42,980
original definition and correct the

513
00:28:40,919 --> 00:28:48,869
first definition of the variable

514
00:28:42,980 --> 00:28:50,940
patching and we run the program like

515
00:28:48,869 --> 00:28:55,049
several times and during the execution

516
00:28:50,940 --> 00:28:57,919
of the Dead iterative execution we check

517
00:28:55,049 --> 00:29:01,109
the consistence among the patches and

518
00:28:57,919 --> 00:29:05,789
when the patches are inconsistent

519
00:29:01,109 --> 00:29:07,320
between executions we identify that it

520
00:29:05,789 --> 00:29:12,239
actually indicate the presence of

521
00:29:07,320 --> 00:29:15,658
unexposed field correlation then if that

522
00:29:12,239 --> 00:29:18,359
happens we try to backtrack to the last

523
00:29:15,659 --> 00:29:25,549
patches and then try a different values

524
00:29:18,359 --> 00:29:29,869
until we don't have inconsistent patches

525
00:29:25,549 --> 00:29:32,700
so this is a little bit kind of more

526
00:29:29,869 --> 00:29:35,340
tricky part so if you are interested in

527
00:29:32,700 --> 00:29:39,119
you can refer the paper we have the

528
00:29:35,340 --> 00:29:47,789
algorithms and the examples to these

529
00:29:39,119 --> 00:29:52,109
unexposed correlations and now I'm going

530
00:29:47,789 --> 00:29:57,239
to show how we evaluate 2p to see

531
00:29:52,109 --> 00:30:00,928
programs all right we have evaluated

532
00:29:57,239 --> 00:30:03,989
this system with nine programs five

533
00:30:00,929 --> 00:30:07,669
programs generate files and poor program

534
00:30:03,989 --> 00:30:07,669
generate network messages

535
00:30:10,020 --> 00:30:15,750
and as you can see the program size

536
00:30:12,210 --> 00:30:18,450
varies from really small and a little

537
00:30:15,750 --> 00:30:20,670
bit large like two megabytes this

538
00:30:18,450 --> 00:30:24,380
program size essentially does not

539
00:30:20,670 --> 00:30:28,110
include all the library dynamic library

540
00:30:24,380 --> 00:30:32,250
codes so actually when it closed in on

541
00:30:28,110 --> 00:30:34,439
to the memory is way more bigger than

542
00:30:32,250 --> 00:30:39,990
this one and the unknown fire size we

543
00:30:34,440 --> 00:30:45,240
want to analyze is very from few bites

544
00:30:39,990 --> 00:30:49,020
to a few megabyte and we have measured a

545
00:30:45,240 --> 00:30:52,110
number of iteration and we have two two

546
00:30:49,020 --> 00:30:54,930
parts the first one is method and not

547
00:30:52,110 --> 00:30:58,050
match it this is the case that at the

548
00:30:54,930 --> 00:31:00,450
matched cases actually if we can pick a

549
00:30:58,050 --> 00:31:02,850
right function in the right program then

550
00:31:00,450 --> 00:31:06,810
how many iteration we need to do to type

551
00:31:02,850 --> 00:31:09,480
all the field in the file and your magic

552
00:31:06,810 --> 00:31:11,340
part is we may pick a long program or

553
00:31:09,480 --> 00:31:14,160
even if we pick the correct program

554
00:31:11,340 --> 00:31:17,310
there are a bunch of functions that has

555
00:31:14,160 --> 00:31:19,980
write operation so let's say we just

556
00:31:17,310 --> 00:31:22,560
pick wrong program and wrong functions

557
00:31:19,980 --> 00:31:24,480
then how many iteration we need to do to

558
00:31:22,560 --> 00:31:30,179
know that this we're not going to help

559
00:31:24,480 --> 00:31:36,090
us so as you can see the magic part when

560
00:31:30,180 --> 00:31:39,360
is finish it successfully is usually ten

561
00:31:36,090 --> 00:31:44,939
times or 20 times less always less than

562
00:31:39,360 --> 00:31:48,000
50 times and your magic part is usually

563
00:31:44,940 --> 00:31:50,880
zero because you can imagine that most

564
00:31:48,000 --> 00:31:53,310
of the fires or most open it and let own

565
00:31:50,880 --> 00:31:55,530
messages they have their signatures like

566
00:31:53,310 --> 00:32:01,710
constant number telling that this

567
00:31:55,530 --> 00:32:04,500
message is this type and when we compare

568
00:32:01,710 --> 00:32:07,620
or try to execute and when we encounter

569
00:32:04,500 --> 00:32:10,950
those kind of things and then we can

570
00:32:07,620 --> 00:32:12,959
usually just immediately fail to

571
00:32:10,950 --> 00:32:15,600
transform the execution so this is

572
00:32:12,960 --> 00:32:17,850
mostly just zero means that at the first

573
00:32:15,600 --> 00:32:22,530
execution we immediately know that this

574
00:32:17,850 --> 00:32:24,000
function will not help us and the number

575
00:32:22,530 --> 00:32:29,700
of type field or

576
00:32:24,000 --> 00:32:31,890
out of number of field means how many

577
00:32:29,700 --> 00:32:33,810
people can accurately type in the

578
00:32:31,890 --> 00:32:40,890
unknown data file or network messages

579
00:32:33,810 --> 00:32:44,820
and the less time means just running

580
00:32:40,890 --> 00:32:47,610
time of our system and this running time

581
00:32:44,820 --> 00:32:50,610
actually include all the iterations we

582
00:32:47,610 --> 00:32:55,040
have so just running one execution

583
00:32:50,610 --> 00:32:58,889
actually doesn't take a lot of time and

584
00:32:55,040 --> 00:33:05,100
the coverage and the past number of

585
00:32:58,890 --> 00:33:07,470
paths explored is like how many

586
00:33:05,100 --> 00:33:10,260
instructions are covered by the first

587
00:33:07,470 --> 00:33:12,300
executing x-force engine and the number

588
00:33:10,260 --> 00:33:16,170
of paths explored by the export engine

589
00:33:12,300 --> 00:33:17,909
too and as you can see we we can cover

590
00:33:16,170 --> 00:33:24,990
like plenty of the instructions and

591
00:33:17,910 --> 00:33:29,280
plenty of paths that can identify the

592
00:33:24,990 --> 00:33:32,220
producer executions and here I let me

593
00:33:29,280 --> 00:33:36,840
explain a few case studies we have gone

594
00:33:32,220 --> 00:33:39,510
through we have a steganography program

595
00:33:36,840 --> 00:33:41,850
that actually embed a secret text in the

596
00:33:39,510 --> 00:33:46,230
image by changing the least significant

597
00:33:41,850 --> 00:33:50,520
bit of the each pixel in the image so

598
00:33:46,230 --> 00:33:52,980
here our setting is we have an image

599
00:33:50,520 --> 00:33:55,770
that potentially or not potentially

600
00:33:52,980 --> 00:33:57,360
contain a hidden message or not so we

601
00:33:55,770 --> 00:34:01,170
don't know whether this is actually

602
00:33:57,360 --> 00:34:03,419
containing a text message or not and by

603
00:34:01,170 --> 00:34:06,180
just looking at is really difficult to

604
00:34:03,420 --> 00:34:08,940
tell because even though the image

605
00:34:06,180 --> 00:34:10,860
contains the secret image it does not

606
00:34:08,940 --> 00:34:14,360
really change a lot it just change the

607
00:34:10,860 --> 00:34:14,360
leasing significant feed

608
00:34:18,370 --> 00:34:29,199
so all right and and also we have some

609
00:34:27,250 --> 00:34:32,110
set of potential programs we don't know

610
00:34:29,199 --> 00:34:35,620
what kind of program exactly can inject

611
00:34:32,110 --> 00:34:38,260
the hidden message to the image so we

612
00:34:35,620 --> 00:34:44,230
have set of programs that may inject or

613
00:34:38,260 --> 00:34:48,880
not so we use these two one image file

614
00:34:44,230 --> 00:34:51,909
and set up programs and feed them to the

615
00:34:48,880 --> 00:34:53,680
pit to see and whether it can generate a

616
00:34:51,909 --> 00:34:56,580
transform the consumer execution or not

617
00:34:53,679 --> 00:35:00,549
here actually we can have two different

618
00:34:56,580 --> 00:35:05,650
outcomes if that image has the secret

619
00:35:00,550 --> 00:35:08,380
message then alright if that image has

620
00:35:05,650 --> 00:35:10,660
the secret image and if one of the

621
00:35:08,380 --> 00:35:13,900
potential producer actually can inject a

622
00:35:10,660 --> 00:35:16,569
secret image to the image a secret text

623
00:35:13,900 --> 00:35:19,060
to the image then we can we will get the

624
00:35:16,570 --> 00:35:23,290
correct transformed consumer execution

625
00:35:19,060 --> 00:35:25,120
otherwise we are not able to transform

626
00:35:23,290 --> 00:35:30,070
the producer executions to the consumer

627
00:35:25,120 --> 00:35:31,690
execution and once we get the

628
00:35:30,070 --> 00:35:34,360
transformed consumer execution we can

629
00:35:31,690 --> 00:35:38,200
simply apply the tane analysis

630
00:35:34,360 --> 00:35:41,340
techniques to understand like first what

631
00:35:38,200 --> 00:35:53,529
kind of texture actually hidden or and

632
00:35:41,340 --> 00:35:55,960
how they hide the text and the their

633
00:35:53,530 --> 00:36:01,110
internal structures and the types of the

634
00:35:55,960 --> 00:36:06,250
internal structures all right so if

635
00:36:01,110 --> 00:36:10,060
there is a hidden messages here at our p

636
00:36:06,250 --> 00:36:14,200
2 c 2 p 2 c 2 can identify these hidden

637
00:36:10,060 --> 00:36:17,529
images with data structures the mario

638
00:36:14,200 --> 00:36:20,379
actually use as well as how they embed

639
00:36:17,530 --> 00:36:24,790
the individual field type information

640
00:36:20,380 --> 00:36:28,720
and if this image is just benign it

641
00:36:24,790 --> 00:36:30,860
doesn't have the secret text then we are

642
00:36:28,720 --> 00:36:33,709
not able to

643
00:36:30,860 --> 00:36:35,360
drive I transform the consumer xscape a

644
00:36:33,710 --> 00:36:38,990
produce execution to the consumer

645
00:36:35,360 --> 00:36:40,760
execution so even though we are not sure

646
00:36:38,990 --> 00:36:44,020
whether the image contain a hidden

647
00:36:40,760 --> 00:36:47,780
message or not we are still we can still

648
00:36:44,020 --> 00:36:55,490
get meaningful information out of the P

649
00:36:47,780 --> 00:36:58,430
to see and hear another case study we

650
00:36:55,490 --> 00:37:00,529
use the Z boat which is Mario that

651
00:36:58,430 --> 00:37:02,810
communicate as through the networks and

652
00:37:00,530 --> 00:37:07,940
it generate different messages depending

653
00:37:02,810 --> 00:37:10,160
on the situation for example sometimes

654
00:37:07,940 --> 00:37:11,810
he generated try to send local

655
00:37:10,160 --> 00:37:14,470
information to other servers and

656
00:37:11,810 --> 00:37:18,320
sometimes it just wait and doing nothing

657
00:37:14,470 --> 00:37:20,480
so our goal is to understand previously

658
00:37:18,320 --> 00:37:25,430
generated message by this program and

659
00:37:20,480 --> 00:37:28,190
it's already sent to other computers so

660
00:37:25,430 --> 00:37:30,500
we have we encountered the prop right

661
00:37:28,190 --> 00:37:35,060
here we have two consecutive messages

662
00:37:30,500 --> 00:37:37,040
that we want to analyze and we have we

663
00:37:35,060 --> 00:37:39,140
encounter a problem that the program

664
00:37:37,040 --> 00:37:41,860
actually does not generate messages

665
00:37:39,140 --> 00:37:44,540
without input so when I try to just

666
00:37:41,860 --> 00:37:49,340
execute this program this program just

667
00:37:44,540 --> 00:37:52,730
run and keep doing nothing so we use

668
00:37:49,340 --> 00:37:59,030
experts to try to try to make this

669
00:37:52,730 --> 00:38:00,860
program generate something and we we

670
00:37:59,030 --> 00:38:03,080
identify that it actually generates

671
00:38:00,860 --> 00:38:07,940
something but it January different

672
00:38:03,080 --> 00:38:10,009
messages so here we have unknown

673
00:38:07,940 --> 00:38:12,440
messages we want to analyze and the

674
00:38:10,010 --> 00:38:16,310
messages generated by the first

675
00:38:12,440 --> 00:38:20,030
execution and I marked different part

676
00:38:16,310 --> 00:38:23,000
with the red boxes and as you can see

677
00:38:20,030 --> 00:38:25,640
all the strings are different and we

678
00:38:23,000 --> 00:38:31,610
have one integer difference between

679
00:38:25,640 --> 00:38:35,569
these two messages so we run DP to see

680
00:38:31,610 --> 00:38:39,440
to generate a idea consumer execution

681
00:38:35,570 --> 00:38:41,510
and this gives us to information that is

682
00:38:39,440 --> 00:38:43,550
first the first message actually

683
00:38:41,510 --> 00:38:44,539
contains the size of the second message

684
00:38:43,550 --> 00:38:47,569
as you can see

685
00:38:44,539 --> 00:38:51,410
a at the 25 actually meaning that the

686
00:38:47,569 --> 00:38:54,049
whole length of the second message and

687
00:38:51,410 --> 00:38:58,489
the second message contains computer

688
00:38:54,049 --> 00:39:01,880
name and the operating system version

689
00:38:58,489 --> 00:39:09,079
information and one key values from the

690
00:39:01,880 --> 00:39:12,499
registry key so we type this information

691
00:39:09,079 --> 00:39:18,319
by painting all the standard windows API

692
00:39:12,499 --> 00:39:32,178
so after we won p to see this is kind of

693
00:39:18,319 --> 00:39:35,529
what we get out of the program and so we

694
00:39:32,179 --> 00:39:40,819
have observe some few interesting things

695
00:39:35,529 --> 00:39:42,949
during our evaluation first of all is it

696
00:39:40,819 --> 00:39:44,739
was actually quite interesting that the

697
00:39:42,949 --> 00:39:47,269
number of iteration to find correct

698
00:39:44,739 --> 00:39:50,390
transformation is not a large because

699
00:39:47,269 --> 00:39:52,488
when I started this project I was

700
00:39:50,390 --> 00:39:55,669
thinking that it maybe take a bunch of a

701
00:39:52,489 --> 00:39:58,309
bunch of times it may run forever but in

702
00:39:55,669 --> 00:40:00,319
most cases the program dependency is

703
00:39:58,309 --> 00:40:05,449
already exposed and we don't see a lot

704
00:40:00,319 --> 00:40:08,089
of unexposed weird correlations and the

705
00:40:05,449 --> 00:40:10,339
second we can precisely identify all the

706
00:40:08,089 --> 00:40:14,659
field in the Cuban fires or messages

707
00:40:10,339 --> 00:40:17,949
with few exceptions first one program

708
00:40:14,659 --> 00:40:22,939
code MD has a lot of floating point

709
00:40:17,949 --> 00:40:26,079
instructions and the net or more is wind

710
00:40:22,939 --> 00:40:29,479
peeing in fuji they have some

711
00:40:26,079 --> 00:40:32,569
non-standard api uses and the fears are

712
00:40:29,479 --> 00:40:35,029
tainted by these non-standard api's but

713
00:40:32,569 --> 00:40:37,519
i want to point out that this limitation

714
00:40:35,029 --> 00:40:38,869
is not actually from the pit to see

715
00:40:37,519 --> 00:40:42,428
these are just imitating of

716
00:40:38,869 --> 00:40:45,229
implementation of pain analysis engine

717
00:40:42,429 --> 00:40:49,189
so we could improve cane analysis engine

718
00:40:45,229 --> 00:40:52,698
to make it better and third we find

719
00:40:49,189 --> 00:40:55,279
found out that transform the consumer

720
00:40:52,699 --> 00:40:57,950
execution sometimes recognize more fear

721
00:40:55,279 --> 00:41:00,950
than some typical consumers

722
00:40:57,950 --> 00:41:03,710
for example mp3 gain is a program that

723
00:41:00,950 --> 00:41:07,819
can calculate something and inject new

724
00:41:03,710 --> 00:41:12,770
tag into the mp3 file and one of the

725
00:41:07,820 --> 00:41:15,650
commercial famous m.tech reader mp3 tag

726
00:41:12,770 --> 00:41:19,369
reader program which is mp3 tag cannot

727
00:41:15,650 --> 00:41:22,790
actually recognize this field so I can

728
00:41:19,369 --> 00:41:26,450
say sometimes it's even even though you

729
00:41:22,790 --> 00:41:28,579
have the consumers it is better to

730
00:41:26,450 --> 00:41:31,069
transform the producer execution to

731
00:41:28,579 --> 00:41:38,990
consumer execution to understand what it

732
00:41:31,070 --> 00:41:41,119
actually generated and to conclude we

733
00:41:38,990 --> 00:41:42,799
have developed p to see which is an

734
00:41:41,119 --> 00:41:47,990
output from a reverse engineering tool

735
00:41:42,800 --> 00:41:50,119
and we it understands the structure and

736
00:41:47,990 --> 00:41:54,529
meaning of the unknown failure messages

737
00:41:50,119 --> 00:41:56,900
and we don't really require consumers

738
00:41:54,530 --> 00:41:59,420
and any inputs to drive the producer

739
00:41:56,900 --> 00:42:01,220
executions we just take the producer

740
00:41:59,420 --> 00:42:03,369
programs and transform it to the

741
00:42:01,220 --> 00:42:08,000
consumer we don't need inputs and the

742
00:42:03,369 --> 00:42:09,859
kiai kiai kept it behind this tool is we

743
00:42:08,000 --> 00:42:12,280
transform a produced execution to the

744
00:42:09,859 --> 00:42:15,310
ideal consumer execution sometimes it

745
00:42:12,280 --> 00:42:20,150
recognize more pure than typical

746
00:42:15,310 --> 00:42:22,670
consumers and we show that it is highly

747
00:42:20,150 --> 00:42:24,589
accurate and we don't need to know the

748
00:42:22,670 --> 00:42:27,589
exact producers so you can just have

749
00:42:24,589 --> 00:42:35,619
settled producers and you don't even

750
00:42:27,589 --> 00:42:41,920
know how to run these programs to write

751
00:42:35,619 --> 00:42:41,920
so any question

752
00:42:53,050 --> 00:42:59,100
so if I said everybody get the idea

