1
00:00:20,900 --> 00:00:25,650
good afternoon welcome to the serious

2
00:00:23,759 --> 00:00:27,990
security seminar it's my great pleasure

3
00:00:25,650 --> 00:00:30,659
to introduce today's speaker professor

4
00:00:27,990 --> 00:00:32,339
Massey at higher who joined the computer

5
00:00:30,660 --> 00:00:38,339
science department as a faculty member

6
00:00:32,340 --> 00:00:40,379
last year he received his PhD from ETH

7
00:00:38,339 --> 00:00:43,260
and before joining Purdue he was a

8
00:00:40,379 --> 00:00:46,489
postdoc at UC Berkeley and his research

9
00:00:43,260 --> 00:00:50,339
interests are in software security

10
00:00:46,489 --> 00:00:51,959
especially well I'll kind of topic in

11
00:00:50,339 --> 00:00:54,449
software security especially binary

12
00:00:51,960 --> 00:00:57,600
security and today he will talk about

13
00:00:54,449 --> 00:01:00,689
the code pointer integrity thanks for

14
00:00:57,600 --> 00:01:02,729
the introduction hi folks the work I'm

15
00:01:00,689 --> 00:01:05,129
going to present today is joint work

16
00:01:02,729 --> 00:01:08,280
with valo damier quit sets off Laszlo

17
00:01:05,129 --> 00:01:11,010
shakira's George gondia our shaker and

18
00:01:08,280 --> 00:01:13,380
Dawn songs while most of the people were

19
00:01:11,010 --> 00:01:16,259
at Berkeley and different places in

20
00:01:13,380 --> 00:01:17,699
between most of the awesome work and

21
00:01:16,259 --> 00:01:19,830
implementation work has been done by the

22
00:01:17,700 --> 00:01:24,869
students so all credit goes to them all

23
00:01:19,830 --> 00:01:28,200
the bad jokes are are my fault so let me

24
00:01:24,869 --> 00:01:31,219
start with what is the reality that we

25
00:01:28,200 --> 00:01:34,289
are facing as security researchers and

26
00:01:31,219 --> 00:01:36,749
programmers every every day it is an

27
00:01:34,289 --> 00:01:39,420
ugly planet out there it is a buck

28
00:01:36,749 --> 00:01:42,179
planet there there are way too many bugs

29
00:01:39,420 --> 00:01:43,950
in software out there and there's no way

30
00:01:42,179 --> 00:01:47,729
we're going to be able to fix all of

31
00:01:43,950 --> 00:01:49,880
them while finding and fixing bugs and

32
00:01:47,729 --> 00:01:52,350
vulnerabilities is important it

33
00:01:49,880 --> 00:01:53,880
unfortunately does not scale and we will

34
00:01:52,350 --> 00:01:55,259
never be able to find all the

35
00:01:53,880 --> 00:01:57,449
vulnerabilities that are out there and

36
00:01:55,259 --> 00:02:00,240
there's always that one we are big bug

37
00:01:57,450 --> 00:02:03,990
lurking behind us waiting to to catch us

38
00:02:00,240 --> 00:02:05,939
unaware also we are focusing on memory

39
00:02:03,990 --> 00:02:07,889
corruption and memory corruption is

40
00:02:05,939 --> 00:02:10,619
abundant it's everywhere if you just

41
00:02:07,889 --> 00:02:13,319
look at the last couple of years and we

42
00:02:10,619 --> 00:02:17,459
look at the security vulnerabilities

43
00:02:13,319 --> 00:02:20,130
that were published as a CVS just in the

44
00:02:17,459 --> 00:02:23,069
area of control flow hi check attacks we

45
00:02:20,130 --> 00:02:25,380
see that there's a huge amount of these

46
00:02:23,069 --> 00:02:27,720
vulnerabilities that allow attackers to

47
00:02:25,380 --> 00:02:30,359
actually completely control your

48
00:02:27,720 --> 00:02:33,030
software and your computer so starting

49
00:02:30,360 --> 00:02:34,000
in two thousand for the average amount

50
00:02:33,030 --> 00:02:36,940
of control full height

51
00:02:34,000 --> 00:02:40,210
gatech attacks was continuously

52
00:02:36,940 --> 00:02:43,630
increasing until the right hand side of

53
00:02:40,210 --> 00:02:47,860
the figure for 2013 and we just picked a

54
00:02:43,630 --> 00:02:50,709
couple off of software pieces so one of

55
00:02:47,860 --> 00:02:53,380
them is Acrobat that a many people use

56
00:02:50,709 --> 00:02:56,410
to display PDF software it's full of

57
00:02:53,380 --> 00:02:59,740
vulnerabilities but also browsers like

58
00:02:56,410 --> 00:03:01,780
Firefox or Internet Explorer have had a

59
00:02:59,740 --> 00:03:04,180
large amount of these vulnerabilities

60
00:03:01,780 --> 00:03:06,670
that allowed an attacker to compromise

61
00:03:04,180 --> 00:03:09,420
your your software security but also

62
00:03:06,670 --> 00:03:11,619
operating systems like OS X and Linux

63
00:03:09,420 --> 00:03:14,890
had a couple of failures that allow

64
00:03:11,620 --> 00:03:18,100
people to exploit them and attack your

65
00:03:14,890 --> 00:03:20,410
software systems so it actually looks

66
00:03:18,100 --> 00:03:21,880
like as if you are being overrun by all

67
00:03:20,410 --> 00:03:23,829
these bugs that are out there and there

68
00:03:21,880 --> 00:03:25,660
is no way how we can we can protect

69
00:03:23,830 --> 00:03:27,760
ourselves against them we have this

70
00:03:25,660 --> 00:03:30,100
little fortress of protection where

71
00:03:27,760 --> 00:03:31,870
we're trying to write safe code but

72
00:03:30,100 --> 00:03:35,320
there are just too many bugs creeping in

73
00:03:31,870 --> 00:03:37,000
and if you just look Oh what happened in

74
00:03:35,320 --> 00:03:41,310
the last couple of months there was

75
00:03:37,000 --> 00:03:44,860
heartbleed which allowed people to read

76
00:03:41,310 --> 00:03:47,200
Albans of private data from from our

77
00:03:44,860 --> 00:03:49,269
computing systems there was a shell

78
00:03:47,200 --> 00:03:53,109
shock which allowed arbitrary command

79
00:03:49,269 --> 00:03:54,670
execution on a huge amount of servers

80
00:03:53,110 --> 00:03:56,080
and there are still many embedded

81
00:03:54,670 --> 00:03:58,298
systems out there that are not patched

82
00:03:56,080 --> 00:03:59,769
against this vulnerability and also more

83
00:03:58,299 --> 00:04:02,850
recently there was the ghost

84
00:03:59,769 --> 00:04:07,390
vulnerability which allowed people to

85
00:04:02,850 --> 00:04:10,030
arbitrary corrupt data in in processes

86
00:04:07,390 --> 00:04:12,429
by controlling a couple of DNS queries

87
00:04:10,030 --> 00:04:16,478
and allowed them to then exploit and get

88
00:04:12,430 --> 00:04:18,489
to arbitrary code execution so at the

89
00:04:16,478 --> 00:04:22,330
basis of all these vulnerability there's

90
00:04:18,488 --> 00:04:24,640
two the simple memory safety violation

91
00:04:22,330 --> 00:04:28,060
and let's look at what the memory safety

92
00:04:24,640 --> 00:04:31,240
violation is it all starts with a form

93
00:04:28,060 --> 00:04:34,440
of invalid dereference so we are doing

94
00:04:31,240 --> 00:04:37,090
some kind of pointer manipulation and

95
00:04:34,440 --> 00:04:38,830
reading from some part of memory that we

96
00:04:37,090 --> 00:04:41,409
shouldn't read so something goes wrong

97
00:04:38,830 --> 00:04:43,630
when we dereference the pointer and it

98
00:04:41,410 --> 00:04:46,240
can either be a dangling pointer which

99
00:04:43,630 --> 00:04:47,569
is a temporal memory safety violation

100
00:04:46,240 --> 00:04:49,369
where

101
00:04:47,569 --> 00:04:52,520
pointer initially pointed to a valid

102
00:04:49,369 --> 00:04:57,610
object but then that object was

103
00:04:52,520 --> 00:05:02,318
deallocated or returned with a free but

104
00:04:57,610 --> 00:05:05,779
the pointer itself was not removed or

105
00:05:02,319 --> 00:05:07,580
zeroed out and while keeping this

106
00:05:05,779 --> 00:05:10,369
pointer around is perfectly safe

107
00:05:07,580 --> 00:05:12,589
accessing the pointer leads to a memory

108
00:05:10,369 --> 00:05:13,849
safety violation and the second kind of

109
00:05:12,589 --> 00:05:16,249
memory safety violations are

110
00:05:13,849 --> 00:05:21,680
out-of-bounds pointers which are spatial

111
00:05:16,249 --> 00:05:24,740
kind of safety validations so initially

112
00:05:21,680 --> 00:05:27,409
the pointer points to a valid object and

113
00:05:24,740 --> 00:05:30,289
due to some point the computation the

114
00:05:27,409 --> 00:05:32,180
point is moved along for example if you

115
00:05:30,289 --> 00:05:34,430
are walking through an array step by

116
00:05:32,180 --> 00:05:36,709
step and you are incrementing the

117
00:05:34,430 --> 00:05:38,419
pointer past the arrow array this is an

118
00:05:36,709 --> 00:05:41,360
out-of-balance violation where you're

119
00:05:38,419 --> 00:05:45,080
certainly accessing data that is no

120
00:05:41,360 --> 00:05:51,469
longer in bounds and thereby it results

121
00:05:45,080 --> 00:05:55,240
in a memory safety violation so it is

122
00:05:51,469 --> 00:05:58,729
only a actual violation if the actual

123
00:05:55,240 --> 00:06:01,339
invalid pointer is read written or freed

124
00:05:58,729 --> 00:06:02,990
again so as long as the pointer just

125
00:06:01,339 --> 00:06:05,899
remains in the program and we are not

126
00:06:02,990 --> 00:06:08,990
using it everything is safe according to

127
00:06:05,899 --> 00:06:10,399
the C and C++ language semantics but as

128
00:06:08,990 --> 00:06:12,860
soon as we dereference or use that

129
00:06:10,399 --> 00:06:15,860
pointer for some other computation the

130
00:06:12,860 --> 00:06:18,680
memory corruption actually happens so

131
00:06:15,860 --> 00:06:20,990
when looking at defense mechanisms we

132
00:06:18,680 --> 00:06:23,089
always have to define a threat threat

133
00:06:20,990 --> 00:06:26,689
model and the threat model we are using

134
00:06:23,089 --> 00:06:29,659
for this talk is as follows we assume a

135
00:06:26,689 --> 00:06:32,029
very powerful attacker model in that the

136
00:06:29,659 --> 00:06:34,369
attacker can read and write arbitrary

137
00:06:32,029 --> 00:06:37,610
data so all the data on the heap on the

138
00:06:34,369 --> 00:06:39,289
stack or in any global place is allowed

139
00:06:37,610 --> 00:06:41,990
to be read by the attacker and the

140
00:06:39,289 --> 00:06:43,729
attacker can also read the code so the

141
00:06:41,990 --> 00:06:46,879
attacker can try to learn secrets from

142
00:06:43,729 --> 00:06:49,279
the code what the attacker cannot do is

143
00:06:46,879 --> 00:06:51,589
modify the program code so the attacker

144
00:06:49,279 --> 00:06:53,569
cannot inject new code and also the pro

145
00:06:51,589 --> 00:06:57,289
the attacker cannot influence program

146
00:06:53,569 --> 00:07:00,199
loading so this is actually a very

147
00:06:57,289 --> 00:07:01,310
realistic attacker model because if you

148
00:07:00,199 --> 00:07:03,320
assume generic

149
00:07:01,310 --> 00:07:05,710
memory safety violations that's exactly

150
00:07:03,320 --> 00:07:08,180
what the attacker can do and if you are

151
00:07:05,710 --> 00:07:10,370
working in a multi-threaded environment

152
00:07:08,180 --> 00:07:12,290
so just imagine the apache process

153
00:07:10,370 --> 00:07:15,440
spawning a couple of workers threats you

154
00:07:12,290 --> 00:07:17,810
can repeat the memory safety violation

155
00:07:15,440 --> 00:07:19,969
and thereby get arbitrary memory access

156
00:07:17,810 --> 00:07:21,500
and read and write the complete memory

157
00:07:19,970 --> 00:07:24,080
space of the application and thereby

158
00:07:21,500 --> 00:07:26,870
compromised it or set up the attack that

159
00:07:24,080 --> 00:07:28,550
you actually want to carry out so the

160
00:07:26,870 --> 00:07:30,350
control flow high check attacks that we

161
00:07:28,550 --> 00:07:33,170
are actually talking about looks as

162
00:07:30,350 --> 00:07:35,660
follows here's a simple piece of of see

163
00:07:33,170 --> 00:07:38,510
like code that we are looking at as a

164
00:07:35,660 --> 00:07:40,550
motivating example in the first line

165
00:07:38,510 --> 00:07:42,830
we're defining a function pointer that

166
00:07:40,550 --> 00:07:45,020
is later used at the end of the program

167
00:07:42,830 --> 00:07:46,729
and there's some computation between the

168
00:07:45,020 --> 00:07:48,740
definition of the function pointer and

169
00:07:46,730 --> 00:07:51,350
the actual use of the function pointer

170
00:07:48,740 --> 00:07:54,500
so there's a some pointer cue that we

171
00:07:51,350 --> 00:07:58,670
assign from a valid buffer plus some

172
00:07:54,500 --> 00:08:00,680
attacker controlled input after that we

173
00:07:58,670 --> 00:08:02,390
at one point in time via assign the

174
00:08:00,680 --> 00:08:04,640
function pointer but later on there's

175
00:08:02,390 --> 00:08:07,400
some additional manipulation of the

176
00:08:04,640 --> 00:08:11,479
pointer q which is the second attacker

177
00:08:07,400 --> 00:08:13,489
controlled value so in a control flow

178
00:08:11,480 --> 00:08:16,010
high-tech attack the attacker can use

179
00:08:13,490 --> 00:08:19,420
these abstract steps to actually get

180
00:08:16,010 --> 00:08:24,080
control over the executed application by

181
00:08:19,420 --> 00:08:27,080
initially redirecting the pointer from

182
00:08:24,080 --> 00:08:29,419
the valid location so initially the

183
00:08:27,080 --> 00:08:31,400
pointer or the programmer intended q2

184
00:08:29,420 --> 00:08:33,800
always point into the buffer but by

185
00:08:31,400 --> 00:08:38,030
supplying additional values the attacker

186
00:08:33,799 --> 00:08:40,189
can make the pointer point into to the

187
00:08:38,030 --> 00:08:41,870
function pointer itself so the attacker

188
00:08:40,190 --> 00:08:44,450
has to know the correct offset as a

189
00:08:41,870 --> 00:08:46,820
first sap off attack and it's the second

190
00:08:44,450 --> 00:08:48,980
step of an attack the attacker overrides

191
00:08:46,820 --> 00:08:50,600
the function pointer to an attacker

192
00:08:48,980 --> 00:08:53,870
controlled gadget which will then be

193
00:08:50,600 --> 00:08:55,490
used to exploit the behavior and

194
00:08:53,870 --> 00:08:57,910
redirect the control flow off the up

195
00:08:55,490 --> 00:09:02,480
like application to an attacker intended

196
00:08:57,910 --> 00:09:05,600
gadget and as a search step the function

197
00:09:02,480 --> 00:09:07,610
pointer is actually must be used by the

198
00:09:05,600 --> 00:09:09,080
application only then will it actually

199
00:09:07,610 --> 00:09:14,180
be dereferenced and the bad stuff

200
00:09:09,080 --> 00:09:15,290
happens so what about existing defenses

201
00:09:14,180 --> 00:09:17,300
that are out there

202
00:09:15,290 --> 00:09:20,089
what do we have to protect our software

203
00:09:17,300 --> 00:09:22,758
against these kind of vulnerabilities so

204
00:09:20,089 --> 00:09:25,850
for one there's a data execution

205
00:09:22,759 --> 00:09:29,449
prevention which was introduced in 2006

206
00:09:25,850 --> 00:09:32,060
which roughly are protects against code

207
00:09:29,449 --> 00:09:33,979
injection attack so before that before

208
00:09:32,060 --> 00:09:36,560
data execution prevention attackers were

209
00:09:33,980 --> 00:09:38,870
able to inject new executable code into

210
00:09:36,560 --> 00:09:41,000
process processes and then execute that

211
00:09:38,870 --> 00:09:43,009
code by redirecting the control flow to

212
00:09:41,000 --> 00:09:45,410
that injected code so data execution

213
00:09:43,009 --> 00:09:47,540
prevention added a couple of bits in

214
00:09:45,410 --> 00:09:49,310
hardware to protect against this and

215
00:09:47,540 --> 00:09:51,980
keeps additional state if a memory page

216
00:09:49,310 --> 00:09:53,839
contains either code or data and allows

217
00:09:51,980 --> 00:09:55,639
us to distinguish between code and data

218
00:09:53,839 --> 00:09:58,519
and protects against all code injection

219
00:09:55,639 --> 00:10:00,910
attacks but code reuse attacks will

220
00:09:58,519 --> 00:10:04,399
remain and there's some additional

221
00:10:00,910 --> 00:10:06,529
protection top of it so there's address

222
00:10:04,399 --> 00:10:09,440
space layout randomization that is a

223
00:10:06,529 --> 00:10:11,660
probabilistic defense to shuffles the

224
00:10:09,440 --> 00:10:14,690
memory areas or memory segments that are

225
00:10:11,660 --> 00:10:18,560
used in the process every time a process

226
00:10:14,690 --> 00:10:22,850
is started so this protects against some

227
00:10:18,560 --> 00:10:25,099
form of a pre-compiled locations and

228
00:10:22,850 --> 00:10:27,680
verdi attacker knows murder current

229
00:10:25,100 --> 00:10:30,319
location is so the attacker first needs

230
00:10:27,680 --> 00:10:35,029
an information leak to recover the

231
00:10:30,319 --> 00:10:38,209
actual pointers and then use those in a

232
00:10:35,029 --> 00:10:40,579
second step of the attack and last but

233
00:10:38,209 --> 00:10:45,319
not least we have stack Canaries which

234
00:10:40,579 --> 00:10:47,989
are a another probabilistic defense

235
00:10:45,319 --> 00:10:50,510
mechanism that protect the stack against

236
00:10:47,990 --> 00:10:53,589
continuous buffer overrides buffer

237
00:10:50,510 --> 00:10:56,180
overflows on the stack frames

238
00:10:53,589 --> 00:10:58,970
unfortunately as we've seen before are

239
00:10:56,180 --> 00:11:02,000
in the motivational slide all of these

240
00:10:58,970 --> 00:11:04,790
defenses can be mitigated and there are

241
00:11:02,000 --> 00:11:07,790
many ways around it if you would like to

242
00:11:04,790 --> 00:11:10,519
know more about this there's a an

243
00:11:07,790 --> 00:11:13,550
earlier serious talk about all the

244
00:11:10,519 --> 00:11:16,579
different steps of of a software attack

245
00:11:13,550 --> 00:11:20,329
and there are some nice papers out there

246
00:11:16,579 --> 00:11:22,819
as well that I reference so you might

247
00:11:20,329 --> 00:11:25,459
say memory safety to the rescue right if

248
00:11:22,819 --> 00:11:27,860
you just move away from these unsafe

249
00:11:25,459 --> 00:11:29,239
languages like C and C++ and implement

250
00:11:27,860 --> 00:11:32,930
all our software and safely

251
00:11:29,240 --> 00:11:35,540
languages will be safe right so people

252
00:11:32,930 --> 00:11:39,010
proposed a large set of safe languages

253
00:11:35,540 --> 00:11:44,449
so there's there's pison there's Java

254
00:11:39,010 --> 00:11:50,360
there C sharp and they're Swift right so

255
00:11:44,450 --> 00:11:52,640
we've solved the problem now while these

256
00:11:50,360 --> 00:11:54,980
languages themselves enforce memory

257
00:11:52,640 --> 00:11:59,300
safety for a program and do not allow an

258
00:11:54,980 --> 00:12:02,570
attacker to gain code execution

259
00:11:59,300 --> 00:12:06,170
capabilities um there's a slight caveat

260
00:12:02,570 --> 00:12:11,120
that we have to look at so let's look at

261
00:12:06,170 --> 00:12:14,529
a specific example um when we look at

262
00:12:11,120 --> 00:12:16,970
Dropbox Dropbox has a has a small

263
00:12:14,529 --> 00:12:18,920
component that runs on your on your

264
00:12:16,970 --> 00:12:21,140
system that is implementing three

265
00:12:18,920 --> 00:12:24,260
roughly 3,000 lines of code to download

266
00:12:21,140 --> 00:12:25,880
files and and synchronize files so it's

267
00:12:24,260 --> 00:12:27,980
like three thousand lines of memory safe

268
00:12:25,880 --> 00:12:31,279
language right so nothing can ever

269
00:12:27,980 --> 00:12:32,959
happen or no memory safety violation can

270
00:12:31,279 --> 00:12:36,200
ever happen but while executing this

271
00:12:32,959 --> 00:12:38,359
code right so why these three thousand

272
00:12:36,200 --> 00:12:41,720
lines of code are safe there's more

273
00:12:38,360 --> 00:12:44,180
software be nice it on the stack and the

274
00:12:41,720 --> 00:12:47,480
Python runtime is implemented in 500

275
00:12:44,180 --> 00:12:49,160
lines of code guess what C code right

276
00:12:47,480 --> 00:12:50,750
which can be full of memory bugs and

277
00:12:49,160 --> 00:12:52,880
there have been several vulnerabilities

278
00:12:50,750 --> 00:12:55,520
in there but it doesn't end there right

279
00:12:52,880 --> 00:12:58,880
behind a below the pison runtime there's

280
00:12:55,520 --> 00:13:00,319
the C library which has roughly two and

281
00:12:58,880 --> 00:13:02,720
a half million lines of code all

282
00:13:00,320 --> 00:13:04,790
implemented in C and the ghost

283
00:13:02,720 --> 00:13:07,130
vulnerability was a prime example that

284
00:13:04,790 --> 00:13:10,670
these libraries are still full of bugs

285
00:13:07,130 --> 00:13:13,459
and bugs that have not been found in the

286
00:13:10,670 --> 00:13:15,319
last 15 years but if you go deeper than

287
00:13:13,459 --> 00:13:17,060
that there's also the Linux kernel of

288
00:13:15,320 --> 00:13:20,180
ruffler that consists of roughly 60

289
00:13:17,060 --> 00:13:22,959
million lines of of C code so why we do

290
00:13:20,180 --> 00:13:25,160
have some memory safe languages the

291
00:13:22,959 --> 00:13:27,050
majority of software that we are running

292
00:13:25,160 --> 00:13:30,800
on current systems has been implemented

293
00:13:27,050 --> 00:13:33,740
on top of C or C++ so while memory

294
00:13:30,800 --> 00:13:36,020
safety our memory safe languages are a

295
00:13:33,740 --> 00:13:37,670
goal and we would like to get there we

296
00:13:36,020 --> 00:13:40,400
are unfortunately not yet there and

297
00:13:37,670 --> 00:13:42,920
there's a large part of the of the code

298
00:13:40,400 --> 00:13:43,189
that remains unsafe so if you look at

299
00:13:42,920 --> 00:13:49,939
the

300
00:13:43,190 --> 00:13:56,480
oh oh yeah the defense back in the magic

301
00:13:49,940 --> 00:13:57,710
boy the colonel the colonel has a SLR so

302
00:13:56,480 --> 00:14:01,370
the colonel uses some form of address

303
00:13:57,710 --> 00:14:05,300
space layout randomization and data

304
00:14:01,370 --> 00:14:07,280
execution prevention unfortunately data

305
00:14:05,300 --> 00:14:10,339
execution prevention can be mitigated in

306
00:14:07,280 --> 00:14:12,140
most kernels because the colonel are in

307
00:14:10,340 --> 00:14:15,830
kernel space the attacker has access to

308
00:14:12,140 --> 00:14:17,840
raw memory and one approach could be you

309
00:14:15,830 --> 00:14:20,300
just set the flag that your your page is

310
00:14:17,840 --> 00:14:23,600
executable but using a memory safety

311
00:14:20,300 --> 00:14:25,459
attack or um there are some other ways

312
00:14:23,600 --> 00:14:27,580
around that as well by changing some

313
00:14:25,460 --> 00:14:31,910
form of some data structures and so on

314
00:14:27,580 --> 00:14:33,980
yeah a good question though so memory

315
00:14:31,910 --> 00:14:36,800
safe memory safe languages are where we

316
00:14:33,980 --> 00:14:39,530
would like to go to but unfortunately we

317
00:14:36,800 --> 00:14:42,050
are far off it takes us as law a long

318
00:14:39,530 --> 00:14:44,650
way from where we actually are to

319
00:14:42,050 --> 00:14:50,209
implement our systems and safe languages

320
00:14:44,650 --> 00:14:52,790
so what can we do well we can try to

321
00:14:50,210 --> 00:14:55,940
reach will fit memory safety on top of

322
00:14:52,790 --> 00:14:57,949
these existing languages to protect the

323
00:14:55,940 --> 00:15:01,730
huge amount of legacy code that is out

324
00:14:57,950 --> 00:15:03,680
there so several systems have been

325
00:15:01,730 --> 00:15:05,990
proposed to retrofit memory safety on

326
00:15:03,680 --> 00:15:08,750
top of C and C++ so it has been soft

327
00:15:05,990 --> 00:15:10,340
bound in cts which is roughly one

328
00:15:08,750 --> 00:15:13,250
hundred and sixteen percent overhead if

329
00:15:10,340 --> 00:15:15,740
you run it on on software they are

330
00:15:13,250 --> 00:15:18,410
secured which is lower overhead but

331
00:15:15,740 --> 00:15:21,320
comes with an additional cost of

332
00:15:18,410 --> 00:15:23,870
rewriting software or that it doesn't

333
00:15:21,320 --> 00:15:27,350
work for all the software and there's a

334
00:15:23,870 --> 00:15:29,510
dress sanitizer which has lower overhead

335
00:15:27,350 --> 00:15:31,730
and southbound in cts but comes at an

336
00:15:29,510 --> 00:15:33,410
additional restriction of unsoundness

337
00:15:31,730 --> 00:15:35,420
where it doesn't find all the bugs and

338
00:15:33,410 --> 00:15:40,010
is restricted in its practicality in

339
00:15:35,420 --> 00:15:42,890
some ways um but let's let's keep the

340
00:15:40,010 --> 00:15:45,380
idea of retrofitting memory safety

341
00:15:42,890 --> 00:15:47,120
around and let's see what how memory

342
00:15:45,380 --> 00:15:49,010
safety would actually work how you would

343
00:15:47,120 --> 00:15:52,640
read through a fit memory safety on on

344
00:15:49,010 --> 00:15:55,560
top of these systems so again we look at

345
00:15:52,640 --> 00:15:57,390
a simple program and

346
00:15:55,560 --> 00:15:59,339
it's basically the same program as

347
00:15:57,390 --> 00:16:01,470
before without the function pointer so

348
00:15:59,340 --> 00:16:03,660
we first allocate that buffer and then

349
00:16:01,470 --> 00:16:06,600
manipulate a pointer to that buffer

350
00:16:03,660 --> 00:16:08,969
using some attacker controlled input and

351
00:16:06,600 --> 00:16:13,740
then assign a value to that pointer the

352
00:16:08,970 --> 00:16:17,670
attacker has control so how can we

353
00:16:13,740 --> 00:16:20,970
protect how can we protect these these

354
00:16:17,670 --> 00:16:23,610
kind of pointer accesses well memory

355
00:16:20,970 --> 00:16:26,400
safety explicitly adds additional bounce

356
00:16:23,610 --> 00:16:28,800
checks to all the pointers that allow

357
00:16:26,400 --> 00:16:31,500
some runtime checking that the pointer

358
00:16:28,800 --> 00:16:33,839
dereference is actually valid at the

359
00:16:31,500 --> 00:16:36,600
time so in addition to the buffer

360
00:16:33,839 --> 00:16:38,820
pointer we add a lower and upper bound

361
00:16:36,600 --> 00:16:40,740
variables to the actual code that is

362
00:16:38,820 --> 00:16:42,300
executed and initialize it when the

363
00:16:40,740 --> 00:16:45,000
pointer itself is initialized in

364
00:16:42,300 --> 00:16:48,029
assigned in addition to that whenever

365
00:16:45,000 --> 00:16:52,830
the pointer is exchanged we propagate

366
00:16:48,029 --> 00:16:55,550
metadata to the pointer so the pointer Q

367
00:16:52,830 --> 00:16:59,010
is update as well as the pointer or

368
00:16:55,550 --> 00:17:03,150
metadata of the the buffer and later on

369
00:16:59,010 --> 00:17:05,730
if there's an axis to the pointer before

370
00:17:03,150 --> 00:17:07,410
that axis we add an additional check to

371
00:17:05,730 --> 00:17:09,810
ensure that the pointer is still in

372
00:17:07,410 --> 00:17:13,429
bounds if the pointer is no longer in

373
00:17:09,810 --> 00:17:19,260
bounds are we abort the program whether

374
00:17:13,429 --> 00:17:22,589
there's a memory error so what we

375
00:17:19,260 --> 00:17:24,390
actually end up this is some form of

376
00:17:22,589 --> 00:17:26,669
safe program that allows the runtime

377
00:17:24,390 --> 00:17:29,370
detection of memory safety

378
00:17:26,670 --> 00:17:32,220
vulnerabilities but unfortunately it

379
00:17:29,370 --> 00:17:33,540
comes at a very high price and we are

380
00:17:32,220 --> 00:17:36,840
paying one hundred and sixteen percent

381
00:17:33,540 --> 00:17:39,210
performance overhead which is a nice

382
00:17:36,840 --> 00:17:41,428
proof of concept but people will not use

383
00:17:39,210 --> 00:17:43,590
it in practice so we have to work

384
00:17:41,429 --> 00:17:45,330
towards lowering this overhead to make

385
00:17:43,590 --> 00:17:47,459
it actually feasible to use it as a

386
00:17:45,330 --> 00:17:49,710
defense mechanism even on current dist

387
00:17:47,460 --> 00:17:51,150
systems the problem that we are

388
00:17:49,710 --> 00:17:54,330
currently facing with these defense

389
00:17:51,150 --> 00:17:57,060
mechanism is that um even though we have

390
00:17:54,330 --> 00:17:59,070
built a couple of nice forts we are

391
00:17:57,060 --> 00:18:01,740
always faced with the safety versus

392
00:17:59,070 --> 00:18:05,310
flexibility and performance question so

393
00:18:01,740 --> 00:18:07,860
either we get safety on one hand or we

394
00:18:05,310 --> 00:18:08,990
get flexibility and performance but we

395
00:18:07,860 --> 00:18:12,479
cannot get both yeah

396
00:18:08,990 --> 00:18:14,760
so the biggest defense break some C code

397
00:18:12,480 --> 00:18:16,740
is it possible that which one's the one

398
00:18:14,760 --> 00:18:18,780
you just showed by adding the boundary

399
00:18:16,740 --> 00:18:21,420
check propagating the boundary is it

400
00:18:18,780 --> 00:18:26,070
possible that sound is complicated code

401
00:18:21,420 --> 00:18:28,950
yeah this arm while softbound is mostly

402
00:18:26,070 --> 00:18:33,090
safe and supports most of the code it

403
00:18:28,950 --> 00:18:34,830
does rely on inferring some form of type

404
00:18:33,090 --> 00:18:37,350
system and type T reference so there

405
00:18:34,830 --> 00:18:39,929
there's always some restriction in your

406
00:18:37,350 --> 00:18:43,439
cases where it will not work out yeah

407
00:18:39,930 --> 00:18:48,510
good question so we are faced with that

408
00:18:43,440 --> 00:18:52,320
question and are still the if you would

409
00:18:48,510 --> 00:18:54,870
like to know more about softbound

410
00:18:52,320 --> 00:18:57,570
there's or or the safe defense

411
00:18:54,870 --> 00:19:00,949
mechanisms there's been a nice talk that

412
00:18:57,570 --> 00:19:04,169
you can watch or you can read about

413
00:19:00,950 --> 00:19:07,980
softbound a sin and secure by just

414
00:19:04,170 --> 00:19:12,270
looking at the papers so moving we now

415
00:19:07,980 --> 00:19:15,570
know that the current defense mechanisms

416
00:19:12,270 --> 00:19:17,580
are not effective memory safety would be

417
00:19:15,570 --> 00:19:21,330
nice to have but comes add a too high

418
00:19:17,580 --> 00:19:24,060
overhead so you're looking at a new

419
00:19:21,330 --> 00:19:26,070
approach keep in mind that we would like

420
00:19:24,060 --> 00:19:28,190
to have memory safety but it is too

421
00:19:26,070 --> 00:19:31,290
expensive to enforce it for all the data

422
00:19:28,190 --> 00:19:33,330
so let's just move forward and only

423
00:19:31,290 --> 00:19:35,820
select a subset of data that we are

424
00:19:33,330 --> 00:19:37,590
actually interested in protecting so

425
00:19:35,820 --> 00:19:40,320
instead of protecting the complete heat

426
00:19:37,590 --> 00:19:41,429
and all the stack and or all the stacks

427
00:19:40,320 --> 00:19:44,010
actually if you're running multiple

428
00:19:41,430 --> 00:19:47,280
threads we only protect a subset of the

429
00:19:44,010 --> 00:19:49,430
data all the safe all the code pointers

430
00:19:47,280 --> 00:19:54,060
that are actually used and in the heap

431
00:19:49,430 --> 00:19:56,010
or on the stack by pushing stuff on a

432
00:19:54,060 --> 00:20:00,540
safe copy of the stack there by

433
00:19:56,010 --> 00:20:02,190
enforcing the integrity of the data but

434
00:20:00,540 --> 00:20:05,550
only a subset of the data that we are

435
00:20:02,190 --> 00:20:07,560
actually interested in so we offer a

436
00:20:05,550 --> 00:20:09,990
strong protection for a select and

437
00:20:07,560 --> 00:20:12,659
well-defined subset of data instead of

438
00:20:09,990 --> 00:20:17,400
offering full protection for all the

439
00:20:12,660 --> 00:20:20,130
data that is out there the attacker may

440
00:20:17,400 --> 00:20:21,750
modify any of the unprotected data and

441
00:20:20,130 --> 00:20:22,840
we don't give any guarantees whatsoever

442
00:20:21,750 --> 00:20:25,090
about the room

443
00:20:22,840 --> 00:20:27,550
any data that is out there so the

444
00:20:25,090 --> 00:20:32,169
attacker is free to run any data only

445
00:20:27,550 --> 00:20:35,139
attack on top of the of the other of the

446
00:20:32,170 --> 00:20:37,300
other data is not protected so instead

447
00:20:35,140 --> 00:20:39,130
of protecting everything a little we

448
00:20:37,300 --> 00:20:42,300
protect a little as good as we can

449
00:20:39,130 --> 00:20:46,210
offering strong integrity guarantees and

450
00:20:42,300 --> 00:20:49,060
to give you a peek into into the

451
00:20:46,210 --> 00:20:51,730
performance that we are looking at if

452
00:20:49,060 --> 00:20:53,169
you're running full memory safety we are

453
00:20:51,730 --> 00:20:55,720
faced with these one hundred sixteen

454
00:20:53,170 --> 00:20:57,670
percent overhead but if we protect only

455
00:20:55,720 --> 00:20:59,590
code pointers and give strong guarantees

456
00:20:57,670 --> 00:21:02,590
for all the code pointers that are used

457
00:20:59,590 --> 00:21:05,379
in the program we can protect against

458
00:21:02,590 --> 00:21:07,510
control flow high-tech attacks at low

459
00:21:05,380 --> 00:21:10,060
two to eight point four percent of

460
00:21:07,510 --> 00:21:11,740
performance overhead these two numbers

461
00:21:10,060 --> 00:21:13,899
are two different policies that we

462
00:21:11,740 --> 00:21:15,820
implement and we will go into more

463
00:21:13,900 --> 00:21:18,460
details what the different policies

464
00:21:15,820 --> 00:21:21,340
entail later on so these two policies

465
00:21:18,460 --> 00:21:23,740
offer strong protection against any

466
00:21:21,340 --> 00:21:25,840
software attacks by protecting only the

467
00:21:23,740 --> 00:21:27,580
code pointers and not giving guarantees

468
00:21:25,840 --> 00:21:31,330
about any other data that is in memory

469
00:21:27,580 --> 00:21:33,689
so let's start with code pointer

470
00:21:31,330 --> 00:21:38,860
separation the first security policy

471
00:21:33,690 --> 00:21:41,290
instead of are just having one heap we

472
00:21:38,860 --> 00:21:47,139
logically separate the heap into two

473
00:21:41,290 --> 00:21:49,540
pieces and I'll look at the regular heap

474
00:21:47,140 --> 00:21:51,190
for the program and any save pointer on

475
00:21:49,540 --> 00:21:54,879
top of it so we do have regular memory

476
00:21:51,190 --> 00:21:57,220
where all the unprotected data remains

477
00:21:54,880 --> 00:21:59,430
and we do have safe memory or we

478
00:21:57,220 --> 00:22:02,890
introduce safe memory as well where we

479
00:21:59,430 --> 00:22:05,440
move all our our function pointers to

480
00:22:02,890 --> 00:22:07,870
and we thereby separate or logically

481
00:22:05,440 --> 00:22:11,170
separate function pointers and any

482
00:22:07,870 --> 00:22:13,300
remaining data and taking the option

483
00:22:11,170 --> 00:22:18,370
order the possibility of an attacker to

484
00:22:13,300 --> 00:22:21,210
to modify it so the safe memory contains

485
00:22:18,370 --> 00:22:23,889
contains code pointers only nothing else

486
00:22:21,210 --> 00:22:27,220
while the regular memory contains all

487
00:22:23,890 --> 00:22:29,500
other data so the function pointers are

488
00:22:27,220 --> 00:22:31,690
moved to the safe memory and there's

489
00:22:29,500 --> 00:22:35,560
just a placeholder that remains in the

490
00:22:31,690 --> 00:22:36,610
unsafe memory the memory layout is

491
00:22:35,560 --> 00:22:38,790
unchanged

492
00:22:36,610 --> 00:22:41,260
to allow binary compatibility with

493
00:22:38,790 --> 00:22:44,260
unprotected libraries why we do not give

494
00:22:41,260 --> 00:22:47,530
any guarantees of codons running in

495
00:22:44,260 --> 00:22:51,070
unprotected libraries we do allow these

496
00:22:47,530 --> 00:22:52,780
the code to be run and an unchanged

497
00:22:51,070 --> 00:22:57,010
memory layout allows us to actually do

498
00:22:52,780 --> 00:23:01,510
that in the on the control plane side

499
00:22:57,010 --> 00:23:05,080
arm any value as either a code pointer

500
00:23:01,510 --> 00:23:07,480
or now and we enforce that any pointer

501
00:23:05,080 --> 00:23:09,699
any code pointer can only read and write

502
00:23:07,480 --> 00:23:11,679
from the safe memory area so the only

503
00:23:09,700 --> 00:23:14,350
thing we can read our other code

504
00:23:11,679 --> 00:23:17,380
pointers or not and thereby we restrict

505
00:23:14,350 --> 00:23:19,480
a set of valuable of values that can be

506
00:23:17,380 --> 00:23:24,640
written in the safe memory to the code

507
00:23:19,480 --> 00:23:27,100
pointers only in addition to the

508
00:23:24,640 --> 00:23:29,860
protection on the heap we also have to

509
00:23:27,100 --> 00:23:32,199
offer protection of the of the actual

510
00:23:29,860 --> 00:23:34,809
stack frames to protect against any

511
00:23:32,200 --> 00:23:36,220
stack-based overflows and there were

512
00:23:34,809 --> 00:23:38,590
several ideas that we looked at

513
00:23:36,220 --> 00:23:40,540
including shadow stacks and other

514
00:23:38,590 --> 00:23:42,459
defense mechanisms but most of them

515
00:23:40,540 --> 00:23:45,280
resulted in five to eight percent

516
00:23:42,460 --> 00:23:47,770
overhead and we wanted to achieve a much

517
00:23:45,280 --> 00:23:50,260
lower overhead in practice so what we

518
00:23:47,770 --> 00:23:52,360
came up with was a separation of stack

519
00:23:50,260 --> 00:23:56,260
frames into safe and unsafe stack frames

520
00:23:52,360 --> 00:23:59,949
or safe and regular stack frames on the

521
00:23:56,260 --> 00:24:03,669
regular stack we have all the all the

522
00:23:59,950 --> 00:24:05,740
values that are used for four-pointer

523
00:24:03,669 --> 00:24:10,799
computations or for other computations

524
00:24:05,740 --> 00:24:14,140
and on the safe stack we have all the

525
00:24:10,799 --> 00:24:17,049
all the values and variables that we can

526
00:24:14,140 --> 00:24:19,360
prove safe so everything that's accessed

527
00:24:17,049 --> 00:24:22,629
safely or that we can prove in the in

528
00:24:19,360 --> 00:24:26,409
our compiler past that is safe is pushed

529
00:24:22,630 --> 00:24:28,960
to the safe stack and anything else like

530
00:24:26,410 --> 00:24:31,419
anything that uses real pointer accesses

531
00:24:28,960 --> 00:24:34,600
or that we can approve is safe is pushed

532
00:24:31,419 --> 00:24:36,669
to the regular stack we don't give any

533
00:24:34,600 --> 00:24:40,270
guarantees whatsoever for data on the

534
00:24:36,669 --> 00:24:44,169
regular stack so any array might might

535
00:24:40,270 --> 00:24:48,960
corrupt any other area for the sample

536
00:24:44,169 --> 00:24:48,960
program that we're looking at here the

537
00:24:49,229 --> 00:24:54,519
the safe variables are are and the

538
00:24:51,669 --> 00:24:56,379
return address the code pointer and the

539
00:24:54,519 --> 00:24:58,719
unsafe variable is the buffer itself

540
00:24:56,379 --> 00:25:03,129
because there could actually be a buffer

541
00:24:58,719 --> 00:25:04,929
overflow happening so to summarize how

542
00:25:03,129 --> 00:25:09,039
does the memory layout actually look

543
00:25:04,929 --> 00:25:11,469
like again we have split the memory of a

544
00:25:09,039 --> 00:25:14,439
program conceptually and logically into

545
00:25:11,469 --> 00:25:17,499
two two planes the safe memory area and

546
00:25:14,439 --> 00:25:21,119
the regular memory area in the safe

547
00:25:17,499 --> 00:25:25,779
memory area all memory accesses are safe

548
00:25:21,119 --> 00:25:29,438
in regular memory all memory accesses

549
00:25:25,779 --> 00:25:31,239
are fast and we actually use hardware

550
00:25:29,439 --> 00:25:33,579
based instruction level isolation to

551
00:25:31,239 --> 00:25:36,099
separate these two these two memory

552
00:25:33,579 --> 00:25:39,849
areas using already existing features in

553
00:25:36,099 --> 00:25:42,489
available on current architectures so

554
00:25:39,849 --> 00:25:45,579
the regular memory contains regular heap

555
00:25:42,489 --> 00:25:47,409
stacks and code which is mapped read

556
00:25:45,579 --> 00:25:49,149
only and cannot modify cannot be

557
00:25:47,409 --> 00:25:51,399
modified by the attacker that case and

558
00:25:49,149 --> 00:25:54,119
the safe memory contains the safe heap

559
00:25:51,399 --> 00:25:57,758
that only contains null values or

560
00:25:54,119 --> 00:26:00,039
pointer values or or or values for

561
00:25:57,759 --> 00:26:02,379
function pointers and the safe stacks

562
00:26:00,039 --> 00:26:10,569
that contain all the safe data on the

563
00:26:02,379 --> 00:26:13,619
snacks so given this separation how can

564
00:26:10,569 --> 00:26:19,109
we still attack code pointer separation

565
00:26:13,619 --> 00:26:22,809
so one single example would be that an

566
00:26:19,109 --> 00:26:26,319
attacker can reuse existing code

567
00:26:22,809 --> 00:26:27,879
pointers out of out of context we do

568
00:26:26,319 --> 00:26:29,979
know that the attacker cannot forge a

569
00:26:27,879 --> 00:26:32,579
new code pointer by pointing it to some

570
00:26:29,979 --> 00:26:35,439
arbitrary location but an attacker might

571
00:26:32,579 --> 00:26:37,779
reuse a code pointer and let me

572
00:26:35,439 --> 00:26:39,429
illustrate that vision is an example so

573
00:26:37,779 --> 00:26:41,079
in this example we have our function

574
00:26:39,429 --> 00:26:43,599
pointer again and our motivating example

575
00:26:41,079 --> 00:26:48,309
but the function pointer is assigned as

576
00:26:43,599 --> 00:26:51,789
rewa struct and the attacker again has

577
00:26:48,309 --> 00:26:56,109
control over our pointer Q and can set

578
00:26:51,789 --> 00:26:59,559
the memory location and the the actual

579
00:26:56,109 --> 00:27:01,539
value that is used so we do know that

580
00:26:59,559 --> 00:27:02,918
the attacker cannot modify the function

581
00:27:01,539 --> 00:27:06,070
pointer itself

582
00:27:02,919 --> 00:27:08,049
but what the attacker can modify is the

583
00:27:06,070 --> 00:27:09,939
dereference from the struct pointer to

584
00:27:08,049 --> 00:27:12,970
the actual function pointer and thereby

585
00:27:09,940 --> 00:27:15,309
going through the in direction so are

586
00:27:12,970 --> 00:27:16,450
the attacker can modify the structure

587
00:27:15,309 --> 00:27:21,158
pointer from pointing to the beginning

588
00:27:16,450 --> 00:27:24,669
of destruct to some other copy of the

589
00:27:21,159 --> 00:27:27,879
struct that is somewhere in our in

590
00:27:24,669 --> 00:27:31,809
memory and contains another valid

591
00:27:27,879 --> 00:27:34,600
function pointer so destructive tacker

592
00:27:31,809 --> 00:27:37,178
construct actually must contain a valid

593
00:27:34,600 --> 00:27:39,939
a valid function pointers otherwise the

594
00:27:37,179 --> 00:27:41,440
value in the safe memory would be null

595
00:27:39,940 --> 00:27:45,809
and the program would stop any SD

596
00:27:41,440 --> 00:27:49,539
referenced this way an attacker can

597
00:27:45,809 --> 00:27:52,509
replace one function pointer is another

598
00:27:49,539 --> 00:27:57,129
function pointer by going through a

599
00:27:52,509 --> 00:27:58,929
dereference chain from a striped so the

600
00:27:57,129 --> 00:28:03,519
other value must be null or a pointer to

601
00:27:58,929 --> 00:28:08,350
another function as I said before how do

602
00:28:03,519 --> 00:28:10,989
we do that we identify all code pointer

603
00:28:08,350 --> 00:28:13,869
accesses through a compiler pass that

604
00:28:10,989 --> 00:28:16,179
looks at a type based analysis and

605
00:28:13,869 --> 00:28:18,908
identifies all the code pointers we

606
00:28:16,179 --> 00:28:22,749
separate those identify types using

607
00:28:18,909 --> 00:28:27,369
instruction level isolation for x86 this

608
00:28:22,749 --> 00:28:29,379
would be segmentation and the CPS code

609
00:28:27,369 --> 00:28:33,158
pointer separation gives you a couple of

610
00:28:29,379 --> 00:28:36,119
security guarantees most importantly an

611
00:28:33,159 --> 00:28:39,309
attacker cannot forge new code pointers

612
00:28:36,119 --> 00:28:41,949
so an attacker can only reuse the code

613
00:28:39,309 --> 00:28:45,850
pointers that already exist in the safe

614
00:28:41,950 --> 00:28:49,330
memory area code pointer is either an

615
00:28:45,850 --> 00:28:53,199
immediate as encoded in the instruction

616
00:28:49,330 --> 00:28:56,619
itself or assigned from another code

617
00:28:53,200 --> 00:28:58,330
pointer there cannot be any attacker

618
00:28:56,619 --> 00:29:01,779
control or attacker constructor code

619
00:28:58,330 --> 00:29:03,489
pointers in that safe memory area ah the

620
00:29:01,779 --> 00:29:05,440
capabilities that remain to the attacker

621
00:29:03,489 --> 00:29:08,440
are that the attacker can replace

622
00:29:05,440 --> 00:29:10,539
existing function stream direction so

623
00:29:08,440 --> 00:29:13,869
for example going from food to bar to

624
00:29:10,539 --> 00:29:17,849
funk the attacker can redirect it to foo

625
00:29:13,869 --> 00:29:17,849
bus funky and thereby control it

626
00:29:19,140 --> 00:29:27,340
but funk you must still be a valid

627
00:29:21,730 --> 00:29:29,800
mullet pointer so in practice are we've

628
00:29:27,340 --> 00:29:32,409
grouped our code pointers together and

629
00:29:29,800 --> 00:29:34,870
can thereby protect them against any

630
00:29:32,410 --> 00:29:38,560
attacks from the outside by keeping them

631
00:29:34,870 --> 00:29:41,620
in a safe area and ensure that there are

632
00:29:38,560 --> 00:29:45,429
no outside accesses but we can do better

633
00:29:41,620 --> 00:29:47,830
than that so we building on top of code

634
00:29:45,430 --> 00:29:51,490
pointer separation we introduced code

635
00:29:47,830 --> 00:29:52,870
pointer integrity as well so the set of

636
00:29:51,490 --> 00:29:55,030
the sensitive pointers that we are

637
00:29:52,870 --> 00:29:58,320
protecting is now no longer just the

638
00:29:55,030 --> 00:30:00,460
code pointers but code pointers and

639
00:29:58,320 --> 00:30:03,159
pointers used to access sensitive

640
00:30:00,460 --> 00:30:04,960
pointers so this is basically a

641
00:30:03,160 --> 00:30:08,740
transitive closure on all the pointers

642
00:30:04,960 --> 00:30:13,450
that are that are used to directly or

643
00:30:08,740 --> 00:30:16,510
indirectly access any code pointer again

644
00:30:13,450 --> 00:30:18,640
we rely on as on identifying sensitive

645
00:30:16,510 --> 00:30:22,660
pointers using an over proximate type

646
00:30:18,640 --> 00:30:24,970
based analysis so the over approximation

647
00:30:22,660 --> 00:30:27,490
tells us that it will always be safe in

648
00:30:24,970 --> 00:30:29,470
the worst case we'll protect additional

649
00:30:27,490 --> 00:30:32,380
data that we wouldn't need to protect

650
00:30:29,470 --> 00:30:34,450
but we'll be safe in any way there might

651
00:30:32,380 --> 00:30:38,410
be additional overhead but we can still

652
00:30:34,450 --> 00:30:41,260
ensure safety so the over approximation

653
00:30:38,410 --> 00:30:44,830
only affects performance are we measured

654
00:30:41,260 --> 00:30:46,510
on smack CPU that are less than six

655
00:30:44,830 --> 00:30:48,399
point five percent of all the accesses

656
00:30:46,510 --> 00:30:52,240
are sensitive according to this

657
00:30:48,400 --> 00:30:54,490
definition and compared to self bound we

658
00:30:52,240 --> 00:30:56,620
only have to protect six point six point

659
00:30:54,490 --> 00:30:59,470
five percent of the memory accesses

660
00:30:56,620 --> 00:31:05,229
which gives us a big performance speed

661
00:30:59,470 --> 00:31:07,990
up so how can we attack code pointer

662
00:31:05,230 --> 00:31:09,940
integrity we have the same example as

663
00:31:07,990 --> 00:31:11,440
before and let's see what additional

664
00:31:09,940 --> 00:31:14,830
instrumentation is actually

665
00:31:11,440 --> 00:31:16,900
automatically inserted so we do have to

666
00:31:14,830 --> 00:31:19,960
lower and upper bounds of the pointer

667
00:31:16,900 --> 00:31:21,880
and we do run the bounced check before

668
00:31:19,960 --> 00:31:26,320
the pointer is actually accessed and the

669
00:31:21,880 --> 00:31:29,779
attacker can can redirect the structure

670
00:31:26,320 --> 00:31:31,999
to an attacker controlled value

671
00:31:29,779 --> 00:31:34,999
and in this case there will actually be

672
00:31:31,999 --> 00:31:37,159
an exception when the attacker

673
00:31:34,999 --> 00:31:40,419
controlled value of Q st reference and

674
00:31:37,159 --> 00:31:43,059
we can stop the program before the

675
00:31:40,419 --> 00:31:45,440
actual memory safety corruption or

676
00:31:43,059 --> 00:31:48,469
memory safety violation happens and

677
00:31:45,440 --> 00:31:52,429
thereby protect the integrity of the of

678
00:31:48,469 --> 00:31:54,289
the system so to make the make the

679
00:31:52,429 --> 00:31:55,849
difference between code point your

680
00:31:54,289 --> 00:31:58,129
integrity and code boundary separation

681
00:31:55,849 --> 00:32:01,759
explicit let me quickly highlight the

682
00:31:58,129 --> 00:32:03,859
the main difference both systems

683
00:32:01,759 --> 00:32:06,259
separate sensitive pointers from regular

684
00:32:03,859 --> 00:32:09,080
data and push all the sensitive data to

685
00:32:06,259 --> 00:32:12,229
a safe memory area both of them rely on

686
00:32:09,080 --> 00:32:14,178
a tight based static analysis but the

687
00:32:12,229 --> 00:32:16,820
set of sensitive pointers is defined

688
00:32:14,179 --> 00:32:19,399
differently for code pointer integrity

689
00:32:16,820 --> 00:32:21,320
it is code pointers and all pointers to

690
00:32:19,399 --> 00:32:25,119
sensitive pointers for code pointer

691
00:32:21,320 --> 00:32:25,119
separations its code pointers only

692
00:32:25,570 --> 00:32:31,700
accessing sensitive pointers as always

693
00:32:28,249 --> 00:32:34,639
safe so for code pointers separation are

694
00:32:31,700 --> 00:32:36,919
we do have separation of the code

695
00:32:34,639 --> 00:32:39,279
finders into its own memory area but for

696
00:32:36,919 --> 00:32:41,210
code pointer integrity we extend the

697
00:32:39,279 --> 00:32:43,609
separation with additional runtime

698
00:32:41,210 --> 00:32:46,909
bounced check checks that ensures that

699
00:32:43,609 --> 00:32:50,059
are no other value can be used to

700
00:32:46,909 --> 00:32:53,179
overwrite the any point during the in

701
00:32:50,059 --> 00:32:56,418
the dereference chain and accessing

702
00:32:53,179 --> 00:32:58,879
regular data is fast so any data that we

703
00:32:56,419 --> 00:33:00,799
don't protect can be accessed at regular

704
00:32:58,879 --> 00:33:02,570
speed without any additional overhead or

705
00:33:00,799 --> 00:33:06,019
any additional instrumentation that must

706
00:33:02,570 --> 00:33:08,210
be executed on top of it so you might

707
00:33:06,019 --> 00:33:11,149
wonder what kind of security guarantees

708
00:33:08,210 --> 00:33:14,029
do we actually give for code pointer

709
00:33:11,149 --> 00:33:17,718
integrity we have a formally guaranteed

710
00:33:14,029 --> 00:33:19,849
protection where we are guarantee memory

711
00:33:17,719 --> 00:33:22,489
safety for all the code pointers so the

712
00:33:19,849 --> 00:33:24,499
code pointers can never be modified by a

713
00:33:22,489 --> 00:33:28,999
memory safety violation using this

714
00:33:24,499 --> 00:33:32,719
approach um this results in 8.4 percent

715
00:33:28,999 --> 00:33:35,179
overhead for spec and 10.4 10.5 percent

716
00:33:32,719 --> 00:33:37,429
overhead for the for onyx benchmarks and

717
00:33:35,179 --> 00:33:40,279
we are protecting roughly six point five

718
00:33:37,429 --> 00:33:41,809
percent of all the memory accesses this

719
00:33:40,279 --> 00:33:42,940
is low overhead that can be actually

720
00:33:41,809 --> 00:33:45,550
used

721
00:33:42,940 --> 00:33:46,840
practice but we would obviously like to

722
00:33:45,550 --> 00:33:49,030
see something that's that's lower than

723
00:33:46,840 --> 00:33:51,520
that or even lower than that therefore

724
00:33:49,030 --> 00:33:55,080
coat pointer separation offers strong

725
00:33:51,520 --> 00:33:57,580
protection in practice and allows you to

726
00:33:55,080 --> 00:34:00,250
separate all the code pointers from any

727
00:33:57,580 --> 00:34:02,290
attacker controlled value and prohibits

728
00:34:00,250 --> 00:34:05,290
attackers from fortune code code

729
00:34:02,290 --> 00:34:06,879
pointers in practice we see oh point

730
00:34:05,290 --> 00:34:08,590
five to one point nine percent overhead

731
00:34:06,880 --> 00:34:12,450
and we are protecting roughly 2.5

732
00:34:08,590 --> 00:34:12,450
percent of the memory accesses ah

733
00:34:13,139 --> 00:34:17,770
something that I only touch briefly is

734
00:34:15,550 --> 00:34:19,210
the safe stack which offers you full

735
00:34:17,770 --> 00:34:21,699
protection against return oriented

736
00:34:19,210 --> 00:34:23,800
programming if you only deploy the same

737
00:34:21,699 --> 00:34:26,319
stack itself and I'm only mentioning it

738
00:34:23,800 --> 00:34:28,780
here because it actually has negligible

739
00:34:26,320 --> 00:34:31,390
overhead and has overhead on par with

740
00:34:28,780 --> 00:34:33,730
stack cookies as they are used on

741
00:34:31,389 --> 00:34:35,319
current system but it offers strictly

742
00:34:33,730 --> 00:34:37,480
stronger protection than a current

743
00:34:35,320 --> 00:34:39,990
defense mechanism and we are working on

744
00:34:37,480 --> 00:34:44,020
integrating that in mainline compilers

745
00:34:39,989 --> 00:34:47,409
so to summarize we've built a set of

746
00:34:44,020 --> 00:34:49,659
defense layers around our around our

747
00:34:47,409 --> 00:34:51,940
system that we can that we can deploy

748
00:34:49,659 --> 00:34:54,370
one after the other and they build on

749
00:34:51,940 --> 00:34:56,950
top of each other so there's there's the

750
00:34:54,370 --> 00:34:58,690
safe stack that starts at the beginning

751
00:34:56,949 --> 00:35:00,609
and in addition to that we have code

752
00:34:58,690 --> 00:35:04,360
pointer separation and coach point your

753
00:35:00,610 --> 00:35:06,490
integrity if you want full protection so

754
00:35:04,360 --> 00:35:09,130
how does the implementation look line we

755
00:35:06,490 --> 00:35:11,259
have an llvm based prototype where we

756
00:35:09,130 --> 00:35:13,810
collect all the type information that we

757
00:35:11,260 --> 00:35:16,240
need in the front end inclined and in

758
00:35:13,810 --> 00:35:19,150
the back end on top of llvm we have the

759
00:35:16,240 --> 00:35:21,040
safe stack CPS and CPI instrumentation

760
00:35:19,150 --> 00:35:23,530
passes and we have additional runtime

761
00:35:21,040 --> 00:35:25,600
support in the in the runtime libraries

762
00:35:23,530 --> 00:35:28,990
for a safe he penned a snack management

763
00:35:25,600 --> 00:35:33,310
the current instruction sets that we

764
00:35:28,990 --> 00:35:35,799
support our x64 and x86 are and the

765
00:35:33,310 --> 00:35:40,299
systems that we support our mac OS x

766
00:35:35,800 --> 00:35:43,180
freebsd and linux the current status of

767
00:35:40,300 --> 00:35:45,460
the implementation we have great support

768
00:35:43,180 --> 00:35:49,419
for code country integrity on mac OS x

769
00:35:45,460 --> 00:35:51,100
and freebsd for x64 or the up streaming

770
00:35:49,420 --> 00:35:54,220
of the patches is in progress and the

771
00:35:51,100 --> 00:35:56,319
safe stack should be coming to llvm soon

772
00:35:54,220 --> 00:35:58,720
as soon as the patch goes

773
00:35:56,320 --> 00:36:02,050
and we figure out the development

774
00:35:58,720 --> 00:36:04,209
process you can fork it on github now if

775
00:36:02,050 --> 00:36:06,700
you want to look at the current

776
00:36:04,210 --> 00:36:10,120
prototype and play with it go ahead and

777
00:36:06,700 --> 00:36:12,279
fork it and the code review of CPS and

778
00:36:10,120 --> 00:36:15,490
CPI is in is in process and we're

779
00:36:12,280 --> 00:36:18,310
working on it you can play with the

780
00:36:15,490 --> 00:36:20,379
release prototype we also have an image

781
00:36:18,310 --> 00:36:25,529
available and will also release more

782
00:36:20,380 --> 00:36:28,120
packages soon so the next question oh

783
00:36:25,530 --> 00:36:30,970
yeah I almost forgot to mention some

784
00:36:28,120 --> 00:36:33,400
changes to super complex build systems

785
00:36:30,970 --> 00:36:36,660
are also needed so when we were looking

786
00:36:33,400 --> 00:36:41,230
at at freebsd we obviously had to modify

787
00:36:36,660 --> 00:36:43,240
some of the make files of the of the

788
00:36:41,230 --> 00:36:45,730
freebsd package management and packaged

789
00:36:43,240 --> 00:36:48,669
compilation system we did not have to

790
00:36:45,730 --> 00:36:53,010
modify any source code just to build

791
00:36:48,670 --> 00:36:55,300
environment to ensure that our our

792
00:36:53,010 --> 00:36:58,920
runtime libraries are linked in as well

793
00:36:55,300 --> 00:37:02,020
mostly so you might ask is it practical

794
00:36:58,920 --> 00:37:06,070
therefore we re compiled the complete

795
00:37:02,020 --> 00:37:08,530
freebsd user space using our our strong

796
00:37:06,070 --> 00:37:11,710
protection and we successfully compiled

797
00:37:08,530 --> 00:37:15,190
it and also more than 100 packages like

798
00:37:11,710 --> 00:37:16,750
pison postgresql SQLite and a whole

799
00:37:15,190 --> 00:37:20,710
bunch of other packages that are often

800
00:37:16,750 --> 00:37:22,900
attacked so the defense that we are

801
00:37:20,710 --> 00:37:26,110
actually looking at has low overhead is

802
00:37:22,900 --> 00:37:30,070
deployable in practice and can be used

803
00:37:26,110 --> 00:37:32,980
today so it is now your part to actually

804
00:37:30,070 --> 00:37:37,990
start playing with this system and get

805
00:37:32,980 --> 00:37:40,300
rid of all those bugs yeah so yeah you

806
00:37:37,990 --> 00:37:42,729
motivate this work by showing the

807
00:37:40,300 --> 00:37:45,640
existent of all this exploit so I wonder

808
00:37:42,730 --> 00:37:47,590
whether you know let's say look at the

809
00:37:45,640 --> 00:37:50,109
last two years exploit on this target

810
00:37:47,590 --> 00:37:51,790
system are all of them protected using

811
00:37:50,110 --> 00:37:54,190
your you imagine world there may be a

812
00:37:51,790 --> 00:37:56,710
few that sleep through or would work to

813
00:37:54,190 --> 00:37:59,110
the situation so for CPI we do have

814
00:37:56,710 --> 00:38:01,540
formal guarantees that no memory safety

815
00:37:59,110 --> 00:38:03,340
violation is possible therefore all

816
00:38:01,540 --> 00:38:06,370
control flow high check attacks are

817
00:38:03,340 --> 00:38:09,200
protected so okay so then are there

818
00:38:06,370 --> 00:38:12,770
other attacks that are not

819
00:38:09,200 --> 00:38:15,290
a control flow hijack that thought of

820
00:38:12,770 --> 00:38:17,540
are in this see me that consider serious

821
00:38:15,290 --> 00:38:20,150
or that's a good question any data only

822
00:38:17,540 --> 00:38:22,310
attack cannot be catched so you met

823
00:38:20,150 --> 00:38:24,860
either radically possible but are they

824
00:38:22,310 --> 00:38:27,230
really out there imagine an ftp server

825
00:38:24,860 --> 00:38:28,970
that has an authenticated mode at a non

826
00:38:27,230 --> 00:38:31,760
0 sending in more than half a bug in

827
00:38:28,970 --> 00:38:33,799
where um and if I can either talk

828
00:38:31,760 --> 00:38:36,680
attacker can right there is also

829
00:38:33,800 --> 00:38:38,630
indicated flag our protection will not

830
00:38:36,680 --> 00:38:40,970
help against it right so this protection

831
00:38:38,630 --> 00:38:43,280
is only geared against to stop control

832
00:38:40,970 --> 00:38:46,160
flow hi check attacks yeah I know yeah

833
00:38:43,280 --> 00:38:49,550
I'm just wondering uh in the real

834
00:38:46,160 --> 00:38:52,129
attacks how many are this control flow

835
00:38:49,550 --> 00:38:54,860
higher end how many that's have a common

836
00:38:52,130 --> 00:38:56,750
attack vector used to be so that's the

837
00:38:54,860 --> 00:39:01,550
biggest attack vector used to and all

838
00:38:56,750 --> 00:39:03,670
the it's we assumed that given this

839
00:39:01,550 --> 00:39:06,890
defense mechanism attackers will shift

840
00:39:03,670 --> 00:39:09,380
towards data attacks or data only

841
00:39:06,890 --> 00:39:11,089
attacks as it gets harder or even

842
00:39:09,380 --> 00:39:13,730
impossible to carry out the control flow

843
00:39:11,090 --> 00:39:17,000
hijack attack so in the future attackers

844
00:39:13,730 --> 00:39:18,770
will resort to our data only attacks to

845
00:39:17,000 --> 00:39:21,560
either escalate their privileges by

846
00:39:18,770 --> 00:39:24,350
setting individual flags like an admin

847
00:39:21,560 --> 00:39:26,870
variable or just extract the data as was

848
00:39:24,350 --> 00:39:29,779
done by by hartley so for example this

849
00:39:26,870 --> 00:39:32,450
approach would not stop heartbleed while

850
00:39:29,780 --> 00:39:34,490
there was a memory safety violation in

851
00:39:32,450 --> 00:39:37,160
heartbleed no code pointers were

852
00:39:34,490 --> 00:39:40,729
modified therefore it would not protect

853
00:39:37,160 --> 00:39:42,560
against that um and obviously more

854
00:39:40,730 --> 00:39:44,750
protection will be or more research will

855
00:39:42,560 --> 00:39:46,250
be needed that's a good thing right so

856
00:39:44,750 --> 00:39:49,520
we can continue to look for strong

857
00:39:46,250 --> 00:39:51,470
defense matters like I said we are in

858
00:39:49,520 --> 00:39:53,300
your field you're you never need to be

859
00:39:51,470 --> 00:39:55,220
afraid of out of work exactly yeah

860
00:39:53,300 --> 00:39:57,200
there's always more guarantees that you

861
00:39:55,220 --> 00:39:58,819
can give and if you if you've given full

862
00:39:57,200 --> 00:40:02,839
guarantees there's always performance

863
00:39:58,820 --> 00:40:04,160
you can optimize so let me conclude code

864
00:40:02,840 --> 00:40:06,530
pointer integrity and co pointer

865
00:40:04,160 --> 00:40:07,990
separation offer strong protection

866
00:40:06,530 --> 00:40:13,310
against control flow high check attacks

867
00:40:07,990 --> 00:40:15,859
and the key insight that I want to to

868
00:40:13,310 --> 00:40:18,049
get get through is that we are enforcing

869
00:40:15,860 --> 00:40:20,510
memory safety for code pointers only

870
00:40:18,050 --> 00:40:22,550
instead of enforcing memory safety for

871
00:40:20,510 --> 00:40:24,860
all the data that is out there users

872
00:40:22,550 --> 00:40:28,090
our protection to the data that is

873
00:40:24,860 --> 00:40:30,500
actually important and needs protection

874
00:40:28,090 --> 00:40:33,410
we do have a working prototype that

875
00:40:30,500 --> 00:40:36,320
supports unmodified C and C++ and has

876
00:40:33,410 --> 00:40:39,379
low overhead in practice the upstream of

877
00:40:36,320 --> 00:40:41,780
the patches is in progress and the safe

878
00:40:39,380 --> 00:40:43,580
stack should be available soon we do

879
00:40:41,780 --> 00:40:45,950
have a home page out there and you can

880
00:40:43,580 --> 00:40:53,799
focus on github to look at the actual

881
00:40:45,950 --> 00:40:53,799
prototype so are there any questions

882
00:41:03,349 --> 00:41:06,349
thanks

