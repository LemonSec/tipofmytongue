1
00:00:00,000 --> 00:00:01,979
good afternoon and welcome to another

2
00:00:01,979 --> 00:00:04,080
episode of the series security seminar

3
00:00:04,080 --> 00:00:06,540
from Purdue University uh great honor

4
00:00:06,540 --> 00:00:08,280
today to be able to introduce our our

5
00:00:08,280 --> 00:00:11,760
speaker so uh Dr Menge shu is an

6
00:00:11,760 --> 00:00:13,559
assistant professor in the cheridan

7
00:00:13,559 --> 00:00:15,360
school of computer science at the

8
00:00:15,360 --> 00:00:18,060
University of Waterloo uh I married a

9
00:00:18,060 --> 00:00:20,359
Canadian so I actually am one of the few

10
00:00:20,359 --> 00:00:23,039
U.S academics who know quite a bit about

11
00:00:23,039 --> 00:00:26,279
the mountain Waterloo so it is my

12
00:00:26,279 --> 00:00:28,859
pleasure to welcome you this week and

13
00:00:28,859 --> 00:00:31,460
have you give our presentation so Meng

14
00:00:31,460 --> 00:00:34,020
thank you thank you for the introduction

15
00:00:34,020 --> 00:00:36,840
Joe and I guess I can share my screen

16
00:00:36,840 --> 00:00:39,920
now for the presentation

17
00:00:40,200 --> 00:00:41,399
okay

18
00:00:41,399 --> 00:00:46,559
great uh this over hi hi everyone so

19
00:00:46,559 --> 00:00:48,960
um my name is and I'm assistant

20
00:00:48,960 --> 00:00:51,600
professor at uwaju and it's really an

21
00:00:51,600 --> 00:00:54,000
honor to be here to give a talk about

22
00:00:54,000 --> 00:00:56,039
the move proverb which is a

23
00:00:56,039 --> 00:00:58,379
formalification tool we developed for

24
00:00:58,379 --> 00:01:00,719
the move language and the associates

25
00:01:00,719 --> 00:01:03,180
blockchains

26
00:01:03,180 --> 00:01:06,720
so this paper this presentation is based

27
00:01:06,720 --> 00:01:09,540
on the paper we published to taxes on

28
00:01:09,540 --> 00:01:13,140
2022 and the paper the code and the

29
00:01:13,140 --> 00:01:15,600
artifact we submitted for the for the

30
00:01:15,600 --> 00:01:18,420
conference are all available online and

31
00:01:18,420 --> 00:01:20,460
then the and this paper wants the best

32
00:01:20,460 --> 00:01:22,619
paper award and then also the best tool

33
00:01:22,619 --> 00:01:24,240
paper nomination

34
00:01:24,240 --> 00:01:27,780
so but you might be curious like why do

35
00:01:27,780 --> 00:01:29,820
I even want to introduce a formal method

36
00:01:29,820 --> 00:01:32,280
paper for a security talk because well

37
00:01:32,280 --> 00:01:33,960
this is a security group and I'm

38
00:01:33,960 --> 00:01:35,700
assuming everyone here is security

39
00:01:35,700 --> 00:01:38,520
oriented so why do I want to introduce a

40
00:01:38,520 --> 00:01:41,220
formal method paper so there are several

41
00:01:41,220 --> 00:01:44,280
reasons but one reason I I think that's

42
00:01:44,280 --> 00:01:47,460
irrelevant is that a lot of work we do

43
00:01:47,460 --> 00:01:49,619
in in security is about software

44
00:01:49,619 --> 00:01:51,659
security and obviously we want to find

45
00:01:51,659 --> 00:01:54,180
bugs and vulnerabilities in the software

46
00:01:54,180 --> 00:01:56,579
and in order to do that we use a lot of

47
00:01:56,579 --> 00:01:59,399
program analysis techniques and symbolic

48
00:01:59,399 --> 00:02:02,579
execution is one method of doing program

49
00:02:02,579 --> 00:02:05,399
analysis now if you happen to be working

50
00:02:05,399 --> 00:02:08,220
in this area of symbolic execution you

51
00:02:08,220 --> 00:02:10,440
might find that the move prover paper is

52
00:02:10,440 --> 00:02:13,379
actually very relevant here so um I'll

53
00:02:13,379 --> 00:02:15,840
show you um why on the later part of

54
00:02:15,840 --> 00:02:18,840
talk so in this talk uh the move proverb

55
00:02:18,840 --> 00:02:20,819
is really a huge

56
00:02:20,819 --> 00:02:23,099
um well it's a large collection of

57
00:02:23,099 --> 00:02:25,500
techniques of course we are not going to

58
00:02:25,500 --> 00:02:28,140
cover all of them but fortunately today

59
00:02:28,140 --> 00:02:30,120
I'm going to cover three things which

60
00:02:30,120 --> 00:02:32,160
are the state exploration Loop

61
00:02:32,160 --> 00:02:34,980
invariants and memory modeling and that

62
00:02:34,980 --> 00:02:37,200
is also the part that is most relevant

63
00:02:37,200 --> 00:02:40,140
to other code bases like codebase is

64
00:02:40,140 --> 00:02:42,720
written in C or C plus plus or Java in

65
00:02:42,720 --> 00:02:44,640
case you want we want to develop new

66
00:02:44,640 --> 00:02:47,420
symbolic execution tools for them

67
00:02:47,420 --> 00:02:50,459
and also this is not the first hand move

68
00:02:50,459 --> 00:02:54,660
prover appears in the uh serious um

69
00:02:54,660 --> 00:02:57,780
seminar in fact last year uh the David

70
00:02:57,780 --> 00:03:00,480
Deal which is the lead researcher in

71
00:03:00,480 --> 00:03:02,760
Facebook at that time and also um yeah I

72
00:03:02,760 --> 00:03:04,500
kind of figure who pioneered the move

73
00:03:04,500 --> 00:03:06,959
prover work uh he did a talk here at

74
00:03:06,959 --> 00:03:09,780
Purdue about the moon proverb and in his

75
00:03:09,780 --> 00:03:12,959
talk it's it's a lot of introduction on

76
00:03:12,959 --> 00:03:16,080
how how about the move language and well

77
00:03:16,080 --> 00:03:19,019
as the user like user experience in

78
00:03:19,019 --> 00:03:21,000
terms of using normal proverb so I

79
00:03:21,000 --> 00:03:23,280
highly recommend you to watch Davis talk

80
00:03:23,280 --> 00:03:25,980
if you want to get a feeling on what the

81
00:03:25,980 --> 00:03:28,080
move prover can do and what are the

82
00:03:28,080 --> 00:03:30,239
things you can specify through move

83
00:03:30,239 --> 00:03:33,180
proverb so in this talk I decided to go

84
00:03:33,180 --> 00:03:34,980
a little bit deeper in terms of the

85
00:03:34,980 --> 00:03:37,560
techniques behind the move prover and

86
00:03:37,560 --> 00:03:40,140
then more on the lines of how do we get

87
00:03:40,140 --> 00:03:41,760
the things or get the specifications

88
00:03:41,760 --> 00:03:44,760
verified and get it get a code check

89
00:03:44,760 --> 00:03:47,819
that the code is actually conformed into

90
00:03:47,819 --> 00:03:49,440
the specifications

91
00:03:49,440 --> 00:03:53,940
so that's about the general theme of

92
00:03:53,940 --> 00:03:55,319
today's talk

93
00:03:55,319 --> 00:03:58,920
and also feel free to raise questions uh

94
00:03:58,920 --> 00:04:01,319
in the through the Q a I won't be able

95
00:04:01,319 --> 00:04:03,780
to monitor them during the talk but I

96
00:04:03,780 --> 00:04:07,140
will answer them at the end of The Talk

97
00:04:07,140 --> 00:04:10,080
so as the outline of what is going to be

98
00:04:10,080 --> 00:04:11,939
covered today so I'll give a brief

99
00:04:11,939 --> 00:04:14,580
introduction on what is move and what is

100
00:04:14,580 --> 00:04:17,760
approver what we can do with that and

101
00:04:17,760 --> 00:04:20,100
also I'll explain how this is relevant

102
00:04:20,100 --> 00:04:23,280
to symbolic execution okay explain what

103
00:04:23,280 --> 00:04:25,500
how conventional symbolic execution are

104
00:04:25,500 --> 00:04:26,759
down and then what are the new

105
00:04:26,759 --> 00:04:29,340
techniques we adopted and how do we

106
00:04:29,340 --> 00:04:31,620
solve the loop issue and then the doing

107
00:04:31,620 --> 00:04:33,660
the memory model and also a little bit

108
00:04:33,660 --> 00:04:36,060
on what are the future plans given the

109
00:04:36,060 --> 00:04:38,220
techniques we already have

110
00:04:38,220 --> 00:04:41,759
so let's go with the introduction first

111
00:04:41,759 --> 00:04:44,880
so as we now know that the reason we

112
00:04:44,880 --> 00:04:47,340
have this smooth proofer is like we want

113
00:04:47,340 --> 00:04:49,440
to secure the assets that are currently

114
00:04:49,440 --> 00:04:52,199
installed on blockchains and these are

115
00:04:52,199 --> 00:04:54,120
blockchains are designed are supposed to

116
00:04:54,120 --> 00:04:56,220
be higher Assurance systems and so are

117
00:04:56,220 --> 00:04:59,280
the smart contracts that manage and

118
00:04:59,280 --> 00:05:01,680
manipulate their stats so there's a

119
00:05:01,680 --> 00:05:04,500
large assets at stake and then the

120
00:05:04,500 --> 00:05:06,120
transactions on blockchains are

121
00:05:06,120 --> 00:05:09,000
irreversible and they may be targeted by

122
00:05:09,000 --> 00:05:11,100
highly motive motivated and well

123
00:05:11,100 --> 00:05:13,320
resources a well-resourced adversaries

124
00:05:13,320 --> 00:05:16,139
as we have seen in tons of examples

125
00:05:16,139 --> 00:05:17,820
there's already hundreds of millions

126
00:05:17,820 --> 00:05:20,940
dollars lost from bugs in smart

127
00:05:20,940 --> 00:05:23,460
contracts so we want to design a program

128
00:05:23,460 --> 00:05:26,340
language as also a formalification tool

129
00:05:26,340 --> 00:05:29,160
to make sure that when you write a smart

130
00:05:29,160 --> 00:05:30,600
contract

131
00:05:30,600 --> 00:05:32,940
um there is um well we tried our best to

132
00:05:32,940 --> 00:05:34,680
guarantee that there is no bugs or no

133
00:05:34,680 --> 00:05:37,560
CBO bugs that can cause such a huge

134
00:05:37,560 --> 00:05:39,060
financial loss

135
00:05:39,060 --> 00:05:42,300
so that's why uh the move language it's

136
00:05:42,300 --> 00:05:44,220
um proposed it was originally developed

137
00:05:44,220 --> 00:05:46,919
for the DM blockchain and now it's a

138
00:05:46,919 --> 00:05:49,440
community-backed um project and they're

139
00:05:49,440 --> 00:05:52,380
still used by um some blockchains like

140
00:05:52,380 --> 00:05:56,039
apples and Suite and star coins so movie

141
00:05:56,039 --> 00:05:58,320
is based on the language is based on the

142
00:05:58,320 --> 00:06:00,840
concept of uh or two concepts one is

143
00:06:00,840 --> 00:06:02,699
called borrow analysis if you're

144
00:06:02,699 --> 00:06:04,620
familiar with rust the other borrow

145
00:06:04,620 --> 00:06:06,720
semantics if you're familiar with rust

146
00:06:06,720 --> 00:06:09,360
this is um this is a like something you

147
00:06:09,360 --> 00:06:12,000
should be very familiar and also

148
00:06:12,000 --> 00:06:14,520
um it's based on linear typing like the

149
00:06:14,520 --> 00:06:17,220
unique punchers in C plus so these two

150
00:06:17,220 --> 00:06:19,620
things actually makes verification

151
00:06:19,620 --> 00:06:22,680
fairly easy for the move language and

152
00:06:22,680 --> 00:06:24,180
also the language doesn't support

153
00:06:24,180 --> 00:06:26,580
Dynamic dispatching and all the core

154
00:06:26,580 --> 00:06:28,860
size can be determined statically and

155
00:06:28,860 --> 00:06:31,380
this is another huge Plus for formal

156
00:06:31,380 --> 00:06:34,259
verification and all the move programs

157
00:06:34,259 --> 00:06:36,600
can only interact with external States

158
00:06:36,600 --> 00:06:39,479
through a limited set of apis again and

159
00:06:39,479 --> 00:06:42,840
a feature suitable for like us friendly

160
00:06:42,840 --> 00:06:44,539
for formal vacation

161
00:06:44,539 --> 00:06:47,100
because the movie is designed with

162
00:06:47,100 --> 00:06:49,560
formalification in mind so it comes

163
00:06:49,560 --> 00:06:51,539
naturally with a full set of

164
00:06:51,539 --> 00:06:53,819
specification language supporting

165
00:06:53,819 --> 00:06:56,160
pre-post conditions and then support

166
00:06:56,160 --> 00:06:58,919
supporting you to specify Global staging

167
00:06:58,919 --> 00:07:01,440
variants and that includes all the first

168
00:07:01,440 --> 00:07:04,020
other predicate calculus as well as the

169
00:07:04,020 --> 00:07:06,780
universal and xensor and existential

170
00:07:06,780 --> 00:07:09,120
quantifiers so this is the general

171
00:07:09,120 --> 00:07:11,580
introduction about the move language so

172
00:07:11,580 --> 00:07:13,380
let's just take a look at a small

173
00:07:13,380 --> 00:07:16,199
example and just feel it how it looks

174
00:07:16,199 --> 00:07:19,620
like so it's it's not too far from a

175
00:07:19,620 --> 00:07:22,440
rust language if I were to classify it

176
00:07:22,440 --> 00:07:25,319
you can define a module and the inside a

177
00:07:25,319 --> 00:07:28,740
module you can Define structs that you

178
00:07:28,740 --> 00:07:31,860
want to well you want to represent at

179
00:07:31,860 --> 00:07:34,199
your data times and then you can Define

180
00:07:34,199 --> 00:07:36,419
functions on what other things you can

181
00:07:36,419 --> 00:07:39,780
do with the structs or with the user

182
00:07:39,780 --> 00:07:42,539
input for example here you are you are

183
00:07:42,539 --> 00:07:45,539
using a account to represent and a bank

184
00:07:45,539 --> 00:07:47,460
account and then you can Define the

185
00:07:47,460 --> 00:07:49,440
withdrawal function which allows the

186
00:07:49,440 --> 00:07:51,900
user to withdraw some money from its

187
00:07:51,900 --> 00:07:55,500
account and and like like a blockchain

188
00:07:55,500 --> 00:07:57,720
system the account is going to be stored

189
00:07:57,720 --> 00:08:00,840
in a global States therefore you do a

190
00:08:00,840 --> 00:08:04,380
borrow Global mute which you you get a

191
00:08:04,380 --> 00:08:06,840
reference or you get a pointer to the

192
00:08:06,840 --> 00:08:08,940
global States and then you operate on

193
00:08:08,940 --> 00:08:11,460
the balance that stores in a in a

194
00:08:11,460 --> 00:08:14,340
blockchain and once this function is

195
00:08:14,340 --> 00:08:16,800
finished it's it's going to write the

196
00:08:16,800 --> 00:08:19,379
changes or the New Balance back to the

197
00:08:19,379 --> 00:08:21,240
blockchain so that's the general

198
00:08:21,240 --> 00:08:24,240
procedure and also you can Define entry

199
00:08:24,240 --> 00:08:26,460
functions or so-called like it's like

200
00:08:26,460 --> 00:08:27,900
the main functions you know blockchain

201
00:08:27,900 --> 00:08:31,199
world how you want to how you want the

202
00:08:31,199 --> 00:08:33,839
user to call into the code

203
00:08:33,839 --> 00:08:36,419
so this is a general feeling on how to

204
00:08:36,419 --> 00:08:38,940
program your moves and

205
00:08:38,940 --> 00:08:41,279
at the same time there's also ways that

206
00:08:41,279 --> 00:08:44,219
you want to specify a move say that I

207
00:08:44,219 --> 00:08:46,200
want to I want to write down some

208
00:08:46,200 --> 00:08:48,959
properties saying that my implementation

209
00:08:48,959 --> 00:08:51,720
of the whatever for example the transfer

210
00:08:51,720 --> 00:08:54,899
function is going to follow exactly what

211
00:08:54,899 --> 00:08:57,360
I wanted to do so for example here you

212
00:08:57,360 --> 00:08:59,700
can define a specification for the

213
00:08:59,700 --> 00:09:02,339
transfer function saying that what are

214
00:09:02,339 --> 00:09:04,440
the cases this transfer function can go

215
00:09:04,440 --> 00:09:07,200
wrong and if the function doesn't go

216
00:09:07,200 --> 00:09:09,660
around what are the end results the user

217
00:09:09,660 --> 00:09:12,060
should supposed to be seeing for example

218
00:09:12,060 --> 00:09:14,580
here you can say that if the transfer

219
00:09:14,580 --> 00:09:17,160
function has to abort if you don't have

220
00:09:17,160 --> 00:09:18,980
if the sender doesn't have enough

221
00:09:18,980 --> 00:09:22,800
funding in in his account and also the

222
00:09:22,800 --> 00:09:24,839
transfer function has the board if the

223
00:09:24,839 --> 00:09:28,320
receiver for example is going to have an

224
00:09:28,320 --> 00:09:30,660
overflow if the new amount goes into

225
00:09:30,660 --> 00:09:31,800
this account

226
00:09:31,800 --> 00:09:34,019
and if the transfer function doesn't

227
00:09:34,019 --> 00:09:36,540
know board we need to ensure that the

228
00:09:36,540 --> 00:09:38,700
balance does get deducted from the

229
00:09:38,700 --> 00:09:41,040
cylinder and increased into the receiver

230
00:09:41,040 --> 00:09:43,080
so these are the things the pre-post

231
00:09:43,080 --> 00:09:45,660
conditions we can specify on how a

232
00:09:45,660 --> 00:09:47,240
transfer function can do

233
00:09:47,240 --> 00:09:49,980
besides that we can also specify Global

234
00:09:49,980 --> 00:09:53,160
invarence says that I don't care how you

235
00:09:53,160 --> 00:09:55,260
implement the function but I want to

236
00:09:55,260 --> 00:09:58,920
just have some requirements is that your

237
00:09:58,920 --> 00:10:01,860
account balance must be above certain

238
00:10:01,860 --> 00:10:04,980
minimum balance or if you try to

239
00:10:04,980 --> 00:10:06,959
withdraw something from your account I

240
00:10:06,959 --> 00:10:08,459
don't care how you implement a

241
00:10:08,459 --> 00:10:10,560
withdrawal function I just want to say

242
00:10:10,560 --> 00:10:13,140
that whenever you do a withdrawal you

243
00:10:13,140 --> 00:10:16,080
cannot withdraw too much that's also

244
00:10:16,080 --> 00:10:18,180
something we support in the move proverb

245
00:10:18,180 --> 00:10:20,220
and they can be elegantly specified

246
00:10:20,220 --> 00:10:21,899
through something called Global

247
00:10:21,899 --> 00:10:22,980
imbalance

248
00:10:22,980 --> 00:10:26,220
so these are the like the things you can

249
00:10:26,220 --> 00:10:29,279
do or with them approver

250
00:10:29,279 --> 00:10:31,320
right now the proverb is of course 100

251
00:10:31,320 --> 00:10:33,540
open source and then actively maintained

252
00:10:33,540 --> 00:10:34,800
on GitHub

253
00:10:34,800 --> 00:10:36,839
um it supports full automatic

254
00:10:36,839 --> 00:10:40,380
verification and to make sure that the

255
00:10:40,380 --> 00:10:42,060
code actually meets the specification

256
00:10:42,060 --> 00:10:44,519
and it's run continuously on the DM

257
00:10:44,519 --> 00:10:46,800
blockchain and the Aptos blockchain and

258
00:10:46,800 --> 00:10:49,260
possibly other blockchains as well

259
00:10:49,260 --> 00:10:52,320
and it runs a little bit slower than the

260
00:10:52,320 --> 00:10:55,079
Linker or other static analysis tools it

261
00:10:55,079 --> 00:10:58,380
takes several minutes to verify a about

262
00:10:58,380 --> 00:11:03,360
9000 lines of code together with 63 6500

263
00:11:03,360 --> 00:11:05,459
lines of specifications and everything

264
00:11:05,459 --> 00:11:07,860
finishes within a couple of minutes so

265
00:11:07,860 --> 00:11:11,160
it's fairly fast and allows this to be

266
00:11:11,160 --> 00:11:14,220
run continuously on the app so every

267
00:11:14,220 --> 00:11:17,160
um code change that touches some of the

268
00:11:17,160 --> 00:11:19,500
move files are going to be checked by

269
00:11:19,500 --> 00:11:22,260
the move prover as well so this is the

270
00:11:22,260 --> 00:11:24,000
current status and if you're interested

271
00:11:24,000 --> 00:11:26,820
I do encourage you to look at the move

272
00:11:26,820 --> 00:11:29,820
language repository and the more prover

273
00:11:29,820 --> 00:11:31,860
is there

274
00:11:31,860 --> 00:11:34,920
so given the similarity of move and rust

275
00:11:34,920 --> 00:11:37,079
the rest of the code snippet will be in

276
00:11:37,079 --> 00:11:39,540
the rust syntax just that you don't need

277
00:11:39,540 --> 00:11:42,000
to learn your language but naturally

278
00:11:42,000 --> 00:11:45,120
they should be all the techniques we see

279
00:11:45,120 --> 00:11:49,200
here should be applicable on both sides

280
00:11:49,200 --> 00:11:52,980
so that's a general introduction on what

281
00:11:52,980 --> 00:11:55,200
the move proverb or what the move

282
00:11:55,200 --> 00:11:57,000
language and the move forward is doing

283
00:11:57,000 --> 00:11:59,880
so now we are going to see how this is

284
00:11:59,880 --> 00:12:02,940
related to symbolic execution so let's

285
00:12:02,940 --> 00:12:05,399
see how what the conventional symbolic

286
00:12:05,399 --> 00:12:06,899
execution are doing

287
00:12:06,899 --> 00:12:09,120
so when we see a function for example

288
00:12:09,120 --> 00:12:11,399
here is a very simple assumption and

289
00:12:11,399 --> 00:12:13,860
then we have a specification saying that

290
00:12:13,860 --> 00:12:17,220
at the end of the execution the result

291
00:12:17,220 --> 00:12:21,260
of R must be greater than the input of X

292
00:12:21,260 --> 00:12:24,420
and regardless of how you set the input

293
00:12:24,420 --> 00:12:26,760
of C1 C2 so which are the two Boolean

294
00:12:26,760 --> 00:12:30,060
Flags well this is a very simple program

295
00:12:30,060 --> 00:12:31,860
and there shouldn't be too hard to

296
00:12:31,860 --> 00:12:35,100
justify uh even with human eyes we can

297
00:12:35,100 --> 00:12:37,260
easily verify that this is going to be

298
00:12:37,260 --> 00:12:41,220
correct so what a a typical way we try

299
00:12:41,220 --> 00:12:43,260
to do is uh we'll go we'll construct a

300
00:12:43,260 --> 00:12:46,620
control flow graph of this program and

301
00:12:46,620 --> 00:12:48,660
if you're careful enough you might also

302
00:12:48,660 --> 00:12:51,060
want to control a control flow graph in

303
00:12:51,060 --> 00:12:54,000
static single assignment form which just

304
00:12:54,000 --> 00:12:57,180
helps you with the analysis and then

305
00:12:57,180 --> 00:13:00,000
this is also what lvm and other

306
00:13:00,000 --> 00:13:03,120
compilers are doing so we take this code

307
00:13:03,120 --> 00:13:06,420
we can we we convert that into a control

308
00:13:06,420 --> 00:13:09,060
flow graphing SSA form and then the

309
00:13:09,060 --> 00:13:12,740
natural salt would be so I will try to

310
00:13:12,740 --> 00:13:15,959
cover all the code paths in this control

311
00:13:15,959 --> 00:13:18,959
flow graph and if I can prove that on

312
00:13:18,959 --> 00:13:21,240
every code path the assertion is going

313
00:13:21,240 --> 00:13:23,339
to hold then I can prove that this

314
00:13:23,339 --> 00:13:25,800
session is going to behold so the whole

315
00:13:25,800 --> 00:13:28,860
function so that's a very simple and

316
00:13:28,860 --> 00:13:31,620
intuitive thought and it actually works

317
00:13:31,620 --> 00:13:36,360
so the way we do this path based

318
00:13:36,360 --> 00:13:39,000
symbolic execution is exactly like what

319
00:13:39,000 --> 00:13:41,760
I said we go over each path we go over

320
00:13:41,760 --> 00:13:44,100
all the code execution path and prove

321
00:13:44,100 --> 00:13:46,440
that for each path the the surgeon holds

322
00:13:46,440 --> 00:13:49,380
so we let's see how we do that with a

323
00:13:49,380 --> 00:13:52,320
single path so at the beginning we just

324
00:13:52,320 --> 00:13:54,480
defined a bunch of variables that we

325
00:13:54,480 --> 00:13:56,720
don't know but we just mark them as

326
00:13:56,720 --> 00:13:59,399
mathematical variables and then during

327
00:13:59,399 --> 00:14:01,740
the execution of the path we start to

328
00:14:01,740 --> 00:14:04,500
collect constraints that

329
00:14:04,500 --> 00:14:07,079
um related to these variables so at the

330
00:14:07,079 --> 00:14:10,019
beginning there's um there's no

331
00:14:10,019 --> 00:14:12,120
constraints on any of the variables and

332
00:14:12,120 --> 00:14:14,579
you can always reach from this code path

333
00:14:14,579 --> 00:14:17,760
and then we go on One path because

334
00:14:17,760 --> 00:14:19,740
there's a branch so we pick one branch

335
00:14:19,740 --> 00:14:22,380
and we go down One path and now we have

336
00:14:22,380 --> 00:14:24,480
some representation of certain variables

337
00:14:24,480 --> 00:14:27,839
so we know that this R1 must be equal to

338
00:14:27,839 --> 00:14:31,200
X plus three and this is only true when

339
00:14:31,200 --> 00:14:34,500
the addition one pose and we further

340
00:14:34,500 --> 00:14:36,600
follow down the execution path and now

341
00:14:36,600 --> 00:14:39,380
we know that this R3 must be equal to R1

342
00:14:39,380 --> 00:14:43,019
and with the past condition hold and

343
00:14:43,019 --> 00:14:45,720
then we further go to another branch and

344
00:14:45,720 --> 00:14:48,600
we discovered a new assignment for the

345
00:14:48,600 --> 00:14:51,660
R4 value and also A New Path condition

346
00:14:51,660 --> 00:14:53,940
because in order for you to reach this

347
00:14:53,940 --> 00:14:57,060
B4 block on both this condition needs to

348
00:14:57,060 --> 00:15:00,899
be true at this particular path so we

349
00:15:00,899 --> 00:15:03,000
collect the path condition until we

350
00:15:03,000 --> 00:15:06,360
reach the end of the path which is the

351
00:15:06,360 --> 00:15:08,519
the block here and then we try to say

352
00:15:08,519 --> 00:15:11,880
that in this particular path given all

353
00:15:11,880 --> 00:15:13,920
these conditions we want to make sure

354
00:15:13,920 --> 00:15:16,620
that these are searching holds so here

355
00:15:16,620 --> 00:15:20,100
is a simplified view of the path

356
00:15:20,100 --> 00:15:22,560
exploration we have the representation

357
00:15:22,560 --> 00:15:25,380
of all the variables that we collected

358
00:15:25,380 --> 00:15:27,540
along the path and we have a path

359
00:15:27,540 --> 00:15:29,339
condition and then we want to prove that

360
00:15:29,339 --> 00:15:32,220
given this information we click directed

361
00:15:32,220 --> 00:15:34,920
we want to prove that assertion holds so

362
00:15:34,920 --> 00:15:37,740
that's very simple and then you can give

363
00:15:37,740 --> 00:15:38,779
this

364
00:15:38,779 --> 00:15:41,399
Boolean conjunctions openly encoding

365
00:15:41,399 --> 00:15:44,100
into a smt solver then the solver is

366
00:15:44,100 --> 00:15:45,779
going to happily give you the answer

367
00:15:45,779 --> 00:15:49,019
that yes I can prove this is correct

368
00:15:49,019 --> 00:15:51,720
so and then by that we basically prove

369
00:15:51,720 --> 00:15:54,360
that if your code follows this execution

370
00:15:54,360 --> 00:15:57,180
path then this assertion must hold now

371
00:15:57,180 --> 00:16:00,060
that's good and

372
00:16:00,060 --> 00:16:02,820
the thing is that we need to prove all

373
00:16:02,820 --> 00:16:05,040
this condition to be holding for all

374
00:16:05,040 --> 00:16:08,160
execution paths so this is one path and

375
00:16:08,160 --> 00:16:10,019
then there's another path you need to

376
00:16:10,019 --> 00:16:13,019
trick at the at this branching point so

377
00:16:13,019 --> 00:16:14,880
you collect a different set of path

378
00:16:14,880 --> 00:16:17,519
condition and you collect different set

379
00:16:17,519 --> 00:16:19,320
of variables and then still you want to

380
00:16:19,320 --> 00:16:22,260
prove that this holds and again you you

381
00:16:22,260 --> 00:16:24,420
go to another path and another path

382
00:16:24,420 --> 00:16:26,760
until the end you prove that all the

383
00:16:26,760 --> 00:16:29,699
paths you prove that this condition is

384
00:16:29,699 --> 00:16:31,560
going to hold for all the path and then

385
00:16:31,560 --> 00:16:33,839
that's basically the the victory right

386
00:16:33,839 --> 00:16:37,079
you you achieved a full coverage of the

387
00:16:37,079 --> 00:16:39,300
program and you make sure that in all

388
00:16:39,300 --> 00:16:41,040
conditions this assertion is going to

389
00:16:41,040 --> 00:16:42,959
hold that's good

390
00:16:42,959 --> 00:16:46,680
the only issue with that is is likely to

391
00:16:46,680 --> 00:16:49,320
run into a path explosion problem but

392
00:16:49,320 --> 00:16:52,320
right now what we see is that

393
00:16:52,320 --> 00:16:55,620
um there's only two diamonds in this

394
00:16:55,620 --> 00:16:57,779
control flow graph therefore you only

395
00:16:57,779 --> 00:17:01,500
needs to have two to the power 2 half

396
00:17:01,500 --> 00:17:03,420
um because well like I said you need to

397
00:17:03,420 --> 00:17:05,400
you need four path to enumerate

398
00:17:05,400 --> 00:17:07,980
everything from B 0 to B6

399
00:17:07,980 --> 00:17:10,740
and if you add one more layer of diamond

400
00:17:10,740 --> 00:17:13,380
here you basically uh increment the

401
00:17:13,380 --> 00:17:16,020
exponent by one so now you need to

402
00:17:16,020 --> 00:17:19,319
explore a path which is uh well still

403
00:17:19,319 --> 00:17:21,959
okay but if you keep adding more layers

404
00:17:21,959 --> 00:17:24,660
into your program control flow graph

405
00:17:24,660 --> 00:17:27,000
then you you realize that the path you

406
00:17:27,000 --> 00:17:29,280
need to explore in order to prove the

407
00:17:29,280 --> 00:17:31,620
assertion at the end grows exponentially

408
00:17:31,620 --> 00:17:34,140
the more like diamonds you see in the

409
00:17:34,140 --> 00:17:36,960
control flow graphs the more well path

410
00:17:36,960 --> 00:17:38,760
you need to explore and that grows

411
00:17:38,760 --> 00:17:41,160
exponentially which is I which is of

412
00:17:41,160 --> 00:17:44,299
course not the ideal case

413
00:17:44,360 --> 00:17:48,720
so in more proverb we definitely do not

414
00:17:48,720 --> 00:17:52,380
try to do this path enumeration because

415
00:17:52,380 --> 00:17:55,620
in in Real uh or in real world programs

416
00:17:55,620 --> 00:17:57,660
you probably won't be able to find

417
00:17:57,660 --> 00:17:59,760
simple programs like

418
00:17:59,760 --> 00:18:03,120
like this which is only about a couple

419
00:18:03,120 --> 00:18:05,700
of lines only about a couple of branches

420
00:18:05,700 --> 00:18:07,799
in the real world program you see a lot

421
00:18:07,799 --> 00:18:10,440
of branches and then you easily see this

422
00:18:10,440 --> 00:18:13,919
diamond shaped control flow graph so we

423
00:18:13,919 --> 00:18:16,320
need to find a way to still prove things

424
00:18:16,320 --> 00:18:18,720
without going through all the paths we

425
00:18:18,720 --> 00:18:19,620
have

426
00:18:19,620 --> 00:18:22,799
so that's why the improver we adopt

427
00:18:22,799 --> 00:18:24,360
something called backward symbolic

428
00:18:24,360 --> 00:18:26,460
execution or

429
00:18:26,460 --> 00:18:28,380
um in more formal education term is

430
00:18:28,380 --> 00:18:30,900
called wikis liberal preconditions

431
00:18:30,900 --> 00:18:35,160
so we use this liberal weakness liberal

432
00:18:35,160 --> 00:18:38,100
precondition calculus to encode the

433
00:18:38,100 --> 00:18:40,260
program so we encode all the basic

434
00:18:40,260 --> 00:18:43,380
blocks at once and send that to asmt

435
00:18:43,380 --> 00:18:45,539
solver instead of going through pass by

436
00:18:45,539 --> 00:18:50,340
path so I will explain what it does uh

437
00:18:50,340 --> 00:18:52,760
exactly

438
00:18:52,799 --> 00:18:55,440
so again we can well we can look at this

439
00:18:55,440 --> 00:18:58,860
example and see what exactly is this

440
00:18:58,860 --> 00:19:01,860
um the backward symbolic execution so

441
00:19:01,860 --> 00:19:04,020
still we start

442
00:19:04,020 --> 00:19:08,220
um we we use this same example as a

443
00:19:08,220 --> 00:19:10,740
running example but this time instead of

444
00:19:10,740 --> 00:19:13,380
going through all uh going through this

445
00:19:13,380 --> 00:19:15,840
path by path we are going to first

446
00:19:15,840 --> 00:19:18,179
convert the program into a dynamic

447
00:19:18,179 --> 00:19:22,080
single assignment form and then do a

448
00:19:22,080 --> 00:19:24,660
then go from there so the dynamic single

449
00:19:24,660 --> 00:19:26,820
assignment is basically lifting the

450
00:19:26,820 --> 00:19:30,299
spine node into the basic blocks where

451
00:19:30,299 --> 00:19:32,580
it's supposed to be defined so that's a

452
00:19:32,580 --> 00:19:34,100
fairly simple

453
00:19:34,100 --> 00:19:37,080
algorithm and then we do a topological

454
00:19:37,080 --> 00:19:38,940
sorting on the control flow graph and

455
00:19:38,940 --> 00:19:41,039
then Traverse backwards based on the

456
00:19:41,039 --> 00:19:42,539
topological order

457
00:19:42,539 --> 00:19:45,360
so I'll skip this details and then I'll

458
00:19:45,360 --> 00:19:46,740
show you the example first and then come

459
00:19:46,740 --> 00:19:49,380
back to the details so still we look at

460
00:19:49,380 --> 00:19:51,660
this example and then we want to encode

461
00:19:51,660 --> 00:19:54,840
this whole program as a smt formula and

462
00:19:54,840 --> 00:19:57,120
then ask the solver to solve it so what

463
00:19:57,120 --> 00:19:59,880
we do is we Define still we Define the

464
00:19:59,880 --> 00:20:01,980
variables and because at the beginning

465
00:20:01,980 --> 00:20:04,860
we know nothing about the program we

466
00:20:04,860 --> 00:20:07,260
Define everything as three variables and

467
00:20:07,260 --> 00:20:10,380
not only that we Define and we give a

468
00:20:10,380 --> 00:20:12,840
free variable for each basic block so

469
00:20:12,840 --> 00:20:15,360
each basic block is going to have a

470
00:20:15,360 --> 00:20:18,059
variable of either true or false and the

471
00:20:18,059 --> 00:20:22,380
meaning is that if this basic block is

472
00:20:22,380 --> 00:20:25,140
true it means that this property holds

473
00:20:25,140 --> 00:20:29,520
so that's a very simple notion so we

474
00:20:29,520 --> 00:20:32,039
start as we said we're going to start

475
00:20:32,039 --> 00:20:35,220
backwards so we start from the end of

476
00:20:35,220 --> 00:20:37,200
the execution which is the last basic

477
00:20:37,200 --> 00:20:38,820
block in execution and then we go

478
00:20:38,820 --> 00:20:42,539
backwards and we we say that we are

479
00:20:42,539 --> 00:20:45,840
going to say please if B6 is true it

480
00:20:45,840 --> 00:20:49,440
means that this uh assertion hose

481
00:20:49,440 --> 00:20:53,039
and we go up in the control flow graph

482
00:20:53,039 --> 00:20:57,240
and then we continue to get a well a

483
00:20:57,240 --> 00:20:59,820
bunch of implications saying that in

484
00:20:59,820 --> 00:21:02,460
order for you to prove B6 is true which

485
00:21:02,460 --> 00:21:05,460
is the assertion we want to prove we are

486
00:21:05,460 --> 00:21:08,220
given the condition that c the second

487
00:21:08,220 --> 00:21:11,580
condition is true here and we know if

488
00:21:11,580 --> 00:21:13,980
the second condition is true are 4 and

489
00:21:13,980 --> 00:21:16,559
R6 are going to be assigned in certain

490
00:21:16,559 --> 00:21:19,020
way and with all the information please

491
00:21:19,020 --> 00:21:22,500
try to approve B6 is true so this is the

492
00:21:22,500 --> 00:21:25,260
the meaning of before here and similarly

493
00:21:25,260 --> 00:21:28,380
we can do B5 it means now if we don't

494
00:21:28,380 --> 00:21:31,320
have the second condition to be true and

495
00:21:31,320 --> 00:21:32,820
we are going to have a different set of

496
00:21:32,820 --> 00:21:34,980
assignment and with this set of salmon

497
00:21:34,980 --> 00:21:37,740
please still try to prove that B6 is

498
00:21:37,740 --> 00:21:40,440
true now if this is provable then we

499
00:21:40,440 --> 00:21:43,440
assign b4p5 to be true as well

500
00:21:43,440 --> 00:21:46,679
and similarly if you want to prove B6 is

501
00:21:46,679 --> 00:21:49,500
true you do need to prove B3 it's true

502
00:21:49,500 --> 00:21:51,720
which means you need to prove both B4

503
00:21:51,720 --> 00:21:54,900
and B5 are true so this is the way how

504
00:21:54,900 --> 00:21:58,080
we woke up and as as we said we're going

505
00:21:58,080 --> 00:22:00,299
to further go upwards and then we get

506
00:22:00,299 --> 00:22:03,840
assigned we get encoding for B1 and B2

507
00:22:03,840 --> 00:22:06,000
and at the end we're getting coding for

508
00:22:06,000 --> 00:22:09,539
b0 meaning if you want to prove

509
00:22:09,539 --> 00:22:11,220
um the whole thing you need to prove

510
00:22:11,220 --> 00:22:13,080
both B1 B2

511
00:22:13,080 --> 00:22:16,440
now we we get all these assignments of

512
00:22:16,440 --> 00:22:18,720
this or all the constraints about these

513
00:22:18,720 --> 00:22:21,000
three variables and all we need to do is

514
00:22:21,000 --> 00:22:23,159
that given these constraints please

515
00:22:23,159 --> 00:22:25,559
prove that V3 is true and if this

516
00:22:25,559 --> 00:22:29,600
provable it means our assertion holds

517
00:22:29,600 --> 00:22:32,940
so you the the solver is very happy to

518
00:22:32,940 --> 00:22:37,020
take this um seemingly complex encoding

519
00:22:37,020 --> 00:22:38,940
and then return you the result that yes

520
00:22:38,940 --> 00:22:41,640
we can prove this

521
00:22:41,640 --> 00:22:43,500
um if we will try to compare the the

522
00:22:43,500 --> 00:22:45,539
process of the forward and backward

523
00:22:45,539 --> 00:22:48,360
symbolic execution you realize that you

524
00:22:48,360 --> 00:22:50,460
know in a in a conventional way of doing

525
00:22:50,460 --> 00:22:52,980
symbolic solution you need to you need

526
00:22:52,980 --> 00:22:55,860
to you have a very simple formula

527
00:22:55,860 --> 00:22:58,500
because on each path there is only

528
00:22:58,500 --> 00:23:00,240
limited information you want to encode

529
00:23:00,240 --> 00:23:03,120
but you need to solve this simple

530
00:23:03,120 --> 00:23:05,580
formula multiple times for different

531
00:23:05,580 --> 00:23:08,340
path however with the backward encoding

532
00:23:08,340 --> 00:23:12,059
you can have a much complex formula but

533
00:23:12,059 --> 00:23:14,039
you only need to solve it for once

534
00:23:14,039 --> 00:23:16,980
and more importantly if you follow the

535
00:23:16,980 --> 00:23:18,720
procedure here we actually never

536
00:23:18,720 --> 00:23:21,840
Traverse a path instead we Traverse by

537
00:23:21,840 --> 00:23:22,980
the

538
00:23:22,980 --> 00:23:26,039
uh by the basic blocks and one basic

539
00:23:26,039 --> 00:23:29,159
block is only like visited only once so

540
00:23:29,159 --> 00:23:32,100
in that case we don't have the problem

541
00:23:32,100 --> 00:23:35,640
of path explosion we only uh our like

542
00:23:35,640 --> 00:23:38,400
encoding is only limited by how many

543
00:23:38,400 --> 00:23:40,020
basic blocks you have

544
00:23:40,020 --> 00:23:43,080
and then this is basically the algorithm

545
00:23:43,080 --> 00:23:45,320
for the World Cup it's a very simple

546
00:23:45,320 --> 00:23:48,659
recursive procedure so it basically says

547
00:23:48,659 --> 00:23:51,780
that every statement in the program is

548
00:23:51,780 --> 00:23:54,419
either a assertion or assignment and if

549
00:23:54,419 --> 00:23:56,220
it's assertion do something if the

550
00:23:56,220 --> 00:23:58,440
assignment do something and if your C2

551
00:23:58,440 --> 00:24:01,799
are a sequence of instructions on do the

552
00:24:01,799 --> 00:24:04,140
recursive procedure and if you see on

553
00:24:04,140 --> 00:24:06,059
two basic blocks that follow certain

554
00:24:06,059 --> 00:24:08,480
things to another

555
00:24:08,480 --> 00:24:11,520
recursive procedure so it's elegantly

556
00:24:11,520 --> 00:24:15,480
designed and yeah it's fairly simple to

557
00:24:15,480 --> 00:24:17,840
adopt

558
00:24:18,419 --> 00:24:21,299
so that's about the backward way of

559
00:24:21,299 --> 00:24:24,299
rounding the uh encoding a program or

560
00:24:24,299 --> 00:24:25,980
visiting the different states in the

561
00:24:25,980 --> 00:24:29,159
program but you might realize that the

562
00:24:29,159 --> 00:24:31,980
thing works pretty fine unless you

563
00:24:31,980 --> 00:24:34,919
ensure you hear that Loop in the control

564
00:24:34,919 --> 00:24:37,200
flow graph because if you hit a loop in

565
00:24:37,200 --> 00:24:39,059
the control flow graph it doesn't matter

566
00:24:39,059 --> 00:24:41,340
whether you want to Traverse the path or

567
00:24:41,340 --> 00:24:43,320
you want to work backwards if you have a

568
00:24:43,320 --> 00:24:46,080
loop you're going to more stuck in the

569
00:24:46,080 --> 00:24:48,780
loop forever if if you only naively

570
00:24:48,780 --> 00:24:50,820
trying to implement trying to visit a

571
00:24:50,820 --> 00:24:53,820
basic box so here is an example there is

572
00:24:53,820 --> 00:24:56,400
a loop here and it also shows up in the

573
00:24:56,400 --> 00:24:58,740
control flow graph we have a loop that

574
00:24:58,740 --> 00:25:01,200
coming from this basic block and then

575
00:25:01,200 --> 00:25:04,440
return or continue at the speed file so

576
00:25:04,440 --> 00:25:07,320
there's a loop here and if you work if

577
00:25:07,320 --> 00:25:09,440
you follow the conventional way which

578
00:25:09,440 --> 00:25:12,179
goes to follow down the path you're

579
00:25:12,179 --> 00:25:14,340
going to seeing this these basic blocks

580
00:25:14,340 --> 00:25:17,039
being visited on and on and on again and

581
00:25:17,039 --> 00:25:19,320
similarly if you work backwards as still

582
00:25:19,320 --> 00:25:23,658
you run into the issue of having loopsy

583
00:25:23,700 --> 00:25:24,779
so

584
00:25:24,779 --> 00:25:28,980
the solution to this is actually a very

585
00:25:28,980 --> 00:25:31,140
old idea which is called mathematical

586
00:25:31,140 --> 00:25:32,279
induction

587
00:25:32,279 --> 00:25:35,700
so this is a very similar problem we see

588
00:25:35,700 --> 00:25:37,559
when we try to prove some mathematical

589
00:25:37,559 --> 00:25:39,900
properties say that we want to prove

590
00:25:39,900 --> 00:25:42,120
that a property holds for every natural

591
00:25:42,120 --> 00:25:45,120
number which means that probably holds

592
00:25:45,120 --> 00:25:47,279
for number zero one two blah blah blah

593
00:25:47,279 --> 00:25:50,520
blah and we do not try to enumerate

594
00:25:50,520 --> 00:25:52,200
everything right we do not try to

595
00:25:52,200 --> 00:25:54,179
enumerate all the natural numbers here

596
00:25:54,179 --> 00:25:56,880
and instead what we do is we do

597
00:25:56,880 --> 00:25:59,580
induction so we prove the base case

598
00:25:59,580 --> 00:26:01,500
holes and then we prove that the

599
00:26:01,500 --> 00:26:03,720
induction case holds as well and the

600
00:26:03,720 --> 00:26:05,580
base case basically well in a very

601
00:26:05,580 --> 00:26:06,480
simple

602
00:26:06,480 --> 00:26:10,200
um scheme you prove that P of zero holes

603
00:26:10,200 --> 00:26:13,380
like zero um the property holds at zero

604
00:26:13,380 --> 00:26:15,720
and then the induction case you prove

605
00:26:15,720 --> 00:26:17,220
that for every

606
00:26:17,220 --> 00:26:20,400
um value but this is natural number if

607
00:26:20,400 --> 00:26:23,159
this P of K holds and then this P of K

608
00:26:23,159 --> 00:26:26,760
plus one holds and if you have both

609
00:26:26,760 --> 00:26:28,980
conditions you can basically be sure

610
00:26:28,980 --> 00:26:31,200
that everything holds the whole

611
00:26:31,200 --> 00:26:34,320
proposition is it's true so this is how

612
00:26:34,320 --> 00:26:36,539
we do things by induction

613
00:26:36,539 --> 00:26:40,380
and if you look at the uh the similarity

614
00:26:40,380 --> 00:26:42,659
between this induction here and then the

615
00:26:42,659 --> 00:26:44,520
looping case

616
00:26:44,520 --> 00:26:47,100
um it's very similar like we in a loop

617
00:26:47,100 --> 00:26:48,779
if you follow down the path you're

618
00:26:48,779 --> 00:26:51,720
essentially doing P0 P1 p2n until the

619
00:26:51,720 --> 00:26:55,380
end but if you can convert that

620
00:26:55,380 --> 00:26:58,320
proposition into an induction you only

621
00:26:58,320 --> 00:27:00,059
need to do two proofs well in the base

622
00:27:00,059 --> 00:27:01,980
case the other induction case and that's

623
00:27:01,980 --> 00:27:04,380
all you don't need to keep looping there

624
00:27:04,380 --> 00:27:07,140
so the trick or the question is how do

625
00:27:07,140 --> 00:27:08,760
we convert that

626
00:27:08,760 --> 00:27:11,039
um into the interlooping that's all into

627
00:27:11,039 --> 00:27:12,419
the induction case

628
00:27:12,419 --> 00:27:15,659
and that is where we require the

629
00:27:15,659 --> 00:27:17,460
developer to provide the looping

630
00:27:17,460 --> 00:27:19,860
variants and these are the keys to break

631
00:27:19,860 --> 00:27:22,320
the Cycles in the control flow graph so

632
00:27:22,320 --> 00:27:24,120
a looping variant is basically

633
00:27:24,120 --> 00:27:26,340
transformed into something like an

634
00:27:26,340 --> 00:27:28,919
assertion at the very beginning and then

635
00:27:28,919 --> 00:27:33,500
a havoc and Assumption of the relations

636
00:27:33,500 --> 00:27:36,539
that should hold in the loop invariant

637
00:27:36,539 --> 00:27:39,360
and also a assertion at the very end of

638
00:27:39,360 --> 00:27:42,779
the bottom so if you just look at the

639
00:27:42,779 --> 00:27:45,120
the wording here the assertion the first

640
00:27:45,120 --> 00:27:47,220
assertion here is basically try to prove

641
00:27:47,220 --> 00:27:49,559
the base case right the base case should

642
00:27:49,559 --> 00:27:52,039
hold at the beginning of the loop

643
00:27:52,039 --> 00:27:55,140
and this havoc and assume is basically

644
00:27:55,140 --> 00:27:58,919
trying to say that the induction case

645
00:27:58,919 --> 00:28:01,799
he's trying to say that for us for for

646
00:28:01,799 --> 00:28:03,299
any

647
00:28:03,299 --> 00:28:04,140
um

648
00:28:04,140 --> 00:28:06,779
for any actuation in the loop

649
00:28:06,779 --> 00:28:09,480
um this thing should hold and we try to

650
00:28:09,480 --> 00:28:12,120
prove that at the end of the loop the

651
00:28:12,120 --> 00:28:13,919
the induction case should hold which

652
00:28:13,919 --> 00:28:16,440
means that P the the proposition of n

653
00:28:16,440 --> 00:28:19,679
plus one should hold so this is exactly

654
00:28:19,679 --> 00:28:24,179
what how we translate a a loop a loop

655
00:28:24,179 --> 00:28:27,360
program into a one without Loops so I

656
00:28:27,360 --> 00:28:29,159
think it's better Illustrated with the

657
00:28:29,159 --> 00:28:31,559
example here so here the difference

658
00:28:31,559 --> 00:28:33,120
between this one and the previous

659
00:28:33,120 --> 00:28:36,539
program is that we have two invariants

660
00:28:36,539 --> 00:28:40,020
here written as uh as part of a

661
00:28:40,020 --> 00:28:42,360
specification so this invariant

662
00:28:42,360 --> 00:28:44,520
basically says that it doesn't matter

663
00:28:44,520 --> 00:28:46,799
which accuration you are on in the loop

664
00:28:46,799 --> 00:28:49,320
these conditions must hold

665
00:28:49,320 --> 00:28:52,159
so these are some these are the the

666
00:28:52,159 --> 00:28:54,600
knowledge given by the developers

667
00:28:54,600 --> 00:28:57,240
similar to how you specify the insurers

668
00:28:57,240 --> 00:28:59,760
here so these are the invariants that

669
00:28:59,760 --> 00:29:02,340
must hold and if we have the inherence

670
00:29:02,340 --> 00:29:04,679
we can transform the program control

671
00:29:04,679 --> 00:29:08,279
flow graph from this way into this way

672
00:29:08,279 --> 00:29:11,700
so as we said it's assertion at the

673
00:29:11,700 --> 00:29:14,100
beginning basically asserting the base

674
00:29:14,100 --> 00:29:17,220
case hold and do a bunch of

675
00:29:17,220 --> 00:29:21,059
um do to establish that the P of K holes

676
00:29:21,059 --> 00:29:24,720
for nak here and then prove that the the

677
00:29:24,720 --> 00:29:27,480
pl of n plus sorry K plus one holds at

678
00:29:27,480 --> 00:29:29,720
the end so this is the induction case

679
00:29:29,720 --> 00:29:33,179
and with that with this whole thing we

680
00:29:33,179 --> 00:29:35,700
can further prove that on the final

681
00:29:35,700 --> 00:29:38,640
assertion holds as well so and if you

682
00:29:38,640 --> 00:29:40,679
look at this control flow graph you

683
00:29:40,679 --> 00:29:42,899
realize that the back Edge which is

684
00:29:42,899 --> 00:29:45,779
originally from B5 to B1 it's gone

685
00:29:45,779 --> 00:29:47,940
because we don't need to stock in the

686
00:29:47,940 --> 00:29:50,220
loop anymore we all we need to do is

687
00:29:50,220 --> 00:29:53,220
just follow the loop once and sorry for

688
00:29:53,220 --> 00:29:55,440
uh break the loop follow the control

689
00:29:55,440 --> 00:29:59,340
flow graph as the using the way well I

690
00:29:59,340 --> 00:30:00,539
mean follow the control flow of graph

691
00:30:00,539 --> 00:30:02,340
backwards using the way we describe just

692
00:30:02,340 --> 00:30:05,760
now and then get uh get the verification

693
00:30:05,760 --> 00:30:08,880
condition so here is just a just an

694
00:30:08,880 --> 00:30:11,340
illustration on how this is done which

695
00:30:11,340 --> 00:30:13,200
is still we follow the control flow

696
00:30:13,200 --> 00:30:16,080
graph from here back to b0 and then we

697
00:30:16,080 --> 00:30:18,120
get everything

698
00:30:18,120 --> 00:30:20,399
um the condition on on all the basic

699
00:30:20,399 --> 00:30:22,200
blocks and then we prove that b0 must be

700
00:30:22,200 --> 00:30:22,919
true

701
00:30:22,919 --> 00:30:26,820
so this is how we handle Loops but of

702
00:30:26,820 --> 00:30:28,919
course there is a downside here which

703
00:30:28,919 --> 00:30:31,799
means this looping variance needs to be

704
00:30:31,799 --> 00:30:34,980
given by the developers or needs to be

705
00:30:34,980 --> 00:30:36,419
given by whoever writes the

706
00:30:36,419 --> 00:30:38,520
specifications otherwise the prover is

707
00:30:38,520 --> 00:30:41,159
going to have a hard time proving the

708
00:30:41,159 --> 00:30:42,600
final results

709
00:30:42,600 --> 00:30:46,260
so there's some ongoing work we try to

710
00:30:46,260 --> 00:30:48,840
we're exploring that we try to eliminate

711
00:30:48,840 --> 00:30:51,960
away or eliminate the need that the

712
00:30:51,960 --> 00:30:53,840
developer need to provide the invariants

713
00:30:53,840 --> 00:30:56,760
so if you have good ideas or if you have

714
00:30:56,760 --> 00:30:59,700
good Solutions or just some ideas do let

715
00:30:59,700 --> 00:31:02,520
us know and we'll be very interested to

716
00:31:02,520 --> 00:31:04,980
see how this thing works on the real

717
00:31:04,980 --> 00:31:07,320
world applications

718
00:31:07,320 --> 00:31:08,279
thank you

719
00:31:08,279 --> 00:31:10,860
so that's about

720
00:31:10,860 --> 00:31:13,140
and then the very last thing that is

721
00:31:13,140 --> 00:31:15,000
related to

722
00:31:15,000 --> 00:31:17,700
the verification problem is how do we

723
00:31:17,700 --> 00:31:21,299
model mutations or references or the

724
00:31:21,299 --> 00:31:24,299
memory so these are like

725
00:31:24,299 --> 00:31:28,140
similar words or like ALS words that can

726
00:31:28,140 --> 00:31:30,480
be used in interchangeably

727
00:31:30,480 --> 00:31:32,760
the reason we need to model memory or

728
00:31:32,760 --> 00:31:36,779
reference is that in most smt theories

729
00:31:36,779 --> 00:31:40,919
there's just no way of encoding that you

730
00:31:40,919 --> 00:31:43,020
updated something in place

731
00:31:43,020 --> 00:31:46,820
now if you look at smt array

732
00:31:46,820 --> 00:31:49,919
smpre Theory you realize that if you

733
00:31:49,919 --> 00:31:53,120
have an update on certain indexing array

734
00:31:53,120 --> 00:31:57,960
you what iris Theory gives you is a new

735
00:31:57,960 --> 00:32:01,380
um new array that has everything being

736
00:32:01,380 --> 00:32:04,799
the same with all one except this the

737
00:32:04,799 --> 00:32:06,480
index gets updated

738
00:32:06,480 --> 00:32:09,899
so there's no way of updating a in place

739
00:32:09,899 --> 00:32:13,380
what you always get is a prime which is

740
00:32:13,380 --> 00:32:15,899
a it's almost the same version of a but

741
00:32:15,899 --> 00:32:19,260
with only the the K index the value at

742
00:32:19,260 --> 00:32:21,120
the key index gets updated

743
00:32:21,120 --> 00:32:24,360
and similarly uh SMP structs follow the

744
00:32:24,360 --> 00:32:27,960
same notion if you for example assign a

745
00:32:27,960 --> 00:32:31,140
new value to a field in the smt struct

746
00:32:31,140 --> 00:32:33,419
well to be specific it should be smt

747
00:32:33,419 --> 00:32:37,500
data type what you get is not as gets

748
00:32:37,500 --> 00:32:41,100
updated instead you get a new s with

749
00:32:41,100 --> 00:32:43,020
everything being the same with a

750
00:32:43,020 --> 00:32:46,260
previous s except the fields that gets

751
00:32:46,260 --> 00:32:47,159
updated

752
00:32:47,159 --> 00:32:50,220
so that's that's the notion here so

753
00:32:50,220 --> 00:32:52,620
there's a mismatch between how you will

754
00:32:52,620 --> 00:32:55,919
program in in move or in Russia in C

755
00:32:55,919 --> 00:32:58,980
versus how the encoding on the smt side

756
00:32:58,980 --> 00:33:02,580
works so there's no In-Place update

757
00:33:02,580 --> 00:33:06,200
um in the smt world

758
00:33:06,200 --> 00:33:09,000
so what what we need to do is basically

759
00:33:09,000 --> 00:33:10,980
we need to bridge the gap right we need

760
00:33:10,980 --> 00:33:14,279
to we need to tell or when you encode

761
00:33:14,279 --> 00:33:16,440
whenever we have a update to the

762
00:33:16,440 --> 00:33:18,360
reference we need to encode that

763
00:33:18,360 --> 00:33:21,179
information into something that there is

764
00:33:21,179 --> 00:33:23,279
update there is a new value created and

765
00:33:23,279 --> 00:33:26,640
please view that new man so this is uh

766
00:33:26,640 --> 00:33:29,039
the the thing we need to solve

767
00:33:29,039 --> 00:33:31,740
and the way we do that in the approver

768
00:33:31,740 --> 00:33:34,260
side is basically eliminating all the

769
00:33:34,260 --> 00:33:37,440
references so which means that when

770
00:33:37,440 --> 00:33:39,659
approvers sees a move program and after

771
00:33:39,659 --> 00:33:42,059
the Transformations approver will not

772
00:33:42,059 --> 00:33:44,399
see any reference anymore and everything

773
00:33:44,399 --> 00:33:47,580
becomes value to that so here is a

774
00:33:47,580 --> 00:33:49,679
here's the enable which is the borrow

775
00:33:49,679 --> 00:33:52,799
semantics as we mentioned is a one key

776
00:33:52,799 --> 00:33:54,360
design

777
00:33:54,360 --> 00:33:57,779
choice move the move language make so

778
00:33:57,779 --> 00:33:59,760
it's similar to how the rust borrow

779
00:33:59,760 --> 00:34:02,159
semantics work so if you see a function

780
00:34:02,159 --> 00:34:04,679
which takes two arguments one is a

781
00:34:04,679 --> 00:34:06,299
mutable reference the other is a

782
00:34:06,299 --> 00:34:08,639
immutable reference you can almost

783
00:34:08,639 --> 00:34:12,239
immediately be sure that A and B are

784
00:34:12,239 --> 00:34:14,099
never pointing to the same memory

785
00:34:14,099 --> 00:34:16,918
location because there's just no way you

786
00:34:16,918 --> 00:34:19,139
can borrow both a mutable version and

787
00:34:19,139 --> 00:34:21,300
immutable version of the same memory

788
00:34:21,300 --> 00:34:22,918
location well let's assume you're

789
00:34:22,918 --> 00:34:25,619
staying safe last and same applies to

790
00:34:25,619 --> 00:34:29,639
move if we see this code the prover

791
00:34:29,639 --> 00:34:33,060
immediately know that there's no worry

792
00:34:33,060 --> 00:34:36,060
that A and B might be aliasing so this

793
00:34:36,060 --> 00:34:40,199
is a huge benefit for the verification

794
00:34:40,199 --> 00:34:42,439
foreign

795
00:34:43,040 --> 00:34:45,839
semantics a more proverb can leverage

796
00:34:45,839 --> 00:34:49,199
this one to eliminate all the references

797
00:34:49,199 --> 00:34:50,760
in the profile

798
00:34:50,760 --> 00:34:53,460
so here is how a move proverb will

799
00:34:53,460 --> 00:34:55,918
translate to program with reference into

800
00:34:55,918 --> 00:34:58,440
the one without a reference so you

801
00:34:58,440 --> 00:35:01,740
although this is written in the rust

802
00:35:01,740 --> 00:35:03,720
syntax you can imagine that these are

803
00:35:03,720 --> 00:35:05,520
smt data types

804
00:35:05,520 --> 00:35:08,940
so any any reference or any mutation

805
00:35:08,940 --> 00:35:11,820
will be consisting of a root which is

806
00:35:11,820 --> 00:35:15,119
where this mutation comes from and how

807
00:35:15,119 --> 00:35:17,520
what is a borrowed chain from this

808
00:35:17,520 --> 00:35:21,119
mutation as well as the current value at

809
00:35:21,119 --> 00:35:23,940
this and this mutation so all the

810
00:35:23,940 --> 00:35:26,700
reference are going to be converted into

811
00:35:26,700 --> 00:35:31,680
asmd struct which has three fields in

812
00:35:31,680 --> 00:35:32,820
the struct

813
00:35:32,820 --> 00:35:35,880
and here is a more concrete example if

814
00:35:35,880 --> 00:35:38,280
we have a struct that defines has two

815
00:35:38,280 --> 00:35:41,760
fields and a rust program which takes a

816
00:35:41,760 --> 00:35:45,420
mutable reference and modify this

817
00:35:45,420 --> 00:35:48,060
reference in place and then returns

818
00:35:48,060 --> 00:35:50,579
what the prover sees or what the program

819
00:35:50,579 --> 00:35:52,920
will after the transformation will

820
00:35:52,920 --> 00:35:55,680
eventually see is that this function

821
00:35:55,680 --> 00:35:58,079
takes a mutation and returns a mutation

822
00:35:58,079 --> 00:36:01,619
and this one represents the old value of

823
00:36:01,619 --> 00:36:04,320
x and then this mutation represents the

824
00:36:04,320 --> 00:36:06,740
new value of x

825
00:36:06,740 --> 00:36:10,260
and after the bunch of Transformations

826
00:36:10,260 --> 00:36:12,780
it will the proverb will basically

827
00:36:12,780 --> 00:36:16,020
approve or show that the MU the return

828
00:36:16,020 --> 00:36:18,839
value which is the new mutation has the

829
00:36:18,839 --> 00:36:22,380
same root has the same path has the same

830
00:36:22,380 --> 00:36:24,660
value except the first field which is

831
00:36:24,660 --> 00:36:25,920
set to 1.

832
00:36:25,920 --> 00:36:29,540
so this is how the prover encoder things

833
00:36:29,540 --> 00:36:33,240
and if you if you think about this

834
00:36:33,240 --> 00:36:36,300
versus the SNP uh array Theory so this

835
00:36:36,300 --> 00:36:39,240
is very friendly to the smt solvers

836
00:36:39,240 --> 00:36:41,220
because the solvers don't understand

837
00:36:41,220 --> 00:36:43,260
what a reference means but they do

838
00:36:43,260 --> 00:36:45,540
understand what the mutual or what a

839
00:36:45,540 --> 00:36:48,000
value means so it's easy to basically

840
00:36:48,000 --> 00:36:50,640
update the value create a value and

841
00:36:50,640 --> 00:36:52,800
sorry take the new pick an old value and

842
00:36:52,800 --> 00:36:54,960
then put a new manual for them

843
00:36:54,960 --> 00:36:57,900
so then the rest of the slides are

844
00:36:57,900 --> 00:37:00,900
basically showing that we are not only

845
00:37:00,900 --> 00:37:03,839
able to encode very simple things like

846
00:37:03,839 --> 00:37:07,980
we have a immediate uh update and then

847
00:37:07,980 --> 00:37:09,780
we just create a ref query the mutation

848
00:37:09,780 --> 00:37:12,420
we convert reference to a mutation and

849
00:37:12,420 --> 00:37:15,300
when we do a struct field update and

850
00:37:15,300 --> 00:37:17,220
then we get a new thing so that's a very

851
00:37:17,220 --> 00:37:20,099
simple case we can also do conditional

852
00:37:20,099 --> 00:37:22,500
bottles so if you borrow conditionally

853
00:37:22,500 --> 00:37:24,900
on different fields

854
00:37:24,900 --> 00:37:28,859
from the from the struct we can encode

855
00:37:28,859 --> 00:37:34,320
that with uh with the data type as well

856
00:37:34,320 --> 00:37:36,480
so all you need to do is basically

857
00:37:36,480 --> 00:37:39,540
follow the program here and then create

858
00:37:39,540 --> 00:37:42,300
two mutations one representing the first

859
00:37:42,300 --> 00:37:44,099
borrow the other representing the second

860
00:37:44,099 --> 00:37:45,960
borrow and then the two mutation

861
00:37:45,960 --> 00:37:48,780
basically the two values are decided by

862
00:37:48,780 --> 00:37:52,380
this Boolean condition and after that if

863
00:37:52,380 --> 00:37:55,200
you do a right if you do an update it's

864
00:37:55,200 --> 00:37:57,599
basically updating one of the mutations

865
00:37:57,599 --> 00:37:59,460
and then at the end we can actually

866
00:37:59,460 --> 00:38:02,640
check which mutation you are trying to

867
00:38:02,640 --> 00:38:04,500
update if you are updating the first

868
00:38:04,500 --> 00:38:06,420
field we are going to update the

869
00:38:06,420 --> 00:38:08,040
mutation of the first field and if

870
00:38:08,040 --> 00:38:09,960
you're updating the second one we up in

871
00:38:09,960 --> 00:38:13,280
the second one so all these can be

872
00:38:13,280 --> 00:38:16,140
elegantly encoded with the mutation

873
00:38:16,140 --> 00:38:18,420
scheme

874
00:38:18,420 --> 00:38:21,000
so these are just small slides to show

875
00:38:21,000 --> 00:38:23,579
that we can handle complicated examples

876
00:38:23,579 --> 00:38:27,240
like different types of borrows and

877
00:38:27,240 --> 00:38:30,359
borrow cross functions they can all be

878
00:38:30,359 --> 00:38:34,260
elegantly included with the the mutation

879
00:38:34,260 --> 00:38:36,300
modeling

880
00:38:36,300 --> 00:38:41,099
so that's about the memory model so it's

881
00:38:41,099 --> 00:38:43,740
it's not directly related to C and C

882
00:38:43,740 --> 00:38:46,079
plus plus because C and C plus plus

883
00:38:46,079 --> 00:38:49,619
doesn't have this borrow mutation but if

884
00:38:49,619 --> 00:38:52,500
you want to work on Raw verification and

885
00:38:52,500 --> 00:38:54,720
or if you want to stay within safe for

886
00:38:54,720 --> 00:38:57,900
us so this is one type of memory model

887
00:38:57,900 --> 00:39:00,920
you might want to consider

888
00:39:00,920 --> 00:39:04,320
so I'll briefly talk about what are the

889
00:39:04,320 --> 00:39:06,240
future directions uh in terms of

890
00:39:06,240 --> 00:39:08,460
research what we can do given the

891
00:39:08,460 --> 00:39:10,260
experience and given the techniques we

892
00:39:10,260 --> 00:39:11,339
already have

893
00:39:11,339 --> 00:39:13,980
so one thing is that as we said the

894
00:39:13,980 --> 00:39:16,200
programs returning CC platform Java they

895
00:39:16,200 --> 00:39:18,240
don't follow the spiral semantics if you

896
00:39:18,240 --> 00:39:21,540
see two pointers uh in C there's really

897
00:39:21,540 --> 00:39:23,060
no much information

898
00:39:23,060 --> 00:39:25,920
there's really nothing you can say based

899
00:39:25,920 --> 00:39:28,380
on that type to know that they don't

900
00:39:28,380 --> 00:39:32,099
alias so in order to solve that we we

901
00:39:32,099 --> 00:39:33,960
can still use the progress memory model

902
00:39:33,960 --> 00:39:37,200
but we need two things one is we need a

903
00:39:37,200 --> 00:39:40,320
ride back that's very early and we also

904
00:39:40,320 --> 00:39:42,599
need to have a write down

905
00:39:42,599 --> 00:39:46,260
um these are more Primitives or more SMP

906
00:39:46,260 --> 00:39:47,760
constructs we need to introduce to

907
00:39:47,760 --> 00:39:51,240
proverb in order to support the case

908
00:39:51,240 --> 00:39:53,760
where there could be different or there

909
00:39:53,760 --> 00:39:56,339
could be Als in the pointers in CNC plus

910
00:39:56,339 --> 00:39:57,900
programs

911
00:39:57,900 --> 00:40:02,339
and another potential research Direction

912
00:40:02,339 --> 00:40:05,520
is on applying this backward symbolic

913
00:40:05,520 --> 00:40:08,579
execution for complex problems

914
00:40:08,579 --> 00:40:11,460
so what we see just now are backwards

915
00:40:11,460 --> 00:40:14,280
symbol execution for simple programs and

916
00:40:14,280 --> 00:40:17,880
even that it already creates a large or

917
00:40:17,880 --> 00:40:20,339
a relatively large in terms of the size

918
00:40:20,339 --> 00:40:23,520
of SNP formulas and if you bring in more

919
00:40:23,520 --> 00:40:25,920
complex programs you can reasonably

920
00:40:25,920 --> 00:40:28,260
expect that the formula are going to be

921
00:40:28,260 --> 00:40:31,619
even larger so and with even larger

922
00:40:31,619 --> 00:40:34,560
program uh how there's a chance that the

923
00:40:34,560 --> 00:40:36,660
smt solver is going to give up it's

924
00:40:36,660 --> 00:40:38,940
going to timeout and tell you that I

925
00:40:38,940 --> 00:40:41,940
don't know how to solve it

926
00:40:41,940 --> 00:40:45,900
so to be practical and then make it

927
00:40:45,900 --> 00:40:47,640
really working instead of just giving

928
00:40:47,640 --> 00:40:51,480
your time out we can do something like a

929
00:40:51,480 --> 00:40:53,760
partial concretization so here is a

930
00:40:53,760 --> 00:40:56,339
general procedure so let's start from a

931
00:40:56,339 --> 00:40:58,980
code location where we think that there

932
00:40:58,980 --> 00:41:00,960
might be a vulnerability say that we

933
00:41:00,960 --> 00:41:02,760
think there might be a memory error in

934
00:41:02,760 --> 00:41:05,220
this part of C code and then we start

935
00:41:05,220 --> 00:41:07,500
from there we do a World Cup in the

936
00:41:07,500 --> 00:41:09,839
control flow graph following the the

937
00:41:09,839 --> 00:41:11,820
rules we showed just now and then get

938
00:41:11,820 --> 00:41:14,220
the condition for the first the entry

939
00:41:14,220 --> 00:41:15,859
part of the function

940
00:41:15,859 --> 00:41:19,680
and if this the whole formula cannot be

941
00:41:19,680 --> 00:41:22,079
proved by the solver we try to find some

942
00:41:22,079 --> 00:41:24,060
intermediate states where the program

943
00:41:24,060 --> 00:41:25,980
can where sorry where the solver can

944
00:41:25,980 --> 00:41:28,619
handle I know we concretize part of the

945
00:41:28,619 --> 00:41:30,900
three variables so one reason the free

946
00:41:30,900 --> 00:41:33,180
the solver cannot handle is likely

947
00:41:33,180 --> 00:41:35,160
because there's just too many free

948
00:41:35,160 --> 00:41:37,560
variables there so we concretize them to

949
00:41:37,560 --> 00:41:39,839
ease the burden on the solver and then

950
00:41:39,839 --> 00:41:42,480
see whether it gets bikes gets better

951
00:41:42,480 --> 00:41:45,900
and if with some concurization we get

952
00:41:45,900 --> 00:41:48,300
lucky and then the solver actually come

953
00:41:48,300 --> 00:41:51,420
up with some positive answers and then

954
00:41:51,420 --> 00:41:53,760
we know that we either get a counter

955
00:41:53,760 --> 00:41:56,339
example which can trigger above or we

956
00:41:56,339 --> 00:41:57,900
didn't get a country example and then we

957
00:41:57,900 --> 00:42:00,480
tried another set of complementation or

958
00:42:00,480 --> 00:42:02,339
we need to concretize more

959
00:42:02,339 --> 00:42:07,740
so these are like up like practices that

960
00:42:07,740 --> 00:42:09,780
make the whole thing practical and

961
00:42:09,780 --> 00:42:12,359
currently I'm not seeing too much of uh

962
00:42:12,359 --> 00:42:15,420
working in this direction

963
00:42:15,420 --> 00:42:18,599
and similarly we can apply the workflow

964
00:42:18,599 --> 00:42:22,440
for AEG automated exploit generation so

965
00:42:22,440 --> 00:42:24,060
essentially it's the same procedure

966
00:42:24,060 --> 00:42:27,660
except that in in in terms of finding a

967
00:42:27,660 --> 00:42:31,619
vulnerable location we try to find the

968
00:42:31,619 --> 00:42:33,780
vulnerability that a final location

969
00:42:33,780 --> 00:42:37,200
where this vulnerability crash the

970
00:42:37,200 --> 00:42:39,240
program and then we work backwards to

971
00:42:39,240 --> 00:42:42,180
see what are the damages we can further

972
00:42:42,180 --> 00:42:46,260
exploit from this this vulnerability so

973
00:42:46,260 --> 00:42:48,960
these are some of the research things

974
00:42:48,960 --> 00:42:52,079
that comes directly from the move prover

975
00:42:52,079 --> 00:42:53,160
project

976
00:42:53,160 --> 00:42:56,280
and with that that will be the

977
00:42:56,280 --> 00:42:59,099
conclusion of the talk and thank you for

978
00:42:59,099 --> 00:43:00,960
the listening and thanks again for the

979
00:43:00,960 --> 00:43:03,060
invitation as well

980
00:43:03,060 --> 00:43:06,900
so I'm going to see if there are

981
00:43:06,900 --> 00:43:09,619
questions

982
00:43:09,900 --> 00:43:12,480
in the chat

983
00:43:12,480 --> 00:43:16,740
so I see one question in a chat which is

984
00:43:16,740 --> 00:43:19,800
what would changing the memory model if

985
00:43:19,800 --> 00:43:22,380
both the arguments were mutable

986
00:43:22,380 --> 00:43:24,300
references

987
00:43:24,300 --> 00:43:26,000
um

988
00:43:26,000 --> 00:43:29,040
so let me try to

989
00:43:29,040 --> 00:43:31,980
get here so if

990
00:43:31,980 --> 00:43:34,619
both the arguments are mutable

991
00:43:34,619 --> 00:43:37,500
references you can still be certain that

992
00:43:37,500 --> 00:43:40,440
none of them are going to be added right

993
00:43:40,440 --> 00:43:43,859
you just cannot borrow two copies of the

994
00:43:43,859 --> 00:43:46,140
two mutable copies of the same thing

995
00:43:46,140 --> 00:43:49,380
from the same object so you still be

996
00:43:49,380 --> 00:43:52,020
sure that both of them are going to be

997
00:43:52,020 --> 00:43:55,920
non-aliasing and if you have two

998
00:43:55,920 --> 00:43:59,160
arguments or most mutable references you

999
00:43:59,160 --> 00:44:02,400
are going to return a tuple which

1000
00:44:02,400 --> 00:44:05,099
takes into Old mutations and return to

1001
00:44:05,099 --> 00:44:07,920
an old mutations so that's

1002
00:44:07,920 --> 00:44:11,000
that's the solution

1003
00:44:17,700 --> 00:44:21,599
so I guess we still have couple minutes

1004
00:44:21,599 --> 00:44:24,000
so if you have more questions

1005
00:44:24,000 --> 00:44:27,780
um do ask in the Q a so I'll try to

1006
00:44:27,780 --> 00:44:30,319
answer them

1007
00:45:00,180 --> 00:45:04,098
so I guess there's no more questions

1008
00:45:05,540 --> 00:45:09,420
there's another one why can't we use the

1009
00:45:09,420 --> 00:45:14,000
SSA fall backward symbolic execution

1010
00:45:14,000 --> 00:45:19,400
uh why can't we use SSA for this

1011
00:45:19,619 --> 00:45:22,440
um uh that's probably because if you see

1012
00:45:22,440 --> 00:45:25,700
a final here sorry this is the SSA form

1013
00:45:25,700 --> 00:45:30,119
and if you see a fine note here it

1014
00:45:30,119 --> 00:45:33,660
you really don't know

1015
00:45:33,660 --> 00:45:36,060
the final only makes sense if you do

1016
00:45:36,060 --> 00:45:38,640
this in a forward way because you know

1017
00:45:38,640 --> 00:45:41,280
where these finals coming from I mean

1018
00:45:41,280 --> 00:45:44,160
where the the two possibility of this

1019
00:45:44,160 --> 00:45:47,160
final coming from but if you do this in

1020
00:45:47,160 --> 00:45:49,920
a backward way there's really no idea on

1021
00:45:49,920 --> 00:45:54,180
how you would know where this R3 is

1022
00:45:54,180 --> 00:45:56,640
going to be assigned from

1023
00:45:56,640 --> 00:45:59,880
so it's better to eagerly lift them up

1024
00:45:59,880 --> 00:46:02,460
into the place where it's supposed to be

1025
00:46:02,460 --> 00:46:04,980
defined and then go from there

1026
00:46:04,980 --> 00:46:08,780
so that's the reason it's more like a

1027
00:46:08,780 --> 00:46:10,980
engineering or

1028
00:46:10,980 --> 00:46:13,440
it's probably not really a theory based

1029
00:46:13,440 --> 00:46:14,819
thing but more like Engineering

1030
00:46:14,819 --> 00:46:17,240
University

1031
00:46:19,020 --> 00:46:22,140
okay so if there's no questions I'll

1032
00:46:22,140 --> 00:46:24,780
stop sharing and I'll pass the stage to

1033
00:46:24,780 --> 00:46:27,800
Mike great

1034
00:46:28,200 --> 00:46:29,940
yeah I don't see any more questions here

1035
00:46:29,940 --> 00:46:32,220
but among thank you so much we really

1036
00:46:32,220 --> 00:46:36,060
appreciate uh you joining us this week

1037
00:46:36,060 --> 00:46:38,579
um really great really great uh

1038
00:46:38,579 --> 00:46:41,339
uh talk here great research that you're

1039
00:46:41,339 --> 00:46:42,540
doing there

1040
00:46:42,540 --> 00:46:45,839
um thank you thank you yeah so uh so

1041
00:46:45,839 --> 00:46:48,119
viewers uh next week will be our last

1042
00:46:48,119 --> 00:46:49,680
week for this semester I can't believe

1043
00:46:49,680 --> 00:46:51,780
it's been going by so fast

1044
00:46:51,780 --> 00:46:54,599
um so you can join us same time 4 30 p.m

1045
00:46:54,599 --> 00:46:56,819
Eastern Time

1046
00:46:56,819 --> 00:46:58,980
thanks a lot thanks thanks Mong take

1047
00:46:58,980 --> 00:47:02,700
care thanks take care bye

1048
00:47:02,700 --> 00:47:05,700
foreign

