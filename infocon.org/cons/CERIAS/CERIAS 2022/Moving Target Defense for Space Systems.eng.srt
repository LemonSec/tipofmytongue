1
00:00:00,060 --> 00:00:02,940
uh good afternoon and uh welcome to the

2
00:00:02,940 --> 00:00:05,700
Purdue security seminar live from Purdue

3
00:00:05,700 --> 00:00:07,980
University whether you are live in the

4
00:00:07,980 --> 00:00:10,860
audience or live virtual or not so live

5
00:00:10,860 --> 00:00:12,599
and viewing this as a recording later on

6
00:00:12,599 --> 00:00:16,800
so uh I've had uh the great pleasure of

7
00:00:16,800 --> 00:00:19,500
knowing our speaker today for eight

8
00:00:19,500 --> 00:00:21,180
years did you realize that eight years

9
00:00:21,180 --> 00:00:24,840
yeah so our our speaker today is a Chris

10
00:00:24,840 --> 00:00:27,900
Jenkins uh Dr Jenkins is a prison as a

11
00:00:27,900 --> 00:00:29,699
principal member of the technical staff

12
00:00:29,699 --> 00:00:31,619
in the systems security research

13
00:00:31,619 --> 00:00:34,079
department at Sandia National Lab a

14
00:00:34,079 --> 00:00:36,600
department of energy National Lab in

15
00:00:36,600 --> 00:00:37,980
their information operations center

16
00:00:37,980 --> 00:00:40,739
Chris supports sandia's mission in three

17
00:00:40,739 --> 00:00:42,960
key areas cyber physical security

18
00:00:42,960 --> 00:00:44,180
research

19
00:00:44,180 --> 00:00:47,520
and high performance Computing did I cut

20
00:00:47,520 --> 00:00:49,079
and paste something out that I'm at

21
00:00:49,079 --> 00:00:51,360
silky area Okay in these two key areas

22
00:00:51,360 --> 00:00:54,680
okay you may want to go

23
00:00:54,680 --> 00:00:58,320
but back in 2014 Kristen his very first

24
00:00:58,320 --> 00:01:00,539
trip to Purdue and I had the Great honor

25
00:01:00,539 --> 00:01:02,219
of being his host during that during

26
00:01:02,219 --> 00:01:06,119
that that trip uh we uh we bonded well

27
00:01:06,119 --> 00:01:08,040
and have maintained contact and and

28
00:01:08,040 --> 00:01:09,420
talked basketball college basketball

29
00:01:09,420 --> 00:01:12,060
whenever we have the opportunity uh but

30
00:01:12,060 --> 00:01:13,680
Chris has been back to campus many times

31
00:01:13,680 --> 00:01:15,240
since then as he is the principal

32
00:01:15,240 --> 00:01:19,140
investigator on a Sandy a funded uh

33
00:01:19,140 --> 00:01:21,600
research project with several uh Purdue

34
00:01:21,600 --> 00:01:23,759
faculty members again Chris always great

35
00:01:23,759 --> 00:01:25,979
to have you back on campus and thanks uh

36
00:01:25,979 --> 00:01:27,479
again for supporting our research

37
00:01:27,479 --> 00:01:29,759
Mission as we support your your research

38
00:01:29,759 --> 00:01:32,400
Mission thank you for that introduction

39
00:01:32,400 --> 00:01:34,860
uh once again my name is Chris Jenkins

40
00:01:34,860 --> 00:01:37,259
it feels good to be here I'm back at

41
00:01:37,259 --> 00:01:39,600
Purdue University as Joel mentioned I

42
00:01:39,600 --> 00:01:41,759
think I gave my first presentation back

43
00:01:41,759 --> 00:01:45,299
in 2014. I'm not realizing how many more

44
00:01:45,299 --> 00:01:47,640
times I would come back to Purdue to not

45
00:01:47,640 --> 00:01:49,320
only present here but to do research

46
00:01:49,320 --> 00:01:51,899
collaboration with other faculty So

47
00:01:51,899 --> 00:01:53,399
today we're going to speak about two

48
00:01:53,399 --> 00:01:55,320
different projects um this one called

49
00:01:55,320 --> 00:01:57,240
movie Target defense for Space Systems

50
00:01:57,240 --> 00:01:59,520
it has completed but it's some work that

51
00:01:59,520 --> 00:02:02,159
we did could do we have one impending

52
00:02:02,159 --> 00:02:04,200
publication on this work and then also

53
00:02:04,200 --> 00:02:06,719
we started a new research program here

54
00:02:06,719 --> 00:02:08,758
with Professor Barat a biographer at

55
00:02:08,758 --> 00:02:10,380
Purdue and we're also going to speak to

56
00:02:10,380 --> 00:02:11,819
that a little bit as well and also I

57
00:02:11,819 --> 00:02:14,459
have my extreme Kylie Jason Hamlin in

58
00:02:14,459 --> 00:02:16,080
the office as you mean the audience here

59
00:02:16,080 --> 00:02:18,500
as well

60
00:02:19,500 --> 00:02:22,560
so for the first presentation we're

61
00:02:22,560 --> 00:02:23,700
going to speak a little bit about why

62
00:02:23,700 --> 00:02:25,739
this work was done give everyone in the

63
00:02:25,739 --> 00:02:28,319
audience some information about moving

64
00:02:28,319 --> 00:02:30,180
Target defense and middle standard 1553

65
00:02:30,180 --> 00:02:32,040
we're going to look at the MTV algorithm

66
00:02:32,040 --> 00:02:34,620
that we've come up with at Sandia some

67
00:02:34,620 --> 00:02:36,180
of the features and attributes of that

68
00:02:36,180 --> 00:02:38,160
algorithm look at the experimentation

69
00:02:38,160 --> 00:02:39,959
that we conducted to prove the algorithm

70
00:02:39,959 --> 00:02:42,900
Works in real-time systems and then also

71
00:02:42,900 --> 00:02:44,640
look at what the work we're doing with

72
00:02:44,640 --> 00:02:46,019
Purdue regarding machine learning

73
00:02:46,019 --> 00:02:48,420
attacks how they defeated our algorithm

74
00:02:48,420 --> 00:02:50,700
and then by changing one line of code

75
00:02:50,700 --> 00:02:53,400
making it much tougher to defeat and

76
00:02:53,400 --> 00:02:55,080
then I also will look at the second

77
00:02:55,080 --> 00:02:56,580
project that we're working on to do

78
00:02:56,580 --> 00:02:58,920
right now that started this year called

79
00:02:58,920 --> 00:03:00,599
Chris and produce impact for that

80
00:03:00,599 --> 00:03:02,840
project

81
00:03:04,019 --> 00:03:06,120
so a little bit about the work before we

82
00:03:06,120 --> 00:03:08,160
get into it so we were able to get a

83
00:03:08,160 --> 00:03:09,720
patent on the algorithm for this work

84
00:03:09,720 --> 00:03:12,300
and optane copyright which is just a

85
00:03:12,300 --> 00:03:14,099
fancy way to say that the United States

86
00:03:14,099 --> 00:03:16,140
government can use this software if they

87
00:03:16,140 --> 00:03:18,420
need to for governmental entities the

88
00:03:18,420 --> 00:03:20,879
key results for this work is that we

89
00:03:20,879 --> 00:03:22,200
were able to reduce the adversarial

90
00:03:22,200 --> 00:03:24,599
knowledge by 97 during our exfiltration

91
00:03:24,599 --> 00:03:26,099
attack and we'll get into that

92
00:03:26,099 --> 00:03:27,599
throughout the presentation we're also

93
00:03:27,599 --> 00:03:30,659
able to quantify Randomness and also

94
00:03:30,659 --> 00:03:32,340
based on the work that was done here at

95
00:03:32,340 --> 00:03:35,159
Purdue improved the algorithm design to

96
00:03:35,159 --> 00:03:36,720
defeat some of the machine learning

97
00:03:36,720 --> 00:03:38,519
attacks and when you see a list of

98
00:03:38,519 --> 00:03:40,799
Publications that we have presented this

99
00:03:40,799 --> 00:03:43,500
work in as well as a pending Journal

100
00:03:43,500 --> 00:03:44,940
publication for some of the work done

101
00:03:44,940 --> 00:03:47,659
here at Purdue

102
00:03:49,220 --> 00:03:51,959
so first why is this work being done

103
00:03:51,959 --> 00:03:54,239
what do we want to do and so the first

104
00:03:54,239 --> 00:03:56,099
thing I mentioned is Satellite Systems

105
00:03:56,099 --> 00:03:57,900
right we want to look at ways to protect

106
00:03:57,900 --> 00:04:00,420
Satellite Systems as some of you may

107
00:04:00,420 --> 00:04:03,000
have been aware just like we had cyber

108
00:04:03,000 --> 00:04:05,220
attacks and terrestrial networks

109
00:04:05,220 --> 00:04:06,900
um space a lot of time is seen as the

110
00:04:06,900 --> 00:04:08,159
next Frontier

111
00:04:08,159 --> 00:04:10,560
of where the Cyber domain can go and so

112
00:04:10,560 --> 00:04:12,780
a lot of our work as Joel mentioned in

113
00:04:12,780 --> 00:04:14,220
my introduction is looking at Cyber

114
00:04:14,220 --> 00:04:16,440
physical systems and in my particular

115
00:04:16,440 --> 00:04:18,000
case some of those High consequence

116
00:04:18,000 --> 00:04:20,339
systems to say if they are attacked as

117
00:04:20,339 --> 00:04:22,139
most of these systems now are being

118
00:04:22,139 --> 00:04:23,639
connected to different networks in one

119
00:04:23,639 --> 00:04:25,680
way or another we want to make sure that

120
00:04:25,680 --> 00:04:28,259
these systems stay protected

121
00:04:28,259 --> 00:04:30,660
and so for This research

122
00:04:30,660 --> 00:04:33,419
the hypothesis that we have is that the

123
00:04:33,419 --> 00:04:35,699
integration of MTD with real-time

124
00:04:35,699 --> 00:04:37,919
protocol can increase the Cyber

125
00:04:37,919 --> 00:04:39,120
resilience

126
00:04:39,120 --> 00:04:41,160
and so the two key research questions

127
00:04:41,160 --> 00:04:44,400
that we have one can it be implemented

128
00:04:44,400 --> 00:04:47,820
in our case can MTD be implemented in a

129
00:04:47,820 --> 00:04:49,139
manner that maintains operational

130
00:04:49,139 --> 00:04:51,419
constraints I.E the protocol still works

131
00:04:51,419 --> 00:04:54,479
as it intends to and two can we provide

132
00:04:54,479 --> 00:04:57,600
quantitative evidence that MTD does in

133
00:04:57,600 --> 00:04:59,400
fact improve cyber resilience and we

134
00:04:59,400 --> 00:05:01,380
believe the uniqueness of this work is

135
00:05:01,380 --> 00:05:03,000
that we're focusing on real-time SWOT

136
00:05:03,000 --> 00:05:06,540
concerning systems and why we can be a

137
00:05:06,540 --> 00:05:08,759
compliment to anomaly detection anomaly

138
00:05:08,759 --> 00:05:11,100
detection is not required for our MTD

139
00:05:11,100 --> 00:05:13,880
system to work

140
00:05:14,040 --> 00:05:16,919
so now we'll get into the background and

141
00:05:16,919 --> 00:05:19,199
I can actually teach a whole class just

142
00:05:19,199 --> 00:05:21,180
on mil standard 1553 but for the

143
00:05:21,180 --> 00:05:23,520
purposes of this work this is a military

144
00:05:23,520 --> 00:05:25,020
protocol that's been around since the

145
00:05:25,020 --> 00:05:28,199
1970s tried and true a lot of military

146
00:05:28,199 --> 00:05:30,720
aircraft use it Satellite Systems use it

147
00:05:30,720 --> 00:05:32,759
the key concept that we need to take

148
00:05:32,759 --> 00:05:34,160
away for this particular presentation

149
00:05:34,160 --> 00:05:36,539
are what you see on the screen the bus

150
00:05:36,539 --> 00:05:38,699
controller the bus monitor and the

151
00:05:38,699 --> 00:05:40,440
remote terminal so typically a bus

152
00:05:40,440 --> 00:05:42,419
controller would be a mission computer

153
00:05:42,419 --> 00:05:45,180
or your aircraft your remote terminal

154
00:05:45,180 --> 00:05:47,039
would be something that may be a sensor

155
00:05:47,039 --> 00:05:48,199
a camera

156
00:05:48,199 --> 00:05:50,460
altimeter or different sensors that you

157
00:05:50,460 --> 00:05:52,259
may have on your particular Network and

158
00:05:52,259 --> 00:05:54,660
then the last is the bus monitor which

159
00:05:54,660 --> 00:05:57,720
serves as the same purpose as your

160
00:05:57,720 --> 00:05:59,220
flight recorder on your typical

161
00:05:59,220 --> 00:06:01,740
commercial airlines

162
00:06:01,740 --> 00:06:03,720
and so here's just an example of a

163
00:06:03,720 --> 00:06:07,080
message that may go on the bus and if

164
00:06:07,080 --> 00:06:09,120
you look at the actual

165
00:06:09,120 --> 00:06:11,120
I guess command in this case it's called

166
00:06:11,120 --> 00:06:15,060
3-r-1 that's W2 and if you get into the

167
00:06:15,060 --> 00:06:16,919
protocol you start to do what we call a

168
00:06:16,919 --> 00:06:19,740
1553 speed but it means the bus

169
00:06:19,740 --> 00:06:21,180
controller sends a command to remote

170
00:06:21,180 --> 00:06:22,680
Terminal 3

171
00:06:22,680 --> 00:06:25,020
it's going to receive data and what's

172
00:06:25,020 --> 00:06:27,900
called sub address 1 and in this case 32

173
00:06:27,900 --> 00:06:31,698
is going to send 32 16-bit words

174
00:06:32,280 --> 00:06:34,560
so that's a little bit about the 1553

175
00:06:34,560 --> 00:06:36,360
protocol looking at moving Target

176
00:06:36,360 --> 00:06:39,180
defense is just a fancy way of saying

177
00:06:39,180 --> 00:06:41,220
it's a dynamic reconfiguration to your

178
00:06:41,220 --> 00:06:42,840
environment so in terms of the graph

179
00:06:42,840 --> 00:06:44,460
that you see here on the screen you have

180
00:06:44,460 --> 00:06:46,380
an attacker that's trying to attack a

181
00:06:46,380 --> 00:06:49,440
server and the IP address is the moving

182
00:06:49,440 --> 00:06:52,259
Target and so by moving it around it

183
00:06:52,259 --> 00:06:54,479
makes it harder for the attacker to

184
00:06:54,479 --> 00:06:56,160
actually attack and get access to your

185
00:06:56,160 --> 00:06:58,319
server and so hence in this case when we

186
00:06:58,319 --> 00:07:00,000
were talking about the IP address and it

187
00:07:00,000 --> 00:07:02,100
defenses the fact that it hops around so

188
00:07:02,100 --> 00:07:05,039
once again our hypothesis is that MTD

189
00:07:05,039 --> 00:07:08,900
does in fact increase cyber resilience

190
00:07:09,060 --> 00:07:11,580
so now we're going to dive into the

191
00:07:11,580 --> 00:07:13,680
design of our algorithm and also

192
00:07:13,680 --> 00:07:15,360
highlight some of the kind of raw

193
00:07:15,360 --> 00:07:18,360
features of the algorithm

194
00:07:18,360 --> 00:07:20,580
so when we first came up with this idea

195
00:07:20,580 --> 00:07:21,780
we wanted

196
00:07:21,780 --> 00:07:23,639
we did not want to come up with a mill

197
00:07:23,639 --> 00:07:27,479
standard 1553 or in this case 1554 we

198
00:07:27,479 --> 00:07:28,979
wanted to keep the underlying protocol

199
00:07:28,979 --> 00:07:31,259
but still have a way to dynamically have

200
00:07:31,259 --> 00:07:33,780
nodes change their address so just like

201
00:07:33,780 --> 00:07:35,400
in the previous example you have IP

202
00:07:35,400 --> 00:07:37,979
addresses in this case you have 1553

203
00:07:37,979 --> 00:07:40,500
addresses we want to keep everything in

204
00:07:40,500 --> 00:07:43,139
sync as you can imagine if these

205
00:07:43,139 --> 00:07:46,020
networks on high consequence systems are

206
00:07:46,020 --> 00:07:47,400
lost and civilization could be

207
00:07:47,400 --> 00:07:50,039
catastrophic and so we but in addition

208
00:07:50,039 --> 00:07:52,620
to that unlike IP addresses where you

209
00:07:52,620 --> 00:07:54,780
have 4 billion or maybe more

210
00:07:54,780 --> 00:07:57,060
on these type of networks you have 31

211
00:07:57,060 --> 00:07:58,620
possible addresses

212
00:07:58,620 --> 00:08:00,599
so we want to make sure that we still

213
00:08:00,599 --> 00:08:02,940
make it difficult for a potential

214
00:08:02,940 --> 00:08:05,039
attacker to guess the next address

215
00:08:05,039 --> 00:08:06,419
and we also don't want to have any

216
00:08:06,419 --> 00:08:09,300
patterns in this because one could argue

217
00:08:09,300 --> 00:08:11,880
that if after a thousand

218
00:08:11,880 --> 00:08:14,220
um variations if I repeat that pattern

219
00:08:14,220 --> 00:08:16,560
that patching could be predicted or

220
00:08:16,560 --> 00:08:17,580
known

221
00:08:17,580 --> 00:08:19,319
frankly MTD doesn't exist for that

222
00:08:19,319 --> 00:08:20,400
system

223
00:08:20,400 --> 00:08:23,099
and as always if we put these messages

224
00:08:23,099 --> 00:08:25,979
on the network we want to make sure that

225
00:08:25,979 --> 00:08:28,139
the node address only change when

226
00:08:28,139 --> 00:08:30,120
authentic commands are put on the bus so

227
00:08:30,120 --> 00:08:31,800
these were the six constraints that we

228
00:08:31,800 --> 00:08:33,479
had when we first started this algorithm

229
00:08:33,479 --> 00:08:36,179
back in 2019.

230
00:08:36,179 --> 00:08:38,339
so when I go into the detail of the

231
00:08:38,339 --> 00:08:39,958
algorithm at the very high level we have

232
00:08:39,958 --> 00:08:41,820
a shared key and a knots

233
00:08:41,820 --> 00:08:43,799
and we push it into a Randomness

234
00:08:43,799 --> 00:08:47,279
primitive the output of that being a

235
00:08:47,279 --> 00:08:48,959
randomized array

236
00:08:48,959 --> 00:08:51,120
and another notch that you could then

237
00:08:51,120 --> 00:08:54,420
again as we call it um pull the crane

238
00:08:54,420 --> 00:08:56,940
and keep generating randomized arrays in

239
00:08:56,940 --> 00:08:58,140
a new knots

240
00:08:58,140 --> 00:09:00,360
and so what you get is a 2d array or as

241
00:09:00,360 --> 00:09:02,820
we call it the state Matrix

242
00:09:02,820 --> 00:09:05,100
so how having this state Matrix how

243
00:09:05,100 --> 00:09:07,320
would you use it and so one of the ways

244
00:09:07,320 --> 00:09:10,140
that we use it this was called

245
00:09:10,140 --> 00:09:11,820
um the static interesting excuse me

246
00:09:11,820 --> 00:09:14,820
static addressing method

247
00:09:14,820 --> 00:09:16,620
so if we have an index of three that

248
00:09:16,620 --> 00:09:19,440
comes out on the bus and a node has a

249
00:09:19,440 --> 00:09:21,120
static address of zero which is the same

250
00:09:21,120 --> 00:09:23,880
address of this as if MTD did not exist

251
00:09:23,880 --> 00:09:25,140
on the bus

252
00:09:25,140 --> 00:09:28,200
it wouldn't pick value 4 for this next

253
00:09:28,200 --> 00:09:29,100
address

254
00:09:29,100 --> 00:09:31,080
and if we had a no that started with a

255
00:09:31,080 --> 00:09:32,820
static address of four and we saw an

256
00:09:32,820 --> 00:09:34,920
index of three it would have its next

257
00:09:34,920 --> 00:09:37,140
address as a value of 24.

258
00:09:37,140 --> 00:09:39,300
so the one thing that you maybe can pick

259
00:09:39,300 --> 00:09:40,620
out about this

260
00:09:40,620 --> 00:09:42,959
is that for a given index

261
00:09:42,959 --> 00:09:46,260
you always get the same next address

262
00:09:46,260 --> 00:09:49,560
and we'll see that in the future because

263
00:09:49,560 --> 00:09:51,600
of that the students here at Purdue

264
00:09:51,600 --> 00:09:53,100
University were able to defeat this

265
00:09:53,100 --> 00:09:55,500
algorithm

266
00:09:55,500 --> 00:09:58,019
so as another way to look at the state

267
00:09:58,019 --> 00:09:59,160
Matrix

268
00:09:59,160 --> 00:10:01,440
instead of having static offset method

269
00:10:01,440 --> 00:10:03,779
or a static indexing method we're able

270
00:10:03,779 --> 00:10:06,000
to have what we call a current indexing

271
00:10:06,000 --> 00:10:08,700
method so using the same state Matrix on

272
00:10:08,700 --> 00:10:10,380
this in this case the index value of two

273
00:10:10,380 --> 00:10:12,779
instead of three if we have a note on

274
00:10:12,779 --> 00:10:14,459
the address and it has a current address

275
00:10:14,459 --> 00:10:18,480
of one this next index is three

276
00:10:18,480 --> 00:10:21,120
and then if we have another index come

277
00:10:21,120 --> 00:10:22,560
out in this case for example let's say

278
00:10:22,560 --> 00:10:25,200
it's still two that same node that now

279
00:10:25,200 --> 00:10:27,060
has a current index of three I mean the

280
00:10:27,060 --> 00:10:29,339
current address of three it's now going

281
00:10:29,339 --> 00:10:32,399
to have a new address of excuse me of

282
00:10:32,399 --> 00:10:33,899
13.

283
00:10:33,899 --> 00:10:36,300
and so one thing we learned for this

284
00:10:36,300 --> 00:10:39,120
particular way of addressing that

285
00:10:39,120 --> 00:10:41,880
it has a temporal locality as part of

286
00:10:41,880 --> 00:10:43,860
their dressing method so whereas in a

287
00:10:43,860 --> 00:10:45,300
static case

288
00:10:45,300 --> 00:10:47,519
index the next address is always the

289
00:10:47,519 --> 00:10:50,339
same in this particular method the

290
00:10:50,339 --> 00:10:51,959
action X address depends on the current

291
00:10:51,959 --> 00:10:54,720
address and we'll see why I'm later on

292
00:10:54,720 --> 00:10:56,399
that was very important for some of the

293
00:10:56,399 --> 00:10:58,620
machine learning attacks and so we have

294
00:10:58,620 --> 00:11:00,240
two other methods that we won't discuss

295
00:11:00,240 --> 00:11:02,100
in this particular presentation called

296
00:11:02,100 --> 00:11:04,560
linear static and linear current

297
00:11:04,560 --> 00:11:06,300
but just note that these are the four

298
00:11:06,300 --> 00:11:08,519
that we're using but we could come up

299
00:11:08,519 --> 00:11:10,740
with different methods most of the work

300
00:11:10,740 --> 00:11:13,560
that we've done here just use the static

301
00:11:13,560 --> 00:11:16,260
and the current method of indexing the

302
00:11:16,260 --> 00:11:19,640
state or excuse me the state Matrix

303
00:11:19,920 --> 00:11:21,839
so now I'm going to go through some of

304
00:11:21,839 --> 00:11:23,339
the attributes that we did with the

305
00:11:23,339 --> 00:11:25,980
algorithm was first created so first of

306
00:11:25,980 --> 00:11:28,019
all we wanted to know what is the size

307
00:11:28,019 --> 00:11:29,399
of The Matrix

308
00:11:29,399 --> 00:11:31,740
so assuming that every address takes up

309
00:11:31,740 --> 00:11:34,500
a byte we can see here that as we go up

310
00:11:34,500 --> 00:11:37,980
to 65 000 arrays we reach our Peak Max

311
00:11:37,980 --> 00:11:39,480
of around

312
00:11:39,480 --> 00:11:41,640
um two megabytes and so we believe

313
00:11:41,640 --> 00:11:43,740
looking at some of the future slides

314
00:11:43,740 --> 00:11:46,200
that will show that we can get away with

315
00:11:46,200 --> 00:11:50,459
about 128 or 256 arrays and so we

316
00:11:50,459 --> 00:11:52,740
believe that a lot of this work could be

317
00:11:52,740 --> 00:11:54,360
done

318
00:11:54,360 --> 00:11:56,279
um in smaller microprocessors and even

319
00:11:56,279 --> 00:11:58,980
in microcontrollers

320
00:11:58,980 --> 00:12:00,779
so here and this is on an Intel

321
00:12:00,779 --> 00:12:02,040
processor

322
00:12:02,040 --> 00:12:04,320
uh in this particular case it's a sixth

323
00:12:04,320 --> 00:12:07,140
generation processor core i7 we wanted

324
00:12:07,140 --> 00:12:09,540
to figure out how long does it take to

325
00:12:09,540 --> 00:12:12,060
generate a particular round of the

326
00:12:12,060 --> 00:12:15,360
algorithm and looking at 65 000 rounds

327
00:12:15,360 --> 00:12:18,060
which is more or less steady state it

328
00:12:18,060 --> 00:12:21,000
takes somewhere shy of 300 microseconds

329
00:12:21,000 --> 00:12:24,899
now this bus runs at one microsecond and

330
00:12:24,899 --> 00:12:27,480
so if it takes you 300 microseconds to

331
00:12:27,480 --> 00:12:28,920
potentially

332
00:12:28,920 --> 00:12:31,500
um generate an array we would advise

333
00:12:31,500 --> 00:12:33,540
that do all of the state generation

334
00:12:33,540 --> 00:12:35,399
ahead of time

335
00:12:35,399 --> 00:12:37,440
and not try to do it on the Fly though

336
00:12:37,440 --> 00:12:38,820
you could if you had a fast enough

337
00:12:38,820 --> 00:12:41,420
processor

338
00:12:41,760 --> 00:12:43,920
so now that we have the state Matrix we

339
00:12:43,920 --> 00:12:45,899
wanted to understand does it provide

340
00:12:45,899 --> 00:12:48,720
enough entropy entropy being one of

341
00:12:48,720 --> 00:12:51,300
those metrics we wanted to look at for

342
00:12:51,300 --> 00:12:52,860
our algorithm design

343
00:12:52,860 --> 00:12:54,779
and so what we see here is that we

344
00:12:54,779 --> 00:12:56,820
generated 65

345
00:12:56,820 --> 00:12:59,700
000 indexes and then looked at the next

346
00:12:59,700 --> 00:13:01,560
address and then put that in a

347
00:13:01,560 --> 00:13:04,079
particular bucket here on the histogram

348
00:13:04,079 --> 00:13:06,899
excuse me and what we found out is that

349
00:13:06,899 --> 00:13:10,320
having a state Matrix of 256 columns

350
00:13:10,320 --> 00:13:12,420
performed from an entropy standpoint

351
00:13:12,420 --> 00:13:16,500
very similar to having 65 000 columns so

352
00:13:16,500 --> 00:13:18,300
our argument from looking at this data

353
00:13:18,300 --> 00:13:20,639
is that we could have smaller State

354
00:13:20,639 --> 00:13:23,279
Matrix and still get good entropy

355
00:13:23,279 --> 00:13:25,560
performance

356
00:13:25,560 --> 00:13:27,899
so we took that same data and looked at

357
00:13:27,899 --> 00:13:29,940
it a step further

358
00:13:29,940 --> 00:13:31,740
and looked at three different sets of

359
00:13:31,740 --> 00:13:34,980
data State Matrix of 512 columns eight

360
00:13:34,980 --> 00:13:37,500
thousand and sixty five thousand and we

361
00:13:37,500 --> 00:13:39,360
wanted to see if we took every single

362
00:13:39,360 --> 00:13:41,339
possible note on that bus so from node

363
00:13:41,339 --> 00:13:44,519
address is zero to no address of 30

364
00:13:44,519 --> 00:13:46,740
we wanted to see how long it would take

365
00:13:46,740 --> 00:13:49,620
for every single possible node to be

366
00:13:49,620 --> 00:13:52,560
assigned another address value at least

367
00:13:52,560 --> 00:13:54,240
once or every other possible value at

368
00:13:54,240 --> 00:13:57,000
least once and the key takeaway from

369
00:13:57,000 --> 00:13:58,079
this

370
00:13:58,079 --> 00:14:00,839
um from this graph of this chart is that

371
00:14:00,839 --> 00:14:03,959
the static cell offset method has a much

372
00:14:03,959 --> 00:14:06,300
higher average or since it has a higher

373
00:14:06,300 --> 00:14:08,160
average and a higher standard deviation

374
00:14:08,160 --> 00:14:11,100
compared to the other three

375
00:14:11,100 --> 00:14:13,260
and the key thing that we that we found

376
00:14:13,260 --> 00:14:15,779
interesting about that is that as we go

377
00:14:15,779 --> 00:14:16,800
through the rest of this presentation

378
00:14:16,800 --> 00:14:18,360
we'll start to show you different

379
00:14:18,360 --> 00:14:21,180
Windows to look at this data and it will

380
00:14:21,180 --> 00:14:22,860
those windows will all kind of agree

381
00:14:22,860 --> 00:14:25,380
that the static method more or less

382
00:14:25,380 --> 00:14:27,360
should be should not be used or we

383
00:14:27,360 --> 00:14:29,339
should say the static method on

384
00:14:29,339 --> 00:14:32,339
performance worse than the other three

385
00:14:32,339 --> 00:14:34,740
so here we have another window we want

386
00:14:34,740 --> 00:14:36,000
to look at

387
00:14:36,000 --> 00:14:37,920
I won't get into the details because I

388
00:14:37,920 --> 00:14:39,300
can spend probably 30 minutes on this

389
00:14:39,300 --> 00:14:41,639
slide alone but we looked at three

390
00:14:41,639 --> 00:14:43,620
aspects of the state Matrix in the

391
00:14:43,620 --> 00:14:46,680
algorithm the offset method the size of

392
00:14:46,680 --> 00:14:48,000
the state Matrix

393
00:14:48,000 --> 00:14:51,120
and how often we were to update the

394
00:14:51,120 --> 00:14:53,699
state Matrix and what we found out using

395
00:14:53,699 --> 00:14:56,399
these nine unpredictability metrics is

396
00:14:56,399 --> 00:14:58,440
that the state size the state matric

397
00:14:58,440 --> 00:15:00,720
size and how often you update the state

398
00:15:00,720 --> 00:15:03,660
Matrix did not did not affect those

399
00:15:03,660 --> 00:15:05,820
metrics as much the unpredictability

400
00:15:05,820 --> 00:15:09,240
metrics but the actual offset method the

401
00:15:09,240 --> 00:15:11,519
metrics did change a lot more meaning

402
00:15:11,519 --> 00:15:14,279
that static had the worst performing and

403
00:15:14,279 --> 00:15:15,839
as you went from left to right moving

404
00:15:15,839 --> 00:15:17,820
over to linear current we had a better

405
00:15:17,820 --> 00:15:18,959
performance in terms of the

406
00:15:18,959 --> 00:15:21,779
unpredictability metrics and so even

407
00:15:21,779 --> 00:15:22,920
though we're looking at it from a

408
00:15:22,920 --> 00:15:25,620
different window we can see that static

409
00:15:25,620 --> 00:15:28,199
performs worse than the other three

410
00:15:28,199 --> 00:15:32,240
types of indexing indexing methods

411
00:15:32,760 --> 00:15:34,920
so in summary from this kind of looking

412
00:15:34,920 --> 00:15:36,899
at the raw data of the algorithm we see

413
00:15:36,899 --> 00:15:38,839
that not all addresses are created

414
00:15:38,839 --> 00:15:41,279
equals some addresses are going to have

415
00:15:41,279 --> 00:15:44,279
more variation than others but they are

416
00:15:44,279 --> 00:15:46,560
close or not purely not not purely

417
00:15:46,560 --> 00:15:48,660
uniform distributed

418
00:15:48,660 --> 00:15:50,399
um but they actually have a very uh

419
00:15:50,399 --> 00:15:51,959
close distribution between something

420
00:15:51,959 --> 00:15:55,680
that is 256 versus 65 000.

421
00:15:55,680 --> 00:15:57,480
um all addresses are going to be used so

422
00:15:57,480 --> 00:16:00,540
there is no load on this bus that if

423
00:16:00,540 --> 00:16:02,220
it's notified let's say it starts out of

424
00:16:02,220 --> 00:16:04,740
address five it will be assigned every

425
00:16:04,740 --> 00:16:06,720
other address at some point in time in

426
00:16:06,720 --> 00:16:09,720
the future as opposed to certain nodes

427
00:16:09,720 --> 00:16:12,899
not getting assign that address at all

428
00:16:12,899 --> 00:16:14,760
you don't need a large Matrix to have

429
00:16:14,760 --> 00:16:17,579
good entropy excuse me but this is

430
00:16:17,579 --> 00:16:19,260
something that we were not we were

431
00:16:19,260 --> 00:16:20,699
assuming that we want to have a larger

432
00:16:20,699 --> 00:16:22,199
Matrix but we found out that we didn't

433
00:16:22,199 --> 00:16:24,480
have to so that means that smaller

434
00:16:24,480 --> 00:16:26,699
processors and microcontrollers could

435
00:16:26,699 --> 00:16:28,620
use this algorithm

436
00:16:28,620 --> 00:16:31,500
um if need be and then also indexing to

437
00:16:31,500 --> 00:16:33,600
the state we would suggest that you

438
00:16:33,600 --> 00:16:35,339
generate the state metrics and use it on

439
00:16:35,339 --> 00:16:37,440
the Fly excuse me generate the

440
00:16:37,440 --> 00:16:39,779
statements beforehand and don't use it

441
00:16:39,779 --> 00:16:41,880
on the Fly unless you have a fast enough

442
00:16:41,880 --> 00:16:43,320
processor and there's different ways

443
00:16:43,320 --> 00:16:45,660
that you could try to minimize the state

444
00:16:45,660 --> 00:16:48,300
and and one of the ideas that we had is

445
00:16:48,300 --> 00:16:51,000
you store every eight rounds and

446
00:16:51,000 --> 00:16:52,320
anything in between that you just

447
00:16:52,320 --> 00:16:54,000
generate on the Fly and so that could

448
00:16:54,000 --> 00:16:56,040
reduce the time but we still would

449
00:16:56,040 --> 00:16:57,839
recommend doing everything ahead of time

450
00:16:57,839 --> 00:17:01,519
and just indexing on the Fly

451
00:17:02,399 --> 00:17:03,779
so now we're going to move into

452
00:17:03,779 --> 00:17:06,679
experimentation

453
00:17:07,439 --> 00:17:09,240
so we wanted to know that hey we have

454
00:17:09,240 --> 00:17:10,439
this algorithm

455
00:17:10,439 --> 00:17:12,900
how do we know it actually works

456
00:17:12,900 --> 00:17:17,099
and so we built a mill standard 1553 bus

457
00:17:17,099 --> 00:17:18,780
and we wanted to do something very

458
00:17:18,780 --> 00:17:20,939
similar just simple excuse me just to

459
00:17:20,939 --> 00:17:22,919
test the algorithm

460
00:17:22,919 --> 00:17:24,660
I believe this was done in the summer of

461
00:17:24,660 --> 00:17:26,099
2019

462
00:17:26,099 --> 00:17:28,559
um two interns we had at Sandia

463
00:17:28,559 --> 00:17:30,780
and so we wanted to try something that

464
00:17:30,780 --> 00:17:32,400
would be done really quickly and just

465
00:17:32,400 --> 00:17:34,200
really test the algorithm and so we

466
00:17:34,200 --> 00:17:36,360
broke it up into two phrases one to

467
00:17:36,360 --> 00:17:39,059
calculate the 24th Fibonacci number and

468
00:17:39,059 --> 00:17:41,100
two an exfiltration experiment

469
00:17:41,100 --> 00:17:43,620
so in Phase One you calculated the

470
00:17:43,620 --> 00:17:45,780
Fibonacci sequence and we were sent a

471
00:17:45,780 --> 00:17:48,780
what we call MTD update command every X

472
00:17:48,780 --> 00:17:50,700
frames and there's two messages per

473
00:17:50,700 --> 00:17:52,160
frame in our particular experimentation

474
00:17:52,160 --> 00:17:55,140
because it went very quick we decided

475
00:17:55,140 --> 00:17:56,640
we're going to have something called

476
00:17:56,640 --> 00:17:58,440
generation which is just calculating

477
00:17:58,440 --> 00:18:01,020
that 24th number over and over again to

478
00:18:01,020 --> 00:18:02,400
get the number of messages that we

479
00:18:02,400 --> 00:18:05,700
needed and then in phase two we wanted

480
00:18:05,700 --> 00:18:07,620
to play the adversary or the role of the

481
00:18:07,620 --> 00:18:10,260
adversary and we wanted to

482
00:18:10,260 --> 00:18:12,720
say if we know a particular node has the

483
00:18:12,720 --> 00:18:13,919
information that we want to pull out

484
00:18:13,919 --> 00:18:16,380
everything going to and from that node

485
00:18:16,380 --> 00:18:18,960
we're going to listen for

486
00:18:18,960 --> 00:18:21,179
and we're going to look at that with MTD

487
00:18:21,179 --> 00:18:23,520
and without MTD

488
00:18:23,520 --> 00:18:25,260
with the goal being that we want to

489
00:18:25,260 --> 00:18:27,840
quantify the reduction in adversarial

490
00:18:27,840 --> 00:18:30,740
knowledge if any

491
00:18:30,780 --> 00:18:32,880
so the way it starts off is that the bus

492
00:18:32,880 --> 00:18:34,380
controller which could also be a mission

493
00:18:34,380 --> 00:18:35,340
computer

494
00:18:35,340 --> 00:18:38,280
is going to send an MTD start message

495
00:18:38,280 --> 00:18:41,160
the RIT is going to take that start uh

496
00:18:41,160 --> 00:18:43,020
excuse me that nons from the MTD start

497
00:18:43,020 --> 00:18:44,880
message and it's going to create a hash

498
00:18:44,880 --> 00:18:46,860
and send it back to the bus controller

499
00:18:46,860 --> 00:18:48,780
if the bus controller is internally

500
00:18:48,780 --> 00:18:51,240
generated has matches it knows that both

501
00:18:51,240 --> 00:18:52,980
the BC and the RT have the same state

502
00:18:52,980 --> 00:18:55,140
Matrix without actually sending

503
00:18:55,140 --> 00:18:56,280
hopefully without linking any

504
00:18:56,280 --> 00:18:57,960
information across the bus

505
00:18:57,960 --> 00:19:00,480
start the Fibonacci calculation after so

506
00:19:00,480 --> 00:19:02,940
many frames we send an entity update it

507
00:19:02,940 --> 00:19:05,220
just has a value between an arcade

508
00:19:05,220 --> 00:19:06,960
between 0 and 127

509
00:19:06,960 --> 00:19:09,419
the new addresses are used and we

510
00:19:09,419 --> 00:19:11,160
continue calculating up until we get to

511
00:19:11,160 --> 00:19:14,039
the value of hexadecimal b520 which is

512
00:19:14,039 --> 00:19:16,500
the 24th Fibonacci number and either we

513
00:19:16,500 --> 00:19:18,720
stopped experimentation or if we need to

514
00:19:18,720 --> 00:19:20,520
generate more data we'll keep doing what

515
00:19:20,520 --> 00:19:22,080
we call Generations

516
00:19:22,080 --> 00:19:23,640
and so just to visually kind of

517
00:19:23,640 --> 00:19:24,960
highlight that

518
00:19:24,960 --> 00:19:27,480
and the MTD start we have the 128 bit

519
00:19:27,480 --> 00:19:28,440
knots

520
00:19:28,440 --> 00:19:31,020
the MTV verify has the hash

521
00:19:31,020 --> 00:19:34,080
into the update has a single value and

522
00:19:34,080 --> 00:19:35,520
of course when we finish we have the

523
00:19:35,520 --> 00:19:37,860
value of b520 and it's a market that we

524
00:19:37,860 --> 00:19:39,299
can always find

525
00:19:39,299 --> 00:19:40,980
um using the bus monitor that we got the

526
00:19:40,980 --> 00:19:43,080
right value and everything is working as

527
00:19:43,080 --> 00:19:45,918
intended

528
00:19:46,320 --> 00:19:48,720
so like I said before we wanted to

529
00:19:48,720 --> 00:19:50,160
figure out

530
00:19:50,160 --> 00:19:52,679
what could an adversary pull out and so

531
00:19:52,679 --> 00:19:54,780
on the left side of the graph

532
00:19:54,780 --> 00:19:56,640
we have the percentage messages that

533
00:19:56,640 --> 00:19:59,520
were exfiltrated and then on the x-axis

534
00:19:59,520 --> 00:20:02,039
we have going from left to right we vary

535
00:20:02,039 --> 00:20:04,679
the frequency of how often we send out

536
00:20:04,679 --> 00:20:06,660
MTD update messages

537
00:20:06,660 --> 00:20:09,480
and so what we found out is that the

538
00:20:09,480 --> 00:20:11,880
attacker would pick a random address and

539
00:20:11,880 --> 00:20:13,919
it would listen for that address

540
00:20:13,919 --> 00:20:15,900
for a certain amount of time what we

541
00:20:15,900 --> 00:20:17,460
found out is that we were able to reduce

542
00:20:17,460 --> 00:20:20,400
the information that attacker gang with

543
00:20:20,400 --> 00:20:24,600
MTD on versus off by 97 percent and so

544
00:20:24,600 --> 00:20:27,299
if you think of uh one divided by 31

545
00:20:27,299 --> 00:20:30,360
it's around 3.2 percent so experimental

546
00:20:30,360 --> 00:20:32,760
Master theoretical estimate that we were

547
00:20:32,760 --> 00:20:34,980
intending to see

548
00:20:34,980 --> 00:20:37,620
and so on the right side same experiment

549
00:20:37,620 --> 00:20:40,760
but the attacker knows the first address

550
00:20:40,760 --> 00:20:42,720
instead of guessing the first address

551
00:20:42,720 --> 00:20:46,080
and so what we saw is that once you have

552
00:20:46,080 --> 00:20:48,000
a low frequency of updates

553
00:20:48,000 --> 00:20:49,860
that because the attackers start on the

554
00:20:49,860 --> 00:20:52,200
known address it was able to catch a lot

555
00:20:52,200 --> 00:20:53,460
more of the traffic

556
00:20:53,460 --> 00:20:55,440
but we have a very small experiment in

557
00:20:55,440 --> 00:20:58,260
this case 50 generations and we believe

558
00:20:58,260 --> 00:21:01,320
we went out to 5 000 5 million the

559
00:21:01,320 --> 00:21:02,820
graphic on the right would start to look

560
00:21:02,820 --> 00:21:04,260
like the one on the left and you're

561
00:21:04,260 --> 00:21:06,240
you're approach that uh theoretical

562
00:21:06,240 --> 00:21:09,240
estimate

563
00:21:10,440 --> 00:21:13,440
so we wanted to Crank It Up A Notch and

564
00:21:13,440 --> 00:21:16,679
get a really smart learning adversary

565
00:21:16,679 --> 00:21:18,840
and so in this case we assume well what

566
00:21:18,840 --> 00:21:22,140
if the adversary could learn the pattern

567
00:21:22,140 --> 00:21:24,660
let's just assume after so many frames

568
00:21:24,660 --> 00:21:28,260
so for example we had a period of 25 so

569
00:21:28,260 --> 00:21:30,419
after every 25 frames we sent out an

570
00:21:30,419 --> 00:21:32,940
entity update command but the adversary

571
00:21:32,940 --> 00:21:34,440
to learn

572
00:21:34,440 --> 00:21:37,260
um the pattern after eight frames then

573
00:21:37,260 --> 00:21:39,120
they could exfil seventy percent of all

574
00:21:39,120 --> 00:21:41,700
the messages and we took them 16 frames

575
00:21:41,700 --> 00:21:44,220
they could actually 40 and of course if

576
00:21:44,220 --> 00:21:46,559
they go above 25 then potentially X fill

577
00:21:46,559 --> 00:21:48,659
nothing which means the average Traders

578
00:21:48,659 --> 00:21:49,860
have the better opportunity to just

579
00:21:49,860 --> 00:21:52,559
listen at one address and don't move

580
00:21:52,559 --> 00:21:55,320
and so what it told us is that if you

581
00:21:55,320 --> 00:21:58,320
can model your adversary and have a

582
00:21:58,320 --> 00:21:59,580
system that can move faster than your

583
00:21:59,580 --> 00:22:01,500
adversary it can make it very

584
00:22:01,500 --> 00:22:03,659
challenging for adversary to ever figure

585
00:22:03,659 --> 00:22:06,919
out what is the next address

586
00:22:08,880 --> 00:22:10,440
and so we want to look at machine

587
00:22:10,440 --> 00:22:12,059
learning and this work as I mentioned

588
00:22:12,059 --> 00:22:14,700
before was done with we're done here at

589
00:22:14,700 --> 00:22:17,340
Purdue University and so before we go

590
00:22:17,340 --> 00:22:18,720
into the machine learning we want to

591
00:22:18,720 --> 00:22:20,880
highlight a few aspects of what the

592
00:22:20,880 --> 00:22:23,039
students were looking at so you look at

593
00:22:23,039 --> 00:22:25,140
the screen you have these circles and

594
00:22:25,140 --> 00:22:28,860
like I said this is 1553 speak but the

595
00:22:28,860 --> 00:22:31,080
key importance of these circles are the

596
00:22:31,080 --> 00:22:33,000
first number so if you look at the blue

597
00:22:33,000 --> 00:22:36,480
box message 4 13 and 14 the first number

598
00:22:36,480 --> 00:22:38,220
is one which means it has a remote

599
00:22:38,220 --> 00:22:40,260
terminal address of one

600
00:22:40,260 --> 00:22:43,080
measures 15 this is what we call MTD

601
00:22:43,080 --> 00:22:45,419
update command and it is a broadcast

602
00:22:45,419 --> 00:22:48,299
command so every node hears it and has a

603
00:22:48,299 --> 00:22:51,480
value of hexadecimal 17 and from that

604
00:22:51,480 --> 00:22:53,400
and we call that the index but from that

605
00:22:53,400 --> 00:22:56,940
index for message 16 and 17 the new

606
00:22:56,940 --> 00:23:00,000
address is 27. and so that's really the

607
00:23:00,000 --> 00:23:01,559
uniqueness of this work is that by

608
00:23:01,559 --> 00:23:03,720
sending out that index both the bus

609
00:23:03,720 --> 00:23:06,240
controller and the remote terminal can

610
00:23:06,240 --> 00:23:07,559
switch over to the correct address

611
00:23:07,559 --> 00:23:09,900
without hopefully making any additional

612
00:23:09,900 --> 00:23:11,880
information and maintaining the protocol

613
00:23:11,880 --> 00:23:15,080
maintaining the same speed

614
00:23:15,539 --> 00:23:17,460
and so just to go back to that real

615
00:23:17,460 --> 00:23:19,140
quick

616
00:23:19,140 --> 00:23:22,080
what the students wanted to do is apply

617
00:23:22,080 --> 00:23:26,280
machine learning to see if if I look at

618
00:23:26,280 --> 00:23:28,799
remote terminal address one I look at

619
00:23:28,799 --> 00:23:31,919
the hexadecimal value of 17 can I figure

620
00:23:31,919 --> 00:23:33,960
out that the next address is going to be

621
00:23:33,960 --> 00:23:35,820
27.

622
00:23:35,820 --> 00:23:37,440
and so originally we had some other

623
00:23:37,440 --> 00:23:39,840
questions we wanted to ask but as you

624
00:23:39,840 --> 00:23:42,539
all know due to the pandemic we were not

625
00:23:42,539 --> 00:23:43,559
able

626
00:23:43,559 --> 00:23:47,580
um to answer all those questions yes

627
00:23:50,270 --> 00:23:53,639
[Music]

628
00:24:04,140 --> 00:24:06,900
you got it you go oh okay

629
00:24:06,900 --> 00:24:09,840
um I think you mentioned that um based

630
00:24:09,840 --> 00:24:13,140
on the current address it is determined

631
00:24:13,140 --> 00:24:15,240
um what the next address will be how do

632
00:24:15,240 --> 00:24:16,980
you determine from the current address

633
00:24:16,980 --> 00:24:20,360
what the next address will be

634
00:24:20,760 --> 00:24:22,460
so make sure I understand the question

635
00:24:22,460 --> 00:24:25,020
so you're asking me how do you determine

636
00:24:25,020 --> 00:24:26,220
the next address

637
00:24:26,220 --> 00:24:28,620
so it depends on the indexing mode

638
00:24:28,620 --> 00:24:30,299
so if you're in What's called the static

639
00:24:30,299 --> 00:24:31,740
indexing mode

640
00:24:31,740 --> 00:24:34,799
given the index value of 17 I'll go back

641
00:24:34,799 --> 00:24:38,340
one given the hexadecimal value of 17.

642
00:24:38,340 --> 00:24:41,039
so that's considered the index

643
00:24:41,039 --> 00:24:43,860
and so in our particular algorithm that

644
00:24:43,860 --> 00:24:46,100
index value of hexadecimal 17

645
00:24:46,100 --> 00:24:49,080
corresponds to a column

646
00:24:49,080 --> 00:24:52,200
and if in this case the remote terminal

647
00:24:52,200 --> 00:24:55,740
address is one so in that column you

648
00:24:55,740 --> 00:24:58,799
have the row of one per se you have a

649
00:24:58,799 --> 00:25:01,380
column of 17 hex whatever that value is

650
00:25:01,380 --> 00:25:03,500
that's your next address

651
00:25:03,500 --> 00:25:06,360
in static indexing

652
00:25:06,360 --> 00:25:09,419
and is that column known to like both

653
00:25:09,419 --> 00:25:11,280
the sender and the receiver correct so

654
00:25:11,280 --> 00:25:14,280
they both have identical State Matrix

655
00:25:14,280 --> 00:25:16,140
and the way they know they have

656
00:25:16,140 --> 00:25:19,320
identical is that a hash is sent between

657
00:25:19,320 --> 00:25:21,840
them before the process even starts

658
00:25:21,840 --> 00:25:24,360
and so they have the same hash

659
00:25:24,360 --> 00:25:25,860
um then they can guarantee they have the

660
00:25:25,860 --> 00:25:29,039
same data for the entire statements

661
00:25:29,039 --> 00:25:31,260
so excellent question

662
00:25:31,260 --> 00:25:33,120
and so what the Purdue students here

663
00:25:33,120 --> 00:25:35,279
we're going to do is figure out from

664
00:25:35,279 --> 00:25:36,720
either looking at previous addresses

665
00:25:36,720 --> 00:25:38,820
looking at the current index value could

666
00:25:38,820 --> 00:25:41,460
they figure out that the value of one

667
00:25:41,460 --> 00:25:44,279
looking at a hexadecimal value of 17 for

668
00:25:44,279 --> 00:25:47,279
the index is going to turn into 27.

669
00:25:47,279 --> 00:25:48,779
so as I'm saying earlier we had some

670
00:25:48,779 --> 00:25:50,520
other questions we wanted to ask and

671
00:25:50,520 --> 00:25:53,100
answer because the pandemic we had to

672
00:25:53,100 --> 00:25:54,360
really focus on different set of

673
00:25:54,360 --> 00:25:56,340
questions and so we kind of down

674
00:25:56,340 --> 00:25:57,600
selected and said well what is the most

675
00:25:57,600 --> 00:25:59,159
important thing about this work what

676
00:25:59,159 --> 00:26:01,380
would give the adversary a home run and

677
00:26:01,380 --> 00:26:03,480
ask if they can predict the patching or

678
00:26:03,480 --> 00:26:05,520
the next address because if they can do

679
00:26:05,520 --> 00:26:07,740
that in effect that you have disabled

680
00:26:07,740 --> 00:26:10,620
and turned off MTD

681
00:26:10,620 --> 00:26:12,720
and so in our particular case we uh the

682
00:26:12,720 --> 00:26:14,880
students decided to use I believe it was

683
00:26:14,880 --> 00:26:18,840
called the long short term memory model

684
00:26:18,840 --> 00:26:21,240
and I'm definitely not an SME expert so

685
00:26:21,240 --> 00:26:22,740
the students definitely helped us out

686
00:26:22,740 --> 00:26:25,080
with this work and we were able to vary

687
00:26:25,080 --> 00:26:26,640
the training size but the test size

688
00:26:26,640 --> 00:26:29,779
always stayed at 20 percent

689
00:26:29,940 --> 00:26:32,820
and so they had this metric called the

690
00:26:32,820 --> 00:26:34,980
F1 and the MCC number

691
00:26:34,980 --> 00:26:36,840
and the key takeaway from that is the

692
00:26:36,840 --> 00:26:38,520
closer you are to one

693
00:26:38,520 --> 00:26:40,679
the better the machine learning model

694
00:26:40,679 --> 00:26:43,440
can predict the next address so

695
00:26:43,440 --> 00:26:45,320
effectively if you're above

696
00:26:45,320 --> 00:26:48,240
0.9.95 every single time you see an

697
00:26:48,240 --> 00:26:50,100
index you know the next address is going

698
00:26:50,100 --> 00:26:51,900
to be we have defeated the algorithm

699
00:26:51,900 --> 00:26:54,480
home run you win average 30 wins the

700
00:26:54,480 --> 00:26:57,600
game and so when we sent them this

701
00:26:57,600 --> 00:26:59,820
information we used What's called the

702
00:26:59,820 --> 00:27:01,740
static indexing method or the static

703
00:27:01,740 --> 00:27:03,480
cell offset method

704
00:27:03,480 --> 00:27:06,539
and going from left to right

705
00:27:06,539 --> 00:27:08,159
on the left side that you're looking at

706
00:27:08,159 --> 00:27:10,440
one previous address the next chart is

707
00:27:10,440 --> 00:27:12,600
looking at two previous addresses and

708
00:27:12,600 --> 00:27:14,039
then the third chart fathers on the

709
00:27:14,039 --> 00:27:15,419
right is looking at three previous

710
00:27:15,419 --> 00:27:17,880
addresses in addition to the index value

711
00:27:17,880 --> 00:27:20,940
and as you can see here on the on the

712
00:27:20,940 --> 00:27:24,059
left side once they got Beyond 20 000

713
00:27:24,059 --> 00:27:26,460
messages they were hitting above 0.90

714
00:27:26,460 --> 00:27:28,740
excuse me 0.9 which means the effect

715
00:27:28,740 --> 00:27:29,820
that we're getting the next address

716
00:27:29,820 --> 00:27:31,320
every time

717
00:27:31,320 --> 00:27:36,059
and so by changing one line of code

718
00:27:36,059 --> 00:27:37,880
we were able to take that from around

719
00:27:37,880 --> 00:27:41,880
0.95 down to less than 0.2 which

720
00:27:41,880 --> 00:27:43,740
effectively means you can it's the same

721
00:27:43,740 --> 00:27:45,480
as picking a random address and so they

722
00:27:45,480 --> 00:27:47,760
were I'm having a very difficult time of

723
00:27:47,760 --> 00:27:50,400
guessing the next address so why do I

724
00:27:50,400 --> 00:27:52,260
feel like this is important

725
00:27:52,260 --> 00:27:53,820
is because when we looked at the

726
00:27:53,820 --> 00:27:56,760
unpredictability metrics it showed that

727
00:27:56,760 --> 00:27:58,940
the way you index the state Matrix

728
00:27:58,940 --> 00:28:02,400
mattered static performed the worst we

729
00:28:02,400 --> 00:28:04,740
looked at machine learning static was

730
00:28:04,740 --> 00:28:06,179
predictable

731
00:28:06,179 --> 00:28:08,820
uh when we looked at uh the previous

732
00:28:08,820 --> 00:28:10,380
chart where I talked about the standard

733
00:28:10,380 --> 00:28:13,140
deviation and the average static had the

734
00:28:13,140 --> 00:28:15,840
highest so different Windows was seen

735
00:28:15,840 --> 00:28:18,600
the same exact conclusion and then when

736
00:28:18,600 --> 00:28:20,279
we looked at current it performed better

737
00:28:20,279 --> 00:28:22,140
and unpredictability metrics in our

738
00:28:22,140 --> 00:28:23,700
particular case

739
00:28:23,700 --> 00:28:25,140
um the machine learning model could no

740
00:28:25,140 --> 00:28:27,179
longer predict the next address doesn't

741
00:28:27,179 --> 00:28:29,580
mean that no model can do it

742
00:28:29,580 --> 00:28:31,620
it just means we were able to make the

743
00:28:31,620 --> 00:28:33,900
algorithm provide more entropy and

744
00:28:33,900 --> 00:28:35,820
remove some potential patterns that

745
00:28:35,820 --> 00:28:39,379
existed using the static method

746
00:28:40,559 --> 00:28:43,158
foreign

747
00:28:44,059 --> 00:28:46,559
for this work obtained some copyright

748
00:28:46,559 --> 00:28:48,900
for the government we're also now

749
00:28:48,900 --> 00:28:51,240
working uh under NDA with the commercial

750
00:28:51,240 --> 00:28:53,700
companies to start a company integrating

751
00:28:53,700 --> 00:28:55,440
some of this technology

752
00:28:55,440 --> 00:28:57,480
and as we mentioned before I think the

753
00:28:57,480 --> 00:28:59,340
key results from this work

754
00:28:59,340 --> 00:29:00,960
is that being able to reduce information

755
00:29:00,960 --> 00:29:02,700
to the adversary

756
00:29:02,700 --> 00:29:05,100
being able to quantify the entropy and

757
00:29:05,100 --> 00:29:06,720
Randomness in the algorithm

758
00:29:06,720 --> 00:29:08,820
and towards the end of the work we

759
00:29:08,820 --> 00:29:11,460
realized that while we focused on Mill

760
00:29:11,460 --> 00:29:13,740
standard 1553

761
00:29:13,740 --> 00:29:15,960
the actual algorithm can be decomposed

762
00:29:15,960 --> 00:29:17,820
into four components

763
00:29:17,820 --> 00:29:19,799
and as you're able to customize each of

764
00:29:19,799 --> 00:29:21,120
those four components you had a

765
00:29:21,120 --> 00:29:23,220
generalized approach to actually

766
00:29:23,220 --> 00:29:26,100
designing an algorithm for IP addresses

767
00:29:26,100 --> 00:29:29,640
can bus addresses crypto keys and maybe

768
00:29:29,640 --> 00:29:31,740
even some other attributes depending on

769
00:29:31,740 --> 00:29:34,159
your system

770
00:29:35,880 --> 00:29:38,399
uh so before I move on are there any

771
00:29:38,399 --> 00:29:42,020
questions from that work

772
00:29:43,080 --> 00:29:45,899
we do have one if an adversary is

773
00:29:45,899 --> 00:29:49,140
sniffing the bus and has access to all

774
00:29:49,140 --> 00:29:52,320
initial conditions can they defeat the

775
00:29:52,320 --> 00:29:54,240
whole scheme assuming that they know the

776
00:29:54,240 --> 00:29:56,279
MTD algorithm

777
00:29:56,279 --> 00:29:58,440
so what the average say would have to

778
00:29:58,440 --> 00:30:01,860
have is that shared key

779
00:30:01,860 --> 00:30:03,659
um so the only thing the adversary sees

780
00:30:03,659 --> 00:30:05,880
on the bus it sees the index going back

781
00:30:05,880 --> 00:30:06,899
and forth

782
00:30:06,899 --> 00:30:09,480
it sees the hash in our case it's really

783
00:30:09,480 --> 00:30:13,140
a hmac 256 or hmac 512

784
00:30:13,140 --> 00:30:15,419
and they see the knots in the MTV start

785
00:30:15,419 --> 00:30:16,799
coming

786
00:30:16,799 --> 00:30:20,100
and without that shared key we're going

787
00:30:20,100 --> 00:30:21,659
to make the argument

788
00:30:21,659 --> 00:30:25,020
that you cannot predict the pattern of

789
00:30:25,020 --> 00:30:27,299
next addresses and to prove that

790
00:30:27,299 --> 00:30:29,399
argument or at least to have more data

791
00:30:29,399 --> 00:30:32,159
and quantifiable argument that's what

792
00:30:32,159 --> 00:30:33,720
the students here Purdue did they use

793
00:30:33,720 --> 00:30:35,580
machine learning they did not have

794
00:30:35,580 --> 00:30:37,559
access to the shared key

795
00:30:37,559 --> 00:30:39,419
with one method they were able to

796
00:30:39,419 --> 00:30:40,860
predict it and with a particular another

797
00:30:40,860 --> 00:30:43,020
method they were not and so I think

798
00:30:43,020 --> 00:30:45,000
given just to address the question

799
00:30:45,000 --> 00:30:46,679
directly

800
00:30:46,679 --> 00:30:48,539
um given a sufficiently strong algorithm

801
00:30:48,539 --> 00:30:50,640
and given the information and attributes

802
00:30:50,640 --> 00:30:52,020
that average that you could get on the

803
00:30:52,020 --> 00:30:54,299
bus they should not be able to predict

804
00:30:54,299 --> 00:30:56,399
the next address unless they have the

805
00:30:56,399 --> 00:30:57,960
shared key

806
00:30:57,960 --> 00:31:00,539
okay that answered the question

807
00:31:00,539 --> 00:31:02,220
yes

808
00:31:02,220 --> 00:31:04,380
is that hash that you're referring to

809
00:31:04,380 --> 00:31:08,340
does that also serve to like seed the um

810
00:31:08,340 --> 00:31:10,200
pseudo-random number generator for the

811
00:31:10,200 --> 00:31:13,140
methods that were Superior to static so

812
00:31:13,140 --> 00:31:16,559
the hash does not seated uh but the

813
00:31:16,559 --> 00:31:20,600
shared key does help with the c

814
00:31:21,720 --> 00:31:24,000
and the Reynolds permanent could use in

815
00:31:24,000 --> 00:31:24,899
our case

816
00:31:24,899 --> 00:31:27,960
I believe we used uh Shaw hashing but

817
00:31:27,960 --> 00:31:29,340
you could use

818
00:31:29,340 --> 00:31:31,980
a symmetric Cipher and either stream

819
00:31:31,980 --> 00:31:33,840
safer mode block Cipher mode you can use

820
00:31:33,840 --> 00:31:35,279
other Primitives

821
00:31:35,279 --> 00:31:38,940
it's just that once the work got going

822
00:31:38,940 --> 00:31:40,679
the hashing worked for us so we just

823
00:31:40,679 --> 00:31:42,480
kept going on did experiments did

824
00:31:42,480 --> 00:31:44,159
machine learning other attributes of the

825
00:31:44,159 --> 00:31:46,020
research but you could go back and try

826
00:31:46,020 --> 00:31:49,919
you know AES 128256 shot 3 and some

827
00:31:49,919 --> 00:31:51,720
other algorithms to see how they fare

828
00:31:51,720 --> 00:31:53,820
with unpredictably metrics histograms so

829
00:31:53,820 --> 00:31:56,240
on and so forth

830
00:31:57,059 --> 00:31:59,340
yes in the back of the orange

831
00:31:59,340 --> 00:32:01,799
uh you mentioned that there was this one

832
00:32:01,799 --> 00:32:04,020
line of code which which you changed

833
00:32:04,020 --> 00:32:06,419
which effectively reduced the the

834
00:32:06,419 --> 00:32:08,460
prediction capability of the lstm model

835
00:32:08,460 --> 00:32:12,000
uh by like 60 I guess because it was

836
00:32:12,000 --> 00:32:15,240
above 80 initially the ml is predicting

837
00:32:15,240 --> 00:32:17,640
everything and now it was below 20 below

838
00:32:17,640 --> 00:32:20,520
0.2 I was just curious as to uh maybe

839
00:32:20,520 --> 00:32:22,320
maybe you could give me just a general

840
00:32:22,320 --> 00:32:24,840
sort of uh idea so what was the line of

841
00:32:24,840 --> 00:32:26,100
code right it was a very simple change

842
00:32:26,100 --> 00:32:28,740
to go from about 95 down to less than

843
00:32:28,740 --> 00:32:33,360
20. uh so it was changing a enum

844
00:32:33,360 --> 00:32:36,539
that said use static offset versus

845
00:32:36,539 --> 00:32:38,520
current offset and so we just started

846
00:32:38,520 --> 00:32:41,940
using current offset uh be the exact

847
00:32:41,940 --> 00:32:43,919
same experimentation generated the SEC

848
00:32:43,919 --> 00:32:46,620
exact same size data set and then headed

849
00:32:46,620 --> 00:32:49,440
over to Purdue and ran the same model it

850
00:32:49,440 --> 00:32:51,840
came out to 0.14 so I will say this the

851
00:32:51,840 --> 00:32:53,640
students

852
00:32:53,640 --> 00:32:55,860
um definitely we're not as happy that it

853
00:32:55,860 --> 00:32:57,720
couldn't get above good back

854
00:32:57,720 --> 00:33:00,480
um to 95 but from our standpoint this

855
00:33:00,480 --> 00:33:02,279
was great because we designed the

856
00:33:02,279 --> 00:33:06,000
algorithm with knobs to begin with so we

857
00:33:06,000 --> 00:33:07,260
didn't say that this is the way it has

858
00:33:07,260 --> 00:33:09,779
to work and this is the only way it has

859
00:33:09,779 --> 00:33:12,480
to work we actually built your knobs and

860
00:33:12,480 --> 00:33:13,919
so whether that's the size of the state

861
00:33:13,919 --> 00:33:16,320
Matrix how often you update it the way

862
00:33:16,320 --> 00:33:18,539
you index into it and so even though we

863
00:33:18,539 --> 00:33:21,059
had quote-unquote compromise it was a

864
00:33:21,059 --> 00:33:22,620
simple fix because we built it into the

865
00:33:22,620 --> 00:33:24,120
algorithm

866
00:33:24,120 --> 00:33:27,320
but there's a question over here

867
00:33:29,659 --> 00:33:32,340
I'm sure I think you already answered

868
00:33:32,340 --> 00:33:33,120
this

869
00:33:33,120 --> 00:33:35,039
um but it was in reference to how how

870
00:33:35,039 --> 00:33:38,580
often you update the the state Matrix uh

871
00:33:38,580 --> 00:33:40,620
from a adversary

872
00:33:40,620 --> 00:33:43,380
um you know look have you done any brute

873
00:33:43,380 --> 00:33:45,899
forcing methods to see you know what is

874
00:33:45,899 --> 00:33:48,539
the recommended time to do a state

875
00:33:48,539 --> 00:33:52,080
Matrix update so we have not used any

876
00:33:52,080 --> 00:33:53,820
brute force method and you don't mind me

877
00:33:53,820 --> 00:33:55,679
asking can you explain what you mean by

878
00:33:55,679 --> 00:33:58,140
the brute force method

879
00:33:58,140 --> 00:34:01,860
yes like um just trying to

880
00:34:01,860 --> 00:34:04,440
um you randomly guess you know the the

881
00:34:04,440 --> 00:34:07,440
state that the Matrix is in based off of

882
00:34:07,440 --> 00:34:09,899
just using you know a sequence of

883
00:34:09,899 --> 00:34:11,520
numbers like a dictionary a hybrid

884
00:34:11,520 --> 00:34:13,800
dictionary attacker

885
00:34:13,800 --> 00:34:14,820
um

886
00:34:14,820 --> 00:34:17,460
so I would say one of the ideas so the

887
00:34:17,460 --> 00:34:19,379
answer to that is no but one of the

888
00:34:19,379 --> 00:34:21,300
ideas that we originally had

889
00:34:21,300 --> 00:34:23,159
was what if someone was listening on the

890
00:34:23,159 --> 00:34:26,339
bus could they build the state matrix by

891
00:34:26,339 --> 00:34:28,260
just listening

892
00:34:28,260 --> 00:34:29,940
um it's a thing called Kobe to kind of

893
00:34:29,940 --> 00:34:32,159
shut that down personally

894
00:34:32,159 --> 00:34:34,199
um but yes if I could go back in time or

895
00:34:34,199 --> 00:34:35,699
you know have more funding for this work

896
00:34:35,699 --> 00:34:38,699
I think having someone just listen and

897
00:34:38,699 --> 00:34:40,260
see how much a statements they could

898
00:34:40,260 --> 00:34:43,020
build uh would be definitely beneficial

899
00:34:43,020 --> 00:34:44,820
and at least

900
00:34:44,820 --> 00:34:46,918
for the unpredictability message we were

901
00:34:46,918 --> 00:34:47,820
looking at

902
00:34:47,820 --> 00:34:53,280
I think every 32 frames to every 4096

903
00:34:53,280 --> 00:34:55,500
is what the work we're looking at and

904
00:34:55,500 --> 00:34:57,960
what we found out is according to

905
00:34:57,960 --> 00:35:00,240
the work that we did

906
00:35:00,240 --> 00:35:03,780
the amount of updating should not affect

907
00:35:03,780 --> 00:35:05,880
greatly the entropy and Randomness in

908
00:35:05,880 --> 00:35:08,460
the algorithm so if you have a choice

909
00:35:08,460 --> 00:35:11,220
why not just wait longer

910
00:35:11,220 --> 00:35:13,500
um so that you don't necessarily

911
00:35:13,500 --> 00:35:15,420
have to spend as much resources updating

912
00:35:15,420 --> 00:35:17,040
but if it doesn't really cost you

913
00:35:17,040 --> 00:35:19,500
anything you know update it every five

914
00:35:19,500 --> 00:35:22,440
ten frames you know just so that it's

915
00:35:22,440 --> 00:35:24,000
just more entropy and more tougher to

916
00:35:24,000 --> 00:35:25,619
actually guess so hopefully that answers

917
00:35:25,619 --> 00:35:26,700
your question

918
00:35:26,700 --> 00:35:29,640
that does and um I I'm sorry I missed

919
00:35:29,640 --> 00:35:31,680
the first part of your your brief um but

920
00:35:31,680 --> 00:35:33,540
for the exchanging of the the secret key

921
00:35:33,540 --> 00:35:35,099
and everything you're using like a

922
00:35:35,099 --> 00:35:37,740
public key infrastructure or so that was

923
00:35:37,740 --> 00:35:39,780
outside the scope of this works okay you

924
00:35:39,780 --> 00:35:41,339
just assumed that he wanted to

925
00:35:41,339 --> 00:35:43,079
participate you would have been shared

926
00:35:43,079 --> 00:35:45,960
okay Sharon keys

927
00:35:45,960 --> 00:35:47,339
all right I was just thinking like over

928
00:35:47,339 --> 00:35:49,619
the net how the how that approach would

929
00:35:49,619 --> 00:35:53,280
be but look at those pki or another

930
00:35:53,280 --> 00:35:55,320
um variant but yeah we just that was out

931
00:35:55,320 --> 00:35:57,060
of scope for this particular word

932
00:35:57,060 --> 00:35:59,160
uh Jones you have your hand up in the

933
00:35:59,160 --> 00:36:02,040
back for another question online

934
00:36:02,040 --> 00:36:05,520
yes another question came in uh is the

935
00:36:05,520 --> 00:36:07,320
timing for node address rotation

936
00:36:07,320 --> 00:36:08,760
configurable

937
00:36:08,760 --> 00:36:12,780
or does the protocol Force ideal timing

938
00:36:12,780 --> 00:36:14,700
it's configurable so and one of the

939
00:36:14,700 --> 00:36:17,359
charts we were showing we were updating

940
00:36:17,359 --> 00:36:19,500
every frame

941
00:36:19,500 --> 00:36:21,240
and we went all the way up to updating

942
00:36:21,240 --> 00:36:23,880
every 100 frames and you could

943
00:36:23,880 --> 00:36:25,980
potentially do every thousand ten

944
00:36:25,980 --> 00:36:28,200
thousand fifty five twenty two really

945
00:36:28,200 --> 00:36:29,640
whatever you wanted

946
00:36:29,640 --> 00:36:31,560
and that's one of the benefits of it

947
00:36:31,560 --> 00:36:33,240
running on top of the existing protocol

948
00:36:33,240 --> 00:36:35,339
we didn't have to really figure out the

949
00:36:35,339 --> 00:36:37,380
timing the protocol says

950
00:36:37,380 --> 00:36:39,900
this is how you communicate within one

951
00:36:39,900 --> 00:36:43,260
of our messages is in is a 16-bit

952
00:36:43,260 --> 00:36:45,599
uh unsigned integer between the value of

953
00:36:45,599 --> 00:36:47,579
0 and 127.

954
00:36:47,579 --> 00:36:48,960
and so we don't have to do anything

955
00:36:48,960 --> 00:36:51,359
specific for timing it's just a message

956
00:36:51,359 --> 00:36:53,700
like anything else since it's really

957
00:36:53,700 --> 00:36:56,400
overlaid on top of the protocol

958
00:36:56,400 --> 00:36:59,420
thank you for the question

959
00:36:59,520 --> 00:37:01,560
um Amy Mojo

960
00:37:01,560 --> 00:37:04,200
that's it okay so we're going to the

961
00:37:04,200 --> 00:37:06,119
next project uh with my remaining time

962
00:37:06,119 --> 00:37:08,640
so this one we just started uh this

963
00:37:08,640 --> 00:37:11,400
fiscal year we have two more years to go

964
00:37:11,400 --> 00:37:13,680
on it so I think any around September

965
00:37:13,680 --> 00:37:16,260
2024 so I don't have nearly as many

966
00:37:16,260 --> 00:37:18,660
slides for this but it's another idea

967
00:37:18,660 --> 00:37:20,640
that we have called crisp Computing

968
00:37:20,640 --> 00:37:22,440
reconfiguration for resilient Space

969
00:37:22,440 --> 00:37:24,960
Systems and it's a way to improve

970
00:37:24,960 --> 00:37:27,599
execution in a resilient manner on host

971
00:37:27,599 --> 00:37:30,599
and so here Jason Hamlin as I mentioned

972
00:37:30,599 --> 00:37:32,400
my colleague he actually leads the team

973
00:37:32,400 --> 00:37:34,680
that works with Purdue

974
00:37:34,680 --> 00:37:37,619
um that you see here in the slide

975
00:37:37,619 --> 00:37:41,220
so cyber resilience is really one of the

976
00:37:41,220 --> 00:37:42,660
key

977
00:37:42,660 --> 00:37:45,599
factors of this particular work and so a

978
00:37:45,599 --> 00:37:46,920
lot of times people say cyber security

979
00:37:46,920 --> 00:37:49,500
so the first question is well how is it

980
00:37:49,500 --> 00:37:51,599
different from cyber resilience and so

981
00:37:51,599 --> 00:37:53,040
what we think of cyber security is you

982
00:37:53,040 --> 00:37:55,260
make this perimeter but once you get

983
00:37:55,260 --> 00:37:56,760
inside a perimeter it's kind of fair

984
00:37:56,760 --> 00:37:58,020
again you can do whatever you want

985
00:37:58,020 --> 00:38:00,180
whereas cyber resilience is really

986
00:38:00,180 --> 00:38:01,619
people thinking of hey you're going to

987
00:38:01,619 --> 00:38:04,619
come inside my perimeter what else can I

988
00:38:04,619 --> 00:38:06,420
do to make it harder that once you do

989
00:38:06,420 --> 00:38:08,220
get inside it makes it harder to do more

990
00:38:08,220 --> 00:38:10,380
damage and potentially in case of this

991
00:38:10,380 --> 00:38:12,420
particular graphic can I expedite

992
00:38:12,420 --> 00:38:14,220
recovery where I can still execute my

993
00:38:14,220 --> 00:38:16,859
mission as needed so not having this

994
00:38:16,859 --> 00:38:18,720
assumption that I have the strong

995
00:38:18,720 --> 00:38:21,359
perimeter once you're inside uh you have

996
00:38:21,359 --> 00:38:23,700
free lateral movement but that really it

997
00:38:23,700 --> 00:38:25,440
makes it harder for you to penetrate if

998
00:38:25,440 --> 00:38:27,320
you do penetrate it's a graceful

999
00:38:27,320 --> 00:38:30,060
degradation excuse me and then also

1000
00:38:30,060 --> 00:38:32,220
expedite recovery so hopefully get back

1001
00:38:32,220 --> 00:38:34,560
to completing the mission

1002
00:38:34,560 --> 00:38:36,060
so as I mentioned when I first started

1003
00:38:36,060 --> 00:38:38,160
right space represents this new frontier

1004
00:38:38,160 --> 00:38:40,500
in cyber security I'm sure you've heard

1005
00:38:40,500 --> 00:38:42,119
about different things going on in the

1006
00:38:42,119 --> 00:38:44,579
government that's looking at space

1007
00:38:44,579 --> 00:38:46,740
and so what we wanted to look at is

1008
00:38:46,740 --> 00:38:49,140
heterogeneous Computing platforms so

1009
00:38:49,140 --> 00:38:50,880
we've learned that a lot of future Space

1010
00:38:50,880 --> 00:38:53,400
Systems are potentially moving away from

1011
00:38:53,400 --> 00:38:55,560
homogeneous Computing platforms and

1012
00:38:55,560 --> 00:38:57,060
moving over to heterogeneous Computing

1013
00:38:57,060 --> 00:39:00,119
platforms so we wanted to know that even

1014
00:39:00,119 --> 00:39:01,680
though this changes because you want to

1015
00:39:01,680 --> 00:39:03,300
get more performance

1016
00:39:03,300 --> 00:39:05,760
okay when you also use those new systems

1017
00:39:05,760 --> 00:39:09,119
to improve cyber resiliency

1018
00:39:09,119 --> 00:39:11,280
and so to look at what is homogeneous

1019
00:39:11,280 --> 00:39:12,839
Computing platform if these have been

1020
00:39:12,839 --> 00:39:15,599
around for a lot longer typically you

1021
00:39:15,599 --> 00:39:17,880
have a certain set of compute units that

1022
00:39:17,880 --> 00:39:20,339
are identical and you run software that

1023
00:39:20,339 --> 00:39:21,660
are identical

1024
00:39:21,660 --> 00:39:24,599
as you see here on the slide dual core

1025
00:39:24,599 --> 00:39:27,000
acquired core you can have soft CPUs in

1026
00:39:27,000 --> 00:39:29,579
the fpga but everything is identical and

1027
00:39:29,579 --> 00:39:32,760
everything is running the same software

1028
00:39:32,760 --> 00:39:35,520
and so really the big output of

1029
00:39:35,520 --> 00:39:37,200
homogeneous Computing platforms is what

1030
00:39:37,200 --> 00:39:41,099
we call TMR or triple modular redundancy

1031
00:39:41,099 --> 00:39:43,380
um a joke we had earlier today we're

1032
00:39:43,380 --> 00:39:45,119
meeting one of the professors was that

1033
00:39:45,119 --> 00:39:46,740
when you submit a paper you may have

1034
00:39:46,740 --> 00:39:48,900
three reviewers

1035
00:39:48,900 --> 00:39:50,940
and as long as two of those reviewers

1036
00:39:50,940 --> 00:39:53,339
accept the paper then your paper may get

1037
00:39:53,339 --> 00:39:55,320
accepted so we actually use this in real

1038
00:39:55,320 --> 00:39:56,339
life

1039
00:39:56,339 --> 00:39:57,660
um but going back to homogeneous

1040
00:39:57,660 --> 00:39:59,339
computing

1041
00:39:59,339 --> 00:40:01,859
um TMR typically has three Computing

1042
00:40:01,859 --> 00:40:04,800
units running identical software and as

1043
00:40:04,800 --> 00:40:07,500
long as two of the units agree

1044
00:40:07,500 --> 00:40:09,660
those units typically May save some

1045
00:40:09,660 --> 00:40:12,000
State and reinitialize the disagreeing

1046
00:40:12,000 --> 00:40:14,460
unit with that state and then they all

1047
00:40:14,460 --> 00:40:16,619
continue forward another way you can do

1048
00:40:16,619 --> 00:40:18,420
it is what's called dmrs you don't need

1049
00:40:18,420 --> 00:40:21,000
a third compute unit the challenge being

1050
00:40:21,000 --> 00:40:22,980
that if there is a fault or disagreement

1051
00:40:22,980 --> 00:40:24,420
you don't know which one is right which

1052
00:40:24,420 --> 00:40:25,740
one is wrong

1053
00:40:25,740 --> 00:40:27,839
and so you can either go back to a

1054
00:40:27,839 --> 00:40:30,480
checkpoint you can reset the system you

1055
00:40:30,480 --> 00:40:32,280
can just issue an alarm or a fault and

1056
00:40:32,280 --> 00:40:34,440
maybe just wait for someone to intervene

1057
00:40:34,440 --> 00:40:36,300
some of the DMR systems usually was

1058
00:40:36,300 --> 00:40:38,339
called lockstep which is at some level

1059
00:40:38,339 --> 00:40:39,900
they could actually execute the same

1060
00:40:39,900 --> 00:40:42,140
instruction in the processor in lockstep

1061
00:40:42,140 --> 00:40:44,160
sometimes there could be a little bit of

1062
00:40:44,160 --> 00:40:46,579
slack so maybe you know four or five

1063
00:40:46,579 --> 00:40:48,660
instructions behind or even something

1064
00:40:48,660 --> 00:40:51,260
much larger but typically in lockstep

1065
00:40:51,260 --> 00:40:53,460
executing at the same time and the

1066
00:40:53,460 --> 00:40:55,140
output is checked at some sync point

1067
00:40:55,140 --> 00:40:57,660
which could be a checkpoint checkpoint

1068
00:40:57,660 --> 00:41:00,359
is being that every so often I take some

1069
00:41:00,359 --> 00:41:03,060
way some image of my state and I have a

1070
00:41:03,060 --> 00:41:04,560
way of getting back to that checkpoint

1071
00:41:04,560 --> 00:41:08,099
so in case my two outputs disagree I

1072
00:41:08,099 --> 00:41:09,599
jump back to the checkpoint and then

1073
00:41:09,599 --> 00:41:11,820
just continue

1074
00:41:11,820 --> 00:41:14,700
and so this is how we use typically

1075
00:41:14,700 --> 00:41:17,520
homogeneous Computing platforms

1076
00:41:17,520 --> 00:41:19,200
so when you think about heterogeneous

1077
00:41:19,200 --> 00:41:21,420
Computing platforms and um hopefully the

1078
00:41:21,420 --> 00:41:23,400
colors are coming through online as well

1079
00:41:23,400 --> 00:41:25,740
we can see that we have a lot more

1080
00:41:25,740 --> 00:41:28,680
diversity we have different compute ones

1081
00:41:28,680 --> 00:41:30,660
and so these are the kind of platforms

1082
00:41:30,660 --> 00:41:33,060
are starting to be used in particular

1083
00:41:33,060 --> 00:41:34,740
we're looking at the designs for sale

1084
00:41:34,740 --> 00:41:37,079
platform where you don't necessarily

1085
00:41:37,079 --> 00:41:40,140
have a quad-core CPU

1086
00:41:40,140 --> 00:41:41,880
um you don't necessarily maybe have a

1087
00:41:41,880 --> 00:41:44,820
quad-core you know DSP you don't have

1088
00:41:44,820 --> 00:41:48,960
enough units to have maybe TMR and so

1089
00:41:48,960 --> 00:41:51,660
what we want to look at is can we look

1090
00:41:51,660 --> 00:41:52,859
at these heterogeneous competing

1091
00:41:52,859 --> 00:41:54,060
platforms

1092
00:41:54,060 --> 00:41:56,220
and still get the resiliency that we had

1093
00:41:56,220 --> 00:41:58,320
in homogeneous opinion platforms were

1094
00:41:58,320 --> 00:42:01,140
potentially done in a different way

1095
00:42:01,140 --> 00:42:03,960
and looking at space Platforms in

1096
00:42:03,960 --> 00:42:06,359
particular you may start out with one

1097
00:42:06,359 --> 00:42:08,520
platform here we have the result on the

1098
00:42:08,520 --> 00:42:10,920
left side and because Space Systems are

1099
00:42:10,920 --> 00:42:12,480
built to be modular you may get

1100
00:42:12,480 --> 00:42:14,760
additional compute units at some point

1101
00:42:14,760 --> 00:42:16,440
in the future so can you incorporate

1102
00:42:16,440 --> 00:42:20,220
them into your cyber resiliency

1103
00:42:20,220 --> 00:42:22,619
and so at the high level what we want to

1104
00:42:22,619 --> 00:42:25,440
do is just the same way TCP guarantees

1105
00:42:25,440 --> 00:42:27,300
Network traffic will get across the

1106
00:42:27,300 --> 00:42:30,660
internet can we use crisp to guarantee

1107
00:42:30,660 --> 00:42:33,480
execution or in our case uh have

1108
00:42:33,480 --> 00:42:35,880
resilient execution and so our first

1109
00:42:35,880 --> 00:42:39,180
experiment is looking at sorting a one

1110
00:42:39,180 --> 00:42:41,400
million element array in the presence of

1111
00:42:41,400 --> 00:42:43,740
fonts and we want to know can we

1112
00:42:43,740 --> 00:42:46,500
organize the system in such a way that

1113
00:42:46,500 --> 00:42:48,900
that sorting will always come out

1114
00:42:48,900 --> 00:42:50,220
correctly

1115
00:42:50,220 --> 00:42:52,800
regardless if it's a Cyber attack

1116
00:42:52,800 --> 00:42:55,020
um the presence of ions hitting some of

1117
00:42:55,020 --> 00:42:57,540
the processors radiation any other

1118
00:42:57,540 --> 00:43:00,420
faults that may happen in the system but

1119
00:43:00,420 --> 00:43:03,420
can we guarantee a TMR like system on

1120
00:43:03,420 --> 00:43:05,640
heterogeneous defeating platforms where

1121
00:43:05,640 --> 00:43:08,160
we always have the same um sorted array

1122
00:43:08,160 --> 00:43:09,540
and then we're also looking at

1123
00:43:09,540 --> 00:43:11,280
compression and maybe even a few other

1124
00:43:11,280 --> 00:43:14,579
algorithms as part of this work as well

1125
00:43:14,579 --> 00:43:16,800
just to see can we guarantee that

1126
00:43:16,800 --> 00:43:18,660
software will always make progression

1127
00:43:18,660 --> 00:43:21,420
and if there is a fault it can remedy

1128
00:43:21,420 --> 00:43:23,099
itself on a heterogeneous Computing

1129
00:43:23,099 --> 00:43:24,599
platform

1130
00:43:24,599 --> 00:43:27,480
and here on the right side uh for any of

1131
00:43:27,480 --> 00:43:29,520
fiscal year 22 and also fifth year 23

1132
00:43:29,520 --> 00:43:31,440
you can see some of the items that

1133
00:43:31,440 --> 00:43:33,960
Purdue is helping us with um at Sandia

1134
00:43:33,960 --> 00:43:35,460
they're going to focus a lot more on the

1135
00:43:35,460 --> 00:43:37,740
algorithm some simulations and then

1136
00:43:37,740 --> 00:43:38,640
we're going to have the physical

1137
00:43:38,640 --> 00:43:41,400
Hardware I'm at our labs and take their

1138
00:43:41,400 --> 00:43:43,020
output and actually run it code it up

1139
00:43:43,020 --> 00:43:46,260
and run it on our physical Hardware

1140
00:43:46,260 --> 00:43:48,300
so that's the end of my presentation uh

1141
00:43:48,300 --> 00:43:49,380
definitely want to thank you for your

1142
00:43:49,380 --> 00:43:52,380
time happy back again went to Purdue and

1143
00:43:52,380 --> 00:43:54,240
now I'll take any questions you may have

1144
00:43:54,240 --> 00:43:56,959
thank you

1145
00:43:57,240 --> 00:44:00,240
foreign

1146
00:44:23,060 --> 00:44:26,940
oh yeah hi uh Chris uh

1147
00:44:26,940 --> 00:44:29,339
you presented it so beautifully I can't

1148
00:44:29,339 --> 00:44:32,099
believe it uh very impressed

1149
00:44:32,099 --> 00:44:32,760
um

1150
00:44:32,760 --> 00:44:35,160
and also it's recorded So

1151
00:44:35,160 --> 00:44:37,619
many students will be able to

1152
00:44:37,619 --> 00:44:40,400
uh listen to this

1153
00:44:40,400 --> 00:44:42,540
I don't have any

1154
00:44:42,540 --> 00:44:46,319
specific question but um

1155
00:44:46,319 --> 00:44:50,099
what I want you to encourage is what the

1156
00:44:50,099 --> 00:44:52,940
students can do

1157
00:44:54,060 --> 00:44:56,460
so thank you for the kind words so one

1158
00:44:56,460 --> 00:44:58,020
thing I would say for the students as

1159
00:44:58,020 --> 00:44:59,640
always when you have people come up and

1160
00:44:59,640 --> 00:45:00,720
speak

1161
00:45:00,720 --> 00:45:02,099
um definitely take the time to learn a

1162
00:45:02,099 --> 00:45:03,119
little bit more about their company

1163
00:45:03,119 --> 00:45:05,339
because believe it or not I was in your

1164
00:45:05,339 --> 00:45:07,980
seat at one point and so you are you are

1165
00:45:07,980 --> 00:45:09,180
going to school to learn some

1166
00:45:09,180 --> 00:45:11,700
fascinating facts to be able to give

1167
00:45:11,700 --> 00:45:13,079
back in your profession and actually

1168
00:45:13,079 --> 00:45:14,640
work in a profession you enjoy so

1169
00:45:14,640 --> 00:45:16,740
definitely afterwards you want to talk

1170
00:45:16,740 --> 00:45:18,900
about internships I do recruit so I've

1171
00:45:18,900 --> 00:45:20,160
been out to about four or five

1172
00:45:20,160 --> 00:45:22,500
universities I'm going out to one in

1173
00:45:22,500 --> 00:45:24,000
about two weeks to recruit so we can

1174
00:45:24,000 --> 00:45:25,859
talk about internships and different

1175
00:45:25,859 --> 00:45:27,900
ways which you plugged in to uh plugged

1176
00:45:27,900 --> 00:45:29,940
in at Sandia so definitely feel free to

1177
00:45:29,940 --> 00:45:33,380
come up and speak afterwards as well

1178
00:45:34,140 --> 00:45:37,079
uh when is a good time for students to

1179
00:45:37,079 --> 00:45:39,720
contact you for the internships

1180
00:45:39,720 --> 00:45:42,780
so we just had our postings go out I

1181
00:45:42,780 --> 00:45:45,000
think uh this month

1182
00:45:45,000 --> 00:45:47,700
and we're probably going to have them

1183
00:45:47,700 --> 00:45:50,880
close around December and so the

1184
00:45:50,880 --> 00:45:53,099
Institute that I primarily interview for

1185
00:45:53,099 --> 00:45:55,859
is called CCD or the center for cyber

1186
00:45:55,859 --> 00:45:57,720
Defenders it's one of the Premier

1187
00:45:57,720 --> 00:46:00,119
institutes that we have at Sandia it's

1188
00:46:00,119 --> 00:46:03,359
about I don't know 30 to 15 students in

1189
00:46:03,359 --> 00:46:05,099
that particular Institute we have others

1190
00:46:05,099 --> 00:46:07,260
so probably whether someone who may have

1191
00:46:07,260 --> 00:46:09,839
around a thousand interns or so but the

1192
00:46:09,839 --> 00:46:11,880
CCD is really the institute for those

1193
00:46:11,880 --> 00:46:13,440
that are focusing and want to know more

1194
00:46:13,440 --> 00:46:17,160
about cyber security and so you if you

1195
00:46:17,160 --> 00:46:18,660
do apply

1196
00:46:18,660 --> 00:46:19,560
um I could definitely give you the

1197
00:46:19,560 --> 00:46:21,240
requisition number to apply to but if

1198
00:46:21,240 --> 00:46:22,980
you do apply you may actually talk to me

1199
00:46:22,980 --> 00:46:24,240
on the phone

1200
00:46:24,240 --> 00:46:26,460
um do a quick phone screen and typically

1201
00:46:26,460 --> 00:46:29,339
I give my assessment back to the people

1202
00:46:29,339 --> 00:46:31,440
who make the decision and then if they

1203
00:46:31,440 --> 00:46:34,200
decide to say yes then typically come

1204
00:46:34,200 --> 00:46:36,300
out in the summer but the way things

1205
00:46:36,300 --> 00:46:38,640
have been the last few years

1206
00:46:38,640 --> 00:46:39,900
um you may even be able to stay in

1207
00:46:39,900 --> 00:46:42,960
working mode I know for myself we had a

1208
00:46:42,960 --> 00:46:44,460
we had a few students come out this

1209
00:46:44,460 --> 00:46:47,040
summer and I believe two of them now are

1210
00:46:47,040 --> 00:46:49,140
year round so he went back to school but

1211
00:46:49,140 --> 00:46:50,700
they're still logging remotely and work

1212
00:46:50,700 --> 00:46:52,920
on the project that we have for them

1213
00:46:52,920 --> 00:46:54,599
okay definitely coming out for the

1214
00:46:54,599 --> 00:46:56,520
summer can turn into a year-round

1215
00:46:56,520 --> 00:46:58,140
employment

1216
00:46:58,140 --> 00:47:01,440
thank you Chris Sandia will be on campus

1217
00:47:01,440 --> 00:47:04,680
uh September 13th at the Sirius uh cyber

1218
00:47:04,680 --> 00:47:07,560
security recruitment Fair uh and uh

1219
00:47:07,560 --> 00:47:10,260
emails will be going out to uh all of

1220
00:47:10,260 --> 00:47:12,780
the students who are on the um serious

1221
00:47:12,780 --> 00:47:15,060
Affiliated student list which you can

1222
00:47:15,060 --> 00:47:18,200
sign up for at

1223
00:47:18,920 --> 00:47:21,839
www.serious.purdue.edu students

1224
00:47:21,839 --> 00:47:23,640
and I believe there's an engineering

1225
00:47:23,640 --> 00:47:25,440
Career Fair coming up and we'll be here

1226
00:47:25,440 --> 00:47:27,660
as well so another one of my colleagues

1227
00:47:27,660 --> 00:47:30,180
who graduated from Purdue uh Sylvia I

1228
00:47:30,180 --> 00:47:31,200
believe she'll be coming out here as

1229
00:47:31,200 --> 00:47:32,839
well

1230
00:47:32,839 --> 00:47:35,099
and with that we are at the end of the

1231
00:47:35,099 --> 00:47:36,900
class period Chris thank you very much

1232
00:47:36,900 --> 00:47:39,780
for joining us uh to those in the room

1233
00:47:39,780 --> 00:47:41,940
and those virtually tuning in thanks

1234
00:47:41,940 --> 00:47:43,380
very much and we'll see you again next

1235
00:47:43,380 --> 00:47:46,520
week thank you

