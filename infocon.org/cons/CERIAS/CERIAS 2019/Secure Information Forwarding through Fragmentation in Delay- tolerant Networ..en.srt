1
00:00:06,290 --> 00:00:15,660
welcome to the serious seminar for

2
00:00:09,780 --> 00:00:18,960
January 24th the where I'm honored today

3
00:00:15,660 --> 00:00:22,410
to be able to welcome dr. Sanjay Maud

4
00:00:18,960 --> 00:00:25,259
Rhea who is the curators distinguished

5
00:00:22,410 --> 00:00:31,859
professor at the Missouri University of

6
00:00:25,259 --> 00:00:36,150
Science and Technology Sanjay has been

7
00:00:31,859 --> 00:00:38,670
the faculty at the Missouri S&T since

8
00:00:36,150 --> 00:00:41,210
well before it was Missouri S&T used to

9
00:00:38,670 --> 00:00:46,110
be known as University of Missouri Rolla

10
00:00:41,210 --> 00:00:51,060
got his PhD at the university or the IIT

11
00:00:46,110 --> 00:00:53,940
in Delhi as actually spent time on the

12
00:00:51,060 --> 00:00:58,200
faculty here at Purdue as a visiting

13
00:00:53,940 --> 00:01:02,790
professor so we are actually welcoming

14
00:00:58,200 --> 00:01:04,680
him back to Purdue he has an extensive

15
00:01:02,790 --> 00:01:07,439
record of research in network security

16
00:01:04,680 --> 00:01:09,329
and particular recently a lot in using

17
00:01:07,439 --> 00:01:13,949
machine learning techniques and big data

18
00:01:09,329 --> 00:01:16,529
to address cloud mobile and network

19
00:01:13,950 --> 00:01:19,469
security issues so with that I will turn

20
00:01:16,530 --> 00:01:19,890
it over to you thanks Chris nice seeing

21
00:01:19,469 --> 00:01:23,280
you

22
00:01:19,890 --> 00:01:28,380
I think we met in an ACEF I guess yes

23
00:01:23,280 --> 00:01:31,140
last time yes thank you thanks all for

24
00:01:28,380 --> 00:01:36,329
coming and thanks to Sarai's for

25
00:01:31,140 --> 00:01:40,889
inviting me here I started my carrier in

26
00:01:36,329 --> 00:01:48,889
us here in Purdue and I remember

27
00:01:40,889 --> 00:01:53,850
receiving $50,000 also a grant in 99 so

28
00:01:48,889 --> 00:01:59,490
it's nice to give a talk now so this

29
00:01:53,850 --> 00:02:03,630
talk is based on my paper last year in s

30
00:01:59,490 --> 00:02:05,939
RDS 2018 and this research is funded by

31
00:02:03,630 --> 00:02:09,750
Air Force Research Lab out of Rome New

32
00:02:05,939 --> 00:02:14,040
York I'm actually on sabbatical this

33
00:02:09,750 --> 00:02:20,260
year so spending some time there also

34
00:02:14,040 --> 00:02:23,858
so the work basically is focused on you

35
00:02:20,260 --> 00:02:28,439
know in military and battlefield and

36
00:02:23,859 --> 00:02:32,409
also in a disaster prone areas you know

37
00:02:28,439 --> 00:02:35,260
the most important thing is how to get

38
00:02:32,409 --> 00:02:37,780
the message in a timely manner and also

39
00:02:35,260 --> 00:02:44,560
we'd like to send the message in a

40
00:02:37,780 --> 00:02:49,060
secure fashion okay so as you can see

41
00:02:44,560 --> 00:02:50,260
you know a problem statement that you

42
00:02:49,060 --> 00:02:52,060
know you're talking about the

43
00:02:50,260 --> 00:02:54,730
applications of battlefield or disaster

44
00:02:52,060 --> 00:02:56,650
affect the area where multiple groups

45
00:02:54,730 --> 00:02:59,018
you know for example in the battle for

46
00:02:56,650 --> 00:03:00,879
their narrow forces you know so they

47
00:02:59,019 --> 00:03:03,040
come from many different countries and

48
00:03:00,879 --> 00:03:05,200
in the disaster you know there's a Red

49
00:03:03,040 --> 00:03:06,879
Cross and then there's a FEMA and then

50
00:03:05,200 --> 00:03:10,209
there's a you know all other agencies

51
00:03:06,879 --> 00:03:13,209
trying to collaborate with each other so

52
00:03:10,209 --> 00:03:15,159
they need to transfer messages and also

53
00:03:13,209 --> 00:03:17,230
in this case we are talking about

54
00:03:15,159 --> 00:03:19,840
transferring the message in a secure

55
00:03:17,230 --> 00:03:22,090
fashion and also in an efficient way

56
00:03:19,840 --> 00:03:23,919
that basically means we are talking

57
00:03:22,090 --> 00:03:26,409
about mobile devices and wireless

58
00:03:23,919 --> 00:03:29,470
networks so the energy and the bandwidth

59
00:03:26,409 --> 00:03:30,940
is the most important thing and if

60
00:03:29,470 --> 00:03:33,819
you're a graduate student you know I

61
00:03:30,940 --> 00:03:35,560
always tell my grad students that the

62
00:03:33,819 --> 00:03:37,089
problem statement has to be very crisp

63
00:03:35,560 --> 00:03:39,310
and clear you know you cannot describe

64
00:03:37,090 --> 00:03:42,760
your problem in ten minutes it should

65
00:03:39,310 --> 00:03:45,940
take one minute right so that's why I

66
00:03:42,760 --> 00:03:48,069
have a very brief problem statement so

67
00:03:45,940 --> 00:03:50,228
within this what I'm trying to address

68
00:03:48,069 --> 00:03:52,750
is so what are the issues in that

69
00:03:50,229 --> 00:03:54,970
environment so for example no

70
00:03:52,750 --> 00:03:57,579
infrastructure you know so we are not

71
00:03:54,970 --> 00:04:00,400
talking about any backbone for example

72
00:03:57,579 --> 00:04:02,500
so secure message then have to be sent

73
00:04:00,400 --> 00:04:04,030
under store forward paradigm in a

74
00:04:02,500 --> 00:04:11,109
delayed trolley network how many of you

75
00:04:04,030 --> 00:04:13,000
know about DTM nobody okay so the DTN is

76
00:04:11,109 --> 00:04:14,680
called delay tolerant network so this is

77
00:04:13,000 --> 00:04:16,329
like what you do is if you want to

78
00:04:14,680 --> 00:04:18,190
transfer a message you know you have

79
00:04:16,329 --> 00:04:20,680
your phone device or smart device and

80
00:04:18,190 --> 00:04:22,389
then you get the message as you move

81
00:04:20,680 --> 00:04:24,700
around from somebody so you don't know

82
00:04:22,389 --> 00:04:26,440
whom you are gonna meet right and that's

83
00:04:24,700 --> 00:04:27,490
why it's called delay so you do store

84
00:04:26,440 --> 00:04:29,590
forward right

85
00:04:27,490 --> 00:04:31,180
so you store for some time and then

86
00:04:29,590 --> 00:04:33,008
forward if you meet somebody who has

87
00:04:31,180 --> 00:04:34,870
interest in that packet right so it's

88
00:04:33,009 --> 00:04:37,210
like campus you know all this do and may

89
00:04:34,870 --> 00:04:39,190
not be interesting everything but then

90
00:04:37,210 --> 00:04:41,440
the idea is you like to route the

91
00:04:39,190 --> 00:04:43,479
message to some building and you don't

92
00:04:41,440 --> 00:04:45,039
know who's gonna go there and there are

93
00:04:43,479 --> 00:04:47,949
many different applications you know

94
00:04:45,039 --> 00:04:49,568
like people try to use using the social

95
00:04:47,949 --> 00:04:52,180
aspect right so if you're trying to

96
00:04:49,569 --> 00:04:53,410
transfer some files about movies you

97
00:04:52,180 --> 00:04:59,020
know in general and those things

98
00:04:53,410 --> 00:05:01,630
important so actually DTN is used really

99
00:04:59,020 --> 00:05:03,940
used in battlefield and disaster and

100
00:05:01,630 --> 00:05:07,270
there's one very important application I

101
00:05:03,940 --> 00:05:09,130
found in Kenya and you know other

102
00:05:07,270 --> 00:05:12,159
countries where they don't have the

103
00:05:09,130 --> 00:05:15,280
bandwidth available so what the lecturer

104
00:05:12,160 --> 00:05:17,380
or the teacher is doing from home you

105
00:05:15,280 --> 00:05:19,929
know the person downloads all the

106
00:05:17,380 --> 00:05:22,870
important lessons on his device and then

107
00:05:19,930 --> 00:05:25,030
come to the school and then based on the

108
00:05:22,870 --> 00:05:27,699
topic they distribute you know

109
00:05:25,030 --> 00:05:30,669
automatically to different people I

110
00:05:27,699 --> 00:05:33,099
recently had it so this part of a bigger

111
00:05:30,669 --> 00:05:35,650
very big project I'm just doing one part

112
00:05:33,099 --> 00:05:38,320
of it and the whole idea was how you can

113
00:05:35,650 --> 00:05:39,638
transfer you know in a battlefield ok so

114
00:05:38,320 --> 00:05:41,949
there are multiple groups are

115
00:05:39,639 --> 00:05:45,280
operational as I said so the major issue

116
00:05:41,949 --> 00:05:47,380
here is finding a notes public key is

117
00:05:45,280 --> 00:05:49,270
not always so we call it always like

118
00:05:47,380 --> 00:05:51,699
public key that we assume right in other

119
00:05:49,270 --> 00:05:54,729
case it's a public it's available but

120
00:05:51,699 --> 00:05:57,070
not in these scenarios and not everybody

121
00:05:54,729 --> 00:05:59,919
actually is authorized to even send the

122
00:05:57,070 --> 00:06:02,680
messages you know so it's not always

123
00:05:59,919 --> 00:06:06,190
possible and only some notes basically

124
00:06:02,680 --> 00:06:09,699
can have an authorization who basically

125
00:06:06,190 --> 00:06:12,310
can encrypt and forward the messages so

126
00:06:09,699 --> 00:06:14,380
there's no centralized trusted Authority

127
00:06:12,310 --> 00:06:16,539
or you know who can generate the keys

128
00:06:14,380 --> 00:06:18,400
for example or that maybe we haven't

129
00:06:16,539 --> 00:06:20,080
compromised even if it's on a Humvee

130
00:06:18,400 --> 00:06:23,919
let's say you know that hum you might

131
00:06:20,080 --> 00:06:27,370
have been compromised same thing so you

132
00:06:23,919 --> 00:06:32,258
cannot do the traditional public/private

133
00:06:27,370 --> 00:06:34,360
key thing ok so as you can see the

134
00:06:32,259 --> 00:06:36,820
challenge is how we can pass the

135
00:06:34,360 --> 00:06:38,919
messages securely and ensure that

136
00:06:36,820 --> 00:06:41,139
they're readable only by the destination

137
00:06:38,919 --> 00:06:45,340
node where it is intended to go

138
00:06:41,139 --> 00:06:48,310
and the other challenge is how each node

139
00:06:45,340 --> 00:06:49,900
can take care of its own keys and

140
00:06:48,310 --> 00:06:54,490
generating the keys and doing the

141
00:06:49,900 --> 00:06:57,250
validation okay so what's the

142
00:06:54,490 --> 00:06:59,319
contribution here in this work we design

143
00:06:57,250 --> 00:07:01,479
a secure data dissemination l garden

144
00:06:59,319 --> 00:07:04,150
based on data and key fragmentation so

145
00:07:01,479 --> 00:07:06,219
what we're trying to do first is we are

146
00:07:04,150 --> 00:07:08,438
fragmenting the data as well as we are

147
00:07:06,219 --> 00:07:10,689
fragmenting the keys okay and then I

148
00:07:08,439 --> 00:07:12,460
will tell you how we are doing that we

149
00:07:10,689 --> 00:07:13,780
also support integrally check for both

150
00:07:12,460 --> 00:07:16,508
the key and data fragments because

151
00:07:13,780 --> 00:07:18,580
somebody can tamper right or somebody

152
00:07:16,509 --> 00:07:20,740
can also drop right a simple black hole

153
00:07:18,580 --> 00:07:23,318
attack that somebody's not forwarding

154
00:07:20,740 --> 00:07:25,780
okay and they can tamper either key or

155
00:07:23,319 --> 00:07:29,530
they can tamper for example the data

156
00:07:25,780 --> 00:07:31,599
fragments so we have done both the

157
00:07:29,530 --> 00:07:33,669
things here what I mean is we have

158
00:07:31,599 --> 00:07:36,878
simulated using the DT and simulator

159
00:07:33,669 --> 00:07:40,000
called 1 and we also have implemented

160
00:07:36,879 --> 00:07:44,620
this on Android platform ok and I'll

161
00:07:40,000 --> 00:07:47,139
show you some screenshots so some

162
00:07:44,620 --> 00:07:50,590
related work so if you work in security

163
00:07:47,139 --> 00:07:53,139
you might be thinking that possibly you

164
00:07:50,590 --> 00:07:56,349
can do using the identities right so you

165
00:07:53,139 --> 00:07:58,599
can use ibc but the problem is again in

166
00:07:56,349 --> 00:08:00,339
the environment which we are talking D

167
00:07:58,599 --> 00:08:03,639
it's very hard to know the identities of

168
00:08:00,339 --> 00:08:05,080
other people right and also that means

169
00:08:03,639 --> 00:08:07,779
if you know the identities then there's

170
00:08:05,080 --> 00:08:09,190
a privacy problem right similarly if you

171
00:08:07,779 --> 00:08:11,620
are trying to use attribute based

172
00:08:09,190 --> 00:08:12,819
encryption here that's again a problem

173
00:08:11,620 --> 00:08:15,069
because you're not talking about

174
00:08:12,819 --> 00:08:18,279
attributes here we are talking about

175
00:08:15,069 --> 00:08:22,180
that how these different authorities can

176
00:08:18,279 --> 00:08:23,620
basically maintain the keys so here we

177
00:08:22,180 --> 00:08:24,669
are not talking like attributes which

178
00:08:23,620 --> 00:08:26,500
are managed by different authorities

179
00:08:24,669 --> 00:08:29,710
right here we are talking about the note

180
00:08:26,500 --> 00:08:32,140
themselves see so the one other work

181
00:08:29,710 --> 00:08:35,289
which is very close to this is called

182
00:08:32,140 --> 00:08:37,870
multi-party encryption and I have

183
00:08:35,289 --> 00:08:39,968
compared my work with this one and as

184
00:08:37,870 --> 00:08:43,060
you can see here that this particular

185
00:08:39,969 --> 00:08:45,010
work has this two things called chaining

186
00:08:43,059 --> 00:08:51,609
and fragmentation and they try to

187
00:08:45,010 --> 00:08:53,910
address this issues ok so let me explain

188
00:08:51,610 --> 00:08:56,040
you how eme works ok

189
00:08:53,910 --> 00:08:57,959
I'm sorry this pointer will not work on

190
00:08:56,040 --> 00:09:02,459
this side so I have to only focus here

191
00:08:57,959 --> 00:09:05,550
so let's see here that I have an Alice

192
00:09:02,459 --> 00:09:08,069
and he does not have the public key of

193
00:09:05,550 --> 00:09:11,579
Bob and he would like to communicate

194
00:09:08,069 --> 00:09:13,110
with Bob okay and then as you can see

195
00:09:11,579 --> 00:09:15,239
there's an arrant who does not have the

196
00:09:13,110 --> 00:09:18,870
public key of Bob but he has a public

197
00:09:15,240 --> 00:09:20,790
key of Frank okay and Chuck has a public

198
00:09:18,870 --> 00:09:22,800
key of Bob they would have the public

199
00:09:20,790 --> 00:09:30,449
key of Bob and Frank has a public key of

200
00:09:22,800 --> 00:09:33,599
Bob okay so now the Alice basically has

201
00:09:30,449 --> 00:09:36,120
a key and the data what alice is doing

202
00:09:33,600 --> 00:09:39,180
is it's dividing the key into different

203
00:09:36,120 --> 00:09:42,209
fragments okay using some algorithm and

204
00:09:39,180 --> 00:09:45,839
I'll tell you what we are using K 1 K 2

205
00:09:42,209 --> 00:09:49,638
K 3 and then it encrypts the data with

206
00:09:45,839 --> 00:09:51,449
the key k okay and this person now

207
00:09:49,639 --> 00:09:53,370
basically is going to send this

208
00:09:51,449 --> 00:09:56,219
information now this each one of these

209
00:09:53,370 --> 00:09:57,569
notes is a idolater all in node okay in

210
00:09:56,220 --> 00:09:59,579
the network so they are like going

211
00:09:57,569 --> 00:10:03,990
around and getting the information from

212
00:09:59,579 --> 00:10:07,949
others so what this guy is going to do

213
00:10:03,990 --> 00:10:09,930
he meets Aaron encrypts with the public

214
00:10:07,949 --> 00:10:13,800
key of Aaron because he has the public

215
00:10:09,930 --> 00:10:18,329
key of Aaron and send the one fragment

216
00:10:13,800 --> 00:10:22,469
k3 and sent the data same thing in Crips

217
00:10:18,329 --> 00:10:24,000
and the K once and the k2 and now Aaron

218
00:10:22,470 --> 00:10:25,920
is going to the same thing because he

219
00:10:24,000 --> 00:10:28,579
has the public key of Frank so it

220
00:10:25,920 --> 00:10:32,910
encrypts and center there are ok and

221
00:10:28,579 --> 00:10:35,459
then Bob basically is going to get all

222
00:10:32,910 --> 00:10:40,829
the three fragments and he's going to

223
00:10:35,459 --> 00:10:44,130
get the data so he can decrypt okay so

224
00:10:40,829 --> 00:10:46,199
the other primaries required how many of

225
00:10:44,130 --> 00:10:52,800
you have heard about this recursive

226
00:10:46,199 --> 00:10:56,250
secret sharing none okay so it's a

227
00:10:52,800 --> 00:10:59,519
famous sammich Al garden and in schemey

228
00:10:56,250 --> 00:11:02,550
cell garden what basically happens you

229
00:10:59,519 --> 00:11:06,149
can use one secret and then you can have

230
00:11:02,550 --> 00:11:07,479
n number of shares and then if you get k

231
00:11:06,149 --> 00:11:09,850
out of n share

232
00:11:07,480 --> 00:11:13,720
then you can get the key okay that's the

233
00:11:09,850 --> 00:11:15,450
famous chefs secret or guardian what I

234
00:11:13,720 --> 00:11:18,279
am using here is something called

235
00:11:15,450 --> 00:11:21,610
recursive secret sharing so what is the

236
00:11:18,279 --> 00:11:25,839
difference here you can basically hide K

237
00:11:21,610 --> 00:11:28,810
minus-1 secrets not just one so as you

238
00:11:25,839 --> 00:11:31,360
can see here that in our SS k minus 1

239
00:11:28,810 --> 00:11:34,000
secrets are used to generate a k- degree

240
00:11:31,360 --> 00:11:38,260
polynomial and at each iteration you can

241
00:11:34,000 --> 00:11:40,450
hide one secret okay so what happens in

242
00:11:38,260 --> 00:11:43,330
that case that you have a k- degree

243
00:11:40,450 --> 00:11:46,330
polynomial we generate n number of key

244
00:11:43,330 --> 00:11:49,480
shares from where you need only k out of

245
00:11:46,330 --> 00:11:52,120
n to generate your key and then once you

246
00:11:49,480 --> 00:11:53,860
have the key you can decrypt at least K

247
00:11:52,120 --> 00:11:56,560
shares are needed that basically means

248
00:11:53,860 --> 00:11:59,980
if any malicious node has K minus 1

249
00:11:56,560 --> 00:12:02,910
share it cannot get the key okay so

250
00:11:59,980 --> 00:12:08,320
that's one primary then another one is

251
00:12:02,910 --> 00:12:10,740
called the Reed Solomon code and this we

252
00:12:08,320 --> 00:12:13,570
are using basically to generate

253
00:12:10,740 --> 00:12:15,490
redundant fragments now while you're

254
00:12:13,570 --> 00:12:18,279
generating redundant fragments because

255
00:12:15,490 --> 00:12:20,680
you know I said electronic networks we

256
00:12:18,279 --> 00:12:23,020
don't know which node I go to meet when

257
00:12:20,680 --> 00:12:25,150
they're going to meet nodes the packets

258
00:12:23,020 --> 00:12:28,240
may be dropped so what you're doing

259
00:12:25,150 --> 00:12:30,520
basically is you're doing the fragments

260
00:12:28,240 --> 00:12:32,200
and then again you would like to have k

261
00:12:30,520 --> 00:12:35,079
out of n kind of property for the data

262
00:12:32,200 --> 00:12:38,020
that was for the key so again as you can

263
00:12:35,080 --> 00:12:40,300
see here I have the data fragments K

264
00:12:38,020 --> 00:12:42,010
fragments for the data and we are using

265
00:12:40,300 --> 00:12:43,959
the reed-solomon code to create

266
00:12:42,010 --> 00:12:48,339
additional m fragments using the Kashi

267
00:12:43,959 --> 00:12:51,369
matrix and here as you can see now I

268
00:12:48,339 --> 00:12:53,560
have KD plus M and fragments using

269
00:12:51,370 --> 00:12:57,430
caution matrix KD fragments so total of

270
00:12:53,560 --> 00:12:59,829
KD plus M fragments and any K of small D

271
00:12:57,430 --> 00:13:02,410
so small D is not same as the capital D

272
00:12:59,830 --> 00:13:04,240
right so some number of fragments is

273
00:13:02,410 --> 00:13:06,520
needed which should be less than of

274
00:13:04,240 --> 00:13:09,430
course KD plus M right to generate the

275
00:13:06,520 --> 00:13:11,439
data so what here is an example so you

276
00:13:09,430 --> 00:13:15,250
see that I have four fragments d1 d2 d3

277
00:13:11,440 --> 00:13:17,890
d4 from the data and then CRS creates

278
00:13:15,250 --> 00:13:20,680
two additional fragments d5 and d6 and

279
00:13:17,890 --> 00:13:27,910
out of this only four fragments are

280
00:13:20,680 --> 00:13:30,040
to regenerate my data okay so let me

281
00:13:27,910 --> 00:13:33,969
give you the overview of the scheme okay

282
00:13:30,040 --> 00:13:37,420
so as you can see here I have a source

283
00:13:33,970 --> 00:13:40,869
node again a DD EndNote and it generates

284
00:13:37,420 --> 00:13:45,429
a key K and it has some secrets which it

285
00:13:40,869 --> 00:13:48,220
has generated h1 and h2 ok so as you can

286
00:13:45,429 --> 00:13:53,559
see here I have a data and I'm

287
00:13:48,220 --> 00:13:56,379
encrypting the data with key K now what

288
00:13:53,559 --> 00:13:59,079
you see here is I have generated 8 key

289
00:13:56,379 --> 00:14:04,329
fragments in this example and I'm using

290
00:13:59,079 --> 00:14:06,878
my RSS to generate those fragments so I

291
00:14:04,329 --> 00:14:09,790
have 8 key shares and then I'm using

292
00:14:06,879 --> 00:14:12,309
here the reed-solomon code to generate

293
00:14:09,790 --> 00:14:15,368
the data fragments ok so in this example

294
00:14:12,309 --> 00:14:19,800
I'm just showing again that I have four

295
00:14:15,369 --> 00:14:22,660
data blocks for fragments and then I

296
00:14:19,800 --> 00:14:27,550
encrypt this of course with the public

297
00:14:22,660 --> 00:14:29,889
key of the intermediate nodes those

298
00:14:27,550 --> 00:14:33,459
intermediate nodes whose public key I

299
00:14:29,889 --> 00:14:35,199
have access to ok and then what I'm

300
00:14:33,459 --> 00:14:37,569
going to do is just disseminate those

301
00:14:35,199 --> 00:14:42,099
key fragments you know through multiple

302
00:14:37,569 --> 00:14:45,998
paths here again I have 6 fragments of

303
00:14:42,100 --> 00:14:47,410
the data and then as you see randomly

304
00:14:45,999 --> 00:14:49,120
I'm just relaying all this data and

305
00:14:47,410 --> 00:14:53,559
normally I'm relying this node and all

306
00:14:49,120 --> 00:14:55,240
this will go through DPN nodes in an

307
00:14:53,559 --> 00:14:57,279
opportunistic fashion right reports this

308
00:14:55,240 --> 00:14:59,980
together I meet somebody I'm going to

309
00:14:57,279 --> 00:15:01,540
transfer the information hopefully that

310
00:14:59,980 --> 00:15:03,660
node will meet some other notes and

311
00:15:01,540 --> 00:15:05,469
we'll be able to send the information

312
00:15:03,660 --> 00:15:11,679
through some other nodes to the

313
00:15:05,470 --> 00:15:13,569
destination ok so as you can see that I

314
00:15:11,679 --> 00:15:16,509
have just written the same thing what I

315
00:15:13,569 --> 00:15:19,540
have described that we use our

316
00:15:16,509 --> 00:15:24,249
algorithms that's why I described the

317
00:15:19,540 --> 00:15:28,179
cauchy matrix now how to handle the key

318
00:15:24,249 --> 00:15:30,819
shares ok so if the destination nodes

319
00:15:28,179 --> 00:15:32,490
public is not available then a node as I

320
00:15:30,819 --> 00:15:34,630
said has to select an intermediate node

321
00:15:32,490 --> 00:15:37,750
so if you see here

322
00:15:34,630 --> 00:15:41,050
again Alice and I have a key

323
00:15:37,750 --> 00:15:44,199
I create three different chairs and now

324
00:15:41,050 --> 00:15:46,449
what you see here you see that the

325
00:15:44,199 --> 00:15:49,060
question is how the intermediate node

326
00:15:46,449 --> 00:15:50,500
knows right because it's not going to

327
00:15:49,060 --> 00:15:52,540
decrypt I don't want that note to

328
00:15:50,500 --> 00:15:54,579
decrypt anything so here what we're

329
00:15:52,540 --> 00:15:57,430
doing again I don't know if you know

330
00:15:54,579 --> 00:16:00,130
proxied encryption so the proxy

331
00:15:57,430 --> 00:16:02,500
encryption key has a very good function

332
00:16:00,130 --> 00:16:05,040
what it does it can change the domain of

333
00:16:02,500 --> 00:16:08,319
encryption from A to B without

334
00:16:05,040 --> 00:16:10,930
decrypting right so it's a key which you

335
00:16:08,319 --> 00:16:11,949
apply on that already encrypted it will

336
00:16:10,930 --> 00:16:13,870
just change the domain without

337
00:16:11,949 --> 00:16:16,779
decrypting right so you can keep the

338
00:16:13,870 --> 00:16:18,610
privacy of the data so if you see here

339
00:16:16,779 --> 00:16:21,130
now you see I have encryption and you

340
00:16:18,610 --> 00:16:24,069
see that pre is my proxy encryption key

341
00:16:21,130 --> 00:16:26,769
which says a to e what it means if I

342
00:16:24,069 --> 00:16:29,410
apply this function right or this key it

343
00:16:26,769 --> 00:16:32,199
will check the domain of encryption from

344
00:16:29,410 --> 00:16:36,550
Alice is for Alice and I swore a DIN

345
00:16:32,199 --> 00:16:40,630
okay so if you see here I'm sending the

346
00:16:36,550 --> 00:16:43,029
k3 encrypted with this proxy encryption

347
00:16:40,630 --> 00:16:45,610
function and E's for Allan so this

348
00:16:43,029 --> 00:16:49,300
basically will change the encryption

349
00:16:45,610 --> 00:16:51,880
from ace domain to YZ domain okay at its

350
00:16:49,300 --> 00:16:53,979
domain and same thing here you see that

351
00:16:51,880 --> 00:16:55,600
here I'm using another proxy encryption

352
00:16:53,980 --> 00:16:58,660
key because it is subject to different

353
00:16:55,600 --> 00:17:02,079
notes so this is a 2d I'm sending the

354
00:16:58,660 --> 00:17:04,270
share k2 and again scale one so what I'm

355
00:17:02,079 --> 00:17:06,428
doing is when I'm sending the shares I'm

356
00:17:04,270 --> 00:17:08,589
actually encrypting that as I said

357
00:17:06,429 --> 00:17:13,990
earlier but the way I'm encrypting is

358
00:17:08,589 --> 00:17:17,559
using the proxy encryption okay so now

359
00:17:13,990 --> 00:17:20,380
you can see that the chuck has used the

360
00:17:17,559 --> 00:17:22,510
C to be key and sent to Bob and the

361
00:17:20,380 --> 00:17:26,230
David has sent this and then the Frank

362
00:17:22,510 --> 00:17:29,020
will send this now bob has all the

363
00:17:26,230 --> 00:17:35,169
shares it needed right and it can

364
00:17:29,020 --> 00:17:37,929
reconstruct the key K okay so now let's

365
00:17:35,169 --> 00:17:39,580
see how you can handle the data now

366
00:17:37,929 --> 00:17:42,880
there are two ways you can do these

367
00:17:39,580 --> 00:17:46,600
things one is where my fragments are

368
00:17:42,880 --> 00:17:48,100
static right static means I pre decide

369
00:17:46,600 --> 00:17:51,820
how many fragments

370
00:17:48,100 --> 00:17:54,480
the problem with that is their pros and

371
00:17:51,820 --> 00:17:58,990
cons but the main problem with that is

372
00:17:54,480 --> 00:18:01,000
if the master size is a small if I say

373
00:17:58,990 --> 00:18:03,390
ten fragments I still have to have ten

374
00:18:01,000 --> 00:18:07,840
fragments even if the size is 100 KB

375
00:18:03,390 --> 00:18:11,980
right but on the other side the

376
00:18:07,840 --> 00:18:15,699
advantage is that I don't have to

377
00:18:11,980 --> 00:18:17,380
regenerate this coffee matrix because if

378
00:18:15,700 --> 00:18:19,000
you have the dynamic fragments you have

379
00:18:17,380 --> 00:18:21,880
to do the computation again in the game

380
00:18:19,000 --> 00:18:24,400
okay so there are pros and cons for that

381
00:18:21,880 --> 00:18:26,380
so we have done work with both the

382
00:18:24,400 --> 00:18:28,510
variations as you can see here the

383
00:18:26,380 --> 00:18:30,160
static so where the coffee matrix is

384
00:18:28,510 --> 00:18:32,470
fixed fixed number of keys and data

385
00:18:30,160 --> 00:18:34,240
fragments and number of packets

386
00:18:32,470 --> 00:18:37,360
increases especially for smaller masses

387
00:18:34,240 --> 00:18:39,400
so that's the downside of it okay and in

388
00:18:37,360 --> 00:18:41,199
the dynamic the cauchy matrix needs to

389
00:18:39,400 --> 00:18:43,000
be generated for every message now we

390
00:18:41,200 --> 00:18:44,710
are talking about this mobile devices so

391
00:18:43,000 --> 00:18:50,110
it's very important that you preserve

392
00:18:44,710 --> 00:18:53,860
the energy at these devices okay and the

393
00:18:50,110 --> 00:18:56,020
the packet number then is proportional

394
00:18:53,860 --> 00:18:58,120
to the masses size because we are making

395
00:18:56,020 --> 00:19:01,420
it dynamic right we see that size is 4

396
00:18:58,120 --> 00:19:03,550
MB 100 mb 5 MB and accordingly we are

397
00:19:01,420 --> 00:19:05,590
trying to decide the number of fragments

398
00:19:03,550 --> 00:19:07,930
okay there is another issue with the

399
00:19:05,590 --> 00:19:10,929
fragments is this a delay tolerant

400
00:19:07,930 --> 00:19:13,930
Network right so if you create very less

401
00:19:10,930 --> 00:19:16,780
fragment the reliability will not be

402
00:19:13,930 --> 00:19:19,270
very high because notes even not

403
00:19:16,780 --> 00:19:21,280
malicious let's say a nerd is just

404
00:19:19,270 --> 00:19:23,020
standing and not moving right that

405
00:19:21,280 --> 00:19:24,820
musically means the node may not be able

406
00:19:23,020 --> 00:19:26,350
to connect with other nodes and then

407
00:19:24,820 --> 00:19:28,450
it's just holding the packet for some

408
00:19:26,350 --> 00:19:30,520
time and after some time the node will

409
00:19:28,450 --> 00:19:33,220
drop those right because it's not able

410
00:19:30,520 --> 00:19:36,520
to deliver if you create many fragments

411
00:19:33,220 --> 00:19:37,810
right saying like flooding you know the

412
00:19:36,520 --> 00:19:42,010
problem with flooding is you are

413
00:19:37,810 --> 00:19:44,679
basically doing what wasting the energy

414
00:19:42,010 --> 00:19:46,870
and the bandwidth right so you have to

415
00:19:44,680 --> 00:19:51,850
see you know what is a good balance when

416
00:19:46,870 --> 00:19:53,860
you do this so now how you handle

417
00:19:51,850 --> 00:19:55,840
different security attacks on this

418
00:19:53,860 --> 00:19:57,250
system so the first is like

419
00:19:55,840 --> 00:20:00,010
man-in-the-middle jack

420
00:19:57,250 --> 00:20:01,539
so here public keys are shared only on

421
00:20:00,010 --> 00:20:03,220
direct contacts

422
00:20:01,539 --> 00:20:04,749
right so then this is not possible I'm

423
00:20:03,220 --> 00:20:07,149
only sharing the public key with others

424
00:20:04,749 --> 00:20:09,549
when notes media each other

425
00:20:07,149 --> 00:20:11,228
packet modification and I'm going to

426
00:20:09,549 --> 00:20:13,899
show that we are doing this integrity

427
00:20:11,229 --> 00:20:16,779
check using the merkel hash tree and

428
00:20:13,899 --> 00:20:19,389
then if there's a black hole redundant

429
00:20:16,779 --> 00:20:21,100
packets are already there right so if

430
00:20:19,389 --> 00:20:22,658
some nodes are going to drop you're

431
00:20:21,100 --> 00:20:25,959
already doing k out of n right you don't

432
00:20:22,659 --> 00:20:28,929
need all the fragments and then say my

433
00:20:25,960 --> 00:20:32,679
honest is trying to learn you know from

434
00:20:28,929 --> 00:20:34,989
other nodes the pattern but since we are

435
00:20:32,679 --> 00:20:37,299
doing different fragments why are

436
00:20:34,989 --> 00:20:39,869
different notes it's very hard to learn

437
00:20:37,299 --> 00:20:44,679
much it's not the same packet is going

438
00:20:39,869 --> 00:20:47,408
through the same pot okay so let's see

439
00:20:44,679 --> 00:20:51,279
first you know the integrity check

440
00:20:47,409 --> 00:20:55,090
because as I said the nodes may try to

441
00:20:51,279 --> 00:20:58,809
alter let's say the data packet okay so

442
00:20:55,090 --> 00:21:02,709
now now this is you know again an issue

443
00:20:58,809 --> 00:21:05,559
because if you are doing static right

444
00:21:02,710 --> 00:21:08,499
the merkel hashed is fixed if you're not

445
00:21:05,559 --> 00:21:11,830
doing a static then it's dynamic then

446
00:21:08,499 --> 00:21:14,379
the merkel hash tree is dynamic right so

447
00:21:11,830 --> 00:21:17,379
then you have to do more work so these

448
00:21:14,379 --> 00:21:19,959
are the pros and con of doing the static

449
00:21:17,379 --> 00:21:23,439
versus dynamic so as you can see I'm

450
00:21:19,960 --> 00:21:26,679
showing you here 8 keys right I showed

451
00:21:23,440 --> 00:21:29,379
that K 1 K 2 K 3 K yet the whole idea

452
00:21:26,679 --> 00:21:30,820
behind this is that you should generate

453
00:21:29,379 --> 00:21:33,219
or the node should generate the same

454
00:21:30,820 --> 00:21:34,658
route right and if it is not able to

455
00:21:33,220 --> 00:21:38,080
generate the same route that basically

456
00:21:34,659 --> 00:21:40,720
means there's a problem so when the

457
00:21:38,080 --> 00:21:43,149
nodes are sending remember that I said

458
00:21:40,720 --> 00:21:45,519
secrets so what are those secrets so

459
00:21:43,149 --> 00:21:48,279
there are these parameters which you are

460
00:21:45,519 --> 00:21:50,470
sending to the nodes right otherwise how

461
00:21:48,279 --> 00:21:52,659
the nodes will now write the information

462
00:21:50,470 --> 00:21:55,809
in this case for example what I'm

463
00:21:52,659 --> 00:21:58,599
sending is let's see the example so you

464
00:21:55,809 --> 00:22:01,450
can see so when I'm sending I'm sending

465
00:21:58,599 --> 00:22:04,269
K 1 I'm sending H 2 I'm sending H 3 4

466
00:22:01,450 --> 00:22:07,269
and H 5 8 why because if I have this I

467
00:22:04,269 --> 00:22:12,879
can generate the route ok or another

468
00:22:07,269 --> 00:22:14,140
example is so if you see k 6 h 5 h 1 4 @

469
00:22:12,879 --> 00:22:17,620
7 8 I can do

470
00:22:14,140 --> 00:22:19,210
right so the idea is that how to check

471
00:22:17,620 --> 00:22:21,489
the integrity is the node will generate

472
00:22:19,210 --> 00:22:23,050
this merkel hash tree and try to see if

473
00:22:21,490 --> 00:22:25,540
they are able to generate the same route

474
00:22:23,050 --> 00:22:31,930
if not they know that somebody has

475
00:22:25,540 --> 00:22:34,930
tampered things so that's for the keys

476
00:22:31,930 --> 00:22:37,750
right I only showed k1 k2 though the

477
00:22:34,930 --> 00:22:41,410
keys so the question is how you can

478
00:22:37,750 --> 00:22:44,320
check the integrity for the data right

479
00:22:41,410 --> 00:22:47,170
those are the key integrity now there

480
00:22:44,320 --> 00:22:49,600
are multiple options you can do this but

481
00:22:47,170 --> 00:22:52,330
the problem is what is the most

482
00:22:49,600 --> 00:22:55,360
efficient way of doing data fragments

483
00:22:52,330 --> 00:22:58,720
because the data size is bigger than

484
00:22:55,360 --> 00:23:01,750
those key fragment size right so the

485
00:22:58,720 --> 00:23:03,970
best we could find is using the elliptic

486
00:23:01,750 --> 00:23:06,820
curve cryptography because you know it's

487
00:23:03,970 --> 00:23:09,520
very efficient so each data fragment is

488
00:23:06,820 --> 00:23:11,649
signed by the source node and then send

489
00:23:09,520 --> 00:23:13,120
the signature by appending it with the

490
00:23:11,650 --> 00:23:15,340
data block right so when you are sending

491
00:23:13,120 --> 00:23:19,239
the data you also append this

492
00:23:15,340 --> 00:23:21,040
information source public key is put as

493
00:23:19,240 --> 00:23:22,570
a secret while generating the key shares

494
00:23:21,040 --> 00:23:26,260
remember that that's why we're using

495
00:23:22,570 --> 00:23:29,860
that K minus 1 you know recursive secret

496
00:23:26,260 --> 00:23:32,980
sharing key to append these kind of

497
00:23:29,860 --> 00:23:35,530
information with those secrets okay so

498
00:23:32,980 --> 00:23:38,170
we can send four five six secrets along

499
00:23:35,530 --> 00:23:40,480
with this information so as you can see

500
00:23:38,170 --> 00:23:44,560
here that I'm piggybacking the

501
00:23:40,480 --> 00:23:46,420
information here that the information

502
00:23:44,560 --> 00:23:49,000
about the source public is put as a

503
00:23:46,420 --> 00:23:50,620
secret while generating those share then

504
00:23:49,000 --> 00:23:53,260
destination can verify the data

505
00:23:50,620 --> 00:23:56,560
fragments after they receive right

506
00:23:53,260 --> 00:24:00,370
because they have the public key so

507
00:23:56,560 --> 00:24:02,409
that's the integrity check so that's the

508
00:24:00,370 --> 00:24:03,850
integrity check for the data then the

509
00:24:02,410 --> 00:24:08,500
previous one I showed you the integrity

510
00:24:03,850 --> 00:24:10,480
check about the keys right so now we

511
00:24:08,500 --> 00:24:13,320
have make sure that nobody has tampered

512
00:24:10,480 --> 00:24:17,620
things now we have done extensive

513
00:24:13,320 --> 00:24:21,310
simulations and if you see in this first

514
00:24:17,620 --> 00:24:23,110
set of graphs so here is this is the

515
00:24:21,310 --> 00:24:26,050
theoretical analysis I'm just showing

516
00:24:23,110 --> 00:24:27,909
you as a graph okay so what is the

517
00:24:26,050 --> 00:24:29,950
theoretical probability the

518
00:24:27,910 --> 00:24:31,870
and the paper we have derived this I'm

519
00:24:29,950 --> 00:24:33,970
just showing you just the final kind of

520
00:24:31,870 --> 00:24:36,879
result as a graph so here is a

521
00:24:33,970 --> 00:24:40,390
probability and if you see here that I

522
00:24:36,880 --> 00:24:42,490
am considering total notes 100 and I

523
00:24:40,390 --> 00:24:45,280
have the average public key possession

524
00:24:42,490 --> 00:24:47,140
is 40 percent that basically means 40

525
00:24:45,280 --> 00:24:50,770
percent of the notes have the public

526
00:24:47,140 --> 00:24:54,010
keys of other notes and see 8 10 13 16

527
00:24:50,770 --> 00:24:58,290
is how many nodes have been compromised

528
00:24:54,010 --> 00:25:01,120
out of those hundred and then I have the

529
00:24:58,290 --> 00:25:03,129
intersection of the notes which have the

530
00:25:01,120 --> 00:25:05,679
public keys and they are in the set of

531
00:25:03,130 --> 00:25:08,980
compromised notes and that's my X and

532
00:25:05,680 --> 00:25:11,140
then I have the key so these are the

533
00:25:08,980 --> 00:25:13,450
number of keys these are the fragments

534
00:25:11,140 --> 00:25:14,710
for the keys and this is the data and

535
00:25:13,450 --> 00:25:18,490
these are the fragments for the data

536
00:25:14,710 --> 00:25:20,620
okay so if you see here C's 8 and X is 4

537
00:25:18,490 --> 00:25:24,280
what it means that 4 notes out of the

538
00:25:20,620 --> 00:25:26,679
notes which have been compromised so the

539
00:25:24,280 --> 00:25:29,110
probability if you see this is the

540
00:25:26,680 --> 00:25:31,300
comparison with the MPE multi-party

541
00:25:29,110 --> 00:25:33,280
encryption scheme so this is the

542
00:25:31,300 --> 00:25:35,800
probability which is 0.6 and this is the

543
00:25:33,280 --> 00:25:37,750
max and min and then you can see also

544
00:25:35,800 --> 00:25:39,760
the average in the median and this is

545
00:25:37,750 --> 00:25:42,880
the method which I have just described

546
00:25:39,760 --> 00:25:44,740
for the same set of parameters you can

547
00:25:42,880 --> 00:25:46,570
compare what is the probability of

548
00:25:44,740 --> 00:25:49,060
compromised messages so we have very

549
00:25:46,570 --> 00:25:51,760
less probability and they have like 0.3

550
00:25:49,060 --> 00:25:54,159
we have like point 0 5 on average in the

551
00:25:51,760 --> 00:25:56,920
median and then of course we have done

552
00:25:54,160 --> 00:25:58,570
for this different sets so this is the

553
00:25:56,920 --> 00:26:01,450
graph I have generated out of the

554
00:25:58,570 --> 00:26:04,240
theoretical bounds which we have just to

555
00:26:01,450 --> 00:26:07,390
show you you know in terms of the bounds

556
00:26:04,240 --> 00:26:09,820
you may not see those things ok so now

557
00:26:07,390 --> 00:26:14,320
the performance evaluation so we use the

558
00:26:09,820 --> 00:26:18,070
simulator DTM and we simulate it for 2

559
00:26:14,320 --> 00:26:22,330
22 hours and data sets which we have

560
00:26:18,070 --> 00:26:25,330
used as the haggle Infocom 2006 data

561
00:26:22,330 --> 00:26:28,030
sets which are very popular node number

562
00:26:25,330 --> 00:26:30,720
so we have 98 nodes so these are using

563
00:26:28,030 --> 00:26:36,940
the real data set and then message is

564
00:26:30,720 --> 00:26:40,000
152 jpg JPEG files the so 152 messages

565
00:26:36,940 --> 00:26:41,680
and they are all JPEG images okay and K

566
00:26:40,000 --> 00:26:45,460
key size is 32

567
00:26:41,680 --> 00:26:50,170
like random symmetric-key D is the data

568
00:26:45,460 --> 00:26:52,390
512 1 MB 2 MB 4 MB JPEG images and then

569
00:26:50,170 --> 00:26:54,610
the number of keys and the fragments for

570
00:26:52,390 --> 00:26:57,040
an 8 number of data and the fragments

571
00:26:54,610 --> 00:26:59,169
each there are block size when we are

572
00:26:57,040 --> 00:27:01,659
using to create the blocks of the data

573
00:26:59,170 --> 00:27:03,640
of the fragments is 512 it's fixed and

574
00:27:01,660 --> 00:27:06,190
the public key is the elliptic curve

575
00:27:03,640 --> 00:27:09,760
probably 160 bit key which is very

576
00:27:06,190 --> 00:27:12,720
efficient so now let's see the message

577
00:27:09,760 --> 00:27:15,910
compromise so here is the compromise

578
00:27:12,720 --> 00:27:18,160
percentage so MP is the multi-party

579
00:27:15,910 --> 00:27:19,870
encryption this is the static crag mints

580
00:27:18,160 --> 00:27:22,480
this is the dynamic fragments and then

581
00:27:19,870 --> 00:27:24,699
we have about 30% less compromised

582
00:27:22,480 --> 00:27:27,100
messages and here is the malicious

583
00:27:24,700 --> 00:27:29,830
number of notes so we have 5 percent 10

584
00:27:27,100 --> 00:27:32,770
percent 15 20 25 percent out of that 98

585
00:27:29,830 --> 00:27:35,860
notes and of course we assume here for

586
00:27:32,770 --> 00:27:38,350
this one the file size is 2 MB and then

587
00:27:35,860 --> 00:27:41,590
50 percent of the notes have the public

588
00:27:38,350 --> 00:27:45,699
keys okay of other notes so we do like

589
00:27:41,590 --> 00:27:47,370
25% less compromised messages bandwidth

590
00:27:45,700 --> 00:27:49,900
consumption because you know you are

591
00:27:47,370 --> 00:27:51,909
sending these fragments and then you

592
00:27:49,900 --> 00:27:53,650
have to make sure that you don't use you

593
00:27:51,910 --> 00:27:55,450
know and consume a lot of bandwidth and

594
00:27:53,650 --> 00:28:00,430
bandwidth is also related to energy

595
00:27:55,450 --> 00:28:03,280
right so here is the 512 KB 1 MB 2 MB

596
00:28:00,430 --> 00:28:06,280
and 4 MB and you see that this is M the

597
00:28:03,280 --> 00:28:08,440
M PE and the reason of course MP has

598
00:28:06,280 --> 00:28:11,230
more bandwidth because they are sending

599
00:28:08,440 --> 00:28:13,120
all the time the complete data they do

600
00:28:11,230 --> 00:28:17,050
fragment the keys but they don't

601
00:28:13,120 --> 00:28:18,699
fragment the data so in our case of

602
00:28:17,050 --> 00:28:20,770
course you see the static and dynamic

603
00:28:18,700 --> 00:28:23,590
there's some difference in terms of

604
00:28:20,770 --> 00:28:26,050
using the bandwidth obviously because

605
00:28:23,590 --> 00:28:28,209
you know the static you can have less

606
00:28:26,050 --> 00:28:30,490
fragments and then we could decide on

607
00:28:28,210 --> 00:28:31,810
the base the static you have fixed

608
00:28:30,490 --> 00:28:36,490
number of fragments in dynamic you can

609
00:28:31,810 --> 00:28:39,129
decide based on the size ok and that's

610
00:28:36,490 --> 00:28:41,260
why you see the static is taking more

611
00:28:39,130 --> 00:28:43,900
because it's fixed it doesn't depend on

612
00:28:41,260 --> 00:28:45,970
this test but dynamic you see that

613
00:28:43,900 --> 00:28:50,620
initial it's ketchups up you know when

614
00:28:45,970 --> 00:28:53,500
it's file size is more ok so the delay

615
00:28:50,620 --> 00:28:55,300
distributions so as you can see here is

616
00:28:53,500 --> 00:28:55,549
a tail distribution you see that at the

617
00:28:55,300 --> 00:28:57,529
end

618
00:28:55,549 --> 00:29:02,480
so this is based on the simulation hours

619
00:28:57,529 --> 00:29:06,710
and here is the MP G average so this is

620
00:29:02,480 --> 00:29:10,610
the static 5:12 this is the dynamic 512

621
00:29:06,710 --> 00:29:13,580
1 MB static 1 MB dynamic 2 MB static 2

622
00:29:10,610 --> 00:29:16,639
MB dynamic 4 MB static and 5 mg dynamic

623
00:29:13,580 --> 00:29:21,710
and this is the number of files received

624
00:29:16,639 --> 00:29:25,158
and at different time ok so this is the

625
00:29:21,710 --> 00:29:27,230
hours delay and this is based on that

626
00:29:25,159 --> 00:29:29,899
simulation hours so if you see here of

627
00:29:27,230 --> 00:29:31,580
course in the beginning you see that not

628
00:29:29,899 --> 00:29:34,789
many files of course you can see that

629
00:29:31,580 --> 00:29:36,408
difference is not much right so even we

630
00:29:34,789 --> 00:29:38,419
are sending the fragments and they are

631
00:29:36,409 --> 00:29:41,749
sending the delay so if you compare the

632
00:29:38,419 --> 00:29:45,259
average it's a very close right and you

633
00:29:41,749 --> 00:29:46,909
see that most of the files received at

634
00:29:45,259 --> 00:29:49,549
this time and then of course there are

635
00:29:46,909 --> 00:29:52,999
some which are stuck somewhere right so

636
00:29:49,549 --> 00:29:54,889
you see that it's a tail distribution so

637
00:29:52,999 --> 00:29:58,399
delay to the C message for varying file

638
00:29:54,889 --> 00:30:00,469
size and the file size variation you can

639
00:29:58,399 --> 00:30:03,379
see on the top same file size of use of

640
00:30:00,470 --> 00:30:06,350
course here the average possession of

641
00:30:03,379 --> 00:30:08,629
the public keys are 25% of the notes ok

642
00:30:06,350 --> 00:30:12,199
so this may improve if you increase for

643
00:30:08,629 --> 00:30:14,269
example to 50% ok but we want you to see

644
00:30:12,200 --> 00:30:17,720
you know like only 1/4 of the notes

645
00:30:14,269 --> 00:30:19,279
basically have the public keys and that

646
00:30:17,720 --> 00:30:23,960
basically means other nodes are sending

647
00:30:19,279 --> 00:30:26,859
through some intermediate nodes energy

648
00:30:23,960 --> 00:30:29,509
so here is the energy in terms of the

649
00:30:26,859 --> 00:30:32,629
RSS write recursive secret sharing

650
00:30:29,509 --> 00:30:35,119
because you know these security guards

651
00:30:32,629 --> 00:30:37,879
takes energy right to execute their

652
00:30:35,119 --> 00:30:40,428
algorithm c RS and this is the crypto

653
00:30:37,879 --> 00:30:42,199
encryption and thus the integrity so

654
00:30:40,429 --> 00:30:44,119
again if you see that this is the

655
00:30:42,200 --> 00:30:46,220
multi-party encryption averages and of

656
00:30:44,119 --> 00:30:47,689
course you see that they don't have this

657
00:30:46,220 --> 00:30:50,480
green box because they don't have

658
00:30:47,690 --> 00:30:52,009
integrity check off anything ok so they

659
00:30:50,480 --> 00:30:53,570
don't do integrated check of the keys

660
00:30:52,009 --> 00:30:58,970
they don't do the integrity check of the

661
00:30:53,570 --> 00:31:02,119
data so if you see here the RSS right

662
00:30:58,970 --> 00:31:04,970
and then this is my C RS and this is my

663
00:31:02,119 --> 00:31:07,699
capture time and this is my integrity so

664
00:31:04,970 --> 00:31:08,890
if you see on the you know all the size

665
00:31:07,700 --> 00:31:11,230
of course

666
00:31:08,890 --> 00:31:14,290
is some increase in the energy but it

667
00:31:11,230 --> 00:31:16,570
kind of here you see that more time in

668
00:31:14,290 --> 00:31:19,620
the integrity check is basically that

669
00:31:16,570 --> 00:31:23,470
means the morkul hash tree or the other

670
00:31:19,620 --> 00:31:25,929
the crypto time is again you know kind

671
00:31:23,470 --> 00:31:28,930
of increases if you increase the file

672
00:31:25,930 --> 00:31:30,670
size now important thing is that you see

673
00:31:28,930 --> 00:31:36,310
that this is the dynamic and this is

674
00:31:30,670 --> 00:31:38,980
static okay and this is static I think

675
00:31:36,310 --> 00:31:41,740
that the type of here this should be D

676
00:31:38,980 --> 00:31:45,520
okay so this is the static and this is

677
00:31:41,740 --> 00:31:47,020
the dynamic so if you see that CRS you

678
00:31:45,520 --> 00:31:50,379
remember that kashi it has to calculate

679
00:31:47,020 --> 00:31:52,389
the that matrix square matrix again and

680
00:31:50,380 --> 00:31:55,240
that's where it has to spend some more

681
00:31:52,390 --> 00:31:59,250
time doing that if it is a static that

682
00:31:55,240 --> 00:32:03,520
time will be very less the calculations

683
00:31:59,250 --> 00:32:08,520
and of course this is the logarithmic

684
00:32:03,520 --> 00:32:11,560
scale just to show delivery ratio and

685
00:32:08,520 --> 00:32:14,440
again so you have different file sizes

686
00:32:11,560 --> 00:32:17,590
and what I have done here is I have done

687
00:32:14,440 --> 00:32:19,960
this the delivery of the keys and the

688
00:32:17,590 --> 00:32:23,230
data and I have just taken the ratio of

689
00:32:19,960 --> 00:32:26,230
n by K as one the data and the keys

690
00:32:23,230 --> 00:32:29,200
ratio as two ratios three and it shows

691
00:32:26,230 --> 00:32:32,110
the keep delivery and it shows the data

692
00:32:29,200 --> 00:32:34,030
delivery right so if you see that the

693
00:32:32,110 --> 00:32:35,860
delivery ratio is much higher for the

694
00:32:34,030 --> 00:32:38,050
keys because you saw that there are more

695
00:32:35,860 --> 00:32:40,000
fragments there the data has less

696
00:32:38,050 --> 00:32:42,190
fragments because data size is bigger

697
00:32:40,000 --> 00:32:45,610
than the key size is because you want to

698
00:32:42,190 --> 00:32:48,520
conserve bandwidth so 512 KB if you see

699
00:32:45,610 --> 00:32:51,879
here the for n by K is 1 when the ratio

700
00:32:48,520 --> 00:32:54,250
is 1 this is the delivery ratio if you

701
00:32:51,880 --> 00:32:57,550
have more fragments delivery ratio will

702
00:32:54,250 --> 00:33:00,190
increase accordingly and more or less

703
00:32:57,550 --> 00:33:03,960
you know similar behavior except that

704
00:33:00,190 --> 00:33:03,960
when the file size is very small

705
00:33:05,010 --> 00:33:11,530
integrally check so here you can see

706
00:33:08,140 --> 00:33:14,200
that I have the correct file received

707
00:33:11,530 --> 00:33:16,600
and you see that with integrity check

708
00:33:14,200 --> 00:33:19,780
for a static with integrity check for

709
00:33:16,600 --> 00:33:22,689
the dynamic without integrity and so if

710
00:33:19,780 --> 00:33:22,850
you see the static and dynamic so this

711
00:33:22,690 --> 00:33:25,220
is

712
00:33:22,850 --> 00:33:27,290
the green and this is the blue and then

713
00:33:25,220 --> 00:33:29,030
this is without integrity check for

714
00:33:27,290 --> 00:33:32,480
static and this is without integrity

715
00:33:29,030 --> 00:33:34,220
check for dynamic so of course you see

716
00:33:32,480 --> 00:33:37,520
that the correct file received is

717
00:33:34,220 --> 00:33:41,300
highest with static because of course

718
00:33:37,520 --> 00:33:43,430
the number of shares are fixed and this

719
00:33:41,300 --> 00:33:44,899
depends on of course how many notes are

720
00:33:43,430 --> 00:33:46,130
corrupted so more and more nodes are

721
00:33:44,900 --> 00:33:50,990
corrupted you could get less and less

722
00:33:46,130 --> 00:33:53,270
number of fights okay and of course if

723
00:33:50,990 --> 00:33:55,910
you don't do the integrity check you see

724
00:33:53,270 --> 00:33:59,960
that you know you get less number of

725
00:33:55,910 --> 00:34:02,390
correct files then what we did is after

726
00:33:59,960 --> 00:34:05,330
that simulation since we're using the

727
00:34:02,390 --> 00:34:07,880
simulation the real data set we wanted

728
00:34:05,330 --> 00:34:10,850
to see some more stuff so we made some

729
00:34:07,880 --> 00:34:13,580
synthetic data set so that we have large

730
00:34:10,850 --> 00:34:15,500
number of nodes so in this one if you

731
00:34:13,580 --> 00:34:19,909
see the number of nodes 50 75 hundred

732
00:34:15,500 --> 00:34:23,449
125 and the total energy used in joules

733
00:34:19,909 --> 00:34:27,259
you can see an average energy per node

734
00:34:23,449 --> 00:34:29,270
okay so if you see here if you know if

735
00:34:27,260 --> 00:34:30,830
you see per node like when the nodes are

736
00:34:29,270 --> 00:34:33,739
less they are spending more energy

737
00:34:30,830 --> 00:34:36,170
because they are doing for example more

738
00:34:33,739 --> 00:34:37,759
data fragments forwarding also more key

739
00:34:36,170 --> 00:34:39,980
forwarding right if there are more

740
00:34:37,760 --> 00:34:43,820
number of nodes that may be distributed

741
00:34:39,980 --> 00:34:45,889
also if you see again like hop count let

742
00:34:43,820 --> 00:34:48,080
me just show here so hop count when

743
00:34:45,889 --> 00:34:50,420
increases right what it means that more

744
00:34:48,080 --> 00:34:54,049
and more nodes are getting in touch with

745
00:34:50,420 --> 00:34:56,630
each other so the receive messages for

746
00:34:54,050 --> 00:34:58,640
seven hours increases right so you see

747
00:34:56,630 --> 00:35:01,730
that in the first zero Tower is not but

748
00:34:58,640 --> 00:35:03,529
then you have 80 forty-seven but when

749
00:35:01,730 --> 00:35:06,830
the hop counts are less you see that

750
00:35:03,530 --> 00:35:09,650
they are more distributed right and with

751
00:35:06,830 --> 00:35:11,630
125 is the same when hop count basically

752
00:35:09,650 --> 00:35:14,000
again it shows that how many contacts

753
00:35:11,630 --> 00:35:16,040
people are making with others you see

754
00:35:14,000 --> 00:35:17,840
that one hundred and ten messages or 99

755
00:35:16,040 --> 00:35:21,500
messages when hop count increases it

756
00:35:17,840 --> 00:35:23,960
doubles right so here is the delay

757
00:35:21,500 --> 00:35:26,180
distribution and CN is the compromised

758
00:35:23,960 --> 00:35:28,930
notes percentage five fifteen and twenty

759
00:35:26,180 --> 00:35:35,040
five and then you have the average

760
00:35:28,930 --> 00:35:38,910
collected public keys 23 33 50 and

761
00:35:35,040 --> 00:35:40,590
you know and for 25 30 350 and then you

762
00:35:38,910 --> 00:35:42,509
see here the compromise when there are

763
00:35:40,590 --> 00:35:45,900
50 nodes compromise when there are 100

764
00:35:42,510 --> 00:35:48,180
percent nodes the hundred nodes so this

765
00:35:45,900 --> 00:35:50,820
shows that you know what is the delay

766
00:35:48,180 --> 00:35:52,500
distribution so if you see here that

767
00:35:50,820 --> 00:35:55,800
five point eight five point five two

768
00:35:52,500 --> 00:35:57,600
point three and when you have the CN

769
00:35:55,800 --> 00:36:03,450
which is the compromise nodes increases

770
00:35:57,600 --> 00:36:05,190
the delay increases right okay so in

771
00:36:03,450 --> 00:36:07,020
conclusion but I'll talk about

772
00:36:05,190 --> 00:36:09,510
implementation after this so in

773
00:36:07,020 --> 00:36:13,050
conclusion the idea behind this work was

774
00:36:09,510 --> 00:36:15,840
that how efficiently you can send the

775
00:36:13,050 --> 00:36:18,060
data to other nodes using delay draw

776
00:36:15,840 --> 00:36:21,240
length networks we want to send the data

777
00:36:18,060 --> 00:36:22,980
in a secure fashion and at the same time

778
00:36:21,240 --> 00:36:25,470
we have to make sure that since it's a

779
00:36:22,980 --> 00:36:27,360
delay tolerant networks the energy and

780
00:36:25,470 --> 00:36:29,730
bandwidth there are two more important

781
00:36:27,360 --> 00:36:33,000
things we have to make sure that they

782
00:36:29,730 --> 00:36:36,330
are not or used okay we use the

783
00:36:33,000 --> 00:36:39,240
recursive secret sharing and kashi read

784
00:36:36,330 --> 00:36:41,009
Solomon and also proxy encryption and

785
00:36:39,240 --> 00:36:43,410
elliptic curves so for different

786
00:36:41,010 --> 00:36:45,660
algorithms combination and then we

787
00:36:43,410 --> 00:36:49,049
showed that it's a significant

788
00:36:45,660 --> 00:36:51,210
improvement over the MPE scheme and of

789
00:36:49,050 --> 00:36:56,160
course if there are more compromised

790
00:36:51,210 --> 00:36:58,890
nodes it can do better okay so after

791
00:36:56,160 --> 00:37:00,899
this you know we implemented all those

792
00:36:58,890 --> 00:37:03,140
algorithms in a module how much time I

793
00:37:00,900 --> 00:37:03,140
have

794
00:37:03,620 --> 00:37:09,870
okay should be able to do that okay so

795
00:37:07,230 --> 00:37:12,120
we implemented using the smartphones on

796
00:37:09,870 --> 00:37:16,230
Android platform using Google nearby

797
00:37:12,120 --> 00:37:18,359
connections API which basically make use

798
00:37:16,230 --> 00:37:21,360
of the best of Wi-Fi or Bluetooth

799
00:37:18,360 --> 00:37:23,580
connection automatically and each divide

800
00:37:21,360 --> 00:37:26,790
acts as a node in a delicate online

801
00:37:23,580 --> 00:37:29,730
network and at a source we do the key

802
00:37:26,790 --> 00:37:31,830
and data fragmentation and then target

803
00:37:29,730 --> 00:37:34,860
node will try to receive this original

804
00:37:31,830 --> 00:37:37,350
message so here the modules which we

805
00:37:34,860 --> 00:37:39,150
have implemented if you see here that we

806
00:37:37,350 --> 00:37:41,100
have a key generator we generate the

807
00:37:39,150 --> 00:37:42,030
keys at each node using the elliptic

808
00:37:41,100 --> 00:37:44,100
curve cryptography

809
00:37:42,030 --> 00:37:46,410
we have a key handler we have data

810
00:37:44,100 --> 00:37:47,569
handler we have key integrity checker we

811
00:37:46,410 --> 00:37:51,140
have data integrity check

812
00:37:47,569 --> 00:37:53,569
okay and then of course on the same side

813
00:37:51,140 --> 00:37:56,170
then you transfer the public keys when

814
00:37:53,569 --> 00:37:58,339
they meet each other share subkeys

815
00:37:56,170 --> 00:37:59,719
messages when they are sent and share

816
00:37:58,339 --> 00:38:01,699
the data fragments when they meet with

817
00:37:59,719 --> 00:38:04,749
each other okay so these are the modules

818
00:38:01,699 --> 00:38:07,539
which we have implemented in this form

819
00:38:04,749 --> 00:38:12,198
I'm sorry

820
00:38:07,539 --> 00:38:14,150
and of course this just tells you the

821
00:38:12,199 --> 00:38:16,999
flowchart of how you do the

822
00:38:14,150 --> 00:38:19,999
communication so start Google nearby

823
00:38:16,999 --> 00:38:23,629
connect to nearby device and exchange

824
00:38:19,999 --> 00:38:25,968
the devices so I have done this work you

825
00:38:23,630 --> 00:38:28,789
know this kind of system I'd built for

826
00:38:25,969 --> 00:38:31,309
air force earlier also not for this

827
00:38:28,789 --> 00:38:34,369
particular work so we have you know all

828
00:38:31,309 --> 00:38:35,959
these things experimented with many

829
00:38:34,369 --> 00:38:37,789
different technology for communication

830
00:38:35,959 --> 00:38:41,690
using the radio networks for the

831
00:38:37,789 --> 00:38:45,469
military bluetooth Google nearby and so

832
00:38:41,690 --> 00:38:47,900
we are just using our previous work for

833
00:38:45,469 --> 00:38:51,069
making these connections and we have

834
00:38:47,900 --> 00:38:54,979
tested actually in a battle well it's a

835
00:38:51,069 --> 00:38:58,400
not the real battlefield but say testing

836
00:38:54,979 --> 00:39:00,769
site stockbridge in new york it's on the

837
00:38:58,400 --> 00:39:03,289
top of the hill so they no have no you

838
00:39:00,769 --> 00:39:04,640
know problem in the communication and

839
00:39:03,289 --> 00:39:07,309
things like that you know there's no

840
00:39:04,640 --> 00:39:10,459
interference I don't even get my AT&T

841
00:39:07,309 --> 00:39:13,279
connection there for example so we took

842
00:39:10,459 --> 00:39:15,828
all these devices there with soldiers on

843
00:39:13,279 --> 00:39:18,170
the go card and they're driving and you

844
00:39:15,829 --> 00:39:20,769
know things like that and then they have

845
00:39:18,170 --> 00:39:23,989
this radio we try to forward things and

846
00:39:20,769 --> 00:39:26,538
so we have done that work so here you

847
00:39:23,989 --> 00:39:29,599
can see my screen shots so I have a

848
00:39:26,539 --> 00:39:31,519
device I have a camera take the image is

849
00:39:29,599 --> 00:39:34,309
it an own message so you are the source

850
00:39:31,519 --> 00:39:36,229
or you're an intermediate tree and then

851
00:39:34,309 --> 00:39:38,209
you have nearby operation enable

852
00:39:36,229 --> 00:39:40,910
disabled for connection so that's the

853
00:39:38,209 --> 00:39:42,259
home screen now you can choose either

854
00:39:40,910 --> 00:39:44,569
you would like to do the static

855
00:39:42,259 --> 00:39:46,789
fragmentation or you would like to see

856
00:39:44,569 --> 00:39:48,499
the dynamic actually I forgot to tell

857
00:39:46,789 --> 00:39:50,749
you that we also have priding base you

858
00:39:48,499 --> 00:39:53,419
know because in case of mission you know

859
00:39:50,749 --> 00:39:56,419
sometimes we do the priority based so

860
00:39:53,420 --> 00:39:57,829
you can see that and then once you click

861
00:39:56,420 --> 00:40:01,430
this so this is the image of my lab

862
00:39:57,829 --> 00:40:03,349
actually this one so this

863
00:40:01,430 --> 00:40:08,480
and sincerely just taken a water feature

864
00:40:03,349 --> 00:40:12,290
to see that so this is the create key

865
00:40:08,480 --> 00:40:14,119
plus data share and then the next one

866
00:40:12,290 --> 00:40:16,040
it creates the fragments it assigns some

867
00:40:14,119 --> 00:40:19,160
ID you know so this is a type data

868
00:40:16,040 --> 00:40:21,529
message ID and then share ID and how in

869
00:40:19,160 --> 00:40:23,270
fragments whether sent not sent and

870
00:40:21,530 --> 00:40:27,380
things like that okay so you can see

871
00:40:23,270 --> 00:40:29,599
those things and then here you know when

872
00:40:27,380 --> 00:40:31,400
it comes to proxy the intermediate nodes

873
00:40:29,599 --> 00:40:33,349
have choose a node using its public key

874
00:40:31,400 --> 00:40:35,660
so that proxy key will be generated at

875
00:40:33,349 --> 00:40:38,500
the source so everything we are doing as

876
00:40:35,660 --> 00:40:41,450
I said at the node level and then

877
00:40:38,500 --> 00:40:43,550
destination message so you can see that

878
00:40:41,450 --> 00:40:46,189
again in the lab he has done the

879
00:40:43,550 --> 00:40:50,480
fragmentation and generated different

880
00:40:46,190 --> 00:40:52,609
file names this is just it's not a

881
00:40:50,480 --> 00:40:56,059
really demo much truant you know I don't

882
00:40:52,609 --> 00:40:57,589
have in the lab we basically give a demo

883
00:40:56,059 --> 00:41:00,559
with five phones and that's what he has

884
00:40:57,589 --> 00:41:02,180
done that is a source in this demo and

885
00:41:00,559 --> 00:41:05,030
these are the intermediate nodes and

886
00:41:02,180 --> 00:41:07,129
here is the compromised node and you can

887
00:41:05,030 --> 00:41:09,319
see that D already has for example let's

888
00:41:07,130 --> 00:41:12,170
assume k 1 k 2 3 already received

889
00:41:09,319 --> 00:41:14,960
earlier and D 1 D 2 D 3 and if I to

890
00:41:12,170 --> 00:41:18,799
meets first then it uses the public key

891
00:41:14,960 --> 00:41:20,960
of this and this and then it has the PK

892
00:41:18,799 --> 00:41:23,480
of the the primary public key and then

893
00:41:20,960 --> 00:41:25,819
you send the key to C N and if it is

894
00:41:23,480 --> 00:41:28,010
compromised then it has to wait for the

895
00:41:25,819 --> 00:41:32,329
information from here to complete the

896
00:41:28,010 --> 00:41:34,790
fragments okay it's more fun to see when

897
00:41:32,329 --> 00:41:42,190
you use the devices then this flowchart

898
00:41:34,790 --> 00:41:42,190
you know it just shows a one case okay

899
00:41:44,049 --> 00:41:49,059
so forget this okay questions

900
00:41:50,579 --> 00:41:57,460
yeah I have one the integrity I'm

901
00:41:53,650 --> 00:41:59,650
thinking a very inexpensive way to kind

902
00:41:57,460 --> 00:42:03,099
of doing in end-to-end integrity check

903
00:41:59,650 --> 00:42:05,559
would be to simply do a checksum on the

904
00:42:03,099 --> 00:42:10,450
reconstructed data file right but the

905
00:42:05,559 --> 00:42:13,059
problem is I don't want to you know

906
00:42:10,450 --> 00:42:15,848
waste my bandwidth to wait for the end

907
00:42:13,059 --> 00:42:20,229
if the node the intermediate node

908
00:42:15,849 --> 00:42:24,549
identified drops so that was the main

909
00:42:20,229 --> 00:42:27,430
thing I guess my question on this I mean

910
00:42:24,549 --> 00:42:29,349
yes there's a cost there but it looked

911
00:42:27,430 --> 00:42:31,538
like your integrity checks in terms of

912
00:42:29,349 --> 00:42:37,809
the the power required were pretty

913
00:42:31,539 --> 00:42:40,269
expensive looking at the the we have

914
00:42:37,809 --> 00:42:41,589
that energy right yeah and and it seemed

915
00:42:40,269 --> 00:42:42,879
to be pretty expensive I mean it's up

916
00:42:41,589 --> 00:42:45,910
there at the top of that log scale so

917
00:42:42,880 --> 00:42:50,019
once you expand that out pretty big I'm

918
00:42:45,910 --> 00:42:55,118
wondering at what level of malicious

919
00:42:50,019 --> 00:42:58,749
nodes does that you know the is is it

920
00:42:55,119 --> 00:43:01,779
better to go ahead and send the

921
00:42:58,749 --> 00:43:04,209
potentially bad packets and make a cheap

922
00:43:01,779 --> 00:43:05,739
check at the end rather than make the

923
00:43:04,210 --> 00:43:07,299
expensive check where I mean there's a

924
00:43:05,739 --> 00:43:09,880
trade-off there's nothing credit off of

925
00:43:07,299 --> 00:43:13,089
any idea on where that would be no so

926
00:43:09,880 --> 00:43:15,609
what basically the thing is that we want

927
00:43:13,089 --> 00:43:17,558
to stop I know what you're saying at the

928
00:43:15,609 --> 00:43:20,558
stop if the node detects that integral

929
00:43:17,559 --> 00:43:22,329
check because if you let it go then it

930
00:43:20,559 --> 00:43:25,089
may use you know multiple nodes

931
00:43:22,329 --> 00:43:27,160
bandwidth because you don't know like

932
00:43:25,089 --> 00:43:29,440
how many hops is going to take before it

933
00:43:27,160 --> 00:43:32,259
reaches and it's an unfortunate stick

934
00:43:29,440 --> 00:43:34,450
you know so we don't want to create so

935
00:43:32,259 --> 00:43:35,920
many copies you know fee you know we

936
00:43:34,450 --> 00:43:38,200
already have fragments we already have

937
00:43:35,920 --> 00:43:40,960
copies you know and then now you know

938
00:43:38,200 --> 00:43:43,598
that one fragment is bad and you got to

939
00:43:40,960 --> 00:43:48,999
let it go so that's right so you know

940
00:43:43,599 --> 00:43:51,549
it's a it's a you know it's a question

941
00:43:48,999 --> 00:43:54,308
that whether you let it go then how much

942
00:43:51,549 --> 00:43:56,559
you know bandwidth it consumes extra and

943
00:43:54,309 --> 00:43:58,299
how many nodes have been how many

944
00:43:56,559 --> 00:44:02,319
message have been compromised and you

945
00:43:58,299 --> 00:44:05,259
know so we have not done that comparison

946
00:44:02,319 --> 00:44:07,269
the idea was just stop it at every node

947
00:44:05,259 --> 00:44:09,640
because I didn't know it can do that

948
00:44:07,269 --> 00:44:11,140
well the intermediate now it it seems

949
00:44:09,640 --> 00:44:13,450
like something that could probably be

950
00:44:11,140 --> 00:44:15,250
estimated analytically what's the

951
00:44:13,450 --> 00:44:20,279
probability that you know what's your

952
00:44:15,250 --> 00:44:23,829
expected cost of forwarding a bad packet

953
00:44:20,279 --> 00:44:26,380
versus your ex you're known cost of

954
00:44:23,829 --> 00:44:27,880
doing the integrity checks and your cost

955
00:44:26,380 --> 00:44:29,319
of doing the integrity checks for good

956
00:44:27,880 --> 00:44:32,140
packets and I'm wondering I mean it may

957
00:44:29,319 --> 00:44:33,640
be that the answer is a very small

958
00:44:32,140 --> 00:44:36,069
percentage of malicious nodes you're

959
00:44:33,640 --> 00:44:37,930
better off doing it this way but right

960
00:44:36,069 --> 00:44:40,538
it's possible an interesting follow-on

961
00:44:37,930 --> 00:44:42,220
right because what happens like you

962
00:44:40,539 --> 00:44:44,380
remember that the fragments we are

963
00:44:42,220 --> 00:44:46,618
choosing I can choose more fragments

964
00:44:44,380 --> 00:44:50,109
yeah unless fragment so it has an impact

965
00:44:46,619 --> 00:44:53,759
yeah oh yeah also many mind so many

966
00:44:50,109 --> 00:44:58,019
variables right so play into exactly

967
00:44:53,759 --> 00:44:58,019
Thanks any other question

968
00:45:02,270 --> 00:45:09,500
so the follow-on work we are doing on

969
00:45:04,010 --> 00:45:15,520
this not that part of it but so we are

970
00:45:09,500 --> 00:45:17,390
looking into for example the images

971
00:45:15,520 --> 00:45:19,250
could be similar

972
00:45:17,390 --> 00:45:22,790
you know because coming from multiple

973
00:45:19,250 --> 00:45:28,640
people and it's like taking the same

974
00:45:22,790 --> 00:45:30,290
image so have to reduce that so I don't

975
00:45:28,640 --> 00:45:33,470
want to do image processing and those

976
00:45:30,290 --> 00:45:35,570
stuff this expensing on the phone so we

977
00:45:33,470 --> 00:45:40,009
could do that in a very different way

978
00:45:35,570 --> 00:45:42,440
one other work within that is you know

979
00:45:40,010 --> 00:45:46,550
when people request we are sending right

980
00:45:42,440 --> 00:45:48,200
now the same image but you're trying to

981
00:45:46,550 --> 00:45:50,119
use machine learning and trying to see

982
00:45:48,200 --> 00:45:52,549
what is the mission of those nodes and

983
00:45:50,119 --> 00:45:54,410
which fragments they may be interested

984
00:45:52,550 --> 00:45:56,540
in right now my fragment is like

985
00:45:54,410 --> 00:45:59,149
chopping a chicken you know I don't see

986
00:45:56,540 --> 00:46:01,190
any semantics and I'm just saying you

987
00:45:59,150 --> 00:46:03,650
know and I'm saying for sex it's not

988
00:46:01,190 --> 00:46:06,859
based on the objects there right it's

989
00:46:03,650 --> 00:46:09,619
just cutting it off so now I'm looking

990
00:46:06,859 --> 00:46:12,310
into more semantical semantical or

991
00:46:09,619 --> 00:46:16,400
semantics before doing the fragments and

992
00:46:12,310 --> 00:46:20,259
then all my keys and everything will be

993
00:46:16,400 --> 00:46:24,109
done based on the semantics so that

994
00:46:20,260 --> 00:46:26,810
nodes can check you know if the keys and

995
00:46:24,109 --> 00:46:28,310
don't follow it if the mission it's

996
00:46:26,810 --> 00:46:35,029
different you know things like that

997
00:46:28,310 --> 00:46:36,589
yes that's an interesting for the image

998
00:46:35,030 --> 00:46:38,690
application I know there are ways of

999
00:46:36,589 --> 00:46:40,460
partitioning images such that getting a

1000
00:46:38,690 --> 00:46:43,400
small number of partitions gives you a

1001
00:46:40,460 --> 00:46:45,369
low resolution image getting a larger

1002
00:46:43,400 --> 00:46:47,270
number gives you higher resolution that

1003
00:46:45,369 --> 00:46:54,680
you've got be a really natural

1004
00:46:47,270 --> 00:46:57,849
application for that right work Oh like

1005
00:46:54,680 --> 00:46:57,848
to thank dr. Madre

1006
00:47:08,780 --> 00:47:10,840
you

