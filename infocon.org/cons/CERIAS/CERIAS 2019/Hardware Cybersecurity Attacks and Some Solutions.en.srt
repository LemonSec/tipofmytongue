1
00:00:00,130 --> 00:00:05,950
hey I'm delighted to welcome professor

2
00:00:03,100 --> 00:00:09,880
Krishna curry from University of North

3
00:00:05,950 --> 00:00:16,230
Texas Department of Computer Science and

4
00:00:09,880 --> 00:00:16,230
Engineering Norah Jones graduated from

5
00:00:16,440 --> 00:00:26,039
University of North Texas and Don Henley

6
00:00:18,820 --> 00:00:31,390
also of Hegel's Krishna has been

7
00:00:26,039 --> 00:00:33,069
director of the NSF Indiana industry

8
00:00:31,390 --> 00:00:35,379
University Research Center

9
00:00:33,069 --> 00:00:38,159
he was department head in computer

10
00:00:35,379 --> 00:00:42,928
science and engineering at University of

11
00:00:38,159 --> 00:00:48,819
Texas and has done amazing work in

12
00:00:42,929 --> 00:00:51,839
Hardware machine learning security so I

13
00:00:48,819 --> 00:00:56,260
would welcome you to go to his web page

14
00:00:51,839 --> 00:00:57,489
and read all about it and also I will

15
00:00:56,260 --> 00:01:04,890
let him get it started on his

16
00:00:57,489 --> 00:01:08,679
presentation I think I thank you Barrett

17
00:01:04,890 --> 00:01:10,689
I don't know how many of you hardware

18
00:01:08,680 --> 00:01:13,180
background in terms of actual processor

19
00:01:10,689 --> 00:01:15,369
or somehow pipelines work and how cache

20
00:01:13,180 --> 00:01:17,680
memories work so what I'll do is I'll

21
00:01:15,369 --> 00:01:21,039
give a brief introduction to how they

22
00:01:17,680 --> 00:01:24,100
work and how those features expose the

23
00:01:21,039 --> 00:01:27,369
hardware to security attacks so my talk

24
00:01:24,100 --> 00:01:28,869
is on hardware side channel attacks most

25
00:01:27,369 --> 00:01:31,179
of you probably know what a side channel

26
00:01:28,869 --> 00:01:34,030
attack means compared to direct attack

27
00:01:31,179 --> 00:01:36,219
so side channel indicates that you

28
00:01:34,030 --> 00:01:38,890
observe certain properties about

29
00:01:36,219 --> 00:01:41,559
executing programs and based on

30
00:01:38,890 --> 00:01:44,710
observation of those property you try to

31
00:01:41,560 --> 00:01:48,659
derive some secret information from the

32
00:01:44,710 --> 00:01:52,109
application itself the program itself so

33
00:01:48,659 --> 00:01:55,020
some examples of site channel are

34
00:01:52,109 --> 00:01:58,509
properties that you can observe is

35
00:01:55,020 --> 00:02:01,329
execution time of a program so along the

36
00:01:58,509 --> 00:02:03,819
Deepak Ram tactic secured based on that

37
00:02:01,329 --> 00:02:06,189
you can predict which branch was taken

38
00:02:03,819 --> 00:02:08,680
what value it so for example in this

39
00:02:06,189 --> 00:02:11,859
organ if you can see clearly but he

40
00:02:08,680 --> 00:02:13,910
helped branch paths there so depending

41
00:02:11,860 --> 00:02:17,090
on execution times you can

42
00:02:13,910 --> 00:02:18,829
now find out which path was taken and

43
00:02:17,090 --> 00:02:20,870
based on which path was taken you also

44
00:02:18,830 --> 00:02:23,870
know what's a conditioned value at their

45
00:02:20,870 --> 00:02:26,240
branch so that's one type of attacks you

46
00:02:23,870 --> 00:02:29,030
can predict so for example you can say

47
00:02:26,240 --> 00:02:31,220
in the branch was the value 0 or greater

48
00:02:29,030 --> 00:02:34,570
than 0 maybe there was a condition used

49
00:02:31,220 --> 00:02:37,420
so you can predict which value was used

50
00:02:34,570 --> 00:02:39,709
so those are called timing attacks and

51
00:02:37,420 --> 00:02:42,859
there are other types of attacks people

52
00:02:39,710 --> 00:02:45,050
have actually were successful which is

53
00:02:42,860 --> 00:02:46,880
power and energy attacks so you can

54
00:02:45,050 --> 00:02:48,850
estimate how much power was how much

55
00:02:46,880 --> 00:02:51,950
energy was consumed by your application

56
00:02:48,850 --> 00:02:55,130
even based on that you can predict what

57
00:02:51,950 --> 00:02:57,589
was the execution path what the values

58
00:02:55,130 --> 00:02:58,970
use and those kinds of things or you can

59
00:02:57,590 --> 00:03:01,760
find out how many times the loop is

60
00:02:58,970 --> 00:03:04,310
executed if Floop is executed longer

61
00:03:01,760 --> 00:03:06,769
then it will take longer it it consumes

62
00:03:04,310 --> 00:03:08,920
more energy and so on and there were

63
00:03:06,770 --> 00:03:12,290
even some attacks observing

64
00:03:08,920 --> 00:03:14,989
electromagnetic energy emitted by your

65
00:03:12,290 --> 00:03:17,810
screen and then predict what was the

66
00:03:14,990 --> 00:03:20,000
actual values type on the screen so

67
00:03:17,810 --> 00:03:22,520
those are the examples of not

68
00:03:20,000 --> 00:03:27,530
interfering with the actual program

69
00:03:22,520 --> 00:03:29,480
execution but observing properties so

70
00:03:27,530 --> 00:03:31,820
what we are going to look at today is

71
00:03:29,480 --> 00:03:34,730
mostly based on timing attacks and few

72
00:03:31,820 --> 00:03:36,799
other properties of the hardware so

73
00:03:34,730 --> 00:03:40,070
there are two things that I'm going to

74
00:03:36,800 --> 00:03:42,220
focus today on one is cache memory the

75
00:03:40,070 --> 00:03:45,859
other one is speculative execution and

76
00:03:42,220 --> 00:03:47,660
those are the two architectural features

77
00:03:45,860 --> 00:03:49,790
I won't call them weaknesses but they're

78
00:03:47,660 --> 00:03:55,880
features of the architecture that will

79
00:03:49,790 --> 00:03:58,609
use exploit specter meltdown so let's

80
00:03:55,880 --> 00:04:01,400
look at how cache memory works so if

81
00:03:58,610 --> 00:04:03,140
you're given an address you're going to

82
00:04:01,400 --> 00:04:10,220
use a certain number of bits from the

83
00:04:03,140 --> 00:04:13,309
address and this is this same screen

84
00:04:10,220 --> 00:04:15,230
that you're seeing I don't know ok so as

85
00:04:13,310 --> 00:04:19,399
you can see the middle bits those 10

86
00:04:15,230 --> 00:04:22,340
bits of an address are used to locate a

87
00:04:19,399 --> 00:04:24,590
cache line to find out where your data

88
00:04:22,340 --> 00:04:27,770
is stored in your cache those are called

89
00:04:24,590 --> 00:04:31,280
index bits all caches use

90
00:04:27,770 --> 00:04:34,698
same set of in the index bits so an

91
00:04:31,280 --> 00:04:38,419
attacker can evict your data as long as

92
00:04:34,699 --> 00:04:41,509
the attackers address matches the index

93
00:04:38,419 --> 00:04:44,479
base of the victim so you can evict them

94
00:04:41,509 --> 00:04:50,150
right so that's one of the property

95
00:04:44,479 --> 00:04:51,620
people exploit nowadays we have

96
00:04:50,150 --> 00:04:53,508
something called set associative cache

97
00:04:51,620 --> 00:04:57,830
basically set associative means and

98
00:04:53,509 --> 00:05:00,470
index identifies a number of cache lines

99
00:04:57,830 --> 00:05:03,650
which is called a set in this example we

100
00:05:00,470 --> 00:05:05,509
have four so one index identifies four

101
00:05:03,650 --> 00:05:08,840
lines so your data may be in one of the

102
00:05:05,509 --> 00:05:11,930
four locations but again we are using a

103
00:05:08,840 --> 00:05:14,299
certain number of bits and in most case

104
00:05:11,930 --> 00:05:16,669
we're using those bits so that we can

105
00:05:14,300 --> 00:05:18,470
use a modular arithmetic so hardware is

106
00:05:16,669 --> 00:05:21,430
simple so we can use those four bits

107
00:05:18,470 --> 00:05:25,759
those are the bits you know index bits

108
00:05:21,430 --> 00:05:29,750
so again because any address uses the

109
00:05:25,759 --> 00:05:32,960
same mechanism attacker can evict

110
00:05:29,750 --> 00:05:35,590
victim's data and by evicting you can

111
00:05:32,960 --> 00:05:38,568
find out if the attacker has the same

112
00:05:35,590 --> 00:05:40,969
index bits or not and based on and you

113
00:05:38,569 --> 00:05:45,560
can exploit I'll give you an example of

114
00:05:40,969 --> 00:05:48,319
exploit let me show you this is the

115
00:05:45,560 --> 00:05:54,110
bernstein's attack was exposed about

116
00:05:48,319 --> 00:05:58,870
like maybe 10 years ago so basically if

117
00:05:54,110 --> 00:05:58,870
you're using encryption based on AES

118
00:05:59,199 --> 00:06:04,940
what most implementations are AES they

119
00:06:02,690 --> 00:06:09,440
what they do is if they pre compute some

120
00:06:04,940 --> 00:06:11,630
values and store in the tables and

121
00:06:09,440 --> 00:06:15,500
you'll find out those values of the

122
00:06:11,630 --> 00:06:17,389
table by using exclusive or of a portion

123
00:06:15,500 --> 00:06:20,870
of the key usually eight bits of the key

124
00:06:17,389 --> 00:06:23,479
and eight bits of the plaintext that

125
00:06:20,870 --> 00:06:26,779
will give you an index into the table so

126
00:06:23,479 --> 00:06:29,449
that that describes some computation

127
00:06:26,779 --> 00:06:30,830
precomputed and those values because

128
00:06:29,449 --> 00:06:34,250
otherwise it's going to take a long time

129
00:06:30,830 --> 00:06:36,948
to compute them right so now it's the

130
00:06:34,250 --> 00:06:39,199
table will go into cash because table is

131
00:06:36,949 --> 00:06:41,420
data contains data so you have to bring

132
00:06:39,199 --> 00:06:43,880
the data into your cache once

133
00:06:41,420 --> 00:06:45,980
gets into the cash you're going to index

134
00:06:43,880 --> 00:06:49,580
it you're going to find the entry right

135
00:06:45,980 --> 00:06:51,800
so based on index use you know something

136
00:06:49,580 --> 00:06:53,450
about the key and the plaintext values

137
00:06:51,800 --> 00:06:56,540
because that's nothing but exclusive on

138
00:06:53,450 --> 00:06:59,270
how goes to write so you can do this

139
00:06:56,540 --> 00:07:02,180
several times to find all the pieces of

140
00:06:59,270 --> 00:07:05,299
the key so that's what Bernstein's

141
00:07:02,180 --> 00:07:08,210
attack is and that this is part of also

142
00:07:05,300 --> 00:07:09,950
the a and current Specter attack so once

143
00:07:08,210 --> 00:07:11,419
you get the data into cache you can use

144
00:07:09,950 --> 00:07:20,719
these kinds of attacks to reveal that

145
00:07:11,420 --> 00:07:23,060
information so that's a I'm going to go

146
00:07:20,720 --> 00:07:23,570
to the quick so in order to perform this

147
00:07:23,060 --> 00:07:25,250
attacks

148
00:07:23,570 --> 00:07:27,080
it's not that easy but what you have to

149
00:07:25,250 --> 00:07:29,650
do is there to have patience you have to

150
00:07:27,080 --> 00:07:32,539
try several times so you pick the right

151
00:07:29,650 --> 00:07:34,460
amount of right indexes right entries in

152
00:07:32,540 --> 00:07:36,050
the table and you have to repeat this

153
00:07:34,460 --> 00:07:38,150
several times because each time you only

154
00:07:36,050 --> 00:07:39,560
get a portion of the key so you have to

155
00:07:38,150 --> 00:07:43,400
repeat it several times to find the

156
00:07:39,560 --> 00:07:46,550
entire key you know you also have to

157
00:07:43,400 --> 00:07:48,560
know if the data is evicted or not so

158
00:07:46,550 --> 00:07:51,230
you have to know if cache entry is

159
00:07:48,560 --> 00:07:53,780
evicted if the cache is addicted its

160
00:07:51,230 --> 00:07:55,940
causes cache miss if it causes cache

161
00:07:53,780 --> 00:07:58,099
miss your program takes longer it

162
00:07:55,940 --> 00:08:01,219
executes right so you have to be able to

163
00:07:58,100 --> 00:08:03,530
measure execution time in a very fine

164
00:08:01,220 --> 00:08:07,100
grained level so that you know if the

165
00:08:03,530 --> 00:08:08,989
cache causing miss or not so these are

166
00:08:07,100 --> 00:08:11,090
not easy but they're doable if you have

167
00:08:08,990 --> 00:08:14,570
the patience if you know how to use the

168
00:08:11,090 --> 00:08:17,390
right tools you can do that so these are

169
00:08:14,570 --> 00:08:18,620
tools which are available to anybody to

170
00:08:17,390 --> 00:08:20,570
use in Linux

171
00:08:18,620 --> 00:08:22,790
so hardware has something called

172
00:08:20,570 --> 00:08:24,710
performance counters so you can use

173
00:08:22,790 --> 00:08:27,530
performance counters to measure how many

174
00:08:24,710 --> 00:08:29,900
cache misses are caused by your program

175
00:08:27,530 --> 00:08:31,489
how many times and the instructions

176
00:08:29,900 --> 00:08:33,280
which is acute it if you want how many

177
00:08:31,490 --> 00:08:35,900
times a multiply instruction is executed

178
00:08:33,280 --> 00:08:37,669
all of those are available so that you

179
00:08:35,900 --> 00:08:41,179
can optimize your code right so those

180
00:08:37,669 --> 00:08:46,579
are made available for good reasons but

181
00:08:41,179 --> 00:08:48,439
people can use that to attack so there

182
00:08:46,580 --> 00:08:50,570
are three types of cache attacks that

183
00:08:48,440 --> 00:08:52,880
are commonly grouped together one is

184
00:08:50,570 --> 00:08:55,130
called primal probe this general generic

185
00:08:52,880 --> 00:08:57,079
name prime is

186
00:08:55,130 --> 00:08:59,779
the attacker fills the entire cache

187
00:08:57,079 --> 00:09:03,529
every single length a line of the cache

188
00:08:59,779 --> 00:09:05,360
is filled by attackers data so cache is

189
00:09:03,529 --> 00:09:09,439
fully full right with the attackers

190
00:09:05,360 --> 00:09:12,500
information now when the victims program

191
00:09:09,440 --> 00:09:14,930
starts executing victim nice day of

192
00:09:12,500 --> 00:09:16,519
replace the data so because he has to

193
00:09:14,930 --> 00:09:17,569
bring the victims program has to bring

194
00:09:16,519 --> 00:09:20,000
its own data

195
00:09:17,569 --> 00:09:22,310
now when the attacker comes back and

196
00:09:20,000 --> 00:09:24,079
tries to execute you can discover that

197
00:09:22,310 --> 00:09:27,258
some of his data has been evicted right

198
00:09:24,079 --> 00:09:29,689
because it causes cache misses based on

199
00:09:27,259 --> 00:09:31,670
that you can know exactly what data

200
00:09:29,690 --> 00:09:34,490
items are evicted and based on their

201
00:09:31,670 --> 00:09:36,769
what is the index from that you can get

202
00:09:34,490 --> 00:09:39,440
additional information of the of the

203
00:09:36,769 --> 00:09:41,149
victim so that's called priming the

204
00:09:39,440 --> 00:09:44,930
probe is prime because you're priming

205
00:09:41,149 --> 00:09:48,560
the cache by filling it fully with your

206
00:09:44,930 --> 00:09:52,638
data victim's attackers data the second

207
00:09:48,560 --> 00:09:54,979
one is called evict and time this way

208
00:09:52,639 --> 00:09:59,180
you don't fill the entire cache you

209
00:09:54,980 --> 00:10:01,160
selectively evict victims data so you

210
00:09:59,180 --> 00:10:05,060
just basically try to store some data

211
00:10:01,160 --> 00:10:07,250
into cache line and then if that causes

212
00:10:05,060 --> 00:10:10,160
a Miss for the victim then you know the

213
00:10:07,250 --> 00:10:12,139
victim access the data item right if

214
00:10:10,160 --> 00:10:14,689
victim access the data item and you

215
00:10:12,139 --> 00:10:16,670
evicted that so victim is going to take

216
00:10:14,689 --> 00:10:19,790
longer so it's going to get a cache miss

217
00:10:16,670 --> 00:10:22,009
so that's also you can time it and find

218
00:10:19,790 --> 00:10:24,889
out which lines the victim may have

219
00:10:22,009 --> 00:10:27,290
accessed so this type of a attack I'll

220
00:10:24,889 --> 00:10:29,029
evict and time so your selectively

221
00:10:27,290 --> 00:10:31,639
victim so you can start everything one

222
00:10:29,029 --> 00:10:35,870
line at a time if the attacker used that

223
00:10:31,639 --> 00:10:37,699
line that means the victim uses that

224
00:10:35,870 --> 00:10:39,769
line the victim is going to cause a

225
00:10:37,699 --> 00:10:41,209
cache miss it's going to take longer if

226
00:10:39,769 --> 00:10:43,370
your team does not did not touch that

227
00:10:41,209 --> 00:10:45,619
line you will not cause a cache miss so

228
00:10:43,370 --> 00:10:50,630
you know that we have victim did not use

229
00:10:45,620 --> 00:10:52,850
that address the third type of attack is

230
00:10:50,630 --> 00:10:54,889
flush and reload and this is

231
00:10:52,850 --> 00:10:57,470
particularly useful if you have

232
00:10:54,889 --> 00:11:00,980
multi-core processors so you don't have

233
00:10:57,470 --> 00:11:02,930
to run on the same core as a victim so

234
00:11:00,980 --> 00:11:05,689
your attack program doesn't have to run

235
00:11:02,930 --> 00:11:08,449
on the same core as a victim in

236
00:11:05,689 --> 00:11:09,120
multi-core using this you can evict all

237
00:11:08,449 --> 00:11:11,729
the cache

238
00:11:09,120 --> 00:11:15,810
for everybody including every course

239
00:11:11,730 --> 00:11:17,279
cash plus shared cash so this is a call

240
00:11:15,810 --> 00:11:20,130
flush and reload so you're going to

241
00:11:17,279 --> 00:11:23,790
flush all caches and that can be done

242
00:11:20,130 --> 00:11:24,540
using a simple Intel instruction called

243
00:11:23,790 --> 00:11:26,610
C flush

244
00:11:24,540 --> 00:11:29,670
so if you see flushing to fix all the

245
00:11:26,610 --> 00:11:32,100
caches so you can use that this way you

246
00:11:29,670 --> 00:11:34,290
don't have to run on the same call as

247
00:11:32,100 --> 00:11:37,230
the victim and still in observed

248
00:11:34,290 --> 00:11:41,120
properties so those are the three most

249
00:11:37,230 --> 00:11:43,920
commonly used types of cache attacks and

250
00:11:41,120 --> 00:11:48,150
actually this this last attack can be

251
00:11:43,920 --> 00:11:50,760
used to reveal which pages are used or

252
00:11:48,150 --> 00:11:53,250
shared by the victim and attacker

253
00:11:50,760 --> 00:11:55,350
because operating system and other

254
00:11:53,250 --> 00:12:00,540
libraries are shared by everybody so you

255
00:11:55,350 --> 00:12:03,450
can find out what portions are used and

256
00:12:00,540 --> 00:12:06,029
the types of solutions commonly used for

257
00:12:03,450 --> 00:12:09,029
this or I i grouped them into two types

258
00:12:06,029 --> 00:12:11,279
one is partitioning the other one is

259
00:12:09,029 --> 00:12:13,400
randomizing these are the two solutions

260
00:12:11,279 --> 00:12:16,140
people have been talking about

261
00:12:13,400 --> 00:12:19,260
partitioning as you would probably

262
00:12:16,140 --> 00:12:21,839
envision is dividing the cache into

263
00:12:19,260 --> 00:12:23,400
different parts and run different

264
00:12:21,839 --> 00:12:27,930
programs in different parts of the cache

265
00:12:23,400 --> 00:12:30,650
so the attacker cannot evict so for

266
00:12:27,930 --> 00:12:35,910
example there are several proposals

267
00:12:30,650 --> 00:12:37,620
armed if you use ARM processors and arm

268
00:12:35,910 --> 00:12:41,660
hat if you are using the arm trusted

269
00:12:37,620 --> 00:12:44,940
zone which is supposed to trust their

270
00:12:41,660 --> 00:12:47,100
support if you're going to use a trusted

271
00:12:44,940 --> 00:12:48,510
zones for running applications each

272
00:12:47,100 --> 00:12:50,839
application is going to be flagged

273
00:12:48,510 --> 00:12:55,140
whether it's a secure application or not

274
00:12:50,839 --> 00:12:55,920
so the cache will also be flagged with

275
00:12:55,140 --> 00:12:57,959
one bit

276
00:12:55,920 --> 00:13:00,120
saying that this cache line belongs to

277
00:12:57,959 --> 00:13:04,079
secure application or non secure

278
00:13:00,120 --> 00:13:06,420
application so the attacker if is

279
00:13:04,080 --> 00:13:10,050
running in a non secure portion will not

280
00:13:06,420 --> 00:13:12,240
be able to evict secure lines so arm

281
00:13:10,050 --> 00:13:21,109
claims that you can't evict mouth lines

282
00:13:12,240 --> 00:13:21,110
but some people have can here

283
00:13:28,930 --> 00:13:37,670
so there's a paper recently showing that

284
00:13:34,310 --> 00:13:39,410
arms that one bit indicating with a

285
00:13:37,670 --> 00:13:42,410
secure application or not doesn't

286
00:13:39,410 --> 00:13:45,230
protect because we talked about Prime

287
00:13:42,410 --> 00:13:46,910
and probe primacy Prime they store the

288
00:13:45,230 --> 00:13:50,540
entire cache before the security

289
00:13:46,910 --> 00:13:52,189
application is loaded right so you

290
00:13:50,540 --> 00:13:54,469
already occupied all of that when the

291
00:13:52,190 --> 00:13:58,190
secure application comes the attackers

292
00:13:54,470 --> 00:14:01,040
lines are still evicted even though you

293
00:13:58,190 --> 00:14:02,899
cannot evict victims lies your lines are

294
00:14:01,040 --> 00:14:04,670
evicted so you can still find out from

295
00:14:02,899 --> 00:14:10,069
there so they are proven that this

296
00:14:04,670 --> 00:14:13,639
doesn't really protect so the other way

297
00:14:10,069 --> 00:14:15,259
of dividing caches just partition the

298
00:14:13,639 --> 00:14:17,060
cache and say these cache lines belong

299
00:14:15,259 --> 00:14:19,360
to secure application these are

300
00:14:17,060 --> 00:14:21,829
belonging to non secure applications

301
00:14:19,360 --> 00:14:23,959
remember I talked about set associative

302
00:14:21,829 --> 00:14:26,870
caches where you have several lines

303
00:14:23,959 --> 00:14:31,069
together one set so recently a paper

304
00:14:26,870 --> 00:14:36,829
from MIT just in this March December

305
00:14:31,069 --> 00:14:39,829
2018 they proposed using different lines

306
00:14:36,829 --> 00:14:42,410
in a set for secure non secure

307
00:14:39,829 --> 00:14:44,209
applications so in this example there

308
00:14:42,410 --> 00:14:46,550
are eight ways that Miss eight cache

309
00:14:44,209 --> 00:14:50,569
lines together has one address one index

310
00:14:46,550 --> 00:14:54,139
those are ways eight ways so for example

311
00:14:50,569 --> 00:14:56,089
that red ones w0 and w1 are allocated

312
00:14:54,139 --> 00:14:59,209
for secure applications the others are

313
00:14:56,089 --> 00:15:01,670
not so you will never able be able to

314
00:14:59,209 --> 00:15:03,250
touch those two lines you will not get

315
00:15:01,670 --> 00:15:06,469
any information about those two lines

316
00:15:03,250 --> 00:15:08,209
but again the primum program is not

317
00:15:06,470 --> 00:15:11,000
protected by this right but if when you

318
00:15:08,209 --> 00:15:13,250
prime to fill the entire cache so you

319
00:15:11,000 --> 00:15:19,310
can still find out that somebody evicted

320
00:15:13,250 --> 00:15:22,790
your lines are not so the other type is

321
00:15:19,310 --> 00:15:27,619
randomizing so one proposal from

322
00:15:22,790 --> 00:15:31,430
Princeton several years ago is to use an

323
00:15:27,620 --> 00:15:33,830
additional table permutation table so

324
00:15:31,430 --> 00:15:35,479
you take the index and

325
00:15:33,830 --> 00:15:37,940
use the in death into a permutation

326
00:15:35,480 --> 00:15:40,700
table and the permutation table gives

327
00:15:37,940 --> 00:15:44,260
some new random address so use the

328
00:15:40,700 --> 00:15:48,350
random address for cash so even though

329
00:15:44,260 --> 00:15:50,270
attacker and victim of same index they

330
00:15:48,350 --> 00:15:53,380
use different random numbers to say

331
00:15:50,270 --> 00:15:57,350
where the data is placed so this way

332
00:15:53,380 --> 00:16:00,260
attacker would does not really know by

333
00:15:57,350 --> 00:16:02,780
evicting a cache line that the attacker

334
00:16:00,260 --> 00:16:07,850
and victim has the same index the index

335
00:16:02,780 --> 00:16:10,400
is been changed the main problem with

336
00:16:07,850 --> 00:16:13,100
this one is he have an extra table that

337
00:16:10,400 --> 00:16:15,860
you had to look up so he cannot access

338
00:16:13,100 --> 00:16:17,840
cash directly so you have to use the

339
00:16:15,860 --> 00:16:21,980
index then going to the permutation

340
00:16:17,840 --> 00:16:24,170
table and then go to the cache cache the

341
00:16:21,980 --> 00:16:25,910
reason why we use cash is because we

342
00:16:24,170 --> 00:16:29,479
want to make memory access very fast

343
00:16:25,910 --> 00:16:32,270
right by adding this extra layer your

344
00:16:29,480 --> 00:16:34,580
speed is going to go down right so

345
00:16:32,270 --> 00:16:37,130
you're losing performance by doing this

346
00:16:34,580 --> 00:16:40,130
the second thing is somebody has to load

347
00:16:37,130 --> 00:16:41,810
those permutation tables so every time

348
00:16:40,130 --> 00:16:43,460
you start running your program you have

349
00:16:41,810 --> 00:16:48,199
to first fill this permutation tables

350
00:16:43,460 --> 00:16:50,270
right so that's an extra overhead so

351
00:16:48,200 --> 00:16:53,270
what we proposed is a much simpler

352
00:16:50,270 --> 00:16:55,160
solution just change which bits you're

353
00:16:53,270 --> 00:16:57,980
going to use for index what do you have

354
00:16:55,160 --> 00:17:00,500
to use the same bits for everybody as an

355
00:16:57,980 --> 00:17:02,960
index remember I've shown you those 10

356
00:17:00,500 --> 00:17:04,459
bits in your address as your index what

357
00:17:02,960 --> 00:17:06,650
do you have to use the same 10 bits

358
00:17:04,459 --> 00:17:09,620
why not use some different combinations

359
00:17:06,650 --> 00:17:12,500
of bits so the victim you will use a

360
00:17:09,619 --> 00:17:15,319
different set of bits and attacker will

361
00:17:12,500 --> 00:17:17,630
use the different bits right so no two

362
00:17:15,319 --> 00:17:19,970
programs use the same portion of your

363
00:17:17,630 --> 00:17:22,250
address that way you won't be able to

364
00:17:19,970 --> 00:17:24,560
predict right so this way you don't have

365
00:17:22,250 --> 00:17:26,810
to change the extra heart you don't have

366
00:17:24,560 --> 00:17:29,330
to go to another table to find you know

367
00:17:26,810 --> 00:17:32,990
an index and so on so by just changing

368
00:17:29,330 --> 00:17:36,409
the bits we get the same effect of

369
00:17:32,990 --> 00:17:39,620
randomizing but which bits be used right

370
00:17:36,410 --> 00:17:44,420
so which studied different solutions one

371
00:17:39,620 --> 00:17:47,959
solution we did was take the standard

372
00:17:44,420 --> 00:17:51,740
index bits and take some bits for

373
00:17:47,960 --> 00:17:53,659
the tag and excludes the organ so your

374
00:17:51,740 --> 00:17:55,250
tag would be different from a tiger's

375
00:17:53,659 --> 00:17:56,779
tag because those bit addresses will be

376
00:17:55,250 --> 00:17:58,549
different so just taking the

377
00:17:56,779 --> 00:18:01,159
exclusive-or them you can create a new

378
00:17:58,549 --> 00:18:03,799
index so it's very simple solution right

379
00:18:01,159 --> 00:18:05,299
the hardware is very simple and you can

380
00:18:03,799 --> 00:18:08,029
think of other ways I'll show you some

381
00:18:05,299 --> 00:18:09,740
data quickly so we studied this how much

382
00:18:08,029 --> 00:18:12,890
performance are you going to lose a game

383
00:18:09,740 --> 00:18:15,260
by using this method so we studied for

384
00:18:12,890 --> 00:18:18,559
several benchmarks and we ran it on a

385
00:18:15,260 --> 00:18:20,149
full core system assuming 4 cores and

386
00:18:18,559 --> 00:18:22,549
four cores running four different

387
00:18:20,149 --> 00:18:25,158
programs each program you use slightly

388
00:18:22,549 --> 00:18:26,450
different indexing method saying that

389
00:18:25,159 --> 00:18:29,690
how much performance is you're going to

390
00:18:26,450 --> 00:18:32,510
lose by doing that as this shows the how

391
00:18:29,690 --> 00:18:35,149
many cache misses our cause was Miss

392
00:18:32,510 --> 00:18:37,129
rate you know at l3 shared level last

393
00:18:35,149 --> 00:18:39,379
level cache as you can see the

394
00:18:37,130 --> 00:18:41,809
difference is not significant so the

395
00:18:39,380 --> 00:18:45,230
first line the blue line to the left in

396
00:18:41,809 --> 00:18:49,190
each of those sets of data is original

397
00:18:45,230 --> 00:18:51,080
that means no standard indexing and the

398
00:18:49,190 --> 00:18:53,120
other things are slightly different

399
00:18:51,080 --> 00:18:55,908
variations running on different types of

400
00:18:53,120 --> 00:18:58,610
processors the AMD processor or Intel

401
00:18:55,909 --> 00:19:00,799
processor and so on as you notice the

402
00:18:58,610 --> 00:19:02,779
difference is not that significant so

403
00:19:00,799 --> 00:19:06,918
you're really not losing significant

404
00:19:02,779 --> 00:19:09,309
performance by changing the indexing we

405
00:19:06,919 --> 00:19:12,919
also studied the actual execution time

406
00:19:09,309 --> 00:19:15,168
so for again for the same benchmarks how

407
00:19:12,919 --> 00:19:17,270
much performance are you losing so as

408
00:19:15,169 --> 00:19:20,690
you can see the performance loss is 1%

409
00:19:17,270 --> 00:19:23,330
or 2% in the range so we feel that this

410
00:19:20,690 --> 00:19:25,909
is except acceptable performance loss

411
00:19:23,330 --> 00:19:29,750
that you can tolerate but achieve

412
00:19:25,909 --> 00:19:32,419
security against cache attacks right and

413
00:19:29,750 --> 00:19:34,970
we tried other type of solutions instead

414
00:19:32,419 --> 00:19:37,700
of exclusive Orion can we use a hand can

415
00:19:34,970 --> 00:19:40,520
we use an and and stuff like that of a

416
00:19:37,700 --> 00:19:42,770
this index bits plus some tag base do

417
00:19:40,520 --> 00:19:45,980
you exclusive or do you hand them do you

418
00:19:42,770 --> 00:19:50,210
hoard them and so on but we found our

419
00:19:45,980 --> 00:19:52,149
end is really bad so if you use and the

420
00:19:50,210 --> 00:19:54,610
performance loss can be significant

421
00:19:52,149 --> 00:19:56,840
where the exclusive-or is very good

422
00:19:54,610 --> 00:19:59,649
exclusive doesn't lose much performance

423
00:19:56,840 --> 00:20:01,730
but if you do err you lose quite a bit

424
00:19:59,649 --> 00:20:04,129
as you can see

425
00:20:01,730 --> 00:20:05,990
so what we need to do is try different

426
00:20:04,130 --> 00:20:09,590
combination here is shows performance

427
00:20:05,990 --> 00:20:13,730
loss and and so on so what we need to do

428
00:20:09,590 --> 00:20:15,379
I'm sorry yeah so what we need to do is

429
00:20:13,730 --> 00:20:18,050
study different ways of changing

430
00:20:15,380 --> 00:20:20,840
indexing randomizing it so that every

431
00:20:18,050 --> 00:20:23,600
time your program is loaded operating

432
00:20:20,840 --> 00:20:26,500
system decides what index to use right

433
00:20:23,600 --> 00:20:29,060
and you can change randomly so now

434
00:20:26,500 --> 00:20:31,460
attacker would never be able to predict

435
00:20:29,060 --> 00:20:33,110
if you have the same index bits or not I

436
00:20:31,460 --> 00:20:34,160
mean you can predict because you hope

437
00:20:33,110 --> 00:20:35,899
they're gonna find that number of

438
00:20:34,160 --> 00:20:38,150
combinations if you're running million

439
00:20:35,900 --> 00:20:40,070
times you can still predict but you're

440
00:20:38,150 --> 00:20:47,540
making so much more difficult for the

441
00:20:40,070 --> 00:20:51,320
attacker the second type of attack is

442
00:20:47,540 --> 00:20:54,110
primarily based on speculation so when

443
00:20:51,320 --> 00:20:56,720
you talk about timing analysis the

444
00:20:54,110 --> 00:20:58,990
timing is based on the fact that all

445
00:20:56,720 --> 00:21:01,940
architectures use speculative execution

446
00:20:58,990 --> 00:21:04,490
so let me talk briefly about what

447
00:21:01,940 --> 00:21:06,800
speculative execution means from

448
00:21:04,490 --> 00:21:09,710
architecture point of view if you're

449
00:21:06,800 --> 00:21:11,330
taking any architecture class you must

450
00:21:09,710 --> 00:21:13,220
have seen this diagram right this is

451
00:21:11,330 --> 00:21:15,860
from Hennessy embarrassin you know a

452
00:21:13,220 --> 00:21:18,470
book so you have the fireline five five

453
00:21:15,860 --> 00:21:21,729
pipeline stages instruction 4hd code

454
00:21:18,470 --> 00:21:25,820
execute and so on right so if you have a

455
00:21:21,730 --> 00:21:28,430
branch instruction you know the branch

456
00:21:25,820 --> 00:21:30,409
instruction is being executed in the

457
00:21:28,430 --> 00:21:31,600
decode stage right when you decode it

458
00:21:30,410 --> 00:21:34,100
you know you have a branch instruction

459
00:21:31,600 --> 00:21:36,350
but he had to wait on the leg secure

460
00:21:34,100 --> 00:21:38,929
stage to find out if the branch is going

461
00:21:36,350 --> 00:21:40,760
to be taken I'm not taking so if you

462
00:21:38,930 --> 00:21:43,520
don't do anything gonna lose two cycles

463
00:21:40,760 --> 00:21:45,980
right in this five five pipeline stages

464
00:21:43,520 --> 00:21:48,560
but most of today's architectures may

465
00:21:45,980 --> 00:21:52,220
have like 20 stages a pipe you know

466
00:21:48,560 --> 00:21:55,010
pipelines so branches can cause about 20

467
00:21:52,220 --> 00:21:56,660
cycle loss so in order to avoid that

468
00:21:55,010 --> 00:21:58,700
what we're going to do is we're gonna

469
00:21:56,660 --> 00:22:01,070
predict whether the branch is going to

470
00:21:58,700 --> 00:22:03,190
be taken or not even before we know the

471
00:22:01,070 --> 00:22:06,500
decision and start executing

472
00:22:03,190 --> 00:22:08,630
instructions for the predicted path that

473
00:22:06,500 --> 00:22:12,200
way if you're correct you won't lose any

474
00:22:08,630 --> 00:22:14,240
his cycles but we are miss predict then

475
00:22:12,200 --> 00:22:15,590
you lose cycles right so then the goal

476
00:22:14,240 --> 00:22:20,029
is to make your prediction

477
00:22:15,590 --> 00:22:24,999
accurate as possible so here is an

478
00:22:20,029 --> 00:22:29,210
example simple loop you know you have

479
00:22:24,999 --> 00:22:32,360
your adding incrementing array by one by

480
00:22:29,210 --> 00:22:35,450
simple loop so what

481
00:22:32,360 --> 00:22:37,998
when I say speculate execution here it

482
00:22:35,450 --> 00:22:39,710
shows when each of the instruction is

483
00:22:37,999 --> 00:22:43,940
going to be completed completed look at

484
00:22:39,710 --> 00:22:47,179
the last column to the right just before

485
00:22:43,940 --> 00:22:49,999
the comments Committee says commit at

486
00:22:47,179 --> 00:22:54,169
cycle number so that indicates when the

487
00:22:49,999 --> 00:22:57,559
instruction actually completed right now

488
00:22:54,169 --> 00:22:59,659
look at load instruction from the second

489
00:22:57,559 --> 00:23:01,759
iteration so if you look at the

490
00:22:59,659 --> 00:23:06,649
iteration number in the first column one

491
00:23:01,759 --> 00:23:09,909
so second iteration the load instruction

492
00:23:06,649 --> 00:23:13,158
should not start unto cycle nine

493
00:23:09,909 --> 00:23:15,559
executing right because the branch from

494
00:23:13,159 --> 00:23:19,940
the first iteration is not completed in

495
00:23:15,559 --> 00:23:22,279
cycle eight so you should not start load

496
00:23:19,940 --> 00:23:24,830
until we know that branch is going to be

497
00:23:22,279 --> 00:23:26,919
taken until I'm the start executing next

498
00:23:24,830 --> 00:23:29,449
iteration in cycle nine

499
00:23:26,919 --> 00:23:31,129
but what speculative execution say hey

500
00:23:29,450 --> 00:23:33,350
this is a loop so chances are you're

501
00:23:31,129 --> 00:23:36,049
going to repeat it so it's going to

502
00:23:33,350 --> 00:23:37,850
predict and predict and start executing

503
00:23:36,049 --> 00:23:39,429
as you can see started executing in

504
00:23:37,850 --> 00:23:43,969
cycle four cyclic

505
00:23:39,429 --> 00:23:46,249
load from the second iteration and if

506
00:23:43,970 --> 00:23:48,740
you're lucky if your branch is going to

507
00:23:46,249 --> 00:23:51,259
be taken everything is going to go well

508
00:23:48,740 --> 00:23:53,869
right he's saved in sub waiting under

509
00:23:51,259 --> 00:23:58,309
cycle nine he started executing cycle

510
00:23:53,869 --> 00:24:03,709
five that means is here four cycles so

511
00:23:58,309 --> 00:24:06,249
that's the idea behind speculation you

512
00:24:03,710 --> 00:24:06,249
have a question

513
00:24:06,460 --> 00:24:12,169
and what's more interesting about this

514
00:24:10,070 --> 00:24:14,210
this is how we're the security attacks

515
00:24:12,169 --> 00:24:17,809
come into play so let's look at this

516
00:24:14,210 --> 00:24:20,629
example of a loop this loop should only

517
00:24:17,809 --> 00:24:23,299
execute hundred times right when I

518
00:24:20,629 --> 00:24:25,428
equals 100 what happens we should not

519
00:24:23,299 --> 00:24:28,399
execute we should not execute next cycle

520
00:24:25,429 --> 00:24:31,490
next iteration right but what does our

521
00:24:28,399 --> 00:24:34,998
speculation do in this in the 1990 when

522
00:24:31,490 --> 00:24:36,409
I equals 99 and when I next cycle curves

523
00:24:34,999 --> 00:24:38,149
would predict that you're going to take

524
00:24:36,409 --> 00:24:44,889
the branch and we go ahead and execute

525
00:24:38,149 --> 00:24:44,889
it what happened then you fetched be 100

526
00:24:45,369 --> 00:24:50,480
you're not supposed to get be 100 you

527
00:24:47,960 --> 00:24:52,249
already got behind 100 write the system

528
00:24:50,480 --> 00:24:55,220
say hey this is wrong you should not

529
00:24:52,249 --> 00:24:58,549
execute it whenever we get the data it

530
00:24:55,220 --> 00:25:00,200
goes into the cache the data if it is

531
00:24:58,549 --> 00:25:02,690
not in the cache already you bring it

532
00:25:00,200 --> 00:25:04,669
from memory into the cache so when I say

533
00:25:02,690 --> 00:25:07,879
Lord I'm bringing the data into the

534
00:25:04,669 --> 00:25:09,259
cache even if the program says you

535
00:25:07,879 --> 00:25:11,719
should you know should not fetch this

536
00:25:09,259 --> 00:25:13,999
instance this data you are not going to

537
00:25:11,720 --> 00:25:17,149
take the data away from the cache you're

538
00:25:13,999 --> 00:25:19,970
going to leave the data in the cache now

539
00:25:17,149 --> 00:25:22,309
the attacker has access to that data

540
00:25:19,970 --> 00:25:25,429
because you can use the cache attacks to

541
00:25:22,309 --> 00:25:27,019
reveal that information so that's behind

542
00:25:25,429 --> 00:25:30,350
that's the attack that Specter and

543
00:25:27,019 --> 00:25:31,610
meltdown uses so basically the it knows

544
00:25:30,350 --> 00:25:32,539
that if we are going to execute

545
00:25:31,610 --> 00:25:35,529
speculatively

546
00:25:32,539 --> 00:25:38,419
and try to execute illegal operations

547
00:25:35,529 --> 00:25:40,879
and it's going to fetch the data so for

548
00:25:38,419 --> 00:25:44,629
example you're not supposed to access

549
00:25:40,879 --> 00:25:48,230
Colonel tables right from the user code

550
00:25:44,629 --> 00:25:50,899
but try try to get it get the data from

551
00:25:48,230 --> 00:25:52,490
the colonel tables and the speculation

552
00:25:50,899 --> 00:25:54,469
may get the data for you already

553
00:25:52,490 --> 00:25:57,230
even the operating system will kill your

554
00:25:54,470 --> 00:25:59,210
program then you can use a different

555
00:25:57,230 --> 00:26:01,279
program to reveal the information from

556
00:25:59,210 --> 00:26:03,830
the cache so you can have two programs

557
00:26:01,279 --> 00:26:05,840
on the attacker side one to try to

558
00:26:03,830 --> 00:26:07,449
legally get the data into the cache and

559
00:26:05,840 --> 00:26:10,970
another to reveal the data of the cache

560
00:26:07,450 --> 00:26:14,029
that's our specter and meltdown type of

561
00:26:10,970 --> 00:26:15,799
attacks work again it's not easy you

562
00:26:14,029 --> 00:26:19,480
have to try so many times to get be able

563
00:26:15,799 --> 00:26:23,230
to get that data so

564
00:26:19,480 --> 00:26:25,210
so again that's the how these two

565
00:26:23,230 --> 00:26:27,310
attacks work and again these are because

566
00:26:25,210 --> 00:26:32,290
how cache memories are designed our

567
00:26:27,310 --> 00:26:34,090
speculation works right so basically how

568
00:26:32,290 --> 00:26:37,540
the speculation works is you have a

569
00:26:34,090 --> 00:26:39,939
table called branch prediction table and

570
00:26:37,540 --> 00:26:42,190
you usually use two bits in the branch

571
00:26:39,940 --> 00:26:44,170
prediction saying that if branch is

572
00:26:42,190 --> 00:26:46,450
predicted correctly a mark if it

573
00:26:44,170 --> 00:26:48,820
mispredicted branch two times then we

574
00:26:46,450 --> 00:26:50,770
change the prediction there's a reason

575
00:26:48,820 --> 00:26:53,379
for why we wait for two times to be miss

576
00:26:50,770 --> 00:26:54,940
predicted but that's if you have taken

577
00:26:53,380 --> 00:26:58,420
architecture you probably know why that

578
00:26:54,940 --> 00:27:00,040
is so we use two bits and you use the

579
00:26:58,420 --> 00:27:02,230
same prediction unless you miss

580
00:27:00,040 --> 00:27:03,970
predicted two times in a row if it miss

581
00:27:02,230 --> 00:27:06,040
politically two times in a row we change

582
00:27:03,970 --> 00:27:07,690
the prediction to the opposite so if you

583
00:27:06,040 --> 00:27:09,639
initially predicted branch is going to

584
00:27:07,690 --> 00:27:11,050
be taken and you miss predicted two

585
00:27:09,640 --> 00:27:11,590
times you change it a branch is

586
00:27:11,050 --> 00:27:17,080
not-taken

587
00:27:11,590 --> 00:27:19,300
right and the next thing we also do is

588
00:27:17,080 --> 00:27:22,240
we have this table can't call a branch

589
00:27:19,300 --> 00:27:29,399
target buffer so what did branch target

590
00:27:22,240 --> 00:27:35,980
buffer does is if I guess can you see my

591
00:27:29,400 --> 00:27:38,110
cursor no okay so you have the address

592
00:27:35,980 --> 00:27:40,660
of the instruction that you're going to

593
00:27:38,110 --> 00:27:42,939
execute if the branch is taken so this

594
00:27:40,660 --> 00:27:45,060
table contains the address where you're

595
00:27:42,940 --> 00:27:47,770
going to jump to if the branch is taken

596
00:27:45,060 --> 00:27:49,870
so if you predicted branch is going to

597
00:27:47,770 --> 00:27:51,550
be taken you already have the address of

598
00:27:49,870 --> 00:27:53,379
where you going to branch so you can

599
00:27:51,550 --> 00:27:56,230
start fetching the day instruction from

600
00:27:53,380 --> 00:27:58,840
that address and start executing so you

601
00:27:56,230 --> 00:28:01,870
won't lose any cycles so that's why we

602
00:27:58,840 --> 00:28:03,189
need this table and this table is going

603
00:28:01,870 --> 00:28:05,739
to be indexed by the branch instruction

604
00:28:03,190 --> 00:28:08,050
so in the previous example we have

605
00:28:05,740 --> 00:28:10,330
branch not equals so the branch is not

606
00:28:08,050 --> 00:28:12,370
equals instruction has an address the

607
00:28:10,330 --> 00:28:15,010
program counter address we use the

608
00:28:12,370 --> 00:28:17,709
program counter address and use that as

609
00:28:15,010 --> 00:28:19,780
an index into this table this table

610
00:28:17,710 --> 00:28:23,080
tells you if the branch is going to be

611
00:28:19,780 --> 00:28:25,240
predicted as taken or not taken and if

612
00:28:23,080 --> 00:28:27,100
it is predicted as taken then we also

613
00:28:25,240 --> 00:28:28,990
have the address are where you're going

614
00:28:27,100 --> 00:28:30,850
to branch to see so yeah all the

615
00:28:28,990 --> 00:28:34,740
information you need to start executing

616
00:28:30,850 --> 00:28:34,740
immediately the next instruction

617
00:28:35,380 --> 00:28:41,780
but once it start executing instructions

618
00:28:38,920 --> 00:28:44,360
speculatively we need to make sure that

619
00:28:41,780 --> 00:28:46,639
if the prediction is not correct we have

620
00:28:44,360 --> 00:28:49,040
to undo all the computations right if

621
00:28:46,640 --> 00:28:51,200
the branch is mispredicted you have to

622
00:28:49,040 --> 00:28:53,540
undo add instructions that follower

623
00:28:51,200 --> 00:28:55,820
multiply instructions we follow so what

624
00:28:53,540 --> 00:28:57,980
we do for that is they have a buffer

625
00:28:55,820 --> 00:29:01,460
called reorder buffer so if you see on

626
00:28:57,980 --> 00:29:04,190
the right hand top and there's a curry

627
00:29:01,460 --> 00:29:07,910
or a buffer so all the instructions

628
00:29:04,190 --> 00:29:10,910
except loader store store their results

629
00:29:07,910 --> 00:29:12,830
in this buffer only when we are ready to

630
00:29:10,910 --> 00:29:14,420
say that branch is correctly predicted

631
00:29:12,830 --> 00:29:18,139
so these instructions are correctly

632
00:29:14,420 --> 00:29:20,540
executed we won't copy the data into the

633
00:29:18,140 --> 00:29:23,420
right locations so we buffer the data

634
00:29:20,540 --> 00:29:26,530
into the buffers until we know whether

635
00:29:23,420 --> 00:29:29,330
you execute it correctly or not

636
00:29:26,530 --> 00:29:34,190
however load instructions still get the

637
00:29:29,330 --> 00:29:37,280
data in the cache so some new solutions

638
00:29:34,190 --> 00:29:41,240
oh by the way one of the things we did

639
00:29:37,280 --> 00:29:46,250
was what if we randomly make the

640
00:29:41,240 --> 00:29:48,170
architecture miss predict so remember we

641
00:29:46,250 --> 00:29:49,670
talked of timing attack timing attack is

642
00:29:48,170 --> 00:29:52,430
assuming that branch prediction is

643
00:29:49,670 --> 00:29:55,490
correct and you know works normally so

644
00:29:52,430 --> 00:29:58,670
you can find the times if I force the

645
00:29:55,490 --> 00:30:02,180
hardware to miss predict randomly I'm

646
00:29:58,670 --> 00:30:03,770
changing the timing right so that it

647
00:30:02,180 --> 00:30:08,240
will become more difficult for timing

648
00:30:03,770 --> 00:30:12,230
attacks to know when I miss a made the

649
00:30:08,240 --> 00:30:15,560
architecture to miss predict so one way

650
00:30:12,230 --> 00:30:17,090
to do that is just clear the table bits

651
00:30:15,560 --> 00:30:19,720
right away if you remember we have the

652
00:30:17,090 --> 00:30:21,830
two bits for a branch prediction right

653
00:30:19,720 --> 00:30:25,430
periodically I'm going to reset to zero

654
00:30:21,830 --> 00:30:27,350
so all of them so the hardware miss

655
00:30:25,430 --> 00:30:30,260
predicts right so depending on when I

656
00:30:27,350 --> 00:30:33,230
reset it the execution time changes

657
00:30:30,260 --> 00:30:34,879
completely so the timing attacks become

658
00:30:33,230 --> 00:30:39,740
much more difficult so here is an

659
00:30:34,880 --> 00:30:43,640
example if you look at the table I shown

660
00:30:39,740 --> 00:30:46,880
you in the two columns there one column

661
00:30:43,640 --> 00:30:48,650
says that if you prediction is correct

662
00:30:46,880 --> 00:30:52,730
your instructions are going to look like

663
00:30:48,650 --> 00:30:54,740
when they are executed and on the right

664
00:30:52,730 --> 00:30:57,050
hand side I'm going to make it

665
00:30:54,740 --> 00:30:58,880
mispredict so we're going to say that

666
00:30:57,050 --> 00:31:01,340
branch is not-taken so even though loops

667
00:30:58,880 --> 00:31:03,320
normally take I miss predicting so it

668
00:31:01,340 --> 00:31:04,850
shows how the instructions look like

669
00:31:03,320 --> 00:31:06,830
when they execute based on this

670
00:31:04,850 --> 00:31:08,540
prediction so as you can see the number

671
00:31:06,830 --> 00:31:10,100
of instructions executed number of

672
00:31:08,540 --> 00:31:13,040
cycles need it will be completely

673
00:31:10,100 --> 00:31:15,620
different right so we can think of

674
00:31:13,040 --> 00:31:17,960
randomly clearing the table right so

675
00:31:15,620 --> 00:31:20,659
what we did was what if I cleared the

676
00:31:17,960 --> 00:31:22,670
table for every 10,000 instructions

677
00:31:20,660 --> 00:31:25,340
every hundred thousand instructions

678
00:31:22,670 --> 00:31:28,790
every million instructions and so on how

679
00:31:25,340 --> 00:31:30,830
much performance am I going to lose if

680
00:31:28,790 --> 00:31:32,620
you clear the table more frequently

681
00:31:30,830 --> 00:31:36,460
you're gonna lose more performance right

682
00:31:32,620 --> 00:31:38,179
so effectively if I clear every cycle

683
00:31:36,460 --> 00:31:39,470
what's going to happen

684
00:31:38,180 --> 00:31:41,090
it means like you don't have any

685
00:31:39,470 --> 00:31:42,620
speculative execution right there's no

686
00:31:41,090 --> 00:31:45,980
speculation because you miss predicting

687
00:31:42,620 --> 00:31:47,750
every time so we can do that or say

688
00:31:45,980 --> 00:31:50,000
never clear then it's going to have full

689
00:31:47,750 --> 00:31:52,490
speculation so you can change randomly

690
00:31:50,000 --> 00:31:53,600
how often you're gonna miss predict so

691
00:31:52,490 --> 00:31:57,560
if you look at I don't know if you can

692
00:31:53,600 --> 00:31:59,209
see that that data so if you miss

693
00:31:57,560 --> 00:32:02,270
predicted every 100 millions

694
00:31:59,210 --> 00:32:04,940
instructions you only lose like 0.1%

695
00:32:02,270 --> 00:32:08,000
whereas if you've cleared it every ten

696
00:32:04,940 --> 00:32:13,070
thousands instruction you might lose

697
00:32:08,000 --> 00:32:14,720
about ten percent so you have a rage and

698
00:32:13,070 --> 00:32:17,540
how much performance are you willing to

699
00:32:14,720 --> 00:32:19,880
lose how much more difficult you want to

700
00:32:17,540 --> 00:32:26,870
make for the timing attacks so you can

701
00:32:19,880 --> 00:32:29,960
change that so again we need to look at

702
00:32:26,870 --> 00:32:33,290
many more solution many more simulations

703
00:32:29,960 --> 00:32:35,900
more examples more tests to do this so

704
00:32:33,290 --> 00:32:37,610
we're working on that and we will

705
00:32:35,900 --> 00:32:40,880
actually what we want to do is launch

706
00:32:37,610 --> 00:32:42,350
Specter attack and find out the timing

707
00:32:40,880 --> 00:32:44,810
differences how much more difficult

708
00:32:42,350 --> 00:32:46,939
would be to predict how many times how

709
00:32:44,810 --> 00:32:48,679
many more times you have to use this

710
00:32:46,940 --> 00:32:51,370
Specter attack before you reveal the

711
00:32:48,680 --> 00:32:51,370
information

712
00:32:52,800 --> 00:33:03,090
and the next progress in trying to

713
00:33:00,020 --> 00:33:06,980
mitigate the attacks the solutions for

714
00:33:03,090 --> 00:33:11,129
this e can we somehow make this

715
00:33:06,980 --> 00:33:13,860
speculative load not visible that's what

716
00:33:11,130 --> 00:33:15,929
we call silent speculative loss that

717
00:33:13,860 --> 00:33:19,800
means treat whenever you're loading the

718
00:33:15,929 --> 00:33:22,410
data speculatively to be different from

719
00:33:19,800 --> 00:33:24,178
normal load instruction remember when

720
00:33:22,410 --> 00:33:25,350
you have speculated load the data comes

721
00:33:24,179 --> 00:33:28,140
to the cache right that's how the

722
00:33:25,350 --> 00:33:30,230
attacker reveals information about the

723
00:33:28,140 --> 00:33:33,929
data so if you bring it into the cache

724
00:33:30,230 --> 00:33:35,850
even though that low should not have

725
00:33:33,929 --> 00:33:39,420
been executed the data is already in the

726
00:33:35,850 --> 00:33:40,919
cache and there are other type of things

727
00:33:39,420 --> 00:33:43,559
that happens when you bring into the

728
00:33:40,920 --> 00:33:45,809
cache there's some thing called metadata

729
00:33:43,559 --> 00:33:47,550
that's also going to change metadata is

730
00:33:45,809 --> 00:33:50,428
like for example when was this cache

731
00:33:47,550 --> 00:33:52,740
line last accessed so we have the LRU

732
00:33:50,429 --> 00:33:55,230
base last at least recently used bits

733
00:33:52,740 --> 00:33:56,760
which are used to find out which cache

734
00:33:55,230 --> 00:33:59,580
line you're going to evict if you have

735
00:33:56,760 --> 00:34:01,110
the evict so that's called metadata and

736
00:33:59,580 --> 00:34:03,840
there's some other thing coherency if

737
00:34:01,110 --> 00:34:06,300
you took a core to core shared the data

738
00:34:03,840 --> 00:34:08,250
and one core rights he had invalidate

739
00:34:06,300 --> 00:34:10,529
the other data and so on so those kinds

740
00:34:08,250 --> 00:34:13,649
of coherence information is also called

741
00:34:10,530 --> 00:34:17,010
a metadata so if you bring the data into

742
00:34:13,649 --> 00:34:20,580
the cache you have to you may change the

743
00:34:17,010 --> 00:34:23,330
metadata or actual cache data so can I

744
00:34:20,580 --> 00:34:23,330
go back to my slide

745
00:34:31,960 --> 00:34:37,159
so there's a paper again appear in

746
00:34:34,969 --> 00:34:41,509
December this year what they're

747
00:34:37,159 --> 00:34:43,669
proposing is use a buffer for load so

748
00:34:41,510 --> 00:34:46,070
don't use the cache memory when you

749
00:34:43,668 --> 00:34:47,989
doing speculative load so you have a

750
00:34:46,070 --> 00:34:50,270
separate buffer so you bring the data

751
00:34:47,989 --> 00:34:54,439
into the buffer rather than into the

752
00:34:50,270 --> 00:34:57,050
cache so that if you miss predicted the

753
00:34:54,440 --> 00:34:58,670
cache data that's not going to be

754
00:34:57,050 --> 00:35:00,940
visible in the cache so attacker would

755
00:34:58,670 --> 00:35:04,550
not know that you actually read the data

756
00:35:00,940 --> 00:35:06,740
so you have to have an extra buffer but

757
00:35:04,550 --> 00:35:08,930
this causes some problems so for one

758
00:35:06,740 --> 00:35:10,910
thing it causes performance because if

759
00:35:08,930 --> 00:35:12,529
somebody else access the same cash flow

760
00:35:10,910 --> 00:35:14,600
or data you have to go back and read

761
00:35:12,530 --> 00:35:17,810
from memory because that still will be

762
00:35:14,600 --> 00:35:20,029
as a cache miss so you have some loss

763
00:35:17,810 --> 00:35:22,190
because if you brought the data into the

764
00:35:20,030 --> 00:35:24,530
cache you would have avoided one cache

765
00:35:22,190 --> 00:35:27,020
miss but now you're causing additional

766
00:35:24,530 --> 00:35:31,790
cache misses so you lose some

767
00:35:27,020 --> 00:35:34,610
information but more significant is how

768
00:35:31,790 --> 00:35:36,860
do we handle cache coherency issues so

769
00:35:34,610 --> 00:35:39,590
let's take an example I shown you they

770
00:35:36,860 --> 00:35:42,440
here two cores right let's assume that

771
00:35:39,590 --> 00:35:45,500
both course you share the same data that

772
00:35:42,440 --> 00:35:49,670
maybe they access the same cache line at

773
00:35:45,500 --> 00:35:52,580
same information core one gets the data

774
00:35:49,670 --> 00:35:55,880
speculatively so it comes to the buffer

775
00:35:52,580 --> 00:35:57,860
and cache is not being modified so core

776
00:35:55,880 --> 00:36:01,040
to does not have any information that

777
00:35:57,860 --> 00:36:03,380
core one access the data right suppose

778
00:36:01,040 --> 00:36:07,040
Core two gets the data and modifies the

779
00:36:03,380 --> 00:36:09,620
data right what should happen to the

780
00:36:07,040 --> 00:36:12,470
data in the buffer should it become an

781
00:36:09,620 --> 00:36:15,350
invalid because co2 already read the

782
00:36:12,470 --> 00:36:18,230
data or should we say that core one

783
00:36:15,350 --> 00:36:21,410
actually read the data before core to so

784
00:36:18,230 --> 00:36:23,420
the data should be valid still so we

785
00:36:21,410 --> 00:36:26,359
have to make decisions as to saying that

786
00:36:23,420 --> 00:36:28,550
which one will be invalidate right so

787
00:36:26,360 --> 00:36:30,380
that's called memory ordering so we have

788
00:36:28,550 --> 00:36:32,690
to find out who read first right which

789
00:36:30,380 --> 00:36:34,940
order should we use so I think let me

790
00:36:32,690 --> 00:36:36,830
see alright so here is a time line if

791
00:36:34,940 --> 00:36:39,970
you want to think of so we have a

792
00:36:36,830 --> 00:36:43,430
speculative load first in core one and

793
00:36:39,970 --> 00:36:46,750
then some time later the second core

794
00:36:43,430 --> 00:36:46,750
read and modify the data

795
00:36:47,089 --> 00:36:55,410
and now the speculation was correct and

796
00:36:52,460 --> 00:36:57,839
Corwin says okay I'm going to use the

797
00:36:55,410 --> 00:36:59,759
data so I read the data before so all

798
00:36:57,839 --> 00:37:02,670
the instructions use my old data right

799
00:36:59,760 --> 00:37:05,069
but that should be invalidated because

800
00:37:02,670 --> 00:37:08,069
Co to modify the data already by the

801
00:37:05,069 --> 00:37:09,808
time so you have to kill all everything

802
00:37:08,069 --> 00:37:13,170
you have done because your data is no

803
00:37:09,809 --> 00:37:16,230
longer valid even though you read the

804
00:37:13,170 --> 00:37:19,289
data first right so you're going to

805
00:37:16,230 --> 00:37:21,359
cause a lot of performance loss because

806
00:37:19,289 --> 00:37:24,450
the way this solution this paper talks

807
00:37:21,359 --> 00:37:27,900
about is when you commit when you're

808
00:37:24,450 --> 00:37:29,490
ready to commit the load instruction so

809
00:37:27,900 --> 00:37:31,380
far nobody knows that you read the data

810
00:37:29,490 --> 00:37:33,950
right so you need to make everybody know

811
00:37:31,380 --> 00:37:37,230
that you read the data so the issue a

812
00:37:33,950 --> 00:37:39,000
normal load second time so first time

813
00:37:37,230 --> 00:37:41,970
you're specularity Lord you got the data

814
00:37:39,000 --> 00:37:45,000
into your buffer when you're ready to

815
00:37:41,970 --> 00:37:46,740
come in you again call you and

816
00:37:45,000 --> 00:37:49,170
instruction say I'm reading the data now

817
00:37:46,740 --> 00:37:52,200
right so that everybody can see it at

818
00:37:49,170 --> 00:37:54,510
that time and at that time the second

819
00:37:52,200 --> 00:37:57,149
core say hey you have a new data by the

820
00:37:54,510 --> 00:37:58,910
way read this data so now we had in will

821
00:37:57,150 --> 00:38:01,440
invalidate all of that data

822
00:37:58,910 --> 00:38:04,558
but today's processes don't do that

823
00:38:01,440 --> 00:38:07,529
today's processors because they read the

824
00:38:04,559 --> 00:38:12,029
data the data is already in the cache so

825
00:38:07,529 --> 00:38:15,359
call once read precedes Quartus

826
00:38:12,029 --> 00:38:18,510
modification so corwin is allowed to use

827
00:38:15,359 --> 00:38:20,720
the data because read before alright so

828
00:38:18,510 --> 00:38:24,660
today's architectures use a different

829
00:38:20,720 --> 00:38:26,250
memory ordering and this new idea will

830
00:38:24,660 --> 00:38:29,009
use a completely different memory

831
00:38:26,250 --> 00:38:31,140
ordering so which one will people accept

832
00:38:29,010 --> 00:38:32,490
because if you run on one system you

833
00:38:31,140 --> 00:38:34,348
might get different answer compared to

834
00:38:32,490 --> 00:38:36,660
running on a different system so you

835
00:38:34,349 --> 00:38:39,329
might have different ordering so people

836
00:38:36,660 --> 00:38:41,700
have to explore how this is gonna impact

837
00:38:39,329 --> 00:38:43,410
your correctness program correctness and

838
00:38:41,700 --> 00:38:46,500
all of those but this is a good solution

839
00:38:43,410 --> 00:38:50,430
so that we can make the lower

840
00:38:46,500 --> 00:38:52,589
specularity laws invisible actually we

841
00:38:50,430 --> 00:38:56,098
were working on it and then suddenly

842
00:38:52,589 --> 00:38:58,770
these people beat us to the deadline so

843
00:38:56,099 --> 00:39:00,840
they got the paper out then we did

844
00:38:58,770 --> 00:39:06,990
we had exactly the same solution we are

845
00:39:00,840 --> 00:39:10,500
exploring so so what we are going to

846
00:39:06,990 --> 00:39:12,450
look at is I don't know how many of you

847
00:39:10,500 --> 00:39:15,960
know the transactional memory models I

848
00:39:12,450 --> 00:39:17,640
was going to talk to dr. Ober gawe about

849
00:39:15,960 --> 00:39:19,650
saying that architecture also used the

850
00:39:17,640 --> 00:39:21,720
transaction models concurrency models

851
00:39:19,650 --> 00:39:24,180
and stuff like that how it is so

852
00:39:21,720 --> 00:39:26,490
basically what we want to do is look at

853
00:39:24,180 --> 00:39:29,160
a sequence of instructions as a single

854
00:39:26,490 --> 00:39:31,049
transaction right so all the

855
00:39:29,160 --> 00:39:34,230
instructions in that sequence will

856
00:39:31,050 --> 00:39:36,300
either commit or do not commit so they

857
00:39:34,230 --> 00:39:38,700
had we all committed together or none of

858
00:39:36,300 --> 00:39:40,800
them will be committed right so in

859
00:39:38,700 --> 00:39:43,200
architecture if we start doing that we

860
00:39:40,800 --> 00:39:46,020
can say that a sequence of instructions

861
00:39:43,200 --> 00:39:49,470
which are executed speculatively will be

862
00:39:46,020 --> 00:39:53,190
a transaction so if we find out that

863
00:39:49,470 --> 00:39:54,930
your Lord is invalid because somebody

864
00:39:53,190 --> 00:39:56,850
else modified the data we're going to

865
00:39:54,930 --> 00:39:59,310
kill all the speculative executed

866
00:39:56,850 --> 00:40:01,710
instruction so we're going to keep it in

867
00:39:59,310 --> 00:40:03,600
buffer so we are exploring saying that

868
00:40:01,710 --> 00:40:04,770
we want to extend that other paper where

869
00:40:03,600 --> 00:40:07,049
they're looking at on a single

870
00:40:04,770 --> 00:40:09,300
speculative instruction but we want to

871
00:40:07,050 --> 00:40:11,700
extend the whole thing as make it as a

872
00:40:09,300 --> 00:40:13,410
transaction so look at speculative

873
00:40:11,700 --> 00:40:16,020
execution convert that into a

874
00:40:13,410 --> 00:40:17,879
transaction model and find out how much

875
00:40:16,020 --> 00:40:19,619
performance is going to lose how the

876
00:40:17,880 --> 00:40:21,900
solution works so that's what we are

877
00:40:19,619 --> 00:40:24,980
working hopefully they won't do the same

878
00:40:21,900 --> 00:40:24,980
thing before we do so

879
00:40:25,460 --> 00:40:30,980
one final thing I just wanted to talk

880
00:40:27,869 --> 00:40:33,690
about Hardware level security issues

881
00:40:30,980 --> 00:40:36,630
most of today process particularly Xeon

882
00:40:33,690 --> 00:40:38,910
processors use hyper threading so hyper

883
00:40:36,630 --> 00:40:41,180
threading basing basically means on a

884
00:40:38,910 --> 00:40:44,580
single core they can mix multiple

885
00:40:41,180 --> 00:40:47,250
threads together and run it through the

886
00:40:44,580 --> 00:40:50,670
pipeline so you can have four threads

887
00:40:47,250 --> 00:40:53,130
sometimes you might see that 10 cores 40

888
00:40:50,670 --> 00:40:57,119
threads that means each core can run 4

889
00:40:53,130 --> 00:40:59,609
threads at a time and mix together those

890
00:40:57,119 --> 00:41:01,170
instructions when you mix those

891
00:40:59,609 --> 00:41:03,779
instruction there's a problem because

892
00:41:01,170 --> 00:41:06,690
they share certain tables they use TLB

893
00:41:03,780 --> 00:41:11,310
tables for example transaction lookaside

894
00:41:06,690 --> 00:41:12,480
buffer tables so now one thread running

895
00:41:11,310 --> 00:41:15,509
on the same core

896
00:41:12,480 --> 00:41:18,600
can try to get information about the TLB

897
00:41:15,510 --> 00:41:20,460
entries of some other thread so now we

898
00:41:18,600 --> 00:41:22,680
can actually reveal page table

899
00:41:20,460 --> 00:41:25,950
information which is very you know like

900
00:41:22,680 --> 00:41:28,770
dangerous so there are some attacks

901
00:41:25,950 --> 00:41:31,350
that's one of the reasons why coffee

902
00:41:28,770 --> 00:41:33,780
lake now it has two options

903
00:41:31,350 --> 00:41:36,350
latest Intel two options either you can

904
00:41:33,780 --> 00:41:39,570
buy one which enables hyper threading

905
00:41:36,350 --> 00:41:41,400
one which it doesn't so if you want a

906
00:41:39,570 --> 00:41:42,420
more secured by one without hyper

907
00:41:41,400 --> 00:41:44,460
threading you might lose some

908
00:41:42,420 --> 00:41:46,920
performance but at least you can avoid

909
00:41:44,460 --> 00:41:55,020
some of the attacks so they give you the

910
00:41:46,920 --> 00:41:57,420
option of doing that so so that's what I

911
00:41:55,020 --> 00:41:59,640
wanted to talk about today basically

912
00:41:57,420 --> 00:42:02,119
about what side channel attacks and

913
00:41:59,640 --> 00:42:04,400
hardware level means give you an idea

914
00:42:02,119 --> 00:42:07,260
what features of the architecture

915
00:42:04,400 --> 00:42:10,050
enables those attacks and what is the

916
00:42:07,260 --> 00:42:12,180
current thinking in protecting it by the

917
00:42:10,050 --> 00:42:15,630
way there's no software solution for

918
00:42:12,180 --> 00:42:18,270
this you cannot prevent these attacks by

919
00:42:15,630 --> 00:42:20,280
simply using software so we have to

920
00:42:18,270 --> 00:42:21,930
change the hardware so intel has to get

921
00:42:20,280 --> 00:42:25,800
rid of all of those over the period of

922
00:42:21,930 --> 00:42:28,859
time until that time any of Intel

923
00:42:25,800 --> 00:42:30,390
processor is prone to those attacks so

924
00:42:28,859 --> 00:42:32,430
there's no software solution for this

925
00:42:30,390 --> 00:42:35,779
you know so so internal knows that

926
00:42:32,430 --> 00:42:35,779
that's why they're working on yourself

927
00:42:36,860 --> 00:42:40,369
[Applause]

928
00:42:42,410 --> 00:42:48,529
depress and then push to ask a question

929
00:42:51,200 --> 00:42:57,270
I have one question I mean it's not

930
00:42:55,530 --> 00:42:59,270
really a software a solution but it's a

931
00:42:57,270 --> 00:43:04,009
solution without changing the hardware

932
00:42:59,270 --> 00:43:08,750
which is basically you cannot allow

933
00:43:04,010 --> 00:43:12,090
untrusted code to run on your hardware

934
00:43:08,750 --> 00:43:14,369
when you're running something that that

935
00:43:12,090 --> 00:43:17,790
is that you're concerned about that

936
00:43:14,369 --> 00:43:20,190
basically you're saying all code is

937
00:43:17,790 --> 00:43:22,500
trusted right so you attack a score can

938
00:43:20,190 --> 00:43:24,210
be trusted to multiple because you don't

939
00:43:22,500 --> 00:43:26,130
know all they're doing is have been

940
00:43:24,210 --> 00:43:28,289
loading and unloading data right

941
00:43:26,130 --> 00:43:32,789
well that's what I mean it's it's not

942
00:43:28,289 --> 00:43:38,549
that attackers code is you know the it's

943
00:43:32,789 --> 00:43:41,789
doing it is doing something you know the

944
00:43:38,549 --> 00:43:43,859
question is who's it trusted by I mean

945
00:43:41,789 --> 00:43:46,319
it's like if I have all my own code that

946
00:43:43,859 --> 00:43:49,470
only I have created I've checked it out

947
00:43:46,319 --> 00:43:51,569
and nothing else can run on the

948
00:43:49,470 --> 00:43:53,308
processor at the time then this

949
00:43:51,569 --> 00:43:55,769
shouldn't so I can write a matrix

950
00:43:53,309 --> 00:43:57,660
multiplication and at the very beginning

951
00:43:55,769 --> 00:44:01,049
I can create a loop all it does it

952
00:43:57,660 --> 00:44:04,200
clears all my huge matrices right what's

953
00:44:01,049 --> 00:44:07,170
happening to the cache then so my code

954
00:44:04,200 --> 00:44:09,180
is perfectly valid code because I'm

955
00:44:07,170 --> 00:44:12,420
writing this huge matrix multiplication

956
00:44:09,180 --> 00:44:16,470
with multiple million by million and at

957
00:44:12,420 --> 00:44:18,150
the very beginning I cleared my matrices

958
00:44:16,470 --> 00:44:20,459
that's enough to clear all the caches

959
00:44:18,150 --> 00:44:23,970
yeah so in other words it's it's very

960
00:44:20,460 --> 00:44:26,729
difficult to validate that code would

961
00:44:23,970 --> 00:44:28,890
not be performing this task right right

962
00:44:26,729 --> 00:44:31,189
so attack that's what attackers use

963
00:44:28,890 --> 00:44:33,239
because you cannot none of the

964
00:44:31,190 --> 00:44:37,499
verification techniques you have in

965
00:44:33,239 --> 00:44:39,930
software will be able to say with

966
00:44:37,499 --> 00:44:44,399
confidence that this could potentially

967
00:44:39,930 --> 00:44:47,038
in a vsi channel attack so that's why I

968
00:44:44,400 --> 00:44:48,900
was talking to Intel intercept is there

969
00:44:47,039 --> 00:44:52,319
a way we can detect a side channel

970
00:44:48,900 --> 00:44:54,599
attack right the only thing you can do

971
00:44:52,319 --> 00:44:56,339
side channel attack is if the side

972
00:44:54,599 --> 00:44:58,559
channel attack is causing more cache

973
00:44:56,339 --> 00:45:01,589
misses maybe you can say that there's

974
00:44:58,559 --> 00:45:03,359
something wrong here right normally your

975
00:45:01,589 --> 00:45:07,170
system should not cause this many cache

976
00:45:03,359 --> 00:45:08,759
misses and suddenly when two programs

977
00:45:07,170 --> 00:45:10,229
are running is causing a lot of cache

978
00:45:08,759 --> 00:45:12,660
misses so there's something suspicious

979
00:45:10,229 --> 00:45:16,348
right that's all I can say beyond that

980
00:45:12,660 --> 00:45:18,719
if you don't know what's happening so so

981
00:45:16,349 --> 00:45:20,339
yeah Intel was looking at is there a way

982
00:45:18,719 --> 00:45:22,440
to find that there is a side channel

983
00:45:20,339 --> 00:45:26,130
attack being in happening right now no

984
00:45:22,440 --> 00:45:31,619
so it it does require though that you

985
00:45:26,130 --> 00:45:34,109
have that you have an another thread or

986
00:45:31,619 --> 00:45:37,049
process running on the processor before

987
00:45:34,109 --> 00:45:39,239
use yours has completely finished its

988
00:45:37,049 --> 00:45:40,120
task that's that's one of the reasons

989
00:45:39,239 --> 00:45:41,980
why hyper

990
00:45:40,120 --> 00:45:43,650
reading some people now saying that I

991
00:45:41,980 --> 00:45:45,550
don't want to use a hyper-threading yeah

992
00:45:43,650 --> 00:45:46,990
yeah this this doesn't require

993
00:45:45,550 --> 00:45:48,520
hyper-threading but it does require

994
00:45:46,990 --> 00:45:51,549
something else running on the same

995
00:45:48,520 --> 00:45:52,900
processor it doesn't have to be in the

996
00:45:51,550 --> 00:45:56,740
same process I remember there's

997
00:45:52,900 --> 00:46:00,430
something called C flush which evicts

998
00:45:56,740 --> 00:46:02,080
all the cache lines everyplace okay so

999
00:46:00,430 --> 00:46:04,480
it's not even on the same process or

1000
00:46:02,080 --> 00:46:06,040
it's on the same as long as the

1001
00:46:04,480 --> 00:46:08,950
multi-core clears all the caches

1002
00:46:06,040 --> 00:46:11,890
well no it's I'm not saying not same

1003
00:46:08,950 --> 00:46:14,980
core multi-core processors we are

1004
00:46:11,890 --> 00:46:17,770
running on a different core you run it's

1005
00:46:14,980 --> 00:46:19,990
not but but but the processor itself if

1006
00:46:17,770 --> 00:46:22,630
I run complete that that I have a

1007
00:46:19,990 --> 00:46:23,859
completely independent processor but

1008
00:46:22,630 --> 00:46:26,110
there's nothing running on any of the

1009
00:46:23,860 --> 00:46:28,450
other cores then why would you want a

1010
00:46:26,110 --> 00:46:31,930
processor with that many cores and not

1011
00:46:28,450 --> 00:46:33,580
use them right yeah exactly and I'm just

1012
00:46:31,930 --> 00:46:35,169
saying that you know from Intel's point

1013
00:46:33,580 --> 00:46:36,490
of view maybe these you know if that's

1014
00:46:35,170 --> 00:46:39,550
the solution then you sell more

1015
00:46:36,490 --> 00:46:41,080
processors yeah you know that's why if

1016
00:46:39,550 --> 00:46:43,930
you're running you know you're the only

1017
00:46:41,080 --> 00:46:46,810
one user yeah I have 32 course but among

1018
00:46:43,930 --> 00:46:49,390
running one basically that's the only

1019
00:46:46,810 --> 00:46:52,270
solution at this point is that you have

1020
00:46:49,390 --> 00:46:54,160
to be the one that's trying to do is all

1021
00:46:52,270 --> 00:46:56,310
these different solutions saying that I

1022
00:46:54,160 --> 00:46:58,870
want to make sure that secure

1023
00:46:56,310 --> 00:47:01,270
applications have reserved cache lines

1024
00:46:58,870 --> 00:47:03,640
even though not all the attacks are you

1025
00:47:01,270 --> 00:47:07,390
know prevented some attacks are

1026
00:47:03,640 --> 00:47:09,879
prevented plus most of the UNIX they

1027
00:47:07,390 --> 00:47:12,129
have the deduplication for example when

1028
00:47:09,880 --> 00:47:14,620
you have two programs running they share

1029
00:47:12,130 --> 00:47:18,670
some tables right some pages you know

1030
00:47:14,620 --> 00:47:20,319
common libraries and so on the reason

1031
00:47:18,670 --> 00:47:22,480
why they do that is you don't want to

1032
00:47:20,320 --> 00:47:24,310
duplicate and waste memory that's forgot

1033
00:47:22,480 --> 00:47:27,400
that's what it's called deduplication

1034
00:47:24,310 --> 00:47:29,980
eliminate duplication but there's a flag

1035
00:47:27,400 --> 00:47:33,730
in Linux saying that I want duplicate

1036
00:47:29,980 --> 00:47:35,620
copies so eliminate deduplication so

1037
00:47:33,730 --> 00:47:38,410
that you could have a flag to say that I

1038
00:47:35,620 --> 00:47:39,520
don't want to use somebody else and I

1039
00:47:38,410 --> 00:47:42,430
don't want to share somebody else a

1040
00:47:39,520 --> 00:47:44,200
libraries give me my own copies right so

1041
00:47:42,430 --> 00:47:46,450
you're willing to lose some performance

1042
00:47:44,200 --> 00:47:48,930
because of that so there are some people

1043
00:47:46,450 --> 00:47:52,299
thinking about in how do we do this

1044
00:47:48,930 --> 00:47:53,848
sacrifice some performance but try to

1045
00:47:52,300 --> 00:47:57,250
mitigate there

1046
00:47:53,849 --> 00:47:59,410
so but the Linux solution when they

1047
00:47:57,250 --> 00:48:01,990
first came out in as soon as Spectre

1048
00:47:59,410 --> 00:48:04,058
attack of the revealed Linux said that

1049
00:48:01,990 --> 00:48:05,470
you can use this then then immediately

1050
00:48:04,059 --> 00:48:12,549
said oh we're losing forty percent

1051
00:48:05,470 --> 00:48:14,348
performance is not acceptable but they

1052
00:48:12,549 --> 00:48:35,410
said that the only solution is change

1053
00:48:14,349 --> 00:48:38,559
Hardware like even if you lose some

1054
00:48:35,410 --> 00:48:42,940
performance like all these attacks will

1055
00:48:38,559 --> 00:48:45,579
not work right like for the meltdown

1056
00:48:42,940 --> 00:48:49,900
attack it just had a software fix of

1057
00:48:45,579 --> 00:48:52,329
where you just make the user

1058
00:48:49,900 --> 00:48:54,250
applications and those system

1059
00:48:52,329 --> 00:48:56,650
applications have like completely

1060
00:48:54,250 --> 00:49:01,720
different memory so this should work

1061
00:48:56,650 --> 00:49:04,420
right of what kind of attacks will this

1062
00:49:01,720 --> 00:49:06,480
not stop but because speculation you

1063
00:49:04,420 --> 00:49:11,079
cannot prevent the speculation where

1064
00:49:06,480 --> 00:49:13,750
even secure cache lines will be brought

1065
00:49:11,079 --> 00:49:15,400
into the cache right so the data will be

1066
00:49:13,750 --> 00:49:17,109
brought into the cache even though

1067
00:49:15,400 --> 00:49:20,049
you're not allowed to access this you

1068
00:49:17,109 --> 00:49:22,720
can illegally try to get the data system

1069
00:49:20,049 --> 00:49:24,369
will kill your abort your program but

1070
00:49:22,720 --> 00:49:27,038
the data is already brought into the

1071
00:49:24,369 --> 00:49:29,619
cache so that's that's the reason behind

1072
00:49:27,039 --> 00:49:32,289
speculative you know attack and

1073
00:49:29,619 --> 00:49:34,059
inspector melt on those cannot be

1074
00:49:32,289 --> 00:49:36,160
prevented it's going to be more

1075
00:49:34,059 --> 00:49:39,160
difficult it takes longer time to do

1076
00:49:36,160 --> 00:49:41,680
that but you cannot prevent unless you

1077
00:49:39,160 --> 00:49:44,980
modify the speculation somehow so we

1078
00:49:41,680 --> 00:49:47,230
have to address the idea of if I'm doing

1079
00:49:44,980 --> 00:49:49,480
speculative execution and if I'm going

1080
00:49:47,230 --> 00:49:51,789
to read the data should I reveal that

1081
00:49:49,480 --> 00:49:53,140
data or not right so right now you're

1082
00:49:51,789 --> 00:49:54,819
revealing the data because you're

1083
00:49:53,140 --> 00:49:56,319
bringing into the cache and that's the

1084
00:49:54,819 --> 00:49:58,690
reason why the last two slides are

1085
00:49:56,319 --> 00:50:01,089
talked about making the speculative

1086
00:49:58,690 --> 00:50:03,849
execution silent mystically the load

1087
00:50:01,089 --> 00:50:06,759
silent that means if you bring the data

1088
00:50:03,849 --> 00:50:07,250
in a specularity more don't change

1089
00:50:06,760 --> 00:50:10,880
anything

1090
00:50:07,250 --> 00:50:12,830
some state so actually what we want to

1091
00:50:10,880 --> 00:50:16,940
do is formalize this saying that in any

1092
00:50:12,830 --> 00:50:19,400
hardware if I do something what changes

1093
00:50:16,940 --> 00:50:22,880
are observable in the system state right

1094
00:50:19,400 --> 00:50:25,070
so what I want to see is if I do

1095
00:50:22,880 --> 00:50:27,290
something speculative I want to make

1096
00:50:25,070 --> 00:50:30,020
sure that my state changes are not

1097
00:50:27,290 --> 00:50:32,090
observable observable by other people so

1098
00:50:30,020 --> 00:50:34,640
how do we do that how do we design such

1099
00:50:32,090 --> 00:50:37,730
that if I do something to speed up I

1100
00:50:34,640 --> 00:50:40,279
don't want to reveal that I'm doing that

1101
00:50:37,730 --> 00:50:42,170
I don't want that information to be

1102
00:50:40,280 --> 00:50:44,870
revealed so what we're looking at what

1103
00:50:42,170 --> 00:50:46,670
are all these state changes for example

1104
00:50:44,870 --> 00:50:50,450
I didn't talk about there one of the

1105
00:50:46,670 --> 00:50:52,910
things nobody has talked about so far is

1106
00:50:50,450 --> 00:50:54,950
performance counters right so

1107
00:50:52,910 --> 00:50:56,660
performance counters as I said counts

1108
00:50:54,950 --> 00:50:58,399
how many times your cache misses or you

1109
00:50:56,660 --> 00:51:00,440
can even count how many times the branch

1110
00:50:58,400 --> 00:51:02,720
instruction is executed how many times

1111
00:51:00,440 --> 00:51:05,960
of loading multiply instructions

1112
00:51:02,720 --> 00:51:07,279
executed right even though I had the

1113
00:51:05,960 --> 00:51:09,710
information that I did something

1114
00:51:07,280 --> 00:51:11,540
speculative your performance counters

1115
00:51:09,710 --> 00:51:14,330
are still counting how many times your

1116
00:51:11,540 --> 00:51:16,130
load instruction was executed so what we

1117
00:51:14,330 --> 00:51:18,110
want to do is make sure that this

1118
00:51:16,130 --> 00:51:21,050
speculated load doesn't even change this

1119
00:51:18,110 --> 00:51:24,560
performance counter right so we have to

1120
00:51:21,050 --> 00:51:26,920
think in terms of what state changes are

1121
00:51:24,560 --> 00:51:31,990
happening whenever I execute something I

1122
00:51:26,920 --> 00:51:34,640
want to make that as you know silent as

1123
00:51:31,990 --> 00:51:36,560
non-observable as possible so the

1124
00:51:34,640 --> 00:51:38,390
attacker cannot use side channel attacks

1125
00:51:36,560 --> 00:51:40,490
remember side channel attack means

1126
00:51:38,390 --> 00:51:43,190
observing something I want to make my

1127
00:51:40,490 --> 00:51:50,209
speculating speculative execution as

1128
00:51:43,190 --> 00:51:58,030
unobservable as possible any other

1129
00:51:50,210 --> 00:52:01,370
questions how do I catch my flight

1130
00:51:58,030 --> 00:52:04,240
but please send an email and any other

1131
00:52:01,370 --> 00:52:04,240
questions you may have

1132
00:52:16,510 --> 00:52:18,570
you

