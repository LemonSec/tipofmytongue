1
00:00:14,680 --> 00:00:23,980
our first technical talk today is one of

2
00:00:19,720 --> 00:00:26,340
our our PhD candidates Brendan Sultan

3
00:00:23,980 --> 00:00:29,200
firm azio in computer science and

4
00:00:26,340 --> 00:00:31,539
brendan is I've had the opportunity to

5
00:00:29,200 --> 00:00:33,790
travel with them and I find his talk and

6
00:00:31,539 --> 00:00:37,540
it's why I sought him out to be one of

7
00:00:33,790 --> 00:00:39,670
our presenters today he's also won a ton

8
00:00:37,540 --> 00:00:41,949
of awards recently and most recently

9
00:00:39,670 --> 00:00:44,489
probably most prestigious as that

10
00:00:41,949 --> 00:00:47,110
brendan has been named one of the two

11
00:00:44,489 --> 00:00:50,078
semantic research fellows for this next

12
00:00:47,110 --> 00:00:55,050
year so congratulations and i'll let you

13
00:00:50,079 --> 00:00:55,050
talk about your research thank you Joe

14
00:01:05,549 --> 00:01:11,409
okay so like Jill said my name is

15
00:01:09,220 --> 00:01:13,840
brendan salta formaggio I'm a PhD

16
00:01:11,409 --> 00:01:15,880
candidate and the cs department here at

17
00:01:13,840 --> 00:01:17,409
Purdue today I'm going to be talking

18
00:01:15,880 --> 00:01:19,449
about some cutting-edge research that

19
00:01:17,409 --> 00:01:22,119
I've been doing in the field of cyber

20
00:01:19,450 --> 00:01:24,220
forensics and specifically along lines

21
00:01:22,119 --> 00:01:26,500
of automatically recovering human

22
00:01:24,220 --> 00:01:28,408
understandable evidence from memory

23
00:01:26,500 --> 00:01:31,149
images of a system under investigation

24
00:01:28,409 --> 00:01:33,070
so most of us when we think of cyber

25
00:01:31,149 --> 00:01:35,860
forensics maybe the first thing to come

26
00:01:33,070 --> 00:01:38,529
to mind is carving old files off of

27
00:01:35,860 --> 00:01:42,210
dusty hard drives right well that's not

28
00:01:38,530 --> 00:01:45,610
this talk because about 10 years ago

29
00:01:42,210 --> 00:01:47,710
investigators there we go investigators

30
00:01:45,610 --> 00:01:49,780
and researchers realize that there is a

31
00:01:47,710 --> 00:01:52,389
wealth of digital evidence that gets

32
00:01:49,780 --> 00:01:54,130
left behind in the RAM of a system when

33
00:01:52,390 --> 00:01:56,409
you're investigating it and this can be

34
00:01:54,130 --> 00:01:59,020
anything from what processes are running

35
00:01:56,409 --> 00:02:01,390
on the machine to even some executing

36
00:01:59,020 --> 00:02:03,520
malware that might be causing more

37
00:02:01,390 --> 00:02:05,440
trouble than the actual criminal to

38
00:02:03,520 --> 00:02:07,539
things like encryption keys for whole

39
00:02:05,440 --> 00:02:09,820
disk encryption and then all of that

40
00:02:07,539 --> 00:02:11,799
application data that's being used at

41
00:02:09,820 --> 00:02:15,280
that time right your browser histories

42
00:02:11,799 --> 00:02:18,190
your chat logs and so much more but the

43
00:02:15,280 --> 00:02:19,959
challenge is as a cyber investigator how

44
00:02:18,190 --> 00:02:22,859
do you recover all of this evidence

45
00:02:19,959 --> 00:02:25,180
that's frozen in a computer's memory

46
00:02:22,859 --> 00:02:26,530
well when we think of what's in memory

47
00:02:25,180 --> 00:02:29,230
usually the first thing to come to mind

48
00:02:26,530 --> 00:02:30,700
is data structures right programming 101

49
00:02:29,230 --> 00:02:32,798
you make some structures and that's

50
00:02:30,700 --> 00:02:34,450
pretty much how all data in memory is

51
00:02:32,799 --> 00:02:37,269
stored organized into some data

52
00:02:34,450 --> 00:02:39,880
structures so investigators first need

53
00:02:37,269 --> 00:02:42,310
to find and recover the data structures

54
00:02:39,880 --> 00:02:45,120
which store the evidence that they're

55
00:02:42,310 --> 00:02:47,440
looking for now this is usually done by

56
00:02:45,120 --> 00:02:49,810
immediately collecting a memory image

57
00:02:47,440 --> 00:02:51,609
that's a byte for byte copy of the

58
00:02:49,810 --> 00:02:54,220
physical RAM on the device you're

59
00:02:51,609 --> 00:02:56,530
investigating and then returning to the

60
00:02:54,220 --> 00:02:58,150
forensics lab to use memory forensics

61
00:02:56,530 --> 00:03:01,150
tools to find these data structures

62
00:02:58,150 --> 00:03:02,799
which it within that memory image to do

63
00:03:01,150 --> 00:03:05,410
this you first pick the data structure

64
00:03:02,799 --> 00:03:07,209
you're looking for you build a signature

65
00:03:05,410 --> 00:03:09,280
for that data structure that's just a

66
00:03:07,209 --> 00:03:11,200
set of constraints that let you find

67
00:03:09,280 --> 00:03:13,409
that data structure in all of that raw

68
00:03:11,200 --> 00:03:16,329
memory that you have in the image and

69
00:03:13,409 --> 00:03:18,819
then a memory forensics tool takes that

70
00:03:16,330 --> 00:03:20,879
signature in and it's going to scan

71
00:03:18,819 --> 00:03:23,379
through every offset in the memory image

72
00:03:20,879 --> 00:03:28,030
finding instances of those data

73
00:03:23,379 --> 00:03:30,638
structures that you're looking for so

74
00:03:28,030 --> 00:03:32,650
prior to my work this was very much the

75
00:03:30,639 --> 00:03:35,500
state of the art every memory forensics

76
00:03:32,650 --> 00:03:38,170
tool out there focused on recovering raw

77
00:03:35,500 --> 00:03:40,840
instances of individual data structures

78
00:03:38,170 --> 00:03:42,700
from memory images and that works pretty

79
00:03:40,840 --> 00:03:45,819
well for a long time if you are looking

80
00:03:42,700 --> 00:03:47,530
for plain text or self-contained fields

81
00:03:45,819 --> 00:03:50,230
within those data structures like a

82
00:03:47,530 --> 00:03:52,569
password field in a user account

83
00:03:50,230 --> 00:03:55,268
structure right but as we're going to

84
00:03:52,569 --> 00:03:57,578
see in this talk focusing on only these

85
00:03:55,269 --> 00:04:00,219
plain text fields in simple data

86
00:03:57,579 --> 00:04:01,810
structures is severely limiting the

87
00:04:00,219 --> 00:04:04,569
amount of evidence that you can recover

88
00:04:01,810 --> 00:04:05,650
from a memory image and so I'm start

89
00:04:04,569 --> 00:04:07,418
things off a little different this

90
00:04:05,650 --> 00:04:09,489
morning actually with a crime story

91
00:04:07,419 --> 00:04:11,650
that's based on some true events that

92
00:04:09,489 --> 00:04:14,139
happened here at Purdue University let

93
00:04:11,650 --> 00:04:16,570
me jump out real quick and go to the

94
00:04:14,139 --> 00:04:24,820
video player because like we said

95
00:04:16,570 --> 00:04:27,340
Microsoft was not cooperating today okay

96
00:04:24,820 --> 00:04:28,870
so about two years ago there was a group

97
00:04:27,340 --> 00:04:30,638
of students who were found changing

98
00:04:28,870 --> 00:04:32,349
grades for themselves as well as

99
00:04:30,639 --> 00:04:34,630
accomplices who paid them for this

100
00:04:32,349 --> 00:04:36,699
service so let's imagine we're watching

101
00:04:34,630 --> 00:04:38,919
this cyber crime unfold the criminal has

102
00:04:36,699 --> 00:04:40,570
access to this official grade report and

103
00:04:38,919 --> 00:04:42,789
they're in the process of changing

104
00:04:40,570 --> 00:04:44,940
grades for themselves as well as other

105
00:04:42,789 --> 00:04:48,370
people who are involved in this crime

106
00:04:44,940 --> 00:04:51,280
but before this would be awesome hacker

107
00:04:48,370 --> 00:04:53,680
has a chance to save the file law

108
00:04:51,280 --> 00:04:55,539
enforcement agents arrive right and the

109
00:04:53,680 --> 00:04:57,759
first thing they're going to do is image

110
00:04:55,539 --> 00:04:59,380
the computer's memory sees the machine

111
00:04:57,759 --> 00:05:01,210
as evidence and then return to the

112
00:04:59,380 --> 00:05:04,180
forensics lab to recover evidence of

113
00:05:01,210 --> 00:05:06,489
this crime now notice the only evidence

114
00:05:04,180 --> 00:05:08,919
that we have at this point of all of the

115
00:05:06,490 --> 00:05:11,229
accomplices involved in this crime is in

116
00:05:08,919 --> 00:05:12,909
the memory of that computer because he

117
00:05:11,229 --> 00:05:15,400
hasn't saved the file that he was

118
00:05:12,909 --> 00:05:17,440
editing yet so the grade report that's

119
00:05:15,400 --> 00:05:18,969
on disk still shows the original grades

120
00:05:17,440 --> 00:05:20,830
and of course you're going to get this

121
00:05:18,969 --> 00:05:24,370
guy into the university police station

122
00:05:20,830 --> 00:05:28,020
and he's not going to be talking so if

123
00:05:24,370 --> 00:05:28,020
we can jump back to the slides

124
00:05:36,650 --> 00:05:41,299
so like I said the state of the art

125
00:05:38,750 --> 00:05:43,550
before my work was recovering these raw

126
00:05:41,300 --> 00:05:45,620
instances of individual data structures

127
00:05:43,550 --> 00:05:48,350
from a memory image now believe it or

128
00:05:45,620 --> 00:05:51,830
not this is that PDF that we just saw

129
00:05:48,350 --> 00:05:54,830
being edited in raw data structure form

130
00:05:51,830 --> 00:05:56,810
you can see the problem just because

131
00:05:54,830 --> 00:05:59,000
investigators can recover raw data

132
00:05:56,810 --> 00:06:01,009
structures doesn't help them understand

133
00:05:59,000 --> 00:06:02,810
the content of those data structures you

134
00:06:01,009 --> 00:06:05,750
can't see what was edited in this PDF

135
00:06:02,810 --> 00:06:07,820
it's all encoded data and the same

136
00:06:05,750 --> 00:06:09,440
problem arises for all kinds of

137
00:06:07,820 --> 00:06:11,419
different evidence that programs are

138
00:06:09,440 --> 00:06:14,060
interacting with things like images

139
00:06:11,419 --> 00:06:16,130
documents basically any kind of encoded

140
00:06:14,060 --> 00:06:18,139
or formatted data is not going to be

141
00:06:16,130 --> 00:06:21,710
plain text or human understandable when

142
00:06:18,139 --> 00:06:23,780
it's in raw memory so we define this as

143
00:06:21,710 --> 00:06:25,520
the content reverse engineering

144
00:06:23,780 --> 00:06:28,039
challenge in memory forensics in a

145
00:06:25,520 --> 00:06:31,039
recent paper of mine overcomes this

146
00:06:28,039 --> 00:06:34,039
challenge by making the observation that

147
00:06:31,039 --> 00:06:36,139
if an application defines a data

148
00:06:34,039 --> 00:06:39,349
structure like that PDF data structure

149
00:06:36,139 --> 00:06:42,229
the application must also define some

150
00:06:39,349 --> 00:06:44,840
printing or rendering logic for that

151
00:06:42,229 --> 00:06:46,880
data structure right so for instance we

152
00:06:44,840 --> 00:06:49,099
have that PDF data structure in memory

153
00:06:46,880 --> 00:06:51,229
the program that defines that data

154
00:06:49,099 --> 00:06:53,360
structure must also know how to display

155
00:06:51,229 --> 00:06:56,539
the PDF it has to know how to save the

156
00:06:53,360 --> 00:06:59,389
PDF to a file so why can't we reuse that

157
00:06:56,539 --> 00:07:02,810
logic to give investigators access to

158
00:06:59,389 --> 00:07:05,659
the content of that PDF so let's imagine

159
00:07:02,810 --> 00:07:07,310
that this simple program code is the PDF

160
00:07:05,659 --> 00:07:09,560
editor we were looking at right it

161
00:07:07,310 --> 00:07:11,300
defines that struct PDF that we're

162
00:07:09,560 --> 00:07:13,370
interested in recovering and then the

163
00:07:11,300 --> 00:07:15,620
first line loads in a PDF file it

164
00:07:13,370 --> 00:07:17,510
initializes that data structure the main

165
00:07:15,620 --> 00:07:19,070
loop executes while the user make some

166
00:07:17,510 --> 00:07:22,130
edits and then finally we have this

167
00:07:19,070 --> 00:07:24,380
saved PDF file function now notice how

168
00:07:22,130 --> 00:07:28,250
this works it takes as input that

169
00:07:24,380 --> 00:07:29,960
in-memory raw PDF structure it formats

170
00:07:28,250 --> 00:07:32,060
it it turns it into a nice human

171
00:07:29,960 --> 00:07:34,310
understandable PDF file and then saves

172
00:07:32,060 --> 00:07:38,180
that file to disk the idea behind

173
00:07:34,310 --> 00:07:41,630
discreet and what we did was remove that

174
00:07:38,180 --> 00:07:44,120
piece of code that actually renders the

175
00:07:41,630 --> 00:07:47,360
PDF data from memory and turn it into

176
00:07:44,120 --> 00:07:49,010
what we call a scanner plus render the

177
00:07:47,360 --> 00:07:50,510
intuition behind a scanner plus render

178
00:07:49,010 --> 00:07:52,190
is that this code

179
00:07:50,510 --> 00:07:54,349
this formatting code must be very

180
00:07:52,190 --> 00:07:56,840
complex it has strong assumptions on the

181
00:07:54,350 --> 00:07:59,450
input that PDF data structure so when we

182
00:07:56,840 --> 00:08:02,119
present it with just random memory it's

183
00:07:59,450 --> 00:08:05,210
going to cause that code to crash but if

184
00:08:02,120 --> 00:08:07,790
we scan through every offset in a memory

185
00:08:05,210 --> 00:08:10,460
image eventually we'll hit that PDF data

186
00:08:07,790 --> 00:08:12,590
structure we're looking for and for that

187
00:08:10,460 --> 00:08:15,349
this function is going to output the

188
00:08:12,590 --> 00:08:17,119
natural application output that would

189
00:08:15,350 --> 00:08:22,010
have been created for that PDF data

190
00:08:17,120 --> 00:08:23,780
structure in memory make sense so I like

191
00:08:22,010 --> 00:08:26,150
to show rather than tell so I'm going to

192
00:08:23,780 --> 00:08:29,960
give you another video that actually

193
00:08:26,150 --> 00:08:33,140
shows discrete in operation we're

194
00:08:29,960 --> 00:08:34,789
covering that PDF I'm a skip past the

195
00:08:33,140 --> 00:08:38,240
first part of this video is just

196
00:08:34,789 --> 00:08:40,610
isolating that scanner plus render logic

197
00:08:38,240 --> 00:08:41,960
the second half is actually doing the

198
00:08:40,610 --> 00:08:44,660
scanning and that's what I'm going to

199
00:08:41,960 --> 00:08:46,340
imma skip to hear okay so like I said

200
00:08:44,660 --> 00:08:48,680
the first part just isolated that

201
00:08:46,340 --> 00:08:50,240
scanner plus render within the binary I

202
00:08:48,680 --> 00:08:51,650
should note that these are binary

203
00:08:50,240 --> 00:08:53,420
techniques that I'm going to be talking

204
00:08:51,650 --> 00:08:55,790
about today we don't require any source

205
00:08:53,420 --> 00:08:57,709
code in order to do this so we've

206
00:08:55,790 --> 00:08:59,209
isolated that scanner plus render and

207
00:08:57,710 --> 00:09:01,610
now we're going to use discrete to scan

208
00:08:59,210 --> 00:09:03,980
the memory image discreet just requires

209
00:09:01,610 --> 00:09:05,570
that we execute the program until we get

210
00:09:03,980 --> 00:09:07,880
to that scanner plus renderer component

211
00:09:05,570 --> 00:09:09,170
and then it's going to take over and

212
00:09:07,880 --> 00:09:12,080
it's going to begin the memory image

213
00:09:09,170 --> 00:09:13,550
scan so here discretes taken over it

214
00:09:12,080 --> 00:09:15,860
takes about 30 minutes to get through

215
00:09:13,550 --> 00:09:17,599
every single offset in that giant memory

216
00:09:15,860 --> 00:09:25,910
image and then when it's done we can

217
00:09:17,600 --> 00:09:27,650
look over the results as expected

218
00:09:25,910 --> 00:09:30,079
there's only one of course because we're

219
00:09:27,650 --> 00:09:32,240
all editing one PDF and we can see in

220
00:09:30,080 --> 00:09:34,820
fact it is the PDF from memory that has

221
00:09:32,240 --> 00:09:36,320
the higher grades on it so now

222
00:09:34,820 --> 00:09:38,270
investigators have a very easy time

223
00:09:36,320 --> 00:09:40,490
figuring out who was involved in this

224
00:09:38,270 --> 00:09:42,650
crime beyond the one guy who is changing

225
00:09:40,490 --> 00:09:44,330
grades and recall without discreet this

226
00:09:42,650 --> 00:09:45,980
is the best that existing techniques

227
00:09:44,330 --> 00:09:48,080
would have given you just these raw data

228
00:09:45,980 --> 00:09:54,110
structures that totally unintelligible

229
00:09:48,080 --> 00:09:57,950
the human investigators so we didn't

230
00:09:54,110 --> 00:10:00,530
just already get back to the slides so

231
00:09:57,950 --> 00:10:02,420
we didn't just test discrete on PDFs we

232
00:10:00,530 --> 00:10:04,130
tested it on a bunch of different types

233
00:10:02,420 --> 00:10:06,439
of data from memory that all

234
00:10:04,130 --> 00:10:07,580
require complex decoding functions if

235
00:10:06,440 --> 00:10:09,890
you read the paper there's even more

236
00:10:07,580 --> 00:10:11,930
things like images from a bunch of

237
00:10:09,890 --> 00:10:13,880
different image processing programs a

238
00:10:11,930 --> 00:10:15,800
screenshot like if you hit print screen

239
00:10:13,880 --> 00:10:18,260
you can actually recover those out of

240
00:10:15,800 --> 00:10:21,770
memory oh this is a good test case these

241
00:10:18,260 --> 00:10:23,870
are in memory request logs from a web

242
00:10:21,770 --> 00:10:25,880
server these have yet to be flushed to

243
00:10:23,870 --> 00:10:27,470
your request log on disk they're just

244
00:10:25,880 --> 00:10:29,390
sitting in memory and of course they're

245
00:10:27,470 --> 00:10:30,620
all encoded right with integers you'd

246
00:10:29,390 --> 00:10:33,560
never understand it but here

247
00:10:30,620 --> 00:10:37,310
investigators get the nice IP addresses

248
00:10:33,560 --> 00:10:39,050
and browsers they're using pdfs like we

249
00:10:37,310 --> 00:10:41,420
saw before is is another interesting

250
00:10:39,050 --> 00:10:43,609
case so top you know you get the system

251
00:10:41,420 --> 00:10:45,890
resource usage for all the processes on

252
00:10:43,610 --> 00:10:48,710
a Linux system so when you run top you

253
00:10:45,890 --> 00:10:50,750
may be only seen 15 20 processes on the

254
00:10:48,710 --> 00:10:53,620
screen but when we ran discrete we

255
00:10:50,750 --> 00:10:56,210
actually found 382 different processes

256
00:10:53,620 --> 00:10:58,310
that's because although top only shows

257
00:10:56,210 --> 00:10:59,930
you 15 or 20 on screen it actually

258
00:10:58,310 --> 00:11:02,209
allocates those data structures for

259
00:10:59,930 --> 00:11:04,579
every process in the system and so you

260
00:11:02,210 --> 00:11:06,230
can see that in memory you may get tons

261
00:11:04,580 --> 00:11:07,610
more evidence than you would get even

262
00:11:06,230 --> 00:11:12,020
just looking at the screen of that

263
00:11:07,610 --> 00:11:13,760
application running vector graphics like

264
00:11:12,020 --> 00:11:15,260
you would draw in xfig and there's a

265
00:11:13,760 --> 00:11:17,780
bunch more you can look you can look at

266
00:11:15,260 --> 00:11:19,910
the paper if you're interested ok so

267
00:11:17,780 --> 00:11:23,060
we've seen from discrete how you can

268
00:11:19,910 --> 00:11:24,829
recover application output that goes to

269
00:11:23,060 --> 00:11:26,780
a single data structure that's in the

270
00:11:24,830 --> 00:11:28,490
memory of an application but that's just

271
00:11:26,780 --> 00:11:29,959
the tip of the iceberg for what's in

272
00:11:28,490 --> 00:11:32,330
memory and especially when we start

273
00:11:29,960 --> 00:11:34,610
thinking about more complex devices such

274
00:11:32,330 --> 00:11:37,040
as smartphones that have a wide array of

275
00:11:34,610 --> 00:11:39,320
onboard devices that are constantly

276
00:11:37,040 --> 00:11:42,050
generating evidence being pushed into

277
00:11:39,320 --> 00:11:43,550
the memory of these smartphones and so

278
00:11:42,050 --> 00:11:46,069
one thing that immediately comes to mind

279
00:11:43,550 --> 00:11:48,500
right is smart phone photography I'm

280
00:11:46,070 --> 00:11:49,970
sure almost everyone in the room has

281
00:11:48,500 --> 00:11:51,590
used their smartphone to take pictures

282
00:11:49,970 --> 00:11:54,620
it's the most common use of smartphones

283
00:11:51,590 --> 00:11:56,810
other than communication and this goes

284
00:11:54,620 --> 00:11:58,700
for criminals as well like these two

285
00:11:56,810 --> 00:12:01,819
teenagers who took selfies on the cells

286
00:11:58,700 --> 00:12:03,320
before robbing a bank this guy also with

287
00:12:01,820 --> 00:12:06,140
his stolen gone about to rob a bank

288
00:12:03,320 --> 00:12:07,940
these two guys who found their stolen

289
00:12:06,140 --> 00:12:10,130
guns good enough to post on Facebook

290
00:12:07,940 --> 00:12:12,710
even a teenager who stole a Lamborghini

291
00:12:10,130 --> 00:12:14,870
and took pictures and posted it on took

292
00:12:12,710 --> 00:12:16,760
pictures of himself and posted it with

293
00:12:14,870 --> 00:12:17,250
his smartphone and these are not just a

294
00:12:16,760 --> 00:12:19,020
few

295
00:12:17,250 --> 00:12:21,390
select cases you can actually google

296
00:12:19,020 --> 00:12:24,140
criminal selfie on your own and find all

297
00:12:21,390 --> 00:12:26,430
of the wealth of these that exist and to

298
00:12:24,140 --> 00:12:28,230
kind of highlight the important still

299
00:12:26,430 --> 00:12:29,729
are more serious note recently there was

300
00:12:28,230 --> 00:12:30,990
a Supreme Court case Riley verse

301
00:12:29,730 --> 00:12:32,700
California some of you were probably

302
00:12:30,990 --> 00:12:34,950
very familiar with it where the

303
00:12:32,700 --> 00:12:36,630
basically the primary evidence that was

304
00:12:34,950 --> 00:12:38,610
of importance in this case was

305
00:12:36,630 --> 00:12:40,770
photographs recovered from a smartphone

306
00:12:38,610 --> 00:12:44,210
that really gave the investigators the

307
00:12:40,770 --> 00:12:46,530
evidence that they were most looking for

308
00:12:44,210 --> 00:12:47,670
but as you can imagine when you take a

309
00:12:46,530 --> 00:12:50,280
picture with a smartphone that

310
00:12:47,670 --> 00:12:53,339
photograph before you snap it off with

311
00:12:50,280 --> 00:12:55,589
the with the camera app it caches a copy

312
00:12:53,340 --> 00:12:58,230
of that photograph in the devices memory

313
00:12:55,590 --> 00:13:01,260
and the same as if you're streaming a

314
00:12:58,230 --> 00:13:03,840
video right like Skype the individual

315
00:13:01,260 --> 00:13:05,970
frames of that video hit memory long

316
00:13:03,840 --> 00:13:08,070
before the skype application ever gets

317
00:13:05,970 --> 00:13:09,960
access to them and you can think skype

318
00:13:08,070 --> 00:13:11,850
never even saves the video to disk this

319
00:13:09,960 --> 00:13:14,820
is all going off to the cloud but it is

320
00:13:11,850 --> 00:13:16,560
in memory okay but probably the most

321
00:13:14,820 --> 00:13:17,910
interesting I'm sure we've all seen this

322
00:13:16,560 --> 00:13:20,010
when you go to take a picture with a

323
00:13:17,910 --> 00:13:21,569
smartphone camera it shows you what the

324
00:13:20,010 --> 00:13:23,430
camera is looking at right it's a little

325
00:13:21,570 --> 00:13:25,980
preview so you can line the shot up

326
00:13:23,430 --> 00:13:28,199
correctly well as you guessed those

327
00:13:25,980 --> 00:13:30,240
preview frames are even being buffered

328
00:13:28,200 --> 00:13:32,730
in memory before you're looking at them

329
00:13:30,240 --> 00:13:35,310
to line the shot up and so this leads to

330
00:13:32,730 --> 00:13:37,560
a very interesting property that

331
00:13:35,310 --> 00:13:39,569
photographic evidence is available in

332
00:13:37,560 --> 00:13:41,849
your smartphone's memory just as soon as

333
00:13:39,570 --> 00:13:44,690
you open an app that uses the camera you

334
00:13:41,850 --> 00:13:47,250
don't have to take a picture or a video

335
00:13:44,690 --> 00:13:49,710
but of course like I said things in

336
00:13:47,250 --> 00:13:52,440
memory are not nicely formatted JPEG

337
00:13:49,710 --> 00:13:54,180
files they're nasty encoded data

338
00:13:52,440 --> 00:13:56,370
structures that have to be recovered and

339
00:13:54,180 --> 00:13:59,010
pieced back together and so that's the

340
00:13:56,370 --> 00:14:00,720
focus of my paper VCR VCR actually is

341
00:13:59,010 --> 00:14:02,839
going to recover all of the photographic

342
00:14:00,720 --> 00:14:05,610
evidence that's in a smart phones memory

343
00:14:02,839 --> 00:14:07,230
so to do this VCR takes as input a

344
00:14:05,610 --> 00:14:10,650
memory image from an Android smartphone

345
00:14:07,230 --> 00:14:12,150
it then recovers the data structures

346
00:14:10,650 --> 00:14:13,800
which correspond to all of that

347
00:14:12,150 --> 00:14:16,020
photographic evidence using

348
00:14:13,800 --> 00:14:18,000
probabilistic inference and we'll get to

349
00:14:16,020 --> 00:14:20,250
that in just a minute and then uses

350
00:14:18,000 --> 00:14:22,380
automated image decoding techniques to

351
00:14:20,250 --> 00:14:24,600
return to the investigators the actual

352
00:14:22,380 --> 00:14:27,220
images that were in the memory of the

353
00:14:24,600 --> 00:14:28,930
device now the

354
00:14:27,220 --> 00:14:31,329
probabilistic inference is important

355
00:14:28,930 --> 00:14:33,219
because VCR face is a pretty significant

356
00:14:31,329 --> 00:14:35,920
challenge all of the different

357
00:14:33,220 --> 00:14:39,399
smartphone vendors out there like LG

358
00:14:35,920 --> 00:14:42,279
Samsung HTC they're all customizing the

359
00:14:39,399 --> 00:14:45,339
Android frameworks camera software to

360
00:14:42,279 --> 00:14:47,139
their specific device so for instance

361
00:14:45,339 --> 00:14:49,000
they may add some fields they may

362
00:14:47,139 --> 00:14:50,290
rearrange some fields within those data

363
00:14:49,000 --> 00:14:52,990
structures we're looking for and

364
00:14:50,290 --> 00:14:54,910
therefore it's impossible to build data

365
00:14:52,990 --> 00:14:56,920
structure signatures ahead of time for

366
00:14:54,910 --> 00:14:58,209
VCR because it's going to be working

367
00:14:56,920 --> 00:15:00,459
with all these different vendor

368
00:14:58,209 --> 00:15:02,680
customized phones and the consequence

369
00:15:00,459 --> 00:15:05,500
there is that when you scan the memory

370
00:15:02,680 --> 00:15:07,449
image you can't actually match your data

371
00:15:05,500 --> 00:15:09,750
structure signature to any of the vendor

372
00:15:07,449 --> 00:15:13,389
customized data that it that's in memory

373
00:15:09,750 --> 00:15:16,120
so to overcome this VCR uses a technique

374
00:15:13,389 --> 00:15:18,879
called vendor generic signatures these

375
00:15:16,120 --> 00:15:20,769
are filled offset independent versions

376
00:15:18,879 --> 00:15:23,290
of the data structure signatures we've

377
00:15:20,769 --> 00:15:25,990
seen previously so instead of requiring

378
00:15:23,290 --> 00:15:27,939
fields to be at certain positions these

379
00:15:25,990 --> 00:15:30,639
are only a set of probabilistic

380
00:15:27,939 --> 00:15:35,379
constraints on the structures field

381
00:15:30,639 --> 00:15:37,540
values so like the trying to find one so

382
00:15:35,379 --> 00:15:40,449
like the cam the string camera or the

383
00:15:37,540 --> 00:15:42,730
PID of the process using the camera but

384
00:15:40,449 --> 00:15:45,729
it has no dependencies on where those

385
00:15:42,730 --> 00:15:47,500
fields lie in the data structure now

386
00:15:45,730 --> 00:15:50,769
armed with these vendor generic

387
00:15:47,500 --> 00:15:52,300
signatures VCR takes a typical scanning

388
00:15:50,769 --> 00:15:54,839
approach where it's going to scan

389
00:15:52,300 --> 00:15:57,160
through the memory image and locate any

390
00:15:54,839 --> 00:15:59,680
variance of these data structures which

391
00:15:57,160 --> 00:16:01,779
match which with high probability now

392
00:15:59,680 --> 00:16:04,439
this may give us false positives but

393
00:16:01,779 --> 00:16:07,569
then we rely on another observation any

394
00:16:04,439 --> 00:16:09,639
valid data structures we recover must

395
00:16:07,569 --> 00:16:11,860
have the same layout of course because

396
00:16:09,639 --> 00:16:13,540
they've been compiled one time so then

397
00:16:11,860 --> 00:16:15,399
we find the matches with the highest

398
00:16:13,540 --> 00:16:17,439
probability and we select all of those

399
00:16:15,399 --> 00:16:18,939
that depend that that have the same

400
00:16:17,439 --> 00:16:21,879
field layout with the highest

401
00:16:18,939 --> 00:16:23,680
probability match make sense so that

402
00:16:21,879 --> 00:16:26,860
allows VCR to handle all the different

403
00:16:23,680 --> 00:16:29,888
vendor customized devices and again I

404
00:16:26,860 --> 00:16:32,949
have a demo of VCR running to recover

405
00:16:29,889 --> 00:16:35,949
some actual photographic evidence see we

406
00:16:32,949 --> 00:16:37,540
can get it I real so again back at the

407
00:16:35,949 --> 00:16:39,099
forensics lab investigators are going to

408
00:16:37,540 --> 00:16:41,199
be working with a memory image from a

409
00:16:39,100 --> 00:16:43,060
smartphone VCR is going to run in

410
00:16:41,200 --> 00:16:45,820
android emulator that we have here and

411
00:16:43,060 --> 00:16:47,920
use the terminal actually to control the

412
00:16:45,820 --> 00:16:50,980
vcr app which we'll see in a minute i've

413
00:16:47,920 --> 00:16:53,890
already in this demo loaded the suspect

414
00:16:50,980 --> 00:16:57,370
memory image onto the emulator to be

415
00:16:53,890 --> 00:17:04,449
scanned and we're just going to watch

416
00:16:57,370 --> 00:17:06,790
the log into terminal to see VCR run so

417
00:17:04,449 --> 00:17:10,240
the investigator just starts the VCR

418
00:17:06,790 --> 00:17:13,540
front-end app I'm not a UI designer

419
00:17:10,240 --> 00:17:15,370
saree do forensics tools and then they

420
00:17:13,540 --> 00:17:21,159
select the memory image that they want

421
00:17:15,369 --> 00:17:23,050
to scan there you go and then VCRs going

422
00:17:21,160 --> 00:17:25,750
to start scanning VCR has a quick to

423
00:17:23,050 --> 00:17:27,550
sched stand two phase scan the first

424
00:17:25,750 --> 00:17:29,440
phase scans through and finds all the

425
00:17:27,550 --> 00:17:31,180
matches that are not probabilistic and

426
00:17:29,440 --> 00:17:32,980
then the second scan goes through and

427
00:17:31,180 --> 00:17:36,550
finds all those vendor generic signature

428
00:17:32,980 --> 00:17:38,200
matches first scan is actually really

429
00:17:36,550 --> 00:17:41,040
quick the second scan takes about five

430
00:17:38,200 --> 00:17:43,630
minutes but we'll skip let's give that

431
00:17:41,040 --> 00:17:48,970
okay so first scans done second scans

432
00:17:43,630 --> 00:17:51,460
going four minutes later and now we can

433
00:17:48,970 --> 00:17:55,540
review the results from VCR on this

434
00:17:51,460 --> 00:17:58,120
memory image so VCR found 16 frames 8

435
00:17:55,540 --> 00:18:00,580
preview frames that's just lining up the

436
00:17:58,120 --> 00:18:02,530
shot as well as eight video frames it's

437
00:18:00,580 --> 00:18:04,720
using the image decoding techniques

438
00:18:02,530 --> 00:18:06,520
right now to decode them and we'll see

439
00:18:04,720 --> 00:18:08,740
in a minute the investigator can

440
00:18:06,520 --> 00:18:11,379
literally just swipe through the fit the

441
00:18:08,740 --> 00:18:13,920
frames when they're when they're

442
00:18:11,380 --> 00:18:13,920
recovered

443
00:18:17,350 --> 00:18:21,070
give it just a minute

444
00:18:24,700 --> 00:18:28,540
okay and so now this is you can see this

445
00:18:26,920 --> 00:18:30,040
is the preview frames the investigator

446
00:18:28,540 --> 00:18:32,470
can swipe through and you can see that

447
00:18:30,040 --> 00:18:34,690
it gives the not only the pictures of

448
00:18:32,470 --> 00:18:36,790
this guy in a hood running but it also

449
00:18:34,690 --> 00:18:39,310
gives you some kind of temporal evidence

450
00:18:36,790 --> 00:18:42,070
you can actually get the time duration

451
00:18:39,310 --> 00:18:43,960
from these images of when this event

452
00:18:42,070 --> 00:18:46,600
occurred and then those were the preview

453
00:18:43,960 --> 00:18:48,610
frames these the video frames and there

454
00:18:46,600 --> 00:18:50,139
was no photograph taken in this demo but

455
00:18:48,610 --> 00:18:56,790
if you taken a photograph also you'd

456
00:18:50,140 --> 00:18:56,790
have seen that there back to the slides

457
00:19:01,330 --> 00:19:05,830
okay so here's a cool case study so like

458
00:19:03,880 --> 00:19:08,710
I said these images are actually hitting

459
00:19:05,830 --> 00:19:10,510
memory long before the app itself is

460
00:19:08,710 --> 00:19:12,700
getting access to them so for instance I

461
00:19:10,510 --> 00:19:14,410
use chase bank chase bank allows you to

462
00:19:12,700 --> 00:19:16,660
take pictures of checks in order to make

463
00:19:14,410 --> 00:19:18,790
a deposit well sure enough that check

464
00:19:16,660 --> 00:19:20,440
image is hitting memory long before the

465
00:19:18,790 --> 00:19:22,899
Chase Bank app is getting to it and that

466
00:19:20,440 --> 00:19:25,390
and in fact we recovered a number of

467
00:19:22,900 --> 00:19:26,980
check images from my phone's memory when

468
00:19:25,390 --> 00:19:28,420
we were doing these tests this is

469
00:19:26,980 --> 00:19:30,070
nothing wrong with the Chase Bank app

470
00:19:28,420 --> 00:19:31,630
they can't help it of course it's get it

471
00:19:30,070 --> 00:19:33,250
that the images when you take it go to

472
00:19:31,630 --> 00:19:34,750
memory first and then chase bank and

473
00:19:33,250 --> 00:19:37,000
access it there's there's no way

474
00:19:34,750 --> 00:19:38,860
currently for Chase Bank to prevent this

475
00:19:37,000 --> 00:19:40,360
it's not actually attack against chase

476
00:19:38,860 --> 00:19:42,550
bank more against the android framework

477
00:19:40,360 --> 00:19:48,790
but let's not talk about it taxes

478
00:19:42,550 --> 00:19:51,220
forensics right ok so we've seen from

479
00:19:48,790 --> 00:19:53,980
discrete how you can recover a bunch of

480
00:19:51,220 --> 00:19:55,930
different types of data structures human

481
00:19:53,980 --> 00:19:58,150
understandable output and we've just

482
00:19:55,930 --> 00:20:00,040
seen VCR recover a number of

483
00:19:58,150 --> 00:20:02,410
photographic evidence types of

484
00:20:00,040 --> 00:20:04,750
photographic evidence from memory but

485
00:20:02,410 --> 00:20:06,310
I'm a human right and when I think of a

486
00:20:04,750 --> 00:20:08,050
digital when I think of digital evidence

487
00:20:06,310 --> 00:20:11,560
when I want to know what a computer is

488
00:20:08,050 --> 00:20:14,110
doing what comes to my mind is a user

489
00:20:11,560 --> 00:20:15,669
interface right we all interact with our

490
00:20:14,110 --> 00:20:17,379
applications through the user interface

491
00:20:15,670 --> 00:20:18,880
and in fact the user interface has a

492
00:20:17,380 --> 00:20:22,150
wealth of different types of evidence

493
00:20:18,880 --> 00:20:24,990
right text images and all this stuff is

494
00:20:22,150 --> 00:20:28,240
displayed in one concise place

495
00:20:24,990 --> 00:20:30,700
unfortunately for investigators gys is

496
00:20:28,240 --> 00:20:33,400
all are also the most complex form of

497
00:20:30,700 --> 00:20:36,070
digital evidence this is each individual

498
00:20:33,400 --> 00:20:37,810
applications GUI is a virtual billboard

499
00:20:36,070 --> 00:20:40,149
of all these diverse applications

500
00:20:37,810 --> 00:20:45,040
specific data structures that build each

501
00:20:40,150 --> 00:20:48,340
little component of that GUI internally

502
00:20:45,040 --> 00:20:51,340
an Android apps GUI is represented as a

503
00:20:48,340 --> 00:20:53,740
GUI hierarchy tree which consists of

504
00:20:51,340 --> 00:20:55,659
tree nodes each tree node may be

505
00:20:53,740 --> 00:20:57,970
hundreds or even thousands of different

506
00:20:55,660 --> 00:20:59,530
data structures I'm simplifying it here

507
00:20:57,970 --> 00:21:03,090
by just showing you parent tree nodes in

508
00:20:59,530 --> 00:21:06,430
blue and child tree nodes in red further

509
00:21:03,090 --> 00:21:08,199
each tree know the actual graphical

510
00:21:06,430 --> 00:21:11,410
content that's on the screen of the app

511
00:21:08,200 --> 00:21:13,780
is encoded into drawing operations each

512
00:21:11,410 --> 00:21:14,710
of these drawing operations describes a

513
00:21:13,780 --> 00:21:17,080
little piece

514
00:21:14,710 --> 00:21:19,600
of the GUI so for instance this draw

515
00:21:17,080 --> 00:21:22,658
text up is just one line of text

516
00:21:19,600 --> 00:21:25,389
together these three ops describe one

517
00:21:22,659 --> 00:21:27,820
line of text in a larger GUI component

518
00:21:25,390 --> 00:21:30,370
and you can imagine a full tree of all

519
00:21:27,820 --> 00:21:32,860
these draw up lists builds the entire

520
00:21:30,370 --> 00:21:35,049
GUI that you're looking at so it makes

521
00:21:32,860 --> 00:21:37,270
sense to focus our recovery on this GUI

522
00:21:35,049 --> 00:21:39,418
tree maybe we can recover it do some

523
00:21:37,270 --> 00:21:42,190
rendering and be easy right

524
00:21:39,419 --> 00:21:45,130
unfortunately not because as most of you

525
00:21:42,190 --> 00:21:48,220
know Android applications do not share

526
00:21:45,130 --> 00:21:49,750
screen space they actually execute one

527
00:21:48,220 --> 00:21:51,220
at a time in the foreground while

528
00:21:49,750 --> 00:21:53,740
there's numerous other apps in the

529
00:21:51,220 --> 00:21:56,110
background and as soon as you background

530
00:21:53,740 --> 00:21:58,779
that app Android goes through and

531
00:21:56,110 --> 00:22:01,029
explicitly fries and nullifies all of

532
00:21:58,779 --> 00:22:02,850
this and all of this GUI data that's in

533
00:22:01,029 --> 00:22:05,590
the apps memory and this basically

534
00:22:02,850 --> 00:22:07,418
disintegrates that whole GUI tree in the

535
00:22:05,590 --> 00:22:09,699
apps memory making all of those

536
00:22:07,419 --> 00:22:11,320
individual data structure approaches

537
00:22:09,700 --> 00:22:12,490
that we just talked about totally

538
00:22:11,320 --> 00:22:13,418
useless here because they wouldn't be

539
00:22:12,490 --> 00:22:16,720
able to find anything it's all

540
00:22:13,419 --> 00:22:19,630
disconnected but this is where my paper

541
00:22:16,720 --> 00:22:22,750
guitar comes in guitar works to actually

542
00:22:19,630 --> 00:22:24,250
rebuild the topology of that GUI tree

543
00:22:22,750 --> 00:22:26,649
from whatever is left in the

544
00:22:24,250 --> 00:22:28,450
applications memory and then do the rear

545
00:22:26,649 --> 00:22:29,979
entering process for the app for the

546
00:22:28,450 --> 00:22:31,779
investigator so that they can look at

547
00:22:29,980 --> 00:22:33,640
the screens of all the apps no matter

548
00:22:31,779 --> 00:22:36,250
how if they were in the foreground the

549
00:22:33,640 --> 00:22:38,049
background so the first step is to

550
00:22:36,250 --> 00:22:39,880
recover the hundreds of thousands of

551
00:22:38,049 --> 00:22:41,260
different data structures that are left

552
00:22:39,880 --> 00:22:43,659
in the applications memory the

553
00:22:41,260 --> 00:22:45,730
correspond to these trees and then to

554
00:22:43,659 --> 00:22:47,860
reconstruct the G the GUI trees

555
00:22:45,730 --> 00:22:50,679
structure alone you can use some

556
00:22:47,860 --> 00:22:52,570
pointers that are left in memory but

557
00:22:50,679 --> 00:22:55,090
then you're left with a problem you've

558
00:22:52,570 --> 00:22:56,860
rebuilt this GUI tree so you know kind

559
00:22:55,090 --> 00:22:58,658
of the structure but you have all of

560
00:22:56,860 --> 00:23:00,580
these drawing operations that you don't

561
00:22:58,659 --> 00:23:02,470
know where they go because there's no

562
00:23:00,580 --> 00:23:04,449
way to recover that Android has gone

563
00:23:02,470 --> 00:23:06,130
through and freed and nullified all the

564
00:23:04,450 --> 00:23:07,600
pointers between these two so there's no

565
00:23:06,130 --> 00:23:09,730
way to figure out where the actual

566
00:23:07,600 --> 00:23:12,879
graphical content goes back onto the

567
00:23:09,730 --> 00:23:15,100
screen you're trying to recreate but we

568
00:23:12,880 --> 00:23:17,320
leverage an interesting observation each

569
00:23:15,100 --> 00:23:20,408
of those tree nodes that we saw earlier

570
00:23:17,320 --> 00:23:24,399
describes some geometrical portion of

571
00:23:20,409 --> 00:23:27,520
the screen space and likewise each of

572
00:23:24,399 --> 00:23:28,039
the recovered draw up lists encodes some

573
00:23:27,520 --> 00:23:30,710
render

574
00:23:28,039 --> 00:23:32,929
graphic content that takes up space on

575
00:23:30,710 --> 00:23:35,539
the screen so maybe you see where I'm

576
00:23:32,929 --> 00:23:38,299
going with this my paper guitar actually

577
00:23:35,539 --> 00:23:42,019
pieces back together the GUI like a

578
00:23:38,299 --> 00:23:45,080
puzzle more formally we find a global

579
00:23:42,019 --> 00:23:47,509
best fit of the GUI graphic components

580
00:23:45,080 --> 00:23:50,178
to the open screen space on the app's

581
00:23:47,509 --> 00:23:52,009
recovered screen and this can be modeled

582
00:23:50,179 --> 00:23:54,320
as a weighted bipartite graph problem

583
00:23:52,009 --> 00:23:57,109
where the node Fitness between each side

584
00:23:54,320 --> 00:24:02,389
is the drawing content that's being

585
00:23:57,109 --> 00:24:06,859
fitted into the GUI and one last demo I

586
00:24:02,389 --> 00:24:10,728
swear show you guitar actually

587
00:24:06,859 --> 00:24:14,178
recovering a screen from the I think

588
00:24:10,729 --> 00:24:17,330
it's whatsapp app but whatsapp messenger

589
00:24:14,179 --> 00:24:22,249
so guitar runs inside of this modified

590
00:24:17,330 --> 00:24:23,779
android emulator again and the

591
00:24:22,249 --> 00:24:25,849
investigators just going to start guitar

592
00:24:23,779 --> 00:24:28,669
and again select the memory image they

593
00:24:25,849 --> 00:24:31,279
want to investigate I think this is an

594
00:24:28,669 --> 00:24:34,999
this is a memory image from whatsapp so

595
00:24:31,279 --> 00:24:36,830
guitar works on every app memory image

596
00:24:34,999 --> 00:24:38,570
independently so you can give it a

597
00:24:36,830 --> 00:24:40,189
hundred app memory images you can give

598
00:24:38,570 --> 00:24:43,189
it one app memory image it doesn't care

599
00:24:40,190 --> 00:24:46,070
it'll work on each one in sequence yeah

600
00:24:43,190 --> 00:24:48,559
it's whatsapp ok so it starts by

601
00:24:46,070 --> 00:24:50,689
scanning for all of those different data

602
00:24:48,559 --> 00:24:52,789
structures that may remain in whatsapp's

603
00:24:50,690 --> 00:24:54,710
memory after the app was put in the

604
00:24:52,789 --> 00:24:57,229
background and left for a while before I

605
00:24:54,710 --> 00:24:59,299
collected that memory image takes about

606
00:24:57,229 --> 00:25:02,509
six minutes and it recovers looks like

607
00:24:59,299 --> 00:25:06,289
about around 200 data structures here

608
00:25:02,509 --> 00:25:08,119
and then does the topology recovery and

609
00:25:06,289 --> 00:25:10,700
then does the bipartite graph matching

610
00:25:08,119 --> 00:25:13,580
that we talked about and then it

611
00:25:10,700 --> 00:25:15,799
actually does the GUI redraw and the

612
00:25:13,580 --> 00:25:17,720
investigator will be presented with the

613
00:25:15,799 --> 00:25:19,759
final GUI so there we go so the

614
00:25:17,720 --> 00:25:22,099
investigator can actually see the GUI of

615
00:25:19,759 --> 00:25:23,809
the app as it looked the last time it

616
00:25:22,099 --> 00:25:26,090
was in the foreground of the suspects

617
00:25:23,809 --> 00:25:28,519
device and for comparison that's a

618
00:25:26,090 --> 00:25:30,199
screenshot of the app when it was in the

619
00:25:28,519 --> 00:25:32,299
foreground of the device now recall that

620
00:25:30,200 --> 00:25:34,099
what we recover is in the background all

621
00:25:32,299 --> 00:25:36,139
of that stuff has been freed and it's

622
00:25:34,099 --> 00:25:37,700
it's available to be overwritten if the

623
00:25:36,139 --> 00:25:39,320
ipad if the app has any you know

624
00:25:37,700 --> 00:25:41,810
background updates or something that it

625
00:25:39,320 --> 00:25:43,909
does but guitar faithfully

626
00:25:41,810 --> 00:25:46,100
recreates everything at least as it

627
00:25:43,910 --> 00:25:49,310
exists in the memory as it still exists

628
00:25:46,100 --> 00:25:52,429
in the memory image and I have an even

629
00:25:49,310 --> 00:25:54,110
more powerful case of guitar recovering

630
00:25:52,430 --> 00:25:56,780
everything as it exists in the memory

631
00:25:54,110 --> 00:26:00,020
image so this is a case study the

632
00:25:56,780 --> 00:26:02,090
samsung s4 contacts app right so this

633
00:26:00,020 --> 00:26:03,800
shows you your contacts so that's a

634
00:26:02,090 --> 00:26:05,360
screenshot of what the app looked like

635
00:26:03,800 --> 00:26:08,060
when it was in the foreground of the

636
00:26:05,360 --> 00:26:10,580
suspects device and then that's the GUI

637
00:26:08,060 --> 00:26:12,139
guitar result for it you can see it

638
00:26:10,580 --> 00:26:14,600
looks and probably ninety percent

639
00:26:12,140 --> 00:26:15,920
correct it is missing a few icons but

640
00:26:14,600 --> 00:26:17,179
again that's because it was freed

641
00:26:15,920 --> 00:26:19,880
there's nothing we can do it actually

642
00:26:17,180 --> 00:26:22,100
gets overwritten in memory so guitar

643
00:26:19,880 --> 00:26:24,350
still able to faithfully recreate it but

644
00:26:22,100 --> 00:26:26,120
in this case study we also got some

645
00:26:24,350 --> 00:26:28,219
extra recovery and we were really

646
00:26:26,120 --> 00:26:30,679
curious what what is this it doesn't

647
00:26:28,220 --> 00:26:32,930
match anything on the most recent screen

648
00:26:30,680 --> 00:26:35,180
where did this come from well when we

649
00:26:32,930 --> 00:26:37,970
thought back actually before we looked

650
00:26:35,180 --> 00:26:40,340
at the contact screen of that app we

651
00:26:37,970 --> 00:26:42,230
were on the call log screen of that app

652
00:26:40,340 --> 00:26:44,540
and so you can see that actually two of

653
00:26:42,230 --> 00:26:45,860
the entries in the call logs persisted

654
00:26:44,540 --> 00:26:48,139
in memory even though we had already

655
00:26:45,860 --> 00:26:50,300
changed screens and then background it

656
00:26:48,140 --> 00:26:51,800
and guitar is able to just recreate that

657
00:26:50,300 --> 00:26:55,389
because it's still in the memory image

658
00:26:51,800 --> 00:26:58,669
and it all pieces back together and

659
00:26:55,390 --> 00:27:00,680
let's keep hammering on chase bank so

660
00:26:58,670 --> 00:27:02,810
the chase bank app is really pretty well

661
00:27:00,680 --> 00:27:04,580
designed it's very secure it requires

662
00:27:02,810 --> 00:27:06,980
you to put in a password when you bring

663
00:27:04,580 --> 00:27:09,439
the app back to the foreground but of

664
00:27:06,980 --> 00:27:11,180
course the last screen you are looking

665
00:27:09,440 --> 00:27:13,190
at before you back rounded the chase

666
00:27:11,180 --> 00:27:15,140
bank app with some internal screen right

667
00:27:13,190 --> 00:27:16,970
after you'd already logged in and so

668
00:27:15,140 --> 00:27:18,710
that's the data structures that guitar

669
00:27:16,970 --> 00:27:20,420
is going to recover so for instance this

670
00:27:18,710 --> 00:27:23,030
is chase bank on three different

671
00:27:20,420 --> 00:27:26,240
smartphones that we tested recovering

672
00:27:23,030 --> 00:27:27,470
the account screen even though it had

673
00:27:26,240 --> 00:27:29,390
been in the background it was already

674
00:27:27,470 --> 00:27:31,220
timed out the app was logged out but

675
00:27:29,390 --> 00:27:33,410
those data structures still remain in

676
00:27:31,220 --> 00:27:35,180
the memory and this was a very proud

677
00:27:33,410 --> 00:27:37,460
moment for me I published this this

678
00:27:35,180 --> 00:27:40,040
picture in the paper and I said figure 3

679
00:27:37,460 --> 00:27:47,390
shows the authors graduate student sized

680
00:27:40,040 --> 00:27:49,190
bank accounts so in conclusion before my

681
00:27:47,390 --> 00:27:50,870
work we were talking about individual

682
00:27:49,190 --> 00:27:53,510
data structures and my work has really

683
00:27:50,870 --> 00:27:55,600
tried to bring that into the 21st

684
00:27:53,510 --> 00:27:57,400
century with some human understand

685
00:27:55,600 --> 00:27:59,678
Hannibal evidence we saw discreet that

686
00:27:57,400 --> 00:28:02,110
recovers application output for specific

687
00:27:59,679 --> 00:28:03,990
application data structures we saw a VCR

688
00:28:02,110 --> 00:28:05,860
which overcomes vendor customized

689
00:28:03,990 --> 00:28:07,960
photographic evidence recovery from

690
00:28:05,860 --> 00:28:10,449
smartphones as well as guitar which

691
00:28:07,960 --> 00:28:13,419
recovers GU eyes that are frozen in

692
00:28:10,450 --> 00:28:15,309
android app memory images just before i

693
00:28:13,419 --> 00:28:18,910
go to put this in a larger picture of

694
00:28:15,309 --> 00:28:22,780
the research that my group is working on

695
00:28:18,910 --> 00:28:24,640
entire in its entirety we work on a PT

696
00:28:22,780 --> 00:28:26,770
that's advanced persistent threat style

697
00:28:24,640 --> 00:28:29,140
malware detection and forensics this is

698
00:28:26,770 --> 00:28:31,210
all based on integrating both forensics

699
00:28:29,140 --> 00:28:33,370
and detection mitigation capabilities

700
00:28:31,210 --> 00:28:35,409
and we come at this from a binary

701
00:28:33,370 --> 00:28:36,969
centric remember I said we work we do

702
00:28:35,409 --> 00:28:38,890
not have any source code for any of the

703
00:28:36,970 --> 00:28:41,799
work that we do our tools rely only on

704
00:28:38,890 --> 00:28:43,480
binaries and we come at it from three

705
00:28:41,799 --> 00:28:45,520
different angles temporal spatial and

706
00:28:43,480 --> 00:28:48,190
behavioral forensics we're supported by

707
00:28:45,520 --> 00:28:51,400
these very wonderful organizations and

708
00:28:48,190 --> 00:28:53,049
we're always looking for more and if

709
00:28:51,400 --> 00:28:54,610
you're interested in any other lines of

710
00:28:53,049 --> 00:28:56,230
work that we have to do we kind of split

711
00:28:54,610 --> 00:28:57,879
them like i said temporal behavioral

712
00:28:56,230 --> 00:28:59,350
spatial you've seen memory forensic sets

713
00:28:57,880 --> 00:29:01,240
and our top that's in this talk and you

714
00:28:59,350 --> 00:29:02,530
can go look at our web page for any of

715
00:29:01,240 --> 00:29:05,679
the other work that we've done recently

716
00:29:02,530 --> 00:29:07,000
and with that I thank you very much for

717
00:29:05,679 --> 00:29:13,690
your attention i'm open to take any

718
00:29:07,000 --> 00:29:15,400
questions Thank You Brendan in the sake

719
00:29:13,690 --> 00:29:18,190
of time Brendan are you going to lunch

720
00:29:15,400 --> 00:29:19,929
with the group today yes very good seat

721
00:29:18,190 --> 00:29:21,309
Brendan out if you want to learn more

722
00:29:19,929 --> 00:29:24,539
about this technology he will be joining

723
00:29:21,309 --> 00:29:24,539
the lunch group

