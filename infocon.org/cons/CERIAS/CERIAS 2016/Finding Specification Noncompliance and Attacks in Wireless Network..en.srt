1
00:00:14,030 --> 00:00:16,090
you

2
00:00:55,589 --> 00:01:04,869
okay welcome to the serious seminar for

3
00:01:01,149 --> 00:01:08,979
april sixth today I'm honored to

4
00:01:04,869 --> 00:01:13,270
introduce dr. and Adele hook who comes

5
00:01:08,979 --> 00:01:18,399
to us from well he's currently in a have

6
00:01:13,270 --> 00:01:20,860
a dual role he's a visiting her research

7
00:01:18,399 --> 00:01:23,170
faculty at Northeastern University but

8
00:01:20,860 --> 00:01:25,690
he is also still in a visiting position

9
00:01:23,170 --> 00:01:27,700
at Purdue University so research Bulldog

10
00:01:25,690 --> 00:01:31,149
research postdocs so he's actually a

11
00:01:27,700 --> 00:01:33,970
postdoctoral position Bob at Ted

12
00:01:31,149 --> 00:01:37,750
northeastern while visiting here in

13
00:01:33,970 --> 00:01:38,740
addition I should point out that you

14
00:01:37,750 --> 00:01:42,610
know this is something you can all

15
00:01:38,740 --> 00:01:44,770
aspire to as he is a graduate of Purdue

16
00:01:42,610 --> 00:01:47,280
University receiving his PhD here

17
00:01:44,770 --> 00:01:51,270
working with Professor new turret ro

18
00:01:47,280 --> 00:01:55,000
working you know within serious so yeah

19
00:01:51,270 --> 00:01:57,550
he before that he as she did his

20
00:01:55,000 --> 00:01:59,319
undergraduate work in Bangladesh and

21
00:01:57,550 --> 00:02:02,830
then headed to Wisconsin he was at

22
00:01:59,319 --> 00:02:05,950
Marquette for his master's before

23
00:02:02,830 --> 00:02:07,959
joining us here at Purdue so with that

24
00:02:05,950 --> 00:02:11,950
all were turned over to end it all to

25
00:02:07,959 --> 00:02:14,680
let you know what he is thank you a lot

26
00:02:11,950 --> 00:02:17,260
about thank you for said that's a nice

27
00:02:14,680 --> 00:02:24,010
introduction can you guys hear me in the

28
00:02:17,260 --> 00:02:26,379
back okay how angry I'll probably try to

29
00:02:24,010 --> 00:02:30,190
stand here that might help me to

30
00:02:26,379 --> 00:02:33,129
interact okay thank you for making time

31
00:02:30,190 --> 00:02:35,909
for my top two day I'm going to talk

32
00:02:33,129 --> 00:02:38,560
about my research which is about finding

33
00:02:35,909 --> 00:02:40,000
specification non-compliance and attacks

34
00:02:38,560 --> 00:02:45,400
in wireless network protocol

35
00:02:40,000 --> 00:02:48,330
implementations so let's get started so

36
00:02:45,400 --> 00:02:51,190
with the emergence of new wireless

37
00:02:48,330 --> 00:02:53,680
technologies like wireless mesh mobile

38
00:02:51,190 --> 00:02:55,870
peer-to-peer Internet of Things being

39
00:02:53,680 --> 00:02:59,560
made popular by companies like Cisco and

40
00:02:55,870 --> 00:03:01,000
Google is live is encouraging several

41
00:02:59,560 --> 00:03:03,730
efforts in building

42
00:03:01,000 --> 00:03:05,680
services by leveraging these networks

43
00:03:03,730 --> 00:03:08,260
these critical services include

44
00:03:05,680 --> 00:03:10,750
emergency responders contactless payment

45
00:03:08,260 --> 00:03:14,109
home and industrial automation so on and

46
00:03:10,750 --> 00:03:16,900
so forth like traditional wired networks

47
00:03:14,110 --> 00:03:19,330
the core of these techni wireless

48
00:03:16,900 --> 00:03:23,200
networks also consists of several

49
00:03:19,330 --> 00:03:25,720
communication protocols let me show you

50
00:03:23,200 --> 00:03:29,920
the development lifecycle of a network

51
00:03:25,720 --> 00:03:32,590
protocol it usually starts with a list

52
00:03:29,920 --> 00:03:34,600
of requirements then the designer comes

53
00:03:32,590 --> 00:03:36,280
up with the protocol design which

54
00:03:34,600 --> 00:03:38,440
followed which is followed by the

55
00:03:36,280 --> 00:03:40,420
development phase and once the

56
00:03:38,440 --> 00:03:45,520
implementation is ready it is shipped

57
00:03:40,420 --> 00:03:49,029
for deployment but prior to shipping the

58
00:03:45,520 --> 00:03:51,070
implementation it is required that this

59
00:03:49,030 --> 00:03:53,350
implementation is checked whether it

60
00:03:51,070 --> 00:03:56,260
complies with all the given requirements

61
00:03:53,350 --> 00:03:58,630
or not if it complies with all the

62
00:03:56,260 --> 00:04:00,459
requirements then we can say that this

63
00:03:58,630 --> 00:04:02,400
is a compliant implementation and

64
00:04:00,459 --> 00:04:06,010
complained to the given requirements

65
00:04:02,400 --> 00:04:08,170
however failing to comply with these

66
00:04:06,010 --> 00:04:12,609
requirements will result in

67
00:04:08,170 --> 00:04:15,510
non-compliance which can cause function

68
00:04:12,610 --> 00:04:18,760
and it loss inconsistent behavior

69
00:04:15,510 --> 00:04:23,080
interoperability issues or even security

70
00:04:18,760 --> 00:04:25,180
consequences now let me show you an

71
00:04:23,080 --> 00:04:28,419
example of real non-compliance in an

72
00:04:25,180 --> 00:04:29,979
implementation so as we all know like

73
00:04:28,419 --> 00:04:32,700
Internet of Things is becoming

74
00:04:29,979 --> 00:04:35,500
increasingly popular these days and

75
00:04:32,700 --> 00:04:38,050
various operating systems at sdks are

76
00:04:35,500 --> 00:04:41,740
being developed to program these IOT

77
00:04:38,050 --> 00:04:46,150
devices kon-tiki is one such operating

78
00:04:41,740 --> 00:04:49,570
system this internet these IOT devices

79
00:04:46,150 --> 00:04:53,109
still use telnet protocol for doing

80
00:04:49,570 --> 00:04:55,840
communication and remote management so

81
00:04:53,110 --> 00:04:58,510
therefore Contiki provides a telnet

82
00:04:55,840 --> 00:05:01,330
server implementations one of the

83
00:04:58,510 --> 00:05:06,640
requirements of this implementation is

84
00:05:01,330 --> 00:05:10,060
as follows that the server must handle

85
00:05:06,640 --> 00:05:11,740
only one client at a time now I will

86
00:05:10,060 --> 00:05:13,850
show you how this implementation

87
00:05:11,740 --> 00:05:16,950
violates this requirement

88
00:05:13,850 --> 00:05:19,140
now consider the client one comes and

89
00:05:16,950 --> 00:05:22,080
then connects with the server it sends

90
00:05:19,140 --> 00:05:24,180
some commands to the server and receives

91
00:05:22,080 --> 00:05:27,810
the corresponding output so far

92
00:05:24,180 --> 00:05:31,170
everything is correct now assume second

93
00:05:27,810 --> 00:05:33,540
client comes and now connects to the

94
00:05:31,170 --> 00:05:36,030
server by accepting this connection

95
00:05:33,540 --> 00:05:39,180
server already violates the requirement

96
00:05:36,030 --> 00:05:42,559
but you can ask that okay why is it a

97
00:05:39,180 --> 00:05:45,090
big deal it's just a connection right

98
00:05:42,560 --> 00:05:47,880
let i'll tell you why is it a big deal

99
00:05:45,090 --> 00:05:50,310
now in this situation consider that the

100
00:05:47,880 --> 00:05:52,560
client once sends some command some new

101
00:05:50,310 --> 00:05:54,900
commands to the server and the server

102
00:05:52,560 --> 00:05:57,780
was supposed to send back the output to

103
00:05:54,900 --> 00:05:59,969
client one but in reality what it does

104
00:05:57,780 --> 00:06:02,190
it sends back output to both the clients

105
00:05:59,970 --> 00:06:06,120
even if client to does not did not send

106
00:06:02,190 --> 00:06:07,830
the command so thus it shows that how it

107
00:06:06,120 --> 00:06:11,610
affects the confidentiality of the

108
00:06:07,830 --> 00:06:13,770
protocol and this is an example of real

109
00:06:11,610 --> 00:06:15,480
non-compliance that we have found in the

110
00:06:13,770 --> 00:06:18,479
quantity still net server implementation

111
00:06:15,480 --> 00:06:21,690
and it shows that implementation needs

112
00:06:18,480 --> 00:06:25,250
to be checked for compliances with you

113
00:06:21,690 --> 00:06:29,160
the specifications prior to deployment

114
00:06:25,250 --> 00:06:31,080
now next even if you have an

115
00:06:29,160 --> 00:06:32,520
implementation that is compliant with

116
00:06:31,080 --> 00:06:35,969
its requirement or which is a

117
00:06:32,520 --> 00:06:37,320
specification it can happen that at the

118
00:06:35,970 --> 00:06:39,390
presence of an attacker in an

119
00:06:37,320 --> 00:06:41,760
adversarial environment these

120
00:06:39,390 --> 00:06:45,810
implementations may lead to some hidden

121
00:06:41,760 --> 00:06:48,270
vulnerabilities which are only I mean

122
00:06:45,810 --> 00:06:51,380
these vulnerabilities are only can only

123
00:06:48,270 --> 00:06:54,510
manifest in an adversarial environment

124
00:06:51,380 --> 00:06:57,330
examples include Apple go to fail which

125
00:06:54,510 --> 00:07:00,140
you may have heard about that openssl

126
00:06:57,330 --> 00:07:03,390
heartbleed bug and so on and so forth

127
00:07:00,140 --> 00:07:06,750
then these vulnerabilities can cause

128
00:07:03,390 --> 00:07:08,460
security consequences or sometimes they

129
00:07:06,750 --> 00:07:14,280
can degrade the expected performance of

130
00:07:08,460 --> 00:07:17,669
the protocol right so now I will give an

131
00:07:14,280 --> 00:07:20,880
example of a real example of these of

132
00:07:17,670 --> 00:07:23,760
such berliner abilities aodv is a

133
00:07:20,880 --> 00:07:27,180
routing protocol that was designed for

134
00:07:23,760 --> 00:07:27,760
wireless ad-hoc networks in insert in

135
00:07:27,180 --> 00:07:31,810
the air

136
00:07:27,760 --> 00:07:34,150
what happens is that their loads for the

137
00:07:31,810 --> 00:07:36,270
routing purpose they don't rely on any

138
00:07:34,150 --> 00:07:38,229
dedicated routers instead they use

139
00:07:36,270 --> 00:07:41,890
themselves they act as routers

140
00:07:38,230 --> 00:07:43,540
throughout their own packets so aodv uu

141
00:07:41,890 --> 00:07:47,110
is in a specific implementation of that

142
00:07:43,540 --> 00:07:49,630
routing protocol so let's consider we

143
00:07:47,110 --> 00:07:52,000
have a network of eight such nodes each

144
00:07:49,630 --> 00:07:54,760
of them is running this aodv uu

145
00:07:52,000 --> 00:07:57,250
implementation we have the source and

146
00:07:54,760 --> 00:08:00,789
the destination and we have also a

147
00:07:57,250 --> 00:08:02,590
compromise node in the network now to

148
00:08:00,790 --> 00:08:05,380
transfer data from the source to the

149
00:08:02,590 --> 00:08:08,739
destination the source needs to have a

150
00:08:05,380 --> 00:08:09,969
route to the destination and if it

151
00:08:08,740 --> 00:08:12,580
doesn't know the route to the

152
00:08:09,970 --> 00:08:15,550
destination what it will do the source

153
00:08:12,580 --> 00:08:18,909
will skill source will broadcast route

154
00:08:15,550 --> 00:08:20,350
request message and the neighboring

155
00:08:18,910 --> 00:08:23,380
nodes will receive that route request

156
00:08:20,350 --> 00:08:26,050
message now assume that neighboring node

157
00:08:23,380 --> 00:08:29,260
into does not have any information about

158
00:08:26,050 --> 00:08:30,850
the destination so then it will

159
00:08:29,260 --> 00:08:32,770
rebroadcast the route request message

160
00:08:30,850 --> 00:08:35,560
now once this message will be received

161
00:08:32,770 --> 00:08:38,319
by the compromise not what it can do it

162
00:08:35,559 --> 00:08:40,209
will change the type of the message for

163
00:08:38,320 --> 00:08:43,210
example to create a malformed route

164
00:08:40,210 --> 00:08:44,950
request message and rebroadcast in now

165
00:08:43,210 --> 00:08:47,350
whoever receives this mal from message

166
00:08:44,950 --> 00:08:50,800
they will crash while processing this

167
00:08:47,350 --> 00:08:53,680
message and as a result it will create

168
00:08:50,800 --> 00:08:55,689
partitions in the network and thus it

169
00:08:53,680 --> 00:08:59,469
can affect availability of your network

170
00:08:55,690 --> 00:09:02,700
and this is a real vulnerability that we

171
00:08:59,470 --> 00:09:06,010
are found in the aod vu implementation

172
00:09:02,700 --> 00:09:08,080
now such incidents advocate for

173
00:09:06,010 --> 00:09:09,970
adversarial testing to ensure the

174
00:09:08,080 --> 00:09:14,620
robustness of the implementation prior

175
00:09:09,970 --> 00:09:16,810
to their deployment so that's why in

176
00:09:14,620 --> 00:09:19,840
this talk I'm going to ask about to

177
00:09:16,810 --> 00:09:22,180
research questions the first question is

178
00:09:19,840 --> 00:09:24,850
that can we automatically detect

179
00:09:22,180 --> 00:09:27,699
specification non-compliance in protocol

180
00:09:24,850 --> 00:09:29,850
implementations so that we can have a

181
00:09:27,700 --> 00:09:34,690
more compliant implementations and

182
00:09:29,850 --> 00:09:37,000
second can we find attacks in the the in

183
00:09:34,690 --> 00:09:39,580
protocol implementations using automated

184
00:09:37,000 --> 00:09:40,400
adversarial testing so that we can have

185
00:09:39,580 --> 00:09:42,170
a more

186
00:09:40,400 --> 00:09:48,350
robust implementation prior to

187
00:09:42,170 --> 00:09:53,540
deployment right now let's look at the

188
00:09:48,350 --> 00:09:55,970
non-compliance detection so as I said at

189
00:09:53,540 --> 00:09:57,620
the beginning that the protocols are

190
00:09:55,970 --> 00:09:59,060
implementation of the protocol's are

191
00:09:57,620 --> 00:10:01,550
expected to comply with their

192
00:09:59,060 --> 00:10:05,079
requirements which is also known as

193
00:10:01,550 --> 00:10:08,060
properties so these properties as we're

194
00:10:05,080 --> 00:10:12,130
specify desired functional requirements

195
00:10:08,060 --> 00:10:16,219
of the protocols and they are usually

196
00:10:12,130 --> 00:10:18,800
described in there in an inn what is

197
00:10:16,220 --> 00:10:21,500
that called informal prose specification

198
00:10:18,800 --> 00:10:23,060
so in you know in other words like you

199
00:10:21,500 --> 00:10:24,830
may have seen like some of the RFC

200
00:10:23,060 --> 00:10:27,589
standards like the protocol that are

201
00:10:24,830 --> 00:10:31,130
described in RFC s so those standards

202
00:10:27,590 --> 00:10:36,140
are quite informal and prose description

203
00:10:31,130 --> 00:10:38,960
of the protocols so now let me show you

204
00:10:36,140 --> 00:10:41,840
an example of such a properties this

205
00:10:38,960 --> 00:10:45,980
example is taken from the RFC of telnet

206
00:10:41,840 --> 00:10:48,380
RFC and UK as you can see is very prose

207
00:10:45,980 --> 00:10:50,900
description of the property in simple

208
00:10:48,380 --> 00:10:55,570
words what it means that if a node

209
00:10:50,900 --> 00:10:58,340
receives a will command it must send a

210
00:10:55,570 --> 00:11:00,470
reply with a do or a don't command

211
00:10:58,340 --> 00:11:02,690
command so this will and don't are like

212
00:11:00,470 --> 00:11:04,280
specific to the telnet protocol whoever

213
00:11:02,690 --> 00:11:06,020
knows about the details they will know

214
00:11:04,280 --> 00:11:10,540
that what do they mean but I will not go

215
00:11:06,020 --> 00:11:13,760
into the detail about that moreover if

216
00:11:10,540 --> 00:11:16,219
implementations that are targeted for

217
00:11:13,760 --> 00:11:19,910
resource-constrained devices like IOT

218
00:11:16,220 --> 00:11:23,120
devices those implementations are often

219
00:11:19,910 --> 00:11:25,760
highly optimized due to the underlying

220
00:11:23,120 --> 00:11:28,610
resource constraint of this a constraint

221
00:11:25,760 --> 00:11:33,439
neighs of these devices and which may

222
00:11:28,610 --> 00:11:37,070
lead to non-compliances so our problem

223
00:11:33,440 --> 00:11:39,430
statement goes as follows given an even

224
00:11:37,070 --> 00:11:43,220
driven network protocol implementation p

225
00:11:39,430 --> 00:11:46,910
how can we check whether p violates the

226
00:11:43,220 --> 00:11:49,610
given requirements however we do not

227
00:11:46,910 --> 00:11:54,889
want to find low-level bugs or memory

228
00:11:49,610 --> 00:11:58,429
errors in this work right okay

229
00:11:54,889 --> 00:12:02,509
now to tackle this problem we have to

230
00:11:58,429 --> 00:12:04,129
deal with some challenges for first that

231
00:12:02,509 --> 00:12:08,209
network protocols are inherently

232
00:12:04,129 --> 00:12:10,429
event-driven and which involves a lot of

233
00:12:08,209 --> 00:12:13,419
complex interactions between its

234
00:12:10,429 --> 00:12:16,549
multiple participants second

235
00:12:13,419 --> 00:12:19,069
non-compliance needs to be checked on

236
00:12:16,549 --> 00:12:22,819
the implementation not on their abstract

237
00:12:19,069 --> 00:12:24,829
design right so that means that we have

238
00:12:22,819 --> 00:12:27,858
to deal with the low-level details and

239
00:12:24,829 --> 00:12:30,199
code complexity and third that

240
00:12:27,859 --> 00:12:32,119
non-compliance can often occur deep in

241
00:12:30,199 --> 00:12:37,008
the execution of the network protocol

242
00:12:32,119 --> 00:12:38,749
which can which can often I mean what do

243
00:12:37,009 --> 00:12:42,529
I mean by deep in the execution is like

244
00:12:38,749 --> 00:12:45,949
after an intricate sequence of events

245
00:12:42,529 --> 00:12:50,389
happens then you may see that as some

246
00:12:45,949 --> 00:12:52,128
non-compliance happened and and there

247
00:12:50,389 --> 00:12:57,230
can be an exponential number of

248
00:12:52,129 --> 00:13:00,439
arbitrary long sequences so let's take a

249
00:12:57,230 --> 00:13:04,029
look at the some existing approaches in

250
00:13:00,439 --> 00:13:06,738
place to address these problems so

251
00:13:04,029 --> 00:13:08,660
they're primarily there are two types of

252
00:13:06,739 --> 00:13:11,809
approaches to deal with this kind of

253
00:13:08,660 --> 00:13:13,910
problem first testing approaches but

254
00:13:11,809 --> 00:13:17,629
oftentimes these chasing approaches are

255
00:13:13,910 --> 00:13:21,889
either I mean manual and they are

256
00:13:17,629 --> 00:13:24,829
error-prone sometimes they liave even

257
00:13:21,889 --> 00:13:27,889
leave some portion of the protocol some

258
00:13:24,829 --> 00:13:30,998
portion of the Explorer code unexplored

259
00:13:27,889 --> 00:13:34,999
because of developers inability to

260
00:13:30,999 --> 00:13:41,839
reason about those cases did I change

261
00:13:34,999 --> 00:13:43,069
something here no okay so yeah I'm just

262
00:13:41,839 --> 00:13:45,889
saying like you guys cannot see the

263
00:13:43,069 --> 00:13:47,959
slide in that yeah we we got on the

264
00:13:45,889 --> 00:13:50,589
display a picture of the room rather

265
00:13:47,959 --> 00:13:50,589
than the slides

266
00:13:53,240 --> 00:13:57,540
we're picking up on the display a

267
00:13:55,380 --> 00:14:11,370
picture of the room rather than the

268
00:13:57,540 --> 00:14:14,219
slides mention it to him okay yeah we'll

269
00:14:11,370 --> 00:14:17,370
just likes here I thought that I did

270
00:14:14,220 --> 00:14:19,970
something it shouldn't happen in just a

271
00:14:17,370 --> 00:14:19,970
pointer

272
00:14:39,899 --> 00:14:47,759
yes this is a non-compliant that's true

273
00:14:44,610 --> 00:14:47,759
that's true

274
00:15:09,160 --> 00:15:14,600
okay i guess i can continue with what or

275
00:15:12,830 --> 00:15:15,890
maybe that would be helpful like if you

276
00:15:14,600 --> 00:15:18,590
guys could have seen the slides anyway

277
00:15:15,890 --> 00:15:20,180
so what i was talking that the existing

278
00:15:18,590 --> 00:15:21,590
approaches of doing that and then one

279
00:15:20,180 --> 00:15:23,900
approach was like a testing the

280
00:15:21,590 --> 00:15:30,410
implementation and the testing

281
00:15:23,900 --> 00:15:33,770
implementation is it ok ok ok I will try

282
00:15:30,410 --> 00:15:35,449
to explain so what I was saying that you

283
00:15:33,770 --> 00:15:38,569
can test the implementation that's one

284
00:15:35,450 --> 00:15:40,280
approach but most of that I mean most of

285
00:15:38,570 --> 00:15:41,990
the time these implementations are the

286
00:15:40,280 --> 00:15:43,850
testing approaches are manual and

287
00:15:41,990 --> 00:15:46,070
error-prone and sometimes they leave

288
00:15:43,850 --> 00:15:48,290
some portion of the code unexplored

289
00:15:46,070 --> 00:15:49,700
because developers inability that they

290
00:15:48,290 --> 00:15:51,949
cannot figure out length they did not

291
00:15:49,700 --> 00:15:53,870
write those kind of test cases that's

292
00:15:51,950 --> 00:15:55,160
one approach and the other approach that

293
00:15:53,870 --> 00:15:58,490
involves model checking the

294
00:15:55,160 --> 00:16:02,300
implementation what it does that you

295
00:15:58,490 --> 00:16:04,430
model check your implementation and it

296
00:16:02,300 --> 00:16:06,439
tries to explore every state of the

297
00:16:04,430 --> 00:16:08,500
implementation and see that if your

298
00:16:06,440 --> 00:16:11,870
requirements satisfied in all possible

299
00:16:08,500 --> 00:16:14,600
all reachable States but all the

300
00:16:11,870 --> 00:16:17,330
existing approaches they fall short due

301
00:16:14,600 --> 00:16:20,270
to some for due to some reasons like

302
00:16:17,330 --> 00:16:22,100
either some of them I mean I mean some

303
00:16:20,270 --> 00:16:25,100
of them require very restrictive form of

304
00:16:22,100 --> 00:16:26,780
properties while some of them are very

305
00:16:25,100 --> 00:16:32,170
language dependent programming language

306
00:16:26,780 --> 00:16:35,750
dependent and some has the rare some our

307
00:16:32,170 --> 00:16:37,969
approaches have very impress eyes in a

308
00:16:35,750 --> 00:16:45,040
sense that because because of their

309
00:16:37,970 --> 00:16:45,040
underlying syntactic approach so ok

310
00:16:47,610 --> 00:16:58,329
maybe I can the way to continue I think

311
00:16:54,819 --> 00:17:00,128
we have to continue because he's okay

312
00:16:58,329 --> 00:17:03,519
yeah it's he was trying things and it

313
00:17:00,129 --> 00:17:09,329
just it seems to be ah here we go he's

314
00:17:03,519 --> 00:17:12,400
got it back oh I was trying to do is

315
00:17:09,329 --> 00:17:20,428
okay so yeah I was talking about the

316
00:17:12,400 --> 00:17:20,429
modern taking approached right so is it

317
00:17:23,890 --> 00:17:37,040
okay okay for some reason it's working a

318
00:17:32,980 --> 00:17:40,790
pointer is working now okay so what we

319
00:17:37,040 --> 00:17:42,950
propose that we propose chiron an

320
00:17:40,790 --> 00:17:45,620
automated framework for compliance

321
00:17:42,950 --> 00:17:47,510
non-compliance detection which is

322
00:17:45,620 --> 00:17:49,699
designed for stateful even driven

323
00:17:47,510 --> 00:17:52,960
network protocol implementations it

324
00:17:49,700 --> 00:17:55,549
helps protocol developers to detect

325
00:17:52,960 --> 00:17:59,330
whether the implementation violates the

326
00:17:55,549 --> 00:18:01,520
given properties are not how moreover

327
00:17:59,330 --> 00:18:03,530
Karen does not make any restrictive

328
00:18:01,520 --> 00:18:05,660
assumption about the underlying stack or

329
00:18:03,530 --> 00:18:12,230
the behavior of other participants of

330
00:18:05,660 --> 00:18:15,470
the protocol we demonstrated chiron on

331
00:18:12,230 --> 00:18:17,480
five different implementation and found

332
00:18:15,470 --> 00:18:19,580
thin instances of non-compliance while

333
00:18:17,480 --> 00:18:22,910
checking against 18 protocol properties

334
00:18:19,580 --> 00:18:24,889
which these non-compliance have impact

335
00:18:22,910 --> 00:18:30,770
or implications on security and

336
00:18:24,890 --> 00:18:32,990
interoperability now before I move into

337
00:18:30,770 --> 00:18:34,780
the details of Cairo on let me show our

338
00:18:32,990 --> 00:18:37,210
of the let me show you guys our

339
00:18:34,780 --> 00:18:42,290
observation on network protocols our

340
00:18:37,210 --> 00:18:44,900
first observation is that protocol

341
00:18:42,290 --> 00:18:48,080
operations are often described as finite

342
00:18:44,900 --> 00:18:50,450
state machines which these finite state

343
00:18:48,080 --> 00:18:53,418
machines dictates the internal state of

344
00:18:50,450 --> 00:18:55,580
the protocol and it also specifies under

345
00:18:53,419 --> 00:18:57,049
which conditions the protocol will make

346
00:18:55,580 --> 00:19:00,770
a transition from one state to another

347
00:18:57,049 --> 00:19:04,309
here you can see an example of the of an

348
00:19:00,770 --> 00:19:08,679
FSM which of an hypothetical protocol

349
00:19:04,309 --> 00:19:11,210
right so the second observation is that

350
00:19:08,679 --> 00:19:14,600
implementation tends to follow closely

351
00:19:11,210 --> 00:19:17,150
follow the space specified FSM or the

352
00:19:14,600 --> 00:19:19,850
described FSM in the order if ism that

353
00:19:17,150 --> 00:19:22,309
was described in the specification here

354
00:19:19,850 --> 00:19:25,040
in this a code example you can see that

355
00:19:22,309 --> 00:19:26,510
that whenever it receives a request it

356
00:19:25,040 --> 00:19:29,720
tries to send the response and change

357
00:19:26,510 --> 00:19:31,680
that state and our third observation is

358
00:19:29,720 --> 00:19:35,610
that

359
00:19:31,680 --> 00:19:39,060
this one is not working okay I have to

360
00:19:35,610 --> 00:19:41,399
get back here okay our third observation

361
00:19:39,060 --> 00:19:44,780
is that non-compliance is often caused

362
00:19:41,400 --> 00:19:47,370
by how the implementation is

363
00:19:44,780 --> 00:19:51,360
implementation handles these network

364
00:19:47,370 --> 00:19:53,639
events for example in this code I mean

365
00:19:51,360 --> 00:19:56,840
in this code a code example you can see

366
00:19:53,640 --> 00:19:59,610
that even after receiving an ACK the

367
00:19:56,840 --> 00:20:01,560
implementation is not moving to the

368
00:19:59,610 --> 00:20:06,060
radius dead instead it was waiting in

369
00:20:01,560 --> 00:20:12,120
the waiting state and that is a non

370
00:20:06,060 --> 00:20:17,220
compliance right now let me give you an

371
00:20:12,120 --> 00:20:20,790
high level approach of Cairo on given a

372
00:20:17,220 --> 00:20:23,990
protocol source Cairo tries to extract

373
00:20:20,790 --> 00:20:26,960
the innocent that was implemented in the

374
00:20:23,990 --> 00:20:30,810
impaired in the source and we get an

375
00:20:26,960 --> 00:20:32,910
extracted protocol fsm now given the

376
00:20:30,810 --> 00:20:34,970
desired properties which is a spacer

377
00:20:32,910 --> 00:20:40,290
which is derived from the specification

378
00:20:34,970 --> 00:20:44,670
we fit the properties and the extracted

379
00:20:40,290 --> 00:20:46,710
fsm into a model checker where the model

380
00:20:44,670 --> 00:20:49,050
checker does it checks whether the

381
00:20:46,710 --> 00:20:52,200
extracted fsm satisfies the given

382
00:20:49,050 --> 00:20:55,110
properties if not that means there is a

383
00:20:52,200 --> 00:20:58,680
violation and then it will report the

384
00:20:55,110 --> 00:21:03,330
violation now let's take a look at each

385
00:20:58,680 --> 00:21:05,610
of the block step by step so let's start

386
00:21:03,330 --> 00:21:08,429
with the protocol source so here is an

387
00:21:05,610 --> 00:21:10,620
example whole showing how an even driven

388
00:21:08,430 --> 00:21:13,470
protocol even driven implementation

389
00:21:10,620 --> 00:21:17,939
looks like it usually starts with a main

390
00:21:13,470 --> 00:21:19,410
that has an event loop or it's usually

391
00:21:17,940 --> 00:21:22,140
called an even loop where it is stace

392
00:21:19,410 --> 00:21:25,380
it's for an listens for a next event and

393
00:21:22,140 --> 00:21:28,410
whenever it listens if I gets a new

394
00:21:25,380 --> 00:21:31,650
event it calls a dispatch function where

395
00:21:28,410 --> 00:21:34,920
it tries to call the appropriate handler

396
00:21:31,650 --> 00:21:38,310
to handle that appropriate event for

397
00:21:34,920 --> 00:21:40,700
example when even X occurs the execution

398
00:21:38,310 --> 00:21:45,070
flows from dispatch to handler X

399
00:21:40,700 --> 00:21:47,850
similarly for event y execution follows

400
00:21:45,070 --> 00:21:52,240
dispatch function and then calls the

401
00:21:47,850 --> 00:21:53,918
handle why so typically this kind of

402
00:21:52,240 --> 00:21:56,320
implementation also maintains some state

403
00:21:53,919 --> 00:21:58,990
variables in this example we are showing

404
00:21:56,320 --> 00:22:02,740
that s I've been here we are showing an

405
00:21:58,990 --> 00:22:04,779
state variable that is s here is an

406
00:22:02,740 --> 00:22:08,350
example of an handler how does it look

407
00:22:04,779 --> 00:22:10,269
like so oftentimes this handler also

408
00:22:08,350 --> 00:22:12,279
changed the state of the protocol for

409
00:22:10,269 --> 00:22:15,039
example here is showing that s is equal

410
00:22:12,279 --> 00:22:19,179
to 2 it's changing from state 1 to state

411
00:22:15,039 --> 00:22:22,570
2 so for our analysis we require the

412
00:22:19,179 --> 00:22:25,480
source in addition we also require that

413
00:22:22,570 --> 00:22:28,960
the name of the state variables in this

414
00:22:25,480 --> 00:22:31,360
case s the protocol entry function which

415
00:22:28,960 --> 00:22:34,090
is the dispatch function which are

416
00:22:31,360 --> 00:22:37,090
handles and dispatch all the events and

417
00:22:34,090 --> 00:22:42,309
call appropriate handlers and the list

418
00:22:37,090 --> 00:22:44,799
of network events okay so let's take a

419
00:22:42,309 --> 00:22:49,000
look at the fsm extractor how does it

420
00:22:44,799 --> 00:22:50,860
work before that the question is that ok

421
00:22:49,000 --> 00:22:52,570
f is an extraction I mean it sounds

422
00:22:50,860 --> 00:22:56,019
challenging or something or difficult

423
00:22:52,570 --> 00:22:58,330
let's say why is it difficult this

424
00:22:56,019 --> 00:23:02,860
example these two diagrams will tell you

425
00:22:58,330 --> 00:23:06,189
why is it difficult this is a fsm r2f

426
00:23:02,860 --> 00:23:09,158
SMS of the same protocol telnet in the

427
00:23:06,190 --> 00:23:12,149
air in this example the left one is the

428
00:23:09,159 --> 00:23:15,490
nicer looking one and very complex

429
00:23:12,149 --> 00:23:18,129
compact fsm that is a film that is

430
00:23:15,490 --> 00:23:20,559
derived from the specification whereas

431
00:23:18,129 --> 00:23:23,049
on the right one on the right side you

432
00:23:20,559 --> 00:23:26,080
have sm that is extracted from an

433
00:23:23,049 --> 00:23:28,149
implementations of the telnet protocol

434
00:23:26,080 --> 00:23:31,658
so as you can see the number of

435
00:23:28,149 --> 00:23:33,758
transition is there are large number of

436
00:23:31,659 --> 00:23:39,549
transition we have noticed in the

437
00:23:33,759 --> 00:23:43,090
implementation so therefore the manually

438
00:23:39,549 --> 00:23:45,220
deriving or extracting these MF SMS from

439
00:23:43,090 --> 00:23:48,309
the implementation is definitely

440
00:23:45,220 --> 00:23:50,379
error-prone and time consuming also

441
00:23:48,309 --> 00:23:55,600
extracting fsm with relevant details for

442
00:23:50,379 --> 00:23:57,610
analysis it is challenging so now let's

443
00:23:55,600 --> 00:23:58,800
take a look at existing approaches that

444
00:23:57,610 --> 00:24:02,580
try to

445
00:23:58,800 --> 00:24:06,870
extract fsm from the source the first

446
00:24:02,580 --> 00:24:08,939
were but they do fall short in our in

447
00:24:06,870 --> 00:24:12,030
our case because we cannot use them

448
00:24:08,940 --> 00:24:14,940
their due to following reasons the

449
00:24:12,030 --> 00:24:18,600
approaches that rely on network crises

450
00:24:14,940 --> 00:24:21,780
that are inherently incomplete and some

451
00:24:18,600 --> 00:24:24,330
of them tries to extract only a sequence

452
00:24:21,780 --> 00:24:27,360
of messages that are valid in a session

453
00:24:24,330 --> 00:24:31,320
rather than the internal protocol fsm

454
00:24:27,360 --> 00:24:34,590
that was implemented and some some

455
00:24:31,320 --> 00:24:38,820
approaches were able to extract fsm out

456
00:24:34,590 --> 00:24:41,760
of the source but they are low-level

457
00:24:38,820 --> 00:24:45,139
program fsm not the high level protocol

458
00:24:41,760 --> 00:24:48,780
fsm that we are talking about so

459
00:24:45,140 --> 00:24:51,060
therefore we design our own fsm

460
00:24:48,780 --> 00:24:53,610
extractor and here's the key idea of how

461
00:24:51,060 --> 00:24:57,629
does it work I'll go into the details in

462
00:24:53,610 --> 00:25:00,959
a bit the first we simulate the protocol

463
00:24:57,630 --> 00:25:03,270
execution using symbolic execution then

464
00:25:00,960 --> 00:25:05,970
during the execution we collect program

465
00:25:03,270 --> 00:25:08,790
state information and constraints along

466
00:25:05,970 --> 00:25:11,640
each execution path and then from there

467
00:25:08,790 --> 00:25:15,170
we extract fsm state and transitions

468
00:25:11,640 --> 00:25:19,470
from the collected information now

469
00:25:15,170 --> 00:25:22,920
before telling you how does it work I'll

470
00:25:19,470 --> 00:25:28,410
give you a brief intro to about symbolic

471
00:25:22,920 --> 00:25:30,180
execution so symbolic execution the in a

472
00:25:28,410 --> 00:25:32,910
nutshell the way it works is that it

473
00:25:30,180 --> 00:25:37,980
executes a program on symbolic value

474
00:25:32,910 --> 00:25:41,190
rather than concrete values so I'll give

475
00:25:37,980 --> 00:25:44,610
you an example here that you consider

476
00:25:41,190 --> 00:25:46,560
this code example where we have main in

477
00:25:44,610 --> 00:25:49,169
the main function we have two inputs X

478
00:25:46,560 --> 00:25:51,210
and Y these are symbolic inputs and then

479
00:25:49,170 --> 00:25:54,840
they will call the let's say we are

480
00:25:51,210 --> 00:25:58,830
executing the code and after X and you

481
00:25:54,840 --> 00:26:02,550
will then it will call the function with

482
00:25:58,830 --> 00:26:04,830
x and y since x and y both are symbolic

483
00:26:02,550 --> 00:26:06,330
they don't have any concrete values they

484
00:26:04,830 --> 00:26:08,760
have symbolic values in this case let's

485
00:26:06,330 --> 00:26:11,909
say we are using a and B that represents

486
00:26:08,760 --> 00:26:16,560
it can take any value from its possible

487
00:26:11,910 --> 00:26:19,690
domain so after executing the first line

488
00:26:16,560 --> 00:26:24,100
that is a professor statement Z becomes

489
00:26:19,690 --> 00:26:26,320
twice be now it hits a conditional

490
00:26:24,100 --> 00:26:30,149
branch where it tries to check that

491
00:26:26,320 --> 00:26:34,149
whether Z and X are equal or not not

492
00:26:30,150 --> 00:26:38,290
since both of them are symbolic the I

493
00:26:34,150 --> 00:26:41,020
mean in the execution engine or the

494
00:26:38,290 --> 00:26:43,990
symbolic ignition it cannot decide which

495
00:26:41,020 --> 00:26:47,889
branch is infeasible so it needs to

496
00:26:43,990 --> 00:26:50,170
follow both the branch so let's say

497
00:26:47,890 --> 00:26:51,880
first it takes the false branch and adds

498
00:26:50,170 --> 00:26:54,870
this condition that twice B is not equal

499
00:26:51,880 --> 00:26:58,480
to a as a constraint of this path and

500
00:26:54,870 --> 00:27:00,729
then if you see the example it returns

501
00:26:58,480 --> 00:27:04,330
from the function and also terminates

502
00:27:00,730 --> 00:27:07,120
the program and this condition becomes a

503
00:27:04,330 --> 00:27:09,939
constraint for that particular execution

504
00:27:07,120 --> 00:27:12,189
path of the program right now if

505
00:27:09,940 --> 00:27:15,930
required you can solve this constraint

506
00:27:12,190 --> 00:27:18,370
to get a concrete values for the input

507
00:27:15,930 --> 00:27:22,450
for example in this case we get these

508
00:27:18,370 --> 00:27:25,719
two input values for where m x is 0 Y is

509
00:27:22,450 --> 00:27:28,120
1 so now if you use these values the

510
00:27:25,720 --> 00:27:31,270
program will always take this execution

511
00:27:28,120 --> 00:27:33,850
branch right so that means like each

512
00:27:31,270 --> 00:27:37,240
execution branch will be represented by

513
00:27:33,850 --> 00:27:39,699
their unique path constraint now we had

514
00:27:37,240 --> 00:27:42,790
another path that we did not explore yet

515
00:27:39,700 --> 00:27:45,580
that is the true branch now you continue

516
00:27:42,790 --> 00:27:49,360
with the two branch and next you hit

517
00:27:45,580 --> 00:27:51,100
another conditional branch again to both

518
00:27:49,360 --> 00:27:53,530
the branches are possible I mean

519
00:27:51,100 --> 00:27:58,090
feasible so the execution needs to

520
00:27:53,530 --> 00:27:59,830
follow both the branches and then again

521
00:27:58,090 --> 00:28:01,870
you take the false branch and you get

522
00:27:59,830 --> 00:28:04,270
the true branch you have different

523
00:28:01,870 --> 00:28:08,469
different path constraint for each

524
00:28:04,270 --> 00:28:13,080
execution path so one important thing

525
00:28:08,470 --> 00:28:16,360
notice here is that II that in general

526
00:28:13,080 --> 00:28:18,429
symbolic executions you need to mark

527
00:28:16,360 --> 00:28:21,310
those input variables at the program

528
00:28:18,430 --> 00:28:22,900
input variables as symbolic so that when

529
00:28:21,310 --> 00:28:26,080
it's running it knows that which are the

530
00:28:22,900 --> 00:28:33,290
which variables are symbolic and

531
00:28:26,080 --> 00:28:35,949
now I really wanted to use this one but

532
00:28:33,290 --> 00:28:38,149
anywhere is not working properly so

533
00:28:35,950 --> 00:28:40,040
early now I will walk you through an

534
00:28:38,150 --> 00:28:43,340
example to explain how our fsm

535
00:28:40,040 --> 00:28:46,700
extraction algorithm works let's start

536
00:28:43,340 --> 00:28:52,550
with let's say let's say we have three

537
00:28:46,700 --> 00:28:55,790
network events t0 t1 t2 and to start the

538
00:28:52,550 --> 00:28:59,870
symbolic execution we will load the

539
00:28:55,790 --> 00:29:01,790
program and we we call this a that's the

540
00:28:59,870 --> 00:29:03,500
initial state of the program we call

541
00:29:01,790 --> 00:29:06,320
this program state as I denote the

542
00:29:03,500 --> 00:29:11,480
program so that a 0 and for clarity we

543
00:29:06,320 --> 00:29:14,990
also call it execution stay now in this

544
00:29:11,480 --> 00:29:18,320
example we will consider that s variable

545
00:29:14,990 --> 00:29:24,980
is defines the protocol fsm state

546
00:29:18,320 --> 00:29:28,100
variable or so now we can extract the

547
00:29:24,980 --> 00:29:31,460
our efficient state from this program

548
00:29:28,100 --> 00:29:34,100
execution state and what we get is f0

549
00:29:31,460 --> 00:29:37,490
where s is equal to 0 if you notice that

550
00:29:34,100 --> 00:29:41,030
the this f-zero contains only the

551
00:29:37,490 --> 00:29:44,180
variable information of s right or is

552
00:29:41,030 --> 00:29:47,030
infirm information of s so we call them

553
00:29:44,180 --> 00:29:50,750
fsm esta just for clarity we also

554
00:29:47,030 --> 00:29:53,360
maintain a queue where we store the

555
00:29:50,750 --> 00:29:56,840
execution is take that needs to be

556
00:29:53,360 --> 00:29:59,179
explored further for our analysis so

557
00:29:56,840 --> 00:30:01,159
since we have an exploit a 0 yet we'll

558
00:29:59,180 --> 00:30:04,520
just keep it in the cube and start

559
00:30:01,160 --> 00:30:08,290
executing from there so now what we do

560
00:30:04,520 --> 00:30:11,660
we will try all the network events on

561
00:30:08,290 --> 00:30:15,590
the execution state so that means that

562
00:30:11,660 --> 00:30:17,420
let's say we trigger t0 on the execution

563
00:30:15,590 --> 00:30:20,179
steady 0 and it ends up with an

564
00:30:17,420 --> 00:30:22,250
execution state e 1 so this execution

565
00:30:20,180 --> 00:30:24,440
state represents the program estate if

566
00:30:22,250 --> 00:30:26,450
you remember from the example that was

567
00:30:24,440 --> 00:30:30,200
showing for even driven implementation

568
00:30:26,450 --> 00:30:31,700
it is a it is the program state when the

569
00:30:30,200 --> 00:30:35,150
program returns from the dispatch

570
00:30:31,700 --> 00:30:38,750
function right so if you have noticed

571
00:30:35,150 --> 00:30:41,210
that here now we can extract the

572
00:30:38,750 --> 00:30:43,460
fsm estate from out of in and the very

573
00:30:41,210 --> 00:30:45,950
variable has changed the value of the

574
00:30:43,460 --> 00:30:49,160
variable has changed from s 0 is equal

575
00:30:45,950 --> 00:30:51,110
to 0 2 now it's s equal to 1 now this is

576
00:30:49,160 --> 00:30:53,930
a new efficient estate we haven't seen

577
00:30:51,110 --> 00:31:00,590
yet so that's why we add it to our graph

578
00:30:53,930 --> 00:31:03,170
and we also add a transition from f 0 f

579
00:31:00,590 --> 00:31:05,899
0 is our current transition from f0 to

580
00:31:03,170 --> 00:31:08,810
f1 with a condition that is a

581
00:31:05,900 --> 00:31:13,180
combination of the network event and the

582
00:31:08,810 --> 00:31:17,210
path constraint from easy row to e1 and

583
00:31:13,180 --> 00:31:19,600
also since this f1 is a new stay fsm

584
00:31:17,210 --> 00:31:23,360
state we will keep the corresponding

585
00:31:19,600 --> 00:31:27,439
execution estate in our queue so that we

586
00:31:23,360 --> 00:31:29,810
can explore it further similarly we'll

587
00:31:27,440 --> 00:31:33,440
try the next network event on easy row

588
00:31:29,810 --> 00:31:35,230
and let's say it did not change any the

589
00:31:33,440 --> 00:31:38,600
value of the state variable and

590
00:31:35,230 --> 00:31:41,540
therefore we don't get any new state but

591
00:31:38,600 --> 00:31:45,290
we have a new transition which is

592
00:31:41,540 --> 00:31:47,690
essentially a self loop then let's say

593
00:31:45,290 --> 00:31:51,050
we try t1 we end up with another

594
00:31:47,690 --> 00:31:53,360
execution state where we have a new

595
00:31:51,050 --> 00:31:57,980
efficient state because s is equal to 2

596
00:31:53,360 --> 00:32:01,689
we will add it to the graph and also add

597
00:31:57,980 --> 00:32:05,540
a transition from our current fsm estate

598
00:32:01,690 --> 00:32:08,570
with to the newly discovered official

599
00:32:05,540 --> 00:32:10,340
state and we also keep the execution is

600
00:32:08,570 --> 00:32:14,840
taking the queue because we need to

601
00:32:10,340 --> 00:32:18,139
explore that and now we are done with

602
00:32:14,840 --> 00:32:20,389
all the execution for easy row now we

603
00:32:18,140 --> 00:32:26,680
move on to the next execution state and

604
00:32:20,390 --> 00:32:29,510
then let's start again with t0 on e one

605
00:32:26,680 --> 00:32:34,850
similar now consider that we just ended

606
00:32:29,510 --> 00:32:38,900
up with a execution state where the fsm

607
00:32:34,850 --> 00:32:41,719
state is a is all because s equal to two

608
00:32:38,900 --> 00:32:43,370
we already have an efficient state f2

609
00:32:41,720 --> 00:32:44,930
which represents a sequel to to those it

610
00:32:43,370 --> 00:32:47,719
so there is no point of adding a new

611
00:32:44,930 --> 00:32:51,960
efficient step there but we will add a

612
00:32:47,720 --> 00:32:57,570
transition from ya from f12

613
00:32:51,960 --> 00:33:00,570
f 2 so this process continues until the

614
00:32:57,570 --> 00:33:02,189
entire Q becomes empty and then the

615
00:33:00,570 --> 00:33:07,220
algorithm terminates and returns this

616
00:33:02,190 --> 00:33:09,930
extracted fsm as an output so now as I

617
00:33:07,220 --> 00:33:13,710
showed on the high level approach that

618
00:33:09,930 --> 00:33:16,980
once we have these fsm extracted fsm we

619
00:33:13,710 --> 00:33:19,770
will feed it to the model checker so now

620
00:33:16,980 --> 00:33:21,150
we need to translate so the extracted

621
00:33:19,770 --> 00:33:23,610
efficient so that the model checker can

622
00:33:21,150 --> 00:33:26,880
understand so we do that in two steps in

623
00:33:23,610 --> 00:33:29,659
the first that we first maps atoms of

624
00:33:26,880 --> 00:33:32,400
each path constraint to an unique

625
00:33:29,660 --> 00:33:34,200
propositional variable because model

626
00:33:32,400 --> 00:33:36,510
checker don't understand that egg skater

627
00:33:34,200 --> 00:33:38,220
than zero what does it mean it's a model

628
00:33:36,510 --> 00:33:42,570
checker expects everything to be boolean

629
00:33:38,220 --> 00:33:45,180
variables so we map each constraint each

630
00:33:42,570 --> 00:33:47,520
atom to a boolean variable and store

631
00:33:45,180 --> 00:33:50,970
this information for our later use and

632
00:33:47,520 --> 00:33:53,550
in the second step we convert the

633
00:33:50,970 --> 00:33:55,290
extracted f ism to the modeling language

634
00:33:53,550 --> 00:34:00,590
that the model checker understands and

635
00:33:55,290 --> 00:34:04,710
the adults we get our a translated fsm

636
00:34:00,590 --> 00:34:10,469
now let's take a look at the property

637
00:34:04,710 --> 00:34:16,760
verification step as I said earlier that

638
00:34:10,469 --> 00:34:16,759
properties are disk okay

639
00:34:16,800 --> 00:34:22,310
No

640
00:34:19,520 --> 00:34:27,889
just working sometimes work sometimes

641
00:34:22,310 --> 00:34:31,790
doesn't okay yeah okay as I said earlier

642
00:34:27,889 --> 00:34:34,129
that the properties are described in

643
00:34:31,790 --> 00:34:35,929
their specification of the protocol or

644
00:34:34,130 --> 00:34:38,800
you can say the documentation of the

645
00:34:35,929 --> 00:34:41,270
protocol here is an example of a prob

646
00:34:38,800 --> 00:34:44,540
property that is taken from again taken

647
00:34:41,270 --> 00:34:47,120
from the telnet RFC and you can see it's

648
00:34:44,540 --> 00:34:51,469
pros description what it means in simple

649
00:34:47,120 --> 00:34:54,679
words is that if a node received two is

650
00:34:51,469 --> 00:34:59,209
equines back to back it must consider

651
00:34:54,679 --> 00:35:05,060
the second IC bite as a regular data so

652
00:34:59,210 --> 00:35:07,910
now in the next step the the next step

653
00:35:05,060 --> 00:35:10,340
the developer takes the atom proposition

654
00:35:07,910 --> 00:35:14,000
map that we build in the previous step

655
00:35:10,340 --> 00:35:19,340
and the extracted fsm and convert this

656
00:35:14,000 --> 00:35:21,920
protects your property into a property

657
00:35:19,340 --> 00:35:24,500
that's pltl format right heel TL is that

658
00:35:21,920 --> 00:35:28,460
propositional temporal logic format now

659
00:35:24,500 --> 00:35:31,010
in the final step we feed the translated

660
00:35:28,460 --> 00:35:33,730
fsm and this property to the model

661
00:35:31,010 --> 00:35:36,710
checker so the model checker tries to

662
00:35:33,730 --> 00:35:39,830
check that whether the translated fsm

663
00:35:36,710 --> 00:35:41,720
satisfies this property if it's

664
00:35:39,830 --> 00:35:45,410
satisfied it will say that the property

665
00:35:41,720 --> 00:35:48,879
is valid if it if it doesn't satisfy

666
00:35:45,410 --> 00:35:51,410
then it will present a counter example

667
00:35:48,880 --> 00:35:53,800
which means there is a violation and

668
00:35:51,410 --> 00:35:55,370
these counter-examples imply

669
00:35:53,800 --> 00:35:57,020
non-compliance that means that

670
00:35:55,370 --> 00:35:59,930
implementation does not comply with

671
00:35:57,020 --> 00:36:02,750
those requirements now you can ask what

672
00:35:59,930 --> 00:36:06,740
if this reported counter examples are

673
00:36:02,750 --> 00:36:10,460
false alarm yes these are possible so

674
00:36:06,740 --> 00:36:12,709
therefore we adopt we use some

675
00:36:10,460 --> 00:36:16,400
validation techniques to rule out such

676
00:36:12,710 --> 00:36:19,670
false positives so before that what is

677
00:36:16,400 --> 00:36:21,770
the counter example a counter example is

678
00:36:19,670 --> 00:36:25,220
a trace of the fsm that falsifies the

679
00:36:21,770 --> 00:36:29,900
property right here is a sample example

680
00:36:25,220 --> 00:36:33,439
so we want to ask the question that okay

681
00:36:29,900 --> 00:36:35,839
it's good that model Jacob gave has some

682
00:36:33,440 --> 00:36:37,819
conquer examples how can we make sure

683
00:36:35,839 --> 00:36:41,630
that this counter example actually

684
00:36:37,819 --> 00:36:44,750
exists in the code oh so to do that we

685
00:36:41,630 --> 00:36:46,730
use to a step validation process wherein

686
00:36:44,750 --> 00:36:49,069
the first step we first asked that

687
00:36:46,730 --> 00:36:51,710
whether the reported counter example is

688
00:36:49,069 --> 00:36:53,810
spurious or not if it is a spurious

689
00:36:51,710 --> 00:36:56,510
counter example we will guide the model

690
00:36:53,810 --> 00:36:58,190
checker so that it will not report the

691
00:36:56,510 --> 00:37:02,750
same experience counter checker in

692
00:36:58,190 --> 00:37:07,069
future and in the other case where it is

693
00:37:02,750 --> 00:37:10,069
not a spurious counter example we go

694
00:37:07,069 --> 00:37:12,589
move it to the next step and that is

695
00:37:10,069 --> 00:37:14,990
where we essentially concretely execute

696
00:37:12,589 --> 00:37:17,720
the counterexample to see that if it is

697
00:37:14,990 --> 00:37:20,450
actual if it if the counter example is

698
00:37:17,720 --> 00:37:24,348
realizable in an actual execution of the

699
00:37:20,450 --> 00:37:26,689
in protocol implementations if so only

700
00:37:24,349 --> 00:37:32,630
then we report the counter example as a

701
00:37:26,690 --> 00:37:34,220
non compliance I will I mean due to time

702
00:37:32,630 --> 00:37:36,710
limitation I will not go to the details

703
00:37:34,220 --> 00:37:39,709
of these validation steps so I will just

704
00:37:36,710 --> 00:37:42,470
move on to that our optimization so what

705
00:37:39,710 --> 00:37:44,869
we notice that we can optimize our

706
00:37:42,470 --> 00:37:48,259
efficient extraction algorithm all bit

707
00:37:44,869 --> 00:37:50,540
further so if you remember in in our

708
00:37:48,260 --> 00:37:53,329
algorithm we were trying all Network

709
00:37:50,540 --> 00:37:56,060
events in each of the execution steps so

710
00:37:53,329 --> 00:37:58,040
we realize that some of the sequence of

711
00:37:56,060 --> 00:38:02,828
network Givens that we were trying we're

712
00:37:58,040 --> 00:38:05,630
not feasible for example in case of TCP

713
00:38:02,829 --> 00:38:08,300
receiving my mania having a receive

714
00:38:05,630 --> 00:38:10,130
event before a connection event is not

715
00:38:08,300 --> 00:38:11,480
meaningful you first have to establish a

716
00:38:10,130 --> 00:38:15,859
connection then you can receive some

717
00:38:11,480 --> 00:38:18,050
packets right so therefore and we also

718
00:38:15,859 --> 00:38:20,779
observe that this infeasible network or

719
00:38:18,050 --> 00:38:25,310
order of network events can lead to many

720
00:38:20,780 --> 00:38:28,880
spurious transitions so so we allow

721
00:38:25,310 --> 00:38:32,380
developers to specify the feasible order

722
00:38:28,880 --> 00:38:35,300
of network events like the protocol

723
00:38:32,380 --> 00:38:37,460
implementing on top of TCP or UDP the

724
00:38:35,300 --> 00:38:39,680
developer can specify that ok this is

725
00:38:37,460 --> 00:38:42,650
the feasible order so I'll show you an

726
00:38:39,680 --> 00:38:44,509
example here like let's consider this

727
00:38:42,650 --> 00:38:45,680
example it says that at the beginning

728
00:38:44,510 --> 00:38:49,430
you have that

729
00:38:45,680 --> 00:38:51,109
as my only connection is possible once

730
00:38:49,430 --> 00:38:53,720
you get a connection then you can

731
00:38:51,110 --> 00:38:56,450
receive new packets or even an event

732
00:38:53,720 --> 00:38:59,810
that will close the connection so these

733
00:38:56,450 --> 00:39:03,259
are sample event model and this is the

734
00:38:59,810 --> 00:39:08,350
one that is the event model for of tcp

735
00:39:03,260 --> 00:39:08,350
from the implementation of contiki OS

736
00:39:08,440 --> 00:39:16,010
right ok so we implemented kyra on the

737
00:39:14,330 --> 00:39:18,380
official extractor was implemented on

738
00:39:16,010 --> 00:39:22,070
top of the key symbolic execution engine

739
00:39:18,380 --> 00:39:24,740
which is an open source engine and we

740
00:39:22,070 --> 00:39:27,830
added additional 4,000 lines of code for

741
00:39:24,740 --> 00:39:31,430
our extractor we also implemented as a

742
00:39:27,830 --> 00:39:34,310
translator since we are I mean we are

743
00:39:31,430 --> 00:39:37,669
using a new assembly model shaker we our

744
00:39:34,310 --> 00:39:40,009
translator can produce or translate the

745
00:39:37,670 --> 00:39:43,910
extracted fsm for that modeling language

746
00:39:40,010 --> 00:39:47,420
and for spurious counterexample checker

747
00:39:43,910 --> 00:39:53,330
we also built a tool on using some of

748
00:39:47,420 --> 00:39:55,930
the key libraries so for evolution we

749
00:39:53,330 --> 00:40:00,110
applied Chiron on five different

750
00:39:55,930 --> 00:40:03,109
implementations of two protocols and we

751
00:40:00,110 --> 00:40:05,840
found 10 instances of non-compliance

752
00:40:03,110 --> 00:40:08,240
while we were checking against 11-18

753
00:40:05,840 --> 00:40:15,370
properties 11 for telnet and seven for

754
00:40:08,240 --> 00:40:18,259
dhcp this result shows the impact of our

755
00:40:15,370 --> 00:40:22,400
optimizations the restricted even model

756
00:40:18,260 --> 00:40:24,140
means that the event model where it only

757
00:40:22,400 --> 00:40:26,270
considered feasible order of events

758
00:40:24,140 --> 00:40:28,490
whereas the non-restricted event model

759
00:40:26,270 --> 00:40:30,020
is that it considered infeasible or

760
00:40:28,490 --> 00:40:32,629
feasible order it considered all

761
00:40:30,020 --> 00:40:35,300
possible event order of events as you

762
00:40:32,630 --> 00:40:37,250
can see there are a lot of transitions

763
00:40:35,300 --> 00:40:45,170
in non-restricted event models and these

764
00:40:37,250 --> 00:40:46,130
are all spurious transitions so now now

765
00:40:45,170 --> 00:40:48,470
that we have talked about the

766
00:40:46,130 --> 00:40:52,130
non-compliance discovering detection

767
00:40:48,470 --> 00:40:54,910
let's shift gears and then talk about

768
00:40:52,130 --> 00:40:54,910
the attack discovery

769
00:40:55,530 --> 00:41:00,420
so routing is a fundamental component to

770
00:40:58,830 --> 00:41:02,040
enable multi have communication in

771
00:41:00,420 --> 00:41:03,660
wireless mesh networks there are a lot

772
00:41:02,040 --> 00:41:05,730
of examples of routing protocols which

773
00:41:03,660 --> 00:41:08,910
are actually implemented and deployed in

774
00:41:05,730 --> 00:41:11,640
real life and we have seen at the

775
00:41:08,910 --> 00:41:13,859
beginning that vulnerabilities often

776
00:41:11,640 --> 00:41:16,950
manifest in adversarial environments

777
00:41:13,860 --> 00:41:18,990
then the question is how to ensure the

778
00:41:16,950 --> 00:41:22,259
robustness of wireless routing protocol

779
00:41:18,990 --> 00:41:26,939
implementations prior to these attacks

780
00:41:22,260 --> 00:41:30,000
prior to deployment in this work we

781
00:41:26,940 --> 00:41:32,220
consider an attack model which is as

782
00:41:30,000 --> 00:41:34,710
follows that we considered attackers are

783
00:41:32,220 --> 00:41:37,259
insiders who do not play by the rules of

784
00:41:34,710 --> 00:41:40,710
the protocol they manipulate protocol

785
00:41:37,260 --> 00:41:43,200
messages to impaired performance and as

786
00:41:40,710 --> 00:41:47,040
a result it can lead to performance

787
00:41:43,200 --> 00:41:48,750
attacks there are very various malicious

788
00:41:47,040 --> 00:41:50,430
actions can be taken by these attackers

789
00:41:48,750 --> 00:41:53,010
for example they can disturb the

790
00:41:50,430 --> 00:41:56,129
delivery or modify the content of the

791
00:41:53,010 --> 00:41:58,290
messages or they can even take some

792
00:41:56,130 --> 00:42:00,450
actions that are pretty specific to

793
00:41:58,290 --> 00:42:05,279
wireless routing for example replay and

794
00:42:00,450 --> 00:42:07,049
black hole we add advocate for

795
00:42:05,280 --> 00:42:10,080
adversarial testing what means that

796
00:42:07,050 --> 00:42:12,390
testing implementation beyond beyond

797
00:42:10,080 --> 00:42:17,100
their basic capabilities are basic

798
00:42:12,390 --> 00:42:18,870
functionalities to do so we we advocate

799
00:42:17,100 --> 00:42:21,480
for examining H cases boundary

800
00:42:18,870 --> 00:42:24,720
conditions and conduct conduct testing

801
00:42:21,480 --> 00:42:26,730
using malicious actions there are some

802
00:42:24,720 --> 00:42:30,089
prior works who use automated

803
00:42:26,730 --> 00:42:32,880
adversarial testing but the default

804
00:42:30,090 --> 00:42:34,770
short for various reasons including they

805
00:42:32,880 --> 00:42:37,170
have some of them has like language

806
00:42:34,770 --> 00:42:40,950
programming language dependency whereas

807
00:42:37,170 --> 00:42:43,140
somewhere very much very targeted for

808
00:42:40,950 --> 00:42:46,560
various specific types of protocols and

809
00:42:43,140 --> 00:42:50,279
mostly wired protocols our protocols

810
00:42:46,560 --> 00:42:53,340
were designed for wired networks so now

811
00:42:50,280 --> 00:42:55,850
the question becomes then how can we

812
00:42:53,340 --> 00:42:58,440
perform automated adversarial testing on

813
00:42:55,850 --> 00:43:03,210
unmodified implementations of wireless

814
00:42:58,440 --> 00:43:06,330
routing protocols so the next question

815
00:43:03,210 --> 00:43:09,780
is the obviously becomes like now that

816
00:43:06,330 --> 00:43:12,870
we want to test what would be our

817
00:43:09,780 --> 00:43:14,880
testing environment one option is that

818
00:43:12,870 --> 00:43:18,180
we can use the real deployed network in

819
00:43:14,880 --> 00:43:20,010
that case the bay there are some

820
00:43:18,180 --> 00:43:21,750
benefits of that because we can run the

821
00:43:20,010 --> 00:43:23,730
actual implementation on real hardware

822
00:43:21,750 --> 00:43:25,710
hardware we don't have to modify the

823
00:43:23,730 --> 00:43:28,890
implementation and we can communicate

824
00:43:25,710 --> 00:43:31,100
using real radio medium and another

825
00:43:28,890 --> 00:43:33,540
option is that you can use simulators

826
00:43:31,100 --> 00:43:36,240
where we simulate both the nodes and the

827
00:43:33,540 --> 00:43:37,830
network it is simple and easy way that

828
00:43:36,240 --> 00:43:40,799
you can do various under various

829
00:43:37,830 --> 00:43:45,390
condition you can test different types

830
00:43:40,800 --> 00:43:47,940
of correctness or and a performance now

831
00:43:45,390 --> 00:43:51,420
at this network environments suitable

832
00:43:47,940 --> 00:43:54,930
for our goal actually not and because of

833
00:43:51,420 --> 00:43:56,970
their limitations for if we use real

834
00:43:54,930 --> 00:43:59,930
deployed networks then the testing will

835
00:43:56,970 --> 00:44:02,759
interfere with the user experience and

836
00:43:59,930 --> 00:44:06,839
since it is a real deployed network we

837
00:44:02,760 --> 00:44:09,450
won't be able to reproduce or the what

838
00:44:06,840 --> 00:44:11,670
and the network events that happen or in

839
00:44:09,450 --> 00:44:17,040
some sense even if we can you may not

840
00:44:11,670 --> 00:44:20,040
match the exact scenario then in case of

841
00:44:17,040 --> 00:44:22,830
simulators oftentimes simulators require

842
00:44:20,040 --> 00:44:24,810
an implementation which is different

843
00:44:22,830 --> 00:44:28,200
from the implementation that will be

844
00:44:24,810 --> 00:44:33,060
deployed in real world and since these

845
00:44:28,200 --> 00:44:36,660
implementations are ran a run in a

846
00:44:33,060 --> 00:44:39,420
simulator they these employee they

847
00:44:36,660 --> 00:44:43,560
cannot have capture the interaction with

848
00:44:39,420 --> 00:44:46,950
the operating system components so

849
00:44:43,560 --> 00:44:49,799
therefore we propose today w a platform

850
00:44:46,950 --> 00:44:53,040
for automated adversarial testing of

851
00:44:49,800 --> 00:44:55,140
wireless routing protocols it allows us

852
00:44:53,040 --> 00:44:57,270
to test actual implementation of the

853
00:44:55,140 --> 00:45:00,660
protocols by leveraging virtualization

854
00:44:57,270 --> 00:45:02,820
and network simulation we tested five

855
00:45:00,660 --> 00:45:07,589
routing protocols with turret and found

856
00:45:02,820 --> 00:45:11,100
several attacks and bugs at a high level

857
00:45:07,590 --> 00:45:13,470
today w works as follows that given an

858
00:45:11,100 --> 00:45:16,740
unmodified target code in this case the

859
00:45:13,470 --> 00:45:19,620
routing implementation it deploys this

860
00:45:16,740 --> 00:45:22,359
code in each of the VMS for

861
00:45:19,620 --> 00:45:25,330
communication it utilizes a

862
00:45:22,360 --> 00:45:27,370
we're emulated wireless network now with

863
00:45:25,330 --> 00:45:28,779
the help of the routing protocol the vm

864
00:45:27,370 --> 00:45:32,880
will start communicating with each other

865
00:45:28,780 --> 00:45:35,200
at some point a malicious component that

866
00:45:32,880 --> 00:45:38,110
injects some malicious actions into the

867
00:45:35,200 --> 00:45:40,450
network and at the end of the execution

868
00:45:38,110 --> 00:45:43,240
the platform measures the performance

869
00:45:40,450 --> 00:45:46,240
and labels that whether the injected

870
00:45:43,240 --> 00:45:52,390
malicious action result in a successful

871
00:45:46,240 --> 00:45:55,720
attack or not so we use virtualization

872
00:45:52,390 --> 00:45:58,690
because it it provides us the some

873
00:45:55,720 --> 00:46:00,700
benefits and that is it allows us to run

874
00:45:58,690 --> 00:46:02,950
unmodified code the same code that will

875
00:46:00,700 --> 00:46:05,620
be run on the deployed pressure on the

876
00:46:02,950 --> 00:46:07,839
onion your deployment and add it to that

877
00:46:05,620 --> 00:46:09,640
you can even use the same OS and the

878
00:46:07,840 --> 00:46:12,400
libraries that you will use for the

879
00:46:09,640 --> 00:46:14,319
deployment it allows us to capture and

880
00:46:12,400 --> 00:46:16,780
therefore it allows us to capture the

881
00:46:14,320 --> 00:46:21,700
interaction between the code and its

882
00:46:16,780 --> 00:46:24,070
native environment and it also removes

883
00:46:21,700 --> 00:46:26,859
any restriction specific towards a

884
00:46:24,070 --> 00:46:31,180
particular OS or some programming

885
00:46:26,860 --> 00:46:32,860
languages on the other hand wireless

886
00:46:31,180 --> 00:46:36,390
network emulation provides a realistic

887
00:46:32,860 --> 00:46:42,280
Network where which has a capability of

888
00:46:36,390 --> 00:46:44,799
reproducing network events so now the

889
00:46:42,280 --> 00:46:46,990
question you can ask like okay how how

890
00:46:44,800 --> 00:46:50,500
are we generating different types of

891
00:46:46,990 --> 00:46:53,229
attacks so our approach is based on

892
00:46:50,500 --> 00:46:55,960
first testing which is shown to be a

893
00:46:53,230 --> 00:46:59,200
very effective blackbox testing what it

894
00:46:55,960 --> 00:47:01,270
does that you randomly mutates some well

895
00:46:59,200 --> 00:47:04,839
form inputs to create various test cases

896
00:47:01,270 --> 00:47:10,720
and then test the given program on these

897
00:47:04,840 --> 00:47:14,260
test cases but it provides very limited

898
00:47:10,720 --> 00:47:16,359
coverage of the large search space so

899
00:47:14,260 --> 00:47:21,630
therefore to reduce the search a large

900
00:47:16,360 --> 00:47:25,360
search space we adopt some measures here

901
00:47:21,630 --> 00:47:27,280
for example instead of modifying the

902
00:47:25,360 --> 00:47:30,430
content of the message are mutating at

903
00:47:27,280 --> 00:47:32,710
at a random position in the message we

904
00:47:30,430 --> 00:47:35,680
try to identify the fields of the

905
00:47:32,710 --> 00:47:37,720
protocol messages and then muted them

906
00:47:35,680 --> 00:47:41,109
we also consider that the message fields

907
00:47:37,720 --> 00:47:43,930
are independent and we apply some

908
00:47:41,109 --> 00:47:47,980
general mutation techniques as proposed

909
00:47:43,930 --> 00:47:50,169
in like previous works for example if it

910
00:47:47,980 --> 00:47:53,890
is a numeric field we can you consider

911
00:47:50,170 --> 00:47:56,440
min or maximum allowed value for that

912
00:47:53,890 --> 00:47:59,020
particular datatype or you can set zero

913
00:47:56,440 --> 00:48:04,059
or negative numbers and so on and so

914
00:47:59,020 --> 00:48:05,890
forth but to do so what we require from

915
00:48:04,059 --> 00:48:09,040
the user that the required needs to

916
00:48:05,890 --> 00:48:14,319
provide the format of each protocol

917
00:48:09,040 --> 00:48:16,900
message so instead of going through the

918
00:48:14,319 --> 00:48:18,849
details of my evolution I will just

919
00:48:16,900 --> 00:48:23,410
provide a summary of the discovered

920
00:48:18,849 --> 00:48:27,130
attacks so we applied we tested five

921
00:48:23,410 --> 00:48:30,460
different implementations on with ted aw

922
00:48:27,130 --> 00:48:32,140
and pong several attacks and bugs where

923
00:48:30,460 --> 00:48:41,920
some of them were not previously

924
00:48:32,140 --> 00:48:44,440
reported it ok so now to wrap up my talk

925
00:48:41,920 --> 00:48:45,880
I would like to go back to the research

926
00:48:44,440 --> 00:48:49,960
questions that I asked at the beginning

927
00:48:45,880 --> 00:48:53,430
of the top so to answer the first

928
00:48:49,960 --> 00:48:55,540
question we develop chiron for automatic

929
00:48:53,430 --> 00:48:58,450
automatically detecting non-compliance

930
00:48:55,540 --> 00:49:01,029
in protocol implementation we applied it

931
00:48:58,450 --> 00:49:03,399
on five impul five prodigal

932
00:49:01,030 --> 00:49:06,460
implementations and found thin instances

933
00:49:03,400 --> 00:49:09,339
of non-compliance and to answer the

934
00:49:06,460 --> 00:49:11,910
second questions we develop turret w for

935
00:49:09,339 --> 00:49:13,900
automated adversarial testing of

936
00:49:11,910 --> 00:49:16,569
wireless routing protocol

937
00:49:13,900 --> 00:49:18,790
implementations and we tested five

938
00:49:16,569 --> 00:49:23,020
implementations using this platform and

939
00:49:18,790 --> 00:49:25,569
found several attacks and bugs so now i

940
00:49:23,020 --> 00:49:29,829
am to tag thank my collaborators and

941
00:49:25,569 --> 00:49:32,890
advisors and thank you all for listening

942
00:49:29,829 --> 00:49:34,119
to my talk I'll be if you have any

943
00:49:32,890 --> 00:49:36,299
question I'll be happy to answer your

944
00:49:34,119 --> 00:49:36,299
questions

945
00:49:41,980 --> 00:49:50,600
as you look at the Internet of Things

946
00:49:44,950 --> 00:49:53,779
networking protocols you had I think 18

947
00:49:50,600 --> 00:49:57,830
different mm-hmm specifications you look

948
00:49:53,780 --> 00:49:59,960
for compliance do you think that some of

949
00:49:57,830 --> 00:50:02,900
these sudden networks would have a

950
00:49:59,960 --> 00:50:05,210
requirement that requires less of those

951
00:50:02,900 --> 00:50:06,650
specifications to function and then

952
00:50:05,210 --> 00:50:09,710
they're isolated from the rest of the

953
00:50:06,650 --> 00:50:11,480
world and therefore should be tested

954
00:50:09,710 --> 00:50:14,540
under different standards or what are

955
00:50:11,480 --> 00:50:17,750
your thoughts okay that's a good

956
00:50:14,540 --> 00:50:21,680
question a good question is so one thing

957
00:50:17,750 --> 00:50:24,320
is that we as you say that you may have

958
00:50:21,680 --> 00:50:25,790
I mean okay specification come from

959
00:50:24,320 --> 00:50:29,840
different places it can come from

960
00:50:25,790 --> 00:50:33,400
standards or it can come from your when

961
00:50:29,840 --> 00:50:35,840
you are implementing you may have some

962
00:50:33,400 --> 00:50:36,950
requirements for example the

963
00:50:35,840 --> 00:50:40,670
requirements that i showed at the

964
00:50:36,950 --> 00:50:42,770
beginning that the server telnet server

965
00:50:40,670 --> 00:50:44,450
needs to talk to only one client that

966
00:50:42,770 --> 00:50:46,370
actually came from their implementation

967
00:50:44,450 --> 00:50:49,490
because they wanted to have an highly

968
00:50:46,370 --> 00:50:52,880
optimized implementation right so in our

969
00:50:49,490 --> 00:50:54,680
the properties that we tested that came

970
00:50:52,880 --> 00:50:57,590
from several places some of them from

971
00:50:54,680 --> 00:50:59,660
the RFC standard some of them from the

972
00:50:57,590 --> 00:51:02,240
documentation code documentation and

973
00:50:59,660 --> 00:51:04,609
some came from bug reports so we try to

974
00:51:02,240 --> 00:51:07,939
see that ok whether it's actually

975
00:51:04,610 --> 00:51:11,120
happened or not so yes you can in those

976
00:51:07,940 --> 00:51:14,870
cases like if you have a specific

977
00:51:11,120 --> 00:51:18,049
requirements that are very your

978
00:51:14,870 --> 00:51:21,230
implementation dependent so you can try

979
00:51:18,050 --> 00:51:23,990
it out and it's definitely required not

980
00:51:21,230 --> 00:51:26,450
only having a I mean properties coming

981
00:51:23,990 --> 00:51:30,910
from standards your implementation may

982
00:51:26,450 --> 00:51:30,910
have some different requirements yeah

983
00:51:31,630 --> 00:51:37,270
yes

984
00:51:33,630 --> 00:51:40,830
your protocol implementation checking

985
00:51:37,270 --> 00:51:43,930
table you noted that you had five

986
00:51:40,830 --> 00:51:50,650
non-compliances in Contiki 2.4 and four

987
00:51:43,930 --> 00:51:53,618
and 2.7 mmm did those overlap ah yes

988
00:51:50,650 --> 00:51:58,750
some of them some of them was there and

989
00:51:53,619 --> 00:52:01,450
that overlap and that I guess yeah a few

990
00:51:58,750 --> 00:52:08,680
two of them is still in yes 2.4 and

991
00:52:01,450 --> 00:52:10,680
still in 2.7 yeah if you're if you're

992
00:52:08,680 --> 00:52:14,589
looking at for example like a smart home

993
00:52:10,680 --> 00:52:17,549
internet of things security I mean

994
00:52:14,590 --> 00:52:20,470
there's some things that consumer can do

995
00:52:17,550 --> 00:52:23,920
some things utilities can do like let's

996
00:52:20,470 --> 00:52:27,910
say comcast xfinity is selling it to

997
00:52:23,920 --> 00:52:29,560
homeowner is there anyone out there that

998
00:52:27,910 --> 00:52:30,879
looks at these different devices that

999
00:52:29,560 --> 00:52:34,350
are trying to plug and play with each

1000
00:52:30,880 --> 00:52:38,260
other from various vendors and says okay

1001
00:52:34,350 --> 00:52:40,960
you know baseline security your

1002
00:52:38,260 --> 00:52:43,060
compliance or baseline yeah security

1003
00:52:40,960 --> 00:52:44,790
Europe just out of the ranch you know

1004
00:52:43,060 --> 00:52:47,350
and no matter what the consumer does

1005
00:52:44,790 --> 00:52:48,970
your unprotected is there anyone looking

1006
00:52:47,350 --> 00:52:51,609
at it from that direction other than say

1007
00:52:48,970 --> 00:52:54,180
research like you would do that's

1008
00:52:51,609 --> 00:52:56,680
another good question I don't think so

1009
00:52:54,180 --> 00:52:58,690
people say that it comes with like basic

1010
00:52:56,680 --> 00:53:01,180
security or something that you go best

1011
00:52:58,690 --> 00:53:03,609
buy or walmart or radio shack you buy

1012
00:53:01,180 --> 00:53:07,330
those two I mean devices you don't even

1013
00:53:03,609 --> 00:53:08,950
know what are the inside I mean and

1014
00:53:07,330 --> 00:53:10,960
that's why I like a lot of if you see

1015
00:53:08,950 --> 00:53:14,319
like cyber security in case of every a

1016
00:53:10,960 --> 00:53:17,440
lot of em I mean hacking is I mean I

1017
00:53:14,320 --> 00:53:18,460
mean in some conferences like Def Con or

1018
00:53:17,440 --> 00:53:20,350
hacking conference that they are showing

1019
00:53:18,460 --> 00:53:22,840
that this is possible they can like

1020
00:53:20,350 --> 00:53:25,330
break into your system I mean that you

1021
00:53:22,840 --> 00:53:28,600
are using in your home these RT devices

1022
00:53:25,330 --> 00:53:30,759
and they don't have enough security in

1023
00:53:28,600 --> 00:53:34,390
some of the cases well that's one more

1024
00:53:30,760 --> 00:53:37,060
question ask you do you see a trend

1025
00:53:34,390 --> 00:53:39,670
where vendors kind of hide what they're

1026
00:53:37,060 --> 00:53:41,859
doing for security to obfuscate and make

1027
00:53:39,670 --> 00:53:43,180
any attackers job more difficult or are

1028
00:53:41,859 --> 00:53:45,009
they kind of saying this is what we

1029
00:53:43,180 --> 00:53:45,500
implement therefore if you're trying to

1030
00:53:45,010 --> 00:53:48,020
engine

1031
00:53:45,500 --> 00:53:50,120
you're a total solution with various

1032
00:53:48,020 --> 00:53:55,509
vendors this is how will work well or

1033
00:53:50,120 --> 00:53:57,890
maybe not so well so you're saying that

1034
00:53:55,510 --> 00:54:01,910
your question is that whether people are

1035
00:53:57,890 --> 00:54:03,440
doing any kind of so let's say we're

1036
00:54:01,910 --> 00:54:05,600
company X and we're selling a new

1037
00:54:03,440 --> 00:54:08,330
product for an internet at home or maybe

1038
00:54:05,600 --> 00:54:10,069
a skate application I'm sorry internet

1039
00:54:08,330 --> 00:54:13,730
of things for a smart home or mesquita

1040
00:54:10,070 --> 00:54:15,920
our vendors advertising that we're

1041
00:54:13,730 --> 00:54:18,470
secure because we use a yes and we use

1042
00:54:15,920 --> 00:54:20,930
you know fetal azmat earliest version is

1043
00:54:18,470 --> 00:54:23,120
or are they kind of basically keeping

1044
00:54:20,930 --> 00:54:25,819
that close hold just to make the

1045
00:54:23,120 --> 00:54:29,470
attackers job more difficult when their

1046
00:54:25,820 --> 00:54:29,470
products are implemented in the field

1047
00:54:34,120 --> 00:54:39,410
yeah I mean I don't know exactly that

1048
00:54:37,400 --> 00:54:42,380
what the users trend right now but I

1049
00:54:39,410 --> 00:54:45,140
would say like the I mean it's getting

1050
00:54:42,380 --> 00:54:48,020
into the radar that way these IOT

1051
00:54:45,140 --> 00:54:49,879
devices are not enough secure and it

1052
00:54:48,020 --> 00:54:51,740
requires a more and more attention from

1053
00:54:49,880 --> 00:54:55,940
the research world and also definitely

1054
00:54:51,740 --> 00:54:58,069
from the industry right I mean I mean

1055
00:54:55,940 --> 00:55:01,480
whether if there might be definitely

1056
00:54:58,070 --> 00:55:05,300
some cost benefit issues there right but

1057
00:55:01,480 --> 00:55:08,450
it's a user's security is involved there

1058
00:55:05,300 --> 00:55:10,550
so definitely I mean they are getting

1059
00:55:08,450 --> 00:55:17,720
attention but I wouldn't say that I mean

1060
00:55:10,550 --> 00:55:21,130
it's completely secured right now any

1061
00:55:17,720 --> 00:55:21,129
more questions yes

1062
00:55:21,540 --> 00:55:28,670
hi um you talked about checking the

1063
00:55:26,430 --> 00:55:32,129
robustness of network protocols

1064
00:55:28,670 --> 00:55:36,630
considering inside attackers do you see

1065
00:55:32,130 --> 00:55:39,660
this research extending to automatically

1066
00:55:36,630 --> 00:55:42,360
detect the possible vulnerabilities

1067
00:55:39,660 --> 00:55:51,569
towards outside attackers like in

1068
00:55:42,360 --> 00:55:53,520
choppers or something hmm ok so one

1069
00:55:51,570 --> 00:55:55,680
thing is that in this case like yeah we

1070
00:55:53,520 --> 00:55:58,620
are specifically we are not considering

1071
00:55:55,680 --> 00:56:00,330
outside attackers and for that like you

1072
00:55:58,620 --> 00:56:02,520
do have like there are a lot of people

1073
00:56:00,330 --> 00:56:05,160
and there are a lot of network security

1074
00:56:02,520 --> 00:56:08,400
techniques that applies like doing

1075
00:56:05,160 --> 00:56:10,200
encryption and doing other stuff but in

1076
00:56:08,400 --> 00:56:13,470
this case we what we are just trying to

1077
00:56:10,200 --> 00:56:16,410
say that after getting one of the nodes

1078
00:56:13,470 --> 00:56:18,450
compromised and then no I mean they they

1079
00:56:16,410 --> 00:56:20,310
know the protocol and they know they

1080
00:56:18,450 --> 00:56:22,950
have I mean they have the encryption

1081
00:56:20,310 --> 00:56:27,090
keys and they are using it what bad they

1082
00:56:22,950 --> 00:56:29,819
can do right underneath the even if your

1083
00:56:27,090 --> 00:56:32,220
messages are encrypted but the values or

1084
00:56:29,820 --> 00:56:33,720
that the content of the message by

1085
00:56:32,220 --> 00:56:37,890
changing those message of what bad they

1086
00:56:33,720 --> 00:56:38,669
can do so yes it's mostly looking the

1087
00:56:37,890 --> 00:56:41,150
problem here from a different

1088
00:56:38,670 --> 00:56:46,950
perspective rather than from outsider

1089
00:56:41,150 --> 00:56:49,350
and also like there are existing other

1090
00:56:46,950 --> 00:56:53,220
researchers other research work that

1091
00:56:49,350 --> 00:56:55,980
look at like trying to defend against

1092
00:56:53,220 --> 00:56:58,259
outside work outside attackers Outsiders

1093
00:56:55,980 --> 00:57:01,130
not the insider so we are from the

1094
00:56:58,260 --> 00:57:01,130
insider perspective

1095
00:57:04,290 --> 00:57:17,640
thing else I'd like to thank see you all

1096
00:57:13,710 --> 00:57:20,210
next week all in this is a serious

1097
00:57:17,640 --> 00:57:20,210
symposium

