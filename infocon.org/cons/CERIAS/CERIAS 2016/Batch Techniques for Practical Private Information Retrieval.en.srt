1
00:00:36,969 --> 00:00:43,989
welcome to the serious seminar for March

2
00:00:40,670 --> 00:00:46,879
9th today I'm pleased to welcome

3
00:00:43,989 --> 00:00:52,220
Professor Ryan Henry who comes to us

4
00:00:46,879 --> 00:00:56,620
from downstate is a professor in in in

5
00:00:52,220 --> 00:01:00,140
computer science at Indiana University

6
00:00:56,620 --> 00:01:03,140
professor Henry got his PhD at the

7
00:01:00,140 --> 00:01:07,399
University of Waterloo so he also comes

8
00:01:03,140 --> 00:01:09,310
to us from from north of here and is

9
00:01:07,399 --> 00:01:13,750
going to be talking to us today about

10
00:01:09,310 --> 00:01:17,179
practical private information retrieval

11
00:01:13,750 --> 00:01:18,410
thanks ok so as Chris mentioned I'm

12
00:01:17,179 --> 00:01:20,539
going to be talking about private

13
00:01:18,410 --> 00:01:23,300
information retrieval I saw on the

14
00:01:20,539 --> 00:01:25,220
website for serious that students are

15
00:01:23,300 --> 00:01:28,039
offered credit to attend this so I was

16
00:01:25,220 --> 00:01:29,840
counting on several students and I kind

17
00:01:28,039 --> 00:01:32,780
of tailored the talk a little bit to be

18
00:01:29,840 --> 00:01:34,580
more to teach you a little bit about how

19
00:01:32,780 --> 00:01:36,710
PIR works rather than to focus on like

20
00:01:34,580 --> 00:01:39,380
the really technical new contributions

21
00:01:36,710 --> 00:01:40,789
so there will be a lot of giving you the

22
00:01:39,380 --> 00:01:42,140
the background behind how these things

23
00:01:40,790 --> 00:01:46,009
actually work and then I'll talk about

24
00:01:42,140 --> 00:01:48,020
some of the new stuff towards the end so

25
00:01:46,009 --> 00:01:50,149
let's start with the problem statement

26
00:01:48,020 --> 00:01:51,469
what are we trying to do so private

27
00:01:50,149 --> 00:01:53,210
information retrieval as you can

28
00:01:51,469 --> 00:01:54,860
probably imagine has something to do

29
00:01:53,210 --> 00:01:58,009
with information retrieval which is this

30
00:01:54,860 --> 00:01:59,689
basic problem of a user trying to fetch

31
00:01:58,009 --> 00:02:01,700
some sort of data from a database so the

32
00:01:59,689 --> 00:02:04,579
user is going to issue a request and is

33
00:02:01,700 --> 00:02:06,049
going to get back a response and this in

34
00:02:04,579 --> 00:02:08,419
and of itself there's a lot of

35
00:02:06,049 --> 00:02:11,600
interesting research questions that you

36
00:02:08,419 --> 00:02:13,640
can ask what we're interested in is what

37
00:02:11,600 --> 00:02:15,680
if we want some notion of privacy here

38
00:02:13,640 --> 00:02:17,779
so I had a conversation recently with my

39
00:02:15,680 --> 00:02:20,269
10 year old niece who was once a very

40
00:02:17,780 --> 00:02:22,280
big Justin Bieber fan and she has

41
00:02:20,269 --> 00:02:24,440
informed me that it is no longer cool to

42
00:02:22,280 --> 00:02:26,239
be a Justin Bieber fan so for the sake

43
00:02:24,440 --> 00:02:29,380
of this example let's suppose that this

44
00:02:26,239 --> 00:02:33,200
request here is for Justin Bieber videos

45
00:02:29,380 --> 00:02:35,209
which might be rather embarrassing so we

46
00:02:33,200 --> 00:02:37,130
want to figure out can we protect the

47
00:02:35,209 --> 00:02:41,030
privacy of this user who's looking for

48
00:02:37,130 --> 00:02:42,918
Justin Bieber videos on the internet now

49
00:02:41,030 --> 00:02:44,989
those of you who know about tor might

50
00:02:42,919 --> 00:02:46,550
say this is an easy problem to solve

51
00:02:44,989 --> 00:02:48,380
you just connect over the Tor

52
00:02:46,550 --> 00:02:50,420
network you send your request for Bieber

53
00:02:48,380 --> 00:02:53,240
videos through tour you get your

54
00:02:50,420 --> 00:02:54,829
response back and now the website this

55
00:02:53,240 --> 00:02:56,480
the server has no idea who it was

56
00:02:54,830 --> 00:03:00,110
looking for these embarrassing Bieber

57
00:02:56,480 --> 00:03:02,600
videos and this of course works for this

58
00:03:00,110 --> 00:03:04,460
particular example but what if instead

59
00:03:02,600 --> 00:03:07,820
of searching for Justin Bieber the user

60
00:03:04,460 --> 00:03:09,860
was searching for some top-secret patent

61
00:03:07,820 --> 00:03:11,780
idea trying to decide is this a novel

62
00:03:09,860 --> 00:03:14,570
idea should I devote the next 6 months

63
00:03:11,780 --> 00:03:17,510
of my life to researching this this what

64
00:03:14,570 --> 00:03:19,730
I believe to be a novel idea what if the

65
00:03:17,510 --> 00:03:21,590
website or the database that's being

66
00:03:19,730 --> 00:03:23,600
queried here is owned by some

67
00:03:21,590 --> 00:03:26,180
multinational corporation with billion

68
00:03:23,600 --> 00:03:28,190
dollar research budget who sees this

69
00:03:26,180 --> 00:03:30,170
idea and goes ah that's a brilliant idea

70
00:03:28,190 --> 00:03:33,040
let's bring this to market before that

71
00:03:30,170 --> 00:03:36,829
user has an opportunity to commercialize

72
00:03:33,040 --> 00:03:39,530
so here tor doesn't help the website or

73
00:03:36,830 --> 00:03:41,600
the server doesn't know whose idea this

74
00:03:39,530 --> 00:03:43,910
is but they still learn the brilliant

75
00:03:41,600 --> 00:03:45,710
idea and so we're solving the wrong

76
00:03:43,910 --> 00:03:47,930
problem using tor here what we really

77
00:03:45,710 --> 00:03:49,730
want to solve is the problem of allowing

78
00:03:47,930 --> 00:03:52,160
the user to query the database and

79
00:03:49,730 --> 00:03:53,869
having the database not have a clue what

80
00:03:52,160 --> 00:03:55,400
it is the user looked for so we're not

81
00:03:53,870 --> 00:03:56,720
going to try to protect the identity of

82
00:03:55,400 --> 00:03:59,360
the user we're going to try to protect

83
00:03:56,720 --> 00:04:00,890
the contents of the query if you want to

84
00:03:59,360 --> 00:04:02,450
protect the identity of the user you can

85
00:04:00,890 --> 00:04:07,130
do all of this over tor and then you get

86
00:04:02,450 --> 00:04:09,649
both notions of privacy okay so that's

87
00:04:07,130 --> 00:04:14,570
that's the basic hand-wavy version of

88
00:04:09,650 --> 00:04:16,579
what exactly is PIR a slightly more

89
00:04:14,570 --> 00:04:18,108
formal definition but by no means the

90
00:04:16,579 --> 00:04:20,089
the cryptographic definition is that

91
00:04:18,108 --> 00:04:22,130
private information retrieval is just

92
00:04:20,089 --> 00:04:24,440
the database technique that is going to

93
00:04:22,130 --> 00:04:27,560
allow a user to query a database while

94
00:04:24,440 --> 00:04:30,560
protecting from the database server the

95
00:04:27,560 --> 00:04:32,480
contents of the user's query and PIR is

96
00:04:30,560 --> 00:04:34,430
how we'll usually refer to private

97
00:04:32,480 --> 00:04:38,570
information retrieval let's see standard

98
00:04:34,430 --> 00:04:40,460
acronym okay so some of you might be

99
00:04:38,570 --> 00:04:42,830
wondering is this actually possible to

100
00:04:40,460 --> 00:04:44,419
query a database and get responses

101
00:04:42,830 --> 00:04:46,520
without the database learning what you

102
00:04:44,419 --> 00:04:47,960
asked for or what it sent you so to

103
00:04:46,520 --> 00:04:49,909
convince you this is possible let's look

104
00:04:47,960 --> 00:04:52,340
at the sort of the trivial way to do

105
00:04:49,910 --> 00:04:53,660
this so the trivial way to do this is

106
00:04:52,340 --> 00:04:55,969
the user is going to ask the database

107
00:04:53,660 --> 00:04:57,229
for something just a very generic query

108
00:04:55,970 --> 00:04:59,810
that says hey I'm looking for something

109
00:04:57,229 --> 00:05:00,400
and the database server is going to say

110
00:04:59,810 --> 00:05:03,100
ok here

111
00:05:00,400 --> 00:05:04,810
everything I've got now you can look up

112
00:05:03,100 --> 00:05:06,070
locally what particular thing you're

113
00:05:04,810 --> 00:05:08,139
looking for and of course this gives you

114
00:05:06,070 --> 00:05:10,690
perfect privacy because the database

115
00:05:08,139 --> 00:05:11,710
server didn't the query didn't contain

116
00:05:10,690 --> 00:05:13,030
any information about what you were

117
00:05:11,710 --> 00:05:14,320
looking for the database server just

118
00:05:13,030 --> 00:05:16,090
sent you everything it doesn't know

119
00:05:14,320 --> 00:05:17,380
which things you were actually looking

120
00:05:16,090 --> 00:05:19,210
for it doesn't even know whether you

121
00:05:17,380 --> 00:05:21,729
found what you wanted so we get perfect

122
00:05:19,210 --> 00:05:23,530
privacy but the communication overhead

123
00:05:21,729 --> 00:05:24,880
is huge imagine searching Google this

124
00:05:23,530 --> 00:05:26,080
way you go to Google and say hey I'm

125
00:05:24,880 --> 00:05:28,300
looking for a website and they say okay

126
00:05:26,080 --> 00:05:31,120
here's the whole internet find the

127
00:05:28,300 --> 00:05:32,590
website he doesn't scale very well so we

128
00:05:31,120 --> 00:05:34,479
need something a little bit more

129
00:05:32,590 --> 00:05:36,190
practical than this so there's a second

130
00:05:34,479 --> 00:05:38,109
requirement beyond the privacy

131
00:05:36,190 --> 00:05:40,120
requirement which we usually call nom

132
00:05:38,110 --> 00:05:41,889
triviality which says that the cost of

133
00:05:40,120 --> 00:05:43,900
this entire interaction between the

134
00:05:41,889 --> 00:05:46,330
client and the server should scale as

135
00:05:43,900 --> 00:05:48,489
little o n where n is the number of bits

136
00:05:46,330 --> 00:05:50,500
in the database and in practice we don't

137
00:05:48,490 --> 00:05:53,800
want this asymptotic norm we really want

138
00:05:50,500 --> 00:05:55,660
that the cost of everything is really

139
00:05:53,800 --> 00:05:56,830
really small compared to the time it

140
00:05:55,660 --> 00:05:59,650
would take to just download this whole

141
00:05:56,830 --> 00:06:01,599
database so now it's less clear if this

142
00:05:59,650 --> 00:06:04,030
is actually possible but it turns out it

143
00:06:01,599 --> 00:06:06,460
is and there's three basic ways that we

144
00:06:04,030 --> 00:06:08,320
know how to solve this problem so the

145
00:06:06,460 --> 00:06:10,690
first one uses home morphic encryption

146
00:06:08,320 --> 00:06:14,139
this has got some really nice properties

147
00:06:10,690 --> 00:06:16,060
but is extremely slow second one users

148
00:06:14,139 --> 00:06:17,740
trusted hardware which has some promise

149
00:06:16,060 --> 00:06:20,289
as long as you can trust the hardware

150
00:06:17,740 --> 00:06:21,400
and the third one uses coding theory and

151
00:06:20,289 --> 00:06:22,900
this is the approach we're going to talk

152
00:06:21,400 --> 00:06:27,549
about in this talk is this coding theory

153
00:06:22,900 --> 00:06:28,989
based approach ok so start with a little

154
00:06:27,550 --> 00:06:30,909
bit of formal model how are we actually

155
00:06:28,990 --> 00:06:33,250
going to set this up we're gonna think

156
00:06:30,909 --> 00:06:35,530
of our database as a matrix this is an R

157
00:06:33,250 --> 00:06:37,360
by s matrix over a finite field if

158
00:06:35,530 --> 00:06:38,679
you're not familiar with finite fields

159
00:06:37,360 --> 00:06:40,900
all you really need to know here is that

160
00:06:38,680 --> 00:06:42,190
it's a mathematical object where you can

161
00:06:40,900 --> 00:06:44,380
do addition you can do multiplication

162
00:06:42,190 --> 00:06:46,510
and you can find inverses so you can

163
00:06:44,380 --> 00:06:48,250
find something if I give you a you can

164
00:06:46,510 --> 00:06:50,800
find a inverse so when you multiply them

165
00:06:48,250 --> 00:06:52,000
together you get one and as long as we

166
00:06:50,800 --> 00:06:53,560
just need any sort of setting where

167
00:06:52,000 --> 00:06:56,289
we're working in a finite set and we

168
00:06:53,560 --> 00:06:59,560
have those properties each of the rows

169
00:06:56,289 --> 00:07:00,820
of this matrix is one of the records in

170
00:06:59,560 --> 00:07:02,320
our database so these are the things

171
00:07:00,820 --> 00:07:04,750
that a user might try to fetch are the

172
00:07:02,320 --> 00:07:07,060
rows of this database and we've just

173
00:07:04,750 --> 00:07:09,849
decomposed each record into a sequence

174
00:07:07,060 --> 00:07:13,469
of words of elements from this field

175
00:07:09,849 --> 00:07:13,469
using some sort of encoding mechanism

176
00:07:14,050 --> 00:07:20,300
now to query this database well this is

177
00:07:18,979 --> 00:07:22,430
the non private way to query this

178
00:07:20,300 --> 00:07:23,870
database perhaps not the way you would

179
00:07:22,430 --> 00:07:25,460
do it if you were implementing on

180
00:07:23,870 --> 00:07:28,370
private queries but this works so you

181
00:07:25,460 --> 00:07:30,438
could send a standard basis vector so

182
00:07:28,370 --> 00:07:33,740
one of these vectors from the the most

183
00:07:30,439 --> 00:07:35,659
obvious basis for the vector space F to

184
00:07:33,740 --> 00:07:37,969
the R so R is the number of rows in the

185
00:07:35,659 --> 00:07:40,129
matrix so there's just a vector that has

186
00:07:37,969 --> 00:07:42,080
all zeros everywhere except for one

187
00:07:40,129 --> 00:07:44,780
position that has a 1 so if you're

188
00:07:42,080 --> 00:07:45,979
looking for the J throw or the j-3 kurd

189
00:07:44,780 --> 00:07:47,989
in this database you're going to put the

190
00:07:45,979 --> 00:07:51,020
one in the J DH position of this vector

191
00:07:47,990 --> 00:07:52,729
and the database server in this non

192
00:07:51,020 --> 00:07:54,740
private scheme is going to answer this

193
00:07:52,729 --> 00:07:58,758
query by multiplying the vector you sent

194
00:07:54,740 --> 00:08:00,800
by the database and if you do this it's

195
00:07:58,759 --> 00:08:02,960
fairly easy to see that you're gonna get

196
00:08:00,800 --> 00:08:04,639
the result that you want so basically

197
00:08:02,960 --> 00:08:06,080
the first row of the matrix is going to

198
00:08:04,639 --> 00:08:07,940
be multiplied by 0 and you're going to

199
00:08:06,080 --> 00:08:09,440
add that to the second row multiplied by

200
00:08:07,940 --> 00:08:12,199
0 and add that to the third row

201
00:08:09,440 --> 00:08:13,969
multiplied by 0 and so on and only the J

202
00:08:12,199 --> 00:08:15,259
throw is going to be multiplied by one

203
00:08:13,969 --> 00:08:16,879
so all of the other rows are going to

204
00:08:15,259 --> 00:08:18,469
disappear but that J throw is going to

205
00:08:16,879 --> 00:08:22,009
be left behind and you're going to get

206
00:08:18,469 --> 00:08:25,250
the record that you were looking for ok

207
00:08:22,009 --> 00:08:28,190
so this seems to work but it's not

208
00:08:25,250 --> 00:08:29,569
private at all so now we need to figure

209
00:08:28,190 --> 00:08:31,400
out what are we going to do to take this

210
00:08:29,569 --> 00:08:35,649
basic approach and turn this into a

211
00:08:31,400 --> 00:08:35,649
private information retrieval protocol

212
00:08:35,948 --> 00:08:42,109
so the idea is to replicate the database

213
00:08:39,260 --> 00:08:43,729
and then this guy here is giving us the

214
00:08:42,110 --> 00:08:46,310
second part of the suggestion and that

215
00:08:43,729 --> 00:08:47,630
is we're going to take this query that

216
00:08:46,310 --> 00:08:49,069
we were multiplying against a database

217
00:08:47,630 --> 00:08:50,600
and we're going to secret share it using

218
00:08:49,070 --> 00:08:53,060
something called Shamir's secret sharing

219
00:08:50,600 --> 00:08:55,850
scheme and this here is shared one

220
00:08:53,060 --> 00:08:58,839
suggesting that so we replicate the

221
00:08:55,850 --> 00:09:01,519
database and then we secret share this

222
00:08:58,839 --> 00:09:02,990
vector component wise we share the first

223
00:09:01,519 --> 00:09:04,790
component the second component and so on

224
00:09:02,990 --> 00:09:07,640
and we send a different vector of secret

225
00:09:04,790 --> 00:09:09,140
chairs to each server ok so what is the

226
00:09:07,640 --> 00:09:11,839
secret sharing thing I'm talking about

227
00:09:09,140 --> 00:09:14,060
the idea is actually very simple suppose

228
00:09:11,839 --> 00:09:17,930
you want to share a secret denoted by

229
00:09:14,060 --> 00:09:20,599
this purple point with the word secret

230
00:09:17,930 --> 00:09:23,599
pointing at it we want to share this

231
00:09:20,600 --> 00:09:25,430
amongst a set of L shareholders so that

232
00:09:23,600 --> 00:09:26,720
any pair of them can work together then

233
00:09:25,430 --> 00:09:28,489
look at the more general case so in this

234
00:09:26,720 --> 00:09:29,839
case we're looking at any pair of them

235
00:09:28,490 --> 00:09:32,480
can reconstruct it and we want the

236
00:09:29,839 --> 00:09:34,460
additional property that any individual

237
00:09:32,480 --> 00:09:36,620
shareholder doesn't know anything about

238
00:09:34,460 --> 00:09:39,260
the secret so you could think of this a

239
00:09:36,620 --> 00:09:41,870
common way to explain why you might want

240
00:09:39,260 --> 00:09:43,700
to do this is the generals that hold the

241
00:09:41,870 --> 00:09:45,350
keys to launch the nukes right you don't

242
00:09:43,700 --> 00:09:49,160
want some general who's having a bad day

243
00:09:45,350 --> 00:09:50,779
to launch the nukes but if several

244
00:09:49,160 --> 00:09:52,459
generals come together and decide we

245
00:09:50,779 --> 00:09:53,750
need to launch these nukes then we want

246
00:09:52,459 --> 00:09:55,819
them to be able to do that and if one of

247
00:09:53,750 --> 00:09:57,200
the generals suffers a heart attack or

248
00:09:55,820 --> 00:09:58,640
something like that we want to make sure

249
00:09:57,200 --> 00:10:00,320
that the the remaining generals could

250
00:09:58,640 --> 00:10:02,330
still launch the nuke so we want to

251
00:10:00,320 --> 00:10:03,589
allow any subsets in this case of two

252
00:10:02,330 --> 00:10:05,000
generals to launch two nukes but we

253
00:10:03,589 --> 00:10:08,720
don't want some rogue general launching

254
00:10:05,000 --> 00:10:11,240
the nukes so the way that we accomplish

255
00:10:08,720 --> 00:10:14,029
this is we think of the secret as a

256
00:10:11,240 --> 00:10:16,970
point on the y-axis and then we choose a

257
00:10:14,029 --> 00:10:19,370
random slope and we form the line that

258
00:10:16,970 --> 00:10:21,830
passes through that secret with the

259
00:10:19,370 --> 00:10:23,270
slope that we chose and then each of the

260
00:10:21,830 --> 00:10:25,279
other shareholders each of the other

261
00:10:23,270 --> 00:10:28,100
generals in this case or each of the PIR

262
00:10:25,279 --> 00:10:34,480
servers in our PIR example are going to

263
00:10:28,100 --> 00:10:38,450
get different points on this line and so

264
00:10:34,480 --> 00:10:41,120
well as you can see here the shares are

265
00:10:38,450 --> 00:10:42,680
just points on a line so if one

266
00:10:41,120 --> 00:10:44,930
shareholder is trying to figure out what

267
00:10:42,680 --> 00:10:46,370
the secret is you kind of have to ignore

268
00:10:44,930 --> 00:10:49,069
all those other points we just have one

269
00:10:46,370 --> 00:10:50,690
point so it could very well be that this

270
00:10:49,070 --> 00:10:52,250
is the secret because the line that

271
00:10:50,690 --> 00:10:54,260
passes through this point also passes

272
00:10:52,250 --> 00:10:56,630
through the secret but for any other

273
00:10:54,260 --> 00:10:59,390
possible secret there's exactly one line

274
00:10:56,630 --> 00:11:02,150
that connects this shareholders point to

275
00:10:59,390 --> 00:11:03,709
that secret and so without some other

276
00:11:02,150 --> 00:11:05,600
information it's impossible to tell

277
00:11:03,709 --> 00:11:06,890
which of these is the correct secret so

278
00:11:05,600 --> 00:11:09,620
it could be this point it could be this

279
00:11:06,890 --> 00:11:11,209
point it could be this point etc as soon

280
00:11:09,620 --> 00:11:12,829
as a second shareholder comes to the

281
00:11:11,209 --> 00:11:15,319
table we now have two points which

282
00:11:12,829 --> 00:11:17,540
uniquely determines the line and we can

283
00:11:15,320 --> 00:11:21,589
figure out very easily what the secret

284
00:11:17,540 --> 00:11:23,630
is so this is how you do the two out of

285
00:11:21,589 --> 00:11:26,300
El version we want slightly more general

286
00:11:23,630 --> 00:11:27,860
version where there's potentially more

287
00:11:26,300 --> 00:11:30,949
shareholders required to come together

288
00:11:27,860 --> 00:11:33,770
and so here I'll show the four out of El

289
00:11:30,950 --> 00:11:35,930
version the idea is very similar we let

290
00:11:33,770 --> 00:11:38,209
the secret be this point on the y

291
00:11:35,930 --> 00:11:39,290
intercept but now instead of passing a

292
00:11:38,209 --> 00:11:41,449
line through the point

293
00:11:39,290 --> 00:11:43,790
we pass a random polynomial in this case

294
00:11:41,449 --> 00:11:45,380
of degree three through the secret and

295
00:11:43,790 --> 00:11:46,910
then we give different points on this

296
00:11:45,380 --> 00:11:49,370
polynomial to each of the shareholders

297
00:11:46,910 --> 00:11:51,170
and it's a little bit harder to see how

298
00:11:49,370 --> 00:11:52,699
they're gonna reconstruct the polynomial

299
00:11:51,170 --> 00:11:54,920
from Lees but it turns out that it's

300
00:11:52,699 --> 00:11:56,540
actually very easy to reconstruct a

301
00:11:54,920 --> 00:11:58,130
polynomial through the set of points and

302
00:11:56,540 --> 00:12:00,170
then you learn the secrets so in this

303
00:11:58,130 --> 00:12:03,649
case if three points on this polynomial

304
00:12:00,170 --> 00:12:05,060
every secret is possible but as soon as

305
00:12:03,649 --> 00:12:06,470
you have a fourth point you reconstruct

306
00:12:05,060 --> 00:12:09,229
the unique polynomial and you can just

307
00:12:06,470 --> 00:12:11,930
read off what the secret is okay so

308
00:12:09,230 --> 00:12:14,149
let's abstract this out into what the

309
00:12:11,930 --> 00:12:16,399
scheme actually looks like so the T out

310
00:12:14,149 --> 00:12:19,339
of LRT plus one out of El secret sharing

311
00:12:16,399 --> 00:12:21,019
scheme our goal is we have a secret s we

312
00:12:19,339 --> 00:12:23,449
want to share it amongst L different

313
00:12:21,019 --> 00:12:25,519
shareholders we want to do this in such

314
00:12:23,449 --> 00:12:27,109
a way that any t plus one or more of

315
00:12:25,519 --> 00:12:29,509
them can easily figure out what the

316
00:12:27,110 --> 00:12:31,540
secret is but any T or fewer of them

317
00:12:29,509 --> 00:12:34,160
can't learn anything about the secret

318
00:12:31,540 --> 00:12:38,180
and we're gonna do this by choosing a

319
00:12:34,160 --> 00:12:39,949
polynomial that has degree T when you

320
00:12:38,180 --> 00:12:41,930
evaluate this polynomial at zero you get

321
00:12:39,949 --> 00:12:43,880
the secret and is otherwise uniform

322
00:12:41,930 --> 00:12:46,550
random from our field with the

323
00:12:43,880 --> 00:12:48,110
coefficients from our field in order to

324
00:12:46,550 --> 00:12:50,449
reconstruct the secret these

325
00:12:48,110 --> 00:12:52,040
shareholders are just going to use oh

326
00:12:50,449 --> 00:12:53,660
and each shareholder is going to get a

327
00:12:52,040 --> 00:12:54,980
point on this polynomial different point

328
00:12:53,660 --> 00:12:56,930
it doesn't matter which points they get

329
00:12:54,980 --> 00:12:59,420
as long as they're not the one that

330
00:12:56,930 --> 00:13:00,319
holds the secret and then to reconstruct

331
00:12:59,420 --> 00:13:02,029
they're going to use Lagrange

332
00:13:00,319 --> 00:13:03,949
interpolation or some other polynomial

333
00:13:02,029 --> 00:13:06,649
interpolation algorithm so the exact

334
00:13:03,949 --> 00:13:08,569
details of that formula aren't important

335
00:13:06,649 --> 00:13:10,130
but it should be easy to see that asking

336
00:13:08,569 --> 00:13:12,439
a computer to do that it's no big deal

337
00:13:10,130 --> 00:13:13,819
it can do it very quickly and this

338
00:13:12,440 --> 00:13:16,040
explains why we need a finite field

339
00:13:13,819 --> 00:13:17,120
because we need to be able to I don't

340
00:13:16,040 --> 00:13:20,510
have a pointer you need to be able to

341
00:13:17,120 --> 00:13:21,860
compute that inverse there that's that's

342
00:13:20,510 --> 00:13:26,839
basically the only reason we need a

343
00:13:21,860 --> 00:13:27,889
field okay so this gives us privacy but

344
00:13:26,839 --> 00:13:31,579
does it actually give us information

345
00:13:27,889 --> 00:13:33,800
retrieval that's the next question so it

346
00:13:31,579 --> 00:13:35,540
turns out it does the reason that it

347
00:13:33,800 --> 00:13:36,769
does is because Shamir's secret sharing

348
00:13:35,540 --> 00:13:39,259
has a nice property which we call

349
00:13:36,769 --> 00:13:41,810
linearity so the observation here is if

350
00:13:39,259 --> 00:13:43,670
you evaluate a polynomial at 0 and you

351
00:13:41,810 --> 00:13:46,489
get a and you evaluate some other

352
00:13:43,670 --> 00:13:48,199
polynomial at 0 and you get B if you add

353
00:13:46,490 --> 00:13:50,269
these two polynomials together and then

354
00:13:48,199 --> 00:13:52,729
evaluate them at 0 you're just going to

355
00:13:50,269 --> 00:13:54,290
get a plus B so they just add up nice

356
00:13:52,730 --> 00:13:57,230
when you add and if i take the

357
00:13:54,290 --> 00:14:00,709
polynomial that evaluates to at zero to

358
00:13:57,230 --> 00:14:03,709
a and I multiply it by a scalar C then I

359
00:14:00,709 --> 00:14:06,138
evaluate that at zero I get C times a so

360
00:14:03,709 --> 00:14:09,079
I can add these things and the the

361
00:14:06,139 --> 00:14:11,060
secrets that they encode just add and I

362
00:14:09,079 --> 00:14:14,029
can multiply by scalars and the secret

363
00:14:11,060 --> 00:14:15,800
same code just multiply likewise when we

364
00:14:14,029 --> 00:14:21,139
look at what's happening in that PIR

365
00:14:15,800 --> 00:14:22,729
protocol it's all linear as well so when

366
00:14:21,139 --> 00:14:24,589
you multiply a vector times a matrix

367
00:14:22,730 --> 00:14:26,420
you're just taking a bunch of scalar

368
00:14:24,589 --> 00:14:28,100
multiple scalar multiples and then

369
00:14:26,420 --> 00:14:30,649
you're adding them together and when you

370
00:14:28,100 --> 00:14:32,570
go to reconstruct the Lagrangian

371
00:14:30,649 --> 00:14:33,920
interpolation formula you're doing a

372
00:14:32,570 --> 00:14:35,720
bunch of scalar multiplies in an

373
00:14:33,920 --> 00:14:37,550
addition so everything here it just

374
00:14:35,720 --> 00:14:39,110
requires that scalar multiplication and

375
00:14:37,550 --> 00:14:41,389
addition holds so we can take secret

376
00:14:39,110 --> 00:14:45,440
cherries multiply them by scalars etc

377
00:14:41,389 --> 00:14:47,870
now we can do our vector matrix multiply

378
00:14:45,440 --> 00:14:49,610
so back to the protocol the user is

379
00:14:47,870 --> 00:14:51,829
going to Shamir secret share this

380
00:14:49,610 --> 00:14:54,920
standard basis vector one component at a

381
00:14:51,829 --> 00:14:57,170
time send the resulting vectors of

382
00:14:54,920 --> 00:14:58,339
shares to the various servers the

383
00:14:57,170 --> 00:15:00,229
server's are going to multiply the

384
00:14:58,339 --> 00:15:02,120
vectors of shares by the database and

385
00:15:00,230 --> 00:15:03,829
the result back to the client and then

386
00:15:02,120 --> 00:15:06,529
the client is going to use the ground

387
00:15:03,829 --> 00:15:08,479
interpolation to reconstruct a vector

388
00:15:06,529 --> 00:15:11,449
which gives the row that it was looking

389
00:15:08,480 --> 00:15:14,660
for and this is going to give us perfect

390
00:15:11,449 --> 00:15:16,219
privacy provided not too many of the

391
00:15:14,660 --> 00:15:20,350
database servers are talking to one

392
00:15:16,220 --> 00:15:24,819
another and no privacy if that

393
00:15:20,350 --> 00:15:24,819
assumption doesn't hold excuse me

394
00:15:32,170 --> 00:15:38,089
okay so yep II we have PIR can we get on

395
00:15:36,560 --> 00:15:40,880
to the new stuff so that all everything

396
00:15:38,089 --> 00:15:43,130
I've told you so far is be known for a

397
00:15:40,880 --> 00:15:44,899
long time and it's not my own ideas but

398
00:15:43,130 --> 00:15:47,329
what I'm gonna tell you now is is the

399
00:15:44,899 --> 00:15:51,170
new stuff so the first thing we're gonna

400
00:15:47,329 --> 00:15:53,899
look at is can we let users fetch

401
00:15:51,170 --> 00:15:56,089
several blocks without just doing

402
00:15:53,899 --> 00:15:57,920
several queries in a row so can we do

403
00:15:56,089 --> 00:15:59,420
this at a lower cost and in particular

404
00:15:57,920 --> 00:16:01,969
we're gonna try to let you fetch several

405
00:15:59,420 --> 00:16:03,920
blocks and have the cost all of the

406
00:16:01,970 --> 00:16:07,850
various costs involved be about the same

407
00:16:03,920 --> 00:16:10,699
as just fetching one block so how might

408
00:16:07,850 --> 00:16:12,920
we do this let's go back to the the

409
00:16:10,699 --> 00:16:14,719
basic idea the basic idea was we're

410
00:16:12,920 --> 00:16:16,430
gonna take one of these standard basis

411
00:16:14,720 --> 00:16:17,930
vectors and multiply it by the matrix

412
00:16:16,430 --> 00:16:20,479
but we're gonna use secret cheering to

413
00:16:17,930 --> 00:16:23,540
split this computation up if you wanted

414
00:16:20,480 --> 00:16:26,660
to fetch several blocks you could send

415
00:16:23,540 --> 00:16:29,990
all of these requests simultaneously as

416
00:16:26,660 --> 00:16:31,759
one big long matrix and now rather than

417
00:16:29,990 --> 00:16:32,750
doing a vector matrix multiplication

418
00:16:31,759 --> 00:16:35,089
you're doing a matrix matrix

419
00:16:32,750 --> 00:16:38,300
multiplication and one immediate

420
00:16:35,089 --> 00:16:41,600
observation is that the cost of

421
00:16:38,300 --> 00:16:43,370
multiplying two matrices if you use a

422
00:16:41,600 --> 00:16:44,959
fast matrix multiplication algorithm is

423
00:16:43,370 --> 00:16:47,120
a little bit lower than the cost of

424
00:16:44,959 --> 00:16:48,739
doing each row individually so we can

425
00:16:47,120 --> 00:16:50,720
save a little bit of computation cost

426
00:16:48,740 --> 00:16:52,279
but the communication cost doesn't

427
00:16:50,720 --> 00:16:54,439
change the computation cost doesn't

428
00:16:52,279 --> 00:16:55,880
change too dramatically so can we do

429
00:16:54,439 --> 00:16:59,209
better than this and it turns out yeah

430
00:16:55,880 --> 00:17:00,470
we can do a lot better than this the way

431
00:16:59,209 --> 00:17:03,560
we're gonna do it is we're gonna use

432
00:17:00,470 --> 00:17:05,929
something called a ramp scheme so going

433
00:17:03,560 --> 00:17:08,299
back to basic secret cheering we can

434
00:17:05,929 --> 00:17:10,579
draw a graph like this to represent how

435
00:17:08,299 --> 00:17:14,150
much data or how much information that

436
00:17:10,579 --> 00:17:16,250
data is revealed to the shareholders

437
00:17:14,150 --> 00:17:20,630
based on how many shares they have so if

438
00:17:16,250 --> 00:17:23,510
we have this is the two out of L version

439
00:17:20,630 --> 00:17:25,400
if you have fewer than two shares

440
00:17:23,510 --> 00:17:26,750
I know it's discrete and I've drawn it

441
00:17:25,400 --> 00:17:29,299
as if it's continuous but just ignore

442
00:17:26,750 --> 00:17:31,070
that if you have fewer than two shares

443
00:17:29,299 --> 00:17:34,580
you have zero information nothing at all

444
00:17:31,070 --> 00:17:36,230
about the secret as soon as you have two

445
00:17:34,580 --> 00:17:37,790
shares you jump up to complete

446
00:17:36,230 --> 00:17:39,290
information we know everything there is

447
00:17:37,790 --> 00:17:41,000
to know about the secret because we have

448
00:17:39,290 --> 00:17:43,990
two shares we can reconstruct the line

449
00:17:41,000 --> 00:17:46,910
in a wrap scheme

450
00:17:43,990 --> 00:17:50,510
we relax us a little bit if you have

451
00:17:46,910 --> 00:17:52,880
fewer than two shares you still have

452
00:17:50,510 --> 00:17:55,460
zero information at all about the secret

453
00:17:52,880 --> 00:17:57,800
but now to get complete information you

454
00:17:55,460 --> 00:18:00,860
have to have seed in this case four you

455
00:17:57,800 --> 00:18:03,200
have to have t plus Q shares so in the

456
00:18:00,860 --> 00:18:05,120
secret sharing scheme it was Q plus one

457
00:18:03,200 --> 00:18:07,460
here we're saying or T plus one now

458
00:18:05,120 --> 00:18:09,739
we're saying is t plus Q for some q and

459
00:18:07,460 --> 00:18:13,070
q could be bigger than one and the

460
00:18:09,740 --> 00:18:15,740
upshot of this is we can now fit q times

461
00:18:13,070 --> 00:18:17,360
as many secret bits into each share so

462
00:18:15,740 --> 00:18:19,250
the shares are still just points on a

463
00:18:17,360 --> 00:18:20,840
polynomial they haven't changed they

464
00:18:19,250 --> 00:18:22,970
look exactly like they used to but

465
00:18:20,840 --> 00:18:28,909
they're now encoding Q times as many

466
00:18:22,970 --> 00:18:31,550
secret bits so how might we do this this

467
00:18:28,910 --> 00:18:33,200
is again still not a new idea ramp

468
00:18:31,550 --> 00:18:34,460
schemes have been studied basically as

469
00:18:33,200 --> 00:18:36,620
long as secret sharing schemes that

470
00:18:34,460 --> 00:18:38,060
Venus have been studied I was an infant

471
00:18:36,620 --> 00:18:39,739
when people were first looking at this

472
00:18:38,060 --> 00:18:43,070
stuff so let's I can't claim credit for

473
00:18:39,740 --> 00:18:45,020
this but this is the way that almost

474
00:18:43,070 --> 00:18:47,330
every paper in fact every paper that

475
00:18:45,020 --> 00:18:49,040
I've ever seen this is how they do the

476
00:18:47,330 --> 00:18:52,970
ramp scheme version of Shamir secret

477
00:18:49,040 --> 00:18:54,740
sharing so in the original version we

478
00:18:52,970 --> 00:18:58,400
had a say in this case a quadratic

479
00:18:54,740 --> 00:18:59,900
polynomial the constant coefficient I

480
00:18:58,400 --> 00:19:02,590
keep thinking I can use a laser pointer

481
00:18:59,900 --> 00:19:07,040
but I can't the constant coefficient is

482
00:19:02,590 --> 00:19:10,550
the secret and the other coefficients

483
00:19:07,040 --> 00:19:12,740
are uniform random and so the general

484
00:19:10,550 --> 00:19:15,200
way to turn this into a ramp scheme the

485
00:19:12,740 --> 00:19:17,480
most common way is to replace one of

486
00:19:15,200 --> 00:19:19,550
these random coefficients with another

487
00:19:17,480 --> 00:19:21,080
secret and then in order to make sure

488
00:19:19,550 --> 00:19:22,760
that we still have the level of privacy

489
00:19:21,080 --> 00:19:24,290
we had before add another term so we

490
00:19:22,760 --> 00:19:26,240
increase the degree of the polynomial by

491
00:19:24,290 --> 00:19:31,460
one we have the two lowest order

492
00:19:26,240 --> 00:19:33,910
coefficients are now two secrets there's

493
00:19:31,460 --> 00:19:37,070
another way you can do it and this is

494
00:19:33,910 --> 00:19:40,210
apparently not very common but it seems

495
00:19:37,070 --> 00:19:42,950
very natural to me rather than replacing

496
00:19:40,210 --> 00:19:44,900
coefficients with secrets we can think

497
00:19:42,950 --> 00:19:46,790
of okay the secret is a point on the

498
00:19:44,900 --> 00:19:48,290
polynomial it's a specific point and we

499
00:19:46,790 --> 00:19:50,389
can encode a different secret at a

500
00:19:48,290 --> 00:19:52,070
different point in the polynomial and

501
00:19:50,390 --> 00:19:53,660
again we're gonna have to increase the

502
00:19:52,070 --> 00:19:55,159
degree of the polynomial to make sure we

503
00:19:53,660 --> 00:19:56,780
get our privacy but rather than using

504
00:19:55,160 --> 00:19:57,170
coefficients to store secrets we're

505
00:19:56,780 --> 00:20:00,560
going to use

506
00:19:57,170 --> 00:20:02,750
points so here we have our first secret

507
00:20:00,560 --> 00:20:04,610
at the y-intercept but now when you

508
00:20:02,750 --> 00:20:06,200
evaluate this polynomial at one you get

509
00:20:04,610 --> 00:20:09,379
a different secret so rather than the

510
00:20:06,200 --> 00:20:10,910
linear coefficient it's the evaluation

511
00:20:09,380 --> 00:20:12,560
at one that gives a second secret and

512
00:20:10,910 --> 00:20:13,940
then to form our secret cheering

513
00:20:12,560 --> 00:20:15,679
polynomial we'll choose a couple of

514
00:20:13,940 --> 00:20:17,900
other points completely at random and

515
00:20:15,680 --> 00:20:19,400
then we'll interpolate through them to

516
00:20:17,900 --> 00:20:21,740
find the polynomial that connects our

517
00:20:19,400 --> 00:20:23,330
secrets to these random points and then

518
00:20:21,740 --> 00:20:24,560
we'll evaluate it at some other places

519
00:20:23,330 --> 00:20:26,870
to get other shares for other

520
00:20:24,560 --> 00:20:29,690
shareholders so we have two different

521
00:20:26,870 --> 00:20:31,689
ways to share in this case two secrets

522
00:20:29,690 --> 00:20:34,760
in the same secret certain polynomial

523
00:20:31,690 --> 00:20:38,780
the question is why might we want to use

524
00:20:34,760 --> 00:20:40,370
one version over the other and in many

525
00:20:38,780 --> 00:20:42,260
cases it really doesn't matter which one

526
00:20:40,370 --> 00:20:45,469
you use but in our case the second

527
00:20:42,260 --> 00:20:46,850
option has a distinct advantage so in

528
00:20:45,470 --> 00:20:48,200
particular if you look at the first

529
00:20:46,850 --> 00:20:50,419
option this is a really simple

530
00:20:48,200 --> 00:20:51,710
conceptually you know you just did the

531
00:20:50,420 --> 00:20:53,360
secrets are just coefficients you

532
00:20:51,710 --> 00:20:55,940
interpolate that polynomial and you read

533
00:20:53,360 --> 00:20:57,620
the coefficients off but it's only kind

534
00:20:55,940 --> 00:20:59,270
of sort of homomorphic so if you

535
00:20:57,620 --> 00:21:02,179
multiply two of these polynomials

536
00:20:59,270 --> 00:21:06,560
together that first secret multiplies

537
00:21:02,180 --> 00:21:10,220
together but the secret that you get on

538
00:21:06,560 --> 00:21:12,500
the Consular the linear term here isn't

539
00:21:10,220 --> 00:21:13,820
the product of the linear terms of the

540
00:21:12,500 --> 00:21:16,490
two polynomials you multiplied together

541
00:21:13,820 --> 00:21:18,139
it's some other more complicated formula

542
00:21:16,490 --> 00:21:19,580
and if you had lots of secrets it gets

543
00:21:18,140 --> 00:21:20,840
more and more complicated we could tell

544
00:21:19,580 --> 00:21:22,189
you exactly what these things are going

545
00:21:20,840 --> 00:21:23,929
to look like but they're never going to

546
00:21:22,190 --> 00:21:25,820
be the product of our two secrets only

547
00:21:23,930 --> 00:21:27,680
the constant term will give us the

548
00:21:25,820 --> 00:21:31,159
product of our two secrets B and D in

549
00:21:27,680 --> 00:21:34,370
this case when we look at the second

550
00:21:31,160 --> 00:21:35,900
option though right so the constant

551
00:21:34,370 --> 00:21:38,360
terms multiply the higher order terms do

552
00:21:35,900 --> 00:21:40,280
not multiply when we look at the second

553
00:21:38,360 --> 00:21:42,800
option it's a little bit more

554
00:21:40,280 --> 00:21:44,300
complicated sort of it's actually not if

555
00:21:42,800 --> 00:21:46,240
you look at it the right way they're

556
00:21:44,300 --> 00:21:48,770
both just linear combinations of

557
00:21:46,240 --> 00:21:51,470
different in different bases so it's

558
00:21:48,770 --> 00:21:53,840
actually equivalent but it's got a nicer

559
00:21:51,470 --> 00:21:55,370
homomorphic property so no matter where

560
00:21:53,840 --> 00:21:57,020
which point we're talking about which

561
00:21:55,370 --> 00:21:58,459
x-coordinate we're talking about on the

562
00:21:57,020 --> 00:22:00,620
polynomials when you multiply two

563
00:21:58,460 --> 00:22:03,170
polynomials together and evaluate it at

564
00:22:00,620 --> 00:22:04,699
that point it's the same as evaluating

565
00:22:03,170 --> 00:22:06,770
those two polynomials at that point and

566
00:22:04,700 --> 00:22:08,510
then multiplying together so the secrets

567
00:22:06,770 --> 00:22:10,110
when you evaluate at 0 multiply together

568
00:22:08,510 --> 00:22:11,850
and the secrets when you evaluate it

569
00:22:10,110 --> 00:22:13,979
multiplied together this is going to be

570
00:22:11,850 --> 00:22:18,480
a big advantage for us when we go back

571
00:22:13,980 --> 00:22:20,100
to Pio okay so now I said you want to

572
00:22:18,480 --> 00:22:22,200
get cue blocks we have one of these

573
00:22:20,100 --> 00:22:25,500
matrices it's got cue rows in it and

574
00:22:22,200 --> 00:22:26,880
each one is just a standard query what

575
00:22:25,500 --> 00:22:28,770
we're gonna do is we're gonna use one of

576
00:22:26,880 --> 00:22:31,020
these rap schemes and we're going to

577
00:22:28,770 --> 00:22:35,299
encode all of these queries together in

578
00:22:31,020 --> 00:22:38,040
a single vector so we're gonna choose

579
00:22:35,299 --> 00:22:41,700
polynomials that pass through so this

580
00:22:38,040 --> 00:22:43,950
polynomial f1 here when you evaluate it

581
00:22:41,700 --> 00:22:45,660
at 0 you get this component when you

582
00:22:43,950 --> 00:22:47,250
evaluate it at 1 you get this and when

583
00:22:45,660 --> 00:22:49,140
we evaluate at 2 you get the next one

584
00:22:47,250 --> 00:22:52,140
and when you evaluate it at Q minus 1

585
00:22:49,140 --> 00:22:54,000
you get this and then it has T random

586
00:22:52,140 --> 00:22:55,679
points at it and we've interpolate it

587
00:22:54,000 --> 00:22:57,720
through those to get a degree T plus Q

588
00:22:55,679 --> 00:23:00,929
polynomial t plus Q minus one polynomial

589
00:22:57,720 --> 00:23:02,730
and f2 likewise when evaluated at 0 you

590
00:23:00,929 --> 00:23:04,410
get this when you evaluate it at 1 you

591
00:23:02,730 --> 00:23:05,520
get this when you evaluate it at 2 you

592
00:23:04,410 --> 00:23:09,090
get this and so on

593
00:23:05,520 --> 00:23:11,280
so we've taken our matrix with Q rows

594
00:23:09,090 --> 00:23:15,270
and we've turned it into still just a

595
00:23:11,280 --> 00:23:16,980
vector of secret shares and then going

596
00:23:15,270 --> 00:23:19,950
back to the PIR protocol we still just

597
00:23:16,980 --> 00:23:21,600
send one evaluation of this vector to

598
00:23:19,950 --> 00:23:24,780
each of the servers and they still just

599
00:23:21,600 --> 00:23:26,399
do the multiplication and if you think

600
00:23:24,780 --> 00:23:27,899
about it or scribble on a piece of paper

601
00:23:26,400 --> 00:23:30,870
it's very easy to come in to yourself

602
00:23:27,900 --> 00:23:33,179
that they're going to the responses they

603
00:23:30,870 --> 00:23:35,399
give back will interpolate to Q

604
00:23:33,179 --> 00:23:38,370
different records instead of just one

605
00:23:35,400 --> 00:23:40,760
and so if you look at what does this

606
00:23:38,370 --> 00:23:44,299
mean for performance this is giving the

607
00:23:40,760 --> 00:23:47,549
per server cost of running the protocol

608
00:23:44,299 --> 00:23:49,379
Goldberg 2007 is the basic protocol that

609
00:23:47,549 --> 00:23:50,639
I started with that I was modifying with

610
00:23:49,380 --> 00:23:52,320
the RAM schemes and then the batch

611
00:23:50,640 --> 00:23:54,000
queries is what I just talked about if

612
00:23:52,320 --> 00:23:56,939
you want to get cue records with

613
00:23:54,000 --> 00:23:58,650
Goldbergs protocol you upload a length

614
00:23:56,940 --> 00:24:00,809
our vector but you have to upload q of

615
00:23:58,650 --> 00:24:03,299
them so you upload q our field elements

616
00:24:00,809 --> 00:24:05,549
to each server you download a length s

617
00:24:03,299 --> 00:24:08,280
element for each query so you download Q

618
00:24:05,549 --> 00:24:11,400
s field elements from each server each

619
00:24:08,280 --> 00:24:14,520
server is doing a vector matrix multiply

620
00:24:11,400 --> 00:24:17,280
which takes our s it's actually 2 RS

621
00:24:14,520 --> 00:24:19,860
field operations not our s and we have

622
00:24:17,280 --> 00:24:22,080
to do that q times and the storage cost

623
00:24:19,860 --> 00:24:22,719
at each server is RS States Thor the

624
00:24:22,080 --> 00:24:26,230
whole matrix

625
00:24:22,720 --> 00:24:27,880
in our cost all of those are the same

626
00:24:26,230 --> 00:24:29,860
but without the cues around so we

627
00:24:27,880 --> 00:24:31,630
basically if Q is one the costs are the

628
00:24:29,860 --> 00:24:33,909
same but as soon as Q is two we've cut

629
00:24:31,630 --> 00:24:35,350
the cost down by a factor of two if Q is

630
00:24:33,910 --> 00:24:37,420
three we've cut it down by a factor of

631
00:24:35,350 --> 00:24:40,179
three and so on so we have a factor Q

632
00:24:37,420 --> 00:24:42,790
improvement in everything except for the

633
00:24:40,180 --> 00:24:45,820
storage cost at the server's so that's

634
00:24:42,790 --> 00:24:46,510
pretty cool but what's the trade-off

635
00:24:45,820 --> 00:24:48,070
here

636
00:24:46,510 --> 00:24:50,220
well okay don't worry about the

637
00:24:48,070 --> 00:24:54,010
trade-off let's just move on

638
00:24:50,220 --> 00:24:56,410
so our second goal is let's fetch only

639
00:24:54,010 --> 00:24:58,840
one block again but let's do it at a way

640
00:24:56,410 --> 00:25:03,190
lower cost and fetching one block used

641
00:24:58,840 --> 00:25:06,399
to cost so the idea here is actually

642
00:25:03,190 --> 00:25:08,050
very similar we're gonna take the

643
00:25:06,400 --> 00:25:09,640
database in this case rather than the

644
00:25:08,050 --> 00:25:11,649
query and we're gonna use these ramp

645
00:25:09,640 --> 00:25:13,750
schemes so with first step is you take

646
00:25:11,650 --> 00:25:16,210
the database which has these are rows

647
00:25:13,750 --> 00:25:18,160
and we're gonna express it in sort of a

648
00:25:16,210 --> 00:25:22,510
block form we're gonna say let's look at

649
00:25:18,160 --> 00:25:24,460
it as R over u matrices stacked on top

650
00:25:22,510 --> 00:25:27,160
of each other where each matrix is of

651
00:25:24,460 --> 00:25:28,480
height u so we're just rewriting at this

652
00:25:27,160 --> 00:25:30,820
point we're saying take the first new

653
00:25:28,480 --> 00:25:32,560
rows call them one matrix and then

654
00:25:30,820 --> 00:25:36,040
they're stacked on top of the next Uros

655
00:25:32,560 --> 00:25:39,970
that's the second matrix and so on then

656
00:25:36,040 --> 00:25:42,399
once we've done that we're going to use

657
00:25:39,970 --> 00:25:44,320
this rap scheme construction we don't

658
00:25:42,400 --> 00:25:46,240
have to choose any random points here we

659
00:25:44,320 --> 00:25:49,210
just interpolate through the various

660
00:25:46,240 --> 00:25:52,450
rows of these block matrices so we find

661
00:25:49,210 --> 00:25:55,720
a vector of polynomials where when you

662
00:25:52,450 --> 00:25:57,190
evaluate these polynomials like the

663
00:25:55,720 --> 00:25:59,920
first polynomial in this vector of

664
00:25:57,190 --> 00:26:06,670
polynomials at zero you get the first

665
00:25:59,920 --> 00:26:08,380
component from from you get this guy and

666
00:26:06,670 --> 00:26:10,360
when you evaluate that first polynomial

667
00:26:08,380 --> 00:26:12,010
at one you get this guy and when you

668
00:26:10,360 --> 00:26:14,830
evaluate the second polynomial in the

669
00:26:12,010 --> 00:26:17,760
first vector at zero you get this guy

670
00:26:14,830 --> 00:26:20,470
and so on so we're just taking our

671
00:26:17,760 --> 00:26:23,290
matrix we're thinking of it as a

672
00:26:20,470 --> 00:26:25,870
collection of smaller matrices and then

673
00:26:23,290 --> 00:26:28,810
we're encoding each matrix into a vector

674
00:26:25,870 --> 00:26:30,250
of polynomials if we want we could

675
00:26:28,810 --> 00:26:31,840
choose some random points in there and

676
00:26:30,250 --> 00:26:33,520
we get something called tau independence

677
00:26:31,840 --> 00:26:35,709
which I'm not really going to talk about

678
00:26:33,520 --> 00:26:36,050
it's useful property if you want to make

679
00:26:35,710 --> 00:26:37,730
sure that

680
00:26:36,050 --> 00:26:39,860
database servers can't actually learn

681
00:26:37,730 --> 00:26:41,240
the contents of the database they're

682
00:26:39,860 --> 00:26:43,070
helping to host so we're gonna assume

683
00:26:41,240 --> 00:26:44,930
the database servers are allowed to know

684
00:26:43,070 --> 00:26:48,260
that so here we've taken the database

685
00:26:44,930 --> 00:26:53,840
which was R by s and we've turned it

686
00:26:48,260 --> 00:26:55,520
into R over u by s polynomials then

687
00:26:53,840 --> 00:26:57,110
we're gonna take these polynomials and

688
00:26:55,520 --> 00:26:58,970
we're gonna give evaluations these

689
00:26:57,110 --> 00:27:00,770
vectors of polynomials are I guess

690
00:26:58,970 --> 00:27:03,560
matrices of polymers and we're gonna

691
00:27:00,770 --> 00:27:05,510
give evaluations teach server so now

692
00:27:03,560 --> 00:27:09,139
each server rather than holding a

693
00:27:05,510 --> 00:27:12,879
database of dimensions R by s holds a

694
00:27:09,140 --> 00:27:15,800
database of dimensions are over u by s

695
00:27:12,880 --> 00:27:19,220
so they're holding a factor u less data

696
00:27:15,800 --> 00:27:22,159
that they were before and the user can

697
00:27:19,220 --> 00:27:23,540
query these these databases in pretty

698
00:27:22,160 --> 00:27:26,030
much the exact same way they were

699
00:27:23,540 --> 00:27:28,520
querying before the only difference is

700
00:27:26,030 --> 00:27:32,060
if I want the first role from the

701
00:27:28,520 --> 00:27:36,920
original matrix then I need to query the

702
00:27:32,060 --> 00:27:39,320
first row in this matrix so this row and

703
00:27:36,920 --> 00:27:41,270
I need to hide my secret in the secret

704
00:27:39,320 --> 00:27:43,939
cheering polynomial at x equals 0 and if

705
00:27:41,270 --> 00:27:47,540
I want the second row I still query the

706
00:27:43,940 --> 00:27:49,930
first row of this matrix but I hide my

707
00:27:47,540 --> 00:27:53,180
secret for this query the secret

708
00:27:49,930 --> 00:27:54,860
standard basis vector at x equals 1 at a

709
00:27:53,180 --> 00:27:57,080
different point and now when I multiply

710
00:27:54,860 --> 00:27:59,060
the two polynomials together because of

711
00:27:57,080 --> 00:28:02,270
that nice homomorphic property I talked

712
00:27:59,060 --> 00:28:06,020
about everything works out and I get

713
00:28:02,270 --> 00:28:09,170
back the the particular row that I was

714
00:28:06,020 --> 00:28:11,260
looking for so when we look at the cost

715
00:28:09,170 --> 00:28:14,630
of this compared to Goldbergs protocol

716
00:28:11,260 --> 00:28:16,879
oh those queues shouldn't be there

717
00:28:14,630 --> 00:28:18,230
that's a copy-paste there so I'm we're

718
00:28:16,880 --> 00:28:20,150
only looking at the cost to fetch one

719
00:28:18,230 --> 00:28:24,880
block and this should say one so this

720
00:28:20,150 --> 00:28:28,310
should be RS RS RS in this new protocol

721
00:28:24,880 --> 00:28:29,900
the upload cost is now only R over you

722
00:28:28,310 --> 00:28:31,700
because we're sending a shorter vector

723
00:28:29,900 --> 00:28:35,690
because now our matrix that each server

724
00:28:31,700 --> 00:28:38,300
holds is a factor you shorter the

725
00:28:35,690 --> 00:28:40,160
computation cost is now R over u by s

726
00:28:38,300 --> 00:28:43,040
instead of R by s so we've saved a

727
00:28:40,160 --> 00:28:45,560
factor u computation time at each one of

728
00:28:43,040 --> 00:28:47,270
the servers and the storage cost for

729
00:28:45,560 --> 00:28:48,559
each server is also reduced by a factor

730
00:28:47,270 --> 00:28:49,970
u because now instead

731
00:28:48,559 --> 00:28:51,289
holding the whole thing they're holding

732
00:28:49,970 --> 00:28:55,129
something that's effect are you smaller

733
00:28:51,289 --> 00:28:59,330
so we've minimized again three of the

734
00:28:55,129 --> 00:29:01,600
costs by factory you I've actually gone

735
00:28:59,330 --> 00:29:04,279
through this a lot faster than I had

736
00:29:01,600 --> 00:29:05,719
expected so yeah there's some more but I

737
00:29:04,279 --> 00:29:07,429
didn't expect to be a quite so soon so

738
00:29:05,720 --> 00:29:09,379
anyways that that's cool too but

739
00:29:07,429 --> 00:29:11,600
seriously like I just glossed over the

740
00:29:09,379 --> 00:29:13,490
trade off last time what is the trade

741
00:29:11,600 --> 00:29:15,199
off there's got to be a trade off you

742
00:29:13,490 --> 00:29:17,269
can't just like infinitely make things

743
00:29:15,200 --> 00:29:18,950
faster so it turns off yes there is a

744
00:29:17,269 --> 00:29:23,139
trade off and so the trade off comes

745
00:29:18,950 --> 00:29:26,509
from what's called Byzantine robustness

746
00:29:23,139 --> 00:29:28,879
so I kept saying we have L servers we're

747
00:29:26,509 --> 00:29:31,309
gonna create secret shares so that at

748
00:29:28,879 --> 00:29:34,399
most T out of L servers can collude and

749
00:29:31,309 --> 00:29:35,720
we have privacy if if you thought about

750
00:29:34,399 --> 00:29:37,879
that you might have wondered why would

751
00:29:35,720 --> 00:29:39,320
you set T less than like L minus one

752
00:29:37,879 --> 00:29:41,629
right you need T plus 1 points to

753
00:29:39,320 --> 00:29:44,809
interpolate you set T equals to L minus

754
00:29:41,629 --> 00:29:47,389
1 and then you can always interpolate

755
00:29:44,809 --> 00:29:48,799
but that way you've maximized the number

756
00:29:47,389 --> 00:29:50,418
of servers that are allowed to clewd

757
00:29:48,799 --> 00:29:52,158
without troubling things happening and

758
00:29:50,419 --> 00:29:54,320
it turns out there's a reason why you

759
00:29:52,159 --> 00:29:56,509
might want to set the privacy threshold

760
00:29:54,320 --> 00:29:57,649
smaller than the total number of servers

761
00:29:56,509 --> 00:29:59,450
and that's because after we've

762
00:29:57,649 --> 00:30:01,399
replicated our database to lots of

763
00:29:59,450 --> 00:30:03,289
different servers we have to worry about

764
00:30:01,399 --> 00:30:07,039
what happens if one of these servers is

765
00:30:03,289 --> 00:30:09,919
evil or misbehaving in some way maybe

766
00:30:07,039 --> 00:30:13,429
it's a malfunction and gives us a bad

767
00:30:09,919 --> 00:30:14,960
response right so when we're talking to

768
00:30:13,429 --> 00:30:16,730
one database server either that server

769
00:30:14,960 --> 00:30:18,440
works or it doesn't if it doesn't were

770
00:30:16,730 --> 00:30:19,759
out of luck great yields of database if

771
00:30:18,440 --> 00:30:21,649
he doesn't answer a query well we're

772
00:30:19,759 --> 00:30:23,629
kind of messed up but now that we've

773
00:30:21,649 --> 00:30:26,090
split it to lots of servers it only

774
00:30:23,629 --> 00:30:30,320
takes one bad apple to possibly spoil

775
00:30:26,090 --> 00:30:31,699
the whole query and so the protocols in

776
00:30:30,320 --> 00:30:34,460
particularly the protocol I was just

777
00:30:31,700 --> 00:30:36,499
talking about has a nice way to deal

778
00:30:34,460 --> 00:30:38,480
with some of the servers giving bad

779
00:30:36,499 --> 00:30:41,440
responses and that is to look at these

780
00:30:38,480 --> 00:30:43,909
secret shares and interpret them as

781
00:30:41,440 --> 00:30:44,960
reed-solomon codes for those of you who

782
00:30:43,909 --> 00:30:46,700
know what those are and then you can

783
00:30:44,960 --> 00:30:48,320
throw standard coding theory algorithms

784
00:30:46,700 --> 00:30:50,299
to figure out which responses were

785
00:30:48,320 --> 00:30:51,740
incorrect and still interpolate but in

786
00:30:50,299 --> 00:30:55,279
order to do this you need to have extra

787
00:30:51,740 --> 00:30:57,139
responses so nice visualization is if

788
00:30:55,279 --> 00:30:59,509
we're looking at the linear case the you

789
00:30:57,139 --> 00:31:02,449
need to to reconstruct if I have extra

790
00:30:59,509 --> 00:31:04,370
points on this line and then one

791
00:31:02,450 --> 00:31:05,990
point that's not on the line it's pretty

792
00:31:04,370 --> 00:31:07,489
easy to see that okay this was the bad

793
00:31:05,990 --> 00:31:09,110
share I can still figure out what the

794
00:31:07,490 --> 00:31:11,120
line is here because all of these other

795
00:31:09,110 --> 00:31:14,090
points are on the line so that

796
00:31:11,120 --> 00:31:15,709
visualization is not so nice when you

797
00:31:14,090 --> 00:31:17,570
look at higher degree polynomials but

798
00:31:15,710 --> 00:31:19,610
the basic idea is exactly the same and

799
00:31:17,570 --> 00:31:22,700
there exists efficient algorithms that

800
00:31:19,610 --> 00:31:24,649
can figure out which points are the

801
00:31:22,700 --> 00:31:27,380
wrong points and can still find the

802
00:31:24,650 --> 00:31:29,270
polynomial as long as we set that

803
00:31:27,380 --> 00:31:32,900
privacy threshold to be lower than the

804
00:31:29,270 --> 00:31:35,480
total number of servers now in the first

805
00:31:32,900 --> 00:31:37,430
paper that came up with this basic

806
00:31:35,480 --> 00:31:39,590
protocol the actual title of the paper

807
00:31:37,430 --> 00:31:40,940
was improving the robustness of private

808
00:31:39,590 --> 00:31:43,429
information retrieval and the main

809
00:31:40,940 --> 00:31:45,830
contribution of this paper was that it

810
00:31:43,430 --> 00:31:49,430
could handle this exceptionally large

811
00:31:45,830 --> 00:31:51,500
number of Byzantine servers so L is the

812
00:31:49,430 --> 00:31:53,210
total number of servers T is the privacy

813
00:31:51,500 --> 00:31:55,550
threshold that it can handle this many

814
00:31:53,210 --> 00:31:59,660
servers which bad responses which was a

815
00:31:55,550 --> 00:32:03,020
big improvement over prior work fast

816
00:31:59,660 --> 00:32:05,360
forward five years we have better

817
00:32:03,020 --> 00:32:08,450
decoding algorithms and some neat ideas

818
00:32:05,360 --> 00:32:10,159
the bound for this exact same protocol

819
00:32:08,450 --> 00:32:13,310
just changing what the client does

820
00:32:10,160 --> 00:32:16,130
improve to this which means that now we

821
00:32:13,310 --> 00:32:18,500
can handle way more Byzantine servers so

822
00:32:16,130 --> 00:32:24,640
the observation is if you were happy

823
00:32:18,500 --> 00:32:28,160
with T and L and V back here then

824
00:32:24,640 --> 00:32:31,460
there's some wiggle room we can change

825
00:32:28,160 --> 00:32:33,350
the degrees of polynomials have the same

826
00:32:31,460 --> 00:32:36,290
level of robustness same level of

827
00:32:33,350 --> 00:32:39,949
privacy and maybe use some of that extra

828
00:32:36,290 --> 00:32:41,570
space to get better throughput so we end

829
00:32:39,950 --> 00:32:44,450
up with a set of parameters that we can

830
00:32:41,570 --> 00:32:46,550
play with so L here is the number of

831
00:32:44,450 --> 00:32:48,230
database servers T is that privacy

832
00:32:46,550 --> 00:32:50,990
threshold it says how many of them are

833
00:32:48,230 --> 00:32:53,630
allowed to clewd so if T collude nothing

834
00:32:50,990 --> 00:32:57,140
bad happens if T plus 1 collude bad

835
00:32:53,630 --> 00:32:58,310
things tau is that independence level I

836
00:32:57,140 --> 00:32:59,690
mentioned before we could add extra

837
00:32:58,310 --> 00:33:02,120
random points when we're doing the

838
00:32:59,690 --> 00:33:03,860
encoding to stop servers from learning

839
00:33:02,120 --> 00:33:05,510
the database so tau is how many servers

840
00:33:03,860 --> 00:33:07,459
are allowed to talk to one another

841
00:33:05,510 --> 00:33:09,230
before they can learn the database by

842
00:33:07,460 --> 00:33:12,080
default it's just zero but if you want

843
00:33:09,230 --> 00:33:15,980
to bump it up you can Q is the number of

844
00:33:12,080 --> 00:33:17,750
records that we get in each query you

845
00:33:15,980 --> 00:33:20,809
that parameter where we were shrinking

846
00:33:17,750 --> 00:33:23,780
the database down and then V is how many

847
00:33:20,809 --> 00:33:25,809
Byzantine servers we can tolerate and we

848
00:33:23,780 --> 00:33:29,299
can set these parameters any way we want

849
00:33:25,809 --> 00:33:30,649
as long as it satisfies this very simple

850
00:33:29,299 --> 00:33:32,780
equation and it's just a linear equation

851
00:33:30,650 --> 00:33:35,960
where you're adding them all together so

852
00:33:32,780 --> 00:33:37,240
this gives us lots of wiggle room to set

853
00:33:35,960 --> 00:33:39,799
parameters as we please

854
00:33:37,240 --> 00:33:43,910
so I've gone through this way faster

855
00:33:39,799 --> 00:33:45,168
than I had actually expected so I'll say

856
00:33:43,910 --> 00:33:49,280
a little bit more that I don't have

857
00:33:45,169 --> 00:33:52,309
slides to cover so one thing that I've

858
00:33:49,280 --> 00:33:55,070
actually looked at recently is just how

859
00:33:52,309 --> 00:33:57,620
low can we set V so how high can we set

860
00:33:55,070 --> 00:33:58,909
Q and you in particular I guess the

861
00:33:57,620 --> 00:34:00,469
other thing I didn't mention is that you

862
00:33:58,910 --> 00:34:02,059
can combine those two approaches there's

863
00:34:00,470 --> 00:34:03,530
a couple of little technical details

864
00:34:02,059 --> 00:34:06,020
that are relatively easy to work out and

865
00:34:03,530 --> 00:34:07,790
now I can fetch Q blocks for a factor

866
00:34:06,020 --> 00:34:09,168
you lower than the cost of fetching one

867
00:34:07,790 --> 00:34:11,810
block and that's where this equation

868
00:34:09,168 --> 00:34:14,179
comes from then the question becomes how

869
00:34:11,810 --> 00:34:16,580
low can we set V in practice right that

870
00:34:14,179 --> 00:34:17,060
we want to support robustness for a good

871
00:34:16,580 --> 00:34:19,549
reason

872
00:34:17,060 --> 00:34:21,918
how low can we set V and so if you

873
00:34:19,550 --> 00:34:23,570
consider a model where the server's have

874
00:34:21,918 --> 00:34:26,929
some reason why they're actually

875
00:34:23,570 --> 00:34:30,139
participating say for example they get

876
00:34:26,929 --> 00:34:31,730
some small monetary incentive to

877
00:34:30,139 --> 00:34:35,740
participate every time the answer query

878
00:34:31,730 --> 00:34:39,710
they get a small amount of money for it

879
00:34:35,739 --> 00:34:43,428
the observation is that if they give you

880
00:34:39,710 --> 00:34:45,949
a bad response and you're able to

881
00:34:43,429 --> 00:34:48,080
reconstruct so if so few of them gave

882
00:34:45,949 --> 00:34:49,939
you a bad response that only V were

883
00:34:48,080 --> 00:34:51,560
malicious only V were Byzantine and

884
00:34:49,940 --> 00:34:53,149
you're able to reconstruct you not only

885
00:34:51,560 --> 00:34:54,859
learn the record you were looking for

886
00:34:53,149 --> 00:34:57,859
but you figure out which ones of these

887
00:34:54,859 --> 00:34:59,509
servers gave you bad responses and you

888
00:34:57,859 --> 00:35:02,150
can stop involving them in future

889
00:34:59,510 --> 00:35:04,460
queries and so they stopped getting paid

890
00:35:02,150 --> 00:35:06,380
for participating and so if you make a

891
00:35:04,460 --> 00:35:08,240
rationality argument based on that you

892
00:35:06,380 --> 00:35:11,000
can show that these servers will

893
00:35:08,240 --> 00:35:12,680
actually always behave as if Q and you

894
00:35:11,000 --> 00:35:15,980
are both set to the smallest possible

895
00:35:12,680 --> 00:35:17,629
value because there's a very simple

896
00:35:15,980 --> 00:35:19,160
argument to show that they can't tell

897
00:35:17,630 --> 00:35:20,660
the difference between actually sorry

898
00:35:19,160 --> 00:35:22,850
they'll behave as if Q is set to the

899
00:35:20,660 --> 00:35:24,859
smallest value is fixed because they

900
00:35:22,850 --> 00:35:28,700
can't tell whether Q is being set to 1

901
00:35:24,859 --> 00:35:29,420
or 2 or 3 or 4 etc and so as long as

902
00:35:28,700 --> 00:35:31,939
users

903
00:35:29,420 --> 00:35:33,890
occasionally send queries where q was

904
00:35:31,940 --> 00:35:35,450
set to one with some you know

905
00:35:33,890 --> 00:35:38,839
unpredictably with some non-negligible

906
00:35:35,450 --> 00:35:40,640
probability the server's can do this

907
00:35:38,839 --> 00:35:42,440
cost-benefit calculation and say is it

908
00:35:40,640 --> 00:35:44,390
worth my effort to try to mess up this

909
00:35:42,440 --> 00:35:46,400
query or should I just answer honestly

910
00:35:44,390 --> 00:35:47,930
if I want to keep getting paid because

911
00:35:46,400 --> 00:35:49,910
they know if they ever get caught they

912
00:35:47,930 --> 00:35:51,589
stop getting paid forever and then you

913
00:35:49,910 --> 00:35:53,960
can make a rationality argument and show

914
00:35:51,589 --> 00:35:55,940
in practice we can set V to zero almost

915
00:35:53,960 --> 00:35:59,180
always and then with some probability

916
00:35:55,940 --> 00:36:01,069
you set V to be as high as it can go and

917
00:35:59,180 --> 00:36:02,839
you send a query and you catch any bad

918
00:36:01,069 --> 00:36:08,058
guys and that prevents the bad guys from

919
00:36:02,839 --> 00:36:10,819
even trying to mess up queries so

920
00:36:08,059 --> 00:36:12,650
there's a lot of more things that you

921
00:36:10,819 --> 00:36:13,880
can do with these techniques one thing

922
00:36:12,650 --> 00:36:19,160
that I've actually been looking at

923
00:36:13,880 --> 00:36:20,630
recently with this approach is so we

924
00:36:19,160 --> 00:36:23,390
want to fetch several records from a

925
00:36:20,630 --> 00:36:25,369
database what if we don't know a priori

926
00:36:23,390 --> 00:36:26,960
which records we want but we want to

927
00:36:25,369 --> 00:36:28,849
leverage this fact that we can actually

928
00:36:26,960 --> 00:36:32,150
fetch queue of them at a time for a

929
00:36:28,849 --> 00:36:33,799
lower cost than fetching just one so

930
00:36:32,150 --> 00:36:35,690
there are existing approaches which lets

931
00:36:33,799 --> 00:36:36,950
you query indexes in a database and

932
00:36:35,690 --> 00:36:38,900
figure out what you're looking for say

933
00:36:36,950 --> 00:36:42,078
to search by keyword or to do SQL

934
00:36:38,900 --> 00:36:45,619
queries we can actually combine this

935
00:36:42,079 --> 00:36:47,180
idea of encoding the databases together

936
00:36:45,619 --> 00:36:49,099
like shrinking the databases as

937
00:36:47,180 --> 00:36:50,868
polynomials and doing batch queries at

938
00:36:49,099 --> 00:36:52,430
the homomorphic properties the additive

939
00:36:50,869 --> 00:36:54,619
properties and multiplicative properties

940
00:36:52,430 --> 00:36:56,990
of the polynomials in order to issue

941
00:36:54,619 --> 00:36:59,569
queries that go against the database and

942
00:36:56,990 --> 00:37:02,209
the result of the query is a new batch

943
00:36:59,569 --> 00:37:05,058
query a new query for different queue

944
00:37:02,210 --> 00:37:06,349
elements that are customized towards

945
00:37:05,059 --> 00:37:08,780
what the user is looking for so you can

946
00:37:06,349 --> 00:37:10,970
have index databases that consists of

947
00:37:08,780 --> 00:37:12,740
queries you send a query against the

948
00:37:10,970 --> 00:37:15,319
index database and it creates a new

949
00:37:12,740 --> 00:37:17,328
query by combining things it's rows and

950
00:37:15,319 --> 00:37:18,859
then issues that against a new database

951
00:37:17,329 --> 00:37:20,960
and sends the result back to you and you

952
00:37:18,859 --> 00:37:22,098
can actually issue very interesting

953
00:37:20,960 --> 00:37:23,450
types of queries I wish I would have

954
00:37:22,099 --> 00:37:24,829
made a slide for that because it's

955
00:37:23,450 --> 00:37:27,230
actually I just didn't think I'd have

956
00:37:24,829 --> 00:37:28,640
time for this so you can do some really

957
00:37:27,230 --> 00:37:31,400
interesting things so I've been looking

958
00:37:28,640 --> 00:37:35,270
at places where this would be a useful

959
00:37:31,400 --> 00:37:37,880
thing to be able to do one application

960
00:37:35,270 --> 00:37:39,710
that came to mind immediately is

961
00:37:37,880 --> 00:37:41,990
something like Twitter so if you're

962
00:37:39,710 --> 00:37:42,720
querying the Twitter database using PIR

963
00:37:41,990 --> 00:37:45,540
its gonna be

964
00:37:42,720 --> 00:37:47,819
slow cuz a Twitter database is huge not

965
00:37:45,540 --> 00:37:51,119
only that but what are you querying for

966
00:37:47,820 --> 00:37:53,490
say I'm following anacott or Chris on

967
00:37:51,119 --> 00:37:55,320
Twitter and I want anak it's most recent

968
00:37:53,490 --> 00:37:59,700
tweets or Chris's most recent tweets

969
00:37:55,320 --> 00:38:01,770
which row do I ask for if I know which

970
00:37:59,700 --> 00:38:05,399
row to ask for I've already seen the

971
00:38:01,770 --> 00:38:07,440
tweet so I have this problem of I need

972
00:38:05,400 --> 00:38:09,090
to know which row to ask for and there's

973
00:38:07,440 --> 00:38:10,500
a ton of rows because each row is a

974
00:38:09,090 --> 00:38:13,050
different tweet and there's the ton of

975
00:38:10,500 --> 00:38:14,880
rows but there's not that many users I

976
00:38:13,050 --> 00:38:16,260
mean there are a lot of users but

977
00:38:14,880 --> 00:38:19,230
compared to the number of tweets there's

978
00:38:16,260 --> 00:38:21,240
a very small number of users so we can

979
00:38:19,230 --> 00:38:23,910
use this index idea to say rather than

980
00:38:21,240 --> 00:38:26,540
querying for the row containing anak

981
00:38:23,910 --> 00:38:30,390
it's most recent tweet I can say I want

982
00:38:26,540 --> 00:38:31,859
the row in the index that lists anak

983
00:38:30,390 --> 00:38:34,529
it's most recent tweets and now I can

984
00:38:31,859 --> 00:38:37,109
say I want the 10 most recent tweets and

985
00:38:34,530 --> 00:38:38,760
my query is for anacott not for his most

986
00:38:37,109 --> 00:38:41,430
recent tweets and that index database

987
00:38:38,760 --> 00:38:43,410
will translate this into a query for

988
00:38:41,430 --> 00:38:45,140
anacott Sten most recent tweets wherever

989
00:38:43,410 --> 00:38:46,950
they happen to reside in the database

990
00:38:45,140 --> 00:38:48,450
process that query against the database

991
00:38:46,950 --> 00:38:50,339
send the result back to me so now I

992
00:38:48,450 --> 00:38:53,759
don't need to know where records reside

993
00:38:50,339 --> 00:38:56,369
in the database I can just say I want to

994
00:38:53,760 --> 00:38:58,080
query the most recent tweets index and I

995
00:38:56,369 --> 00:38:59,700
need to know where anak 'it's wrote

996
00:38:58,080 --> 00:39:02,069
which is a static thing in that database

997
00:38:59,700 --> 00:39:04,109
resides and it'll always give me Anika's

998
00:39:02,070 --> 00:39:06,450
10 most recent tweets or Chris's 10 most

999
00:39:04,109 --> 00:39:10,290
recent tweets or anybody else's there

1000
00:39:06,450 --> 00:39:11,640
could be other data other indexes into

1001
00:39:10,290 --> 00:39:13,259
the database that lets you query it

1002
00:39:11,640 --> 00:39:15,950
using different views so you could for

1003
00:39:13,260 --> 00:39:20,190
example ask for the most retweeted

1004
00:39:15,950 --> 00:39:21,629
queries by anacott or I'm not a big

1005
00:39:20,190 --> 00:39:22,830
Twitter user so I don't know other ways

1006
00:39:21,630 --> 00:39:24,420
that you might want to look for tweets

1007
00:39:22,830 --> 00:39:26,130
but any anything that you can come up

1008
00:39:24,420 --> 00:39:27,690
with you could conceivably build a

1009
00:39:26,130 --> 00:39:31,080
different index floor and so by querying

1010
00:39:27,690 --> 00:39:32,849
the index you're leaking what you're

1011
00:39:31,080 --> 00:39:35,700
looking for whether it's most recent or

1012
00:39:32,849 --> 00:39:37,530
most influential or trending or whatever

1013
00:39:35,700 --> 00:39:39,169
but you're not leaking whose tweets

1014
00:39:37,530 --> 00:39:41,670
you're actually looking for and you're

1015
00:39:39,170 --> 00:39:43,260
eliminating your decoupling the location

1016
00:39:41,670 --> 00:39:44,820
in the database from how the query is

1017
00:39:43,260 --> 00:39:46,470
formed so now the user can issue these

1018
00:39:44,820 --> 00:39:48,450
queries without actually having to know

1019
00:39:46,470 --> 00:39:49,680
the whole structure of the database and

1020
00:39:48,450 --> 00:39:52,439
in a Twitter example this is

1021
00:39:49,680 --> 00:39:54,060
particularly important because Twitter

1022
00:39:52,440 --> 00:39:55,290
will allow you to query their database

1023
00:39:54,060 --> 00:39:56,160
but they actually go out of their way to

1024
00:39:55,290 --> 00:39:58,950
make sure that

1025
00:39:56,160 --> 00:40:00,569
you cannot scrape the entire database

1026
00:39:58,950 --> 00:40:02,669
they don't want you to know the entire

1027
00:40:00,569 --> 00:40:03,869
structure of their entire database they

1028
00:40:02,670 --> 00:40:05,309
just want you to be able access it

1029
00:40:03,869 --> 00:40:07,829
through their API and this actually lets

1030
00:40:05,309 --> 00:40:10,020
you do that whereas traditional PIR

1031
00:40:07,829 --> 00:40:10,829
techniques wouldn't actually even make

1032
00:40:10,020 --> 00:40:13,680
that possible

1033
00:40:10,829 --> 00:40:19,530
so there's lots of applications beyond

1034
00:40:13,680 --> 00:40:21,839
just making things faster yeah so I

1035
00:40:19,530 --> 00:40:25,109
guess into 10k is the most prominent

1036
00:40:21,839 --> 00:40:26,549
will be hashtags when it when

1037
00:40:25,109 --> 00:40:27,420
interesting keyword thing can be

1038
00:40:26,549 --> 00:40:30,660
hashtags

1039
00:40:27,420 --> 00:40:32,460
well now coming to here the batching

1040
00:40:30,660 --> 00:40:35,038
that you're performing is fraud the

1041
00:40:32,460 --> 00:40:37,740
queries from a single user yes can

1042
00:40:35,039 --> 00:40:39,000
something happens when you when they

1043
00:40:37,740 --> 00:40:42,149
have several users were making

1044
00:40:39,000 --> 00:40:45,000
simultaneous queries and maybe you can

1045
00:40:42,150 --> 00:40:47,099
use some of the batching there yeah that

1046
00:40:45,000 --> 00:40:49,680
is a much more difficult problem there

1047
00:40:47,099 --> 00:40:52,380
is stuff you can do so actually going

1048
00:40:49,680 --> 00:40:54,118
back to I said can we do better than

1049
00:40:52,380 --> 00:40:56,460
this just using fast matrix

1050
00:40:54,119 --> 00:41:00,660
multiplication there's actually a recent

1051
00:40:56,460 --> 00:41:04,140
paper by well by Ian and Casey I don't

1052
00:41:00,660 --> 00:41:07,200
know if you know Casey where it was that

1053
00:41:04,140 --> 00:41:11,308
that basically was based on this

1054
00:41:07,200 --> 00:41:14,939
observation that okay his back further

1055
00:41:11,309 --> 00:41:17,339
than I thought that multiplying this

1056
00:41:14,940 --> 00:41:18,809
matrix by the database is a lot more

1057
00:41:17,339 --> 00:41:21,779
efficient than multiplying each row

1058
00:41:18,809 --> 00:41:24,450
individually and so they updated the per

1059
00:41:21,779 --> 00:41:26,279
C++ as the implementation of this basic

1060
00:41:24,450 --> 00:41:28,710
protocol not the stuff I've been talking

1061
00:41:26,279 --> 00:41:30,839
about today they updated it so that the

1062
00:41:28,710 --> 00:41:32,549
server can accumulate a bunch of queries

1063
00:41:30,839 --> 00:41:33,750
and then do a fast matrix multiplication

1064
00:41:32,549 --> 00:41:36,839
so that gives you a little bit of

1065
00:41:33,750 --> 00:41:39,359
performance gain over processing each

1066
00:41:36,839 --> 00:41:40,920
individually if you want to use the ramp

1067
00:41:39,359 --> 00:41:43,920
scheme based stuff that I was talking

1068
00:41:40,920 --> 00:41:46,859
about today you have to be very careful

1069
00:41:43,920 --> 00:41:49,710
so it is possible to encode the queries

1070
00:41:46,859 --> 00:41:52,440
at sort of random x coordinates within

1071
00:41:49,710 --> 00:41:54,299
your polynomials so that and then reveal

1072
00:41:52,440 --> 00:41:55,980
which x coordinate the queries being

1073
00:41:54,299 --> 00:41:57,569
encoded into the server so that the

1074
00:41:55,980 --> 00:41:58,799
server can collect different queries

1075
00:41:57,569 --> 00:42:03,690
that were encoded at different x

1076
00:41:58,799 --> 00:42:06,720
coordinates and combine them but now you

1077
00:42:03,690 --> 00:42:08,549
have sort of two options from here so

1078
00:42:06,720 --> 00:42:09,660
it's going to combine these two build so

1079
00:42:08,549 --> 00:42:11,069
just using the editor

1080
00:42:09,660 --> 00:42:12,598
Bertie's of the polynomials can combine

1081
00:42:11,069 --> 00:42:14,640
them to build a single query that it

1082
00:42:12,599 --> 00:42:16,559
evaluates against a database now it can

1083
00:42:14,640 --> 00:42:19,140
either send that result back to all the

1084
00:42:16,559 --> 00:42:20,940
users in which case the users can

1085
00:42:19,140 --> 00:42:22,379
interpolate to each of these x

1086
00:42:20,940 --> 00:42:27,089
coordinates and figure out what other

1087
00:42:22,380 --> 00:42:30,119
people were looking for or it can try to

1088
00:42:27,089 --> 00:42:31,799
randomize things for you yeah but you

1089
00:42:30,119 --> 00:42:34,079
that that willing to communicate with

1090
00:42:31,799 --> 00:42:35,130
each other if so if users are willing to

1091
00:42:34,079 --> 00:42:36,839
communicate with each other it's a

1092
00:42:35,130 --> 00:42:38,609
relatively easy problem it's actually

1093
00:42:36,839 --> 00:42:40,319
quite quite easy to combine them they

1094
00:42:38,609 --> 00:42:41,730
can even if they're willing to

1095
00:42:40,319 --> 00:42:42,839
coordinate and they're willing to leak

1096
00:42:41,730 --> 00:42:45,690
to one another what they're searching

1097
00:42:42,839 --> 00:42:46,710
for then they can not interactively send

1098
00:42:45,690 --> 00:42:48,000
those things that they don't even have

1099
00:42:46,710 --> 00:42:50,819
to talk to one another as long as

1100
00:42:48,000 --> 00:42:51,480
they've a priori like agreed on how this

1101
00:42:50,819 --> 00:42:53,369
is gonna work

1102
00:42:51,480 --> 00:42:54,900
and then they learn each other's queries

1103
00:42:53,369 --> 00:42:57,119
if you're trying to hide from each user

1104
00:42:54,900 --> 00:42:58,920
the other users queries then you either

1105
00:42:57,119 --> 00:43:01,410
have to trust the database servers to

1106
00:42:58,920 --> 00:43:02,819
randomize the responses before they send

1107
00:43:01,410 --> 00:43:04,890
them back which the randomization is

1108
00:43:02,819 --> 00:43:06,599
easy but it has to be coordinated

1109
00:43:04,890 --> 00:43:09,808
amongst all servers and you have to

1110
00:43:06,599 --> 00:43:13,890
trust them to do it or the users have to

1111
00:43:09,809 --> 00:43:15,180
somehow construct their queries in such

1112
00:43:13,890 --> 00:43:16,589
a way that they can decode them but

1113
00:43:15,180 --> 00:43:17,970
other users won't know how to decode

1114
00:43:16,589 --> 00:43:22,859
them and the only way you can really do

1115
00:43:17,970 --> 00:43:24,629
that is to issue you know queries and

1116
00:43:22,859 --> 00:43:26,490
previous rounds that give you random

1117
00:43:24,630 --> 00:43:28,140
linear combinations of the database that

1118
00:43:26,490 --> 00:43:31,819
you can use to hide which standard basis

1119
00:43:28,140 --> 00:43:33,720
vector you're sending and you end up in

1120
00:43:31,819 --> 00:43:36,000
do you have to make some wonky

1121
00:43:33,720 --> 00:43:37,618
assumptions oh yeah you can do it but

1122
00:43:36,000 --> 00:43:40,500
the assumptions you have to be very

1123
00:43:37,619 --> 00:43:41,990
careful about yeah it would be

1124
00:43:40,500 --> 00:43:44,670
interesting to see whether there's a

1125
00:43:41,990 --> 00:43:46,649
really good way to do that but I haven't

1126
00:43:44,670 --> 00:43:53,130
put - I've thought about it but not

1127
00:43:46,650 --> 00:43:55,319
in-depth yet well I have a question one

1128
00:43:53,130 --> 00:43:58,289
thing that always has bothered me about

1129
00:43:55,319 --> 00:44:02,460
private information retrieval is the

1130
00:43:58,289 --> 00:44:04,380
name and that is because you know it's

1131
00:44:02,460 --> 00:44:07,349
really as you say you're using the terms

1132
00:44:04,380 --> 00:44:08,970
queries and/or index lookup which is

1133
00:44:07,349 --> 00:44:12,809
really what it is when we think about

1134
00:44:08,970 --> 00:44:16,859
information retrieval it's often best

1135
00:44:12,809 --> 00:44:19,170
match there is no exact answer you're

1136
00:44:16,859 --> 00:44:22,828
looking for something that's that's

1137
00:44:19,170 --> 00:44:23,579
close now you know and I've always

1138
00:44:22,829 --> 00:44:25,109
looked at this

1139
00:44:23,579 --> 00:44:28,739
said you know this just doesn't address

1140
00:44:25,109 --> 00:44:30,390
that problem at all I'm wondering have

1141
00:44:28,739 --> 00:44:33,440
you thought about this because when I

1142
00:44:30,390 --> 00:44:36,839
realize a lot of what you do a lot of

1143
00:44:33,440 --> 00:44:40,589
information retrieval techniques do

1144
00:44:36,839 --> 00:44:42,509
reduce to matrix multiplications have

1145
00:44:40,589 --> 00:44:45,089
you thought much about is there a way to

1146
00:44:42,509 --> 00:44:47,430
get best match retrieval weather than

1147
00:44:45,089 --> 00:44:49,859
exact match retrieval out of these i've

1148
00:44:47,430 --> 00:44:53,609
thought a little bit about that and

1149
00:44:49,859 --> 00:44:55,440
there are some kind of things that you

1150
00:44:53,609 --> 00:44:57,450
can sort of do i I haven't thought a lot

1151
00:44:55,440 --> 00:44:59,309
about it and I'm really not an expert in

1152
00:44:57,450 --> 00:45:02,279
how the best match algorithm stuff work

1153
00:44:59,309 --> 00:45:04,440
in it I agree that there's probably a

1154
00:45:02,279 --> 00:45:06,089
lot of potential for that some of the

1155
00:45:04,440 --> 00:45:08,219
stuff that I've been looking at is like

1156
00:45:06,089 --> 00:45:10,140
the index things that I sort of talked

1157
00:45:08,219 --> 00:45:12,119
about a little bit at the end I've been

1158
00:45:10,140 --> 00:45:13,589
looking at how do you look for things

1159
00:45:12,119 --> 00:45:14,789
where the thing might not be in the

1160
00:45:13,589 --> 00:45:16,109
database or you don't know where it

1161
00:45:14,789 --> 00:45:18,509
resides at the database and you're

1162
00:45:16,109 --> 00:45:20,098
rather trying to issue queries for like

1163
00:45:18,509 --> 00:45:22,049
a contextual query I'm looking for

1164
00:45:20,099 --> 00:45:24,749
something of this sort give me the best

1165
00:45:22,049 --> 00:45:27,959
matches and so if you can predict what

1166
00:45:24,749 --> 00:45:30,180
sorts of questions users might ask it's

1167
00:45:27,959 --> 00:45:31,919
very easy to prepare indexes that will

1168
00:45:30,180 --> 00:45:33,629
answer the queries and give the best

1169
00:45:31,920 --> 00:45:36,749
matches for the query even if no exact

1170
00:45:33,630 --> 00:45:40,650
match misses exist if you want to be

1171
00:45:36,749 --> 00:45:43,379
able to do things like find the closest

1172
00:45:40,650 --> 00:45:44,940
to a particular query what nothing

1173
00:45:43,380 --> 00:45:46,670
exists and you don't want to have to

1174
00:45:44,940 --> 00:45:50,969
anticipate all the possible questions

1175
00:45:46,670 --> 00:45:53,130
you can do this with interaction so if

1176
00:45:50,969 --> 00:45:54,779
there is one query and based on the

1177
00:45:53,130 --> 00:45:56,609
response you issue another query then

1178
00:45:54,779 --> 00:45:58,140
you can build complicated data

1179
00:45:56,609 --> 00:45:59,848
structures you can build any data

1180
00:45:58,140 --> 00:46:01,199
structure really you want and have the

1181
00:45:59,849 --> 00:46:03,569
Pierre query go through the data

1182
00:46:01,199 --> 00:46:05,789
structure and then anything that you can

1183
00:46:03,569 --> 00:46:07,199
solve non privately with that data

1184
00:46:05,789 --> 00:46:08,489
structure you can solve privately so

1185
00:46:07,199 --> 00:46:10,199
this is how the keyword searches and

1186
00:46:08,489 --> 00:46:12,539
stuff typically work you construct a

1187
00:46:10,199 --> 00:46:15,359
b-tree over the database the users query

1188
00:46:12,539 --> 00:46:17,099
the B tree recursively until they found

1189
00:46:15,359 --> 00:46:18,180
the coordinate that they actually want

1190
00:46:17,099 --> 00:46:19,890
and then the issue query for that

1191
00:46:18,180 --> 00:46:23,669
coordinate and so the stuff I've been

1192
00:46:19,890 --> 00:46:25,259
looking at is explicitly non interactive

1193
00:46:23,670 --> 00:46:26,849
you do not have this back and forth you

1194
00:46:25,259 --> 00:46:28,319
send a query the query gets transformed

1195
00:46:26,849 --> 00:46:29,699
into the query you actually want and

1196
00:46:28,319 --> 00:46:33,209
then it gets evaluated and then sent

1197
00:46:29,699 --> 00:46:35,249
back to you but those are really the

1198
00:46:33,209 --> 00:46:37,240
only two things and and people have done

1199
00:46:35,249 --> 00:46:39,310
a related sort of

1200
00:46:37,240 --> 00:46:41,140
the SQL query type thing as well that's

1201
00:46:39,310 --> 00:46:44,290
very similar to the bee tree thing I

1202
00:46:41,140 --> 00:46:45,910
proposed that's basically all that's

1203
00:46:44,290 --> 00:46:53,860
being done at this point

1204
00:46:45,910 --> 00:46:56,890
I guess somewhat sort of related I did

1205
00:46:53,860 --> 00:46:59,380
some work in the past on using PIR to do

1206
00:46:56,890 --> 00:47:02,500
ecommerce and we were looking at so if

1207
00:46:59,380 --> 00:47:05,190
you were to envision a sort of

1208
00:47:02,500 --> 00:47:07,900
competitor to Amazon's Kindle Store

1209
00:47:05,190 --> 00:47:09,220
where everything was purchased using

1210
00:47:07,900 --> 00:47:10,900
private information retrieval so we

1211
00:47:09,220 --> 00:47:13,390
wanted to solve the problem of can you

1212
00:47:10,900 --> 00:47:16,300
sell things where things have different

1213
00:47:13,390 --> 00:47:19,420
prices and knowing how much a person

1214
00:47:16,300 --> 00:47:20,710
paid will reveal a large a lot of

1215
00:47:19,420 --> 00:47:22,030
information about what they would say

1216
00:47:20,710 --> 00:47:24,700
bought so we want to hide the price that

1217
00:47:22,030 --> 00:47:27,550
they paid but make sure they pay the

1218
00:47:24,700 --> 00:47:29,020
correct price and to throw a wrench into

1219
00:47:27,550 --> 00:47:30,730
things let's say there's Amazon Prime

1220
00:47:29,020 --> 00:47:32,200
membership so these people are allowed

1221
00:47:30,730 --> 00:47:34,090
to get some things for free and maybe

1222
00:47:32,200 --> 00:47:36,759
other things are cheaper than for a

1223
00:47:34,090 --> 00:47:37,960
non-member and we want to be able to

1224
00:47:36,760 --> 00:47:40,300
support all of this but have it

1225
00:47:37,960 --> 00:47:41,920
completely oblivious so first off if you

1226
00:47:40,300 --> 00:47:44,520
want to do payments you need to say

1227
00:47:41,920 --> 00:47:46,990
prepay for a credit card they're like a

1228
00:47:44,520 --> 00:47:48,190
debit card type thing that has a balance

1229
00:47:46,990 --> 00:47:50,200
in it and now you just have to prove

1230
00:47:48,190 --> 00:47:51,640
that I have enough money in my thing to

1231
00:47:50,200 --> 00:47:53,890
pay for whatever is I'm getting and I've

1232
00:47:51,640 --> 00:47:55,390
subtracted the appropriate amount and we

1233
00:47:53,890 --> 00:47:58,540
were able to build a nice protocol it

1234
00:47:55,390 --> 00:48:00,279
that lets you do these purchases then we

1235
00:47:58,540 --> 00:48:02,170
started to think okay so is Amazon ever

1236
00:48:00,280 --> 00:48:04,360
going to support something like this

1237
00:48:02,170 --> 00:48:06,910
well no obviously not because Amazon

1238
00:48:04,360 --> 00:48:09,670
wants to know what you purchased they

1239
00:48:06,910 --> 00:48:10,629
don't just want to get the braids amount

1240
00:48:09,670 --> 00:48:12,640
of money they want to be able to do

1241
00:48:10,630 --> 00:48:15,070
analytics they want to know what's

1242
00:48:12,640 --> 00:48:18,310
purchased when and so we were able to

1243
00:48:15,070 --> 00:48:20,410
show how you can build histograms of

1244
00:48:18,310 --> 00:48:22,150
sales and say well this was downloaded X

1245
00:48:20,410 --> 00:48:23,859
number of times this was downloaded Y

1246
00:48:22,150 --> 00:48:26,020
times and this was downloaded Z times

1247
00:48:23,860 --> 00:48:27,730
without revealing who purchased what at

1248
00:48:26,020 --> 00:48:29,020
what time and if you have to pay

1249
00:48:27,730 --> 00:48:31,450
commissions to different people we were

1250
00:48:29,020 --> 00:48:32,980
able to show okay based on how many

1251
00:48:31,450 --> 00:48:34,509
times this was downloaded and whether

1252
00:48:32,980 --> 00:48:36,370
they were Prime members or non Prime

1253
00:48:34,510 --> 00:48:38,470
members and so on how much money is this

1254
00:48:36,370 --> 00:48:41,950
person who owns that the intellectual

1255
00:48:38,470 --> 00:48:43,600
property how much did they get paid and

1256
00:48:41,950 --> 00:48:47,799
we realized that with that same data we

1257
00:48:43,600 --> 00:48:49,540
were able to do things like build sub

1258
00:48:47,800 --> 00:48:50,890
databases that like the sort the

1259
00:48:49,540 --> 00:48:52,599
database according to puffy

1260
00:48:50,890 --> 00:48:55,269
and so on and you could issue a query

1261
00:48:52,599 --> 00:48:57,880
against a the top half of the database

1262
00:48:55,269 --> 00:48:59,019
and so you're revealing explicitly that

1263
00:48:57,880 --> 00:49:01,720
I don't want something from the bottom

1264
00:48:59,019 --> 00:49:03,069
half of the database but the stuff in

1265
00:49:01,720 --> 00:49:05,230
the bottom after the database is known

1266
00:49:03,069 --> 00:49:06,880
to be the stuff that nobody wants and so

1267
00:49:05,230 --> 00:49:08,349
most users want stuff in the top half

1268
00:49:06,880 --> 00:49:10,000
and so by revealing I want something in

1269
00:49:08,349 --> 00:49:11,170
the top half you're revealing I want one

1270
00:49:10,000 --> 00:49:13,510
of the popular things that everybody

1271
00:49:11,170 --> 00:49:15,940
wants and so you're kind of minimizing

1272
00:49:13,510 --> 00:49:17,890
what's leaked to get these savings of

1273
00:49:15,940 --> 00:49:20,500
I'm querying a subset of the database

1274
00:49:17,890 --> 00:49:22,808
and so using that sort of thing you

1275
00:49:20,500 --> 00:49:25,029
could also possibly get some sort of

1276
00:49:22,809 --> 00:49:40,869
useful information retrieval stuff that

1277
00:49:25,029 --> 00:49:42,760
we never thought of that strew I mean we

1278
00:49:40,869 --> 00:49:43,990
that was sort of like a passing comment

1279
00:49:42,760 --> 00:49:46,000
at the end of the paper was lucky you

1280
00:49:43,990 --> 00:49:48,160
could also do this there's some

1281
00:49:46,000 --> 00:49:50,049
intricate privacy ramifications that

1282
00:49:48,160 --> 00:49:51,730
we're not going to explore we're just

1283
00:49:50,049 --> 00:49:54,849
pointing out that this is a possibility

1284
00:49:51,730 --> 00:49:56,710
in it might be so if you're doing the

1285
00:49:54,849 --> 00:49:58,390
half-and-half thing we actually assume

1286
00:49:56,710 --> 00:50:01,390
that it's a preeto distribution and we

1287
00:49:58,390 --> 00:50:04,420
just for sake of arguments at 8020 rule

1288
00:50:01,390 --> 00:50:07,720
80% of users want the top 20% 20% of

1289
00:50:04,420 --> 00:50:10,150
users want the bottom 80% now we thought

1290
00:50:07,720 --> 00:50:11,859
okay well that's you know you're still

1291
00:50:10,150 --> 00:50:14,019
you're leaking relatively small amount

1292
00:50:11,859 --> 00:50:15,308
or you are leaking that the important

1293
00:50:14,019 --> 00:50:17,109
bit of information that you want the

1294
00:50:15,309 --> 00:50:19,180
uncommon stuff but now most of its

1295
00:50:17,109 --> 00:50:22,240
uncommon stuff so narrowing it down to

1296
00:50:19,180 --> 00:50:23,828
which uncommon stuff is still very hard

1297
00:50:22,240 --> 00:50:25,890
I mean it's impossible to actually

1298
00:50:23,829 --> 00:50:30,130
narrow it down further based on the PIR

1299
00:50:25,890 --> 00:50:31,779
but yeah it that's when you start doing

1300
00:50:30,130 --> 00:50:33,519
things like that the privacy guarantees

1301
00:50:31,779 --> 00:50:35,230
go from very clear-cut you reveal

1302
00:50:33,519 --> 00:50:37,899
nothing but you're doing a query to very

1303
00:50:35,230 --> 00:50:41,769
nuanced and intricate and hard to

1304
00:50:37,900 --> 00:50:43,240
actually reason about so I don't know

1305
00:50:41,769 --> 00:50:48,339
whether that answers or evades your

1306
00:50:43,240 --> 00:50:50,019
questions but that's yes I think cash in

1307
00:50:48,339 --> 00:50:52,569
math that you did a little bit before

1308
00:50:50,019 --> 00:50:54,160
this you want to break the rule boy in

1309
00:50:52,569 --> 00:50:58,269
matrix and what they call them is that

1310
00:50:54,160 --> 00:51:00,160
what you had or I just for space i

1311
00:50:58,269 --> 00:51:02,109
transposed to get a column so you

1312
00:51:00,160 --> 00:51:03,848
multiply a row by it and you get a row

1313
00:51:02,109 --> 00:51:04,090
but I transposed it so it would fit on

1314
00:51:03,849 --> 00:51:08,590
this

1315
00:51:04,090 --> 00:51:19,750
slide nice okay so it's your I think

1316
00:51:08,590 --> 00:51:21,490
you're referring to right here yes yeah

1317
00:51:19,750 --> 00:51:23,350
so you're taking a row matrix that has

1318
00:51:21,490 --> 00:51:25,479
the same length as the height of the

1319
00:51:23,350 --> 00:51:26,950
database you multiply by a database you

1320
00:51:25,480 --> 00:51:28,810
get a row matrix but I wrote the

1321
00:51:26,950 --> 00:51:34,689
transpose just because otherwise it

1322
00:51:28,810 --> 00:51:42,490
wouldn't have fit Thanks any other

1323
00:51:34,690 --> 00:51:44,590
questions so one question typically as

1324
00:51:42,490 --> 00:51:46,419
many of the practical studies started to

1325
00:51:44,590 --> 00:51:48,700
make it appear they found that the key

1326
00:51:46,420 --> 00:51:50,650
problem is not the communication but

1327
00:51:48,700 --> 00:51:53,049
rather computation which is basically

1328
00:51:50,650 --> 00:51:56,590
you have to touch each of the element

1329
00:51:53,050 --> 00:51:58,300
yes in your thing so can something

1330
00:51:56,590 --> 00:51:59,620
happen there I mean even now when you

1331
00:51:58,300 --> 00:52:01,840
are reducing the effort you're reducing

1332
00:51:59,620 --> 00:52:05,620
there forever factor you but if you

1333
00:52:01,840 --> 00:52:07,870
count all the server's it still our RS

1334
00:52:05,620 --> 00:52:11,350
divided by U and actually multiply with

1335
00:52:07,870 --> 00:52:16,000
the know L so in that sense it's maybe

1336
00:52:11,350 --> 00:52:18,370
more than RS it is more than Rs yeah

1337
00:52:16,000 --> 00:52:22,020
it's silly I mean it has to be more than

1338
00:52:18,370 --> 00:52:22,020
RS because L has to be bigger than you

1339
00:52:22,740 --> 00:52:27,700
it seems like this computation I mean

1340
00:52:26,260 --> 00:52:30,490
there are interesting studies and when

1341
00:52:27,700 --> 00:52:33,310
you have a really fast network maybe

1342
00:52:30,490 --> 00:52:35,319
that's where the TV LP are look started

1343
00:52:33,310 --> 00:52:39,160
to better because these computations are

1344
00:52:35,320 --> 00:52:41,740
huge so now it's up there the saving

1345
00:52:39,160 --> 00:52:44,500
grace is that this is they were already

1346
00:52:41,740 --> 00:52:46,569
inherently distributing that computation

1347
00:52:44,500 --> 00:52:49,180
over several nodes and the computation

1348
00:52:46,570 --> 00:52:51,550
at each node has to do is embarrassingly

1349
00:52:49,180 --> 00:52:55,149
is embarrassingly parallel Liza below

1350
00:52:51,550 --> 00:52:56,830
you can parallelize it basically in not

1351
00:52:55,150 --> 00:52:58,870
infinitely but I guess you can paralyze

1352
00:52:56,830 --> 00:53:00,640
it until each node or each core does

1353
00:52:58,870 --> 00:53:02,319
like one multiplication and there's no

1354
00:53:00,640 --> 00:53:03,970
synchronization issues you just multiply

1355
00:53:02,320 --> 00:53:06,070
one thing and then you add the things

1356
00:53:03,970 --> 00:53:08,169
and there you don't have to synchronize

1357
00:53:06,070 --> 00:53:09,820
you just have to click the results and

1358
00:53:08,170 --> 00:53:12,340
add them together so that the

1359
00:53:09,820 --> 00:53:14,410
parallelization is very easy but you're

1360
00:53:12,340 --> 00:53:16,240
absolutely right that it's still at the

1361
00:53:14,410 --> 00:53:17,890
end of the day a lot of computation it

1362
00:53:16,240 --> 00:53:19,689
has to happen so that's part of

1363
00:53:17,890 --> 00:53:23,470
reason why it's interesting to be able

1364
00:53:19,690 --> 00:53:26,650
to shrink it by a factor you I we have

1365
00:53:23,470 --> 00:53:28,720
been looking just in the past couple

1366
00:53:26,650 --> 00:53:30,850
weeks my student and I started looking

1367
00:53:28,720 --> 00:53:32,109
at what happens when you so there was a

1368
00:53:30,850 --> 00:53:36,270
little bit of background there was a

1369
00:53:32,110 --> 00:53:39,280
paper in 2014 that showed that under

1370
00:53:36,270 --> 00:53:41,860
ridiculous trade-offs but still very

1371
00:53:39,280 --> 00:53:43,300
interesting you can do PIR where at the

1372
00:53:41,860 --> 00:53:45,400
end of the day you download one extra

1373
00:53:43,300 --> 00:53:48,460
bit of data compared to an on private

1374
00:53:45,400 --> 00:53:49,840
query only one bit exactly one bit and

1375
00:53:48,460 --> 00:53:51,820
it was like a tight you get this one

1376
00:53:49,840 --> 00:53:53,680
extra bit you have to have exponentially

1377
00:53:51,820 --> 00:53:55,240
many servers and you have to upload

1378
00:53:53,680 --> 00:53:56,890
something the size of the database to

1379
00:53:55,240 --> 00:53:59,169
each server and there's like it's just a

1380
00:53:56,890 --> 00:54:01,870
crazy all the other parameters are crazy

1381
00:53:59,170 --> 00:54:06,010
but you can download only one bit extra

1382
00:54:01,870 --> 00:54:07,569
and so we thought okay then then then

1383
00:54:06,010 --> 00:54:08,860
they had this impossibility result say

1384
00:54:07,570 --> 00:54:10,090
if you only want to download one extra

1385
00:54:08,860 --> 00:54:11,860
bit you can't do much better than we

1386
00:54:10,090 --> 00:54:13,900
just did but if you are willing to

1387
00:54:11,860 --> 00:54:16,480
download C a factor two or a factor four

1388
00:54:13,900 --> 00:54:18,490
more bits then you can do you can reduce

1389
00:54:16,480 --> 00:54:20,680
all of these parameters quite a bit and

1390
00:54:18,490 --> 00:54:22,839
so we thought what if we use the U and Q

1391
00:54:20,680 --> 00:54:25,330
here to recreate this so we take our

1392
00:54:22,840 --> 00:54:27,160
rows that are each this long and we chop

1393
00:54:25,330 --> 00:54:29,290
them down into like really short rows

1394
00:54:27,160 --> 00:54:31,060
and split them over a whole bunch of

1395
00:54:29,290 --> 00:54:33,940
rows and then we use the U to shrink

1396
00:54:31,060 --> 00:54:35,590
that database down and we say rather

1397
00:54:33,940 --> 00:54:37,270
than trying to fit this all into the L

1398
00:54:35,590 --> 00:54:38,710
servers we already have we just say well

1399
00:54:37,270 --> 00:54:40,150
let these more servers now write these

1400
00:54:38,710 --> 00:54:41,470
other proteins other protocols are

1401
00:54:40,150 --> 00:54:43,030
saying the number of servers has to be

1402
00:54:41,470 --> 00:54:44,500
linear in the size of the data so what

1403
00:54:43,030 --> 00:54:45,730
if we say something similar and we say

1404
00:54:44,500 --> 00:54:47,800
we're gonna make these parameters really

1405
00:54:45,730 --> 00:54:49,330
big and we're gonna just add more

1406
00:54:47,800 --> 00:54:51,510
servers so we could still answer a query

1407
00:54:49,330 --> 00:54:54,069
and you get some really interesting

1408
00:54:51,510 --> 00:54:56,170
asymptotic so if one thing we can do PIR

1409
00:54:54,070 --> 00:54:58,750
where you download exactly twice the

1410
00:54:56,170 --> 00:55:00,910
size of a record and unlike the other

1411
00:54:58,750 --> 00:55:02,350
protocols where no two servers conclude

1412
00:55:00,910 --> 00:55:03,910
and nobody can know which subset of

1413
00:55:02,350 --> 00:55:06,630
servers you queried here you have like

1414
00:55:03,910 --> 00:55:09,790
an honest majority assumption instead

1415
00:55:06,630 --> 00:55:12,540
did the cost per node becomes like

1416
00:55:09,790 --> 00:55:16,150
logarithmic multiplications instead of

1417
00:55:12,540 --> 00:55:18,610
linear but if you add up all what every

1418
00:55:16,150 --> 00:55:22,540
node is doing it's still what more than

1419
00:55:18,610 --> 00:55:25,600
our times s and that just seems to be

1420
00:55:22,540 --> 00:55:27,430
inherent unless you change the threat

1421
00:55:25,600 --> 00:55:29,799
model like if you change the goal of the

1422
00:55:27,430 --> 00:55:31,259
PIR to get there's basically there's an

1423
00:55:29,800 --> 00:55:32,340
impossibility results are coming up

1424
00:55:31,260 --> 00:55:33,840
against then unless you change the

1425
00:55:32,340 --> 00:55:36,380
definitions you really can't get around

1426
00:55:33,840 --> 00:55:36,380
that result

