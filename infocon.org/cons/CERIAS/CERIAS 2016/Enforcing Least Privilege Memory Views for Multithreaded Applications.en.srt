1
00:00:08,090 --> 00:00:13,320
hello everyone I'm Terry shoe I'm from

2
00:00:11,100 --> 00:00:15,838
Purdue University at Cabrillo science

3
00:00:13,320 --> 00:00:18,660
department I'm a fifth year PhD student

4
00:00:15,839 --> 00:00:23,279
working with my advisor Patrick stirrer

5
00:00:18,660 --> 00:00:24,869
and Matias payer so thank you for coming

6
00:00:23,279 --> 00:00:26,970
I'm presenting a joint work with my

7
00:00:24,869 --> 00:00:30,779
co-author Kevin Huffman was a previous

8
00:00:26,970 --> 00:00:33,180
PhD student graduated a couple of years

9
00:00:30,779 --> 00:00:35,670
ago my advisor Pat research and

10
00:00:33,180 --> 00:00:39,170
participate here this work is about

11
00:00:35,670 --> 00:00:42,059
streaks thread isolation for C or C++

12
00:00:39,170 --> 00:00:45,899
modifier applications we publish this

13
00:00:42,059 --> 00:00:47,640
work at this year's CCS in Vienna and

14
00:00:45,899 --> 00:00:51,570
you're welcome to check out the paper

15
00:00:47,640 --> 00:00:53,670
and white so let's get started so one of

16
00:00:51,570 --> 00:00:56,489
the problems of today's software so

17
00:00:53,670 --> 00:00:58,230
today today's software have numerous

18
00:00:56,489 --> 00:01:00,750
components running within the same

19
00:00:58,230 --> 00:01:02,809
process address space what makes this

20
00:01:00,750 --> 00:01:05,759
situation a security nightmare is that

21
00:01:02,809 --> 00:01:07,229
some of these software components they

22
00:01:05,759 --> 00:01:10,590
could be developed by various third

23
00:01:07,229 --> 00:01:13,740
parties so if a targeted application is

24
00:01:10,590 --> 00:01:16,020
a modified application then all of these

25
00:01:13,740 --> 00:01:18,208
software components are unconditionally

26
00:01:16,020 --> 00:01:21,000
trusted even if they shouldn't be so

27
00:01:18,209 --> 00:01:24,240
that's the problem here to provide

28
00:01:21,000 --> 00:01:26,550
isolation for software components one

29
00:01:24,240 --> 00:01:29,899
could use process to isolate program

30
00:01:26,550 --> 00:01:33,229
data but that requires the programmer to

31
00:01:29,899 --> 00:01:36,090
completely redesign the legacy software

32
00:01:33,229 --> 00:01:39,179
another popular solution is based on

33
00:01:36,090 --> 00:01:42,599
software fault isolation which could

34
00:01:39,179 --> 00:01:45,330
cause various delays due to the software

35
00:01:42,599 --> 00:01:49,590
monitor it's depending on the

36
00:01:45,330 --> 00:01:51,239
implementation techniques so here we use

37
00:01:49,590 --> 00:01:53,190
a really simple example to illustrate

38
00:01:51,239 --> 00:01:54,530
the isolation problem in a single

39
00:01:53,190 --> 00:01:57,569
process address space

40
00:01:54,530 --> 00:02:00,810
imagine a screen box to be the address

41
00:01:57,569 --> 00:02:03,479
space of a program in this example the

42
00:02:00,810 --> 00:02:06,539
program stores its own secret and they

43
00:02:03,479 --> 00:02:09,478
shouldn't be accessible by other

44
00:02:06,539 --> 00:02:13,099
irrelevant software components but as

45
00:02:09,479 --> 00:02:17,430
you all know software called modules

46
00:02:13,099 --> 00:02:19,019
plug-ins for web browsers to even access

47
00:02:17,430 --> 00:02:20,760
the physical devices on your assistance

48
00:02:19,020 --> 00:02:24,390
and various library

49
00:02:20,760 --> 00:02:26,489
and even microservices so as the program

50
00:02:24,390 --> 00:02:28,589
has more and more components to same

51
00:02:26,489 --> 00:02:30,720
process address space increases the

52
00:02:28,590 --> 00:02:33,480
chance of being compromised so it's a

53
00:02:30,720 --> 00:02:35,730
problem it takes only one component

54
00:02:33,480 --> 00:02:38,819
component to be compromised to exploit

55
00:02:35,730 --> 00:02:41,040
the entire program this problem is due

56
00:02:38,819 --> 00:02:43,440
to the intrinsically sheared single

57
00:02:41,040 --> 00:02:47,280
processes in space and the lack of inter

58
00:02:43,440 --> 00:02:48,750
process isolation so one could use

59
00:02:47,280 --> 00:02:52,319
process to isolate the software

60
00:02:48,750 --> 00:02:54,180
components a process isolation has its

61
00:02:52,319 --> 00:02:57,238
own drawbacks for example non-trivial

62
00:02:54,180 --> 00:02:59,549
IPC increases the code complexity and

63
00:02:57,239 --> 00:03:03,060
sometimes even the performance overhead

64
00:02:59,549 --> 00:03:05,129
is observable also there's a lot a lot

65
00:03:03,060 --> 00:03:08,250
of resource duplication at system level

66
00:03:05,129 --> 00:03:10,980
and curls process synchronization can

67
00:03:08,250 --> 00:03:13,200
also be an headache for programmer and

68
00:03:10,980 --> 00:03:15,179
most importantly it is extremely

69
00:03:13,200 --> 00:03:18,679
difficult to overhaul programs with

70
00:03:15,180 --> 00:03:21,409
large code base to use process isolation

71
00:03:18,680 --> 00:03:23,730
but if we could safely bring all this

72
00:03:21,409 --> 00:03:25,948
process that process every space

73
00:03:23,730 --> 00:03:28,679
together and therefore remove the

74
00:03:25,949 --> 00:03:31,079
expensive IPC programmers will be able

75
00:03:28,680 --> 00:03:33,329
to selectively isolate a process memory

76
00:03:31,079 --> 00:03:37,680
and have an efficient and secure

77
00:03:33,329 --> 00:03:40,230
partially shared memory pool so the

78
00:03:37,680 --> 00:03:42,030
ability to selectively isolate the

79
00:03:40,230 --> 00:03:45,929
process memory allows the program to

80
00:03:42,030 --> 00:03:47,849
eliminate IPC and to share as many

81
00:03:45,930 --> 00:03:50,220
resources as possible at the system

82
00:03:47,849 --> 00:03:52,518
level and the program could assume

83
00:03:50,220 --> 00:03:55,349
thread synchronization still works and

84
00:03:52,519 --> 00:03:58,139
because of the shared memory assumption

85
00:03:55,349 --> 00:04:01,099
the code changes could be minimum in

86
00:03:58,139 --> 00:04:05,099
terms of memory access and data sharing

87
00:04:01,099 --> 00:04:07,440
so efficient and secure intra process

88
00:04:05,099 --> 00:04:09,988
isolation is the motivation of our work

89
00:04:07,440 --> 00:04:11,669
here our goal is to provide the

90
00:04:09,989 --> 00:04:13,590
programmer with the programming

91
00:04:11,669 --> 00:04:16,970
abstraction to selectively isolate

92
00:04:13,590 --> 00:04:19,560
process memory with several properties

93
00:04:16,970 --> 00:04:21,539
we believe that I ignore it for security

94
00:04:19,560 --> 00:04:24,930
tools to to be widely and quickly

95
00:04:21,539 --> 00:04:26,820
adapted a tool needs to be flexible so

96
00:04:24,930 --> 00:04:29,460
that no matter the client or the server

97
00:04:26,820 --> 00:04:30,630
side applications think can take

98
00:04:29,460 --> 00:04:34,109
advantage of it

99
00:04:30,630 --> 00:04:34,740
second we think that I think that new

100
00:04:34,110 --> 00:04:37,110
tools should

101
00:04:34,740 --> 00:04:38,930
extremely easy to use without the need

102
00:04:37,110 --> 00:04:42,750
for programmer to overhaul an entire

103
00:04:38,930 --> 00:04:45,390
legacy software also a tool that does

104
00:04:42,750 --> 00:04:47,580
not require modifications or a specific

105
00:04:45,390 --> 00:04:49,550
hardware means that it is ready to be

106
00:04:47,580 --> 00:04:53,099
deployed on today's commodity system

107
00:04:49,550 --> 00:04:55,800
last but not least a tour children

108
00:04:53,100 --> 00:04:58,560
sacrifice parallelism when providing

109
00:04:55,800 --> 00:04:59,790
security and it should guarantee the

110
00:04:58,560 --> 00:05:05,310
security of the software we saw

111
00:04:59,790 --> 00:05:07,830
civilizing execution so to address this

112
00:05:05,310 --> 00:05:10,440
design challenges we propose secure

113
00:05:07,830 --> 00:05:13,080
memory views we call the smbs it allows

114
00:05:10,440 --> 00:05:14,940
the programmer to selectively isolate a

115
00:05:13,080 --> 00:05:17,669
process address space based on user

116
00:05:14,940 --> 00:05:20,160
defined policy so we define three

117
00:05:17,670 --> 00:05:21,810
abstractions to manage process memory to

118
00:05:20,160 --> 00:05:25,590
achieve inter process isolation

119
00:05:21,810 --> 00:05:28,230
first we define a memory production

120
00:05:25,590 --> 00:05:32,250
domain to be an contiguous range of

121
00:05:28,230 --> 00:05:33,750
virtual memory address second we define

122
00:05:32,250 --> 00:05:36,480
a secure memory view as a thread

123
00:05:33,750 --> 00:05:39,630
container with a collection of memory

124
00:05:36,480 --> 00:05:44,210
protection domain so an smv defines

125
00:05:39,630 --> 00:05:48,600
whether thread who read/write/execute

126
00:05:44,210 --> 00:05:50,729
llk free data in the memory domain so

127
00:05:48,600 --> 00:05:53,430
finally we create a special thread

128
00:05:50,730 --> 00:05:58,290
called SMB thread that strictly follows

129
00:05:53,430 --> 00:06:00,870
the privileged defined by snv's so

130
00:05:58,290 --> 00:06:03,330
here's an high-level overview of what

131
00:06:00,870 --> 00:06:05,340
SMEs look like there are five memory

132
00:06:03,330 --> 00:06:09,990
domains in this example and for SMB

133
00:06:05,340 --> 00:06:11,880
threads and thread t4 is using two

134
00:06:09,990 --> 00:06:12,210
memory domains as you can see in this

135
00:06:11,880 --> 00:06:16,290
figure

136
00:06:12,210 --> 00:06:18,810
so suppose domain lll is compromised by

137
00:06:16,290 --> 00:06:22,380
your attacker so it's working red and

138
00:06:18,810 --> 00:06:24,060
this is what the memory domains look

139
00:06:22,380 --> 00:06:29,040
like in the program's virtual address

140
00:06:24,060 --> 00:06:33,000
space so the compromised t thread the

141
00:06:29,040 --> 00:06:35,160
compromised 33 is isolate by smb3 that

142
00:06:33,000 --> 00:06:38,850
can only access the memory pages in the

143
00:06:35,160 --> 00:06:41,880
memory domain l so it is not possible

144
00:06:38,850 --> 00:06:43,830
for t3 to access memory pages in memory

145
00:06:41,880 --> 00:06:45,630
domain s that stores the program secret

146
00:06:43,830 --> 00:06:47,520
even even though they are just rest

147
00:06:45,630 --> 00:06:49,730
living within the same process error

148
00:06:47,520 --> 00:06:53,940
space

149
00:06:49,730 --> 00:06:55,620
okay so SMB is really easy to use the

150
00:06:53,940 --> 00:06:57,780
programmer just need to link to SME

151
00:06:55,620 --> 00:07:00,900
library when compiling source go and

152
00:06:57,780 --> 00:07:02,369
include a header file so just to give a

153
00:07:00,900 --> 00:07:05,450
really simple example of how to use

154
00:07:02,370 --> 00:07:08,490
snv's with some of the basic API cost

155
00:07:05,450 --> 00:07:10,700
first we can create a memory domain and

156
00:07:08,490 --> 00:07:14,640
store the program secret in that domain

157
00:07:10,700 --> 00:07:16,710
then we create an SMB contender and we

158
00:07:14,640 --> 00:07:18,479
make the SME join the memory domain so

159
00:07:16,710 --> 00:07:21,239
there's a there's a mapping recording in

160
00:07:18,480 --> 00:07:22,830
the system in order to access data in

161
00:07:21,240 --> 00:07:24,230
the memory domain we need to grant

162
00:07:22,830 --> 00:07:26,640
permission to the smv

163
00:07:24,230 --> 00:07:29,070
so you can see there's a dash liner and

164
00:07:26,640 --> 00:07:31,830
also the privilege record at the bottom

165
00:07:29,070 --> 00:07:33,630
of SME so here we allow SME want to read

166
00:07:31,830 --> 00:07:34,140
data in the memory domain one but

167
00:07:33,630 --> 00:07:37,710
nothing else

168
00:07:34,140 --> 00:07:41,669
and finally we create an SME thread that

169
00:07:37,710 --> 00:07:44,549
is totally isolated by smb1 okay so

170
00:07:41,670 --> 00:07:47,310
after the SME thread finished its job

171
00:07:44,550 --> 00:07:50,040
then we join the thread so the threat

172
00:07:47,310 --> 00:07:52,920
leaves the system and make the SM SM

173
00:07:50,040 --> 00:07:55,500
believe the system and we kill this MV

174
00:07:52,920 --> 00:07:58,260
and then killed a memory domain fronting

175
00:07:55,500 --> 00:08:01,310
system so this privilege setup might be

176
00:07:58,260 --> 00:08:04,950
a little inconvenient in terms of

177
00:08:01,310 --> 00:08:07,350
refactoring a legacy software so we

178
00:08:04,950 --> 00:08:08,940
provide you an easier way to for the

179
00:08:07,350 --> 00:08:11,580
programmer to minimize the code

180
00:08:08,940 --> 00:08:13,710
refactoring effort so the SMB api could

181
00:08:11,580 --> 00:08:16,020
automatically intercept Milwaukee and

182
00:08:13,710 --> 00:08:19,130
pthread create costs and replace them

183
00:08:16,020 --> 00:08:21,780
with set of SMB related functions

184
00:08:19,130 --> 00:08:24,560
therefore the the programmer only needs

185
00:08:21,780 --> 00:08:27,179
to add two lines of code to the program

186
00:08:24,560 --> 00:08:29,130
one for the header and another lines of

187
00:08:27,180 --> 00:08:32,520
another line of code for initializing

188
00:08:29,130 --> 00:08:37,070
the main program in the in this library

189
00:08:32,520 --> 00:08:39,689
assisted setup hp3 is automatically

190
00:08:37,070 --> 00:08:43,140
intercepted and replaced by an SF III

191
00:08:39,690 --> 00:08:45,230
and will receive a private domain for

192
00:08:43,140 --> 00:08:48,240
its stack initially

193
00:08:45,230 --> 00:08:49,560
solar programmer to assume that threads

194
00:08:48,240 --> 00:08:51,240
are isolated from each other

195
00:08:49,560 --> 00:08:54,000
in addition thread local memory

196
00:08:51,240 --> 00:08:57,240
allocation happens automatically in

197
00:08:54,000 --> 00:09:00,210
depth as probably private domain that is

198
00:08:57,240 --> 00:09:02,020
not accessible by all other threads so

199
00:09:00,210 --> 00:09:04,300
in this case we're

200
00:09:02,020 --> 00:09:07,360
trust me too in the case where threats

201
00:09:04,300 --> 00:09:09,849
needs to share data the program could

202
00:09:07,360 --> 00:09:13,899
create a shared domain and carefully

203
00:09:09,850 --> 00:09:17,080
control the SS privilege so far we've

204
00:09:13,899 --> 00:09:20,560
talked about how to use our proposed

205
00:09:17,080 --> 00:09:22,810
snv's from the user space we implemented

206
00:09:20,560 --> 00:09:25,209
the the SMB API in the user space for

207
00:09:22,810 --> 00:09:27,939
about 800 lines of code but what's

208
00:09:25,209 --> 00:09:30,430
really managing the memory views and

209
00:09:27,940 --> 00:09:33,010
enforcing the memory memory reference is

210
00:09:30,430 --> 00:09:36,250
actually in a kernel space that we

211
00:09:33,010 --> 00:09:39,700
implement it with around 2,000 lines of

212
00:09:36,250 --> 00:09:42,640
code in our Linux kernel prototype we've

213
00:09:39,700 --> 00:09:45,430
added SMB kernel module they access a

214
00:09:42,640 --> 00:09:48,760
system cost to invoke internal kernel

215
00:09:45,430 --> 00:09:51,640
function the SMB metadata management

216
00:09:48,760 --> 00:09:55,240
managed to manages the overall per

217
00:09:51,640 --> 00:09:57,370
process isolation setup we assumed and

218
00:09:55,240 --> 00:09:59,770
we also manipulate the page table for

219
00:09:57,370 --> 00:10:03,100
threats to isolate their memory space

220
00:09:59,770 --> 00:10:06,189
and we utilize the page fault handler as

221
00:10:03,100 --> 00:10:12,220
a software monitor to chat illegal

222
00:10:06,190 --> 00:10:14,110
memory references so dig into details in

223
00:10:12,220 --> 00:10:16,720
the current Linux kernel each process

224
00:10:14,110 --> 00:10:20,980
has 1 mm struck here and instruct the mm

225
00:10:16,720 --> 00:10:24,579
means memory management in kernel in

226
00:10:20,980 --> 00:10:27,640
Linux kernel so the aims check and

227
00:10:24,579 --> 00:10:30,339
instruct describes the memory space of a

228
00:10:27,640 --> 00:10:33,310
process a process try a process child of

229
00:10:30,339 --> 00:10:35,230
thread use the same image shot so that

230
00:10:33,310 --> 00:10:39,300
they are seen exact same virtual memory

231
00:10:35,230 --> 00:10:42,370
space and with with the same permission

232
00:10:39,300 --> 00:10:45,670
for metadata management we added several

233
00:10:42,370 --> 00:10:48,010
data structures to record a per process

234
00:10:45,670 --> 00:10:51,219
our solution set up in the in the kernel

235
00:10:48,010 --> 00:10:52,750
space the most important ones are mm

236
00:10:51,220 --> 00:10:55,089
dump truck and SME struct

237
00:10:52,750 --> 00:10:57,579
they record the privilege setup and

238
00:10:55,089 --> 00:11:00,130
virtual address mapping with privileged

239
00:10:57,579 --> 00:11:03,180
information inside the kernel so that

240
00:11:00,130 --> 00:11:06,970
your attacker cannot bypass

241
00:11:03,180 --> 00:11:10,449
kernel level protection to just to crack

242
00:11:06,970 --> 00:11:15,390
assemblies design it has to it has to

243
00:11:10,449 --> 00:11:18,689
exploit kernel in order to attack SMEs

244
00:11:15,390 --> 00:11:22,829
so you'll notice each and its SMB use

245
00:11:18,690 --> 00:11:26,089
one page table so we describe how we

246
00:11:22,829 --> 00:11:28,769
separate page table in the next slide

247
00:11:26,089 --> 00:11:32,700
this is how the original and external

248
00:11:28,769 --> 00:11:34,890
managers process and its threads memory

249
00:11:32,700 --> 00:11:37,880
space so you can see there in this

250
00:11:34,890 --> 00:11:40,620
example there are three threads they're

251
00:11:37,880 --> 00:11:44,450
all sharing the same page table and all

252
00:11:40,620 --> 00:11:47,850
the memory management related metadata

253
00:11:44,450 --> 00:11:50,700
but in SMPS we don't want threads to

254
00:11:47,850 --> 00:11:53,760
have to have global access to the entire

255
00:11:50,700 --> 00:11:58,170
process address space therefore we need

256
00:11:53,760 --> 00:12:01,140
to separate their page tables also as to

257
00:11:58,170 --> 00:12:03,329
mutually agree on the process address

258
00:12:01,140 --> 00:12:06,529
space but with different page tables

259
00:12:03,329 --> 00:12:09,449
threats are actually seen the same

260
00:12:06,529 --> 00:12:12,950
virtual memory space but with the with

261
00:12:09,450 --> 00:12:15,540
different permissions so with this

262
00:12:12,950 --> 00:12:17,250
memory management we could allow thread

263
00:12:15,540 --> 00:12:22,469
one to read and write to the protected

264
00:12:17,250 --> 00:12:28,170
region and threat to could only read

265
00:12:22,470 --> 00:12:30,480
well three has no permission at all so

266
00:12:28,170 --> 00:12:33,149
this partially shared memory memory

267
00:12:30,480 --> 00:12:35,190
space has several benefits for example

268
00:12:33,149 --> 00:12:38,640
it allows legacy for synchronization

269
00:12:35,190 --> 00:12:42,690
that utilizes mm shock to work with SMB

270
00:12:38,640 --> 00:12:45,990
seamlessly if you use pthreads library

271
00:12:42,690 --> 00:12:48,660
most of the most of the P threads API

272
00:12:45,990 --> 00:12:51,060
calls when they are using calling of

273
00:12:48,660 --> 00:12:56,130
synchronization api's internally Linux

274
00:12:51,060 --> 00:12:58,469
kernel uses this mm struct it also

275
00:12:56,130 --> 00:13:01,079
allows the bug in tools such as fel

276
00:12:58,470 --> 00:13:03,390
going to attach to an SME program

277
00:13:01,079 --> 00:13:05,719
because we don't use clone Sisco to

278
00:13:03,390 --> 00:13:08,640
create different processes rate space

279
00:13:05,720 --> 00:13:10,800
which breaks the single process that is

280
00:13:08,640 --> 00:13:14,160
single process address space assumption

281
00:13:10,800 --> 00:13:16,109
for tools life l grain and most

282
00:13:14,160 --> 00:13:19,010
importantly we found that sharing the

283
00:13:16,110 --> 00:13:21,120
same image shocked to avoid many kernel

284
00:13:19,010 --> 00:13:25,170
synchronization for M related data

285
00:13:21,120 --> 00:13:27,449
structures ok so once we have threads

286
00:13:25,170 --> 00:13:29,189
page tables set up separately we can

287
00:13:27,449 --> 00:13:33,240
check the ESS privilege when

288
00:13:29,190 --> 00:13:34,110
page four happens so when we're handling

289
00:13:33,240 --> 00:13:36,540
and page fault

290
00:13:34,110 --> 00:13:38,460
the original Linux kernel only checks

291
00:13:36,540 --> 00:13:41,430
whether a memory access is barely by

292
00:13:38,460 --> 00:13:45,420
determining if a given memory area is

293
00:13:41,430 --> 00:13:47,969
napped in a system if a region is is not

294
00:13:45,420 --> 00:13:51,060
mapped a segmentation fault signal will

295
00:13:47,970 --> 00:13:54,840
be delivered to the toilet program and

296
00:13:51,060 --> 00:13:57,449
that triggered a page fault if an access

297
00:13:54,840 --> 00:13:59,760
memory region is mapped or fixable and

298
00:13:57,450 --> 00:14:02,220
the kernel will proceed to prepare the

299
00:13:59,760 --> 00:14:04,860
memory page in the same instruction is

300
00:14:02,220 --> 00:14:07,560
executed again without without the SEC

301
00:14:04,860 --> 00:14:09,900
forcing signal so to facilitate intra

302
00:14:07,560 --> 00:14:12,209
process isolation we added additional

303
00:14:09,900 --> 00:14:15,230
privilege checks just before the kernel

304
00:14:12,210 --> 00:14:17,550
actually proceeded to fix the page fault

305
00:14:15,230 --> 00:14:20,820
so the added privilege checks are

306
00:14:17,550 --> 00:14:22,969
marking in a gray box our privilege

307
00:14:20,820 --> 00:14:25,740
checks first make sure the thread type

308
00:14:22,970 --> 00:14:27,720
if the fault is generated by an SME

309
00:14:25,740 --> 00:14:31,350
thread it further checks whether the

310
00:14:27,720 --> 00:14:33,180
smb3 is running it's running in SMB that

311
00:14:31,350 --> 00:14:36,570
has the privilege to access the domain

312
00:14:33,180 --> 00:14:39,030
containing the full address if the page

313
00:14:36,570 --> 00:14:41,220
fault passes all checks then the SME

314
00:14:39,030 --> 00:14:44,100
kernel will perform the main page in to

315
00:14:41,220 --> 00:14:46,770
fix the page fault otherwise there's any

316
00:14:44,100 --> 00:14:49,200
kernel or send segmentation for signal

317
00:14:46,770 --> 00:14:56,400
to the faulty SME threats to block under

318
00:14:49,200 --> 00:14:59,820
privileged access so let's that's all

319
00:14:56,400 --> 00:15:02,220
for a high-level implementation so now

320
00:14:59,820 --> 00:15:05,550
we go to evaluation we evaluate our

321
00:15:02,220 --> 00:15:08,280
snv's prototype on Intel machine with

322
00:15:05,550 --> 00:15:10,920
four cores and sixteen gigabytes of RAM

323
00:15:08,280 --> 00:15:14,160
running our modify Linux kernel based on

324
00:15:10,920 --> 00:15:16,800
version pre recent version released

325
00:15:14,160 --> 00:15:18,689
early this year we compile all the

326
00:15:16,800 --> 00:15:22,620
benchmarks into two versions P threads

327
00:15:18,690 --> 00:15:24,120
and SME threads for all multi-threaded

328
00:15:22,620 --> 00:15:26,160
benchmarks we create the n plus 1

329
00:15:24,120 --> 00:15:28,350
protection domains where n is the number

330
00:15:26,160 --> 00:15:30,750
of threads and the additional memory

331
00:15:28,350 --> 00:15:34,790
domain is the global pool for threads to

332
00:15:30,750 --> 00:15:37,140
securely share data to make sure our

333
00:15:34,790 --> 00:15:39,810
modification doesn't break the Linux

334
00:15:37,140 --> 00:15:43,050
kernel correctness when we tested our

335
00:15:39,810 --> 00:15:45,449
SME cono is a set of testing script in

336
00:15:43,050 --> 00:15:48,569
Linux test project I didn't observe any

337
00:15:45,450 --> 00:15:50,970
system errors or tympanic so it's just

338
00:15:48,570 --> 00:15:54,360
basically your set of script that is

339
00:15:50,970 --> 00:15:56,370
mash and alder were clone to your kernel

340
00:15:54,360 --> 00:16:00,680
and see if your current of crashes or

341
00:15:56,370 --> 00:16:03,030
didn't pass any test case or your kernel

342
00:16:00,680 --> 00:16:06,180
sometimes you could most much in most of

343
00:16:03,030 --> 00:16:09,089
the case you're gonna have kernel panic

344
00:16:06,180 --> 00:16:13,199
if your memory pages is now set up

345
00:16:09,090 --> 00:16:16,710
correctly so we pass all that checks the

346
00:16:13,200 --> 00:16:19,740
benchmark we used our parsec Firefox web

347
00:16:16,710 --> 00:16:22,110
browser Cherokee and patch web servers

348
00:16:19,740 --> 00:16:24,390
so all this bank all this experiment can

349
00:16:22,110 --> 00:16:29,430
be reproduced on systems running on

350
00:16:24,390 --> 00:16:32,400
today's x86 power so first we look at

351
00:16:29,430 --> 00:16:34,170
parsec which includes 12 applications in

352
00:16:32,400 --> 00:16:36,030
different application domains for

353
00:16:34,170 --> 00:16:38,400
example machine learning compression

354
00:16:36,030 --> 00:16:41,339
decompression and graphics kind of

355
00:16:38,400 --> 00:16:44,670
workloads these applications are all

356
00:16:41,340 --> 00:16:48,140
motivated with pretty complex threat

357
00:16:44,670 --> 00:16:50,699
interaction and memory operations

358
00:16:48,140 --> 00:16:53,939
although it is not necessary to protect

359
00:16:50,700 --> 00:16:55,410
the security of this benchmark

360
00:16:53,940 --> 00:16:57,090
application because they are just

361
00:16:55,410 --> 00:16:59,189
benchmark program without problem

362
00:16:57,090 --> 00:17:01,140
secrets but we use the project to show

363
00:16:59,190 --> 00:17:04,770
that assembly can protect threats

364
00:17:01,140 --> 00:17:06,780
private stack for different applications

365
00:17:04,770 --> 00:17:10,109
with intensive and parallel memory

366
00:17:06,780 --> 00:17:12,780
operations so there are twelve

367
00:17:10,109 --> 00:17:14,760
benchmarks and last bar is the average

368
00:17:12,780 --> 00:17:16,260
overhead the overhead the overall

369
00:17:14,760 --> 00:17:19,140
performance overhead is around two

370
00:17:16,260 --> 00:17:22,879
percent and we only added about two

371
00:17:19,140 --> 00:17:22,880
lines of code to each of the benchmark

372
00:17:23,000 --> 00:17:29,780
so to test real-world applications we

373
00:17:27,119 --> 00:17:32,550
first look at modifying web web servers

374
00:17:29,780 --> 00:17:34,950
we chose jerky because it uses per

375
00:17:32,550 --> 00:17:38,639
thread memory buffer to isolate threads

376
00:17:34,950 --> 00:17:40,670
from remote connections the SMB version

377
00:17:38,640 --> 00:17:43,620
of the server is able to automatically

378
00:17:40,670 --> 00:17:45,660
handle isolation with only two months of

379
00:17:43,620 --> 00:17:47,429
code changes one-line full header and

380
00:17:45,660 --> 00:17:50,880
other one initial for initializing the

381
00:17:47,430 --> 00:17:53,850
main program the server has 40 threats

382
00:17:50,880 --> 00:17:57,000
by default to handle incoming requests

383
00:17:53,850 --> 00:18:00,090
concurrently we use standard Apache

384
00:17:57,000 --> 00:18:02,700
to send 100,000 requests with

385
00:18:00,090 --> 00:18:05,760
concurrency level set to 4 and measure

386
00:18:02,700 --> 00:18:07,860
the wrong time overhead so results are

387
00:18:05,760 --> 00:18:10,680
just that the security enhanced jerky

388
00:18:07,860 --> 00:18:13,800
server does not incur more than 1% of

389
00:18:10,680 --> 00:18:16,530
runtime overhead in all cases we also

390
00:18:13,800 --> 00:18:20,280
ran experiment with Apache web server

391
00:18:16,530 --> 00:18:25,770
with even larger files up to 1 gigabytes

392
00:18:20,280 --> 00:18:28,860
and the overhead states below 1% finally

393
00:18:25,770 --> 00:18:31,290
we look at whether SMB will work on

394
00:18:28,860 --> 00:18:33,780
practical and more complex software such

395
00:18:31,290 --> 00:18:36,480
as web browsers they require strong

396
00:18:33,780 --> 00:18:39,840
resource isolation we use the snv's to

397
00:18:36,480 --> 00:18:43,340
protect firefox javascript engine called

398
00:18:39,840 --> 00:18:47,250
spider monkey the original Firefox

399
00:18:43,340 --> 00:18:48,629
already isolates resource for 4

400
00:18:47,250 --> 00:18:51,300
different tabs using the concept of

401
00:18:48,630 --> 00:18:52,980
compartments but the isolation

402
00:18:51,300 --> 00:18:55,800
boundaries for these compartments are

403
00:18:52,980 --> 00:18:58,560
only logical meaning that if there's a

404
00:18:55,800 --> 00:19:01,200
memory back then the attacker can

405
00:18:58,560 --> 00:19:02,970
exploit that memory block can run and

406
00:19:01,200 --> 00:19:06,660
attack other compartments it's still

407
00:19:02,970 --> 00:19:09,390
possible so we introduced a new threat

408
00:19:06,660 --> 00:19:12,050
type called SMB threat to Firefox with

409
00:19:09,390 --> 00:19:15,720
around 12 lines of code changes so that

410
00:19:12,050 --> 00:19:19,290
JavaScript engine could isolate jobs for

411
00:19:15,720 --> 00:19:22,500
different compartments so we ran this

412
00:19:19,290 --> 00:19:25,860
for different JavaScript benchmarks

413
00:19:22,500 --> 00:19:28,500
available online you can run this

414
00:19:25,860 --> 00:19:32,429
benchmark online to use your your

415
00:19:28,500 --> 00:19:34,530
browsers super your Chrome and we run we

416
00:19:32,430 --> 00:19:36,360
ran this benchmarks and I measure the

417
00:19:34,530 --> 00:19:40,770
runtime of overhead each benchmark

418
00:19:36,360 --> 00:19:43,139
contains about 20 to 40 workloads these

419
00:19:40,770 --> 00:19:45,960
benchmarks are they are designed to to

420
00:19:43,140 --> 00:19:48,060
be run in in its own tab and the page

421
00:19:45,960 --> 00:19:51,120
force are trapped by SM is to check the

422
00:19:48,060 --> 00:19:54,419
threads access privilege so the overall

423
00:19:51,120 --> 00:19:57,540
result indicates that the performance

424
00:19:54,420 --> 00:19:59,910
overhead is about 2% it's about 2% on

425
00:19:57,540 --> 00:20:03,540
average and so we believe our prototype

426
00:19:59,910 --> 00:20:07,700
could be practical and good practical

427
00:20:03,540 --> 00:20:07,700
for production software like Firefox

428
00:20:08,309 --> 00:20:12,428
so there are some limitations and

429
00:20:10,929 --> 00:20:14,169
concerns surrounding the current

430
00:20:12,429 --> 00:20:16,149
prototype of snv's for example

431
00:20:14,169 --> 00:20:18,850
assemblies do not protect against

432
00:20:16,149 --> 00:20:21,908
malicious library threats so to overcome

433
00:20:18,850 --> 00:20:24,189
this issue programmer could attend

434
00:20:21,909 --> 00:20:26,580
library source code and then compile it

435
00:20:24,190 --> 00:20:29,289
with assemblies for a maximum protection

436
00:20:26,580 --> 00:20:32,549
second assemblies provide intra process

437
00:20:29,289 --> 00:20:35,289
isolation I have to trust the OS kernel

438
00:20:32,549 --> 00:20:36,940
there are several of toggling works that

439
00:20:35,289 --> 00:20:39,039
could be used to further isolate the

440
00:20:36,940 --> 00:20:42,490
Auris kernel for example nested kernel

441
00:20:39,039 --> 00:20:46,690
for x86 architecture or ski on arm for

442
00:20:42,490 --> 00:20:48,429
mobile devices also currently SMEs do

443
00:20:46,690 --> 00:20:51,850
not protect against the text targeting

444
00:20:48,429 --> 00:20:55,389
data on the same page this problem could

445
00:20:51,850 --> 00:20:57,668
be handled by avoiding that poor data

446
00:20:55,389 --> 00:21:00,279
placement for example don't put problem

447
00:20:57,669 --> 00:21:02,909
state secrets right next to an attacker

448
00:21:00,279 --> 00:21:05,980
control payload in the same page and

449
00:21:02,909 --> 00:21:10,269
finally assemblies can attack our system

450
00:21:05,980 --> 00:21:15,700
with how well box that will affect the

451
00:21:10,269 --> 00:21:17,950
correctness of the page table bits we

452
00:21:15,700 --> 00:21:20,259
have some interesting ideas for our

453
00:21:17,950 --> 00:21:22,450
ongoing work just to name a few

454
00:21:20,259 --> 00:21:25,600
we envision a security context switch

455
00:21:22,450 --> 00:21:28,179
mechanism that allows SMB threats to

456
00:21:25,600 --> 00:21:31,389
securely switch between different

457
00:21:28,179 --> 00:21:34,899
assemblies such mechanism will help

458
00:21:31,389 --> 00:21:36,879
applications to that embedded privilege

459
00:21:34,899 --> 00:21:38,768
component into under each one in the

460
00:21:36,879 --> 00:21:41,498
same positive space to isolate the

461
00:21:38,769 --> 00:21:45,399
memory views for example cellulous

462
00:21:41,499 --> 00:21:49,059
database applications such as sequel by

463
00:21:45,399 --> 00:21:51,580
3 or tokyo cabinet in addition we're

464
00:21:49,059 --> 00:21:53,860
also looking at mechanism for snv's

465
00:21:51,580 --> 00:21:56,619
across different processes as its faces

466
00:21:53,860 --> 00:21:59,289
to collaborate in secure and controlled

467
00:21:56,619 --> 00:22:00,639
fashion so this will provide software

468
00:21:59,289 --> 00:22:03,899
almost unbound the amount of virtual

469
00:22:00,639 --> 00:22:05,860
memory with capabilities protection

470
00:22:03,899 --> 00:22:08,168
finally assemblies rely on the

471
00:22:05,860 --> 00:22:10,539
correctness of like solution set up to

472
00:22:08,169 --> 00:22:13,059
provide protection therefore we are

473
00:22:10,539 --> 00:22:14,470
interested in designing a practical tool

474
00:22:13,059 --> 00:22:19,389
that would guide the programmer to

475
00:22:14,470 --> 00:22:21,929
design secure computing environment ok

476
00:22:19,389 --> 00:22:23,129
to summarize we propose a programming

477
00:22:21,929 --> 00:22:25,110
action with Colonel level implementation

478
00:22:23,129 --> 00:22:29,189
called SMBs

479
00:22:25,110 --> 00:22:30,990
for intra process isolation assemblies

480
00:22:29,190 --> 00:22:34,799
allowed programmer to selectively

481
00:22:30,990 --> 00:22:36,450
isolate process memory for threats so

482
00:22:34,799 --> 00:22:39,899
that a malicious photo man cannot

483
00:22:36,450 --> 00:22:43,440
compromise other benign ones we believe

484
00:22:39,899 --> 00:22:45,959
SMEs are flexible and easy to use it's

485
00:22:43,440 --> 00:22:47,970
flexible as we've shown that we were

486
00:22:45,960 --> 00:22:50,309
able to use a service on different

487
00:22:47,970 --> 00:22:53,789
software from desktop web browser to

488
00:22:50,309 --> 00:22:57,269
back-end web servers it's easy to use

489
00:22:53,789 --> 00:22:59,519
because the evaluation showed that SMB

490
00:22:57,269 --> 00:23:02,039
is required at most 12 lines of code

491
00:22:59,519 --> 00:23:05,210
changes to legacy software such as

492
00:23:02,039 --> 00:23:08,249
Firefox with 13 million lines of code

493
00:23:05,210 --> 00:23:10,730
SMEs rely on commodity hardware so no

494
00:23:08,249 --> 00:23:14,190
FPGA or special hardware is need

495
00:23:10,730 --> 00:23:16,830
actually the systems were all wrong time

496
00:23:14,190 --> 00:23:18,749
overhead in various benchmarks and real

497
00:23:16,830 --> 00:23:20,789
world applications to show that this

498
00:23:18,749 --> 00:23:22,889
protection mechanism could become a

499
00:23:20,789 --> 00:23:28,879
fairly practical solution for intra

500
00:23:22,889 --> 00:23:31,889
process isolation I concludes my talk

501
00:23:28,879 --> 00:23:33,658
SMEs prototype is publicly available on

502
00:23:31,889 --> 00:23:35,969
github you're welcome to try system now

503
00:23:33,659 --> 00:23:38,519
and I'm sure the prototype is not

504
00:23:35,970 --> 00:23:41,460
perfect so feel free to contact me if

505
00:23:38,519 --> 00:23:43,259
you have it's just interesting ideas how

506
00:23:41,460 --> 00:23:45,720
to improve the prototype or any speeding

507
00:23:43,259 --> 00:23:48,049
up projects thank you I'll take

508
00:23:45,720 --> 00:23:48,049
questions

509
00:23:59,730 --> 00:24:05,399
any questions there a question could you

510
00:24:02,760 --> 00:24:09,720
go in more details how do you enforce

511
00:24:05,399 --> 00:24:11,459
those policies so the policies defined

512
00:24:09,720 --> 00:24:14,159
by the programmer so the programmer has

513
00:24:11,460 --> 00:24:17,130
to say ok I have this set of virtual

514
00:24:14,159 --> 00:24:19,769
memory region and then I allow only set

515
00:24:17,130 --> 00:24:21,480
up threats who access those region so

516
00:24:19,769 --> 00:24:23,909
it's set up by the programmer at the

517
00:24:21,480 --> 00:24:27,779
high level but the privilege in

518
00:24:23,909 --> 00:24:31,019
enforcement's implemented in the kernel

519
00:24:27,779 --> 00:24:33,600
level so this is the architecture so you

520
00:24:31,019 --> 00:24:38,760
can't use API calls as a programmer you

521
00:24:33,600 --> 00:24:40,649
can use our API calls to insert the

522
00:24:38,760 --> 00:24:42,230
policy set up in your source code and

523
00:24:40,649 --> 00:24:44,518
then compile it with our library and

524
00:24:42,230 --> 00:24:47,639
then you run the program our kernel

525
00:24:44,519 --> 00:24:49,769
whenever there is a security violation

526
00:24:47,639 --> 00:24:55,789
they kind of intercept evaluation

527
00:24:49,769 --> 00:24:55,789
through page fault yes

528
00:24:59,150 --> 00:25:05,090
so there are two parts one part it's

529
00:25:01,570 --> 00:25:07,850
user level library and there is another

530
00:25:05,090 --> 00:25:09,530
part that's sitting inside the kernel so

531
00:25:07,850 --> 00:25:14,439
as you can see in this our architecture

532
00:25:09,530 --> 00:25:18,950
figure so I have user level there's a

533
00:25:14,440 --> 00:25:21,590
user level a SME user space API so those

534
00:25:18,950 --> 00:25:25,280
are the API is the programmer uses to

535
00:25:21,590 --> 00:25:28,220
set up the security policy and after

536
00:25:25,280 --> 00:25:30,050
that everything every day all the secure

537
00:25:28,220 --> 00:25:33,200
access the enforcement is done by the

538
00:25:30,050 --> 00:25:34,790
kernel which is located in the kernel

539
00:25:33,200 --> 00:25:39,950
space and the programmer has no

540
00:25:34,790 --> 00:25:45,590
privilege to touch those go to the

541
00:25:39,950 --> 00:25:47,240
kernel space I wouldn't say it's it's

542
00:25:45,590 --> 00:25:49,040
not possible it is possible because

543
00:25:47,240 --> 00:25:53,330
there are a lot of kernel exploits

544
00:25:49,040 --> 00:25:54,379
existing today's attack I wouldn't say

545
00:25:53,330 --> 00:25:57,230
it's hard either I would say it's

546
00:25:54,380 --> 00:25:59,000
orthogonal topic topic you can use other

547
00:25:57,230 --> 00:26:02,600
production mechanism and then compile it

548
00:25:59,000 --> 00:26:09,440
come combine that with snv's to provide

549
00:26:02,600 --> 00:26:17,469
full protection yeah are there other

550
00:26:09,440 --> 00:26:17,470
questions all right thank you

551
00:26:35,220 --> 00:26:37,280
you

552
00:26:40,220 --> 00:26:42,280
you

