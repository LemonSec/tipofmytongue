1
00:00:03,299 --> 00:00:11,220
find out if I should call my hair

2
00:00:05,530 --> 00:00:11,220
raining once I come up on the screen I

3
00:00:12,840 --> 00:00:18,970
can get too much right now it's next

4
00:00:14,950 --> 00:00:24,150
door at a very short walk yeah you too

5
00:00:18,970 --> 00:00:24,150
much got scammed by 30 seconds please

6
00:00:50,810 --> 00:00:57,470
okay welcome to the final serious

7
00:00:54,510 --> 00:01:00,180
seminar for spring semester of 2016

8
00:00:57,470 --> 00:01:04,440
today we have with us Christopher

9
00:01:00,180 --> 00:01:05,940
Gutierrez who is a PhD student in the

10
00:01:04,440 --> 00:01:09,289
department of computer science and

11
00:01:05,940 --> 00:01:13,259
serious here at Purdue University

12
00:01:09,290 --> 00:01:15,479
crisper comes to us from Cal State where

13
00:01:13,260 --> 00:01:18,420
he did his undergraduate his bachelor's

14
00:01:15,479 --> 00:01:21,960
and master's work has been out here

15
00:01:18,420 --> 00:01:25,050
since I believe 2011 and is going to be

16
00:01:21,960 --> 00:01:30,119
talking to us today about the work that

17
00:01:25,050 --> 00:01:33,630
one the best poster award at the serious

18
00:01:30,119 --> 00:01:37,740
symposium held last week so that I got

19
00:01:33,630 --> 00:01:38,910
turned over to Chris thanks so today I'm

20
00:01:37,740 --> 00:01:41,729
going to be presenting earth sets

21
00:01:38,910 --> 00:01:43,710
passwords any password cracking and

22
00:01:41,729 --> 00:01:47,039
detecting leakage so this work was

23
00:01:43,710 --> 00:01:51,210
pioneered by mohamed el machaca which

24
00:01:47,040 --> 00:01:52,800
graduate he graduated last year and some

25
00:01:51,210 --> 00:01:55,169
of the some of the work i continued on

26
00:01:52,800 --> 00:01:59,479
from that this is also work with spa and

27
00:01:55,170 --> 00:02:02,490
Micah tall and Geoff Avery so the paper

28
00:01:59,479 --> 00:02:04,679
which some of the stuff here's detailed

29
00:02:02,490 --> 00:02:07,318
is was presented in acts act 2015

30
00:02:04,679 --> 00:02:09,209
there's a journal submission underway

31
00:02:07,319 --> 00:02:10,110
with some of the new results that I'll

32
00:02:09,209 --> 00:02:14,370
talk about towards the end of the

33
00:02:10,110 --> 00:02:17,430
presentation so this work we're looking

34
00:02:14,370 --> 00:02:18,900
at passwords and protecting them they're

35
00:02:17,430 --> 00:02:22,380
a big problem here are some news

36
00:02:18,900 --> 00:02:25,650
articles it seems like these things are

37
00:02:22,380 --> 00:02:28,109
reoccurring Evernote some password

38
00:02:25,650 --> 00:02:31,560
leakages there Yahoo you harmony

39
00:02:28,110 --> 00:02:33,150
linkedin I'm sure if you go out in

40
00:02:31,560 --> 00:02:34,620
Google right now and search with some

41
00:02:33,150 --> 00:02:38,550
stuff you could see some more later

42
00:02:34,620 --> 00:02:41,160
leakages passwords are kind of here to

43
00:02:38,550 --> 00:02:42,780
stay and when you figure out a better

44
00:02:41,160 --> 00:02:45,329
way to protect them so I'm this work

45
00:02:42,780 --> 00:02:50,310
we're going to be using deception to try

46
00:02:45,330 --> 00:02:53,250
to help mitigate some of the leakages so

47
00:02:50,310 --> 00:02:54,930
here's kind of the general threat model

48
00:02:53,250 --> 00:02:57,030
right you have a user that's using some

49
00:02:54,930 --> 00:02:59,220
online services it's like you know some

50
00:02:57,030 --> 00:03:00,870
social network or what have you they

51
00:02:59,220 --> 00:03:02,819
communicate their password and and

52
00:03:00,870 --> 00:03:03,920
somewhere out on the net the password is

53
00:03:02,819 --> 00:03:07,000
stored say

54
00:03:03,920 --> 00:03:09,589
some cryptographic hash with some salt

55
00:03:07,000 --> 00:03:11,390
the problem is if there's an insider

56
00:03:09,590 --> 00:03:14,510
that has access to that web server or

57
00:03:11,390 --> 00:03:17,208
there's a the web surrogate or the

58
00:03:14,510 --> 00:03:19,519
server gets compromised then someone can

59
00:03:17,209 --> 00:03:21,950
steal those passwords and run a brute

60
00:03:19,520 --> 00:03:26,300
force attack breaking some of the weak

61
00:03:21,950 --> 00:03:29,899
passwords so with the earth SATs

62
00:03:26,300 --> 00:03:31,519
password the go our our goal here is to

63
00:03:29,900 --> 00:03:33,920
eliminate the possibility offline

64
00:03:31,519 --> 00:03:35,720
dictionary attacks by injecting some

65
00:03:33,920 --> 00:03:40,458
deceit into the way we store the

66
00:03:35,720 --> 00:03:41,690
passwords also since we're injecting the

67
00:03:40,459 --> 00:03:43,700
seat we're giving them false information

68
00:03:41,690 --> 00:03:45,650
if they go out and try to crack these

69
00:03:43,700 --> 00:03:47,810
passwords rather than producing a real

70
00:03:45,650 --> 00:03:50,450
password we they produce a fake password

71
00:03:47,810 --> 00:03:54,650
they go out and try to login posing as a

72
00:03:50,450 --> 00:03:56,420
user an alarm is triggered and you're

73
00:03:54,650 --> 00:03:58,910
going to react appropriately so

74
00:03:56,420 --> 00:04:07,190
notifying the user system administrators

75
00:03:58,910 --> 00:04:09,530
walking the account or etc so here's the

76
00:04:07,190 --> 00:04:11,900
kind of a high level view of what it

77
00:04:09,530 --> 00:04:15,230
sets password without what our system

78
00:04:11,900 --> 00:04:16,820
actually does it uses in the center here

79
00:04:15,230 --> 00:04:20,450
we have the hardware security module

80
00:04:16,820 --> 00:04:22,940
which is critical to our to the way we

81
00:04:20,450 --> 00:04:26,150
generate these password hashes so on the

82
00:04:22,940 --> 00:04:28,880
left-hand side you have your your master

83
00:04:26,150 --> 00:04:34,010
password file say sort on like a bsd

84
00:04:28,880 --> 00:04:35,450
system with several user accounts so i'm

85
00:04:34,010 --> 00:04:36,950
going to guide you through kind of the

86
00:04:35,450 --> 00:04:41,930
process of whether it's that's password

87
00:04:36,950 --> 00:04:43,400
does first when the user types in the

88
00:04:41,930 --> 00:04:46,130
password say for the first time they

89
00:04:43,400 --> 00:04:48,890
they login to create a new password a

90
00:04:46,130 --> 00:04:50,510
fake password is generated and i'll talk

91
00:04:48,890 --> 00:04:52,219
about how that generation actually works

92
00:04:50,510 --> 00:04:54,950
let's say we just come up with some

93
00:04:52,220 --> 00:04:58,820
simple password to as kind of like the

94
00:04:54,950 --> 00:05:02,180
the decoy password next we'll use the

95
00:04:58,820 --> 00:05:04,460
hardware security module to generate a

96
00:05:02,180 --> 00:05:06,919
new password salt and hash and these

97
00:05:04,460 --> 00:05:09,229
salt and hashes are indistinguishable

98
00:05:06,919 --> 00:05:11,719
from how you would what you would expect

99
00:05:09,229 --> 00:05:14,750
to be stored on a real system and then

100
00:05:11,720 --> 00:05:16,820
we we write out these these new modified

101
00:05:14,750 --> 00:05:19,550
hashes out into the

102
00:05:16,820 --> 00:05:22,969
password the file that stores all the

103
00:05:19,550 --> 00:05:25,100
password hashes and all the dive into

104
00:05:22,970 --> 00:05:28,820
the details of the generation how that

105
00:05:25,100 --> 00:05:31,520
all works so we have two threats to

106
00:05:28,820 --> 00:05:34,190
consider here we have an offline

107
00:05:31,520 --> 00:05:36,590
adversary so this is an adversary that

108
00:05:34,190 --> 00:05:38,510
obtains the username and password hashes

109
00:05:36,590 --> 00:05:40,130
but doesn't have access to the actual

110
00:05:38,510 --> 00:05:42,440
machine in which the passwords are

111
00:05:40,130 --> 00:05:44,900
stored think of this as someone

112
00:05:42,440 --> 00:05:47,020
compromising machine stealing the hashes

113
00:05:44,900 --> 00:05:48,979
running it through John the Ripper and

114
00:05:47,020 --> 00:05:51,650
posting all those passwords and

115
00:05:48,980 --> 00:05:54,440
usernames out in like put a paste bin or

116
00:05:51,650 --> 00:05:56,060
some other website so the attacker is

117
00:05:54,440 --> 00:05:58,100
able to download that information and

118
00:05:56,060 --> 00:06:02,750
perhaps you use it to go log into those

119
00:05:58,100 --> 00:06:04,880
accounts so we assume that the attacker

120
00:06:02,750 --> 00:06:06,950
may be aware that their debts password

121
00:06:04,880 --> 00:06:09,230
isn't actually in place on the server

122
00:06:06,950 --> 00:06:10,789
which these hashes were generated but

123
00:06:09,230 --> 00:06:13,190
does not have access to the server to

124
00:06:10,790 --> 00:06:15,980
actually query the harbor dependent

125
00:06:13,190 --> 00:06:20,840
function which we use in our experiments

126
00:06:15,980 --> 00:06:22,490
at HSN Harbor security module on the

127
00:06:20,840 --> 00:06:23,989
other hand we have an online adversary

128
00:06:22,490 --> 00:06:25,610
so this is the adversary that actually

129
00:06:23,990 --> 00:06:27,710
has access to the machine which

130
00:06:25,610 --> 00:06:32,720
generates the passwords and hashes that

131
00:06:27,710 --> 00:06:34,880
are stored on on factual servant so this

132
00:06:32,720 --> 00:06:36,950
is the same basically the same threat

133
00:06:34,880 --> 00:06:38,990
model but they have access to the actual

134
00:06:36,950 --> 00:06:41,960
machine which with the the password

135
00:06:38,990 --> 00:06:45,260
hashes are generated notice here though

136
00:06:41,960 --> 00:06:47,299
if if the adversary is able to server

137
00:06:45,260 --> 00:06:49,460
this hardware security module the

138
00:06:47,300 --> 00:06:52,160
security basically reduces down to what

139
00:06:49,460 --> 00:06:55,580
we had to just a conventional hashing

140
00:06:52,160 --> 00:06:58,130
scheme just to say here that our scheme

141
00:06:55,580 --> 00:06:59,990
that we're proposing is a supplement not

142
00:06:58,130 --> 00:07:02,990
a replacement to your traditional

143
00:06:59,990 --> 00:07:04,910
mechanisms to safely store passwords

144
00:07:02,990 --> 00:07:10,130
this is just another layer of security

145
00:07:04,910 --> 00:07:12,490
that we're providing so here I'll talk a

146
00:07:10,130 --> 00:07:14,630
little bit about the technical details

147
00:07:12,490 --> 00:07:16,610
so I'm going to guide you through how

148
00:07:14,630 --> 00:07:20,719
the system would work if you're a brand

149
00:07:16,610 --> 00:07:22,100
new user actually no sorry this is this

150
00:07:20,720 --> 00:07:25,490
is if you're having an existing user

151
00:07:22,100 --> 00:07:27,860
with some hash is stored on on on the

152
00:07:25,490 --> 00:07:30,500
server in your traditional way so up at

153
00:07:27,860 --> 00:07:33,260
the top we have you I

154
00:07:30,500 --> 00:07:36,140
which is the user a is the the

155
00:07:33,260 --> 00:07:39,590
cryptographic hash of the password and s

156
00:07:36,140 --> 00:07:43,550
is the the random salt we first push

157
00:07:39,590 --> 00:07:48,710
this that the password hash through the

158
00:07:43,550 --> 00:07:50,840
harbor dependent function which which we

159
00:07:48,710 --> 00:07:52,120
then push it through your your hashing

160
00:07:50,840 --> 00:07:55,099
scheme that you have on your server

161
00:07:52,120 --> 00:07:57,620
appended to the salt so that's the third

162
00:07:55,100 --> 00:08:00,320
step here on the bottom to produce beta

163
00:07:57,620 --> 00:08:09,230
beta is your new hash that you saved on

164
00:08:00,320 --> 00:08:10,669
the on your on your server so this this

165
00:08:09,230 --> 00:08:12,650
first step that we just went through is

166
00:08:10,669 --> 00:08:16,219
just kind of the initialization to

167
00:08:12,650 --> 00:08:18,890
produce these new hashes on the stored

168
00:08:16,220 --> 00:08:20,750
on your server at some later point when

169
00:08:18,890 --> 00:08:22,760
the user logs in now that we've

170
00:08:20,750 --> 00:08:25,460
initialized the system they provide

171
00:08:22,760 --> 00:08:29,270
their username password so you I the

172
00:08:25,460 --> 00:08:32,210
user name p I the password we'd use a

173
00:08:29,270 --> 00:08:36,740
the password to generate this earth

174
00:08:32,210 --> 00:08:38,000
stats password this P I star I'll talk a

175
00:08:36,740 --> 00:08:40,820
little bit about the details of how you

176
00:08:38,000 --> 00:08:44,420
generate that just for now it's just

177
00:08:40,820 --> 00:08:46,490
some some other this the are deceptive

178
00:08:44,420 --> 00:08:50,990
component it's some randomly generated

179
00:08:46,490 --> 00:08:54,680
password that will pose as as the fake

180
00:08:50,990 --> 00:08:57,020
password so once we do that we generate

181
00:08:54,680 --> 00:08:58,910
the search sets password we generate

182
00:08:57,020 --> 00:09:03,620
this new saw and this is really kind of

183
00:08:58,910 --> 00:09:05,780
the critical component of the scheme we

184
00:09:03,620 --> 00:09:08,960
use the the true password appended with

185
00:09:05,780 --> 00:09:12,709
the username and we XOR that with their

186
00:09:08,960 --> 00:09:14,660
tats password that we generated again

187
00:09:12,710 --> 00:09:16,930
this Purdue this is going to be our new

188
00:09:14,660 --> 00:09:20,839
salt that we're storing on the server

189
00:09:16,930 --> 00:09:23,989
one note keep in mind the identity here

190
00:09:20,839 --> 00:09:26,600
so the actual Earth's that's password is

191
00:09:23,990 --> 00:09:28,850
equal to this harder dependent function

192
00:09:26,600 --> 00:09:31,810
that we pass through the username and

193
00:09:28,850 --> 00:09:34,730
password x sword with the salt and that

194
00:09:31,810 --> 00:09:38,959
will hopefully be clear here in a minute

195
00:09:34,730 --> 00:09:41,600
why that's an important step once we do

196
00:09:38,959 --> 00:09:44,030
that we produce this new hash now that

197
00:09:41,600 --> 00:09:46,040
the user has provided their to password

198
00:09:44,030 --> 00:09:48,709
and we store the new salt and the new

199
00:09:46,040 --> 00:09:51,890
hash in our database so this is at the

200
00:09:48,710 --> 00:09:55,400
very bottom we have beta and beta i-beam

201
00:09:51,890 --> 00:10:07,189
they use the hash for the user I and the

202
00:09:55,400 --> 00:10:10,310
sulfur user so now you know we want to

203
00:10:07,190 --> 00:10:12,170
see how this works now a user is going

204
00:10:10,310 --> 00:10:14,000
to log in they provide their username

205
00:10:12,170 --> 00:10:15,680
and password and we're going to run

206
00:10:14,000 --> 00:10:21,470
through kind of what happens in the

207
00:10:15,680 --> 00:10:24,140
Earth's at scheme so first we check to

208
00:10:21,470 --> 00:10:27,290
see if the user provided the correct

209
00:10:24,140 --> 00:10:29,300
password so this is the identity that I

210
00:10:27,290 --> 00:10:31,699
mentioned earlier that if the user

211
00:10:29,300 --> 00:10:34,280
provided the true password the hdf

212
00:10:31,700 --> 00:10:38,540
appended with a true password and the

213
00:10:34,280 --> 00:10:40,699
username x sword with a stored salt it

214
00:10:38,540 --> 00:10:42,860
will produce a bi and notice here on the

215
00:10:40,700 --> 00:10:45,070
bottom I have a note the reason if the

216
00:10:42,860 --> 00:10:49,310
user provided the true password this

217
00:10:45,070 --> 00:10:54,110
calculation should come out to be the

218
00:10:49,310 --> 00:10:56,719
ersatz password if the user enters in

219
00:10:54,110 --> 00:10:58,040
some so part of our scheme we first

220
00:10:56,720 --> 00:11:00,320
check to see if they entered in the true

221
00:10:58,040 --> 00:11:02,329
password next we check to see if if if

222
00:11:00,320 --> 00:11:03,860
that failed that first step failed we

223
00:11:02,330 --> 00:11:07,400
check to see if the earth sides password

224
00:11:03,860 --> 00:11:08,990
was was provided so if the earth sets

225
00:11:07,400 --> 00:11:13,130
password was provided we generate an

226
00:11:08,990 --> 00:11:14,570
alert else if both of those steps fail

227
00:11:13,130 --> 00:11:20,810
them then we just tell the user that

228
00:11:14,570 --> 00:11:23,230
their authentication failed any

229
00:11:20,810 --> 00:11:23,229
questions

230
00:11:25,529 --> 00:11:30,089
this is kind of the tricky part of the

231
00:11:27,269 --> 00:11:32,819
talk so you can if you can explain that

232
00:11:30,089 --> 00:11:35,279
so so what's happening in this second

233
00:11:32,819 --> 00:11:37,769
step what what exactly has happened so

234
00:11:35,279 --> 00:11:39,779
the first step we check to see if the

235
00:11:37,769 --> 00:11:41,339
user provided that you password and we

236
00:11:39,779 --> 00:11:43,589
run it through our heart of hardware

237
00:11:41,339 --> 00:11:45,809
dependent function the second step if

238
00:11:43,589 --> 00:11:51,350
the user provided the earth SATs

239
00:11:45,809 --> 00:11:54,540
password so if i have my mouse here

240
00:11:51,350 --> 00:11:57,029
where my mouse ago so i'll just try to

241
00:11:54,540 --> 00:11:59,579
explain it so if the user / the user

242
00:11:57,029 --> 00:12:02,759
provides p i which i highlighted in blue

243
00:11:59,579 --> 00:12:04,439
if this P I is this is the same p i

244
00:12:02,759 --> 00:12:06,809
starred that we produce when we

245
00:12:04,439 --> 00:12:09,180
generated the hash then we trigger an

246
00:12:06,809 --> 00:12:10,980
alarm and it's because of this identity

247
00:12:09,180 --> 00:12:21,870
down here in the bottom if you look

248
00:12:10,980 --> 00:12:29,009
closely um what's that hmm yes I'll walk

249
00:12:21,870 --> 00:12:31,290
I'll walk around so notice here when we

250
00:12:29,009 --> 00:12:35,399
so just ignore this right here where we

251
00:12:31,290 --> 00:12:37,920
produce the salt this is the salt we

252
00:12:35,399 --> 00:12:39,779
produce which is you know typically in

253
00:12:37,920 --> 00:12:41,128
your in your traditional system it's

254
00:12:39,779 --> 00:12:45,029
just some randomly generated number

255
00:12:41,129 --> 00:12:46,350
right so here the way we produce it is

256
00:12:45,029 --> 00:12:48,480
we run it through our heart dependent

257
00:12:46,350 --> 00:12:50,129
function with the true password of X

258
00:12:48,480 --> 00:12:53,309
sword with the Earth's that's password

259
00:12:50,129 --> 00:12:56,839
and so up here when we check this if the

260
00:12:53,309 --> 00:12:59,850
user provided the true password this SI

261
00:12:56,839 --> 00:13:02,100
cancels out with what we had before

262
00:12:59,850 --> 00:13:04,259
right if you look here just replace this

263
00:13:02,100 --> 00:13:05,730
part up here with the SI these two

264
00:13:04,259 --> 00:13:10,050
portions cancel out and we're left with

265
00:13:05,730 --> 00:13:11,759
the ersatz password so we first check

266
00:13:10,050 --> 00:13:15,870
the true password and if the true

267
00:13:11,759 --> 00:13:17,870
password is equals R sr-bi that we have

268
00:13:15,870 --> 00:13:21,449
stored the only authenticate the user

269
00:13:17,870 --> 00:13:23,790
next we check to see if the p.i that the

270
00:13:21,449 --> 00:13:25,889
that the user provided is the ersatz

271
00:13:23,790 --> 00:13:27,629
password and we do this by just running

272
00:13:25,889 --> 00:13:29,069
it through the hash without pushing it

273
00:13:27,629 --> 00:13:32,670
through the hardware dependent function

274
00:13:29,069 --> 00:13:35,540
and that will produce if they're if

275
00:13:32,670 --> 00:13:38,069
they're equal then we trigger an alarm

276
00:13:35,540 --> 00:13:39,520
so my question is why is that an alarm

277
00:13:38,069 --> 00:13:42,390
why is that some

278
00:13:39,520 --> 00:13:46,210
that should trigger an alarm right so

279
00:13:42,390 --> 00:13:47,740
the idea here is if you if if an

280
00:13:46,210 --> 00:13:50,800
attacker steals all these passwords

281
00:13:47,740 --> 00:13:53,050
which is our beta since they don't have

282
00:13:50,800 --> 00:13:54,370
access to the hdf they don't have that

283
00:13:53,050 --> 00:13:55,719
physical access we're assuming they

284
00:13:54,370 --> 00:13:58,360
don't have access to the hardware

285
00:13:55,720 --> 00:13:59,770
security module then they're there when

286
00:13:58,360 --> 00:14:01,690
they run a brute force attack with a

287
00:13:59,770 --> 00:14:03,130
dictionary they're only able to push

288
00:14:01,690 --> 00:14:06,430
through dictionary words and not

289
00:14:03,130 --> 00:14:08,380
actually calculate that hdf portion so

290
00:14:06,430 --> 00:14:11,500
it triggers an alarm because if the

291
00:14:08,380 --> 00:14:15,220
attacker went through a dictionary for P

292
00:14:11,500 --> 00:14:16,540
I then at some point if the that the

293
00:14:15,220 --> 00:14:20,230
passwords week then it's going to

294
00:14:16,540 --> 00:14:28,030
produce the the beta I that was that can

295
00:14:20,230 --> 00:14:30,390
be produced without the hdf any other

296
00:14:28,030 --> 00:14:30,390
questions

297
00:14:33,390 --> 00:14:41,040
alright so three main properties like i

298
00:14:38,700 --> 00:14:43,170
mentioned checking the password requires

299
00:14:41,040 --> 00:14:46,829
access physical access to this hardware

300
00:14:43,170 --> 00:14:48,390
dependent function in our scheme which

301
00:14:46,830 --> 00:14:50,130
i'll talk about talk about some of the

302
00:14:48,390 --> 00:14:51,630
implementation details here in a minute

303
00:14:50,130 --> 00:14:54,840
we use the hardware security module

304
00:14:51,630 --> 00:14:58,650
which is just something that you can

305
00:14:54,840 --> 00:15:01,500
purchase online so I sense the attacker

306
00:14:58,650 --> 00:15:04,380
doesn't have access to the hardware

307
00:15:01,500 --> 00:15:06,420
security module they can't do an offline

308
00:15:04,380 --> 00:15:08,040
dictionary tag if they steal these

309
00:15:06,420 --> 00:15:12,180
passwords and put a push it through John

310
00:15:08,040 --> 00:15:13,439
the Ripper it will it will produce it

311
00:15:12,180 --> 00:15:15,120
will it will make it look like they

312
00:15:13,440 --> 00:15:19,890
found the true password but in fact it's

313
00:15:15,120 --> 00:15:21,390
not the true password so cracking

314
00:15:19,890 --> 00:15:24,990
returns are sets password for every

315
00:15:21,390 --> 00:15:27,870
count so rather than some of the some of

316
00:15:24,990 --> 00:15:29,970
the other work of putting some some

317
00:15:27,870 --> 00:15:31,890
false information in dated and password

318
00:15:29,970 --> 00:15:34,020
databases you can put like a fake user

319
00:15:31,890 --> 00:15:35,730
and password and maybe have something

320
00:15:34,020 --> 00:15:38,760
out there authentication server checking

321
00:15:35,730 --> 00:15:42,930
to see if if the fake user and password

322
00:15:38,760 --> 00:15:44,760
was provided our scheme rather produces

323
00:15:42,930 --> 00:15:49,290
a fake password for every user account

324
00:15:44,760 --> 00:15:51,120
that's stored in our system and what's

325
00:15:49,290 --> 00:15:54,990
really nice is that we maintain the same

326
00:15:51,120 --> 00:15:57,090
password format so that if an attacker

327
00:15:54,990 --> 00:15:59,160
were to look just look through the

328
00:15:57,090 --> 00:16:01,350
password file it wouldn't show anything

329
00:15:59,160 --> 00:16:02,910
different they of course can run some

330
00:16:01,350 --> 00:16:05,520
other statistical analysis to try to

331
00:16:02,910 --> 00:16:07,020
detect this if this game is in place but

332
00:16:05,520 --> 00:16:10,890
the goal here is to deceive the attacker

333
00:16:07,020 --> 00:16:12,300
into using these these fake these fake

334
00:16:10,890 --> 00:16:15,470
password files that are generated

335
00:16:12,300 --> 00:16:15,469
through a brute force attack

336
00:16:16,950 --> 00:16:23,760
so I mentioned earlier this generation

337
00:16:19,620 --> 00:16:26,700
function which is the way we produce

338
00:16:23,760 --> 00:16:27,750
these fake passwords there's some

339
00:16:26,700 --> 00:16:30,300
properties that we want to meet for

340
00:16:27,750 --> 00:16:33,360
these fake passwords we want them to be

341
00:16:30,300 --> 00:16:34,680
plausible so that if an attacker were to

342
00:16:33,360 --> 00:16:36,510
crack these passwords it looks like

343
00:16:34,680 --> 00:16:41,969
something that an actual user would

344
00:16:36,510 --> 00:16:44,160
produce since we're using the weekend we

345
00:16:41,970 --> 00:16:46,070
can assume that we can use the true

346
00:16:44,160 --> 00:16:48,360
password to help generate some of these

347
00:16:46,070 --> 00:16:50,640
fake passwords we want it to be non

348
00:16:48,360 --> 00:16:52,440
deducible so if an attacker were to look

349
00:16:50,640 --> 00:16:54,660
at a fake password they should not be

350
00:16:52,440 --> 00:16:57,390
able to deduce that the true users

351
00:16:54,660 --> 00:16:59,790
passwords further it should be typo

352
00:16:57,390 --> 00:17:01,710
resilient so if an attack or if a true

353
00:16:59,790 --> 00:17:04,409
user types in their password and maybe

354
00:17:01,710 --> 00:17:07,020
miss types it the edits distance should

355
00:17:04,410 --> 00:17:11,190
be significantly far enough so that we

356
00:17:07,020 --> 00:17:13,369
don't generate false positives the crack

357
00:17:11,190 --> 00:17:17,820
ability of the passwords stored in our

358
00:17:13,369 --> 00:17:21,719
hash file should reflect reality so if

359
00:17:17,819 --> 00:17:23,040
you have you know certain percentage of

360
00:17:21,720 --> 00:17:25,199
users that you expect to have weak

361
00:17:23,040 --> 00:17:28,920
passwords the that should also be

362
00:17:25,199 --> 00:17:32,610
reflected in the way in our and our

363
00:17:28,920 --> 00:17:33,750
password file finally the the fake

364
00:17:32,610 --> 00:17:36,300
passwords that are produced should

365
00:17:33,750 --> 00:17:41,640
adhere to the same password policy

366
00:17:36,300 --> 00:17:43,169
that's out on your system there's

367
00:17:41,640 --> 00:17:45,420
several in the paper we list several

368
00:17:43,170 --> 00:17:49,440
ways of choosing this generation

369
00:17:45,420 --> 00:17:52,260
function if you want details are in the

370
00:17:49,440 --> 00:17:55,740
paper but I but the the highlight here

371
00:17:52,260 --> 00:17:57,120
is just we want to follow these these

372
00:17:55,740 --> 00:18:05,070
properties for generating the ersatz

373
00:17:57,120 --> 00:18:10,560
password our scheme has a very simple

374
00:18:05,070 --> 00:18:12,060
method of producing a backup for because

375
00:18:10,560 --> 00:18:14,370
we're since we're using this a hardware

376
00:18:12,060 --> 00:18:16,500
security module if somehow that is

377
00:18:14,370 --> 00:18:18,149
compromised or destroyed or stolen the

378
00:18:16,500 --> 00:18:21,900
keys are lost so we want a way to

379
00:18:18,150 --> 00:18:24,840
actually recover and so the scheme we're

380
00:18:21,900 --> 00:18:27,120
just using a public/private key the

381
00:18:24,840 --> 00:18:29,760
private key is never used in operation

382
00:18:27,120 --> 00:18:32,289
the stored similar may be in the vault

383
00:18:29,760 --> 00:18:34,840
during the initialization which I step

384
00:18:32,289 --> 00:18:36,970
through earlier of converting all these

385
00:18:34,840 --> 00:18:40,959
stored password hashes into these earth

386
00:18:36,970 --> 00:18:44,169
sets passwords we basically make a copy

387
00:18:40,960 --> 00:18:46,840
and put it in the backup storage and and

388
00:18:44,169 --> 00:18:49,780
we do this by encrypting it with a

389
00:18:46,840 --> 00:18:51,340
public key and then a pen and creating a

390
00:18:49,780 --> 00:18:53,080
log every time there's a change the

391
00:18:51,340 --> 00:18:59,110
password file and encrypted with a

392
00:18:53,080 --> 00:19:01,090
public key if at some point the hardware

393
00:18:59,110 --> 00:19:03,100
module fails or something gets

394
00:19:01,090 --> 00:19:05,080
compromised we can we can backtrack and

395
00:19:03,100 --> 00:19:07,418
recover that and then pretty use a new

396
00:19:05,080 --> 00:19:10,178
Harbor security module hard dependent

397
00:19:07,419 --> 00:19:18,070
function to produce to reinitialize the

398
00:19:10,179 --> 00:19:21,490
scheme so implementation details we use

399
00:19:18,070 --> 00:19:22,629
the ub HSM it's there's a picture of it

400
00:19:21,490 --> 00:19:24,190
on the right I have an older version

401
00:19:22,630 --> 00:19:27,460
it's much larger this is pretty

402
00:19:24,190 --> 00:19:30,760
inconspicuous for the harbor dependent

403
00:19:27,460 --> 00:19:33,580
function we're just using a HVAC with a

404
00:19:30,760 --> 00:19:36,039
sha-1 with the key that's stored on the

405
00:19:33,580 --> 00:19:39,220
hardware security module you could use a

406
00:19:36,039 --> 00:19:44,760
TPM or a puff physically on cloneable

407
00:19:39,220 --> 00:19:47,799
function so the implementation we did

408
00:19:44,760 --> 00:19:52,510
three separate experiments somewhat

409
00:19:47,799 --> 00:19:54,520
related we first implemented the earth

410
00:19:52,510 --> 00:19:56,408
sites password scheme on a pan UNIX

411
00:19:54,520 --> 00:20:00,220
module which is the authentication

412
00:19:56,409 --> 00:20:03,760
module on on unix-like systems we did

413
00:20:00,220 --> 00:20:05,320
this on a freebsd operating system we

414
00:20:03,760 --> 00:20:06,820
also integrated or the earth sets

415
00:20:05,320 --> 00:20:09,939
password scheme on the lightweight

416
00:20:06,820 --> 00:20:14,200
directory access control protocol ldap

417
00:20:09,940 --> 00:20:17,830
for short with a linux client server

418
00:20:14,200 --> 00:20:20,230
model and we also looked at the Pythia

419
00:20:17,830 --> 00:20:24,340
prf service which was a paper published

420
00:20:20,230 --> 00:20:29,919
in use next 2015 all the code is

421
00:20:24,340 --> 00:20:33,240
available on github and kind of the the

422
00:20:29,919 --> 00:20:36,669
rationale for choosing these three

423
00:20:33,240 --> 00:20:38,770
authentication schemes so we wanted to

424
00:20:36,669 --> 00:20:40,179
show and demonstrate the flexibility of

425
00:20:38,770 --> 00:20:42,290
there's that's password scheme we're

426
00:20:40,179 --> 00:20:44,900
making a claim that it's not a

427
00:20:42,290 --> 00:20:46,850
terribly complicated in that integrating

428
00:20:44,900 --> 00:20:50,480
these on this existing authentication

429
00:20:46,850 --> 00:20:51,980
systems is not too much work so I'll

430
00:20:50,480 --> 00:20:58,880
talk about some of the performance

431
00:20:51,980 --> 00:21:02,470
details here so this is for the Pam unix

432
00:20:58,880 --> 00:21:07,300
module for the setup we used a sha-512

433
00:21:02,470 --> 00:21:10,820
hashing this is the H around all the the

434
00:21:07,300 --> 00:21:13,940
HSM me back up I should have actually

435
00:21:10,820 --> 00:21:16,370
put a picture there so this is the H

436
00:21:13,940 --> 00:21:19,190
that produces the hash at the very am on

437
00:21:16,370 --> 00:21:23,110
the on the beta step the second to last

438
00:21:19,190 --> 00:21:23,110
step oops

439
00:21:29,500 --> 00:21:34,309
for the Earth's that's password

440
00:21:32,150 --> 00:21:36,200
generation function we just randomly

441
00:21:34,309 --> 00:21:38,750
selected a six character dictionary word

442
00:21:36,200 --> 00:21:40,100
i actually just went on looked up the

443
00:21:38,750 --> 00:21:43,100
official scrabble dictionary you found

444
00:21:40,100 --> 00:21:46,520
all the six character length words this

445
00:21:43,100 --> 00:21:49,250
is the idea here is to kind of produce

446
00:21:46,520 --> 00:21:52,129
something that's crackable we use the

447
00:21:49,250 --> 00:21:53,300
fix password of six characters for our

448
00:21:52,130 --> 00:21:57,110
experiments so we fix all these

449
00:21:53,300 --> 00:21:59,360
parameters and ran it through a thousand

450
00:21:57,110 --> 00:22:04,070
times and produce the this link this

451
00:21:59,360 --> 00:22:07,280
latency plot so it's actually quite

452
00:22:04,070 --> 00:22:10,159
there's quite a big overhead here the

453
00:22:07,280 --> 00:22:14,690
baseline which is the pam unix module

454
00:22:10,160 --> 00:22:17,600
without their it sets mechanism it's

455
00:22:14,690 --> 00:22:20,780
about on average about four point five

456
00:22:17,600 --> 00:22:24,219
point four milliseconds our scheme is

457
00:22:20,780 --> 00:22:27,620
quite a bit more than that it's a about

458
00:22:24,220 --> 00:22:30,260
280 milliseconds on average in the

459
00:22:27,620 --> 00:22:32,389
distributions don't vary too much from

460
00:22:30,260 --> 00:22:39,350
using detecting the true pastured versus

461
00:22:32,390 --> 00:22:43,520
detecting errors that's password for the

462
00:22:39,350 --> 00:22:45,919
ldap scheme the setup is we we wanted to

463
00:22:43,520 --> 00:22:50,210
just measure the latency caused by their

464
00:22:45,920 --> 00:22:52,309
it sets mechanism so our user or client

465
00:22:50,210 --> 00:22:55,370
user network was all done on a local

466
00:22:52,309 --> 00:22:58,190
area network so little overhead from

467
00:22:55,370 --> 00:22:59,689
networking latency and we did no channel

468
00:22:58,190 --> 00:23:06,040
encryption so we're just looking at

469
00:22:59,690 --> 00:23:11,540
specifically their SATs leniency again

470
00:23:06,040 --> 00:23:13,700
it's about two to three times slower by

471
00:23:11,540 --> 00:23:15,710
producing our scheme it's a little bit

472
00:23:13,700 --> 00:23:21,500
better than what we had in the pan UNIX

473
00:23:15,710 --> 00:23:24,770
module the the median for the true and

474
00:23:21,500 --> 00:23:29,660
Earth sets password was about point nine

475
00:23:24,770 --> 00:23:34,070
seconds point eight seconds while the

476
00:23:29,660 --> 00:23:36,580
baseline was about point three so the

477
00:23:34,070 --> 00:23:40,100
Pythia PRF service we've looked at this

478
00:23:36,580 --> 00:23:41,570
at this paper we found some it was

479
00:23:40,100 --> 00:23:44,540
really interesting

480
00:23:41,570 --> 00:23:47,929
method that they proposed where they use

481
00:23:44,540 --> 00:23:50,510
partially oblivious funct a function to

482
00:23:47,930 --> 00:23:53,000
to basically split up how the password

483
00:23:50,510 --> 00:23:54,920
is stored and there they produce the

484
00:23:53,000 --> 00:23:58,670
mechanism to rotate the keys in a very

485
00:23:54,920 --> 00:24:00,320
clever way what and we integrated our

486
00:23:58,670 --> 00:24:03,980
Earth's at scheme into this and what's

487
00:24:00,320 --> 00:24:06,200
nice is their scheme allows for quick

488
00:24:03,980 --> 00:24:08,630
rotation if something is compromised and

489
00:24:06,200 --> 00:24:11,210
our earthside scheme allows a mechanism

490
00:24:08,630 --> 00:24:12,590
to detect if something is compromised so

491
00:24:11,210 --> 00:24:14,330
we downloaded their source and

492
00:24:12,590 --> 00:24:16,370
integrated the earth set scheme into

493
00:24:14,330 --> 00:24:21,470
their system and produce these

494
00:24:16,370 --> 00:24:25,189
performance Layton sees again quite a

495
00:24:21,470 --> 00:24:28,430
bit of an overhead but it's really up to

496
00:24:25,190 --> 00:24:31,220
our the use case this if if this latency

497
00:24:28,430 --> 00:24:35,870
is is justified to increase a little bit

498
00:24:31,220 --> 00:24:39,500
of the security of the system some of

499
00:24:35,870 --> 00:24:41,300
the details about the code there's

500
00:24:39,500 --> 00:24:44,420
really two libraries written one and see

501
00:24:41,300 --> 00:24:46,940
and one in Python the C library was used

502
00:24:44,420 --> 00:24:50,330
for the Pam UNIX experiment and the ldap

503
00:24:46,940 --> 00:24:53,210
experiment about 250 lines of code for

504
00:24:50,330 --> 00:24:54,949
the Pythia prf service where the the

505
00:24:53,210 --> 00:25:00,230
Python library was about a hundred lines

506
00:24:54,950 --> 00:25:02,840
code the difference between and so this

507
00:25:00,230 --> 00:25:04,250
this library kinda produces all the core

508
00:25:02,840 --> 00:25:08,379
functionality for the Earth's hats

509
00:25:04,250 --> 00:25:11,600
password scheme and the the figure below

510
00:25:08,380 --> 00:25:13,310
just detail some of the integration that

511
00:25:11,600 --> 00:25:14,719
needed some of the code needed that

512
00:25:13,310 --> 00:25:19,159
needed to be changed to integrate into

513
00:25:14,720 --> 00:25:22,660
these systems between 30 lines of code

514
00:25:19,160 --> 00:25:30,440
260 lines of code depending on the on

515
00:25:22,660 --> 00:25:31,610
the scheme that we're integrating in the

516
00:25:30,440 --> 00:25:33,260
paper we talked a little bit of the

517
00:25:31,610 --> 00:25:37,129
details how this could be used on it on

518
00:25:33,260 --> 00:25:39,680
the TPM rather than HSM it's it's

519
00:25:37,130 --> 00:25:42,260
basically the same steps initializing

520
00:25:39,680 --> 00:25:45,830
the the TPM storing some creating some

521
00:25:42,260 --> 00:25:48,500
key to be for the H Mac to use creating

522
00:25:45,830 --> 00:25:51,199
a handle to the key and just using that

523
00:25:48,500 --> 00:25:54,190
handle any time we want to produce say a

524
00:25:51,200 --> 00:25:56,919
hash and verifying

525
00:25:54,190 --> 00:25:59,320
authenticating the user one of the

526
00:25:56,919 --> 00:26:01,960
weaknesses here is though similar to the

527
00:25:59,320 --> 00:26:04,000
HSM scheme if the if the the TPM

528
00:26:01,960 --> 00:26:05,409
password is compromised and they can an

529
00:26:04,000 --> 00:26:13,570
attacker can potentially wipe all the

530
00:26:05,409 --> 00:26:19,179
keys on the TPM so that's about it any

531
00:26:13,570 --> 00:26:20,559
questions you explain it well but I just

532
00:26:19,179 --> 00:26:24,009
already say it back to make sure I got

533
00:26:20,559 --> 00:26:27,460
it okay so you're generating Curt sets

534
00:26:24,009 --> 00:26:32,019
passwords randomly across users all

535
00:26:27,460 --> 00:26:35,370
right and then when someone logs in with

536
00:26:32,019 --> 00:26:37,269
a hack password it's not an ersatz

537
00:26:35,370 --> 00:26:40,689
substitution where there should be one

538
00:26:37,269 --> 00:26:42,669
it detects that and then it triggers an

539
00:26:40,690 --> 00:26:43,870
alarm and say hey someone is not here

540
00:26:42,669 --> 00:26:46,659
the chance someone's here that shouldn't

541
00:26:43,870 --> 00:26:48,250
be and then usually what happens with

542
00:26:46,659 --> 00:26:52,029
that alarm who sees it how does it

543
00:26:48,250 --> 00:26:53,470
reacted too yeah so the policy around

544
00:26:52,029 --> 00:26:58,360
there it's at skiing we kind of left it

545
00:26:53,470 --> 00:26:59,710
up to the the practitioner right now the

546
00:26:58,360 --> 00:27:04,029
actual implementation just generates

547
00:26:59,710 --> 00:27:06,039
this but just a lot panic just a message

548
00:27:04,029 --> 00:27:07,690
that comes up but if you download the

549
00:27:06,039 --> 00:27:09,629
code and you want to actually run this

550
00:27:07,690 --> 00:27:13,389
Stefan on a real system you can just

551
00:27:09,629 --> 00:27:15,189
basically change out the the panic

552
00:27:13,389 --> 00:27:17,769
message to whatever you want it to do

553
00:27:15,190 --> 00:27:22,679
notify and system administrator walk the

554
00:27:17,769 --> 00:27:25,990
account whatever policy you really want

555
00:27:22,679 --> 00:27:28,929
so the Yubikey is sitting on a server

556
00:27:25,990 --> 00:27:30,639
that's right okay yeah actually one of

557
00:27:28,929 --> 00:27:32,889
the the future work that we want to look

558
00:27:30,639 --> 00:27:36,758
at so on the ldap scheme we're requiring

559
00:27:32,889 --> 00:27:37,959
the user to touch the ldap server every

560
00:27:36,759 --> 00:27:41,440
time they want to authenticate in

561
00:27:37,960 --> 00:27:43,360
reality the way this works is the first

562
00:27:41,440 --> 00:27:47,830
time you log in you communicate with the

563
00:27:43,360 --> 00:27:49,449
ldap server they send basically a hash

564
00:27:47,830 --> 00:27:51,460
of the password it depends on the

565
00:27:49,450 --> 00:27:53,649
details of the scheme because it's kind

566
00:27:51,460 --> 00:27:55,480
of up to have the system administrator

567
00:27:53,649 --> 00:27:58,600
wants to use it but nonetheless there's

568
00:27:55,480 --> 00:28:01,330
a caching mechanism that rather than

569
00:27:58,600 --> 00:28:03,490
having the user often communicate with

570
00:28:01,330 --> 00:28:06,279
the ldap server every single time they

571
00:28:03,490 --> 00:28:07,389
store the the credentials on on the

572
00:28:06,279 --> 00:28:09,519
system locally so the

573
00:28:07,389 --> 00:28:11,859
have to touch communicate with the ldap

574
00:28:09,519 --> 00:28:13,829
server there's a challenge there with

575
00:28:11,859 --> 00:28:16,178
producing these certs that's passwords

576
00:28:13,829 --> 00:28:22,599
so we want to look at that in future

577
00:28:16,179 --> 00:28:24,549
work on the one because see what you

578
00:28:22,599 --> 00:28:28,059
have to do you'd have to cash you'd have

579
00:28:24,549 --> 00:28:29,529
to produce the actual hash which is

580
00:28:28,059 --> 00:28:31,329
exactly what you're trying to protect

581
00:28:29,529 --> 00:28:34,599
from being disclosed that's exactly

582
00:28:31,329 --> 00:28:37,119
right but at least it it wouldn't be it

583
00:28:34,599 --> 00:28:39,458
would be just the few users just the

584
00:28:37,119 --> 00:28:40,658
cash you wouldn't get the whole file so

585
00:28:39,459 --> 00:28:42,759
you wouldn't be able to that's exactly

586
00:28:40,659 --> 00:28:47,889
right it's though it still reduces the

587
00:28:42,759 --> 00:28:49,929
tax base yeah but if you were to and in

588
00:28:47,889 --> 00:28:52,299
the paper we detail some some mechanisms

589
00:28:49,929 --> 00:28:53,709
to kind of fall back on right if you

590
00:28:52,299 --> 00:28:55,599
just send them the hash of the of the

591
00:28:53,709 --> 00:28:58,119
real user password it we're back to

592
00:28:55,599 --> 00:28:59,649
where our security scheme was before we

593
00:28:58,119 --> 00:29:04,119
introduce ourselves password so it's no

594
00:28:59,649 --> 00:29:05,559
better or no worse than before you can

595
00:29:04,119 --> 00:29:08,139
come up with something clever if you're

596
00:29:05,559 --> 00:29:11,678
able to do some attestation maybe

597
00:29:08,139 --> 00:29:13,418
there's a TPM on on the say your laptop

598
00:29:11,679 --> 00:29:15,999
and some mobile device that doesn't have

599
00:29:13,419 --> 00:29:19,749
internet access all the time to do some

600
00:29:15,999 --> 00:29:22,239
kind of communication to do the dirts at

601
00:29:19,749 --> 00:29:23,409
scheme locally on the on the cash but

602
00:29:22,239 --> 00:29:30,789
some of those details need to be worked

603
00:29:23,409 --> 00:29:34,239
out I have another question yeah did you

604
00:29:30,789 --> 00:29:36,609
do any measurements of the you know this

605
00:29:34,239 --> 00:29:38,739
this extra time is that all in that

606
00:29:36,609 --> 00:29:40,869
hardware security module oh yeah edge of

607
00:29:38,739 --> 00:29:42,820
it yeah we were able to measure the

608
00:29:40,869 --> 00:29:44,799
actual time spent there yeah we did we

609
00:29:42,820 --> 00:29:49,450
it's detailed in the paper I can talk

610
00:29:44,799 --> 00:29:52,209
about it so the the the the programming

611
00:29:49,450 --> 00:29:54,219
interface that you beko provided was

612
00:29:52,209 --> 00:29:56,379
written in Python so we saw a huge

613
00:29:54,219 --> 00:29:59,979
latency overhead because we had a at one

614
00:29:56,379 --> 00:30:02,589
point in our C code for the the pan unix

615
00:29:59,979 --> 00:30:05,829
module we had to stop everything switch

616
00:30:02,589 --> 00:30:09,009
to a switch over to python code run the

617
00:30:05,829 --> 00:30:10,658
api's get the output and then switch

618
00:30:09,009 --> 00:30:12,609
back and that caused a lot of overhead

619
00:30:10,659 --> 00:30:14,169
when we ran through our analysis so

620
00:30:12,609 --> 00:30:16,418
that's why the Python was faster that's

621
00:30:14,169 --> 00:30:17,499
right that's right which is in counter

622
00:30:16,419 --> 00:30:19,389
intuitive right you would think the C

623
00:30:17,499 --> 00:30:20,650
code would be faster and also this

624
00:30:19,389 --> 00:30:24,610
device is communicating

625
00:30:20,650 --> 00:30:26,950
USB if there was a hardware

626
00:30:24,610 --> 00:30:29,080
implementation may be on the actual bus

627
00:30:26,950 --> 00:30:32,380
or like on the the motherboard it might

628
00:30:29,080 --> 00:30:35,020
be faster one thing to note is we didn't

629
00:30:32,380 --> 00:30:36,940
code this up for up to be the most

630
00:30:35,020 --> 00:30:38,710
optimal solution there could be some

631
00:30:36,940 --> 00:30:42,340
speed up if if you were to rewrite the

632
00:30:38,710 --> 00:30:44,020
the api's for in native see then I

633
00:30:42,340 --> 00:30:45,399
imagine it would be much faster you

634
00:30:44,020 --> 00:30:56,010
wouldn't have that overhead of switching

635
00:30:45,400 --> 00:30:56,010
between C and Python any other questions

636
00:30:59,100 --> 00:31:12,510
thanks for listening preciate your seven

637
00:32:07,040 --> 00:32:09,100
you

