1
00:00:16,340 --> 00:00:22,710
our next technical talk is another

2
00:00:19,500 --> 00:00:25,349
serious student Daniel mini who is in

3
00:00:22,710 --> 00:00:29,250
computer science and is a PhD candidate

4
00:00:25,349 --> 00:00:30,750
here Daniel thank you very much so good

5
00:00:29,250 --> 00:00:32,430
afternoon everybody thanks for being

6
00:00:30,750 --> 00:00:35,909
here and thanks to the oldest serious

7
00:00:32,430 --> 00:00:38,610
organization to for for hosting me my

8
00:00:35,909 --> 00:00:41,720
name is Daniel immedi I'm a PhD student

9
00:00:38,610 --> 00:00:44,399
at work with Professor bertino on

10
00:00:41,720 --> 00:00:46,680
security techniques for sensor systems

11
00:00:44,399 --> 00:00:48,420
and the Internet of Things for the

12
00:00:46,680 --> 00:00:51,030
particular work that I want to present

13
00:00:48,420 --> 00:00:53,399
today I work with the professor payer as

14
00:00:51,030 --> 00:00:55,440
well one of the new additions to the to

15
00:00:53,399 --> 00:00:57,030
the cs department very very welcome and

16
00:00:55,440 --> 00:01:02,099
very appreciated and he was in one of

17
00:00:57,030 --> 00:01:04,019
the panels earlier so what I'm going to

18
00:01:02,100 --> 00:01:05,970
talk about today is a project called

19
00:01:04,019 --> 00:01:09,479
NASA check that deals with with memory

20
00:01:05,970 --> 00:01:11,220
safety so ubiquitous computing and the

21
00:01:09,479 --> 00:01:12,810
panel right now was really interesting

22
00:01:11,220 --> 00:01:15,300
for this purpose is now is now

23
00:01:12,810 --> 00:01:18,030
definitely a reality of it wireless

24
00:01:15,300 --> 00:01:22,830
sensor networks has have been around for

25
00:01:18,030 --> 00:01:24,660
quite a long time now and all those all

26
00:01:22,830 --> 00:01:26,459
the sensors are really really wet spread

27
00:01:24,660 --> 00:01:28,080
for a variety of reasons I mean they're

28
00:01:26,459 --> 00:01:30,539
small and cheap and so you can find them

29
00:01:28,080 --> 00:01:32,970
they found a good purpose for

30
00:01:30,539 --> 00:01:35,250
thermostats industrial settings

31
00:01:32,970 --> 00:01:37,050
precision agriculture the agriculture

32
00:01:35,250 --> 00:01:39,330
department here at Purdue has a lot of

33
00:01:37,050 --> 00:01:41,729
actual good uses for those for the

34
00:01:39,330 --> 00:01:44,280
sensors to monitor the comp the soil

35
00:01:41,729 --> 00:01:46,470
composition the humidity the the light

36
00:01:44,280 --> 00:01:49,890
and the temperature so they have a

37
00:01:46,470 --> 00:01:52,050
really wide variety of usages and the

38
00:01:49,890 --> 00:01:55,289
Internet of Things as a generalization

39
00:01:52,050 --> 00:01:59,819
of it is really really picking up pace

40
00:01:55,289 --> 00:02:02,520
right now and with all those small

41
00:01:59,819 --> 00:02:05,759
systems there are however in some cases

42
00:02:02,520 --> 00:02:07,560
quite powerful and always on and

43
00:02:05,759 --> 00:02:10,259
connected to the internet security

44
00:02:07,560 --> 00:02:13,440
becomes really really paramount and a

45
00:02:10,258 --> 00:02:16,129
lot of you know policy side of it have

46
00:02:13,440 --> 00:02:20,340
been discussed in the panel just now

47
00:02:16,129 --> 00:02:22,440
however from the system perspective like

48
00:02:20,340 --> 00:02:24,870
concretely some of the requirements that

49
00:02:22,440 --> 00:02:26,900
are really important are having

50
00:02:24,870 --> 00:02:29,880
reliability for the system and the end

51
00:02:26,900 --> 00:02:31,680
in whatever way you want to achieve this

52
00:02:29,880 --> 00:02:34,019
having data delivery that is actually

53
00:02:31,680 --> 00:02:35,670
trustworthy and you know data actually

54
00:02:34,020 --> 00:02:37,380
gets to the destination and tampered

55
00:02:35,670 --> 00:02:39,750
with and with all the correct

56
00:02:37,380 --> 00:02:42,450
measurements and that the service in

57
00:02:39,750 --> 00:02:47,070
this case has to be available as much as

58
00:02:42,450 --> 00:02:48,450
possible for the whole time and this

59
00:02:47,070 --> 00:02:49,950
particular work with focus on wireless

60
00:02:48,450 --> 00:02:51,299
sensor networks so we'll see that we're

61
00:02:49,950 --> 00:02:55,549
talking about sensors that are

62
00:02:51,300 --> 00:02:58,860
significantly smaller less powerful and

63
00:02:55,550 --> 00:03:02,250
and with way way more like strangers

64
00:02:58,860 --> 00:03:03,570
stringent constraints so why is this

65
00:03:02,250 --> 00:03:05,340
area where I have to be functional all

66
00:03:03,570 --> 00:03:06,630
times however they have a lot of a lot

67
00:03:05,340 --> 00:03:09,300
of problems in trying to achieve

68
00:03:06,630 --> 00:03:11,940
security they communicate on an

69
00:03:09,300 --> 00:03:14,160
unreliable wireless medium they have

70
00:03:11,940 --> 00:03:15,810
constrained resources and they usually

71
00:03:14,160 --> 00:03:18,510
operate in an attendant environment so

72
00:03:15,810 --> 00:03:20,700
those sensors are just deployed with no

73
00:03:18,510 --> 00:03:23,280
temper proof packaging and anybody can

74
00:03:20,700 --> 00:03:26,450
steal an old reverse engineer actually

75
00:03:23,280 --> 00:03:29,130
analyze it so this can easily lead to

76
00:03:26,450 --> 00:03:31,140
failures that are both transient and so

77
00:03:29,130 --> 00:03:32,700
you know they disrupt the service for a

78
00:03:31,140 --> 00:03:36,089
little while or even permanent and they

79
00:03:32,700 --> 00:03:37,440
can cause a real damage some of the

80
00:03:36,090 --> 00:03:40,710
security threats of this of this

81
00:03:37,440 --> 00:03:43,800
connected world what a sensor networks

82
00:03:40,710 --> 00:03:45,720
are susceptible to attacks in a lot of

83
00:03:43,800 --> 00:03:48,200
different from a lot of different entry

84
00:03:45,720 --> 00:03:51,540
points so packets and network traffic

85
00:03:48,200 --> 00:03:55,709
device resources actual network routing

86
00:03:51,540 --> 00:03:57,870
and while you can think that attacking a

87
00:03:55,710 --> 00:04:01,530
deployment for example for agriculture

88
00:03:57,870 --> 00:04:04,220
might not make many many victims apart

89
00:04:01,530 --> 00:04:05,970
from some economical interests well

90
00:04:04,220 --> 00:04:07,950
earlier we were just talking about

91
00:04:05,970 --> 00:04:10,340
hacking pacemakers and so there's

92
00:04:07,950 --> 00:04:14,760
actually a lot of possibilities to do

93
00:04:10,340 --> 00:04:17,670
real harm to people safety so if you're

94
00:04:14,760 --> 00:04:19,589
if you are automating and using sensors

95
00:04:17,670 --> 00:04:21,959
for for a hospital you can give a

96
00:04:19,589 --> 00:04:24,900
patient the wrong treatment with a you

97
00:04:21,959 --> 00:04:26,910
know security breach in the in a smart

98
00:04:24,900 --> 00:04:29,849
city a lot of those sensors for example

99
00:04:26,910 --> 00:04:32,250
control traffic lights and if you have a

100
00:04:29,850 --> 00:04:35,670
wide area blackout well the consequences

101
00:04:32,250 --> 00:04:38,070
can be can be pretty bad so for what a

102
00:04:35,670 --> 00:04:40,350
sensor networks a really widespread

103
00:04:38,070 --> 00:04:41,729
operating system that is you want to be

104
00:04:40,350 --> 00:04:43,710
working on for this project is called

105
00:04:41,729 --> 00:04:46,020
tan us and

106
00:04:43,710 --> 00:04:49,169
those applications are often critical

107
00:04:46,020 --> 00:04:51,630
but as we said achieving the the big

108
00:04:49,170 --> 00:04:54,590
three of security reliability integrity

109
00:04:51,630 --> 00:04:57,420
and availability is it's really hard and

110
00:04:54,590 --> 00:05:00,090
10 us is this the sensor network that

111
00:04:57,420 --> 00:05:02,790
tried to make it says the sensor network

112
00:05:00,090 --> 00:05:04,349
operating system they try to make sensor

113
00:05:02,790 --> 00:05:08,820
network development as easy as possible

114
00:05:04,350 --> 00:05:10,080
and it is all those applications are

115
00:05:08,820 --> 00:05:12,030
developed in languages there are

116
00:05:10,080 --> 00:05:14,849
low-level languages so we're talking

117
00:05:12,030 --> 00:05:17,750
about C or other dialects of see those

118
00:05:14,850 --> 00:05:20,700
languages have no memory protection and

119
00:05:17,750 --> 00:05:22,200
whoever has written any single even

120
00:05:20,700 --> 00:05:24,270
small piece of code in C knows that it

121
00:05:22,200 --> 00:05:25,890
makes it actually you know it makes it

122
00:05:24,270 --> 00:05:28,049
really easy for you to write code that

123
00:05:25,890 --> 00:05:33,570
will have will have memory memory

124
00:05:28,050 --> 00:05:35,310
problems now I want to bring everybody

125
00:05:33,570 --> 00:05:38,219
up to speed on memory vulnerabilities

126
00:05:35,310 --> 00:05:40,920
which will be the focus of this work in

127
00:05:38,220 --> 00:05:43,140
my talk I'll just give a really quick

128
00:05:40,920 --> 00:05:46,200
introduction on a couple of attacks that

129
00:05:43,140 --> 00:05:49,860
can happen at the memory level so the

130
00:05:46,200 --> 00:05:53,210
outcome of a memory corruption can have

131
00:05:49,860 --> 00:05:55,680
a various like a wide range of outcomes

132
00:05:53,210 --> 00:05:58,739
the nodes those little sensor nodes can

133
00:05:55,680 --> 00:06:01,560
just crash or reboot and no big deal is

134
00:05:58,740 --> 00:06:04,380
just a transient failure you can start

135
00:06:01,560 --> 00:06:05,730
actually processing and disseminating

136
00:06:04,380 --> 00:06:07,980
incorrect data so if you're trying to

137
00:06:05,730 --> 00:06:11,040
measure the temperature of the soil in a

138
00:06:07,980 --> 00:06:13,500
huge crop for example you can start

139
00:06:11,040 --> 00:06:16,860
making serious business decisions based

140
00:06:13,500 --> 00:06:18,690
on data is completely skewed and slowly

141
00:06:16,860 --> 00:06:20,370
degrading the functionality of your

142
00:06:18,690 --> 00:06:23,040
network up until it's actually not

143
00:06:20,370 --> 00:06:26,760
really useful anymore but it can get

144
00:06:23,040 --> 00:06:28,820
much worse so what the what the problem

145
00:06:26,760 --> 00:06:33,090
is with memory vulnerability is that

146
00:06:28,820 --> 00:06:35,810
it's what easy to get to the point of

147
00:06:33,090 --> 00:06:38,010
having those sensors execute arbitrary

148
00:06:35,810 --> 00:06:40,530
malicious pieces of code that somebody

149
00:06:38,010 --> 00:06:43,020
can try and inject in otherwise benign

150
00:06:40,530 --> 00:06:44,460
software and there's a couple of

151
00:06:43,020 --> 00:06:46,830
different ways more than what I'm

152
00:06:44,460 --> 00:06:48,750
listing here to do this in general the

153
00:06:46,830 --> 00:06:50,909
code injections attack the code

154
00:06:48,750 --> 00:06:53,330
injection attacks or other techniques

155
00:06:50,910 --> 00:06:55,890
are return oriented programming your

156
00:06:53,330 --> 00:06:57,568
reshuffling pieces of existing code in

157
00:06:55,890 --> 00:06:59,369
order to make a program do

158
00:06:57,569 --> 00:07:02,389
what you wanted to do and know what the

159
00:06:59,369 --> 00:07:05,219
original programmer intended for it and

160
00:07:02,389 --> 00:07:08,249
so in the news there have been a lot of

161
00:07:05,219 --> 00:07:10,020
a lot of actual concrete incidents in

162
00:07:08,249 --> 00:07:13,439
which you know memory memory corruption

163
00:07:10,020 --> 00:07:16,619
attacks have led to a lot of a lot of

164
00:07:13,439 --> 00:07:18,599
problems and I was going to mention the

165
00:07:16,619 --> 00:07:20,459
the pacemaker again but you know it was

166
00:07:18,599 --> 00:07:24,270
preceded by the panel already on that

167
00:07:20,459 --> 00:07:25,919
but that was a very serious incident one

168
00:07:24,270 --> 00:07:27,979
that I thought it was really funny when

169
00:07:25,919 --> 00:07:32,369
it came out and more related to the IOT

170
00:07:27,979 --> 00:07:35,128
last year a smart refrigerator was found

171
00:07:32,369 --> 00:07:37,919
sending spam emails was was a spam

172
00:07:35,129 --> 00:07:40,469
server for for some malicious attacker

173
00:07:37,919 --> 00:07:42,359
and so they found analyzing the traffic

174
00:07:40,469 --> 00:07:44,189
that the refrigerator in somebody's

175
00:07:42,360 --> 00:07:46,669
house was actually spamming other people

176
00:07:44,189 --> 00:07:49,199
which I thought it was pretty hilarious

177
00:07:46,669 --> 00:07:50,849
and so in general you know having

178
00:07:49,199 --> 00:07:52,319
appropriate measures to protect the

179
00:07:50,849 --> 00:07:55,889
functionality of wireless sensor network

180
00:07:52,319 --> 00:07:58,889
becomes really paramount now to see what

181
00:07:55,889 --> 00:08:01,529
what a memory vulnerability actually is

182
00:07:58,889 --> 00:08:04,199
from the technical point of view and you

183
00:08:01,529 --> 00:08:07,169
know technical people please bear with

184
00:08:04,199 --> 00:08:08,519
me for a couple of minutes um let's look

185
00:08:07,169 --> 00:08:10,409
at what it what a buffer will flow is

186
00:08:08,519 --> 00:08:13,559
one of the basic types of memory memory

187
00:08:10,409 --> 00:08:15,869
attacks a memory corruption how it works

188
00:08:13,559 --> 00:08:17,479
so for this simple example what I want

189
00:08:15,869 --> 00:08:19,559
to what I want to do is to go through

190
00:08:17,479 --> 00:08:20,998
I'm assuming that I try to register

191
00:08:19,559 --> 00:08:22,709
through the serious symposium and I'm

192
00:08:20,999 --> 00:08:24,680
playing with a with a little kiosk to

193
00:08:22,709 --> 00:08:26,789
you in order to go go ahead and register

194
00:08:24,680 --> 00:08:28,259
in the top part of the screen I'm going

195
00:08:26,789 --> 00:08:30,688
to show what's the interface that I

196
00:08:28,259 --> 00:08:32,188
interact with and in the bottom I try

197
00:08:30,689 --> 00:08:33,839
you know little zeros and one so that's

198
00:08:32,188 --> 00:08:36,779
that's supposed to be a kind of a

199
00:08:33,839 --> 00:08:39,539
simplistic vision of what the the memory

200
00:08:36,779 --> 00:08:41,370
of the devices at that state so we have

201
00:08:39,539 --> 00:08:43,500
a couple fields although all the data is

202
00:08:41,370 --> 00:08:46,110
stored in fields in the memory and the

203
00:08:43,500 --> 00:08:47,970
programmer has to choose at the very

204
00:08:46,110 --> 00:08:50,550
beginning how big those fields are those

205
00:08:47,970 --> 00:08:52,740
fields are so you know you can be on the

206
00:08:50,550 --> 00:08:54,269
safe side and say that to store the full

207
00:08:52,740 --> 00:08:57,720
name of somebody that is registering

208
00:08:54,269 --> 00:09:00,630
maybe a hundred characters will do some

209
00:08:57,720 --> 00:09:02,220
you know foreign language names will

210
00:09:00,630 --> 00:09:04,800
disagree with that but you know you can

211
00:09:02,220 --> 00:09:06,449
you can never be too safe anyway in this

212
00:09:04,800 --> 00:09:08,099
case we have a field for the full name

213
00:09:06,449 --> 00:09:10,769
and a feel for the age and in memory

214
00:09:08,100 --> 00:09:11,100
they often happen to be one next to the

215
00:09:10,769 --> 00:09:15,240
other

216
00:09:11,100 --> 00:09:17,580
so what happens is the disc is is

217
00:09:15,240 --> 00:09:19,950
letting me register and it tells me that

218
00:09:17,580 --> 00:09:22,140
if I'm 21 years old or younger I can get

219
00:09:19,950 --> 00:09:24,420
in for free so the first thing that I

220
00:09:22,140 --> 00:09:26,819
asked me is to swipe my ID in the kiosk

221
00:09:24,420 --> 00:09:30,030
and so I do that and it reads my age and

222
00:09:26,820 --> 00:09:32,130
it reads that my edge is 27 and it puts

223
00:09:30,030 --> 00:09:34,530
that in the little H field in memory and

224
00:09:32,130 --> 00:09:37,020
then he tells me please enter your name

225
00:09:34,530 --> 00:09:40,560
in the little text box so I put in my

226
00:09:37,020 --> 00:09:42,569
full name I press ENTER and in memory

227
00:09:40,560 --> 00:09:45,839
that information is actually copied in

228
00:09:42,570 --> 00:09:48,750
there and well not very surprisingly

229
00:09:45,840 --> 00:09:50,340
well the total that I yo is not free I

230
00:09:48,750 --> 00:09:54,270
have to pay let's say ten dollars for

231
00:09:50,340 --> 00:09:57,990
this now if I am a security researcher

232
00:09:54,270 --> 00:10:00,060
and a bit of a freeloader then I might

233
00:09:57,990 --> 00:10:02,550
want to try and circumvent the system to

234
00:10:00,060 --> 00:10:05,310
try and get in for free anyway so what I

235
00:10:02,550 --> 00:10:08,880
do is I like that's fine let's start

236
00:10:05,310 --> 00:10:11,579
over I go ahead and swap my ID again my

237
00:10:08,880 --> 00:10:14,340
age hasn't changed I have an age since

238
00:10:11,580 --> 00:10:17,610
the first time I swiped likely and when

239
00:10:14,340 --> 00:10:21,060
it tells me to input my name well what I

240
00:10:17,610 --> 00:10:23,550
do is to put in a really really long

241
00:10:21,060 --> 00:10:25,859
string well crafted so that i can try

242
00:10:23,550 --> 00:10:28,170
and circumvent the system and to see if

243
00:10:25,860 --> 00:10:29,850
those programmers are for this kiosk

244
00:10:28,170 --> 00:10:33,420
actually thought that somebody might try

245
00:10:29,850 --> 00:10:35,130
to to play them when i press enter this

246
00:10:33,420 --> 00:10:37,740
information will be copied in the full

247
00:10:35,130 --> 00:10:40,260
name field and unfortunately will be so

248
00:10:37,740 --> 00:10:42,360
long that it goes up over the boundaries

249
00:10:40,260 --> 00:10:45,330
of the field and it spills over the next

250
00:10:42,360 --> 00:10:47,160
field so what I did is providing a

251
00:10:45,330 --> 00:10:49,950
string and just interacting with the

252
00:10:47,160 --> 00:10:51,930
system I was able to alter the memory so

253
00:10:49,950 --> 00:10:54,930
that some other information has been

254
00:10:51,930 --> 00:10:56,760
tampered with the kiosk developer

255
00:10:54,930 --> 00:10:58,560
thought that will really smart people

256
00:10:56,760 --> 00:11:00,150
have to swipe the ID and they will never

257
00:10:58,560 --> 00:11:02,849
be able to you know circumvent the

258
00:11:00,150 --> 00:11:05,449
system but now i owe them zero dollars

259
00:11:02,850 --> 00:11:08,430
and i can get it to the symposium so

260
00:11:05,450 --> 00:11:10,320
this is some sort of simplistic you know

261
00:11:08,430 --> 00:11:14,729
example of how a buffer overflow works

262
00:11:10,320 --> 00:11:16,950
and you may think that you know serious

263
00:11:14,730 --> 00:11:19,290
without those ten dollars hopefully will

264
00:11:16,950 --> 00:11:23,310
now go bankrupt unless everybody starts

265
00:11:19,290 --> 00:11:24,899
doing it however how this translates to

266
00:11:23,310 --> 00:11:28,498
actual code and how it works

267
00:11:24,899 --> 00:11:30,119
is that usually in memory there's fields

268
00:11:28,499 --> 00:11:32,009
for data and there's fields of support

269
00:11:30,119 --> 00:11:34,970
for control flow to decide what the next

270
00:11:32,009 --> 00:11:38,459
instructions will be and and so a

271
00:11:34,970 --> 00:11:40,170
simplistic layout of an actual memory of

272
00:11:38,459 --> 00:11:41,969
the program can look something like this

273
00:11:40,170 --> 00:11:45,059
i have a little feel for some data let's

274
00:11:41,970 --> 00:11:47,069
say a message a field that holds what

275
00:11:45,059 --> 00:11:48,689
the next actual instruction to be

276
00:11:47,069 --> 00:11:51,389
executed will be let's say its

277
00:11:48,689 --> 00:11:54,059
instruction at the address 1 2 3 4 and

278
00:11:51,389 --> 00:11:56,339
the end then there's that is the code so

279
00:11:54,059 --> 00:11:57,779
right now the flow is fine if i do the

280
00:11:56,339 --> 00:12:00,240
same trick of trying and you know

281
00:11:57,779 --> 00:12:03,119
writing too much and overriding what i

282
00:12:00,240 --> 00:12:05,429
can do is do inject some evil code some

283
00:12:03,119 --> 00:12:07,649
malicious code here put some padding so

284
00:12:05,429 --> 00:12:09,389
that we get to the point i want and then

285
00:12:07,649 --> 00:12:12,899
also but right what the next instruction

286
00:12:09,389 --> 00:12:14,220
address will be so all of a sudden the

287
00:12:12,899 --> 00:12:15,929
next instruction is now what the

288
00:12:14,220 --> 00:12:17,990
programmer intended but it's some code

289
00:12:15,929 --> 00:12:23,850
completely our betray that i injected

290
00:12:17,990 --> 00:12:26,369
now you know I hope I convinced you that

291
00:12:23,850 --> 00:12:28,920
you know buffer overflows are scary I

292
00:12:26,369 --> 00:12:30,329
will try to scare you even a little more

293
00:12:28,920 --> 00:12:33,269
right now just because in wireless

294
00:12:30,329 --> 00:12:35,699
sensor networks one of the important

295
00:12:33,269 --> 00:12:38,129
characteristics is that all of the nodes

296
00:12:35,699 --> 00:12:40,349
of the network run the exact same image

297
00:12:38,129 --> 00:12:42,269
of a software the exact same software

298
00:12:40,350 --> 00:12:45,269
runs in the same way with the same

299
00:12:42,269 --> 00:12:47,970
memory addresses on all of the nodes we

300
00:12:45,269 --> 00:12:49,939
can think of a network of 5 nodes we can

301
00:12:47,970 --> 00:12:55,189
think of a network of a thousand nodes

302
00:12:49,939 --> 00:12:57,748
if I find one vulnerability in one node

303
00:12:55,189 --> 00:13:02,040
this is a realistic picture of me

304
00:12:57,749 --> 00:13:04,679
obviously I can craft a specific network

305
00:13:02,040 --> 00:13:08,279
packet that I just sent to whatever

306
00:13:04,679 --> 00:13:09,870
nodes I have in my vicinity I am able to

307
00:13:08,279 --> 00:13:11,939
corrupt them with that vulnerability

308
00:13:09,870 --> 00:13:14,370
that one vulnerability and tell them to

309
00:13:11,939 --> 00:13:17,339
just keep propagating and keep infected

310
00:13:14,370 --> 00:13:19,529
the whole network this is not only

311
00:13:17,339 --> 00:13:21,899
feasible and not too hard but it's

312
00:13:19,529 --> 00:13:24,029
actually been shown for all of the

313
00:13:21,899 --> 00:13:30,119
available sensor architectures out there

314
00:13:24,029 --> 00:13:31,769
right now so why is this relevant this

315
00:13:30,119 --> 00:13:33,839
has been an issue not just for census

316
00:13:31,769 --> 00:13:38,910
but for software in general for a long

317
00:13:33,839 --> 00:13:40,950
time now and the

318
00:13:38,910 --> 00:13:42,839
the problem is that for regular

319
00:13:40,950 --> 00:13:45,450
platforms a lot of research has been has

320
00:13:42,840 --> 00:13:46,260
been done and a lot of the common

321
00:13:45,450 --> 00:13:48,570
techniques that have been developed

322
00:13:46,260 --> 00:13:51,030
require a lot of additional memory a lot

323
00:13:48,570 --> 00:13:53,400
of additional resources virtual memory

324
00:13:51,030 --> 00:13:54,720
techniques those sensors don't have

325
00:13:53,400 --> 00:13:58,380
those characteristics they just don't

326
00:13:54,720 --> 00:13:59,700
and so in some cases they have a really

327
00:13:58,380 --> 00:14:01,920
high overhead and this sensor is

328
00:13:59,700 --> 00:14:04,050
sometimes process real-time data that it

329
00:14:01,920 --> 00:14:05,939
has to go to go pretty fast I can slow

330
00:14:04,050 --> 00:14:10,319
them down too much so a big overhead is

331
00:14:05,940 --> 00:14:12,330
also a big no-no the sense there's power

332
00:14:10,320 --> 00:14:13,890
you know like let's try and go back to

333
00:14:12,330 --> 00:14:16,080
the bright side now that we're really in

334
00:14:13,890 --> 00:14:19,199
a dark place there's a lot of advantages

335
00:14:16,080 --> 00:14:22,710
to to this sensor software they're

336
00:14:19,200 --> 00:14:25,410
usually the code sizes is small and it's

337
00:14:22,710 --> 00:14:28,800
very modular it's focused on doing one

338
00:14:25,410 --> 00:14:31,800
task and doing it well and the whole

339
00:14:28,800 --> 00:14:35,400
program is available for ten us even the

340
00:14:31,800 --> 00:14:37,349
operating system code is included and

341
00:14:35,400 --> 00:14:41,189
compiled all together in a single image

342
00:14:37,350 --> 00:14:42,930
so there is no dynamic library to be

343
00:14:41,190 --> 00:14:45,120
loaded something that I didn't expect to

344
00:14:42,930 --> 00:14:47,339
happen so this can actually be used to

345
00:14:45,120 --> 00:14:50,910
our advantage when designing a defense

346
00:14:47,340 --> 00:14:53,520
strategy to use advanced language based

347
00:14:50,910 --> 00:14:57,329
techniques that know everything a priori

348
00:14:53,520 --> 00:14:58,680
and also the thing is we see that the

349
00:14:57,330 --> 00:15:00,540
problem is when I'm trying to access the

350
00:14:58,680 --> 00:15:03,569
memory I either write or read from the

351
00:15:00,540 --> 00:15:05,579
memory so one could say we'll just check

352
00:15:03,570 --> 00:15:07,530
every time that you touch the memory

353
00:15:05,580 --> 00:15:08,990
check that you're inside the boundaries

354
00:15:07,530 --> 00:15:12,000
or whatever field you're dealing with

355
00:15:08,990 --> 00:15:14,250
that can have really really high

356
00:15:12,000 --> 00:15:16,080
overhead and slow down but not all of

357
00:15:14,250 --> 00:15:18,030
those checks are are needed if I have

358
00:15:16,080 --> 00:15:19,740
all of the code available what I can do

359
00:15:18,030 --> 00:15:21,810
is to determine well some of these

360
00:15:19,740 --> 00:15:25,140
memory accesses will never result into

361
00:15:21,810 --> 00:15:27,380
any problem or an attack and so I don't

362
00:15:25,140 --> 00:15:29,790
need to slow down the problem that much

363
00:15:27,380 --> 00:15:31,410
so this was the older bases in the

364
00:15:29,790 --> 00:15:32,880
premises for nest check which is the

365
00:15:31,410 --> 00:15:34,709
which is the work that I developed with

366
00:15:32,880 --> 00:15:37,410
Professor p.m. professor bertino and

367
00:15:34,710 --> 00:15:40,560
what we do is we combine static analysis

368
00:15:37,410 --> 00:15:42,780
and dynamic instrumentation to a static

369
00:15:40,560 --> 00:15:45,810
time try to find all of the possible

370
00:15:42,780 --> 00:15:48,449
bugs that we know and are known as well

371
00:15:45,810 --> 00:15:51,030
as provide memory safety guarantees with

372
00:15:48,450 --> 00:15:51,889
the lowest possible overhead whenever I

373
00:15:51,030 --> 00:15:53,988
can see that

374
00:15:51,889 --> 00:15:55,790
a check will not be needed because I can

375
00:15:53,989 --> 00:15:58,029
statically prove that that piece of code

376
00:15:55,790 --> 00:16:00,618
that memory access will always be safe

377
00:15:58,029 --> 00:16:03,739
so there's a lot of applications and we

378
00:16:00,619 --> 00:16:05,619
can think of corporate corporate devices

379
00:16:03,739 --> 00:16:07,429
but also consumer devices so you know

380
00:16:05,619 --> 00:16:10,189
extending this to the Internet of Things

381
00:16:07,429 --> 00:16:13,429
this can help protect the nest

382
00:16:10,189 --> 00:16:16,939
thermostat that is trying to you know

383
00:16:13,429 --> 00:16:20,419
break loose into your home network so

384
00:16:16,939 --> 00:16:23,299
some of the goals of our of our work

385
00:16:20,419 --> 00:16:25,819
where to find bugs I call bugs what is

386
00:16:23,299 --> 00:16:27,858
actually a bug from the developer no

387
00:16:25,819 --> 00:16:30,589
matter what input I try to give to that

388
00:16:27,859 --> 00:16:32,389
kiosk a bug means that all the time the

389
00:16:30,589 --> 00:16:36,169
problem the program will crash at that

390
00:16:32,389 --> 00:16:37,910
particular memory access then I try to

391
00:16:36,169 --> 00:16:39,980
find all the vulnerabilities which means

392
00:16:37,910 --> 00:16:42,049
all the memory accesses that potentially

393
00:16:39,980 --> 00:16:45,230
depending on the input could lead to a

394
00:16:42,049 --> 00:16:47,689
problem and either I turret of Lee I

395
00:16:45,230 --> 00:16:50,569
remove all the checks that are not

396
00:16:47,689 --> 00:16:53,149
needed and the ones that I can say well

397
00:16:50,569 --> 00:16:55,849
this is memory access is safe and I

398
00:16:53,149 --> 00:16:59,149
insert all the checks these are the

399
00:16:55,850 --> 00:17:01,639
static goals and dynamically I I protect

400
00:16:59,149 --> 00:17:03,470
with a check all the excesses that could

401
00:17:01,639 --> 00:17:06,319
lead to a problem and so I will catch

402
00:17:03,470 --> 00:17:11,329
whatever attempt to break into into my

403
00:17:06,319 --> 00:17:13,490
memory the tiny operating system is

404
00:17:11,329 --> 00:17:16,730
developed in an sc which is a dialect of

405
00:17:13,490 --> 00:17:19,099
see that has a couple extra extra

406
00:17:16,730 --> 00:17:22,909
features but for the most part is SC and

407
00:17:19,099 --> 00:17:24,589
the normal tool chain works as you take

408
00:17:22,909 --> 00:17:26,360
the Nestea source code you put

409
00:17:24,589 --> 00:17:28,789
everything together the network stack

410
00:17:26,359 --> 00:17:31,000
the operating system your code that you

411
00:17:28,789 --> 00:17:34,279
wrote you compile it and then you use

412
00:17:31,000 --> 00:17:37,399
GCC the c compiler to output for the

413
00:17:34,279 --> 00:17:40,700
target platform for the sensor what we

414
00:17:37,399 --> 00:17:44,809
do is to leverage llvm in the middle the

415
00:17:40,700 --> 00:17:48,320
llvm is a an open source compiler and

416
00:17:44,809 --> 00:17:51,440
optimizer and what we do is to add a

417
00:17:48,320 --> 00:17:54,379
sequence of steps proprietary to our to

418
00:17:51,440 --> 00:17:57,440
our particular system that will take

419
00:17:54,380 --> 00:17:59,510
care of working on the on an abstract

420
00:17:57,440 --> 00:18:02,000
representation of the code do type

421
00:17:59,510 --> 00:18:05,530
inference to classify all the pointers

422
00:18:02,000 --> 00:18:07,910
based based on how dangerous they are

423
00:18:05,530 --> 00:18:09,860
calculate metadata and use that meta

424
00:18:07,910 --> 00:18:12,530
data to reduce the checks and finally

425
00:18:09,860 --> 00:18:16,699
produce all of the all the dynamic

426
00:18:12,530 --> 00:18:19,010
runtime checks so to give a glimpse of

427
00:18:16,700 --> 00:18:22,100
the big static part of the work in the

428
00:18:19,010 --> 00:18:24,440
big dynamic part of the work what we do

429
00:18:22,100 --> 00:18:26,870
is we use it a type system to classify

430
00:18:24,440 --> 00:18:30,470
all pointers and memory accesses into

431
00:18:26,870 --> 00:18:33,080
three categories safe pointers are the

432
00:18:30,470 --> 00:18:36,890
ones that will never result in a memory

433
00:18:33,080 --> 00:18:40,340
remember your sequence pointers are the

434
00:18:36,890 --> 00:18:42,140
ones that could and dynamic pointers are

435
00:18:40,340 --> 00:18:44,060
the ones for which I actually don't know

436
00:18:42,140 --> 00:18:47,480
anything they could contain any type of

437
00:18:44,060 --> 00:18:49,610
information any data type and will

438
00:18:47,480 --> 00:18:51,290
usually know just as a little snapshot

439
00:18:49,610 --> 00:18:53,419
of the algorithm they've used to

440
00:18:51,290 --> 00:18:55,600
classify all accesses we consider them

441
00:18:53,420 --> 00:18:58,130
safe at the very beginning and then

442
00:18:55,600 --> 00:19:00,020
going through all of the excesses if I

443
00:18:58,130 --> 00:19:03,500
do any sort of pointer arithmetic on

444
00:19:00,020 --> 00:19:05,300
that on that particular pointer I could

445
00:19:03,500 --> 00:19:07,310
potentially go out of bounds and so I

446
00:19:05,300 --> 00:19:10,580
call it sequence and I make it you know

447
00:19:07,310 --> 00:19:12,649
potentially vulnerable if I do weird

448
00:19:10,580 --> 00:19:15,919
operations with those pointers like

449
00:19:12,650 --> 00:19:18,410
casting and integer into a string or

450
00:19:15,920 --> 00:19:20,330
vice versa hour into a pointer which is

451
00:19:18,410 --> 00:19:23,810
by the way totally legal in see it's

452
00:19:20,330 --> 00:19:26,600
there's nothing nothing against it the

453
00:19:23,810 --> 00:19:29,360
sum of the it's fun to try and get this

454
00:19:26,600 --> 00:19:32,060
the standard out see and find that some

455
00:19:29,360 --> 00:19:34,370
of those operations are legal and their

456
00:19:32,060 --> 00:19:38,179
result is defined as undefined behavior

457
00:19:34,370 --> 00:19:42,169
that's how they define the standard and

458
00:19:38,180 --> 00:19:45,290
i classify those as dynamic pointers i

459
00:19:42,170 --> 00:19:47,540
keep track of some some data about all

460
00:19:45,290 --> 00:19:50,030
the memory areas that those pointers

461
00:19:47,540 --> 00:19:51,710
point2 so how big are those fields how

462
00:19:50,030 --> 00:19:54,020
much i can move in one direction or the

463
00:19:51,710 --> 00:19:56,540
other during my analysis i keep all the

464
00:19:54,020 --> 00:19:58,580
metadata in memory of my of my

465
00:19:56,540 --> 00:20:00,230
particular tool to try and not add any

466
00:19:58,580 --> 00:20:03,050
overhead to the application at the

467
00:20:00,230 --> 00:20:05,210
beginning and I for example for each

468
00:20:03,050 --> 00:20:07,700
pointer i see it points into the memory

469
00:20:05,210 --> 00:20:10,580
somewhere and it can freely move in it

470
00:20:07,700 --> 00:20:13,400
in its allotted space of SL to the left

471
00:20:10,580 --> 00:20:16,879
and sh to the to the right for example

472
00:20:13,400 --> 00:20:18,770
and now more than that in some cases i

473
00:20:16,880 --> 00:20:22,220
need some some

474
00:20:18,770 --> 00:20:24,950
a variable might have some pointers my

475
00:20:22,220 --> 00:20:28,280
point to different parts of the memory

476
00:20:24,950 --> 00:20:30,920
depending on how the code whatever path

477
00:20:28,280 --> 00:20:33,560
the execution of the code takes and so

478
00:20:30,920 --> 00:20:36,290
in this little simple example I have a

479
00:20:33,560 --> 00:20:38,870
pointer fee that pointer will be given a

480
00:20:36,290 --> 00:20:42,050
different amount of memory depending on

481
00:20:38,870 --> 00:20:45,050
a variable that is provided by the user

482
00:20:42,050 --> 00:20:49,580
let that variable a so what I do I don't

483
00:20:45,050 --> 00:20:52,100
know how big P will have as a space in

484
00:20:49,580 --> 00:20:54,800
the memory and what I do is to add my

485
00:20:52,100 --> 00:20:57,740
tool will add some explicit metadata

486
00:20:54,800 --> 00:20:59,300
holders to say well you know depending

487
00:20:57,740 --> 00:21:01,400
on the path i will keep track of

488
00:20:59,300 --> 00:21:04,159
whatever chose whatever choice you made

489
00:21:01,400 --> 00:21:07,730
before and make all of my decision about

490
00:21:04,160 --> 00:21:11,710
the checks at runtime based on the

491
00:21:07,730 --> 00:21:14,780
actual dynamic runtime execution flow in

492
00:21:11,710 --> 00:21:18,680
the very last case sometimes having an

493
00:21:14,780 --> 00:21:21,260
additional variable cannot be enough I'm

494
00:21:18,680 --> 00:21:24,230
thinking about pointers that are inside

495
00:21:21,260 --> 00:21:25,430
structures pointers that are pointing to

496
00:21:24,230 --> 00:21:28,280
the heap and they're passed around

497
00:21:25,430 --> 00:21:31,310
through various castes so in this case I

498
00:21:28,280 --> 00:21:34,100
might have to use a an explicit metadata

499
00:21:31,310 --> 00:21:36,379
table in memory which is what makes a

500
00:21:34,100 --> 00:21:40,820
very high overhead for a lot of the

501
00:21:36,380 --> 00:21:42,890
techniques for regular pc software so

502
00:21:40,820 --> 00:21:45,919
this is something that in some cases is

503
00:21:42,890 --> 00:21:48,650
just necessary on the dynamic side what

504
00:21:45,920 --> 00:21:50,840
I do is in lv empty memory accesses are

505
00:21:48,650 --> 00:21:53,420
get element pointer instructions and

506
00:21:50,840 --> 00:21:56,560
well that's when i'm calculating which

507
00:21:53,420 --> 00:21:59,360
memory location to access and any

508
00:21:56,560 --> 00:22:02,419
vulnerable i insert all my checks before

509
00:21:59,360 --> 00:22:04,729
all the vulnerable accesses right before

510
00:22:02,420 --> 00:22:07,580
that particular instruction the

511
00:22:04,730 --> 00:22:10,040
reduction is done by checking all the

512
00:22:07,580 --> 00:22:13,600
metadata that I have collected up to

513
00:22:10,040 --> 00:22:15,860
that particular point in the code and

514
00:22:13,600 --> 00:22:18,889
combine it with whatever type that

515
00:22:15,860 --> 00:22:23,270
pointer was whatever usage attracts so

516
00:22:18,890 --> 00:22:25,430
far and if the check will over result at

517
00:22:23,270 --> 00:22:28,550
that point I can see it will always say

518
00:22:25,430 --> 00:22:31,220
tell me sure this is safe that is a

519
00:22:28,550 --> 00:22:32,178
check that i can safely skip and not add

520
00:22:31,220 --> 00:22:34,249
any

521
00:22:32,179 --> 00:22:38,659
over had any additional instruction onto

522
00:22:34,249 --> 00:22:40,789
the onto the program so I will go

523
00:22:38,659 --> 00:22:44,059
quickly through some of the evaluation

524
00:22:40,789 --> 00:22:47,658
results of my of my software now to to

525
00:22:44,059 --> 00:22:50,690
start wrapping it up we ran our software

526
00:22:47,659 --> 00:22:52,369
on 10 standard applications that come

527
00:22:50,690 --> 00:22:54,259
with the tiny OS operating system

528
00:22:52,369 --> 00:22:55,999
they're open source applications we

529
00:22:54,259 --> 00:22:57,830
weren't expecting to find many actually

530
00:22:55,999 --> 00:23:00,169
memory bugs they've been around in the

531
00:22:57,830 --> 00:23:04,249
community as open source for something

532
00:23:00,169 --> 00:23:06,080
like 20 years so any memory bug you know

533
00:23:04,249 --> 00:23:08,690
i'm going to say has been caught already

534
00:23:06,080 --> 00:23:11,360
the caveat is like hopefully has been

535
00:23:08,690 --> 00:23:13,940
caught already but we can probably say

536
00:23:11,360 --> 00:23:15,619
that and we can see that just looking at

537
00:23:13,940 --> 00:23:18,230
how all the pointers on average are

538
00:23:15,619 --> 00:23:21,470
classified the vast majority of memory

539
00:23:18,230 --> 00:23:24,080
accesses in a sensor application will be

540
00:23:21,470 --> 00:23:26,509
safe so I will not need any particular

541
00:23:24,080 --> 00:23:29,029
check or extra care for that pointer

542
00:23:26,509 --> 00:23:32,570
this lets me let's my technique in my

543
00:23:29,029 --> 00:23:35,059
tool have a really low overhead and out

544
00:23:32,570 --> 00:23:36,769
of those that are not safe my tool is

545
00:23:35,059 --> 00:23:38,869
able to determine that eighteen percent

546
00:23:36,769 --> 00:23:41,809
of that all those checks are actually

547
00:23:38,869 --> 00:23:43,730
useless and so i can safely skip them we

548
00:23:41,809 --> 00:23:46,908
keep reducing and shaving a little bit

549
00:23:43,730 --> 00:23:48,980
of the overhead necessary for that what

550
00:23:46,909 --> 00:23:51,289
i do measure at this point once i

551
00:23:48,980 --> 00:23:54,169
actually run my tool on this on the code

552
00:23:51,289 --> 00:23:56,509
is to see what is the overhead in terms

553
00:23:54,169 --> 00:23:58,369
of code size in terms of memory usage

554
00:23:56,509 --> 00:24:00,769
and in terms of performance so how much

555
00:23:58,369 --> 00:24:03,439
do I slow down the execution on code

556
00:24:00,769 --> 00:24:05,840
size the average is usually six point

557
00:24:03,440 --> 00:24:07,909
nine percent in this case for all of our

558
00:24:05,840 --> 00:24:09,860
but across all of our benchmark and you

559
00:24:07,909 --> 00:24:11,360
have to think also that you know these

560
00:24:09,860 --> 00:24:14,269
are bites like those applications are

561
00:24:11,360 --> 00:24:15,860
really tiny so this is about 350

562
00:24:14,269 --> 00:24:18,049
kilobytes for something that contains

563
00:24:15,860 --> 00:24:21,199
operating system and network stack so an

564
00:24:18,049 --> 00:24:23,889
increment of seven percent is quite

565
00:24:21,200 --> 00:24:26,869
reasonable to have full memory safety

566
00:24:23,889 --> 00:24:28,969
from the performance point of view the

567
00:24:26,869 --> 00:24:31,580
slowdown on average on that we observed

568
00:24:28,970 --> 00:24:33,350
is two point eight percent and we go up

569
00:24:31,580 --> 00:24:35,600
to a slowdown of eight point four

570
00:24:33,350 --> 00:24:38,869
percent which is you know a very

571
00:24:35,600 --> 00:24:41,449
competitive with a lot of much bigger

572
00:24:38,869 --> 00:24:44,418
overhead techniques for PCs and

573
00:24:41,450 --> 00:24:45,940
traditional systems and for the memory

574
00:24:44,419 --> 00:24:47,379
point of view

575
00:24:45,940 --> 00:24:50,649
it really depends on what kind of data

576
00:24:47,379 --> 00:24:53,080
that application deals with we go as low

577
00:24:50,649 --> 00:24:55,629
as it as an overhead of seven percent

578
00:24:53,080 --> 00:24:58,269
and in all of the cases that we analyze

579
00:24:55,629 --> 00:25:00,850
we never went above the 10 kilobytes of

580
00:24:58,269 --> 00:25:03,399
total memory take kilobytes of RAM is

581
00:25:00,850 --> 00:25:05,500
just so little that the little sensor

582
00:25:03,399 --> 00:25:07,418
platform that we were talking that we

583
00:25:05,500 --> 00:25:09,730
were dealing with hats which are the

584
00:25:07,419 --> 00:25:13,980
telus be modes for anybody that's doing

585
00:25:09,730 --> 00:25:16,629
sensor sensor network research or work

586
00:25:13,980 --> 00:25:18,399
to wrap it up i want to just highlight a

587
00:25:16,629 --> 00:25:21,279
couple couple good points about my

588
00:25:18,399 --> 00:25:22,989
technique and a couple points that are

589
00:25:21,279 --> 00:25:25,360
future directions for the work and stuff

590
00:25:22,990 --> 00:25:26,919
that i'd like to improve so we have a

591
00:25:25,360 --> 00:25:29,229
really low overhead and this is because

592
00:25:26,919 --> 00:25:32,620
a lot of the heavy lifting is done at

593
00:25:29,230 --> 00:25:34,120
compile time and i don't require any

594
00:25:32,620 --> 00:25:36,250
source code modifications there are

595
00:25:34,120 --> 00:25:38,049
other techniques for sensor for sensor

596
00:25:36,250 --> 00:25:41,320
networks anton us out there that

597
00:25:38,049 --> 00:25:43,418
required the the programmer to go

598
00:25:41,320 --> 00:25:45,820
through all of the variables and the

599
00:25:43,419 --> 00:25:48,460
pointers and declare exactly how much

600
00:25:45,820 --> 00:25:50,830
space how big the memory area will be

601
00:25:48,460 --> 00:25:53,950
for those pointers that is a huge amount

602
00:25:50,830 --> 00:25:55,960
of work and that has been you know it's

603
00:25:53,950 --> 00:25:57,759
it's a one of the first effort in that

604
00:25:55,960 --> 00:26:00,250
direction was called safety on us it's

605
00:25:57,759 --> 00:26:02,679
still very good but it is it has a

606
00:26:00,250 --> 00:26:04,809
really really lot of you know a big

607
00:26:02,679 --> 00:26:09,759
burden of effort on the on the developer

608
00:26:04,809 --> 00:26:11,620
yeah also i put in a tiny but i think

609
00:26:09,759 --> 00:26:14,169
it's really important I work on llvm

610
00:26:11,620 --> 00:26:16,330
which is you know I work on top of an

611
00:26:14,169 --> 00:26:18,429
intermediate abstract representation of

612
00:26:16,330 --> 00:26:20,830
the code that means that I can apply

613
00:26:18,429 --> 00:26:22,929
this technique if I want to to any

614
00:26:20,830 --> 00:26:26,139
source code I'm completely agnostic to

615
00:26:22,929 --> 00:26:29,529
that as long as llvm supports it as an

616
00:26:26,139 --> 00:26:32,258
input language and I can directly apply

617
00:26:29,529 --> 00:26:33,730
this to any hardware even without any

618
00:26:32,259 --> 00:26:35,830
memory protection just because we don't

619
00:26:33,730 --> 00:26:38,559
require virtual memory we don't require

620
00:26:35,830 --> 00:26:40,529
anything additional like that so it's

621
00:26:38,559 --> 00:26:43,149
very suitable for for constrained device

622
00:26:40,529 --> 00:26:46,899
points of improvement so little little

623
00:26:43,149 --> 00:26:49,149
minus signs failure handling whenever a

624
00:26:46,899 --> 00:26:51,100
code whenever somebody still tries to

625
00:26:49,149 --> 00:26:53,768
attack the application is protected i

626
00:26:51,100 --> 00:26:57,158
will not let them corrupt the memory

627
00:26:53,769 --> 00:26:59,800
however as of now when a check fails all

628
00:26:57,159 --> 00:27:02,350
i can do for real is

629
00:26:59,800 --> 00:27:04,120
to reboot the node I will just stop the

630
00:27:02,350 --> 00:27:06,730
execution then in there well i will not

631
00:27:04,120 --> 00:27:08,739
let them propagate false data or do

632
00:27:06,730 --> 00:27:10,600
malicious attacks but i have to reboot

633
00:27:08,740 --> 00:27:13,420
so it might be a slight disruption in

634
00:27:10,600 --> 00:27:15,490
the service what we want to look into is

635
00:27:13,420 --> 00:27:17,470
to give the programmer some the

636
00:27:15,490 --> 00:27:20,230
possibility of deciding what exactly

637
00:27:17,470 --> 00:27:25,030
happens when a memory corruption still

638
00:27:20,230 --> 00:27:27,400
tries to verify no temporal safety

639
00:27:25,030 --> 00:27:29,350
temporal safety what we talked about so

640
00:27:27,400 --> 00:27:31,750
far is called spatial safety so I go out

641
00:27:29,350 --> 00:27:33,850
of the allotted space we can do this

642
00:27:31,750 --> 00:27:35,980
also in time so let's make you even

643
00:27:33,850 --> 00:27:39,550
scare you we can do this also in time an

644
00:27:35,980 --> 00:27:41,610
attacker can try to access data that was

645
00:27:39,550 --> 00:27:44,320
used in the past in the code and so

646
00:27:41,610 --> 00:27:48,189
theoretically that memory should be

647
00:27:44,320 --> 00:27:50,200
unused and we allocatable however

648
00:27:48,190 --> 00:27:53,430
somebody can try and read them that

649
00:27:50,200 --> 00:27:56,560
information and lick it out we don't

650
00:27:53,430 --> 00:27:58,180
address this in the current prototype we

651
00:27:56,560 --> 00:27:59,950
don't we probably don't need to because

652
00:27:58,180 --> 00:28:02,650
those sensor systems don't have dynamic

653
00:27:59,950 --> 00:28:04,450
memory allocation for the most part but

654
00:28:02,650 --> 00:28:06,670
we would like to investigate it into it

655
00:28:04,450 --> 00:28:09,580
just for the system that do have dynamic

656
00:28:06,670 --> 00:28:12,430
memory allocation and the last part is

657
00:28:09,580 --> 00:28:14,830
how well do we scale to bigger code

658
00:28:12,430 --> 00:28:16,690
bases and that can be around on more

659
00:28:14,830 --> 00:28:18,220
powerful platforms we want to

660
00:28:16,690 --> 00:28:21,250
investigate if there is the possibility

661
00:28:18,220 --> 00:28:23,620
to use formal brief occation techniques

662
00:28:21,250 --> 00:28:26,020
to you know give a mathematical formal

663
00:28:23,620 --> 00:28:29,020
proof that this software will be memory

664
00:28:26,020 --> 00:28:32,530
vulnerability free so these are the

665
00:28:29,020 --> 00:28:34,420
these are the pros and cons and I thank

666
00:28:32,530 --> 00:28:36,160
you so much for listening to me and I'm

667
00:28:34,420 --> 00:28:38,610
definitely open for for questions if you

668
00:28:36,160 --> 00:28:38,610
guys want

669
00:28:50,730 --> 00:28:57,520
hey Danny and I stopped by ragunathan

670
00:28:53,290 --> 00:29:00,760
from easy at Purdue two questions one is

671
00:28:57,520 --> 00:29:02,980
um I thought you mentioned the memory

672
00:29:00,760 --> 00:29:05,410
overhead oh my memory overhead I presume

673
00:29:02,980 --> 00:29:07,480
you mean that I'm overhead yes and you

674
00:29:05,410 --> 00:29:09,400
said that the memory overhead is always

675
00:29:07,480 --> 00:29:12,580
less than 10 kilobytes is that correct

676
00:29:09,400 --> 00:29:14,890
the the whole memory that we use oh it's

677
00:29:12,580 --> 00:29:18,040
the memory that was used by the program

678
00:29:14,890 --> 00:29:19,990
originally plus my overhead it's always

679
00:29:18,040 --> 00:29:22,060
within the 10 kilobytes constraints of

680
00:29:19,990 --> 00:29:25,090
the platform that we were using and

681
00:29:22,060 --> 00:29:28,240
could you what is the memory overhead

682
00:29:25,090 --> 00:29:29,800
that your technique sort of adds it says

683
00:29:28,240 --> 00:29:32,140
as low as seven percent that seems to be

684
00:29:29,800 --> 00:29:34,090
the best case and so what does the could

685
00:29:32,140 --> 00:29:35,320
you I'd what the average case is because

686
00:29:34,090 --> 00:29:36,280
I know the 10 kilobytes is the total

687
00:29:35,320 --> 00:29:37,600
amount of memory that this

688
00:29:36,280 --> 00:29:40,230
microcontroller has that allows

689
00:29:37,600 --> 00:29:43,600
microcontroller hat right exactly so

690
00:29:40,230 --> 00:29:45,400
it's really ugly to present an average

691
00:29:43,600 --> 00:29:49,030
just because there are some cases in

692
00:29:45,400 --> 00:29:52,420
which some programs natively use 6 bytes

693
00:29:49,030 --> 00:29:54,970
of memory and I have to store 3-pointers

694
00:29:52,420 --> 00:29:57,400
just three pointers that adds up to 24

695
00:29:54,970 --> 00:30:00,910
24 bytes so my overhead in that case is

696
00:29:57,400 --> 00:30:02,740
about four hundred percent so you know

697
00:30:00,910 --> 00:30:05,680
presenting the average it looks like

698
00:30:02,740 --> 00:30:07,930
it's gigantic however i'm adding 24

699
00:30:05,680 --> 00:30:09,850
bytes you know on top of six so if you

700
00:30:07,930 --> 00:30:12,430
just do the relative percentage it looks

701
00:30:09,850 --> 00:30:14,800
gigantic but it's you know 24 24

702
00:30:12,430 --> 00:30:17,560
kilobytes it's hard to represent it as

703
00:30:14,800 --> 00:30:21,610
an absolute measure but so yeah there's

704
00:30:17,560 --> 00:30:23,770
there's some cake in which i have more

705
00:30:21,610 --> 00:30:26,260
overhead than what the original program

706
00:30:23,770 --> 00:30:28,540
used just because for example the

707
00:30:26,260 --> 00:30:31,030
network stack always will require some

708
00:30:28,540 --> 00:30:33,129
some pointers to be stored in the memory

709
00:30:31,030 --> 00:30:35,290
so just as a visual illustration so on

710
00:30:33,130 --> 00:30:36,640
this graph as the black lines your

711
00:30:35,290 --> 00:30:39,670
instrumented cord and the green lines

712
00:30:36,640 --> 00:30:41,380
the original application the black line

713
00:30:39,670 --> 00:30:43,360
is how much memory the original

714
00:30:41,380 --> 00:30:45,880
application used and the green is what i

715
00:30:43,360 --> 00:30:47,560
add on top of it okay i just put them

716
00:30:45,880 --> 00:30:49,450
one next to the other to compare you

717
00:30:47,560 --> 00:30:54,790
know the relative size of it so you know

718
00:30:49,450 --> 00:30:58,930
if i use 3500 bytes of memory and i add

719
00:30:54,790 --> 00:31:00,610
if 500 is not terrible oops but in this

720
00:30:58,930 --> 00:31:03,430
case if you were to do a percentage is

721
00:31:00,610 --> 00:31:05,110
really a really bad number but got it I

722
00:31:03,430 --> 00:31:06,850
was just looking for it yes no thank you

723
00:31:05,110 --> 00:31:08,800
that's good the second second question

724
00:31:06,850 --> 00:31:10,810
we had was given the fact that an

725
00:31:08,800 --> 00:31:13,180
increasing number of microcontrollers

726
00:31:10,810 --> 00:31:17,590
that are being used in you know IOT

727
00:31:13,180 --> 00:31:20,140
devices or you know sensor networks have

728
00:31:17,590 --> 00:31:22,360
now memory protection units or MP use

729
00:31:20,140 --> 00:31:23,800
built into the hardware what

730
00:31:22,360 --> 00:31:25,449
implications does that have on a

731
00:31:23,800 --> 00:31:27,810
technique like this I mean it does that

732
00:31:25,450 --> 00:31:30,810
in some sense make some of these

733
00:31:27,810 --> 00:31:35,139
techniques redundant or you know not

734
00:31:30,810 --> 00:31:37,270
required anymore for some of those some

735
00:31:35,140 --> 00:31:40,600
of those controllers yes absolutely that

736
00:31:37,270 --> 00:31:42,040
is true they the thing is that those are

737
00:31:40,600 --> 00:31:45,159
usually used for something that you

738
00:31:42,040 --> 00:31:47,230
don't want to have 10,000 copies off so

739
00:31:45,160 --> 00:31:49,900
if you if you use that microcontroller

740
00:31:47,230 --> 00:31:51,340
to power a thermostat for example like

741
00:31:49,900 --> 00:31:53,350
chances are you going to have one of

742
00:31:51,340 --> 00:31:56,919
those and that's going to cost you about

743
00:31:53,350 --> 00:31:59,110
$300 something like this if you have to

744
00:31:56,920 --> 00:32:00,910
deploy this for a health care

745
00:31:59,110 --> 00:32:03,129
application to collect like you know

746
00:32:00,910 --> 00:32:04,960
humidity across the hospital to make

747
00:32:03,130 --> 00:32:08,110
sure that everybody is comfortable for

748
00:32:04,960 --> 00:32:09,580
example you might want to spend a really

749
00:32:08,110 --> 00:32:11,879
little amount of time and have a dumb

750
00:32:09,580 --> 00:32:13,810
chip that does only one thing and

751
00:32:11,880 --> 00:32:15,820
there's still the chance that somebody's

752
00:32:13,810 --> 00:32:17,770
going to try and hack that I don't know

753
00:32:15,820 --> 00:32:19,929
if this answers your question oh well

754
00:32:17,770 --> 00:32:22,030
yes we can we can take this offline but

755
00:32:19,930 --> 00:32:27,640
sounds good at I know now that that's a

756
00:32:22,030 --> 00:32:30,700
very good point yes thank you any

757
00:32:27,640 --> 00:32:34,750
further questions or very tired after a

758
00:32:30,700 --> 00:32:36,960
long day all right thank you very much

759
00:32:34,750 --> 00:32:36,960
again

760
00:32:37,789 --> 00:32:39,850
you

