1
00:00:06,819 --> 00:00:13,420
hello and welcome everybody it's my

2
00:00:09,830 --> 00:00:17,779
great pleasure to introduce Masonboro

3
00:00:13,420 --> 00:00:20,779
fifth year PhD student in computer

4
00:00:17,779 --> 00:00:24,680
science and he's gonna talk today about

5
00:00:20,779 --> 00:00:27,890
C fix object type integrity it's a novel

6
00:00:24,680 --> 00:00:30,170
mitigation that protects C++

7
00:00:27,890 --> 00:00:33,080
applications against different forms of

8
00:00:30,170 --> 00:00:34,309
attacks and memory corruptions I'm very

9
00:00:33,080 --> 00:00:36,890
interested in what he's going to say

10
00:00:34,309 --> 00:00:39,080
about it thank you thank you Matthias

11
00:00:36,890 --> 00:00:40,670
for that introduction so as mentioned my

12
00:00:39,080 --> 00:00:42,879
name is Nathan bro and I'm a fifth year

13
00:00:40,670 --> 00:00:45,620
PhD student here at Purdue University

14
00:00:42,879 --> 00:00:48,170
today I will be presenting our work

15
00:00:45,620 --> 00:00:50,809
called C fix on object type integrity as

16
00:00:48,170 --> 00:00:52,790
mentioned it's a novel type of defense

17
00:00:50,809 --> 00:00:55,699
for preventing control flow hijacking

18
00:00:52,790 --> 00:00:58,220
attacks so I'd like to start the talk

19
00:00:55,699 --> 00:01:01,099
with a brief survey who in this room

20
00:00:58,220 --> 00:01:02,659
uses a web browser everybody right yep

21
00:01:01,100 --> 00:01:05,770
yep get your hands up

22
00:01:02,659 --> 00:01:09,580
who uses Chrome out of curiosity and

23
00:01:05,770 --> 00:01:12,020
that leaves one person what do you use

24
00:01:09,580 --> 00:01:15,380
okay so that's everyone uses Chrome

25
00:01:12,020 --> 00:01:17,600
lovely so you may have heard of Google's

26
00:01:15,380 --> 00:01:20,539
pwned own competitions and other bug

27
00:01:17,600 --> 00:01:22,729
bounty programs where they compete to

28
00:01:20,540 --> 00:01:25,220
have security researchers try to attack

29
00:01:22,730 --> 00:01:27,110
the browsers so if you visit a web site

30
00:01:25,220 --> 00:01:27,920
or accept network traffic of any kind

31
00:01:27,110 --> 00:01:30,290
through your browser

32
00:01:27,920 --> 00:01:32,240
what can a malicious adversary is to

33
00:01:30,290 --> 00:01:34,010
achieve and the answer is quite

34
00:01:32,240 --> 00:01:36,110
frequently that they can pop a shell or

35
00:01:34,010 --> 00:01:38,630
in these competitions for humour they

36
00:01:36,110 --> 00:01:40,880
pop things like calculators so simply by

37
00:01:38,630 --> 00:01:42,830
using your browser to explore the web

38
00:01:40,880 --> 00:01:45,350
you've potentially given a malicious

39
00:01:42,830 --> 00:01:47,210
actor a shell on your computer that they

40
00:01:45,350 --> 00:01:50,210
can then use to install their malware

41
00:01:47,210 --> 00:01:51,710
read your files and exfiltrate them or

42
00:01:50,210 --> 00:01:54,339
do whatever they want

43
00:01:51,710 --> 00:01:56,780
so these browsers represent a

44
00:01:54,340 --> 00:02:00,979
significant code base that is network

45
00:01:56,780 --> 00:02:03,320
facing and frequently exploitable so to

46
00:02:00,979 --> 00:02:05,840
give some more detail on how browsers

47
00:02:03,320 --> 00:02:07,610
are exploitable need to introduce the

48
00:02:05,840 --> 00:02:10,789
idea of control flow hijacking attacks

49
00:02:07,610 --> 00:02:13,250
so the idea here is that C and C++

50
00:02:10,788 --> 00:02:16,279
programming languages are ubiquitous Lee

51
00:02:13,250 --> 00:02:19,470
used the browsers that we just mentioned

52
00:02:16,280 --> 00:02:21,390
are all primarily implemented in C++

53
00:02:19,470 --> 00:02:24,180
the servers which are listed here are

54
00:02:21,390 --> 00:02:26,250
primarily implemented in C and these

55
00:02:24,180 --> 00:02:30,120
languages provide neither memory nor

56
00:02:26,250 --> 00:02:32,220
type safety so by sending the correctly

57
00:02:30,120 --> 00:02:34,850
formed input the attacker is able to

58
00:02:32,220 --> 00:02:37,410
take control of these processes and

59
00:02:34,850 --> 00:02:38,010
cause them to execute a process of their

60
00:02:37,410 --> 00:02:41,310
choosing

61
00:02:38,010 --> 00:02:43,260
aka a shell so how big a problem is this

62
00:02:41,310 --> 00:02:45,420
in practice is this just an esoteric

63
00:02:43,260 --> 00:02:46,890
concern that you know no one really

64
00:02:45,420 --> 00:02:48,780
needs to worry about because it's so

65
00:02:46,890 --> 00:02:52,589
difficult or is this widespread in

66
00:02:48,780 --> 00:02:54,840
practice so we did a search of the C V's

67
00:02:52,590 --> 00:02:57,630
and found that there were over 14,000 of

68
00:02:54,840 --> 00:02:59,760
them that gave the adversary code

69
00:02:57,630 --> 00:03:03,870
execution and these are stats just for

70
00:02:59,760 --> 00:03:05,399
2017 so yes Matthias Oh what our

71
00:03:03,870 --> 00:03:07,620
Seavey's see these are common

72
00:03:05,400 --> 00:03:09,900
vulnerabilities and exploitation so if

73
00:03:07,620 --> 00:03:12,990
you're a responsible security expert and

74
00:03:09,900 --> 00:03:14,760
you're doing analysis of some program

75
00:03:12,990 --> 00:03:17,160
and you find a bug and it's actually

76
00:03:14,760 --> 00:03:19,230
exploitable you first report it to the

77
00:03:17,160 --> 00:03:21,510
vendor and then when they fix it you

78
00:03:19,230 --> 00:03:23,310
create a CVE and you report it publicly

79
00:03:21,510 --> 00:03:25,140
so that everyone knows what the problem

80
00:03:23,310 --> 00:03:26,900
was and that they should patch it and

81
00:03:25,140 --> 00:03:30,179
these often come with proof-of-concept

82
00:03:26,900 --> 00:03:31,230
exploits so that you know if you're a

83
00:03:30,180 --> 00:03:33,000
researcher and you're trying to

84
00:03:31,230 --> 00:03:35,790
duplicate it and see if some new defense

85
00:03:33,000 --> 00:03:37,440
policy would prevent this exploit you

86
00:03:35,790 --> 00:03:41,609
have sort of the raw materials at hand

87
00:03:37,440 --> 00:03:43,829
to easily test that and as we mentioned

88
00:03:41,610 --> 00:03:45,630
previously these things allow attackers

89
00:03:43,830 --> 00:03:49,320
to control your systems and are

90
00:03:45,630 --> 00:03:51,030
generally bad so for this audience I'd

91
00:03:49,320 --> 00:03:52,920
like to talk a little bit about what is

92
00:03:51,030 --> 00:03:54,510
memory safety I apologize for the

93
00:03:52,920 --> 00:03:56,458
quality of the next couple slides these

94
00:03:54,510 --> 00:03:58,500
were sort of adding in at the last

95
00:03:56,459 --> 00:04:00,450
second so don't have lots of fancy

96
00:03:58,500 --> 00:04:02,640
animations and so forth so you'll have

97
00:04:00,450 --> 00:04:05,579
to bear with me as I talk through these

98
00:04:02,640 --> 00:04:07,019
so I mentioned that C and C++ are

99
00:04:05,580 --> 00:04:09,600
insecure because they don't provide

100
00:04:07,020 --> 00:04:11,940
memory or type safety so first what is

101
00:04:09,600 --> 00:04:14,940
memory safety there's sort of two

102
00:04:11,940 --> 00:04:16,620
flavors of memory safety so when you do

103
00:04:14,940 --> 00:04:18,329
a malloc or you create an array on the

104
00:04:16,620 --> 00:04:20,070
stack or even a local variable on the

105
00:04:18,329 --> 00:04:22,079
stack these all create what you can

106
00:04:20,070 --> 00:04:24,300
think of as memory objects they have a

107
00:04:22,079 --> 00:04:26,370
lifetime either until you free them or

108
00:04:24,300 --> 00:04:28,140
until the stack frame returns they have

109
00:04:26,370 --> 00:04:31,410
a size they're either an array that's

110
00:04:28,140 --> 00:04:33,370
you know 10 entries long and each entry

111
00:04:31,410 --> 00:04:35,650
is 4 bytes so it's really a 40 byte

112
00:04:33,370 --> 00:04:37,360
memory object or you know for malloc you

113
00:04:35,650 --> 00:04:39,669
explicitly say how many bytes you want

114
00:04:37,360 --> 00:04:41,740
so they have a fixed size and they have

115
00:04:39,669 --> 00:04:44,229
a fixed lifetime so you can have two

116
00:04:41,740 --> 00:04:45,790
types of memory safety violations you

117
00:04:44,229 --> 00:04:47,979
can have a spatial memory safety

118
00:04:45,790 --> 00:04:51,310
violation where the size property is

119
00:04:47,979 --> 00:04:54,130
that violated you have a pointer to this

120
00:04:51,310 --> 00:04:55,690
object and it's been incremented or

121
00:04:54,130 --> 00:04:57,940
decremented such that it no longer

122
00:04:55,690 --> 00:05:01,360
points to the object but the memory

123
00:04:57,940 --> 00:05:03,520
either before or after it as long as is

124
00:05:01,360 --> 00:05:05,949
just a pointer this is legal according

125
00:05:03,520 --> 00:05:07,719
to the C standard once you dereference

126
00:05:05,949 --> 00:05:09,789
that pointer and actually access the

127
00:05:07,720 --> 00:05:11,680
underlying memory and it's out of bounds

128
00:05:09,789 --> 00:05:15,310
for the object you've committed a memory

129
00:05:11,680 --> 00:05:16,960
safety violation so these have a couple

130
00:05:15,310 --> 00:05:19,389
of sub types that you might think about

131
00:05:16,960 --> 00:05:21,549
there could be sequential memory safety

132
00:05:19,389 --> 00:05:24,190
violations which is your classic buffer

133
00:05:21,550 --> 00:05:26,770
overflow your reading input until you

134
00:05:24,190 --> 00:05:29,590
see a newline and you only allocated a

135
00:05:26,770 --> 00:05:31,719
you know 40 car long array and the

136
00:05:29,590 --> 00:05:35,080
attacker sends you 200 bytes of data and

137
00:05:31,720 --> 00:05:37,750
so suddenly bytes 41 42 43 start

138
00:05:35,080 --> 00:05:40,570
overwriting other things you could also

139
00:05:37,750 --> 00:05:43,450
have an arbitrary violation let's say

140
00:05:40,570 --> 00:05:45,280
the attacker has overwritten pointer on

141
00:05:43,450 --> 00:05:47,919
the stack or the heap or globally

142
00:05:45,280 --> 00:05:50,440
wherever it is and made it point to a

143
00:05:47,919 --> 00:05:52,180
location of their choosing they now have

144
00:05:50,440 --> 00:05:53,830
an arbitrary memory right because the

145
00:05:52,180 --> 00:05:55,930
attacker is choosing the address that

146
00:05:53,830 --> 00:05:57,909
the pointer points to and so by

147
00:05:55,930 --> 00:05:59,950
controlling the pointer if it's then

148
00:05:57,910 --> 00:06:02,410
dereference the attacker can control any

149
00:05:59,950 --> 00:06:05,020
location in memory without having to do

150
00:06:02,410 --> 00:06:07,510
a sequential write so initial defenses

151
00:06:05,020 --> 00:06:09,190
like stack Canaries that were aimed at

152
00:06:07,510 --> 00:06:11,590
you know buffer overflows on the stack

153
00:06:09,190 --> 00:06:15,070
and sequential writes are not powerful

154
00:06:11,590 --> 00:06:17,198
enough in general they're also temporal

155
00:06:15,070 --> 00:06:20,020
memory safety issues these are a little

156
00:06:17,199 --> 00:06:22,060
less easy to just talk track but the

157
00:06:20,020 --> 00:06:24,609
sort of catch phrase here is use after

158
00:06:22,060 --> 00:06:27,910
free vulnerabilities or uninitialized

159
00:06:24,610 --> 00:06:30,639
reads so by using these the attacker can

160
00:06:27,910 --> 00:06:32,320
start allocating or excuse me modifying

161
00:06:30,639 --> 00:06:35,139
arbitrary memory you know wherever that

162
00:06:32,320 --> 00:06:37,150
object was and maybe a new object will

163
00:06:35,139 --> 00:06:39,400
get allocated there or already has been

164
00:06:37,150 --> 00:06:44,530
so you can corrupt the internals of some

165
00:06:39,400 --> 00:06:47,099
other object using this old pointer type

166
00:06:44,530 --> 00:06:49,140
safety type safety and

167
00:06:47,100 --> 00:06:51,630
again this slide works much better with

168
00:06:49,140 --> 00:06:54,180
actual struck sand memory regions and so

169
00:06:51,630 --> 00:06:55,800
forth so I apologize but there's sort of

170
00:06:54,180 --> 00:06:58,890
two different things you can do here you

171
00:06:55,800 --> 00:07:00,960
can cast to a type that is that is

172
00:06:58,890 --> 00:07:03,090
larger than you are so you have a ten by

173
00:07:00,960 --> 00:07:05,340
table jects a and you cast it to a type

174
00:07:03,090 --> 00:07:07,349
that's 20 bytes long well suddenly you

175
00:07:05,340 --> 00:07:08,849
have access to an extra ten bytes of

176
00:07:07,350 --> 00:07:10,680
memory that you weren't supposed to and

177
00:07:08,850 --> 00:07:13,260
so you have a memory corruption through

178
00:07:10,680 --> 00:07:15,030
this so in this way type safety

179
00:07:13,260 --> 00:07:16,950
violations can lead to memory safety

180
00:07:15,030 --> 00:07:19,080
errors because you're accessing memory

181
00:07:16,950 --> 00:07:21,180
that you shouldn't be able to

182
00:07:19,080 --> 00:07:23,460
there are also type confusion airs where

183
00:07:21,180 --> 00:07:25,590
you're misinterpreting the bytes so

184
00:07:23,460 --> 00:07:27,930
let's say you have a struct that has a

185
00:07:25,590 --> 00:07:29,729
you know pointer field in it somewhere

186
00:07:27,930 --> 00:07:32,610
and you have a struct of the same size

187
00:07:29,730 --> 00:07:34,290
that has a int field in it and you

188
00:07:32,610 --> 00:07:35,580
caused a cast from the version with the

189
00:07:34,290 --> 00:07:37,590
pointer field to the version with the

190
00:07:35,580 --> 00:07:39,840
int field and suddenly you're writing

191
00:07:37,590 --> 00:07:41,609
what you think is an int but some other

192
00:07:39,840 --> 00:07:43,619
part of the program will come along and

193
00:07:41,610 --> 00:07:45,270
think it's a pointer and suddenly the

194
00:07:43,620 --> 00:07:47,910
attacker is written in arbitrary pointer

195
00:07:45,270 --> 00:07:50,969
to memory and you know gains significant

196
00:07:47,910 --> 00:07:53,820
power from this there are also variants

197
00:07:50,970 --> 00:07:56,040
of this that are C++ specific so C++

198
00:07:53,820 --> 00:07:58,500
really likes its class hierarchy you can

199
00:07:56,040 --> 00:08:00,570
define a you know parent class and a

200
00:07:58,500 --> 00:08:02,610
child class and maybe you don't just

201
00:08:00,570 --> 00:08:04,349
have one child but you have a brother

202
00:08:02,610 --> 00:08:06,210
and a sister and there's a whole family

203
00:08:04,350 --> 00:08:08,940
of them so there's some cousin classes

204
00:08:06,210 --> 00:08:11,099
as well and for polymorphism we would

205
00:08:08,940 --> 00:08:13,200
like to be able to do up casts we want

206
00:08:11,100 --> 00:08:15,360
to you know take a child and cast it to

207
00:08:13,200 --> 00:08:17,729
the parent or the grandparent or what

208
00:08:15,360 --> 00:08:19,350
have you and still be able to use it so

209
00:08:17,730 --> 00:08:21,300
that we can write you know detailed

210
00:08:19,350 --> 00:08:23,190
classes for very specific things but

211
00:08:21,300 --> 00:08:25,490
then when we don't need the most

212
00:08:23,190 --> 00:08:28,620
specific thing but just you know

213
00:08:25,490 --> 00:08:30,770
different abstraction over them we can

214
00:08:28,620 --> 00:08:33,240
use the classes higher in the hierarchy

215
00:08:30,770 --> 00:08:36,390
the problem comes in when you start

216
00:08:33,240 --> 00:08:39,719
doing down casts so every parent object

217
00:08:36,390 --> 00:08:41,640
is not necessarily a child right so if

218
00:08:39,719 --> 00:08:43,650
you have a child object and you've up

219
00:08:41,640 --> 00:08:45,300
cast it to parent of course you can down

220
00:08:43,650 --> 00:08:46,980
cast it back to child this is never

221
00:08:45,300 --> 00:08:49,290
going to cause problems because you're

222
00:08:46,980 --> 00:08:50,820
just returning to your original type but

223
00:08:49,290 --> 00:08:52,620
if it was originally allocated as a

224
00:08:50,820 --> 00:08:54,810
parent and you're down casting it to

225
00:08:52,620 --> 00:08:56,190
child bad things can happen the child

226
00:08:54,810 --> 00:08:58,619
might be bigger you might be getting

227
00:08:56,190 --> 00:09:00,420
access to different memory if you're

228
00:08:58,620 --> 00:09:00,810
corrupting the virtual table pointer to

229
00:09:00,420 --> 00:09:02,250
do the

230
00:09:00,810 --> 00:09:04,439
you can start changing the actual

231
00:09:02,250 --> 00:09:06,090
virtual functions that get called if the

232
00:09:04,440 --> 00:09:08,190
idea of a virtual table in a virtual

233
00:09:06,090 --> 00:09:12,570
table pointer and virtual functions are

234
00:09:08,190 --> 00:09:15,570
scary to you worry not I have slides so

235
00:09:12,570 --> 00:09:19,830
before we get to them though I want to

236
00:09:15,570 --> 00:09:22,380
talk a little bit about why C++ offers

237
00:09:19,830 --> 00:09:26,100
both unique vulnerabilities and chances

238
00:09:22,380 --> 00:09:27,930
for defenses to have traction so you

239
00:09:26,100 --> 00:09:29,730
know before we went into what is memory

240
00:09:27,930 --> 00:09:31,560
and type safety we were worried about

241
00:09:29,730 --> 00:09:33,779
control flow hijacking attacks which

242
00:09:31,560 --> 00:09:36,329
were giving the attackers the ability to

243
00:09:33,779 --> 00:09:39,630
hijack your process and execute whatever

244
00:09:36,330 --> 00:09:41,400
they wanted instead so how did you know

245
00:09:39,630 --> 00:09:43,620
and so they're using the memory and type

246
00:09:41,400 --> 00:09:45,540
safety vulnerability to achieve this but

247
00:09:43,620 --> 00:09:47,880
there in goal is to change the control

248
00:09:45,540 --> 00:09:49,230
flow of the program by hijacking it so

249
00:09:47,880 --> 00:09:50,850
to do this they have to over write a

250
00:09:49,230 --> 00:09:51,360
code pointer somewhere in the program's

251
00:09:50,850 --> 00:09:53,850
memory

252
00:09:51,360 --> 00:09:54,870
one of the classic targets is the return

253
00:09:53,850 --> 00:09:57,660
address on the stack

254
00:09:54,870 --> 00:10:00,600
there are also however function pointers

255
00:09:57,660 --> 00:10:03,390
in C or these virtual table pointers in

256
00:10:00,600 --> 00:10:05,880
C++ so there are forward edges where

257
00:10:03,390 --> 00:10:07,949
there are variables that decide what

258
00:10:05,880 --> 00:10:09,450
function will get called so you go

259
00:10:07,950 --> 00:10:12,060
through the program and you know

260
00:10:09,450 --> 00:10:13,860
depending on its state in the execution

261
00:10:12,060 --> 00:10:16,469
path you set this variable to some value

262
00:10:13,860 --> 00:10:18,540
and then you call a function through

263
00:10:16,470 --> 00:10:21,000
that variable so you're using the C

264
00:10:18,540 --> 00:10:23,370
function pointer thing and so the target

265
00:10:21,000 --> 00:10:25,320
is being determined at runtime based on

266
00:10:23,370 --> 00:10:27,900
some dynamic state so it's very

267
00:10:25,320 --> 00:10:30,240
difficult to know at compile time say if

268
00:10:27,900 --> 00:10:33,660
you're emitting a defense what is the

269
00:10:30,240 --> 00:10:35,100
correct target and so it's protecting

270
00:10:33,660 --> 00:10:38,790
these forward edges that we're going to

271
00:10:35,100 --> 00:10:41,880
focus on here we note that we can do a

272
00:10:38,790 --> 00:10:43,829
little bit better for C++ especially for

273
00:10:41,880 --> 00:10:46,160
virtual calls because they have fairly

274
00:10:43,830 --> 00:10:50,040
strict semantics defined by the language

275
00:10:46,160 --> 00:10:53,069
so in particular a virtual calls target

276
00:10:50,040 --> 00:10:55,410
depends on the type of the object so if

277
00:10:53,070 --> 00:10:57,180
you allocate a child object and you're

278
00:10:55,410 --> 00:10:58,560
going to call its foo method you're

279
00:10:57,180 --> 00:11:00,540
always going to get the child's

280
00:10:58,560 --> 00:11:02,400
implementation of foo you're not going

281
00:11:00,540 --> 00:11:04,529
to get the parents or the grandparents

282
00:11:02,400 --> 00:11:06,990
even if you happen to have cast the

283
00:11:04,529 --> 00:11:08,459
child object up and are treating it as a

284
00:11:06,990 --> 00:11:10,560
parent you're always going to get the

285
00:11:08,459 --> 00:11:12,510
child's specific implementation of the

286
00:11:10,560 --> 00:11:14,760
virtual function and this is all all

287
00:11:12,510 --> 00:11:18,689
depends on the allocated type of the

288
00:11:14,760 --> 00:11:21,210
function however once this gets compiled

289
00:11:18,690 --> 00:11:23,130
down to machine code this distinction of

290
00:11:21,210 --> 00:11:24,450
what is the type of the object is no

291
00:11:23,130 --> 00:11:26,490
longer set in stone

292
00:11:24,450 --> 00:11:28,590
it's reliant on a value that's just

293
00:11:26,490 --> 00:11:30,180
sitting there in the objects memory so

294
00:11:28,590 --> 00:11:32,370
it can be corrupted through a memory or

295
00:11:30,180 --> 00:11:34,979
a type safety issue and the type of the

296
00:11:32,370 --> 00:11:37,230
object changed and then you know the

297
00:11:34,980 --> 00:11:39,240
Machine doesn't care it's going to look

298
00:11:37,230 --> 00:11:40,800
at this and if it points to an

299
00:11:39,240 --> 00:11:42,660
executable region of memory it will

300
00:11:40,800 --> 00:11:45,900
happily try to execute them for you so

301
00:11:42,660 --> 00:11:48,240
there's this semantic gap between what

302
00:11:45,900 --> 00:11:50,220
the language requires and what and

303
00:11:48,240 --> 00:11:53,010
compilers currently emit in machine code

304
00:11:50,220 --> 00:11:54,630
which does not enforce everything so

305
00:11:53,010 --> 00:11:57,330
what we're going to do is we're going to

306
00:11:54,630 --> 00:11:59,610
fill this gap between the source level

307
00:11:57,330 --> 00:12:02,090
requirements and what actually happens

308
00:11:59,610 --> 00:12:02,090
in machine code

309
00:12:02,120 --> 00:12:08,040
so we've I've mentioned the idea of

310
00:12:05,010 --> 00:12:10,020
virtual tables and virtual functions and

311
00:12:08,040 --> 00:12:11,640
virtual dispatch so let's look at a code

312
00:12:10,020 --> 00:12:13,130
example to see how all this actually

313
00:12:11,640 --> 00:12:15,510
works in practice

314
00:12:13,130 --> 00:12:17,040
so we're going to use this example

315
00:12:15,510 --> 00:12:18,510
several times so it's worth going

316
00:12:17,040 --> 00:12:21,089
through it in a little bit of detail so

317
00:12:18,510 --> 00:12:24,330
I've defined two classes there's a class

318
00:12:21,090 --> 00:12:26,880
a which has one member which is just a

319
00:12:24,330 --> 00:12:28,620
string or car star in this case and then

320
00:12:26,880 --> 00:12:30,090
it has a virtual function we don't

321
00:12:28,620 --> 00:12:32,040
really care what this function does the

322
00:12:30,090 --> 00:12:33,780
point is that it's virtual which means

323
00:12:32,040 --> 00:12:35,969
that classes from in that inherit from

324
00:12:33,780 --> 00:12:38,459
this class can redefine this to do

325
00:12:35,970 --> 00:12:40,500
something specific for them so then we

326
00:12:38,460 --> 00:12:42,450
have a Class B which does inherit from

327
00:12:40,500 --> 00:12:45,780
Class A and as you might have suspected

328
00:12:42,450 --> 00:12:49,220
does override the implementation of food

329
00:12:45,780 --> 00:12:52,800
to do something specific to Class B and

330
00:12:49,220 --> 00:12:55,080
then let's see what happens in this code

331
00:12:52,800 --> 00:12:58,229
we have a main function that creates an

332
00:12:55,080 --> 00:13:01,530
object both of Class A and of Class B so

333
00:12:58,230 --> 00:13:04,350
when you create the a object it shows up

334
00:13:01,530 --> 00:13:07,770
on the heap and it has two things in it

335
00:13:04,350 --> 00:13:09,360
it has the you know pointer to the

336
00:13:07,770 --> 00:13:11,970
string that we would expect from the

337
00:13:09,360 --> 00:13:14,340
member but the compiler secretly adds a

338
00:13:11,970 --> 00:13:16,020
hidden field to each polymorphic class

339
00:13:14,340 --> 00:13:18,960
so any class that has a virtual function

340
00:13:16,020 --> 00:13:21,120
in it and what this pointer does is it

341
00:13:18,960 --> 00:13:23,310
tells you where is the list of correct

342
00:13:21,120 --> 00:13:26,250
implementations of my virtual functions

343
00:13:23,310 --> 00:13:28,109
so I have one virtual function foo which

344
00:13:26,250 --> 00:13:30,240
implementation should I actually use

345
00:13:28,110 --> 00:13:33,360
and this is stored in the virtual table

346
00:13:30,240 --> 00:13:35,580
so all the virtual table is is a array

347
00:13:33,360 --> 00:13:37,530
of function pointers for the correct

348
00:13:35,580 --> 00:13:40,410
implementation of each virtual function

349
00:13:37,530 --> 00:13:45,959
in the class and so when you do this for

350
00:13:40,410 --> 00:13:47,760
B you get a virtual table pointer to get

351
00:13:45,960 --> 00:13:49,890
the virtual table for B which has a

352
00:13:47,760 --> 00:13:52,830
function pointer to bees inflammation of

353
00:13:49,890 --> 00:13:55,770
foo so that when you come down here and

354
00:13:52,830 --> 00:13:58,590
we actually do virtual calls so here

355
00:13:55,770 --> 00:14:01,890
i've defined a dispatch function which

356
00:13:58,590 --> 00:14:03,840
takes one object it's of Class A which

357
00:14:01,890 --> 00:14:06,300
means it can either be an a object or a

358
00:14:03,840 --> 00:14:08,700
B object that has been up cast to Class

359
00:14:06,300 --> 00:14:11,400
A and so we would expect this to call

360
00:14:08,700 --> 00:14:13,680
either the a implementation or the B

361
00:14:11,400 --> 00:14:15,900
implementation of foo depending on the

362
00:14:13,680 --> 00:14:18,959
type of the underlying object so at

363
00:14:15,900 --> 00:14:21,510
runtime how is this type determined well

364
00:14:18,960 --> 00:14:23,610
it won't I'm missing some highlighting

365
00:14:21,510 --> 00:14:25,319
the virtual table pointer field of the a

366
00:14:23,610 --> 00:14:27,570
object was supposed to turn green there

367
00:14:25,320 --> 00:14:31,820
showing that it's been used to find the

368
00:14:27,570 --> 00:14:34,950
correct function pointer for the a foo

369
00:14:31,820 --> 00:14:36,660
similarly when you do this for B you

370
00:14:34,950 --> 00:14:38,610
come down here and you find the B

371
00:14:36,660 --> 00:14:42,180
implementation because the underlying

372
00:14:38,610 --> 00:14:43,920
type of the object was Class B so does

373
00:14:42,180 --> 00:14:45,780
everyone sort of understand how virtual

374
00:14:43,920 --> 00:14:47,699
dispatch and polymorphism are working

375
00:14:45,780 --> 00:14:49,650
this is going to be key for the rest of

376
00:14:47,700 --> 00:14:54,470
the talk if you're lost here you might

377
00:14:49,650 --> 00:14:57,630
as well just take a nap ok I'm going to

378
00:14:54,470 --> 00:14:59,160
well yeah so I was very tempted to say

379
00:14:57,630 --> 00:15:01,590
that Matthias was offering a

380
00:14:59,160 --> 00:15:03,270
all-expense-paid trip to the Bahamas for

381
00:15:01,590 --> 00:15:05,280
Spring Break for the person to ask the

382
00:15:03,270 --> 00:15:06,750
most interesting question but then I

383
00:15:05,280 --> 00:15:14,699
don't I'm not really that funny so I

384
00:15:06,750 --> 00:15:16,470
didn't ok so the question becomes what

385
00:15:14,700 --> 00:15:17,700
can go wrong we've seen how dynamic

386
00:15:16,470 --> 00:15:19,860
dispatch works

387
00:15:17,700 --> 00:15:22,650
so now we can need to consider how an

388
00:15:19,860 --> 00:15:24,390
attacker might go about abusing it so

389
00:15:22,650 --> 00:15:27,240
here it's the same program that we've

390
00:15:24,390 --> 00:15:29,280
seen before except that we've added in

391
00:15:27,240 --> 00:15:31,410
an arbitrary right for the attacker and

392
00:15:29,280 --> 00:15:33,480
a vulnerable function we don't really

393
00:15:31,410 --> 00:15:35,219
care what the how this function is

394
00:15:33,480 --> 00:15:37,440
implemented just that it gives the

395
00:15:35,220 --> 00:15:39,960
attacker an arbitrary right so what

396
00:15:37,440 --> 00:15:41,939
might the attacker do with this well the

397
00:15:39,960 --> 00:15:43,919
virtual table pointer is determining

398
00:15:41,939 --> 00:15:45,689
run-time what function is getting called

399
00:15:43,919 --> 00:15:47,098
so maybe the attacker would like a

400
00:15:45,689 --> 00:15:49,289
different implementation of the foo

401
00:15:47,099 --> 00:15:51,389
function to be called and so they could

402
00:15:49,289 --> 00:15:53,279
redirect the virtual table pointer to

403
00:15:51,389 --> 00:15:55,429
point to the B implementation even

404
00:15:53,279 --> 00:15:57,720
though this was an a object and

405
00:15:55,429 --> 00:15:59,549
similarly you know just for a nice

406
00:15:57,720 --> 00:16:01,739
illustration they could overwrite the

407
00:15:59,549 --> 00:16:04,039
other virtual table pointer in the B

408
00:16:01,739 --> 00:16:06,569
object to point to the a implementation

409
00:16:04,039 --> 00:16:09,899
so now when we come down here and do

410
00:16:06,569 --> 00:16:11,699
dispatch oh no this was allocated as an

411
00:16:09,899 --> 00:16:14,429
a object but we're getting the B

412
00:16:11,699 --> 00:16:16,498
implementation of the foo function this

413
00:16:14,429 --> 00:16:18,238
may not seem serious it may sort of seem

414
00:16:16,499 --> 00:16:20,339
like a parlor trick or just sort of a

415
00:16:18,239 --> 00:16:21,839
prank that you can play but there's been

416
00:16:20,339 --> 00:16:24,569
work to show that this actually gives

417
00:16:21,839 --> 00:16:28,739
arbitrary execution in practice and is

418
00:16:24,569 --> 00:16:30,509
enough you know with sufficient you know

419
00:16:28,739 --> 00:16:34,169
analysis to string these together to

420
00:16:30,509 --> 00:16:36,149
actually get a shell out of it and so

421
00:16:34,169 --> 00:16:38,549
the more powerful version of this is

422
00:16:36,149 --> 00:16:40,829
what if we don't just change to an

423
00:16:38,549 --> 00:16:42,539
existing virtual table what if we wanted

424
00:16:40,829 --> 00:16:45,569
to inject an entirely new synthetic

425
00:16:42,539 --> 00:16:47,159
object and you know completely blow away

426
00:16:45,569 --> 00:16:50,069
the object to be something of our

427
00:16:47,159 --> 00:16:51,359
choosing what could we do well again we

428
00:16:50,069 --> 00:16:53,488
have the arbitrary right through the

429
00:16:51,359 --> 00:16:55,289
vulnerable function but here the

430
00:16:53,489 --> 00:16:57,029
attacker could just completely wipe out

431
00:16:55,289 --> 00:17:00,119
and replace the memory contents of these

432
00:16:57,029 --> 00:17:01,859
objects and you know the virtual table

433
00:17:00,119 --> 00:17:03,629
pointer will still be there but the

434
00:17:01,859 --> 00:17:06,209
virtual table doesn't necessarily have

435
00:17:03,629 --> 00:17:08,730
to be an existing one for a programmer

436
00:17:06,209 --> 00:17:10,829
to find class it just needs to be an

437
00:17:08,730 --> 00:17:12,480
array of function pointers with you know

438
00:17:10,829 --> 00:17:14,759
a pointer to the function the attacker

439
00:17:12,480 --> 00:17:16,589
cares about at the right index so the

440
00:17:14,759 --> 00:17:18,149
attacker could add in the address of say

441
00:17:16,589 --> 00:17:21,480
system if they happen to know what it is

442
00:17:18,148 --> 00:17:24,208
and then when you come to the dispatch

443
00:17:21,480 --> 00:17:26,279
oh no we're calling system and I don't

444
00:17:24,209 --> 00:17:27,689
have an animation for that but I think

445
00:17:26,279 --> 00:17:30,720
we've all seen this example enough to

446
00:17:27,689 --> 00:17:33,360
follow along so synthetic objects were

447
00:17:30,720 --> 00:17:35,250
first proposed in a paper called

448
00:17:33,360 --> 00:17:37,320
counterfeit object-oriented programming

449
00:17:35,250 --> 00:17:40,379
I like to pronounce the acronym coop

450
00:17:37,320 --> 00:17:42,960
that was presented at Auckland in 2015

451
00:17:40,379 --> 00:17:45,840
so this is a fairly cool attack paper

452
00:17:42,960 --> 00:17:48,210
and if you're into how can you do fancy

453
00:17:45,840 --> 00:17:53,100
forms of control flow hijacking for C++

454
00:17:48,210 --> 00:17:54,240
I recommend you go read it okay so you

455
00:17:53,100 --> 00:17:55,800
know people have known about these

456
00:17:54,240 --> 00:17:58,200
attacks for a while this is

457
00:17:55,800 --> 00:17:59,909
you know new news so to speak so what

458
00:17:58,200 --> 00:18:02,130
has the research community attempted to

459
00:17:59,910 --> 00:18:03,810
do about it the current state of the art

460
00:18:02,130 --> 00:18:06,510
defense is known as control flow

461
00:18:03,810 --> 00:18:08,100
integrity the idea of this defense is

462
00:18:06,510 --> 00:18:10,050
for each indirect call site so

463
00:18:08,100 --> 00:18:12,270
everywhere a function pointer is going

464
00:18:10,050 --> 00:18:14,520
to be used or virtual dispatch is going

465
00:18:12,270 --> 00:18:16,379
to be happened we're going to look at

466
00:18:14,520 --> 00:18:17,970
all the functions in the program and try

467
00:18:16,380 --> 00:18:19,890
to figure out which ones could possibly

468
00:18:17,970 --> 00:18:22,380
have the programmer meant to call here

469
00:18:19,890 --> 00:18:24,330
so in general this means we look at the

470
00:18:22,380 --> 00:18:25,860
function prototype okay this is a

471
00:18:24,330 --> 00:18:27,540
function that returns an int it has

472
00:18:25,860 --> 00:18:30,360
three arguments the arguments are of

473
00:18:27,540 --> 00:18:32,070
type you know car and can float so we're

474
00:18:30,360 --> 00:18:33,810
going to find every address taken

475
00:18:32,070 --> 00:18:36,060
function that returns an int and has

476
00:18:33,810 --> 00:18:37,470
three arguments of those types and we're

477
00:18:36,060 --> 00:18:40,560
going to say that you're allowed to call

478
00:18:37,470 --> 00:18:43,140
those here this is of course hugely over

479
00:18:40,560 --> 00:18:44,520
approximate but it's static analysis so

480
00:18:43,140 --> 00:18:48,630
there are some limits to what you can do

481
00:18:44,520 --> 00:18:50,760
because of alias analysis so if at any

482
00:18:48,630 --> 00:18:52,920
point you cast a function pointer to say

483
00:18:50,760 --> 00:18:55,050
a void star which is an unfortunately

484
00:18:52,920 --> 00:18:57,270
common paradigm and then you cast it

485
00:18:55,050 --> 00:18:59,490
back to this suddenly it's very hard for

486
00:18:57,270 --> 00:19:00,900
a static analysis to figure out what are

487
00:18:59,490 --> 00:19:03,150
the set of things it actually was

488
00:19:00,900 --> 00:19:04,770
intended to point to because the avoid

489
00:19:03,150 --> 00:19:06,360
star could point to anything and if

490
00:19:04,770 --> 00:19:08,850
there are other assignments to this and

491
00:19:06,360 --> 00:19:11,159
so forth so it's in general undecidable

492
00:19:08,850 --> 00:19:13,139
there have been papers that try to do

493
00:19:11,160 --> 00:19:15,480
better than just all functions with the

494
00:19:13,140 --> 00:19:17,430
correct prototype and they can get some

495
00:19:15,480 --> 00:19:18,720
traction in some cases but in general

496
00:19:17,430 --> 00:19:21,180
they still have to fall back to

497
00:19:18,720 --> 00:19:23,220
everything with the right prototype so

498
00:19:21,180 --> 00:19:25,080
the big weakness of this is that it's

499
00:19:23,220 --> 00:19:26,790
you know using static analysis and over

500
00:19:25,080 --> 00:19:29,550
approximate that it's limiting the

501
00:19:26,790 --> 00:19:32,100
attacker to a set of allowed functions

502
00:19:29,550 --> 00:19:34,530
and so it's likely although not been

503
00:19:32,100 --> 00:19:36,330
demonstrated that just by bending well

504
00:19:34,530 --> 00:19:38,010
yes actually excuse me I misspoke it has

505
00:19:36,330 --> 00:19:40,649
been demonstrated that just by bending

506
00:19:38,010 --> 00:19:43,020
control flow within the allowed set for

507
00:19:40,650 --> 00:19:44,670
any possible CFI implementation you can

508
00:19:43,020 --> 00:19:47,070
achieve arbitrary execution in some

509
00:19:44,670 --> 00:19:51,240
cases this was the control flow bending

510
00:19:47,070 --> 00:19:53,280
paper but you know it has some

511
00:19:51,240 --> 00:19:55,290
advantages too because it's making life

512
00:19:53,280 --> 00:19:57,360
significantly harder so instead of it

513
00:19:55,290 --> 00:20:00,060
these indirect call sites being able to

514
00:19:57,360 --> 00:20:02,189
go to any executable byte in the program

515
00:20:00,060 --> 00:20:04,710
you're now limited to a set of functions

516
00:20:02,190 --> 00:20:06,840
so fancy attacks that look for you know

517
00:20:04,710 --> 00:20:09,210
four and five byte long so-called

518
00:20:06,840 --> 00:20:09,720
gadgets like Rob have been significantly

519
00:20:09,210 --> 00:20:11,280
mitigate

520
00:20:09,720 --> 00:20:14,310
because now you have to use entire

521
00:20:11,280 --> 00:20:15,930
functions so that helps and it comes

522
00:20:14,310 --> 00:20:18,179
with low overhead you know you're doing

523
00:20:15,930 --> 00:20:19,770
all your analysis at compile time no one

524
00:20:18,180 --> 00:20:21,660
really cares if it takes longer to

525
00:20:19,770 --> 00:20:23,430
compile your program they care about the

526
00:20:21,660 --> 00:20:25,550
actual execution time the runtime

527
00:20:23,430 --> 00:20:27,750
overhead of it and these have been

528
00:20:25,550 --> 00:20:29,940
significantly optimized through ten

529
00:20:27,750 --> 00:20:32,670
years of research to be about 2%

530
00:20:29,940 --> 00:20:34,290
overhead for the best implementations so

531
00:20:32,670 --> 00:20:36,780
these are cheap and they are providing

532
00:20:34,290 --> 00:20:40,080
power they just aren't quite good enough

533
00:20:36,780 --> 00:20:41,550
and a switch will show so to make this a

534
00:20:40,080 --> 00:20:44,040
little more concrete we have a nice

535
00:20:41,550 --> 00:20:45,990
little animation here we have a call

536
00:20:44,040 --> 00:20:47,370
through a function pointer and there are

537
00:20:45,990 --> 00:20:49,680
these arrows to say oh look it could

538
00:20:47,370 --> 00:20:52,739
point anywhere in memory and now we add

539
00:20:49,680 --> 00:20:54,540
in C Fi and some of the arrows have been

540
00:20:52,740 --> 00:20:56,100
blocked out which I did note by turning

541
00:20:54,540 --> 00:20:58,920
them red and you're down to a set of

542
00:20:56,100 --> 00:21:05,070
allowed targets so as C if I'm making

543
00:20:58,920 --> 00:21:06,690
sense to everyone okay so now we finally

544
00:21:05,070 --> 00:21:09,600
get to talk about the new fun stuff that

545
00:21:06,690 --> 00:21:12,540
I've done namely object type integrity

546
00:21:09,600 --> 00:21:15,959
so oti is a new class of defense

547
00:21:12,540 --> 00:21:18,030
policies for C++ the main thing here is

548
00:21:15,960 --> 00:21:19,920
that we're not going to protect call

549
00:21:18,030 --> 00:21:22,560
sites we're going to protect the objects

550
00:21:19,920 --> 00:21:24,180
themselves and in particular when you

551
00:21:22,560 --> 00:21:26,040
had this object on the heap in its

552
00:21:24,180 --> 00:21:28,170
virtual table we're going to put a lock

553
00:21:26,040 --> 00:21:30,330
on this relationship we're not going to

554
00:21:28,170 --> 00:21:32,900
let the attacker choose the virtual

555
00:21:30,330 --> 00:21:34,980
table that's associated with an object

556
00:21:32,900 --> 00:21:36,720
another way of saying this is that the

557
00:21:34,980 --> 00:21:40,530
attacker cannot control the type of the

558
00:21:36,720 --> 00:21:47,130
object to do I'm going to wander back

559
00:21:40,530 --> 00:21:48,990
behind here right so there are a couple

560
00:21:47,130 --> 00:21:51,330
other things that are worth noting here

561
00:21:48,990 --> 00:21:53,520
oti requires the objects to have an own

562
00:21:51,330 --> 00:21:56,129
type so if you're doing the synthetic

563
00:21:53,520 --> 00:21:57,810
object to type attack and just

564
00:21:56,130 --> 00:21:59,850
completely injecting your own object

565
00:21:57,810 --> 00:22:02,310
that object will not have an own type

566
00:21:59,850 --> 00:22:03,570
per the oti policy so we're going to

567
00:22:02,310 --> 00:22:05,970
detect that as well

568
00:22:03,570 --> 00:22:08,669
we have the first defense to do so in a

569
00:22:05,970 --> 00:22:10,890
truly principled manner further this

570
00:22:08,670 --> 00:22:12,510
policy is extensible I'm going to be

571
00:22:10,890 --> 00:22:14,940
talking today about how it can be used

572
00:22:12,510 --> 00:22:16,560
to predict dynamic cast but it could

573
00:22:14,940 --> 00:22:19,550
also be used for type safety and

574
00:22:16,560 --> 00:22:22,260
possibly even use after free protection

575
00:22:19,550 --> 00:22:23,710
so back to our little graphic that we

576
00:22:22,260 --> 00:22:26,560
use for CFI

577
00:22:23,710 --> 00:22:29,350
so we're see if I limited it to a set of

578
00:22:26,560 --> 00:22:32,110
targets oti is going to limit it to a

579
00:22:29,350 --> 00:22:34,500
single target at runtime because the

580
00:22:32,110 --> 00:22:36,790
type of the object uniquely determines

581
00:22:34,500 --> 00:22:39,300
the virtual function that should be

582
00:22:36,790 --> 00:22:41,860
called it a virtual dispatch site by

583
00:22:39,300 --> 00:22:43,720
guaranteeing the type associated with an

584
00:22:41,860 --> 00:22:45,100
object when you do dispatch on this

585
00:22:43,720 --> 00:22:46,960
object you're always going to get the

586
00:22:45,100 --> 00:22:51,760
single correct target so we no longer

587
00:22:46,960 --> 00:22:53,560
have an approximation problem so to

588
00:22:51,760 --> 00:22:55,150
guarantee that this is not just some

589
00:22:53,560 --> 00:22:57,490
ivory tower idea and that it actually

590
00:22:55,150 --> 00:22:59,590
works in practice we were obligated to

591
00:22:57,490 --> 00:23:01,960
come up with a prototype this is why

592
00:22:59,590 --> 00:23:04,149
grad students exist professors exist to

593
00:23:01,960 --> 00:23:06,700
have fun ideas grad students exist to

594
00:23:04,150 --> 00:23:09,100
prove that they work in practice so we

595
00:23:06,700 --> 00:23:12,430
call this prototype implementation C fix

596
00:23:09,100 --> 00:23:14,230
and what it does is it enforces the C++

597
00:23:12,430 --> 00:23:16,060
object type semantics at the Machine

598
00:23:14,230 --> 00:23:18,760
level so it does what you would expect

599
00:23:16,060 --> 00:23:21,340
from this talk we've looked at the type

600
00:23:18,760 --> 00:23:22,870
according to the C++ semantics and we're

601
00:23:21,340 --> 00:23:25,750
going to inject some code to ensure that

602
00:23:22,870 --> 00:23:27,219
that type cannot be modified and so that

603
00:23:25,750 --> 00:23:30,010
these semantics are actually enforced at

604
00:23:27,220 --> 00:23:31,720
the Machine level to do this we have to

605
00:23:30,010 --> 00:23:33,760
instrument a couple of things we have to

606
00:23:31,720 --> 00:23:35,830
instrument objects constructors so that

607
00:23:33,760 --> 00:23:37,810
we can record their types and we also

608
00:23:35,830 --> 00:23:40,000
have to instrument dynamic dispatch to

609
00:23:37,810 --> 00:23:41,500
enforce our actual policy so once we

610
00:23:40,000 --> 00:23:43,120
have the type of the object at a

611
00:23:41,500 --> 00:23:46,990
dispatch site what are we going to do

612
00:23:43,120 --> 00:23:49,030
there are two options you could just

613
00:23:46,990 --> 00:23:52,030
prevent any attack from happening you

614
00:23:49,030 --> 00:23:53,879
could use our protected type and ignore

615
00:23:52,030 --> 00:23:56,590
the vulnerable type in the object and

616
00:23:53,880 --> 00:23:58,720
know that the correct virtual function

617
00:23:56,590 --> 00:24:00,970
is always going to be called but maybe

618
00:23:58,720 --> 00:24:02,170
you don't you know just want to

619
00:24:00,970 --> 00:24:03,040
guarantee that the correct virtual

620
00:24:02,170 --> 00:24:04,660
function will be called

621
00:24:03,040 --> 00:24:06,700
perhaps you're willing to pay a little

622
00:24:04,660 --> 00:24:08,950
extra overhead and actually detect that

623
00:24:06,700 --> 00:24:10,600
an attack is happening in this case you

624
00:24:08,950 --> 00:24:13,390
can compare the type stored in the

625
00:24:10,600 --> 00:24:15,879
object to our protected type and if they

626
00:24:13,390 --> 00:24:17,440
differ you can detect an attack or a bug

627
00:24:15,880 --> 00:24:20,020
or you know what have you depending on

628
00:24:17,440 --> 00:24:23,370
your context so for this talk we're

629
00:24:20,020 --> 00:24:26,740
going to focus on the idea of prevention

630
00:24:23,370 --> 00:24:29,199
okay so how is C fix designed it's a

631
00:24:26,740 --> 00:24:33,100
compile time instrumentation it's

632
00:24:29,200 --> 00:24:35,320
implemented on top of LVM 39.1 it comes

633
00:24:33,100 --> 00:24:37,240
in two parts as I mentioned we have to

634
00:24:35,320 --> 00:24:38,560
know the correct type of the object

635
00:24:37,240 --> 00:24:40,570
this is determined in the objects

636
00:24:38,560 --> 00:24:42,190
constructor so we instrument the

637
00:24:40,570 --> 00:24:44,649
constructors to record the correct type

638
00:24:42,190 --> 00:24:47,620
for the objects and then we use these

639
00:24:44,650 --> 00:24:49,210
types for dynamic dispatch and there

640
00:24:47,620 --> 00:24:52,449
will be an illustration of how all this

641
00:24:49,210 --> 00:24:54,640
works out coming up we do require a

642
00:24:52,450 --> 00:24:58,450
runtime library which is just a memory

643
00:24:54,640 --> 00:25:02,380
mapped area of region of memory that we

644
00:24:58,450 --> 00:25:05,530
use to score the correct types in so how

645
00:25:02,380 --> 00:25:08,050
does this work in practice okay so here

646
00:25:05,530 --> 00:25:10,750
we're allocating our a object as usual

647
00:25:08,050 --> 00:25:12,220
for our little code example and then we

648
00:25:10,750 --> 00:25:14,920
come along and it's actually being

649
00:25:12,220 --> 00:25:16,810
created on the heap so previously you

650
00:25:14,920 --> 00:25:18,850
have the virtual table pointer that only

651
00:25:16,810 --> 00:25:20,470
pointed to the virtual table what we've

652
00:25:18,850 --> 00:25:23,260
done is we've added in the metadata

653
00:25:20,470 --> 00:25:25,780
table we're using the address of a as

654
00:25:23,260 --> 00:25:27,850
the index into this table and storing

655
00:25:25,780 --> 00:25:30,639
the correct virtual table pointer for a

656
00:25:27,850 --> 00:25:33,939
at the you know slot indicated by its

657
00:25:30,640 --> 00:25:35,620
address right so in addition to having

658
00:25:33,940 --> 00:25:37,600
the type stored in the object we now

659
00:25:35,620 --> 00:25:42,429
also have it replicated in our metadata

660
00:25:37,600 --> 00:25:45,550
table similarly for B we do the same

661
00:25:42,430 --> 00:25:48,850
thing so now when you come to dynamic

662
00:25:45,550 --> 00:25:51,040
dispatch you use the virtual table

663
00:25:48,850 --> 00:25:53,350
pointer or type for the object that was

664
00:25:51,040 --> 00:25:55,180
stored in our protected region so even

665
00:25:53,350 --> 00:25:57,100
if an attacker has changed the virtual

666
00:25:55,180 --> 00:25:59,050
table pointer in the object it doesn't

667
00:25:57,100 --> 00:26:00,820
matter because we're using our protected

668
00:25:59,050 --> 00:26:06,940
one so the correct function will still

669
00:26:00,820 --> 00:26:09,220
be called do okay so to show how this

670
00:26:06,940 --> 00:26:11,350
might work versus an attack you know

671
00:26:09,220 --> 00:26:13,540
here we actually have a little animation

672
00:26:11,350 --> 00:26:16,120
to show that the virtual table pointer

673
00:26:13,540 --> 00:26:18,580
in the object has been corrupted but now

674
00:26:16,120 --> 00:26:20,679
we come to the dispatch and we're using

675
00:26:18,580 --> 00:26:22,810
the correct one so this is just you know

676
00:26:20,680 --> 00:26:25,320
some animation in color to show what I

677
00:26:22,810 --> 00:26:28,360
explained to you previously

678
00:26:25,320 --> 00:26:30,820
yep this is clear to everyone the you

679
00:26:28,360 --> 00:26:32,979
know that you know the attacker has

680
00:26:30,820 --> 00:26:34,450
corrupted the type in the actual object

681
00:26:32,980 --> 00:26:36,820
but it doesn't matter because the

682
00:26:34,450 --> 00:26:38,830
attacker can't change where the object

683
00:26:36,820 --> 00:26:40,600
was allocated so we can look up the

684
00:26:38,830 --> 00:26:42,129
correct type for that object and use it

685
00:26:40,600 --> 00:26:44,679
to make sure that the correct virtual

686
00:26:42,130 --> 00:26:48,480
function gets called so it's you know

687
00:26:44,680 --> 00:26:48,480
nicely simple and elegant in practice

688
00:26:51,420 --> 00:26:56,680
all right so but all this would be

689
00:26:54,760 --> 00:26:59,320
worthless if the attacker can just come

690
00:26:56,680 --> 00:27:01,060
along and modify our metadata instead of

691
00:26:59,320 --> 00:27:03,070
modifying the type in the object right

692
00:27:01,060 --> 00:27:05,379
so I have to be able to convince you and

693
00:27:03,070 --> 00:27:06,970
the security community in general that

694
00:27:05,380 --> 00:27:09,370
our metadata is actually integrity

695
00:27:06,970 --> 00:27:13,030
protected that only our instrumentation

696
00:27:09,370 --> 00:27:15,310
can write to it and not in attacker so

697
00:27:13,030 --> 00:27:17,440
as you might suspect we have two classes

698
00:27:15,310 --> 00:27:19,330
of rights in the program there are those

699
00:27:17,440 --> 00:27:20,920
that we have inserted through our

700
00:27:19,330 --> 00:27:22,389
instrumentation that are actually

701
00:27:20,920 --> 00:27:24,850
allowed to access the metadata

702
00:27:22,390 --> 00:27:26,830
and there are all our excuse me there

703
00:27:24,850 --> 00:27:28,840
are all other rights so all the other

704
00:27:26,830 --> 00:27:31,300
rights should not be able to access the

705
00:27:28,840 --> 00:27:33,459
metadata and so you can think of this as

706
00:27:31,300 --> 00:27:35,379
saying that they must be in bounds for

707
00:27:33,460 --> 00:27:37,840
the rest of memory so you can think of

708
00:27:35,380 --> 00:27:39,460
this as being an array bounds check you

709
00:27:37,840 --> 00:27:42,639
know that there are two areas of memory

710
00:27:39,460 --> 00:27:44,440
there's the region that most rights are

711
00:27:42,640 --> 00:27:47,170
allowed to write to and then there's our

712
00:27:44,440 --> 00:27:49,300
specific metadata region and so this

713
00:27:47,170 --> 00:27:51,760
brought to mind Intel's new memory

714
00:27:49,300 --> 00:27:53,620
protection extensions this is an ice ax

715
00:27:51,760 --> 00:27:56,410
feature that lets you do array bounds

716
00:27:53,620 --> 00:27:58,239
checks very quickly once you have the

717
00:27:56,410 --> 00:28:00,790
bounds loaded in their special bounds

718
00:27:58,240 --> 00:28:02,410
register it becomes one instruction and

719
00:28:00,790 --> 00:28:05,280
the hardware does the comparison and

720
00:28:02,410 --> 00:28:08,500
generates a signal if it has failed

721
00:28:05,280 --> 00:28:11,350
there is one catch however in that you

722
00:28:08,500 --> 00:28:13,450
need one contiguous region of memory to

723
00:28:11,350 --> 00:28:17,320
check with npx it doesn't like you

724
00:28:13,450 --> 00:28:21,070
saying inbounds are from zero to 50 and

725
00:28:17,320 --> 00:28:24,370
then from 70 to 100 also it wants one

726
00:28:21,070 --> 00:28:26,620
region of memory so to do this what

727
00:28:24,370 --> 00:28:29,290
we've done is we perform our checks on a

728
00:28:26,620 --> 00:28:31,090
rotated address space we calculate how

729
00:28:29,290 --> 00:28:33,370
much we have to add so that our metadata

730
00:28:31,090 --> 00:28:35,500
table is at the top of the address space

731
00:28:33,370 --> 00:28:37,979
instead of being wherever it is in the

732
00:28:35,500 --> 00:28:41,170
middle and then you know because of

733
00:28:37,980 --> 00:28:43,240
integer overflow you add that much and

734
00:28:41,170 --> 00:28:45,310
the rotation as shown sort of on the

735
00:28:43,240 --> 00:28:47,500
right side of this figure you know

736
00:28:45,310 --> 00:28:49,690
happens so now you have our metadata

737
00:28:47,500 --> 00:28:51,700
table on the top of this rotated address

738
00:28:49,690 --> 00:28:54,040
space and you can use one MPX

739
00:28:51,700 --> 00:28:56,020
instruction to ask you know is the

740
00:28:54,040 --> 00:28:59,620
rotated pointer below the meta data

741
00:28:56,020 --> 00:29:02,190
table or not so this is a new

742
00:28:59,620 --> 00:29:05,100
application of MPX and it's kind of

743
00:29:02,190 --> 00:29:07,620
because this issue comes up fairly often

744
00:29:05,100 --> 00:29:10,080
for run time defenses that they want to

745
00:29:07,620 --> 00:29:12,000
have some sort of metadata or

746
00:29:10,080 --> 00:29:13,679
information about the program state on

747
00:29:12,000 --> 00:29:15,960
the side that they're going to look at

748
00:29:13,680 --> 00:29:20,400
to decide how to enforce their defense

749
00:29:15,960 --> 00:29:23,070
policies so this you know it's both an

750
00:29:20,400 --> 00:29:25,020
engineering detail and a design decision

751
00:29:23,070 --> 00:29:28,139
because it's how can we take this and

752
00:29:25,020 --> 00:29:30,030
make it fit what we need so does anyone

753
00:29:28,140 --> 00:29:35,340
have any questions about this as I take

754
00:29:30,030 --> 00:29:36,899
a drink okay cool

755
00:29:35,340 --> 00:29:39,179
this is just one detail that I'm

756
00:29:36,900 --> 00:29:41,390
particularly proud of even though it's

757
00:29:39,180 --> 00:29:44,670
perhaps less important to the overall

758
00:29:41,390 --> 00:29:47,550
the work which is mainly focused on the

759
00:29:44,670 --> 00:29:51,240
control flow hijacking and you know how

760
00:29:47,550 --> 00:29:53,550
to secure the virtual calls since I have

761
00:29:51,240 --> 00:29:55,050
50 minutes instead of 20 I've decided to

762
00:29:53,550 --> 00:29:57,690
bore you with details about how this

763
00:29:55,050 --> 00:30:00,360
metadata table is actually implemented

764
00:29:57,690 --> 00:30:02,760
it doesn't particularly matter matter

765
00:30:00,360 --> 00:30:06,419
but it's a two level page table so you

766
00:30:02,760 --> 00:30:10,140
have a pointer as shown here in this bar

767
00:30:06,420 --> 00:30:11,850
on the bottom and so you have a top

768
00:30:10,140 --> 00:30:14,520
level page table and then various

769
00:30:11,850 --> 00:30:17,520
second-level page tables so you look at

770
00:30:14,520 --> 00:30:19,560
the top 22 bits of the pointer and you

771
00:30:17,520 --> 00:30:21,600
use them as an index in the top level

772
00:30:19,560 --> 00:30:23,639
table that gets you a pointer to the

773
00:30:21,600 --> 00:30:25,860
relevant second-level table where you

774
00:30:23,640 --> 00:30:28,290
use the next 20 bits as the index into

775
00:30:25,860 --> 00:30:30,419
that and so that's how you convert the

776
00:30:28,290 --> 00:30:32,760
address of the object into an actual

777
00:30:30,420 --> 00:30:35,130
metadata entry you do the usual page

778
00:30:32,760 --> 00:30:38,070
table walk where this is how we've split

779
00:30:35,130 --> 00:30:39,450
it up and structured it the details here

780
00:30:38,070 --> 00:30:40,850
are really not important I just thought

781
00:30:39,450 --> 00:30:43,680
I would mention them as a time filler

782
00:30:40,850 --> 00:30:45,449
okay so everyone took in that for that

783
00:30:43,680 --> 00:30:51,120
slide right yep okay good

784
00:30:45,450 --> 00:30:53,100
all right so we've talked shouldn't rest

785
00:30:51,120 --> 00:30:57,870
my finger on my clicker we've talked a

786
00:30:53,100 --> 00:30:59,189
lot about the theory of all this but we

787
00:30:57,870 --> 00:31:01,709
do have to show that it works in

788
00:30:59,190 --> 00:31:03,630
practice and so to do an evaluation I'm

789
00:31:01,710 --> 00:31:06,330
going to talk to you both about how

790
00:31:03,630 --> 00:31:08,730
we've quantitatively evaluated the

791
00:31:06,330 --> 00:31:10,590
security of this project and how it can

792
00:31:08,730 --> 00:31:13,080
be combined with control flow integrity

793
00:31:10,590 --> 00:31:14,580
which was the existing technique in the

794
00:31:13,080 --> 00:31:16,439
benefits you might get from doing that

795
00:31:14,580 --> 00:31:19,080
and then we also have a

796
00:31:16,440 --> 00:31:20,940
Foreman's evaluation noticeably we were

797
00:31:19,080 --> 00:31:23,220
able to compile more than just toy

798
00:31:20,940 --> 00:31:25,680
benchmarks so we actually got Chrome to

799
00:31:23,220 --> 00:31:28,710
compile and ran the standard JavaScript

800
00:31:25,680 --> 00:31:31,320
benchmarks with about 2% overhead we

801
00:31:28,710 --> 00:31:34,490
also ran the usual compiler suite of

802
00:31:31,320 --> 00:31:36,810
benchmarks which is known as spec CPU

803
00:31:34,490 --> 00:31:39,300
okay so for security

804
00:31:36,810 --> 00:31:42,090
how do existing defenses work these are

805
00:31:39,300 --> 00:31:45,330
all just CFI implementations so they're

806
00:31:42,090 --> 00:31:47,790
based on static analysis and so it's a

807
00:31:45,330 --> 00:31:49,620
dispatch site you know if you were just

808
00:31:47,790 --> 00:31:52,440
looking at any address taken functioned

809
00:31:49,620 --> 00:31:55,379
green circles show the functions that

810
00:31:52,440 --> 00:31:57,660
you might target when you apply LVM CFI

811
00:31:55,380 --> 00:31:59,940
it's aware of the class hierarchy so

812
00:31:57,660 --> 00:32:02,340
because excuse me because this is an a

813
00:31:59,940 --> 00:32:04,110
object that's being used it's able to

814
00:32:02,340 --> 00:32:08,280
limit it to just the two functions in

815
00:32:04,110 --> 00:32:11,850
that class hierarchy V Trust is a less

816
00:32:08,280 --> 00:32:15,000
general policy it's only focused on C++

817
00:32:11,850 --> 00:32:17,280
whereas LVM CFI also protects C style

818
00:32:15,000 --> 00:32:19,980
and direct pointers excuse me C style

819
00:32:17,280 --> 00:32:22,440
function pointers and it also leverages

820
00:32:19,980 --> 00:32:26,760
a class hierarchy analysis and achieves

821
00:32:22,440 --> 00:32:29,750
basically the same precision CPS is a

822
00:32:26,760 --> 00:32:33,120
policy that achieves better precision

823
00:32:29,750 --> 00:32:36,180
what CPS can be thought of as a subset

824
00:32:33,120 --> 00:32:38,129
of memory safety so they say we're going

825
00:32:36,180 --> 00:32:39,630
to protect all code pointers we're going

826
00:32:38,130 --> 00:32:42,030
to move them to a separate region of

827
00:32:39,630 --> 00:32:44,880
memory and there aren't going to be any

828
00:32:42,030 --> 00:32:47,720
arrays or anything there so that you

829
00:32:44,880 --> 00:32:49,830
know attacker cannot easily corrupt them

830
00:32:47,720 --> 00:32:52,050
there are of course some ifs ands and

831
00:32:49,830 --> 00:32:54,360
buts and there's a heavier weight policy

832
00:32:52,050 --> 00:32:57,060
known as CFI that addresses many of

833
00:32:54,360 --> 00:32:59,610
those but cps is the one that achieves

834
00:32:57,060 --> 00:33:01,590
roughly comparable performance so it's

835
00:32:59,610 --> 00:33:04,020
the policy we'll look at and because

836
00:33:01,590 --> 00:33:08,310
it's actually integrity protecting the

837
00:33:04,020 --> 00:33:10,379
pointer sort of it can detect that there

838
00:33:08,310 --> 00:33:13,800
should only be one valid target based on

839
00:33:10,380 --> 00:33:15,750
the object okay so to show the

840
00:33:13,800 --> 00:33:18,120
differences differences and sort of

841
00:33:15,750 --> 00:33:20,760
tease out the different issues in these

842
00:33:18,120 --> 00:33:22,800
policies we've created some micro

843
00:33:20,760 --> 00:33:25,140
benchmarks which just showed different

844
00:33:22,800 --> 00:33:27,360
attacks and then we compiled them with

845
00:33:25,140 --> 00:33:29,549
the various defenses and saw what

846
00:33:27,360 --> 00:33:33,129
targets we were actually able to

847
00:33:29,549 --> 00:33:35,049
address so the first one is fake virtual

848
00:33:33,130 --> 00:33:37,750
tables where you inject a virtual table

849
00:33:35,049 --> 00:33:39,668
of your choosing and all the defenses

850
00:33:37,750 --> 00:33:41,650
are able to do with that if you do a

851
00:33:39,669 --> 00:33:42,820
slightly fancier version of this where

852
00:33:41,650 --> 00:33:45,190
you actually make sure that the function

853
00:33:42,820 --> 00:33:47,980
prototypes in your injected virtual

854
00:33:45,190 --> 00:33:51,610
table match up they're all still able to

855
00:33:47,980 --> 00:33:53,110
deal with that virtual table exchange is

856
00:33:51,610 --> 00:33:55,809
like what I showed you on one of those

857
00:33:53,110 --> 00:33:58,059
first slides where we cross the virtual

858
00:33:55,809 --> 00:34:01,658
table pointers and you know pointed it

859
00:33:58,059 --> 00:34:04,629
to something different that's also

860
00:34:01,659 --> 00:34:06,280
handled by existing defenses where

861
00:34:04,630 --> 00:34:09,280
existing defenses struggle is if you

862
00:34:06,280 --> 00:34:11,679
change the virtual table to be that of a

863
00:34:09,280 --> 00:34:13,300
related class they can't detect that

864
00:34:11,679 --> 00:34:15,879
because they're statically allowing the

865
00:34:13,300 --> 00:34:18,730
entire class hierarchy so you can get

866
00:34:15,879 --> 00:34:21,159
away with violating them and then when

867
00:34:18,730 --> 00:34:23,139
you do coop style synthetic objects CPS

868
00:34:21,159 --> 00:34:24,669
is not able to deal with this because

869
00:34:23,139 --> 00:34:26,980
they don't know what the correct type of

870
00:34:24,668 --> 00:34:28,658
the object should have been even though

871
00:34:26,980 --> 00:34:30,250
they're protecting the virtual table

872
00:34:28,659 --> 00:34:32,230
pointer they don't know what its correct

873
00:34:30,250 --> 00:34:33,760
value was and they aren't tracing it

874
00:34:32,230 --> 00:34:36,659
throughout the lifetime of the object so

875
00:34:33,760 --> 00:34:39,159
they aren't able to detect these attacks

876
00:34:36,659 --> 00:34:42,940
okay so in a nutshell

877
00:34:39,159 --> 00:34:44,950
oti versus C if I so object type

878
00:34:42,940 --> 00:34:47,470
integrity can be combined with control

879
00:34:44,949 --> 00:34:49,658
flow integrity it's fairly apparent why

880
00:34:47,469 --> 00:34:51,730
this is so control flow integrity is

881
00:34:49,659 --> 00:34:53,859
focusing on call sights we're focusing

882
00:34:51,730 --> 00:34:56,889
on objects so there's no reason that

883
00:34:53,859 --> 00:34:58,840
these policies should conflict as I've

884
00:34:56,889 --> 00:35:01,350
mentioned control flow integrity is over

885
00:34:58,840 --> 00:35:03,970
approximate but what it does get you is

886
00:35:01,350 --> 00:35:06,250
that there's an absolute set of allowed

887
00:35:03,970 --> 00:35:07,899
targets for a call site so with ours

888
00:35:06,250 --> 00:35:09,630
we're guaranteeing the correctness of

889
00:35:07,900 --> 00:35:12,520
virtual dispatch for a given object

890
00:35:09,630 --> 00:35:14,950
however if an attacker is able to modify

891
00:35:12,520 --> 00:35:17,080
the data flow through the program such

892
00:35:14,950 --> 00:35:19,689
that the wrong object reaches a virtual

893
00:35:17,080 --> 00:35:21,190
dispatch site we can't detect that we

894
00:35:19,690 --> 00:35:23,170
will be make sure that the correct

895
00:35:21,190 --> 00:35:24,910
virtual function is called but if it's

896
00:35:23,170 --> 00:35:26,980
the wrong object well we're going to get

897
00:35:24,910 --> 00:35:29,319
the wrong virtual function so if you add

898
00:35:26,980 --> 00:35:31,660
in C fi you can limit the set of objects

899
00:35:29,320 --> 00:35:33,430
that an attacker can substitute to once

900
00:35:31,660 --> 00:35:35,859
that would be you know at least in the

901
00:35:33,430 --> 00:35:38,190
same class hierarchy so this provides a

902
00:35:35,859 --> 00:35:40,839
little bit of extra defense there and

903
00:35:38,190 --> 00:35:42,520
just from an engineering perspective I

904
00:35:40,839 --> 00:35:45,100
was shocked I just you know

905
00:35:42,520 --> 00:35:47,590
used our modified clang and turned on

906
00:35:45,100 --> 00:35:49,930
the CFI flag and all the benchmarks

907
00:35:47,590 --> 00:35:51,730
still worked this was unheard of it made

908
00:35:49,930 --> 00:35:53,770
my life super easy thought I was going

909
00:35:51,730 --> 00:35:55,270
to have to spend a month debugging but

910
00:35:53,770 --> 00:35:57,250
I'm sort of the larger design level

911
00:35:55,270 --> 00:35:59,620
point is that these are truly compatible

912
00:35:57,250 --> 00:36:01,000
policies that aren't conflicting they're

913
00:35:59,620 --> 00:36:02,700
addressing different parts of the

914
00:36:01,000 --> 00:36:06,160
program

915
00:36:02,700 --> 00:36:09,580
ok so performance results time so on the

916
00:36:06,160 --> 00:36:11,970
x-axis you can see the 7 C++ spec

917
00:36:09,580 --> 00:36:14,470
benchmarks we got all of them to run and

918
00:36:11,970 --> 00:36:16,180
which is not necessarily a case for

919
00:36:14,470 --> 00:36:18,939
compiler based offenses there's often

920
00:36:16,180 --> 00:36:22,149
one or two missing for engineering

921
00:36:18,940 --> 00:36:24,730
reasons and then on the y-axis is the

922
00:36:22,150 --> 00:36:26,110
percent overhead so we're showing two

923
00:36:24,730 --> 00:36:29,410
different results here at the lighter

924
00:36:26,110 --> 00:36:32,250
bar is just the overhead from switching

925
00:36:29,410 --> 00:36:34,540
to the C fix dispatch scheme so for

926
00:36:32,250 --> 00:36:36,670
creating the metadata table and

927
00:36:34,540 --> 00:36:39,310
maintaining entries in it and then using

928
00:36:36,670 --> 00:36:41,230
our protected types for virtual dispatch

929
00:36:39,310 --> 00:36:43,930
instead of using the one in the object

930
00:36:41,230 --> 00:36:46,660
so for just doing all that we get about

931
00:36:43,930 --> 00:36:49,270
two percent overhead then when you add

932
00:36:46,660 --> 00:36:51,399
in MPX and start integrity protecting

933
00:36:49,270 --> 00:36:53,560
the metadata table because you're

934
00:36:51,400 --> 00:36:55,690
checking every write in the program

935
00:36:53,560 --> 00:36:57,640
there's of course slightly more overhead

936
00:36:55,690 --> 00:36:59,500
we end up at five percent on average

937
00:36:57,640 --> 00:37:02,589
although you can see that there's that

938
00:36:59,500 --> 00:37:05,920
one pathological case for on net that

939
00:37:02,590 --> 00:37:08,220
ends up at 13 percent or so so you know

940
00:37:05,920 --> 00:37:12,040
you get what you pay for

941
00:37:08,220 --> 00:37:15,250
so in conclusion object type integrity

942
00:37:12,040 --> 00:37:16,630
is a new class of defense policy we've

943
00:37:15,250 --> 00:37:19,240
shown how it can be used to protect

944
00:37:16,630 --> 00:37:20,950
virtual dispatch but because we're

945
00:37:19,240 --> 00:37:22,959
tracking types of objects it's clearly

946
00:37:20,950 --> 00:37:25,120
extensible to type safety issues and

947
00:37:22,960 --> 00:37:25,630
because we're maintaining metadata per

948
00:37:25,120 --> 00:37:26,529
object

949
00:37:25,630 --> 00:37:28,210
there are also some interesting

950
00:37:26,530 --> 00:37:31,150
applications to use after free

951
00:37:28,210 --> 00:37:34,450
protection it has low performance

952
00:37:31,150 --> 00:37:36,160
overhead 2% on Chrome and you know

953
00:37:34,450 --> 00:37:38,080
within the same ballpark on the

954
00:37:36,160 --> 00:37:40,899
computation intensive spec CPU

955
00:37:38,080 --> 00:37:43,180
benchmarks we've shown how it can be

956
00:37:40,900 --> 00:37:45,670
combined with control flow integrity to

957
00:37:43,180 --> 00:37:47,649
mitigate data flow attacks and our

958
00:37:45,670 --> 00:37:49,390
implementation is open source at this

959
00:37:47,650 --> 00:37:52,510
link I encourage you to go check it out

960
00:37:49,390 --> 00:37:55,370
and with that I am done and will and I'm

961
00:37:52,510 --> 00:38:01,030
happy to take any questions

962
00:37:55,370 --> 00:38:01,029
[Applause]

963
00:38:17,190 --> 00:38:42,100
no dumb questions so that's a good

964
00:38:39,190 --> 00:38:43,840
question the naive way that they might

965
00:38:42,100 --> 00:38:46,180
try to do it is to edit the actual

966
00:38:43,840 --> 00:38:48,510
virtual tables and you know change the

967
00:38:46,180 --> 00:38:51,390
function pointer that's stored there

968
00:38:48,510 --> 00:38:53,740
unfortunately for attackers these are

969
00:38:51,390 --> 00:38:55,779
statically determined at runtime so we

970
00:38:53,740 --> 00:38:57,580
can map them into read-only memory so

971
00:38:55,780 --> 00:39:00,550
you can't directly modify the virtual

972
00:38:57,580 --> 00:39:03,009
tables what you can do is change the

973
00:39:00,550 --> 00:39:05,260
pointer to these tables right so virtual

974
00:39:03,010 --> 00:39:07,420
calls are double indirect you go through

975
00:39:05,260 --> 00:39:08,800
the pointer to the virtual table to find

976
00:39:07,420 --> 00:39:10,450
the pointer to the function that you

977
00:39:08,800 --> 00:39:13,060
want to call so you've traversed two

978
00:39:10,450 --> 00:39:15,250
pointers and you know the second one is

979
00:39:13,060 --> 00:39:16,840
secure because it's read-only the first

980
00:39:15,250 --> 00:39:18,520
one however is in writable memory

981
00:39:16,840 --> 00:39:19,870
because for each object that you

982
00:39:18,520 --> 00:39:22,000
allocate you have to be able to write

983
00:39:19,870 --> 00:39:23,950
into it okay what is the correct virtual

984
00:39:22,000 --> 00:39:25,930
table for this and so because that

985
00:39:23,950 --> 00:39:28,180
virtual table pointers sitting there in

986
00:39:25,930 --> 00:39:29,980
writable memory the attacker can use the

987
00:39:28,180 --> 00:39:31,810
underlying bug of their choice we don't

988
00:39:29,980 --> 00:39:34,990
care it's probably going to be a memory

989
00:39:31,810 --> 00:39:36,730
or a type safety issue and you know use

990
00:39:34,990 --> 00:39:38,680
that to overwrite the virtual table

991
00:39:36,730 --> 00:39:40,360
pointer and then you know to choose

992
00:39:38,680 --> 00:39:42,940
their function they just have to choose

993
00:39:40,360 --> 00:39:44,320
what virtual table they point to or

994
00:39:42,940 --> 00:39:46,510
maybe they don't point to the beginning

995
00:39:44,320 --> 00:39:48,280
of a virtual table maybe they point for

996
00:39:46,510 --> 00:39:50,020
entries above it so that when they use

997
00:39:48,280 --> 00:39:51,850
the index they end up at the function of

998
00:39:50,020 --> 00:39:55,140
their choosing even if it wasn't at the

999
00:39:51,850 --> 00:39:55,140
correct index to begin with

1000
00:40:02,960 --> 00:40:06,570
[Applause]

1001
00:40:10,910 --> 00:40:12,970
you

