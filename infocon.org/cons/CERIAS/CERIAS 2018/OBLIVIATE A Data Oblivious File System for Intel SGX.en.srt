1
00:00:07,160 --> 00:00:14,820
so hi everyone and welcome to serious

2
00:00:11,880 --> 00:00:18,390
security seminar today I mean we have

3
00:00:14,820 --> 00:00:20,700
Dede our speaker is added ahmed ali rock

4
00:00:18,390 --> 00:00:23,789
ahmad is the second year

5
00:00:20,700 --> 00:00:26,310
tgd student at Purdue and I'm he's

6
00:00:23,789 --> 00:00:29,339
working on system security and today he

7
00:00:26,310 --> 00:00:32,820
gonna present his work on how we use the

8
00:00:29,339 --> 00:00:35,400
previous Ram to implement the EDD fast

9
00:00:32,820 --> 00:00:37,830
system especially for the Internet's GX

10
00:00:35,400 --> 00:00:42,989
so let me pass it to a deal to

11
00:00:37,830 --> 00:00:46,410
appreciate the paper thank you hi

12
00:00:42,989 --> 00:00:48,328
everyone I just said I my name is adilyn

13
00:00:46,410 --> 00:00:50,309
with I'm a second year PhD student being

14
00:00:48,329 --> 00:00:52,739
advised by Professor byung-hyun jury so

15
00:00:50,309 --> 00:00:55,800
my whole area of research is system

16
00:00:52,739 --> 00:00:57,718
security and my recent focus has been a

17
00:00:55,800 --> 00:01:00,180
lot on trusted hardware especially

18
00:00:57,719 --> 00:01:02,519
cyclin of education with interest rate

19
00:01:00,180 --> 00:01:03,989
hardware so I'm going to be presenting

20
00:01:02,519 --> 00:01:06,000
our paper

21
00:01:03,989 --> 00:01:08,210
obliviate a data oblivious file system

22
00:01:06,000 --> 00:01:12,420
for Intel SGX which is due to appear in

23
00:01:08,210 --> 00:01:15,539
n DSS during the next week so it's me

24
00:01:12,420 --> 00:01:17,990
along with my with other members of my

25
00:01:15,540 --> 00:01:21,689
group that from Purdue University who

26
00:01:17,990 --> 00:01:25,710
have authored this paper so let's begin

27
00:01:21,689 --> 00:01:27,508
so well cloud computing with the advent

28
00:01:25,710 --> 00:01:29,490
of cloud computing there have been a lot

29
00:01:27,509 --> 00:01:31,380
of there's been a lot of good things

30
00:01:29,490 --> 00:01:33,298
about cloud computing there's been a lot

31
00:01:31,380 --> 00:01:35,490
of threats and security issues about

32
00:01:33,299 --> 00:01:37,649
cloud computing so for example it's

33
00:01:35,490 --> 00:01:39,839
let's build on a very simple scenario

34
00:01:37,649 --> 00:01:42,659
let's say that there's a user who wants

35
00:01:39,840 --> 00:01:44,490
to store let's say some sort of trusted

36
00:01:42,659 --> 00:01:47,930
data some sort of sensitive data on

37
00:01:44,490 --> 00:01:52,679
cloud clouds now the problem is that

38
00:01:47,930 --> 00:01:55,200
public clouds you can name any they're

39
00:01:52,680 --> 00:01:58,680
not completely trusted right so the

40
00:01:55,200 --> 00:02:00,869
cloud provider has access to your to the

41
00:01:58,680 --> 00:02:02,549
Machine site runs out to you and then

42
00:02:00,869 --> 00:02:04,680
there are other tenants that are also

43
00:02:02,549 --> 00:02:06,539
sharing machines with you within the

44
00:02:04,680 --> 00:02:09,840
cloud so that means that there are a

45
00:02:06,539 --> 00:02:12,390
number of ways that other people the

46
00:02:09,840 --> 00:02:14,400
cloud provider or other tenants can sort

47
00:02:12,390 --> 00:02:17,579
of look into what you're doing and sort

48
00:02:14,400 --> 00:02:19,770
of leak out your sensitive information

49
00:02:17,580 --> 00:02:20,349
or whatever sensitive data that you've

50
00:02:19,770 --> 00:02:24,129
stored

51
00:02:20,349 --> 00:02:26,159
within the cloud so let's look at this

52
00:02:24,129 --> 00:02:30,189
scenario now you have the untrusted

53
00:02:26,159 --> 00:02:32,140
cloud provider the untrusted tenants so

54
00:02:30,189 --> 00:02:36,219
well that's why it draw straight

55
00:02:32,140 --> 00:02:38,200
hardware was sort of imagined right

56
00:02:36,219 --> 00:02:40,269
because the user is going to say ok let

57
00:02:38,200 --> 00:02:42,488
me use a trusted hardware and therefore

58
00:02:40,269 --> 00:02:45,040
using the trusted hardware I can sort of

59
00:02:42,489 --> 00:02:47,530
say that this is secure sort of say that

60
00:02:45,040 --> 00:02:50,500
whatever code or data I am running

61
00:02:47,530 --> 00:02:53,079
within the cluster or ohshit cloud is is

62
00:02:50,500 --> 00:02:54,790
secure and one such trusted Hardware is

63
00:02:53,079 --> 00:02:56,620
into SGX which has been recently

64
00:02:54,790 --> 00:02:58,780
commoditized recently it's been almost 2

65
00:02:56,620 --> 00:03:02,620
years so it's been commoditized by inter

66
00:02:58,780 --> 00:03:04,840
with the skylake architecture so what

67
00:03:02,620 --> 00:03:06,519
what a normal user is going to perceive

68
00:03:04,840 --> 00:03:08,019
with into less GX and other trusted

69
00:03:06,519 --> 00:03:09,669
hardware is that there is a trusted

70
00:03:08,019 --> 00:03:12,250
region within the clouds that is

71
00:03:09,669 --> 00:03:14,829
completely impenetrable by the cloud

72
00:03:12,250 --> 00:03:16,989
provider by other tenants by any sort of

73
00:03:14,829 --> 00:03:19,840
higher privilege or same privilege

74
00:03:16,989 --> 00:03:22,090
components so that is what a normal user

75
00:03:19,840 --> 00:03:26,680
is going to perceive of into SGX and

76
00:03:22,090 --> 00:03:29,019
other trusted hardware and it's going to

77
00:03:26,680 --> 00:03:30,280
say ok thanks a lot SGX that you know

78
00:03:29,019 --> 00:03:31,900
thanks a lot prostrate hardware

79
00:03:30,280 --> 00:03:35,199
everything is secure I'm going to live

80
00:03:31,900 --> 00:03:37,090
with live my life happily but bear with

81
00:03:35,199 --> 00:03:39,569
me when I say this that the real world

82
00:03:37,090 --> 00:03:42,669
is a bit more complicated than that

83
00:03:39,569 --> 00:03:44,349
so to understand to understand the

84
00:03:42,669 --> 00:03:46,900
complications that arise with trusted

85
00:03:44,349 --> 00:03:49,629
hardware such as intellect she acts you

86
00:03:46,900 --> 00:03:52,419
have to understand how Intel SGX works

87
00:03:49,629 --> 00:03:56,349
how what if what is what is intellect

88
00:03:52,419 --> 00:03:57,430
reacts so so so into LS GX so let's

89
00:03:56,349 --> 00:03:59,530
consider that when you're when a

90
00:03:57,430 --> 00:04:01,750
computer boots up you have your physical

91
00:03:59,530 --> 00:04:03,370
memory what the processor does with the

92
00:04:01,750 --> 00:04:05,560
physical memory is that it creates a

93
00:04:03,370 --> 00:04:07,750
very small region inside the physical

94
00:04:05,560 --> 00:04:10,540
memory which is called the EPC which is

95
00:04:07,750 --> 00:04:12,579
the enclave page cache where which is

96
00:04:10,540 --> 00:04:15,040
reserved during boot up so it is always

97
00:04:12,579 --> 00:04:16,840
random is period up so it's not going to

98
00:04:15,040 --> 00:04:19,000
be the same space but in your physical

99
00:04:16,839 --> 00:04:20,529
memory or your DRAM to be more

100
00:04:19,000 --> 00:04:22,089
particular there's going to be a very

101
00:04:20,529 --> 00:04:23,500
small space that's going to be trust

102
00:04:22,089 --> 00:04:25,750
that's going to be reserved by the

103
00:04:23,500 --> 00:04:28,719
processor and the processor is not going

104
00:04:25,750 --> 00:04:30,700
to allow any access onto this source

105
00:04:28,719 --> 00:04:33,880
this small memory region apart from

106
00:04:30,700 --> 00:04:34,150
apart from in a trusted state which we

107
00:04:33,880 --> 00:04:37,120
call

108
00:04:34,150 --> 00:04:39,969
the unclear state so and this trusted

109
00:04:37,120 --> 00:04:41,950
memory region is just 128 megabytes and

110
00:04:39,970 --> 00:04:43,840
that's obviously for performance reasons

111
00:04:41,950 --> 00:04:47,260
you don't want your hold Iran to be

112
00:04:43,840 --> 00:04:49,659
trusted because of ensuing properties so

113
00:04:47,260 --> 00:04:51,340
let's suppose so what what happens when

114
00:04:49,660 --> 00:04:53,560
so what do we say what is the Nestea X

115
00:04:51,340 --> 00:04:55,690
what is an xj x program how is it

116
00:04:53,560 --> 00:04:57,760
different from regular programs so the

117
00:04:55,690 --> 00:04:59,260
thing is well a regular program has its

118
00:04:57,760 --> 00:05:01,240
address space and you know they have

119
00:04:59,260 --> 00:05:04,930
their different components the stag

120
00:05:01,240 --> 00:05:07,180
keith etc etc so you can imagine that

121
00:05:04,930 --> 00:05:09,220
within within a regular programs address

122
00:05:07,180 --> 00:05:12,190
space you just sort of create another

123
00:05:09,220 --> 00:05:15,130
address space it is exactly the same as

124
00:05:12,190 --> 00:05:19,020
a regular program it also has its code

125
00:05:15,130 --> 00:05:22,420
stack heath etc regions and but it is

126
00:05:19,020 --> 00:05:24,880
trusted now it is a trusted region and

127
00:05:22,420 --> 00:05:27,550
all the memory pages allocated to this

128
00:05:24,880 --> 00:05:32,170
trusted region are only from from within

129
00:05:27,550 --> 00:05:34,960
the EPC so normally in a let's suppose

130
00:05:32,170 --> 00:05:36,850
in a normal inner normal program you can

131
00:05:34,960 --> 00:05:40,090
technically the operating system can

132
00:05:36,850 --> 00:05:42,640
technically allocate any page whatsoever

133
00:05:40,090 --> 00:05:44,650
from wherever in the physical memory but

134
00:05:42,640 --> 00:05:47,260
these unclear pages will always remain

135
00:05:44,650 --> 00:05:49,270
within the EPC so and the EPC is a

136
00:05:47,260 --> 00:05:51,370
trusted region where the process which

137
00:05:49,270 --> 00:05:53,169
the processor controls so that is where

138
00:05:51,370 --> 00:05:55,270
the whole notion of security comes from

139
00:05:53,170 --> 00:05:57,310
so what would happen is that there are

140
00:05:55,270 --> 00:05:58,780
system components even higher privileged

141
00:05:57,310 --> 00:06:01,570
system components like the operating

142
00:05:58,780 --> 00:06:04,330
system or the bios or vmm extractor etc

143
00:06:01,570 --> 00:06:05,950
hypervisors etc what's going to happen

144
00:06:04,330 --> 00:06:09,070
that these system components even if

145
00:06:05,950 --> 00:06:10,900
they try to access this certain memory

146
00:06:09,070 --> 00:06:13,150
region let's say the if you see memory

147
00:06:10,900 --> 00:06:14,859
region the processor is just not going

148
00:06:13,150 --> 00:06:19,179
to allow it so it's going to be access

149
00:06:14,860 --> 00:06:21,670
restricted by the s3x processor so in in

150
00:06:19,180 --> 00:06:24,640
that sense you've technically created a

151
00:06:21,670 --> 00:06:26,890
very secure space within your within

152
00:06:24,640 --> 00:06:29,140
your programs address address space

153
00:06:26,890 --> 00:06:31,390
where you can execute code where you can

154
00:06:29,140 --> 00:06:32,890
store your data and do whatever you want

155
00:06:31,390 --> 00:06:35,650
and sort of thing that you know

156
00:06:32,890 --> 00:06:38,919
everything is happening very smoothly

157
00:06:35,650 --> 00:06:40,840
and very securely so this is the this is

158
00:06:38,920 --> 00:06:43,530
a very brief overview of how Intel SGX

159
00:06:40,840 --> 00:06:47,020
works and how in the last X Pro programs

160
00:06:43,530 --> 00:06:48,280
operate so let's move ahead

161
00:06:47,020 --> 00:06:49,659
so now let's

162
00:06:48,280 --> 00:06:51,849
talk about the file system now like

163
00:06:49,660 --> 00:06:53,740
extra programs like any regular programs

164
00:06:51,850 --> 00:06:57,340
have to access file system have to

165
00:06:53,740 --> 00:06:59,500
access files and certain files etc so

166
00:06:57,340 --> 00:07:00,969
for example let's take three programs

167
00:06:59,500 --> 00:07:03,940
let's say let's take a database program

168
00:07:00,970 --> 00:07:06,160
a web server and a personal storage

169
00:07:03,940 --> 00:07:07,960
program like Dropbox and we say that you

170
00:07:06,160 --> 00:07:09,340
know this program has to access

171
00:07:07,960 --> 00:07:11,979
everything is stored in the form of

172
00:07:09,340 --> 00:07:15,070
files so we have to access files to

173
00:07:11,980 --> 00:07:18,520
write data to read data to read a query

174
00:07:15,070 --> 00:07:21,490
insert a query select a query etc etc so

175
00:07:18,520 --> 00:07:25,479
but now you can see that these are sort

176
00:07:21,490 --> 00:07:27,190
of unclear protected applications now

177
00:07:25,480 --> 00:07:29,620
they're going to try to access the disk

178
00:07:27,190 --> 00:07:33,250
to to access a file what's going to

179
00:07:29,620 --> 00:07:36,430
happen is unclear programs like all

180
00:07:33,250 --> 00:07:40,600
regular programs are ring three so bring

181
00:07:36,430 --> 00:07:43,419
three programs in the current operating

182
00:07:40,600 --> 00:07:45,760
system models cannot access the disk on

183
00:07:43,419 --> 00:07:47,919
their own that is why the operating

184
00:07:45,760 --> 00:07:49,570
system comes into play so you have to

185
00:07:47,919 --> 00:07:52,419
rely on the operating system which is a

186
00:07:49,570 --> 00:07:54,640
rings Eero system to actually access the

187
00:07:52,419 --> 00:07:57,070
disk like a regular like a regular

188
00:07:54,640 --> 00:07:59,409
program so well that creates a

189
00:07:57,070 --> 00:08:03,040
complication right because in in the

190
00:07:59,410 --> 00:08:04,720
trust in the threat model of SGX

191
00:08:03,040 --> 00:08:07,600
the operating system is technically

192
00:08:04,720 --> 00:08:11,200
controlled by the adversary I eat the

193
00:08:07,600 --> 00:08:13,000
the cloud provider so that that means

194
00:08:11,200 --> 00:08:14,710
that if you're if you're relying on a

195
00:08:13,000 --> 00:08:17,350
system that is controlled by an

196
00:08:14,710 --> 00:08:19,090
adversary for a certain for certain

197
00:08:17,350 --> 00:08:20,770
let's say application like for certain

198
00:08:19,090 --> 00:08:23,109
to access files for example in this

199
00:08:20,770 --> 00:08:25,090
scenario that means that definitely

200
00:08:23,110 --> 00:08:26,470
there is there is something that that is

201
00:08:25,090 --> 00:08:28,780
that would be a problem

202
00:08:26,470 --> 00:08:30,669
so for example the operating system

203
00:08:28,780 --> 00:08:32,289
which could potentially be adversarial

204
00:08:30,669 --> 00:08:34,329
what the operating system could do is it

205
00:08:32,289 --> 00:08:36,218
could simply log whatever system calls

206
00:08:34,330 --> 00:08:38,500
you make like for example it could log

207
00:08:36,219 --> 00:08:40,870
that you asked to open this file and

208
00:08:38,500 --> 00:08:42,549
then you ask to read a certain offset

209
00:08:40,870 --> 00:08:44,140
because all the system calls are

210
00:08:42,549 --> 00:08:45,849
definitely going to be handled by the

211
00:08:44,140 --> 00:08:47,140
operating system there is nothing

212
00:08:45,850 --> 00:08:49,390
preventing the operating system from

213
00:08:47,140 --> 00:08:51,850
knowing what exactly you're doing with

214
00:08:49,390 --> 00:08:53,170
which file and exact right sector what

215
00:08:51,850 --> 00:08:56,740
are you doing are you reading are you

216
00:08:53,170 --> 00:08:58,719
writing etc so this is a problem well as

217
00:08:56,740 --> 00:09:00,490
jakes has been now been there for almost

218
00:08:58,720 --> 00:09:02,410
two years so this is not a new problem

219
00:09:00,490 --> 00:09:05,350
people already know about this

220
00:09:02,410 --> 00:09:07,300
so what happens is that a lot of people

221
00:09:05,350 --> 00:09:08,800
in the akka in academic research they

222
00:09:07,300 --> 00:09:11,380
proposed a new file system which they

223
00:09:08,800 --> 00:09:13,359
call the in-memory file system so the

224
00:09:11,380 --> 00:09:15,519
in-memory file system is so is very

225
00:09:13,360 --> 00:09:18,600
similar what would happen is instead of

226
00:09:15,519 --> 00:09:21,579
reading from the operating system during

227
00:09:18,600 --> 00:09:24,190
program initialization what's going to

228
00:09:21,579 --> 00:09:26,380
work what the process is going to do is

229
00:09:24,190 --> 00:09:29,110
that it is going to preload all the

230
00:09:26,380 --> 00:09:31,600
required files into the unclip and save

231
00:09:29,110 --> 00:09:33,370
it within the enclave memory space so

232
00:09:31,600 --> 00:09:36,490
that means that for example if you have

233
00:09:33,370 --> 00:09:37,839
to access a dot txt and B dot txt you

234
00:09:36,490 --> 00:09:40,690
what are you going to do is you're going

235
00:09:37,839 --> 00:09:43,690
to just read the whole files into memory

236
00:09:40,690 --> 00:09:45,640
before program execution and you're just

237
00:09:43,690 --> 00:09:47,980
going to read everything we didn't write

238
00:09:45,640 --> 00:09:49,930
using inside in memory and then you and

239
00:09:47,980 --> 00:09:51,820
then when you are done when the program

240
00:09:49,930 --> 00:09:54,640
terminates you're just going to dump

241
00:09:51,820 --> 00:09:56,410
everything back to the disk again using

242
00:09:54,640 --> 00:09:58,149
system calls and the operating system

243
00:09:56,410 --> 00:09:59,620
the operating system but then the

244
00:09:58,149 --> 00:10:01,779
operating system technically doesn't

245
00:09:59,620 --> 00:10:03,940
really know what you've done within the

246
00:10:01,779 --> 00:10:08,560
execution frame because everything was

247
00:10:03,940 --> 00:10:11,350
executed within the trusted object so

248
00:10:08,560 --> 00:10:13,839
this is a this is one of the this is one

249
00:10:11,350 --> 00:10:14,470
of the proposed solutions to this

250
00:10:13,839 --> 00:10:18,279
problem

251
00:10:14,470 --> 00:10:20,529
however the problem comes about when you

252
00:10:18,279 --> 00:10:22,630
go into detail about STX and you

253
00:10:20,529 --> 00:10:25,570
understand that STX is not a completely

254
00:10:22,630 --> 00:10:28,450
trusted environment if STX had no side

255
00:10:25,570 --> 00:10:31,209
channel or it has no other sort of

256
00:10:28,450 --> 00:10:33,610
attack possible on it then this would be

257
00:10:31,209 --> 00:10:36,489
a kiss would be a very good solution yes

258
00:10:33,610 --> 00:10:38,290
but since there are side channels we

259
00:10:36,490 --> 00:10:41,380
also have to consider side channels in

260
00:10:38,290 --> 00:10:44,110
this in this scenario so this this work

261
00:10:41,380 --> 00:10:47,050
has been proposed by a bunch of OSGi

262
00:10:44,110 --> 00:10:49,390
papers over the course of two years so

263
00:10:47,050 --> 00:10:51,279
let's let's let's dive deep let's dive

264
00:10:49,390 --> 00:10:53,860
into the side channel attacks against

265
00:10:51,279 --> 00:10:56,500
SGX so there's there's an attack called

266
00:10:53,860 --> 00:10:58,000
the controlled channel attack so to

267
00:10:56,500 --> 00:11:00,399
understand this attack consider that the

268
00:10:58,000 --> 00:11:01,990
operating system siddur that in modern

269
00:11:00,399 --> 00:11:03,550
operating systems there is a concept of

270
00:11:01,990 --> 00:11:06,130
paging and there's a concept of page

271
00:11:03,550 --> 00:11:09,130
tables the page tables are accessed are

272
00:11:06,130 --> 00:11:11,020
accessible both to the processor end to

273
00:11:09,130 --> 00:11:12,699
the operating system so what would

274
00:11:11,020 --> 00:11:14,560
happen is that let's suppose you have

275
00:11:12,699 --> 00:11:15,579
this trusted filesystem library which is

276
00:11:14,560 --> 00:11:17,439
part of the in-memory

277
00:11:15,580 --> 00:11:19,420
file system that we just we just saw in

278
00:11:17,440 --> 00:11:20,920
the previous slides what would happen is

279
00:11:19,420 --> 00:11:23,349
that lets say the Enclave is trying to

280
00:11:20,920 --> 00:11:27,030
access certain blocks within this file

281
00:11:23,350 --> 00:11:29,440
within this memory region and then

282
00:11:27,030 --> 00:11:30,970
implicitly the processor is going to set

283
00:11:29,440 --> 00:11:32,680
the access pit because that's what the

284
00:11:30,970 --> 00:11:34,810
processor does and it's required for a

285
00:11:32,680 --> 00:11:37,150
lot of optimizations so in the page

286
00:11:34,810 --> 00:11:39,489
table it is going to set the access bit

287
00:11:37,150 --> 00:11:41,620
on that specific frame and it's going to

288
00:11:39,490 --> 00:11:44,740
say ok this this frame was accessed by

289
00:11:41,620 --> 00:11:47,860
this Enclave process so what would

290
00:11:44,740 --> 00:11:49,840
happen is it is set by the processor but

291
00:11:47,860 --> 00:11:52,780
again the operating system being

292
00:11:49,840 --> 00:11:55,240
all-powerful can actually view the page

293
00:11:52,780 --> 00:11:56,980
table so it knows exactly what pages

294
00:11:55,240 --> 00:11:58,810
were accessed so of course the

295
00:11:56,980 --> 00:12:01,300
granularity of pages is four kilobytes

296
00:11:58,810 --> 00:12:04,119
but sort of what would happen is you can

297
00:12:01,300 --> 00:12:06,599
still with the the Enclave would still

298
00:12:04,120 --> 00:12:09,580
sort of leak information as to exactly

299
00:12:06,600 --> 00:12:11,200
what part of the file was accessed let's

300
00:12:09,580 --> 00:12:13,240
suppose that this file starts from here

301
00:12:11,200 --> 00:12:16,390
then you can still figure out okay what

302
00:12:13,240 --> 00:12:18,130
offset or what granular in in some sort

303
00:12:16,390 --> 00:12:21,370
of granularity what offset of the file

304
00:12:18,130 --> 00:12:22,750
was accessed so this is one this is a

305
00:12:21,370 --> 00:12:24,610
control channel attack there's been two

306
00:12:22,750 --> 00:12:26,560
different papers that have talked about

307
00:12:24,610 --> 00:12:28,510
these attacks and have even talked about

308
00:12:26,560 --> 00:12:30,250
improved versions of these attacks one

309
00:12:28,510 --> 00:12:32,830
interesting thing to note about this

310
00:12:30,250 --> 00:12:35,710
attack is that this is a highly this is

311
00:12:32,830 --> 00:12:37,960
extremely noise is extremely noise free

312
00:12:35,710 --> 00:12:39,820
channel this is not like other it

313
00:12:37,960 --> 00:12:42,010
accesses this is something that you can

314
00:12:39,820 --> 00:12:44,950
that the operating system can view can

315
00:12:42,010 --> 00:12:46,870
can technically view every page that was

316
00:12:44,950 --> 00:12:49,240
accessed by the Enclave sort of

317
00:12:46,870 --> 00:12:51,370
revealing that information outside the

318
00:12:49,240 --> 00:12:54,040
Enclave and the offer to the operating

319
00:12:51,370 --> 00:12:56,110
system so this is the control channel

320
00:12:54,040 --> 00:12:57,790
attack let's move on the second the

321
00:12:56,110 --> 00:12:59,860
second very important attack is the

322
00:12:57,790 --> 00:13:01,719
cache attack the cache attack is not

323
00:12:59,860 --> 00:13:03,600
really is not really a new attack it so

324
00:13:01,720 --> 00:13:07,140
it's it's always been there for almost

325
00:13:03,600 --> 00:13:09,670
more than 15 years now I guess so

326
00:13:07,140 --> 00:13:12,460
what what happens in the cache attack is

327
00:13:09,670 --> 00:13:14,110
like the cache architecture as you guys

328
00:13:12,460 --> 00:13:17,110
would always be would definitely be

329
00:13:14,110 --> 00:13:20,350
familiar is that all all processes

330
00:13:17,110 --> 00:13:21,790
Enclave or non Enclave SGX or non STX

331
00:13:20,350 --> 00:13:24,910
programs they all share the cache

332
00:13:21,790 --> 00:13:26,680
architecture so for example there is one

333
00:13:24,910 --> 00:13:29,920
attack that is called the prime plus

334
00:13:26,680 --> 00:13:33,489
probe attack where the attacker simply

335
00:13:29,920 --> 00:13:35,709
different cash sets in with its own data

336
00:13:33,490 --> 00:13:38,350
which is called the prime phase and then

337
00:13:35,709 --> 00:13:40,868
it lets the victim process which is in

338
00:13:38,350 --> 00:13:42,430
our case the unclear execute and what

339
00:13:40,869 --> 00:13:44,980
would happen is when the Enclave would

340
00:13:42,430 --> 00:13:47,679
access certain date set data then it

341
00:13:44,980 --> 00:13:50,559
would evict the attackers cash set and

342
00:13:47,679 --> 00:13:52,029
it would fill them with its own data so

343
00:13:50,559 --> 00:13:54,160
the next time around when the attacker

344
00:13:52,029 --> 00:13:57,339
is going to try to access its own data

345
00:13:54,160 --> 00:13:59,230
again so if the data had been evicted in

346
00:13:57,339 --> 00:14:00,339
the last cycle it's going to take much

347
00:13:59,230 --> 00:14:02,470
much long

348
00:14:00,339 --> 00:14:06,670
it's going to take a much longer time to

349
00:14:02,470 --> 00:14:07,990
actually access that data other other

350
00:14:06,670 --> 00:14:10,300
than the case that when it wasn't

351
00:14:07,990 --> 00:14:12,490
actually accessed so based on this

352
00:14:10,300 --> 00:14:15,609
information and this is this is a very

353
00:14:12,490 --> 00:14:18,670
this is this is a very possible attack

354
00:14:15,610 --> 00:14:20,740
that people have shown is is extremely

355
00:14:18,670 --> 00:14:23,199
possible because there is a huge

356
00:14:20,740 --> 00:14:25,480
difference between the probe times of an

357
00:14:23,199 --> 00:14:28,540
evicted data and a non evicted data and

358
00:14:25,480 --> 00:14:30,730
which you can measure using our DTSC or

359
00:14:28,540 --> 00:14:33,040
whatever clock cycle measuring or

360
00:14:30,730 --> 00:14:34,389
performance measuring counters so this

361
00:14:33,040 --> 00:14:36,579
is traditionally called the primeplus

362
00:14:34,389 --> 00:14:40,089
probe attack this is not as a specific

363
00:14:36,579 --> 00:14:42,699
attack this has been around for almost

364
00:14:40,089 --> 00:14:44,679
five six years but very recently there

365
00:14:42,699 --> 00:14:46,449
have been three very good papers who've

366
00:14:44,679 --> 00:14:48,970
actually shown that these attacks are

367
00:14:46,449 --> 00:14:51,790
even more poor even even more more

368
00:14:48,970 --> 00:14:54,790
potent in the s3x environment because

369
00:14:51,790 --> 00:14:56,679
now the operating system is untrusted

370
00:14:54,790 --> 00:14:59,290
and the operating system can do a lot of

371
00:14:56,679 --> 00:15:04,329
tricks to ensure that there is very

372
00:14:59,290 --> 00:15:06,459
little noise for this attack so let's

373
00:15:04,329 --> 00:15:08,979
move on so now we've now I've just

374
00:15:06,459 --> 00:15:11,709
talked about some major some to two very

375
00:15:08,980 --> 00:15:13,990
important attacks now let's say now I'm

376
00:15:11,709 --> 00:15:16,569
going to try to describe how these

377
00:15:13,990 --> 00:15:19,509
attacks can be carried out in principle

378
00:15:16,569 --> 00:15:21,670
how for example to illustrate our point

379
00:15:19,509 --> 00:15:24,040
what we did was we did a case study on

380
00:15:21,670 --> 00:15:26,920
sequel light which as you all know is a

381
00:15:24,040 --> 00:15:28,839
lightweight database program so let's

382
00:15:26,920 --> 00:15:30,910
suppose that the in this scenario there

383
00:15:28,839 --> 00:15:33,129
is a doctor or an insurance provider who

384
00:15:30,910 --> 00:15:34,959
is trying to access a patient's history

385
00:15:33,129 --> 00:15:37,149
now the patient's history is stored on a

386
00:15:34,959 --> 00:15:39,549
database in the cloud but the cloud

387
00:15:37,149 --> 00:15:41,920
provider says that okay you can have an

388
00:15:39,549 --> 00:15:43,560
extra X protected database now there are

389
00:15:41,920 --> 00:15:46,170
actually cloud providers

390
00:15:43,560 --> 00:15:50,640
were already who are actually giving SGX

391
00:15:46,170 --> 00:15:52,079
enclaves for to to their clients so in

392
00:15:50,640 --> 00:15:54,210
this scenario what happens is that the

393
00:15:52,080 --> 00:15:56,700
SP the database is technically SGX

394
00:15:54,210 --> 00:15:58,380
protected but the doctor is going to run

395
00:15:56,700 --> 00:16:02,250
a bunch of different queries and try to

396
00:15:58,380 --> 00:16:04,020
see ok what happens so let's so let's

397
00:16:02,250 --> 00:16:06,690
suppose that this database has let's say

398
00:16:04,020 --> 00:16:08,910
just the name and two columns there

399
00:16:06,690 --> 00:16:11,610
that's for the heart condition and the

400
00:16:08,910 --> 00:16:13,260
lung lung condition or something and the

401
00:16:11,610 --> 00:16:15,029
doctor is going to run different queries

402
00:16:13,260 --> 00:16:16,560
on crime I'm trying to find okay for

403
00:16:15,029 --> 00:16:18,300
example what is this guy is heart

404
00:16:16,560 --> 00:16:21,540
condition what is this guy's lungs it's

405
00:16:18,300 --> 00:16:26,310
pretty exact right cetera to sort of do

406
00:16:21,540 --> 00:16:28,890
a proper diagnosis so this is um so for

407
00:16:26,310 --> 00:16:31,020
example in in our test in our test

408
00:16:28,890 --> 00:16:33,449
database what what happens is that in

409
00:16:31,020 --> 00:16:35,750
the first query let's suppose that the

410
00:16:33,450 --> 00:16:39,810
doctor asked for Bob's heart history

411
00:16:35,750 --> 00:16:41,700
then in that scenario what sequel light

412
00:16:39,810 --> 00:16:43,589
is going to do is it's going to go into

413
00:16:41,700 --> 00:16:45,690
the role that corresponds to Bob I'm

414
00:16:43,589 --> 00:16:49,530
going to access its heart eastery and

415
00:16:45,690 --> 00:16:52,320
going to return that data to the doctor

416
00:16:49,530 --> 00:16:54,780
so let's suppose that we do a syscall

417
00:16:52,320 --> 00:16:57,120
based attack which is for the native

418
00:16:54,780 --> 00:16:59,189
file system so in this scenario you can

419
00:16:57,120 --> 00:17:01,860
see that the attacker already knows that

420
00:16:59,190 --> 00:17:04,020
okay and this this Enclave tried to

421
00:17:01,860 --> 00:17:07,410
access this database which is mint or DB

422
00:17:04,020 --> 00:17:09,599
and try to read these these three and

423
00:17:07,410 --> 00:17:11,310
these three offsets now the first two

424
00:17:09,599 --> 00:17:14,310
the line two and three four simply

425
00:17:11,310 --> 00:17:16,290
correspond to meta data that that is

426
00:17:14,310 --> 00:17:18,688
always accessed whenever a sequel ID

427
00:17:16,290 --> 00:17:20,970
database server starts so the first and

428
00:17:18,689 --> 00:17:23,970
the last one corresponds to the offset

429
00:17:20,970 --> 00:17:26,069
of the row so that is simply that simply

430
00:17:23,970 --> 00:17:28,500
says that if the first two if we exclude

431
00:17:26,069 --> 00:17:30,750
the first two then we simply just access

432
00:17:28,500 --> 00:17:35,100
the seventh seventh row within this

433
00:17:30,750 --> 00:17:37,770
database because each row here is so

434
00:17:35,100 --> 00:17:41,969
because because each row is eight

435
00:17:37,770 --> 00:17:44,150
kilobytes right the third third entry so

436
00:17:41,970 --> 00:17:46,950
similarly using the page table attack

437
00:17:44,150 --> 00:17:49,860
you can you can similarly get very

438
00:17:46,950 --> 00:17:52,770
similar very very similar traces so the

439
00:17:49,860 --> 00:17:55,649
attacker definitely sees that okay the

440
00:17:52,770 --> 00:17:57,539
first two are are very close to each

441
00:17:55,650 --> 00:17:59,850
other are right only four

442
00:17:57,539 --> 00:18:02,999
might add only four kilobyte offsets and

443
00:17:59,850 --> 00:18:05,879
the next one has a specific X offset and

444
00:18:02,999 --> 00:18:08,639
based on on these traces the attacker

445
00:18:05,879 --> 00:18:10,289
can know okay based on multiple runs

446
00:18:08,639 --> 00:18:12,508
what the attack would find out okay this

447
00:18:10,289 --> 00:18:14,999
is where the database starts from and at

448
00:18:12,509 --> 00:18:17,399
this offset was the access perpetrated

449
00:18:14,999 --> 00:18:20,190
so that means that this entry was

450
00:18:17,399 --> 00:18:22,109
accessed and since the entry since again

451
00:18:20,190 --> 00:18:24,509
if let's say the doctor runs the query

452
00:18:22,109 --> 00:18:27,059
again a second time it's going to still

453
00:18:24,509 --> 00:18:28,889
be the same it's going to still give the

454
00:18:27,059 --> 00:18:30,690
same memory traces because of course

455
00:18:28,889 --> 00:18:33,478
that's how file is read there is no

456
00:18:30,690 --> 00:18:35,429
randomization or anything so the next

457
00:18:33,479 --> 00:18:37,080
time around even on the second run it's

458
00:18:35,429 --> 00:18:39,389
going to be the same query it's going to

459
00:18:37,080 --> 00:18:40,739
be the same memory traces then suppose

460
00:18:39,389 --> 00:18:44,248
that there is a second query that would

461
00:18:40,739 --> 00:18:46,710
happen where so what would happen is

462
00:18:44,249 --> 00:18:49,859
let's say the doctor asked for Alice's

463
00:18:46,710 --> 00:18:51,749
lung his lungs history so now the lungs

464
00:18:49,859 --> 00:18:53,849
history is the second is this

465
00:18:51,749 --> 00:18:56,009
technically the third column so sick

466
00:18:53,849 --> 00:18:58,349
polite always goes column by column

467
00:18:56,009 --> 00:19:00,570
until it finds the required column so

468
00:18:58,349 --> 00:19:02,609
that's how sequel ID operates so based

469
00:19:00,570 --> 00:19:06,029
on this what would happen is again the

470
00:19:02,609 --> 00:19:07,470
first two reads correspond to the two

471
00:19:06,029 --> 00:19:09,539
reading the manner data which is the

472
00:19:07,470 --> 00:19:12,179
first and second page of the file and

473
00:19:09,539 --> 00:19:14,789
the the next two correspond to whatever

474
00:19:12,179 --> 00:19:17,159
you want to access so it is 4 0 9 6 0

475
00:19:14,789 --> 00:19:19,379
here and the next page here and again

476
00:19:17,159 --> 00:19:20,999
using page table based attacks you get

477
00:19:19,379 --> 00:19:23,399
the same memory traces you get the same

478
00:19:20,999 --> 00:19:26,009
addresses and based on multiple runs you

479
00:19:23,399 --> 00:19:27,330
can figure out exactly you can you don't

480
00:19:26,009 --> 00:19:29,099
really know what the query means of

481
00:19:27,330 --> 00:19:33,119
course let's we because we assume that

482
00:19:29,099 --> 00:19:36,539
the that this is an SGX protected in

483
00:19:33,119 --> 00:19:38,549
memory filesystem but you but you still

484
00:19:36,539 --> 00:19:40,649
know that ok for example this guy was

485
00:19:38,549 --> 00:19:42,479
trying to access this entry and this

486
00:19:40,649 --> 00:19:44,939
entry corresponds to this IP address

487
00:19:42,479 --> 00:19:49,139
which can still be used to correlate to

488
00:19:44,940 --> 00:19:53,700
sort of leak out some information which

489
00:19:49,139 --> 00:19:56,158
is not really ideal in our scenario so

490
00:19:53,700 --> 00:19:57,599
this is sort of a very simplistic attack

491
00:19:56,159 --> 00:19:59,789
and of course there are limitations to

492
00:19:57,599 --> 00:20:01,649
this attack because number one of the

493
00:19:59,789 --> 00:20:03,179
page table attack is just four kilobytes

494
00:20:01,649 --> 00:20:05,359
in granularity so that means that

495
00:20:03,179 --> 00:20:07,830
whatever you learn would be if your

496
00:20:05,359 --> 00:20:09,779
queries are smaller than four kilobytes

497
00:20:07,830 --> 00:20:10,679
then you would still have more noise

498
00:20:09,779 --> 00:20:12,690
then you would not

499
00:20:10,680 --> 00:20:14,730
you know exactly which query it is but

500
00:20:12,690 --> 00:20:19,410
again this is just to illustrate a point

501
00:20:14,730 --> 00:20:21,810
using our test database so the question

502
00:20:19,410 --> 00:20:23,280
now the question comes that okay we we

503
00:20:21,810 --> 00:20:24,720
understand that there are side channels

504
00:20:23,280 --> 00:20:27,270
this the side channels are not really

505
00:20:24,720 --> 00:20:30,600
new the first paper again that proposed

506
00:20:27,270 --> 00:20:33,120
the control channel attacks was was

507
00:20:30,600 --> 00:20:36,090
presented in 2014 in the 2014 Auckland

508
00:20:33,120 --> 00:20:38,699
so the question arises that what what

509
00:20:36,090 --> 00:20:42,780
exactly is the is the way of mitigating

510
00:20:38,700 --> 00:20:45,620
this threat so number one what what

511
00:20:42,780 --> 00:20:48,450
we've seen recently in in in research in

512
00:20:45,620 --> 00:20:50,820
conferences is that there's been a very

513
00:20:48,450 --> 00:20:52,890
particular focus on mitigating

514
00:20:50,820 --> 00:20:56,129
individual side channels individual

515
00:20:52,890 --> 00:20:58,530
memory base side channels which which I

516
00:20:56,130 --> 00:21:00,270
believe is a risky approach because

517
00:20:58,530 --> 00:21:02,370
there are always going to be more side

518
00:21:00,270 --> 00:21:05,129
channels and the way frustrate hardware

519
00:21:02,370 --> 00:21:07,290
such as SGX is created it has to share

520
00:21:05,130 --> 00:21:09,570
some information with untrusted

521
00:21:07,290 --> 00:21:10,980
subsystems for performance reasons for a

522
00:21:09,570 --> 00:21:14,070
lot of other reasons for a lot of

523
00:21:10,980 --> 00:21:15,990
architectural reasons and historical

524
00:21:14,070 --> 00:21:19,169
reasons also so that means that if

525
00:21:15,990 --> 00:21:20,790
you're trying to if you're trying to fix

526
00:21:19,170 --> 00:21:23,250
individual side channels or you're

527
00:21:20,790 --> 00:21:25,710
trying to mask side channels especially

528
00:21:23,250 --> 00:21:27,930
memory base side channels it might not

529
00:21:25,710 --> 00:21:29,760
be such a good idea to do that because

530
00:21:27,930 --> 00:21:31,890
there are always going to be more than

531
00:21:29,760 --> 00:21:36,210
one side channels and you can't always

532
00:21:31,890 --> 00:21:38,280
fix all of them together so if you focus

533
00:21:36,210 --> 00:21:40,560
on one of them and try to fix them by

534
00:21:38,280 --> 00:21:42,270
masking them by ensuring that let's say

535
00:21:40,560 --> 00:21:45,510
you don't get the side channels outside

536
00:21:42,270 --> 00:21:48,480
the Enclave it is not really it's not

537
00:21:45,510 --> 00:21:51,150
really a very good idea I believe so

538
00:21:48,480 --> 00:21:53,250
so the thing is you have to realize is

539
00:21:51,150 --> 00:21:54,600
that memory base side channels or memory

540
00:21:53,250 --> 00:21:57,450
base side channels they rely on

541
00:21:54,600 --> 00:21:59,340
predictable access patterns so the

542
00:21:57,450 --> 00:22:01,260
pattern of access has to be predictable

543
00:21:59,340 --> 00:22:04,230
so that you know in multiple runs the

544
00:22:01,260 --> 00:22:06,570
attacker can correlate okay what exactly

545
00:22:04,230 --> 00:22:08,580
are you trying to access for example

546
00:22:06,570 --> 00:22:12,090
let's say you might want to access a

547
00:22:08,580 --> 00:22:14,460
cryptographic key or something so it

548
00:22:12,090 --> 00:22:16,260
does rely on predictable access patterns

549
00:22:14,460 --> 00:22:19,290
and without predictable access patterns

550
00:22:16,260 --> 00:22:22,560
it would be hard for it for for memory

551
00:22:19,290 --> 00:22:24,418
based side channels to be exploited then

552
00:22:22,560 --> 00:22:27,119
the question comes how

553
00:22:24,419 --> 00:22:30,059
do you provide generic and theoretically

554
00:22:27,119 --> 00:22:33,330
sound protections against predictable

555
00:22:30,059 --> 00:22:35,549
access pattern based attacks so we move

556
00:22:33,330 --> 00:22:37,908
on to a concept known as oblivious RAM

557
00:22:35,549 --> 00:22:40,470
which is a very famous cryptographic

558
00:22:37,909 --> 00:22:43,470
primitive that has been around for

559
00:22:40,470 --> 00:22:45,359
almost 20 years now so oblivious Ram is

560
00:22:43,470 --> 00:22:47,100
just to understand the threat model of

561
00:22:45,359 --> 00:22:49,710
oblivious ran when you have to

562
00:22:47,100 --> 00:22:51,959
understand a client-server model where

563
00:22:49,710 --> 00:22:54,149
this in the server which which is an

564
00:22:51,960 --> 00:22:56,220
untrusted cloud what the client is

565
00:22:54,149 --> 00:22:58,049
trying to store is let's say some some

566
00:22:56,220 --> 00:23:01,499
sort of data that the client is trying

567
00:22:58,049 --> 00:23:05,759
to store within the server and then the

568
00:23:01,499 --> 00:23:06,809
client wants to access that data in a in

569
00:23:05,759 --> 00:23:09,389
a secure manner

570
00:23:06,809 --> 00:23:11,100
so by secure manner what that means is

571
00:23:09,389 --> 00:23:14,939
that when I'm trying to access let's say

572
00:23:11,100 --> 00:23:16,619
block a the cloud provider or whatever

573
00:23:14,940 --> 00:23:19,200
tenant should not really be able to know

574
00:23:16,619 --> 00:23:21,509
exactly which block which data block was

575
00:23:19,200 --> 00:23:23,970
accessed so the users call is security

576
00:23:21,509 --> 00:23:26,039
but the attackers goal might be an it

577
00:23:23,970 --> 00:23:28,169
might be an potentially adversarial

578
00:23:26,039 --> 00:23:30,899
cloud so it wants to figure out exactly

579
00:23:28,169 --> 00:23:34,739
what you're trying to access so this is

580
00:23:30,899 --> 00:23:36,928
a the model of of the English Ram so

581
00:23:34,739 --> 00:23:40,169
path or M is an improved version of

582
00:23:36,929 --> 00:23:44,330
oblivious Ram that was proposed in 2012

583
00:23:40,169 --> 00:23:47,399
by mu stefanov who was a Purdue graduate

584
00:23:44,330 --> 00:23:50,939
so it's an improved version of path of

585
00:23:47,399 --> 00:23:53,969
oblivious Ram that uses a tree based or

586
00:23:50,940 --> 00:23:55,919
am scheme so in this scenario over here

587
00:23:53,970 --> 00:23:58,649
at the server end you have all your

588
00:23:55,919 --> 00:24:01,470
blocks all your users blocks which are

589
00:23:58,649 --> 00:24:04,168
shown in by the real blocks in the in

590
00:24:01,470 --> 00:24:06,389
the orange ones so you have different

591
00:24:04,169 --> 00:24:08,399
blocks over here but then you also have

592
00:24:06,389 --> 00:24:11,129
dummy blocks and you sort of have a tree

593
00:24:08,399 --> 00:24:12,809
formation where the number of real

594
00:24:11,129 --> 00:24:15,899
blocks in the tree is equal to the leaf

595
00:24:12,809 --> 00:24:17,940
of the tree as you can observe so that's

596
00:24:15,899 --> 00:24:20,969
that's how that's sort of a construction

597
00:24:17,940 --> 00:24:23,970
of the oblivious run of the oblivious

598
00:24:20,970 --> 00:24:26,100
Ram tree within the server and then on

599
00:24:23,970 --> 00:24:28,409
the client side you have you have a

600
00:24:26,100 --> 00:24:30,600
position map and you have a stash what

601
00:24:28,409 --> 00:24:33,539
the position map does it is that it

602
00:24:30,600 --> 00:24:36,689
simply holds whatever is the position of

603
00:24:33,539 --> 00:24:37,890
individual blocks of the client so for

604
00:24:36,690 --> 00:24:40,350
example a it

605
00:24:37,890 --> 00:24:43,590
says is stored at 0-0 so that means to

606
00:24:40,350 --> 00:24:46,560
access a you have to go through 0 and 0

607
00:24:43,590 --> 00:24:50,550
to get it so whatever the pot is it's

608
00:24:46,560 --> 00:24:52,290
stored over here for be again 0 1 so it

609
00:24:50,550 --> 00:24:53,850
doesn't really say exactly where it's

610
00:24:52,290 --> 00:24:55,409
stored it just says that this is the

611
00:24:53,850 --> 00:24:58,800
lease and you just have to access the

612
00:24:55,410 --> 00:25:01,920
whole pump so this stash is just a very

613
00:24:58,800 --> 00:25:03,330
small not a moderately small memory

614
00:25:01,920 --> 00:25:04,530
region where you're just going to store

615
00:25:03,330 --> 00:25:10,290
the plots that you're going to access

616
00:25:04,530 --> 00:25:11,790
from the from the server so let's let's

617
00:25:10,290 --> 00:25:13,770
let's have a look at how bathroom

618
00:25:11,790 --> 00:25:16,020
actually works so let's say your goal is

619
00:25:13,770 --> 00:25:18,090
to access block a so what would happen

620
00:25:16,020 --> 00:25:20,280
in this scenario is that first you would

621
00:25:18,090 --> 00:25:23,280
have so first the first phase is reading

622
00:25:20,280 --> 00:25:25,710
the block so first number one you're

623
00:25:23,280 --> 00:25:28,020
going to consult the position map to

624
00:25:25,710 --> 00:25:29,850
find out exactly where a is you can

625
00:25:28,020 --> 00:25:32,940
solve the position map it says it's at 0

626
00:25:29,850 --> 00:25:34,139
0 it says it's a leave 0 0 so now what

627
00:25:32,940 --> 00:25:38,160
you're going to do is you're going to

628
00:25:34,140 --> 00:25:40,920
obtain the whole path 0 0 and then save

629
00:25:38,160 --> 00:25:43,830
it in the stash which is again your

630
00:25:40,920 --> 00:25:45,510
trusted memory region now one thing to

631
00:25:43,830 --> 00:25:47,100
note here is that we've discarded the

632
00:25:45,510 --> 00:25:48,570
dummy blocks because we don't need those

633
00:25:47,100 --> 00:25:50,550
plots those dummy blocks were just to

634
00:25:48,570 --> 00:25:52,200
fool the attacker sorry one thing I

635
00:25:50,550 --> 00:25:54,419
forgot to mention is that the or am

636
00:25:52,200 --> 00:25:56,160
server is completely encrypted so the

637
00:25:54,420 --> 00:25:58,650
attacker does not know which block is

638
00:25:56,160 --> 00:26:00,270
real which block is dummy this is a

639
00:25:58,650 --> 00:26:01,710
knowledge that is only available to us

640
00:26:00,270 --> 00:26:04,440
it's not available to the attacker

641
00:26:01,710 --> 00:26:05,970
because everything is encrypted so we

642
00:26:04,440 --> 00:26:07,500
discarded the dummy blocks and we only

643
00:26:05,970 --> 00:26:09,090
stored the real block over here we know

644
00:26:07,500 --> 00:26:11,910
whatever operation we want to do with

645
00:26:09,090 --> 00:26:13,770
the with the plot so why is this secure

646
00:26:11,910 --> 00:26:15,690
the only reason this is secure is

647
00:26:13,770 --> 00:26:17,430
because you extracted multiple blocks

648
00:26:15,690 --> 00:26:19,470
when you only needed one of those blocks

649
00:26:17,430 --> 00:26:21,390
you extracted multiple blocks you

650
00:26:19,470 --> 00:26:22,980
extracted the whole path and since the

651
00:26:21,390 --> 00:26:24,630
attacker doesn't really know which which

652
00:26:22,980 --> 00:26:26,520
block is the real or which one is the

653
00:26:24,630 --> 00:26:28,680
dummy the attacker doesn't know which

654
00:26:26,520 --> 00:26:30,810
block did you actually want to access so

655
00:26:28,680 --> 00:26:33,240
multiple blocks extracted actually hide

656
00:26:30,810 --> 00:26:35,820
the the required block whatever block

657
00:26:33,240 --> 00:26:38,190
was required so let's move on now this

658
00:26:35,820 --> 00:26:40,320
is secure now we can I hope you guys can

659
00:26:38,190 --> 00:26:43,230
all see that this is somehow secure

660
00:26:40,320 --> 00:26:45,510
because now you've extracted multiple

661
00:26:43,230 --> 00:26:47,700
blocks but the problem is if we keep

662
00:26:45,510 --> 00:26:49,740
with this and we do this again the next

663
00:26:47,700 --> 00:26:51,570
time then we would still leak the same

664
00:26:49,740 --> 00:26:54,420
information right if we again

665
00:26:51,570 --> 00:26:56,520
- to obtain block a we read parts zero

666
00:26:54,420 --> 00:26:58,680
and zero then there is no security

667
00:26:56,520 --> 00:27:00,510
because then again the attacker would

668
00:26:58,680 --> 00:27:03,000
know okay this is the same path that was

669
00:27:00,510 --> 00:27:04,560
accessed before so it must be the same

670
00:27:03,000 --> 00:27:07,410
block I don't know what block it is but

671
00:27:04,560 --> 00:27:09,750
it must be the same block so this is uh

672
00:27:07,410 --> 00:27:11,310
this is that now without that would then

673
00:27:09,750 --> 00:27:17,100
defeat our purpose of actually having

674
00:27:11,310 --> 00:27:18,990
all this complex structure so now what

675
00:27:17,100 --> 00:27:22,230
is our goal our goal is to write back

676
00:27:18,990 --> 00:27:23,880
the block in a random fashion to ensure

677
00:27:22,230 --> 00:27:25,560
that the next time we read the attacker

678
00:27:23,880 --> 00:27:27,960
can still not correlate what block it

679
00:27:25,560 --> 00:27:29,280
was so we're going to randomize the

680
00:27:27,960 --> 00:27:32,010
position of the block that we just

681
00:27:29,280 --> 00:27:34,740
extracted a was zero zero before now it

682
00:27:32,010 --> 00:27:36,660
changed from one zero and so this was

683
00:27:34,740 --> 00:27:39,570
just random any random position it could

684
00:27:36,660 --> 00:27:41,130
be any any leaf position here and then

685
00:27:39,570 --> 00:27:43,320
we're going to get it from the stash and

686
00:27:41,130 --> 00:27:45,150
write it back into the tree according to

687
00:27:43,320 --> 00:27:48,060
the new position so since the new

688
00:27:45,150 --> 00:27:50,040
position was one zero the only place in

689
00:27:48,060 --> 00:27:52,200
the aram tree that this block would go

690
00:27:50,040 --> 00:27:54,960
was the root node because that is the

691
00:27:52,200 --> 00:27:57,750
only one that is within the path of one

692
00:27:54,960 --> 00:27:59,460
zero again the interest the important

693
00:27:57,750 --> 00:28:02,460
thing is we wrote back to the exact same

694
00:27:59,460 --> 00:28:05,100
path that we read from so we read from

695
00:28:02,460 --> 00:28:07,320
here and we're writing back again on the

696
00:28:05,100 --> 00:28:08,699
same path we can't freely write back to

697
00:28:07,320 --> 00:28:10,350
a random path because that would again

698
00:28:08,700 --> 00:28:12,900
leak some information we write back to

699
00:28:10,350 --> 00:28:15,240
the to the same path but we ensure that

700
00:28:12,900 --> 00:28:17,190
we write it back to the position again

701
00:28:15,240 --> 00:28:19,470
this is the root node here to the

702
00:28:17,190 --> 00:28:22,680
position where it should be according to

703
00:28:19,470 --> 00:28:25,440
whatever randomized position we got one

704
00:28:22,680 --> 00:28:27,720
zero so then we write back the blog at

705
00:28:25,440 --> 00:28:29,730
random position - technically randomized

706
00:28:27,720 --> 00:28:31,500
next access so the next time we're going

707
00:28:29,730 --> 00:28:33,390
to access a let's suppose we have to

708
00:28:31,500 --> 00:28:36,870
access again what would happen is we

709
00:28:33,390 --> 00:28:39,570
would simply be reading the path 1 0 and

710
00:28:36,870 --> 00:28:41,280
not 0 0 again so now the attacker

711
00:28:39,570 --> 00:28:43,770
doesn't know that whether this one 0

712
00:28:41,280 --> 00:28:46,110
corresponds to block another block or

713
00:28:43,770 --> 00:28:47,850
this block or whatever so the attacker

714
00:28:46,110 --> 00:28:50,149
doesn't learn any interesting

715
00:28:47,850 --> 00:28:52,770
information out of this out of our

716
00:28:50,150 --> 00:28:55,980
access step and the next time again it

717
00:28:52,770 --> 00:28:57,629
is random so it is it is again secure

718
00:28:55,980 --> 00:28:59,940
there is a whole description of why this

719
00:28:57,630 --> 00:29:03,240
is secure in the path or and paper if

720
00:28:59,940 --> 00:29:05,400
you guys are interested um so now we're

721
00:29:03,240 --> 00:29:08,100
going to go into what might

722
00:29:05,400 --> 00:29:09,300
is about and what our well after

723
00:29:08,100 --> 00:29:11,969
building this diagram we would now

724
00:29:09,300 --> 00:29:14,700
discuss what obliviate is so oblivious

725
00:29:11,970 --> 00:29:18,680
as is technically a memory charm in the

726
00:29:14,700 --> 00:29:23,490
Harry Potter series that allows you to

727
00:29:18,680 --> 00:29:26,100
simpler the wizard to sort of make the

728
00:29:23,490 --> 00:29:28,590
other person forget what happened so I

729
00:29:26,100 --> 00:29:31,080
know this is the usage of this term in

730
00:29:28,590 --> 00:29:32,879
this paper is very loose because yeah

731
00:29:31,080 --> 00:29:35,370
the Nerds are going to say that this is

732
00:29:32,880 --> 00:29:38,160
not technically the right usage but I

733
00:29:35,370 --> 00:29:41,370
really like the incantation and I won't

734
00:29:38,160 --> 00:29:42,900
apologize for that so so if you guys

735
00:29:41,370 --> 00:29:44,489
remember this scene from Harry Potter

736
00:29:42,900 --> 00:29:46,320
I'm hoping everyone has seen Harry

737
00:29:44,490 --> 00:29:48,960
Potter and otherwise you should

738
00:29:46,320 --> 00:29:51,540
definitely go see it right now so what

739
00:29:48,960 --> 00:29:54,300
happened is that a hermione is trying to

740
00:29:51,540 --> 00:29:55,770
use that incantation on her parents so

741
00:29:54,300 --> 00:29:57,690
that you know her parents forget about

742
00:29:55,770 --> 00:30:00,360
her and Lord Voldemort can not

743
00:29:57,690 --> 00:30:03,240
technically mess with them and they move

744
00:30:00,360 --> 00:30:04,500
to Australia or someplace free from or

745
00:30:03,240 --> 00:30:06,390
Canada or whatever

746
00:30:04,500 --> 00:30:08,929
someplace free from Lord Voldemort's

747
00:30:06,390 --> 00:30:11,640
influence somewhere away from London so

748
00:30:08,929 --> 00:30:13,650
in in our scenario what we're trying to

749
00:30:11,640 --> 00:30:15,630
say is that you know hermione again is

750
00:30:13,650 --> 00:30:17,460
going to say obliviate or whatever we're

751
00:30:15,630 --> 00:30:19,800
saying obliviate and we want the

752
00:30:17,460 --> 00:30:21,480
operating system which is exploiting all

753
00:30:19,800 --> 00:30:24,178
these side channels to sort of

754
00:30:21,480 --> 00:30:26,640
technically start trying and not be very

755
00:30:24,179 --> 00:30:29,970
happy with his or her life anymore

756
00:30:26,640 --> 00:30:32,100
the attackers so oblivion is technically

757
00:30:29,970 --> 00:30:35,970
a memory charm against the operating

758
00:30:32,100 --> 00:30:37,439
system and in this scenario for so let

759
00:30:35,970 --> 00:30:39,900
me go through let me walk through

760
00:30:37,440 --> 00:30:42,179
exactly what obliviate would do and how

761
00:30:39,900 --> 00:30:44,970
its secure it would secure everything so

762
00:30:42,179 --> 00:30:47,280
this is sort of a walkthrough slide so

763
00:30:44,970 --> 00:30:49,950
in this scenario the program again you

764
00:30:47,280 --> 00:30:51,928
have us you have any specific program

765
00:30:49,950 --> 00:30:55,110
you can think of sequel light light TBD

766
00:30:51,929 --> 00:30:57,480
whatever web servers etc so it has there

767
00:30:55,110 --> 00:31:00,270
is a trusted proxy we install a trusted

768
00:30:57,480 --> 00:31:02,690
proxy inside the Enclave program which

769
00:31:00,270 --> 00:31:06,030
is going to intercept the system calls

770
00:31:02,690 --> 00:31:07,890
provided by the program and it's going

771
00:31:06,030 --> 00:31:10,139
to encrypt them and send them to

772
00:31:07,890 --> 00:31:12,270
obliviate it's going to send them to

773
00:31:10,140 --> 00:31:13,980
obliviate obliviate is another Enclave

774
00:31:12,270 --> 00:31:16,320
so these are two separate enclaves here

775
00:31:13,980 --> 00:31:18,840
and obliviate is responsible for

776
00:31:16,320 --> 00:31:20,700
handling all file system operations what

777
00:31:18,840 --> 00:31:22,709
this application is going to do is this

778
00:31:20,700 --> 00:31:24,990
is that it is just going to take the

779
00:31:22,710 --> 00:31:27,120
messages encrypt the message the message

780
00:31:24,990 --> 00:31:29,280
by the messages I mean the system calls

781
00:31:27,120 --> 00:31:31,590
whatever system calls it wants and it's

782
00:31:29,280 --> 00:31:33,389
going to send them to obliviate using

783
00:31:31,590 --> 00:31:36,050
encrypted I using encrypted

784
00:31:33,390 --> 00:31:39,960
inter-process communication so again

785
00:31:36,050 --> 00:31:42,149
after it sends it there in in the the

786
00:31:39,960 --> 00:31:44,940
obliviate which is again an enclave we

787
00:31:42,150 --> 00:31:46,620
have our trusted service we're just

788
00:31:44,940 --> 00:31:48,570
going to bridge sort of bridge the gap

789
00:31:46,620 --> 00:31:51,540
between file system operations and aram

790
00:31:48,570 --> 00:31:53,490
now aram as we just saw was very

791
00:31:51,540 --> 00:31:55,889
simplistic in its model whereas file

792
00:31:53,490 --> 00:31:58,500
system has a few complex operations that

793
00:31:55,890 --> 00:32:00,150
you have to do so to bridge the gap we

794
00:31:58,500 --> 00:32:02,700
have a trusted service that runs within

795
00:32:00,150 --> 00:32:04,800
the Enclave and then we provide we

796
00:32:02,700 --> 00:32:06,440
provision it further to actually make

797
00:32:04,800 --> 00:32:09,419
sure that it doesn't leave information

798
00:32:06,440 --> 00:32:12,600
we sort of use data oblivious Manor data

799
00:32:09,420 --> 00:32:14,820
handling by which we ensure that site

800
00:32:12,600 --> 00:32:16,439
channel leakage the site channels do not

801
00:32:14,820 --> 00:32:19,200
actually leak information from our

802
00:32:16,440 --> 00:32:21,810
implementation and then we access the

803
00:32:19,200 --> 00:32:24,900
Orang server to get the blocks in an

804
00:32:21,810 --> 00:32:26,250
orange fashion so at the end what you're

805
00:32:24,900 --> 00:32:28,380
doing is you're actually accessing

806
00:32:26,250 --> 00:32:31,620
multiple blocks using the orang

807
00:32:28,380 --> 00:32:33,780
operations instead of accessing one so

808
00:32:31,620 --> 00:32:35,399
again this Orem tree has been filled

809
00:32:33,780 --> 00:32:39,330
with whatever files you are going to

810
00:32:35,400 --> 00:32:42,090
need so it is technically it is

811
00:32:39,330 --> 00:32:44,189
technically an in-memory filesystem but

812
00:32:42,090 --> 00:32:46,679
but it's different in this aspect that

813
00:32:44,190 --> 00:32:49,680
we are sort of going to ensure that each

814
00:32:46,680 --> 00:32:53,190
operation is done using or an access so

815
00:32:49,680 --> 00:32:54,720
that it is technically this technically

816
00:32:53,190 --> 00:32:58,620
oblivious to the underlying operating

817
00:32:54,720 --> 00:33:00,270
system so first point of obliviate the

818
00:32:58,620 --> 00:33:02,909
first point of this filesystem is that

819
00:33:00,270 --> 00:33:04,950
as all legacy file systems in Linux and

820
00:33:02,910 --> 00:33:06,780
windows etc we're going to decouple the

821
00:33:04,950 --> 00:33:08,310
filesystem support from the Enclave

822
00:33:06,780 --> 00:33:11,040
application we don't want the

823
00:33:08,310 --> 00:33:14,100
application to be handling the files on

824
00:33:11,040 --> 00:33:16,050
its own because again the whole point of

825
00:33:14,100 --> 00:33:18,030
having this sort of a system having

826
00:33:16,050 --> 00:33:19,770
operating system in the operating system

827
00:33:18,030 --> 00:33:22,620
handling all this file system was for

828
00:33:19,770 --> 00:33:24,210
you is so that you you the program

829
00:33:22,620 --> 00:33:27,510
developer doesn't really have to bother

830
00:33:24,210 --> 00:33:29,160
about all this stuff and we're we're

831
00:33:27,510 --> 00:33:30,930
trying to follow the same model and we

832
00:33:29,160 --> 00:33:32,880
say that okay we have a bunch of

833
00:33:30,930 --> 00:33:34,830
different Enclave applications over here

834
00:33:32,880 --> 00:33:36,600
so all these Enclave applications are

835
00:33:34,830 --> 00:33:39,240
going to connect one single central

836
00:33:36,600 --> 00:33:41,159
point this central point of the rainbow

837
00:33:39,240 --> 00:33:43,110
obviously we have to ensure this is a

838
00:33:41,160 --> 00:33:45,450
secure communication which can be

839
00:33:43,110 --> 00:33:47,699
ensured between enclaves using different

840
00:33:45,450 --> 00:33:50,900
Hellman and then we have to make sure

841
00:33:47,700 --> 00:33:53,550
that oblivion this central point

842
00:33:50,900 --> 00:33:55,830
definitely handles all the file system

843
00:33:53,550 --> 00:33:58,680
operations all the file system calls in

844
00:33:55,830 --> 00:34:01,230
a secure manner so you so that we ensure

845
00:33:58,680 --> 00:34:04,350
that this so this is one central point

846
00:34:01,230 --> 00:34:06,270
and we put all the burden of creating

847
00:34:04,350 --> 00:34:08,549
completely secure file systems on this

848
00:34:06,270 --> 00:34:10,560
Enclave over here rather than individual

849
00:34:08,550 --> 00:34:12,690
enclaves having to do all this on their

850
00:34:10,560 --> 00:34:14,880
own so separate against the pressure of

851
00:34:12,690 --> 00:34:16,590
functions facilitates app development

852
00:34:14,880 --> 00:34:18,630
obviously so that the developer doesn't

853
00:34:16,590 --> 00:34:21,600
have to worry about all this stuff we

854
00:34:18,630 --> 00:34:23,970
handle it for them how do we do it that

855
00:34:21,600 --> 00:34:26,069
would we I'm going to explain now so

856
00:34:23,969 --> 00:34:27,569
another very important thing is they're

857
00:34:26,070 --> 00:34:29,520
supposed to be legacy application

858
00:34:27,570 --> 00:34:31,470
support so now we can't really expect

859
00:34:29,520 --> 00:34:32,730
the application developer and because

860
00:34:31,469 --> 00:34:34,469
there are so many applications already

861
00:34:32,730 --> 00:34:36,870
that are already being developed and can

862
00:34:34,469 --> 00:34:38,939
simply reported within SGX we don't want

863
00:34:36,870 --> 00:34:41,339
all those applications to technically

864
00:34:38,940 --> 00:34:43,620
have to change their whole source code

865
00:34:41,340 --> 00:34:46,230
to actually be able to support

866
00:34:43,620 --> 00:34:48,359
obliviate or the file or a secure file

867
00:34:46,230 --> 00:34:50,940
system so we're going to install a

868
00:34:48,360 --> 00:34:53,310
trusted proxy within the Enclave program

869
00:34:50,940 --> 00:34:55,080
which is a very small library of a

870
00:34:53,310 --> 00:34:57,420
couple of hundred lines of code that

871
00:34:55,080 --> 00:34:59,400
would just what it simply does it is

872
00:34:57,420 --> 00:35:01,230
going to intercept with whatever system

873
00:34:59,400 --> 00:35:02,850
calls especially file system related

874
00:35:01,230 --> 00:35:04,440
system calls it's going to intercept

875
00:35:02,850 --> 00:35:07,140
those system calls and encrypt those

876
00:35:04,440 --> 00:35:10,200
requests in in fixed size messages and

877
00:35:07,140 --> 00:35:12,720
going to send them through to obliviate

878
00:35:10,200 --> 00:35:14,730
now we use now user term here called

879
00:35:12,720 --> 00:35:16,770
exit Alice message queue interfaces

880
00:35:14,730 --> 00:35:19,230
which is sort of that

881
00:35:16,770 --> 00:35:20,940
so the unclear so to understand this you

882
00:35:19,230 --> 00:35:22,920
have to understand that the unclip can

883
00:35:20,940 --> 00:35:24,780
technically access the untrusted part

884
00:35:22,920 --> 00:35:28,680
but the untrusted part can not access

885
00:35:24,780 --> 00:35:30,420
the unsafe so since this is since there

886
00:35:28,680 --> 00:35:32,940
is a one-way traffic we ensure that the

887
00:35:30,420 --> 00:35:34,860
Enclave doesn't exactly exit the onkyo

888
00:35:32,940 --> 00:35:36,540
is still running in the background but

889
00:35:34,860 --> 00:35:39,210
we just make sure that we pass the

890
00:35:36,540 --> 00:35:41,310
messages through our message queue on to

891
00:35:39,210 --> 00:35:44,510
the untrusted part which is going to use

892
00:35:41,310 --> 00:35:46,290
shared memory interface already already

893
00:35:44,510 --> 00:35:49,230
implemented within more

894
00:35:46,290 --> 00:35:52,080
operating systems to send all the data

895
00:35:49,230 --> 00:35:53,760
through to the obliviate unclip which is

896
00:35:52,080 --> 00:35:57,660
going to handle all file system

897
00:35:53,760 --> 00:35:59,430
operations for you so again the second

898
00:35:57,660 --> 00:36:03,930
point is there should not be any changes

899
00:35:59,430 --> 00:36:06,600
from the application developer at all so

900
00:36:03,930 --> 00:36:09,270
the third part is how you secure file

901
00:36:06,600 --> 00:36:11,009
systems now so when you think about file

902
00:36:09,270 --> 00:36:12,930
systems there are two major things that

903
00:36:11,010 --> 00:36:15,030
you have to protect number one you have

904
00:36:12,930 --> 00:36:17,009
to protect what file was accessed if you

905
00:36:15,030 --> 00:36:18,590
want to create a secure file system and

906
00:36:17,010 --> 00:36:21,090
number two you have to protect what

907
00:36:18,590 --> 00:36:23,910
offset within that file was actually

908
00:36:21,090 --> 00:36:25,770
accessed if you leak any sort any of

909
00:36:23,910 --> 00:36:27,870
these two informations then technically

910
00:36:25,770 --> 00:36:30,030
your file system is not secure then

911
00:36:27,870 --> 00:36:32,609
you're you are leaking some information

912
00:36:30,030 --> 00:36:34,170
and and different applications have

913
00:36:32,610 --> 00:36:36,300
different requirements for example you

914
00:36:34,170 --> 00:36:38,310
can have you can cover a web server a

915
00:36:36,300 --> 00:36:39,750
web server it's very important a web

916
00:36:38,310 --> 00:36:41,730
server we all know is going to read the

917
00:36:39,750 --> 00:36:43,380
application completely so it is much

918
00:36:41,730 --> 00:36:45,600
more important that you were able to

919
00:36:43,380 --> 00:36:48,090
secure which file was accessed which

920
00:36:45,600 --> 00:36:51,360
HTML file JavaScript etc was accessed

921
00:36:48,090 --> 00:36:53,010
rather than what offset was accessed

922
00:36:51,360 --> 00:36:55,560
because of course the whole file is

923
00:36:53,010 --> 00:36:59,190
going to be read for web servers in most

924
00:36:55,560 --> 00:37:00,509
scenarios so I aim for and the other end

925
00:36:59,190 --> 00:37:02,310
on the other hand we just saw an example

926
00:37:00,510 --> 00:37:04,590
of the synchronize database where we

927
00:37:02,310 --> 00:37:06,240
showed that the offset is the offset

928
00:37:04,590 --> 00:37:07,740
information is very important and we

929
00:37:06,240 --> 00:37:11,069
cannot leak the offset information

930
00:37:07,740 --> 00:37:16,020
either so what would happen is so each

931
00:37:11,070 --> 00:37:19,560
file is an is an or am tree so each file

932
00:37:16,020 --> 00:37:21,900
is broken down into a smaller or AM tree

933
00:37:19,560 --> 00:37:24,240
if for example like let's say it has

934
00:37:21,900 --> 00:37:25,890
this file has four blocks we break it

935
00:37:24,240 --> 00:37:28,379
down into four different blocks and

936
00:37:25,890 --> 00:37:30,089
create an or am tree out of it and then

937
00:37:28,380 --> 00:37:31,800
this single or am tree is going to

938
00:37:30,090 --> 00:37:33,540
protect file offset because again

939
00:37:31,800 --> 00:37:35,400
whenever you're going to access a

940
00:37:33,540 --> 00:37:38,790
specific offset we're going to ensure

941
00:37:35,400 --> 00:37:40,500
that you do one or M operation and no

942
00:37:38,790 --> 00:37:43,230
Ram access and then we have a

943
00:37:40,500 --> 00:37:46,350
hierarchical or Ram tree layout where

944
00:37:43,230 --> 00:37:49,800
each individual file is again around

945
00:37:46,350 --> 00:37:51,870
tree so again we're using the single

946
00:37:49,800 --> 00:37:54,840
using the single or am free you can

947
00:37:51,870 --> 00:37:56,850
protect the file offset using these this

948
00:37:54,840 --> 00:37:58,740
the second tier or Ram tree you can

949
00:37:56,850 --> 00:38:00,120
protect what what file exactly was

950
00:37:58,740 --> 00:38:02,310
accessed because then you can do

951
00:38:00,120 --> 00:38:04,560
another Orem operation on the larger

952
00:38:02,310 --> 00:38:08,009
tree to protect what file was accessed

953
00:38:04,560 --> 00:38:09,480
so at the end of the day what we ensure

954
00:38:08,010 --> 00:38:12,570
is that we're going to protect both the

955
00:38:09,480 --> 00:38:14,210
file and the file offset as a result of

956
00:38:12,570 --> 00:38:18,870
as a result of this

957
00:38:14,210 --> 00:38:20,910
so the perhaps the most important part

958
00:38:18,870 --> 00:38:23,279
is how do you secure or run because when

959
00:38:20,910 --> 00:38:26,279
if you remember or am we were we were

960
00:38:23,280 --> 00:38:28,560
doing we in the trusted memory region

961
00:38:26,280 --> 00:38:31,020
there was the position nap and the stash

962
00:38:28,560 --> 00:38:32,520
and the position map and the stash in in

963
00:38:31,020 --> 00:38:34,650
the traditional in the traditional

964
00:38:32,520 --> 00:38:37,650
around it is considered that both of

965
00:38:34,650 --> 00:38:39,480
these are in completely trusted memory

966
00:38:37,650 --> 00:38:41,370
regions where the attacker does not

967
00:38:39,480 --> 00:38:43,740
really know anything about what is

968
00:38:41,370 --> 00:38:45,509
happening then we can in in in those

969
00:38:43,740 --> 00:38:47,939
scenarios then it makes sense to just

970
00:38:45,510 --> 00:38:50,370
naively read everything but in scenarios

971
00:38:47,940 --> 00:38:53,550
for SD xs-2x already has so many side

972
00:38:50,370 --> 00:38:56,339
channels you can't really expect to - in

973
00:38:53,550 --> 00:38:59,850
securely read the stash all the position

974
00:38:56,340 --> 00:39:02,160
map and expect that it would be secure

975
00:38:59,850 --> 00:39:04,440
so for example let's suppose the stash

976
00:39:02,160 --> 00:39:07,529
you have to load from the stash and you

977
00:39:04,440 --> 00:39:09,600
have to send it to let's say the whoever

978
00:39:07,530 --> 00:39:11,280
asked for this plot then that means you

979
00:39:09,600 --> 00:39:13,350
have to go through this - and you have

980
00:39:11,280 --> 00:39:15,120
to send a specific you have to copy it

981
00:39:13,350 --> 00:39:17,819
from one memory location to another

982
00:39:15,120 --> 00:39:20,580
memory location so you have to load it

983
00:39:17,820 --> 00:39:22,860
from here but then again site channels

984
00:39:20,580 --> 00:39:27,060
in SGX are are going to be a hassle

985
00:39:22,860 --> 00:39:28,170
because now again you can in using using

986
00:39:27,060 --> 00:39:30,600
the side channels the attacker knows

987
00:39:28,170 --> 00:39:32,670
exactly which offset within the stash

988
00:39:30,600 --> 00:39:34,500
was accessed and which offset has been

989
00:39:32,670 --> 00:39:39,060
copied from this memory location to

990
00:39:34,500 --> 00:39:41,640
whatever a final destination location so

991
00:39:39,060 --> 00:39:43,590
this would again defeat the purpose

992
00:39:41,640 --> 00:39:45,210
again for the position math you have to

993
00:39:43,590 --> 00:39:48,030
consult the position map on each access

994
00:39:45,210 --> 00:39:50,190
you have to know exactly which index to

995
00:39:48,030 --> 00:39:52,170
access and if if the attacker knows what

996
00:39:50,190 --> 00:39:54,120
index within the position Matthew access

997
00:39:52,170 --> 00:39:56,880
the attacker knows which block you were

998
00:39:54,120 --> 00:39:59,700
you were getting from the from the

999
00:39:56,880 --> 00:40:01,370
server from the Aram trees so again that

1000
00:39:59,700 --> 00:40:04,620
would defeat the whole purpose of Aram

1001
00:40:01,370 --> 00:40:06,810
so to do this we use single single visa

1002
00:40:04,620 --> 00:40:09,000
is a x86 instruction which is called

1003
00:40:06,810 --> 00:40:11,549
conditional move so what see move is

1004
00:40:09,000 --> 00:40:13,470
going to do is that it is based on a

1005
00:40:11,550 --> 00:40:15,660
similar use a flag value based on

1006
00:40:13,470 --> 00:40:17,879
Schlag value it is either going to let's

1007
00:40:15,660 --> 00:40:19,589
say you have a and B memory locations so

1008
00:40:17,880 --> 00:40:23,670
based on the flag value it would either

1009
00:40:19,590 --> 00:40:25,320
copy a to B or it would not but if even

1010
00:40:23,670 --> 00:40:27,420
if it does or it does not it will

1011
00:40:25,320 --> 00:40:29,160
exhibit the exact same memory patterns

1012
00:40:27,420 --> 00:40:32,160
because it would access a and then

1013
00:40:29,160 --> 00:40:35,069
access P in this exact format but what

1014
00:40:32,160 --> 00:40:37,140
it would just do is is that it would

1015
00:40:35,070 --> 00:40:39,420
ensure that whatever the flag value is

1016
00:40:37,140 --> 00:40:42,150
it would either copy it from A to B or

1017
00:40:39,420 --> 00:40:43,830
it would not but again it would be it

1018
00:40:42,150 --> 00:40:46,050
would exhibit the same memory traces in

1019
00:40:43,830 --> 00:40:47,549
int so the attacker so any attacker that

1020
00:40:46,050 --> 00:40:50,000
is simply looking at memory traces

1021
00:40:47,550 --> 00:40:52,470
cannot really figure out what's going on

1022
00:40:50,000 --> 00:40:54,960
so using C move we're going to

1023
00:40:52,470 --> 00:40:57,029
technically access each index in the

1024
00:40:54,960 --> 00:41:00,030
position map and each index in the stash

1025
00:40:57,030 --> 00:41:01,710
and then and at the end of it what the

1026
00:41:00,030 --> 00:41:03,150
attacker sees is that all of them were

1027
00:41:01,710 --> 00:41:06,060
accessed the attacker doesn't really

1028
00:41:03,150 --> 00:41:08,130
know which one exactly it was this is I

1029
00:41:06,060 --> 00:41:10,440
admit an expensive operation but this is

1030
00:41:08,130 --> 00:41:11,910
required because unless you are able to

1031
00:41:10,440 --> 00:41:14,369
completely protect the stash and the

1032
00:41:11,910 --> 00:41:16,470
position map there is no point of using

1033
00:41:14,369 --> 00:41:18,540
or on because then you would be creating

1034
00:41:16,470 --> 00:41:21,359
a side channel in your M implementation

1035
00:41:18,540 --> 00:41:23,070
so this is a this is we're calling this

1036
00:41:21,359 --> 00:41:27,750
a side channel resistant or an

1037
00:41:23,070 --> 00:41:29,460
implementation and next part is it's

1038
00:41:27,750 --> 00:41:32,940
technically related to performance is

1039
00:41:29,460 --> 00:41:34,800
how we improve performance so so again

1040
00:41:32,940 --> 00:41:37,020
in the Orang model there is the client

1041
00:41:34,800 --> 00:41:38,849
there is the server so the OM client is

1042
00:41:37,020 --> 00:41:41,430
just a mere data information and a small

1043
00:41:38,849 --> 00:41:43,080
memory region to hold memory blocks so

1044
00:41:41,430 --> 00:41:44,879
it is a small region so it can

1045
00:41:43,080 --> 00:41:46,770
technically be fit within the Enclave

1046
00:41:44,880 --> 00:41:48,930
without much problem because it's a very

1047
00:41:46,770 --> 00:41:51,750
small feature if you remember the anchor

1048
00:41:48,930 --> 00:41:54,240
was just a 128 megabytes region so the

1049
00:41:51,750 --> 00:41:56,730
anchor does not have a lot of space the

1050
00:41:54,240 --> 00:41:58,049
anchor if does support paging but again

1051
00:41:56,730 --> 00:41:58,349
I would explain why that's not a good

1052
00:41:58,050 --> 00:42:02,250
idea

1053
00:41:58,349 --> 00:42:04,500
so so the metadata information which is

1054
00:42:02,250 --> 00:42:07,530
small and can be easily fixed with fit

1055
00:42:04,500 --> 00:42:09,810
within 128 megabytes you can just keep

1056
00:42:07,530 --> 00:42:12,690
them within the Enclave within the

1057
00:42:09,810 --> 00:42:14,849
Enclave but where's the Orang trees have

1058
00:42:12,690 --> 00:42:16,200
to be kept outside the Enclave in an

1059
00:42:14,849 --> 00:42:18,420
encrypted manner because they're

1060
00:42:16,200 --> 00:42:20,790
extremely large and they're going to be

1061
00:42:18,420 --> 00:42:25,190
more than gig gig above more than a few

1062
00:42:20,790 --> 00:42:26,330
gigabytes in memory in memory space so

1063
00:42:25,190 --> 00:42:28,130
okay

1064
00:42:26,330 --> 00:42:30,380
just to give you an illustration why

1065
00:42:28,130 --> 00:42:32,300
this is required so if you can see the

1066
00:42:30,380 --> 00:42:35,420
epc region is a small memory region

1067
00:42:32,300 --> 00:42:37,580
where the program might so as it as as a

1068
00:42:35,420 --> 00:42:39,590
as as regular programs if you remember

1069
00:42:37,580 --> 00:42:41,270
the regular programs have let's say you

1070
00:42:39,590 --> 00:42:43,160
have 16 gigabyte of D Ram

1071
00:42:41,270 --> 00:42:44,870
but your program might be using 32

1072
00:42:43,160 --> 00:42:46,910
megabytes of space so how does that

1073
00:42:44,870 --> 00:42:49,730
happen is because you have swapping you

1074
00:42:46,910 --> 00:42:52,790
can swap pages in and out of the disk so

1075
00:42:49,730 --> 00:42:55,880
similarly for SGX although this is just

1076
00:42:52,790 --> 00:42:57,560
a 128 megabytes space and our cliff can

1077
00:42:55,880 --> 00:43:00,620
technically use more than 128 megabytes

1078
00:42:57,560 --> 00:43:03,170
it can use 64 gigabytes of space how it

1079
00:43:00,620 --> 00:43:05,900
does that is simply that it simply swaps

1080
00:43:03,170 --> 00:43:08,570
in and out of the DRAM very similar to

1081
00:43:05,900 --> 00:43:11,690
how normal processes swap in and out of

1082
00:43:08,570 --> 00:43:14,150
disk the swapping in and out of DRAM is

1083
00:43:11,690 --> 00:43:16,250
a although much faster but it is still

1084
00:43:14,150 --> 00:43:19,370
very expensive and there's a whole paper

1085
00:43:16,250 --> 00:43:21,560
on it on how expensive Enclave exits are

1086
00:43:19,370 --> 00:43:24,080
due to swap in and swap out so if we

1087
00:43:21,560 --> 00:43:26,420
keep everything within the Enclave which

1088
00:43:24,080 --> 00:43:29,270
we technically can't it would be

1089
00:43:26,420 --> 00:43:32,420
extremely expensive and very very

1090
00:43:29,270 --> 00:43:35,090
performed and and not really friendly to

1091
00:43:32,420 --> 00:43:36,740
performance so as a result we use custom

1092
00:43:35,090 --> 00:43:39,770
encryption and ensure that the Oram

1093
00:43:36,740 --> 00:43:41,479
trees are stored outside the ampere so

1094
00:43:39,770 --> 00:43:42,890
encrypted or Ram trees are stored

1095
00:43:41,480 --> 00:43:46,370
outside Jung here for performance

1096
00:43:42,890 --> 00:43:48,920
reasons so leverage so this is the last

1097
00:43:46,370 --> 00:43:52,660
part of oblivion of the design of

1098
00:43:48,920 --> 00:43:55,610
obliviate so suppose that we're going to

1099
00:43:52,660 --> 00:43:57,620
do another performance improvement that

1100
00:43:55,610 --> 00:43:59,870
we thought about was to leverage a

1101
00:43:57,620 --> 00:44:02,060
synchronicity so what happens is let's

1102
00:43:59,870 --> 00:44:04,580
suppose you have a database application

1103
00:44:02,060 --> 00:44:07,250
that is going to say ok I need to read

1104
00:44:04,580 --> 00:44:09,170
this certain file at this certain offset

1105
00:44:07,250 --> 00:44:12,140
and it's going to send it's going to

1106
00:44:09,170 --> 00:44:14,300
send it to obliviate to our file system

1107
00:44:12,140 --> 00:44:16,339
but the file system so within the file

1108
00:44:14,300 --> 00:44:18,470
system we use two threads one one thread

1109
00:44:16,340 --> 00:44:20,810
is the front end thread that handles all

1110
00:44:18,470 --> 00:44:23,359
incoming requests one thread is the back

1111
00:44:20,810 --> 00:44:27,860
end thread that handles all the file

1112
00:44:23,360 --> 00:44:30,500
whatever request that it's that that the

1113
00:44:27,860 --> 00:44:32,510
application made so the front end thread

1114
00:44:30,500 --> 00:44:34,040
is just going to say to the it's just

1115
00:44:32,510 --> 00:44:37,130
going to ask the backend thread to read

1116
00:44:34,040 --> 00:44:38,630
whatever block it is and then the

1117
00:44:37,130 --> 00:44:40,099
backend thread is going to read it and

1118
00:44:38,630 --> 00:44:42,949
going to reply right

1119
00:44:40,099 --> 00:44:45,049
so we can just so by using this we can

1120
00:44:42,949 --> 00:44:47,150
ensure that we can leverage we can

1121
00:44:45,049 --> 00:44:48,979
ensure that right back is done by the

1122
00:44:47,150 --> 00:44:52,819
back end right whereas the front end

1123
00:44:48,979 --> 00:44:53,328
train provides the reply to the to the

1124
00:44:52,819 --> 00:44:55,009
user

1125
00:44:53,329 --> 00:44:57,319
so by doing this we are technically

1126
00:44:55,009 --> 00:44:59,539
saving log of n operations log of n

1127
00:44:57,319 --> 00:45:02,029
stoppage time because while this while

1128
00:44:59,539 --> 00:45:04,940
all file system calls are blocking so

1129
00:45:02,029 --> 00:45:08,329
that means that that that means that

1130
00:45:04,940 --> 00:45:10,670
definitely the program is waiting for

1131
00:45:08,329 --> 00:45:14,630
the request before it can resume

1132
00:45:10,670 --> 00:45:16,459
operation so yeah we're going to perform

1133
00:45:14,630 --> 00:45:18,529
asynchronous right back so the

1134
00:45:16,459 --> 00:45:21,259
implementation is using just the

1135
00:45:18,529 --> 00:45:23,150
interesti X software development kit

1136
00:45:21,259 --> 00:45:25,999
which has already been provided by in

1137
00:45:23,150 --> 00:45:28,849
winter we use graphene STX which is a

1138
00:45:25,999 --> 00:45:31,939
library operating system to run some

1139
00:45:28,849 --> 00:45:33,469
heavyweight applications to just you

1140
00:45:31,940 --> 00:45:35,059
should just think that the library

1141
00:45:33,469 --> 00:45:36,499
operating system is sort of like a very

1142
00:45:35,059 --> 00:45:39,589
small operating system within the

1143
00:45:36,499 --> 00:45:42,078
Enclave that provides functionality to

1144
00:45:39,589 --> 00:45:44,058
run heavy applications so performance

1145
00:45:42,079 --> 00:45:46,190
above all performance evaluation we we

1146
00:45:44,059 --> 00:45:47,959
took three reference file systems one is

1147
00:45:46,190 --> 00:45:50,299
the native file system which is just a

1148
00:45:47,959 --> 00:45:51,769
regular and Linux file system we use the

1149
00:45:50,299 --> 00:45:53,959
in-memory file system that I explained

1150
00:45:51,769 --> 00:45:56,238
at the start of this presentation and we

1151
00:45:53,959 --> 00:45:59,808
also use the obliviate or our own file

1152
00:45:56,239 --> 00:46:02,569
system so we use so we show eyes on

1153
00:45:59,809 --> 00:46:04,369
benchmarks and we can show that work

1154
00:46:02,569 --> 00:46:06,440
while comparing obliviate and the

1155
00:46:04,369 --> 00:46:08,329
in-memory file system the performances

1156
00:46:06,440 --> 00:46:10,880
are actually very similar so we have

1157
00:46:08,329 --> 00:46:12,650
very little overhead or less than three

1158
00:46:10,880 --> 00:46:14,359
times overhead I would say very little

1159
00:46:12,650 --> 00:46:16,339
but still less than three times overhead

1160
00:46:14,359 --> 00:46:18,049
against the in memory file system the

1161
00:46:16,339 --> 00:46:20,630
reason for that is that the in-memory

1162
00:46:18,049 --> 00:46:22,940
file system again is extremely slow if

1163
00:46:20,630 --> 00:46:26,119
you keep everything within the Enclave

1164
00:46:22,940 --> 00:46:28,699
then that is not really the role not

1165
00:46:26,119 --> 00:46:31,489
really a good approach because again the

1166
00:46:28,699 --> 00:46:33,529
Enclave has very small memory physical

1167
00:46:31,489 --> 00:46:36,349
memory and in-memory file system exerts

1168
00:46:33,529 --> 00:46:38,359
a lot of pressure on it well when we're

1169
00:46:36,349 --> 00:46:40,339
comparing very small file sizes we are

1170
00:46:38,359 --> 00:46:42,019
even comparable to the native file

1171
00:46:40,339 --> 00:46:45,558
system but again when we go to larger

1172
00:46:42,019 --> 00:46:48,198
file sizes we are we lagged behind by a

1173
00:46:45,559 --> 00:46:50,059
degree which is expected because the

1174
00:46:48,199 --> 00:46:52,690
native file system is not is completely

1175
00:46:50,059 --> 00:46:55,820
insecure and

1176
00:46:52,690 --> 00:46:57,830
well so then we did some macro

1177
00:46:55,820 --> 00:47:00,470
benchmarks using sequel light and light

1178
00:46:57,830 --> 00:47:02,840
TPD so for light TPD we used a bunch of

1179
00:47:00,470 --> 00:47:05,930
range a range of different file sizes

1180
00:47:02,840 --> 00:47:09,680
and we try to access them and we use for

1181
00:47:05,930 --> 00:47:13,460
try to insert and select 500 queries

1182
00:47:09,680 --> 00:47:16,129
from sequel light we show that that even

1183
00:47:13,460 --> 00:47:19,160
for macro benchmarks oblivia trim shows

1184
00:47:16,130 --> 00:47:20,990
almost two times almost less than two

1185
00:47:19,160 --> 00:47:23,330
times overhead over the in memory

1186
00:47:20,990 --> 00:47:25,310
filesystem and again the in-memory file

1187
00:47:23,330 --> 00:47:28,009
system is also insecure but it is the

1188
00:47:25,310 --> 00:47:30,470
next best secure version that off file

1189
00:47:28,010 --> 00:47:32,660
systems that we have currently and in

1190
00:47:30,470 --> 00:47:36,649
conclusion I would say that first of all

1191
00:47:32,660 --> 00:47:38,960
it's very risky to focus to focus on

1192
00:47:36,650 --> 00:47:41,680
mitigating a single side channel as a

1193
00:47:38,960 --> 00:47:44,450
lot of previous work has done and

1194
00:47:41,680 --> 00:47:46,040
oblivious Ram can be can definitely be

1195
00:47:44,450 --> 00:47:47,660
used to provide reasonable security of

1196
00:47:46,040 --> 00:47:49,759
course there are performance drawbacks

1197
00:47:47,660 --> 00:47:51,890
and huge performance drawbacks but

1198
00:47:49,760 --> 00:47:54,080
oblivious Ram can technically provide

1199
00:47:51,890 --> 00:47:56,120
you very sound security and should

1200
00:47:54,080 --> 00:47:58,490
definitely be considered as an as an

1201
00:47:56,120 --> 00:48:00,500
alternative oblivion in a nutshell is

1202
00:47:58,490 --> 00:48:04,040
that it's it provides a secure file

1203
00:48:00,500 --> 00:48:07,700
system library for Intel SGX well we use

1204
00:48:04,040 --> 00:48:09,400
pot or AM to ensure that all filesystem

1205
00:48:07,700 --> 00:48:12,259
file related system calls are handled

1206
00:48:09,400 --> 00:48:16,100
securely we leverage C move to secure

1207
00:48:12,260 --> 00:48:17,870
the Aram implementation and we also talk

1208
00:48:16,100 --> 00:48:21,140
about specific SGX specific

1209
00:48:17,870 --> 00:48:24,350
optimizations to ensure that we sort of

1210
00:48:21,140 --> 00:48:28,879
provide a quick close enough performance

1211
00:48:24,350 --> 00:48:30,670
to the next best insecure filesystem

1212
00:48:28,880 --> 00:48:35,120
which is the in-memory filesystem and

1213
00:48:30,670 --> 00:48:37,520
that is it for my presentation thank you

1214
00:48:35,120 --> 00:48:40,790
so much for listening if you guys have

1215
00:48:37,520 --> 00:48:43,030
any questions I am I'm happy to answer

1216
00:48:40,790 --> 00:48:43,029
them

1217
00:48:46,060 --> 00:48:50,599
[Applause]

1218
00:48:59,800 --> 00:49:04,280
any random SGX question I mean it

1219
00:49:02,870 --> 00:49:06,380
doesn't have to be focused on this

1220
00:49:04,280 --> 00:49:09,640
anything that you might think about

1221
00:49:06,380 --> 00:49:09,640
forestry yes

1222
00:49:13,970 --> 00:49:19,520
our files stored on the disk encrypted

1223
00:49:15,950 --> 00:49:22,839
or they are just plain text files stored

1224
00:49:19,520 --> 00:49:26,900
in the disk yeah so by the disk you mean

1225
00:49:22,840 --> 00:49:28,520
just I mean this yes on the right so

1226
00:49:26,900 --> 00:49:31,430
they don't technically you need to be

1227
00:49:28,520 --> 00:49:33,410
encrypted right but yeah let's say they

1228
00:49:31,430 --> 00:49:36,279
are encrypted but they don't technically

1229
00:49:33,410 --> 00:49:38,899
need to be because as long as you ensure

1230
00:49:36,280 --> 00:49:40,340
no yeah it would be better than a

1231
00:49:38,900 --> 00:49:42,050
encrypted definitely better than their

1232
00:49:40,340 --> 00:49:43,550
encrypt right because otherwise when

1233
00:49:42,050 --> 00:49:45,260
you're going to dump everything back

1234
00:49:43,550 --> 00:49:47,000
then the attack would still know what

1235
00:49:45,260 --> 00:49:48,770
changed so you definitely have to keep

1236
00:49:47,000 --> 00:49:51,950
everything in cookies so if you keep

1237
00:49:48,770 --> 00:49:53,690
everything encrypted then how is it why

1238
00:49:51,950 --> 00:49:56,149
is it important to protect from the

1239
00:49:53,690 --> 00:49:59,060
adversary knowing that which block

1240
00:49:56,150 --> 00:50:01,910
you've accessed if given the fact that

1241
00:49:59,060 --> 00:50:03,860
every okay so one one one very simple

1242
00:50:01,910 --> 00:50:05,990
way is to ensure that let's just read

1243
00:50:03,860 --> 00:50:07,850
the whole file okay that's the that's

1244
00:50:05,990 --> 00:50:09,319
the first thing that comes into my okay

1245
00:50:07,850 --> 00:50:11,870
if we read the whole file then it is

1246
00:50:09,320 --> 00:50:13,340
definitely completely secure yes but

1247
00:50:11,870 --> 00:50:15,440
let's suppose that your encryption is

1248
00:50:13,340 --> 00:50:16,550
done block by block which is generally

1249
00:50:15,440 --> 00:50:18,320
the encryption that you've used

1250
00:50:16,550 --> 00:50:20,720
so you're going to use a block by block

1251
00:50:18,320 --> 00:50:21,950
encryption to ensure that that means

1252
00:50:20,720 --> 00:50:23,839
that you don't have to read the whole

1253
00:50:21,950 --> 00:50:25,100
file if you want to read the whole file

1254
00:50:23,840 --> 00:50:28,100
that would be secure but that would be

1255
00:50:25,100 --> 00:50:32,150
even more performance hazardous then

1256
00:50:28,100 --> 00:50:34,370
around no actually my question is if the

1257
00:50:32,150 --> 00:50:36,710
file if the file data itself is

1258
00:50:34,370 --> 00:50:38,960
encrypted yes why is it important to

1259
00:50:36,710 --> 00:50:40,760
protect from the adversary right knowing

1260
00:50:38,960 --> 00:50:42,800
which block you can't write that's it

1261
00:50:40,760 --> 00:50:44,390
that's a good question so the again if

1262
00:50:42,800 --> 00:50:47,510
you if you remember the attack that we

1263
00:50:44,390 --> 00:50:50,060
that I Illustrated at the start it

1264
00:50:47,510 --> 00:50:52,310
doesn't really matter what the data is

1265
00:50:50,060 --> 00:50:54,200
what matters in that is that it's

1266
00:50:52,310 --> 00:50:56,570
sometimes even if the attacker doesn't

1267
00:50:54,200 --> 00:50:58,910
know what data is you can somehow sort

1268
00:50:56,570 --> 00:51:01,140
of leverage any sort of small

1269
00:50:58,910 --> 00:51:02,970
information to figure out what is being

1270
00:51:01,140 --> 00:51:05,098
what is being drawn so in this scenario

1271
00:51:02,970 --> 00:51:06,419
in this in this scenario let's say the

1272
00:51:05,099 --> 00:51:08,910
attacker knows what the database

1273
00:51:06,420 --> 00:51:10,349
semantics is if the attacker knows what

1274
00:51:08,910 --> 00:51:12,299
the database semantics is it doesn't

1275
00:51:10,349 --> 00:51:14,849
matter if he knows which where he it is

1276
00:51:12,299 --> 00:51:17,970
because he can still say okay this guy

1277
00:51:14,849 --> 00:51:20,250
this IP address try to access gave me

1278
00:51:17,970 --> 00:51:23,879
this query and try to access this index

1279
00:51:20,250 --> 00:51:26,250
within this sequel ID database so the

1280
00:51:23,880 --> 00:51:28,769
attacker let's say that later on that

1281
00:51:26,250 --> 00:51:29,670
data is perhaps public or something made

1282
00:51:28,769 --> 00:51:31,319
public or something

1283
00:51:29,670 --> 00:51:33,119
then again the attacker has some

1284
00:51:31,319 --> 00:51:35,190
information that I can use to leverage

1285
00:51:33,119 --> 00:51:36,750
similarly there have been other attacks

1286
00:51:35,190 --> 00:51:38,849
that have been used that have been that

1287
00:51:36,750 --> 00:51:42,420
have used side channels to break whole

1288
00:51:38,849 --> 00:51:44,190
RSA crypto keys using again database

1289
00:51:42,420 --> 00:51:45,720
side channels such as page tables and

1290
00:51:44,190 --> 00:51:48,210
cache based attacks so there are

1291
00:51:45,720 --> 00:51:50,189
multiple versions of of why we need to

1292
00:51:48,210 --> 00:51:52,519
secure against these side channels but

1293
00:51:50,190 --> 00:51:55,519
especially for file systems this is one

1294
00:51:52,519 --> 00:51:57,750
guiding example of why you might need it

1295
00:51:55,519 --> 00:52:00,118
actually I have one more question please

1296
00:51:57,750 --> 00:52:03,890
like um can you go to the slide where

1297
00:52:00,119 --> 00:52:08,099
you show the I believe the ORM trees and

1298
00:52:03,890 --> 00:52:09,960
the where you mentioned randomizing this

1299
00:52:08,099 --> 00:52:13,920
block yeah right you're randomizing

1300
00:52:09,960 --> 00:52:17,930
right back right so if you if you try to

1301
00:52:13,920 --> 00:52:21,779
write back a block back into the tree

1302
00:52:17,930 --> 00:52:24,328
the the adversary will be able to know

1303
00:52:21,779 --> 00:52:27,299
where you've right back to right right

1304
00:52:24,329 --> 00:52:29,250
but maybe I wasn't very clear but you

1305
00:52:27,299 --> 00:52:31,589
don't write back one block you write

1306
00:52:29,250 --> 00:52:33,599
back the whole path so you're going to

1307
00:52:31,589 --> 00:52:35,009
write back this path this root node and

1308
00:52:33,599 --> 00:52:37,349
then you're going to write back this

1309
00:52:35,009 --> 00:52:41,700
node here also and then this node here

1310
00:52:37,349 --> 00:52:43,859
also we can see where your onion sorry

1311
00:52:41,700 --> 00:52:46,769
ah so you what technically is going to

1312
00:52:43,859 --> 00:52:49,348
happen is that you are in this joint

1313
00:52:46,769 --> 00:52:54,000
from here so you are going to write back

1314
00:52:49,349 --> 00:52:56,880
here here here and here the whole power

1315
00:52:54,000 --> 00:52:58,470
huh instead of just a single node so if

1316
00:52:56,880 --> 00:53:00,089
you just write back here then the

1317
00:52:58,470 --> 00:53:01,740
attacked then the attacker already knows

1318
00:53:00,089 --> 00:53:03,328
where you've written back and then if

1319
00:53:01,740 --> 00:53:05,459
the attacker knows where you wrote back

1320
00:53:03,329 --> 00:53:06,509
the real block definitely but since

1321
00:53:05,460 --> 00:53:07,980
we're going to write back to the whole

1322
00:53:06,509 --> 00:53:09,990
path the title doesn't know exactly

1323
00:53:07,980 --> 00:53:12,539
where it could be it could be here it

1324
00:53:09,990 --> 00:53:14,700
could be here again right it could be

1325
00:53:12,539 --> 00:53:15,000
the same space a same spot it could be

1326
00:53:14,700 --> 00:53:16,859
here

1327
00:53:15,000 --> 00:53:19,230
it could be here the attacker doesn't

1328
00:53:16,860 --> 00:53:21,120
know so the whole point is that since

1329
00:53:19,230 --> 00:53:22,830
the attacker doesn't know it cannot

1330
00:53:21,120 --> 00:53:25,529
correlate the next time you're going to

1331
00:53:22,830 --> 00:53:27,450
try to access it so if the next time you

1332
00:53:25,530 --> 00:53:29,250
try to access this path again the

1333
00:53:27,450 --> 00:53:30,899
attacker could think that maybe it's the

1334
00:53:29,250 --> 00:53:32,850
same block maybe it's a different block

1335
00:53:30,900 --> 00:53:34,770
the attacker doesn't know because he

1336
00:53:32,850 --> 00:53:37,950
can't he didn't he couldn't correlate

1337
00:53:34,770 --> 00:53:40,020
from your first access so the first step

1338
00:53:37,950 --> 00:53:42,120
is just trying to erase the trace right

1339
00:53:40,020 --> 00:53:44,310
right it's similar to you raising a

1340
00:53:42,120 --> 00:53:46,200
trace but you have to put block a back

1341
00:53:44,310 --> 00:53:49,320
to somewhere like in the Y zero

1342
00:53:46,200 --> 00:53:52,439
yes like like the left subtree of the

1343
00:53:49,320 --> 00:53:54,270
right subtree ready yeah so you will you

1344
00:53:52,440 --> 00:53:56,820
owe your program will try to rise to

1345
00:53:54,270 --> 00:53:58,410
that position but the our program will

1346
00:53:56,820 --> 00:54:00,960
try to write to all different positions

1347
00:53:58,410 --> 00:54:02,549
so the other dummy blocks but the other

1348
00:54:00,960 --> 00:54:03,960
also blocks like you're trying to write

1349
00:54:02,550 --> 00:54:06,630
and these are going to be encrypted so

1350
00:54:03,960 --> 00:54:08,130
since everything is encrypted you're

1351
00:54:06,630 --> 00:54:11,310
also going to write here you're also

1352
00:54:08,130 --> 00:54:12,900
going to write here so the whole point

1353
00:54:11,310 --> 00:54:14,549
is since you're going to write to the

1354
00:54:12,900 --> 00:54:17,490
whole path to every node in the path

1355
00:54:14,550 --> 00:54:19,140
you're not just going to write here now

1356
00:54:17,490 --> 00:54:20,609
this is a completely trusted name we

1357
00:54:19,140 --> 00:54:22,230
reach and the attacker doesn't know

1358
00:54:20,610 --> 00:54:24,570
what's going there going on there

1359
00:54:22,230 --> 00:54:26,730
the attacker only knows that you you you

1360
00:54:24,570 --> 00:54:28,440
gave it some memory to write here and

1361
00:54:26,730 --> 00:54:29,820
then you gave it some other memory to

1362
00:54:28,440 --> 00:54:31,860
write here and then you gave it some

1363
00:54:29,820 --> 00:54:34,650
other memory to write here the attacker

1364
00:54:31,860 --> 00:54:36,330
knows this this much I believe there's

1365
00:54:34,650 --> 00:54:38,220
another very face of the right back

1366
00:54:36,330 --> 00:54:40,650
right because you have to position a

1367
00:54:38,220 --> 00:54:42,569
into the new randomized right but you're

1368
00:54:40,650 --> 00:54:44,310
just going to give that information to

1369
00:54:42,570 --> 00:54:46,170
the attacker you will you go you can

1370
00:54:44,310 --> 00:54:48,299
sort of create that right you can start

1371
00:54:46,170 --> 00:54:50,160
from here start writing back whatever

1372
00:54:48,300 --> 00:54:51,450
you can hear this is pretty complex

1373
00:54:50,160 --> 00:54:53,609
problem than you may think

1374
00:54:51,450 --> 00:54:55,529
and the key idea is that young if you

1375
00:54:53,610 --> 00:54:57,960
are simply writing a single block and

1376
00:54:55,530 --> 00:54:59,700
your tech arena right your city instead

1377
00:54:57,960 --> 00:55:02,520
maybe you can be simply write the whole

1378
00:54:59,700 --> 00:55:04,080
note that it's not other direction but

1379
00:55:02,520 --> 00:55:06,180
that's going to be too slow like

1380
00:55:04,080 --> 00:55:07,890
attacker will have no idea which block

1381
00:55:06,180 --> 00:55:10,290
has been written because you fear simply

1382
00:55:07,890 --> 00:55:12,540
updating newly updating entire blocks

1383
00:55:10,290 --> 00:55:15,690
that's going to be too slow so just use

1384
00:55:12,540 --> 00:55:18,330
smart free smart fate have indeed is

1385
00:55:15,690 --> 00:55:20,490
sort of the Treaty organisation sold in

1386
00:55:18,330 --> 00:55:22,920
the past and now you can promise me this

1387
00:55:20,490 --> 00:55:24,810
is as somehow as secure as Natalia

1388
00:55:22,920 --> 00:55:26,430
taking the block so we so we need to

1389
00:55:24,810 --> 00:55:28,700
write back to a lot of dummy notes

1390
00:55:26,430 --> 00:55:31,910
basically but it is right

1391
00:55:28,700 --> 00:55:34,609
minimize those DNA testing longer frame

1392
00:55:31,910 --> 00:55:36,920
so you know in a real world for you how

1393
00:55:34,609 --> 00:55:40,190
deep is the how deep are the branches so

1394
00:55:36,920 --> 00:55:41,810
it depends on your data right so in the

1395
00:55:40,190 --> 00:55:43,490
in the path program construction what

1396
00:55:41,810 --> 00:55:46,578
they say is as long as the number of

1397
00:55:43,490 --> 00:55:49,810
real blocks in your tree are equal to

1398
00:55:46,579 --> 00:55:55,040
the leaf of your tree you can provide a

1399
00:55:49,810 --> 00:56:05,359
guaranteed security the same it's very

1400
00:55:55,040 --> 00:56:06,740
smart rate that is the body yeah so I

1401
00:56:05,359 --> 00:56:08,598
kind of wanted to know I say that I'm

1402
00:56:06,740 --> 00:56:11,000
somebody who is actually planning on

1403
00:56:08,599 --> 00:56:12,410
using this and I'm signing up for say

1404
00:56:11,000 --> 00:56:14,270
some sort of database hosted on a cloud

1405
00:56:12,410 --> 00:56:16,098
service it seems like from my

1406
00:56:14,270 --> 00:56:18,079
perspective I'm just you know making

1407
00:56:16,099 --> 00:56:20,780
queries getting responses what is

1408
00:56:18,079 --> 00:56:22,550
stopping an adversarial server from

1409
00:56:20,780 --> 00:56:24,740
essentially lying to me and pretending

1410
00:56:22,550 --> 00:56:31,040
they're running all of this rather than

1411
00:56:24,740 --> 00:56:32,899
actually doing it right it couldn't they

1412
00:56:31,040 --> 00:56:34,460
essentially is there any way that you

1413
00:56:32,900 --> 00:56:37,010
could get around that perhaps and be

1414
00:56:34,460 --> 00:56:39,530
sure that this is what is being done so

1415
00:56:37,010 --> 00:56:41,569
there is a sort of remote attestation

1416
00:56:39,530 --> 00:56:43,670
that is possible with SGX

1417
00:56:41,569 --> 00:56:46,310
where you can sort of say that okay

1418
00:56:43,670 --> 00:56:48,650
we're using another Enclave you can sort

1419
00:56:46,310 --> 00:56:51,200
of a test that whatever is being run

1420
00:56:48,650 --> 00:56:52,640
within this Enclave now there's still no

1421
00:56:51,200 --> 00:56:54,379
guarantee that you know they're actually

1422
00:56:52,640 --> 00:56:57,470
going to run it within that I don't even

1423
00:56:54,380 --> 00:57:00,230
give you data but unless but as long as

1424
00:56:57,470 --> 00:57:02,089
you ensure you ensure that that remote

1425
00:57:00,230 --> 00:57:04,250
attestation that you do with that

1426
00:57:02,089 --> 00:57:06,529
Enclave and your Enclave they match

1427
00:57:04,250 --> 00:57:08,420
because you have to also involve Intel

1428
00:57:06,530 --> 00:57:10,700
inter is the one that can sort of give

1429
00:57:08,420 --> 00:57:14,329
you to go ahead that okay yes

1430
00:57:10,700 --> 00:57:16,790
whatever this attested let's say knock

1431
00:57:14,329 --> 00:57:19,280
was given to you is from another uncles

1432
00:57:16,790 --> 00:57:24,770
so you can sort of predict you can sort

1433
00:57:19,280 --> 00:57:27,130
of say that this is secure any other

1434
00:57:24,770 --> 00:57:27,130
questions

1435
00:57:28,190 --> 00:57:31,369
[Applause]

1436
00:57:39,599 --> 00:57:41,660
you

