1
00:00:19,070 --> 00:00:21,520
Work SMTer Not Harder Concolic Execution for
CTF

2
00:00:21,520 --> 00:00:23,050
Christina Johns
SAMAN: Hi, everyone!

3
00:00:23,050 --> 00:00:24,050
Appreciate it.

4
00:00:24,050 --> 00:00:27,880
And we'll be having another session with another
speaker today.

5
00:00:27,880 --> 00:00:30,590
So, thanks to the previous speaker.

6
00:00:30,590 --> 00:00:36,320
And first of all, going to the speaker track,
I just wanted to thank our track sponsors.

7
00:00:36,320 --> 00:00:45,120
That is iNE eLearn Security, Axonius, MongoDB,
Juniper Networks, Corelight, Google, We Hack

8
00:00:45,120 --> 00:00:48,050
Purple and BridgeCrew by Prisma Cloud.

9
00:00:48,050 --> 00:00:54,250
Very, very thankful to the sponsors for making
it and making The Diana Initiative so big.

10
00:00:54,250 --> 00:01:01,640
So, today we have our speaker, Christina Johns
who will be talking about Work SMTer Not Harder

11
00:01:01,640 --> 00:01:04,900
Concolic Execution for CTF.

12
00:01:04,900 --> 00:01:12,370
Christina Johns is a cybersecurity engineer
at MIT RE with over 10 years of experience.

13
00:01:12,370 --> 00:01:19,190
She has worked in a variety of areas including
web application assessment, Android forensics,

14
00:01:19,190 --> 00:01:24,850
incident response, and most recently she has
started working on reverse engineering.

15
00:01:24,850 --> 00:01:32,419
Her research interests lie at the intersection
of automating binary analysis and malware

16
00:01:32,420 --> 00:01:33,950
reverse engineering.

17
00:01:33,950 --> 00:01:40,640
She has started multiple intro to CTF workshops,
volunteers with the Cyberjutsu girls academy

18
00:01:40,640 --> 00:01:47,560
and sharing her skills and helping other to
do the same.

19
00:01:47,560 --> 00:01:52,229
Welcome, Christina, and good luck for your
session.

20
00:01:52,229 --> 00:01:53,990
CHRISTINA: Thank you.

21
00:01:53,990 --> 00:01:55,149
Welcome, everyone.

22
00:01:55,150 --> 00:02:00,369
I'm Christina and I'm going to be talking
about something that I think is cool, concolic

23
00:02:00,369 --> 00:02:09,119
execution and how it can be used to solve
reverse CTF challenges.

24
00:02:09,119 --> 00:02:14,320
An overview of what we're talking about today.

25
00:02:14,320 --> 00:02:19,220
A little bit about why use automation in the
first place.

26
00:02:19,220 --> 00:02:23,600
And then we're gonna talk about a specific
automated analysis technique called concolic

27
00:02:23,600 --> 00:02:25,850
execution.

28
00:02:25,850 --> 00:02:32,070
And two technologies and tools that are useful
for concolic execution.

29
00:02:32,070 --> 00:02:37,620
Angr, a binary analysis framework, and Z3,
an SMT solver.

30
00:02:37,620 --> 00:02:44,290
You can think of an SMT solver as a tool that
you can give an equation with unknown variables,

31
00:02:44,290 --> 00:02:46,780
and it will tell you if the equation is satisfiable.

32
00:02:46,780 --> 00:02:50,090
If it is, it will give you values for the
variables.

33
00:02:50,090 --> 00:02:53,450
However, it's possible it might not solve
this in a reasonable time.

34
00:02:53,450 --> 00:02:55,518
That's possible to keep in mind.

35
00:02:55,519 --> 00:03:01,440
We'll then be applying these tools and techniques
to three problems.

36
00:03:01,440 --> 00:03:04,720
They won't be full walk throughs, because
that would take too long.

37
00:03:04,720 --> 00:03:11,840
But we will be focus on how these tools specifically
can help you solve the challenge.

38
00:03:11,840 --> 00:03:15,870
As you might have guessed, this is a pretty
large topic.

39
00:03:15,870 --> 00:03:20,799
It could probably do multiple days, a deep
dive into this.

40
00:03:20,799 --> 00:03:26,980
But the goal of this talk is to give you a
foundation to explore this on your own.

41
00:03:26,980 --> 00:03:30,040
So, why automation?

42
00:03:30,040 --> 00:03:37,220
The simple answer is to get your flags faster
so you can get more points so you can run

43
00:03:37,220 --> 00:03:38,220
the CTF.

44
00:03:38,220 --> 00:03:41,670
But even if that wasn't your goal, some of
the most difficult classes of reverse engineering

45
00:03:41,670 --> 00:03:44,530
challenges can require some sort of automation.

46
00:03:44,530 --> 00:03:48,160
So, it might be the scale of the problem.

47
00:03:48,160 --> 00:03:54,410
Each part of you might have hundreds of binaries
to analyze, and each part might not be that

48
00:03:54,410 --> 00:03:55,410
complicated.

49
00:03:55,410 --> 00:03:58,870
But the sheer number of them is too much to
do by hand.

50
00:03:58,870 --> 00:04:05,540
Or it could be there's complex computation
or obfuscation that is would be unreasonable

51
00:04:05,540 --> 00:04:12,049
to solve in a weekend if you didn't do some
sort of automation to help you out.

52
00:04:12,050 --> 00:04:16,620
So, concolic execution.

53
00:04:16,620 --> 00:04:20,970
Concolic execution is a portmanteau of symbolic
and concrete execution.

54
00:04:20,970 --> 00:04:28,660
So, symbolic education execution is a software
technology first explored in the '70s for

55
00:04:28,660 --> 00:04:30,630
software verification.

56
00:04:30,630 --> 00:04:36,780
In the early 2000s, there was renewed research
in this area due to improvements and SMT solvers

57
00:04:36,780 --> 00:04:39,940
as well as additional computation power.

58
00:04:39,940 --> 00:04:46,950
Such that these techniques were more feasible
than they were when they were originally proposed.

59
00:04:46,950 --> 00:04:55,000
So, concolic execution is one of these one
of the results of this research.

60
00:04:55,000 --> 00:05:00,130
It is techniques to combine symbolic and concrete
execution.

61
00:05:00,130 --> 00:05:05,010
And the reason for this is to enable strategies
to overcome some of the challenges with pure

62
00:05:05,010 --> 00:05:06,840
symbolic execution.

63
00:05:06,840 --> 00:05:10,140
And we'll talk about some of those a little
bit later.

64
00:05:10,140 --> 00:05:13,570
So, here we have an example program.

65
00:05:13,570 --> 00:05:15,650
It takes some input.

66
00:05:15,650 --> 00:05:18,500
It has a few compares.

67
00:05:18,500 --> 00:05:22,550
And then it enters one of two states.

68
00:05:22,550 --> 00:05:27,680
And so, maybe we are really interested in
the print foo state for whatever reason.

69
00:05:27,680 --> 00:05:29,401
Maybe that's a bad outcome, we're worried
about it.

70
00:05:29,401 --> 00:05:33,970
We want to know what are the possible inputs
that could lead to that state?

71
00:05:33,970 --> 00:05:40,480
So, some of the options we have for this would
be to start trying random variables or values

72
00:05:40,480 --> 00:05:41,480
for X.

73
00:05:41,480 --> 00:05:44,590
So, just kind of blindly guessing.

74
00:05:44,590 --> 00:05:49,150
X maybe an exhaustive search so we knew what
everybody we had tried.

75
00:05:49,150 --> 00:05:56,940
A third technique is symbolic execution which
is what we're gonna talk about.

76
00:05:56,940 --> 00:06:05,060
So, here we have the symbolic analysis tree
drawn out for our example program.

77
00:06:05,060 --> 00:06:12,390
So, at the beginning, we're going to say that
the variable we care about, X, the input,

78
00:06:12,390 --> 00:06:13,550
is going to be symbolic.

79
00:06:13,550 --> 00:06:15,960
So, we'll assign it to alpha.

80
00:06:15,960 --> 00:06:18,830
And then Y is assigned zero by program.

81
00:06:18,830 --> 00:06:20,740
So, you come to the first branch.

82
00:06:20,740 --> 00:06:23,880
If X is greater than 6, you take the true
path.

83
00:06:23,880 --> 00:06:26,620
If it's less, you take the false path.

84
00:06:26,620 --> 00:06:30,350
And the great thing about symbolic execution
is that it analyzes both paths.

85
00:06:30,350 --> 00:06:36,780
So, with normal execution, you would have
to test the value and then see which way you

86
00:06:36,780 --> 00:06:37,780
went.

87
00:06:37,780 --> 00:06:40,489
This way you can explore both simultaneously.

88
00:06:40,490 --> 00:06:46,740
So, if we take the true branch, we now have
a state that alpha has to be greater than

89
00:06:46,740 --> 00:06:47,740
6.

90
00:06:47,740 --> 00:06:48,740
Because that was the condition.

91
00:06:48,740 --> 00:06:50,389
And Y is now equal to 3.

92
00:06:50,389 --> 00:06:55,960
And the constraints to follow this path were
that alpha was greater than 6.

93
00:06:55,960 --> 00:07:02,060
So, for our next branch statement we have
X plus Y is equal to 9.

94
00:07:02,060 --> 00:07:08,090
So, now the true path says that our state
remains the same.

95
00:07:08,090 --> 00:07:13,200
But we add an additional constraint that alpha
plus Y is equal to 9.

96
00:07:13,200 --> 00:07:17,680
And so, we do that for all all the paths through
the program.

97
00:07:17,680 --> 00:07:23,919
So, now when we we so, the state we were interested
in was foo.

98
00:07:23,919 --> 00:07:31,400
So, we're going to look at the specific state
and constraint data for states where we print

99
00:07:31,400 --> 00:07:32,400
foo.

100
00:07:32,400 --> 00:07:38,310
So, for the first one, we can solve the we
give the constraints to our SMT solver.

101
00:07:38,310 --> 00:07:41,870
And the SMT solver tell us that's unsatisfiable.

102
00:07:41,870 --> 00:07:48,530
There is not a number that is greater than
6 that you can add to Y and get to 9.

103
00:07:48,530 --> 00:07:55,239
So, we know that it's not possible to come
down this path to get to foo.

104
00:07:55,240 --> 00:08:01,400
However, the other state, which prints foo,
had alpha less than or equal to 6.

105
00:08:01,400 --> 00:08:07,270
And so, the SMT solver will tell us in order
to satisfy the constraints for that state,

106
00:08:07,270 --> 00:08:08,770
alpha would have to be 6.

107
00:08:08,770 --> 00:08:15,490
Or 6 is one value, at least, that would get
you to that path.

108
00:08:15,490 --> 00:08:20,330
So, this chart is not so much meant to be
read.

109
00:08:20,330 --> 00:08:21,330
It's from Wikipedia.

110
00:08:21,330 --> 00:08:27,479
It is the symbolic execution frameworks that
are on Wikipedia.

111
00:08:27,480 --> 00:08:29,860
So, you can see there's a lot of them.

112
00:08:29,860 --> 00:08:31,770
And a lot of them are open source.

113
00:08:31,770 --> 00:08:34,120
Which is really exciting.

114
00:08:34,120 --> 00:08:37,899
And we're gonna talk specifically about one
of them which is angr.

115
00:08:37,899 --> 00:08:39,860
So, oops.

116
00:08:39,860 --> 00:08:42,799
Sorry about that.

117
00:08:42,799 --> 00:08:47,699
So, an overview of angr.

118
00:08:47,699 --> 00:08:51,260
Angr is a Python open source binary analysis
framework.

119
00:08:51,260 --> 00:08:52,980
It's on GitHub.

120
00:08:52,980 --> 00:09:00,110
It was developed by UCSB as part of their
2016 DARPA Grand Challenge entry.

121
00:09:00,110 --> 00:09:05,070
The goal of the grand challenge was to create
automated systems and find bugs and patch

122
00:09:05,070 --> 00:09:06,770
them.

123
00:09:06,770 --> 00:09:12,260
It has a large community with continued development
and great documentation.

124
00:09:12,260 --> 00:09:19,390
So, it's frequently updated, and they've taken,
you know, something that's pretty complicated

125
00:09:19,390 --> 00:09:23,189
to make and I think through their documentation
they've made it about as understandable as

126
00:09:23,190 --> 00:09:24,670
you probably could.

127
00:09:24,670 --> 00:09:27,829
So, I'm a big fan.

128
00:09:27,830 --> 00:09:31,420
So, these are some of the components that
make up angr.

129
00:09:31,420 --> 00:09:34,040
We're gonna talk a little bit about.

130
00:09:34,040 --> 00:09:39,990
So, the project is the overarching structure
that holds the analysis information.

131
00:09:39,990 --> 00:09:46,430
So, you give it the path to your binary and
you're going to be using it like throughout

132
00:09:46,430 --> 00:09:48,500
your analysis.

133
00:09:48,500 --> 00:09:53,350
CLE is the loader that loads your binary.

134
00:09:53,350 --> 00:09:56,130
It has multi architecture support.

135
00:09:56,130 --> 00:10:01,140
It stands for CLE Loads Everything.

136
00:10:01,140 --> 00:10:05,319
The solver, that we talked a little bit about
SMT solvers.

137
00:10:05,320 --> 00:10:07,900
The library they use is Claripy.

138
00:10:07,900 --> 00:10:14,260
It looks similar to Z3 it uses Z3 in the backend.

139
00:10:14,260 --> 00:10:19,550
And it looks kind of similar to Z3's Python
interface.

140
00:10:19,550 --> 00:10:26,030
SimStates are how you look at and manipulate
state data.

141
00:10:26,030 --> 00:10:32,010
So, for each basic block that you your analysis
goes through, you can set and read memory

142
00:10:32,010 --> 00:10:36,000
information, registry information for that
state and execution.

143
00:10:36,000 --> 00:10:41,210
And then the simulation manager is how you
run your analysis.

144
00:10:41,210 --> 00:10:43,080
There's multiple execution engines.

145
00:10:43,080 --> 00:10:51,000
One possible option is Unicorn which is a
emulator which can speed up your analysis.

146
00:10:51,000 --> 00:10:58,930
And the other main execution engine is based
on Vex.

147
00:10:58,930 --> 00:11:04,130
Which uses the Vex intermediate representation.

148
00:11:04,130 --> 00:11:08,710
So, diving in a little bit to the solver.

149
00:11:08,710 --> 00:11:12,420
So, this is what the syntax of the solver
is gonna look like.

150
00:11:12,420 --> 00:11:16,670
You can create bit vectors.

151
00:11:16,670 --> 00:11:20,410
Which are concrete values.

152
00:11:20,410 --> 00:11:22,810
And you can also create symbolic vectors.

153
00:11:22,810 --> 00:11:28,219
So, that is really important for, you know,
symbolic execution, right?

154
00:11:28,220 --> 00:11:30,780
The values that we want to solve for.

155
00:11:30,780 --> 00:11:34,230
We're going to make symbolic vectors.

156
00:11:34,230 --> 00:11:39,550
Then you can create you can access the solver
through your Claripy.

157
00:11:39,550 --> 00:11:41,050
And add constraints.

158
00:11:41,050 --> 00:11:50,660
That's the equation part of what the constraints
have to be for how your variables interact.

159
00:11:50,660 --> 00:11:55,680
And then you can ask Claripy to evaluate your
symbolic variable.

160
00:11:55,680 --> 00:12:02,219
So, you know, you can ask it to give you a
value that satisfies that equation or to tell

161
00:12:02,220 --> 00:12:05,490
you that it can't.

162
00:12:05,490 --> 00:12:08,710
So, I mentioned Z3 a couple times.

163
00:12:08,710 --> 00:12:11,160
Z3 is an SMT solver, again.

164
00:12:11,160 --> 00:12:13,699
It was created by Microsoft Research.

165
00:12:13,700 --> 00:12:17,830
It's the current solver in Claripy used by
angr.

166
00:12:17,830 --> 00:12:22,340
It has its it uses a domain specific language.

167
00:12:22,340 --> 00:12:26,280
But it also has a lot of different language
bindings.

168
00:12:26,280 --> 00:12:32,310
So, there is there are Python bindings so
you can program it in Python which is really

169
00:12:32,310 --> 00:12:33,310
great.

170
00:12:33,310 --> 00:12:35,079
And it is also open source and on GitHub.

171
00:12:35,080 --> 00:12:41,800
So, it can be used on its own to solve certain
problems which we'll talk about also.

172
00:12:41,800 --> 00:12:46,500
So, like I mentioned, SimStates before.

173
00:12:46,500 --> 00:12:54,650
After you create your project, you want to
create an entry state to begin your execution.

174
00:12:54,650 --> 00:12:59,189
So, this is sort of the beginning of what
your program is.

175
00:12:59,190 --> 00:13:05,750
And so, to that first state, you can add constraints
on the memory and registers to the solver

176
00:13:05,750 --> 00:13:10,500
that it can use as it does its analysis.

177
00:13:10,500 --> 00:13:16,560
This simulation engine, you pass the state
that you want to explore.

178
00:13:16,560 --> 00:13:19,219
And there's a few different options for exploration.

179
00:13:19,220 --> 00:13:23,480
So, you can step, which will advance you one
basic walk at a time.

180
00:13:23,480 --> 00:13:31,490
You can ask it to explore and give it a find
address or a find equation.

181
00:13:31,490 --> 00:13:36,840
Or you can tell it an equation or an address
that you want to avoid.

182
00:13:36,840 --> 00:13:38,459
Or both.

183
00:13:38,459 --> 00:13:40,890
And there's also an option to just tell it
to run.

184
00:13:40,890 --> 00:13:45,960
So, it will run until it terminates.

185
00:13:45,960 --> 00:13:50,529
And like I mentioned before, Unicorn and Vex
are part of the simulation engine.

186
00:13:50,529 --> 00:13:59,220
So, we've covered a little bit of the theory
behind symbolic execution and some of the

187
00:13:59,220 --> 00:14:01,250
real specifics to using angr.

188
00:14:01,250 --> 00:14:06,370
So, now we're going to talk about how you
can get all the flags.

189
00:14:06,370 --> 00:14:16,540
So, a lot of reverse engineering CTF problems
have this map nicely to the find/avoid construct.

190
00:14:16,540 --> 00:14:20,990
So, you you know, you take some input.

191
00:14:20,990 --> 00:14:21,990
It checks.

192
00:14:21,990 --> 00:14:24,820
It runs a function against that.

193
00:14:24,820 --> 00:14:30,870
It returns a result and then there's an if
statement of if it's this thing, you win.

194
00:14:30,870 --> 00:14:33,430
Otherwise, try again, or no.

195
00:14:33,430 --> 00:14:41,199
So, you want to find the state that prints
you win, and you want to avoid obviously,

196
00:14:41,200 --> 00:14:42,950
the state that says try again.

197
00:14:42,950 --> 00:14:44,390
You don't want to try again.

198
00:14:44,390 --> 00:14:46,890
You just want the flag.

199
00:14:46,890 --> 00:14:51,310
So, this is an example from last year's Diana
CTF.

200
00:14:51,310 --> 00:14:56,099
I've pulled part of it out from the compiler.

201
00:14:56,100 --> 00:15:04,220
So, you can some RE on the challenge, and
get the inputs and check the bytes against

202
00:15:04,220 --> 00:15:07,970
the array that it has.

203
00:15:07,970 --> 00:15:11,740
If something doesn't match, it tells you nope!

204
00:15:11,740 --> 00:15:15,010
And if everything matches, you found the flag.

205
00:15:15,010 --> 00:15:21,180
So, we're gonna use that with angr's explorer
functionality.

206
00:15:21,180 --> 00:15:28,589
So, to create our angr script, we're gonna
start with a project.

207
00:15:28,589 --> 00:15:33,390
And then we're going to create this symbolic
variable for our input.

208
00:15:33,390 --> 00:15:44,770
So, we're using Claripy here to create a array
of symbolic bytes for the length of the input.

209
00:15:44,770 --> 00:15:49,689
So, through reverse engineering we figured
out this is how long our flag should be.

210
00:15:49,690 --> 00:15:57,150
We then concatenate that array together to
create our flag input.

211
00:15:57,150 --> 00:16:03,890
And then we use the entry state to create
the beginning of our challenge and then the

212
00:16:03,890 --> 00:16:12,040
arguments are for Linux the name of the binary
and then this challenge takes a parameter

213
00:16:12,040 --> 00:16:13,040
as input.

214
00:16:13,040 --> 00:16:15,990
So, we put our symbolic input there.

215
00:16:15,990 --> 00:16:22,600
And we're going to use the option to use angr,
or to use Unicorn to speed up our analysis.

216
00:16:22,600 --> 00:16:28,620
So, now that we have the state created, we
want to add constraints based on the information

217
00:16:28,620 --> 00:16:32,170
we know about the challenge.

218
00:16:32,170 --> 00:16:36,640
So, this will help angr solve it faster.

219
00:16:36,640 --> 00:16:42,120
It reduces this space that it has to search
for an answer.

220
00:16:42,120 --> 00:16:47,810
So, we know, for example, that our flag is
going to be printable characters.

221
00:16:47,810 --> 00:16:56,359
So, we can tell it that each of those bytes
should be less than the top end of the ASCII

222
00:16:56,360 --> 00:16:59,020
range and greater than the bottom.

223
00:16:59,020 --> 00:17:04,299
And if it's a CTF that has a really specific
flag format, you could put constraints on

224
00:17:04,299 --> 00:17:12,579
the first few bytes to say it should match
the flag format.

225
00:17:12,579 --> 00:17:15,790
So, to run the simulation, we have two options.

226
00:17:15,790 --> 00:17:23,049
We can use the explore functionality to give
it the find the address of the flag print

227
00:17:23,049 --> 00:17:24,049
statement.

228
00:17:24,049 --> 00:17:26,349
And avoid the nope print statement.

229
00:17:26,349 --> 00:17:32,779
Or we can just say, I want to run the whole
analysis and then now look at results afterwards.

230
00:17:32,779 --> 00:17:36,480
So, once it's run, we want to get results.

231
00:17:36,480 --> 00:17:45,460
If you choose the explore strategy, you so,
I should explain that the simulation manager

232
00:17:45,460 --> 00:17:50,130
as it's running, it uses stashes to keep track
of the states it has.

233
00:17:50,130 --> 00:17:55,799
So, it will have an active stash which are
states that are still being explored.

234
00:17:55,799 --> 00:17:57,519
Or states to explore.

235
00:17:57,519 --> 00:18:02,730
A dead ended stash which are states that have
reached the end of execution.

236
00:18:02,730 --> 00:18:08,610
And if you're using explorer, it will have,
it will put states into found or avoid.

237
00:18:08,610 --> 00:18:14,059
So, we can hopefully the CTF challenge only
has one answer.

238
00:18:14,059 --> 00:18:20,269
So, you can look at the first found state
and then use the solver to evaluate for each

239
00:18:20,269 --> 00:18:24,679
byte in our symbolic variable to get the flag.

240
00:18:24,679 --> 00:18:32,539
If you chose to use the run strategy, you
can look through all of the dead ended states

241
00:18:32,539 --> 00:18:35,649
for the output that's the flag.

242
00:18:35,649 --> 00:18:42,779
So, you want the state where you got to that
that's the flag statement and you can look

243
00:18:42,779 --> 00:18:43,980
for that and standard out.

244
00:18:43,980 --> 00:18:48,119
And then you would evaluate the same way,
asking the solver to evaluate each character

245
00:18:48,119 --> 00:18:50,029
of the flag.

246
00:18:50,029 --> 00:18:58,499
So, to recap that challenge, the things you
needed to find via reverse engineering for

247
00:18:58,499 --> 00:19:03,989
the challenge were the length of the flag
and the address of the fail and win states

248
00:19:03,989 --> 00:19:05,639
or the successful print statement.

249
00:19:05,639 --> 00:19:07,408
So, you still have to do some REs.

250
00:19:07,409 --> 00:19:09,389
You don't get out of all of it.

251
00:19:09,389 --> 00:19:13,508
But you do have to do maybe less.

252
00:19:13,509 --> 00:19:21,869
So, this challenge was from redpwn 2020.

253
00:19:21,869 --> 00:19:26,370
It took a flag as input using fgets.

254
00:19:26,370 --> 00:19:31,238
The length of the flag was 73 bytes and then
it did a series of compares for each byte

255
00:19:31,239 --> 00:19:34,710
of the flag against the other characters in
the flag itself.

256
00:19:34,710 --> 00:19:42,279
So, this is a small output of you can see
it moves two different parts of the array

257
00:19:42,279 --> 00:19:46,399
into registers, compares them and jumps based
on that comparison.

258
00:19:46,399 --> 00:19:54,658
And it was a little bit trickier in that this
initial jump label was not always there was

259
00:19:54,659 --> 00:19:57,630
a second jump to the actual fail statement.

260
00:19:57,630 --> 00:20:02,759
So, you couldn't just look you couldn't just
rename one of these fail and then like quickly

261
00:20:02,759 --> 00:20:08,249
see which way you wanted to do the compare.

262
00:20:08,249 --> 00:20:14,389
So, the name of the challenge was SMarT solver.

263
00:20:14,389 --> 00:20:21,469
Our script would look pretty similar, even
though there's the second jump, it's similar

264
00:20:21,470 --> 00:20:24,139
to the first jump.

265
00:20:24,139 --> 00:20:31,779
There were two library calls in this challenge
that were causing execution to take longer

266
00:20:31,779 --> 00:20:33,259
than was really feasible.

267
00:20:33,259 --> 00:20:40,970
So, one thing you can do if you know that
you have one output or a simpler output for

268
00:20:40,970 --> 00:20:44,210
those library calls, is you can hook the library
calls with angr.

269
00:20:44,210 --> 00:20:47,850
Is, we knew the length of the string we were
giving it.

270
00:20:47,850 --> 00:20:51,939
And we knew that we were only going to give
it alphanumeric characters.

271
00:20:51,940 --> 00:20:59,320
So, we could create hooks for these two functions
so that they returned something quick.

272
00:20:59,320 --> 00:21:01,908
And speed up the analysis.

273
00:21:01,909 --> 00:21:09,789
So, an alternative solution and most of the
write ups that I saw for this challenge used

274
00:21:09,789 --> 00:21:10,789
Z3.

275
00:21:10,789 --> 00:21:13,229
So, the challenge is this series of compares.

276
00:21:13,229 --> 00:21:15,950
So, it maps really nicely to Z3 constraints.

277
00:21:15,950 --> 00:21:20,690
However, you would probably still want to
do some automation.

278
00:21:20,690 --> 00:21:23,710
Because there were around 5,000 compares.

279
00:21:23,710 --> 00:21:33,289
So, you'd probably want to automate parsing
of compares and translating that into Z3 to

280
00:21:33,289 --> 00:21:34,830
in order to solve it.

281
00:21:34,830 --> 00:21:39,460
But it's this is one that would be possible
to do with Z3 and you wouldn't have to use

282
00:21:39,460 --> 00:21:41,350
angr.

283
00:21:41,350 --> 00:21:47,998
So, what are some of the things you might
ask yourself to decide do I want to try angr

284
00:21:47,999 --> 00:21:48,999
or Z3?

285
00:21:48,999 --> 00:21:54,859
So, if the binary has some properties which
make angr challenging to use, like maybe lots

286
00:21:54,859 --> 00:21:59,699
of system calls or you can't write a hook
that simplifies them.

287
00:21:59,700 --> 00:22:03,850
Or if it's written in a language that has
a lot of runtime calls.

288
00:22:03,850 --> 00:22:04,850
Like maybe go arrest.

289
00:22:04,850 --> 00:22:07,978
That's going to be really hard for angr to
churn through.

290
00:22:07,979 --> 00:22:16,650
So, if it's feasible to extract constraints
like that, then if that's fairly easy, then

291
00:22:16,650 --> 00:22:20,429
Z3 is probably the way to go.

292
00:22:20,429 --> 00:22:28,220
So, the last example challenge we're gonna
talk about is FLARE 2018 magic.

293
00:22:28,220 --> 00:22:33,899
So, in this example, we're going to solve
a we're going to use angr to solve a sub component

294
00:22:33,899 --> 00:22:36,379
of the problem.

295
00:22:36,379 --> 00:22:40,029
So, a high level overview of this challenge.

296
00:22:40,029 --> 00:22:41,639
It was pretty complex.

297
00:22:41,639 --> 00:22:43,889
So, there's lots of details I'm leaving out.

298
00:22:43,890 --> 00:22:49,179
But the input was broke into an 33 different
pieces and each piece was passed to one of

299
00:22:49,179 --> 00:22:52,720
seven algorithms to check.

300
00:22:52,720 --> 00:22:56,500
And then the order of the algorithms was scrambled.

301
00:22:56,500 --> 00:23:00,859
And this was repeated 666 times.

302
00:23:00,859 --> 00:23:06,110
So, angr does have support for self modifying
code through unicorn.

303
00:23:06,110 --> 00:23:11,379
But 666 of those might still be a lot.

304
00:23:11,379 --> 00:23:12,379
I'm not sure.

305
00:23:12,379 --> 00:23:16,908
I didn't my attempts at solving it without
breaking it out didn't work.

306
00:23:16,909 --> 00:23:18,749
But maybe you could.

307
00:23:18,749 --> 00:23:21,870
So, it's too large to just fire and forget.

308
00:23:21,870 --> 00:23:24,189
But can we divide the problem up?

309
00:23:24,190 --> 00:23:31,119
So, what I did was I extracted each algorithm
while using a script.

310
00:23:31,119 --> 00:23:37,658
And then I asked angr to solve for each piece
of the key for each algorithm.

311
00:23:37,659 --> 00:23:43,510
So, once you do that, the other 665 keys can
be calculated.

312
00:23:43,510 --> 00:23:48,730
So, you only need it to solve that first key.

313
00:23:48,730 --> 00:23:53,850
So, the extracted programs are not full programs.

314
00:23:53,850 --> 00:23:55,299
They are just shellcode, right?

315
00:23:55,299 --> 00:23:58,840
Because they are called from within within
program.

316
00:23:58,840 --> 00:24:00,299
But that's not a problem.

317
00:24:00,299 --> 00:24:02,690
Angr has support for shellcode.

318
00:24:02,690 --> 00:24:10,989
So, you can load the shellcode into a project
and then you can create a blank state.

319
00:24:10,989 --> 00:24:18,990
So, one option that is helpful is this zero
fill unconstrained memory.

320
00:24:18,990 --> 00:24:25,090
So, if you know that you're gonna have a lot
of memory that, you know, there won't be the

321
00:24:25,090 --> 00:24:31,330
setup code from regular program execution,
this can really help speed things up if it's

322
00:24:31,330 --> 00:24:35,449
okay for that not to be symbolic.

323
00:24:35,450 --> 00:24:40,029
So, the shellcode expected three arguments.

324
00:24:40,029 --> 00:24:45,139
So, one of those was our the part that it
was checking.

325
00:24:45,139 --> 00:24:47,500
That we made symbolic.

326
00:24:47,500 --> 00:24:56,139
And then we used concrete variables for the
two others that we knew.

327
00:24:56,139 --> 00:25:04,769
So, starting with a blank initial state, there's
going to be a lot that program expects.

328
00:25:04,769 --> 00:25:07,200
So, don't necessarily try to read this.

329
00:25:07,200 --> 00:25:13,559
But it's more to illustrate that you can store
information in memory for the initial state.

330
00:25:13,559 --> 00:25:15,379
You can set registers.

331
00:25:15,379 --> 00:25:17,359
And if you're doing something with shellcode.

332
00:25:17,359 --> 00:25:22,269
You might need to do that because you're going
to be missing context for program execution

333
00:25:22,269 --> 00:25:25,379
that shellcode expects.

334
00:25:25,379 --> 00:25:35,139
And then this was an example where there wasn't
there were multiple requirements for the find

335
00:25:35,139 --> 00:25:36,139
state.

336
00:25:36,139 --> 00:25:43,939
So, you can define a function that asks questions
about the state of the program.

337
00:25:43,940 --> 00:25:46,570
So, have I returned from this function?

338
00:25:46,570 --> 00:25:53,070
So, this was the return address that I put
on the stack so I can find it.

339
00:25:53,070 --> 00:25:54,860
And what are are there certain registers I
care about?

340
00:25:54,860 --> 00:26:01,299
So, in this case, the return value of 1 indicated
that it was successful.

341
00:26:01,299 --> 00:26:11,570
So, you can pass this function to explore's
find variable and it will find it for you.

342
00:26:11,570 --> 00:26:18,269
So, to summarize that challenge, we can use
automation to extract for parts of code we

343
00:26:18,269 --> 00:26:19,269
need.

344
00:26:19,269 --> 00:26:21,259
And then we can solve for the key using angr.

345
00:26:21,259 --> 00:26:24,299
So, obviously, there's still a lot of other
work to do.

346
00:26:24,299 --> 00:26:26,479
It's not a push button solution.

347
00:26:26,479 --> 00:26:33,120
But you didn't have to this allowed you to
not reimplement each of those seven algorithms

348
00:26:33,120 --> 00:26:36,649
and reverse those individual functions.

349
00:26:36,649 --> 00:26:40,099
And then there was a key scrambling algorithm.

350
00:26:40,099 --> 00:26:44,849
So, once you had the first key, if you reimplemented
their key scrambling, you could get all of

351
00:26:44,849 --> 00:26:50,129
the keys, feed it back to the binary and get
the flag.

352
00:26:50,129 --> 00:26:58,509
So, we've seen three examples with where symbolic
execution, concolic execution really helped

353
00:26:58,509 --> 00:26:59,509
us out a lot.

354
00:26:59,509 --> 00:27:03,240
But it's important to remember that there's
no silver bullet.

355
00:27:03,240 --> 00:27:06,539
There are challenges that you want to think
about when you're writing your scripts.

356
00:27:06,539 --> 00:27:13,059
So, path explosion where you create a lot
of state really quickly is one.

357
00:27:13,059 --> 00:27:15,039
You might run out of resources.

358
00:27:15,039 --> 00:27:22,080
Laps and recursion are two things that can
cause that to happen.

359
00:27:22,080 --> 00:27:24,139
So, you'll want to watch for that.

360
00:27:24,139 --> 00:27:29,109
And just kind of, you know, anything you can
think of to reduce the amount of state it's

361
00:27:29,109 --> 00:27:30,109
gonna create.

362
00:27:30,109 --> 00:27:36,428
Any more constraints you can give to it is
going to help it solve in a faster time.

363
00:27:36,429 --> 00:27:39,279
And then also library and system call modeling.

364
00:27:39,279 --> 00:27:41,419
There's a lot they're called Sim procedures.

365
00:27:41,419 --> 00:27:44,090
There's a lot that come with angr.

366
00:27:44,090 --> 00:27:48,570
But sometimes they return symbolic variables.

367
00:27:48,570 --> 00:27:50,389
They can't make assumptions about your program.

368
00:27:50,389 --> 00:27:55,279
So, if there's stuff you know about program
that you're analyzing that you can tell angr,

369
00:27:55,279 --> 00:27:57,960
that's going to help you out.

370
00:27:57,960 --> 00:28:03,729
So, in conclusion, concolic execution not
just for academics.

371
00:28:03,729 --> 00:28:10,379
You too can use it to solve all the CTF problems
faster.

372
00:28:10,379 --> 00:28:16,899
And maybe even some challenges that otherwise
would have taken you way too long.

373
00:28:16,899 --> 00:28:18,549
But it's important to remember, there are
limitations.

374
00:28:18,549 --> 00:28:25,100
So, you know, you have to engineer around
those.

375
00:28:25,100 --> 00:28:27,039
These are some resources.

376
00:28:27,039 --> 00:28:29,799
Angr's documentation, like I mentioned before,
is really good.

377
00:28:29,799 --> 00:28:31,950
So, there is a lot of it.

378
00:28:31,950 --> 00:28:33,409
So, it can be a little inundating.

379
00:28:33,409 --> 00:28:39,929
I recommend reading it in conjunction with
looking at this CTF, the angr CTF.

380
00:28:39,929 --> 00:28:42,460
Angr CTF is I think really cool.

381
00:28:42,460 --> 00:28:44,090
It has a lot of scaffolding code.

382
00:28:44,090 --> 00:28:46,399
It's meant for you to learn.

383
00:28:46,399 --> 00:28:53,768
So, it's a great resource and reading about
the reading about the components while you're

384
00:28:53,769 --> 00:28:56,970
using them, you know, kind of helps reinforce
that.

385
00:28:56,970 --> 00:29:00,219
And there's also a Ghidra plugin out if for
angr.

386
00:29:00,219 --> 00:29:03,219
So, that's all.

387
00:29:03,219 --> 00:29:04,219
Thanks.

388
00:29:04,219 --> 00:29:10,200
I guess, are there any questions?

389
00:29:10,200 --> 00:29:13,840
SAMAN: Thank you so much, Christina.

390
00:29:13,840 --> 00:29:16,218
That was really, really amazing.

391
00:29:16,219 --> 00:29:22,479
And I really appreciated it, and I guess everyone
here agreed that the mention of the code.

392
00:29:22,479 --> 00:29:26,090
Like showing off codes was really helpful.

393
00:29:26,090 --> 00:29:31,949
And really got a good hold of, you know, how
and what can go around.

394
00:29:31,950 --> 00:29:32,950
Okay.

395
00:29:32,950 --> 00:29:36,989
So, the question we have here.

396
00:29:36,989 --> 00:29:42,869
You spoke about multiple exit criteria where
you were looking for an exit from a library.

397
00:29:42,869 --> 00:29:46,209
Could you explain a little on this?

398
00:29:46,210 --> 00:29:52,059
CHRISTINA: So, I...

399
00:29:52,059 --> 00:29:56,359
I think the question is asking about the function
I showed where I said there was it wasn't

400
00:29:56,359 --> 00:29:58,918
just you wanted to get to an address.

401
00:29:58,919 --> 00:30:06,469
So, for in the first few I showed, just getting
to a state where the address said you win

402
00:30:06,469 --> 00:30:08,679
meant that you got the flag.

403
00:30:08,679 --> 00:30:14,200
But there are cases like, for example, the
shellcode that I was pulling out that it could

404
00:30:14,200 --> 00:30:19,519
exit, and I wouldn't necessarily know if it
was successful or not.

405
00:30:19,519 --> 00:30:29,120
So, I had to add another another value in
there to say, was the return register, REX,

406
00:30:29,120 --> 00:30:30,590
was that equal to 1?

407
00:30:30,590 --> 00:30:33,309
Because that meant that it had been successful.

408
00:30:33,309 --> 00:30:38,940
Yeah, that would have been the case if there's
not a single state where you can say this

409
00:30:38,940 --> 00:30:44,529
was successful, then you might have to say,
well, I know that I need this memory to be

410
00:30:44,529 --> 00:30:45,529
this value.

411
00:30:45,529 --> 00:30:49,009
Or I know that this return value should be
there.

412
00:30:49,009 --> 00:30:51,580
So, that's the case where you might want to
define a function.

413
00:30:51,580 --> 00:30:55,230
SAMAN: Are thanks, Christina.

414
00:30:55,230 --> 00:31:02,570
I guess, Jaynie, that answers your question.

415
00:31:02,570 --> 00:31:07,908
I guess been getting a lot of appreciation
pointers for you, Christina.

416
00:31:07,909 --> 00:31:10,210
CHRISTINA: I'm glad.

417
00:31:10,210 --> 00:31:16,270
If you think of a question later, feel free
to reach out to me on the Diana Slack.

418
00:31:16,270 --> 00:31:20,750
Just my name, Christina Johns.

419
00:31:20,750 --> 00:31:24,749
SAMAN: Also, Christina, if you could just
pin down those three links.

420
00:31:24,749 --> 00:31:30,210
I guess they're really interested in having
those three URLs that you just provided although

421
00:31:30,210 --> 00:31:31,210
the end.

422
00:31:31,210 --> 00:31:32,639
CHRISTINA: Yeah.

423
00:31:32,639 --> 00:31:39,889
SAMAN: And everyone, I've just shared along
Christina's Twitter handle and how you can

424
00:31:39,889 --> 00:31:50,580
connect back to her on Diana's Slack.

425
00:31:50,580 --> 00:31:55,220
Okay.

426
00:31:55,220 --> 00:32:01,229
The URLs are in.

427
00:32:01,229 --> 00:32:05,200
Great, great.

428
00:32:05,200 --> 00:32:07,179
Okay.

429
00:32:07,179 --> 00:32:20,899
Jaynie, yes, it will be available on YouTube.

430
00:32:20,899 --> 00:32:23,008
You can check The Diana Initiative YouTube
page.

431
00:32:23,009 --> 00:32:25,179
It will be later posted there.

432
00:32:25,179 --> 00:32:30,999
Apart from there, Christina, there's just
one more question.

433
00:32:30,999 --> 00:32:32,320
You talk about using CTF.

434
00:32:32,320 --> 00:32:38,158
So, what is some real world applications of
SMT solvers?

435
00:32:38,159 --> 00:32:40,190
CHRISTINA: Yeah.

436
00:32:40,190 --> 00:32:43,730
SMTs solvers are used in software verification.

437
00:32:43,730 --> 00:32:47,320
So, I think that's why Microsoft did the research,
right?

438
00:32:47,320 --> 00:32:50,149
They wanted to make their code better.

439
00:32:50,149 --> 00:32:56,070
And the same with concolic execution frameworks
or binary execution frameworks like angr.

440
00:32:56,070 --> 00:32:59,629
The DARPA Grand Challenge was for patching.

441
00:32:59,629 --> 00:33:04,269
That's a really common use case.

442
00:33:04,269 --> 00:33:06,960
But any sort of binary analysis that you would
want to do.

443
00:33:06,960 --> 00:33:16,609
There's certain malware obfuscation techniques
where it can help simplify a terrible looking

444
00:33:16,609 --> 00:33:19,228
static analysis situation.

445
00:33:19,229 --> 00:33:24,330
So, it can be used for that as well.

446
00:33:24,330 --> 00:33:28,468
SAMAN: Thanks, Christina.

447
00:33:28,469 --> 00:33:33,419
Hope, Steve, that answers your question.

448
00:33:33,419 --> 00:33:34,970
Okay.

449
00:33:34,970 --> 00:33:40,619
The URLs look fine.

450
00:33:40,619 --> 00:33:47,029
In that case, I guess, if there are any more
issues, or any more questions regarding her

451
00:33:47,029 --> 00:33:51,220
session, you can connect back with Christina
on Diana's Slack.

452
00:33:51,220 --> 00:33:54,359
She's readily available there and she can
answer your questions there.

453
00:33:54,359 --> 00:34:00,699
And apart from that, I will just post a speaker
survey over here for her.

454
00:34:00,700 --> 00:34:06,309
If you could go back and give a small feedback,
that would be great.

455
00:34:06,309 --> 00:34:12,179
And apart from that, I encourage you to stop
at the socials or expo halls.

456
00:34:12,179 --> 00:34:15,040
There's some really amazing events going on
there.

457
00:34:15,040 --> 00:34:19,239
So it will be really great for you all to
be there and hang on there.

458
00:34:19,239 --> 00:34:23,529
You can network with people and attend a lot
of sessions at the expo hall.

459
00:34:23,530 --> 00:34:24,530
Okay.

460
00:34:24,530 --> 00:34:25,659
Great time.

461
00:34:25,659 --> 00:34:28,510
CHRISTINA: Thanks so much!

462
00:34:28,510 --> 00:34:29,940
SAMAN: Yep.

463
00:34:29,940 --> 00:34:31,360
Thank you.

464
00:34:31,360 --> 00:34:32,790
Thanks, everyone!

