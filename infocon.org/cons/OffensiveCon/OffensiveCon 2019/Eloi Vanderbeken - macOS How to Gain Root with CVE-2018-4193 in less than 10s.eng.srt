1
00:00:01,790 --> 00:00:09,450
[Applause]

2
00:00:04,910 --> 00:00:12,629
so I and so am i i'm alois<font color="#E5E5E5"> bruno</font><font color="#CCCCCC"> de</font>

3
00:00:09,450 --> 00:00:15,299
Hibiki<font color="#E5E5E5"> no I'm French and the little</font>

4
00:00:12,630 --> 00:00:18,330
<font color="#E5E5E5">builds a little bit sick</font><font color="#CCCCCC"> so excuse me</font>

5
00:00:15,299 --> 00:00:22,320
for my bad english or<font color="#E5E5E5"> i if</font><font color="#CCCCCC"> i cough too</font>

6
00:00:18,330 --> 00:00:24,839
much in the microphone so I'm<font color="#CCCCCC"> working</font>

7
00:00:22,320 --> 00:00:27,990
for a<font color="#CCCCCC"> cynic Shiva</font><font color="#E5E5E5"> which is</font><font color="#CCCCCC"> a defensive</font>

8
00:00:24,840 --> 00:00:31,619
<font color="#E5E5E5">security company we have 50 ninjas in</font>

9
00:00:27,990 --> 00:00:35,250
our team<font color="#CCCCCC"> and</font><font color="#E5E5E5"> we are divided in a three</font>

10
00:00:31,619 --> 00:00:37,290
different<font color="#CCCCCC"> pools so mainly pentest</font>

11
00:00:35,250 --> 00:00:40,379
reverse engineering and development and

12
00:00:37,290 --> 00:00:44,010
I'm<font color="#CCCCCC"> a</font><font color="#E5E5E5"> team coordinator for our reverse</font>

13
00:00:40,379 --> 00:00:46,410
engineering we have<font color="#CCCCCC"> 21 reversers in the</font>

14
00:00:44,010 --> 00:00:49,050
team and<font color="#E5E5E5"> we focus mainly on lalibela</font>

15
00:00:46,410 --> 00:00:51,860
development<font color="#E5E5E5"> reverse and the</font>

16
00:00:49,050 --> 00:00:54,599
vulnerability research and exploitation

17
00:00:51,860 --> 00:00:59,579
<font color="#E5E5E5">if there is</font><font color="#CCCCCC"> software in it then we can</font>

18
00:00:54,600 --> 00:01:04,589
own it basically everything from boot

19
00:00:59,579 --> 00:01:07,040
loaders to<font color="#CCCCCC"> Webber zero everything and we</font>

20
00:01:04,589 --> 00:01:12,210
<font color="#CCCCCC">are iring so if</font><font color="#E5E5E5"> you're interested</font><font color="#CCCCCC"> though</font>

21
00:01:07,040 --> 00:01:17,070
<font color="#E5E5E5">drop us a mail so quick introduction so</font>

22
00:01:12,210 --> 00:01:19,919
I'm going<font color="#CCCCCC"> to talk about CVE</font><font color="#E5E5E5"> 2018 41 93</font>

23
00:01:17,070 --> 00:01:22,649
<font color="#E5E5E5">so this is a vulnerability in Windows</font>

24
00:01:19,920 --> 00:01:27,659
<font color="#CCCCCC">Server which is a user land</font><font color="#E5E5E5"> demon in Mac</font>

25
00:01:22,650 --> 00:01:32,090
OS which<font color="#E5E5E5"> is used to display</font><font color="#CCCCCC"> Windows on</font>

26
00:01:27,659 --> 00:01:34,619
Mac<font color="#E5E5E5"> OS so for</font><font color="#CCCCCC"> our compositing and and</font>

27
00:01:32,090 --> 00:01:37,310
the routing different events<font color="#E5E5E5"> like when</font>

28
00:01:34,619 --> 00:01:41,400
you click<font color="#CCCCCC"> on a window when you try</font><font color="#E5E5E5"> to</font>

29
00:01:37,310 --> 00:01:43,649
displace things so it was a bug

30
00:01:41,400 --> 00:01:48,649
discovered by a<font color="#CCCCCC"> read</font><font color="#E5E5E5"> two systems and at</font>

31
00:01:43,649 --> 00:01:51,720
least two others<font color="#E5E5E5"> 1 to 1 2018 teams I</font>

32
00:01:48,649 --> 00:01:56,340
heard that a<font color="#CCCCCC"> lot of</font><font color="#E5E5E5"> people at this</font>

33
00:01:51,720 --> 00:02:00,119
<font color="#E5E5E5">burgum</font><font color="#CCCCCC"> was</font><font color="#E5E5E5"> read read</font><font color="#CCCCCC"> to systems used it</font>

34
00:01:56,340 --> 00:02:02,430
in the<font color="#CCCCCC"> poncho on</font><font color="#E5E5E5"> China to spoon a root</font>

35
00:02:00,119 --> 00:02:06,329
shell but their exploits<font color="#E5E5E5"> took something</font>

36
00:02:02,430 --> 00:02:09,330
<font color="#CCCCCC">like 90 seconds to work and their</font>

37
00:02:06,329 --> 00:02:12,269
exploit<font color="#E5E5E5"> didn't work the three first</font>

38
00:02:09,330 --> 00:02:13,200
timer and only the<font color="#E5E5E5"> fourth and</font><font color="#CCCCCC"> endpoint</font>

39
00:02:12,270 --> 00:02:16,980
one rules you

40
00:02:13,200 --> 00:02:19,890
the other three attempts so<font color="#E5E5E5"> didn't even</font>

41
00:02:16,980 --> 00:02:21,899
work d-day<font color="#CCCCCC"> the full strain is</font><font color="#E5E5E5"> I</font>

42
00:02:19,890 --> 00:02:24,510
described in a very<font color="#CCCCCC"> excellent blood</font>

43
00:02:21,900 --> 00:02:27,599
passed ERISA that<font color="#CCCCCC"> I invite you to read</font>

44
00:02:24,510 --> 00:02:30,540
them<font color="#E5E5E5"> and</font><font color="#CCCCCC"> in the last one</font><font color="#E5E5E5"> they offer the</font>

45
00:02:27,599 --> 00:02:37,440
binary ninja<font color="#E5E5E5"> license to the first person</font>

46
00:02:30,540 --> 00:02:39,390
<font color="#E5E5E5">who would publish an exploit</font><font color="#CCCCCC"> that works</font>

47
00:02:37,440 --> 00:02:41,519
in less than<font color="#CCCCCC"> ten seconds</font><font color="#E5E5E5"> without</font>

48
00:02:39,390 --> 00:02:44,790
crashing<font color="#E5E5E5"> Windows Server obviously and</font>

49
00:02:41,519 --> 00:02:49,500
with more<font color="#E5E5E5"> than 90</font><font color="#CCCCCC"> percent</font><font color="#E5E5E5"> of</font><font color="#CCCCCC"> real rot</font>

50
00:02:44,790 --> 00:02:53,880
<font color="#E5E5E5">the ability</font><font color="#CCCCCC"> 3 so I decided to give</font><font color="#E5E5E5"> it a</font>

51
00:02:49,500 --> 00:02:56,160
try so the bag<font color="#CCCCCC"> is very very simple</font><font color="#E5E5E5"> it</font>

52
00:02:53,880 --> 00:02:56,549
was<font color="#CCCCCC"> found they are</font><font color="#E5E5E5"> in process</font><font color="#CCCCCC"> done</font>

53
00:02:56,160 --> 00:02:58,829
<font color="#CCCCCC">fighting</font>

54
00:02:56,549 --> 00:03:01,500
so there is an<font color="#CCCCCC"> attacker con called the</font>

55
00:02:58,829 --> 00:03:04,380
signed<font color="#E5E5E5"> and the index and it can be used</font>

56
00:03:01,500 --> 00:03:07,319
without a lower bound<font color="#E5E5E5"> so</font><font color="#CCCCCC"> are they</font><font color="#E5E5E5"> clear</font>

57
00:03:04,380 --> 00:03:09,420
you can access the third element<font color="#CCCCCC"> of the</font>

58
00:03:07,319 --> 00:03:11,849
array you<font color="#CCCCCC"> cannot access</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> 10th</font>

59
00:03:09,420 --> 00:03:17,220
elements of the array but you can access

60
00:03:11,849 --> 00:03:19,798
<font color="#CCCCCC">the -10 element of the array</font><font color="#E5E5E5"> so really a</font>

61
00:03:17,220 --> 00:03:23,489
simple bug but there is some limitation

62
00:03:19,799 --> 00:03:28,769
<font color="#E5E5E5">you are the elements in the</font><font color="#CCCCCC"> array</font><font color="#E5E5E5"> must</font>

63
00:03:23,489 --> 00:03:31,319
<font color="#E5E5E5">have</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> word equal to 400 and must be</font>

64
00:03:28,769 --> 00:03:35,310
<font color="#E5E5E5">followed</font><font color="#CCCCCC"> by a null pointer and if those</font>

65
00:03:31,319 --> 00:03:37,920
<font color="#CCCCCC">preconditions</font><font color="#E5E5E5"> are met then you have a</font><font color="#CCCCCC"> 1</font>

66
00:03:35,310 --> 00:03:40,260
pointer which is a written in place of

67
00:03:37,920 --> 00:03:43,619
the null pointer<font color="#CCCCCC"> and there is a Mac port</font>

68
00:03:40,260 --> 00:03:48,480
names that that will overwrite<font color="#CCCCCC"> the</font><font color="#E5E5E5"> D</font>

69
00:03:43,620 --> 00:03:51,269
<font color="#E5E5E5">word next to it so the</font><font color="#CCCCCC"> it pointer points</font>

70
00:03:48,480 --> 00:03:55,730
<font color="#CCCCCC">for the moment on an unknown object and</font>

71
00:03:51,269 --> 00:03:55,730
that<font color="#E5E5E5"> wasn't described by</font><font color="#CCCCCC"> read to system</font>

72
00:03:55,819 --> 00:04:01,708
so a little<font color="#E5E5E5"> digression maybe and not all</font>

73
00:03:59,069 --> 00:04:04,410
<font color="#E5E5E5">of you know what's a Mac port name even</font>

74
00:04:01,709 --> 00:04:07,799
if ty<font color="#CCCCCC"> lumber and talked a little bit</font>

75
00:04:04,410 --> 00:04:12,750
about<font color="#E5E5E5"> that</font><font color="#CCCCCC"> yesterday</font><font color="#E5E5E5"> so basically it's</font>

76
00:04:07,799 --> 00:04:16,709
just an ID which<font color="#CCCCCC"> is used to to reference</font>

77
00:04:12,750 --> 00:04:19,680
<font color="#E5E5E5">a port and the port is like a general</font>

78
00:04:16,709 --> 00:04:23,610
<font color="#CCCCCC">mechanism used to send message both</font>

79
00:04:19,680 --> 00:04:26,430
<font color="#CCCCCC">inter processes and to</font><font color="#E5E5E5"> kernel objects</font>

80
00:04:23,610 --> 00:04:29,009
so a<font color="#CCCCCC"> mock port name is basically under</font>

81
00:04:26,430 --> 00:04:33,389
to talk with the<font color="#CCCCCC"> kernel object or with</font>

82
00:04:29,009 --> 00:04:39,120
the server<font color="#CCCCCC"> so this this index is</font>

83
00:04:33,389 --> 00:04:41,639
<font color="#E5E5E5">basically incremented at each at each</font>

84
00:04:39,120 --> 00:04:45,180
generation<font color="#E5E5E5"> and there is a</font><font color="#CCCCCC"> 10-count</font><font color="#E5E5E5"> which</font>

85
00:04:41,639 --> 00:04:46,979
<font color="#E5E5E5">is used to</font><font color="#CCCCCC"> make sure that if you reuse</font>

86
00:04:45,180 --> 00:04:50,940
<font color="#CCCCCC">the</font><font color="#E5E5E5"> same index you don't have the same</font>

87
00:04:46,979 --> 00:04:53,539
<font color="#CCCCCC">Mac port name</font><font color="#E5E5E5"> this is to detect</font><font color="#CCCCCC"> to early</font>

88
00:04:50,940 --> 00:04:57,630
detect the reuse of a Mac port name

89
00:04:53,539 --> 00:05:01,469
<font color="#CCCCCC">which is which was unintentionally</font><font color="#E5E5E5"> freed</font>

90
00:04:57,630 --> 00:05:04,860
and then<font color="#CCCCCC"> reused so as</font><font color="#E5E5E5"> this used to be a</font>

91
00:05:01,470 --> 00:05:07,590
100% deterministic<font color="#E5E5E5"> and it was used</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> by</font>

92
00:05:04,860 --> 00:05:10,440
the<font color="#CCCCCC"> attackers</font><font color="#E5E5E5"> to out cut some values in</font>

93
00:05:07,590 --> 00:05:13,198
their exploits<font color="#E5E5E5"> most notably Mac tasks</font>

94
00:05:10,440 --> 00:05:17,430
<font color="#E5E5E5">self port which is</font><font color="#CCCCCC"> basically under on</font>

95
00:05:13,199 --> 00:05:19,289
the process if you<font color="#E5E5E5"> have a</font><font color="#CCCCCC"> multi</font><font color="#E5E5E5"> Mac</font><font color="#CCCCCC"> task</font>

96
00:05:17,430 --> 00:05:21,509
<font color="#E5E5E5">port on the process and you can</font>

97
00:05:19,289 --> 00:05:25,500
<font color="#CCCCCC">read/write its memory</font><font color="#E5E5E5"> you can manipulate</font>

98
00:05:21,509 --> 00:05:29,460
its thread so being able to<font color="#CCCCCC"> arm code</font>

99
00:05:25,500 --> 00:05:32,849
this<font color="#E5E5E5"> value was useful in exploits you</font>

100
00:05:29,460 --> 00:05:36,330
are you can also send Mac ports to

101
00:05:32,849 --> 00:05:39,419
another task<font color="#E5E5E5"> so you could spray a lot of</font>

102
00:05:36,330 --> 00:05:42,870
Mac ports and<font color="#E5E5E5"> out code a Mac port name</font>

103
00:05:39,419 --> 00:05:45,359
in your<font color="#CCCCCC"> exploit</font><font color="#E5E5E5"> so you don't have to</font>

104
00:05:42,870 --> 00:05:48,539
make any logic you can just make a big

105
00:05:45,360 --> 00:05:50,880
<font color="#CCCCCC">rub chain which send a</font><font color="#E5E5E5"> Mac nice H</font>

106
00:05:48,539 --> 00:05:54,300
containing the Mac<font color="#CCCCCC"> task self</font><font color="#E5E5E5"> your</font>

107
00:05:50,880 --> 00:05:58,800
exploiting process and that just works

108
00:05:54,300 --> 00:06:01,620
<font color="#CCCCCC">so since iOS</font><font color="#E5E5E5"> 11 Apple decided to fix</font>

109
00:05:58,800 --> 00:06:03,840
this and now the<font color="#E5E5E5"> name</font><font color="#CCCCCC"> space is</font>

110
00:06:01,620 --> 00:06:08,159
<font color="#CCCCCC">randomized</font><font color="#E5E5E5"> which means that you cannot</font>

111
00:06:03,840 --> 00:06:10,520
predict what<font color="#E5E5E5"> will be the next Mac</font><font color="#CCCCCC"> port</font>

112
00:06:08,159 --> 00:06:13,469
names that will<font color="#E5E5E5"> be used by the kernel</font>

113
00:06:10,520 --> 00:06:16,590
but<font color="#CCCCCC"> eight first</font><font color="#E5E5E5"> entries are not yet</font>

114
00:06:13,469 --> 00:06:19,590
randomized so because of compatibility

115
00:06:16,590 --> 00:06:22,409
reason so you<font color="#E5E5E5"> can</font><font color="#CCCCCC"> still</font><font color="#E5E5E5"> out code Mac</font>

116
00:06:19,590 --> 00:06:26,599
<font color="#CCCCCC">tasks alpha and your exploits they also</font>

117
00:06:22,409 --> 00:06:29,370
try to randomize the generation counter

118
00:06:26,599 --> 00:06:32,759
but it is still initialized with free

119
00:06:29,370 --> 00:06:35,070
and still incremented by<font color="#CCCCCC"> 4 the only</font>

120
00:06:32,759 --> 00:06:39,400
<font color="#E5E5E5">difference is</font><font color="#CCCCCC"> now the</font>

121
00:06:35,070 --> 00:06:43,390
my<font color="#E5E5E5"> poor name cycle after sixteen thirty</font>

122
00:06:39,400 --> 00:06:46,359
<font color="#E5E5E5">to sixty or 48 or</font><font color="#CCCCCC"> sixty we are four</font>

123
00:06:43,390 --> 00:06:49,419
<font color="#E5E5E5">generations instead of</font><font color="#CCCCCC"> 64</font><font color="#E5E5E5"> before so you</font>

124
00:06:46,360 --> 00:06:55,380
don't know how many<font color="#E5E5E5"> times you</font><font color="#CCCCCC"> need to do</font>

125
00:06:49,420 --> 00:07:01,620
a reallocate<font color="#CCCCCC"> a</font><font color="#E5E5E5"> port to use it in your</font><font color="#CCCCCC"> to</font>

126
00:06:55,380 --> 00:07:05,230
so it can be used<font color="#E5E5E5"> by your your victim</font><font color="#CCCCCC"> so</font>

127
00:07:01,620 --> 00:07:09,610
it was just a little<font color="#E5E5E5"> digression</font><font color="#CCCCCC"> we won't</font>

128
00:07:05,230 --> 00:07:12,010
talk<font color="#CCCCCC"> about</font><font color="#E5E5E5"> Mac port anymore</font><font color="#CCCCCC"> just a quick</font>

129
00:07:09,610 --> 00:07:14,290
recap<font color="#CCCCCC"> about the</font><font color="#E5E5E5"> vulnerability so we can</font>

130
00:07:12,010 --> 00:07:16,840
overwrite a null pointer with<font color="#CCCCCC"> a pointer</font>

131
00:07:14,290 --> 00:07:19,780
in the<font color="#CCCCCC"> rip and we can have a</font><font color="#E5E5E5"> write a</font><font color="#CCCCCC"> D</font>

132
00:07:16,840 --> 00:07:21,909
word<font color="#CCCCCC"> with a</font><font color="#E5E5E5"> Mac port name</font><font color="#CCCCCC"> because</font>

133
00:07:19,780 --> 00:07:24,580
Windows Server has<font color="#CCCCCC"> a lot of</font><font color="#E5E5E5"> different</font>

134
00:07:21,910 --> 00:07:26,410
clients<font color="#CCCCCC"> we don't know what will be</font><font color="#E5E5E5"> the</font>

135
00:07:24,580 --> 00:07:29,109
<font color="#CCCCCC">Mac port names that will be used</font><font color="#E5E5E5"> to</font>

136
00:07:26,410 --> 00:07:31,570
override the D word and we don't know

137
00:07:29,110 --> 00:07:34,419
either what's the value of<font color="#E5E5E5"> the of the</font>

138
00:07:31,570 --> 00:07:38,919
<font color="#E5E5E5">EEP pointer which is used</font><font color="#CCCCCC"> at to</font>

139
00:07:34,419 --> 00:07:41,680
overwrite as<font color="#CCCCCC"> another pointer so</font><font color="#E5E5E5"> read to</font>

140
00:07:38,919 --> 00:07:46,719
system exploits<font color="#CCCCCC"> use the Mac port name to</font>

141
00:07:41,680 --> 00:07:49,770
over to overwrite<font color="#CCCCCC"> a pointer and they</font>

142
00:07:46,720 --> 00:07:52,360
used a lot of<font color="#CCCCCC"> EEP spread make sure</font><font color="#E5E5E5"> that</font>

143
00:07:49,770 --> 00:07:56,440
the<font color="#CCCCCC"> overwritten</font><font color="#E5E5E5"> pointer points and</font>

144
00:07:52,360 --> 00:07:59,680
<font color="#E5E5E5">studied the memory and</font><font color="#CCCCCC"> well they did a</font>

145
00:07:56,440 --> 00:08:01,900
lot of<font color="#E5E5E5"> complicated</font><font color="#CCCCCC"> stuff and</font><font color="#E5E5E5"> I invite</font>

146
00:07:59,680 --> 00:08:05,530
you<font color="#CCCCCC"> to read the blog post</font><font color="#E5E5E5"> to understand</font>

147
00:08:01,900 --> 00:08:08,229
it what you will<font color="#E5E5E5"> need to remember is the</font>

148
00:08:05,530 --> 00:08:11,140
problem with this approach is because

149
00:08:08,229 --> 00:08:14,729
<font color="#CCCCCC">you</font><font color="#E5E5E5"> are using Mac code name you may have</font>

150
00:08:11,140 --> 00:08:17,650
to eat sprayer<font color="#CCCCCC"> four gigabytes of memory</font>

151
00:08:14,729 --> 00:08:22,150
which<font color="#CCCCCC"> is okay</font><font color="#E5E5E5"> for bone to an exploit but</font>

152
00:08:17,650 --> 00:08:24,640
can be a very<font color="#E5E5E5"> slow so now I'm going</font><font color="#CCCCCC"> to</font>

153
00:08:22,150 --> 00:08:28,690
describe exploit strategies that are

154
00:08:24,640 --> 00:08:31,840
that I used so the first thing that<font color="#E5E5E5"> I</font>

155
00:08:28,690 --> 00:08:34,479
thought<font color="#E5E5E5"> when I read</font><font color="#CCCCCC"> their</font><font color="#E5E5E5"> their exploit</font>

156
00:08:31,840 --> 00:08:37,900
was why not<font color="#CCCCCC"> using the pointer value</font>

157
00:08:34,479 --> 00:08:40,930
instead of<font color="#E5E5E5"> the Mac port name so the idea</font>

158
00:08:37,900 --> 00:08:43,890
was to basically<font color="#E5E5E5"> just find a null</font>

159
00:08:40,929 --> 00:08:43,890
optional pointer

160
00:08:45,939 --> 00:08:53,509
replace<font color="#CCCCCC"> it with</font><font color="#E5E5E5"> our unknown point eight</font>

161
00:08:50,089 --> 00:08:56,720
pointer managed<font color="#E5E5E5"> to freeze the</font><font color="#CCCCCC"> associated</font>

162
00:08:53,509 --> 00:09:00,110
object reuse the allocation with<font color="#E5E5E5"> control</font>

163
00:08:56,720 --> 00:09:02,540
the data and then<font color="#E5E5E5"> trigger</font><font color="#CCCCCC"> the use of the</font>

164
00:09:00,110 --> 00:09:05,629
optional optional pointer to gain a<font color="#CCCCCC"> code</font>

165
00:09:02,540 --> 00:09:09,679
execution<font color="#E5E5E5"> and execute our payload so</font>

166
00:09:05,629 --> 00:09:12,459
easy<font color="#CCCCCC"> basically I thought that I was</font>

167
00:09:09,679 --> 00:09:16,699
going<font color="#E5E5E5"> to do find a way to place this</font>

168
00:09:12,459 --> 00:09:18,518
pattern in memory<font color="#E5E5E5"> replace the null</font>

169
00:09:16,699 --> 00:09:21,529
pointer with an overwritten printer

170
00:09:18,519 --> 00:09:24,649
freeze the object reuse the allocation

171
00:09:21,529 --> 00:09:28,269
with a<font color="#E5E5E5"> controlled data use the</font>

172
00:09:24,649 --> 00:09:31,759
overwritten pointer<font color="#E5E5E5"> gain execution and</font>

173
00:09:28,269 --> 00:09:33,589
and that's it so<font color="#E5E5E5"> basically when you do</font>

174
00:09:31,759 --> 00:09:37,699
everybody<font color="#E5E5E5"> knows that when you control</font>

175
00:09:33,589 --> 00:09:39,319
rip everything<font color="#CCCCCC"> is over so the first</font>

176
00:09:37,699 --> 00:09:42,378
thing we need to do to exploit or

177
00:09:39,319 --> 00:09:48,490
vulnerability is to find a<font color="#E5E5E5"> null optional</font>

178
00:09:42,379 --> 00:09:48,490
pointer that we can later replace

179
00:09:48,610 --> 00:09:54,350
fortunately Windows Server give us a

180
00:09:51,019 --> 00:09:58,399
really powerful primitive<font color="#E5E5E5"> because we can</font>

181
00:09:54,350 --> 00:10:00,799
set properties<font color="#E5E5E5"> and connection that can</font>

182
00:09:58,399 --> 00:10:03,829
<font color="#E5E5E5">be used on any connection no privileges</font>

183
00:10:00,799 --> 00:10:08,029
are required and we said we can set

184
00:10:03,829 --> 00:10:10,459
arbitrary<font color="#E5E5E5"> properties and the values</font><font color="#CCCCCC"> of</font>

185
00:10:08,029 --> 00:10:12,199
these properties<font color="#E5E5E5"> are</font><font color="#CCCCCC"> objective-c values</font>

186
00:10:10,459 --> 00:10:15,849
that are this this<font color="#CCCCCC"> zero</font>

187
00:10:12,199 --> 00:10:19,579
<font color="#CCCCCC">realised sorry from</font><font color="#E5E5E5"> the user input and</font>

188
00:10:15,850 --> 00:10:23,899
<font color="#CCCCCC">later we</font><font color="#E5E5E5"> can read delete and modify</font>

189
00:10:19,579 --> 00:10:26,748
those properties<font color="#E5E5E5"> so this is a very</font>

190
00:10:23,899 --> 00:10:29,360
convenient convenient way<font color="#CCCCCC"> to miss a trip</font>

191
00:10:26,749 --> 00:10:31,939
or to read back<font color="#CCCCCC"> modified properties</font><font color="#E5E5E5"> to</font>

192
00:10:29,360 --> 00:10:35,299
<font color="#CCCCCC">our liquor values or</font><font color="#E5E5E5"> to place</font><font color="#CCCCCC"> a</font>

193
00:10:31,939 --> 00:10:38,569
arbitrary<font color="#CCCCCC"> data</font><font color="#E5E5E5"> in the memory so from the</font>

194
00:10:35,299 --> 00:10:40,309
dock we know that we can allocate a lot

195
00:10:38,569 --> 00:10:42,319
<font color="#CCCCCC">of different objects so mainly</font>

196
00:10:40,309 --> 00:10:47,449
everything that can be<font color="#E5E5E5"> realized through</font>

197
00:10:42,319 --> 00:10:51,920
the objective-c API so<font color="#CCCCCC"> that includes</font><font color="#E5E5E5"> CF</font>

198
00:10:47,449 --> 00:10:55,279
data<font color="#E5E5E5"> strings arrays</font><font color="#CCCCCC"> dictionary dates</font>

199
00:10:51,920 --> 00:10:57,709
boolean and numbers so let's see what we

200
00:10:55,279 --> 00:10:59,570
can<font color="#CCCCCC"> do with through the object</font>

201
00:10:57,710 --> 00:11:04,070
because I remember we<font color="#CCCCCC"> haven't we need to</font>

202
00:10:59,570 --> 00:11:06,440
have the following shape with a 400<font color="#E5E5E5"> G</font>

203
00:11:04,070 --> 00:11:08,690
word<font color="#E5E5E5"> followed by a new pointer for the</font>

204
00:11:06,440 --> 00:11:17,630
road by<font color="#E5E5E5"> the</font><font color="#CCCCCC"> word that can that</font><font color="#E5E5E5"> we can</font>

205
00:11:08,690 --> 00:11:20,060
<font color="#E5E5E5">safely</font><font color="#CCCCCC"> overwritten</font><font color="#E5E5E5"> so well how can we</font>

206
00:11:17,630 --> 00:11:23,120
have<font color="#CCCCCC"> this</font><font color="#E5E5E5"> patterns in memory so of</font>

207
00:11:20,060 --> 00:11:26,329
<font color="#E5E5E5">course of</font><font color="#CCCCCC"> course</font><font color="#E5E5E5"> we can</font><font color="#CCCCCC"> use data</font><font color="#E5E5E5"> or</font>

208
00:11:23,120 --> 00:11:28,370
strings<font color="#E5E5E5"> so we just put the patterns that</font>

209
00:11:26,330 --> 00:11:30,590
we<font color="#E5E5E5"> want in our strings because it's</font>

210
00:11:28,370 --> 00:11:33,530
Objective C we can have<font color="#E5E5E5"> a null byte in</font>

211
00:11:30,590 --> 00:11:37,100
our strings it's not a<font color="#E5E5E5"> problem even if</font>

212
00:11:33,530 --> 00:11:40,010
it was we<font color="#E5E5E5"> can just use TF data that was</font>

213
00:11:37,100 --> 00:11:42,440
<font color="#E5E5E5">used by a red to to get the Mac</font><font color="#CCCCCC"> port</font>

214
00:11:40,010 --> 00:11:44,810
name and pointer values in<font color="#CCCCCC"> there exploit</font>

215
00:11:42,440 --> 00:11:46,280
but<font color="#E5E5E5"> of course that won't</font><font color="#CCCCCC"> get that</font><font color="#E5E5E5"> won't</font>

216
00:11:44,810 --> 00:11:50,599
give you<font color="#E5E5E5"> on</font><font color="#CCCCCC"> your code execution because</font>

217
00:11:46,280 --> 00:11:53,360
<font color="#CCCCCC">you are just</font><font color="#E5E5E5"> modifying data so we are</font>

218
00:11:50,600 --> 00:11:56,600
not<font color="#E5E5E5"> thinking about</font><font color="#CCCCCC"> C F array if there is</font>

219
00:11:53,360 --> 00:11:59,450
array<font color="#CCCCCC"> maybe here you can you can put a</font>

220
00:11:56,600 --> 00:12:01,910
null object and in it and get another

221
00:11:59,450 --> 00:12:04,580
pointer replaced but actually an

222
00:12:01,910 --> 00:12:08,839
objective-c<font color="#E5E5E5"> pointers are not really know</font>

223
00:12:04,580 --> 00:12:12,820
that<font color="#E5E5E5"> they are this is</font><font color="#CCCCCC"> a special</font>

224
00:12:08,840 --> 00:12:16,850
singleton object which is used<font color="#E5E5E5"> to</font>

225
00:12:12,820 --> 00:12:18,530
signify<font color="#CCCCCC"> that a value is new so you can</font>

226
00:12:16,850 --> 00:12:22,760
add you can<font color="#E5E5E5"> you cannot have any new</font>

227
00:12:18,530 --> 00:12:24,589
pointer is in your CF array of course

228
00:12:22,760 --> 00:12:27,800
date boolean<font color="#E5E5E5"> and numbers are useless</font>

229
00:12:24,590 --> 00:12:31,310
<font color="#CCCCCC">you're</font><font color="#E5E5E5"> basically just values so even if</font>

230
00:12:27,800 --> 00:12:33,229
you<font color="#E5E5E5"> manage to</font><font color="#CCCCCC"> two</font><font color="#E5E5E5"> over</font><font color="#CCCCCC"> right</font><font color="#E5E5E5"> over right</font>

231
00:12:31,310 --> 00:12:38,239
<font color="#E5E5E5">there values that won't give you a</font>

232
00:12:33,230 --> 00:12:41,240
nickel<font color="#E5E5E5"> a exact so</font><font color="#CCCCCC"> there's the latest</font>

233
00:12:38,240 --> 00:12:47,810
<font color="#CCCCCC">object that we have left is a CF</font>

234
00:12:41,240 --> 00:12:50,690
dictionary so they use - table and our

235
00:12:47,810 --> 00:12:53,380
tables contain null pointers so that's a

236
00:12:50,690 --> 00:12:56,900
win and during our table<font color="#E5E5E5"> destructions</font>

237
00:12:53,380 --> 00:13:00,260
the allocator with<font color="#CCCCCC"> will just go through</font>

238
00:12:56,900 --> 00:13:03,079
the wall hash table<font color="#E5E5E5"> check if the pointer</font>

239
00:13:00,260 --> 00:13:06,800
is new<font color="#E5E5E5"> or not and if it's new then it</font>

240
00:13:03,080 --> 00:13:09,410
will be released so we think<font color="#E5E5E5"> that's a</font>

241
00:13:06,800 --> 00:13:11,069
win but<font color="#E5E5E5"> not really because you remember</font>

242
00:13:09,410 --> 00:13:13,620
we have a CF dictionary don't

243
00:13:11,070 --> 00:13:17,009
we have to<font color="#CCCCCC"> overwrite two pointers the</font>

244
00:13:13,620 --> 00:13:21,329
value and the key because if you if we

245
00:13:17,009 --> 00:13:23,430
only overwrite the value then when the

246
00:13:21,329 --> 00:13:27,410
key will<font color="#CCCCCC"> be destroyed you will</font><font color="#E5E5E5"> have a</font>

247
00:13:23,430 --> 00:13:30,870
null pointer dereference<font color="#E5E5E5"> and if you just</font>

248
00:13:27,410 --> 00:13:34,910
overwrite the key without<font color="#E5E5E5"> the values and</font>

249
00:13:30,870 --> 00:13:37,579
the pointer will<font color="#E5E5E5"> just not be used</font>

250
00:13:34,910 --> 00:13:41,910
moreover we still have the problem<font color="#CCCCCC"> of</font>

251
00:13:37,579 --> 00:13:44,729
<font color="#E5E5E5">the</font><font color="#CCCCCC"> 400g want to be placed before on</font>

252
00:13:41,910 --> 00:13:47,339
<font color="#E5E5E5">their pointer and we don't know if it's</font>

253
00:13:44,730 --> 00:13:50,069
really safe<font color="#CCCCCC"> to overwrite the</font><font color="#E5E5E5"> g-word just</font>

254
00:13:47,339 --> 00:13:55,139
after a<font color="#E5E5E5"> pointer in the in the rush table</font>

255
00:13:50,069 --> 00:13:55,969
<font color="#E5E5E5">so we need to go deeper fortunately</font><font color="#CCCCCC"> for</font>

256
00:13:55,139 --> 00:13:59,850
us

257
00:13:55,970 --> 00:14:02,759
<font color="#E5E5E5">corefoundation is kind</font><font color="#CCCCCC"> open-source kind</font>

258
00:13:59,850 --> 00:14:05,940
of because there was no update for<font color="#E5E5E5"> four</font>

259
00:14:02,759 --> 00:14:07,949
years so the code changed a little bit

260
00:14:05,940 --> 00:14:10,769
but<font color="#E5E5E5"> the source helps</font><font color="#CCCCCC"> rot</font>

261
00:14:07,949 --> 00:14:13,920
and when when you read the source you

262
00:14:10,769 --> 00:14:16,560
are<font color="#E5E5E5"> you find out that actually a CF</font>

263
00:14:13,920 --> 00:14:19,500
property<font color="#CCCCCC"> list create with data</font><font color="#E5E5E5"> except</font>

264
00:14:16,560 --> 00:14:23,130
three different<font color="#E5E5E5"> formats it first tries</font>

265
00:14:19,500 --> 00:14:24,959
to decode binary format<font color="#E5E5E5"> if it if it</font>

266
00:14:23,130 --> 00:14:28,439
doesn't work<font color="#CCCCCC"> then it tries to parse it</font>

267
00:14:24,959 --> 00:14:32,609
as XML<font color="#E5E5E5"> and if it doesn't work then it</font>

268
00:14:28,440 --> 00:14:35,940
tries to<font color="#E5E5E5"> pass the old plist format for</font>

269
00:14:32,610 --> 00:14:40,290
<font color="#CCCCCC">jews who knows it it's a JSON like</font>

270
00:14:35,940 --> 00:14:43,529
format so let's<font color="#CCCCCC"> try let's read all the</font>

271
00:14:40,290 --> 00:14:45,930
source code<font color="#CCCCCC"> XML and the old format</font><font color="#E5E5E5"> are</font>

272
00:14:43,529 --> 00:14:48,920
not really interesting<font color="#CCCCCC"> I'm just</font><font color="#E5E5E5"> basilic</font>

273
00:14:45,930 --> 00:14:53,430
here basically<font color="#CCCCCC"> a so this yet</font><font color="#E5E5E5"> this</font>

274
00:14:48,920 --> 00:14:56,130
<font color="#CCCCCC">réaliser but binary format however</font><font color="#E5E5E5"> is a</font>

275
00:14:53,430 --> 00:14:58,949
little<font color="#CCCCCC"> bit more interesting</font><font color="#E5E5E5"> because it</font>

276
00:14:56,130 --> 00:15:01,529
supports more objects than the other and

277
00:14:58,949 --> 00:15:04,740
<font color="#E5E5E5">more</font><font color="#CCCCCC"> object and what's documented in</font>

278
00:15:01,529 --> 00:15:09,689
Apple documentation most notably<font color="#E5E5E5"> it can</font>

279
00:15:04,740 --> 00:15:14,880
do it<font color="#E5E5E5"> can</font><font color="#CCCCCC"> uncie realize CF null</font><font color="#E5E5E5"> and CF</font>

280
00:15:09,689 --> 00:15:18,800
set<font color="#E5E5E5"> something</font><font color="#CCCCCC"> is very</font><font color="#E5E5E5"> very strange in in</font>

281
00:15:14,880 --> 00:15:21,209
the code is<font color="#CCCCCC"> that you on it support</font>

282
00:15:18,800 --> 00:15:23,639
<font color="#E5E5E5">deserializing but you cannot you see</font>

283
00:15:21,209 --> 00:15:24,420
<font color="#CCCCCC">realises those values</font><font color="#E5E5E5"> you if you try to</font>

284
00:15:23,639 --> 00:15:27,930
use the

285
00:15:24,420 --> 00:15:29,729
API to serialize<font color="#CCCCCC"> EF said</font><font color="#E5E5E5"> it will just</font>

286
00:15:27,930 --> 00:15:33,269
<font color="#E5E5E5">throw an error and you won't be able to</font>

287
00:15:29,730 --> 00:15:38,930
<font color="#E5E5E5">rise</font><font color="#CCCCCC"> this values</font><font color="#E5E5E5"> so you have to forge</font>

288
00:15:33,269 --> 00:15:42,720
<font color="#CCCCCC">your</font><font color="#E5E5E5"> own</font><font color="#CCCCCC"> CF set she</font><font color="#E5E5E5"> realized for you and</font>

289
00:15:38,930 --> 00:15:45,420
what's<font color="#CCCCCC"> great with</font><font color="#E5E5E5"> CF set is that the</font>

290
00:15:42,720 --> 00:15:48,060
excuse the exact same hash tables and a

291
00:15:45,420 --> 00:15:50,370
dictionary<font color="#CCCCCC"> but obviously there is an</font>

292
00:15:48,060 --> 00:15:53,339
<font color="#CCCCCC">only values and no keys in a CF set so</font>

293
00:15:50,370 --> 00:15:56,940
you just have<font color="#CCCCCC"> to overwrite</font><font color="#E5E5E5"> one null</font>

294
00:15:53,339 --> 00:16:01,050
pointer to get cut execution but we

295
00:15:56,940 --> 00:16:05,550
still<font color="#E5E5E5"> need</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> put</font><font color="#CCCCCC"> 400</font><font color="#E5E5E5"> before on our</font><font color="#CCCCCC"> new</font>

296
00:16:01,050 --> 00:16:09,649
pointer so for the moment<font color="#CCCCCC"> or battle-plan</font>

297
00:16:05,550 --> 00:16:13,229
become a little<font color="#E5E5E5"> bit more clear here</font>

298
00:16:09,649 --> 00:16:17,250
something like<font color="#CCCCCC"> that we</font><font color="#E5E5E5"> are going</font><font color="#CCCCCC"> to</font>

299
00:16:13,230 --> 00:16:24,329
create a CF set<font color="#E5E5E5"> and we will overwrite</font>

300
00:16:17,250 --> 00:16:28,279
<font color="#CCCCCC">the</font><font color="#E5E5E5"> null pointer with our</font><font color="#CCCCCC"> 8 pointer so</font>

301
00:16:24,329 --> 00:16:33,599
the question is are we going<font color="#E5E5E5"> to put this</font>

302
00:16:28,279 --> 00:16:35,459
<font color="#CCCCCC">0x 400 before a</font><font color="#E5E5E5"> new pointer so the</font>

303
00:16:33,600 --> 00:16:39,029
answer<font color="#CCCCCC"> is again</font><font color="#E5E5E5"> you know in core</font>

304
00:16:35,459 --> 00:16:41,819
<font color="#E5E5E5">foundation internals because some some</font>

305
00:16:39,029 --> 00:16:43,829
tiny objects are stored directly<font color="#E5E5E5"> in</font>

306
00:16:41,820 --> 00:16:47,010
their<font color="#CCCCCC"> reference that means that instead</font>

307
00:16:43,829 --> 00:16:49,260
<font color="#CCCCCC">of having a pointer and EEP allocation</font>

308
00:16:47,010 --> 00:16:51,420
<font color="#E5E5E5">you</font><font color="#CCCCCC"> would have directly</font><font color="#E5E5E5"> the value in the</font>

309
00:16:49,260 --> 00:16:54,360
the pointer which is not going to

310
00:16:51,420 --> 00:16:58,110
<font color="#E5E5E5">anymore obviously</font><font color="#CCCCCC"> it only works for</font>

311
00:16:54,360 --> 00:17:01,019
small<font color="#E5E5E5"> values that can be put in just a</font>

312
00:16:58,110 --> 00:17:03,390
pointer and<font color="#E5E5E5"> so that saves some memory</font>

313
00:17:01,019 --> 00:17:05,640
and<font color="#E5E5E5"> CPU cycles because you don't have to</font>

314
00:17:03,390 --> 00:17:07,470
keep references on<font color="#E5E5E5"> to the objects and</font>

315
00:17:05,640 --> 00:17:10,730
you don't have to allocate or free

316
00:17:07,470 --> 00:17:13,380
memories when you are manipulating<font color="#E5E5E5"> them</font>

317
00:17:10,730 --> 00:17:16,349
to<font color="#E5E5E5"> identify those objects that are</font>

318
00:17:13,380 --> 00:17:20,339
directly storing the reference so lower

319
00:17:16,349 --> 00:17:24,510
significant bit is set because every

320
00:17:20,339 --> 00:17:27,599
allocation is a multiple of 16 so if the

321
00:17:24,510 --> 00:17:31,290
lowest bit is set you know that is<font color="#E5E5E5"> not a</font>

322
00:17:27,599 --> 00:17:33,959
pointer for from the sweep<font color="#E5E5E5"> the next</font>

323
00:17:31,290 --> 00:17:38,370
three<font color="#CCCCCC"> loud significant bit</font><font color="#E5E5E5"> encodes the</font>

324
00:17:33,960 --> 00:17:41,040
type of<font color="#E5E5E5"> the object so</font><font color="#CCCCCC"> you don't have</font>

325
00:17:38,370 --> 00:17:44,219
all those three<font color="#E5E5E5"> bits that are used today</font>

326
00:17:41,040 --> 00:17:46,770
and there is only a<font color="#CCCCCC"> 1 2 3 4 5 5</font>

327
00:17:44,220 --> 00:17:50,210
<font color="#CCCCCC">different</font><font color="#E5E5E5"> types that are that are</font>

328
00:17:46,770 --> 00:17:52,440
supported right now and what you need<font color="#CCCCCC"> to</font>

329
00:17:50,210 --> 00:17:55,680
you need to<font color="#CCCCCC"> be</font><font color="#E5E5E5"> careful</font><font color="#CCCCCC"> when</font><font color="#E5E5E5"> you use</font>

330
00:17:52,440 --> 00:17:59,040
<font color="#E5E5E5">those pointers because the tag type</font>

331
00:17:55,680 --> 00:18:01,800
<font color="#E5E5E5">that's our name lazy initialized that</font>

332
00:17:59,040 --> 00:18:04,740
means that if you if you try to

333
00:18:01,800 --> 00:18:07,020
overwrite a pointer with a target

334
00:18:04,740 --> 00:18:10,890
pointer<font color="#CCCCCC"> we choose a type that wasn't</font>

335
00:18:07,020 --> 00:18:15,480
already<font color="#E5E5E5"> used</font><font color="#CCCCCC"> by</font><font color="#E5E5E5"> your program then the</font>

336
00:18:10,890 --> 00:18:17,550
core foundation one time sorry the core

337
00:18:15,480 --> 00:18:19,290
foundation<font color="#CCCCCC"> runtime won't know this type</font>

338
00:18:17,550 --> 00:18:22,649
<font color="#E5E5E5">and you will crash your</font><font color="#CCCCCC"> program so</font>

339
00:18:19,290 --> 00:18:27,000
Windows<font color="#E5E5E5"> Server only use CF strings CF</font>

340
00:18:22,650 --> 00:18:30,000
number and<font color="#E5E5E5"> NS</font><font color="#CCCCCC"> item</font><font color="#E5E5E5"> in a in his</font>

341
00:18:27,000 --> 00:18:33,090
<font color="#CCCCCC">day-to-day</font><font color="#E5E5E5"> life we</font><font color="#CCCCCC"> can force it to use</font>

342
00:18:30,000 --> 00:18:35,850
<font color="#E5E5E5">NS date by forcing him</font><font color="#CCCCCC"> to deserialize</font>

343
00:18:33,090 --> 00:18:40,050
and<font color="#E5E5E5"> s date but for</font><font color="#CCCCCC"> example we won't</font><font color="#E5E5E5"> be</font>

344
00:18:35,850 --> 00:18:47,610
able to<font color="#E5E5E5"> use a NS index path in our or</font>

345
00:18:40,050 --> 00:18:52,399
exploit so to make<font color="#E5E5E5"> things a little bit</font>

346
00:18:47,610 --> 00:18:55,679
more more visual here is two different

347
00:18:52,400 --> 00:18:59,430
<font color="#CCCCCC">tagged tag type</font><font color="#E5E5E5"> the first one is a</font>

348
00:18:55,680 --> 00:19:02,180
number<font color="#CCCCCC"> so we see that right we see that</font>

349
00:18:59,430 --> 00:19:06,360
the lowest bit is set in both different

350
00:19:02,180 --> 00:19:11,790
<font color="#E5E5E5">tagged pointers</font><font color="#CCCCCC"> the next three bit is</font>

351
00:19:06,360 --> 00:19:16,800
here<font color="#E5E5E5"> it</font><font color="#CCCCCC"> three so this</font><font color="#E5E5E5"> is a number the</font>

352
00:19:11,790 --> 00:19:20,129
<font color="#E5E5E5">three see yes that signifies that the</font>

353
00:19:16,800 --> 00:19:21,990
object is a<font color="#CCCCCC"> Q word and the</font><font color="#E5E5E5"> rest of the</font>

354
00:19:20,130 --> 00:19:25,530
target pointer is used to store the

355
00:19:21,990 --> 00:19:28,080
<font color="#E5E5E5">value of the CF number and this is exact</font>

356
00:19:25,530 --> 00:19:32,670
same things for<font color="#CCCCCC"> a next tagged pointer</font>

357
00:19:28,080 --> 00:19:36,179
which is<font color="#CCCCCC"> era</font><font color="#E5E5E5"> string so now we know how</font>

358
00:19:32,670 --> 00:19:38,790
to put a<font color="#E5E5E5"> 400 before on dual pointer</font><font color="#CCCCCC"> all</font>

359
00:19:36,180 --> 00:19:43,040
we have<font color="#E5E5E5"> to do is to put in our self set</font>

360
00:19:38,790 --> 00:19:49,010
a number with the

361
00:19:43,040 --> 00:19:54,260
is value of<font color="#CCCCCC"> their number is 400 this way</font>

362
00:19:49,010 --> 00:19:58,700
we will<font color="#CCCCCC"> have</font><font color="#E5E5E5"> D</font><font color="#CCCCCC"> worn equal</font><font color="#E5E5E5"> to 400 just</font>

363
00:19:54,260 --> 00:20:06,020
before a new pointer<font color="#CCCCCC"> I hope this is</font>

364
00:19:58,700 --> 00:20:08,540
clear<font color="#E5E5E5"> the problem</font><font color="#CCCCCC"> is how do we make sure</font>

365
00:20:06,020 --> 00:20:10,610
<font color="#CCCCCC">that because</font><font color="#E5E5E5"> remember this is a stripper</font>

366
00:20:08,540 --> 00:20:15,230
how do<font color="#E5E5E5"> we make sure</font><font color="#CCCCCC"> that our values are</font>

367
00:20:10,610 --> 00:20:18,379
correctly<font color="#E5E5E5"> placed in memory the good</font>

368
00:20:15,230 --> 00:20:20,230
thing<font color="#E5E5E5"> is that</font><font color="#CCCCCC"> CF set is a generic</font>

369
00:20:18,380 --> 00:20:22,880
construction<font color="#E5E5E5"> so you can</font><font color="#CCCCCC"> pass</font><font color="#E5E5E5"> different</font>

370
00:20:20,230 --> 00:20:24,679
<font color="#E5E5E5">you can use it with</font><font color="#CCCCCC"> basically every</font><font color="#E5E5E5"> type</font>

371
00:20:22,880 --> 00:20:28,480
but because we are<font color="#E5E5E5"> working</font><font color="#CCCCCC"> with</font>

372
00:20:24,679 --> 00:20:33,770
<font color="#CCCCCC">Objective C</font><font color="#E5E5E5"> objects the CF set use</font>

373
00:20:28,480 --> 00:20:35,990
<font color="#E5E5E5">built-in callbacks so we know what the</font>

374
00:20:33,770 --> 00:20:38,929
<font color="#CCCCCC">edge functions that will</font><font color="#E5E5E5"> be used and it</font>

375
00:20:35,990 --> 00:20:43,580
is<font color="#CCCCCC"> deterministic which</font><font color="#E5E5E5"> means that we can</font>

376
00:20:38,929 --> 00:20:46,460
choose by by<font color="#E5E5E5"> brute</font><font color="#CCCCCC"> forcing the lowest</font>

377
00:20:43,580 --> 00:20:49,059
bit of our CF number we can control

378
00:20:46,460 --> 00:20:52,730
<font color="#E5E5E5">weight will be placed in our</font><font color="#CCCCCC"> ice table</font>

379
00:20:49,059 --> 00:20:57,350
so we can because of<font color="#E5E5E5"> that we can put</font>

380
00:20:52,730 --> 00:20:59,750
<font color="#CCCCCC">almost arbitrary</font><font color="#E5E5E5"> keyword in</font><font color="#CCCCCC"> say in a CF</font>

381
00:20:57,350 --> 00:21:03,159
dictionary<font color="#E5E5E5"> and CF set in there are</font>

382
00:20:59,750 --> 00:21:05,929
tables of course we won't we won't

383
00:21:03,160 --> 00:21:08,840
control the lowest significant bit<font color="#E5E5E5"> that</font>

384
00:21:05,929 --> 00:21:10,970
<font color="#CCCCCC">include the types of object</font><font color="#E5E5E5"> that not a</font>

385
00:21:08,840 --> 00:21:14,750
problem<font color="#CCCCCC"> is since we just</font><font color="#E5E5E5"> need to control</font>

386
00:21:10,970 --> 00:21:21,230
<font color="#E5E5E5">the 32 bits of the value</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> in our</font>

387
00:21:14,750 --> 00:21:26,330
attack so<font color="#CCCCCC"> era</font><font color="#E5E5E5"> I made a</font><font color="#CCCCCC"> little animation</font>

388
00:21:21,230 --> 00:21:29,510
<font color="#E5E5E5">so we see that if we try to put</font><font color="#CCCCCC"> a in or</font>

389
00:21:26,330 --> 00:21:32,570
CF set<font color="#CCCCCC"> a CF number equal to these values</font>

390
00:21:29,510 --> 00:21:34,700
<font color="#E5E5E5">that I won't read</font><font color="#CCCCCC"> it will</font><font color="#E5E5E5"> be placed here</font>

391
00:21:32,570 --> 00:21:37,610
<font color="#E5E5E5">but we don't want it to be placed</font><font color="#CCCCCC"> here</font>

392
00:21:34,700 --> 00:21:41,210
<font color="#E5E5E5">want it to be placed just</font><font color="#CCCCCC"> above so we</font>

393
00:21:37,610 --> 00:21:44,209
<font color="#CCCCCC">change</font><font color="#E5E5E5"> the lowest if you can</font><font color="#CCCCCC"> bit of the</font>

394
00:21:41,210 --> 00:21:48,200
CF number<font color="#E5E5E5"> weari a we see what will</font>

395
00:21:44,210 --> 00:21:51,230
be<font color="#CCCCCC"> placed in</font><font color="#E5E5E5"> or in our our table and we</font>

396
00:21:48,200 --> 00:21:53,230
change the value<font color="#CCCCCC"> of the CF number until</font>

397
00:21:51,230 --> 00:21:58,630
<font color="#CCCCCC">it is placed where we want</font>

398
00:21:53,230 --> 00:22:01,630
just before<font color="#CCCCCC"> our new pointer so the next</font>

399
00:21:58,630 --> 00:22:07,090
<font color="#CCCCCC">things that are blocking us is what can</font>

400
00:22:01,630 --> 00:22:09,429
<font color="#E5E5E5">we do is the value after on your pointer</font>

401
00:22:07,090 --> 00:22:12,309
because it will be overwritten with<font color="#E5E5E5"> no</font>

402
00:22:09,429 --> 00:22:16,029
no value<font color="#CCCCCC"> Massa backport name</font><font color="#E5E5E5"> so is it</font>

403
00:22:12,309 --> 00:22:19,990
safe to erase this value here with a<font color="#CCCCCC"> Mac</font>

404
00:22:16,029 --> 00:22:21,309
<font color="#E5E5E5">porn name so fortunately for us the</font>

405
00:22:19,990 --> 00:22:26,649
answer is yes

406
00:22:21,309 --> 00:22:31,330
why because<font color="#E5E5E5"> Mac port names are always</font>

407
00:22:26,649 --> 00:22:33,879
after two least significant bits that

408
00:22:31,330 --> 00:22:40,899
are set<font color="#E5E5E5"> which means that a Mac port name</font>

409
00:22:33,880 --> 00:22:44,980
<font color="#E5E5E5">can finish with a 3</font><font color="#CCCCCC"> a 7 a B</font><font color="#E5E5E5"> or F 3 B and</font>

410
00:22:40,899 --> 00:22:48,428
F are not valid target tagged<font color="#E5E5E5"> type so as</font>

411
00:22:44,980 --> 00:22:51,669
I<font color="#CCCCCC"> just said to you I just said to use</font>

412
00:22:48,429 --> 00:22:54,419
that using<font color="#E5E5E5"> invalid the tag types might</font>

413
00:22:51,669 --> 00:22:58,870
crash your program<font color="#E5E5E5"> fortunately</font><font color="#CCCCCC"> for us</font>

414
00:22:54,419 --> 00:23:01,600
<font color="#E5E5E5">when we will destroy off self a set to</font>

415
00:22:58,870 --> 00:23:04,629
trigger code execution<font color="#E5E5E5"> the function that</font>

416
00:23:01,600 --> 00:23:07,149
<font color="#E5E5E5">will</font><font color="#CCCCCC"> be called</font><font color="#E5E5E5"> is</font><font color="#CCCCCC"> C F release and C F</font>

417
00:23:04,630 --> 00:23:09,220
release<font color="#CCCCCC"> considers that</font><font color="#E5E5E5"> if you are trying</font>

418
00:23:07,149 --> 00:23:10,479
to<font color="#E5E5E5"> release a</font><font color="#CCCCCC"> typed pointer</font><font color="#E5E5E5"> there is</font>

419
00:23:09,220 --> 00:23:14,350
nothing to do because<font color="#E5E5E5"> there is no</font>

420
00:23:10,480 --> 00:23:17,590
<font color="#E5E5E5">location as sated with that with tagged</font>

421
00:23:14,350 --> 00:23:19,658
pointer<font color="#E5E5E5"> so we'll just do</font><font color="#CCCCCC"> nothing if the</font>

422
00:23:17,590 --> 00:23:21,220
pointer is tagged it doesn't check<font color="#E5E5E5"> here</font>

423
00:23:19,659 --> 00:23:26,039
it doesn't<font color="#CCCCCC"> even check the</font><font color="#E5E5E5"> type of the</font>

424
00:23:21,220 --> 00:23:30,880
tag<font color="#CCCCCC"> to pointer so it's always safe to</font>

425
00:23:26,039 --> 00:23:35,320
overwrite the the next slot<font color="#E5E5E5"> with a Mac</font>

426
00:23:30,880 --> 00:23:41,350
<font color="#CCCCCC">port name even if you're</font><font color="#E5E5E5"> the type is</font>

427
00:23:35,320 --> 00:23:45,658
invalid<font color="#CCCCCC"> so</font><font color="#E5E5E5"> for the moment what we are</font>

428
00:23:41,350 --> 00:23:51,428
going<font color="#E5E5E5"> to do is to create a CF set wisdom</font>

429
00:23:45,659 --> 00:23:53,380
<font color="#E5E5E5">CF numbers starting</font><font color="#CCCCCC"> with</font><font color="#E5E5E5"> a 400 followed</font>

430
00:23:51,429 --> 00:23:57,120
<font color="#CCCCCC">by a null pointer and we repeat this</font>

431
00:23:53,380 --> 00:23:59,919
pattern<font color="#E5E5E5"> everywhere in our hash table</font>

432
00:23:57,120 --> 00:24:01,510
when we trigger<font color="#CCCCCC"> the vulnerability</font><font color="#E5E5E5"> one of</font>

433
00:23:59,919 --> 00:24:04,720
the null pointer will<font color="#CCCCCC"> be overwritten by</font>

434
00:24:01,510 --> 00:24:06,370
a hip pointer<font color="#CCCCCC"> and the</font><font color="#E5E5E5"> next the values</font>

435
00:24:04,720 --> 00:24:09,340
next to it will be<font color="#E5E5E5"> array</font>

436
00:24:06,370 --> 00:24:11,260
with will be overwritten<font color="#E5E5E5"> sorry with a</font>

437
00:24:09,340 --> 00:24:14,830
<font color="#E5E5E5">the Mac port name but</font><font color="#CCCCCC"> that won't</font><font color="#E5E5E5"> have</font>

438
00:24:11,260 --> 00:24:18,879
<font color="#E5E5E5">any any consequence in the drinks the</font>

439
00:24:14,830 --> 00:24:21,129
destruction of the CF set so on<font color="#CCCCCC"> maybe</font>

440
00:24:18,880 --> 00:24:24,909
you are<font color="#E5E5E5"> wondering what if the lowest bit</font>

441
00:24:21,130 --> 00:24:27,250
wasn't set<font color="#E5E5E5"> that wouldn't be a problem</font>

442
00:24:24,909 --> 00:24:31,210
neither because allocation size in the

443
00:24:27,250 --> 00:24:34,809
<font color="#E5E5E5">if that I as I</font><font color="#CCCCCC"> said are multiples of</font><font color="#E5E5E5"> of</font>

444
00:24:31,210 --> 00:24:38,140
16 bytes<font color="#E5E5E5"> and</font><font color="#CCCCCC"> our tables elements count</font>

445
00:24:34,809 --> 00:24:41,110
our prime prime numbers so<font color="#CCCCCC"> that means</font>

446
00:24:38,140 --> 00:24:43,539
that<font color="#E5E5E5"> there is always at least</font><font color="#CCCCCC"> 8 bytes at</font>

447
00:24:41,110 --> 00:24:46,959
the end of the<font color="#CCCCCC"> dialogue at the end of</font>

448
00:24:43,539 --> 00:24:49,179
the allocation which is not used by<font color="#E5E5E5"> the</font>

449
00:24:46,960 --> 00:24:53,470
by the hash<font color="#CCCCCC"> table but that was allocated</font>

450
00:24:49,179 --> 00:24:56,500
by<font color="#CCCCCC"> zero</font><font color="#E5E5E5"> cater so it's always safe to to</font>

451
00:24:53,470 --> 00:24:57,760
write<font color="#CCCCCC"> the</font><font color="#E5E5E5"> word just after the</font><font color="#CCCCCC"> end of the</font>

452
00:24:56,500 --> 00:25:03,580
of the<font color="#E5E5E5"> rush</font>

453
00:24:57,760 --> 00:25:05,860
table<font color="#E5E5E5"> so even if</font><font color="#CCCCCC"> Erin we had other other</font>

454
00:25:03,580 --> 00:25:09,699
things<font color="#CCCCCC"> and a mac pot</font><font color="#E5E5E5"> name</font>

455
00:25:05,860 --> 00:25:12,689
we just we would just have<font color="#CCCCCC"> to put</font><font color="#E5E5E5"> our</font>

456
00:25:09,700 --> 00:25:15,010
<font color="#CCCCCC">anchor at the end of the hash table and</font>

457
00:25:12,690 --> 00:25:18,429
<font color="#E5E5E5">mac port names that is overwritten</font>

458
00:25:15,010 --> 00:25:21,490
there won't<font color="#E5E5E5"> be part of the our table but</font>

459
00:25:18,429 --> 00:25:24,250
it would be part<font color="#E5E5E5"> of the allocated</font><font color="#CCCCCC"> memory</font>

460
00:25:21,490 --> 00:25:28,510
allocated so it's totally saved to

461
00:25:24,250 --> 00:25:31,120
overwrite this pointer here so the

462
00:25:28,510 --> 00:25:34,840
latest problems that we have to trigger

463
00:25:31,120 --> 00:25:39,158
<font color="#CCCCCC">a</font><font color="#E5E5E5"> vulnerability as I said we</font><font color="#CCCCCC"> can</font><font color="#E5E5E5"> only</font>

464
00:25:34,840 --> 00:25:42,399
specify a negative of negative index now

465
00:25:39,159 --> 00:25:45,520
the problem is that<font color="#E5E5E5"> the array which</font><font color="#CCCCCC"> is</font>

466
00:25:42,399 --> 00:25:53,439
used<font color="#E5E5E5"> and is a global and really early</font>

467
00:25:45,520 --> 00:25:56,470
allocated so there is no way to to

468
00:25:53,440 --> 00:26:00,520
control where the array that will<font color="#E5E5E5"> be</font>

469
00:25:56,470 --> 00:26:02,860
used during<font color="#CCCCCC"> very triggering</font><font color="#E5E5E5"> we have no</font>

470
00:26:00,520 --> 00:26:07,320
way<font color="#CCCCCC"> to control where it will be placed</font>

471
00:26:02,860 --> 00:26:11,500
<font color="#E5E5E5">in memory and as you know the rip grows</font>

472
00:26:07,320 --> 00:26:13,720
<font color="#E5E5E5">forward fortunately for us</font><font color="#CCCCCC"> the base</font><font color="#E5E5E5"> of</font>

473
00:26:11,500 --> 00:26:16,240
the EEP is just<font color="#E5E5E5"> before the stack so it</font>

474
00:26:13,720 --> 00:26:18,130
cannot<font color="#CCCCCC"> grouse for world indefinitely</font>

475
00:26:16,240 --> 00:26:20,030
<font color="#E5E5E5">because</font><font color="#CCCCCC"> he authorized it with</font><font color="#E5E5E5"> a</font>

476
00:26:18,130 --> 00:26:22,160
<font color="#E5E5E5">overwrite the stack</font>

477
00:26:20,030 --> 00:26:25,190
so if you read the internals of Lib

478
00:26:22,160 --> 00:26:29,810
<font color="#CCCCCC">Malik you will see that the</font><font color="#E5E5E5"> Apes first</font>

479
00:26:25,190 --> 00:26:33,920
grows forward during 256<font color="#CCCCCC"> megabytes and</font>

480
00:26:29,810 --> 00:26:38,600
then it will<font color="#CCCCCC"> growth</font><font color="#E5E5E5"> a backward by with</font>

481
00:26:33,920 --> 00:26:43,220
chunk of 256<font color="#CCCCCC"> megabytes so if we allocate</font>

482
00:26:38,600 --> 00:26:48,409
enough<font color="#E5E5E5"> CF set after a given time</font>

483
00:26:43,220 --> 00:26:52,370
they<font color="#E5E5E5"> will be placed before our array we</font>

484
00:26:48,410 --> 00:26:55,760
just have to to send<font color="#E5E5E5"> a lot of CF set to</font>

485
00:26:52,370 --> 00:26:58,550
a Windows<font color="#E5E5E5"> Server fortunately for us we</font>

486
00:26:55,760 --> 00:27:01,730
can do this in<font color="#E5E5E5"> just one operation by</font>

487
00:26:58,550 --> 00:27:04,250
assigning<font color="#E5E5E5"> a very big CF array of CF set</font>

488
00:27:01,730 --> 00:27:06,320
as the value of<font color="#CCCCCC"> just one</font><font color="#E5E5E5"> property</font><font color="#CCCCCC"> so</font>

489
00:27:04,250 --> 00:27:09,680
there will be just<font color="#CCCCCC"> one</font><font color="#E5E5E5"> message sent to</font>

490
00:27:06,320 --> 00:27:13,310
the<font color="#E5E5E5"> Windows Server to create this this</font>

491
00:27:09,680 --> 00:27:16,370
bigger location<font color="#CCCCCC"> so</font><font color="#E5E5E5"> make things</font><font color="#CCCCCC"> clearer</font>

492
00:27:13,310 --> 00:27:20,870
<font color="#CCCCCC">here</font><font color="#E5E5E5"> we have got our hip underneath</font>

493
00:27:16,370 --> 00:27:25,820
we've got<font color="#CCCCCC"> the stack here there is a 256</font>

494
00:27:20,870 --> 00:27:28,580
megabyte of of<font color="#CCCCCC"> EEB that are reserved</font><font color="#E5E5E5"> so</font>

495
00:27:25,820 --> 00:27:32,480
if we send CF set a large array of CF

496
00:27:28,580 --> 00:27:36,770
<font color="#E5E5E5">sets to two</font><font color="#CCCCCC"> windows over there will be</font>

497
00:27:32,480 --> 00:27:39,260
first allocated at after<font color="#CCCCCC"> the</font><font color="#E5E5E5"> array so we</font>

498
00:27:36,770 --> 00:27:43,190
<font color="#E5E5E5">cannot access them with negative index</font>

499
00:27:39,260 --> 00:27:46,879
left after a while we see<font color="#E5E5E5"> that</font><font color="#CCCCCC"> new</font>

500
00:27:43,190 --> 00:27:49,310
<font color="#E5E5E5">location</font><font color="#CCCCCC"> is made before so</font><font color="#E5E5E5"> now we can we</font>

501
00:27:46,880 --> 00:27:54,650
can<font color="#E5E5E5"> we</font><font color="#CCCCCC"> can eat them with</font><font color="#E5E5E5"> a negative</font>

502
00:27:49,310 --> 00:28:00,950
<font color="#CCCCCC">index</font><font color="#E5E5E5"> and and overwrite one of the</font>

503
00:27:54,650 --> 00:28:04,970
pointer<font color="#CCCCCC"> of</font><font color="#E5E5E5"> or I stables so</font><font color="#CCCCCC"> now we have a</font>

504
00:28:00,950 --> 00:28:07,850
null pointer<font color="#E5E5E5"> that we can reuse now what</font>

505
00:28:04,970 --> 00:28:14,660
we want to<font color="#E5E5E5"> do is to free the associated</font>

506
00:28:07,850 --> 00:28:16,669
object<font color="#CCCCCC"> - there is no much time left</font>

507
00:28:14,660 --> 00:28:20,660
we need to<font color="#CCCCCC"> free the</font><font color="#E5E5E5"> sated object to</font>

508
00:28:16,670 --> 00:28:22,670
replace it<font color="#CCCCCC"> with controlled data so there</font>

509
00:28:20,660 --> 00:28:25,100
is<font color="#E5E5E5"> nothing really interesting there is</font>

510
00:28:22,670 --> 00:28:27,590
<font color="#E5E5E5">just reversing the</font><font color="#CCCCCC"> Windows Server</font><font color="#E5E5E5"> to</font>

511
00:28:25,100 --> 00:28:31,070
find out what the allocated<font color="#E5E5E5"> object is</font>

512
00:28:27,590 --> 00:28:34,250
it's actually<font color="#CCCCCC"> an application and</font>

513
00:28:31,070 --> 00:28:38,480
you can create as many applications<font color="#CCCCCC"> as</font>

514
00:28:34,250 --> 00:28:43,370
<font color="#CCCCCC">you want from your from any clients or</font>

515
00:28:38,480 --> 00:28:45,500
from any client the object can be

516
00:28:43,370 --> 00:28:49,760
freedom<font color="#E5E5E5"> without closing</font><font color="#CCCCCC"> the connection</font>

517
00:28:45,500 --> 00:28:52,400
it's not<font color="#E5E5E5"> that he but</font><font color="#CCCCCC"> you can do</font><font color="#E5E5E5"> it so</font>

518
00:28:49,760 --> 00:28:54,560
the<font color="#E5E5E5"> idea is</font><font color="#CCCCCC"> just</font><font color="#E5E5E5"> after we triggered the</font>

519
00:28:52,400 --> 00:28:56,450
<font color="#CCCCCC">vulnerabilities to freesias say to the</font>

520
00:28:54,560 --> 00:29:00,260
application<font color="#CCCCCC"> and now we</font><font color="#E5E5E5"> just have to</font>

521
00:28:56,450 --> 00:29:08,000
reuse<font color="#CCCCCC"> the allocation</font><font color="#E5E5E5"> to get cutter to to</font>

522
00:29:00,260 --> 00:29:11,530
replace the object with control data so

523
00:29:08,000 --> 00:29:15,260
as I said we replaced a new pointer with

524
00:29:11,530 --> 00:29:17,090
with a with<font color="#CCCCCC"> an eight pointer</font><font color="#E5E5E5"> during</font><font color="#CCCCCC"> CF</font>

525
00:29:15,260 --> 00:29:20,090
<font color="#E5E5E5">set destruction this pointer</font><font color="#CCCCCC"> will be</font>

526
00:29:17,090 --> 00:29:21,199
considered as a pointer<font color="#CCCCCC"> on an</font>

527
00:29:20,090 --> 00:29:24,800
objective-c

528
00:29:21,200 --> 00:29:27,020
object so<font color="#E5E5E5"> I invite</font><font color="#CCCCCC"> you to read and the</font>

529
00:29:24,800 --> 00:29:29,780
<font color="#E5E5E5">NEEMO frac article to understand how to</font>

530
00:29:27,020 --> 00:29:31,160
exploit this kind of things<font color="#CCCCCC"> so main</font>

531
00:29:29,780 --> 00:29:34,250
<font color="#CCCCCC">thing is the main</font><font color="#E5E5E5"> things that you</font><font color="#CCCCCC"> need</font>

532
00:29:31,160 --> 00:29:36,890
<font color="#CCCCCC">to know is you</font><font color="#E5E5E5"> have to</font><font color="#CCCCCC"> override</font><font color="#E5E5E5"> the very</font>

533
00:29:34,250 --> 00:29:40,520
first pointer of<font color="#E5E5E5"> the allocation to</font>

534
00:29:36,890 --> 00:29:42,590
control the is a pointer and obviously

535
00:29:40,520 --> 00:29:44,600
you cannot do<font color="#CCCCCC"> that</font><font color="#E5E5E5"> by allocating</font>

536
00:29:42,590 --> 00:29:47,090
<font color="#E5E5E5">objective-c object because objective-c</font>

537
00:29:44,600 --> 00:29:49,820
object<font color="#E5E5E5"> already have this pointer set to</font>

538
00:29:47,090 --> 00:29:53,899
specify<font color="#E5E5E5"> their types so you need to find</font>

539
00:29:49,820 --> 00:29:56,000
a way<font color="#E5E5E5"> to allocate control data where</font><font color="#CCCCCC"> you</font>

540
00:29:53,900 --> 00:29:58,880
control the very first<font color="#CCCCCC"> keyword</font><font color="#E5E5E5"> of</font><font color="#CCCCCC"> the</font>

541
00:29:56,000 --> 00:30:01,730
<font color="#CCCCCC">allocation so the first thing that you</font>

542
00:29:58,880 --> 00:30:04,880
think<font color="#CCCCCC"> about is just to use array report</font>

543
00:30:01,730 --> 00:30:07,240
a<font color="#CCCCCC"> problem with array is that</font><font color="#E5E5E5"> they are</font>

544
00:30:04,880 --> 00:30:11,030
immutable<font color="#E5E5E5"> when you are using them</font><font color="#CCCCCC"> too</font>

545
00:30:07,240 --> 00:30:15,050
<font color="#E5E5E5">when you are just really</font><font color="#CCCCCC"> just realizing</font>

546
00:30:11,030 --> 00:30:17,629
them so if there are immutable<font color="#E5E5E5"> their</font>

547
00:30:15,050 --> 00:30:19,760
containers are<font color="#CCCCCC"> inline I located</font><font color="#E5E5E5"> this</font>

548
00:30:17,630 --> 00:30:22,580
means that you<font color="#E5E5E5"> never</font><font color="#CCCCCC"> control the</font>

549
00:30:19,760 --> 00:30:28,610
beginning of the allocation when you are

550
00:30:22,580 --> 00:30:31,429
locating CFRA lucky look yes<font color="#E5E5E5"> see I've</font>

551
00:30:28,610 --> 00:30:35,209
<font color="#E5E5E5">set our tables are not in line allocated</font>

552
00:30:31,430 --> 00:30:38,540
so we can again<font color="#CCCCCC"> use CF set and force</font><font color="#E5E5E5"> ash</font>

553
00:30:35,210 --> 00:30:40,820
table where we will control the<font color="#CCCCCC"> first D</font>

554
00:30:38,540 --> 00:30:43,340
words the words the first pointer<font color="#CCCCCC"> we</font>

555
00:30:40,820 --> 00:30:46,908
<font color="#CCCCCC">were the</font><font color="#E5E5E5"> first value of</font>

556
00:30:43,340 --> 00:30:51,199
of the of the allocation so we just

557
00:30:46,909 --> 00:30:53,269
create new<font color="#CCCCCC"> CF set and we will place</font><font color="#E5E5E5"> CF</font>

558
00:30:51,200 --> 00:30:56,840
integrals at the beginning of it to a

559
00:30:53,269 --> 00:31:01,090
<font color="#CCCCCC">controllers first the first</font><font color="#E5E5E5"> pointer of</font>

560
00:30:56,840 --> 00:31:05,860
the of their location sorry<font color="#CCCCCC"> our I made</font>

561
00:31:01,090 --> 00:31:11,600
another drawing<font color="#E5E5E5"> so</font><font color="#CCCCCC"> you can understand</font>

562
00:31:05,860 --> 00:31:14,029
<font color="#E5E5E5">you know we will build a CF set and the</font>

563
00:31:11,600 --> 00:31:16,939
first<font color="#CCCCCC"> value of our</font><font color="#E5E5E5"> ash table will</font><font color="#CCCCCC"> be a</font>

564
00:31:14,029 --> 00:31:22,100
CF number and will be<font color="#E5E5E5"> considered as an</font>

565
00:31:16,940 --> 00:31:26,419
<font color="#CCCCCC">is a pointer when the or our overwritten</font>

566
00:31:22,100 --> 00:31:28,998
<font color="#CCCCCC">a pointer will be</font><font color="#E5E5E5"> used</font><font color="#CCCCCC"> so now</font><font color="#E5E5E5"> all we</font>

567
00:31:26,419 --> 00:31:31,360
have to do is to<font color="#CCCCCC"> message</font><font color="#E5E5E5"> the deep to</font>

568
00:31:28,999 --> 00:31:34,820
create holes for the application<font color="#CCCCCC"> object</font>

569
00:31:31,360 --> 00:31:36,799
create a little<font color="#E5E5E5"> bit tinier old for all</font>

570
00:31:34,820 --> 00:31:41,899
<font color="#E5E5E5">the other objects they</font><font color="#CCCCCC"> can't they don't</font>

571
00:31:36,799 --> 00:31:44,418
use or old reserved for application<font color="#E5E5E5"> we</font>

572
00:31:41,899 --> 00:31:47,748
create our application<font color="#CCCCCC"> with some luck it</font>

573
00:31:44,419 --> 00:31:50,419
will be locating in one of our old which

574
00:31:47,749 --> 00:31:52,580
rigors of<font color="#CCCCCC"> vulnerability</font><font color="#E5E5E5"> we freeze the</font>

575
00:31:50,419 --> 00:31:55,039
application object<font color="#CCCCCC"> and then reuse the</font>

576
00:31:52,580 --> 00:31:59,330
allocation with or forged<font color="#E5E5E5"> CF set edge</font>

577
00:31:55,039 --> 00:32:03,490
tables the problem is<font color="#E5E5E5"> corefoundation</font>

578
00:31:59,330 --> 00:32:06,850
used the default<font color="#CCCCCC"> EEP</font><font color="#E5E5E5"> as all C and C++</font>

579
00:32:03,490 --> 00:32:10,070
allocation made with malloc and you and

580
00:32:06,850 --> 00:32:13,189
the default<font color="#E5E5E5"> EEP use separate</font><font color="#CCCCCC"> Magazine</font>

581
00:32:10,070 --> 00:32:15,740
<font color="#CCCCCC">perk or C's to optimize the processor on</font>

582
00:32:13,190 --> 00:32:18,490
<font color="#E5E5E5">cache axis and to reduce</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> risk of</font>

583
00:32:15,740 --> 00:32:21,669
concurrent access to global EEP

584
00:32:18,490 --> 00:32:25,309
<font color="#E5E5E5">structures so this problematic because</font>

585
00:32:21,669 --> 00:32:28,340
if<font color="#E5E5E5"> our application was allocated by a</font>

586
00:32:25,309 --> 00:32:31,460
core<font color="#E5E5E5"> we need to use the same core to</font>

587
00:32:28,340 --> 00:32:33,678
allocate our<font color="#E5E5E5"> CF set otherwise it will be</font>

588
00:32:31,460 --> 00:32:37,129
locating in a<font color="#E5E5E5"> completely different</font>

589
00:32:33,679 --> 00:32:40,070
region so you<font color="#E5E5E5"> can find more information</font>

590
00:32:37,129 --> 00:32:43,959
<font color="#CCCCCC">about the EEP</font><font color="#E5E5E5"> in</font><font color="#CCCCCC"> oppression in</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> new</font>

591
00:32:40,070 --> 00:32:46,789
presentation I<font color="#CCCCCC"> did in 2018 at</font><font color="#E5E5E5"> stack</font><font color="#CCCCCC"> I</font>

592
00:32:43,960 --> 00:32:50,500
won't go into a lot<font color="#CCCCCC"> of details in this</font>

593
00:32:46,789 --> 00:32:54,200
<font color="#E5E5E5">tool because I don't have much time</font><font color="#CCCCCC"> left</font>

594
00:32:50,500 --> 00:32:55,940
<font color="#CCCCCC">just remember that we need</font><font color="#E5E5E5"> to message</font>

595
00:32:54,200 --> 00:32:59,659
all the<font color="#E5E5E5"> magazine</font>

596
00:32:55,940 --> 00:33:03,529
to make sure<font color="#E5E5E5"> that we can reuse of read</font>

597
00:32:59,659 --> 00:33:06,049
application so my first idea<font color="#E5E5E5"> to message</font>

598
00:33:03,529 --> 00:33:07,489
<font color="#CCCCCC">leap was to use</font><font color="#E5E5E5"> she upset</font><font color="#CCCCCC"> I mean I mean</font>

599
00:33:06,049 --> 00:33:10,629
<font color="#CCCCCC">they</font><font color="#E5E5E5"> are really saves the day twice</font>

600
00:33:07,489 --> 00:33:14,569
<font color="#E5E5E5">maybe it can save the day after the</font>

601
00:33:10,629 --> 00:33:17,839
<font color="#E5E5E5">abyss can save a third day so let's just</font>

602
00:33:14,569 --> 00:33:24,649
<font color="#CCCCCC">Forge to relight CF</font><font color="#E5E5E5"> set with duplicate</font>

603
00:33:17,839 --> 00:33:27,708
<font color="#E5E5E5">keys</font><font color="#CCCCCC"> if we do</font><font color="#E5E5E5"> that the this realization</font>

604
00:33:24,649 --> 00:33:30,708
process<font color="#E5E5E5"> should free a duplicated object</font>

605
00:33:27,709 --> 00:33:33,559
when creating the CF set the problem<font color="#CCCCCC"> is</font>

606
00:33:30,709 --> 00:33:35,959
that there is a burger in in the

607
00:33:33,559 --> 00:33:39,129
deserialization process and<font color="#E5E5E5"> the never</font>

608
00:33:35,959 --> 00:33:42,619
free that duplicated object because<font color="#E5E5E5"> the</font>

609
00:33:39,129 --> 00:33:45,829
the<font color="#E5E5E5"> archons the considers that CF set</font>

610
00:33:42,619 --> 00:33:48,799
must<font color="#E5E5E5"> be correctly serialized so there is</font>

611
00:33:45,829 --> 00:33:50,899
no duplicated kids<font color="#CCCCCC"> so they don't keep</font>

612
00:33:48,799 --> 00:33:53,690
reference of the<font color="#CCCCCC"> the disabled the</font>

613
00:33:50,899 --> 00:33:57,529
reference counting when creating the CF

614
00:33:53,690 --> 00:34:00,469
set so you<font color="#CCCCCC"> can you you cannot</font><font color="#E5E5E5"> use CF set</font>

615
00:33:57,529 --> 00:34:03,139
to a message memory<font color="#CCCCCC"> data I drop a</font>

616
00:34:00,469 --> 00:34:05,659
fantastic<font color="#CCCCCC"> zero</font><font color="#E5E5E5"> day you can</font><font color="#CCCCCC"> crush Windows</font>

617
00:34:03,139 --> 00:34:08,719
<font color="#CCCCCC">Server but by making em creating a lot</font>

618
00:34:05,659 --> 00:34:14,089
of CF sets with duplicated keys and it

619
00:34:08,719 --> 00:34:16,250
will<font color="#E5E5E5"> never free as the</font><font color="#CCCCCC"> allocation so my</font>

620
00:34:14,089 --> 00:34:18,949
<font color="#CCCCCC">Simona you will just use properties</font><font color="#E5E5E5"> you</font>

621
00:34:16,250 --> 00:34:21,139
create a lot<font color="#E5E5E5"> of properties you delight</font>

622
00:34:18,949 --> 00:34:24,230
some properties<font color="#CCCCCC"> that we made that will</font>

623
00:34:21,139 --> 00:34:29,329
make<font color="#E5E5E5"> old this is not very</font><font color="#CCCCCC"> snug</font><font color="#E5E5E5"> but that</font>

624
00:34:24,230 --> 00:34:33,199
works quite<font color="#CCCCCC"> well so in the in the</font>

625
00:34:29,329 --> 00:34:36,500
process<font color="#E5E5E5"> I also create some</font><font color="#CCCCCC"> applications</font>

626
00:34:33,199 --> 00:34:38,388
<font color="#E5E5E5">because it seems to help</font><font color="#CCCCCC"> Windows</font><font color="#E5E5E5"> Server</font>

627
00:34:36,500 --> 00:34:40,219
to switch from a court<font color="#CCCCCC"> windows</font><font color="#E5E5E5"> over on</font>

628
00:34:38,389 --> 00:34:43,909
maybe because there is some a

629
00:34:40,219 --> 00:34:46,879
synchronous asynchronous operations<font color="#E5E5E5"> use</font>

630
00:34:43,909 --> 00:34:49,519
<font color="#E5E5E5">the during</font><font color="#CCCCCC"> application creation I don't</font>

631
00:34:46,879 --> 00:34:52,690
really know why<font color="#CCCCCC"> it works but actually it</font>

632
00:34:49,518 --> 00:34:56,199
works<font color="#E5E5E5"> maybe just asleep would be enough</font>

633
00:34:52,690 --> 00:34:59,930
my exploit words I didn't touch<font color="#E5E5E5"> anything</font>

634
00:34:56,199 --> 00:35:04,700
<font color="#E5E5E5">and to debug everything I just</font><font color="#CCCCCC"> used my</font>

635
00:34:59,930 --> 00:35:07,029
<font color="#CCCCCC">viewer</font><font color="#E5E5E5"> so maybe I can show you how it</font>

636
00:35:04,700 --> 00:35:07,029
works

637
00:35:07,110 --> 00:35:15,010
so basically is just<font color="#E5E5E5"> some PNG generated</font>

638
00:35:11,890 --> 00:35:19,450
from a snapshot of the<font color="#CCCCCC"> veep</font><font color="#E5E5E5"> that I</font>

639
00:35:15,010 --> 00:35:21,640
displays in<font color="#CCCCCC"> a with HTML and</font><font color="#E5E5E5"> G JavaScript</font>

640
00:35:19,450 --> 00:35:24,580
<font color="#E5E5E5">and here you can see that there</font><font color="#CCCCCC"> is a lot</font>

641
00:35:21,640 --> 00:35:29,410
of well maybe<font color="#E5E5E5"> you can't because it's too</font>

642
00:35:24,580 --> 00:35:32,920
small<font color="#E5E5E5"> if I click on the picture we see</font>

643
00:35:29,410 --> 00:35:41,200
that there<font color="#CCCCCC"> is a</font><font color="#E5E5E5"> freed block of</font><font color="#CCCCCC"> Zarek's 0</font>

644
00:35:32,920 --> 00:35:46,180
<font color="#E5E5E5">X 70 bytes and others that</font><font color="#CCCCCC"> are</font><font color="#E5E5E5"> 0 X 60</font>

645
00:35:41,200 --> 00:35:48,399
<font color="#CCCCCC">bytes so this is really</font><font color="#E5E5E5"> useful</font><font color="#CCCCCC"> when you</font>

646
00:35:46,180 --> 00:35:54,120
are trying<font color="#CCCCCC"> to message rape</font><font color="#E5E5E5"> who have a</font>

647
00:35:48,400 --> 00:35:54,120
tool to<font color="#CCCCCC"> visualize to visualize things</font>

648
00:35:56,760 --> 00:36:06,160
some with some luck we are<font color="#CCCCCC"> reused or a</font>

649
00:36:02,640 --> 00:36:08,529
3d object<font color="#CCCCCC"> so the next things to do is to</font>

650
00:36:06,160 --> 00:36:12,730
<font color="#CCCCCC">trigger</font><font color="#E5E5E5"> the use of overwritten pointer</font>

651
00:36:08,530 --> 00:36:15,550
to gain arbitrary code execution so

652
00:36:12,730 --> 00:36:18,220
<font color="#E5E5E5">getting cut</font><font color="#CCCCCC"> exactly is quite easy you</font>

653
00:36:15,550 --> 00:36:20,050
just<font color="#E5E5E5"> have to trigger to trigger</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> user</font>

654
00:36:18,220 --> 00:36:21,660
<font color="#E5E5E5">power of a written pointer all we have</font>

655
00:36:20,050 --> 00:36:24,970
to do is to delete<font color="#E5E5E5"> the property</font>

656
00:36:21,660 --> 00:36:28,180
associated with<font color="#E5E5E5"> a huge CF array of CF</font>

657
00:36:24,970 --> 00:36:33,069
set so every CF set will<font color="#CCCCCC"> be freedom and</font>

658
00:36:28,180 --> 00:36:35,230
when when when or overwritten CF set

659
00:36:33,070 --> 00:36:38,770
will be<font color="#E5E5E5"> released or overwritten pointer</font>

660
00:36:35,230 --> 00:36:43,240
will<font color="#CCCCCC"> be used</font><font color="#E5E5E5"> with with a call to</font><font color="#CCCCCC"> CF</font>

661
00:36:38,770 --> 00:36:46,720
<font color="#CCCCCC">reddy's but the question how do we</font><font color="#E5E5E5"> get</font>

662
00:36:43,240 --> 00:36:49,450
<font color="#CCCCCC">arbitrary code exact the answer is by</font>

663
00:36:46,720 --> 00:36:52,390
forging a fake fake<font color="#E5E5E5"> objective-c object</font>

664
00:36:49,450 --> 00:36:57,759
and the fake objective-c class the

665
00:36:52,390 --> 00:37:00,430
problem<font color="#CCCCCC"> is that this this there is a lot</font>

666
00:36:57,760 --> 00:37:03,820
of<font color="#CCCCCC"> jury references that</font><font color="#E5E5E5"> are involved</font>

667
00:37:00,430 --> 00:37:05,980
<font color="#E5E5E5">before getting our IP because you have</font>

668
00:37:03,820 --> 00:37:08,020
<font color="#E5E5E5">your object that</font><font color="#CCCCCC"> ug referenced we had</font>

669
00:37:05,980 --> 00:37:11,320
the eyes a pointer<font color="#E5E5E5"> that you dereference</font>

670
00:37:08,020 --> 00:37:13,060
<font color="#E5E5E5">to get the objective-c class object then</font>

671
00:37:11,320 --> 00:37:16,840
you've got a<font color="#CCCCCC"> cash pointer that</font><font color="#E5E5E5"> you</font><font color="#CCCCCC"> are</font>

672
00:37:13,060 --> 00:37:18,670
<font color="#E5E5E5">ready that</font><font color="#CCCCCC"> you that you do reference</font><font color="#E5E5E5"> to</font>

673
00:37:16,840 --> 00:37:19,660
get the function<font color="#CCCCCC"> pointer so there is a</font>

674
00:37:18,670 --> 00:37:22,180
lot<font color="#CCCCCC"> of different</font>

675
00:37:19,660 --> 00:37:25,720
the references<font color="#E5E5E5"> are involved so you are</font>

676
00:37:22,180 --> 00:37:29,440
you need<font color="#CCCCCC"> to bypass a</font><font color="#E5E5E5"> SLR to forge your</font>

677
00:37:25,720 --> 00:37:31,930
your fake object for code is<font color="#E5E5E5"> really easy</font>

678
00:37:29,440 --> 00:37:34,480
because the<font color="#E5E5E5"> system libs are loaded at</font>

679
00:37:31,930 --> 00:37:37,230
<font color="#E5E5E5">the same address</font><font color="#CCCCCC"> for all the process all</font>

680
00:37:34,480 --> 00:37:39,910
the processes thanks to the shared<font color="#E5E5E5"> cache</font>

681
00:37:37,230 --> 00:37:42,370
well even if that's<font color="#E5E5E5"> not really true</font>

682
00:37:39,910 --> 00:37:43,589
<font color="#CCCCCC">anymore on iOS</font><font color="#E5E5E5"> 12 but that's another</font>

683
00:37:42,370 --> 00:37:52,140
story

684
00:37:43,590 --> 00:37:55,930
the problem is for a data<font color="#CCCCCC"> area I</font><font color="#E5E5E5"> a SLR 3</font>

685
00:37:52,140 --> 00:37:58,990
<font color="#CCCCCC">maybe we could try to</font><font color="#E5E5E5"> leak reuse the</font>

686
00:37:55,930 --> 00:38:01,480
object address<font color="#E5E5E5"> like</font><font color="#CCCCCC"> a red 2 systems did</font>

687
00:37:58,990 --> 00:38:05,229
<font color="#E5E5E5">the program is</font><font color="#CCCCCC"> that the allocation is a</font>

688
00:38:01,480 --> 00:38:08,200
really small it's<font color="#E5E5E5"> only 70 bytes</font>

689
00:38:05,230 --> 00:38:11,650
<font color="#E5E5E5">so it's</font><font color="#CCCCCC"> an to fit everything in it I</font>

690
00:38:08,200 --> 00:38:18,520
<font color="#E5E5E5">mean the fake object the fake class and</font>

691
00:38:11,650 --> 00:38:21,940
the payload so what I thought was well

692
00:38:18,520 --> 00:38:25,300
<font color="#E5E5E5">Mac OS</font><font color="#CCCCCC"> and iOS</font><font color="#E5E5E5"> a SLR is known to be weak</font>

693
00:38:21,940 --> 00:38:27,940
<font color="#E5E5E5">I mean there was there is there was</font>

694
00:38:25,300 --> 00:38:30,240
several<font color="#E5E5E5"> exploit that just out code</font>

695
00:38:27,940 --> 00:38:33,180
<font color="#E5E5E5">addresses the main recent one being</font>

696
00:38:30,240 --> 00:38:36,279
<font color="#CCCCCC">sorry my bad exploit for kernel</font>

697
00:38:33,180 --> 00:38:40,000
vulnerability<font color="#CCCCCC"> we're just out cold</font>

698
00:38:36,280 --> 00:38:42,550
<font color="#E5E5E5">colonel addresses in exploit so I</font>

699
00:38:40,000 --> 00:38:46,570
thought it's<font color="#CCCCCC"> not that uncommon to out</font>

700
00:38:42,550 --> 00:38:52,540
code addresses into<font color="#E5E5E5"> systems</font><font color="#CCCCCC"> it seems so</font>

701
00:38:46,570 --> 00:38:56,920
I<font color="#CCCCCC"> try to study all the ASLR</font><font color="#E5E5E5"> works in Mac</font>

702
00:38:52,540 --> 00:39:02,050
<font color="#E5E5E5">OS so the first thing that I studied was</font>

703
00:38:56,920 --> 00:39:04,420
<font color="#CCCCCC">the allocation because I can already</font>

704
00:39:02,050 --> 00:39:09,100
message and allocate a<font color="#E5E5E5"> lot of</font>

705
00:39:04,420 --> 00:39:13,810
<font color="#E5E5E5">self-injury the problem is the</font><font color="#CCCCCC"> EPA and</font>

706
00:39:09,100 --> 00:39:17,770
the<font color="#CCCCCC"> Mac OS and on 64-bit</font><font color="#E5E5E5"> platform is</font>

707
00:39:13,810 --> 00:39:22,900
really randomized<font color="#CCCCCC"> I mean you you would</font>

708
00:39:17,770 --> 00:39:26,200
have<font color="#E5E5E5"> to to spray 512 gigabytes of memory</font>

709
00:39:22,900 --> 00:39:30,370
<font color="#E5E5E5">before being able to</font><font color="#CCCCCC"> add coded address</font>

710
00:39:26,200 --> 00:39:31,720
<font color="#E5E5E5">so obviously this is</font><font color="#CCCCCC"> undo able you could</font>

711
00:39:30,370 --> 00:39:34,359
do it

712
00:39:31,720 --> 00:39:35,020
<font color="#E5E5E5">search</font><font color="#CCCCCC"> two big platforms but that's not</font>

713
00:39:34,359 --> 00:39:40,540
the point

714
00:39:35,020 --> 00:39:49,270
so I<font color="#CCCCCC"> I looked at other other means to</font>

715
00:39:40,540 --> 00:39:53,680
<font color="#E5E5E5">allocate memory under xnu and I</font><font color="#CCCCCC"> looked</font>

716
00:39:49,270 --> 00:39:56,619
at other<font color="#E5E5E5"> a</font><font color="#CCCCCC"> cerrar mechanism</font><font color="#E5E5E5"> so the main</font>

717
00:39:53,680 --> 00:40:00,009
<font color="#CCCCCC">execute executable is randomized</font><font color="#E5E5E5"> with an</font>

718
00:39:56,619 --> 00:40:04,680
random slider<font color="#CCCCCC"> but the</font><font color="#E5E5E5"> random slide is</font>

719
00:40:00,010 --> 00:40:08,980
quite small it's<font color="#CCCCCC"> actually only 256</font>

720
00:40:04,680 --> 00:40:12,759
megabyte<font color="#E5E5E5"> at least on a 64-bit platform</font>

721
00:40:08,980 --> 00:40:15,460
and the same slide is<font color="#CCCCCC"> actually used for</font>

722
00:40:12,760 --> 00:40:18,040
<font color="#E5E5E5">the</font><font color="#CCCCCC"> status that</font><font color="#E5E5E5"> means that on Mac OS</font><font color="#CCCCCC"> and</font>

723
00:40:15,460 --> 00:40:23,500
iOS<font color="#CCCCCC"> if you have a stack click then you</font>

724
00:40:18,040 --> 00:40:26,940
get<font color="#E5E5E5"> main executable</font><font color="#CCCCCC"> leak directly for</font>

725
00:40:23,500 --> 00:40:30,160
free<font color="#E5E5E5"> and the inverse is of course true</font>

726
00:40:26,940 --> 00:40:34,359
<font color="#E5E5E5">so I invite</font><font color="#CCCCCC"> you to read the code of xnu</font>

727
00:40:30,160 --> 00:40:38,109
<font color="#CCCCCC">to to see that</font><font color="#E5E5E5"> and the dynamic loader is</font>

728
00:40:34,359 --> 00:40:39,940
loaded<font color="#E5E5E5"> just after the main executable if</font>

729
00:40:38,109 --> 00:40:44,529
it doesn't have<font color="#CCCCCC"> as address which is</font><font color="#E5E5E5"> the</font>

730
00:40:39,940 --> 00:40:49,839
case on Mac OS<font color="#CCCCCC"> and iOS and again 256</font>

731
00:40:44,530 --> 00:40:51,940
megabytes light is used so value<font color="#CCCCCC"> Korea</font>

732
00:40:49,839 --> 00:40:54,460
when you when you create<font color="#CCCCCC"> a process you</font>

733
00:40:51,940 --> 00:40:59,910
will<font color="#E5E5E5"> have this layout so the original</font>

734
00:40:54,460 --> 00:40:59,910
base address is<font color="#CCCCCC"> is at the top</font><font color="#E5E5E5"> of the</font>

735
00:41:00,210 --> 00:41:11,079
<font color="#CCCCCC">thing then you've</font><font color="#E5E5E5"> got a random slide of</font>

736
00:41:03,940 --> 00:41:14,440
less<font color="#CCCCCC"> than 255</font><font color="#E5E5E5"> 66-56</font><font color="#CCCCCC"> or a megabyte your</font>

737
00:41:11,079 --> 00:41:16,690
executable is loaded and then another

738
00:41:14,440 --> 00:41:21,819
slide is added<font color="#CCCCCC"> to the end of the edge</font>

739
00:41:16,690 --> 00:41:27,130
table again less than 256<font color="#E5E5E5"> megabytes the</font>

740
00:41:21,819 --> 00:41:30,609
dynamic linker is loaded<font color="#E5E5E5"> and why am i</font>

741
00:41:27,130 --> 00:41:34,060
why am I telling<font color="#E5E5E5"> you</font><font color="#CCCCCC"> that this is</font>

742
00:41:30,609 --> 00:41:37,540
because when you<font color="#E5E5E5"> allocate pages without</font>

743
00:41:34,060 --> 00:41:41,279
specifying<font color="#CCCCCC"> bad address they will be</font>

744
00:41:37,540 --> 00:41:44,319
allocated just after the main executable

745
00:41:41,280 --> 00:41:45,570
<font color="#E5E5E5">unless specific undocumented flag is</font>

746
00:41:44,319 --> 00:41:48,630
used<font color="#E5E5E5"> during process</font>

747
00:41:45,570 --> 00:41:53,850
creation<font color="#E5E5E5"> this flag is only used</font><font color="#CCCCCC"> by a by</font>

748
00:41:48,630 --> 00:41:56,430
Apple for<font color="#E5E5E5"> WebKit</font><font color="#CCCCCC"> so that means</font><font color="#E5E5E5"> that if</font>

749
00:41:53,850 --> 00:42:00,029
if we<font color="#CCCCCC"> manage to</font><font color="#E5E5E5"> force the process to</font>

750
00:41:56,430 --> 00:42:03,960
allocate more than 512 megabytes of

751
00:42:00,030 --> 00:42:09,270
<font color="#E5E5E5">memory via Mac VM api's then we can</font>

752
00:42:03,960 --> 00:42:13,050
<font color="#E5E5E5">output the</font><font color="#CCCCCC"> address of the of the pages</font>

753
00:42:09,270 --> 00:42:17,460
<font color="#E5E5E5">so imagine</font><font color="#CCCCCC"> shaft</font><font color="#E5E5E5"> this is the state of</font>

754
00:42:13,050 --> 00:42:19,740
<font color="#E5E5E5">Windows</font><font color="#CCCCCC"> Server when we exploit it so we</font>

755
00:42:17,460 --> 00:42:22,590
have some pages<font color="#CCCCCC"> allocated just after a</font>

756
00:42:19,740 --> 00:42:26,370
Windows Server<font color="#CCCCCC"> and if you make enough</font>

757
00:42:22,590 --> 00:42:30,270
allocations<font color="#CCCCCC"> we see that at a given</font><font color="#E5E5E5"> point</font>

758
00:42:26,370 --> 00:42:33,960
<font color="#E5E5E5">we are and would put 100%</font><font color="#CCCCCC"> sure that we</font>

759
00:42:30,270 --> 00:42:40,080
have our<font color="#E5E5E5"> 50 or 41 values that will be at</font>

760
00:42:33,960 --> 00:42:43,170
given<font color="#E5E5E5"> address the question is now how</font>

761
00:42:40,080 --> 00:42:46,200
can<font color="#CCCCCC"> I force Windows</font><font color="#E5E5E5"> Server to allocate</font>

762
00:42:43,170 --> 00:42:46,950
pages the answer is actually quite

763
00:42:46,200 --> 00:42:49,710
<font color="#E5E5E5">simple</font>

764
00:42:46,950 --> 00:42:56,580
Windows Server is an old service so it

765
00:42:49,710 --> 00:42:59,220
is not using XP<font color="#CCCCCC"> crns X</font><font color="#E5E5E5"> PC mechanism like</font>

766
00:42:56,580 --> 00:43:02,850
the service Tyler talked about yesterday

767
00:42:59,220 --> 00:43:06,689
<font color="#CCCCCC">say it is using an older mechanism which</font>

768
00:43:02,850 --> 00:43:09,990
is<font color="#E5E5E5"> Megan and for me</font>

769
00:43:06,690 --> 00:43:14,640
<font color="#CCCCCC">MIG function that takes unbounded rays</font>

770
00:43:09,990 --> 00:43:20,370
<font color="#E5E5E5">as arguments to pass</font><font color="#CCCCCC"> this</font><font color="#E5E5E5"> values to the</font>

771
00:43:14,640 --> 00:43:24,240
distant<font color="#CCCCCC"> big media functions we</font><font color="#E5E5E5"> send out</font>

772
00:43:20,370 --> 00:43:26,900
of line descriptors<font color="#CCCCCC"> and</font><font color="#E5E5E5"> also out of line</font>

773
00:43:24,240 --> 00:43:31,229
descriptors<font color="#CCCCCC"> are sent they are just</font>

774
00:43:26,900 --> 00:43:36,080
copied by the by the kernel into the<font color="#E5E5E5"> the</font>

775
00:43:31,230 --> 00:43:39,480
distant process so because there is no

776
00:43:36,080 --> 00:43:42,840
no limit<font color="#E5E5E5"> of the size of the arguments</font>

777
00:43:39,480 --> 00:43:47,760
that the MiG function can take<font color="#E5E5E5"> you</font><font color="#CCCCCC"> can</font>

778
00:43:42,840 --> 00:43:51,990
just ask<font color="#CCCCCC"> X nu</font><font color="#E5E5E5"> to to copy a 4 gigabyte of</font>

779
00:43:47,760 --> 00:43:55,650
memory<font color="#E5E5E5"> in the distant process and that</font>

780
00:43:51,990 --> 00:43:58,790
does work<font color="#CCCCCC"> even if the until undocumented</font>

781
00:43:55,650 --> 00:44:02,359
flag is<font color="#CCCCCC"> used because allocation</font>

782
00:43:58,790 --> 00:44:09,279
the<font color="#E5E5E5"> allocation mechanism is different a</font>

783
00:44:02,359 --> 00:44:09,279
little bit<font color="#CCCCCC"> different from the</font><font color="#E5E5E5"> VM map API</font>

784
00:44:09,490 --> 00:44:14,899
<font color="#CCCCCC">this is also</font><font color="#E5E5E5"> very fast because the</font>

785
00:44:12,140 --> 00:44:18,970
memory<font color="#E5E5E5"> is actually not really copied</font>

786
00:44:14,900 --> 00:44:21,890
<font color="#CCCCCC">it's</font><font color="#E5E5E5"> only</font><font color="#CCCCCC"> copy-on-write so this</font><font color="#E5E5E5"> is</font>

787
00:44:18,970 --> 00:44:26,600
<font color="#CCCCCC">immediate you don't have to wait for the</font>

788
00:44:21,890 --> 00:44:29,750
<font color="#CCCCCC">copied</font><font color="#E5E5E5"> hua creo to send you a message so</font>

789
00:44:26,600 --> 00:44:32,359
the<font color="#E5E5E5"> strategy is just to reserve a 4</font>

790
00:44:29,750 --> 00:44:35,540
gigabyte<font color="#E5E5E5"> of virtual memory to allocate a</font>

791
00:44:32,359 --> 00:44:39,259
page we put our fake<font color="#E5E5E5"> objective-c class</font>

792
00:44:35,540 --> 00:44:41,830
and in<font color="#E5E5E5"> with our payload in the page and</font>

793
00:44:39,260 --> 00:44:44,950
we duplicate<font color="#CCCCCC"> the page we remap it</font><font color="#E5E5E5"> n</font>

794
00:44:41,830 --> 00:44:48,560
times to<font color="#E5E5E5"> create a big 4 gigabyte</font>

795
00:44:44,950 --> 00:44:52,160
contiguous buffer but which is only

796
00:44:48,560 --> 00:44:55,430
<font color="#E5E5E5">using</font><font color="#CCCCCC"> a 1:1 physical pages</font><font color="#E5E5E5"> so we don't</font>

797
00:44:52,160 --> 00:44:58,940
have<font color="#E5E5E5"> any problem of of using too much</font>

798
00:44:55,430 --> 00:45:03,500
<font color="#E5E5E5">memory then we call as a set connection</font>

799
00:44:58,940 --> 00:45:07,850
property to replace the big array of CF

800
00:45:03,500 --> 00:45:10,220
set with or<font color="#E5E5E5"> foggy byte buffer the buffer</font>

801
00:45:07,850 --> 00:45:13,190
will be copied in Windows<font color="#E5E5E5"> Server and we</font>

802
00:45:10,220 --> 00:45:17,000
are because we are<font color="#CCCCCC"> allocating</font><font color="#E5E5E5"> 4 gigabyte</font>

803
00:45:13,190 --> 00:45:20,390
in<font color="#E5E5E5"> Windows Server we can out code the</font>

804
00:45:17,000 --> 00:45:24,440
address of<font color="#E5E5E5"> our fake objective-c class in</font>

805
00:45:20,390 --> 00:45:27,618
or exploit then our fake class will be

806
00:45:24,440 --> 00:45:32,450
used when<font color="#E5E5E5"> the CF set will</font><font color="#CCCCCC"> be a destroyer</font>

807
00:45:27,619 --> 00:45:40,670
and<font color="#CCCCCC"> MiG will automatically free</font><font color="#E5E5E5"> or big</font>

808
00:45:32,450 --> 00:45:47,960
<font color="#CCCCCC">for gigabyte allocation so again</font><font color="#E5E5E5"> I made</font>

809
00:45:40,670 --> 00:45:50,840
some<font color="#CCCCCC"> Chiba so it's a little</font><font color="#E5E5E5"> bit more</font>

810
00:45:47,960 --> 00:45:53,720
clear so<font color="#CCCCCC"> we've got our exploit we will</font>

811
00:45:50,840 --> 00:45:56,150
serve<font color="#E5E5E5"> 4 gigabyte of memory we</font><font color="#CCCCCC"> create our</font>

812
00:45:53,720 --> 00:46:00,109
fake class and we put our payload<font color="#E5E5E5"> in a</font>

813
00:45:56,150 --> 00:46:03,890
page<font color="#E5E5E5"> we duplicate the page we send the</font>

814
00:46:00,109 --> 00:46:05,990
<font color="#CCCCCC">message to two windows server then we</font>

815
00:46:03,890 --> 00:46:07,509
can<font color="#CCCCCC"> output the</font><font color="#E5E5E5"> address of our fake class</font>

816
00:46:05,990 --> 00:46:12,669
here

817
00:46:07,510 --> 00:46:17,680
and we will<font color="#CCCCCC"> able to use this address</font>

818
00:46:12,670 --> 00:46:24,580
Nara<font color="#E5E5E5"> in our overwritten</font><font color="#CCCCCC"> in our</font><font color="#E5E5E5"> reused</font>

819
00:46:17,680 --> 00:46:27,970
<font color="#E5E5E5">object so now</font><font color="#CCCCCC"> all we have to do is to</font>

820
00:46:24,580 --> 00:46:31,840
<font color="#E5E5E5">enter</font><font color="#CCCCCC"> a continuation of execution so</font>

821
00:46:27,970 --> 00:46:34,060
she's not<font color="#CCCCCC"> really out because when our a</font>

822
00:46:31,840 --> 00:46:36,940
<font color="#CCCCCC">Objective C when</font><font color="#E5E5E5"> our fake</font><font color="#CCCCCC"> Objective C</font>

823
00:46:34,060 --> 00:46:41,500
object will be released<font color="#E5E5E5"> and our</font><font color="#CCCCCC"> D I will</font>

824
00:46:36,940 --> 00:46:45,670
<font color="#CCCCCC">point our on Objective C object and we</font>

825
00:46:41,500 --> 00:46:49,390
control our our IP so we could try to

826
00:46:45,670 --> 00:46:53,800
stack<font color="#CCCCCC"> peeve out and make some Rob that's</font>

827
00:46:49,390 --> 00:46:55,450
<font color="#E5E5E5">what</font><font color="#CCCCCC"> red</font><font color="#E5E5E5"> to systems</font><font color="#CCCCCC"> didn't but it's</font>

828
00:46:53,800 --> 00:46:57,610
quite complicated<font color="#E5E5E5"> to ensure a</font>

829
00:46:55,450 --> 00:47:00,460
continuation of execution after<font color="#E5E5E5"> that for</font>

830
00:46:57,610 --> 00:47:03,490
<font color="#E5E5E5">example red</font><font color="#CCCCCC"> two systems what they did is</font>

831
00:47:00,460 --> 00:47:07,770
to<font color="#E5E5E5"> allocate a fake stack and a jump at</font>

832
00:47:03,490 --> 00:47:12,899
the beginning of the window<font color="#E5E5E5"> of messaging</font>

833
00:47:07,770 --> 00:47:17,170
<font color="#CCCCCC">underling process</font><font color="#E5E5E5"> I found that it</font><font color="#CCCCCC"> was</font>

834
00:47:12,900 --> 00:47:20,740
the<font color="#E5E5E5"> most beautiful things to do so I</font>

835
00:47:17,170 --> 00:47:23,640
<font color="#E5E5E5">decided to just use a pure job</font><font color="#CCCCCC"> payload</font>

836
00:47:20,740 --> 00:47:26,979
them so I just<font color="#CCCCCC"> jump damn damn damn job</font>

837
00:47:23,640 --> 00:47:30,129
control the first value<font color="#CCCCCC"> the</font><font color="#E5E5E5"> control the</font>

838
00:47:26,980 --> 00:47:32,680
<font color="#E5E5E5">value of our di and jump on a system to</font>

839
00:47:30,130 --> 00:47:37,270
execute arbitrary shell commands<font color="#E5E5E5"> and</font>

840
00:47:32,680 --> 00:47:45,129
after that everything<font color="#E5E5E5"> will continue like</font>

841
00:47:37,270 --> 00:47:49,300
<font color="#E5E5E5">nothing</font><font color="#CCCCCC"> happened so -</font><font color="#E5E5E5"> I will now show</font>

842
00:47:45,130 --> 00:47:52,270
you what what<font color="#CCCCCC"> how the</font><font color="#E5E5E5"> exploitation works</font>

843
00:47:49,300 --> 00:47:56,020
<font color="#E5E5E5">so this is the</font><font color="#CCCCCC"> initial state of Windows</font>

844
00:47:52,270 --> 00:48:00,759
<font color="#CCCCCC">Server we first allocate are a big array</font>

845
00:47:56,020 --> 00:48:05,320
of CF set then<font color="#CCCCCC"> we miss a trip by</font>

846
00:48:00,760 --> 00:48:07,810
creating a lot<font color="#E5E5E5"> of properties</font><font color="#CCCCCC"> in the in</font>

847
00:48:05,320 --> 00:48:09,850
Windows Server<font color="#CCCCCC"> then we delete some</font>

848
00:48:07,810 --> 00:48:15,190
properties<font color="#CCCCCC"> to make some holes in the</font>

849
00:48:09,850 --> 00:48:17,170
open then<font color="#E5E5E5"> we create our application with</font>

850
00:48:15,190 --> 00:48:19,180
some changes which will<font color="#E5E5E5"> be located</font><font color="#CCCCCC"> in</font>

851
00:48:17,170 --> 00:48:22,600
<font color="#CCCCCC">one of our old</font>

852
00:48:19,180 --> 00:48:25,299
then<font color="#CCCCCC"> we trigger</font><font color="#E5E5E5"> the vulnerability this</font>

853
00:48:22,600 --> 00:48:28,390
will<font color="#E5E5E5"> replace</font><font color="#CCCCCC"> one of</font><font color="#E5E5E5"> our new pointer in</font>

854
00:48:25,300 --> 00:48:32,460
our CF set with a pointer<font color="#E5E5E5"> on our</font>

855
00:48:28,390 --> 00:48:35,230
application<font color="#E5E5E5"> we</font><font color="#CCCCCC"> delete the application</font>

856
00:48:32,460 --> 00:48:38,620
<font color="#E5E5E5">then</font><font color="#CCCCCC"> we try to reuse the memory by</font>

857
00:48:35,230 --> 00:48:43,330
allocating a lot of value creating a lot

858
00:48:38,620 --> 00:48:49,210
<font color="#CCCCCC">of CF set again so you see that the</font><font color="#E5E5E5"> the</font>

859
00:48:43,330 --> 00:48:52,049
pink rectangles<font color="#CCCCCC"> don't don't use the</font>

860
00:48:49,210 --> 00:48:57,130
<font color="#E5E5E5">biggest old this is because of the of</font>

861
00:48:52,050 --> 00:48:59,110
<font color="#E5E5E5">our memory allocator</font><font color="#CCCCCC"> walks it will to</font>

862
00:48:57,130 --> 00:49:04,120
make sure that the EEP is not too

863
00:48:59,110 --> 00:49:07,530
fragmented<font color="#E5E5E5"> it will first</font><font color="#CCCCCC"> use the 60</font>

864
00:49:04,120 --> 00:49:11,560
<font color="#CCCCCC">bytes</font><font color="#E5E5E5"> old before the</font><font color="#CCCCCC"> seventh byte</font><font color="#E5E5E5"> all</font>

865
00:49:07,530 --> 00:49:14,620
that ensures that<font color="#E5E5E5"> our memory allocation</font>

866
00:49:11,560 --> 00:49:18,720
will not be reused with CF set<font color="#CCCCCC"> errors</font>

867
00:49:14,620 --> 00:49:23,799
<font color="#E5E5E5">but with ash tables as we want it to be</font>

868
00:49:18,720 --> 00:49:26,459
then we send we call the set connection

869
00:49:23,800 --> 00:49:31,480
property again with our<font color="#CCCCCC"> folk about</font>

870
00:49:26,460 --> 00:49:37,030
<font color="#CCCCCC">buffer that</font><font color="#E5E5E5"> will put one of our page at</font>

871
00:49:31,480 --> 00:49:40,180
the out coded address in the in the fake

872
00:49:37,030 --> 00:49:43,000
class we can use pointers that<font color="#E5E5E5"> are in</font>

873
00:49:40,180 --> 00:49:47,080
the<font color="#CCCCCC"> Scheldt cache because they are the</font>

874
00:49:43,000 --> 00:49:51,850
same in<font color="#E5E5E5"> both victim address space and</font>

875
00:49:47,080 --> 00:49:54,310
the attacker address space then all the

876
00:49:51,850 --> 00:49:56,740
CF set will<font color="#CCCCCC"> be will be released</font><font color="#E5E5E5"> because</font>

877
00:49:54,310 --> 00:50:00,009
we are redefining the properties of the

878
00:49:56,740 --> 00:50:02,290
old property<font color="#CCCCCC"> is freedom this will use</font>

879
00:50:00,010 --> 00:50:07,840
this will<font color="#E5E5E5"> trigger the use of our</font>

880
00:50:02,290 --> 00:50:11,770
overwritten pointer that will execute

881
00:50:07,840 --> 00:50:16,090
arbitrary command and at<font color="#E5E5E5"> the end of the</font>

882
00:50:11,770 --> 00:50:19,180
property<font color="#CCCCCC"> or redefinition the big</font><font color="#E5E5E5"> four</font>

883
00:50:16,090 --> 00:50:21,760
gigabyte array will be<font color="#E5E5E5"> freed all we have</font>

884
00:50:19,180 --> 00:50:23,740
<font color="#E5E5E5">to do next is to clean a little</font><font color="#CCCCCC"> bit too</font>

885
00:50:21,760 --> 00:50:28,270
<font color="#CCCCCC">deep</font><font color="#E5E5E5"> by freeing the rest of the</font>

886
00:50:23,740 --> 00:50:31,779
properties and we are back to<font color="#E5E5E5"> the</font>

887
00:50:28,270 --> 00:50:36,530
<font color="#CCCCCC">initial state of the</font><font color="#E5E5E5"> of the process</font>

888
00:50:31,780 --> 00:50:42,619
so I said<font color="#E5E5E5"> that the exploit is stable it</font>

889
00:50:36,530 --> 00:51:03,490
<font color="#CCCCCC">is better</font><font color="#E5E5E5"> you</font><font color="#CCCCCC"> know what</font><font color="#E5E5E5"> it is</font><font color="#CCCCCC"> so let's</font>

890
00:50:42,619 --> 00:51:03,490
<font color="#E5E5E5">pray with and raccoons up and here we go</font>

891
00:51:08,289 --> 00:51:22,939
and it is so as we can<font color="#CCCCCC"> see him the</font>

892
00:51:18,229 --> 00:51:25,158
exploit take<font color="#CCCCCC"> nine seconds to spoon</font><font color="#E5E5E5"> to</font>

893
00:51:22,939 --> 00:51:31,269
execute arbitrary commands<font color="#E5E5E5"> we could gain</font>

894
00:51:25,159 --> 00:51:34,219
some signals by by over by out cuttings

895
00:51:31,269 --> 00:51:36,258
<font color="#E5E5E5">serialized CF set which takes a lot of</font>

896
00:51:34,219 --> 00:51:40,159
time to serialize<font color="#E5E5E5"> but because everything</font>

897
00:51:36,259 --> 00:51:43,809
<font color="#CCCCCC">is out coded we could just put</font><font color="#E5E5E5"> it in in</font>

898
00:51:40,159 --> 00:51:46,009
a you<font color="#E5E5E5"> know out</font><font color="#CCCCCC"> buffer</font><font color="#E5E5E5"> that we decompress</font>

899
00:51:43,809 --> 00:51:49,189
<font color="#CCCCCC">but that would make the code a little</font>

900
00:51:46,009 --> 00:51:51,799
<font color="#E5E5E5">less reliable</font><font color="#CCCCCC"> soft</font><font color="#E5E5E5"> because</font><font color="#CCCCCC"> I'm still</font>

901
00:51:49,189 --> 00:51:56,509
under<font color="#E5E5E5"> ten seconds</font><font color="#CCCCCC"> I decided to keep it</font>

902
00:51:51,799 --> 00:52:00,038
like that<font color="#E5E5E5"> so what's great with this</font>

903
00:51:56,509 --> 00:52:03,109
exploit is normally you can use it<font color="#E5E5E5"> twice</font>

904
00:52:00,039 --> 00:52:06,259
<font color="#E5E5E5">without crashing so let's see if it</font>

905
00:52:03,109 --> 00:52:08,869
works it will take even<font color="#E5E5E5"> less time</font>

906
00:52:06,259 --> 00:52:10,929
<font color="#E5E5E5">because it works it takes</font><font color="#CCCCCC"> likes this</font>

907
00:52:08,869 --> 00:52:17,059
time because you're the<font color="#E5E5E5"> if don't have</font><font color="#CCCCCC"> to</font>

908
00:52:10,929 --> 00:52:20,539
to<font color="#CCCCCC"> regrow</font><font color="#E5E5E5"> so here we have trigger yes</font>

909
00:52:17,059 --> 00:52:32,899
unless<font color="#E5E5E5"> you know one in eight seconds</font>

910
00:52:20,539 --> 00:52:35,659
<font color="#CCCCCC">only so it worked great</font><font color="#E5E5E5"> so the change is</font>

911
00:52:32,899 --> 00:52:37,779
<font color="#E5E5E5">complete</font><font color="#CCCCCC"> and the exploit is</font><font color="#E5E5E5"> really</font>

912
00:52:35,659 --> 00:52:44,779
stable<font color="#CCCCCC"> like for real</font>

913
00:52:37,779 --> 00:52:47,709
only<font color="#CCCCCC"> the CV only one</font><font color="#E5E5E5"> CV was used but it</font>

914
00:52:44,779 --> 00:52:50,029
took<font color="#E5E5E5"> quite a long</font><font color="#CCCCCC"> time to get this</font>

915
00:52:47,709 --> 00:52:53,448
exploit code working<font color="#E5E5E5"> because</font><font color="#CCCCCC"> I had</font>

916
00:52:50,029 --> 00:52:56,029
reversed quite a lot of<font color="#E5E5E5"> different things</font>

917
00:52:53,449 --> 00:52:59,119
<font color="#E5E5E5">so it took eighteen days to cut just</font>

918
00:52:56,029 --> 00:53:02,479
<font color="#E5E5E5">like nine hundred lines of code</font><font color="#CCCCCC"> which</font>

919
00:52:59,119 --> 00:53:05,899
<font color="#E5E5E5">was a lot of fun the exploit source code</font>

920
00:53:02,479 --> 00:53:08,479
is<font color="#E5E5E5"> available which we cheated like two</font>

921
00:53:05,899 --> 00:53:11,659
<font color="#E5E5E5">or</font><font color="#CCCCCC"> three</font><font color="#E5E5E5"> days</font><font color="#CCCCCC"> ago</font><font color="#E5E5E5"> so you're welcome to</font>

922
00:53:08,479 --> 00:53:14,270
<font color="#E5E5E5">just read it and re-eat</font><font color="#CCCCCC"> and do whatever</font>

923
00:53:11,659 --> 00:53:17,940
you want with it

924
00:53:14,270 --> 00:53:20,940
so I would like<font color="#E5E5E5"> to thanks</font><font color="#CCCCCC"> red to systems</font>

925
00:53:17,940 --> 00:53:23,309
<font color="#E5E5E5">for the challenge because well I'm the</font>

926
00:53:20,940 --> 00:53:25,859
binary ninja commercial license that I

927
00:53:23,309 --> 00:53:28,380
wanna I don't<font color="#E5E5E5"> know if I will do a lot</font><font color="#CCCCCC"> of</font>

928
00:53:25,859 --> 00:53:31,170
things with<font color="#CCCCCC"> it but</font><font color="#E5E5E5"> that's always</font><font color="#CCCCCC"> great</font>

929
00:53:28,380 --> 00:53:32,910
to other to<font color="#E5E5E5"> have it thanks</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> us</font><font color="#CCCCCC"> in Act</font>

930
00:53:31,170 --> 00:53:33,869
<font color="#CCCCCC">II</font><font color="#E5E5E5"> for the times and the review and the</font>

931
00:53:32,910 --> 00:53:36,899
<font color="#E5E5E5">awesome team</font>

932
00:53:33,869 --> 00:53:39,540
thanks to<font color="#E5E5E5"> offensive</font><font color="#CCCCCC"> con for the amazing</font>

933
00:53:36,900 --> 00:53:44,099
event<font color="#E5E5E5"> and</font><font color="#CCCCCC"> I don't know if I will survive</font>

934
00:53:39,540 --> 00:53:45,720
<font color="#E5E5E5">to tonight party but thanks to my wife</font>

935
00:53:44,099 --> 00:53:48,059
for letting me go<font color="#E5E5E5"> to Berlin on</font>

936
00:53:45,720 --> 00:53:50,390
Valentine's<font color="#CCCCCC"> Day</font><font color="#E5E5E5"> and thank you for</font>

937
00:53:48,059 --> 00:53:50,390
attention

938
00:53:50,930 --> 00:54:08,480
[Applause]

939
00:53:57,400 --> 00:54:10,340
do you have any question<font color="#E5E5E5"> I'm Surya</font>

940
00:54:08,480 --> 00:54:16,040
<font color="#CCCCCC">you're gonna</font><font color="#E5E5E5"> eat a little bit late</font>

941
00:54:10,340 --> 00:54:17,720
because of<font color="#E5E5E5"> me not really a serious</font>

942
00:54:16,040 --> 00:54:20,420
<font color="#E5E5E5">question but what is the YouTube video</font>

943
00:54:17,720 --> 00:54:25,069
in the comment<font color="#E5E5E5"> oh can you play it</font><font color="#CCCCCC"> this</font>

944
00:54:20,420 --> 00:54:28,330
<font color="#E5E5E5">is a French song personnel Delilah it's</font>

945
00:54:25,070 --> 00:54:41,650
a song about<font color="#E5E5E5"> a man punching</font><font color="#CCCCCC"> holes in</font>

946
00:54:28,330 --> 00:54:41,650
Metro tickets<font color="#E5E5E5"> the question</font>

947
00:54:49,650 --> 00:54:54,140
well thank you Bon Appetit

