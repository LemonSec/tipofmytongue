1
00:00:01,690 --> 00:00:07,820
[Applause]

2
00:00:08,080 --> 00:00:09,679
so hello everyone

3
00:00:09,679 --> 00:00:11,599
thanks so much for coming also good job

4
00:00:11,599 --> 00:00:13,360
you've made it to the final talk of the

5
00:00:13,360 --> 00:00:14,639
conference

6
00:00:14,639 --> 00:00:17,520
i'm sergey this is mark we both work as

7
00:00:17,520 --> 00:00:19,760
part of google project zero

8
00:00:19,760 --> 00:00:22,880
we both have been mainly focusing on

9
00:00:22,880 --> 00:00:25,840
chrome research for the past few years

10
00:00:25,840 --> 00:00:28,320
today we're gonna talk about escaping

11
00:00:28,320 --> 00:00:30,720
the sandbox in chromium-based browsers

12
00:00:30,720 --> 00:00:32,320
and more specifically

13
00:00:32,320 --> 00:00:34,640
general approaches an attacker might

14
00:00:34,640 --> 00:00:37,280
take to exploit vulnerabilities in

15
00:00:37,280 --> 00:00:38,879
privileged browser components from a

16
00:00:38,879 --> 00:00:40,719
compromised renderer

17
00:00:40,719 --> 00:00:42,960
so first i'll give you a few examples of

18
00:00:42,960 --> 00:00:45,039
real-world sandbox escapes

19
00:00:45,039 --> 00:00:47,360
and describe

20
00:00:47,360 --> 00:00:49,520
one of our own latest full chains and in

21
00:00:49,520 --> 00:00:52,320
the second more technical part

22
00:00:52,320 --> 00:00:54,559
mark is going to present a new approach

23
00:00:54,559 --> 00:00:56,399
to exploiting vulnerabilities in

24
00:00:56,399 --> 00:00:58,640
privileged processes

25
00:00:58,640 --> 00:01:00,559
so how do people escape the sandbox in

26
00:01:00,559 --> 00:01:01,440
chrome

27
00:01:01,440 --> 00:01:03,359
for many years

28
00:01:03,359 --> 00:01:05,438
most real world actors didn't even

29
00:01:05,438 --> 00:01:07,760
bother with attacking privileged chrome

30
00:01:07,760 --> 00:01:09,840
processors they would just go straight

31
00:01:09,840 --> 00:01:12,960
from the renderer to the us kernel or a

32
00:01:12,960 --> 00:01:14,799
privileged system service

33
00:01:14,799 --> 00:01:17,119
especially since their implants

34
00:01:17,119 --> 00:01:19,520
would usually require a system

35
00:01:19,520 --> 00:01:21,920
privileges to work anyway

36
00:01:21,920 --> 00:01:24,320
such sandbox escapes are nice very

37
00:01:24,320 --> 00:01:26,960
usable between browsers for example they

38
00:01:26,960 --> 00:01:29,759
live longer we've seen them in the while

39
00:01:29,759 --> 00:01:32,079
and they are out of scope of this talk

40
00:01:32,079 --> 00:01:35,520
because they're not chrome specific

41
00:01:35,520 --> 00:01:38,000
luckily it looks like attacking the

42
00:01:38,000 --> 00:01:39,119
os

43
00:01:39,119 --> 00:01:41,119
directly from the renderer is no longer

44
00:01:41,119 --> 00:01:44,079
in in the path of least resistance at

45
00:01:44,079 --> 00:01:46,079
least on some platforms

46
00:01:46,079 --> 00:01:47,520
so maybe

47
00:01:47,520 --> 00:01:49,439
instead of working on this super duper

48
00:01:49,439 --> 00:01:51,360
secure mode someone should

49
00:01:51,360 --> 00:01:53,280
work on uh stronger sandboxing

50
00:01:53,280 --> 00:01:54,479
primitives

51
00:01:54,479 --> 00:01:55,520
but yeah

52
00:01:55,520 --> 00:01:58,320
on some platforms it is now easier to

53
00:01:58,320 --> 00:01:59,680
build a chain

54
00:01:59,680 --> 00:02:02,719
where you compromise the browser or gpu

55
00:02:02,719 --> 00:02:05,360
or network process as an intermediate

56
00:02:05,360 --> 00:02:07,439
step towards getting super powers on the

57
00:02:07,439 --> 00:02:09,360
target device

58
00:02:09,360 --> 00:02:12,400
and how do you do that well occasionally

59
00:02:12,400 --> 00:02:14,879
security researchers find

60
00:02:14,879 --> 00:02:17,040
bugs in privileged processes that can be

61
00:02:17,040 --> 00:02:19,520
triggered directly from javascript or

62
00:02:19,520 --> 00:02:21,440
over the network and you can actually

63
00:02:21,440 --> 00:02:22,480
check out

64
00:02:22,480 --> 00:02:24,319
uh our blog

65
00:02:24,319 --> 00:02:26,239
about exploiting such a bug in the

66
00:02:26,239 --> 00:02:28,160
project your blog

67
00:02:28,160 --> 00:02:30,160
but most of the time

68
00:02:30,160 --> 00:02:31,920
you're required to have a more precise

69
00:02:31,920 --> 00:02:34,720
control over what's sent to you the

70
00:02:34,720 --> 00:02:36,080
privilege process to trigger the

71
00:02:36,080 --> 00:02:38,160
vulnerability which means you have to

72
00:02:38,160 --> 00:02:40,560
compromise the render first and let's

73
00:02:40,560 --> 00:02:41,920
look at a few ways

74
00:02:41,920 --> 00:02:46,000
attackers abuse the compromised renderer

75
00:02:46,000 --> 00:02:48,239
this first example is from an exploit

76
00:02:48,239 --> 00:02:49,519
competition

77
00:02:49,519 --> 00:02:51,120
most of the expert is written in

78
00:02:51,120 --> 00:02:52,640
javascript

79
00:02:52,640 --> 00:02:54,800
but the javascript code has to live

80
00:02:54,800 --> 00:02:57,599
patch a number of native functions in

81
00:02:57,599 --> 00:02:59,040
the chrome binary

82
00:02:59,040 --> 00:03:00,720
experts usually do that for one of two

83
00:03:00,720 --> 00:03:01,920
reasons

84
00:03:01,920 --> 00:03:05,120
to remove some render side checks uh in

85
00:03:05,120 --> 00:03:07,680
order to trigger the bug or

86
00:03:07,680 --> 00:03:10,400
uh prevent the renderer from crashing in

87
00:03:10,400 --> 00:03:12,480
the process of excladation and the

88
00:03:12,480 --> 00:03:15,760
second possible reason is that you

89
00:03:15,760 --> 00:03:19,920
might need to modify some data that will

90
00:03:19,920 --> 00:03:22,159
be passed through an ipc channel in a

91
00:03:22,159 --> 00:03:24,159
way that just impossible during the

92
00:03:24,159 --> 00:03:26,720
normal browser operation like corrupt

93
00:03:26,720 --> 00:03:28,959
some length field where the lens

94
00:03:28,959 --> 00:03:30,640
calculation is always correct in the

95
00:03:30,640 --> 00:03:31,760
render

96
00:03:31,760 --> 00:03:33,360
and the main disadvantage of this

97
00:03:33,360 --> 00:03:35,200
approach is that

98
00:03:35,200 --> 00:03:37,599
the necessary modifications

99
00:03:37,599 --> 00:03:39,519
are unique to each bug so it takes

100
00:03:39,519 --> 00:03:41,680
manual work to implement them and quite

101
00:03:41,680 --> 00:03:44,159
possibly takes extra work each time the

102
00:03:44,159 --> 00:03:46,239
browser is updated

103
00:03:46,239 --> 00:03:48,959
there also might be subtle side effects

104
00:03:48,959 --> 00:03:51,200
which will reduce the stability of the

105
00:03:51,200 --> 00:03:54,000
chain and most productionized exploits

106
00:03:54,000 --> 00:03:57,040
actually don't work this way

107
00:03:57,040 --> 00:03:59,360
the absolute wheat is covered in the

108
00:03:59,360 --> 00:04:02,720
wild in late 2020 takes a different and

109
00:04:02,720 --> 00:04:04,720
more conventional approach

110
00:04:04,720 --> 00:04:07,120
in general in the wild browser explore

111
00:04:07,120 --> 00:04:09,680
chains consist of isolated

112
00:04:09,680 --> 00:04:12,560
interchangeable components

113
00:04:12,560 --> 00:04:14,000
since it makes maintaining the

114
00:04:14,000 --> 00:04:15,840
capability easier

115
00:04:15,840 --> 00:04:18,399
in addition it allows the attacker to do

116
00:04:18,399 --> 00:04:20,560
a bit of extra profiling from the render

117
00:04:20,560 --> 00:04:23,040
process and pick the most appropriate

118
00:04:23,040 --> 00:04:24,960
sandbox escape

119
00:04:24,960 --> 00:04:26,560
the render export usually doesn't

120
00:04:26,560 --> 00:04:28,880
provide an interface

121
00:04:28,880 --> 00:04:31,120
to a later stage

122
00:04:31,120 --> 00:04:33,120
it doesn't expose an arbitrary read

123
00:04:33,120 --> 00:04:34,720
write primitive or function call

124
00:04:34,720 --> 00:04:35,759
primitive

125
00:04:35,759 --> 00:04:38,320
it just receives a binary blob with

126
00:04:38,320 --> 00:04:39,440
shell code

127
00:04:39,440 --> 00:04:42,639
and jumps at the beginning of it this

128
00:04:42,639 --> 00:04:44,800
exploit is a small handwritten binary

129
00:04:44,800 --> 00:04:46,160
that supports

130
00:04:46,160 --> 00:04:48,400
four major versions of chrome the

131
00:04:48,400 --> 00:04:51,040
developer had to maintain a list of

132
00:04:51,040 --> 00:04:53,600
version dependent constants and a few

133
00:04:53,600 --> 00:04:56,639
bits of version dependent code so the

134
00:04:56,639 --> 00:05:00,320
expert looks up a table of ipc functions

135
00:05:00,320 --> 00:05:03,680
known as the mojo system api and more

136
00:05:03,680 --> 00:05:05,440
than that later

137
00:05:05,440 --> 00:05:07,440
well and interacts with other processors

138
00:05:07,440 --> 00:05:09,600
at this level which is roughly in the

139
00:05:09,600 --> 00:05:11,120
middle of

140
00:05:11,120 --> 00:05:13,600
the chrome ipc model

141
00:05:13,600 --> 00:05:15,520
the actor has definitely spent a lot of

142
00:05:15,520 --> 00:05:16,639
time

143
00:05:16,639 --> 00:05:19,440
on their sandbox escape exploitation

144
00:05:19,440 --> 00:05:21,600
framework but there's still a fair

145
00:05:21,600 --> 00:05:24,320
amount of manual labor required for each

146
00:05:24,320 --> 00:05:27,440
new bug and exploit

147
00:05:28,080 --> 00:05:29,520
also

148
00:05:29,520 --> 00:05:31,600
yeah they actually has to do things like

149
00:05:31,600 --> 00:05:33,919
going through nine levels of indirection

150
00:05:33,919 --> 00:05:36,960
just to get an ipc handle but that is

151
00:05:36,960 --> 00:05:38,800
just an unavoidable consequence of

152
00:05:38,800 --> 00:05:41,840
chrome's code complexity and the final

153
00:05:41,840 --> 00:05:43,039
example

154
00:05:43,039 --> 00:05:45,039
is also served

155
00:05:45,039 --> 00:05:47,280
uh to target as a binary blob but this

156
00:05:47,280 --> 00:05:50,320
one is much bigger

157
00:05:50,320 --> 00:05:53,039
there's a small bridge layer that looks

158
00:05:53,039 --> 00:05:55,520
up a few pointers in the process memory

159
00:05:55,520 --> 00:05:58,560
and initializes a few structures there's

160
00:05:58,560 --> 00:06:00,479
core exploit logic like the main

161
00:06:00,479 --> 00:06:03,280
function but virtually everything else

162
00:06:03,280 --> 00:06:07,120
is just a copy of chrome that's compiled

163
00:06:07,120 --> 00:06:08,560
in to the

164
00:06:08,560 --> 00:06:10,960
exploits to the binary block

165
00:06:10,960 --> 00:06:12,880
and it's the first time in my experience

166
00:06:12,880 --> 00:06:16,400
that recovering symbols in an exploit

167
00:06:16,400 --> 00:06:19,360
uh we've been div was effective as you

168
00:06:19,360 --> 00:06:21,840
can see on the screenshot is nice c plus

169
00:06:21,840 --> 00:06:23,520
plus function names

170
00:06:23,520 --> 00:06:25,120
there's likely a separate build of this

171
00:06:25,120 --> 00:06:28,240
exploit for every supported version and

172
00:06:28,240 --> 00:06:30,479
interestingly it seems like the most

173
00:06:30,479 --> 00:06:32,240
advanced framework

174
00:06:32,240 --> 00:06:34,000
with little to

175
00:06:34,000 --> 00:06:34,880
no

176
00:06:34,880 --> 00:06:35,919
uh

177
00:06:35,919 --> 00:06:38,880
manual work required per browser update

178
00:06:38,880 --> 00:06:40,240
but

179
00:06:40,240 --> 00:06:42,800
well i hope you agree that two megabyte

180
00:06:42,800 --> 00:06:44,560
shell code is

181
00:06:44,560 --> 00:06:46,880
not the most elegant thing you

182
00:06:46,880 --> 00:06:49,120
ever

183
00:06:49,120 --> 00:06:50,960
yeah these three examples more or less

184
00:06:50,960 --> 00:06:53,440
represent all the samox escapes

185
00:06:53,440 --> 00:06:54,639
more

186
00:06:54,639 --> 00:06:56,560
or rather the sandbox escape

187
00:06:56,560 --> 00:06:58,880
exploitation approaches we've seen in

188
00:06:58,880 --> 00:07:00,720
external exploits

189
00:07:00,720 --> 00:07:01,599
well

190
00:07:01,599 --> 00:07:03,759
we don't like them we want our exploits

191
00:07:03,759 --> 00:07:06,319
to be in pure javascript

192
00:07:06,319 --> 00:07:07,599
so

193
00:07:07,599 --> 00:07:10,240
story time

194
00:07:10,400 --> 00:07:12,639
why is this a picture on the slide

195
00:07:12,639 --> 00:07:14,960
should one of the keynote speakers be

196
00:07:14,960 --> 00:07:17,599
well concerned not really there is

197
00:07:17,599 --> 00:07:19,199
tradition in the security and privacy

198
00:07:19,199 --> 00:07:21,759
teams at google if you live in the team

199
00:07:21,759 --> 00:07:23,680
or we'll live in the company we're

200
00:07:23,680 --> 00:07:25,360
moving to another office like another

201
00:07:25,360 --> 00:07:27,199
country you can challenge your

202
00:07:27,199 --> 00:07:29,759
colleagues to own you and steal your

203
00:07:29,759 --> 00:07:31,280
password

204
00:07:31,280 --> 00:07:34,400
your goal is then to defend yourself

205
00:07:34,400 --> 00:07:36,960
this counts as a security exercise and

206
00:07:36,960 --> 00:07:39,280
it leads to interesting discoveries

207
00:07:39,280 --> 00:07:40,319
it

208
00:07:40,319 --> 00:07:43,599
allows the defensive teams to

209
00:07:43,599 --> 00:07:46,240
improve their detection for example most

210
00:07:46,240 --> 00:07:48,080
importantly just a

211
00:07:48,080 --> 00:07:50,800
fun way to

212
00:07:50,879 --> 00:07:53,199
well a way to have fun at work

213
00:07:53,199 --> 00:07:57,199
and actually use some of your zero days

214
00:07:57,680 --> 00:07:59,919
time is usually a constraint in these

215
00:07:59,919 --> 00:08:02,319
exercises because not everyone announces

216
00:08:02,319 --> 00:08:05,440
their departure too well in advance and

217
00:08:05,440 --> 00:08:08,479
the fact that the target expects you to

218
00:08:08,479 --> 00:08:10,720
tag them in the next few weeks

219
00:08:10,720 --> 00:08:13,520
makes it even more exciting

220
00:08:13,520 --> 00:08:14,560
uh

221
00:08:14,560 --> 00:08:16,720
so a little more than a year ago we

222
00:08:16,720 --> 00:08:18,960
learned that justin shu opted into the

223
00:08:18,960 --> 00:08:20,319
tradition

224
00:08:20,319 --> 00:08:22,319
you might know him as one of the authors

225
00:08:22,319 --> 00:08:23,440
of this book

226
00:08:23,440 --> 00:08:25,520
entitled the art of the software

227
00:08:25,520 --> 00:08:28,319
security assessment but jason also spent

228
00:08:28,319 --> 00:08:31,199
more than a decade securing chrome so it

229
00:08:31,199 --> 00:08:33,120
all naturally made sense to own him with

230
00:08:33,120 --> 00:08:35,919
a chrome full chain

231
00:08:38,479 --> 00:08:40,399
we knew that

232
00:08:40,399 --> 00:08:42,958
as most googlers justin primarily used

233
00:08:42,958 --> 00:08:45,680
his chrome os laptop we suspected it

234
00:08:45,680 --> 00:08:46,959
might create

235
00:08:46,959 --> 00:08:50,080
additional challenges well and it did

236
00:08:50,080 --> 00:08:52,320
so just a couple of words about the

237
00:08:52,320 --> 00:08:53,680
renderer bug

238
00:08:53,680 --> 00:08:56,000
we tried to cut corners obviously and

239
00:08:56,000 --> 00:08:58,800
build an end day chain first so started

240
00:08:58,800 --> 00:09:00,160
by looking for

241
00:09:00,160 --> 00:09:02,640
recently fixed issues that hadn't yet

242
00:09:02,640 --> 00:09:05,040
made it into the latest table release

243
00:09:05,040 --> 00:09:07,440
of chrome and chrome os actually helped

244
00:09:07,440 --> 00:09:09,120
us because it lags

245
00:09:09,120 --> 00:09:10,880
with you day behind the

246
00:09:10,880 --> 00:09:13,120
uh behind other platforms

247
00:09:13,120 --> 00:09:16,320
so and as a lot of you probably know

248
00:09:16,320 --> 00:09:18,160
the best place for finding fresh render

249
00:09:18,160 --> 00:09:20,000
bugs in chrome that are easy to exploit

250
00:09:20,000 --> 00:09:23,760
is v8 slash source compiler

251
00:09:23,760 --> 00:09:24,560
uh

252
00:09:24,560 --> 00:09:25,920
the trigga fan

253
00:09:25,920 --> 00:09:27,360
this change immediately caught our

254
00:09:27,360 --> 00:09:28,720
attention

255
00:09:28,720 --> 00:09:31,040
uh debug

256
00:09:31,040 --> 00:09:32,240
it fixes

257
00:09:32,240 --> 00:09:34,160
makes it the compiled code produce an

258
00:09:34,160 --> 00:09:35,920
incorrect result for an arithmetic

259
00:09:35,920 --> 00:09:37,440
operation

260
00:09:37,440 --> 00:09:38,959
and you can

261
00:09:38,959 --> 00:09:40,560
use it to

262
00:09:40,560 --> 00:09:42,720
create a type mismatch and then exploit

263
00:09:42,720 --> 00:09:44,399
it like a classic

264
00:09:44,399 --> 00:09:45,600
type of bug

265
00:09:45,600 --> 00:09:48,880
in the cheat compiler box is so powerful

266
00:09:48,880 --> 00:09:49,680
and

267
00:09:49,680 --> 00:09:52,720
they have been so thoroughly studied as

268
00:09:52,720 --> 00:09:55,040
amy and samuel's presentation should

269
00:09:55,040 --> 00:09:56,959
have convinced you

270
00:09:56,959 --> 00:09:59,279
that it literally takes minutes or a few

271
00:09:59,279 --> 00:10:01,920
hours in a really bad case to repurpose

272
00:10:01,920 --> 00:10:03,600
your existing

273
00:10:03,600 --> 00:10:05,839
exploit for a new bug that's exactly

274
00:10:05,839 --> 00:10:06,959
what we did

275
00:10:06,959 --> 00:10:09,200
so with the renderer quickly out of the

276
00:10:09,200 --> 00:10:12,079
way we moved on to the sandbox escape

277
00:10:12,079 --> 00:10:14,720
unfortunately we couldn't find any

278
00:10:14,720 --> 00:10:16,560
ndas that affected chrome os and were

279
00:10:16,560 --> 00:10:18,320
easy enough to exploit so we had to look

280
00:10:18,320 --> 00:10:19,040
for

281
00:10:19,040 --> 00:10:21,360
our own vulnerability

282
00:10:21,360 --> 00:10:23,920
our choice of the area to focus on was

283
00:10:23,920 --> 00:10:26,320
inspired by in the wild bug we

284
00:10:26,320 --> 00:10:29,040
investigated just a few weeks before

285
00:10:29,040 --> 00:10:31,040
and that area is the layer that

286
00:10:31,040 --> 00:10:34,880
translates ipc types in chrome into

287
00:10:34,880 --> 00:10:37,920
native c plus plus types this is done

288
00:10:37,920 --> 00:10:40,560
automatically most of the time but some

289
00:10:40,560 --> 00:10:42,800
in some corner cases the developer has

290
00:10:42,800 --> 00:10:45,200
to implement the serialization and

291
00:10:45,200 --> 00:10:48,640
deserialization manually

292
00:10:48,800 --> 00:10:51,040
yeah so in

293
00:10:51,040 --> 00:10:52,800
our experience

294
00:10:52,800 --> 00:10:54,959
performing variant analysis on

295
00:10:54,959 --> 00:10:56,959
and in the wild issue

296
00:10:56,959 --> 00:10:58,800
almost always leads to the discovery of

297
00:10:58,800 --> 00:11:02,480
at least one related issue or a variant

298
00:11:02,480 --> 00:11:04,800
this is not the case for any other type

299
00:11:04,800 --> 00:11:07,760
of external or internal bug report

300
00:11:07,760 --> 00:11:10,240
like it almost like people

301
00:11:10,240 --> 00:11:12,800
selling capabilities don't like bug

302
00:11:12,800 --> 00:11:14,399
collisions

303
00:11:14,399 --> 00:11:15,519
and

304
00:11:15,519 --> 00:11:17,680
choose to look for bugs in more obscure

305
00:11:17,680 --> 00:11:19,600
areas

306
00:11:19,600 --> 00:11:21,839
so on this slide you can see the

307
00:11:21,839 --> 00:11:25,200
definition of a chrome ipc data type

308
00:11:25,200 --> 00:11:27,920
called data element written in

309
00:11:27,920 --> 00:11:30,000
mojo idl

310
00:11:30,000 --> 00:11:32,240
data element is essentially

311
00:11:32,240 --> 00:11:35,120
a union type but it was defined as a

312
00:11:35,120 --> 00:11:36,880
regular structure

313
00:11:36,880 --> 00:11:38,880
emulating a union with a few shared

314
00:11:38,880 --> 00:11:39,920
fields

315
00:11:39,920 --> 00:11:41,600
on the right you can see

316
00:11:41,600 --> 00:11:44,959
it redefined properly after the fix

317
00:11:44,959 --> 00:11:47,200
the problem here is that several data

318
00:11:47,200 --> 00:11:49,839
element subtypes need to track the

319
00:11:49,839 --> 00:11:51,680
length of the element

320
00:11:51,680 --> 00:11:54,240
but one of the subtypes namely

321
00:11:54,240 --> 00:11:55,440
k bytes

322
00:11:55,440 --> 00:11:58,000
uh already stores the length internally

323
00:11:58,000 --> 00:12:00,079
and the deserialization code doesn't

324
00:12:00,079 --> 00:12:02,320
check that the two values match

325
00:12:02,320 --> 00:12:03,440
this is the

326
00:12:03,440 --> 00:12:05,839
the serialization function

327
00:12:05,839 --> 00:12:09,279
uh out points to an object of the native

328
00:12:09,279 --> 00:12:12,480
c plus class data element type outbuff

329
00:12:12,480 --> 00:12:13,519
is a

330
00:12:13,519 --> 00:12:16,160
is a nasty vector that's initialized

331
00:12:16,160 --> 00:12:19,200
with the data we control and our length

332
00:12:19,200 --> 00:12:21,920
is initialized with an independent value

333
00:12:21,920 --> 00:12:24,079
essentially which we also control of

334
00:12:24,079 --> 00:12:26,160
course the code that deals

335
00:12:26,160 --> 00:12:28,639
with serialized data elements with

336
00:12:28,639 --> 00:12:30,560
deserialized data it's fully trusted in

337
00:12:30,560 --> 00:12:33,199
length field

338
00:12:33,360 --> 00:12:34,480
we

339
00:12:34,480 --> 00:12:36,720
unfortunately can't sit on

340
00:12:36,720 --> 00:12:38,560
zero days at project zero so we had to

341
00:12:38,560 --> 00:12:40,079
report the issue to chrome before

342
00:12:40,079 --> 00:12:41,360
continuing

343
00:12:41,360 --> 00:12:43,519
but the bug seems pretty powerful and

344
00:12:43,519 --> 00:12:45,519
it's a classic primitive we have a

345
00:12:45,519 --> 00:12:47,360
buffer in which we control

346
00:12:47,360 --> 00:12:49,680
the fake length the actual length and

347
00:12:49,680 --> 00:12:51,519
the contents

348
00:12:51,519 --> 00:12:54,240
unlike the original in the wild issue

349
00:12:54,240 --> 00:12:56,160
though a privileged process will never

350
00:12:56,160 --> 00:12:58,639
write anything to the buffer

351
00:12:58,639 --> 00:13:01,120
the only thing it can do is to send the

352
00:13:01,120 --> 00:13:03,279
contents of the data element to remote

353
00:13:03,279 --> 00:13:08,320
server as a body of an http request

354
00:13:10,079 --> 00:13:12,880
luckily for us our colleague stefan

355
00:13:12,880 --> 00:13:14,399
has discovered a technique for

356
00:13:14,399 --> 00:13:16,480
exploiting infolegs and privileged

357
00:13:16,480 --> 00:13:19,279
processes actually

358
00:13:19,279 --> 00:13:21,760
presented it at this stage and the last

359
00:13:21,760 --> 00:13:23,200
offensive com

360
00:13:23,200 --> 00:13:25,680
it turns out that in chrome you can talk

361
00:13:25,680 --> 00:13:28,240
to an ipc interface as long as you know

362
00:13:28,240 --> 00:13:32,240
it's a 128-bit secret port name

363
00:13:32,240 --> 00:13:34,560
well to be honest you can no longer do

364
00:13:34,560 --> 00:13:36,160
that stefan has finally killed the

365
00:13:36,160 --> 00:13:37,760
technique in

366
00:13:37,760 --> 00:13:39,839
chrome 99 so

367
00:13:39,839 --> 00:13:41,760
in a few weeks it's yeah it will become

368
00:13:41,760 --> 00:13:45,279
useless the vulnerable code handles http

369
00:13:45,279 --> 00:13:46,720
requests so

370
00:13:46,720 --> 00:13:49,199
we must be in the network process

371
00:13:49,199 --> 00:13:52,079
this event has some advantages because

372
00:13:52,079 --> 00:13:52,800
if

373
00:13:52,800 --> 00:13:54,639
our

374
00:13:54,639 --> 00:13:57,279
sloppy exploit crashes the process will

375
00:13:57,279 --> 00:14:00,800
get restarted automatically

376
00:14:00,839 --> 00:14:03,920
without notifying the user

377
00:14:03,920 --> 00:14:05,920
but there are not too many privileged

378
00:14:05,920 --> 00:14:07,920
interfaces in that process and most of

379
00:14:07,920 --> 00:14:09,839
them are created

380
00:14:09,839 --> 00:14:12,800
early in the process startup

381
00:14:12,800 --> 00:14:15,839
so we couldn't groom the heap

382
00:14:15,839 --> 00:14:19,120
well enough to just

383
00:14:19,120 --> 00:14:20,240
steal the

384
00:14:20,240 --> 00:14:22,880
interface name of our choice with a

385
00:14:22,880 --> 00:14:23,839
single

386
00:14:23,839 --> 00:14:25,920
uh

387
00:14:25,920 --> 00:14:28,560
infolec the best strategy we came up

388
00:14:28,560 --> 00:14:30,800
with was to

389
00:14:30,800 --> 00:14:33,920
spray the heap with the target port name

390
00:14:33,920 --> 00:14:37,279
by repeatedly calling a method on the

391
00:14:37,279 --> 00:14:38,959
target interface and we can do that

392
00:14:38,959 --> 00:14:41,600
directly obviously but we can ask the

393
00:14:41,600 --> 00:14:43,839
browser process

394
00:14:43,839 --> 00:14:45,760
we usually can find a method that will

395
00:14:45,760 --> 00:14:48,079
trigger

396
00:14:49,279 --> 00:14:52,240
the sum method in the network process

397
00:14:52,240 --> 00:14:54,959
through the browser process and from

398
00:14:54,959 --> 00:14:56,560
another thread

399
00:14:56,560 --> 00:14:59,199
at the same time would trigger the bug

400
00:14:59,199 --> 00:15:00,160
uh

401
00:15:00,160 --> 00:15:01,279
basically

402
00:15:01,279 --> 00:15:03,279
collect everything that looked like it

403
00:15:03,279 --> 00:15:05,440
could be port name and

404
00:15:05,440 --> 00:15:08,560
check if it's the port we need

405
00:15:08,560 --> 00:15:13,199
the process would take some time uh

406
00:15:13,199 --> 00:15:15,040
and it was also dependent on the

407
00:15:15,040 --> 00:15:16,800
internet bandwidth because we actually

408
00:15:16,800 --> 00:15:19,199
had to send the leak data over the

409
00:15:19,199 --> 00:15:21,680
network

410
00:15:22,560 --> 00:15:25,040
yeah interesting to just close the tab

411
00:15:25,040 --> 00:15:29,759
before it finished also uh

412
00:15:29,759 --> 00:15:31,759
hip spraying a lot of stuff from

413
00:15:31,759 --> 00:15:34,480
multiple processes multiple threads

414
00:15:34,480 --> 00:15:35,680
is

415
00:15:35,680 --> 00:15:38,160
cpu intensive so

416
00:15:38,160 --> 00:15:39,920
if we didn't succeed quickly enough the

417
00:15:39,920 --> 00:15:42,560
fans on the target device would start

418
00:15:42,560 --> 00:15:45,759
spinning a hundred percent which was

419
00:15:45,759 --> 00:15:47,519
slightly suspicious for

420
00:15:47,519 --> 00:15:49,440
our target

421
00:15:49,440 --> 00:15:52,160
we didn't have enough time to find a

422
00:15:52,160 --> 00:15:53,680
better bug

423
00:15:53,680 --> 00:15:56,160
so we just

424
00:15:56,160 --> 00:15:58,160
came up with a workaround

425
00:15:58,160 --> 00:16:02,000
i decided to hide the process

426
00:16:03,040 --> 00:16:05,040
after we successfully exploit the

427
00:16:05,040 --> 00:16:06,399
initial issue

428
00:16:06,399 --> 00:16:10,320
the v8 bug then wait and continue at a

429
00:16:10,320 --> 00:16:13,040
later pace

430
00:16:13,920 --> 00:16:16,079
hopefully without taking too much

431
00:16:16,079 --> 00:16:17,680
attention

432
00:16:17,680 --> 00:16:20,399
by default the renderer is terminated

433
00:16:20,399 --> 00:16:22,800
shortly after the page

434
00:16:22,800 --> 00:16:24,800
is closed

435
00:16:24,800 --> 00:16:26,639
we can avoid that

436
00:16:26,639 --> 00:16:28,959
thanks to shared workers

437
00:16:28,959 --> 00:16:30,959
the shared work interface represents a

438
00:16:30,959 --> 00:16:32,880
specific kind of

439
00:16:32,880 --> 00:16:34,160
worker that can be accessed from

440
00:16:34,160 --> 00:16:37,839
multiple windows at the same time

441
00:16:37,839 --> 00:16:40,079
and

442
00:16:40,079 --> 00:16:41,839
as you can see from its

443
00:16:41,839 --> 00:16:44,480
mojo interface

444
00:16:44,480 --> 00:16:46,560
the shared work and the process it lives

445
00:16:46,560 --> 00:16:49,040
in will be terminated after

446
00:16:49,040 --> 00:16:51,920
the last connection

447
00:16:51,920 --> 00:16:54,079
until it goes away

448
00:16:54,079 --> 00:16:56,639
from a compromised renderer

449
00:16:56,639 --> 00:16:58,320
if we have an obviously read write we

450
00:16:58,320 --> 00:17:00,320
can just

451
00:17:00,320 --> 00:17:02,720
essentially connect the worker to itself

452
00:17:02,720 --> 00:17:06,480
creating an infinite loop and

453
00:17:06,480 --> 00:17:08,000
preventing the process from being

454
00:17:08,000 --> 00:17:10,079
terminated until the whole browser is

455
00:17:10,079 --> 00:17:13,679
restarted the trick worked pretty well

456
00:17:13,679 --> 00:17:14,640
the

457
00:17:14,640 --> 00:17:16,319
laptop

458
00:17:16,319 --> 00:17:20,079
would no longer turn into a jet plane

459
00:17:20,079 --> 00:17:22,400
we just needed to find an ipc interface

460
00:17:22,400 --> 00:17:24,319
to attack

461
00:17:24,319 --> 00:17:26,959
this is a network service the

462
00:17:26,959 --> 00:17:29,200
main motor interface of the network

463
00:17:29,200 --> 00:17:31,039
process used

464
00:17:31,039 --> 00:17:33,440
solely by the browser process and it has

465
00:17:33,440 --> 00:17:35,280
one curious method

466
00:17:35,280 --> 00:17:38,559
that allows you to set up the full path

467
00:17:38,559 --> 00:17:39,360
to

468
00:17:39,360 --> 00:17:42,000
external gss api library that gets

469
00:17:42,000 --> 00:17:44,080
loaded when chrome receives a 401

470
00:17:44,080 --> 00:17:45,440
response

471
00:17:45,440 --> 00:17:47,200
from a web server

472
00:17:47,200 --> 00:17:49,200
that's right message

473
00:17:49,200 --> 00:17:52,880
just loads an so of your choice

474
00:17:52,880 --> 00:17:54,240
uh

475
00:17:54,240 --> 00:17:55,679
very convenient

476
00:17:55,679 --> 00:17:58,559
all that's left is to drop a file on the

477
00:17:58,559 --> 00:18:01,280
target's disk

478
00:18:01,280 --> 00:18:02,400
yeah

479
00:18:02,400 --> 00:18:06,720
there's a lot of different ways you can

480
00:18:08,960 --> 00:18:11,200
use to drop a file

481
00:18:11,200 --> 00:18:13,200
uh you could have used http cache force

482
00:18:13,200 --> 00:18:15,200
the download but

483
00:18:15,200 --> 00:18:16,000
there's

484
00:18:16,000 --> 00:18:18,320
an even better way because the ipc

485
00:18:18,320 --> 00:18:19,840
interface that

486
00:18:19,840 --> 00:18:23,840
access the backhand for the html file

487
00:18:23,840 --> 00:18:26,640
file system api

488
00:18:26,640 --> 00:18:29,120
has the method get platform path that

489
00:18:29,120 --> 00:18:30,880
just

490
00:18:30,880 --> 00:18:32,720
returns you the

491
00:18:32,720 --> 00:18:35,039
full path to

492
00:18:35,039 --> 00:18:36,080
your

493
00:18:36,080 --> 00:18:39,840
uh web file system file uh

494
00:18:39,840 --> 00:18:42,320
it's obviously not exposed to javascript

495
00:18:42,320 --> 00:18:43,200
but

496
00:18:43,200 --> 00:18:45,200
nothing prevents a compromised fender

497
00:18:45,200 --> 00:18:46,960
from calling it

498
00:18:46,960 --> 00:18:47,679
we

499
00:18:47,679 --> 00:18:50,240
put all the parts together

500
00:18:50,240 --> 00:18:52,400
popped caulk

501
00:18:52,400 --> 00:18:54,000
and

502
00:18:54,000 --> 00:18:55,840
we'll learn the hardware the chrome os

503
00:18:55,840 --> 00:18:58,559
isn't linux because in chrome os use the

504
00:18:58,559 --> 00:19:00,720
user data folder which is the only

505
00:19:00,720 --> 00:19:01,679
folder

506
00:19:01,679 --> 00:19:04,000
we could add uh

507
00:19:04,000 --> 00:19:05,760
top files and

508
00:19:05,760 --> 00:19:09,120
it was a non-executable amount

509
00:19:09,120 --> 00:19:12,160
we were really running out of time

510
00:19:12,160 --> 00:19:14,799
at that point because the new chrome

511
00:19:14,799 --> 00:19:17,679
version came out with both of our box

512
00:19:17,679 --> 00:19:18,720
fixed

513
00:19:18,720 --> 00:19:20,960
chest and essentially just needed to

514
00:19:20,960 --> 00:19:22,000
reboot

515
00:19:22,000 --> 00:19:25,200
his laptop

516
00:19:25,200 --> 00:19:27,919
since our last goal was to since our

517
00:19:27,919 --> 00:19:30,640
goal was just to steal the password

518
00:19:30,640 --> 00:19:33,440
we will settle on using another

519
00:19:33,440 --> 00:19:35,600
privileged method in the same network

520
00:19:35,600 --> 00:19:39,240
service interface

521
00:19:40,240 --> 00:19:42,880
to temporarily redirect

522
00:19:42,880 --> 00:19:45,679
all traffic to our proxy server

523
00:19:45,679 --> 00:19:47,679
and make the browser trust our

524
00:19:47,679 --> 00:19:49,200
certificates

525
00:19:49,200 --> 00:19:51,600
then we backgroud the login page by

526
00:19:51,600 --> 00:19:53,600
requesting it from the exploit

527
00:19:53,600 --> 00:19:55,679
responding

528
00:19:55,679 --> 00:19:57,520
from our proxy

529
00:19:57,520 --> 00:19:59,679
adding a couple of very aggressive http

530
00:19:59,679 --> 00:20:02,000
cache headers and a bit of our own

531
00:20:02,000 --> 00:20:03,840
javascript

532
00:20:03,840 --> 00:20:06,799
this is the final exploit flow we have

533
00:20:06,799 --> 00:20:08,960
successfully stolen the password

534
00:20:08,960 --> 00:20:10,720
twice actually because

535
00:20:10,720 --> 00:20:13,039
uh yeah chasing couldn't properly clear

536
00:20:13,039 --> 00:20:15,280
the cache for some reason the first time

537
00:20:15,280 --> 00:20:18,559
the expert has a nice property it's data

538
00:20:18,559 --> 00:20:21,039
only both of its versions didn't have to

539
00:20:21,039 --> 00:20:23,440
run any shell code you don't have to

540
00:20:23,440 --> 00:20:26,240
call any native functions all thanks to

541
00:20:26,240 --> 00:20:29,520
mojo gs and mojo.js is a feature

542
00:20:29,520 --> 00:20:31,840
of chrome that exposes

543
00:20:31,840 --> 00:20:34,400
part of ipc to javascript

544
00:20:34,400 --> 00:20:36,400
it's used by internal

545
00:20:36,400 --> 00:20:38,240
chrome pages but in a compromised

546
00:20:38,240 --> 00:20:42,000
renderer it can be enabled by just or

547
00:20:42,000 --> 00:20:43,760
writing a flag

548
00:20:43,760 --> 00:20:45,760
while we're talking

549
00:20:45,760 --> 00:20:47,679
the browser people in the audience might

550
00:20:47,679 --> 00:20:48,480
ask

551
00:20:48,480 --> 00:20:50,480
why are telling them about

552
00:20:50,480 --> 00:20:52,559
the technique that has been public since

553
00:20:52,559 --> 00:20:55,120
2019 because

554
00:20:55,120 --> 00:20:57,039
we want to show how

555
00:20:57,039 --> 00:20:57,919
fun

556
00:20:57,919 --> 00:20:59,840
exploitation is once you can do it from

557
00:20:59,840 --> 00:21:02,960
javascript but this is an ideal case

558
00:21:02,960 --> 00:21:04,640
we just got lucky with our sandbox

559
00:21:04,640 --> 00:21:05,600
escape

560
00:21:05,600 --> 00:21:08,480
that is the interface the bug was in and

561
00:21:08,480 --> 00:21:09,760
all the interfaces we used for

562
00:21:09,760 --> 00:21:12,240
exploitation were supported by mojo

563
00:21:12,240 --> 00:21:16,000
chairs and in 2022 it's not the case for

564
00:21:16,000 --> 00:21:17,120
most of

565
00:21:17,120 --> 00:21:19,200
bugs and privilege processes reported to

566
00:21:19,200 --> 00:21:20,240
chrome

567
00:21:20,240 --> 00:21:22,240
mark will talk about

568
00:21:22,240 --> 00:21:24,320
why it's not always the case and what to

569
00:21:24,320 --> 00:21:26,240
do about it

570
00:21:26,240 --> 00:21:27,280
okay

571
00:21:27,280 --> 00:21:28,880
yes it works good

572
00:21:28,880 --> 00:21:31,840
um

573
00:21:32,240 --> 00:21:33,919
yeah i hope everybody had a coffee

574
00:21:33,919 --> 00:21:36,240
during the break because it's gonna get

575
00:21:36,240 --> 00:21:37,520
much

576
00:21:37,520 --> 00:21:39,760
heavier from here on and i don't have

577
00:21:39,760 --> 00:21:41,840
enough time to really do a full intro to

578
00:21:41,840 --> 00:21:44,000
mojo i did try to make those slides but

579
00:21:44,000 --> 00:21:47,120
it was just too much

580
00:21:47,280 --> 00:21:49,360
so the rest of this talk is basically

581
00:21:49,360 --> 00:21:52,080
going to follow a little journey

582
00:21:52,080 --> 00:21:53,360
into

583
00:21:53,360 --> 00:21:55,840
mojo and javascript and how the two

584
00:21:55,840 --> 00:21:56,840
mixed

585
00:21:56,840 --> 00:21:59,760
together and it's kind of following

586
00:21:59,760 --> 00:22:00,960
um

587
00:22:00,960 --> 00:22:02,159
a

588
00:22:02,159 --> 00:22:03,840
process that i went through after we

589
00:22:03,840 --> 00:22:05,600
finished analyzing the

590
00:22:05,600 --> 00:22:08,400
second uh sandbox escape that sergey

591
00:22:08,400 --> 00:22:11,679
mentioned before from in the wild stuff

592
00:22:11,679 --> 00:22:13,600
where i said oh i don't understand

593
00:22:13,600 --> 00:22:15,600
chrome android sandbox exploitation

594
00:22:15,600 --> 00:22:17,600
anymore i need to go write an exploit

595
00:22:17,600 --> 00:22:19,679
for this bug just to like you know get

596
00:22:19,679 --> 00:22:21,760
that familiarity back

597
00:22:21,760 --> 00:22:22,640
um

598
00:22:22,640 --> 00:22:24,080
and then i got talked into oh well you

599
00:22:24,080 --> 00:22:25,840
should write the exploit in javascript

600
00:22:25,840 --> 00:22:27,280
and oh actually you should make the

601
00:22:27,280 --> 00:22:29,520
whole thing data only and you know just

602
00:22:29,520 --> 00:22:32,240
snowballed from there

603
00:22:32,240 --> 00:22:34,559
so yeah

604
00:22:34,559 --> 00:22:35,600
quickly

605
00:22:35,600 --> 00:22:37,840
take a look at some mojo idl so this is

606
00:22:37,840 --> 00:22:39,280
basically

607
00:22:39,280 --> 00:22:43,520
how your chrome developer

608
00:22:43,520 --> 00:22:45,679
describes the interface that

609
00:22:45,679 --> 00:22:47,840
their service exposes

610
00:22:47,840 --> 00:22:49,520
we've got a super simple example at the

611
00:22:49,520 --> 00:22:51,120
top

612
00:22:51,120 --> 00:22:52,799
it's a small interface it has one

613
00:22:52,799 --> 00:22:54,880
function it takes a string argument it

614
00:22:54,880 --> 00:22:58,559
returns an array of integers right

615
00:22:58,559 --> 00:23:01,039
in practice the mojo idl lets you

616
00:23:01,039 --> 00:23:02,559
specify like

617
00:23:02,559 --> 00:23:05,760
arrays of maps of integers or arrays of

618
00:23:05,760 --> 00:23:09,200
maps of interfaces or all sorts of crazy

619
00:23:09,200 --> 00:23:11,120
things

620
00:23:11,120 --> 00:23:12,240
but we're not going to go into that

621
00:23:12,240 --> 00:23:14,559
really today

622
00:23:14,559 --> 00:23:16,960
the bottom two examples are a little

623
00:23:16,960 --> 00:23:18,559
more interesting so those would be

624
00:23:18,559 --> 00:23:20,320
interfaces which

625
00:23:20,320 --> 00:23:22,400
you know where they actually return

626
00:23:22,400 --> 00:23:23,520
a handle

627
00:23:23,520 --> 00:23:25,919
to another service

628
00:23:25,919 --> 00:23:26,960
and there's an important difference

629
00:23:26,960 --> 00:23:28,240
between the two

630
00:23:28,240 --> 00:23:29,280
which is

631
00:23:29,280 --> 00:23:32,159
the top one that returns a remote

632
00:23:32,159 --> 00:23:35,200
and a remote is like a service binding

633
00:23:35,200 --> 00:23:37,200
which has its own

634
00:23:37,200 --> 00:23:38,799
message pipe

635
00:23:38,799 --> 00:23:39,760
um

636
00:23:39,760 --> 00:23:40,720
and

637
00:23:40,720 --> 00:23:42,640
an associated remote

638
00:23:42,640 --> 00:23:44,000
that is like

639
00:23:44,000 --> 00:23:46,320
a handle to a service where

640
00:23:46,320 --> 00:23:48,640
you're actually sharing a message pipe

641
00:23:48,640 --> 00:23:50,400
between the parent interface and the

642
00:23:50,400 --> 00:23:52,080
child interface

643
00:23:52,080 --> 00:23:53,919
and we'll see some examples of that in a

644
00:23:53,919 --> 00:23:56,320
little bit

645
00:23:56,320 --> 00:23:58,720
but first i've got a kind of

646
00:23:58,720 --> 00:24:00,559
the writing is kind of small anyway 10

647
00:24:00,559 --> 00:24:03,120
mile view of the mojo

648
00:24:03,120 --> 00:24:04,400
implementation

649
00:24:04,400 --> 00:24:05,520
in chrome

650
00:24:05,520 --> 00:24:07,039
so

651
00:24:07,039 --> 00:24:09,120
starting at the top we have this client

652
00:24:09,120 --> 00:24:10,640
language layer

653
00:24:10,640 --> 00:24:12,080
and

654
00:24:12,080 --> 00:24:14,960
actually you can implement mojo code in

655
00:24:14,960 --> 00:24:19,600
javascript in c plus in java

656
00:24:19,600 --> 00:24:21,120
and in theory you know whatever other

657
00:24:21,120 --> 00:24:23,840
language you would implement this top

658
00:24:23,840 --> 00:24:26,400
section in

659
00:24:26,400 --> 00:24:28,640
and actually the top layer

660
00:24:28,640 --> 00:24:30,720
in this orange section is automatically

661
00:24:30,720 --> 00:24:32,640
generated from that idl code we looked

662
00:24:32,640 --> 00:24:34,799
at dominica

663
00:24:34,799 --> 00:24:37,200
underneath that we have a c api layer

664
00:24:37,200 --> 00:24:39,200
called the mojo system api

665
00:24:39,200 --> 00:24:41,600
and that's where

666
00:24:41,600 --> 00:24:43,279
one of those exploits we saw was

667
00:24:43,279 --> 00:24:45,360
actually hooking into to manually do

668
00:24:45,360 --> 00:24:47,440
their mojo

669
00:24:47,440 --> 00:24:48,960
exploit

670
00:24:48,960 --> 00:24:50,720
um and underneath that we have a load of

671
00:24:50,720 --> 00:24:52,320
cpu plus code which actually implements

672
00:24:52,320 --> 00:24:54,080
all of this and the platform dependence

673
00:24:54,080 --> 00:24:55,600
stuff to actually send these messages

674
00:24:55,600 --> 00:24:57,919
between processes which is obviously

675
00:24:57,919 --> 00:25:00,799
different on each platform

676
00:25:00,799 --> 00:25:03,760
so sergey said a minute ago like yeah

677
00:25:03,760 --> 00:25:05,360
this mojo jess thing it was talked about

678
00:25:05,360 --> 00:25:08,240
in 2019 i think i was maybe the first

679
00:25:08,240 --> 00:25:11,200
person publicly to to talk about doing

680
00:25:11,200 --> 00:25:12,559
this i don't know if anyone was doing it

681
00:25:12,559 --> 00:25:14,480
before hands up

682
00:25:14,480 --> 00:25:16,240
but

683
00:25:16,240 --> 00:25:18,000
yeah so you have a comp you have a

684
00:25:18,000 --> 00:25:20,559
renderer bug there's a flag you can flip

685
00:25:20,559 --> 00:25:22,159
you can reload the frame you get these

686
00:25:22,159 --> 00:25:24,799
javascript bindings you can talk mojo

687
00:25:24,799 --> 00:25:28,080
it's really sweet

688
00:25:28,080 --> 00:25:29,919
your your exploits can be data only

689
00:25:29,919 --> 00:25:31,279
right

690
00:25:31,279 --> 00:25:33,919
so what does this javascript look like

691
00:25:33,919 --> 00:25:35,279
um

692
00:25:35,279 --> 00:25:37,760
this is just a small snippet of code to

693
00:25:37,760 --> 00:25:40,080
interact with the blob registry

694
00:25:40,080 --> 00:25:42,640
um anyone here who has written a mojo

695
00:25:42,640 --> 00:25:44,799
exploit probably used something like

696
00:25:44,799 --> 00:25:46,640
this because it's super convenient for

697
00:25:46,640 --> 00:25:48,960
heat manipulation in the browser process

698
00:25:48,960 --> 00:25:50,159
um

699
00:25:50,159 --> 00:25:52,400
but yeah the top three lines

700
00:25:52,400 --> 00:25:55,360
we're creating basically a

701
00:25:55,360 --> 00:25:58,559
handle to to a blob registry

702
00:25:58,559 --> 00:26:00,799
we're binding that to a message pipe and

703
00:26:00,799 --> 00:26:02,400
then we're sending that message pipe to

704
00:26:02,400 --> 00:26:03,840
the browser process and asking the

705
00:26:03,840 --> 00:26:06,400
browser process to actually connect that

706
00:26:06,400 --> 00:26:09,039
to the blob registry

707
00:26:09,039 --> 00:26:10,799
um the middle bit this is just setting

708
00:26:10,799 --> 00:26:14,080
up arguments whatever some data right

709
00:26:14,080 --> 00:26:16,159
um and then we have effectively a second

710
00:26:16,159 --> 00:26:18,240
ipc call at the bottom

711
00:26:18,240 --> 00:26:19,840
where we're actually sending a request

712
00:26:19,840 --> 00:26:22,000
to this blob registry handle we created

713
00:26:22,000 --> 00:26:25,840
a minute ago so far so good

714
00:26:26,080 --> 00:26:28,799
and for the 2019 exploit and for the one

715
00:26:28,799 --> 00:26:30,000
that um

716
00:26:30,000 --> 00:26:31,600
sergey just discussed

717
00:26:31,600 --> 00:26:33,200
like this is enough we can do everything

718
00:26:33,200 --> 00:26:35,360
we need but he also said

719
00:26:35,360 --> 00:26:37,279
yeah there are some reasons why you

720
00:26:37,279 --> 00:26:38,720
can't use this

721
00:26:38,720 --> 00:26:41,039
and

722
00:26:41,360 --> 00:26:43,440
shortly after that blog post

723
00:26:43,440 --> 00:26:45,679
we saw like a lot of reuse of this

724
00:26:45,679 --> 00:26:48,640
technique in exploit competitions in vrp

725
00:26:48,640 --> 00:26:50,000
reports

726
00:26:50,000 --> 00:26:52,080
and it's kind of dropped off like a lot

727
00:26:52,080 --> 00:26:54,240
of the bug reports now and as you saw

728
00:26:54,240 --> 00:26:55,840
all in the wild stuff

729
00:26:55,840 --> 00:26:56,799
um

730
00:26:56,799 --> 00:26:58,799
there's either renderer patches or just

731
00:26:58,799 --> 00:27:01,120
like loading an elf file or whatever

732
00:27:01,120 --> 00:27:01,919
right

733
00:27:01,919 --> 00:27:04,000
and there's a reason for that

734
00:27:04,000 --> 00:27:07,200
and it's kind of illustrated here so

735
00:27:07,200 --> 00:27:11,120
on the left we have like six interfaces

736
00:27:11,120 --> 00:27:12,480
these are

737
00:27:12,480 --> 00:27:14,159
possibly not all but

738
00:27:14,159 --> 00:27:17,360
nearly all of the ways that the renderer

739
00:27:17,360 --> 00:27:19,679
requests the service binding from the

740
00:27:19,679 --> 00:27:22,240
browser process

741
00:27:22,240 --> 00:27:23,679
and the bottom two which are colored in

742
00:27:23,679 --> 00:27:26,320
orange they're actually exposed to moto

743
00:27:26,320 --> 00:27:28,320
js

744
00:27:28,320 --> 00:27:30,159
and the top four

745
00:27:30,159 --> 00:27:31,919
they're all channeled through this one

746
00:27:31,919 --> 00:27:34,159
big message pipe this associated message

747
00:27:34,159 --> 00:27:35,120
pipe

748
00:27:35,120 --> 00:27:36,640
um

749
00:27:36,640 --> 00:27:37,679
and

750
00:27:37,679 --> 00:27:39,919
this isn't exposed to mojo jess there's

751
00:27:39,919 --> 00:27:42,480
a reason for that which is that

752
00:27:42,480 --> 00:27:43,600
at this

753
00:27:43,600 --> 00:27:45,760
top level in the

754
00:27:45,760 --> 00:27:47,520
implementation we saw before like the

755
00:27:47,520 --> 00:27:48,880
orange layer

756
00:27:48,880 --> 00:27:50,880
you can't really share a single message

757
00:27:50,880 --> 00:27:53,200
pipe between multiple languages

758
00:27:53,200 --> 00:27:55,039
because how would you know which of

759
00:27:55,039 --> 00:27:56,320
those language was supposed to be

760
00:27:56,320 --> 00:27:57,760
reading the next message you got on that

761
00:27:57,760 --> 00:27:59,600
message right it's just the way it's

762
00:27:59,600 --> 00:28:01,200
architected it's not something that

763
00:28:01,200 --> 00:28:04,559
conceptually really works

764
00:28:04,640 --> 00:28:06,080
in addition it's actually not something

765
00:28:06,080 --> 00:28:07,919
that chrome needs

766
00:28:07,919 --> 00:28:10,399
for what they use moto js for so there's

767
00:28:10,399 --> 00:28:12,000
really no reason that they would go and

768
00:28:12,000 --> 00:28:14,480
support it

769
00:28:14,480 --> 00:28:16,240
so we need to find a way around this

770
00:28:16,240 --> 00:28:17,279
first

771
00:28:17,279 --> 00:28:19,039
um because the bug i was looking to

772
00:28:19,039 --> 00:28:21,600
exploit is in a frame associated

773
00:28:21,600 --> 00:28:23,600
interface which is up there in that top

774
00:28:23,600 --> 00:28:26,240
blue section

775
00:28:27,039 --> 00:28:29,520
so we can't share a message pipe between

776
00:28:29,520 --> 00:28:31,440
javascript and c plus plus

777
00:28:31,440 --> 00:28:32,159
but

778
00:28:32,159 --> 00:28:34,640
we can man in the middle a message pipe

779
00:28:34,640 --> 00:28:37,600
between javascript and c plus and just

780
00:28:37,600 --> 00:28:40,240
proxy all of those messages

781
00:28:40,240 --> 00:28:43,559
through javascript

782
00:28:44,080 --> 00:28:46,159
and you think like this is a lot of

783
00:28:46,159 --> 00:28:47,760
like this is a lot of messages this is

784
00:28:47,760 --> 00:28:48,720
like

785
00:28:48,720 --> 00:28:51,039
all of your frame manipulation all of

786
00:28:51,039 --> 00:28:52,320
your dom

787
00:28:52,320 --> 00:28:53,600
like

788
00:28:53,600 --> 00:28:54,799
everything

789
00:28:54,799 --> 00:28:56,799
goes through these this message pipe but

790
00:28:56,799 --> 00:29:00,000
actually it works pretty fine

791
00:29:00,159 --> 00:29:01,120
it's

792
00:29:01,120 --> 00:29:02,480
even better if you do it in a cross

793
00:29:02,480 --> 00:29:04,080
process iframe and not the top level

794
00:29:04,080 --> 00:29:06,000
window because then you don't have any

795
00:29:06,000 --> 00:29:08,480
ui problems at all

796
00:29:08,480 --> 00:29:10,000
so at this point

797
00:29:10,000 --> 00:29:11,600
you say okay we're done

798
00:29:11,600 --> 00:29:13,679
we have mojo.js support for all of the

799
00:29:13,679 --> 00:29:15,200
interfaces we can go and write our

800
00:29:15,200 --> 00:29:16,799
exploit but

801
00:29:16,799 --> 00:29:19,120
um

802
00:29:19,520 --> 00:29:20,880
one of the things that i've been talking

803
00:29:20,880 --> 00:29:22,080
to chrome about one of the things that

804
00:29:22,080 --> 00:29:24,399
came out of that 2019 work was people

805
00:29:24,399 --> 00:29:25,679
saying okay

806
00:29:25,679 --> 00:29:27,520
we should just get rid of mojo.js like

807
00:29:27,520 --> 00:29:29,039
we should just not have this in any of

808
00:29:29,039 --> 00:29:31,679
these renderers that don't need it

809
00:29:31,679 --> 00:29:34,159
and i said well it's not like i mean you

810
00:29:34,159 --> 00:29:35,440
could do that but

811
00:29:35,440 --> 00:29:36,399
it won't

812
00:29:36,399 --> 00:29:37,919
prevent people from doing this i said

813
00:29:37,919 --> 00:29:39,440
like you can just re-implement mojo in

814
00:29:39,440 --> 00:29:42,159
javascript like it's not

815
00:29:42,159 --> 00:29:43,679
such a big problem

816
00:29:43,679 --> 00:29:45,200
um

817
00:29:45,200 --> 00:29:46,720
and then we wondered like

818
00:29:46,720 --> 00:29:48,240
can you like

819
00:29:48,240 --> 00:29:50,080
can you do that cat like we know

820
00:29:50,080 --> 00:29:51,600
javascript engine is super powerful

821
00:29:51,600 --> 00:29:52,720
right we know

822
00:29:52,720 --> 00:29:53,600
you have

823
00:29:53,600 --> 00:29:55,919
so much control but can you really just

824
00:29:55,919 --> 00:29:58,159
re-implement mojo in javascript fully

825
00:29:58,159 --> 00:30:00,399
data only and just

826
00:30:00,399 --> 00:30:03,440
you know not need mojo.js at all

827
00:30:03,440 --> 00:30:04,720
um

828
00:30:04,720 --> 00:30:06,880
i didn't start with that right like i

829
00:30:06,880 --> 00:30:08,559
don't i'm not going to do some huge

830
00:30:08,559 --> 00:30:10,480
engineering project just

831
00:30:10,480 --> 00:30:13,360
straight jump in so i said okay like

832
00:30:13,360 --> 00:30:15,279
what's the simplest way that i could go

833
00:30:15,279 --> 00:30:17,520
about doing this so quickly we'll just

834
00:30:17,520 --> 00:30:21,600
talk back about renderer exploitation so

835
00:30:21,600 --> 00:30:23,440
i think everybody who's written like a

836
00:30:23,440 --> 00:30:25,919
browser exploit will or like a renderer

837
00:30:25,919 --> 00:30:27,279
exploit will be like yeah these are

838
00:30:27,279 --> 00:30:29,520
pretty reasonable primitives to get from

839
00:30:29,520 --> 00:30:31,520
a javascript engine bug right like not

840
00:30:31,520 --> 00:30:32,799
your first order primitives but your

841
00:30:32,799 --> 00:30:34,840
second order primitives right

842
00:30:34,840 --> 00:30:37,760
um so you've got two type confusion

843
00:30:37,760 --> 00:30:39,919
primitives you've got an arbitrary read

844
00:30:39,919 --> 00:30:42,720
arbitrary right

845
00:30:43,440 --> 00:30:44,799
now

846
00:30:44,799 --> 00:30:46,880
this v8 heap sandbox thing right maybe

847
00:30:46,880 --> 00:30:49,039
this arbitrary read up right is going to

848
00:30:49,039 --> 00:30:52,080
become hard who knows

849
00:30:52,080 --> 00:30:53,760
certainly the bottom two

850
00:30:53,760 --> 00:30:55,039
we would hope

851
00:30:55,039 --> 00:30:57,600
that with maybe in five years time ten

852
00:30:57,600 --> 00:31:00,159
years time we have super robust cfi we

853
00:31:00,159 --> 00:31:02,960
have acg everywhere and like

854
00:31:02,960 --> 00:31:04,480
these primitives are looking kind of

855
00:31:04,480 --> 00:31:06,960
questionable maybe i don't know i would

856
00:31:06,960 --> 00:31:09,279
like to see that that future right

857
00:31:09,279 --> 00:31:11,440
um is it going to make a difference for

858
00:31:11,440 --> 00:31:13,519
our sandbox escapes

859
00:31:13,519 --> 00:31:15,679
so

860
00:31:16,159 --> 00:31:17,120
yeah

861
00:31:17,120 --> 00:31:19,679
so where do we start well

862
00:31:19,679 --> 00:31:22,559
this is where mojo.js actually sits in

863
00:31:22,559 --> 00:31:25,600
this this implementation diagram right

864
00:31:25,600 --> 00:31:26,880
um

865
00:31:26,880 --> 00:31:29,600
and it's very very close conceptually to

866
00:31:29,600 --> 00:31:31,679
the blue layer underneath so

867
00:31:31,679 --> 00:31:34,240
this is going to be the easiest way to

868
00:31:34,240 --> 00:31:36,240
sort of bodge ourselves together a new

869
00:31:36,240 --> 00:31:37,679
moto js

870
00:31:37,679 --> 00:31:40,000
um and it turns out it's it's like

871
00:31:40,000 --> 00:31:41,679
pretty easy so

872
00:31:41,679 --> 00:31:43,200
you've using your function called

873
00:31:43,200 --> 00:31:45,279
primitive you can pretty much just you

874
00:31:45,279 --> 00:31:47,120
know write some javascript that mimics

875
00:31:47,120 --> 00:31:49,600
mojo.js and

876
00:31:49,600 --> 00:31:52,159
90 of this this whole thing just drops

877
00:31:52,159 --> 00:31:54,080
out

878
00:31:54,080 --> 00:31:55,279
pretty

879
00:31:55,279 --> 00:31:57,679
easily

880
00:31:58,240 --> 00:31:59,600
however

881
00:31:59,600 --> 00:32:03,200
there is another 10 right um

882
00:32:03,200 --> 00:32:05,039
and

883
00:32:05,039 --> 00:32:07,039
i guess i need to explain briefly what a

884
00:32:07,039 --> 00:32:08,159
trap is

885
00:32:08,159 --> 00:32:09,519
um so

886
00:32:09,519 --> 00:32:11,120
we've been talking about message pipes

887
00:32:11,120 --> 00:32:13,039
and sending messages between processes

888
00:32:13,039 --> 00:32:16,480
but um

889
00:32:17,039 --> 00:32:19,600
mojo doesn't just poll message pipes to

890
00:32:19,600 --> 00:32:21,360
see when there is a message ready right

891
00:32:21,360 --> 00:32:23,760
they need you need something like select

892
00:32:23,760 --> 00:32:25,600
or you know some concept like this

893
00:32:25,600 --> 00:32:26,640
because you have

894
00:32:26,640 --> 00:32:29,840
hundreds of message pipes per process

895
00:32:29,840 --> 00:32:33,600
so trap is like the mojo native

896
00:32:33,600 --> 00:32:36,320
equivalent of select um

897
00:32:36,320 --> 00:32:37,840
and what a trap is basically you

898
00:32:37,840 --> 00:32:40,480
register a handler you attach it to a to

899
00:32:40,480 --> 00:32:43,039
a to a message pipe and when that pipe

900
00:32:43,039 --> 00:32:45,120
becomes readable that trap will fire and

901
00:32:45,120 --> 00:32:47,279
your handle will get called

902
00:32:47,279 --> 00:32:49,279
the problem for us here is this handler

903
00:32:49,279 --> 00:32:52,000
is a function pointer

904
00:32:52,000 --> 00:32:52,960
and

905
00:32:52,960 --> 00:32:55,279
you can't really just have a function

906
00:32:55,279 --> 00:32:59,360
pointer to a javascript function

907
00:32:59,360 --> 00:33:01,440
and

908
00:33:01,440 --> 00:33:03,519
i'll admit that i did actually spend

909
00:33:03,519 --> 00:33:05,760
like maybe a day trying to think of like

910
00:33:05,760 --> 00:33:08,080
how i could arrange things in such a way

911
00:33:08,080 --> 00:33:09,600
that i could have a function pointer to

912
00:33:09,600 --> 00:33:11,279
a javascript function and then i was

913
00:33:11,279 --> 00:33:13,360
like this is really stupid i need to

914
00:33:13,360 --> 00:33:15,279
move on and i will just throw some shell

915
00:33:15,279 --> 00:33:17,120
code in here so

916
00:33:17,120 --> 00:33:20,719
this is the first implementation right

917
00:33:21,519 --> 00:33:23,360
we have a handle to a message pipe we

918
00:33:23,360 --> 00:33:24,960
have a watcher it's going to watch that

919
00:33:24,960 --> 00:33:26,480
handle

920
00:33:26,480 --> 00:33:28,880
we're going to add a trap in

921
00:33:28,880 --> 00:33:30,240
and we'll point that call back to some

922
00:33:30,240 --> 00:33:32,720
shell code

923
00:33:32,880 --> 00:33:35,679
and what will that shell code do well

924
00:33:35,679 --> 00:33:37,200
we want this to be fairly simple right

925
00:33:37,200 --> 00:33:39,440
so we'll just have a big bite array over

926
00:33:39,440 --> 00:33:41,200
in our javascript maybe an old space

927
00:33:41,200 --> 00:33:43,200
something like that

928
00:33:43,200 --> 00:33:45,279
and when that

929
00:33:45,279 --> 00:33:48,240
trap fires the shell code will just set

930
00:33:48,240 --> 00:33:50,480
the signal in this table

931
00:33:50,480 --> 00:33:51,919
and we can pull it from javascript and

932
00:33:51,919 --> 00:33:54,960
we can deliver our callbacks um

933
00:33:54,960 --> 00:33:55,840
yeah

934
00:33:55,840 --> 00:33:59,600
so where are we at so at this point

935
00:33:59,600 --> 00:34:00,640
we're feeling pretty good because we

936
00:34:00,640 --> 00:34:02,640
have a complete polyfill for mojo.js and

937
00:34:02,640 --> 00:34:05,279
we're like well if they remove moto gs

938
00:34:05,279 --> 00:34:07,360
who cares i still have my exploit

939
00:34:07,360 --> 00:34:10,879
written in javascript it's not a problem

940
00:34:11,839 --> 00:34:13,679
but

941
00:34:13,679 --> 00:34:15,359
it's not really

942
00:34:15,359 --> 00:34:17,119
future proof in terms of mitigations

943
00:34:17,119 --> 00:34:19,760
right and certainly not cfi compatible i

944
00:34:19,760 --> 00:34:20,800
mean

945
00:34:20,800 --> 00:34:22,800
i guess you all can probably produce

946
00:34:22,800 --> 00:34:24,800
those primitives right now so i guess

947
00:34:24,800 --> 00:34:27,199
you don't care that much but maybe in 10

948
00:34:27,199 --> 00:34:29,440
years

949
00:34:29,440 --> 00:34:31,760
i would like to think that

950
00:34:31,760 --> 00:34:32,960
those primitives are going to become

951
00:34:32,960 --> 00:34:36,480
more hard and

952
00:34:37,599 --> 00:34:39,199
desire of having shell code in there

953
00:34:39,199 --> 00:34:42,639
right maybe with acg and jitless mode

954
00:34:42,639 --> 00:34:45,918
like this is already kind of

955
00:34:45,918 --> 00:34:46,960
so

956
00:34:46,960 --> 00:34:48,719
it's the first thing we want to do we

957
00:34:48,719 --> 00:34:52,239
want to get rid of the shell code um

958
00:34:52,239 --> 00:34:54,639
and uh

959
00:34:54,639 --> 00:34:56,879
yeah i had to think this this was like

960
00:34:56,879 --> 00:34:58,480
my biggest worry in this whole project

961
00:34:58,480 --> 00:34:59,839
right how am i going to get rid of this

962
00:34:59,839 --> 00:35:01,839
shellcode

963
00:35:01,839 --> 00:35:03,200
and i looked at a lot of the web

964
00:35:03,200 --> 00:35:05,839
platform looking for places that mojo is

965
00:35:05,839 --> 00:35:08,480
used and might be useful

966
00:35:08,480 --> 00:35:09,760
and i found

967
00:35:09,760 --> 00:35:12,800
message channel and

968
00:35:12,800 --> 00:35:14,160
so message channel is like a normal

969
00:35:14,160 --> 00:35:17,280
javascript feature

970
00:35:17,280 --> 00:35:19,680
if you're familiar with post message

971
00:35:19,680 --> 00:35:22,400
message channel is basically a way that

972
00:35:22,400 --> 00:35:24,560
some javascript code can create

973
00:35:24,560 --> 00:35:26,320
a new channel

974
00:35:26,320 --> 00:35:29,040
and it can send part of that over post

975
00:35:29,040 --> 00:35:32,480
message so that you have a separate

976
00:35:32,480 --> 00:35:33,920
communication channel between two

977
00:35:33,920 --> 00:35:36,320
origins or two contexts maybe a worker

978
00:35:36,320 --> 00:35:38,000
and a main page or

979
00:35:38,000 --> 00:35:40,000
an iframe

980
00:35:40,000 --> 00:35:41,200
um

981
00:35:41,200 --> 00:35:42,720
and under the hood that channel is just

982
00:35:42,720 --> 00:35:45,599
a mojo message pipe so

983
00:35:45,599 --> 00:35:48,000
we replace our trap

984
00:35:48,000 --> 00:35:50,079
with a message channel pair

985
00:35:50,079 --> 00:35:52,240
and if you can see like

986
00:35:52,240 --> 00:35:54,079
it's kind of awkward to point over there

987
00:35:54,079 --> 00:35:55,119
but like

988
00:35:55,119 --> 00:35:56,240
this

989
00:35:56,240 --> 00:35:58,400
this pair of message ports they're

990
00:35:58,400 --> 00:36:00,320
effectively connected through some

991
00:36:00,320 --> 00:36:02,720
native code to a pair of message pipes

992
00:36:02,720 --> 00:36:04,880
which meet in the middle

993
00:36:04,880 --> 00:36:05,920
um

994
00:36:05,920 --> 00:36:07,680
and obviously

995
00:36:07,680 --> 00:36:08,720
if this

996
00:36:08,720 --> 00:36:10,720
message port is going to work it needs

997
00:36:10,720 --> 00:36:12,720
to get notifications when those message

998
00:36:12,720 --> 00:36:14,480
pipes are readable right

999
00:36:14,480 --> 00:36:15,359
um

1000
00:36:15,359 --> 00:36:17,680
and that's exactly what they have right

1001
00:36:17,680 --> 00:36:19,839
so for each of these message pipes there

1002
00:36:19,839 --> 00:36:21,200
is a trap which is waiting on that

1003
00:36:21,200 --> 00:36:23,040
handle

1004
00:36:23,040 --> 00:36:24,000
so

1005
00:36:24,000 --> 00:36:26,480
can we just move that handle to point to

1006
00:36:26,480 --> 00:36:27,839
our other message pipe and get

1007
00:36:27,839 --> 00:36:29,839
notifications when that message pipe is

1008
00:36:29,839 --> 00:36:31,280
ready for reading

1009
00:36:31,280 --> 00:36:34,320
um yeah we can i mean

1010
00:36:34,320 --> 00:36:35,920
modulo

1011
00:36:35,920 --> 00:36:38,240
some gymnastics but yes we can and it

1012
00:36:38,240 --> 00:36:41,040
works um

1013
00:36:41,040 --> 00:36:44,720
one of the problems here is that this

1014
00:36:44,720 --> 00:36:47,280
this message port interface right it

1015
00:36:47,280 --> 00:36:49,520
doesn't send raw mojo messages right

1016
00:36:49,520 --> 00:36:51,280
like we can't just send whatever we want

1017
00:36:51,280 --> 00:36:52,960
over that it has some structure it

1018
00:36:52,960 --> 00:36:54,960
expects

1019
00:36:54,960 --> 00:36:57,119
so we have to actually make sure that

1020
00:36:57,119 --> 00:36:58,960
when our top message pipe the one that

1021
00:36:58,960 --> 00:37:01,119
we're actually interested in kind of

1022
00:37:01,119 --> 00:37:02,240
pulling

1023
00:37:02,240 --> 00:37:04,160
becomes ready for reading

1024
00:37:04,160 --> 00:37:05,280
well

1025
00:37:05,280 --> 00:37:06,880
this other message pipe has to have a

1026
00:37:06,880 --> 00:37:08,400
message that's ready to be read

1027
00:37:08,400 --> 00:37:10,160
otherwise everything's gonna get really

1028
00:37:10,160 --> 00:37:11,440
confused

1029
00:37:11,440 --> 00:37:12,320
um

1030
00:37:12,320 --> 00:37:13,359
so yeah we have to do a bit of

1031
00:37:13,359 --> 00:37:14,960
gymnastics but

1032
00:37:14,960 --> 00:37:16,960
it's not actually

1033
00:37:16,960 --> 00:37:19,839
as hard as it looked

1034
00:37:20,839 --> 00:37:24,160
so at this point i'm like okay this is

1035
00:37:24,160 --> 00:37:25,359
going to work i think this is probably

1036
00:37:25,359 --> 00:37:27,839
when i submitted the cfp i'm like it's

1037
00:37:27,839 --> 00:37:28,960
going to be

1038
00:37:28,960 --> 00:37:30,240
and then

1039
00:37:30,240 --> 00:37:31,920
fast forward you know

1040
00:37:31,920 --> 00:37:33,440
whatever it's getting close to the

1041
00:37:33,440 --> 00:37:37,440
conference it's not actually finished um

1042
00:37:37,440 --> 00:37:38,880
because it turns out actually

1043
00:37:38,880 --> 00:37:40,480
re-implementing message pipe is not as

1044
00:37:40,480 --> 00:37:42,240
easy as you might think there's a lot of

1045
00:37:42,240 --> 00:37:43,680
code there

1046
00:37:43,680 --> 00:37:45,599
and

1047
00:37:45,599 --> 00:37:47,520
if we go back to our little system

1048
00:37:47,520 --> 00:37:49,440
diagram

1049
00:37:49,440 --> 00:37:51,440
it's actually kind of difficult

1050
00:37:51,440 --> 00:37:55,440
to interact with the mojo implementation

1051
00:37:55,440 --> 00:37:57,520
at any layer other than the very bottom

1052
00:37:57,520 --> 00:37:58,560
layer

1053
00:37:58,560 --> 00:37:59,920
um

1054
00:37:59,920 --> 00:38:02,000
from like javascript in this data only

1055
00:38:02,000 --> 00:38:04,400
way um

1056
00:38:04,400 --> 00:38:06,400
and the reason for that is just that

1057
00:38:06,400 --> 00:38:07,839
almost all of these layers they're kind

1058
00:38:07,839 --> 00:38:09,760
of a pass through like they just call

1059
00:38:09,760 --> 00:38:11,760
directly into the layer below

1060
00:38:11,760 --> 00:38:12,480
so

1061
00:38:12,480 --> 00:38:14,560
if you're accessing this in parallel

1062
00:38:14,560 --> 00:38:16,160
like obviously the javascript thread

1063
00:38:16,160 --> 00:38:18,240
doesn't normally send mojo messages like

1064
00:38:18,240 --> 00:38:19,280
directly

1065
00:38:19,280 --> 00:38:20,079
so

1066
00:38:20,079 --> 00:38:22,880
the i o thread is constantly interacting

1067
00:38:22,880 --> 00:38:23,680
with

1068
00:38:23,680 --> 00:38:26,400
mojo channels

1069
00:38:26,400 --> 00:38:27,760
we need some

1070
00:38:27,760 --> 00:38:30,160
actual concurrency primitives

1071
00:38:30,160 --> 00:38:32,240
and the only place there is any locking

1072
00:38:32,240 --> 00:38:34,240
or cueing or anything useful like this

1073
00:38:34,240 --> 00:38:36,640
is right down in the bottom so

1074
00:38:36,640 --> 00:38:37,920
we're going to end up writing a lot of c

1075
00:38:37,920 --> 00:38:40,240
a lot of c plus in javascript

1076
00:38:40,240 --> 00:38:42,000
but before we do that

1077
00:38:42,000 --> 00:38:43,920
um we'll take a look at what things look

1078
00:38:43,920 --> 00:38:48,000
like at this very bottom layer so

1079
00:38:48,000 --> 00:38:49,599
this is basically

1080
00:38:49,599 --> 00:38:51,359
if we look at that javascript we wrote

1081
00:38:51,359 --> 00:38:52,640
earlier

1082
00:38:52,640 --> 00:38:55,200
this is the first message which actually

1083
00:38:55,200 --> 00:38:56,800
gets sent

1084
00:38:56,800 --> 00:39:00,320
over the pipe between the two processes

1085
00:39:00,320 --> 00:39:02,160
i'm not going to go into it in detail

1086
00:39:02,160 --> 00:39:04,480
but the top green section is a load of

1087
00:39:04,480 --> 00:39:05,839
different headers

1088
00:39:05,839 --> 00:39:08,240
the big red section is the metadata

1089
00:39:08,240 --> 00:39:09,839
associated with the message pipe that's

1090
00:39:09,839 --> 00:39:11,839
actually being sent

1091
00:39:11,839 --> 00:39:13,680
and all of the orange is actually

1092
00:39:13,680 --> 00:39:17,119
generated from the idl code so that's

1093
00:39:17,119 --> 00:39:18,880
not something that we have to build

1094
00:39:18,880 --> 00:39:22,400
ourselves in this case

1095
00:39:22,640 --> 00:39:24,320
and again we go back to like fast

1096
00:39:24,320 --> 00:39:26,000
forwarding

1097
00:39:26,000 --> 00:39:27,599
i'm not going to show you all of this

1098
00:39:27,599 --> 00:39:29,599
javascript code i will hopefully release

1099
00:39:29,599 --> 00:39:31,200
it at some point when i've removed all

1100
00:39:31,200 --> 00:39:33,280
the to-do's um

1101
00:39:33,280 --> 00:39:36,000
i'm not quite there yet but this is std

1102
00:39:36,000 --> 00:39:39,760
unordered map find in javascript um

1103
00:39:39,760 --> 00:39:42,480
and compatible with cbos plus

1104
00:39:42,480 --> 00:39:45,119
um and in order to get this message pipe

1105
00:39:45,119 --> 00:39:46,240
stuff working right we're going to

1106
00:39:46,240 --> 00:39:49,040
re-implement like half of base and half

1107
00:39:49,040 --> 00:39:51,119
of flip c plus just so that we can

1108
00:39:51,119 --> 00:39:54,240
interact with the data structures

1109
00:39:54,240 --> 00:39:57,839
safely or correctly

1110
00:39:58,480 --> 00:39:59,920
so

1111
00:39:59,920 --> 00:40:02,000
the process i took when i was doing this

1112
00:40:02,000 --> 00:40:04,640
i would say was basically like

1113
00:40:04,640 --> 00:40:07,119
i'm going to go rewrite a load of c plus

1114
00:40:07,119 --> 00:40:09,440
code in javascript and test it and then

1115
00:40:09,440 --> 00:40:11,359
as soon as i reach a point where i find

1116
00:40:11,359 --> 00:40:13,839
something really hard

1117
00:40:13,839 --> 00:40:16,079
or awkward i'll just put a function call

1118
00:40:16,079 --> 00:40:17,359
because i have this called primitive

1119
00:40:17,359 --> 00:40:19,839
right um and i put it to do and i'm like

1120
00:40:19,839 --> 00:40:21,680
later i'll come back to that

1121
00:40:21,680 --> 00:40:23,440
and at this point we have like three to

1122
00:40:23,440 --> 00:40:24,480
do's left

1123
00:40:24,480 --> 00:40:26,400
and they're all kind of hard

1124
00:40:26,400 --> 00:40:28,000
so the rest of this talk is going to be

1125
00:40:28,000 --> 00:40:30,720
like how do we solve each of these

1126
00:40:30,720 --> 00:40:32,960
awkward problems

1127
00:40:32,960 --> 00:40:34,640
in this data only environment where we

1128
00:40:34,640 --> 00:40:39,040
don't want to actually need to break cfi

1129
00:40:39,040 --> 00:40:40,319
and the first one

1130
00:40:40,319 --> 00:40:41,599
which i guess some of you might have

1131
00:40:41,599 --> 00:40:44,000
guessed already is locking

1132
00:40:44,000 --> 00:40:46,240
right

1133
00:40:48,400 --> 00:40:50,720
we need to interact concurrently with

1134
00:40:50,720 --> 00:40:52,640
these c plus data structures from

1135
00:40:52,640 --> 00:40:55,279
javascript

1136
00:40:55,760 --> 00:40:57,920
and the first time i did this i just

1137
00:40:57,920 --> 00:40:59,760
like iterated through the lists and the

1138
00:40:59,760 --> 00:41:01,520
exploit worked like most of the time

1139
00:41:01,520 --> 00:41:03,200
it's like nobody modifies it at the same

1140
00:41:03,200 --> 00:41:05,760
time we're all good um that's not really

1141
00:41:05,760 --> 00:41:08,720
ideal um so yeah we want to take locks

1142
00:41:08,720 --> 00:41:10,400
we want to drop locks

1143
00:41:10,400 --> 00:41:13,119
taking logs

1144
00:41:14,240 --> 00:41:16,079
i mean it's a spin lock right what can

1145
00:41:16,079 --> 00:41:17,920
go wrong um

1146
00:41:17,920 --> 00:41:19,839
i know user space spin locks are frowned

1147
00:41:19,839 --> 00:41:21,680
upon but

1148
00:41:21,680 --> 00:41:24,319
for our purposes this this this will do

1149
00:41:24,319 --> 00:41:25,920
fine

1150
00:41:25,920 --> 00:41:27,839
um

1151
00:41:27,839 --> 00:41:31,040
so this is how you unlock a lock

1152
00:41:31,040 --> 00:41:33,119
right

1153
00:41:33,119 --> 00:41:37,359
um yeah kind of so

1154
00:41:37,599 --> 00:41:39,440
in this case and this is what happens

1155
00:41:39,440 --> 00:41:41,599
maybe nine out of ten times right

1156
00:41:41,599 --> 00:41:44,560
everything is totally fine

1157
00:41:44,560 --> 00:41:46,000
i'll add you can actually do some extra

1158
00:41:46,000 --> 00:41:48,000
tricks so if you modify the internals of

1159
00:41:48,000 --> 00:41:50,480
the mutex you can make it so that other

1160
00:41:50,480 --> 00:41:52,560
threads will spin on it for a bit first

1161
00:41:52,560 --> 00:41:55,280
and some things like this that

1162
00:41:55,280 --> 00:41:57,119
you can get it kind of like you'll only

1163
00:41:57,119 --> 00:42:00,560
your exploit will only stall maybe

1164
00:42:00,560 --> 00:42:02,960
this happens so this is the other case

1165
00:42:02,960 --> 00:42:05,119
this is the bad case javascript is

1166
00:42:05,119 --> 00:42:06,400
holding a lock

1167
00:42:06,400 --> 00:42:09,599
c plus plus code comes to take that lock

1168
00:42:09,599 --> 00:42:11,359
the c plus plus code is like okay i

1169
00:42:11,359 --> 00:42:12,640
better wait

1170
00:42:12,640 --> 00:42:14,240
the javascript code is like i'm going to

1171
00:42:14,240 --> 00:42:16,400
unlock that

1172
00:42:16,400 --> 00:42:18,319
and the i o thread is gone right like

1173
00:42:18,319 --> 00:42:20,240
the i o thread is just going to sleep

1174
00:42:20,240 --> 00:42:22,079
until the browser process kills us

1175
00:42:22,079 --> 00:42:25,520
because we're not talking to it anymore

1176
00:42:26,640 --> 00:42:27,680
and

1177
00:42:27,680 --> 00:42:29,599
i went through a sort of denial phase

1178
00:42:29,599 --> 00:42:31,359
here where i was like

1179
00:42:31,359 --> 00:42:32,720
somewhere

1180
00:42:32,720 --> 00:42:34,400
in the blink code

1181
00:42:34,400 --> 00:42:36,400
i will find a function

1182
00:42:36,400 --> 00:42:39,200
which will acquire a lock and then call

1183
00:42:39,200 --> 00:42:40,720
into javascript

1184
00:42:40,720 --> 00:42:42,400
and then when the javascript returns it

1185
00:42:42,400 --> 00:42:45,040
will release the lock this

1186
00:42:45,040 --> 00:42:46,960
surely somebody has written this in

1187
00:42:46,960 --> 00:42:49,760
blink there is so much code

1188
00:42:49,760 --> 00:42:50,880
and after

1189
00:42:50,880 --> 00:42:52,160
a day of

1190
00:42:52,160 --> 00:42:56,000
grepping through i was like

1191
00:42:56,000 --> 00:42:58,720
again you're being dumb like there is

1192
00:42:58,720 --> 00:43:01,839
just no reason that like this would just

1193
00:43:01,839 --> 00:43:04,800
be so broken that it's like impossible

1194
00:43:04,800 --> 00:43:06,319
that this would exist

1195
00:43:06,319 --> 00:43:07,680
um

1196
00:43:07,680 --> 00:43:10,160
so i found this instead which is not

1197
00:43:10,160 --> 00:43:11,119
that

1198
00:43:11,119 --> 00:43:12,480
um

1199
00:43:12,480 --> 00:43:15,920
this is part of the web codecs api

1200
00:43:15,920 --> 00:43:17,280
and all there is to really say about

1201
00:43:17,280 --> 00:43:18,560
this is

1202
00:43:18,560 --> 00:43:20,560
we have this small object this small

1203
00:43:20,560 --> 00:43:22,480
object contains a mutex

1204
00:43:22,480 --> 00:43:24,800
when we call this function that mutex is

1205
00:43:24,800 --> 00:43:29,040
acquired and then immediately released

1206
00:43:30,240 --> 00:43:31,359
and

1207
00:43:31,359 --> 00:43:33,520
this object is actually referenced from

1208
00:43:33,520 --> 00:43:35,680
the video frame object

1209
00:43:35,680 --> 00:43:38,480
which is actually directly exposed to

1210
00:43:38,480 --> 00:43:40,240
javascript this is one of the bindings

1211
00:43:40,240 --> 00:43:41,359
objects

1212
00:43:41,359 --> 00:43:43,839
and this object has a pointer to that

1213
00:43:43,839 --> 00:43:45,920
frame handle object

1214
00:43:45,920 --> 00:43:46,640
so

1215
00:43:46,640 --> 00:43:48,720
by calling this timestamp function we

1216
00:43:48,720 --> 00:43:50,800
can get a pointer followed to lock a

1217
00:43:50,800 --> 00:43:53,280
mutex and then unlock the mutex so this

1218
00:43:53,280 --> 00:43:55,280
gives us a primitive basically to lock

1219
00:43:55,280 --> 00:43:58,480
and unlock immediately a mutex

1220
00:43:58,480 --> 00:44:00,079
and that's enough to actually fix our

1221
00:44:00,079 --> 00:44:01,920
problem so

1222
00:44:01,920 --> 00:44:03,440
we're sitting here the i o thread is

1223
00:44:03,440 --> 00:44:05,040
stalled

1224
00:44:05,040 --> 00:44:06,880
when we unlock the mutex we can actually

1225
00:44:06,880 --> 00:44:09,440
see somebody else is waiting for us to

1226
00:44:09,440 --> 00:44:11,599
release that mutex

1227
00:44:11,599 --> 00:44:14,000
and we need to now add another thread

1228
00:44:14,000 --> 00:44:17,599
the left gap kind of foreshadowing that

1229
00:44:17,599 --> 00:44:20,079
so we add in a worker

1230
00:44:20,079 --> 00:44:22,640
and what that worker will do is forcibly

1231
00:44:22,640 --> 00:44:24,480
unlock the lock so just set it to

1232
00:44:24,480 --> 00:44:26,000
unlocked

1233
00:44:26,000 --> 00:44:27,839
and then start spinning using that

1234
00:44:27,839 --> 00:44:31,280
primitive to lock and unlock this mutex

1235
00:44:31,280 --> 00:44:32,720
and while it's going we're just going to

1236
00:44:32,720 --> 00:44:34,560
race it in the main thread

1237
00:44:34,560 --> 00:44:36,160
and we're going to try and flip the bit

1238
00:44:36,160 --> 00:44:38,000
which says somebody else is waiting on

1239
00:44:38,000 --> 00:44:40,480
this mutex

1240
00:44:40,480 --> 00:44:41,440
and

1241
00:44:41,440 --> 00:44:44,319
in this case we lost we lost again but

1242
00:44:44,319 --> 00:44:46,000
eventually the main thread will flip

1243
00:44:46,000 --> 00:44:48,160
this while the worker thread is holding

1244
00:44:48,160 --> 00:44:49,599
the mutex

1245
00:44:49,599 --> 00:44:52,160
and then when the mutex is unlocked

1246
00:44:52,160 --> 00:44:54,079
the i o thread wakes back up and we can

1247
00:44:54,079 --> 00:44:55,839
continue

1248
00:44:55,839 --> 00:44:57,119
um

1249
00:44:57,119 --> 00:44:59,760
yeah pretty cool

1250
00:45:01,040 --> 00:45:03,440
so second place

1251
00:45:03,440 --> 00:45:06,000
so we've got locking

1252
00:45:06,000 --> 00:45:08,079
we've implemented all of this stuff

1253
00:45:08,079 --> 00:45:10,160
but at some point we have to actually

1254
00:45:10,160 --> 00:45:12,480
send these messages and

1255
00:45:12,480 --> 00:45:14,000
on linux

1256
00:45:14,000 --> 00:45:15,680
there's actually two ways to send one is

1257
00:45:15,680 --> 00:45:16,960
shared memory that's easy but that

1258
00:45:16,960 --> 00:45:19,359
doesn't work for all messages

1259
00:45:19,359 --> 00:45:22,400
so we actually need a pipe right and

1260
00:45:22,400 --> 00:45:25,920
writing to a pipe is a syscall

1261
00:45:26,240 --> 00:45:28,240
if we look at the actual channel code

1262
00:45:28,240 --> 00:45:31,040
there is a fallback path

1263
00:45:31,040 --> 00:45:33,760
that will get triggered basically if the

1264
00:45:33,760 --> 00:45:36,000
pipe is full

1265
00:45:36,000 --> 00:45:37,359
um

1266
00:45:37,359 --> 00:45:38,560
so you could say well like okay let's

1267
00:45:38,560 --> 00:45:40,000
just send lots of messages the pipe will

1268
00:45:40,000 --> 00:45:42,319
be full and then we can quickly but like

1269
00:45:42,319 --> 00:45:44,560
that's going to cause loads of

1270
00:45:44,560 --> 00:45:46,160
allocations we're trying to write an

1271
00:45:46,160 --> 00:45:48,560
exploit right we don't want to like

1272
00:45:48,560 --> 00:45:50,480
dos the browser process just to send a

1273
00:45:50,480 --> 00:45:52,560
single message like that's not going to

1274
00:45:52,560 --> 00:45:54,800
happen

1275
00:45:54,800 --> 00:45:57,280
so we need to find a way basically to

1276
00:45:57,280 --> 00:45:58,800
mimic

1277
00:45:58,800 --> 00:46:00,400
the bold function call at the bottom

1278
00:46:00,400 --> 00:46:02,240
here wait for write on i o thread no

1279
00:46:02,240 --> 00:46:03,680
lock

1280
00:46:03,680 --> 00:46:05,119
um and that

1281
00:46:05,119 --> 00:46:06,800
initially i just used a function call

1282
00:46:06,800 --> 00:46:07,920
here

1283
00:46:07,920 --> 00:46:08,880
um

1284
00:46:08,880 --> 00:46:10,240
but if we look at what that function

1285
00:46:10,240 --> 00:46:11,760
does

1286
00:46:11,760 --> 00:46:14,560
is it's just going to post a task onto

1287
00:46:14,560 --> 00:46:16,720
the i o thread

1288
00:46:16,720 --> 00:46:18,240
now

1289
00:46:18,240 --> 00:46:20,720
post task itself is not tremendously

1290
00:46:20,720 --> 00:46:22,079
complicated

1291
00:46:22,079 --> 00:46:24,000
um again there is some locking there's

1292
00:46:24,000 --> 00:46:26,079
some sort of lockless magic and things

1293
00:46:26,079 --> 00:46:27,839
but eventually you're just shoving

1294
00:46:27,839 --> 00:46:30,799
something into a queue

1295
00:46:31,280 --> 00:46:34,880
i would note that this is probably the

1296
00:46:34,880 --> 00:46:35,760
most

1297
00:46:35,760 --> 00:46:37,760
sketchy part in terms of future

1298
00:46:37,760 --> 00:46:40,800
mitigations because we do have to fake a

1299
00:46:40,800 --> 00:46:43,599
c plus object that contains like a

1300
00:46:43,599 --> 00:46:45,839
function pointer right effectively

1301
00:46:45,839 --> 00:46:47,119
um

1302
00:46:47,119 --> 00:46:48,000
so

1303
00:46:48,000 --> 00:46:49,680
maybe

1304
00:46:49,680 --> 00:46:51,119
you could imagine some current

1305
00:46:51,119 --> 00:46:52,960
mitigations that might try to do

1306
00:46:52,960 --> 00:46:54,800
something to stop this from being easily

1307
00:46:54,800 --> 00:46:57,119
forgeable

1308
00:46:57,119 --> 00:46:58,400
i

1309
00:46:58,400 --> 00:46:59,599
don't

1310
00:46:59,599 --> 00:47:01,680
think that any current implementations

1311
00:47:01,680 --> 00:47:04,319
would make this actually very hard

1312
00:47:04,319 --> 00:47:06,160
but if you do feel free to talk to me

1313
00:47:06,160 --> 00:47:08,799
about that later

1314
00:47:09,200 --> 00:47:10,880
so all we have to do actually is create

1315
00:47:10,880 --> 00:47:13,839
this fake task and add it to this queue

1316
00:47:13,839 --> 00:47:15,680
um

1317
00:47:15,680 --> 00:47:17,520
i did spend two days debugging why the

1318
00:47:17,520 --> 00:47:19,839
exploit didn't work after i did this

1319
00:47:19,839 --> 00:47:20,800
um

1320
00:47:20,800 --> 00:47:23,760
even though these tasks were getting run

1321
00:47:23,760 --> 00:47:25,119
the exploit didn't work the exploit

1322
00:47:25,119 --> 00:47:26,400
didn't work because the tasks were

1323
00:47:26,400 --> 00:47:28,160
getting run really late

1324
00:47:28,160 --> 00:47:29,520
tasks were getting run really late

1325
00:47:29,520 --> 00:47:30,880
because the i o thread wasn't doing

1326
00:47:30,880 --> 00:47:33,280
anything

1327
00:47:33,280 --> 00:47:35,119
so

1328
00:47:35,119 --> 00:47:38,160
there is a load-bearing cookie set in my

1329
00:47:38,160 --> 00:47:40,160
framework that just causes the i o

1330
00:47:40,160 --> 00:47:41,680
thread to do some work so that it picks

1331
00:47:41,680 --> 00:47:43,839
up these tasks and sends the messages

1332
00:47:43,839 --> 00:47:46,000
and that's all you need to do just

1333
00:47:46,000 --> 00:47:48,319
just to force this message queue to exit

1334
00:47:48,319 --> 00:47:51,200
so that it actually picks up this task

1335
00:47:51,200 --> 00:47:53,359
so we can send messages

1336
00:47:53,359 --> 00:47:55,200
um and we're left with really one

1337
00:47:55,200 --> 00:47:56,960
problem left

1338
00:47:56,960 --> 00:47:57,839
um

1339
00:47:57,839 --> 00:47:58,880
and this

1340
00:47:58,880 --> 00:48:01,839
this is kind of a tricky one because

1341
00:48:01,839 --> 00:48:04,559
again maybe if you've been thinking and

1342
00:48:04,559 --> 00:48:06,240
well maybe that's a bit that's a bit

1343
00:48:06,240 --> 00:48:09,119
much to expect to follow and

1344
00:48:09,119 --> 00:48:11,839
anyway um

1345
00:48:11,839 --> 00:48:14,400
we have these traps

1346
00:48:14,400 --> 00:48:17,040
um that we discussed right and if we

1347
00:48:17,040 --> 00:48:20,559
receive a message in javascript

1348
00:48:20,559 --> 00:48:22,079
and it needs to be dispatched to the

1349
00:48:22,079 --> 00:48:24,640
cpos plus code we might have to fire one

1350
00:48:24,640 --> 00:48:26,079
of these traps

1351
00:48:26,079 --> 00:48:28,160
but we already know these traps contain

1352
00:48:28,160 --> 00:48:31,200
arbitrary function pointers

1353
00:48:31,200 --> 00:48:32,160
so

1354
00:48:32,160 --> 00:48:33,839
like this is the code where it would

1355
00:48:33,839 --> 00:48:36,000
happen right so

1356
00:48:36,000 --> 00:48:37,839
if we'd received a message on a message

1357
00:48:37,839 --> 00:48:40,800
pipe and we actually need to dispatch

1358
00:48:40,800 --> 00:48:42,160
that message

1359
00:48:42,160 --> 00:48:44,559
and it turns out that's the next message

1360
00:48:44,559 --> 00:48:46,240
that message pipe is waiting for so that

1361
00:48:46,240 --> 00:48:49,040
message pipe goes from non-readable to

1362
00:48:49,040 --> 00:48:51,200
readable then that port status has

1363
00:48:51,200 --> 00:48:52,800
changed we need

1364
00:48:52,800 --> 00:48:55,040
to actually fire that trap

1365
00:48:55,040 --> 00:48:56,160
which means we have to call this

1366
00:48:56,160 --> 00:48:58,960
function pointer

1367
00:48:59,920 --> 00:49:00,880
so

1368
00:49:00,880 --> 00:49:04,559
there are basically three cases here

1369
00:49:04,800 --> 00:49:06,559
so the first one

1370
00:49:06,559 --> 00:49:08,400
we have our exploit code in javascript

1371
00:49:08,400 --> 00:49:10,000
it's sending some message through this

1372
00:49:10,000 --> 00:49:12,800
proxy it's going to another process

1373
00:49:12,800 --> 00:49:14,720
if we get a message back it's going to

1374
00:49:14,720 --> 00:49:16,400
the javascript so

1375
00:49:16,400 --> 00:49:18,160
we don't care what the c plus code

1376
00:49:18,160 --> 00:49:21,200
thinks it's not a problem

1377
00:49:21,599 --> 00:49:23,280
we have our exploit code in javascript

1378
00:49:23,280 --> 00:49:25,280
it's sending a message to the local cpos

1379
00:49:25,280 --> 00:49:27,440
plus code this is a problem but we don't

1380
00:49:27,440 --> 00:49:29,280
care because you're not trying to

1381
00:49:29,280 --> 00:49:31,280
exploit the local renderer right so why

1382
00:49:31,280 --> 00:49:34,319
would you send this message

1383
00:49:35,200 --> 00:49:37,599
unfortunately this case we actually do

1384
00:49:37,599 --> 00:49:40,000
care about um so this is when we're

1385
00:49:40,000 --> 00:49:42,160
proxying a message from the browser

1386
00:49:42,160 --> 00:49:44,480
process to the local c plus plus code

1387
00:49:44,480 --> 00:49:46,160
and that would make a message pipe

1388
00:49:46,160 --> 00:49:47,839
readable

1389
00:49:47,839 --> 00:49:49,599
and then we need to actually dispatch

1390
00:49:49,599 --> 00:49:53,440
this trap we need to call this function

1391
00:49:53,440 --> 00:49:55,119
one way around this would be to

1392
00:49:55,119 --> 00:49:56,720
literally re-implement the entire

1393
00:49:56,720 --> 00:49:58,720
renderer in javascript inside the

1394
00:49:58,720 --> 00:50:00,720
renderer so that you could just dispatch

1395
00:50:00,720 --> 00:50:02,400
this to your javascript implementation

1396
00:50:02,400 --> 00:50:04,559
of all of these interfaces

1397
00:50:04,559 --> 00:50:06,720
i would not recommend trying to do that

1398
00:50:06,720 --> 00:50:07,520
but

1399
00:50:07,520 --> 00:50:09,119
again if you do it i would love to see

1400
00:50:09,119 --> 00:50:10,839
the code

1401
00:50:10,839 --> 00:50:13,920
um what i actually did was complain to

1402
00:50:13,920 --> 00:50:15,280
my teammates about how this was

1403
00:50:15,280 --> 00:50:16,400
impossible

1404
00:50:16,400 --> 00:50:17,359
um

1405
00:50:17,359 --> 00:50:18,240
and

1406
00:50:18,240 --> 00:50:20,319
as often happens when you say something

1407
00:50:20,319 --> 00:50:22,160
like that um

1408
00:50:22,160 --> 00:50:24,640
jan horn was like it's really easy what

1409
00:50:24,640 --> 00:50:26,480
are you complaining about you just need

1410
00:50:26,480 --> 00:50:28,640
to add more indirection

1411
00:50:28,640 --> 00:50:31,680
so indeed double down

1412
00:50:31,680 --> 00:50:34,800
double down add another renderer

1413
00:50:34,800 --> 00:50:36,800
suddenly all of these messages that were

1414
00:50:36,800 --> 00:50:39,040
processed local and problematic now

1415
00:50:39,040 --> 00:50:41,599
they're they're not process local right

1416
00:50:41,599 --> 00:50:43,839
every message we want to deliver locally

1417
00:50:43,839 --> 00:50:46,720
we just bounce through another renderer

1418
00:50:46,720 --> 00:50:48,480
the problem is solved and the c plus

1419
00:50:48,480 --> 00:50:50,720
code just handles it for us

1420
00:50:50,720 --> 00:50:52,240
um

1421
00:50:52,240 --> 00:50:55,119
yeah and at that point

1422
00:50:55,119 --> 00:50:58,079
the end we have a full

1423
00:50:58,079 --> 00:51:00,720
effectively mitigation safe mojo.js

1424
00:51:00,720 --> 00:51:02,240
future-proof

1425
00:51:02,240 --> 00:51:03,200
um

1426
00:51:03,200 --> 00:51:05,440
implementation of mojo from javascript

1427
00:51:05,440 --> 00:51:06,640
and

1428
00:51:06,640 --> 00:51:08,720
you can go on and write i mean i never

1429
00:51:08,720 --> 00:51:09,760
actually got around to writing the

1430
00:51:09,760 --> 00:51:11,119
exploit because it took me so long to

1431
00:51:11,119 --> 00:51:13,760
write the framework that i was like oh

1432
00:51:13,760 --> 00:51:15,599
it's offensive con already

1433
00:51:15,599 --> 00:51:17,280
um

1434
00:51:17,280 --> 00:51:18,720
so i guess i'll probably go and do that

1435
00:51:18,720 --> 00:51:20,640
at some point but um

1436
00:51:20,640 --> 00:51:21,440
yeah

1437
00:51:21,440 --> 00:51:24,800
um i do intend to release the code at

1438
00:51:24,800 --> 00:51:26,000
least

1439
00:51:26,000 --> 00:51:26,800
the

1440
00:51:26,800 --> 00:51:28,720
simple polyfill should be releasable

1441
00:51:28,720 --> 00:51:30,240
fairly soon

1442
00:51:30,240 --> 00:51:32,480
um but i'm not making any promises i

1443
00:51:32,480 --> 00:51:34,480
would also like to write some blog posts

1444
00:51:34,480 --> 00:51:37,440
about details but again

1445
00:51:37,440 --> 00:51:40,880
there's so much stuff to do so

1446
00:51:40,880 --> 00:51:42,400
but yeah

1447
00:51:42,400 --> 00:51:45,800
any questions

1448
00:51:54,319 --> 00:51:56,400
you

