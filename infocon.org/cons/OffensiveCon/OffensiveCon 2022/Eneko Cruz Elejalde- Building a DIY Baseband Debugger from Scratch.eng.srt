1
00:00:05,560 --> 00:00:10,719
[Applause]

2
00:00:10,719 --> 00:00:12,960
thank you very much so welcome everyone

3
00:00:12,960 --> 00:00:15,360
this is building a diy baseband debugger

4
00:00:15,360 --> 00:00:17,840
from scratch and my name is neko cruz

5
00:00:17,840 --> 00:00:19,439
i am a researcher for exodus

6
00:00:19,439 --> 00:00:21,439
intelligence and my main interest is

7
00:00:21,439 --> 00:00:22,880
vulnerability research and exploit

8
00:00:22,880 --> 00:00:24,000
development

9
00:00:24,000 --> 00:00:26,320
but although we do have a mobile team at

10
00:00:26,320 --> 00:00:27,840
exodus intelligence this is my own

11
00:00:27,840 --> 00:00:30,000
personal research and this is unrelated

12
00:00:30,000 --> 00:00:32,960
to anything that we do at xi

13
00:00:32,960 --> 00:00:34,640
on this presentation we're going to go

14
00:00:34,640 --> 00:00:36,559
really quickly through a very very brief

15
00:00:36,559 --> 00:00:38,559
introduction to baseband we're going to

16
00:00:38,559 --> 00:00:40,800
go through what we actually need to get

17
00:00:40,800 --> 00:00:42,960
started in basement research we're going

18
00:00:42,960 --> 00:00:44,480
to take a look at how we are going to

19
00:00:44,480 --> 00:00:46,960
build a bisburn debugger uh for the

20
00:00:46,960 --> 00:00:50,160
targeting the htc one m9 plus

21
00:00:50,160 --> 00:00:52,559
and uh finally to demonstrate this

22
00:00:52,559 --> 00:00:54,320
hopefully the democrats are smiling to

23
00:00:54,320 --> 00:00:55,680
me we're going to be setting a

24
00:00:55,680 --> 00:00:58,079
breakpoint reading a

25
00:00:58,079 --> 00:01:00,399
message for memory life

26
00:01:00,399 --> 00:01:03,520
um so as i really briefly introduction

27
00:01:03,520 --> 00:01:05,280
to baseband we need to take into account

28
00:01:05,280 --> 00:01:07,200
that a baseband data smartphone is very

29
00:01:07,200 --> 00:01:08,799
different from a computer in a computer

30
00:01:08,799 --> 00:01:10,240
in a general

31
00:01:10,240 --> 00:01:12,320
purpose computer we have a single

32
00:01:12,320 --> 00:01:14,720
processor a cpu running everything and

33
00:01:14,720 --> 00:01:17,600
some peripherals whereas in a in a in a

34
00:01:17,600 --> 00:01:19,119
smartphone we have multiple processors

35
00:01:19,119 --> 00:01:21,119
an application processor digital signal

36
00:01:21,119 --> 00:01:23,920
processors wi-fi chips and the basement

37
00:01:23,920 --> 00:01:26,080
processor that are working together to

38
00:01:26,080 --> 00:01:27,680
achieve a common goal

39
00:01:27,680 --> 00:01:28,479
um

40
00:01:28,479 --> 00:01:30,799
in case of the baseband pressure and the

41
00:01:30,799 --> 00:01:32,640
application processor in a smartphone

42
00:01:32,640 --> 00:01:35,200
they do communicate using sharing

43
00:01:35,200 --> 00:01:37,040
using shared memory interfaces as well

44
00:01:37,040 --> 00:01:38,400
as

45
00:01:38,400 --> 00:01:40,960
in the uh in case of the application

46
00:01:40,960 --> 00:01:43,040
processor and basement processor case

47
00:01:43,040 --> 00:01:45,040
they use 80 commands

48
00:01:45,040 --> 00:01:45,759
so

49
00:01:45,759 --> 00:01:47,920
all in all at the very minimum a

50
00:01:47,920 --> 00:01:49,759
smartphone is going to be running a

51
00:01:49,759 --> 00:01:52,479
linux kernel an android operating system

52
00:01:52,479 --> 00:01:55,439
some user applications and a firmware

53
00:01:55,439 --> 00:01:57,680
for each processor

54
00:01:57,680 --> 00:01:59,759
uh the application processor is going to

55
00:01:59,759 --> 00:02:01,600
be running a linux kernel and an android

56
00:02:01,600 --> 00:02:03,520
operating system and

57
00:02:03,520 --> 00:02:05,280
any application user application that

58
00:02:05,280 --> 00:02:06,560
you can think about

59
00:02:06,560 --> 00:02:07,600
whereas

60
00:02:07,600 --> 00:02:09,758
the baseband processor is going to be an

61
00:02:09,758 --> 00:02:11,840
arm chip in this case in this case of

62
00:02:11,840 --> 00:02:13,920
this particular phone running its own

63
00:02:13,920 --> 00:02:16,400
operating system or firmware

64
00:02:16,400 --> 00:02:19,200
um as you probably know the baseband

65
00:02:19,200 --> 00:02:20,879
processor is the one handling cellular

66
00:02:20,879 --> 00:02:24,000
communications with cell phone towers

67
00:02:24,000 --> 00:02:25,599
why is this interesting to us why is

68
00:02:25,599 --> 00:02:27,440
this interesting to me particularly

69
00:02:27,440 --> 00:02:29,440
because this is a pro code base and it's

70
00:02:29,440 --> 00:02:31,519
actually written in cnc plus which as

71
00:02:31,519 --> 00:02:32,640
you might know

72
00:02:32,640 --> 00:02:35,120
this can bring a lot of bucks

73
00:02:35,120 --> 00:02:38,959
in this case um for the htc one m9 i

74
00:02:38,959 --> 00:02:40,560
found that in the baseband there is no

75
00:02:40,560 --> 00:02:41,519
privilege

76
00:02:41,519 --> 00:02:44,400
separation whatsoever in the basement os

77
00:02:44,400 --> 00:02:46,959
um but however the entry bar is higher

78
00:02:46,959 --> 00:02:49,599
as you do need some hardware

79
00:02:49,599 --> 00:02:51,440
and this

80
00:02:51,440 --> 00:02:53,040
this actually means that there is less

81
00:02:53,040 --> 00:02:55,599
research uh available on the topic on

82
00:02:55,599 --> 00:02:58,319
top of that most interestingly uh

83
00:02:58,319 --> 00:03:00,159
this offers the possibility of

84
00:03:00,159 --> 00:03:02,000
triggering remote qualification over the

85
00:03:02,000 --> 00:03:03,920
air without any user interaction

86
00:03:03,920 --> 00:03:06,000
whatsoever

87
00:03:06,000 --> 00:03:08,159
so as a bare minimum to get started in

88
00:03:08,159 --> 00:03:10,560
baseband research we do need a phone we

89
00:03:10,560 --> 00:03:12,400
need some solar

90
00:03:12,400 --> 00:03:15,280
cellular setup which is comprised of a

91
00:03:15,280 --> 00:03:17,599
hardware setup and a software setup

92
00:03:17,599 --> 00:03:19,920
and we need also some minimum to have

93
00:03:19,920 --> 00:03:22,720
access to the baseband to the baseband

94
00:03:22,720 --> 00:03:24,879
firmware or the always binary it's also

95
00:03:24,879 --> 00:03:26,799
very nice to get some debugging symbols

96
00:03:26,799 --> 00:03:28,000
as always

97
00:03:28,000 --> 00:03:29,599
and it's also very nice to have a

98
00:03:29,599 --> 00:03:31,360
debugger the debugger building the

99
00:03:31,360 --> 00:03:34,239
debugger is the main topic for this talk

100
00:03:34,239 --> 00:03:36,879
um i'm going to be targeting the htc one

101
00:03:36,879 --> 00:03:39,599
m9 plus today uh it is a pretty old

102
00:03:39,599 --> 00:03:41,920
baseband it's from 2015 but it's

103
00:03:41,920 --> 00:03:43,440
actually very great it's a really good

104
00:03:43,440 --> 00:03:46,159
platform to get started this go for

105
00:03:46,159 --> 00:03:48,959
around 100 dollars on ebay and so far

106
00:03:48,959 --> 00:03:52,560
i've destroyed three of them in my test

107
00:03:52,560 --> 00:03:55,360
the pros of using this platform is that

108
00:03:55,360 --> 00:03:57,040
routing is partially supported by the

109
00:03:57,040 --> 00:03:59,120
manufacturer and most importantly the

110
00:03:59,120 --> 00:04:00,879
basement firmware is not signed or

111
00:04:00,879 --> 00:04:04,239
checked whatsoever um for this uh

112
00:04:04,239 --> 00:04:06,239
for this uh research to be extended to

113
00:04:06,239 --> 00:04:07,599
other platforms

114
00:04:07,599 --> 00:04:09,519
uh the basement firmware not to be

115
00:04:09,519 --> 00:04:11,920
checked is a requirement

116
00:04:11,920 --> 00:04:13,040
um

117
00:04:13,040 --> 00:04:16,478
and rooting the um rooting the phone is

118
00:04:16,478 --> 00:04:19,120
usually a requirement also to be able to

119
00:04:19,120 --> 00:04:22,800
override the firm the basement firmware

120
00:04:22,800 --> 00:04:23,919
inside

121
00:04:23,919 --> 00:04:27,199
my target i have placed a sim card

122
00:04:27,199 --> 00:04:29,600
not just any sim card is one

123
00:04:29,600 --> 00:04:32,479
of which the mc is known is these are

124
00:04:32,479 --> 00:04:34,639
manufactured by cismocom

125
00:04:34,639 --> 00:04:36,800
the mca the

126
00:04:36,800 --> 00:04:38,720
international mobile subscriber identity

127
00:04:38,720 --> 00:04:41,199
is going to be known to open bts and

128
00:04:41,199 --> 00:04:43,440
therefore this phone when is when the

129
00:04:43,440 --> 00:04:45,440
sim card is inserted is going to be

130
00:04:45,440 --> 00:04:48,000
allowed in the network although others

131
00:04:48,000 --> 00:04:50,240
should be should should work as well i

132
00:04:50,240 --> 00:04:52,000
so far i haven't found a single sim card

133
00:04:52,000 --> 00:04:53,680
that didn't work

134
00:04:53,680 --> 00:04:56,240
um this cellular setup which i have

135
00:04:56,240 --> 00:04:57,360
right here

136
00:04:57,360 --> 00:05:00,000
looks like this is a tabletop device and

137
00:05:00,000 --> 00:05:02,080
what is the what um

138
00:05:02,080 --> 00:05:04,720
what the box is is actually is actually

139
00:05:04,720 --> 00:05:06,720
an earth enclosure which is going to

140
00:05:06,720 --> 00:05:08,800
prevent radio frequency from escaping

141
00:05:08,800 --> 00:05:10,400
and is going to prevent

142
00:05:10,400 --> 00:05:11,840
interfering

143
00:05:11,840 --> 00:05:12,720
um

144
00:05:12,720 --> 00:05:15,199
with legitimacy or communications inside

145
00:05:15,199 --> 00:05:17,919
it i have the machine the power supply

146
00:05:17,919 --> 00:05:19,759
unit had to be stripped because i could

147
00:05:19,759 --> 00:05:22,639
only drive up to 50 volts

148
00:05:22,639 --> 00:05:25,280
inside the inside the earth enclosure so

149
00:05:25,280 --> 00:05:26,400
i had to

150
00:05:26,400 --> 00:05:28,560
take the the power supply unit of the

151
00:05:28,560 --> 00:05:30,479
dell machine and put it outside driving

152
00:05:30,479 --> 00:05:32,639
just a few cables inside there's also a

153
00:05:32,639 --> 00:05:35,759
usrp b200 which is an sdr device a

154
00:05:35,759 --> 00:05:39,120
software defined radio peripheral and

155
00:05:39,120 --> 00:05:41,280
right next to it there is the target

156
00:05:41,280 --> 00:05:42,880
phone um

157
00:05:42,880 --> 00:05:44,960
under the phone there is a fan because

158
00:05:44,960 --> 00:05:48,080
inside here it gets pretty pretty hot

159
00:05:48,080 --> 00:05:49,919
especially when it runs for a long time

160
00:05:49,919 --> 00:05:53,120
so it is it does need to be cooled down

161
00:05:53,120 --> 00:05:56,000
and this is what it looks like um at a

162
00:05:56,000 --> 00:05:56,800
very

163
00:05:56,800 --> 00:05:58,960
you know in very abstract terms

164
00:05:58,960 --> 00:05:59,759
um

165
00:05:59,759 --> 00:06:02,080
so the digital machine is running ubuntu

166
00:06:02,080 --> 00:06:03,600
1204

167
00:06:03,600 --> 00:06:06,160
and is running open bts open bts is

168
00:06:06,160 --> 00:06:09,360
going to be the base station software

169
00:06:09,360 --> 00:06:12,400
openvts is directly controlling our usrp

170
00:06:12,400 --> 00:06:14,160
and we are also controlling the test

171
00:06:14,160 --> 00:06:17,120
phone through uh through adb

172
00:06:17,120 --> 00:06:19,280
uh the usrp and the test phone are

173
00:06:19,280 --> 00:06:22,000
obviously going to be talking using uh

174
00:06:22,000 --> 00:06:23,520
over gsm

175
00:06:23,520 --> 00:06:25,840
and this all is going to be controlled

176
00:06:25,840 --> 00:06:27,840
by another machine that is sitting

177
00:06:27,840 --> 00:06:31,199
outside of the of the earth enclosure

178
00:06:31,199 --> 00:06:32,960
and it's going to be communicating over

179
00:06:32,960 --> 00:06:35,759
a version over serial connection the

180
00:06:35,759 --> 00:06:37,120
reason to use a zero connection instead

181
00:06:37,120 --> 00:06:38,479
of anything else

182
00:06:38,479 --> 00:06:40,639
is that this earth enclosure is really

183
00:06:40,639 --> 00:06:42,160
good at something this is isolating

184
00:06:42,160 --> 00:06:44,160
radio frequency and therefore i could

185
00:06:44,160 --> 00:06:46,639
not drive an ethernet connection through

186
00:06:46,639 --> 00:06:47,520
it

187
00:06:47,520 --> 00:06:50,000
because their capacitor separating the

188
00:06:50,000 --> 00:06:52,080
inside and the outside so the so the

189
00:06:52,080 --> 00:06:53,680
signal would

190
00:06:53,680 --> 00:06:56,319
would get too attenuated

191
00:06:56,319 --> 00:06:57,280
so

192
00:06:57,280 --> 00:06:59,599
right now we are done with cellular

193
00:06:59,599 --> 00:07:01,440
setup and let's take a look at how we

194
00:07:01,440 --> 00:07:02,720
can actually

195
00:07:02,720 --> 00:07:04,720
find the firmware and the or the os

196
00:07:04,720 --> 00:07:07,360
binary for this for this box

197
00:07:07,360 --> 00:07:10,319
it turns to be stored in the file system

198
00:07:10,319 --> 00:07:12,240
it's really easy to fetch it

199
00:07:12,240 --> 00:07:14,960
and this image

200
00:07:14,960 --> 00:07:17,520
is designed to load at positions here in

201
00:07:17,520 --> 00:07:19,599
the basement processor memory and as

202
00:07:19,599 --> 00:07:21,759
such because there is no encryption or

203
00:07:21,759 --> 00:07:23,360
whatever it can be directly loaded into

204
00:07:23,360 --> 00:07:24,479
airport

205
00:07:24,479 --> 00:07:25,680
um it is

206
00:07:25,680 --> 00:07:27,520
some reason some reverse engineering

207
00:07:27,520 --> 00:07:29,759
showed that it's actually based on

208
00:07:29,759 --> 00:07:31,840
nucleus plus which as you might know is

209
00:07:31,840 --> 00:07:34,240
a real time prevent preemptive operating

210
00:07:34,240 --> 00:07:35,120
system

211
00:07:35,120 --> 00:07:37,440
it is written in c and there's quite a

212
00:07:37,440 --> 00:07:39,680
lot of documentation available online so

213
00:07:39,680 --> 00:07:40,720
it's um

214
00:07:40,720 --> 00:07:42,720
it's really easy to reverse engineer

215
00:07:42,720 --> 00:07:45,199
what mediatek built into this

216
00:07:45,199 --> 00:07:47,039
this source code also turns out to be

217
00:07:47,039 --> 00:07:48,639
partially available online for unknown

218
00:07:48,639 --> 00:07:52,080
reasons so that is that is even better

219
00:07:52,080 --> 00:07:54,080
now that we have the basement firmware

220
00:07:54,080 --> 00:07:55,599
and the os binary

221
00:07:55,599 --> 00:07:56,879
we are going to take a look at how we

222
00:07:56,879 --> 00:07:59,759
can find debugging symbols this can also

223
00:07:59,759 --> 00:08:02,479
be found in the this can also be found

224
00:08:02,479 --> 00:08:04,080
in the file system it's really easy to

225
00:08:04,080 --> 00:08:05,919
find them and they're directly loadable

226
00:08:05,919 --> 00:08:07,360
into anapra

227
00:08:07,360 --> 00:08:09,039
with com with the script that the guys

228
00:08:09,039 --> 00:08:10,479
had consequences

229
00:08:10,479 --> 00:08:12,400
developed and by the way the rest of

230
00:08:12,400 --> 00:08:15,520
this research builds upon path of least

231
00:08:15,520 --> 00:08:18,000
resistance by consequence which is a an

232
00:08:18,000 --> 00:08:19,840
excellent piece of research and a really

233
00:08:19,840 --> 00:08:22,560
good point to get started

234
00:08:22,560 --> 00:08:24,960
so now that we have this really brief

235
00:08:24,960 --> 00:08:27,440
interaction to baseband and how we're

236
00:08:27,440 --> 00:08:29,120
going to start with it we're going to

237
00:08:29,120 --> 00:08:31,680
get to the debugger

238
00:08:31,680 --> 00:08:34,240
we want to build a debugger and we want

239
00:08:34,240 --> 00:08:35,679
to be able to do these things we want to

240
00:08:35,679 --> 00:08:37,039
be able to read memory we want to be

241
00:08:37,039 --> 00:08:39,519
able to read registers write memory at

242
00:08:39,519 --> 00:08:41,440
breakpoints and after adding breakpoints

243
00:08:41,440 --> 00:08:44,480
we also want to be able to remove them

244
00:08:44,480 --> 00:08:46,640
so to do this we need to take the

245
00:08:46,640 --> 00:08:48,880
following steps so we first need to

246
00:08:48,880 --> 00:08:50,720
choose how we're going to

247
00:08:50,720 --> 00:08:51,920
get the

248
00:08:51,920 --> 00:08:53,120
base button processor and the

249
00:08:53,120 --> 00:08:55,279
application processor to communicate

250
00:08:55,279 --> 00:08:56,240
and

251
00:08:56,240 --> 00:08:58,640
for this we have multiple options we can

252
00:08:58,640 --> 00:09:00,800
choose between 80 commands and share

253
00:09:00,800 --> 00:09:02,480
memory interfaces

254
00:09:02,480 --> 00:09:04,880
um 80 commands as you might probably

255
00:09:04,880 --> 00:09:06,720
know make use of the serial interface

256
00:09:06,720 --> 00:09:08,160
between the baseband processor and the

257
00:09:08,160 --> 00:09:10,240
application processor

258
00:09:10,240 --> 00:09:12,160
therefore are synchronous and they're

259
00:09:12,160 --> 00:09:14,080
quite well documented meaning that there

260
00:09:14,080 --> 00:09:14,959
are

261
00:09:14,959 --> 00:09:16,720
lengthy pdfs

262
00:09:16,720 --> 00:09:19,200
documented the documenting the

263
00:09:19,200 --> 00:09:21,440
at command set supported by the

264
00:09:21,440 --> 00:09:22,640
by the

265
00:09:22,640 --> 00:09:25,440
by the basement chip in question

266
00:09:25,440 --> 00:09:26,959
um

267
00:09:26,959 --> 00:09:28,480
there's also share memory which is

268
00:09:28,480 --> 00:09:30,320
pretty undocumented and it's used

269
00:09:30,320 --> 00:09:32,000
primarily by the radio interface layer

270
00:09:32,000 --> 00:09:35,279
demon so we're not going to go for

271
00:09:35,279 --> 00:09:37,040
share memory we're going to go for 80

272
00:09:37,040 --> 00:09:39,360
commands and our strategy is going to be

273
00:09:39,360 --> 00:09:41,279
to find an at command that is not used

274
00:09:41,279 --> 00:09:44,480
and overwrite this command handler with

275
00:09:44,480 --> 00:09:46,160
some sort of debugging stuff the

276
00:09:46,160 --> 00:09:47,760
debugging debugger stuff that we're

277
00:09:47,760 --> 00:09:51,600
going to be building um to send 80

278
00:09:51,600 --> 00:09:53,680
commands on a mediatek phone

279
00:09:53,680 --> 00:09:56,480
um i found out that there's slash dev

280
00:09:56,480 --> 00:09:58,800
slash tti c0 which is the

281
00:09:58,800 --> 00:10:00,160
serial interface between the baseband

282
00:10:00,160 --> 00:10:01,760
processor and the application processor

283
00:10:01,760 --> 00:10:04,320
however the gsm multiplexer daemon is

284
00:10:04,320 --> 00:10:06,240
permanently attached which makes it

285
00:10:06,240 --> 00:10:08,399
useless however the

286
00:10:08,399 --> 00:10:10,720
multiplexer daemon exposes slash dev

287
00:10:10,720 --> 00:10:13,600
slash radio slash atc 1 which stands for

288
00:10:13,600 --> 00:10:15,440
at command interface 1.

289
00:10:15,440 --> 00:10:18,959
we can just echo our 80 commands to it

290
00:10:18,959 --> 00:10:20,320
but of course as you might have guessed

291
00:10:20,320 --> 00:10:22,240
there are better solutions

292
00:10:22,240 --> 00:10:25,440
if we take a look at logcat while we are

293
00:10:25,440 --> 00:10:28,000
issuing our 80 commands it turns out

294
00:10:28,000 --> 00:10:29,120
that

295
00:10:29,120 --> 00:10:31,279
the radio interface layer demon writes

296
00:10:31,279 --> 00:10:33,440
unsolicited input

297
00:10:33,440 --> 00:10:36,240
unsolicited at command output directly

298
00:10:36,240 --> 00:10:38,720
to logcat so we can either grip it or

299
00:10:38,720 --> 00:10:41,279
even better we can install a p-trace

300
00:10:41,279 --> 00:10:42,240
hook

301
00:10:42,240 --> 00:10:45,839
into the radio interface layer demon

302
00:10:45,839 --> 00:10:48,640
to patch a single call to this android

303
00:10:48,640 --> 00:10:51,440
print to intercept whatever was meant to

304
00:10:51,440 --> 00:10:54,079
be written into logcat

305
00:10:54,079 --> 00:10:56,880
um now that we have chosen how

306
00:10:56,880 --> 00:10:58,720
we are going to communicate

307
00:10:58,720 --> 00:11:00,640
between uh where how the communication

308
00:11:00,640 --> 00:11:01,839
between the application processor and

309
00:11:01,839 --> 00:11:03,440
the basement processor are going to take

310
00:11:03,440 --> 00:11:04,240
place

311
00:11:04,240 --> 00:11:07,680
we need to choose a debugging mode uh we

312
00:11:07,680 --> 00:11:09,519
and we need to design between paradigms

313
00:11:09,519 --> 00:11:10,959
we have to decide between holding mode

314
00:11:10,959 --> 00:11:12,880
and monitor mode if we're debugging in

315
00:11:12,880 --> 00:11:15,040
halting mode this cpu the processor in

316
00:11:15,040 --> 00:11:16,640
question is going to be stopped

317
00:11:16,640 --> 00:11:19,200
completely while we're debugging a task

318
00:11:19,200 --> 00:11:21,200
and if we choose to debug it in monitor

319
00:11:21,200 --> 00:11:23,040
mode this cpu is going to maintain

320
00:11:23,040 --> 00:11:24,720
functionality we have different

321
00:11:24,720 --> 00:11:26,079
constraints here

322
00:11:26,079 --> 00:11:28,480
as you as already as i already mentioned

323
00:11:28,480 --> 00:11:30,160
nucleus plus is a real-time operating

324
00:11:30,160 --> 00:11:33,040
system and it has a number of and it has

325
00:11:33,040 --> 00:11:35,600
a number of tasks running these tasks

326
00:11:35,600 --> 00:11:37,920
need to need to continue running as long

327
00:11:37,920 --> 00:11:39,600
as we are as long as the base panel is

328
00:11:39,600 --> 00:11:42,160
working because otherwise we would be

329
00:11:42,160 --> 00:11:45,680
interrupting baseband and we would be

330
00:11:45,680 --> 00:11:47,680
interrupting cellular communication we

331
00:11:47,680 --> 00:11:49,760
really don't want that and on top of

332
00:11:49,760 --> 00:11:51,279
that the communication

333
00:11:51,279 --> 00:11:52,399
between the

334
00:11:52,399 --> 00:11:53,760
between the application processor and

335
00:11:53,760 --> 00:11:56,160
the basement processor as we decide is

336
00:11:56,160 --> 00:11:58,399
going to be done with 80 commands and

337
00:11:58,399 --> 00:12:00,240
therefore we do need the baseband to

338
00:12:00,240 --> 00:12:02,480
cooperate with us therefore

339
00:12:02,480 --> 00:12:04,480
i ended up choosing monitor mode but

340
00:12:04,480 --> 00:12:05,839
this is not going to be very important

341
00:12:05,839 --> 00:12:09,279
until we're dealing with breakpoints

342
00:12:09,600 --> 00:12:12,000
so now that we can get

343
00:12:12,000 --> 00:12:14,320
we have made some key decisions

344
00:12:14,320 --> 00:12:16,720
we are going to um

345
00:12:16,720 --> 00:12:19,360
first try to patch this firmware

346
00:12:19,360 --> 00:12:21,360
to pass the string from the baseband

347
00:12:21,360 --> 00:12:23,519
process to the application processor we

348
00:12:23,519 --> 00:12:25,600
chose the ati command

349
00:12:25,600 --> 00:12:28,000
and i found out that

350
00:12:28,000 --> 00:12:30,880
the handler for this for this h command

351
00:12:30,880 --> 00:12:34,240
is is in the functionary eta handler

352
00:12:34,240 --> 00:12:36,160
which permanently sits as the in this

353
00:12:36,160 --> 00:12:39,839
address as there is no slr whatsoever

354
00:12:39,839 --> 00:12:41,040
the

355
00:12:41,040 --> 00:12:43,519
mm-iit handler function looks like this

356
00:12:43,519 --> 00:12:45,120
there are two interesting function calls

357
00:12:45,120 --> 00:12:47,600
right here are my fast string print

358
00:12:47,600 --> 00:12:50,000
which kind of which is lumiere to printf

359
00:12:50,000 --> 00:12:52,880
and rmi to uart what is happening here

360
00:12:52,880 --> 00:12:54,240
is that some information about the

361
00:12:54,240 --> 00:12:55,920
baseband is being grabbed is being

362
00:12:55,920 --> 00:12:57,839
passed to remember my fastest string

363
00:12:57,839 --> 00:12:59,760
print and finally i remember i write to

364
00:12:59,760 --> 00:13:00,720
you art

365
00:13:00,720 --> 00:13:02,560
and i remember right to ur that's

366
00:13:02,560 --> 00:13:05,360
exactly what you think it does it sends

367
00:13:05,360 --> 00:13:08,880
um it sends some string over the serial

368
00:13:08,880 --> 00:13:11,760
connection uh to the to the application

369
00:13:11,760 --> 00:13:13,760
processor so our strategy right here is

370
00:13:13,760 --> 00:13:15,440
going to be to make some room in this

371
00:13:15,440 --> 00:13:18,000
stack uh you know in the past that we're

372
00:13:18,000 --> 00:13:19,279
going to develop

373
00:13:19,279 --> 00:13:20,720
and we're going to be calling in my

374
00:13:20,720 --> 00:13:22,720
right ur to pass a custom string

375
00:13:22,720 --> 00:13:24,880
whatever we want back to the basement

376
00:13:24,880 --> 00:13:26,160
back to the application processor the

377
00:13:26,160 --> 00:13:28,000
string that i chose is going to be ola

378
00:13:28,000 --> 00:13:29,920
which means hello in spanish by the way

379
00:13:29,920 --> 00:13:31,680
so here we're making some room in this

380
00:13:31,680 --> 00:13:32,720
stack

381
00:13:32,720 --> 00:13:36,079
we're configuring r0r1 and r2 with

382
00:13:36,079 --> 00:13:38,399
arguments and we're just loading the

383
00:13:38,399 --> 00:13:40,320
address of our mmi right here into our

384
00:13:40,320 --> 00:13:43,680
six and we're just calling it

385
00:13:43,680 --> 00:13:46,320
um pretty simple so far and the next

386
00:13:46,320 --> 00:13:48,800
step knowing that we can just send data

387
00:13:48,800 --> 00:13:50,880
we are going to

388
00:13:50,880 --> 00:13:52,959
figure out if we can pass an actual

389
00:13:52,959 --> 00:13:55,760
datum an actual hexadecimal value and an

390
00:13:55,760 --> 00:13:57,519
integer from the baseband processor to

391
00:13:57,519 --> 00:13:59,519
the application processor

392
00:13:59,519 --> 00:14:00,880
in this case

393
00:14:00,880 --> 00:14:02,480
we're going to try to read a single

394
00:14:02,480 --> 00:14:05,120
register for example so this strategy

395
00:14:05,120 --> 00:14:07,519
here is going to be to make some room in

396
00:14:07,519 --> 00:14:09,120
this tag once again

397
00:14:09,120 --> 00:14:10,560
and instead of calling i remember my

398
00:14:10,560 --> 00:14:12,240
right ur directly we're going to first

399
00:14:12,240 --> 00:14:14,000
call sprintf

400
00:14:14,000 --> 00:14:16,800
passing a format specifier um

401
00:14:16,800 --> 00:14:19,040
that consists of percentage x c or z or

402
00:14:19,040 --> 00:14:20,959
zero zero to convert this datum into a

403
00:14:20,959 --> 00:14:24,000
string this is first year c programming

404
00:14:24,000 --> 00:14:24,880
um

405
00:14:24,880 --> 00:14:28,399
and i did observe that if the datum's

406
00:14:28,399 --> 00:14:31,440
first byte is zero zero there's a crash

407
00:14:31,440 --> 00:14:33,199
rather than looking into the into the

408
00:14:33,199 --> 00:14:35,360
root cause for this i decided to work

409
00:14:35,360 --> 00:14:37,760
around it and i did this

410
00:14:37,760 --> 00:14:39,839
by uh checking whether or not the

411
00:14:39,839 --> 00:14:42,720
datum's first most significant byte is

412
00:14:42,720 --> 00:14:44,880
set to zero zero and apply a different

413
00:14:44,880 --> 00:14:49,199
format specifier whether it is or not

414
00:14:49,199 --> 00:14:51,440
finally we call air memory to yard to

415
00:14:51,440 --> 00:14:52,959
return this string to the application

416
00:14:52,959 --> 00:14:54,959
processor and this is what the patch

417
00:14:54,959 --> 00:14:56,880
looks like if this is the mystery

418
00:14:56,880 --> 00:14:58,959
argument that we want to send we're just

419
00:14:58,959 --> 00:15:00,800
going to load it

420
00:15:00,800 --> 00:15:03,680
um we're just going to

421
00:15:03,680 --> 00:15:06,320
call sprintf to create a string in the

422
00:15:06,320 --> 00:15:09,760
stack right here at sp plus 0x4

423
00:15:09,760 --> 00:15:11,680
where it's going this is going to be

424
00:15:11,680 --> 00:15:14,560
where our

425
00:15:14,560 --> 00:15:16,800
our return string is going to be placed

426
00:15:16,800 --> 00:15:19,600
we're going to call sprintf right here

427
00:15:19,600 --> 00:15:22,160
um and with the result string we're

428
00:15:22,160 --> 00:15:24,639
going to call him right you are again

429
00:15:24,639 --> 00:15:27,199
passing the string that we just created

430
00:15:27,199 --> 00:15:28,560
this is really simple and by the way

431
00:15:28,560 --> 00:15:30,720
this is going to be what it would look

432
00:15:30,720 --> 00:15:34,240
like graphically in the in the baseband

433
00:15:34,240 --> 00:15:34,959
uh

434
00:15:34,959 --> 00:15:37,680
in the baseband memory so as you can see

435
00:15:37,680 --> 00:15:39,519
this is what we overwrote

436
00:15:39,519 --> 00:15:40,560
and

437
00:15:40,560 --> 00:15:42,720
this is going to be our this is going to

438
00:15:42,720 --> 00:15:44,320
be our patch and as you can see it is

439
00:15:44,320 --> 00:15:46,800
returning prematurely without executing

440
00:15:46,800 --> 00:15:50,240
the rest of what we did not patch

441
00:15:50,240 --> 00:15:53,680
um now that we can patch the firmware to

442
00:15:53,680 --> 00:15:55,360
pass data from the baseband processor

443
00:15:55,360 --> 00:15:58,000
let's see what if we can do the opposite

444
00:15:58,000 --> 00:15:59,839
let's see if we can pass some data from

445
00:15:59,839 --> 00:16:01,040
the application processor to the

446
00:16:01,040 --> 00:16:02,639
baseband processor

447
00:16:02,639 --> 00:16:03,440
and

448
00:16:03,440 --> 00:16:05,199
fortunately thanks to the previous patch

449
00:16:05,199 --> 00:16:06,800
i observed that it was it is now

450
00:16:06,800 --> 00:16:08,800
possible to read registers and i did

451
00:16:08,800 --> 00:16:11,600
observe that r1 contains a pointer to

452
00:16:11,600 --> 00:16:13,360
the 80 command pass to the 80 command

453
00:16:13,360 --> 00:16:16,320
passes the string that was the string

454
00:16:16,320 --> 00:16:17,839
that represents the 80 command that we

455
00:16:17,839 --> 00:16:19,040
just passed

456
00:16:19,040 --> 00:16:21,600
um so it is very simple once again we

457
00:16:21,600 --> 00:16:23,199
can call atoy

458
00:16:23,199 --> 00:16:25,600
to parse the decimal string

459
00:16:25,600 --> 00:16:28,480
that follows the string ati so

460
00:16:28,480 --> 00:16:31,360
after ati there would be a number and we

461
00:16:31,360 --> 00:16:33,440
can just call atoy on that number

462
00:16:33,440 --> 00:16:37,279
following the string ati um we can call

463
00:16:37,279 --> 00:16:38,959
sprintf once again

464
00:16:38,959 --> 00:16:41,199
and if we call air memory to ur we can

465
00:16:41,199 --> 00:16:43,040
get the baseband to echo

466
00:16:43,040 --> 00:16:46,079
whatever we just sent to it

467
00:16:46,079 --> 00:16:47,199
however

468
00:16:47,199 --> 00:16:48,880
with what we're just one instruction

469
00:16:48,880 --> 00:16:51,120
away from being able to read the whole

470
00:16:51,120 --> 00:16:53,360
baseband memory as with this integer

471
00:16:53,360 --> 00:16:54,720
that we just managed to pass to the

472
00:16:54,720 --> 00:16:57,600
baseband we can index memory

473
00:16:57,600 --> 00:16:59,920
so if we use the parse integer

474
00:16:59,920 --> 00:17:02,480
parsed by atoy to index memory

475
00:17:02,480 --> 00:17:05,039
we can just read whatever there is in

476
00:17:05,039 --> 00:17:07,679
the basement here i'm fetching

477
00:17:07,679 --> 00:17:09,599
the 80 command

478
00:17:09,599 --> 00:17:11,599
the 80 command string which is pointed

479
00:17:11,599 --> 00:17:13,839
which is now going to be pointed to by

480
00:17:13,839 --> 00:17:15,280
r0

481
00:17:15,280 --> 00:17:16,959
i am

482
00:17:16,959 --> 00:17:18,480
calling atoy right here

483
00:17:18,480 --> 00:17:19,839
i am

484
00:17:19,839 --> 00:17:21,039
then

485
00:17:21,039 --> 00:17:23,599
applying a different form a specifier uh

486
00:17:23,599 --> 00:17:24,559
depending on whether the most

487
00:17:24,559 --> 00:17:27,280
significant byte is set to 0 or not

488
00:17:27,280 --> 00:17:29,840
i'm going to call s printf once again

489
00:17:29,840 --> 00:17:31,039
and i

490
00:17:31,039 --> 00:17:33,840
send back whatever came out of sprintf

491
00:17:33,840 --> 00:17:37,120
back to the application processor

492
00:17:37,120 --> 00:17:39,600
we can now read the whole basement

493
00:17:39,600 --> 00:17:41,360
memory

494
00:17:41,360 --> 00:17:42,880
however writing memory is a different

495
00:17:42,880 --> 00:17:45,280
business we will have to disable some

496
00:17:45,280 --> 00:17:47,120
memory protections

497
00:17:47,120 --> 00:17:48,000
and

498
00:17:48,000 --> 00:17:48,880
these

499
00:17:48,880 --> 00:17:52,160
memory protections come in two different

500
00:17:52,160 --> 00:17:54,160
in two different flavors their memory

501
00:17:54,160 --> 00:17:56,240
protection set by the basement processor

502
00:17:56,240 --> 00:17:58,400
firmware on its own memory

503
00:17:58,400 --> 00:18:00,559
and this strategy is going to be to deal

504
00:18:00,559 --> 00:18:01,600
with this

505
00:18:01,600 --> 00:18:04,080
by patching the firmware once again

506
00:18:04,080 --> 00:18:06,240
um there are also memory protection set

507
00:18:06,240 --> 00:18:08,960
by the application perceptron startup

508
00:18:08,960 --> 00:18:11,679
and to undo this we are going to load a

509
00:18:11,679 --> 00:18:15,520
kernel object into the host kernel to

510
00:18:15,520 --> 00:18:18,320
undo basically what the what the kernel

511
00:18:18,320 --> 00:18:22,480
did to us on baseband processor startup

512
00:18:22,480 --> 00:18:25,200
um it turns out that the baseband uh

513
00:18:25,200 --> 00:18:28,880
firmware sets season mpu at the function

514
00:18:28,880 --> 00:18:31,440
mpu underscore in it

515
00:18:31,440 --> 00:18:33,760
and this is done by several calls to mpu

516
00:18:33,760 --> 00:18:36,160
automate region and mpu make region

517
00:18:36,160 --> 00:18:39,360
which if we reverse engineer them it

518
00:18:39,360 --> 00:18:40,559
turns out that they are actually

519
00:18:40,559 --> 00:18:42,799
programming the mpu programming

520
00:18:42,799 --> 00:18:43,919
registers

521
00:18:43,919 --> 00:18:46,400
i reverse engineer this course and it

522
00:18:46,400 --> 00:18:48,720
turns out that there are nine of them

523
00:18:48,720 --> 00:18:50,400
and these are the

524
00:18:50,400 --> 00:18:52,559
these are the memory regions that are

525
00:18:52,559 --> 00:18:53,760
defined

526
00:18:53,760 --> 00:18:56,320
with the respective protection flags

527
00:18:56,320 --> 00:18:57,360
we

528
00:18:57,360 --> 00:19:00,080
have specifically we have issues with

529
00:19:00,080 --> 00:19:02,080
the region number six run region number

530
00:19:02,080 --> 00:19:04,720
seven and region number eight so to undo

531
00:19:04,720 --> 00:19:07,120
them we are going to overwrite

532
00:19:07,120 --> 00:19:09,919
the instructions setting um the

533
00:19:09,919 --> 00:19:12,799
protection flux into the r2 register

534
00:19:12,799 --> 00:19:15,120
which is later going to be used

535
00:19:15,120 --> 00:19:17,520
to program mpu registers we're just

536
00:19:17,520 --> 00:19:20,000
going to override it with an instruction

537
00:19:20,000 --> 00:19:20,799
that

538
00:19:20,799 --> 00:19:23,679
sets a different value in

539
00:19:23,679 --> 00:19:25,120
in r2

540
00:19:25,120 --> 00:19:27,919
uh so to deal with uh regions six and

541
00:19:27,919 --> 00:19:31,200
seven we're just going to relax the

542
00:19:31,200 --> 00:19:33,679
we're going to configure r2 with a

543
00:19:33,679 --> 00:19:34,960
different protection flag that is going

544
00:19:34,960 --> 00:19:38,559
to just disable uh the right protection

545
00:19:38,559 --> 00:19:41,440
and the same applies for region number

546
00:19:41,440 --> 00:19:43,200
eight

547
00:19:43,200 --> 00:19:44,880
now that we have disabled the baseband

548
00:19:44,880 --> 00:19:47,760
processor memory protection

549
00:19:47,760 --> 00:19:50,559
i was trying to

550
00:19:50,559 --> 00:19:52,640
i was trying to write memory after i had

551
00:19:52,640 --> 00:19:54,799
disabled this but it was for some for

552
00:19:54,799 --> 00:19:57,039
some reason impossible and i did notice

553
00:19:57,039 --> 00:19:59,520
on the message during the during the

554
00:19:59,520 --> 00:20:01,360
baseband process of restart

555
00:20:01,360 --> 00:20:04,640
that this was being uh this was this was

556
00:20:04,640 --> 00:20:05,760
being

557
00:20:05,760 --> 00:20:07,360
this was being locked

558
00:20:07,360 --> 00:20:09,600
uh this led me to believe that the

559
00:20:09,600 --> 00:20:12,159
kernel is setting up some um

560
00:20:12,159 --> 00:20:14,720
some memory restrictions

561
00:20:14,720 --> 00:20:17,360
and it turns out that this is uh this

562
00:20:17,360 --> 00:20:20,080
this is the case the partial

563
00:20:20,080 --> 00:20:21,360
source code

564
00:20:21,360 --> 00:20:22,799
for um

565
00:20:22,799 --> 00:20:24,880
responsible for loading up the firmware

566
00:20:24,880 --> 00:20:26,880
and starting the baseband processor is

567
00:20:26,880 --> 00:20:29,360
available in github for unknown reasons

568
00:20:29,360 --> 00:20:31,679
and it turns out that indeed there were

569
00:20:31,679 --> 00:20:33,360
two

570
00:20:33,360 --> 00:20:36,000
there are two regions being flagged as

571
00:20:36,000 --> 00:20:36,960
um

572
00:20:36,960 --> 00:20:38,480
there are two reasons being flagged as

573
00:20:38,480 --> 00:20:41,200
read only or forbidden completely

574
00:20:41,200 --> 00:20:43,840
and to deal with this we can just create

575
00:20:43,840 --> 00:20:45,760
our own kernel object

576
00:20:45,760 --> 00:20:47,919
and we can call eminpu's region

577
00:20:47,919 --> 00:20:49,679
protection to

578
00:20:49,679 --> 00:20:51,360
to undo these protections

579
00:20:51,360 --> 00:20:54,000
here you can see that we are programming

580
00:20:54,000 --> 00:20:56,240
um no protection

581
00:20:56,240 --> 00:20:58,559
for both regions that we are interested

582
00:20:58,559 --> 00:21:00,159
in

583
00:21:00,159 --> 00:21:03,280
um now that we have disabled our memory

584
00:21:03,280 --> 00:21:06,000
fractions for the baseband completely

585
00:21:06,000 --> 00:21:08,159
uh we can pretty much write memory uh we

586
00:21:08,159 --> 00:21:10,960
can write wherever we want in the rom

587
00:21:10,960 --> 00:21:12,480
from we can actually instruct the

588
00:21:12,480 --> 00:21:14,400
baseband processor to write wherever we

589
00:21:14,400 --> 00:21:16,799
want in each room

590
00:21:16,799 --> 00:21:19,120
and

591
00:21:20,559 --> 00:21:21,919
now it becomes now

592
00:21:21,919 --> 00:21:24,480
if we want to if we want to write to

593
00:21:24,480 --> 00:21:26,159
executable memory if we are going to

594
00:21:26,159 --> 00:21:28,480
write instructions instruction barriers

595
00:21:28,480 --> 00:21:31,360
to become important at this point

596
00:21:31,360 --> 00:21:35,200
to our final goal of building a debugger

597
00:21:35,200 --> 00:21:37,520
i did i decided to define two new

598
00:21:37,520 --> 00:21:39,360
special memory areas that are going to

599
00:21:39,360 --> 00:21:41,600
be shared between bleed debuggy task and

600
00:21:41,600 --> 00:21:43,280
the debugger task which are going to be

601
00:21:43,280 --> 00:21:45,280
the the value status block

602
00:21:45,280 --> 00:21:49,200
and the register bank so um both of the

603
00:21:49,200 --> 00:21:50,880
both the debugger status block and the

604
00:21:50,880 --> 00:21:52,880
right register bank are shared between

605
00:21:52,880 --> 00:21:54,720
the debugger and the buggy

606
00:21:54,720 --> 00:21:56,960
and the debugger status block is going

607
00:21:56,960 --> 00:21:58,960
to be a set of flags set up by the

608
00:21:58,960 --> 00:22:02,320
debugger for the debugging to act upon

609
00:22:02,320 --> 00:22:04,000
these are going these flags are going to

610
00:22:04,000 --> 00:22:04,799
be

611
00:22:04,799 --> 00:22:07,280
um downfall registers

612
00:22:07,280 --> 00:22:10,400
or remove the breakpoint or whatever

613
00:22:10,400 --> 00:22:12,000
whereas the right register bank is going

614
00:22:12,000 --> 00:22:14,480
to be basically a snapshot of all the

615
00:22:14,480 --> 00:22:17,520
registers uh created by the debuggy for

616
00:22:17,520 --> 00:22:19,600
the debugger to consume and send back to

617
00:22:19,600 --> 00:22:22,000
the application processor

618
00:22:22,000 --> 00:22:25,360
and um now for the not for the real deal

619
00:22:25,360 --> 00:22:27,360
now the most important most difficult

620
00:22:27,360 --> 00:22:31,840
thing we want to set some breakpoints

621
00:22:31,840 --> 00:22:32,880
um

622
00:22:32,880 --> 00:22:33,600
so

623
00:22:33,600 --> 00:22:35,280
we are going to consider that when we

624
00:22:35,280 --> 00:22:37,120
are debugging a baseband we are going to

625
00:22:37,120 --> 00:22:39,840
have two tasks at any point first the

626
00:22:39,840 --> 00:22:42,240
debuggy task is going the debugger task

627
00:22:42,240 --> 00:22:44,240
is going to be the 80 command handler

628
00:22:44,240 --> 00:22:46,480
that we just overwrought

629
00:22:46,480 --> 00:22:48,960
and it's going to influence the debuggy

630
00:22:48,960 --> 00:22:49,840
task

631
00:22:49,840 --> 00:22:53,840
this is going to be doing it in two ways

632
00:22:53,840 --> 00:22:55,760
first off is going to be setting flux in

633
00:22:55,760 --> 00:22:57,520
the debugger status block for the

634
00:22:57,520 --> 00:23:00,000
debuggy task to act upon

635
00:23:00,000 --> 00:23:03,919
and most importantly is going to replace

636
00:23:03,919 --> 00:23:05,919
any instruction that is going to

637
00:23:05,919 --> 00:23:08,559
hopefully be executed by the debagitas

638
00:23:08,559 --> 00:23:10,240
with a breakpoint

639
00:23:10,240 --> 00:23:12,159
the debugging task is going to be any

640
00:23:12,159 --> 00:23:15,360
other and is going to be stuck in an

641
00:23:15,360 --> 00:23:18,000
active weight loop

642
00:23:18,000 --> 00:23:20,000
when a breakpoint when a breakpoint is

643
00:23:20,000 --> 00:23:21,280
encountered

644
00:23:21,280 --> 00:23:24,080
in this loop it one is going to want to

645
00:23:24,080 --> 00:23:26,400
read the flag set by the debuggie but

646
00:23:26,400 --> 00:23:28,640
set by debugger and act appropriately on

647
00:23:28,640 --> 00:23:31,200
them so for example if the debugger

648
00:23:31,200 --> 00:23:33,840
instructed the debuggy to dump its

649
00:23:33,840 --> 00:23:36,720
registers it's going to do so and if the

650
00:23:36,720 --> 00:23:40,240
debugger instructs it by key to replace

651
00:23:40,240 --> 00:23:42,000
its own trap instruction on breakpoint

652
00:23:42,000 --> 00:23:44,880
removal is also going to do sorry

653
00:23:44,880 --> 00:23:47,039
the breakpoint instruction that we are

654
00:23:47,039 --> 00:23:50,240
using is software interrupt swi also

655
00:23:50,240 --> 00:23:52,080
known as svc

656
00:23:52,080 --> 00:23:54,000
and it's kind of similar to the x86 or

657
00:23:54,000 --> 00:23:56,799
x64 instruction

658
00:23:56,799 --> 00:23:58,720
and when executed

659
00:23:58,720 --> 00:24:00,559
the processor operating mode is going to

660
00:24:00,559 --> 00:24:04,400
become supervisor or svc and is going to

661
00:24:04,400 --> 00:24:07,360
an execution is going to be resumed at

662
00:24:07,360 --> 00:24:08,720
the address

663
00:24:08,720 --> 00:24:09,760
fetched

664
00:24:09,760 --> 00:24:11,679
from the interrupt vector table

665
00:24:11,679 --> 00:24:13,679
corresponding to

666
00:24:13,679 --> 00:24:17,200
corresponding to the svc handler

667
00:24:17,200 --> 00:24:19,760
in memory is going to look like this so

668
00:24:19,760 --> 00:24:22,559
if this is our debuggie task when it

669
00:24:22,559 --> 00:24:24,640
hits a breakpoint it's going to be stuck

670
00:24:24,640 --> 00:24:26,000
in a loop

671
00:24:26,000 --> 00:24:27,440
and it's going to be acquiring the

672
00:24:27,440 --> 00:24:29,520
debugger status block that is going to

673
00:24:29,520 --> 00:24:30,840
be set by the

674
00:24:30,840 --> 00:24:33,919
debugger for actions to take for weather

675
00:24:33,919 --> 00:24:37,679
to for whether for instructions

676
00:24:38,080 --> 00:24:40,320
and is going to fulfill those by writing

677
00:24:40,320 --> 00:24:42,000
back into the

678
00:24:42,000 --> 00:24:43,440
into the

679
00:24:43,440 --> 00:24:46,400
red register bank or is going to fulfill

680
00:24:46,400 --> 00:24:48,640
them by removing it if by removing its

681
00:24:48,640 --> 00:24:50,640
own breakpoint if instructed

682
00:24:50,640 --> 00:24:52,720
after the

683
00:24:52,720 --> 00:24:55,520
after the loop is finished when the

684
00:24:55,520 --> 00:24:56,960
when the breakpoint is finally removed

685
00:24:56,960 --> 00:24:59,840
it's going to want to jump back to the

686
00:24:59,840 --> 00:25:01,360
to the original breakpoint instruction

687
00:25:01,360 --> 00:25:04,400
that will now have to be replaced by the

688
00:25:04,400 --> 00:25:06,240
original instruction

689
00:25:06,240 --> 00:25:08,799
we need to take into account that in arm

690
00:25:08,799 --> 00:25:11,120
we have two instructions set

691
00:25:11,120 --> 00:25:12,960
these are arm and thumb

692
00:25:12,960 --> 00:25:14,799
and the instruction set in use is always

693
00:25:14,799 --> 00:25:17,039
given by the bit by the bit t of the

694
00:25:17,039 --> 00:25:20,080
current processor status register

695
00:25:20,080 --> 00:25:22,640
and to alternate between these two

696
00:25:22,640 --> 00:25:24,400
instruction encodings

697
00:25:24,400 --> 00:25:25,279
the

698
00:25:25,279 --> 00:25:26,840
branches structure

699
00:25:26,840 --> 00:25:29,600
bx and i think most of the branch

700
00:25:29,600 --> 00:25:32,400
instructions are going to copy the bit 0

701
00:25:32,400 --> 00:25:34,480
of the pc of the program counter to the

702
00:25:34,480 --> 00:25:37,279
current processor status register so for

703
00:25:37,279 --> 00:25:38,960
example if we're jumping from an odd

704
00:25:38,960 --> 00:25:41,120
address to an even address the

705
00:25:41,120 --> 00:25:42,720
instruction setting use changes from

706
00:25:42,720 --> 00:25:45,440
thumb to arm and vice versa there are

707
00:25:45,440 --> 00:25:46,960
some challenges with the proposed

708
00:25:46,960 --> 00:25:49,039
architecture namely

709
00:25:49,039 --> 00:25:52,400
that the breakpoints the loop

710
00:25:52,400 --> 00:25:53,760
representing the breakpoint must

711
00:25:53,760 --> 00:25:55,679
contemplate whether

712
00:25:55,679 --> 00:25:58,159
originally the processor was executing

713
00:25:58,159 --> 00:26:00,320
thumb or arm coil

714
00:26:00,320 --> 00:26:03,120
and finally after

715
00:26:03,120 --> 00:26:06,799
the after the after exiting the

716
00:26:06,799 --> 00:26:08,799
the debugging loop

717
00:26:08,799 --> 00:26:11,360
the original processor mode has to be

718
00:26:11,360 --> 00:26:12,480
restored

719
00:26:12,480 --> 00:26:14,480
meaning that if this processor was in

720
00:26:14,480 --> 00:26:16,720
system mode if it was executing a higher

721
00:26:16,720 --> 00:26:19,039
privilege level it must be it must go

722
00:26:19,039 --> 00:26:19,840
back

723
00:26:19,840 --> 00:26:22,480
into into that original mode

724
00:26:22,480 --> 00:26:25,120
apart from obviously restoring registers

725
00:26:25,120 --> 00:26:28,240
so as not to disturb um the execution of

726
00:26:28,240 --> 00:26:29,679
the original program

727
00:26:29,679 --> 00:26:31,679
on top of that if we're running our

728
00:26:31,679 --> 00:26:34,080
tasks indefinitely in an endless loop

729
00:26:34,080 --> 00:26:36,880
this is going to result in uh in

730
00:26:36,880 --> 00:26:38,960
in a starvation scenario which

731
00:26:38,960 --> 00:26:41,039
eventually results in a baseband crash

732
00:26:41,039 --> 00:26:43,200
so we need to avoid this somehow

733
00:26:43,200 --> 00:26:45,279
to prevent starvation i had to reverse

734
00:26:45,279 --> 00:26:47,360
engineer the tasks running in nucleus

735
00:26:47,360 --> 00:26:50,240
plus in this mediatek basement firmware

736
00:26:50,240 --> 00:26:51,919
and i found that there are 60 touchs of

737
00:26:51,919 --> 00:26:53,840
them the way it works

738
00:26:53,840 --> 00:26:56,400
is that lower priority tasks cannot

739
00:26:56,400 --> 00:26:58,640
preempt higher priority so if there is a

740
00:26:58,640 --> 00:27:00,880
if there's a high priority task running

741
00:27:00,880 --> 00:27:02,400
it cannot be kicked out by a lower

742
00:27:02,400 --> 00:27:03,679
priority task

743
00:27:03,679 --> 00:27:04,960
and

744
00:27:04,960 --> 00:27:07,919
the issue right here is that our debuggy

745
00:27:07,919 --> 00:27:08,799
task

746
00:27:08,799 --> 00:27:10,960
might have a higher priority that

747
00:27:10,960 --> 00:27:13,679
that the debugger task therefore if the

748
00:27:13,679 --> 00:27:16,240
debuggy task is stuck in an endless loop

749
00:27:16,240 --> 00:27:18,080
in an active weight loop we might not be

750
00:27:18,080 --> 00:27:19,919
able to keep it kick it out as the

751
00:27:19,919 --> 00:27:22,960
scheduler will keep scheduling it

752
00:27:22,960 --> 00:27:26,159
without possibility to breaking the loop

753
00:27:26,159 --> 00:27:29,840
our options to solve this here are to

754
00:27:29,840 --> 00:27:31,840
set the debuggy task to the lower to the

755
00:27:31,840 --> 00:27:34,399
lowest priority possible but this gives

756
00:27:34,399 --> 00:27:38,320
way to many other challenges

757
00:27:38,320 --> 00:27:41,760
and also on top of that other

758
00:27:41,760 --> 00:27:44,320
the correct workings of nucleus plus

759
00:27:44,320 --> 00:27:46,159
might depend on the priorities being

760
00:27:46,159 --> 00:27:47,600
configured

761
00:27:47,600 --> 00:27:49,200
configured correctly

762
00:27:49,200 --> 00:27:50,480
so

763
00:27:50,480 --> 00:27:52,320
the solution in this case is going to be

764
00:27:52,320 --> 00:27:55,200
to sleep before to force the debugging

765
00:27:55,200 --> 00:27:56,799
task to sleep

766
00:27:56,799 --> 00:27:58,880
in a way to force preemption

767
00:27:58,880 --> 00:28:00,559
and we're going to do this by calling

768
00:28:00,559 --> 00:28:02,480
call sleep task which takes a

769
00:28:02,480 --> 00:28:04,159
millisecond value

770
00:28:04,159 --> 00:28:06,799
and the way this works is when

771
00:28:06,799 --> 00:28:09,600
call sleep task is called then tcc task

772
00:28:09,600 --> 00:28:11,039
sleep is called

773
00:28:11,039 --> 00:28:13,360
which does some error checking if no

774
00:28:13,360 --> 00:28:15,360
errors are encountered then tcc called

775
00:28:15,360 --> 00:28:17,840
task sleep is called

776
00:28:17,840 --> 00:28:21,679
and finally tcc task sleep calls tcc

777
00:28:21,679 --> 00:28:24,159
suspend task veneer which effectively

778
00:28:24,159 --> 00:28:26,799
suspends the calling task

779
00:28:26,799 --> 00:28:30,000
for a given number of milliseconds

780
00:28:30,000 --> 00:28:32,720
the issue once again is that call slip

781
00:28:32,720 --> 00:28:36,159
task cannot be called into into svc mode

782
00:28:36,159 --> 00:28:39,279
and we know that every time that the

783
00:28:39,279 --> 00:28:40,399
the

784
00:28:40,399 --> 00:28:42,240
that the software interrupt instruction

785
00:28:42,240 --> 00:28:44,080
that our interrupting instruction is

786
00:28:44,080 --> 00:28:46,240
executed the processor is going to

787
00:28:46,240 --> 00:28:48,880
switch to svc mode

788
00:28:48,880 --> 00:28:50,720
so the solution in this case is going to

789
00:28:50,720 --> 00:28:52,799
be on each iteration of the debugger

790
00:28:52,799 --> 00:28:54,799
loop we are going to change to the

791
00:28:54,799 --> 00:28:57,279
original execution mode

792
00:28:57,279 --> 00:28:58,720
we're going to call

793
00:28:58,720 --> 00:29:00,480
call sleep task

794
00:29:00,480 --> 00:29:03,760
and we're going to then try to jump back

795
00:29:03,760 --> 00:29:05,919
to the original breakpoint address so if

796
00:29:05,919 --> 00:29:07,600
the breakpoint hasn't

797
00:29:07,600 --> 00:29:09,440
yet been removed

798
00:29:09,440 --> 00:29:12,640
then swi is executed again we go back

799
00:29:12,640 --> 00:29:14,399
into the loop

800
00:29:14,399 --> 00:29:16,320
and we execute everything over and over

801
00:29:16,320 --> 00:29:17,360
and over

802
00:29:17,360 --> 00:29:18,880
however if the breakpoint had been

803
00:29:18,880 --> 00:29:20,799
removed the original instruction gets

804
00:29:20,799 --> 00:29:22,880
executed and we continue normally in

805
00:29:22,880 --> 00:29:24,480
sequence

806
00:29:24,480 --> 00:29:26,559
so our strategy for setting a breakpoint

807
00:29:26,559 --> 00:29:28,480
is going to be this we're going to

808
00:29:28,480 --> 00:29:31,360
override the swi handler address

809
00:29:31,360 --> 00:29:32,880
with um

810
00:29:32,880 --> 00:29:34,799
with uh with the address of a function

811
00:29:34,799 --> 00:29:37,360
that we have patched into the firmware

812
00:29:37,360 --> 00:29:39,840
and our breakpoint entry

813
00:29:39,840 --> 00:29:41,679
after swi

814
00:29:41,679 --> 00:29:43,600
instruction the instruction set in use

815
00:29:43,600 --> 00:29:45,760
is going to be rm so we're going to

816
00:29:45,760 --> 00:29:46,799
continue

817
00:29:46,799 --> 00:29:49,760
executing whatever we want into arm

818
00:29:49,760 --> 00:29:53,760
and we're going to use this opportunity

819
00:29:53,760 --> 00:29:55,440
to check the debugger status block to

820
00:29:55,440 --> 00:29:58,000
see what the debugger requested from

821
00:29:58,000 --> 00:30:00,159
from the debuggy and we're going to

822
00:30:00,159 --> 00:30:02,720
fulfill those so if the debugger wants

823
00:30:02,720 --> 00:30:03,440
us

824
00:30:03,440 --> 00:30:05,520
to remove our own breakpoint we're going

825
00:30:05,520 --> 00:30:07,279
to remove it here if the debugger wants

826
00:30:07,279 --> 00:30:08,880
us to dump the registers we're going to

827
00:30:08,880 --> 00:30:10,880
do it here we're going to attempt to

828
00:30:10,880 --> 00:30:12,880
exit the breakpoint

829
00:30:12,880 --> 00:30:14,559
and we're going to take a look at how we

830
00:30:14,559 --> 00:30:16,399
exit the bracket a bit later

831
00:30:16,399 --> 00:30:17,679
however

832
00:30:17,679 --> 00:30:18,559
if

833
00:30:18,559 --> 00:30:21,600
the debugger had instructed the debuggy

834
00:30:21,600 --> 00:30:24,559
to remove its own breakpoint we are

835
00:30:24,559 --> 00:30:26,720
going to patch again

836
00:30:26,720 --> 00:30:29,520
the breakpoint instruction with the with

837
00:30:29,520 --> 00:30:31,120
whatever was

838
00:30:31,120 --> 00:30:32,960
there originally

839
00:30:32,960 --> 00:30:34,240
and

840
00:30:34,240 --> 00:30:36,000
when we are attempting to access the

841
00:30:36,000 --> 00:30:38,480
breakpoint we are going to restore the

842
00:30:38,480 --> 00:30:40,480
operating mode of the processor as well

843
00:30:40,480 --> 00:30:42,000
as the registers

844
00:30:42,000 --> 00:30:44,240
if this was arm

845
00:30:44,240 --> 00:30:46,960
we are going to we're going to

846
00:30:46,960 --> 00:30:49,919
we're going to um well before before we

847
00:30:49,919 --> 00:30:52,000
jump back to the breakpoint address uh

848
00:30:52,000 --> 00:30:54,159
we're going to call cal sleep task

849
00:30:54,159 --> 00:30:57,039
and if we were executing arm we're going

850
00:30:57,039 --> 00:31:00,000
to uh just jump to uh just jump to the

851
00:31:00,000 --> 00:31:02,159
base to the breakpoint address which

852
00:31:02,159 --> 00:31:05,039
should be given by the link register

853
00:31:05,039 --> 00:31:07,120
if it was thumb we just need to

854
00:31:07,120 --> 00:31:10,320
increment the breakpoint address by one

855
00:31:10,320 --> 00:31:12,960
which we just took from lr from the link

856
00:31:12,960 --> 00:31:15,279
register and we're going to just jump to

857
00:31:15,279 --> 00:31:18,320
the incremental link register which is

858
00:31:18,320 --> 00:31:19,760
which is basically going to bring back

859
00:31:19,760 --> 00:31:21,919
the processor into thumb mode

860
00:31:21,919 --> 00:31:25,679
the patch is going to look like this

861
00:31:25,679 --> 00:31:27,360
so the way it works is that when a

862
00:31:27,360 --> 00:31:29,039
breakpoint is hit

863
00:31:29,039 --> 00:31:32,320
the address of our sv modified svc

864
00:31:32,320 --> 00:31:34,080
handler routine is going to be fetched

865
00:31:34,080 --> 00:31:36,240
from the interrupt vector table

866
00:31:36,240 --> 00:31:38,480
and we're going to jump to it

867
00:31:38,480 --> 00:31:41,519
we are going to do whatever the debugger

868
00:31:41,519 --> 00:31:44,159
instructed us to do

869
00:31:44,159 --> 00:31:47,279
um and um we're going to do whatever the

870
00:31:47,279 --> 00:31:49,360
debugger instructor has to do by

871
00:31:49,360 --> 00:31:51,600
checking the contents of the debugger

872
00:31:51,600 --> 00:31:54,799
status blocked and by updating it if

873
00:31:54,799 --> 00:31:56,640
necessary

874
00:31:56,640 --> 00:31:58,480
once we're done with this

875
00:31:58,480 --> 00:32:00,960
we're going to try to jump back

876
00:32:00,960 --> 00:32:02,799
in a way um

877
00:32:02,799 --> 00:32:05,360
in a way that we are re-attempting the

878
00:32:05,360 --> 00:32:06,480
instruction that triggered the

879
00:32:06,480 --> 00:32:08,480
breakpoint after we have called cal

880
00:32:08,480 --> 00:32:10,799
sleep task

881
00:32:10,799 --> 00:32:13,679
and now for my greatest trick i'm going

882
00:32:13,679 --> 00:32:16,159
to try to set a breakpoint

883
00:32:16,159 --> 00:32:19,600
and you in in a live baseball target i'm

884
00:32:19,600 --> 00:32:20,799
going to

885
00:32:20,799 --> 00:32:24,000
try to read a message from memory live

886
00:32:24,000 --> 00:32:25,760
after sending

887
00:32:25,760 --> 00:32:27,279
after sending a

888
00:32:27,279 --> 00:32:29,519
gsm layer 3 message

889
00:32:29,519 --> 00:32:32,000
um there are two important scripts that

890
00:32:32,000 --> 00:32:34,320
we're that we need to be familiar with

891
00:32:34,320 --> 00:32:36,960
let me debug agent new dot py which is

892
00:32:36,960 --> 00:32:40,159
going to be controlling the debugger

893
00:32:40,159 --> 00:32:43,679
via adb via the android debug bridge

894
00:32:43,679 --> 00:32:46,320
um basically uh

895
00:32:46,320 --> 00:32:47,760
debug the

896
00:32:47,760 --> 00:32:49,200
debugger agent

897
00:32:49,200 --> 00:32:51,840
is going to be issuing the 80 commands

898
00:32:51,840 --> 00:32:54,240
that i'm that corresponds to the actions

899
00:32:54,240 --> 00:32:56,480
that i want the debugger to take instead

900
00:32:56,480 --> 00:32:58,799
of me having to craft it manually

901
00:32:58,799 --> 00:33:02,159
final dot py is another is script that

902
00:33:02,159 --> 00:33:03,840
we're going to be using

903
00:33:03,840 --> 00:33:08,000
to deliver a base64 encoded gsm layer 3

904
00:33:08,000 --> 00:33:10,720
message directly to the basement

905
00:33:10,720 --> 00:33:14,240
because we're using openbts here

906
00:33:14,240 --> 00:33:17,760
openbts allows us to open up a test call

907
00:33:17,760 --> 00:33:18,960
which

908
00:33:18,960 --> 00:33:23,039
results in the opening of a udp socket

909
00:33:23,039 --> 00:33:24,880
in the local machine

910
00:33:24,880 --> 00:33:27,279
to which whatever we send is going to

911
00:33:27,279 --> 00:33:30,159
end up being delivered to the layer 3 of

912
00:33:30,159 --> 00:33:31,519
the of the

913
00:33:31,519 --> 00:33:33,360
of the gsm protocol stack in the

914
00:33:33,360 --> 00:33:35,039
basement

915
00:33:35,039 --> 00:33:35,919
um

916
00:33:35,919 --> 00:33:36,880
and

917
00:33:36,880 --> 00:33:39,760
so this this script actually understands

918
00:33:39,760 --> 00:33:42,559
most of uh the most of the assembly r3

919
00:33:42,559 --> 00:33:44,559
messages thanks to this which is a

920
00:33:44,559 --> 00:33:46,240
spreadsheet

921
00:33:46,240 --> 00:33:49,120
uh that i created by

922
00:33:49,120 --> 00:33:50,240
damping

923
00:33:50,240 --> 00:33:53,360
most of the pdf uh specific gsm

924
00:33:53,360 --> 00:33:56,000
specification messages right here and

925
00:33:56,000 --> 00:33:58,640
then parsing it using scapi

926
00:33:58,640 --> 00:34:00,960
um

927
00:34:00,960 --> 00:34:02,880
the final.pyscript is also going to

928
00:34:02,880 --> 00:34:06,559
manage uh openvds startup if we require

929
00:34:06,559 --> 00:34:08,000
it to do so

930
00:34:08,000 --> 00:34:10,560
it's going to check with the association

931
00:34:10,560 --> 00:34:12,719
of the phone to our

932
00:34:12,719 --> 00:34:14,399
malicious space

933
00:34:14,399 --> 00:34:16,800
to our malicious base station and is

934
00:34:16,800 --> 00:34:18,079
going to do

935
00:34:18,079 --> 00:34:21,918
this optionally by by means of uh

936
00:34:21,918 --> 00:34:23,199
by

937
00:34:23,199 --> 00:34:26,239
emulating taps and taking screenshots

938
00:34:26,239 --> 00:34:27,199
um

939
00:34:27,199 --> 00:34:30,000
and before right before the test case is

940
00:34:30,000 --> 00:34:32,639
sent we're going to paint the baseband

941
00:34:32,639 --> 00:34:34,560
over over an attic command we're going

942
00:34:34,560 --> 00:34:36,719
to issue the command 80 to which we

943
00:34:36,719 --> 00:34:39,599
expect to get an okay response

944
00:34:39,599 --> 00:34:41,760
and finally we are going to send this

945
00:34:41,760 --> 00:34:44,000
user message message over

946
00:34:44,000 --> 00:34:46,320
over the layer 3 channel over the test

947
00:34:46,320 --> 00:34:47,520
call

948
00:34:47,520 --> 00:34:49,599
um we are going to be setting a

949
00:34:49,599 --> 00:34:52,399
breakpoint at this address

950
00:34:52,399 --> 00:34:54,719
and we're going to send this test case

951
00:34:54,719 --> 00:34:57,359
which is in coordinate base64 which

952
00:34:57,359 --> 00:35:00,000
corresponds to a mobility management

953
00:35:00,000 --> 00:35:03,200
location update reject we're going to be

954
00:35:03,200 --> 00:35:05,599
reading the registers on the baseband so

955
00:35:05,599 --> 00:35:07,440
the baseband chip live using the

956
00:35:07,440 --> 00:35:10,079
debugger and we're going to be

957
00:35:10,079 --> 00:35:11,920
reading the memory live using the

958
00:35:11,920 --> 00:35:13,280
debugger as well

959
00:35:13,280 --> 00:35:15,839
the test case is this one as i told you

960
00:35:15,839 --> 00:35:17,680
location update reject

961
00:35:17,680 --> 00:35:20,160
the reason why i chose this message is

962
00:35:20,160 --> 00:35:24,160
because we have this reject cross

963
00:35:24,160 --> 00:35:25,599
field right there

964
00:35:25,599 --> 00:35:29,599
and it is um i i can use it to stick in

965
00:35:29,599 --> 00:35:32,400
there whatever i want i decided to stick

966
00:35:32,400 --> 00:35:34,800
in there as they reject close four a's

967
00:35:34,800 --> 00:35:37,760
which are given by these 441 bytes right

968
00:35:37,760 --> 00:35:39,040
there

969
00:35:39,040 --> 00:35:42,400
and because i am interested in verifying

970
00:35:42,400 --> 00:35:45,359
that this debugger works i'm going to

971
00:35:45,359 --> 00:35:48,720
be taking a look at this incoming ilm

972
00:35:48,720 --> 00:35:51,599
struct which is a variable

973
00:35:51,599 --> 00:35:52,640
passed

974
00:35:52,640 --> 00:35:53,839
to this

975
00:35:53,839 --> 00:35:55,040
l3

976
00:35:55,040 --> 00:35:58,400
um to this l3 module by the lower layer

977
00:35:58,400 --> 00:36:00,400
and i'm going to be interested in the

978
00:36:00,400 --> 00:36:02,960
peer buff ptr member

979
00:36:02,960 --> 00:36:06,720
which should contain a pointer to the to

980
00:36:06,720 --> 00:36:09,680
the message that was just received over

981
00:36:09,680 --> 00:36:11,680
over over the earth

982
00:36:11,680 --> 00:36:13,200
because i'm interested in this spear

983
00:36:13,200 --> 00:36:14,560
buff pdr

984
00:36:14,560 --> 00:36:17,200
um remember i'm going to be interested

985
00:36:17,200 --> 00:36:19,920
in the contents of r7 which is written

986
00:36:19,920 --> 00:36:22,000
to right there

987
00:36:22,000 --> 00:36:25,440
and therefore i'm going to be overriding

988
00:36:25,440 --> 00:36:28,880
that call to mm-com has off

989
00:36:28,880 --> 00:36:31,839
with uh with a software interrupt which

990
00:36:31,839 --> 00:36:34,320
is going to which is going to result

991
00:36:34,320 --> 00:36:36,720
into

992
00:36:36,720 --> 00:36:38,800
the breakpoint getting hit

993
00:36:38,800 --> 00:36:41,359
at the um address of the of the

994
00:36:41,359 --> 00:36:43,359
overwritten handler being fetched from

995
00:36:43,359 --> 00:36:45,440
the from the

996
00:36:45,440 --> 00:36:47,520
interrupt vector table

997
00:36:47,520 --> 00:36:50,320
is going to result into the in the

998
00:36:50,320 --> 00:36:52,400
debugger checking

999
00:36:52,400 --> 00:36:54,560
what indeed checking what it needs to do

1000
00:36:54,560 --> 00:36:58,079
from a structure from the debugger and

1001
00:36:58,079 --> 00:36:59,839
this um

1002
00:36:59,839 --> 00:37:01,599
and as a result of this breakpoint being

1003
00:37:01,599 --> 00:37:02,640
hit

1004
00:37:02,640 --> 00:37:04,640
execution is going to be stuck

1005
00:37:04,640 --> 00:37:07,839
in this swi instruction for a while how

1006
00:37:07,839 --> 00:37:10,240
long for as long as we want to given

1007
00:37:10,240 --> 00:37:11,280
that

1008
00:37:11,280 --> 00:37:13,440
all other tasks are going to continue

1009
00:37:13,440 --> 00:37:15,920
normally

1010
00:37:15,920 --> 00:37:18,240
so let's get right through it i already

1011
00:37:18,240 --> 00:37:20,079
talked about what i have here

1012
00:37:20,079 --> 00:37:23,599
so right now there is um there is no gsm

1013
00:37:23,599 --> 00:37:26,000
network um

1014
00:37:26,000 --> 00:37:28,880
uh started so i'm going to

1015
00:37:28,880 --> 00:37:30,960
connect through my cr connection to this

1016
00:37:30,960 --> 00:37:33,040
to the dell machine inside the inside

1017
00:37:33,040 --> 00:37:34,880
the earth enclosure

1018
00:37:34,880 --> 00:37:37,839
and let's see what happens

1019
00:37:45,839 --> 00:37:47,599
so i'm using tmax which is terminal

1020
00:37:47,599 --> 00:37:49,440
multiplexer and this is necessary

1021
00:37:49,440 --> 00:37:51,280
because i only have one terminal this is

1022
00:37:51,280 --> 00:37:53,599
not an ssh link this is just a zero link

1023
00:37:53,599 --> 00:37:55,200
so i can just get one terminal and you

1024
00:37:55,200 --> 00:37:57,599
need a terminal multiplexer i'm going to

1025
00:37:57,599 --> 00:37:59,760
go to tab one which should

1026
00:37:59,760 --> 00:38:00,560
um

1027
00:38:00,560 --> 00:38:03,040
i'm going to instruct open bts to start

1028
00:38:03,040 --> 00:38:04,960
now we need to close the lid as right

1029
00:38:04,960 --> 00:38:06,560
now there is some

1030
00:38:06,560 --> 00:38:08,640
there's a gsm network in here and i

1031
00:38:08,640 --> 00:38:11,200
don't want your phones connecting to it

1032
00:38:11,200 --> 00:38:12,320
now that

1033
00:38:12,320 --> 00:38:15,280
open bts has been started we can go

1034
00:38:15,280 --> 00:38:18,400
ahead and install our p trace hook we

1035
00:38:18,400 --> 00:38:21,040
can just clear this

1036
00:38:21,040 --> 00:38:24,359
start adb

1037
00:38:33,040 --> 00:38:35,839
we need to figure out which of uh which

1038
00:38:35,839 --> 00:38:38,160
uh process the mediatek

1039
00:38:38,160 --> 00:38:41,119
um radio interface layer daemon is going

1040
00:38:41,119 --> 00:38:43,440
to be running on so that we can inject

1041
00:38:43,440 --> 00:38:47,040
our pre-trace hook on it

1042
00:38:51,920 --> 00:38:53,520
so we are attaching to each of the

1043
00:38:53,520 --> 00:38:55,520
threads that

1044
00:38:55,520 --> 00:38:56,640
this

1045
00:38:56,640 --> 00:38:59,280
that this process is comprised of and

1046
00:38:59,280 --> 00:39:01,440
now that we have installed our pitch

1047
00:39:01,440 --> 00:39:03,599
race hook we can receive

1048
00:39:03,599 --> 00:39:04,560
um

1049
00:39:04,560 --> 00:39:06,800
we can send and receive 80 commands

1050
00:39:06,800 --> 00:39:10,400
directly instead of having an um

1051
00:39:10,400 --> 00:39:12,839
and desired output being placed on

1052
00:39:12,839 --> 00:39:15,760
logcat now that i have

1053
00:39:15,760 --> 00:39:16,560
the

1054
00:39:16,560 --> 00:39:18,880
phrase hook running i can just

1055
00:39:18,880 --> 00:39:19,760
um

1056
00:39:19,760 --> 00:39:21,280
i can just um

1057
00:39:21,280 --> 00:39:23,200
go to open bt

1058
00:39:23,200 --> 00:39:24,640
i can just

1059
00:39:24,640 --> 00:39:26,720
go to um

1060
00:39:26,720 --> 00:39:29,359
to my phone dot py task

1061
00:39:29,359 --> 00:39:32,598
oh actually

1062
00:40:03,599 --> 00:40:05,119
so i'm going to reboot the phone for a

1063
00:40:05,119 --> 00:40:07,200
second and when it reboots i'm going to

1064
00:40:07,200 --> 00:40:09,440
manually associate it to this gsm

1065
00:40:09,440 --> 00:40:11,440
network that i have created now it is

1066
00:40:11,440 --> 00:40:14,760
putting up

1067
00:40:27,680 --> 00:40:29,839
and after this even if the demo works

1068
00:40:29,839 --> 00:40:31,920
i'm going to show you a video of what it

1069
00:40:31,920 --> 00:40:34,880
looks uh from the inside because this

1070
00:40:34,880 --> 00:40:37,359
shows it much much better than

1071
00:40:37,359 --> 00:40:39,680
using it from there

1072
00:40:39,680 --> 00:40:42,480
it's almost booted so now that

1073
00:40:42,480 --> 00:40:44,079
now i'm just going to

1074
00:40:44,079 --> 00:40:49,240
associate it manually to the gsm network

1075
00:41:14,000 --> 00:41:16,319
so right now i'm searching for networks

1076
00:41:16,319 --> 00:41:17,119
which

1077
00:41:17,119 --> 00:41:19,359
should show only one the one that exists

1078
00:41:19,359 --> 00:41:20,400
inside

1079
00:41:20,400 --> 00:41:22,640
and it did indeed it does show it i'm

1080
00:41:22,640 --> 00:41:25,359
going to click on it

1081
00:41:26,400 --> 00:41:28,400
and it's regis attempting to register on

1082
00:41:28,400 --> 00:41:30,560
it

1083
00:41:31,440 --> 00:41:34,160
now i'm registered so now i'm going to

1084
00:41:34,160 --> 00:41:35,359
install

1085
00:41:35,359 --> 00:41:36,560
the

1086
00:41:36,560 --> 00:41:40,599
dp trace full once again

1087
00:41:53,920 --> 00:41:55,760
so now we're attached to it

1088
00:41:55,760 --> 00:41:57,599
and

1089
00:41:57,599 --> 00:41:59,520
we're going to

1090
00:41:59,520 --> 00:42:03,480
get our test case

1091
00:42:37,520 --> 00:42:38,400
now

1092
00:42:38,400 --> 00:42:40,880
uh final lot by is loading the

1093
00:42:40,880 --> 00:42:43,200
predefined message types is also going

1094
00:42:43,200 --> 00:42:45,599
to make a few checks on whether the

1095
00:42:45,599 --> 00:42:48,800
baseband is associated to

1096
00:42:48,800 --> 00:42:52,240
is associated to our network

1097
00:42:53,599 --> 00:42:55,119
and let's see what those checks look

1098
00:42:55,119 --> 00:42:58,119
like

1099
00:43:07,359 --> 00:43:08,960
so right now a test call has been

1100
00:43:08,960 --> 00:43:11,680
established so we have a udp socket

1101
00:43:11,680 --> 00:43:12,400
that

1102
00:43:12,400 --> 00:43:14,480
we can use to send messages directly to

1103
00:43:14,480 --> 00:43:15,200
the

1104
00:43:15,200 --> 00:43:18,079
uh to the uh gsm layer 3 of the target

1105
00:43:18,079 --> 00:43:20,560
basement

1106
00:43:21,040 --> 00:43:23,280
the test case is now ready to be sent

1107
00:43:23,280 --> 00:43:25,359
but right before we send it we're going

1108
00:43:25,359 --> 00:43:29,359
to use the debugger to set a breakpoint

1109
00:43:32,319 --> 00:43:35,440
and we want to set the breakpoint

1110
00:43:35,440 --> 00:43:38,000
we're going to first request reading the

1111
00:43:38,000 --> 00:43:41,000
registers

1112
00:43:47,599 --> 00:43:49,599
this worked

1113
00:43:49,599 --> 00:43:51,200
and we're going to set a thumb

1114
00:43:51,200 --> 00:43:52,960
breakpoint

1115
00:43:52,960 --> 00:43:54,800
at this address which corresponds to

1116
00:43:54,800 --> 00:43:57,839
what i just showed before

1117
00:44:04,640 --> 00:44:06,800
so the breakpoint is set

1118
00:44:06,800 --> 00:44:09,680
and now we can just go ahead and send

1119
00:44:09,680 --> 00:44:12,480
our test case we press enter right here

1120
00:44:12,480 --> 00:44:14,800
and if everything worked

1121
00:44:14,800 --> 00:44:17,200
the debugger should be able to show us

1122
00:44:17,200 --> 00:44:19,040
the registers at the time the breakpoint

1123
00:44:19,040 --> 00:44:21,760
was set let's take a look at let's take

1124
00:44:21,760 --> 00:44:24,319
a look at them

1125
00:44:35,040 --> 00:44:36,880
and indeed it worked we were able to

1126
00:44:36,880 --> 00:44:39,760
read the registers at the moment

1127
00:44:39,760 --> 00:44:41,839
that the breakpoint was hit

1128
00:44:41,839 --> 00:44:43,760
at this point we're quite interested as

1129
00:44:43,760 --> 00:44:47,040
i said in r7 which is going to contain

1130
00:44:47,040 --> 00:44:49,760
the um the um the message that was

1131
00:44:49,760 --> 00:44:52,720
received over there so let's read memory

1132
00:44:52,720 --> 00:44:54,640
at that at that

1133
00:44:54,640 --> 00:44:57,960
at that place

1134
00:45:14,960 --> 00:45:17,040
on indeed as you can see there

1135
00:45:17,040 --> 00:45:18,720
effectively

1136
00:45:18,720 --> 00:45:20,560
the whole message that we intended to

1137
00:45:20,560 --> 00:45:22,400
send including the four a's have been

1138
00:45:22,400 --> 00:45:24,319
placed in memory as we could just read

1139
00:45:24,319 --> 00:45:25,440
it

1140
00:45:25,440 --> 00:45:27,760
hopefully the baseband hasn't crashed

1141
00:45:27,760 --> 00:45:29,520
so we are going to remove the

1142
00:45:29,520 --> 00:45:32,720
breakpoints and we're going to check

1143
00:45:32,720 --> 00:45:35,520
whether or not after execution continues

1144
00:45:35,520 --> 00:45:37,520
we are able to ping the baseband again

1145
00:45:37,520 --> 00:45:40,759
over there

1146
00:45:48,960 --> 00:45:51,200
so the breakpoint has been removed and

1147
00:45:51,200 --> 00:45:52,160
we can

1148
00:45:52,160 --> 00:45:54,560
instruct find out py to keep

1149
00:45:54,560 --> 00:45:57,040
to keep to carry on with the with other

1150
00:45:57,040 --> 00:45:59,680
checks let's take a look at

1151
00:45:59,680 --> 00:46:02,240
window number five and let's take a look

1152
00:46:02,240 --> 00:46:05,439
at what happened

1153
00:46:08,560 --> 00:46:10,400
and indeed

1154
00:46:10,400 --> 00:46:12,240
we were able to pick the baseband over

1155
00:46:12,240 --> 00:46:15,440
there again and we were able to also

1156
00:46:15,440 --> 00:46:18,000
check that uh the baseband is indeed

1157
00:46:18,000 --> 00:46:20,240
responding over an 80 command and it's

1158
00:46:20,240 --> 00:46:22,800
also the phone is still alive it's still

1159
00:46:22,800 --> 00:46:25,119
responding over adb

1160
00:46:25,119 --> 00:46:28,560
and finally i'm going to go to

1161
00:46:28,560 --> 00:46:32,160
i'm going to go back to the debugger

1162
00:46:33,920 --> 00:46:35,680
and i'm going to check that the

1163
00:46:35,680 --> 00:46:38,078
that the

1164
00:46:38,560 --> 00:46:43,240
that the basement chip is still alive

1165
00:46:43,920 --> 00:46:45,920
and this is still alive indeed so the

1166
00:46:45,920 --> 00:46:48,079
basement processor didn't crash as a

1167
00:46:48,079 --> 00:46:51,599
result of uh we debunking it so i would

1168
00:46:51,599 --> 00:46:53,280
say that this is successful at this

1169
00:46:53,280 --> 00:46:55,440
point now i'm going to show

1170
00:46:55,440 --> 00:46:58,960
the demo that i had pre-recorded

1171
00:46:58,960 --> 00:47:00,640
which shows the

1172
00:47:00,640 --> 00:47:02,720
which shows the

1173
00:47:02,720 --> 00:47:05,359
manual association of the

1174
00:47:05,359 --> 00:47:07,599
of the of the phone

1175
00:47:07,599 --> 00:47:09,599
i'm starting open bts once again this

1176
00:47:09,599 --> 00:47:12,400
you already saw

1177
00:47:18,000 --> 00:47:20,800
now there's a json network inside the rf

1178
00:47:20,800 --> 00:47:23,119
enclosure and we're going to proceed to

1179
00:47:23,119 --> 00:47:25,760
define uh to associate

1180
00:47:25,760 --> 00:47:29,119
it manually to our network

1181
00:47:29,200 --> 00:47:30,960
we need to search for networks we click

1182
00:47:30,960 --> 00:47:32,800
on network operators we search on

1183
00:47:32,800 --> 00:47:35,119
networks we search for networks and

1184
00:47:35,119 --> 00:47:37,119
right here is searching if you were

1185
00:47:37,119 --> 00:47:38,800
really really sharp at this point we

1186
00:47:38,800 --> 00:47:40,559
have seen you have seen that at the top

1187
00:47:40,559 --> 00:47:42,640
of the phone in the status bar there are

1188
00:47:42,640 --> 00:47:44,319
three bars representing that we're

1189
00:47:44,319 --> 00:47:46,000
already connected to the network but

1190
00:47:46,000 --> 00:47:48,000
we're just going to search for them

1191
00:47:48,000 --> 00:47:51,000
anyways

1192
00:48:07,119 --> 00:48:08,960
we see that indeed one network is found

1193
00:48:08,960 --> 00:48:10,800
so we click on it to associate and we're

1194
00:48:10,800 --> 00:48:13,280
registering it

1195
00:48:13,280 --> 00:48:15,599
now that we're registering it we can go

1196
00:48:15,599 --> 00:48:17,920
back to the terminal and install our

1197
00:48:17,920 --> 00:48:20,640
pre-choice hook

1198
00:48:20,640 --> 00:48:22,240
and display trace hook as i already

1199
00:48:22,240 --> 00:48:23,280
explained

1200
00:48:23,280 --> 00:48:25,960
is going to allow us to intercept

1201
00:48:25,960 --> 00:48:29,200
unwanted 80 command results directly

1202
00:48:29,200 --> 00:48:30,720
from

1203
00:48:30,720 --> 00:48:33,280
directly from the mediatek radio

1204
00:48:33,280 --> 00:48:35,760
interface layer demon before they go to

1205
00:48:35,760 --> 00:48:38,319
look at

1206
00:48:42,079 --> 00:48:44,480
this jordan is on so

1207
00:48:44,480 --> 00:48:45,760
now we're

1208
00:48:45,760 --> 00:48:47,040
going to send the test case we're going

1209
00:48:47,040 --> 00:48:50,160
to prepare to send it

1210
00:48:55,920 --> 00:48:58,160
and here there's some there are some

1211
00:48:58,160 --> 00:49:00,640
checks been done on the phone

1212
00:49:00,640 --> 00:49:01,599
to

1213
00:49:01,599 --> 00:49:02,880
ensure that

1214
00:49:02,880 --> 00:49:05,040
before we try to open a test call the

1215
00:49:05,040 --> 00:49:07,440
phone is associated to our cellular

1216
00:49:07,440 --> 00:49:09,040
network

1217
00:49:09,040 --> 00:49:14,200
and the test call itself is stable

1218
00:49:23,200 --> 00:49:25,280
now the test case is ready to be sent

1219
00:49:25,280 --> 00:49:27,839
once again

1220
00:49:28,559 --> 00:49:32,240
and we send it by pressing enter

1221
00:49:39,280 --> 00:49:41,119
we request the registers to be read by

1222
00:49:41,119 --> 00:49:45,520
configuring the debugger status block

1223
00:49:45,520 --> 00:49:48,640
now we set the breakpoint

1224
00:49:49,839 --> 00:49:52,640
now when the message that we're going to

1225
00:49:52,640 --> 00:49:55,680
be sending is removed is is received in

1226
00:49:55,680 --> 00:49:57,599
the baseband side execution is going to

1227
00:49:57,599 --> 00:50:00,079
be stuck

1228
00:50:01,119 --> 00:50:05,800
and we can read the registers once again

1229
00:50:13,440 --> 00:50:15,200
this is what i showed before already

1230
00:50:15,200 --> 00:50:17,280
we're interested in r7

1231
00:50:17,280 --> 00:50:19,119
so we can

1232
00:50:19,119 --> 00:50:23,559
read read memory at that point

1233
00:50:42,480 --> 00:50:45,359
and this you already saw and we did

1234
00:50:45,359 --> 00:50:47,440
we were able to retrieve the contents of

1235
00:50:47,440 --> 00:50:48,960
memory at that point

1236
00:50:48,960 --> 00:50:52,160
also back to the presentation

1237
00:50:52,160 --> 00:50:54,319
i think this next slide we don't need

1238
00:50:54,319 --> 00:50:56,160
because you already saw the that the

1239
00:50:56,160 --> 00:50:58,319
expected results are actually there

1240
00:50:58,319 --> 00:50:59,119
and

1241
00:50:59,119 --> 00:51:01,680
by overwriting this swi interrupt

1242
00:51:01,680 --> 00:51:04,880
handler we were able to indeed set and

1243
00:51:04,880 --> 00:51:06,800
remove breakpoints

1244
00:51:06,800 --> 00:51:10,480
so our diy basement baseball debugger

1245
00:51:10,480 --> 00:51:12,880
wishlist is now complete

1246
00:51:12,880 --> 00:51:13,920
and

1247
00:51:13,920 --> 00:51:15,760
of course i'm going to be releasing this

1248
00:51:15,760 --> 00:51:18,480
code later today which is going to be

1249
00:51:18,480 --> 00:51:20,319
comprised of all the firmware patches

1250
00:51:20,319 --> 00:51:23,040
the logic to patch the firmware

1251
00:51:23,040 --> 00:51:24,400
image itself

1252
00:51:24,400 --> 00:51:26,160
the pitrace hoop program and the

1253
00:51:26,160 --> 00:51:29,680
debugger agent oh what happened

1254
00:51:30,720 --> 00:51:32,880
okay and the debugger agent or all of

1255
00:51:32,880 --> 00:51:34,400
them all of this is going to be layered

1256
00:51:34,400 --> 00:51:36,720
today in this address so yeah just go

1257
00:51:36,720 --> 00:51:37,920
for it

1258
00:51:37,920 --> 00:51:40,400
and if you have some questions at this

1259
00:51:40,400 --> 00:51:42,880
point and if you're if i can answer them

1260
00:51:42,880 --> 00:51:46,290
i would be more than happy to do so

1261
00:51:46,290 --> 00:51:52,619
[Applause]

1262
00:51:53,760 --> 00:51:55,839
you

