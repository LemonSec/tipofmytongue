1
00:00:01,020 --> 00:00:04,240
[Applause]

2
00:00:04,240 --> 00:00:04,520
thanks

3
00:00:04,520 --> 00:00:08,090
[Applause]

4
00:00:08,400 --> 00:00:10,559
okay hi everyone uh great to see you all

5
00:00:10,559 --> 00:00:11,440
here

6
00:00:11,440 --> 00:00:15,280
uh i'm waiting for the slides okay

7
00:00:15,280 --> 00:00:18,000
let's see

8
00:00:18,160 --> 00:00:22,320
and how did i put this in full screen

9
00:00:23,199 --> 00:00:25,519
all right here we go uh yeah welcome to

10
00:00:25,519 --> 00:00:27,760
our talk i'm sam

11
00:00:27,760 --> 00:00:29,920
and together with amy i will talk or we

12
00:00:29,920 --> 00:00:32,079
will talk about javascript engine

13
00:00:32,079 --> 00:00:33,920
security in

14
00:00:33,920 --> 00:00:35,440
2022.

15
00:00:35,440 --> 00:00:37,520
um it's going to be a more of a high

16
00:00:37,520 --> 00:00:38,800
level talk

17
00:00:38,800 --> 00:00:40,320
so we're not going to do a deep dive

18
00:00:40,320 --> 00:00:42,320
into any specific bug

19
00:00:42,320 --> 00:00:45,440
instead it's more of an overview talk

20
00:00:45,440 --> 00:00:48,000
we do link to lots of resources for

21
00:00:48,000 --> 00:00:50,480
those interested in more details

22
00:00:50,480 --> 00:00:52,559
and we'll also keep it light on

23
00:00:52,559 --> 00:00:54,640
javascript language internals

24
00:00:54,640 --> 00:00:56,480
although we do need a little bit of that

25
00:00:56,480 --> 00:00:59,839
so we'll start with that

26
00:00:59,920 --> 00:01:02,239
for javascript really the the only thing

27
00:01:02,239 --> 00:01:04,000
you need to know for this talk is it's a

28
00:01:04,000 --> 00:01:07,280
very dynamic language and so for example

29
00:01:07,280 --> 00:01:09,840
that means that it has dynamic typing so

30
00:01:09,840 --> 00:01:12,720
here you have a variable v here it's a

31
00:01:12,720 --> 00:01:14,720
number but then nothing prevents you

32
00:01:14,720 --> 00:01:17,040
from setting it to a string right and

33
00:01:17,040 --> 00:01:18,080
then

34
00:01:18,080 --> 00:01:20,720
this variable slot on the stack it's

35
00:01:20,720 --> 00:01:23,119
then a pointer to a string somewhere or

36
00:01:23,119 --> 00:01:25,600
you can set it to an object

37
00:01:25,600 --> 00:01:27,840
and then it points to this

38
00:01:27,840 --> 00:01:30,079
yeah whatever this is

39
00:01:30,079 --> 00:01:32,479
and so all of this can change right

40
00:01:32,479 --> 00:01:34,799
and so next we look at how objects look

41
00:01:34,799 --> 00:01:35,600
like

42
00:01:35,600 --> 00:01:38,840
uh a bit in memory again this is kind of

43
00:01:38,840 --> 00:01:42,159
a high level concept this is

44
00:01:42,159 --> 00:01:44,399
roughly how all the major engines do it

45
00:01:44,399 --> 00:01:46,880
these days

46
00:01:46,880 --> 00:01:48,000
and so

47
00:01:48,000 --> 00:01:50,079
similar code snippet right you have

48
00:01:50,079 --> 00:01:51,439
you're creating an

49
00:01:51,439 --> 00:01:53,360
object with two properties

50
00:01:53,360 --> 00:01:55,680
and so what you end up with is

51
00:01:55,680 --> 00:01:57,600
the object in memory

52
00:01:57,600 --> 00:02:00,159
which has a pointer to a type or a

53
00:02:00,159 --> 00:02:02,240
hidden class

54
00:02:02,240 --> 00:02:04,560
i think it's called hidden class

55
00:02:04,560 --> 00:02:06,560
just because it's similar to a class in

56
00:02:06,560 --> 00:02:09,360
c plus plus or java except it's hidden

57
00:02:09,360 --> 00:02:11,440
to the programmer

58
00:02:11,440 --> 00:02:13,599
and so now this hidden class

59
00:02:13,599 --> 00:02:16,000
this contains the information where

60
00:02:16,000 --> 00:02:18,080
those properties live right and so in

61
00:02:18,080 --> 00:02:21,040
this case it says a and b are both

62
00:02:21,040 --> 00:02:23,280
inline properties and so they are stored

63
00:02:23,280 --> 00:02:25,599
directly in that object

64
00:02:25,599 --> 00:02:28,480
and here if we were to load property a

65
00:02:28,480 --> 00:02:30,959
to print it for example

66
00:02:30,959 --> 00:02:32,959
what the engine does it goes to this

67
00:02:32,959 --> 00:02:35,200
object it goes to the type to the hidden

68
00:02:35,200 --> 00:02:38,400
class asks hey where is property a

69
00:02:38,400 --> 00:02:39,599
stored

70
00:02:39,599 --> 00:02:41,599
that tells it it's in line in the object

71
00:02:41,599 --> 00:02:45,200
and so then it goes and fetches it

72
00:02:45,200 --> 00:02:47,360
now one of the main reasons for doing

73
00:02:47,360 --> 00:02:50,480
the separation of object and type is

74
00:02:50,480 --> 00:02:53,519
that you can share those type objects so

75
00:02:53,519 --> 00:02:55,760
if we were to create another similar

76
00:02:55,760 --> 00:02:57,760
looking object

77
00:02:57,760 --> 00:02:59,519
like this here with again a and b

78
00:02:59,519 --> 00:03:02,640
properties it can point to the same

79
00:03:02,640 --> 00:03:05,440
hidden class in memory and so you save

80
00:03:05,440 --> 00:03:07,680
some memory for example

81
00:03:07,680 --> 00:03:09,680
but again all of this is dynamic all of

82
00:03:09,680 --> 00:03:11,920
this can change and so here for example

83
00:03:11,920 --> 00:03:14,959
we can add another property

84
00:03:14,959 --> 00:03:17,120
to this o2 object

85
00:03:17,120 --> 00:03:19,519
right and so then what happens well we

86
00:03:19,519 --> 00:03:21,680
can no longer point to the first hidden

87
00:03:21,680 --> 00:03:24,000
class because it doesn't have c so we

88
00:03:24,000 --> 00:03:25,920
need to create a new one

89
00:03:25,920 --> 00:03:27,680
the other problem we might have in this

90
00:03:27,680 --> 00:03:29,599
case is that we don't have any more

91
00:03:29,599 --> 00:03:31,200
space in

92
00:03:31,200 --> 00:03:33,840
the object itself and so we need to

93
00:03:33,840 --> 00:03:36,560
allocate some kind of out of line

94
00:03:36,560 --> 00:03:38,319
property storage right like some

95
00:03:38,319 --> 00:03:40,400
property area maybe

96
00:03:40,400 --> 00:03:42,560
and then that again has those slots and

97
00:03:42,560 --> 00:03:45,200
the hidden class says c is stored out of

98
00:03:45,200 --> 00:03:48,480
line slot 0.

99
00:03:48,480 --> 00:03:50,159
and we could do even more shenanigans

100
00:03:50,159 --> 00:03:52,000
like we could delete properties that

101
00:03:52,000 --> 00:03:53,040
exist

102
00:03:53,040 --> 00:03:55,360
in which case again we need a new hidden

103
00:03:55,360 --> 00:03:56,480
class

104
00:03:56,480 --> 00:03:59,040
that now only has b and c

105
00:03:59,040 --> 00:04:00,879
and the slot 0 is

106
00:04:00,879 --> 00:04:03,200
in some deleted state right

107
00:04:03,200 --> 00:04:05,280
so again main takeaway all of this can

108
00:04:05,280 --> 00:04:08,239
change it's a very hostile environment i

109
00:04:08,239 --> 00:04:09,280
would say

110
00:04:09,280 --> 00:04:11,360
and we'll see how this breaks things

111
00:04:11,360 --> 00:04:13,040
later

112
00:04:13,040 --> 00:04:15,120
so here's a

113
00:04:15,120 --> 00:04:16,079
small

114
00:04:16,079 --> 00:04:18,798
kind of summary of typical js engine

115
00:04:18,798 --> 00:04:21,040
components we'll do a quick walkthrough

116
00:04:21,040 --> 00:04:23,600
how they work together to run

117
00:04:23,600 --> 00:04:25,680
your javascript code

118
00:04:25,680 --> 00:04:26,880
so

119
00:04:26,880 --> 00:04:28,720
javascript code comes in here for

120
00:04:28,720 --> 00:04:30,800
example from the web browser where it

121
00:04:30,800 --> 00:04:33,040
fetches it from the network

122
00:04:33,040 --> 00:04:34,720
first thing it does it goes into the

123
00:04:34,720 --> 00:04:36,479
bytecode compiler

124
00:04:36,479 --> 00:04:38,960
and so that compiles it to engine

125
00:04:38,960 --> 00:04:41,199
specific bytecode so each of the major

126
00:04:41,199 --> 00:04:42,720
engines they have their own bytecode

127
00:04:42,720 --> 00:04:43,840
format

128
00:04:43,840 --> 00:04:46,400
that they optimize for their respective

129
00:04:46,400 --> 00:04:48,240
interpreter for example

130
00:04:48,240 --> 00:04:49,759
that's the next thing that happens the

131
00:04:49,759 --> 00:04:51,199
bytecode gets

132
00:04:51,199 --> 00:04:53,280
executed or interpreted

133
00:04:53,280 --> 00:04:55,120
by an interpreter

134
00:04:55,120 --> 00:04:57,440
and while it does that it interacts with

135
00:04:57,440 --> 00:04:59,040
what we're just calling the run time

136
00:04:59,040 --> 00:04:59,919
here

137
00:04:59,919 --> 00:05:01,840
which is basically the set of like all

138
00:05:01,840 --> 00:05:04,160
the constructors you have available all

139
00:05:04,160 --> 00:05:05,759
the built-in objects

140
00:05:05,759 --> 00:05:07,600
built-in methods and so on like your

141
00:05:07,600 --> 00:05:09,600
whole environment

142
00:05:09,600 --> 00:05:12,000
and while that runs it creates a runtime

143
00:05:12,000 --> 00:05:14,080
state like for example it sets up

144
00:05:14,080 --> 00:05:16,479
objects as we've seen before links them

145
00:05:16,479 --> 00:05:19,039
together it creates kind of a graph

146
00:05:19,039 --> 00:05:22,560
of things referencing each other

147
00:05:22,560 --> 00:05:24,240
now eventually if this byte could run

148
00:05:24,240 --> 00:05:26,400
for a long time it gets hot what they

149
00:05:26,400 --> 00:05:27,600
call it

150
00:05:27,600 --> 00:05:29,280
and at this point the engine decides

151
00:05:29,280 --> 00:05:31,520
well maybe it's a good time now to

152
00:05:31,520 --> 00:05:33,759
optimize this code further so your web

153
00:05:33,759 --> 00:05:36,080
page runs faster

154
00:05:36,080 --> 00:05:38,320
puts that byte code feeds that into the

155
00:05:38,320 --> 00:05:39,759
jit compiler

156
00:05:39,759 --> 00:05:41,919
which then optimizes the code and

157
00:05:41,919 --> 00:05:44,240
produces machine code and that should

158
00:05:44,240 --> 00:05:46,560
hopefully be very fast and now

159
00:05:46,560 --> 00:05:48,560
everything is nice and smooth

160
00:05:48,560 --> 00:05:51,039
but otherwise it behaves the same as the

161
00:05:51,039 --> 00:05:52,560
bytecode right it interacts with the

162
00:05:52,560 --> 00:05:55,199
runtime does its thing

163
00:05:55,199 --> 00:05:59,120
this just a in a more performant way

164
00:05:59,120 --> 00:06:00,000
now

165
00:06:00,000 --> 00:06:01,600
eventually

166
00:06:01,600 --> 00:06:03,120
javascript is a garbage collected

167
00:06:03,120 --> 00:06:04,800
language so it means the programmer

168
00:06:04,800 --> 00:06:07,919
doesn't have to manually unlock in three

169
00:06:07,919 --> 00:06:08,960
things

170
00:06:08,960 --> 00:06:11,360
instead there's a garbage collector

171
00:06:11,360 --> 00:06:14,160
which takes care of figuring out when

172
00:06:14,160 --> 00:06:16,160
memory is no longer referenced here in

173
00:06:16,160 --> 00:06:18,479
this example like this some node here

174
00:06:18,479 --> 00:06:20,240
some object that isn't referenced by

175
00:06:20,240 --> 00:06:22,319
anyone so the collector comes in does

176
00:06:22,319 --> 00:06:24,560
kind of a graph walk figures out this

177
00:06:24,560 --> 00:06:27,199
object no one is using it and it frees

178
00:06:27,199 --> 00:06:29,039
it

179
00:06:29,039 --> 00:06:30,400
and then finally there's also

180
00:06:30,400 --> 00:06:32,560
webassembly which is integrated in in

181
00:06:32,560 --> 00:06:35,199
the javascript engines

182
00:06:35,199 --> 00:06:37,440
it's a basically a byte code format for

183
00:06:37,440 --> 00:06:39,759
the web if you want you could take c

184
00:06:39,759 --> 00:06:42,400
plus plus code compile it to webassembly

185
00:06:42,400 --> 00:06:44,319
run it in your browser

186
00:06:44,319 --> 00:06:45,759
and this has a slightly different

187
00:06:45,759 --> 00:06:48,160
pipeline but it's mostly really just a

188
00:06:48,160 --> 00:06:49,919
front end part that's different so

189
00:06:49,919 --> 00:06:51,759
there's a different compiler

190
00:06:51,759 --> 00:06:54,720
that takes the wasm bytecode format and

191
00:06:54,720 --> 00:06:56,720
converts it either again to some other

192
00:06:56,720 --> 00:06:59,440
bytecode or directly to jit code in this

193
00:06:59,440 --> 00:07:01,680
case this works for wasm it doesn't

194
00:07:01,680 --> 00:07:03,840
really work for js and we'll see why in

195
00:07:03,840 --> 00:07:06,160
a second

196
00:07:06,160 --> 00:07:07,199
okay

197
00:07:07,199 --> 00:07:08,800
so with this short introduction we're

198
00:07:08,800 --> 00:07:10,720
going to zoom into one of the most

199
00:07:10,720 --> 00:07:12,319
complex parts

200
00:07:12,319 --> 00:07:14,720
which is the jit compiler

201
00:07:14,720 --> 00:07:16,880
it's going to be up next and we will

202
00:07:16,880 --> 00:07:18,720
start with um

203
00:07:18,720 --> 00:07:21,360
kind of a simple example for how jitting

204
00:07:21,360 --> 00:07:23,680
of javascript works

205
00:07:23,680 --> 00:07:25,840
so here's some

206
00:07:25,840 --> 00:07:28,720
i just made up this code here um

207
00:07:28,720 --> 00:07:30,880
it's it's like a kind of a bitmap thing

208
00:07:30,880 --> 00:07:33,599
of eight bit integers and there's a

209
00:07:33,599 --> 00:07:36,240
function set and you give it a point

210
00:07:36,240 --> 00:07:40,080
and a value um and it's going to set

211
00:07:40,080 --> 00:07:42,319
the the bitmap at that point to the

212
00:07:42,319 --> 00:07:44,240
provided value right it does a bit of

213
00:07:44,240 --> 00:07:47,199
sanity checking it tries to make sure

214
00:07:47,199 --> 00:07:50,319
that x and y are within the range

215
00:07:50,319 --> 00:07:52,080
but yeah

216
00:07:52,080 --> 00:07:53,919
so um

217
00:07:53,919 --> 00:07:56,319
really the first problem if you

218
00:07:56,319 --> 00:07:58,080
just wanted to like convert this to

219
00:07:58,080 --> 00:07:59,360
machine code

220
00:07:59,360 --> 00:08:01,360
the the big problem you have is you

221
00:08:01,360 --> 00:08:03,440
don't actually know what p is like what

222
00:08:03,440 --> 00:08:05,120
the type of p is

223
00:08:05,120 --> 00:08:06,479
i mean if you look at this you would

224
00:08:06,479 --> 00:08:08,000
guess it's probably an object with

225
00:08:08,000 --> 00:08:09,840
property x and y that are probably

226
00:08:09,840 --> 00:08:11,440
numbers but there's nothing that

227
00:08:11,440 --> 00:08:13,919
guarantees that like we could run this

228
00:08:13,919 --> 00:08:15,599
with a string and in that case it would

229
00:08:15,599 --> 00:08:18,000
do weird things

230
00:08:18,000 --> 00:08:20,319
and so this can actually be jittered

231
00:08:20,319 --> 00:08:21,680
just like that

232
00:08:21,680 --> 00:08:24,319
so what has to happen first is the

233
00:08:24,319 --> 00:08:26,400
code has to run a couple of times in the

234
00:08:26,400 --> 00:08:29,360
interpreter and while it runs there the

235
00:08:29,360 --> 00:08:31,120
engine gathers type feedback so it

236
00:08:31,120 --> 00:08:33,279
remembers okay if this function has been

237
00:08:33,279 --> 00:08:35,279
called with this type before and only

238
00:08:35,279 --> 00:08:36,399
this type

239
00:08:36,399 --> 00:08:38,399
and so sometimes this is called training

240
00:08:38,399 --> 00:08:40,799
so we need some kind of for loop

241
00:08:40,799 --> 00:08:43,519
that just calls this

242
00:08:43,519 --> 00:08:45,600
and and now we can start with some

243
00:08:45,600 --> 00:08:47,680
jitting

244
00:08:47,680 --> 00:08:49,440
how i'm going to do this is on the left

245
00:08:49,440 --> 00:08:51,680
side it's highlighted the line that's

246
00:08:51,680 --> 00:08:52,720
being

247
00:08:52,720 --> 00:08:54,560
jitted if you want

248
00:08:54,560 --> 00:08:56,240
on the right there's some jit

249
00:08:56,240 --> 00:08:58,399
intermediate language pseudo code for

250
00:08:58,399 --> 00:09:00,720
the highlighted snippet

251
00:09:00,720 --> 00:09:02,320
and so in this case the first thing that

252
00:09:02,320 --> 00:09:04,640
happens is bytecode parsing

253
00:09:04,640 --> 00:09:06,720
the jit engine takes in the bytecode and

254
00:09:06,720 --> 00:09:10,320
turns it into some high-ish level jit

255
00:09:10,320 --> 00:09:12,480
intermediate language in this case it

256
00:09:12,480 --> 00:09:14,160
still has pretty high level operations

257
00:09:14,160 --> 00:09:15,279
it's just like

258
00:09:15,279 --> 00:09:18,480
load property do a compare load property

259
00:09:18,480 --> 00:09:20,880
do a compare

260
00:09:20,880 --> 00:09:23,040
what's going to happen next is two

261
00:09:23,040 --> 00:09:25,360
things the first part is speculation

262
00:09:25,360 --> 00:09:27,200
which is exactly where this feedback

263
00:09:27,200 --> 00:09:29,519
from past executions comes in

264
00:09:29,519 --> 00:09:32,240
and so the engine sees ah okay pm

265
00:09:32,240 --> 00:09:34,399
so far p has always been this like

266
00:09:34,399 --> 00:09:36,640
object type one with property x and y

267
00:09:36,640 --> 00:09:37,680
and so on

268
00:09:37,680 --> 00:09:39,279
and so it speculates that this will be

269
00:09:39,279 --> 00:09:40,959
the same in the future

270
00:09:40,959 --> 00:09:42,880
and it just puts in a type check and if

271
00:09:42,880 --> 00:09:44,560
that check fails then

272
00:09:44,560 --> 00:09:46,480
the runtime will actually just go back

273
00:09:46,480 --> 00:09:48,080
to the interpreter and this code will

274
00:09:48,080 --> 00:09:48,839
not

275
00:09:48,839 --> 00:09:50,560
continue

276
00:09:50,560 --> 00:09:52,560
and then it also by that point it knows

277
00:09:52,560 --> 00:09:54,399
the type so it can convert this high

278
00:09:54,399 --> 00:09:55,519
level

279
00:09:55,519 --> 00:09:58,640
load property operation to a low level

280
00:09:58,640 --> 00:09:59,920
load field

281
00:09:59,920 --> 00:10:03,519
plus 8 thing so that's called lowering

282
00:10:03,519 --> 00:10:05,760
now if you look at this code

283
00:10:05,760 --> 00:10:07,440
you realize well it's kind of redundant

284
00:10:07,440 --> 00:10:08,800
right like we're loading we're doing

285
00:10:08,800 --> 00:10:10,560
this type check twice

286
00:10:10,560 --> 00:10:12,000
we're doing the load twice there's

287
00:10:12,000 --> 00:10:13,600
nothing in between that could really

288
00:10:13,600 --> 00:10:15,839
mess up anything and so here's the first

289
00:10:15,839 --> 00:10:16,839
round of

290
00:10:16,839 --> 00:10:19,040
optimization the compiler figures out

291
00:10:19,040 --> 00:10:21,279
this is redundant and it drops

292
00:10:21,279 --> 00:10:25,519
the second pair of these operations

293
00:10:25,760 --> 00:10:28,399
let's look at this line down here

294
00:10:28,399 --> 00:10:29,279
where it

295
00:10:29,279 --> 00:10:32,320
stores the value into the

296
00:10:32,320 --> 00:10:34,079
u and 8 array

297
00:10:34,079 --> 00:10:36,079
and again at first this is going to look

298
00:10:36,079 --> 00:10:37,680
pretty high level it's loading the

299
00:10:37,680 --> 00:10:39,839
global value w

300
00:10:39,839 --> 00:10:41,839
doing a generic multiplication and

301
00:10:41,839 --> 00:10:43,440
generic addition

302
00:10:43,440 --> 00:10:46,079
loading the global bmp value and doing a

303
00:10:46,079 --> 00:10:48,720
generic store element

304
00:10:48,720 --> 00:10:51,839
same kind of similar thing here we do

305
00:10:51,839 --> 00:10:53,600
lowering and in this case we also do

306
00:10:53,600 --> 00:10:56,160
constant folding we know that w and bmp

307
00:10:56,160 --> 00:10:58,320
are constants they can change we don't

308
00:10:58,320 --> 00:10:59,760
need to load them

309
00:10:59,760 --> 00:11:02,240
we know that x and y are integers we can

310
00:11:02,240 --> 00:11:03,279
do a

311
00:11:03,279 --> 00:11:06,000
specific integer multiplication

312
00:11:06,000 --> 00:11:07,760
and we also turn

313
00:11:07,760 --> 00:11:09,680
the generic store element we turn it

314
00:11:09,680 --> 00:11:11,920
into a check bounce and uh

315
00:11:11,920 --> 00:11:13,839
like just to write into an array

316
00:11:13,839 --> 00:11:16,399
operation

317
00:11:16,800 --> 00:11:18,880
so let's do another optimization here

318
00:11:18,880 --> 00:11:21,440
this one is called range analysis and or

319
00:11:21,440 --> 00:11:24,240
bounce check elimination

320
00:11:24,240 --> 00:11:27,519
if you look at the if condition

321
00:11:27,519 --> 00:11:28,959
you will see and the compiler will

322
00:11:28,959 --> 00:11:32,560
conclude that at the highlighted line x

323
00:11:32,560 --> 00:11:35,200
and y must be integers

324
00:11:35,200 --> 00:11:38,320
in this range 0 through 64.

325
00:11:38,320 --> 00:11:40,480
and so if you know that then you can

326
00:11:40,480 --> 00:11:42,399
figure out what the possible range of

327
00:11:42,399 --> 00:11:44,720
values is after the multiplication to

328
00:11:44,720 --> 00:11:46,560
this here and then you can also figure

329
00:11:46,560 --> 00:11:49,040
out what it is after the addition

330
00:11:49,040 --> 00:11:51,279
and then you see well this bounce check

331
00:11:51,279 --> 00:11:53,200
is really not necessary the bounce check

332
00:11:53,200 --> 00:11:56,880
just checks if it's between 0 and 4096

333
00:11:56,880 --> 00:11:59,360
but we already know that so let's get

334
00:11:59,360 --> 00:12:01,760
rid of this bounce check

335
00:12:01,760 --> 00:12:04,160
because it's very expensive of course we

336
00:12:04,160 --> 00:12:06,079
don't want to do bounce checking

337
00:12:06,079 --> 00:12:07,120
um

338
00:12:07,120 --> 00:12:09,040
and so yeah we can get rid of that and

339
00:12:09,040 --> 00:12:11,920
here's the kind of final jit code for

340
00:12:11,920 --> 00:12:15,279
this example it's really just those few

341
00:12:15,279 --> 00:12:18,480
low level operations and those can more

342
00:12:18,480 --> 00:12:20,240
or less just be

343
00:12:20,240 --> 00:12:22,160
lowered to one or a couple of machine

344
00:12:22,160 --> 00:12:24,639
code instructions like the load fields

345
00:12:24,639 --> 00:12:26,560
it's just going to be like one move or

346
00:12:26,560 --> 00:12:28,560
ldr

347
00:12:28,560 --> 00:12:30,240
the multiplication and addition and so

348
00:12:30,240 --> 00:12:31,760
on

349
00:12:31,760 --> 00:12:34,240
cool so this is a short summary of what

350
00:12:34,240 --> 00:12:35,519
we've seen

351
00:12:35,519 --> 00:12:37,760
like how does a jit work on a high level

352
00:12:37,760 --> 00:12:39,839
it starts from unoptimized byte code it

353
00:12:39,839 --> 00:12:42,720
does speculation based on feedback

354
00:12:42,720 --> 00:12:44,720
then it does a number of rounds of lower

355
00:12:44,720 --> 00:12:47,600
ring to the next lower level language

356
00:12:47,600 --> 00:12:50,000
optimize on that

357
00:12:50,000 --> 00:12:51,360
and then at the end you have machine

358
00:12:51,360 --> 00:12:53,839
code

359
00:12:54,720 --> 00:12:57,120
all right

360
00:12:59,760 --> 00:13:01,200
so let's look at a

361
00:13:01,200 --> 00:13:05,120
hypothetical example for a bug

362
00:13:05,120 --> 00:13:06,399
another

363
00:13:06,399 --> 00:13:08,480
js snippet

364
00:13:08,480 --> 00:13:11,120
it's just a function that takes in an

365
00:13:11,120 --> 00:13:13,040
supposedly an array

366
00:13:13,040 --> 00:13:15,440
a callback function and a value

367
00:13:15,440 --> 00:13:17,440
and it calls find index

368
00:13:17,440 --> 00:13:19,519
find index will

369
00:13:19,519 --> 00:13:21,760
go through the array called the callback

370
00:13:21,760 --> 00:13:24,079
for each value and once the callback

371
00:13:24,079 --> 00:13:25,440
returns true

372
00:13:25,440 --> 00:13:27,519
it returns the index for which it

373
00:13:27,519 --> 00:13:29,360
returns true and then this function

374
00:13:29,360 --> 00:13:31,920
takes that index and sets the value to

375
00:13:31,920 --> 00:13:35,360
the provided one

376
00:13:35,360 --> 00:13:37,120
so now

377
00:13:37,120 --> 00:13:39,199
if you did kind of a similar thing as we

378
00:13:39,199 --> 00:13:40,880
did before you would maybe end up with

379
00:13:40,880 --> 00:13:42,160
this code

380
00:13:42,160 --> 00:13:44,240
where it does a type check that a is an

381
00:13:44,240 --> 00:13:46,959
array calls into the runtime does a

382
00:13:46,959 --> 00:13:50,639
bounce check and stores into the array

383
00:13:50,639 --> 00:13:52,639
now you might be tempted to try some

384
00:13:52,639 --> 00:13:54,560
range analysis here

385
00:13:54,560 --> 00:13:56,639
and you might conclude well

386
00:13:56,639 --> 00:13:58,399
find index i mean certainly this is

387
00:13:58,399 --> 00:14:00,399
going to give me an index back so the

388
00:14:00,399 --> 00:14:03,199
value i get or the range for i is going

389
00:14:03,199 --> 00:14:05,279
to be between 0 and whatever the length

390
00:14:05,279 --> 00:14:06,639
of the array is

391
00:14:06,639 --> 00:14:08,160
and then you are very happy to remove

392
00:14:08,160 --> 00:14:09,839
this bounce check

393
00:14:09,839 --> 00:14:12,880
and save some executions at runtime

394
00:14:12,880 --> 00:14:14,320
but no

395
00:14:14,320 --> 00:14:16,959
this doesn't quite work um because of

396
00:14:16,959 --> 00:14:19,920
course if the value is never found

397
00:14:19,920 --> 00:14:22,079
then find index in this case it returns

398
00:14:22,079 --> 00:14:24,399
negative one uh and so this would give

399
00:14:24,399 --> 00:14:26,240
you an out of bounds

400
00:14:26,240 --> 00:14:28,880
read or write right in this case

401
00:14:28,880 --> 00:14:30,800
in front of the area

402
00:14:30,800 --> 00:14:33,279
so that doesn't work

403
00:14:33,279 --> 00:14:34,959
of course this is a very simple example

404
00:14:34,959 --> 00:14:36,720
but i think it kind of highlights the

405
00:14:36,720 --> 00:14:38,560
point

406
00:14:38,560 --> 00:14:40,160
so

407
00:14:40,160 --> 00:14:42,240
now you might be tempted to say okay

408
00:14:42,240 --> 00:14:45,040
let's let me fix up my range analysis

409
00:14:45,040 --> 00:14:46,959
really it's between negative one and the

410
00:14:46,959 --> 00:14:48,560
length of the array

411
00:14:48,560 --> 00:14:50,240
and and so then maybe i can kind of

412
00:14:50,240 --> 00:14:52,160
simplify this bounce check i just need

413
00:14:52,160 --> 00:14:53,680
to make sure it's

414
00:14:53,680 --> 00:14:55,920
bigger than zero

415
00:14:55,920 --> 00:14:58,000
no it's not negative large or equal to

416
00:14:58,000 --> 00:14:59,680
zero

417
00:14:59,680 --> 00:15:02,079
but again this doesn't quite work

418
00:15:02,079 --> 00:15:04,000
uh and now the problem is uh callback

419
00:15:04,000 --> 00:15:07,120
trickery what you can do is in your

420
00:15:07,120 --> 00:15:09,120
in this callback that you give to find

421
00:15:09,120 --> 00:15:11,680
index you could resize the array now you

422
00:15:11,680 --> 00:15:14,560
could just set it set its length to zero

423
00:15:14,560 --> 00:15:16,480
um the backing store would get

424
00:15:16,480 --> 00:15:18,240
reallocated also

425
00:15:18,240 --> 00:15:20,560
and then again you get an out of bounds

426
00:15:20,560 --> 00:15:22,959
access into this area

427
00:15:22,959 --> 00:15:24,880
so this is what i meant before when i

428
00:15:24,880 --> 00:15:26,639
said it's a pretty hostile environment

429
00:15:26,639 --> 00:15:29,519
there's so many things that can change

430
00:15:29,519 --> 00:15:30,880
all the time

431
00:15:30,880 --> 00:15:34,240
so you need to be very careful

432
00:15:34,240 --> 00:15:35,440
okay

433
00:15:35,440 --> 00:15:38,000
so enough with hypothetical bugs let's

434
00:15:38,000 --> 00:15:40,639
look at some real bugs

435
00:15:40,639 --> 00:15:42,399
so this picture

436
00:15:42,399 --> 00:15:43,920
and no worries we're going to go through

437
00:15:43,920 --> 00:15:47,839
it step by step no worries

438
00:15:48,000 --> 00:15:51,040
this list like kind of the

439
00:15:51,040 --> 00:15:53,120
a lot of the jit bugs we've seen in the

440
00:15:53,120 --> 00:15:54,720
last few years

441
00:15:54,720 --> 00:15:56,560
they are all linked there

442
00:15:56,560 --> 00:15:58,480
the kind of barrier for inclusion was

443
00:15:58,480 --> 00:16:00,959
there had to be some decent write-up of

444
00:16:00,959 --> 00:16:03,680
the bug so all of these are really great

445
00:16:03,680 --> 00:16:05,680
resources

446
00:16:05,680 --> 00:16:06,839
and so yeah

447
00:16:06,839 --> 00:16:09,839
let's let's build this up step by step

448
00:16:09,839 --> 00:16:12,880
so we start from these red bubbles

449
00:16:12,880 --> 00:16:15,040
those are kind of the

450
00:16:15,040 --> 00:16:17,199
fundamental memory in safeties if you

451
00:16:17,199 --> 00:16:19,120
want right you have

452
00:16:19,120 --> 00:16:21,199
spatial memory safety means if you have

453
00:16:21,199 --> 00:16:22,639
an array when your access is out of

454
00:16:22,639 --> 00:16:25,519
bounds then you're violating that

455
00:16:25,519 --> 00:16:27,920
type safety is violated by a type

456
00:16:27,920 --> 00:16:29,680
confusion you

457
00:16:29,680 --> 00:16:31,600
think your object is of type x but

458
00:16:31,600 --> 00:16:33,279
really it's of type y so that's your

459
00:16:33,279 --> 00:16:34,639
type confusion

460
00:16:34,639 --> 00:16:37,040
and temporal memory safety well if

461
00:16:37,040 --> 00:16:38,720
you're using an object after it has been

462
00:16:38,720 --> 00:16:40,560
freed then you have a temporal memory

463
00:16:40,560 --> 00:16:42,800
safety violation

464
00:16:42,800 --> 00:16:43,920
um

465
00:16:43,920 --> 00:16:45,120
and so

466
00:16:45,120 --> 00:16:48,160
the way to read this is

467
00:16:48,160 --> 00:16:50,720
there are optimizations and analysis

468
00:16:50,720 --> 00:16:53,839
passes they have different colors um and

469
00:16:53,839 --> 00:16:54,560
an

470
00:16:54,560 --> 00:16:56,720
arrow here just means one breaks the

471
00:16:56,720 --> 00:16:58,959
other okay and so

472
00:16:58,959 --> 00:17:00,560
bounce check elimination i think that's

473
00:17:00,560 --> 00:17:02,000
pretty obvious since what we've just

474
00:17:02,000 --> 00:17:04,160
seen if bounce check elimination goes

475
00:17:04,160 --> 00:17:06,640
wrong that breaks spatial memory safety

476
00:17:06,640 --> 00:17:08,160
now you have removed the bounce check

477
00:17:08,160 --> 00:17:09,919
that you shouldn't have removed that

478
00:17:09,919 --> 00:17:12,319
gives you out of bounds access

479
00:17:12,319 --> 00:17:14,079
and there were actually there was at

480
00:17:14,079 --> 00:17:16,000
least one bug

481
00:17:16,000 --> 00:17:18,240
some time ago 2017

482
00:17:18,240 --> 00:17:20,319
directly in the bounce check elimination

483
00:17:20,319 --> 00:17:22,880
itself not even in the analysis i think

484
00:17:22,880 --> 00:17:24,400
it was something where they just forgot

485
00:17:24,400 --> 00:17:26,000
to check for negative numbers like they

486
00:17:26,000 --> 00:17:28,240
had all the range information but they

487
00:17:28,240 --> 00:17:30,080
didn't actually check if

488
00:17:30,080 --> 00:17:31,760
they just checked was it below the

489
00:17:31,760 --> 00:17:33,840
bounce but not was it bigger than zero

490
00:17:33,840 --> 00:17:34,720
and so

491
00:17:34,720 --> 00:17:36,880
then they removed it um

492
00:17:36,880 --> 00:17:41,039
but then uh starting 2017 and 2018

493
00:17:41,039 --> 00:17:43,039
um a lot of bugs came up in the range

494
00:17:43,039 --> 00:17:45,039
analysis itself and that is a much more

495
00:17:45,039 --> 00:17:47,760
complex thing that is like you need

496
00:17:47,760 --> 00:17:51,200
to model every operation in your jit ir

497
00:17:51,200 --> 00:17:53,919
and compute the output range and so lots

498
00:17:53,919 --> 00:17:55,360
of things go wrong

499
00:17:55,360 --> 00:17:57,120
they're kind of similar to the example

500
00:17:57,120 --> 00:17:58,840
we've seen

501
00:17:58,840 --> 00:18:01,919
um so yeah

502
00:18:01,919 --> 00:18:04,720
so look look at another

503
00:18:04,720 --> 00:18:06,880
kind of another group of optimizations

504
00:18:06,880 --> 00:18:09,919
here which is type check elimination

505
00:18:09,919 --> 00:18:12,799
also similar to what we've seen so this

506
00:18:12,799 --> 00:18:14,640
might be a case where

507
00:18:14,640 --> 00:18:16,320
you have two type checks for the same

508
00:18:16,320 --> 00:18:18,320
type and then the engine decides it

509
00:18:18,320 --> 00:18:19,840
doesn't actually need one of them and

510
00:18:19,840 --> 00:18:21,440
drops it

511
00:18:21,440 --> 00:18:22,160
the

512
00:18:22,160 --> 00:18:24,720
big issue that can happen here is

513
00:18:24,720 --> 00:18:26,799
your engine things it can remove this

514
00:18:26,799 --> 00:18:28,880
type check but actually in between the

515
00:18:28,880 --> 00:18:30,480
type changed

516
00:18:30,480 --> 00:18:32,480
and so in that case the second type

517
00:18:32,480 --> 00:18:34,240
check would have been necessary but it

518
00:18:34,240 --> 00:18:36,799
was removed so you get a type confusion

519
00:18:36,799 --> 00:18:39,120
and those again they were kind of early

520
00:18:39,120 --> 00:18:41,120
jit bucks i would say

521
00:18:41,120 --> 00:18:45,600
2018 2019-ish there was one 2020

522
00:18:45,600 --> 00:18:48,000
but yeah

523
00:18:48,240 --> 00:18:50,240
then we have this optimization here this

524
00:18:50,240 --> 00:18:53,679
one is specific to firefox

525
00:18:53,679 --> 00:18:56,160
while the others are mostly again engine

526
00:18:56,160 --> 00:18:57,679
they are kind of happening in every

527
00:18:57,679 --> 00:18:59,280
engine

528
00:18:59,280 --> 00:19:01,760
global value numbering is

529
00:19:01,760 --> 00:19:03,440
an optimization where they try to kind

530
00:19:03,440 --> 00:19:04,720
of find

531
00:19:04,720 --> 00:19:07,120
duplicate operations so it's a bit more

532
00:19:07,120 --> 00:19:08,840
generic than just the type check

533
00:19:08,840 --> 00:19:10,960
elimination for example if you're doing

534
00:19:10,960 --> 00:19:12,240
the same if you're adding the same

535
00:19:12,240 --> 00:19:13,679
values twice

536
00:19:13,679 --> 00:19:16,480
this path will figure it out and not

537
00:19:16,480 --> 00:19:19,120
make you do it twice

538
00:19:19,120 --> 00:19:21,679
and here were similar issues here

539
00:19:21,679 --> 00:19:23,440
for this to happen they are for this to

540
00:19:23,440 --> 00:19:25,280
work correctly they again needed to

541
00:19:25,280 --> 00:19:27,679
model correctly when side effects could

542
00:19:27,679 --> 00:19:29,679
happen when things could change

543
00:19:29,679 --> 00:19:31,360
this wasn't always correct it's kind of

544
00:19:31,360 --> 00:19:32,559
hard

545
00:19:32,559 --> 00:19:34,480
and it broke a few times

546
00:19:34,480 --> 00:19:36,960
what's interesting here is that this

547
00:19:36,960 --> 00:19:39,360
can lead to different types of like

548
00:19:39,360 --> 00:19:41,760
fundamental memory and safeties

549
00:19:41,760 --> 00:19:43,679
because for example if you removed if

550
00:19:43,679 --> 00:19:45,360
you exploited this bug to remove a

551
00:19:45,360 --> 00:19:47,280
bounce check you get an out of bounds

552
00:19:47,280 --> 00:19:48,160
right

553
00:19:48,160 --> 00:19:50,000
if you exploited it to remove a type

554
00:19:50,000 --> 00:19:52,240
check then you get a type confusion it's

555
00:19:52,240 --> 00:19:54,400
kind of interesting to note

556
00:19:54,400 --> 00:19:56,080
but yeah

557
00:19:56,080 --> 00:19:58,080
moving on

558
00:19:58,080 --> 00:20:00,000
really for the temporal memory safety

559
00:20:00,000 --> 00:20:02,000
there i couldn't i could only find one

560
00:20:02,000 --> 00:20:04,000
type of bug

561
00:20:04,000 --> 00:20:06,000
which has to do with gc modeling and

562
00:20:06,000 --> 00:20:08,640
write barriers now write barriers in

563
00:20:08,640 --> 00:20:10,880
javascript they mean or in garbage

564
00:20:10,880 --> 00:20:13,360
collected language what it means is if

565
00:20:13,360 --> 00:20:15,919
your collector has scanned an object

566
00:20:15,919 --> 00:20:18,320
and then this object changes then you

567
00:20:18,320 --> 00:20:20,559
need to tell the collector to rescan

568
00:20:20,559 --> 00:20:22,559
because it might now point to a new

569
00:20:22,559 --> 00:20:24,720
object

570
00:20:24,720 --> 00:20:26,880
but then again you can try to optimize

571
00:20:26,880 --> 00:20:28,880
this and figure out well if there

572
00:20:28,880 --> 00:20:30,480
couldn't have been a garbage collection

573
00:20:30,480 --> 00:20:32,559
triggered between here and here then

574
00:20:32,559 --> 00:20:34,080
surely this object couldn't have been

575
00:20:34,080 --> 00:20:35,120
marked

576
00:20:35,120 --> 00:20:38,000
and so on and i don't need this barrier

577
00:20:38,000 --> 00:20:39,840
and yeah if you do your modeling wrong

578
00:20:39,840 --> 00:20:43,840
then it again breaks this entire chain

579
00:20:44,880 --> 00:20:45,760
okay

580
00:20:45,760 --> 00:20:47,919
here are two others one is register

581
00:20:47,919 --> 00:20:49,440
allocation um

582
00:20:49,440 --> 00:20:51,760
pretty fundamental optimization or

583
00:20:51,760 --> 00:20:53,679
maybe not even an optimization i don't

584
00:20:53,679 --> 00:20:54,799
know

585
00:20:54,799 --> 00:20:55,840
which

586
00:20:55,840 --> 00:20:57,760
broke i like there's one bug that i

587
00:20:57,760 --> 00:20:58,799
could find

588
00:20:58,799 --> 00:21:01,039
it's pretty nice also but you could

589
00:21:01,039 --> 00:21:02,640
imagine this could lead to all kinds of

590
00:21:02,640 --> 00:21:05,520
issues if it goes wrong

591
00:21:05,520 --> 00:21:08,320
loop invariant code motion is the other

592
00:21:08,320 --> 00:21:10,159
so there you see a simple example for

593
00:21:10,159 --> 00:21:11,200
that

594
00:21:11,200 --> 00:21:13,440
the idea is you try to figure out if

595
00:21:13,440 --> 00:21:16,080
some operat some operation really has to

596
00:21:16,080 --> 00:21:17,440
happen in a loop

597
00:21:17,440 --> 00:21:18,960
and if it doesn't well you can move it

598
00:21:18,960 --> 00:21:21,440
in front and you save some executions at

599
00:21:21,440 --> 00:21:23,360
one time

600
00:21:23,360 --> 00:21:25,200
those types of bugs they were of the

601
00:21:25,200 --> 00:21:26,480
shape

602
00:21:26,480 --> 00:21:29,120
of this optimization moving for example

603
00:21:29,120 --> 00:21:31,200
an array access in front of the bounce

604
00:21:31,200 --> 00:21:33,200
check that doesn't work

605
00:21:33,200 --> 00:21:34,960
or it would move

606
00:21:34,960 --> 00:21:35,600
an

607
00:21:35,600 --> 00:21:37,280
access to some object in front of the

608
00:21:37,280 --> 00:21:39,600
type check right and so again this could

609
00:21:39,600 --> 00:21:42,480
give you different primitives

610
00:21:42,480 --> 00:21:44,159
maybe another interesting thing to note

611
00:21:44,159 --> 00:21:46,240
here is those bugs were specific to

612
00:21:46,240 --> 00:21:49,679
javascript core that's the safari engine

613
00:21:49,679 --> 00:21:51,760
it seems we v8 for example never had

614
00:21:51,760 --> 00:21:54,080
these issues and i think it's at least

615
00:21:54,080 --> 00:21:56,240
partially to do with how they

616
00:21:56,240 --> 00:21:58,480
represent the intermediate language they

617
00:21:58,480 --> 00:22:00,159
couldn't really move

618
00:22:00,159 --> 00:22:02,400
um an area axis in front of a bounce

619
00:22:02,400 --> 00:22:04,400
check because there's some effect edge

620
00:22:04,400 --> 00:22:06,799
between those

621
00:22:06,799 --> 00:22:08,240
but okay

622
00:22:08,240 --> 00:22:10,559
so let's um go a bit

623
00:22:10,559 --> 00:22:13,840
further in time

624
00:22:13,840 --> 00:22:16,400
so back in 2017 2018 i think a lot of

625
00:22:16,400 --> 00:22:18,400
people audited this or looked into this

626
00:22:18,400 --> 00:22:20,400
range analysis pass i mean at the end of

627
00:22:20,400 --> 00:22:22,240
the day it's one file

628
00:22:22,240 --> 00:22:24,159
you know that any bug in here gives you

629
00:22:24,159 --> 00:22:26,080
a nice exploitable bug so i think lots

630
00:22:26,080 --> 00:22:28,159
of people looked at that

631
00:22:28,159 --> 00:22:30,559
but then people started to move on

632
00:22:30,559 --> 00:22:31,600
and the

633
00:22:31,600 --> 00:22:34,640
idea here is that well even if your

634
00:22:34,640 --> 00:22:36,960
range analysis is correct

635
00:22:36,960 --> 00:22:38,320
but then if you're

636
00:22:38,320 --> 00:22:39,760
if the actual machine code that's

637
00:22:39,760 --> 00:22:42,000
generated if that is wrong you still get

638
00:22:42,000 --> 00:22:44,720
a similar primitive because you have a

639
00:22:44,720 --> 00:22:46,480
difference between what range analysis

640
00:22:46,480 --> 00:22:48,880
thinks and what is actually the value at

641
00:22:48,880 --> 00:22:50,480
runtime

642
00:22:50,480 --> 00:22:52,080
and so there were a number of bugs that

643
00:22:52,080 --> 00:22:54,480
would effectively just lead to wrong

644
00:22:54,480 --> 00:22:57,120
results being computed by a function

645
00:22:57,120 --> 00:23:00,720
which by itself is not a security issue

646
00:23:00,720 --> 00:23:02,559
but it becomes a security issue because

647
00:23:02,559 --> 00:23:04,320
it then breaks range analysis and it

648
00:23:04,320 --> 00:23:07,120
then breaks this entire chain

649
00:23:07,120 --> 00:23:09,039
so for example there were some

650
00:23:09,039 --> 00:23:11,120
what i just called pattern matching bugs

651
00:23:11,120 --> 00:23:13,679
last year

652
00:23:13,679 --> 00:23:16,240
for example there was one where

653
00:23:16,240 --> 00:23:18,240
they tried in the jit they tried to

654
00:23:18,240 --> 00:23:20,640
detect a rotation operation so

655
00:23:20,640 --> 00:23:22,400
javascript doesn't have rotation so what

656
00:23:22,400 --> 00:23:23,919
you have to do is some shifting and some

657
00:23:23,919 --> 00:23:26,559
bitwise operation they try to detect ah

658
00:23:26,559 --> 00:23:28,159
here's the bitwise operation and the

659
00:23:28,159 --> 00:23:29,760
input is the shift so maybe that's a

660
00:23:29,760 --> 00:23:31,520
rotation they would turn it into

661
00:23:31,520 --> 00:23:33,520
rotation

662
00:23:33,520 --> 00:23:35,600
but okay i guess it's going to come back

663
00:23:35,600 --> 00:23:36,960
soon

664
00:23:36,960 --> 00:23:39,039
but it wasn't always a rotation and so

665
00:23:39,039 --> 00:23:41,840
they ended up with wrong computations at

666
00:23:41,840 --> 00:23:44,320
runtime and then this breaks this entire

667
00:23:44,320 --> 00:23:45,520
chain

668
00:23:45,520 --> 00:23:47,360
similar things lowering there was one

669
00:23:47,360 --> 00:23:49,200
bug where they just used the wrong

670
00:23:49,200 --> 00:23:51,520
machine code instruction essentially

671
00:23:51,520 --> 00:23:52,880
that didn't quite have the right

672
00:23:52,880 --> 00:23:54,559
semantics

673
00:23:54,559 --> 00:23:56,400
or there was one bug with common sub

674
00:23:56,400 --> 00:23:58,720
expression elimination leading to a very

675
00:23:58,720 --> 00:24:02,880
similar thing of wrong result at runtime

676
00:24:03,039 --> 00:24:05,600
and finally a similar thing as i would

677
00:24:05,600 --> 00:24:07,600
say happened with these type inference

678
00:24:07,600 --> 00:24:08,640
bugs

679
00:24:08,640 --> 00:24:10,159
where again lots of people probably

680
00:24:10,159 --> 00:24:11,440
looked at these

681
00:24:11,440 --> 00:24:14,799
few files that did type in friends

682
00:24:14,799 --> 00:24:17,200
but then type in friends relies to some

683
00:24:17,200 --> 00:24:19,200
degree on runtime state

684
00:24:19,200 --> 00:24:22,159
so in many engines there's some objects

685
00:24:22,159 --> 00:24:24,559
can say well my my property here is a

686
00:24:24,559 --> 00:24:27,200
constant or this property has a constant

687
00:24:27,200 --> 00:24:29,520
type it's never going to change

688
00:24:29,520 --> 00:24:31,200
things like that and so then of course

689
00:24:31,200 --> 00:24:33,760
if type in french sees that can be like

690
00:24:33,760 --> 00:24:35,200
okay well if the

691
00:24:35,200 --> 00:24:36,960
runtime says this will always have this

692
00:24:36,960 --> 00:24:39,760
type then i don't need the type check

693
00:24:39,760 --> 00:24:41,919
and then those were bugs that didn't

694
00:24:41,919 --> 00:24:45,039
even necessarily happen in the jit

695
00:24:45,039 --> 00:24:46,320
they could have been elsewhere in the

696
00:24:46,320 --> 00:24:48,400
engine and some of them were but they

697
00:24:48,400 --> 00:24:51,200
kind of corrupted this um or

698
00:24:51,200 --> 00:24:54,159
violated those integrity guarantees and

699
00:24:54,159 --> 00:24:56,480
then this in turn breaks the jit and it

700
00:24:56,480 --> 00:24:59,039
breaks this chain and it goes

701
00:24:59,039 --> 00:25:01,840
to a type confusion

702
00:25:01,840 --> 00:25:04,000
cool and there we have it

703
00:25:04,000 --> 00:25:05,360
again

704
00:25:05,360 --> 00:25:07,279
the full picture

705
00:25:07,279 --> 00:25:09,039
and yeah there's lots of references

706
00:25:09,039 --> 00:25:11,600
linked here

707
00:25:11,919 --> 00:25:14,240
so i want to talk very briefly about

708
00:25:14,240 --> 00:25:16,559
exploitation of these bugs

709
00:25:16,559 --> 00:25:18,480
the the main message here is just that

710
00:25:18,480 --> 00:25:20,880
these bugs are very powerful

711
00:25:20,880 --> 00:25:22,320
and they give you a great deal of

712
00:25:22,320 --> 00:25:24,880
control so if you think of for example

713
00:25:24,880 --> 00:25:26,559
these type confusion box where you can

714
00:25:26,559 --> 00:25:30,080
remove a type check this lets you choose

715
00:25:30,080 --> 00:25:32,320
the victim type it lets you choose the

716
00:25:32,320 --> 00:25:34,320
target type and it lets you choose the

717
00:25:34,320 --> 00:25:36,640
operation you can really put

718
00:25:36,640 --> 00:25:38,720
build together your own type confusion

719
00:25:38,720 --> 00:25:39,760
bug

720
00:25:39,760 --> 00:25:41,840
anything you want and it's a similar

721
00:25:41,840 --> 00:25:44,559
thing for these spatial memory safety

722
00:25:44,559 --> 00:25:46,159
and temporal memory safety things where

723
00:25:46,159 --> 00:25:47,840
you can choose

724
00:25:47,840 --> 00:25:50,240
the area you are accessing out of bounds

725
00:25:50,240 --> 00:25:53,120
the index the size and so on so that

726
00:25:53,120 --> 00:25:55,760
really gives you a properly nice

727
00:25:55,760 --> 00:25:58,960
exploitation primitives

728
00:25:59,600 --> 00:26:02,480
good um so fairly quickly you might

729
00:26:02,480 --> 00:26:04,799
think now there's just it's all jit bugs

730
00:26:04,799 --> 00:26:06,240
these days

731
00:26:06,240 --> 00:26:07,840
it's not

732
00:26:07,840 --> 00:26:09,200
this is

733
00:26:09,200 --> 00:26:11,440
going back to the overview slides of the

734
00:26:11,440 --> 00:26:13,360
different components

735
00:26:13,360 --> 00:26:15,279
there are bugs elsewhere and this is

736
00:26:15,279 --> 00:26:18,080
just bugs from last year so the jitbox

737
00:26:18,080 --> 00:26:20,400
they were from up to six years ago so

738
00:26:20,400 --> 00:26:22,640
this is just from last year and you kind

739
00:26:22,640 --> 00:26:24,960
of see there's bugs everywhere there's

740
00:26:24,960 --> 00:26:26,559
plenty of complexity in these other

741
00:26:26,559 --> 00:26:28,080
parts

742
00:26:28,080 --> 00:26:29,840
but the thing is many of these they

743
00:26:29,840 --> 00:26:32,559
don't quite fit a good good bug pattern

744
00:26:32,559 --> 00:26:34,960
also many of these are one-off bugs

745
00:26:34,960 --> 00:26:36,840
there was one garbage collection bug for

746
00:26:36,840 --> 00:26:40,000
example dealing with weak sets where

747
00:26:40,000 --> 00:26:41,600
they didn't scan

748
00:26:41,600 --> 00:26:42,480
in

749
00:26:42,480 --> 00:26:44,240
a certain situation they wouldn't

750
00:26:44,240 --> 00:26:46,799
properly scan objects

751
00:26:46,799 --> 00:26:48,320
they were interesting bugs in the

752
00:26:48,320 --> 00:26:50,799
runtime where they would leak internal

753
00:26:50,799 --> 00:26:53,840
values to script

754
00:26:54,480 --> 00:26:56,880
yeah they were kind of classic integer

755
00:26:56,880 --> 00:26:59,760
overflow bugs in in the wasm compiler or

756
00:26:59,760 --> 00:27:01,440
other weirdnesses in the bytecode

757
00:27:01,440 --> 00:27:03,120
compiler

758
00:27:03,120 --> 00:27:05,039
but yeah again lots of links here if

759
00:27:05,039 --> 00:27:07,039
you're interested in more details

760
00:27:07,039 --> 00:27:08,880
and at this point i want to hand over to

761
00:27:08,880 --> 00:27:13,279
amy for exploitation and mitigations

762
00:27:16,400 --> 00:27:18,960
all right so we just saw a bunch of

763
00:27:18,960 --> 00:27:22,720
different bug classes mostly in the jit

764
00:27:22,720 --> 00:27:25,039
and we also saw how the jit bugs have

765
00:27:25,039 --> 00:27:27,760
grown more complex moving further away

766
00:27:27,760 --> 00:27:29,440
from the actual

767
00:27:29,440 --> 00:27:30,320
um

768
00:27:30,320 --> 00:27:32,480
you know problem with like a out of

769
00:27:32,480 --> 00:27:34,320
bounds or whatever we're getting really

770
00:27:34,320 --> 00:27:36,320
complicated into

771
00:27:36,320 --> 00:27:38,640
these complex interactions

772
00:27:38,640 --> 00:27:40,399
but i want to talk a little bit about

773
00:27:40,399 --> 00:27:43,120
the other half of javascript explication

774
00:27:43,120 --> 00:27:46,480
in 2020 which is the exploitation

775
00:27:46,480 --> 00:27:47,760
but before we can do that we have to go

776
00:27:47,760 --> 00:27:49,520
back in time slightly

777
00:27:49,520 --> 00:27:50,640
so

778
00:27:50,640 --> 00:27:52,080
let's look at what the average

779
00:27:52,080 --> 00:27:55,840
javascript exploit circa 2016 was

780
00:27:55,840 --> 00:27:57,600
now there's a couple of things

781
00:27:57,600 --> 00:27:59,919
here so the bug that you would start

782
00:27:59,919 --> 00:28:02,000
with is usually something like an out of

783
00:28:02,000 --> 00:28:05,360
bounds or maybe it is a type confusion

784
00:28:05,360 --> 00:28:06,960
which you'll know is pretty much the

785
00:28:06,960 --> 00:28:09,679
same primitives that we still get today

786
00:28:09,679 --> 00:28:11,279
as we just saw with all of our different

787
00:28:11,279 --> 00:28:13,279
jit bugs

788
00:28:13,279 --> 00:28:14,960
and then you would take that

789
00:28:14,960 --> 00:28:17,360
out of bounds or type confusion and you

790
00:28:17,360 --> 00:28:19,279
would use it to either corrupt an

791
00:28:19,279 --> 00:28:21,679
existing javascript object in the heap

792
00:28:21,679 --> 00:28:24,559
or you would try to create your own fake

793
00:28:24,559 --> 00:28:25,919
object

794
00:28:25,919 --> 00:28:28,399
in your memory and then inject that into

795
00:28:28,399 --> 00:28:30,240
the interpreter so then it tries to

796
00:28:30,240 --> 00:28:32,080
access it

797
00:28:32,080 --> 00:28:33,120
and there were a lot of different

798
00:28:33,120 --> 00:28:34,720
techniques for this

799
00:28:34,720 --> 00:28:36,799
but generally it was pretty easy to do

800
00:28:36,799 --> 00:28:38,880
for most bugs

801
00:28:38,880 --> 00:28:40,720
from there the next thing that you would

802
00:28:40,720 --> 00:28:43,120
see is trying to get an arbitrary read

803
00:28:43,120 --> 00:28:44,480
write primitive

804
00:28:44,480 --> 00:28:47,440
now this primitive was also very easy to

805
00:28:47,440 --> 00:28:49,679
do in the vast majority of cases and it

806
00:28:49,679 --> 00:28:51,840
was usually done with what's called a

807
00:28:51,840 --> 00:28:54,640
array buffer and array buffers are just

808
00:28:54,640 --> 00:28:56,720
a way for javascript to store

809
00:28:56,720 --> 00:28:58,559
some arbitrary memory somewhere you know

810
00:28:58,559 --> 00:29:00,000
maybe it wants to do some bitewise

811
00:29:00,000 --> 00:29:02,240
computations it needs a buffer to do

812
00:29:02,240 --> 00:29:04,880
that so that's a great target for

813
00:29:04,880 --> 00:29:07,200
hijacking because if we can corrupt

814
00:29:07,200 --> 00:29:08,880
where that buffer is pointing well that

815
00:29:08,880 --> 00:29:10,880
gives us a really easy primitive for

816
00:29:10,880 --> 00:29:12,399
arbitrary read write so that's what we'd

817
00:29:12,399 --> 00:29:14,000
usually see

818
00:29:14,000 --> 00:29:15,200
and then you're probably thinking okay

819
00:29:15,200 --> 00:29:17,039
well the next step of an x-play is you

820
00:29:17,039 --> 00:29:18,000
know you

821
00:29:18,000 --> 00:29:19,520
get your rock chain you find all your

822
00:29:19,520 --> 00:29:22,159
gadgets don't even need that in 2016

823
00:29:22,159 --> 00:29:24,159
most of these engines still had read

824
00:29:24,159 --> 00:29:26,720
write execute jit pages which means all

825
00:29:26,720 --> 00:29:29,039
you had to do is get a function that was

826
00:29:29,039 --> 00:29:30,240
compiled

827
00:29:30,240 --> 00:29:32,720
smash the code with your arbitrary read

828
00:29:32,720 --> 00:29:35,279
write and you're good to go

829
00:29:35,279 --> 00:29:36,159
so

830
00:29:36,159 --> 00:29:39,200
honestly pretty easy exploit chains

831
00:29:39,200 --> 00:29:42,240
but now we're in 2022 so let's see if

832
00:29:42,240 --> 00:29:45,039
it's gotten any more difficult

833
00:29:45,039 --> 00:29:47,039
now the first thing i want to talk about

834
00:29:47,039 --> 00:29:50,559
a little bit is how effective classical

835
00:29:50,559 --> 00:29:52,240
mitigations are

836
00:29:52,240 --> 00:29:54,399
um i'm sure a lot of you probably

837
00:29:54,399 --> 00:29:58,159
recognize these aslr dep stack cookies

838
00:29:58,159 --> 00:30:00,720
but honestly these are not very

839
00:30:00,720 --> 00:30:02,480
important when we're exploiting

840
00:30:02,480 --> 00:30:03,919
javascript

841
00:30:03,919 --> 00:30:06,159
partly due to how powerful javascript is

842
00:30:06,159 --> 00:30:08,000
in the first place

843
00:30:08,000 --> 00:30:10,320
the primitives that we get from the

844
00:30:10,320 --> 00:30:12,320
types of bugs that we're looking at

845
00:30:12,320 --> 00:30:14,480
usually give us a way to read memory

846
00:30:14,480 --> 00:30:17,120
either out of bounds or potentially

847
00:30:17,120 --> 00:30:20,480
confuse a pointer with like a floating

848
00:30:20,480 --> 00:30:22,399
point so that we can read it and leak

849
00:30:22,399 --> 00:30:25,039
that memory so aslr most of the time you

850
00:30:25,039 --> 00:30:26,559
do not need like a second bug or

851
00:30:26,559 --> 00:30:29,520
anything like that to bypass

852
00:30:29,520 --> 00:30:31,679
additionally for

853
00:30:31,679 --> 00:30:34,000
dep or nx where it's trying to prevent

854
00:30:34,000 --> 00:30:36,080
you from having your own executable show

855
00:30:36,080 --> 00:30:36,960
code

856
00:30:36,960 --> 00:30:38,720
well that doesn't really matter because

857
00:30:38,720 --> 00:30:39,919
we have a jit

858
00:30:39,919 --> 00:30:41,840
and regardless of being able to write

859
00:30:41,840 --> 00:30:44,559
the code into the jit we can also trick

860
00:30:44,559 --> 00:30:46,880
the jit compiler into adding our code

861
00:30:46,880 --> 00:30:48,399
there anyway

862
00:30:48,399 --> 00:30:50,399
through various methods so that doesn't

863
00:30:50,399 --> 00:30:52,159
really matter either and then finally

864
00:30:52,159 --> 00:30:54,640
stack cookies most of the bugs involve

865
00:30:54,640 --> 00:30:56,559
the heap we very rarely see something

866
00:30:56,559 --> 00:30:59,279
that's just like a stack overflow

867
00:30:59,279 --> 00:31:02,320
a lot of this stuff is logic bugs so

868
00:31:02,320 --> 00:31:05,600
fat cookies don't really have any effect

869
00:31:05,600 --> 00:31:08,159
but what about more modern mitigations

870
00:31:08,159 --> 00:31:09,519
and when we're thinking about modern

871
00:31:09,519 --> 00:31:11,679
mitigations we're usually thinking about

872
00:31:11,679 --> 00:31:14,799
uh control flow integrity

873
00:31:14,799 --> 00:31:16,960
or control flow enforcement and this is

874
00:31:16,960 --> 00:31:18,640
going to give us

875
00:31:18,640 --> 00:31:21,600
a couple of different ways to prevent

876
00:31:21,600 --> 00:31:23,279
code from jumping

877
00:31:23,279 --> 00:31:24,240
to

878
00:31:24,240 --> 00:31:26,720
an unexpected area so either to shell

879
00:31:26,720 --> 00:31:29,679
code or to like a rock chain

880
00:31:29,679 --> 00:31:30,559
and there's a couple of different

881
00:31:30,559 --> 00:31:32,399
flavors here so

882
00:31:32,399 --> 00:31:33,120
on

883
00:31:33,120 --> 00:31:35,200
newer arm devices we have pointer

884
00:31:35,200 --> 00:31:38,240
authentication usually called pac

885
00:31:38,240 --> 00:31:40,480
and also even more recently in the spec

886
00:31:40,480 --> 00:31:43,039
we have branch target identification

887
00:31:43,039 --> 00:31:45,279
these try to make it hard to

888
00:31:45,279 --> 00:31:47,919
call invalid pointers as well as making

889
00:31:47,919 --> 00:31:50,480
it hard to jump into code which should

890
00:31:50,480 --> 00:31:52,080
not be jumped into

891
00:31:52,080 --> 00:31:55,200
on modern intel chips we've got shadow

892
00:31:55,200 --> 00:31:56,240
stack

893
00:31:56,240 --> 00:31:57,840
which tries to protect return addresses

894
00:31:57,840 --> 00:32:00,320
and we've also got our control flow

895
00:32:00,320 --> 00:32:02,399
enforcement tech which is going to again

896
00:32:02,399 --> 00:32:04,399
try to prevent rop

897
00:32:04,399 --> 00:32:05,919
and on the software side of things on

898
00:32:05,919 --> 00:32:08,240
windows for quite a while we've had cfg

899
00:32:08,240 --> 00:32:10,640
which is going to try to prevent again

900
00:32:10,640 --> 00:32:13,200
invalid jumps

901
00:32:13,200 --> 00:32:14,480
it doesn't really do a whole lot for

902
00:32:14,480 --> 00:32:16,080
return addresses

903
00:32:16,080 --> 00:32:18,399
so okay it's 2022 we've got modern

904
00:32:18,399 --> 00:32:21,039
hardware you know these should all be

905
00:32:21,039 --> 00:32:22,720
helping us out here

906
00:32:22,720 --> 00:32:24,799
but when we actually go and look at the

907
00:32:24,799 --> 00:32:27,279
implementations and support within our

908
00:32:27,279 --> 00:32:30,080
javascript engines it's mostly not there

909
00:32:30,080 --> 00:32:32,000
yet

910
00:32:32,000 --> 00:32:34,240
the one that we kind of do see and we'll

911
00:32:34,240 --> 00:32:35,600
have to deal with is point

912
00:32:35,600 --> 00:32:37,519
authentication on

913
00:32:37,519 --> 00:32:41,200
our safari devices

914
00:32:41,200 --> 00:32:44,159
but v8 and chromium um they're still

915
00:32:44,159 --> 00:32:46,559
working on having full implementation of

916
00:32:46,559 --> 00:32:48,799
a lot of these now chromium does support

917
00:32:48,799 --> 00:32:50,720
some of these pretty well

918
00:32:50,720 --> 00:32:52,880
but the problem in a lot of these cases

919
00:32:52,880 --> 00:32:56,080
is the compiler the jit doesn't really

920
00:32:56,080 --> 00:32:58,080
uh have full support for these which

921
00:32:58,080 --> 00:32:59,919
makes it fairly easy to bypass in a lot

922
00:32:59,919 --> 00:33:01,440
of cases when we're dealing with just

923
00:33:01,440 --> 00:33:03,440
the javascript engine itself now of

924
00:33:03,440 --> 00:33:05,600
course something like the sandbox

925
00:33:05,600 --> 00:33:07,600
might be a bit harder to deal with some

926
00:33:07,600 --> 00:33:08,640
of these but we're focusing on

927
00:33:08,640 --> 00:33:11,440
javascript here

928
00:33:11,440 --> 00:33:13,200
um okay so

929
00:33:13,200 --> 00:33:14,399
i want to talk a little bit more about

930
00:33:14,399 --> 00:33:16,080
pointer authentication

931
00:33:16,080 --> 00:33:17,120
since

932
00:33:17,120 --> 00:33:19,360
that is one of the

933
00:33:19,360 --> 00:33:20,799
bigger things that you may have to deal

934
00:33:20,799 --> 00:33:23,440
with if you're looking at safari

935
00:33:23,440 --> 00:33:25,519
and you're trying to exploit an ios

936
00:33:25,519 --> 00:33:27,760
device or some of the newer macbooks

937
00:33:27,760 --> 00:33:29,600
which benefit from this

938
00:33:29,600 --> 00:33:31,360
so if you're not familiar with it the

939
00:33:31,360 --> 00:33:33,840
idea of pointer authentication is that

940
00:33:33,840 --> 00:33:36,559
you can cryptographically sign a pointer

941
00:33:36,559 --> 00:33:38,880
in such a way that when you use it you

942
00:33:38,880 --> 00:33:41,519
can verify that the pointer has not been

943
00:33:41,519 --> 00:33:43,679
changed or rather that the bits at the

944
00:33:43,679 --> 00:33:47,679
top of it match the bits at the bottom

945
00:33:47,679 --> 00:33:49,600
and it does this through some hardware

946
00:33:49,600 --> 00:33:51,919
instructions which can use keys that can

947
00:33:51,919 --> 00:33:54,399
be loaded in various ways

948
00:33:54,399 --> 00:33:55,919
so we've got the pac instructions which

949
00:33:55,919 --> 00:33:57,919
do the actual signing and the ot

950
00:33:57,919 --> 00:33:59,919
instructions which can verify and then

951
00:33:59,919 --> 00:34:02,000
there's also instructions that let you

952
00:34:02,000 --> 00:34:04,080
do things like an atomic verify and

953
00:34:04,080 --> 00:34:07,039
branch or verify and return so that you

954
00:34:07,039 --> 00:34:08,800
avoid race conditions

955
00:34:08,800 --> 00:34:11,520
and as an example here we have this is a

956
00:34:11,520 --> 00:34:14,320
pointer to the jit and we can

957
00:34:14,320 --> 00:34:16,320
see the pack version and we can see the

958
00:34:16,320 --> 00:34:19,040
upper bits are now set to

959
00:34:19,040 --> 00:34:21,440
our signature

960
00:34:21,440 --> 00:34:23,520
now if i were to try to corrupt this and

961
00:34:23,520 --> 00:34:24,879
use it

962
00:34:24,879 --> 00:34:26,480
like we see on the side

963
00:34:26,480 --> 00:34:27,679
when it actually goes through these

964
00:34:27,679 --> 00:34:29,760
instructions the pointer is going to end

965
00:34:29,760 --> 00:34:31,520
up like this it's going to have this

966
00:34:31,520 --> 00:34:34,079
high bit set which will make it invalid

967
00:34:34,079 --> 00:34:35,679
and so when you try to use it you end up

968
00:34:35,679 --> 00:34:37,679
crashing

969
00:34:37,679 --> 00:34:40,079
so this can be kind of um you know

970
00:34:40,079 --> 00:34:42,719
tricky to deal with if you are trying to

971
00:34:42,719 --> 00:34:44,879
jump to your rock chain or jump to shell

972
00:34:44,879 --> 00:34:46,839
code at the end of an

973
00:34:46,839 --> 00:34:49,440
exploit so let's think about some

974
00:34:49,440 --> 00:34:51,520
strategies of how we can get around this

975
00:34:51,520 --> 00:34:53,440
now first off i want to say at this

976
00:34:53,440 --> 00:34:55,359
point you know pax banner been around

977
00:34:55,359 --> 00:34:57,440
for a few years now

978
00:34:57,440 --> 00:34:59,680
and bypasses you could kind of consider

979
00:34:59,680 --> 00:35:02,400
them similar to bugs right if if

980
00:35:02,400 --> 00:35:03,280
you

981
00:35:03,280 --> 00:35:05,680
have a bypass that's public it's

982
00:35:05,680 --> 00:35:06,800
probably going to get patched pretty

983
00:35:06,800 --> 00:35:08,400
quickly by vendors

984
00:35:08,400 --> 00:35:10,560
and also if you're trying to work on

985
00:35:10,560 --> 00:35:12,160
this for your exploit you might need to

986
00:35:12,160 --> 00:35:14,160
do some research

987
00:35:14,160 --> 00:35:15,839
independently try to find your own

988
00:35:15,839 --> 00:35:17,839
bypass maintain it

989
00:35:17,839 --> 00:35:19,839
but that's usually a

990
00:35:19,839 --> 00:35:23,839
one-time cost as long as you keep your

991
00:35:23,839 --> 00:35:25,680
bypass alive

992
00:35:25,680 --> 00:35:27,119
since you can then reuse it for any

993
00:35:27,119 --> 00:35:29,119
other exploits

994
00:35:29,119 --> 00:35:31,200
um but just to give you an example of

995
00:35:31,200 --> 00:35:32,480
what some of these

996
00:35:32,480 --> 00:35:33,920
bypasses might look like and these are

997
00:35:33,920 --> 00:35:36,480
really strict bypasses where you end up

998
00:35:36,480 --> 00:35:38,240
with a pointer

999
00:35:38,240 --> 00:35:39,760
like an arbitrary pointer that you can

1000
00:35:39,760 --> 00:35:41,760
sign or a pointer that jumps somewhere

1001
00:35:41,760 --> 00:35:43,839
that it's not supposed to

1002
00:35:43,839 --> 00:35:45,760
one of the big ones is pointer forgery

1003
00:35:45,760 --> 00:35:47,520
and the idea of this is tricking the

1004
00:35:47,520 --> 00:35:48,560
program

1005
00:35:48,560 --> 00:35:51,359
into compiling or sorry

1006
00:35:51,359 --> 00:35:53,040
assigning

1007
00:35:53,040 --> 00:35:55,680
an arbitrary pointer for you

1008
00:35:55,680 --> 00:35:56,480
and

1009
00:35:56,480 --> 00:35:58,480
this is a bit easier when you have

1010
00:35:58,480 --> 00:36:00,240
something like an arbitrary read write

1011
00:36:00,240 --> 00:36:01,760
because for example all you have to do

1012
00:36:01,760 --> 00:36:04,000
is look for writable memory that happens

1013
00:36:04,000 --> 00:36:05,440
to get signed so you can look for that

1014
00:36:05,440 --> 00:36:08,000
control flow in your program and try to

1015
00:36:08,000 --> 00:36:09,040
hit it

1016
00:36:09,040 --> 00:36:10,320
and there is at least one example of

1017
00:36:10,320 --> 00:36:12,800
this in webkit and you can get some more

1018
00:36:12,800 --> 00:36:14,240
information on the ref that's linked

1019
00:36:14,240 --> 00:36:16,960
there but this is what it looked like so

1020
00:36:16,960 --> 00:36:20,079
it was loading this pow function it

1021
00:36:20,079 --> 00:36:21,920
would then would be used by the jit so

1022
00:36:21,920 --> 00:36:23,680
that the you know if you're calling

1023
00:36:23,680 --> 00:36:25,839
math.pal later on

1024
00:36:25,839 --> 00:36:27,680
and it would load this pointer from this

1025
00:36:27,680 --> 00:36:29,520
writable page of memory

1026
00:36:29,520 --> 00:36:32,079
run our pack function and sign it

1027
00:36:32,079 --> 00:36:34,079
but of course if we have arbitrary write

1028
00:36:34,079 --> 00:36:36,720
we can overwrite that pointer and have

1029
00:36:36,720 --> 00:36:38,560
it sign something arbitrary instead and

1030
00:36:38,560 --> 00:36:40,400
use that

1031
00:36:40,400 --> 00:36:42,240
now i do want to point out again we're

1032
00:36:42,240 --> 00:36:45,119
mostly talking about safari here uh

1033
00:36:45,119 --> 00:36:47,520
chrome and v8 are

1034
00:36:47,520 --> 00:36:49,440
you know improving their pac support but

1035
00:36:49,440 --> 00:36:51,280
as i mentioned jitted code is not

1036
00:36:51,280 --> 00:36:53,599
currently supported so that's a bit more

1037
00:36:53,599 --> 00:36:55,920
of an easy bypass in terms of dealing

1038
00:36:55,920 --> 00:36:57,760
with like a newer android device that

1039
00:36:57,760 --> 00:37:00,160
has pac

1040
00:37:00,160 --> 00:37:03,119
uh but you know this is maybe far

1041
00:37:03,119 --> 00:37:05,680
and few between trying to find these

1042
00:37:05,680 --> 00:37:08,000
kinds of things so what else can we do

1043
00:37:08,000 --> 00:37:09,839
well we can kind of think about what

1044
00:37:09,839 --> 00:37:11,920
we're doing right now right we're

1045
00:37:11,920 --> 00:37:14,240
running javascript code and we've kind

1046
00:37:14,240 --> 00:37:15,920
of given it more permissions we've given

1047
00:37:15,920 --> 00:37:18,880
it the ability to read and write memory

1048
00:37:18,880 --> 00:37:21,200
so what if we can try to continue to

1049
00:37:21,200 --> 00:37:23,040
give it different functionality without

1050
00:37:23,040 --> 00:37:25,680
explicitly getting code execution

1051
00:37:25,680 --> 00:37:27,040
and this is partly something that you

1052
00:37:27,040 --> 00:37:29,040
could do because there's a lot of

1053
00:37:29,040 --> 00:37:30,960
functionality in the browser which is

1054
00:37:30,960 --> 00:37:32,320
kind of the functionality you might want

1055
00:37:32,320 --> 00:37:34,320
for something like a sandbox escape for

1056
00:37:34,320 --> 00:37:37,680
example certain syscalls or doing ipc

1057
00:37:37,680 --> 00:37:40,079
um to the broker or maybe other parts of

1058
00:37:40,079 --> 00:37:42,240
the operating system that already pretty

1059
00:37:42,240 --> 00:37:44,800
much exists since it's needed to be used

1060
00:37:44,800 --> 00:37:46,320
anyway

1061
00:37:46,320 --> 00:37:48,240
so what you might want to look for is

1062
00:37:48,240 --> 00:37:50,560
things that you can call from javascript

1063
00:37:50,560 --> 00:37:52,000
usually through

1064
00:37:52,000 --> 00:37:54,400
some bound api like one of the many many

1065
00:37:54,400 --> 00:37:56,640
web apis that exist

1066
00:37:56,640 --> 00:37:57,680
and then

1067
00:37:57,680 --> 00:38:01,760
corrupt the data that that api then uses

1068
00:38:01,760 --> 00:38:03,520
in some way to

1069
00:38:03,520 --> 00:38:05,200
create a

1070
00:38:05,200 --> 00:38:08,160
outcome which is favorable to you

1071
00:38:08,160 --> 00:38:10,400
so we kind of call this scripted code

1072
00:38:10,400 --> 00:38:12,079
execution

1073
00:38:12,079 --> 00:38:13,839
because you're writing you you're not

1074
00:38:13,839 --> 00:38:15,520
getting actual code execution you're

1075
00:38:15,520 --> 00:38:17,119
still in your javascript

1076
00:38:17,119 --> 00:38:20,240
script but you're calling and using

1077
00:38:20,240 --> 00:38:21,599
these different functionalities that

1078
00:38:21,599 --> 00:38:24,560
already exist without needing to corrupt

1079
00:38:24,560 --> 00:38:26,640
these protected pointers

1080
00:38:26,640 --> 00:38:28,880
now a good example of this which has

1081
00:38:28,880 --> 00:38:31,119
mostly been mitigated recently is

1082
00:38:31,119 --> 00:38:33,520
objective-c selectors so what you could

1083
00:38:33,520 --> 00:38:35,280
do is you could find these objective-c

1084
00:38:35,280 --> 00:38:37,520
calls that you could reach from normal

1085
00:38:37,520 --> 00:38:39,119
javascript functions

1086
00:38:39,119 --> 00:38:41,520
and then give them corrupted

1087
00:38:41,520 --> 00:38:43,440
objective-c objects that set up this

1088
00:38:43,440 --> 00:38:46,000
whole chain of library calls and do

1089
00:38:46,000 --> 00:38:47,440
mostly what you want and there's some

1090
00:38:47,440 --> 00:38:48,800
good examples of this if you want to

1091
00:38:48,800 --> 00:38:50,960
kind of see what that looked like

1092
00:38:50,960 --> 00:38:52,560
but that's an idea of what we're talking

1093
00:38:52,560 --> 00:38:54,960
about here

1094
00:38:55,040 --> 00:38:58,240
now going from even here

1095
00:38:58,240 --> 00:39:00,079
you can what if you don't even you can't

1096
00:39:00,079 --> 00:39:02,160
find the functionality you need

1097
00:39:02,160 --> 00:39:03,839
well you can potentially even think

1098
00:39:03,839 --> 00:39:07,040
about other targets for a write

1099
00:39:07,040 --> 00:39:09,280
now we've got a lot of things going on

1100
00:39:09,280 --> 00:39:11,119
in our browser not everything we can

1101
00:39:11,119 --> 00:39:14,000
directly control from javascript

1102
00:39:14,000 --> 00:39:15,520
there's going to be a bunch of like ipc

1103
00:39:15,520 --> 00:39:16,720
stuff going on in the background for

1104
00:39:16,720 --> 00:39:18,640
example that you can't like directly

1105
00:39:18,640 --> 00:39:20,800
call and say do this ipc right now with

1106
00:39:20,800 --> 00:39:22,720
this data

1107
00:39:22,720 --> 00:39:24,880
but the data for that ipc is still in

1108
00:39:24,880 --> 00:39:26,800
your process for example

1109
00:39:26,800 --> 00:39:28,720
so you could potentially use your

1110
00:39:28,720 --> 00:39:32,079
arbitrary read write to try to attack

1111
00:39:32,079 --> 00:39:34,800
the integrity of that data that's going

1112
00:39:34,800 --> 00:39:38,160
across the ipc or also potentially try

1113
00:39:38,160 --> 00:39:41,040
to get infra extra sensitive information

1114
00:39:41,040 --> 00:39:43,119
to be leaked into your process so that

1115
00:39:43,119 --> 00:39:44,960
you can then read it

1116
00:39:44,960 --> 00:39:45,920
um

1117
00:39:45,920 --> 00:39:48,240
so again an example would be

1118
00:39:48,240 --> 00:39:51,440
finding the buffer for the ipc

1119
00:39:51,440 --> 00:39:53,440
smashing the data as it goes out so that

1120
00:39:53,440 --> 00:39:54,400
you know you're actually calling

1121
00:39:54,400 --> 00:39:55,760
something different than what the

1122
00:39:55,760 --> 00:39:57,760
original code expected and again you

1123
00:39:57,760 --> 00:40:01,119
wouldn't need code execution to do this

1124
00:40:01,119 --> 00:40:03,119
but this can kind of cause a little bit

1125
00:40:03,119 --> 00:40:05,040
of an issue which is that you're

1126
00:40:05,040 --> 00:40:07,200
creating new race conditions

1127
00:40:07,200 --> 00:40:08,960
you have your ipc thread or whatever

1128
00:40:08,960 --> 00:40:10,720
you're targeting which is going to be

1129
00:40:10,720 --> 00:40:12,319
running and trying to send out all its

1130
00:40:12,319 --> 00:40:14,400
messages meanwhile your javascript

1131
00:40:14,400 --> 00:40:16,560
thread is trying to get in there write

1132
00:40:16,560 --> 00:40:18,880
its malicious data and hopefully not

1133
00:40:18,880 --> 00:40:20,079
crash

1134
00:40:20,079 --> 00:40:21,520
and that can be kind of dangerous and

1135
00:40:21,520 --> 00:40:23,680
unreliable

1136
00:40:23,680 --> 00:40:25,920
if you don't necessarily know if you're

1137
00:40:25,920 --> 00:40:27,280
right is going to happen at the correct

1138
00:40:27,280 --> 00:40:28,400
time

1139
00:40:28,400 --> 00:40:29,760
so you usually want to figure out a way

1140
00:40:29,760 --> 00:40:30,560
to

1141
00:40:30,560 --> 00:40:33,599
improve your reliability here

1142
00:40:33,599 --> 00:40:36,880
partly through something like exploiting

1143
00:40:36,880 --> 00:40:40,319
a linked list so one common or one

1144
00:40:40,319 --> 00:40:43,280
technique that we've seen to do this is

1145
00:40:43,280 --> 00:40:45,440
if we find a linked list structure that

1146
00:40:45,440 --> 00:40:47,520
is being used on some of these paths

1147
00:40:47,520 --> 00:40:49,839
that we want to target we can corrupt it

1148
00:40:49,839 --> 00:40:52,000
with our arbitrary read write to create

1149
00:40:52,000 --> 00:40:53,680
this infinite loop

1150
00:40:53,680 --> 00:40:55,280
then while that thread is chewing on the

1151
00:40:55,280 --> 00:40:57,520
infinite loop we've eliminated our race

1152
00:40:57,520 --> 00:40:59,599
condition we go in with our right

1153
00:40:59,599 --> 00:41:01,280
clean up everything

1154
00:41:01,280 --> 00:41:03,040
fixed the link list and now it continues

1155
00:41:03,040 --> 00:41:04,720
on its way without ever knowing that we

1156
00:41:04,720 --> 00:41:06,480
were there

1157
00:41:06,480 --> 00:41:08,319
so this is just an exploitation trick to

1158
00:41:08,319 --> 00:41:10,640
try to make these sort of races a bit

1159
00:41:10,640 --> 00:41:13,200
more winnable

1160
00:41:13,200 --> 00:41:14,000
but

1161
00:41:14,000 --> 00:41:15,119
maybe you

1162
00:41:15,119 --> 00:41:17,359
don't care that much about escaping the

1163
00:41:17,359 --> 00:41:19,280
sandbox because to be honest there's

1164
00:41:19,280 --> 00:41:20,400
quite a bit of

1165
00:41:20,400 --> 00:41:22,960
interesting data in the browser itself

1166
00:41:22,960 --> 00:41:25,359
what if we could get some of that data

1167
00:41:25,359 --> 00:41:27,520
into our process so that we can then

1168
00:41:27,520 --> 00:41:28,480
read it

1169
00:41:28,480 --> 00:41:30,240
instead of trying to get out of the

1170
00:41:30,240 --> 00:41:32,480
process and then reading it

1171
00:41:32,480 --> 00:41:34,560
so one way that we can kind of do this

1172
00:41:34,560 --> 00:41:36,240
at least in safari

1173
00:41:36,240 --> 00:41:38,880
is we can use something like an iframe

1174
00:41:38,880 --> 00:41:41,200
or different network requests to a

1175
00:41:41,200 --> 00:41:43,119
different website

1176
00:41:43,119 --> 00:41:45,359
now normally there's a thing called same

1177
00:41:45,359 --> 00:41:48,640
origin policy which tries to protect

1178
00:41:48,640 --> 00:41:50,319
a website from accessing data from

1179
00:41:50,319 --> 00:41:52,480
another site so you know attacker.com

1180
00:41:52,480 --> 00:41:54,880
can't read your gmail for example

1181
00:41:54,880 --> 00:41:56,400
but

1182
00:41:56,400 --> 00:41:58,079
if you were to load a site into an

1183
00:41:58,079 --> 00:41:59,359
iframe

1184
00:41:59,359 --> 00:42:00,079
the

1185
00:42:00,079 --> 00:42:01,839
process needs to actually be able to

1186
00:42:01,839 --> 00:42:03,440
access that iframe to do things like

1187
00:42:03,440 --> 00:42:06,160
sending messages and a lot of cases it

1188
00:42:06,160 --> 00:42:07,520
needs to figure things out like you know

1189
00:42:07,520 --> 00:42:09,440
if you click somewhere on the screen

1190
00:42:09,440 --> 00:42:11,680
it has to get into that iframe and

1191
00:42:11,680 --> 00:42:13,680
process everything that's happening and

1192
00:42:13,680 --> 00:42:16,800
so you know historically the easiest way

1193
00:42:16,800 --> 00:42:18,960
to do that was to just put that data in

1194
00:42:18,960 --> 00:42:20,640
the same process so you don't have to

1195
00:42:20,640 --> 00:42:22,480
worry about going between processes

1196
00:42:22,480 --> 00:42:24,160
every time

1197
00:42:24,160 --> 00:42:26,640
but this creates a problem where now

1198
00:42:26,640 --> 00:42:29,680
a compromised process can read that data

1199
00:42:29,680 --> 00:42:32,000
potentially inject scripts into that

1200
00:42:32,000 --> 00:42:32,880
site

1201
00:42:32,880 --> 00:42:34,720
compromise the accounts that are logged

1202
00:42:34,720 --> 00:42:38,560
in potentially mess with persistent data

1203
00:42:38,560 --> 00:42:39,760
potentially even do something like

1204
00:42:39,760 --> 00:42:41,599
install a service worker so that later

1205
00:42:41,599 --> 00:42:44,160
on when the site is accessed you still

1206
00:42:44,160 --> 00:42:46,960
have your javascript execution in that

1207
00:42:46,960 --> 00:42:48,240
site

1208
00:42:48,240 --> 00:42:50,560
um so this is actually pretty effective

1209
00:42:50,560 --> 00:42:52,560
if you have sensitive data in the

1210
00:42:52,560 --> 00:42:54,079
browser itself

1211
00:42:54,079 --> 00:42:56,000
which is one reason you may want to have

1212
00:42:56,000 --> 00:42:59,040
things like cookies turned off or

1213
00:42:59,040 --> 00:43:01,200
automatically log out of things fairly

1214
00:43:01,200 --> 00:43:03,119
often

1215
00:43:03,119 --> 00:43:04,319
but anyway

1216
00:43:04,319 --> 00:43:06,800
this has been slightly mitigated

1217
00:43:06,800 --> 00:43:08,880
in at least two browsers

1218
00:43:08,880 --> 00:43:11,119
more recently so both chrome and i

1219
00:43:11,119 --> 00:43:12,880
believe firefox in like one of the most

1220
00:43:12,880 --> 00:43:15,040
recent major updates or maybe it's on

1221
00:43:15,040 --> 00:43:17,280
nightly right now uh have implemented a

1222
00:43:17,280 --> 00:43:19,280
thing called site isolation

1223
00:43:19,280 --> 00:43:21,760
and the idea of site isolation is that

1224
00:43:21,760 --> 00:43:24,400
rather than having our

1225
00:43:24,400 --> 00:43:26,720
iframe inside of the current process

1226
00:43:26,720 --> 00:43:28,240
it's actually going to be in a separate

1227
00:43:28,240 --> 00:43:30,560
process reserved for that site so we can

1228
00:43:30,560 --> 00:43:32,880
no longer directly access that data and

1229
00:43:32,880 --> 00:43:35,280
instead we have to go through the ipc so

1230
00:43:35,280 --> 00:43:37,200
this kind of solves that problem now

1231
00:43:37,200 --> 00:43:39,359
there's a few kind of edge cases they're

1232
00:43:39,359 --> 00:43:41,440
like sub domains can be in the same

1233
00:43:41,440 --> 00:43:44,880
process unless you turn on some better

1234
00:43:44,880 --> 00:43:47,359
settings but they kind of want those off

1235
00:43:47,359 --> 00:43:48,960
because the more processes the more

1236
00:43:48,960 --> 00:43:50,800
memory usage and you know chrome already

1237
00:43:50,800 --> 00:43:52,839
uses so much ram anyway

1238
00:43:52,839 --> 00:43:56,240
um so anyway this is one thing that you

1239
00:43:56,240 --> 00:43:59,119
can still do at least in safari

1240
00:43:59,119 --> 00:44:00,560
okay

1241
00:44:00,560 --> 00:44:03,200
so at this point we kind of get the idea

1242
00:44:03,200 --> 00:44:05,200
that the first part of our exploitation

1243
00:44:05,200 --> 00:44:06,800
is pretty easy still

1244
00:44:06,800 --> 00:44:08,800
but now it's maybe a little harder to

1245
00:44:08,800 --> 00:44:10,880
get our end game but there's multiple

1246
00:44:10,880 --> 00:44:12,720
things that we can do there's different

1247
00:44:12,720 --> 00:44:14,480
strategies we can take depending on what

1248
00:44:14,480 --> 00:44:17,119
where our goal is in our exploit

1249
00:44:17,119 --> 00:44:20,319
so it's not really like game over yet

1250
00:44:20,319 --> 00:44:22,880
it's still fairly viable to complete

1251
00:44:22,880 --> 00:44:26,640
this and go for like a sandbox escape

1252
00:44:26,640 --> 00:44:29,119
um so maybe the vendors have started

1253
00:44:29,119 --> 00:44:31,200
looking a little bit further up and

1254
00:44:31,200 --> 00:44:32,800
trying to see well this arbitrary read

1255
00:44:32,800 --> 00:44:34,960
write is really powerful can they

1256
00:44:34,960 --> 00:44:37,119
mitigate that to make it harder for an

1257
00:44:37,119 --> 00:44:38,560
attacker to get that primitive in the

1258
00:44:38,560 --> 00:44:40,560
first place

1259
00:44:40,560 --> 00:44:42,640
and one way that this has started being

1260
00:44:42,640 --> 00:44:45,520
done is through pointer caging

1261
00:44:45,520 --> 00:44:47,440
the idea of this is that

1262
00:44:47,440 --> 00:44:50,079
if pointers can be restricted to only go

1263
00:44:50,079 --> 00:44:52,240
into certain regions of memory

1264
00:44:52,240 --> 00:44:54,319
then even if you have an arbitrary

1265
00:44:54,319 --> 00:44:56,400
pointer you can't really do a whole lot

1266
00:44:56,400 --> 00:44:58,319
with it if all you can do is access a

1267
00:44:58,319 --> 00:45:00,640
certain heap region

1268
00:45:00,640 --> 00:45:03,359
so the first real implementation of this

1269
00:45:03,359 --> 00:45:05,119
is in javascript core which is against

1270
00:45:05,119 --> 00:45:07,599
safari's javascript engine

1271
00:45:07,599 --> 00:45:09,680
they call it gigacage

1272
00:45:09,680 --> 00:45:11,920
and it's essentially this large region

1273
00:45:11,920 --> 00:45:13,680
of heap memory

1274
00:45:13,680 --> 00:45:14,640
which

1275
00:45:14,640 --> 00:45:15,760
you can then

1276
00:45:15,760 --> 00:45:17,760
tag any pointer so you can see here

1277
00:45:17,760 --> 00:45:20,079
there's this thing called caged pointer

1278
00:45:20,079 --> 00:45:22,000
you can put that type on any pointer you

1279
00:45:22,000 --> 00:45:24,640
want and it will force it to always

1280
00:45:24,640 --> 00:45:26,640
point into this cage and essentially

1281
00:45:26,640 --> 00:45:28,880
does that by masking off the upper bits

1282
00:45:28,880 --> 00:45:31,119
and just adding it as an offset so

1283
00:45:31,119 --> 00:45:32,960
really it just turns it into an offset

1284
00:45:32,960 --> 00:45:34,319
into the heap rather than an actual

1285
00:45:34,319 --> 00:45:36,079
pointer

1286
00:45:36,079 --> 00:45:37,359
and you can see the first thing that

1287
00:45:37,359 --> 00:45:39,119
they really applied it to was the array

1288
00:45:39,119 --> 00:45:40,079
buffer

1289
00:45:40,079 --> 00:45:42,000
as i mentioned before you know a lot of

1290
00:45:42,000 --> 00:45:43,920
older exploits pretty much every time

1291
00:45:43,920 --> 00:45:46,880
they use a ray buffer so easy uh so this

1292
00:45:46,880 --> 00:45:49,359
makes array buffer less viable

1293
00:45:49,359 --> 00:45:51,440
but there's kind of a few

1294
00:45:51,440 --> 00:45:53,200
well actually first so here's an example

1295
00:45:53,200 --> 00:45:54,640
of what this looks like

1296
00:45:54,640 --> 00:45:56,800
it also has these runways on either side

1297
00:45:56,800 --> 00:45:58,720
so that you can't just go out of bounds

1298
00:45:58,720 --> 00:46:00,560
with like a very large length and a very

1299
00:46:00,560 --> 00:46:02,640
large offset

1300
00:46:02,640 --> 00:46:05,040
that's guaranteed by 32-bit integer

1301
00:46:05,040 --> 00:46:06,319
lengths

1302
00:46:06,319 --> 00:46:07,920
and then of course if you corrupt it

1303
00:46:07,920 --> 00:46:09,760
it's all going to force it into offsets

1304
00:46:09,760 --> 00:46:11,280
into this

1305
00:46:11,280 --> 00:46:12,640
cage

1306
00:46:12,640 --> 00:46:14,400
additionally they try to keep

1307
00:46:14,400 --> 00:46:16,319
anything sensitive out of the cage so

1308
00:46:16,319 --> 00:46:18,240
it's mostly just data that doesn't

1309
00:46:18,240 --> 00:46:19,839
really matter if it's corrupted so it's

1310
00:46:19,839 --> 00:46:21,839
like you can't really leverage that

1311
00:46:21,839 --> 00:46:25,359
right into something more interesting

1312
00:46:25,359 --> 00:46:27,200
but there are a few issues with this

1313
00:46:27,200 --> 00:46:28,400
implementation

1314
00:46:28,400 --> 00:46:30,400
one of them is that you the devs

1315
00:46:30,400 --> 00:46:32,079
themselves have to protect each of these

1316
00:46:32,079 --> 00:46:34,000
pointers one at a time they have to

1317
00:46:34,000 --> 00:46:36,240
explicitly add that type to any pointer

1318
00:46:36,240 --> 00:46:37,839
that they think is vulnerable

1319
00:46:37,839 --> 00:46:39,680
and then also you have to guarantee that

1320
00:46:39,680 --> 00:46:41,680
they're using the correct implementation

1321
00:46:41,680 --> 00:46:43,920
of the uncaging everywhere and this is a

1322
00:46:43,920 --> 00:46:45,520
big problem for the jit where there's

1323
00:46:45,520 --> 00:46:47,599
tons of optimizations there's tons of

1324
00:46:47,599 --> 00:46:49,200
different ways that these pointers can

1325
00:46:49,200 --> 00:46:50,880
be accessed so that's a lot of

1326
00:46:50,880 --> 00:46:52,560
modification that has to be done to

1327
00:46:52,560 --> 00:46:54,839
ensure that the caging is being done

1328
00:46:54,839 --> 00:46:56,480
correctly

1329
00:46:56,480 --> 00:46:58,560
additionally there's just tons and tons

1330
00:46:58,560 --> 00:47:01,680
of different pointers in the code um

1331
00:47:01,680 --> 00:47:05,119
even ignoring the like dom and other web

1332
00:47:05,119 --> 00:47:07,520
apis that get stuck in our

1333
00:47:07,520 --> 00:47:09,520
keep there's just tons of other objects

1334
00:47:09,520 --> 00:47:11,280
we can use

1335
00:47:11,280 --> 00:47:13,440
so all an attacker needs to do is find a

1336
00:47:13,440 --> 00:47:16,160
single pointer that is not protected and

1337
00:47:16,160 --> 00:47:18,640
they're pretty much good to go

1338
00:47:18,640 --> 00:47:21,200
and this is also can be done made easier

1339
00:47:21,200 --> 00:47:22,640
depending on what type of object you're

1340
00:47:22,640 --> 00:47:24,800
looking at sometimes

1341
00:47:24,800 --> 00:47:26,800
you know you can make a fake object that

1342
00:47:26,800 --> 00:47:28,960
still has a vulnerable pointer in it and

1343
00:47:28,960 --> 00:47:30,880
it's pretty easy

1344
00:47:30,880 --> 00:47:33,119
so at least currently the easiest method

1345
00:47:33,119 --> 00:47:36,720
to do this is via the js array this is a

1346
00:47:36,720 --> 00:47:39,760
very common data structure it's used for

1347
00:47:39,760 --> 00:47:42,720
almost all the different objects which

1348
00:47:42,720 --> 00:47:44,640
are going to be you know in your normal

1349
00:47:44,640 --> 00:47:47,200
scripts so part of the issue i think

1350
00:47:47,200 --> 00:47:48,960
that they haven't caged it yet is again

1351
00:47:48,960 --> 00:47:51,040
the jit it's just very difficult for

1352
00:47:51,040 --> 00:47:54,480
them to implement all of that

1353
00:47:54,880 --> 00:47:58,079
in a way that is perfectly protected

1354
00:47:58,079 --> 00:48:00,160
so right now you can take your butterfly

1355
00:48:00,160 --> 00:48:01,839
which is just the data pointer in our

1356
00:48:01,839 --> 00:48:03,760
array you can point it at something else

1357
00:48:03,760 --> 00:48:05,680
and as long as you have this non-zero

1358
00:48:05,680 --> 00:48:07,440
value which is the length which it's

1359
00:48:07,440 --> 00:48:08,800
going to check to make sure that you can

1360
00:48:08,800 --> 00:48:10,319
access that memory

1361
00:48:10,319 --> 00:48:12,000
you'll be good to go

1362
00:48:12,000 --> 00:48:13,839
now this is slightly limited there's

1363
00:48:13,839 --> 00:48:15,839
also a little bit of an issue with some

1364
00:48:15,839 --> 00:48:17,680
certain bit patterns but i'm not going

1365
00:48:17,680 --> 00:48:19,599
to get into that but generally what

1366
00:48:19,599 --> 00:48:22,160
you'll see is this is the initial

1367
00:48:22,160 --> 00:48:24,400
read write primitive and then it's used

1368
00:48:24,400 --> 00:48:26,800
to corrupt a more complex structure that

1369
00:48:26,800 --> 00:48:28,800
has a better way to do a read write to

1370
00:48:28,800 --> 00:48:31,440
get pretty much unlimited arbitrary read

1371
00:48:31,440 --> 00:48:33,200
write

1372
00:48:33,200 --> 00:48:34,960
so giga cage doesn't seem like the best

1373
00:48:34,960 --> 00:48:36,480
right now maybe they could put a lot of

1374
00:48:36,480 --> 00:48:38,880
effort into it um but when you think

1375
00:48:38,880 --> 00:48:41,359
about what's really required

1376
00:48:41,359 --> 00:48:43,040
you're going to start finding that you

1377
00:48:43,040 --> 00:48:44,800
need to make sure all the pointers in

1378
00:48:44,800 --> 00:48:46,960
your heap are protected by a cage in

1379
00:48:46,960 --> 00:48:48,800
some way

1380
00:48:48,800 --> 00:48:50,480
and part of the problem with this is

1381
00:48:50,480 --> 00:48:52,079
there's a lot of external pointers that

1382
00:48:52,079 --> 00:48:53,920
go to other things like i mentioned the

1383
00:48:53,920 --> 00:48:56,079
web apis the dom

1384
00:48:56,079 --> 00:48:59,040
um all kinds of like meta data pointers

1385
00:48:59,040 --> 00:49:00,960
these would also have to be caged or

1386
00:49:00,960 --> 00:49:03,280
removed from the heap

1387
00:49:03,280 --> 00:49:04,400
so

1388
00:49:04,400 --> 00:49:06,400
if you were going and looking towards

1389
00:49:06,400 --> 00:49:08,160
making this mitigation better you'd

1390
00:49:08,160 --> 00:49:09,920
probably want to first remove all those

1391
00:49:09,920 --> 00:49:12,480
pointers that don't point to the

1392
00:49:12,480 --> 00:49:14,640
javascript put them somewhere outside

1393
00:49:14,640 --> 00:49:16,079
and then give javascript a way to

1394
00:49:16,079 --> 00:49:17,839
reference them

1395
00:49:17,839 --> 00:49:21,760
and this is pretty much what a future

1396
00:49:21,760 --> 00:49:24,160
mitigation which is being created by a

1397
00:49:24,160 --> 00:49:27,040
chrome team for v8 called heap sandbox

1398
00:49:27,040 --> 00:49:28,160
and this

1399
00:49:28,160 --> 00:49:29,839
mitigation essentially makes it so that

1400
00:49:29,839 --> 00:49:31,440
all of the objects in the javascript

1401
00:49:31,440 --> 00:49:33,520
heap are going to be stuck within this

1402
00:49:33,520 --> 00:49:35,680
four gigabyte region this is partly

1403
00:49:35,680 --> 00:49:38,240
possible because v8 recently switched to

1404
00:49:38,240 --> 00:49:40,960
32-bit pointers to save memory so that

1405
00:49:40,960 --> 00:49:42,400
makes it a lot easier for them to just

1406
00:49:42,400 --> 00:49:44,640
say here's a four gigabyte slice you

1407
00:49:44,640 --> 00:49:46,400
know your pointers are 32-bit you can't

1408
00:49:46,400 --> 00:49:49,040
access anything outside of it

1409
00:49:49,040 --> 00:49:50,480
and then of course we have a table at

1410
00:49:50,480 --> 00:49:53,119
the bottom which includes the external

1411
00:49:53,119 --> 00:49:54,880
pointers as well as some type

1412
00:49:54,880 --> 00:49:57,119
information to try to prevent you from

1413
00:49:57,119 --> 00:49:58,960
specifying different indexes and causing

1414
00:49:58,960 --> 00:50:01,440
a type confusion

1415
00:50:01,440 --> 00:50:04,000
so now even if you have you know any of

1416
00:50:04,000 --> 00:50:05,040
these

1417
00:50:05,040 --> 00:50:06,880
out of bounds or type confusions that we

1418
00:50:06,880 --> 00:50:08,720
saw earlier you're going to kind of be

1419
00:50:08,720 --> 00:50:11,119
stuck where your rights are only to

1420
00:50:11,119 --> 00:50:12,240
other objects that you could have

1421
00:50:12,240 --> 00:50:14,160
already corrupted or created

1422
00:50:14,160 --> 00:50:15,680
and what you're going to have to do is

1423
00:50:15,680 --> 00:50:17,920
try to find other behavior

1424
00:50:17,920 --> 00:50:20,400
somewhere in the browser which you can

1425
00:50:20,400 --> 00:50:23,119
kind of poke at through these handles or

1426
00:50:23,119 --> 00:50:24,079
these

1427
00:50:24,079 --> 00:50:26,160
indexes in the table which when you

1428
00:50:26,160 --> 00:50:27,440
think about it that's kind of like what

1429
00:50:27,440 --> 00:50:29,440
you do for a sandbox escape hence the

1430
00:50:29,440 --> 00:50:31,760
name heap sandbox it's trying to create

1431
00:50:31,760 --> 00:50:34,480
another layer of security around the js

1432
00:50:34,480 --> 00:50:35,599
compiler

1433
00:50:35,599 --> 00:50:36,880
so this is kind of

1434
00:50:36,880 --> 00:50:38,240
i feel like the way that we're going to

1435
00:50:38,240 --> 00:50:40,480
be going towards in terms of securing

1436
00:50:40,480 --> 00:50:42,480
these kinds of virtual machines which

1437
00:50:42,480 --> 00:50:44,400
have a lot of vulnerabilities in them

1438
00:50:44,400 --> 00:50:46,480
again it's not going to be bulletproof

1439
00:50:46,480 --> 00:50:48,240
there still can be tons of other issues

1440
00:50:48,240 --> 00:50:50,160
in the web browser in all the different

1441
00:50:50,160 --> 00:50:52,319
apis but it at least makes it a bit more

1442
00:50:52,319 --> 00:50:55,040
difficult within javascript to

1443
00:50:55,040 --> 00:50:59,119
corrupt other sensitive data

1444
00:50:59,119 --> 00:51:01,440
all right so now we're kind of at our

1445
00:51:01,440 --> 00:51:03,680
current state of most exploits and again

1446
00:51:03,680 --> 00:51:05,520
this is a little weird because it's

1447
00:51:05,520 --> 00:51:07,280
different browsers have different

1448
00:51:07,280 --> 00:51:10,160
settings some have pack some don't some

1449
00:51:10,160 --> 00:51:12,720
have site isolation some don't you know

1450
00:51:12,720 --> 00:51:15,839
some have our heap isolation stuff

1451
00:51:15,839 --> 00:51:17,280
but generally this is what we're going

1452
00:51:17,280 --> 00:51:18,960
to see as all the browsers are catching

1453
00:51:18,960 --> 00:51:21,200
up to each other

1454
00:51:21,200 --> 00:51:22,559
all right so

1455
00:51:22,559 --> 00:51:24,240
this is uh pretty much

1456
00:51:24,240 --> 00:51:26,319
all that we have but a few things just

1457
00:51:26,319 --> 00:51:29,440
to reiterate so we saw that there are

1458
00:51:29,440 --> 00:51:31,599
fewer bug classes they're more

1459
00:51:31,599 --> 00:51:34,240
um you know focus on the jit recently

1460
00:51:34,240 --> 00:51:35,920
and outside of the jit there's only been

1461
00:51:35,920 --> 00:51:38,000
a couple you know one-off bugs and parts

1462
00:51:38,000 --> 00:51:40,000
of the code less

1463
00:51:40,000 --> 00:51:42,079
comp or less vulnerability classes but

1464
00:51:42,079 --> 00:51:44,800
more complex bugs

1465
00:51:44,800 --> 00:51:46,240
additionally there isn't really much

1466
00:51:46,240 --> 00:51:47,839
difference in the early stages of

1467
00:51:47,839 --> 00:51:49,280
exploitation it's pretty much the same

1468
00:51:49,280 --> 00:51:50,880
as it's been for years

1469
00:51:50,880 --> 00:51:52,640
but the later stages are a little bit

1470
00:51:52,640 --> 00:51:54,720
trickier in some cases

1471
00:51:54,720 --> 00:51:56,400
but not too bad

1472
00:51:56,400 --> 00:51:58,000
future mitigations though are starting

1473
00:51:58,000 --> 00:51:59,280
to look worse you know as all these

1474
00:51:59,280 --> 00:52:01,680
other cfi implementations come in as

1475
00:52:01,680 --> 00:52:04,319
they patch more bypasses it was going to

1476
00:52:04,319 --> 00:52:06,319
become harder and more of a concerted

1477
00:52:06,319 --> 00:52:08,240
effort to actually bypass these things

1478
00:52:08,240 --> 00:52:09,440
but it's still not completely

1479
00:52:09,440 --> 00:52:10,800
bulletproof

1480
00:52:10,800 --> 00:52:12,800
all right so that's all we've got um

1481
00:52:12,800 --> 00:52:14,720
thank you very much i guess if there's

1482
00:52:14,720 --> 00:52:16,319
some questions there's microphone over

1483
00:52:16,319 --> 00:52:19,319
here

1484
00:52:20,760 --> 00:52:27,440
[Applause]

