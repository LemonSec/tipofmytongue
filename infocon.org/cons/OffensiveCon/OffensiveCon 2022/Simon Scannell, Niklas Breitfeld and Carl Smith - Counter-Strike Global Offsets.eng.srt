1
00:00:00,799 --> 00:00:02,720
so hello everyone

2
00:00:02,720 --> 00:00:04,080
welcome to our talk counter-strike

3
00:00:04,080 --> 00:00:05,600
global offsets our journey into

4
00:00:05,600 --> 00:00:07,600
exploiting the source engine

5
00:00:07,600 --> 00:00:08,960
and today we're going to talk about how

6
00:00:08,960 --> 00:00:10,559
we pawn cs go clients with a malicious

7
00:00:10,559 --> 00:00:12,240
server

8
00:00:12,240 --> 00:00:13,599
so first off i wanted to talk a bit

9
00:00:13,599 --> 00:00:15,040
about motivation

10
00:00:15,040 --> 00:00:16,960
so counter-strike global offensive has a

11
00:00:16,960 --> 00:00:18,800
huge following and lots of players on

12
00:00:18,800 --> 00:00:20,080
steam every month

13
00:00:20,080 --> 00:00:21,600
additionally it also has like a very

14
00:00:21,600 --> 00:00:23,600
lively esports community

15
00:00:23,600 --> 00:00:25,199
there's already been successful prior

16
00:00:25,199 --> 00:00:26,880
work which in combination with the older

17
00:00:26,880 --> 00:00:28,880
source engine has lots of potential for

18
00:00:28,880 --> 00:00:30,480
some juicy bugs

19
00:00:30,480 --> 00:00:32,800
so we also started this work um a bit

20
00:00:32,800 --> 00:00:34,160
more than a year ago as a pandemic

21
00:00:34,160 --> 00:00:36,880
project but we were all at home

22
00:00:36,880 --> 00:00:38,160
there was also a public link of the

23
00:00:38,160 --> 00:00:39,680
source code in github which has proven

24
00:00:39,680 --> 00:00:41,360
to be very helpful

25
00:00:41,360 --> 00:00:43,280
and we also played it extensively at

26
00:00:43,280 --> 00:00:45,039
some point in our lives and we thought

27
00:00:45,039 --> 00:00:46,320
like it would be super cool if you could

28
00:00:46,320 --> 00:00:48,640
opponent so yeah

29
00:00:48,640 --> 00:00:50,879
um so what is our attack scenario we

30
00:00:50,879 --> 00:00:52,320
specifically focused on server-to-client

31
00:00:52,320 --> 00:00:54,239
vulnerabilities as the server-side code

32
00:00:54,239 --> 00:00:56,079
was already like thoroughly audited and

33
00:00:56,079 --> 00:00:59,120
also it seemed quite robust um yeah

34
00:00:59,120 --> 00:01:00,480
there are lots of community servers

35
00:01:00,480 --> 00:01:02,160
everyone can like host one and even

36
00:01:02,160 --> 00:01:03,920
during our testing players join their

37
00:01:03,920 --> 00:01:05,199
server at random

38
00:01:05,199 --> 00:01:06,880
um i think we also crashed someone at

39
00:01:06,880 --> 00:01:09,280
some point and yeah so this this

40
00:01:09,280 --> 00:01:10,479
definitely seemed like a realistic

41
00:01:10,479 --> 00:01:13,040
attack scenario and well yeah once we

42
00:01:13,040 --> 00:01:14,960
have pawn one client we can also iterate

43
00:01:14,960 --> 00:01:16,640
through the player's friends list and

44
00:01:16,640 --> 00:01:18,080
just send out crafted seam invites to

45
00:01:18,080 --> 00:01:19,680
make them join our servers and pawn them

46
00:01:19,680 --> 00:01:22,000
as well

47
00:01:22,159 --> 00:01:23,680
to give some background we first need to

48
00:01:23,680 --> 00:01:25,520
cover like the setup and some of the

49
00:01:25,520 --> 00:01:26,720
tooling that we built specifically for

50
00:01:26,720 --> 00:01:28,000
this project

51
00:01:28,000 --> 00:01:29,840
so the client uses so-called information

52
00:01:29,840 --> 00:01:31,119
concealment engine like a symmetric

53
00:01:31,119 --> 00:01:32,960
block cipher for encryption they only

54
00:01:32,960 --> 00:01:35,040
perform a real key exchange on efficient

55
00:01:35,040 --> 00:01:36,000
servers

56
00:01:36,000 --> 00:01:37,520
and on community servers the key is

57
00:01:37,520 --> 00:01:40,320
always hard-coded and tied to reversion

58
00:01:40,320 --> 00:01:41,840
because apparently they prefer to write

59
00:01:41,840 --> 00:01:43,200
their own like networking protocol on

60
00:01:43,200 --> 00:01:45,520
top of udp for speed improvements the

61
00:01:45,520 --> 00:01:47,200
baseline networking code includes like

62
00:01:47,200 --> 00:01:48,799
fragmentation layers and also supports

63
00:01:48,799 --> 00:01:50,320
compression

64
00:01:50,320 --> 00:01:51,759
on top of this like adjusted udp

65
00:01:51,759 --> 00:01:52,880
protocol the main method of

66
00:01:52,880 --> 00:01:54,479
communication is

67
00:01:54,479 --> 00:01:56,159
via protobuffs where they exchange like

68
00:01:56,159 --> 00:01:58,240
messages of various types which are

69
00:01:58,240 --> 00:02:00,240
either bi-directional only from client

70
00:02:00,240 --> 00:02:02,960
to server or only from server to client

71
00:02:02,960 --> 00:02:04,880
we explicitly target these messages and

72
00:02:04,880 --> 00:02:06,399
we'll be making references to them

73
00:02:06,399 --> 00:02:09,119
throughout the talk so we build a proxy

74
00:02:09,119 --> 00:02:11,038
that allows us to inspect dump drop or

75
00:02:11,038 --> 00:02:13,440
even modify these messages in real time

76
00:02:13,440 --> 00:02:15,360
and it has been super helpful

77
00:02:15,360 --> 00:02:17,040
for analysis testing the vulnerabilities

78
00:02:17,040 --> 00:02:19,680
and subsequent development of exploits

79
00:02:19,680 --> 00:02:22,080
so here's like a short demo of the proxy

80
00:02:22,080 --> 00:02:23,920
in action on the left hand side you can

81
00:02:23,920 --> 00:02:26,000
see the player moving shooting changing

82
00:02:26,000 --> 00:02:27,920
weapons and on the right hand side you

83
00:02:27,920 --> 00:02:29,840
can see the messages that are being like

84
00:02:29,840 --> 00:02:31,200
yeah that we captured in real time

85
00:02:31,200 --> 00:02:33,599
basically

86
00:02:34,879 --> 00:02:37,599
yeah so the source engine was released

87
00:02:37,599 --> 00:02:39,519
way back in 2004 and it's mostly written

88
00:02:39,519 --> 00:02:41,360
in c plus plus so this already sounds

89
00:02:41,360 --> 00:02:43,920
super promising as security

90
00:02:43,920 --> 00:02:45,760
back in 2004 was quite different to like

91
00:02:45,760 --> 00:02:47,360
modern security practices

92
00:02:47,360 --> 00:02:49,040
so most prominently there was like a

93
00:02:49,040 --> 00:02:51,040
classic stack buffer overflow in the

94
00:02:51,040 --> 00:02:53,280
pricing of encryption parameters and it

95
00:02:53,280 --> 00:02:55,920
has been fixed but since counter-strike

96
00:02:55,920 --> 00:02:57,760
is also compiled without stack cookies

97
00:02:57,760 --> 00:02:58,879
it makes exploiting these kinds of

98
00:02:58,879 --> 00:03:00,720
vulnerabilities rather easy especially

99
00:03:00,720 --> 00:03:02,000
in the past

100
00:03:02,000 --> 00:03:03,360
there are various lines of codes that do

101
00:03:03,360 --> 00:03:04,800
not seem to be actually used in the game

102
00:03:04,800 --> 00:03:06,159
the whole architecture of the game is

103
00:03:06,159 --> 00:03:07,920
quite complex and it's definitely not

104
00:03:07,920 --> 00:03:09,360
immediately clear what code is

105
00:03:09,360 --> 00:03:10,959
responsible for what

106
00:03:10,959 --> 00:03:13,599
the developers also use lots of berserks

107
00:03:13,599 --> 00:03:14,959
which they sometimes use for balance

108
00:03:14,959 --> 00:03:17,280
checking fortunately for us those assets

109
00:03:17,280 --> 00:03:18,800
do not actually end up in the release

110
00:03:18,800 --> 00:03:21,040
build so this made finding some of the

111
00:03:21,040 --> 00:03:23,519
out of bounds accesses very easy

112
00:03:23,519 --> 00:03:25,360
so lesson learned do not use the search

113
00:03:25,360 --> 00:03:26,720
for bounce checking if they are

114
00:03:26,720 --> 00:03:28,080
definitely not they're compiling to

115
00:03:28,080 --> 00:03:29,200
release but it's not combined into

116
00:03:29,200 --> 00:03:31,519
response so now i'm gonna hand over to

117
00:03:31,519 --> 00:03:33,519
simon he will talk about first bug the

118
00:03:33,519 --> 00:03:36,000
info leak

119
00:03:36,799 --> 00:03:37,599
hey

120
00:03:37,599 --> 00:03:40,720
thank you carl so um you know with

121
00:03:40,720 --> 00:03:42,159
although there were some decking

122
00:03:42,159 --> 00:03:43,760
mitigations we still needed to break

123
00:03:43,760 --> 00:03:46,159
aslr which is why we started looking for

124
00:03:46,159 --> 00:03:47,440
an info leak

125
00:03:47,440 --> 00:03:49,840
and to start explaining the spark i want

126
00:03:49,840 --> 00:03:51,599
to give you some background just to have

127
00:03:51,599 --> 00:03:53,760
some context in order to understand the

128
00:03:53,760 --> 00:03:54,959
info leak

129
00:03:54,959 --> 00:03:56,000
so

130
00:03:56,000 --> 00:03:58,159
csco has a problem which is that anyone

131
00:03:58,159 --> 00:04:00,560
can host a community server

132
00:04:00,560 --> 00:04:02,480
with maps that are not typically shipped

133
00:04:02,480 --> 00:04:05,280
with cisco by default those are your

134
00:04:05,280 --> 00:04:07,439
serve maps or hide and seek or whatever

135
00:04:07,439 --> 00:04:09,760
you want to play and they might ship

136
00:04:09,760 --> 00:04:11,200
with some game assets that the client

137
00:04:11,200 --> 00:04:12,799
doesn't have

138
00:04:12,799 --> 00:04:14,480
now this is the problem is every time

139
00:04:14,480 --> 00:04:16,639
the cs go server changes the map all

140
00:04:16,639 --> 00:04:18,000
players that don't have the map

141
00:04:18,000 --> 00:04:20,478
downloaded would get disconnected and as

142
00:04:20,478 --> 00:04:22,000
you can imagine that could be quite

143
00:04:22,000 --> 00:04:23,840
frustrating if you get disconnected like

144
00:04:23,840 --> 00:04:26,320
every 10 minutes

145
00:04:26,320 --> 00:04:28,080
the solution to this problem is to

146
00:04:28,080 --> 00:04:30,080
enable players to dynamically download

147
00:04:30,080 --> 00:04:32,240
maps at the beginning of each round

148
00:04:32,240 --> 00:04:33,680
the way this works is that the server

149
00:04:33,680 --> 00:04:36,160
sends the client the http url um during

150
00:04:36,160 --> 00:04:37,759
the connection stage from which you

151
00:04:37,759 --> 00:04:39,199
download files from

152
00:04:39,199 --> 00:04:40,320
and we actually discovered a

153
00:04:40,320 --> 00:04:42,080
piledriver's path traversal bug in the

154
00:04:42,080 --> 00:04:44,080
download functionality but it turned out

155
00:04:44,080 --> 00:04:47,120
to be a duplicate which is unfortunate

156
00:04:47,120 --> 00:04:49,199
but we further investigated and found an

157
00:04:49,199 --> 00:04:51,199
interesting parser differential bug that

158
00:04:51,199 --> 00:04:53,520
led to a powerful info leak

159
00:04:53,520 --> 00:04:55,199
so with the next slides we'll break down

160
00:04:55,199 --> 00:04:57,360
the high level logic flow of the donor

161
00:04:57,360 --> 00:04:59,680
functionality as it was implemented on

162
00:04:59,680 --> 00:05:00,800
linux

163
00:05:00,800 --> 00:05:03,280
csgo also works on linux which is cool

164
00:05:03,280 --> 00:05:05,360
and we prefer working on linux as we're

165
00:05:05,360 --> 00:05:07,520
more familiar with it than windows and i

166
00:05:07,520 --> 00:05:09,120
will come back as to why that is

167
00:05:09,120 --> 00:05:11,600
important in a couple of slides

168
00:05:11,600 --> 00:05:13,199
so at the beginning of each match the

169
00:05:13,199 --> 00:05:14,880
server sends the client a list of files

170
00:05:14,880 --> 00:05:16,800
that are required to play on during the

171
00:05:16,800 --> 00:05:18,000
current match

172
00:05:18,000 --> 00:05:20,400
whether that is sounds or skins or any

173
00:05:20,400 --> 00:05:22,720
other game asset you could think of

174
00:05:22,720 --> 00:05:24,560
and the client then simply concatenates

175
00:05:24,560 --> 00:05:27,120
the missing file name with the http url

176
00:05:27,120 --> 00:05:28,400
they received during the connection

177
00:05:28,400 --> 00:05:30,639
stage the download is implemented using

178
00:05:30,639 --> 00:05:33,919
lib curl on linux

179
00:05:33,919 --> 00:05:35,600
now let's look at some reverse code and

180
00:05:35,600 --> 00:05:37,039
interesting behavior

181
00:05:37,039 --> 00:05:39,360
when cs go set up the curl request it

182
00:05:39,360 --> 00:05:41,039
registered a callback that is called for

183
00:05:41,039 --> 00:05:43,360
each header in the http response

184
00:05:43,360 --> 00:05:45,600
this is the curl header kill a qr header

185
00:05:45,600 --> 00:05:47,360
callback you can see

186
00:05:47,360 --> 00:05:49,280
here and it basically just receives the

187
00:05:49,280 --> 00:05:51,280
pointer to the header

188
00:05:51,280 --> 00:05:53,360
and that's it and then there's also

189
00:05:53,360 --> 00:05:55,600
co-write a call right callback which is

190
00:05:55,600 --> 00:05:58,080
called when the http body is received

191
00:05:58,080 --> 00:06:00,560
which contains a pointer to the buffer

192
00:06:00,560 --> 00:06:02,479
containing the body

193
00:06:02,479 --> 00:06:03,919
now looking at the code of the curl

194
00:06:03,919 --> 00:06:05,440
header callback we can see that there's

195
00:06:05,440 --> 00:06:07,360
a case sensitive compare against the

196
00:06:07,360 --> 00:06:09,600
header name and if it equals content

197
00:06:09,600 --> 00:06:11,120
length a branch is entered and we'll

198
00:06:11,120 --> 00:06:12,639
discuss what happens inside of that

199
00:06:12,639 --> 00:06:13,919
special branch

200
00:06:13,919 --> 00:06:16,080
on the next slides

201
00:06:16,080 --> 00:06:17,919
so we have just seen that the conlength

202
00:06:17,919 --> 00:06:19,680
header is processed and interpreted by

203
00:06:19,680 --> 00:06:22,880
csgo the value of it which is an integer

204
00:06:22,880 --> 00:06:24,639
is used by csgo to allocate a buffer

205
00:06:24,639 --> 00:06:26,560
that is large enough to fit in the http

206
00:06:26,560 --> 00:06:28,639
response body as given by the http

207
00:06:28,639 --> 00:06:29,680
server

208
00:06:29,680 --> 00:06:31,600
the buffer is sent written to disk with

209
00:06:31,600 --> 00:06:34,240
the desired file name via the cool write

210
00:06:34,240 --> 00:06:36,080
callback

211
00:06:36,080 --> 00:06:38,240
so now for the parser differential

212
00:06:38,240 --> 00:06:40,240
on linux the cs go client parses the

213
00:06:40,240 --> 00:06:42,319
header case sensitive but the underlying

214
00:06:42,319 --> 00:06:44,479
library which is curl case insensitive

215
00:06:44,479 --> 00:06:45,840
this naturally leads to confusion

216
00:06:45,840 --> 00:06:47,280
between the two

217
00:06:47,280 --> 00:06:49,759
if we now tell csgo the cs go client to

218
00:06:49,759 --> 00:06:51,360
create a large buffer on the heap by

219
00:06:51,360 --> 00:06:52,800
setting the content length header to an

220
00:06:52,800 --> 00:06:55,120
arbitrary value but then just not some

221
00:06:55,120 --> 00:06:57,680
sending body or an empty body

222
00:06:57,680 --> 00:06:59,520
the cs go client will happily write

223
00:06:59,520 --> 00:07:02,479
uninstallized memory to disk

224
00:07:02,479 --> 00:07:04,000
so to illustrate this point a bit more

225
00:07:04,000 --> 00:07:06,560
here's an example http response sent by

226
00:07:06,560 --> 00:07:08,960
a malicious server so as can be seen two

227
00:07:08,960 --> 00:07:10,400
content length headers are present in

228
00:07:10,400 --> 00:07:12,639
response and the first time it occurs it

229
00:07:12,639 --> 00:07:14,400
uses capital letters and has the value

230
00:07:14,400 --> 00:07:17,039
one two three seven and the second time

231
00:07:17,039 --> 00:07:18,560
it occurs it occurs with lowercase

232
00:07:18,560 --> 00:07:21,440
letters and has the value zero so csgo

233
00:07:21,440 --> 00:07:23,599
only recognizes the first header and

234
00:07:23,599 --> 00:07:26,319
allocates a buffer of size 127. curl on

235
00:07:26,319 --> 00:07:28,319
the other hand expects an empty body now

236
00:07:28,319 --> 00:07:30,400
that it recognized the second header and

237
00:07:30,400 --> 00:07:33,599
uses it as the value and then proceeds

238
00:07:33,599 --> 00:07:35,360
to write the buffer to disk

239
00:07:35,360 --> 00:07:38,160
and it does return an error and this

240
00:07:38,160 --> 00:07:39,759
file will now contain uninitialized

241
00:07:39,759 --> 00:07:41,360
memory that is because the coil write

242
00:07:41,360 --> 00:07:43,039
callback is never actually called

243
00:07:43,039 --> 00:07:45,840
because the body is empty

244
00:07:45,840 --> 00:07:46,639
so

245
00:07:46,639 --> 00:07:48,080
now to windows

246
00:07:48,080 --> 00:07:50,000
on windows they use an entirely

247
00:07:50,000 --> 00:07:52,160
different http library and they actually

248
00:07:52,160 --> 00:07:54,800
used completely different code but the

249
00:07:54,800 --> 00:07:56,800
code the same proof concept that i just

250
00:07:56,800 --> 00:07:58,639
showed you actually worked on windows

251
00:07:58,639 --> 00:08:00,560
without having to be modified which was

252
00:08:00,560 --> 00:08:01,840
kind of cool

253
00:08:01,840 --> 00:08:03,120
and

254
00:08:03,120 --> 00:08:05,120
so on windows instead of

255
00:08:05,120 --> 00:08:06,960
the instead of curl they use the

256
00:08:06,960 --> 00:08:10,160
built-in windows internet api

257
00:08:10,160 --> 00:08:11,759
and they use a couple of functions so

258
00:08:11,759 --> 00:08:14,080
first they would open a client resource

259
00:08:14,080 --> 00:08:16,160
client resource with internet open

260
00:08:16,160 --> 00:08:18,400
and then they would open specifically

261
00:08:18,400 --> 00:08:21,440
http resource with internet open url

262
00:08:21,440 --> 00:08:23,120
and then they use a resource to make the

263
00:08:23,120 --> 00:08:26,160
http request with internet read file and

264
00:08:26,160 --> 00:08:28,160
then some interesting things happened

265
00:08:28,160 --> 00:08:31,280
where they use http query info on the

266
00:08:31,280 --> 00:08:32,799
resource to gather some information

267
00:08:32,799 --> 00:08:34,799
about the request for example you could

268
00:08:34,799 --> 00:08:37,279
request the values of some headers and

269
00:08:37,279 --> 00:08:39,360
in this case they use http query info to

270
00:08:39,360 --> 00:08:41,120
retrieve the value of the content length

271
00:08:41,120 --> 00:08:43,360
header similarly to the implementation

272
00:08:43,360 --> 00:08:45,279
of linux now what was interesting is

273
00:08:45,279 --> 00:08:47,440
that windows didn't complain when we

274
00:08:47,440 --> 00:08:49,920
retrieved that value and actually the

275
00:08:49,920 --> 00:08:52,320
real size of the body is returned by

276
00:08:52,320 --> 00:08:54,560
internet read file instead of http query

277
00:08:54,560 --> 00:08:56,880
info so again they did not compare the

278
00:08:56,880 --> 00:08:59,200
values and use the wrong value without a

279
00:08:59,200 --> 00:09:01,360
body ever being received and written to

280
00:09:01,360 --> 00:09:04,000
the body buffer and wrote that file to

281
00:09:04,000 --> 00:09:05,760
disk

282
00:09:05,760 --> 00:09:08,480
so in order to break aslr we can now

283
00:09:08,480 --> 00:09:10,640
spray the object the heap with objects

284
00:09:10,640 --> 00:09:12,720
that contain function pointers and then

285
00:09:12,720 --> 00:09:14,640
de-allocate them again

286
00:09:14,640 --> 00:09:16,959
and luckily the cs go process did not

287
00:09:16,959 --> 00:09:18,320
clear allocated memory when it was

288
00:09:18,320 --> 00:09:19,920
allocated or freed

289
00:09:19,920 --> 00:09:21,279
this means that the buffers have written

290
00:09:21,279 --> 00:09:23,200
this would contain anything that was

291
00:09:23,200 --> 00:09:24,800
written to the memory beforehand and

292
00:09:24,800 --> 00:09:26,320
then freed again

293
00:09:26,320 --> 00:09:27,440
so

294
00:09:27,440 --> 00:09:29,040
you have to keep in mind though now we

295
00:09:29,040 --> 00:09:30,880
have files on the client of arbitrary

296
00:09:30,880 --> 00:09:34,160
size um kind of um with that contain

297
00:09:34,160 --> 00:09:35,920
uninitialized memory including some

298
00:09:35,920 --> 00:09:37,279
juicy pointers

299
00:09:37,279 --> 00:09:38,880
um but they're stored on the client's

300
00:09:38,880 --> 00:09:40,480
disk so now we had to find a way to

301
00:09:40,480 --> 00:09:42,160
retrieve those contents from the

302
00:09:42,160 --> 00:09:45,040
client's disk and we thought okay maybe

303
00:09:45,040 --> 00:09:46,480
we'll have to find some super

304
00:09:46,480 --> 00:09:48,720
sophisticated side channel league or any

305
00:09:48,720 --> 00:09:50,720
way to leak the files but

306
00:09:50,720 --> 00:09:52,880
as it turned out it was very easy

307
00:09:52,880 --> 00:09:54,640
because funny enough the cs go server

308
00:09:54,640 --> 00:09:56,560
can just ask the client to upload any

309
00:09:56,560 --> 00:09:59,600
file that is in the cs go directory

310
00:09:59,600 --> 00:10:01,760
we assume this was done to verify some

311
00:10:01,760 --> 00:10:03,440
files on the client

312
00:10:03,440 --> 00:10:05,440
and instead of uploading a hash of the

313
00:10:05,440 --> 00:10:07,760
file or crc or whatever they would just

314
00:10:07,760 --> 00:10:09,440
upload the entire file

315
00:10:09,440 --> 00:10:12,000
this meant we could just parse the file

316
00:10:12,000 --> 00:10:13,680
look for some pointers that we were

317
00:10:13,680 --> 00:10:15,519
looking for which contained some

318
00:10:15,519 --> 00:10:18,240
function pointers to the base image and

319
00:10:18,240 --> 00:10:19,920
we broke aslr

320
00:10:19,920 --> 00:10:22,640
and the info leak was 100 reliable and

321
00:10:22,640 --> 00:10:25,600
we tested it on many times and it almost

322
00:10:25,600 --> 00:10:27,200
worked every single time on the first

323
00:10:27,200 --> 00:10:29,360
try and even if it didn't work on the

324
00:10:29,360 --> 00:10:30,480
first try

325
00:10:30,480 --> 00:10:31,920
you could just retried an infinite

326
00:10:31,920 --> 00:10:33,279
amount of times because you didn't

327
00:10:33,279 --> 00:10:35,360
actually corrupt the client's memory and

328
00:10:35,360 --> 00:10:37,040
you could just ask them to re-download

329
00:10:37,040 --> 00:10:38,720
the files again and repeat the whole

330
00:10:38,720 --> 00:10:41,120
process so now that we had a reliable

331
00:10:41,120 --> 00:10:42,720
info leak we're ready to corrupt some

332
00:10:42,720 --> 00:10:44,480
memory which is what niklas will be

333
00:10:44,480 --> 00:10:47,839
talking about next

334
00:10:48,079 --> 00:10:51,600
yes thank you simon for the info league

335
00:10:51,600 --> 00:10:54,240
so obviously we also need some way to

336
00:10:54,240 --> 00:10:55,519
corrupt memory

337
00:10:55,519 --> 00:10:56,480
and

338
00:10:56,480 --> 00:10:57,920
it is to say whether we tried the

339
00:10:57,920 --> 00:11:00,000
following

340
00:11:00,000 --> 00:11:02,079
methods to find bugs on both server and

341
00:11:02,079 --> 00:11:03,680
the client side we were only able to

342
00:11:03,680 --> 00:11:05,600
find bugs on the client side the server

343
00:11:05,600 --> 00:11:08,399
side has already been pretty hard since

344
00:11:08,399 --> 00:11:12,720
source league in 2021 by 2020 sorry

345
00:11:12,720 --> 00:11:15,120
and didn't yield us with any bug

346
00:11:15,120 --> 00:11:16,399
whatsoever

347
00:11:16,399 --> 00:11:18,480
so to get a feel for the networking

348
00:11:18,480 --> 00:11:20,480
attack service we utilized our

349
00:11:20,480 --> 00:11:22,079
networking proxy

350
00:11:22,079 --> 00:11:24,079
and started to modify with some of the

351
00:11:24,079 --> 00:11:26,480
protobuf messages and played around the

352
00:11:26,480 --> 00:11:29,360
values a bit so and this showed

353
00:11:29,360 --> 00:11:31,760
promising results as we are able to find

354
00:11:31,760 --> 00:11:33,279
quite a few issues

355
00:11:33,279 --> 00:11:35,920
um sadly however the majority of bucks

356
00:11:35,920 --> 00:11:38,399
were simple null pointer drafts

357
00:11:38,399 --> 00:11:40,720
and which is not in our interest as we

358
00:11:40,720 --> 00:11:42,880
were hoping for an rce and crashing the

359
00:11:42,880 --> 00:11:45,519
client is not really a security concern

360
00:11:45,519 --> 00:11:47,760
at least at least not for us

361
00:11:47,760 --> 00:11:49,839
however in the end we found

362
00:11:49,839 --> 00:11:52,240
quite a neat out of bounds access bug

363
00:11:52,240 --> 00:11:53,760
and yeah

364
00:11:53,760 --> 00:11:56,000
so additionally we also used the

365
00:11:56,000 --> 00:11:57,600
knowledge that asserts were not compiled

366
00:11:57,600 --> 00:12:00,240
into release built and manually edited

367
00:12:00,240 --> 00:12:02,399
audited

368
00:12:02,399 --> 00:12:05,519
the source and that also yielded us with

369
00:12:05,519 --> 00:12:08,240
an interesting bug

370
00:12:08,240 --> 00:12:10,560
so one of the out of bounds access was

371
00:12:10,560 --> 00:12:12,639
in split screen control

372
00:12:12,639 --> 00:12:14,560
to give you some context the source

373
00:12:14,560 --> 00:12:16,160
engine is able to have a two-player

374
00:12:16,160 --> 00:12:18,240
split screen session which can be

375
00:12:18,240 --> 00:12:20,800
requested by the client and the bug is

376
00:12:20,800 --> 00:12:22,320
triggered by the split screen control

377
00:12:22,320 --> 00:12:24,720
message sent back by the server

378
00:12:24,720 --> 00:12:26,320
and you can see that on the left hand

379
00:12:26,320 --> 00:12:27,920
side

380
00:12:27,920 --> 00:12:29,920
this is to acknowledge the split screen

381
00:12:29,920 --> 00:12:32,000
request from the client and the client

382
00:12:32,000 --> 00:12:33,760
uses this message to set up the split

383
00:12:33,760 --> 00:12:36,240
screen session and some metadata around

384
00:12:36,240 --> 00:12:37,440
it

385
00:12:37,440 --> 00:12:38,800
however

386
00:12:38,800 --> 00:12:40,720
no check on the client is performed if

387
00:12:40,720 --> 00:12:42,399
the client has actually requested a

388
00:12:42,399 --> 00:12:44,880
split screen session in the first place

389
00:12:44,880 --> 00:12:46,880
so the attacking server is able to send

390
00:12:46,880 --> 00:12:49,360
that control message at any time and the

391
00:12:49,360 --> 00:12:51,360
client will happily comply and set up

392
00:12:51,360 --> 00:12:52,480
the

393
00:12:52,480 --> 00:12:53,519
thing

394
00:12:53,519 --> 00:12:56,000
so on the right hand side you can see an

395
00:12:56,000 --> 00:12:58,079
image of the vulnerable code

396
00:12:58,079 --> 00:13:01,120
and the end slot is basically the slot

397
00:13:01,120 --> 00:13:03,920
index in the put above message which is

398
00:13:03,920 --> 00:13:07,760
unmodified and unchecked whatsoever

399
00:13:07,760 --> 00:13:10,320
right so the array we can perform this

400
00:13:10,320 --> 00:13:12,480
out of bounds on actualizing the data

401
00:13:12,480 --> 00:13:14,240
section so we have so we have to keep

402
00:13:14,240 --> 00:13:16,639
that in mind when we develop the exploit

403
00:13:16,639 --> 00:13:19,200
and also you can see a few lines down

404
00:13:19,200 --> 00:13:21,920
the code that virtual call is performed

405
00:13:21,920 --> 00:13:23,040
so we

406
00:13:23,040 --> 00:13:27,120
have pc control almost instantly

407
00:13:27,680 --> 00:13:29,519
so to take advantage of

408
00:13:29,519 --> 00:13:31,680
to take advantage of this issue we first

409
00:13:31,680 --> 00:13:34,880
need to find a way to place a pointer to

410
00:13:34,880 --> 00:13:36,720
controlled memory inside the data

411
00:13:36,720 --> 00:13:37,760
section

412
00:13:37,760 --> 00:13:40,000
and luckily for us the source engine

413
00:13:40,000 --> 00:13:41,360
provides us with just the right

414
00:13:41,360 --> 00:13:44,000
primitive and that's sievers

415
00:13:44,000 --> 00:13:46,160
receivers or configuration values for

416
00:13:46,160 --> 00:13:47,120
short

417
00:13:47,120 --> 00:13:49,760
fixed named config values which are part

418
00:13:49,760 --> 00:13:52,320
of the bi-directional put of a protocol

419
00:13:52,320 --> 00:13:54,720
for those of you who played csgo like

420
00:13:54,720 --> 00:13:56,720
setting your crosshair or viewmodel

421
00:13:56,720 --> 00:13:59,760
that's also a siever

422
00:13:59,760 --> 00:14:01,839
and they can hold all kinds of types

423
00:14:01,839 --> 00:14:04,000
such as strings or floating points or

424
00:14:04,000 --> 00:14:06,480
colors which are actually

425
00:14:06,480 --> 00:14:08,320
interpreted as integers which is

426
00:14:08,320 --> 00:14:09,920
important for later

427
00:14:09,920 --> 00:14:12,079
um and that server has actually the

428
00:14:12,079 --> 00:14:14,399
ability to set and receivers to its

429
00:14:14,399 --> 00:14:16,880
liking

430
00:14:16,880 --> 00:14:18,639
so because only a fixed number of

431
00:14:18,639 --> 00:14:21,040
predefined sievers actually exist they

432
00:14:21,040 --> 00:14:23,199
are also stored in the data section and

433
00:14:23,199 --> 00:14:26,560
this is exactly what we need

434
00:14:27,199 --> 00:14:29,519
so in case the siever is a string a

435
00:14:29,519 --> 00:14:31,440
pointer will be placed which points to

436
00:14:31,440 --> 00:14:33,600
the heap

437
00:14:33,600 --> 00:14:36,399
and the best part is that thanks to the

438
00:14:36,399 --> 00:14:38,800
way values are updated

439
00:14:38,800 --> 00:14:39,050
the

440
00:14:39,050 --> 00:14:40,320
[Music]

441
00:14:40,320 --> 00:14:42,399
the server has the ability to write null

442
00:14:42,399 --> 00:14:44,800
bytes into those strings as well so the

443
00:14:44,800 --> 00:14:47,040
client will only reallocate the buffer

444
00:14:47,040 --> 00:14:49,040
if the updated string is bigger or it

445
00:14:49,040 --> 00:14:51,839
wasn't a string before so by repeatedly

446
00:14:51,839 --> 00:14:53,920
sending the payload in

447
00:14:53,920 --> 00:14:56,079
shrinking chunks splitting at navi

448
00:14:56,079 --> 00:14:58,000
nullbyte we were able to place any

449
00:14:58,000 --> 00:15:00,800
memory we wanted into the um

450
00:15:00,800 --> 00:15:02,240
into the keyboard server and that's

451
00:15:02,240 --> 00:15:04,079
that's actually really important because

452
00:15:04,079 --> 00:15:06,160
uh sometimes due to a sli it could be

453
00:15:06,160 --> 00:15:09,199
that the base image was

454
00:15:09,199 --> 00:15:11,199
placed at the section where nobody was

455
00:15:11,199 --> 00:15:13,199
in the pointer and then the whole expert

456
00:15:13,199 --> 00:15:15,599
wouldn't work

457
00:15:15,920 --> 00:15:18,720
so and we additionally used another

458
00:15:18,720 --> 00:15:21,199
trick with sievers and that this has to

459
00:15:21,199 --> 00:15:23,040
do with the color

460
00:15:23,040 --> 00:15:24,839
attribute

461
00:15:24,839 --> 00:15:28,720
and we needed that to place a control

462
00:15:28,720 --> 00:15:30,560
pointer like with the string we can only

463
00:15:30,560 --> 00:15:32,399
control the contents but not the pointer

464
00:15:32,399 --> 00:15:34,639
but we also needed a pointer

465
00:15:34,639 --> 00:15:37,680
so but contrary to pointers the integer

466
00:15:37,680 --> 00:15:39,600
values are first obscured before they

467
00:15:39,600 --> 00:15:41,040
are stored you can see that in the

468
00:15:41,040 --> 00:15:42,800
screenshots on the right

469
00:15:42,800 --> 00:15:43,680
and

470
00:15:43,680 --> 00:15:45,360
a comment in the source engine actually

471
00:15:45,360 --> 00:15:47,920
tells us that this was to make it harder

472
00:15:47,920 --> 00:15:50,079
to find the value in memory using cheat

473
00:15:50,079 --> 00:15:51,199
engine

474
00:15:51,199 --> 00:15:52,160
and

475
00:15:52,160 --> 00:15:54,480
that could have proved a tough roadblock

476
00:15:54,480 --> 00:15:57,680
for us actually because we had no way to

477
00:15:57,680 --> 00:16:01,040
predict the encoding however thankfully

478
00:16:01,040 --> 00:16:02,399
uh

479
00:16:02,399 --> 00:16:04,000
the encoding was done via the disk

480
00:16:04,000 --> 00:16:05,519
pointer and because we leaked the base

481
00:16:05,519 --> 00:16:08,160
image with the info leak already we can

482
00:16:08,160 --> 00:16:10,720
predict the encoding and so still place

483
00:16:10,720 --> 00:16:11,600
any

484
00:16:11,600 --> 00:16:13,839
value we wanted into the memory so if

485
00:16:13,839 --> 00:16:16,480
they actually use the random value that

486
00:16:16,480 --> 00:16:19,680
would have wouldn't have worked

487
00:16:19,759 --> 00:16:21,360
so let's have a quick overview over the

488
00:16:21,360 --> 00:16:22,560
game plan

489
00:16:22,560 --> 00:16:24,959
so the first arrow is the out of bounds

490
00:16:24,959 --> 00:16:27,519
axis of the split screen array and

491
00:16:27,519 --> 00:16:30,240
that's this will point to the effects

492
00:16:30,240 --> 00:16:31,120
string

493
00:16:31,120 --> 00:16:33,600
the siva string object which will point

494
00:16:33,600 --> 00:16:37,680
to our fake object on the heap

495
00:16:37,680 --> 00:16:39,759
so now we have to create a valid virtual

496
00:16:39,759 --> 00:16:42,160
table for the virtual call to take pc

497
00:16:42,160 --> 00:16:43,279
control

498
00:16:43,279 --> 00:16:45,519
and we use the second siever to write a

499
00:16:45,519 --> 00:16:49,120
single jump gadget and point it to the

500
00:16:49,120 --> 00:16:50,959
and

501
00:16:50,959 --> 00:16:53,759
so we pointed the virtual table to the

502
00:16:53,759 --> 00:16:55,839
second siever we used as a with the

503
00:16:55,839 --> 00:16:57,920
color object to point it to a single

504
00:16:57,920 --> 00:17:00,480
jump gadget inside the the main text

505
00:17:00,480 --> 00:17:01,600
section

506
00:17:01,600 --> 00:17:04,319
and then we just pivoted into a robbed

507
00:17:04,319 --> 00:17:07,520
chain and i will talk about that now

508
00:17:07,520 --> 00:17:09,439
so thanks to the nature of virtual

509
00:17:09,439 --> 00:17:12,079
chords we have at least some context to

510
00:17:12,079 --> 00:17:14,240
play with or some registers in this case

511
00:17:14,240 --> 00:17:16,000
this pointer is stored in ecx and

512
00:17:16,000 --> 00:17:17,919
because our fake object is entirely

513
00:17:17,919 --> 00:17:20,240
controlled we have a pointer to

514
00:17:20,240 --> 00:17:22,880
memory which we have chosen beforehand

515
00:17:22,880 --> 00:17:25,119
uh to our advantage

516
00:17:25,119 --> 00:17:26,880
and actually while we were developing

517
00:17:26,880 --> 00:17:29,440
the exploit why multiple updates were

518
00:17:29,440 --> 00:17:31,120
released to the game which is quite rare

519
00:17:31,120 --> 00:17:34,080
so we were quite unlucky and sometimes

520
00:17:34,080 --> 00:17:37,200
gadgets were added or removed so

521
00:17:37,200 --> 00:17:39,440
in a few cases ebx also pointed to the

522
00:17:39,440 --> 00:17:41,840
fake object and that simplified the

523
00:17:41,840 --> 00:17:44,720
jump chain quite a bit

524
00:17:44,720 --> 00:17:47,840
so in both cases we pivoted the stack to

525
00:17:47,840 --> 00:17:49,280
the fake object

526
00:17:49,280 --> 00:17:51,520
as this controls a good chunk of memory

527
00:17:51,520 --> 00:17:54,799
uh suitable to holding a rob

528
00:17:54,799 --> 00:17:56,559
so in the first one we first need to

529
00:17:56,559 --> 00:17:59,280
exchange ecx with eax and then dual

530
00:17:59,280 --> 00:18:03,360
pivot after an additional jump gadget

531
00:18:03,360 --> 00:18:05,440
and in the second one we were able to

532
00:18:05,440 --> 00:18:08,240
pivot immediately

533
00:18:08,240 --> 00:18:10,160
so and for the rob chain we just use the

534
00:18:10,160 --> 00:18:13,039
generic rob2 system or shall execute a

535
00:18:13,039 --> 00:18:15,600
depending on os which is enough to give

536
00:18:15,600 --> 00:18:18,799
us control over the client

537
00:18:18,799 --> 00:18:22,600
so let's have a quick demo

538
00:18:32,559 --> 00:18:35,918
yeah let's maybe watch it a second time

539
00:18:46,960 --> 00:18:48,559
so what is the actual impact of this bug

540
00:18:48,559 --> 00:18:50,400
well we can reliably execute code on the

541
00:18:50,400 --> 00:18:52,640
victim's machine so the information can

542
00:18:52,640 --> 00:18:54,160
be performed multiple times until we are

543
00:18:54,160 --> 00:18:55,440
certain that we have all the pointers

544
00:18:55,440 --> 00:18:56,400
that we need

545
00:18:56,400 --> 00:18:58,400
and out of bounds issue is in the memory

546
00:18:58,400 --> 00:18:59,840
corruption are also reliable assuming

547
00:18:59,840 --> 00:19:01,760
that info leak is valid so from here on

548
00:19:01,760 --> 00:19:03,039
attackers could easily see a private

549
00:19:03,039 --> 00:19:04,640
information stage malware steal

550
00:19:04,640 --> 00:19:06,960
expensive keys or install cryptominers

551
00:19:06,960 --> 00:19:08,640
it would also just be as easy to send

552
00:19:08,640 --> 00:19:10,080
out more steam invites to pawn even more

553
00:19:10,080 --> 00:19:12,000
people and or just use the pc as part of

554
00:19:12,000 --> 00:19:13,120
the botnet

555
00:19:13,120 --> 00:19:15,200
so one more thing let's also talk about

556
00:19:15,200 --> 00:19:16,960
the disclosure timeline

557
00:19:16,960 --> 00:19:17,760
so

558
00:19:17,760 --> 00:19:19,200
we have reported the bug through haka

559
00:19:19,200 --> 00:19:20,960
one on the fourth of january last year

560
00:19:20,960 --> 00:19:22,320
and it was actually charged a couple of

561
00:19:22,320 --> 00:19:24,480
days later by a hacker one employee and

562
00:19:24,480 --> 00:19:26,240
then nothing happened for almost three

563
00:19:26,240 --> 00:19:27,039
months

564
00:19:27,039 --> 00:19:28,160
so yeah

565
00:19:28,160 --> 00:19:29,679
we already gave up on like getting a

566
00:19:29,679 --> 00:19:31,360
bounty and we hope to just get a blog

567
00:19:31,360 --> 00:19:33,280
post at some point

568
00:19:33,280 --> 00:19:34,640
but then some other people actually

569
00:19:34,640 --> 00:19:35,840
published posts about counter-strike

570
00:19:35,840 --> 00:19:37,600
vulnerabilities on twitter and we joined

571
00:19:37,600 --> 00:19:39,440
them and published a video of our

572
00:19:39,440 --> 00:19:40,960
exploit as well

573
00:19:40,960 --> 00:19:43,039
then after a couple of days a couple of

574
00:19:43,039 --> 00:19:44,240
news outlets actually covered the

575
00:19:44,240 --> 00:19:46,240
vulnerabilities which then apparently

576
00:19:46,240 --> 00:19:48,400
made valve focused on the heka1 reports

577
00:19:48,400 --> 00:19:49,520
and we noticed that it was slowly

578
00:19:49,520 --> 00:19:52,240
getting fixed and that gave us hope

579
00:19:52,240 --> 00:19:54,080
eventually so like eventually our report

580
00:19:54,080 --> 00:19:55,679
was fixed and we actually received

581
00:19:55,679 --> 00:19:57,840
fifteen thousand dollars as a bounty

582
00:19:57,840 --> 00:19:59,520
yeah but unfortunately the communication

583
00:19:59,520 --> 00:20:01,120
was only through echo one representative

584
00:20:01,120 --> 00:20:02,320
and we never got any message from a

585
00:20:02,320 --> 00:20:04,880
valve employee

586
00:20:04,880 --> 00:20:06,960
yeah so this is the end of our talk

587
00:20:06,960 --> 00:20:08,320
feel free to ask us any questions you

588
00:20:08,320 --> 00:20:10,080
can also reach us through twitter

589
00:20:10,080 --> 00:20:14,039
and yeah that's it

