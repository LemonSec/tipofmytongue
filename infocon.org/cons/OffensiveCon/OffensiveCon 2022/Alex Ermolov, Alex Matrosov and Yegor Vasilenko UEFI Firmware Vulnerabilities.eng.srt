1
00:00:03,919 --> 00:00:06,399
hello berlin

2
00:00:06,399 --> 00:00:08,800
so only for offensive con i can wake up

3
00:00:08,800 --> 00:00:10,960
too early and deliver the talk at 7 00

4
00:00:10,960 --> 00:00:12,000
am

5
00:00:12,000 --> 00:00:13,599
but today we have a lot of stuff to

6
00:00:13,599 --> 00:00:16,079
discuss and uh

7
00:00:16,079 --> 00:00:17,760
actually i'm very happy to be on the

8
00:00:17,760 --> 00:00:21,439
stage again on offensive con and uh uh

9
00:00:21,439 --> 00:00:24,160
i'm alex matroz of uh alex your mole

10
00:00:24,160 --> 00:00:27,119
office here and jaguar vasilenko also

11
00:00:27,119 --> 00:00:29,199
been a part of this research and we will

12
00:00:29,199 --> 00:00:31,199
be discussed today ufi firmware

13
00:00:31,199 --> 00:00:33,840
vulnerabilities past present and future

14
00:00:33,840 --> 00:00:37,600
who we are and we represent here uh

15
00:00:37,600 --> 00:00:39,840
binary if i explore team

16
00:00:39,840 --> 00:00:42,399
and actually binary if i explore team

17
00:00:42,399 --> 00:00:45,840
focused on offensive research and we

18
00:00:45,840 --> 00:00:48,800
are continuously committing to actually

19
00:00:48,800 --> 00:00:50,719
apply our offensive research to

20
00:00:50,719 --> 00:00:53,600
defensive practices and protect the

21
00:00:53,600 --> 00:00:56,160
companies which we work in with

22
00:00:56,160 --> 00:00:58,160
you can find a bit more on these links

23
00:00:58,160 --> 00:01:00,559
about our research and uh

24
00:01:00,559 --> 00:01:02,399
and something else

25
00:01:02,399 --> 00:01:03,199
so

26
00:01:03,199 --> 00:01:04,000
but

27
00:01:04,000 --> 00:01:05,519
let's talk about how many

28
00:01:05,519 --> 00:01:08,320
vulnerabilities we will be talked uh

29
00:01:08,320 --> 00:01:11,200
today you know delivering our talk today

30
00:01:11,200 --> 00:01:13,680
one two five ten

31
00:01:13,680 --> 00:01:16,240
no it's actually much more and we will

32
00:01:16,240 --> 00:01:19,040
be talk about 28 vulnerabilities which

33
00:01:19,040 --> 00:01:22,159
being discovered by our team and today

34
00:01:22,159 --> 00:01:24,320
is another five uh

35
00:01:24,320 --> 00:01:28,560
date of disclosure for hp and uh let's

36
00:01:28,560 --> 00:01:30,240
go actually

37
00:01:30,240 --> 00:01:31,520
um

38
00:01:31,520 --> 00:01:34,079
these 23 vulnerabilities being disclosed

39
00:01:34,079 --> 00:01:36,640
uh earlier this week and we

40
00:01:36,640 --> 00:01:38,880
specifically target this disclosure for

41
00:01:38,880 --> 00:01:41,759
offensive conference and you can see

42
00:01:41,759 --> 00:01:44,479
here is a lot of vulnerabilities related

43
00:01:44,479 --> 00:01:48,720
to system management uh mod of x86

44
00:01:48,720 --> 00:01:52,159
ecosystems where basically you can get a

45
00:01:52,159 --> 00:01:55,200
privilege escalation or code execution

46
00:01:55,200 --> 00:01:57,920
choose memory corruption and uh to be

47
00:01:57,920 --> 00:01:59,759
honest finding ufi firmware

48
00:01:59,759 --> 00:02:01,520
vulnerabilities it is addictive as you

49
00:02:01,520 --> 00:02:02,479
can see

50
00:02:02,479 --> 00:02:03,759
and

51
00:02:03,759 --> 00:02:06,840
we want to thanks uh thank

52
00:02:06,840 --> 00:02:08,639
um

53
00:02:08,639 --> 00:02:11,440
inside pcr because we want to

54
00:02:11,440 --> 00:02:13,920
acknowledge their work and actually

55
00:02:13,920 --> 00:02:16,080
they've been collaborating with us and

56
00:02:16,080 --> 00:02:18,239
very productively fixing the

57
00:02:18,239 --> 00:02:20,959
vulnerabilities we discussed with them

58
00:02:20,959 --> 00:02:24,000
also it's another five we will be

59
00:02:24,000 --> 00:02:26,800
talking through our talk today uh it's

60
00:02:26,800 --> 00:02:29,760
related to the hp and also we want to

61
00:02:29,760 --> 00:02:31,920
acknowledge uh the collaboration between

62
00:02:31,920 --> 00:02:34,720
hp pcr and binary to make these

63
00:02:34,720 --> 00:02:36,800
vulnerabilities fixed

64
00:02:36,800 --> 00:02:39,280
all right uh what this vulnerability

65
00:02:39,280 --> 00:02:40,879
stands for and

66
00:02:40,879 --> 00:02:44,400
you can think about like okay we have

67
00:02:44,400 --> 00:02:46,400
this privilege escalation to system

68
00:02:46,400 --> 00:02:48,720
management mode or we have uh code

69
00:02:48,720 --> 00:02:50,560
execution and system management mod what

70
00:02:50,560 --> 00:02:53,760
we can do and to be honest usually

71
00:02:53,760 --> 00:02:56,000
such vulnerabilities can be used for the

72
00:02:56,000 --> 00:02:57,840
second stage of exploit to gain

73
00:02:57,840 --> 00:03:00,159
persistent into the firmware even if as

74
00:03:00,159 --> 00:03:02,239
example you don't have a right primitive

75
00:03:02,239 --> 00:03:03,680
or basically

76
00:03:03,680 --> 00:03:06,959
spy flash or firmer storage protected

77
00:03:06,959 --> 00:03:09,840
it is still a lot of possibilities for

78
00:03:09,840 --> 00:03:13,599
the attacker deliver as example uh in a

79
00:03:13,599 --> 00:03:16,319
memory implant to the system management

80
00:03:16,319 --> 00:03:18,480
mode not persistent but as example

81
00:03:18,480 --> 00:03:20,640
servers not reboots very frequently also

82
00:03:20,640 --> 00:03:23,519
you can bypass your boot and other uh

83
00:03:23,519 --> 00:03:26,239
integrity checking policies also tpms

84
00:03:26,239 --> 00:03:28,319
and health attestation for device will

85
00:03:28,319 --> 00:03:30,480
not help because basically pcrs

86
00:03:30,480 --> 00:03:34,560
registers on tpms doesn't extend after

87
00:03:34,560 --> 00:03:37,680
runtime happens right so basically you

88
00:03:37,680 --> 00:03:41,519
have a particular state of your system

89
00:03:41,519 --> 00:03:43,920
when the system boots but if you have a

90
00:03:43,920 --> 00:03:45,840
runtime expectation such of the

91
00:03:45,840 --> 00:03:49,440
mitigations doesn't help unfortunately

92
00:03:49,440 --> 00:03:50,720
and

93
00:03:50,720 --> 00:03:51,599
also

94
00:03:51,599 --> 00:03:53,439
recently kaspersky lab discovered

95
00:03:53,439 --> 00:03:57,120
moonbound so such of the firmware boot

96
00:03:57,120 --> 00:03:59,439
kits and implants can be

97
00:03:59,439 --> 00:04:01,760
use such of the vulnerabilities we will

98
00:04:01,760 --> 00:04:04,560
be talking today to deliver payload into

99
00:04:04,560 --> 00:04:06,319
the firmware

100
00:04:06,319 --> 00:04:07,040
but

101
00:04:07,040 --> 00:04:10,080
why that happens so first of all uh most

102
00:04:10,080 --> 00:04:11,760
of the vulnerabilities will be talking

103
00:04:11,760 --> 00:04:14,159
today it's not targeting a single vendor

104
00:04:14,159 --> 00:04:16,798
it's targeting uh multiple vendors

105
00:04:16,798 --> 00:04:18,720
because it's been found in the reference

106
00:04:18,720 --> 00:04:21,199
code and basically

107
00:04:21,199 --> 00:04:23,840
i think everyone knows what the lock 4g

108
00:04:23,840 --> 00:04:25,680
issue stands for from the previous

109
00:04:25,680 --> 00:04:29,280
december and i would say

110
00:04:29,280 --> 00:04:30,639
pretty much

111
00:04:30,639 --> 00:04:33,120
similar problems can be happens on any

112
00:04:33,120 --> 00:04:35,680
ecosystem where the components get

113
00:04:35,680 --> 00:04:38,960
reused and adopted by multiple vendors

114
00:04:38,960 --> 00:04:41,280
this is visual changes right so

115
00:04:41,280 --> 00:04:43,040
basically if you find vulnerabilities in

116
00:04:43,040 --> 00:04:45,520
such component it can be applicable for

117
00:04:45,520 --> 00:04:48,479
any vendor not just one and

118
00:04:48,479 --> 00:04:51,680
from this disclosure it is actually 25

119
00:04:51,680 --> 00:04:54,560
vendors different vendors being targeted

120
00:04:54,560 --> 00:04:56,240
by the vulnerabilities we discussed

121
00:04:56,240 --> 00:04:58,400
hopefully everyone from this disclosure

122
00:04:58,400 --> 00:05:00,800
already got fixed in their uh device

123
00:05:00,800 --> 00:05:04,000
ecosystem most of them did and that's a

124
00:05:04,000 --> 00:05:06,639
good news but update your firmware

125
00:05:06,639 --> 00:05:08,479
so

126
00:05:08,479 --> 00:05:11,280
just briefly about ufi ecosystem right

127
00:05:11,280 --> 00:05:14,639
so we have a intel amd reference code we

128
00:05:14,639 --> 00:05:17,199
have a tiana core edk2 reference code

129
00:05:17,199 --> 00:05:19,919
but also we have another layer which is

130
00:05:19,919 --> 00:05:22,000
called independent bias developers which

131
00:05:22,000 --> 00:05:25,199
is actually developing uh another layer

132
00:05:25,199 --> 00:05:26,960
of the reference code which is get

133
00:05:26,960 --> 00:05:29,039
adopted by many other companies and to

134
00:05:29,039 --> 00:05:30,960
be honest like device manufacturers

135
00:05:30,960 --> 00:05:33,520
usually not develop much code themselves

136
00:05:33,520 --> 00:05:35,199
they usually develop some piece of the

137
00:05:35,199 --> 00:05:38,000
code which is target specific device for

138
00:05:38,000 --> 00:05:41,039
some particular features which is unique

139
00:05:41,039 --> 00:05:45,520
for the device itself but not for ufi

140
00:05:45,520 --> 00:05:47,120
ecosystem

141
00:05:47,120 --> 00:05:48,000
and

142
00:05:48,000 --> 00:05:49,280
also

143
00:05:49,280 --> 00:05:51,919
if you think about uefi firmware it is

144
00:05:51,919 --> 00:05:52,880
actually a

145
00:05:52,880 --> 00:05:55,360
cool operating system inside your

146
00:05:55,360 --> 00:05:58,560
computer it is over 6 million lines of

147
00:05:58,560 --> 00:06:01,199
code it is actually bigger than nowadays

148
00:06:01,199 --> 00:06:04,720
in dos kernel right from microsoft

149
00:06:04,720 --> 00:06:08,560
and of course uh such of the huge attack

150
00:06:08,560 --> 00:06:10,479
surface can be impacted by multiple

151
00:06:10,479 --> 00:06:12,960
vulnerabilities a few words about

152
00:06:12,960 --> 00:06:15,280
disclosure uh first of all like

153
00:06:15,280 --> 00:06:17,360
coordinating disclosure with multiple

154
00:06:17,360 --> 00:06:20,479
vendors it's tough and of course like uh

155
00:06:20,479 --> 00:06:24,240
one single company can do it uh

156
00:06:24,240 --> 00:06:26,319
very well because first of all if you're

157
00:06:26,319 --> 00:06:28,240
disclosing this one vendor usually this

158
00:06:28,240 --> 00:06:30,639
vendor cares more about their security

159
00:06:30,639 --> 00:06:33,440
posture and they don't basically pay

160
00:06:33,440 --> 00:06:36,160
much attention to disclosing or recover

161
00:06:36,160 --> 00:06:38,400
uh everyone who

162
00:06:38,400 --> 00:06:40,240
potentially can be targeted by such

163
00:06:40,240 --> 00:06:43,120
vulnerabilities it's why uh the best

164
00:06:43,120 --> 00:06:44,720
probably approach in such of the

165
00:06:44,720 --> 00:06:46,319
industry-wide disclosure to pick

166
00:06:46,319 --> 00:06:48,960
independent party like carnegie mellon

167
00:06:48,960 --> 00:06:51,919
search or cc to basically go through all

168
00:06:51,919 --> 00:06:53,840
the vendors uh

169
00:06:53,840 --> 00:06:56,880
with the same time and same dedication

170
00:06:56,880 --> 00:06:59,039
and what we did and actually

171
00:06:59,039 --> 00:07:03,360
linux firmware volume uh service lvfs

172
00:07:03,360 --> 00:07:06,240
helps us a lot to actually scope all the

173
00:07:06,240 --> 00:07:09,120
targeted vendors and get them in time

174
00:07:09,120 --> 00:07:11,440
updated about

175
00:07:11,440 --> 00:07:14,160
this vulnerabilities and

176
00:07:14,160 --> 00:07:15,599
think

177
00:07:15,599 --> 00:07:18,560
this patch cycle with everyone who is

178
00:07:18,560 --> 00:07:21,120
actually impacted

179
00:07:21,120 --> 00:07:22,720
but

180
00:07:22,720 --> 00:07:24,639
the former supply chain condition

181
00:07:24,639 --> 00:07:27,199
unfortunately exists what does that mean

182
00:07:27,199 --> 00:07:29,120
uh update

183
00:07:29,120 --> 00:07:30,560
updates

184
00:07:30,560 --> 00:07:33,360
process is actually asynchronous have a

185
00:07:33,360 --> 00:07:36,240
asynchronous nature by design and

186
00:07:36,240 --> 00:07:37,280
between

187
00:07:37,280 --> 00:07:39,360
patching vulnerabilities and upcoming

188
00:07:39,360 --> 00:07:41,919
fixes and third parties

189
00:07:41,919 --> 00:07:44,800
it is always exists some time frame

190
00:07:44,800 --> 00:07:46,639
which is actually create some sort of

191
00:07:46,639 --> 00:07:48,800
phrase condition when as example

192
00:07:48,800 --> 00:07:50,960
reference code vendor released earlier

193
00:07:50,960 --> 00:07:52,720
the patch or

194
00:07:52,720 --> 00:07:54,800
as example device vendor released

195
00:07:54,800 --> 00:07:58,400
earlier the update and new fixes didn't

196
00:07:58,400 --> 00:08:01,360
apply to this update and the next patch

197
00:08:01,360 --> 00:08:03,599
cycle will be in the few months and

198
00:08:03,599 --> 00:08:06,160
usually that happens which is actually

199
00:08:06,160 --> 00:08:09,440
creating the problems when

200
00:08:09,440 --> 00:08:11,840
multiple devices can stay unfixed with

201
00:08:11,840 --> 00:08:14,720
even known vulnerabilities

202
00:08:14,720 --> 00:08:15,520
and

203
00:08:15,520 --> 00:08:17,440
this picture just illustrating what i've

204
00:08:17,440 --> 00:08:20,000
been saying on the previous slide and

205
00:08:20,000 --> 00:08:22,080
exactly what's happening

206
00:08:22,080 --> 00:08:23,680
it is a

207
00:08:23,680 --> 00:08:26,240
race condition on different layers of

208
00:08:26,240 --> 00:08:29,120
delivery of the patch

209
00:08:29,120 --> 00:08:30,160
to the

210
00:08:30,160 --> 00:08:32,399
endpoint system and of course customers

211
00:08:32,399 --> 00:08:35,200
get hurt always in such of the process

212
00:08:35,200 --> 00:08:38,000
but disclosing vulnerabilities and get

213
00:08:38,000 --> 00:08:40,240
them fixed it's two different problems

214
00:08:40,240 --> 00:08:41,679
and should be of course solved

215
00:08:41,679 --> 00:08:45,680
separately but let's go uh more about

216
00:08:45,680 --> 00:08:47,519
uh what we will

217
00:08:47,519 --> 00:08:49,760
deliver in this talk we'll be talking

218
00:08:49,760 --> 00:08:51,920
about more vulnerabilities mitigations

219
00:08:51,920 --> 00:08:54,399
and how it will be bypassed but also of

220
00:08:54,399 --> 00:08:56,000
course we need to provide some tooling

221
00:08:56,000 --> 00:08:57,920
to detect such of the vulnerabilities

222
00:08:57,920 --> 00:09:00,720
you can find our firmware controls uh in

223
00:09:00,720 --> 00:09:03,600
our github repository it opens source so

224
00:09:03,600 --> 00:09:06,720
you can uh just use for the detection

225
00:09:06,720 --> 00:09:08,160
all the

226
00:09:08,160 --> 00:09:11,120
firmware hand detections available

227
00:09:11,120 --> 00:09:12,720
all right so let's focus on the

228
00:09:12,720 --> 00:09:14,560
vulnerabilities and

229
00:09:14,560 --> 00:09:17,120
i will be spoiled a bit uh in the next

230
00:09:17,120 --> 00:09:20,160
part you will see the full smm rop

231
00:09:20,160 --> 00:09:22,800
exploit never been present publicly

232
00:09:22,800 --> 00:09:25,760
before alex stage is yours

233
00:09:25,760 --> 00:09:27,120
okay

234
00:09:27,120 --> 00:09:30,080
uh thank you thank you hello everyone i

235
00:09:30,080 --> 00:09:32,240
think thanks for coming so uh we'll

236
00:09:32,240 --> 00:09:34,320
start with the discussion about the

237
00:09:34,320 --> 00:09:37,040
perfect example of a component uh in

238
00:09:37,040 --> 00:09:39,440
supply chain which initially has a

239
00:09:39,440 --> 00:09:41,920
complex architecture and wasn't intended

240
00:09:41,920 --> 00:09:42,800
to be

241
00:09:42,800 --> 00:09:44,399
much secure

242
00:09:44,399 --> 00:09:46,720
first when the vulnerability discoveries

243
00:09:46,720 --> 00:09:49,440
in in this component made

244
00:09:49,440 --> 00:09:51,279
developers to apply

245
00:09:51,279 --> 00:09:53,279
accurate and

246
00:09:53,279 --> 00:09:55,680
targeted security fixes however the

247
00:09:55,680 --> 00:09:59,040
initial complexity of uh and insecure

248
00:09:59,040 --> 00:10:01,920
design of this component of this module

249
00:10:01,920 --> 00:10:03,120
uh

250
00:10:03,120 --> 00:10:06,480
created the opportunity to discover more

251
00:10:06,480 --> 00:10:09,360
variants of those bugs and even

252
00:10:09,360 --> 00:10:10,880
rediscover it

253
00:10:10,880 --> 00:10:12,560
multiple times

254
00:10:12,560 --> 00:10:15,279
so that's why we call this part

255
00:10:15,279 --> 00:10:19,839
of the presentation as the past

256
00:10:20,240 --> 00:10:23,040
so i as you can see we are talking about

257
00:10:23,040 --> 00:10:26,560
the usbrt component which is the part of

258
00:10:26,560 --> 00:10:29,040
mei ufi firmware code based used by a

259
00:10:29,040 --> 00:10:30,560
lot of vendors

260
00:10:30,560 --> 00:10:32,560
and shipped to uh

261
00:10:32,560 --> 00:10:33,760
millions

262
00:10:33,760 --> 00:10:35,279
uh

263
00:10:35,279 --> 00:10:38,160
endpoint users and as you can see it has

264
00:10:38,160 --> 00:10:41,440
an initially complex architecture uh

265
00:10:41,440 --> 00:10:46,079
it has dxc park it has smm part uh it

266
00:10:46,079 --> 00:10:49,200
all of these uh intended to

267
00:10:49,200 --> 00:10:50,800
handle uh

268
00:10:50,800 --> 00:10:54,000
intended to handle usb events uh in in

269
00:10:54,000 --> 00:10:56,880
boot time and in runtime and for these

270
00:10:56,880 --> 00:10:58,640
for these purposes they are multiple a

271
00:10:58,640 --> 00:11:01,360
software and hardware smi handlers in

272
00:11:01,360 --> 00:11:04,720
this module and the dxe and uh

273
00:11:04,720 --> 00:11:08,000
and runtime sms smm part

274
00:11:08,000 --> 00:11:10,079
are communicating to each other through

275
00:11:10,079 --> 00:11:10,880
a

276
00:11:10,880 --> 00:11:13,600
through an object a huge complex object

277
00:11:13,600 --> 00:11:16,640
called usb global data and this is the

278
00:11:16,640 --> 00:11:17,519
point

279
00:11:17,519 --> 00:11:19,519
of

280
00:11:19,519 --> 00:11:21,040
this is a starting point of attacks

281
00:11:21,040 --> 00:11:21,920
because

282
00:11:21,920 --> 00:11:23,040
it has

283
00:11:23,040 --> 00:11:25,200
a lot of pointers inside it a lot of

284
00:11:25,200 --> 00:11:27,760
nested and nested nested pointers inside

285
00:11:27,760 --> 00:11:30,000
it and

286
00:11:30,000 --> 00:11:31,120
and

287
00:11:31,120 --> 00:11:34,320
even the function pointers are also uh

288
00:11:34,320 --> 00:11:37,279
stored in this in this huge data block

289
00:11:37,279 --> 00:11:39,600
so which which is uh started in

290
00:11:39,600 --> 00:11:42,480
untrusted for smm the untrusted memory

291
00:11:42,480 --> 00:11:43,920
system memory

292
00:11:43,920 --> 00:11:45,440
uh so

293
00:11:45,440 --> 00:11:46,640
if you

294
00:11:46,640 --> 00:11:48,079
if we'll go

295
00:11:48,079 --> 00:11:51,600
next we we we can see that

296
00:11:51,600 --> 00:11:53,680
that the first wake up call happened in

297
00:11:53,680 --> 00:11:55,839
2016

298
00:11:55,839 --> 00:11:56,800
and

299
00:11:56,800 --> 00:11:59,040
the

300
00:11:59,120 --> 00:12:01,040
no it was the

301
00:12:01,040 --> 00:12:03,760
previous slide

302
00:12:03,760 --> 00:12:04,720
yeah

303
00:12:04,720 --> 00:12:07,200
this is the one yeah the the first uh

304
00:12:07,200 --> 00:12:10,800
the first wake-up call happened in 2007

305
00:12:10,800 --> 00:12:12,639
and we go briefly through this

306
00:12:12,639 --> 00:12:14,240
vulnerability

307
00:12:14,240 --> 00:12:15,040
this

308
00:12:15,040 --> 00:12:17,839
as you can see untrusted input for

309
00:12:17,839 --> 00:12:21,760
software semi handler of usbrt

310
00:12:21,760 --> 00:12:25,519
it extracts from extended bias data area

311
00:12:25,519 --> 00:12:27,760
this the pointer to a struct we call it

312
00:12:27,760 --> 00:12:29,760
the structure struct pointer

313
00:12:29,760 --> 00:12:31,920
and the pointer is passed through uh

314
00:12:31,920 --> 00:12:35,279
with no sanity checks to a function and

315
00:12:35,279 --> 00:12:37,120
and this function

316
00:12:37,120 --> 00:12:43,600
writes uh fixed data byte f0 through

317
00:12:43,600 --> 00:12:45,279
to

318
00:12:45,279 --> 00:12:47,920
the data pointed by this struct by by

319
00:12:47,920 --> 00:12:50,959
this point structural structure pointer

320
00:12:50,959 --> 00:12:53,518
and uh

321
00:12:53,760 --> 00:12:55,440
as you can see untrusted input no

322
00:12:55,440 --> 00:12:58,240
sanitation and uh memory corruption

323
00:12:58,240 --> 00:12:59,279
classical memory corruption

324
00:12:59,279 --> 00:13:00,880
vulnerabilities so

325
00:13:00,880 --> 00:13:02,959
uh when when we

326
00:13:02,959 --> 00:13:05,360
let's go next

327
00:13:05,360 --> 00:13:09,880
uh so the a few years ago in 2000

328
00:13:09,880 --> 00:13:12,480
2017 another vulnerability was

329
00:13:12,480 --> 00:13:15,120
discovered it was discovered also in

330
00:13:15,120 --> 00:13:16,480
intel nukes

331
00:13:16,480 --> 00:13:18,320
uh and uh

332
00:13:18,320 --> 00:13:20,480
the

333
00:13:20,480 --> 00:13:23,120
let's go next the the vulnerability

334
00:13:23,120 --> 00:13:24,160
itself

335
00:13:24,160 --> 00:13:25,680
uh was

336
00:13:25,680 --> 00:13:29,760
was a bit deeper than the original one

337
00:13:29,760 --> 00:13:31,440
it was a call out

338
00:13:31,440 --> 00:13:34,320
and the vulnerability

339
00:13:34,320 --> 00:13:37,040
so i'm showing on the exact

340
00:13:37,040 --> 00:13:39,440
code page so so you can understand what

341
00:13:39,440 --> 00:13:41,839
i'm talking about uh

342
00:13:41,839 --> 00:13:45,199
again untrusted input software

343
00:13:45,199 --> 00:13:48,480
structure pointer it was sanitated later

344
00:13:48,480 --> 00:13:49,360
or

345
00:13:49,360 --> 00:13:51,120
we are not talking about sanitation the

346
00:13:51,120 --> 00:13:54,399
structure point however uh the there is

347
00:13:54,399 --> 00:13:57,440
a call uh there is an index which is

348
00:13:57,440 --> 00:13:59,519
extracted from the structure pointer

349
00:13:59,519 --> 00:14:01,120
this is the function index and the

350
00:14:01,120 --> 00:14:05,600
function is called from a usb api table

351
00:14:05,600 --> 00:14:06,560
and

352
00:14:06,560 --> 00:14:10,720
the and this table contains uh

353
00:14:10,720 --> 00:14:13,279
multiple functions which could be called

354
00:14:13,279 --> 00:14:15,120
and attacker

355
00:14:15,120 --> 00:14:17,040
caller of this software smart handler

356
00:14:17,040 --> 00:14:18,959
can specify which

357
00:14:18,959 --> 00:14:21,600
exactly which function will be called so

358
00:14:21,600 --> 00:14:25,279
in the next slide uh you can see that uh

359
00:14:25,279 --> 00:14:27,120
that

360
00:14:27,120 --> 00:14:28,880
here is here this table on the on the

361
00:14:28,880 --> 00:14:30,560
left and

362
00:14:30,560 --> 00:14:32,480
and the function

363
00:14:32,480 --> 00:14:36,000
usb ipa function number 14 in this table

364
00:14:36,000 --> 00:14:38,399
leads to a call out at least you call

365
00:14:38,399 --> 00:14:41,440
that where a function and parameters is

366
00:14:41,440 --> 00:14:45,600
extracted from structure pointer and

367
00:14:45,600 --> 00:14:47,680
from the structure pointed by structure

368
00:14:47,680 --> 00:14:50,160
pointer and

369
00:14:50,160 --> 00:14:51,519
and there is

370
00:14:51,519 --> 00:14:54,720
uh there is a function block which

371
00:14:54,720 --> 00:14:55,920
allows to

372
00:14:55,920 --> 00:14:57,920
call

373
00:14:57,920 --> 00:15:00,480
an arbitrary function and with record

374
00:15:00,480 --> 00:15:05,199
and specify up to seven parameters in it

375
00:15:05,199 --> 00:15:06,000
so

376
00:15:06,000 --> 00:15:06,959
yeah

377
00:15:06,959 --> 00:15:08,000
they

378
00:15:08,000 --> 00:15:10,000
they have

379
00:15:10,000 --> 00:15:12,880
they try to to patch it with

380
00:15:12,880 --> 00:15:15,760
adding the validation for uh structure

381
00:15:15,760 --> 00:15:19,040
pointed for usb global data uh so uh

382
00:15:19,040 --> 00:15:19,920
they

383
00:15:19,920 --> 00:15:21,600
actually the first attempt was like

384
00:15:21,600 --> 00:15:22,720
adding the

385
00:15:22,720 --> 00:15:25,199
uh the uh

386
00:15:25,199 --> 00:15:28,079
the sanitation of pointers of course and

387
00:15:28,079 --> 00:15:30,639
then uh validation of the

388
00:15:30,639 --> 00:15:32,480
protecting the pointers that are

389
00:15:32,480 --> 00:15:34,560
actually should point to smm like

390
00:15:34,560 --> 00:15:36,320
function pointers

391
00:15:36,320 --> 00:15:38,160
and

392
00:15:38,160 --> 00:15:38,959
see

393
00:15:38,959 --> 00:15:41,279
they they started to protect to protect

394
00:15:41,279 --> 00:15:45,440
this block with a crc 32 uh check sound

395
00:15:45,440 --> 00:15:48,000
which is uh which is actually not strong

396
00:15:48,000 --> 00:15:52,320
enough to secure the data and there is a

397
00:15:52,320 --> 00:15:55,279
there is a method to spoof it there's a

398
00:15:55,279 --> 00:15:57,120
project that can

399
00:15:57,120 --> 00:16:00,880
allow to do it automatically so

400
00:16:00,880 --> 00:16:03,600
let's go next

401
00:16:03,680 --> 00:16:04,800
here

402
00:16:04,800 --> 00:16:09,120
in on the left side you can see the crc

403
00:16:09,120 --> 00:16:10,399
table

404
00:16:10,399 --> 00:16:12,320
initialization routine

405
00:16:12,320 --> 00:16:13,759
which was

406
00:16:13,759 --> 00:16:15,680
initially applied with this static

407
00:16:15,680 --> 00:16:17,040
polynomial

408
00:16:17,040 --> 00:16:18,560
and

409
00:16:18,560 --> 00:16:21,120
and to fix to in the second in the

410
00:16:21,120 --> 00:16:22,720
second try to fix this vulnerability

411
00:16:22,720 --> 00:16:25,360
they applied a dynamic polynomial which

412
00:16:25,360 --> 00:16:28,320
was uh uh extracted as you can see in

413
00:16:28,320 --> 00:16:29,920
the center in

414
00:16:29,920 --> 00:16:32,959
from the mi usb sman protocol

415
00:16:32,959 --> 00:16:34,560
which in turn

416
00:16:34,560 --> 00:16:35,680
uh

417
00:16:35,680 --> 00:16:37,360
which in turn it

418
00:16:37,360 --> 00:16:39,440
extracts it from

419
00:16:39,440 --> 00:16:43,199
from power management timer and this

420
00:16:43,199 --> 00:16:45,440
value though it will be unique for

421
00:16:45,440 --> 00:16:48,160
different systems of course but for

422
00:16:48,160 --> 00:16:51,759
exact system exact uh firmware exactly

423
00:16:51,759 --> 00:16:54,399
the configuration from boot to boot in

424
00:16:54,399 --> 00:16:57,360
most cases it won't be

425
00:16:57,360 --> 00:17:00,160
it won't be different but

426
00:17:00,160 --> 00:17:01,199
but

427
00:17:01,199 --> 00:17:04,640
for like brute forcing uh they have

428
00:17:04,640 --> 00:17:06,319
added the

429
00:17:06,319 --> 00:17:08,559
locked plug that allows us

430
00:17:08,559 --> 00:17:09,839
to

431
00:17:09,839 --> 00:17:12,559
make only one attempt per boot

432
00:17:12,559 --> 00:17:13,760
to

433
00:17:13,760 --> 00:17:16,240
to use this software as my handler and

434
00:17:16,240 --> 00:17:19,439
this solution well it kind of worked

435
00:17:19,439 --> 00:17:20,319
uh

436
00:17:20,319 --> 00:17:22,240
let's go next

437
00:17:22,240 --> 00:17:27,599
kind of work yeah yes but no we we uh

438
00:17:27,599 --> 00:17:29,760
there is uh there is

439
00:17:29,760 --> 00:17:31,760
there was another discovery of the

440
00:17:31,760 --> 00:17:34,320
vulnerability in the usbrt

441
00:17:34,320 --> 00:17:37,600
but not in intel nukes in intel servers

442
00:17:37,600 --> 00:17:40,559
it was in 2020

443
00:17:40,559 --> 00:17:41,230
so

444
00:17:41,230 --> 00:17:42,480
[Music]

445
00:17:42,480 --> 00:17:45,200
you can go next please yeah

446
00:17:45,200 --> 00:17:48,000
so in 2020

447
00:17:48,000 --> 00:17:48,799
uh

448
00:17:48,799 --> 00:17:50,960
the exactly the same vulnerability was

449
00:17:50,960 --> 00:17:55,039
found that was in 2017 uh usb ipad

450
00:17:55,039 --> 00:17:58,799
function number 14. no crc32 validation

451
00:17:58,799 --> 00:18:01,679
wasn't applied

452
00:18:01,679 --> 00:18:02,960
at that moment

453
00:18:02,960 --> 00:18:05,520
and this is a classical uh

454
00:18:05,520 --> 00:18:07,679
classical example of where a fixes

455
00:18:07,679 --> 00:18:10,240
delivery problem exists for different

456
00:18:10,240 --> 00:18:13,280
product lines even in one

457
00:18:13,280 --> 00:18:15,360
vendor so

458
00:18:15,360 --> 00:18:17,280
inside as you can see inside intel

459
00:18:17,280 --> 00:18:20,080
devices uh hierarchy code branches could

460
00:18:20,080 --> 00:18:21,679
be could not be

461
00:18:21,679 --> 00:18:24,960
could be kept not up to date in years

462
00:18:24,960 --> 00:18:26,000
and

463
00:18:26,000 --> 00:18:28,960
however this was not enough and on the

464
00:18:28,960 --> 00:18:32,000
next slide uh this was not enough for us

465
00:18:32,000 --> 00:18:32,960
and

466
00:18:32,960 --> 00:18:38,799
we as we can see in 2020 again uh and

467
00:18:38,799 --> 00:18:41,200
one another time in intel servers the

468
00:18:41,200 --> 00:18:43,520
intel servers they were the

469
00:18:43,520 --> 00:18:45,760
vulnerability were discovered

470
00:18:45,760 --> 00:18:47,280
in another

471
00:18:47,280 --> 00:18:50,160
function from this usb api table and

472
00:18:50,160 --> 00:18:52,960
this function allows to

473
00:18:52,960 --> 00:18:54,160
to

474
00:18:54,160 --> 00:18:56,960
call out from smm

475
00:18:56,960 --> 00:19:00,400
uh all all pointers uh for

476
00:19:00,400 --> 00:19:02,960
all all the data for calculating the

477
00:19:02,960 --> 00:19:05,840
function pointer uh in in the

478
00:19:05,840 --> 00:19:08,480
highlighted block are extracted from the

479
00:19:08,480 --> 00:19:11,280
usb data which is in system memory hence

480
00:19:11,280 --> 00:19:15,120
it is controllable by an attacker and uh

481
00:19:15,120 --> 00:19:16,160
at

482
00:19:16,160 --> 00:19:19,200
this point uh crc 32

483
00:19:19,200 --> 00:19:22,080
with custom table was applied but it was

484
00:19:22,080 --> 00:19:25,440
not covering all usb data contents

485
00:19:25,440 --> 00:19:26,480
and

486
00:19:26,480 --> 00:19:27,440
that was

487
00:19:27,440 --> 00:19:30,400
that was the vulnerability so

488
00:19:30,400 --> 00:19:33,039
uh the there was another discovery under

489
00:19:33,039 --> 00:19:35,840
the same cbe uh the vulnerability it is

490
00:19:35,840 --> 00:19:38,400
the same exactly the same cloud exactly

491
00:19:38,400 --> 00:19:43,120
the same uh well same way quite similar

492
00:19:43,120 --> 00:19:45,840
formula to calculate the function

493
00:19:45,840 --> 00:19:48,320
pointer which is extracted from the

494
00:19:48,320 --> 00:19:51,600
untrusted input global usb data

495
00:19:51,600 --> 00:19:52,799
and

496
00:19:52,799 --> 00:19:53,520
but

497
00:19:53,520 --> 00:19:55,679
the difference is that

498
00:19:55,679 --> 00:19:58,080
the the the previous will all previous

499
00:19:58,080 --> 00:20:00,080
vulnerabilities were in

500
00:20:00,080 --> 00:20:02,559
software as my handler but this one is

501
00:20:02,559 --> 00:20:05,280
in hardware as my handler will

502
00:20:05,280 --> 00:20:06,559
be quite more

503
00:20:06,559 --> 00:20:07,760
tricky to

504
00:20:07,760 --> 00:20:12,400
trigger but it is it handles usb events

505
00:20:12,400 --> 00:20:14,000
so um

506
00:20:14,000 --> 00:20:16,480
finally finally

507
00:20:16,480 --> 00:20:17,760
the

508
00:20:17,760 --> 00:20:20,799
in 2021

509
00:20:20,799 --> 00:20:21,520
we

510
00:20:21,520 --> 00:20:23,760
can see a roll back to

511
00:20:23,760 --> 00:20:25,679
uh to

512
00:20:25,679 --> 00:20:28,240
2016 where initial original

513
00:20:28,240 --> 00:20:31,360
vulnerability was found because in 2021

514
00:20:31,360 --> 00:20:32,840
in asos

515
00:20:32,840 --> 00:20:34,559
devices

516
00:20:34,559 --> 00:20:37,440
in asus devices were the

517
00:20:37,440 --> 00:20:39,520
exactly the

518
00:20:39,520 --> 00:20:41,640
same vulnerabilities that were found in

519
00:20:41,640 --> 00:20:44,400
2016 were found

520
00:20:44,400 --> 00:20:46,080
and

521
00:20:46,080 --> 00:20:47,120
and

522
00:20:47,120 --> 00:20:51,440
report it to vendor so as you can see

523
00:20:51,440 --> 00:20:55,280
five six six years vulnerability leaves

524
00:20:55,280 --> 00:20:58,000
without without any fixes and it

525
00:20:58,000 --> 00:21:00,480
actually lives longer as we

526
00:21:00,480 --> 00:21:03,760
will see a bit later so let's go next

527
00:21:03,760 --> 00:21:06,960
so what is happening in present in

528
00:21:06,960 --> 00:21:09,280
present uh we

529
00:21:09,280 --> 00:21:10,159
uh

530
00:21:10,159 --> 00:21:13,280
recently we saw uh some

531
00:21:13,280 --> 00:21:15,679
some some some big news

532
00:21:15,679 --> 00:21:16,880
from us

533
00:21:16,880 --> 00:21:21,120
we have discovered a pretty

534
00:21:21,120 --> 00:21:23,840
pretty long list of vulnerabilities even

535
00:21:23,840 --> 00:21:25,919
for uefi but

536
00:21:25,919 --> 00:21:28,000
but they

537
00:21:28,000 --> 00:21:30,159
they

538
00:21:30,159 --> 00:21:32,559
they similar similar to applaud problems

539
00:21:32,559 --> 00:21:35,840
that that were the that were presented

540
00:21:35,840 --> 00:21:38,240
in in a few years

541
00:21:38,240 --> 00:21:39,840
past and

542
00:21:39,840 --> 00:21:42,640
we can see that in some cases

543
00:21:42,640 --> 00:21:45,679
industry doesn't learn so the first type

544
00:21:45,679 --> 00:21:47,679
of the vulnerability is the

545
00:21:47,679 --> 00:21:48,720
uh

546
00:21:48,720 --> 00:21:50,720
is the call out in the software semi

547
00:21:50,720 --> 00:21:53,440
handler we we cannot uh talk more much

548
00:21:53,440 --> 00:21:55,440
about details because we have no time

549
00:21:55,440 --> 00:21:56,880
for it all

550
00:21:56,880 --> 00:21:59,120
any all the details we you can find on

551
00:21:59,120 --> 00:22:03,520
our github and on our website so uh so

552
00:22:03,520 --> 00:22:05,280
i'll just

553
00:22:05,280 --> 00:22:07,919
go go from one type to another and just

554
00:22:07,919 --> 00:22:10,320
describe it quickly so the first step is

555
00:22:10,320 --> 00:22:12,640
a call out from the efi

556
00:22:12,640 --> 00:22:15,280
runtime services which is

557
00:22:15,280 --> 00:22:18,320
stored in system memory hence

558
00:22:18,320 --> 00:22:22,799
a callout is possible the this is the

559
00:22:23,200 --> 00:22:25,919
the code from software so from some

560
00:22:25,919 --> 00:22:29,200
software's my handler the and we found

561
00:22:29,200 --> 00:22:32,480
just one uh such vulnerability now on

562
00:22:32,480 --> 00:22:34,480
the next slide

563
00:22:34,480 --> 00:22:37,280
we can see that there

564
00:22:37,280 --> 00:22:41,840
no this is go go to the previous please

565
00:22:41,840 --> 00:22:45,039
previous previous

566
00:22:45,440 --> 00:22:47,679
boot boot services yes

567
00:22:47,679 --> 00:22:49,520
boot services we can

568
00:22:49,520 --> 00:22:51,440
we as we can see

569
00:22:51,440 --> 00:22:54,880
there are more than one vulnerabilities

570
00:22:54,880 --> 00:22:56,480
in in

571
00:22:56,480 --> 00:22:58,880
this type cloud through through yafi

572
00:22:58,880 --> 00:23:01,919
boot services which also is stored

573
00:23:01,919 --> 00:23:04,559
in system memory which is untrusted for

574
00:23:04,559 --> 00:23:06,080
smm

575
00:23:06,080 --> 00:23:08,480
and on the next slide there are a bunch

576
00:23:08,480 --> 00:23:12,320
of uh memory corruptions oh no this is a

577
00:23:12,320 --> 00:23:13,840
they call out

578
00:23:13,840 --> 00:23:14,880
the

579
00:23:14,880 --> 00:23:15,760
non

580
00:23:15,760 --> 00:23:18,480
smm protocol which is located by the

581
00:23:18,480 --> 00:23:21,360
boot services in the boot time and for

582
00:23:21,360 --> 00:23:24,400
an smi handler uses it as

583
00:23:24,400 --> 00:23:27,679
like this without any sanitation and

584
00:23:27,679 --> 00:23:30,559
has a system memory object which

585
00:23:30,559 --> 00:23:31,919
allows the target to hijack the

586
00:23:31,919 --> 00:23:34,640
execution flow like in previous cases

587
00:23:34,640 --> 00:23:37,120
and on the next slide uh

588
00:23:37,120 --> 00:23:39,600
more than one again

589
00:23:39,600 --> 00:23:41,840
memory corruption vulnerabilities

590
00:23:41,840 --> 00:23:44,080
most of them through communication

591
00:23:44,080 --> 00:23:47,200
buffer which is uh also untrusted input

592
00:23:47,200 --> 00:23:50,799
for child software as my handlers status

593
00:23:50,799 --> 00:23:52,159
codes

594
00:23:52,159 --> 00:23:53,440
fixed

595
00:23:53,440 --> 00:23:56,080
bytes poor co-words

596
00:23:56,080 --> 00:23:59,279
div words and other data is written

597
00:23:59,279 --> 00:24:00,400
uh

598
00:24:00,400 --> 00:24:01,840
through through

599
00:24:01,840 --> 00:24:03,760
two pointers nested inside the

600
00:24:03,760 --> 00:24:05,760
communication buffer so

601
00:24:05,760 --> 00:24:07,520
it is not

602
00:24:07,520 --> 00:24:10,480
not a tricky thing to

603
00:24:10,480 --> 00:24:13,279
exploit those issues

604
00:24:13,279 --> 00:24:14,400
and

605
00:24:14,400 --> 00:24:17,039
and we have also another

606
00:24:17,039 --> 00:24:18,480
just one

607
00:24:18,480 --> 00:24:21,120
stack buffer flow vulnerability

608
00:24:21,120 --> 00:24:23,360
which can be executed during boot

609
00:24:23,360 --> 00:24:24,559
and

610
00:24:24,559 --> 00:24:27,679
this is a classical uh insecure handling

611
00:24:27,679 --> 00:24:31,120
of efi variables uh alex will talk uh

612
00:24:31,120 --> 00:24:34,479
just a bit more about that

613
00:24:34,559 --> 00:24:37,039
regarding some hp vulnerabilities he

614
00:24:37,039 --> 00:24:40,080
promised so

615
00:24:40,080 --> 00:24:41,679
we we have

616
00:24:41,679 --> 00:24:43,840
disclosed we we have reported them of

617
00:24:43,840 --> 00:24:45,120
course to

618
00:24:45,120 --> 00:24:48,159
to inside to the vendors and as you can

619
00:24:48,159 --> 00:24:52,320
see a lot of a lot of vendors affected

620
00:24:52,320 --> 00:24:53,440
uh

621
00:24:53,440 --> 00:24:56,159
more than 25 if i remember correctly

622
00:24:56,159 --> 00:24:59,360
millions of devices but

623
00:24:59,360 --> 00:25:02,000
the interest the industry examples life

624
00:25:02,000 --> 00:25:05,360
examples show us that uh in many cases

625
00:25:05,360 --> 00:25:06,320
the

626
00:25:06,320 --> 00:25:10,320
uh the and asynchronous nature of the

627
00:25:10,320 --> 00:25:13,360
supply chain and updates delivery in in

628
00:25:13,360 --> 00:25:16,400
firmware industries show us that uh

629
00:25:16,400 --> 00:25:17,840
probably

630
00:25:17,840 --> 00:25:21,200
um and most likely uh a lot of those

631
00:25:21,200 --> 00:25:23,360
vulnerabilities will be unpatched for a

632
00:25:23,360 --> 00:25:27,200
long time on on endpoint devices

633
00:25:27,200 --> 00:25:28,640
and uh

634
00:25:28,640 --> 00:25:31,840
and they can can be on the state like

635
00:25:31,840 --> 00:25:35,039
that in years as we saw just before and

636
00:25:35,039 --> 00:25:38,400
uh so this this is the time to ask uh

637
00:25:38,400 --> 00:25:41,120
to ask our our

638
00:25:41,120 --> 00:25:43,840
dear friend use brt how how how is how

639
00:25:43,840 --> 00:25:46,600
is it going with uh with this module in

640
00:25:46,600 --> 00:25:50,080
2022 and in 2022 we saw

641
00:25:50,080 --> 00:25:53,360
a device which has uh two

642
00:25:53,360 --> 00:25:56,480
which receives updates in 2021 which was

643
00:25:56,480 --> 00:25:58,159
still receiving updates

644
00:25:58,159 --> 00:26:02,400
in the past year and it in it had it has

645
00:26:02,400 --> 00:26:06,320
for four years uh the vulnerability 20

646
00:26:06,320 --> 00:26:10,240
which was discovered 20 in 2017

647
00:26:10,240 --> 00:26:12,799
it was existing and it was existing as a

648
00:26:12,799 --> 00:26:15,039
zero day on this device and it's still

649
00:26:15,039 --> 00:26:16,480
exploitable and

650
00:26:16,480 --> 00:26:19,360
the most popular mitigation like smm

651
00:26:19,360 --> 00:26:22,080
code check enabled which doesn't allow

652
00:26:22,080 --> 00:26:25,840
execute to execute code outside fsmram

653
00:26:25,840 --> 00:26:28,640
this is a mitigation from callouts

654
00:26:28,640 --> 00:26:31,120
it was it was not enabled on this system

655
00:26:31,120 --> 00:26:33,919
so let's go to the description of this

656
00:26:33,919 --> 00:26:36,559
vulnerability i just remem remember that

657
00:26:36,559 --> 00:26:39,679
there was a call of

658
00:26:39,679 --> 00:26:42,000
which an attacker can call

659
00:26:42,000 --> 00:26:44,640
specify a call to

660
00:26:44,640 --> 00:26:49,039
invoke the usb api function number 14

661
00:26:49,039 --> 00:26:49,919
which

662
00:26:49,919 --> 00:26:53,120
where all parameters are controllable

663
00:26:53,120 --> 00:26:55,120
controllable by an attacker and

664
00:26:55,120 --> 00:26:58,720
extracted in the global usb data

665
00:26:58,720 --> 00:27:00,960
and

666
00:27:01,039 --> 00:27:03,919
an attacker can even specify

667
00:27:03,919 --> 00:27:06,159
arguments from 0

668
00:27:06,159 --> 00:27:07,600
to 7

669
00:27:07,600 --> 00:27:10,320
to 7 arguments to invoke any code

670
00:27:10,320 --> 00:27:11,919
and the proof of concept for this

671
00:27:11,919 --> 00:27:13,679
vulnerability actually was released four

672
00:27:13,679 --> 00:27:16,559
years ago and it was working for us just

673
00:27:16,559 --> 00:27:19,200
like that we just made some some fixes

674
00:27:19,200 --> 00:27:21,600
uh uh to

675
00:27:21,600 --> 00:27:23,840
make some something useful we on the

676
00:27:23,840 --> 00:27:27,200
next slide we can demonstrate uh it

677
00:27:27,200 --> 00:27:30,159
works on this system this is kevin lake

678
00:27:30,159 --> 00:27:33,039
uh still receiving an update but

679
00:27:33,039 --> 00:27:35,760
with with zero days inside

680
00:27:35,760 --> 00:27:36,559
and

681
00:27:36,559 --> 00:27:39,840
uh and uh as you can as you can see uh

682
00:27:39,840 --> 00:27:43,760
there was a dump as a starting of the uh

683
00:27:43,760 --> 00:27:46,000
assam ram dump in the in the beginning

684
00:27:46,000 --> 00:27:49,279
uh which is the signature smm s3 under

685
00:27:49,279 --> 00:27:52,799
line 64. this is the content with which

686
00:27:52,799 --> 00:27:54,080
most likely

687
00:27:54,080 --> 00:27:57,039
in start and the beginning of some ram

688
00:27:57,039 --> 00:27:58,399
is stored

689
00:27:58,399 --> 00:28:00,240
so the future

690
00:28:00,240 --> 00:28:04,080
uh in the future we have uh

691
00:28:04,080 --> 00:28:07,199
we have the next slide

692
00:28:08,159 --> 00:28:09,279
yeah thank you

693
00:28:09,279 --> 00:28:13,200
in the future we have uh again usbrt

694
00:28:13,200 --> 00:28:14,320
with

695
00:28:14,320 --> 00:28:16,480
2020.

696
00:28:16,480 --> 00:28:19,279
version of the vulnerability

697
00:28:19,279 --> 00:28:22,000
discovered in the wild receiving updates

698
00:28:22,000 --> 00:28:25,120
and at this time the the mitigation was

699
00:28:25,120 --> 00:28:26,399
set

700
00:28:26,399 --> 00:28:30,080
and this made us

701
00:28:30,080 --> 00:28:33,039
made us try to to bypass this mitigation

702
00:28:33,039 --> 00:28:35,520
and create and create

703
00:28:35,520 --> 00:28:36,960
and apply the

704
00:28:36,960 --> 00:28:38,480
rope technique

705
00:28:38,480 --> 00:28:42,159
which is known for years but for ufi

706
00:28:42,159 --> 00:28:43,279
it wasn't

707
00:28:43,279 --> 00:28:44,720
uh

708
00:28:44,720 --> 00:28:46,559
at least in public it wasn't presented

709
00:28:46,559 --> 00:28:48,240
before so

710
00:28:48,240 --> 00:28:50,799
uh so let's uh

711
00:28:50,799 --> 00:28:53,520
let's see how it goes so uh just a few

712
00:28:53,520 --> 00:28:55,840
details about the vulnerability to

713
00:28:55,840 --> 00:28:58,960
remember to remind you um

714
00:28:58,960 --> 00:29:01,120
there was the usb api function number

715
00:29:01,120 --> 00:29:04,080
two in the table we can as an attacker

716
00:29:04,080 --> 00:29:08,240
can call it so i u crc

717
00:29:08,240 --> 00:29:11,520
32 is bypassable there was no batch

718
00:29:11,520 --> 00:29:13,279
at this time

719
00:29:13,279 --> 00:29:14,320
for

720
00:29:14,320 --> 00:29:17,520
against the spoofing crc just like that

721
00:29:17,520 --> 00:29:18,960
and

722
00:29:18,960 --> 00:29:21,360
the vulnerability leads to

723
00:29:21,360 --> 00:29:22,240
coal

724
00:29:22,240 --> 00:29:24,640
and arbitrary function

725
00:29:24,640 --> 00:29:25,440
but

726
00:29:25,440 --> 00:29:27,520
in this time we cannot

727
00:29:27,520 --> 00:29:30,480
er we cannot control the parameters and

728
00:29:30,480 --> 00:29:32,799
that's why we have to

729
00:29:32,799 --> 00:29:35,039
uh build to build the code that creates

730
00:29:35,039 --> 00:29:38,320
such parameters using our rope technique

731
00:29:38,320 --> 00:29:39,039
so

732
00:29:39,039 --> 00:29:42,159
let's go uh to the next slide uh

733
00:29:42,159 --> 00:29:44,640
here there is a perfect examples to

734
00:29:44,640 --> 00:29:47,919
build rope techniques in ufi firmware

735
00:29:47,919 --> 00:29:51,520
because these two blocks set jumps set

736
00:29:51,520 --> 00:29:54,159
jump and internal log jump you can find

737
00:29:54,159 --> 00:29:54,960
these

738
00:29:54,960 --> 00:29:56,000
gadgets

739
00:29:56,000 --> 00:30:00,159
in almost in any txt and snmp driver and

740
00:30:00,159 --> 00:30:04,399
that's that allows us to build

741
00:30:04,399 --> 00:30:07,279
to build a stable rope chain for

742
00:30:07,279 --> 00:30:08,720
uh for

743
00:30:08,720 --> 00:30:11,520
just for one driver and using the code

744
00:30:11,520 --> 00:30:14,320
only in this driver and we don't need

745
00:30:14,320 --> 00:30:16,320
anything outside of this driver and

746
00:30:16,320 --> 00:30:19,360
outside it code pages so

747
00:30:19,360 --> 00:30:21,360
uh the first

748
00:30:21,360 --> 00:30:23,279
yes the first

749
00:30:23,279 --> 00:30:24,960
gadget is

750
00:30:24,960 --> 00:30:26,480
used to

751
00:30:26,480 --> 00:30:29,039
leak register values including error sp

752
00:30:29,039 --> 00:30:30,960
it is very important to leak rsp because

753
00:30:30,960 --> 00:30:34,240
we will make in future some calls and we

754
00:30:34,240 --> 00:30:36,159
will have to restore it to not crush

755
00:30:36,159 --> 00:30:40,240
anything and uh to leak it we have to

756
00:30:40,240 --> 00:30:42,799
the the leakage is performed to the

757
00:30:42,799 --> 00:30:44,960
address which is uh

758
00:30:44,960 --> 00:30:47,360
which is very

759
00:30:47,360 --> 00:30:50,399
relevant to uh to what's stored in rcx

760
00:30:50,399 --> 00:30:52,640
in our case there's the extort and a

761
00:30:52,640 --> 00:30:56,799
pointer to a memory uh in to a system

762
00:30:56,799 --> 00:30:59,440
memory some some area in system memory

763
00:30:59,440 --> 00:31:01,840
and in this case it doesn't have to do

764
00:31:01,840 --> 00:31:04,399
anything with that but in case in case

765
00:31:04,399 --> 00:31:07,279
you will uh you will face the situation

766
00:31:07,279 --> 00:31:08,320
where

767
00:31:08,320 --> 00:31:11,039
r6 is pointing to an sm ram and you

768
00:31:11,039 --> 00:31:13,760
cannot access the sm ram to read those

769
00:31:13,760 --> 00:31:15,679
leaked registers

770
00:31:15,679 --> 00:31:17,120
you will have to

771
00:31:17,120 --> 00:31:21,519
use another gadget internal long jump

772
00:31:21,519 --> 00:31:22,799
which will

773
00:31:22,799 --> 00:31:25,200
which will

774
00:31:25,279 --> 00:31:26,559
perform

775
00:31:26,559 --> 00:31:28,799
uh

776
00:31:29,039 --> 00:31:31,039
perform a move instruction

777
00:31:31,039 --> 00:31:34,880
of zero weeks e8 which this address is

778
00:31:34,880 --> 00:31:37,519
available on any almost any system i i

779
00:31:37,519 --> 00:31:39,279
suggest uh

780
00:31:39,279 --> 00:31:41,679
it will change the

781
00:31:41,679 --> 00:31:45,360
ecx register means r6 and

782
00:31:45,360 --> 00:31:48,559
that's how that's how

783
00:31:48,559 --> 00:31:51,279
you will change it and then you are free

784
00:31:51,279 --> 00:31:54,320
to call so about rsp there is a pop

785
00:31:54,320 --> 00:31:57,519
rdx there was a pop rdx instruction in

786
00:31:57,519 --> 00:31:58,960
in those

787
00:31:58,960 --> 00:32:01,760
in the gadget we used and that's that

788
00:32:01,760 --> 00:32:03,840
will at least will allow us to

789
00:32:03,840 --> 00:32:06,480
uh to restore

790
00:32:06,480 --> 00:32:09,200
to restore it to restore the stack and

791
00:32:09,200 --> 00:32:10,559
continue

792
00:32:10,559 --> 00:32:13,039
execution without any crash without

793
00:32:13,039 --> 00:32:14,399
crashing anything

794
00:32:14,399 --> 00:32:17,679
so at the step one we uh

795
00:32:17,679 --> 00:32:20,559
we know how to read the register and we

796
00:32:20,559 --> 00:32:22,320
know how to write the register using

797
00:32:22,320 --> 00:32:24,320
those different gadgets inside set jump

798
00:32:24,320 --> 00:32:26,080
and long jump

799
00:32:26,080 --> 00:32:28,240
and internal launch

800
00:32:28,240 --> 00:32:30,080
function and

801
00:32:30,080 --> 00:32:31,039
to

802
00:32:31,039 --> 00:32:31,919
uh

803
00:32:31,919 --> 00:32:33,200
we need

804
00:32:33,200 --> 00:32:36,159
something useful we we would like to try

805
00:32:36,159 --> 00:32:38,880
to read sm ram again like

806
00:32:38,880 --> 00:32:41,919
once again this this demonstration and

807
00:32:41,919 --> 00:32:43,919
uh that's why we decided to use the

808
00:32:43,919 --> 00:32:46,640
copenham function but we have to

809
00:32:46,640 --> 00:32:47,840
specify

810
00:32:47,840 --> 00:32:49,600
its parameters its

811
00:32:49,600 --> 00:32:52,399
size source destination and size which

812
00:32:52,399 --> 00:32:55,440
is r6 rdx and r8

813
00:32:55,440 --> 00:32:57,760
and that's why we have to find the

814
00:32:57,760 --> 00:33:00,480
gadgets in this driver we found it using

815
00:33:00,480 --> 00:33:02,480
ropper uh tool

816
00:33:02,480 --> 00:33:05,279
and the this is this is just specifying

817
00:33:05,279 --> 00:33:09,120
uh r8 and rdx and r6

818
00:33:09,120 --> 00:33:10,559
registers

819
00:33:10,559 --> 00:33:13,440
and those these gadgets are

820
00:33:13,440 --> 00:33:17,519
widely used in firmware in dxe in smm

821
00:33:17,519 --> 00:33:19,360
because these

822
00:33:19,360 --> 00:33:21,360
these

823
00:33:21,360 --> 00:33:24,000
these code patterns are used to work

824
00:33:24,000 --> 00:33:27,840
with efi protocols and this code is

825
00:33:27,840 --> 00:33:29,200
is a

826
00:33:29,200 --> 00:33:32,080
pretty spread form for those for those

827
00:33:32,080 --> 00:33:34,720
type of drivers and so this at the step

828
00:33:34,720 --> 00:33:37,519
one we

829
00:33:37,519 --> 00:33:39,600
we are specifying

830
00:33:39,600 --> 00:33:41,279
uh in the first line of code we are

831
00:33:41,279 --> 00:33:44,559
specifying our eight then we specifying

832
00:33:44,559 --> 00:33:47,519
we specifying the address of the gadget

833
00:33:47,519 --> 00:33:51,440
that will uh create our it value for us

834
00:33:51,440 --> 00:33:52,559
correctly

835
00:33:52,559 --> 00:33:55,679
and then we specify rdx and earthquakes

836
00:33:55,679 --> 00:33:57,760
in this in the next gadget and in the

837
00:33:57,760 --> 00:33:59,440
next gadget we are performing internal

838
00:33:59,440 --> 00:34:02,799
long jump to restore all

839
00:34:02,799 --> 00:34:07,279
values of the registers and set uh rsp

840
00:34:07,279 --> 00:34:11,040
to before because we made some calls and

841
00:34:11,040 --> 00:34:12,960
we that's why we have your story speed

842
00:34:12,960 --> 00:34:15,679
to its previous condition to not for not

843
00:34:15,679 --> 00:34:18,480
questioning and then we are performing

844
00:34:18,480 --> 00:34:21,040
the third gadget will perform us

845
00:34:21,040 --> 00:34:23,199
the jump instruction to cope with them

846
00:34:23,199 --> 00:34:24,480
and

847
00:34:24,480 --> 00:34:26,399
it will go smoothly

848
00:34:26,399 --> 00:34:27,359
next

849
00:34:27,359 --> 00:34:28,480
slide

850
00:34:28,480 --> 00:34:29,359
so

851
00:34:29,359 --> 00:34:32,159
this step to exploitation

852
00:34:32,159 --> 00:34:34,960
this is a part of the proof concept for

853
00:34:34,960 --> 00:34:37,359
it i think we'll we are going going to

854
00:34:37,359 --> 00:34:38,560
publish it

855
00:34:38,560 --> 00:34:40,560
uh so

856
00:34:40,560 --> 00:34:42,239
uh we are

857
00:34:42,239 --> 00:34:44,159
specifying the data in the controlled

858
00:34:44,159 --> 00:34:48,800
memory uh controlled by and

859
00:34:48,800 --> 00:34:51,199
which will be pointed by rcx then we are

860
00:34:51,199 --> 00:34:54,320
specifying the usb data usb global data

861
00:34:54,320 --> 00:34:56,800
to actually exploit the vulnerability to

862
00:34:56,800 --> 00:34:59,040
trigger it and then we are triggering

863
00:34:59,040 --> 00:35:01,680
the software smi handler and as a result

864
00:35:01,680 --> 00:35:02,880
we

865
00:35:02,880 --> 00:35:03,920
through

866
00:35:03,920 --> 00:35:06,800
with with our copy memory routine are

867
00:35:06,800 --> 00:35:10,240
extracting one byte from smr

868
00:35:10,240 --> 00:35:12,720
and and demonstration let's see how it

869
00:35:12,720 --> 00:35:13,839
goes

870
00:35:13,839 --> 00:35:18,160
roping the smm so as you can see in this

871
00:35:18,160 --> 00:35:20,720
in this demonstration the first

872
00:35:20,720 --> 00:35:22,640
lines are the

873
00:35:22,640 --> 00:35:25,200
register values extracted using those

874
00:35:25,200 --> 00:35:28,640
gadgets and the second is the sm rom

875
00:35:28,640 --> 00:35:31,599
dump and as you can see again

876
00:35:31,599 --> 00:35:35,760
the signature smm s3 underline 64 is at

877
00:35:35,760 --> 00:35:36,880
the beginning

878
00:35:36,880 --> 00:35:39,920
this proves us that it is a smron

879
00:35:39,920 --> 00:35:42,400
contents

880
00:35:43,200 --> 00:35:47,598
the mic is yours alex thank you

881
00:35:49,920 --> 00:35:53,280
yeah so uh actually alex thanks a lot i

882
00:35:53,280 --> 00:35:55,359
think uh that's been pretty interesting

883
00:35:55,359 --> 00:35:58,960
demonstration about uh rop exploit into

884
00:35:58,960 --> 00:36:01,359
smm and i would say on public it's been

885
00:36:01,359 --> 00:36:04,320
not available any sort of uh

886
00:36:04,320 --> 00:36:07,680
examples about how we can actually

887
00:36:07,680 --> 00:36:12,240
create a full chain of rop exploit to um

888
00:36:12,240 --> 00:36:14,000
to his intuition

889
00:36:14,000 --> 00:36:14,920
and uh

890
00:36:14,920 --> 00:36:16,560
[Music]

891
00:36:16,560 --> 00:36:19,599
bad news for uh mitigation developers

892
00:36:19,599 --> 00:36:21,280
it's actually bypasses mum check

893
00:36:21,280 --> 00:36:24,960
completely and to be honest it is very

894
00:36:24,960 --> 00:36:28,000
hard to mitigate such of the problem but

895
00:36:28,000 --> 00:36:30,960
i think uh a bit later on this fight

896
00:36:30,960 --> 00:36:33,119
will be covered some new topics about

897
00:36:33,119 --> 00:36:34,960
the mitigations and of course it is a

898
00:36:34,960 --> 00:36:38,079
lot of things moving forward in terms of

899
00:36:38,079 --> 00:36:41,599
defense but let's focus on uh some other

900
00:36:41,599 --> 00:36:44,000
vulnerabilities we want to discuss today

901
00:36:44,000 --> 00:36:46,640
and um in our representation with uh

902
00:36:46,640 --> 00:36:49,200
alex tyroshkin and adam zabrowski on

903
00:36:49,200 --> 00:36:52,400
black hat us in vegas last year we've

904
00:36:52,400 --> 00:36:55,760
been talking a lot about uh also misuse

905
00:36:55,760 --> 00:36:58,240
of the get variables and actually how

906
00:36:58,240 --> 00:37:00,079
common it is and

907
00:37:00,079 --> 00:37:01,200
still

908
00:37:01,200 --> 00:37:04,400
very broadly available in a

909
00:37:04,400 --> 00:37:07,119
x86 ecosystem especially on servers

910
00:37:07,119 --> 00:37:08,560
which is pretty scary

911
00:37:08,560 --> 00:37:09,760
so

912
00:37:09,760 --> 00:37:13,359
let's actually talk to uh like uh uh how

913
00:37:13,359 --> 00:37:14,960
this will represent this memory

914
00:37:14,960 --> 00:37:16,160
corruption vulnerabilities can be

915
00:37:16,160 --> 00:37:18,800
exploited and

916
00:37:18,800 --> 00:37:21,920
so first of all uh we developed uh the

917
00:37:21,920 --> 00:37:24,640
tool called efi explorer it's a ida pro

918
00:37:24,640 --> 00:37:27,920
plugin which helps to reconstruct uh ufi

919
00:37:27,920 --> 00:37:31,200
specific semantics and types and

920
00:37:31,200 --> 00:37:33,760
actually smash simplifier

921
00:37:33,760 --> 00:37:36,640
simplify a lot the reverse engineer life

922
00:37:36,640 --> 00:37:38,480
for actually

923
00:37:38,480 --> 00:37:40,160
digging into

924
00:37:40,160 --> 00:37:43,280
ufi firmwares but also we developed some

925
00:37:43,280 --> 00:37:45,760
generic checks for such of the problems

926
00:37:45,760 --> 00:37:47,920
like misuse of the get variables

927
00:37:47,920 --> 00:37:50,720
unfortunately we mentioned this multiple

928
00:37:50,720 --> 00:37:52,240
times we share these thoughts with the

929
00:37:52,240 --> 00:37:54,240
developers but i think they still not

930
00:37:54,240 --> 00:37:56,320
use it uh such of the plugin for

931
00:37:56,320 --> 00:37:57,920
basically detecting the problems in

932
00:37:57,920 --> 00:37:59,520
their firmware so of course it's just

933
00:37:59,520 --> 00:38:01,839
simple heuristic it can

934
00:38:01,839 --> 00:38:03,760
create a lot of false positives but

935
00:38:03,760 --> 00:38:04,800
basically

936
00:38:04,800 --> 00:38:06,880
visually you can recognize if it is real

937
00:38:06,880 --> 00:38:09,760
issue or not let's look on the left side

938
00:38:09,760 --> 00:38:11,359
of the pseudocode

939
00:38:11,359 --> 00:38:14,320
window basically it is exactly the

940
00:38:14,320 --> 00:38:16,160
classical problem where we have an

941
00:38:16,160 --> 00:38:19,119
initialized size ones to usage of get

942
00:38:19,119 --> 00:38:21,359
variables when the size gets reduced and

943
00:38:21,359 --> 00:38:23,839
actually lead to a classical memory

944
00:38:23,839 --> 00:38:26,960
corruption problem on the stack

945
00:38:26,960 --> 00:38:27,920
and

946
00:38:27,920 --> 00:38:30,480
also actually

947
00:38:30,480 --> 00:38:33,359
why that happens right so because the

948
00:38:33,359 --> 00:38:35,839
primary display value it is in the ram

949
00:38:35,839 --> 00:38:38,720
value so controlled by the attacker and

950
00:38:38,720 --> 00:38:40,400
in such cases you also can rewrite

951
00:38:40,400 --> 00:38:44,480
return address uh easily so basically uh

952
00:38:44,480 --> 00:38:47,200
we use uh qmo to

953
00:38:47,200 --> 00:38:49,440
navigate this driver and it's another

954
00:38:49,440 --> 00:38:51,760
bad news for the firmware developers

955
00:38:51,760 --> 00:38:53,200
because you do not

956
00:38:53,200 --> 00:38:55,839
always need actually target system

957
00:38:55,839 --> 00:38:58,240
available to develop

958
00:38:58,240 --> 00:39:01,760
some poc for that because in many cases

959
00:39:01,760 --> 00:39:04,240
uh if you have the driver which doesn't

960
00:39:04,240 --> 00:39:06,640
have any hardware specific features

961
00:39:06,640 --> 00:39:09,119
inside you can just emulate with qmo

962
00:39:09,119 --> 00:39:12,079
some things you can stop at and actually

963
00:39:12,079 --> 00:39:14,800
lead to a particular functionality to

964
00:39:14,800 --> 00:39:16,400
execute the code which you wanted to

965
00:39:16,400 --> 00:39:19,359
test it so basically

966
00:39:19,359 --> 00:39:22,079
i would say in many cases

967
00:39:22,079 --> 00:39:24,640
you can move from

968
00:39:24,640 --> 00:39:26,640
an aesthetic analysis to something

969
00:39:26,640 --> 00:39:29,119
hybrid approach where you can use

970
00:39:29,119 --> 00:39:31,920
pieces of dynamic analysis and static

971
00:39:31,920 --> 00:39:34,160
analysis together and actually it's very

972
00:39:34,160 --> 00:39:35,119
powerful

973
00:39:35,119 --> 00:39:38,079
let's look uh how actually exploit will

974
00:39:38,079 --> 00:39:40,320
be looks like to be honest it's just a

975
00:39:40,320 --> 00:39:42,640
classical stack overflow no mitigations

976
00:39:42,640 --> 00:39:44,720
it's actually very straightforward right

977
00:39:44,720 --> 00:39:47,599
so we still have shell code and just uh

978
00:39:47,599 --> 00:39:50,640
actually popping these shells inside the

979
00:39:50,640 --> 00:39:53,520
dixie driver and

980
00:39:53,520 --> 00:39:56,640
thing is this system broadly spread into

981
00:39:56,640 --> 00:39:59,599
the data centers uh it and

982
00:39:59,599 --> 00:40:01,599
this is pretty scary vulnerability i

983
00:40:01,599 --> 00:40:04,079
would say it is unprivileged driver it's

984
00:40:04,079 --> 00:40:06,319
not a cement driver right it is a dxe

985
00:40:06,319 --> 00:40:08,800
driver but such of the dixie driver can

986
00:40:08,800 --> 00:40:12,800
lead a full compromise of

987
00:40:12,800 --> 00:40:15,599
actually secure boot because basically

988
00:40:15,599 --> 00:40:17,599
you are

989
00:40:17,599 --> 00:40:20,640
having the driver which is vulnerable

990
00:40:20,640 --> 00:40:23,280
you can have the similar effect like a

991
00:40:23,280 --> 00:40:25,440
boot hole vulnerability basically by

992
00:40:25,440 --> 00:40:28,240
passing boot of chain

993
00:40:28,240 --> 00:40:31,359
trust when you executing the code uh

994
00:40:31,359 --> 00:40:34,079
inside the dixie phase right uh extra

995
00:40:34,079 --> 00:40:36,800
code which will be actual shell code

996
00:40:36,800 --> 00:40:40,720
yeah so it is a demonstration in qmo

997
00:40:40,720 --> 00:40:44,319
right but also we have another one on hp

998
00:40:44,319 --> 00:40:47,119
system and it's exactly connects to our

999
00:40:47,119 --> 00:40:50,079
disclosure today

1000
00:40:51,520 --> 00:40:53,839
and let's look on this one

1001
00:40:53,839 --> 00:40:57,200
uh same problem right so data size only

1002
00:40:57,200 --> 00:41:00,160
once initialized we have actually some

1003
00:41:00,160 --> 00:41:02,960
sort of sanitization but it is not

1004
00:41:02,960 --> 00:41:05,760
creating a problem to pass it and

1005
00:41:05,760 --> 00:41:06,960
also

1006
00:41:06,960 --> 00:41:09,040
data size didn't change after the first

1007
00:41:09,040 --> 00:41:11,599
get variable call and it leads to

1008
00:41:11,599 --> 00:41:13,839
classical stack overflow memory

1009
00:41:13,839 --> 00:41:15,280
corruption

1010
00:41:15,280 --> 00:41:19,520
so again detected by fi explorer so

1011
00:41:19,520 --> 00:41:23,040
developers use efi explorer

1012
00:41:23,040 --> 00:41:24,640
and

1013
00:41:24,640 --> 00:41:28,400
here uh just this simple demonstration

1014
00:41:28,400 --> 00:41:29,599
same thing

1015
00:41:29,599 --> 00:41:32,319
running the driver then exposing

1016
00:41:32,319 --> 00:41:36,000
some variable which is actually uh

1017
00:41:36,000 --> 00:41:40,160
will be corrupt the memory after so

1018
00:41:40,160 --> 00:41:43,440
yeah greetings from efi explorer team

1019
00:41:43,440 --> 00:41:45,040
looks cool

1020
00:41:45,040 --> 00:41:46,079
all right

1021
00:41:46,079 --> 00:41:48,640
but uh what's the next

1022
00:41:48,640 --> 00:41:52,160
how actually this will be moving um to

1023
00:41:52,160 --> 00:41:55,760
some of the more uh in-depth mitigation

1024
00:41:55,760 --> 00:41:57,680
right so we're talking a lot about the

1025
00:41:57,680 --> 00:41:59,839
attack surface reduction we're talking a

1026
00:41:59,839 --> 00:42:02,640
lot about many things but compare

1027
00:42:02,640 --> 00:42:05,359
complexity of efi ecosystem and

1028
00:42:05,359 --> 00:42:07,839
complexity of the firmware itself tell

1029
00:42:07,839 --> 00:42:11,200
us a lot so that's actually such of the

1030
00:42:11,200 --> 00:42:13,040
problems will be not changed the

1031
00:42:13,040 --> 00:42:14,960
vulnerabilities we discussed on this

1032
00:42:14,960 --> 00:42:17,040
presentation today with you guys it's

1033
00:42:17,040 --> 00:42:19,119
not a new problems this classes of

1034
00:42:19,119 --> 00:42:21,520
vulnerability is known for years

1035
00:42:21,520 --> 00:42:22,400
and

1036
00:42:22,400 --> 00:42:24,240
also i would say why it's still

1037
00:42:24,240 --> 00:42:26,960
happening in many cases it's not enough

1038
00:42:26,960 --> 00:42:28,960
knowledge base to actually learn how

1039
00:42:28,960 --> 00:42:31,280
these problems looks like right how many

1040
00:42:31,280 --> 00:42:34,240
you you have exploits available like poc

1041
00:42:34,240 --> 00:42:36,319
exploits available on the public two

1042
00:42:36,319 --> 00:42:38,720
three five but basically it's not enough

1043
00:42:38,720 --> 00:42:40,960
to learn right so if you look how many

1044
00:42:40,960 --> 00:42:42,720
exploits you need to actually test your

1045
00:42:42,720 --> 00:42:46,079
mitigations on the browser so much more

1046
00:42:46,079 --> 00:42:47,839
right so you need a fuzziers and a lot

1047
00:42:47,839 --> 00:42:49,920
of other things but how you can develop

1048
00:42:49,920 --> 00:42:51,839
the good fuzzer if your development team

1049
00:42:51,839 --> 00:42:53,760
if you not understand how the attackers

1050
00:42:53,760 --> 00:42:55,839
will be used such of the practices to

1051
00:42:55,839 --> 00:42:58,640
attack the systems right so basically

1052
00:42:58,640 --> 00:43:00,640
it's one of the reasons why we actually

1053
00:43:00,640 --> 00:43:03,760
always try to release very detailed uh

1054
00:43:03,760 --> 00:43:05,839
advisories because first of all we want

1055
00:43:05,839 --> 00:43:07,440
to make a commitment to search of the

1056
00:43:07,440 --> 00:43:09,200
knowledge base to transfer this

1057
00:43:09,200 --> 00:43:10,960
knowledge to the development teams and

1058
00:43:10,960 --> 00:43:12,960
product teams to learn from such of the

1059
00:43:12,960 --> 00:43:15,440
mistakes because it's enough how many

1060
00:43:15,440 --> 00:43:17,200
years we need to repeat the similar

1061
00:43:17,200 --> 00:43:18,240
problems

1062
00:43:18,240 --> 00:43:21,680
10 20 or more i think we need to move

1063
00:43:21,680 --> 00:43:24,160
something else

1064
00:43:24,160 --> 00:43:25,200
and

1065
00:43:25,200 --> 00:43:26,560
also

1066
00:43:26,560 --> 00:43:29,920
a lot of things uh happening in uh

1067
00:43:29,920 --> 00:43:32,000
actually reference code right so in this

1068
00:43:32,000 --> 00:43:34,560
slides talking about some sort of like

1069
00:43:34,560 --> 00:43:35,599
uh

1070
00:43:35,599 --> 00:43:40,000
complexity of uh ism itself right so and

1071
00:43:40,000 --> 00:43:43,119
in many cases like that hiker can

1072
00:43:43,119 --> 00:43:47,119
corrupt something and then expose

1073
00:43:47,119 --> 00:43:49,040
the problem and it's exactly about the

1074
00:43:49,040 --> 00:43:51,119
smm ready to lock

1075
00:43:51,119 --> 00:43:53,440
so but

1076
00:43:53,440 --> 00:43:56,240
actually uh a lot of new mitigations

1077
00:43:56,240 --> 00:44:00,400
with fancy words like htm p palm uh smm

1078
00:44:00,400 --> 00:44:03,440
ct intel hardware shield came up

1079
00:44:03,440 --> 00:44:06,079
recently right and it sounds like it's

1080
00:44:06,079 --> 00:44:08,640
game over right so basically everything

1081
00:44:08,640 --> 00:44:11,440
is mitigated protected done

1082
00:44:11,440 --> 00:44:12,560
but

1083
00:44:12,560 --> 00:44:15,599
party is not over

1084
00:44:15,760 --> 00:44:18,800
because it's complexity of the ecosystem

1085
00:44:18,800 --> 00:44:21,680
of the ecosystem itself leads to many

1086
00:44:21,680 --> 00:44:24,160
problems and we will talk about that

1087
00:44:24,160 --> 00:44:27,119
so uh first of all like what is intel

1088
00:44:27,119 --> 00:44:29,760
p-pump stand for it is some sort of like

1089
00:44:29,760 --> 00:44:32,400
a memory isolation based on

1090
00:44:32,400 --> 00:44:35,280
virtualization technologies called stm2

1091
00:44:35,280 --> 00:44:38,480
to isolate each smm driver

1092
00:44:38,480 --> 00:44:40,240
to separate

1093
00:44:40,240 --> 00:44:42,960
execution domain and

1094
00:44:42,960 --> 00:44:47,040
it's of course create some sort of

1095
00:44:47,040 --> 00:44:49,440
complexity for development because this

1096
00:44:49,440 --> 00:44:52,079
should be done by development team right

1097
00:44:52,079 --> 00:44:54,480
and also

1098
00:44:54,480 --> 00:44:57,359
uh it is a lot of policies need to be

1099
00:44:57,359 --> 00:45:00,000
applied right so and basically we have

1100
00:45:00,000 --> 00:45:03,040
like a first generation of cstm when

1101
00:45:03,040 --> 00:45:05,280
it's been just smm

1102
00:45:05,280 --> 00:45:07,359
under the hypervisor now it's

1103
00:45:07,359 --> 00:45:09,359
transferred to different phase when we

1104
00:45:09,359 --> 00:45:10,720
have actually

1105
00:45:10,720 --> 00:45:14,160
multiple layers of memory isolation like

1106
00:45:14,160 --> 00:45:16,640
now we have a ring synthesis right so it

1107
00:45:16,640 --> 00:45:18,720
is ring tree and ring zero

1108
00:45:18,720 --> 00:45:21,839
how it will be different

1109
00:45:22,480 --> 00:45:25,040
from exploitation standpoint

1110
00:45:25,040 --> 00:45:27,839
um so basically yes because it will be

1111
00:45:27,839 --> 00:45:30,560
create complexity raising the bar but

1112
00:45:30,560 --> 00:45:32,880
the question is how broadly it will be

1113
00:45:32,880 --> 00:45:35,520
adopted and to be honest at scale we

1114
00:45:35,520 --> 00:45:38,640
don't see much systems actually uh adopt

1115
00:45:38,640 --> 00:45:41,040
such of the mitigations and i really

1116
00:45:41,040 --> 00:45:44,240
believe because it's also create few

1117
00:45:44,240 --> 00:45:46,880
side effects so it can affect the

1118
00:45:46,880 --> 00:45:50,160
performance and uh actually performance

1119
00:45:50,160 --> 00:45:52,480
it's not a friend of security because

1120
00:45:52,480 --> 00:45:54,640
think about the most of the device

1121
00:45:54,640 --> 00:45:58,400
developers they care how fast your

1122
00:45:58,400 --> 00:46:00,640
screen will blink after you open the lid

1123
00:46:00,640 --> 00:46:03,359
on the laptop because it's visible for

1124
00:46:03,359 --> 00:46:05,680
for users and they will be going by

1125
00:46:05,680 --> 00:46:07,839
another vendor because it's boots faster

1126
00:46:07,839 --> 00:46:10,800
right so basically i'm not a true

1127
00:46:10,800 --> 00:46:13,200
believer this mitigations will be

1128
00:46:13,200 --> 00:46:15,920
available for each smm driver it can be

1129
00:46:15,920 --> 00:46:19,359
for some most critical ones or not but

1130
00:46:19,359 --> 00:46:21,680
if you even notice await all of them

1131
00:46:21,680 --> 00:46:24,480
that's already a big hole in in this

1132
00:46:24,480 --> 00:46:27,200
mitigation another thing

1133
00:46:27,200 --> 00:46:30,078
it is a

1134
00:46:30,640 --> 00:46:33,200
complexity of such of the feature itself

1135
00:46:33,200 --> 00:46:36,560
right so we have a actual policies apply

1136
00:46:36,560 --> 00:46:40,240
for each uh driver how it will be loaded

1137
00:46:40,240 --> 00:46:42,720
what kind of boundary synthesis memory

1138
00:46:42,720 --> 00:46:45,920
will be created and of course

1139
00:46:45,920 --> 00:46:49,119
it can lead some memory corruption bugs

1140
00:46:49,119 --> 00:46:51,200
right so because

1141
00:46:51,200 --> 00:46:54,000
too many things can be go wrong right

1142
00:46:54,000 --> 00:46:56,720
and if you read something from flash

1143
00:46:56,720 --> 00:46:59,839
storage where policies exist

1144
00:46:59,839 --> 00:47:02,000
it's basically can be controlled by the

1145
00:47:02,000 --> 00:47:03,359
attacker right

1146
00:47:03,359 --> 00:47:04,160
so

1147
00:47:04,160 --> 00:47:07,119
yeah it's some spoiler so research

1148
00:47:07,119 --> 00:47:11,319
ongoing stay tuned

1149
00:47:11,359 --> 00:47:13,599
too fast and

1150
00:47:13,599 --> 00:47:15,760
of course complexity of ecosystem and a

1151
00:47:15,760 --> 00:47:18,480
lot of other things plays against of

1152
00:47:18,480 --> 00:47:22,000
security and uh as we can see

1153
00:47:22,000 --> 00:47:26,319
uh even this thing like a usbrt it's not

1154
00:47:26,319 --> 00:47:29,280
actually that complex but it's still

1155
00:47:29,280 --> 00:47:31,920
vulnerable and still exposing the bugs

1156
00:47:31,920 --> 00:47:34,640
to the ecosystem and the

1157
00:47:34,640 --> 00:47:35,839
problem is

1158
00:47:35,839 --> 00:47:38,079
of course like different generation of

1159
00:47:38,079 --> 00:47:41,040
platforms different generation of

1160
00:47:41,040 --> 00:47:43,599
cpus and firmware frameworks and other

1161
00:47:43,599 --> 00:47:45,680
things and this create

1162
00:47:45,680 --> 00:47:46,559
help

1163
00:47:46,559 --> 00:47:48,400
complexity

1164
00:47:48,400 --> 00:47:50,880
a problem and

1165
00:47:50,880 --> 00:47:53,920
i would say it's hard to fix it because

1166
00:47:53,920 --> 00:47:56,480
different uh lines even from the same

1167
00:47:56,480 --> 00:47:59,680
vendor have a different update cycles

1168
00:47:59,680 --> 00:48:00,720
and

1169
00:48:00,720 --> 00:48:04,079
also priorities right so let's say first

1170
00:48:04,079 --> 00:48:06,160
year probably they care about the second

1171
00:48:06,160 --> 00:48:08,559
year less care about that and third year

1172
00:48:08,559 --> 00:48:11,040
they almost forget and they deliver only

1173
00:48:11,040 --> 00:48:13,119
the critical updates a lot of vendors do

1174
00:48:13,119 --> 00:48:15,839
that and unfortunately that happens i

1175
00:48:15,839 --> 00:48:18,319
would say uh most of the enterprise

1176
00:48:18,319 --> 00:48:20,319
vendors is actually doing better than

1177
00:48:20,319 --> 00:48:22,960
just two years support cycles but still

1178
00:48:22,960 --> 00:48:25,680
a lot of vendors

1179
00:48:25,680 --> 00:48:28,160
just shifting their priorities for such

1180
00:48:28,160 --> 00:48:31,119
of the platform and we really need to

1181
00:48:31,119 --> 00:48:33,440
just clean up the ecosystem from such of

1182
00:48:33,440 --> 00:48:36,720
the legacy parks and actually create

1183
00:48:36,720 --> 00:48:38,880
more effective mitigations that's what

1184
00:48:38,880 --> 00:48:40,640
the industry need and it's exactly what

1185
00:48:40,640 --> 00:48:42,960
this research talking about how many

1186
00:48:42,960 --> 00:48:45,599
years will be exposing cloud

1187
00:48:45,599 --> 00:48:47,200
vulnerabilities

1188
00:48:47,200 --> 00:48:50,240
it's been in early 2000s it's been

1189
00:48:50,240 --> 00:48:53,200
happening right now we need to move on

1190
00:48:53,200 --> 00:48:54,640
and

1191
00:48:54,640 --> 00:48:57,599
it's been our talk exactly about such of

1192
00:48:57,599 --> 00:48:59,680
the topics and we want to help the

1193
00:48:59,680 --> 00:49:01,760
industry to get fixed thank you very

1194
00:49:01,760 --> 00:49:05,520
much and happy to answer your questions

1195
00:49:05,520 --> 00:49:08,680
thank you

