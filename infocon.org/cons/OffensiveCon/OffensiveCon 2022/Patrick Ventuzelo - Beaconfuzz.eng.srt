1
00:00:02,960 --> 00:00:04,480
thank you everyone

2
00:00:04,480 --> 00:00:06,560
sorry by advance for the people that was

3
00:00:06,560 --> 00:00:08,400
looking for the ios

4
00:00:08,400 --> 00:00:11,120
ios like talk i mean i will be your

5
00:00:11,120 --> 00:00:12,880
replacement but i hope you will learn a

6
00:00:12,880 --> 00:00:14,880
lot of stuff basically the really good

7
00:00:14,880 --> 00:00:17,680
part is that my i think my talk will

8
00:00:17,680 --> 00:00:20,400
just follow what basically mark told you

9
00:00:20,400 --> 00:00:22,720
uh during the keynote like about the

10
00:00:22,720 --> 00:00:25,039
step of being like a researcher and

11
00:00:25,039 --> 00:00:26,960
testing stuff and so on because that's

12
00:00:26,960 --> 00:00:29,439
basically what i've done on the last

13
00:00:29,439 --> 00:00:32,320
past two years with this project was

14
00:00:32,320 --> 00:00:34,079
basically i was

15
00:00:34,079 --> 00:00:36,640
kind of a bit new about like the

16
00:00:36,640 --> 00:00:38,800
blockchain node and especially at rom

17
00:00:38,800 --> 00:00:40,800
and what was

18
00:00:40,800 --> 00:00:43,520
supposedly like the evolution that will

19
00:00:43,520 --> 00:00:44,399
happen

20
00:00:44,399 --> 00:00:48,160
and um you will see that it's basically

21
00:00:48,160 --> 00:00:51,440
a told focus on the fuzzing journey and

22
00:00:51,440 --> 00:00:54,160
the different step i made to reach a

23
00:00:54,160 --> 00:00:55,360
certain goal that was finding

24
00:00:55,360 --> 00:00:57,600
vulnerability and so on i will not talk

25
00:00:57,600 --> 00:00:59,039
too much about the vulnerabilities

26
00:00:59,039 --> 00:01:00,320
themselves

27
00:01:00,320 --> 00:01:01,600
because i mean

28
00:01:01,600 --> 00:01:03,199
i suppose not a lot of you are on the

29
00:01:03,199 --> 00:01:05,040
blockchain security

30
00:01:05,040 --> 00:01:07,920
ecosystem so it will not make sense but

31
00:01:07,920 --> 00:01:10,240
at least you you will be able to reuse

32
00:01:10,240 --> 00:01:11,760
like i hope

33
00:01:11,760 --> 00:01:12,960
a bunch of

34
00:01:12,960 --> 00:01:15,040
like tips and tricks regarding dealing

35
00:01:15,040 --> 00:01:17,920
with huge projects and especially with

36
00:01:17,920 --> 00:01:19,040
projects

37
00:01:19,040 --> 00:01:21,200
and

38
00:01:21,360 --> 00:01:23,680
that are not really common and

39
00:01:23,680 --> 00:01:24,799
dealing with

40
00:01:24,799 --> 00:01:26,880
a bunch of characteristics that are

41
00:01:26,880 --> 00:01:28,080
really special

42
00:01:28,080 --> 00:01:30,640
so um just to tell you a bit more about

43
00:01:30,640 --> 00:01:33,280
me i'm patrick i'm running the fuzzing

44
00:01:33,280 --> 00:01:35,280
labs company where basically i'm doing

45
00:01:35,280 --> 00:01:37,759
training about fuzzing and on a bunch of

46
00:01:37,759 --> 00:01:41,280
stuff mainly lacrosse go web assembly

47
00:01:41,280 --> 00:01:42,880
browser and so on and a lot of

48
00:01:42,880 --> 00:01:44,720
blockchain stuff of course

49
00:01:44,720 --> 00:01:47,200
i'm french you can hear that of course

50
00:01:47,200 --> 00:01:49,759
and i'm also running the fuzzing labs

51
00:01:49,759 --> 00:01:51,520
channel so where basically i'm doing

52
00:01:51,520 --> 00:01:54,399
like fuzzing every week and there is one

53
00:01:54,399 --> 00:01:56,719
video per week

54
00:01:56,719 --> 00:01:58,960
so first of all i will need to tell you

55
00:01:58,960 --> 00:02:01,840
a bit more about what is a term 2.0

56
00:02:01,840 --> 00:02:02,560
and

57
00:02:02,560 --> 00:02:05,119
also what is a term for the

58
00:02:05,119 --> 00:02:07,600
ones that are not aware of course so

59
00:02:07,600 --> 00:02:09,919
basically at army i consider it's like

60
00:02:09,919 --> 00:02:12,640
one of the first blockchains that i was

61
00:02:12,640 --> 00:02:14,640
i think it was even the first one to run

62
00:02:14,640 --> 00:02:16,959
smart contracts so of course really

63
00:02:16,959 --> 00:02:19,599
famous blockchain with the crypto

64
00:02:19,599 --> 00:02:22,720
pump and and so on it's basically in

65
00:02:22,720 --> 00:02:24,400
terms of

66
00:02:24,400 --> 00:02:27,599
if if i need to synthesize uh is like

67
00:02:27,599 --> 00:02:29,599
what is under the hood it just appeared

68
00:02:29,599 --> 00:02:31,680
to be a network where basically you have

69
00:02:31,680 --> 00:02:34,560
multiple nodes that will discuss to

70
00:02:34,560 --> 00:02:37,760
each other the way they will discuss so

71
00:02:37,760 --> 00:02:39,840
it's using p2p

72
00:02:39,840 --> 00:02:43,120
stuff and um they will basically send

73
00:02:43,120 --> 00:02:45,840
block and transaction and it's basically

74
00:02:45,840 --> 00:02:48,319
they are sharing the database together

75
00:02:48,319 --> 00:02:50,879
and yeah that that's basically pretty

76
00:02:50,879 --> 00:02:53,440
much all so that's uh that's

77
00:02:53,440 --> 00:02:54,800
mostly one

78
00:02:54,800 --> 00:02:58,080
so that's the that's the idea so

79
00:02:58,080 --> 00:03:00,000
the first thing we can say is of course

80
00:03:00,000 --> 00:03:01,840
there is a lot of stuff to do with the

81
00:03:01,840 --> 00:03:04,800
networking stack especially if you are

82
00:03:04,800 --> 00:03:06,720
thinking that all those nodes will

83
00:03:06,720 --> 00:03:09,599
basically communicate to each other so

84
00:03:09,599 --> 00:03:10,879
the main

85
00:03:10,879 --> 00:03:13,360
kind of attack we can have in such case

86
00:03:13,360 --> 00:03:15,360
is basically another miner that will

87
00:03:15,360 --> 00:03:17,360
attack you to maybe do the denial of

88
00:03:17,360 --> 00:03:19,120
service or this kind of

89
00:03:19,120 --> 00:03:20,400
vulnerability

90
00:03:20,400 --> 00:03:23,280
so it will be basically using the enr

91
00:03:23,280 --> 00:03:25,760
and all this other networking stack

92
00:03:25,760 --> 00:03:27,680
and then we have the

93
00:03:27,680 --> 00:03:30,159
beacon chain itself so the different

94
00:03:30,159 --> 00:03:33,280
basic blocks that are sent to each other

95
00:03:33,280 --> 00:03:36,560
and this one are basically serialized in

96
00:03:36,560 --> 00:03:40,879
and encode into what we call ssd so it's

97
00:03:40,879 --> 00:03:43,200
specific format and it's more easy to

98
00:03:43,200 --> 00:03:45,840
just give them and share this kind of

99
00:03:45,840 --> 00:03:48,959
stuff and basically this one this object

100
00:03:48,959 --> 00:03:51,200
will contain

101
00:03:51,200 --> 00:03:53,760
the block the transit the transition and

102
00:03:53,760 --> 00:03:55,280
all this kind of

103
00:03:55,280 --> 00:03:57,760
blockchain specific stuff

104
00:03:57,760 --> 00:03:59,200
so in terms of bugs that are really

105
00:03:59,200 --> 00:04:01,360
interesting we have all the stuff that

106
00:04:01,360 --> 00:04:03,200
will crush or panic

107
00:04:03,200 --> 00:04:05,200
because as i mentioned that means a

108
00:04:05,200 --> 00:04:08,000
complete denial of service of the

109
00:04:08,000 --> 00:04:10,799
node so that's really bad of course we

110
00:04:10,799 --> 00:04:13,439
are looking for memory option and

111
00:04:13,439 --> 00:04:15,599
if we can get rce that's even better but

112
00:04:15,599 --> 00:04:17,199
you will see that because of the

113
00:04:17,199 --> 00:04:19,759
language they actually choose

114
00:04:19,759 --> 00:04:21,918
it's not something that we will see

115
00:04:21,918 --> 00:04:23,680
really often to be honest

116
00:04:23,680 --> 00:04:26,400
and one kind of bug that is

117
00:04:26,400 --> 00:04:27,840
really specific to blockchain are

118
00:04:27,840 --> 00:04:30,479
consensus bug so that's mean it's a

119
00:04:30,479 --> 00:04:32,960
logic bug but since we are dealing with

120
00:04:32,960 --> 00:04:36,080
blockchain um if we have a logic bug

121
00:04:36,080 --> 00:04:37,840
that means you will get part of the

122
00:04:37,840 --> 00:04:40,320
network that will do some one thing the

123
00:04:40,320 --> 00:04:42,080
other part will do another thing and

124
00:04:42,080 --> 00:04:44,800
that's what we call a fork so if we have

125
00:04:44,800 --> 00:04:46,639
something like that it's really

126
00:04:46,639 --> 00:04:47,520
again

127
00:04:47,520 --> 00:04:49,600
one of the most critical vulnerability

128
00:04:49,600 --> 00:04:52,479
you maybe heard of some of them recently

129
00:04:52,479 --> 00:04:53,520
um

130
00:04:53,520 --> 00:04:56,080
on other blockchain and that's the kind

131
00:04:56,080 --> 00:04:58,080
of bug that

132
00:04:58,080 --> 00:05:00,560
leads to the development of this further

133
00:05:00,560 --> 00:05:01,680
that we're gonna

134
00:05:01,680 --> 00:05:04,400
that i'm gonna discuss

135
00:05:04,400 --> 00:05:06,560
so the target of today will be this one

136
00:05:06,560 --> 00:05:08,320
so the first one is lighthouse developed

137
00:05:08,320 --> 00:05:11,440
by sigma prime and in rust the other one

138
00:05:11,440 --> 00:05:15,120
prism in go nimbus in niem so maybe some

139
00:05:15,120 --> 00:05:17,360
of you don't know what is it and that's

140
00:05:17,360 --> 00:05:19,440
perfectly normal

141
00:05:19,440 --> 00:05:20,960
you have tekku

142
00:05:20,960 --> 00:05:23,280
in java and you have

143
00:05:23,280 --> 00:05:27,039
so i put this one as a client it's

144
00:05:27,039 --> 00:05:28,880
a client and not really a client i mean

145
00:05:28,880 --> 00:05:30,560
it's written in javascript and tab

146
00:05:30,560 --> 00:05:34,160
scripts so you you can think that

147
00:05:34,160 --> 00:05:36,080
it's gonna be maybe complicated to have

148
00:05:36,080 --> 00:05:38,000
like some proper node and proper

149
00:05:38,000 --> 00:05:39,680
software at the end that will just run

150
00:05:39,680 --> 00:05:42,240
everything in in this language so the

151
00:05:42,240 --> 00:05:44,479
main idea is lostar is also providing a

152
00:05:44,479 --> 00:05:46,560
lot of library for

153
00:05:46,560 --> 00:05:48,639
web application and so on related to

154
00:05:48,639 --> 00:05:51,120
sram so that's still a really good

155
00:05:51,120 --> 00:05:53,039
target for us

156
00:05:53,039 --> 00:05:56,160
and especially because if you remember

157
00:05:56,160 --> 00:05:57,759
they should all follow the same

158
00:05:57,759 --> 00:05:59,919
specification so that's

159
00:05:59,919 --> 00:06:01,759
already a really good point

160
00:06:01,759 --> 00:06:03,919
so at this point the main difficulty as

161
00:06:03,919 --> 00:06:05,680
you can see is we have

162
00:06:05,680 --> 00:06:08,400
let's say five different software

163
00:06:08,400 --> 00:06:11,039
written by five different team in five

164
00:06:11,039 --> 00:06:13,440
different language and they should

165
00:06:13,440 --> 00:06:15,199
basically follow the same specification

166
00:06:15,199 --> 00:06:18,240
so what can go wrong

167
00:06:18,560 --> 00:06:20,800
so let's talk about beacon first so

168
00:06:20,800 --> 00:06:23,840
that's the further we uh i basically

169
00:06:23,840 --> 00:06:27,199
wrote and i wrote it with sigma prime

170
00:06:27,199 --> 00:06:28,720
another company that

171
00:06:28,720 --> 00:06:31,039
specialized in blockchain security

172
00:06:31,039 --> 00:06:34,160
and also one of the developer of one of

173
00:06:34,160 --> 00:06:35,360
this

174
00:06:35,360 --> 00:06:36,400
client

175
00:06:36,400 --> 00:06:37,680
so basically to give you a bit of

176
00:06:37,680 --> 00:06:40,479
history the project starts not with me

177
00:06:40,479 --> 00:06:43,520
but with guido that is really well known

178
00:06:43,520 --> 00:06:46,720
with the um i think it's crypto first

179
00:06:46,720 --> 00:06:47,759
project

180
00:06:47,759 --> 00:06:49,120
and basically he's doing a lot of

181
00:06:49,120 --> 00:06:50,880
different shelf fuzzing and so on so

182
00:06:50,880 --> 00:06:53,520
basically create a proof of concept um

183
00:06:53,520 --> 00:06:54,560
using

184
00:06:54,560 --> 00:06:56,720
a leap further written in simple spruce

185
00:06:56,720 --> 00:06:58,400
and he was already starting to do the

186
00:06:58,400 --> 00:07:00,639
job in 2019

187
00:07:00,639 --> 00:07:03,199
so after that sigma prime gets the lead

188
00:07:03,199 --> 00:07:05,520
on that and they get they receive a

189
00:07:05,520 --> 00:07:07,919
grant by the hrm foundation to basically

190
00:07:07,919 --> 00:07:10,560
continue the project and and find some

191
00:07:10,560 --> 00:07:13,280
new bugs and after some time i discuss

192
00:07:13,280 --> 00:07:15,759
with the sigma prime game and we find

193
00:07:15,759 --> 00:07:18,080
out that it could be a good fit to to

194
00:07:18,080 --> 00:07:20,240
work together so that's the the start of

195
00:07:20,240 --> 00:07:22,880
the beacon first project

196
00:07:22,880 --> 00:07:25,120
so as i mentioned i'm going to discuss

197
00:07:25,120 --> 00:07:26,479
about like basically the complete

198
00:07:26,479 --> 00:07:30,800
process that we have been through

199
00:07:30,800 --> 00:07:32,080
so the first

200
00:07:32,080 --> 00:07:34,560
thing we i take a look was basically the

201
00:07:34,560 --> 00:07:37,919
existing code and it's in simplest press

202
00:07:37,919 --> 00:07:40,400
and i really don't don't like simple

203
00:07:40,400 --> 00:07:42,639
spreads so that was the

204
00:07:42,639 --> 00:07:44,720
main issue for me at first

205
00:07:44,720 --> 00:07:46,400
because i mean if i need to spend like

206
00:07:46,400 --> 00:07:48,960
one years and and more on a project and

207
00:07:48,960 --> 00:07:52,560
i don't like the language and i'm

208
00:07:52,560 --> 00:07:54,240
really not happy to write any separate

209
00:07:54,240 --> 00:07:55,599
place line of code

210
00:07:55,599 --> 00:07:57,759
it's going to be complicated and even if

211
00:07:57,759 --> 00:07:58,879
you take a look at all the other

212
00:07:58,879 --> 00:08:00,800
projects there is none in separate place

213
00:08:00,800 --> 00:08:03,440
there is in rust and especially sigma

214
00:08:03,440 --> 00:08:04,400
prime

215
00:08:04,400 --> 00:08:06,560
is wrecking everything in rest so i can

216
00:08:06,560 --> 00:08:09,039
also leverage the fact that the people

217
00:08:09,039 --> 00:08:12,000
where with who i'm working are actually

218
00:08:12,000 --> 00:08:14,400
developing one of the clients in russ so

219
00:08:14,400 --> 00:08:17,440
if i need any advice any help i can just

220
00:08:17,440 --> 00:08:19,680
basically ask them

221
00:08:19,680 --> 00:08:23,039
so the first road map that we come

222
00:08:23,039 --> 00:08:25,360
was this one the first thing

223
00:08:25,360 --> 00:08:26,879
it was needed for me to understand the

224
00:08:26,879 --> 00:08:29,039
context of it i mean i was familiar with

225
00:08:29,039 --> 00:08:31,919
atram but not with the current future

226
00:08:31,919 --> 00:08:33,599
evolution of it

227
00:08:33,599 --> 00:08:34,559
um

228
00:08:34,559 --> 00:08:37,039
after that i was planning to do

229
00:08:37,039 --> 00:08:38,958
what we call um

230
00:08:38,958 --> 00:08:42,080
eth2 first so basically coverage guided

231
00:08:42,080 --> 00:08:43,039
fuzzing

232
00:08:43,039 --> 00:08:45,200
that will allow us to generate a fuzzing

233
00:08:45,200 --> 00:08:47,440
corporate that will be reusable

234
00:08:47,440 --> 00:08:50,160
across all the different clients

235
00:08:50,160 --> 00:08:52,320
then we find out that it could be really

236
00:08:52,320 --> 00:08:54,640
interesting to have like a really basic

237
00:08:54,640 --> 00:08:57,040
differential further that means we will

238
00:08:57,040 --> 00:08:59,200
just provide an input and compare the

239
00:08:59,200 --> 00:09:00,640
result against all the other

240
00:09:00,640 --> 00:09:02,000
implementation but

241
00:09:02,000 --> 00:09:03,680
actually in that case without writing

242
00:09:03,680 --> 00:09:05,360
any line of code because it was just

243
00:09:05,360 --> 00:09:07,760
basically you leveraging on all the

244
00:09:07,760 --> 00:09:09,680
testing tools available

245
00:09:09,680 --> 00:09:12,160
by all the different clients so that was

246
00:09:12,160 --> 00:09:13,680
really easy to implement and you're

247
00:09:13,680 --> 00:09:16,080
going to see that and the final one the

248
00:09:16,080 --> 00:09:17,920
most painful one

249
00:09:17,920 --> 00:09:20,480
in in that case was the differential

250
00:09:20,480 --> 00:09:22,560
further beacon first two

251
00:09:22,560 --> 00:09:24,560
and basically this one is doing

252
00:09:24,560 --> 00:09:27,200
structural fuzzing

253
00:09:27,200 --> 00:09:28,399
and

254
00:09:28,399 --> 00:09:30,080
especially it's doing differential

255
00:09:30,080 --> 00:09:33,279
fuzzing against directly the

256
00:09:33,279 --> 00:09:36,640
older client and the painful point on

257
00:09:36,640 --> 00:09:39,600
that is basically that um it was needed

258
00:09:39,600 --> 00:09:42,160
to create ffi bindings to basically

259
00:09:42,160 --> 00:09:43,680
communicate directly with all those

260
00:09:43,680 --> 00:09:45,519
clients in turn in all those different

261
00:09:45,519 --> 00:09:48,560
languages so that was kind of easy

262
00:09:48,560 --> 00:09:51,040
as as a project but the return on

263
00:09:51,040 --> 00:09:52,959
investment to bns was

264
00:09:52,959 --> 00:09:54,800
really really nice and we we're gonna

265
00:09:54,800 --> 00:09:56,399
see that

266
00:09:56,399 --> 00:09:59,040
so yeah i'm on shown some design choice

267
00:09:59,040 --> 00:10:00,240
already so

268
00:10:00,240 --> 00:10:02,560
rewriting everything in rest

269
00:10:02,560 --> 00:10:05,360
better lean and so on and so on i will

270
00:10:05,360 --> 00:10:07,200
not

271
00:10:07,200 --> 00:10:08,480
give you

272
00:10:08,480 --> 00:10:11,040
too much love but trust

273
00:10:11,040 --> 00:10:12,720
and after that

274
00:10:12,720 --> 00:10:14,959
why should we create multiple fuzzing

275
00:10:14,959 --> 00:10:18,240
tools and the main reason is

276
00:10:18,240 --> 00:10:20,560
we will not target the same piece of

277
00:10:20,560 --> 00:10:21,920
code each time

278
00:10:21,920 --> 00:10:23,279
and also

279
00:10:23,279 --> 00:10:25,440
something that is really important to

280
00:10:25,440 --> 00:10:27,600
keep in mind is

281
00:10:27,600 --> 00:10:29,760
all those different teams are following

282
00:10:29,760 --> 00:10:31,600
the same specification

283
00:10:31,600 --> 00:10:32,880
over the time

284
00:10:32,880 --> 00:10:35,120
the specification is changing they are

285
00:10:35,120 --> 00:10:37,760
not always following the same one and

286
00:10:37,760 --> 00:10:39,040
they

287
00:10:39,040 --> 00:10:42,079
don't always follow the same

288
00:10:42,079 --> 00:10:44,160
architecture and reproduce exactly what

289
00:10:44,160 --> 00:10:46,399
the specification is all about

290
00:10:46,399 --> 00:10:47,600
so

291
00:10:47,600 --> 00:10:49,600
the main idea with creating multiple

292
00:10:49,600 --> 00:10:51,519
phrasing tools is basically to be really

293
00:10:51,519 --> 00:10:54,640
fast if there is any broken

294
00:10:54,640 --> 00:10:57,200
changes and if

295
00:10:57,200 --> 00:10:59,440
one client is only at the same

296
00:10:59,440 --> 00:11:01,519
specification version numbers and

297
00:11:01,519 --> 00:11:03,600
another one and so on having something

298
00:11:03,600 --> 00:11:05,600
modulable that will still allow us to

299
00:11:05,600 --> 00:11:08,480
find bugs even if

300
00:11:08,480 --> 00:11:12,000
we got some stuff that are broken

301
00:11:12,000 --> 00:11:13,760
after that the second question we can

302
00:11:13,760 --> 00:11:15,600
ask is why not directly use the most

303
00:11:15,600 --> 00:11:17,279
efficient technique as i mentioned i

304
00:11:17,279 --> 00:11:18,399
mean the

305
00:11:18,399 --> 00:11:20,480
big differential frozen that

306
00:11:20,480 --> 00:11:21,440
i mean

307
00:11:21,440 --> 00:11:23,519
typically you can just find every bugs

308
00:11:23,519 --> 00:11:25,839
that we we're gonna find previously

309
00:11:25,839 --> 00:11:29,600
and the main idea is always to find all

310
00:11:29,600 --> 00:11:32,160
the longing fruit the faster because if

311
00:11:32,160 --> 00:11:35,040
you have for example a bug that will

312
00:11:35,040 --> 00:11:37,040
you succeed to trigger it and it's on

313
00:11:37,040 --> 00:11:39,440
the ssd decoding part that's mean

314
00:11:39,440 --> 00:11:41,519
whatever stuff you're gonna send that

315
00:11:41,519 --> 00:11:43,200
actually trigger this bug

316
00:11:43,200 --> 00:11:45,760
you will get a crash maybe

317
00:11:45,760 --> 00:11:48,240
probably thousands of crashes and you

318
00:11:48,240 --> 00:11:50,000
will just be stuck and you will not be

319
00:11:50,000 --> 00:11:52,000
able to go deeper in the code base and

320
00:11:52,000 --> 00:11:54,399
find the bugs that are basically after

321
00:11:54,399 --> 00:11:56,880
so it's really important to to be fast

322
00:11:56,880 --> 00:11:58,240
on that and

323
00:11:58,240 --> 00:12:00,399
try to find all those longing foot the

324
00:12:00,399 --> 00:12:02,720
the faster

325
00:12:02,720 --> 00:12:05,120
so let's talk about the first one eth2

326
00:12:05,120 --> 00:12:07,120
first so as i mentioned it will be

327
00:12:07,120 --> 00:12:09,440
coverage guided fuzzing so right now the

328
00:12:09,440 --> 00:12:11,680
question is oh are you doing coverage

329
00:12:11,680 --> 00:12:13,760
guided fuzzing on all the language i

330
00:12:13,760 --> 00:12:15,279
mentioned so i will just give you some

331
00:12:15,279 --> 00:12:17,920
detail and also show you the result of

332
00:12:17,920 --> 00:12:18,959
it

333
00:12:18,959 --> 00:12:21,680
so that will be this specific part and

334
00:12:21,680 --> 00:12:23,519
just keep in mind that everything we are

335
00:12:23,519 --> 00:12:25,360
doing we are not just standing bugs we

336
00:12:25,360 --> 00:12:27,519
are also generating a fuzzing corpora

337
00:12:27,519 --> 00:12:28,959
and that's really interesting and really

338
00:12:28,959 --> 00:12:31,839
important because this corpora will be

339
00:12:31,839 --> 00:12:35,200
like a key point into the complete

340
00:12:35,200 --> 00:12:37,200
fuzzing ecosystem that we are building

341
00:12:37,200 --> 00:12:38,880
right now

342
00:12:38,880 --> 00:12:41,839
so the first one um i actually first was

343
00:12:41,839 --> 00:12:43,600
lighthouse directly because it was

344
00:12:43,600 --> 00:12:46,079
written in rust and i was already really

345
00:12:46,079 --> 00:12:48,480
familiar with fuzzing with rose code

346
00:12:48,480 --> 00:12:50,240
and in term of

347
00:12:50,240 --> 00:12:51,760
further available you have really a

348
00:12:51,760 --> 00:12:53,120
bunch of them

349
00:12:53,120 --> 00:12:55,360
typically these are just bindings on the

350
00:12:55,360 --> 00:12:57,519
the surprise plus furthers that already

351
00:12:57,519 --> 00:13:00,240
exist so on first cargo first and afl

352
00:13:00,240 --> 00:13:03,040
so really easy to to use really easy to

353
00:13:03,040 --> 00:13:06,160
maintain in terms of complexity for the

354
00:13:06,160 --> 00:13:08,560
fuzzing harnesses itself

355
00:13:08,560 --> 00:13:11,200
the first step was to basically using

356
00:13:11,200 --> 00:13:14,639
those further generate ssd object so i

357
00:13:14,639 --> 00:13:18,320
will just generate some ssd binary

358
00:13:18,320 --> 00:13:22,160
and after that i took this ssd binary i

359
00:13:22,160 --> 00:13:25,120
tried to convert that so do a decoding

360
00:13:25,120 --> 00:13:27,920
into a proper object

361
00:13:27,920 --> 00:13:30,959
then i try to load randomly one beacon

362
00:13:30,959 --> 00:13:33,360
state because in that case we have um so

363
00:13:33,360 --> 00:13:34,399
there is

364
00:13:34,399 --> 00:13:36,000
when we are doing like processing of

365
00:13:36,000 --> 00:13:37,680
this kind of stuff we have

366
00:13:37,680 --> 00:13:40,000
an existing state and basically the

367
00:13:40,000 --> 00:13:42,320
block we're going to process will update

368
00:13:42,320 --> 00:13:44,880
this state to another one so it's always

369
00:13:44,880 --> 00:13:47,360
like an association between state and

370
00:13:47,360 --> 00:13:49,360
some object to process

371
00:13:49,360 --> 00:13:51,440
so in that case i i've made something

372
00:13:51,440 --> 00:13:53,199
really simple i just took the all the

373
00:13:53,199 --> 00:13:55,440
unit testes given by the adram

374
00:13:55,440 --> 00:13:56,639
foundation

375
00:13:56,639 --> 00:13:59,199
and i extract all the beacon state and i

376
00:13:59,199 --> 00:14:01,600
basically just pick randomly one each

377
00:14:01,600 --> 00:14:03,680
time the further is restarting or after

378
00:14:03,680 --> 00:14:04,639
some time

379
00:14:04,639 --> 00:14:07,040
and finally the processing of the state

380
00:14:07,040 --> 00:14:09,519
transition so you can see that the

381
00:14:09,519 --> 00:14:11,120
i mean in terms of piece of code it's

382
00:14:11,120 --> 00:14:13,519
really simple not really fancy

383
00:14:13,519 --> 00:14:14,480
but

384
00:14:14,480 --> 00:14:16,800
that's also the good part of having all

385
00:14:16,800 --> 00:14:18,000
the clients following the same

386
00:14:18,000 --> 00:14:20,240
specification they

387
00:14:20,240 --> 00:14:22,399
got a bit to use like the the same

388
00:14:22,399 --> 00:14:24,959
naming and the same um

389
00:14:24,959 --> 00:14:27,360
function prototype so it's even simpler

390
00:14:27,360 --> 00:14:29,279
to go through the like switching from

391
00:14:29,279 --> 00:14:31,839
codebase to codebase

392
00:14:31,839 --> 00:14:34,160
so the result of that was basically

393
00:14:34,160 --> 00:14:36,880
three bug phones so the first one was a

394
00:14:36,880 --> 00:14:38,880
memory allocation failure so it could be

395
00:14:38,880 --> 00:14:40,959
weird since we are talking about trust

396
00:14:40,959 --> 00:14:41,760
and

397
00:14:41,760 --> 00:14:43,519
a lot of you might know that rust is

398
00:14:43,519 --> 00:14:45,760
well known to be pretty good in memory

399
00:14:45,760 --> 00:14:46,720
safety

400
00:14:46,720 --> 00:14:49,600
but the fact is this one was basically

401
00:14:49,600 --> 00:14:52,079
trying to allocate too much memory and

402
00:14:52,079 --> 00:14:54,800
it was just like growing too fast and at

403
00:14:54,800 --> 00:14:56,800
some point just shut down

404
00:14:56,800 --> 00:14:59,279
the two other one was some panics so

405
00:14:59,279 --> 00:15:01,519
panics in russ are really really common

406
00:15:01,519 --> 00:15:04,079
there is multiple ways to trigger panics

407
00:15:04,079 --> 00:15:06,320
and

408
00:15:06,320 --> 00:15:07,600
if you are

409
00:15:07,600 --> 00:15:08,880
developing a

410
00:15:08,880 --> 00:15:10,320
like a cli

411
00:15:10,320 --> 00:15:11,279
tool

412
00:15:11,279 --> 00:15:14,079
you don't really care of panics but as a

413
00:15:14,079 --> 00:15:15,680
reminder panics

414
00:15:15,680 --> 00:15:17,519
mean denial of service

415
00:15:17,519 --> 00:15:19,680
when we are talking about blockchain

416
00:15:19,680 --> 00:15:21,120
software

417
00:15:21,120 --> 00:15:24,079
so that's the idea so the good part of

418
00:15:24,079 --> 00:15:26,160
this is that in terms of limitation i

419
00:15:26,160 --> 00:15:28,000
was not really limited when developing

420
00:15:28,000 --> 00:15:29,920
the stuff it was just like taking some

421
00:15:29,920 --> 00:15:32,160
more time to just target another part of

422
00:15:32,160 --> 00:15:34,959
the code and that was pretty much all so

423
00:15:34,959 --> 00:15:37,759
that's nice to to not be limited

424
00:15:37,759 --> 00:15:40,240
either by the fuzzer or other by the

425
00:15:40,240 --> 00:15:42,160
client itself

426
00:15:42,160 --> 00:15:44,240
in terms of improvement there is a lot

427
00:15:44,240 --> 00:15:45,199
of them

428
00:15:45,199 --> 00:15:46,560
basically the first one will be

429
00:15:46,560 --> 00:15:48,160
structural fuzzing using what we call

430
00:15:48,160 --> 00:15:50,240
the arbitrary trait and you're going to

431
00:15:50,240 --> 00:15:51,920
see that that's basically what we're

432
00:15:51,920 --> 00:15:53,519
going to use later

433
00:15:53,519 --> 00:15:56,399
for another tool and yeah of course

434
00:15:56,399 --> 00:15:58,560
adding more fuzzing harnesses mean

435
00:15:58,560 --> 00:16:00,399
increasing the code coverage and

436
00:16:00,399 --> 00:16:02,880
potentially finding more bugs

437
00:16:02,880 --> 00:16:05,360
so that was lighthouse and

438
00:16:05,360 --> 00:16:07,360
if you remember

439
00:16:07,360 --> 00:16:09,120
the scheme

440
00:16:09,120 --> 00:16:10,959
this stuff allow me to generate a

441
00:16:10,959 --> 00:16:12,959
fuzzing coupler so once i have this

442
00:16:12,959 --> 00:16:15,360
fuzzing copper that will basically be

443
00:16:15,360 --> 00:16:17,199
assess the object

444
00:16:17,199 --> 00:16:19,759
i can just do them fuzzing so

445
00:16:19,759 --> 00:16:21,920
basically i'm just taking an existing

446
00:16:21,920 --> 00:16:24,240
client so for this one it was prism and

447
00:16:24,240 --> 00:16:26,560
i just use like one of the utility tools

448
00:16:26,560 --> 00:16:28,480
they give me and i just provide

449
00:16:28,480 --> 00:16:31,120
everything and hope for crashes

450
00:16:31,120 --> 00:16:34,160
sadly i failed to that for this one

451
00:16:34,160 --> 00:16:35,680
and i mean

452
00:16:35,680 --> 00:16:37,199
it was not

453
00:16:37,199 --> 00:16:38,959
so important to file at this point

454
00:16:38,959 --> 00:16:39,839
because

455
00:16:39,839 --> 00:16:41,759
i mean basically

456
00:16:41,759 --> 00:16:44,639
it's pretty simple and that means

457
00:16:44,639 --> 00:16:47,120
we we have still a lot

458
00:16:47,120 --> 00:16:50,560
lots of stuff to to do so this one from

459
00:16:50,560 --> 00:16:51,839
no bugs

460
00:16:51,839 --> 00:16:54,320
okay whatever let's go and do coverage

461
00:16:54,320 --> 00:16:57,519
guided fuzzing again but this time in go

462
00:16:57,519 --> 00:17:00,000
so you have multiple gophers there again

463
00:17:00,000 --> 00:17:01,680
so

464
00:17:01,680 --> 00:17:04,160
personally i prefer to use go first but

465
00:17:04,160 --> 00:17:07,280
with the specific leap further flag that

466
00:17:07,280 --> 00:17:08,880
will basically just

467
00:17:08,880 --> 00:17:10,720
create an archive and you can just

468
00:17:10,720 --> 00:17:12,799
compile it with clang and that's okay

469
00:17:12,799 --> 00:17:14,480
you are basically running lip feather

470
00:17:14,480 --> 00:17:16,240
and not something else

471
00:17:16,240 --> 00:17:18,880
so that's good in terms of complexity i

472
00:17:18,880 --> 00:17:21,199
call it medium because the main issue

473
00:17:21,199 --> 00:17:23,679
that i got was all the self regarding

474
00:17:23,679 --> 00:17:26,000
like seagull and especially they are

475
00:17:26,000 --> 00:17:28,559
using some bls implementation that is

476
00:17:28,559 --> 00:17:31,760
like something in c that is used in

477
00:17:31,760 --> 00:17:34,000
their project and so on and on top of

478
00:17:34,000 --> 00:17:35,840
that there was using basel so i don't

479
00:17:35,840 --> 00:17:37,760
know if you're familiar with basil

480
00:17:37,760 --> 00:17:40,720
it's supposed to help people to

481
00:17:40,720 --> 00:17:43,200
maintain and compile more easily their

482
00:17:43,200 --> 00:17:44,240
stuff

483
00:17:44,240 --> 00:17:46,080
i mean it's the case only if you know

484
00:17:46,080 --> 00:17:48,720
basel otherwise it's a complete mess so

485
00:17:48,720 --> 00:17:51,760
hopefully uh they um

486
00:17:51,760 --> 00:17:54,240
at some point rewrite a bunch of the the

487
00:17:54,240 --> 00:17:56,960
codes they they was using and they uh

488
00:17:56,960 --> 00:17:58,559
called what they said the biggest

489
00:17:58,559 --> 00:18:00,720
feature of the year that is basically

490
00:18:00,720 --> 00:18:03,600
having prism that is go gettable so that

491
00:18:03,600 --> 00:18:07,360
means really easily installable and

492
00:18:07,360 --> 00:18:11,039
usable and so on so it helped me a lot

493
00:18:11,039 --> 00:18:13,039
so that's basically under the snee path

494
00:18:13,039 --> 00:18:14,720
of code if you

495
00:18:14,720 --> 00:18:16,480
want to first in that case it was like a

496
00:18:16,480 --> 00:18:18,799
blockader so as you can see it's taking

497
00:18:18,799 --> 00:18:21,280
some bite and after that we are creating

498
00:18:21,280 --> 00:18:23,760
some beacon block so i mean it was

499
00:18:23,760 --> 00:18:26,240
extracted and loaded from somewhere else

500
00:18:26,240 --> 00:18:28,320
we are doing the un-martial ssc so we

501
00:18:28,320 --> 00:18:29,360
are doing the

502
00:18:29,360 --> 00:18:32,480
decoding of the ssd object once we have

503
00:18:32,480 --> 00:18:35,120
the object we are initially

504
00:18:35,120 --> 00:18:37,679
doing some initialization sorry and

505
00:18:37,679 --> 00:18:39,840
after that we are doing block process

506
00:18:39,840 --> 00:18:42,400
block header and that's that's okay you

507
00:18:42,400 --> 00:18:44,559
can see that we are using like process

508
00:18:44,559 --> 00:18:47,679
blockade or no verify that's because

509
00:18:47,679 --> 00:18:49,360
and that's again some really useful

510
00:18:49,360 --> 00:18:51,360
feature if you are doing fuzzing

511
00:18:51,360 --> 00:18:54,320
in that case i we ask the all the teams

512
00:18:54,320 --> 00:18:55,679
to basically

513
00:18:55,679 --> 00:18:57,440
provide us

514
00:18:57,440 --> 00:18:59,760
like the equivalent of the real function

515
00:18:59,760 --> 00:19:02,240
but without all the mathematical

516
00:19:02,240 --> 00:19:04,559
verification and all the cryptographic

517
00:19:04,559 --> 00:19:07,120
verification that can be in place so in

518
00:19:07,120 --> 00:19:09,120
that case there is some dls

519
00:19:09,120 --> 00:19:11,039
refrigeration and so on and the main

520
00:19:11,039 --> 00:19:12,559
goal with that is

521
00:19:12,559 --> 00:19:14,960
since i will do fuzzing i don't i mean

522
00:19:14,960 --> 00:19:17,840
if there is any ashes comparison and so

523
00:19:17,840 --> 00:19:19,679
on of course it will fail

524
00:19:19,679 --> 00:19:21,679
every time and i will be stuck at this

525
00:19:21,679 --> 00:19:22,559
point

526
00:19:22,559 --> 00:19:24,640
into the fuzzing process so basically

527
00:19:24,640 --> 00:19:26,480
i'm just telling them okay let's

528
00:19:26,480 --> 00:19:29,039
consider that all the verifications that

529
00:19:29,039 --> 00:19:30,960
you are doing in terms of cryptography

530
00:19:30,960 --> 00:19:33,120
are okay and for the rest we can just

531
00:19:33,120 --> 00:19:34,640
continue

532
00:19:34,640 --> 00:19:37,360
so the result of that was three bucks so

533
00:19:37,360 --> 00:19:39,919
that's uh that was nice um in that case

534
00:19:39,919 --> 00:19:42,799
we got some slice bond outer front one

535
00:19:42,799 --> 00:19:44,799
of the most common vulnerability in go

536
00:19:44,799 --> 00:19:47,039
software and also some nil pointer de

537
00:19:47,039 --> 00:19:49,039
reference also something really common

538
00:19:49,039 --> 00:19:50,880
especially if you are not checking the

539
00:19:50,880 --> 00:19:53,120
error that is returned by the function

540
00:19:53,120 --> 00:19:56,720
so that was the the case uh right there

541
00:19:56,720 --> 00:19:59,280
and yeah it was it was nice it was fine

542
00:19:59,280 --> 00:20:02,159
it was generating some new um corpora

543
00:20:02,159 --> 00:20:03,840
some new input that was completely

544
00:20:03,840 --> 00:20:05,360
actually different

545
00:20:05,360 --> 00:20:06,640
for some of them

546
00:20:06,640 --> 00:20:09,200
than the the rest one and so on so we

547
00:20:09,200 --> 00:20:11,760
can just move on on that

548
00:20:11,760 --> 00:20:13,360
so after that

549
00:20:13,360 --> 00:20:15,600
again i took the shot to

550
00:20:15,600 --> 00:20:17,679
go to another one in that case nimbus

551
00:20:17,679 --> 00:20:19,120
written in nim

552
00:20:19,120 --> 00:20:21,360
so i will talk a bit more after about

553
00:20:21,360 --> 00:20:23,120
nim and basically they are also

554
00:20:23,120 --> 00:20:25,120
providing a bunch of testing tools so

555
00:20:25,120 --> 00:20:27,520
dumb fuzzing again and this time i was a

556
00:20:27,520 --> 00:20:28,880
bit more lucky

557
00:20:28,880 --> 00:20:30,159
basically because

558
00:20:30,159 --> 00:20:32,320
the implementation and the way they

559
00:20:32,320 --> 00:20:34,320
developed the ssc coding was buggy at

560
00:20:34,320 --> 00:20:36,400
this time so

561
00:20:36,400 --> 00:20:38,880
i succeeded to find like five bugs

562
00:20:38,880 --> 00:20:40,799
and typically there's the kind of

563
00:20:40,799 --> 00:20:42,960
longing truck that you are looking at

564
00:20:42,960 --> 00:20:44,240
because

565
00:20:44,240 --> 00:20:46,400
those kind of bugs will have

566
00:20:46,400 --> 00:20:49,039
the completely blocking my other

567
00:20:49,039 --> 00:20:51,360
coverage guided further in the future so

568
00:20:51,360 --> 00:20:53,200
that was really nice to just be able to

569
00:20:53,200 --> 00:20:55,520
find them so as you can see we have some

570
00:20:55,520 --> 00:20:58,000
segmentation fault um some assertion

571
00:20:58,000 --> 00:20:59,840
error and index error

572
00:20:59,840 --> 00:21:02,559
so let's discuss quickly about the

573
00:21:02,559 --> 00:21:05,520
what is nim and why we are getting some

574
00:21:05,520 --> 00:21:08,240
segmentation fault basically nim is a

575
00:21:08,240 --> 00:21:10,000
programming language that look like

576
00:21:10,000 --> 00:21:12,080
python that you have like some snippet

577
00:21:12,080 --> 00:21:14,799
of code right there

578
00:21:14,799 --> 00:21:17,760
and it's a compile language with some

579
00:21:17,760 --> 00:21:20,960
strong type static typing

580
00:21:20,960 --> 00:21:22,880
but the way it works is basically the

581
00:21:22,880 --> 00:21:26,240
nim compiler will compile

582
00:21:26,240 --> 00:21:29,039
your name code into c

583
00:21:29,039 --> 00:21:31,360
and after that they are basically it's

584
00:21:31,360 --> 00:21:33,840
the classical compilation of c program

585
00:21:33,840 --> 00:21:35,120
so you

586
00:21:35,120 --> 00:21:37,840
you start to see what could go wrong uh

587
00:21:37,840 --> 00:21:42,720
with like name to c c to binary

588
00:21:42,840 --> 00:21:46,159
and of course we can get some bugs like

589
00:21:46,159 --> 00:21:48,320
segmentation fault and so on but the

590
00:21:48,320 --> 00:21:50,880
good part of it is we can easily

591
00:21:50,880 --> 00:21:52,799
integrate some and

592
00:21:52,799 --> 00:21:55,840
add some existing further on top of that

593
00:21:55,840 --> 00:21:57,600
and also the good part in that case

594
00:21:57,600 --> 00:21:59,600
really good part is that actually the

595
00:21:59,600 --> 00:22:01,760
nimbus team that is developing this

596
00:22:01,760 --> 00:22:02,559
stuff

597
00:22:02,559 --> 00:22:06,000
is actually like contain a lot of the

598
00:22:06,000 --> 00:22:07,600
developer of the nin programming

599
00:22:07,600 --> 00:22:09,600
language so i can it was possible just

600
00:22:09,600 --> 00:22:11,520
for me to ask them if they can just

601
00:22:11,520 --> 00:22:13,280
implement a new photo

602
00:22:13,280 --> 00:22:15,679
and basically provide me some something

603
00:22:15,679 --> 00:22:18,480
really easy to do and just continue my

604
00:22:18,480 --> 00:22:21,520
work and and find some new bugs

605
00:22:21,520 --> 00:22:23,679
so in terms of complexity in that case a

606
00:22:23,679 --> 00:22:26,080
completely new language to learn and to

607
00:22:26,080 --> 00:22:27,440
deal with

608
00:22:27,440 --> 00:22:28,240
and

609
00:22:28,240 --> 00:22:29,440
yeah as i mentioned the further

610
00:22:29,440 --> 00:22:32,080
abstraction was not available so just

611
00:22:32,080 --> 00:22:34,880
need to wait a bit and it was not like

612
00:22:34,880 --> 00:22:36,559
pretty straightforward like the other

613
00:22:36,559 --> 00:22:37,520
one

614
00:22:37,520 --> 00:22:39,760
i will try to be quick on the other one

615
00:22:39,760 --> 00:22:41,919
but you you get the you get the idea so

616
00:22:41,919 --> 00:22:45,120
this one find two bugs um not a lot of

617
00:22:45,120 --> 00:22:48,000
limitation because once i i got my lip

618
00:22:48,000 --> 00:22:50,400
further running on meme code that was

619
00:22:50,400 --> 00:22:51,840
pretty nice

620
00:22:51,840 --> 00:22:53,440
and so on so

621
00:22:53,440 --> 00:22:55,280
pretty pretty nice

622
00:22:55,280 --> 00:22:58,320
tequi was in java

623
00:22:58,320 --> 00:23:00,880
again some dumb fuzzing really simple

624
00:23:00,880 --> 00:23:03,360
just using the docker getting some cli

625
00:23:03,360 --> 00:23:06,880
clients testing the stuff five month

626
00:23:06,880 --> 00:23:08,000
five

627
00:23:08,000 --> 00:23:10,960
sorry so one that was really interesting

628
00:23:10,960 --> 00:23:13,360
was the daniel of serbia the nail of

629
00:23:13,360 --> 00:23:15,760
service infinite processing of

630
00:23:15,760 --> 00:23:16,640
one

631
00:23:16,640 --> 00:23:19,760
basically ssd block and after that a

632
00:23:19,760 --> 00:23:21,840
bunch of exceptions that was not handled

633
00:23:21,840 --> 00:23:24,320
directly by the by the program or by the

634
00:23:24,320 --> 00:23:26,799
cli

635
00:23:27,679 --> 00:23:29,520
in term of coverage guided fuzzing it

636
00:23:29,520 --> 00:23:31,679
was a bit more messy

637
00:23:31,679 --> 00:23:34,400
maybe some of you heard about jaser

638
00:23:34,400 --> 00:23:35,360
that is

639
00:23:35,360 --> 00:23:38,080
really famous right now but at the time

640
00:23:38,080 --> 00:23:40,640
it was not available so basically the

641
00:23:40,640 --> 00:23:43,120
only stuff available for me at this time

642
00:23:43,120 --> 00:23:45,600
was gqf plus afl

643
00:23:45,600 --> 00:23:48,000
so i don't know if you ever try it

644
00:23:48,000 --> 00:23:50,640
but it's really really really slow i

645
00:23:50,640 --> 00:23:52,400
mean

646
00:23:52,400 --> 00:23:55,360
not really useful so that's why um

647
00:23:55,360 --> 00:23:57,760
i only find one bug with that

648
00:23:57,760 --> 00:23:59,760
it's not because there is no bugs it's

649
00:23:59,760 --> 00:24:01,440
basically because it's taking so much

650
00:24:01,440 --> 00:24:03,200
time to further that

651
00:24:03,200 --> 00:24:04,559
i mean i was

652
00:24:04,559 --> 00:24:06,559
just not finding anything else and and

653
00:24:06,559 --> 00:24:07,840
getting i don't know a thousand

654
00:24:07,840 --> 00:24:10,240
execution per per hour or something like

655
00:24:10,240 --> 00:24:13,039
that even less so

656
00:24:13,039 --> 00:24:15,600
as i'm as you might know fuzzing speed

657
00:24:15,600 --> 00:24:18,080
is kind of important and especially when

658
00:24:18,080 --> 00:24:20,080
you're dealing with this kind of stuff

659
00:24:20,080 --> 00:24:21,200
in that case

660
00:24:21,200 --> 00:24:24,000
so definitely some improvement possible

661
00:24:24,000 --> 00:24:25,840
at this time

662
00:24:25,840 --> 00:24:27,840
of the of the

663
00:24:27,840 --> 00:24:29,760
of the project and it was basically find

664
00:24:29,760 --> 00:24:32,799
another way to first java code

665
00:24:32,799 --> 00:24:35,279
last one lot star i'm gonna be quick

666
00:24:35,279 --> 00:24:37,760
there is gs first really useful really

667
00:24:37,760 --> 00:24:40,080
simple to use that's the rns i mean it's

668
00:24:40,080 --> 00:24:43,520
difficult to to be more simple than that

669
00:24:43,520 --> 00:24:45,200
basically you are just launching the

670
00:24:45,200 --> 00:24:47,039
stuff i have not done any dumb fuzzing

671
00:24:47,039 --> 00:24:49,039
because just implementing coverage grade

672
00:24:49,039 --> 00:24:51,120
diffusing in that case was already

673
00:24:51,120 --> 00:24:53,600
way way much simpler

674
00:24:53,600 --> 00:24:55,840
so in that case seven bang

675
00:24:55,840 --> 00:24:58,000
oh sorry seven bugs

676
00:24:58,000 --> 00:25:01,440
found mainly type error ranger

677
00:25:01,440 --> 00:25:04,400
but either the ssd decoding or other

678
00:25:04,400 --> 00:25:06,480
some networking stuff you can see some

679
00:25:06,480 --> 00:25:07,679
enr

680
00:25:07,679 --> 00:25:10,000
string right there and for example this

681
00:25:10,000 --> 00:25:12,080
one are basically like the

682
00:25:12,080 --> 00:25:14,080
the proof of concept to just reproduce

683
00:25:14,080 --> 00:25:15,919
the bug so as you can see it was not

684
00:25:15,919 --> 00:25:18,159
really complicated

685
00:25:18,159 --> 00:25:20,480
so that was nice so basically all of

686
00:25:20,480 --> 00:25:22,799
that of the all this coverage guided

687
00:25:22,799 --> 00:25:24,880
fuzzing leads to this result so at the

688
00:25:24,880 --> 00:25:29,279
end 26 bug funds so far 10 of them using

689
00:25:29,279 --> 00:25:31,760
just dumb fuzzing just replaying

690
00:25:31,760 --> 00:25:34,799
existing physical power and 16 of them

691
00:25:34,799 --> 00:25:36,320
using coverage guided fuzzing i mean

692
00:25:36,320 --> 00:25:39,520
generated by the coverage guided further

693
00:25:39,520 --> 00:25:41,919
so the pros are pretty simple i mean

694
00:25:41,919 --> 00:25:42,880
it's

695
00:25:42,880 --> 00:25:45,360
it was really efficient in terms of

696
00:25:45,360 --> 00:25:47,039
ratio like the

697
00:25:47,039 --> 00:25:49,679
bugs compared to the time i spend on

698
00:25:49,679 --> 00:25:50,480
that

699
00:25:50,480 --> 00:25:52,720
for most most of them

700
00:25:52,720 --> 00:25:53,520
and

701
00:25:53,520 --> 00:25:55,200
the really good part is that coverage

702
00:25:55,200 --> 00:25:57,200
guided fuzzing basically

703
00:25:57,200 --> 00:26:00,159
produce reusable and interesting corpora

704
00:26:00,159 --> 00:26:02,720
that you can just reuse over time and

705
00:26:02,720 --> 00:26:04,640
it's not just specific for blockchain to

706
00:26:04,640 --> 00:26:06,720
be honest i mean you should whatever the

707
00:26:06,720 --> 00:26:08,640
library you are facing i'm pretty sure

708
00:26:08,640 --> 00:26:11,120
there is multiple implementation of it

709
00:26:11,120 --> 00:26:13,200
and i don't know you are using

710
00:26:13,200 --> 00:26:15,840
let's say lip png so okay you are using

711
00:26:15,840 --> 00:26:18,320
lip edging you will generate some png

712
00:26:18,320 --> 00:26:21,120
picture but there is not only one parser

713
00:26:21,120 --> 00:26:23,279
of png you have some other one written

714
00:26:23,279 --> 00:26:26,000
in other language and so on so if you

715
00:26:26,000 --> 00:26:28,320
are facing a project it can make sense

716
00:26:28,320 --> 00:26:30,559
for you to just give it a try and just

717
00:26:30,559 --> 00:26:32,559
provide your corpora

718
00:26:32,559 --> 00:26:35,679
to other library and see if it's if it's

719
00:26:35,679 --> 00:26:38,000
finding any bugs i mean the corporate is

720
00:26:38,000 --> 00:26:41,520
the key in in that case

721
00:26:41,520 --> 00:26:43,760
the good part also was basically what i

722
00:26:43,760 --> 00:26:45,360
mentioned they all follow the same

723
00:26:45,360 --> 00:26:47,679
specification so really easy to for me

724
00:26:47,679 --> 00:26:49,919
to just switch from one code base to to

725
00:26:49,919 --> 00:26:53,120
the other and in term of unique bugs and

726
00:26:53,120 --> 00:26:55,039
so on as you can see it was mainly like

727
00:26:55,039 --> 00:26:57,760
lotstar nimbus and tequi that was

728
00:26:57,760 --> 00:27:00,880
containing bugs at this time and

729
00:27:00,880 --> 00:27:03,200
you will see that but it was mainly on

730
00:27:03,200 --> 00:27:05,279
ssd decoding

731
00:27:05,279 --> 00:27:08,960
stuff so decoding is hard

732
00:27:08,960 --> 00:27:11,039
so the cons

733
00:27:11,039 --> 00:27:12,159
i mean

734
00:27:12,159 --> 00:27:14,720
in that case i was mainly dependent of

735
00:27:14,720 --> 00:27:15,600
the

736
00:27:15,600 --> 00:27:17,360
different coverage guided further

737
00:27:17,360 --> 00:27:18,960
available for me

738
00:27:18,960 --> 00:27:21,360
so as i mentioned for teq it was a bit

739
00:27:21,360 --> 00:27:26,240
hard because basically java and gqf afl

740
00:27:26,240 --> 00:27:29,360
and so on so it was kind of messy

741
00:27:29,360 --> 00:27:32,080
also the cryptographic bls nature stuff

742
00:27:32,080 --> 00:27:33,520
could have been

743
00:27:33,520 --> 00:27:35,440
an issue it had been at the beginning

744
00:27:35,440 --> 00:27:37,520
but after that as i mentioned they

745
00:27:37,520 --> 00:27:39,600
developed a new verify stuff like they

746
00:27:39,600 --> 00:27:42,000
allow me to just

747
00:27:42,000 --> 00:27:44,480
bypass this part of the stuff and it was

748
00:27:44,480 --> 00:27:46,960
increasing the coverage a lot at this

749
00:27:46,960 --> 00:27:49,840
point um difficult to detect logic bugs

750
00:27:49,840 --> 00:27:52,240
of course because i'm i'm leveraging on

751
00:27:52,240 --> 00:27:53,760
the fact that the coverage guided

752
00:27:53,760 --> 00:27:55,760
further will basically tell me there is

753
00:27:55,760 --> 00:27:58,159
a crash but i mean logic bugs

754
00:27:58,159 --> 00:27:59,679
most of the time will not lead to a

755
00:27:59,679 --> 00:28:00,799
crash

756
00:28:00,799 --> 00:28:03,760
so that's the the issue and finally time

757
00:28:03,760 --> 00:28:05,600
consuming because i need to write all

758
00:28:05,600 --> 00:28:08,640
the fading harness myself and

759
00:28:08,640 --> 00:28:11,760
test do the testing running and so on so

760
00:28:11,760 --> 00:28:14,000
not also the most

761
00:28:14,000 --> 00:28:15,679
appealing stuff

762
00:28:15,679 --> 00:28:17,600
of the day

763
00:28:17,600 --> 00:28:19,840
so let's right now take a look of

764
00:28:19,840 --> 00:28:22,480
basically the other tool i create based

765
00:28:22,480 --> 00:28:24,720
on that so i was working on this stuff

766
00:28:24,720 --> 00:28:26,720
implementing my my stuff and so on and

767
00:28:26,720 --> 00:28:29,120
so on and after some time i decided that

768
00:28:29,120 --> 00:28:30,559
it could be really interesting to

769
00:28:30,559 --> 00:28:32,960
basically as you saw the

770
00:28:32,960 --> 00:28:35,120
dumb fuzzing was basically reusing the

771
00:28:35,120 --> 00:28:37,440
the different toolings and command line

772
00:28:37,440 --> 00:28:39,840
tools available so i just create like a

773
00:28:39,840 --> 00:28:41,039
really basic

774
00:28:41,039 --> 00:28:43,200
program in rust and you can even do that

775
00:28:43,200 --> 00:28:45,360
in in bash that will basically take an

776
00:28:45,360 --> 00:28:47,360
input provide that to the to the

777
00:28:47,360 --> 00:28:50,159
different cli tool and just take a look

778
00:28:50,159 --> 00:28:53,279
at the output if it's like crashing not

779
00:28:53,279 --> 00:28:56,480
crashing if it's like passing properly

780
00:28:56,480 --> 00:28:58,799
getting some error or not and just

781
00:28:58,799 --> 00:29:01,520
comparing the output of all those tools

782
00:29:01,520 --> 00:29:03,919
it was really easy to implement i mean i

783
00:29:03,919 --> 00:29:05,360
just need to

784
00:29:05,360 --> 00:29:07,600
basically compile all the stuff into

785
00:29:07,600 --> 00:29:10,000
some dockers and after that extract all

786
00:29:10,000 --> 00:29:12,480
the command line tool run them in

787
00:29:12,480 --> 00:29:16,000
parallel and just compare the wizard

788
00:29:16,000 --> 00:29:18,640
so that stuff was as i mentioned really

789
00:29:18,640 --> 00:29:21,760
easy but i only found one bug with it so

790
00:29:21,760 --> 00:29:23,919
the main question could be is it really

791
00:29:23,919 --> 00:29:25,919
useful is it really worth it to spend

792
00:29:25,919 --> 00:29:28,799
some time for that and the answer is yes

793
00:29:28,799 --> 00:29:31,120
of course because what i've done is

794
00:29:31,120 --> 00:29:34,399
basically having a way for me to

795
00:29:34,399 --> 00:29:37,440
get for one input all the output of all

796
00:29:37,440 --> 00:29:40,159
the clients so for debugging later you

797
00:29:40,159 --> 00:29:41,840
will see that it was basically one of

798
00:29:41,840 --> 00:29:44,640
the most useful tool for me because when

799
00:29:44,640 --> 00:29:46,720
you are dealing with logic bugs

800
00:29:46,720 --> 00:29:48,640
it's in that case really important to

801
00:29:48,640 --> 00:29:50,640
know if

802
00:29:50,640 --> 00:29:51,600
your

803
00:29:51,600 --> 00:29:53,919
the main target you are focusing is it

804
00:29:53,919 --> 00:29:56,320
the one that is buggy or and is it like

805
00:29:56,320 --> 00:29:58,000
all the the other ones that are doing

806
00:29:58,000 --> 00:30:00,880
the stuff right or is it the opposite

807
00:30:00,880 --> 00:30:03,679
so that's the kind of tooling that in

808
00:30:03,679 --> 00:30:06,320
that case makes the the more sense

809
00:30:06,320 --> 00:30:08,399
the cons of course i mean it's not a

810
00:30:08,399 --> 00:30:10,799
further that's basically just like a

811
00:30:10,799 --> 00:30:13,200
replayer or a common basic command line

812
00:30:13,200 --> 00:30:16,320
tool or script um so i mean except i

813
00:30:16,320 --> 00:30:18,000
mean you need to provide some input and

814
00:30:18,000 --> 00:30:20,640
the input are not coming from

815
00:30:20,640 --> 00:30:22,640
i mean are coming from somewhere so at

816
00:30:22,640 --> 00:30:24,880
some point you you need to have input as

817
00:30:24,880 --> 00:30:26,240
well

818
00:30:26,240 --> 00:30:28,960
so that leads me to the biggest part of

819
00:30:28,960 --> 00:30:30,880
the project that was basically the

820
00:30:30,880 --> 00:30:33,360
differential further um so we call it

821
00:30:33,360 --> 00:30:37,279
beacon first v2 and the main idea was to

822
00:30:37,279 --> 00:30:40,080
find logic bugs that's the only goals

823
00:30:40,080 --> 00:30:42,000
for us with this

824
00:30:42,000 --> 00:30:44,320
this piece of software we are not

825
00:30:44,320 --> 00:30:46,720
expecting expecting to get crashes and

826
00:30:46,720 --> 00:30:48,559
so on because

827
00:30:48,559 --> 00:30:50,720
if you remember we already have eth2

828
00:30:50,720 --> 00:30:52,399
first for that and i mean when i was

829
00:30:52,399 --> 00:30:54,320
developing the stuff eth2 first was

830
00:30:54,320 --> 00:30:56,559
still running on some server and

831
00:30:56,559 --> 00:30:59,360
eth2diff was using only use for like

832
00:30:59,360 --> 00:31:01,840
debugging and so on so if there is any

833
00:31:01,840 --> 00:31:04,559
bugs hopefully i mean crushing bugs it

834
00:31:04,559 --> 00:31:07,120
was already catch by eth2 first or it

835
00:31:07,120 --> 00:31:08,799
will be in the future so

836
00:31:08,799 --> 00:31:10,720
it's not really the most important

837
00:31:10,720 --> 00:31:12,640
what was really important in that case

838
00:31:12,640 --> 00:31:15,600
was to leverage the fact that we can use

839
00:31:15,600 --> 00:31:17,440
structural fuzzing and

840
00:31:17,440 --> 00:31:19,760
the really important part with that is

841
00:31:19,760 --> 00:31:21,840
as i mentioned before that we was

842
00:31:21,840 --> 00:31:25,440
basically generating ssd object

843
00:31:25,440 --> 00:31:29,360
that was then decode and then process

844
00:31:29,360 --> 00:31:31,039
the main idea with structural fuzzing

845
00:31:31,039 --> 00:31:33,519
will be to simplify the stuff and only

846
00:31:33,519 --> 00:31:35,679
generate valid structure

847
00:31:35,679 --> 00:31:37,519
directly at the beginning so we don't

848
00:31:37,519 --> 00:31:40,559
have the ssd decoding process anymore

849
00:31:40,559 --> 00:31:43,440
and we are only valid creating some

850
00:31:43,440 --> 00:31:45,840
valid structure i mean valid in the in

851
00:31:45,840 --> 00:31:47,919
the format maybe not on the content

852
00:31:47,919 --> 00:31:50,559
inside but at least we are generating

853
00:31:50,559 --> 00:31:51,279
and

854
00:31:51,279 --> 00:31:54,559
simplifying a lot the the process

855
00:31:54,559 --> 00:31:56,720
so in term of complexity this one was i

856
00:31:56,720 --> 00:32:00,240
would say medium hard

857
00:32:00,240 --> 00:32:03,039
because it's depending which client you

858
00:32:03,039 --> 00:32:05,440
need to deal with and which language

859
00:32:05,440 --> 00:32:06,720
especially

860
00:32:06,720 --> 00:32:07,679
because

861
00:32:07,679 --> 00:32:09,840
we have the structural fuzzing so for

862
00:32:09,840 --> 00:32:12,080
that i've used rust i will discuss

863
00:32:12,080 --> 00:32:14,159
that right after and after that you have

864
00:32:14,159 --> 00:32:16,559
the old ffi bindings and the main

865
00:32:16,559 --> 00:32:19,039
question is what is happening if the

866
00:32:19,039 --> 00:32:22,559
language is not really

867
00:32:23,679 --> 00:32:25,760
like easy to use to create like share

868
00:32:25,760 --> 00:32:28,159
libraries that can be used later with

869
00:32:28,159 --> 00:32:30,480
ffi bindings and that's that was

870
00:32:30,480 --> 00:32:32,559
basically what happened and of course a

871
00:32:32,559 --> 00:32:34,880
lot of manual writing and compilation

872
00:32:34,880 --> 00:32:37,279
process i mean compilation is the worst

873
00:32:37,279 --> 00:32:38,799
in this kind of

874
00:32:38,799 --> 00:32:40,720
project

875
00:32:40,720 --> 00:32:42,720
so let's take a look uh at the

876
00:32:42,720 --> 00:32:44,559
architecture of beacon first so that's

877
00:32:44,559 --> 00:32:46,480
basically what i mentioned

878
00:32:46,480 --> 00:32:49,039
my main goal in that case is to generate

879
00:32:49,039 --> 00:32:49,919
uh

880
00:32:49,919 --> 00:32:52,880
at sorry at the station uh so using

881
00:32:52,880 --> 00:32:54,880
structural fuzzing so in that case i've

882
00:32:54,880 --> 00:32:57,279
used um as a

883
00:32:57,279 --> 00:32:59,120
main project

884
00:32:59,120 --> 00:33:01,039
lighthouse because the further is

885
00:33:01,039 --> 00:33:02,960
written in rust and lighthouse in rest

886
00:33:02,960 --> 00:33:04,960
as well and we can leverage on what we

887
00:33:04,960 --> 00:33:07,919
call the arbitrary trait that is a

888
00:33:07,919 --> 00:33:11,120
really simple way to basically generate

889
00:33:11,120 --> 00:33:14,399
some object using a rust so really

890
00:33:14,399 --> 00:33:16,960
useful really efficient so once we get

891
00:33:16,960 --> 00:33:19,360
this attestation i will basically do

892
00:33:19,360 --> 00:33:22,960
some ssd encoding and

893
00:33:22,960 --> 00:33:24,799
the main idea

894
00:33:24,799 --> 00:33:27,360
is because when i will communicate with

895
00:33:27,360 --> 00:33:29,919
this one

896
00:33:29,919 --> 00:33:31,840
they are written in another language

897
00:33:31,840 --> 00:33:34,240
than rest and that also means that maybe

898
00:33:34,240 --> 00:33:36,240
the memory mapping inside will not be

899
00:33:36,240 --> 00:33:38,399
the same so it's not possible for me to

900
00:33:38,399 --> 00:33:39,200
just

901
00:33:39,200 --> 00:33:41,360
create an attestation put that in some

902
00:33:41,360 --> 00:33:43,519
chunk of memory and just tell to the

903
00:33:43,519 --> 00:33:46,399
other guy okay access to this one and it

904
00:33:46,399 --> 00:33:48,480
will be your structure and yeah don't

905
00:33:48,480 --> 00:33:50,559
worry it's gonna be okay

906
00:33:50,559 --> 00:33:52,480
it's not possible so what i've done is

907
00:33:52,480 --> 00:33:53,600
basically

908
00:33:53,600 --> 00:33:56,320
convert that into a ssd object that is

909
00:33:56,320 --> 00:33:58,080
cross-compatible against all the

910
00:33:58,080 --> 00:34:00,320
implementation and after that i provide

911
00:34:00,320 --> 00:34:03,120
that to the different other clients they

912
00:34:03,120 --> 00:34:05,039
have done the decoding so of course we

913
00:34:05,039 --> 00:34:07,360
are wasting a bit of time but that's

914
00:34:07,360 --> 00:34:10,320
okay and then at this point in time

915
00:34:10,320 --> 00:34:12,879
everyone got the same object following

916
00:34:12,879 --> 00:34:15,679
the same specification and containing

917
00:34:15,679 --> 00:34:18,480
the exact same data on it so what i can

918
00:34:18,480 --> 00:34:19,918
then do is

919
00:34:19,918 --> 00:34:21,599
do all the

920
00:34:21,599 --> 00:34:23,040
the processing

921
00:34:23,040 --> 00:34:27,280
of those object and do the complete

922
00:34:27,280 --> 00:34:30,239
state processing and after that at the

923
00:34:30,239 --> 00:34:33,040
end i will just output the result and

924
00:34:33,040 --> 00:34:36,719
the output result could be either the um

925
00:34:36,719 --> 00:34:39,599
the new state of the blockchain or

926
00:34:39,599 --> 00:34:42,480
either it will be just

927
00:34:42,480 --> 00:34:43,520
like

928
00:34:43,520 --> 00:34:44,960
they got an error

929
00:34:44,960 --> 00:34:46,719
it's not possible it's like an invalid

930
00:34:46,719 --> 00:34:49,520
state or invalid object and so on so i

931
00:34:49,520 --> 00:34:52,320
can detect in that case logic bugs at

932
00:34:52,320 --> 00:34:54,879
multiple levels i can detect at this

933
00:34:54,879 --> 00:34:57,599
level if they are not able to decode an

934
00:34:57,599 --> 00:35:00,240
object that is actually a valid object

935
00:35:00,240 --> 00:35:03,119
i can detect at this point

936
00:35:03,119 --> 00:35:04,880
that they are trying to do the

937
00:35:04,880 --> 00:35:06,960
processing and they are failing to the

938
00:35:06,960 --> 00:35:09,760
processing of this valid object against

939
00:35:09,760 --> 00:35:11,920
something else or i mean very

940
00:35:11,920 --> 00:35:14,640
succeed or fail in that case

941
00:35:14,640 --> 00:35:17,200
and the last one is i can

942
00:35:17,200 --> 00:35:19,359
check what is the output result and

943
00:35:19,359 --> 00:35:21,680
verify that the output result is always

944
00:35:21,680 --> 00:35:24,320
the same against all implementation

945
00:35:24,320 --> 00:35:26,560
so we have a really good granular

946
00:35:26,560 --> 00:35:30,240
granularity on that and

947
00:35:30,240 --> 00:35:32,079
of course the main question is

948
00:35:32,079 --> 00:35:34,320
is it possible to find bugs with that

949
00:35:34,320 --> 00:35:36,880
and the result is yes so in that case we

950
00:35:36,880 --> 00:35:38,960
succeeded to find six bugs

951
00:35:38,960 --> 00:35:40,880
mainly in prison

952
00:35:40,880 --> 00:35:42,060
and it was

953
00:35:42,060 --> 00:35:43,280
[Music]

954
00:35:43,280 --> 00:35:45,599
really like logic bugs it was incorrect

955
00:35:45,599 --> 00:35:49,520
validation um no verification of some

956
00:35:49,520 --> 00:35:53,359
index or subpart of the structure um

957
00:35:53,359 --> 00:35:56,560
mainly like one client on that prism was

958
00:35:56,560 --> 00:35:58,720
maybe validating the state or creating

959
00:35:58,720 --> 00:36:00,560
an output state when all the other one

960
00:36:00,560 --> 00:36:02,800
was basically rejecting the stuff and so

961
00:36:02,800 --> 00:36:04,000
on and so on

962
00:36:04,000 --> 00:36:06,640
so that was really interesting and

963
00:36:06,640 --> 00:36:09,040
i mean in terms of results as i

964
00:36:09,040 --> 00:36:11,680
mentioned all those bugs basically are

965
00:36:11,680 --> 00:36:14,320
consensus bugs that mean

966
00:36:14,320 --> 00:36:17,520
the kind of one of the most critical for

967
00:36:17,520 --> 00:36:19,040
blockchain software

968
00:36:19,040 --> 00:36:20,960
so good result

969
00:36:20,960 --> 00:36:23,280
i mean the only downside could be maybe

970
00:36:23,280 --> 00:36:24,320
the speed

971
00:36:24,320 --> 00:36:26,960
because i mean there is a lot of essays

972
00:36:26,960 --> 00:36:29,119
encoding making all the stuff working

973
00:36:29,119 --> 00:36:32,400
together and of course the

974
00:36:32,400 --> 00:36:33,920
most

975
00:36:33,920 --> 00:36:36,160
issue is basically that it's taking a

976
00:36:36,160 --> 00:36:38,720
long long time to write all the bindings

977
00:36:38,720 --> 00:36:41,119
all the stuff and especially the

978
00:36:41,119 --> 00:36:43,440
compilation you need to compile some

979
00:36:43,440 --> 00:36:46,000
share library for all the projects and

980
00:36:46,000 --> 00:36:48,800
just run them together and hope it will

981
00:36:48,800 --> 00:36:50,160
work and if

982
00:36:50,160 --> 00:36:54,320
one guy one team is basically using

983
00:36:54,320 --> 00:36:56,480
updating too fast or not using the same

984
00:36:56,480 --> 00:36:58,960
specification version it will always

985
00:36:58,960 --> 00:37:00,640
fail because you will always get some

986
00:37:00,640 --> 00:37:02,320
different result than the other one so

987
00:37:02,320 --> 00:37:04,160
you also need to be sure they are all

988
00:37:04,160 --> 00:37:05,839
following the same specification at the

989
00:37:05,839 --> 00:37:08,880
same time

990
00:37:08,880 --> 00:37:11,200
so let me conclude and give you like a

991
00:37:11,200 --> 00:37:12,800
big overview of the complete project

992
00:37:12,800 --> 00:37:15,280
that was basically all those tools

993
00:37:15,280 --> 00:37:18,160
so at the end 33 bugs almost all

994
00:37:18,160 --> 00:37:20,800
critical as i mentioned

995
00:37:20,800 --> 00:37:22,800
so that's the like the

996
00:37:22,800 --> 00:37:25,440
the total number as you can see most of

997
00:37:25,440 --> 00:37:29,200
them was like prism nimbus tiku um

998
00:37:29,200 --> 00:37:31,200
lotstar as you can see it's only seven

999
00:37:31,200 --> 00:37:33,520
uh and i've not mentioned anything about

1000
00:37:33,520 --> 00:37:35,599
lovestar or regarding the differential

1001
00:37:35,599 --> 00:37:37,119
fuzzing and so on

1002
00:37:37,119 --> 00:37:39,280
the main reason of that is at the time i

1003
00:37:39,280 --> 00:37:40,400
was

1004
00:37:40,400 --> 00:37:43,520
lost the los satum was a bit late in

1005
00:37:43,520 --> 00:37:46,000
terms of developing and and following

1006
00:37:46,000 --> 00:37:47,280
the same

1007
00:37:47,280 --> 00:37:49,599
versioning of the specification than the

1008
00:37:49,599 --> 00:37:52,640
other so it was not useful to to add

1009
00:37:52,640 --> 00:37:54,800
them to the differential thing but it's

1010
00:37:54,800 --> 00:37:56,480
not the case anymore

1011
00:37:56,480 --> 00:37:59,200
also something we have done

1012
00:37:59,200 --> 00:38:00,960
we have done the community fuzzing so

1013
00:38:00,960 --> 00:38:02,400
basically

1014
00:38:02,400 --> 00:38:05,200
i put everything into a docker

1015
00:38:05,200 --> 00:38:07,920
and i basically we basically just ask

1016
00:38:07,920 --> 00:38:10,400
people to run the docker and try to find

1017
00:38:10,400 --> 00:38:11,599
bugs for us

1018
00:38:11,599 --> 00:38:14,240
and if they succeed they just report the

1019
00:38:14,240 --> 00:38:16,480
stuff to the github and after that we

1020
00:38:16,480 --> 00:38:18,880
communicate to all the teams and that's

1021
00:38:18,880 --> 00:38:19,760
okay

1022
00:38:19,760 --> 00:38:21,520
so

1023
00:38:21,520 --> 00:38:23,520
that was really efficient

1024
00:38:23,520 --> 00:38:26,560
and it was really nice to just make my

1025
00:38:26,560 --> 00:38:30,079
father run on everyone's laptop

1026
00:38:30,079 --> 00:38:31,920
it's only possible if you are dealing

1027
00:38:31,920 --> 00:38:34,000
with something that is not production

1028
00:38:34,000 --> 00:38:35,920
ready in that case it was under

1029
00:38:35,920 --> 00:38:38,320
development um if you are familiar with

1030
00:38:38,320 --> 00:38:40,640
the current evolution know there is

1031
00:38:40,640 --> 00:38:43,599
already like a kind of a main net for

1032
00:38:43,599 --> 00:38:45,200
that that is running

1033
00:38:45,200 --> 00:38:47,359
it will not be something that we will do

1034
00:38:47,359 --> 00:38:49,680
again right now if it was possible i

1035
00:38:49,680 --> 00:38:52,000
mean it's too impactful if there is any

1036
00:38:52,000 --> 00:38:53,359
bugs that are just

1037
00:38:53,359 --> 00:38:57,359
found and not reported directly by us

1038
00:38:57,359 --> 00:38:59,359
the main difficulty of this project was

1039
00:38:59,359 --> 00:39:03,280
basically keeping everything up to date

1040
00:39:03,280 --> 00:39:05,839
as i mentioned specification team

1041
00:39:05,839 --> 00:39:07,200
language

1042
00:39:07,200 --> 00:39:08,480
and so on

1043
00:39:08,480 --> 00:39:10,480
kind of eevee stuff

1044
00:39:10,480 --> 00:39:12,960
and i'm doing fuzzing so basically i'm

1045
00:39:12,960 --> 00:39:14,800
trying to find bugs on all the parts of

1046
00:39:14,800 --> 00:39:16,079
the code

1047
00:39:16,079 --> 00:39:18,880
and it was

1048
00:39:18,880 --> 00:39:21,119
painful for the compilation part

1049
00:39:21,119 --> 00:39:22,640
i will say

1050
00:39:22,640 --> 00:39:24,560
in term of impacts that's also really

1051
00:39:24,560 --> 00:39:26,720
interesting because at the end we found

1052
00:39:26,720 --> 00:39:30,079
like 23 crush and panics and as you can

1053
00:39:30,079 --> 00:39:33,920
see we found like seven logic bugs so

1054
00:39:33,920 --> 00:39:37,200
if at some point i was only focused on

1055
00:39:37,200 --> 00:39:39,920
doing coverage guided fuzzing um like

1056
00:39:39,920 --> 00:39:41,920
eth2 first

1057
00:39:41,920 --> 00:39:44,320
i will basically have missed a bunch of

1058
00:39:44,320 --> 00:39:47,119
bugs that are right there and

1059
00:39:47,119 --> 00:39:49,680
and most of them especially the logic

1060
00:39:49,680 --> 00:39:53,200
one are definitely critical in that case

1061
00:39:53,200 --> 00:39:55,760
so it's really interesting to see that

1062
00:39:55,760 --> 00:39:58,800
even if it's take the more time

1063
00:39:58,800 --> 00:40:00,960
it will lead you to increasing the

1064
00:40:00,960 --> 00:40:02,560
coverage and find

1065
00:40:02,560 --> 00:40:05,599
some stuff that will not have been found

1066
00:40:05,599 --> 00:40:07,520
except in production

1067
00:40:07,520 --> 00:40:08,560
and

1068
00:40:08,560 --> 00:40:11,760
that's the worst cases for us

1069
00:40:11,760 --> 00:40:13,040
lastly

1070
00:40:13,040 --> 00:40:14,160
i want to

1071
00:40:14,160 --> 00:40:16,000
give you a bit of take away and

1072
00:40:16,000 --> 00:40:18,960
statistic basically about that

1073
00:40:18,960 --> 00:40:20,400
for me

1074
00:40:20,400 --> 00:40:21,680
blockchain software are really

1075
00:40:21,680 --> 00:40:23,760
interesting

1076
00:40:23,760 --> 00:40:26,640
i mean you have a bunch of concepts that

1077
00:40:26,640 --> 00:40:28,240
are really interesting

1078
00:40:28,240 --> 00:40:29,040
and

1079
00:40:29,040 --> 00:40:32,160
you have as you saw the networking stack

1080
00:40:32,160 --> 00:40:33,920
the

1081
00:40:33,920 --> 00:40:36,319
everything regarding logic that

1082
00:40:36,319 --> 00:40:38,640
maybe in other kinds of software are not

1083
00:40:38,640 --> 00:40:40,560
as critical and so on so really

1084
00:40:40,560 --> 00:40:43,440
interesting definitely

1085
00:40:43,440 --> 00:40:45,280
you don't need to have complex further

1086
00:40:45,280 --> 00:40:48,160
to find bugs i mean if you remember i

1087
00:40:48,160 --> 00:40:50,240
found a bunch of bugs by doing like

1088
00:40:50,240 --> 00:40:52,720
replaying the fuzzing corporate so

1089
00:40:52,720 --> 00:40:55,680
dumb fuzzing definitely

1090
00:40:55,680 --> 00:40:57,680
and if we take a look at

1091
00:40:57,680 --> 00:41:01,119
where this bug was as you can see

1092
00:41:01,119 --> 00:41:04,079
ssc decoding that was the main

1093
00:41:04,079 --> 00:41:08,000
source of bugs and

1094
00:41:08,000 --> 00:41:11,040
again decoding is always hard

1095
00:41:11,040 --> 00:41:12,560
and in that case

1096
00:41:12,560 --> 00:41:14,640
all many all those bugs was basically

1097
00:41:14,640 --> 00:41:17,119
just one with them further so it was

1098
00:41:17,119 --> 00:41:20,160
already some good state after that some

1099
00:41:20,160 --> 00:41:21,760
networking stuff and some state

1100
00:41:21,760 --> 00:41:24,319
processing bug as well

1101
00:41:24,319 --> 00:41:27,520
differential e fuzzing is really an

1102
00:41:27,520 --> 00:41:29,520
extremely powerful to find logic box for

1103
00:41:29,520 --> 00:41:32,000
me it's the best way you can do it and i

1104
00:41:32,000 --> 00:41:34,079
really invite you to take a look at the

1105
00:41:34,079 --> 00:41:36,319
crypto first project of guido

1106
00:41:36,319 --> 00:41:37,599
and you will see that it's running on

1107
00:41:37,599 --> 00:41:41,280
oss first and it just found i think more

1108
00:41:41,280 --> 00:41:43,040
than 100

1109
00:41:43,040 --> 00:41:46,160
logic bugs in crypto implementation and

1110
00:41:46,160 --> 00:41:47,599
so on so

1111
00:41:47,599 --> 00:41:49,520
it's not a subject that is discussed a

1112
00:41:49,520 --> 00:41:52,160
lot uh and i think it's a bit bad we

1113
00:41:52,160 --> 00:41:53,680
start to see some differential fuzzing

1114
00:41:53,680 --> 00:41:55,760
also like in in browser especially with

1115
00:41:55,760 --> 00:41:56,480
like

1116
00:41:56,480 --> 00:41:59,520
jit compilation and jit output

1117
00:41:59,520 --> 00:42:01,680
but definitely i think it will be the

1118
00:42:01,680 --> 00:42:04,480
one of the next few things if you can

1119
00:42:04,480 --> 00:42:06,880
try to implement that and it could be

1120
00:42:06,880 --> 00:42:08,480
really

1121
00:42:08,480 --> 00:42:09,680
valuable

1122
00:42:09,680 --> 00:42:11,839
for the future of the project

1123
00:42:11,839 --> 00:42:15,680
by the time we remove all the gql afl

1124
00:42:15,680 --> 00:42:18,880
for offering java java code and we was

1125
00:42:18,880 --> 00:42:20,880
using jazer

1126
00:42:20,880 --> 00:42:22,720
it's already in production it's spanning

1127
00:42:22,720 --> 00:42:25,359
bugs so that's nice we continue to

1128
00:42:25,359 --> 00:42:28,000
improve the target and so on continue to

1129
00:42:28,000 --> 00:42:30,240
find some bugs i think we have like 10

1130
00:42:30,240 --> 00:42:32,960
or 12 more bugs right now on may on also

1131
00:42:32,960 --> 00:42:35,119
the different other phase of a term 2.0

1132
00:42:35,119 --> 00:42:36,319
basically

1133
00:42:36,319 --> 00:42:39,920
and um yeah we just update also all the

1134
00:42:39,920 --> 00:42:43,119
fuzzing analyses and we actually also uh

1135
00:42:43,119 --> 00:42:44,400
just

1136
00:42:44,400 --> 00:42:46,240
follow the specification so at some

1137
00:42:46,240 --> 00:42:48,319
point the specification right now it is

1138
00:42:48,319 --> 00:42:50,960
choosing a snappy that is another

1139
00:42:50,960 --> 00:42:52,160
encoding

1140
00:42:52,160 --> 00:42:54,000
format and

1141
00:42:54,000 --> 00:42:56,240
so we are again doing some fuzzing on

1142
00:42:56,240 --> 00:42:58,319
this other part of the code and finding

1143
00:42:58,319 --> 00:42:59,359
bugs

1144
00:42:59,359 --> 00:43:00,720
in that as well

1145
00:43:00,720 --> 00:43:02,160
the last

1146
00:43:02,160 --> 00:43:03,599
one is

1147
00:43:03,599 --> 00:43:07,040
the pi is basically

1148
00:43:07,440 --> 00:43:09,359
regarding phasing techniques

1149
00:43:09,359 --> 00:43:11,920
what was the most efficient

1150
00:43:11,920 --> 00:43:14,560
as you can see coverage guided is

1151
00:43:14,560 --> 00:43:16,800
a pretty good move but dumb fuzzing

1152
00:43:16,800 --> 00:43:20,240
actually perform really well so

1153
00:43:20,240 --> 00:43:23,119
don't just think okay

1154
00:43:23,119 --> 00:43:25,119
i'm new to fuzzing

1155
00:43:25,119 --> 00:43:28,560
i don't know how to compile and use

1156
00:43:28,560 --> 00:43:30,800
coverage guided further and so on

1157
00:43:30,800 --> 00:43:33,040
just give it a try and even some dumb

1158
00:43:33,040 --> 00:43:34,319
replayer

1159
00:43:34,319 --> 00:43:37,200
and i don't know i mean like using dev

1160
00:43:37,200 --> 00:43:38,319
slash dev

1161
00:43:38,319 --> 00:43:41,119
random can work sometime

1162
00:43:41,119 --> 00:43:43,520
not for that but it can

1163
00:43:43,520 --> 00:43:44,319
and

1164
00:43:44,319 --> 00:43:46,880
you can already have some good result

1165
00:43:46,880 --> 00:43:48,480
with that

1166
00:43:48,480 --> 00:43:50,410
thank you

1167
00:43:50,410 --> 00:43:57,839
[Applause]

1168
00:43:57,839 --> 00:43:59,920
you

