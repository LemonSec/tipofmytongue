1
00:00:00,480 --> 00:00:03,439
uh so yes today uh martin and i are

2
00:00:03,439 --> 00:00:05,279
going to be presenting some work we have

3
00:00:05,279 --> 00:00:06,319
been doing

4
00:00:06,319 --> 00:00:07,919
last year

5
00:00:07,919 --> 00:00:11,120
uh investigating the t of the samsung

6
00:00:11,120 --> 00:00:13,840
galaxy s21 of the exynos model and

7
00:00:13,840 --> 00:00:15,839
especially a component of this tea which

8
00:00:15,839 --> 00:00:18,480
is called the loadable firmer

9
00:00:18,480 --> 00:00:19,680
so

10
00:00:19,680 --> 00:00:21,039
why are we here

11
00:00:21,039 --> 00:00:22,000
well

12
00:00:22,000 --> 00:00:23,439
there's a couple of reasons why we're

13
00:00:23,439 --> 00:00:24,240
here

14
00:00:24,240 --> 00:00:25,840
and some more

15
00:00:25,840 --> 00:00:27,680
and a couple more

16
00:00:27,680 --> 00:00:29,119
and a few more

17
00:00:29,119 --> 00:00:29,840
and

18
00:00:29,840 --> 00:00:31,679
some more that are still uh in the

19
00:00:31,679 --> 00:00:33,360
disclosure process

20
00:00:33,360 --> 00:00:34,719
and we're going to talk about a couple

21
00:00:34,719 --> 00:00:36,640
of these things

22
00:00:36,640 --> 00:00:38,239
um so

23
00:00:38,239 --> 00:00:39,920
this is overview of what we're going to

24
00:00:39,920 --> 00:00:42,399
talking we're going to talk about

25
00:00:42,399 --> 00:00:44,239
we'll first have an introduction about

26
00:00:44,239 --> 00:00:46,480
teas and trust zone then we will be

27
00:00:46,480 --> 00:00:48,320
talking about the samsung's te

28
00:00:48,320 --> 00:00:50,160
architecture which is based on their own

29
00:00:50,160 --> 00:00:52,719
tos which is called tigris

30
00:00:52,719 --> 00:00:54,960
then we will be looking at loadable

31
00:00:54,960 --> 00:00:56,399
firmwares which is

32
00:00:56,399 --> 00:00:58,800
most of the analysis will present

33
00:00:58,800 --> 00:01:00,480
how we extracted them how we decrypted

34
00:01:00,480 --> 00:01:02,480
them and then how we found

35
00:01:02,480 --> 00:01:04,720
vulnerabilities inside these firmwares

36
00:01:04,720 --> 00:01:07,600
and how we exploited them

37
00:01:07,600 --> 00:01:08,880
so let's start with the introduction

38
00:01:08,880 --> 00:01:10,479
about about trusted execution

39
00:01:10,479 --> 00:01:13,200
environments this is like a trust zone

40
00:01:13,200 --> 00:01:14,880
centric view of

41
00:01:14,880 --> 00:01:16,240
tes

42
00:01:16,240 --> 00:01:18,159
where basically the

43
00:01:18,159 --> 00:01:20,000
environment is split between two worlds

44
00:01:20,000 --> 00:01:21,600
normal world which is the re rich

45
00:01:21,600 --> 00:01:23,119
execution environment and the secure

46
00:01:23,119 --> 00:01:25,200
world which is a te

47
00:01:25,200 --> 00:01:26,640
and in the normal world you have the

48
00:01:26,640 --> 00:01:29,040
usual applications and android

49
00:01:29,040 --> 00:01:30,640
environment running while in a secure

50
00:01:30,640 --> 00:01:33,119
world you'll have a tos which is runs a

51
00:01:33,119 --> 00:01:34,400
kernel

52
00:01:34,400 --> 00:01:36,560
several trusted applications

53
00:01:36,560 --> 00:01:39,360
which ultimately will protect keys

54
00:01:39,360 --> 00:01:41,759
such as payment keys file system

55
00:01:41,759 --> 00:01:43,840
encryption keys but also biometric data

56
00:01:43,840 --> 00:01:47,200
belonging to the user of the phone

57
00:01:48,000 --> 00:01:49,920
let's look at trustsome a bit more in

58
00:01:49,920 --> 00:01:51,600
detail we have this place between normal

59
00:01:51,600 --> 00:01:53,439
world and secure world that i just

60
00:01:53,439 --> 00:01:54,479
showed

61
00:01:54,479 --> 00:01:56,240
and then you see in the columns of

62
00:01:56,240 --> 00:01:57,759
different privilege levels defined by

63
00:01:57,759 --> 00:02:00,799
the arm architecture so we have el0 in

64
00:02:00,799 --> 00:02:02,640
both normal world and secure world which

65
00:02:02,640 --> 00:02:04,159
is the application level so it's the

66
00:02:04,159 --> 00:02:05,680
least privileged level

67
00:02:05,680 --> 00:02:07,119
then we have el1

68
00:02:07,119 --> 00:02:08,959
which is where the kernel run both the

69
00:02:08,959 --> 00:02:10,720
linux kernel and the tigris kernel in

70
00:02:10,720 --> 00:02:13,040
the secure world we have the hypervisor

71
00:02:13,040 --> 00:02:15,280
in the normal world and finally at el3

72
00:02:15,280 --> 00:02:17,280
which is the most privileged level we

73
00:02:17,280 --> 00:02:20,239
have bl-31 which is also called monitor

74
00:02:20,239 --> 00:02:22,080
code

75
00:02:22,080 --> 00:02:24,319
and this is some dedicated code that

76
00:02:24,319 --> 00:02:26,080
always runs in secure mode and handles

77
00:02:26,080 --> 00:02:29,680
the switching between the two worlds

78
00:02:30,239 --> 00:02:31,920
we see that

79
00:02:31,920 --> 00:02:33,840
the secure world is isolated part of the

80
00:02:33,840 --> 00:02:35,200
system so

81
00:02:35,200 --> 00:02:39,040
it has this ns bit scr fcr and s bit set

82
00:02:39,040 --> 00:02:41,519
to zero and has been known secure which

83
00:02:41,519 --> 00:02:43,200
means if a

84
00:02:43,200 --> 00:02:45,200
secure work performs operations over

85
00:02:45,200 --> 00:02:47,360
secure memory or secure peripherals so

86
00:02:47,360 --> 00:02:49,120
they will be allowed and if instead

87
00:02:49,120 --> 00:02:50,480
these operations come from a normal

88
00:02:50,480 --> 00:02:52,800
world which have the ns bit set to one

89
00:02:52,800 --> 00:02:55,760
this will be blocked

90
00:02:56,560 --> 00:02:58,640
so if we look at how applications will

91
00:02:58,640 --> 00:03:00,000
uh

92
00:03:00,000 --> 00:03:02,959
interact with the te you'll see that

93
00:03:02,959 --> 00:03:04,800
first thing the app needs to do is to

94
00:03:04,800 --> 00:03:06,879
send a request to the kernel that's

95
00:03:06,879 --> 00:03:07,840
because

96
00:03:07,840 --> 00:03:10,159
android apps cannot directly interact

97
00:03:10,159 --> 00:03:12,560
with the

98
00:03:12,560 --> 00:03:13,760
that's

99
00:03:13,760 --> 00:03:15,840
so this communication is done through

100
00:03:15,840 --> 00:03:17,440
some device that the linux kernel will

101
00:03:17,440 --> 00:03:20,319
expose and then the linux kernel will

102
00:03:20,319 --> 00:03:21,840
execute this special instruction which

103
00:03:21,840 --> 00:03:24,720
is called smc secure monitor call

104
00:03:24,720 --> 00:03:25,840
and uh

105
00:03:25,840 --> 00:03:26,879
yeah this

106
00:03:26,879 --> 00:03:29,040
smc will come up multiple times in the

107
00:03:29,040 --> 00:03:30,959
course of this presentation this is a

108
00:03:30,959 --> 00:03:32,239
instruction that will generate an

109
00:03:32,239 --> 00:03:35,519
exception at the bl-31 so the l3 level

110
00:03:35,519 --> 00:03:37,599
mbl31 will then

111
00:03:37,599 --> 00:03:39,760
determine the id that was specified by

112
00:03:39,760 --> 00:03:42,879
the app for this smc call and it will

113
00:03:42,879 --> 00:03:44,560
decide what to do you can either process

114
00:03:44,560 --> 00:03:47,519
it internally or it can forward it to a

115
00:03:47,519 --> 00:03:49,599
trusted application through the tgis

116
00:03:49,599 --> 00:03:51,519
kernel and the trust application will

117
00:03:51,519 --> 00:03:54,239
then process this and

118
00:03:54,239 --> 00:03:55,680
use functionality implemented in the

119
00:03:55,680 --> 00:03:57,840
theories kernel and then start to do the

120
00:03:57,840 --> 00:03:59,439
inverse

121
00:03:59,439 --> 00:04:01,200
path and send the answer back to the

122
00:04:01,200 --> 00:04:03,760
application

123
00:04:04,159 --> 00:04:07,040
so tigris is a tos that has been

124
00:04:07,040 --> 00:04:09,439
developed by samsung it's

125
00:04:09,439 --> 00:04:11,280
been deployed on the s10 for the first

126
00:04:11,280 --> 00:04:13,920
time it's stored encrypted in high-end

127
00:04:13,920 --> 00:04:14,879
models

128
00:04:14,879 --> 00:04:16,798
it's a relatively small kernel but it's

129
00:04:16,798 --> 00:04:18,720
not a full micro kernel so it still

130
00:04:18,720 --> 00:04:21,040
contains a couple of drivers

131
00:04:21,040 --> 00:04:22,960
it conveniently implements projects like

132
00:04:22,960 --> 00:04:24,560
cisco so whenever you want to interact

133
00:04:24,560 --> 00:04:26,400
with the driver you need to open a

134
00:04:26,400 --> 00:04:28,080
device and then you can do the usual i o

135
00:04:28,080 --> 00:04:30,880
ctl read write map etc to interact with

136
00:04:30,880 --> 00:04:31,600
them

137
00:04:31,600 --> 00:04:33,280
and this is some examples of drivers

138
00:04:33,280 --> 00:04:35,199
that are implemented

139
00:04:35,199 --> 00:04:37,360
in the os

140
00:04:37,360 --> 00:04:39,120
now if we go back to the previous

141
00:04:39,120 --> 00:04:40,479
picture there's actually something i

142
00:04:40,479 --> 00:04:43,280
didn't show before which runs next to

143
00:04:43,280 --> 00:04:44,960
the tigris kernel and these are the

144
00:04:44,960 --> 00:04:46,400
loadable firmwares which is what we are

145
00:04:46,400 --> 00:04:48,240
going to look at today

146
00:04:48,240 --> 00:04:50,160
um so

147
00:04:50,160 --> 00:04:52,400
the idea of a split between kernel and

148
00:04:52,400 --> 00:04:54,160
global firmware is that the kernel tries

149
00:04:54,160 --> 00:04:57,280
to be somehow a hardware agnostic and

150
00:04:57,280 --> 00:04:59,360
the loadable firmware implements all the

151
00:04:59,360 --> 00:05:00,720
low level

152
00:05:00,720 --> 00:05:03,360
like register peripheral operations that

153
00:05:03,360 --> 00:05:05,759
are hardware specific

154
00:05:05,759 --> 00:05:07,360
and

155
00:05:07,360 --> 00:05:09,039
so how are these

156
00:05:09,039 --> 00:05:10,400
components loaded

157
00:05:10,400 --> 00:05:12,960
so this is a boot chain of s21 it's a

158
00:05:12,960 --> 00:05:15,360
fairly typical blue chain

159
00:05:15,360 --> 00:05:18,560
so we'll have first the boot rom

160
00:05:18,560 --> 00:05:21,280
that will start the chain of trust it

161
00:05:21,280 --> 00:05:24,639
will then load bl1 in secure mode

162
00:05:24,639 --> 00:05:27,280
bl 1 will run from sram and load the

163
00:05:27,280 --> 00:05:30,720
next stages so epbl which and as you can

164
00:05:30,720 --> 00:05:31,919
see from

165
00:05:31,919 --> 00:05:34,080
this box basically all the next stages

166
00:05:34,080 --> 00:05:35,680
that run in secure world are stored

167
00:05:35,680 --> 00:05:37,840
encrypted both in flash and in firmware

168
00:05:37,840 --> 00:05:40,160
updates so basically this is a bit of a

169
00:05:40,160 --> 00:05:42,639
black box for an attacker and from this

170
00:05:42,639 --> 00:05:45,039
point on you you will have

171
00:05:45,039 --> 00:05:46,960
both secure and non-secure worlds

172
00:05:46,960 --> 00:05:49,280
running in parallel the non-secure one

173
00:05:49,280 --> 00:05:51,039
will have first bl2 and then little

174
00:05:51,039 --> 00:05:53,199
kernel which will then bootstrap the

175
00:05:53,199 --> 00:05:55,520
linux kernel and on the secure side you

176
00:05:55,520 --> 00:05:58,400
instead have epbl which loads bl31 so

177
00:05:58,400 --> 00:06:00,560
bl31 is this monitor code that is always

178
00:06:00,560 --> 00:06:02,080
running at runtime

179
00:06:02,080 --> 00:06:04,240
bl31

180
00:06:04,240 --> 00:06:07,199
will then get images for a lot of

181
00:06:07,199 --> 00:06:09,199
firmware nte from the little kernel it

182
00:06:09,199 --> 00:06:11,360
will authenticate decrypt them

183
00:06:11,360 --> 00:06:14,560
and load them into memory

184
00:06:15,840 --> 00:06:18,000
so uh if we look at the loadable

185
00:06:18,000 --> 00:06:19,919
firmware they are stored in a specific

186
00:06:19,919 --> 00:06:23,120
partition for loadable firmwares ldfw

187
00:06:23,120 --> 00:06:25,759
uh it's actually a single image

188
00:06:25,759 --> 00:06:28,400
that contains many concatenated smaller

189
00:06:28,400 --> 00:06:30,400
images for each loadable firmware so

190
00:06:30,400 --> 00:06:32,400
there are multiple loadable firmwares

191
00:06:32,400 --> 00:06:34,880
each of them start with this magic

192
00:06:34,880 --> 00:06:36,160
loadable

193
00:06:36,160 --> 00:06:37,759
and uh

194
00:06:37,759 --> 00:06:40,400
basically the bl-31 will iterate through

195
00:06:40,400 --> 00:06:42,080
all of them until it finds an image that

196
00:06:42,080 --> 00:06:43,759
is called tail firmer when that is found

197
00:06:43,759 --> 00:06:45,520
it means it's the end

198
00:06:45,520 --> 00:06:47,680
and

199
00:06:47,680 --> 00:06:50,639
yes they are loaded at the base address

200
00:06:50,639 --> 00:06:52,319
100 000 in x

201
00:06:52,319 --> 00:06:54,000
and as i mentioned before they all run

202
00:06:54,000 --> 00:06:56,080
in secure e1 so they are very privileged

203
00:06:56,080 --> 00:06:57,599
as privileged as the kernel and they are

204
00:06:57,599 --> 00:07:01,440
an interesting target for an attacker

205
00:07:01,440 --> 00:07:03,520
so uh as i mentioned there are multiple

206
00:07:03,520 --> 00:07:05,520
firmwares um

207
00:07:05,520 --> 00:07:08,319
we're going to list them uh here uh

208
00:07:08,319 --> 00:07:10,639
from the biggest to the smallest this is

209
00:07:10,639 --> 00:07:12,400
the crypto manager it has a lot of code

210
00:07:12,400 --> 00:07:13,599
because it has to implement all the

211
00:07:13,599 --> 00:07:15,759
cryptographic functionality that is done

212
00:07:15,759 --> 00:07:18,560
by the hardware it does stuff such as

213
00:07:18,560 --> 00:07:20,160
encryption decryption using the hardware

214
00:07:20,160 --> 00:07:22,960
key random number generation

215
00:07:22,960 --> 00:07:25,120
otp fuses and so on

216
00:07:25,120 --> 00:07:27,599
then we have a drm loadable firmware

217
00:07:27,599 --> 00:07:29,440
which is used for trusted ui for

218
00:07:29,440 --> 00:07:31,599
payments so when you enter your pin

219
00:07:31,599 --> 00:07:33,440
a secure camera

220
00:07:33,440 --> 00:07:35,680
for a face unlock and secure video path

221
00:07:35,680 --> 00:07:37,199
for drm

222
00:07:37,199 --> 00:07:39,520
we have the flash memory protector which

223
00:07:39,520 --> 00:07:41,680
is done for a transparent flash used for

224
00:07:41,680 --> 00:07:43,759
transparent flash encryption

225
00:07:43,759 --> 00:07:47,280
hdcp which is the like the cryptographic

226
00:07:47,280 --> 00:07:49,919
component of hdmi

227
00:07:49,919 --> 00:07:53,199
and rpmb which is some form of secure

228
00:07:53,199 --> 00:07:55,280
storage that is implemented on the

229
00:07:55,280 --> 00:07:57,520
flash

230
00:07:57,520 --> 00:07:59,599
so

231
00:07:59,599 --> 00:08:01,440
if we now extract

232
00:08:01,440 --> 00:08:02,800
one of these loadable firmwares from a

233
00:08:02,800 --> 00:08:04,560
firmware update

234
00:08:04,560 --> 00:08:07,199
we can take a look at what's in there

235
00:08:07,199 --> 00:08:10,240
we see the magic as we mentioned earlier

236
00:08:10,240 --> 00:08:12,240
this is the size all of the values are

237
00:08:12,240 --> 00:08:14,000
in a little endian so the size would be

238
00:08:14,000 --> 00:08:16,879
21 10 0 0.

239
00:08:16,879 --> 00:08:18,479
then there's smc base and this is

240
00:08:18,479 --> 00:08:22,000
interesting so basically um each

241
00:08:22,000 --> 00:08:24,319
loadable firmware has a smc range

242
00:08:24,319 --> 00:08:27,199
assigned so every smc as an id

243
00:08:27,199 --> 00:08:28,879
in this case the smc base for this

244
00:08:28,879 --> 00:08:32,680
loadable firmware is 82.001000

245
00:08:32,719 --> 00:08:36,399
and then the last byte is ignored so

246
00:08:36,399 --> 00:08:37,919
the basically there will be a better

247
00:08:37,919 --> 00:08:39,919
match on the first three bytes if they

248
00:08:39,919 --> 00:08:42,399
if the caller specifies those three

249
00:08:42,399 --> 00:08:43,519
bytes

250
00:08:43,519 --> 00:08:44,240
as

251
00:08:44,240 --> 00:08:46,480
smc value they will be forwarded to this

252
00:08:46,480 --> 00:08:49,279
loadable firmware

253
00:08:49,360 --> 00:08:51,120
then next one is just a version number

254
00:08:51,120 --> 00:08:52,880
it's actually a date so in this case it

255
00:08:52,880 --> 00:08:56,320
was the 29th of december 2020

256
00:08:56,320 --> 00:08:58,480
and then uh there is a name so this is

257
00:08:58,480 --> 00:09:00,000
the cryptomanager it's the largest

258
00:09:00,000 --> 00:09:02,399
loadable firmware we mentioned earlier

259
00:09:02,399 --> 00:09:03,920
and finally at the end there is this

260
00:09:03,920 --> 00:09:05,839
huge block of encrypted code and data of

261
00:09:05,839 --> 00:09:08,000
course the real device is much larger

262
00:09:08,000 --> 00:09:10,399
and it's just yeah basically encrypted

263
00:09:10,399 --> 00:09:13,839
you can't do much with it at the moment

264
00:09:13,839 --> 00:09:16,480
so let's take a look at the how

265
00:09:16,480 --> 00:09:18,320
loadable firmness look like when they

266
00:09:18,320 --> 00:09:20,080
are loaded in memory

267
00:09:20,080 --> 00:09:21,040
so

268
00:09:21,040 --> 00:09:23,680
they have a very simple memory view

269
00:09:23,680 --> 00:09:24,480
uh

270
00:09:24,480 --> 00:09:26,720
basically this is the lowest 32 bits of

271
00:09:26,720 --> 00:09:29,839
uh the memory ranges and then at address

272
00:09:29,839 --> 00:09:31,440
hundred thousand there will be the image

273
00:09:31,440 --> 00:09:33,360
of the loadable firmware as stored in

274
00:09:33,360 --> 00:09:34,959
flash but of course decrypted and then

275
00:09:34,959 --> 00:09:36,640
stored into memory

276
00:09:36,640 --> 00:09:39,519
and then at this address there will be

277
00:09:39,519 --> 00:09:41,760
all the registers that are supported by

278
00:09:41,760 --> 00:09:43,360
the soc

279
00:09:43,360 --> 00:09:45,519
and then at the address 80 and then all

280
00:09:45,519 --> 00:09:48,800
zeros that's where the drm starts so

281
00:09:48,800 --> 00:09:51,440
this will be the two gigabytes of dram

282
00:09:51,440 --> 00:09:53,120
mapped of this address

283
00:09:53,120 --> 00:09:55,200
which includes the dram configured as

284
00:09:55,200 --> 00:09:57,360
secure so this is a

285
00:09:57,360 --> 00:10:00,240
drm which is reserved only to the te

286
00:10:00,240 --> 00:10:02,160
and it contains

287
00:10:02,160 --> 00:10:04,320
also another copy sort of alias of the

288
00:10:04,320 --> 00:10:06,399
loadable firmware as view in the

289
00:10:06,399 --> 00:10:09,200
physical memory

290
00:10:09,279 --> 00:10:10,880
so um

291
00:10:10,880 --> 00:10:14,240
now if we go even more into detail

292
00:10:14,240 --> 00:10:15,760
we see there is this

293
00:10:15,760 --> 00:10:17,279
on the left there is a header of the

294
00:10:17,279 --> 00:10:18,640
loadable firmware

295
00:10:18,640 --> 00:10:21,279
and at address at offset c there is a

296
00:10:21,279 --> 00:10:23,440
pointer to the function that is used to

297
00:10:23,440 --> 00:10:26,959
handle smcs so it will point here

298
00:10:26,959 --> 00:10:29,279
so whenever bl31 will receive an smc

299
00:10:29,279 --> 00:10:32,240
that matches the id which is stored here

300
00:10:32,240 --> 00:10:35,279
of this loadable firmware

301
00:10:35,279 --> 00:10:37,920
bl-31 will read the address at offset c

302
00:10:37,920 --> 00:10:39,600
and then it will then call this function

303
00:10:39,600 --> 00:10:40,880
to process

304
00:10:40,880 --> 00:10:42,079
the

305
00:10:42,079 --> 00:10:44,560
smc

306
00:10:44,560 --> 00:10:45,680
and

307
00:10:45,680 --> 00:10:48,000
inside uh

308
00:10:48,000 --> 00:10:49,600
these loadable firmwares will have smc

309
00:10:49,600 --> 00:10:51,760
handlers which is normally just a big

310
00:10:51,760 --> 00:10:53,680
switch

311
00:10:53,680 --> 00:10:56,480
which takes five arguments the first

312
00:10:56,480 --> 00:10:58,880
four of them are simply

313
00:10:58,880 --> 00:11:02,079
the four registers from x0 to x3 that

314
00:11:02,079 --> 00:11:04,480
were passed by the caller were invoked

315
00:11:04,480 --> 00:11:06,000
the smc

316
00:11:06,000 --> 00:11:08,399
the first one is always the smc id

317
00:11:08,399 --> 00:11:11,440
and the remaining three are specific and

318
00:11:11,440 --> 00:11:13,760
their meaning depends on the smc

319
00:11:13,760 --> 00:11:15,519
and then you'll have all the handlers in

320
00:11:15,519 --> 00:11:20,200
this case the hender for smc 3806

321
00:11:20,720 --> 00:11:22,480
then there is the fifth argument which

322
00:11:22,480 --> 00:11:25,279
we called is nsec and this specifies

323
00:11:25,279 --> 00:11:27,680
whether the caller was running secure or

324
00:11:27,680 --> 00:11:29,279
non-secure mode

325
00:11:29,279 --> 00:11:30,640
so

326
00:11:30,640 --> 00:11:32,480
what this means is that all these

327
00:11:32,480 --> 00:11:33,680
loadable firmwares have a way to

328
00:11:33,680 --> 00:11:36,240
identify who called the global firmware

329
00:11:36,240 --> 00:11:38,399
smc and they can decide whether a

330
00:11:38,399 --> 00:11:40,640
certain smc is only allowed to be called

331
00:11:40,640 --> 00:11:42,800
by the te

332
00:11:42,800 --> 00:11:45,040
like it is in this case

333
00:11:45,040 --> 00:11:46,480
or

334
00:11:46,480 --> 00:11:48,720
if it is allowed to everybody so even

335
00:11:48,720 --> 00:11:50,880
the re would be allowed to invoke

336
00:11:50,880 --> 00:11:53,680
certain smc's

337
00:11:53,680 --> 00:11:55,920
for now let's take a closer look at the

338
00:11:55,920 --> 00:11:58,160
secure only smc's

339
00:11:58,160 --> 00:12:01,440
so the idea of secure only smc's is that

340
00:12:01,440 --> 00:12:04,240
they will be called by the tigers kernel

341
00:12:04,240 --> 00:12:06,240
and the tigger's kernel runs the dl1 so

342
00:12:06,240 --> 00:12:08,000
it's the same privilege level of

343
00:12:08,000 --> 00:12:10,480
loadable firmwares

344
00:12:10,480 --> 00:12:11,760
however

345
00:12:11,760 --> 00:12:13,440
tigris implements

346
00:12:13,440 --> 00:12:16,399
some more functionality

347
00:12:16,399 --> 00:12:18,399
and this is a

348
00:12:18,399 --> 00:12:20,480
overview of the ta permissions

349
00:12:20,480 --> 00:12:22,320
and we can see one of the permissions

350
00:12:22,320 --> 00:12:24,880
that the a can have is the permission to

351
00:12:24,880 --> 00:12:26,880
issue smcs

352
00:12:26,880 --> 00:12:28,240
so

353
00:12:28,240 --> 00:12:30,000
of course um

354
00:12:30,000 --> 00:12:31,600
smc is

355
00:12:31,600 --> 00:12:34,639
just by architectural the definitions

356
00:12:34,639 --> 00:12:36,399
a privileged instruction so tas cannot

357
00:12:36,399 --> 00:12:38,880
directly use smc instructions

358
00:12:38,880 --> 00:12:40,160
but

359
00:12:40,160 --> 00:12:42,240
the kernel has an interface exposed to

360
00:12:42,240 --> 00:12:44,399
smc that's what we were seeing at the

361
00:12:44,399 --> 00:12:46,880
very beginning like some drivers

362
00:12:46,880 --> 00:12:49,440
that are accessible using the posix

363
00:12:49,440 --> 00:12:50,880
ciscos

364
00:12:50,880 --> 00:12:53,519
and tas that have these permissions and

365
00:12:53,519 --> 00:12:55,680
there are a couple of them can call this

366
00:12:55,680 --> 00:12:57,760
um

367
00:12:57,760 --> 00:13:00,160
this driver and then

368
00:13:00,160 --> 00:13:02,160
pass smcs to the loadable firmwares or

369
00:13:02,160 --> 00:13:04,800
to bl-31 and this is actually the

370
00:13:04,800 --> 00:13:08,880
compiled view of this smc handler

371
00:13:08,880 --> 00:13:11,839
as exposed by tigris to tas so assuming

372
00:13:11,839 --> 00:13:14,079
a ta has the correct right

373
00:13:14,079 --> 00:13:15,360
for

374
00:13:15,360 --> 00:13:17,200
talking to the

375
00:13:17,200 --> 00:13:19,519
to issue smc's the first thing the

376
00:13:19,519 --> 00:13:22,160
kernel does is validate and parse the

377
00:13:22,160 --> 00:13:24,560
smc arguments

378
00:13:24,560 --> 00:13:26,079
this is not very interesting because the

379
00:13:26,079 --> 00:13:28,320
ta can always specify a combination of

380
00:13:28,320 --> 00:13:30,160
arguments that says do not validate and

381
00:13:30,160 --> 00:13:32,079
do not check any of them just pass them

382
00:13:32,079 --> 00:13:34,880
directly to the smc handler and if that

383
00:13:34,880 --> 00:13:37,600
function succeeds then the kernel will

384
00:13:37,600 --> 00:13:42,480
forward the arguments and issue the smc

385
00:13:44,959 --> 00:13:46,320
so

386
00:13:46,320 --> 00:13:48,320
we started thinking um

387
00:13:48,320 --> 00:13:50,560
let's assume we exploited the ta we have

388
00:13:50,560 --> 00:13:53,920
runtime control over ta

389
00:13:54,160 --> 00:13:56,720
what can we do with this smc

390
00:13:56,720 --> 00:13:59,279
interface exposed by the kernel and uh

391
00:13:59,279 --> 00:14:01,839
getting runtime controller ta is not the

392
00:14:01,839 --> 00:14:04,480
something we will be talking about today

393
00:14:04,480 --> 00:14:06,320
tas are just applications they have a

394
00:14:06,320 --> 00:14:08,880
usual set of mitigations and

395
00:14:08,880 --> 00:14:10,880
i mean vulnerabilities happen they can

396
00:14:10,880 --> 00:14:12,320
be exploited

397
00:14:12,320 --> 00:14:14,079
so if we have such a vulnerability what

398
00:14:14,079 --> 00:14:17,680
can we do with it and

399
00:14:17,680 --> 00:14:19,600
two years ago martin and i also looked

400
00:14:19,600 --> 00:14:21,839
at the s10

401
00:14:21,839 --> 00:14:23,440
and back then we identified the

402
00:14:23,440 --> 00:14:24,959
vulnerability that gave us full control

403
00:14:24,959 --> 00:14:27,040
of the te which means thanks to this

404
00:14:27,040 --> 00:14:28,800
vulnerability

405
00:14:28,800 --> 00:14:30,399
we were able to extract the loadable

406
00:14:30,399 --> 00:14:32,880
firmwares uh from memory as they were

407
00:14:32,880 --> 00:14:34,560
running on the s10

408
00:14:34,560 --> 00:14:37,199
and our idea was can we identify some

409
00:14:37,199 --> 00:14:39,279
functionality that has not been changed

410
00:14:39,279 --> 00:14:41,839
in the stand uh compress in the s21

411
00:14:41,839 --> 00:14:44,720
compared to s10 and try to exploit this

412
00:14:44,720 --> 00:14:47,760
on the s21

413
00:14:48,320 --> 00:14:50,720
so this is what we identified this is an

414
00:14:50,720 --> 00:14:53,120
smc implemented in the crypto manager

415
00:14:53,120 --> 00:14:56,399
and this is only reserved to the secure

416
00:14:56,399 --> 00:14:57,680
callers

417
00:14:57,680 --> 00:14:59,600
and the first thing it does it takes an

418
00:14:59,600 --> 00:15:01,680
argument passed by the caller

419
00:15:01,680 --> 00:15:04,399
this is a structure of c0 bytes and it

420
00:15:04,399 --> 00:15:06,240
checks that this structure needs to be

421
00:15:06,240 --> 00:15:08,320
fully within the tv memory

422
00:15:08,320 --> 00:15:10,320
and with team memory i mean anywhere in

423
00:15:10,320 --> 00:15:13,199
tv memory can be ta memory uh crypto

424
00:15:13,199 --> 00:15:15,600
memo crypto a local firmware memory

425
00:15:15,600 --> 00:15:18,720
kernel serious kernel memory anywhere

426
00:15:18,720 --> 00:15:21,440
once that is verified

427
00:15:21,440 --> 00:15:23,360
it will then

428
00:15:23,360 --> 00:15:25,040
extract two

429
00:15:25,040 --> 00:15:27,360
physical memory buffers as specified

430
00:15:27,360 --> 00:15:28,639
within the structure so basically the

431
00:15:28,639 --> 00:15:30,160
structure will have a physical memory

432
00:15:30,160 --> 00:15:32,480
start address and a length

433
00:15:32,480 --> 00:15:34,079
of the first buffer and of the second

434
00:15:34,079 --> 00:15:35,120
buffer

435
00:15:35,120 --> 00:15:37,120
and again it will check that these two

436
00:15:37,120 --> 00:15:40,639
buffers are fully within the te memory

437
00:15:40,639 --> 00:15:44,000
after all these checks are done

438
00:15:44,000 --> 00:15:46,000
it will call some hardware functionality

439
00:15:46,000 --> 00:15:48,320
that will do an encrypted dma

440
00:15:48,320 --> 00:15:49,360
from

441
00:15:49,360 --> 00:15:51,680
first buffer encrypting data into the

442
00:15:51,680 --> 00:15:54,160
second buffer

443
00:15:54,160 --> 00:15:57,759
so is there a problem here well

444
00:15:58,079 --> 00:16:00,079
it's good that the smc verifies that all

445
00:16:00,079 --> 00:16:02,079
the buffers are in the secure world

446
00:16:02,079 --> 00:16:03,120
but

447
00:16:03,120 --> 00:16:04,959
there is no as i mentioned there is no

448
00:16:04,959 --> 00:16:07,040
check that these two buffers are within

449
00:16:07,040 --> 00:16:09,519
a ta memory or within te memory it's

450
00:16:09,519 --> 00:16:11,519
just simply somewhere in there

451
00:16:11,519 --> 00:16:12,639
and

452
00:16:12,639 --> 00:16:15,040
it sort of expects that this these

453
00:16:15,040 --> 00:16:16,480
parameters are set correctly by the

454
00:16:16,480 --> 00:16:18,720
caller because it expects the kernel to

455
00:16:18,720 --> 00:16:20,639
set these parameters correctly

456
00:16:20,639 --> 00:16:23,279
but what if instead the ta specify

457
00:16:23,279 --> 00:16:25,120
different value for these parameters and

458
00:16:25,120 --> 00:16:28,240
passes them through the ta interface

459
00:16:28,240 --> 00:16:30,000
and this is actually our plan so the

460
00:16:30,000 --> 00:16:32,880
idea was use this smc interface to the

461
00:16:32,880 --> 00:16:34,160
kernel

462
00:16:34,160 --> 00:16:36,959
to issue an ioctl the kernel will simply

463
00:16:36,959 --> 00:16:39,040
take our data forward it's to bl 31

464
00:16:39,040 --> 00:16:41,199
which will see okay there's an smc

465
00:16:41,199 --> 00:16:43,839
coming from the kernel

466
00:16:43,839 --> 00:16:46,320
and it's the for the crypto manager so

467
00:16:46,320 --> 00:16:47,680
it will simply again pass it to the

468
00:16:47,680 --> 00:16:49,360
crypto manager the crypto manager sees

469
00:16:49,360 --> 00:16:53,360
okay this is the smc used for um

470
00:16:53,360 --> 00:16:56,399
encrypted memory to memory dma

471
00:16:56,399 --> 00:16:58,079
and then it will configure the crypto

472
00:16:58,079 --> 00:16:59,279
engine

473
00:16:59,279 --> 00:17:01,279
uh set up

474
00:17:01,279 --> 00:17:02,959
the mode which is encounter mode and

475
00:17:02,959 --> 00:17:05,119
this is the actually the only thing that

476
00:17:05,119 --> 00:17:06,400
is enforced

477
00:17:06,400 --> 00:17:07,760
by

478
00:17:07,760 --> 00:17:10,240
the crypto manager because all the rest

479
00:17:10,240 --> 00:17:11,039
he

480
00:17:11,039 --> 00:17:11,919
iv

481
00:17:11,919 --> 00:17:13,760
source address destination address and

482
00:17:13,760 --> 00:17:18,079
length will be controlled by the ta

483
00:17:18,079 --> 00:17:19,919
the crypto engine is configured what we

484
00:17:19,919 --> 00:17:22,480
can do from a ta is for instance point

485
00:17:22,480 --> 00:17:23,919
the source address

486
00:17:23,919 --> 00:17:25,280
from crypto manager memory and

487
00:17:25,280 --> 00:17:26,720
destination address

488
00:17:26,720 --> 00:17:29,120
in some memory belonging to the ta

489
00:17:29,120 --> 00:17:30,480
itself

490
00:17:30,480 --> 00:17:32,960
and because we know the key

491
00:17:32,960 --> 00:17:35,360
we can simply encrypt memory

492
00:17:35,360 --> 00:17:37,039
put it in the ta memory space from

493
00:17:37,039 --> 00:17:38,799
within the ta decrypt it and then we

494
00:17:38,799 --> 00:17:40,400
extracted memory belonging to the crypto

495
00:17:40,400 --> 00:17:41,360
manager

496
00:17:41,360 --> 00:17:42,640
and we're not limited to the crypto

497
00:17:42,640 --> 00:17:45,120
manager we can extract bl31 memory we

498
00:17:45,120 --> 00:17:47,280
can extract the kernel memory everything

499
00:17:47,280 --> 00:17:49,520
just copy it within the ta and then read

500
00:17:49,520 --> 00:17:51,840
it out

501
00:17:52,640 --> 00:17:54,960
we have only a small problem left and it

502
00:17:54,960 --> 00:17:57,919
is that the smc handler and the dma

503
00:17:57,919 --> 00:17:59,520
engine expect physical addresses and the

504
00:17:59,520 --> 00:18:01,600
ta has no idea about physical addresses

505
00:18:01,600 --> 00:18:04,160
ta runs in its own virtual address space

506
00:18:04,160 --> 00:18:06,559
and we need to find a couple of physical

507
00:18:06,559 --> 00:18:08,559
addresses one is the physical address of

508
00:18:08,559 --> 00:18:09,840
the structure that contains the

509
00:18:09,840 --> 00:18:11,679
definition of the buffers

510
00:18:11,679 --> 00:18:13,760
and the rest is the physical addresses

511
00:18:13,760 --> 00:18:15,919
of the buffers themselves for doing the

512
00:18:15,919 --> 00:18:17,840
dma

513
00:18:17,840 --> 00:18:19,840
uh fortunately this is not too

514
00:18:19,840 --> 00:18:21,280
complicated

515
00:18:21,280 --> 00:18:22,720
because there are a few things that we

516
00:18:22,720 --> 00:18:23,600
know

517
00:18:23,600 --> 00:18:25,600
first thing we know is where the t

518
00:18:25,600 --> 00:18:27,440
memory starts and ends this is just

519
00:18:27,440 --> 00:18:30,320
something you can read out from android

520
00:18:30,320 --> 00:18:34,080
and then we know that heap locations are

521
00:18:34,080 --> 00:18:36,720
relatively predictable so we know ta can

522
00:18:36,720 --> 00:18:39,280
allocate at max about 50 megabytes and

523
00:18:39,280 --> 00:18:41,520
this whole space is 120 megabytes for

524
00:18:41,520 --> 00:18:43,039
the te

525
00:18:43,039 --> 00:18:44,880
we know that if we have a bigger

526
00:18:44,880 --> 00:18:47,840
location uh contiguous

527
00:18:47,840 --> 00:18:50,080
pages in the va space will be also

528
00:18:50,080 --> 00:18:52,080
continuous in the physical address space

529
00:18:52,080 --> 00:18:54,080
so that's nice you get a nice contiguous

530
00:18:54,080 --> 00:18:55,360
view

531
00:18:55,360 --> 00:18:57,760
and the start address of this allocation

532
00:18:57,760 --> 00:19:00,160
and i mean the physical start address

533
00:19:00,160 --> 00:19:01,919
is more or less constant so there are a

534
00:19:01,919 --> 00:19:04,000
few pages that differ between different

535
00:19:04,000 --> 00:19:06,400
executions and i think these

536
00:19:06,400 --> 00:19:08,320
mostly depend on just the state of the

537
00:19:08,320 --> 00:19:11,840
te memory at that time

538
00:19:12,640 --> 00:19:13,679
so

539
00:19:13,679 --> 00:19:17,280
what we thought was let's spray the heap

540
00:19:17,280 --> 00:19:19,600
let's put thousands of copies of this

541
00:19:19,600 --> 00:19:20,720
structure

542
00:19:20,720 --> 00:19:24,160
and execute this smc from a rope payload

543
00:19:24,160 --> 00:19:26,080
that runs in a compromised ta that has

544
00:19:26,080 --> 00:19:28,160
the smc permission

545
00:19:28,160 --> 00:19:30,480
so once we do a big allocation this is

546
00:19:30,480 --> 00:19:32,000
what's going to happen we will allocate

547
00:19:32,000 --> 00:19:34,720
something on the heap and these are the

548
00:19:34,720 --> 00:19:37,760
start and end address plus minus a few

549
00:19:37,760 --> 00:19:39,440
kilobytes of

550
00:19:39,440 --> 00:19:41,760
located heap

551
00:19:41,760 --> 00:19:43,120
structure on the heap

552
00:19:43,120 --> 00:19:45,840
and then we'll start filling this

553
00:19:45,840 --> 00:19:47,760
structure this

554
00:19:47,760 --> 00:19:50,000
space on the heap with a lot of copies

555
00:19:50,000 --> 00:19:51,280
of the structure

556
00:19:51,280 --> 00:19:53,200
and all these copies in the structure

557
00:19:53,200 --> 00:19:55,520
will set a destination address at

558
00:19:55,520 --> 00:19:57,320
somewhere close to

559
00:19:57,320 --> 00:19:59,679
bbd000 because we know the destination

560
00:19:59,679 --> 00:20:00,880
address

561
00:20:00,880 --> 00:20:02,240
that destination address belongs to the

562
00:20:02,240 --> 00:20:04,720
ta and the source address to other

563
00:20:04,720 --> 00:20:06,640
memory areas that are outside the ta

564
00:20:06,640 --> 00:20:07,919
memory space

565
00:20:07,919 --> 00:20:10,960
then we issue the smc

566
00:20:10,960 --> 00:20:12,960
and then this whole

567
00:20:12,960 --> 00:20:14,799
buffer that we allocated will be

568
00:20:14,799 --> 00:20:17,600
overwritten with encrypted extracted ce

569
00:20:17,600 --> 00:20:22,480
data that we can decrypt offline

570
00:20:22,480 --> 00:20:25,200
and we try this approach it works and

571
00:20:25,200 --> 00:20:27,200
the nice thing about this approach is

572
00:20:27,200 --> 00:20:29,840
now i presented how we managed to read

573
00:20:29,840 --> 00:20:30,960
out

574
00:20:30,960 --> 00:20:34,559
protected memory from the te kernel

575
00:20:34,559 --> 00:20:36,640
but we can also overwrite it and because

576
00:20:36,640 --> 00:20:38,400
this happens through a dma engine you're

577
00:20:38,400 --> 00:20:40,480
not restricted by the mmu settings that

578
00:20:40,480 --> 00:20:42,240
normally would prevent you from

579
00:20:42,240 --> 00:20:44,320
overwriting code and so on

580
00:20:44,320 --> 00:20:46,640
with this you can simply tell the dma

581
00:20:46,640 --> 00:20:48,640
engine write this on top of the code

582
00:20:48,640 --> 00:20:50,240
section of the kernel and it will help

583
00:20:50,240 --> 00:20:53,520
you replace the kernel

584
00:20:53,520 --> 00:20:54,480
so

585
00:20:54,480 --> 00:20:56,559
this was the first vulnerability we

586
00:20:56,559 --> 00:20:58,159
found

587
00:20:58,159 --> 00:21:00,400
which is nice but

588
00:21:00,400 --> 00:21:02,880
can we find more

589
00:21:02,880 --> 00:21:04,880
and

590
00:21:04,880 --> 00:21:07,200
so at this point we were at a stage

591
00:21:07,200 --> 00:21:09,280
where we had the loadable firmwares

592
00:21:09,280 --> 00:21:10,720
fully extracted

593
00:21:10,720 --> 00:21:14,080
we decrypted them we got their plaintext

594
00:21:14,080 --> 00:21:17,520
value load them in ida

595
00:21:17,520 --> 00:21:20,080
and the smc we currently exploited is

596
00:21:20,080 --> 00:21:22,799
only accessible to secure memory which

597
00:21:22,799 --> 00:21:24,720
means you would first need to exploit

598
00:21:24,720 --> 00:21:25,760
the ta

599
00:21:25,760 --> 00:21:27,760
which has the smc permission then run

600
00:21:27,760 --> 00:21:29,200
your code from there and then run the

601
00:21:29,200 --> 00:21:30,960
exploit which

602
00:21:30,960 --> 00:21:33,760
i mean there are it's quite complex

603
00:21:33,760 --> 00:21:35,679
and we thought

604
00:21:35,679 --> 00:21:36,960
is there something that we can do

605
00:21:36,960 --> 00:21:38,880
directly from the android side because

606
00:21:38,880 --> 00:21:40,559
as we showed earlier there are some smcs

607
00:21:40,559 --> 00:21:44,320
that are accessible to android um this

608
00:21:44,320 --> 00:21:46,080
is not so simple though

609
00:21:46,080 --> 00:21:47,520
because

610
00:21:47,520 --> 00:21:50,720
it's not easy to issue arbitrary smcs

611
00:21:50,720 --> 00:21:52,720
as i mentioned smc is a kernel-only

612
00:21:52,720 --> 00:21:54,000
instruction

613
00:21:54,000 --> 00:21:57,360
and in the running system in s21 there

614
00:21:57,360 --> 00:21:58,960
is no driver that exposes this

615
00:21:58,960 --> 00:22:01,120
functionality even if you are rooted

616
00:22:01,120 --> 00:22:02,880
there is no driver that just takes your

617
00:22:02,880 --> 00:22:07,039
smc id and passes it happily to the te

618
00:22:07,039 --> 00:22:08,720
so for the purpose of this research we

619
00:22:08,720 --> 00:22:10,720
decided okay let's just make a custom

620
00:22:10,720 --> 00:22:12,400
kernel

621
00:22:12,400 --> 00:22:13,840
where

622
00:22:13,840 --> 00:22:15,760
we can flash on the device and we added

623
00:22:15,760 --> 00:22:17,919
two drivers to it

624
00:22:17,919 --> 00:22:19,760
one is an smc driver

625
00:22:19,760 --> 00:22:21,919
which does exactly what i just mentioned

626
00:22:21,919 --> 00:22:23,360
takes

627
00:22:23,360 --> 00:22:25,600
smc id and some arguments and then just

628
00:22:25,600 --> 00:22:27,600
passes them to the

629
00:22:27,600 --> 00:22:29,200
to the te

630
00:22:29,200 --> 00:22:30,880
and the second driver is a sort of

631
00:22:30,880 --> 00:22:33,440
helper driver that we use to access

632
00:22:33,440 --> 00:22:36,080
physical memory from the android side it

633
00:22:36,080 --> 00:22:37,760
basically maps physical memory and then

634
00:22:37,760 --> 00:22:38,799
allows

635
00:22:38,799 --> 00:22:41,440
user mode application on android to read

636
00:22:41,440 --> 00:22:43,120
and write the contents of this physical

637
00:22:43,120 --> 00:22:44,640
memory

638
00:22:44,640 --> 00:22:45,600
so

639
00:22:45,600 --> 00:22:47,440
now that we have the setup ready we

640
00:22:47,440 --> 00:22:48,400
started

641
00:22:48,400 --> 00:22:50,159
looking for vulnerabilities

642
00:22:50,159 --> 00:22:51,360
and

643
00:22:51,360 --> 00:22:53,120
i would not like to ask more time to

644
00:22:53,120 --> 00:22:55,039
come over to tell us a bit more about

645
00:22:55,039 --> 00:22:57,280
this

646
00:23:00,640 --> 00:23:01,440
so

647
00:23:01,440 --> 00:23:04,720
what can we find because

648
00:23:04,720 --> 00:23:08,240
these are encrypted binary site and it

649
00:23:08,240 --> 00:23:10,799
sort of means that this also

650
00:23:10,799 --> 00:23:12,799
means that not that many people are

651
00:23:12,799 --> 00:23:15,679
looking at these type of binaries

652
00:23:15,679 --> 00:23:18,240
so could that maybe reveal interesting

653
00:23:18,240 --> 00:23:20,840
vulnerabilities

654
00:23:20,840 --> 00:23:24,000
so let's start to have a look so we

655
00:23:24,000 --> 00:23:26,640
start with looking at the rpmb loadable

656
00:23:26,640 --> 00:23:27,840
firmware

657
00:23:27,840 --> 00:23:30,799
and what it does is um one of the first

658
00:23:30,799 --> 00:23:32,640
things you need to do is you need to

659
00:23:32,640 --> 00:23:34,720
register some memory that you are going

660
00:23:34,720 --> 00:23:36,320
to share between the secure and the

661
00:23:36,320 --> 00:23:38,480
non-secure world and somewhere during

662
00:23:38,480 --> 00:23:41,840
the boot process you will um

663
00:23:41,840 --> 00:23:44,960
the linux kernel will issue an smc to

664
00:23:44,960 --> 00:23:47,279
say like this is where i want to have

665
00:23:47,279 --> 00:23:49,600
this shared memory

666
00:23:49,600 --> 00:23:51,039
and

667
00:23:51,039 --> 00:23:53,600
what this smc then will do it will check

668
00:23:53,600 --> 00:23:55,679
like if this memory is fully in

669
00:23:55,679 --> 00:23:58,000
non-secure memory because well you don't

670
00:23:58,000 --> 00:23:58,960
want

671
00:23:58,960 --> 00:24:00,960
the linux kernel to maybe provide a

672
00:24:00,960 --> 00:24:03,279
pointer somewhere in your secure memory

673
00:24:03,279 --> 00:24:05,120
so it will do arrange the act like hey

674
00:24:05,120 --> 00:24:07,840
is this really non-secure memory and if

675
00:24:07,840 --> 00:24:10,080
so it will register it and it will set

676
00:24:10,080 --> 00:24:13,120
up the context for

677
00:24:13,120 --> 00:24:15,919
the rpmb loadable firmware

678
00:24:15,919 --> 00:24:19,120
so this works as expected

679
00:24:19,120 --> 00:24:21,520
but then we started looking and we

680
00:24:21,520 --> 00:24:23,520
noticed that there was some new code

681
00:24:23,520 --> 00:24:26,799
added that was not there at the s10 yet

682
00:24:26,799 --> 00:24:30,799
and this code was remarkably small

683
00:24:30,799 --> 00:24:32,480
it was basically four lines when you

684
00:24:32,480 --> 00:24:36,080
decompiled it and that's a bit odd

685
00:24:36,080 --> 00:24:38,240
um especially it means that we are for

686
00:24:38,240 --> 00:24:40,640
sure not checking where this call is

687
00:24:40,640 --> 00:24:42,559
coming from so everybody can call it

688
00:24:42,559 --> 00:24:45,039
secure or non-secure site that was even

689
00:24:45,039 --> 00:24:46,400
weirder

690
00:24:46,400 --> 00:24:49,840
are we really directly writing to some

691
00:24:49,840 --> 00:24:52,080
pointers that are provided by the caller

692
00:24:52,080 --> 00:24:54,880
without any pointer check

693
00:24:54,880 --> 00:24:57,679
and the answer is yes

694
00:24:57,679 --> 00:24:59,440
so

695
00:24:59,440 --> 00:25:02,400
we have now a primitive and directly

696
00:25:02,400 --> 00:25:04,880
reachable primitive from the non-secure

697
00:25:04,880 --> 00:25:08,799
side that we can write a 64 or a 1024 to

698
00:25:08,799 --> 00:25:11,760
any address we want so how can we use

699
00:25:11,760 --> 00:25:14,480
that can we maybe cover up a length from

700
00:25:14,480 --> 00:25:17,840
a buffer or from a range jack to maybe

701
00:25:17,840 --> 00:25:20,559
create a buffer overflow can we maybe do

702
00:25:20,559 --> 00:25:21,520
some

703
00:25:21,520 --> 00:25:23,360
magic

704
00:25:23,360 --> 00:25:26,799
with maybe the pay sales well we decided

705
00:25:26,799 --> 00:25:29,919
to take a slightly different approach

706
00:25:29,919 --> 00:25:32,880
we decided to actually let

707
00:25:32,880 --> 00:25:35,120
the hardware and use it basically

708
00:25:35,120 --> 00:25:37,679
against itself so how is it actually

709
00:25:37,679 --> 00:25:39,520
working that we have a separation

710
00:25:39,520 --> 00:25:42,159
between a non-secure and a secure world

711
00:25:42,159 --> 00:25:45,679
how is the memory from the secure world

712
00:25:45,679 --> 00:25:48,159
actually guaranteed not accessible by

713
00:25:48,159 --> 00:25:51,360
the non-secure world well your cpu core

714
00:25:51,360 --> 00:25:53,120
is running either in secure motor

715
00:25:53,120 --> 00:25:54,720
non-secure mode and this is controlled

716
00:25:54,720 --> 00:25:56,960
by the ns bit that is part of the sdi

717
00:25:56,960 --> 00:25:58,400
register

718
00:25:58,400 --> 00:26:00,320
and then the cpu wants to access some

719
00:26:00,320 --> 00:26:02,799
memory it will put an

720
00:26:02,799 --> 00:26:05,120
memory transaction on the bus

721
00:26:05,120 --> 00:26:07,279
and this transaction will then get

722
00:26:07,279 --> 00:26:09,840
routed to the memory controller and as

723
00:26:09,840 --> 00:26:11,120
part of this

724
00:26:11,120 --> 00:26:13,919
bus information we send the address but

725
00:26:13,919 --> 00:26:16,240
we also reflect our execution state on

726
00:26:16,240 --> 00:26:17,200
the bus

727
00:26:17,200 --> 00:26:19,679
and then this will reach the memory

728
00:26:19,679 --> 00:26:21,440
controller and the memory controller

729
00:26:21,440 --> 00:26:24,080
will then access that address for us

730
00:26:24,080 --> 00:26:27,600
except there is a reality one step uh

731
00:26:27,600 --> 00:26:29,279
happening in between

732
00:26:29,279 --> 00:26:32,799
that is uh going to check like is this

733
00:26:32,799 --> 00:26:34,880
actually a secure on a non-secure memory

734
00:26:34,880 --> 00:26:37,200
access and the hardware that is doing

735
00:26:37,200 --> 00:26:39,279
this is called the t-set asc the

736
00:26:39,279 --> 00:26:41,600
trustron address space controller

737
00:26:41,600 --> 00:26:43,360
and your and the threshold address space

738
00:26:43,360 --> 00:26:46,240
controller triggered to the hardware

739
00:26:46,240 --> 00:26:49,200
registers something called secure ranges

740
00:26:49,200 --> 00:26:50,480
these are

741
00:26:50,480 --> 00:26:53,120
a group of start and end addresses with

742
00:26:53,120 --> 00:26:55,760
permissions with what the hardware will

743
00:26:55,760 --> 00:26:57,200
consider us

744
00:26:57,200 --> 00:27:01,440
to as memory that has a special yeah

745
00:27:01,440 --> 00:27:03,919
that has special permissions and this

746
00:27:03,919 --> 00:27:06,320
could for example be it is accessible by

747
00:27:06,320 --> 00:27:08,480
the non-secure world or it is accessible

748
00:27:08,480 --> 00:27:10,240
by the secure world and not by the

749
00:27:10,240 --> 00:27:12,080
non-secure world

750
00:27:12,080 --> 00:27:14,559
and then what the tsa asc will do it

751
00:27:14,559 --> 00:27:15,679
will

752
00:27:15,679 --> 00:27:18,960
basically compare the memory transaction

753
00:27:18,960 --> 00:27:21,360
against the secure

754
00:27:21,360 --> 00:27:23,840
ranges that are configured it will check

755
00:27:23,840 --> 00:27:25,840
the

756
00:27:25,840 --> 00:27:28,159
execution state and it will decide

757
00:27:28,159 --> 00:27:30,159
whether or not it will allow it in this

758
00:27:30,159 --> 00:27:32,320
case we are doing a transaction to

759
00:27:32,320 --> 00:27:34,240
something that is part of the secure

760
00:27:34,240 --> 00:27:35,919
memory while they are running in the

761
00:27:35,919 --> 00:27:37,919
non-secure state so in this case the

762
00:27:37,919 --> 00:27:40,240
t-set asc will just say this is not

763
00:27:40,240 --> 00:27:43,120
going to happen and it will generate an

764
00:27:43,120 --> 00:27:44,159
interrupt

765
00:27:44,159 --> 00:27:46,480
for a security violation

766
00:27:46,480 --> 00:27:49,840
however if we are actually running in

767
00:27:49,840 --> 00:27:53,039
the secure mode the t-set asc is going

768
00:27:53,039 --> 00:27:55,039
to allow the memory transaction to

769
00:27:55,039 --> 00:27:56,000
happen

770
00:27:56,000 --> 00:27:57,840
but how is this actually

771
00:27:57,840 --> 00:28:00,080
really working on from an hardware level

772
00:28:00,080 --> 00:28:01,679
so how are

773
00:28:01,679 --> 00:28:03,600
these secure ranges configured well

774
00:28:03,600 --> 00:28:05,760
there are standard designs for that ase

775
00:28:05,760 --> 00:28:08,000
and some vendors use these standard

776
00:28:08,000 --> 00:28:10,480
designs they license from arm directly

777
00:28:10,480 --> 00:28:13,039
however samsung has decided to create

778
00:28:13,039 --> 00:28:14,880
their own controller that is

779
00:28:14,880 --> 00:28:17,360
functionally the same but the register

780
00:28:17,360 --> 00:28:19,520
interface is completely different

781
00:28:19,520 --> 00:28:22,320
and what you see is that

782
00:28:22,320 --> 00:28:24,880
when you start checking the registers

783
00:28:24,880 --> 00:28:27,520
this is not documented so we had to

784
00:28:27,520 --> 00:28:30,080
figure out where these registers are and

785
00:28:30,080 --> 00:28:31,919
then start looking like what is the

786
00:28:31,919 --> 00:28:34,320
meaning of all these bits but you then

787
00:28:34,320 --> 00:28:37,520
at a certain moment see is that we have

788
00:28:37,520 --> 00:28:40,480
two blocks of 30 bytes

789
00:28:40,480 --> 00:28:42,399
in the register space that looks an

790
00:28:42,399 --> 00:28:45,120
awful lot like hey this could be a start

791
00:28:45,120 --> 00:28:46,880
and an end address and we see some other

792
00:28:46,880 --> 00:28:49,440
bits which are probably permissions

793
00:28:49,440 --> 00:28:51,279
so what do we have here well in this

794
00:28:51,279 --> 00:28:54,600
case we have a start address from

795
00:28:54,600 --> 00:28:57,360
b8a0000 to

796
00:28:57,360 --> 00:29:00,000
e0 which is actually one page less than

797
00:29:00,000 --> 00:29:03,279
what it is really protecting

798
00:29:03,279 --> 00:29:04,640
and actually

799
00:29:04,640 --> 00:29:07,120
this is even

800
00:29:07,120 --> 00:29:09,440
a simplification in reality we don't

801
00:29:09,440 --> 00:29:11,679
have one memory controller and one t-set

802
00:29:11,679 --> 00:29:14,320
asc but we have four memory controllers

803
00:29:14,320 --> 00:29:17,440
f40s at ascs because samsung decided

804
00:29:17,440 --> 00:29:19,679
that it is sort of interleaving the

805
00:29:19,679 --> 00:29:21,480
memory so every

806
00:29:21,480 --> 00:29:25,120
256 bytes of memory is routed to a

807
00:29:25,120 --> 00:29:28,159
different memory controller

808
00:29:28,159 --> 00:29:30,480
so depending on the address you want to

809
00:29:30,480 --> 00:29:31,520
access

810
00:29:31,520 --> 00:29:34,159
it will go to a different controller and

811
00:29:34,159 --> 00:29:37,360
a different tset asc and also each dsc

812
00:29:37,360 --> 00:29:39,440
has its own set of hardware registers

813
00:29:39,440 --> 00:29:41,520
that configures what the secure ranges

814
00:29:41,520 --> 00:29:43,440
are

815
00:29:43,440 --> 00:29:45,200
well let's start messing with these

816
00:29:45,200 --> 00:29:47,440
registers what happens for example if we

817
00:29:47,440 --> 00:29:50,240
set an end address before

818
00:29:50,240 --> 00:29:52,640
a start address well

819
00:29:52,640 --> 00:29:54,000
you would assume that this will

820
00:29:54,000 --> 00:29:55,840
completely break the system right it's

821
00:29:55,840 --> 00:29:57,840
for sure this is not a valid

822
00:29:57,840 --> 00:29:59,760
configuration

823
00:29:59,760 --> 00:30:01,360
well

824
00:30:01,360 --> 00:30:04,080
you start trying this and maybe you see

825
00:30:04,080 --> 00:30:06,840
some interesting behavior

826
00:30:06,840 --> 00:30:10,000
so for our smc driver in the linux

827
00:30:10,000 --> 00:30:11,760
kernel we have created a very small

828
00:30:11,760 --> 00:30:14,399
command line utility that allows us to

829
00:30:14,399 --> 00:30:16,080
interact with the driver and we can just

830
00:30:16,080 --> 00:30:18,720
from a shell an adb shell

831
00:30:18,720 --> 00:30:20,960
issue arbitrary smc's with arbitrary

832
00:30:20,960 --> 00:30:24,159
arguments which is very convenient

833
00:30:24,159 --> 00:30:26,240
from a research perspective

834
00:30:26,240 --> 00:30:26,960
so

835
00:30:26,960 --> 00:30:29,760
we provide smc id that we want to call

836
00:30:29,760 --> 00:30:32,960
and we provide the

837
00:30:32,960 --> 00:30:36,000
the hardware register address

838
00:30:36,000 --> 00:30:37,760
of the end address of the secure range

839
00:30:37,760 --> 00:30:41,039
for the te memory and we do this

840
00:30:41,039 --> 00:30:43,600
once for every t-set asc because we have

841
00:30:43,600 --> 00:30:45,679
four of them we do it four times and you

842
00:30:45,679 --> 00:30:48,320
actually can see that the end address

843
00:30:48,320 --> 00:30:51,120
the third byte is basically incrementing

844
00:30:51,120 --> 00:30:53,440
that is the shift of where these

845
00:30:53,440 --> 00:30:57,039
registers are mapped

846
00:30:57,039 --> 00:30:58,960
and then our tool

847
00:30:58,960 --> 00:31:01,519
will do simply an ioctl with the

848
00:31:01,519 --> 00:31:04,399
arguments provided to our driver put it

849
00:31:04,399 --> 00:31:05,440
in the right

850
00:31:05,440 --> 00:31:08,399
registers and issue the smc instruction

851
00:31:08,399 --> 00:31:10,480
because well from user mode we cannot

852
00:31:10,480 --> 00:31:12,880
issue that instruction directly

853
00:31:12,880 --> 00:31:15,279
and when you then check back like what

854
00:31:15,279 --> 00:31:18,080
has happened well the last one was

855
00:31:18,080 --> 00:31:22,399
writing 1024 to the end address

856
00:31:22,399 --> 00:31:25,200
we still have the correct start address

857
00:31:25,200 --> 00:31:26,159
for

858
00:31:26,159 --> 00:31:28,640
our secure range except this time the

859
00:31:28,640 --> 00:31:33,240
end address has been changed to 1024

860
00:31:33,279 --> 00:31:36,159
and well we no longer have a valid uh

861
00:31:36,159 --> 00:31:38,480
configuration anymore but what is now

862
00:31:38,480 --> 00:31:40,159
going to happen when we access secure

863
00:31:40,159 --> 00:31:41,679
memory

864
00:31:41,679 --> 00:31:44,000
while we are running a non-secure mode

865
00:31:44,000 --> 00:31:46,799
so with the ns bit set to one well from

866
00:31:46,799 --> 00:31:49,679
the tz.asc perspective we have a secure

867
00:31:49,679 --> 00:31:51,360
range with the secure range with an end

868
00:31:51,360 --> 00:31:53,679
address before the start address and the

869
00:31:53,679 --> 00:31:56,640
tjsc is just like okay i'm going to

870
00:31:56,640 --> 00:32:00,559
allow this fine go ahead

871
00:32:00,559 --> 00:32:03,279
and this is exactly

872
00:32:03,279 --> 00:32:05,360
what we are going to do

873
00:32:05,360 --> 00:32:06,559
so

874
00:32:06,559 --> 00:32:09,120
i have here an s21 with the firmware

875
00:32:09,120 --> 00:32:12,719
from may last year

876
00:32:13,279 --> 00:32:16,480
that is the one that is still vulnerable

877
00:32:16,480 --> 00:32:20,080
and first i'm going to show you

878
00:32:20,399 --> 00:32:22,879
a part of

879
00:32:25,919 --> 00:32:28,399
first i'm going to show you a part of

880
00:32:28,399 --> 00:32:30,559
secure memory and

881
00:32:30,559 --> 00:32:32,559
we have nothing done yet which basically

882
00:32:32,559 --> 00:32:34,799
means we read back

883
00:32:34,799 --> 00:32:36,159
zeros

884
00:32:36,159 --> 00:32:38,159
at the moment our request is being

885
00:32:38,159 --> 00:32:41,200
ignored and what we then can do

886
00:32:41,200 --> 00:32:44,240
we issue our

887
00:32:48,399 --> 00:32:51,760
we issue our four smcs so you can see

888
00:32:51,760 --> 00:32:52,960
that

889
00:32:52,960 --> 00:32:55,120
it is actually for for convenience

890
00:32:55,120 --> 00:32:57,519
printing all the register states before

891
00:32:57,519 --> 00:33:01,039
and after for debugging purposes

892
00:33:01,039 --> 00:33:02,880
but we have now four times issued the

893
00:33:02,880 --> 00:33:05,200
vulnerable smc and let's check the

894
00:33:05,200 --> 00:33:07,039
secure memory again

895
00:33:07,039 --> 00:33:09,679
well we have actually unprotected the

896
00:33:09,679 --> 00:33:12,559
bl31

897
00:33:12,640 --> 00:33:15,279
memory rail the entire secure memory but

898
00:33:15,279 --> 00:33:17,200
this is the place where it stores its

899
00:33:17,200 --> 00:33:19,440
version number

900
00:33:19,440 --> 00:33:21,360
basically showing we have now from the

901
00:33:21,360 --> 00:33:24,000
non-secure site completely unrestricted

902
00:33:24,000 --> 00:33:27,279
access to the secure memory

903
00:33:33,440 --> 00:33:36,799
so what else can we find well

904
00:33:36,799 --> 00:33:38,399
let's take a look at the completely

905
00:33:38,399 --> 00:33:40,480
different low level firmware let's

906
00:33:40,480 --> 00:33:43,039
so we had a bit more looking at uh the

907
00:33:43,039 --> 00:33:46,720
rpm b1 um well we decided that after a

908
00:33:46,720 --> 00:33:49,440
while we wanted something else so we

909
00:33:49,440 --> 00:33:52,240
started looking at the htc people and

910
00:33:52,240 --> 00:33:54,080
the htc p1

911
00:33:54,080 --> 00:33:57,039
is a bit interesting so

912
00:33:57,039 --> 00:33:58,960
for some reason

913
00:33:58,960 --> 00:34:01,360
it allows you to configure an internet

914
00:34:01,360 --> 00:34:04,799
id which is somehow associated with how

915
00:34:04,799 --> 00:34:06,880
they handle the

916
00:34:06,880 --> 00:34:11,119
secure communication with the end device

917
00:34:12,079 --> 00:34:13,040
but

918
00:34:13,040 --> 00:34:15,199
the non-secure world is

919
00:34:15,199 --> 00:34:17,440
assigning which interrupt is being used

920
00:34:17,440 --> 00:34:19,520
for this or at least saying to this

921
00:34:19,520 --> 00:34:21,918
loadable firmware this is the hardware

922
00:34:21,918 --> 00:34:23,918
interrupt you have to use for this

923
00:34:23,918 --> 00:34:26,159
so we have an

924
00:34:26,159 --> 00:34:28,480
smc that allows us to specify this

925
00:34:28,480 --> 00:34:31,839
interrupt but then we have another smc

926
00:34:31,839 --> 00:34:34,000
that um

927
00:34:34,000 --> 00:34:36,719
is going to configure this smc in the

928
00:34:36,719 --> 00:34:40,239
hardware so what we will do is we will

929
00:34:40,239 --> 00:34:43,280
change in the gic the

930
00:34:43,280 --> 00:34:45,839
the generic interrupt controller that is

931
00:34:45,839 --> 00:34:49,280
basically a configurable

932
00:34:49,280 --> 00:34:50,239
yeah

933
00:34:50,239 --> 00:34:52,560
mechanism for how you want to route your

934
00:34:52,560 --> 00:34:54,320
interrupts and if you want to route them

935
00:34:54,320 --> 00:34:57,280
to the normal world or the secure world

936
00:34:57,280 --> 00:34:58,240
and

937
00:34:58,240 --> 00:35:00,640
we are going to change this based on the

938
00:35:00,640 --> 00:35:03,520
interrupt index we have specified

939
00:35:03,520 --> 00:35:05,839
by the normal world

940
00:35:05,839 --> 00:35:08,640
except we don't do any form of

941
00:35:08,640 --> 00:35:11,920
validation on it and we directly access

942
00:35:11,920 --> 00:35:15,119
the relevant hardware registers

943
00:35:15,119 --> 00:35:18,240
so what allows us to do that well

944
00:35:18,240 --> 00:35:21,200
because we are adding this internet

945
00:35:21,200 --> 00:35:23,920
index and we calculate which hardware

946
00:35:23,920 --> 00:35:26,000
register corresponds with a certain

947
00:35:26,000 --> 00:35:27,680
index by

948
00:35:27,680 --> 00:35:29,520
masking and shifting

949
00:35:29,520 --> 00:35:32,240
the index we actually get a right

950
00:35:32,240 --> 00:35:34,480
primitive in a part of the register

951
00:35:34,480 --> 00:35:36,800
space well actually it's sort of the

952
00:35:36,800 --> 00:35:39,760
entire register space except

953
00:35:39,760 --> 00:35:43,599
a small part at the very beginning

954
00:35:43,599 --> 00:35:46,079
what we can do with this is from four

955
00:35:46,079 --> 00:35:49,599
bytes we can selectively set one bit to

956
00:35:49,599 --> 00:35:52,320
a one we can decide which bit we want to

957
00:35:52,320 --> 00:35:54,880
set but it's only one bit

958
00:35:54,880 --> 00:35:55,839
um

959
00:35:55,839 --> 00:35:58,720
so what can we do

960
00:35:58,720 --> 00:36:00,960
the a bit of a challenge with this is is

961
00:36:00,960 --> 00:36:03,040
that we don't really

962
00:36:03,040 --> 00:36:05,839
have a very deep understanding how all

963
00:36:05,839 --> 00:36:08,240
the hardware registers work right it's

964
00:36:08,240 --> 00:36:09,680
not like that for

965
00:36:09,680 --> 00:36:12,160
socs like this that the registered

966
00:36:12,160 --> 00:36:15,599
documentation is freely available so

967
00:36:15,599 --> 00:36:17,680
what you want to do would mean full

968
00:36:17,680 --> 00:36:19,520
reverse engineering and of course things

969
00:36:19,520 --> 00:36:21,760
like linux kernel drivers can be very

970
00:36:21,760 --> 00:36:23,680
convenient for it but we want to have

971
00:36:23,680 --> 00:36:26,000
something that has an impact from like

972
00:36:26,000 --> 00:36:28,640
the secure side and basically meaning

973
00:36:28,640 --> 00:36:30,640
things that the linux kernel can access

974
00:36:30,640 --> 00:36:32,240
are probably not

975
00:36:32,240 --> 00:36:35,040
interesting from this perspective

976
00:36:35,040 --> 00:36:37,839
so what are we going to overwrite well

977
00:36:37,839 --> 00:36:39,599
we decided to just go for the teas at

978
00:36:39,599 --> 00:36:42,400
asc again it it is within

979
00:36:42,400 --> 00:36:44,880
it's within range

980
00:36:44,880 --> 00:36:46,640
but this time we actually set the high

981
00:36:46,640 --> 00:36:48,720
bit of the start address of

982
00:36:48,720 --> 00:36:50,160
the secure range

983
00:36:50,160 --> 00:36:52,640
effectively setting the start address

984
00:36:52,640 --> 00:36:54,560
after the end address

985
00:36:54,560 --> 00:36:56,640
again unprotecting

986
00:36:56,640 --> 00:36:59,520
the secure memory

987
00:36:59,520 --> 00:37:01,680
so

988
00:37:01,680 --> 00:37:03,359
how are these loadable firmwares

989
00:37:03,359 --> 00:37:06,320
actually loaded

990
00:37:06,320 --> 00:37:08,480
because well they are stored in a

991
00:37:08,480 --> 00:37:10,640
separate partition we have seen during

992
00:37:10,640 --> 00:37:13,040
the boot flow that um

993
00:37:13,040 --> 00:37:16,480
they will get loaded by blt31

994
00:37:16,480 --> 00:37:18,000
actually in collaboration with little

995
00:37:18,000 --> 00:37:19,280
kernel

996
00:37:19,280 --> 00:37:21,119
so how is this actually working and we

997
00:37:21,119 --> 00:37:23,760
started working on trying to reverse

998
00:37:23,760 --> 00:37:25,599
engineer this mechanism and try to get

999
00:37:25,599 --> 00:37:28,560
an understanding how this encrypted blob

1000
00:37:28,560 --> 00:37:31,119
of data is loaded and authenticated

1001
00:37:31,119 --> 00:37:33,440
maybe something interesting is going on

1002
00:37:33,440 --> 00:37:34,240
there

1003
00:37:34,240 --> 00:37:35,119
well

1004
00:37:35,119 --> 00:37:37,520
what happens is little kernel is doing

1005
00:37:37,520 --> 00:37:40,240
the load from the ufs puts it somewhere

1006
00:37:40,240 --> 00:37:43,119
in non-secure memory provide the pointer

1007
00:37:43,119 --> 00:37:46,000
through an smc to the secure world

1008
00:37:46,000 --> 00:37:48,880
to the monitor bl31 because

1009
00:37:48,880 --> 00:37:53,280
that's the one running at that moment

1010
00:37:53,359 --> 00:37:56,160
and then that smc will trigger the

1011
00:37:56,160 --> 00:37:59,119
signature verification the unpacking

1012
00:37:59,119 --> 00:38:02,800
the decryption put at the right location

1013
00:38:02,800 --> 00:38:05,280
in the secure memory

1014
00:38:05,280 --> 00:38:07,520
configure

1015
00:38:07,520 --> 00:38:09,200
or triggering an initialization

1016
00:38:09,200 --> 00:38:10,400
mechanism

1017
00:38:10,400 --> 00:38:12,720
however this smc

1018
00:38:12,720 --> 00:38:14,720
is this

1019
00:38:14,720 --> 00:38:16,640
only accessible during boot or is there

1020
00:38:16,640 --> 00:38:18,320
maybe something interesting also during

1021
00:38:18,320 --> 00:38:19,520
runtime

1022
00:38:19,520 --> 00:38:20,800
well

1023
00:38:20,800 --> 00:38:22,960
this is the smc

1024
00:38:22,960 --> 00:38:26,160
and this smc in bl31

1025
00:38:26,160 --> 00:38:28,320
it does the pointer check yeah so you

1026
00:38:28,320 --> 00:38:30,960
provide non-secure memory it will copy

1027
00:38:30,960 --> 00:38:32,720
in that memory

1028
00:38:32,720 --> 00:38:34,560
from the non-secure side to the secure

1029
00:38:34,560 --> 00:38:37,520
side because well while it is unpacking

1030
00:38:37,520 --> 00:38:38,880
it

1031
00:38:38,880 --> 00:38:40,880
you don't want that the non-secure site

1032
00:38:40,880 --> 00:38:42,640
can mess with it and maybe cause some

1033
00:38:42,640 --> 00:38:44,960
issues like some doctor issues

1034
00:38:44,960 --> 00:38:47,280
and then it will do a signature

1035
00:38:47,280 --> 00:38:51,920
verification either directly in the

1036
00:38:51,920 --> 00:38:55,200
in bl31 itself or if you have already

1037
00:38:55,200 --> 00:38:57,440
loaded your loadable firmware before you

1038
00:38:57,440 --> 00:39:00,079
can actually load it again and then you

1039
00:39:00,079 --> 00:39:01,839
will verify

1040
00:39:01,839 --> 00:39:04,960
the signature using the crypto manager

1041
00:39:04,960 --> 00:39:08,560
and if something fails you will erase

1042
00:39:08,560 --> 00:39:10,720
the secure memory

1043
00:39:10,720 --> 00:39:11,760
so

1044
00:39:11,760 --> 00:39:13,680
this is of course in

1045
00:39:13,680 --> 00:39:15,440
separate buffer right

1046
00:39:15,440 --> 00:39:16,880
so

1047
00:39:16,880 --> 00:39:18,240
you you

1048
00:39:18,240 --> 00:39:20,960
maybe don't dynamically allocate it but

1049
00:39:20,960 --> 00:39:23,520
during development you have said okay

1050
00:39:23,520 --> 00:39:25,599
this is the buffer that i'm going to

1051
00:39:25,599 --> 00:39:28,640
load my loadable firmware because well

1052
00:39:28,640 --> 00:39:31,119
if you can load it again

1053
00:39:31,119 --> 00:39:33,760
that's probably not the best idea

1054
00:39:33,760 --> 00:39:36,000
well

1055
00:39:36,640 --> 00:39:39,280
is it actually a separate buffer

1056
00:39:39,280 --> 00:39:42,079
so what happens if we try to send the

1057
00:39:42,079 --> 00:39:43,839
smc

1058
00:39:43,839 --> 00:39:46,800
even with just a blob of null bytes

1059
00:39:46,800 --> 00:39:48,240
well

1060
00:39:48,240 --> 00:39:52,000
we have the phone let's try

1061
00:39:53,280 --> 00:39:56,280
so

1062
00:39:58,079 --> 00:39:58,880
so

1063
00:39:58,880 --> 00:40:00,640
the phone is still the secure memory is

1064
00:40:00,640 --> 00:40:02,400
unprotected

1065
00:40:02,400 --> 00:40:05,119
sure we can directly poken it it's not

1066
00:40:05,119 --> 00:40:06,240
relevant

1067
00:40:06,240 --> 00:40:08,479
so

1068
00:40:09,599 --> 00:40:10,480
let's

1069
00:40:10,480 --> 00:40:11,520
fill

1070
00:40:11,520 --> 00:40:12,400
some

1071
00:40:12,400 --> 00:40:15,760
random location in non-secure memory

1072
00:40:15,760 --> 00:40:18,560
with null by

1073
00:40:20,319 --> 00:40:22,400
phone is happily

1074
00:40:22,400 --> 00:40:25,680
let's then actually trigger

1075
00:40:25,680 --> 00:40:26,880
the

1076
00:40:26,880 --> 00:40:29,359
smc

1077
00:40:32,240 --> 00:40:33,040
well

1078
00:40:33,040 --> 00:40:36,319
the phone instantly became unresponsive

1079
00:40:36,319 --> 00:40:38,800
and we can actually see the smc

1080
00:40:38,800 --> 00:40:40,800
in the previous smcs you saw it

1081
00:40:40,800 --> 00:40:43,359
returning and printing

1082
00:40:43,359 --> 00:40:46,160
like the register state after returning

1083
00:40:46,160 --> 00:40:48,319
in this case we cannot even get to that

1084
00:40:48,319 --> 00:40:50,480
point anymore so

1085
00:40:50,480 --> 00:40:53,599
what has happened here

1086
00:40:53,599 --> 00:40:55,280
and you will hear a beep in a moment

1087
00:40:55,280 --> 00:40:57,839
because um well the crash is silent and

1088
00:40:57,839 --> 00:40:59,119
the hardware

1089
00:40:59,119 --> 00:41:02,000
watchdog needs to kick in in a moment

1090
00:41:02,000 --> 00:41:05,880
and we'll restart the phone

1091
00:41:11,280 --> 00:41:14,400
so what happened well this was for sure

1092
00:41:14,400 --> 00:41:16,319
not a separate buffer

1093
00:41:16,319 --> 00:41:18,800
we were directly stamping over the

1094
00:41:18,800 --> 00:41:20,640
memory where the loadable firmware is

1095
00:41:20,640 --> 00:41:22,720
currently running from

1096
00:41:22,720 --> 00:41:23,920
of course

1097
00:41:23,920 --> 00:41:27,040
this is like an encrypted blob of data

1098
00:41:27,040 --> 00:41:29,920
an assigned blob of data and we are

1099
00:41:29,920 --> 00:41:32,160
going to verify the signature and this

1100
00:41:32,160 --> 00:41:35,119
signature unless we of course reload the

1101
00:41:35,119 --> 00:41:37,040
original loadable firmware this

1102
00:41:37,040 --> 00:41:38,800
signature is not going to match we

1103
00:41:38,800 --> 00:41:41,599
cannot force signatures

1104
00:41:41,599 --> 00:41:43,440
and when we fail

1105
00:41:43,440 --> 00:41:44,240
the

1106
00:41:44,240 --> 00:41:46,640
signature verification we're also going

1107
00:41:46,640 --> 00:41:49,280
to zero out that part of the memory we

1108
00:41:49,280 --> 00:41:51,119
have already filled it with zeros now it

1109
00:41:51,119 --> 00:41:53,440
doesn't really matter but

1110
00:41:53,440 --> 00:41:54,880
you have seen what happens with the

1111
00:41:54,880 --> 00:41:56,560
phone so

1112
00:41:56,560 --> 00:41:58,880
either we because we directly fill it

1113
00:41:58,880 --> 00:42:01,680
with servers or you try to put there

1114
00:42:01,680 --> 00:42:04,319
some real code it will zero it out the

1115
00:42:04,319 --> 00:42:06,640
phone will crash within a fraction of a

1116
00:42:06,640 --> 00:42:08,720
second because those loadable firmware

1117
00:42:08,720 --> 00:42:10,880
are in use

1118
00:42:10,880 --> 00:42:12,960
so

1119
00:42:12,960 --> 00:42:16,000
how can we prevent this zeroing out of

1120
00:42:16,000 --> 00:42:18,319
the after the signature verification

1121
00:42:18,319 --> 00:42:21,280
fail can we somehow bypass the signature

1122
00:42:21,280 --> 00:42:22,880
verification

1123
00:42:22,880 --> 00:42:25,119
we can maybe race it so

1124
00:42:25,119 --> 00:42:27,359
the segment of verification

1125
00:42:27,359 --> 00:42:28,560
it's quite a

1126
00:42:28,560 --> 00:42:30,960
significant amount of

1127
00:42:30,960 --> 00:42:34,960
code and data that needs to be verified

1128
00:42:35,040 --> 00:42:36,960
it will need to hash it it will use the

1129
00:42:36,960 --> 00:42:38,960
crypto engine for it it's relatively

1130
00:42:38,960 --> 00:42:42,839
fast but we can probably race it

1131
00:42:42,839 --> 00:42:46,079
um or is there maybe an easier way

1132
00:42:46,079 --> 00:42:47,839
because

1133
00:42:47,839 --> 00:42:50,319
remember

1134
00:42:53,040 --> 00:42:55,040
we had two ways of verifying this

1135
00:42:55,040 --> 00:42:56,400
signature

1136
00:42:56,400 --> 00:42:58,640
so if you load the loadable firmware for

1137
00:42:58,640 --> 00:42:59,920
the first time

1138
00:42:59,920 --> 00:43:03,440
we were loading verifying it using bl31

1139
00:43:03,440 --> 00:43:05,280
but if we had the loadable firmware

1140
00:43:05,280 --> 00:43:07,839
already loaded we were verifying it

1141
00:43:07,839 --> 00:43:09,839
using the crypto manager

1142
00:43:09,839 --> 00:43:12,079
and the crypto manager is a loadable

1143
00:43:12,079 --> 00:43:13,359
firmware

1144
00:43:13,359 --> 00:43:14,240
so

1145
00:43:14,240 --> 00:43:18,240
if we overwrite the loadable firmware by

1146
00:43:18,240 --> 00:43:19,680
what are

1147
00:43:19,680 --> 00:43:22,240
what code is doing the verification

1148
00:43:22,240 --> 00:43:23,440
well

1149
00:43:23,440 --> 00:43:26,480
actually we have replaced that complete

1150
00:43:26,480 --> 00:43:29,520
underlying code by overwriting the blob

1151
00:43:29,520 --> 00:43:32,160
and trigger the authentication we

1152
00:43:32,160 --> 00:43:34,880
actually automatically also trigger

1153
00:43:34,880 --> 00:43:37,599
jumping to the data that we have written

1154
00:43:37,599 --> 00:43:39,200
there

1155
00:43:39,200 --> 00:43:41,040
so

1156
00:43:41,040 --> 00:43:42,960
basically the only thing we have to do

1157
00:43:42,960 --> 00:43:44,240
is

1158
00:43:44,240 --> 00:43:46,319
the authentication smc

1159
00:43:46,319 --> 00:43:48,480
make it return yeah this signature is

1160
00:43:48,480 --> 00:43:50,160
perfectly valid

1161
00:43:50,160 --> 00:43:52,720
and you can completely replace the

1162
00:43:52,720 --> 00:43:55,040
loadable firmware at runtime it will not

1163
00:43:55,040 --> 00:43:57,680
be erased and now it's our code running

1164
00:43:57,680 --> 00:44:00,799
uploadable firmware

1165
00:44:01,920 --> 00:44:05,440
um what else do we have well

1166
00:44:05,440 --> 00:44:07,119
every system needs

1167
00:44:07,119 --> 00:44:08,560
debug information

1168
00:44:08,560 --> 00:44:10,240
if there is something that develop

1169
00:44:10,240 --> 00:44:12,720
developers love its debug information

1170
00:44:12,720 --> 00:44:15,200
and well i love debug information as

1171
00:44:15,200 --> 00:44:16,800
well

1172
00:44:16,800 --> 00:44:18,960
so

1173
00:44:19,599 --> 00:44:22,400
if you check after you boot up and you

1174
00:44:22,400 --> 00:44:25,040
grab the dms of your f21 or basically

1175
00:44:25,040 --> 00:44:28,160
any exynos based

1176
00:44:28,560 --> 00:44:31,119
phone you will see messages of something

1177
00:44:31,119 --> 00:44:34,240
called the seclock and this is really

1178
00:44:34,240 --> 00:44:39,279
doing what its name implies it is

1179
00:44:40,000 --> 00:44:41,760
getting the messages from the secure

1180
00:44:41,760 --> 00:44:44,319
world and putting them in the non-secure

1181
00:44:44,319 --> 00:44:46,480
dms of your linux kernel

1182
00:44:46,480 --> 00:44:50,079
so we have for example seen

1183
00:44:50,079 --> 00:44:52,400
about the rpmb the initialization the

1184
00:44:52,400 --> 00:44:54,240
registers from world shared memory the

1185
00:44:54,240 --> 00:44:56,240
non-secure site provide

1186
00:44:56,240 --> 00:44:58,000
the address where we want to have the

1187
00:44:58,000 --> 00:44:59,920
shared memory well

1188
00:44:59,920 --> 00:45:01,839
the loadable firmware is nicely saying a

1189
00:45:01,839 --> 00:45:03,599
message i have registered your shared

1190
00:45:03,599 --> 00:45:06,000
memory and here you can find it

1191
00:45:06,000 --> 00:45:08,319
well how is this actually working

1192
00:45:08,319 --> 00:45:09,520
because

1193
00:45:09,520 --> 00:45:11,359
how is it possible that something from

1194
00:45:11,359 --> 00:45:13,520
the secure world can write to the kernel

1195
00:45:13,520 --> 00:45:16,560
lock on the non-secure side well

1196
00:45:16,560 --> 00:45:18,800
this mechanism the secure lock is

1197
00:45:18,800 --> 00:45:20,720
basically a set of ring buffers that are

1198
00:45:20,720 --> 00:45:23,359
shared between the secure and non-secure

1199
00:45:23,359 --> 00:45:24,400
site

1200
00:45:24,400 --> 00:45:27,359
and we have then a kernel driver

1201
00:45:27,359 --> 00:45:29,280
running

1202
00:45:29,280 --> 00:45:32,000
in the handle on the linux side that

1203
00:45:32,000 --> 00:45:34,160
basically takes the data from this ring

1204
00:45:34,160 --> 00:45:36,079
buffer and will then

1205
00:45:36,079 --> 00:45:37,920
k-print them to

1206
00:45:37,920 --> 00:45:39,920
the kernel lock

1207
00:45:39,920 --> 00:45:42,640
and that way this is how they show up in

1208
00:45:42,640 --> 00:45:45,118
dms

1209
00:45:45,359 --> 00:45:48,960
for i guess convenience we have per cpu

1210
00:45:48,960 --> 00:45:50,079
core

1211
00:45:50,079 --> 00:45:52,640
a separate ring buffer probably also to

1212
00:45:52,640 --> 00:45:53,680
not have to

1213
00:45:53,680 --> 00:45:55,520
too many issues with

1214
00:45:55,520 --> 00:45:58,319
concurrency locking and similar kinds of

1215
00:45:58,319 --> 00:46:00,319
problems which can get a bit hairy if

1216
00:46:00,319 --> 00:46:01,839
you have to do it across a security

1217
00:46:01,839 --> 00:46:03,920
boundary

1218
00:46:03,920 --> 00:46:06,160
so

1219
00:46:06,800 --> 00:46:10,640
we have here our smc handler we register

1220
00:46:10,640 --> 00:46:12,560
our message and we call well we have

1221
00:46:12,560 --> 00:46:14,560
called it printf we have no idea how

1222
00:46:14,560 --> 00:46:18,079
this function is originally called

1223
00:46:18,079 --> 00:46:19,040
what is

1224
00:46:19,040 --> 00:46:21,280
shared in our ring buffer is defined by

1225
00:46:21,280 --> 00:46:23,040
this structure and what we have is

1226
00:46:23,040 --> 00:46:25,680
basically a right counter a read counter

1227
00:46:25,680 --> 00:46:28,640
a base address and a two flex so one of

1228
00:46:28,640 --> 00:46:31,760
them is like the buffer is full so the

1229
00:46:31,760 --> 00:46:33,599
linux kernel was not fast enough in

1230
00:46:33,599 --> 00:46:36,560
picking up new messages and something

1231
00:46:36,560 --> 00:46:39,200
about that this system got blocked for

1232
00:46:39,200 --> 00:46:41,760
whatever reason

1233
00:46:41,760 --> 00:46:43,599
now of course we properly validated

1234
00:46:43,599 --> 00:46:45,440
information right because we share it

1235
00:46:45,440 --> 00:46:47,440
across the security boundary from the

1236
00:46:47,440 --> 00:46:49,839
normal world to the secure world both

1237
00:46:49,839 --> 00:46:51,359
the normal world and the secure world

1238
00:46:51,359 --> 00:46:52,960
are dealing with this information

1239
00:46:52,960 --> 00:46:54,480
changing the lead counter changing the

1240
00:46:54,480 --> 00:46:56,720
right counter this is perfectly

1241
00:46:56,720 --> 00:46:58,720
validated right

1242
00:46:58,720 --> 00:47:00,960
so let's take a look at how printf is

1243
00:47:00,960 --> 00:47:03,359
actually implemented

1244
00:47:03,359 --> 00:47:06,000
we start with based on on this score we

1245
00:47:06,000 --> 00:47:08,480
are running getting the address of our

1246
00:47:08,480 --> 00:47:11,680
ring buffer and in log info we are now

1247
00:47:11,680 --> 00:47:15,119
pointing directly into memory that is

1248
00:47:15,119 --> 00:47:17,280
non-secure

1249
00:47:17,280 --> 00:47:18,960
and what do we get from that well we get

1250
00:47:18,960 --> 00:47:20,960
the right counter because well we are

1251
00:47:20,960 --> 00:47:23,119
going to add messages to the ring buffer

1252
00:47:23,119 --> 00:47:26,000
and we have our base address

1253
00:47:26,000 --> 00:47:28,000
and then we calculate based on the right

1254
00:47:28,000 --> 00:47:30,079
counter and the base address where we

1255
00:47:30,079 --> 00:47:31,920
are going to write

1256
00:47:31,920 --> 00:47:34,720
and we write the message there

1257
00:47:34,720 --> 00:47:37,119
but what is missing

1258
00:47:37,119 --> 00:47:39,440
that is the check that we don't specify

1259
00:47:39,440 --> 00:47:41,760
an overly big right counter that is the

1260
00:47:41,760 --> 00:47:42,559
check

1261
00:47:42,559 --> 00:47:47,200
for the base address well it's not there

1262
00:47:47,200 --> 00:47:49,280
so

1263
00:47:49,280 --> 00:47:51,440
the ring buffers are

1264
00:47:51,440 --> 00:47:55,079
at c3000

1265
00:47:55,920 --> 00:47:59,359
one of for each score they get in

1266
00:47:59,359 --> 00:48:02,000
incremented addresses by roughly 10 000

1267
00:48:02,000 --> 00:48:04,319
hex

1268
00:48:04,400 --> 00:48:06,960
we use our driver to directly poke in

1269
00:48:06,960 --> 00:48:08,160
that

1270
00:48:08,160 --> 00:48:09,760
in that memory

1271
00:48:09,760 --> 00:48:11,599
and what we basically do

1272
00:48:11,599 --> 00:48:13,119
is

1273
00:48:13,119 --> 00:48:15,760
we set both the read counter and the

1274
00:48:15,760 --> 00:48:18,400
right counter to zero so

1275
00:48:18,400 --> 00:48:21,280
effectively the ring buffer is empty

1276
00:48:21,280 --> 00:48:23,920
and we change the base address

1277
00:48:23,920 --> 00:48:25,920
where the lock message is being written

1278
00:48:25,920 --> 00:48:27,599
to well

1279
00:48:27,599 --> 00:48:29,119
i don't know if you recognize this

1280
00:48:29,119 --> 00:48:30,319
address

1281
00:48:30,319 --> 00:48:31,599
but

1282
00:48:31,599 --> 00:48:34,640
this is the tz isc

1283
00:48:34,640 --> 00:48:36,160
one thing

1284
00:48:36,160 --> 00:48:39,520
we need to be quickly restore it

1285
00:48:39,520 --> 00:48:41,200
strictly speaking it's not needed you

1286
00:48:41,200 --> 00:48:44,400
can also unload the kernel module

1287
00:48:44,400 --> 00:48:46,480
but if you don't want to mess too much

1288
00:48:46,480 --> 00:48:48,480
with the system if you quickly restore

1289
00:48:48,480 --> 00:48:50,880
the original information you have a

1290
00:48:50,880 --> 00:48:53,200
pretty high chance that you are not

1291
00:48:53,200 --> 00:48:55,280
crashing the system at least as long as

1292
00:48:55,280 --> 00:48:56,960
you are not doing it too early after

1293
00:48:56,960 --> 00:48:59,119
boot because then the system is still

1294
00:48:59,119 --> 00:49:01,440
quite actively writing messages to the

1295
00:49:01,440 --> 00:49:03,839
sec lock

1296
00:49:06,480 --> 00:49:08,160
one thing

1297
00:49:08,160 --> 00:49:10,160
the ring buffers are core specific so we

1298
00:49:10,160 --> 00:49:12,240
need to pin our process

1299
00:49:12,240 --> 00:49:14,559
to a specific core or we need to change

1300
00:49:14,559 --> 00:49:17,839
all ring buffers

1301
00:49:25,599 --> 00:49:27,119
well the phone rebooted from the

1302
00:49:27,119 --> 00:49:28,720
previous

1303
00:49:28,720 --> 00:49:31,040
demo which is exactly why that was a

1304
00:49:31,040 --> 00:49:32,480
crash demo and not something else

1305
00:49:32,480 --> 00:49:33,680
because otherwise i would forget to

1306
00:49:33,680 --> 00:49:36,240
reboot it

1307
00:49:41,599 --> 00:49:45,640
well i forgot to show you

1308
00:49:45,920 --> 00:49:47,839
that we cannot access the secure memory

1309
00:49:47,839 --> 00:49:50,400
yet but you have to trust me on that

1310
00:49:50,400 --> 00:49:52,400
because what you can see is we have only

1311
00:49:52,400 --> 00:49:55,599
protected one t-set asc this time not

1312
00:49:55,599 --> 00:49:57,920
all four of them we can simply repeat

1313
00:49:57,920 --> 00:50:00,720
this four times and

1314
00:50:00,720 --> 00:50:02,960
unprotect all of them what we could also

1315
00:50:02,960 --> 00:50:06,559
do is we have access to a quarter of

1316
00:50:06,559 --> 00:50:09,040
the secure memory code and data so we

1317
00:50:09,040 --> 00:50:10,640
can also

1318
00:50:10,640 --> 00:50:13,920
simply change the code of a few smc's

1319
00:50:13,920 --> 00:50:16,960
that are exactly within this quarter of

1320
00:50:16,960 --> 00:50:20,160
the memory that we have unprotected

1321
00:50:20,160 --> 00:50:21,599
and that way

1322
00:50:21,599 --> 00:50:25,720
further compromise the system

1323
00:50:32,880 --> 00:50:33,839
well

1324
00:50:33,839 --> 00:50:35,680
that brings us to the end

1325
00:50:35,680 --> 00:50:37,119
um

1326
00:50:37,119 --> 00:50:40,079
the loadable firmware is really critical

1327
00:50:40,079 --> 00:50:42,960
in samsung's security model it is so

1328
00:50:42,960 --> 00:50:46,559
privileged and also

1329
00:50:50,640 --> 00:50:53,520
and it's this attack service is not only

1330
00:50:53,520 --> 00:50:55,760
on the secure side it's

1331
00:50:55,760 --> 00:50:58,400
actually both to the secure side and the

1332
00:50:58,400 --> 00:51:00,800
non-secure side of course you need

1333
00:51:00,800 --> 00:51:02,720
kernel level privileges

1334
00:51:02,720 --> 00:51:04,640
to reach this smc instruction because

1335
00:51:04,640 --> 00:51:06,720
well by default

1336
00:51:06,720 --> 00:51:08,800
there is no driver going to give you

1337
00:51:08,800 --> 00:51:11,040
that i'm not sure that for this audience

1338
00:51:11,040 --> 00:51:14,960
that's an overcomable obstacle

1339
00:51:15,440 --> 00:51:17,920
we found some critical vulnerabilities

1340
00:51:17,920 --> 00:51:19,680
we have a few more in the disclosure

1341
00:51:19,680 --> 00:51:21,200
process

1342
00:51:21,200 --> 00:51:23,680
and what is particularly interesting is

1343
00:51:23,680 --> 00:51:27,200
actually the simplicity of these bugs

1344
00:51:27,200 --> 00:51:30,079
the obstacle is that this is encrypted

1345
00:51:30,079 --> 00:51:32,480
not because this is some

1346
00:51:32,480 --> 00:51:34,720
super

1347
00:51:34,720 --> 00:51:37,200
crazy exploit that

1348
00:51:37,200 --> 00:51:39,119
you need to study for i don't know how

1349
00:51:39,119 --> 00:51:42,160
long it are relatively simple attacks

1350
00:51:42,160 --> 00:51:44,559
however the barrier for actually getting

1351
00:51:44,559 --> 00:51:46,079
to this is

1352
00:51:46,079 --> 00:51:49,920
high and that um you notice that

1353
00:51:49,920 --> 00:51:51,680
when you are looking at this type of

1354
00:51:51,680 --> 00:51:53,359
code

1355
00:51:53,359 --> 00:51:54,960
and for the people that have samsung

1356
00:51:54,960 --> 00:51:57,520
devices i would say update and also keep

1357
00:51:57,520 --> 00:51:58,720
your update

1358
00:51:58,720 --> 00:52:01,680
in the coming months

1359
00:52:02,640 --> 00:52:03,760
anyway

1360
00:52:03,760 --> 00:52:05,599
that's the presentation i hope you liked

1361
00:52:05,599 --> 00:52:08,640
it if you have questions please ask them

1362
00:52:08,640 --> 00:52:10,800
otherwise feel free to come to us we

1363
00:52:10,800 --> 00:52:14,000
will be around for well the rest of the

1364
00:52:14,000 --> 00:52:17,480
these two days

