1
00:00:00,080 --> 00:00:02,639
yeah welcome to our talk rage against

2
00:00:02,639 --> 00:00:04,640
the machine clear

3
00:00:04,640 --> 00:00:06,879
it will be about the

4
00:00:06,879 --> 00:00:09,440
machine clear transient execution

5
00:00:09,440 --> 00:00:12,639
vulnerabilities that we have found

6
00:00:12,639 --> 00:00:13,840
here we see

7
00:00:13,840 --> 00:00:15,360
some strange corner case of modern

8
00:00:15,360 --> 00:00:16,560
processors

9
00:00:16,560 --> 00:00:18,400
and we managed to

10
00:00:18,400 --> 00:00:19,920
to exploit them

11
00:00:19,920 --> 00:00:23,600
we also present a full and exploit later

12
00:00:23,600 --> 00:00:25,439
in the presentation

13
00:00:25,439 --> 00:00:27,519
running on firefox

14
00:00:27,519 --> 00:00:29,199
but before that

15
00:00:29,199 --> 00:00:30,880
just a presentation

16
00:00:30,880 --> 00:00:32,960
so i am enrico

17
00:00:32,960 --> 00:00:34,480
i made this work with

18
00:00:34,480 --> 00:00:35,360
the

19
00:00:35,360 --> 00:00:37,120
my colleague hani raghav that will speak

20
00:00:37,120 --> 00:00:38,160
later

21
00:00:38,160 --> 00:00:39,760
and also with the help of herbert and

22
00:00:39,760 --> 00:00:41,120
cristiano

23
00:00:41,120 --> 00:00:44,000
and all of us are coming from the rusev

24
00:00:44,000 --> 00:00:47,600
system security group in amsterdam

25
00:00:47,600 --> 00:00:49,039
and

26
00:00:49,039 --> 00:00:50,879
the talk today will be splitted as

27
00:00:50,879 --> 00:00:52,239
follow mainly

28
00:00:52,239 --> 00:00:54,800
we start with a small background section

29
00:00:54,800 --> 00:00:56,160
then we

30
00:00:56,160 --> 00:00:57,520
we have the core of the presentation

31
00:00:57,520 --> 00:00:59,680
that is about machine clears

32
00:00:59,680 --> 00:01:02,239
uh also later we're going to present the

33
00:01:02,239 --> 00:01:04,400
full endpoint exploit

34
00:01:04,400 --> 00:01:07,520
on firefox and finally some conclusion

35
00:01:07,520 --> 00:01:10,320
and results

36
00:01:10,320 --> 00:01:13,840
okay let's start uh with something funny

37
00:01:13,840 --> 00:01:14,960
uh

38
00:01:14,960 --> 00:01:16,320
just by looking at this image you can

39
00:01:16,320 --> 00:01:17,360
see

40
00:01:17,360 --> 00:01:19,600
something is odd we see

41
00:01:19,600 --> 00:01:22,640
a roof with metals with with the

42
00:01:22,640 --> 00:01:24,240
melted snow

43
00:01:24,240 --> 00:01:25,200
and

44
00:01:25,200 --> 00:01:26,479
you know

45
00:01:26,479 --> 00:01:28,400
just by walking on the street and seeing

46
00:01:28,400 --> 00:01:29,360
this

47
00:01:29,360 --> 00:01:31,439
is suspicious right

48
00:01:31,439 --> 00:01:32,799
and

49
00:01:32,799 --> 00:01:34,560
we think that this is a perfect example

50
00:01:34,560 --> 00:01:36,479
of a side channel

51
00:01:36,479 --> 00:01:38,880
because here the

52
00:01:38,880 --> 00:01:41,280
dutch police managed to find guys

53
00:01:41,280 --> 00:01:43,360
growing legally with the

54
00:01:43,360 --> 00:01:44,880
in their apartment

55
00:01:44,880 --> 00:01:47,360
just by looking at the roof because as

56
00:01:47,360 --> 00:01:49,360
you can guess the high temperature was

57
00:01:49,360 --> 00:01:50,799
melting there's no

58
00:01:50,799 --> 00:01:51,759
and

59
00:01:51,759 --> 00:01:54,479
yeah they just caught these uh these

60
00:01:54,479 --> 00:01:55,360
guys

61
00:01:55,360 --> 00:01:57,200
with assay channel okay so they don't

62
00:01:57,200 --> 00:01:58,079
see

63
00:01:58,079 --> 00:02:00,240
people grow with but just by the

64
00:02:00,240 --> 00:02:03,040
methods nobody they managed to

65
00:02:03,040 --> 00:02:05,520
guess that

66
00:02:05,600 --> 00:02:07,840
however today we're not talking about

67
00:02:07,840 --> 00:02:10,959
weed side channel but cpu is a channel

68
00:02:10,959 --> 00:02:12,160
so

69
00:02:12,160 --> 00:02:13,840
the most famous one

70
00:02:13,840 --> 00:02:16,239
and also easy to to use

71
00:02:16,239 --> 00:02:19,040
is to use a timing side channel and not

72
00:02:19,040 --> 00:02:19,840
the

73
00:02:19,840 --> 00:02:22,640
for example before a thermal channel

74
00:02:22,640 --> 00:02:23,440
and

75
00:02:23,440 --> 00:02:25,520
it's kind of simple in the end so

76
00:02:25,520 --> 00:02:27,120
here we have an example where we have an

77
00:02:27,120 --> 00:02:28,879
attacker and a victim

78
00:02:28,879 --> 00:02:31,280
and they share a common resource for

79
00:02:31,280 --> 00:02:33,599
example the array that you can see on

80
00:02:33,599 --> 00:02:35,440
the bottom

81
00:02:35,440 --> 00:02:38,560
the first step is to bring the

82
00:02:38,560 --> 00:02:40,000
this shared resource

83
00:02:40,000 --> 00:02:42,640
also in the data cache in a known state

84
00:02:42,640 --> 00:02:45,920
for example by flashing the entire cache

85
00:02:45,920 --> 00:02:48,160
so we know that every entry of the array

86
00:02:48,160 --> 00:02:51,360
is not present in the cache

87
00:02:51,360 --> 00:02:54,239
later the big team for example

88
00:02:54,239 --> 00:02:55,840
will access

89
00:02:55,840 --> 00:02:58,000
some array entries depending on a secret

90
00:02:58,000 --> 00:02:58,959
bit

91
00:02:58,959 --> 00:03:01,680
and let's say that for example

92
00:03:01,680 --> 00:03:05,200
the secret key bit is uh is one so we

93
00:03:05,200 --> 00:03:09,440
are accessing entry one okay

94
00:03:09,599 --> 00:03:12,159
later the attacker just need to perform

95
00:03:12,159 --> 00:03:14,800
the reload step that is simply measuring

96
00:03:14,800 --> 00:03:18,480
the log time of every array entry

97
00:03:18,480 --> 00:03:20,319
and as you can expect the first dot will

98
00:03:20,319 --> 00:03:22,239
be quite slow because already 0 is not

99
00:03:22,239 --> 00:03:23,440
in the cache

100
00:03:23,440 --> 00:03:25,360
the second one will be much faster

101
00:03:25,360 --> 00:03:27,519
because the victim already brought into

102
00:03:27,519 --> 00:03:28,640
the cache

103
00:03:28,640 --> 00:03:30,720
the first entry of the array and the

104
00:03:30,720 --> 00:03:33,120
others will be also slow

105
00:03:33,120 --> 00:03:35,760
so by observing the this timing side

106
00:03:35,760 --> 00:03:37,440
channel so this timing difference of

107
00:03:37,440 --> 00:03:38,879
float operation

108
00:03:38,879 --> 00:03:40,640
we can interfere that

109
00:03:40,640 --> 00:03:42,799
uh we can appear that the the victim

110
00:03:42,799 --> 00:03:44,720
actually

111
00:03:44,720 --> 00:03:45,519
the

112
00:03:45,519 --> 00:03:49,440
at position i was equal to one

113
00:03:49,519 --> 00:03:51,599
things get extremely interesting when we

114
00:03:51,599 --> 00:03:53,920
combine this timing say channel

115
00:03:53,920 --> 00:03:56,080
with transient execution or speculative

116
00:03:56,080 --> 00:03:58,319
execution

117
00:03:58,319 --> 00:04:00,959
so modern processors try to predict the

118
00:04:00,959 --> 00:04:03,040
the flow of the program to increase the

119
00:04:03,040 --> 00:04:04,319
throughput

120
00:04:04,319 --> 00:04:06,560
and probably you know there are the

121
00:04:06,560 --> 00:04:08,080
branch predictor

122
00:04:08,080 --> 00:04:09,760
and let's look at this simple example

123
00:04:09,760 --> 00:04:11,120
let's suppose that

124
00:04:11,120 --> 00:04:13,120
we have an if condition where we need to

125
00:04:13,120 --> 00:04:14,400
execute the branch

126
00:04:14,400 --> 00:04:17,120
only if we are inbound okay

127
00:04:17,120 --> 00:04:19,519
and let's imagine that the array size

128
00:04:19,519 --> 00:04:21,839
is not available because for example is

129
00:04:21,839 --> 00:04:23,120
coming from

130
00:04:23,120 --> 00:04:25,120
a slow load operation

131
00:04:25,120 --> 00:04:28,160
the processor for sure will not wait to

132
00:04:28,160 --> 00:04:30,720
know the resize it will speculatively

133
00:04:30,720 --> 00:04:32,880
execute the branch

134
00:04:32,880 --> 00:04:33,919
and

135
00:04:33,919 --> 00:04:36,320
if this happens

136
00:04:36,320 --> 00:04:38,240
this load will be speculatively executed

137
00:04:38,240 --> 00:04:39,440
for example

138
00:04:39,440 --> 00:04:41,199
and

139
00:04:41,199 --> 00:04:44,080
the the cache will be populated

140
00:04:44,080 --> 00:04:46,720
with array at position x

141
00:04:46,720 --> 00:04:48,080
let's suppose that in the end this

142
00:04:48,080 --> 00:04:50,560
branch prediction was wrong

143
00:04:50,560 --> 00:04:52,960
uh the processor must uh you know

144
00:04:52,960 --> 00:04:55,120
destroy all these uh wrong path in the

145
00:04:55,120 --> 00:04:57,280
pipeline and restart the execution from

146
00:04:57,280 --> 00:04:59,120
the correct path

147
00:04:59,120 --> 00:05:00,240
however

148
00:05:00,240 --> 00:05:03,280
this micro architectural trace so this

149
00:05:03,280 --> 00:05:05,759
access to array x

150
00:05:05,759 --> 00:05:08,639
was it happened okay it's still there

151
00:05:08,639 --> 00:05:10,639
and an attacker using again his

152
00:05:10,639 --> 00:05:13,360
timing side channel can observe what the

153
00:05:13,360 --> 00:05:14,880
processor did

154
00:05:14,880 --> 00:05:18,960
in a wrongly speculated branch

155
00:05:18,960 --> 00:05:21,280
so the rest is basically history as you

156
00:05:21,280 --> 00:05:23,759
can see this is a timeline of all the

157
00:05:23,759 --> 00:05:25,919
attacks that are based on these two

158
00:05:25,919 --> 00:05:27,520
simple primitives

159
00:05:27,520 --> 00:05:30,960
we start with early 2018 with the famous

160
00:05:30,960 --> 00:05:33,120
spectra and meltdown

161
00:05:33,120 --> 00:05:34,800
then later we had the

162
00:05:34,800 --> 00:05:38,320
l1 terminal fault it was quite powerful

163
00:05:38,320 --> 00:05:41,360
then in 2018 with the big class of micro

164
00:05:41,360 --> 00:05:43,360
architectural data sampling

165
00:05:43,360 --> 00:05:45,360
with many variants as you can see

166
00:05:45,360 --> 00:05:46,560
leaking from

167
00:05:46,560 --> 00:05:48,080
different buffers

168
00:05:48,080 --> 00:05:50,240
we also had the first injection attacks

169
00:05:50,240 --> 00:05:52,880
the load-bearing injection

170
00:05:52,880 --> 00:05:54,639
and even

171
00:05:54,639 --> 00:05:58,080
kind of recent the crosstalk attack

172
00:05:58,080 --> 00:06:00,240
even broke the barrier of the single car

173
00:06:00,240 --> 00:06:02,479
so these attacks were even working

174
00:06:02,479 --> 00:06:05,840
among physical different

175
00:06:05,840 --> 00:06:08,080
and now in this talk representing the

176
00:06:08,080 --> 00:06:10,479
let's say us transit execution attacks

177
00:06:10,479 --> 00:06:12,000
that are based on machine clearance on

178
00:06:12,000 --> 00:06:14,160
the topic of today

179
00:06:14,160 --> 00:06:16,720
and we managed to find two

180
00:06:16,720 --> 00:06:18,080
vulnerabilities

181
00:06:18,080 --> 00:06:19,840
named the floating point with injection

182
00:06:19,840 --> 00:06:22,479
and speculative called storable pass

183
00:06:22,479 --> 00:06:26,080
now leave the the word to ani

184
00:06:29,440 --> 00:06:31,360
all right so before getting into the

185
00:06:31,360 --> 00:06:32,479
different attacks that we're presenting

186
00:06:32,479 --> 00:06:35,199
today let's take a step back and look at

187
00:06:35,199 --> 00:06:37,520
what is the root cause of all these

188
00:06:37,520 --> 00:06:39,919
different type of transit execution

189
00:06:39,919 --> 00:06:41,440
vulnerabilities that have been found so

190
00:06:41,440 --> 00:06:44,479
far and intel defines bad speculation as

191
00:06:44,479 --> 00:06:46,400
the root cause of discarding issue

192
00:06:46,400 --> 00:06:49,440
issued operations on x86 processors and

193
00:06:49,440 --> 00:06:51,199
it also defines that there are two main

194
00:06:51,199 --> 00:06:53,199
subclasses of this behavior the first

195
00:06:53,199 --> 00:06:55,280
one is called branch misprediction where

196
00:06:55,280 --> 00:06:57,039
a parent predictor mispredicts either

197
00:06:57,039 --> 00:06:58,400
the direction

198
00:06:58,400 --> 00:07:00,479
or the target of a branch as we saw

199
00:07:00,479 --> 00:07:01,680
earlier

200
00:07:01,680 --> 00:07:03,840
and the second subclass of bad

201
00:07:03,840 --> 00:07:05,599
speculation is called machine clear

202
00:07:05,599 --> 00:07:08,639
where a machine clear condition flushes

203
00:07:08,639 --> 00:07:11,520
the entire pipeline and then the cpu

204
00:07:11,520 --> 00:07:12,880
resumes the execution from the last

205
00:07:12,880 --> 00:07:14,479
retired instruction so it's not just

206
00:07:14,479 --> 00:07:16,560
about a mispredicted branch but it's the

207
00:07:16,560 --> 00:07:18,560
entire pipeline once the machine clear

208
00:07:18,560 --> 00:07:20,639
condition occurs

209
00:07:20,639 --> 00:07:22,880
so as we said branch piece prediction

210
00:07:22,880 --> 00:07:24,160
have been widely

211
00:07:24,160 --> 00:07:26,080
explored in previous attacks like

212
00:07:26,080 --> 00:07:28,319
spectre and along with different ways of

213
00:07:28,319 --> 00:07:30,960
creating falls and different ways of

214
00:07:30,960 --> 00:07:32,639
upboarding an intel

215
00:07:32,639 --> 00:07:33,680
tsx

216
00:07:33,680 --> 00:07:35,919
transaction many attacks have been

217
00:07:35,919 --> 00:07:37,919
focused only on these variants of these

218
00:07:37,919 --> 00:07:40,240
root causes but the same cannot be said

219
00:07:40,240 --> 00:07:42,800
about the class of machine clear where

220
00:07:42,800 --> 00:07:45,199
up until to this work it remains widely

221
00:07:45,199 --> 00:07:46,960
unexplored and this is what we are going

222
00:07:46,960 --> 00:07:50,160
to uh to explain in this presentation

223
00:07:50,160 --> 00:07:52,240
so in this work we're going to uh we

224
00:07:52,240 --> 00:07:54,000
perform the reverse engineering and the

225
00:07:54,000 --> 00:07:56,240
security analysis of four main types

226
00:07:56,240 --> 00:07:57,759
four different root causes that can

227
00:07:57,759 --> 00:08:00,160
create a transit execution path

228
00:08:00,160 --> 00:08:02,879
uh on modern cpus and the first one is

229
00:08:02,879 --> 00:08:04,080
called cell phone defined code machine

230
00:08:04,080 --> 00:08:06,160
clear then we have floating point memory

231
00:08:06,160 --> 00:08:09,680
ordering and memory's ambiguation clear

232
00:08:09,680 --> 00:08:12,000
two of these led us to obtain

233
00:08:12,000 --> 00:08:14,319
two new transit execution based attack

234
00:08:14,319 --> 00:08:16,160
primitives the first one is called

235
00:08:16,160 --> 00:08:18,240
speculative code store bypass which is

236
00:08:18,240 --> 00:08:20,319
based on a self-modified machine clear

237
00:08:20,319 --> 00:08:21,840
and the second was called floating point

238
00:08:21,840 --> 00:08:23,919
value injection which is based on a

239
00:08:23,919 --> 00:08:27,120
floating point machine clear

240
00:08:27,120 --> 00:08:28,720
furthermore floating point value

241
00:08:28,720 --> 00:08:30,319
injection led us to

242
00:08:30,319 --> 00:08:33,120
obtain and mount an end-to-end attack on

243
00:08:33,120 --> 00:08:35,360
firefox leaking advertising memory

244
00:08:35,360 --> 00:08:36,958
addresses with a leakage rate that can

245
00:08:36,958 --> 00:08:38,880
reach 13 kilobytes per second and this

246
00:08:38,880 --> 00:08:40,880
is what we're going to see later in

247
00:08:40,880 --> 00:08:42,640
details

248
00:08:42,640 --> 00:08:44,720
so in order to understand more the

249
00:08:44,720 --> 00:08:47,200
different types of machine clear that

250
00:08:47,200 --> 00:08:49,440
we're talking about today we first try

251
00:08:49,440 --> 00:08:51,839
to understand what is the architectural

252
00:08:51,839 --> 00:08:53,600
invariant at the core of each type of

253
00:08:53,600 --> 00:08:55,440
machine clear

254
00:08:55,440 --> 00:08:57,839
then how this event can be violated and

255
00:08:57,839 --> 00:09:00,000
therefore triggering the machine clear

256
00:09:00,000 --> 00:09:01,920
or the pipeline flush

257
00:09:01,920 --> 00:09:03,760
then what is the what are the security

258
00:09:03,760 --> 00:09:05,760
implications of

259
00:09:05,760 --> 00:09:08,399
this invariant violation and finally how

260
00:09:08,399 --> 00:09:10,399
this violation can be exploited and

261
00:09:10,399 --> 00:09:12,080
these are the four points that we're

262
00:09:12,080 --> 00:09:14,399
going to focus on when we are studying

263
00:09:14,399 --> 00:09:15,519
the different types of machine clear

264
00:09:15,519 --> 00:09:17,519
that we're presenting

265
00:09:17,519 --> 00:09:19,040
so the first type that we're talking

266
00:09:19,040 --> 00:09:20,480
about today is called self-modifying

267
00:09:20,480 --> 00:09:22,880
code machine clear and it's based on a

268
00:09:22,880 --> 00:09:24,080
self-modifying code what is a

269
00:09:24,080 --> 00:09:25,600
self-modifying code it's a program

270
00:09:25,600 --> 00:09:27,839
storing instructions as data

271
00:09:27,839 --> 00:09:29,440
modifying its own code as it's being

272
00:09:29,440 --> 00:09:31,839
exceeded it has been widely used and

273
00:09:31,839 --> 00:09:33,440
malware is trying to impact themselves

274
00:09:33,440 --> 00:09:35,920
when it's a right moment that's just one

275
00:09:35,920 --> 00:09:37,920
example but here we are going to see a

276
00:09:37,920 --> 00:09:39,120
cell phone frame code in a completely

277
00:09:39,120 --> 00:09:40,399
different

278
00:09:40,399 --> 00:09:41,839
way

279
00:09:41,839 --> 00:09:44,000
so let's take a look at this snippet of

280
00:09:44,000 --> 00:09:46,560
code we have two instructions the first

281
00:09:46,560 --> 00:09:49,120
one is modifying the following one

282
00:09:49,120 --> 00:09:51,920
changing it from a load secret to an

283
00:09:51,920 --> 00:09:54,320
operation

284
00:09:54,320 --> 00:09:56,640
modern front end in modern x86

285
00:09:56,640 --> 00:09:58,800
processors in order to maximize the

286
00:09:58,800 --> 00:10:01,519
execution throughput they speculatively

287
00:10:01,519 --> 00:10:03,839
fetch the code and execute well ahead of

288
00:10:03,839 --> 00:10:05,040
retirement

289
00:10:05,040 --> 00:10:06,959
so what happens once the front end of a

290
00:10:06,959 --> 00:10:09,200
modern cpus encounters a self-refined

291
00:10:09,200 --> 00:10:11,519
code

292
00:10:11,839 --> 00:10:14,560
since it already speculatedly

293
00:10:14,560 --> 00:10:16,240
fetched decoded and executed the load

294
00:10:16,240 --> 00:10:18,240
secret because this is what the program

295
00:10:18,240 --> 00:10:19,200
is saying

296
00:10:19,200 --> 00:10:21,200
when uh it encounters the store

297
00:10:21,200 --> 00:10:23,440
instruction which is trying to modify

298
00:10:23,440 --> 00:10:25,760
the already fetched codes

299
00:10:25,760 --> 00:10:28,079
it will have to flush its pipeline from

300
00:10:28,079 --> 00:10:29,680
the previously fetched decoded and

301
00:10:29,680 --> 00:10:31,040
execute instruction in this case the

302
00:10:31,040 --> 00:10:33,040
load secret and take into account the

303
00:10:33,040 --> 00:10:35,200
new instruction that is being stored

304
00:10:35,200 --> 00:10:37,120
which is the no operation and then

305
00:10:37,120 --> 00:10:40,000
refresh it decoded and executed

306
00:10:40,000 --> 00:10:42,800
but since this detection of a cell phone

307
00:10:42,800 --> 00:10:44,959
reflect code is not immediate this

308
00:10:44,959 --> 00:10:47,360
creates a temporary window

309
00:10:47,360 --> 00:10:50,480
where the micro textual side effects of

310
00:10:50,480 --> 00:10:52,240
the speculatively fascicular executed

311
00:10:52,240 --> 00:10:53,519
instruction in this case the loot the

312
00:10:53,519 --> 00:10:55,440
load secret can be still observed

313
00:10:55,440 --> 00:10:57,040
through caches and other buffers in the

314
00:10:57,040 --> 00:10:59,600
cpu as we saw earlier and if an attacker

315
00:10:59,600 --> 00:11:02,079
can have a side channel and be able to

316
00:11:02,079 --> 00:11:05,200
observe what has been executed

317
00:11:05,200 --> 00:11:06,720
in the sale code from the safe code in

318
00:11:06,720 --> 00:11:09,279
this case the low secret it then can it

319
00:11:09,279 --> 00:11:11,360
then can leak

320
00:11:11,360 --> 00:11:14,399
the information that was loaded

321
00:11:14,399 --> 00:11:16,000
so the architectural invite here is that

322
00:11:16,000 --> 00:11:18,160
store instructions always target data

323
00:11:18,160 --> 00:11:19,360
addresses

324
00:11:19,360 --> 00:11:20,480
and

325
00:11:20,480 --> 00:11:22,320
this invariant is violated in the case

326
00:11:22,320 --> 00:11:24,399
of a self-referent code which targets

327
00:11:24,399 --> 00:11:26,640
code addresses instead

328
00:11:26,640 --> 00:11:28,320
this validation allows an attacker to

329
00:11:28,320 --> 00:11:30,720
transiently execute sale code in this

330
00:11:30,720 --> 00:11:33,040
case the load secret

331
00:11:33,040 --> 00:11:34,959
and in order to understand how this can

332
00:11:34,959 --> 00:11:37,360
be exploited we need first to understand

333
00:11:37,360 --> 00:11:39,680
um what is the attack primitive that

334
00:11:39,680 --> 00:11:41,680
this type of machine clear is providing

335
00:11:41,680 --> 00:11:42,959
us

336
00:11:42,959 --> 00:11:44,320
so

337
00:11:44,320 --> 00:11:46,880
we can break this down to two main steps

338
00:11:46,880 --> 00:11:48,800
we need to write code and we need then

339
00:11:48,800 --> 00:11:50,720
to execute it these are the two

340
00:11:50,720 --> 00:11:52,399
fundamental steps that we need to do in

341
00:11:52,399 --> 00:11:54,839
order to perform a self-refined

342
00:11:54,839 --> 00:11:57,519
code so the attack primitive which is

343
00:11:57,519 --> 00:11:59,040
built on top uh software muffin

344
00:11:59,040 --> 00:12:00,800
combination clear is called speculative

345
00:12:00,800 --> 00:12:03,680
code server pass and it uh it it's built

346
00:12:03,680 --> 00:12:05,120
on top of a

347
00:12:05,120 --> 00:12:07,600
transient window created and originated

348
00:12:07,600 --> 00:12:09,040
by a cell phone vehicle machine clear

349
00:12:09,040 --> 00:12:10,560
and it allows an attacker to execute

350
00:12:10,560 --> 00:12:14,079
sale code as we saw earlier

351
00:12:14,160 --> 00:12:16,079
so this can be broken down in three

352
00:12:16,079 --> 00:12:17,200
steps but

353
00:12:17,200 --> 00:12:20,480
keep in mind that code and data are two

354
00:12:20,480 --> 00:12:22,399
views of the same exact memory and

355
00:12:22,399 --> 00:12:24,800
they're always kept coherent coherence

356
00:12:24,800 --> 00:12:27,279
between each other all the time at least

357
00:12:27,279 --> 00:12:28,720
on the architectural

358
00:12:28,720 --> 00:12:29,680
level

359
00:12:29,680 --> 00:12:32,240
and code code and data could view and

360
00:12:32,240 --> 00:12:33,600
data view can be

361
00:12:33,600 --> 00:12:35,920
suction cache and data cache for example

362
00:12:35,920 --> 00:12:37,839
so in the first step of our attack

363
00:12:37,839 --> 00:12:39,120
primitive we need to perform the first

364
00:12:39,120 --> 00:12:40,959
step of a cell phone frame code which is

365
00:12:40,959 --> 00:12:42,800
storing code and

366
00:12:42,800 --> 00:12:45,040
there are different uh use case uh

367
00:12:45,040 --> 00:12:46,720
scenarios where this can be performed

368
00:12:46,720 --> 00:12:48,720
let's say for example jit engines where

369
00:12:48,720 --> 00:12:51,040
code is under the attackers controller

370
00:12:51,040 --> 00:12:53,600
can decide what is the code being

371
00:12:53,600 --> 00:12:54,720
determined

372
00:12:54,720 --> 00:12:57,839
so in step one we store the code of a

373
00:12:57,839 --> 00:13:00,320
function f at the address where the code

374
00:13:00,320 --> 00:13:03,360
of function g is residing and we do this

375
00:13:03,360 --> 00:13:05,120
in the data view in data cache because

376
00:13:05,120 --> 00:13:08,240
we're storing code as data

377
00:13:08,240 --> 00:13:11,440
this will temporarily desynchronize what

378
00:13:11,440 --> 00:13:12,959
the code that is residing at the same

379
00:13:12,959 --> 00:13:14,800
address in the code view compared to

380
00:13:14,800 --> 00:13:16,800
what we just stored in dataview at the

381
00:13:16,800 --> 00:13:18,480
same exact address

382
00:13:18,480 --> 00:13:20,399
and now if we try to perform the second

383
00:13:20,399 --> 00:13:21,839
step of a cell phone frame code which is

384
00:13:21,839 --> 00:13:24,079
executing code and we try to call

385
00:13:24,079 --> 00:13:26,160
function f that we just stored

386
00:13:26,160 --> 00:13:27,760
the cpu

387
00:13:27,760 --> 00:13:30,399
or i mean the more precisely the front

388
00:13:30,399 --> 00:13:32,480
end will try to fetch and decode and

389
00:13:32,480 --> 00:13:34,320
execute transiently the code that is

390
00:13:34,320 --> 00:13:36,160
residing at that address from the code

391
00:13:36,160 --> 00:13:37,120
view

392
00:13:37,120 --> 00:13:40,560
which is the code of function g

393
00:13:40,639 --> 00:13:43,199
later it will detect that this was a

394
00:13:43,199 --> 00:13:45,360
self-modifying code and then we'll flush

395
00:13:45,360 --> 00:13:47,600
the pipeline from the code of function g

396
00:13:47,600 --> 00:13:50,399
and then eventually re-synchronize the

397
00:13:50,399 --> 00:13:52,240
two views and fetch in the code and

398
00:13:52,240 --> 00:13:54,480
execute the code function f which was

399
00:13:54,480 --> 00:13:55,920
intended to be executed in the first

400
00:13:55,920 --> 00:13:56,800
place

401
00:13:56,800 --> 00:13:58,800
but the side effects the microcontextual

402
00:13:58,800 --> 00:14:00,480
trace that an attacker can observe off

403
00:14:00,480 --> 00:14:02,959
the scale code that was executed this

404
00:14:02,959 --> 00:14:05,120
case function g is still there it can be

405
00:14:05,120 --> 00:14:07,600
observed

406
00:14:09,040 --> 00:14:10,800
when we were reverse engineering this

407
00:14:10,800 --> 00:14:12,720
behavior and we looked at the software

408
00:14:12,720 --> 00:14:14,800
development manual of intel of how to

409
00:14:14,800 --> 00:14:15,839
handle cell phone frame code and

410
00:14:15,839 --> 00:14:18,320
customize code we

411
00:14:18,320 --> 00:14:19,680
saw that there are two options being

412
00:14:19,680 --> 00:14:21,600
suggested to handle these cases and

413
00:14:21,600 --> 00:14:24,079
interestingly option one is describing

414
00:14:24,079 --> 00:14:26,639
the exact steps that we need to perform

415
00:14:26,639 --> 00:14:28,079
our attack primitive

416
00:14:28,079 --> 00:14:28,800
so

417
00:14:28,800 --> 00:14:30,800
any software that is adopting option one

418
00:14:30,800 --> 00:14:33,199
to handle self-refined code is actually

419
00:14:33,199 --> 00:14:34,800
performing a speculative code served by

420
00:14:34,800 --> 00:14:37,359
pass attack

421
00:14:37,839 --> 00:14:40,639
in fact uh two main web browsers

422
00:14:40,639 --> 00:14:43,440
chromium and firefox when they get new

423
00:14:43,440 --> 00:14:45,519
code they're not doing any operations

424
00:14:45,519 --> 00:14:47,600
whatsoever because they rely on the fact

425
00:14:47,600 --> 00:14:49,839
that code and data are always kept

426
00:14:49,839 --> 00:14:51,600
coherent which they are on the

427
00:14:51,600 --> 00:14:52,720
architectural level but on

428
00:14:52,720 --> 00:14:54,880
microarchitecture this is not guaranteed

429
00:14:54,880 --> 00:14:58,040
at all

430
00:14:58,160 --> 00:15:00,399
so to exploit a self-modifying

431
00:15:00,399 --> 00:15:02,160
commission clear we have speculative

432
00:15:02,160 --> 00:15:05,279
codes bypass which allows an attacker to

433
00:15:05,279 --> 00:15:07,680
execute cell code which is somehow

434
00:15:07,680 --> 00:15:10,480
similar to its architectural counterpart

435
00:15:10,480 --> 00:15:12,480
i used after free for example a tech

436
00:15:12,480 --> 00:15:14,160
primitive which allows an attacker to

437
00:15:14,160 --> 00:15:17,760
reference uh data that is not

438
00:15:17,760 --> 00:15:21,199
in memory yet that is not referenced yet

439
00:15:21,199 --> 00:15:23,920
anymore sorry

440
00:15:24,800 --> 00:15:27,120
so this was one type of machine clear

441
00:15:27,120 --> 00:15:28,399
the second type that we're presenting

442
00:15:28,399 --> 00:15:31,199
today is called memory ordering and

443
00:15:31,199 --> 00:15:32,639
we're going to start from a definition

444
00:15:32,639 --> 00:15:34,880
what is a memory order model in this

445
00:15:34,880 --> 00:15:38,160
case a tool a total store order memory

446
00:15:38,160 --> 00:15:40,880
model guarantees that all cpu cores see

447
00:15:40,880 --> 00:15:43,279
all memory operations as the program

448
00:15:43,279 --> 00:15:46,240
order except in one case

449
00:15:46,240 --> 00:15:47,759
when we have stored instruction followed

450
00:15:47,759 --> 00:15:49,759
by a load instruction operating on

451
00:15:49,759 --> 00:15:51,199
different addresses these two

452
00:15:51,199 --> 00:15:54,399
instructions might be might be reordered

453
00:15:54,399 --> 00:15:56,079
let's take a look at that example to

454
00:15:56,079 --> 00:15:57,600
make it easier to

455
00:15:57,600 --> 00:15:59,519
to follow so here we have two processors

456
00:15:59,519 --> 00:16:01,199
two cores

457
00:16:01,199 --> 00:16:03,120
processor a is performing two load

458
00:16:03,120 --> 00:16:05,120
instructions from address x and y and

459
00:16:05,120 --> 00:16:07,199
then a subsequent dependent operation

460
00:16:07,199 --> 00:16:09,680
and processor b is uh performing a two

461
00:16:09,680 --> 00:16:11,600
store instructions at the same addresses

462
00:16:11,600 --> 00:16:14,399
that processor a is loading

463
00:16:14,399 --> 00:16:16,800
let's say that for example uh the first

464
00:16:16,800 --> 00:16:18,959
load in processor a is slow there's a

465
00:16:18,959 --> 00:16:21,040
cache miss that data at lsx needs to be

466
00:16:21,040 --> 00:16:23,920
fetched from dram that takes uh

467
00:16:23,920 --> 00:16:26,079
too long so processor a as we saw tries

468
00:16:26,079 --> 00:16:27,519
to optimize all the different operations

469
00:16:27,519 --> 00:16:29,440
that can be done at the micro actual

470
00:16:29,440 --> 00:16:31,120
level so internally at the architectural

471
00:16:31,120 --> 00:16:34,639
level it will violate the memory model

472
00:16:34,639 --> 00:16:36,880
and executing out of order the second

473
00:16:36,880 --> 00:16:38,959
load on address y and all subsequent

474
00:16:38,959 --> 00:16:41,040
dependent operations and it will keep

475
00:16:41,040 --> 00:16:43,600
them in a ready to commit state so when

476
00:16:43,600 --> 00:16:46,959
then the data at x is being fed from

477
00:16:46,959 --> 00:16:48,959
dram it will commit everything

478
00:16:48,959 --> 00:16:51,519
architecturally in order and then being

479
00:16:51,519 --> 00:16:53,519
following the memory model but

480
00:16:53,519 --> 00:16:55,279
internally on the architectural level it

481
00:16:55,279 --> 00:16:58,240
can do all sort of optimizations that

482
00:16:58,240 --> 00:17:00,480
can also violate

483
00:17:00,480 --> 00:17:02,560
the memory model

484
00:17:02,560 --> 00:17:04,400
so let's assume that at this point

485
00:17:04,400 --> 00:17:06,480
processor b performs the

486
00:17:06,480 --> 00:17:08,319
the two stores at the same addresses

487
00:17:08,319 --> 00:17:11,199
that uh processor a loaded out of order

488
00:17:11,199 --> 00:17:12,640
at this point

489
00:17:12,640 --> 00:17:14,319
processor a is

490
00:17:14,319 --> 00:17:16,400
basically called red-handed like i mean

491
00:17:16,400 --> 00:17:19,839
cannot commit anymore the data that was

492
00:17:19,839 --> 00:17:22,799
loaded out of order because it otherwise

493
00:17:22,799 --> 00:17:24,480
would be the proof the architectural

494
00:17:24,480 --> 00:17:25,839
proof that it actually violated the

495
00:17:25,839 --> 00:17:28,000
memory model internally

496
00:17:28,000 --> 00:17:30,640
and what it had to do now is flush the

497
00:17:30,640 --> 00:17:32,640
pipeline from the ready to commit

498
00:17:32,640 --> 00:17:34,240
instructions that it performed out or

499
00:17:34,240 --> 00:17:36,400
out of order take into account the new

500
00:17:36,400 --> 00:17:38,080
value that has been stored by processor

501
00:17:38,080 --> 00:17:42,160
b at address y and then re-execute the

502
00:17:42,160 --> 00:17:43,760
load over

503
00:17:43,760 --> 00:17:46,640
y again and commit everything in program

504
00:17:46,640 --> 00:17:48,720
order to be compliant with the memory

505
00:17:48,720 --> 00:17:50,640
model

506
00:17:50,640 --> 00:17:52,160
so in this case

507
00:17:52,160 --> 00:17:53,600
the architectural environment of this

508
00:17:53,600 --> 00:17:55,520
type of machine clear is called is that

509
00:17:55,520 --> 00:17:57,760
out of order execution always complies

510
00:17:57,760 --> 00:17:59,760
with the total store

511
00:17:59,760 --> 00:18:01,600
order memory model

512
00:18:01,600 --> 00:18:02,480
this

513
00:18:02,480 --> 00:18:03,840
environment is violated in the case of a

514
00:18:03,840 --> 00:18:04,880
memory

515
00:18:04,880 --> 00:18:07,039
ordering model as we saw

516
00:18:07,039 --> 00:18:08,960
earlier and the security implication

517
00:18:08,960 --> 00:18:10,720
here is that an attacker

518
00:18:10,720 --> 00:18:12,160
this allows an attacker to transiently

519
00:18:12,160 --> 00:18:14,880
leak sale data

520
00:18:14,880 --> 00:18:17,360
which is in this case the load that it

521
00:18:17,360 --> 00:18:20,080
was performed out of order

522
00:18:20,080 --> 00:18:21,520
and uh

523
00:18:21,520 --> 00:18:23,520
to exploit this this is not trivial at

524
00:18:23,520 --> 00:18:25,840
all because we need to synchronize the

525
00:18:25,840 --> 00:18:27,840
two the execution of the two

526
00:18:27,840 --> 00:18:29,360
instructions on the micro micro

527
00:18:29,360 --> 00:18:30,720
rectangular level from two different

528
00:18:30,720 --> 00:18:33,039
cores

529
00:18:33,600 --> 00:18:35,200
okay now we'll look at the different

530
00:18:35,200 --> 00:18:36,320
types of machine clear that we're

531
00:18:36,320 --> 00:18:38,720
presenting

532
00:18:40,000 --> 00:18:42,400
okay now we switch to the third type of

533
00:18:42,400 --> 00:18:43,520
machine clear that we are presenting

534
00:18:43,520 --> 00:18:46,960
today that is about floating points

535
00:18:46,960 --> 00:18:49,760
so when the io guys decided to create

536
00:18:49,760 --> 00:18:50,720
the

537
00:18:50,720 --> 00:18:52,799
standard for floating points

538
00:18:52,799 --> 00:18:57,039
they decided to do not waste any space

539
00:18:57,039 --> 00:18:59,280
of the 64 or 32-bit of the 14-point

540
00:18:59,280 --> 00:19:01,120
numbers

541
00:19:01,120 --> 00:19:02,480
and they

542
00:19:02,480 --> 00:19:04,400
allocated a special range of

543
00:19:04,400 --> 00:19:06,960
floating-point numbers for very small

544
00:19:06,960 --> 00:19:09,520
numbers that are named sub-normal or the

545
00:19:09,520 --> 00:19:10,799
normal

546
00:19:10,799 --> 00:19:12,000
so

547
00:19:12,000 --> 00:19:14,400
to keep it short every number for the

548
00:19:14,400 --> 00:19:16,960
double representation smaller than 2 to

549
00:19:16,960 --> 00:19:19,760
the power of negative 1022

550
00:19:19,760 --> 00:19:20,799
it will be

551
00:19:20,799 --> 00:19:23,200
represented differently from the other

552
00:19:23,200 --> 00:19:24,720
let's say standard floating point

553
00:19:24,720 --> 00:19:27,120
numbers

554
00:19:27,120 --> 00:19:28,400
uh

555
00:19:28,400 --> 00:19:29,919
to better explain let's have a look at

556
00:19:29,919 --> 00:19:32,080
this small snippet of code just a

557
00:19:32,080 --> 00:19:33,679
floating point division followed by a

558
00:19:33,679 --> 00:19:36,720
floating point addition

559
00:19:36,720 --> 00:19:39,280
so as you can imagine i don't know the

560
00:19:39,280 --> 00:19:41,840
other designer at the intel md and so on

561
00:19:41,840 --> 00:19:43,520
they were not happy about this uh

562
00:19:43,520 --> 00:19:45,760
special case so they optimized the

563
00:19:45,760 --> 00:19:48,240
hardware to only handle

564
00:19:48,240 --> 00:19:48,960
not

565
00:19:48,960 --> 00:19:51,039
normal floating point numbers

566
00:19:51,039 --> 00:19:53,760
and in the case of subnormal numbers

567
00:19:53,760 --> 00:19:56,000
they will handle it in a

568
00:19:56,000 --> 00:19:58,240
special way okay so again let's have a

569
00:19:58,240 --> 00:20:00,320
look at this example so we have a normal

570
00:20:00,320 --> 00:20:01,840
floating point division

571
00:20:01,840 --> 00:20:03,760
and let's assume that the results or the

572
00:20:03,760 --> 00:20:07,840
operand are in this strange abnormal

573
00:20:07,840 --> 00:20:10,400
range of floating point numbers

574
00:20:10,400 --> 00:20:12,159
so what happens

575
00:20:12,159 --> 00:20:13,760
is that

576
00:20:13,760 --> 00:20:16,799
the fpu will generate a wrongly computed

577
00:20:16,799 --> 00:20:18,640
results because again the other is not

578
00:20:18,640 --> 00:20:21,120
capable to enter such numbers

579
00:20:21,120 --> 00:20:22,960
so it will provide these wrong results

580
00:20:22,960 --> 00:20:25,120
to subsequent instruction

581
00:20:25,120 --> 00:20:27,760
and only later after a bit it will

582
00:20:27,760 --> 00:20:30,000
discover all them this was

583
00:20:30,000 --> 00:20:32,480
a wrong result sorry for that let me

584
00:20:32,480 --> 00:20:34,880
remove everything from the pipeline

585
00:20:34,880 --> 00:20:37,120
let me compute the correct results with

586
00:20:37,120 --> 00:20:39,120
a microcode assist

587
00:20:39,120 --> 00:20:41,120
uh by the way this is a software

588
00:20:41,120 --> 00:20:43,039
division so again the arduino is not

589
00:20:43,039 --> 00:20:44,640
capable so the processor is injecting

590
00:20:44,640 --> 00:20:46,720
literally instruction in the pipeline to

591
00:20:46,720 --> 00:20:49,120
compute the division by the software

592
00:20:49,120 --> 00:20:51,600
and then it will provide the results to

593
00:20:51,600 --> 00:20:53,760
the subsequent instruction

594
00:20:53,760 --> 00:20:55,280
as you can imagine this is a huge

595
00:20:55,280 --> 00:20:56,720
performance

596
00:20:56,720 --> 00:20:57,679
hit

597
00:20:57,679 --> 00:20:59,280
however these abnormal numbers are

598
00:20:59,280 --> 00:21:01,360
usually rare enough to not

599
00:21:01,360 --> 00:21:04,320
cause any damage on the performance

600
00:21:04,320 --> 00:21:06,880
but here we notice that basically the r

601
00:21:06,880 --> 00:21:08,720
or the floating point unit is totally

602
00:21:08,720 --> 00:21:11,200
biased on just working on

603
00:21:11,200 --> 00:21:12,960
normal numbers

604
00:21:12,960 --> 00:21:14,720
and we can simply violate this

605
00:21:14,720 --> 00:21:16,720
environment by performing any operation

606
00:21:16,720 --> 00:21:19,440
on subnormal numbers

607
00:21:19,440 --> 00:21:21,120
and here a secret implication is that an

608
00:21:21,120 --> 00:21:22,880
attacker can

609
00:21:22,880 --> 00:21:24,159
inject a

610
00:21:24,159 --> 00:21:28,320
wrong results on the pipeline okay

611
00:21:28,320 --> 00:21:30,880
and regarding exploitation uh here

612
00:21:30,880 --> 00:21:32,080
things

613
00:21:32,080 --> 00:21:33,760
gets pretty interesting in our opinion

614
00:21:33,760 --> 00:21:34,720
because

615
00:21:34,720 --> 00:21:36,720
our primitive is to inject a floating

616
00:21:36,720 --> 00:21:38,320
point results that

617
00:21:38,320 --> 00:21:40,400
you think about is

618
00:21:40,400 --> 00:21:42,640
strange not common

619
00:21:42,640 --> 00:21:43,520
so

620
00:21:43,520 --> 00:21:45,600
we managed to build an entrance exploit

621
00:21:45,600 --> 00:21:48,559
we're going to show you the details now

622
00:21:48,559 --> 00:21:50,720
this is the attack setup

623
00:21:50,720 --> 00:21:52,640
on the left we have a victim page with

624
00:21:52,640 --> 00:21:55,520
some content that you want to to leak

625
00:21:55,520 --> 00:21:56,880
and on the right we have an iframe

626
00:21:56,880 --> 00:21:58,880
imagine this is an advertisement or

627
00:21:58,880 --> 00:22:00,080
stuff like that

628
00:22:00,080 --> 00:22:02,159
and please notice these are two

629
00:22:02,159 --> 00:22:05,039
different origins because firefox

630
00:22:05,039 --> 00:22:07,600
maybe now but i'm sure a few months ago

631
00:22:07,600 --> 00:22:10,880
didn't have the set isolation so

632
00:22:10,880 --> 00:22:14,960
this was still a totally working attack

633
00:22:14,960 --> 00:22:17,840
and so before we said we can inject our

634
00:22:17,840 --> 00:22:20,320
wrongly computed results okay

635
00:22:20,320 --> 00:22:22,320
but due to some fuzzing reverse

636
00:22:22,320 --> 00:22:24,480
engineering we managed to build a tool

637
00:22:24,480 --> 00:22:26,240
where you simply provide the value that

638
00:22:26,240 --> 00:22:28,400
you want to see transiently so the wrong

639
00:22:28,400 --> 00:22:29,840
computer results

640
00:22:29,840 --> 00:22:32,320
for example we want to see that b as a

641
00:22:32,320 --> 00:22:34,240
speculative result

642
00:22:34,240 --> 00:22:35,919
and the 2 will give you the x and y

643
00:22:35,919 --> 00:22:38,080
operand to perform division to get the

644
00:22:38,080 --> 00:22:41,039
specific values transiently so

645
00:22:41,039 --> 00:22:42,559
for example

646
00:22:42,559 --> 00:22:44,480
the tool on the bottom is just uh it

647
00:22:44,480 --> 00:22:46,240
will perform the division and give you

648
00:22:46,240 --> 00:22:48,400
the true results so the correct one the

649
00:22:48,400 --> 00:22:50,400
architectural one that you can see is

650
00:22:50,400 --> 00:22:52,400
minus infinity

651
00:22:52,400 --> 00:22:53,600
it's here

652
00:22:53,600 --> 00:22:56,240
while uh the transcendent results

653
00:22:56,240 --> 00:22:58,240
is actually dead with zero zero as we

654
00:22:58,240 --> 00:23:01,440
specified before

655
00:23:01,520 --> 00:23:03,760
maybe now you start to see where expert

656
00:23:03,760 --> 00:23:05,520
is going to

657
00:23:05,520 --> 00:23:07,360
to attack so

658
00:23:07,360 --> 00:23:10,159
you see the upper bits are set to ffffb

659
00:23:10,159 --> 00:23:12,960
and more precisely this is a none not a

660
00:23:12,960 --> 00:23:13,840
number

661
00:23:13,840 --> 00:23:16,240
floating point value

662
00:23:16,240 --> 00:23:17,120
and

663
00:23:17,120 --> 00:23:19,280
in firefox engine

664
00:23:19,280 --> 00:23:21,760
the javascript engine of firefox

665
00:23:21,760 --> 00:23:23,600
actually every javascript object is

666
00:23:23,600 --> 00:23:25,120
represented using a floating point

667
00:23:25,120 --> 00:23:29,120
number it's a nice trick to reuse the

668
00:23:29,120 --> 00:23:31,919
unused space of floating point numbers

669
00:23:31,919 --> 00:23:33,120
where

670
00:23:33,120 --> 00:23:36,159
basically the the upper bits are used to

671
00:23:36,159 --> 00:23:38,400
store the type of the object of the

672
00:23:38,400 --> 00:23:39,520
variable

673
00:23:39,520 --> 00:23:41,039
and the bottom bits are used for the

674
00:23:41,039 --> 00:23:43,039
payload so for example

675
00:23:43,039 --> 00:23:45,919
ffb is for stype string

676
00:23:45,919 --> 00:23:48,080
and that beef is the payload that is a

677
00:23:48,080 --> 00:23:49,600
pointer

678
00:23:49,600 --> 00:23:52,559
to the content of the string okay

679
00:23:52,559 --> 00:23:54,559
uh why for example

680
00:23:54,559 --> 00:23:56,159
the

681
00:23:56,159 --> 00:23:57,760
this other number here is just a

682
00:23:57,760 --> 00:24:00,240
standard floating point the double value

683
00:24:00,240 --> 00:24:02,000
okay

684
00:24:02,000 --> 00:24:03,600
so what happens if in javascript we

685
00:24:03,600 --> 00:24:05,600
perform the division of these two values

686
00:24:05,600 --> 00:24:07,679
and right after we ask

687
00:24:07,679 --> 00:24:10,320
the engine look what is the type of z

688
00:24:10,320 --> 00:24:13,279
the floating point division results

689
00:24:13,279 --> 00:24:15,600
well here we are performing speculative

690
00:24:15,600 --> 00:24:17,279
type confusion

691
00:24:17,279 --> 00:24:19,279
where basically

692
00:24:19,279 --> 00:24:22,240
transiently since we set the high bits

693
00:24:22,240 --> 00:24:23,760
to ffb

694
00:24:23,760 --> 00:24:25,760
the engine will believe ah of course the

695
00:24:25,760 --> 00:24:27,679
floating point division is of type

696
00:24:27,679 --> 00:24:28,880
string

697
00:24:28,880 --> 00:24:30,400
while architecturally when the results

698
00:24:30,400 --> 00:24:32,559
will be minus infinity you will take the

699
00:24:32,559 --> 00:24:34,320
other branch okay

700
00:24:34,320 --> 00:24:36,480
so the red part will only be executed

701
00:24:36,480 --> 00:24:39,360
transiently in a speculative window

702
00:24:39,360 --> 00:24:41,200
and as you notice we have a control of

703
00:24:41,200 --> 00:24:42,960
this lower b setup the point of the

704
00:24:42,960 --> 00:24:44,080
string

705
00:24:44,080 --> 00:24:46,559
is that b value and now it's game over

706
00:24:46,559 --> 00:24:47,520
because

707
00:24:47,520 --> 00:24:50,159
for example we can access the string

708
00:24:50,159 --> 00:24:52,799
length attribute for example

709
00:24:52,799 --> 00:24:54,400
and actually we are the referencing

710
00:24:54,400 --> 00:24:56,559
arbitrary memory addresses

711
00:24:56,559 --> 00:24:59,760
and we can use a simple uh flash all the

712
00:24:59,760 --> 00:25:01,440
side channel to

713
00:25:01,440 --> 00:25:03,120
leave on a trace that later we can

714
00:25:03,120 --> 00:25:04,799
observe to

715
00:25:04,799 --> 00:25:06,400
to leak actually the memory content

716
00:25:06,400 --> 00:25:07,679
pointed by

717
00:25:07,679 --> 00:25:10,880
this crafted pointer

718
00:25:11,919 --> 00:25:15,520
one last piece to conclude the attack

719
00:25:15,520 --> 00:25:17,600
and i think also this is

720
00:25:17,600 --> 00:25:19,840
nice because we show the

721
00:25:19,840 --> 00:25:21,919
you know the the power of transcendent

722
00:25:21,919 --> 00:25:23,520
execution attacks

723
00:25:23,520 --> 00:25:27,200
we we can easily also bypass slr

724
00:25:27,200 --> 00:25:29,039
we just need to allocate a big chunk of

725
00:25:29,039 --> 00:25:31,679
memory this attacker spray memory with

726
00:25:31,679 --> 00:25:33,520
all a's for example

727
00:25:33,520 --> 00:25:35,760
one gigabyte is sufficient

728
00:25:35,760 --> 00:25:38,240
and then what we do we look at coarse

729
00:25:38,240 --> 00:25:40,960
grained addresses

730
00:25:40,960 --> 00:25:43,679
until we leak all a's okay

731
00:25:43,679 --> 00:25:46,000
and the nice part here is that all these

732
00:25:46,000 --> 00:25:47,120
um

733
00:25:47,120 --> 00:25:49,919
execution is speculative okay so if for

734
00:25:49,919 --> 00:25:51,679
example we use this address here that is

735
00:25:51,679 --> 00:25:54,159
not even mapped it should kind of crash

736
00:25:54,159 --> 00:25:56,320
firefox but this is speculative we can

737
00:25:56,320 --> 00:25:58,320
do whatever we want because nothing of

738
00:25:58,320 --> 00:26:01,919
this is committed is committed so we can

739
00:26:01,919 --> 00:26:03,679
spray the memory and read whatever you

740
00:26:03,679 --> 00:26:07,039
want without crushing anything

741
00:26:07,360 --> 00:26:10,559
you have a demo of the attack as you can

742
00:26:10,559 --> 00:26:12,320
see here on the left with the victim on

743
00:26:12,320 --> 00:26:14,880
the right the frame

744
00:26:14,880 --> 00:26:17,840
we run the attack so as i said before we

745
00:26:17,840 --> 00:26:20,880
start by allocating one gigabyte of

746
00:26:20,880 --> 00:26:21,840
known

747
00:26:21,840 --> 00:26:23,039
memory

748
00:26:23,039 --> 00:26:26,480
and right after we are going to perform

749
00:26:26,480 --> 00:26:30,559
to break slr by a cross-grained surge

750
00:26:30,559 --> 00:26:32,080
and here please notice that we are

751
00:26:32,080 --> 00:26:34,240
generating the x and y operand reporting

752
00:26:34,240 --> 00:26:35,840
point division

753
00:26:35,840 --> 00:26:37,200
to

754
00:26:37,200 --> 00:26:38,960
generate

755
00:26:38,960 --> 00:26:40,640
but

756
00:26:40,640 --> 00:26:44,000
the pc was too strong so

757
00:26:44,400 --> 00:26:46,559
wait a second let me okay so we were

758
00:26:46,559 --> 00:26:48,559
leaking uh sorry we're breaking breaking

759
00:26:48,559 --> 00:26:50,000
slr

760
00:26:50,000 --> 00:26:51,440
and

761
00:26:51,440 --> 00:26:52,640
here please notice that we are

762
00:26:52,640 --> 00:26:55,600
generating the x and y operand

763
00:26:55,600 --> 00:26:57,360
to generate these specific colors we

764
00:26:57,360 --> 00:27:00,480
want to to leak

765
00:27:00,480 --> 00:27:02,799
this takes usually a few seconds exactly

766
00:27:02,799 --> 00:27:04,640
now we have broke

767
00:27:04,640 --> 00:27:05,760
slr

768
00:27:05,760 --> 00:27:07,760
now we're already leaking the memory of

769
00:27:07,760 --> 00:27:09,200
the victim we are just only printing

770
00:27:09,200 --> 00:27:11,760
when we find something meaningful

771
00:27:11,760 --> 00:27:13,840
uh here again the speed was 13 kilobytes

772
00:27:13,840 --> 00:27:15,679
per second so you will see exactly

773
00:27:15,679 --> 00:27:18,240
soonish now we are clicking the

774
00:27:18,240 --> 00:27:20,480
the victim page

775
00:27:20,480 --> 00:27:21,919
and also it's nice because if we leave

776
00:27:21,919 --> 00:27:25,440
running for a bit we also start leaking

777
00:27:25,440 --> 00:27:27,039
other stuff like it seems like

778
00:27:27,039 --> 00:27:29,120
javascript code we have no idea

779
00:27:29,120 --> 00:27:31,600
so we have full compromise the the

780
00:27:31,600 --> 00:27:32,960
process

781
00:27:32,960 --> 00:27:33,380
and

782
00:27:33,380 --> 00:27:34,559
[Music]

783
00:27:34,559 --> 00:27:36,159
again if you think about

784
00:27:36,159 --> 00:27:37,600
at least for us this is pretty crazy

785
00:27:37,600 --> 00:27:39,120
attack because

786
00:27:39,120 --> 00:27:41,279
from a floating point division

787
00:27:41,279 --> 00:27:44,159
to a red arbitrary

788
00:27:44,159 --> 00:27:45,679
memory

789
00:27:45,679 --> 00:27:47,600
or energy engine

790
00:27:47,600 --> 00:27:49,120
again using

791
00:27:49,120 --> 00:27:51,200
speculative

792
00:27:51,200 --> 00:27:52,720
attacks

793
00:27:52,720 --> 00:27:56,640
was a yeah it's pretty good

794
00:27:58,159 --> 00:28:00,080
yeah as i said the leakage rate was

795
00:28:00,080 --> 00:28:02,880
about 13 kilobytes per second

796
00:28:02,880 --> 00:28:03,760
uh

797
00:28:03,760 --> 00:28:06,559
yeah just briefly about mitigation

798
00:28:06,559 --> 00:28:08,159
there are multiples you can simply

799
00:28:08,159 --> 00:28:10,399
disable the this representation in the

800
00:28:10,399 --> 00:28:12,480
floating point unit

801
00:28:12,480 --> 00:28:14,840
we also implemented a compiler path to

802
00:28:14,840 --> 00:28:18,080
serialize possible fpva gadgets

803
00:28:18,080 --> 00:28:20,960
with a 53 percent overhead

804
00:28:20,960 --> 00:28:23,200
or as firefox did

805
00:28:23,200 --> 00:28:25,600
basically now after every floating point

806
00:28:25,600 --> 00:28:28,080
operation they conditionally check

807
00:28:28,080 --> 00:28:30,320
that the 14 point result is not of type

808
00:28:30,320 --> 00:28:31,679
none so

809
00:28:31,679 --> 00:28:33,279
you cannot anymore

810
00:28:33,279 --> 00:28:34,720
uh

811
00:28:34,720 --> 00:28:36,320
let's say type confuse the javascript

812
00:28:36,320 --> 00:28:37,200
engine

813
00:28:37,200 --> 00:28:38,720
while chrome was saved by default

814
00:28:38,720 --> 00:28:42,480
because was already using site

815
00:28:42,840 --> 00:28:45,279
isolation now we'll quickly present the

816
00:28:45,279 --> 00:28:47,039
last type of machine clear that is

817
00:28:47,039 --> 00:28:49,120
memory some migration

818
00:28:49,120 --> 00:28:50,640
so

819
00:28:50,640 --> 00:28:52,720
when we have a load instruction followed

820
00:28:52,720 --> 00:28:54,880
by a store instruction

821
00:28:54,880 --> 00:28:56,480
and the destination of the store is not

822
00:28:56,480 --> 00:28:58,720
ready yet there is a special predictor

823
00:28:58,720 --> 00:29:01,200
named the members application unit

824
00:29:01,200 --> 00:29:03,760
that tries to predict if this stock

825
00:29:03,760 --> 00:29:05,360
store load instructions are operating on

826
00:29:05,360 --> 00:29:07,279
the same address so aliasing you're not

827
00:29:07,279 --> 00:29:09,679
allowing it's quite simple let's look as

828
00:29:09,679 --> 00:29:11,679
always as an example

829
00:29:11,679 --> 00:29:13,840
imagine you have a store followed by a

830
00:29:13,840 --> 00:29:14,880
load

831
00:29:14,880 --> 00:29:17,039
and let's say that the store address is

832
00:29:17,039 --> 00:29:19,840
yet not known is a xx value so the

833
00:29:19,840 --> 00:29:22,240
processor will not wait for the store to

834
00:29:22,240 --> 00:29:24,640
complete it will start doing the load

835
00:29:24,640 --> 00:29:27,360
operation uh transiently

836
00:29:27,360 --> 00:29:28,799
and

837
00:29:28,799 --> 00:29:30,240
for doing that actually it will ask

838
00:29:30,240 --> 00:29:32,399
before the predictor if the store and

839
00:29:32,399 --> 00:29:34,080
the rule will be on the same address

840
00:29:34,080 --> 00:29:35,919
and let's say the predictor will say no

841
00:29:35,919 --> 00:29:38,720
no you can continue out of order because

842
00:29:38,720 --> 00:29:40,559
they are not aliasing

843
00:29:40,559 --> 00:29:42,799
so the cpu will actually perform the

844
00:29:42,799 --> 00:29:44,720
load before the store

845
00:29:44,720 --> 00:29:46,720
but what happens is actually

846
00:29:46,720 --> 00:29:48,240
the store and the load were on the same

847
00:29:48,240 --> 00:29:49,279
address

848
00:29:49,279 --> 00:29:51,360
where the processor needs to squash all

849
00:29:51,360 --> 00:29:52,640
this instruction

850
00:29:52,640 --> 00:29:55,440
clean the pipeline perform the store and

851
00:29:55,440 --> 00:29:57,840
only then the load

852
00:29:57,840 --> 00:29:59,679
or you can see here the

853
00:29:59,679 --> 00:30:02,399
retrancing pad

854
00:30:02,399 --> 00:30:05,440
loaded some steel value

855
00:30:05,440 --> 00:30:07,919
and hearing variant is that the

856
00:30:07,919 --> 00:30:09,200
basically the membrane's application

857
00:30:09,200 --> 00:30:11,200
unit never fails

858
00:30:11,200 --> 00:30:13,039
and to violate that the attacker needs

859
00:30:13,039 --> 00:30:15,520
to massage the predictor to

860
00:30:15,520 --> 00:30:18,240
make a wrongly prediction here

861
00:30:18,240 --> 00:30:20,240
and implication as i said is that we are

862
00:30:20,240 --> 00:30:24,080
leaking stale data from memory

863
00:30:24,080 --> 00:30:26,080
and this was already known in the past

864
00:30:26,080 --> 00:30:28,799
as a spectre v4 or also speculative

865
00:30:28,799 --> 00:30:30,480
store bypass

866
00:30:30,480 --> 00:30:33,120
however intel defines this as a machine

867
00:30:33,120 --> 00:30:35,520
clear type so we also presented you

868
00:30:35,520 --> 00:30:37,279
today

869
00:30:37,279 --> 00:30:39,919
now ah yes

870
00:30:39,919 --> 00:30:41,279
if you really like this this

871
00:30:41,279 --> 00:30:42,559
presentation you can also have a look at

872
00:30:42,559 --> 00:30:43,679
our paper

873
00:30:43,679 --> 00:30:46,399
there are many other machine clears that

874
00:30:46,399 --> 00:30:48,000
all this corner case of the processor

875
00:30:48,000 --> 00:30:49,279
for example we have

876
00:30:49,279 --> 00:30:52,320
complex masked move instruction

877
00:30:52,320 --> 00:30:54,640
exception other intel interrupts a lot

878
00:30:54,640 --> 00:30:56,320
of microcode assist

879
00:30:56,320 --> 00:30:57,840
so as you can see machine creators are

880
00:30:57,840 --> 00:31:00,000
broad class of

881
00:31:00,000 --> 00:31:01,679
transient execution part of the

882
00:31:01,679 --> 00:31:03,679
processor

883
00:31:03,679 --> 00:31:05,279
and now yeah we conclude with some

884
00:31:05,279 --> 00:31:07,600
results

885
00:31:09,279 --> 00:31:11,519
okay so now that we've seen many types

886
00:31:11,519 --> 00:31:13,360
of machine clear let's zoom out a bit

887
00:31:13,360 --> 00:31:15,679
and look at the big picture so we saw

888
00:31:15,679 --> 00:31:17,760
self-modifying codes machine clear

889
00:31:17,760 --> 00:31:20,399
allowing step code execution

890
00:31:20,399 --> 00:31:22,399
a memory ordering allowing

891
00:31:22,399 --> 00:31:24,240
still data to be

892
00:31:24,240 --> 00:31:25,200
leaked

893
00:31:25,200 --> 00:31:26,720
a floating point

894
00:31:26,720 --> 00:31:28,240
performing an injection of a wrong

895
00:31:28,240 --> 00:31:29,200
result

896
00:31:29,200 --> 00:31:34,080
on the transient path and then lastly

897
00:31:34,080 --> 00:31:34,960
still

898
00:31:34,960 --> 00:31:38,480
memory leak through the misprediction of

899
00:31:38,480 --> 00:31:40,000
the ali singh of two addresses through

900
00:31:40,000 --> 00:31:41,840
the memories immigration unit

901
00:31:41,840 --> 00:31:43,440
so

902
00:31:43,440 --> 00:31:45,440
let's look at some numbers to evaluate

903
00:31:45,440 --> 00:31:47,279
how these new types of machine clear

904
00:31:47,279 --> 00:31:49,039
perform compared to all the previous

905
00:31:49,039 --> 00:31:50,159
known

906
00:31:50,159 --> 00:31:51,440
causes of

907
00:31:51,440 --> 00:31:53,679
transit execution here on the x-axis we

908
00:31:53,679 --> 00:31:55,120
have the different

909
00:31:55,120 --> 00:31:57,120
mechanisms or way to create a transit

910
00:31:57,120 --> 00:31:59,600
execution path and on the y-axis we have

911
00:31:59,600 --> 00:32:02,720
two metrics to evaluate these uh this

912
00:32:02,720 --> 00:32:04,799
behavior the top plot represents the

913
00:32:04,799 --> 00:32:07,760
number of uh transient loads uh loaded

914
00:32:07,760 --> 00:32:09,279
operations that fit in a single

915
00:32:09,279 --> 00:32:12,640
transient window and the bottom uh plot

916
00:32:12,640 --> 00:32:14,720
represent the leakage rate how how much

917
00:32:14,720 --> 00:32:17,360
can we leak with the corresponding

918
00:32:17,360 --> 00:32:19,760
transit execution mechanism

919
00:32:19,760 --> 00:32:23,840
and the blue bars intel the red bars are

920
00:32:23,840 --> 00:32:25,440
amd

921
00:32:25,440 --> 00:32:27,279
so here we have the flushing reload this

922
00:32:27,279 --> 00:32:29,039
is the attack that we saw at the

923
00:32:29,039 --> 00:32:30,000
beginning of this presentation

924
00:32:30,000 --> 00:32:31,679
representing the architectural upper

925
00:32:31,679 --> 00:32:33,440
limit of a leakage rate

926
00:32:33,440 --> 00:32:35,440
nothing can nothing transiently can leak

927
00:32:35,440 --> 00:32:37,200
more than this because these are

928
00:32:37,200 --> 00:32:39,039
committed and retired instructions that

929
00:32:39,039 --> 00:32:41,200
are leaking memory

930
00:32:41,200 --> 00:32:43,279
but all the others are transient so they

931
00:32:43,279 --> 00:32:44,640
can uh

932
00:32:44,640 --> 00:32:47,440
the transit window can finish uh earlier

933
00:32:47,440 --> 00:32:48,720
so they cannot leak more than the

934
00:32:48,720 --> 00:32:50,480
architectural leakage

935
00:32:50,480 --> 00:32:53,200
then we have intel tsx bht and falls

936
00:32:53,200 --> 00:32:54,320
where

937
00:32:54,320 --> 00:32:56,399
which are the three main

938
00:32:56,399 --> 00:32:58,000
causes that all previous transit

939
00:32:58,000 --> 00:32:59,519
excision attack we're relying on to

940
00:32:59,519 --> 00:33:01,440
create a transit execution path and

941
00:33:01,440 --> 00:33:05,120
perform these memory leaks and um uh

942
00:33:05,120 --> 00:33:06,960
intel tsx as we know is only available

943
00:33:06,960 --> 00:33:09,600
on intel cpus and it's not supporting

944
00:33:09,600 --> 00:33:11,519
anymore recent cpus because of these

945
00:33:11,519 --> 00:33:13,120
attacks

946
00:33:13,120 --> 00:33:14,880
um so an attacker would have been left

947
00:33:14,880 --> 00:33:17,360
with uh mispredicting a branch like in

948
00:33:17,360 --> 00:33:19,200
the case of bht or

949
00:33:19,200 --> 00:33:21,519
triggering the fault somehow but it's

950
00:33:21,519 --> 00:33:24,559
still using the same root cause but with

951
00:33:24,559 --> 00:33:27,200
our work we're providing five new uh

952
00:33:27,200 --> 00:33:29,039
ways to create a transient execution

953
00:33:29,039 --> 00:33:30,960
path which are available both on intel

954
00:33:30,960 --> 00:33:32,000
and amd

955
00:33:32,000 --> 00:33:34,880
and if we can look at the smc so

956
00:33:34,880 --> 00:33:36,640
software frame code machine clear in a

957
00:33:36,640 --> 00:33:37,840
single window

958
00:33:37,840 --> 00:33:39,600
triggered by self-refined code we can

959
00:33:39,600 --> 00:33:43,360
fit more than 160 transient loads that

960
00:33:43,360 --> 00:33:44,880
will never be observed on the

961
00:33:44,880 --> 00:33:47,039
architectural uh level of the

962
00:33:47,039 --> 00:33:48,320
of the cpu

963
00:33:48,320 --> 00:33:51,120
so 160 loads leaving a microactual trace

964
00:33:51,120 --> 00:33:53,120
that can be also only observed through

965
00:33:53,120 --> 00:33:55,279
some sort of side channel as we saw

966
00:33:55,279 --> 00:33:56,399
earlier

967
00:33:56,399 --> 00:33:58,080
which is quite powerful many things can

968
00:33:58,080 --> 00:34:01,120
fit in 160 loads

969
00:34:01,120 --> 00:34:02,720
another interesting number here is that

970
00:34:02,720 --> 00:34:04,720
with a floating point machine clear we

971
00:34:04,720 --> 00:34:06,880
can reach a leakage rate that is more

972
00:34:06,880 --> 00:34:08,960
than four megabits per second

973
00:34:08,960 --> 00:34:11,199
there is no predictor to mistrain there

974
00:34:11,199 --> 00:34:14,000
is no uh it's not complicated it's so

975
00:34:14,000 --> 00:34:16,239
deterministic once we have an x and y

976
00:34:16,239 --> 00:34:18,079
and we know what is a transient result

977
00:34:18,079 --> 00:34:20,960
that we will be created we have an x and

978
00:34:20,960 --> 00:34:23,280
y we have a transient window that we can

979
00:34:23,280 --> 00:34:27,200
uh use as we saw in our exploit

980
00:34:27,520 --> 00:34:29,599
so now that we have so many ways to

981
00:34:29,599 --> 00:34:31,520
create a transient execution path we try

982
00:34:31,520 --> 00:34:34,480
to classify these to have a more uh an

983
00:34:34,480 --> 00:34:35,918
easier way to look at

984
00:34:35,918 --> 00:34:38,480
these attacks and we classified those

985
00:34:38,480 --> 00:34:40,560
those mechanisms for a route based on a

986
00:34:40,560 --> 00:34:42,879
root cause

987
00:34:42,879 --> 00:34:45,760
so we have the

988
00:34:45,760 --> 00:34:49,040
big class of bad speculation that is uh

989
00:34:49,040 --> 00:34:51,040
has two main subclasses one is control

990
00:34:51,040 --> 00:34:52,399
flowers prediction or branches

991
00:34:52,399 --> 00:34:54,399
prediction or and the other one is data

992
00:34:54,399 --> 00:34:56,560
misprediction or machine clear and these

993
00:34:56,560 --> 00:34:58,320
two subclasses distinguish between are

994
00:34:58,320 --> 00:35:01,680
we speculating speculating on code or

995
00:35:01,680 --> 00:35:04,960
are we speculating on data

996
00:35:04,960 --> 00:35:07,119
then each subclass has its own predictor

997
00:35:07,119 --> 00:35:08,960
subclass uh

998
00:35:08,960 --> 00:35:10,640
the one under control respection these

999
00:35:10,640 --> 00:35:12,240
are the ones that have been used

1000
00:35:12,240 --> 00:35:14,320
in all different transfusion attacks

1001
00:35:14,320 --> 00:35:17,520
that we saw up until uh a year ago or so

1002
00:35:17,520 --> 00:35:19,599
and and under the predictions of data

1003
00:35:19,599 --> 00:35:21,440
inspection we have the disambiguation

1004
00:35:21,440 --> 00:35:23,359
that was previously classified as yet a

1005
00:35:23,359 --> 00:35:25,119
spectre variant but it's actually a type

1006
00:35:25,119 --> 00:35:27,200
of machine clear because it's predicting

1007
00:35:27,200 --> 00:35:30,000
over data and not code so while control

1008
00:35:30,000 --> 00:35:32,079
flows prediction are failed attempts to

1009
00:35:32,079 --> 00:35:33,839
predict what is the next instruction to

1010
00:35:33,839 --> 00:35:34,880
execute

1011
00:35:34,880 --> 00:35:36,560
data mispredictions or machine clear are

1012
00:35:36,560 --> 00:35:39,920
failed attempts to predict the value of

1013
00:35:39,920 --> 00:35:42,720
some sort of data

1014
00:35:42,960 --> 00:35:45,359
then we have the subclass of

1015
00:35:45,359 --> 00:35:46,880
architectural exceptions that belongs to

1016
00:35:46,880 --> 00:35:48,560
database prediction where we have all

1017
00:35:48,560 --> 00:35:49,839
the different types of page faults that

1018
00:35:49,839 --> 00:35:50,960
have been used

1019
00:35:50,960 --> 00:35:53,680
in previous attacks then we introduced

1020
00:35:53,680 --> 00:35:55,440
this new subclass of theorems prediction

1021
00:35:55,440 --> 00:35:57,440
where we which we called a likely

1022
00:35:57,440 --> 00:35:59,040
environment violation where we have all

1023
00:35:59,040 --> 00:36:00,320
the different architectural environments

1024
00:36:00,320 --> 00:36:02,560
that usually hold but occasionally fail

1025
00:36:02,560 --> 00:36:04,480
for some for some reason for example in

1026
00:36:04,480 --> 00:36:06,240
the case of floating point unit flowing

1027
00:36:06,240 --> 00:36:07,680
point machine clear as long as we are

1028
00:36:07,680 --> 00:36:09,599
providing two normal numbers everything

1029
00:36:09,599 --> 00:36:11,599
is fine the environment is not broken

1030
00:36:11,599 --> 00:36:13,599
and ovulated not violated we don't have

1031
00:36:13,599 --> 00:36:15,599
a machine clear but as as soon as we

1032
00:36:15,599 --> 00:36:18,240
provide uh a subnormal or the normal

1033
00:36:18,240 --> 00:36:20,400
operand or the result of two normal

1034
00:36:20,400 --> 00:36:23,119
numbers are yelding or giving a

1035
00:36:23,119 --> 00:36:25,520
subnormal result everything breaks the

1036
00:36:25,520 --> 00:36:27,200
invariant is violated and we have a

1037
00:36:27,200 --> 00:36:29,359
machine clear

1038
00:36:29,359 --> 00:36:31,440
also we observe that we have uh the

1039
00:36:31,440 --> 00:36:33,680
class of hardware interrupts that uh

1040
00:36:33,680 --> 00:36:35,839
during our revisit engineering we saw

1041
00:36:35,839 --> 00:36:38,720
that it they also create a transient

1042
00:36:38,720 --> 00:36:40,960
window that can be exploited you can

1043
00:36:40,960 --> 00:36:44,320
read more about this in our paper

1044
00:36:44,320 --> 00:36:47,520
so we disclosed fpvi scsb to all major

1045
00:36:47,520 --> 00:36:49,280
cpu browser operating system vendors

1046
00:36:49,280 --> 00:36:52,160
earlier last year and we were we got

1047
00:36:52,160 --> 00:36:53,440
confirmed that

1048
00:36:53,440 --> 00:36:55,119
floating point value injection affects

1049
00:36:55,119 --> 00:36:58,720
all intel cpus all md cpus and

1050
00:36:58,720 --> 00:37:00,320
also some arm

1051
00:37:00,320 --> 00:37:01,599
cpus

1052
00:37:01,599 --> 00:37:03,599
and when it comes to a csb or

1053
00:37:03,599 --> 00:37:05,839
speculative code server pass again it

1054
00:37:05,839 --> 00:37:08,240
affects all intel cpus all in the cpus

1055
00:37:08,240 --> 00:37:10,160
but in the case of arm this does not

1056
00:37:10,160 --> 00:37:12,800
work because the coherence between code

1057
00:37:12,800 --> 00:37:15,119
and data are left explicitly to the user

1058
00:37:15,119 --> 00:37:17,520
so this cannot work out of the box as it

1059
00:37:17,520 --> 00:37:20,640
does for intel and amd

1060
00:37:20,640 --> 00:37:21,680
um

1061
00:37:21,680 --> 00:37:24,240
yeah model confirmed fpgi and deployed

1062
00:37:24,240 --> 00:37:26,720
mitigation uh by conditioning masking

1063
00:37:26,720 --> 00:37:29,119
the malicious numbbox the uh transit

1064
00:37:29,119 --> 00:37:32,160
result from firefox 87 and the zen

1065
00:37:32,160 --> 00:37:33,680
hypervisor also

1066
00:37:33,680 --> 00:37:36,160
mitigated a csb by

1067
00:37:36,160 --> 00:37:38,720
issuing a serializing instruction after

1068
00:37:38,720 --> 00:37:40,960
it stores the new code so we don't store

1069
00:37:40,960 --> 00:37:42,880
and execute

1070
00:37:42,880 --> 00:37:44,560
right after that but you store the new

1071
00:37:44,560 --> 00:37:46,160
code you issue serializing instruction

1072
00:37:46,160 --> 00:37:47,599
to make sure that code and data contain

1073
00:37:47,599 --> 00:37:49,200
the new code that you just stored and

1074
00:37:49,200 --> 00:37:50,960
then you execute that

1075
00:37:50,960 --> 00:37:53,280
address

1076
00:37:53,920 --> 00:37:55,440
so to conclude

1077
00:37:55,440 --> 00:37:57,760
uh bad speculation is not caused only by

1078
00:37:57,760 --> 00:38:01,040
classic graduate predictions but also by

1079
00:38:01,040 --> 00:38:02,320
architectural environment validation

1080
00:38:02,320 --> 00:38:03,839
like the the entire class of machine

1081
00:38:03,839 --> 00:38:06,400
collections that we presented today

1082
00:38:06,400 --> 00:38:08,320
these invariants can be exploited

1083
00:38:08,320 --> 00:38:10,320
creating new uh security threats like

1084
00:38:10,320 --> 00:38:12,000
floating point by injection and

1085
00:38:12,000 --> 00:38:13,760
speculative code star bypass

1086
00:38:13,760 --> 00:38:14,560
and

1087
00:38:14,560 --> 00:38:16,800
we think that now defenses moving

1088
00:38:16,800 --> 00:38:19,119
forward must focus on the wider meaning

1089
00:38:19,119 --> 00:38:20,640
of these

1090
00:38:20,640 --> 00:38:22,079
these classes of

1091
00:38:22,079 --> 00:38:24,560
bad speculation and not only just trying

1092
00:38:24,560 --> 00:38:26,720
to avoid that an attacker can mistrain a

1093
00:38:26,720 --> 00:38:28,560
branch predictor or some so sort of like

1094
00:38:28,560 --> 00:38:29,920
this

1095
00:38:29,920 --> 00:38:32,079
so you can find our paper the exploit

1096
00:38:32,079 --> 00:38:34,079
code and the reverse engineering code on

1097
00:38:34,079 --> 00:38:36,560
our links and yeah thanks for your

1098
00:38:36,560 --> 00:38:39,560
attention

