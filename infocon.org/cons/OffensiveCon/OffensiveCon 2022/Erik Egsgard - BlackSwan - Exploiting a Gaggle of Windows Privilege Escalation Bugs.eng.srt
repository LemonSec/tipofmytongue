1
00:00:00,160 --> 00:00:01,040
um

2
00:00:01,040 --> 00:00:02,879
yeah so i'm gonna be talking about a uh

3
00:00:02,879 --> 00:00:04,640
a project that i did kind of earlier

4
00:00:04,640 --> 00:00:06,399
last year um

5
00:00:06,399 --> 00:00:07,839
wasn't actually supposed to be on

6
00:00:07,839 --> 00:00:09,840
offensive topic um but i started doing

7
00:00:09,840 --> 00:00:11,360
some research and in the course of the

8
00:00:11,360 --> 00:00:12,880
research i ended up finding a bunch of

9
00:00:12,880 --> 00:00:14,960
privilege elevation bugs

10
00:00:14,960 --> 00:00:16,480
in windows so that'll be what this uh

11
00:00:16,480 --> 00:00:17,840
this talk is about

12
00:00:17,840 --> 00:00:19,920
um i'll start give a little bit of a

13
00:00:19,920 --> 00:00:22,400
background kind of about me um so i've

14
00:00:22,400 --> 00:00:24,560
been doing uh computer security mostly

15
00:00:24,560 --> 00:00:27,199
in the offensive uh research area um

16
00:00:27,199 --> 00:00:30,080
since 2005 sir for quite a while um and

17
00:00:30,080 --> 00:00:32,000
then a year ago um i kind of switched

18
00:00:32,000 --> 00:00:34,079
teams joined uh field effect and i've

19
00:00:34,079 --> 00:00:36,160
been doing defensive work uh since then

20
00:00:36,160 --> 00:00:38,000
um which means now i can share some of

21
00:00:38,000 --> 00:00:39,520
the stuff i've been doing i don't have

22
00:00:39,520 --> 00:00:42,239
to keep it secret so

23
00:00:42,239 --> 00:00:44,079
yeah and one of the things i've learned

24
00:00:44,079 --> 00:00:45,520
over that this amount of time in the

25
00:00:45,520 --> 00:00:46,800
industry is that for any kind of

26
00:00:46,800 --> 00:00:48,719
research project to be taken seriously

27
00:00:48,719 --> 00:00:50,800
by you guys and get attention um you

28
00:00:50,800 --> 00:00:54,160
need a catchy name and a cool logo so uh

29
00:00:54,160 --> 00:00:57,120
there i think we've got it

30
00:00:57,680 --> 00:00:59,359
um

31
00:00:59,359 --> 00:01:01,120
right so uh i'm kind of gonna go a

32
00:01:01,120 --> 00:01:02,800
little bit in a bit of a weird order

33
00:01:02,800 --> 00:01:04,000
going through this but essentially

34
00:01:04,000 --> 00:01:06,000
follow the uh the research that i was

35
00:01:06,000 --> 00:01:08,960
originally doing um and then kind of the

36
00:01:08,960 --> 00:01:10,720
bugs i discovered along the way and how

37
00:01:10,720 --> 00:01:12,640
that led on to

38
00:01:12,640 --> 00:01:14,220
to finding other bugs

39
00:01:14,220 --> 00:01:15,920
[Music]

40
00:01:15,920 --> 00:01:17,759
and just kind of a quick aside here

41
00:01:17,759 --> 00:01:19,280
about the kind of techniques used in

42
00:01:19,280 --> 00:01:21,360
things so this was all all this was a

43
00:01:21,360 --> 00:01:23,759
reverse engineering done with uh ghidra

44
00:01:23,759 --> 00:01:25,600
for static analysis

45
00:01:25,600 --> 00:01:27,759
and then using wind bag with vmware

46
00:01:27,759 --> 00:01:30,720
hyper-v for dynamic analysis

47
00:01:30,720 --> 00:01:32,240
which makes it a lot easier to skip over

48
00:01:32,240 --> 00:01:34,400
some of the kind of tedious non

49
00:01:34,400 --> 00:01:36,479
non-interesting parts of the static

50
00:01:36,479 --> 00:01:39,040
analysis

51
00:01:39,040 --> 00:01:40,720
so the first thing i started doing was

52
00:01:40,720 --> 00:01:43,759
oh actually go back up here um

53
00:01:43,759 --> 00:01:46,079
before i get going i wanted to uh just

54
00:01:46,079 --> 00:01:48,240
go over a little bit about uh

55
00:01:48,240 --> 00:01:50,399
some of the windows kernel i o uh this

56
00:01:50,399 --> 00:01:52,079
is going to apply to

57
00:01:52,079 --> 00:01:53,360
several other things that i'm talking

58
00:01:53,360 --> 00:01:54,560
about later

59
00:01:54,560 --> 00:01:57,360
um and specifically uh when user mode is

60
00:01:57,360 --> 00:01:58,799
talking to kernel mode how does kernel

61
00:01:58,799 --> 00:02:01,759
mode access the uh the data um

62
00:02:01,759 --> 00:02:03,680
so there's kind of three main methods

63
00:02:03,680 --> 00:02:05,840
and i'm stealing the uh the names from

64
00:02:05,840 --> 00:02:08,959
uh the ioctal handlers in windows um but

65
00:02:08,959 --> 00:02:10,959
this also applies to how the patterns of

66
00:02:10,959 --> 00:02:12,239
how memories manage from just the

67
00:02:12,239 --> 00:02:14,160
regular syscalls

68
00:02:14,160 --> 00:02:16,720
so there's a the first one is a buffered

69
00:02:16,720 --> 00:02:18,319
io which is where

70
00:02:18,319 --> 00:02:20,160
kernel will take any data from user mode

71
00:02:20,160 --> 00:02:22,239
and make a full copy of it in its own

72
00:02:22,239 --> 00:02:24,160
memory so that when the drivers are

73
00:02:24,160 --> 00:02:25,280
accessing

74
00:02:25,280 --> 00:02:26,480
the memory they don't need to worry

75
00:02:26,480 --> 00:02:28,879
about uh you know it's user mode changed

76
00:02:28,879 --> 00:02:30,720
it or anything it should be a static

77
00:02:30,720 --> 00:02:32,720
copy of what was provided

78
00:02:32,720 --> 00:02:34,319
the second method

79
00:02:34,319 --> 00:02:36,879
being direct i o is when kernel

80
00:02:36,879 --> 00:02:39,040
will lock the user mode pages in memory

81
00:02:39,040 --> 00:02:41,200
and then create a mapping

82
00:02:41,200 --> 00:02:43,440
of a kernel address pointing to the same

83
00:02:43,440 --> 00:02:45,760
physical pages so that

84
00:02:45,760 --> 00:02:47,280
it doesn't require any copying it's a

85
00:02:47,280 --> 00:02:49,200
little faster but user mode both user

86
00:02:49,200 --> 00:02:50,800
mode and kernel mode can

87
00:02:50,800 --> 00:02:52,800
see and change the values in the in

88
00:02:52,800 --> 00:02:53,760
those

89
00:02:53,760 --> 00:02:56,000
memory pages so if you're writing code

90
00:02:56,000 --> 00:02:58,720
that's doing direct i o

91
00:02:58,720 --> 00:03:01,280
you need to make sure you're you know

92
00:03:01,280 --> 00:03:02,640
aware of those kind of issues that can

93
00:03:02,640 --> 00:03:04,239
come up if user mode changes things on

94
00:03:04,239 --> 00:03:05,040
you

95
00:03:05,040 --> 00:03:07,200
and then the last

96
00:03:07,200 --> 00:03:09,680
method is uh just if kernel directly

97
00:03:09,680 --> 00:03:12,159
accesses user mode memory um

98
00:03:12,159 --> 00:03:16,480
oh called neither i o so

99
00:03:16,480 --> 00:03:17,920
yeah that's kind of a little bit more

100
00:03:17,920 --> 00:03:20,000
tricky that uh kernels provided the user

101
00:03:20,000 --> 00:03:22,080
mode addresses uh

102
00:03:22,080 --> 00:03:23,760
and it can as long as it's in the

103
00:03:23,760 --> 00:03:25,360
process context of the user mode

104
00:03:25,360 --> 00:03:26,640
application it can just read and write

105
00:03:26,640 --> 00:03:29,200
directly to memory however um it has to

106
00:03:29,200 --> 00:03:31,120
be within uh tri-accept blocks in the

107
00:03:31,120 --> 00:03:32,400
kernel drivers

108
00:03:32,400 --> 00:03:34,319
because if a page wherever to become

109
00:03:34,319 --> 00:03:36,239
unmapped by user mode it will cause a

110
00:03:36,239 --> 00:03:37,599
blue screen if not

111
00:03:37,599 --> 00:03:39,280
and also kernel drivers are supposed to

112
00:03:39,280 --> 00:03:41,519
enclose any access or before they access

113
00:03:41,519 --> 00:03:42,959
any range of memory they need to probe

114
00:03:42,959 --> 00:03:45,519
it for read or write to ensure that

115
00:03:45,519 --> 00:03:47,120
the address range is in a valid user

116
00:03:47,120 --> 00:03:48,720
mode range and they're not

117
00:03:48,720 --> 00:03:51,440
user modes not providing kernel pointers

118
00:03:51,440 --> 00:03:52,480
um

119
00:03:52,480 --> 00:03:54,560
yeah so that's just kind of some basic

120
00:03:54,560 --> 00:03:56,640
reminders about uh windows kernel i o

121
00:03:56,640 --> 00:03:58,959
and memory access

122
00:03:58,959 --> 00:04:00,560
so the uh

123
00:04:00,560 --> 00:04:02,319
the first bit of uh

124
00:04:02,319 --> 00:04:03,920
what led me down this path was i started

125
00:04:03,920 --> 00:04:07,040
looking at uh into alpc um which is the

126
00:04:07,040 --> 00:04:09,120
advanced local procedure call

127
00:04:09,120 --> 00:04:10,959
and so on on windows this is uh was

128
00:04:10,959 --> 00:04:14,239
introduced with windows vista um and

129
00:04:14,239 --> 00:04:16,560
it's how all kind of a lot of the ipc is

130
00:04:16,560 --> 00:04:17,279
done

131
00:04:17,279 --> 00:04:19,519
in windows and they wanted to

132
00:04:19,519 --> 00:04:21,918
kind of create a more performant version

133
00:04:21,918 --> 00:04:26,159
um compared to older versions of windows

134
00:04:27,440 --> 00:04:29,360
and um so the reason i was looking at

135
00:04:29,360 --> 00:04:31,120
this was that um

136
00:04:31,120 --> 00:04:32,880
just to see if there was any way kind of

137
00:04:32,880 --> 00:04:35,040
our defensive product could could

138
00:04:35,040 --> 00:04:36,639
see any of the messages going by or

139
00:04:36,639 --> 00:04:38,479
getting kind of metadata around what was

140
00:04:38,479 --> 00:04:40,160
happening on the on the system just to

141
00:04:40,160 --> 00:04:41,759
help try and defend the endpoints

142
00:04:41,759 --> 00:04:43,840
against malicious behavior

143
00:04:43,840 --> 00:04:45,199
um

144
00:04:45,199 --> 00:04:46,720
i ended up getting distracted with all

145
00:04:46,720 --> 00:04:48,240
this research and

146
00:04:48,240 --> 00:04:49,440
that that other research is still

147
00:04:49,440 --> 00:04:50,400
pending

148
00:04:50,400 --> 00:04:51,280
um

149
00:04:51,280 --> 00:04:53,440
yeah so the alpc interface is uh

150
00:04:53,440 --> 00:04:55,360
primarily undocumented there's just

151
00:04:55,360 --> 00:04:57,199
little snippets here and there talking

152
00:04:57,199 --> 00:04:58,080
about it

153
00:04:58,080 --> 00:05:00,000
as you can see in the uh

154
00:05:00,000 --> 00:05:01,759
the list of apis here it's not that big

155
00:05:01,759 --> 00:05:04,400
a list of sys calls

156
00:05:04,400 --> 00:05:05,919
and really it behaves a lot like a

157
00:05:05,919 --> 00:05:06,960
traditional

158
00:05:06,960 --> 00:05:08,960
socket programming interface

159
00:05:08,960 --> 00:05:10,720
you know there's a client and a server

160
00:05:10,720 --> 00:05:13,039
you listen for connections and then can

161
00:05:13,039 --> 00:05:16,080
send messages back and forth

162
00:05:16,080 --> 00:05:17,280
um

163
00:05:17,280 --> 00:05:19,199
and some of the uh yeah performance

164
00:05:19,199 --> 00:05:21,280
features that were added a big one was

165
00:05:21,280 --> 00:05:23,440
there's a lot of uses of usage of shared

166
00:05:23,440 --> 00:05:25,520
memory so whether it's between you know

167
00:05:25,520 --> 00:05:26,320
the

168
00:05:26,320 --> 00:05:27,759
client in the kernel or server in the

169
00:05:27,759 --> 00:05:29,520
kernel or actually client and server can

170
00:05:29,520 --> 00:05:30,960
share memory directly so they can

171
00:05:30,960 --> 00:05:33,759
exchange data without even having to

172
00:05:33,759 --> 00:05:35,440
send it through the kernel at all

173
00:05:35,440 --> 00:05:37,199
and then a lot of support for i o

174
00:05:37,199 --> 00:05:39,520
completion ports which just

175
00:05:39,520 --> 00:05:41,440
speeds up

176
00:05:41,440 --> 00:05:43,039
makes it more it makes it easier to

177
00:05:43,039 --> 00:05:45,440
access

178
00:05:46,000 --> 00:05:47,680
to get notifications of reads or writes

179
00:05:47,680 --> 00:05:49,759
or messages that are coming through

180
00:05:49,759 --> 00:05:51,520
another point i wanted to make with this

181
00:05:51,520 --> 00:05:53,680
is that the alpc kind of because it's a

182
00:05:53,680 --> 00:05:55,199
core part of

183
00:05:55,199 --> 00:05:57,520
windows ipc is accessible from all

184
00:05:57,520 --> 00:05:59,120
sandboxes that

185
00:05:59,120 --> 00:06:02,160
all that i looked at anyway

186
00:06:02,400 --> 00:06:04,720
so we'll take a little bit of a look at

187
00:06:04,720 --> 00:06:06,960
alpc messages and kind of what they look

188
00:06:06,960 --> 00:06:10,800
like so this structure definition

189
00:06:10,800 --> 00:06:12,720
is a port message

190
00:06:12,720 --> 00:06:14,400
um

191
00:06:14,400 --> 00:06:15,759
this is a header that goes on all

192
00:06:15,759 --> 00:06:17,520
messages that are coming into and out of

193
00:06:17,520 --> 00:06:19,280
user mode

194
00:06:19,280 --> 00:06:21,199
and kind of the interesting things there

195
00:06:21,199 --> 00:06:22,880
that it's got a couple of length fields

196
00:06:22,880 --> 00:06:24,960
at the beginning anytime there's length

197
00:06:24,960 --> 00:06:26,479
piercings that's interesting i'm not

198
00:06:26,479 --> 00:06:27,919
really sure why there's two here but

199
00:06:27,919 --> 00:06:30,000
there's a

200
00:06:30,000 --> 00:06:31,759
one the first one is uh the length of

201
00:06:31,759 --> 00:06:33,120
the data and then the second one is the

202
00:06:33,120 --> 00:06:34,639
total length of the header and the

203
00:06:34,639 --> 00:06:36,639
actual appended data although it would

204
00:06:36,639 --> 00:06:38,319
make sense if the uh if they did that

205
00:06:38,319 --> 00:06:40,160
for kind of forwards compatibility

206
00:06:40,160 --> 00:06:41,440
reasons if they thought the header might

207
00:06:41,440 --> 00:06:44,400
change size uh old code could be uh

208
00:06:44,400 --> 00:06:46,720
could still handle new additions uh if

209
00:06:46,720 --> 00:06:48,880
messages were changed in the future

210
00:06:48,880 --> 00:06:51,120
um and besides just kind of opaque data

211
00:06:51,120 --> 00:06:52,880
to the kernel messages that are

212
00:06:52,880 --> 00:06:54,560
exchanged can also handle a bunch of

213
00:06:54,560 --> 00:06:56,639
different types of metadata

214
00:06:56,639 --> 00:06:58,960
so client and server can exchange

215
00:06:58,960 --> 00:07:01,280
handles to different things on windows

216
00:07:01,280 --> 00:07:04,080
impersonation information so if the

217
00:07:04,080 --> 00:07:05,759
server wants to impersonate the client

218
00:07:05,759 --> 00:07:07,840
when doing some sort of operation

219
00:07:07,840 --> 00:07:10,160
to ensure the permission checks are good

220
00:07:10,160 --> 00:07:12,400
that information can be

221
00:07:12,400 --> 00:07:14,319
contained within the metadata and then

222
00:07:14,319 --> 00:07:16,160
also shared memory details so if a

223
00:07:16,160 --> 00:07:17,599
client and server have agreed they're

224
00:07:17,599 --> 00:07:18,960
going to be

225
00:07:18,960 --> 00:07:20,880
exchanging

226
00:07:20,880 --> 00:07:22,240
information through some sort of shared

227
00:07:22,240 --> 00:07:24,960
memory region then

228
00:07:24,960 --> 00:07:26,400
the details of that can be shared

229
00:07:26,400 --> 00:07:27,919
through

230
00:07:27,919 --> 00:07:28,840
through the

231
00:07:28,840 --> 00:07:31,280
metadata um

232
00:07:31,280 --> 00:07:32,479
so when you're sending messages there's

233
00:07:32,479 --> 00:07:33,759
kind of

234
00:07:33,759 --> 00:07:35,280
a couple different ways to send and

235
00:07:35,280 --> 00:07:36,800
receive them so

236
00:07:36,800 --> 00:07:38,400
the slow path what i'm calling the slow

237
00:07:38,400 --> 00:07:40,479
path is if you just have a vanilla

238
00:07:40,479 --> 00:07:42,639
client a vanilla server

239
00:07:42,639 --> 00:07:44,400
when a message gets sent down it gets

240
00:07:44,400 --> 00:07:46,479
copied into kernel memory so the kernel

241
00:07:46,479 --> 00:07:48,800
code will allocate a copy of it and then

242
00:07:48,800 --> 00:07:51,120
stick it on the receiving ports uh

243
00:07:51,120 --> 00:07:53,199
message queue and it gets saved there

244
00:07:53,199 --> 00:07:55,039
and then when the recipient says i want

245
00:07:55,039 --> 00:07:56,720
to receive a message

246
00:07:56,720 --> 00:07:58,879
it will get copied off into back into

247
00:07:58,879 --> 00:08:01,120
user mode so that's for to send one

248
00:08:01,120 --> 00:08:04,960
message that's um two copies

249
00:08:06,240 --> 00:08:08,240
sort of drive out

250
00:08:08,240 --> 00:08:11,759
um so the uh one of the performance

251
00:08:11,759 --> 00:08:13,120
to make that a little faster using

252
00:08:13,120 --> 00:08:15,759
completion lists

253
00:08:15,759 --> 00:08:17,680
so completion lists are

254
00:08:17,680 --> 00:08:18,879
they're kind of a region of memory

255
00:08:18,879 --> 00:08:21,039
that's created

256
00:08:21,039 --> 00:08:23,199
by either end of the board or both

257
00:08:23,199 --> 00:08:24,000
they're

258
00:08:24,000 --> 00:08:27,360
optional um and they

259
00:08:27,360 --> 00:08:28,720
it's a shared region of memory between

260
00:08:28,720 --> 00:08:32,399
the kernel and one end of the port

261
00:08:32,399 --> 00:08:34,799
and the what is used for storing any

262
00:08:34,799 --> 00:08:37,440
kind of pending receive messages um

263
00:08:37,440 --> 00:08:38,958
so there's different parts of a

264
00:08:38,958 --> 00:08:41,039
completion list there's a header which

265
00:08:41,039 --> 00:08:42,958
is the structure that you can see here

266
00:08:42,958 --> 00:08:44,240
and then there's a section that can kind

267
00:08:44,240 --> 00:08:45,839
of contains a list of any pending

268
00:08:45,839 --> 00:08:47,120
messages

269
00:08:47,120 --> 00:08:49,680
a bitmap section that's used to

270
00:08:49,680 --> 00:08:51,680
to do allocations out of the data

271
00:08:51,680 --> 00:08:54,399
section which is the last one

272
00:08:54,399 --> 00:08:56,000
and in the header as you can see there's

273
00:08:56,000 --> 00:08:58,080
like offsets and sizes of all the

274
00:08:58,080 --> 00:09:00,560
different sections

275
00:09:00,560 --> 00:09:02,800
um so look at kind of this and a picture

276
00:09:02,800 --> 00:09:03,680
form

277
00:09:03,680 --> 00:09:04,880
um

278
00:09:04,880 --> 00:09:06,160
so this is a

279
00:09:06,160 --> 00:09:08,720
kind of a completion list um and so you

280
00:09:08,720 --> 00:09:10,560
can see at the top there's a header it's

281
00:09:10,560 --> 00:09:11,920
got offsets to the three different

282
00:09:11,920 --> 00:09:12,959
sections

283
00:09:12,959 --> 00:09:14,959
um

284
00:09:14,959 --> 00:09:17,040
and so what happens when a uh when a new

285
00:09:17,040 --> 00:09:19,519
message comes in to be so if the

286
00:09:19,519 --> 00:09:20,880
kernel has a message and wants to

287
00:09:20,880 --> 00:09:23,440
deliver it to a port that has a

288
00:09:23,440 --> 00:09:25,040
completion list

289
00:09:25,040 --> 00:09:27,519
the first things it does is it looks for

290
00:09:27,519 --> 00:09:29,279
free memory in the completion list so

291
00:09:29,279 --> 00:09:30,880
it'll scan the bitmap looking for a

292
00:09:30,880 --> 00:09:32,720
range of zero bits

293
00:09:32,720 --> 00:09:35,040
to cover whatever the size is

294
00:09:35,040 --> 00:09:36,959
so the bitmap's all just zeros and ones

295
00:09:36,959 --> 00:09:38,800
and indicates which parts of the data

296
00:09:38,800 --> 00:09:40,720
are in use um

297
00:09:40,720 --> 00:09:42,959
once it finds a free section it'll do an

298
00:09:42,959 --> 00:09:44,640
interlocked exchange to set them all to

299
00:09:44,640 --> 00:09:47,040
one and then that will claim a chunk of

300
00:09:47,040 --> 00:09:49,600
data in the data section so then i can

301
00:09:49,600 --> 00:09:51,839
copy the the message data in

302
00:09:51,839 --> 00:09:54,880
um and at that point it'll copy the like

303
00:09:54,880 --> 00:09:56,959
four byte offset to the data and stick

304
00:09:56,959 --> 00:09:58,480
that into the

305
00:09:58,480 --> 00:09:59,760
wherever the list

306
00:09:59,760 --> 00:10:01,760
tail is pointing to so the list tail is

307
00:10:01,760 --> 00:10:04,640
just an offset into the list section

308
00:10:04,640 --> 00:10:06,800
and the list section is a group of

309
00:10:06,800 --> 00:10:08,480
offsets into the data section where the

310
00:10:08,480 --> 00:10:11,279
messages are so as messages are received

311
00:10:11,279 --> 00:10:13,040
and kind of waiting they'll get written

312
00:10:13,040 --> 00:10:13,920
in

313
00:10:13,920 --> 00:10:15,519
at the tail of the list

314
00:10:15,519 --> 00:10:17,200
and then when someone calls receive or

315
00:10:17,200 --> 00:10:18,320
when the client wants to receive a

316
00:10:18,320 --> 00:10:19,760
message they don't need to make any

317
00:10:19,760 --> 00:10:21,200
kernel calls

318
00:10:21,200 --> 00:10:22,399
they can just look at where the list

319
00:10:22,399 --> 00:10:24,640
head is get the offset for the data and

320
00:10:24,640 --> 00:10:26,160
then look down into the data section to

321
00:10:26,160 --> 00:10:27,680
read it out and once they've used the

322
00:10:27,680 --> 00:10:30,079
data they would just zero out the bits

323
00:10:30,079 --> 00:10:32,399
in the bitmap to free the memory

324
00:10:32,399 --> 00:10:34,560
and then adjust the list head up by one

325
00:10:34,560 --> 00:10:37,600
to say we've taken the message out

326
00:10:37,600 --> 00:10:39,360
um

327
00:10:39,360 --> 00:10:41,440
yeah so that's how they work

328
00:10:41,440 --> 00:10:43,360
and that's also where

329
00:10:43,360 --> 00:10:45,360
spotted the the first problem that kind

330
00:10:45,360 --> 00:10:47,600
of led me down this uh this research

331
00:10:47,600 --> 00:10:50,800
rabbit hole so this is the code

332
00:10:50,800 --> 00:10:51,839
for

333
00:10:51,839 --> 00:10:54,480
i hope it's big enough to read

334
00:10:54,480 --> 00:10:57,120
for complete dismap dispatch message so

335
00:10:57,120 --> 00:10:58,880
this is the code that handles once a

336
00:10:58,880 --> 00:11:00,240
message has been received into kernel

337
00:11:00,240 --> 00:11:01,839
mode and it's being

338
00:11:01,839 --> 00:11:04,000
added to the completion list of a

339
00:11:04,000 --> 00:11:05,279
client port

340
00:11:05,279 --> 00:11:07,920
um so down the left side kind of the the

341
00:11:07,920 --> 00:11:09,120
interesting parts are marked with

342
00:11:09,120 --> 00:11:11,440
comments so the first comment there

343
00:11:11,440 --> 00:11:12,640
is

344
00:11:12,640 --> 00:11:13,600
the

345
00:11:13,600 --> 00:11:15,040
call to allocate the buffer out of the

346
00:11:15,040 --> 00:11:18,000
data section so from that call um it it

347
00:11:18,000 --> 00:11:19,680
gets an offset of where it has enough

348
00:11:19,680 --> 00:11:21,200
free data for the message and then it

349
00:11:21,200 --> 00:11:23,360
calculates uh the user math message

350
00:11:23,360 --> 00:11:25,680
which is a pointer to this uh where the

351
00:11:25,680 --> 00:11:27,519
message is going to go in this shared

352
00:11:27,519 --> 00:11:30,079
memory region

353
00:11:30,079 --> 00:11:31,839
and then at the bottom

354
00:11:31,839 --> 00:11:34,399
of the screen on the left there

355
00:11:34,399 --> 00:11:36,160
it copies in all the port message

356
00:11:36,160 --> 00:11:37,839
headers so that includes all the length

357
00:11:37,839 --> 00:11:40,079
fields the header length data length and

358
00:11:40,079 --> 00:11:42,720
the flag fields and so then moving on on

359
00:11:42,720 --> 00:11:45,120
to the other side uh it then copies the

360
00:11:45,120 --> 00:11:47,440
actual data in um

361
00:11:47,440 --> 00:11:50,399
through those a couple of calls and then

362
00:11:50,399 --> 00:11:52,480
if so the important part is if there's

363
00:11:52,480 --> 00:11:53,920
any attributes in the message it needs

364
00:11:53,920 --> 00:11:55,519
to calculate where the attribute should

365
00:11:55,519 --> 00:11:58,399
go so it has to um

366
00:11:58,399 --> 00:11:59,839
figure out the location of kind of the

367
00:11:59,839 --> 00:12:02,160
source and that's the source set sorry

368
00:12:02,160 --> 00:12:03,600
has to figure out the location of the

369
00:12:03,600 --> 00:12:05,360
destination attributes

370
00:12:05,360 --> 00:12:07,440
by using the data length of the actual

371
00:12:07,440 --> 00:12:08,560
message

372
00:12:08,560 --> 00:12:10,800
and so the bug here is that

373
00:12:10,800 --> 00:12:12,800
it goes and reads the length instead of

374
00:12:12,800 --> 00:12:14,800
from the original kind of fixed copy it

375
00:12:14,800 --> 00:12:16,399
had it goes and reads it back out of the

376
00:12:16,399 --> 00:12:17,519
shared

377
00:12:17,519 --> 00:12:19,360
user buffer so it's copied the header

378
00:12:19,360 --> 00:12:20,959
already into this buffer that's shared

379
00:12:20,959 --> 00:12:22,160
with user mode

380
00:12:22,160 --> 00:12:23,519
and it goes in and reads the length out

381
00:12:23,519 --> 00:12:26,320
again so if a malicious application is

382
00:12:26,320 --> 00:12:28,639
able to change the length um in between

383
00:12:28,639 --> 00:12:30,959
these two uh

384
00:12:30,959 --> 00:12:32,639
the section and one where it copies the

385
00:12:32,639 --> 00:12:34,160
real value in and then where it actually

386
00:12:34,160 --> 00:12:36,480
uses it um we can end up with the

387
00:12:36,480 --> 00:12:38,639
attribute section or the destination for

388
00:12:38,639 --> 00:12:40,079
the attributes pointing past the end of

389
00:12:40,079 --> 00:12:41,519
this buffer

390
00:12:41,519 --> 00:12:42,320
um

391
00:12:42,320 --> 00:12:44,480
and so that's exactly what's possible

392
00:12:44,480 --> 00:12:46,480
and then you see this um expose

393
00:12:46,480 --> 00:12:47,920
attributes at the end that's essentially

394
00:12:47,920 --> 00:12:49,440
does copying of the attributes into the

395
00:12:49,440 --> 00:12:50,720
pointer so it gives us a memory

396
00:12:50,720 --> 00:12:52,959
corruption past the end of this um

397
00:12:52,959 --> 00:12:54,880
pointer so

398
00:12:54,880 --> 00:12:56,880
i found this and uh i was initially

399
00:12:56,880 --> 00:12:58,399
pretty excited because i

400
00:12:58,399 --> 00:13:00,160
knew you could use alpc from anywhere

401
00:13:00,160 --> 00:13:02,240
i'm like oh memory corruption from

402
00:13:02,240 --> 00:13:04,079
from inside you know kind of any sandbox

403
00:13:04,079 --> 00:13:07,560
sounds pretty exciting

404
00:13:07,600 --> 00:13:09,120
and uh we're thinking about what we

405
00:13:09,120 --> 00:13:10,639
should do with it well to determine that

406
00:13:10,639 --> 00:13:11,920
kind of the severity of the bug we

407
00:13:11,920 --> 00:13:13,519
wanted to look and see well can we prove

408
00:13:13,519 --> 00:13:15,680
whether or not it's exploitable so i

409
00:13:15,680 --> 00:13:17,519
started trying to look at well okay how

410
00:13:17,519 --> 00:13:19,600
do we turn this

411
00:13:19,600 --> 00:13:23,440
memory corruption into an exploit

412
00:13:23,440 --> 00:13:26,000
and so very quickly started running into

413
00:13:26,000 --> 00:13:28,800
a few hiccups

414
00:13:28,800 --> 00:13:30,880
so it turns out that this is not like

415
00:13:30,880 --> 00:13:34,399
standard page pool or non-page pool

416
00:13:34,399 --> 00:13:36,000
memory corruption

417
00:13:36,000 --> 00:13:37,760
which has all been like lots of

418
00:13:37,760 --> 00:13:39,600
information on how to exploit those and

419
00:13:39,600 --> 00:13:42,800
we'll get to that later too

420
00:13:42,800 --> 00:13:45,199
instead with this memory comes from

421
00:13:45,199 --> 00:13:48,639
this call here it's mapped block pages

422
00:13:48,639 --> 00:13:50,959
and so when the

423
00:13:50,959 --> 00:13:52,560
when the kernel says you know i want to

424
00:13:52,560 --> 00:13:54,639
map these pages into user mode or into

425
00:13:54,639 --> 00:13:57,199
kernel memory sorry

426
00:13:57,199 --> 00:13:58,880
the address range it comes from is

427
00:13:58,880 --> 00:14:00,720
actually from the system pte range and

428
00:14:00,720 --> 00:14:02,160
so you can see on the side i've used

429
00:14:02,160 --> 00:14:05,279
windbag to dump the address layout

430
00:14:05,279 --> 00:14:07,440
of the vm at the time

431
00:14:07,440 --> 00:14:09,120
and there's that system pte section

432
00:14:09,120 --> 00:14:10,720
highlighted in red so it comes from that

433
00:14:10,720 --> 00:14:12,000
address range

434
00:14:12,000 --> 00:14:13,360
you can see there's the page pools in

435
00:14:13,360 --> 00:14:15,279
there the couple of non-page pools and

436
00:14:15,279 --> 00:14:17,360
other address ranges um

437
00:14:17,360 --> 00:14:19,760
one thing to note about this is uh so

438
00:14:19,760 --> 00:14:21,519
for all i think all of windows 10

439
00:14:21,519 --> 00:14:23,600
definitely the newer ones

440
00:14:23,600 --> 00:14:25,839
all these addresses are randomized with

441
00:14:25,839 --> 00:14:27,600
kernel aslr on boot

442
00:14:27,600 --> 00:14:30,240
and the order changes and everything um

443
00:14:30,240 --> 00:14:31,760
also something to notice is that the

444
00:14:31,760 --> 00:14:33,920
size is really big a lot bigger than uh

445
00:14:33,920 --> 00:14:36,000
four gigabytes so even if you could

446
00:14:36,000 --> 00:14:37,519
predict what order they were going to be

447
00:14:37,519 --> 00:14:39,600
in and thought well maybe i can corrupt

448
00:14:39,600 --> 00:14:42,000
from one into the other that's

449
00:14:42,000 --> 00:14:43,920
you would need like a very specific kind

450
00:14:43,920 --> 00:14:45,360
of bug you definitely can't with this

451
00:14:45,360 --> 00:14:46,959
one

452
00:14:46,959 --> 00:14:48,000
um

453
00:14:48,000 --> 00:14:50,160
and so i started looking at the system

454
00:14:50,160 --> 00:14:52,639
pdes or what was what else was in that

455
00:14:52,639 --> 00:14:54,480
address range so to looking for some

456
00:14:54,480 --> 00:14:56,000
sort of primitives that could be used to

457
00:14:56,000 --> 00:14:58,079
groom or to you know to turn into an

458
00:14:58,079 --> 00:14:59,839
exploit

459
00:14:59,839 --> 00:15:01,680
and it turns out most of these are used

460
00:15:01,680 --> 00:15:03,440
for parameters and

461
00:15:03,440 --> 00:15:06,240
windows system calls

462
00:15:06,240 --> 00:15:07,600
and so which are typically very

463
00:15:07,600 --> 00:15:08,880
short-lived

464
00:15:08,880 --> 00:15:10,800
colonel will allocate some memory just

465
00:15:10,800 --> 00:15:12,399
during the system call and free it at

466
00:15:12,399 --> 00:15:13,920
the end

467
00:15:13,920 --> 00:15:16,160
and also almost in almost all of those

468
00:15:16,160 --> 00:15:18,480
cases all the data is coming from user

469
00:15:18,480 --> 00:15:20,320
mode are about to go to user mode so

470
00:15:20,320 --> 00:15:23,760
being able to change it doesn't add

471
00:15:23,760 --> 00:15:25,199
doesn't give it give us anything you can

472
00:15:25,199 --> 00:15:27,760
use towards exploitation um

473
00:15:27,760 --> 00:15:29,440
so what really would be looking for was

474
00:15:29,440 --> 00:15:30,320
kind of

475
00:15:30,320 --> 00:15:32,399
memory that or allocations in this

476
00:15:32,399 --> 00:15:33,440
address space that have a longer

477
00:15:33,440 --> 00:15:34,720
lifetime

478
00:15:34,720 --> 00:15:36,800
we can kind of free on demand and would

479
00:15:36,800 --> 00:15:39,680
have something useful in it

480
00:15:39,680 --> 00:15:42,320
i spent about a week

481
00:15:42,320 --> 00:15:44,399
looking looking for ways to solve this

482
00:15:44,399 --> 00:15:46,399
and started

483
00:15:46,399 --> 00:15:47,519
going through all different kind of

484
00:15:47,519 --> 00:15:50,560
areas of the kernel anywhere i thought

485
00:15:50,560 --> 00:15:52,079
something might be using this that could

486
00:15:52,079 --> 00:15:53,199
could be doing something interesting in

487
00:15:53,199 --> 00:15:54,399
this address space

488
00:15:54,399 --> 00:15:55,279
um

489
00:15:55,279 --> 00:15:56,800
and so the

490
00:15:56,800 --> 00:15:59,920
tldr on this is i wasn't successful um

491
00:15:59,920 --> 00:16:01,440
if anybody has good ideas about how to

492
00:16:01,440 --> 00:16:03,519
exploit this i'd be very curious to know

493
00:16:03,519 --> 00:16:04,320
um

494
00:16:04,320 --> 00:16:06,240
but if you're ever stuck and you can't

495
00:16:06,240 --> 00:16:07,920
figure out how to exploit a bug uh the

496
00:16:07,920 --> 00:16:10,480
easiest way is just to go find more

497
00:16:10,480 --> 00:16:11,519
um

498
00:16:11,519 --> 00:16:12,639
so

499
00:16:12,639 --> 00:16:14,560
one of the areas i i was looking into to

500
00:16:14,560 --> 00:16:16,399
try and find uh

501
00:16:16,399 --> 00:16:18,880
things that could be used to exploit

502
00:16:18,880 --> 00:16:23,720
the alpc bug was windows sockets

503
00:16:24,000 --> 00:16:26,560
so i was specifically choosing areas

504
00:16:26,560 --> 00:16:27,759
that i knew

505
00:16:27,759 --> 00:16:29,360
were still accessible from kind of low

506
00:16:29,360 --> 00:16:31,759
privileged processes this one sockets

507
00:16:31,759 --> 00:16:33,759
are not accessible from all sandboxes

508
00:16:33,759 --> 00:16:35,360
like not the browser sandboxes but they

509
00:16:35,360 --> 00:16:37,839
are from from some other ones

510
00:16:37,839 --> 00:16:40,079
uh and i also knew that windows sockets

511
00:16:40,079 --> 00:16:41,759
in particular are very

512
00:16:41,759 --> 00:16:43,360
very complex so i thought oh this might

513
00:16:43,360 --> 00:16:46,959
be a good idea good place to look for uh

514
00:16:46,959 --> 00:16:48,399
things that might have

515
00:16:48,399 --> 00:16:49,680
might help with

516
00:16:49,680 --> 00:16:51,680
the grooming or exploitation of the

517
00:16:51,680 --> 00:16:53,199
previous bug

518
00:16:53,199 --> 00:16:54,399
um

519
00:16:54,399 --> 00:16:56,560
so i don't expect you can read that but

520
00:16:56,560 --> 00:16:57,600
um

521
00:16:57,600 --> 00:17:00,399
so the the diagram on the right is kind

522
00:17:00,399 --> 00:17:03,839
of a rough diagram of um

523
00:17:03,839 --> 00:17:05,679
windows networking stack layout so

524
00:17:05,679 --> 00:17:08,480
windows provides a standard socket api

525
00:17:08,480 --> 00:17:09,599
it's almost

526
00:17:09,599 --> 00:17:11,839
posix compliant but probably not quite

527
00:17:11,839 --> 00:17:13,520
so you have all the standard socket

528
00:17:13,520 --> 00:17:15,520
calls but whereas in other os operating

529
00:17:15,520 --> 00:17:17,919
systems those are all syscalls directly

530
00:17:17,919 --> 00:17:19,839
to kernel and windows all that is

531
00:17:19,839 --> 00:17:21,760
implemented in winsock which is a user

532
00:17:21,760 --> 00:17:22,880
mode

533
00:17:22,880 --> 00:17:24,880
module and the actual kernel mode

534
00:17:24,880 --> 00:17:27,199
interface for sockets is through the

535
00:17:27,199 --> 00:17:30,559
ancillary function driver or afd.cis

536
00:17:30,559 --> 00:17:31,600
which is

537
00:17:31,600 --> 00:17:34,559
the opposite of simple so this uh the

538
00:17:34,559 --> 00:17:37,280
dispatch table i have in here um

539
00:17:37,280 --> 00:17:38,480
is just kind of a list of all the

540
00:17:38,480 --> 00:17:40,320
functions that are used just for doing

541
00:17:40,320 --> 00:17:42,640
control operations on the sockets and

542
00:17:42,640 --> 00:17:44,720
one of them is even as a secondary table

543
00:17:44,720 --> 00:17:46,160
so there's a whole other list of things

544
00:17:46,160 --> 00:17:47,280
oops

545
00:17:47,280 --> 00:17:49,280
um

546
00:17:49,280 --> 00:17:52,720
yeah so it's pretty complicated um

547
00:17:52,720 --> 00:17:54,559
so i thought it's good to look at so

548
00:17:54,559 --> 00:17:56,240
also in this diagram

549
00:17:56,240 --> 00:17:58,880
so there's afd.cis which is where

550
00:17:58,880 --> 00:18:00,720
user mode would normally interact with

551
00:18:00,720 --> 00:18:01,919
the kernel

552
00:18:01,919 --> 00:18:04,000
but if you're a kernel device driver and

553
00:18:04,000 --> 00:18:06,320
you want to do networking

554
00:18:06,320 --> 00:18:08,400
in the past the legacy interface just

555
00:18:08,400 --> 00:18:10,160
used the transport driver interface or

556
00:18:10,160 --> 00:18:12,240
tdi.cis

557
00:18:12,240 --> 00:18:13,520
and the

558
00:18:13,520 --> 00:18:14,960
new way well

559
00:18:14,960 --> 00:18:16,720
it's been around since vista but the the

560
00:18:16,720 --> 00:18:19,120
new way um is to use the windsock kernel

561
00:18:19,120 --> 00:18:21,840
uh interface uh or wsk

562
00:18:21,840 --> 00:18:23,280
but they keep around for backwards

563
00:18:23,280 --> 00:18:26,320
compatibility uh tdi interface

564
00:18:26,320 --> 00:18:28,720
and then from there uh anybody talking

565
00:18:28,720 --> 00:18:31,120
to afd or or one of the two kernel mode

566
00:18:31,120 --> 00:18:32,640
options would then be able to talk down

567
00:18:32,640 --> 00:18:33,760
the network stack to the different

568
00:18:33,760 --> 00:18:36,080
layers

569
00:18:37,039 --> 00:18:40,000
um so going into a little bit of details

570
00:18:40,000 --> 00:18:43,840
about how sockets were created

571
00:18:44,000 --> 00:18:45,840
so to create a socket you just can open

572
00:18:45,840 --> 00:18:48,160
up the afd device with this

573
00:18:48,160 --> 00:18:50,799
special endpoint path on the end

574
00:18:50,799 --> 00:18:53,320
so you open up device slash afd

575
00:18:53,320 --> 00:18:56,799
endpoint um

576
00:18:56,799 --> 00:18:59,120
and to specify the options about how the

577
00:18:59,120 --> 00:19:01,200
socket can be created you

578
00:19:01,200 --> 00:19:03,919
use extended attributes um and depending

579
00:19:03,919 --> 00:19:06,160
on the specifics of the extended

580
00:19:06,160 --> 00:19:07,840
attribute name and what's in there you

581
00:19:07,840 --> 00:19:08,720
can do

582
00:19:08,720 --> 00:19:10,160
you can create your whole family of

583
00:19:10,160 --> 00:19:13,120
normal networking sockets there's also

584
00:19:13,120 --> 00:19:14,960
sand sockets

585
00:19:14,960 --> 00:19:17,840
for talking to storage area networks

586
00:19:17,840 --> 00:19:20,559
or rio sockets which were news to me so

587
00:19:20,559 --> 00:19:23,520
this is a registered i o extension i was

588
00:19:23,520 --> 00:19:25,840
introduced around windows 8 and it's to

589
00:19:25,840 --> 00:19:28,879
allow faster i o

590
00:19:28,960 --> 00:19:31,440
with sockets um i didn't really play

591
00:19:31,440 --> 00:19:32,799
around with them so i don't know more

592
00:19:32,799 --> 00:19:34,559
than that but if you wanted to do the

593
00:19:34,559 --> 00:19:39,200
standard tcp udp unix sockets you use an

594
00:19:39,200 --> 00:19:41,360
extended attribute name of this afd open

595
00:19:41,360 --> 00:19:43,200
packet

596
00:19:43,200 --> 00:19:45,120
xx and i have in the comments that are

597
00:19:45,120 --> 00:19:46,640
kind of the

598
00:19:46,640 --> 00:19:48,160
the fields

599
00:19:48,160 --> 00:19:49,679
that you would fill out to get a tcp

600
00:19:49,679 --> 00:19:51,840
socket um so you have flags

601
00:19:51,840 --> 00:19:53,440
the flags field you can

602
00:19:53,440 --> 00:19:54,799
just how you specify like you want to

603
00:19:54,799 --> 00:19:57,360
raw socket or connection list or see

604
00:19:57,360 --> 00:20:00,480
root a whole bunch of different options

605
00:20:00,480 --> 00:20:02,080
there's also your standard address

606
00:20:02,080 --> 00:20:04,000
family

607
00:20:04,000 --> 00:20:06,000
address family address type and protocol

608
00:20:06,000 --> 00:20:09,760
fields um and you can also specify a

609
00:20:09,760 --> 00:20:11,440
device name a transport device name at

610
00:20:11,440 --> 00:20:13,039
the end so in this case we're saying we

611
00:20:13,039 --> 00:20:14,880
want to use the tcp driver as the

612
00:20:14,880 --> 00:20:17,360
transport you could also specify

613
00:20:17,360 --> 00:20:19,200
udp or there's a couple different

614
00:20:19,200 --> 00:20:20,400
options

615
00:20:20,400 --> 00:20:21,679
so

616
00:20:21,679 --> 00:20:23,600
the interesting thing when i started

617
00:20:23,600 --> 00:20:26,240
looking at this and how this is handled

618
00:20:26,240 --> 00:20:27,360
is that there's a whole bunch of

619
00:20:27,360 --> 00:20:29,760
different ways to do kind of the same

620
00:20:29,760 --> 00:20:31,360
thing and

621
00:20:31,360 --> 00:20:33,440
changing these

622
00:20:33,440 --> 00:20:35,360
the values slightly in this packet ends

623
00:20:35,360 --> 00:20:36,880
up creating

624
00:20:36,880 --> 00:20:38,159
sockets that are treated slightly

625
00:20:38,159 --> 00:20:41,039
differently by the kernel

626
00:20:41,760 --> 00:20:43,919
so if you send in these parameters here

627
00:20:43,919 --> 00:20:46,320
you'll get a tcp socket

628
00:20:46,320 --> 00:20:48,000
out of it

629
00:20:48,000 --> 00:20:50,559
a handle to a tcp socket and if you

630
00:20:50,559 --> 00:20:52,799
remove the transport name from this and

631
00:20:52,799 --> 00:20:55,200
just put in the address family address

632
00:20:55,200 --> 00:20:57,120
type and protocol you get a tcp socket

633
00:20:57,120 --> 00:20:59,440
as well

634
00:20:59,440 --> 00:21:01,679
or if you just remove set the protocol

635
00:21:01,679 --> 00:21:04,240
field to zero you also get a tcp socket

636
00:21:04,240 --> 00:21:06,159
which seems like you know not not a big

637
00:21:06,159 --> 00:21:08,559
deal but actually internally afd is

638
00:21:08,559 --> 00:21:10,960
going to have set different flags on the

639
00:21:10,960 --> 00:21:13,120
endpoint object that gets created

640
00:21:13,120 --> 00:21:14,720
which is going to result in slightly

641
00:21:14,720 --> 00:21:16,400
different code paths

642
00:21:16,400 --> 00:21:17,919
happening in the kernel so you might not

643
00:21:17,919 --> 00:21:19,760
notice it from user mode at all but in

644
00:21:19,760 --> 00:21:20,880
the kernel

645
00:21:20,880 --> 00:21:21,600
the

646
00:21:21,600 --> 00:21:22,960
the rest of the operations on that

647
00:21:22,960 --> 00:21:24,799
socket are being handled slightly

648
00:21:24,799 --> 00:21:27,200
differently

649
00:21:28,480 --> 00:21:30,480
other thing uh

650
00:21:30,480 --> 00:21:32,320
we spent some time looking into was okay

651
00:21:32,320 --> 00:21:33,919
well how are um

652
00:21:33,919 --> 00:21:35,600
options set on the socket so this is

653
00:21:35,600 --> 00:21:37,840
your standard eye optical socket set

654
00:21:37,840 --> 00:21:40,559
socket option uh calls um all of these

655
00:21:40,559 --> 00:21:42,320
are handled by the uh

656
00:21:42,320 --> 00:21:47,520
this uh afd tli i o control uh dispatch

657
00:21:47,520 --> 00:21:48,320
um

658
00:21:48,320 --> 00:21:50,000
and they come in from user mode and

659
00:21:50,000 --> 00:21:51,360
there's a little bit of validation that

660
00:21:51,360 --> 00:21:53,280
happens and then they get passed on down

661
00:21:53,280 --> 00:21:55,760
to the various uh lower level transport

662
00:21:55,760 --> 00:21:58,480
drivers whether it's tcp or the pacer

663
00:21:58,480 --> 00:22:00,080
driver or the

664
00:22:00,080 --> 00:22:02,799
unix socket driver

665
00:22:02,799 --> 00:22:04,400
and through the validation user mode's

666
00:22:04,400 --> 00:22:05,919
restricted to kind of a subset of

667
00:22:05,919 --> 00:22:08,320
options so on the right this is the the

668
00:22:08,320 --> 00:22:09,840
structure that gets passed in from user

669
00:22:09,840 --> 00:22:13,120
mode so we have a type field which is

670
00:22:13,120 --> 00:22:14,880
tells the uh

671
00:22:14,880 --> 00:22:16,080
indicates whether you're doing you're

672
00:22:16,080 --> 00:22:17,840
setting a socket option getting one

673
00:22:17,840 --> 00:22:19,840
doing the i octal socket

674
00:22:19,840 --> 00:22:22,400
or it can be zero which is uh

675
00:22:22,400 --> 00:22:24,159
not allowed in user mode it's for

676
00:22:24,159 --> 00:22:26,400
internal only you set your

677
00:22:26,400 --> 00:22:28,880
level and then ioptil code and the data

678
00:22:28,880 --> 00:22:30,720
that goes in

679
00:22:30,720 --> 00:22:32,000
um

680
00:22:32,000 --> 00:22:33,440
so in terms of the validation that

681
00:22:33,440 --> 00:22:37,840
happens uh this function here the

682
00:22:37,840 --> 00:22:39,840
on the left gets called and so this is

683
00:22:39,840 --> 00:22:41,360
saying it gets calls that's coming from

684
00:22:41,360 --> 00:22:43,280
user mode so first of all i make sure

685
00:22:43,280 --> 00:22:46,000
that that endpoint field um

686
00:22:46,000 --> 00:22:48,720
is set in the packet

687
00:22:48,720 --> 00:22:50,400
and then it checks the type so the first

688
00:22:50,400 --> 00:22:52,320
block the one or two was set or get

689
00:22:52,320 --> 00:22:55,760
ioctyls set or sorry not iota set or get

690
00:22:55,760 --> 00:22:58,320
socket options um and if you're that it

691
00:22:58,320 --> 00:23:00,400
makes sure that your socket level is not

692
00:23:00,400 --> 00:23:01,360
uh

693
00:23:01,360 --> 00:23:03,840
well these two values you can't do fff c

694
00:23:03,840 --> 00:23:06,640
or d um anything else is okay and then

695
00:23:06,640 --> 00:23:09,840
the else case saying it's also okay if

696
00:23:09,840 --> 00:23:12,480
it's type three which is ioctal socket

697
00:23:12,480 --> 00:23:14,799
and your level is zero

698
00:23:14,799 --> 00:23:16,720
so that restricts any use of the

699
00:23:16,720 --> 00:23:18,000
internal option

700
00:23:18,000 --> 00:23:19,520
and then on the other side

701
00:23:19,520 --> 00:23:21,520
just after this function is called

702
00:23:21,520 --> 00:23:23,440
there's also handling

703
00:23:23,440 --> 00:23:25,760
for a couple of special ioctal codes

704
00:23:25,760 --> 00:23:27,120
so this

705
00:23:27,120 --> 00:23:30,559
the first one is a set qos

706
00:23:30,559 --> 00:23:32,000
and it does some special handling for

707
00:23:32,000 --> 00:23:34,080
that and the second one

708
00:23:34,080 --> 00:23:36,080
function code if you look it up in wk is

709
00:23:36,080 --> 00:23:39,440
in the wdk headers is reserved um but

710
00:23:39,440 --> 00:23:41,600
with the symbols the function that it

711
00:23:41,600 --> 00:23:43,840
calls is associate qos so presumably

712
00:23:43,840 --> 00:23:44,640
that's

713
00:23:44,640 --> 00:23:47,600
uh socket option associate qos

714
00:23:47,600 --> 00:23:48,880
and what both of those

715
00:23:48,880 --> 00:23:50,159
functions do is they just do some

716
00:23:50,159 --> 00:23:51,760
conversion on the buffer so you pass in

717
00:23:51,760 --> 00:23:53,279
some input buffer they do a bit of

718
00:23:53,279 --> 00:23:55,440
special conversion and then send a new

719
00:23:55,440 --> 00:23:56,880
buffer down through the rest of the

720
00:23:56,880 --> 00:23:59,440
kernel stack

721
00:23:59,919 --> 00:24:01,200
yeah so this is going to become

722
00:24:01,200 --> 00:24:02,840
important

723
00:24:02,840 --> 00:24:08,000
later um so next up we have the uh

724
00:24:09,760 --> 00:24:12,159
well i guess i'll back up a second so

725
00:24:12,159 --> 00:24:13,919
one one thing i thought of kind of when

726
00:24:13,919 --> 00:24:16,960
i got to here was um

727
00:24:16,960 --> 00:24:18,880
so initially i was just going through

728
00:24:18,880 --> 00:24:20,240
and looking for

729
00:24:20,240 --> 00:24:22,000
allocations for things that i could

730
00:24:22,000 --> 00:24:24,960
groom the first bug with um

731
00:24:24,960 --> 00:24:26,880
but as i kind of learned more about the

732
00:24:26,880 --> 00:24:28,400
code base i started thinking i was like

733
00:24:28,400 --> 00:24:30,480
well i wonder if there's like a way to

734
00:24:30,480 --> 00:24:32,240
bypass these checks because of all these

735
00:24:32,240 --> 00:24:34,720
different options on the sockets um

736
00:24:34,720 --> 00:24:37,039
it could change how

737
00:24:37,039 --> 00:24:38,960
what different code pads there were so i

738
00:24:38,960 --> 00:24:40,159
started looking

739
00:24:40,159 --> 00:24:41,440
at keeping that kind of in the back of

740
00:24:41,440 --> 00:24:43,120
my mind is something i wanted to keep an

741
00:24:43,120 --> 00:24:45,440
eye out for

742
00:24:45,440 --> 00:24:47,279
so i already mentioned this tdi

743
00:24:47,279 --> 00:24:50,000
interface um so yeah it's the legacy

744
00:24:50,000 --> 00:24:53,279
interface um and so what kernel clients

745
00:24:53,279 --> 00:24:55,440
would do is if they uh

746
00:24:55,440 --> 00:24:58,480
they would create a socket um

747
00:24:58,480 --> 00:25:01,520
through the tdi or an endpoint socket

748
00:25:01,520 --> 00:25:03,279
and if they want to set options they

749
00:25:03,279 --> 00:25:05,919
talk um directly

750
00:25:05,919 --> 00:25:06,960
to uh

751
00:25:06,960 --> 00:25:08,799
originally it was tdi but there's this

752
00:25:08,799 --> 00:25:09,919
driver at

753
00:25:09,919 --> 00:25:11,520
transport driver

754
00:25:11,520 --> 00:25:14,240
interface extension or tdx.sys and

755
00:25:14,240 --> 00:25:15,679
really it's just

756
00:25:15,679 --> 00:25:17,760
provides the old interface and as a

757
00:25:17,760 --> 00:25:20,640
wrapper to the new tcp

758
00:25:20,640 --> 00:25:23,440
afd stack so if you're setting options

759
00:25:23,440 --> 00:25:26,320
in that case the old legacy drivers will

760
00:25:26,320 --> 00:25:27,760
talk to tdx

761
00:25:27,760 --> 00:25:30,000
and can send ioctals directly into the

762
00:25:30,000 --> 00:25:31,679
stack and it

763
00:25:31,679 --> 00:25:33,200
doesn't go through the same validation

764
00:25:33,200 --> 00:25:35,760
that's in afd.cis

765
00:25:35,760 --> 00:25:37,279
whereas a regular application it will

766
00:25:37,279 --> 00:25:39,440
get a socket handle

767
00:25:39,440 --> 00:25:41,520
it talks to afd.cis it goes through the

768
00:25:41,520 --> 00:25:43,600
validation code

769
00:25:43,600 --> 00:25:46,159
and then afd will look up what's the

770
00:25:46,159 --> 00:25:47,919
transport layer endpoint and then send

771
00:25:47,919 --> 00:25:51,600
the ioctyl packet on down

772
00:25:52,000 --> 00:25:53,919
and so i began wondering well is there

773
00:25:53,919 --> 00:25:55,760
any way for us for a user mode

774
00:25:55,760 --> 00:25:59,600
application to talk to tdx directly

775
00:26:02,080 --> 00:26:03,279
and so there is

776
00:26:03,279 --> 00:26:04,480
you can you can open a handle to the

777
00:26:04,480 --> 00:26:05,919
device

778
00:26:05,919 --> 00:26:07,520
but you can't open any endpoints on it

779
00:26:07,520 --> 00:26:08,559
that's all

780
00:26:08,559 --> 00:26:10,400
blocked from user mode there's a couple

781
00:26:10,400 --> 00:26:12,880
of kind of control eye octals that don't

782
00:26:12,880 --> 00:26:15,840
do anything interesting

783
00:26:15,840 --> 00:26:16,720
but

784
00:26:16,720 --> 00:26:18,960
what i did find out was that if you use

785
00:26:18,960 --> 00:26:20,799
some of those different options i was

786
00:26:20,799 --> 00:26:24,400
talking about earlier um

787
00:26:24,400 --> 00:26:26,240
depending on how you create the socket

788
00:26:26,240 --> 00:26:28,559
uh it can have handles as the end the

789
00:26:28,559 --> 00:26:30,400
kernel endpoint for the socket will have

790
00:26:30,400 --> 00:26:32,640
handles associated with the transport

791
00:26:32,640 --> 00:26:36,080
layer driver um

792
00:26:36,320 --> 00:26:37,840
and the endpoint and the transport layer

793
00:26:37,840 --> 00:26:40,640
endpoint can be associated with the

794
00:26:40,640 --> 00:26:42,400
with the socket and there's one of the

795
00:26:42,400 --> 00:26:44,080
afd functions and that big dispatch

796
00:26:44,080 --> 00:26:45,760
table was a function to query those

797
00:26:45,760 --> 00:26:48,559
handles so if you create the socket in

798
00:26:48,559 --> 00:26:50,240
just the right way and then you issue

799
00:26:50,240 --> 00:26:52,400
this query handle call

800
00:26:52,400 --> 00:26:55,760
afd will return you a handle to the tdx

801
00:26:55,760 --> 00:26:57,520
endpoint so which we couldn't open

802
00:26:57,520 --> 00:26:59,840
directly but if colonel's kind enough to

803
00:26:59,840 --> 00:27:01,120
give us a handle then we could start

804
00:27:01,120 --> 00:27:03,679
talking to it so with that handle we're

805
00:27:03,679 --> 00:27:07,440
able to call into the tdx drivers

806
00:27:07,440 --> 00:27:09,919
ioctal interface

807
00:27:09,919 --> 00:27:13,120
and bypass afd entirely in all the

808
00:27:13,120 --> 00:27:15,200
protections that were in there

809
00:27:15,200 --> 00:27:16,240
so

810
00:27:16,240 --> 00:27:17,600
i thought well that's for sure there's

811
00:27:17,600 --> 00:27:18,960
got to be

812
00:27:18,960 --> 00:27:21,760
bugs if we can hit that code path so at

813
00:27:21,760 --> 00:27:23,039
that point i started saying well i'm

814
00:27:23,039 --> 00:27:25,520
going to start auditing some of these uh

815
00:27:25,520 --> 00:27:27,520
transport drivers and look at their eye

816
00:27:27,520 --> 00:27:29,360
octal handlers or set socket option

817
00:27:29,360 --> 00:27:30,720
handlers

818
00:27:30,720 --> 00:27:32,000
and see if there's anything interesting

819
00:27:32,000 --> 00:27:34,480
going on there if i don't have the same

820
00:27:34,480 --> 00:27:36,159
restrictions

821
00:27:36,159 --> 00:27:37,360
um

822
00:27:37,360 --> 00:27:39,120
and so that's where i found the first

823
00:27:39,120 --> 00:27:41,120
bug um

824
00:27:41,120 --> 00:27:43,360
down here uh and so all the bugs that i

825
00:27:43,360 --> 00:27:45,919
mentioned here almost all of them

826
00:27:45,919 --> 00:27:48,080
have been uh

827
00:27:48,080 --> 00:27:49,200
all the ones i'm going to give details

828
00:27:49,200 --> 00:27:51,520
for have been patched already

829
00:27:51,520 --> 00:27:53,760
um

830
00:27:54,559 --> 00:27:56,000
yeah i don't really have much much code

831
00:27:56,000 --> 00:27:57,679
for this i started looking at what you

832
00:27:57,679 --> 00:27:59,520
could hit if you set uh

833
00:27:59,520 --> 00:28:01,600
the type to zero so zero again was the

834
00:28:01,600 --> 00:28:05,279
control only or internal only option

835
00:28:05,279 --> 00:28:07,039
and one of the

836
00:28:07,039 --> 00:28:08,799
things that got called was this query

837
00:28:08,799 --> 00:28:11,200
security endpoint function which simply

838
00:28:11,200 --> 00:28:14,159
returns a pointer to the security

839
00:28:14,159 --> 00:28:16,159
descriptor for the socket there's no

840
00:28:16,159 --> 00:28:17,919
like

841
00:28:17,919 --> 00:28:19,919
it's not even a bug it's just it was

842
00:28:19,919 --> 00:28:21,440
never supposed to be called by user mode

843
00:28:21,440 --> 00:28:23,440
so right away you get a

844
00:28:23,440 --> 00:28:25,200
an address in the page pool

845
00:28:25,200 --> 00:28:27,440
from the kernel so super super easy info

846
00:28:27,440 --> 00:28:30,559
leak um

847
00:28:30,559 --> 00:28:32,080
yeah oh and one thing i wanted to point

848
00:28:32,080 --> 00:28:33,679
out with a slide too is uh if you look

849
00:28:33,679 --> 00:28:36,080
at the i octal structure structure here

850
00:28:36,080 --> 00:28:37,600
um it's a little bit different than the

851
00:28:37,600 --> 00:28:39,919
one that we used through afd so there's

852
00:28:39,919 --> 00:28:43,120
none there's a few less fields

853
00:28:43,120 --> 00:28:44,960
just type level ioctal and then we have

854
00:28:44,960 --> 00:28:48,559
an input buffer and an output buffer but

855
00:28:48,559 --> 00:28:50,240
otherwise it's handled the same once you

856
00:28:50,240 --> 00:28:52,480
get down to this level

857
00:28:52,480 --> 00:28:54,000
um

858
00:28:54,000 --> 00:28:56,559
so i i didn't do a demo of this just

859
00:28:56,559 --> 00:28:59,520
took a screenshot of this so it's

860
00:28:59,520 --> 00:29:01,600
really simple code you just open the

861
00:29:01,600 --> 00:29:03,279
endpoint with the right

862
00:29:03,279 --> 00:29:04,480
flag set

863
00:29:04,480 --> 00:29:06,720
um

864
00:29:07,120 --> 00:29:08,480
but one thing i should mention in order

865
00:29:08,480 --> 00:29:10,240
for this whole bypass to work you have

866
00:29:10,240 --> 00:29:12,640
to bind uh yeah you either have to

867
00:29:12,640 --> 00:29:14,080
connect the socket or bind it to an

868
00:29:14,080 --> 00:29:16,640
address um otherwise the

869
00:29:16,640 --> 00:29:19,120
the handles don't get set for the tdx

870
00:29:19,120 --> 00:29:20,480
endpoint

871
00:29:20,480 --> 00:29:22,799
so that does prevent the bypass from

872
00:29:22,799 --> 00:29:24,799
working inside all the sandboxes i

873
00:29:24,799 --> 00:29:27,440
looked at

874
00:29:27,440 --> 00:29:29,600
so you bind the socket and then you

875
00:29:29,600 --> 00:29:31,360
query the tdx handle and then you just

876
00:29:31,360 --> 00:29:33,039
call this one nioctyl and it sends you

877
00:29:33,039 --> 00:29:36,640
back a page pool pointer

878
00:29:39,039 --> 00:29:40,880
but that's not just an info leaks not

879
00:29:40,880 --> 00:29:42,799
too exciting however

880
00:29:42,799 --> 00:29:43,679
um

881
00:29:43,679 --> 00:29:45,600
there's the corresponding function uh

882
00:29:45,600 --> 00:29:47,440
that's set security so the first one was

883
00:29:47,440 --> 00:29:49,919
a query security there's a set security

884
00:29:49,919 --> 00:29:51,840
it's exactly the same except instead of

885
00:29:51,840 --> 00:29:53,120
reading the pointer out you get to write

886
00:29:53,120 --> 00:29:55,440
the pointer so this lets an attacker

887
00:29:55,440 --> 00:29:57,440
write

888
00:29:57,440 --> 00:29:59,520
set the security descriptor for saka to

889
00:29:59,520 --> 00:30:02,080
any value

890
00:30:02,399 --> 00:30:03,600
so

891
00:30:03,600 --> 00:30:04,960
that's kind of neat well what does it do

892
00:30:04,960 --> 00:30:06,159
with that

893
00:30:06,159 --> 00:30:07,520
there's probably

894
00:30:07,520 --> 00:30:10,000
multiple ways to approach this um but it

895
00:30:10,000 --> 00:30:12,159
turned out the uh

896
00:30:12,159 --> 00:30:14,559
the easiest way was kind of right right

897
00:30:14,559 --> 00:30:15,760
right there as soon as when i was

898
00:30:15,760 --> 00:30:17,360
looking at the code it just takes the

899
00:30:17,360 --> 00:30:19,360
pointer from user mode and then calls

900
00:30:19,360 --> 00:30:21,520
this ob reference security descriptor on

901
00:30:21,520 --> 00:30:22,399
it

902
00:30:22,399 --> 00:30:23,919
and if you look at that function it just

903
00:30:23,919 --> 00:30:25,600
does a little bit of pointer math and

904
00:30:25,600 --> 00:30:26,399
then

905
00:30:26,399 --> 00:30:28,320
does an increment on that address so

906
00:30:28,320 --> 00:30:31,200
this gives you an arbitrary increment of

907
00:30:31,200 --> 00:30:33,520
any address in the kernel

908
00:30:33,520 --> 00:30:35,200
so that's

909
00:30:35,200 --> 00:30:36,399
especially with an info league that

910
00:30:36,399 --> 00:30:38,080
should definitely be enough

911
00:30:38,080 --> 00:30:39,200
to win

912
00:30:39,200 --> 00:30:40,320
um

913
00:30:40,320 --> 00:30:43,279
one thing i found looking for bugs is

914
00:30:43,279 --> 00:30:45,520
what two things i guess one is if you're

915
00:30:45,520 --> 00:30:47,840
in an area of code and you start finding

916
00:30:47,840 --> 00:30:49,840
bugs there's a good chance there's going

917
00:30:49,840 --> 00:30:51,679
to be more because of either has not

918
00:30:51,679 --> 00:30:54,000
been audited well or the person was was

919
00:30:54,000 --> 00:30:55,440
not thinking uh didn't have the right

920
00:30:55,440 --> 00:30:58,159
mindset to program defensively uh and

921
00:30:58,159 --> 00:30:59,919
also i find i'll get to do it like a

922
00:30:59,919 --> 00:31:02,399
role so if i'm able to spot a particular

923
00:31:02,399 --> 00:31:03,919
type of bug

924
00:31:03,919 --> 00:31:05,600
i usually start seeing it

925
00:31:05,600 --> 00:31:06,960
tend to they tend to come in bunches

926
00:31:06,960 --> 00:31:08,799
anyway finding bugs

927
00:31:08,799 --> 00:31:10,720
um just not usually

928
00:31:10,720 --> 00:31:13,039
this many so the second

929
00:31:13,039 --> 00:31:14,399
thing if you recall when i talked back

930
00:31:14,399 --> 00:31:16,000
about the validation

931
00:31:16,000 --> 00:31:19,840
there was also um

932
00:31:20,000 --> 00:31:21,600
besides just the restrictions on types

933
00:31:21,600 --> 00:31:22,720
coming in there was also those two

934
00:31:22,720 --> 00:31:24,960
functions that did some extra massaging

935
00:31:24,960 --> 00:31:27,200
of the input data so there was a this

936
00:31:27,200 --> 00:31:31,120
associate qos or quality of service

937
00:31:31,120 --> 00:31:33,760
function and what that was

938
00:31:33,760 --> 00:31:35,519
did was like i mentioned it was

939
00:31:35,519 --> 00:31:36,880
converting the input buffer into some

940
00:31:36,880 --> 00:31:39,039
other format so

941
00:31:39,039 --> 00:31:41,120
this one was not uh there's no symbols

942
00:31:41,120 --> 00:31:43,440
for what the or use examples of using it

943
00:31:43,440 --> 00:31:44,640
so i don't know entirely what the

944
00:31:44,640 --> 00:31:45,760
structure is

945
00:31:45,760 --> 00:31:46,880
but there was some structure you were

946
00:31:46,880 --> 00:31:48,720
supposed to pass in on the left

947
00:31:48,720 --> 00:31:50,320
that has a file handle and some other

948
00:31:50,320 --> 00:31:52,240
value and then it would get converted to

949
00:31:52,240 --> 00:31:54,159
this structure on the right that has a

950
00:31:54,159 --> 00:31:56,240
file object pointer so it looks up the

951
00:31:56,240 --> 00:31:58,000
object for the file handle

952
00:31:58,000 --> 00:32:00,559
and a couple of other values uh and so

953
00:32:00,559 --> 00:32:02,159
when you come in through

954
00:32:02,159 --> 00:32:04,880
the tdx bypass you're able to pass in

955
00:32:04,880 --> 00:32:06,640
the structure on the right so you can

956
00:32:06,640 --> 00:32:08,960
pass in a pointer to an arbitrary file

957
00:32:08,960 --> 00:32:11,519
object um

958
00:32:11,519 --> 00:32:12,880
which is the file objects are pretty

959
00:32:12,880 --> 00:32:16,480
complicated there's for sure a way to

960
00:32:16,480 --> 00:32:18,080
exploit that

961
00:32:18,080 --> 00:32:20,000
but when i started looking at it

962
00:32:20,000 --> 00:32:21,440
so this is the

963
00:32:21,440 --> 00:32:24,880
the function here at the top

964
00:32:24,960 --> 00:32:26,880
so the second case is if you pass in

965
00:32:26,880 --> 00:32:28,399
that structure with the file object

966
00:32:28,399 --> 00:32:29,360
pointer

967
00:32:29,360 --> 00:32:30,799
it starts doing a whole bunch of stuff

968
00:32:30,799 --> 00:32:32,799
with the file object it very quickly got

969
00:32:32,799 --> 00:32:34,799
complicated uh

970
00:32:34,799 --> 00:32:36,240
all the things hoops you'd have to jump

971
00:32:36,240 --> 00:32:38,240
through to try and keep it from crashing

972
00:32:38,240 --> 00:32:40,080
while getting some useful primitive out

973
00:32:40,080 --> 00:32:41,440
of it

974
00:32:41,440 --> 00:32:42,960
then i noticed that at the beginning of

975
00:32:42,960 --> 00:32:44,640
the this function there was a check and

976
00:32:44,640 --> 00:32:46,320
said if you didn't pass in the proper

977
00:32:46,320 --> 00:32:48,720
structure and you just pass in a pointer

978
00:32:48,720 --> 00:32:50,000
we're just going to bump a reference

979
00:32:50,000 --> 00:32:52,720
count on that so

980
00:32:52,720 --> 00:32:54,320
this is another

981
00:32:54,320 --> 00:32:57,600
arbitrary increment uh primitive here

982
00:32:57,600 --> 00:32:59,440
so that was the uh

983
00:32:59,440 --> 00:33:00,880
the second one

984
00:33:00,880 --> 00:33:02,000
so the uh

985
00:33:02,000 --> 00:33:04,880
the third one and interesting they um

986
00:33:04,880 --> 00:33:06,720
uh when microsoft assigned cves for

987
00:33:06,720 --> 00:33:10,000
these although the info leak and these

988
00:33:10,000 --> 00:33:13,440
three bugs i'm talking about right here

989
00:33:15,760 --> 00:33:18,080
we're all

990
00:33:18,080 --> 00:33:20,480
required the bypass to work

991
00:33:20,480 --> 00:33:22,240
the info leak got a separate cve and

992
00:33:22,240 --> 00:33:24,080
then these three different privilege

993
00:33:24,080 --> 00:33:25,600
elevation ones all got grouped under the

994
00:33:25,600 --> 00:33:27,519
same one

995
00:33:27,519 --> 00:33:29,760
and so the last one was this other

996
00:33:29,760 --> 00:33:33,360
function that i mentioned the set qos

997
00:33:33,360 --> 00:33:34,960
and this one was a little bit different

998
00:33:34,960 --> 00:33:36,840
so this one is in

999
00:33:36,840 --> 00:33:38,960
the the

1000
00:33:38,960 --> 00:33:40,159
sdk

1001
00:33:40,159 --> 00:33:41,440
so what you're supposed to pass in is

1002
00:33:41,440 --> 00:33:43,039
the structure on the right

1003
00:33:43,039 --> 00:33:44,720
which is a quality of service structure

1004
00:33:44,720 --> 00:33:46,080
it's got a couple of

1005
00:33:46,080 --> 00:33:49,440
flow specification fields and then a wsa

1006
00:33:49,440 --> 00:33:51,360
buffer structure which contains a

1007
00:33:51,360 --> 00:33:53,200
pointer to some other data

1008
00:33:53,200 --> 00:33:56,159
so all this special set qos handler did

1009
00:33:56,159 --> 00:33:57,440
was say well i'm going to take those two

1010
00:33:57,440 --> 00:33:59,840
user mode buffers allocate one in kernel

1011
00:33:59,840 --> 00:34:01,440
and stick them in it together

1012
00:34:01,440 --> 00:34:03,600
um

1013
00:34:04,960 --> 00:34:06,960
right

1014
00:34:06,960 --> 00:34:10,320
but so coming in from the uh the

1015
00:34:10,320 --> 00:34:13,119
the bypass route um

1016
00:34:13,119 --> 00:34:14,719
that didn't happen so we had full kind

1017
00:34:14,719 --> 00:34:15,760
of

1018
00:34:15,760 --> 00:34:17,839
control over the input buffer and they

1019
00:34:17,839 --> 00:34:20,399
never copied the the second buffer in so

1020
00:34:20,399 --> 00:34:21,918
this one got a little bit complicated

1021
00:34:21,918 --> 00:34:23,440
because it ended up reading out of the

1022
00:34:23,440 --> 00:34:26,960
input data in multiple places

1023
00:34:26,960 --> 00:34:28,239
in the uh

1024
00:34:28,239 --> 00:34:29,679
in the call stack

1025
00:34:29,679 --> 00:34:31,918
so it was a bit spread out so i

1026
00:34:31,918 --> 00:34:33,359
tried as best i could to get into one

1027
00:34:33,359 --> 00:34:34,560
slide

1028
00:34:34,560 --> 00:34:36,320
but the buffer length going into this

1029
00:34:36,320 --> 00:34:38,320
update flow function here so that was

1030
00:34:38,320 --> 00:34:40,960
read out from the user controlled packet

1031
00:34:40,960 --> 00:34:41,839
in fact

1032
00:34:41,839 --> 00:34:43,440
from user mode memory

1033
00:34:43,440 --> 00:34:45,599
earlier in the call stack and then in

1034
00:34:45,599 --> 00:34:47,679
this update flow function

1035
00:34:47,679 --> 00:34:48,960
it allocates enough memory for it

1036
00:34:48,960 --> 00:34:50,239
because it's going to make again another

1037
00:34:50,239 --> 00:34:51,520
copy

1038
00:34:51,520 --> 00:34:53,520
but then if you look at the the mem copy

1039
00:34:53,520 --> 00:34:54,800
down here again

1040
00:34:54,800 --> 00:34:56,320
the last line

1041
00:34:56,320 --> 00:34:57,760
it reads the length field out of the

1042
00:34:57,760 --> 00:34:59,920
user mode buffer again

1043
00:34:59,920 --> 00:35:01,440
so it's the same race condition as the

1044
00:35:01,440 --> 00:35:03,520
alpc bug if we swap the lengths between

1045
00:35:03,520 --> 00:35:05,359
these two um

1046
00:35:05,359 --> 00:35:07,359
between the two times then we get a

1047
00:35:07,359 --> 00:35:09,599
buffer overflow so this one is just a

1048
00:35:09,599 --> 00:35:13,040
regular non-page pool overflow

1049
00:35:13,040 --> 00:35:15,280
so just a quick uh summary so at this

1050
00:35:15,280 --> 00:35:17,520
point um we'd have this validation

1051
00:35:17,520 --> 00:35:19,599
bypass an info leak

1052
00:35:19,599 --> 00:35:22,000
two arbitrary increments in the kernel

1053
00:35:22,000 --> 00:35:25,359
and a non-page pool overflow

1054
00:35:26,320 --> 00:35:28,720
and so i was

1055
00:35:28,720 --> 00:35:30,240
very confident that at least some of

1056
00:35:30,240 --> 00:35:32,000
these could be exploited into a kind of

1057
00:35:32,000 --> 00:35:34,480
reliable code execution um

1058
00:35:34,480 --> 00:35:36,480
but i also was starting to get a

1059
00:35:36,480 --> 00:35:38,640
bit suspicious about just in general the

1060
00:35:38,640 --> 00:35:40,800
quality of this code and so i thought

1061
00:35:40,800 --> 00:35:42,960
well why don't i keep spend a little bit

1062
00:35:42,960 --> 00:35:44,640
more time auditing

1063
00:35:44,640 --> 00:35:47,680
the other option handlers so

1064
00:35:47,680 --> 00:35:49,280
in this case i said started looking

1065
00:35:49,280 --> 00:35:50,640
through ones that didn't require the

1066
00:35:50,640 --> 00:35:52,079
ioctal

1067
00:35:52,079 --> 00:35:53,920
validation bypass

1068
00:35:53,920 --> 00:35:56,480
uh it turned out there were some more

1069
00:35:56,480 --> 00:36:00,079
more bugs so the first one uh

1070
00:36:00,079 --> 00:36:01,440
there's this

1071
00:36:01,440 --> 00:36:03,440
set multicast filter option

1072
00:36:03,440 --> 00:36:05,680
so this is for setting if you're using a

1073
00:36:05,680 --> 00:36:07,359
multicast address and you want to filter

1074
00:36:07,359 --> 00:36:09,280
either in or out some addresses

1075
00:36:09,280 --> 00:36:12,160
you can set filters on the socket

1076
00:36:12,160 --> 00:36:14,480
and it takes in a list of addresses so

1077
00:36:14,480 --> 00:36:17,359
in this case this particular one is ipv4

1078
00:36:17,359 --> 00:36:18,960
only so you have a bunch of four byte

1079
00:36:18,960 --> 00:36:20,560
addresses

1080
00:36:20,560 --> 00:36:22,079
in a list

1081
00:36:22,079 --> 00:36:23,920
of arbitrary size well there's a limit

1082
00:36:23,920 --> 00:36:26,480
on the size

1083
00:36:26,560 --> 00:36:28,320
and this gets processed down in this

1084
00:36:28,320 --> 00:36:29,520
function in

1085
00:36:29,520 --> 00:36:32,520
gcp.sys

1086
00:36:32,800 --> 00:36:35,440
so here's the the code for this

1087
00:36:35,440 --> 00:36:37,520
this was actually in this set session

1088
00:36:37,520 --> 00:36:39,359
info function was handled a lot of the

1089
00:36:39,359 --> 00:36:41,920
options i was kind of a

1090
00:36:41,920 --> 00:36:44,000
big one to reverse but once you get the

1091
00:36:44,000 --> 00:36:46,400
case statements broken out it became

1092
00:36:46,400 --> 00:36:48,960
not too bad

1093
00:36:49,359 --> 00:36:51,040
and you can see there's checks on the

1094
00:36:51,040 --> 00:36:53,200
length there are some validation checks

1095
00:36:53,200 --> 00:36:55,839
um and then similar pattern to what i've

1096
00:36:55,839 --> 00:36:57,920
talked about already um

1097
00:36:57,920 --> 00:36:59,839
excuse me

1098
00:36:59,839 --> 00:37:01,280
they then read the length again out of

1099
00:37:01,280 --> 00:37:02,480
the packet

1100
00:37:02,480 --> 00:37:03,359
so

1101
00:37:03,359 --> 00:37:05,200
same thing if you alternate this value

1102
00:37:05,200 --> 00:37:08,240
between a high high and low value uh if

1103
00:37:08,240 --> 00:37:09,359
you happen to

1104
00:37:09,359 --> 00:37:10,880
get through the checks with a low value

1105
00:37:10,880 --> 00:37:12,800
but hit the the next function with a

1106
00:37:12,800 --> 00:37:15,200
high value um

1107
00:37:15,200 --> 00:37:17,119
then it triggers a denial of service in

1108
00:37:17,119 --> 00:37:18,400
this case it's just an out of bounds

1109
00:37:18,400 --> 00:37:20,320
read um it passes in the array and the

1110
00:37:20,320 --> 00:37:22,480
size uh

1111
00:37:22,480 --> 00:37:24,000
and it just it's just making a copy of

1112
00:37:24,000 --> 00:37:27,119
the array and it'll read past the end

1113
00:37:27,119 --> 00:37:27,839
so

1114
00:37:27,839 --> 00:37:29,359
one interesting thing is i just closed

1115
00:37:29,359 --> 00:37:31,839
this one to microsoft

1116
00:37:31,839 --> 00:37:33,520
and their response was they don't

1117
00:37:33,520 --> 00:37:36,640
consider local denial of services to be

1118
00:37:36,640 --> 00:37:39,359
meet their bar for service

1119
00:37:39,359 --> 00:37:40,880
so they did end up patching this bug but

1120
00:37:40,880 --> 00:37:42,800
i think it's the the way they patched it

1121
00:37:42,800 --> 00:37:45,119
was uh

1122
00:37:45,119 --> 00:37:47,520
the um the memory buffers they were

1123
00:37:47,520 --> 00:37:49,040
passing down here were still pointing to

1124
00:37:49,040 --> 00:37:51,920
user controlled uh

1125
00:37:51,920 --> 00:37:54,800
memory so they just made a copy of the

1126
00:37:54,800 --> 00:37:56,720
any of the user options coming in so

1127
00:37:56,720 --> 00:37:58,079
what gets passed down is something that

1128
00:37:58,079 --> 00:38:00,160
user mode can no longer

1129
00:38:00,160 --> 00:38:02,800
no longer swap um but kind of because of

1130
00:38:02,800 --> 00:38:04,880
that during the the rest of the research

1131
00:38:04,880 --> 00:38:06,720
i ended up finding a couple more denial

1132
00:38:06,720 --> 00:38:08,560
of services but i didn't bother to write

1133
00:38:08,560 --> 00:38:10,720
them up um so they're still floating

1134
00:38:10,720 --> 00:38:13,359
around out there

1135
00:38:13,920 --> 00:38:15,599
so i could play games on

1136
00:38:15,599 --> 00:38:18,400
my co-workers boxes um

1137
00:38:18,400 --> 00:38:20,079
yeah this uh

1138
00:38:20,079 --> 00:38:21,440
so

1139
00:38:21,440 --> 00:38:23,200
yeah denial of service not super

1140
00:38:23,200 --> 00:38:25,920
interesting um but fortunately like

1141
00:38:25,920 --> 00:38:27,680
literally right underneath it in my

1142
00:38:27,680 --> 00:38:29,280
decompiler output was this case

1143
00:38:29,280 --> 00:38:31,920
statement um and so the previous one was

1144
00:38:31,920 --> 00:38:34,480
setting a multicast filter with ipv4

1145
00:38:34,480 --> 00:38:37,280
only addresses uh but when they came

1146
00:38:37,280 --> 00:38:39,440
around with windows vista they included

1147
00:38:39,440 --> 00:38:42,720
support for ipv6

1148
00:38:43,119 --> 00:38:44,800
i think that's mostly when it came in uh

1149
00:38:44,800 --> 00:38:47,040
and so they added in this ioctal to set

1150
00:38:47,040 --> 00:38:49,760
a same multicast filter but with ipv4 or

1151
00:38:49,760 --> 00:38:53,119
ipv6 addresses and it has the exact same

1152
00:38:53,119 --> 00:38:56,000
bug fortunately

1153
00:38:56,000 --> 00:38:57,440
and in this case you can see it's

1154
00:38:57,440 --> 00:38:58,720
actually allocating memory to make a

1155
00:38:58,720 --> 00:39:00,560
copy of the pool so there's a an

1156
00:39:00,560 --> 00:39:02,960
allocate using the length readout at the

1157
00:39:02,960 --> 00:39:05,040
beginning um and then it runs through a

1158
00:39:05,040 --> 00:39:06,560
for loop and copies all the addresses

1159
00:39:06,560 --> 00:39:08,320
into that memory so

1160
00:39:08,320 --> 00:39:09,359
the

1161
00:39:09,359 --> 00:39:10,960
exact same problem

1162
00:39:10,960 --> 00:39:13,760
set it low for the the validation checks

1163
00:39:13,760 --> 00:39:15,599
and then flip it high when you get into

1164
00:39:15,599 --> 00:39:17,680
the copy loop and you cause a buffer um

1165
00:39:17,680 --> 00:39:20,640
overflow so the only um

1166
00:39:20,640 --> 00:39:22,640
tricky part with this one is that the

1167
00:39:22,640 --> 00:39:24,400
memory is read out again every time

1168
00:39:24,400 --> 00:39:26,240
through this for loop so if you're just

1169
00:39:26,240 --> 00:39:28,400
flipping the the length value back

1170
00:39:28,400 --> 00:39:30,320
between high and low you might get to a

1171
00:39:30,320 --> 00:39:32,400
case where you get through the

1172
00:39:32,400 --> 00:39:34,880
size validation on the um

1173
00:39:34,880 --> 00:39:36,400
on the input but then you break out of

1174
00:39:36,400 --> 00:39:38,240
the copy loop before you've completed

1175
00:39:38,240 --> 00:39:40,079
overflowing everything you want to which

1176
00:39:40,079 --> 00:39:42,720
could cause kind of yeah instability if

1177
00:39:42,720 --> 00:39:44,960
you only do partial partial corruption

1178
00:39:44,960 --> 00:39:46,720
so the the solution to that was just

1179
00:39:46,720 --> 00:39:47,680
instead of

1180
00:39:47,680 --> 00:39:50,400
flipping back and forth was to uh you

1181
00:39:50,400 --> 00:39:51,520
know in the loop counter that was

1182
00:39:51,520 --> 00:39:53,440
writing this value was to write it low

1183
00:39:53,440 --> 00:39:56,480
once and then write the high value for

1184
00:39:56,480 --> 00:39:58,640
you know 100 times or something uh and

1185
00:39:58,640 --> 00:40:00,560
then just repeat that so it was

1186
00:40:00,560 --> 00:40:02,160
low for only a short window because it

1187
00:40:02,160 --> 00:40:03,520
only has to get through it's only read

1188
00:40:03,520 --> 00:40:05,440
once to get through the validation

1189
00:40:05,440 --> 00:40:07,119
and then set it high for a lot longer so

1190
00:40:07,119 --> 00:40:08,400
you're likely to get through the the

1191
00:40:08,400 --> 00:40:10,240
copy loop and it just tweaked the value

1192
00:40:10,240 --> 00:40:11,599
so that there was a good balance between

1193
00:40:11,599 --> 00:40:13,440
it not taking too long to win the race

1194
00:40:13,440 --> 00:40:14,560
um and

1195
00:40:14,560 --> 00:40:16,800
not exiting that copy

1196
00:40:16,800 --> 00:40:18,800
too soon

1197
00:40:18,800 --> 00:40:19,839
um

1198
00:40:19,839 --> 00:40:21,440
so just to add on then to the summary so

1199
00:40:21,440 --> 00:40:22,880
now we have the original ones i

1200
00:40:22,880 --> 00:40:25,680
mentioned plus denial of service

1201
00:40:25,680 --> 00:40:28,800
and one more uh non-page pool overflow

1202
00:40:28,800 --> 00:40:30,720
so we can move on to

1203
00:40:30,720 --> 00:40:33,359
talking about how to exploit them

1204
00:40:33,359 --> 00:40:36,400
um this this one's funny because they're

1205
00:40:36,400 --> 00:40:39,839
pools that are overflowing

1206
00:40:41,280 --> 00:40:42,400
um

1207
00:40:42,400 --> 00:40:43,760
right so

1208
00:40:43,760 --> 00:40:46,240
uh i hadn't actually looked at windows

1209
00:40:46,240 --> 00:40:47,760
exploitation for quite a while before

1210
00:40:47,760 --> 00:40:50,079
doing this uh research so

1211
00:40:50,079 --> 00:40:51,200
i looked around for kind of what

1212
00:40:51,200 --> 00:40:52,880
research is out there to get up to speed

1213
00:40:52,880 --> 00:40:56,160
with kind of what the latest tricks are

1214
00:40:57,280 --> 00:40:58,960
and there is some really good

1215
00:40:58,960 --> 00:41:00,480
research and papers out there one in

1216
00:41:00,480 --> 00:41:01,839
particular that i

1217
00:41:01,839 --> 00:41:03,520
used a lot was the um scooping the

1218
00:41:03,520 --> 00:41:05,359
windows pool paper

1219
00:41:05,359 --> 00:41:07,920
i have a reference at the end

1220
00:41:07,920 --> 00:41:09,920
and so

1221
00:41:09,920 --> 00:41:11,440
yeah looking for

1222
00:41:11,440 --> 00:41:13,200
how to turn these uh page spool and

1223
00:41:13,200 --> 00:41:15,119
non-page pool overflows into kind of

1224
00:41:15,119 --> 00:41:16,560
working exploits

1225
00:41:16,560 --> 00:41:19,520
name pipes turn out to be super useful

1226
00:41:19,520 --> 00:41:21,359
for this there's two features to name

1227
00:41:21,359 --> 00:41:23,920
pipes that make exploitation uh and

1228
00:41:23,920 --> 00:41:26,160
grooming a lot easier

1229
00:41:26,160 --> 00:41:28,319
so there's name piped attributes uh and

1230
00:41:28,319 --> 00:41:31,599
then data entries in the uh

1231
00:41:31,599 --> 00:41:34,240
name pipe to write cues um so you can

1232
00:41:34,240 --> 00:41:36,160
see the

1233
00:41:36,160 --> 00:41:38,160
ins so the reason why these uh

1234
00:41:38,160 --> 00:41:40,800
these are both good things is that um

1235
00:41:40,800 --> 00:41:42,560
they have variable length allocation so

1236
00:41:42,560 --> 00:41:44,079
there you can see the uh

1237
00:41:44,079 --> 00:41:46,000
headers on the of the structures on the

1238
00:41:46,000 --> 00:41:47,680
side here so they both have a kind of a

1239
00:41:47,680 --> 00:41:49,200
small header and then they're followed

1240
00:41:49,200 --> 00:41:52,000
by inline data immediately afterwards

1241
00:41:52,000 --> 00:41:53,359
and there's really not much limit on

1242
00:41:53,359 --> 00:41:55,280
this length you can put in so we have a

1243
00:41:55,280 --> 00:41:57,440
big you know variable size allocations

1244
00:41:57,440 --> 00:41:58,720
we can choose which size we're going to

1245
00:41:58,720 --> 00:41:59,760
allocate

1246
00:41:59,760 --> 00:42:01,920
besides the headers we have full control

1247
00:42:01,920 --> 00:42:03,359
over the data

1248
00:42:03,359 --> 00:42:05,280
and in both cases we can free them kind

1249
00:42:05,280 --> 00:42:06,240
of

1250
00:42:06,240 --> 00:42:08,800
on demand when we want to

1251
00:42:08,800 --> 00:42:10,160
the other useful thing about both of

1252
00:42:10,160 --> 00:42:13,118
these is once you set

1253
00:42:13,920 --> 00:42:16,079
set one of them on the pipe you can read

1254
00:42:16,079 --> 00:42:17,680
it back out without triggering or

1255
00:42:17,680 --> 00:42:20,079
triggering a free so attributes are easy

1256
00:42:20,079 --> 00:42:21,599
you just set an attribute on the pipe

1257
00:42:21,599 --> 00:42:22,560
and then you can go read what the

1258
00:42:22,560 --> 00:42:24,240
attribute is you don't cause it to be

1259
00:42:24,240 --> 00:42:25,760
freed

1260
00:42:25,760 --> 00:42:27,760
and data queue entries what they

1261
00:42:27,760 --> 00:42:29,280
actually are is when you write data to a

1262
00:42:29,280 --> 00:42:30,720
pipe

1263
00:42:30,720 --> 00:42:32,800
they get kind of an entry gets created

1264
00:42:32,800 --> 00:42:34,640
to cue it until someone reads it off so

1265
00:42:34,640 --> 00:42:36,240
if you go to read it it gets removed and

1266
00:42:36,240 --> 00:42:37,440
freed

1267
00:42:37,440 --> 00:42:39,440
but pipes also give you the option to

1268
00:42:39,440 --> 00:42:41,040
peek into what's on the queue so you can

1269
00:42:41,040 --> 00:42:43,119
just say i want to peek into the data on

1270
00:42:43,119 --> 00:42:44,800
the queue it'll let you read these data

1271
00:42:44,800 --> 00:42:46,720
queue entries and not actually

1272
00:42:46,720 --> 00:42:48,480
pop them off

1273
00:42:48,480 --> 00:42:49,280
um

1274
00:42:49,280 --> 00:42:50,480
and so the other thing when we're

1275
00:42:50,480 --> 00:42:52,240
looking at kind of exploiting any kind

1276
00:42:52,240 --> 00:42:53,520
of

1277
00:42:53,520 --> 00:42:56,240
memory corruption or on the heap

1278
00:42:56,240 --> 00:42:57,599
is you need to know kind of details

1279
00:42:57,599 --> 00:42:59,280
about what the heap is that you're going

1280
00:42:59,280 --> 00:43:01,760
to be exploiting um so the only thing i

1281
00:43:01,760 --> 00:43:03,839
looked at was kind of newer windows and

1282
00:43:03,839 --> 00:43:05,920
they all use the the segment heap

1283
00:43:05,920 --> 00:43:06,880
um

1284
00:43:06,880 --> 00:43:08,640
which again has got some good write-ups

1285
00:43:08,640 --> 00:43:11,200
there's a good one from

1286
00:43:11,200 --> 00:43:13,359
target quite a few years back on a kind

1287
00:43:13,359 --> 00:43:15,520
of modern pool kernel pool exploitation

1288
00:43:15,520 --> 00:43:17,440
that talks a lot about the uh

1289
00:43:17,440 --> 00:43:20,000
the different types of heaps um

1290
00:43:20,000 --> 00:43:22,000
and specifically i was looking at the

1291
00:43:22,000 --> 00:43:24,079
variable size back end for the the

1292
00:43:24,079 --> 00:43:25,599
segment heap which lets you mix

1293
00:43:25,599 --> 00:43:26,800
allocations of a bunch of different

1294
00:43:26,800 --> 00:43:28,160
sizes

1295
00:43:28,160 --> 00:43:29,680
and it turns out that it turned out to

1296
00:43:29,680 --> 00:43:31,359
be really

1297
00:43:31,359 --> 00:43:33,599
relatively easy to protect the predict

1298
00:43:33,599 --> 00:43:36,079
and control the heap layout using that

1299
00:43:36,079 --> 00:43:38,160
so i'll talk a little bit about kind of

1300
00:43:38,160 --> 00:43:40,079
what the grooming strategy was going to

1301
00:43:40,079 --> 00:43:42,000
be and how to turn this

1302
00:43:42,000 --> 00:43:44,000
into an exploit

1303
00:43:44,000 --> 00:43:47,680
um so the variable size back end

1304
00:43:47,680 --> 00:43:50,640
i'm kind of running along eh um

1305
00:43:50,640 --> 00:43:52,480
so this is used for allocations that are

1306
00:43:52,480 --> 00:43:54,960
bigger than 512 bytes

1307
00:43:54,960 --> 00:43:56,880
and not page line

1308
00:43:56,880 --> 00:43:59,119
um and it's made up of a whole bunch of

1309
00:43:59,119 --> 00:44:01,599
sub segments which kind of get created

1310
00:44:01,599 --> 00:44:03,200
when new allocations come in and these

1311
00:44:03,200 --> 00:44:04,480
sub segments will hold a bunch of

1312
00:44:04,480 --> 00:44:06,560
individual allocations and as bigger

1313
00:44:06,560 --> 00:44:08,800
allocations come out of them uh you got

1314
00:44:08,800 --> 00:44:10,880
to get these free chunks created

1315
00:44:10,880 --> 00:44:12,880
uh and there's a bunch of details with

1316
00:44:12,880 --> 00:44:14,319
why there's you know they try and keep

1317
00:44:14,319 --> 00:44:17,280
the big chunks page lined uh

1318
00:44:17,280 --> 00:44:18,560
and

1319
00:44:18,560 --> 00:44:19,680
and that's why you end up with these

1320
00:44:19,680 --> 00:44:22,800
multiple sections of small free chunks

1321
00:44:22,800 --> 00:44:24,720
um

1322
00:44:24,720 --> 00:44:27,119
so for the grooming um

1323
00:44:27,119 --> 00:44:27,920
which

1324
00:44:27,920 --> 00:44:29,760
if we just uh and i know i'm showing a

1325
00:44:29,760 --> 00:44:30,960
picture of just one but really what

1326
00:44:30,960 --> 00:44:32,160
we're aiming to do is create a whole

1327
00:44:32,160 --> 00:44:33,599
bunch of identical

1328
00:44:33,599 --> 00:44:36,319
sub segments in memory

1329
00:44:36,319 --> 00:44:38,400
so we start off here by doing one big

1330
00:44:38,400 --> 00:44:40,240
allocation uh

1331
00:44:40,240 --> 00:44:42,319
in this example we're talking about the

1332
00:44:42,319 --> 00:44:44,400
the right data cues so we have a data

1333
00:44:44,400 --> 00:44:46,000
queue header on this we do one big

1334
00:44:46,000 --> 00:44:48,800
almost 64k allocation

1335
00:44:48,800 --> 00:44:50,640
which creates if we do enough of them

1336
00:44:50,640 --> 00:44:52,720
we'll create new sub segments um and so

1337
00:44:52,720 --> 00:44:54,079
now we have

1338
00:44:54,079 --> 00:44:56,480
a couple of free chunks um and what we

1339
00:44:56,480 --> 00:44:58,079
want to be able to do is reliably get

1340
00:44:58,079 --> 00:45:00,000
our overflow chunk uh in front of that

1341
00:45:00,000 --> 00:45:01,920
one so we need to make sure any holes at

1342
00:45:01,920 --> 00:45:04,160
the end have been filled up

1343
00:45:04,160 --> 00:45:05,920
so now we have this slightly smaller

1344
00:45:05,920 --> 00:45:07,760
chunk at the end so we need to do

1345
00:45:07,760 --> 00:45:10,000
another big allocation or a round of big

1346
00:45:10,000 --> 00:45:12,079
allocations to use up that free chunk

1347
00:45:12,079 --> 00:45:13,760
and so now we have kind of two big

1348
00:45:13,760 --> 00:45:16,079
allocations um

1349
00:45:16,079 --> 00:45:17,599
and then a couple of free chunks at the

1350
00:45:17,599 --> 00:45:18,480
end

1351
00:45:18,480 --> 00:45:20,960
all right good came back um and this one

1352
00:45:20,960 --> 00:45:22,560
uh slightly larger free chunk at the

1353
00:45:22,560 --> 00:45:24,160
beginning so now if we filled in

1354
00:45:24,160 --> 00:45:25,520
everything correctly we should be able

1355
00:45:25,520 --> 00:45:26,400
to

1356
00:45:26,400 --> 00:45:28,000
if we cause our overflow allocation to

1357
00:45:28,000 --> 00:45:30,480
be around that fc0 byte size we should

1358
00:45:30,480 --> 00:45:32,240
be able to land it every time right in

1359
00:45:32,240 --> 00:45:32,960
front

1360
00:45:32,960 --> 00:45:34,000
um

1361
00:45:34,000 --> 00:45:36,319
and it turns out that's uh

1362
00:45:36,319 --> 00:45:37,760
entirely possible we just need a little

1363
00:45:37,760 --> 00:45:40,000
bit smaller size to make room for the

1364
00:45:40,000 --> 00:45:42,240
the chunk headers so at this point we

1365
00:45:42,240 --> 00:45:44,880
can reliably overflow

1366
00:45:44,880 --> 00:45:47,839
our data cue header

1367
00:45:48,079 --> 00:45:50,400
um so skipping along just briefly look

1368
00:45:50,400 --> 00:45:51,920
at kind of some of the name pipe

1369
00:45:51,920 --> 00:45:53,920
internals and so how we turn that into

1370
00:45:53,920 --> 00:45:54,800
uh

1371
00:45:54,800 --> 00:45:56,480
you know

1372
00:45:56,480 --> 00:45:57,839
interesting primitives that we can use

1373
00:45:57,839 --> 00:46:00,880
to exploit the box so the name piped

1374
00:46:00,880 --> 00:46:02,000
when you create a name pipe you

1375
00:46:02,000 --> 00:46:03,599
initially you get a name piped file

1376
00:46:03,599 --> 00:46:04,720
object

1377
00:46:04,720 --> 00:46:07,599
and that also the excret the other thing

1378
00:46:07,599 --> 00:46:08,960
that gets created at the same time is

1379
00:46:08,960 --> 00:46:10,400
the ccb

1380
00:46:10,400 --> 00:46:12,400
object

1381
00:46:12,400 --> 00:46:14,319
ccb was referenced a bunch i think it

1382
00:46:14,319 --> 00:46:16,160
stands for control context block that

1383
00:46:16,160 --> 00:46:18,319
was my best guess um

1384
00:46:18,319 --> 00:46:20,160
and internally that contains a bunch of

1385
00:46:20,160 --> 00:46:22,400
pointers to

1386
00:46:22,400 --> 00:46:24,160
lists of attributes and kind of lists of

1387
00:46:24,160 --> 00:46:25,680
anything on the pending right queue or

1388
00:46:25,680 --> 00:46:29,240
pending read queue

1389
00:46:30,480 --> 00:46:32,319
so to get an arbitrary kernel read out

1390
00:46:32,319 --> 00:46:34,319
of this

1391
00:46:34,319 --> 00:46:36,880
this technique will work for either the

1392
00:46:36,880 --> 00:46:38,880
the attributes or the write queue entry

1393
00:46:38,880 --> 00:46:40,400
case

1394
00:46:40,400 --> 00:46:42,000
they both have kind of the same format

1395
00:46:42,000 --> 00:46:43,440
of a list entry at the beginning and

1396
00:46:43,440 --> 00:46:45,520
then a length field so even with just a

1397
00:46:45,520 --> 00:46:47,359
single byte

1398
00:46:47,359 --> 00:46:49,200
of corruption we can just

1399
00:46:49,200 --> 00:46:51,119
corrupt the bottom byte of the flink

1400
00:46:51,119 --> 00:46:53,359
header

1401
00:46:53,359 --> 00:46:54,839
so that instead of

1402
00:46:54,839 --> 00:46:57,280
the flink pointing to the start of the

1403
00:46:57,280 --> 00:46:58,800
next data queue entry we can get it to

1404
00:46:58,800 --> 00:47:00,400
point down into the controlled data

1405
00:47:00,400 --> 00:47:01,680
section

1406
00:47:01,680 --> 00:47:04,079
so if we corrupt it just right then the

1407
00:47:04,079 --> 00:47:05,599
flink actually points into the portion

1408
00:47:05,599 --> 00:47:07,280
of the data that we control and we can

1409
00:47:07,280 --> 00:47:09,200
have arbitrary values

1410
00:47:09,200 --> 00:47:11,119
for the next header in the chain so that

1411
00:47:11,119 --> 00:47:13,920
applies to either

1412
00:47:14,160 --> 00:47:16,400
the data key or attributes

1413
00:47:16,400 --> 00:47:18,720
so the issue with the two overflows i

1414
00:47:18,720 --> 00:47:20,480
had in this case is they you couldn't

1415
00:47:20,480 --> 00:47:21,920
overwrite just a single byte you had to

1416
00:47:21,920 --> 00:47:23,760
overwrite more than that so at least

1417
00:47:23,760 --> 00:47:25,440
four bytes at which point you've kind of

1418
00:47:25,440 --> 00:47:27,680
clobbered the pointer

1419
00:47:27,680 --> 00:47:31,200
and that doesn't work however

1420
00:47:31,200 --> 00:47:34,079
you can just overwrite the entire thing

1421
00:47:34,079 --> 00:47:36,079
and because of the way windows does kind

1422
00:47:36,079 --> 00:47:38,720
of the i o you can just point the flink

1423
00:47:38,720 --> 00:47:41,680
pointer right into user mode

1424
00:47:41,680 --> 00:47:44,240
and uh create a fake structure there

1425
00:47:44,240 --> 00:47:46,640
it also we can modify the length of the

1426
00:47:46,640 --> 00:47:48,559
one we've corrupted in kernel mode so

1427
00:47:48,559 --> 00:47:50,640
that if we peek into the pipe we can

1428
00:47:50,640 --> 00:47:52,720
read past the end of that uh i have too

1429
00:47:52,720 --> 00:47:54,079
many zeros in the diagram but you can

1430
00:47:54,079 --> 00:47:56,079
read past the end of the

1431
00:47:56,079 --> 00:47:57,359
of the data queue entry and get the

1432
00:47:57,359 --> 00:47:59,359
headers off the next thing in the heap

1433
00:47:59,359 --> 00:48:01,119
so which gives us kind of an aslr bot

1434
00:48:01,119 --> 00:48:02,960
aslr bypass because it lets us know

1435
00:48:02,960 --> 00:48:05,599
where the chunk is in memory

1436
00:48:05,599 --> 00:48:07,760
and then the once we have the fully

1437
00:48:07,760 --> 00:48:09,520
controlled one in user mode we can just

1438
00:48:09,520 --> 00:48:12,079
change the values uh to get a arbitrary

1439
00:48:12,079 --> 00:48:14,559
read of arbitrary length and just change

1440
00:48:14,559 --> 00:48:17,040
it as we need to

1441
00:48:17,040 --> 00:48:18,160
yeah

1442
00:48:18,160 --> 00:48:20,480
to do as much reading as we want so the

1443
00:48:20,480 --> 00:48:22,000
next uh

1444
00:48:22,000 --> 00:48:23,839
thing i wanted to cover was how to get

1445
00:48:23,839 --> 00:48:26,079
an arbitrary write so all the other

1446
00:48:26,079 --> 00:48:29,359
stuff i'd seen documented about how to

1447
00:48:29,359 --> 00:48:31,440
use name pipes for kind of exploitation

1448
00:48:31,440 --> 00:48:34,720
primitives all follow the same path

1449
00:48:34,720 --> 00:48:36,319
up to here and at this point they

1450
00:48:36,319 --> 00:48:38,400
usually

1451
00:48:38,400 --> 00:48:40,559
tried to leverage some

1452
00:48:40,559 --> 00:48:41,760
corrupt some pool headers to get an

1453
00:48:41,760 --> 00:48:43,359
arbitrary increment and then leverage

1454
00:48:43,359 --> 00:48:44,960
that into elevating your token

1455
00:48:44,960 --> 00:48:46,720
privileges

1456
00:48:46,720 --> 00:48:48,400
so i was thinking was there some other

1457
00:48:48,400 --> 00:48:51,280
way to do do this so we can get um

1458
00:48:51,280 --> 00:48:54,160
an arbitrary right

1459
00:48:56,640 --> 00:48:58,640
so i did find one other primitive

1460
00:48:58,640 --> 00:49:00,960
in here with this security context field

1461
00:49:00,960 --> 00:49:02,800
in the data queue entry

1462
00:49:02,800 --> 00:49:05,280
um it turns out that's uh

1463
00:49:05,280 --> 00:49:06,880
yeah it's a pointer to the security

1464
00:49:06,880 --> 00:49:08,559
context for the socket

1465
00:49:08,559 --> 00:49:10,800
uh or sorry for the pipe forget what i'm

1466
00:49:10,800 --> 00:49:12,640
talking about um

1467
00:49:12,640 --> 00:49:14,160
and if it gets changed when the pipe's

1468
00:49:14,160 --> 00:49:16,400
being read

1469
00:49:16,400 --> 00:49:18,880
the code will go and free the existing

1470
00:49:18,880 --> 00:49:20,559
value and replace it with this new one

1471
00:49:20,559 --> 00:49:22,800
so by setting it twice we set it to some

1472
00:49:22,800 --> 00:49:25,440
pointer it gets copied into the the ccb

1473
00:49:25,440 --> 00:49:26,880
and then we set it to null in the next

1474
00:49:26,880 --> 00:49:28,880
iteration it'll go and free the original

1475
00:49:28,880 --> 00:49:30,319
value that we stuck in there so we can

1476
00:49:30,319 --> 00:49:31,680
free

1477
00:49:31,680 --> 00:49:33,280
arbitrary memory with this kind of

1478
00:49:33,280 --> 00:49:35,680
primitive

1479
00:49:37,200 --> 00:49:38,720
and so for an arbitrary write we're

1480
00:49:38,720 --> 00:49:41,200
using the right queue

1481
00:49:41,200 --> 00:49:43,599
to get the reads in kernel

1482
00:49:43,599 --> 00:49:46,160
and so a typical pattern used on other

1483
00:49:46,160 --> 00:49:48,079
operating systems as well for exploiting

1484
00:49:48,079 --> 00:49:50,800
um in fact pipes are used uh

1485
00:49:50,800 --> 00:49:53,359
i've seen them used on android as well

1486
00:49:53,359 --> 00:49:55,680
if you

1487
00:49:55,760 --> 00:49:57,119
if you were able to control the read

1488
00:49:57,119 --> 00:49:57,920
queue

1489
00:49:57,920 --> 00:49:59,119
that gives you the equivalent of an

1490
00:49:59,119 --> 00:50:01,119
arbitrary write because a read cube

1491
00:50:01,119 --> 00:50:02,800
here's a pending read for the socket

1492
00:50:02,800 --> 00:50:03,920
here's the length i want to read and

1493
00:50:03,920 --> 00:50:05,839
here's the address to read it to and if

1494
00:50:05,839 --> 00:50:06,720
we can

1495
00:50:06,720 --> 00:50:08,240
control what that address is then we can

1496
00:50:08,240 --> 00:50:10,160
get essentially a right to any address

1497
00:50:10,160 --> 00:50:11,920
and kernel

1498
00:50:11,920 --> 00:50:15,040
so with the arbitrary free

1499
00:50:15,040 --> 00:50:16,720
we're actually able to so we could have

1500
00:50:16,720 --> 00:50:18,079
tried to corrupt one of those entries

1501
00:50:18,079 --> 00:50:19,920
but they're small and a fixed size which

1502
00:50:19,920 --> 00:50:22,319
makes it problematic so

1503
00:50:22,319 --> 00:50:23,440
instead we

1504
00:50:23,440 --> 00:50:25,520
free the file

1505
00:50:25,520 --> 00:50:27,599
pipe file object and with the read we

1506
00:50:27,599 --> 00:50:29,040
can go and read all these objects so we

1507
00:50:29,040 --> 00:50:31,359
know what the contents are so

1508
00:50:31,359 --> 00:50:33,680
we free the pipe object and replace it

1509
00:50:33,680 --> 00:50:36,319
with one that's almost identical except

1510
00:50:36,319 --> 00:50:38,160
the pointer to the ccb

1511
00:50:38,160 --> 00:50:40,720
points to a fake copy of the ccb and our

1512
00:50:40,720 --> 00:50:43,359
fit copy of the ccb is all identical

1513
00:50:43,359 --> 00:50:45,520
except for the read queue we stick

1514
00:50:45,520 --> 00:50:48,079
values in it um and we point them

1515
00:50:48,079 --> 00:50:50,559
to values we control so now

1516
00:50:50,559 --> 00:50:52,400
when you write to the pipe you can write

1517
00:50:52,400 --> 00:50:56,319
to kind of any value in kernel memory

1518
00:50:56,800 --> 00:50:59,359
uh yeah so that's that's uh

1519
00:50:59,359 --> 00:51:00,640
that was it for how to exploit these

1520
00:51:00,640 --> 00:51:03,440
bugs um kind of the next things i had to

1521
00:51:03,440 --> 00:51:05,599
do was figure out how to kind of do some

1522
00:51:05,599 --> 00:51:07,760
cleanup and repair clobbered heat

1523
00:51:07,760 --> 00:51:08,800
headers

1524
00:51:08,800 --> 00:51:10,720
with the overflow have to repair all the

1525
00:51:10,720 --> 00:51:12,319
linked lists

1526
00:51:12,319 --> 00:51:13,920
and then actually do something

1527
00:51:13,920 --> 00:51:17,280
interesting with the kernel rewrite

1528
00:51:17,280 --> 00:51:18,720
once you have read write on the kernel

1529
00:51:18,720 --> 00:51:20,319
it's pretty much you know game over you

1530
00:51:20,319 --> 00:51:23,200
can do what you uh and do what you want

1531
00:51:23,200 --> 00:51:24,800
so whether it's elevating or turn off

1532
00:51:24,800 --> 00:51:27,200
security features anything like that

1533
00:51:27,200 --> 00:51:29,680
so i was going to do a demo

1534
00:51:29,680 --> 00:51:32,000
but not only am i short on time but i

1535
00:51:32,000 --> 00:51:32,960
also

1536
00:51:32,960 --> 00:51:35,119
broke my vm over lunch so

1537
00:51:35,119 --> 00:51:37,040
i couldn't actually run it anyway but

1538
00:51:37,040 --> 00:51:38,880
fortunately i took a screenshot of what

1539
00:51:38,880 --> 00:51:40,640
the demo looked like so pretend this was

1540
00:51:40,640 --> 00:51:44,480
running and then a system shell pops

1541
00:51:48,839 --> 00:51:53,839
up a very very stress-free demo um

1542
00:51:53,839 --> 00:51:55,839
so i'm going to skip through a couple

1543
00:51:55,839 --> 00:51:58,160
slides here just super quick um because

1544
00:51:58,160 --> 00:51:59,359
i want to get to the

1545
00:51:59,359 --> 00:52:01,440
the last bug

1546
00:52:01,440 --> 00:52:03,599
so this was just how to exploit a

1547
00:52:03,599 --> 00:52:05,680
arbitrary kernel increment so that we

1548
00:52:05,680 --> 00:52:07,599
have this info leak in kernel but what

1549
00:52:07,599 --> 00:52:09,440
it leaks us is a fixed address in the

1550
00:52:09,440 --> 00:52:10,640
page pool

1551
00:52:10,640 --> 00:52:12,079
and we need to know what to what to

1552
00:52:12,079 --> 00:52:14,079
increment um

1553
00:52:14,079 --> 00:52:15,760
solution to this was just

1554
00:52:15,760 --> 00:52:17,520
allocate a whole bunch of memory and

1555
00:52:17,520 --> 00:52:18,400
then

1556
00:52:18,400 --> 00:52:20,640
increment some value in how

1557
00:52:20,640 --> 00:52:22,400
up where we've grown the pool so we can

1558
00:52:22,400 --> 00:52:23,760
you know kind of guess roughly how big

1559
00:52:23,760 --> 00:52:25,200
the pool is and if we allocate a bunch

1560
00:52:25,200 --> 00:52:27,599
of big buffers um

1561
00:52:27,599 --> 00:52:29,520
with large pipe attributes we can just

1562
00:52:29,520 --> 00:52:32,319
sort of increment somewhere in there

1563
00:52:32,319 --> 00:52:34,160
and there's a good chance we can land in

1564
00:52:34,160 --> 00:52:35,760
one of these newly created buffers so we

1565
00:52:35,760 --> 00:52:37,119
just go and read all the attributes

1566
00:52:37,119 --> 00:52:39,520
until we find out

1567
00:52:39,520 --> 00:52:41,440
where it is

1568
00:52:41,440 --> 00:52:44,720
and then to turn that into an exploit

1569
00:52:44,720 --> 00:52:46,480
this is just like the example i said at

1570
00:52:46,480 --> 00:52:48,400
the beginning where if you can corrupt

1571
00:52:48,400 --> 00:52:49,760
one of these flink headers you can point

1572
00:52:49,760 --> 00:52:51,520
it down into the data section so we use

1573
00:52:51,520 --> 00:52:54,079
the increment to add do a misaligned

1574
00:52:54,079 --> 00:52:56,640
increment we can add 100 bytes

1575
00:52:56,640 --> 00:52:58,800
hex bytes onto the value of the flink it

1576
00:52:58,800 --> 00:53:00,960
points down into the actual attribute

1577
00:53:00,960 --> 00:53:03,440
data that we fully control and we have

1578
00:53:03,440 --> 00:53:05,119
an arbitrary read

1579
00:53:05,119 --> 00:53:07,920
yada yada yada

1580
00:53:08,800 --> 00:53:10,640
and with this we can once we have the

1581
00:53:10,640 --> 00:53:12,240
arbitrary read we can actually leverage

1582
00:53:12,240 --> 00:53:14,000
the arbitrary write in exactly the same

1583
00:53:14,000 --> 00:53:16,800
way because we can go there's no free

1584
00:53:16,800 --> 00:53:18,800
primitive through the attributes but we

1585
00:53:18,800 --> 00:53:20,240
can go back and read out where the data

1586
00:53:20,240 --> 00:53:22,160
queue entries are

1587
00:53:22,160 --> 00:53:23,200
and

1588
00:53:23,200 --> 00:53:24,880
increment one of those and then we're

1589
00:53:24,880 --> 00:53:26,319
back in the

1590
00:53:26,319 --> 00:53:27,680
using this method and we're back in the

1591
00:53:27,680 --> 00:53:30,160
exact same scenario as the um

1592
00:53:30,160 --> 00:53:31,839
previous bugs

1593
00:53:31,839 --> 00:53:34,000
uh

1594
00:53:34,240 --> 00:53:36,400
yes really quick aside uh when i was

1595
00:53:36,400 --> 00:53:38,800
looking at this with um disclosing this

1596
00:53:38,800 --> 00:53:40,720
to microsoft there were some discussions

1597
00:53:40,720 --> 00:53:42,559
back and forth about whether this worked

1598
00:53:42,559 --> 00:53:44,240
from the sandboxes that were within

1599
00:53:44,240 --> 00:53:47,280
their bug bounty program

1600
00:53:47,280 --> 00:53:49,040
that just kind of increased the severity

1601
00:53:49,040 --> 00:53:50,640
so it turns out this particular one

1602
00:53:50,640 --> 00:53:51,920
works from the

1603
00:53:51,920 --> 00:53:54,000
windows defender application guard rbc

1604
00:53:54,000 --> 00:53:56,800
broker sandbox and while i was kind of

1605
00:53:56,800 --> 00:53:59,359
proving that it did i also noticed that

1606
00:53:59,359 --> 00:54:02,160
that sandbox had access to the um http

1607
00:54:02,160 --> 00:54:03,520
server api

1608
00:54:03,520 --> 00:54:04,720
and i was getting a little bit tired of

1609
00:54:04,720 --> 00:54:06,480
doing write-ups so i thought oh i'll

1610
00:54:06,480 --> 00:54:08,720
take a look and see why the

1611
00:54:08,720 --> 00:54:10,880
what's this what this is doing uh there

1612
00:54:10,880 --> 00:54:12,720
and i really don't know why the rpc

1613
00:54:12,720 --> 00:54:14,960
sandbox can access uh

1614
00:54:14,960 --> 00:54:17,200
the server api but it's in there

1615
00:54:17,200 --> 00:54:18,319
so

1616
00:54:18,319 --> 00:54:21,680
uh windows provides uh an http.sys

1617
00:54:21,680 --> 00:54:23,440
driver that's there on all versions to

1618
00:54:23,440 --> 00:54:25,839
do

1619
00:54:26,079 --> 00:54:28,319
to kind of provide a web server service

1620
00:54:28,319 --> 00:54:30,160
so normally you'd have iis and this

1621
00:54:30,160 --> 00:54:32,440
diagram is a picture of how iis uses

1622
00:54:32,440 --> 00:54:35,280
http.sys but it also lets you have

1623
00:54:35,280 --> 00:54:37,200
arbitrary applications that just do

1624
00:54:37,200 --> 00:54:39,520
their own web hosting

1625
00:54:39,520 --> 00:54:42,559
by directly accessing the api

1626
00:54:42,559 --> 00:54:43,520
um

1627
00:54:43,520 --> 00:54:46,799
and this is all well documented on msdn

1628
00:54:46,799 --> 00:54:48,480
sorry i'm skipping through this a bit

1629
00:54:48,480 --> 00:54:51,359
quick but almost

1630
00:54:51,359 --> 00:54:52,799
and uh

1631
00:54:52,799 --> 00:54:54,720
yeah there's kind of three main things

1632
00:54:54,720 --> 00:54:56,720
you uh you would do with the api to get

1633
00:54:56,720 --> 00:54:58,720
set up uh you create a session and a

1634
00:54:58,720 --> 00:55:00,160
session is really just a container for a

1635
00:55:00,160 --> 00:55:01,520
bunch of properties that are common

1636
00:55:01,520 --> 00:55:04,160
across uh your application um and then

1637
00:55:04,160 --> 00:55:06,559
you can register different urls um

1638
00:55:06,559 --> 00:55:08,319
grouping them again by kind of common

1639
00:55:08,319 --> 00:55:09,599
properties

1640
00:55:09,599 --> 00:55:10,960
each of these

1641
00:55:10,960 --> 00:55:12,799
url groups

1642
00:55:12,799 --> 00:55:14,559
gets associated with a request queue

1643
00:55:14,559 --> 00:55:16,000
that gets created so you can have

1644
00:55:16,000 --> 00:55:18,000
multiple applications reading requests

1645
00:55:18,000 --> 00:55:20,160
out of the queues as they come in a good

1646
00:55:20,160 --> 00:55:21,920
way for load balancing and kind of

1647
00:55:21,920 --> 00:55:23,440
performance reasons

1648
00:55:23,440 --> 00:55:24,960
um

1649
00:55:24,960 --> 00:55:28,000
so looking at the user mode api uh for

1650
00:55:28,000 --> 00:55:30,240
this and i mentioned already these were

1651
00:55:30,240 --> 00:55:32,400
some groupings for common properties so

1652
00:55:32,400 --> 00:55:35,359
you have this ability to set um

1653
00:55:35,359 --> 00:55:37,920
properties on your session

1654
00:55:37,920 --> 00:55:39,760
um and one of the interesting properties

1655
00:55:39,760 --> 00:55:41,520
here was this uh it's channel binding

1656
00:55:41,520 --> 00:55:44,319
tokens which is a security extension to

1657
00:55:44,319 --> 00:55:47,319
ssl

1658
00:55:48,319 --> 00:55:49,760
yeah and there's a structure there you

1659
00:55:49,760 --> 00:55:51,680
can see there's an array of of uh

1660
00:55:51,680 --> 00:55:53,040
service names which are the names of the

1661
00:55:53,040 --> 00:55:54,880
binding tokens and then a structure that

1662
00:55:54,880 --> 00:55:57,520
kind of defines the binding tokens

1663
00:55:57,520 --> 00:55:59,119
and so in this one when you're actually

1664
00:55:59,119 --> 00:56:00,319
querying them

1665
00:56:00,319 --> 00:56:01,599
this is the function to read them out of

1666
00:56:01,599 --> 00:56:02,960
the kernel

1667
00:56:02,960 --> 00:56:04,000
um

1668
00:56:04,000 --> 00:56:05,760
and it turns out there's another kind of

1669
00:56:05,760 --> 00:56:08,079
the same time of check time of use bug

1670
00:56:08,079 --> 00:56:09,760
um

1671
00:56:09,760 --> 00:56:11,200
this uh

1672
00:56:11,200 --> 00:56:14,079
the memory that's being used is the

1673
00:56:14,079 --> 00:56:15,119
uh

1674
00:56:15,119 --> 00:56:17,280
with a direct i o where there's a

1675
00:56:17,280 --> 00:56:19,040
pages in memory with a kernel mode

1676
00:56:19,040 --> 00:56:21,200
address that maps to the same backing

1677
00:56:21,200 --> 00:56:22,480
page

1678
00:56:22,480 --> 00:56:24,480
um and you can see down near the bottom

1679
00:56:24,480 --> 00:56:26,480
it's uh the length gets written up to

1680
00:56:26,480 --> 00:56:28,480
the user mode memory and then right away

1681
00:56:28,480 --> 00:56:30,720
afterwards

1682
00:56:30,720 --> 00:56:32,640
it's incrementing to the next property

1683
00:56:32,640 --> 00:56:34,559
that's going to read out and it uses the

1684
00:56:34,559 --> 00:56:36,880
the size that was written

1685
00:56:36,880 --> 00:56:38,319
written into user mode memory reads it

1686
00:56:38,319 --> 00:56:40,240
back out and increments the loop so if

1687
00:56:40,240 --> 00:56:42,480
user mode messes with the size

1688
00:56:42,480 --> 00:56:44,160
we get another kind of right past the

1689
00:56:44,160 --> 00:56:45,680
end of the buffer

1690
00:56:45,680 --> 00:56:47,599
um

1691
00:56:47,599 --> 00:56:50,880
yeah sadly however

1692
00:56:53,520 --> 00:56:54,400
uh

1693
00:56:54,400 --> 00:56:56,000
okay here's the code for it this this

1694
00:56:56,000 --> 00:56:57,680
code is i didn't actually try compiling

1695
00:56:57,680 --> 00:56:59,599
it but this is actually all the code to

1696
00:56:59,599 --> 00:57:01,520
trigger the trigger the bug so on the

1697
00:57:01,520 --> 00:57:02,319
left

1698
00:57:02,319 --> 00:57:04,400
essentially we just create two session

1699
00:57:04,400 --> 00:57:06,400
properties at the bottom

1700
00:57:06,400 --> 00:57:08,640
we query them continuously in a loop and

1701
00:57:08,640 --> 00:57:09,680
on the right

1702
00:57:09,680 --> 00:57:11,280
is a thread that's created that just

1703
00:57:11,280 --> 00:57:13,440
keeps overwriting the file size and so

1704
00:57:13,440 --> 00:57:15,200
eventually the race will win

1705
00:57:15,200 --> 00:57:16,319
and we'll

1706
00:57:16,319 --> 00:57:18,079
write way past the end of the buffer and

1707
00:57:18,079 --> 00:57:20,160
cause a crash um

1708
00:57:20,160 --> 00:57:21,520
unfortunately it turns out this is

1709
00:57:21,520 --> 00:57:23,520
exactly the same as the alpc it's in the

1710
00:57:23,520 --> 00:57:25,680
system pte range so i didn't have a way

1711
00:57:25,680 --> 00:57:28,960
of turning this into an exploit

1712
00:57:28,960 --> 00:57:30,160
um

1713
00:57:30,160 --> 00:57:31,520
all right so pretty much

1714
00:57:31,520 --> 00:57:34,400
done this is the the timeline uh for

1715
00:57:34,400 --> 00:57:36,720
when i did this work so

1716
00:57:36,720 --> 00:57:39,200
windows vista came out in 2007.

1717
00:57:39,200 --> 00:57:40,480
um

1718
00:57:40,480 --> 00:57:42,960
i started looking at this stuff in april

1719
00:57:42,960 --> 00:57:43,839
um

1720
00:57:43,839 --> 00:57:46,640
found the alpc bug about a week later

1721
00:57:46,640 --> 00:57:49,040
found the socket bugs

1722
00:57:49,040 --> 00:57:50,960
um and then a week later we submitted

1723
00:57:50,960 --> 00:57:52,799
kind of sample exploits and the proof of

1724
00:57:52,799 --> 00:57:55,040
concept to microsoft

1725
00:57:55,040 --> 00:57:57,280
everything ended up getting patched by

1726
00:57:57,280 --> 00:57:58,720
the fall

1727
00:57:58,720 --> 00:58:00,319
so maybe four or five months for some of

1728
00:58:00,319 --> 00:58:04,319
them which isn't which isn't too bad um

1729
00:58:04,319 --> 00:58:06,880
yeah that's it uh have some

1730
00:58:06,880 --> 00:58:08,880
acknowledgments so these are papers uh

1731
00:58:08,880 --> 00:58:11,280
and presentations i i referenced

1732
00:58:11,280 --> 00:58:13,520
um doing the write up uh there's a link

1733
00:58:13,520 --> 00:58:15,839
to the paper that i put out

1734
00:58:15,839 --> 00:58:19,280
back in november maybe um if anybody

1735
00:58:19,280 --> 00:58:20,799
wants more details

1736
00:58:20,799 --> 00:58:22,480
and then if there's time i think we're

1737
00:58:22,480 --> 00:58:24,319
going into break but if anybody wants to

1738
00:58:24,319 --> 00:58:26,720
stay past the break uh feel free to ask

1739
00:58:26,720 --> 00:58:29,760
questions or that's me on twitter xnomad

1740
00:58:29,760 --> 00:58:30,720
so

1741
00:58:30,720 --> 00:58:34,279
you can find me there

1742
00:58:38,400 --> 00:58:40,480
you

