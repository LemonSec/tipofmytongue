1
00:00:00,000 --> 00:00:05,790
hi everybody so researching iOS

2
00:00:03,959 --> 00:00:08,519
internals and iOS foreign abilities is

3
00:00:05,790 --> 00:00:10,410
hard right you know what I mean my name

4
00:00:08,519 --> 00:00:12,929
is Jonathan effec and welcome to the

5
00:00:10,410 --> 00:00:16,500
talk simplifying iOS research booting

6
00:00:12,929 --> 00:00:18,300
iOS and qmu I gave a similar talk about

7
00:00:16,500 --> 00:00:20,130
this project two months ago at blackhat

8
00:00:18,300 --> 00:00:21,960
Europe and I'm happy to say that in the

9
00:00:20,130 --> 00:00:24,119
short time between the conference's we

10
00:00:21,960 --> 00:00:26,939
were able to implement a lot of new

11
00:00:24,119 --> 00:00:29,400
exciting features I'm excited to be here

12
00:00:26,939 --> 00:00:30,720
and present this project to you I want

13
00:00:29,400 --> 00:00:34,550
to thank you all for being here and for

14
00:00:30,720 --> 00:00:37,829
attending this talk with me let's begin

15
00:00:34,550 --> 00:00:39,629
all right so in this talk I'll whip I

16
00:00:37,829 --> 00:00:42,300
will present a new simple way to

17
00:00:39,629 --> 00:00:43,980
research iOS but before we get into this

18
00:00:42,300 --> 00:00:46,910
new way let's review the current with

19
00:00:43,980 --> 00:00:49,620
research methods used by iOS researchers

20
00:00:46,910 --> 00:00:53,489
so what are the current ways researchers

21
00:00:49,620 --> 00:00:55,739
used in order to analyze iOS there's a

22
00:00:53,489 --> 00:00:57,269
company which offers full iOS simulation

23
00:00:55,739 --> 00:00:59,459
on their remote servers for their

24
00:00:57,270 --> 00:01:01,530
customers they have full debug

25
00:00:59,460 --> 00:01:04,349
capabilities they offer many research

26
00:01:01,530 --> 00:01:06,780
features and they have a solution for

27
00:01:04,349 --> 00:01:10,439
many iOS versions on many iOS devices

28
00:01:06,780 --> 00:01:12,360
now this sounds great right well it is

29
00:01:10,439 --> 00:01:14,580
rate but there are three issues with

30
00:01:12,360 --> 00:01:16,880
using it the first one is that you must

31
00:01:14,580 --> 00:01:19,408
be invited it is not generally available

32
00:01:16,880 --> 00:01:22,020
the second one is that it costs a lot of

33
00:01:19,409 --> 00:01:23,939
money to use their services and the most

34
00:01:22,020 --> 00:01:25,500
important issue is that your private

35
00:01:23,939 --> 00:01:27,360
research which possibly contains

36
00:01:25,500 --> 00:01:29,939
sensitive research details and foreign

37
00:01:27,360 --> 00:01:34,439
abilities is exposed to anyone who can

38
00:01:29,939 --> 00:01:36,658
gain access to the servers another

39
00:01:34,439 --> 00:01:38,250
method used by researchers is to use

40
00:01:36,659 --> 00:01:40,680
developing fused iPhones

41
00:01:38,250 --> 00:01:42,750
these are iPhone devices made by Apple

42
00:01:40,680 --> 00:01:45,360
with full debug capabilities used by

43
00:01:42,750 --> 00:01:47,159
their own OS developers so they could be

44
00:01:45,360 --> 00:01:50,579
able to debug their code on real iPhone

45
00:01:47,159 --> 00:01:52,259
devices recently Apple also announced

46
00:01:50,579 --> 00:01:55,559
that they're going to provide provide

47
00:01:52,259 --> 00:01:58,380
such devices to select few non non Apple

48
00:01:55,560 --> 00:02:00,210
iOS security researchers in order to

49
00:01:58,380 --> 00:02:02,100
assist uncovering iOS security

50
00:02:00,210 --> 00:02:07,710
vulnerabilities before they're used by

51
00:02:02,100 --> 00:02:09,239
offensive hackers this is also great for

52
00:02:07,710 --> 00:02:12,000
research if you can get your hands on

53
00:02:09,239 --> 00:02:13,770
such a device but unfortunately they're

54
00:02:12,000 --> 00:02:15,900
very much unavailable it is very

55
00:02:13,770 --> 00:02:17,460
hard to get one and even if you do get

56
00:02:15,900 --> 00:02:18,990
one you probably had to do something

57
00:02:17,460 --> 00:02:20,790
illegal or at least make an Apple

58
00:02:18,990 --> 00:02:23,970
employee perform a serious breach of

59
00:02:20,790 --> 00:02:25,980
contract in order to get one plus using

60
00:02:23,970 --> 00:02:30,720
physical devices for research does not

61
00:02:25,980 --> 00:02:33,060
scale very well another method used by

62
00:02:30,720 --> 00:02:35,430
researchers is to use checkmate demoted

63
00:02:33,060 --> 00:02:37,440
iPhones thanks to the great work by

64
00:02:35,430 --> 00:02:37,980
axiom X and the team worked on the

65
00:02:37,440 --> 00:02:40,050
project

66
00:02:37,980 --> 00:02:41,820
now most iPhones up to iPhone 10 can be

67
00:02:40,050 --> 00:02:45,330
devoted and debugged as if they were

68
00:02:41,820 --> 00:02:48,030
development fused iPhones this is very

69
00:02:45,330 --> 00:02:50,270
good for research but the equipment

70
00:02:48,030 --> 00:02:52,800
required to do this costs a lot of money

71
00:02:50,270 --> 00:02:54,780
changing the file system device tree the

72
00:02:52,800 --> 00:02:57,590
kernel and other aspects of the system

73
00:02:54,780 --> 00:03:00,210
is more complicated than wind emulation

74
00:02:57,590 --> 00:03:02,160
implementing fast date restoration is

75
00:03:00,210 --> 00:03:06,750
harder in these devices than with

76
00:03:02,160 --> 00:03:08,670
emulation or virtualization and it is

77
00:03:06,750 --> 00:03:12,290
hard to perform research and fuzzing at

78
00:03:08,670 --> 00:03:15,030
scale while using physical devices

79
00:03:12,290 --> 00:03:17,459
another method used by researchers is to

80
00:03:15,030 --> 00:03:19,950
use jailbroken devices on jailbroken

81
00:03:17,460 --> 00:03:22,020
devices you can execute arbitrary kernel

82
00:03:19,950 --> 00:03:24,570
code and recently Brandon is a denier

83
00:03:22,020 --> 00:03:26,430
and beer published projects which

84
00:03:24,570 --> 00:03:29,070
enabled debug capabilities on some

85
00:03:26,430 --> 00:03:32,250
iPhones using vulnerabilities this is

86
00:03:29,070 --> 00:03:34,350
also great for research but unless you

87
00:03:32,250 --> 00:03:36,270
use this kernel debugger then executing

88
00:03:34,350 --> 00:03:39,600
kernel code is far from full debug

89
00:03:36,270 --> 00:03:41,370
capabilities on an emulated device it is

90
00:03:39,600 --> 00:03:43,380
also more challenging to scale such

91
00:03:41,370 --> 00:03:45,390
research while using physical devices

92
00:03:43,380 --> 00:03:49,410
and conduct fuzzing campaigns with fast

93
00:03:45,390 --> 00:03:51,450
state recovery and most importantly it

94
00:03:49,410 --> 00:03:53,670
requires a for an ability to children

95
00:03:51,450 --> 00:03:56,280
jailbreak the iPhone or to use this

96
00:03:53,670 --> 00:03:57,809
kernel debugger so in most cases it

97
00:03:56,280 --> 00:03:59,940
cannot be used to research the most

98
00:03:57,810 --> 00:04:03,959
recent iOS and the most recent iOS

99
00:03:59,940 --> 00:04:06,690
device and another method is to use

100
00:04:03,959 --> 00:04:10,050
regular non-jailbroken iPhones now these

101
00:04:06,690 --> 00:04:11,700
iPhones are very easy to get but they

102
00:04:10,050 --> 00:04:14,700
are very limited in their debug and

103
00:04:11,700 --> 00:04:16,440
research capabilities in most cases all

104
00:04:14,700 --> 00:04:19,829
you have is a crash report that looks

105
00:04:16,440 --> 00:04:21,630
like this now this gives a lot of

106
00:04:19,829 --> 00:04:23,520
information regarding the status of the

107
00:04:21,630 --> 00:04:24,990
CPU and the registers when the panic

108
00:04:23,520 --> 00:04:27,330
happened or the Vernor ability was

109
00:04:24,990 --> 00:04:27,660
triggered but still it is very hard to

110
00:04:27,330 --> 00:04:29,490
war

111
00:04:27,660 --> 00:04:31,350
quit and it is much more difficult than

112
00:04:29,490 --> 00:04:34,560
working with a full kernel debugger

113
00:04:31,350 --> 00:04:36,810
on an emulated system my goal in

114
00:04:34,560 --> 00:04:38,730
emulating iOS was to create a new open

115
00:04:36,810 --> 00:04:41,040
free easy-to-use way to privately

116
00:04:38,730 --> 00:04:43,710
research iOS without requiring any

117
00:04:41,040 --> 00:04:46,230
vulnerabilities and it is very easy to

118
00:04:43,710 --> 00:04:49,229
start using it emulation lets you have

119
00:04:46,230 --> 00:04:51,600
full debug capabilities it is easier to

120
00:04:49,230 --> 00:04:53,820
develop support for more iOS versions

121
00:04:51,600 --> 00:04:56,040
and you can run multiple instances

122
00:04:53,820 --> 00:04:59,099
easily at scale for debugging research

123
00:04:56,040 --> 00:05:00,840
and fuzzing before we get into the

124
00:04:59,100 --> 00:05:05,700
research details let me tell you a

125
00:05:00,840 --> 00:05:07,859
little bit about myself so my name is

126
00:05:05,700 --> 00:05:10,710
Jonathan effec and I manage the Alice

127
00:05:07,860 --> 00:05:12,240
research group at HCL AppScan when I

128
00:05:10,710 --> 00:05:14,669
started this role I wanted to start

129
00:05:12,240 --> 00:05:16,530
getting into iOS security research well

130
00:05:14,670 --> 00:05:19,530
studying the subject I realized that

131
00:05:16,530 --> 00:05:21,030
there was no easy public open way to

132
00:05:19,530 --> 00:05:23,460
research iOS internals and

133
00:05:21,030 --> 00:05:25,409
vulnerabilities this is when I started

134
00:05:23,460 --> 00:05:27,930
looking into emulation I thought that if

135
00:05:25,410 --> 00:05:30,780
i OS could be executed on key mu that I

136
00:05:27,930 --> 00:05:33,750
could create such a research platform

137
00:05:30,780 --> 00:05:35,400
that that is easy to use I looked it up

138
00:05:33,750 --> 00:05:38,940
to see if anyone started working on

139
00:05:35,400 --> 00:05:40,620
emulating iOS emulating iOS and found a

140
00:05:38,940 --> 00:05:43,530
few very old projects that are not

141
00:05:40,620 --> 00:05:45,240
relevant for current versions I also

142
00:05:43,530 --> 00:05:47,609
found another project that started

143
00:05:45,240 --> 00:05:49,320
working on executing iOS interiour again

144
00:05:47,610 --> 00:05:53,370
on key mu and reached some very

145
00:05:49,320 --> 00:05:55,440
interesting milestones this is the

146
00:05:53,370 --> 00:05:59,730
amazing work I found posted on the wards

147
00:05:55,440 --> 00:06:01,500
doing badly blog by Chu Wei Chung all

148
00:05:59,730 --> 00:06:04,380
right so I'm not going to explain what

149
00:06:01,500 --> 00:06:07,200
qmu is but the important thing to note

150
00:06:04,380 --> 00:06:09,690
is that qmu supports emulating arm 64

151
00:06:07,200 --> 00:06:11,520
architectures and therefore it is a

152
00:06:09,690 --> 00:06:16,320
great project to start from when trying

153
00:06:11,520 --> 00:06:18,330
to emulate iOS devices so we before we

154
00:06:16,320 --> 00:06:22,469
get to our research let's review what

155
00:06:18,330 --> 00:06:26,640
was achieved by Chuy's project so they

156
00:06:22,470 --> 00:06:30,600
chose to work on to use iPhone iOS 12

157
00:06:26,640 --> 00:06:32,490
beta 4 for iPhone 10 they extracted the

158
00:06:30,600 --> 00:06:34,410
kernel image in the device tree from the

159
00:06:32,490 --> 00:06:37,740
software update available on the Apple

160
00:06:34,410 --> 00:06:39,750
servers they patched the kernel and were

161
00:06:37,740 --> 00:06:40,720
able to load the patch kernel the device

162
00:06:39,750 --> 00:06:42,250
tree and the

163
00:06:40,720 --> 00:06:44,920
the kernel boot arguments into the

164
00:06:42,250 --> 00:06:47,290
emulated devices memory they were also

165
00:06:44,920 --> 00:06:50,380
able to loader on disk into the emulated

166
00:06:47,290 --> 00:06:53,230
memory and they were able to emulate a

167
00:06:50,380 --> 00:06:57,219
UART see a serial device where they were

168
00:06:53,230 --> 00:06:59,500
able to make the kernel print the kernel

169
00:06:57,220 --> 00:07:02,560
logs and see the kernel logs and this

170
00:06:59,500 --> 00:07:04,930
emulated you are at serial device they

171
00:07:02,560 --> 00:07:07,300
booted the kernel and they booted the

172
00:07:04,930 --> 00:07:09,790
kernel up to the point where it executed

173
00:07:07,300 --> 00:07:12,460
lunch D the first user mode process but

174
00:07:09,790 --> 00:07:16,150
known on Apple executables were executed

175
00:07:12,460 --> 00:07:18,130
on top of it now here you can see the

176
00:07:16,150 --> 00:07:20,099
system serial output and in the output

177
00:07:18,130 --> 00:07:26,920
you can see that lunch D was actually

178
00:07:20,100 --> 00:07:28,660
executed and produced output so what

179
00:07:26,920 --> 00:07:31,840
were our goals when starting this

180
00:07:28,660 --> 00:07:33,669
project we wanted at first to boot the

181
00:07:31,840 --> 00:07:35,530
kernel on Kim you without any patches

182
00:07:33,669 --> 00:07:39,490
and we did just that

183
00:07:35,530 --> 00:07:41,109
but as I will soon present we decided to

184
00:07:39,490 --> 00:07:43,990
patch the kernel for a feature I will

185
00:07:41,110 --> 00:07:45,940
talk about later we wanted to support

186
00:07:43,990 --> 00:07:48,490
different hardware devices this display

187
00:07:45,940 --> 00:07:50,200
touch and everything else we wanted to

188
00:07:48,490 --> 00:07:52,840
support different iOS versions for

189
00:07:50,200 --> 00:07:54,520
different iOS devices and of course the

190
00:07:52,840 --> 00:07:56,969
main motivation for starting the sole

191
00:07:54,520 --> 00:07:59,710
was to conduct iOS security research

192
00:07:56,970 --> 00:08:01,840
plus we wanted to learn a lot about iOS

193
00:07:59,710 --> 00:08:06,430
and qmu internals while working on this

194
00:08:01,840 --> 00:08:09,789
project so what is the current status of

195
00:08:06,430 --> 00:08:11,830
our project as stated before we are able

196
00:08:09,790 --> 00:08:14,770
to execute the kernel and the secure

197
00:08:11,830 --> 00:08:16,780
monitor without any patches but we

198
00:08:14,770 --> 00:08:18,820
decided to drop the secure monitor and

199
00:08:16,780 --> 00:08:25,869
patch the kernel for a feature I will

200
00:08:18,820 --> 00:08:27,700
soon present and we're able to execute

201
00:08:25,870 --> 00:08:29,620
our own user mode applications over

202
00:08:27,700 --> 00:08:31,870
lunch D that are not signed by Apple

203
00:08:29,620 --> 00:08:36,219
we're able to run an interactive bath

204
00:08:31,870 --> 00:08:38,110
shell on iOS on qmu we have a few gdb

205
00:08:36,219 --> 00:08:39,820
scripts that allow us to list the tasks

206
00:08:38,110 --> 00:08:41,950
the threads the location zones and

207
00:08:39,820 --> 00:08:44,020
information about them and we also have

208
00:08:41,950 --> 00:08:47,320
a gdb script that allows us to switch

209
00:08:44,020 --> 00:08:49,329
between threads in the kernel we

210
00:08:47,320 --> 00:08:53,440
currently allow access to the kernel

211
00:08:49,330 --> 00:08:54,520
task port from user mode we're able to

212
00:08:53,440 --> 00:08:56,590
mount the full disk

213
00:08:54,520 --> 00:09:01,060
from the software update with our own

214
00:08:56,590 --> 00:09:03,730
block device driver and the system runs

215
00:09:01,060 --> 00:09:06,969
most of the iOS use remote services that

216
00:09:03,730 --> 00:09:09,190
come on the full disk images we're able

217
00:09:06,970 --> 00:09:11,110
to connect to a dropper ssh server

218
00:09:09,190 --> 00:09:13,750
running on the iOS guests were able to

219
00:09:11,110 --> 00:09:16,900
connect it from to it from the q mu host

220
00:09:13,750 --> 00:09:19,090
and we're able to make the kernel render

221
00:09:16,900 --> 00:09:21,040
its log messages to it to a textual

222
00:09:19,090 --> 00:09:24,340
frame buffer and display this frame

223
00:09:21,040 --> 00:09:29,670
buffer in a q mu window we currently

224
00:09:24,340 --> 00:09:29,670
only support iOS 12.1 for iPhone 6s plus

225
00:09:29,730 --> 00:09:34,000
all right then now let's see a short

226
00:09:32,260 --> 00:09:38,950
demonstration of our project before we

227
00:09:34,000 --> 00:09:40,510
talk about the research details all

228
00:09:38,950 --> 00:09:42,490
right so this is the command line that

229
00:09:40,510 --> 00:09:47,530
we use in order to execute our project

230
00:09:42,490 --> 00:09:49,990
or qmu to emulate the iPhone let's fire

231
00:09:47,530 --> 00:09:52,839
up gdb and attach it to our Q mu

232
00:09:49,990 --> 00:09:55,210
instance and we can see now the kernel

233
00:09:52,840 --> 00:09:57,730
logs and the kernel booting we can see

234
00:09:55,210 --> 00:10:00,100
now the lunge D logs and all the iOS

235
00:09:57,730 --> 00:10:03,090
services starting and we have an

236
00:10:00,100 --> 00:10:03,090
interactive bass show

237
00:10:08,010 --> 00:10:16,620
all right so now let's connect to the

238
00:10:09,960 --> 00:10:21,780
SSH server and we now have an

239
00:10:16,620 --> 00:10:23,700
interactive bash shell over SSH and we

240
00:10:21,780 --> 00:10:26,040
can see that we are running as root and

241
00:10:23,700 --> 00:10:27,600
we can extract some host information we

242
00:10:26,040 --> 00:10:29,430
can get information about the loaded

243
00:10:27,600 --> 00:10:31,410
kernel extensions we can get some

244
00:10:29,430 --> 00:10:33,959
virtual memory statistics and get some

245
00:10:31,410 --> 00:10:37,770
more host information and we can get a

246
00:10:33,960 --> 00:10:39,660
full dump of the i/o kit registry but

247
00:10:37,770 --> 00:10:43,350
more important than that we can go back

248
00:10:39,660 --> 00:10:54,089
to gdb and for example load one over gdb

249
00:10:43,350 --> 00:10:56,040
scripts now this script is used to list

250
00:10:54,090 --> 00:10:57,990
all the currently running tasks and we

251
00:10:56,040 --> 00:10:58,530
can see now that we have our tcp tunnel

252
00:10:57,990 --> 00:11:00,270
running

253
00:10:58,530 --> 00:11:03,360
we have street board running and we have

254
00:11:00,270 --> 00:11:05,069
the dropper ssh server running and we

255
00:11:03,360 --> 00:11:07,380
have a lot of tasks running in the

256
00:11:05,070 --> 00:11:10,200
system but even more important than that

257
00:11:07,380 --> 00:11:12,540
we can just use gdb to debug the kernel

258
00:11:10,200 --> 00:11:14,490
to use all the known and familiar gdb

259
00:11:12,540 --> 00:11:16,829
features and the known and familiar gdb

260
00:11:14,490 --> 00:11:20,960
interface to just debug the kernel as we

261
00:11:16,830 --> 00:11:20,960
would debug anything else in gdb and

262
00:11:21,470 --> 00:11:25,830
another short demonstration just this

263
00:11:24,030 --> 00:11:27,839
time we start a project again but we

264
00:11:25,830 --> 00:11:29,880
have the kernels now rendered in a frame

265
00:11:27,840 --> 00:11:31,740
buffer at the current logs rendered in a

266
00:11:29,880 --> 00:11:33,840
frame buffer we can display this frame

267
00:11:31,740 --> 00:11:39,030
buffer in the qmu window and we haven't

268
00:11:33,840 --> 00:11:42,900
get the bash prompt in this window all

269
00:11:39,030 --> 00:11:45,120
right so we talked about interesting

270
00:11:42,900 --> 00:11:47,280
past research done for executing iOS and

271
00:11:45,120 --> 00:11:49,350
CMU in this talk we are going to walk

272
00:11:47,280 --> 00:11:51,030
through some select research stages we

273
00:11:49,350 --> 00:11:53,880
had to go through to achieve iOS

274
00:11:51,030 --> 00:11:55,470
execution on qmu we will first talk

275
00:11:53,880 --> 00:11:57,480
about how we were able to boot the

276
00:11:55,470 --> 00:11:59,340
kernel then talk about how we were able

277
00:11:57,480 --> 00:12:01,920
to run executables that are not signed

278
00:11:59,340 --> 00:12:03,840
by Apple on the emulated iOS device

279
00:12:01,920 --> 00:12:07,650
after that we will talk about how we

280
00:12:03,840 --> 00:12:10,170
executed bash on iOS later we will talk

281
00:12:07,650 --> 00:12:11,819
about the new content getting access to

282
00:12:10,170 --> 00:12:13,979
the kernel task force from user mode

283
00:12:11,820 --> 00:12:17,010
connecting to a dropper as a site server

284
00:12:13,980 --> 00:12:19,230
on the guest from the host rendering the

285
00:12:17,010 --> 00:12:21,930
kernel logs on a textual frame buffer

286
00:12:19,230 --> 00:12:24,690
using our own block device drivers

287
00:12:21,930 --> 00:12:26,969
the food disc images of the iOS system

288
00:12:24,690 --> 00:12:29,910
and some launched D crazyness we

289
00:12:26,970 --> 00:12:34,080
encountered finally we will talk about

290
00:12:29,910 --> 00:12:38,280
what lies ahead for this project all

291
00:12:34,080 --> 00:12:41,190
right then how did we put the iOS kernel

292
00:12:38,280 --> 00:12:43,589
on cue this subject will will be covered

293
00:12:41,190 --> 00:12:45,210
here only briefly since we need time to

294
00:12:43,590 --> 00:12:47,220
talk about the new feature and because

295
00:12:45,210 --> 00:12:49,410
as we will later see we no longer use

296
00:12:47,220 --> 00:12:51,960
the secure monitor then I will not go on

297
00:12:49,410 --> 00:12:53,459
into all the details here the black hat

298
00:12:51,960 --> 00:12:55,890
slides where this is covered together

299
00:12:53,460 --> 00:12:57,780
with these lights will be uploaded in a

300
00:12:55,890 --> 00:12:59,370
few days to a github repository and the

301
00:12:57,780 --> 00:13:03,900
details can be found there and on our

302
00:12:59,370 --> 00:13:06,900
blog then again how did we put the iOS

303
00:13:03,900 --> 00:13:10,230
kernel in human so we started off with

304
00:13:06,900 --> 00:13:11,730
the method used by Chuy's project we

305
00:13:10,230 --> 00:13:13,560
loaded the different sections of the

306
00:13:11,730 --> 00:13:16,020
kernel into the emulated devices memory

307
00:13:13,560 --> 00:13:18,930
and started at executing the kernel at

308
00:13:16,020 --> 00:13:21,689
its entry point in exception level 1 but

309
00:13:18,930 --> 00:13:23,459
soon enough we hit a we hit a crash when

310
00:13:21,690 --> 00:13:27,180
the when we're trying to execute the

311
00:13:23,460 --> 00:13:29,310
secured monitor call instruction so what

312
00:13:27,180 --> 00:13:32,130
is a secure monitor somewhat similar to

313
00:13:29,310 --> 00:13:34,229
the protection rings concept in x86 in

314
00:13:32,130 --> 00:13:36,480
arm we have for exception levels the

315
00:13:34,230 --> 00:13:38,700
user mode code runs in exception level 0

316
00:13:36,480 --> 00:13:40,440
the kernel and exception level 1 we

317
00:13:38,700 --> 00:13:41,880
don't have code for exception level 2 in

318
00:13:40,440 --> 00:13:44,130
our system but it is used for

319
00:13:41,880 --> 00:13:46,050
hypervisors and the secure monitor runs

320
00:13:44,130 --> 00:13:50,189
in the most privileged mode exception

321
00:13:46,050 --> 00:13:53,819
level 3 all right so this is how the

322
00:13:50,190 --> 00:13:55,890
secure monitor works in iOS so the

323
00:13:53,820 --> 00:13:58,410
secure monitor starts its execution at

324
00:13:55,890 --> 00:14:00,030
boot in exception level 3 it resides in

325
00:13:58,410 --> 00:14:03,209
a secure memory location that is not

326
00:14:00,030 --> 00:14:05,010
accessible to kernel code its services

327
00:14:03,210 --> 00:14:07,140
secure monitor calls from the kernel

328
00:14:05,010 --> 00:14:09,360
this concept is somewhat similar to how

329
00:14:07,140 --> 00:14:12,600
the kernel services system calls from

330
00:14:09,360 --> 00:14:14,580
user mode applications and it is

331
00:14:12,600 --> 00:14:17,640
responsible for kpp kernel patch

332
00:14:14,580 --> 00:14:19,650
protection so kpp protects the system so

333
00:14:17,640 --> 00:14:21,720
even if a hacker is able to exploit an

334
00:14:19,650 --> 00:14:24,360
arbitrary write vulnerability in the

335
00:14:21,720 --> 00:14:26,280
kernel kpp is supposed to stop them from

336
00:14:24,360 --> 00:14:28,440
changing or patching the kernel code the

337
00:14:26,280 --> 00:14:33,030
kernel page table and other important

338
00:14:28,440 --> 00:14:34,730
data structures so how did we overcome

339
00:14:33,030 --> 00:14:36,709
this how do we

340
00:14:34,730 --> 00:14:39,889
how did we execute the secure monitor :

341
00:14:36,709 --> 00:14:42,079
struction so we decided to load the

342
00:14:39,889 --> 00:14:44,269
secure monitor image in the secure

343
00:14:42,079 --> 00:14:45,888
memory of the emulated device and we

344
00:14:44,269 --> 00:14:49,699
also loaded the security monitor boot

345
00:14:45,889 --> 00:14:51,529
arguments into this secure memory and we

346
00:14:49,699 --> 00:14:54,769
started executing the secure monitor at

347
00:14:51,529 --> 00:14:56,480
its entry point in exception level 3 the

348
00:14:54,769 --> 00:14:58,639
secure monitor finished its boot

349
00:14:56,480 --> 00:15:01,339
sequence and jumped to the kernel at its

350
00:14:58,639 --> 00:15:03,019
entry point in exception level 1 the

351
00:15:01,339 --> 00:15:05,959
kernel in its turn

352
00:15:03,019 --> 00:15:07,699
finished its boot sequence and used the

353
00:15:05,959 --> 00:15:10,160
secure monitor to service its secure

354
00:15:07,699 --> 00:15:15,740
monitor calls and we are now able to

355
00:15:10,160 --> 00:15:17,600
boot the kernel on qmu so now let's talk

356
00:15:15,740 --> 00:15:19,399
about how we were able to run our own

357
00:15:17,600 --> 00:15:22,339
applications that are not signed by

358
00:15:19,399 --> 00:15:24,260
Apple on iOS since the iOS kernel will

359
00:15:22,339 --> 00:15:26,930
normally only execute applications that

360
00:15:24,260 --> 00:15:29,360
are assigned by Apple this subject will

361
00:15:26,930 --> 00:15:31,160
also only be covered here briefly more

362
00:15:29,360 --> 00:15:33,980
details can be found in the blackhat

363
00:15:31,160 --> 00:15:36,139
slides and on our blog so we use the

364
00:15:33,980 --> 00:15:38,449
frost cache in order to do this so what

365
00:15:36,139 --> 00:15:40,339
is the trust cash Tosca she's the least

366
00:15:38,449 --> 00:15:42,109
of executable hashes that represent the

367
00:15:40,339 --> 00:15:45,040
executables that are allowed execution

368
00:15:42,110 --> 00:15:47,690
in iOS without a signature verification

369
00:15:45,040 --> 00:15:49,430
only if the executable hash is not in

370
00:15:47,690 --> 00:15:51,170
the trust cache then it's signature is

371
00:15:49,430 --> 00:15:53,209
checked if it is in the list then

372
00:15:51,170 --> 00:15:54,889
execution is allowed so now let's see

373
00:15:53,209 --> 00:15:56,779
how this works by example let's say we

374
00:15:54,889 --> 00:15:59,480
have excludable one and acceptable to

375
00:15:56,779 --> 00:16:02,329
both executables are not signed by Apple

376
00:15:59,480 --> 00:16:04,670
and x-cube all have one hash is not in

377
00:16:02,329 --> 00:16:08,149
the cross cache and the executable tooth

378
00:16:04,670 --> 00:16:10,459
hash is in the trash therefore that's

379
00:16:08,149 --> 00:16:12,589
the kernel will execute allow execution

380
00:16:10,459 --> 00:16:18,979
box to go to and deny execution of

381
00:16:12,589 --> 00:16:21,170
executable one so the iOS system has

382
00:16:18,980 --> 00:16:23,660
three different types of cross caches

383
00:16:21,170 --> 00:16:25,639
there is the least of hard-coded hashes

384
00:16:23,660 --> 00:16:28,040
approved in the kernel cache they reside

385
00:16:25,639 --> 00:16:31,250
in the kernel image itself and it is

386
00:16:28,040 --> 00:16:32,149
hard-coded in the kernel image so we

387
00:16:31,250 --> 00:16:34,190
could have just

388
00:16:32,149 --> 00:16:36,889
overridden some of the hashes in this

389
00:16:34,190 --> 00:16:39,709
list and in use this list in order to

390
00:16:36,889 --> 00:16:42,019
allow execution of our own applications

391
00:16:39,709 --> 00:16:44,420
but at first we did not want to patch

392
00:16:42,019 --> 00:16:46,339
the kernel at all so we did not choose

393
00:16:44,420 --> 00:16:49,260
this approach

394
00:16:46,339 --> 00:16:51,330
there is also a dynamic trust cash that

395
00:16:49,260 --> 00:16:53,220
can that can be loaded at runtime from a

396
00:16:51,330 --> 00:16:55,589
file but in order to load this dynamic

397
00:16:53,220 --> 00:16:57,420
trust cash from a file at runtime we

398
00:16:55,589 --> 00:17:00,810
needed our user mode code to be allowed

399
00:16:57,420 --> 00:17:04,290
execution so we couldn't do this as well

400
00:17:00,810 --> 00:17:06,089
and there is a static trust cache in

401
00:17:04,290 --> 00:17:09,928
memory that is pointed to from the

402
00:17:06,089 --> 00:17:12,780
device tree so what is a device tree

403
00:17:09,929 --> 00:17:14,429
device tree let's the bootloader tell

404
00:17:12,780 --> 00:17:15,800
the colonel what hardware devices are

405
00:17:14,429 --> 00:17:18,480
attached to the host and the

406
00:17:15,800 --> 00:17:20,309
specifications of these devices in

407
00:17:18,480 --> 00:17:21,959
addition it enables the bootloader to

408
00:17:20,309 --> 00:17:24,510
pass to the kernel other pieces of

409
00:17:21,959 --> 00:17:28,260
information such as the location in

410
00:17:24,510 --> 00:17:30,270
memory of the trust gosh now the raw

411
00:17:28,260 --> 00:17:32,400
device tree is available in the software

412
00:17:30,270 --> 00:17:35,250
update and we do patch the device tree

413
00:17:32,400 --> 00:17:39,140
to add the static trust cache to it and

414
00:17:35,250 --> 00:17:39,140
we also patch it for different reasons

415
00:17:39,500 --> 00:17:43,800
so we now see that the iOS kernel

416
00:17:42,000 --> 00:17:46,140
accepts the static cross cache with the

417
00:17:43,800 --> 00:17:49,649
least of executable hashes that exists

418
00:17:46,140 --> 00:17:51,660
in its memory before the kernel boot the

419
00:17:49,650 --> 00:17:54,330
address of this trust cache must be

420
00:17:51,660 --> 00:17:59,220
pointed to by the device tree by

421
00:17:54,330 --> 00:18:01,409
reversing this code an other code that

422
00:17:59,220 --> 00:18:03,780
is used for parsing the input static

423
00:18:01,410 --> 00:18:06,210
trust structure we were able to

424
00:18:03,780 --> 00:18:08,010
understand its structure this way we

425
00:18:06,210 --> 00:18:09,809
were able to build our own static cross

426
00:18:08,010 --> 00:18:13,230
cache and write it to the devices memory

427
00:18:09,809 --> 00:18:15,030
before booting the system and this is

428
00:18:13,230 --> 00:18:16,620
the open source code of the kernel which

429
00:18:15,030 --> 00:18:18,928
reads the address of the static cross

430
00:18:16,620 --> 00:18:20,909
cache from the device tree the kernel

431
00:18:18,929 --> 00:18:23,040
later uses this address to parse the

432
00:18:20,910 --> 00:18:25,200
static rasca structure with the list of

433
00:18:23,040 --> 00:18:27,840
hashes and builds a new structure that

434
00:18:25,200 --> 00:18:31,230
it can search in for the static trust

435
00:18:27,840 --> 00:18:33,149
cache so we build our own static trust

436
00:18:31,230 --> 00:18:35,610
cache with the hashes of our non apple

437
00:18:33,150 --> 00:18:39,630
executables and use it for making the

438
00:18:35,610 --> 00:18:42,360
kernel execute our applications and it

439
00:18:39,630 --> 00:18:44,640
works we are now able to make the iOS

440
00:18:42,360 --> 00:18:49,428
kernel execute our applications using

441
00:18:44,640 --> 00:18:49,429
our own static cross cache now

442
00:18:53,190 --> 00:18:58,300
since we will later see that we now

443
00:18:55,600 --> 00:19:00,790
patch the kernel then we will consider

444
00:18:58,300 --> 00:19:03,070
to later patch core trust to just treat

445
00:19:00,790 --> 00:19:04,840
every application as if it is in the

446
00:19:03,070 --> 00:19:07,030
transition instead of building our own

447
00:19:04,840 --> 00:19:12,429
static trust cache but this is how it

448
00:19:07,030 --> 00:19:15,040
works in the project now all right so

449
00:19:12,430 --> 00:19:16,690
lunch D is the first user mode process

450
00:19:15,040 --> 00:19:18,220
in the system it is responsible for

451
00:19:16,690 --> 00:19:20,710
spawning all other user mode

452
00:19:18,220 --> 00:19:25,510
applications and services now let's see

453
00:19:20,710 --> 00:19:28,750
how we made it execute our bash shell so

454
00:19:25,510 --> 00:19:30,580
the we started with mounting to run disk

455
00:19:28,750 --> 00:19:32,500
on the research computer we used around

456
00:19:30,580 --> 00:19:34,120
disk in order to boot the system and at

457
00:19:32,500 --> 00:19:36,700
first we mounted it on the research

458
00:19:34,120 --> 00:19:39,070
computer then we removed all the files

459
00:19:36,700 --> 00:19:41,110
from the launch demons directory now the

460
00:19:39,070 --> 00:19:43,120
files in the launch demons directory are

461
00:19:41,110 --> 00:19:45,479
responsible for instructing launch D to

462
00:19:43,120 --> 00:19:47,790
execute the other processes and services

463
00:19:45,480 --> 00:19:49,990
each file in this directory is

464
00:19:47,790 --> 00:19:53,649
responsible for instructing launch D to

465
00:19:49,990 --> 00:19:56,290
execute a different process and we added

466
00:19:53,650 --> 00:19:58,420
a single file to this directory to

467
00:19:56,290 --> 00:20:02,470
instruct lunch D to run our bash shell

468
00:19:58,420 --> 00:20:04,930
and we added the bash executable to the

469
00:20:02,470 --> 00:20:07,210
round disk and we added the bash

470
00:20:04,930 --> 00:20:10,570
executable hash to the to our static

471
00:20:07,210 --> 00:20:12,430
cross cache we unmounted the roundest

472
00:20:10,570 --> 00:20:15,850
from the research computer and started

473
00:20:12,430 --> 00:20:18,030
qmu so this is the file that we used in

474
00:20:15,850 --> 00:20:20,290
order to instruct launch T to run bash

475
00:20:18,030 --> 00:20:22,660
and we can see here that we instructed

476
00:20:20,290 --> 00:20:25,240
launch D to run bash interactively and

477
00:20:22,660 --> 00:20:27,400
here we point at lunch D to wear it to

478
00:20:25,240 --> 00:20:31,270
the path where it can find the bash

479
00:20:27,400 --> 00:20:33,130
executable on the wrong disc and here we

480
00:20:31,270 --> 00:20:35,050
instructed launch DTU slash dev slash

481
00:20:33,130 --> 00:20:38,710
console which is the serial device for

482
00:20:35,050 --> 00:20:43,200
SD out SD error and ste and here we

483
00:20:38,710 --> 00:20:43,200
started lunch D to run bash as root

484
00:20:44,010 --> 00:20:50,830
alright so the system actually launch D

485
00:20:46,900 --> 00:20:53,110
try to execute bash now did it work well

486
00:20:50,830 --> 00:20:54,460
of course he did not work at first and

487
00:20:53,110 --> 00:20:57,070
loves showed that they're missing

488
00:20:54,460 --> 00:20:59,980
libraries required in for running bash

489
00:20:57,070 --> 00:21:03,280
and we did not have any idea why this

490
00:20:59,980 --> 00:21:05,380
happened or how we can solve it but as

491
00:21:03,280 --> 00:21:05,920
it turns out the roundest Gammage comes

492
00:21:05,380 --> 00:21:08,110
with

493
00:21:05,920 --> 00:21:09,520
the dynamic loader cash on it now this

494
00:21:08,110 --> 00:21:12,490
is the file that holds most of the

495
00:21:09,520 --> 00:21:14,050
runtime libraries for iOS and he calls

496
00:21:12,490 --> 00:21:17,890
libraries that are required for

497
00:21:14,050 --> 00:21:19,510
executing bash so we decided to copy

498
00:21:17,890 --> 00:21:21,670
this file into the realm disk at the

499
00:21:19,510 --> 00:21:24,190
correct path this file can be found at

500
00:21:21,670 --> 00:21:28,060
the on the full disk images available on

501
00:21:24,190 --> 00:21:30,400
the software update but alas it still

502
00:21:28,060 --> 00:21:35,110
did not work and it still showed the

503
00:21:30,400 --> 00:21:37,270
same error so we now wanted to

504
00:21:35,110 --> 00:21:38,889
understand why this fails for this we

505
00:21:37,270 --> 00:21:40,270
decided to debug the dynamic loader

506
00:21:38,890 --> 00:21:42,400
which is the user mode component

507
00:21:40,270 --> 00:21:45,340
responsible for loading the dynamic

508
00:21:42,400 --> 00:21:47,590
loader cache into the process now since

509
00:21:45,340 --> 00:21:48,790
we have a gdb attached to the iOS kernel

510
00:21:47,590 --> 00:21:52,659
we can just debug this code

511
00:21:48,790 --> 00:21:54,639
interactively and see why it fails okay

512
00:21:52,660 --> 00:21:58,330
so this is the open source code of the

513
00:21:54,640 --> 00:22:00,490
dynamic loader and using it we can just

514
00:21:58,330 --> 00:22:01,990
start our debugging process from the

515
00:22:00,490 --> 00:22:04,210
most interesting place that we want to

516
00:22:01,990 --> 00:22:05,790
debug which is this function open shirt

517
00:22:04,210 --> 00:22:07,870
cache file which is responsible

518
00:22:05,790 --> 00:22:11,889
responsible for loading the dynamic

519
00:22:07,870 --> 00:22:14,080
loader cache file so stepping through

520
00:22:11,890 --> 00:22:16,000
the execution path with gdb showed that

521
00:22:14,080 --> 00:22:19,659
the error was here in this system call

522
00:22:16,000 --> 00:22:21,400
shared reach in map inside and P now

523
00:22:19,660 --> 00:22:23,440
since the project we developed has a

524
00:22:21,400 --> 00:22:25,150
kernel debugger then it makes what would

525
00:22:23,440 --> 00:22:27,310
otherwise be a great challenge very

526
00:22:25,150 --> 00:22:29,110
simple we can just debug the user mode

527
00:22:27,310 --> 00:22:32,800
code and continue debugging the kernel

528
00:22:29,110 --> 00:22:34,870
through the system call now stepping

529
00:22:32,800 --> 00:22:37,120
through this function we see that the

530
00:22:34,870 --> 00:22:40,330
call to shared region map and slide is

531
00:22:37,120 --> 00:22:42,340
the one that fails and stepping into

532
00:22:40,330 --> 00:22:44,500
that function we can see that this is

533
00:22:42,340 --> 00:22:46,990
the condition that fails and in our case

534
00:22:44,500 --> 00:22:50,290
it seems that UID does not equal zero

535
00:22:46,990 --> 00:22:51,970
and therefore the function fails so it

536
00:22:50,290 --> 00:22:53,860
seems that the code tries to validate

537
00:22:51,970 --> 00:22:55,480
that the cache file is owned by root

538
00:22:53,860 --> 00:22:58,120
that they know that dynamic loader cache

539
00:22:55,480 --> 00:23:00,310
file is owned by root 2 ID 0 and it

540
00:22:58,120 --> 00:23:04,030
seems that in our case it is not the

541
00:23:00,310 --> 00:23:05,679
case so we mounted the RAM disk on the

542
00:23:04,030 --> 00:23:07,780
research computer in a different way to

543
00:23:05,680 --> 00:23:09,970
allow permission in editing because the

544
00:23:07,780 --> 00:23:11,649
default way of mounting it around disk

545
00:23:09,970 --> 00:23:14,020
on the research computer does not allow

546
00:23:11,650 --> 00:23:16,300
permission editing and we copied the

547
00:23:14,020 --> 00:23:18,700
dynamic loader cache file again onto it

548
00:23:16,300 --> 00:23:19,600
and which owned it to root and this time

549
00:23:18,700 --> 00:23:24,520
it worked and where

550
00:23:19,600 --> 00:23:26,320
able to run bash over lunch d alright so

551
00:23:24,520 --> 00:23:28,720
now let's talk about the new content

552
00:23:26,320 --> 00:23:31,409
let's see how we're able to get access

553
00:23:28,720 --> 00:23:34,990
to the kernel task port form user mode

554
00:23:31,410 --> 00:23:36,820
so tasks for peds imatra very similar to

555
00:23:34,990 --> 00:23:39,250
a system call that allows getting access

556
00:23:36,820 --> 00:23:41,918
to another task fort on the same host

557
00:23:39,250 --> 00:23:44,049
from user mode and when used with PID 0

558
00:23:41,919 --> 00:23:46,660
it gives access to the kernel task for

559
00:23:44,049 --> 00:23:48,490
it access to another task board gives

560
00:23:46,660 --> 00:23:50,260
full control over the other tasks with

561
00:23:48,490 --> 00:23:51,850
memory read write code execution and

562
00:23:50,260 --> 00:23:54,370
everything else and when used with the

563
00:23:51,850 --> 00:23:56,439
kernel task port with the kernel task

564
00:23:54,370 --> 00:23:59,918
then it gives full control over the

565
00:23:56,440 --> 00:24:01,840
kernel but it seems that Apple wanted to

566
00:23:59,919 --> 00:24:03,039
restrict access to the kernel task for

567
00:24:01,840 --> 00:24:07,059
it and not give user mode applications

568
00:24:03,039 --> 00:24:09,879
access to it so they added a condition

569
00:24:07,059 --> 00:24:12,070
in this function so that if PID 0 is

570
00:24:09,880 --> 00:24:16,330
asked for that is the kernel task port

571
00:24:12,070 --> 00:24:18,220
then the function fails not only did

572
00:24:16,330 --> 00:24:20,260
Apple prevent access to the kernel task

573
00:24:18,220 --> 00:24:23,080
port they also prevented usage of such

574
00:24:20,260 --> 00:24:25,200
ports from user mode with this code that

575
00:24:23,080 --> 00:24:28,539
gets called whenever a task port is used

576
00:24:25,200 --> 00:24:30,850
in here we can see that the task pointer

577
00:24:28,539 --> 00:24:33,190
is checked to see if we try to operate

578
00:24:30,850 --> 00:24:35,530
on the kernel test and that the corn

579
00:24:33,190 --> 00:24:38,860
task is not the kernel if this is the

580
00:24:35,530 --> 00:24:40,539
case then access is denied note that the

581
00:24:38,860 --> 00:24:42,100
first comparison is just a pointer

582
00:24:40,539 --> 00:24:44,500
comparison and it does not check any

583
00:24:42,100 --> 00:24:48,219
other task attributes to verify it is

584
00:24:44,500 --> 00:24:50,740
indeed the kernel task so see guzar

585
00:24:48,220 --> 00:24:52,330
suggested a way to overcome this see

586
00:24:50,740 --> 00:24:54,820
goose's suggestion is implementing

587
00:24:52,330 --> 00:24:56,320
different jail breaks and exploits remap

588
00:24:54,820 --> 00:24:58,450
the kernel task memory to another

589
00:24:56,320 --> 00:25:00,639
virtual memory buffer in a different

590
00:24:58,450 --> 00:25:03,400
address and create a new task force to

591
00:25:00,640 --> 00:25:05,320
point to this new address this way the

592
00:25:03,400 --> 00:25:07,510
pointer comparison will not detect this

593
00:25:05,320 --> 00:25:09,370
as the kernel test because it is in a

594
00:25:07,510 --> 00:25:12,340
different address and will allow access

595
00:25:09,370 --> 00:25:14,080
after that install this new task for

596
00:25:12,340 --> 00:25:17,709
that special host port 4 which is

597
00:25:14,080 --> 00:25:19,360
accessible to user mode applications we

598
00:25:17,710 --> 00:25:21,360
still did not want to patch the kernel

599
00:25:19,360 --> 00:25:24,280
at this point so we went on a solution

600
00:25:21,360 --> 00:25:27,790
similar to what is suggested on C

601
00:25:24,280 --> 00:25:30,280
goose's repository so we allocated

602
00:25:27,790 --> 00:25:33,158
static virtual memory for the remap for

603
00:25:30,280 --> 00:25:35,289
a remapped proxy kernel test and we used

604
00:25:33,159 --> 00:25:37,979
qiyam use mmio mechanism to read our

605
00:25:35,289 --> 00:25:41,229
accrued rights from to our faker faker

606
00:25:37,979 --> 00:25:44,019
no proxy task to the real colonel task

607
00:25:41,229 --> 00:25:46,090
and we created a copy of the colonel

608
00:25:44,019 --> 00:25:50,229
task port but instead of pointing to the

609
00:25:46,090 --> 00:25:52,899
to the colonel task it now points to our

610
00:25:50,229 --> 00:25:55,749
proxy colonel tossed or faked proxy

611
00:25:52,899 --> 00:25:58,299
colonel task and we installed this port

612
00:25:55,749 --> 00:26:02,019
to host special port for which is

613
00:25:58,299 --> 00:26:03,700
accessible to user mode applications so

614
00:26:02,019 --> 00:26:06,279
now let's see how this works again with

615
00:26:03,700 --> 00:26:08,859
some visuals so we allocated memory in

616
00:26:06,279 --> 00:26:10,149
the kernel in a fixed address for a fake

617
00:26:08,859 --> 00:26:12,728
proxy kernel task

618
00:26:10,149 --> 00:26:15,158
so whenever a memory read operation gets

619
00:26:12,729 --> 00:26:17,169
to this buffer it is redirected to the

620
00:26:15,159 --> 00:26:18,879
real colonel task and the value is

621
00:26:17,169 --> 00:26:21,639
returned from the real colonel task

622
00:26:18,879 --> 00:26:24,129
using an MMA o handler in q mu for this

623
00:26:21,639 --> 00:26:28,658
new buffer it works the same way with

624
00:26:24,129 --> 00:26:30,879
write operations after that we created a

625
00:26:28,659 --> 00:26:34,239
fake kernel task Bob we just copied the

626
00:26:30,879 --> 00:26:36,189
original kernel teleport and instead of

627
00:26:34,239 --> 00:26:38,379
having it point to the real colonel task

628
00:26:36,190 --> 00:26:40,960
we had it points to our proxy kernel

629
00:26:38,379 --> 00:26:42,820
task but whenever it is used we actually

630
00:26:40,960 --> 00:26:44,950
operate on the real colonel task because

631
00:26:42,820 --> 00:26:47,830
all the region rights are redirected to

632
00:26:44,950 --> 00:26:50,139
the real colonel task after that we

633
00:26:47,830 --> 00:26:52,629
install this fake kernel teleport to

634
00:26:50,139 --> 00:26:55,019
host special port 4 and therefore it is

635
00:26:52,629 --> 00:26:58,238
now accessible to user mode applications

636
00:26:55,019 --> 00:27:00,460
so this solution solves our two issues

637
00:26:58,239 --> 00:27:02,710
it no longer uses the original kernel

638
00:27:00,460 --> 00:27:04,690
task pointers so the pointer comparison

639
00:27:02,710 --> 00:27:06,460
in the function we saw before will not

640
00:27:04,690 --> 00:27:09,429
detect this as the kernel task and

641
00:27:06,460 --> 00:27:11,440
therefore will not deny access it also

642
00:27:09,429 --> 00:27:13,210
registers this new task for it in a

643
00:27:11,440 --> 00:27:16,389
place that is accessible to user mode

644
00:27:13,210 --> 00:27:19,570
applications in host special port 4 and

645
00:27:16,389 --> 00:27:21,908
it works now that we execute kmm a tool

646
00:27:19,570 --> 00:27:24,070
by Zabuza that uses the kernel task port

647
00:27:21,909 --> 00:27:25,720
to read memory from the kernel we can

648
00:27:24,070 --> 00:27:28,178
see that it can successfully read the

649
00:27:25,720 --> 00:27:31,269
kuruma ho header from the running kernel

650
00:27:28,179 --> 00:27:33,729
memory now since we will later see that

651
00:27:31,269 --> 00:27:35,619
we now do patch the kernel then later we

652
00:27:33,729 --> 00:27:38,529
might decide to change this solution to

653
00:27:35,619 --> 00:27:42,099
just patching these two functions but

654
00:27:38,529 --> 00:27:44,499
this is how it works for now all right

655
00:27:42,099 --> 00:27:46,399
so let's see how we're able to get an

656
00:27:44,499 --> 00:27:50,180
activist state connections

657
00:27:46,400 --> 00:27:53,180
the host to the guests this solution was

658
00:27:50,180 --> 00:27:56,750
implemented by the LF research member

659
00:27:53,180 --> 00:27:58,600
live over on ski so there is the normal

660
00:27:56,750 --> 00:28:00,950
way of doing this just by emulating

661
00:27:58,600 --> 00:28:04,340
networking hardware that can work with

662
00:28:00,950 --> 00:28:06,620
the existing iOS drivers there is

663
00:28:04,340 --> 00:28:09,379
another no normal way to do this with

664
00:28:06,620 --> 00:28:11,659
writing our own driver and emulating and

665
00:28:09,380 --> 00:28:14,570
emulating a network controller that can

666
00:28:11,660 --> 00:28:16,490
work with this driver but we chose to do

667
00:28:14,570 --> 00:28:18,590
it in a much simpler way we chose to do

668
00:28:16,490 --> 00:28:20,960
it with communicating with the qmu host

669
00:28:18,590 --> 00:28:26,270
from a user mode TCP tunnel process

670
00:28:20,960 --> 00:28:28,100
using QM use register write callbacks so

671
00:28:26,270 --> 00:28:30,379
let's see how this works now this is the

672
00:28:28,100 --> 00:28:32,929
TCP tunnel process the user mode process

673
00:28:30,380 --> 00:28:36,620
running in the iOS guest and let's see

674
00:28:32,930 --> 00:28:39,010
what it does in order to to tunnel TCP

675
00:28:36,620 --> 00:28:41,929
connections from the host to the guest

676
00:28:39,010 --> 00:28:44,090
so the first thing that it does is to

677
00:28:41,930 --> 00:28:47,450
allocate a command buffer in its own

678
00:28:44,090 --> 00:28:50,419
memory in its own user mode a user space

679
00:28:47,450 --> 00:28:54,080
process memory after that it allocates a

680
00:28:50,420 --> 00:28:55,910
response buffer after that it writes a

681
00:28:54,080 --> 00:28:57,620
receive command to the command buffer so

682
00:28:55,910 --> 00:29:00,680
now the command buffer holds a receive

683
00:28:57,620 --> 00:29:03,500
command and after that it writes to a

684
00:29:00,680 --> 00:29:05,870
system register in qumu we created our

685
00:29:03,500 --> 00:29:08,720
own emulated new system register that

686
00:29:05,870 --> 00:29:10,429
does not exist on real iPhones we can do

687
00:29:08,720 --> 00:29:13,390
this because qmu has a very good

688
00:29:10,430 --> 00:29:16,310
interface for system register callbacks

689
00:29:13,390 --> 00:29:18,710
all right so now this triggers the qmu

690
00:29:16,310 --> 00:29:22,190
register write handler callback let's

691
00:29:18,710 --> 00:29:24,920
see what we doing in here now the qmu

692
00:29:22,190 --> 00:29:26,720
host has direct readwrite memory access

693
00:29:24,920 --> 00:29:31,250
to their currently mapped virtual memory

694
00:29:26,720 --> 00:29:34,580
map so this this makes reading from the

695
00:29:31,250 --> 00:29:36,500
user from the guest user mode process

696
00:29:34,580 --> 00:29:38,960
very simple even though we're now in the

697
00:29:36,500 --> 00:29:41,630
context of the qmu host user mode

698
00:29:38,960 --> 00:29:45,920
process can just read directly from the

699
00:29:41,630 --> 00:29:47,660
guest from the August process memory so

700
00:29:45,920 --> 00:29:49,580
we read the receive command and then

701
00:29:47,660 --> 00:29:51,590
since we got a receive command we call

702
00:29:49,580 --> 00:29:54,740
the receive function on a host socket

703
00:29:51,590 --> 00:29:56,659
and we write the receive data to their

704
00:29:54,740 --> 00:29:59,150
response buffer so now we have the

705
00:29:56,660 --> 00:29:59,990
response that the the data that we got

706
00:29:59,150 --> 00:30:02,299
from mercy

707
00:29:59,990 --> 00:30:05,480
in the user mode process in the TCP

708
00:30:02,299 --> 00:30:07,970
tunnel memory and and after we have this

709
00:30:05,480 --> 00:30:12,559
we can just sit send these dead data to

710
00:30:07,970 --> 00:30:15,049
a local socket and therefore transfer

711
00:30:12,559 --> 00:30:17,990
data from a whole socket to a guest

712
00:30:15,049 --> 00:30:19,999
socket so this solution is so cool and

713
00:30:17,990 --> 00:30:21,590
simple as it keeps the guest kernel

714
00:30:19,999 --> 00:30:23,330
altogether and just uses direct

715
00:30:21,590 --> 00:30:25,970
communication between the guest user

716
00:30:23,330 --> 00:30:31,399
mode TCP tunnel process and the host qmu

717
00:30:25,970 --> 00:30:33,320
process so we're we received data from

718
00:30:31,399 --> 00:30:35,059
the host socket and send it to the guest

719
00:30:33,320 --> 00:30:37,580
socket and vice versa and this is how

720
00:30:35,059 --> 00:30:39,408
the tcp tunnel works it is very

721
00:30:37,580 --> 00:30:41,299
inefficient with the busy loop running

722
00:30:39,409 --> 00:30:44,119
endlessly without blocking at all even

723
00:30:41,299 --> 00:30:47,059
when there is no traffic available but

724
00:30:44,119 --> 00:30:52,610
it works smoothly enough for now and we

725
00:30:47,059 --> 00:30:54,499
have an active ssh connection okay so

726
00:30:52,610 --> 00:30:56,149
now that we have a working ssh

727
00:30:54,499 --> 00:30:57,799
connection let's talk about how we were

728
00:30:56,149 --> 00:30:59,748
able to get the kernel to render its

729
00:30:57,799 --> 00:31:02,509
kernel logs in a frame buffer instead of

730
00:30:59,749 --> 00:31:05,960
the serial output and how we got qmu to

731
00:31:02,509 --> 00:31:07,789
display this frame buffer so this

732
00:31:05,960 --> 00:31:11,299
solution was implemented by the aleph

733
00:31:07,789 --> 00:31:13,309
research member vera means so the first

734
00:31:11,299 --> 00:31:15,470
thing that we did was to set up a new

735
00:31:13,309 --> 00:31:19,119
ROM FB device with our own display

736
00:31:15,470 --> 00:31:21,799
parameters in qmu and we had to tell it

737
00:31:19,119 --> 00:31:25,059
the frame buffer height width size

738
00:31:21,799 --> 00:31:27,950
address pixel format and everything else

739
00:31:25,059 --> 00:31:30,230
the iOS kernel has built-in support for

740
00:31:27,950 --> 00:31:31,940
rendering the console output messages to

741
00:31:30,230 --> 00:31:34,429
a frame buffer instead of writing them

742
00:31:31,940 --> 00:31:36,139
to a serial device so we just have to

743
00:31:34,429 --> 00:31:37,999
configure the relevant boot arguments

744
00:31:36,139 --> 00:31:39,949
with the frame buffer size height width

745
00:31:37,999 --> 00:31:41,690
pixel format memory address and

746
00:31:39,950 --> 00:31:43,730
everything else and make the kernel

747
00:31:41,690 --> 00:31:46,129
render these messages to a frame buffer

748
00:31:43,730 --> 00:31:47,690
after we did that the kernel started

749
00:31:46,129 --> 00:31:49,820
rendering these messages to the

750
00:31:47,690 --> 00:31:52,669
configured frame buffer and here you can

751
00:31:49,820 --> 00:31:58,460
see the code that actually uses that

752
00:31:52,669 --> 00:32:01,549
actually puts this configures the kernel

753
00:31:58,460 --> 00:32:03,619
to use this frame buffer so after that

754
00:32:01,549 --> 00:32:05,749
we just had to connect the qmu MFP

755
00:32:03,619 --> 00:32:07,879
device frame buffer to the iOS frame

756
00:32:05,749 --> 00:32:10,009
buffer and it works and we can now

757
00:32:07,879 --> 00:32:15,080
display in the qmu window the rendered

758
00:32:10,009 --> 00:32:19,789
frame buffer okay so now let's talk

759
00:32:15,080 --> 00:32:22,189
about our block device driver so to run

760
00:32:19,789 --> 00:32:24,799
this that we used until now to boot the

761
00:32:22,190 --> 00:32:27,080
system around disk lock devices do not

762
00:32:24,799 --> 00:32:29,690
support disks that are larger than 1.5

763
00:32:27,080 --> 00:32:33,740
gigabytes the full disk images are

764
00:32:29,690 --> 00:32:36,519
larger than 4 gigabytes plus using the

765
00:32:33,740 --> 00:32:39,139
wrong disk we only have support for

766
00:32:36,519 --> 00:32:41,509
loading one block device in the system

767
00:32:39,139 --> 00:32:43,039
but we wanted a block device for the

768
00:32:41,509 --> 00:32:44,899
route mount and another one for the

769
00:32:43,039 --> 00:32:48,889
readwrite data mount same as a regular

770
00:32:44,899 --> 00:32:50,959
iOS system so to solve this we wrote our

771
00:32:48,889 --> 00:32:54,019
own block device driver to load the two

772
00:32:50,960 --> 00:32:56,359
large block devices and now we had to

773
00:32:54,019 --> 00:32:58,159
patch the kernel and call our driver

774
00:32:56,359 --> 00:33:01,369
during the kernel boot and we had to do

775
00:32:58,159 --> 00:33:03,049
it this way because we needed our block

776
00:33:01,369 --> 00:33:05,149
device driver to be up and running

777
00:33:03,049 --> 00:33:08,539
before the kernel mounts the root mount

778
00:33:05,149 --> 00:33:10,100
in order to use our block device we

779
00:33:08,539 --> 00:33:12,109
tried to solve this in a few ways

780
00:33:10,100 --> 00:33:14,209
without patching the kernel and spent

781
00:33:12,109 --> 00:33:16,609
quite some time on it but eventually we

782
00:33:14,210 --> 00:33:18,769
decided at this point that it is now

783
00:33:16,609 --> 00:33:22,970
time to patch the kernel and solve it

784
00:33:18,769 --> 00:33:26,389
this way so first let's see how the

785
00:33:22,970 --> 00:33:27,129
kernel how the hook how we hook the

786
00:33:26,389 --> 00:33:30,320
kernel

787
00:33:27,129 --> 00:33:32,570
so we allocated kernel memory at a fixed

788
00:33:30,320 --> 00:33:36,499
location and we wrote a trampoline who

789
00:33:32,570 --> 00:33:39,379
code in arm 64 assembly and copied it to

790
00:33:36,499 --> 00:33:42,049
the allocated kernel memory then we

791
00:33:39,379 --> 00:33:45,080
compiled our driver code reading in situ

792
00:33:42,049 --> 00:33:47,690
a flat arm 64 binary and we also copied

793
00:33:45,080 --> 00:33:49,820
it to the allocated kernel memory we

794
00:33:47,690 --> 00:33:51,409
then parse the page table and made all

795
00:33:49,820 --> 00:33:54,649
this space to pay just read write

796
00:33:51,409 --> 00:33:57,440
execute because they hold our driver

797
00:33:54,649 --> 00:34:00,498
code and data so we need read write

798
00:33:57,440 --> 00:34:01,999
execute all right so let's say this is

799
00:34:00,499 --> 00:34:04,639
the kernel code and this is the place

800
00:34:01,999 --> 00:34:06,559
where we want to install our hook and so

801
00:34:04,639 --> 00:34:09,190
now let's first see if this is a good

802
00:34:06,559 --> 00:34:12,079
candidate for us to install our hook in

803
00:34:09,190 --> 00:34:14,059
so we want to install our hook here and

804
00:34:12,079 --> 00:34:15,710
we need to make sure that there is no

805
00:34:14,059 --> 00:34:17,960
there are no position dependent

806
00:34:15,710 --> 00:34:19,668
instructions because we will later we

807
00:34:17,960 --> 00:34:21,649
will now we will now override three

808
00:34:19,668 --> 00:34:23,388
instructions and we will later execute

809
00:34:21,649 --> 00:34:25,109
them from a different location in memory

810
00:34:23,389 --> 00:34:26,160
so we need to make sure that there

811
00:34:25,110 --> 00:34:28,800
there are no position-dependent

812
00:34:26,159 --> 00:34:32,429
instructions such as a trad RP and

813
00:34:28,800 --> 00:34:34,320
branch instructions and we also need a

814
00:34:32,429 --> 00:34:37,919
register that will be discarded after

815
00:34:34,320 --> 00:34:40,620
the hook because what when we override

816
00:34:37,920 --> 00:34:43,409
these instructions we will also use one

817
00:34:40,620 --> 00:34:47,159
register that that we will not be able

818
00:34:43,409 --> 00:34:48,960
to restore its value later so this looks

819
00:34:47,159 --> 00:34:51,449
like a good candidate because it answers

820
00:34:48,960 --> 00:34:52,980
these two conditions we have no position

821
00:34:51,449 --> 00:34:55,109
dependent instructions here in these

822
00:34:52,980 --> 00:34:57,420
three instructions and we have x1 that

823
00:34:55,110 --> 00:35:02,220
is discarded after the hook so let's

824
00:34:57,420 --> 00:35:04,620
install our hook here so the first thing

825
00:35:02,220 --> 00:35:06,330
that we do is to copy the original

826
00:35:04,620 --> 00:35:08,670
instructions to a different memory

827
00:35:06,330 --> 00:35:11,970
location where we will execute them

828
00:35:08,670 --> 00:35:14,220
later and then we overwrite the original

829
00:35:11,970 --> 00:35:15,839
instructions with new instructions and

830
00:35:14,220 --> 00:35:17,850
these instructions are just responsible

831
00:35:15,840 --> 00:35:21,360
for loading x1 with the hook code

832
00:35:17,850 --> 00:35:24,089
address and then jump to x1 so this is

833
00:35:21,360 --> 00:35:26,250
how it works and then the who code saves

834
00:35:24,090 --> 00:35:28,320
all the registers on the stack set up 6

835
00:35:26,250 --> 00:35:30,420
want to point to the driver code and

836
00:35:28,320 --> 00:35:32,910
then jumps to the driver initialization

837
00:35:30,420 --> 00:35:35,190
code once it returns from the driver

838
00:35:32,910 --> 00:35:37,259
code then we restore all the registers

839
00:35:35,190 --> 00:35:40,080
from the stack we execute the original

840
00:35:37,260 --> 00:35:43,370
three instructions we set up x1 to point

841
00:35:40,080 --> 00:35:46,470
to the kernel code after the hook and we

842
00:35:43,370 --> 00:35:49,890
continue executing the kernel code from

843
00:35:46,470 --> 00:35:51,990
where we stopped okay so now that we're

844
00:35:49,890 --> 00:35:55,049
able to hook the kernel let's see how

845
00:35:51,990 --> 00:35:57,180
the driver itself works so we do not

846
00:35:55,050 --> 00:36:01,860
have a kernel development kit for iOS or

847
00:35:57,180 --> 00:36:05,310
a compatible C++ compiler so in IO kit

848
00:36:01,860 --> 00:36:08,310
each driver is represented by a C++

849
00:36:05,310 --> 00:36:10,620
class and for each class that iOS CPP

850
00:36:08,310 --> 00:36:13,920
runtime has a meta class used mainly for

851
00:36:10,620 --> 00:36:16,950
runtime type information to create a new

852
00:36:13,920 --> 00:36:18,780
block device driver in i/o kit we needed

853
00:36:16,950 --> 00:36:21,480
to create a class inheriting from the

854
00:36:18,780 --> 00:36:23,730
i/o block storage device class implement

855
00:36:21,480 --> 00:36:25,770
the relevant virtual functions create a

856
00:36:23,730 --> 00:36:28,950
class instance and register it in the

857
00:36:25,770 --> 00:36:30,960
i/o kit registry for this we decided to

858
00:36:28,950 --> 00:36:34,470
create a new class with C code that does

859
00:36:30,960 --> 00:36:36,300
the does exactly this so the first thing

860
00:36:34,470 --> 00:36:38,819
that we had to do was to create new v

861
00:36:36,300 --> 00:36:40,859
tables for the for the new class for the

862
00:36:38,819 --> 00:36:46,199
clustered represents our driver and it's

863
00:36:40,859 --> 00:36:48,239
metaclass after that we called the

864
00:36:46,199 --> 00:36:50,849
metaclass constructor and registered the

865
00:36:48,239 --> 00:36:55,410
numeric last instance in the global

866
00:36:50,849 --> 00:36:56,939
iokit classes dictionary after that we

867
00:36:55,410 --> 00:36:59,399
call the static function a low class

868
00:36:56,939 --> 00:37:01,439
with name and used it to create two new

869
00:36:59,400 --> 00:37:03,539
instances over a driver class to

870
00:37:01,439 --> 00:37:05,189
represent our two new vlog devices one

871
00:37:03,539 --> 00:37:08,999
for the route mount and one for the read

872
00:37:05,189 --> 00:37:11,519
write data mount after that we called

873
00:37:08,999 --> 00:37:13,738
register service on these two instances

874
00:37:11,519 --> 00:37:16,558
in order to enable the new block devices

875
00:37:13,739 --> 00:37:19,380
no this is what a regular IO key driver

876
00:37:16,559 --> 00:37:21,989
and the IO and the iOS co-op C++ runtime

877
00:37:19,380 --> 00:37:26,160
would have done to register the classes

878
00:37:21,989 --> 00:37:28,589
in to register their instances so again

879
00:37:26,160 --> 00:37:30,928
in iokit each driver is represented by a

880
00:37:28,589 --> 00:37:33,660
C++ class and for each class there is

881
00:37:30,929 --> 00:37:36,029
also a meta class for our new classes we

882
00:37:33,660 --> 00:37:37,769
copied the V tables of the class and

883
00:37:36,029 --> 00:37:40,079
it's meta class and created our own

884
00:37:37,769 --> 00:37:43,859
three tables with our own virtual

885
00:37:40,079 --> 00:37:45,959
functions for the metaclass we

886
00:37:43,859 --> 00:37:48,409
implemented the alec virtual function

887
00:37:45,959 --> 00:37:51,209
and we will get to that later

888
00:37:48,409 --> 00:37:53,339
we change a few virtual functions for

889
00:37:51,209 --> 00:37:55,529
the class itself but we will only talk

890
00:37:53,339 --> 00:37:58,469
about one one of them to explain how

891
00:37:55,529 --> 00:38:00,479
this works the virtual functions indices

892
00:37:58,469 --> 00:38:02,789
and roles were examined by reversing

893
00:38:00,479 --> 00:38:04,859
other classes that inherit from the i/o

894
00:38:02,789 --> 00:38:09,269
block storage device in the kernel and

895
00:38:04,859 --> 00:38:11,279
their virtual functions so this is the

896
00:38:09,269 --> 00:38:13,738
driver bringing up code and we just saw

897
00:38:11,279 --> 00:38:16,439
how we created the two new V tables

898
00:38:13,739 --> 00:38:18,659
after we create the two new V tables we

899
00:38:16,439 --> 00:38:20,939
call the metaclass constructor to create

900
00:38:18,659 --> 00:38:25,169
a meta class global instance and the

901
00:38:20,939 --> 00:38:26,788
inheritance data is actually used here

902
00:38:25,169 --> 00:38:29,118
in the meta class constructor call and

903
00:38:26,789 --> 00:38:31,799
saved in the metaclass global instance

904
00:38:29,119 --> 00:38:33,839
after that we registered a meta class

905
00:38:31,799 --> 00:38:37,349
instance in the global iokit dictionary

906
00:38:33,839 --> 00:38:41,159
and after that we create a driver

907
00:38:37,349 --> 00:38:42,989
instance now to the creation function

908
00:38:41,159 --> 00:38:45,150
finds the driver class by name by

909
00:38:42,989 --> 00:38:46,979
searching this iokit global dictionary

910
00:38:45,150 --> 00:38:49,289
where we're just registered our meta

911
00:38:46,979 --> 00:38:51,890
class in so this is why it is important

912
00:38:49,289 --> 00:38:54,769
to register the medical instance same

913
00:38:51,890 --> 00:38:57,828
global ioki dictionary now this triggers

914
00:38:54,769 --> 00:39:01,189
the lock virtual function for the

915
00:38:57,829 --> 00:39:04,490
metaclass that we over wrote before so

916
00:39:01,190 --> 00:39:06,130
let's see how we implemented it the

917
00:39:04,490 --> 00:39:08,868
first thing that he does is to allocate

918
00:39:06,130 --> 00:39:11,420
kernel memory for the driver instance

919
00:39:08,869 --> 00:39:14,359
then it's called it calls the parent

920
00:39:11,420 --> 00:39:16,549
constructor after that it fixes the

921
00:39:14,359 --> 00:39:19,538
vtable pointer to point where new

922
00:39:16,549 --> 00:39:21,799
created vtable

923
00:39:19,539 --> 00:39:23,809
after that it calls the instance

924
00:39:21,799 --> 00:39:25,730
constructor on the metaclass instance

925
00:39:23,809 --> 00:39:29,690
now this is what gets called every time

926
00:39:25,730 --> 00:39:33,829
a new C++ class is created in the in the

927
00:39:29,690 --> 00:39:38,809
iOS kernel alright so now we have a

928
00:39:33,829 --> 00:39:40,730
driver instance now in iokit every

929
00:39:38,809 --> 00:39:43,339
driver needs to be registered in the i/o

930
00:39:40,730 --> 00:39:45,769
kit registry in order to be active the

931
00:39:43,339 --> 00:39:47,630
i/o kit registry is a tree of driver

932
00:39:45,769 --> 00:39:49,910
nodes that each one is connected to a

933
00:39:47,630 --> 00:39:51,380
parent driver in our case it doesn't

934
00:39:49,910 --> 00:39:54,828
matter which node the driver is

935
00:39:51,380 --> 00:39:58,009
connected to so we find an existing

936
00:39:54,829 --> 00:40:01,880
registry node and we attach a driver to

937
00:39:58,009 --> 00:40:03,799
this existing node and then we call

938
00:40:01,880 --> 00:40:06,079
register service on our new driver

939
00:40:03,799 --> 00:40:09,019
instance now this triggers the iokit

940
00:40:06,079 --> 00:40:11,329
runtime to actually find its own drivers

941
00:40:09,019 --> 00:40:13,459
to attach to our instance and these

942
00:40:11,329 --> 00:40:16,430
drivers are responsible to create the

943
00:40:13,460 --> 00:40:18,680
two new bsd block devices and after that

944
00:40:16,430 --> 00:40:21,640
we have two new block devices that are

945
00:40:18,680 --> 00:40:23,839
actually active and ready to be used

946
00:40:21,640 --> 00:40:26,058
alright so now that we have our block

947
00:40:23,839 --> 00:40:30,440
device is active let's see how we read

948
00:40:26,059 --> 00:40:32,299
and write from them so we implemented

949
00:40:30,440 --> 00:40:35,420
the virtual functions to read write from

950
00:40:32,299 --> 00:40:38,299
to the new block devices and this works

951
00:40:35,420 --> 00:40:40,339
in a very similar manner to help the TCP

952
00:40:38,299 --> 00:40:42,470
tunnel works we write to a system with

953
00:40:40,339 --> 00:40:44,660
register and the qmu callback read

954
00:40:42,470 --> 00:40:48,230
writes directly from two memory buffers

955
00:40:44,660 --> 00:40:50,480
on the guest to transfer the data the

956
00:40:48,230 --> 00:40:54,650
block device data on the qmu host is

957
00:40:50,480 --> 00:40:56,509
backed by files so this is the virtual

958
00:40:54,650 --> 00:40:59,000
function responsible for read and write

959
00:40:56,509 --> 00:41:01,220
operations for the block device same as

960
00:40:59,000 --> 00:41:04,190
the TCP tunnel we again use the qmu

961
00:41:01,220 --> 00:41:05,080
system register callbacks mechanism with

962
00:41:04,190 --> 00:41:07,810
our own

963
00:41:05,080 --> 00:41:10,029
existing system register and we again

964
00:41:07,810 --> 00:41:11,680
used the fact that Q has direct access

965
00:41:10,030 --> 00:41:14,650
to the currently mapped virtual memory

966
00:41:11,680 --> 00:41:17,319
map now this is an example of how the

967
00:41:14,650 --> 00:41:19,390
read operation works so again we

968
00:41:17,320 --> 00:41:22,750
allocate a command buffer in the kernel

969
00:41:19,390 --> 00:41:25,540
memory and we allocate a response buffer

970
00:41:22,750 --> 00:41:27,220
in the kernel memory and we write a read

971
00:41:25,540 --> 00:41:29,290
command to the command buffer so now the

972
00:41:27,220 --> 00:41:32,500
command buffer holds a read command and

973
00:41:29,290 --> 00:41:34,180
we write to the system register and this

974
00:41:32,500 --> 00:41:37,450
triggers the key me register write

975
00:41:34,180 --> 00:41:40,779
handler callback and in it we can just

976
00:41:37,450 --> 00:41:42,970
read directly from the command buffer so

977
00:41:40,780 --> 00:41:45,370
we now read the read command and we

978
00:41:42,970 --> 00:41:50,080
perform a read operation on the file

979
00:41:45,370 --> 00:41:52,740
that is backing the block device and we

980
00:41:50,080 --> 00:41:55,450
write a response to the response buffer

981
00:41:52,740 --> 00:41:56,890
so now the function the read function to

982
00:41:55,450 --> 00:42:00,399
read virtual function of the block

983
00:41:56,890 --> 00:42:03,370
device can return these data and operate

984
00:42:00,400 --> 00:42:05,920
properly and here we can see the ira

985
00:42:03,370 --> 00:42:07,930
output in our system we can see that we

986
00:42:05,920 --> 00:42:10,480
have our driver loaded and active and

987
00:42:07,930 --> 00:42:13,419
here you can see a successful mount

988
00:42:10,480 --> 00:42:15,340
command for our new block device on /mnt

989
00:42:13,420 --> 00:42:20,500
1 and we can see that it actually holds

990
00:42:15,340 --> 00:42:24,850
real data on it all right so now let's

991
00:42:20,500 --> 00:42:26,680
talk again about the secure monitor so

992
00:42:24,850 --> 00:42:28,750
we moved from not batching the kernel at

993
00:42:26,680 --> 00:42:32,589
all to patching it in order to load our

994
00:42:28,750 --> 00:42:34,810
driver but in order to do this we have

995
00:42:32,590 --> 00:42:36,730
to disable the security door in order to

996
00:42:34,810 --> 00:42:39,910
disable kbp right because it will not

997
00:42:36,730 --> 00:42:43,780
allow us to to patch the kernel and to

998
00:42:39,910 --> 00:42:45,970
patch the page table but we have the

999
00:42:43,780 --> 00:42:48,010
secure monitor called that we want to

1000
00:42:45,970 --> 00:42:50,620
not load the secure monitor and just

1001
00:42:48,010 --> 00:42:53,050
start executing the kernel edit entry

1002
00:42:50,620 --> 00:42:55,870
point in exception level 1 but we have

1003
00:42:53,050 --> 00:42:57,670
the secure monitor call instruction that

1004
00:42:55,870 --> 00:43:00,430
we crashed on before when we did just

1005
00:42:57,670 --> 00:43:01,990
that so there is another simple solution

1006
00:43:00,430 --> 00:43:03,910
which is not the secure monitor

1007
00:43:01,990 --> 00:43:07,240
instruction and therefore we can

1008
00:43:03,910 --> 00:43:09,640
continue execution but there's another

1009
00:43:07,240 --> 00:43:11,649
way kpp kicks in and it is by trapping

1010
00:43:09,640 --> 00:43:14,410
floating point operations done in user

1011
00:43:11,650 --> 00:43:17,290
mode or in kernel mode to to the secure

1012
00:43:14,410 --> 00:43:18,970
monitor to exception level 3 but this is

1013
00:43:17,290 --> 00:43:22,630
configured by the CPA

1014
00:43:18,970 --> 00:43:24,069
rel1 register so if we just intercept

1015
00:43:22,630 --> 00:43:25,300
all right income you would just

1016
00:43:24,070 --> 00:43:27,580
intercept all the rights to this

1017
00:43:25,300 --> 00:43:30,400
register so it will always hold this

1018
00:43:27,580 --> 00:43:32,529
value and this value means that FB II

1019
00:43:30,400 --> 00:43:36,130
and III that means don't trap any

1020
00:43:32,530 --> 00:43:38,500
floating operations at all then the K P

1021
00:43:36,130 --> 00:43:40,210
P never kicks in and the secure mana

1022
00:43:38,500 --> 00:43:42,370
door is never triggered and then we can

1023
00:43:40,210 --> 00:43:44,710
just execute our kernel without the

1024
00:43:42,370 --> 00:43:47,170
secure monitor now if you don't want to

1025
00:43:44,710 --> 00:43:49,210
learn more about how this works how K P

1026
00:43:47,170 --> 00:43:53,050
P and the screamo noodle works in iOS

1027
00:43:49,210 --> 00:43:57,940
systems and this is a great very good

1028
00:43:53,050 --> 00:44:00,220
blog post with all the information all

1029
00:43:57,940 --> 00:44:03,250
right so now let's talk about some

1030
00:44:00,220 --> 00:44:05,649
launch D craziness we encountered so we

1031
00:44:03,250 --> 00:44:07,870
created our two raw H of s block device

1032
00:44:05,650 --> 00:44:10,540
disk images with the full disk images

1033
00:44:07,870 --> 00:44:12,069
content from the software update one for

1034
00:44:10,540 --> 00:44:14,980
the route mount and one for the read

1035
00:44:12,070 --> 00:44:17,950
write data mount and we started qmu

1036
00:44:14,980 --> 00:44:20,290
again but instead of having it used we

1037
00:44:17,950 --> 00:44:22,089
pointed it to the to the new blog device

1038
00:44:20,290 --> 00:44:25,509
for the route mount instead of having it

1039
00:44:22,090 --> 00:44:29,110
mount the ROM disk as the route mount

1040
00:44:25,510 --> 00:44:31,480
and we added our laundry items for

1041
00:44:29,110 --> 00:44:33,160
executing back the our bash shell to

1042
00:44:31,480 --> 00:44:35,620
start our tcp tunnel to start our

1043
00:44:33,160 --> 00:44:37,060
dropper ss8 server and other services we

1044
00:44:35,620 --> 00:44:39,279
added them to the launch daemons

1045
00:44:37,060 --> 00:44:44,110
directory as we saw before where all the

1046
00:44:39,280 --> 00:44:46,150
launch the items are saved but when we

1047
00:44:44,110 --> 00:44:48,340
started the system our services did not

1048
00:44:46,150 --> 00:44:52,180
run but we saw that all their original

1049
00:44:48,340 --> 00:44:54,160
system services did run but we did not

1050
00:44:52,180 --> 00:44:56,560
have any idea why this happened or how

1051
00:44:54,160 --> 00:44:59,020
we can solve it so we tried a few things

1052
00:44:56,560 --> 00:45:00,610
we try to remove all the launch the

1053
00:44:59,020 --> 00:45:03,880
items all the files from the launch

1054
00:45:00,610 --> 00:45:06,190
daemons directory but still no go we see

1055
00:45:03,880 --> 00:45:08,140
that all the original iOS services still

1056
00:45:06,190 --> 00:45:12,280
execute same as before and obviously

1057
00:45:08,140 --> 00:45:13,779
ours our processes don't execute so we

1058
00:45:12,280 --> 00:45:17,020
try to remove the launch daemons

1059
00:45:13,780 --> 00:45:21,190
directory altogether but this time we

1060
00:45:17,020 --> 00:45:23,080
get a panic and nothing executes so this

1061
00:45:21,190 --> 00:45:25,090
time we try to boot with the content of

1062
00:45:23,080 --> 00:45:27,220
the roundest we try to boot using the

1063
00:45:25,090 --> 00:45:29,080
new block device but with the old

1064
00:45:27,220 --> 00:45:32,140
content that we used to put around this

1065
00:45:29,080 --> 00:45:32,890
quiz just the same as before but this

1066
00:45:32,140 --> 00:45:34,600
time we got a

1067
00:45:32,890 --> 00:45:37,569
panic with an error about a missing

1068
00:45:34,600 --> 00:45:39,910
service cache so in order to understand

1069
00:45:37,570 --> 00:45:42,640
this we reversed lunch D and we saw that

1070
00:45:39,910 --> 00:45:45,490
there is another file at another place

1071
00:45:42,640 --> 00:45:48,160
where the lunch the items are saved XB c

1072
00:45:45,490 --> 00:45:50,109
d cache dynamic library so this is the

1073
00:45:48,160 --> 00:45:52,629
service cache that was referred that the

1074
00:45:50,110 --> 00:45:54,550
message referred to before and it seems

1075
00:45:52,630 --> 00:45:57,340
that this dynamic library has its own

1076
00:45:54,550 --> 00:45:59,650
data structure which old holds the lunch

1077
00:45:57,340 --> 00:46:02,950
d items instead of using the lunch

1078
00:45:59,650 --> 00:46:05,020
demon's directory and it looks like

1079
00:46:02,950 --> 00:46:07,089
lunch decides whether to use this cache

1080
00:46:05,020 --> 00:46:09,250
or the filesystem disdaineth this

1081
00:46:07,090 --> 00:46:11,460
service cache from the dynamic library

1082
00:46:09,250 --> 00:46:13,930
or the filesystem

1083
00:46:11,460 --> 00:46:16,090
lunch the items from the lunch demons

1084
00:46:13,930 --> 00:46:18,879
directory based on the boot arguments if

1085
00:46:16,090 --> 00:46:21,660
it thinks if if lunch D thinks this is a

1086
00:46:18,880 --> 00:46:23,940
run disk boot then it allows loading

1087
00:46:21,660 --> 00:46:26,770
lunch the items from the filesystem

1088
00:46:23,940 --> 00:46:30,700
otherwise it can only use this dynamic

1089
00:46:26,770 --> 00:46:32,860
library so this is the code where lunch

1090
00:46:30,700 --> 00:46:34,870
D actually decides whether it is around

1091
00:46:32,860 --> 00:46:37,840
this boot or not if it can find our D

1092
00:46:34,870 --> 00:46:40,000
equals MZ 0 in the kernel boot argument

1093
00:46:37,840 --> 00:46:42,730
then it thinks it is around this boot

1094
00:46:40,000 --> 00:46:45,370
otherwise it's not around this quote so

1095
00:46:42,730 --> 00:46:47,920
we just patched the lunch D to make you

1096
00:46:45,370 --> 00:46:50,020
think it always finds already equals and

1097
00:46:47,920 --> 00:46:52,120
the zero and therefore it thinks it is

1098
00:46:50,020 --> 00:46:55,509
around this boot even though it's not

1099
00:46:52,120 --> 00:46:58,270
around this boot and we signed our new

1100
00:46:55,510 --> 00:47:01,660
lunch deep patch binary and we updated

1101
00:46:58,270 --> 00:47:03,940
our static trust cache to include the

1102
00:47:01,660 --> 00:47:05,680
hash of the new assigned binary and we

1103
00:47:03,940 --> 00:47:08,620
replaced the launch D binary in the

1104
00:47:05,680 --> 00:47:11,259
filesystem we removed a service cache

1105
00:47:08,620 --> 00:47:13,480
dynamic library file from the system and

1106
00:47:11,260 --> 00:47:15,670
how it works and launch D uses our lunch

1107
00:47:13,480 --> 00:47:18,190
D lunch D items from the lunch daemons

1108
00:47:15,670 --> 00:47:19,870
directory and we can see that we have

1109
00:47:18,190 --> 00:47:22,480
our bash process running and we have

1110
00:47:19,870 --> 00:47:26,730
springboard and where our tcp tunnel and

1111
00:47:22,480 --> 00:47:26,730
we have our dropper as the state server

1112
00:47:26,760 --> 00:47:29,910
all right

1113
00:47:32,650 --> 00:47:38,260
okay so now let's talk about what lies

1114
00:47:35,320 --> 00:47:41,920
ahead for this project so we want to

1115
00:47:38,260 --> 00:47:44,380
implement Yui and hid support we want to

1116
00:47:41,920 --> 00:47:46,960
understand a step better and and

1117
00:47:44,380 --> 00:47:49,450
actually execute key back D that we just

1118
00:47:46,960 --> 00:47:52,060
disabled for now we want to implement

1119
00:47:49,450 --> 00:47:54,879
interrupt support for performance

1120
00:47:52,060 --> 00:47:57,070
improvement for the TCP tunnel we want

1121
00:47:54,880 --> 00:47:59,680
to test a VPN connection over an SSH

1122
00:47:57,070 --> 00:48:01,690
tunnel we want to implement a few

1123
00:47:59,680 --> 00:48:04,930
performance improvement we want to use

1124
00:48:01,690 --> 00:48:07,930
KVM virtualization instead of emulation

1125
00:48:04,930 --> 00:48:11,080
we wanna see if to investigate using

1126
00:48:07,930 --> 00:48:12,399
more than one CPU and once we get GUI

1127
00:48:11,080 --> 00:48:14,830
support we want to understand if

1128
00:48:12,400 --> 00:48:16,710
software rendering is fast enough or we

1129
00:48:14,830 --> 00:48:19,360
need to do something else

1130
00:48:16,710 --> 00:48:22,630
we want to support more I o s versions

1131
00:48:19,360 --> 00:48:24,550
on for more I Oh s devices we want to

1132
00:48:22,630 --> 00:48:26,350
work on simple occasion with Jonathan

1133
00:48:24,550 --> 00:48:29,830
Levine's day tool or otherwise to

1134
00:48:26,350 --> 00:48:32,440
support more iOS versions we want to

1135
00:48:29,830 --> 00:48:34,029
implement fast state recovery and of

1136
00:48:32,440 --> 00:48:35,530
course the main motivation for starting

1137
00:48:34,030 --> 00:48:37,690
this all was to conduct security

1138
00:48:35,530 --> 00:48:40,660
research and we intend to do just that

1139
00:48:37,690 --> 00:48:43,270
and we intend to you to do fast coverage

1140
00:48:40,660 --> 00:48:47,230
guided structure where with state

1141
00:48:43,270 --> 00:48:48,970
recovery fuzzing now if you found this

1142
00:48:47,230 --> 00:48:51,550
project interesting and useful you can

1143
00:48:48,970 --> 00:48:53,919
find it on github and better yet you can

1144
00:48:51,550 --> 00:48:55,600
contribute code to it on github have a

1145
00:48:53,920 --> 00:48:57,730
look at the issues to tackle posted on

1146
00:48:55,600 --> 00:48:59,500
the github repository if you indeed

1147
00:48:57,730 --> 00:49:01,780
found it interesting you can find more

1148
00:48:59,500 --> 00:49:03,160
research details which are which I did

1149
00:49:01,780 --> 00:49:05,110
not have time to present and other

1150
00:49:03,160 --> 00:49:05,640
research projects on our blog and on

1151
00:49:05,110 --> 00:49:08,320
Twitter

1152
00:49:05,640 --> 00:49:10,060
we will soon update the code the blog

1153
00:49:08,320 --> 00:49:12,940
and everything with all the new content

1154
00:49:10,060 --> 00:49:14,950
that was presented today and that brings

1155
00:49:12,940 --> 00:49:17,650
us to the end I'd like to thank you all

1156
00:49:14,950 --> 00:49:19,710
for your time and attention today thank

1157
00:49:17,650 --> 00:49:19,710
you

1158
00:49:26,550 --> 00:49:41,320
anybody has questions questions no

1159
00:49:36,010 --> 00:49:44,260
questions oh there we go hey thanks for

1160
00:49:41,320 --> 00:49:46,930
the talk so have you tried running qmo

1161
00:49:44,260 --> 00:49:48,520
on an armed host and did it improve like

1162
00:49:46,930 --> 00:49:51,279
your performance and stuff like that for

1163
00:49:48,520 --> 00:49:56,560
fuzzing or did you try it and did it

1164
00:49:51,280 --> 00:49:58,690
help well actually yes we just started

1165
00:49:56,560 --> 00:50:01,750
working on it but it's a very weak ARM

1166
00:49:58,690 --> 00:50:04,900
processor so and of course when doing it

1167
00:50:01,750 --> 00:50:08,020
in full full emulation then it gives no

1168
00:50:04,900 --> 00:50:10,270
performance improvements because it

1169
00:50:08,020 --> 00:50:13,330
still uses emulation but when we try to

1170
00:50:10,270 --> 00:50:15,790
do it with kvn it seems to be running a

1171
00:50:13,330 --> 00:50:17,890
little bit quick quicker but it's KVM

1172
00:50:15,790 --> 00:50:19,870
the system still not does not run very

1173
00:50:17,890 --> 00:50:23,350
well on kV and we have to solve a few

1174
00:50:19,870 --> 00:50:25,420
issues so once once this happens we

1175
00:50:23,350 --> 00:50:29,490
think we'll we will see some performance

1176
00:50:25,420 --> 00:50:29,490
improvements okay thank you very much

1177
00:50:29,730 --> 00:50:33,510
anybody else questions

1178
00:50:41,390 --> 00:50:47,279
so you mentioned intercepting the well

1179
00:50:45,420 --> 00:50:49,410
knocking out the SEM calls and then

1180
00:50:47,280 --> 00:50:53,250
intercepting some of that do you have

1181
00:50:49,410 --> 00:50:55,350
any projection of like what impact that

1182
00:50:53,250 --> 00:50:58,590
will have on the security context of it

1183
00:50:55,350 --> 00:51:01,080
is there any any like now testing that

1184
00:50:58,590 --> 00:51:03,660
you you can't do because that that might

1185
00:51:01,080 --> 00:51:05,430
catch you or things that that might you

1186
00:51:03,660 --> 00:51:06,930
know you might be able to do in an

1187
00:51:05,430 --> 00:51:08,819
emulated environment that may not

1188
00:51:06,930 --> 00:51:13,560
translate to hardware because of the

1189
00:51:08,820 --> 00:51:16,230
modifications you've made there well

1190
00:51:13,560 --> 00:51:18,690
there could be things like that but not

1191
00:51:16,230 --> 00:51:20,550
that I can think of right now it just we

1192
00:51:18,690 --> 00:51:22,710
just use it to disable the security

1193
00:51:20,550 --> 00:51:24,600
durand the kpp so exploiting

1194
00:51:22,710 --> 00:51:26,550
vulnerabilities will be easier on the

1195
00:51:24,600 --> 00:51:28,560
emulated system than on real devices

1196
00:51:26,550 --> 00:51:30,660
because you don't have to I don't know

1197
00:51:28,560 --> 00:51:34,109
if you depending on the device you try

1198
00:51:30,660 --> 00:51:37,830
to attack you there's KT RR or the Lord

1199
00:51:34,109 --> 00:51:41,130
or this kpp mechanism using the secured

1200
00:51:37,830 --> 00:51:44,100
monitor so exploiting will be easier but

1201
00:51:41,130 --> 00:51:50,750
as for finding bugs I can't think of

1202
00:51:44,100 --> 00:51:50,750
anything anyone else

1203
00:51:55,529 --> 00:52:01,509
hi great talk why is there why one point

1204
00:51:59,319 --> 00:52:02,919
five gigabytes limits what's up with

1205
00:52:01,509 --> 00:52:04,719
that where does it come from

1206
00:52:02,919 --> 00:52:08,169
and why can't you just increase it

1207
00:52:04,719 --> 00:52:12,189
instead of doing that whole voodoo stuff

1208
00:52:08,169 --> 00:52:14,618
with the block driver so actually the

1209
00:52:12,189 --> 00:52:17,678
system behaves very strangely when we

1210
00:52:14,619 --> 00:52:19,959
try to load larger disks on the round

1211
00:52:17,679 --> 00:52:22,029
disk and it it actually loads this block

1212
00:52:19,959 --> 00:52:24,189
device in a special mechanism it does

1213
00:52:22,029 --> 00:52:26,979
not use the full IO key driver loaded

1214
00:52:24,189 --> 00:52:30,669
for this block device just creates the

1215
00:52:26,979 --> 00:52:33,308
BST block device in the system and to be

1216
00:52:30,669 --> 00:52:36,098
honest it didn't fail to mount larger

1217
00:52:33,309 --> 00:52:38,019
this it's mounted and then it behaved

1218
00:52:36,099 --> 00:52:39,609
very strangely and instead of

1219
00:52:38,019 --> 00:52:41,408
investigating a gate which we just

1220
00:52:39,609 --> 00:52:51,598
decided to implement our own block

1221
00:52:41,409 --> 00:52:55,539
device driver yep thanks for the talk

1222
00:52:51,599 --> 00:52:58,419
would a porter authentication be

1223
00:52:55,539 --> 00:53:00,880
difficult to add to this project like

1224
00:52:58,419 --> 00:53:03,129
does it already implement that or is

1225
00:53:00,880 --> 00:53:10,509
that going to require a lot of extra

1226
00:53:03,130 --> 00:53:13,389
effort to add Twitter so well we still

1227
00:53:10,509 --> 00:53:15,369
we started to think about this but we

1228
00:53:13,389 --> 00:53:17,829
still haven't really looked into this it

1229
00:53:15,369 --> 00:53:19,389
depends on a few factors if we if we do

1230
00:53:17,829 --> 00:53:24,759
it with emulation then it depends

1231
00:53:19,389 --> 00:53:26,919
whether qmu currently supports fact

1232
00:53:24,759 --> 00:53:29,349
instructions in in a way that is

1233
00:53:26,919 --> 00:53:31,359
compatible with how Apple uses them

1234
00:53:29,349 --> 00:53:33,279
otherwise we'll have to do modifications

1235
00:53:31,359 --> 00:53:35,939
in order to emulate it and when using

1236
00:53:33,279 --> 00:53:38,169
virtualization then we'll have to use a

1237
00:53:35,939 --> 00:53:40,828
processor that supports these

1238
00:53:38,169 --> 00:53:45,839
instructions in such way or to do other

1239
00:53:40,829 --> 00:53:45,839
modifications to support it yeah

