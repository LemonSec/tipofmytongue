1
00:00:00,030 --> 00:00:05,970
hello my name is Alexander Popov I'm

2
00:00:03,659 --> 00:00:08,309
glad to tell you about exploiting a

3
00:00:05,970 --> 00:00:11,849
Linux kernel vulnerability in video for

4
00:00:08,309 --> 00:00:14,940
Linux subsystem I'm a kernel developer

5
00:00:11,849 --> 00:00:17,520
since 2013 and security researcher at

6
00:00:14,940 --> 00:00:20,039
positive technologist the plan of the

7
00:00:17,520 --> 00:00:23,400
talk first I will describe their

8
00:00:20,039 --> 00:00:28,019
vulnerability I will tell about the bugs

9
00:00:23,400 --> 00:00:33,089
the fixes which I made and then I will

10
00:00:28,019 --> 00:00:36,379
focus on exploitation on x86 64 first

11
00:00:33,090 --> 00:00:39,899
about heating the race condition to

12
00:00:36,380 --> 00:00:44,370
provoke the memory corruption then about

13
00:00:39,899 --> 00:00:46,469
the control flow hijack for video for

14
00:00:44,370 --> 00:00:49,879
Linux subsystem then I will describe the

15
00:00:46,469 --> 00:00:53,809
method of bypassing supervisor mode

16
00:00:49,879 --> 00:00:56,360
execution and access prevention from the

17
00:00:53,809 --> 00:00:59,309
kernel thread context restrictions and

18
00:00:56,360 --> 00:01:02,100
finally I will tell about privilege

19
00:00:59,309 --> 00:01:07,020
escalation payload show the demo on

20
00:01:02,100 --> 00:01:09,150
Ubuntu server and interesting part I

21
00:01:07,020 --> 00:01:14,340
will tell about possible exploit

22
00:01:09,150 --> 00:01:16,439
integration this vulnerability is a

23
00:01:14,340 --> 00:01:18,450
local privilege escalation in the Linux

24
00:01:16,439 --> 00:01:21,990
kernel the type of the bug is race

25
00:01:18,450 --> 00:01:23,820
condition everybody may know that race

26
00:01:21,990 --> 00:01:28,589
condition is the situation in software

27
00:01:23,820 --> 00:01:32,508
when the result of the computation

28
00:01:28,590 --> 00:01:37,860
depends on the order of the computations

29
00:01:32,509 --> 00:01:42,899
in for example in simultaneous threads

30
00:01:37,860 --> 00:01:46,860
and this vulnerability is V 2000 1918

31
00:01:42,899 --> 00:01:49,409
683 refers to three similar bugs in the

32
00:01:46,860 --> 00:01:53,960
vivid driver of video file in accept

33
00:01:49,409 --> 00:01:58,320
system and several majors distributions

34
00:01:53,960 --> 00:02:00,710
ship this driver is a kernel module for

35
00:01:58,320 --> 00:02:05,820
example Ubuntu Arch Linux

36
00:02:00,710 --> 00:02:08,848
sousei and some others few words about

37
00:02:05,820 --> 00:02:13,000
video for Linux it is a collection of

38
00:02:08,848 --> 00:02:14,859
drivers and API for

39
00:02:13,000 --> 00:02:17,530
video streaming support in the Linux

40
00:02:14,860 --> 00:02:18,610
kernel and the vulnerable driver the

41
00:02:17,530 --> 00:02:22,320
vivid driver

42
00:02:18,610 --> 00:02:25,000
it has needed for emulating the hardware

43
00:02:22,320 --> 00:02:29,530
which is supported by video for Linux

44
00:02:25,000 --> 00:02:33,090
subsystem and this hardware includes

45
00:02:29,530 --> 00:02:36,130
video caption output and input device

46
00:02:33,090 --> 00:02:38,640
captioned I put devices radio receivers

47
00:02:36,130 --> 00:02:43,359
and transmitters and software-defined

48
00:02:38,640 --> 00:02:46,149
radios this driver a driver is needed

49
00:02:43,360 --> 00:02:49,030
for emulating the hardware to test and

50
00:02:46,150 --> 00:02:53,020
develop the user space software which

51
00:02:49,030 --> 00:02:57,490
interacts with that Hardware through

52
00:02:53,020 --> 00:03:01,660
video file in accept system and this

53
00:02:57,490 --> 00:03:05,050
driver brings their attack surface to

54
00:03:01,660 --> 00:03:07,570
the system it turned out that the device

55
00:03:05,050 --> 00:03:11,350
is created by the driver is available to

56
00:03:07,570 --> 00:03:14,019
normal user to a regular user on Ubuntu

57
00:03:11,350 --> 00:03:19,079
because Ubuntu applies readwrite access

58
00:03:14,020 --> 00:03:21,310
list when the user is logged in

59
00:03:19,080 --> 00:03:24,310
unfortunately I didn't manage to outer

60
00:03:21,310 --> 00:03:29,260
load the vulnerable module that's why I

61
00:03:24,310 --> 00:03:34,840
did the full disclosure the timeline the

62
00:03:29,260 --> 00:03:38,890
bugs were introduced in 2014 and around

63
00:03:34,840 --> 00:03:43,560
5 years later my scholar father with

64
00:03:38,890 --> 00:03:46,600
custom modifications hit the the bug and

65
00:03:43,560 --> 00:03:48,820
gave me the crush I started the

66
00:03:46,600 --> 00:03:51,430
investigation and a month and a half

67
00:03:48,820 --> 00:03:54,400
after that I had a fully working

68
00:03:51,430 --> 00:03:58,780
proof-of-concept exploit and the fixing

69
00:03:54,400 --> 00:04:02,530
patch which I sent to a security team of

70
00:03:58,780 --> 00:04:04,780
the Linux kernel I decided I chosen to

71
00:04:02,530 --> 00:04:07,660
be a good citizen of free software so I

72
00:04:04,780 --> 00:04:09,640
did the responsible disclosure and 15

73
00:04:07,660 --> 00:04:12,190
minutes later Allah knows Torvalds

74
00:04:09,640 --> 00:04:14,950
replied and review started and the next

75
00:04:12,190 --> 00:04:19,839
day I already prepared two more versions

76
00:04:14,950 --> 00:04:22,000
of the fixing patch and Lino's allowed

77
00:04:19,839 --> 00:04:25,359
to do full disclosure because the driver

78
00:04:22,000 --> 00:04:29,139
can't be automatically loaded

79
00:04:25,360 --> 00:04:31,270
November 4 I November 2 I did the full

80
00:04:29,139 --> 00:04:34,690
risk or disclosure but two days later

81
00:04:31,270 --> 00:04:39,490
Allah knows suddenly realized that we

82
00:04:34,690 --> 00:04:43,509
had a mistake in the patch maybe we can

83
00:04:39,490 --> 00:04:45,009
keep details for Q&A but I sent the next

84
00:04:43,509 --> 00:04:48,250
version to the public mailing lists

85
00:04:45,009 --> 00:04:51,490
since the full disclosure was has

86
00:04:48,250 --> 00:04:55,060
already happened and the CV was

87
00:04:51,490 --> 00:05:01,650
allocated for this issue November 8 the

88
00:04:55,060 --> 00:05:04,599
page is taken to the to the tree of

89
00:05:01,650 --> 00:05:06,638
video for Linux maintainer and go to the

90
00:05:04,599 --> 00:05:10,780
main line and in the at the end of

91
00:05:06,639 --> 00:05:14,680
November this page was applied to a

92
00:05:10,780 --> 00:05:17,799
stable trees of the Linux kernel that

93
00:05:14,680 --> 00:05:22,210
was the timeline what was the actual bug

94
00:05:17,800 --> 00:05:23,860
the bugs which which I found I used as I

95
00:05:22,210 --> 00:05:27,359
said I used C square with custom

96
00:05:23,860 --> 00:05:30,130
modifications and Colonel drew sanitizer

97
00:05:27,360 --> 00:05:33,130
detected use after free on the linked

98
00:05:30,130 --> 00:05:35,669
list manipulations in the vulnerable

99
00:05:33,130 --> 00:05:41,050
driver I started to investigate it and

100
00:05:35,669 --> 00:05:43,750
the reason of this memory corruption was

101
00:05:41,050 --> 00:05:46,690
quite far from the memory corruption

102
00:05:43,750 --> 00:05:49,389
itself it turned out that there is the

103
00:05:46,690 --> 00:05:52,449
same incorrect approach to locking in

104
00:05:49,389 --> 00:05:57,779
those three functions it is just copied

105
00:05:52,449 --> 00:05:57,779
and pasted it in in three places and now

106
00:05:59,370 --> 00:06:06,099
let's do that

107
00:06:01,719 --> 00:06:10,690
and now the puzzle for clever system

108
00:06:06,099 --> 00:06:13,210
software developers so we have process

109
00:06:10,690 --> 00:06:14,319
context where we closed the file

110
00:06:13,210 --> 00:06:17,378
descriptor

111
00:06:14,319 --> 00:06:19,900
during this separation the mutex is

112
00:06:17,379 --> 00:06:22,060
locked but on closing at the file

113
00:06:19,900 --> 00:06:24,190
descriptor the kernel thread which is

114
00:06:22,060 --> 00:06:26,590
doing streaming should be stopped as

115
00:06:24,190 --> 00:06:29,139
well but this kernel thread uses this

116
00:06:26,590 --> 00:06:32,650
mutex as well what can we do to avoid

117
00:06:29,139 --> 00:06:35,020
deadlock on the streaming stop and that

118
00:06:32,650 --> 00:06:39,128
was the wrong answer of the developer in

119
00:06:35,020 --> 00:06:41,889
2014 so it decided to unlock mutex

120
00:06:39,129 --> 00:06:44,830
while just to put the colonel threat

121
00:06:41,889 --> 00:06:48,129
wait so just you can see the mutex at

122
00:06:44,830 --> 00:06:51,519
the gate and the kernel thread as a

123
00:06:48,129 --> 00:06:54,459
sheep which is going to get out when we

124
00:06:51,519 --> 00:06:57,129
open the door for a while it was

125
00:06:54,459 --> 00:07:00,879
expectations but the reality that there

126
00:06:57,129 --> 00:07:03,639
are a lot of reader through reader

127
00:07:00,879 --> 00:07:07,469
processes which can compete with kernel

128
00:07:03,639 --> 00:07:13,300
thread for that mutex and win the race

129
00:07:07,469 --> 00:07:16,029
so if so unlocking the mutex during

130
00:07:13,300 --> 00:07:18,069
streaming stop on closing the file

131
00:07:16,029 --> 00:07:22,599
descriptor is a bad idea what happens

132
00:07:18,069 --> 00:07:24,550
another reading function can lock the

133
00:07:22,599 --> 00:07:29,050
mutex instead of kernel thread and

134
00:07:24,550 --> 00:07:31,539
manipulate the cue of the video for

135
00:07:29,050 --> 00:07:33,129
linux buffers and that is completely not

136
00:07:31,539 --> 00:07:35,800
expected by the video for linux

137
00:07:33,129 --> 00:07:41,199
subsystem that the queue is modified

138
00:07:35,800 --> 00:07:44,169
during the streaming stop so that is at

139
00:07:41,199 --> 00:07:46,689
the final page which allows to avoid

140
00:07:44,169 --> 00:07:49,389
such situations it has a proper fix it

141
00:07:46,689 --> 00:07:51,610
consists of two parts the first part I

142
00:07:49,389 --> 00:07:54,389
avoid unlocking the mutex on the

143
00:07:51,610 --> 00:07:58,899
streaming stop just don't do not unload

144
00:07:54,389 --> 00:08:02,709
do not unlock only ask a thread to stop

145
00:07:58,899 --> 00:08:06,550
and the kernel thread in kernel thread I

146
00:08:02,709 --> 00:08:09,879
use mutex trial lock instead of mutex

147
00:08:06,550 --> 00:08:13,389
lock which with which immediately fails

148
00:08:09,879 --> 00:08:20,309
if it can't lock the mutex if it fails

149
00:08:13,389 --> 00:08:23,289
it goes to sleep for a while and starts

150
00:08:20,309 --> 00:08:26,769
the new iteration of the loop what

151
00:08:23,289 --> 00:08:31,748
happens in case of vulnerability

152
00:08:26,769 --> 00:08:34,389
situation there file descriptor is being

153
00:08:31,749 --> 00:08:37,509
closed and the mutex is locked

154
00:08:34,389 --> 00:08:40,719
suddenly the kernel threat wakes up it

155
00:08:37,509 --> 00:08:44,519
tries to lock mutex fails and goes to

156
00:08:40,719 --> 00:08:49,269
sleep it happens several times and then

157
00:08:44,519 --> 00:08:52,089
eventually there on closing the file

158
00:08:49,269 --> 00:08:53,020
descriptor the kernel thread stop is

159
00:08:52,089 --> 00:08:56,490
called

160
00:08:53,020 --> 00:09:01,000
on next and next time when you - when

161
00:08:56,490 --> 00:09:02,700
Colonel thread is woken up it checks

162
00:09:01,000 --> 00:09:06,670
that Colonel thread should stop

163
00:09:02,700 --> 00:09:10,510
understand that yet yes it's okay - now

164
00:09:06,670 --> 00:09:15,010
it is moment to exit and finishes so it

165
00:09:10,510 --> 00:09:17,790
is kind of low class way how to stop the

166
00:09:15,010 --> 00:09:23,110
colonel threat during the streaming stop

167
00:09:17,790 --> 00:09:28,209
when they have they need the same

168
00:09:23,110 --> 00:09:33,700
resource together now let's speak about

169
00:09:28,210 --> 00:09:38,080
the exploitation first part of the

170
00:09:33,700 --> 00:09:40,930
exploitation is winning the race so

171
00:09:38,080 --> 00:09:44,460
hitting the race condition that code I

172
00:09:40,930 --> 00:09:47,349
run in several death threats which are

173
00:09:44,460 --> 00:09:49,660
running simultaneously and this code

174
00:09:47,350 --> 00:09:56,770
hits the race condition you can see here

175
00:09:49,660 --> 00:10:00,160
that okay that read in one P thread

176
00:09:56,770 --> 00:10:04,540
competes with closed in another P thread

177
00:10:00,160 --> 00:10:07,150
and when reading is winning and locks

178
00:10:04,540 --> 00:10:10,240
the music's the linked list is

179
00:10:07,150 --> 00:10:18,430
manipulated and the memory corruption

180
00:10:10,240 --> 00:10:21,610
can happen when a reader wins the race

181
00:10:18,430 --> 00:10:24,790
condition and locked the mutex it adds

182
00:10:21,610 --> 00:10:28,930
another Wiebe to buffer into the vb2

183
00:10:24,790 --> 00:10:31,839
queue and after the streaming is fully

184
00:10:28,930 --> 00:10:34,089
stopped video for linux subsystem cleans

185
00:10:31,840 --> 00:10:37,180
up the resources and frees all the

186
00:10:34,090 --> 00:10:41,410
buffers in this queue but the driver is

187
00:10:37,180 --> 00:10:43,810
not aware that the the buffer which was

188
00:10:41,410 --> 00:10:46,480
you know just added is already freed and

189
00:10:43,810 --> 00:10:48,969
it still has the reference to the freed

190
00:10:46,480 --> 00:10:51,490
object that is use after free which

191
00:10:48,970 --> 00:10:54,550
happens on the next time when streaming

192
00:10:51,490 --> 00:10:58,150
is started again the file descriptor is

193
00:10:54,550 --> 00:11:02,740
opened and we have one read system call

194
00:10:58,150 --> 00:11:06,340
for this file descriptor and here you

195
00:11:02,740 --> 00:11:06,760
can see at the kernel address in it as a

196
00:11:06,340 --> 00:11:11,199
rapport

197
00:11:06,760 --> 00:11:17,970
that their object the vulnerable object

198
00:11:11,199 --> 00:11:23,380
is from K Malik one kilobyte slab cache

199
00:11:17,970 --> 00:11:27,180
now exploiting the use of the free how

200
00:11:23,380 --> 00:11:31,899
to override the object which was freed

201
00:11:27,180 --> 00:11:36,939
the idea was to use brilliant approach

202
00:11:31,899 --> 00:11:40,000
by vitaliy nickel Janka by statics at

203
00:11:36,940 --> 00:11:43,209
are powered by user fault FD what is the

204
00:11:40,000 --> 00:11:45,220
main idea on the first step video for

205
00:11:43,209 --> 00:11:47,410
linux allocates the buffer then on

206
00:11:45,220 --> 00:11:52,389
streaming stop it

207
00:11:47,410 --> 00:11:54,689
frees the buffer and after that we from

208
00:11:52,389 --> 00:11:58,839
the user space we call set exciter and

209
00:11:54,690 --> 00:12:03,300
Colonel allocates the extended attribute

210
00:11:58,839 --> 00:12:07,300
in the kernel space when the size of the

211
00:12:03,300 --> 00:12:11,339
extended attribute is the same sip is

212
00:12:07,300 --> 00:12:15,370
close to VB to buffer size allocator

213
00:12:11,339 --> 00:12:18,730
gives the same address which was just

214
00:12:15,370 --> 00:12:23,260
freed from the similar slap cache that's

215
00:12:18,730 --> 00:12:29,709
why we can put our payload on the freed

216
00:12:23,260 --> 00:12:31,839
object and override it as I said set

217
00:12:29,709 --> 00:12:34,149
exciter is powered by user fault of D it

218
00:12:31,839 --> 00:12:38,589
has needed to keep the payload in the

219
00:12:34,149 --> 00:12:41,980
kernel space there is a page fault

220
00:12:38,589 --> 00:12:44,949
requested at the end of the area which

221
00:12:41,980 --> 00:12:47,290
is allocated in the kernel memory that's

222
00:12:44,949 --> 00:12:49,329
why when the data is copied the page

223
00:12:47,290 --> 00:12:52,480
fault is hit and propagated to the user

224
00:12:49,329 --> 00:12:55,540
space but user space my handler in the

225
00:12:52,480 --> 00:12:59,279
user space does nothing to handle this

226
00:12:55,540 --> 00:13:02,469
page fault that's why the set exciter

227
00:12:59,279 --> 00:13:05,500
process hangs and keeps the payload in

228
00:13:02,470 --> 00:13:12,089
the kernel space forever finally when we

229
00:13:05,500 --> 00:13:16,990
have user to free access the the system

230
00:13:12,089 --> 00:13:20,199
works with overwritten object with the

231
00:13:16,990 --> 00:13:20,800
payload which we put them and we have

232
00:13:20,199 --> 00:13:24,399
the

233
00:13:20,800 --> 00:13:27,160
privilege escalation but it was not so

234
00:13:24,399 --> 00:13:29,230
easy to use this approach in my case

235
00:13:27,160 --> 00:13:31,540
because it turned out that the

236
00:13:29,230 --> 00:13:34,000
vulnerable vb2 buffer is not the last

237
00:13:31,540 --> 00:13:37,180
one which was freed that's why it was

238
00:13:34,000 --> 00:13:41,290
some deeper somewhere deeper in the free

239
00:13:37,180 --> 00:13:43,479
list and calling only only only 1k Malik

240
00:13:41,290 --> 00:13:46,540
was not enough to get the same address

241
00:13:43,480 --> 00:13:48,459
from the alligator that's why I really

242
00:13:46,540 --> 00:13:53,920
needed to spray but how to spray when

243
00:13:48,459 --> 00:13:57,939
your thread is hanging hangs on the set

244
00:13:53,920 --> 00:14:00,010
exciter system cool and I used the brute

245
00:13:57,940 --> 00:14:02,910
force solution I just created a pool of

246
00:14:00,010 --> 00:14:07,330
thread thousands thousands of them and

247
00:14:02,910 --> 00:14:10,779
each of them calls set exciter hangs

248
00:14:07,330 --> 00:14:14,350
happily but we have a lot of allocations

249
00:14:10,779 --> 00:14:16,800
in various slab caches moreover this

250
00:14:14,350 --> 00:14:19,630
approach allows to spread the

251
00:14:16,800 --> 00:14:24,250
allocations distribute them among

252
00:14:19,630 --> 00:14:29,200
different CPUs and have allocations on

253
00:14:24,250 --> 00:14:33,190
all slab caches which are worth CPU so

254
00:14:29,200 --> 00:14:37,270
after a hip sprays successful vb2 buffer

255
00:14:33,190 --> 00:14:40,329
is overwritten by my pal ode and I can

256
00:14:37,270 --> 00:14:44,770
use it for privilege escalation next

257
00:14:40,329 --> 00:14:48,160
step hijack the control floor in video

258
00:14:44,770 --> 00:14:50,470
for Linux subsystem I was learning this

259
00:14:48,160 --> 00:14:54,219
the code of that subsystem for a long

260
00:14:50,470 --> 00:14:57,690
time it was playful I wanted to find

261
00:14:54,220 --> 00:15:00,520
some exploit primitive my goal was to

262
00:14:57,690 --> 00:15:03,520
get arbitrary right primitive but I

263
00:15:00,520 --> 00:15:08,020
didn't manage but finally I found the

264
00:15:03,520 --> 00:15:10,750
very promising function pointer here on

265
00:15:08,020 --> 00:15:14,410
this diagram you can see how objects in

266
00:15:10,750 --> 00:15:21,459
video for linux are connected together

267
00:15:14,410 --> 00:15:24,219
so there is a vb to vivid buffer and vb

268
00:15:21,459 --> 00:15:26,290
to buffer structure just at the

269
00:15:24,220 --> 00:15:31,709
beginning of the structure and it has

270
00:15:26,290 --> 00:15:34,540
the reference to vb 2q structure which

271
00:15:31,709 --> 00:15:37,390
also has the reference to

272
00:15:34,540 --> 00:15:40,420
mium obstruction in that memo of

273
00:15:37,390 --> 00:15:43,210
structure we have a lot of function

274
00:15:40,420 --> 00:15:46,120
pointers and this excellent viader

275
00:15:43,210 --> 00:15:48,970
function pointer which is very

276
00:15:46,120 --> 00:15:50,440
convenient for exploitation moreover you

277
00:15:48,970 --> 00:15:55,120
can see that

278
00:15:50,440 --> 00:15:57,040
mium brief field is passed to this

279
00:15:55,120 --> 00:16:00,370
function pointer what is when it is

280
00:15:57,040 --> 00:16:03,370
called as an argument so if we override

281
00:16:00,370 --> 00:16:05,440
the VB to buffer we can control the

282
00:16:03,370 --> 00:16:09,760
argument of the function pointer which

283
00:16:05,440 --> 00:16:14,260
will be called really nice so I started

284
00:16:09,760 --> 00:16:17,380
to they experiment with implementing

285
00:16:14,260 --> 00:16:20,140
this this idea and first I disabled

286
00:16:17,380 --> 00:16:23,439
supervisor mode access and execution

287
00:16:20,140 --> 00:16:26,130
prevention kernel page table is elation

288
00:16:23,440 --> 00:16:34,690
but those features which can disturb the

289
00:16:26,130 --> 00:16:38,290
read to user attack and I pointed I set

290
00:16:34,690 --> 00:16:44,190
the pointer to VB to Q to the user space

291
00:16:38,290 --> 00:16:49,800
memory but I got all the time.i I got

292
00:16:44,190 --> 00:16:53,320
this error unable to handle page fold

293
00:16:49,800 --> 00:16:56,170
finally I found out that this pointer is

294
00:16:53,320 --> 00:16:58,150
the referenced in the context of kernel

295
00:16:56,170 --> 00:17:03,310
thread where user space is not mapped at

296
00:16:58,150 --> 00:17:05,589
all so that brought the trouble for

297
00:17:03,310 --> 00:17:10,510
exploitation I didn't know how to put

298
00:17:05,589 --> 00:17:12,520
the payload because if the user space is

299
00:17:10,510 --> 00:17:13,990
not mapped at all I should put the

300
00:17:12,520 --> 00:17:17,160
payload somewhere in the kernel space

301
00:17:13,990 --> 00:17:21,670
and it should be at the location of

302
00:17:17,160 --> 00:17:26,050
address with address which I know that

303
00:17:21,670 --> 00:17:27,910
was a trouble but I had a clue during

304
00:17:26,050 --> 00:17:30,760
this experiment I dropped the kernel

305
00:17:27,910 --> 00:17:34,840
changes which I had for deeper fuzzing

306
00:17:30,760 --> 00:17:37,810
and I saw that just before use of the

307
00:17:34,840 --> 00:17:40,780
free video for Linux gives the kernel

308
00:17:37,810 --> 00:17:45,070
warning and this warning contains a lot

309
00:17:40,780 --> 00:17:48,259
of interesting information and moreover

310
00:17:45,070 --> 00:17:51,110
the kernel log where this

311
00:17:48,259 --> 00:17:54,200
is printed is available to regular users

312
00:17:51,110 --> 00:17:56,990
on Ubuntu so maybe it can be useful

313
00:17:54,200 --> 00:17:59,269
useful for exploitation but I didn't

314
00:17:56,990 --> 00:18:01,100
didn't know how to use it that is the

315
00:17:59,269 --> 00:18:07,159
example of the kernel warning you can

316
00:18:01,100 --> 00:18:10,340
see here that there is a code line where

317
00:18:07,159 --> 00:18:12,980
warning happened the contents of the

318
00:18:10,340 --> 00:18:19,279
registers and the call trace so a lot of

319
00:18:12,980 --> 00:18:21,919
information so I spent some time trying

320
00:18:19,279 --> 00:18:25,009
to find a solution and then asked my

321
00:18:21,919 --> 00:18:28,490
friend and Rican eval of who is a very

322
00:18:25,009 --> 00:18:30,799
well well known Colonel security

323
00:18:28,490 --> 00:18:33,679
researcher and he presented me with a

324
00:18:30,799 --> 00:18:35,710
really good idea to put the payload in

325
00:18:33,679 --> 00:18:40,759
the kernel stack and hold it there

326
00:18:35,710 --> 00:18:42,950
waiting with the same technique I use a

327
00:18:40,759 --> 00:18:48,110
fault FD like in the heap spray by

328
00:18:42,950 --> 00:18:50,509
vitaliy Kalyan and it was a really nice

329
00:18:48,110 --> 00:18:53,508
idea which helped me a lot

330
00:18:50,509 --> 00:18:55,789
I think I believe it is a noble method

331
00:18:53,509 --> 00:19:02,869
let me call it Cyrus method to credit my

332
00:18:55,789 --> 00:19:06,850
friend so I had an inside I can read the

333
00:19:02,869 --> 00:19:13,699
kernel warning parse it and extract the

334
00:19:06,850 --> 00:19:15,980
stack RSP register and understand the

335
00:19:13,700 --> 00:19:18,889
location of the kernel stack then next I

336
00:19:15,980 --> 00:19:20,659
can anticipate the future position of

337
00:19:18,889 --> 00:19:22,908
the payload in the kernel stack on the

338
00:19:20,659 --> 00:19:25,340
next system call so I have the place

339
00:19:22,909 --> 00:19:28,669
with known address in the kernel space

340
00:19:25,340 --> 00:19:31,340
wait to put my payload and that was the

341
00:19:28,669 --> 00:19:37,159
most pleasant moment of the research

342
00:19:31,340 --> 00:19:40,279
just like however Flake told us today at

343
00:19:37,159 --> 00:19:43,580
the keynote that that kind of moment

344
00:19:40,279 --> 00:19:49,970
make you make hiking really hip ahem

345
00:19:43,580 --> 00:19:55,418
really that joyful and so I created the

346
00:19:49,970 --> 00:19:59,389
exploit orchestra which did the

347
00:19:55,419 --> 00:20:01,129
exploitation first I will show the

348
00:19:59,389 --> 00:20:01,580
kernel warning with the useful

349
00:20:01,129 --> 00:20:04,300
information

350
00:20:01,580 --> 00:20:07,040
here you can see there are SP register

351
00:20:04,300 --> 00:20:09,860
with the address of the kernel stack and

352
00:20:07,040 --> 00:20:15,080
moreover you can see our eleven register

353
00:20:09,860 --> 00:20:18,020
it starts from eight F which means that

354
00:20:15,080 --> 00:20:21,679
that is the luckiest location somewhere

355
00:20:18,020 --> 00:20:23,840
in the kernel code and that pointer can

356
00:20:21,680 --> 00:20:25,880
be used to bypass kernel address space

357
00:20:23,840 --> 00:20:29,230
layout randomization we can calculate

358
00:20:25,880 --> 00:20:33,560
the offset randomized offset of the

359
00:20:29,230 --> 00:20:39,050
kernel text now about the exploit

360
00:20:33,560 --> 00:20:41,860
orchestra it consists of 50 P threads in

361
00:20:39,050 --> 00:20:45,139
five different roles there are two

362
00:20:41,860 --> 00:20:47,449
eraser eraser P threads which compete

363
00:20:45,140 --> 00:20:50,600
each other to hit the race condition for

364
00:20:47,450 --> 00:20:54,290
later memory corruption then I have 44

365
00:20:50,600 --> 00:20:56,780
sprayers which do ascetic satyr to

366
00:20:54,290 --> 00:21:01,820
perform the heap spray powered by user

367
00:20:56,780 --> 00:21:05,480
fault FD such number I chosen such

368
00:21:01,820 --> 00:21:08,740
number just empirically to make the

369
00:21:05,480 --> 00:21:15,470
exploit really stable so it is the

370
00:21:08,740 --> 00:21:20,270
minimum minimal number which I which I

371
00:21:15,470 --> 00:21:23,300
chosen when for the exploit to be really

372
00:21:20,270 --> 00:21:27,280
stable and not failed then I have two P

373
00:21:23,300 --> 00:21:31,580
threads for caching the page fault

374
00:21:27,280 --> 00:21:34,430
created by user fault FD 1 P thread for

375
00:21:31,580 --> 00:21:37,580
parsing the kernel log to extract the

376
00:21:34,430 --> 00:21:40,010
valuable information from the warning

377
00:21:37,580 --> 00:21:43,010
and adapting adapting the payload

378
00:21:40,010 --> 00:21:45,770
finally I have the one fatality fit to

379
00:21:43,010 --> 00:21:49,280
read which triggers the privilege

380
00:21:45,770 --> 00:21:52,280
escalation and the threat of different

381
00:21:49,280 --> 00:21:55,399
roles synchronize on different sets of

382
00:21:52,280 --> 00:21:59,780
different barriers that how my exploit

383
00:21:55,400 --> 00:22:03,230
orchestra looks like it is me conducting

384
00:21:59,780 --> 00:22:05,840
it P thread and this guy with drums I

385
00:22:03,230 --> 00:22:08,000
think he is a fatality P thread which

386
00:22:05,840 --> 00:22:11,830
perform performs the privilege

387
00:22:08,000 --> 00:22:15,230
escalation now how the exploit is played

388
00:22:11,830 --> 00:22:18,139
I will describe it in chrono

389
00:22:15,230 --> 00:22:20,960
chronological order first we have

390
00:22:18,139 --> 00:22:25,250
barrier prepare when we're all the P

391
00:22:20,960 --> 00:22:27,440
threats prepare before they exploit 44

392
00:22:25,250 --> 00:22:31,519
sprayers create files in temporary file

393
00:22:27,440 --> 00:22:35,210
system for later using inset exciter and

394
00:22:31,519 --> 00:22:38,899
they come to barrier and wait the kernel

395
00:22:35,210 --> 00:22:42,279
message Colonel Locke parser opens the

396
00:22:38,899 --> 00:22:46,399
kernel look they've came message and

397
00:22:42,279 --> 00:22:49,220
comes to better as well and to raves

398
00:22:46,399 --> 00:22:51,830
racers come to the barrier and when they

399
00:22:49,220 --> 00:22:55,330
all together come to the same bear the

400
00:22:51,830 --> 00:23:00,470
bear opens and they start to work

401
00:22:55,330 --> 00:23:05,178
further then we have barrier race it is

402
00:23:00,470 --> 00:23:08,360
only for two P threads for racers racers

403
00:23:05,179 --> 00:23:10,220
first sleep for a while to let other pit

404
00:23:08,360 --> 00:23:13,549
roads go to the next barrier and sleep

405
00:23:10,220 --> 00:23:20,720
and then two racers come to the barrier

406
00:23:13,549 --> 00:23:22,730
and after that starts to to work with a

407
00:23:20,720 --> 00:23:26,990
vivid driver as I described to hit the

408
00:23:22,730 --> 00:23:32,000
race condition next barrier is barrel

409
00:23:26,990 --> 00:23:33,769
pars two racers after after heating the

410
00:23:32,000 --> 00:23:36,440
race condition come to this barrier

411
00:23:33,769 --> 00:23:40,700
where the kernel message parser is

412
00:23:36,440 --> 00:23:42,830
waiting when racers come better opens

413
00:23:40,700 --> 00:23:43,340
and kernel message parser understands

414
00:23:42,830 --> 00:23:46,010
okay

415
00:23:43,340 --> 00:23:49,360
the racing is finished now I need to

416
00:23:46,010 --> 00:23:54,320
parse it parses the kernel warning

417
00:23:49,360 --> 00:23:59,649
parses the kernel log and finds the RSP

418
00:23:54,320 --> 00:24:03,500
and r11 registers the values of them and

419
00:23:59,649 --> 00:24:06,350
it calculates the addresses for the

420
00:24:03,500 --> 00:24:08,090
payload and adapts the payload because

421
00:24:06,350 --> 00:24:12,519
now after parsing we know where the

422
00:24:08,090 --> 00:24:17,330
kernel stack is is in the memory

423
00:24:12,519 --> 00:24:20,289
finally it adapts the payload and comes

424
00:24:17,330 --> 00:24:23,889
to the next barrier barrier key stack

425
00:24:20,289 --> 00:24:27,529
here two racers are waiting for for the

426
00:24:23,889 --> 00:24:29,510
for the spit thread and when they are

427
00:24:27,529 --> 00:24:33,710
all together in the

428
00:24:29,510 --> 00:24:37,040
threat they start there they call the

429
00:24:33,710 --> 00:24:41,929
adjust Timex system cool which puts the

430
00:24:37,040 --> 00:24:44,649
payload on the kernel stack I will tell

431
00:24:41,929 --> 00:24:48,260
about this is called a little bit later

432
00:24:44,650 --> 00:24:52,040
after placing the payload on the kernel

433
00:24:48,260 --> 00:24:55,400
stack in the page fault handler number

434
00:24:52,040 --> 00:24:58,970
two we have we catch two page folds from

435
00:24:55,400 --> 00:25:00,350
the racers and come to the barrier where

436
00:24:58,970 --> 00:25:04,549
sprays are waiting

437
00:25:00,350 --> 00:25:06,799
then sprayers understand that it's time

438
00:25:04,549 --> 00:25:10,700
to put the payload on the kernel heap

439
00:25:06,799 --> 00:25:15,950
and call ascetics at are powered by user

440
00:25:10,700 --> 00:25:17,750
fault FD and this P threads hang and in

441
00:25:15,950 --> 00:25:20,030
the page fault handler number one we

442
00:25:17,750 --> 00:25:23,540
catch all those page faults 44 page

443
00:25:20,030 --> 00:25:25,970
faults and understand okay now the heap

444
00:25:23,540 --> 00:25:29,059
spray is finished we come to the next P

445
00:25:25,970 --> 00:25:31,070
thread next barrier barrier fatality

446
00:25:29,059 --> 00:25:34,220
where the fatality P thread is waiting

447
00:25:31,070 --> 00:25:37,159
and fatality pthread understands when

448
00:25:34,220 --> 00:25:39,110
the barrier opens that it's time to

449
00:25:37,160 --> 00:25:42,740
privileges to do the privilege

450
00:25:39,110 --> 00:25:46,790
escalation and that's it so this method

451
00:25:42,740 --> 00:25:49,160
method allows to bypass supervisor mode

452
00:25:46,790 --> 00:25:52,100
access and execution prevention from the

453
00:25:49,160 --> 00:25:54,679
kernel thread context restrictions and

454
00:25:52,100 --> 00:25:58,120
bypass kernel address space layout

455
00:25:54,679 --> 00:26:02,630
randomization as well on Ubuntu server

456
00:25:58,120 --> 00:26:07,280
now I want to tell you about the exploit

457
00:26:02,630 --> 00:26:11,059
payload so as I already managed

458
00:26:07,280 --> 00:26:14,540
mentioned the payload is created in two

459
00:26:11,059 --> 00:26:17,120
places in kernel heap by spray P threads

460
00:26:14,540 --> 00:26:20,600
which call set exciter and in kernel

461
00:26:17,120 --> 00:26:23,270
stack by Racer P threads which call

462
00:26:20,600 --> 00:26:28,850
adjust time X address time X is the

463
00:26:23,270 --> 00:26:31,700
system call which which calls on when

464
00:26:28,850 --> 00:26:35,149
Colonel handles it it calls copy from

465
00:26:31,700 --> 00:26:38,870
user from the user space to the kernel

466
00:26:35,150 --> 00:26:40,730
stack there is a structure for the time

467
00:26:38,870 --> 00:26:42,860
act structure which is filled by the

468
00:26:40,730 --> 00:26:47,059
user space data and it is

469
00:26:42,860 --> 00:26:49,399
large enough to put the payload the

470
00:26:47,059 --> 00:26:51,980
exploit payload consists of three parts

471
00:26:49,400 --> 00:26:55,040
which you already seen on the diagram

472
00:26:51,980 --> 00:26:57,530
the first is VB to buffer which is in

473
00:26:55,040 --> 00:27:00,440
the kernel heap the second is VB to Q

474
00:26:57,530 --> 00:27:02,299
which is in the kernel stack and finally

475
00:27:00,440 --> 00:27:04,360
the memo ops with the function pointer

476
00:27:02,299 --> 00:27:07,820
which is in the kernel stack as well and

477
00:27:04,360 --> 00:27:10,669
that this diagram shows my payload how

478
00:27:07,820 --> 00:27:14,450
it is organized on the Left left-hand

479
00:27:10,670 --> 00:27:17,870
side you see the kernel heap and VB to

480
00:27:14,450 --> 00:27:23,270
buffer which is overwritten by our hip

481
00:27:17,870 --> 00:27:26,809
spray this VB to buffer refers to VB to

482
00:27:23,270 --> 00:27:30,918
Q which is at the known place in the

483
00:27:26,809 --> 00:27:34,370
kernel stack the data to the kernel

484
00:27:30,919 --> 00:27:38,600
stack is written to E is written to

485
00:27:34,370 --> 00:27:44,209
Colonel timox structure but the VB to

486
00:27:38,600 --> 00:27:46,969
buffer refers to the VB to Q so there

487
00:27:44,210 --> 00:27:50,960
type some type confusion happens because

488
00:27:46,970 --> 00:27:54,770
of use of the free the VB to Q refers to

489
00:27:50,960 --> 00:27:57,200
memo ops and I had to overlap all the

490
00:27:54,770 --> 00:28:01,040
structure all those structures because I

491
00:27:57,200 --> 00:28:03,140
have I have limited space in the kernel

492
00:28:01,040 --> 00:28:08,120
stack the memo oops

493
00:28:03,140 --> 00:28:11,570
has this viader point a function pointer

494
00:28:08,120 --> 00:28:17,030
which points to stack pivoting gadget

495
00:28:11,570 --> 00:28:20,480
and their argument for this function for

496
00:28:17,030 --> 00:28:24,940
viader function comes from vb to buffer

497
00:28:20,480 --> 00:28:28,730
and this address this is address of the

498
00:28:24,940 --> 00:28:34,940
rope chain which is at the kernel stack

499
00:28:28,730 --> 00:28:37,640
as well so final stack is doing the

500
00:28:34,940 --> 00:28:40,250
privilege escalation and it is some kind

501
00:28:37,640 --> 00:28:42,440
of combination of return oriented

502
00:28:40,250 --> 00:28:49,370
programming and jump rating programming

503
00:28:42,440 --> 00:28:52,850
so it is rope and drop that is the the

504
00:28:49,370 --> 00:28:55,489
definition of the function where we do

505
00:28:52,850 --> 00:28:56,929
the control flow hijack the argument on

506
00:28:55,490 --> 00:29:01,250
x86 64

507
00:28:56,930 --> 00:29:05,390
a pass is passed through via RDI

508
00:29:01,250 --> 00:29:07,190
register and this RTI register is under

509
00:29:05,390 --> 00:29:10,100
our control since we control the

510
00:29:07,190 --> 00:29:16,490
argument so there is an excellent gadget

511
00:29:10,100 --> 00:29:21,020
which fits this this requirements push

512
00:29:16,490 --> 00:29:24,230
our di and pop our SP and return so our

513
00:29:21,020 --> 00:29:30,860
controlled argument goes to stack

514
00:29:24,230 --> 00:29:35,300
pointer and then we can execute our rope

515
00:29:30,860 --> 00:29:37,820
chain the this rope chain is executed in

516
00:29:35,300 --> 00:29:40,760
the kernel thread context so it is a bit

517
00:29:37,820 --> 00:29:43,879
unusual usually people just overwrite

518
00:29:40,760 --> 00:29:46,400
the credentials of the user space

519
00:29:43,880 --> 00:29:49,160
process of the exploit but here we don't

520
00:29:46,400 --> 00:29:53,300
have user space that's why I had to do

521
00:29:49,160 --> 00:29:58,730
it another way so that is the rope chain

522
00:29:53,300 --> 00:30:03,740
I will describe it in details first we

523
00:29:58,730 --> 00:30:06,830
pop there are 15 register and the value

524
00:30:03,740 --> 00:30:10,400
which gets to this register is the

525
00:30:06,830 --> 00:30:17,090
address of run command function from

526
00:30:10,400 --> 00:30:20,650
kernel reboot dot C and the argument for

527
00:30:17,090 --> 00:30:24,470
this run command function will be the

528
00:30:20,650 --> 00:30:26,750
name of some shell script so I needed to

529
00:30:24,470 --> 00:30:27,290
past the address of the string as an

530
00:30:26,750 --> 00:30:32,360
argument

531
00:30:27,290 --> 00:30:36,920
so next gadget does pop RDI and the

532
00:30:32,360 --> 00:30:39,199
address of the shell command comes to

533
00:30:36,920 --> 00:30:44,270
our D I register which will be the

534
00:30:39,200 --> 00:30:47,630
argument of run CMD command then I jump

535
00:30:44,270 --> 00:30:51,010
to r15 so ransom D command is executed

536
00:30:47,630 --> 00:30:57,080
and the argument of the comment is the

537
00:30:51,010 --> 00:31:02,210
shell script then after privileges are

538
00:30:57,080 --> 00:31:03,980
escalated I have this do tasks dead

539
00:31:02,210 --> 00:31:06,770
function which is called

540
00:31:03,980 --> 00:31:09,160
the same way I will describe it white as

541
00:31:06,770 --> 00:31:10,460
needed but first I want to show the

542
00:31:09,160 --> 00:31:14,390
shell come

543
00:31:10,460 --> 00:31:16,760
and it simply drops the password for

544
00:31:14,390 --> 00:31:21,980
root so next time after exploit worked

545
00:31:16,760 --> 00:31:26,270
we can log in under root without giving

546
00:31:21,980 --> 00:31:29,420
the password and the last step with this

547
00:31:26,270 --> 00:31:33,530
the last trick with do tasks dead is for

548
00:31:29,420 --> 00:31:36,440
so-called system fixating if I let the

549
00:31:33,530 --> 00:31:38,420
kernel thread work after the privilege

550
00:31:36,440 --> 00:31:41,420
escalation it provokes some another

551
00:31:38,420 --> 00:31:45,320
unnecessary kernel crashes so we need to

552
00:31:41,420 --> 00:31:48,080
keep the system work working that's why

553
00:31:45,320 --> 00:31:51,439
I decided to just kill this kernel

554
00:31:48,080 --> 00:31:54,649
thread and when do task that is

555
00:31:51,440 --> 00:31:58,210
performed in the kernel thread it dies

556
00:31:54,650 --> 00:32:01,820
and we have no crashes systems that

557
00:31:58,210 --> 00:32:14,750
continues to work now

558
00:32:01,820 --> 00:32:18,760
the demo yep Hill here I log in as a

559
00:32:14,750 --> 00:32:23,560
normal user on the right hand side and

560
00:32:18,760 --> 00:32:23,560
show some information about the system

561
00:32:23,710 --> 00:32:32,150
first about the distribution then about

562
00:32:28,790 --> 00:32:40,430
the kernel it is the original Ubuntu

563
00:32:32,150 --> 00:32:43,010
kernel now I show that supervisor mode

564
00:32:40,430 --> 00:32:45,410
access prevention and supervised mode

565
00:32:43,010 --> 00:32:50,710
execution prevention I enabled you can

566
00:32:45,410 --> 00:32:50,710
see it from broke CPU yes

567
00:32:54,440 --> 00:33:00,800
now I show the colonel common line to

568
00:32:57,560 --> 00:33:04,850
show that I didn't disable colonel

569
00:33:00,800 --> 00:33:11,870
vegetable isolation or Colonel address

570
00:33:04,850 --> 00:33:14,090
space layout randomization and now I

571
00:33:11,870 --> 00:33:20,330
show that the vulnerable module is

572
00:33:14,090 --> 00:33:23,780
loaded it has done mainly yeah now I try

573
00:33:20,330 --> 00:33:26,570
to I show that it is a normal user I

574
00:33:23,780 --> 00:33:30,910
tried to login as root and it asks for

575
00:33:26,570 --> 00:33:30,909
the password no way

576
00:33:33,910 --> 00:33:42,430
now let's connect to this virtual

577
00:33:37,550 --> 00:33:42,430
machine via SSH and run the exploit

578
00:33:49,710 --> 00:33:55,050
yeah very fast shell command is run as

579
00:33:52,890 --> 00:33:58,460
root and let's try to log in as root

580
00:33:55,050 --> 00:33:58,460
yeah without password

581
00:34:05,630 --> 00:34:11,930
I also want to say that the exploit

582
00:34:08,929 --> 00:34:16,850
turned out that exploit is really really

583
00:34:11,929 --> 00:34:21,350
stable it all also never fails so I'm

584
00:34:16,850 --> 00:34:23,810
glad now about possible exploit

585
00:34:21,350 --> 00:34:28,909
mitigation very interesting part

586
00:34:23,810 --> 00:34:31,790
first of all recent kernels have this

587
00:34:28,909 --> 00:34:35,359
unprivileged user fault FD setting if we

588
00:34:31,790 --> 00:34:40,550
set it to zero the user fault FD is not

589
00:34:35,360 --> 00:34:44,840
available to unprivileged user so it can

590
00:34:40,550 --> 00:34:46,790
disturb the way how the payload was

591
00:34:44,840 --> 00:34:51,740
placed in the kernel heap and the kernel

592
00:34:46,790 --> 00:34:56,090
stack another mitigation is against the

593
00:34:51,739 --> 00:34:59,000
info leak through the kernel log there

594
00:34:56,090 --> 00:35:03,020
is add mask restrict sis control if we

595
00:34:59,000 --> 00:35:07,010
set it to one we need as I remember caps

596
00:35:03,020 --> 00:35:11,600
is admin capability to read the kernel

597
00:35:07,010 --> 00:35:14,840
log but by the way Ubuntu users regular

598
00:35:11,600 --> 00:35:17,960
users participants of admin group and

599
00:35:14,840 --> 00:35:22,900
they can read a verses log verlox's log

600
00:35:17,960 --> 00:35:29,330
anyway even if the setting is set to 1

601
00:35:22,900 --> 00:35:32,210
next is the feature from Jerry security

602
00:35:29,330 --> 00:35:37,340
an interesting one called Park strand k

603
00:35:32,210 --> 00:35:40,460
stack it Rosen demises the the location

604
00:35:37,340 --> 00:35:43,100
of the kernel stack on every system call

605
00:35:40,460 --> 00:35:46,810
on each system call so that makes the

606
00:35:43,100 --> 00:35:51,259
exploit guess the future position of the

607
00:35:46,810 --> 00:35:57,259
of the payload on the kernel stack next

608
00:35:51,260 --> 00:36:00,140
feature it can break the rope and drop

609
00:35:57,260 --> 00:36:02,300
chain which I used it has Park strap

610
00:36:00,140 --> 00:36:05,420
from Jarrah security as well finally

611
00:36:02,300 --> 00:36:08,330
there is hopefully in future there will

612
00:36:05,420 --> 00:36:12,200
be our memory taking extension support

613
00:36:08,330 --> 00:36:17,180
for the Linux kernel which can kill use

614
00:36:12,200 --> 00:36:18,549
of the free bug class in general now the

615
00:36:17,180 --> 00:36:20,350
conclusion

616
00:36:18,550 --> 00:36:22,480
investigating and fixing this

617
00:36:20,350 --> 00:36:24,339
vulnerability developing the

618
00:36:22,480 --> 00:36:25,960
proof-of-concept exploit and preparing

619
00:36:24,340 --> 00:36:29,140
the stock was a really big deal for me

620
00:36:25,960 --> 00:36:32,860
and I really hope you enjoyed it today I

621
00:36:29,140 --> 00:36:36,100
will publish detailed write-up about the

622
00:36:32,860 --> 00:36:38,370
exploitation that's it thank you very

623
00:36:36,100 --> 00:36:38,370
much

624
00:36:39,450 --> 00:36:45,319
[Applause]

625
00:36:45,960 --> 00:36:53,380
there's so is the warning that you've

626
00:36:50,710 --> 00:36:57,910
used e is it triggered by the same bug

627
00:36:53,380 --> 00:37:04,000
or is it a different bug it is triggered

628
00:36:57,910 --> 00:37:08,049
by situation when we have buffers in a

629
00:37:04,000 --> 00:37:11,619
strange state in the queue of buffers on

630
00:37:08,049 --> 00:37:13,030
stringing stop so it is some generic

631
00:37:11,619 --> 00:37:16,270
warning which can happen in different

632
00:37:13,030 --> 00:37:19,240
situations as well but in that case our

633
00:37:16,270 --> 00:37:22,809
driver just triggered this warning

634
00:37:19,240 --> 00:37:25,029
because it unexpectedly added the buffer

635
00:37:22,809 --> 00:37:27,099
to the queue during the streaming stop

636
00:37:25,030 --> 00:37:30,250
it's still possible to trigger it with

637
00:37:27,099 --> 00:37:33,430
your fixes applied yes yes because this

638
00:37:30,250 --> 00:37:42,549
warning just shows the situation when

639
00:37:33,430 --> 00:37:47,680
the driver behaves bad I want to notice

640
00:37:42,549 --> 00:37:52,569
also there was an announcement by CDI in

641
00:37:47,680 --> 00:37:54,460
autumn as I remember that there was some

642
00:37:52,569 --> 00:37:56,589
vulnerability for video for Linux

643
00:37:54,460 --> 00:37:59,109
subsystem it was used after free as well

644
00:37:56,589 --> 00:38:04,270
it was reported to CDI

645
00:37:59,109 --> 00:38:05,619
and Android systems were affected but it

646
00:38:04,270 --> 00:38:07,509
was reported without the

647
00:38:05,619 --> 00:38:09,400
proof-of-concept exploit I don't know

648
00:38:07,510 --> 00:38:10,869
maybe because of kernel thread

649
00:38:09,400 --> 00:38:13,990
restrictions anyway

650
00:38:10,869 --> 00:38:16,299
the technique which I showed maybe can

651
00:38:13,990 --> 00:38:23,009
be applicable to other bugs in this

652
00:38:16,299 --> 00:38:23,009
subsystem any more questions

653
00:38:25,760 --> 00:38:36,740
doesn't look like it so thank you ah

654
00:38:27,740 --> 00:38:37,279
there's one more thanks for the great

655
00:38:36,740 --> 00:38:39,080
talk

656
00:38:37,280 --> 00:38:42,050
just one question you've mentioned the

657
00:38:39,080 --> 00:38:43,790
the custom z-score implementation or

658
00:38:42,050 --> 00:38:44,450
your customizations could you tell us

659
00:38:43,790 --> 00:38:49,580
more about that

660
00:38:44,450 --> 00:38:52,640
yeah thank you for a question so this

661
00:38:49,580 --> 00:38:56,390
corner III would say fuzzing consists of

662
00:38:52,640 --> 00:39:00,910
two parts the Father itself and the

663
00:38:56,390 --> 00:39:04,339
system which give us so to modify this

664
00:39:00,910 --> 00:39:08,540
your fuzzing you can change both things

665
00:39:04,340 --> 00:39:12,790
and in my case I modified the kernel to

666
00:39:08,540 --> 00:39:16,490
drop all the unnecessary warnings and

667
00:39:12,790 --> 00:39:20,060
information about dead logs lockups and

668
00:39:16,490 --> 00:39:26,149
all of that that allowed the fighting

669
00:39:20,060 --> 00:39:29,570
process go deeper originally fuzzing

670
00:39:26,150 --> 00:39:34,220
would stop on the warning but i disabled

671
00:39:29,570 --> 00:39:36,850
warnings so my fighting hit Dre the use

672
00:39:34,220 --> 00:39:40,640
of the free buck which is exploitable

673
00:39:36,850 --> 00:39:43,339
that's why when I disabled my kernel

674
00:39:40,640 --> 00:39:47,379
changes for deeper fuzzing I saw this

675
00:39:43,340 --> 00:39:47,380
warning and got an idea how to exploit

676
00:39:48,700 --> 00:39:57,230
so then I don't know any more questions

677
00:39:53,620 --> 00:39:57,839
okay then thank you very much for the

678
00:39:57,230 --> 00:40:00,939
talk

679
00:39:57,840 --> 00:40:00,939
[Applause]

