1
00:00:00,000 --> 00:00:03,330
hey everyone welcome to our talk bugs on

2
00:00:02,070 --> 00:00:05,369
the windshield fuzzing the windows

3
00:00:03,330 --> 00:00:07,529
kernel we're really excited to be here

4
00:00:05,370 --> 00:00:09,929
today it's an amazing venue with lots of

5
00:00:07,529 --> 00:00:12,330
great people and we hope you enjoy this

6
00:00:09,929 --> 00:00:15,179
presentation as much as we had doing the

7
00:00:12,330 --> 00:00:16,049
research so a little bit about us my

8
00:00:15,179 --> 00:00:18,150
name is Yahveh lon

9
00:00:16,049 --> 00:00:19,740
I'm the CTO at Orca security and I've

10
00:00:18,150 --> 00:00:22,528
been a security researcher for the past

11
00:00:19,740 --> 00:00:25,169
ten years also recently I was added to

12
00:00:22,529 --> 00:00:27,810
nsrc most valuable security researcher

13
00:00:25,170 --> 00:00:29,580
for 2019 my name is nathaniell Bensimon

14
00:00:27,810 --> 00:00:31,859
I'm a security researcher a checkpoint

15
00:00:29,580 --> 00:00:35,129
research and I'm also in the same list

16
00:00:31,859 --> 00:00:37,230
as you all so our motivation for this

17
00:00:35,130 --> 00:00:39,960
research is that we love fuzzing we

18
00:00:37,230 --> 00:00:41,910
really do but also we had a pretty

19
00:00:39,960 --> 00:00:43,649
successful fuzzing campaign again but

20
00:00:41,910 --> 00:00:44,160
against binary format parsers in

21
00:00:43,649 --> 00:00:46,469
userspace

22
00:00:44,160 --> 00:00:49,879
we found multiple vulnerabilities in

23
00:00:46,469 --> 00:00:52,050
formats such as JPEG GIF EMF wmfc so on

24
00:00:49,879 --> 00:00:54,089
mostly targeting the dhobi reader in

25
00:00:52,050 --> 00:00:55,529
Microsoft edge if you're interesting to

26
00:00:54,090 --> 00:00:57,239
read more about this research you should

27
00:00:55,530 --> 00:00:59,550
check out checkpoint research blog we

28
00:00:57,239 --> 00:01:03,358
have everything about the methodology

29
00:00:59,550 --> 00:01:04,530
and anything else so at this point we

30
00:01:03,359 --> 00:01:06,450
were wrapping up the previous research

31
00:01:04,530 --> 00:01:08,310
and we felt that we wanted a bigger

32
00:01:06,450 --> 00:01:10,500
challenge and fuzzing Windows kernel

33
00:01:08,310 --> 00:01:12,960
seemed hard enough and there's an added

34
00:01:10,500 --> 00:01:14,729
bonus we can take one of our existing

35
00:01:12,960 --> 00:01:16,140
user space vulnerabilities chain them

36
00:01:14,729 --> 00:01:18,500
together with a newly found kernel

37
00:01:16,140 --> 00:01:22,049
vulnerabilities and create a full chain

38
00:01:18,500 --> 00:01:24,259
so a few obligatory slides this since

39
00:01:22,049 --> 00:01:26,880
this is a presentation about fuzzing

40
00:01:24,259 --> 00:01:28,770
fuzzing is a method for automatic I'm

41
00:01:26,880 --> 00:01:30,089
just kidding this is offensive Khan

42
00:01:28,770 --> 00:01:33,449
we're not gonna do introduction to

43
00:01:30,090 --> 00:01:35,759
fuzzing we don't have time for that so

44
00:01:33,450 --> 00:01:36,900
anyway and we were we were at the

45
00:01:35,759 --> 00:01:39,119
beginning of the research and we said to

46
00:01:36,900 --> 00:01:41,520
ourselves we have we have a lot of

47
00:01:39,119 --> 00:01:43,590
experience with AFL can we use AFL to

48
00:01:41,520 --> 00:01:45,149
attack the Windows kernel and the answer

49
00:01:43,590 --> 00:01:47,939
is pretty surprisingly not

50
00:01:45,149 --> 00:01:50,939
unsurprisingly yes there's kfl which is

51
00:01:47,939 --> 00:01:54,570
AFL with ok and K and K stands for

52
00:01:50,939 --> 00:01:56,789
kernel so kfl is a reaches is a research

53
00:01:54,570 --> 00:01:58,919
buzzer from the bottom university and

54
00:01:56,790 --> 00:02:01,649
that leverages AFL style fuzzing for

55
00:01:58,920 --> 00:02:04,860
attacking Windows OS kernels it supports

56
00:02:01,649 --> 00:02:06,930
Windows Linux and Mac OS and it was used

57
00:02:04,860 --> 00:02:09,810
to find real bugs in real software which

58
00:02:06,930 --> 00:02:11,190
is what we want careful is a pretty

59
00:02:09,810 --> 00:02:12,660
interesting architecture we're going to

60
00:02:11,190 --> 00:02:13,530
review it quickly because it's important

61
00:02:12,660 --> 00:02:15,690
for the rest of

62
00:02:13,530 --> 00:02:17,910
presentation the main father runs on the

63
00:02:15,690 --> 00:02:20,970
host and when it starts it will spawn

64
00:02:17,910 --> 00:02:23,010
multiple virtual machines that run that

65
00:02:20,970 --> 00:02:24,750
are running the target the West in the

66
00:02:23,010 --> 00:02:26,549
guest OS there will be a pre-loaded

67
00:02:24,750 --> 00:02:28,230
agent that will cooperate with the

68
00:02:26,550 --> 00:02:28,770
Father to drive the fuzzing process

69
00:02:28,230 --> 00:02:30,899
forward

70
00:02:28,770 --> 00:02:33,930
the fuzzing looks looks something like

71
00:02:30,900 --> 00:02:37,020
this the agent will request an input

72
00:02:33,930 --> 00:02:39,060
from the from the will request any input

73
00:02:37,020 --> 00:02:41,670
from the father and the input will be

74
00:02:39,060 --> 00:02:43,440
transferred from shared memory then the

75
00:02:41,670 --> 00:02:45,299
agent will request from the hypervisor

76
00:02:43,440 --> 00:02:46,980
to record coverage we're going to talk

77
00:02:45,300 --> 00:02:50,519
about exactly how in a moment

78
00:02:46,980 --> 00:02:52,709
next the agent will pass whatever buffer

79
00:02:50,519 --> 00:02:56,130
it got to whatever it it wants to attack

80
00:02:52,709 --> 00:02:58,260
in this case test sis and finally it

81
00:02:56,130 --> 00:03:00,120
will stop coverage it will notify the

82
00:02:58,260 --> 00:03:03,769
hypervisor to stop coverage and the

83
00:03:00,120 --> 00:03:03,769
coverage will be transferred the father

84
00:03:05,090 --> 00:03:10,620
so how does how is kfl able to generate

85
00:03:08,310 --> 00:03:12,269
coverage traces well it uses an Intel

86
00:03:10,620 --> 00:03:15,390
processor trace which is also known as

87
00:03:12,269 --> 00:03:17,700
Indra PT which is a low overhead

88
00:03:15,390 --> 00:03:20,130
Hardware execution tracing feature that

89
00:03:17,700 --> 00:03:22,470
supports ray tracing coverage for each

90
00:03:20,130 --> 00:03:24,030
Hardware friend the trace information is

91
00:03:22,470 --> 00:03:26,760
written in compressed form to physical

92
00:03:24,030 --> 00:03:28,410
memory and kfl uses a fast decoder to

93
00:03:26,760 --> 00:03:32,429
generate full traces from the compressed

94
00:03:28,410 --> 00:03:34,950
form a finally crash detection it's

95
00:03:32,430 --> 00:03:37,200
pretty cool when when the agent is first

96
00:03:34,950 --> 00:03:38,760
loaded it will send the addresses of bug

97
00:03:37,200 --> 00:03:40,708
check and bug check acts to the kernel

98
00:03:38,760 --> 00:03:43,048
and to the hypervisor and the hypervisor

99
00:03:40,709 --> 00:03:45,269
will patch those addresses with a

100
00:03:43,049 --> 00:03:48,209
special shell code that will issue a

101
00:03:45,269 --> 00:03:50,970
hyper call when the system will crash

102
00:03:48,209 --> 00:03:53,250
the patch kernel will call bug chicken

103
00:03:50,970 --> 00:03:55,350
bug check X which will issue the hyper

104
00:03:53,250 --> 00:03:59,340
call which will notify the father about

105
00:03:55,350 --> 00:04:01,620
the crash so let's let's do a quick

106
00:03:59,340 --> 00:04:04,620
recap of how a harness looks like we

107
00:04:01,620 --> 00:04:07,530
start with a hyper call that tells the

108
00:04:04,620 --> 00:04:11,970
hypervisor to to monitor this process

109
00:04:07,530 --> 00:04:14,700
then we assign a buffer to where to

110
00:04:11,970 --> 00:04:17,370
write the the input and then in an

111
00:04:14,700 --> 00:04:20,488
infinite loop we will try we will first

112
00:04:17,370 --> 00:04:22,800
ask for a new payload we will try start

113
00:04:20,488 --> 00:04:25,080
racing coverage pass the buffer to

114
00:04:22,800 --> 00:04:27,389
whatever we want to attack and finally

115
00:04:25,080 --> 00:04:30,030
it tell the the hypervisor

116
00:04:27,389 --> 00:04:31,110
tracing coverage here's a screenshot of

117
00:04:30,030 --> 00:04:32,638
kfl running

118
00:04:31,110 --> 00:04:36,360
if you blink fast enough it kind of

119
00:04:32,639 --> 00:04:38,759
looks like a FL so what can we attack

120
00:04:36,360 --> 00:04:41,669
with k FL or what can we attack with a

121
00:04:38,759 --> 00:04:44,669
FL so from our experience good targets

122
00:04:41,669 --> 00:04:46,289
for K FL and AFL are fast targets ones

123
00:04:44,669 --> 00:04:49,049
that are actually able to execute

124
00:04:46,289 --> 00:04:51,090
hundreds of iterations per second and MA

125
00:04:49,050 --> 00:04:54,569
and parsers specifically for binary

126
00:04:51,090 --> 00:04:56,849
formats so what binary format parsers

127
00:04:54,569 --> 00:04:59,159
live inside the Windows kernel and so

128
00:04:56,849 --> 00:05:00,840
there are quite a few and there are a

129
00:04:59,159 --> 00:05:05,610
file system and file system like formats

130
00:05:00,840 --> 00:05:07,919
like an TF NTFS fat CL FS v HD registry

131
00:05:05,610 --> 00:05:10,740
there are device drivers that parse a

132
00:05:07,919 --> 00:05:14,008
binary format there are the

133
00:05:10,740 --> 00:05:16,710
cryptographic drivers that perspiring

134
00:05:14,009 --> 00:05:20,400
format and there are quite a few others

135
00:05:16,710 --> 00:05:22,349
and so but at this point we took a step

136
00:05:20,400 --> 00:05:24,779
back and we said to ourselves let's look

137
00:05:22,349 --> 00:05:28,050
at a typical kernel bug at this gate cv

138
00:05:24,779 --> 00:05:29,849
2018 zero seven four four if you look at

139
00:05:28,050 --> 00:05:32,580
this you don't have to read it just look

140
00:05:29,849 --> 00:05:34,529
at the structure there are multiple

141
00:05:32,580 --> 00:05:37,219
system codes here the takers input

142
00:05:34,529 --> 00:05:40,469
highly structured data like structs

143
00:05:37,219 --> 00:05:43,830
magic numbers function pointers strings

144
00:05:40,469 --> 00:05:45,779
and flags and they and they have

145
00:05:43,830 --> 00:05:48,628
dependencies between them meaning that

146
00:05:45,779 --> 00:05:50,339
thus the call for the output of one

147
00:05:48,629 --> 00:05:52,020
function is the input for the next

148
00:05:50,339 --> 00:05:54,900
function and this is pretty common in

149
00:05:52,020 --> 00:05:57,930
kernel bugs that there is a sequence of

150
00:05:54,900 --> 00:05:59,878
calls that put the system in a state

151
00:05:57,930 --> 00:06:02,009
where vulnerability is triggered but

152
00:05:59,879 --> 00:06:04,229
notice that there are no binary parsers

153
00:06:02,009 --> 00:06:06,419
here and these are the kind of bugs we

154
00:06:04,229 --> 00:06:10,020
want to find with Varia within this

155
00:06:06,419 --> 00:06:12,628
research so if we take a step back and

156
00:06:10,020 --> 00:06:15,060
unfortunately what kfl provides us is a

157
00:06:12,629 --> 00:06:17,039
binary blob at now what we want is a

158
00:06:15,060 --> 00:06:20,069
sequence of syscalls that semantically

159
00:06:17,039 --> 00:06:21,839
makes sense preferably as a C file so

160
00:06:20,069 --> 00:06:24,330
and if we look back at the attack

161
00:06:21,839 --> 00:06:27,419
surface again and with that we had with

162
00:06:24,330 --> 00:06:30,029
binary parsers and we go back and look

163
00:06:27,419 --> 00:06:32,099
what is called furnace fuzzer it can can

164
00:06:30,029 --> 00:06:34,620
give us we can see that then now the map

165
00:06:32,099 --> 00:06:36,270
is much much better we can attack much

166
00:06:34,620 --> 00:06:37,550
more of the kernel and that's that's

167
00:06:36,270 --> 00:06:40,349
good for us as attackers

168
00:06:37,550 --> 00:06:41,190
so we decided to dump kfl and move to a

169
00:06:40,349 --> 00:06:42,960
Cisco for

170
00:06:41,190 --> 00:06:46,440
and we did what every good researcher

171
00:06:42,960 --> 00:06:49,950
does and we use Google to search for a

172
00:06:46,440 --> 00:06:54,990
Cisco father and that's how we found a

173
00:06:49,950 --> 00:06:58,460
scholar hey I'm gonna need an L will now

174
00:06:54,990 --> 00:06:58,460
come and tell you all about this color

175
00:07:02,180 --> 00:07:07,020
this color is coverage guarded structure

176
00:07:05,010 --> 00:07:09,659
where kind of father try saying these

177
00:07:07,020 --> 00:07:12,900
five times in a row it's also known as

178
00:07:09,660 --> 00:07:15,840
smart Cisco father it supports multiple

179
00:07:12,900 --> 00:07:18,390
operating systems such as Linux FreeBSD

180
00:07:15,840 --> 00:07:19,859
folks here are joined and more it

181
00:07:18,390 --> 00:07:22,469
supports running on multiple machine

182
00:07:19,860 --> 00:07:24,660
types such as QM you guessed Google

183
00:07:22,470 --> 00:07:27,660
Cloud engine instances mobile phones and

184
00:07:24,660 --> 00:07:30,980
others it's also supports running on

185
00:07:27,660 --> 00:07:36,000
multiple architectures like eggs x86 64

186
00:07:30,980 --> 00:07:37,800
64-bit arms and others this color is

187
00:07:36,000 --> 00:07:39,720
also known in some in some circles as

188
00:07:37,800 --> 00:07:43,290
the hardest-working researcher in the

189
00:07:39,720 --> 00:07:46,080
Linux kernel community to date it is

190
00:07:43,290 --> 00:07:50,010
found around 3700 bugs in the Linux

191
00:07:46,080 --> 00:07:52,590
kernel one example is CB 2019 to two one

192
00:07:50,010 --> 00:07:54,330
five which may be presented earlier the

193
00:07:52,590 --> 00:07:57,900
use of the frame binder which was found

194
00:07:54,330 --> 00:07:59,880
being exploited in the wild as you can

195
00:07:57,900 --> 00:08:01,770
see in the screenshot from sis bot sis

196
00:07:59,880 --> 00:08:07,950
course online dashboard it was found to

197
00:08:01,770 --> 00:08:10,799
use by Cisco modern fascists have few

198
00:08:07,950 --> 00:08:14,099
common characteristics we have a smart

199
00:08:10,800 --> 00:08:16,110
test case generator Mutato they use a

200
00:08:14,100 --> 00:08:17,850
feedback mechanism usually a code

201
00:08:16,110 --> 00:08:20,940
coverage for to drive the following

202
00:08:17,850 --> 00:08:25,500
process and the employee sophisticated

203
00:08:20,940 --> 00:08:27,390
bug Oracle's for detecting crashes let's

204
00:08:25,500 --> 00:08:29,610
see how this caller answer this criteria

205
00:08:27,390 --> 00:08:33,960
starting with test case generator and

206
00:08:29,610 --> 00:08:37,169
material this caller generates programs

207
00:08:33,960 --> 00:08:38,430
which are a sequence of Cisco's let's

208
00:08:37,169 --> 00:08:41,728
look at an example of a program

209
00:08:38,429 --> 00:08:44,339
generated by sis color this program

210
00:08:41,729 --> 00:08:47,850
opens a file called file 0 and a

211
00:08:44,340 --> 00:08:49,530
scientist result to R 0 this weirdo

212
00:08:47,850 --> 00:08:51,780
pointer assignment syntax our

213
00:08:49,530 --> 00:08:53,970
instructions to write the string file 0

214
00:08:51,780 --> 00:08:54,630
to memory and pass this pointer to the

215
00:08:53,970 --> 00:08:57,540
open

216
00:08:54,630 --> 00:09:00,330
to the open sea school this syntax is

217
00:08:57,540 --> 00:09:02,010
not only used for Strings but also for

218
00:09:00,330 --> 00:09:06,810
describing memory layers of structs

219
00:09:02,010 --> 00:09:09,210
buffers unions and others next the

220
00:09:06,810 --> 00:09:14,030
program reads 57 bytes from the file to

221
00:09:09,210 --> 00:09:16,920
memory and finally it closes the file

222
00:09:14,030 --> 00:09:19,709
but how does this color but how is his

223
00:09:16,920 --> 00:09:21,839
color able to generate programs well it

224
00:09:19,710 --> 00:09:24,030
uses his call descriptions syscall

225
00:09:21,840 --> 00:09:25,950
descriptions are how you as a researcher

226
00:09:24,030 --> 00:09:28,680
defined to Cisco learn how to generate

227
00:09:25,950 --> 00:09:32,070
Cisco's it's basically the recipe is

228
00:09:28,680 --> 00:09:34,439
used by Cisco to bake programs let's

229
00:09:32,070 --> 00:09:37,080
look at a simple description for example

230
00:09:34,440 --> 00:09:38,910
the Cisco exit which has only which has

231
00:09:37,080 --> 00:09:42,000
only one parameter the airport which is

232
00:09:38,910 --> 00:09:44,850
an int notice that this color uses a go

233
00:09:42,000 --> 00:09:48,870
lights in disk syntax where the type

234
00:09:44,850 --> 00:09:50,990
comes after the argument name a more

235
00:09:48,870 --> 00:09:53,850
complicated example is the closest Co

236
00:09:50,990 --> 00:09:56,640
which receives a file skipper descriptor

237
00:09:53,850 --> 00:09:58,830
which is technically an int however we

238
00:09:56,640 --> 00:10:01,050
know that file descriptors are a handle

239
00:09:58,830 --> 00:10:02,520
to kernel results meaning that random

240
00:10:01,050 --> 00:10:05,219
numbers will just be rejected by the

241
00:10:02,520 --> 00:10:07,710
kernel that's why sis color has the

242
00:10:05,220 --> 00:10:10,320
concept of resource which is the type

243
00:10:07,710 --> 00:10:12,740
that it cannot generate by itself but he

244
00:10:10,320 --> 00:10:16,290
tends to use other Cisco's to obtain it

245
00:10:12,740 --> 00:10:20,220
an example of Cisco dot which returns a

246
00:10:16,290 --> 00:10:23,599
file descriptor is the open Cisco Cisco

247
00:10:20,220 --> 00:10:26,970
also supports flags structs unions and

248
00:10:23,600 --> 00:10:30,510
others in the case of open it knows that

249
00:10:26,970 --> 00:10:33,750
open mode is a flag which means it can

250
00:10:30,510 --> 00:10:36,480
use one or more flags together last

251
00:10:33,750 --> 00:10:38,460
example is the richest code the cisco

252
00:10:36,480 --> 00:10:40,560
receives buffer is an input which it to

253
00:10:38,460 --> 00:10:43,050
iraq which it will write up to length by

254
00:10:40,560 --> 00:10:44,760
two it noticed that length and buffer

255
00:10:43,050 --> 00:10:47,069
have a semantic relationship meaning

256
00:10:44,760 --> 00:10:48,750
that the length should not be bigger

257
00:10:47,070 --> 00:10:53,790
than the buffer otherwise it will

258
00:10:48,750 --> 00:10:56,790
probably fail cisco descriptions are

259
00:10:53,790 --> 00:10:59,790
written two text files since season

260
00:10:56,790 --> 00:11:01,740
which is cisco ler tool will take the

261
00:10:59,790 --> 00:11:04,140
cisco descriptions and automatically

262
00:11:01,740 --> 00:11:08,040
generate go code that will be compiled

263
00:11:04,140 --> 00:11:09,990
into sis father this father will then

264
00:11:08,040 --> 00:11:12,389
the Siskel description to generate

265
00:11:09,990 --> 00:11:14,100
programs by randomly selecting Cisco's

266
00:11:12,389 --> 00:11:17,490
and making sure to satisfy their

267
00:11:14,100 --> 00:11:20,550
dependencies since caller is also able

268
00:11:17,490 --> 00:11:24,060
to mutate mutate existing programs with

269
00:11:20,550 --> 00:11:27,269
a few mutation strategies insert call

270
00:11:24,060 --> 00:11:28,709
will insert the call making sure to have

271
00:11:27,269 --> 00:11:32,279
all required dependencies to

272
00:11:28,709 --> 00:11:35,099
successfully call the cisco mutate arc

273
00:11:32,279 --> 00:11:40,259
will mutate an argument according to its

274
00:11:35,100 --> 00:11:47,579
type splice will take two random

275
00:11:40,259 --> 00:11:49,889
programs and join them and squash and

276
00:11:47,579 --> 00:11:52,079
Eve will perform a first-time mutations

277
00:11:49,889 --> 00:11:55,769
on complex pointers such as structs

278
00:11:52,079 --> 00:11:57,839
buffers unions and others so clearly

279
00:11:55,769 --> 00:12:00,029
this caller has a sophisticated

280
00:11:57,839 --> 00:12:04,490
sophisticated test case generator and

281
00:12:00,029 --> 00:12:06,600
mutator moving on to feedback mechanism

282
00:12:04,490 --> 00:12:08,639
now that we know how this caller

283
00:12:06,600 --> 00:12:12,240
generates programs let's look at the big

284
00:12:08,639 --> 00:12:15,360
picture the main binary for seed color

285
00:12:12,240 --> 00:12:17,550
is season manager when it starts season

286
00:12:15,360 --> 00:12:19,980
manager will do the following it will

287
00:12:17,550 --> 00:12:22,769
all the copies of programs then it will

288
00:12:19,980 --> 00:12:25,079
start the target machines it will copy

289
00:12:22,769 --> 00:12:27,630
the father and the executor binaries to

290
00:12:25,079 --> 00:12:30,899
the machine using SSH and execute the

291
00:12:27,630 --> 00:12:32,760
father at this point since father will

292
00:12:30,899 --> 00:12:37,500
establish connection with C's manager

293
00:12:32,760 --> 00:12:39,480
and start communicating by RPC this

294
00:12:37,500 --> 00:12:42,779
father will then fetch the corpus and

295
00:12:39,480 --> 00:12:44,370
start generating programs for each

296
00:12:42,779 --> 00:12:46,290
program it will send it back to the

297
00:12:44,370 --> 00:12:49,410
manager for safekeeping in case of a

298
00:12:46,290 --> 00:12:51,930
crash when his father will send it to

299
00:12:49,410 --> 00:12:55,230
the executor which will run the syscalls

300
00:12:51,930 --> 00:12:57,209
and collect coverage from the colonel we

301
00:12:55,230 --> 00:13:01,290
will talk in a moment about Linux kernel

302
00:12:57,209 --> 00:13:03,089
coverage how it's done using cable then

303
00:13:01,290 --> 00:13:05,759
since executors will send back the

304
00:13:03,089 --> 00:13:07,410
coverage to to the father which will

305
00:13:05,759 --> 00:13:12,269
notify the manager in case of a new

306
00:13:07,410 --> 00:13:14,579
coverage Linux kernel coverage is done

307
00:13:12,269 --> 00:13:17,370
using K curve which is a compile time

308
00:13:14,579 --> 00:13:20,589
tracing feature it uses the coverage

309
00:13:17,370 --> 00:13:23,620
sanitizer F sanitized crispy cigar

310
00:13:20,590 --> 00:13:26,710
for example we can see that Colonel funk

311
00:13:23,620 --> 00:13:28,720
has few possible code paths we would

312
00:13:26,710 --> 00:13:31,990
like to know for each path if it was

313
00:13:28,720 --> 00:13:34,150
visitor in order to do this the compiler

314
00:13:31,990 --> 00:13:36,430
would add an instrumentation to each

315
00:13:34,150 --> 00:13:38,680
basic block which will call a callback

316
00:13:36,430 --> 00:13:44,079
function that saves the instruction

317
00:13:38,680 --> 00:13:46,689
pointer to a pair of red buffer coverage

318
00:13:44,080 --> 00:13:49,210
collection user space is like really

319
00:13:46,690 --> 00:13:51,850
easy you generally assume there is only

320
00:13:49,210 --> 00:13:54,670
one one thread and everything is

321
00:13:51,850 --> 00:13:57,250
deterministic and fun in kernel space

322
00:13:54,670 --> 00:14:02,050
however garbage collection quickly hits

323
00:13:57,250 --> 00:14:06,310
a few roadblocks interrupts will appear

324
00:14:02,050 --> 00:14:08,529
and randomly appear in random name

325
00:14:06,310 --> 00:14:11,369
distress there are background threads

326
00:14:08,529 --> 00:14:13,960
that are used to process some Siskel's

327
00:14:11,370 --> 00:14:16,720
there is a general non determinism from

328
00:14:13,960 --> 00:14:19,480
interaction with hardware and flex

329
00:14:16,720 --> 00:14:24,010
caused by scheduler or a locator

330
00:14:19,480 --> 00:14:26,050
behavior to handle coverage flags sis

331
00:14:24,010 --> 00:14:28,750
caller employs a mitigation technique a

332
00:14:26,050 --> 00:14:31,150
coverage mitigation technique first it

333
00:14:28,750 --> 00:14:35,260
defines two types of coverage the

334
00:14:31,150 --> 00:14:37,360
minimum coverage which is which is it

335
00:14:35,260 --> 00:14:39,189
contained within which is the coverage

336
00:14:37,360 --> 00:14:41,500
stress that is contained within the

337
00:14:39,190 --> 00:14:44,290
minimum coverage and the maximum

338
00:14:41,500 --> 00:14:48,970
coverage which is all the coverage that

339
00:14:44,290 --> 00:14:50,770
we ever encountered if a program if a

340
00:14:48,970 --> 00:14:53,140
program coverage stress is contained

341
00:14:50,770 --> 00:14:56,860
within the minimum coverage then we will

342
00:14:53,140 --> 00:14:58,839
discard it but if so scholar detects a

343
00:14:56,860 --> 00:15:01,210
new coverage which is not contained in

344
00:14:58,839 --> 00:15:03,880
the minimum coverage it will run the

345
00:15:01,210 --> 00:15:05,650
program three times and will only use

346
00:15:03,880 --> 00:15:08,620
the crabbit what was consistent between

347
00:15:05,650 --> 00:15:10,329
all the three runs so it will add the

348
00:15:08,620 --> 00:15:12,190
deterministic coverage to the minimum

349
00:15:10,330 --> 00:15:15,750
coverage and the non deterministic

350
00:15:12,190 --> 00:15:18,360
coverage to the maximum coverage

351
00:15:15,750 --> 00:15:23,709
coverage feedback mechanism check

352
00:15:18,360 --> 00:15:26,380
finally bug or occur in case of a crash

353
00:15:23,709 --> 00:15:29,530
Linux kernel will panic and print crash

354
00:15:26,380 --> 00:15:31,570
information into the console since

355
00:15:29,530 --> 00:15:33,730
manager will detect the panic message

356
00:15:31,570 --> 00:15:36,309
and report on a crash

357
00:15:33,730 --> 00:15:39,160
this color is usually used with caisson

358
00:15:36,309 --> 00:15:41,290
and optionally with Katie Sun came sand

359
00:15:39,160 --> 00:15:43,839
and other sands which greatly improves

360
00:15:41,290 --> 00:15:51,579
his colors ability to find buggy

361
00:15:43,839 --> 00:15:54,399
conditions bug Oracle check Cisco Lorenz

362
00:15:51,579 --> 00:15:56,229
to be unsupervised meaning it will try

363
00:15:54,399 --> 00:15:59,169
to automate the entire fuzzing process

364
00:15:56,230 --> 00:15:59,799
in an ideal world fathers are just plug

365
00:15:59,169 --> 00:16:01,749
and play

366
00:15:59,799 --> 00:16:04,389
but like Charlie Miller used to say

367
00:16:01,749 --> 00:16:07,509
working with fathers is like babysitting

368
00:16:04,389 --> 00:16:10,029
an army of monkeys in the case of

369
00:16:07,509 --> 00:16:13,059
crushes since manager would spawn

370
00:16:10,029 --> 00:16:15,069
multiple reproducer machine in the

371
00:16:13,059 --> 00:16:16,509
process of reproduction this caller will

372
00:16:15,069 --> 00:16:19,299
dissect the crushing program from its

373
00:16:16,509 --> 00:16:21,220
lot and will minimize them and will

374
00:16:19,299 --> 00:16:23,079
minimize them when the process is

375
00:16:21,220 --> 00:16:24,819
finished most of the time it will

376
00:16:23,079 --> 00:16:26,979
reproduce either assist program like

377
00:16:24,819 --> 00:16:29,858
we've seen earlier or a C code which

378
00:16:26,980 --> 00:16:35,889
reproduces the crush so2wakeup

379
00:16:29,859 --> 00:16:39,489
sis color is awesome but sis color is

380
00:16:35,889 --> 00:16:42,009
for Linux so actually before this

381
00:16:39,489 --> 00:16:44,859
presentation we talked with Demetria

382
00:16:42,009 --> 00:16:47,379
Cove which is the father of Cisco and it

383
00:16:44,859 --> 00:16:49,209
corrected us that this color is not only

384
00:16:47,379 --> 00:16:52,059
for Linux but supports other operating

385
00:16:49,209 --> 00:16:54,849
systems as well so when we mean sis

386
00:16:52,059 --> 00:16:56,559
coder is for Linux when we say this

387
00:16:54,850 --> 00:16:59,949
color is for nukes we actually mean sis

388
00:16:56,559 --> 00:17:02,829
color is also for Linux but we want to

389
00:16:59,949 --> 00:17:04,709
fast windows so let's run Linux on

390
00:17:02,829 --> 00:17:08,948
Windows

391
00:17:04,709 --> 00:17:10,720
what is double yourself w cell is a

392
00:17:08,949 --> 00:17:13,120
compatibility layer from running Linux

393
00:17:10,720 --> 00:17:14,769
binaries natively on Windows it

394
00:17:13,119 --> 00:17:18,668
translates between the Linux is cost

395
00:17:14,769 --> 00:17:20,740
windows system course allows to

396
00:17:18,669 --> 00:17:23,079
interrupt Linux and Windows binaries for

397
00:17:20,740 --> 00:17:24,659
example we can run task list from bash

398
00:17:23,079 --> 00:17:27,428
and count the number of lines

399
00:17:24,659 --> 00:17:30,880
it required s resources when running a

400
00:17:27,429 --> 00:17:32,529
full virtual machine and finally it was

401
00:17:30,880 --> 00:17:35,799
designed to bring developers back to

402
00:17:32,529 --> 00:17:39,909
Windows I mean to run bash and called in

403
00:17:35,799 --> 00:17:43,059
excrement for developers so that's it

404
00:17:39,909 --> 00:17:45,460
how does it work starting from Windows

405
00:17:43,059 --> 00:17:47,500
10 there is a new type of lightweight

406
00:17:45,460 --> 00:17:49,539
process called Pico process

407
00:17:47,500 --> 00:17:52,059
when I pick up process issues a Cisco

408
00:17:49,539 --> 00:17:54,158
which will pass from the antique from

409
00:17:52,059 --> 00:17:57,309
the antique Colonel to dedicated driver

410
00:17:54,159 --> 00:17:59,650
called keiko provider in the case of

411
00:17:57,309 --> 00:18:02,200
double yourself the picker processes are

412
00:17:59,650 --> 00:18:05,140
Linux binaries and the picker provider

413
00:18:02,200 --> 00:18:10,360
lxs in the lexcorp will translate the

414
00:18:05,140 --> 00:18:12,549
see Linux Cisco's to anti system goes so

415
00:18:10,360 --> 00:18:15,219
at this point we decided to start with W

416
00:18:12,549 --> 00:18:17,889
cell because fighting W cell is very

417
00:18:15,220 --> 00:18:19,360
similar to fuzzing the Linux kernel so

418
00:18:17,890 --> 00:18:23,440
we can reuse most of the existing

419
00:18:19,360 --> 00:18:27,939
grammar and the binaries it is

420
00:18:23,440 --> 00:18:29,860
relatively new it has to be a big attack

421
00:18:27,940 --> 00:18:32,730
surface to drivers which are I want one

422
00:18:29,860 --> 00:18:36,010
megabyte encode we've little CVS and

423
00:18:32,730 --> 00:18:38,860
finally we wanted to find bugs for full

424
00:18:36,010 --> 00:18:40,990
chain but also but we also wanted to get

425
00:18:38,860 --> 00:18:43,479
some experience fuzzing with sis caller

426
00:18:40,990 --> 00:18:45,960
on Windows so it looked like a good

427
00:18:43,480 --> 00:18:45,960
first step

428
00:18:46,620 --> 00:18:51,129
looking at Cisco architecture we need

429
00:18:49,030 --> 00:18:54,399
the few things to change to fast double

430
00:18:51,130 --> 00:18:58,240
yourself we need an SSH server which is

431
00:18:54,400 --> 00:18:59,710
easy we have a Linux distro for that we

432
00:18:58,240 --> 00:19:03,250
need to find a way to collect coverage

433
00:18:59,710 --> 00:19:07,350
and finally we need a mechanism for

434
00:19:03,250 --> 00:19:07,350
crash detection and crash deduplication

435
00:19:07,919 --> 00:19:15,010
how to get racing coverage windows this

436
00:19:12,010 --> 00:19:16,539
close was compiled binary meaning that

437
00:19:15,010 --> 00:19:19,480
we can't use a compile time tracing

438
00:19:16,539 --> 00:19:22,360
feature a lock K curve so we fought a

439
00:19:19,480 --> 00:19:24,909
few alternatives the first option was

440
00:19:22,360 --> 00:19:28,000
using an emulator like box of hue and

441
00:19:24,909 --> 00:19:29,950
adding coverage instrumentation the

442
00:19:28,000 --> 00:19:32,530
second option was using static binary

443
00:19:29,950 --> 00:19:35,470
instrumentation for coverage like PFF

444
00:19:32,530 --> 00:19:39,730
another option was using a hypervisor

445
00:19:35,470 --> 00:19:42,789
with sampling coverage like a popper but

446
00:19:39,730 --> 00:19:48,700
at the end we settled on using int opt

447
00:19:42,789 --> 00:19:52,150
for coverage for coverage like k FL what

448
00:19:48,700 --> 00:19:55,120
we did was to add patches to k vm to

449
00:19:52,150 --> 00:19:57,429
support coverage with interpreting so we

450
00:19:55,120 --> 00:20:00,489
used large parts of k FL k vm patches

451
00:19:57,429 --> 00:20:01,360
for death in addition we exposed the

452
00:20:00,490 --> 00:20:04,120
executor

453
00:20:01,360 --> 00:20:06,790
like interface so now when the executors

454
00:20:04,120 --> 00:20:09,459
tries to start stop or collect coverage

455
00:20:06,790 --> 00:20:14,379
it will communicate with the KVM instead

456
00:20:09,460 --> 00:20:15,670
of the colonel we also support X for

457
00:20:14,380 --> 00:20:18,130
exporting coverage in dino Morea

458
00:20:15,670 --> 00:20:21,010
coverage format also known as the Arco

459
00:20:18,130 --> 00:20:22,570
format and we use the iodine the awesome

460
00:20:21,010 --> 00:20:27,010
night house plugin to visualize the

461
00:20:22,570 --> 00:20:28,389
coverage here's an example of how the

462
00:20:27,010 --> 00:20:30,400
light house visual at the coverage by

463
00:20:28,390 --> 00:20:34,540
adding colors to the executed basic

464
00:20:30,400 --> 00:20:36,549
blocks as for ba-gawk-oh we used the

465
00:20:34,540 --> 00:20:38,830
same technique as in kfl in case you

466
00:20:36,549 --> 00:20:40,540
already forgotten weed patch bug chicken

467
00:20:38,830 --> 00:20:43,689
bug check X with a shell code that

468
00:20:40,540 --> 00:20:45,428
issues a hyper call on a crash we also

469
00:20:43,690 --> 00:20:49,480
added a red X to identify crashes from

470
00:20:45,429 --> 00:20:52,030
qmu output and finally we enabled driver

471
00:20:49,480 --> 00:20:54,970
verifier with special pools for Alex

472
00:20:52,030 --> 00:20:59,950
Cole and Alexis s to detect to catch

473
00:20:54,970 --> 00:21:01,780
pool corruptions a common issue with

474
00:20:59,950 --> 00:21:04,330
fathers is that they encountered the

475
00:21:01,780 --> 00:21:06,879
same bug many times when the father

476
00:21:04,330 --> 00:21:08,860
finds a new crash we want our father our

477
00:21:06,880 --> 00:21:12,160
father to automatically determine

478
00:21:08,860 --> 00:21:15,209
whether this is a unique crash or is it

479
00:21:12,160 --> 00:21:18,100
duplicate in order to decide is this

480
00:21:15,210 --> 00:21:23,200
color requires a unique output for each

481
00:21:18,100 --> 00:21:25,570
crash our approach for duplicate crash

482
00:21:23,200 --> 00:21:27,940
deduplication could be categorized as

483
00:21:25,570 --> 00:21:32,020
yellow because you know you only live

484
00:21:27,940 --> 00:21:34,390
once we use qmu to read question thread

485
00:21:32,020 --> 00:21:37,059
stack and search for all the addresses

486
00:21:34,390 --> 00:21:41,470
that lie within the traced module in our

487
00:21:37,059 --> 00:21:43,899
case alex courses and we output the

488
00:21:41,470 --> 00:21:48,000
first few offsets in the module that

489
00:21:43,900 --> 00:21:48,000
which was it looks something like this

490
00:21:48,570 --> 00:21:55,780
so a quick recap we had an ssh server

491
00:21:52,740 --> 00:22:01,240
cover check crash detection and

492
00:21:55,780 --> 00:22:04,240
symbolize our check so before fuzzing we

493
00:22:01,240 --> 00:22:06,910
started with a sanity check but we

494
00:22:04,240 --> 00:22:09,190
didn't have a double yourself bug so we

495
00:22:06,910 --> 00:22:12,880
used KVM to patch alex core kernel code

496
00:22:09,190 --> 00:22:14,740
in order to emulate the bird the father

497
00:22:12,880 --> 00:22:15,290
was able to find injected bug within

498
00:22:14,740 --> 00:22:18,170
minutes

499
00:22:15,290 --> 00:22:19,220
so we felt like we were like we were

500
00:22:18,170 --> 00:22:21,350
ready to run the Father

501
00:22:19,220 --> 00:22:24,050
so we started fuzzing double yourself

502
00:22:21,350 --> 00:22:28,219
and then it rained bugs

503
00:22:24,050 --> 00:22:30,110
well not really a short time after we

504
00:22:28,220 --> 00:22:31,910
started the Father we noticed the crash

505
00:22:30,110 --> 00:22:37,370
with critical structure co-option and we

506
00:22:31,910 --> 00:22:40,160
were like what the fast quick quick go

507
00:22:37,370 --> 00:22:42,770
going showed that it's purge guard so

508
00:22:40,160 --> 00:22:45,860
why did patch guard came to our life to

509
00:22:42,770 --> 00:22:48,860
crash our machines so let's return to

510
00:22:45,860 --> 00:22:51,620
how we detect crashes so if you remember

511
00:22:48,860 --> 00:22:55,250
that in order to detect crashes we edit

512
00:22:51,620 --> 00:23:02,330
a patch to Antos so good news everyone

513
00:22:55,250 --> 00:23:04,730
edge guard is working we first try to

514
00:23:02,330 --> 00:23:07,970
enable kernel debugging but that caused

515
00:23:04,730 --> 00:23:09,410
random hangs in our guest what we

516
00:23:07,970 --> 00:23:12,080
eventually did was to write a small

517
00:23:09,410 --> 00:23:13,700
driver called panic reporter which will

518
00:23:12,080 --> 00:23:15,980
register with entrance a bug check

519
00:23:13,700 --> 00:23:19,420
Colbeck using k register back to call

520
00:23:15,980 --> 00:23:22,100
back when so now when the kernel crashes

521
00:23:19,420 --> 00:23:23,990
enters will call panic reporter which

522
00:23:22,100 --> 00:23:28,879
will issue a hyper call notifying on a

523
00:23:23,990 --> 00:23:30,440
crash we're in the father a game and we

524
00:23:28,880 --> 00:23:33,560
got a new crush with different error

525
00:23:30,440 --> 00:23:36,560
code unfortunately for us the crash did

526
00:23:33,560 --> 00:23:38,960
not reproduce we spent hours reproducing

527
00:23:36,560 --> 00:23:40,909
in the back but with causing a bug from

528
00:23:38,960 --> 00:23:44,300
offsets and random junk of the stack

529
00:23:40,910 --> 00:23:47,830
proved really difficult so clearly our

530
00:23:44,300 --> 00:23:50,780
first symbolized attempt didn't go well

531
00:23:47,830 --> 00:23:52,580
at this point we said let's use the

532
00:23:50,780 --> 00:23:55,510
debugger to capture crash information

533
00:23:52,580 --> 00:23:58,370
and used that for D 2 application

534
00:23:55,510 --> 00:24:01,040
unfortunately running KD on Linux

535
00:23:58,370 --> 00:24:02,419
machine was not stable and very slow it

536
00:24:01,040 --> 00:24:05,300
took us to several minutes to get the

537
00:24:02,420 --> 00:24:10,730
crash now so we opted to use the Windows

538
00:24:05,300 --> 00:24:12,350
machine for running the debuggers we set

539
00:24:10,730 --> 00:24:15,230
up the windows guest with a network

540
00:24:12,350 --> 00:24:17,270
kernel debugger enabled we built a small

541
00:24:15,230 --> 00:24:19,640
go UDP server that would that would

542
00:24:17,270 --> 00:24:22,430
listen for connections from guest and

543
00:24:19,640 --> 00:24:25,520
connect them with to the debugger with

544
00:24:22,430 --> 00:24:27,320
scripts to create the crash now this

545
00:24:25,520 --> 00:24:29,180
entire setup is hosted on a Windows

546
00:24:27,320 --> 00:24:33,260
machine where KD and symbols

547
00:24:29,180 --> 00:24:36,980
are working that worked well but for

548
00:24:33,260 --> 00:24:39,560
like my minutes but when we scaled it up

549
00:24:36,980 --> 00:24:41,480
the connection with a debugger would

550
00:24:39,560 --> 00:24:44,950
sometimes be cut off and not recover

551
00:24:41,480 --> 00:24:47,510
this would cause a gas machine to hang

552
00:24:44,950 --> 00:24:49,820
in addition in the process of

553
00:24:47,510 --> 00:24:52,010
reproduction sis caller attempts to

554
00:24:49,820 --> 00:24:55,310
minimize the crushing programs as much

555
00:24:52,010 --> 00:24:58,129
as possible meaning it will crush the

556
00:24:55,310 --> 00:24:59,960
Machine multiple times and wait to for

557
00:24:58,130 --> 00:25:03,890
the crash logs to see if it's the same

558
00:24:59,960 --> 00:25:06,440
crash so now creating crush dump was a

559
00:25:03,890 --> 00:25:11,300
bottleneck for for the filing process so

560
00:25:06,440 --> 00:25:13,850
we realized we need a better solution we

561
00:25:11,300 --> 00:25:16,730
took a step back and asked ourselves how

562
00:25:13,850 --> 00:25:19,340
our KD and win debug are able to

563
00:25:16,730 --> 00:25:22,550
generate programs to generate a call

564
00:25:19,340 --> 00:25:25,699
stack sorry the answer is the use dbg

565
00:25:22,550 --> 00:25:27,950
hub dll it contains a function called

566
00:25:25,700 --> 00:25:30,380
stack walk which will iteratively

567
00:25:27,950 --> 00:25:34,400
walk-walk the stack and restore the

568
00:25:30,380 --> 00:25:35,990
context record for the relevant frame we

569
00:25:34,400 --> 00:25:38,510
could use it to produce a full contact

570
00:25:35,990 --> 00:25:41,240
and symbolize and symbolize it using sim

571
00:25:38,510 --> 00:25:43,460
from address function to use it we had

572
00:25:41,240 --> 00:25:46,840
the good we had to get a few things

573
00:25:43,460 --> 00:25:49,100
the the stack frame CPU contacts and

574
00:25:46,840 --> 00:25:54,530
implement a function that reads a gas

575
00:25:49,100 --> 00:25:56,540
the gas memory the final the final

576
00:25:54,530 --> 00:25:56,899
symbol as your architecture is really

577
00:25:56,540 --> 00:26:00,770
awkward

578
00:25:56,900 --> 00:26:02,840
but it works as follows on the Windows

579
00:26:00,770 --> 00:26:06,889
machine we run a server process that

580
00:26:02,840 --> 00:26:09,709
exposes a stack walk like API when the

581
00:26:06,890 --> 00:26:12,200
test machine crashes um you reach the

582
00:26:09,710 --> 00:26:15,320
stack the module addresses and the

583
00:26:12,200 --> 00:26:18,440
registers using KVM and sends it to the

584
00:26:15,320 --> 00:26:19,879
symbolized the symbolize er then call a

585
00:26:18,440 --> 00:26:22,670
stack walk with all the relevant

586
00:26:19,880 --> 00:26:24,860
arguments dot and retrieves a call stack

587
00:26:22,670 --> 00:26:28,430
which will it which will it send back to

588
00:26:24,860 --> 00:26:32,659
the qmu this architecture was heavily

589
00:26:28,430 --> 00:26:35,420
inspired back by box pong for Windows so

590
00:26:32,660 --> 00:26:38,330
after a lot of agony we got from these

591
00:26:35,420 --> 00:26:42,880
random numbers to this beautiful call

592
00:26:38,330 --> 00:26:42,879
stack look at those pretty symbols

593
00:26:44,389 --> 00:26:49,379
we don't like running Windows machine

594
00:26:46,649 --> 00:26:51,658
alongside our Father so we asked

595
00:26:49,379 --> 00:26:53,789
ourselves how hard it will be to

596
00:26:51,659 --> 00:26:57,480
implement a minimal version of Akkadian

597
00:26:53,789 --> 00:27:00,029
go so we started developing que digo

598
00:26:57,480 --> 00:27:03,929
which includes a pdb parser and

599
00:27:00,029 --> 00:27:07,470
downloader a stack and winder and you

600
00:27:03,929 --> 00:27:09,690
that uses symbol unwind info and a

601
00:27:07,470 --> 00:27:12,059
Celtic protocol a KD protocol client

602
00:27:09,690 --> 00:27:14,100
which we implemented for KD Syria

603
00:27:12,059 --> 00:27:17,850
Katie net will be available in the near

604
00:27:14,100 --> 00:27:20,219
future it's not perfect but we got it to

605
00:27:17,850 --> 00:27:22,168
compile into sis color and to symbolize

606
00:27:20,220 --> 00:27:26,549
crushes directly without the use of

607
00:27:22,169 --> 00:27:28,379
another remote machine now you all will

608
00:27:26,549 --> 00:27:33,690
come and talk to you about our next

609
00:27:28,379 --> 00:27:36,389
problem that we encounter so the next

610
00:27:33,690 --> 00:27:40,289
issue we got was a coverage stability or

611
00:27:36,389 --> 00:27:42,178
if I our coverage instability so sis

612
00:27:40,289 --> 00:27:44,279
color uses multiple threads to detect

613
00:27:42,179 --> 00:27:46,559
data races but in our coverage

614
00:27:44,279 --> 00:27:48,749
implementation we only had one coverage

615
00:27:46,559 --> 00:27:50,789
buffer for the entire process so in

616
00:27:48,749 --> 00:27:52,980
practice and the same program running

617
00:27:50,789 --> 00:27:55,830
multiple times will result in different

618
00:27:52,980 --> 00:27:57,570
coverage traces and coverage instability

619
00:27:55,830 --> 00:28:01,350
hurts the father's ability to found new

620
00:27:57,570 --> 00:28:04,439
code paths and thus finding new bugs so

621
00:28:01,350 --> 00:28:06,809
we had to fix this issue and we said

622
00:28:04,440 --> 00:28:08,580
let's do it like a cough so in order to

623
00:28:06,809 --> 00:28:11,999
do that we had to do a few things the

624
00:28:08,580 --> 00:28:15,600
first is we needed to be able to track

625
00:28:11,999 --> 00:28:17,940
threads in the guest in order to swap BT

626
00:28:15,600 --> 00:28:21,029
buffers for each Val and we also had

627
00:28:17,940 --> 00:28:23,549
neither to add handle aware API to KVM

628
00:28:21,029 --> 00:28:25,559
so we could fetch different coverage

629
00:28:23,549 --> 00:28:30,658
traces from different threads using a

630
00:28:25,559 --> 00:28:32,519
handle so third tracking we started with

631
00:28:30,659 --> 00:28:34,710
trying to find a way to get thread

632
00:28:32,519 --> 00:28:37,529
tracking from KVM the first thing we did

633
00:28:34,710 --> 00:28:39,570
was to peek at kef current thread and we

634
00:28:37,529 --> 00:28:41,100
found it uses GS with a specific offset

635
00:28:39,570 --> 00:28:45,149
to get a pointer to the current a thread

636
00:28:41,100 --> 00:28:47,279
on windows windows x86 beat machines and

637
00:28:45,149 --> 00:28:50,309
the GS segments point to K PCR which is

638
00:28:47,279 --> 00:28:52,259
the kernel process control region then

639
00:28:50,309 --> 00:28:54,149
we went to the swap context function in

640
00:28:52,259 --> 00:28:55,170
anthos which we which is used for

641
00:28:54,149 --> 00:28:57,479
context switching

642
00:28:55,170 --> 00:28:59,880
between threads we started looking for a

643
00:28:57,480 --> 00:29:01,710
better for a good hook near the end of

644
00:28:59,880 --> 00:29:04,020
the function there's a call for swap

645
00:29:01,710 --> 00:29:07,820
jeaious which swaps the current GS value

646
00:29:04,020 --> 00:29:11,160
with the one in IA Colonel Diaz bass MSR

647
00:29:07,820 --> 00:29:13,260
in via mix we can trap on the MSR writes

648
00:29:11,160 --> 00:29:17,660
which in other words mean we have a

649
00:29:13,260 --> 00:29:20,610
callback on a context switch back to KVM

650
00:29:17,660 --> 00:29:22,140
so what we are if limitation for Fed

651
00:29:20,610 --> 00:29:24,750
tracking is actually pretty simple

652
00:29:22,140 --> 00:29:28,020
we started with disabling the disabled

653
00:29:24,750 --> 00:29:31,200
for the the intercept of GS bass and we

654
00:29:28,020 --> 00:29:35,280
added coding in KVM to swap buffers on

655
00:29:31,200 --> 00:29:37,530
each GS change and finally we added to

656
00:29:35,280 --> 00:29:39,660
panic reporter code to notify JVM on

657
00:29:37,530 --> 00:29:42,660
thread termination because nobody likes

658
00:29:39,660 --> 00:29:45,030
memory leaks so that in that way we can

659
00:29:42,660 --> 00:29:50,160
release the physical memory back to the

660
00:29:45,030 --> 00:29:53,129
hosts so if we put it all together let

661
00:29:50,160 --> 00:29:55,620
when this executors starts it will spawn

662
00:29:53,130 --> 00:29:59,100
a few threads and register them with k

663
00:29:55,620 --> 00:30:00,959
vm k vm will allocate TT buffers for

664
00:29:59,100 --> 00:30:04,500
each thread and start recording coverage

665
00:30:00,960 --> 00:30:07,340
for each for all of them let's say for

666
00:30:04,500 --> 00:30:10,470
if thread 3 tries to issue a system call

667
00:30:07,340 --> 00:30:13,470
they would it would be recorded but if

668
00:30:10,470 --> 00:30:15,900
an evil thread will start running the

669
00:30:13,470 --> 00:30:20,670
coverage trace will stop until the

670
00:30:15,900 --> 00:30:23,430
thread will resume execution finally if

671
00:30:20,670 --> 00:30:25,470
the fret dies the panic reporter will

672
00:30:23,430 --> 00:30:31,350
notify k vm which will release its

673
00:30:25,470 --> 00:30:34,440
physical memory so we we in hindsight

674
00:30:31,350 --> 00:30:36,389
we're all a much smarter and when we

675
00:30:34,440 --> 00:30:38,340
when we looked recently at the swap

676
00:30:36,390 --> 00:30:42,030
context function in we found references

677
00:30:38,340 --> 00:30:44,250
to a IP t sees a quick googling brought

678
00:30:42,030 --> 00:30:46,440
us to Alex UNESCO SCADA page which

679
00:30:44,250 --> 00:30:49,470
provides more some more details on IP t

680
00:30:46,440 --> 00:30:52,650
says which is apparently an Intel PT

681
00:30:49,470 --> 00:30:54,630
driver used by Microsoft for for tracing

682
00:30:52,650 --> 00:30:57,810
Windows kernel and for tracing Windows

683
00:30:54,630 --> 00:30:59,880
it has support for perf thread tracking

684
00:30:57,810 --> 00:31:02,310
which is pretty cool and with the saved

685
00:30:59,880 --> 00:31:04,830
us a lot of time and pain but it doesn't

686
00:31:02,310 --> 00:31:06,750
support a kernel trace as a

687
00:31:04,830 --> 00:31:09,269
because it has an if statement that does

688
00:31:06,750 --> 00:31:11,130
not support it so in hindsight we could

689
00:31:09,269 --> 00:31:13,980
have bought an isolate server which has

690
00:31:11,130 --> 00:31:16,830
support for vmx Intel PT virtualization

691
00:31:13,980 --> 00:31:20,130
and wrote a small patch to IPT says that

692
00:31:16,830 --> 00:31:23,389
would allow a kernel trace to to trace

693
00:31:20,130 --> 00:31:27,000
kernel instead of using a modified k vm

694
00:31:23,390 --> 00:31:28,710
and we had other issues like we had Auto

695
00:31:27,000 --> 00:31:32,159
loaded programs that would starve our

696
00:31:28,710 --> 00:31:34,620
father's onedrive Windows Update would

697
00:31:32,159 --> 00:31:36,779
restart our father randomly causing C

698
00:31:34,620 --> 00:31:39,870
scholar to think it's a Hank Windows

699
00:31:36,779 --> 00:31:42,929
Defender decided our Father is a virus

700
00:31:39,870 --> 00:31:44,489
and in general take time and make sure

701
00:31:42,929 --> 00:31:49,049
you adjust your father for best

702
00:31:44,490 --> 00:31:52,559
performance so the results we fast for

703
00:31:49,049 --> 00:31:55,139
two weeks and and we we had a working

704
00:31:52,559 --> 00:31:58,408
prototype for C scholar we found at that

705
00:31:55,139 --> 00:32:01,049
time for bugs 14 out of service bugs -

706
00:31:58,409 --> 00:32:02,580
that fit in a tweet to deadlocks which

707
00:32:01,049 --> 00:32:03,929
are still not resolved if you're

708
00:32:02,580 --> 00:32:07,470
interested you can check out the Gator

709
00:32:03,929 --> 00:32:09,720
bait for wsl we have issues there but we

710
00:32:07,470 --> 00:32:12,120
found zero security vulnerabilities in

711
00:32:09,720 --> 00:32:15,120
hindsight we discovered that Microsoft

712
00:32:12,120 --> 00:32:17,459
was worth buzzing with websites color

713
00:32:15,120 --> 00:32:20,549
wsl at about the same time so

714
00:32:17,460 --> 00:32:24,090
understandably we did we did not find

715
00:32:20,549 --> 00:32:25,440
bugs that they already closed but we

716
00:32:24,090 --> 00:32:27,178
were a bit disappointed but we decided

717
00:32:25,440 --> 00:32:29,610
to move to a real privilege escalation

718
00:32:27,179 --> 00:32:32,159
target and we went back to the Windows

719
00:32:29,610 --> 00:32:35,219
kernel attack surface map and we decided

720
00:32:32,159 --> 00:32:37,620
to set our sights on win32 K first one

721
00:32:35,220 --> 00:32:39,120
is win32 K it's the kernel side of the

722
00:32:37,620 --> 00:32:40,739
windows subsystem which is the go

723
00:32:39,120 --> 00:32:43,289
infrastructure for the operating system

724
00:32:40,740 --> 00:32:45,029
it includes two major parts the user

725
00:32:43,289 --> 00:32:48,360
which is also known as the window

726
00:32:45,029 --> 00:32:53,279
manager and the GDI which is the graphic

727
00:32:48,360 --> 00:32:54,990
device interface so why win32 k well

728
00:32:53,279 --> 00:32:56,850
first it because it's a very popular

729
00:32:54,990 --> 00:32:58,620
target for local preference creation and

730
00:32:56,850 --> 00:33:01,830
we're looking for local privilege

731
00:32:58,620 --> 00:33:04,229
escalation and second it has huge attack

732
00:33:01,830 --> 00:33:07,559
surface with more than 1500 syscalls and

733
00:33:04,230 --> 00:33:08,730
although it has been fast before some

734
00:33:07,559 --> 00:33:11,279
would say to the DEF

735
00:33:08,730 --> 00:33:13,409
we couldn't find any previous work and

736
00:33:11,279 --> 00:33:16,139
coverage guided a grammar fuzzing for

737
00:33:13,409 --> 00:33:18,530
win32 k and we decided if it's not

738
00:33:16,139 --> 00:33:23,428
complex we're going to find bugs

739
00:33:18,530 --> 00:33:25,230
so we had to do additional changes so at

740
00:33:23,429 --> 00:33:28,170
first we had to make changes to the

741
00:33:25,230 --> 00:33:29,670
father the executor a few changes to IPC

742
00:33:28,170 --> 00:33:32,400
because we're moving from Linux to

743
00:33:29,670 --> 00:33:34,920
Windows and minor changes to the

744
00:33:32,400 --> 00:33:36,870
coverage our first attempt at boarding

745
00:33:34,920 --> 00:33:38,280
was to change the extension to dot exe

746
00:33:36,870 --> 00:33:41,129
and hope for the best

747
00:33:38,280 --> 00:33:44,520
but since that didn't do the trick we

748
00:33:41,130 --> 00:33:46,679
had to do like real work so the first we

749
00:33:44,520 --> 00:33:49,080
had to do changes to the executor which

750
00:33:46,679 --> 00:33:51,570
was to support up to 12 parameters per

751
00:33:49,080 --> 00:33:53,790
syscall because you know windows and

752
00:33:51,570 --> 00:33:56,129
then we ported some always related

753
00:33:53,790 --> 00:33:59,639
changes around thread management shared

754
00:33:56,130 --> 00:34:01,620
memory pipes and to name a few we had to

755
00:33:59,640 --> 00:34:04,559
expose windows sis calls to the executor

756
00:34:01,620 --> 00:34:06,629
and we decided to build everything on

757
00:34:04,559 --> 00:34:11,520
linux because it was much easier for us

758
00:34:06,630 --> 00:34:13,500
but it it cost us a few headaches so the

759
00:34:11,520 --> 00:34:15,540
the method for building it all of this

760
00:34:13,500 --> 00:34:17,668
on Linux is starts like this you start

761
00:34:15,540 --> 00:34:19,409
with Windows dll's then you use a tool

762
00:34:17,668 --> 00:34:21,388
named Jan def to generate that files

763
00:34:19,409 --> 00:34:23,580
then you use another tool called mingw

764
00:34:21,389 --> 00:34:25,710
dll tool to generate import libs and

765
00:34:23,580 --> 00:34:29,609
finally you linked it all together to

766
00:34:25,710 --> 00:34:31,710
your happy executors we had to do some

767
00:34:29,609 --> 00:34:36,149
changes to the father again small things

768
00:34:31,710 --> 00:34:38,760
around IPC and memory and we had to add

769
00:34:36,149 --> 00:34:40,830
the entire win32 cake grammar which

770
00:34:38,760 --> 00:34:45,540
we'll talk about extensively in a few

771
00:34:40,830 --> 00:34:47,549
slides for coverage we actually and we

772
00:34:45,540 --> 00:34:49,770
had to do a few changes because win32 k

773
00:34:47,550 --> 00:34:52,710
is not one thing but three things it's

774
00:34:49,770 --> 00:34:55,739
actually win32 k base we 32k full and

775
00:34:52,710 --> 00:34:58,530
win32 k and unfortunately our Intel pity

776
00:34:55,739 --> 00:35:00,899
decoder only supported one module we

777
00:34:58,530 --> 00:35:02,040
solve this issue by moving to win EFS

778
00:35:00,900 --> 00:35:03,960
inter pd decoder

779
00:35:02,040 --> 00:35:06,180
which is also support for multiple

780
00:35:03,960 --> 00:35:10,020
modules and as a side effect is much

781
00:35:06,180 --> 00:35:16,740
faster and finally we can get coverage

782
00:35:10,020 --> 00:35:19,259
traces for win32 k so to recap we we've

783
00:35:16,740 --> 00:35:22,350
modified the executor we changed

784
00:35:19,260 --> 00:35:25,550
something in IPC exit a father and

785
00:35:22,350 --> 00:35:28,680
coverage we moved to a sanity check

786
00:35:25,550 --> 00:35:31,500
where we try to reproduce cv 2018 zero

787
00:35:28,680 --> 00:35:35,098
seven four four which we seen earlier

788
00:35:31,500 --> 00:35:36,840
but it did not reproduce turns out our

789
00:35:35,099 --> 00:35:40,230
father was running under session zero

790
00:35:36,840 --> 00:35:41,760
and not under normal user session one we

791
00:35:40,230 --> 00:35:43,890
fix this issue pretty quickly by moving

792
00:35:41,760 --> 00:35:46,650
the SSH server from being the service to

793
00:35:43,890 --> 00:35:49,890
being the normal startup program but but

794
00:35:46,650 --> 00:35:51,840
the main takeaway from that is it's

795
00:35:49,890 --> 00:35:53,970
important to test your father's and make

796
00:35:51,840 --> 00:35:58,560
sure you reproduce all bugs otherwise

797
00:35:53,970 --> 00:36:00,598
you're probably just wasting CPU we then

798
00:35:58,560 --> 00:36:03,630
we move to coverage stability and we

799
00:36:00,599 --> 00:36:05,700
move to further stability where we added

800
00:36:03,630 --> 00:36:08,460
15 IP eyes and we let the photo run for

801
00:36:05,700 --> 00:36:11,368
the night and we got a blue screen our

802
00:36:08,460 --> 00:36:13,440
first thought was that yard but the bug

803
00:36:11,369 --> 00:36:16,590
was reproducible without the father so

804
00:36:13,440 --> 00:36:17,340
we gave it a second look the first bug

805
00:36:16,590 --> 00:36:19,170
was really weird

806
00:36:17,340 --> 00:36:22,109
it was a use after free in open

807
00:36:19,170 --> 00:36:25,109
clipboard and it was only reproducible

808
00:36:22,109 --> 00:36:28,230
on a few machines and we were like what

809
00:36:25,109 --> 00:36:30,540
the fuzz unfortunately looking at the

810
00:36:28,230 --> 00:36:32,160
crashing program did not reveal any

811
00:36:30,540 --> 00:36:35,340
significant clues about the root cause

812
00:36:32,160 --> 00:36:37,319
so we had to do a real work so looking

813
00:36:35,340 --> 00:36:39,000
at the crash site in Ida we can see that

814
00:36:37,320 --> 00:36:41,310
the code is trying to fetch the process

815
00:36:39,000 --> 00:36:46,230
ID but the process information is freed

816
00:36:41,310 --> 00:36:48,089
before use so what what what what we

817
00:36:46,230 --> 00:36:49,859
discovered is that on machine that the

818
00:36:48,089 --> 00:36:52,619
bug reproduced the if statement above

819
00:36:49,859 --> 00:36:54,750
the block evaluates to true what does it

820
00:36:52,619 --> 00:36:57,900
check well he checked that an etw at

821
00:36:54,750 --> 00:37:00,510
win32 k trace logging provider has a

822
00:36:57,900 --> 00:37:02,580
specific feature turned on what we found

823
00:37:00,510 --> 00:37:03,960
out through experimentation is if we

824
00:37:02,580 --> 00:37:04,380
were to install the same machine a few

825
00:37:03,960 --> 00:37:06,900
times

826
00:37:04,380 --> 00:37:08,280
sometimes the bug sometimes this flag

827
00:37:06,900 --> 00:37:10,440
would be on and sometimes it would be

828
00:37:08,280 --> 00:37:12,240
off and it feels like our fuzzing

829
00:37:10,440 --> 00:37:15,000
machine was probably some part of a

830
00:37:12,240 --> 00:37:17,609
feature experiment so I don't always get

831
00:37:15,000 --> 00:37:21,690
an a/b tested machine but when I do I

832
00:37:17,609 --> 00:37:23,848
get a vulnerability in it so we went

833
00:37:21,690 --> 00:37:26,760
back to check instability and we

834
00:37:23,849 --> 00:37:28,710
reinstalled Windows and made sure that

835
00:37:26,760 --> 00:37:32,339
the flag was definitely off this time

836
00:37:28,710 --> 00:37:33,810
and we got another bug this one was

837
00:37:32,339 --> 00:37:35,820
actually pretty interesting it's a

838
00:37:33,810 --> 00:37:38,520
denial of service in register class IX

839
00:37:35,820 --> 00:37:41,160
which only requires one Cisco which was

840
00:37:38,520 --> 00:37:43,460
odd but the bug itself was not really in

841
00:37:41,160 --> 00:37:45,270
winter in 2k but in RTL are okay tip

842
00:37:43,460 --> 00:37:47,880
apparently when

843
00:37:45,270 --> 00:37:49,950
when requesting allocations in specific

844
00:37:47,880 --> 00:37:52,140
sizes Artie a lot of people would try to

845
00:37:49,950 --> 00:37:54,720
allocate a memory from reserved name

846
00:37:52,140 --> 00:37:56,900
from his earth memory off the heap and

847
00:37:54,720 --> 00:38:00,000
crash while reading non-committed pages

848
00:37:56,900 --> 00:38:02,610
so at this point our motivation was

849
00:38:00,000 --> 00:38:05,250
really high because we're 15 Cisco's we

850
00:38:02,610 --> 00:38:11,340
found two bugs and we 1500 Cisco's we're

851
00:38:05,250 --> 00:38:14,370
gonna find 200 bucks right so our next

852
00:38:11,340 --> 00:38:16,410
our next and what we decided to do next

853
00:38:14,370 --> 00:38:20,190
is to create a full grammar for wind 32k

854
00:38:16,410 --> 00:38:23,490
from scratch which is a pain our first

855
00:38:20,190 --> 00:38:25,200
thought was let's automate this but we

856
00:38:23,490 --> 00:38:28,109
had the few obstacles the first one is

857
00:38:25,200 --> 00:38:30,980
that windows header do not convey enough

858
00:38:28,110 --> 00:38:34,080
semantic information to generate quality

859
00:38:30,980 --> 00:38:36,950
grammars from it and the second thing is

860
00:38:34,080 --> 00:38:41,850
that there are pretty there are

861
00:38:36,950 --> 00:38:45,060
undocumented windows API so so we had to

862
00:38:41,850 --> 00:38:47,339
do more work fortunately for us Windows

863
00:38:45,060 --> 00:38:49,259
is technically open-source because there

864
00:38:47,340 --> 00:38:51,300
is the Windows NT leak sources

865
00:38:49,260 --> 00:38:53,100
there's the windows 2000 leak sources

866
00:38:51,300 --> 00:38:56,340
there's react OS which is technically

867
00:38:53,100 --> 00:38:59,400
Windows 2003 leak sources there is WR k

868
00:38:56,340 --> 00:39:01,710
and a few other resources so what we

869
00:38:59,400 --> 00:39:03,000
actually did for each syscall is we

870
00:39:01,710 --> 00:39:05,340
looked at the sources and the

871
00:39:03,000 --> 00:39:08,760
documentation in Sdn and we try to

872
00:39:05,340 --> 00:39:10,860
verify as much as we can in ina and and

873
00:39:08,760 --> 00:39:12,650
we basically became grammar working

874
00:39:10,860 --> 00:39:15,600
union workers in the grammar mines

875
00:39:12,650 --> 00:39:17,670
mostly pis are pretty simple but others

876
00:39:15,600 --> 00:39:19,560
have complex input structures with

877
00:39:17,670 --> 00:39:22,080
complicated semantic relationship that

878
00:39:19,560 --> 00:39:25,920
was really obtained here's a few

879
00:39:22,080 --> 00:39:28,460
examples of a grammar that we added if

880
00:39:25,920 --> 00:39:31,620
you can feel the pain while reading this

881
00:39:28,460 --> 00:39:32,970
so we let the puzzle run and we've been

882
00:39:31,620 --> 00:39:35,609
a few hours we found three new

883
00:39:32,970 --> 00:39:37,410
vulnerabilities in GDI and we let the

884
00:39:35,610 --> 00:39:41,940
fuzzer run for another week but it found

885
00:39:37,410 --> 00:39:43,980
nothing and we felt we want more so at

886
00:39:41,940 --> 00:39:46,860
this point we had to do a go a bit

887
00:39:43,980 --> 00:39:48,330
deeper and I am sorry to disappoint many

888
00:39:46,860 --> 00:39:49,160
of you in the audience but fathers are

889
00:39:48,330 --> 00:39:51,930
not magic

890
00:39:49,160 --> 00:39:54,480
which means that we as researchers need

891
00:39:51,930 --> 00:39:56,190
to teach them tricks and help them to

892
00:39:54,480 --> 00:39:58,449
reach how to reach attack surfaces in

893
00:39:56,190 --> 00:40:01,249
order for them to find bugs for us

894
00:39:58,449 --> 00:40:02,749
so our method for doing this is we try

895
00:40:01,249 --> 00:40:05,149
to learn as much as we can about the

896
00:40:02,749 --> 00:40:07,069
attack surface with we're targeting that

897
00:40:05,150 --> 00:40:09,079
classes prior work anything with that we

898
00:40:07,069 --> 00:40:11,089
can get our hands off and we try to

899
00:40:09,079 --> 00:40:13,309
reproduce all bugs because they give us

900
00:40:11,089 --> 00:40:15,170
information about they teach us a lot

901
00:40:13,309 --> 00:40:17,059
about the attack surface and they teach

902
00:40:15,170 --> 00:40:19,789
us a lot about the limitations of our

903
00:40:17,059 --> 00:40:22,670
fathers and finally we take time and

904
00:40:19,789 --> 00:40:24,680
look for coverage because coverage also

905
00:40:22,670 --> 00:40:26,869
shows you the things that you don't know

906
00:40:24,680 --> 00:40:28,969
are missing from your from your

907
00:40:26,869 --> 00:40:30,739
fathering campaign we take all of these

908
00:40:28,969 --> 00:40:33,259
insights and we try to inject them back

909
00:40:30,739 --> 00:40:34,939
into the fuzzing process I know this is

910
00:40:33,259 --> 00:40:37,099
pretty abstract so let's give it a

911
00:40:34,939 --> 00:40:42,229
concrete example from our research and

912
00:40:37,099 --> 00:40:44,329
so one weird winter 2k trick is there is

913
00:40:42,229 --> 00:40:46,788
a thing called win a GDI shared handle

914
00:40:44,329 --> 00:40:49,819
table which is a table of handles

915
00:40:46,789 --> 00:40:52,999
pointed from the PB it's basically an

916
00:40:49,819 --> 00:40:55,489
array of structs that that has all the

917
00:40:52,999 --> 00:40:58,788
handles relevant for GDI and those with

918
00:40:55,489 --> 00:41:01,189
process ID zero our global handles

919
00:40:58,789 --> 00:41:02,869
meaning that they are that you can use

920
00:41:01,189 --> 00:41:05,779
them from any process even though you

921
00:41:02,869 --> 00:41:07,249
haven't created them so we thought maybe

922
00:41:05,779 --> 00:41:09,920
we can use them in our fuzzing process

923
00:41:07,249 --> 00:41:12,678
and that would yield new bugs so we

924
00:41:09,920 --> 00:41:15,289
created a new service called that what

925
00:41:12,679 --> 00:41:18,859
it does is it traverses the array and

926
00:41:15,289 --> 00:41:21,049
searches for global handles and we let

927
00:41:18,859 --> 00:41:24,410
the fuzzer run and within a few hours it

928
00:41:21,049 --> 00:41:26,900
found CV 20 19 1 1 5 9 which is

929
00:41:24,410 --> 00:41:32,269
triggered by one Cisco and a global

930
00:41:26,900 --> 00:41:34,099
handle so the results of the research is

931
00:41:32,269 --> 00:41:37,339
we fast for one and a half month in our

932
00:41:34,099 --> 00:41:39,859
spare time we found a vulnerabilities we

933
00:41:37,339 --> 00:41:43,459
got assigned 6 e ve 1 is duplicate and

934
00:41:39,859 --> 00:41:46,009
one is still pending and and we found

935
00:41:43,459 --> 00:41:47,689
three denials of service bugs 1 crash in

936
00:41:46,009 --> 00:41:49,910
win logon which we are having a really

937
00:41:47,689 --> 00:41:54,288
hard time to pin down and a few dead

938
00:41:49,910 --> 00:41:57,308
locks so we ask ourselves we sell those

939
00:41:54,289 --> 00:42:00,049
half LP is fine but can we make it an RC

940
00:41:57,309 --> 00:42:02,660
so enter the windows metafile format

941
00:42:00,049 --> 00:42:06,469
which is like all good things designed

942
00:42:02,660 --> 00:42:08,959
in the 90s it's it supports both vector

943
00:42:06,469 --> 00:42:10,970
graphics and bitmaps and if I were to

944
00:42:08,959 --> 00:42:12,890
summarize this that

945
00:42:10,970 --> 00:42:15,649
that the image format in a sentence it

946
00:42:12,890 --> 00:42:17,450
would be basically if you took system

947
00:42:15,650 --> 00:42:18,400
calls and serialized them into an image

948
00:42:17,450 --> 00:42:21,140
file

949
00:42:18,400 --> 00:42:24,140
Microsoft extended wmf a few times with

950
00:42:21,140 --> 00:42:25,850
EMF EMF plus an EMF spool and if you

951
00:42:24,140 --> 00:42:28,520
were interested to hear more about this

952
00:42:25,850 --> 00:42:32,509
about wmf in general you should check

953
00:42:28,520 --> 00:42:35,240
out jurors research on the topic so

954
00:42:32,510 --> 00:42:38,480
where we looked at the spec for a EE for

955
00:42:35,240 --> 00:42:42,200
EMF and we under the bitmap RICO types

956
00:42:38,480 --> 00:42:45,200
there is a record type called a stretch

957
00:42:42,200 --> 00:42:48,500
BLT and we happen to add the

958
00:42:45,200 --> 00:42:59,299
vulnerability and stretch building so we

959
00:42:48,500 --> 00:43:01,490
can do a demo you can see that's almost

960
00:42:59,300 --> 00:43:05,360
fully patched windows because we

961
00:43:01,490 --> 00:43:07,910
recorded that in last week hey we were

962
00:43:05,360 --> 00:43:12,760
using in front of you because word was a

963
00:43:07,910 --> 00:43:12,759
bit annoying but we get a crash

964
00:43:17,800 --> 00:43:24,170
so for future work we want to fuzz

965
00:43:21,770 --> 00:43:26,660
diuretics which is currently within fast

966
00:43:24,170 --> 00:43:29,690
because of limitations we encountered in

967
00:43:26,660 --> 00:43:33,230
this collar and also win32 K callbacks

968
00:43:29,690 --> 00:43:36,910
which are a big attack surface for for

969
00:43:33,230 --> 00:43:39,590
win32 k generally user-mode callbacks

970
00:43:36,910 --> 00:43:43,609
also we have a pretty big corpus of

971
00:43:39,590 --> 00:43:45,500
programs about 1 451 programs and we

972
00:43:43,610 --> 00:43:47,120
want to and we want to try them out with

973
00:43:45,500 --> 00:43:49,750
new bug Oracle's that will be able to

974
00:43:47,120 --> 00:43:52,990
detect crashes in a more precise manner

975
00:43:49,750 --> 00:43:54,920
and we want to open-source airport and

976
00:43:52,990 --> 00:43:59,089
finally we want to fast the rest of the

977
00:43:54,920 --> 00:44:01,490
kernel so to recap we started from our

978
00:43:59,090 --> 00:44:04,070
user space bugs but we wanted a kernel

979
00:44:01,490 --> 00:44:06,319
one we looked at K FL but it wasn't good

980
00:44:04,070 --> 00:44:10,010
enough so we moved the sales caller and

981
00:44:06,320 --> 00:44:11,990
we started porting to WSL we were a bit

982
00:44:10,010 --> 00:44:15,320
disappointed that nothing happened

983
00:44:11,990 --> 00:44:17,589
we've moved back to winter it ok we did

984
00:44:15,320 --> 00:44:20,720
a lot of grammar mining we got 8 bucks

985
00:44:17,590 --> 00:44:24,020
we were able to turn some of them to our

986
00:44:20,720 --> 00:44:26,000
C's and we want to say special thanks to

987
00:44:24,020 --> 00:44:27,890
the dynamics tool teams at Google for

988
00:44:26,000 --> 00:44:30,620
creating CS color and a lot of other

989
00:44:27,890 --> 00:44:33,170
infrastructure around it it's it's

990
00:44:30,620 --> 00:44:35,029
amazing to own reals committee who

991
00:44:33,170 --> 00:44:38,000
helped us making these slides really

992
00:44:35,030 --> 00:44:41,610
pretty and also one mentor for a special

993
00:44:38,000 --> 00:44:51,919
assistants in the project thank you

994
00:44:41,610 --> 00:44:51,919
[Applause]

995
00:45:01,850 --> 00:45:11,640
yeah so yes we a lot of like the the

996
00:45:09,450 --> 00:45:14,399
windows headers like when it says a D

997
00:45:11,640 --> 00:45:17,069
word does it mean a D word or a flag or

998
00:45:14,400 --> 00:45:19,680
it could be an atom which is a pointer

999
00:45:17,070 --> 00:45:21,720
to something or it can be like a lot of

1000
00:45:19,680 --> 00:45:23,310
things which are not a D word so it

1001
00:45:21,720 --> 00:45:25,859
doesn't have enough information to

1002
00:45:23,310 --> 00:45:28,250
effectively fuzz it if if if the

1003
00:45:25,860 --> 00:45:30,990
execution speed for Colonel fuzzing was

1004
00:45:28,250 --> 00:45:33,120
at the same speed of wind of userspace

1005
00:45:30,990 --> 00:45:35,700
fuzzing would probably be able to get

1006
00:45:33,120 --> 00:45:40,279
away with a lot much less accurate

1007
00:45:35,700 --> 00:45:40,279
grammar than we had to do for wind 32k

1008
00:45:42,050 --> 00:45:51,870
yeah thanks for sharing

1009
00:45:50,310 --> 00:45:55,890
thanks for sharing and so the approach

1010
00:45:51,870 --> 00:45:59,089
that didn't work how much time take to

1011
00:45:55,890 --> 00:46:02,129
all to do all these research and

1012
00:45:59,090 --> 00:46:04,320
continue to work after you spend I think

1013
00:46:02,130 --> 00:46:07,980
a lot of time to see something that is

1014
00:46:04,320 --> 00:46:09,300
not working and so we described like the

1015
00:46:07,980 --> 00:46:11,130
things that didn't work because they

1016
00:46:09,300 --> 00:46:13,950
were important to us to describe them

1017
00:46:11,130 --> 00:46:15,630
but the entire research was about in a

1018
00:46:13,950 --> 00:46:19,529
span of four months where we did it in

1019
00:46:15,630 --> 00:46:22,410
our 20% time at work so it wasn't a huge

1020
00:46:19,530 --> 00:46:25,410
effort we had some like advantage

1021
00:46:22,410 --> 00:46:27,839
because we worked on similar things in

1022
00:46:25,410 --> 00:46:30,029
the past and we could start pretty more

1023
00:46:27,840 --> 00:46:32,970
easily and we were also standing on

1024
00:46:30,030 --> 00:46:34,950
shoulders of giants like that made a lot

1025
00:46:32,970 --> 00:46:38,879
of things in in the space so we could

1026
00:46:34,950 --> 00:46:39,629
reuse a lot of things thanks for your

1027
00:46:38,880 --> 00:46:44,340
talk

1028
00:46:39,630 --> 00:46:47,250
you showed that windows had blue screen

1029
00:46:44,340 --> 00:46:49,890
of death because of use of the free I

1030
00:46:47,250 --> 00:46:54,000
dunno how does it detect use of the free

1031
00:46:49,890 --> 00:46:57,210
Jesus we I said it earlier we use a we

1032
00:46:54,000 --> 00:47:00,240
added special post-offer alex for win32

1033
00:46:57,210 --> 00:47:01,539
kbase when 52k for another so we can

1034
00:47:00,240 --> 00:47:04,258
catch a poke

1035
00:47:01,539 --> 00:47:07,059
for double fries and this kind of stuff

1036
00:47:04,259 --> 00:47:09,429
like it's its built-in features in a

1037
00:47:07,059 --> 00:47:11,349
windows and you can generate you can

1038
00:47:09,429 --> 00:47:13,269
designate which drivers you want are

1039
00:47:11,349 --> 00:47:15,880
there pools to be tracked it has a

1040
00:47:13,269 --> 00:47:18,549
performance penalty it uses something

1041
00:47:15,880 --> 00:47:21,189
very simple to electric fence like well

1042
00:47:18,549 --> 00:47:22,749
you have guard pages in each side and so

1043
00:47:21,189 --> 00:47:26,199
that's that's how it does it

1044
00:47:22,749 --> 00:47:29,019
and it also delays returning memory back

1045
00:47:26,199 --> 00:47:30,899
so we can detect use after freeze thank

1046
00:47:29,019 --> 00:47:39,399
you

1047
00:47:30,899 --> 00:47:43,049
anyone else so everyone else is

1048
00:47:39,399 --> 00:47:43,049
apparently still processing the info

