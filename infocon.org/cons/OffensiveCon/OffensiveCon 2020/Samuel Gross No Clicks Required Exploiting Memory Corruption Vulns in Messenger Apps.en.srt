1
00:00:00,030 --> 00:00:04,200
thanks for staying or coming everyone

2
00:00:01,920 --> 00:00:07,140
will just continue pretty much right

3
00:00:04,200 --> 00:00:09,030
where Natalie left off I do want to

4
00:00:07,140 --> 00:00:12,239
spend two minutes explaining this

5
00:00:09,030 --> 00:00:16,378
vulnerability it's again like a cycle

6
00:00:12,240 --> 00:00:19,320
issue ordering NS an archiving again in

7
00:00:16,379 --> 00:00:20,460
the shared key dictionary so basically

8
00:00:19,320 --> 00:00:23,039
what you have to know is there is a

9
00:00:20,460 --> 00:00:25,410
shared key dictionary that at the top

10
00:00:23,039 --> 00:00:27,840
right you can see it it's basically an

11
00:00:25,410 --> 00:00:31,198
area of values and a pointer to a shared

12
00:00:27,840 --> 00:00:33,510
key set in a shared key set itself is a

13
00:00:31,199 --> 00:00:37,950
linked list so I can have sub sub sub

14
00:00:33,510 --> 00:00:40,649
key sets and then they have the number

15
00:00:37,950 --> 00:00:43,739
of keys they store then a rank table and

16
00:00:40,649 --> 00:00:46,320
then the area of keys right and so the

17
00:00:43,739 --> 00:00:48,870
way the lookup works is you take the you

18
00:00:46,320 --> 00:00:52,829
you want to look up k1 maybe okay let's

19
00:00:48,870 --> 00:00:55,078
go with k3 so you want to look up k3 you

20
00:00:52,829 --> 00:00:58,859
go to the first shared key set you hash

21
00:00:55,079 --> 00:01:01,710
the value k3 basically and you said AZ

22
00:00:58,859 --> 00:01:04,470
index into the rank table and then the

23
00:01:01,710 --> 00:01:07,890
rank table gives you an index into the

24
00:01:04,470 --> 00:01:10,740
keys area right but that index is bounce

25
00:01:07,890 --> 00:01:12,930
checked against num key okay and so in

26
00:01:10,740 --> 00:01:14,580
this case it wouldn't find the key K 3

27
00:01:12,930 --> 00:01:18,030
in the first he said it would go to the

28
00:01:14,580 --> 00:01:20,850
second key set do the same thing fine k

29
00:01:18,030 --> 00:01:23,970
the key K 3 and then that that's the

30
00:01:20,850 --> 00:01:26,699
index for the values area in the shared

31
00:01:23,970 --> 00:01:28,979
key dictionary why is this important

32
00:01:26,700 --> 00:01:32,460
well really the only important thing

33
00:01:28,979 --> 00:01:34,259
here is this one invariant that Nam key

34
00:01:32,460 --> 00:01:36,390
must be equal to the length of this

35
00:01:34,259 --> 00:01:37,860
array if that's not the case then

36
00:01:36,390 --> 00:01:41,930
there's a big problem because then this

37
00:01:37,860 --> 00:01:44,549
rank table stuff can index out of bounds

38
00:01:41,930 --> 00:01:46,710
let's see how this ended with coda looks

39
00:01:44,549 --> 00:01:48,180
like for for this kind of object it's

40
00:01:46,710 --> 00:01:50,759
fairly straightforward really what it

41
00:01:48,180 --> 00:01:52,380
does is like take all the values out of

42
00:01:50,759 --> 00:01:56,490
the archive right this is like this

43
00:01:52,380 --> 00:01:59,219
decode so decodes the num key field and

44
00:01:56,490 --> 00:02:01,560
the rank table field then it decodes the

45
00:01:59,219 --> 00:02:03,390
sub key set and then the first if

46
00:02:01,560 --> 00:02:05,460
statement that's where it makes sure

47
00:02:03,390 --> 00:02:07,770
this invariant holds right there like

48
00:02:05,460 --> 00:02:10,348
key length of the keys area must be

49
00:02:07,770 --> 00:02:12,150
equal and then interestingly there's a

50
00:02:10,348 --> 00:02:13,049
for loop where it tries to look up every

51
00:02:12,150 --> 00:02:15,090
key

52
00:02:13,050 --> 00:02:16,440
just to make sure that it's like useful

53
00:02:15,090 --> 00:02:19,920
that it can actually look up all the

54
00:02:16,440 --> 00:02:22,109
keys looks pretty much okay but let's

55
00:02:19,920 --> 00:02:24,660
see what happens when we try to mess

56
00:02:22,110 --> 00:02:27,030
with it so we start with an empty shared

57
00:02:24,660 --> 00:02:28,799
key set at the top we start decoding

58
00:02:27,030 --> 00:02:31,830
these values okay Nam key let's put in

59
00:02:28,800 --> 00:02:34,140
some some interesting values ffff and

60
00:02:31,830 --> 00:02:38,760
four one four one four one and then we

61
00:02:34,140 --> 00:02:40,350
go and decode a second one here and we

62
00:02:38,760 --> 00:02:43,040
do the whole thing again right we start

63
00:02:40,350 --> 00:02:46,019
from the top we fill in all these values

64
00:02:43,040 --> 00:02:47,730
and now we actually make a cycle and

65
00:02:46,020 --> 00:02:50,790
this is like not not how you're supposed

66
00:02:47,730 --> 00:02:53,130
to do it and you make a cycle back to

67
00:02:50,790 --> 00:02:55,530
shared key set one and this actually

68
00:02:53,130 --> 00:02:58,410
works there's handling less logic in the

69
00:02:55,530 --> 00:03:00,420
key to an archiver to make this possible

70
00:02:58,410 --> 00:03:03,030
okay and then we decode the keys and

71
00:03:00,420 --> 00:03:06,000
this is okay right like dumb key and the

72
00:03:03,030 --> 00:03:09,930
ranked the keys length is the same and

73
00:03:06,000 --> 00:03:13,740
now we try to look up every key and so

74
00:03:09,930 --> 00:03:15,660
in this case we are here we decode away

75
00:03:13,740 --> 00:03:17,910
we look up the key and shared key said -

76
00:03:15,660 --> 00:03:20,340
and it isn't being found because the

77
00:03:17,910 --> 00:03:22,170
index is 42 it's not that's not the

78
00:03:20,340 --> 00:03:24,630
right one so we recursed

79
00:03:22,170 --> 00:03:27,079
to share key said one and now all of a

80
00:03:24,630 --> 00:03:29,880
sudden here we have a memory corruption

81
00:03:27,080 --> 00:03:34,020
because now this invariant doesn't hold

82
00:03:29,880 --> 00:03:35,700
right it's Nam key is hex ffffff so it's

83
00:03:34,020 --> 00:03:37,920
things this keys area is gigantic but

84
00:03:35,700 --> 00:03:41,070
really it's Niall pointer and so we can

85
00:03:37,920 --> 00:03:43,708
access an arbitrary address and have

86
00:03:41,070 --> 00:03:45,930
that be used as an objective-c object so

87
00:03:43,709 --> 00:03:48,510
that's the bug it gives us an arbitrary

88
00:03:45,930 --> 00:03:51,360
address dereference and that's what

89
00:03:48,510 --> 00:03:53,730
we're going to exploit now right so this

90
00:03:51,360 --> 00:03:57,180
is just a summary again our bug

91
00:03:53,730 --> 00:04:00,030
primitive so how do you exploit this

92
00:03:57,180 --> 00:04:01,770
kind of bug um basically what you need

93
00:04:00,030 --> 00:04:04,680
to do is to create some kind of fake

94
00:04:01,770 --> 00:04:06,330
object and have that object be used

95
00:04:04,680 --> 00:04:08,580
right so this pointer that's being read

96
00:04:06,330 --> 00:04:10,440
this absolute point is that's being

97
00:04:08,580 --> 00:04:12,840
treated as a pointer to an object is the

98
00:04:10,440 --> 00:04:14,820
object and it will call methods on it so

99
00:04:12,840 --> 00:04:17,790
that should be exploitable if we can

100
00:04:14,820 --> 00:04:20,130
fake these in particular I think it will

101
00:04:17,790 --> 00:04:22,229
call like dialogue or is nsstring on

102
00:04:20,130 --> 00:04:25,080
this thing and so what you would have to

103
00:04:22,229 --> 00:04:27,270
do is like fake an objective-c object

104
00:04:25,080 --> 00:04:29,280
I have a class pointer that

105
00:04:27,270 --> 00:04:31,258
points to a fake objective-c class and

106
00:04:29,280 --> 00:04:33,119
then that Objective C class has the

107
00:04:31,259 --> 00:04:34,319
function pointers and those will be

108
00:04:33,120 --> 00:04:37,710
called so once you have control over

109
00:04:34,319 --> 00:04:41,520
that you can get code execution now the

110
00:04:37,710 --> 00:04:43,109
obvious problem we have here is a SLR so

111
00:04:41,520 --> 00:04:45,120
we don't actually know where anything is

112
00:04:43,110 --> 00:04:47,159
in memory we don't know where our fake

113
00:04:45,120 --> 00:04:49,169
object end up when we put them in memory

114
00:04:47,159 --> 00:04:52,349
and we also don't know where libraries

115
00:04:49,169 --> 00:04:55,049
are so we don't have code point us and

116
00:04:52,349 --> 00:04:57,990
we'll take a this problem in two parts

117
00:04:55,050 --> 00:05:00,020
part one is will do heap spraying which

118
00:04:57,990 --> 00:05:02,699
is an old technique but it still works

119
00:05:00,020 --> 00:05:05,400
and so what you do basically is you

120
00:05:02,699 --> 00:05:07,889
allocate maybe 256 megabytes of memory

121
00:05:05,400 --> 00:05:12,419
this is fairly easy over iMessage

122
00:05:07,889 --> 00:05:14,639
actually due to the an archiver and once

123
00:05:12,419 --> 00:05:16,530
we have allocated that much memory then

124
00:05:14,639 --> 00:05:19,199
at this one address the hex one one

125
00:05:16,530 --> 00:05:23,008
seven zeros there will be control data

126
00:05:19,199 --> 00:05:24,810
our data and so this is how we can put

127
00:05:23,009 --> 00:05:28,289
fake objects into memory which is spray

128
00:05:24,810 --> 00:05:31,500
to 256 megabytes and then our fake

129
00:05:28,289 --> 00:05:35,520
objects are located at a known address

130
00:05:31,500 --> 00:05:37,710
and it's pretty good the second part is

131
00:05:35,520 --> 00:05:39,599
more complicated so the problem we now

132
00:05:37,710 --> 00:05:43,609
still have is we don't know any code

133
00:05:39,599 --> 00:05:46,830
pointers and so because we can't like

134
00:05:43,610 --> 00:05:48,719
inject executable code into the process

135
00:05:46,830 --> 00:05:51,060
we have to know the addresses of

136
00:05:48,719 --> 00:05:56,099
existing executable code so we need

137
00:05:51,060 --> 00:05:59,120
library addresses and this problem I had

138
00:05:56,099 --> 00:06:03,180
two different approaches for that for

139
00:05:59,120 --> 00:06:04,919
taking that problem and I kind of

140
00:06:03,180 --> 00:06:06,630
followed both but then I I didn't really

141
00:06:04,919 --> 00:06:08,068
get the first one to work but the second

142
00:06:06,630 --> 00:06:09,210
one worked but I still want to go

143
00:06:08,069 --> 00:06:11,279
through both of them because I think

144
00:06:09,210 --> 00:06:13,229
they are kind of interesting the idea

145
00:06:11,279 --> 00:06:17,310
for the first one is basically to work

146
00:06:13,229 --> 00:06:19,740
around a SLR and and like deal with not

147
00:06:17,310 --> 00:06:21,659
knowing these addresses so one typical

148
00:06:19,740 --> 00:06:23,909
example here's a partial pointer over

149
00:06:21,659 --> 00:06:25,560
writes all right if you like have a one

150
00:06:23,909 --> 00:06:27,569
buy it over right into a pointer then

151
00:06:25,560 --> 00:06:28,949
you can do some interesting stuff

152
00:06:27,569 --> 00:06:31,740
without actually knowing where the

153
00:06:28,949 --> 00:06:33,090
pointer points to this doesn't work here

154
00:06:31,740 --> 00:06:35,699
because of the bug the bug is like an

155
00:06:33,090 --> 00:06:38,039
absolute address D ref but maybe we can

156
00:06:35,699 --> 00:06:40,710
do something similar where anti second

157
00:06:38,039 --> 00:06:44,460
ideas to properly I guess break a SLR

158
00:06:40,710 --> 00:06:48,210
and get addresses through then yeah

159
00:06:44,460 --> 00:06:51,390
fake objects and so on start with the

160
00:06:48,210 --> 00:06:55,049
first one so the rough idea I had was to

161
00:06:51,390 --> 00:06:58,560
to do a heap spray without knowing

162
00:06:55,050 --> 00:07:00,630
library addresses but instead having the

163
00:06:58,560 --> 00:07:03,120
the application itself put in some

164
00:07:00,630 --> 00:07:05,340
pointers into the sprayed into the

165
00:07:03,120 --> 00:07:07,830
contents of the heap spray so maybe it

166
00:07:05,340 --> 00:07:10,650
makes it more clear with this image so

167
00:07:07,830 --> 00:07:13,130
my heap spray is at this hex 1 1 7 0

168
00:07:10,650 --> 00:07:16,080
Edwin's and what I want to put there are

169
00:07:13,130 --> 00:07:17,880
fake objects that have some valid

170
00:07:16,080 --> 00:07:20,070
pointers in them that the application

171
00:07:17,880 --> 00:07:22,080
itself puts in there and then I have a

172
00:07:20,070 --> 00:07:24,750
pointer maybe to some interesting global

173
00:07:22,080 --> 00:07:27,810
object and since that's part of a faked

174
00:07:24,750 --> 00:07:30,840
object maybe I can make the process do

175
00:07:27,810 --> 00:07:35,130
something interesting to it like that's

176
00:07:30,840 --> 00:07:36,869
the really vague idea that I had one

177
00:07:35,130 --> 00:07:39,990
example how this can work in our

178
00:07:36,870 --> 00:07:44,010
scenario here is the the nskeyedarchiver

179
00:07:39,990 --> 00:07:46,500
it allows decoding C style arrays like

180
00:07:44,010 --> 00:07:49,020
well just fixed sized arrays you said

181
00:07:46,500 --> 00:07:52,260
I'd like give me 10 an area of 10 or

182
00:07:49,020 --> 00:07:54,830
decode me 10 integers or so and actually

183
00:07:52,260 --> 00:07:57,150
it also supports decoding class pointers

184
00:07:54,830 --> 00:08:00,599
for I don't know why and it seems like a

185
00:07:57,150 --> 00:08:02,880
really absurd feature but what what this

186
00:08:00,600 --> 00:08:05,100
lets you do is it lets you create a

187
00:08:02,880 --> 00:08:06,960
linear array in memory with pointers to

188
00:08:05,100 --> 00:08:09,990
classes and then if you look at

189
00:08:06,960 --> 00:08:12,299
objective-c objects and in memory and

190
00:08:09,990 --> 00:08:14,820
Objective C object is just a pointer to

191
00:08:12,300 --> 00:08:17,400
a class and then the fields that it has

192
00:08:14,820 --> 00:08:20,250
right and so with that we can suddenly

193
00:08:17,400 --> 00:08:22,349
create somewhat valid looking

194
00:08:20,250 --> 00:08:25,230
objective-c objects without knowing

195
00:08:22,350 --> 00:08:28,950
addresses so it makes this more clear

196
00:08:25,230 --> 00:08:31,410
the picture at the bottom the archive if

197
00:08:28,950 --> 00:08:33,780
we put in pretty much just has the

198
00:08:31,410 --> 00:08:36,210
string NS array in it where it's like

199
00:08:33,780 --> 00:08:38,699
this is an array of classes and each

200
00:08:36,210 --> 00:08:40,860
entry is the class NS array so I just

201
00:08:38,700 --> 00:08:43,440
need the name of the class and then the

202
00:08:40,860 --> 00:08:45,360
keyed an archiver will go ahead and like

203
00:08:43,440 --> 00:08:47,850
look up the name of this class look up

204
00:08:45,360 --> 00:08:49,650
the class object and put in the pointer

205
00:08:47,850 --> 00:08:52,680
to their class into this memory buffer

206
00:08:49,650 --> 00:08:54,069
and so I end up with this memory dump on

207
00:08:52,680 --> 00:08:56,260
the right side

208
00:08:54,070 --> 00:08:58,780
and now this suddenly looks like a

209
00:08:56,260 --> 00:09:01,180
legitimate NS array because the first

210
00:08:58,780 --> 00:09:03,400
quad word is a pointer to a class

211
00:09:01,180 --> 00:09:05,739
the emissary class and so now I've been

212
00:09:03,400 --> 00:09:09,520
able to fake objects without actually

213
00:09:05,740 --> 00:09:10,540
knowing any addresses I pursued this a

214
00:09:09,520 --> 00:09:13,930
bit further

215
00:09:10,540 --> 00:09:16,959
I guess the farthest I got was I I was

216
00:09:13,930 --> 00:09:20,170
able to basically free some object and

217
00:09:16,960 --> 00:09:23,680
then make the application lower or

218
00:09:20,170 --> 00:09:26,439
decrement some ref count now that that

219
00:09:23,680 --> 00:09:27,760
ref count would also be appointed to a

220
00:09:26,440 --> 00:09:29,800
class I would like that the thing that

221
00:09:27,760 --> 00:09:31,920
would be whether refcon would be

222
00:09:29,800 --> 00:09:36,069
decremented was also pointed to a class

223
00:09:31,920 --> 00:09:38,740
and so it just so happened that if you

224
00:09:36,070 --> 00:09:40,420
look at a class object the first quad

225
00:09:38,740 --> 00:09:42,670
word is again appointed to a class I

226
00:09:40,420 --> 00:09:44,439
made a class and the second quad word is

227
00:09:42,670 --> 00:09:47,290
the pointer to the super class right so

228
00:09:44,440 --> 00:09:49,450
Objective C has inheritance and these

229
00:09:47,290 --> 00:09:50,920
class objects the second quadrant is

230
00:09:49,450 --> 00:09:53,740
always the pointer to the super class

231
00:09:50,920 --> 00:09:57,099
and now due to this reference County

232
00:09:53,740 --> 00:09:59,580
command it was I was able to defer meant

233
00:09:57,100 --> 00:10:01,870
the second pointer to the superclass

234
00:09:59,580 --> 00:10:04,210
which is kind of hilarious because it

235
00:10:01,870 --> 00:10:06,400
lets lets you change the inheritance

236
00:10:04,210 --> 00:10:09,010
hierarchy at runtime because this is

237
00:10:06,400 --> 00:10:11,709
writable but it's not immediately useful

238
00:10:09,010 --> 00:10:15,390
at least I couldn't really see something

239
00:10:11,710 --> 00:10:19,510
immediately what we are to do with this

240
00:10:15,390 --> 00:10:22,360
so I kind of gave up on that idea but I

241
00:10:19,510 --> 00:10:24,160
still think it it could be done there's

242
00:10:22,360 --> 00:10:27,040
probably more you can do like more

243
00:10:24,160 --> 00:10:28,900
primitives we can gain by by faking

244
00:10:27,040 --> 00:10:30,640
object in a similar way or doing other

245
00:10:28,900 --> 00:10:35,079
clever things so that's why I wanted to

246
00:10:30,640 --> 00:10:38,590
include it here the other option that

247
00:10:35,080 --> 00:10:41,860
ended up working is well properly

248
00:10:38,590 --> 00:10:44,560
defeating a SLR which which has two

249
00:10:41,860 --> 00:10:45,850
steps or two parts to it the one the

250
00:10:44,560 --> 00:10:48,780
first part is we need some kind of

251
00:10:45,850 --> 00:10:51,310
communication channel to leak data back

252
00:10:48,780 --> 00:10:53,650
and the second part is we have to

253
00:10:51,310 --> 00:10:56,890
exploit the back in in such a way that

254
00:10:53,650 --> 00:10:59,800
we get some info over this communication

255
00:10:56,890 --> 00:11:02,560
channel so let's deal with the channel

256
00:10:59,800 --> 00:11:05,170
first here's a screenshot of iMessage

257
00:11:02,560 --> 00:11:07,390
and here you can nicely see the three

258
00:11:05,170 --> 00:11:10,030
different states a message can be in

259
00:11:07,390 --> 00:11:12,180
the first one is red the second is

260
00:11:10,030 --> 00:11:14,380
delivered and the third is none of those

261
00:11:12,180 --> 00:11:16,839
and the way this works is through

262
00:11:14,380 --> 00:11:18,670
deliver or I guess received a message

263
00:11:16,840 --> 00:11:20,650
received

264
00:11:18,670 --> 00:11:23,589
and so there's read received which say

265
00:11:20,650 --> 00:11:25,300
yes I got this message and the user

266
00:11:23,590 --> 00:11:27,730
actually read it

267
00:11:25,300 --> 00:11:30,189
and the second type is delivery received

268
00:11:27,730 --> 00:11:32,710
and those are sent automatically which

269
00:11:30,190 --> 00:11:36,120
makes it very interesting by this I am

270
00:11:32,710 --> 00:11:39,700
agent process that Natalie mentioned and

271
00:11:36,120 --> 00:11:42,730
and so we get them automatically once

272
00:11:39,700 --> 00:11:44,350
the message arrives in I am agent and so

273
00:11:42,730 --> 00:11:46,540
this is going to be our communication

274
00:11:44,350 --> 00:11:51,010
channel because now we get some kind of

275
00:11:46,540 --> 00:11:52,900
information back from the process so

276
00:11:51,010 --> 00:11:55,810
let's build something cool with that are

277
00:11:52,900 --> 00:12:00,300
an Oracle on the Left there is some

278
00:11:55,810 --> 00:12:02,829
rough pseudocode about how this this

279
00:12:00,300 --> 00:12:05,620
message processing and I am agent works

280
00:12:02,830 --> 00:12:08,080
and the delivery received sending and so

281
00:12:05,620 --> 00:12:10,870
the key point here is that the NS an

282
00:12:08,080 --> 00:12:13,630
archiving happens before the delivery

283
00:12:10,870 --> 00:12:16,390
received is being sent and what this

284
00:12:13,630 --> 00:12:18,790
gives us now it's basically a crash or

285
00:12:16,390 --> 00:12:21,520
occur because if we can trigger a crash

286
00:12:18,790 --> 00:12:24,040
during the on archiving then we won't

287
00:12:21,520 --> 00:12:26,500
see a delivery received and if we don't

288
00:12:24,040 --> 00:12:28,449
crash then we see a delivery received so

289
00:12:26,500 --> 00:12:32,020
all of a sudden we have a one basically

290
00:12:28,450 --> 00:12:34,600
one bit information leak did it crash

291
00:12:32,020 --> 00:12:37,030
did it not crash and now the remaining

292
00:12:34,600 --> 00:12:39,010
challenge is to crash when some

293
00:12:37,030 --> 00:12:41,980
condition is met so that we infer some

294
00:12:39,010 --> 00:12:45,250
kind of some piece of information from

295
00:12:41,980 --> 00:12:50,170
that okay so that's the communication

296
00:12:45,250 --> 00:12:53,380
channel let's go to exploitation before

297
00:12:50,170 --> 00:12:56,050
we do that um some some iOS internals

298
00:12:53,380 --> 00:12:58,900
there's this thing called ey LD shared

299
00:12:56,050 --> 00:13:01,420
cache the idea is to take all the the

300
00:12:58,900 --> 00:13:03,670
majority of system libraries and you pre

301
00:13:01,420 --> 00:13:06,520
link them into one gigantic binary blob

302
00:13:03,670 --> 00:13:08,620
which is around one gigabyte in size so

303
00:13:06,520 --> 00:13:11,410
it's pretty gigantic and that is shared

304
00:13:08,620 --> 00:13:14,320
and mapped in all userspace processes on

305
00:13:11,410 --> 00:13:16,900
iOS and there's three things about this

306
00:13:14,320 --> 00:13:18,760
that are very interesting the first is

307
00:13:16,900 --> 00:13:20,740
it's always mapped in this address

308
00:13:18,760 --> 00:13:24,279
region of four gigabyte between

309
00:13:20,740 --> 00:13:26,470
one eight and two eight seven zeroes the

310
00:13:24,279 --> 00:13:28,950
second is the randomization granularity

311
00:13:26,470 --> 00:13:32,830
is four thousand hex four thousand bytes

312
00:13:28,950 --> 00:13:34,959
because of large pages in iOS but the

313
00:13:32,830 --> 00:13:37,180
third is the most interesting one the

314
00:13:34,959 --> 00:13:40,449
shared cache is actually mapped at the

315
00:13:37,180 --> 00:13:42,640
same address in every process on this on

316
00:13:40,450 --> 00:13:46,270
the same device so it's only randomized

317
00:13:42,640 --> 00:13:48,730
per boot is what this means which means

318
00:13:46,270 --> 00:13:51,370
that for example if we crash I am agent

319
00:13:48,730 --> 00:13:53,140
we know that when it responds the next

320
00:13:51,370 --> 00:13:55,290
time the shared cache is still at the

321
00:13:53,140 --> 00:13:59,560
same address

322
00:13:55,290 --> 00:14:01,870
okay so let's build an Oracle um the the

323
00:13:59,560 --> 00:14:05,560
bug that I showed that gives us the

324
00:14:01,870 --> 00:14:07,660
arbitrary address D ref primitive can it

325
00:14:05,560 --> 00:14:10,899
basically gives us this Oracle function

326
00:14:07,660 --> 00:14:13,899
so we put in some address and it will

327
00:14:10,899 --> 00:14:16,870
only not crash if the address is mapped

328
00:14:13,899 --> 00:14:19,959
and then if the value that's at that

329
00:14:16,870 --> 00:14:22,480
address is either 0 or if it like looks

330
00:14:19,959 --> 00:14:24,550
like a valid objective-c pointer which

331
00:14:22,480 --> 00:14:26,500
means that kind of the most significant

332
00:14:24,550 --> 00:14:28,990
bit said then it it looks like a tank

333
00:14:26,500 --> 00:14:31,899
pointer or it actually points to a valid

334
00:14:28,990 --> 00:14:33,940
objective-c thing so only if these

335
00:14:31,899 --> 00:14:36,550
conditions are met will it not crash

336
00:14:33,940 --> 00:14:39,310
when we give it an address otherwise it

337
00:14:36,550 --> 00:14:41,620
will crash and now we can observe this

338
00:14:39,310 --> 00:14:44,670
crash because we either get a delivery

339
00:14:41,620 --> 00:14:49,779
received or we don't so that's the idea

340
00:14:44,670 --> 00:14:51,819
so what do we do with this part off line

341
00:14:49,779 --> 00:14:55,510
so that this doesn't need network

342
00:14:51,820 --> 00:14:59,800
connection we will basically compile a

343
00:14:55,510 --> 00:15:01,510
profile of the shared cache given this

344
00:14:59,800 --> 00:15:03,939
oracle function so this is really simple

345
00:15:01,510 --> 00:15:09,760
you you take that wire shared cache you

346
00:15:03,940 --> 00:15:11,560
get it from IPSW whatever so you have

347
00:15:09,760 --> 00:15:13,060
this huge binary you take the Oracle

348
00:15:11,560 --> 00:15:15,069
function and you just run it over the

349
00:15:13,060 --> 00:15:17,170
entire shared cache and the result is

350
00:15:15,070 --> 00:15:20,050
basically like a bitmap right bit 1 bit

351
00:15:17,170 --> 00:15:22,810
0 a bit 1 depending on whether this

352
00:15:20,050 --> 00:15:24,790
function returns true or false and so

353
00:15:22,810 --> 00:15:28,479
here at the bottom you can see an

354
00:15:24,790 --> 00:15:30,130
example profile and maybe the white area

355
00:15:28,480 --> 00:15:32,380
means this is where it wouldn't crash

356
00:15:30,130 --> 00:15:35,350
and the black area means this is where

357
00:15:32,380 --> 00:15:37,230
it would crash when probing

358
00:15:35,350 --> 00:15:39,339
in practice there's a search state

359
00:15:37,230 --> 00:15:41,110
because for example there's a writable

360
00:15:39,339 --> 00:15:43,000
area in the shared cache and you don't

361
00:15:41,110 --> 00:15:46,300
know if that at runtime what what will

362
00:15:43,000 --> 00:15:48,790
be there but it makes it it's easier to

363
00:15:46,300 --> 00:15:55,479
explain with a true state I'm sorry I

364
00:15:48,790 --> 00:15:59,110
was a true state profile so the next

365
00:15:55,480 --> 00:16:03,519
step is then to do some linear memory

366
00:15:59,110 --> 00:16:04,899
scan we know the the possible region

367
00:16:03,519 --> 00:16:07,810
where the shared cache is mapped you can

368
00:16:04,899 --> 00:16:11,560
see it on the right in this image and so

369
00:16:07,810 --> 00:16:15,729
we just go in like for example 256

370
00:16:11,560 --> 00:16:19,540
megabytes increments and just go over

371
00:16:15,730 --> 00:16:21,399
this range query this Oracle and at some

372
00:16:19,540 --> 00:16:22,060
point it will return true or like we

373
00:16:21,399 --> 00:16:24,399
will get it

374
00:16:22,060 --> 00:16:27,160
delivery received and then we know okay

375
00:16:24,399 --> 00:16:30,610
we have found some address somewhere in

376
00:16:27,160 --> 00:16:35,980
the shared cache like maybe this 1900

377
00:16:30,610 --> 00:16:39,310
seven four zero zero zero okay the next

378
00:16:35,980 --> 00:16:41,079
thing we do is again offline we have to

379
00:16:39,310 --> 00:16:45,699
now compute all the possible base

380
00:16:41,079 --> 00:16:48,819
addresses sorry that would lead to us

381
00:16:45,699 --> 00:16:51,219
not crashing on this particular address

382
00:16:48,819 --> 00:16:53,860
that we just probed and this is again

383
00:16:51,220 --> 00:16:57,339
very easy and we just go in page size

384
00:16:53,860 --> 00:17:00,339
steps over our shared cache profile and

385
00:16:57,339 --> 00:17:03,579
now every where every in this picture

386
00:17:00,339 --> 00:17:06,640
every white region is now a potential

387
00:17:03,579 --> 00:17:09,039
candidate right because this this is the

388
00:17:06,640 --> 00:17:13,390
the the eight bytes that we could have

389
00:17:09,039 --> 00:17:15,459
just probed in this case and so in

390
00:17:13,390 --> 00:17:17,860
practice I think this will leave us with

391
00:17:15,459 --> 00:17:19,780
maybe 30 to 40 cells and candidates

392
00:17:17,859 --> 00:17:23,500
because the share caches gigantic it's

393
00:17:19,780 --> 00:17:25,569
like oh well like one gigabyte also in

394
00:17:23,500 --> 00:17:28,720
size okay so we have all these

395
00:17:25,569 --> 00:17:30,850
candidates last step we need to

396
00:17:28,720 --> 00:17:32,860
eliminate them until we have just one

397
00:17:30,850 --> 00:17:36,100
remaining and I think this is either

398
00:17:32,860 --> 00:17:38,320
best to explain with an image so suppose

399
00:17:36,100 --> 00:17:41,408
I just have five five candidates left

400
00:17:38,320 --> 00:17:42,879
here and there they are now all mapped

401
00:17:41,409 --> 00:17:45,640
at different addresses that's why they

402
00:17:42,880 --> 00:17:47,920
like shifted right and you can see the

403
00:17:45,640 --> 00:17:50,620
initial address that we probed

404
00:17:47,920 --> 00:17:54,400
it like goes only through white white

405
00:17:50,620 --> 00:17:56,050
space because it didn't crash right so

406
00:17:54,400 --> 00:17:59,290
that's the initial errors and now we

407
00:17:56,050 --> 00:18:01,060
pick another address to probe so that

408
00:17:59,290 --> 00:18:03,520
roughly half of the candidates will have

409
00:18:01,060 --> 00:18:07,330
a 1-bit and the other half has a zero

410
00:18:03,520 --> 00:18:11,379
bit and so this way regardless of what

411
00:18:07,330 --> 00:18:13,120
this this Oracle returns we are able to

412
00:18:11,380 --> 00:18:16,090
roughly discard half the remaining

413
00:18:13,120 --> 00:18:18,879
candidates right so in this case if it

414
00:18:16,090 --> 00:18:21,730
crashes then we know we either have the

415
00:18:18,880 --> 00:18:23,650
first or the last profile right because

416
00:18:21,730 --> 00:18:25,360
there's that this is why the black areas

417
00:18:23,650 --> 00:18:28,360
and if it doesn't crash we have one of

418
00:18:25,360 --> 00:18:30,219
the three middle ones and so we just

419
00:18:28,360 --> 00:18:32,679
keep doing this and in every step we

420
00:18:30,220 --> 00:18:34,810
basically have the number of remaining

421
00:18:32,680 --> 00:18:36,460
candidates and so this is really fast in

422
00:18:34,810 --> 00:18:39,310
practice this takes like 20 or so

423
00:18:36,460 --> 00:18:44,920
queries to go from 30,000 candidates to

424
00:18:39,310 --> 00:18:47,730
just one okay so and this will then tell

425
00:18:44,920 --> 00:18:50,560
us the base address of the shared cache

426
00:18:47,730 --> 00:18:54,190
right so I think I have just about

427
00:18:50,560 --> 00:18:55,710
enough time so this now this is what it

428
00:18:54,190 --> 00:18:58,000
looks like we have all the addresses and

429
00:18:55,710 --> 00:19:01,590
this is good enough for any device that

430
00:18:58,000 --> 00:19:04,110
doesn't support pointers indication

431
00:19:01,590 --> 00:19:09,520
which is every device before the iPhone

432
00:19:04,110 --> 00:19:13,530
10s on the 10s and you are Apple has a

433
00:19:09,520 --> 00:19:16,210
new feature called point authentication

434
00:19:13,530 --> 00:19:18,580
half-minute idea is that you take

435
00:19:16,210 --> 00:19:21,520
everything that's a function pointer can

436
00:19:18,580 --> 00:19:24,639
be any point in theory and you sign it

437
00:19:21,520 --> 00:19:26,379
ID process startup for example and so

438
00:19:24,640 --> 00:19:28,210
you do this with a specific instruction

439
00:19:26,380 --> 00:19:29,830
as you can see in the bottom and then

440
00:19:28,210 --> 00:19:33,370
you have a signature and you store that

441
00:19:29,830 --> 00:19:35,620
in the top bits and then before using a

442
00:19:33,370 --> 00:19:38,139
pointer for example for jumping to it

443
00:19:35,620 --> 00:19:41,679
you are CENTAC eight and make sure the

444
00:19:38,140 --> 00:19:44,590
signature is actually valid and if it's

445
00:19:41,680 --> 00:19:47,560
not then you crash and so this prevents

446
00:19:44,590 --> 00:19:51,449
us from doing like directly gaining a

447
00:19:47,560 --> 00:19:54,159
control over the PC program counter

448
00:19:51,450 --> 00:19:57,190
because we we are not able to fake these

449
00:19:54,160 --> 00:20:00,370
these signatures so we need to bypass

450
00:19:57,190 --> 00:20:01,539
back so this pretty much what I said

451
00:20:00,370 --> 00:20:04,719
right we cannot

452
00:20:01,539 --> 00:20:09,669
make these code point us anymore the

453
00:20:04,720 --> 00:20:11,679
idea for the bypass roughly is that why

454
00:20:09,669 --> 00:20:14,159
we cannot use what we cannot fake

455
00:20:11,679 --> 00:20:16,629
classes we can reuse existing classes

456
00:20:14,159 --> 00:20:19,600
and so here in this case I have a fake

457
00:20:16,629 --> 00:20:22,178
objective-c object but it points to real

458
00:20:19,600 --> 00:20:25,238
existing class with signed function

459
00:20:22,179 --> 00:20:28,049
pointers and this will ultimately give

460
00:20:25,239 --> 00:20:31,149
me some form of arbitrary objective-c

461
00:20:28,049 --> 00:20:33,879
method called primitive where we can

462
00:20:31,149 --> 00:20:35,428
call any method or almost any method

463
00:20:33,879 --> 00:20:39,158
with pretty much controlled arguments

464
00:20:35,429 --> 00:20:48,190
and this is powerful enough this is all

465
00:20:39,159 --> 00:20:49,869
that necessary okay so we cannot execute

466
00:20:48,190 --> 00:20:51,849
arbitrary objective-c methods also

467
00:20:49,869 --> 00:20:55,899
outside of the same box because this was

468
00:20:51,849 --> 00:20:58,269
on iOS 12.4 whether the archiving still

469
00:20:55,899 --> 00:21:00,340
happened outside of a sandbox connects

470
00:20:58,269 --> 00:21:03,039
this user data etc we don't care about

471
00:21:00,340 --> 00:21:05,649
that we just want to calculator the way

472
00:21:03,039 --> 00:21:06,940
to do it is you call this one or one way

473
00:21:05,649 --> 00:21:09,518
to do it is you call this one

474
00:21:06,940 --> 00:21:13,169
objective-c method to launch an

475
00:21:09,519 --> 00:21:18,450
application name the calculator and

476
00:21:13,169 --> 00:21:18,450
let's see we can get that to work

477
00:21:23,410 --> 00:21:26,529
[Music]

478
00:21:45,379 --> 00:21:54,119
yeah okay so this is the iPhone I'm

479
00:21:48,419 --> 00:21:56,369
using it's still on 1234 right so this

480
00:21:54,119 --> 00:22:00,570
is the last one a bit version like at

481
00:21:56,369 --> 00:22:02,359
this point more than half a year old and

482
00:22:00,570 --> 00:22:06,769
[Music]

483
00:22:02,359 --> 00:22:11,369
let's start this I hope it works

484
00:22:06,769 --> 00:22:12,599
okay so what what you can see now okay

485
00:22:11,369 --> 00:22:15,559
it's recording it's kind of unnecessary

486
00:22:12,599 --> 00:22:19,019
anyway what you can see now is it's

487
00:22:15,559 --> 00:22:21,749
going to do this linear scanning phase

488
00:22:19,019 --> 00:22:25,249
right and it's nicely telling us what

489
00:22:21,749 --> 00:22:27,719
it's doing at this point

490
00:22:25,249 --> 00:22:30,059
and so it's probing these these

491
00:22:27,719 --> 00:22:34,769
addresses and I think this step is is

492
00:22:30,059 --> 00:22:37,469
128 or 256 megabytes increments and so

493
00:22:34,769 --> 00:22:39,419
it's testing these addresses and it's

494
00:22:37,469 --> 00:22:42,329
not getting a delivery received back so

495
00:22:39,419 --> 00:22:45,719
it assumes okay it crashed and now this

496
00:22:42,329 --> 00:22:48,149
for this one address the hex 1b it did

497
00:22:45,719 --> 00:22:51,659
get a receipt back and don't know us

498
00:22:48,149 --> 00:22:53,428
okay it has found a valid address and it

499
00:22:51,659 --> 00:22:58,109
has it did this this candidate

500
00:22:53,429 --> 00:23:00,749
computation thing and figured it had 32

501
00:22:58,109 --> 00:23:02,458
thousand candidates and now it's going

502
00:23:00,749 --> 00:23:05,569
to roughly half that number in every

503
00:23:02,459 --> 00:23:07,829
with every additional additional message

504
00:23:05,569 --> 00:23:11,459
so you can see it already went down to

505
00:23:07,829 --> 00:23:13,769
fifteen or sixteen thousand roughly and

506
00:23:11,459 --> 00:23:16,079
it will keep doing that and I think I

507
00:23:13,769 --> 00:23:18,479
can actually take questions now while

508
00:23:16,079 --> 00:23:20,789
this runs this will take like another

509
00:23:18,479 --> 00:23:22,469
one or two minutes so maybe it's a good

510
00:23:20,789 --> 00:23:33,299
time to take questions if there are any

511
00:23:22,469 --> 00:23:42,149
at this point all right there no come on

512
00:23:33,299 --> 00:23:43,499
make me run through the room idea I

513
00:23:42,149 --> 00:23:45,299
thank you for it talk first of all I

514
00:23:43,499 --> 00:23:47,039
guess that only works because I miss

515
00:23:45,299 --> 00:23:49,649
like restarting in the background all

516
00:23:47,039 --> 00:23:53,309
the time because it's crashing exactly

517
00:23:49,649 --> 00:23:55,649
right so and this is really important so

518
00:23:53,309 --> 00:23:58,470
the I am agent is just restarted every

519
00:23:55,649 --> 00:24:00,600
time it crashes there's

520
00:23:58,470 --> 00:24:03,660
one ones one thing happen that happens

521
00:24:00,600 --> 00:24:06,360
is if it crashes too quickly there will

522
00:24:03,660 --> 00:24:07,860
be a respawn delay like there will be a

523
00:24:06,360 --> 00:24:10,229
penalty and it won't be restarted for a

524
00:24:07,860 --> 00:24:12,810
couple of minutes and so I always have

525
00:24:10,230 --> 00:24:15,210
to wait about 10 seconds between two

526
00:24:12,810 --> 00:24:17,520
consecutive crashes and this is why I

527
00:24:15,210 --> 00:24:20,400
can only will probe the Oracle every

528
00:24:17,520 --> 00:24:23,270
once every 10 seconds roughly but it's

529
00:24:20,400 --> 00:24:25,950
like it's really not a not a big issue

530
00:24:23,270 --> 00:24:27,540
and this is probably something that

531
00:24:25,950 --> 00:24:30,270
should be fixed if it's not already

532
00:24:27,540 --> 00:24:38,580
fixed that this demon just restarts all

533
00:24:30,270 --> 00:24:46,110
the time you know okay almost through I

534
00:24:38,580 --> 00:24:49,320
think I'm also almost out of time let's

535
00:24:46,110 --> 00:24:54,990
see if it finishes in 30 seconds I don't

536
00:24:49,320 --> 00:25:00,060
think it will but yeah so it has found

537
00:24:54,990 --> 00:25:02,580
the base address now it's 1988 Ruby four

538
00:25:00,060 --> 00:25:06,000
zeros and now it's doing a heap spray

539
00:25:02,580 --> 00:25:08,790
and this is also really really happy

540
00:25:06,000 --> 00:25:12,600
right now I think so I'm like doing this

541
00:25:08,790 --> 00:25:15,120
unless you can say well in 24 steps I'm

542
00:25:12,600 --> 00:25:16,860
very certain with some better

543
00:25:15,120 --> 00:25:19,350
engineering you could do the whole heap

544
00:25:16,860 --> 00:25:21,120
spray in one single message and like to

545
00:25:19,350 --> 00:25:23,459
one sing a message that this heap spray

546
00:25:21,120 --> 00:25:33,090
+ trigger the Bach but I am doing this

547
00:25:23,460 --> 00:25:40,220
in like 25 or so yeah sorry Stefan I I

548
00:25:33,090 --> 00:25:40,220
hope it's gonna work it better okay

549
00:25:45,899 --> 00:25:52,389
okay so let's see so when it triggers

550
00:25:50,679 --> 00:25:54,309
actually the phone freezes the UI

551
00:25:52,389 --> 00:25:56,109
freezes for a couple of seconds I don't

552
00:25:54,309 --> 00:26:00,070
know why but I think that's what

553
00:25:56,109 --> 00:26:05,489
happened now because the second on the

554
00:26:00,070 --> 00:26:08,489
clock the seconds don't move further yes

555
00:26:05,489 --> 00:26:08,489
yes

556
00:26:18,409 --> 00:26:24,870
awesome just just quick quick at least

557
00:26:21,659 --> 00:26:27,990
yeah there is a chance that it fails and

558
00:26:24,870 --> 00:26:31,529
if so do you know why is it possible it

559
00:26:27,990 --> 00:26:33,720
fails so it's possible that it fails but

560
00:26:31,529 --> 00:26:38,909
not nothing that can be that can't be

561
00:26:33,720 --> 00:26:41,909
fixed so one reason is if the there's a

562
00:26:38,909 --> 00:26:45,240
srr bypass if it finds a like writable

563
00:26:41,909 --> 00:26:46,620
page and find something where actual

564
00:26:45,240 --> 00:26:48,419
pointer is then right now this

565
00:26:46,620 --> 00:26:51,449
implementation handles this incorrectly

566
00:26:48,419 --> 00:26:52,950
and also the heaps phrase it would be

567
00:26:51,450 --> 00:26:55,289
much much better if it happened in one

568
00:26:52,950 --> 00:26:58,169
message because now like some allocation

569
00:26:55,289 --> 00:27:00,799
happens between two of these then it

570
00:26:58,169 --> 00:27:00,799
could failure

