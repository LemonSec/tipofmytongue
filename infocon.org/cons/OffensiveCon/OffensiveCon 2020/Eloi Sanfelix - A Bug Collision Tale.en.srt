1
00:00:00,329 --> 00:00:05,790
well hi everyone as Tillman said I'm not

2
00:00:02,970 --> 00:00:08,250
Elissa so this is not an jinx but it's

3
00:00:05,790 --> 00:00:11,820
going to be Android exploitation Android

4
00:00:08,250 --> 00:00:13,379
kernel in particular so well I work for

5
00:00:11,820 --> 00:00:15,230
this company that you may have heard of

6
00:00:13,380 --> 00:00:17,279
which is called blue floss security

7
00:00:15,230 --> 00:00:21,570
which is why I'm the last-minute

8
00:00:17,279 --> 00:00:23,039
replacement of the talk the so the the

9
00:00:21,570 --> 00:00:27,240
bug or the talk is a bit of a story

10
00:00:23,039 --> 00:00:28,560
about oh wait sorry does this work yeah

11
00:00:27,240 --> 00:00:30,570
so I know I have to talk since two days

12
00:00:28,560 --> 00:00:34,469
ago so please be nice to me and stuff

13
00:00:30,570 --> 00:00:38,010
but yeah these slides are prepared for a

14
00:00:34,469 --> 00:00:42,059
while before that anyway so it's a bug

15
00:00:38,010 --> 00:00:43,890
that we found in mid-september 2018 and

16
00:00:42,059 --> 00:00:45,269
some other people also found and we

17
00:00:43,890 --> 00:00:47,550
spend considerable time and frustration

18
00:00:45,270 --> 00:00:50,640
just working through it and I'm gonna

19
00:00:47,550 --> 00:00:52,680
share a bit of that with you guys so

20
00:00:50,640 --> 00:00:56,129
it's a local privilege escalation on

21
00:00:52,680 --> 00:00:57,809
Android we had an exploit for this pixel

22
00:00:56,129 --> 00:01:01,680
serious we tried one and three I believe

23
00:00:57,809 --> 00:01:04,018
maybe even two as well and galaxy s 9

24
00:01:01,680 --> 00:01:06,060
and it's a bug in a driver that will

25
00:01:04,019 --> 00:01:09,540
sound familiar to you anybody heard of

26
00:01:06,060 --> 00:01:10,049
binder so we'll go through that in a

27
00:01:09,540 --> 00:01:12,689
moment

28
00:01:10,049 --> 00:01:14,340
so the first first part of the talk is

29
00:01:12,689 --> 00:01:18,360
going to be a bit of introduction and

30
00:01:14,340 --> 00:01:20,700
warm-up with details about binder so

31
00:01:18,360 --> 00:01:23,549
binder in case you didn't notice yet

32
00:01:20,700 --> 00:01:27,090
it's the the main core IPC mechanism of

33
00:01:23,549 --> 00:01:29,159
Android so there is a kernel driver that

34
00:01:27,090 --> 00:01:30,659
performs the transport part of the

35
00:01:29,159 --> 00:01:32,340
driver so it's in charge of sending

36
00:01:30,659 --> 00:01:34,590
messages from one site to the other and

37
00:01:32,340 --> 00:01:36,000
you know orchestrating all this and they

38
00:01:34,590 --> 00:01:38,070
don't top of it all there is the context

39
00:01:36,000 --> 00:01:40,619
manager which is in the Android world is

40
00:01:38,070 --> 00:01:42,630
called service manager and this is

41
00:01:40,619 --> 00:01:45,030
basically like a service directory like

42
00:01:42,630 --> 00:01:46,649
when you would call to the cable person

43
00:01:45,030 --> 00:01:48,780
say connect me to this number or

44
00:01:46,649 --> 00:01:50,759
whatever so you basically can ask the

45
00:01:48,780 --> 00:01:52,979
service directory I want to talk to the

46
00:01:50,759 --> 00:01:54,540
context service and it will give you a

47
00:01:52,979 --> 00:01:56,939
reference to that contact and you can

48
00:01:54,540 --> 00:01:58,290
talk to it from that point onwards and

49
00:01:56,939 --> 00:02:00,750
on top of that there is a bunch of

50
00:01:58,290 --> 00:02:03,000
libraries that provide the transparent

51
00:02:00,750 --> 00:02:05,579
remote procedure calls an object

52
00:02:03,000 --> 00:02:07,950
serialization and an interesting thing

53
00:02:05,579 --> 00:02:09,359
of binder is that that it's accessible

54
00:02:07,950 --> 00:02:11,400
for every process in the system

55
00:02:09,360 --> 00:02:12,569
including the chrome sandbox and you

56
00:02:11,400 --> 00:02:13,709
know five of sandbox it's just

57
00:02:12,569 --> 00:02:16,469
accessible to everything

58
00:02:13,709 --> 00:02:19,650
on Android so that makes it a potential

59
00:02:16,469 --> 00:02:27,510
target for some sandbox escapes so how

60
00:02:19,650 --> 00:02:32,519
does this work one sec so there is a

61
00:02:27,510 --> 00:02:34,769
sender process which is up here and

62
00:02:32,519 --> 00:02:37,079
there is a receiving process down here

63
00:02:34,769 --> 00:02:40,319
this receiving process has a mapping

64
00:02:37,079 --> 00:02:42,090
this is the blue buffer that's managed

65
00:02:40,319 --> 00:02:43,500
by the binder driver so when you want to

66
00:02:42,090 --> 00:02:45,000
send a message from one side to the

67
00:02:43,500 --> 00:02:46,950
other you make the data that you want to

68
00:02:45,000 --> 00:02:49,379
send and some metadata which is this

69
00:02:46,950 --> 00:02:51,418
offsets part here and you prepare it and

70
00:02:49,379 --> 00:02:53,459
you make a structure that point to it on

71
00:02:51,419 --> 00:02:55,980
your own address space so you basically

72
00:02:53,459 --> 00:02:58,049
say here is some data here is an

73
00:02:55,980 --> 00:03:00,179
opposites I want to talk to the service

74
00:02:58,049 --> 00:03:01,650
with this number this handle and I want

75
00:03:00,180 --> 00:03:04,290
to ask it to do an action that's

76
00:03:01,650 --> 00:03:06,750
transaction called 1 now that goes to

77
00:03:04,290 --> 00:03:09,388
the driver and the driver will take this

78
00:03:06,750 --> 00:03:11,579
and will basically translate these

79
00:03:09,389 --> 00:03:13,469
things or like validated and translate

80
00:03:11,579 --> 00:03:16,169
etcetera and will copy them over to the

81
00:03:13,469 --> 00:03:17,668
other buffer to the destination so at

82
00:03:16,169 --> 00:03:20,090
this point the destination can see this

83
00:03:17,669 --> 00:03:23,310
translated and validated and whatnot

84
00:03:20,090 --> 00:03:25,079
content but it has to read a transaction

85
00:03:23,310 --> 00:03:27,780
to receive it to want to receive it and

86
00:03:25,079 --> 00:03:29,419
when he does that it will get a similar

87
00:03:27,780 --> 00:03:31,889
structure to the one we started with

88
00:03:29,419 --> 00:03:35,069
except that the service the service

89
00:03:31,889 --> 00:03:37,979
handle here has been converted down here

90
00:03:35,069 --> 00:03:39,780
into a service pointer okay so that's

91
00:03:37,979 --> 00:03:41,549
part of what the driver translation

92
00:03:39,780 --> 00:03:43,340
process does it translates handles into

93
00:03:41,549 --> 00:03:45,810
pointers and we'll see what else it does

94
00:03:43,340 --> 00:03:47,340
so yeah this allows us to send data from

95
00:03:45,810 --> 00:03:52,709
one site to the other with an action

96
00:03:47,340 --> 00:03:54,239
code and some objects now what is in

97
00:03:52,709 --> 00:03:56,400
that transaction what are those offsets

98
00:03:54,239 --> 00:03:59,340
right so in a transaction there could be

99
00:03:56,400 --> 00:04:00,810
just opaque data which has no format

100
00:03:59,340 --> 00:04:04,979
it's just the driver doesn't care about

101
00:04:00,810 --> 00:04:06,930
it and there can be of objects at

102
00:04:04,979 --> 00:04:11,009
different offsets within the transaction

103
00:04:06,930 --> 00:04:13,169
so that the offsets array has offsets

104
00:04:11,009 --> 00:04:15,869
into the transaction at which the driver

105
00:04:13,169 --> 00:04:18,989
is going to find objects that it has to

106
00:04:15,870 --> 00:04:20,789
translate and those objects can be of

107
00:04:18,988 --> 00:04:22,409
different types including file

108
00:04:20,789 --> 00:04:23,969
descriptors so it will just send the

109
00:04:22,409 --> 00:04:26,550
file descriptor the same as if you send

110
00:04:23,969 --> 00:04:27,520
them through a UNIX socket it's the same

111
00:04:26,550 --> 00:04:29,620
thing it just appears

112
00:04:27,520 --> 00:04:32,979
the other side and file descriptor erase

113
00:04:29,620 --> 00:04:35,050
there's just many file descriptors then

114
00:04:32,979 --> 00:04:37,389
there are binder objects and these are

115
00:04:35,050 --> 00:04:39,370
like for example the services they're a

116
00:04:37,389 --> 00:04:41,349
binder object they start on the sending

117
00:04:39,370 --> 00:04:42,879
process as an object and when you put

118
00:04:41,349 --> 00:04:45,759
them in a transaction they become a

119
00:04:42,879 --> 00:04:47,470
handle which is an opaque number such

120
00:04:45,759 --> 00:04:49,509
that the other side doesn't learn this

121
00:04:47,470 --> 00:04:52,629
whatever object it is or whatever it

122
00:04:49,509 --> 00:04:54,370
could be but instead it will be

123
00:04:52,629 --> 00:04:56,349
translated into a handle that's process

124
00:04:54,370 --> 00:04:58,690
specific now for each of these objects

125
00:04:56,349 --> 00:05:01,270
there is a binder node which is written

126
00:04:58,690 --> 00:05:03,219
up here this is a structure that's

127
00:05:01,270 --> 00:05:05,680
reference counted and represents this

128
00:05:03,220 --> 00:05:08,050
object for the whole system so anybody

129
00:05:05,680 --> 00:05:10,870
who has a handle to this object will

130
00:05:08,050 --> 00:05:12,490
somehow know that our binder will know

131
00:05:10,870 --> 00:05:14,349
that it refers to this particular object

132
00:05:12,490 --> 00:05:16,630
and it only keeps one copy of the object

133
00:05:14,349 --> 00:05:18,580
but then as many handles as needed and

134
00:05:16,630 --> 00:05:19,900
if you send handles then it depends on

135
00:05:18,580 --> 00:05:22,210
whether you send the handle to the owner

136
00:05:19,900 --> 00:05:23,560
of the process or to another process if

137
00:05:22,210 --> 00:05:25,150
you send the handle to the owner of the

138
00:05:23,560 --> 00:05:27,219
process it will translate it back into a

139
00:05:25,150 --> 00:05:28,719
binder if you send the handle to yet

140
00:05:27,219 --> 00:05:30,639
another process it will translate it

141
00:05:28,719 --> 00:05:32,349
into a new handle for that process and

142
00:05:30,639 --> 00:05:35,530
in this way you can just send objects

143
00:05:32,349 --> 00:05:38,530
around the system such that bind their

144
00:05:35,530 --> 00:05:41,650
nose or actually that the original owner

145
00:05:38,530 --> 00:05:43,568
of the of the the original owner of this

146
00:05:41,650 --> 00:05:45,099
object knows if it receives that object

147
00:05:43,569 --> 00:05:46,539
or if you'll receive something else and

148
00:05:45,099 --> 00:05:49,300
you can use this also as a kind of an

149
00:05:46,539 --> 00:05:53,560
token to pass around for permission

150
00:05:49,300 --> 00:05:54,219
checking and things like that so okay we

151
00:05:53,560 --> 00:05:55,509
have this buffer

152
00:05:54,219 --> 00:05:57,310
we send this buffer around that there

153
00:05:55,509 --> 00:05:58,599
are some objects in there and then when

154
00:05:57,310 --> 00:06:00,909
we're done with the buffer the driver

155
00:05:58,599 --> 00:06:03,580
has to clean this up somehow so when we

156
00:06:00,909 --> 00:06:06,159
give it back to the to the driver the

157
00:06:03,580 --> 00:06:08,050
driver will take a look and see that

158
00:06:06,159 --> 00:06:09,849
there is a target now so who did we send

159
00:06:08,050 --> 00:06:12,669
the transaction to and it will drop a

160
00:06:09,849 --> 00:06:14,860
reference on that then it will check all

161
00:06:12,669 --> 00:06:16,990
the objects in the buffer and release

162
00:06:14,860 --> 00:06:18,940
any kind of references that are in there

163
00:06:16,990 --> 00:06:20,440
and the same will go with file

164
00:06:18,940 --> 00:06:25,960
descriptor erase it will just close

165
00:06:20,440 --> 00:06:28,569
every file descriptor in there and this

166
00:06:25,960 --> 00:06:31,388
of course allows for reusing our objects

167
00:06:28,569 --> 00:06:32,919
and not having just a growing list of

168
00:06:31,389 --> 00:06:36,940
our a drawing buffer that is

169
00:06:32,919 --> 00:06:38,979
indefinitely growing all right so we

170
00:06:36,940 --> 00:06:41,110
start with the bugs these are bugs that

171
00:06:38,979 --> 00:06:44,409
we actually fast

172
00:06:41,110 --> 00:06:46,210
the first bug is you probably I don't

173
00:06:44,410 --> 00:06:49,000
know if it is it readable from oh wait

174
00:06:46,210 --> 00:06:51,310
is it readable from the back yeah okay

175
00:06:49,000 --> 00:06:55,150
so it's a use after free bug in binder

176
00:06:51,310 --> 00:06:56,770
and you can see well down here the

177
00:06:55,150 --> 00:06:59,289
thread stack that allocated it binder

178
00:06:56,770 --> 00:07:01,120
transaction and if you would scroll down

179
00:06:59,290 --> 00:07:03,700
you would see who is using it now and

180
00:07:01,120 --> 00:07:05,320
who freed it right so what do you do

181
00:07:03,700 --> 00:07:07,599
next you try to figure out what this bug

182
00:07:05,320 --> 00:07:09,070
is and what happened so you go to the

183
00:07:07,600 --> 00:07:10,720
place well located a to a place for free

184
00:07:09,070 --> 00:07:13,300
did and you know what's happening here

185
00:07:10,720 --> 00:07:16,390
why is this happening so it turned out

186
00:07:13,300 --> 00:07:18,730
that it was a race condition like many

187
00:07:16,390 --> 00:07:22,300
other bugs that are showing up these

188
00:07:18,730 --> 00:07:24,910
days and the rest condition was related

189
00:07:22,300 --> 00:07:27,040
to this allow user free variable that

190
00:07:24,910 --> 00:07:29,830
you see up here so what's happening here

191
00:07:27,040 --> 00:07:33,400
is on one side on the well on your right

192
00:07:29,830 --> 00:07:35,650
side also mind like this you see the

193
00:07:33,400 --> 00:07:37,870
thread that's receiving a transaction a

194
00:07:35,650 --> 00:07:39,489
one-way transaction and on the right on

195
00:07:37,870 --> 00:07:41,650
the other side thread number two is the

196
00:07:39,490 --> 00:07:45,100
thread that's trying to free a buffer a

197
00:07:41,650 --> 00:07:46,299
transaction buffer now when this is

198
00:07:45,100 --> 00:07:48,280
written this is lock less there is no

199
00:07:46,300 --> 00:07:51,310
locks here so when this is written to

200
00:07:48,280 --> 00:07:55,179
one this guy can go past this point yeah

201
00:07:51,310 --> 00:07:59,260
agreed with that now when we get to the

202
00:07:55,180 --> 00:08:00,940
else branch here and come here then the

203
00:07:59,260 --> 00:08:02,770
transaction buffer it will be checked

204
00:08:00,940 --> 00:08:04,390
and if it's the existing then it will

205
00:08:02,770 --> 00:08:07,030
remove a back pointer to the transaction

206
00:08:04,390 --> 00:08:09,340
to prevent use after free and then it

207
00:08:07,030 --> 00:08:11,859
will kay free the transaction right what

208
00:08:09,340 --> 00:08:16,719
happens however is that if this check

209
00:08:11,860 --> 00:08:18,520
happens before this check then we see a

210
00:08:16,720 --> 00:08:21,430
transaction buffer that's not null but

211
00:08:18,520 --> 00:08:23,440
then if the free here happens before

212
00:08:21,430 --> 00:08:25,450
this particular point in time we're

213
00:08:23,440 --> 00:08:26,680
gonna write a new pointer at an offset

214
00:08:25,450 --> 00:08:30,670
from a transaction that has just been

215
00:08:26,680 --> 00:08:32,470
freed does that make sense now you could

216
00:08:30,670 --> 00:08:34,630
say like you mean you may think that

217
00:08:32,470 --> 00:08:36,010
this is not really that the Kay free

218
00:08:34,630 --> 00:08:37,659
will take much longer than this guy to

219
00:08:36,010 --> 00:08:40,600
come from here to here but you know like

220
00:08:37,659 --> 00:08:44,380
preemption etc also it turns out that

221
00:08:40,600 --> 00:08:46,180
this lookup is cached in a register and

222
00:08:44,380 --> 00:08:48,160
therefore here there is no memory

223
00:08:46,180 --> 00:08:49,359
dereference anymore so that also

224
00:08:48,160 --> 00:08:50,949
increases like you know you're not

225
00:08:49,360 --> 00:08:52,960
fetching the power at the pointer twice

226
00:08:50,950 --> 00:08:54,340
and therefore the second time you don't

227
00:08:52,960 --> 00:08:54,880
see the null so you gives you a little

228
00:08:54,340 --> 00:08:57,370
bit of a big

229
00:08:54,880 --> 00:08:59,830
Windell again anyway this is not the

230
00:08:57,370 --> 00:09:02,110
buggy I'm talking about because we

231
00:08:59,830 --> 00:09:04,480
looked at it and yeah the window it was

232
00:09:02,110 --> 00:09:06,520
pretty small there's no really time to

233
00:09:04,480 --> 00:09:08,890
preempt this thing there's no API there

234
00:09:06,520 --> 00:09:12,490
that allows you to preempt the reuse

235
00:09:08,890 --> 00:09:14,140
path before like you know to make the

236
00:09:12,490 --> 00:09:15,550
window bigger there is no way to go to

237
00:09:14,140 --> 00:09:18,040
user space or no logs or anything

238
00:09:15,550 --> 00:09:19,359
happening there and you can only write a

239
00:09:18,040 --> 00:09:20,829
new let a certain offset which it's

240
00:09:19,360 --> 00:09:23,020
useful but if you add it to all these

241
00:09:20,830 --> 00:09:24,970
other conditions then we had the feeling

242
00:09:23,020 --> 00:09:27,819
that we could look for something better

243
00:09:24,970 --> 00:09:30,160
right but I still wanted to make sure

244
00:09:27,820 --> 00:09:31,540
that this was actually the bug that I

245
00:09:30,160 --> 00:09:34,150
was triggering with the fuzzer so I made

246
00:09:31,540 --> 00:09:38,020
a POC for this and you know I made some

247
00:09:34,150 --> 00:09:40,510
semi random racing between these two

248
00:09:38,020 --> 00:09:42,610
conditions and I just ran it for a bit

249
00:09:40,510 --> 00:09:45,460
and immediately started seeing trash

250
00:09:42,610 --> 00:09:48,040
locks different from the original bug

251
00:09:45,460 --> 00:09:49,750
actually so this bug number two which

252
00:09:48,040 --> 00:09:53,319
the father also found but like a week

253
00:09:49,750 --> 00:09:55,930
later this is a kernel bug and if you're

254
00:09:53,320 --> 00:09:58,180
familiar with Linux kernel this doesn't

255
00:09:55,930 --> 00:09:59,770
mean that there is like a it's not

256
00:09:58,180 --> 00:10:01,569
necessarily mean something really bad it

257
00:09:59,770 --> 00:10:03,340
just means you violated an assumption

258
00:10:01,570 --> 00:10:06,910
that they live elaborate encoded in a

259
00:10:03,340 --> 00:10:09,820
sort of assert okay so what assumption

260
00:10:06,910 --> 00:10:11,380
did we did we violate well we violated

261
00:10:09,820 --> 00:10:13,720
the fact that we're freeing a buffer for

262
00:10:11,380 --> 00:10:17,080
a second time and it was free and again

263
00:10:13,720 --> 00:10:19,510
when we look at it it's again with the

264
00:10:17,080 --> 00:10:22,720
culprit with the allow user free

265
00:10:19,510 --> 00:10:24,850
variable which is also unlocked the

266
00:10:22,720 --> 00:10:27,070
update is unlocked it turns out that

267
00:10:24,850 --> 00:10:27,550
when these buffer is returned from the

268
00:10:27,070 --> 00:10:29,590
allocator

269
00:10:27,550 --> 00:10:31,359
if the buffer was ever used for a

270
00:10:29,590 --> 00:10:33,280
previous transaction it already had this

271
00:10:31,360 --> 00:10:36,190
flag set to one so this gives me a

272
00:10:33,280 --> 00:10:38,500
window from this point to this point to

273
00:10:36,190 --> 00:10:40,990
come in and free this buffer and pass

274
00:10:38,500 --> 00:10:42,940
this check yeah so now I'm going to have

275
00:10:40,990 --> 00:10:45,070
a transaction that's processing a buffer

276
00:10:42,940 --> 00:10:46,480
and a transaction that's freeing the

277
00:10:45,070 --> 00:10:48,880
buffer in at the same time the same

278
00:10:46,480 --> 00:10:51,750
buffer so this transaction will probably

279
00:10:48,880 --> 00:10:53,980
do something weird with this buffer

280
00:10:51,750 --> 00:10:55,990
there is one thing these buffers are not

281
00:10:53,980 --> 00:10:57,880
necessarily came out of buffers they are

282
00:10:55,990 --> 00:11:01,950
just in the V malloc space and it's not

283
00:10:57,880 --> 00:11:01,950
like a heap use after free just yet

284
00:11:02,640 --> 00:11:08,260
so yeah this is the body that we're

285
00:11:05,740 --> 00:11:08,830
going to talk about and it's going to be

286
00:11:08,260 --> 00:11:12,730
pro

287
00:11:08,830 --> 00:11:15,360
a bumpy ride so let's see the thing is

288
00:11:12,730 --> 00:11:18,670
at this point I went to have a party and

289
00:11:15,360 --> 00:11:20,800
yeah I spent some time in the flight

290
00:11:18,670 --> 00:11:22,540
just you know trying to trigger this bug

291
00:11:20,800 --> 00:11:25,329
in a more controllable way and trying to

292
00:11:22,540 --> 00:11:28,839
find something interesting with it

293
00:11:25,330 --> 00:11:30,790
and yeah I just got random bug checks

294
00:11:28,840 --> 00:11:33,580
everywhere and I couldn't get past those

295
00:11:30,790 --> 00:11:34,689
in any way and my mood was if you ask

296
00:11:33,580 --> 00:11:35,860
some of my colleagues it was like yeah

297
00:11:34,690 --> 00:11:40,480
no way I'm gonna exploit this in a

298
00:11:35,860 --> 00:11:42,580
reliable way in this kind of bug but

299
00:11:40,480 --> 00:11:44,560
luckily I have colleagues so somebody

300
00:11:42,580 --> 00:11:48,460
stayed working and that was called

301
00:11:44,560 --> 00:11:50,170
Jordan he's around I don't know where he

302
00:11:48,460 --> 00:11:52,810
had a good idea during that week so he

303
00:11:50,170 --> 00:11:55,510
stayed back home he worked on this the

304
00:11:52,810 --> 00:11:57,849
idea was related to basically sending a

305
00:11:55,510 --> 00:11:59,350
fake transaction first with fake objects

306
00:11:57,850 --> 00:12:02,740
so preparing the transaction with fake

307
00:11:59,350 --> 00:12:05,320
objects first but not passing an offsets

308
00:12:02,740 --> 00:12:06,880
sighs so you say there are no objects to

309
00:12:05,320 --> 00:12:08,680
the binder driver so the binder will

310
00:12:06,880 --> 00:12:12,670
treat this as pure data and just put it

311
00:12:08,680 --> 00:12:14,050
in there right now if we free this so we

312
00:12:12,670 --> 00:12:16,000
receive the buffer we free it and now

313
00:12:14,050 --> 00:12:18,099
it's available for the next transaction

314
00:12:16,000 --> 00:12:20,470
but the data is not cleared it stays

315
00:12:18,100 --> 00:12:23,440
there so now we have some fake objects

316
00:12:20,470 --> 00:12:25,600
sitting there now if we try to now

317
00:12:23,440 --> 00:12:27,070
create a new transaction in which we

318
00:12:25,600 --> 00:12:29,620
tell the driver that there is actually

319
00:12:27,070 --> 00:12:31,270
offset but we race with the bug what

320
00:12:29,620 --> 00:12:33,910
will happen is that the free path will

321
00:12:31,270 --> 00:12:35,439
release objects that were not validated

322
00:12:33,910 --> 00:12:36,850
by the driver so it will release

323
00:12:35,440 --> 00:12:40,810
arbitrary objects with arbitrary

324
00:12:36,850 --> 00:12:43,570
contents and therefore we can free we

325
00:12:40,810 --> 00:12:46,479
can free fake objects yeah but these are

326
00:12:43,570 --> 00:12:48,490
not objects as in like kernel objects

327
00:12:46,480 --> 00:12:50,050
yes it's not an arbitrary K free it's a

328
00:12:48,490 --> 00:12:52,110
release of a binder object from the

329
00:12:50,050 --> 00:12:55,630
transaction so let's see what that means

330
00:12:52,110 --> 00:12:58,630
but first well with that particular pork

331
00:12:55,630 --> 00:13:00,970
what we had was that this binder type

332
00:12:58,630 --> 00:13:03,670
FDA so a file descriptor array was being

333
00:13:00,970 --> 00:13:07,000
freed prematurely with uncontrolled data

334
00:13:03,670 --> 00:13:09,880
or I'm verify data and that thing has a

335
00:13:07,000 --> 00:13:13,270
parent buffer which we then controlled

336
00:13:09,880 --> 00:13:15,010
so that's a pointer which points in this

337
00:13:13,270 --> 00:13:16,870
case in to user land but then the kernel

338
00:13:15,010 --> 00:13:19,300
does some computation to compute the

339
00:13:16,870 --> 00:13:22,310
kernel alias of this user land pointer

340
00:13:19,300 --> 00:13:24,890
and then it the reference is it here

341
00:13:22,310 --> 00:13:28,099
down at the bottom so basically with

342
00:13:24,890 --> 00:13:29,960
this pot we could basically read from

343
00:13:28,100 --> 00:13:31,850
semi-controlled addresses and closed

344
00:13:29,960 --> 00:13:33,650
file list semi arbitrary file

345
00:13:31,850 --> 00:13:36,650
descriptors if we could do this but

346
00:13:33,650 --> 00:13:38,270
there is more switch cases up here next

347
00:13:36,650 --> 00:13:44,000
to this one that may be more interesting

348
00:13:38,270 --> 00:13:45,890
right so this means as I said we can

349
00:13:44,000 --> 00:13:48,070
force the release of fake objects one of

350
00:13:45,890 --> 00:13:50,089
them is valid file descriptor arrays and

351
00:13:48,070 --> 00:13:51,680
actually this is very useful you would

352
00:13:50,089 --> 00:13:53,420
say like what what do I do with a closed

353
00:13:51,680 --> 00:13:54,529
file descriptor but there are some

354
00:13:53,420 --> 00:13:56,120
things you can do and for this

355
00:13:54,529 --> 00:13:58,400
particular bug we use these to know

356
00:13:56,120 --> 00:13:59,660
whether we trigger the race or not so we

357
00:13:58,400 --> 00:14:02,360
have a thread just looking at the file

358
00:13:59,660 --> 00:14:04,490
descriptor and we have the race thread

359
00:14:02,360 --> 00:14:06,290
release the file descriptor and when our

360
00:14:04,490 --> 00:14:09,220
thread says like invalid file descriptor

361
00:14:06,290 --> 00:14:11,750
then we know we want d'être their race

362
00:14:09,220 --> 00:14:13,250
then on the other hand we have binary

363
00:14:11,750 --> 00:14:15,740
objects and I said in the beginning they

364
00:14:13,250 --> 00:14:17,779
are reference counted so what you put in

365
00:14:15,740 --> 00:14:20,510
there is just a descriptor of the object

366
00:14:17,779 --> 00:14:22,760
this pointer that identifies the object

367
00:14:20,510 --> 00:14:24,650
and then the binder will look up the

368
00:14:22,760 --> 00:14:26,750
object the heap object and we'll drop a

369
00:14:24,650 --> 00:14:28,939
reference to it because it was acquired

370
00:14:26,750 --> 00:14:30,440
during the translation process so now we

371
00:14:28,940 --> 00:14:33,950
have a primitive that allows us to drop

372
00:14:30,440 --> 00:14:36,440
references on arbitrary arbitrary binder

373
00:14:33,950 --> 00:14:38,600
objects at least minor objects that

374
00:14:36,440 --> 00:14:41,510
represent arbitrary notes that we sent

375
00:14:38,600 --> 00:14:43,220
through binder and of course if you

376
00:14:41,510 --> 00:14:45,319
decrement the references to zero then

377
00:14:43,220 --> 00:14:46,640
the system things they are not used and

378
00:14:45,320 --> 00:14:51,320
it will free them and you get to use

379
00:14:46,640 --> 00:14:54,080
after free so what's the high-level plan

380
00:14:51,320 --> 00:14:56,020
to summarize the beast first we refill

381
00:14:54,080 --> 00:15:00,020
transaction buffer with fake objects

382
00:14:56,020 --> 00:15:03,500
next we free the transaction buffer so

383
00:15:00,020 --> 00:15:05,959
that allow user 3 is 1 next we make a

384
00:15:03,500 --> 00:15:07,580
transaction which has data and offsets

385
00:15:05,959 --> 00:15:10,550
such that the driver will process the

386
00:15:07,580 --> 00:15:13,670
day pointer the objects that we prepared

387
00:15:10,550 --> 00:15:15,500
in there and make we make the racing the

388
00:15:13,670 --> 00:15:17,329
sending side fail quickly to make it

389
00:15:15,500 --> 00:15:19,279
exit fast and not process these fake

390
00:15:17,330 --> 00:15:20,810
objects because otherwise it will start

391
00:15:19,279 --> 00:15:24,500
translating them and it will make a mess

392
00:15:20,810 --> 00:15:26,630
of them and then on another thread we

393
00:15:24,500 --> 00:15:29,029
erase these to cause the free of these

394
00:15:26,630 --> 00:15:32,689
objects and then from the monitor thread

395
00:15:29,029 --> 00:15:33,920
we will be looking to know when we when

396
00:15:32,690 --> 00:15:36,140
we trigger the race so we can stop

397
00:15:33,920 --> 00:15:39,319
racing and continue with the exploit

398
00:15:36,140 --> 00:15:40,730
and after that after that Palace

399
00:15:39,320 --> 00:15:43,100
creature is closed we will also tinker

400
00:15:40,730 --> 00:15:44,900
with reference counts to calls use after

401
00:15:43,100 --> 00:15:46,400
freeze and now we will use those to use

402
00:15:44,900 --> 00:15:49,720
after freeze to somehow get Colonel

403
00:15:46,400 --> 00:15:52,370
readwrite access and from their profit

404
00:15:49,720 --> 00:15:54,800
okay but there are a few problems

405
00:15:52,370 --> 00:15:59,680
problem number one is that if we raise

406
00:15:54,800 --> 00:16:03,800
this thing and we get to this point here

407
00:15:59,680 --> 00:16:06,050
after the freeing path has been has

408
00:16:03,800 --> 00:16:08,240
reached a free point it will be set to

409
00:16:06,050 --> 00:16:09,979
no less buffer so it will have set this

410
00:16:08,240 --> 00:16:12,050
buffer to null and then we trigger a

411
00:16:09,980 --> 00:16:14,990
crash in a null pointer the reference or

412
00:16:12,050 --> 00:16:16,459
whatever exception so yeah that's not

413
00:16:14,990 --> 00:16:19,130
nice we have to make sure that this

414
00:16:16,460 --> 00:16:21,950
doesn't happen there is also a bunch of

415
00:16:19,130 --> 00:16:24,130
bug ons that Linux keeps ranting about

416
00:16:21,950 --> 00:16:27,320
but developers keep adding to their code

417
00:16:24,130 --> 00:16:29,090
and this one so this one here was in

418
00:16:27,320 --> 00:16:31,190
particular the one that was being hit by

419
00:16:29,090 --> 00:16:33,010
the by the fuzzer but then we have a

420
00:16:31,190 --> 00:16:36,890
bunch of other ones that may or may not

421
00:16:33,010 --> 00:16:38,750
occur once we enter this this buffer

422
00:16:36,890 --> 00:16:40,550
free flow function for the second time

423
00:16:38,750 --> 00:16:42,080
so the first time around this is all

424
00:16:40,550 --> 00:16:44,150
fine but the second time this one is set

425
00:16:42,080 --> 00:16:47,630
to one transaction is set to null and

426
00:16:44,150 --> 00:16:50,689
then this data may or may not be good so

427
00:16:47,630 --> 00:16:52,370
we have like five asserts to get through

428
00:16:50,690 --> 00:16:55,850
before we can do anything useful with

429
00:16:52,370 --> 00:16:57,530
this otherwise we will crash and yeah

430
00:16:55,850 --> 00:16:59,240
for our approach to work we need to be

431
00:16:57,530 --> 00:17:03,110
on both sides of a transaction sender

432
00:16:59,240 --> 00:17:05,870
and receiver because we need to know the

433
00:17:03,110 --> 00:17:08,180
pointers the user space pointers or well

434
00:17:05,869 --> 00:17:11,510
expected pointers from the binder notes

435
00:17:08,180 --> 00:17:13,550
and we also it's also convenient for

436
00:17:11,510 --> 00:17:15,109
easier synchronization it's not like the

437
00:17:13,550 --> 00:17:19,579
main requirement is because of the

438
00:17:15,109 --> 00:17:21,139
binder notes now the talking to talking

439
00:17:19,579 --> 00:17:22,879
to yourself kind of thing is not really

440
00:17:21,140 --> 00:17:25,100
something that happens on Android not

441
00:17:22,880 --> 00:17:26,480
often because as I said earlier if you

442
00:17:25,099 --> 00:17:28,520
try to get if you get a handle to

443
00:17:26,480 --> 00:17:30,050
yourself it becomes a pointer and you

444
00:17:28,520 --> 00:17:32,690
can only talk to handles so how do we

445
00:17:30,050 --> 00:17:35,389
deal with this but it turns out that the

446
00:17:32,690 --> 00:17:38,690
binder driver has like for them file

447
00:17:35,390 --> 00:17:40,370
descriptors match processes right and

448
00:17:38,690 --> 00:17:41,870
there are some tricks through for

449
00:17:40,370 --> 00:17:44,629
example the token manager written down

450
00:17:41,870 --> 00:17:47,510
here which was disclosed in one of the

451
00:17:44,630 --> 00:17:48,950
project zero issues a while back with

452
00:17:47,510 --> 00:17:50,030
that one you can get a handle to

453
00:17:48,950 --> 00:17:51,500
yourself like you can put

454
00:17:50,030 --> 00:17:52,970
and then you can later look up the

455
00:17:51,500 --> 00:17:55,580
handle as long as you know some secret

456
00:17:52,970 --> 00:17:57,800
number so this one is very convenient to

457
00:17:55,580 --> 00:17:59,840
make binder allow you to talk to

458
00:17:57,800 --> 00:18:02,030
yourself now you can have two processes

459
00:17:59,840 --> 00:18:03,889
that have the ability to talk with each

460
00:18:02,030 --> 00:18:07,250
other through binder without bothering

461
00:18:03,890 --> 00:18:08,930
any anything else in the system but

462
00:18:07,250 --> 00:18:11,120
these also limits us to non sandbox

463
00:18:08,930 --> 00:18:12,980
processes so the bug was reachable from

464
00:18:11,120 --> 00:18:14,629
the sandbox but we didn't see a good way

465
00:18:12,980 --> 00:18:16,910
to exploit it and we went for this way

466
00:18:14,630 --> 00:18:18,320
which then now from that point on we

467
00:18:16,910 --> 00:18:22,550
cannot do sandbox escape with this bug

468
00:18:18,320 --> 00:18:25,610
or with this approach and on top of that

469
00:18:22,550 --> 00:18:28,159
you know all mitigations kernel SLR PNP

470
00:18:25,610 --> 00:18:30,790
xn which are the armed equivalents to

471
00:18:28,160 --> 00:18:33,380
snap and snap if you are into Intel and

472
00:18:30,790 --> 00:18:34,970
yeah it was like the pixel 3 came out

473
00:18:33,380 --> 00:18:36,830
right at the time we were working on

474
00:18:34,970 --> 00:18:39,050
this and came out with control flow

475
00:18:36,830 --> 00:18:41,379
integrity and Samsung also has their own

476
00:18:39,050 --> 00:18:44,720
flavour on their phones for a while and

477
00:18:41,380 --> 00:18:47,090
on top of that Samsung has this our KP

478
00:18:44,720 --> 00:18:48,620
you heard about yesterday which also

479
00:18:47,090 --> 00:18:52,209
does some protection things that prevent

480
00:18:48,620 --> 00:18:55,280
us from exploding in certain ways so

481
00:18:52,210 --> 00:19:03,710
yeah it's a long road with hopefully

482
00:18:55,280 --> 00:19:06,470
root shells at the end so the roadmap is

483
00:19:03,710 --> 00:19:09,500
I broke this down into like five easy

484
00:19:06,470 --> 00:19:11,300
steps avoid a nullpointerexception five

485
00:19:09,500 --> 00:19:12,530
or six I don't know do I know to count

486
00:19:11,300 --> 00:19:13,970
yeah

487
00:19:12,530 --> 00:19:15,800
avoid the boo null pointer exception

488
00:19:13,970 --> 00:19:18,260
first the bug on crashes then use the

489
00:19:15,800 --> 00:19:20,540
use after free to bypass ksl are in some

490
00:19:18,260 --> 00:19:23,570
way so get some pointers to start

491
00:19:20,540 --> 00:19:25,370
working with then use the use after free

492
00:19:23,570 --> 00:19:27,980
again to get rid right access and then

493
00:19:25,370 --> 00:19:32,149
clean everything up in case we corrupted

494
00:19:27,980 --> 00:19:33,860
things and get root so yeah

495
00:19:32,150 --> 00:19:35,420
number one avoiding the null pointer

496
00:19:33,860 --> 00:19:36,649
exception and for this one in the next

497
00:19:35,420 --> 00:19:39,650
one there are two ways of doing things

498
00:19:36,650 --> 00:19:42,980
and yeah my way for this one was

499
00:19:39,650 --> 00:19:46,070
basically just run some code in fast

500
00:19:42,980 --> 00:19:47,840
CPUs and run some code and slow CPUs if

501
00:19:46,070 --> 00:19:50,240
you've looked at the arm there is big

502
00:19:47,840 --> 00:19:51,800
little architectures and therefore you

503
00:19:50,240 --> 00:19:53,330
look you have usually four cores that

504
00:19:51,800 --> 00:19:55,250
are big and four cores that are small or

505
00:19:53,330 --> 00:19:58,730
two and two and they have different

506
00:19:55,250 --> 00:20:01,010
properties so I played around scheduler

507
00:19:58,730 --> 00:20:03,389
properties to just pin different threads

508
00:20:01,010 --> 00:20:06,419
to different CPUs and I got two

509
00:20:03,389 --> 00:20:09,059
pretty reliably get through the the null

510
00:20:06,419 --> 00:20:11,249
pointer the reference without crashing

511
00:20:09,059 --> 00:20:14,329
still happens every like 200 attempts or

512
00:20:11,249 --> 00:20:16,459
something but you know it's not too bad

513
00:20:14,329 --> 00:20:19,320
so this kind of works but it needs

514
00:20:16,459 --> 00:20:21,149
tweaking per device and you know the

515
00:20:19,320 --> 00:20:22,950
scientific and proper way of doing this

516
00:20:21,149 --> 00:20:26,748
is what my colleague did which is

517
00:20:22,950 --> 00:20:29,909
playing with with the conventional

518
00:20:26,749 --> 00:20:32,579
unlocks and I think in this case it was

519
00:20:29,909 --> 00:20:34,409
some mutex contentions where when you

520
00:20:32,579 --> 00:20:36,509
release a mutex if it has waiters then

521
00:20:34,409 --> 00:20:37,829
there are calls into the scheduler and

522
00:20:36,509 --> 00:20:39,570
these allows pre-empting at the right

523
00:20:37,829 --> 00:20:45,629
moment so that you can have a bigger

524
00:20:39,570 --> 00:20:48,119
window to do your exploit right so this

525
00:20:45,629 --> 00:20:51,168
is out of the way now on to the bug on

526
00:20:48,119 --> 00:20:54,809
crashes again I went for the ugly way

527
00:20:51,169 --> 00:20:57,179
which was you know I saw I said that

528
00:20:54,809 --> 00:20:59,039
there is this monitoring thread right so

529
00:20:57,179 --> 00:21:01,259
once this monitoring thread releases a

530
00:20:59,039 --> 00:21:02,908
file descriptor we know that we won the

531
00:21:01,259 --> 00:21:04,139
race so what I'm going to do is I'm

532
00:21:02,909 --> 00:21:07,079
going to pin this thread it with the

533
00:21:04,139 --> 00:21:10,168
exact same same CPU as the thread that's

534
00:21:07,079 --> 00:21:13,259
gonna cost trouble later on ok and now

535
00:21:10,169 --> 00:21:15,179
I'm going to cause I use after free with

536
00:21:13,259 --> 00:21:17,009
my bug right and then from that use

537
00:21:15,179 --> 00:21:18,809
after free with the monitor what I'll do

538
00:21:17,009 --> 00:21:21,269
is I'll reframe the object reclaim the

539
00:21:18,809 --> 00:21:24,059
object replace it with some object that

540
00:21:21,269 --> 00:21:27,179
has an acquired spin lock and then

541
00:21:24,059 --> 00:21:31,259
acquire it so now we go into a spin law

542
00:21:27,179 --> 00:21:32,820
which is non pre-emptive and the CPU

543
00:21:31,259 --> 00:21:36,570
completely hangs but hey we have eight

544
00:21:32,820 --> 00:21:40,049
so you know we can fix it later it's

545
00:21:36,570 --> 00:21:41,789
it's annoying it's ugly you know like

546
00:21:40,049 --> 00:21:42,959
when your link doesn't work well or when

547
00:21:41,789 --> 00:21:44,940
the other thing doesn't work well then

548
00:21:42,959 --> 00:21:46,859
you your CPU is hanging and then you

549
00:21:44,940 --> 00:21:48,419
have to reboot your phone especially if

550
00:21:46,859 --> 00:21:50,519
you're developing the exploit then this

551
00:21:48,419 --> 00:21:53,329
is a nightmare but there is also the

552
00:21:50,519 --> 00:21:57,869
smart way to do this again from Jordan

553
00:21:53,329 --> 00:21:59,820
he saw that I swear I tried this before

554
00:21:57,869 --> 00:22:01,559
but it didn't work so but anyway he

555
00:21:59,820 --> 00:22:03,958
started sending a transaction and at the

556
00:22:01,559 --> 00:22:06,479
right time would reuse the buffer and

557
00:22:03,959 --> 00:22:09,229
would set the freed thing that was

558
00:22:06,479 --> 00:22:11,070
causing problems to zero again and

559
00:22:09,229 --> 00:22:12,749
everything else would match because it

560
00:22:11,070 --> 00:22:15,418
was a proper buffer that had been reused

561
00:22:12,749 --> 00:22:17,190
then it became like a like a reuse of

562
00:22:15,419 --> 00:22:19,349
the freed buffer like I used up for free

563
00:22:17,190 --> 00:22:23,909
but with the right data so we get past

564
00:22:19,349 --> 00:22:25,649
we can pass the whole yeah the whole how

565
00:22:23,909 --> 00:22:27,840
do you say it yeah the whole set of

566
00:22:25,649 --> 00:22:29,340
asserts at once so this was very nice

567
00:22:27,840 --> 00:22:31,830
because you know I got rid of one use

568
00:22:29,340 --> 00:22:33,629
after free in my exploit so this is what

569
00:22:31,830 --> 00:22:37,769
I used at the end when my whole exploit

570
00:22:33,629 --> 00:22:39,299
worked and everything but anyway so the

571
00:22:37,769 --> 00:22:42,869
crashes are out of the way at least the

572
00:22:39,299 --> 00:22:44,580
stupid ones now we want to get arbitrary

573
00:22:42,869 --> 00:22:46,320
read or well actually we want to bypass

574
00:22:44,580 --> 00:22:48,090
castle Arduino no point is right now

575
00:22:46,320 --> 00:22:52,559
there is case a lot we know nothing

576
00:22:48,090 --> 00:22:54,029
about it currently so because its use

577
00:22:52,559 --> 00:22:57,749
after free we need to do some hips

578
00:22:54,029 --> 00:23:01,109
praying yeah or well reallocated with

579
00:22:57,749 --> 00:23:04,700
control contents now what comes next in

580
00:23:01,109 --> 00:23:07,678
the slice yeah so most known and generic

581
00:23:04,700 --> 00:23:09,539
convenient ways to do to do hips praying

582
00:23:07,679 --> 00:23:11,729
wouldn't work on Android back then I

583
00:23:09,539 --> 00:23:15,119
think many phones came with config is

584
00:23:11,729 --> 00:23:18,629
equals no which rules out key control

585
00:23:15,119 --> 00:23:20,639
based spraying CCSVI PC is usually also

586
00:23:18,629 --> 00:23:21,539
no in at least in the common kernels I

587
00:23:20,639 --> 00:23:24,599
don't know if there are kernels out

588
00:23:21,539 --> 00:23:27,899
there that let use it and user folded

589
00:23:24,599 --> 00:23:31,428
these also disabled so you cannot use

590
00:23:27,899 --> 00:23:34,018
these nice techniques that are out there

591
00:23:31,429 --> 00:23:35,309
there is another complication that well

592
00:23:34,019 --> 00:23:37,379
yeah it's sometimes a complication

593
00:23:35,309 --> 00:23:39,418
sometimes a blessing but all the objects

594
00:23:37,379 --> 00:23:40,619
that are less than hundred 28 bytes but

595
00:23:39,419 --> 00:23:42,899
at least at this point it was like this

596
00:23:40,619 --> 00:23:45,779
all of them would go to the hundred

597
00:23:42,899 --> 00:23:48,359
twenty eight byte came Alex lab so

598
00:23:45,779 --> 00:23:49,710
that's it's annoying because like you

599
00:23:48,359 --> 00:23:51,059
know all sort of unrelated things will

600
00:23:49,710 --> 00:23:52,529
come to your slab but it's also maybe

601
00:23:51,059 --> 00:23:53,970
good because all sort of unrelated

602
00:23:52,529 --> 00:23:57,080
things will come to your slab and you

603
00:23:53,970 --> 00:23:59,669
can use use them for the use after free

604
00:23:57,080 --> 00:24:02,428
so we went for send message based

605
00:23:59,669 --> 00:24:04,409
spraying it's a known method it has full

606
00:24:02,429 --> 00:24:07,379
control of or almost full control of

607
00:24:04,409 --> 00:24:09,809
size contents and also lifetime if you

608
00:24:07,379 --> 00:24:13,139
do it the way that we were doing it but

609
00:24:09,809 --> 00:24:14,999
in that way it requires one thread per

610
00:24:13,139 --> 00:24:16,228
allocated object kind of similar to the

611
00:24:14,999 --> 00:24:17,429
user fault of D because you have to

612
00:24:16,229 --> 00:24:20,820
block the thread so that it doesn't get

613
00:24:17,429 --> 00:24:23,729
freed and this works because send

614
00:24:20,820 --> 00:24:25,589
message has came a lock up here with a

615
00:24:23,729 --> 00:24:29,279
control length as long as we pass a

616
00:24:25,589 --> 00:24:30,929
certain minimum and then it has a copy

617
00:24:29,279 --> 00:24:33,210
from user here

618
00:24:30,930 --> 00:24:35,400
with our data and then it does some

619
00:24:33,210 --> 00:24:38,130
things and then it fries it on the way

620
00:24:35,400 --> 00:24:40,830
out so what we do is we make sure that

621
00:24:38,130 --> 00:24:43,020
these blocks somewhere here and you know

622
00:24:40,830 --> 00:24:44,309
like you can just make a full buffer in

623
00:24:43,020 --> 00:24:45,900
the socket or things like that and

624
00:24:44,309 --> 00:24:47,520
socket operations are there are Soviet

625
00:24:45,900 --> 00:24:48,750
operations that are blocking so you

626
00:24:47,520 --> 00:24:50,280
could block the send message at the

627
00:24:48,750 --> 00:24:56,700
right time and your thread stays there

628
00:24:50,280 --> 00:24:59,300
until you unblock it later on so from

629
00:24:56,700 --> 00:25:02,520
there we need to leak data we have this

630
00:24:59,300 --> 00:25:06,870
binder node that we freed so that's this

631
00:25:02,520 --> 00:25:09,420
target node up here and when you receive

632
00:25:06,870 --> 00:25:10,919
a transaction there are two pointers

633
00:25:09,420 --> 00:25:12,929
that are taken out of that binder node

634
00:25:10,920 --> 00:25:18,000
and they're given to you to user land

635
00:25:12,929 --> 00:25:19,620
and that's the PTR and the cookie so and

636
00:25:18,000 --> 00:25:21,420
these are just copied to users so you

637
00:25:19,620 --> 00:25:23,428
can just read them so what we do is we

638
00:25:21,420 --> 00:25:25,320
have to find an object that has

639
00:25:23,429 --> 00:25:30,510
something nice to leak at those two

640
00:25:25,320 --> 00:25:32,100
offsets okay but this is during a

641
00:25:30,510 --> 00:25:34,110
transaction received and we are working

642
00:25:32,100 --> 00:25:36,209
with transactions to trigger the bug so

643
00:25:34,110 --> 00:25:39,270
and we have to receive transactions also

644
00:25:36,210 --> 00:25:42,210
Sofie usually if any thread

645
00:25:39,270 --> 00:25:43,470
yeah if any thread that's a looper in

646
00:25:42,210 --> 00:25:45,059
binder tries to read the transaction

647
00:25:43,470 --> 00:25:47,070
they will get the first transaction

648
00:25:45,059 --> 00:25:49,139
that's available and these will

649
00:25:47,070 --> 00:25:50,820
basically make a problem with our bug

650
00:25:49,140 --> 00:25:53,010
because we cannot trigger the bug and

651
00:25:50,820 --> 00:25:55,919
keep the transaction that was before it

652
00:25:53,010 --> 00:25:58,980
pending but there is a semi complicated

653
00:25:55,920 --> 00:26:01,890
way of doing of doing that which is

654
00:25:58,980 --> 00:26:04,590
basically having nested transactions so

655
00:26:01,890 --> 00:26:07,200
what you do is you start with one thread

656
00:26:04,590 --> 00:26:09,800
you call into thread B and then that

657
00:26:07,200 --> 00:26:11,790
thread B calls back into thread a and

658
00:26:09,800 --> 00:26:13,440
because it's in the context of an

659
00:26:11,790 --> 00:26:15,450
already existing transaction it goes

660
00:26:13,440 --> 00:26:16,950
specifically to thread a because it

661
00:26:15,450 --> 00:26:18,960
could be a callback on an object that

662
00:26:16,950 --> 00:26:21,540
thread a provided so we'd rather have

663
00:26:18,960 --> 00:26:22,770
that thread handle it and the same

664
00:26:21,540 --> 00:26:26,428
happens if we do a third transaction

665
00:26:22,770 --> 00:26:28,650
from here to this one it's still in the

666
00:26:26,429 --> 00:26:31,470
context of an outer transaction so we

667
00:26:28,650 --> 00:26:34,710
end up queuing this transactions for one

668
00:26:31,470 --> 00:26:36,750
specific specific thread with this we

669
00:26:34,710 --> 00:26:39,150
can just dedicate this thread to a leak

670
00:26:36,750 --> 00:26:40,950
and wait until they use after free has

671
00:26:39,150 --> 00:26:43,140
happened receive the transaction and we

672
00:26:40,950 --> 00:26:44,519
leak two pointers or well hopefully two

673
00:26:43,140 --> 00:26:48,059
pointers I mean if I look to none

674
00:26:44,519 --> 00:26:49,830
zero not useful but now we have to

675
00:26:48,059 --> 00:26:53,279
figure out what object to replace this

676
00:26:49,830 --> 00:26:54,589
with so when you have a hammer

677
00:26:53,279 --> 00:26:57,839
everything looks like a nail

678
00:26:54,589 --> 00:27:01,080
so I used Ida I went to either a

679
00:26:57,839 --> 00:27:05,479
structure size and you know growth by by

680
00:27:01,080 --> 00:27:09,208
size and I found this structure that

681
00:27:05,479 --> 00:27:11,099
contains linked list that points to file

682
00:27:09,209 --> 00:27:14,369
pointers which are typically very useful

683
00:27:11,099 --> 00:27:16,408
and I can actually make as many of the

684
00:27:14,369 --> 00:27:17,820
most of them as I want and I can control

685
00:27:16,409 --> 00:27:21,089
the lifetime of the structures as well

686
00:27:17,820 --> 00:27:27,658
so now I know a file pointer and if you

687
00:27:21,089 --> 00:27:30,629
see down there up hit down here there is

688
00:27:27,659 --> 00:27:32,969
a kernel pointer coming out so yeah we

689
00:27:30,629 --> 00:27:37,109
now know a kernel pointer we bypassed

690
00:27:32,969 --> 00:27:40,139
case a large kind of but this was not

691
00:27:37,109 --> 00:27:41,939
very stable I think it was working like

692
00:27:40,139 --> 00:27:44,639
70% of the time so we're like nice it

693
00:27:41,940 --> 00:27:46,469
kind of works but then every now and

694
00:27:44,639 --> 00:27:48,029
then it would fail and I wanted this to

695
00:27:46,469 --> 00:27:50,279
work properly especially when I was

696
00:27:48,029 --> 00:27:51,690
debugging with this ugly way of dead

697
00:27:50,279 --> 00:27:53,399
locking everything because it was super

698
00:27:51,690 --> 00:27:56,190
annoying to have to reset your phone

699
00:27:53,399 --> 00:27:57,988
every two minutes

700
00:27:56,190 --> 00:28:00,269
so I traced a malliband cage-free with

701
00:27:57,989 --> 00:28:03,239
the built-in kernel tracing capabilities

702
00:28:00,269 --> 00:28:04,769
and I realized that what was happening

703
00:28:03,239 --> 00:28:06,779
was that there was so much time in

704
00:28:04,769 --> 00:28:08,219
between my alok and my free and there

705
00:28:06,779 --> 00:28:11,099
was so much things happening in this

706
00:28:08,219 --> 00:28:13,979
labs that the slab was not already

707
00:28:11,099 --> 00:28:16,139
freeing or the reallocating slab was not

708
00:28:13,979 --> 00:28:18,450
coming from the same cpu as the previous

709
00:28:16,139 --> 00:28:21,079
one so there are active slabs on CPUs

710
00:28:18,450 --> 00:28:23,759
that own each CPU and it was somehow

711
00:28:21,079 --> 00:28:26,099
landing in a different CPU originally I

712
00:28:23,759 --> 00:28:29,339
was pinning everything to the same CPU

713
00:28:26,099 --> 00:28:33,168
and this is why sometimes my my object

714
00:28:29,339 --> 00:28:36,450
moved to a different CPU solution well

715
00:28:33,169 --> 00:28:38,249
easy just do it on also be use just

716
00:28:36,450 --> 00:28:40,499
spray more make more threads and you

717
00:28:38,249 --> 00:28:42,989
know bigger orchestras they were saying

718
00:28:40,499 --> 00:28:46,529
earlier and that's it and now we were

719
00:28:42,989 --> 00:28:50,509
looking quite reliably so yeah slow

720
00:28:46,529 --> 00:28:50,509
progress but better than no progress

721
00:28:55,500 --> 00:29:03,070
now I want to get rid right access so to

722
00:29:01,120 --> 00:29:05,379
do that from a leak it's kind of hard so

723
00:29:03,070 --> 00:29:07,779
we want to corrupt some data and we look

724
00:29:05,380 --> 00:29:10,720
at the rest of the users of these nodes

725
00:29:07,779 --> 00:29:12,309
of these target nodes because we can

726
00:29:10,720 --> 00:29:14,200
fake this nodes we can set the reference

727
00:29:12,309 --> 00:29:16,389
count to one and then we can free the

728
00:29:14,200 --> 00:29:18,730
binder buffer that we already freed

729
00:29:16,390 --> 00:29:21,450
before that has or abandon a binder

730
00:29:18,730 --> 00:29:24,010
transaction that's for that node and

731
00:29:21,450 --> 00:29:28,179
what happens then is that before it

732
00:29:24,010 --> 00:29:29,620
releases it it will do it will do these

733
00:29:28,179 --> 00:29:33,010
two things the first thing is a binder

734
00:29:29,620 --> 00:29:35,199
DQ work I logged which knows what and

735
00:29:33,010 --> 00:29:39,220
the second one is the RB race which is

736
00:29:35,200 --> 00:29:40,840
removing a node in an RB tree the first

737
00:29:39,220 --> 00:29:42,460
one boils down to a list delete which

738
00:29:40,840 --> 00:29:45,490
you also probably heard of if you've

739
00:29:42,460 --> 00:29:47,409
been here for two days and the other one

740
00:29:45,490 --> 00:29:49,659
you can make it boil down to some sort

741
00:29:47,409 --> 00:29:53,200
of list delete as well so what we get is

742
00:29:49,659 --> 00:29:56,590
to say 8:00 p.m. all primitives almost

743
00:29:53,200 --> 00:29:59,799
arbitrary right almost arbitrary a byte

744
00:29:56,590 --> 00:30:04,209
mirrored overwrite primitives the first

745
00:29:59,799 --> 00:30:07,720
one depends on config debug list which

746
00:30:04,210 --> 00:30:09,549
is set sometimes but anyway

747
00:30:07,720 --> 00:30:13,149
and the second one depend is basically

748
00:30:09,549 --> 00:30:19,059
if you set it to set the left part of

749
00:30:13,149 --> 00:30:21,399
the arbitrary to no then you get this so

750
00:30:19,059 --> 00:30:22,960
that means that you get the very same

751
00:30:21,399 --> 00:30:24,789
primitive to through two different

752
00:30:22,960 --> 00:30:26,139
functions yeah if you said it's

753
00:30:24,789 --> 00:30:29,320
something different from null then you

754
00:30:26,139 --> 00:30:31,240
just get a yeah a cascade of stuff that

755
00:30:29,320 --> 00:30:33,220
you don't want to think about so just

756
00:30:31,240 --> 00:30:34,450
you know simplify set one to know and

757
00:30:33,220 --> 00:30:37,690
that's the fastest path through a

758
00:30:34,450 --> 00:30:40,600
function done so with these two guys we

759
00:30:37,690 --> 00:30:43,539
can write semi arbitrary values to

760
00:30:40,600 --> 00:30:46,629
control the dresses these values though

761
00:30:43,539 --> 00:30:48,190
have to be writable addresses and if

762
00:30:46,630 --> 00:30:51,039
you've been paying attention you know

763
00:30:48,190 --> 00:30:53,200
that I only know one pointer so far so

764
00:30:51,039 --> 00:30:55,210
that's a bit problematic for now but

765
00:30:53,200 --> 00:30:56,769
also there is PA n so I cannot fake some

766
00:30:55,210 --> 00:30:59,799
of these things in user land so I cannot

767
00:30:56,769 --> 00:31:02,860
write to user land so we solve this with

768
00:30:59,799 --> 00:31:04,809
binder mapping spray which is basically

769
00:31:02,860 --> 00:31:06,549
open many file descriptors M map and

770
00:31:04,809 --> 00:31:08,350
then you have for each of them a vemma

771
00:31:06,549 --> 00:31:10,090
lock buff

772
00:31:08,350 --> 00:31:12,189
so you do it looks like this we have

773
00:31:10,090 --> 00:31:13,810
this thing this is the struct file we

774
00:31:12,190 --> 00:31:16,690
know the Erb we know the pointer to this

775
00:31:13,810 --> 00:31:19,179
guy to the beginning of this guy now we

776
00:31:16,690 --> 00:31:21,630
make new file descriptors this binder if

777
00:31:19,180 --> 00:31:24,850
these should be one two three four but

778
00:31:21,630 --> 00:31:27,940
and then it turns out that this part is

779
00:31:24,850 --> 00:31:31,179
fairly predictable you can predict quite

780
00:31:27,940 --> 00:31:33,220
well the Rhema lock space and if you

781
00:31:31,180 --> 00:31:35,530
make enough of these guys and then you

782
00:31:33,220 --> 00:31:37,900
just trigger your bug and point it to a

783
00:31:35,530 --> 00:31:40,180
guest address within this spray and now

784
00:31:37,900 --> 00:31:43,480
you have an inode and a private data

785
00:31:40,180 --> 00:31:45,310
from the file pointing into this where

786
00:31:43,480 --> 00:31:47,380
you can control the data because this is

787
00:31:45,310 --> 00:31:49,030
binder transaction buffer so you can

788
00:31:47,380 --> 00:31:51,930
send transactions to this process and

789
00:31:49,030 --> 00:31:55,060
the data will come from the transactions

790
00:31:51,930 --> 00:31:57,640
so at the moment we have an inode and a

791
00:31:55,060 --> 00:31:59,889
private data how do we leak but first

792
00:31:57,640 --> 00:32:02,410
the status check we can place arbitrary

793
00:31:59,890 --> 00:32:05,770
data at a known location so PN is gone

794
00:32:02,410 --> 00:32:08,530
for us we can leak a struct file and we

795
00:32:05,770 --> 00:32:09,639
corrupted private data and if I note and

796
00:32:08,530 --> 00:32:11,200
we can fake those structures in the

797
00:32:09,640 --> 00:32:12,850
binder mapping by just sending the

798
00:32:11,200 --> 00:32:14,140
transactions we still need to know for

799
00:32:12,850 --> 00:32:16,030
convenience which one of these many

800
00:32:14,140 --> 00:32:18,610
mappings will create it it's the one

801
00:32:16,030 --> 00:32:19,870
that we that it points to but that's

802
00:32:18,610 --> 00:32:22,990
fairly easy because the override is

803
00:32:19,870 --> 00:32:24,429
mirrored and it will modify the binder

804
00:32:22,990 --> 00:32:27,550
mapping so which is scan and we find

805
00:32:24,430 --> 00:32:28,810
which one was over overwritten and we

806
00:32:27,550 --> 00:32:33,790
learned some pointers on the way which

807
00:32:28,810 --> 00:32:37,990
is always nice to have now but when we

808
00:32:33,790 --> 00:32:39,990
do this we can call into a stat or F

809
00:32:37,990 --> 00:32:42,940
stat really for a file descriptor and

810
00:32:39,990 --> 00:32:45,190
because we control the F inode the FI

811
00:32:42,940 --> 00:32:47,350
node will be pointing to an arbitrary

812
00:32:45,190 --> 00:32:49,270
location in its past here and then there

813
00:32:47,350 --> 00:32:49,780
is a dereference of that for the

814
00:32:49,270 --> 00:32:52,540
superblock

815
00:32:49,780 --> 00:32:55,060
and it will read four bytes out so we

816
00:32:52,540 --> 00:32:58,210
can just send a miner transaction put

817
00:32:55,060 --> 00:32:59,800
the SB value to whatever we want then

818
00:32:58,210 --> 00:33:01,240
trigger F stat and we read four bytes

819
00:32:59,800 --> 00:33:02,740
and we just rinse and repeat as many

820
00:33:01,240 --> 00:33:06,120
times as we want and we can just read

821
00:33:02,740 --> 00:33:08,290
arbitrary arbitrary kernel later and

822
00:33:06,120 --> 00:33:10,030
since we had a pointer to start with

823
00:33:08,290 --> 00:33:11,560
that point into a struct file then we

824
00:33:10,030 --> 00:33:13,540
can also leak the kernel base and we can

825
00:33:11,560 --> 00:33:17,350
just keep pulling from that and learn

826
00:33:13,540 --> 00:33:19,030
the whole address space so that allows

827
00:33:17,350 --> 00:33:21,070
us to basically yeah

828
00:33:19,030 --> 00:33:23,529
bypass ksl are completely

829
00:33:21,070 --> 00:33:26,740
now all we need now is an arbitrary

830
00:33:23,529 --> 00:33:32,769
right so there is light at the end of

831
00:33:26,740 --> 00:33:34,450
the tunnel all right

832
00:33:32,769 --> 00:33:37,450
so how do we get an arbitrary right well

833
00:33:34,450 --> 00:33:41,019
I use the private data for that private

834
00:33:37,450 --> 00:33:43,690
data is the opaque structure in a struct

835
00:33:41,019 --> 00:33:45,250
file that is binder it's driver specific

836
00:33:43,690 --> 00:33:47,620
so if it's a binder file descriptor this

837
00:33:45,250 --> 00:33:49,450
is a binder proc if it's I don't know

838
00:33:47,620 --> 00:33:51,580
whatever other type of file descriptor

839
00:33:49,450 --> 00:33:53,259
then this is whatever this driver is

840
00:33:51,580 --> 00:33:56,529
using for representing the file

841
00:33:53,259 --> 00:33:58,960
descriptor internally so for binder

842
00:33:56,529 --> 00:34:01,990
there is this binder proc which contains

843
00:33:58,960 --> 00:34:03,730
an a locator inside which contains the

844
00:34:01,990 --> 00:34:07,349
buffers that binder sends transactions

845
00:34:03,730 --> 00:34:10,210
to and those buffers they contain oh

846
00:34:07,349 --> 00:34:11,918
this is not now I don't know where my

847
00:34:10,210 --> 00:34:15,159
mouse is well they contain this data

848
00:34:11,918 --> 00:34:16,118
pointer that is exactly the address

849
00:34:15,159 --> 00:34:17,770
where the member where the copy from

850
00:34:16,119 --> 00:34:19,810
user will be performed on sending a

851
00:34:17,770 --> 00:34:23,619
transaction so all we need to do is we

852
00:34:19,810 --> 00:34:25,328
need to fake these few links in the

853
00:34:23,619 --> 00:34:27,280
binder mapping and then send a

854
00:34:25,329 --> 00:34:29,560
transaction and then the transaction

855
00:34:27,280 --> 00:34:31,030
will basically write whatever data we

856
00:34:29,560 --> 00:34:32,889
send to the transaction will be written

857
00:34:31,030 --> 00:34:36,760
at the address that we control and we

858
00:34:32,889 --> 00:34:39,579
have an arbitrary write and yeah we also

859
00:34:36,760 --> 00:34:44,940
learn a couple other pointers again but

860
00:34:39,579 --> 00:34:47,109
this gives us this broke that's nice

861
00:34:44,940 --> 00:34:50,679
anyway this gives us a right primitive

862
00:34:47,109 --> 00:34:53,828
so what we need to do now is well get

863
00:34:50,679 --> 00:34:55,810
route right so we first set salinity

864
00:34:53,829 --> 00:34:59,020
enforcing to zero or now this is going

865
00:34:55,810 --> 00:35:00,940
by itself we then find in it and still

866
00:34:59,020 --> 00:35:02,140
its credentials not so much for the fact

867
00:35:00,940 --> 00:35:03,790
that it's route because we already know

868
00:35:02,140 --> 00:35:06,400
it but for the cell enix context and

869
00:35:03,790 --> 00:35:08,950
maybe there is other useful stuff we

870
00:35:06,400 --> 00:35:11,109
clean up and in my case this meant

871
00:35:08,950 --> 00:35:13,089
cleaning up the deadlock CPU so only at

872
00:35:11,109 --> 00:35:16,000
this point I can actually get rid of

873
00:35:13,089 --> 00:35:17,650
that stupid stock CPU but this was like

874
00:35:16,000 --> 00:35:20,609
maybe one second or something of their

875
00:35:17,650 --> 00:35:22,810
log if everything works fine and then Oh

876
00:35:20,609 --> 00:35:28,828
what's happening somebody's messing with

877
00:35:22,810 --> 00:35:28,828
me do I really need to disable Bluetooth

878
00:35:32,040 --> 00:35:41,620
turn off done all right what are you

879
00:35:37,150 --> 00:35:46,870
seeing now the other thing oh this mag

880
00:35:41,620 --> 00:35:53,080
books are useful what's happening so I

881
00:35:46,870 --> 00:35:56,009
kind of lost my presentation is it here

882
00:35:53,080 --> 00:35:58,450
no that's ah I'm getting confused sorry

883
00:35:56,010 --> 00:36:00,340
sorry guys it's actually there that was

884
00:35:58,450 --> 00:36:04,029
actually the presentation I think right

885
00:36:00,340 --> 00:36:06,450
so this went forward without me talking

886
00:36:04,030 --> 00:36:10,570
so then I got confused

887
00:36:06,450 --> 00:36:12,549
so the yeah released the deadlock CPU

888
00:36:10,570 --> 00:36:13,900
and then remember we have this end

889
00:36:12,550 --> 00:36:15,820
message threads that are blocked on the

890
00:36:13,900 --> 00:36:18,160
way out there gonna free these these

891
00:36:15,820 --> 00:36:19,810
buffers and we use some of them for

892
00:36:18,160 --> 00:36:21,339
binder free which frees the buffer as

893
00:36:19,810 --> 00:36:23,020
well so we would have a double free if

894
00:36:21,340 --> 00:36:25,120
we don't clear the references so we just

895
00:36:23,020 --> 00:36:27,009
have to make sure that find whatever

896
00:36:25,120 --> 00:36:29,589
ever send message is storing its

897
00:36:27,010 --> 00:36:32,980
reference and make it nool and then you

898
00:36:29,590 --> 00:36:35,110
know we will be able to pass any yeah we

899
00:36:32,980 --> 00:36:38,140
will be able to survive this and then we

900
00:36:35,110 --> 00:36:40,870
start a reversible shell so now is the

901
00:36:38,140 --> 00:36:41,920
moment of truth this is a video but

902
00:36:40,870 --> 00:36:44,049
that's not what you're going to see

903
00:36:41,920 --> 00:36:48,700
because I have some faith in the demo

904
00:36:44,050 --> 00:36:54,310
gods still is it again the video damn it

905
00:36:48,700 --> 00:36:57,870
I don't know how to use computers now

906
00:36:54,310 --> 00:37:01,880
it's it's open and there is this thing

907
00:36:57,870 --> 00:37:04,609
which is phone which is here

908
00:37:01,880 --> 00:37:10,450
I have to unlock it I have to show you

909
00:37:04,610 --> 00:37:13,490
what it's running it's running Android

910
00:37:10,450 --> 00:37:14,930
it's running Android version 9 and I

911
00:37:13,490 --> 00:37:16,819
don't know if that's visible from the

912
00:37:14,930 --> 00:37:18,589
end I'll read it out loud because this

913
00:37:16,820 --> 00:37:20,750
thing doesn't work anymore

914
00:37:18,590 --> 00:37:23,930
it's December 5 2000 18 so that's when

915
00:37:20,750 --> 00:37:25,340
we were working on this and here there

916
00:37:23,930 --> 00:37:34,790
is a shell but that I don't want the

917
00:37:25,340 --> 00:37:37,760
shell I actually want logcat alright so

918
00:37:34,790 --> 00:37:39,890
yeah I just press here go to my exploit

919
00:37:37,760 --> 00:37:44,210
and press press bone and see what

920
00:37:39,890 --> 00:37:48,109
happens and hope to be lucky it works

921
00:37:44,210 --> 00:37:49,280
most of the time so alright we're now

922
00:37:48,110 --> 00:37:51,230
trying to trigger the back and we're

923
00:37:49,280 --> 00:37:52,520
linking pointers and stuff and the

924
00:37:51,230 --> 00:37:53,990
application didn't crash it was me that

925
00:37:52,520 --> 00:37:55,370
clicked something because when the phone

926
00:37:53,990 --> 00:37:58,069
is active it's actually faster to win

927
00:37:55,370 --> 00:37:59,779
the race and I'm impatient but I got a

928
00:37:58,070 --> 00:38:01,850
connection back and you see some leaks

929
00:37:59,780 --> 00:38:04,820
coming through and a lockout window so

930
00:38:01,850 --> 00:38:09,980
like all the kernel addresses etc and we

931
00:38:04,820 --> 00:38:13,930
can see here well we can do ID here and

932
00:38:09,980 --> 00:38:16,730
it says we root and we can get in force

933
00:38:13,930 --> 00:38:21,200
and yeah

934
00:38:16,730 --> 00:38:25,590
[Applause]

935
00:38:21,200 --> 00:38:27,359
so that worked now there is a bit more I

936
00:38:25,590 --> 00:38:34,140
hope you're soon seeing the presentation

937
00:38:27,360 --> 00:38:36,780
again this one is this it yeah I need to

938
00:38:34,140 --> 00:38:38,670
move there oh it's not it I think where

939
00:38:36,780 --> 00:38:44,490
I moved the wrong thing as I said I

940
00:38:38,670 --> 00:38:46,230
don't know computers it's crashing ok

941
00:38:44,490 --> 00:38:51,569
well I'll say it out loud while it

942
00:38:46,230 --> 00:38:52,070
recovers so here we go so are we done

943
00:38:51,570 --> 00:38:56,040
yet

944
00:38:52,070 --> 00:38:57,540
the so there is this we said that we

945
00:38:56,040 --> 00:38:59,610
wanted to do with this and the galaxy s

946
00:38:57,540 --> 00:39:01,980
9 so there is least config debug this

947
00:38:59,610 --> 00:39:03,360
config the bucket list is set which

948
00:39:01,980 --> 00:39:06,480
means only one of the two arbitrary

949
00:39:03,360 --> 00:39:07,980
right primitives is available luckily

950
00:39:06,480 --> 00:39:10,950
back then there was no panic on

951
00:39:07,980 --> 00:39:12,660
corruption with that feature so I it

952
00:39:10,950 --> 00:39:14,700
would just warned on the kernel locks

953
00:39:12,660 --> 00:39:17,700
but it would not panic so it's like oh

954
00:39:14,700 --> 00:39:21,720
the list is not good ok I will go

955
00:39:17,700 --> 00:39:23,640
through and then I use the private data

956
00:39:21,720 --> 00:39:25,859
one two

957
00:39:23,640 --> 00:39:27,240
so I overwrite private data for a binary

958
00:39:25,860 --> 00:39:30,120
file descriptor and then I figured a way

959
00:39:27,240 --> 00:39:32,459
to make a second arbitrary right from

960
00:39:30,120 --> 00:39:35,640
there and then corrupt further things

961
00:39:32,460 --> 00:39:37,320
and get to the same spot and then also

962
00:39:35,640 --> 00:39:41,970
another complication is that it was

963
00:39:37,320 --> 00:39:44,850
using an old driver CV 20 17 13 164 2017

964
00:39:41,970 --> 00:39:46,830
were September 2018 right what happened

965
00:39:44,850 --> 00:39:48,690
well what happened was I think my

966
00:39:46,830 --> 00:39:51,000
understanding was what happened is that

967
00:39:48,690 --> 00:39:53,790
this CV is on the Android security

968
00:39:51,000 --> 00:39:56,640
bulletins for pixel phone's pixel Nexus

969
00:39:53,790 --> 00:39:58,410
phones it's not only a generic one it's

970
00:39:56,640 --> 00:40:00,000
on the pixel phones which means that

971
00:39:58,410 --> 00:40:02,220
many OEMs because it's on the pixel

972
00:40:00,000 --> 00:40:05,460
phones it's not my problem so I don't

973
00:40:02,220 --> 00:40:08,189
port it so that is for us that is good

974
00:40:05,460 --> 00:40:09,690
and bad that means that we can so this

975
00:40:08,190 --> 00:40:11,550
bug in particular was putting these

976
00:40:09,690 --> 00:40:14,220
binder buffers inside the binder big

977
00:40:11,550 --> 00:40:15,750
buffer including the next and the proof

978
00:40:14,220 --> 00:40:17,640
pointer and everything so we could see

979
00:40:15,750 --> 00:40:18,870
all these kernel addresses but we can

980
00:40:17,640 --> 00:40:20,850
also see all the metadata of the

981
00:40:18,870 --> 00:40:22,290
allocator so we know precisely when the

982
00:40:20,850 --> 00:40:24,240
buffer is being allocated and the

983
00:40:22,290 --> 00:40:26,880
allocated which means that I can also

984
00:40:24,240 --> 00:40:28,439
get past this null point like I haven't

985
00:40:26,880 --> 00:40:29,910
more timing information so it's easier

986
00:40:28,440 --> 00:40:31,950
for me to get through the null pointer

987
00:40:29,910 --> 00:40:34,920
crashes as well

988
00:40:31,950 --> 00:40:37,350
but I cannot use my right primitive

989
00:40:34,920 --> 00:40:39,960
because this this implementation had in

990
00:40:37,350 --> 00:40:41,430
line buffers and not out of line bars so

991
00:40:39,960 --> 00:40:43,890
I had to change this and do kind of Rob

992
00:40:41,430 --> 00:40:45,960
or actually not rob because there is

993
00:40:43,890 --> 00:40:48,890
some checks but it's function oriented

994
00:40:45,960 --> 00:40:51,450
programming literally like that and

995
00:40:48,890 --> 00:40:53,490
solution forcing is not read-only so we

996
00:40:51,450 --> 00:40:56,520
cannot do like disable Salinas we're

997
00:40:53,490 --> 00:40:59,220
done go but I just reloaded some

998
00:40:56,520 --> 00:41:01,560
selenium stuff and also that point

999
00:40:59,220 --> 00:41:03,120
Samsung had I think by mistake

1000
00:41:01,560 --> 00:41:07,170
disabled part of the credential

1001
00:41:03,120 --> 00:41:11,160
protection for a few months I think so I

1002
00:41:07,170 --> 00:41:13,760
could just override it so now it's like

1003
00:41:11,160 --> 00:41:17,759
yay we're good

1004
00:41:13,760 --> 00:41:19,230
except this happened if you're familiar

1005
00:41:17,760 --> 00:41:22,380
with the Linux kernel mailing list this

1006
00:41:19,230 --> 00:41:24,660
looks very similar and I cannot zoom in

1007
00:41:22,380 --> 00:41:26,850
any more but up there it says 6th of

1008
00:41:24,660 --> 00:41:28,410
November and I got to finish this thing

1009
00:41:26,850 --> 00:41:30,410
by like at the end of December so I was

1010
00:41:28,410 --> 00:41:39,810
like damn it

1011
00:41:30,410 --> 00:41:41,160
so yeah this was Miguel's face mostly so

1012
00:41:39,810 --> 00:41:43,110
at this point we're like well you know

1013
00:41:41,160 --> 00:41:44,940
got fixed too bad we spend an extra

1014
00:41:43,110 --> 00:41:48,780
month and you know it's it's annoying

1015
00:41:44,940 --> 00:41:51,750
but yeah we thought it's probably

1016
00:41:48,780 --> 00:41:54,000
project zero and it turned out a few

1017
00:41:51,750 --> 00:41:56,310
months later this cannot be seen on the

1018
00:41:54,000 --> 00:41:58,710
screen but this is March 6th of March is

1019
00:41:56,310 --> 00:41:59,990
written up there in sort of Chinese but

1020
00:41:58,710 --> 00:42:07,170
I guess that means month or something

1021
00:41:59,990 --> 00:42:09,689
6th of March or of 2019 so the these

1022
00:42:07,170 --> 00:42:12,150
guys from 360 they published a post

1023
00:42:09,690 --> 00:42:13,740
which was of course after Google had

1024
00:42:12,150 --> 00:42:15,210
published the Security Bulletin so now

1025
00:42:13,740 --> 00:42:20,220
it's fixed and it's on all Android

1026
00:42:15,210 --> 00:42:23,640
phones right and yeah they they we're

1027
00:42:20,220 --> 00:42:26,129
the ones to find the debug but it was

1028
00:42:23,640 --> 00:42:30,839
actually also project 0 so Yun horn

1029
00:42:26,130 --> 00:42:32,730
found it and well the the part that

1030
00:42:30,840 --> 00:42:36,210
makes me feel at least a little less bad

1031
00:42:32,730 --> 00:42:38,880
is that down here it says reported on

1032
00:42:36,210 --> 00:42:39,990
the 3rd 23rd of November of 2018 so at

1033
00:42:38,880 --> 00:42:41,370
least I'm not the only one who's not

1034
00:42:39,990 --> 00:42:45,379
reading the kernel mailing list and

1035
00:42:41,370 --> 00:42:45,380
missing that you know there are all bugs

1036
00:42:48,560 --> 00:42:55,650
that's my timing Oh plenty

1037
00:42:52,640 --> 00:42:58,859
so yeah this this was a bit the story

1038
00:42:55,650 --> 00:43:01,710
now I want to look at it at the bug or

1039
00:42:58,860 --> 00:43:03,840
at the way the guys from 360 exploited

1040
00:43:01,710 --> 00:43:06,150
the bug and of course I don't have their

1041
00:43:03,840 --> 00:43:10,410
exploit so this is all based on pure

1042
00:43:06,150 --> 00:43:12,870
speculation based on their presentation

1043
00:43:10,410 --> 00:43:14,370
they made attacking the box which had

1044
00:43:12,870 --> 00:43:15,750
most of the details but if you don't try

1045
00:43:14,370 --> 00:43:17,460
to re-implement it then there are some

1046
00:43:15,750 --> 00:43:21,690
details that are always kind of missing

1047
00:43:17,460 --> 00:43:23,250
that you don't really understand so they

1048
00:43:21,690 --> 00:43:25,830
don't use this this way of doing like

1049
00:43:23,250 --> 00:43:27,300
this allow user this freeing of objects

1050
00:43:25,830 --> 00:43:29,520
in the binder transactions they just go

1051
00:43:27,300 --> 00:43:30,900
for a pure use after free on the heap

1052
00:43:29,520 --> 00:43:31,980
right away

1053
00:43:30,900 --> 00:43:33,510
and that's on the binder buffer

1054
00:43:31,980 --> 00:43:35,610
structure so these binary buffers are

1055
00:43:33,510 --> 00:43:37,650
actually sometimes reuse the old one but

1056
00:43:35,610 --> 00:43:39,000
they sometimes make new ones and three

1057
00:43:37,650 --> 00:43:41,100
the old ones depending on whether they

1058
00:43:39,000 --> 00:43:42,660
are like adjacent Buffon's that buffers

1059
00:43:41,100 --> 00:43:44,430
that you can reuse or you know it's an

1060
00:43:42,660 --> 00:43:45,600
alligator and sometimes it's like okay

1061
00:43:44,430 --> 00:43:46,950
this buffer in the middle now I can

1062
00:43:45,600 --> 00:43:49,020
merge with the other two so I drop this

1063
00:43:46,950 --> 00:43:51,240
one and stuff like that and that will

1064
00:43:49,020 --> 00:43:52,950
basically make use after free on that

1065
00:43:51,240 --> 00:43:55,379
buffer because it really goes to the

1066
00:43:52,950 --> 00:43:58,980
heap and then you can use it for your

1067
00:43:55,380 --> 00:44:00,450
transaction my understanding well so

1068
00:43:58,980 --> 00:44:01,710
first of all this should work from the

1069
00:44:00,450 --> 00:44:04,589
sandbox because you need you know need

1070
00:44:01,710 --> 00:44:06,000
control of both ends or tricks that I

1071
00:44:04,590 --> 00:44:09,270
don't know about to do that from the

1072
00:44:06,000 --> 00:44:12,570
sandbox it also I think it requires

1073
00:44:09,270 --> 00:44:16,980
triggering the race or use after freeze

1074
00:44:12,570 --> 00:44:19,140
for each readwrite access I think and I

1075
00:44:16,980 --> 00:44:20,490
think this because so maybe you can do

1076
00:44:19,140 --> 00:44:22,200
with the race once because they will

1077
00:44:20,490 --> 00:44:27,120
reuse this buffer many times and whatnot

1078
00:44:22,200 --> 00:44:28,710
but I believe at least to be able to

1079
00:44:27,120 --> 00:44:30,210
read and to write they have to send a

1080
00:44:28,710 --> 00:44:31,920
new transaction which should be a freed

1081
00:44:30,210 --> 00:44:33,150
buffer that they control and therefore

1082
00:44:31,920 --> 00:44:34,560
every time you have a user after free

1083
00:44:33,150 --> 00:44:37,260
for everything that you access and in

1084
00:44:34,560 --> 00:44:38,610
our case we did one race win to use

1085
00:44:37,260 --> 00:44:40,650
after free is triggered from that one

1086
00:44:38,610 --> 00:44:42,300
time and then we're done with it

1087
00:44:40,650 --> 00:44:45,750
we don't need to trigger that right so

1088
00:44:42,300 --> 00:44:47,940
hopefully this is faster they also use a

1089
00:44:45,750 --> 00:44:49,470
service that echoes data back to the

1090
00:44:47,940 --> 00:44:51,030
process and this is how they go around

1091
00:44:49,470 --> 00:44:53,069
the limitation of being able to talk to

1092
00:44:51,030 --> 00:44:55,170
yourself so they send some data to the

1093
00:44:53,070 --> 00:44:56,820
servers then they trigger about well

1094
00:44:55,170 --> 00:44:57,810
they call they triggered about well they

1095
00:44:56,820 --> 00:44:59,370
call

1096
00:44:57,810 --> 00:45:01,110
this function that gives the data back

1097
00:44:59,370 --> 00:45:03,359
the same data that we probe that we

1098
00:45:01,110 --> 00:45:05,250
produced that allows them to you an

1099
00:45:03,360 --> 00:45:07,770
arbitrary right it's very similar to my

1100
00:45:05,250 --> 00:45:08,880
arbitrary right but it's abusing the

1101
00:45:07,770 --> 00:45:12,450
fact that the server is giving back

1102
00:45:08,880 --> 00:45:13,860
stuff that you control and as far as I

1103
00:45:12,450 --> 00:45:15,689
know this service is not reachable from

1104
00:45:13,860 --> 00:45:17,190
within sandbox so that drops again the

1105
00:45:15,690 --> 00:45:18,870
possibility of doing a sandbox escape

1106
00:45:17,190 --> 00:45:21,810
and you'd have to find something similar

1107
00:45:18,870 --> 00:45:24,259
on the sandbox they also use a Qualcomm

1108
00:45:21,810 --> 00:45:26,880
only driver for leaking a struct file

1109
00:45:24,260 --> 00:45:28,380
this I'm pretty sure this shouldn't work

1110
00:45:26,880 --> 00:45:29,790
from sandbox and if it does it's a bug

1111
00:45:28,380 --> 00:45:32,460
in itself probably in the sandbox

1112
00:45:29,790 --> 00:45:34,410
profile and it's also not generic in the

1113
00:45:32,460 --> 00:45:36,960
sense that you cannot use every Android

1114
00:45:34,410 --> 00:45:40,230
phone and use this Qualcomm specific

1115
00:45:36,960 --> 00:45:42,210
driver the they also played with

1116
00:45:40,230 --> 00:45:43,980
scheduling and mutex is to improve the

1117
00:45:42,210 --> 00:45:46,620
odds so they were not as dumb as me to

1118
00:45:43,980 --> 00:45:48,860
just like do this weird deadlock and

1119
00:45:46,620 --> 00:45:51,240
they were much smarter like my colleague

1120
00:45:48,860 --> 00:45:53,310
they also seemed to pin to CPUs to

1121
00:45:51,240 --> 00:45:54,629
improve their chances and that's also

1122
00:45:53,310 --> 00:45:56,250
not allowed on the sandbox or another

1123
00:45:54,630 --> 00:45:58,740
requirement that drops the sandbox

1124
00:45:56,250 --> 00:46:00,870
exploit ability of these although you

1125
00:45:58,740 --> 00:46:02,729
can probably work around it so my

1126
00:46:00,870 --> 00:46:04,770
overall feeling and I'm probably

1127
00:46:02,730 --> 00:46:06,240
mistaken about this is that it seems

1128
00:46:04,770 --> 00:46:09,990
ours is a little faster and more

1129
00:46:06,240 --> 00:46:12,810
reliable but you know could probably be

1130
00:46:09,990 --> 00:46:14,279
not but there's has the potential that

1131
00:46:12,810 --> 00:46:15,480
their approach has the potential to be a

1132
00:46:14,280 --> 00:46:18,450
sandbox escape which towers definitely

1133
00:46:15,480 --> 00:46:20,460
has not without an additional bug to be

1134
00:46:18,450 --> 00:46:25,350
able to talk to yourself and they were

1135
00:46:20,460 --> 00:46:28,020
first so they win anyway and in terms of

1136
00:46:25,350 --> 00:46:29,790
their closing conclusions kind of you

1137
00:46:28,020 --> 00:46:32,040
know that writing exploits modern

1138
00:46:29,790 --> 00:46:34,110
exploits can be a pain it's still

1139
00:46:32,040 --> 00:46:36,080
possible but you know just do not

1140
00:46:34,110 --> 00:46:39,030
despair if you're trying to learn this

1141
00:46:36,080 --> 00:46:40,650
but fragmentation is kind of annoying so

1142
00:46:39,030 --> 00:46:43,200
we had this bug that was like in the

1143
00:46:40,650 --> 00:46:45,600
core of Android but we ended up writing

1144
00:46:43,200 --> 00:46:46,890
two fairly different like similar

1145
00:46:45,600 --> 00:46:49,500
approach with fairly different exploits

1146
00:46:46,890 --> 00:46:50,790
for two different phones and I'm pretty

1147
00:46:49,500 --> 00:46:52,080
sure if we took another phone from

1148
00:46:50,790 --> 00:46:53,730
another brand we probably had to change

1149
00:46:52,080 --> 00:46:55,710
something as well even if we didn't rely

1150
00:46:53,730 --> 00:46:56,880
on you know offsets from the kernel base

1151
00:46:55,710 --> 00:46:59,340
or stuff like that with resolve

1152
00:46:56,880 --> 00:47:00,420
everything on run time I think we would

1153
00:46:59,340 --> 00:47:02,070
probably have to write different

1154
00:47:00,420 --> 00:47:04,770
exploits just because of differences in

1155
00:47:02,070 --> 00:47:06,600
the kernels and it's yeah it's really

1156
00:47:04,770 --> 00:47:08,340
easy to go down a rabbit hole and it's

1157
00:47:06,600 --> 00:47:09,660
good to keep a keep in mind that there

1158
00:47:08,340 --> 00:47:11,490
are probably better solutions that the

1159
00:47:09,660 --> 00:47:13,259
one you're working on right now and

1160
00:47:11,490 --> 00:47:15,600
take a few steps back think about what

1161
00:47:13,260 --> 00:47:18,930
you're doing and try to find the best

1162
00:47:15,600 --> 00:47:21,029
solutions and yeah the common conclusion

1163
00:47:18,930 --> 00:47:22,350
and when we're talking about many things

1164
00:47:21,030 --> 00:47:26,450
including Android is that there is a

1165
00:47:22,350 --> 00:47:29,220
pretty large patch gap in this

1166
00:47:26,450 --> 00:47:33,839
particular case I think this was four

1167
00:47:29,220 --> 00:47:36,990
months from from the upstream kernel fix

1168
00:47:33,840 --> 00:47:38,880
to the Android bulletin so that's quite

1169
00:47:36,990 --> 00:47:41,609
a long time and then of course not

1170
00:47:38,880 --> 00:47:45,390
everybody fixes this on the day one so

1171
00:47:41,610 --> 00:47:48,720
there is quite a lot in window and with

1172
00:47:45,390 --> 00:47:52,500
these I want to do a little video and

1173
00:47:48,720 --> 00:47:56,580
special request from Miguel and then I

1174
00:47:52,500 --> 00:48:00,119
will be open for questions so in case

1175
00:47:56,580 --> 00:48:01,410
you don't see this that's February 2020

1176
00:48:00,119 --> 00:48:07,950
over there and the video should be

1177
00:48:01,410 --> 00:48:13,190
playing but is it it says it is now it

1178
00:48:07,950 --> 00:48:13,189
is all computers

1179
00:48:18,040 --> 00:48:21,520
so there is no so we cannot with

1180
00:48:20,110 --> 00:48:23,200
selenium system forcing we run this

1181
00:48:21,520 --> 00:48:25,330
thing it's not the phone crashing it's

1182
00:48:23,200 --> 00:48:28,540
just going to sleep that's why I clicked

1183
00:48:25,330 --> 00:48:30,990
him there and while kernel based IDE

1184
00:48:28,540 --> 00:48:30,990
blah

1185
00:48:39,339 --> 00:48:55,729
so that's a wrap questions thanks for it

1186
00:48:52,309 --> 00:48:58,960
work first question as I understood you

1187
00:48:55,729 --> 00:49:01,669
first with fuzzing you found bugs which

1188
00:48:58,960 --> 00:49:04,609
seized boat didn't find write correctly

1189
00:49:01,670 --> 00:49:06,249
so you used some tricks for your fuzzing

1190
00:49:04,609 --> 00:49:09,529
yes

1191
00:49:06,249 --> 00:49:13,640
any details or just definitions were not

1192
00:49:09,529 --> 00:49:16,130
proper enough that's another question

1193
00:49:13,640 --> 00:49:18,410
that yeah go ahead

1194
00:49:16,130 --> 00:49:19,940
so these color definitions were not good

1195
00:49:18,410 --> 00:49:26,749
enough to find these bugs that's the

1196
00:49:19,940 --> 00:49:30,019
only thing I can say okay thanks you had

1197
00:49:26,749 --> 00:49:34,578
another question go ahead I have another

1198
00:49:30,019 --> 00:49:36,950
question so yesterday many Tolos but Liz

1199
00:49:34,579 --> 00:49:39,680
Dale yeah fact that there is no safe and

1200
00:49:36,950 --> 00:49:43,700
linking usual as another burg use of the

1201
00:49:39,680 --> 00:49:45,499
same kind of so say is linking is it

1202
00:49:43,700 --> 00:49:47,779
going to be introduced or is it just to

1203
00:49:45,499 --> 00:49:50,988
slow to a safer nicking in the safe

1204
00:49:47,779 --> 00:49:52,489
because this is done on most OS on the

1205
00:49:50,989 --> 00:49:53,839
desktop so why is it not done on the

1206
00:49:52,489 --> 00:49:57,079
Linux kernel do you have any idea

1207
00:49:53,839 --> 00:49:59,239
I mean it's depending on the config of

1208
00:49:57,079 --> 00:50:00,859
the kernel it's of course slower because

1209
00:49:59,239 --> 00:50:03,950
you do checks and stuff but there is a

1210
00:50:00,859 --> 00:50:05,779
conflict that's convicted by default so

1211
00:50:03,950 --> 00:50:07,549
I don't know maybe now Android put it in

1212
00:50:05,779 --> 00:50:11,420
the common carnal that can be do you

1213
00:50:07,549 --> 00:50:12,890
know yeah because you know the way this

1214
00:50:11,420 --> 00:50:15,739
works there is the under common kernel

1215
00:50:12,890 --> 00:50:17,479
which is full from upstream and then

1216
00:50:15,739 --> 00:50:19,039
from like LTS or whatever and then there

1217
00:50:17,479 --> 00:50:20,718
is the port from each vendor which adds

1218
00:50:19,039 --> 00:50:23,479
its own drivers and changes everything

1219
00:50:20,719 --> 00:50:27,170
in between and you know add all sorts of

1220
00:50:23,479 --> 00:50:28,609
security features and yeah they config

1221
00:50:27,170 --> 00:50:30,739
files typically extend from the ones

1222
00:50:28,609 --> 00:50:33,229
that come from common kernel and what

1223
00:50:30,739 --> 00:50:35,420
happens is that often these people just

1224
00:50:33,229 --> 00:50:36,828
stick to one kernel for the whole

1225
00:50:35,420 --> 00:50:39,769
lifetime of a device and they don't

1226
00:50:36,829 --> 00:50:43,700
upgrade to new world lines anymore so it

1227
00:50:39,769 --> 00:50:46,700
takes a little while and you mentioned

1228
00:50:43,700 --> 00:50:49,819
those bug on checks and if you heat it

1229
00:50:46,700 --> 00:50:51,828
is a chronic process context so process

1230
00:50:49,819 --> 00:50:52,310
crushed or it is Anna kernel you have

1231
00:50:51,829 --> 00:50:55,040
been

1232
00:50:52,310 --> 00:50:55,549
so it's panic I think it's technically

1233
00:50:55,040 --> 00:50:57,740
an oops

1234
00:50:55,550 --> 00:50:59,510
but there is this panic on oops thing so

1235
00:50:57,740 --> 00:51:01,129
in Android devices in practice this

1236
00:50:59,510 --> 00:51:08,810
means that just a complete crash of your

1237
00:51:01,130 --> 00:51:15,980
kernel and a reboot okay questions

1238
00:51:08,810 --> 00:51:18,259
anywhere else no yeah running so you

1239
00:51:15,980 --> 00:51:21,230
said Samsung accidentally disabled rkp

1240
00:51:18,260 --> 00:51:21,560
on something important you speak more to

1241
00:51:21,230 --> 00:51:24,710
that

1242
00:51:21,560 --> 00:51:28,099
no it's config of the kernel just and

1243
00:51:24,710 --> 00:51:31,160
that's that's fine now so no worth

1244
00:51:28,099 --> 00:51:34,819
talking about it anymore it's it's it's

1245
00:51:31,160 --> 00:51:38,149
fixed now so I think it's accidental I

1246
00:51:34,819 --> 00:51:42,560
mean no no more than that was the method

1247
00:51:38,150 --> 00:51:46,220
used similar to that reboot one in the

1248
00:51:42,560 --> 00:51:49,578
power command off sorry I can I don't

1249
00:51:46,220 --> 00:51:51,379
lose your method for disabling or KP it

1250
00:51:49,579 --> 00:51:53,839
was already disabled let's say

1251
00:51:51,380 --> 00:51:55,780
completely distorted credentials so they

1252
00:51:53,839 --> 00:51:58,700
were not read-only in this case that's I

1253
00:51:55,780 --> 00:51:59,780
don't know why just that at that moment

1254
00:51:58,700 --> 00:52:02,569
I didn't investigate this further

1255
00:51:59,780 --> 00:52:05,920
because the but what got fixed and you

1256
00:52:02,569 --> 00:52:05,920
know gotcha

1257
00:52:05,950 --> 00:52:09,069
anything else

