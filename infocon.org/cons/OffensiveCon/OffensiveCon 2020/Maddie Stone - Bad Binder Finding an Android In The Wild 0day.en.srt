1
00:00:01,520 --> 00:00:06,960
good morning thanks for waking up bright

2
00:00:04,350 --> 00:00:09,149
and early to come and hear about binder

3
00:00:06,960 --> 00:00:11,160
zero day as he said my name is Matty

4
00:00:09,150 --> 00:00:13,019
stone and I am currently a security

5
00:00:11,160 --> 00:00:16,109
researcher on Google's project zero

6
00:00:13,019 --> 00:00:18,660
where my focus is on what can we learn

7
00:00:16,109 --> 00:00:21,060
what can we find out and things from

8
00:00:18,660 --> 00:00:22,769
zero days that are used in the wild and

9
00:00:21,060 --> 00:00:26,189
that's how can we use that information

10
00:00:22,769 --> 00:00:28,669
to make zero day hard before that I was

11
00:00:26,189 --> 00:00:33,329
on the Google's Android security team

12
00:00:28,670 --> 00:00:35,700
but this is a story of how I found an

13
00:00:33,329 --> 00:00:40,100
Android zero day that was being used in

14
00:00:35,700 --> 00:00:44,129
the wild attributed to NSO so let's take

15
00:00:40,100 --> 00:00:45,719
go back in time to late summer 2019 this

16
00:00:44,129 --> 00:00:47,879
was just at the cusp of when I was

17
00:00:45,719 --> 00:00:50,700
switching from the Android security team

18
00:00:47,879 --> 00:00:52,620
to move on to Google project zero and I

19
00:00:50,700 --> 00:00:54,809
get this meeting invite not really sure

20
00:00:52,620 --> 00:00:56,459
what it's about show up there's a lot of

21
00:00:54,809 --> 00:00:58,559
people from a couple of different teams

22
00:00:56,460 --> 00:01:02,399
within Google and we receive information

23
00:00:58,559 --> 00:01:05,399
saying hey we've heard that they're in a

24
00:01:02,399 --> 00:01:08,369
so has a zero day for Android and

25
00:01:05,400 --> 00:01:10,740
they're using this to install Pegasus by

26
00:01:08,369 --> 00:01:13,049
we're on target devices what do you all

27
00:01:10,740 --> 00:01:14,640
know about it we're all sort of looking

28
00:01:13,049 --> 00:01:16,680
back and forth at each other like do you

29
00:01:14,640 --> 00:01:19,710
have any other details we haven't heard

30
00:01:16,680 --> 00:01:22,890
about this what's going on and so this

31
00:01:19,710 --> 00:01:25,949
talk will be a story of how I found it

32
00:01:22,890 --> 00:01:29,520
what information we got hat what the bug

33
00:01:25,950 --> 00:01:31,979
is how do you exploit it what does a POC

34
00:01:29,520 --> 00:01:33,750
look like and then what is all this

35
00:01:31,979 --> 00:01:35,250
information about in the wild and what

36
00:01:33,750 --> 00:01:38,250
can we learn from it how should we move

37
00:01:35,250 --> 00:01:40,860
forward so this was my starter project

38
00:01:38,250 --> 00:01:44,340
for Google project zero came into this

39
00:01:40,860 --> 00:01:47,130
with no really kernel knowledge and so

40
00:01:44,340 --> 00:01:49,829
hopefully that's interesting helpful but

41
00:01:47,130 --> 00:01:52,649
our starting point was a bunch of

42
00:01:49,829 --> 00:01:55,199
different facts sort of marketing

43
00:01:52,649 --> 00:01:58,140
details about hey you can trust us this

44
00:01:55,200 --> 00:02:00,719
capability exists because here's a bunch

45
00:01:58,140 --> 00:02:01,950
of different information about it so one

46
00:02:00,719 --> 00:02:05,189
of the first details about this

47
00:02:01,950 --> 00:02:07,320
capability was it's a kernel privilege

48
00:02:05,189 --> 00:02:09,628
escalation using a use after free

49
00:02:07,320 --> 00:02:12,480
vulnerability and it's reachable from

50
00:02:09,628 --> 00:02:13,140
inside the chrome sandbox so from this

51
00:02:12,480 --> 00:02:15,090
it already

52
00:02:13,140 --> 00:02:17,100
gulps down what we're looking for we're

53
00:02:15,090 --> 00:02:19,470
not looking at Android app space we're

54
00:02:17,100 --> 00:02:22,380
not looking at the framework for Android

55
00:02:19,470 --> 00:02:25,550
we can focus just on the kernel and we

56
00:02:22,380 --> 00:02:29,790
know it's a use after free vulnerability

57
00:02:25,550 --> 00:02:31,800
next we heard it affects pixel 1 & 2 but

58
00:02:29,790 --> 00:02:34,019
does not affect the pixel 3 and 3a

59
00:02:31,800 --> 00:02:35,630
remember this was before the pixel 4 was

60
00:02:34,020 --> 00:02:37,920
released and this is especially

61
00:02:35,630 --> 00:02:40,590
interesting your first gut instinct is

62
00:02:37,920 --> 00:02:43,260
cool simple all we got to do is dip Ixil

63
00:02:40,590 --> 00:02:45,150
2 and pixel 3 turns out there's a lot

64
00:02:43,260 --> 00:02:47,459
more changes than you'd expect because

65
00:02:45,150 --> 00:02:50,250
they're running off of different kernels

66
00:02:47,459 --> 00:02:53,070
pixel 2 is focused earth is built on the

67
00:02:50,250 --> 00:02:57,600
Linux 4.4 where a pixel 3 is built on

68
00:02:53,070 --> 00:03:00,000
the Linux 4.9 but the other interesting

69
00:02:57,600 --> 00:03:03,120
fact was is that we heard it's been

70
00:03:00,000 --> 00:03:05,400
patched in the Linux kernel greater than

71
00:03:03,120 --> 00:03:08,310
4 are greater than or equal to 4 point

72
00:03:05,400 --> 00:03:11,730
14 without a Seabee so though we about a

73
00:03:08,310 --> 00:03:14,880
CVE is not that crazy because if you've

74
00:03:11,730 --> 00:03:17,670
worked with the Linux kernel before they

75
00:03:14,880 --> 00:03:19,739
treat a bug is a bug it's not a bug is

76
00:03:17,670 --> 00:03:22,440
not a security bug it's just a bug so

77
00:03:19,739 --> 00:03:27,060
they often patch security issues without

78
00:03:22,440 --> 00:03:29,940
CBE's but what is highlighted is that we

79
00:03:27,060 --> 00:03:32,310
know pixel 3 is not affected pixel 3

80
00:03:29,940 --> 00:03:34,410
runs on 4 point 9 but now we're being

81
00:03:32,310 --> 00:03:37,380
told it wasn't patched in the Linux

82
00:03:34,410 --> 00:03:40,410
kernel 4.90 lingly and greater than our

83
00:03:37,380 --> 00:03:44,010
4.14 so these are all just details to

84
00:03:40,410 --> 00:03:46,980
start putting in our head of how do we

85
00:03:44,010 --> 00:03:51,380
narrow it down to which patch for a bug

86
00:03:46,980 --> 00:03:54,179
is this vulnerable vole nura hunting for

87
00:03:51,380 --> 00:03:55,920
so now we get into the technical details

88
00:03:54,180 --> 00:03:59,220
about this bug and how we begin to

89
00:03:55,920 --> 00:04:02,429
really think of what is it so the kernel

90
00:03:59,220 --> 00:04:06,330
flag option config debug list breaks the

91
00:04:02,430 --> 00:04:08,730
primitive we're using so next step how

92
00:04:06,330 --> 00:04:11,459
does behavior change when config debug

93
00:04:08,730 --> 00:04:14,340
list is enabled versus disabled so

94
00:04:11,459 --> 00:04:16,530
thankfully it's pretty well scoped

95
00:04:14,340 --> 00:04:18,720
there's only two actions you can perform

96
00:04:16,529 --> 00:04:21,000
whose behavior would change when this

97
00:04:18,720 --> 00:04:23,760
flag is enabled adding to a doubly

98
00:04:21,000 --> 00:04:26,099
linked list and deleting to a deleting

99
00:04:23,760 --> 00:04:26,520
from a doubly linked list and that means

100
00:04:26,099 --> 00:04:29,310
that

101
00:04:26,520 --> 00:04:31,530
only three functions differ list add a

102
00:04:29,310 --> 00:04:35,370
slightly different behavior and then

103
00:04:31,530 --> 00:04:38,460
list del entry only exists when config

104
00:04:35,370 --> 00:04:40,680
debug list is enabled and lists tell the

105
00:04:38,460 --> 00:04:44,039
parent to that function either calls

106
00:04:40,680 --> 00:04:47,159
list del entry or not so now we know

107
00:04:44,039 --> 00:04:49,740
that we are looking for a use after free

108
00:04:47,159 --> 00:04:53,280
and when you're using that use after

109
00:04:49,740 --> 00:04:59,880
free you're probably calling list ad or

110
00:04:53,280 --> 00:05:02,460
list del on that freed thing and so

111
00:04:59,880 --> 00:05:07,289
here's an example of what list del entry

112
00:05:02,460 --> 00:05:10,380
looks like if config debug list is not

113
00:05:07,289 --> 00:05:13,020
enabled then you actually only call this

114
00:05:10,380 --> 00:05:16,680
del it never calls this list el entry

115
00:05:13,020 --> 00:05:19,639
however win config debug list is enabled

116
00:05:16,680 --> 00:05:24,240
we have all of these extra Chuck checks

117
00:05:19,639 --> 00:05:27,090
enabled which can end up with a bug on

118
00:05:24,240 --> 00:05:29,460
and these different checks are would

119
00:05:27,090 --> 00:05:32,008
prevent and on linking primitive because

120
00:05:29,460 --> 00:05:35,638
they're checking that hey the entry we

121
00:05:32,009 --> 00:05:38,789
want to delete does its next prove

122
00:05:35,639 --> 00:05:40,740
back to entry as you would expect in a

123
00:05:38,789 --> 00:05:42,840
doubly linked list and those types of

124
00:05:40,740 --> 00:05:45,389
checks to ensure that you can't use that

125
00:05:42,840 --> 00:05:48,179
I'm linking so this confirms even more

126
00:05:45,389 --> 00:05:51,330
okay we probably want a none linking

127
00:05:48,180 --> 00:05:55,380
primitive with this bug the next detail

128
00:05:51,330 --> 00:05:58,680
we had is that config armed 64 ye you AO

129
00:05:55,380 --> 00:06:03,680
hinders exploitation doesn't break it it

130
00:05:58,680 --> 00:06:09,199
just hinders it so you AO is user access

131
00:06:03,680 --> 00:06:12,029
shoot basically what it means is that

132
00:06:09,199 --> 00:06:14,819
with we were trying to overwrite the

133
00:06:12,029 --> 00:06:18,509
address limit which we are which tells

134
00:06:14,819 --> 00:06:22,080
you whether or not your user your user

135
00:06:18,509 --> 00:06:24,800
mode operation for example can access

136
00:06:22,080 --> 00:06:28,289
kernel memory or not it's that bound

137
00:06:24,800 --> 00:06:30,210
rather than our exploit just overwriting

138
00:06:28,289 --> 00:06:32,190
the address limit in the test drug it

139
00:06:30,210 --> 00:06:36,239
would have to change another flag if

140
00:06:32,190 --> 00:06:37,860
config arm 64 UAL is also enabled so we

141
00:06:36,240 --> 00:06:39,780
can get from that that the exploit is

142
00:06:37,860 --> 00:06:43,560
likely using memory corruption to

143
00:06:39,780 --> 00:06:45,690
change that address limit next we heard

144
00:06:43,560 --> 00:06:48,000
the vulnerability is exploitable in

145
00:06:45,690 --> 00:06:50,790
Chrome's rendering processes under

146
00:06:48,000 --> 00:06:53,010
androids isolated app SELinux domain so

147
00:06:50,790 --> 00:06:55,650
this is very similar to the first bullet

148
00:06:53,010 --> 00:06:58,020
point and what we double checked is that

149
00:06:55,650 --> 00:07:00,270
this would actually be true of also

150
00:06:58,020 --> 00:07:04,560
Firefox or others they're running

151
00:07:00,270 --> 00:07:06,150
similar but it's likely that this local

152
00:07:04,560 --> 00:07:10,350
privileged escalation bug that we're

153
00:07:06,150 --> 00:07:13,380
looking for is paired with a browser

154
00:07:10,350 --> 00:07:15,090
render or chrome render or exploit so

155
00:07:13,380 --> 00:07:16,860
that no longer is it a local privilege

156
00:07:15,090 --> 00:07:21,900
escalation it's a chain that can be

157
00:07:16,860 --> 00:07:23,820
delivered remotely next fix exploit

158
00:07:21,900 --> 00:07:26,159
requires little or no des per device

159
00:07:23,820 --> 00:07:28,409
customization which again goes back to

160
00:07:26,160 --> 00:07:30,900
the kernel thing but it's telling us

161
00:07:28,410 --> 00:07:34,130
that this is likely in the common kernel

162
00:07:30,900 --> 00:07:37,289
of Android rather than a am

163
00:07:34,130 --> 00:07:39,389
customization such as Samsung's

164
00:07:37,290 --> 00:07:41,580
customizations to the kernel or Google

165
00:07:39,389 --> 00:07:43,590
pixels customizations to the kernel so

166
00:07:41,580 --> 00:07:46,560
it further helps us understand where are

167
00:07:43,590 --> 00:07:49,200
we looking for a bug and lastly we had a

168
00:07:46,560 --> 00:07:50,850
list of affected devices the last slide

169
00:07:49,200 --> 00:07:53,520
of this I will link to a blog post about

170
00:07:50,850 --> 00:07:55,350
this as well as the p0 issue tracker and

171
00:07:53,520 --> 00:07:58,799
so that's where you can find the full

172
00:07:55,350 --> 00:07:59,460
list so what do I do with this

173
00:07:58,800 --> 00:08:01,410
information

174
00:07:59,460 --> 00:08:04,590
again as I said I hadn't looked at the

175
00:08:01,410 --> 00:08:07,229
kernels before thankfully had a team

176
00:08:04,590 --> 00:08:09,150
with a lot of expertise but it's just

177
00:08:07,229 --> 00:08:12,210
tedious I started going through patch

178
00:08:09,150 --> 00:08:13,440
tipping and chain I started going

179
00:08:12,210 --> 00:08:16,049
through change logs and different

180
00:08:13,440 --> 00:08:18,510
patches using lore to look up for

181
00:08:16,050 --> 00:08:21,630
patches that included list L or list add

182
00:08:18,510 --> 00:08:24,450
information and honestly didn't find

183
00:08:21,630 --> 00:08:25,919
much with this first process with just

184
00:08:24,450 --> 00:08:29,610
these details in my limited knowledge

185
00:08:25,919 --> 00:08:31,349
about that space I had found a bug that

186
00:08:29,610 --> 00:08:33,690
I got really excited about kept

187
00:08:31,350 --> 00:08:36,270
following through and then it turned out

188
00:08:33,690 --> 00:08:40,650
that it didn't match every detail

189
00:08:36,270 --> 00:08:42,360
exactly and so thankfully about a week

190
00:08:40,650 --> 00:08:43,919
or two after I had found that bug and

191
00:08:42,360 --> 00:08:45,390
gotten pretty discouraged didn't know

192
00:08:43,919 --> 00:08:47,760
where else to look

193
00:08:45,390 --> 00:08:51,089
I'd gotten information that did you look

194
00:08:47,760 --> 00:08:53,310
in detail at binder so binder driver is

195
00:08:51,089 --> 00:08:55,680
drivers Android binder see

196
00:08:53,310 --> 00:08:58,469
and so once it was scoped down to a

197
00:08:55,680 --> 00:09:00,689
single file that's when I began to do

198
00:08:58,470 --> 00:09:03,210
the dipping between pixel 2 and pixel 3

199
00:09:00,690 --> 00:09:05,760
and there were only actually a couple of

200
00:09:03,210 --> 00:09:08,400
significant diff or changes between

201
00:09:05,760 --> 00:09:10,260
those two there enough that you could go

202
00:09:08,400 --> 00:09:12,029
through every single one of them and

203
00:09:10,260 --> 00:09:15,029
this commit in particular stood out

204
00:09:12,029 --> 00:09:17,420
because one it says use after free and

205
00:09:15,029 --> 00:09:19,830
it's changelog and that is fixing it

206
00:09:17,420 --> 00:09:23,610
next it's a patch coming from linux

207
00:09:19,830 --> 00:09:27,510
upstream into the Android kernel for

208
00:09:23,610 --> 00:09:31,440
pixel 3 the upstream patch was also only

209
00:09:27,510 --> 00:09:34,080
applied to 4.14 kernel and lastly be use

210
00:09:31,440 --> 00:09:37,830
after free includes a list L operation

211
00:09:34,080 --> 00:09:39,930
on the freed object so this stood out

212
00:09:37,830 --> 00:09:42,630
super obvious when your patch knipfing

213
00:09:39,930 --> 00:09:43,640
and thus ended up being the bug when I

214
00:09:42,630 --> 00:09:45,960
went through each of these different

215
00:09:43,640 --> 00:09:50,760
details we knew it ended up matching

216
00:09:45,960 --> 00:09:55,080
exactly so what is the bug it's covered

217
00:09:50,760 --> 00:09:57,150
under the CVE number now but it is a use

218
00:09:55,080 --> 00:09:59,700
after free and the Android binder driver

219
00:09:57,150 --> 00:10:01,230
due to a pull handler using a way queue

220
00:09:59,700 --> 00:10:04,170
that is not tied to the lifetime of the

221
00:10:01,230 --> 00:10:06,900
file so what that means is one we have a

222
00:10:04,170 --> 00:10:08,760
use after free in the Android binder

223
00:10:06,900 --> 00:10:11,160
driver if you're not up to speed on

224
00:10:08,760 --> 00:10:13,770
Android binder it is the inter-process

225
00:10:11,160 --> 00:10:16,680
communication mechanism within Android

226
00:10:13,770 --> 00:10:19,470
and so it's a kernel driver and kernel

227
00:10:16,680 --> 00:10:21,900
drivers perform file operations to

228
00:10:19,470 --> 00:10:25,500
perform the different things so in this

229
00:10:21,900 --> 00:10:28,290
case it's the pull operation in this

230
00:10:25,500 --> 00:10:32,070
Android binder drivers pull handler is

231
00:10:28,290 --> 00:10:35,730
getting passed away queue that can be

232
00:10:32,070 --> 00:10:39,180
freed prior to the Android binder driver

233
00:10:35,730 --> 00:10:42,420
being released so that is in a sentence

234
00:10:39,180 --> 00:10:44,790
what this vulnerability is so this is

235
00:10:42,420 --> 00:10:46,410
the binder thread struct and in the

236
00:10:44,790 --> 00:10:47,939
binder thread struct is where this

237
00:10:46,410 --> 00:10:49,980
weight queue lives that we are passing

238
00:10:47,940 --> 00:10:53,670
to the pull handler and can be free and

239
00:10:49,980 --> 00:10:55,230
this weight queue has this structure

240
00:10:53,670 --> 00:10:57,959
definition where it's just a spin lock

241
00:10:55,230 --> 00:11:00,060
and a list head the list head if you're

242
00:10:57,959 --> 00:11:04,829
not familiar with the Linux kernel it

243
00:11:00,060 --> 00:11:07,079
has a next and a proven it and so if

244
00:11:04,830 --> 00:11:08,850
this binder thread is free

245
00:11:07,080 --> 00:11:11,490
so is the wait queue because if you

246
00:11:08,850 --> 00:11:14,610
notice it's embedded in there it's not a

247
00:11:11,490 --> 00:11:17,040
pointer but then when we take a look at

248
00:11:14,610 --> 00:11:22,140
our pull function within the binder

249
00:11:17,040 --> 00:11:24,630
driver when the file that this operation

250
00:11:22,140 --> 00:11:27,600
is being performed on is the binder proc

251
00:11:24,630 --> 00:11:30,840
struct as shown by the file pointer and

252
00:11:27,600 --> 00:11:34,050
what it's casted or what it is there but

253
00:11:30,840 --> 00:11:36,150
when then we call pull wait we're

254
00:11:34,050 --> 00:11:38,819
passing that same binder proc as the

255
00:11:36,150 --> 00:11:41,520
file pointer but the second argument

256
00:11:38,820 --> 00:11:44,550
which is our way queue is binder thread

257
00:11:41,520 --> 00:11:47,069
so the normal operation that would be

258
00:11:44,550 --> 00:11:50,910
secure is that the wait queue that you

259
00:11:47,070 --> 00:11:54,030
pass here can't be freed and is assured

260
00:11:50,910 --> 00:11:57,060
to be alive until release is called on

261
00:11:54,030 --> 00:12:01,380
that file however as we've seen that's

262
00:11:57,060 --> 00:12:03,869
not the case here so taking a step back

263
00:12:01,380 --> 00:12:05,970
as I've said before I was not the first

264
00:12:03,870 --> 00:12:10,650
one to find this bug it had been patched

265
00:12:05,970 --> 00:12:13,620
in first in February 2018 after being

266
00:12:10,650 --> 00:12:15,360
discovered by sis caller which is a sis

267
00:12:13,620 --> 00:12:18,000
bot is a fuzzer that is running

268
00:12:15,360 --> 00:12:22,320
constantly over the Linux kernel had

269
00:12:18,000 --> 00:12:25,050
reported it in November 2017 so February

270
00:12:22,320 --> 00:12:27,390
2018 after they'd gotten the bug report

271
00:12:25,050 --> 00:12:30,689
had looked at it they then patched it up

272
00:12:27,390 --> 00:12:32,460
stream in for 1/4 and also the patch had

273
00:12:30,690 --> 00:12:35,850
been taken in the android common kernels

274
00:12:32,460 --> 00:12:38,460
for 4.9 which is the pixel three four

275
00:12:35,850 --> 00:12:41,070
point four which is pixel two and the

276
00:12:38,460 --> 00:12:44,700
other devices that were launched in that

277
00:12:41,070 --> 00:12:46,980
fall 2017 period and then three point

278
00:12:44,700 --> 00:12:50,550
one eight which is the same life cycle

279
00:12:46,980 --> 00:12:52,950
pixel one however it was never included

280
00:12:50,550 --> 00:12:56,130
in the android security bulletins so

281
00:12:52,950 --> 00:12:58,860
what this means is that OMS and Android

282
00:12:56,130 --> 00:13:00,810
devices were never said hey here's a

283
00:12:58,860 --> 00:13:03,180
patch for a security issue you need to

284
00:13:00,810 --> 00:13:05,579
now apply this to the devices so that's

285
00:13:03,180 --> 00:13:09,089
how pixel three ended up not being

286
00:13:05,580 --> 00:13:12,240
affected because pixel three launched in

287
00:13:09,089 --> 00:13:14,339
fall of 2018 this device for this patch

288
00:13:12,240 --> 00:13:16,440
had been applied in February 2018 to the

289
00:13:14,339 --> 00:13:18,690
four nine kernel so it was only

290
00:13:16,440 --> 00:13:20,000
affecting all the devices that had been

291
00:13:18,690 --> 00:13:23,110
launched prior to that

292
00:13:20,000 --> 00:13:27,050
but there's been some discussion as

293
00:13:23,110 --> 00:13:30,410
throughout this one that is this 2-0 day

294
00:13:27,050 --> 00:13:31,839
should this be called a 677 day where is

295
00:13:30,410 --> 00:13:34,129
it and I think there's a lot of

296
00:13:31,839 --> 00:13:35,629
interesting discussion for us to have as

297
00:13:34,129 --> 00:13:37,519
a community because they have different

298
00:13:35,629 --> 00:13:39,829
implications but I don't think there's

299
00:13:37,519 --> 00:13:41,540
one right answer because in terms of

300
00:13:39,829 --> 00:13:42,739
zero day if we considered zero days as

301
00:13:41,540 --> 00:13:46,699
something that defenders don't know

302
00:13:42,740 --> 00:13:49,879
about and users don't know about this is

303
00:13:46,699 --> 00:13:52,490
it because the the defenders are Android

304
00:13:49,879 --> 00:13:54,889
or OEMs didn't know this was a security

305
00:13:52,490 --> 00:13:56,899
bug that they should have in there but

306
00:13:54,889 --> 00:13:58,870
if we call it a zero day then it's

307
00:13:56,899 --> 00:14:01,519
alleviating some responsibility of

308
00:13:58,870 --> 00:14:03,290
monitoring upstream patches syncing to

309
00:14:01,519 --> 00:14:06,259
upstream patches and things like that

310
00:14:03,290 --> 00:14:08,959
and instead this has been left unpatched

311
00:14:06,259 --> 00:14:10,910
for 677 days even though it was upstream

312
00:14:08,959 --> 00:14:13,910
so I think it's an interesting

313
00:14:10,910 --> 00:14:16,790
discussion and requires some nuance but

314
00:14:13,910 --> 00:14:20,230
there's also no real one answer I don't

315
00:14:16,790 --> 00:14:22,480
think so let's get into the fun stuff

316
00:14:20,230 --> 00:14:25,910
how do we exploit it

317
00:14:22,480 --> 00:14:28,639
so this caller back in November 2017

318
00:14:25,910 --> 00:14:32,029
actually was able to on its own create a

319
00:14:28,639 --> 00:14:34,990
sea reducer for the buck so what this is

320
00:14:32,029 --> 00:14:37,879
is that you see we're opening binder as

321
00:14:34,990 --> 00:14:40,129
Wynn does for a driver and then we're

322
00:14:37,879 --> 00:14:43,670
creating we're associating it with a

323
00:14:40,129 --> 00:14:46,189
pole but then we free that binder thread

324
00:14:43,670 --> 00:14:48,979
struct with the IAP till find our thread

325
00:14:46,189 --> 00:14:50,959
exit so as of now that wait queue is

326
00:14:48,980 --> 00:14:54,079
still associated with the pole handler

327
00:14:50,959 --> 00:14:58,279
in a pole and then when we exit main as

328
00:14:54,079 --> 00:15:00,800
the next step eople CTL del is

329
00:14:58,279 --> 00:15:04,040
automatically called with an exit which

330
00:15:00,800 --> 00:15:07,069
tries to remove our way cue from the

331
00:15:04,040 --> 00:15:09,079
pole handler that wait queue has already

332
00:15:07,069 --> 00:15:11,269
been freed though so now we're

333
00:15:09,079 --> 00:15:14,029
performing this list del operation on

334
00:15:11,269 --> 00:15:17,209
this already freed wake you and that's

335
00:15:14,029 --> 00:15:23,480
how this crash POC works so we have a

336
00:15:17,209 --> 00:15:25,518
crash pop how do we exploit it so I

337
00:15:23,480 --> 00:15:28,730
teamed up with Yan horn to write this as

338
00:15:25,519 --> 00:15:30,500
soon as we verified the bug be reported

339
00:15:28,730 --> 00:15:32,899
to Android under seven-day deadlines and

340
00:15:30,500 --> 00:15:33,670
we really wanted to show that this was

341
00:15:32,899 --> 00:15:36,550
an

342
00:15:33,670 --> 00:15:38,530
voidable puck being used in the wild and

343
00:15:36,550 --> 00:15:40,750
so we got to work trying to write this

344
00:15:38,530 --> 00:15:43,089
in less than seven days and our goal was

345
00:15:40,750 --> 00:15:45,010
to use this bug to grab our betray

346
00:15:43,090 --> 00:15:47,770
Colonel read and write from an

347
00:15:45,010 --> 00:15:49,180
unprivileged application context so the

348
00:15:47,770 --> 00:15:50,860
primitive we were using as I've said a

349
00:15:49,180 --> 00:15:54,010
couple of times is the unlinking of the

350
00:15:50,860 --> 00:15:55,660
doubly linked list and to actually get

351
00:15:54,010 --> 00:15:57,550
that arbitrary Colonel read and white

352
00:15:55,660 --> 00:16:00,520
right we're going to trigger our use

353
00:15:57,550 --> 00:16:02,890
after for a twice the first time we're

354
00:16:00,520 --> 00:16:05,079
gonna use that the use after free to be

355
00:16:02,890 --> 00:16:07,449
able to read out the tests truck to

356
00:16:05,080 --> 00:16:09,280
address from the colonel because our

357
00:16:07,450 --> 00:16:10,960
goal to get that arbitrary colonel read

358
00:16:09,280 --> 00:16:13,569
and write is to overwrite the address

359
00:16:10,960 --> 00:16:16,150
limit and the address limit lives within

360
00:16:13,570 --> 00:16:17,620
the test struct so we leak that address

361
00:16:16,150 --> 00:16:19,810
the first time and then we trigger the

362
00:16:17,620 --> 00:16:22,030
use after free a second time and that's

363
00:16:19,810 --> 00:16:27,010
when we actually overwrite the address

364
00:16:22,030 --> 00:16:29,740
limit so the address limit is a value

365
00:16:27,010 --> 00:16:31,840
which defines the address range that can

366
00:16:29,740 --> 00:16:34,840
be accessed when dereferencing user

367
00:16:31,840 --> 00:16:38,650
space pointers so if we change that then

368
00:16:34,840 --> 00:16:43,870
we in our user mode user space process

369
00:16:38,650 --> 00:16:45,670
can now access kernel memory the timer

370
00:16:43,870 --> 00:16:49,960
says I have 43 minutes and I was only a

371
00:16:45,670 --> 00:16:53,260
30-minute slots but someone can help me

372
00:16:49,960 --> 00:16:55,600
do timing but uh so the way that we are

373
00:16:53,260 --> 00:16:58,180
going to do this is we're gonna actually

374
00:16:55,600 --> 00:17:03,370
use vectored i/o also known as scatter

375
00:16:58,180 --> 00:17:04,690
gather IO and so detian does this in a

376
00:17:03,370 --> 00:17:07,540
similar method he talks about in his

377
00:17:04,690 --> 00:17:08,950
code blue 2017 talk so I suggest that

378
00:17:07,540 --> 00:17:12,040
talk to if you're interested in this

379
00:17:08,950 --> 00:17:14,290
exploitation method so what is vectored

380
00:17:12,040 --> 00:17:17,770
i/o we are using it because we need a

381
00:17:14,290 --> 00:17:20,409
way to reallocate something we control

382
00:17:17,770 --> 00:17:23,889
over that now freed binder thread struct

383
00:17:20,410 --> 00:17:26,440
and so the way vectored IO works very

384
00:17:23,890 --> 00:17:29,410
briefly is that a vectored read you're

385
00:17:26,440 --> 00:17:33,010
taking data from a source it could be a

386
00:17:29,410 --> 00:17:35,830
socket a pipe etc we're using a file and

387
00:17:33,010 --> 00:17:38,050
we will scatter it to disparate buffers

388
00:17:35,830 --> 00:17:41,020
in memory and those disparate buffers

389
00:17:38,050 --> 00:17:43,659
are stated by a certain struct which

390
00:17:41,020 --> 00:17:46,120
we'll get to vector writes on the other

391
00:17:43,660 --> 00:17:47,230
hand are taking data from disparate

392
00:17:46,120 --> 00:17:50,649
buffers and putting them

393
00:17:47,230 --> 00:17:53,169
into a data sink in our case of file so

394
00:17:50,650 --> 00:17:56,860
although vectored reads in vectored

395
00:17:53,169 --> 00:17:58,210
writes in our space in our situation and

396
00:17:56,860 --> 00:18:00,219
how we're trying to read and write to

397
00:17:58,210 --> 00:18:03,580
kernel they're actually the opposite we

398
00:18:00,220 --> 00:18:06,010
use the read to do a kernel right and we

399
00:18:03,580 --> 00:18:10,600
use the vectored write to do a kernel

400
00:18:06,010 --> 00:18:13,480
read so I mentioned that this includes

401
00:18:10,600 --> 00:18:15,549
different buffers throughout memory so

402
00:18:13,480 --> 00:18:17,350
the struct we're actually using to

403
00:18:15,549 --> 00:18:19,900
reallocate the space from the binder

404
00:18:17,350 --> 00:18:21,490
thread struct that was freed is an array

405
00:18:19,900 --> 00:18:24,429
of Iowa backstraps

406
00:18:21,490 --> 00:18:26,410
this array tells these read and write

407
00:18:24,429 --> 00:18:28,840
operations where all these different

408
00:18:26,410 --> 00:18:31,390
buffers that I'm using that I'm going to

409
00:18:28,840 --> 00:18:34,570
use for these different IO ops so the

410
00:18:31,390 --> 00:18:37,150
struct IO Beck is 16 bytes first with a

411
00:18:34,570 --> 00:18:39,610
pointer to the beginning of the first

412
00:18:37,150 --> 00:18:42,880
buffer and then the second one is the

413
00:18:39,610 --> 00:18:45,159
length of what that buffer is so we

414
00:18:42,880 --> 00:18:47,200
create an array of these different

415
00:18:45,160 --> 00:18:50,100
strokes that is almost the exact same

416
00:18:47,200 --> 00:18:53,650
size of our binder thread because it is

417
00:18:50,100 --> 00:18:57,090
16 and our binder thread struct was hex

418
00:18:53,650 --> 00:19:00,370
408 we're eight bytes off but because

419
00:18:57,090 --> 00:19:03,159
the kernel memory allocator basically

420
00:19:00,370 --> 00:19:05,520
allocates based on sides and slabs it

421
00:19:03,160 --> 00:19:10,169
was enough that we can rely reliably

422
00:19:05,520 --> 00:19:12,970
reliably reallocate into that space and

423
00:19:10,169 --> 00:19:16,540
so what's interesting is although we're

424
00:19:12,970 --> 00:19:20,200
creating these I avec arrays and user

425
00:19:16,540 --> 00:19:22,178
space the operations will actually copy

426
00:19:20,200 --> 00:19:25,000
them into the kernel so that's how we

427
00:19:22,179 --> 00:19:28,929
get this overwrite of the freed memory

428
00:19:25,000 --> 00:19:30,820
in the kernel so this is what it looks

429
00:19:28,929 --> 00:19:33,549
like when we reallocate we have our

430
00:19:30,820 --> 00:19:36,370
binder thread struct at offset AO is

431
00:19:33,549 --> 00:19:37,929
where our weight queue begins starting

432
00:19:36,370 --> 00:19:40,750
with the spinlock and then the two

433
00:19:37,929 --> 00:19:43,299
entries and the task list and so when we

434
00:19:40,750 --> 00:19:48,790
reallocate our i/o vekar a there then

435
00:19:43,299 --> 00:19:52,750
that ends up being indexed n io vac the

436
00:19:48,790 --> 00:19:55,210
io v base again the address of the

437
00:19:52,750 --> 00:19:57,909
buffer then the length and then in the

438
00:19:55,210 --> 00:20:00,470
next entry which is another entry to the

439
00:19:57,909 --> 00:20:02,830
buffer and so to over write

440
00:20:00,470 --> 00:20:04,610
now we use our unlinking primitive Oh

441
00:20:02,830 --> 00:20:07,970
jumped ahead a little bit

442
00:20:04,610 --> 00:20:10,490
so Oh to get to the unlinking primitive

443
00:20:07,970 --> 00:20:13,130
we call EP control del which will then

444
00:20:10,490 --> 00:20:17,240
call EP remove which will then call EP

445
00:20:13,130 --> 00:20:18,770
remove weight Q so when the system still

446
00:20:17,240 --> 00:20:20,809
believes that the week he was living in

447
00:20:18,770 --> 00:20:23,900
this memory it is going to try and

448
00:20:20,809 --> 00:20:27,889
remove it and do all of these different

449
00:20:23,900 --> 00:20:29,840
steps to end up on our list l and so as

450
00:20:27,890 --> 00:20:34,010
of now when it's trying to do this list

451
00:20:29,840 --> 00:20:36,530
del it wants to delete this entry in the

452
00:20:34,010 --> 00:20:40,780
kernel which points back to the list

453
00:20:36,530 --> 00:20:43,340
head the list head which is in our

454
00:20:40,780 --> 00:20:43,760
binder thread struct within the weight

455
00:20:43,340 --> 00:20:46,039
queue

456
00:20:43,760 --> 00:20:49,400
and so we've overwritten those values

457
00:20:46,039 --> 00:20:52,129
with using our i/o back array so that

458
00:20:49,400 --> 00:20:55,280
now proved in our doubly linked list

459
00:20:52,130 --> 00:20:58,940
currently is dead beef and we set the

460
00:20:55,280 --> 00:21:01,490
length to a thousand so when we perform

461
00:20:58,940 --> 00:21:03,530
a list del on this and config debug list

462
00:21:01,490 --> 00:21:08,419
is not enabled so it's not double

463
00:21:03,530 --> 00:21:11,830
checking that that list had previous you

464
00:21:08,419 --> 00:21:15,860
would expect in a doubly linked list we

465
00:21:11,830 --> 00:21:19,340
now have this structure where it's now

466
00:21:15,860 --> 00:21:22,340
pointing prefactor list head which is

467
00:21:19,340 --> 00:21:26,030
the address in kernel memory and so now

468
00:21:22,340 --> 00:21:29,270
we have an i/o vac array where we are

469
00:21:26,030 --> 00:21:31,340
saying a buffer is living in kernel

470
00:21:29,270 --> 00:21:33,770
memory after they've done the double

471
00:21:31,340 --> 00:21:36,408
checks that our buffers were only in

472
00:21:33,770 --> 00:21:39,470
user round space so this is now how we

473
00:21:36,409 --> 00:21:44,000
are able to perform IO operations to and

474
00:21:39,470 --> 00:21:47,020
from kernel memory so demo and now I

475
00:21:44,000 --> 00:21:47,020
pray to the demo gods

476
00:21:51,650 --> 00:22:03,140
what not everyone uses a pink terminal

477
00:21:55,840 --> 00:22:08,030
so here I have a oh okay so I have a

478
00:22:03,140 --> 00:22:14,210
pixel term device and if we want to see

479
00:22:08,030 --> 00:22:16,490
what the build fingerprint is oops so

480
00:22:14,210 --> 00:22:19,310
it's running Android ten in the

481
00:22:16,490 --> 00:22:23,150
September SPL which is right before they

482
00:22:19,310 --> 00:22:25,879
patched this bug and if you look because

483
00:22:23,150 --> 00:22:28,700
we are demonstrating the kernel rewrite

484
00:22:25,880 --> 00:22:32,210
by overriding the kernel name so here's

485
00:22:28,700 --> 00:22:35,800
a normal one and Who am I I'm just

486
00:22:32,210 --> 00:22:38,380
running a shell we did demo in our

487
00:22:35,800 --> 00:22:41,330
project zero issue showing as a

488
00:22:38,380 --> 00:22:43,100
untrusted app but trying to video the

489
00:22:41,330 --> 00:22:46,220
phone wouldn't have been a great

490
00:22:43,100 --> 00:22:48,350
experience so now I'm gonna run our POC

491
00:22:46,220 --> 00:22:54,310
which was released in the project zero

492
00:22:48,350 --> 00:22:58,490
issue tracker so it did the first step

493
00:22:54,310 --> 00:23:01,190
where we were doing the read to leak the

494
00:22:58,490 --> 00:23:03,320
task struct to address which is current

495
00:23:01,190 --> 00:23:06,380
pointers equal equal that's what the

496
00:23:03,320 --> 00:23:08,060
task struct address was we then run this

497
00:23:06,380 --> 00:23:11,360
whole thing again where we actually

498
00:23:08,060 --> 00:23:14,510
rewrite that kernel address and we use

499
00:23:11,360 --> 00:23:16,879
that ability to read right to now show

500
00:23:14,510 --> 00:23:20,540
that we were able to overwrite the

501
00:23:16,880 --> 00:23:22,490
kernel name to exploited kernel so that

502
00:23:20,540 --> 00:23:24,730
is how we got arbitrary kernel read

503
00:23:22,490 --> 00:23:24,730
right

504
00:23:31,150 --> 00:23:37,370
so yeah all that's been released there's

505
00:23:34,250 --> 00:23:41,020
a blog post that talks about that super

506
00:23:37,370 --> 00:23:43,610
more in depth as well as others have now

507
00:23:41,020 --> 00:23:45,860
created put that all together to create

508
00:23:43,610 --> 00:23:49,039
a route that is available too if you're

509
00:23:45,860 --> 00:23:51,799
looking to root your device but this led

510
00:23:49,039 --> 00:23:54,408
to some interesting conversations beyond

511
00:23:51,799 --> 00:23:57,679
just here's above here's a vulnerability

512
00:23:54,409 --> 00:24:00,380
its exploitable there was the whole

513
00:23:57,679 --> 00:24:02,720
other layer of this of this is being

514
00:24:00,380 --> 00:24:04,789
used against people and our job as

515
00:24:02,720 --> 00:24:08,570
security professionals is try to help

516
00:24:04,789 --> 00:24:11,390
people so we reported under a seven-day

517
00:24:08,570 --> 00:24:13,399
disclosure deadline but we didn't have

518
00:24:11,390 --> 00:24:16,700
an exploit sample to demonstrate look

519
00:24:13,400 --> 00:24:18,919
here this is the proof that this is

520
00:24:16,700 --> 00:24:22,669
being used to try and exploit people and

521
00:24:18,919 --> 00:24:25,460
the reason why I and others didn't think

522
00:24:22,669 --> 00:24:27,679
it was necessary is that it seemed like

523
00:24:25,460 --> 00:24:29,840
there was enough evidence that this was

524
00:24:27,679 --> 00:24:33,590
being used to target people and that

525
00:24:29,840 --> 00:24:36,289
this file into Google's published policy

526
00:24:33,590 --> 00:24:38,418
of each day and actively exploited

527
00:24:36,289 --> 00:24:40,850
vulnerability remains undisclosed to the

528
00:24:38,419 --> 00:24:43,159
public and unpatched more devices or

529
00:24:40,850 --> 00:24:45,080
accounts can be compromised but it did

530
00:24:43,159 --> 00:24:48,200
in a led to a lot of discussions within

531
00:24:45,080 --> 00:24:50,030
ourself of what is the bar for reporting

532
00:24:48,200 --> 00:24:53,120
something as in the wild and thus under

533
00:24:50,030 --> 00:24:54,830
a very short timeline how do we all make

534
00:24:53,120 --> 00:24:56,449
those decisions that can be agreed to

535
00:24:54,830 --> 00:24:58,639
that we feel good about that we know

536
00:24:56,450 --> 00:25:02,539
we're not just putting this really tough

537
00:24:58,640 --> 00:25:05,570
deadline on people but we decided to do

538
00:25:02,539 --> 00:25:07,789
that because there was all these details

539
00:25:05,570 --> 00:25:12,350
about this capability with this

540
00:25:07,789 --> 00:25:15,158
association to an organization and also

541
00:25:12,350 --> 00:25:19,639
when I reviewed all these kernel patches

542
00:25:15,159 --> 00:25:21,799
there was only one bug and earth this

543
00:25:19,640 --> 00:25:24,049
bug matched every single detail we

544
00:25:21,799 --> 00:25:26,090
received including the long list of

545
00:25:24,049 --> 00:25:29,000
affected devices and not affect affected

546
00:25:26,090 --> 00:25:31,158
devices and it was the only bug that

547
00:25:29,000 --> 00:25:32,539
matched all of these so after matching

548
00:25:31,159 --> 00:25:36,289
it I went through every other diff

549
00:25:32,539 --> 00:25:40,760
within the binder the binder changes and

550
00:25:36,289 --> 00:25:42,800
none of the others matched but my whole

551
00:25:40,760 --> 00:25:45,260
role here is trying to see

552
00:25:42,800 --> 00:25:47,419
how do we make zero-day hard by learning

553
00:25:45,260 --> 00:25:50,540
as much as we can and how do we approach

554
00:25:47,420 --> 00:25:53,210
zero days in the wild and so this has

555
00:25:50,540 --> 00:25:56,240
included a lot of different efforts one

556
00:25:53,210 --> 00:25:57,890
reversing exploit samples to one of the

557
00:25:56,240 --> 00:25:59,660
biggest things we've been doing is root

558
00:25:57,890 --> 00:26:02,210
cause analysis on the vulnerability

559
00:25:59,660 --> 00:26:04,160
there's often a lot of talk about the

560
00:26:02,210 --> 00:26:05,780
exploit payloads and the threat actors

561
00:26:04,160 --> 00:26:07,760
behind them but what is that

562
00:26:05,780 --> 00:26:11,420
vulnerability that makes it a zero day

563
00:26:07,760 --> 00:26:13,790
and thus dangerous so hopefully we'll be

564
00:26:11,420 --> 00:26:17,300
publishing a lot of those RCS we've been

565
00:26:13,790 --> 00:26:19,100
working on in the coming months or so

566
00:26:17,300 --> 00:26:21,800
we've been doing a lot of variant

567
00:26:19,100 --> 00:26:23,449
analysis which the next slide will talk

568
00:26:21,800 --> 00:26:24,950
about the variant analysis on this bug

569
00:26:23,450 --> 00:26:28,130
because if we think about it as

570
00:26:24,950 --> 00:26:30,680
researchers we often find more than one

571
00:26:28,130 --> 00:26:32,960
bug at a time you might choose to only

572
00:26:30,680 --> 00:26:34,250
exploit one because it's the easiest but

573
00:26:32,960 --> 00:26:36,290
you usually find a couple of other

574
00:26:34,250 --> 00:26:39,200
things as you're looking and so we can

575
00:26:36,290 --> 00:26:42,080
assume that the other side is also doing

576
00:26:39,200 --> 00:26:44,540
that as well so if there has been this

577
00:26:42,080 --> 00:26:47,210
failure case where a zero-day in the

578
00:26:44,540 --> 00:26:49,370
wild has been detected which is a

579
00:26:47,210 --> 00:26:51,500
failure case how can we make sure that

580
00:26:49,370 --> 00:26:53,840
we use every piece of information that

581
00:26:51,500 --> 00:26:55,820
is leaked from that detection that

582
00:26:53,840 --> 00:26:58,250
failure to make it that much harder and

583
00:26:55,820 --> 00:27:01,610
raise the investment for anyone who

584
00:26:58,250 --> 00:27:03,170
wants to use them in the Wow we've also

585
00:27:01,610 --> 00:27:05,060
been taking this information to

586
00:27:03,170 --> 00:27:07,880
brainstorm new detection methods and

587
00:27:05,060 --> 00:27:10,879
work with people in that way but what

588
00:27:07,880 --> 00:27:13,160
this requires and what we all need to be

589
00:27:10,880 --> 00:27:14,810
doing is collaboration so if you want to

590
00:27:13,160 --> 00:27:15,650
talk to me after this I'd love to talk

591
00:27:14,810 --> 00:27:17,720
to you

592
00:27:15,650 --> 00:27:22,610
to see how we can all work together in

593
00:27:17,720 --> 00:27:25,430
this space but in that all rows into

594
00:27:22,610 --> 00:27:28,010
obviously did some variant analysis on

595
00:27:25,430 --> 00:27:29,720
this bug to see what else might that

596
00:27:28,010 --> 00:27:31,310
have find is there any vulnerabilities

597
00:27:29,720 --> 00:27:34,640
available that they could plug and play

598
00:27:31,310 --> 00:27:36,409
once this one is burned and so I did two

599
00:27:34,640 --> 00:27:38,930
different variant analysis approaches

600
00:27:36,410 --> 00:27:41,240
and I went into this case study in depth

601
00:27:38,930 --> 00:27:43,280
last week at blue hat IL as well as some

602
00:27:41,240 --> 00:27:44,930
other 0 days and alone so if this is

603
00:27:43,280 --> 00:27:48,500
what you're interested in that video

604
00:27:44,930 --> 00:27:51,410
should be out soon but I approached it

605
00:27:48,500 --> 00:27:53,090
from both what bugs have been patched in

606
00:27:51,410 --> 00:27:53,990
the upstream that haven't made it down

607
00:27:53,090 --> 00:27:55,790
to

608
00:27:53,990 --> 00:27:58,760
that Android devices that were

609
00:27:55,790 --> 00:28:00,379
previously launched as well as are there

610
00:27:58,760 --> 00:28:03,140
any other drivers in the Linux kernel

611
00:28:00,380 --> 00:28:07,130
whose pole handler uses awake cue that

612
00:28:03,140 --> 00:28:10,040
can be freed prior to that file being

613
00:28:07,130 --> 00:28:13,370
released and so approach number one left

614
00:28:10,040 --> 00:28:17,000
led to a bug that was patched in last

615
00:28:13,370 --> 00:28:19,489
months or February last week's Android

616
00:28:17,000 --> 00:28:21,710
security bulletins and it is actually a

617
00:28:19,490 --> 00:28:24,170
bug that was introduced by the patch for

618
00:28:21,710 --> 00:28:27,679
this first bug and also had been in the

619
00:28:24,170 --> 00:28:29,780
Linux kernel so that's one I talked

620
00:28:27,679 --> 00:28:32,090
about it again last week at blue hat and

621
00:28:29,780 --> 00:28:34,490
the second one I went through two

622
00:28:32,090 --> 00:28:36,350
hundred and something different files

623
00:28:34,490 --> 00:28:38,390
that included calls to pole weight and

624
00:28:36,350 --> 00:28:40,760
thankfully there was only one other

625
00:28:38,390 --> 00:28:42,890
potential bug where the way queue that

626
00:28:40,760 --> 00:28:45,350
was being passed a pole weight what's

627
00:28:42,890 --> 00:28:48,110
not tied to the lifetime of the file but

628
00:28:45,350 --> 00:28:51,340
that driver is not really used anymore

629
00:28:48,110 --> 00:28:54,500
so it seems pretty good in that respect

630
00:28:51,340 --> 00:28:58,280
but in conclusion there's a few

631
00:28:54,500 --> 00:29:01,850
takeaways I hope you come from this is

632
00:28:58,280 --> 00:29:05,660
that we can use leads even without

633
00:29:01,850 --> 00:29:08,090
exploit samples to help find bugs and

634
00:29:05,660 --> 00:29:09,740
get security vulnerabilities patched so

635
00:29:08,090 --> 00:29:12,530
I think we all need to always continue

636
00:29:09,740 --> 00:29:14,809
to be creative and how do we use

637
00:29:12,530 --> 00:29:16,550
information even if it's not the

638
00:29:14,809 --> 00:29:18,678
information we really really want like

639
00:29:16,550 --> 00:29:20,840
an exploit sample is always great but

640
00:29:18,679 --> 00:29:23,270
what else can we do next

641
00:29:20,840 --> 00:29:26,629
is and I don't have to tell most of you

642
00:29:23,270 --> 00:29:30,080
all in here but the patch gap y'all if

643
00:29:26,630 --> 00:29:32,420
you are working on downstream from an

644
00:29:30,080 --> 00:29:32,689
upstream Linux kernel or something like

645
00:29:32,420 --> 00:29:35,750
that

646
00:29:32,690 --> 00:29:38,960
that patch gap is leaving a super ripe

647
00:29:35,750 --> 00:29:41,990
area for exploitation you know just last

648
00:29:38,960 --> 00:29:43,550
year or a few months ago there were a

649
00:29:41,990 --> 00:29:45,440
lot of different

650
00:29:43,550 --> 00:29:47,330
pone to own bugs that were on browsers

651
00:29:45,440 --> 00:29:49,640
where those books had actually been

652
00:29:47,330 --> 00:29:51,460
patched upstream in chromium you know

653
00:29:49,640 --> 00:29:54,860
these types of things are continually

654
00:29:51,460 --> 00:29:56,300
affecting user and devices is that we

655
00:29:54,860 --> 00:30:00,169
got to get better at addressing that

656
00:29:56,300 --> 00:30:01,850
patch gap and lastly I'm really ramping

657
00:30:00,170 --> 00:30:03,620
up this year a day in the wild work I

658
00:30:01,850 --> 00:30:04,668
know there's a lot of different people

659
00:30:03,620 --> 00:30:07,320
who've been working on different

660
00:30:04,669 --> 00:30:10,620
sections of this problem

661
00:30:07,320 --> 00:30:12,830
from threat Intel you know from exploit

662
00:30:10,620 --> 00:30:14,909
a load from vulnerability analysis

663
00:30:12,830 --> 00:30:18,090
definitely open to collaboration so

664
00:30:14,910 --> 00:30:20,730
please reach out and lastly this was

665
00:30:18,090 --> 00:30:22,709
super quick dot the talk hopefully you

666
00:30:20,730 --> 00:30:25,170
found it valuable and interesting but if

667
00:30:22,710 --> 00:30:27,360
you want more there's a super detailed

668
00:30:25,170 --> 00:30:29,130
blog post as well as information in this

669
00:30:27,360 --> 00:30:32,010
POC code if you want to look at it in

670
00:30:29,130 --> 00:30:34,520
our issue tracker and with that thank

671
00:30:32,010 --> 00:30:34,520
you so much

672
00:30:34,630 --> 00:30:37,709
[Applause]

