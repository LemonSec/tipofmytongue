1
00:00:00,179 --> 00:00:05,970
hi everyone so before I start I'm just

2
00:00:04,200 --> 00:00:09,870
gonna just quickly put this video

3
00:00:05,970 --> 00:00:12,300
because I think it really shows how we

4
00:00:09,870 --> 00:00:13,678
all been working so hard to present here

5
00:00:12,300 --> 00:00:15,000
at the Pacifica and I really want to

6
00:00:13,679 --> 00:00:18,090
thank you

7
00:00:15,000 --> 00:00:20,880
offensive confer having me again I've

8
00:00:18,090 --> 00:00:23,250
engine three conferences I like it I'll

9
00:00:20,880 --> 00:00:25,680
come back but basically when we build

10
00:00:23,250 --> 00:00:29,429
stuff or when we try to destroy stuff we

11
00:00:25,680 --> 00:00:32,159
have lots of problems and I I like this

12
00:00:29,429 --> 00:00:35,910
video you want try to solve one problem

13
00:00:32,159 --> 00:00:38,629
you have another one and your manager is

14
00:00:35,910 --> 00:00:38,629
behind you

15
00:00:43,100 --> 00:00:48,710
right so so that's that's what we do

16
00:00:47,600 --> 00:00:52,780
right

17
00:00:48,710 --> 00:00:54,980
so I'm Cedric I'm Cedric I'm part of the

18
00:00:52,780 --> 00:00:58,489
exploitive home group at the NCC group

19
00:00:54,980 --> 00:01:00,949
and my goal my job day-to-day job is to

20
00:00:58,489 --> 00:01:04,479
write exploit for existing

21
00:01:00,949 --> 00:01:07,970
vulnerabilities that are patched so our

22
00:01:04,479 --> 00:01:09,560
pentest team can use this exploit and

23
00:01:07,970 --> 00:01:10,070
demonstrate that if you don't patch it's

24
00:01:09,560 --> 00:01:13,580
bad

25
00:01:10,070 --> 00:01:15,229
basically the export we write are just

26
00:01:13,580 --> 00:01:18,170
more than proof of concept in that they

27
00:01:15,229 --> 00:01:20,330
have to write to work as much as

28
00:01:18,170 --> 00:01:23,210
possible and for all the versions that

29
00:01:20,330 --> 00:01:24,830
we can if possible the research I'm

30
00:01:23,210 --> 00:01:27,649
going to be presenting today

31
00:01:24,830 --> 00:01:29,810
has been done with Erin Adams who is not

32
00:01:27,649 --> 00:01:32,450
going to be here but we work in the same

33
00:01:29,810 --> 00:01:34,220
team so the presentation I'm going to do

34
00:01:32,450 --> 00:01:36,740
today is about a Windows kind of

35
00:01:34,220 --> 00:01:38,390
inability in a component called KTM

36
00:01:36,740 --> 00:01:41,600
which stands for current transaction

37
00:01:38,390 --> 00:01:44,929
manager it actually was found by

38
00:01:41,600 --> 00:01:47,419
Kaspersky and Boris and who presented

39
00:01:44,929 --> 00:01:51,320
the the research on blu-ray

40
00:01:47,420 --> 00:01:53,509
earlier today and I I go and they they

41
00:01:51,320 --> 00:01:56,320
found it exploited in the wild and they

42
00:01:53,509 --> 00:01:59,509
published a blog post about how roughly

43
00:01:56,320 --> 00:02:02,508
they found it and at least what were

44
00:01:59,509 --> 00:02:06,650
they some explanation about the bag

45
00:02:02,509 --> 00:02:10,459
it was exploited in the wild at the end

46
00:02:06,650 --> 00:02:14,019
of 2018 and we were interested in this

47
00:02:10,459 --> 00:02:17,630
nobility and we started exploit

48
00:02:14,019 --> 00:02:20,750
researching into this ribbity in 2010 19

49
00:02:17,630 --> 00:02:22,609
early early nineteen months after and we

50
00:02:20,750 --> 00:02:25,220
never got access to the actual exploit

51
00:02:22,610 --> 00:02:28,370
or a lot of detail we only had access to

52
00:02:25,220 --> 00:02:30,320
discuss Persky blog that gave us a few

53
00:02:28,370 --> 00:02:32,900
hints about the bag the first one was it

54
00:02:30,320 --> 00:02:34,549
was that it was a race condition in this

55
00:02:32,900 --> 00:02:36,980
new component that we didn't know at

56
00:02:34,549 --> 00:02:39,590
that time KTM he was exploitable in the

57
00:02:36,980 --> 00:02:43,250
browser sandbox because it's it's it's

58
00:02:39,590 --> 00:02:46,640
allowed to access KTM from the most

59
00:02:43,250 --> 00:02:49,519
personal sandbox contrary to win32 K for

60
00:02:46,640 --> 00:02:51,708
instance it was working on Windows 10

61
00:02:49,519 --> 00:02:54,260
and it there was a few hints to trigger

62
00:02:51,709 --> 00:02:56,329
the the race the presentation I'm going

63
00:02:54,260 --> 00:02:56,940
to do today is very similar to the one

64
00:02:56,329 --> 00:03:01,290
that was

65
00:02:56,940 --> 00:03:05,400
presented a POC at the end of the last

66
00:03:01,290 --> 00:03:06,959
year by Aaron there just if you think

67
00:03:05,400 --> 00:03:08,880
when you start a new research just doing

68
00:03:06,960 --> 00:03:10,890
a little bit research on Google to see

69
00:03:08,880 --> 00:03:12,690
what was in KTM actually wasn't a

70
00:03:10,890 --> 00:03:16,529
component that has been targeted a lot

71
00:03:12,690 --> 00:03:17,609
in the late last twenty ten years only

72
00:03:16,530 --> 00:03:19,620
four CVEs

73
00:03:17,610 --> 00:03:21,300
and most of them are not actually

74
00:03:19,620 --> 00:03:23,990
exploitable bug just in our service or

75
00:03:21,300 --> 00:03:28,260
memory disclosure Berg found by Giroux

76
00:03:23,990 --> 00:03:30,330
and so among this the the 2018 one is

77
00:03:28,260 --> 00:03:35,100
the actual Kaspersky's blog that we took

78
00:03:30,330 --> 00:03:37,050
as a reference CV 2018 and 86 11 and

79
00:03:35,100 --> 00:03:40,140
there was a another article about Katia

80
00:03:37,050 --> 00:03:45,570
KTM which actually was last year about

81
00:03:40,140 --> 00:03:48,239
ways to evade AVS using KTM so this is

82
00:03:45,570 --> 00:03:51,690
basically the thing I've read probably

83
00:03:48,240 --> 00:03:55,320
200 times but I mean really among the

84
00:03:51,690 --> 00:03:58,260
few weeks and months I've been working

85
00:03:55,320 --> 00:03:59,850
on this exploit and basically at first

86
00:03:58,260 --> 00:04:02,010
you read it and you're like oh yeah that

87
00:03:59,850 --> 00:04:03,810
looks really I'm not going to go over it

88
00:04:02,010 --> 00:04:06,209
because I'm gonna go into detail but you

89
00:04:03,810 --> 00:04:08,820
can see there are few links to some

90
00:04:06,209 --> 00:04:11,160
functions that were called transactions

91
00:04:08,820 --> 00:04:13,470
and nisman resource manager objects and

92
00:04:11,160 --> 00:04:16,399
basically this is this is permitted when

93
00:04:13,470 --> 00:04:23,190
I read this blog post I'm like okay so

94
00:04:16,399 --> 00:04:24,659
actually should be easy right so few

95
00:04:23,190 --> 00:04:26,990
tooling if you're interested to see how

96
00:04:24,660 --> 00:04:29,430
what we use so basically when you start

97
00:04:26,990 --> 00:04:34,380
we want to exploit an existing rarity

98
00:04:29,430 --> 00:04:36,870
the best method is to use however method

99
00:04:34,380 --> 00:04:39,630
which is used bindus so in our case we

100
00:04:36,870 --> 00:04:42,540
use de Fora mainly because we want to

101
00:04:39,630 --> 00:04:44,190
have the D compiler and you get this

102
00:04:42,540 --> 00:04:47,700
list of functions the one that you can

103
00:04:44,190 --> 00:04:50,160
see TM recover which was manager 38 blog

104
00:04:47,700 --> 00:04:51,840
changes this is the one we're interested

105
00:04:50,160 --> 00:04:56,280
in and basically it looks like four

106
00:04:51,840 --> 00:04:58,080
different pages like this okay so this

107
00:04:56,280 --> 00:05:00,630
is definitely not an integer overflow

108
00:04:58,080 --> 00:05:05,070
before malach with just a check that is

109
00:05:00,630 --> 00:05:07,919
not checking the length of an allocation

110
00:05:05,070 --> 00:05:09,539
right so and even if you have the de

111
00:05:07,919 --> 00:05:10,710
compiler you still have pointers you

112
00:05:09,539 --> 00:05:12,780
don't know what they're going up

113
00:05:10,710 --> 00:05:15,299
what's going on so now we need to

114
00:05:12,780 --> 00:05:16,919
analyze to understand what is KTM okay

115
00:05:15,300 --> 00:05:18,420
because we can't just say it's an

116
00:05:16,920 --> 00:05:20,850
integer overflow we know it's a race

117
00:05:18,420 --> 00:05:22,530
condition but for now we don't have any

118
00:05:20,850 --> 00:05:25,770
information about the bag so we're gonna

119
00:05:22,530 --> 00:05:29,130
go over KTM see how a little bit of

120
00:05:25,770 --> 00:05:32,900
internals to understand the patch how we

121
00:05:29,130 --> 00:05:35,010
trigger the bag how we basically wrote

122
00:05:32,900 --> 00:05:37,469
managed to get an arbitrary readwrite

123
00:05:35,010 --> 00:05:42,659
primitive and how we really we escalated

124
00:05:37,470 --> 00:05:45,180
privileges so what is KTM so KTM is very

125
00:05:42,660 --> 00:05:48,540
specific to Windows so basically you

126
00:05:45,180 --> 00:05:49,980
look at the MSDN the KTM portal and you

127
00:05:48,540 --> 00:05:52,590
get something like this with with like a

128
00:05:49,980 --> 00:05:54,300
list of enumeration function structures

129
00:05:52,590 --> 00:05:55,739
that you can call from using on or also

130
00:05:54,300 --> 00:05:59,400
from kernel actually there are both

131
00:05:55,740 --> 00:06:03,360
api's I basically KTM II actually was

132
00:05:59,400 --> 00:06:06,299
added in 20 2006 and basically it's a

133
00:06:03,360 --> 00:06:08,040
component to deal with transactions

134
00:06:06,300 --> 00:06:09,690
similarly to what you would think when

135
00:06:08,040 --> 00:06:12,600
you deal with a database with

136
00:06:09,690 --> 00:06:15,719
transactions SQL database where you want

137
00:06:12,600 --> 00:06:19,380
to have different requests and you want

138
00:06:15,720 --> 00:06:22,740
to make sure the transaction operations

139
00:06:19,380 --> 00:06:25,320
you do will if one if something fails

140
00:06:22,740 --> 00:06:27,360
among the different transaction you will

141
00:06:25,320 --> 00:06:28,800
always have a consistent state and it

142
00:06:27,360 --> 00:06:31,080
will never be corrupted and you can

143
00:06:28,800 --> 00:06:32,670
always revert to a previous state that

144
00:06:31,080 --> 00:06:34,950
is saying even if you lose the latest

145
00:06:32,670 --> 00:06:37,380
changes so this is actually in the

146
00:06:34,950 --> 00:06:41,430
Windows kernel so they have this kernel

147
00:06:37,380 --> 00:06:44,670
transaction manager and so it's been in

148
00:06:41,430 --> 00:06:47,000
Windows since Vista and it was in TOS

149
00:06:44,670 --> 00:06:51,150
kernel first and now it's in TN dirtiest

150
00:06:47,000 --> 00:06:53,430
specific it's actually in the kernel but

151
00:06:51,150 --> 00:06:54,750
it's also used by other components in

152
00:06:53,430 --> 00:06:57,000
the kernel called the transaction

153
00:06:54,750 --> 00:06:59,730
registry and the traditional NCI fetch

154
00:06:57,000 --> 00:07:01,500
which as you can imagine used KTM to

155
00:06:59,730 --> 00:07:04,320
implement it for the file system order

156
00:07:01,500 --> 00:07:07,980
registry and it's also available from

157
00:07:04,320 --> 00:07:09,900
user and - so amusing Minnie can print

158
00:07:07,980 --> 00:07:16,550
transaction and it's going to use the

159
00:07:09,900 --> 00:07:20,849
KTM from the camera so after browsing

160
00:07:16,550 --> 00:07:23,250
the MSDN pages also a lot of times and

161
00:07:20,850 --> 00:07:24,689
playing with with it

162
00:07:23,250 --> 00:07:27,269
by writing some

163
00:07:24,689 --> 00:07:29,489
code its to interact with it we

164
00:07:27,269 --> 00:07:31,169
understood that there were four

165
00:07:29,489 --> 00:07:35,578
different objects that were really

166
00:07:31,169 --> 00:07:37,229
important for talking with KTM the all

167
00:07:35,579 --> 00:07:39,239
reference counted and medically you have

168
00:07:37,229 --> 00:07:40,949
the transaction major you have the

169
00:07:39,239 --> 00:07:43,018
resource manager transaction and the

170
00:07:40,949 --> 00:07:45,269
investment the transaction manager is

171
00:07:43,019 --> 00:07:47,849
the one that allows you to manage the

172
00:07:45,269 --> 00:07:51,479
logs that will be that will allow you to

173
00:07:47,849 --> 00:07:52,860
revert to a previous state the richness

174
00:07:51,479 --> 00:07:55,679
manager is the one that managed the

175
00:07:52,860 --> 00:07:58,259
specific resource that you want to deal

176
00:07:55,679 --> 00:08:00,628
with for our transaction then you have

177
00:07:58,259 --> 00:08:04,159
the transaction object which you create

178
00:08:00,629 --> 00:08:06,959
to to say this will be the whole work

179
00:08:04,159 --> 00:08:08,669
the whole actions I want to be part of

180
00:08:06,959 --> 00:08:10,169
the same transaction and then you have

181
00:08:08,669 --> 00:08:13,258
the enlistment which is basically the

182
00:08:10,169 --> 00:08:14,789
link between the resource map the

183
00:08:13,259 --> 00:08:18,899
resource and the transaction that will

184
00:08:14,789 --> 00:08:20,938
end list 2 to a specific task and this

185
00:08:18,899 --> 00:08:22,889
is basically how it works you have four

186
00:08:20,939 --> 00:08:25,019
different functions that will that you

187
00:08:22,889 --> 00:08:26,429
can call from form userland so create

188
00:08:25,019 --> 00:08:28,769
transaction manager create resource

189
00:08:26,429 --> 00:08:30,268
manager then create transaction they

190
00:08:28,769 --> 00:08:33,990
were at the bottom and then create

191
00:08:30,269 --> 00:08:37,860
enlistment to to enlist to a specific

192
00:08:33,990 --> 00:08:40,198
transaction for a particular work so

193
00:08:37,860 --> 00:08:42,300
just I won't detail all the arguments

194
00:08:40,198 --> 00:08:44,128
because it's going to be boring but I

195
00:08:42,299 --> 00:08:45,719
want just to highlight with fewer

196
00:08:44,129 --> 00:08:48,449
arguments that are interesting for the

197
00:08:45,720 --> 00:08:50,819
back from our exploitation point of you

198
00:08:48,449 --> 00:08:52,829
later so for our you won't understand

199
00:08:50,819 --> 00:08:56,279
why I'm talking about this argument but

200
00:08:52,829 --> 00:08:59,339
just for information so when you create

201
00:08:56,279 --> 00:09:02,250
a transaction manager you can pass a log

202
00:08:59,339 --> 00:09:03,930
file name and it's either you pass an

203
00:09:02,250 --> 00:09:07,050
actual file name that will be used on

204
00:09:03,930 --> 00:09:11,008
the file system to save the transaction

205
00:09:07,050 --> 00:09:13,559
on a persistent memory or you passed no

206
00:09:11,009 --> 00:09:15,449
and you get a volatile transaction

207
00:09:13,559 --> 00:09:17,490
manager so we would say why do you want

208
00:09:15,449 --> 00:09:19,019
to have a volatile transaction actually

209
00:09:17,490 --> 00:09:20,910
I don't really know but from an

210
00:09:19,019 --> 00:09:24,089
exploitation point of view there is no

211
00:09:20,910 --> 00:09:26,790
log so it's you can't rollback really

212
00:09:24,089 --> 00:09:29,910
but from expedition point of view it's

213
00:09:26,790 --> 00:09:31,920
interesting because there is a limit on

214
00:09:29,910 --> 00:09:34,410
the actual log and so being able to

215
00:09:31,920 --> 00:09:36,529
create volatile transaction matter is

216
00:09:34,410 --> 00:09:38,579
useful from an explosion point of view

217
00:09:36,529 --> 00:09:42,120
so we create a transaction

218
00:09:38,580 --> 00:09:45,630
I create a KTM object most of the fields

219
00:09:42,120 --> 00:09:48,360
are not relevant for us when you create

220
00:09:45,630 --> 00:09:50,040
a resource manager to handle the

221
00:09:48,360 --> 00:09:52,620
resource you can pass the description

222
00:09:50,040 --> 00:09:56,910
which is basically a name for the

223
00:09:52,620 --> 00:09:59,459
resource manager that will be associated

224
00:09:56,910 --> 00:10:02,480
with this resource manager or you can

225
00:09:59,459 --> 00:10:05,579
pass normal to avoid creating a name and

226
00:10:02,480 --> 00:10:07,860
the resource manager has a few field

227
00:10:05,579 --> 00:10:11,699
that are interesting for us so we can

228
00:10:07,860 --> 00:10:13,260
see the description at the bottom we can

229
00:10:11,700 --> 00:10:15,089
see the transaction manager pointer that

230
00:10:13,260 --> 00:10:18,029
points to the transaction manager object

231
00:10:15,089 --> 00:10:20,220
and then at the top you can see the

232
00:10:18,029 --> 00:10:22,860
state or the flag of the actual resource

233
00:10:20,220 --> 00:10:25,950
manager and there is a mutex which

234
00:10:22,860 --> 00:10:29,459
basically dictates if you can access and

235
00:10:25,950 --> 00:10:31,980
read the description or if you can

236
00:10:29,459 --> 00:10:35,760
browse the annasmith list which is

237
00:10:31,980 --> 00:10:39,329
pointed by the Aniston head which will

238
00:10:35,760 --> 00:10:40,769
see the list of enlistment so you need

239
00:10:39,329 --> 00:10:42,779
to lock this music to be able to browse

240
00:10:40,769 --> 00:10:44,670
this list or access this description and

241
00:10:42,779 --> 00:10:47,360
then you have lots of feel that are

242
00:10:44,670 --> 00:10:49,260
related to notification and it's because

243
00:10:47,360 --> 00:10:51,540
actually there is a queue of

244
00:10:49,260 --> 00:10:55,730
notification that can be triggered when

245
00:10:51,540 --> 00:10:58,050
certain isn't happened and basically

246
00:10:55,730 --> 00:10:59,700
we'll see later that actually this

247
00:10:58,050 --> 00:11:05,189
notification we can read it from user

248
00:10:59,700 --> 00:11:07,529
nan which can be useful so then the

249
00:11:05,190 --> 00:11:09,450
transaction so the transaction doesn't

250
00:11:07,529 --> 00:11:12,360
have really important arguments because

251
00:11:09,450 --> 00:11:13,890
it's just a new park object that tells

252
00:11:12,360 --> 00:11:16,529
you this is part of the same transaction

253
00:11:13,890 --> 00:11:18,569
but it doesn't nothing is associated

254
00:11:16,529 --> 00:11:20,640
with the transaction in itself just a

255
00:11:18,570 --> 00:11:25,110
piece of work to be done and then you

256
00:11:20,640 --> 00:11:27,089
have you have the enlistment which is

257
00:11:25,110 --> 00:11:28,949
basically to enlist to a specific

258
00:11:27,089 --> 00:11:31,680
transaction that's going to associate

259
00:11:28,949 --> 00:11:33,810
the transaction to the actual resource

260
00:11:31,680 --> 00:11:36,540
so the incident is very important for us

261
00:11:33,810 --> 00:11:39,329
because I will see as we will see the

262
00:11:36,540 --> 00:11:41,250
bug actually allows us to a trigger use

263
00:11:39,329 --> 00:11:43,380
after free in the enlistment so knowing

264
00:11:41,250 --> 00:11:46,560
the actual layout of the objects is very

265
00:11:43,380 --> 00:11:48,000
important but basically we can see we

266
00:11:46,560 --> 00:11:51,989
can pass the handle for the resource

267
00:11:48,000 --> 00:11:52,510
manager in the transaction so the layout

268
00:11:51,990 --> 00:11:56,590
of the app

269
00:11:52,510 --> 00:11:59,880
direct is this so it has different

270
00:11:56,590 --> 00:12:02,830
states for this the actual announcement

271
00:11:59,880 --> 00:12:04,810
the notification mask dictates what are

272
00:12:02,830 --> 00:12:06,640
the different notifications that will

273
00:12:04,810 --> 00:12:11,349
trigger an event when the unexplained

274
00:12:06,640 --> 00:12:13,750
changes state and and then you have the

275
00:12:11,350 --> 00:12:16,330
next same R M which is the linked list

276
00:12:13,750 --> 00:12:18,850
of the audience meant associated with

277
00:12:16,330 --> 00:12:21,670
the same resource manager so you can

278
00:12:18,850 --> 00:12:24,460
understand it's a little bit messy but

279
00:12:21,670 --> 00:12:28,089
I'll show you a figure in a second for

280
00:12:24,460 --> 00:12:31,030
the actual flags the actual unless flags

281
00:12:28,090 --> 00:12:33,100
that are interesting so when we were

282
00:12:31,030 --> 00:12:34,420
reversing we this is how we documented

283
00:12:33,100 --> 00:12:37,570
the flags with the two that are

284
00:12:34,420 --> 00:12:39,849
interesting for us our finalized because

285
00:12:37,570 --> 00:12:42,730
the finalization of an enlistment

286
00:12:39,850 --> 00:12:45,030
dictates when the enlistment has

287
00:12:42,730 --> 00:12:48,400
finished doing its work and basically

288
00:12:45,030 --> 00:12:50,020
the anything can be freed and the second

289
00:12:48,400 --> 00:12:53,170
flag that is important for us as well as

290
00:12:50,020 --> 00:12:55,060
the superior flag because in the KTM

291
00:12:53,170 --> 00:12:57,579
world they they have this concept of

292
00:12:55,060 --> 00:12:59,290
actually distributed transaction between

293
00:12:57,580 --> 00:13:01,930
different hosts and you can have a

294
00:12:59,290 --> 00:13:03,579
superior resource manager and super

295
00:13:01,930 --> 00:13:05,739
enlistment that actually is the one that

296
00:13:03,580 --> 00:13:08,170
kind of orchestrating the other thing

297
00:13:05,740 --> 00:13:09,550
but in our case we don't really care so

298
00:13:08,170 --> 00:13:13,900
that's something we can kind of ignore

299
00:13:09,550 --> 00:13:16,959
for now in when we reverse engineer so

300
00:13:13,900 --> 00:13:19,810
how do we free and insolence so any

301
00:13:16,960 --> 00:13:21,640
spend our reference counted by reversing

302
00:13:19,810 --> 00:13:24,790
we find this function TMP finalized

303
00:13:21,640 --> 00:13:28,540
enlistment that we can see it lower the

304
00:13:24,790 --> 00:13:31,060
ref count and we can see that it does it

305
00:13:28,540 --> 00:13:34,270
when it actually moves from a proper

306
00:13:31,060 --> 00:13:36,040
straight to a committed state and so we

307
00:13:34,270 --> 00:13:38,230
can see that from user land we can call

308
00:13:36,040 --> 00:13:41,709
a commit complete to trigger the

309
00:13:38,230 --> 00:13:45,670
finalization of an instance and if there

310
00:13:41,710 --> 00:13:47,830
is no reference on the actual object

311
00:13:45,670 --> 00:13:49,540
which means we need to close the actual

312
00:13:47,830 --> 00:13:52,240
handle we got in the first place from

313
00:13:49,540 --> 00:13:54,160
creating the an expense then the actual

314
00:13:52,240 --> 00:13:56,320
enzmann will be freed and if there are

315
00:13:54,160 --> 00:13:58,959
on other references in the kernel

316
00:13:56,320 --> 00:14:01,600
once these reference are gone the actual

317
00:13:58,960 --> 00:14:04,930
in spinels freed so this is basically a

318
00:14:01,600 --> 00:14:06,019
summary if you don't get the whole thing

319
00:14:04,930 --> 00:14:08,920
before this is summer

320
00:14:06,019 --> 00:14:11,149
to be able to follow the remaining part

321
00:14:08,920 --> 00:14:14,929
so we have the actual transaction

322
00:14:11,149 --> 00:14:16,369
manager which is the first object we

323
00:14:14,929 --> 00:14:19,129
create we have the resource manager

324
00:14:16,369 --> 00:14:20,779
which has an instant head which is a

325
00:14:19,129 --> 00:14:24,170
linked list of different investments

326
00:14:20,779 --> 00:14:26,749
that that are associated to either one

327
00:14:24,170 --> 00:14:28,579
or several transaction but this linked

328
00:14:26,749 --> 00:14:32,569
list of enlistment is actually important

329
00:14:28,579 --> 00:14:34,248
to understand the bagger the transaction

330
00:14:32,569 --> 00:14:37,790
and enlistment can move from different

331
00:14:34,249 --> 00:14:39,470
states and by reversing we found that

332
00:14:37,790 --> 00:14:41,629
they can move from preparing to

333
00:14:39,470 --> 00:14:45,949
committed and the thing there is a

334
00:14:41,629 --> 00:14:47,600
relation between the the change of state

335
00:14:45,949 --> 00:14:50,829
for the inocent and the transaction

336
00:14:47,600 --> 00:14:54,170
basically what happens is if a

337
00:14:50,829 --> 00:14:56,599
transaction has several an easement

338
00:14:54,170 --> 00:14:59,929
associated with it all the enlistment

339
00:14:56,600 --> 00:15:03,559
needs to sync to a specific site so the

340
00:14:59,929 --> 00:15:06,589
actual transaction can move to this same

341
00:15:03,559 --> 00:15:10,069
state and it was actually very important

342
00:15:06,589 --> 00:15:12,679
because there isn't much research on KTM

343
00:15:10,069 --> 00:15:13,998
we actually had to define objects to the

344
00:15:12,679 --> 00:15:20,720
specific state so we could actually

345
00:15:13,999 --> 00:15:24,790
trigger the bag in the first place so

346
00:15:20,720 --> 00:15:24,790
the last thing about a KTM is

347
00:15:25,899 --> 00:15:30,529
notification so there is an API called

348
00:15:28,970 --> 00:15:32,509
get notification resource manager that

349
00:15:30,529 --> 00:15:36,230
you can call from user Minh that allows

350
00:15:32,509 --> 00:15:43,189
you to get notified when specific

351
00:15:36,230 --> 00:15:45,589
investments change state and it and

352
00:15:43,189 --> 00:15:49,868
we'll see why it can be useful basically

353
00:15:45,589 --> 00:15:53,110
it's on the first in first out basis and

354
00:15:49,869 --> 00:15:55,579
you can follow that from userland and

355
00:15:53,110 --> 00:15:59,119
you can even as you say twitch

356
00:15:55,579 --> 00:16:01,089
enlistments had bent efficient by the

357
00:15:59,119 --> 00:16:05,329
structure that is returned from username

358
00:16:01,089 --> 00:16:07,249
from calendar to using the less desk

359
00:16:05,329 --> 00:16:10,579
instead concepts that we need to

360
00:16:07,249 --> 00:16:14,499
understand for KTM is the concept of

361
00:16:10,579 --> 00:16:17,329
recovery so if a transaction fails or

362
00:16:14,499 --> 00:16:19,670
powers down you restart your computer

363
00:16:17,329 --> 00:16:22,760
and now you want to recover to a same

364
00:16:19,670 --> 00:16:25,099
states you can basically call recover

365
00:16:22,760 --> 00:16:27,350
versus manager and it's going to try to

366
00:16:25,100 --> 00:16:28,460
go over all the different enlistment

367
00:16:27,350 --> 00:16:31,780
associated with the different

368
00:16:28,460 --> 00:16:34,970
transactions and try to see if it can

369
00:16:31,780 --> 00:16:36,740
recover to a sense state and the way

370
00:16:34,970 --> 00:16:40,340
does that is that it sends a

371
00:16:36,740 --> 00:16:42,830
notification to different workers to

372
00:16:40,340 --> 00:16:49,820
synchronize them so so they can decide

373
00:16:42,830 --> 00:16:53,330
what to do to fit the transaction okay

374
00:16:49,820 --> 00:16:56,440
so understanding the CV so okay now we

375
00:16:53,330 --> 00:16:58,610
have a better understanding of KTM so we

376
00:16:56,440 --> 00:17:04,280
started doing actually a better

377
00:16:58,610 --> 00:17:07,400
reversing so we had this we actually use

378
00:17:04,280 --> 00:17:10,129
a lot x-rays for this research very

379
00:17:07,400 --> 00:17:13,220
useful and if you actually start

380
00:17:10,130 --> 00:17:15,350
documenting all the different objects

381
00:17:13,220 --> 00:17:18,200
from you understanding KTM clarice was

382
00:17:15,349 --> 00:17:20,359
measure you end up having something that

383
00:17:18,200 --> 00:17:23,000
is a lot more readable so maybe it's

384
00:17:20,359 --> 00:17:25,310
hard to read but basically on the left

385
00:17:23,000 --> 00:17:27,950
you have the renewable version and on

386
00:17:25,310 --> 00:17:30,100
the right the patch one and so on in red

387
00:17:27,950 --> 00:17:32,360
is the code that has been removed and

388
00:17:30,100 --> 00:17:34,429
and basically the code that has been

389
00:17:32,360 --> 00:17:36,860
removed is the fact that it's checking

390
00:17:34,430 --> 00:17:39,200
an announcement flag to check if it's

391
00:17:36,860 --> 00:17:42,139
finalized and if it's finalized it's

392
00:17:39,200 --> 00:17:45,560
gonna set a boolean to one and then it

393
00:17:42,140 --> 00:17:47,960
goes outside of this F if-else loop and

394
00:17:45,560 --> 00:17:50,780
there is another if loop that checks on

395
00:17:47,960 --> 00:17:53,060
this flag and if this flag is set then

396
00:17:50,780 --> 00:17:55,129
it's going to basically start from the

397
00:17:53,060 --> 00:17:57,139
head of the list instead of checking

398
00:17:55,130 --> 00:17:59,540
instead of going into the next point or

399
00:17:57,140 --> 00:18:02,240
the flame pointer which is it just below

400
00:17:59,540 --> 00:18:04,700
so basically what has been done is this

401
00:18:02,240 --> 00:18:06,830
thing has been removed and instead on

402
00:18:04,700 --> 00:18:09,020
the right there is a lot more code which

403
00:18:06,830 --> 00:18:11,570
is confusing but you can forget the the

404
00:18:09,020 --> 00:18:13,790
the order line except the last one the

405
00:18:11,570 --> 00:18:15,290
last one says okay just give me the head

406
00:18:13,790 --> 00:18:17,450
of the list so basically what happens is

407
00:18:15,290 --> 00:18:20,000
they remove the check on the finalize

408
00:18:17,450 --> 00:18:22,130
state and the boolean and they just

409
00:18:20,000 --> 00:18:25,820
assume let's start from the head always

410
00:18:22,130 --> 00:18:27,110
and there is no if-else and so there is

411
00:18:25,820 --> 00:18:28,610
an additional code that actually checks

412
00:18:27,110 --> 00:18:30,560
on the transaction manager but first

413
00:18:28,610 --> 00:18:33,080
it's just like an optimization to exit

414
00:18:30,560 --> 00:18:35,059
the loop as soon as possible

415
00:18:33,080 --> 00:18:39,080
okay so we haven't interesting a little

416
00:18:35,059 --> 00:18:41,119
bit of the loop this is probably the the

417
00:18:39,080 --> 00:18:42,889
hardest part to understand because it's

418
00:18:41,119 --> 00:18:43,488
a lot of code and and probably not that

419
00:18:42,889 --> 00:18:46,248
useful

420
00:18:43,489 --> 00:18:48,249
but just take it as am as I'm talking

421
00:18:46,249 --> 00:18:51,200
more than just reading the whole code

422
00:18:48,249 --> 00:18:53,179
there is a this is the recover Resource

423
00:18:51,200 --> 00:18:55,129
Manager loop that basically is going to

424
00:18:53,179 --> 00:18:56,869
loop on on the list of enlistment that

425
00:18:55,129 --> 00:18:59,330
we saw here there is a list of

426
00:18:56,869 --> 00:19:01,220
enlistment appointed by the animal head

427
00:18:59,330 --> 00:19:03,049
and it's going to go over each and is

428
00:19:01,220 --> 00:19:07,399
meant to see if we can if it can notify

429
00:19:03,049 --> 00:19:09,470
them and the way it does that first it's

430
00:19:07,399 --> 00:19:11,209
gonna check if it's the animal head

431
00:19:09,470 --> 00:19:14,179
meaning it's done with the list it's

432
00:19:11,210 --> 00:19:17,529
it's gonna just exit the loop it's it's

433
00:19:14,179 --> 00:19:19,820
done the the function has done its work

434
00:19:17,529 --> 00:19:21,320
the the second thing it's gonna do is

435
00:19:19,820 --> 00:19:22,999
gonna check if the the enlistment has

436
00:19:21,320 --> 00:19:25,009
been finalized already because it's been

437
00:19:22,999 --> 00:19:26,929
if it's been finalized no need to

438
00:19:25,009 --> 00:19:28,399
actually send a notification so we're

439
00:19:26,929 --> 00:19:32,269
just gonna skip it and continue to the

440
00:19:28,399 --> 00:19:35,268
flink the next thing is it's gonna bomb

441
00:19:32,269 --> 00:19:38,539
the an easement ref count and this is to

442
00:19:35,269 --> 00:19:42,169
the enlistment cannot be freed and we

443
00:19:38,539 --> 00:19:45,109
have a lock on the enlistment then the

444
00:19:42,169 --> 00:19:48,460
thing is the ref can't prevent the the

445
00:19:45,109 --> 00:19:51,678
free later when we send a notification

446
00:19:48,460 --> 00:19:54,649
then there is an if to check if the the

447
00:19:51,679 --> 00:19:57,289
the enlistment is notifiable so the

448
00:19:54,649 --> 00:19:59,869
anything is notifiable means we can send

449
00:19:57,289 --> 00:20:01,429
a notification later and the thing it

450
00:19:59,869 --> 00:20:04,279
does is at the end of this if it's

451
00:20:01,429 --> 00:20:07,639
basically unset notifiable flag saying

452
00:20:04,279 --> 00:20:09,769
what it means is that if if it wasn't

453
00:20:07,639 --> 00:20:11,719
not variable in the first place it will

454
00:20:09,769 --> 00:20:16,970
notify but it will also never notified

455
00:20:11,720 --> 00:20:18,950
again because the flag is unset then it

456
00:20:16,970 --> 00:20:20,690
also set this boolean to actually sign

457
00:20:18,950 --> 00:20:23,480
identification and that will dictate

458
00:20:20,690 --> 00:20:25,070
that it actually calls this TMP set

459
00:20:23,480 --> 00:20:27,619
ratification ratios manager that was a

460
00:20:25,070 --> 00:20:29,029
notification but before it's sent its

461
00:20:27,619 --> 00:20:32,299
notification is going to basically

462
00:20:29,029 --> 00:20:34,580
unlock the resource manager a mutex and

463
00:20:32,299 --> 00:20:37,100
it's a lipid similar to the race

464
00:20:34,580 --> 00:20:38,178
condition we saw earlier this morning in

465
00:20:37,100 --> 00:20:40,759
on the linux kernel

466
00:20:38,179 --> 00:20:43,359
it's basically releasing a mutex before

467
00:20:40,759 --> 00:20:46,159
calling another function and it's bad

468
00:20:43,359 --> 00:20:46,939
what happens is that reading the mutex

469
00:20:46,159 --> 00:20:49,580
allows

470
00:20:46,940 --> 00:20:52,220
identification to actually finalize the

471
00:20:49,580 --> 00:20:55,129
Aniston's and potentially it can lead to

472
00:20:52,220 --> 00:20:58,009
deletion of the of the the object if the

473
00:20:55,129 --> 00:20:59,689
ref count goes to zero so we saw earlier

474
00:20:58,009 --> 00:21:02,509
that the ref counts will not be 0

475
00:20:59,690 --> 00:21:04,580
because we acquired the mutex on the

476
00:21:02,509 --> 00:21:06,889
enzmann to prevent that but what happens

477
00:21:04,580 --> 00:21:08,779
if there is a check or the actual only

478
00:21:06,889 --> 00:21:10,908
spin flag just after sending

479
00:21:08,779 --> 00:21:12,590
identification to say it is easy and

480
00:21:10,909 --> 00:21:14,539
it's been finalized and basically that

481
00:21:12,590 --> 00:21:17,149
they are exactly trying to prevent the

482
00:21:14,539 --> 00:21:19,729
user after free but what happens is that

483
00:21:17,149 --> 00:21:22,488
the code that is just after actually

484
00:21:19,729 --> 00:21:24,289
it's prone to a race condition because

485
00:21:22,489 --> 00:21:27,679
what happens is that it's possible

486
00:21:24,289 --> 00:21:34,070
possibly it's possible to congest the

487
00:21:27,679 --> 00:21:36,710
mutex and make it that the actual free

488
00:21:34,070 --> 00:21:39,710
of the object happens while we are

489
00:21:36,710 --> 00:21:42,409
congested here after the check of the

490
00:21:39,710 --> 00:21:44,599
finalize has been done and so what

491
00:21:42,409 --> 00:21:46,369
happens is that even though we fail to

492
00:21:44,599 --> 00:21:47,809
detect that he was finalised it was

493
00:21:46,369 --> 00:21:49,820
finalized in between and then we

494
00:21:47,809 --> 00:22:01,309
actually are going to access a flink

495
00:21:49,820 --> 00:22:04,309
pointer but afraid objects so so what

496
00:22:01,309 --> 00:22:05,629
happens is that the function is

497
00:22:04,309 --> 00:22:11,869
basically going over all these elements

498
00:22:05,629 --> 00:22:14,330
and is trying to make sure it's it

499
00:22:11,869 --> 00:22:16,728
notified the animals our front not yet

500
00:22:14,330 --> 00:22:18,408
finalized and detect if the unexplained

501
00:22:16,729 --> 00:22:24,139
is finalized and they are failing to do

502
00:22:18,409 --> 00:22:26,809
so so ok so we have a better

503
00:22:24,139 --> 00:22:29,330
understanding of the nobility how do we

504
00:22:26,809 --> 00:22:33,979
trigger this bug so our approach has

505
00:22:29,330 --> 00:22:35,840
been to trigger a face fake fake race

506
00:22:33,979 --> 00:22:37,849
and it was mainly because back in the

507
00:22:35,840 --> 00:22:38,959
day here I'm just describing my

508
00:22:37,849 --> 00:22:40,549
understanding of the bag because I've

509
00:22:38,960 --> 00:22:42,019
done the exploit for it but back in that

510
00:22:40,549 --> 00:22:43,070
I think that were we're looking at this

511
00:22:42,019 --> 00:22:45,739
loop we actually don't have this

512
00:22:43,070 --> 00:22:49,519
understanding I want to make sure we

513
00:22:45,739 --> 00:22:53,239
actually understand the problem and so

514
00:22:49,519 --> 00:22:55,820
what we did basically is we patch the KA

515
00:22:53,239 --> 00:22:58,869
wait for single object to be just a jump

516
00:22:55,820 --> 00:23:00,540
to to loop forever while we are

517
00:22:58,869 --> 00:23:03,689
debugging

518
00:23:00,540 --> 00:23:05,460
and in the meantime we forced the

519
00:23:03,690 --> 00:23:07,860
Aniston to be afraid and we try to

520
00:23:05,460 --> 00:23:13,740
confirm that one we were receiving

521
00:23:07,860 --> 00:23:15,689
resuming the thread by unpacking in

522
00:23:13,740 --> 00:23:19,110
windbg we would actually trigger a user

523
00:23:15,690 --> 00:23:20,970
after frame so how do we actually know

524
00:23:19,110 --> 00:23:23,419
which end is meant to free so even

525
00:23:20,970 --> 00:23:27,300
initially our approach was to basically

526
00:23:23,420 --> 00:23:29,580
free all the enlistment but after some

527
00:23:27,300 --> 00:23:31,080
thought we thought that if we try to win

528
00:23:29,580 --> 00:23:33,480
a race we may want to try several times

529
00:23:31,080 --> 00:23:36,620
so we wanted to basically have a way to

530
00:23:33,480 --> 00:23:39,720
just free the one we we want to target

531
00:23:36,620 --> 00:23:41,909
and so our idea was to actually use the

532
00:23:39,720 --> 00:23:45,270
get notification resource manager to

533
00:23:41,910 --> 00:23:46,800
basically count the notifications that

534
00:23:45,270 --> 00:23:49,590
were received by the different

535
00:23:46,800 --> 00:23:51,030
enlistment and find the actual last

536
00:23:49,590 --> 00:23:53,520
illness known that was touched by the

537
00:23:51,030 --> 00:23:55,710
the loop so we can free the last one and

538
00:23:53,520 --> 00:23:59,010
actually that works works really well we

539
00:23:55,710 --> 00:24:00,420
are able just to know exactly what

540
00:23:59,010 --> 00:24:02,610
enlistment has been touched by the loop

541
00:24:00,420 --> 00:24:04,830
and and and just free this one and

542
00:24:02,610 --> 00:24:06,840
trigger a user for free so we confirmed

543
00:24:04,830 --> 00:24:10,230
with the driver verifier order with the

544
00:24:06,840 --> 00:24:12,179
debugger that the bug was real and if

545
00:24:10,230 --> 00:24:14,220
we're able to win the race effectively

546
00:24:12,180 --> 00:24:16,890
will work so what would happen is the we

547
00:24:14,220 --> 00:24:18,300
would the loop would fail to detect that

548
00:24:16,890 --> 00:24:22,200
the young Eastman has been freed and

549
00:24:18,300 --> 00:24:26,250
finalized and it would just access free

550
00:24:22,200 --> 00:24:27,840
memory so how do we actually win the

551
00:24:26,250 --> 00:24:29,280
race and that's the power that actually

552
00:24:27,840 --> 00:24:31,740
took us some time

553
00:24:29,280 --> 00:24:33,540
and maybe people who run Windows

554
00:24:31,740 --> 00:24:35,580
Explorer windows can exploitation and

555
00:24:33,540 --> 00:24:36,840
race conditions this would have done it

556
00:24:35,580 --> 00:24:38,939
right away

557
00:24:36,840 --> 00:24:40,949
it wasn't our case so it was actually

558
00:24:38,940 --> 00:24:42,840
hinted as well by the Kaspersky blog

559
00:24:40,950 --> 00:24:45,330
even though it was wasn't really obvious

560
00:24:42,840 --> 00:24:47,370
for us for some point for quite some

561
00:24:45,330 --> 00:24:51,929
time but basically it's possible to

562
00:24:47,370 --> 00:24:56,310
suspend the thread in the loop and to

563
00:24:51,930 --> 00:24:58,500
effectively make it stuck at the exact

564
00:24:56,310 --> 00:25:00,060
time we're interested in and the reason

565
00:24:58,500 --> 00:25:02,460
is because when you actually call the

566
00:25:00,060 --> 00:25:06,060
suspend function to actually suspend its

567
00:25:02,460 --> 00:25:08,700
read it will be it will be more likely

568
00:25:06,060 --> 00:25:11,070
that it will be blocked or natural

569
00:25:08,700 --> 00:25:13,590
points like waiting for a lock which is

570
00:25:11,070 --> 00:25:14,200
exactly the problem here is that you can

571
00:25:13,590 --> 00:25:16,600
have a way

572
00:25:14,200 --> 00:25:19,450
for single object just after we win the

573
00:25:16,600 --> 00:25:22,949
race and so the idea is to congest the

574
00:25:19,450 --> 00:25:26,380
ratios manager new text in order to

575
00:25:22,950 --> 00:25:28,360
increase the likelihood of suspending

576
00:25:26,380 --> 00:25:29,680
the shredder this the right place by

577
00:25:28,360 --> 00:25:31,540
calling a function for an sis

578
00:25:29,680 --> 00:25:35,020
confirmation to query the resource

579
00:25:31,540 --> 00:25:37,240
manager information and if we actually

580
00:25:35,020 --> 00:25:40,540
are able to suspend it at the right

581
00:25:37,240 --> 00:25:42,370
place we we actually have all the all

582
00:25:40,540 --> 00:25:44,500
the time we want in the world to

583
00:25:42,370 --> 00:25:46,959
actually win the race because the the

584
00:25:44,500 --> 00:25:49,150
thread is stuck exactly were rot and

585
00:25:46,960 --> 00:25:51,610
it's actually doing the same thing as we

586
00:25:49,150 --> 00:25:53,710
were doing in the debugger and we can

587
00:25:51,610 --> 00:25:55,750
just do what we want and just even go

588
00:25:53,710 --> 00:25:59,530
have a coffee and come back it enter and

589
00:25:55,750 --> 00:26:02,530
we win the race and the cool thing as

590
00:25:59,530 --> 00:26:03,970
well is that if the the when we

591
00:26:02,530 --> 00:26:06,460
suspended the thread it's not at the

592
00:26:03,970 --> 00:26:08,200
right spot what happened is we will not

593
00:26:06,460 --> 00:26:10,630
win the race no use after free will

594
00:26:08,200 --> 00:26:16,360
happen and we basically try again so

595
00:26:10,630 --> 00:26:18,280
it's it's quite nice and reliable so we

596
00:26:16,360 --> 00:26:21,100
can keep trying so just have a few

597
00:26:18,280 --> 00:26:23,139
animations to show you how it works

598
00:26:21,100 --> 00:26:25,840
because there are different threads so

599
00:26:23,140 --> 00:26:27,580
we are in this loop TM recovery sauce

600
00:26:25,840 --> 00:26:31,090
manager is passing all this investment

601
00:26:27,580 --> 00:26:34,000
list and basically on behalf of the

602
00:26:31,090 --> 00:26:35,020
recovery thread and what happens is at

603
00:26:34,000 --> 00:26:37,780
the beginning of the function is going

604
00:26:35,020 --> 00:26:39,700
to lock this mutex it's going to test if

605
00:26:37,780 --> 00:26:41,040
it's if the the current and instant

606
00:26:39,700 --> 00:26:44,410
we're parsing in this list is not

607
00:26:41,040 --> 00:26:47,500
finalized and notifiable and it's going

608
00:26:44,410 --> 00:26:49,060
to start queuing notification so it's

609
00:26:47,500 --> 00:26:50,350
not skewing education and but just

610
00:26:49,060 --> 00:26:56,200
before doing that it's going to relock

611
00:26:50,350 --> 00:26:57,669
the mutex sorry is just after tree

612
00:26:56,200 --> 00:27:01,120
notification it's going to relock the

613
00:26:57,670 --> 00:27:04,000
mutex and what happens in in the

614
00:27:01,120 --> 00:27:07,360
meantime we have a congestion congestion

615
00:27:04,000 --> 00:27:09,130
thread that will keep spamming and t

616
00:27:07,360 --> 00:27:11,409
query information ratios measure to say

617
00:27:09,130 --> 00:27:13,660
give me give me your name give me your

618
00:27:11,410 --> 00:27:16,570
source manager name and it will

619
00:27:13,660 --> 00:27:19,720
effectively keep locking the mutex to

620
00:27:16,570 --> 00:27:22,419
actually read the description and in the

621
00:27:19,720 --> 00:27:23,790
meantime we have a third thread which is

622
00:27:22,420 --> 00:27:27,010
the suspense rate that will basically

623
00:27:23,790 --> 00:27:27,789
start to suspend the recovery sweat

624
00:27:27,010 --> 00:27:30,158
which is

625
00:27:27,789 --> 00:27:32,408
in the loop and the idea is we want to

626
00:27:30,159 --> 00:27:34,119
suspend it at the right place so it's

627
00:27:32,409 --> 00:27:35,200
gonna say okay I want to suspend you

628
00:27:34,119 --> 00:27:38,049
okay

629
00:27:35,200 --> 00:27:40,080
suspend now suspend now and so the trick

630
00:27:38,049 --> 00:27:43,029
there is a trick here that we can use

631
00:27:40,080 --> 00:27:44,408
which I think I've been used by this the

632
00:27:43,029 --> 00:27:47,799
explaining the why because they use this

633
00:27:44,409 --> 00:27:49,960
function as well but basically you can

634
00:27:47,799 --> 00:27:52,029
use NT query straight information and

635
00:27:49,960 --> 00:27:54,100
yeah this function is to query

636
00:27:52,029 --> 00:27:56,619
information about a thread and you can

637
00:27:54,100 --> 00:27:59,199
say I want to know the last fiscal that

638
00:27:56,619 --> 00:28:00,908
has been used by your thread and this

639
00:27:59,200 --> 00:28:03,940
function only works if the thread is

640
00:28:00,909 --> 00:28:05,679
suspended so if it's suspended you will

641
00:28:03,940 --> 00:28:07,419
get a reply but if it's not just banded

642
00:28:05,679 --> 00:28:11,470
you'll get two unsuccessful so you can

643
00:28:07,419 --> 00:28:14,559
detect if it's suspended or not so okay

644
00:28:11,470 --> 00:28:16,840
so the suspense read says okay I try to

645
00:28:14,559 --> 00:28:19,330
suspend you now you're suspended the

646
00:28:16,840 --> 00:28:20,408
option notification cured in the what in

647
00:28:19,330 --> 00:28:23,918
the meantime and now

648
00:28:20,409 --> 00:28:26,529
the Strait is suspended so what happens

649
00:28:23,919 --> 00:28:29,019
is the Australia suspended while parsing

650
00:28:26,529 --> 00:28:30,749
a specific enlistment and so now from

651
00:28:29,019 --> 00:28:33,999
using only we can count the number of

652
00:28:30,749 --> 00:28:36,940
incidents that has been notified by

653
00:28:33,999 --> 00:28:39,279
using the notification function and

654
00:28:36,940 --> 00:28:42,099
determine which enlistment we want to

655
00:28:39,279 --> 00:28:45,340
free from username so we can free this

656
00:28:42,099 --> 00:28:49,479
enlistment and then resume the recover

657
00:28:45,340 --> 00:28:50,769
is read and what happens is if we if the

658
00:28:49,479 --> 00:28:52,690
recovery stroke was suspended all right

659
00:28:50,769 --> 00:28:55,690
at the right place then we win the race

660
00:28:52,690 --> 00:28:59,919
and we we basically get to use after

661
00:28:55,690 --> 00:29:02,529
free and if not then we can try again so

662
00:28:59,919 --> 00:29:05,289
okay so now we have the problem of how

663
00:29:02,529 --> 00:29:07,149
do we replace the object we know

664
00:29:05,289 --> 00:29:09,729
everything is on the known page pool so

665
00:29:07,149 --> 00:29:12,820
Paul is just for the the the term for

666
00:29:09,729 --> 00:29:14,950
the channel heap but basically we know

667
00:29:12,820 --> 00:29:16,899
everything in on on page pool and we

668
00:29:14,950 --> 00:29:18,460
know the size of the incident sown on

669
00:29:16,899 --> 00:29:22,599
page pool thanks read the obvious

670
00:29:18,460 --> 00:29:27,369
approach so at first another thing that

671
00:29:22,599 --> 00:29:29,799
we didn't know even though now we know

672
00:29:27,369 --> 00:29:33,129
it's you it's been used by the actual in

673
00:29:29,799 --> 00:29:35,499
the world exploit is that there was a

674
00:29:33,129 --> 00:29:38,320
technique using non page using

675
00:29:35,499 --> 00:29:40,450
name pipes which actually is known I

676
00:29:38,320 --> 00:29:41,830
think Alex Nina square the one who

677
00:29:40,450 --> 00:29:47,159
talked about it in twin

678
00:29:41,830 --> 00:29:50,939
t14 back in the days it's been recently

679
00:29:47,159 --> 00:29:55,480
used a few in a few blog posts

680
00:29:50,940 --> 00:29:57,130
one from blog first early this year but

681
00:29:55,480 --> 00:30:00,279
basically you can use name pipes

682
00:29:57,130 --> 00:30:02,409
it's very good technique because it's it

683
00:30:00,279 --> 00:30:05,559
gives you a lot of control and the idea

684
00:30:02,409 --> 00:30:09,070
is that a name pipe is like a pipe that

685
00:30:05,559 --> 00:30:11,049
you can send information to from one end

686
00:30:09,070 --> 00:30:12,820
to another and read and write and the

687
00:30:11,049 --> 00:30:14,679
idea is that every time you write

688
00:30:12,820 --> 00:30:17,019
something on a nine pipe it's going to

689
00:30:14,679 --> 00:30:19,240
be allocated on an on-page pool and it

690
00:30:17,019 --> 00:30:19,929
won't be freed until you read it from

691
00:30:19,240 --> 00:30:22,269
the other end

692
00:30:19,929 --> 00:30:25,480
so you just have to allocate a named

693
00:30:22,269 --> 00:30:27,010
pipe and just start sending data on the

694
00:30:25,480 --> 00:30:29,260
name pipe and you can allocate stuff on

695
00:30:27,010 --> 00:30:31,450
the non page pool and what is really

696
00:30:29,260 --> 00:30:33,250
cool is that you control the size

697
00:30:31,450 --> 00:30:37,090
because it depends on how much you write

698
00:30:33,250 --> 00:30:39,070
/ / / right and you control the most of

699
00:30:37,090 --> 00:30:40,480
the data because that's the data you're

700
00:30:39,070 --> 00:30:42,428
supposed to write in a pipe the only

701
00:30:40,480 --> 00:30:45,039
thing there is a data on tree structure

702
00:30:42,429 --> 00:30:47,649
that dictates some information which you

703
00:30:45,039 --> 00:30:52,629
don't control but it's small enough and

704
00:30:47,649 --> 00:30:54,189
for us it didn't cause any problem so so

705
00:30:52,630 --> 00:30:55,029
how does it work if you want to do

706
00:30:54,190 --> 00:30:57,309
something free

707
00:30:55,029 --> 00:31:00,010
you can open two nine pipe and then pipe

708
00:30:57,309 --> 00:31:02,470
a and B a usual technique to avoid

709
00:31:00,010 --> 00:31:05,260
coalescing and and being able to replay

710
00:31:02,470 --> 00:31:09,039
the chunk you free when you do that you

711
00:31:05,260 --> 00:31:14,830
use after free so we get data on both

712
00:31:09,039 --> 00:31:17,799
chunks we free data from pipe B so we

713
00:31:14,830 --> 00:31:22,000
allocate chunks on both pipes we free

714
00:31:17,799 --> 00:31:24,340
data fib by reading the order data from

715
00:31:22,000 --> 00:31:26,230
PI B which create holes and we use these

716
00:31:24,340 --> 00:31:28,120
holes to allocate all the elements that

717
00:31:26,230 --> 00:31:31,000
we were going to be targeting in our

718
00:31:28,120 --> 00:31:35,649
loop and the idea is now our enlistment

719
00:31:31,000 --> 00:31:37,600
are in specific spot and bond bounded by

720
00:31:35,649 --> 00:31:40,090
others that that will never never be

721
00:31:37,600 --> 00:31:42,549
freed and so once we free the enlistment

722
00:31:40,090 --> 00:31:45,549
that we target for the user for free we

723
00:31:42,549 --> 00:31:48,639
can just replace data with the name pipe

724
00:31:45,549 --> 00:31:50,500
technique which I've described - to

725
00:31:48,639 --> 00:31:53,229
replay the via instant with a fake

726
00:31:50,500 --> 00:31:55,510
enlistment so this is just to show the

727
00:31:53,230 --> 00:32:01,260
end the alignment between the

728
00:31:55,510 --> 00:32:05,590
the main pipe and the Aniston's so here

729
00:32:01,260 --> 00:32:09,330
we failed while we succeeded for the

730
00:32:05,590 --> 00:32:13,540
exploit to replace the insolent with a

731
00:32:09,330 --> 00:32:18,280
fake enlistment which contains next same

732
00:32:13,540 --> 00:32:20,980
rmph link pointer which is pointing to

733
00:32:18,280 --> 00:32:24,910
something so the thing I didn't explain

734
00:32:20,980 --> 00:32:27,340
here is delayed free lists so there is a

735
00:32:24,910 --> 00:32:30,150
concept in the Windows kernel which is I

736
00:32:27,340 --> 00:32:34,649
think mostly for optimization which is

737
00:32:30,150 --> 00:32:37,060
that when the the the chunks are freed

738
00:32:34,650 --> 00:32:39,310
they are not actually freed right away

739
00:32:37,060 --> 00:32:45,520
they are put in part into a delightful

740
00:32:39,310 --> 00:32:47,889
it which is a way to make them real when

741
00:32:45,520 --> 00:32:50,230
you want to relocate chunks quickly and

742
00:32:47,890 --> 00:32:53,710
it's been in Windows in Vista but

743
00:32:50,230 --> 00:32:56,620
basically the idea is that when the 32

744
00:32:53,710 --> 00:32:58,000
chunks are in this list and the list is

745
00:32:56,620 --> 00:33:00,270
full then it's going to flush the list

746
00:32:58,000 --> 00:33:04,240
it's going to actually free the list and

747
00:33:00,270 --> 00:33:06,100
and and free the 32 chunks the thing is

748
00:33:04,240 --> 00:33:07,570
for us it doesn't really matter and

749
00:33:06,100 --> 00:33:09,280
actually actually the first explode we

750
00:33:07,570 --> 00:33:12,399
got working didn't take into account

751
00:33:09,280 --> 00:33:14,139
that is the interesting thing behind it

752
00:33:12,400 --> 00:33:16,930
is that because we can trigger the race

753
00:33:14,140 --> 00:33:20,620
several times we run this loop even if

754
00:33:16,930 --> 00:33:23,260
we actually make it suspended on the

755
00:33:20,620 --> 00:33:26,350
right spot and we actually fail to

756
00:33:23,260 --> 00:33:28,750
replace the object bus because of the

757
00:33:26,350 --> 00:33:31,240
delayed free list when it can actually

758
00:33:28,750 --> 00:33:32,920
use it it's going to use it from the one

759
00:33:31,240 --> 00:33:34,930
in the free in the delight footage which

760
00:33:32,920 --> 00:33:37,870
hasn't been reused anyway so it's gonna

761
00:33:34,930 --> 00:33:39,130
use a style pointer which is valid and

762
00:33:37,870 --> 00:33:41,530
it's going to just continue in the

763
00:33:39,130 --> 00:33:43,450
linked list so it's just gonna fail we

764
00:33:41,530 --> 00:33:45,670
won the race we just fail to use after

765
00:33:43,450 --> 00:33:48,640
free but we can try again and it works

766
00:33:45,670 --> 00:33:52,620
so but that's just but obviously the

767
00:33:48,640 --> 00:33:55,510
good method is to actually 332 chunks to

768
00:33:52,620 --> 00:33:59,530
free the list because it's simple method

769
00:33:55,510 --> 00:34:02,790
and just makes it faster so how do we go

770
00:33:59,530 --> 00:34:04,899
from that to actually detect a race win

771
00:34:02,790 --> 00:34:06,639
because we are in New Zealand we don't

772
00:34:04,900 --> 00:34:09,909
know when we win the race

773
00:34:06,640 --> 00:34:13,540
the thing is there is no snap so that's

774
00:34:09,909 --> 00:34:17,379
very useful the thing is what we can do

775
00:34:13,540 --> 00:34:20,379
is we can use the fake the the first

776
00:34:17,379 --> 00:34:22,449
fake chunk that were used that was

777
00:34:20,379 --> 00:34:24,489
replacing the the yelling spoon object

778
00:34:22,449 --> 00:34:29,319
which is in red point to an instrument

779
00:34:24,489 --> 00:34:32,109
in New Zealand which will be touched by

780
00:34:29,320 --> 00:34:34,629
the the loop at the next iteration and

781
00:34:32,109 --> 00:34:36,190
and make it that's when it actually

782
00:34:34,629 --> 00:34:38,379
parts the anisa and it's going to change

783
00:34:36,190 --> 00:34:39,909
something and we can get it in super

784
00:34:38,379 --> 00:34:43,929
mention from user because we can read

785
00:34:39,909 --> 00:34:45,790
this investment so the thing is we we

786
00:34:43,929 --> 00:34:47,830
saw earlier that in the loop the first

787
00:34:45,790 --> 00:34:49,659
thing is it does checks if the Union is

788
00:34:47,830 --> 00:34:52,060
not viable and if it's the case just

789
00:34:49,659 --> 00:34:54,159
unset the flag so we just make sure our

790
00:34:52,060 --> 00:34:56,679
announcement in New Zealand has this

791
00:34:54,159 --> 00:34:58,240
flag set and we it will be unset by the

792
00:34:56,679 --> 00:35:00,040
kernel and we can detect it from New

793
00:34:58,240 --> 00:35:02,500
Zealand so here we detect we warn the

794
00:35:00,040 --> 00:35:04,420
race what what we do next

795
00:35:02,500 --> 00:35:07,090
the problem is that if we make it point

796
00:35:04,420 --> 00:35:09,760
to another instance another another we

797
00:35:07,090 --> 00:35:12,430
can maybe q mm but I mama at some point

798
00:35:09,760 --> 00:35:14,080
is gonna crash if we don't know where to

799
00:35:12,430 --> 00:35:16,720
point the investment so the the

800
00:35:14,080 --> 00:35:18,790
technique we used is basically to point

801
00:35:16,720 --> 00:35:20,350
the NSmen to itself so it's going to

802
00:35:18,790 --> 00:35:22,900
basically be stuck on the same

803
00:35:20,350 --> 00:35:25,150
enlistments which is our fake user and

804
00:35:22,900 --> 00:35:28,180
investment until we actually decide to

805
00:35:25,150 --> 00:35:30,130
do something about it and when we are

806
00:35:28,180 --> 00:35:32,410
ready we can just change this fling

807
00:35:30,130 --> 00:35:34,000
pointer from using and make it point to

808
00:35:32,410 --> 00:35:37,660
another series of unexplained that we

809
00:35:34,000 --> 00:35:39,670
want to do work for so we named this

810
00:35:37,660 --> 00:35:44,920
immiscibility trap investment because

811
00:35:39,670 --> 00:35:46,960
it's trapped into the kernel so okay so

812
00:35:44,920 --> 00:35:50,020
the last the next thing is how do we

813
00:35:46,960 --> 00:35:51,940
actually debug a race win because so

814
00:35:50,020 --> 00:35:55,300
there is a refusing a debugger using

815
00:35:51,940 --> 00:35:57,580
like the different print tests and we

816
00:35:55,300 --> 00:36:01,330
decided to use another method just

817
00:35:57,580 --> 00:36:03,940
because we repetitively debugged it and

818
00:36:01,330 --> 00:36:07,240
we found a technique which basically

819
00:36:03,940 --> 00:36:09,760
consists in using the superior flag I

820
00:36:07,240 --> 00:36:11,560
said earlier the superior is used in the

821
00:36:09,760 --> 00:36:13,480
case where we don't care but it's

822
00:36:11,560 --> 00:36:15,759
actually there is code in this function

823
00:36:13,480 --> 00:36:17,890
that actually dictates different things

824
00:36:15,760 --> 00:36:20,260
if it's superior and so what we can do

825
00:36:17,890 --> 00:36:23,350
we can just set the superior flag it

826
00:36:20,260 --> 00:36:26,050
enlistment and so and set a breakpoint

827
00:36:23,350 --> 00:36:28,630
in the NSmen case in the superior case

828
00:36:26,050 --> 00:36:32,140
and it will only trigger for our fake

829
00:36:28,630 --> 00:36:34,300
enlistment so it doesn't slow down any

830
00:36:32,140 --> 00:36:35,950
race or whatever and it will trigger

831
00:36:34,300 --> 00:36:38,470
once we won the race so it's quite nice

832
00:36:35,950 --> 00:36:39,939
to just try to debug it's something to

833
00:36:38,470 --> 00:36:43,419
keep in mind when you're developing an

834
00:36:39,940 --> 00:36:46,240
exploit and repeatedly trigger the be

835
00:36:43,420 --> 00:36:48,580
exploit so the next problem we had is

836
00:36:46,240 --> 00:36:50,379
how do we actually escape the loop so

837
00:36:48,580 --> 00:36:54,069
the first thing to know is that if we

838
00:36:50,380 --> 00:36:57,250
actually escape the loop we lose any any

839
00:36:54,070 --> 00:36:58,780
primitive because the advantage is we're

840
00:36:57,250 --> 00:37:01,660
on this loop and we'll have some control

841
00:36:58,780 --> 00:37:03,820
but once we exit the loop we we actually

842
00:37:01,660 --> 00:37:05,620
don't have anything so we have to do

843
00:37:03,820 --> 00:37:08,860
everything previous before exiting the

844
00:37:05,620 --> 00:37:10,390
loop but the thing is even though we are

845
00:37:08,860 --> 00:37:12,010
thinking about okay we want to find this

846
00:37:10,390 --> 00:37:14,230
right primitive it's actually good to

847
00:37:12,010 --> 00:37:16,110
think about how to escape because

848
00:37:14,230 --> 00:37:18,340
because we're going to repetitively

849
00:37:16,110 --> 00:37:20,980
execute the exploits it's good to have a

850
00:37:18,340 --> 00:37:22,750
clean thing that exits properly so

851
00:37:20,980 --> 00:37:25,480
you'll have to resume your VM or restart

852
00:37:22,750 --> 00:37:26,680
your em all the time so actually we're

853
00:37:25,480 --> 00:37:28,420
thinking about that in the background

854
00:37:26,680 --> 00:37:32,710
and what we're trying to find a right

855
00:37:28,420 --> 00:37:35,380
primitive we noticed that we were

856
00:37:32,710 --> 00:37:37,600
building some fake enlistment with right

857
00:37:35,380 --> 00:37:39,910
structures inside the enlistment and we

858
00:37:37,600 --> 00:37:42,220
noticed that the enlistment

859
00:37:39,910 --> 00:37:45,279
that was taught by the kernel actually

860
00:37:42,220 --> 00:37:48,160
introduced leaked some some pointers

861
00:37:45,280 --> 00:37:49,900
into our fake investment because the

862
00:37:48,160 --> 00:37:54,940
mutex of the investment which is the

863
00:37:49,900 --> 00:37:57,760
commitment here gets two pointers get

864
00:37:54,940 --> 00:38:00,160
added to a linked list and one points to

865
00:37:57,760 --> 00:38:03,730
a cache read which is the current rate

866
00:38:00,160 --> 00:38:06,160
of running in canal and the other one

867
00:38:03,730 --> 00:38:08,800
points to the key resource manager which

868
00:38:06,160 --> 00:38:11,649
is very cool thanks to KF wait for

869
00:38:08,800 --> 00:38:14,140
single object and this actually

870
00:38:11,650 --> 00:38:15,730
technique could be applied to other bug

871
00:38:14,140 --> 00:38:17,620
I think it's quite generate the fact

872
00:38:15,730 --> 00:38:19,450
that you can create a fake mutex that is

873
00:38:17,620 --> 00:38:21,910
touched by the kernel but what is really

874
00:38:19,450 --> 00:38:24,549
cool about this technique is that this

875
00:38:21,910 --> 00:38:27,520
this leak is that it leaks the key

876
00:38:24,550 --> 00:38:30,220
resource manager address which exists

877
00:38:27,520 --> 00:38:31,930
which is exactly what we need to exhibit

878
00:38:30,220 --> 00:38:33,790
the loop because the test is to test is

879
00:38:31,930 --> 00:38:36,580
the fling pointer

880
00:38:33,790 --> 00:38:38,529
the address of the Aniston head in the

881
00:38:36,580 --> 00:38:41,200
curry sauce manager objects so now we

882
00:38:38,530 --> 00:38:44,170
can just escape the loop by setting the

883
00:38:41,200 --> 00:38:46,270
flame pointer to the head of the

884
00:38:44,170 --> 00:38:47,530
reference manager so this is what it

885
00:38:46,270 --> 00:38:50,590
looks like now

886
00:38:47,530 --> 00:38:51,900
so we have the escape enlistment on the

887
00:38:50,590 --> 00:38:55,120
right that points to the leaked

888
00:38:51,900 --> 00:38:57,160
characters measure and in between we

889
00:38:55,120 --> 00:39:00,640
have we had our first trap enlistment

890
00:38:57,160 --> 00:39:03,930
number two which allowed it allowed us

891
00:39:00,640 --> 00:39:06,670
to detect we won the race and then we

892
00:39:03,930 --> 00:39:08,140
for now we don't have it but we want to

893
00:39:06,670 --> 00:39:11,020
have a what we call limited right

894
00:39:08,140 --> 00:39:12,759
primitive lwp which basically is a

895
00:39:11,020 --> 00:39:14,590
series of an easement that gives us some

896
00:39:12,760 --> 00:39:16,720
kind of right primitive and then we have

897
00:39:14,590 --> 00:39:18,820
another trap banishment that tells us

898
00:39:16,720 --> 00:39:20,529
that this right primitive has been done

899
00:39:18,820 --> 00:39:27,130
and then we can again cue other an

900
00:39:20,530 --> 00:39:28,030
incident and so on okay cool so we can

901
00:39:27,130 --> 00:39:30,610
go into care now

902
00:39:28,030 --> 00:39:32,290
we can make it race we can make it user

903
00:39:30,610 --> 00:39:33,780
to free we can make we can make it

904
00:39:32,290 --> 00:39:37,270
returned to user month

905
00:39:33,780 --> 00:39:38,650
cool but we don't we don't we haven't

906
00:39:37,270 --> 00:39:39,840
done anything in front of don't have any

907
00:39:38,650 --> 00:39:44,290
right prima ta we don't have any

908
00:39:39,840 --> 00:39:47,820
anything so we're digging deep to find a

909
00:39:44,290 --> 00:39:49,690
right primitive and lots of reversing

910
00:39:47,820 --> 00:39:51,670
documenting stuff we don't know we're

911
00:39:49,690 --> 00:39:53,530
going we couldn't think though is that

912
00:39:51,670 --> 00:39:55,210
we're stuck into this function so we

913
00:39:53,530 --> 00:39:57,190
know we we know we have to find

914
00:39:55,210 --> 00:39:59,440
something in the function that are

915
00:39:57,190 --> 00:40:02,040
called inside this loop and the one that

916
00:39:59,440 --> 00:40:07,410
looked the best was ke release mutex

917
00:40:02,040 --> 00:40:10,840
initially because it has a linked list

918
00:40:07,410 --> 00:40:14,080
that could be used for me rights even

919
00:40:10,840 --> 00:40:16,480
though now after windows 7 so since

920
00:40:14,080 --> 00:40:18,310
Windows 8 there is safer linking so we

921
00:40:16,480 --> 00:40:20,440
couldn't use them but it looked

922
00:40:18,310 --> 00:40:22,270
interesting and so we kept looking and

923
00:40:20,440 --> 00:40:25,230
we actually found an arbitrary increment

924
00:40:22,270 --> 00:40:28,120
where here the interlock interlocked add

925
00:40:25,230 --> 00:40:29,920
we control the Shred queue we control

926
00:40:28,120 --> 00:40:32,650
current count so we can make it an

927
00:40:29,920 --> 00:40:34,120
address that point in somewhere and

928
00:40:32,650 --> 00:40:36,250
increment it by 1

929
00:40:34,120 --> 00:40:38,410
I think that it's very complicated

930
00:40:36,250 --> 00:40:41,220
because there are lots of functions that

931
00:40:38,410 --> 00:40:43,779
are being called you need to actually

932
00:40:41,220 --> 00:40:46,029
define lots of constraints to not only

933
00:40:43,780 --> 00:40:47,410
trigger this increment but also then to

934
00:40:46,030 --> 00:40:49,869
avoid crashing in

935
00:40:47,410 --> 00:40:53,109
part of the code to actually make it

936
00:40:49,869 --> 00:40:54,940
trigger about several times so I won't

937
00:40:53,109 --> 00:40:57,250
go into detail about that it's too

938
00:40:54,940 --> 00:41:00,630
complicated to go in in a presentation

939
00:40:57,250 --> 00:41:03,309
but we will post a series of blog post

940
00:41:00,630 --> 00:41:04,960
about that the the cool thing is we can

941
00:41:03,309 --> 00:41:07,029
change multiple increments so we can

942
00:41:04,960 --> 00:41:08,740
incremental address several times and we

943
00:41:07,029 --> 00:41:12,039
can actually build an arbitrary a write

944
00:41:08,740 --> 00:41:13,538
primitive the negative R that to

945
00:41:12,039 --> 00:41:14,920
actually increment it to a known value

946
00:41:13,539 --> 00:41:16,299
we need to know the first value in the

947
00:41:14,920 --> 00:41:18,880
first place because we are incrementing

948
00:41:16,299 --> 00:41:22,329
by one so we need to know the initial

949
00:41:18,880 --> 00:41:26,710
value and there are some risk in this

950
00:41:22,329 --> 00:41:29,289
patch level and basically what we have

951
00:41:26,710 --> 00:41:32,079
now is that we can trigger this series

952
00:41:29,289 --> 00:41:34,539
of increment promotive and make it

953
00:41:32,079 --> 00:41:36,299
finished by a trap instant and we all

954
00:41:34,539 --> 00:41:42,009
know that all the implements have been

955
00:41:36,299 --> 00:41:44,349
executed so this is how looks looks like

956
00:41:42,009 --> 00:41:47,109
in terms of all the structures we need

957
00:41:44,349 --> 00:41:50,019
to define obviously I won't explain it

958
00:41:47,109 --> 00:41:52,328
all but it's lots of constraint and it

959
00:41:50,019 --> 00:41:54,368
depends on the on the OS even though

960
00:41:52,329 --> 00:41:58,569
most of them are are quite the same

961
00:41:54,369 --> 00:42:01,509
which is lucky for us this is basically

962
00:41:58,569 --> 00:42:07,660
when we build all this constraints and

963
00:42:01,509 --> 00:42:09,549
we start our exploits we just make sure

964
00:42:07,660 --> 00:42:11,710
that when we charge it it's not going to

965
00:42:09,549 --> 00:42:16,359
explode because it's I mean when we see

966
00:42:11,710 --> 00:42:18,640
that it's likely to explode ok so now we

967
00:42:16,359 --> 00:42:20,440
have an increment the problem is we

968
00:42:18,640 --> 00:42:21,098
don't have an arbor to read so we cannot

969
00:42:20,440 --> 00:42:24,609
read memory

970
00:42:21,099 --> 00:42:27,039
we can't leak the address we want to

971
00:42:24,609 --> 00:42:31,410
overwrite to get something else so we

972
00:42:27,039 --> 00:42:33,519
want to build an arbitrary primitive so

973
00:42:31,410 --> 00:42:36,549
the thing is we have a good and saying

974
00:42:33,519 --> 00:42:38,140
of KT and not only because we we didn't

975
00:42:36,549 --> 00:42:39,880
have to dig into all the API

976
00:42:38,140 --> 00:42:40,269
documentation because there was known

977
00:42:39,880 --> 00:42:41,829
before

978
00:42:40,269 --> 00:42:43,899
also because we had to reverse-engineer

979
00:42:41,829 --> 00:42:46,839
a lot because we had to find this right

980
00:42:43,900 --> 00:42:48,869
limited so the best choice for us was to

981
00:42:46,839 --> 00:42:52,058
actually use KT I'm too far to build a

982
00:42:48,869 --> 00:42:54,039
reprint here and actually we used K

983
00:42:52,059 --> 00:42:56,349
resource manager description because the

984
00:42:54,039 --> 00:42:57,670
thing is this description can be when

985
00:42:56,349 --> 00:42:59,140
you create a resource manager we can

986
00:42:57,670 --> 00:43:01,000
create a resource matter that has a

987
00:42:59,140 --> 00:43:03,160
description which is no so

988
00:43:01,000 --> 00:43:05,140
the pointer the name holder and the

989
00:43:03,160 --> 00:43:08,009
length of the Unicode string with both

990
00:43:05,140 --> 00:43:10,420
will both be 0 and so we know that the

991
00:43:08,010 --> 00:43:13,990
initial value and that is exactly what

992
00:43:10,420 --> 00:43:15,370
we need for right for using our

993
00:43:13,990 --> 00:43:17,379
increment we need to know the initial

994
00:43:15,370 --> 00:43:18,970
value so we know that 0 and we know we

995
00:43:17,380 --> 00:43:20,830
the address of the resource manager

996
00:43:18,970 --> 00:43:22,990
because it was leaked in nationally so

997
00:43:20,830 --> 00:43:25,029
we can actually overwrite the length and

998
00:43:22,990 --> 00:43:28,000
the name to build an arbitrary read

999
00:43:25,030 --> 00:43:29,710
primitive and so the idea is we can use

1000
00:43:28,000 --> 00:43:32,200
the Sisko to read the description from

1001
00:43:29,710 --> 00:43:34,390
New Zealand and after overwriting the

1002
00:43:32,200 --> 00:43:36,640
the pointer and the length and we and we

1003
00:43:34,390 --> 00:43:38,410
can repeat that because we knew the

1004
00:43:36,640 --> 00:43:40,270
previous version we overrode in the

1005
00:43:38,410 --> 00:43:43,390
first place so we can just rinse and

1006
00:43:40,270 --> 00:43:47,770
repeat so this gives us an arbitrary

1007
00:43:43,390 --> 00:43:51,430
primitive so this is the updated diagram

1008
00:43:47,770 --> 00:43:54,880
the idea is that we initially had the

1009
00:43:51,430 --> 00:43:56,680
user after free we have the track the

1010
00:43:54,880 --> 00:44:00,310
initial trap element that allowed us to

1011
00:43:56,680 --> 00:44:02,169
leak the the address of the resource

1012
00:44:00,310 --> 00:44:03,430
manager from the address of the resource

1013
00:44:02,170 --> 00:44:05,830
manager we know the address of the

1014
00:44:03,430 --> 00:44:08,290
description we know that both values are

1015
00:44:05,830 --> 00:44:12,040
0 so we use the increment to increment

1016
00:44:08,290 --> 00:44:14,190
the description field to the address we

1017
00:44:12,040 --> 00:44:17,920
wanna lake and then we leak the address

1018
00:44:14,190 --> 00:44:20,290
with the Cisco I said before and we can

1019
00:44:17,920 --> 00:44:23,680
leak any any value so now we we've done

1020
00:44:20,290 --> 00:44:25,690
the leak it finished with the trap and

1021
00:44:23,680 --> 00:44:27,190
we can restore the previous value from

1022
00:44:25,690 --> 00:44:29,020
the description once we're done with the

1023
00:44:27,190 --> 00:44:34,360
leak so now we have our birth arbitrary

1024
00:44:29,020 --> 00:44:40,410
leak primitive working ok so some people

1025
00:44:34,360 --> 00:44:44,320
would say that's cool incrementing a

1026
00:44:40,410 --> 00:44:46,810
64-bit number 2 to the power 64 that's

1027
00:44:44,320 --> 00:44:48,670
gonna take a while yes and we had these

1028
00:44:46,810 --> 00:44:51,130
questions at POC so we added this

1029
00:44:48,670 --> 00:44:56,740
information basically how is it possible

1030
00:44:51,130 --> 00:45:01,120
in practice to increase a value to the

1031
00:44:56,740 --> 00:45:04,120
value you want in two to two thousand

1032
00:45:01,120 --> 00:45:08,890
rights the idea is just as an example

1033
00:45:04,120 --> 00:45:12,400
you have a address 1000 X you have 8

1034
00:45:08,890 --> 00:45:15,328
bytes it is your 64-bit value you want

1035
00:45:12,400 --> 00:45:17,859
to overwrite its initially 0 you

1036
00:45:15,329 --> 00:45:19,810
you want to make it one two three four

1037
00:45:17,859 --> 00:45:22,960
hex but you don't want to do one two

1038
00:45:19,810 --> 00:45:25,900
three four hex increments so what do you

1039
00:45:22,960 --> 00:45:29,650
do is you just increment it thirty four

1040
00:45:25,900 --> 00:45:32,800
times at addresses 1,000 and then you

1041
00:45:29,650 --> 00:45:34,599
increment it 12 times at address 1001

1042
00:45:32,800 --> 00:45:37,450
and then you've just reduced the amount

1043
00:45:34,599 --> 00:45:39,339
of time and you can so do and do and so

1044
00:45:37,450 --> 00:45:42,640
on the only problem is that once you

1045
00:45:39,339 --> 00:45:45,700
arrive to the latest byte if you want to

1046
00:45:42,640 --> 00:45:48,339
increment for instance 42 3f which is

1047
00:45:45,700 --> 00:45:49,868
lower the most significant byte the

1048
00:45:48,339 --> 00:45:51,609
problem is while you're incrementing it

1049
00:45:49,869 --> 00:45:54,430
so if you're incrementing if you

1050
00:45:51,609 --> 00:45:56,348
increment it c1 time it's gonna reach FF

1051
00:45:54,430 --> 00:45:59,200
and then if you want to eat one more -

1052
00:45:56,349 --> 00:46:03,040
or this the amount that is needed to

1053
00:45:59,200 --> 00:46:05,439
reach 3f when you actually increment it

1054
00:46:03,040 --> 00:46:07,569
from FF to 0 it's really it's gonna

1055
00:46:05,440 --> 00:46:09,040
actually have a Curie that is on the

1056
00:46:07,569 --> 00:46:10,300
next byte and you correctly adjust in

1057
00:46:09,040 --> 00:46:14,970
memory so that's bad

1058
00:46:10,300 --> 00:46:17,680
the trick to do to avoid that is that

1059
00:46:14,970 --> 00:46:20,109
what you can do is you can reset the the

1060
00:46:17,680 --> 00:46:24,250
previous value the whole 64 bits to 0

1061
00:46:20,109 --> 00:46:25,869
and the way to do that is you set every

1062
00:46:24,250 --> 00:46:27,910
byte to FF so you start with the first

1063
00:46:25,869 --> 00:46:31,569
byte with the first technique with the

1064
00:46:27,910 --> 00:46:36,520
misalign equipment you do it FF FF FF

1065
00:46:31,569 --> 00:46:38,410
and once you reach the FF full FF what

1066
00:46:36,520 --> 00:46:41,319
you do is you do an align increment on

1067
00:46:38,410 --> 00:46:44,140
the 64-bit value and basically it's it's

1068
00:46:41,319 --> 00:46:45,700
gonna overflow but it's not going to

1069
00:46:44,140 --> 00:46:48,029
overflow memory it's just gonna overflow

1070
00:46:45,700 --> 00:46:53,230
the 64-bit value but it doesn't matter

1071
00:46:48,030 --> 00:46:57,790
and you don't have any side effect so

1072
00:46:53,230 --> 00:46:59,950
effectively you have one run to set

1073
00:46:57,790 --> 00:47:02,079
everything to 0 and one run to set

1074
00:46:59,950 --> 00:47:06,098
anything to the value you want worst

1075
00:47:02,079 --> 00:47:10,810
case so we start two times 256 times

1076
00:47:06,099 --> 00:47:12,460
eight which is 2,000 okay so we have an

1077
00:47:10,810 --> 00:47:14,770
arbitrary read we have an arbitrary

1078
00:47:12,460 --> 00:47:18,550
right so how do we get free vasc this is

1079
00:47:14,770 --> 00:47:21,069
standard technique but basically we we

1080
00:47:18,550 --> 00:47:24,190
used the increment to increment to

1081
00:47:21,069 --> 00:47:28,089
increment to replace the sister our

1082
00:47:24,190 --> 00:47:29,140
process token with the system token so

1083
00:47:28,089 --> 00:47:32,589
we basically use

1084
00:47:29,140 --> 00:47:35,589
the increments to build a knobby theory

1085
00:47:32,589 --> 00:47:37,200
primitive we leak the system token and

1086
00:47:35,589 --> 00:47:40,599
then we use the right primitive to

1087
00:47:37,200 --> 00:47:42,819
override the Ori process the only thing

1088
00:47:40,599 --> 00:47:46,960
is that because we are actually over in

1089
00:47:42,819 --> 00:47:50,500
overwriting a pointer the increment can

1090
00:47:46,960 --> 00:47:52,690
actually make it make the pointer

1091
00:47:50,500 --> 00:47:55,510
invalid so potentially if someone

1092
00:47:52,690 --> 00:47:57,789
something reads the pointer while we're

1093
00:47:55,510 --> 00:47:59,710
incrementing it it can be a sorry so

1094
00:47:57,789 --> 00:48:01,690
there is a risk of BSOD fine for

1095
00:47:59,710 --> 00:48:04,210
instance if task manager of our expose

1096
00:48:01,690 --> 00:48:05,920
process Explorer is actually accessing

1097
00:48:04,210 --> 00:48:09,339
the link list of a process while we're

1098
00:48:05,920 --> 00:48:14,410
incrementing this this thing and it may

1099
00:48:09,339 --> 00:48:18,339
happen so yeah so our technique is data

1100
00:48:14,410 --> 00:48:20,078
only we didn't investigate bypassing CFG

1101
00:48:18,339 --> 00:48:22,619
even though we think it's the bag is

1102
00:48:20,079 --> 00:48:28,420
quite powerful and it should be possible

1103
00:48:22,619 --> 00:48:31,569
we ported it from vista to 10 both on

1104
00:48:28,420 --> 00:48:35,079
32-bit and 64-bit and that was quite

1105
00:48:31,569 --> 00:48:38,890
straightforward the last thing I want to

1106
00:48:35,079 --> 00:48:40,960
present is some bonus work on some work

1107
00:48:38,890 --> 00:48:44,230
we've we found after we made our

1108
00:48:40,960 --> 00:48:48,279
presentation basically what happened is

1109
00:48:44,230 --> 00:48:50,109
that it turns out Boris anton from

1110
00:48:48,279 --> 00:48:55,240
Kaspersky even though they published

1111
00:48:50,109 --> 00:48:57,369
this amazing blog post they they

1112
00:48:55,240 --> 00:48:59,229
actually published a series of slide

1113
00:48:57,369 --> 00:49:02,650
explaining more that we hadn't seen

1114
00:48:59,230 --> 00:49:05,500
before but basically what happens it

1115
00:49:02,650 --> 00:49:07,779
actually describes some methodology of

1116
00:49:05,500 --> 00:49:12,819
what they've used and we actually didn't

1117
00:49:07,779 --> 00:49:14,410
find it and at that time we were like ok

1118
00:49:12,819 --> 00:49:16,480
we don't find it we find it we found it

1119
00:49:14,410 --> 00:49:19,450
by accident by looking for win32 k

1120
00:49:16,480 --> 00:49:22,359
filtering search but we couldn't find it

1121
00:49:19,450 --> 00:49:28,419
by searching for the CV or KTM and so at

1122
00:49:22,359 --> 00:49:30,880
that time were like ok actually at the

1123
00:49:28,420 --> 00:49:33,880
end it ended up being a happy story at

1124
00:49:30,880 --> 00:49:36,940
least for us because the approach they

1125
00:49:33,880 --> 00:49:39,400
took was different from ours and this is

1126
00:49:36,940 --> 00:49:41,650
what I want to talk about here there are

1127
00:49:39,400 --> 00:49:43,099
three things that I can that I want to

1128
00:49:41,650 --> 00:49:44,930
explain that are different and

1129
00:49:43,099 --> 00:49:48,859
they actually makes it very interesting

1130
00:49:44,930 --> 00:49:51,618
for us is that the first thing for

1131
00:49:48,859 --> 00:49:53,660
detecting if they if they won the race

1132
00:49:51,619 --> 00:49:56,380
it doesn't seem like they actually use

1133
00:49:53,660 --> 00:49:59,598
this the same system as try punishment

1134
00:49:56,380 --> 00:50:01,910
making the the loop stuck temporarily

1135
00:49:59,599 --> 00:50:06,259
which was quite nice they use some kind

1136
00:50:01,910 --> 00:50:07,609
of mutex and even notification object in

1137
00:50:06,259 --> 00:50:11,180
the kernel that makes it trapped

1138
00:50:07,609 --> 00:50:13,279
temporarily inside some ke white phone

1139
00:50:11,180 --> 00:50:16,308
signal object and they are able then to

1140
00:50:13,279 --> 00:50:20,559
modify it from user and to restore it

1141
00:50:16,309 --> 00:50:23,329
and also to to to do a right primitive

1142
00:50:20,559 --> 00:50:24,739
and so it's interesting because it's a

1143
00:50:23,329 --> 00:50:27,469
different approach now the other thing

1144
00:50:24,739 --> 00:50:29,660
is it's actually more complicated than

1145
00:50:27,469 --> 00:50:31,880
our our method because our method is

1146
00:50:29,660 --> 00:50:34,058
just setting a flag and checking if the

1147
00:50:31,880 --> 00:50:39,699
flag isn't set which was quite a nice

1148
00:50:34,059 --> 00:50:42,499
and so there their method actually also

1149
00:50:39,699 --> 00:50:44,390
dictated what they use afterward which

1150
00:50:42,499 --> 00:50:46,819
is that they actually don't use an

1151
00:50:44,390 --> 00:50:48,618
increment either they actually use the

1152
00:50:46,819 --> 00:50:49,880
right zero primitive so as well well

1153
00:50:48,619 --> 00:50:52,969
that's cool

1154
00:50:49,880 --> 00:50:55,130
didn't we use the increment and so they

1155
00:50:52,969 --> 00:50:56,809
use the right zero in the same kind of

1156
00:50:55,130 --> 00:50:58,130
path that we actually found the

1157
00:50:56,809 --> 00:51:01,459
increment in which is quite interesting

1158
00:50:58,130 --> 00:51:05,930
and so they have the capability to write

1159
00:51:01,459 --> 00:51:07,399
zero to any address and the only thing

1160
00:51:05,930 --> 00:51:09,979
is there is a constraint that the least

1161
00:51:07,400 --> 00:51:13,239
significant bit must already be zero to

1162
00:51:09,979 --> 00:51:17,269
avoid deadlock but the it works and

1163
00:51:13,239 --> 00:51:20,749
actually the the in order to reach the

1164
00:51:17,269 --> 00:51:22,788
right zero primitive and and and avoid

1165
00:51:20,749 --> 00:51:24,169
crashing and everything it's a lot

1166
00:51:22,789 --> 00:51:25,999
simpler they don't have to go that

1167
00:51:24,170 --> 00:51:27,680
deeper instead of our increment so

1168
00:51:25,999 --> 00:51:30,680
that's nice it's it's fat it's better

1169
00:51:27,680 --> 00:51:32,930
it's easier to to exploit the only thing

1170
00:51:30,680 --> 00:51:39,229
we realized after by analyzing there are

1171
00:51:32,930 --> 00:51:42,319
this powerful technique that it no okay

1172
00:51:39,229 --> 00:51:45,049
the only thing is it doesn't work on

1173
00:51:42,319 --> 00:51:46,729
some case like this 64 because of some

1174
00:51:45,049 --> 00:51:52,670
different difference in the code and

1175
00:51:46,729 --> 00:51:54,379
also on this 10-7 x86 x86 because of

1176
00:51:52,670 --> 00:51:56,600
some different macro that is used in the

1177
00:51:54,380 --> 00:51:59,840
Windows kernel that makes the

1178
00:51:56,600 --> 00:52:01,430
the primitive not working because the

1179
00:51:59,840 --> 00:52:03,320
well the whole value needs to be zero in

1180
00:52:01,430 --> 00:52:08,450
the first place to actually write zero

1181
00:52:03,320 --> 00:52:10,040
so it doesn't it doesn't work and the

1182
00:52:08,450 --> 00:52:12,919
other thing we initially thought it was

1183
00:52:10,040 --> 00:52:16,220
actually writing zero shouldn't be that

1184
00:52:12,920 --> 00:52:17,840
powerful because actually being able to

1185
00:52:16,220 --> 00:52:19,189
increment looks better right because we

1186
00:52:17,840 --> 00:52:21,710
can increment to any value where else

1187
00:52:19,190 --> 00:52:24,290
write zero is just one value right but

1188
00:52:21,710 --> 00:52:25,760
actually combining the write zero to

1189
00:52:24,290 --> 00:52:27,800
another trick which is using the

1190
00:52:25,760 --> 00:52:29,660
previous mode this the write zero

1191
00:52:27,800 --> 00:52:31,160
becomes a lot more powerful and this

1192
00:52:29,660 --> 00:52:33,500
technique was first documented by a

1193
00:52:31,160 --> 00:52:37,069
tournament in 2011 as far as I can tell

1194
00:52:33,500 --> 00:52:40,940
the idea is that you can overwrite the

1195
00:52:37,070 --> 00:52:45,530
case read previous mode field and

1196
00:52:40,940 --> 00:52:47,960
previous mode dictates if a cisco if

1197
00:52:45,530 --> 00:52:51,080
when a thread is running from in the

1198
00:52:47,960 --> 00:52:52,610
kernel if the thread has been a call

1199
00:52:51,080 --> 00:52:54,710
from new zealand or if it's a kernel

1200
00:52:52,610 --> 00:52:57,860
thread and basically what what it means

1201
00:52:54,710 --> 00:53:00,260
is that in the kernel some checks will

1202
00:52:57,860 --> 00:53:04,430
be skipped if the shreddies camel and it

1203
00:53:00,260 --> 00:53:06,440
doesn't come from using them so and so

1204
00:53:04,430 --> 00:53:08,839
if you are able to set your previous

1205
00:53:06,440 --> 00:53:12,110
mode to zero which actually dictates if

1206
00:53:08,840 --> 00:53:14,240
the color one is the the user 0 is the

1207
00:53:12,110 --> 00:53:16,820
kernel or 0 is the kind of anything else

1208
00:53:14,240 --> 00:53:18,620
it the user so if you can overwrite

1209
00:53:16,820 --> 00:53:21,650
previous mode with zero we can basically

1210
00:53:18,620 --> 00:53:24,290
say oh now we are thread is a scanner

1211
00:53:21,650 --> 00:53:26,720
and we can just call auntie read virtual

1212
00:53:24,290 --> 00:53:29,420
memory auntie write virtual memory from

1213
00:53:26,720 --> 00:53:32,149
New Zealand which are sis calls to read

1214
00:53:29,420 --> 00:53:33,410
or write memory but because it thinks

1215
00:53:32,150 --> 00:53:35,180
we're a canal we can read and write

1216
00:53:33,410 --> 00:53:38,830
memory from the calendar so it's really

1217
00:53:35,180 --> 00:53:41,299
cool technique the so it looks really

1218
00:53:38,830 --> 00:53:43,970
super powerful the only thing is when

1219
00:53:41,300 --> 00:53:45,620
we're trying to port this technique to

1220
00:53:43,970 --> 00:53:49,459
see the advantages we realize that

1221
00:53:45,620 --> 00:53:50,960
actually it only works on on 64-bit just

1222
00:53:49,460 --> 00:53:54,080
because the previous mode the way it's

1223
00:53:50,960 --> 00:53:56,240
implemented in 632 bit is different and

1224
00:53:54,080 --> 00:53:58,730
they they basically don't rely on it

1225
00:53:56,240 --> 00:54:02,359
really they just really every time Cisco

1226
00:53:58,730 --> 00:54:05,840
is is made they override the previous

1227
00:54:02,360 --> 00:54:08,000
mode in the camera using the CS register

1228
00:54:05,840 --> 00:54:10,570
so we can't actually override it and

1229
00:54:08,000 --> 00:54:13,310
make it used by the kernel

1230
00:54:10,570 --> 00:54:15,850
it's possibly the first in the wild use

1231
00:54:13,310 --> 00:54:19,460
of the previous mode if I'm not mistaken

1232
00:54:15,850 --> 00:54:26,529
so that was cool to see it so I have a

1233
00:54:19,460 --> 00:54:37,869
quick demo so as I said the increment

1234
00:54:26,530 --> 00:54:41,510
technique can crash if this shred if the

1235
00:54:37,869 --> 00:54:45,020
if the task manager decides to read

1236
00:54:41,510 --> 00:54:46,190
sorry yeah read the pointer we're

1237
00:54:45,020 --> 00:54:48,770
incrementing while we're incrementing

1238
00:54:46,190 --> 00:54:51,260
but for now we just triggering big

1239
00:54:48,770 --> 00:54:53,960
exploits so we're going to trigger the

1240
00:54:51,260 --> 00:54:55,850
recovery of the resource manager and

1241
00:54:53,960 --> 00:54:57,440
we're gonna make the straight in the

1242
00:54:55,850 --> 00:54:59,200
loop and then we're going to try to win

1243
00:54:57,440 --> 00:55:02,510
the race by suspending the thread

1244
00:54:59,200 --> 00:55:04,339
multiple times trying to detect it from

1245
00:55:02,510 --> 00:55:08,119
user on now we detected from using that

1246
00:55:04,340 --> 00:55:10,100
we won the race so now it's stuck into

1247
00:55:08,119 --> 00:55:13,310
this try punishment and I will basically

1248
00:55:10,100 --> 00:55:17,029
overwrite structures in the resource

1249
00:55:13,310 --> 00:55:18,619
manager to to build a reprime ative and

1250
00:55:17,030 --> 00:55:20,570
each time we want to increment an

1251
00:55:18,619 --> 00:55:22,580
address we are basically going to have

1252
00:55:20,570 --> 00:55:24,530
to read the address in the first place

1253
00:55:22,580 --> 00:55:26,210
but but to read the address we have to

1254
00:55:24,530 --> 00:55:28,100
increment it in the first place so that

1255
00:55:26,210 --> 00:55:34,310
so it takes a little bit of time

1256
00:55:28,100 --> 00:55:36,490
actually so here we're reading the

1257
00:55:34,310 --> 00:55:43,430
different addresses on on the processes

1258
00:55:36,490 --> 00:55:46,450
to find the system system process so we

1259
00:55:43,430 --> 00:55:46,450
found the system process

1260
00:55:58,040 --> 00:56:10,400
on your system so the last thing I want

1261
00:56:08,960 --> 00:56:12,460
to show is as well we actually

1262
00:56:10,400 --> 00:56:14,990
implemented the previous mod primitive

1263
00:56:12,460 --> 00:56:18,740
which both which works as well on with

1264
00:56:14,990 --> 00:56:21,649
the Sten 64-bit so now our exploit

1265
00:56:18,740 --> 00:56:26,359
actually use this method for 64 bits 10

1266
00:56:21,650 --> 00:56:27,920
because it's never going to crash so the

1267
00:56:26,360 --> 00:56:30,200
race is the same but it's just once we

1268
00:56:27,920 --> 00:56:32,240
won the race the parsing or all the

1269
00:56:30,200 --> 00:56:34,580
structures which can just read and write

1270
00:56:32,240 --> 00:56:43,120
arbitrary memory so just right away so

1271
00:56:34,580 --> 00:56:43,120
it's a lot faster as you can see

1272
00:56:47,490 --> 00:56:54,879
so so what we can get from that it was

1273
00:56:51,369 --> 00:56:57,009
very very reliable exploitable race

1274
00:56:54,880 --> 00:56:58,779
condition the increment make it a little

1275
00:56:57,009 --> 00:57:00,069
bit less reliable because of the fact

1276
00:56:58,779 --> 00:57:05,440
that we'll write a pointer but if you

1277
00:57:00,069 --> 00:57:07,569
actually use a CFG bypass arm actually

1278
00:57:05,440 --> 00:57:10,089
to get cut exact in the kernel we may

1279
00:57:07,569 --> 00:57:11,740
not have this problem was very

1280
00:57:10,089 --> 00:57:14,019
interesting for us from a research point

1281
00:57:11,740 --> 00:57:16,899
of view to actually see after the fact

1282
00:57:14,019 --> 00:57:17,470
that that the approach they took was

1283
00:57:16,900 --> 00:57:20,829
different

1284
00:57:17,470 --> 00:57:24,250
I was valuable we will publish more

1285
00:57:20,829 --> 00:57:28,259
details about the in like a five blog

1286
00:57:24,250 --> 00:57:30,579
post series so if you're interested and

1287
00:57:28,259 --> 00:57:32,940
yeah that's all for me if you have any

1288
00:57:30,579 --> 00:57:32,940
question

1289
00:57:38,060 --> 00:57:49,430
like over it REI thanks a lot for your

1290
00:57:43,760 --> 00:57:53,060
talk when you spoke about hip sprain you

1291
00:57:49,430 --> 00:57:57,529
showed that you create two pair of pipes

1292
00:57:53,060 --> 00:58:02,990
right and as I didn't understand why did

1293
00:57:57,530 --> 00:58:06,770
you receive this messages on one pipe to

1294
00:58:02,990 --> 00:58:09,200
create holes written the technique is a

1295
00:58:06,770 --> 00:58:11,600
little bit funky but the idea is that

1296
00:58:09,200 --> 00:58:13,580
the allocation is not about creating a

1297
00:58:11,600 --> 00:58:16,940
pipe but it's about when you actually

1298
00:58:13,580 --> 00:58:21,860
write data on the pipe so the idea is we

1299
00:58:16,940 --> 00:58:24,170
create pipe a and B and we once we have

1300
00:58:21,860 --> 00:58:25,700
created both pipe we send data on one

1301
00:58:24,170 --> 00:58:28,820
pipe and the other one pipe and the

1302
00:58:25,700 --> 00:58:32,089
other and so the strategy we thank Chui

1303
00:58:28,820 --> 00:58:33,470
is to make a lie layout that creates

1304
00:58:32,090 --> 00:58:36,230
hole so what you don't necessarily why

1305
00:58:33,470 --> 00:58:38,509
we create hole so we grate hole because

1306
00:58:36,230 --> 00:58:40,910
we want the enlistment to be stuck

1307
00:58:38,510 --> 00:58:43,760
between other allocation that's the

1308
00:58:40,910 --> 00:58:47,509
thing Sri technique if you look online I

1309
00:58:43,760 --> 00:58:49,940
thought it is for Buffalo flow on the

1310
00:58:47,510 --> 00:58:52,010
heap right no so here the idea is not to

1311
00:58:49,940 --> 00:58:53,930
overflow adjacent shanks it works as

1312
00:58:52,010 --> 00:58:55,490
well for overflowing addition checks you

1313
00:58:53,930 --> 00:58:58,970
can use similar techniques but here

1314
00:58:55,490 --> 00:59:02,569
really the technique is that later if we

1315
00:58:58,970 --> 00:59:06,230
if we are here and our free chunk is not

1316
00:59:02,570 --> 00:59:08,120
stuck in between all the chunks what

1317
00:59:06,230 --> 00:59:11,270
happens is the memory allocator will

1318
00:59:08,120 --> 00:59:13,310
coalesce this chunk in red with other

1319
00:59:11,270 --> 00:59:15,950
thing and then we have no idea of the

1320
00:59:13,310 --> 00:59:24,350
size of the chunk to replace and we want

1321
00:59:15,950 --> 00:59:28,250
to know the size thank you now I see are

1322
00:59:24,350 --> 00:59:31,250
there are no questions thank you I'll be

1323
00:59:28,250 --> 00:59:33,430
around anyway then thank you for amazing

1324
00:59:31,250 --> 00:59:33,430
talk

