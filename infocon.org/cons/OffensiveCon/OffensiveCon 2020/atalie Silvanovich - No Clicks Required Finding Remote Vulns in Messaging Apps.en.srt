1
00:00:00,000 --> 00:00:05,609
hi everyone thanks so much for coming

2
00:00:02,700 --> 00:00:07,259
today I'm gonna talk about fully remote

3
00:00:05,609 --> 00:00:10,139
vulnerabilities and messaging

4
00:00:07,259 --> 00:00:12,870
applications I'm Nathalie Silvano vaq

5
00:00:10,139 --> 00:00:16,079
and I'm a member of project 0 at Google

6
00:00:12,870 --> 00:00:17,759
and fully remote mobile vulnerabilities

7
00:00:16,079 --> 00:00:20,430
and exploits is something that we've

8
00:00:17,760 --> 00:00:22,650
been interested in for a long time the

9
00:00:20,430 --> 00:00:25,680
thing is it's one of those things where

10
00:00:22,650 --> 00:00:28,979
there's lots of rumors and speculation

11
00:00:25,680 --> 00:00:32,850
and not so much actual technical

12
00:00:28,980 --> 00:00:35,370
information for example early last year

13
00:00:32,850 --> 00:00:37,350
Chowki bakra made this tweet where he

14
00:00:35,370 --> 00:00:39,510
pretty much compared the security of

15
00:00:37,350 --> 00:00:42,059
different messengers from a zero-day

16
00:00:39,510 --> 00:00:44,430
exploit perspective and this was

17
00:00:42,059 --> 00:00:46,468
especially interesting because chowky

18
00:00:44,430 --> 00:00:49,079
runs a company called zero diem that

19
00:00:46,469 --> 00:00:52,230
publishes this public price list for all

20
00:00:49,079 --> 00:00:54,989
sorts of exploits for all sorts of

21
00:00:52,230 --> 00:00:57,779
targets and you'll see near the top

22
00:00:54,989 --> 00:01:00,718
there is zero click exploits and

23
00:00:57,780 --> 00:01:03,600
whatsapp and iMessage and then I'm

24
00:01:00,719 --> 00:01:06,119
signaling telegram lower down and to me

25
00:01:03,600 --> 00:01:08,820
this indicates that these exploits

26
00:01:06,119 --> 00:01:12,090
probably exist and are probably valued

27
00:01:08,820 --> 00:01:15,479
by attackers around the same time last

28
00:01:12,090 --> 00:01:18,150
year this article came out about the UAE

29
00:01:15,479 --> 00:01:20,939
secret hacking team and it talked about

30
00:01:18,150 --> 00:01:24,180
a tool called Karma that accesses data

31
00:01:20,939 --> 00:01:26,820
on people's iPhones and they

32
00:01:24,180 --> 00:01:29,520
specifically said that it did not

33
00:01:26,820 --> 00:01:32,250
require the target to click and that it

34
00:01:29,520 --> 00:01:34,890
relied on an undisclosed Wallner ability

35
00:01:32,250 --> 00:01:36,869
in Apple's iMessage software so this is

36
00:01:34,890 --> 00:01:39,680
another piece of evidence that attackers

37
00:01:36,869 --> 00:01:42,299
are using this type of vulnerability

38
00:01:39,680 --> 00:01:44,790
finally May of last year

39
00:01:42,299 --> 00:01:46,799
whatsapp actually detected attackers

40
00:01:44,790 --> 00:01:48,990
using a zero-day vulnerability against

41
00:01:46,799 --> 00:01:51,360
their iOS client in the wild and it was

42
00:01:48,990 --> 00:01:52,470
a fully remote 0 click vulnerability so

43
00:01:51,360 --> 00:01:55,049
I think this is the best evidence we

44
00:01:52,470 --> 00:01:57,420
have that attackers are actually using

45
00:01:55,049 --> 00:02:01,369
these vulnerabilities for all sorts of

46
00:01:57,420 --> 00:02:03,930
things but well there is all this

47
00:02:01,369 --> 00:02:06,210
indication there's not a lot of

48
00:02:03,930 --> 00:02:09,239
technical information available that

49
00:02:06,210 --> 00:02:11,340
publicly um so what we wanted to do is

50
00:02:09,239 --> 00:02:13,000
close the gap between the private

51
00:02:11,340 --> 00:02:15,550
attacker knowledge and what's available

52
00:02:13,000 --> 00:02:18,520
publicly and specifically and the

53
00:02:15,550 --> 00:02:21,310
questions wanted to answer was do these

54
00:02:18,520 --> 00:02:23,590
bugs exist and if so where in what

55
00:02:21,310 --> 00:02:24,970
component and how do they work that's

56
00:02:23,590 --> 00:02:27,910
what I'm going to talk about in this

57
00:02:24,970 --> 00:02:29,830
talk and then afterwards Samuel gross

58
00:02:27,910 --> 00:02:31,750
another member of project zero is going

59
00:02:29,830 --> 00:02:34,750
to talk about how to exploit these bugs

60
00:02:31,750 --> 00:02:36,730
because every so often there has been a

61
00:02:34,750 --> 00:02:39,340
bug found that you know could

62
00:02:36,730 --> 00:02:41,890
theoretically be fully remote even going

63
00:02:39,340 --> 00:02:43,390
back to things like stage fright but

64
00:02:41,890 --> 00:02:45,070
there hasn't been a lot of information

65
00:02:43,390 --> 00:02:48,010
about whether it's possible to exploit

66
00:02:45,070 --> 00:02:51,010
it so Samuel is gonna talk about his

67
00:02:48,010 --> 00:02:53,049
exploit for iMessage which i think is

68
00:02:51,010 --> 00:02:56,730
probably one of the first fully remote

69
00:02:53,050 --> 00:03:01,150
exploits of this type to be made public

70
00:02:56,730 --> 00:03:02,679
so what makes a bug fully remote well so

71
00:03:01,150 --> 00:03:05,170
they're also called interaction listen 0

72
00:03:02,680 --> 00:03:07,900
click and there is a few requirements we

73
00:03:05,170 --> 00:03:09,910
had for this research the first one is

74
00:03:07,900 --> 00:03:12,250
no user interaction required like

75
00:03:09,910 --> 00:03:14,590
absolutely none like you can have your

76
00:03:12,250 --> 00:03:18,430
friend you know take a device out of the

77
00:03:14,590 --> 00:03:21,040
box and install the messenger and then

78
00:03:18,430 --> 00:03:24,220
you can use the exploit right away

79
00:03:21,040 --> 00:03:26,980
no proximity there are exploits that

80
00:03:24,220 --> 00:03:29,739
involve say being on the network path or

81
00:03:26,980 --> 00:03:31,390
using Wi-Fi or Bluetooth locally and

82
00:03:29,739 --> 00:03:34,150
these are still important but they're

83
00:03:31,390 --> 00:03:35,950
not what we were looking at here also a

84
00:03:34,150 --> 00:03:38,380
short wait time which I'm not going to

85
00:03:35,950 --> 00:03:39,940
quantify but sometimes you know there's

86
00:03:38,380 --> 00:03:41,709
bugs where they're like oh well the

87
00:03:39,940 --> 00:03:44,370
person's eventually gonna unlock their

88
00:03:41,709 --> 00:03:46,989
phone or eventually do this or that and

89
00:03:44,370 --> 00:03:49,360
nothing we looked at relies on that and

90
00:03:46,989 --> 00:03:51,940
also we're looking for bugs that require

91
00:03:49,360 --> 00:03:53,920
at a reasonable set of identifiers so

92
00:03:51,940 --> 00:03:55,810
pretty much however you contact the

93
00:03:53,920 --> 00:03:57,488
person on the messaging application

94
00:03:55,810 --> 00:04:01,000
usually their phone number or email

95
00:03:57,489 --> 00:04:02,890
address once bugs start to require more

96
00:04:01,000 --> 00:04:06,370
complex information like say someone's

97
00:04:02,890 --> 00:04:09,670
IMEI they become more difficult for

98
00:04:06,370 --> 00:04:11,620
attackers to use and finally some

99
00:04:09,670 --> 00:04:13,839
messengers have a concept of friendship

100
00:04:11,620 --> 00:04:15,430
or contacts where there's additional

101
00:04:13,840 --> 00:04:17,680
features you can use if someone's a

102
00:04:15,430 --> 00:04:19,120
contact and we look for bugs

103
00:04:17,680 --> 00:04:21,820
specifically that don't require that

104
00:04:19,120 --> 00:04:24,820
type of feature and once again bugs that

105
00:04:21,820 --> 00:04:26,650
do are still important but it's another

106
00:04:24,820 --> 00:04:29,080
step that an attacker has to

107
00:04:26,650 --> 00:04:30,789
you complete if they want someone to say

108
00:04:29,080 --> 00:04:34,508
you know be their contact or their

109
00:04:30,790 --> 00:04:37,060
friend on a messenger so thinking about

110
00:04:34,509 --> 00:04:39,610
this more theoretically what sort of

111
00:04:37,060 --> 00:04:42,370
bugs could be zero click and there's

112
00:04:39,610 --> 00:04:44,949
kind of two classes the first is memory

113
00:04:42,370 --> 00:04:47,020
corruption vulnerabilities and we looked

114
00:04:44,949 --> 00:04:49,360
for these although one of the challenges

115
00:04:47,020 --> 00:04:51,190
is these mobile messengers often don't

116
00:04:49,360 --> 00:04:53,560
have a lot of native code and definitely

117
00:04:51,190 --> 00:04:56,440
don't have a lot of native code that is

118
00:04:53,560 --> 00:04:57,970
available in the remote context and if

119
00:04:56,440 --> 00:04:59,740
you do find a bug which we did an

120
00:04:57,970 --> 00:05:02,590
exploitation is challenging and when we

121
00:04:59,740 --> 00:05:04,330
started this project we didn't know how

122
00:05:02,590 --> 00:05:06,820
you would exploit a bug like this

123
00:05:04,330 --> 00:05:09,340
on the flip side there's also logic bugs

124
00:05:06,820 --> 00:05:12,159
but they're rarer than memory corruption

125
00:05:09,340 --> 00:05:14,109
bugs and quite often you know they're

126
00:05:12,160 --> 00:05:16,060
not that versatile if you have a

127
00:05:14,110 --> 00:05:17,680
terrible memory corruption bug you know

128
00:05:16,060 --> 00:05:21,010
sometimes if you put in a lot of effort

129
00:05:17,680 --> 00:05:22,930
you can make it execute code typically

130
00:05:21,010 --> 00:05:26,620
for a logic bug you get what you get and

131
00:05:22,930 --> 00:05:28,599
that's it um one thing that we did find

132
00:05:26,620 --> 00:05:30,880
though is that bugs that expose attack

133
00:05:28,599 --> 00:05:33,760
surface can be very helpful for example

134
00:05:30,880 --> 00:05:36,130
imagine you have an image parser that

135
00:05:33,760 --> 00:05:37,719
gets executed like after the user clicks

136
00:05:36,130 --> 00:05:41,099
sometimes there can be bugs that move

137
00:05:37,720 --> 00:05:43,900
attack surface forward move it so that

138
00:05:41,099 --> 00:05:46,990
now you don't have to click and I think

139
00:05:43,900 --> 00:05:50,859
this is a very promising way to find

140
00:05:46,990 --> 00:05:52,889
vulnerabilities that are fully remote 52

141
00:05:50,860 --> 00:05:57,310
examples here

142
00:05:52,889 --> 00:05:59,770
sorry I look at whatsapp this was I

143
00:05:57,310 --> 00:06:01,900
think one of the first messaging clients

144
00:05:59,770 --> 00:06:04,690
I looked at and I look at the Android

145
00:06:01,900 --> 00:06:07,419
client and the native code was actually

146
00:06:04,690 --> 00:06:09,039
very limited pretty much the only native

147
00:06:07,419 --> 00:06:11,409
component to Android are image

148
00:06:09,039 --> 00:06:14,500
processing and video conferencing and

149
00:06:11,409 --> 00:06:17,080
image processing actually has a lot of

150
00:06:14,500 --> 00:06:18,880
limitations in that most of the

151
00:06:17,080 --> 00:06:20,949
interesting image processing is done on

152
00:06:18,880 --> 00:06:22,539
the send side so if you found a

153
00:06:20,949 --> 00:06:24,460
vulnerability someone would have to send

154
00:06:22,539 --> 00:06:26,260
someone that image is opposed to receive

155
00:06:24,460 --> 00:06:29,020
it so I didn't look at that attack

156
00:06:26,260 --> 00:06:30,639
surface much because of that so I looked

157
00:06:29,020 --> 00:06:33,690
at first what's called videoconferencing

158
00:06:30,639 --> 00:06:35,860
signaling which is when a call is set up

159
00:06:33,690 --> 00:06:37,510
you have to you know say things about

160
00:06:35,860 --> 00:06:39,340
your device and figure out the stream

161
00:06:37,510 --> 00:06:40,480
and that's a fully remote attack surface

162
00:06:39,340 --> 00:06:42,280
because typically the

163
00:06:40,480 --> 00:06:45,100
exchange disinformation before they even

164
00:06:42,280 --> 00:06:47,619
ring for the other user I'm looking at

165
00:06:45,100 --> 00:06:49,750
this I found a few minor logic bugs but

166
00:06:47,620 --> 00:06:53,020
nothing too exciting and then I looked

167
00:06:49,750 --> 00:06:55,270
at the video stream RTP is the protocol

168
00:06:53,020 --> 00:06:56,950
and I found one bug there in video

169
00:06:55,270 --> 00:06:59,890
processing but unfortunately it wasn't a

170
00:06:56,950 --> 00:07:02,500
fully remote bug it was a bug that

171
00:06:59,890 --> 00:07:05,860
required one click and the later after

172
00:07:02,500 --> 00:07:07,780
this research that whatsapp zero-day was

173
00:07:05,860 --> 00:07:11,350
detected in the wild and what was

174
00:07:07,780 --> 00:07:12,760
interesting about it is it had like used

175
00:07:11,350 --> 00:07:15,280
bugs that were fairly similar to what I

176
00:07:12,760 --> 00:07:17,860
found but what they did is they use the

177
00:07:15,280 --> 00:07:19,239
logic bug to pretty much move the

178
00:07:17,860 --> 00:07:21,490
protocol processing for video

179
00:07:19,240 --> 00:07:25,570
conferencing forward so that now it was

180
00:07:21,490 --> 00:07:27,520
fully remote and now this protocol

181
00:07:25,570 --> 00:07:29,980
that's very prone to memory corruption

182
00:07:27,520 --> 00:07:31,570
flaws was available to attackers without

183
00:07:29,980 --> 00:07:33,160
picking up the call so that I thought

184
00:07:31,570 --> 00:07:34,570
that was you know an especially

185
00:07:33,160 --> 00:07:37,960
interesting way to put things together

186
00:07:34,570 --> 00:07:40,270
to make kind of two bugs to get that

187
00:07:37,960 --> 00:07:43,900
alone we're not fully remote into one

188
00:07:40,270 --> 00:07:46,359
bug that was another example of this is

189
00:07:43,900 --> 00:07:48,250
I found a logic bug in signal and this

190
00:07:46,360 --> 00:07:50,530
is what I would given as an example of

191
00:07:48,250 --> 00:07:52,090
like quite a quality logic bug it was

192
00:07:50,530 --> 00:07:54,190
pretty much you could send a message to

193
00:07:52,090 --> 00:07:55,929
the signal client and it would pick up

194
00:07:54,190 --> 00:07:57,880
the phone and then you could listen

195
00:07:55,930 --> 00:07:59,790
through the microphone and this was a

196
00:07:57,880 --> 00:08:02,230
very interesting bug in its own right

197
00:07:59,790 --> 00:08:04,690
but it's also useful in creating for

198
00:08:02,230 --> 00:08:06,790
increasing attack surface signal already

199
00:08:04,690 --> 00:08:08,740
processes a lot of data before you pick

200
00:08:06,790 --> 00:08:10,330
up a phone call but if you can pick up a

201
00:08:08,740 --> 00:08:12,610
phone call like there's now even more

202
00:08:10,330 --> 00:08:14,229
attack surface so I think this bug was

203
00:08:12,610 --> 00:08:16,540
even more concerning not just from the

204
00:08:14,230 --> 00:08:18,820
perspective of being able to listen to

205
00:08:16,540 --> 00:08:20,500
someone but also from the perspective of

206
00:08:18,820 --> 00:08:23,430
I think it makes a lot of other

207
00:08:20,500 --> 00:08:29,140
vulnerable things available to attackers

208
00:08:23,430 --> 00:08:30,520
so we're doing this a general process at

209
00:08:29,140 --> 00:08:31,510
least for mobile applications is it

210
00:08:30,520 --> 00:08:33,579
generally I'm starting off by

211
00:08:31,510 --> 00:08:36,250
determining which components have native

212
00:08:33,580 --> 00:08:37,750
code and some messengers they have so

213
00:08:36,250 --> 00:08:40,120
much native code but that's the only

214
00:08:37,750 --> 00:08:42,370
step I do they have enough that there is

215
00:08:40,120 --> 00:08:44,560
a lot of vulnerabilities in there and

216
00:08:42,370 --> 00:08:47,290
also you have to figure out which ones

217
00:08:44,560 --> 00:08:48,880
are reachable remotely but some

218
00:08:47,290 --> 00:08:51,339
messengers do have a lot of this and

219
00:08:48,880 --> 00:08:54,280
some have not so much and then the ones

220
00:08:51,340 --> 00:08:55,660
where this is not possible

221
00:08:54,280 --> 00:08:58,180
but then it makes sense to start looking

222
00:08:55,660 --> 00:09:01,839
for ways to increase attack surface and

223
00:08:58,180 --> 00:09:04,479
see what can be moved forward to make it

224
00:09:01,840 --> 00:09:06,040
fully remote so I'm gonna talk

225
00:09:04,480 --> 00:09:08,080
specifically about what we did with

226
00:09:06,040 --> 00:09:10,060
iMessage and I must say it was a bit

227
00:09:08,080 --> 00:09:12,330
special in that I feel that it has a

228
00:09:10,060 --> 00:09:15,250
uniquely large remote attack surface

229
00:09:12,330 --> 00:09:17,800
compared to basically anything else I've

230
00:09:15,250 --> 00:09:19,870
looked at there was just so much

231
00:09:17,800 --> 00:09:20,890
processing done in native code and I

232
00:09:19,870 --> 00:09:23,650
think part of this is because it's

233
00:09:20,890 --> 00:09:26,410
written in objective-c meanwhile a lot

234
00:09:23,650 --> 00:09:28,569
of clients are written in Java or Swift

235
00:09:26,410 --> 00:09:31,540
and it also had a lot of formatting

236
00:09:28,570 --> 00:09:33,700
features including extensions which I'll

237
00:09:31,540 --> 00:09:35,230
talk a bit about later and I worked with

238
00:09:33,700 --> 00:09:36,820
Samuel gross on this and he's going to

239
00:09:35,230 --> 00:09:41,050
talk about the exploits for these bugs

240
00:09:36,820 --> 00:09:43,290
later so we started off by writing an

241
00:09:41,050 --> 00:09:45,760
iMessage sending an intercepting client

242
00:09:43,290 --> 00:09:47,980
if you can do this first um it really

243
00:09:45,760 --> 00:09:51,130
helps then we could look at the messages

244
00:09:47,980 --> 00:09:53,410
and we were able to also send messages

245
00:09:51,130 --> 00:09:56,260
to test how things worked it really sped

246
00:09:53,410 --> 00:09:59,410
up our ability to look at these bugs um

247
00:09:56,260 --> 00:10:01,360
so we did this by using frida to hook

248
00:09:59,410 --> 00:10:03,219
the incoming and outgoing messages and

249
00:10:01,360 --> 00:10:05,170
we did this in both Mac and iPhone so

250
00:10:03,220 --> 00:10:08,740
this was a good tooling to be able to

251
00:10:05,170 --> 00:10:10,599
test out bugs and from this this is what

252
00:10:08,740 --> 00:10:14,620
a message looks like and it's in the

253
00:10:10,600 --> 00:10:17,410
binary plist format which on iOS is used

254
00:10:14,620 --> 00:10:19,150
to do all sorts of things some of the

255
00:10:17,410 --> 00:10:21,699
interesting fields is you can see

256
00:10:19,150 --> 00:10:24,520
there's the text content and then

257
00:10:21,700 --> 00:10:27,040
there's this B ID and B P these are

258
00:10:24,520 --> 00:10:28,199
related to extensions so you know how

259
00:10:27,040 --> 00:10:31,209
like there's this feature on the iPhone

260
00:10:28,200 --> 00:10:33,010
where you point the device at yourself

261
00:10:31,210 --> 00:10:34,390
and you talk and then the giraffe smell

262
00:10:33,010 --> 00:10:37,390
with moves at the same time as your

263
00:10:34,390 --> 00:10:39,490
mouse that is an extension so the way

264
00:10:37,390 --> 00:10:41,439
this works is that'll be serialized and

265
00:10:39,490 --> 00:10:44,650
put into this BP field and then the B ID

266
00:10:41,440 --> 00:10:46,540
will tell iMessage what type of data it

267
00:10:44,650 --> 00:10:48,100
is so it'll say this is typed raff and

268
00:10:46,540 --> 00:10:51,339
then the other side will know how to

269
00:10:48,100 --> 00:10:54,700
decode it there was also the API which

270
00:10:51,339 --> 00:10:56,320
is also a blob of serialized data that

271
00:10:54,700 --> 00:10:58,630
um contains information about the

272
00:10:56,320 --> 00:11:01,120
message and we didn't look at this as

273
00:10:58,630 --> 00:11:03,850
much but it is somewhere that's also

274
00:11:01,120 --> 00:11:05,260
available to to serialize stuff and also

275
00:11:03,850 --> 00:11:07,330
there's the P field which is the

276
00:11:05,260 --> 00:11:07,960
participants you can send an iMessage to

277
00:11:07,330 --> 00:11:12,040
a lot of people

278
00:11:07,960 --> 00:11:14,410
if you want so we look more deeply at

279
00:11:12,040 --> 00:11:16,630
this serialization which is the BP and

280
00:11:14,410 --> 00:11:20,410
ATI fields and the way this works

281
00:11:16,630 --> 00:11:22,870
generally is that every class that you

282
00:11:20,410 --> 00:11:24,939
can de serialize will have a function

283
00:11:22,870 --> 00:11:27,240
called a knit with coder defined which

284
00:11:24,940 --> 00:11:30,310
defines how it gets to serialized and

285
00:11:27,240 --> 00:11:31,930
this we thought was especially promising

286
00:11:30,310 --> 00:11:33,880
because there were several passed bugs

287
00:11:31,930 --> 00:11:36,880
in it with coder functions and including

288
00:11:33,880 --> 00:11:38,890
some that were found by Ian beer so

289
00:11:36,880 --> 00:11:40,960
here's an example of how this

290
00:11:38,890 --> 00:11:43,750
realization works so this is a certainty

291
00:11:40,960 --> 00:11:48,130
suit or a serialized object you can see

292
00:11:43,750 --> 00:11:50,410
on my right there is the class is the

293
00:11:48,130 --> 00:11:52,450
class hierarchy so there's nsurl and s

294
00:11:50,410 --> 00:11:53,949
object and that's the type of the object

295
00:11:52,450 --> 00:11:56,430
you're trying to dis you realize and

296
00:11:53,950 --> 00:12:01,330
then it will call in it with coder for

297
00:11:56,430 --> 00:12:02,800
the URL and then that will in this a

298
00:12:01,330 --> 00:12:04,990
name with coder function pull out the

299
00:12:02,800 --> 00:12:07,599
stuff it needs to initialize the URL in

300
00:12:04,990 --> 00:12:10,750
this case you can see the NS base and NS

301
00:12:07,600 --> 00:12:12,880
relative on the other side and these are

302
00:12:10,750 --> 00:12:14,500
references to objects and the 0 1 is

303
00:12:12,880 --> 00:12:15,970
just null but the 6 is actually a

304
00:12:14,500 --> 00:12:18,370
reference to this string on the other

305
00:12:15,970 --> 00:12:19,690
side at the very top column so it'll

306
00:12:18,370 --> 00:12:21,310
pull out this string and then that will

307
00:12:19,690 --> 00:12:25,150
be the URL for the URL it will

308
00:12:21,310 --> 00:12:27,219
initialize this object and return it so

309
00:12:25,150 --> 00:12:29,709
what is this actually happened so when

310
00:12:27,220 --> 00:12:31,870
we look at I message for the BP field

311
00:12:29,710 --> 00:12:35,440
this deserialization happened in

312
00:12:31,870 --> 00:12:37,810
springboard so this was great it was a

313
00:12:35,440 --> 00:12:40,180
none sandboxed process though it's it's

314
00:12:37,810 --> 00:12:43,239
not anymore the serialization is now

315
00:12:40,180 --> 00:12:46,959
done in IMD persistence which has fewer

316
00:12:43,240 --> 00:12:49,180
privileges and is sandboxed this also

317
00:12:46,960 --> 00:12:53,050
was done in mobile SMS with one-click so

318
00:12:49,180 --> 00:12:54,880
that's not that interesting and then the

319
00:12:53,050 --> 00:12:56,589
ime agent process does the same thing

320
00:12:54,880 --> 00:13:00,300
with this ati field so that's another

321
00:12:56,590 --> 00:13:03,340
option for using bugs into serialization

322
00:13:00,300 --> 00:13:05,170
so the serialization does have some

323
00:13:03,340 --> 00:13:07,420
security features which are called NS

324
00:13:05,170 --> 00:13:10,959
secure coding and there's kind of two

325
00:13:07,420 --> 00:13:13,959
big things this does the first one is if

326
00:13:10,960 --> 00:13:21,040
an encoder from a class is used it has

327
00:13:13,960 --> 00:13:21,790
to extend another method in the in the

328
00:13:21,040 --> 00:13:23,380
object

329
00:13:21,790 --> 00:13:26,160
and the second method and this basically

330
00:13:23,380 --> 00:13:28,330
means that you can't accidentally

331
00:13:26,160 --> 00:13:31,810
releasing it with coder you have to

332
00:13:28,330 --> 00:13:33,070
intentionally extend this function so

333
00:13:31,810 --> 00:13:35,160
that you're kind of putting in a flag

334
00:13:33,070 --> 00:13:37,960
that says yes I'm doing this on purpose

335
00:13:35,160 --> 00:13:40,120
but the other thing which I think is

336
00:13:37,960 --> 00:13:42,190
more important is that it requires the

337
00:13:40,120 --> 00:13:43,960
developer to say what they wanted to

338
00:13:42,190 --> 00:13:46,120
serialize either a list or a single

339
00:13:43,960 --> 00:13:47,920
thing this prevents like you know you

340
00:13:46,120 --> 00:13:50,560
want a string but you get an object back

341
00:13:47,920 --> 00:13:53,680
and that's really important although

342
00:13:50,560 --> 00:13:55,540
unfortunately there are what they call

343
00:13:53,680 --> 00:13:58,359
safe to serialize serialization and

344
00:13:55,540 --> 00:14:01,360
unsafe to serialization and there's

345
00:13:58,360 --> 00:14:03,010
methods for each so anti secure coding

346
00:14:01,360 --> 00:14:05,170
is not necessarily enabled and

347
00:14:03,010 --> 00:14:08,230
unfortunately these have very similar

348
00:14:05,170 --> 00:14:10,740
names so for example this one is safe

349
00:14:08,230 --> 00:14:13,780
and this one is unsafe and you'll notice

350
00:14:10,740 --> 00:14:16,450
these are very similar and I am sure no

351
00:14:13,780 --> 00:14:19,569
one ever messes up which one to use

352
00:14:16,450 --> 00:14:23,470
so I was concerning so our first idea

353
00:14:19,570 --> 00:14:26,170
was let's see if we can find some

354
00:14:23,470 --> 00:14:28,030
accidental insecure calls and our idea

355
00:14:26,170 --> 00:14:30,189
was let's see if we can do that and then

356
00:14:28,030 --> 00:14:31,600
initialize a WebKit instance and then

357
00:14:30,190 --> 00:14:33,880
there's lots of alms and WebKit

358
00:14:31,600 --> 00:14:35,530
so it would be easier and exploitation

359
00:14:33,880 --> 00:14:37,810
is well-known so it should be easy to

360
00:14:35,530 --> 00:14:39,220
start exploiting at that point but we

361
00:14:37,810 --> 00:14:41,439
actually looked through every call and

362
00:14:39,220 --> 00:14:44,560
they were all secure even though they're

363
00:14:41,440 --> 00:14:46,750
a bit confusing so that was good so then

364
00:14:44,560 --> 00:14:48,189
we decided let's see if we can find an

365
00:14:46,750 --> 00:14:49,270
extension that misused is it a

366
00:14:48,190 --> 00:14:51,490
serialized object

367
00:14:49,270 --> 00:14:54,069
so pretty much extensions can implement

368
00:14:51,490 --> 00:14:57,550
their own to serialization they aren't

369
00:14:54,070 --> 00:14:59,290
bound by this nskeyedarchiver stuff so

370
00:14:57,550 --> 00:15:01,689
we went through all of these and we

371
00:14:59,290 --> 00:15:04,599
found what I called one kind of inferior

372
00:15:01,690 --> 00:15:06,700
bug this extension called digital touch

373
00:15:04,600 --> 00:15:09,880
which you can use to like draw images

374
00:15:06,700 --> 00:15:11,920
and iMessage it would disi realize some

375
00:15:09,880 --> 00:15:13,540
arrays but I would trust the length so

376
00:15:11,920 --> 00:15:15,040
this could end up reading way out of

377
00:15:13,540 --> 00:15:16,870
bounds but that's just a read out of

378
00:15:15,040 --> 00:15:20,740
bounds I'm not really an exploitable

379
00:15:16,870 --> 00:15:24,190
issue so we moved on so the other thing

380
00:15:20,740 --> 00:15:25,960
we did look at here is can we use these

381
00:15:24,190 --> 00:15:27,730
extensions to once again load a WebKit

382
00:15:25,960 --> 00:15:30,220
instance because there's one extension

383
00:15:27,730 --> 00:15:31,780
called link presentation and that's when

384
00:15:30,220 --> 00:15:34,360
you send someone a link you'll notice an

385
00:15:31,780 --> 00:15:35,529
iMessage you get a preview when we

386
00:15:34,360 --> 00:15:37,540
thought well maybe that pretty

387
00:15:35,529 --> 00:15:39,819
view involves WebKit but it turns out

388
00:15:37,540 --> 00:15:42,099
this was actually very well designed and

389
00:15:39,819 --> 00:15:43,779
when you send a link using iMessage the

390
00:15:42,100 --> 00:15:46,779
person who's sending takes all the risk

391
00:15:43,779 --> 00:15:48,279
on their device it gets loaded and then

392
00:15:46,779 --> 00:15:51,459
on their device it gets created it gets

393
00:15:48,279 --> 00:15:54,160
turned into a preview so it never gets

394
00:15:51,459 --> 00:15:55,809
loaded on the receiving device and we

395
00:15:54,160 --> 00:15:57,339
did look and CEO is there a way we can

396
00:15:55,809 --> 00:15:59,860
trick this and get it to load WebKit

397
00:15:57,339 --> 00:16:03,790
instance on the receiver but we couldn't

398
00:15:59,860 --> 00:16:05,439
find any so our next idea was let's look

399
00:16:03,790 --> 00:16:07,569
at you know all the legitimate to

400
00:16:05,439 --> 00:16:09,699
serialization all the init with coders

401
00:16:07,569 --> 00:16:13,660
and see if they have any bugs in them

402
00:16:09,699 --> 00:16:16,389
and this actually turned out to be like

403
00:16:13,660 --> 00:16:19,360
quite a big attack surface because in

404
00:16:16,389 --> 00:16:21,730
iMessage there's typically these seven

405
00:16:19,360 --> 00:16:24,459
classes that they just serialize and as

406
00:16:21,730 --> 00:16:26,889
dictionary and extra et cetera but then

407
00:16:24,459 --> 00:16:29,018
also all their subclasses can be to

408
00:16:26,889 --> 00:16:31,180
serialized and the way the subclasses

409
00:16:29,019 --> 00:16:33,519
get included is there from every single

410
00:16:31,180 --> 00:16:35,170
library that gets loaded by iMessage or

411
00:16:33,519 --> 00:16:37,029
in this case springboard and that's

412
00:16:35,170 --> 00:16:39,639
quite a lot of libraries so this ended

413
00:16:37,029 --> 00:16:42,100
up being I think probably about 80 to

414
00:16:39,639 --> 00:16:45,759
100 objects that we reviewed the net

415
00:16:42,100 --> 00:16:47,800
with coders of and we found this bug um

416
00:16:45,759 --> 00:16:50,350
this is actually an interesting logic

417
00:16:47,800 --> 00:16:53,740
bug pretty much there was an estate a

418
00:16:50,350 --> 00:16:55,870
class that when I was the SI realized it

419
00:16:53,740 --> 00:16:57,699
would load a local file and this turned

420
00:16:55,870 --> 00:17:00,430
out to be problematic because it kind of

421
00:16:57,699 --> 00:17:01,870
had two problems problem number one was

422
00:17:00,430 --> 00:17:03,670
that it trusts the length of the

423
00:17:01,870 --> 00:17:05,949
serialized file so if you said oh this

424
00:17:03,670 --> 00:17:07,928
is a 100 byte file but it was actually a

425
00:17:05,949 --> 00:17:09,880
10 byte file the rest of that memory

426
00:17:07,929 --> 00:17:11,679
would be uninitialized but more

427
00:17:09,880 --> 00:17:13,299
importantly they did have a check to

428
00:17:11,679 --> 00:17:14,949
make sure this was a local file that you

429
00:17:13,299 --> 00:17:18,189
were not fetching something from a URL

430
00:17:14,949 --> 00:17:20,079
but that check was defective so with

431
00:17:18,189 --> 00:17:23,169
that ability you could actually use this

432
00:17:20,079 --> 00:17:24,938
to pull a file off of a device and the

433
00:17:23,169 --> 00:17:26,770
general idea is you would use this NS

434
00:17:24,939 --> 00:17:28,750
data which would load the file into the

435
00:17:26,770 --> 00:17:30,820
buffer and then using other to

436
00:17:28,750 --> 00:17:33,159
serialization you could append this data

437
00:17:30,820 --> 00:17:35,500
to an nsurl and then you could use the

438
00:17:33,159 --> 00:17:37,450
bug again to visit that URL and then

439
00:17:35,500 --> 00:17:39,070
that URL would have appended as URL

440
00:17:37,450 --> 00:17:43,530
parameter all the contents of that data

441
00:17:39,070 --> 00:17:46,049
of that file so that was pretty cool um

442
00:17:43,530 --> 00:17:48,760
but then we moved on

443
00:17:46,049 --> 00:17:51,490
we had a thought which is

444
00:17:48,760 --> 00:17:53,110
what if a class does not have any met

445
00:17:51,490 --> 00:17:55,960
with coder and you try to serialize it

446
00:17:53,110 --> 00:17:58,959
and it turned out that normal

447
00:17:55,960 --> 00:18:01,870
inheritance rules apply which was quite

448
00:17:58,960 --> 00:18:05,950
interesting so for example when you

449
00:18:01,870 --> 00:18:08,229
initialize an NS data you calling it

450
00:18:05,950 --> 00:18:12,030
with capacity and almost every NS data

451
00:18:08,230 --> 00:18:14,740
class will extend in it with capacity to

452
00:18:12,030 --> 00:18:17,220
initialize their memory but let's see

453
00:18:14,740 --> 00:18:20,020
does he realize an NS data that that

454
00:18:17,220 --> 00:18:22,960
extends or you to serialize class that

455
00:18:20,020 --> 00:18:25,330
extends NS data if he does not have its

456
00:18:22,960 --> 00:18:27,160
own in it with coder and the one above

457
00:18:25,330 --> 00:18:29,080
it calls init with capacity it will call

458
00:18:27,160 --> 00:18:31,300
the init with capacity of the subclass

459
00:18:29,080 --> 00:18:33,280
not the class then you implemented the

460
00:18:31,300 --> 00:18:35,560
in it with coder so this is like a very

461
00:18:33,280 --> 00:18:37,540
unexpected code path that I think most

462
00:18:35,560 --> 00:18:40,210
developers would not expect when they're

463
00:18:37,540 --> 00:18:40,899
at creating a new MNS data class or

464
00:18:40,210 --> 00:18:44,950
anything like that

465
00:18:40,900 --> 00:18:47,050
I'm smells quite problematic so we found

466
00:18:44,950 --> 00:18:49,570
a bug that involved this problem this

467
00:18:47,050 --> 00:18:52,300
was in a class called PF array and it

468
00:18:49,570 --> 00:18:53,860
had in it with objects count extended

469
00:18:52,300 --> 00:18:56,490
and this isn't another very common

470
00:18:53,860 --> 00:19:01,570
function this is typically how you

471
00:18:56,490 --> 00:19:03,580
initialize an array and the problem with

472
00:19:01,570 --> 00:19:05,020
it is that it didn't create references

473
00:19:03,580 --> 00:19:07,149
to any of the objects in the array and

474
00:19:05,020 --> 00:19:09,250
I'm assuming that this subclass was

475
00:19:07,150 --> 00:19:10,690
intended to be used in some very special

476
00:19:09,250 --> 00:19:13,750
circumstance where there were already

477
00:19:10,690 --> 00:19:15,760
references to everything but it wasn't

478
00:19:13,750 --> 00:19:17,350
because of this behavior basically

479
00:19:15,760 --> 00:19:21,220
anyone who does see realized anything

480
00:19:17,350 --> 00:19:23,230
could also to serialize this class which

481
00:19:21,220 --> 00:19:25,480
has no references so this was a youth

482
00:19:23,230 --> 00:19:29,980
after free for like every item in the

483
00:19:25,480 --> 00:19:31,740
array but we moved on and it got more

484
00:19:29,980 --> 00:19:34,690
complicated because here's a question

485
00:19:31,740 --> 00:19:37,660
what if an object has cycles in it what

486
00:19:34,690 --> 00:19:39,670
if I say you know my NS array is or my

487
00:19:37,660 --> 00:19:41,680
nsurl has the string but my string is an

488
00:19:39,670 --> 00:19:43,780
nsurl and they just kind of go forever

489
00:19:41,680 --> 00:19:47,320
um and this is actually quite

490
00:19:43,780 --> 00:19:49,210
interesting so to start off how does

491
00:19:47,320 --> 00:19:51,909
something get to serialize the very

492
00:19:49,210 --> 00:19:54,280
first time you to serialize it well it's

493
00:19:51,910 --> 00:19:56,530
it's called let's say NS sound class it

494
00:19:54,280 --> 00:19:58,180
gets allocated and then there's a

495
00:19:56,530 --> 00:20:00,280
temporary dictionary and it gets added

496
00:19:58,180 --> 00:20:02,470
to it then and it was coder gets called

497
00:20:00,280 --> 00:20:04,120
and then it will get removed from the

498
00:20:02,470 --> 00:20:06,429
very dictionary and added to a permanent

499
00:20:04,120 --> 00:20:08,949
dictionary now what happens we need to

500
00:20:06,429 --> 00:20:10,960
serialize it a second time well if it's

501
00:20:08,950 --> 00:20:12,669
in the temporary dictionary it will copy

502
00:20:10,960 --> 00:20:13,900
it and pull it out if it's in the object

503
00:20:12,669 --> 00:20:16,030
dictionary it will copy it and pull it

504
00:20:13,900 --> 00:20:17,530
out otherwise you have actually not to

505
00:20:16,030 --> 00:20:21,399
serialize this object and you have to do

506
00:20:17,530 --> 00:20:23,678
that so that's interesting there's kind

507
00:20:21,400 --> 00:20:25,539
of two problems here problem number one

508
00:20:23,679 --> 00:20:27,190
is because of that temporary dictionary

509
00:20:25,539 --> 00:20:29,620
you can grab the object before you're

510
00:20:27,190 --> 00:20:31,659
done the Annette with coder and that's

511
00:20:29,620 --> 00:20:34,120
like violating all sorts of expectations

512
00:20:31,659 --> 00:20:37,330
the programmer has there's also this

513
00:20:34,120 --> 00:20:39,489
problem where I mean it was coder is not

514
00:20:37,330 --> 00:20:42,520
guaranteed to return the object that is

515
00:20:39,490 --> 00:20:44,200
returned that is allocated initially the

516
00:20:42,520 --> 00:20:45,879
documents say it can return something

517
00:20:44,200 --> 00:20:47,289
different if they want but meanwhile

518
00:20:45,880 --> 00:20:50,260
this temporary dictionary has no

519
00:20:47,289 --> 00:20:52,210
references so theoretically you could

520
00:20:50,260 --> 00:20:53,289
follow all the documentation and end up

521
00:20:52,210 --> 00:20:55,390
with something that has use after free

522
00:20:53,289 --> 00:20:56,500
in it I'm actually didn't find any bugs

523
00:20:55,390 --> 00:20:59,260
like this but I found it a little

524
00:20:56,500 --> 00:21:01,000
disconcerting that even as documented

525
00:20:59,260 --> 00:21:03,070
you aren't guaranteed to always have

526
00:21:01,000 --> 00:21:06,909
references to things where there should

527
00:21:03,070 --> 00:21:08,918
be references so looking at cycles and

528
00:21:06,909 --> 00:21:11,140
we found a couple of bugs um there was

529
00:21:08,919 --> 00:21:14,429
this one in the NS Cherokee dictionary

530
00:21:11,140 --> 00:21:18,460
and basically this is a dictionary where

531
00:21:14,429 --> 00:21:20,799
you get optimization in return for

532
00:21:18,460 --> 00:21:22,659
declaring all your keys upfront and all

533
00:21:20,799 --> 00:21:24,940
these keys are in a singly linked list

534
00:21:22,659 --> 00:21:26,950
and the buck here is they would go in

535
00:21:24,940 --> 00:21:28,990
the net with coder and before your

536
00:21:26,950 --> 00:21:31,539
linked list was complete you could use

537
00:21:28,990 --> 00:21:32,950
the object and the problem with this is

538
00:21:31,539 --> 00:21:35,169
that the first time you use the object

539
00:21:32,950 --> 00:21:37,539
it allocates an array that has all the

540
00:21:35,169 --> 00:21:39,010
elements in it and then when you NY and

541
00:21:37,539 --> 00:21:39,940
you'll add more stuff to this linked

542
00:21:39,010 --> 00:21:41,860
list and then when you're actually

543
00:21:39,940 --> 00:21:45,520
trying and access those keys and you'll

544
00:21:41,860 --> 00:21:46,780
read out of bounds and this is a very

545
00:21:45,520 --> 00:21:48,460
exploitable bug basically because it

546
00:21:46,780 --> 00:21:51,340
does calls on this out of bounds reads

547
00:21:48,460 --> 00:21:54,520
right away um and I have this picture

548
00:21:51,340 --> 00:21:56,230
here this is just because people are

549
00:21:54,520 --> 00:21:58,570
always like Natalie do you have special

550
00:21:56,230 --> 00:22:02,320
tools that create objects for you and

551
00:21:58,570 --> 00:22:06,280
the answer is no I had forge them one by

552
00:22:02,320 --> 00:22:08,530
one and it takes days so that is how I

553
00:22:06,280 --> 00:22:10,570
made this bug work I'm including this I

554
00:22:08,530 --> 00:22:12,908
Stephan Esther put this on Twitter this

555
00:22:10,570 --> 00:22:14,620
morning he made a tool that very least

556
00:22:12,909 --> 00:22:16,010
if you already have the object it'll

557
00:22:14,620 --> 00:22:20,209
display it much more nicely

558
00:22:16,010 --> 00:22:21,860
in mine we can't all be talented but I

559
00:22:20,210 --> 00:22:23,570
thought this was pretty cool and

560
00:22:21,860 --> 00:22:27,979
probably a better visualization than

561
00:22:23,570 --> 00:22:29,389
this so there was another bug we found

562
00:22:27,980 --> 00:22:31,970
that was similar and I think this one's

563
00:22:29,390 --> 00:22:34,490
a little intuitively easier this is also

564
00:22:31,970 --> 00:22:37,010
in an optimized dictionary class but

565
00:22:34,490 --> 00:22:39,110
this one it would to serialize an array

566
00:22:37,010 --> 00:22:40,850
it would to serialize the array length

567
00:22:39,110 --> 00:22:42,168
and then it would do stuff and then it

568
00:22:40,850 --> 00:22:43,969
would check that the length was correct

569
00:22:42,169 --> 00:22:46,520
and you had this problem because of

570
00:22:43,970 --> 00:22:48,200
cycles you could cycle back and use this

571
00:22:46,520 --> 00:22:49,610
object before it was complete so there

572
00:22:48,200 --> 00:22:51,799
was actually no guarantee that that

573
00:22:49,610 --> 00:22:56,899
length was correct and that ended up

574
00:22:51,799 --> 00:22:58,370
being an out of bounds right so um those

575
00:22:56,900 --> 00:23:00,110
were all the bugs we found so I'm gonna

576
00:22:58,370 --> 00:23:01,939
end off by talking about you know why

577
00:23:00,110 --> 00:23:05,479
were there so many bugs here and the

578
00:23:01,940 --> 00:23:08,240
reality here was that the serialization

579
00:23:05,480 --> 00:23:10,040
presented a huge attack surface and the

580
00:23:08,240 --> 00:23:12,080
subclass thing and library behavior made

581
00:23:10,040 --> 00:23:13,970
it worse the problem is every time you

582
00:23:12,080 --> 00:23:16,639
included a library all this

583
00:23:13,970 --> 00:23:18,080
deserialization code got included even

584
00:23:16,640 --> 00:23:20,240
if that wasn't intended by the developer

585
00:23:18,080 --> 00:23:22,370
that wrote the library and even if

586
00:23:20,240 --> 00:23:23,900
you're using that library for something

587
00:23:22,370 --> 00:23:25,219
that is completely different even if

588
00:23:23,900 --> 00:23:28,370
you're like never even using that

589
00:23:25,220 --> 00:23:30,020
de-serialize class in the library I'm

590
00:23:28,370 --> 00:23:34,580
happy to say that this has been improved

591
00:23:30,020 --> 00:23:36,889
in iOS 13 now deserialization doesn't

592
00:23:34,580 --> 00:23:38,899
allow sub classing now if you just

593
00:23:36,890 --> 00:23:40,940
utilize an array it will just call the

594
00:23:38,900 --> 00:23:42,890
array I menace and it was coder

595
00:23:40,940 --> 00:23:45,410
I think that's great I think that would

596
00:23:42,890 --> 00:23:49,669
have prevented every bug but one we

597
00:23:45,410 --> 00:23:53,110
found in this research so that's it

598
00:23:49,669 --> 00:23:55,669
in conclusion fully remote bugs exist

599
00:23:53,110 --> 00:23:58,040
we've reported ten bugs total and

600
00:23:55,669 --> 00:24:01,100
iMessage and I think I found about four

601
00:23:58,040 --> 00:24:03,799
and other messengers at this point most

602
00:24:01,100 --> 00:24:05,750
remote bugs existed in native code but

603
00:24:03,799 --> 00:24:08,059
I'm every so often there was a great

604
00:24:05,750 --> 00:24:10,730
logic bug so don't ignore that Avenue

605
00:24:08,059 --> 00:24:13,460
either I found the design problems with

606
00:24:10,730 --> 00:24:15,710
I messaged me and serialization made

607
00:24:13,460 --> 00:24:16,880
this especially bug prone surface so I

608
00:24:15,710 --> 00:24:19,429
think there is a lesson to be learned

609
00:24:16,880 --> 00:24:21,559
here as well in how to design a mat

610
00:24:19,429 --> 00:24:23,990
messenger because definitely there's a

611
00:24:21,559 --> 00:24:25,879
big gap in my opinion between the ones

612
00:24:23,990 --> 00:24:27,590
that are easiest to find bugs in and the

613
00:24:25,880 --> 00:24:29,700
ones that are hardest to find bugs in

614
00:24:27,590 --> 00:24:31,590
and finally we

615
00:24:29,700 --> 00:24:34,590
some tools for this research on this

616
00:24:31,590 --> 00:24:36,000
talk one is the iOS messaging tool these

617
00:24:34,590 --> 00:24:38,970
are the ones that will send and receive

618
00:24:36,000 --> 00:24:41,970
eye messages and then there's also these

619
00:24:38,970 --> 00:24:43,860
video conferencing tools below which can

620
00:24:41,970 --> 00:24:46,460
also be helpful for finding bugs that

621
00:24:43,860 --> 00:24:48,779
logic bugs might be able to make remote

622
00:24:46,460 --> 00:24:50,639
so that's it thanks a lot

623
00:24:48,779 --> 00:24:53,429
I don't think we have any time for

624
00:24:50,639 --> 00:24:55,168
questions but stay tuned for Samuels

625
00:24:53,429 --> 00:24:58,340
talk about how to exploit these bugs

626
00:24:55,169 --> 00:24:58,340
thanks a lot

