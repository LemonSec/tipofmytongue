1
00:00:00,030 --> 00:00:04,620
hello and welcome to my talk on

2
00:00:02,220 --> 00:00:07,529
emulating hypervisors my name is IRA

3
00:00:04,620 --> 00:00:13,860
steely Starla's and just like everybody

4
00:00:07,529 --> 00:00:16,139
else you can call me Aris first of all

5
00:00:13,860 --> 00:00:21,119
the few words about me I'm an electrical

6
00:00:16,139 --> 00:00:24,210
and computer engineer I used to study

7
00:00:21,119 --> 00:00:26,820
robots academically three years ago I

8
00:00:24,210 --> 00:00:32,579
made a transition into security research

9
00:00:26,820 --> 00:00:34,829
and since then I work for sensors I'm

10
00:00:32,579 --> 00:00:37,050
mainly interested in vulnerability

11
00:00:34,829 --> 00:00:40,710
research exploit development reverse

12
00:00:37,050 --> 00:00:42,629
engineering and so on in my early steps

13
00:00:40,710 --> 00:00:46,550
I used to break virtualization software

14
00:00:42,629 --> 00:00:50,280
and now I'm mostly fighting Androids

15
00:00:46,550 --> 00:00:52,468
so this is the main agenda of the talk

16
00:00:50,280 --> 00:00:56,430
we're gonna start with some introductory

17
00:00:52,469 --> 00:00:58,739
stuff about low-level arm and

18
00:00:56,430 --> 00:01:00,930
virtualization extensions and then

19
00:00:58,739 --> 00:01:04,110
proceed with our proposed solution and

20
00:01:00,930 --> 00:01:06,780
analysis of the target system before

21
00:01:04,110 --> 00:01:12,170
continuing with discussing fuzzing

22
00:01:06,780 --> 00:01:14,670
implementations so until the recently

23
00:01:12,170 --> 00:01:16,560
kernel used to be the last line of

24
00:01:14,670 --> 00:01:18,299
defense against a full system

25
00:01:16,560 --> 00:01:19,650
compromised of course that's not true

26
00:01:18,299 --> 00:01:23,060
anymore since there are various

27
00:01:19,650 --> 00:01:25,950
mitigations that have been introduced

28
00:01:23,060 --> 00:01:29,390
hypervisors have been utilized as well

29
00:01:25,950 --> 00:01:32,540
despite their traditional use for

30
00:01:29,390 --> 00:01:35,759
virtualization in the Android ecosystem

31
00:01:32,540 --> 00:01:38,970
this has been facilitated mainly by arm

32
00:01:35,759 --> 00:01:41,670
virtualization extensions and then they

33
00:01:38,970 --> 00:01:47,280
very main scope is to protect the kernel

34
00:01:41,670 --> 00:01:49,560
during runtime that being said debugging

35
00:01:47,280 --> 00:01:52,939
Android is a major pain in the ass as

36
00:01:49,560 --> 00:01:55,320
most of you might know there are endless

37
00:01:52,939 --> 00:01:59,789
customizations from various vendors and

38
00:01:55,320 --> 00:02:03,508
amps lack of public source in many

39
00:01:59,790 --> 00:02:06,090
aspects lack of public tools the

40
00:02:03,509 --> 00:02:11,430
debugging interfaces however that means

41
00:02:06,090 --> 00:02:13,740
that proper debugging system framework

42
00:02:11,430 --> 00:02:15,050
is critical and it's

43
00:02:13,740 --> 00:02:19,040
usually one of the most time-consuming

44
00:02:15,050 --> 00:02:22,470
tasks of researchers and significantly

45
00:02:19,040 --> 00:02:25,829
significantly improves the quality of

46
00:02:22,470 --> 00:02:30,359
work the exploit development and of

47
00:02:25,830 --> 00:02:34,830
course vulnerability research so as

48
00:02:30,360 --> 00:02:39,150
Jonathan previously said what most

49
00:02:34,830 --> 00:02:42,660
researchers end up doing is emulating

50
00:02:39,150 --> 00:02:45,420
targeted components under qmo which

51
00:02:42,660 --> 00:02:48,590
allows us full control over the targeted

52
00:02:45,420 --> 00:02:52,619
the emulated system of course

53
00:02:48,590 --> 00:02:54,300
observability including debugging so in

54
00:02:52,620 --> 00:02:57,540
this presentation we're going to talk

55
00:02:54,300 --> 00:02:59,760
about low-level arm concepts and

56
00:02:57,540 --> 00:03:01,380
virtualization extensions and we're

57
00:02:59,760 --> 00:03:03,420
going to demonstrate its concept

58
00:03:01,380 --> 00:03:06,840
introduced with a framework I

59
00:03:03,420 --> 00:03:10,649
implemented to bootstrap and interact

60
00:03:06,840 --> 00:03:13,050
with Samsung hypervisor called rkp under

61
00:03:10,650 --> 00:03:15,570
this set up we're gonna then investigate

62
00:03:13,050 --> 00:03:17,940
fuzzing setups and hopefully this will

63
00:03:15,570 --> 00:03:22,010
allow you to understand the under

64
00:03:17,940 --> 00:03:26,880
examination system for you to build

65
00:03:22,010 --> 00:03:29,480
frameworks for your own systems so first

66
00:03:26,880 --> 00:03:31,950
thing first some things about arm

67
00:03:29,480 --> 00:03:33,980
introductory stuff there are two

68
00:03:31,950 --> 00:03:38,640
security States secure and non-secure

69
00:03:33,980 --> 00:03:41,010
also refer refer to as worlds for

70
00:03:38,640 --> 00:03:44,570
extension levels also called execution

71
00:03:41,010 --> 00:03:47,970
levels the higher the execution level

72
00:03:44,570 --> 00:03:50,630
number the higher the privilege so l0 is

73
00:03:47,970 --> 00:03:53,400
the least privileged and is the userland

74
00:03:50,630 --> 00:03:58,609
l3 is the most privileged and it's

75
00:03:53,400 --> 00:04:02,540
called secure monitor to move between

76
00:03:58,610 --> 00:04:05,280
execution levels we take interrupts

77
00:04:02,540 --> 00:04:08,630
exceptions or a term from them yield

78
00:04:05,280 --> 00:04:12,870
zero to go to l1 have a supervisor call

79
00:04:08,630 --> 00:04:16,920
SVC instruction l1 to l2 hypervisor call

80
00:04:12,870 --> 00:04:20,010
hvc l1 real to to go to l3 we got a

81
00:04:16,920 --> 00:04:22,830
secure monitor call SMC and we drop to

82
00:04:20,010 --> 00:04:26,070
lower levels with exception return

83
00:04:22,830 --> 00:04:27,300
instruction irit we're gonna be

84
00:04:26,070 --> 00:04:35,099
targeting normal

85
00:04:27,300 --> 00:04:39,629
world l2 in this talk and what's l2 it's

86
00:04:35,099 --> 00:04:41,819
a hypervisor and its main its main thing

87
00:04:39,629 --> 00:04:44,340
is to dictate you know one behavior and

88
00:04:41,819 --> 00:04:47,280
control it we have mainly two things

89
00:04:44,340 --> 00:04:49,258
happening first of all a behavior

90
00:04:47,280 --> 00:04:51,960
controlled by hypervisor configuration

91
00:04:49,259 --> 00:04:54,599
register which dictates the way ill one

92
00:04:51,960 --> 00:04:58,560
interacts with the system for example we

93
00:04:54,599 --> 00:05:02,250
have the ability to drop access to

94
00:04:58,560 --> 00:05:04,289
system registers to l2 so l1 trash-talks

95
00:05:02,250 --> 00:05:08,520
system register for example to disable

96
00:05:04,289 --> 00:05:11,460
the MMU the are the access is dropped to

97
00:05:08,520 --> 00:05:14,190
l2 and he decides whether the action is

98
00:05:11,460 --> 00:05:17,580
supposed to happen or not and different

99
00:05:14,190 --> 00:05:20,849
parameters of it and then we have states

100
00:05:17,580 --> 00:05:22,650
- translation which breaks the

101
00:05:20,849 --> 00:05:25,979
traditional translation of virtual

102
00:05:22,650 --> 00:05:29,310
addresses without States to its virtual

103
00:05:25,979 --> 00:05:32,460
address is translated by an MMU to the

104
00:05:29,310 --> 00:05:34,740
corresponding physical address and with

105
00:05:32,460 --> 00:05:35,580
stage 2 we have an additional step as we

106
00:05:34,740 --> 00:05:38,819
going to see next

107
00:05:35,580 --> 00:05:40,529
so from left to right we have the

108
00:05:38,819 --> 00:05:42,900
virtual address space of e l1 which is

109
00:05:40,529 --> 00:05:47,159
translated through stage one translation

110
00:05:42,900 --> 00:05:49,469
tables and this is now an intermediate

111
00:05:47,159 --> 00:05:51,630
physical address and this is what the

112
00:05:49,469 --> 00:05:54,120
operating system thinks is the actual

113
00:05:51,630 --> 00:05:57,090
physical address but to retrieve the arc

114
00:05:54,120 --> 00:05:59,250
so that physical address we go through

115
00:05:57,090 --> 00:06:01,198
stage two tables which are not

116
00:05:59,250 --> 00:06:03,180
accessible by l1 they are only

117
00:06:01,199 --> 00:06:08,879
accessible by l2 and of course he'll

118
00:06:03,180 --> 00:06:11,279
three and more importantly a stage two

119
00:06:08,879 --> 00:06:15,289
tables and table entries have their own

120
00:06:11,279 --> 00:06:18,840
memory attributes which ultimately

121
00:06:15,289 --> 00:06:20,940
define the memory translation process

122
00:06:18,840 --> 00:06:24,029
for example if a virtual address is

123
00:06:20,940 --> 00:06:27,569
defined as executable in stage 1 tables

124
00:06:24,029 --> 00:06:30,599
and not executable at stage 2 tables

125
00:06:27,569 --> 00:06:35,419
then trying to execute from that virtual

126
00:06:30,599 --> 00:06:39,449
address results in a translation error

127
00:06:35,419 --> 00:06:40,659
the Samsung has implemented a security

128
00:06:39,449 --> 00:06:41,920
platform we

129
00:06:40,660 --> 00:06:44,230
most of you might know it's called

130
00:06:41,920 --> 00:06:46,300
Samsung Knox as part of this

131
00:06:44,230 --> 00:06:49,090
implementation they have a hypervisor a

132
00:06:46,300 --> 00:06:52,510
proprietary hypervisor called runtime

133
00:06:49,090 --> 00:06:54,609
kernel protection rkp rkp has been

134
00:06:52,510 --> 00:06:58,690
targeting before there are various

135
00:06:54,610 --> 00:07:01,630
examples the most notable one is target

136
00:06:58,690 --> 00:07:04,780
is by project zero that targeted Samsung

137
00:07:01,630 --> 00:07:07,450
Galaxy s7 r KP implementation in this

138
00:07:04,780 --> 00:07:09,309
talk we will be focusing on Si it not

139
00:07:07,450 --> 00:07:12,330
eight implementation which sir some

140
00:07:09,310 --> 00:07:15,130
architecture similarities with s7 one

141
00:07:12,330 --> 00:07:17,500
it's newer with more additions and

142
00:07:15,130 --> 00:07:20,500
complexity moreover it's been stripped

143
00:07:17,500 --> 00:07:24,220
and six strings are obfuscated making a

144
00:07:20,500 --> 00:07:26,770
reversing process more difficult and one

145
00:07:24,220 --> 00:07:29,440
of the main reasons we chose this is

146
00:07:26,770 --> 00:07:31,359
that it's simple with respect to

147
00:07:29,440 --> 00:07:34,120
secondary functionalities and features

148
00:07:31,360 --> 00:07:36,700
so it is a good target for educational

149
00:07:34,120 --> 00:07:42,700
purposes but in the end of the day it

150
00:07:36,700 --> 00:07:43,930
was an arbitrary selection so now let's

151
00:07:42,700 --> 00:07:45,700
move on with the framework

152
00:07:43,930 --> 00:07:47,250
implementation and the analysis of the

153
00:07:45,700 --> 00:07:51,460
target system

154
00:07:47,250 --> 00:07:56,140
we will be implementing minimal

155
00:07:51,460 --> 00:07:59,650
framework focusing components for l3 and

156
00:07:56,140 --> 00:08:04,719
l1 to allow to bootstrap and interact

157
00:07:59,650 --> 00:08:10,390
with l2 our framework is operated in an

158
00:08:04,720 --> 00:08:12,250
elf 64 bit image and since qmo allows us

159
00:08:10,390 --> 00:08:16,300
to boot directly from elf images

160
00:08:12,250 --> 00:08:18,370
simplifying our boot process our

161
00:08:16,300 --> 00:08:20,710
studying starting physical address is

162
00:08:18,370 --> 00:08:21,940
hex 80 million which is of great

163
00:08:20,710 --> 00:08:23,770
importance and we're going to discuss

164
00:08:21,940 --> 00:08:25,270
later why and then we have our

165
00:08:23,770 --> 00:08:27,159
configuration

166
00:08:25,270 --> 00:08:31,930
which as you can see we use the virtual

167
00:08:27,160 --> 00:08:34,240
platform core cortex a15 a57 cpu a

168
00:08:31,930 --> 00:08:38,020
single core with a single thread three

169
00:08:34,240 --> 00:08:40,630
gigabytes of ram and of course your free

170
00:08:38,020 --> 00:08:45,490
annual to enable and we attach to gdb

171
00:08:40,630 --> 00:08:47,560
this how this is the actual command on

172
00:08:45,490 --> 00:08:49,480
the left on the right where that's the

173
00:08:47,560 --> 00:08:52,709
gdb and we are now ready to start

174
00:08:49,480 --> 00:08:55,329
implementing our framework

175
00:08:52,709 --> 00:08:57,219
this high-level approach of what we want

176
00:08:55,329 --> 00:08:58,959
to do we want to start a deal 3 and

177
00:08:57,220 --> 00:09:01,329
define our system state then we wanna

178
00:08:58,959 --> 00:09:04,479
drop to l1 and define its own state with

179
00:09:01,329 --> 00:09:07,180
M mu etc and then move move on to l2

180
00:09:04,480 --> 00:09:10,779
this approach is not the only approach

181
00:09:07,180 --> 00:09:13,630
we could do things for example we could

182
00:09:10,779 --> 00:09:14,560
drop from male 3 to l2 and then move on

183
00:09:13,630 --> 00:09:16,930
to l1

184
00:09:14,560 --> 00:09:20,138
this is dictated from the targeted

185
00:09:16,930 --> 00:09:23,620
architecture and there are differences

186
00:09:20,139 --> 00:09:25,360
for example if we have no dependencies

187
00:09:23,620 --> 00:09:28,149
from real one in the bootstrap process

188
00:09:25,360 --> 00:09:30,279
then we can say if we go to l2 directly

189
00:09:28,149 --> 00:09:32,980
from ill 3 and then drop to l1 if we had

190
00:09:30,279 --> 00:09:35,850
different dependencies though then of

191
00:09:32,980 --> 00:09:38,980
course we have to enable the l1 first

192
00:09:35,850 --> 00:09:41,920
we're gonna see how this is gonna go for

193
00:09:38,980 --> 00:09:45,339
us so system boots so what we're gonna

194
00:09:41,920 --> 00:09:47,620
do first in first some simple stuff we

195
00:09:45,339 --> 00:09:49,269
define the stack pointer so we can have

196
00:09:47,620 --> 00:09:52,180
local variables and invoke functions

197
00:09:49,269 --> 00:09:55,480
properly and then we have to set the

198
00:09:52,180 --> 00:09:58,660
exception vectors there format is seen

199
00:09:55,480 --> 00:10:03,189
in the image next there are 16 entries

200
00:09:58,660 --> 00:10:06,250
of hex 80 bytes each they are organized

201
00:10:03,189 --> 00:10:09,509
in four groups of four each group is

202
00:10:06,250 --> 00:10:12,459
used for a different execution level and

203
00:10:09,509 --> 00:10:14,290
we have one entry for synchronous

204
00:10:12,459 --> 00:10:16,000
exemption one for interrupts want to

205
00:10:14,290 --> 00:10:18,910
fast interrupts and one phone system

206
00:10:16,000 --> 00:10:22,509
errors rkb does not support support

207
00:10:18,910 --> 00:10:29,319
interrupts or fast interrupts so we

208
00:10:22,509 --> 00:10:33,040
won't we won't be enabling them we won't

209
00:10:29,319 --> 00:10:37,060
be implementing userland applications

210
00:10:33,040 --> 00:10:40,120
from no yield zero as a result l1 and

211
00:10:37,060 --> 00:10:43,000
entries are empty empty actually they

212
00:10:40,120 --> 00:10:45,339
lead to infinite loops and for real

213
00:10:43,000 --> 00:10:48,220
three we are only gonna be supporting

214
00:10:45,339 --> 00:10:54,370
synchronous exceptions from lower 64-bit

215
00:10:48,220 --> 00:10:57,399
States which is entry hex for 400 after

216
00:10:54,370 --> 00:11:01,689
that has been said we define the system

217
00:10:57,399 --> 00:11:04,000
state and some system registers we will

218
00:11:01,689 --> 00:11:06,430
be focusing on Neil 3 and you'll want to

219
00:11:04,000 --> 00:11:08,260
allow rkp to define its own state

220
00:11:06,430 --> 00:11:11,380
properly well almost as we're going to

221
00:11:08,260 --> 00:11:14,020
see next so what we have to do we boot

222
00:11:11,380 --> 00:11:16,149
reset ill three we have to set the

223
00:11:14,020 --> 00:11:18,250
secure configuration register to define

224
00:11:16,149 --> 00:11:22,089
the world we are executing in so we set

225
00:11:18,250 --> 00:11:26,500
a normal world define it to state as a

226
00:11:22,089 --> 00:11:30,520
64-bit l2 in the same system register

227
00:11:26,500 --> 00:11:34,899
and we have to define l1 state in the

228
00:11:30,520 --> 00:11:37,180
hypervisor configuration register these

229
00:11:34,899 --> 00:11:40,540
values are required along with some

230
00:11:37,180 --> 00:11:41,920
reserved bits and if we fail to set them

231
00:11:40,540 --> 00:11:44,110
properly at least in the queue

232
00:11:41,920 --> 00:11:48,880
environment we cannot drop to lower

233
00:11:44,110 --> 00:11:50,740
execution levels as we gonna see next so

234
00:11:48,880 --> 00:11:53,380
how do we drop the lower execution

235
00:11:50,740 --> 00:11:55,270
levels we can only drop by returning

236
00:11:53,380 --> 00:11:56,920
from exception since we are at reset

237
00:11:55,270 --> 00:11:58,990
there is no exception the letters there

238
00:11:56,920 --> 00:12:00,760
so we create a fake exception to return

239
00:11:58,990 --> 00:12:03,010
to and how do we do that there are three

240
00:12:00,760 --> 00:12:05,140
registers which are related to

241
00:12:03,010 --> 00:12:08,380
exceptions first we have the exception

242
00:12:05,140 --> 00:12:10,600
link register and this holds the return

243
00:12:08,380 --> 00:12:14,279
address after the exception has been

244
00:12:10,600 --> 00:12:19,570
handled saved process status register

245
00:12:14,279 --> 00:12:22,240
holds P state which is the state we were

246
00:12:19,570 --> 00:12:26,589
executing when the exception happened

247
00:12:22,240 --> 00:12:28,540
and we said that at 64-bit l1 exception

248
00:12:26,589 --> 00:12:30,100
syndrome register holds information

249
00:12:28,540 --> 00:12:32,620
about the exception itself and as a

250
00:12:30,100 --> 00:12:34,570
result for returning is irrelevant so

251
00:12:32,620 --> 00:12:37,000
after setting these values and executing

252
00:12:34,570 --> 00:12:42,190
instruction E right we are now executing

253
00:12:37,000 --> 00:12:48,010
at l1 at function for example start l1

254
00:12:42,190 --> 00:12:50,290
in this layout so we are now we have set

255
00:12:48,010 --> 00:12:51,839
our ill three parameters and we are now

256
00:12:50,290 --> 00:12:56,829
ready to start implementing and

257
00:12:51,839 --> 00:12:58,570
initializing l1 disclaimer our setup is

258
00:12:56,829 --> 00:13:01,930
not identical to the Samsung Linux

259
00:12:58,570 --> 00:13:04,329
kernel is it's minimal in comparison and

260
00:13:01,930 --> 00:13:07,779
we focus on bootstrapping and

261
00:13:04,329 --> 00:13:11,099
interacting with our K P that being said

262
00:13:07,779 --> 00:13:14,050
we have to stay as close as possible

263
00:13:11,100 --> 00:13:17,740
with respect to various parameters to

264
00:13:14,050 --> 00:13:19,729
the original kernel for two main reasons

265
00:13:17,740 --> 00:13:23,420
first of all

266
00:13:19,730 --> 00:13:25,730
the nature of this implementation in the

267
00:13:23,420 --> 00:13:28,490
nature of l2 as a protector for the

268
00:13:25,730 --> 00:13:30,680
kernel l2 makes various assumptions and

269
00:13:28,490 --> 00:13:34,160
our type and is tightly coupled with the

270
00:13:30,680 --> 00:13:38,060
kernel so we must satisfy each of these

271
00:13:34,160 --> 00:13:42,199
dependencies for our setup to be correct

272
00:13:38,060 --> 00:13:44,449
and even if the target ETL to had some

273
00:13:42,200 --> 00:13:47,810
flexibility regarding the supported

274
00:13:44,450 --> 00:13:50,149
systems we must ensure that we are as

275
00:13:47,810 --> 00:13:53,839
close as possible to the under

276
00:13:50,149 --> 00:13:55,790
examination system to make sure to

277
00:13:53,839 --> 00:14:01,670
ensure that we have proper interaction

278
00:13:55,790 --> 00:14:04,130
and we study the proper behavior so

279
00:14:01,670 --> 00:14:06,439
system registers for real one we

280
00:14:04,130 --> 00:14:08,720
extracted there's there values from

281
00:14:06,440 --> 00:14:11,839
source and the virus Oracle's that are

282
00:14:08,720 --> 00:14:13,550
going to be introduced later for now we

283
00:14:11,839 --> 00:14:16,910
can assume that these are arbitrarily

284
00:14:13,550 --> 00:14:21,920
chosen and one of the most important

285
00:14:16,910 --> 00:14:25,130
ones are TCR l1 which defines the memory

286
00:14:21,920 --> 00:14:27,829
management setup we specify a 4 kilobyte

287
00:14:25,130 --> 00:14:33,260
page size or granule sizes is the

288
00:14:27,829 --> 00:14:37,279
terminology 50 to 512 gigabytes or 13i

289
00:14:33,260 --> 00:14:39,230
bit input virtual address reason and one

290
00:14:37,279 --> 00:14:41,149
terabyte intermediate physical address

291
00:14:39,230 --> 00:14:43,250
so what this layout means is first of

292
00:14:41,149 --> 00:14:47,420
all we have four kilobyte page size of

293
00:14:43,250 --> 00:14:49,820
512 entries per page and the 39 bit

294
00:14:47,420 --> 00:14:52,610
input virtual address region region

295
00:14:49,820 --> 00:14:55,459
means that we do not require a level 0

296
00:14:52,610 --> 00:14:57,019
table as we go and seen next so this how

297
00:14:55,459 --> 00:15:00,529
translations work we're going to go

298
00:14:57,019 --> 00:15:05,630
backwards level 3 is the last table and

299
00:15:00,529 --> 00:15:08,720
its entry here points to can map to a 4

300
00:15:05,630 --> 00:15:11,449
kilobyte page of course since we have

301
00:15:08,720 --> 00:15:14,000
512 entries we can map a 2 megabyte

302
00:15:11,449 --> 00:15:16,219
region each entry is indexed as we can

303
00:15:14,000 --> 00:15:18,579
as we see from the image below from bit

304
00:15:16,220 --> 00:15:24,380
from bits or address bits

305
00:15:18,579 --> 00:15:27,140
22:12 it's level 2 table its entry index

306
00:15:24,380 --> 00:15:30,439
by bits 29 to 21

307
00:15:27,140 --> 00:15:33,410
can either point to a level 3 table or

308
00:15:30,440 --> 00:15:38,120
to a 2 megabyte region effectively and

309
00:15:33,410 --> 00:15:42,259
during the translation process and how

310
00:15:38,120 --> 00:15:44,600
are these distinguished the entry type

311
00:15:42,259 --> 00:15:48,649
is in the least significant bits of the

312
00:15:44,600 --> 00:15:51,529
entry block descriptors and paste

313
00:15:48,649 --> 00:15:54,800
descriptors are more or less the same

314
00:15:51,529 --> 00:15:57,129
however paste descriptors are only found

315
00:15:54,800 --> 00:16:01,758
in the level 3 table

316
00:15:57,129 --> 00:16:04,910
so moving on level 1 table index by bits

317
00:16:01,759 --> 00:16:07,610
38 to 30 other points to level 2 table

318
00:16:04,910 --> 00:16:09,680
or one gigabyte region ending

319
00:16:07,610 --> 00:16:13,279
translation as well so with a level 1

320
00:16:09,680 --> 00:16:17,589
table we can map 512 gigabyte region and

321
00:16:13,279 --> 00:16:20,779
that's why we don't need a level 0 table

322
00:16:17,589 --> 00:16:22,970
so for our one implementation we're

323
00:16:20,779 --> 00:16:25,579
gonna be enabling the MMU there are two

324
00:16:22,970 --> 00:16:29,449
page tables we have one identity mapping

325
00:16:25,579 --> 00:16:30,888
for low virtual addresses TTB are 0

326
00:16:29,449 --> 00:16:32,839
where virtual address is equal to

327
00:16:30,889 --> 00:16:34,879
physical addresses and then we have the

328
00:16:32,839 --> 00:16:37,220
high virtual addresses for tea TBR 1

329
00:16:34,879 --> 00:16:41,360
where the virtual address equals the

330
00:16:37,220 --> 00:16:44,660
physical address last I have a pre fixed

331
00:16:41,360 --> 00:16:47,209
offset which you can see here and we

332
00:16:44,660 --> 00:16:49,399
will be mapping our framework in with

333
00:16:47,209 --> 00:16:51,859
level 2 block entries or 2 megabyte

334
00:16:49,399 --> 00:16:54,769
increments so let's see how this world

335
00:16:51,860 --> 00:16:58,250
works we have created the page tables we

336
00:16:54,769 --> 00:16:59,870
have not yet enabled the MMU and this is

337
00:16:58,250 --> 00:17:02,720
the virtual address that we want to

338
00:16:59,870 --> 00:17:04,520
translate this is the this should be

339
00:17:02,720 --> 00:17:08,919
this should lead us to the reset

340
00:17:04,520 --> 00:17:14,150
function so we get the level 1 entry

341
00:17:08,919 --> 00:17:17,419
index which is 2 and the entry for the

342
00:17:14,150 --> 00:17:19,490
end the second entry for tea TBR one is

343
00:17:17,419 --> 00:17:21,439
the one you see here from the least

344
00:17:19,490 --> 00:17:25,039
significant bit we can see that it is a

345
00:17:21,439 --> 00:17:29,090
valid page descriptor sorry table

346
00:17:25,039 --> 00:17:32,120
descriptor so it leads to level 2 we

347
00:17:29,090 --> 00:17:35,780
extract the index for level 2 from the

348
00:17:32,120 --> 00:17:37,610
virtual address and read the entry from

349
00:17:35,780 --> 00:17:42,830
the second-level table which is now a

350
00:17:37,610 --> 00:17:46,309
valid block descriptor so this means the

351
00:17:42,830 --> 00:17:47,210
page translations finished and using the

352
00:17:46,309 --> 00:17:49,820
remaining bits from

353
00:17:47,210 --> 00:17:51,380
the virtual address and examining the

354
00:17:49,820 --> 00:17:53,870
resulting memory we can see of course

355
00:17:51,380 --> 00:17:58,340
that we are in reset function so that's

356
00:17:53,870 --> 00:18:01,279
how translation works so we have enabled

357
00:17:58,340 --> 00:18:04,490
our MMU and Setiawan parameters so we

358
00:18:01,279 --> 00:18:08,840
are now ready to bootstrap the

359
00:18:04,490 --> 00:18:11,330
hypervisor the hypervisor in a framework

360
00:18:08,840 --> 00:18:13,428
is incorporated in the framework image

361
00:18:11,330 --> 00:18:16,850
so it must be placed in its expected

362
00:18:13,429 --> 00:18:19,909
physical address our KP is an elf file

363
00:18:16,850 --> 00:18:22,870
so we can easily figure out the physical

364
00:18:19,909 --> 00:18:26,840
address by reading the elf header since

365
00:18:22,870 --> 00:18:29,719
HPC knows is not available yet rkp has

366
00:18:26,840 --> 00:18:32,539
not been initialized we cannot invoke

367
00:18:29,720 --> 00:18:35,210
HVC directly so what we do is we go

368
00:18:32,539 --> 00:18:37,990
Tweel 3 and drop to l2 similar in a

369
00:18:35,210 --> 00:18:42,110
similar fashion as we did for ul 1 and

370
00:18:37,990 --> 00:18:44,270
to define the like exception we have the

371
00:18:42,110 --> 00:18:46,010
exception syndrome register and we set

372
00:18:44,270 --> 00:18:49,940
there the elf entry point which is also

373
00:18:46,010 --> 00:18:52,480
available to us by the elf header saved

374
00:18:49,940 --> 00:18:57,470
process status register we specify

375
00:18:52,480 --> 00:19:02,539
64-bit il to state and as before ESR is

376
00:18:57,470 --> 00:19:04,309
irrelevant so returning performing Irit

377
00:19:02,539 --> 00:19:07,840
instruction we are now executing the L

378
00:19:04,309 --> 00:19:10,760
the entry point for our KP in the L 2

379
00:19:07,840 --> 00:19:14,600
the entry point eventually leads to vm m

380
00:19:10,760 --> 00:19:16,100
main we can see an edited snippet here

381
00:19:14,600 --> 00:19:19,879
and we're going to discuss the various

382
00:19:16,100 --> 00:19:22,250
steps next so memory need is the first

383
00:19:19,880 --> 00:19:24,919
function of interest it initializes a

384
00:19:22,250 --> 00:19:27,350
buffer which is the first Oracle it is

385
00:19:24,919 --> 00:19:30,830
available to us by a proc of a sentry

386
00:19:27,350 --> 00:19:34,719
rkp log and we can see from the snippet

387
00:19:30,830 --> 00:19:38,178
that we have various memory regions

388
00:19:34,720 --> 00:19:41,330
which allow us to verify that our

389
00:19:38,179 --> 00:19:44,570
configuration is correct and our process

390
00:19:41,330 --> 00:19:45,408
of bootstrapping is indeed similar to

391
00:19:44,570 --> 00:19:51,260
the original one

392
00:19:45,409 --> 00:19:54,649
next we move to vm m in it now there the

393
00:19:51,260 --> 00:19:58,850
vectors are set so we can now invoke hvc

394
00:19:54,649 --> 00:20:00,800
from l1 however we may we have to first

395
00:19:58,850 --> 00:20:03,980
enable the actual command from the sea

396
00:20:00,800 --> 00:20:06,260
configuration register and finally VM I

397
00:20:03,980 --> 00:20:10,820
mean it sets hypervisor configuration

398
00:20:06,260 --> 00:20:13,160
values for example l1 writes to l1

399
00:20:10,820 --> 00:20:16,280
system registers are trapped to l2 for

400
00:20:13,160 --> 00:20:22,100
example our KP does not allow l1 to

401
00:20:16,280 --> 00:20:24,620
disable its own MMU next we have s1

402
00:20:22,100 --> 00:20:27,350
enable and ness to enable as one is

403
00:20:24,620 --> 00:20:30,169
stage one translation for l2 we're not

404
00:20:27,350 --> 00:20:33,110
going to be focusing on that one stage

405
00:20:30,170 --> 00:20:35,630
two is really important for us the page

406
00:20:33,110 --> 00:20:38,629
tables are statically defined and the

407
00:20:35,630 --> 00:20:42,020
configuration for stage 2 is a 4

408
00:20:38,630 --> 00:20:45,890
kilobyte granule size and a 40 bit input

409
00:20:42,020 --> 00:20:48,350
virtual address and we also start at

410
00:20:45,890 --> 00:20:51,020
level 1 with concatenated tables and

411
00:20:48,350 --> 00:20:53,419
this is very important for our analysis

412
00:20:51,020 --> 00:20:55,250
and who understand how things work so in

413
00:20:53,420 --> 00:20:59,240
the traditional approach we have 40 bits

414
00:20:55,250 --> 00:21:03,350
now so we require level 0 table with two

415
00:20:59,240 --> 00:21:07,240
entries indexed by bit 39 value 0 or 1

416
00:21:03,350 --> 00:21:09,830
so we have two tables for level 1

417
00:21:07,240 --> 00:21:11,780
concatenated tables and are what allows

418
00:21:09,830 --> 00:21:14,090
us to do is to reduce the translation

419
00:21:11,780 --> 00:21:18,200
steps allows us to have two physical

420
00:21:14,090 --> 00:21:20,810
addresses to physical pages in

421
00:21:18,200 --> 00:21:25,100
contiguous memory which are indexed now

422
00:21:20,810 --> 00:21:27,169
by bits 32 39 so level 0 table is

423
00:21:25,100 --> 00:21:31,280
discarded and we now have a two page

424
00:21:27,170 --> 00:21:34,520
table level 1 of course this is allowed

425
00:21:31,280 --> 00:21:39,860
for up to 16 concatenated tables for

426
00:21:34,520 --> 00:21:42,110
example if we had a 41 bit input virtual

427
00:21:39,860 --> 00:21:44,719
address region then we would require 4

428
00:21:42,110 --> 00:21:48,229
tables which could be indexed by bits 30

429
00:21:44,720 --> 00:21:50,360
to 40 and based on some other tools

430
00:21:48,230 --> 00:21:53,900
which you can find on references we have

431
00:21:50,360 --> 00:21:59,959
built it to to dump the tables and their

432
00:21:53,900 --> 00:22:03,440
memory attributes so hypervisor has been

433
00:21:59,960 --> 00:22:08,590
bootstrap and terminates the bootstrap

434
00:22:03,440 --> 00:22:11,960
process our KP terminates by SMC and

435
00:22:08,590 --> 00:22:14,669
effect effectively going from mil to 12

436
00:22:11,960 --> 00:22:17,100
3 X 0 register which is the

437
00:22:14,670 --> 00:22:18,900
the argument holds a special value to

438
00:22:17,100 --> 00:22:21,050
let us know that it came from the

439
00:22:18,900 --> 00:22:24,650
bootstrap process and x1 the second

440
00:22:21,050 --> 00:22:27,690
argument has the initialization status

441
00:22:24,650 --> 00:22:29,550
since we perform an additional SMC we

442
00:22:27,690 --> 00:22:31,740
now have an additional exception frame

443
00:22:29,550 --> 00:22:33,690
so to continue from the previous state

444
00:22:31,740 --> 00:22:38,400
we have to restore the exception frames

445
00:22:33,690 --> 00:22:40,740
but since our framework is minimal we do

446
00:22:38,400 --> 00:22:43,040
not require to preserve any information

447
00:22:40,740 --> 00:22:47,070
so we can reset the state by dropping

448
00:22:43,040 --> 00:22:50,399
stack pointers and drop to a new l1

449
00:22:47,070 --> 00:22:56,040
function which in our setup is ill 1

450
00:22:50,400 --> 00:22:58,890
main so a really important thing here is

451
00:22:56,040 --> 00:23:00,930
of course the first introduced system

452
00:22:58,890 --> 00:23:03,210
constraint of the physical address that

453
00:23:00,930 --> 00:23:04,980
we have to place our frameworks in

454
00:23:03,210 --> 00:23:09,840
Statesville translation tables have been

455
00:23:04,980 --> 00:23:12,600
enabled it's virtual address after being

456
00:23:09,840 --> 00:23:15,030
translated in l1 by stage 1 tables is

457
00:23:12,600 --> 00:23:16,830
not an actual physical address but an

458
00:23:15,030 --> 00:23:19,230
intermediate physical address and as

459
00:23:16,830 --> 00:23:21,899
such it must be mapped in the stage 2

460
00:23:19,230 --> 00:23:24,780
translation tables or else we're going

461
00:23:21,900 --> 00:23:26,940
to have a translation fault examining

462
00:23:24,780 --> 00:23:30,750
the page tape the stage 2 tables you can

463
00:23:26,940 --> 00:23:36,350
see that hex 80 million is executable

464
00:23:30,750 --> 00:23:36,350
and that's where we place our framework

465
00:23:37,160 --> 00:23:43,860
so we are now ready to start discussing

466
00:23:40,290 --> 00:23:45,690
the initialization of our KP which is

467
00:23:43,860 --> 00:23:48,020
the second stage of the booster process

468
00:23:45,690 --> 00:23:53,700
but before that let's talk about how

469
00:23:48,020 --> 00:23:56,460
exceptions are handled all entries first

470
00:23:53,700 --> 00:24:00,660
create an exception frame and then lead

471
00:23:56,460 --> 00:24:01,260
to function V MMD spots with three

472
00:24:00,660 --> 00:24:04,770
arguments

473
00:24:01,260 --> 00:24:09,090
the first two are information about the

474
00:24:04,770 --> 00:24:11,610
exception in nature and the third is the

475
00:24:09,090 --> 00:24:14,159
exception frame the MMD spots only

476
00:24:11,610 --> 00:24:19,439
handle synchronous exceptions by design

477
00:24:14,160 --> 00:24:21,240
and returns otherwise vmm synchronous

478
00:24:19,440 --> 00:24:22,860
handler is the handler for the

479
00:24:21,240 --> 00:24:24,910
synchronous exceptions as the name

480
00:24:22,860 --> 00:24:27,310
suggests

481
00:24:24,910 --> 00:24:29,290
and what happens here is pretty simple

482
00:24:27,310 --> 00:24:31,570
we exact the reason for the exception

483
00:24:29,290 --> 00:24:36,180
which is encoded in the exception class

484
00:24:31,570 --> 00:24:39,790
field of exception syndrome register and

485
00:24:36,180 --> 00:24:44,020
ABC invocations which are switch cases

486
00:24:39,790 --> 00:24:48,010
12 and C X 12 and 16 are handled by

487
00:24:44,020 --> 00:24:50,410
function rkp main to reach our gaping

488
00:24:48,010 --> 00:24:53,530
main and the functions which case we

489
00:24:50,410 --> 00:24:54,940
must satisfy some requirements for the

490
00:24:53,530 --> 00:24:57,639
command which we're going to see next

491
00:24:54,940 --> 00:25:01,500
first of all the command is the first

492
00:24:57,640 --> 00:25:04,300
argument for HB c x0 and must have

493
00:25:01,500 --> 00:25:06,750
prefix and it's a value that you see

494
00:25:04,300 --> 00:25:10,899
here and this is checked before eating

495
00:25:06,750 --> 00:25:12,910
our KP main secondly in our KP main as

496
00:25:10,900 --> 00:25:18,610
you see next the command is shifted by

497
00:25:12,910 --> 00:25:22,120
12 and a byte is extracted so that byte

498
00:25:18,610 --> 00:25:25,330
is used as the index in the switch case

499
00:25:22,120 --> 00:25:26,860
so before it's in the switch case there

500
00:25:25,330 --> 00:25:28,980
is an additional function which we're

501
00:25:26,860 --> 00:25:31,179
going to examine here but before

502
00:25:28,980 --> 00:25:33,040
discussing the function let's see for

503
00:25:31,180 --> 00:25:37,030
example the second entry which is rkp

504
00:25:33,040 --> 00:25:40,840
definite with ID 1 so how do we fix the

505
00:25:37,030 --> 00:25:43,870
command for this ID we shift 1 by 12 so

506
00:25:40,840 --> 00:25:46,149
we got hex from 1000 and or with the

507
00:25:43,870 --> 00:25:48,429
prefix so you can see right next the

508
00:25:46,150 --> 00:25:52,810
command that is required to be next zero

509
00:25:48,430 --> 00:25:54,640
for us to reach our KP definite check a

510
00:25:52,810 --> 00:25:58,000
switch command function is our KP

511
00:25:54,640 --> 00:26:01,290
specific and we're going to discuss it

512
00:25:58,000 --> 00:26:03,340
because it brings an interesting

513
00:26:01,290 --> 00:26:07,330
requirement that we need to have in mind

514
00:26:03,340 --> 00:26:09,639
for similar implementations the command

515
00:26:07,330 --> 00:26:11,199
ad must be smaller than a specific

516
00:26:09,640 --> 00:26:14,980
counter that's okay

517
00:26:11,200 --> 00:26:17,230
and we have command counters which are

518
00:26:14,980 --> 00:26:19,690
checked some commands are not allowed to

519
00:26:17,230 --> 00:26:21,850
be executed more than counter times for

520
00:26:19,690 --> 00:26:24,700
example the initialization commands must

521
00:26:21,850 --> 00:26:29,050
only be called once if we somehow invoke

522
00:26:24,700 --> 00:26:30,970
them again then system crosses other

523
00:26:29,050 --> 00:26:34,540
commands for example the third and the

524
00:26:30,970 --> 00:26:36,940
fourth entry with counter minus 1 can be

525
00:26:34,540 --> 00:26:38,270
called arbitrarily amount of times of

526
00:26:36,940 --> 00:26:42,060
course

527
00:26:38,270 --> 00:26:43,730
so now we can interact with our capin

528
00:26:42,060 --> 00:26:46,560
let's see how we initialize the

529
00:26:43,730 --> 00:26:49,740
hypervisor the first function is our KP

530
00:26:46,560 --> 00:26:52,800
in need we say D zero you can also see

531
00:26:49,740 --> 00:26:55,860
the command and it expects the struck

532
00:26:52,800 --> 00:26:59,460
with info about the kernel such as the

533
00:26:55,860 --> 00:27:03,409
text and data regions the Vimala Crain's

534
00:26:59,460 --> 00:27:07,950
page table addresses and some Samsung

535
00:27:03,410 --> 00:27:10,050
specific regions this is the function

536
00:27:07,950 --> 00:27:14,450
and we're going to examine next the

537
00:27:10,050 --> 00:27:16,889
various steps are KPD bug login it

538
00:27:14,450 --> 00:27:19,200
initializes the second Oracle which is

539
00:27:16,890 --> 00:27:22,650
available via the same progress entry

540
00:27:19,200 --> 00:27:27,090
and on the top part of the snippet we

541
00:27:22,650 --> 00:27:29,580
can see it being used and dumping system

542
00:27:27,090 --> 00:27:32,730
registers and we can see the format of

543
00:27:29,580 --> 00:27:34,620
an edited snippet below and this is

544
00:27:32,730 --> 00:27:39,020
really important for us because it holds

545
00:27:34,620 --> 00:27:41,639
information regarding several several

546
00:27:39,020 --> 00:27:46,220
system registers which allow us to

547
00:27:41,640 --> 00:27:46,220
properly define the framework state

548
00:27:47,090 --> 00:27:52,199
there are two modes that are KP can be

549
00:27:49,950 --> 00:27:54,990
executed in and they depend on the magic

550
00:27:52,200 --> 00:27:57,420
value once our cap is initialized with

551
00:27:54,990 --> 00:28:00,240
normal interaction we cannot change the

552
00:27:57,420 --> 00:28:03,420
state there is normal mode with magic

553
00:28:00,240 --> 00:28:04,800
values safe 1 and test mode with magic

554
00:28:03,420 --> 00:28:07,370
value safe 2

555
00:28:04,800 --> 00:28:09,510
it enables testing as the name suggests

556
00:28:07,370 --> 00:28:11,580
and what does it do

557
00:28:09,510 --> 00:28:14,430
disable some command counters so we can

558
00:28:11,580 --> 00:28:15,810
invoke some functions more than counter

559
00:28:14,430 --> 00:28:18,390
times depending on the new

560
00:28:15,810 --> 00:28:20,310
configurations and it enables a set of

561
00:28:18,390 --> 00:28:28,230
additional functions which are not

562
00:28:20,310 --> 00:28:30,780
defined without the test mode the most

563
00:28:28,230 --> 00:28:34,110
important function of the rkp need is

564
00:28:30,780 --> 00:28:36,270
our KP paging in it it has various

565
00:28:34,110 --> 00:28:40,979
checks regarding the memory layout of

566
00:28:36,270 --> 00:28:43,379
the l1 implementation and our framework

567
00:28:40,980 --> 00:28:46,430
must satisfy each and every one of these

568
00:28:43,380 --> 00:28:51,780
[Music]

569
00:28:46,430 --> 00:28:54,270
requirements additionally it edited

570
00:28:51,780 --> 00:28:56,700
it had its memory region attributes for

571
00:28:54,270 --> 00:28:59,550
stage 2 translation regarding with

572
00:28:56,700 --> 00:29:01,950
respect to the provided memory layout

573
00:28:59,550 --> 00:29:03,870
it sets internal information from memory

574
00:29:01,950 --> 00:29:06,540
region housekeeping for example it knows

575
00:29:03,870 --> 00:29:09,030
it can distinguish between a kernel

576
00:29:06,540 --> 00:29:12,210
kernel text region and a raw data region

577
00:29:09,030 --> 00:29:15,210
and specify and decide later whether a

578
00:29:12,210 --> 00:29:18,360
specific action is allowed or not and

579
00:29:15,210 --> 00:29:21,680
maps sensitive regions from stage 2 so

580
00:29:18,360 --> 00:29:24,149
there are no more accessible from l1 and

581
00:29:21,680 --> 00:29:27,120
it's and every one of these steps must

582
00:29:24,150 --> 00:29:29,870
be successfully executed or else rkp

583
00:29:27,120 --> 00:29:37,229
does not initialize and we can no longer

584
00:29:29,870 --> 00:29:40,020
invoke SBC this some layout some entries

585
00:29:37,230 --> 00:29:41,910
are not supported by functionality in a

586
00:29:40,020 --> 00:29:42,510
framework for the example the Vimala

587
00:29:41,910 --> 00:29:45,510
grains

588
00:29:42,510 --> 00:29:49,160
however they are expected by our KP and

589
00:29:45,510 --> 00:29:53,180
we must at least make sure to satisfy

590
00:29:49,160 --> 00:29:57,300
the ridge the region layout for these

591
00:29:53,180 --> 00:29:59,460
memory regions and also the system

592
00:29:57,300 --> 00:30:02,790
constraint of figure bytes is explained

593
00:29:59,460 --> 00:30:04,860
here since it ensures that we have

594
00:30:02,790 --> 00:30:06,870
enough physical address to place

595
00:30:04,860 --> 00:30:11,879
specific regions in their expected

596
00:30:06,870 --> 00:30:14,699
physical locations the second command is

597
00:30:11,880 --> 00:30:18,120
our KP deferred initialization our KP

598
00:30:14,700 --> 00:30:20,220
definite with a command 81 it changes

599
00:30:18,120 --> 00:30:23,280
the kernel text region to read read-only

600
00:30:20,220 --> 00:30:26,370
for stage 2 tables so we cannot write to

601
00:30:23,280 --> 00:30:29,280
the kernel text region anymore and

602
00:30:26,370 --> 00:30:31,560
TPB r1 and it's sub tables are changed

603
00:30:29,280 --> 00:30:34,350
to read only and not executable as we

604
00:30:31,560 --> 00:30:37,050
can see from the second sink from the

605
00:30:34,350 --> 00:30:42,810
snippet on the right we're gonna see

606
00:30:37,050 --> 00:30:44,010
those in detail in our demo so we have

607
00:30:42,810 --> 00:30:45,810
reached a state where we can now

608
00:30:44,010 --> 00:30:47,879
interact with our KP and invoke further

609
00:30:45,810 --> 00:30:50,940
ADC commands however we did not follow

610
00:30:47,880 --> 00:30:51,450
the original initialization process to

611
00:30:50,940 --> 00:30:53,850
the letter

612
00:30:51,450 --> 00:30:55,440
there are various routines that are not

613
00:30:53,850 --> 00:30:58,860
void of meaning in a framework for

614
00:30:55,440 --> 00:31:02,280
example passing offsets for various

615
00:30:58,860 --> 00:31:05,010
kernel strokes to our KP for example the

616
00:31:02,280 --> 00:31:08,070
credential structure the

617
00:31:05,010 --> 00:31:11,040
Sally Knox of VFS mound and so forth

618
00:31:08,070 --> 00:31:14,220
however we did introduce the basic yield

619
00:31:11,040 --> 00:31:17,129
to concepts we require to properly set

620
00:31:14,220 --> 00:31:20,940
in a framework and interact with our KP

621
00:31:17,130 --> 00:31:22,860
and the most important part is that we

622
00:31:20,940 --> 00:31:25,890
have reached a state where we can now

623
00:31:22,860 --> 00:31:30,178
interact and start investigating fuzzing

624
00:31:25,890 --> 00:31:33,480
setups before moving on we have we must

625
00:31:30,179 --> 00:31:36,090
be aware of SMC invocations from yellow

626
00:31:33,480 --> 00:31:37,559
to implementations that lead to l3 we

627
00:31:36,090 --> 00:31:39,570
have to handle them there and this is

628
00:31:37,559 --> 00:31:42,480
many of importance both in the

629
00:31:39,570 --> 00:31:45,139
configuration stage but also while

630
00:31:42,480 --> 00:31:49,830
fuzzing because we can have unexpected

631
00:31:45,140 --> 00:31:54,630
results there and fuzzing father stopped

632
00:31:49,830 --> 00:31:56,399
working in our KP specifically in this

633
00:31:54,630 --> 00:32:00,600
specific target there is only one

634
00:31:56,400 --> 00:32:04,200
available which is it has its own hvc

635
00:32:00,600 --> 00:32:07,020
command and is related to verification

636
00:32:04,200 --> 00:32:09,809
of various images that are loaded from

637
00:32:07,020 --> 00:32:17,850
the disk and we can leave that for now

638
00:32:09,809 --> 00:32:21,389
so safety first and demo ok this is

639
00:32:17,850 --> 00:32:30,510
gonna be a live demo starting the

640
00:32:21,390 --> 00:32:34,020
framework okay so we are at reset

641
00:32:30,510 --> 00:32:35,760
function we start executing and we reach

642
00:32:34,020 --> 00:32:40,740
the state where we are gonna drop to

643
00:32:35,760 --> 00:32:43,590
yield l1 so SP CR holds the value to

644
00:32:40,740 --> 00:32:49,790
specify that we move to that we came

645
00:32:43,590 --> 00:32:53,370
from l1 64 bits and we want a job to

646
00:32:49,790 --> 00:32:59,389
function start il-1 you can see the

647
00:32:53,370 --> 00:33:01,860
address here switch L is a custom tool

648
00:32:59,390 --> 00:33:05,070
so we can see we're executing a deal

649
00:33:01,860 --> 00:33:11,010
free and then going further now we are

650
00:33:05,070 --> 00:33:13,549
at l1 setting various registers enabling

651
00:33:11,010 --> 00:33:13,549
the MMU

652
00:33:15,480 --> 00:33:21,480
so we move about two-wheel free this is

653
00:33:18,029 --> 00:33:26,309
the exception handler for l3 it saves

654
00:33:21,480 --> 00:33:28,620
the exception frame and leads to handle

655
00:33:26,309 --> 00:33:33,710
interrupts which is the main synchronous

656
00:33:28,620 --> 00:33:36,899
exception handler so we move on to

657
00:33:33,710 --> 00:33:40,230
initializing our KP exception link

658
00:33:36,899 --> 00:33:42,029
register is the alpha entry point we

659
00:33:40,230 --> 00:33:46,110
specify that we came from anneal to

660
00:33:42,029 --> 00:33:50,669
64-bit state in SPS are and continue and

661
00:33:46,110 --> 00:33:53,850
this is now we are now in the entry

662
00:33:50,669 --> 00:33:55,980
point for our KP executing at the l2

663
00:33:53,850 --> 00:33:58,129
this eventually leads this function

664
00:33:55,980 --> 00:34:00,539
which is vmm main as we saw before

665
00:33:58,130 --> 00:34:04,769
continuing with our execution we have

666
00:34:00,539 --> 00:34:06,539
now successfully bootstrap the

667
00:34:04,769 --> 00:34:09,599
hypervisor as we see this is the magic

668
00:34:06,539 --> 00:34:11,879
value for X 0 and 0 for X 1 indicates

669
00:34:09,599 --> 00:34:16,649
successful initialization so we move on

670
00:34:11,879 --> 00:34:24,739
to wheel 3 system initialized properly

671
00:34:16,649 --> 00:34:30,598
so we listed the state and drop to l1 ok

672
00:34:24,739 --> 00:34:40,229
so first first initialization function

673
00:34:30,599 --> 00:34:42,089
rkp in need so we can see here the the

674
00:34:40,230 --> 00:34:44,520
expected value so you can see for

675
00:34:42,089 --> 00:34:46,168
example safe 1 and the rest of the

676
00:34:44,520 --> 00:34:51,710
memory regions which are passed to our

677
00:34:46,168 --> 00:34:55,109
KP invoking SBC leads to VM MD spots

678
00:34:51,710 --> 00:34:58,770
next is VC command is our KP deferred

679
00:34:55,109 --> 00:35:01,680
initialization this is the entry as we

680
00:34:58,770 --> 00:35:04,589
saw before so we create the exception

681
00:35:01,680 --> 00:35:07,828
frame in our KP and these are the values

682
00:35:04,589 --> 00:35:13,410
that are passed to this function which

683
00:35:07,829 --> 00:35:17,460
is vmm dispatch I'm sorry I didn't ask

684
00:35:13,410 --> 00:35:20,759
is this demo visible for everyone here

685
00:35:17,460 --> 00:35:26,000
do you want me to zoom in a bit good

686
00:35:20,760 --> 00:35:26,000
ok so

687
00:35:29,260 --> 00:35:33,800
we have reached this function here I'm

688
00:35:31,850 --> 00:35:36,259
gonna demonstrate how useful our

689
00:35:33,800 --> 00:35:40,490
framework is so this is gonna change our

690
00:35:36,260 --> 00:35:49,400
text physical our text and a framework

691
00:35:40,490 --> 00:35:55,129
text region to read only so this is the

692
00:35:49,400 --> 00:36:02,180
value that we are interested in page

693
00:35:55,130 --> 00:36:06,220
walk so we dump the tables and we can

694
00:36:02,180 --> 00:36:14,990
see here that this is executable and

695
00:36:06,220 --> 00:36:23,089
readwrite so we execute this function

696
00:36:14,990 --> 00:36:26,180
page walk again so this was the initial

697
00:36:23,090 --> 00:36:28,580
state and this is the next one so the

698
00:36:26,180 --> 00:36:33,100
text region of the ill one in our

699
00:36:28,580 --> 00:36:36,200
framework is now read-only and this is

700
00:36:33,100 --> 00:36:38,569
somewhat complex function so with this

701
00:36:36,200 --> 00:36:40,700
framework simply executing it we can get

702
00:36:38,570 --> 00:36:44,540
an understanding of how things work

703
00:36:40,700 --> 00:36:49,910
before moving on to the actual auditing

704
00:36:44,540 --> 00:36:54,830
process and this is similarly performed

705
00:36:49,910 --> 00:37:06,710
with TTB r1 and it's subtables let's see

706
00:36:54,830 --> 00:37:11,600
that as well we can see here its value

707
00:37:06,710 --> 00:37:18,860
so now executing this function and

708
00:37:11,600 --> 00:37:21,529
dumping the tables again this was the

709
00:37:18,860 --> 00:37:26,900
original value and now we can see that

710
00:37:21,530 --> 00:37:32,650
it's not executable and read-only so

711
00:37:26,900 --> 00:37:37,930
continuing we also have access to the

712
00:37:32,650 --> 00:37:37,930
various debug buffers of course

713
00:37:42,829 --> 00:37:52,579
so the debug buffer and the log buffer

714
00:37:46,489 --> 00:37:57,509
can be easily accessed from our setup

715
00:37:52,579 --> 00:38:05,489
this is mostly it for now let's see an

716
00:37:57,509 --> 00:38:08,489
additional thing that's of importance so

717
00:38:05,489 --> 00:38:11,960
let's say that we set a framework to be

718
00:38:08,489 --> 00:38:15,180
in a different physical address

719
00:38:11,960 --> 00:38:18,680
initialize the frame rkp initialize

720
00:38:15,180 --> 00:38:24,419
here's initialization is successful so

721
00:38:18,680 --> 00:38:28,259
we return to l1 to l-3 initialize

722
00:38:24,420 --> 00:38:37,849
successfully so we now try to execute to

723
00:38:28,259 --> 00:38:41,549
drop to l1 so reset the state so this is

724
00:38:37,849 --> 00:38:47,880
the address that we now wanna return to

725
00:38:41,549 --> 00:38:53,670
and continuing from this point we hit an

726
00:38:47,880 --> 00:38:56,249
exception in the l2 and the faulting

727
00:38:53,670 --> 00:38:58,380
address is the address that we wanting

728
00:38:56,249 --> 00:39:01,229
to return so we wanted to return to an

729
00:38:58,380 --> 00:39:03,630
l1 address that's not much in stage 2

730
00:39:01,229 --> 00:39:05,749
tables and that results in a translation

731
00:39:03,630 --> 00:39:05,749
error

732
00:39:16,880 --> 00:39:26,900
so let's move on with the fuzzing set up

733
00:39:23,109 --> 00:39:28,940
and our number of approaches for example

734
00:39:26,900 --> 00:39:30,440
we could use armed semi hosting which

735
00:39:28,940 --> 00:39:33,259
allows us to communicate with the host

736
00:39:30,440 --> 00:39:36,920
and uses our your facilities which is

737
00:39:33,259 --> 00:39:40,039
supported by Kumho and it's not but we

738
00:39:36,920 --> 00:39:42,049
require to sync with house somehow and

739
00:39:40,039 --> 00:39:44,119
due to its implementation is probably

740
00:39:42,049 --> 00:39:46,700
gonna be a bit slower or we can fast

741
00:39:44,119 --> 00:39:50,390
directly from Q mu which is sync by

742
00:39:46,700 --> 00:39:55,249
design but we must modify would support

743
00:39:50,390 --> 00:39:58,819
that we chose the second approach for

744
00:39:55,249 --> 00:40:01,279
various reasons mainly to study q mo so

745
00:39:58,819 --> 00:40:02,808
what we do is qm you have create have qm

746
00:40:01,279 --> 00:40:05,420
will create a test case and deliver that

747
00:40:02,809 --> 00:40:08,420
test case to the vm to do that we

748
00:40:05,420 --> 00:40:11,660
utilize break instruction so we can pass

749
00:40:08,420 --> 00:40:13,880
commands from the immediate value so

750
00:40:11,660 --> 00:40:16,220
instruction is B R K and immediate value

751
00:40:13,880 --> 00:40:19,309
that value is encoded in the exception

752
00:40:16,220 --> 00:40:22,968
syndrome register filled instruction

753
00:40:19,309 --> 00:40:25,460
specific syndrome is s so we can cut it

754
00:40:22,969 --> 00:40:28,309
in qmo and of course we can create

755
00:40:25,460 --> 00:40:31,309
arbitrary phasing harnesses but we must

756
00:40:28,309 --> 00:40:34,160
make sure that fuzzing the test case

757
00:40:31,309 --> 00:40:38,719
created in q mu and framework that

758
00:40:34,160 --> 00:40:41,779
execute are in sync this how we handle

759
00:40:38,719 --> 00:40:44,989
breaking instruction in q mo the its arm

760
00:40:41,779 --> 00:40:48,710
CPU to interrupt function we get the

761
00:40:44,989 --> 00:40:51,650
exception a reason from the exception

762
00:40:48,710 --> 00:40:55,539
the entry the field exception index and

763
00:40:51,650 --> 00:40:58,279
we inject our functionality in B R K we

764
00:40:55,539 --> 00:41:03,710
have created the symbol harness to fast

765
00:40:58,279 --> 00:41:06,410
commands so B R K moves on to Q mu we

766
00:41:03,710 --> 00:41:10,069
may get a random byte for the command ID

767
00:41:06,410 --> 00:41:12,170
and we have an r KP specific thing most

768
00:41:10,069 --> 00:41:18,680
of a CVC commands for our KP require a

769
00:41:12,170 --> 00:41:21,319
valid l1 buffer so we also satisfy that

770
00:41:18,680 --> 00:41:23,839
we copy round above the data to the

771
00:41:21,319 --> 00:41:26,299
buffer and fit that as a second argument

772
00:41:23,839 --> 00:41:30,220
so after the test case is created we

773
00:41:26,299 --> 00:41:33,560
invoke SBC and false and then repeat

774
00:41:30,220 --> 00:41:35,779
so this is how things work after the

775
00:41:33,560 --> 00:41:37,730
initialization we invoke break fast

776
00:41:35,780 --> 00:41:43,760
function which we can see leads to be R

777
00:41:37,730 --> 00:41:48,590
K 1 B R K 1 he's got is identified in

778
00:41:43,760 --> 00:41:51,020
qmo by the syndrome we have case 1 so we

779
00:41:48,590 --> 00:41:53,360
get a random byte we create the command

780
00:41:51,020 --> 00:41:56,360
this is the command ID we create a

781
00:41:53,360 --> 00:42:01,310
command and said when store that in

782
00:41:56,360 --> 00:42:04,010
register X 0 and then we have the l1

783
00:42:01,310 --> 00:42:06,770
buffer and we copy random byte random

784
00:42:04,010 --> 00:42:10,580
data into it and place its pointer to X

785
00:42:06,770 --> 00:42:14,810
1 so now we are ready to call our KB

786
00:42:10,580 --> 00:42:16,910
fast since qmo make sure to have the

787
00:42:14,810 --> 00:42:19,009
sink in set for example we have the

788
00:42:16,910 --> 00:42:21,620
command in X 0 and the buffering next

789
00:42:19,010 --> 00:42:24,560
one we do not have to do further steps

790
00:42:21,620 --> 00:42:27,380
in the framework to sync the test case

791
00:42:24,560 --> 00:42:33,200
with the HVC invocations

792
00:42:27,380 --> 00:42:36,280
so we now are ready to execute the

793
00:42:33,200 --> 00:42:40,910
father and we do and nothing happens so

794
00:42:36,280 --> 00:42:43,070
what the hell's going on there's nothing

795
00:42:40,910 --> 00:42:44,750
there to cross because this is a

796
00:42:43,070 --> 00:42:46,940
bare-metal implementation so what

797
00:42:44,750 --> 00:42:48,440
happens one thing goes south abort

798
00:42:46,940 --> 00:42:51,380
exceptions which are synchronous

799
00:42:48,440 --> 00:42:54,980
exceptions and what we do that there we

800
00:42:51,380 --> 00:42:57,290
handle them in q mu we identify them in

801
00:42:54,980 --> 00:43:00,080
arm CPU doing the route same as b r k

802
00:42:57,290 --> 00:43:03,470
with the exception index for example

803
00:43:00,080 --> 00:43:08,750
here we have instruction abort and data

804
00:43:03,470 --> 00:43:11,870
board and in our function we have we

805
00:43:08,750 --> 00:43:15,410
create a cross log and reset the queue a

806
00:43:11,870 --> 00:43:18,259
move to resume with the execution this

807
00:43:15,410 --> 00:43:22,759
is a sample cross log and we're going to

808
00:43:18,260 --> 00:43:26,780
see more details about it next so don't

809
00:43:22,760 --> 00:43:29,360
worry about it before continuing there

810
00:43:26,780 --> 00:43:32,870
are some special cases they result in

811
00:43:29,360 --> 00:43:36,470
endless loop and in our setup that's

812
00:43:32,870 --> 00:43:39,650
disastrous for this approach the dummy

813
00:43:36,470 --> 00:43:41,660
fuzzing we identify them by the address

814
00:43:39,650 --> 00:43:43,050
but of course that does not scale well

815
00:43:41,660 --> 00:43:45,540
because we cannot

816
00:43:43,050 --> 00:43:48,590
know beforehand it's single address

817
00:43:45,540 --> 00:43:51,029
that's gonna lead to such state but that

818
00:43:48,590 --> 00:43:53,550
there are more elegant solutions for

819
00:43:51,030 --> 00:43:56,370
example watchdog timers but we are not

820
00:43:53,550 --> 00:44:00,090
interested in our dummy fuzzing to cover

821
00:43:56,370 --> 00:44:02,040
each and everything for our KB

822
00:44:00,090 --> 00:44:05,070
specifically there are two functions of

823
00:44:02,040 --> 00:44:07,790
interest vmm panic and this is found in

824
00:44:05,070 --> 00:44:12,180
only a handful of places for example if

825
00:44:07,790 --> 00:44:13,980
vmm synchronous handler somehow results

826
00:44:12,180 --> 00:44:18,029
in an error for example a synchronous

827
00:44:13,980 --> 00:44:21,660
exception that's not supported then vmm

828
00:44:18,030 --> 00:44:23,790
this part leads to vmm panic and what we

829
00:44:21,660 --> 00:44:27,859
do when we identify this is we reset the

830
00:44:23,790 --> 00:44:30,930
system rkp policy violation function

831
00:44:27,860 --> 00:44:34,020
better aligns with the assertion logic

832
00:44:30,930 --> 00:44:37,710
for example if we invoke native ec

833
00:44:34,020 --> 00:44:44,360
command more than counter x then that

834
00:44:37,710 --> 00:44:47,030
leads to an RK people's violation so

835
00:44:44,360 --> 00:44:57,900
conclusion now before the conclusions

836
00:44:47,030 --> 00:45:00,560
let's see a demo it's not gonna be as

837
00:44:57,900 --> 00:45:00,560
fancy

838
00:45:05,410 --> 00:45:15,980
so we are now executing policy violation

839
00:45:11,000 --> 00:45:21,230
but we also have an abort so that's good

840
00:45:15,980 --> 00:45:26,770
something works we can see here the

841
00:45:21,230 --> 00:45:32,570
abort in the host let's see this sample

842
00:45:26,770 --> 00:45:36,560
this is SV as you can see here this has

843
00:45:32,570 --> 00:45:38,990
been reported Samsung the slides do not

844
00:45:36,560 --> 00:45:43,299
have the sample because I was not sure

845
00:45:38,990 --> 00:45:47,810
if the parts would be public by there by

846
00:45:43,300 --> 00:45:50,950
this time so we can see the faulting

847
00:45:47,810 --> 00:45:56,660
address here this is the command that

848
00:45:50,950 --> 00:46:00,529
resulted in the abort so if you remember

849
00:45:56,660 --> 00:46:07,790
the command creation logic then this is

850
00:46:00,530 --> 00:46:10,880
command ID hex 9b and this is where the

851
00:46:07,790 --> 00:46:16,640
exception happened we have also a

852
00:46:10,880 --> 00:46:21,350
disassembly here so we can see that x 0

853
00:46:16,640 --> 00:46:26,210
x 2 holds this value which is controlled

854
00:46:21,350 --> 00:46:29,540
by us and is the guest buffer and X 0

855
00:46:26,210 --> 00:46:33,550
has a predefined value and it right in

856
00:46:29,540 --> 00:46:38,540
tries to access this address and write

857
00:46:33,550 --> 00:46:41,840
x1 into it so in our class log we can

858
00:46:38,540 --> 00:46:43,820
add arbitrary information so we have

859
00:46:41,840 --> 00:46:46,100
this for demonstration these are the

860
00:46:43,820 --> 00:46:48,110
values for the abort we have the CPU

861
00:46:46,100 --> 00:46:50,450
state disassembly to know where this

862
00:46:48,110 --> 00:46:53,240
happened and memory dumps for example

863
00:46:50,450 --> 00:47:05,149
this is this is the first data that is

864
00:46:53,240 --> 00:47:09,410
passed in the framework buffer ok right

865
00:47:05,150 --> 00:47:11,750
so conclusions so we introduced key

866
00:47:09,410 --> 00:47:13,520
concepts and discussed the various

867
00:47:11,750 --> 00:47:16,900
considerations when you have to keep in

868
00:47:13,520 --> 00:47:18,680
mind when researching such targets and

869
00:47:16,900 --> 00:47:20,750
some basic approach

870
00:47:18,680 --> 00:47:22,339
is the fuzzing so hopefully with this

871
00:47:20,750 --> 00:47:26,030
information you can start developing

872
00:47:22,340 --> 00:47:28,690
your own frameworks some references and

873
00:47:26,030 --> 00:47:34,580
special things to people that

874
00:47:28,690 --> 00:47:36,740
contributed to my research we can see

875
00:47:34,580 --> 00:47:40,970
someone here or maybe this is a mythical

876
00:47:36,740 --> 00:47:44,149
beast a teaser for you guys

877
00:47:40,970 --> 00:47:48,169
I have also implemented AFL with full

878
00:47:44,150 --> 00:47:51,710
system qmo emulation sadly 50 minutes is

879
00:47:48,170 --> 00:47:54,770
not enough for everything this this was

880
00:47:51,710 --> 00:47:57,650
based on Triforce AFL which is suddenly

881
00:47:54,770 --> 00:48:00,050
suddenly abandoned there are many

882
00:47:57,650 --> 00:48:03,860
changes since these are the versions we

883
00:48:00,050 --> 00:48:07,850
used so as I've said before for example

884
00:48:03,860 --> 00:48:10,420
with the very situation that lead to

885
00:48:07,850 --> 00:48:13,640
endless loops as my as you might know

886
00:48:10,420 --> 00:48:16,040
AFL handles them with what's on timers

887
00:48:13,640 --> 00:48:20,540
that's why we don't care about them in

888
00:48:16,040 --> 00:48:22,790
our dummy fuzzing this is a snapshot of

889
00:48:20,540 --> 00:48:24,770
the execution we can see that we are

890
00:48:22,790 --> 00:48:26,060
executing at around sixty hundred

891
00:48:24,770 --> 00:48:30,350
executions per second

892
00:48:26,060 --> 00:48:36,410
and perfect stability identifying new

893
00:48:30,350 --> 00:48:41,270
paths and crosses so how are we on time

894
00:48:36,410 --> 00:48:44,270
not good okay the demo for this one is

895
00:48:41,270 --> 00:48:48,580
not that fascinating either way so

896
00:48:44,270 --> 00:48:48,580
that's it for me thank you all

897
00:48:50,610 --> 00:49:00,180
[Applause]

898
00:48:52,550 --> 00:49:05,100
so any questions for you guys let me

899
00:49:00,180 --> 00:49:08,310
show you this thing you hear while

900
00:49:05,100 --> 00:49:13,049
moving to the questions

901
00:49:08,310 --> 00:49:15,180
yep okay so we are executing the full

902
00:49:13,050 --> 00:49:19,740
system fuzzing oh yeah go ahead

903
00:49:15,180 --> 00:49:27,060
oh nice worker is really nice are SMC

904
00:49:19,740 --> 00:49:30,359
trapped by l2 l1 s MCS trapped by l2 for

905
00:49:27,060 --> 00:49:34,500
this configuration I don't think so yeah

906
00:49:30,360 --> 00:49:38,100
I am Not sure right now you could

907
00:49:34,500 --> 00:49:41,310
probably do that but I'm not certainly

908
00:49:38,100 --> 00:49:43,589
not sure I cannot answer that let's

909
00:49:41,310 --> 00:49:48,600
assume it's not for a moment what would

910
00:49:43,590 --> 00:49:52,560
prevent L one from reinitializing l2 by

911
00:49:48,600 --> 00:49:57,600
holding an initial SMC it depends on the

912
00:49:52,560 --> 00:50:04,640
rkp on the l2 configuration ality rkp

913
00:49:57,600 --> 00:50:06,960
has mitigations against this it has

914
00:50:04,640 --> 00:50:11,759
initialization status which is said it

915
00:50:06,960 --> 00:50:14,600
cannot be reset yes nhbc right hmm that

916
00:50:11,760 --> 00:50:17,490
goes to the counters are only for HBC's

917
00:50:14,600 --> 00:50:19,860
but it's relevant if you have access to

918
00:50:17,490 --> 00:50:21,450
your free like code execution yeah then

919
00:50:19,860 --> 00:50:23,520
you don't care about the l2 because

920
00:50:21,450 --> 00:50:27,149
you'll free is higher in Cleveland right

921
00:50:23,520 --> 00:50:30,120
if you go to l3 by SMC and then yell

922
00:50:27,150 --> 00:50:32,850
three drops to l2 l2 is already

923
00:50:30,120 --> 00:50:38,970
initialized and he knows that or C so

924
00:50:32,850 --> 00:50:40,440
the l2 l3 l2 you could have ear 3 do the

925
00:50:38,970 --> 00:50:46,140
check it doesn't matter

926
00:50:40,440 --> 00:50:49,290
yeah so long as someone has the check

927
00:50:46,140 --> 00:50:51,589
but rkp knows that has that

928
00:50:49,290 --> 00:50:54,090
functionality in its implementation

929
00:50:51,590 --> 00:50:55,740
let's discuss that offline hmm let's

930
00:50:54,090 --> 00:50:59,119
discuss that offline I'm interested

931
00:50:55,740 --> 00:51:03,720
thank you if something was not clear

932
00:50:59,119 --> 00:51:06,359
okay any more questions no questions

933
00:51:03,720 --> 00:51:06,930
all right before are there any more

934
00:51:06,359 --> 00:51:10,440
questions

935
00:51:06,930 --> 00:51:13,399
all right and I have a final thing if

936
00:51:10,440 --> 00:51:17,700
for you guys what two minutes I am

937
00:51:13,400 --> 00:51:22,019
really excited and proud to say that you

938
00:51:17,700 --> 00:51:24,868
can find further information in your

939
00:51:22,019 --> 00:51:29,430
favorite online magazine regarding this

940
00:51:24,869 --> 00:51:37,880
work and I'm really proud to have

941
00:51:29,430 --> 00:51:37,879
contributed to frog cheers - frog stuff

942
00:51:42,260 --> 00:51:49,490
cheers - frog stuff for continuing to

943
00:51:45,650 --> 00:51:54,329
for keeping frog alive with such amazing

944
00:51:49,490 --> 00:51:58,348
content and for being very accommodating

945
00:51:54,329 --> 00:52:00,650
with my various requests so very proud

946
00:51:58,349 --> 00:52:04,559
to have contributed to their efforts

947
00:52:00,650 --> 00:52:08,039
that's it for me so feel free to reach

948
00:52:04,559 --> 00:52:11,539
out for any questions I'm available I'm

949
00:52:08,039 --> 00:52:11,539
gonna be here for a few days

