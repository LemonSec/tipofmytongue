1
00:00:01,640 --> 00:00:07,999
alright guys I think it's time looks
like everybody made it in

2
00:00:07,999 --> 00:00:12,890
so there we go just yep

3
00:00:13,400 --> 00:00:18,589
welcome to the binary ninja vs ipad pro
we weren't sure exactly what to college

4
00:00:18,589 --> 00:00:22,668
so we said something about malware but
it's really about checking out the tools

5
00:00:22,669 --> 00:00:28,130
that are available to us as reverse
engineers malware analyst vulnerability

6
00:00:28,130 --> 00:00:32,360
researchers software devs that are
looking at clothes source apps as a lot

7
00:00:32,360 --> 00:00:35,960
of reasons why you might want to reverse
engineer something and there's a lot of

8
00:00:35,960 --> 00:00:39,320
different tools kind of feathers in our
cap that we can use to make that happen

9
00:00:39,320 --> 00:00:46,609
and some good friends of mine that I
know very well Jordan and his coal crew

10
00:00:46,609 --> 00:00:50,840
here rusty you guys want to stand up so
stay standing stay standing stay

11
00:00:50,840 --> 00:00:51,649
standing

12
00:00:51,649 --> 00:00:54,530
I just want to say a few things while
they stand embarrassing just a little

13
00:00:54,530 --> 00:00:59,030
bit i've been in the security research
seen a long time and I don't know very

14
00:00:59,030 --> 00:01:03,769
many people in this field that would
have the gumption to try to create a

15
00:01:03,769 --> 00:01:07,399
software product that would compete
head-to-head with something like idea

16
00:01:07,400 --> 00:01:11,659
which is kind of a you know a kind of an
icon in our field and sell it for half

17
00:01:11,659 --> 00:01:14,750
the price or less so i would say give
him a round of applause because i think

18
00:01:14,750 --> 00:01:17,750
it's amazing what they're doing

19
00:01:20,900 --> 00:01:29,900
ok so who am i by the way I'm Jared amat
CTO binary defensed and founder of Ed

20
00:01:29,900 --> 00:01:34,190
labs josh and i both trained here at
derby with some training here this year

21
00:01:34,820 --> 00:01:39,559
great class apset buzzing coding
reversing advanced security hacking all

22
00:01:39,560 --> 00:01:42,560
that kind of good stuff so if you want
to check that out feel free

23
00:01:43,760 --> 00:01:48,170
josh is here with me we had another
fellow Josh Blake do a little bit of

24
00:01:48,170 --> 00:01:49,100
work as well

25
00:01:49,100 --> 00:01:54,710
Josh's miss you so we both know Lord
here it comes

26
00:02:01,340 --> 00:02:05,390
it's like warmer than even just room
temperature warm it's like being in the

27
00:02:05,390 --> 00:02:13,520
microwave warm thank you Dave anybody
wants this after it's always going to be

28
00:02:13,520 --> 00:02:17,360
right here okay so back to where I was

29
00:02:17,360 --> 00:02:22,850
oh we worked worked a lot of different
organizations the issue we both the I've

30
00:02:22,850 --> 00:02:26,299
done stuff with chromium he's done some
malware analysis for them so spices to

31
00:02:26,300 --> 00:02:29,840
say we have a lot of experience both in
product security vulnerability research

32
00:02:29,840 --> 00:02:35,360
malware analysis you name it we've kind
of done I even have some courses up on

33
00:02:35,360 --> 00:02:39,739
pluralsight and those folks are here if
you want to work my pluralsight friends

34
00:02:39,739 --> 00:02:43,130
they're right here if you want to stand
up say hi give everybody way you can

35
00:02:43,130 --> 00:02:50,090
check out the course they're so binary
ninja if you go to the website and you

36
00:02:50,090 --> 00:02:53,360
can check out all the different features
we're not going to like I'm not a paid

37
00:02:53,360 --> 00:02:56,239
spokesmen provider and just so you know
I tried to actually do a pair of fair

38
00:02:56,239 --> 00:03:01,670
analysis between idea and binary ninja
so you know it is what it is if I mess

39
00:03:01,670 --> 00:03:04,579
up stuff miss stuff jourdan's right up
here after you can come find him he's

40
00:03:04,580 --> 00:03:06,049
got stickers

41
00:03:06,049 --> 00:03:08,810
you might even be able to get a teacher
but I don't know about that that's

42
00:03:08,810 --> 00:03:12,799
probably gonna take a lot of convincing
but so we're not going to go through the

43
00:03:12,799 --> 00:03:16,519
whole list of every feature that's in
each product and really try to

44
00:03:17,310 --> 00:03:21,870
no go exhaustive on that today's
learning was more about you know I just

45
00:03:21,870 --> 00:03:25,890
kind of ruled the roost right at least
in my perspective anyway for for a

46
00:03:25,890 --> 00:03:30,988
spectrum of activities so what about
this new tool you know doesn't have a

47
00:03:30,989 --> 00:03:35,099
shot at doing what what I does and so
that's kind of what I was interested in

48
00:03:35,099 --> 00:03:38,250
learning about first of all the pricing
is a lot more straightforward on binary

49
00:03:38,250 --> 00:03:44,459
digits lot cheaper it's a lot easier to
understand it's just got two very simple

50
00:03:44,459 --> 00:03:48,060
way to understand if you go and look at
the price of riding pro go to the

51
00:03:48,060 --> 00:03:52,140
website for x-rays and and try to figure
out how to buy I to pro it's like you

52
00:03:52,140 --> 00:03:55,140
have to figure out which zone you're in
the eurozone and like all this stuff

53
00:03:55,140 --> 00:03:58,500
right in with you wanted like name
license or floating license and really

54
00:03:58,500 --> 00:04:02,970
chaotic confusing i thought but anyway
you'll find out at the end of the day

55
00:04:02,970 --> 00:04:05,760
that is quite a bit more particularly if
you want to do compiler and all the

56
00:04:05,760 --> 00:04:08,700
other sort of add-ons and have to buy
for each architecture doesn't just work

57
00:04:08,700 --> 00:04:11,819
on your mac or windows or whatever like
you've got to buy it separately for ages

58
00:04:11,819 --> 00:04:16,320
so i would say binary digits definitely
better in that sense it's much easier to

59
00:04:16,320 --> 00:04:21,358
buy and in easier on the wallet and you
know that whole thing in terms of the

60
00:04:21,358 --> 00:04:23,130
interface pretty similar

61
00:04:23,130 --> 00:04:27,870
just open it up you can drop a file in
it whether it's an executable or an

62
00:04:27,870 --> 00:04:29,669
alpha object or whatever it may be

63
00:04:29,669 --> 00:04:34,830
throw it in Idaho or binary ninja and
you'll get a similar sort of look and

64
00:04:34,830 --> 00:04:39,990
feel to the graph so I a lot of the
hotkeys if you're familiar with idea i

65
00:04:39,990 --> 00:04:45,120
think the vector 35 folks intentionally
made some of the hotkeys pretty similar

66
00:04:45,120 --> 00:04:48,539
so that you can transition your skill
set from Ida over to binary ninja-like

67
00:04:48,539 --> 00:04:52,260
if you hit the spacebar for example you
go to the flat view versus the graph you

68
00:04:52,260 --> 00:04:57,599
so that was kind of existing knowledge
as you have already there that's great I

69
00:04:57,600 --> 00:05:01,380
think that definitely is a transition if
you're interested in learning the tool

70
00:05:01,380 --> 00:05:05,940
some places where is a little bit more
mature because I mean that's the tip too

71
00:05:05,940 --> 00:05:08,639
long didn't read right if you want to
take away from this talk it's like hey

72
00:05:08,639 --> 00:05:12,630
by ninjas awesome but they've only been
selling it for a few months where you

73
00:05:12,630 --> 00:05:15,990
know I'd has been on the market a long
time so it's going to have a few extra

74
00:05:15,990 --> 00:05:20,520
things for example like it particularly
on Windows it seemed to us anyway that

75
00:05:20,520 --> 00:05:25,599
like finding main and symbols and things
like that idea was a little better at

76
00:05:25,600 --> 00:05:29,380
for now I know George got a whole road
map of where they're at and where their

77
00:05:29,380 --> 00:05:31,870
features are coming and where it's going
to be in the future and I think you can

78
00:05:31,870 --> 00:05:38,200
stay and talk to him about that if you
want to know exactly where that is so on

79
00:05:38,200 --> 00:05:42,400
our Morel for mac or whatever maybe
maybe they're more comparable maybe a

80
00:05:42,400 --> 00:05:46,539
fine engine does a better job there I
didn't we didn't try every combination

81
00:05:46,540 --> 00:05:51,430
of situations but at least if you're in
the probably the highest percentage of

82
00:05:51,430 --> 00:05:55,720
reverse engineers there's ones that do
reino reversing for about finding

83
00:05:55,720 --> 00:05:59,350
vulnerabilities and for closer all that
stuff but malware analysis on Windows is

84
00:05:59,350 --> 00:06:03,730
a pretty big piece of what I think it's
used for so it does have some nice

85
00:06:03,730 --> 00:06:04,780
capabilities

86
00:06:04,780 --> 00:06:09,760
I probably wins therefore now in terms
of being able to identify functions like

87
00:06:09,760 --> 00:06:15,340
Maine and start to their instead of
starting you and starts also things like

88
00:06:15,340 --> 00:06:22,840
identifying common types common features
functions for example if you're really

89
00:06:22,840 --> 00:06:26,469
kind of down in the weeds if you're used
to looking at the bits and bytes of

90
00:06:26,470 --> 00:06:30,220
things this is from control-flow guards
if you're looking at a binary that's can

91
00:06:30,220 --> 00:06:34,960
been compiled for Windows 8 or Windows
10 and it's got this new protection that

92
00:06:34,960 --> 00:06:40,299
visual studio 2015 higher gives you
called CFG I'd recognized that this call

93
00:06:40,300 --> 00:06:44,620
is to a call to going to check to see if
the pointers about . and out where in

94
00:06:44,620 --> 00:06:48,130
this case by ninja didn't recognize it
so well so you could name it you could

95
00:06:48,130 --> 00:06:52,659
definitely you know typename and stuff
like that but I did more in terms of

96
00:06:52,660 --> 00:06:58,240
functions and all of that stuff so and
that's to be expected right a tool

97
00:06:58,240 --> 00:07:01,990
that's been around for a long time cost
a lot more to it versus a tool it's a

98
00:07:01,990 --> 00:07:06,130
little bit on the field you kind of
expect that sort of different so um in

99
00:07:06,130 --> 00:07:09,340
terms of the interface views the
interview the hex view the graph use

100
00:07:09,340 --> 00:07:13,659
pretty similar the look and fuel feel of
binary images a little cooler it's got

101
00:07:13,660 --> 00:07:16,870
kind of the dark background and all that
you can customize that night too if you

102
00:07:16,870 --> 00:07:21,790
want so you can kind of get similar
looks and feels i would say the tabs is

103
00:07:21,790 --> 00:07:24,250
something we really enjoyed by your
ninja so if you're going to open

104
00:07:24,250 --> 00:07:28,240
multiple programs multiple DLLs whatever
you might have you can have it all in

105
00:07:28,240 --> 00:07:30,420
your main engine window

106
00:07:30,420 --> 00:07:33,510
I don't know pinches of word is that a
word can be said vengeance the binary

107
00:07:33,510 --> 00:07:40,440
into rbn benja ok so we're in either you
have to open up each dll and stuff

108
00:07:40,440 --> 00:07:44,670
separately in a different program so you
know that is a little more clunky and

109
00:07:44,670 --> 00:07:50,250
itís I like that about ninja if you
will the log output on the bottom is

110
00:07:50,250 --> 00:07:53,430
pretty similar you get a bit of a
similar thing although I like the

111
00:07:53,430 --> 00:07:57,780
scripting view of injury better and
you've got a kind of a window dedicated

112
00:07:57,780 --> 00:08:02,909
to the interactive python interface
which is much cooler much nicer I think

113
00:08:02,910 --> 00:08:08,850
I like that a lot better the auto
analysis and the UI all that when you

114
00:08:08,850 --> 00:08:13,170
first load a program in my experience
was faster engine so if you put a big

115
00:08:13,170 --> 00:08:18,150
fat deal like ms HTML that dll if you've
ever done that put put that dll in idea

116
00:08:18,150 --> 00:08:21,900
and see what happens you end up units
like go get a cup of coffee right and

117
00:08:21,900 --> 00:08:26,969
you know maybe I don't know you could
escort again why exactly what it is is

118
00:08:26,970 --> 00:08:30,780
results end up a little better right you
get more that it types it finds things

119
00:08:30,780 --> 00:08:33,809
better and like some things get named
better so ends up a little better but

120
00:08:33,809 --> 00:08:37,439
it's a lot slower than you is a lot more
responsive and a lot faster and enjoy so

121
00:08:37,440 --> 00:08:38,430
I like that

122
00:08:38,429 --> 00:08:43,739
pros and cons there cross-referencing
views are still there so you can find

123
00:08:43,740 --> 00:08:44,730
the string view

124
00:08:44,730 --> 00:08:47,700
josh is going to do the demo part so
he's kind of giving you the meat i'm

125
00:08:47,700 --> 00:08:51,870
giving you more the overview he's going
to actually do a demo of showing you the

126
00:08:51,870 --> 00:08:56,160
look and feel of Bingen vs Ida and
looking at a script we wrote just a

127
00:08:56,160 --> 00:08:59,490
simple script and there's nothing really
special about it is for a piece of

128
00:08:59,490 --> 00:09:03,360
malware is basically how hard is it to
write it for idea how hard is it to port

129
00:09:03,360 --> 00:09:08,100
it to binge I basically was kind of our
task is to see if it was comparable so

130
00:09:08,100 --> 00:09:11,820
you'll see a lot of that like I said the
strings view is there you can find that

131
00:09:11,820 --> 00:09:16,620
it didn't seem like the cross references
in strings you was quite as good engine

132
00:09:16,620 --> 00:09:20,610
I didn't see that so there's a list of
the hotkeys I'll just leave that for you

133
00:09:20,610 --> 00:09:24,270
they're pretty similar so like if you
hit G for example to go to a particular

134
00:09:24,270 --> 00:09:30,630
location is the same an idea or benja
the patching and modification i think is

135
00:09:30,630 --> 00:09:34,560
definitely going to be better especially
in the long term and even now inja

136
00:09:34,560 --> 00:09:38,550
because their background is really more
vulnerability research so that's been

137
00:09:38,550 --> 00:09:40,709
more of their focus

138
00:09:40,710 --> 00:09:44,520
a lot of the work they've done revolves
around you know being able to change in

139
00:09:44,520 --> 00:09:48,360
patch and shell code and find bugs and
all that kind of stuff so the patching

140
00:09:48,360 --> 00:09:53,100
and modification part invention is
really top-notch got a link there to the

141
00:09:53,100 --> 00:09:57,810
SEC binary . ninja and that's it will
show some other documentation links but

142
00:09:57,810 --> 00:10:05,040
you can find all the documentation on
those links as well so what is il and

143
00:10:05,040 --> 00:10:09,480
basically you know i'm not going to go
into a long-winded explanation of it but

144
00:10:09,480 --> 00:10:13,980
I get it allows for an intermediate view
of the assembly so that cool things can

145
00:10:13,980 --> 00:10:18,930
be done so that you know the
simplification of a new architecture can

146
00:10:18,930 --> 00:10:19,770
be added

147
00:10:19,770 --> 00:10:24,090
that's something that Jordan his team
ninja they really feel like the aisle

148
00:10:24,090 --> 00:10:29,400
that they have is gonna help them in the
long run to create their decompiler to

149
00:10:29,400 --> 00:10:31,890
do a lot of things that they're going to
do to not only catch up but in the long

150
00:10:31,890 --> 00:10:36,390
run excel so the is available in
invention is really exciting i encourage

151
00:10:36,390 --> 00:10:39,660
you to kind of dig deep into that it's
sort of a deeper compiler theory type

152
00:10:39,660 --> 00:10:42,390
subject that I'm definitely not going to
go over today it's not a broadly

153
00:10:42,390 --> 00:10:46,650
accessible think it's kinda down in the
weeds but if you just to take a look

154
00:10:46,650 --> 00:10:51,300
like it the at the very bottom of it i'm
on the assembly there's a je which is

155
00:10:51,300 --> 00:10:56,640
jump and assembly right we're in the ilu
see it as more of an if so you get kind

156
00:10:56,640 --> 00:11:02,819
of a slightly higher level view of the
logic not necessarily decompile it's not

157
00:11:02,820 --> 00:11:05,700
see or anything like that but you get a
little bit more intermediate

158
00:11:05,700 --> 00:11:10,530
representation which we thought was cool
same thing in arm if you are of a jump

159
00:11:10,530 --> 00:11:14,670
versus just using the words if it's a
little more accessible maybe so we like

160
00:11:14,670 --> 00:11:18,360
that we thought that was pretty awesome
that you could get that now one of the

161
00:11:18,360 --> 00:11:22,440
common questions that people ask me is
so well I mean I heard you talking about

162
00:11:22,440 --> 00:11:25,710
your ninja what architectures by aegis
four you can go to the website and find

163
00:11:25,710 --> 00:11:31,980
out and quite a few like the x86 the arm
its 6502 but definitely not as exhausted

164
00:11:31,980 --> 00:11:33,930
as a tool that's been around 20 years
right

165
00:11:33,930 --> 00:11:38,250
you look at the list of things that I to
support its like Qualcomm Snapdragon the

166
00:11:38,250 --> 00:11:41,730
gameboy fujitsu like all these crazy
architectures like I don't even know

167
00:11:41,730 --> 00:11:45,840
right like who I i do I don't find
myself reversing that a lot but if you

168
00:11:45,840 --> 00:11:50,040
do then i might be the tool in that case
right me to make sense come on

169
00:11:50,040 --> 00:11:50,920
so

170
00:11:50,920 --> 00:11:55,599
um this is kind of where we begin to get
into the meat here so the plugins we

171
00:11:55,600 --> 00:11:57,940
wanted to take a look at what does it
take to write one

172
00:11:57,940 --> 00:12:02,589
what's the interface look like how do
you transition and existing Ida plug-in

173
00:12:02,589 --> 00:12:08,110
to a ninja plug-in and that's going to
be an important thing that needs to

174
00:12:08,110 --> 00:12:11,470
happen and I'm sure that something that
Jordan rusty and his crew would love

175
00:12:11,470 --> 00:12:16,060
your help your support get the community
involved in that because what happens is

176
00:12:16,060 --> 00:12:21,040
idea has a lot of this right if you are
Matt where author and are no matter

177
00:12:21,040 --> 00:12:24,639
author I'm malware analysis analyst if
you're malware authors you might do this

178
00:12:24,639 --> 00:12:26,260
too

179
00:12:26,260 --> 00:12:33,069
I need obviously need my starbucks
caramel or analyst you probably have

180
00:12:33,070 --> 00:12:39,160
some plugins for Ida that help you do
your auntie you know deification

181
00:12:39,160 --> 00:12:43,000
techniques and all this stuff especially
if you're doing runtime analysis right

182
00:12:43,000 --> 00:12:46,209
and that's one place where I definitely
excels right now is they have a debugger

183
00:12:46,209 --> 00:12:49,989
built-in web engine doesn't so if you're
gonna do runtime stuff and you've got

184
00:12:49,990 --> 00:12:54,370
special plugins and you're doing it
because you work on our own windows is

185
00:12:54,370 --> 00:12:59,199
going to be your thing but that can very
easily change and one of the ways that

186
00:12:59,199 --> 00:13:04,000
can changes is a the vector 35 group
they've got a vision for a whole

187
00:13:04,000 --> 00:13:08,949
community around plugins that as those
begin to port and change and come to be

188
00:13:08,949 --> 00:13:12,640
a ninja they'll be a lot more organized
to be a lot more accessible that'll be

189
00:13:12,640 --> 00:13:17,110
easier to write that we faster this
whole sort of App Store idea i guess is

190
00:13:17,110 --> 00:13:21,459
jordan's vision I think for what he
wants to do with plugins for binge and

191
00:13:21,459 --> 00:13:24,219
that's something right now that I
doesn't really have it's pretty much

192
00:13:24,220 --> 00:13:27,399
like you gotta go out and surf the
interwebs and troll some shady sites and

193
00:13:27,399 --> 00:13:30,130
then I like found this plug-in like it's
their kind of they're not always easy to

194
00:13:30,130 --> 00:13:35,019
find in every case so that's the scoop
with plugins right now so they you know

195
00:13:35,019 --> 00:13:38,319
there's going to be supporting that
needs to be done in the short term for

196
00:13:38,319 --> 00:13:44,829
sure so i'll let Josh go over that the
api's and take a look at that one of the

197
00:13:44,829 --> 00:13:48,489
other things it's cool about binges it
has an undue which is not something I'd

198
00:13:48,490 --> 00:13:52,720
ever have so we thought that's a that's
something that's missing for a long time

199
00:13:52,720 --> 00:13:53,810
so

200
00:13:53,810 --> 00:13:57,800
I you know we gotta we gotta throw that
in there so on that note I'm going to

201
00:13:57,800 --> 00:14:04,010
turn it over to Josh and he's kind of
get in the weeds a little bit like Jared

202
00:14:04,010 --> 00:14:07,790
um I spent all night while you guys were
partying making that video so I hope you

203
00:14:07,790 --> 00:14:09,620
enjoy it

204
00:14:09,620 --> 00:14:14,510
well my name is Joshua I'm a two jobs
today one is totally explain or conveyed

205
00:14:14,510 --> 00:14:17,569
a little bit more of the technical not
going all the way into the weeds about

206
00:14:17,570 --> 00:14:21,110
the script of our sample the problem i
set out to tackle for this particular

207
00:14:21,110 --> 00:14:25,460
demo use case the other thing I need to
do is suck all the humor of out of the

208
00:14:25,460 --> 00:14:29,210
rest of the afternoon so bear with me
here as we get a little bit deeper than

209
00:14:29,210 --> 00:14:34,790
the overview so I what we started I want
to look for was just a simple sample

210
00:14:34,790 --> 00:14:38,390
that exhibited some characteristic
something that find myself doing over

211
00:14:38,390 --> 00:14:43,430
and over again and one of those and what
I found was a sample is really just a

212
00:14:43,430 --> 00:14:47,569
common dropper but it was dynamic
resolving the API calls it was making so

213
00:14:47,570 --> 00:14:50,810
I was finding a bunch of call to
register so an indirect call and I

214
00:14:50,810 --> 00:14:54,680
figured out there quickly where it was
obvious candidate bunch of hashes in

215
00:14:54,680 --> 00:14:57,890
order to resolve the modules and
eventually the api's within those

216
00:14:57,890 --> 00:15:00,920
modules to make those calls so finding
those addresses putting into the

217
00:15:00,920 --> 00:15:04,490
register of course than making that call
as an analyst at something that's a bit

218
00:15:04,490 --> 00:15:07,070
frustrating because it slows us down we
don't understand exactly what that

219
00:15:07,070 --> 00:15:10,700
samples doing until we can figure out
what those calls are so I thought that

220
00:15:10,700 --> 00:15:13,580
would be a great use case especially
something that would be achievable

221
00:15:13,580 --> 00:15:17,240
maintainable to set out and do with in
binary integer actually started with ida

222
00:15:17,240 --> 00:15:21,260
and a Python script and then converted
into binary ninja here you can see the

223
00:15:21,260 --> 00:15:23,510
mp5 the virus total score

224
00:15:23,510 --> 00:15:26,390
it's also in our github account so we'll
have a link here at the end of the

225
00:15:26,390 --> 00:15:29,630
slides if you're interested to pull down
not only the sample as well as the

226
00:15:29,630 --> 00:15:31,189
script those are available

227
00:15:31,190 --> 00:15:34,580
um first head-on packet so of course
that's usually one of the first things

228
00:15:34,580 --> 00:15:38,930
we have to do with malware and nothing
too extravagant there i have a fairly

229
00:15:38,930 --> 00:15:42,859
simple i think i'm a fairly routine
approach to the obvious skating and

230
00:15:42,860 --> 00:15:46,459
getting that unpack binary out that is
typically have either watch the process

231
00:15:46,459 --> 00:15:49,880
creation and kind of get an idea what
it's doing first to determine if it is

232
00:15:49,880 --> 00:15:54,560
pack and then the other is put into
bugger probably put some break points on

233
00:15:54,560 --> 00:15:58,310
the memory allocations and just track
those memory allocations until I find in

234
00:15:58,310 --> 00:16:02,479
memory the P header signatures that I
can dump that memory that's likely my

235
00:16:02,480 --> 00:16:05,870
unpack binary I don't spend a lot of
time trying to figure out how it was

236
00:16:05,870 --> 00:16:07,440
packed so in this case definitely

237
00:16:07,440 --> 00:16:13,200
dealing with any of that it's avoiding
strings and supporting imports so all

238
00:16:13,200 --> 00:16:17,670
the calls are dynamic so once this
sample was unpacked it was just a bunch

239
00:16:17,670 --> 00:16:20,849
of instructions there's nothing in there
that gave me any insight into what did

240
00:16:20,850 --> 00:16:25,560
without further damage dynamic analysis
how it did that was again fairly

241
00:16:25,560 --> 00:16:29,430
straightforward so I think the value is
a script like this is it something that

242
00:16:29,430 --> 00:16:33,599
I'll be able to use or hopefully adopt
over and over again here as I look at

243
00:16:33,600 --> 00:16:37,740
and analyze more samples so it has kind
of two main portions to it

244
00:16:37,740 --> 00:16:41,490
the first is to dynamically located the
module that wants to fall finally API

245
00:16:41,490 --> 00:16:45,840
calls it so kernel32 for example so it's
gonna walk the pad in order to find the

246
00:16:45,840 --> 00:16:49,410
currently loaded modules for that
process once it finds those the ones

247
00:16:49,410 --> 00:16:53,430
that is seeking anyway then it has a
base address from there it can use the

248
00:16:53,430 --> 00:16:57,390
the PE file format to start from that
base address and figure out where the

249
00:16:57,390 --> 00:17:01,230
exports are the exports then are
essentially hashed compared to the

250
00:17:01,230 --> 00:17:05,130
hashes that are hard-coded in the sample
and it has the address from there

251
00:17:05,130 --> 00:17:08,939
so then it can populate a essentially a
destination array and array of addresses

252
00:17:08,939 --> 00:17:11,520
that it knows which one is which in
order to make the calls a little bit

253
00:17:11,520 --> 00:17:20,459
later on can see no strings no weapon no
imports and exports i'm very sad and

254
00:17:20,459 --> 00:17:24,660
this is a sample here in the disassembly
view of the problem so we've got this

255
00:17:24,660 --> 00:17:29,130
push pop and call so we know that D word
is going to be what's pushed into her

256
00:17:29,130 --> 00:17:38,070
eventually move into that register but I
don't know what it is ok as Jared

257
00:17:38,070 --> 00:17:41,580
alluded to a little bit earlier i really
had I think two options in a normal

258
00:17:41,580 --> 00:17:46,020
workflow what which was already starting
to figure out what these registers are I

259
00:17:46,020 --> 00:17:49,770
could continue with a static approach in
this case the sample is relatively small

260
00:17:49,770 --> 00:17:53,040
so it probably would have been a lot
quicker to just dynamically do it that

261
00:17:53,040 --> 00:17:56,850
is maybe set a few break points at a lot
of these indirect call sites and then

262
00:17:56,850 --> 00:18:00,510
comment and change the names of the
symbols as I went but that wasn't really

263
00:18:00,510 --> 00:18:02,940
the point I wanted to solve the
statically in order to produce the

264
00:18:02,940 --> 00:18:07,170
script so I went that route anyway this
also is where i started have to deviate

265
00:18:07,170 --> 00:18:10,920
a little bit of my workflow so normally
with with IDA pro I'd set the

266
00:18:10,920 --> 00:18:14,910
breakpoints i connected to my local
win32 debugger window bug and I go ahead

267
00:18:14,910 --> 00:18:20,010
and start debug integrated it's nice i
can see the values and those registers

268
00:18:20,010 --> 00:18:20,980
then as i hit my break

269
00:18:20,980 --> 00:18:25,660
points and then I'm able to add comments
or rename symbols as i go with binary

270
00:18:25,660 --> 00:18:29,440
image I had to bring up a lot of butter
or just use is so little bit of a

271
00:18:29,440 --> 00:18:32,230
difference there just because there
isn't that integrated debugger support

272
00:18:32,230 --> 00:18:35,890
at this time I've seen some plugins or
at least one that is trying to bridge

273
00:18:35,890 --> 00:18:39,910
that gap but i'm sure there's probably a
roadmap for it as well but just a little

274
00:18:39,910 --> 00:18:45,700
bit of a deviation so the next part was
to implement the functionality to figure

275
00:18:45,700 --> 00:18:49,570
out the functionality and then implement
statically so going through this is one

276
00:18:49,570 --> 00:18:53,139
of the first calls identified
essentially a start and then a main into

277
00:18:53,140 --> 00:18:56,290
this program and so I jumped right ahead
this is the main method or what i

278
00:18:56,290 --> 00:19:01,149
considered main this is a really good
example of how this process in the

279
00:19:01,150 --> 00:19:04,900
sample work the first function is going
to resolve the module the second is

280
00:19:04,900 --> 00:19:08,260
going to resolve all the api's and wants
to call from within that module and then

281
00:19:08,260 --> 00:19:11,290
that last call is going to be the
indirect called whatever API that it

282
00:19:11,290 --> 00:19:15,010
wants to make a call to someone you
might recognize just by the signature of

283
00:19:15,010 --> 00:19:18,400
that those pushes before that call that
it's a virtual a lock but we'll see that

284
00:19:18,400 --> 00:19:19,780
here in just a moment

285
00:19:19,780 --> 00:19:23,410
the first thing it does you can see the
very first instruction they're listed in

286
00:19:23,410 --> 00:19:26,860
that screenshot is the hash so that's
the hard code hash it moves into a

287
00:19:26,860 --> 00:19:30,729
register so with these next two
functions all of the parameters are

288
00:19:30,730 --> 00:19:35,770
essentially being asked to register so
ebx is loaded with that value that hash

289
00:19:35,770 --> 00:19:40,600
watch the pad returns an ETA X the value
of the address of the module that it's

290
00:19:40,600 --> 00:19:46,600
after we can see later on that as that
next function is called Dax is moving

291
00:19:46,600 --> 00:19:50,949
EVP so that's how that knows what base
address what module to start looking for

292
00:19:50,950 --> 00:19:55,870
try to resolve those calls those
addresses for the API calls on the next

293
00:19:55,870 --> 00:20:01,120
two instructions after the first call le
si le di that is the addresses for the

294
00:20:01,120 --> 00:20:04,330
source so it's an array of d words
especially those hands of those hashes

295
00:20:04,330 --> 00:20:05,918
that are going to be prepared

296
00:20:05,919 --> 00:20:08,530
they're going to genetically dynamically
generated and compared to find the

297
00:20:08,530 --> 00:20:13,178
address and then the DI is gonna be the
destination it's another array that

298
00:20:13,179 --> 00:20:16,990
after the samples have the ability to
run its going to be populated with

299
00:20:16,990 --> 00:20:17,890
addresses

300
00:20:17,890 --> 00:20:22,750
ok when that returns then you can see
getting to that last call

301
00:20:23,320 --> 00:20:26,678
there's a push d-word some one of those
elements is pushed on the stack popped

302
00:20:26,679 --> 00:20:29,350
off the stack moved into the register
that were going to call from

303
00:20:29,350 --> 00:20:39,490
those are my notes just in case i forgot
that ok so the functionality between the

304
00:20:39,490 --> 00:20:45,039
two were really rather similar so they
had a very similar approach in bars how

305
00:20:45,039 --> 00:20:48,580
they actually generated the hash so
instead of going through both of those i

306
00:20:48,580 --> 00:20:52,270
decided to skip how the module has
created and just jump right into how it

307
00:20:52,270 --> 00:20:55,990
actually resolve the API so in this case
when that function is called that was

308
00:20:55,990 --> 00:20:59,919
the second call that we have from the
previous slide we are assuming passed by

309
00:20:59,919 --> 00:21:04,000
that eax register that we have the base
address for module so it's able to then

310
00:21:04,000 --> 00:21:10,900
parse that structure it's a deal else a
PE file define those imports it has once

311
00:21:10,900 --> 00:21:14,679
it has access to all those explore I'm
sorry nothing important the exports its

312
00:21:14,679 --> 00:21:17,650
going to compare those it's going to
generate a half resection export my name

313
00:21:17,650 --> 00:21:22,450
and it's just going to simply do that by
iterating over each character of the

314
00:21:22,450 --> 00:21:25,990
export named character by character
doing a little bit manipulation along

315
00:21:25,990 --> 00:21:29,470
the way to eventually create the hashes
it gets the end of the name into that

316
00:21:29,470 --> 00:21:33,580
string then it has the hash that hashes
then compared to one of those is

317
00:21:33,580 --> 00:21:38,199
hard-coded and if the hashes are the
same then it returns the address so it's

318
00:21:38,200 --> 00:21:42,789
found the address of the export that
wants to call if not it continues on and

319
00:21:42,789 --> 00:21:47,020
it does this for every single value that
every single half so that's looking for

320
00:21:47,020 --> 00:21:50,020
resolving those as it goes

321
00:21:53,020 --> 00:21:57,490
so the scripts will take a look at the
full script in just a moment I wanted to

322
00:21:57,490 --> 00:22:01,539
take a couple of slides here to explain
a little bit more detail kind of the the

323
00:22:01,539 --> 00:22:06,850
core differences between the two scripts
and i found as I not only wrote them but

324
00:22:06,850 --> 00:22:10,750
Jordan and his team were very gracious
to give me some feedback on my first and

325
00:22:10,750 --> 00:22:15,580
admittedly rather rough draft of the
script they see that they really come

326
00:22:15,580 --> 00:22:20,500
together there's a lot of overlap
between the two so with this this is the

327
00:22:20,500 --> 00:22:26,380
binary ninja script and you can see with
that first function what we're getting

328
00:22:26,380 --> 00:22:30,640
is essentially a function object and I'm
passing it in the address of where I

329
00:22:30,640 --> 00:22:33,549
want to start so that's what I that's
the hard-coded address that i consider

330
00:22:33,549 --> 00:22:38,110
to be my main function from Maine going
to go through each block and each block

331
00:22:38,110 --> 00:22:42,399
of code with his pocket code then i'm
also going to get all the instructions

332
00:22:42,400 --> 00:22:47,020
the il-4 each for each instruction
within that block from there it's really

333
00:22:47,020 --> 00:22:52,510
just a matter of looking for the call
target because why would I decided to

334
00:22:52,510 --> 00:22:55,900
break on so that I could figure out what
those resolve all the api called

335
00:22:55,900 --> 00:22:59,560
statically is when I saw the call to
that very first function so I have I

336
00:22:59,560 --> 00:23:05,740
just called a module result module API
address resolve API address so with this

337
00:23:05,740 --> 00:23:10,690
one actually I I break down the address
for the result of the API so the second

338
00:23:10,690 --> 00:23:14,350
to last call and the reason I did that
was because with some of these

339
00:23:14,350 --> 00:23:17,320
instructions a little bit later on
you'll see that when i get to that call

340
00:23:17,320 --> 00:23:20,710
instruction then i can actually ask it
for the values of the registers that

341
00:23:20,710 --> 00:23:23,890
preceded that and this is a really good
example of that because I knew those

342
00:23:23,890 --> 00:23:27,130
registers are going to have static
values moved in was able to query those

343
00:23:27,130 --> 00:23:32,140
the register state that call instruction
to get those values so first thing

344
00:23:32,140 --> 00:23:37,210
resolve the module by hash i generated
the hash function looking for and

345
00:23:37,210 --> 00:23:40,930
determining what the actual dll was and
in the static case here in the script I

346
00:23:40,930 --> 00:23:43,870
didn't actually need an address i'm not
dealing with the virtual address space

347
00:23:43,870 --> 00:23:47,889
here I just need to know which dl it was
so that I could later on parts that PE

348
00:23:47,890 --> 00:23:53,170
and walk the exports once i found it the
next thing I did was called the result

349
00:23:53,170 --> 00:23:56,740
module api's so that was the function
then that was responsible for parsing

350
00:23:56,740 --> 00:24:00,460
that p during the hash for each export
and then comparing it from those

351
00:24:00,460 --> 00:24:04,990
hard-coded hashes in the original sample
as that resolve those I knew the name i

352
00:24:04,990 --> 00:24:07,960
can update the symbols and I had better
visibility into what the sample was

353
00:24:07,960 --> 00:24:18,010
doing ok same section and the I descript
not a whole lot different here slightly

354
00:24:18,010 --> 00:24:22,510
different functions of course different
API but same process we're going through

355
00:24:22,510 --> 00:24:23,410
each instruction

356
00:24:23,410 --> 00:24:26,410
I'm looking for the call once i find the
call i'm able to pull all the

357
00:24:26,410 --> 00:24:30,730
information I need in order to resolve
those api's with this one though I had

358
00:24:30,730 --> 00:24:34,510
to adjust just a little bit and that I
looked for not the call to resolve the

359
00:24:34,510 --> 00:24:39,100
actual API where I had the name of the
module but where I called the module

360
00:24:39,100 --> 00:24:42,340
because once i knew i was at that point
I could look at the previous instruction

361
00:24:42,340 --> 00:24:46,449
to get the module hash I could go then
to structions beyond beyond the hammer

362
00:24:46,450 --> 00:24:50,650
iterate and find the destination of the
source of the hashes as well so once i

363
00:24:50,650 --> 00:24:54,040
found that call I had everything I
needed from there so a slight difference

364
00:24:54,040 --> 00:24:56,020
in the two scripts just based off of
highlight

365
00:24:56,020 --> 00:25:01,120
i was able to walk back and forth from
the current instruction now as I

366
00:25:01,120 --> 00:25:05,560
mentioned this is where i felt i was
able to really simplify my script my

367
00:25:05,560 --> 00:25:10,060
first time through what I ended up doing
was I didn't know how to effectively get

368
00:25:10,060 --> 00:25:13,960
those values from those registers i
found that Paul site and I wanted to get

369
00:25:13,960 --> 00:25:18,520
ESInet I dbx and these values that were
previous instructions and I wasn't quite

370
00:25:18,520 --> 00:25:22,000
sure how to do that so I ended up doing
my first time through was simply

371
00:25:22,000 --> 00:25:24,820
creating a list and appending all these
I'll instructions to list and then

372
00:25:24,820 --> 00:25:28,000
keeping track of some sort of a counter
so that when I knew I got to that call

373
00:25:28,000 --> 00:25:32,590
site i could go back in my list pull out
the IL plot the values and that bloated

374
00:25:32,590 --> 00:25:36,669
the script quite a bit finally was
pointed out to me through some help that

375
00:25:36,670 --> 00:25:40,960
i could just create those registers so
you can see here that's what this is

376
00:25:40,960 --> 00:25:45,850
doing so that may not get register value
at means our function i passed the

377
00:25:45,850 --> 00:25:49,090
address i tell it what register I want
and I tell it's giving the property

378
00:25:49,090 --> 00:25:53,110
value and now I have a source and the
destination so those addresses that i

379
00:25:53,110 --> 00:26:01,929
was looking for within this particular
binary kinda similar concept but i had

380
00:26:01,930 --> 00:26:05,710
to use next had previous head so I just
had to move from the current instruction

381
00:26:05,710 --> 00:26:10,270
that I was on using that head object
that to go back and then also to

382
00:26:10,270 --> 00:26:12,370
increment so that i could get those
values

383
00:26:12,370 --> 00:26:23,050
alright so at this point probably the
scariest for me is to do the demo demo

384
00:26:23,050 --> 00:26:26,980
as well as walk through the scripts is
that even legible

385
00:26:27,610 --> 00:26:35,199
yeah okay okay so i'm going to try to
compare them side-by-side and just point

386
00:26:35,200 --> 00:26:37,030
out a few things here long as we go

387
00:26:37,030 --> 00:26:39,730
you can see hopefully that there's quite
a bit of overlap there's quite a bit of

388
00:26:39,730 --> 00:26:44,530
similarity between the two scripts so
imports the addresses are a little bit

389
00:26:44,530 --> 00:26:47,410
different and they are different because
I explained to have a slightly different

390
00:26:47,410 --> 00:26:51,580
approach as far as determining when to
trigger the functionality of my script I

391
00:26:51,580 --> 00:26:56,379
had a heck of a time finding any real
good bit manipulation functions so i had

392
00:26:56,380 --> 00:27:01,510
to find this rotate left implementation
on the internet and kept a source there

393
00:27:01,510 --> 00:27:04,720
i have two functions to help create the
module hash

394
00:27:05,400 --> 00:27:12,420
how folks are getting here

395
00:27:12,420 --> 00:27:16,920
unfortunately what video capture devices
flaked out on us so we don't have any

396
00:27:16,920 --> 00:27:20,850
audio us to talk but hopefully we got
most of the content here sorry for the

397
00:27:20,850 --> 00:27:20,939
problems

