1
00:00:00,000 --> 00:00:46,539
get started afternoon everyone my name
is Christopher goma's I'm a

2
00:00:46,539 --> 00:00:49,440
cyber-security researcher at a place
called the Battelle Memorial Institute

3
00:00:49,440 --> 00:00:53,410
been a pretty fun place to work I gotta
do a lot of really interesting things

4
00:00:53,410 --> 00:00:57,710
their thing I like most about it is give
me a lot of really off the wall ideas

5
00:00:57,710 --> 00:01:01,050
for creating things to pursue my free
time slots when I want to talk to you

6
00:01:01,050 --> 00:01:05,010
about today's something I've been
tinkering with my free time over the

7
00:01:05,010 --> 00:01:09,460
last couple months so this whole thing
has to do with her Skoda engineering so

8
00:01:09,460 --> 00:01:13,460
if you're not familiar with the concept
of reverse engineering Cody ideas we can

9
00:01:13,460 --> 00:01:18,490
take an executable like a dot out here
and we can disassemble it to look at the

10
00:01:18,490 --> 00:01:21,920
smallest instructions inside at the
stadium by looking at these individual

11
00:01:21,920 --> 00:01:25,549
instructions we can figure out exactly
what this program can understand a

12
00:01:25,549 --> 00:01:30,049
program at this level we can exploit
and/or modify or copy it probably in a

13
00:01:30,049 --> 00:01:34,270
way that the original author within like
so that's the idea behind reverse

14
00:01:34,270 --> 00:01:39,950
engineering so while back how is killing
some time on the site I like re mass to

15
00:01:39,950 --> 00:01:43,610
get help site with lots and lots of
interesting articles I was looking for

16
00:01:43,610 --> 00:01:48,759
an article to spend some time reading in
this one by a guy named Steven dolan

17
00:01:48,759 --> 00:01:53,479
really caught my interest right away so
dolenz article starts out with a really

18
00:01:53,479 --> 00:01:57,939
humorous observation about the x86
architecture he observes that it is well

19
00:01:57,939 --> 00:02:02,850
known that the x86 instruction set is
purok over complicated and redundant

20
00:02:02,850 --> 00:02:06,640
redundant which showed us how much fluff
it has by demonstrating that remains

21
00:02:06,640 --> 00:02:09,119
churning complete reduced to just one

22
00:02:09,119 --> 00:02:13,610
instruction so right away that opening
paragraph just blew my mind I thought

23
00:02:13,610 --> 00:02:17,030
I've been using x86 for twenty years and
I had no idea such an instruction

24
00:02:17,030 --> 00:02:18,390
existed

25
00:02:18,390 --> 00:02:22,980
what instruction is this what magical
instruction is somehow capturing

26
00:02:22,980 --> 00:02:29,159
complete entirely by itself so it turns
out it's the simplest instruction higher

27
00:02:29,159 --> 00:02:34,010
architectures the movie struction saul
does is it unconditionally copies data

28
00:02:34,010 --> 00:02:40,269
from one location to another really just
that simple but apparently move is

29
00:02:40,269 --> 00:02:46,349
trying to unseat boy does that mean well
I'm using any code that we write could

30
00:02:46,349 --> 00:02:51,950
be written as a set of moves and
absolutely nothing else but the more you

31
00:02:51,950 --> 00:02:55,049
think about that the more impossible
it's easy to think of all the incredible

32
00:02:55,049 --> 00:03:01,329
complex things are towed has to do like
arithmetic comparison branching function

33
00:03:01,329 --> 00:03:07,470
calls you telling me that we can do all
of that with just moves that that seems

34
00:03:07,470 --> 00:03:14,030
impossible but it turned complete and
has to be true the more I thought about

35
00:03:14,030 --> 00:03:19,819
that the more I realize that be kinda
hard to reverse engineer wouldn't it was

36
00:03:19,819 --> 00:03:23,180
written in only move instructions
because we start with code like this

37
00:03:23,180 --> 00:03:26,569
where even without a lot of assembly
background with kinda look at this and

38
00:03:26,569 --> 00:03:31,389
understand what's going on are doing
here is we're loading 0 into memory

39
00:03:31,389 --> 00:03:34,700
that's gonna be setting a local variable
20 them are pushing an argument on the

40
00:03:34,700 --> 00:03:38,419
stack and printing it out with a
function call for removing an argument

41
00:03:38,419 --> 00:03:42,760
from a stack and adding 12 our local
variable when comparing our local

42
00:03:42,760 --> 00:03:46,340
variable two hundred and if it's less
than or equal to a hundred we jump back

43
00:03:46,340 --> 00:03:49,760
to the beginning and repeat this whole
thing over again so all this does is it

44
00:03:49,760 --> 00:03:53,569
print something out a hundred times it
is that the individual instructions

45
00:03:53,569 --> 00:03:58,090
being used as a monitor themselves tell
us exactly what's going on the phone for

46
00:03:58,090 --> 00:04:02,370
the control flow in this program tells
us what this program is doing so it's

47
00:04:02,370 --> 00:04:06,099
really easy to get those clues about
what's happening here in decipher what

48
00:04:06,099 --> 00:04:10,340
this program supposed to be before to
rewrite this entire thing with just

49
00:04:10,340 --> 00:04:14,879
unconditional move instructions we would
lose all all the clues behind for

50
00:04:14,879 --> 00:04:17,320
reverse engineering are suddenly gone

51
00:04:17,320 --> 00:04:22,220
we just have this indecipherable stream
unconditional data transfers this will

52
00:04:22,220 --> 00:04:25,250
be a reverse engineering nightmare we
could really stop people from

53
00:04:25,250 --> 00:04:31,620
understanding or modifying exploiting
our code if this way is dead but in

54
00:04:31,620 --> 00:04:34,700
order to make that happen we have to
understand a little bit about what it

55
00:04:34,700 --> 00:04:38,800
machine really is sort of an academic
level 3 machines like this

56
00:04:38,800 --> 00:04:42,830
52 bowl of things where one of them is
finite set of states and others

57
00:04:42,830 --> 00:04:46,290
extinguish starting state once a finite
set of symbols you got this

58
00:04:46,290 --> 00:04:49,980
distinguished playing simple and you've
got the transition table Delta that kind

59
00:04:49,980 --> 00:04:54,260
of maps to cross products human Sigma
honor the cross product using mine

60
00:04:54,260 --> 00:04:57,120
either left or right and what that
actually gives you is like the state

61
00:04:57,120 --> 00:05:01,840
transition diagram a way of moving
between states changing symbols that's

62
00:05:01,840 --> 00:05:05,710
the approach golden touch in his paper
he traded this

63
00:05:05,710 --> 00:05:09,650
shearing machine showed how to move
instruction could move between different

64
00:05:09,650 --> 00:05:13,720
states in the Turing machine and that
that's a proof that move is chairing

65
00:05:13,720 --> 00:05:17,960
complete so is really fascinating figure
out that this really simple instruction

66
00:05:17,960 --> 00:05:23,230
is somehow tearing complete but he plays
in practice you can find that that's

67
00:05:23,230 --> 00:05:28,030
really purely academic because this
state transition diagram has so far

68
00:05:28,030 --> 00:05:32,590
removed from the processes that we use
everyday you can't get much useful

69
00:05:32,590 --> 00:05:36,990
information about her from this proof
that movie starring complete and

70
00:05:36,990 --> 00:05:41,910
technologists this sort of
tongue-in-cheek concludes article on

71
00:05:41,910 --> 00:05:45,390
removing all but the move instruction
from future iterations of the x86

72
00:05:45,390 --> 00:05:49,730
architecture we have many advantages
instruction format will be simplified

73
00:05:49,730 --> 00:05:54,010
extensive decoding it would become much
cheaper than currently used for complex

74
00:05:54,010 --> 00:05:58,610
functional units to be repurposed as
even more cash as long as someone else

75
00:05:58,610 --> 00:06:03,800
implements the compiler so I really
really like dolenz idea was really

76
00:06:03,800 --> 00:06:08,940
amused by his approach here so I read
that last sentence I could do that

77
00:06:08,940 --> 00:06:15,840
on meet your compiler challenge accepted
so I set out to build this is moved

78
00:06:15,840 --> 00:06:20,050
compiler but it's kind of a daunting
prospect train she's literally just

79
00:06:20,050 --> 00:06:24,290
ahead that means back and forth
imitating changes how do we go from that

80
00:06:24,290 --> 00:06:29,990
definition to an actual compiler
fortunately dolenz paper had no idea

81
00:06:29,990 --> 00:06:33,930
that we could borrow from and start to
build one of those really interesting

82
00:06:33,930 --> 00:06:38,250
eight years at the move instruction can
actually check for equality for example

83
00:06:38,250 --> 00:06:41,980
let's say we had two numbers X&Y wanted
to figure out whether or not

84
00:06:41,980 --> 00:06:46,440
X&Y were equal to each other using only
the move instruction

85
00:06:46,440 --> 00:06:51,450
dolenz idea was we could write 02 memory
address s right ones memory address why

86
00:06:51,450 --> 00:06:55,980
read back from memory address X now tell
us whether or not these two numbers were

87
00:06:55,980 --> 00:06:58,090
equal to its imagine a true I R E

88
00:06:58,090 --> 00:07:03,460
Texas three NY history this is right 02
memory address three right 12 memory

89
00:07:03,460 --> 00:07:08,120
address three men read that her memory
address 302 memory address three was a

90
00:07:08,120 --> 00:07:13,370
one so we've got the one telling us that
these two values what if they weren't X

91
00:07:13,370 --> 00:07:18,950
was 23 says right here to memory address
to write 12 memory address three in

92
00:07:18,950 --> 00:07:25,150
rebate for memory address to blasting we
just wrote memory address to 100 telling

93
00:07:25,150 --> 00:07:29,480
us things aren't so if three move
instructions we just implemented

94
00:07:29,480 --> 00:07:34,050
inequality chest so that's that's really
neat gives us a step forward and other

95
00:07:34,050 --> 00:07:40,490
key a firm dole's paper was there's
gonna be 13 2011 code is moving truck

96
00:07:40,490 --> 00:07:44,050
got no way to branch you got nobody
skipping thank all of your instructions

97
00:07:44,050 --> 00:07:48,680
to execute every time no matter what but
you design your program correctly a

98
00:07:48,680 --> 00:07:53,240
block of moves can either have an effect
or have no effect just depending on the

99
00:07:53,240 --> 00:07:58,470
initial state the systems we can apply
that and just a little bit another key a

100
00:07:58,470 --> 00:08:03,570
landscaper is history machine required
single jump instruction to look back to

101
00:08:03,570 --> 00:08:07,030
the beginning other programs that kinda
sounds like a cheater trying to stick

102
00:08:07,030 --> 00:08:10,120
with just move instructions but that
really doesn't violate tutoring

103
00:08:10,120 --> 00:08:15,000
completeness of moves out a bit later on
how we can actually fix that issue but

104
00:08:15,000 --> 00:08:17,180
this is what dolenz program would look
like

105
00:08:17,180 --> 00:08:21,930
instructions followed by a jump back to
the beginning

106
00:08:21,930 --> 00:08:26,930
of the program is turning machine design
also required an invalid memory address

107
00:08:26,930 --> 00:08:31,110
for halting basically these moves in the
infinite loop we need some way to stop

108
00:08:31,110 --> 00:08:34,500
our program so Dolan said just a scene
that there's some invalid memory address

109
00:08:34,500 --> 00:08:38,679
when you access that the system so
there's a sort of our basic building

110
00:08:38,680 --> 00:08:44,680
blocks and we can try to start with but
I was a little bit where to go from here

111
00:08:44,680 --> 00:08:49,160
but I thought if I could build on his
ideas and adapters primitive Turing

112
00:08:49,160 --> 00:08:53,430
machine operations resumed higher level
logic I could teach his diet soda work

113
00:08:53,430 --> 00:08:57,820
on actual data set of abstract symbols
and if I added all these new operations

114
00:08:57,820 --> 00:09:02,270
if else arithmetic logic jumps and
everything else our program needs then

115
00:09:02,270 --> 00:09:07,540
maybe a little bit closer to something
that we could actually use in practice

116
00:09:07,540 --> 00:09:13,450
so first thing I started with was how it
implements its statement using only move

117
00:09:13,450 --> 00:09:16,680
instructions that say you wanted to
implement this simple piece of code if

118
00:09:16,680 --> 00:09:22,100
X&Y are equal to each other then
assigned a value 102 ferryboat Corsa

119
00:09:22,100 --> 00:09:26,930
catch here is we have no branches we
have only move instructions so all up as

120
00:09:26,930 --> 00:09:31,420
a going to execute no matter what the
solution I found a problem is to force a

121
00:09:31,420 --> 00:09:35,410
path to operate on dummy data if we
don't want results looking back at that

122
00:09:35,410 --> 00:09:41,850
each other then X equals 100 so we'll
first evaluate that equality using

123
00:09:41,850 --> 00:09:47,120
equality by a move that we saw earlier
if X&Y are equal to each other then

124
00:09:47,120 --> 00:09:51,980
we'll look up the selector so it points
to a real copy of data then we say X

125
00:09:51,980 --> 00:09:57,040
equals 100 it going to sign one hundred
and two are real program states on the

126
00:09:57,040 --> 00:10:00,209
other hand if X&Y are not equal to each
other we're gonna load up that selector

127
00:10:00,209 --> 00:10:04,920
without pointers from scratch data in
our next up block has to execute was

128
00:10:04,920 --> 00:10:10,040
gonna wait to jump over the sex equals
100 but now when it executes a sign 100

129
00:10:10,040 --> 00:10:14,450
dummy reaching the memory that's just
going to be discarded that's how we can

130
00:10:14,450 --> 00:10:19,149
have different effects even though all
of our instructions are going text you

131
00:10:19,149 --> 00:10:23,140
every single time so we see that might
look something like this you could build

132
00:10:23,140 --> 00:10:28,170
up an array of pointers with the first
being appointed to the dummy data second

133
00:10:28,170 --> 00:10:30,680
being a pointer to real data

134
00:10:30,680 --> 00:10:34,560
results for equality check to select
between one of those two pointers

135
00:10:34,560 --> 00:10:39,020
reference design 102 whatever points
that's what that looks like in C and

136
00:10:39,020 --> 00:10:42,420
assembly it's a little bit something
like this with Nazem syntex he got a

137
00:10:42,420 --> 00:10:46,950
real copy of your variable X a copy of
your variable that's a real copy of why

138
00:10:46,950 --> 00:10:52,089
after a couple of why I need to raise to
select between the two use equality

139
00:10:52,089 --> 00:10:56,660
check that we already looked at to pick
between pointer to the real data pointer

140
00:10:56,660 --> 00:11:01,459
to the Big Data you grab that point her
out of her reign and you assign 100 into

141
00:11:01,459 --> 00:11:07,209
whatever whatever you dragged either
later vacated ending on a result study

142
00:11:07,209 --> 00:11:12,220
quality check so so the solution
implemented at sort of a a low level is

143
00:11:12,220 --> 00:11:15,779
to add the selector functions which
really despite her race for all of our

144
00:11:15,779 --> 00:11:20,209
very being really close attention you
might notice or something a little bit

145
00:11:20,209 --> 00:11:24,910
funky about that equality check that we
looked at here were writing 0 into some

146
00:11:24,910 --> 00:11:30,230
arbitrary location memory that's pretty
good way to save your program but you

147
00:11:30,230 --> 00:11:34,080
get around that problem as long as you
limit yourself to one byte data so for

148
00:11:34,080 --> 00:11:37,790
brevity I'm not asking to go over how we
do that picture really curious you can

149
00:11:37,790 --> 00:11:44,390
look at how we get around us a call
tissues quality check tonight have

150
00:11:44,390 --> 00:11:48,450
gotten this far pretty simple to have
some basic extension if else's if he'll

151
00:11:48,450 --> 00:11:52,720
sit else's inequality checks all things
like that but if we have to keep writing

152
00:11:52,720 --> 00:11:59,029
this in moves to get help ourselves a
little bit by building macros macros to

153
00:11:59,029 --> 00:12:04,200
expand to only with instructions to give
us a way to write slightly higher level

154
00:12:04,200 --> 00:12:08,630
logic and we would otherwise be able to
so here's an assembly macro for checking

155
00:12:08,630 --> 00:12:11,470
the two numbers are equal to each other
with instructions

156
00:12:11,470 --> 00:12:16,160
any quality checks here is on the way to
generate those selector functions with a

157
00:12:16,160 --> 00:12:22,089
macro so we've got it all says at this
point we really want something a little

158
00:12:22,089 --> 00:12:23,779
bit more robust really want to wait

159
00:12:23,779 --> 00:12:32,170
Branch code but we can do that by
extending this is this basic idea

160
00:12:32,170 --> 00:12:36,709
gonna do implement branches anytime you
want to branch at that branch is

161
00:12:36,709 --> 00:12:40,140
supposed to be taken then restore the
target address restore the address of

162
00:12:40,140 --> 00:12:41,630
location branching to

163
00:12:41,630 --> 00:12:46,500
return execution by turning execution
off I mean we switch over all of our

164
00:12:46,500 --> 00:12:50,950
selector pointers 2.2 dummy data so the
program can continue executing but it's

165
00:12:50,950 --> 00:12:54,770
gonna operate on a scratch system state
on the other hand at the branch is not

166
00:12:54,770 --> 00:12:59,620
taking them just need execution on so
that the system on a real system state

167
00:12:59,620 --> 00:13:03,730
then on every operation we're going to
perform we check if execution is on

168
00:13:03,730 --> 00:13:08,960
executions on we run the operation on
real data executions we check the

169
00:13:08,960 --> 00:13:13,690
current branch target if we are turning
on and run the operation on real data if

170
00:13:13,690 --> 00:13:17,630
not believe execution often running at a
lot to take in but it looks something

171
00:13:17,630 --> 00:13:21,700
like this in practice we've got this
phone stream of move instructions at the

172
00:13:21,700 --> 00:13:24,970
very end we just jump back to the
beginning to think over and over and

173
00:13:24,970 --> 00:13:25,950
over again

174
00:13:25,950 --> 00:13:31,030
infinite loop what say you want to
implement a branch from this location to

175
00:13:31,030 --> 00:13:35,540
dislocation the way they were going to
do that is when we want to branch were

176
00:13:35,540 --> 00:13:38,360
going to store the target address that
we're branching to in a situation where

177
00:13:38,360 --> 00:13:44,870
branching to address 100 °c to restore
that somewhere near gonna by switching

178
00:13:44,870 --> 00:13:50,270
all of our data pointers over to dummy
data so that future moves can execute

179
00:13:50,270 --> 00:13:51,550
but I'll take effect

180
00:13:51,550 --> 00:13:57,190
state system state turning it off and on
every block after that will check for

181
00:13:57,190 --> 00:14:01,110
the branch target or not if not the
branch target was gonna continue reading

182
00:14:01,110 --> 00:14:06,010
and run on the lake system states are
not the branch target here not hear back

183
00:14:06,010 --> 00:14:09,790
around but eventually lead to block
where are the branch target we see that

184
00:14:09,790 --> 00:14:14,070
were at address 100 C on that matches
the store Target so we're going to

185
00:14:14,070 --> 00:14:17,560
switch over to real data now gonna turn
execution I change all of our data

186
00:14:17,560 --> 00:14:18,300
pointers

187
00:14:18,300 --> 00:14:23,830
the actual system states so the future
moves after this will take effect on the

188
00:14:23,830 --> 00:14:29,560
real system so that we can simulate
branching with instructions

189
00:14:29,560 --> 00:14:33,220
arithmetic a little bit more complicated
at first but its next hurdle we have to

190
00:14:33,220 --> 00:14:37,060
overcome she turns out to be really
really easy with lookup tables and it's

191
00:14:37,060 --> 00:14:42,060
especially easy because constrained
ourselves to bite size data from before

192
00:14:42,060 --> 00:14:44,590
so let's say I want to implement

193
00:14:44,590 --> 00:14:50,910
just add one to a number with only moved
between a symbol lookup table soon see

194
00:14:50,910 --> 00:14:52,250
that looks something like this

195
00:14:52,250 --> 00:14:58,770
246 elements are a so if they want to
figure out what is to be commended by 10

196
00:14:58,770 --> 00:15:06,710
just go to element 2012 see June
committed by 13 simple enough an

197
00:15:06,710 --> 00:15:09,810
assembly that looks something like this
to generate your table in any actual

198
00:15:09,810 --> 00:15:14,400
operation is a simple as going into your
table and looking up a certain element

199
00:15:14,400 --> 00:15:19,810
that table that value documents pretty
much the same way let's say one of the

200
00:15:19,810 --> 00:15:25,610
detriment of value to react elements REE
my documents are 80123 to see three

201
00:15:25,610 --> 00:15:29,920
documented as to the same thing an
assembly to build the table and here's

202
00:15:29,920 --> 00:15:34,370
how we decrements with the move
instruction in assembly so getting a

203
00:15:34,370 --> 00:15:38,100
little bit further we're going to need
logic gates at some point things like

204
00:15:38,100 --> 00:15:42,040
you or we knew that pretty easily with
lookup tables as well and set of

205
00:15:42,040 --> 00:15:46,740
instructions we can do that with
instructions using lookup tables just

206
00:15:46,740 --> 00:15:50,510
generate a couple of different arrays so
let's say wanted to find a logical and

207
00:15:50,510 --> 00:15:57,220
of 10 I go to my hand her a look up some
array 1 element 0 to find out the

208
00:15:57,220 --> 00:16:06,570
logical end of those two values 04 of 04
10 element want to find out the logical

209
00:16:06,570 --> 00:16:12,140
or does 2012 a simple memory lookups I
can implement logic gates as well so

210
00:16:12,140 --> 00:16:18,540
this is some or macros to implement or
with only move instructions and with the

211
00:16:18,540 --> 00:16:24,630
new construction is not with only a
halter programmer executing this list of

212
00:16:24,630 --> 00:16:28,150
moves in an infinite loop right now we
need someone to stop executing at some

213
00:16:28,150 --> 00:16:34,090
point so Dolan had an idea for a citizen
there some special invalid address that

214
00:16:34,090 --> 00:16:37,650
will haunt your program will have ever
read anything and see this probably

215
00:16:37,650 --> 00:16:42,760
sounds familiar to you know it's a
pretty good way to hold your programs

216
00:16:42,760 --> 00:16:46,140
not the cleanest way that's gonna say
follow your program but it'll stop

217
00:16:46,140 --> 00:16:51,370
so that's what we're going to use for me
access no was simply cease execution so

218
00:16:51,370 --> 00:16:56,240
wanna stop our program it's the simplest
trying to read from address 0 course we

219
00:16:56,240 --> 00:16:59,750
don't do that every single time we had
destruction wanna conditionally stop our

220
00:16:59,750 --> 00:17:03,810
program when it's time to stop it so
here's how you instructions

221
00:17:03,810 --> 00:17:09,900
conditionally dereference know in order
to save her program to stop it

222
00:17:09,900 --> 00:17:15,070
got some some preschool building blocks
for actually writing only program got

223
00:17:15,070 --> 00:17:21,240
macro sticky quality inequality not
endure race to get data from either real

224
00:17:21,240 --> 00:17:25,620
memory or scratch memory increment
decrement transfusion on and off for

225
00:17:25,620 --> 00:17:29,340
branching got only truly useful building
blocks need to build up and nothing is

226
00:17:29,340 --> 00:17:35,970
this whole thing becomes almost doable
as long as you're writing assembly right

227
00:17:35,970 --> 00:17:41,640
now simply forever would like to compile
and only move instructions so I C

228
00:17:41,640 --> 00:17:46,450
compilers kind of lofty goals here but I
thought let's start with something a lot

229
00:17:46,450 --> 00:17:50,290
simpler lot more manageable so the
simplest language I could possibly think

230
00:17:50,290 --> 00:17:54,300
up as a starting point is something a
little bit inappropriate for a

231
00:17:54,300 --> 00:17:59,260
family-friendly conference like this but
it's it's it's it's minimal esoteric

232
00:17:59,260 --> 00:18:03,420
programming language that has only eat
instructions only two registers

233
00:18:03,420 --> 00:18:07,270
instruction pointer in the data point
for the purposes of this document try to

234
00:18:07,270 --> 00:18:12,590
call this spring hopefully I won't screw
that up but he said the eight bring your

235
00:18:12,590 --> 00:18:16,980
options really simple we've got a way to
increment our data pointer way to

236
00:18:16,980 --> 00:18:18,559
document our data pointer

237
00:18:18,559 --> 00:18:22,240
a way to implement the bite at the data
point when a detriment to bite at the

238
00:18:22,240 --> 00:18:26,639
data plan year wait to read in a byte
array a printout of bytes in a way to

239
00:18:26,639 --> 00:18:32,419
loose forwards backwards instructions we
have available to us in brain yards but

240
00:18:32,419 --> 00:18:36,019
we're gonna have one more way to
actually hold the system so here's a

241
00:18:36,019 --> 00:18:41,379
really simple brain yup program to print
out 1230 all of our main memory Brainiac

242
00:18:41,379 --> 00:18:44,830
starts out 0 so if you want to print out
of wine we need to get one of our data

243
00:18:44,830 --> 00:18:52,159
cells up to the ASCII value of 1 631 so
we're going to increments our data so X

244
00:18:52,159 --> 00:18:53,179
thirty times

245
00:18:53,179 --> 00:18:57,379
increment it one more point out that
value or to print out 2011 committed

246
00:18:57,379 --> 00:19:01,929
against get up texture YouTube printed
out the two etcetera etcetera to print

247
00:19:01,929 --> 00:19:07,869
out 1234 another common paradigm in
bringing you to set a date assaulted 0

248
00:19:07,869 --> 00:19:11,669
we simply move over that day to sell
over and over again decker many by one

249
00:19:11,669 --> 00:19:15,919
each time until it reaches zero so
here's a brain yup program for printing

250
00:19:15,919 --> 00:19:17,249
out hello world

251
00:19:17,249 --> 00:19:20,960
all they do is to get some funny looping
stuff to try to get their data cells up

252
00:19:20,960 --> 00:19:23,779
into the ASCII range capital H

253
00:19:23,779 --> 00:19:28,759
move over a day to sell decrement sat
down to eat print out the each increment

254
00:19:28,759 --> 00:19:37,289
it up to FGH I J K L print out your team
and committed up to an open topic how

255
00:19:37,289 --> 00:19:40,860
brain networks just comment and
decrement values printing them out as

256
00:19:40,860 --> 00:19:46,309
you go along you can do anything to
bring this number generator and brainy

257
00:19:46,309 --> 00:19:51,000
99 bottles of beer on the wall written
and bring out its

258
00:19:51,000 --> 00:19:55,150
it's a really really horrible
programming way way worse than trying to

259
00:19:55,150 --> 00:20:00,870
program with only moves so why on earth
would we incorporate this compiler well

260
00:20:00,870 --> 00:20:04,610
turns out that with the building blocks
we just talked about his brain

261
00:20:04,610 --> 00:20:11,020
operations are really really easy to
remove instructions so if I can get my

262
00:20:11,020 --> 00:20:16,570
code into brain then I can translate it
only moves and I happen to know going

263
00:20:16,570 --> 00:20:21,420
into this that there's actually already
a basic to brain compiler out there so I

264
00:20:21,420 --> 00:20:25,570
could change the two compilers together
to go from basic training to move

265
00:20:25,570 --> 00:20:30,770
instructions so we gotta figure out how
to write our brain instructions as only

266
00:20:30,770 --> 00:20:34,470
move so many you some of the macros that
we are traded like not going to expand

267
00:20:34,470 --> 00:20:39,510
and is going to expand so all we do is
check is this the current frame

268
00:20:39,510 --> 00:20:46,710
construction if it is not slept fitfully
and then implement that destruction so

269
00:20:46,710 --> 00:20:52,790
in this case + increments the value at
the current data sales agreement lookup

270
00:20:52,790 --> 00:20:56,280
tables implemented then right back to
memory the real memory or fake number

271
00:20:56,280 --> 00:21:00,560
depending on whether or not this
junction same thing with decrement

272
00:21:00,560 --> 00:21:03,750
moving data pointer left it pretty
simple moving data pointer rights pretty

273
00:21:03,750 --> 00:21:11,580
simple halting conditionally dereference
her to initially hoped the system in

274
00:21:11,580 --> 00:21:15,200
putting up a little bit more complicated
we did the same thing as before we check

275
00:21:15,200 --> 00:21:19,680
is the sticker instruction are we trying
to help put one of our brain yet that

276
00:21:19,680 --> 00:21:25,130
use on the catch is that due to Linux
limitations can't directly out point

277
00:21:25,130 --> 00:21:29,470
standard out right away we have to ask
the kernel to help put something for us

278
00:21:29,470 --> 00:21:36,160
so in this one case a to deviate from my
instructions and Colin in order to print

279
00:21:36,160 --> 00:21:41,420
out to print out this fight for me at
this point so I'm sure how we can fix

280
00:21:41,420 --> 00:21:45,830
this later get around but that's easiest
way for us to get started singing for

281
00:21:45,830 --> 00:21:51,200
reading data and we're gonna need a new
stadium looping it's a little bit more

282
00:21:51,200 --> 00:21:54,780
complicated but it's the same basic
premise you're moving trucks to check

283
00:21:54,780 --> 00:21:58,880
whether or not you're trained on the
spring construction if you are switching

284
00:21:58,880 --> 00:22:04,679
over to real data are not switch over to
fake data set up your branching targets

285
00:22:04,679 --> 00:22:09,860
instructions thank you for bringing in
the other direction so with that we've

286
00:22:09,860 --> 00:22:14,470
got all of our brain instructions
implemented as I'm just a series of the

287
00:22:14,470 --> 00:22:23,370
truck tire tool did a translation what I
call them that really quickly see how

288
00:22:23,370 --> 00:22:29,370
things really pretty straightforward
just a couple hundred lines of code so

289
00:22:29,370 --> 00:22:33,510
we open up our compiler here we'll see
ought really doing is it's reading a

290
00:22:33,510 --> 00:22:35,000
brain up construction

291
00:22:35,000 --> 00:22:39,580
reaching out to move instruction that
would correspond to that brain structure

292
00:22:39,580 --> 00:22:43,910
so for example here to bring a
construction this year the movie

293
00:22:43,910 --> 00:22:45,140
structions

294
00:22:45,140 --> 00:22:50,850
so really pretty simple that allows us
to do now let's just take a training

295
00:22:50,850 --> 00:22:56,950
program just 13 cipher written and brain
we can now feed that training program

296
00:22:56,950 --> 00:23:03,679
into our compiler and output
corresponding assembly then used to

297
00:23:03,679 --> 00:23:10,520
assemble our program used LG delink our
program we can use options now to

298
00:23:10,520 --> 00:23:21,540
actually check the results tonight got a
program only move instructions right 13

299
00:23:21,540 --> 00:23:35,620
safer hello and using only move
instruction run the route 39

300
00:23:35,620 --> 00:23:43,350
so are using instructions to do actually
fairly complicated things just a simple

301
00:23:43,350 --> 00:23:47,030
set of unconditional data transfers but
there was something I really really

302
00:23:47,030 --> 00:23:51,140
bothered me about this we got 29
moonstruck

303
00:23:51,140 --> 00:23:56,760
back here you'll see that the jump
instruction and occasionally and year

304
00:23:56,760 --> 00:24:04,930
we've got this concept but it's still
really bothered me that I had not

305
00:24:04,930 --> 00:24:09,850
decided this program but it turns out
that she thinks these things just set up

306
00:24:09,850 --> 00:24:13,980
our execution environment correctly so
getting ready dnt turns out to be

307
00:24:13,980 --> 00:24:20,080
actually pretty easy with memory map so
I am at the standard any standard output

308
00:24:20,080 --> 00:24:25,000
streams into our processes memory access
standard in standard out just through

309
00:24:25,000 --> 00:24:31,620
moving structure so we can use move Fri
02 rhea those streams into our memories

310
00:24:31,620 --> 00:24:38,190
of entities and jump up and down one's a
little bit more complex a lot of ideas

311
00:24:38,190 --> 00:24:42,880
ahead for getting rid of that final jump
found in the end was to set up our

312
00:24:42,880 --> 00:24:47,860
program to be its own legal signal
exception handler so what that alot of

313
00:24:47,860 --> 00:24:53,240
steel is hella tell the next we want our
program to handle its own exceptions

314
00:24:53,240 --> 00:24:57,120
will set the SA node the first flight
has triggered this exception multiple

315
00:24:57,120 --> 00:25:01,970
times never going to replace that final
jump instruction within legal action

316
00:25:01,970 --> 00:25:05,510
instead so anything about illegal move
you might be thinking something like

317
00:25:05,510 --> 00:25:09,980
that's actually legal memory access not

318
00:25:09,980 --> 00:25:17,549
illegal construction all of x86 is
trying to load the CES register with a

319
00:25:17,549 --> 00:25:21,740
move instruction you're not supposed to
be able to encode that instruction but

320
00:25:21,740 --> 00:25:25,559
that I'll throw in illegal instruction
exception so when an exception get

321
00:25:25,559 --> 00:25:30,600
strong the program will try to handle
its own exception in a while loop back

322
00:25:30,600 --> 00:25:36,880
to the program without having to use a
job but that's gonna cause exception

323
00:25:36,880 --> 00:25:41,530
handling to prevent a stackoverflow the
last apostle is to rely on every

324
00:25:41,530 --> 00:25:45,919
iteration of our program with that set
of steps to successfully get rid of that

325
00:25:45,919 --> 00:25:54,350
final jump instruction can have your
move program but if for all of this

326
00:25:54,350 --> 00:25:58,400
disease can be totally unusable because
it's way harder right brain than it is

327
00:25:58,400 --> 00:26:04,140
to write and moves so that's where this
other compiler comes into play so I did

328
00:26:04,140 --> 00:26:11,059
not write another compiler fortunately
somebody else creating but in a pile out

329
00:26:11,059 --> 00:26:16,630
their card yet basic basic allow you to
do is take a basic program I wrote this

330
00:26:16,630 --> 00:26:22,990
on the wall program and they say should
be pretty easy to decipher we set the

331
00:26:22,990 --> 00:26:27,880
number on the wall in a loop first set
of lyrics the second set up the first

332
00:26:27,880 --> 00:26:32,840
set of lyrics can take one down pass
around document print out the lyrics we

333
00:26:32,840 --> 00:26:36,010
can tell you continue to we had no more
bottles of beer on the wall

334
00:26:36,010 --> 00:26:39,860
sparsely York's go to first set of
lyrics varies based on whether or not

335
00:26:39,860 --> 00:26:45,580
you bottles of beer left as the second
set of lyrics so I'm free sample program

336
00:26:45,580 --> 00:26:53,410
but EF BASIC compiler will allow us to
translate that into crania so now we can

337
00:26:53,410 --> 00:26:57,049
open are bringing out version of this
and yet they suggest conveniently

338
00:26:57,049 --> 00:27:03,240
translated that into down here fifteen
thousand Brainiac instructions so we now

339
00:27:03,240 --> 00:27:13,700
take that you bring it into our office
skater program and to only move

340
00:27:13,700 --> 00:27:20,340
instructions verify that we do in fact
have nothing but a tremendous stream of

341
00:27:20,340 --> 00:27:22,200
moves past my computers running

342
00:27:22,200 --> 00:27:33,970
but I think of a presentation you can
imagine there's a little bit of bloat

343
00:27:33,970 --> 00:27:41,610
and program size again from maybe a
hundred flights to about eight megabytes

344
00:27:41,610 --> 00:27:47,340
but you will see we got rid of that
final jump at the end with justice in

345
00:27:47,340 --> 00:27:50,700
illegal move instruction when it hit
that will begin executing our program

346
00:27:50,700 --> 00:27:55,780
back from the beginning so now we go
ahead and actually run this thing

347
00:27:55,780 --> 00:28:06,330
happens because it is really really slow
actually start putting something out for

348
00:28:06,330 --> 00:28:12,220
us to print out 99 bottles of beer on
the wall and maybe even more time and

349
00:28:12,220 --> 00:28:24,130
tell us how many are left we take one
down so

350
00:28:24,130 --> 00:28:38,620
actually doing nothing but this giant
stream of Internet Movie

351
00:28:38,620 --> 00:28:44,520
options so actually really cool that you
can do that sort of executing maybe I'll

352
00:28:44,520 --> 00:28:50,400
finish at some point but what he can do
anything now we can compile it with DFA

353
00:28:50,400 --> 00:28:55,240
significant translated through the masa
skater in Sioux only move instructions

354
00:28:55,240 --> 00:29:00,370
so I start trying to think of
interesting things that we could make so

355
00:29:00,370 --> 00:29:14,630
here's a program written in only moves
factor numbers for us go ahead and with

356
00:29:14,630 --> 00:29:19,930
nothing but a bunch of unconditional
moving structure of course it doesn't

357
00:29:19,930 --> 00:29:24,630
clean up easy way our program stop is by
putting themselves

358
00:29:24,630 --> 00:29:32,930
but also we've got a program written
instructions regenerate prime numbers

359
00:29:32,930 --> 00:29:33,580
for us

360
00:29:33,580 --> 00:29:43,720
sophisticated math with nothing but but
moves fact here's a complete CSS

361
00:29:43,720 --> 00:29:49,260
decryption pfeiffer written and move
instructions here's a role playing game

362
00:29:49,260 --> 00:29:55,890
called lost written in only move
instructions even Mathias Kaden d'amato

363
00:29:55,890 --> 00:30:01,130
skaters have a program written only move
instructions that compiles other

364
00:30:01,130 --> 00:30:10,970
programs and instructions and
fortunately take days to complete so but

365
00:30:10,970 --> 00:30:14,310
there is a lot of fun to watch

366
00:30:14,310 --> 00:30:18,560
nothing but move instructions do Rio
computation but I went back to my

367
00:30:18,560 --> 00:30:22,750
original question is an effective anti
reverse engineering thing

368
00:30:22,750 --> 00:30:26,430
experience reverses year actually
approach this problem I kinda thought

369
00:30:26,430 --> 00:30:32,200
well I'm an experienced what would I do
if I opened up a while and I saw nothing

370
00:30:32,200 --> 00:30:37,850
but hundreds of thousands of movie
instructions really I find something

371
00:30:37,850 --> 00:30:43,080
else to her first ever since you're
treading it's fun and this doesn't look

372
00:30:43,080 --> 00:30:47,950
like fun at all to me so it'd be pretty
effective just done but more seriously

373
00:30:47,950 --> 00:30:51,160
thinking about this as an entry reverse
engineering technique brings up some

374
00:30:51,160 --> 00:30:54,380
interesting observations are going back
to the 99 bottles of beer on the wall to

375
00:30:54,380 --> 00:30:58,070
know if we have written and see the
first function will look something like

376
00:30:58,070 --> 00:30:58,910
this

377
00:30:58,910 --> 00:31:04,970
first lyrics will look like this second
set of lyrics is more simple if you

378
00:31:04,970 --> 00:31:08,300
wrote all this is one big function
control flow graph looks something like

379
00:31:08,300 --> 00:31:14,020
this now an experienced person here at
this exactly what was going on here just

380
00:31:14,020 --> 00:31:18,560
by looking at the control flow graph so
other the station tools usually take

381
00:31:18,560 --> 00:31:21,570
your program and they try to add a lot
of complexity to it to make it more

382
00:31:21,570 --> 00:31:25,160
difficult to reverse engineer see my
take the same program put it to a

383
00:31:25,160 --> 00:31:29,050
different obfuscation tool will become
really really complicated on the other

384
00:31:29,050 --> 00:31:31,290
hand if you put this true democracy
skater

385
00:31:31,290 --> 00:31:38,090
this is what you get out as there are no
branches there's no control

386
00:31:38,090 --> 00:31:41,730
going on here so this is 99 bottles of
beer on the wall

387
00:31:41,730 --> 00:31:47,600
this was the writer Tim Sypher we saw
earlier this is Towers of Hanoi this is

388
00:31:47,600 --> 00:31:51,450
a Mandelbrot fractal and this is that
lost role-playing you might notice a

389
00:31:51,450 --> 00:31:57,170
pattern here I'm pretty much everything
comes out exactly the same and these are

390
00:31:57,170 --> 00:32:00,090
fun to look at and I decided to defect
or reverse engineering

391
00:32:00,090 --> 00:32:04,430
really like it when you got one block
100,000 instructions

392
00:32:04,430 --> 00:32:09,850
crash every single time you try to look
at it so it's it's effective in that

393
00:32:09,850 --> 00:32:17,980
regards to opposite the station it
simple buys programs in order to

394
00:32:17,980 --> 00:32:21,880
obfuscate than every program becomes
exactly the same thing and there's no

395
00:32:21,880 --> 00:32:26,210
dead code alot of the station tools
adjunct coat for you to see if true but

396
00:32:26,210 --> 00:32:30,750
there is no dead code here there's only
that sometimes data and sometimes works

397
00:32:30,750 --> 00:32:38,320
but more realistically retirement to
reverse engineer the same person would

398
00:32:38,320 --> 00:32:43,420
do it they'd see that there are these
patterns groups of move instructions or

399
00:32:43,420 --> 00:32:48,110
implement a simple basic operation so
they would have recently moved back to

400
00:32:48,110 --> 00:32:52,770
the basic operations and then her hearse
basic operations but that's a shame

401
00:32:52,770 --> 00:32:57,420
really really easy to add some routine
that actually shuttled individual move

402
00:32:57,420 --> 00:33:01,370
instructions inside his block so you
don't end up with any patterns of moves

403
00:33:01,370 --> 00:33:05,960
inside of your coat even junk move
instructions cited his blocks of that no

404
00:33:05,960 --> 00:33:12,560
two blocks ever look like to eat and
blocks you can't separate them into more

405
00:33:12,560 --> 00:33:15,820
fundamental operations and then you can
have been rearranged the basic blocks

406
00:33:15,820 --> 00:33:18,720
and a lot of situations because they
often operate independently of one

407
00:33:18,720 --> 00:33:24,330
another so it becomes a reverse
engineering nightmare when you can read

408
00:33:24,330 --> 00:33:29,920
the entire program every time you
compiling especially because all the

409
00:33:29,920 --> 00:33:34,580
instructions the same already compiled
something one time to look like this

410
00:33:34,580 --> 00:33:41,960
compiling exactly like this again look
like this it's just a nightmare and even

411
00:33:41,960 --> 00:33:46,180
without this what i was finding a nice
writing this is ication Lee made a

412
00:33:46,180 --> 00:33:51,560
mistake i introduce some kinda bug and I
don't dive into GB with instructions to

413
00:33:51,560 --> 00:33:55,370
figure out what was going on and even
though I just written instructions

414
00:33:55,370 --> 00:33:59,350
myself five seconds earlier I could not
keep track what was happening because

415
00:33:59,350 --> 00:34:04,370
everything looks exactly like everything
else in the program so it's pretty

416
00:34:04,370 --> 00:34:10,669
daunting but there are some pretty
obvious limitations here it's not fast

417
00:34:10,669 --> 00:34:15,669
and one of the biggest reasons for that
is the way that jumps work on Armada

418
00:34:15,669 --> 00:34:19,710
skated coat wanna jump from one location
to another we switched back and forth

419
00:34:19,710 --> 00:34:27,429
between real and imagined something from
here to here is simply turn off

420
00:34:27,429 --> 00:34:33,290
execution hear all these new operating
it up when i turn on execution here's a

421
00:34:33,290 --> 00:34:37,950
small number of wasted moves in between
those patients but jumping forward not

422
00:34:37,950 --> 00:34:39,870
backwards not a problem

423
00:34:39,870 --> 00:34:44,140
jumping backwards is where the real
problem arises a jump back from here to

424
00:34:44,140 --> 00:34:49,350
here at randolph execution my entire
program has to execute again before can

425
00:34:49,350 --> 00:34:53,480
turn on execution year that's especially
problematic because of the way brain yet

426
00:34:53,480 --> 00:34:58,810
sets to 0 it does a small do documenting
value over and over again until it

427
00:34:58,810 --> 00:35:03,070
reaches zero so every time I want a
detriment of value by one rainy my

428
00:35:03,070 --> 00:35:07,280
entire program has to react itself under
meeting that's going to make things

429
00:35:07,280 --> 00:35:13,770
really slow highlight that we can check
on how are your programs doing and it's

430
00:35:13,770 --> 00:35:21,210
it's not even close but it's getting
there so that seems unusual but I kind

431
00:35:21,210 --> 00:35:25,770
of figured I'd gone this far and I had a
lot of fun with it would a C compiler

432
00:35:25,770 --> 00:35:30,000
really be that much more complicated
turns out the answer is yes

433
00:35:30,000 --> 00:35:35,650
but I had so far was maybe two hundred
lines of really easy code that took

434
00:35:35,650 --> 00:35:39,940
about three hours to write it into a C
compiler was thousands and thousands of

435
00:35:39,940 --> 00:35:44,380
lines really really complex code but it
actually turned out to be fairly

436
00:35:44,380 --> 00:35:49,580
straightforward so I started trying to
implement and arithmetic logic unit I'll

437
00:35:49,580 --> 00:35:55,790
see you need to go from bite sized at
brain was using in 24 32 bit 32 bit

438
00:35:55,790 --> 00:35:59,880
arithmetic is you can't just look up
table anymore you don't have enough

439
00:35:59,880 --> 00:36:04,050
memory for these giant 32 bit lookup
tables we gotta do it a little bit more

440
00:36:04,050 --> 00:36:08,170
advanced but still doable so here's some
assembly macrocycle expands only move

441
00:36:08,170 --> 00:36:12,050
instruction for implementing 32 bit
that's all we do is we just ate a bunch

442
00:36:12,050 --> 00:36:13,100
of eight bit

443
00:36:13,100 --> 00:36:20,130
expand as macros 32 bit ad with options
look something like this

444
00:36:20,130 --> 00:36:23,900
subtraction similar expands something
like this

445
00:36:23,900 --> 00:36:27,120
shifting its a little bit more
complicated user macros for left ships

446
00:36:27,120 --> 00:36:33,150
which extends right ships expand this
nation's where things start to get here

447
00:36:33,150 --> 00:36:42,020
are multiplication macros that will
extend him that's thirty two divisions

448
00:36:42,020 --> 00:36:48,810
where it gets really really so here are
32 bit division macros little over seven

449
00:36:48,810 --> 00:36:53,500
thousand new construction we just kind
of ridiculous when you think that when

450
00:36:53,500 --> 00:36:57,260
did instruction would do exactly the
same day but the point is that it can be

451
00:36:57,260 --> 00:37:01,940
done we can use moves to accomplish all
of these things so I kind of took that

452
00:37:01,940 --> 00:37:09,310
as a starting point and really ran with
it to build this compiler so I used LCC

453
00:37:09,310 --> 00:37:14,280
at the front end this little bit of a
challenge because you need to preserve

454
00:37:14,280 --> 00:37:19,590
so many registers just for shuffling
around memory that you can't get much to

455
00:37:19,590 --> 00:37:28,880
the compiler front LCD LCD x86 registers
remember shuffling on how to find a new

456
00:37:28,880 --> 00:37:30,130
calling convention for me

457
00:37:30,130 --> 00:37:34,529
instructions trading emulated stack with
move integrated that 32 bit arithmetic

458
00:37:34,529 --> 00:37:38,059
logic unit simple by the way that are
preaching work through those dummies

459
00:37:38,059 --> 00:37:43,200
implements all one hundred and two
intermediate language instructions with

460
00:37:43,200 --> 00:37:50,289
only moves SEC compiler but it turned
out to go a lot smoother so that's what

461
00:37:50,289 --> 00:37:56,019
I call my office cater to this completes
Decompiler compile C source code only

462
00:37:56,019 --> 00:38:02,410
instructions so I try to think about
what the best thing to trade with demo

463
00:38:02,410 --> 00:38:08,559
with my skater to not always really
liked game nibbles her room so I showed

464
00:38:08,559 --> 00:38:14,670
up this little nibbles game you see a
couple hundred lines of code you can now

465
00:38:14,670 --> 00:38:20,589
run that through our Armada skater to
move C compiler on Drug Mart escape that

466
00:38:20,589 --> 00:38:27,319
for us and translated into just a
tremendous number of instructions now we

467
00:38:27,319 --> 00:38:32,670
can run this program can actually play
nipples

468
00:38:32,670 --> 00:38:38,819
options and you know it's actually kind
of fast as possible at this point so

469
00:38:38,819 --> 00:38:46,109
that I could actually run real C code
using only move instructions but my I

470
00:38:46,109 --> 00:38:48,650
compile it was lacking for a little
while because I didn't know how to

471
00:38:48,650 --> 00:38:57,259
floating point math x86 move can access
a floating point so I came up with this

472
00:38:57,259 --> 00:39:03,230
was to create a move on me I Tripoli
floating-point any later about 500,000

473
00:39:03,230 --> 00:39:09,000
move instructions to emulate floating
point math with only moves but what that

474
00:39:09,000 --> 00:39:17,160
lets you do is really any floating point
demonstrate floating point math right up

475
00:39:17,160 --> 00:39:21,470
3d graphics graphics thank you

476
00:39:21,470 --> 00:39:28,910
and see if we can compile with armed
obfuscator leaking and are moving me

477
00:39:28,910 --> 00:39:36,010
floating-point libraries now see supra
dump that we could sit here all day in

478
00:39:36,010 --> 00:39:43,470
the Sun cuz that's a lot of moving
structions but actually done matrix

479
00:39:43,470 --> 00:39:55,079
manipulations cosines signs all sorts of
crazy transplant

480
00:39:55,079 --> 00:40:01,299
a lot of work for spinning cube is the
best way to demonstrate floating point

481
00:40:01,299 --> 00:40:06,910
instructions so I was pretty excited
about how that turned out really just a

482
00:40:06,910 --> 00:40:11,459
complete C compiler so I got examples
potentially to eat high square roots a

483
00:40:11,459 --> 00:40:19,839
yes desman D five shot 68 coin stuff
games fractals public great racing

484
00:40:19,839 --> 00:40:26,589
engines generate great race damages on
the move instructions and it's it's fun

485
00:40:26,589 --> 00:40:31,329
to spot it turn away and I think as far
as I know this is the world's first

486
00:40:31,329 --> 00:40:34,819
single instruction C compiler probably
because I don't think anybody's ever

487
00:40:34,819 --> 00:40:42,289
wanted such a thing before but it was a
lot of fun to work on and complete

488
00:40:42,289 --> 00:40:48,640
instructions exist we know movies trying
complete like that out there without it

489
00:40:48,640 --> 00:40:53,829
seems obvious in the XOR must be trained
complete movie featuring complete guide

490
00:40:53,829 --> 00:40:57,059
to be think about something simple that
say you want to move the value 23 for

491
00:40:57,059 --> 00:41:03,180
into the yaks register which do that
with just a pair of exercise instead XOR

492
00:41:03,180 --> 00:41:10,609
EAX with itself to clear it out with an
X or Y axis 24 to get ya access to 1234

493
00:41:10,609 --> 00:41:14,959
so it's just a pair of expertise we can
simulate so I turned that into an

494
00:41:14,959 --> 00:41:19,430
exorcist skater Michelle compile C
program since you only X-ers

495
00:41:19,430 --> 00:41:26,989
instructions so really all this thing
ends up being his little python script

496
00:41:26,989 --> 00:41:32,809
that takes takes the output of the moths
catering translates those move

497
00:41:32,809 --> 00:41:42,499
instructions into an equivalent set X or
instructions so so what we do is we

498
00:41:42,499 --> 00:41:46,529
compile a program at the mosque the
skater then we run it through the sex or

499
00:41:46,529 --> 00:41:53,300
translator in order to get this program

500
00:41:53,300 --> 00:42:00,260
this particular wine were using to print
out prime numbers so now with only X-ers

501
00:42:00,260 --> 00:42:06,690
operations just calculate the prime
numbers up to 10,000 things like exeter

502
00:42:06,690 --> 00:42:13,650
out there are two options we could do
the same thing X or a pair of endures

503
00:42:13,650 --> 00:42:18,030
the same things I made endorphin skater
if you're treated with the way you

504
00:42:18,030 --> 00:42:22,230
subtraction combine a bunch of sub
operations in order to implement it

505
00:42:22,230 --> 00:42:26,170
moves that's the subsurface cater my
favorite sitcom exchange exchange the

506
00:42:26,170 --> 00:42:30,760
skater I couldn't i couldn't quite get
comp exchange he turned complete by

507
00:42:30,760 --> 00:42:33,980
itself but he combining with another
exchange instruction you can make that

508
00:42:33,980 --> 00:42:39,150
happen so you can write her I tend to
only cop exchange exchange instructions

509
00:42:39,150 --> 00:42:44,850
or another good one I was running out of
names at this point later Tyler C code

510
00:42:44,850 --> 00:42:51,720
into a single bit shift instruction is
so this one gets to be actually slower

511
00:42:51,720 --> 00:42:58,360
than the brain code so I would actually
run it but we can actually see it

512
00:42:58,360 --> 00:43:06,950
compile and now he's got complete
program with nothing but single but she

513
00:43:06,950 --> 00:43:14,580
actually do anything that we could do in
C so I still wasn't ready to call it

514
00:43:14,580 --> 00:43:15,240
quits

515
00:43:15,240 --> 00:43:20,980
think of ideas for modest 3.0 a friend
of mine pointed me to this paper showing

516
00:43:20,980 --> 00:43:25,360
that the x86 memory management unit is
chairing complete what that means is

517
00:43:25,360 --> 00:43:29,800
that you don't need any instruction 6
for Turing complete D page fault

518
00:43:29,800 --> 00:43:35,500
exception handling mechanisms and x86
bartering complete by themselves so that

519
00:43:35,500 --> 00:43:37,550
researchers courtesy of 22 guys

520
00:43:37,550 --> 00:43:43,190
angered inserted broadus free sharp guys
but my goal for next year

521
00:43:43,190 --> 00:43:45,750
compiler that outputs no instructions

522
00:43:45,750 --> 00:43:56,140
by wrapping everything up I really don't
worry solution is incredibly fun little

523
00:43:56,140 --> 00:43:59,460
side project to work on for a little
while so if you're interested in this at

524
00:43:59,460 --> 00:44:03,640
all all the source on github you can get
the original model skater there that's

525
00:44:03,640 --> 00:44:07,890
the Brainiac version you can get the C
compiler version on the other flank the

526
00:44:07,890 --> 00:44:13,190
skaters there's even a crack me there if
you liked her sincere and move on their

527
00:44:13,190 --> 00:44:16,640
person here you can check out that
cracked me I've got some other stuff up

528
00:44:16,640 --> 00:44:22,190
on the GitHub desk on a show to talk
Audrey psyche which lets you restructure

529
00:44:22,190 --> 00:44:25,440
the control flow of your programs in
order to draw images

530
00:44:25,440 --> 00:44:29,580
absolutely no purpose but also kinda
like things that serve a purpose instead

531
00:44:29,580 --> 00:44:32,860
there's also some cold up there for
architectural privilege escalation

532
00:44:32,860 --> 00:44:35,970
vulnerability built into the x86
architecture

533
00:44:35,970 --> 00:44:39,510
checked out two and I'll be tossed in
some other random things up there in the

534
00:44:39,510 --> 00:44:40,340
future

535
00:44:40,340 --> 00:44:44,610
getting feedback decide not to discuss
it more with you wouldn't be where it is

536
00:44:44,610 --> 00:44:50,030
today without people's input project you
can follow me on Twitter that's XOR EAX

537
00:44:50,030 --> 00:44:56,220
if you want to have a discussion more
than 140 characters feel free to email

538
00:44:56,220 --> 00:45:02,060
me want to see if our original up
something yet but i wanna see if our

539
00:45:02,060 --> 00:45:05,100
original

540
00:45:05,100 --> 00:45:09,110
the analogue program is finished and
it's not close but I got a few minutes

541
00:45:09,110 --> 00:45:13,970
left it there any questions keep
churning away and see how it does yeah

542
00:45:13,970 --> 00:45:26,500
yeah all the different propagation
techniques are independent of one

543
00:45:26,500 --> 00:45:30,980
another so let's move obfuscation was
not enough you could certainly

544
00:45:30,980 --> 00:45:34,720
interchange them are combined creative
ways to complicate things

545
00:45:34,720 --> 00:45:51,900
yes the question is with the end met
technique to get rid of unctad don't you

546
00:45:51,900 --> 00:45:55,700
need additional non move instructions on
you do but the difference is that they

547
00:45:55,700 --> 00:46:00,180
can be in the loader itself so it could
be completely separate from your program

548
00:46:00,180 --> 00:46:05,869
that could be part of the OS program
moves ok so our training program

549
00:46:05,869 --> 00:46:10,510
actually finished and i think im at a
time but I really appreciate everyone's

550
00:46:10,510 --> 00:46:14,150
stopping by to check this out I'd love
to get feedback from everyone thanks

