1
00:00:00,000 --> 00:00:07,460
at 500 people of debit cards welcome to
the three way below random YouTube

2
00:00:07,460 --> 00:00:19,810
viewer my name is Adam this is neck and
neck so like shameless self plug I am

3
00:00:19,810 --> 00:00:23,810
writing a book on game hacking so this
is a preview copy there's a preview copy

4
00:00:23,810 --> 00:00:26,670
for auction and hackers for charity
they're good people so give them money

5
00:00:26,670 --> 00:00:30,599
and buy the preview copy its first three
chapters will be out in a few months

6
00:00:30,599 --> 00:00:36,559
other than that I just own user land and
he researches malware and from that we

7
00:00:36,559 --> 00:00:40,090
came up with this talk so we hope you
guys like any given a makeover to him

8
00:00:40,090 --> 00:00:48,079
he's going to start to talk out so what
the stock is about zero tattoo world a

9
00:00:48,079 --> 00:00:54,949
generic on Packard for Windows malware
and what we call it a packer attacker

10
00:00:54,949 --> 00:01:02,260
and why did you write it because we
wanted to analyze malware at scale and

11
00:01:02,260 --> 00:01:07,020
we couldn't find good open source tools
to do that we could have bought some

12
00:01:07,020 --> 00:01:10,250
commercial solution there couple of
services there but there are two

13
00:01:10,250 --> 00:01:15,590
problems with them first is we actually
wanted to know what exactly are we doing

14
00:01:15,590 --> 00:01:24,060
those things are proprietary enclosed
source and secondly we thought it would

15
00:01:24,060 --> 00:01:29,930
be fun to to develop it ourselves and
share with the community for for

16
00:01:29,930 --> 00:01:36,150
everybody to use for independent
researchers and academics and so on so

17
00:01:36,150 --> 00:01:41,920
yeah let's begin with a bit of
background so we use the term Packers

18
00:01:41,920 --> 00:01:48,000
really losing what we mean by that is
this the following things so when Mauer

19
00:01:48,000 --> 00:01:55,280
execute on your machine is usually
starts with self and packing code that

20
00:01:55,280 --> 00:02:00,160
extracts the actual malicious payload
from somewhere

21
00:02:00,160 --> 00:02:04,960
could be a resource section it could be
hidden somewhere in the PE header or

22
00:02:04,960 --> 00:02:13,220
scattered across the the Pinery then it
does some unpacking or decryption or

23
00:02:13,220 --> 00:02:19,770
both and then it transfers control to
that code and there are many ways to do

24
00:02:19,770 --> 00:02:27,590
that first invited into a separate file
and then launched up file but we're not

25
00:02:27,590 --> 00:02:31,840
interested in that because just trivial
you just need to watch for changes to

26
00:02:31,840 --> 00:02:36,310
the file system what we more interested
in is what happened in the memory and

27
00:02:36,310 --> 00:02:39,850
there are several ways they're actually
many ways to do that but most of the

28
00:02:39,850 --> 00:02:45,620
time there are gonna three approaches
first is they usually they can be an

29
00:02:45,620 --> 00:02:53,800
empty P E section aware of extracts that
or they can be extracts the pale to the

30
00:02:53,800 --> 00:02:59,180
heap and then execute from the heap but
can replace the whole executable image

31
00:02:59,180 --> 00:03:05,440
and it can inject into another process
these are Kenneth three generic ways

32
00:03:05,440 --> 00:03:08,880
that we are cool can handle

33
00:03:08,880 --> 00:03:17,630
so let's let's look at them in a bit
more detail and let's just think what a

34
00:03:17,630 --> 00:03:21,980
generic and Packer should do so when
executing from the heat what happens is

35
00:03:21,980 --> 00:03:30,240
Mallory allocates some memory and signs
its execution privileges are now then it

36
00:03:30,240 --> 00:03:35,050
impacts the payload to that region and
then transfers control again this is a

37
00:03:35,050 --> 00:03:42,030
very generic generic diagram that it can
jump to that code can call it as a

38
00:03:42,030 --> 00:03:47,650
function that can mess with the stack or
exception handlers whatever so in this

39
00:03:47,650 --> 00:03:52,350
case the generic and Packers should
track the occasions in and watch out for

40
00:03:52,350 --> 00:03:58,510
memory that it is accessible for
execution and when the execution in that

41
00:03:58,510 --> 00:04:05,760
memory region is detected dump that
memory region where as we suggest as we

42
00:04:05,760 --> 00:04:06,760
think

43
00:04:06,760 --> 00:04:14,290
malicious payload should be then so when
replacing an image again it would

44
00:04:14,290 --> 00:04:20,570
usually allocates memory and the code
air that's easier to cooperate with

45
00:04:20,570 --> 00:04:27,870
upheld then just overrides the image
section by section and jumps to you and

46
00:04:27,870 --> 00:04:34,720
true point in this case a generic and
Packers should trace track changes to

47
00:04:34,720 --> 00:04:42,080
the executable image and then if changes
were made and execution in the in the

48
00:04:42,080 --> 00:04:47,630
code section was detected and dump it
dumped the whole the whole image and

49
00:04:47,630 --> 00:04:52,090
that's like what UPX does for instance
it has like an empty P E section and

50
00:04:52,090 --> 00:04:55,620
then it writes a new coach that peace
action without like any import table or

51
00:04:55,620 --> 00:04:59,710
whatever it resolves all that stuff
before unpacking and then execute from

52
00:04:59,710 --> 00:05:05,760
there either that or it can just come up
all the sections and then

53
00:05:05,760 --> 00:05:11,140
and map them again to maybe even two
different location and finally process

54
00:05:11,140 --> 00:05:15,820
injection this is the easiest one if my
where does inject code into another

55
00:05:15,820 --> 00:05:23,490
process then that code is important so
just dump everything so that there are

56
00:05:23,490 --> 00:05:28,010
many ways to implement a generic and
Packer no one would be a kernel driver

57
00:05:28,010 --> 00:05:34,710
that's actually very good way to do that
except you need driver guys to do that

58
00:05:34,710 --> 00:05:40,890
which we aren't then another and another
way to do that is helping to which is an

59
00:05:40,890 --> 00:05:46,740
interesting thing is a just-in-time
compiler that basically compiles every

60
00:05:46,740 --> 00:05:51,730
instruction and then execute them it's
very powerful and can a non-intrusive

61
00:05:51,730 --> 00:05:57,610
freely but it's really slow so can as a
point of the generic and Packers to make

62
00:05:57,610 --> 00:06:01,540
our analysis faster so we don't want to
go with that

63
00:06:01,540 --> 00:06:07,580
and finally is a reasonable is a
reasonable solution it can easy to

64
00:06:07,580 --> 00:06:14,200
bypass but at least we get it easier to
implement as well and well it's just

65
00:06:14,200 --> 00:06:18,480
something that we must most familiar
with and so we went with this we used

66
00:06:18,480 --> 00:06:22,550
Microsoft detours it's it's free
everybody can download it everybody can

67
00:06:22,550 --> 00:06:30,190
use it and everybody can reproduce what
we will be presenting now I'll shut up

68
00:06:30,190 --> 00:06:36,840
and let Nick walk you through the
implementation ok so our tool back

69
00:06:36,840 --> 00:06:41,590
protector it is Captain Hook based and
there's a packer we're gonna I can

70
00:06:41,590 --> 00:06:47,400
explain how to beat up that Packer now
Cinemagic takes place inside of a DLL

71
00:06:47,400 --> 00:06:51,450
that we inject into the mouth to the
mouth is going to be started suspended

72
00:06:51,450 --> 00:06:56,190
when injected lol into it let it run so
we use a mix of traditional detour

73
00:06:56,190 --> 00:07:01,730
hooking that's what we use Microsoft
detours for and with that detour hooking

74
00:07:01,730 --> 00:07:07,350
we use vector exception handler cooking
so this is a trick where you give memory

75
00:07:07,350 --> 00:07:09,800
you remove privileges from memory

76
00:07:09,800 --> 00:07:13,490
does so like if you want to check
remembers being written to you remove

77
00:07:13,490 --> 00:07:16,699
the right privilege from the memory and
thrown exception when it happens you can

78
00:07:16,699 --> 00:07:17,470
catch it

79
00:07:17,470 --> 00:07:22,060
restore right privilege or privileges
and let it executes thats type of

80
00:07:22,060 --> 00:07:27,419
hooking we use for execution and writing
on them our must run to completion once

81
00:07:27,419 --> 00:07:31,330
we inject the DL if the malware detected
something's wrong if it knows it's in a

82
00:07:31,330 --> 00:07:36,460
sandbox if it knows it's an avian if it
doesn't hit CNC so doesn't unpack any of

83
00:07:36,460 --> 00:07:39,280
these reasons will make it not work
right because there's nothing to detect

84
00:07:39,280 --> 00:07:44,150
if it decides not to unpack and for
obvious reasons you do you run this in

85
00:07:44,150 --> 00:07:51,659
like an hour analysis p.m. we're on our
testing hard nvm so we think is what its

86
00:07:51,659 --> 00:07:56,550
called there's a tool called P a fish
that you can use to check it does like

87
00:07:56,550 --> 00:08:01,039
all the normal detection techniques to
see if I can see him so you hard nvm use

88
00:08:01,039 --> 00:08:04,860
that if it can see any assume our can
see it and then it makes it easier

89
00:08:04,860 --> 00:08:07,719
because of our tech-savvy em it's not
gonna unpack and you're gonna think the

90
00:08:07,719 --> 00:08:14,800
tool failed so that's one of the
prerequisites so we can actually see the

91
00:08:14,800 --> 00:08:19,210
title soften the top it says
implementation and unpacking for heat

92
00:08:19,210 --> 00:08:23,340
based Packers so for heat base Packers
like we explained before what they can

93
00:08:23,340 --> 00:08:28,479
do their own unpack to executable heap
memory and just execute from there so

94
00:08:28,479 --> 00:08:32,469
the first step we're gonna hook and to
protect virtual memory and in geology

95
00:08:32,469 --> 00:08:36,250
virtual memory and when we have hooks on
those functions we can see when a page

96
00:08:36,250 --> 00:08:40,589
is given VMX acute either at all
location time or after the fact when is

97
00:08:40,589 --> 00:08:45,459
given VMX acute we can actually just
remove that p.m. execute from memory

98
00:08:45,459 --> 00:08:50,300
like it said it was read write execute
we just let me know given execute and

99
00:08:50,300 --> 00:08:54,709
then we have a vector exception handler
and we catch a DEP exceptions Data

100
00:08:54,709 --> 00:08:58,890
Execution Prevention exceptions when we
see a DEP exception come through we know

101
00:08:58,890 --> 00:09:04,370
execution happened on memory that was an
executable so then we'll check if it was

102
00:09:04,370 --> 00:09:08,730
one of our tracked pages that we removed
execution from then it was probably

103
00:09:08,730 --> 00:09:11,570
unpacked there so we don't that from
memory

104
00:09:11,570 --> 00:09:19,700
this is the implementation for pc-based
Packers this is a bit tricky r because

105
00:09:19,700 --> 00:09:25,340
the peace action at Lake win when the
process starts off like when it forks

106
00:09:25,340 --> 00:09:29,310
its gonna send everything upset all the
memory and stuff up how the according to

107
00:09:29,310 --> 00:09:33,040
the characteristics and the pea header
so the PE header says this section has

108
00:09:33,040 --> 00:09:37,190
these characteristics that mean
read-write execute then it can be given

109
00:09:37,190 --> 00:09:42,760
execute before where before our hooks
are there and so what we're gonna do is

110
00:09:42,760 --> 00:09:47,110
as soon as our hopes are injected we're
going to loop over every peace action if

111
00:09:47,110 --> 00:09:49,830
we see something that has execute well
that's fine

112
00:09:49,830 --> 00:09:54,900
there should be some executable code but
it should also be writable by default

113
00:09:54,900 --> 00:09:59,120
the entry point sections not writable if
you see something that's ridable and

114
00:09:59,120 --> 00:10:03,720
executable instead of tracking execute
you remove the right clip privilege from

115
00:10:03,720 --> 00:10:08,210
it and then within the vector exception
handler will get an access violation if

116
00:10:08,210 --> 00:10:11,850
something treasure right to that peace
action can execute just fine until

117
00:10:11,850 --> 00:10:15,820
something traced to write to it we get
an exception and then we switch we

118
00:10:15,820 --> 00:10:18,630
remove execution now because we assume
this right

119
00:10:18,630 --> 00:10:22,930
wrote the code and then next time it
execute our vector exception handler

120
00:10:22,930 --> 00:10:27,460
will catch it again after the right and
now we know if cobras and packed we

121
00:10:27,460 --> 00:10:31,110
dumped out of memory to desk and I'll
catch ups and all these other packers at

122
00:10:31,110 --> 00:10:38,070
work this way and then there's the
injection whether it's injecting DLL

123
00:10:38,070 --> 00:10:42,850
doing a manual map to another process
whatever it does we'll catch that just

124
00:10:42,850 --> 00:10:43,410
by

125
00:10:43,410 --> 00:10:47,030
there's only two hundred points in that
really which is any rate virtual memory

126
00:10:47,030 --> 00:10:50,580
and Auntie map view of section to the
only real ways to get memory into

127
00:10:50,580 --> 00:10:53,700
another process from user mode so you
just hope those you dump everything

128
00:10:53,700 --> 00:10:57,310
everything should be important in that
case so just dump the entire buffer from

129
00:10:57,310 --> 00:11:04,910
memory so we did run into some problems
that took awhile to figure out at one

130
00:11:04,910 --> 00:11:10,040
point some malware just like it wasn't
throwing exceptions we didn't know why

131
00:11:10,040 --> 00:11:14,590
and then was like oh that's a flag in
the PE header and if it's not set a

132
00:11:14,590 --> 00:11:19,680
compile-time we won't get the exceptions
so there's a function that just call set

133
00:11:19,680 --> 00:11:22,819
process debt policy Windows API function
enabled app

134
00:11:22,819 --> 00:11:28,039
done another probably ran into some time
to access violation exception just occur

135
00:11:28,039 --> 00:11:32,350
from our could be terrible there could
be a bug in the mouth where it could be

136
00:11:32,350 --> 00:11:35,439
using it to transfer control flow
there's a bunch of reasons why access

137
00:11:35,439 --> 00:11:39,989
violations occur and like the first
iteration of our vector exception

138
00:11:39,989 --> 00:11:43,739
handler just wasn't handling this well
so sometimes it would see an access

139
00:11:43,739 --> 00:11:47,350
violation that wasn't due to one of our
memory hooks and get confused and would

140
00:11:47,350 --> 00:11:51,220
cause a malware to like break it
wouldn't run or whatever so we had to

141
00:11:51,220 --> 00:11:54,879
deal with that and make sure to only
handle exceptions reeve triggered

142
00:11:54,879 --> 00:12:08,289
ourselves sometimes I just don't trigger
properly we never really figured out why

143
00:12:08,289 --> 00:12:12,319
there is it's only like WinNT create
thread happens when a new thread happens

144
00:12:12,319 --> 00:12:16,049
on on executing our memory sometimes a
DEP exceptions acted weird instead of

145
00:12:16,049 --> 00:12:19,579
figuring out why we just took them to
create thread because that's we can

146
00:12:19,579 --> 00:12:28,350
detect execution that way to know why
not we can break now where is if the

147
00:12:28,350 --> 00:12:33,579
power is compiled without depth on then
it might have just been unpacking to

148
00:12:33,579 --> 00:12:37,789
writable memory and executing there and
never giving it executes and now it

149
00:12:37,789 --> 00:12:41,199
still work when deputies turned off but
now that we've been forced to tap and

150
00:12:41,199 --> 00:12:45,829
where to track stuff it can make them
our not run sometimes so like with

151
00:12:45,829 --> 00:12:51,129
access violations we just had to be like
very sure that DEP exceptions are under

152
00:12:51,129 --> 00:12:54,939
tracking and if we get a DEP exception
that occurs that isn't a result of one

153
00:12:54,939 --> 00:12:59,449
are member of one of our memory hooks we
need to just let it go to restore page

154
00:12:59,449 --> 00:13:03,679
execute so can execute and then we let
it go without doing anything and that

155
00:13:03,679 --> 00:13:10,239
kinda simulate stepless and then some
Packers are to stage like malware

156
00:13:10,239 --> 00:13:14,879
download something drops it to the file
system runs that that on packs so did

157
00:13:14,879 --> 00:13:20,839
attack that we just doesn't create
process internal we make it create any

158
00:13:20,839 --> 00:13:25,720
processes are suspended inject into them
and then on suspend this way we will

159
00:13:25,720 --> 00:13:31,320
just keep like recursively going into
any new processes and dumping from there

160
00:13:31,320 --> 00:13:36,280
and the biggest problem so far the code
just keeps getting more complex more

161
00:13:36,280 --> 00:13:39,670
unreadable there's all these weird hooks
going on all these like flag checks of

162
00:13:39,670 --> 00:13:43,310
memory all this other stuff so the only
solution we found for that is just like

163
00:13:43,310 --> 00:13:48,040
refactor and cry because I yeah it's
getting a million I really don't know

164
00:13:48,040 --> 00:13:57,060
how to fix it is so we're like we've
already talked about as a packer

165
00:13:57,060 --> 00:14:01,900
attacker the hooks are written in C++
injectors and C++ we have some Python

166
00:14:01,900 --> 00:14:05,640
bootstrapping scripts for testing like
dispatching stuff the PM's you guys are

167
00:14:05,640 --> 00:14:11,130
going to see that soon a demo Visual
Studio 2010 is what I used Microsoft

168
00:14:11,130 --> 00:14:16,300
detours on it only works in 32 bit
because you need to pay $10,000 get 64

169
00:14:16,300 --> 00:14:20,460
bit detours or break your own cooking
engineer use mad she would you still

170
00:14:20,460 --> 00:14:26,810
like a thousand bucks so 32 bit only and
we use VMWare Fusion for testing we have

171
00:14:26,810 --> 00:14:31,190
to get up repo rate there I will handed
back to Vadim he's going to show you

172
00:14:31,190 --> 00:14:38,530
guys a live demo and talk about the
experiments in our success rates ok so

173
00:14:38,530 --> 00:14:48,300
very first prototype and we wanted to
test the efficiency so we set up this

174
00:14:48,300 --> 00:14:52,890
little testing environment so we
downloaded a bunch of malware from

175
00:14:52,890 --> 00:14:58,870
ryushare.com concretely we downloaded
the torrent with its use in Citadel

176
00:14:58,870 --> 00:15:05,530
based malware and so is it is it a
perfect is it an amazing best in the

177
00:15:05,530 --> 00:15:10,490
world now where Sharon know is it
statistically representative it's

178
00:15:10,490 --> 00:15:16,680
probably not but there is no data said
would be 100% statistically

179
00:15:16,680 --> 00:15:21,990
representative but the big advantage of
Irish shares that you can download a lot

180
00:15:21,990 --> 00:15:30,030
of malware in in a torrent and we chose
Zeus and Citadel back his term

181
00:15:30,030 --> 00:15:37,270
many samples collected for like five
years or so and these days are banking

182
00:15:37,270 --> 00:15:42,960
charges that are very well studied and
it's easy to automate automatically

183
00:15:42,960 --> 00:15:45,740
check whether the packing was complete
or not

184
00:15:45,740 --> 00:15:51,350
different malware artifacts such as the
registry keys me be your agent strings

185
00:15:51,350 --> 00:16:00,280
and stuff are known so we could check
for that so we then filtered we only

186
00:16:00,280 --> 00:16:05,130
included 32 be executable some DLLs are
not supported for now and 64 bit is not

187
00:16:05,130 --> 00:16:10,360
supported for now so we put everything
into database and then for each

188
00:16:10,360 --> 00:16:16,670
experiment we sample three hundred and
fifty files randomly from that data set

189
00:16:16,670 --> 00:16:21,280
and submitted to our test virtual
machines a number three hundred and

190
00:16:21,280 --> 00:16:29,530
fifty has no scientific rationale for
why we picked it is because on early

191
00:16:29,530 --> 00:16:36,340
stages of development things just go
wrong all the time and we had to

192
00:16:36,340 --> 00:16:40,990
manually go through all that malware
manually recreate the unpacking steps

193
00:16:40,990 --> 00:16:46,060
and find out what went wrong and how
should we adjust our own packing

194
00:16:46,060 --> 00:16:50,520
algorithm so three hundred and fifty
years about the number we were

195
00:16:50,520 --> 00:16:57,310
comfortable with going manually in a few
days so and then we had the weirdest

196
00:16:57,310 --> 00:17:02,390
election you read this Mac with VMware
Fusion on and we are doing it a little

197
00:17:02,390 --> 00:17:10,090
bit and just tested regularly constantly
and we were adjusting our scripts and

198
00:17:10,090 --> 00:17:14,959
then we walked everything into their
results journal

199
00:17:14,959 --> 00:17:20,059
so what are what is the Packer attack
what are what are the components first

200
00:17:20,059 --> 00:17:24,689
of all it's the DLL called back or
attacking hook it's the basically the

201
00:17:24,689 --> 00:17:31,210
core engine of the basically it is an
attacker then their packet every exam

202
00:17:31,210 --> 00:17:34,740
which is just which is just an
executable that she starred in it

203
00:17:34,740 --> 00:17:44,080
injects the DLL into into malware and it
works very simple at the moment it

204
00:17:44,080 --> 00:17:52,750
doesn't mean API or user interface you
just put both into your path and you

205
00:17:52,750 --> 00:17:59,980
create a folder called dams in the in
the C Drive and that's it and you gonna

206
00:17:59,980 --> 00:18:04,460
need your probably gonna need Microsoft
Visual C++ Redistributable and that's

207
00:18:04,460 --> 00:18:12,309
enough to run a macro tracker on your
machine so when we were setting up our

208
00:18:12,309 --> 00:18:19,409
view this is just the you know the kind
of guidelines we were using the first of

209
00:18:19,409 --> 00:18:25,870
all we would not recommend installing
VMware or VirtualBox tools in the gas is

210
00:18:25,870 --> 00:18:33,169
tomorrow where do you take those by just
simply looking into their registry and

211
00:18:33,169 --> 00:18:40,409
looking for names VMware Oracle or
whatever and it's really really trivial

212
00:18:40,409 --> 00:18:48,870
to find soon so this is a no-no and Dan
virtual machines communicate only to the

213
00:18:48,870 --> 00:18:51,330
to the hosts as an internal network

214
00:18:51,330 --> 00:18:55,770
and before actually running a
large-scale experiments we used paranoid

215
00:18:55,770 --> 00:19:02,170
fish to check how brown from our
machines were to the bypasses now an

216
00:19:02,170 --> 00:19:07,420
important important things here is his
diet parented fish is actually a pretty

217
00:19:07,420 --> 00:19:13,500
pretty goood user testing tool for
europe yams and it's really hard to

218
00:19:13,500 --> 00:19:19,330
satisfy all of the checks that it does
but we'd recommend to do is once you are

219
00:19:19,330 --> 00:19:25,480
once you reasonably good once you pass
the most of the checks were the couple

220
00:19:25,480 --> 00:19:32,070
we didn't pass but that does fine as
though something that there was some

221
00:19:32,070 --> 00:19:40,140
something that man will detect and won't
run so you cannot reach 100% success

222
00:19:40,140 --> 00:19:47,780
rate here now and then we run in testing
setup and use the results with brought

223
00:19:47,780 --> 00:19:56,690
in almost 90% of cases we were able to
dump shouldn't code doesn't mean it's

224
00:19:56,690 --> 00:20:04,470
it's an absolutely perfect readable well
aligned executable but there are chunks

225
00:20:04,470 --> 00:20:12,680
of actual malware actual malicious
payload but you still can work with an

226
00:20:12,680 --> 00:20:19,970
extract some streams maybe some other
indicators may be creeped 0 constants

227
00:20:19,970 --> 00:20:21,410
and so on

228
00:20:21,410 --> 00:20:27,390
about future about 45 percent of all
malware were tested we were able to Dom

229
00:20:27,390 --> 00:20:35,480
actually the full P which is interesting
is it means half of the times in this

230
00:20:35,480 --> 00:20:37,090
data set

231
00:20:37,090 --> 00:20:44,640
at some point has the full P in the
memory as Nick mentioned enforcing DDP

232
00:20:44,640 --> 00:20:51,990
DAP caused a side effect milder would
crash and the good thing is that most

233
00:20:51,990 --> 00:20:58,240
Margaret crash after we already dumped
it afterward the payload but still we

234
00:20:58,240 --> 00:21:08,100
have around 30 percent of crashes so
while some precious yeah some crashes

235
00:21:08,100 --> 00:21:12,950
happened because because of us sometimes
just is just bad now we're maybe too old

236
00:21:12,950 --> 00:21:17,770
now that was written for older sis
running on Windows seven by the way and

237
00:21:17,770 --> 00:21:23,410
above 4% just eres we have no idea what
happened

238
00:21:23,410 --> 00:21:32,370
era so error is we have we have logs to
cut the staff at the Packer attacker

239
00:21:32,370 --> 00:21:39,220
generates we have dumps and we have logs
and in the log we can indicate either

240
00:21:39,220 --> 00:21:45,460
the crash happened or if it's only for
your log is empty then something went

241
00:21:45,460 --> 00:21:51,130
wrong and this is what encounters areas
where there was nothing there

242
00:21:51,130 --> 00:22:00,620
cute so some interesting statistics with
other number of his number of junks

243
00:22:00,620 --> 00:22:08,210
around 13 in average but standard
deviation which is should be estd not

244
00:22:08,210 --> 00:22:13,330
STF standard deviation is 12.5 so

245
00:22:13,330 --> 00:22:19,810
statistically statistically speaking
this isn't really a good data said but

246
00:22:19,810 --> 00:22:20,570
then again

247
00:22:20,570 --> 00:22:26,830
impossible to find good data and maximum
was 62 and also announces that only 20%

248
00:22:26,830 --> 00:22:33,710
of malware dataset used process which is
which is interesting time

249
00:22:33,710 --> 00:22:41,789
most popular most common technique with
expected spectrum are also when we say

250
00:22:41,789 --> 00:22:46,140
we have like thirteen dumps it doesn't
necessarily mean there's thirteen things

251
00:22:46,140 --> 00:22:51,760
unpacked sometimes it can just mean that
like its unpacked in like a huge piece

252
00:22:51,760 --> 00:22:55,309
of code execution thirteen different
places and their non sequential they

253
00:22:55,309 --> 00:22:58,529
were all located together and we just
don't have a way to clear those together

254
00:22:58,529 --> 00:23:01,440
so doesn't mean there's thirteen
different pieces of our being unpacked

255
00:23:01,440 --> 00:23:09,200
just that and execute in 13 different
places on the same malware and here's

256
00:23:09,200 --> 00:23:14,320
how the number of extracted cochons
distributed so

257
00:23:14,320 --> 00:23:19,529
horizontal axis is now where samples and
vertical is the number of hidden chunks

258
00:23:19,529 --> 00:23:24,580
and interestingly we have at least two
distinct stripes what does it mean I

259
00:23:24,580 --> 00:23:31,450
don't know just my sister pattern says
it's an interesting pattern without

260
00:23:31,450 --> 00:23:40,110
worth worth mentioning yeah maximum 62
someone run malware has 62 chunks of

261
00:23:40,110 --> 00:23:51,950
code executed before it jumped to their
payload so let me show you that thing in

262
00:23:51,950 --> 00:23:53,940
action

263
00:23:53,940 --> 00:24:10,140
sure yes

264
00:24:10,140 --> 00:24:19,980
mentioned didn't produce any banding
dumps

265
00:24:19,980 --> 00:24:30,320
so here we have our virtual machine it's
not a hardened target p.m. is just a

266
00:24:30,320 --> 00:24:36,690
basic p.m. and it's very slow for some
reason when I plug in and other modern

267
00:24:36,690 --> 00:24:46,410
get slow so we have the Packer attacker
can you see how we have the Packers have

268
00:24:46,410 --> 00:24:51,799
around the back protector who work in
the Windows folder so they are in the

269
00:24:51,799 --> 00:25:03,320
path and we have the dumps folder
charities it's in the C Drive so now we

270
00:25:03,320 --> 00:25:19,650
can launch the Packer attacker Citadel
here in banking Trojan so and when we do

271
00:25:19,650 --> 00:25:25,780
this we see some stuff going on here

272
00:25:25,780 --> 00:25:29,760
it generates the dumps

273
00:25:29,760 --> 00:25:39,669
so there's multiple different kinds of
dumps it still going ok so you see the

274
00:25:39,669 --> 00:25:43,049
ones that have like the notepad icon
those are just logs you can see the

275
00:25:43,049 --> 00:25:46,929
process ideas within brackets at the
same one dumped so in the brackets is a

276
00:25:46,929 --> 00:25:50,110
process I knew in case we inject into a
new process you can kind of trace back

277
00:25:50,110 --> 00:25:54,260
to where it came from the next number
you see after the underscores just a

278
00:25:54,260 --> 00:25:57,970
timestamp so we can tell how many
milliseconds apart did we generate these

279
00:25:57,970 --> 00:26:01,510
dumps that helps an analysis that helps
us tell us they were sleep calls and

280
00:26:01,510 --> 00:26:05,220
stuff like this that malware might do it
also helps us determine how long we need

281
00:26:05,220 --> 00:26:09,210
to keep the VMware inning for by
checking how long most dumps come out

282
00:26:09,210 --> 00:26:12,690
the next number is the start

283
00:26:12,690 --> 00:26:17,110
memory address where it was unpacked to
Wetherby memory address or whatever P

284
00:26:17,110 --> 00:26:22,659
had her where wasn't happy and then the
one after that is the end address

285
00:26:22,659 --> 00:26:27,769
after that is so for this kind of dump
this is a dump that we we detected with

286
00:26:27,769 --> 00:26:32,889
execute with our depth hooks so we have
the entry point after that but offset

287
00:26:32,889 --> 00:26:39,119
into this dump where where the code
entry point where where the co executed

288
00:26:39,119 --> 00:26:43,169
at CNN you can throw this into Ida and
you can tell entry point is here and

289
00:26:43,169 --> 00:26:46,409
you're starting at the same place at the
malware started at so it's a bit easier

290
00:26:46,409 --> 00:26:50,729
to analyze and just jumping into the
dump on there's other types of dumps

291
00:26:50,729 --> 00:26:55,599
will see like if you look down to the W
PM's can you go down to the wpm yeah

292
00:26:55,599 --> 00:27:00,269
these wpm they're just right process
memory sucks so we just dumped the whole

293
00:27:00,269 --> 00:27:03,340
thing there's no execution information
there so we don't have an entry point

294
00:27:03,340 --> 00:27:08,970
but everything else is the same there's
also the dot and vos . dont thats map

295
00:27:08,970 --> 00:27:12,399
view of section it's the same as the
right process memory dumps where we

296
00:27:12,399 --> 00:27:16,080
don't we don't have any spike execution
state information so we just give you

297
00:27:16,080 --> 00:27:26,600
the science and where it was alright

298
00:27:26,600 --> 00:27:34,580
I just wanted to demonstrate what was
the effect of using the protector so if

299
00:27:34,580 --> 00:27:52,360
we run so if we're on for example
strings on that malware samples will see

300
00:27:52,360 --> 00:27:59,130
that there isn't much and if we check
the entropy and the section information

301
00:27:59,130 --> 00:28:04,280
will see that this region because I
entropy region with his usually

302
00:28:04,280 --> 00:28:08,950
indicative of unpacking this particular
one is packed into several has several

303
00:28:08,950 --> 00:28:17,590
several layers of packing and the outer
layer is UPX you can see here so then

304
00:28:17,590 --> 00:28:28,720
lets copies of these dumps back to the
host and I'll show you what to do with

305
00:28:28,720 --> 00:28:38,700
them because we have quite a few

306
00:28:38,700 --> 00:28:52,690
superfast yes

307
00:28:52,690 --> 00:29:13,690
now if we will probably put the mic here
they need both hands can hear me yes so

308
00:29:13,690 --> 00:29:21,570
when you look at the dams we actually
see that the plenty of those so what

309
00:29:21,570 --> 00:29:26,890
packer attacker does is just does what
we explain so dumps everything things

310
00:29:26,890 --> 00:29:35,670
suspicions up to an analyst or some sort
of post processing tools and scripts to

311
00:29:35,670 --> 00:29:39,640
figure out what to do with those dams
but it's really easy there's really

312
00:29:39,640 --> 00:29:41,670
nothing special

313
00:29:41,670 --> 00:29:46,990
first check you can do just checked the
file and knew immediately can see that

314
00:29:46,990 --> 00:29:52,710
we actually were lucky enough to dump
several full peas and it also as you can

315
00:29:52,710 --> 00:29:58,630
see there are two dumps that are dumped
dumped from the memory and then there's

316
00:29:58,630 --> 00:30:03,520
one right process memory dump and what
it means it means there were several

317
00:30:03,520 --> 00:30:09,770
wares at some point unpacked itself into
memory and then it ran and then injected

318
00:30:09,770 --> 00:30:18,140
into another process you can get the
idea of how the initial infection goes

319
00:30:18,140 --> 00:30:28,480
on so and if we look into that one of
the dam system memory dump we done from

320
00:30:28,480 --> 00:30:31,550
the hip if we look at this

321
00:30:31,550 --> 00:30:39,330
the strains we will actually find

322
00:30:39,330 --> 00:30:53,170
can see the full address table some user
agent strings and so on this when you do

323
00:30:53,170 --> 00:30:58,010
not that lucky well sometimes mouth has
something like really interesting like

324
00:30:58,010 --> 00:31:02,310
maybe your else of the
command-and-control servers or maybe

325
00:31:02,310 --> 00:31:07,740
some indicators that are very useful for
detection for example but most of the

326
00:31:07,740 --> 00:31:11,960
time is something like this and
sometimes you don't see the strains

327
00:31:11,960 --> 00:31:18,170
although you bad the final payload all
the strings could be encrypted and as

328
00:31:18,170 --> 00:31:23,510
well as the API function names and
resolve on the fly and we have a couple

329
00:31:23,510 --> 00:31:28,720
of ideas what to do with it but so far
he's just as far as it as far as it gets

330
00:31:28,720 --> 00:31:40,920
and if we look again if we look at the
entropy then then you'll see that it

331
00:31:40,920 --> 00:31:48,470
actually looks reasonably good that this
is a good and troop 44 binaries just the

332
00:31:48,470 --> 00:31:55,310
green plot by the way is the frequency
of FFO combined frequency over 500

333
00:31:55,310 --> 00:32:01,810
to these two bites guess statistically
bytes in

334
00:32:01,810 --> 00:32:18,960
executables for a bit so it's a good
thing to plot and look ok so interesting

335
00:32:18,960 --> 00:32:26,670
observations we we've made during this
research while the Packers at some point

336
00:32:26,670 --> 00:32:32,680
they have the full P into memory and we
can dump it so it's easy to defeat

337
00:32:32,680 --> 00:32:39,550
really take that a lot of times we can
take that PE that we don't and we can

338
00:32:39,550 --> 00:32:44,250
just run it on it's own it's got no
dependencies on the Packer it's like we

339
00:32:44,250 --> 00:32:47,450
can just throw in Olean analyzer
throughout the night and have a full

340
00:32:47,450 --> 00:32:53,500
binary like it's everything's intact so
they're on on the on on the other hand

341
00:32:53,500 --> 00:33:00,210
we we found out that malware is prone to
crashing if we enforce step it's weird

342
00:33:00,210 --> 00:33:27,990
maybe as a result of bad design and
decryption layers will not necessarily

343
00:33:27,990 --> 00:33:32,360
layers but can a decryption steps before
the final payload kicks in

344
00:33:32,360 --> 00:33:37,610
was also interested in and on its own
might be a good indicator of now if you

345
00:33:37,610 --> 00:33:41,720
want to detect mouse want to tell it
from the actual binary you can actually

346
00:33:41,720 --> 00:33:46,450
try to unpack it and see the number of
layers which is interesting

347
00:33:46,450 --> 00:33:56,240
so let's let's settle for second go back
to the results and so as you can see

348
00:33:56,240 --> 00:34:02,730
percent is a good result doesn't mean
that our tools billion always quite get

349
00:34:02,730 --> 00:34:13,480
it but the high success rate because
bankers are kind of you see my writers

350
00:34:13,480 --> 00:34:18,550
they don't really bother writing
advanced backers only reason they do is

351
00:34:18,550 --> 00:34:23,570
to bypass different but very signature
checks and so on and for a navy for

352
00:34:23,570 --> 00:34:28,970
example on the house they cannot afford
to run their mouths sample and two

353
00:34:28,970 --> 00:34:34,100
lighted fully execute and dump it so
maybe these are good enough to bypass

354
00:34:34,100 --> 00:34:40,500
some but they're pretty pretty bad that
they use the same kind of pattern that

355
00:34:40,500 --> 00:34:45,989
we exploit and weakened um so that's why
we have such a reasonably good success

356
00:34:45,990 --> 00:34:50,600
rate so what's the future work

357
00:34:50,600 --> 00:34:59,960
the crash as well at least as many as we
can then will we have some ideas for

358
00:34:59,960 --> 00:35:09,930
anti anti honking at this point it's
relatively easy to detect the hoax and

359
00:35:09,930 --> 00:35:14,670
yeah we're gonna implemented yellow
support that you are kind of three main

360
00:35:14,670 --> 00:35:20,510
steps another idea we had his maybe you
make it as a sandbox module but the

361
00:35:20,510 --> 00:35:22,710
problem is that they also using hooks

362
00:35:22,710 --> 00:35:29,220
and these might be exclusive we gonna
have to think about that I guess that's

363
00:35:29,220 --> 00:35:29,950
about it

364
00:35:29,950 --> 00:35:35,820
this is the source code location you can
downloaded download into their check

365
00:35:35,820 --> 00:35:44,000
check amount for or try to modify and
very welcome your criticism go ahead and

366
00:35:44,000 --> 00:35:50,950
destroy us tell us tell us how we stock
and how we were doing it wrong and where

367
00:35:50,950 --> 00:36:05,290
we welcome them were very very warmly
welcomed that so that's it thank you we

368
00:36:05,290 --> 00:36:17,160
ran this really really fast so we have
plenty of time for questions

369
00:36:17,160 --> 00:36:25,550
anti anti cooking methods so there's
like a lot of well-documented ways to do

370
00:36:25,550 --> 00:36:30,690
this so since we know exactly what we're
gonna hook and we're kind of in control

371
00:36:30,690 --> 00:36:34,910
of the V em like if we know the VMA 2007
for instance we can write our own hooks

372
00:36:34,910 --> 00:36:38,060
where we put a jump in the middle of the
function or something somewhere where

373
00:36:38,060 --> 00:36:41,130
the powers not gonna see it and we know
what the state is so that we could do

374
00:36:41,130 --> 00:36:45,290
something from there another thing we
can do is sense all as far as I know all

375
00:36:45,290 --> 00:36:48,970
the guys were hooking you system calls
we could just hook the system calls

376
00:36:48,970 --> 00:36:52,760
themselves we can scan the binaries
override the system calls with an entry

377
00:36:52,760 --> 00:36:56,740
catch that do something like that we can
I think there's chaos if a system call

378
00:36:56,740 --> 00:37:00,720
you have that function you hook every
system call in 32 bit binaries on

379
00:37:00,720 --> 00:37:02,500
Windows we could do something like that

380
00:37:02,500 --> 00:37:09,280
mad she hook is a library with a lot of
good anti anti cooking methods in its so

381
00:37:09,280 --> 00:37:12,630
doing some reversing their could give us
more information and just I'm sure

382
00:37:12,630 --> 00:37:15,900
there's been talks and white papers on
it that I would research when we went

383
00:37:15,900 --> 00:37:22,830
about that anyone else

384
00:37:22,830 --> 00:37:31,640
so I was actually thinking about that as
we're going to the talk like the

385
00:37:31,640 --> 00:37:35,060
question was how we run into our that
use of actor and structured exception

386
00:37:35,060 --> 00:37:38,690
handling heavy run into problems so I
was thinking about that we're giving the

387
00:37:38,690 --> 00:37:43,120
talk actually just hit me that like some
of the areas we are getting could be

388
00:37:43,120 --> 00:37:46,380
because they're using these exception
handlers to detect

389
00:37:46,380 --> 00:37:51,600
VMI's like common ways to detect VMware
detect debuggers are is to throw certain

390
00:37:51,600 --> 00:37:55,600
types of exceptions and catch those
exceptions and if they're not caught it

391
00:37:55,600 --> 00:37:59,290
means the debugger something there so we
could be stepping on that in some place

392
00:37:59,290 --> 00:38:03,450
but we haven't done research there and
there were also uses it for a

393
00:38:03,450 --> 00:38:08,310
control-flow transfer so it all like
unpack to one place and then thrown

394
00:38:08,310 --> 00:38:11,910
exception with the exception handler
dress as the address of where and unpack

395
00:38:11,910 --> 00:38:16,530
too as I can indirect control transfer
we see that a lot and as far as I know

396
00:38:16,530 --> 00:38:20,850
we work pretty well with that but I'm
not sure about other reasons why they

397
00:38:20,850 --> 00:38:32,320
might be using it will have to research
that they can do that so the question

398
00:38:32,320 --> 00:38:37,370
was can they detect that detours is
there and not unpack and the answer to

399
00:38:37,370 --> 00:38:42,930
that is yes that goes with the anti anti
hooking another thing we can do there is

400
00:38:42,930 --> 00:38:48,960
since we we're in the malware before it
runs it suspended right so we can unlink

401
00:38:48,960 --> 00:38:53,290
from the modulus so they don't see Rd
lol we can hook whatever functions are

402
00:38:53,290 --> 00:38:56,760
going to be using to read the memory
from the deal also check if the bites

403
00:38:56,760 --> 00:38:59,910
are the same and we can spoof what
everyone of course there's always ways

404
00:38:59,910 --> 00:39:02,980
around that just like there's ways
around whatever sandbox you can think of

405
00:39:02,980 --> 00:39:07,790
but it's it's good enough because this
is a small enough to order all the power

406
00:39:07,790 --> 00:39:10,480
we run into doesn't know anything about
it and I know knows a thing about this

407
00:39:10,480 --> 00:39:14,030
tool so right now it's good in the
future now that we're releasing it and

408
00:39:14,030 --> 00:39:19,320
hoping people start using and we will
have to think about this stuff

409
00:39:19,320 --> 00:39:24,660
one little remark we have all these nice
names here is so in the grip on the

410
00:39:24,660 --> 00:39:29,760
gipper we have all nice names back
retired Rd allow the script called

411
00:39:29,760 --> 00:39:36,270
unpack taught by the gas escaped called
agent . my of course when you deploy it

412
00:39:36,270 --> 00:39:44,930
is recommended to randomize those names
because yeah because for example sandbox

413
00:39:44,930 --> 00:39:53,110
or in some other sandboxes it also named
agent by so maybe they will buy that but

414
00:39:53,110 --> 00:40:00,370
we only named this way because for the
you know the crap clarity 124 people who

415
00:40:00,370 --> 00:40:16,940
read that code for them to know what
does that do so how high is our

416
00:40:16,940 --> 00:40:24,690
confidence that we enumerated all the
possible way my work in on itself I'm

417
00:40:24,690 --> 00:40:34,040
sorry yeah it's hard to you give you the
exact number that there's nothing I can

418
00:40:34,040 --> 00:40:38,650
think of so this is just based on our
experience with Mauer I do our analyses

419
00:40:38,650 --> 00:40:43,300
on daily basis these are things I most
commonly see and one of the reasons were

420
00:40:43,300 --> 00:40:49,810
made it made it open sources for other
people we might be biased because we

421
00:40:49,810 --> 00:40:55,490
don't have every every kind of man hours
that's possible and some people are

422
00:40:55,490 --> 00:40:59,730
better than they have their own data
sets that might be different and so we

423
00:40:59,730 --> 00:41:03,930
welcome to try our tool in their data
set and give us feedback and we'll be

424
00:41:03,930 --> 00:41:11,450
happy to adjust the algorithm but so far
that this is this is the kind of the

425
00:41:11,450 --> 00:41:16,090
scope of the tool and to also address at
like he said we're going with what we

426
00:41:16,090 --> 00:41:20,010
see so I can already think of a few ways
to do it right like I might create a

427
00:41:20,010 --> 00:41:23,360
shared memory chunk of my process rights
himself to their it's not executable

428
00:41:23,360 --> 00:41:27,190
then injects shellcode in another
process that grabs and memory segment

429
00:41:27,190 --> 00:41:28,829
gives an execution privileges running

430
00:41:28,829 --> 00:41:33,249
it as far as I know where we're not
going to detect that at all but no one

431
00:41:33,249 --> 00:41:39,039
does that at this point if I probably
just gave bad guys good idea but if they

432
00:41:39,039 --> 00:41:43,969
do start doing stuff like this it's
trivial to detect the main thing we're

433
00:41:43,969 --> 00:41:49,349
worried about is if this becomes a thing
malware wants to hide from the easiest

434
00:41:49,349 --> 00:41:52,319
way is to hide from hooks it's not to
come up with a new packing outgrow them

435
00:41:52,319 --> 00:41:55,789
it's not to rewrite your Packers it's
not to do something crazy it's the

436
00:41:55,789 --> 00:41:59,069
bypass so that's that's why that's one
of the main things were thinking about

437
00:41:59,069 --> 00:42:08,940
fixing no one else ok well I think we're
good thank you for your time it's been

438
00:42:08,940 --> 00:42:14,839
great hope to see you guys at the party
tonight have a good one thanks

