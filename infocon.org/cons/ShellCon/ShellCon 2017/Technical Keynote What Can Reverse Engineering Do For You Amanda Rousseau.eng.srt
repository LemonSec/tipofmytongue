1
00:00:12,860 --> 00:00:18,029
all right so some of you already know me

2
00:00:15,780 --> 00:00:21,150
from Twitter my name my actual name is

3
00:00:18,029 --> 00:00:22,890
Amanda Russo I go by my unicorn because

4
00:00:21,150 --> 00:00:25,320
I would thought it was funny

5
00:00:22,890 --> 00:00:27,449
and I like zombie unicorns because why

6
00:00:25,320 --> 00:00:31,439
not have like fluffy stuff with like

7
00:00:27,449 --> 00:00:33,870
evil stuff together so what do I do

8
00:00:31,439 --> 00:00:35,820
I'm a senior our researcher at in game I

9
00:00:33,870 --> 00:00:39,930
look at Mauer all day I write detection

10
00:00:35,820 --> 00:00:40,980
plugins on the side I do I speak at

11
00:00:39,930 --> 00:00:44,129
conferences

12
00:00:40,980 --> 00:00:47,640
I teach Mauer reverse engineering and I

13
00:00:44,129 --> 00:00:51,510
do this on my own time so it's I don't

14
00:00:47,640 --> 00:00:53,610
sleep I'm also on the DEF CON CFP Review

15
00:00:51,510 --> 00:00:57,809
Board and now I'm on the opt code review

16
00:00:53,610 --> 00:01:00,180
board for Dubai I host meetups I have a

17
00:00:57,809 --> 00:01:03,328
meet-up locally in San Francisco I

18
00:01:00,180 --> 00:01:06,240
follow fashion trends I started vanity

19
00:01:03,329 --> 00:01:10,170
sex to follow like cyber and security

20
00:01:06,240 --> 00:01:12,949
and fashion and I occasionally post

21
00:01:10,170 --> 00:01:17,439
on Twitter

22
00:01:12,950 --> 00:01:19,700
a lot of fun stuff so why

23
00:01:17,439 --> 00:01:22,070
reverse-engineering I don't know how

24
00:01:19,700 --> 00:01:24,799
many of you actually delved into reverse

25
00:01:22,070 --> 00:01:26,750
engineering but it's a lot of it's in a

26
00:01:24,799 --> 00:01:28,970
lot of disciplines in cybersecurity it's

27
00:01:26,750 --> 00:01:30,799
one of the foundations of both the red

28
00:01:28,970 --> 00:01:32,450
team and blue team and I've kind of

29
00:01:30,799 --> 00:01:34,039
listed out you know where reverse

30
00:01:32,450 --> 00:01:36,860
engineering might apply in different

31
00:01:34,039 --> 00:01:38,600
disciplines mainly I've been on the blue

32
00:01:36,860 --> 00:01:40,219
team most of the time but I've started

33
00:01:38,600 --> 00:01:43,490
to venture out into a little bit of red

34
00:01:40,219 --> 00:01:46,759
teaming but you'll see that it's just a

35
00:01:43,490 --> 00:01:49,339
foundation so I thought wow I really

36
00:01:46,759 --> 00:01:50,659
need to teach people what I know to

37
00:01:49,340 --> 00:01:51,979
teach them in a different way than what

38
00:01:50,659 --> 00:01:56,479
they learned in college or what they

39
00:01:51,979 --> 00:01:58,970
learn in normal trainings so what I want

40
00:01:56,479 --> 00:02:02,630
to get to take away out of this talk is

41
00:01:58,970 --> 00:02:04,640
look out for rabbit holes so I asked

42
00:02:02,630 --> 00:02:06,770
when I started out I you know you're

43
00:02:04,640 --> 00:02:08,568
looking at the assembly and you're going

44
00:02:06,770 --> 00:02:12,380
deeper and deeper and deeper reverse

45
00:02:08,568 --> 00:02:14,238
engineering and you just get stuck you

46
00:02:12,380 --> 00:02:16,370
don't know what you're doing and you're

47
00:02:14,239 --> 00:02:18,500
just focused and hammering away at one

48
00:02:16,370 --> 00:02:20,450
thing and you're spending days and days

49
00:02:18,500 --> 00:02:23,329
on it when you shouldn't be when you

50
00:02:20,450 --> 00:02:26,440
should take a step back and break things

51
00:02:23,329 --> 00:02:30,590
down so you know what you're doing

52
00:02:26,440 --> 00:02:32,329
so my mentors over the years I'm not

53
00:02:30,590 --> 00:02:34,430
gonna say his name so I'm gonna have am

54
00:02:32,329 --> 00:02:36,340
anonymous dude said you only need a

55
00:02:34,430 --> 00:02:38,930
disassembler debugger and a hex editor

56
00:02:36,340 --> 00:02:41,030
you don't need all these fancy tools all

57
00:02:38,930 --> 00:02:45,170
you need is those three things but fancy

58
00:02:41,030 --> 00:02:48,910
tools do help you get by so I give to

59
00:02:45,170 --> 00:02:48,910
you the re starter pack

60
00:02:49,170 --> 00:02:56,920
so I whenever I can't do coffee he drink

61
00:02:54,190 --> 00:02:58,780
redbull a lot I'm always carrying

62
00:02:56,920 --> 00:03:00,700
eyedrops off with me because I have

63
00:02:58,780 --> 00:03:04,450
contacts and I'm constantly staring at

64
00:03:00,700 --> 00:03:08,470
the screen I also use x64 debug for my

65
00:03:04,450 --> 00:03:11,530
debugger Ida Pro I do like Rodari too

66
00:03:08,470 --> 00:03:17,019
but you know Ida Pro is my base and then

67
00:03:11,530 --> 00:03:18,190
a hex editor so here's kind of like an

68
00:03:17,019 --> 00:03:19,569
overview of tools that you'll probably

69
00:03:18,190 --> 00:03:21,850
use and you've heard of these over the

70
00:03:19,569 --> 00:03:24,179
years Ida Rodari

71
00:03:21,850 --> 00:03:27,130
capstone is if you want to automate

72
00:03:24,180 --> 00:03:28,870
disassembly debuggers like I mentioned

73
00:03:27,130 --> 00:03:31,569
before a lot of people use Olie debug

74
00:03:28,870 --> 00:03:34,989
because of all the plugins gdb if you

75
00:03:31,569 --> 00:03:37,089
want to do Linux stuff and then support

76
00:03:34,989 --> 00:03:38,769
tools information-gathering so these are

77
00:03:37,090 --> 00:03:43,180
pretty much all the things that I use I

78
00:03:38,769 --> 00:03:45,600
don't use anything else so that brings

79
00:03:43,180 --> 00:03:47,980
me to the approach like I said before

80
00:03:45,600 --> 00:03:49,329
the one thing that'll help you go you

81
00:03:47,980 --> 00:03:52,359
know stay away from those rabbit holes

82
00:03:49,330 --> 00:03:55,000
and make things go faster is recognizing

83
00:03:52,360 --> 00:03:57,040
patterns recognizing patterns and now

84
00:03:55,000 --> 00:03:59,620
that comes with experience if you look a

85
00:03:57,040 --> 00:04:01,510
lot at tons and tons of our when I was

86
00:03:59,620 --> 00:04:04,660
that fire I used to look at like 50,000

87
00:04:01,510 --> 00:04:08,679
samples a day which is not enough right

88
00:04:04,660 --> 00:04:10,600
not enough time so I'm here to teach you

89
00:04:08,680 --> 00:04:12,730
about you know different patterns in a

90
00:04:10,600 --> 00:04:15,310
high-level view but also look at the

91
00:04:12,730 --> 00:04:18,370
assembly itself because there it's more

92
00:04:15,310 --> 00:04:20,738
like abstract shapes than they are you

93
00:04:18,370 --> 00:04:23,890
know looking at the little tiny assembly

94
00:04:20,738 --> 00:04:26,130
pieces by themselves so I'm gonna break

95
00:04:23,890 --> 00:04:28,479
down these algorithms into basic steps

96
00:04:26,130 --> 00:04:30,159
I'm gonna tell you that information

97
00:04:28,479 --> 00:04:33,099
gathering is key because it'll tell you

98
00:04:30,160 --> 00:04:36,780
how everything is structured and then

99
00:04:33,100 --> 00:04:39,550
use the backward and forward navigation

100
00:04:36,780 --> 00:04:42,010
so what do I mean by backwards and

101
00:04:39,550 --> 00:04:43,900
forwards navigation I'm saying start in

102
00:04:42,010 --> 00:04:46,030
the middle then work your way backwards

103
00:04:43,900 --> 00:04:48,669
up until you reach the start of the

104
00:04:46,030 --> 00:04:50,830
function and from there you can have

105
00:04:48,669 --> 00:04:52,810
your little navigation on where you're

106
00:04:50,830 --> 00:04:54,490
gonna go next so that you can bring

107
00:04:52,810 --> 00:04:57,610
yourself all the way back from the start

108
00:04:54,490 --> 00:05:00,370
to the point that you ended in the

109
00:04:57,610 --> 00:05:03,650
middle and take notes

110
00:05:00,370 --> 00:05:05,569
these are my she totes I have a little I

111
00:05:03,650 --> 00:05:07,758
have like tons of moleskin notebooks at

112
00:05:05,569 --> 00:05:12,800
home that just have a bunch of addresses

113
00:05:07,759 --> 00:05:17,240
and points little arrows and stuff so

114
00:05:12,800 --> 00:05:18,680
I'm gonna go over simple packing evasion

115
00:05:17,240 --> 00:05:20,960
a couple different evasion techniques

116
00:05:18,680 --> 00:05:23,960
crypto identifying a wooden there's a

117
00:05:20,960 --> 00:05:25,818
crypto algorithm and then shellcode so

118
00:05:23,960 --> 00:05:29,080
shellcode unpacking or almost the same

119
00:05:25,819 --> 00:05:31,849
thing but go into the detail about that

120
00:05:29,080 --> 00:05:34,520
so things to look for when you're

121
00:05:31,849 --> 00:05:38,870
looking at packing anyone familiar with

122
00:05:34,520 --> 00:05:41,359
upx or tomayto any type of those Packers

123
00:05:38,870 --> 00:05:43,370
is basically taking the code making it

124
00:05:41,360 --> 00:05:47,479
smaller so that it's in a smaller binary

125
00:05:43,370 --> 00:05:50,030
and then unpacking it in runtime so when

126
00:05:47,479 --> 00:05:51,830
you see packing it's gonna allocate a

127
00:05:50,030 --> 00:05:53,030
huge memory chunk or it'll have that

128
00:05:51,830 --> 00:05:55,669
memory trunk there already it's just

129
00:05:53,030 --> 00:05:57,770
empty it'll load references from a

130
00:05:55,669 --> 00:06:01,909
section a resource or in the data

131
00:05:57,770 --> 00:06:05,000
section some routine that loops this

132
00:06:01,909 --> 00:06:07,400
loop slot it's obvious recreate the

133
00:06:05,000 --> 00:06:09,770
import table which is key because it'll

134
00:06:07,400 --> 00:06:11,840
have to put the import table in the new

135
00:06:09,770 --> 00:06:13,669
memory section and then you have to

136
00:06:11,840 --> 00:06:16,400
convert the that memory section to

137
00:06:13,669 --> 00:06:20,539
executable and then you'll jump to the

138
00:06:16,400 --> 00:06:23,359
newly copied bytes right so I made it a

139
00:06:20,539 --> 00:06:25,909
little animated diagram of what this

140
00:06:23,360 --> 00:06:27,610
looks like so there's a loop happening

141
00:06:25,909 --> 00:06:30,620
there's where the new codes going

142
00:06:27,610 --> 00:06:33,560
recreates import table changes that data

143
00:06:30,620 --> 00:06:35,629
section to R to P X and then jumps

144
00:06:33,560 --> 00:06:39,129
somewhere in the middle where the entry

145
00:06:35,629 --> 00:06:39,129
point is so I could do it stuff

146
00:06:39,789 --> 00:06:43,639
alright upx

147
00:06:41,389 --> 00:06:45,979
this is really basic we see it a lot if

148
00:06:43,639 --> 00:06:48,830
you don't want to use a ukx unpacker i'm

149
00:06:45,979 --> 00:06:50,659
going to show you like how it looks in

150
00:06:48,830 --> 00:06:54,469
the diagram that I showed you

151
00:06:50,659 --> 00:06:56,750
so in upx at least this upx version this

152
00:06:54,469 --> 00:06:59,300
data chunk here where's all the junk

153
00:06:56,750 --> 00:07:02,150
data that's packed this is where it's

154
00:06:59,300 --> 00:07:05,509
gonna put this new data after it's

155
00:07:02,150 --> 00:07:07,008
unpacking right so it starts to recreate

156
00:07:05,509 --> 00:07:08,990
the import table and I put these nice

157
00:07:07,009 --> 00:07:12,830
little lovely things here load library

158
00:07:08,990 --> 00:07:13,670
egg get proc address and a good

159
00:07:12,830 --> 00:07:15,200
indicator

160
00:07:13,670 --> 00:07:16,910
when something's packed is when you put

161
00:07:15,200 --> 00:07:21,830
it into Ida and I'll say a little they I

162
00:07:16,910 --> 00:07:23,990
t's up so that's a good indicator

163
00:07:21,830 --> 00:07:28,789
that it's recreating all the imports and

164
00:07:23,990 --> 00:07:33,800
so here's kind of like a little music

165
00:07:28,790 --> 00:07:35,770
running there we go so I kind of went

166
00:07:33,800 --> 00:07:38,450
through and I did this last night

167
00:07:35,770 --> 00:07:41,120
showing how the imports are being loaded

168
00:07:38,450 --> 00:07:43,280
into the new memory location you can see

169
00:07:41,120 --> 00:07:46,790
the 76 Sony it's all backwards right

170
00:07:43,280 --> 00:07:48,500
little indeed you could see all the

171
00:07:46,790 --> 00:07:52,970
imports being loaded with the get proc

172
00:07:48,500 --> 00:07:55,250
address and this upx sample alright and

173
00:07:52,970 --> 00:07:57,620
then you'll see later on right down

174
00:07:55,250 --> 00:07:59,450
below it'll do it'll call out to virtual

175
00:07:57,620 --> 00:08:02,150
protect to change that memory location

176
00:07:59,450 --> 00:08:04,490
to executable and then I'll loop a bit

177
00:08:02,150 --> 00:08:06,830
remember I said looping and then it'll

178
00:08:04,490 --> 00:08:12,290
jump just somewhere inside that new

179
00:08:06,830 --> 00:08:15,349
memory location so how to get around it

180
00:08:12,290 --> 00:08:18,560
look for references to jump data

181
00:08:15,350 --> 00:08:20,570
anything in the resources different

182
00:08:18,560 --> 00:08:22,400
sections or the data and then look for

183
00:08:20,570 --> 00:08:23,870
that jump call because you're going I

184
00:08:22,400 --> 00:08:27,169
want to put a breakpoint on that jump

185
00:08:23,870 --> 00:08:28,490
call save the addresses of the new

186
00:08:27,170 --> 00:08:30,080
memory if you're debugging save the

187
00:08:28,490 --> 00:08:32,840
address of the new memory location off

188
00:08:30,080 --> 00:08:35,270
put it in your notes and then set a

189
00:08:32,840 --> 00:08:37,490
breakpoint on that memory region in your

190
00:08:35,270 --> 00:08:40,789
debugger and you can jump directly into

191
00:08:37,490 --> 00:08:43,430
the codes that's executable all right

192
00:08:40,789 --> 00:08:47,569
now a vision don't you like these

193
00:08:43,429 --> 00:08:50,900
graphics that like lots of jumps jump

194
00:08:47,570 --> 00:08:55,190
jump jumps the whole point of evasion is

195
00:08:50,900 --> 00:08:57,140
to throw off the panelist right there's

196
00:08:55,190 --> 00:09:00,260
gonna be a jump that goes directly to

197
00:08:57,140 --> 00:09:02,600
the program exit and then there's gonna

198
00:09:00,260 --> 00:09:04,310
be a lot of environment checking as well

199
00:09:02,600 --> 00:09:08,420
as a bunch of the useless routines to

200
00:09:04,310 --> 00:09:11,510
throw you off your course so here's kind

201
00:09:08,420 --> 00:09:14,449
of an example of just a generic evasion

202
00:09:11,510 --> 00:09:17,569
you have some check and then a jump if

203
00:09:14,450 --> 00:09:19,640
not zero to exit and another check jump

204
00:09:17,570 --> 00:09:21,230
to exit another check trim takes it so

205
00:09:19,640 --> 00:09:22,280
these checks could be environmental

206
00:09:21,230 --> 00:09:25,850
checks

207
00:09:22,280 --> 00:09:29,500
they could be VM checks doesn't matter

208
00:09:25,850 --> 00:09:33,140
it all looks the same all the time

209
00:09:29,500 --> 00:09:38,330
alright so here's kind of example of an

210
00:09:33,140 --> 00:09:42,650
anti VM Maur that I have in my ro 102 re

211
00:09:38,330 --> 00:09:46,160
102 course you can see like after the

212
00:09:42,650 --> 00:09:48,829
check it does a comparison EAX EDI

213
00:09:46,160 --> 00:09:51,530
there's a jump if not zero or jump zero

214
00:09:48,830 --> 00:09:54,710
and then here's the process to exit that

215
00:09:51,530 --> 00:09:57,439
is going to jump to if it's not if it is

216
00:09:54,710 --> 00:09:59,360
zero and then continue to the next check

217
00:09:57,440 --> 00:10:02,840
so it goes through all these different

218
00:09:59,360 --> 00:10:06,380
checks in order to kill the process if

219
00:10:02,840 --> 00:10:08,300
it's in running in a VM alright so

220
00:10:06,380 --> 00:10:09,890
there's different types of evasion and I

221
00:10:08,300 --> 00:10:11,060
just explained before that there's VM

222
00:10:09,890 --> 00:10:13,880
evasion where it's checking the

223
00:10:11,060 --> 00:10:17,949
environment for VM artifacts anti

224
00:10:13,880 --> 00:10:20,980
analysis it uses jumps and functions

225
00:10:17,950 --> 00:10:25,070
useless jumps and functions ante AV

226
00:10:20,980 --> 00:10:28,130
evasion or anti AV detection heavy off

227
00:10:25,070 --> 00:10:30,560
vacation environment checks and anti

228
00:10:28,130 --> 00:10:35,780
automation it just says I'm looking for

229
00:10:30,560 --> 00:10:37,910
user activity all right so with VM

230
00:10:35,780 --> 00:10:39,620
evasion what are you looking for it's

231
00:10:37,910 --> 00:10:42,140
gonna check anything about the hardware

232
00:10:39,620 --> 00:10:44,330
the BIOS the registry keys for the

233
00:10:42,140 --> 00:10:47,540
hardware stuff it's gonna look for

234
00:10:44,330 --> 00:10:50,180
driver names related to the VMware or VM

235
00:10:47,540 --> 00:10:53,329
depending on what you're using and a

236
00:10:50,180 --> 00:10:56,030
good resource to check that people use

237
00:10:53,330 --> 00:10:58,550
is this paranoid fish caught fish you

238
00:10:56,030 --> 00:11:01,069
can use a script to detect if you're

239
00:10:58,550 --> 00:11:06,650
running in a VM or you can harden your

240
00:11:01,070 --> 00:11:10,010
VM depending so and that same anti VM

241
00:11:06,650 --> 00:11:13,300
our here is its where it's checking the

242
00:11:10,010 --> 00:11:16,490
physical drive it's creating the

243
00:11:13,300 --> 00:11:19,520
physical drive file so it can check the

244
00:11:16,490 --> 00:11:22,250
device IO control this is kind of what

245
00:11:19,520 --> 00:11:24,740
looks like here's the call here's the

246
00:11:22,250 --> 00:11:26,750
test and then jump if not and then it

247
00:11:24,740 --> 00:11:28,580
continues processing so there's that

248
00:11:26,750 --> 00:11:31,690
jump if not zero sometimes it's jump

249
00:11:28,580 --> 00:11:35,230
zero you're gonna see that often

250
00:11:31,690 --> 00:11:38,110
so normally when you see a registry an

251
00:11:35,230 --> 00:11:41,920
API call or registry key check is doing

252
00:11:38,110 --> 00:11:45,270
that environmental chip all right

253
00:11:41,920 --> 00:11:48,390
things to look for for our anti analysis

254
00:11:45,270 --> 00:11:51,220
useless jumps so this one was fun

255
00:11:48,390 --> 00:11:54,010
there's if you were to take out all of

256
00:11:51,220 --> 00:11:57,430
these jumps its push EBP which is a

257
00:11:54,010 --> 00:11:59,020
stack stuff move EBP ESP and you don't

258
00:11:57,430 --> 00:12:03,670
need all of these chumps but it throws

259
00:11:59,020 --> 00:12:05,680
off a vide signatures so when you look

260
00:12:03,670 --> 00:12:09,510
at it even more you know it's really

261
00:12:05,680 --> 00:12:12,310
tough to follow this in a debugger but

262
00:12:09,510 --> 00:12:16,060
quite a nicely puts this out for you so

263
00:12:12,310 --> 00:12:18,280
you can follow along so on top of that

264
00:12:16,060 --> 00:12:21,400
there's the bugger checks time bombs and

265
00:12:18,280 --> 00:12:25,270
tick timer checks tick timer checks is

266
00:12:21,400 --> 00:12:27,400
if you start the program and it runs a

267
00:12:25,270 --> 00:12:29,410
certain function and it checks the time

268
00:12:27,400 --> 00:12:31,630
right after to make sure that it's

269
00:12:29,410 --> 00:12:35,350
running properly in a normal fashion

270
00:12:31,630 --> 00:12:37,290
rather than in debugging all right anti

271
00:12:35,350 --> 00:12:40,360
AV detection things to look for

272
00:12:37,290 --> 00:12:42,160
accessing register keys for AV names how

273
00:12:40,360 --> 00:12:44,020
many of you seen this they'll just sit

274
00:12:42,160 --> 00:12:47,740
there and check every single AV it knows

275
00:12:44,020 --> 00:12:49,930
to see if it's running yeah and then

276
00:12:47,740 --> 00:12:51,760
checking Program Files dll's and driver

277
00:12:49,930 --> 00:12:53,800
names so if you're familiar with a lot

278
00:12:51,760 --> 00:12:55,930
of AV engines there you use a lot of

279
00:12:53,800 --> 00:12:58,300
dll's and they sometimes inject those

280
00:12:55,930 --> 00:12:59,949
dll's into all your processes so

281
00:12:58,300 --> 00:13:06,219
sometimes it'll check for those dll's

282
00:12:59,950 --> 00:13:08,500
sitting on the image image space and

283
00:13:06,220 --> 00:13:11,920
then a stack bakes bass strings and io

284
00:13:08,500 --> 00:13:15,730
sees in that same sample I have the

285
00:13:11,920 --> 00:13:17,860
example of where it's pushing a like one

286
00:13:15,730 --> 00:13:19,420
character onto the stack to build up a

287
00:13:17,860 --> 00:13:21,100
whole string so in this case that's

288
00:13:19,420 --> 00:13:23,530
looking for sample guess it wants to

289
00:13:21,100 --> 00:13:26,080
check if it's name is sample or its path

290
00:13:23,530 --> 00:13:28,089
this name sample because with VM

291
00:13:26,080 --> 00:13:32,530
automation they're gonna name it sample

292
00:13:28,090 --> 00:13:35,260
I don't know why but you can see s am

293
00:13:32,530 --> 00:13:38,459
peel and it's pushed and you know move

294
00:13:35,260 --> 00:13:42,380
nicely into position so it can call it

295
00:13:38,460 --> 00:13:44,690
so this is really hard to I you know

296
00:13:42,380 --> 00:13:46,939
right signatures on because they're on

297
00:13:44,690 --> 00:13:51,800
the stack and not like get a nice little

298
00:13:46,940 --> 00:13:54,020
D word offset all right now anti

299
00:13:51,800 --> 00:13:56,900
automation this one is fun and I really

300
00:13:54,020 --> 00:13:59,090
hate anti automation because you know

301
00:13:56,900 --> 00:14:02,959
when I'm reversing it or debugging it I

302
00:13:59,090 --> 00:14:05,780
have to always patch this stuff so one

303
00:14:02,960 --> 00:14:08,030
of the things is mouse movement checking

304
00:14:05,780 --> 00:14:11,270
if the foreground window state changes

305
00:14:08,030 --> 00:14:13,250
so like you just move the window another

306
00:14:11,270 --> 00:14:16,430
side it shows that there's actually

307
00:14:13,250 --> 00:14:20,450
someone at the computer long sleeps

308
00:14:16,430 --> 00:14:22,910
wait calls say your VM automation runs

309
00:14:20,450 --> 00:14:25,990
for 5 minutes it'll run for 20 minutes

310
00:14:22,910 --> 00:14:28,310
so it can go past that analysis time

311
00:14:25,990 --> 00:14:29,900
alright and then the finally internet

312
00:14:28,310 --> 00:14:32,239
connection test so sometimes it'll go

313
00:14:29,900 --> 00:14:35,030
hey Google can I see can you see me or

314
00:14:32,240 --> 00:14:37,100
hey Microsoft are you there because if

315
00:14:35,030 --> 00:14:38,720
you can't connect to those and it says

316
00:14:37,100 --> 00:14:43,040
oh well there's something fishy I don't

317
00:14:38,720 --> 00:14:44,660
have actual internet connection alright

318
00:14:43,040 --> 00:14:47,630
so here's what I explained before the

319
00:14:44,660 --> 00:14:49,610
foreground window state change so it'll

320
00:14:47,630 --> 00:14:51,770
keep going through this loop checking if

321
00:14:49,610 --> 00:14:53,510
the state has changed and it will sit

322
00:14:51,770 --> 00:14:56,689
there forever until the state actually

323
00:14:53,510 --> 00:14:59,480
changes so when you're doing a VM like

324
00:14:56,690 --> 00:15:00,650
automation you're not seeing anything

325
00:14:59,480 --> 00:15:07,460
because it's just sitting there waiting

326
00:15:00,650 --> 00:15:09,290
for the front window to change right so

327
00:15:07,460 --> 00:15:12,260
how to get around it like I said

328
00:15:09,290 --> 00:15:14,660
patching is fun you just have to change

329
00:15:12,260 --> 00:15:17,510
if you're doing it dynamically all you

330
00:15:14,660 --> 00:15:20,990
have to do is change the little zero

331
00:15:17,510 --> 00:15:24,110
flag or you can patch it directly in the

332
00:15:20,990 --> 00:15:27,530
Maur or in the binary itself and then

333
00:15:24,110 --> 00:15:29,660
that way you can run it again so and

334
00:15:27,530 --> 00:15:31,310
here's that zero flag I was mentioning

335
00:15:29,660 --> 00:15:38,530
them when you're debugging you just flip

336
00:15:31,310 --> 00:15:43,250
that bit to one all right now crypto

337
00:15:38,530 --> 00:15:45,740
crypto is really easy to death to detect

338
00:15:43,250 --> 00:15:47,060
for Strings because there's always going

339
00:15:45,740 --> 00:15:50,570
to be a function called right after

340
00:15:47,060 --> 00:15:53,660
string is loaded so load a reference and

341
00:15:50,570 --> 00:15:56,900
data or wherever call function right

342
00:15:53,660 --> 00:16:00,620
after loop a lot

343
00:15:56,900 --> 00:16:03,860
explore something really simple so I'll

344
00:16:00,620 --> 00:16:05,720
show you what that looks like so here in

345
00:16:03,860 --> 00:16:08,570
this sample it's actually going to load

346
00:16:05,720 --> 00:16:11,000
encrypted shellcode using our c4 into

347
00:16:08,570 --> 00:16:14,480
memory what you're seeing here is this

348
00:16:11,000 --> 00:16:16,670
junk data small junk data all this junk

349
00:16:14,480 --> 00:16:18,800
data and then right after it loads this

350
00:16:16,670 --> 00:16:21,079
junk data and the size it calls a

351
00:16:18,800 --> 00:16:23,120
function and you see this function being

352
00:16:21,080 --> 00:16:28,010
called a lot because every single time

353
00:16:23,120 --> 00:16:30,200
it it loads up a string or a byte array

354
00:16:28,010 --> 00:16:34,189
it will call that function and decrypt

355
00:16:30,200 --> 00:16:36,110
it so that that's a good indicator is to

356
00:16:34,190 --> 00:16:40,670
see these functions repeated right after

357
00:16:36,110 --> 00:16:43,970
data is loaded all right so with ciphers

358
00:16:40,670 --> 00:16:46,130
and normal crypto there's a lot of

359
00:16:43,970 --> 00:16:52,130
looping involved it's looping to switch

360
00:16:46,130 --> 00:16:53,960
bytes looping to X or something and kind

361
00:16:52,130 --> 00:16:56,689
of like an example here you can see this

362
00:16:53,960 --> 00:16:59,380
here is one iteration one iteration one

363
00:16:56,690 --> 00:17:01,790
iteration and you're gonna see that in

364
00:16:59,380 --> 00:17:03,830
these algorithms so what you're gonna

365
00:17:01,790 --> 00:17:06,680
keep in mind is finding when you see the

366
00:17:03,830 --> 00:17:09,380
increment do some functions and keep

367
00:17:06,680 --> 00:17:11,360
looping and keep looping and you'll see

368
00:17:09,380 --> 00:17:13,940
this and then once it's done going

369
00:17:11,359 --> 00:17:16,459
through the whole thing you know it will

370
00:17:13,940 --> 00:17:18,530
be in that new memory space and then

371
00:17:16,460 --> 00:17:21,650
finally X or something

372
00:17:18,530 --> 00:17:24,319
so immediately look for an XOR where

373
00:17:21,650 --> 00:17:27,920
there's two values that are different a

374
00:17:24,319 --> 00:17:29,090
B not a when you see this XOR with two

375
00:17:27,920 --> 00:17:31,550
values that are the same is just

376
00:17:29,090 --> 00:17:36,050
clearing out the register just a cheap

377
00:17:31,550 --> 00:17:39,200
way to do that so look for like here

378
00:17:36,050 --> 00:17:42,350
it's looking at this location at ESI and

379
00:17:39,200 --> 00:17:45,200
it's taking the lower byte of EI x + x

380
00:17:42,350 --> 00:17:48,320
wiring that together so this is actually

381
00:17:45,200 --> 00:17:51,890
in the rc4 algorithm that it this memory

382
00:17:48,320 --> 00:17:53,540
was using really simple that's how you

383
00:17:51,890 --> 00:17:57,050
know I have you guys heard of the

384
00:17:53,540 --> 00:17:58,550
flareon for a challenge I all I did was

385
00:17:57,050 --> 00:18:00,520
look for the XOR and I was like oh it's

386
00:17:58,550 --> 00:18:03,590
encrypted

387
00:18:00,520 --> 00:18:06,470
okay now static analysis how do you get

388
00:18:03,590 --> 00:18:07,810
around it frequent uses like I said

389
00:18:06,470 --> 00:18:10,470
frequent users of the

390
00:18:07,810 --> 00:18:14,950
right after the data the data is loaded

391
00:18:10,470 --> 00:18:16,510
and then if you know that in crypto

392
00:18:14,950 --> 00:18:17,710
algorithm by going through it and

393
00:18:16,510 --> 00:18:19,390
writing your notes down and just

394
00:18:17,710 --> 00:18:21,460
stepping through the whole algorithm you

395
00:18:19,390 --> 00:18:24,010
can create a decryption for that huge

396
00:18:21,460 --> 00:18:27,280
memory space or that huge data that's

397
00:18:24,010 --> 00:18:29,950
being referenced you can place the

398
00:18:27,280 --> 00:18:32,230
breakpoint right before it returns to

399
00:18:29,950 --> 00:18:34,660
the decrypted area like you would do in

400
00:18:32,230 --> 00:18:41,160
packing just set a memory breakpoint on

401
00:18:34,660 --> 00:18:47,080
the new memory location or said that or

402
00:18:41,160 --> 00:18:50,080
you could extract that out just just the

403
00:18:47,080 --> 00:18:52,179
data itself right in your script and

404
00:18:50,080 --> 00:18:54,429
then turn that if it's shell code into

405
00:18:52,180 --> 00:18:58,390
an exe and I'll get down to it

406
00:18:54,430 --> 00:19:01,140
I'll go over that at the end oh it's

407
00:18:58,390 --> 00:19:05,430
similar to packing like I said before

408
00:19:01,140 --> 00:19:07,960
shell code is I'm gonna skip ahead here

409
00:19:05,430 --> 00:19:10,150
the shell code is basically process

410
00:19:07,960 --> 00:19:15,250
independent code so it doesn't need a

411
00:19:10,150 --> 00:19:17,860
specific OS or libraries in order to run

412
00:19:15,250 --> 00:19:19,540
it'll just run by itself it doesn't need

413
00:19:17,860 --> 00:19:22,510
anything else that may or may not

414
00:19:19,540 --> 00:19:24,879
recreate the import table so that's one

415
00:19:22,510 --> 00:19:27,940
of the things I want to get across it'll

416
00:19:24,880 --> 00:19:29,910
do virtual lock or you know create a new

417
00:19:27,940 --> 00:19:35,110
memories on the heap turn it to

418
00:19:29,910 --> 00:19:37,540
executable with a virtual protect and

419
00:19:35,110 --> 00:19:39,939
then copy that large chunk into into

420
00:19:37,540 --> 00:19:43,690
memory and then jump to the offset or

421
00:19:39,940 --> 00:19:45,850
pop push return to the offset and then

422
00:19:43,690 --> 00:19:47,770
you know it could spot a new thread of

423
00:19:45,850 --> 00:19:49,990
that new memory location or you know

424
00:19:47,770 --> 00:19:51,700
just run from that memory location more

425
00:19:49,990 --> 00:19:55,300
often I see the shell code spawn from a

426
00:19:51,700 --> 00:19:58,810
new thread but you know in this case it

427
00:19:55,300 --> 00:20:03,610
did not and like I said before it's

428
00:19:58,810 --> 00:20:07,120
similar to unpacking so here's that nice

429
00:20:03,610 --> 00:20:10,000
little lovely diagram again the shell

430
00:20:07,120 --> 00:20:13,689
code normally some warned data puts it

431
00:20:10,000 --> 00:20:17,320
change it to our W X and then executes

432
00:20:13,690 --> 00:20:19,660
so normally at the start of the shell

433
00:20:17,320 --> 00:20:20,200
code but sometimes it starts in the

434
00:20:19,660 --> 00:20:22,389
middle

435
00:20:20,200 --> 00:20:27,250
but most of the time it starts at the

436
00:20:22,389 --> 00:20:30,090
beginning all right so here's an example

437
00:20:27,250 --> 00:20:33,460
of it starting actually in the middle

438
00:20:30,090 --> 00:20:35,559
it's before how it gets in the show code

439
00:20:33,460 --> 00:20:37,389
is not a jump not like packing it's just

440
00:20:35,559 --> 00:20:40,510
a simple jump rate so this one is

441
00:20:37,389 --> 00:20:44,799
actually pushing the value onto the

442
00:20:40,510 --> 00:20:47,200
stack and then returning so what is this

443
00:20:44,799 --> 00:20:50,260
what does that mean so normally when you

444
00:20:47,200 --> 00:20:53,049
want to return to a function it pops

445
00:20:50,260 --> 00:20:55,929
instead then in this case it's pushing

446
00:20:53,049 --> 00:21:01,840
so when it returns it returns back to

447
00:20:55,929 --> 00:21:05,049
that new memory location so like a lot

448
00:21:01,840 --> 00:21:08,320
of these look for references and the

449
00:21:05,049 --> 00:21:13,690
sections resources or data look for the

450
00:21:08,320 --> 00:21:17,049
jump call or the pop return call or push

451
00:21:13,690 --> 00:21:19,269
return College change that I save the

452
00:21:17,049 --> 00:21:20,980
address like and like similar to packing

453
00:21:19,269 --> 00:21:23,769
save the address of the new memory

454
00:21:20,980 --> 00:21:25,720
location put a memory or Hardware

455
00:21:23,769 --> 00:21:29,919
breakpoint on that new location and jump

456
00:21:25,720 --> 00:21:33,309
to it when it gets executed or you can

457
00:21:29,919 --> 00:21:35,230
extract the shellcode out decrypt it if

458
00:21:33,309 --> 00:21:37,620
it's encrypted and turn it into an 8-3

459
00:21:35,230 --> 00:21:41,260
so that you can throw it into Ida Pro

460
00:21:37,620 --> 00:21:45,760
and so I think hexa corn originally had

461
00:21:41,260 --> 00:21:52,029
this this tutorial where you can turn

462
00:21:45,760 --> 00:21:55,149
that ASM into a new Exe way I named this

463
00:21:52,029 --> 00:21:57,130
section ayylmao and then here's my

464
00:21:55,149 --> 00:22:00,459
shellcode bin that I extract it out from

465
00:21:57,130 --> 00:22:03,549
memory and then I can turn that into an

466
00:22:00,460 --> 00:22:06,309
object and then link it with go link and

467
00:22:03,549 --> 00:22:08,230
then I can but the main thing that you

468
00:22:06,309 --> 00:22:10,510
have to do is you have to know the entry

469
00:22:08,230 --> 00:22:12,549
point of the shellcode because if you

470
00:22:10,510 --> 00:22:15,519
don't then Ida's gonna be like whoa what

471
00:22:12,549 --> 00:22:19,210
the hell is this am I looking at so when

472
00:22:15,519 --> 00:22:22,960
you know the entry point you can go into

473
00:22:19,210 --> 00:22:25,080
like a PE editor and you know that the

474
00:22:22,960 --> 00:22:29,580
start of the program starts at a

475
00:22:25,080 --> 00:22:31,629
thousand in hex you add that with actual

476
00:22:29,580 --> 00:22:33,399
entry points in the show

477
00:22:31,630 --> 00:22:37,690
code when you're like looking at it and

478
00:22:33,400 --> 00:22:40,120
it should be like 1000 hex plus whatever

479
00:22:37,690 --> 00:22:42,670
your address is and you put that into

480
00:22:40,120 --> 00:22:46,239
the entry point and then that should

481
00:22:42,670 --> 00:22:51,760
allow you to dissemble it and and run it

482
00:22:46,240 --> 00:22:56,740
in the debugger or disassembler alright

483
00:22:51,760 --> 00:22:58,750
finally my own time all right things to

484
00:22:56,740 --> 00:23:01,240
remember take notes

485
00:22:58,750 --> 00:23:04,090
lots of lots of notes I think I use

486
00:23:01,240 --> 00:23:04,990
Evernote and all of the reverse

487
00:23:04,090 --> 00:23:07,510
engineering stuff I do

488
00:23:04,990 --> 00:23:10,600
it's just littered with screenshots and

489
00:23:07,510 --> 00:23:14,110
like addresses I mean I used I do the

490
00:23:10,600 --> 00:23:17,409
notebook to a tag team and then patch

491
00:23:14,110 --> 00:23:19,719
patch patch I patch a lot of malware if

492
00:23:17,410 --> 00:23:21,730
I don't like it I'm like well I don't

493
00:23:19,720 --> 00:23:24,760
want to you know debug you again so I'm

494
00:23:21,730 --> 00:23:26,590
just gonna patch that little instruction

495
00:23:24,760 --> 00:23:28,840
so I can run through it nicely and

496
00:23:26,590 --> 00:23:32,260
figure out the rest of the the binary

497
00:23:28,840 --> 00:23:34,270
and then memory and hardware breakpoints

498
00:23:32,260 --> 00:23:35,860
are your friends I think I explained

499
00:23:34,270 --> 00:23:37,840
before about the shell code and the

500
00:23:35,860 --> 00:23:41,350
packing you want to set a memory

501
00:23:37,840 --> 00:23:43,449
breakpoint or hardware breakpoint on the

502
00:23:41,350 --> 00:23:46,060
execution of a certain memory that

503
00:23:43,450 --> 00:23:48,210
certain section that way you can jump to

504
00:23:46,060 --> 00:23:50,860
it really quickly and you won't miss it

505
00:23:48,210 --> 00:23:52,750
loops are annoying but they're good for

506
00:23:50,860 --> 00:23:54,669
identifying a different bunch of

507
00:23:52,750 --> 00:23:56,890
different algorithms depending on what

508
00:23:54,670 --> 00:23:59,080
type of loop it is how it's doing that

509
00:23:56,890 --> 00:24:01,960
it's increment it also might differ

510
00:23:59,080 --> 00:24:05,409
based on the language as well but it's

511
00:24:01,960 --> 00:24:08,100
it's a good place to start at least for

512
00:24:05,410 --> 00:24:10,900
analyze data that you want to look at

513
00:24:08,100 --> 00:24:13,120
repeated functions are fishy but they're

514
00:24:10,900 --> 00:24:15,370
great indicators like I explained before

515
00:24:13,120 --> 00:24:17,169
with crypto functions you're always

516
00:24:15,370 --> 00:24:19,419
gonna see that function reused over and

517
00:24:17,170 --> 00:24:21,340
over again I remember there was a

518
00:24:19,420 --> 00:24:23,740
malware I looked at where it would

519
00:24:21,340 --> 00:24:26,050
decrypt the function before it actually

520
00:24:23,740 --> 00:24:29,950
executed it it's kind of like dotnet

521
00:24:26,050 --> 00:24:33,220
where it converts the il code into

522
00:24:29,950 --> 00:24:35,260
machine code and then you know runs that

523
00:24:33,220 --> 00:24:37,620
function right then and there and

524
00:24:35,260 --> 00:24:40,510
runtime the same thing with like

525
00:24:37,620 --> 00:24:42,399
decrypting functions and Mauer they're

526
00:24:40,510 --> 00:24:44,020
gonna decrypt it run it decrypt it run

527
00:24:42,400 --> 00:24:45,100
it and it's kind of obvious if they're

528
00:24:44,020 --> 00:24:57,450
reusing the

529
00:24:45,100 --> 00:24:57,449
function so finally questions sure I

530
00:25:01,020 --> 00:25:13,270
have no choice but yeah you can if you

531
00:25:11,380 --> 00:25:15,340
want to set it up but you know I'm old

532
00:25:13,270 --> 00:25:21,070
school and I'll just you know turn it on

533
00:25:15,340 --> 00:25:22,990
and go at it I wish I had Ida and lytx

534
00:25:21,070 --> 00:25:30,879
but only in Windows because that's all

535
00:25:22,990 --> 00:25:34,210
they'll pay for sure it's all online

536
00:25:30,880 --> 00:25:38,890
already I'm just not saying they're on

537
00:25:34,210 --> 00:25:40,870
video yeah a lot of the pictures that

538
00:25:38,890 --> 00:25:46,960
you saw in there are actually from the

539
00:25:40,870 --> 00:25:51,129
re 101 and 102 courses you're looking at

540
00:25:46,960 --> 00:25:53,289
so many samples how do you okay I have

541
00:25:51,130 --> 00:25:56,620
millions and millions of nested folders

542
00:25:53,289 --> 00:25:58,390
I have backup drives everywhere no one

543
00:25:56,620 --> 00:26:09,699
wants to touch my laptop because it's

544
00:25:58,390 --> 00:26:12,880
full of Mauer I can actually show you so

545
00:26:09,700 --> 00:26:14,890
I'm super organized and I have like all

546
00:26:12,880 --> 00:26:18,370
my Mauer here that I'm like recently

547
00:26:14,890 --> 00:26:20,620
looking at and I keep any Mauer that's

548
00:26:18,370 --> 00:26:22,439
old I like put it on my server so I can

549
00:26:20,620 --> 00:26:25,149
go you know bring it back down again

550
00:26:22,440 --> 00:26:27,309
it's not password protected but it's my

551
00:26:25,150 --> 00:26:31,230
server and it's locked down so it's my

552
00:26:27,309 --> 00:26:31,230
malware I do what I want

553
00:26:33,630 --> 00:26:38,980
yes yeah

554
00:26:36,909 --> 00:26:41,760
give me your malware yeah I'll look at

555
00:26:38,980 --> 00:26:41,760
him yep

556
00:26:41,769 --> 00:26:50,600
it's on my secured or github dial if you

557
00:26:47,480 --> 00:27:02,029
go to my Twitter page it has the URL

558
00:26:50,600 --> 00:27:04,539
there yeah these slides yeah yep any

559
00:27:02,029 --> 00:27:04,539
other questions

560
00:27:04,960 --> 00:27:10,809
awesome I think I got everyone back on

561
00:27:08,210 --> 00:27:10,809
time now

562
00:27:18,050 --> 00:27:21,919
[Applause]

563
00:27:32,690 --> 00:27:34,750
you

