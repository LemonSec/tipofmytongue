1
00:00:00,000 --> 00:00:07,230
all right this is automated bug finding

2
00:00:03,360 --> 00:00:09,870
in practice with Kent Clint Gibbler and

3
00:00:07,230 --> 00:00:11,340
Daniel DeFries dr. Clint Gibbler is a

4
00:00:09,870 --> 00:00:12,928
senior security consultant and research

5
00:00:11,340 --> 00:00:14,070
director at NCC Group a global

6
00:00:12,929 --> 00:00:15,809
information assurance specialist

7
00:00:14,070 --> 00:00:17,940
providing organizations with security

8
00:00:15,809 --> 00:00:19,650
consulting services by day he performs

9
00:00:17,940 --> 00:00:21,180
penetration tests of web applications

10
00:00:19,650 --> 00:00:22,919
mobile apps and networks for companies

11
00:00:21,180 --> 00:00:25,609
ranging from large enterprises to new

12
00:00:22,920 --> 00:00:28,019
startups Daniel is a co-founder of

13
00:00:25,609 --> 00:00:29,640
practical program analysis LLC a

14
00:00:28,019 --> 00:00:31,380
boutique security firm specializing in

15
00:00:29,640 --> 00:00:32,668
building security tools that make pen

16
00:00:31,380 --> 00:00:34,680
testers and security engineers more

17
00:00:32,668 --> 00:00:36,629
efficient he is currently a PhD student

18
00:00:34,680 --> 00:00:38,040
at UC Davis where his research focuses

19
00:00:36,630 --> 00:00:39,780
on developing analysis techniques to

20
00:00:38,040 --> 00:00:46,590
find bugs in the Linux kernel please

21
00:00:39,780 --> 00:00:48,480
welcome Quintin Daniel to con 2018 Hey

22
00:00:46,590 --> 00:00:49,739
thank you so much for coming and thank

23
00:00:48,480 --> 00:00:51,510
you to the organizers for having us

24
00:00:49,739 --> 00:00:53,370
today we're gonna be talking about a

25
00:00:51,510 --> 00:00:54,870
number of different automated bug

26
00:00:53,370 --> 00:00:57,570
finding techniques and we're also gonna

27
00:00:54,870 --> 00:00:59,218
talk about when they're good when they

28
00:00:57,570 --> 00:01:00,989
struggle and point you to a bunch of

29
00:00:59,219 --> 00:01:03,359
resources for learning more whether it's

30
00:01:00,989 --> 00:01:05,220
tools papers or other cumference talks

31
00:01:03,359 --> 00:01:09,960
so let's get into it

32
00:01:05,220 --> 00:01:12,179
first a little bit about us so I'm

33
00:01:09,960 --> 00:01:14,639
Daniel freeze I'm a PhD student UC Davis

34
00:01:12,180 --> 00:01:16,500
my research is program analysis on

35
00:01:14,640 --> 00:01:20,240
systems code particularly Linux kernel I

36
00:01:16,500 --> 00:01:22,380
like finding bugs and Linux we run a new

37
00:01:20,240 --> 00:01:26,580
security firm for a practical program in

38
00:01:22,380 --> 00:01:28,530
SOC finding bugs and basically we want

39
00:01:26,580 --> 00:01:31,079
to do program analysis from a practical

40
00:01:28,530 --> 00:01:35,670
perspective and I would be happy to talk

41
00:01:31,079 --> 00:01:36,929
your ear off about LLVM and I'm a

42
00:01:35,670 --> 00:01:39,060
research director and security

43
00:01:36,930 --> 00:01:41,369
consultant doing penetration tests at

44
00:01:39,060 --> 00:01:43,170
all sorts of companies also a co-founder

45
00:01:41,369 --> 00:01:45,450
and I'm a middle Westerner living in San

46
00:01:43,170 --> 00:01:49,439
Francisco the land of Kombucha on tap

47
00:01:45,450 --> 00:01:50,579
and go to yoga so before we get into it

48
00:01:49,439 --> 00:01:52,500
let's talk a little motivation about

49
00:01:50,579 --> 00:01:54,089
this talk so life as an application

50
00:01:52,500 --> 00:01:56,149
security engineer tends to be like the

51
00:01:54,090 --> 00:01:58,049
following so you have a small team of

52
00:01:56,149 --> 00:01:59,640
app site professionals who are

53
00:01:58,049 --> 00:02:01,259
supporting hundreds or even thousands of

54
00:01:59,640 --> 00:02:03,479
developers so there's too much code

55
00:02:01,259 --> 00:02:05,280
being developed too quickly to possibly

56
00:02:03,479 --> 00:02:07,259
review by hand but at the same time you

57
00:02:05,280 --> 00:02:09,538
want to ensure a security baseline

58
00:02:07,259 --> 00:02:11,700
across all of these repos and services

59
00:02:09,538 --> 00:02:14,268
so the question is how can we find bugs

60
00:02:11,700 --> 00:02:15,709
at scale and can we find some bugs

61
00:02:14,269 --> 00:02:18,930
semi-automatically

62
00:02:15,709 --> 00:02:20,400
so the answer is yes we can or this

63
00:02:18,930 --> 00:02:22,739
would be a pretty boring talk it would

64
00:02:20,400 --> 00:02:24,870
just be one slide that said no but

65
00:02:22,739 --> 00:02:26,519
unlike a lot of people who hype up

66
00:02:24,870 --> 00:02:27,959
specific techniques or specific products

67
00:02:26,519 --> 00:02:29,879
we're going to keep it real and be

68
00:02:27,959 --> 00:02:33,030
honest about strengths and weaknesses of

69
00:02:29,879 --> 00:02:35,159
various approaches ok so this is the

70
00:02:33,030 --> 00:02:37,590
entire talk at a big picture so we're

71
00:02:35,159 --> 00:02:39,030
going to talk at a high level about some

72
00:02:37,590 --> 00:02:40,680
automated bug finding in general and

73
00:02:39,030 --> 00:02:41,940
sort of the big classes of it then we're

74
00:02:40,680 --> 00:02:44,069
going to talk about some specific

75
00:02:41,940 --> 00:02:45,599
techniques in detail and then at the end

76
00:02:44,069 --> 00:02:47,608
we're going to have a sort of cheat

77
00:02:45,599 --> 00:02:49,649
sheet overview for everything we talked

78
00:02:47,609 --> 00:02:52,970
about here's when it's good here's what

79
00:02:49,650 --> 00:02:56,430
it has troubles and and things like that

80
00:02:52,970 --> 00:02:58,920
ok so when we say program analysis this

81
00:02:56,430 --> 00:03:00,299
sounds sort of fancy but really it's

82
00:02:58,920 --> 00:03:02,629
just a pretentious way of saying

83
00:03:00,299 --> 00:03:04,379
programs that analyze other programs so

84
00:03:02,629 --> 00:03:06,239
specifically we're going to be talking

85
00:03:04,379 --> 00:03:07,620
in the context of security but really

86
00:03:06,239 --> 00:03:11,190
this could be applied to a number of

87
00:03:07,620 --> 00:03:13,889
problem domains such as just analyzing

88
00:03:11,190 --> 00:03:15,810
program behavior or just generally

89
00:03:13,889 --> 00:03:20,280
understanding how a given system works

90
00:03:15,810 --> 00:03:21,959
by building a tool to analyze it so you

91
00:03:20,280 --> 00:03:23,459
can group automated bug finding

92
00:03:21,959 --> 00:03:26,129
techniques into two high-level

93
00:03:23,459 --> 00:03:28,319
categories static analysis and dynamic

94
00:03:26,129 --> 00:03:30,209
analysis so static is reasoning about

95
00:03:28,319 --> 00:03:33,000
code based on looking at it and then

96
00:03:30,209 --> 00:03:34,949
dynamic is running code and observing

97
00:03:33,000 --> 00:03:37,940
how it behaves so one you look at the

98
00:03:34,949 --> 00:03:40,349
code the other you are running it and

99
00:03:37,940 --> 00:03:42,510
observing how it behaves at runtime so

100
00:03:40,349 --> 00:03:44,220
static analysis is nice in that it's

101
00:03:42,510 --> 00:03:48,328
high coverage because you see all of the

102
00:03:44,220 --> 00:03:50,760
code and it can be fast but the con is

103
00:03:48,329 --> 00:03:52,409
that it's imprecise in that just

104
00:03:50,760 --> 00:03:54,510
inherently in any static analysis tool

105
00:03:52,409 --> 00:03:57,349
there's various approximations and

106
00:03:54,510 --> 00:03:59,489
assumptions you have to make in order to

107
00:03:57,349 --> 00:04:02,459
and just build a tool that actually

108
00:03:59,489 --> 00:04:04,680
finishes running in practice on the

109
00:04:02,459 --> 00:04:07,109
other hand dynamic analysis is precise

110
00:04:04,680 --> 00:04:08,699
in that if you see a vulnerability

111
00:04:07,109 --> 00:04:11,280
that's actually exploited you know it

112
00:04:08,699 --> 00:04:13,109
actually is a bug so it tends to report

113
00:04:11,280 --> 00:04:15,449
more true positives but on the other

114
00:04:13,109 --> 00:04:16,859
hand code coverage can be a challenge so

115
00:04:15,449 --> 00:04:19,829
when you're only detecting

116
00:04:16,858 --> 00:04:21,418
vulnerabilities based on running it and

117
00:04:19,829 --> 00:04:23,250
observing behavior any code that you're

118
00:04:21,418 --> 00:04:26,520
not running you can't find bugs in

119
00:04:23,250 --> 00:04:29,910
right and again this is just a

120
00:04:26,520 --> 00:04:31,490
high-level generalization so some common

121
00:04:29,910 --> 00:04:35,310
terminology when we're talking about

122
00:04:31,490 --> 00:04:37,470
automated bug finding tools so we care

123
00:04:35,310 --> 00:04:39,600
about whether a tool reports or doesn't

124
00:04:37,470 --> 00:04:41,640
report something and then on the other

125
00:04:39,600 --> 00:04:44,040
side whether something's a real bug or

126
00:04:41,640 --> 00:04:46,050
not a real bug so if a tool says hey

127
00:04:44,040 --> 00:04:47,550
this is a bug and you look at it and

128
00:04:46,050 --> 00:04:50,310
actually is we call this a true positive

129
00:04:47,550 --> 00:04:52,800
which is great we found a bug we care

130
00:04:50,310 --> 00:04:54,450
about but if the tool says hey this is a

131
00:04:52,800 --> 00:04:56,310
bug but it's not a real bug we call this

132
00:04:54,450 --> 00:04:58,710
a false positive in that it's thinks

133
00:04:56,310 --> 00:05:00,240
something's an issue but it's not and

134
00:04:58,710 --> 00:05:03,000
then on the other side if the tool

135
00:05:00,240 --> 00:05:04,320
doesn't find a bug but through pen

136
00:05:03,000 --> 00:05:06,030
testing or other approaches you find

137
00:05:04,320 --> 00:05:08,760
it's actually there this is false

138
00:05:06,030 --> 00:05:10,440
negative so this can be bad because you

139
00:05:08,760 --> 00:05:12,870
may think that hey we've used all these

140
00:05:10,440 --> 00:05:15,240
tools and we're pretty sure that this

141
00:05:12,870 --> 00:05:18,780
tool are this code base is secure but

142
00:05:15,240 --> 00:05:20,490
you've missed some things but then a

143
00:05:18,780 --> 00:05:22,409
good thing true negative if it doesn't

144
00:05:20,490 --> 00:05:24,030
report a bug and it's there's no bug

145
00:05:22,410 --> 00:05:27,750
there cool like don't bother me about

146
00:05:24,030 --> 00:05:29,700
things that don't exist so ideally you

147
00:05:27,750 --> 00:05:31,650
want to minimize false positives and

148
00:05:29,700 --> 00:05:33,120
also false negatives but this is the

149
00:05:31,650 --> 00:05:35,219
real world and you can never build a

150
00:05:33,120 --> 00:05:36,600
tool that is perfect in both there's

151
00:05:35,220 --> 00:05:39,870
just fundamental reasons why this is

152
00:05:36,600 --> 00:05:42,240
never the case okay so first topic let's

153
00:05:39,870 --> 00:05:45,060
talk about static taint analysis so this

154
00:05:42,240 --> 00:05:46,260
sounds complicated and fancy but you've

155
00:05:45,060 --> 00:05:48,810
probably used a form of this already

156
00:05:46,260 --> 00:05:50,789
right so as a penetration tester

157
00:05:48,810 --> 00:05:52,530
oftentimes we're looking in code bases

158
00:05:50,790 --> 00:05:54,720
for things that might be interesting to

159
00:05:52,530 --> 00:05:56,760
investigate further and one Python

160
00:05:54,720 --> 00:05:59,810
example is the run method of sub-process

161
00:05:56,760 --> 00:06:02,550
which takes an argument and runs it a

162
00:05:59,810 --> 00:06:04,950
sort of a shell command so if an

163
00:06:02,550 --> 00:06:06,570
attacker is able to pass input into this

164
00:06:04,950 --> 00:06:09,120
this could be dangerous because it could

165
00:06:06,570 --> 00:06:12,240
lead to code execution so grep is nice

166
00:06:09,120 --> 00:06:15,210
in that it's very simple to search for a

167
00:06:12,240 --> 00:06:16,919
given string a regular expression but it

168
00:06:15,210 --> 00:06:18,750
doesn't quite do everything we want

169
00:06:16,919 --> 00:06:20,669
right so if we just look for this string

170
00:06:18,750 --> 00:06:23,160
we may match on something that's in a

171
00:06:20,669 --> 00:06:25,859
comment we may match on something that's

172
00:06:23,160 --> 00:06:29,010
in a string so you know sub-process dot

173
00:06:25,860 --> 00:06:30,720
run in both of these cases is textually

174
00:06:29,010 --> 00:06:32,360
in the code but it's not actually

175
00:06:30,720 --> 00:06:36,320
running the method that we care about so

176
00:06:32,360 --> 00:06:38,450
in order to have some language aware

177
00:06:36,320 --> 00:06:41,420
processing we really need something that

178
00:06:38,450 --> 00:06:45,770
can parse the source code into a format

179
00:06:41,420 --> 00:06:47,540
that we can reason about so often we

180
00:06:45,770 --> 00:06:49,789
take source code and parse it into an

181
00:06:47,540 --> 00:06:54,050
intermediate format or abstract syntax

182
00:06:49,790 --> 00:06:55,760
tree or ast which allows us to do things

183
00:06:54,050 --> 00:06:58,040
like the following so really here we're

184
00:06:55,760 --> 00:06:59,960
looking for find me every time the run

185
00:06:58,040 --> 00:07:01,910
method is called on the sub process

186
00:06:59,960 --> 00:07:04,789
module so rather than looking at just

187
00:07:01,910 --> 00:07:06,380
the string text of the source code we

188
00:07:04,790 --> 00:07:09,050
can parse it into this tree like

189
00:07:06,380 --> 00:07:10,340
structure where we might say okay this

190
00:07:09,050 --> 00:07:13,100
isn't just text it's actually a

191
00:07:10,340 --> 00:07:15,289
conditional and we see there's this call

192
00:07:13,100 --> 00:07:17,270
expression representing the sub

193
00:07:15,290 --> 00:07:19,340
processed out run method and so forth so

194
00:07:17,270 --> 00:07:21,740
rather than operating on just text we're

195
00:07:19,340 --> 00:07:23,869
operating on a tree or a graph like

196
00:07:21,740 --> 00:07:28,310
structure which lets us reason about

197
00:07:23,870 --> 00:07:29,570
code constructs and so ultimately we

198
00:07:28,310 --> 00:07:32,570
need to know what we're looking for as

199
00:07:29,570 --> 00:07:36,050
one wise woman said you get in life what

200
00:07:32,570 --> 00:07:38,090
you have the courage to ask for and yes

201
00:07:36,050 --> 00:07:41,450
we just put a quote from Oprah in our

202
00:07:38,090 --> 00:07:43,039
computer security talk so specifically

203
00:07:41,450 --> 00:07:45,289
what do we won right so when we're pen

204
00:07:43,040 --> 00:07:47,930
testing we want things like here's some

205
00:07:45,290 --> 00:07:49,610
data I control and it gets passed to in

206
00:07:47,930 --> 00:07:52,580
this case the arguments of so processed

207
00:07:49,610 --> 00:07:55,430
run so uh wasp calls these injection

208
00:07:52,580 --> 00:07:56,900
attacks where there's basically attacker

209
00:07:55,430 --> 00:07:59,270
controlled data that go to some

210
00:07:56,900 --> 00:08:00,950
dangerous location and when you think

211
00:07:59,270 --> 00:08:02,690
about it this actually describes a ton

212
00:08:00,950 --> 00:08:04,370
of different types of vulnerabilities so

213
00:08:02,690 --> 00:08:08,840
buffer overflows cross-site scripting

214
00:08:04,370 --> 00:08:10,610
sequel injection and so forth so if

215
00:08:08,840 --> 00:08:13,130
you've heard of various commercial

216
00:08:10,610 --> 00:08:15,260
static analysis tools like check marks

217
00:08:13,130 --> 00:08:17,120
fortify and a bunch of other ones this

218
00:08:15,260 --> 00:08:19,370
is essentially at their core how they

219
00:08:17,120 --> 00:08:20,930
actually work so at the beginning you

220
00:08:19,370 --> 00:08:23,870
have source code which is then parsed

221
00:08:20,930 --> 00:08:26,390
into an intermediate representation such

222
00:08:23,870 --> 00:08:27,650
as an abstract syntax tree but from

223
00:08:26,390 --> 00:08:29,659
there we don't have quite all the

224
00:08:27,650 --> 00:08:31,280
information we want we want to add a

225
00:08:29,660 --> 00:08:35,270
control and data flow on there as well

226
00:08:31,280 --> 00:08:37,520
so you know this statement if it

227
00:08:35,270 --> 00:08:40,340
evaluates to true then we execute these

228
00:08:37,520 --> 00:08:42,470
or not for conditionals or you know this

229
00:08:40,340 --> 00:08:44,510
is how data flows through the system so

230
00:08:42,470 --> 00:08:46,550
by adding these extra edges and building

231
00:08:44,510 --> 00:08:48,500
a graph we can reason about control and

232
00:08:46,550 --> 00:08:49,370
data dependencies between statements and

233
00:08:48,500 --> 00:08:50,780
functions

234
00:08:49,370 --> 00:08:53,150
so once you have all of this knowledge

235
00:08:50,780 --> 00:08:56,510
codified up you can then apply various

236
00:08:53,150 --> 00:08:59,620
security rules and then at the and then

237
00:08:56,510 --> 00:09:02,689
out of this you get some security bugs

238
00:08:59,620 --> 00:09:04,730
so in every static analysis tool there's

239
00:09:02,690 --> 00:09:05,420
several core components so let's talk

240
00:09:04,730 --> 00:09:08,240
about those

241
00:09:05,420 --> 00:09:10,010
so flask is a Python based web

242
00:09:08,240 --> 00:09:12,770
application framework so let's look at a

243
00:09:10,010 --> 00:09:16,580
very simple controller that takes in a

244
00:09:12,770 --> 00:09:19,310
folder URL parameter and then runs LS on

245
00:09:16,580 --> 00:09:22,820
that folder so what's dangerous here is

246
00:09:19,310 --> 00:09:24,770
if a malicious folder value is passed in

247
00:09:22,820 --> 00:09:26,590
then potentially there's a command

248
00:09:24,770 --> 00:09:29,810
injection issue here

249
00:09:26,590 --> 00:09:31,850
so in general we want to keep track of

250
00:09:29,810 --> 00:09:33,890
something called sources which is where

251
00:09:31,850 --> 00:09:37,310
does attacker control input enter the

252
00:09:33,890 --> 00:09:39,610
system so examples are URL and foreign

253
00:09:37,310 --> 00:09:45,020
parameters headers environment variables

254
00:09:39,610 --> 00:09:46,970
and so forth and then we care about

255
00:09:45,020 --> 00:09:48,680
where does this dangerous input

256
00:09:46,970 --> 00:09:50,570
potentially go so we call these sinks

257
00:09:48,680 --> 00:09:53,349
which is basically if an attacker can

258
00:09:50,570 --> 00:09:56,240
control input that goes here this is bad

259
00:09:53,350 --> 00:09:59,270
so some examples of sinks so in this

260
00:09:56,240 --> 00:10:01,490
case it's any arguments to sub process

261
00:09:59,270 --> 00:10:04,040
dot run but some other examples are just

262
00:10:01,490 --> 00:10:06,110
any unpair mature I sequel query if

263
00:10:04,040 --> 00:10:07,579
you're generating HTML without properly

264
00:10:06,110 --> 00:10:13,880
encoding it this can lead to cross-site

265
00:10:07,580 --> 00:10:16,160
scripting and so forth okay but in the

266
00:10:13,880 --> 00:10:18,140
real world it's not often that you get

267
00:10:16,160 --> 00:10:19,640
attacker cultural input and directly

268
00:10:18,140 --> 00:10:20,990
pass it somewhere dangerous usually

269
00:10:19,640 --> 00:10:24,020
there's a series of steps in between

270
00:10:20,990 --> 00:10:25,520
where it's processed or may be passed

271
00:10:24,020 --> 00:10:27,500
between functions or things like that so

272
00:10:25,520 --> 00:10:29,360
we need to be able to track when did it

273
00:10:27,500 --> 00:10:30,860
enter the system and then how eventually

274
00:10:29,360 --> 00:10:33,140
does it get there and so the

275
00:10:30,860 --> 00:10:34,850
intermediate steps in that are called

276
00:10:33,140 --> 00:10:37,340
transfer functions which is basically an

277
00:10:34,850 --> 00:10:41,330
operation where attacker controlled

278
00:10:37,340 --> 00:10:44,750
input or a taint is propagated so some

279
00:10:41,330 --> 00:10:47,270
examples of this are assignment or

280
00:10:44,750 --> 00:10:51,800
various string concatenation operations

281
00:10:47,270 --> 00:10:55,010
and things like that okay the final

282
00:10:51,800 --> 00:10:56,810
thing is sometimes either we use a

283
00:10:55,010 --> 00:10:59,750
library or build a function ourselves

284
00:10:56,810 --> 00:11:01,819
that processes user input and then makes

285
00:10:59,750 --> 00:11:02,720
it safe so for example here we could

286
00:11:01,820 --> 00:11:06,889
have this canal

287
00:11:02,720 --> 00:11:09,139
path method that makes sure that the

288
00:11:06,889 --> 00:11:11,269
user provided value isn't in a folder

289
00:11:09,139 --> 00:11:15,529
other than one of the ones we expect so

290
00:11:11,269 --> 00:11:16,939
in general we're looking for where where

291
00:11:15,529 --> 00:11:19,579
does attacker control templates start

292
00:11:16,939 --> 00:11:21,410
where is it bad if it goes to how does

293
00:11:19,579 --> 00:11:23,089
it get between those two and then does

294
00:11:21,410 --> 00:11:25,579
any of those steps pass through a method

295
00:11:23,089 --> 00:11:28,069
that makes it safe so if the tool

296
00:11:25,579 --> 00:11:30,019
doesn't understand various sanitizer

297
00:11:28,069 --> 00:11:32,029
methods it may report an issue that we

298
00:11:30,019 --> 00:11:33,769
don't actually care about because we've

299
00:11:32,029 --> 00:11:37,009
made it safe the tool just doesn't get

300
00:11:33,769 --> 00:11:39,050
that so some examples of this are

301
00:11:37,009 --> 00:11:41,180
performing output encoding to protect

302
00:11:39,050 --> 00:11:42,790
from cross-site scripting parametrized

303
00:11:41,180 --> 00:11:48,258
queries to prevent from sequel injection

304
00:11:42,790 --> 00:11:52,009
and so forth okay so when a static an

305
00:11:48,259 --> 00:11:53,720
else is hard this could be ten hours of

306
00:11:52,009 --> 00:11:56,269
content itself but here's some high

307
00:11:53,720 --> 00:11:57,889
level things so when you're reasoning

308
00:11:56,269 --> 00:12:00,079
about code if you don't have all of it

309
00:11:57,889 --> 00:12:03,470
then you can't properly model it right

310
00:12:00,079 --> 00:12:05,180
so if the code passes some tainted data

311
00:12:03,470 --> 00:12:06,829
into some library function and we don't

312
00:12:05,180 --> 00:12:09,229
have that source code we can't reason

313
00:12:06,829 --> 00:12:10,638
about it so we don't know when we get it

314
00:12:09,230 --> 00:12:12,620
back like where does it come back into

315
00:12:10,639 --> 00:12:14,660
the system was it made safe in this

316
00:12:12,620 --> 00:12:17,139
library if you're reaching out to an

317
00:12:14,660 --> 00:12:19,670
external API you don't necessarily know

318
00:12:17,139 --> 00:12:21,559
what it's doing with the data and so

319
00:12:19,670 --> 00:12:22,878
forth there's also dynamic language

320
00:12:21,559 --> 00:12:24,319
features that are hard to reason about

321
00:12:22,879 --> 00:12:26,209
statically because again we're not

322
00:12:24,319 --> 00:12:28,579
running the code where we're just

323
00:12:26,209 --> 00:12:31,309
reasoning about it so eval type

324
00:12:28,579 --> 00:12:33,229
functions that take a string and run

325
00:12:31,309 --> 00:12:36,110
them as code or for example using

326
00:12:33,230 --> 00:12:38,509
reflection in Java it's also tough to do

327
00:12:36,110 --> 00:12:40,220
interprocedural analysis so so far the

328
00:12:38,509 --> 00:12:43,459
examples have been within one method but

329
00:12:40,220 --> 00:12:45,589
in many cases tainted data is flowing

330
00:12:43,459 --> 00:12:46,910
across classes across files across

331
00:12:45,589 --> 00:12:48,889
methods and we need to be able to keep

332
00:12:46,910 --> 00:12:51,769
track of this and just implementation

333
00:12:48,889 --> 00:12:53,600
wise this is hard also supporting many

334
00:12:51,769 --> 00:12:57,079
languages and frameworks in practice can

335
00:12:53,600 --> 00:12:59,449
be a ton of engineering work for example

336
00:12:57,079 --> 00:13:00,859
just on C depending on which compiler

337
00:12:59,449 --> 00:13:03,709
they're using the language constructs

338
00:13:00,860 --> 00:13:05,300
they accept may be very different and

339
00:13:03,709 --> 00:13:07,819
your tool needs to be able to handle all

340
00:13:05,300 --> 00:13:08,660
of them so there's a very interesting

341
00:13:07,819 --> 00:13:10,910
article below

342
00:13:08,660 --> 00:13:13,459
from Coverity where they basically talk

343
00:13:10,910 --> 00:13:15,050
about hey we built this tool and here's

344
00:13:13,459 --> 00:13:16,130
a bunch of problems we had actually

345
00:13:15,050 --> 00:13:19,609
getting it to work

346
00:13:16,130 --> 00:13:22,070
in practice okay so what are some nice

347
00:13:19,610 --> 00:13:24,350
things about static analysis so tools

348
00:13:22,070 --> 00:13:25,760
gale better than people you don't have

349
00:13:24,350 --> 00:13:27,530
time to manually review millions of

350
00:13:25,760 --> 00:13:29,240
lines of code but you can throw a tool

351
00:13:27,530 --> 00:13:31,339
at it it can also give you some

352
00:13:29,240 --> 00:13:32,720
interesting results for large legacy

353
00:13:31,340 --> 00:13:35,780
code bases finding some of our

354
00:13:32,720 --> 00:13:38,840
low-hanging fruit and human auditors get

355
00:13:35,780 --> 00:13:40,850
tired you know after so many hours but

356
00:13:38,840 --> 00:13:42,800
tools because they define what they're

357
00:13:40,850 --> 00:13:45,710
looking for they can always apply the

358
00:13:42,800 --> 00:13:47,300
security rules consistently and in

359
00:13:45,710 --> 00:13:49,070
theory you can keep up with the rapid

360
00:13:47,300 --> 00:13:51,439
pace of development but doing very

361
00:13:49,070 --> 00:13:56,000
complicated data flow can be slow in

362
00:13:51,440 --> 00:13:58,700
practice so if you're using this as an

363
00:13:56,000 --> 00:14:00,740
application security team there's often

364
00:13:58,700 --> 00:14:02,750
a significant initial time investment in

365
00:14:00,740 --> 00:14:04,130
setting it up and tuning it so just out

366
00:14:02,750 --> 00:14:06,560
of the box that may report tons and tons

367
00:14:04,130 --> 00:14:08,870
of false positives so you need to teach

368
00:14:06,560 --> 00:14:10,579
it how your code base works and it can

369
00:14:08,870 --> 00:14:12,620
also be a large recurring time

370
00:14:10,580 --> 00:14:14,560
investment triaging the finding which

371
00:14:12,620 --> 00:14:16,940
can be boring for the epic team and

372
00:14:14,560 --> 00:14:20,780
pushing those results too directly to

373
00:14:16,940 --> 00:14:22,460
developers can damage trust so here's a

374
00:14:20,780 --> 00:14:24,319
bunch of tools brakeman is the most

375
00:14:22,460 --> 00:14:26,360
popular Ruby on Rails one and we've

376
00:14:24,320 --> 00:14:29,090
listed a bunch of resources for other

377
00:14:26,360 --> 00:14:31,160
languages and there is a awesome static

378
00:14:29,090 --> 00:14:35,960
analysis github repo that lists like

379
00:14:31,160 --> 00:14:38,480
hundreds of them so if you want to know

380
00:14:35,960 --> 00:14:39,890
more about the principles of how static

381
00:14:38,480 --> 00:14:42,440
analysis works there's a pretty great

382
00:14:39,890 --> 00:14:44,630
book written by several of the original

383
00:14:42,440 --> 00:14:46,490
fortify people called secure programming

384
00:14:44,630 --> 00:14:48,860
- static analysis if you want to

385
00:14:46,490 --> 00:14:50,090
understand the academic underpinnings a

386
00:14:48,860 --> 00:14:51,830
little bit more there's some compiler

387
00:14:50,090 --> 00:14:54,290
books that are pretty good and if you

388
00:14:51,830 --> 00:14:56,120
want to know a huge amount of mathy

389
00:14:54,290 --> 00:14:58,310
detail about all these different program

390
00:14:56,120 --> 00:15:00,680
analysis things you can read principles

391
00:14:58,310 --> 00:15:02,239
of program analysis which is incredibly

392
00:15:00,680 --> 00:15:05,390
dense I think like the third page is

393
00:15:02,240 --> 00:15:11,240
pretty much all equations but there's

394
00:15:05,390 --> 00:15:12,890
some good stuff there too yes so so that

395
00:15:11,240 --> 00:15:15,110
static analysis but static analysis

396
00:15:12,890 --> 00:15:18,410
isn't the only way that you could find

397
00:15:15,110 --> 00:15:20,690
these bugs right so let's talk about the

398
00:15:18,410 --> 00:15:22,579
same problem but approach it from a

399
00:15:20,690 --> 00:15:24,440
dynamic perspective so we're still

400
00:15:22,580 --> 00:15:27,730
talking about taint analysis so we're

401
00:15:24,440 --> 00:15:29,800
still looking for data flows that come

402
00:15:27,730 --> 00:15:31,389
from some this fine source where we

403
00:15:29,800 --> 00:15:33,670
think an attacker control input and

404
00:15:31,389 --> 00:15:35,829
we're still looking for data flows to

405
00:15:33,670 --> 00:15:37,360
some sensitive sink where we don't want

406
00:15:35,829 --> 00:15:38,829
attackers to be able to provide input

407
00:15:37,360 --> 00:15:40,269
and we want to figure out if it's

408
00:15:38,829 --> 00:15:42,189
possible to get there and if so how do

409
00:15:40,269 --> 00:15:44,800
we get there what's the path but we're

410
00:15:42,190 --> 00:15:46,269
gonna try and do it dynamically so the

411
00:15:44,800 --> 00:15:48,490
way you do this with dynamic taint

412
00:15:46,269 --> 00:15:51,339
analysis also known as taint tracking is

413
00:15:48,490 --> 00:15:52,990
that you instrument the program so

414
00:15:51,339 --> 00:15:54,910
you're gonna take the data structures

415
00:15:52,990 --> 00:15:58,329
that exist and you're gonna add some

416
00:15:54,910 --> 00:16:00,459
fields to them so if you see the diagram

417
00:15:58,329 --> 00:16:02,079
at the bottom so this might be what it

418
00:16:00,459 --> 00:16:02,979
would look like approximately if you

419
00:16:02,079 --> 00:16:05,290
were going to do

420
00:16:02,980 --> 00:16:06,970
paint analysis dynamically for Java

421
00:16:05,290 --> 00:16:09,250
strings so this would be a popular

422
00:16:06,970 --> 00:16:11,800
target so Java strings are going to be

423
00:16:09,250 --> 00:16:14,529
objects that have the actual string data

424
00:16:11,800 --> 00:16:18,639
they have some length among much other

425
00:16:14,529 --> 00:16:20,949
things in metadata and they exist in

426
00:16:18,639 --> 00:16:22,870
memory now instead of just having a

427
00:16:20,949 --> 00:16:25,120
vanilla Java string what we do is we

428
00:16:22,870 --> 00:16:29,560
attach an another field we'll call this

429
00:16:25,120 --> 00:16:33,910
a taint tag and set the taint flag to

430
00:16:29,560 --> 00:16:37,000
true if the string came in from say an

431
00:16:33,910 --> 00:16:38,680
HTTP request and set it to false if it's

432
00:16:37,000 --> 00:16:40,420
a string literal if it was generated

433
00:16:38,680 --> 00:16:43,510
from something we trust and then we'll

434
00:16:40,420 --> 00:16:46,089
propagate this now the propagation will

435
00:16:43,510 --> 00:16:47,139
be similar to static taint analysis and

436
00:16:46,089 --> 00:16:50,139
we'll track it as it goes through the

437
00:16:47,139 --> 00:16:52,269
program this happens at some low level

438
00:16:50,139 --> 00:16:54,190
usually so static faint analysis you're

439
00:16:52,269 --> 00:16:55,209
doing source code level analysis and

440
00:16:54,190 --> 00:16:56,470
you're going to try and reason about

441
00:16:55,209 --> 00:16:57,819
properties of the program this is

442
00:16:56,470 --> 00:16:59,920
totally different we're gonna instrument

443
00:16:57,819 --> 00:17:01,420
it possibly at the Java bytecode level

444
00:16:59,920 --> 00:17:03,010
we could instrument it at the machine

445
00:17:01,420 --> 00:17:05,649
code level like say d6 we could

446
00:17:03,010 --> 00:17:07,119
instrument it at some Python interpreter

447
00:17:05,650 --> 00:17:09,970
or something like that and so you need

448
00:17:07,119 --> 00:17:11,678
to actually modify the runtime and then

449
00:17:09,970 --> 00:17:13,809
you need to exercise the program right

450
00:17:11,679 --> 00:17:15,730
so this is dynamic analysis we can't

451
00:17:13,809 --> 00:17:17,410
reason about all paths automatically so

452
00:17:15,730 --> 00:17:20,049
we need some sort of test suite or a

453
00:17:17,410 --> 00:17:21,220
fuzzer or you can just manually click

454
00:17:20,049 --> 00:17:22,780
through the program and somehow you

455
00:17:21,220 --> 00:17:24,910
actually have to drive the program and

456
00:17:22,780 --> 00:17:27,399
run it and then you'll run the

457
00:17:24,910 --> 00:17:29,620
instrumented version and you'll see do

458
00:17:27,400 --> 00:17:32,140
we actually see any tainted data go to

459
00:17:29,620 --> 00:17:35,290
sinks that's our goal if the data does

460
00:17:32,140 --> 00:17:37,510
actually reach a sink then we have a

461
00:17:35,290 --> 00:17:39,399
problem the nice thing is it's dynamic

462
00:17:37,510 --> 00:17:40,480
analysis is that if it you actually see

463
00:17:39,400 --> 00:17:41,740
it happen you don't

464
00:17:40,480 --> 00:17:43,809
to worry about false positives because

465
00:17:41,740 --> 00:17:47,169
you have a trace this actually happened

466
00:17:43,809 --> 00:17:48,879
so in the taint analysis world the

467
00:17:47,169 --> 00:17:50,620
instead of transfer functions they tend

468
00:17:48,880 --> 00:17:53,200
to call it taint propagation it's very

469
00:17:50,620 --> 00:17:54,939
similar you define a taint policy so you

470
00:17:53,200 --> 00:17:58,480
list your sources and sinks just like

471
00:17:54,940 --> 00:18:00,100
you did before then you decide and this

472
00:17:58,480 --> 00:18:01,690
is a decision how is taint going to

473
00:18:00,100 --> 00:18:05,350
propagate so here if I have an

474
00:18:01,690 --> 00:18:08,320
assignment from X to X from Y plus Z

475
00:18:05,350 --> 00:18:11,350
let's say either Y or Z is tainted I

476
00:18:08,320 --> 00:18:14,740
have a decision to make is X now tainted

477
00:18:11,350 --> 00:18:16,120
does the plus operator if it's

478
00:18:14,740 --> 00:18:18,520
concatenation if it strings or what if

479
00:18:16,120 --> 00:18:19,809
does that propagate taint or not if it's

480
00:18:18,520 --> 00:18:22,889
straight assignment you probably would

481
00:18:19,809 --> 00:18:25,210
do string builders propagate taint does

482
00:18:22,890 --> 00:18:26,950
your various operations you have to

483
00:18:25,210 --> 00:18:29,049
define a policy for all the language

484
00:18:26,950 --> 00:18:31,750
constructs usually at a low level again

485
00:18:29,049 --> 00:18:34,240
so Java bytecode what what is going to

486
00:18:31,750 --> 00:18:37,059
propagate to taint you also have to

487
00:18:34,240 --> 00:18:40,270
worry about implicit flows so control

488
00:18:37,059 --> 00:18:43,389
dependent flows if I have if a is true

489
00:18:40,270 --> 00:18:45,730
then B is true now clearly there is a

490
00:18:43,390 --> 00:18:48,340
flow of information from A to B here

491
00:18:45,730 --> 00:18:50,350
right a and B will always be set to the

492
00:18:48,340 --> 00:18:51,939
same yet there's no actual machine code

493
00:18:50,350 --> 00:18:55,030
assignment anywhere in there that's

494
00:18:51,940 --> 00:18:56,650
gonna say B is equal to a so this would

495
00:18:55,030 --> 00:18:59,350
be an implicit flow do I worry about

496
00:18:56,650 --> 00:19:01,150
this in a privacy world if you're

497
00:18:59,350 --> 00:19:03,100
worried about tracking tainted for

498
00:19:01,150 --> 00:19:06,780
information leaks for example as a phone

499
00:19:03,100 --> 00:19:09,309
may be leaking your unique identifier or

500
00:19:06,780 --> 00:19:10,450
your user ID or something this might be

501
00:19:09,309 --> 00:19:13,840
something that you'd be very interested

502
00:19:10,450 --> 00:19:15,340
in tracking but if you taint implicit

503
00:19:13,840 --> 00:19:17,139
flows all of a sudden you're gonna taint

504
00:19:15,340 --> 00:19:19,389
a lot of things and now you have to deal

505
00:19:17,140 --> 00:19:20,980
with false positives so again there's

506
00:19:19,390 --> 00:19:23,230
lots of decisions to make here you can't

507
00:19:20,980 --> 00:19:28,770
just run a taint analysis it has to be

508
00:19:23,230 --> 00:19:31,720
tailored to your specific problem and

509
00:19:28,770 --> 00:19:33,160
these decisions are made with respect to

510
00:19:31,720 --> 00:19:36,700
trade-offs right so what you want to

511
00:19:33,160 --> 00:19:38,799
avoid is over taint consider the example

512
00:19:36,700 --> 00:19:41,350
of having a function table so I've got

513
00:19:38,799 --> 00:19:43,840
some function table that has a list of

514
00:19:41,350 --> 00:19:46,418
functions in it and perhaps I'm going to

515
00:19:43,840 --> 00:19:47,590
receive input in from a network source

516
00:19:46,419 --> 00:19:49,179
so this is going to be a network packet

517
00:19:47,590 --> 00:19:51,189
with lots of headers this might be

518
00:19:49,179 --> 00:19:52,690
partially tainted right so perhaps

519
00:19:51,190 --> 00:19:54,130
there's protocol headers that I don't

520
00:19:52,690 --> 00:19:55,990
consider tainted but I would

521
00:19:54,130 --> 00:19:58,060
consider the payload data tainted and

522
00:19:55,990 --> 00:20:00,190
now I'm going to jump into a function

523
00:19:58,060 --> 00:20:02,260
table based upon this network data do I

524
00:20:00,190 --> 00:20:05,110
consider that function jump tainted

525
00:20:02,260 --> 00:20:06,580
maybe maybe not it depends on what what

526
00:20:05,110 --> 00:20:09,010
part of the network packet I'm reading

527
00:20:06,580 --> 00:20:10,960
and if you decide to taint control flow

528
00:20:09,010 --> 00:20:12,850
like this now all of a sudden you're

529
00:20:10,960 --> 00:20:14,590
gonna taint a lot of things and this

530
00:20:12,850 --> 00:20:16,360
will probably lead to over taint and

531
00:20:14,590 --> 00:20:17,830
you'll need lots of false positives so

532
00:20:16,360 --> 00:20:20,350
you have to be very careful about what

533
00:20:17,830 --> 00:20:22,179
you're considering tainted input and not

534
00:20:20,350 --> 00:20:25,120
it can't just be anything that comes

535
00:20:22,180 --> 00:20:27,430
into the system usually further

536
00:20:25,120 --> 00:20:29,290
considerations are because this is a

537
00:20:27,430 --> 00:20:31,510
dynamic analysis dynamic analysis

538
00:20:29,290 --> 00:20:33,550
clearly you have to be able to build the

539
00:20:31,510 --> 00:20:36,460
source and instrument it and this can be

540
00:20:33,550 --> 00:20:38,590
an onerous requirement because you have

541
00:20:36,460 --> 00:20:41,050
to be able to instrument every runtime

542
00:20:38,590 --> 00:20:42,639
so if you're targeting Ruby then you

543
00:20:41,050 --> 00:20:43,870
need will instrument Ruby for targeting

544
00:20:42,640 --> 00:20:46,540
Android you need to build in straight

545
00:20:43,870 --> 00:20:48,459
the Android Java interpreter again

546
00:20:46,540 --> 00:20:51,310
leading to implicit flows as a decision

547
00:20:48,460 --> 00:20:53,010
it will probably lead to over taint if

548
00:20:51,310 --> 00:20:55,600
you handle implicit flow so typically

549
00:20:53,010 --> 00:20:58,350
taint analysis will ignore it and they

550
00:20:55,600 --> 00:21:01,659
just say well we don't handle that an

551
00:20:58,350 --> 00:21:04,149
inherently taint analysis will lead to

552
00:21:01,660 --> 00:21:06,790
performance degradation so one enticing

553
00:21:04,150 --> 00:21:08,680
thing might be let's just run a taint

554
00:21:06,790 --> 00:21:10,870
analysis in production so we'll just

555
00:21:08,680 --> 00:21:14,590
instrument our application and then

556
00:21:10,870 --> 00:21:16,300
deploy it and if we see any input that's

557
00:21:14,590 --> 00:21:18,280
come in that is tainted that hits a sink

558
00:21:16,300 --> 00:21:19,600
we should throw an alarm and we'll just

559
00:21:18,280 --> 00:21:21,580
see what happens in real life which

560
00:21:19,600 --> 00:21:23,020
would be really amazing except where it

561
00:21:21,580 --> 00:21:24,939
will probably make your application much

562
00:21:23,020 --> 00:21:26,170
much slower because all of your objects

563
00:21:24,940 --> 00:21:28,150
in memory will be larger your runtime

564
00:21:26,170 --> 00:21:29,830
performance will go down and in practice

565
00:21:28,150 --> 00:21:31,210
this is very difficult to do so what

566
00:21:29,830 --> 00:21:33,340
people who tend to do is they

567
00:21:31,210 --> 00:21:35,230
instrumented in tests and they run test

568
00:21:33,340 --> 00:21:36,820
Suites on it and hope that these test

569
00:21:35,230 --> 00:21:38,230
Suites are representative of what you

570
00:21:36,820 --> 00:21:40,750
see in real life and we all know there

571
00:21:38,230 --> 00:21:42,130
are some limitations there you have to

572
00:21:40,750 --> 00:21:43,420
decide at what level are you tainting

573
00:21:42,130 --> 00:21:45,070
are you interested in tainting every bit

574
00:21:43,420 --> 00:21:46,630
if you're tainting every bit then you

575
00:21:45,070 --> 00:21:48,189
have metadata for every bit of memory

576
00:21:46,630 --> 00:21:49,720
this is probably going to be difficult

577
00:21:48,190 --> 00:21:51,430
to do so you probably can't taint every

578
00:21:49,720 --> 00:21:53,040
bit you probably taint it a much larger

579
00:21:51,430 --> 00:21:56,260
level but now you have a trade-off and

580
00:21:53,040 --> 00:21:58,240
then finally what do you do about native

581
00:21:56,260 --> 00:22:00,460
interfaces so tip let's say you're

582
00:21:58,240 --> 00:22:02,530
tainting an android app and then an

583
00:22:00,460 --> 00:22:04,840
Android app calls into native code and

584
00:22:02,530 --> 00:22:06,730
then that response comes back in well

585
00:22:04,840 --> 00:22:07,309
you probably can't taint the native code

586
00:22:06,730 --> 00:22:09,529
too

587
00:22:07,309 --> 00:22:10,908
it maybe you could but typically you're

588
00:22:09,529 --> 00:22:12,799
probably just doing the interpreter and

589
00:22:10,909 --> 00:22:14,179
so now do you taint everything that

590
00:22:12,799 --> 00:22:15,740
comes in from native code you probably

591
00:22:14,179 --> 00:22:17,360
have an over taint situation do you

592
00:22:15,740 --> 00:22:19,700
taint nothing that goes into native code

593
00:22:17,360 --> 00:22:21,469
you probably under taint situation so it

594
00:22:19,700 --> 00:22:23,029
there are again lots of decisions and

595
00:22:21,470 --> 00:22:26,149
you have to think about what exactly am

596
00:22:23,029 --> 00:22:27,830
I trying to do here there's lots of

597
00:22:26,149 --> 00:22:30,350
resources on this there's a fantastic

598
00:22:27,830 --> 00:22:31,939
paper very classic all you ever wanted

599
00:22:30,350 --> 00:22:33,559
to know about dynamic taint analysis and

600
00:22:31,940 --> 00:22:34,909
forward symbolic execution if you're

601
00:22:33,559 --> 00:22:37,370
interested in that I would recommend

602
00:22:34,909 --> 00:22:40,070
starting there taintdroid for Android

603
00:22:37,370 --> 00:22:42,799
stuff is a both a paper and a tool it's

604
00:22:40,070 --> 00:22:44,418
what sort of got me into this there's

605
00:22:42,799 --> 00:22:45,918
another paper here and linked to a

606
00:22:44,419 --> 00:22:49,039
couple tools these are dynamic paint

607
00:22:45,919 --> 00:22:51,259
analysis for binaries mostly but there's

608
00:22:49,039 --> 00:22:56,600
paint analysis for for lots of things

609
00:22:51,259 --> 00:22:58,820
about grind you can find it so that's

610
00:22:56,600 --> 00:23:00,619
paint analysis both static static and

611
00:22:58,820 --> 00:23:03,189
dynamic let's switch gears a little bit

612
00:23:00,619 --> 00:23:05,509
and talk about a different technique

613
00:23:03,190 --> 00:23:05,869
that tries to do something completely

614
00:23:05,509 --> 00:23:08,179
different

615
00:23:05,869 --> 00:23:11,149
it's called symbolic execution and the

616
00:23:08,179 --> 00:23:14,029
goal here is to think about what are the

617
00:23:11,149 --> 00:23:17,809
limitations of particularly of dynamic

618
00:23:14,029 --> 00:23:20,480
analysis in general which is that when

619
00:23:17,809 --> 00:23:22,999
you watch a program run and you provided

620
00:23:20,480 --> 00:23:25,070
a some concrete input you get to see one

621
00:23:22,999 --> 00:23:26,419
path through that program you have one

622
00:23:25,070 --> 00:23:28,399
piece of information which is that this

623
00:23:26,419 --> 00:23:31,909
input drives the program down some

624
00:23:28,399 --> 00:23:33,408
particular path even if you're using a

625
00:23:31,909 --> 00:23:36,019
fuzzer we'll talk about fuzzing in a

626
00:23:33,409 --> 00:23:38,990
little bit you then throw a lot of

627
00:23:36,019 --> 00:23:40,940
inputs at it and you see that each one

628
00:23:38,990 --> 00:23:44,119
of these inputs provides some particular

629
00:23:40,940 --> 00:23:45,860
path through the program but when a

630
00:23:44,119 --> 00:23:47,360
human reads code they don't really read

631
00:23:45,860 --> 00:23:48,049
code that way they'll look at the

632
00:23:47,360 --> 00:23:50,080
conditionals

633
00:23:48,049 --> 00:23:53,809
they'll reason about it and say well

634
00:23:50,080 --> 00:23:55,939
perhaps this whole range of values if I

635
00:23:53,809 --> 00:23:58,279
see if X is less than a hundred the

636
00:23:55,940 --> 00:24:00,259
human doesn't say well oh for some value

637
00:23:58,279 --> 00:24:01,879
74 we'll go down this path they say well

638
00:24:00,259 --> 00:24:04,899
anytime X is less than a hundred it'll

639
00:24:01,879 --> 00:24:07,279
take this path so how can we sort of

640
00:24:04,899 --> 00:24:09,830
take a step towards automated reasoning

641
00:24:07,279 --> 00:24:12,919
about software and symbolic execution

642
00:24:09,830 --> 00:24:15,830
tries to do this by marking variables as

643
00:24:12,919 --> 00:24:17,539
symbolic so the step one usually when

644
00:24:15,830 --> 00:24:18,830
you're using a symbolic execution engine

645
00:24:17,539 --> 00:24:19,908
as you pick variables that you're

646
00:24:18,830 --> 00:24:21,678
interested in

647
00:24:19,909 --> 00:24:23,239
so these will form a security

648
00:24:21,679 --> 00:24:25,459
perspective these will often be things

649
00:24:23,239 --> 00:24:27,559
that are going to be similar to tainted

650
00:24:25,459 --> 00:24:28,940
sources and you'll figure out where

651
00:24:27,559 --> 00:24:31,879
they're assigned and you say I want to

652
00:24:28,940 --> 00:24:34,099
reason about what is going to happen for

653
00:24:31,879 --> 00:24:36,678
inputs for this particular variable so

654
00:24:34,099 --> 00:24:38,839
step one figure out what objects you're

655
00:24:36,679 --> 00:24:41,029
interested in the program and then we're

656
00:24:38,839 --> 00:24:43,789
going to keep track of what happens to

657
00:24:41,029 --> 00:24:46,299
those in paths through the program as we

658
00:24:43,789 --> 00:24:48,979
look at it and interpret it symbolically

659
00:24:46,299 --> 00:24:51,469
the goal at the end of symbolic

660
00:24:48,979 --> 00:24:54,289
execution is that we want to be able to

661
00:24:51,469 --> 00:25:00,319
say if you give some input in this range

662
00:24:54,289 --> 00:25:02,059
of values then this will happen and if I

663
00:25:00,319 --> 00:25:05,178
want to drive a program to some

664
00:25:02,059 --> 00:25:07,129
particular line of code give me an input

665
00:25:05,179 --> 00:25:08,599
that would get me there do input

666
00:25:07,129 --> 00:25:10,369
generation also called test case

667
00:25:08,599 --> 00:25:12,198
generation which is a really hard

668
00:25:10,369 --> 00:25:14,779
program and particularly difficult for

669
00:25:12,199 --> 00:25:16,219
humans deep in software if you've got

670
00:25:14,779 --> 00:25:18,109
hundreds of if statements and

671
00:25:16,219 --> 00:25:21,559
conditionals and you're trying to reason

672
00:25:18,109 --> 00:25:23,359
how would I figure out some input that

673
00:25:21,559 --> 00:25:25,309
will get me to this piece of line of

674
00:25:23,359 --> 00:25:27,168
code it's a difficult problem and here

675
00:25:25,309 --> 00:25:29,389
symbolic execution can help and this is

676
00:25:27,169 --> 00:25:31,489
really driven by recent advances in

677
00:25:29,389 --> 00:25:33,498
constraint solvers so it's at solving

678
00:25:31,489 --> 00:25:36,079
SMT solving have gotten extremely

679
00:25:33,499 --> 00:25:39,649
impressive in recent years and this is

680
00:25:36,079 --> 00:25:42,709
driven a increase in excitement about

681
00:25:39,649 --> 00:25:47,748
symbolic execution so let's look at an

682
00:25:42,709 --> 00:25:50,059
example so say I have this code at the

683
00:25:47,749 --> 00:25:52,069
beginning will say name the variable

684
00:25:50,059 --> 00:25:53,779
name comes in from some input source and

685
00:25:52,069 --> 00:25:55,940
let's say I'm interested in this

686
00:25:53,779 --> 00:25:58,639
variable so all mark it's a little

687
00:25:55,940 --> 00:26:00,109
difficult to read apologize there's

688
00:25:58,639 --> 00:26:02,599
comments on the side if you can see it

689
00:26:00,109 --> 00:26:05,359
let's let's say I'll mark name is

690
00:26:02,599 --> 00:26:07,519
symbolic now this is unconstrained at

691
00:26:05,359 --> 00:26:09,529
the beginning I have no idea what the

692
00:26:07,519 --> 00:26:10,909
value is that name holds it comes in

693
00:26:09,529 --> 00:26:12,649
from some input source that I don't

694
00:26:10,909 --> 00:26:14,659
control so we just say it's question

695
00:26:12,649 --> 00:26:18,498
mark it's a we have no idea what this is

696
00:26:14,659 --> 00:26:20,599
right now as we step through so an

697
00:26:18,499 --> 00:26:23,119
embolic interpreter will be stepping

698
00:26:20,599 --> 00:26:25,189
through this program and interpreting it

699
00:26:23,119 --> 00:26:26,629
as if it were running pure symbolic

700
00:26:25,190 --> 00:26:29,269
execution isn't actually going to run

701
00:26:26,629 --> 00:26:31,189
the program and it will look at the

702
00:26:29,269 --> 00:26:32,430
conditionals so let's say we've taken

703
00:26:31,190 --> 00:26:35,220
Vivendi R

704
00:26:32,430 --> 00:26:37,320
now we know something about name if we

705
00:26:35,220 --> 00:26:39,570
are executing this line of code we know

706
00:26:37,320 --> 00:26:41,070
for a fact that name has to be equal to

707
00:26:39,570 --> 00:26:42,990
admin so we can mark what we'll call a

708
00:26:41,070 --> 00:26:45,600
path constraint here so at this point in

709
00:26:42,990 --> 00:26:47,790
code we know that the value of name is

710
00:26:45,600 --> 00:26:50,669
admin and this seems very simple and

711
00:26:47,790 --> 00:26:52,920
trivial and in some cases it is but

712
00:26:50,670 --> 00:26:54,930
imagine collecting a lot of these right

713
00:26:52,920 --> 00:26:56,640
so imagine 20 of these chained in a row

714
00:26:54,930 --> 00:26:57,900
would be very interesting to know well

715
00:26:56,640 --> 00:26:59,850
what is the solution to those

716
00:26:57,900 --> 00:27:02,670
constraints and we can keep going here

717
00:26:59,850 --> 00:27:04,770
so if we get to this point we know that

718
00:27:02,670 --> 00:27:07,500
it's the conjunction of the constraints

719
00:27:04,770 --> 00:27:10,170
the name it has to be admin we know that

720
00:27:07,500 --> 00:27:13,380
command must be died so if both of those

721
00:27:10,170 --> 00:27:16,110
are true we get here we can invert one

722
00:27:13,380 --> 00:27:18,570
of those so if we get to this point we

723
00:27:16,110 --> 00:27:20,669
say that name must be admin command is

724
00:27:18,570 --> 00:27:22,379
not equal to die so on and so forth

725
00:27:20,670 --> 00:27:24,260
convert the other one name it's not

726
00:27:22,380 --> 00:27:27,690
equal to admin now we have another one

727
00:27:24,260 --> 00:27:29,250
so now we have the two variables name it

728
00:27:27,690 --> 00:27:30,930
must not be equal to admin we have that

729
00:27:29,250 --> 00:27:32,430
path constraint and we have another

730
00:27:30,930 --> 00:27:33,780
value that will call password which

731
00:27:32,430 --> 00:27:35,700
people say is symbolic we don't know

732
00:27:33,780 --> 00:27:38,910
what that is yet right it comes from

733
00:27:35,700 --> 00:27:40,410
input and we play the same game here

734
00:27:38,910 --> 00:27:43,530
name is not equal to admin link the

735
00:27:40,410 --> 00:27:44,730
password must be less than 20 name is

736
00:27:43,530 --> 00:27:46,080
not an equal to admin link the password

737
00:27:44,730 --> 00:27:47,400
is greater than equal to 20 so we've

738
00:27:46,080 --> 00:27:49,110
gathered all of the constraints in this

739
00:27:47,400 --> 00:27:50,870
short snippet of code so we know what

740
00:27:49,110 --> 00:27:53,219
has to happen here

741
00:27:50,870 --> 00:27:55,260
now you pass these to a constraint

742
00:27:53,220 --> 00:27:56,180
solver so this is something that we're

743
00:27:55,260 --> 00:27:59,010
not going to cover there is

744
00:27:56,180 --> 00:28:00,960
off-the-shelf constraint solvers as III

745
00:27:59,010 --> 00:28:02,550
being a very popular one there's many of

746
00:28:00,960 --> 00:28:05,130
them that are very fast that basically

747
00:28:02,550 --> 00:28:07,350
that's a black box you pass a whole big

748
00:28:05,130 --> 00:28:09,510
list of constraints to it and it will

749
00:28:07,350 --> 00:28:11,189
tell you these values solve it it'll

750
00:28:09,510 --> 00:28:13,860
give you one example back usually some

751
00:28:11,190 --> 00:28:16,230
here's a the values that will get you

752
00:28:13,860 --> 00:28:18,360
here it gives you solutions to the

753
00:28:16,230 --> 00:28:20,040
constraints and says let's say I want to

754
00:28:18,360 --> 00:28:21,689
get to this line crash if you're a

755
00:28:20,040 --> 00:28:25,440
security person crash is probably the

756
00:28:21,690 --> 00:28:26,790
most interesting line here you say if I

757
00:28:25,440 --> 00:28:29,010
want to get to this point that will

758
00:28:26,790 --> 00:28:30,720
crash it what do I need to pass now

759
00:28:29,010 --> 00:28:32,190
clearly a human again could look at this

760
00:28:30,720 --> 00:28:34,500
and figure this out pretty quickly but

761
00:28:32,190 --> 00:28:38,190
imagine this at scale so you ask the

762
00:28:34,500 --> 00:28:39,810
constraint solver tell me the values

763
00:28:38,190 --> 00:28:42,030
that would get me here these are trivial

764
00:28:39,810 --> 00:28:44,340
name is admin command is equal to die

765
00:28:42,030 --> 00:28:45,750
and it gives you these inputs back you

766
00:28:44,340 --> 00:28:46,020
pass these the to the program and the

767
00:28:45,750 --> 00:28:47,880
probe

768
00:28:46,020 --> 00:28:51,780
we'll crash so that's the general idea

769
00:28:47,880 --> 00:28:53,550
it gives you bugs so what's the problem

770
00:28:51,780 --> 00:28:55,230
or whether good things about this so

771
00:28:53,550 --> 00:28:57,690
input generation is amazing actually

772
00:28:55,230 --> 00:28:58,980
getting inputs back is amazing you can

773
00:28:57,690 --> 00:29:03,720
get high coverage test Suites you get

774
00:28:58,980 --> 00:29:05,280
whole symbolic ranges the problems this

775
00:29:03,720 --> 00:29:07,520
is really slow a lot of times there's a

776
00:29:05,280 --> 00:29:09,149
lot of paths through the program has

777
00:29:07,520 --> 00:29:12,120
exponential and the number of branches

778
00:29:09,150 --> 00:29:14,070
that you have there are various advances

779
00:29:12,120 --> 00:29:15,479
that you can read about nowadays most

780
00:29:14,070 --> 00:29:16,980
people will use what's called can colic

781
00:29:15,480 --> 00:29:18,330
testing so this is a combination of

782
00:29:16,980 --> 00:29:21,030
symbolic execution and running the

783
00:29:18,330 --> 00:29:22,560
program can call it concretely to bypass

784
00:29:21,030 --> 00:29:25,050
some problems like what do you do if you

785
00:29:22,560 --> 00:29:27,000
have libraries so that's generally what

786
00:29:25,050 --> 00:29:29,190
you would want to look at if you're

787
00:29:27,000 --> 00:29:31,350
interested in this now and here's some

788
00:29:29,190 --> 00:29:34,820
examples that could get you started in

789
00:29:31,350 --> 00:29:34,820
modern symbolic execution engines

790
00:29:36,020 --> 00:29:41,460
alright so let's talk about fuzzing

791
00:29:38,360 --> 00:29:42,990
while symbolic execution is sort of

792
00:29:41,460 --> 00:29:46,470
intellectually very nice it's like oh

793
00:29:42,990 --> 00:29:48,390
that's a reason about values so fuzzing

794
00:29:46,470 --> 00:29:50,010
essentially is you're throwing a ton of

795
00:29:48,390 --> 00:29:52,520
input at something and seeing what

796
00:29:50,010 --> 00:29:54,090
crashes so there's three main approach

797
00:29:52,520 --> 00:29:57,680
approaches that were going to talk about

798
00:29:54,090 --> 00:30:00,000
and each have strengths and weaknesses

799
00:29:57,680 --> 00:30:01,620
so the first is a mutation based

800
00:30:00,000 --> 00:30:03,990
approach so we're starting with some

801
00:30:01,620 --> 00:30:05,760
known good inputs that we've seen as

802
00:30:03,990 --> 00:30:08,670
applied to the program this is our input

803
00:30:05,760 --> 00:30:10,290
corpus and then we're gonna choose a way

804
00:30:08,670 --> 00:30:12,390
to mutate this input into something that

805
00:30:10,290 --> 00:30:13,920
ideally is going to get a crash or other

806
00:30:12,390 --> 00:30:15,930
interesting behavior from the target

807
00:30:13,920 --> 00:30:18,590
program so this mutation could be

808
00:30:15,930 --> 00:30:22,800
flipping bits injecting random bytes

809
00:30:18,590 --> 00:30:24,449
that we think like no bytes or new lines

810
00:30:22,800 --> 00:30:26,790
or just things that we think will cause

811
00:30:24,450 --> 00:30:28,440
problems and then once we've mutated the

812
00:30:26,790 --> 00:30:31,440
known good input we then give it to the

813
00:30:28,440 --> 00:30:33,060
application and observe what happens so

814
00:30:31,440 --> 00:30:34,920
the nice thing about this approach is

815
00:30:33,060 --> 00:30:36,179
it's very easy to get started you don't

816
00:30:34,920 --> 00:30:39,270
necessarily need to have any knowledge

817
00:30:36,180 --> 00:30:41,910
at all about the input structure headed

818
00:30:39,270 --> 00:30:43,680
to the program but the challenge here is

819
00:30:41,910 --> 00:30:46,650
it can be tough to find non surface

820
00:30:43,680 --> 00:30:48,120
level bugs so let's say the initial part

821
00:30:46,650 --> 00:30:50,820
of the program does some complicated

822
00:30:48,120 --> 00:30:51,870
vetting of the input before it gets to

823
00:30:50,820 --> 00:30:54,689
any of the interesting functionality

824
00:30:51,870 --> 00:30:56,820
unless your input satisfies all those

825
00:30:54,690 --> 00:30:58,310
properties you can't necessarily hit the

826
00:30:56,820 --> 00:31:02,120
deeper code that you

827
00:30:58,310 --> 00:31:05,570
one two okay so the another fuzzing

828
00:31:02,120 --> 00:31:07,250
approach is generation based so here you

829
00:31:05,570 --> 00:31:09,409
were defining a specification for how

830
00:31:07,250 --> 00:31:11,960
input should be structured so for

831
00:31:09,410 --> 00:31:12,740
example for a network packet we could

832
00:31:11,960 --> 00:31:14,810
say okay

833
00:31:12,740 --> 00:31:16,010
this many bytes is this header and then

834
00:31:14,810 --> 00:31:17,270
we have a length field and then we have

835
00:31:16,010 --> 00:31:19,460
a checksum and different things like

836
00:31:17,270 --> 00:31:22,160
that and then we are going to define a

837
00:31:19,460 --> 00:31:24,290
list of bad values for each data type in

838
00:31:22,160 --> 00:31:25,910
this input specification we're then

839
00:31:24,290 --> 00:31:28,700
going to generate all possible inputs

840
00:31:25,910 --> 00:31:31,220
for the structure using bad values and

841
00:31:28,700 --> 00:31:32,690
then again send them to the program so

842
00:31:31,220 --> 00:31:35,030
what's nice here is because we are

843
00:31:32,690 --> 00:31:38,390
codifying a specification for how the

844
00:31:35,030 --> 00:31:40,010
input should be structured we can in

845
00:31:38,390 --> 00:31:42,920
theory get very deep coverage here

846
00:31:40,010 --> 00:31:45,830
because we're providing input that will

847
00:31:42,920 --> 00:31:47,990
be accepted by the program this can also

848
00:31:45,830 --> 00:31:50,000
handle complex input types with

849
00:31:47,990 --> 00:31:52,520
dependencies so we could have a very

850
00:31:50,000 --> 00:31:54,530
complex data structure each of which or

851
00:31:52,520 --> 00:31:57,050
has a series of nested components which

852
00:31:54,530 --> 00:31:59,180
we also specify how they should look so

853
00:31:57,050 --> 00:32:00,980
we can get great coverage this way but

854
00:31:59,180 --> 00:32:02,420
the negative here is that it can require

855
00:32:00,980 --> 00:32:04,730
deep understanding of the input or

856
00:32:02,420 --> 00:32:06,470
protocol so it with the mutation based

857
00:32:04,730 --> 00:32:08,090
approach we could just sort of throw

858
00:32:06,470 --> 00:32:09,830
something at it and then hopefully get

859
00:32:08,090 --> 00:32:14,360
some value here we need to do upfront

860
00:32:09,830 --> 00:32:16,129
work to figure out how exactly to

861
00:32:14,360 --> 00:32:18,139
specify the input to the program and

862
00:32:16,130 --> 00:32:20,840
here's an example from Buffa's where

863
00:32:18,140 --> 00:32:23,030
we're saying if we're fuzzing FTP we

864
00:32:20,840 --> 00:32:26,360
have this string user and then a space

865
00:32:23,030 --> 00:32:28,670
and then some user name and so forth so

866
00:32:26,360 --> 00:32:29,240
again mutation is we're just randomly

867
00:32:28,670 --> 00:32:31,310
mutating

868
00:32:29,240 --> 00:32:33,200
the input and seeing what happens here

869
00:32:31,310 --> 00:32:34,460
we're saying this is what the the

870
00:32:33,200 --> 00:32:36,410
structure of the input should look like

871
00:32:34,460 --> 00:32:40,640
at a high level and then tweak it based

872
00:32:36,410 --> 00:32:43,580
on the specification we've defined okay

873
00:32:40,640 --> 00:32:46,100
so the final approach is evolution based

874
00:32:43,580 --> 00:32:47,810
so this is sort of taking the original

875
00:32:46,100 --> 00:32:50,300
mutation approach and taking a one step

876
00:32:47,810 --> 00:32:52,429
further so again we have a known good

877
00:32:50,300 --> 00:32:54,110
input corpus which we're going to mutate

878
00:32:52,430 --> 00:32:56,870
in some way but this time we're going to

879
00:32:54,110 --> 00:32:59,090
monitor execution of the program for

880
00:32:56,870 --> 00:33:00,949
some property generally we're looking at

881
00:32:59,090 --> 00:33:02,870
code coverage because the more of the

882
00:33:00,950 --> 00:33:04,430
program were executing the more likely

883
00:33:02,870 --> 00:33:06,949
we are to get to part of the program

884
00:33:04,430 --> 00:33:09,380
where there may be bugs so rather than

885
00:33:06,950 --> 00:33:11,840
targeting just one narrow part of the

886
00:33:09,380 --> 00:33:13,400
code we're going to prioritize

887
00:33:11,840 --> 00:33:16,309
inputs that we mutate and get us

888
00:33:13,400 --> 00:33:18,799
somewhere else because that's exciting

889
00:33:16,309 --> 00:33:21,590
so as we mutate when we find input that

890
00:33:18,799 --> 00:33:22,820
gets us to better code coverage let's

891
00:33:21,590 --> 00:33:24,918
add that back into the input and then

892
00:33:22,820 --> 00:33:27,200
keep mutating it to see if we can spread

893
00:33:24,919 --> 00:33:29,059
more and more so this can actually be

894
00:33:27,200 --> 00:33:30,740
incredibly effective at finding bugs one

895
00:33:29,059 --> 00:33:32,450
of the most popular versions of this

896
00:33:30,740 --> 00:33:35,419
right now is called an American fuzzy

897
00:33:32,450 --> 00:33:38,570
lop or a FL which is found a ton of bugs

898
00:33:35,419 --> 00:33:40,070
in many many different applications and

899
00:33:38,570 --> 00:33:43,820
this can actually even find very hard to

900
00:33:40,070 --> 00:33:45,799
reach code paths one downside of this is

901
00:33:43,820 --> 00:33:47,240
to get maximum value oftentimes you need

902
00:33:45,799 --> 00:33:49,490
the source code so that you can

903
00:33:47,240 --> 00:33:50,840
instrument it and you also are going to

904
00:33:49,490 --> 00:33:52,429
have to do a little bit of upfront work

905
00:33:50,840 --> 00:33:54,559
in terms of building test harnesses

906
00:33:52,429 --> 00:33:55,929
which say okay so we have this

907
00:33:54,559 --> 00:33:58,610
complicated program there are several

908
00:33:55,929 --> 00:34:00,890
functional regions each of which do

909
00:33:58,610 --> 00:34:02,539
different sort of things you might want

910
00:34:00,890 --> 00:34:04,250
to build a test harness such that you're

911
00:34:02,539 --> 00:34:05,510
calling into each functional part so

912
00:34:04,250 --> 00:34:09,770
that you can make sure that the fuzzer

913
00:34:05,510 --> 00:34:12,260
can get to each part okay so what are

914
00:34:09,770 --> 00:34:13,310
some strengths of fuzzing depending on

915
00:34:12,260 --> 00:34:16,070
what type you're doing it can be very

916
00:34:13,310 --> 00:34:18,440
fast to get set up so this is nice

917
00:34:16,070 --> 00:34:21,109
even though conceptually fuzzing seems

918
00:34:18,440 --> 00:34:24,230
very simple it is incredibly effective

919
00:34:21,109 --> 00:34:25,730
at finding bugs in many cases it's also

920
00:34:24,230 --> 00:34:27,530
nice because you can just let it run

921
00:34:25,730 --> 00:34:30,020
continuously and then triage the crashes

922
00:34:27,530 --> 00:34:31,369
as they come so you can be doing manual

923
00:34:30,020 --> 00:34:32,629
penetration testing or doing other stuff

924
00:34:31,369 --> 00:34:35,330
and just sort of let this run in the

925
00:34:32,629 --> 00:34:37,339
background and it's also very nice on C

926
00:34:35,330 --> 00:34:39,500
and C++ code bases so looking for a

927
00:34:37,339 --> 00:34:41,739
memory corruptions and types of issues

928
00:34:39,500 --> 00:34:41,739
like that

929
00:34:41,980 --> 00:34:47,359
okay so what's hard for fuzzing again

930
00:34:45,168 --> 00:34:50,509
code coverage as with many and dynamic

931
00:34:47,359 --> 00:34:52,549
analysis approaches it's fundamentally

932
00:34:50,510 --> 00:34:55,010
hard so when you're fuzzing you can very

933
00:34:52,550 --> 00:34:57,020
quickly get to some place in the program

934
00:34:55,010 --> 00:34:59,300
and sort of navigate around in that

935
00:34:57,020 --> 00:35:01,609
space but you may get stuck in this

936
00:34:59,300 --> 00:35:03,230
space and you're not hitting a bridge

937
00:35:01,609 --> 00:35:05,869
that's enabling you to test another big

938
00:35:03,230 --> 00:35:07,220
part of the code so if your initial

939
00:35:05,869 --> 00:35:08,900
input has some sort of complicated

940
00:35:07,220 --> 00:35:11,060
structure maybe there's check sums or a

941
00:35:08,900 --> 00:35:12,380
length field and those are checked

942
00:35:11,060 --> 00:35:14,359
immediately and if you don't pass them

943
00:35:12,380 --> 00:35:17,119
then you never get anywhere this can be

944
00:35:14,359 --> 00:35:18,529
tough unless you're you know specifying

945
00:35:17,119 --> 00:35:21,200
a specification for the input ahead of

946
00:35:18,530 --> 00:35:24,080
time and again deep nested conditionals

947
00:35:21,200 --> 00:35:25,609
or very complex program state may make

948
00:35:24,080 --> 00:35:30,799
it difficult for you to reach

949
00:35:25,609 --> 00:35:32,420
program points to fuzz various stateful

950
00:35:30,799 --> 00:35:35,359
protocols or fuzzing network services

951
00:35:32,420 --> 00:35:36,739
can be challenging and again complicated

952
00:35:35,359 --> 00:35:39,078
input formats or protocols you might

953
00:35:36,739 --> 00:35:41,180
need to codify some knowledge upfront in

954
00:35:39,079 --> 00:35:42,710
a fundamental open question is how much

955
00:35:41,180 --> 00:35:44,390
fuzzing is good enough right you could

956
00:35:42,710 --> 00:35:46,819
just keep fuzzing until the Sun burns

957
00:35:44,390 --> 00:35:49,578
out but this may not be a good use of

958
00:35:46,819 --> 00:35:51,650
your time right so generally what people

959
00:35:49,579 --> 00:35:53,210
do is fuzz for a while until you're not

960
00:35:51,650 --> 00:35:55,999
getting any new branches covered that

961
00:35:53,210 --> 00:35:59,509
you haven't seen already but determining

962
00:35:55,999 --> 00:36:01,759
this in general is an open problem so

963
00:35:59,509 --> 00:36:04,190
here's a couple of links to fuzzers of

964
00:36:01,759 --> 00:36:06,710
different types so some mutation ones

965
00:36:04,190 --> 00:36:07,789
some generation ones and if you want to

966
00:36:06,710 --> 00:36:10,640
play around with this I would encourage

967
00:36:07,789 --> 00:36:12,259
you to look at AFL or Lib buzzer those

968
00:36:10,640 --> 00:36:14,150
are very popular ones right now and

969
00:36:12,259 --> 00:36:18,739
there's a couple of other miscellaneous

970
00:36:14,150 --> 00:36:21,950
ones related to fuzzing etherium or like

971
00:36:18,739 --> 00:36:24,849
the Dom for testing browsers and even

972
00:36:21,950 --> 00:36:27,710
some fuzzing some dotnet toolchains

973
00:36:24,849 --> 00:36:28,880
again there's hundreds or thousands of

974
00:36:27,710 --> 00:36:36,499
blog posts and good talks on these

975
00:36:28,880 --> 00:36:38,539
here's just a few we recommend so we

976
00:36:36,499 --> 00:36:40,910
mentioned that fuzzing has a problem

977
00:36:38,539 --> 00:36:44,329
with deep nested conditionals and

978
00:36:40,910 --> 00:36:45,828
reaching hard-to-reach paths in a

979
00:36:44,329 --> 00:36:48,440
program well we just talked about

980
00:36:45,829 --> 00:36:50,630
something that is good at handling deep

981
00:36:48,440 --> 00:36:53,059
nested conditionals and so really what

982
00:36:50,630 --> 00:36:54,920
the state of the art here is if you take

983
00:36:53,059 --> 00:36:57,220
fuzzing and you combine it with some

984
00:36:54,920 --> 00:37:00,079
Baalak execution the observation is that

985
00:36:57,220 --> 00:37:01,459
the code paths that fuzzing covers and

986
00:37:00,079 --> 00:37:05,029
the code paths that symbolic execution

987
00:37:01,460 --> 00:37:08,359
covers are complimentary right so

988
00:37:05,029 --> 00:37:12,680
fuzzing tends to be extremely fast at

989
00:37:08,359 --> 00:37:14,960
covering bugs that it can reach right so

990
00:37:12,680 --> 00:37:18,200
it will explore some compartments of the

991
00:37:14,960 --> 00:37:22,160
code very rapidly but if you have some

992
00:37:18,200 --> 00:37:25,578
if statement that is complex random

993
00:37:22,160 --> 00:37:27,558
mutation can be difficult to cross that

994
00:37:25,579 --> 00:37:29,539
but we have something symbolic execution

995
00:37:27,559 --> 00:37:31,819
and constraint solvers that are very

996
00:37:29,539 --> 00:37:34,579
good at crossing complex constraints

997
00:37:31,819 --> 00:37:36,410
they're slow in small areas so they're

998
00:37:34,579 --> 00:37:38,910
not as fast as fuzzing as covering code

999
00:37:36,410 --> 00:37:41,640
but if you get a fuzzer that is stuck

1000
00:37:38,910 --> 00:37:44,220
what you can do is then use a symbolic

1001
00:37:41,640 --> 00:37:47,400
execution engine to cross that boundary

1002
00:37:44,220 --> 00:37:54,299
and then keep fuzzing so this is what

1003
00:37:47,400 --> 00:37:55,619
people do nowadays so if you look at the

1004
00:37:54,299 --> 00:37:59,220
cyber Grand Challenge for example so

1005
00:37:55,619 --> 00:38:02,220
DARPA ran a challenge to try to build

1006
00:37:59,220 --> 00:38:05,759
automated tools to compete in binary

1007
00:38:02,220 --> 00:38:08,160
analysis of DEFCON style CTF and pretty

1008
00:38:05,760 --> 00:38:09,930
much everybody who did well in that

1009
00:38:08,160 --> 00:38:11,520
challenge and rank high early used some

1010
00:38:09,930 --> 00:38:14,669
kind of combination of symbolic

1011
00:38:11,520 --> 00:38:17,460
execution and fuzzing so this this is

1012
00:38:14,670 --> 00:38:19,650
what for automated bug finding is sort

1013
00:38:17,460 --> 00:38:21,390
of state-of-the-art here are some

1014
00:38:19,650 --> 00:38:24,089
resources if you want to look at that in

1015
00:38:21,390 --> 00:38:26,279
more detail in particular I would highly

1016
00:38:24,089 --> 00:38:27,569
recommend looking at driller augmenting

1017
00:38:26,280 --> 00:38:30,599
fuzzing through selective symbolic

1018
00:38:27,569 --> 00:38:32,339
execution but there it has become very

1019
00:38:30,599 --> 00:38:34,200
popular and is now sort of the de-facto

1020
00:38:32,339 --> 00:38:37,308
technique for if you want to find bugs

1021
00:38:34,200 --> 00:38:37,308
particularly in binaries

1022
00:38:39,880 --> 00:38:44,770
yeah so just quickly some other related

1023
00:38:42,640 --> 00:38:46,480
work we've been talking about sort of

1024
00:38:44,770 --> 00:38:48,340
the core fundamental principle is about

1025
00:38:46,480 --> 00:38:51,250
of a number of analysis techniques

1026
00:38:48,340 --> 00:38:53,260
there's been some other work in looking

1027
00:38:51,250 --> 00:38:54,730
at how our company is actually using

1028
00:38:53,260 --> 00:38:58,230
this in practice how do you integrate it

1029
00:38:54,730 --> 00:39:00,430
into the SCLC so the first one is a

1030
00:38:58,230 --> 00:39:02,650
shameless plug for something I did

1031
00:39:00,430 --> 00:39:04,180
earlier where I basically talked with a

1032
00:39:02,650 --> 00:39:06,310
number of different companies who are

1033
00:39:04,180 --> 00:39:08,649
trying to scale their internal security

1034
00:39:06,310 --> 00:39:10,029
efforts using automation and I talked

1035
00:39:08,650 --> 00:39:12,040
about a number of different ways that

1036
00:39:10,030 --> 00:39:14,170
they found that is helpful some that

1037
00:39:12,040 --> 00:39:15,580
aren't and just generally what's a good

1038
00:39:14,170 --> 00:39:17,140
use of their time and then Zane Lackey

1039
00:39:15,580 --> 00:39:24,430
also has a very excellent talk in this

1040
00:39:17,140 --> 00:39:26,230
space as well so what do we get out of

1041
00:39:24,430 --> 00:39:30,460
it what's the end so what do we take

1042
00:39:26,230 --> 00:39:33,670
away from all this so the first thing to

1043
00:39:30,460 --> 00:39:35,410
note is that none of this talks about

1044
00:39:33,670 --> 00:39:37,690
finding business logic flaws if you have

1045
00:39:35,410 --> 00:39:39,640
something more subtle where you have

1046
00:39:37,690 --> 00:39:41,290
some specification about how your

1047
00:39:39,640 --> 00:39:43,240
application is supposed to operate the

1048
00:39:41,290 --> 00:39:45,000
business logic level these things won't

1049
00:39:43,240 --> 00:39:47,229
by default be able to find that right

1050
00:39:45,000 --> 00:39:51,550
and so you would have to build to teach

1051
00:39:47,230 --> 00:39:54,010
it what you're looking for second thing

1052
00:39:51,550 --> 00:39:55,720
to note is that a lot of this stuff has

1053
00:39:54,010 --> 00:39:58,210
required a huge amount of effort to

1054
00:39:55,720 --> 00:40:00,160
build and while it can be fun and an

1055
00:39:58,210 --> 00:40:01,570
interesting hobby project to try and

1056
00:40:00,160 --> 00:40:03,759
roll one of these from scratch in

1057
00:40:01,570 --> 00:40:06,760
practice you really really don't want to

1058
00:40:03,760 --> 00:40:08,710
do that so find a tool customize an

1059
00:40:06,760 --> 00:40:11,320
existing tool but you probably don't

1060
00:40:08,710 --> 00:40:13,420
want to go all the way from I am parsing

1061
00:40:11,320 --> 00:40:14,950
source code to an ast to writing a

1062
00:40:13,420 --> 00:40:17,710
symbolic execution engine it's just

1063
00:40:14,950 --> 00:40:19,660
going to take too long and there's no

1064
00:40:17,710 --> 00:40:22,900
silver bullet here like none of these

1065
00:40:19,660 --> 00:40:24,310
things will find everything it's really

1066
00:40:22,900 --> 00:40:25,660
important to understand what the

1067
00:40:24,310 --> 00:40:28,180
strengths and weaknesses are of every

1068
00:40:25,660 --> 00:40:29,770
technique because some techniques will

1069
00:40:28,180 --> 00:40:33,299
just completely fail at finding uh some

1070
00:40:29,770 --> 00:40:38,050
class of bugs and so it's important to

1071
00:40:33,300 --> 00:40:40,750
choose appropriately so static taint

1072
00:40:38,050 --> 00:40:42,700
analysis is really good for large code

1073
00:40:40,750 --> 00:40:46,180
bases I mean one of the advantage is is

1074
00:40:42,700 --> 00:40:49,149
that it can cover large amounts of code

1075
00:40:46,180 --> 00:40:51,250
relatively quickly and but you have to

1076
00:40:49,150 --> 00:40:53,110
be willing to invest time in tuning and

1077
00:40:51,250 --> 00:40:53,560
triage in your tools if you just run any

1078
00:40:53,110 --> 00:40:54,940
static

1079
00:40:53,560 --> 00:40:58,090
analysis tool which most of you probably

1080
00:40:54,940 --> 00:41:00,340
know this it will fire up this tons of

1081
00:40:58,090 --> 00:41:01,990
false positives and you have to deal

1082
00:41:00,340 --> 00:41:04,720
with this and so you have to be willing

1083
00:41:01,990 --> 00:41:07,149
to invest the time upfront to tune it to

1084
00:41:04,720 --> 00:41:09,009
add the sanitizers before you really

1085
00:41:07,150 --> 00:41:11,170
start to get value out of that it's not

1086
00:41:09,010 --> 00:41:12,580
going to be as good for dynamic

1087
00:41:11,170 --> 00:41:14,230
languages probably there's a lot of

1088
00:41:12,580 --> 00:41:16,350
research in this area but generally

1089
00:41:14,230 --> 00:41:19,420
tools are not very good at handling

1090
00:41:16,350 --> 00:41:20,500
languages with dynamic features it's not

1091
00:41:19,420 --> 00:41:22,510
going to be very good with micro

1092
00:41:20,500 --> 00:41:25,810
services usually if you have lots of

1093
00:41:22,510 --> 00:41:28,320
data that's crossing api's it's going to

1094
00:41:25,810 --> 00:41:30,850
have a trouble tracking all of that and

1095
00:41:28,320 --> 00:41:34,030
finally because of the false positive

1096
00:41:30,850 --> 00:41:36,100
rates generally epic teams tend to hate

1097
00:41:34,030 --> 00:41:37,900
them and you're going to have problems

1098
00:41:36,100 --> 00:41:39,970
if you have a very small team and don't

1099
00:41:37,900 --> 00:41:43,450
have the amount of time it takes to tune

1100
00:41:39,970 --> 00:41:45,819
these and go through the results dynamic

1101
00:41:43,450 --> 00:41:48,250
taint analysis is great if you control

1102
00:41:45,820 --> 00:41:50,170
the binaries on the platform that it's

1103
00:41:48,250 --> 00:41:52,330
running on if you can build it and you

1104
00:41:50,170 --> 00:41:54,490
can run it and if you're interested in

1105
00:41:52,330 --> 00:41:56,799
information leakage or that sort of

1106
00:41:54,490 --> 00:41:59,529
taint analysis style problems it's not

1107
00:41:56,800 --> 00:42:01,480
going to be very good if your input is

1108
00:41:59,530 --> 00:42:02,950
just sort of the application is

1109
00:42:01,480 --> 00:42:05,230
structured in a way that input is gonna

1110
00:42:02,950 --> 00:42:07,870
go through bottlenecks and start

1111
00:42:05,230 --> 00:42:10,500
tainting everything so you have to look

1112
00:42:07,870 --> 00:42:12,520
at how your application is handling data

1113
00:42:10,500 --> 00:42:16,780
symbolic execution is great if you

1114
00:42:12,520 --> 00:42:19,210
actually need an input to generate and

1115
00:42:16,780 --> 00:42:20,650
to reproduce the bug it's great for

1116
00:42:19,210 --> 00:42:23,980
solving complex and getting to deep

1117
00:42:20,650 --> 00:42:25,900
places in the program but it can't

1118
00:42:23,980 --> 00:42:29,080
handle and scale to something that's

1119
00:42:25,900 --> 00:42:30,280
that's a very large code base fuzzing is

1120
00:42:29,080 --> 00:42:31,630
great if particularly if you have

1121
00:42:30,280 --> 00:42:35,920
languages where you're looking for

1122
00:42:31,630 --> 00:42:37,420
memory corruption and a very popular

1123
00:42:35,920 --> 00:42:38,710
target is parsing code if you have a

1124
00:42:37,420 --> 00:42:40,860
parser somewhere in your code you

1125
00:42:38,710 --> 00:42:43,570
probably want to fuzz it please fuzz it

1126
00:42:40,860 --> 00:42:44,920
and it's also really nice if you happen

1127
00:42:43,570 --> 00:42:47,290
to have a cluster of computers sitting

1128
00:42:44,920 --> 00:42:49,270
around your life will be much easier but

1129
00:42:47,290 --> 00:42:52,720
if you have complex stateful protocols

1130
00:42:49,270 --> 00:42:55,090
very complex inputs or complex logic and

1131
00:42:52,720 --> 00:42:56,500
then it's going to be time-consuming to

1132
00:42:55,090 --> 00:42:59,490
set up the harmonies that are required

1133
00:42:56,500 --> 00:42:59,490
to fuzz your program

1134
00:43:00,789 --> 00:43:05,150
all right thank you very much for your

1135
00:43:03,109 --> 00:43:06,920
time if you find these types of things

1136
00:43:05,150 --> 00:43:09,470
interesting we're going to be writing a

1137
00:43:06,920 --> 00:43:13,940
number of blog posts and other things on

1138
00:43:09,470 --> 00:43:15,230
our website or post to our Twitter we're

1139
00:43:13,940 --> 00:43:17,000
going to look at ideally a number of

1140
00:43:15,230 --> 00:43:20,119
different open source tools and see when

1141
00:43:17,000 --> 00:43:21,680
do they do well what causes them to

1142
00:43:20,119 --> 00:43:23,210
struggle like a bunch of different

1143
00:43:21,680 --> 00:43:25,149
static analysis tools poor language and

1144
00:43:23,210 --> 00:43:27,260
a number of different things like that

1145
00:43:25,150 --> 00:43:34,010
yeah we have a few minutes for any

1146
00:43:27,260 --> 00:43:38,359
questions yeah yes we will make these

1147
00:43:34,010 --> 00:43:39,920
slides available yeah because we wanted

1148
00:43:38,359 --> 00:43:41,808
to link to a bunch of things which you

1149
00:43:39,920 --> 00:43:45,130
can go to after yeah

1150
00:43:41,809 --> 00:43:45,130
any other questions yes

1151
00:43:58,170 --> 00:44:02,220
okay the question is do we have any

1152
00:44:00,580 --> 00:44:04,240
thoughts or recommendations for

1153
00:44:02,220 --> 00:44:07,470
targeting micro-services without

1154
00:44:04,240 --> 00:44:09,609
necessarily writing customizations to

1155
00:44:07,470 --> 00:44:14,709
describe how they work across API

1156
00:44:09,610 --> 00:44:16,600
boundaries I think the answer to that in

1157
00:44:14,710 --> 00:44:18,220
general I don't think there's any

1158
00:44:16,600 --> 00:44:21,339
approach that handles that particularly

1159
00:44:18,220 --> 00:44:22,660
well so in theory if you had the code

1160
00:44:21,340 --> 00:44:24,340
for all of the different micro

1161
00:44:22,660 --> 00:44:26,109
architecture or all of the micro

1162
00:44:24,340 --> 00:44:28,810
services you could try to infer the

1163
00:44:26,110 --> 00:44:31,390
different routes and then connect them

1164
00:44:28,810 --> 00:44:32,799
that way but I think this is honestly an

1165
00:44:31,390 --> 00:44:36,279
open research question that I don't

1166
00:44:32,800 --> 00:44:39,190
think anyone tackles super well yeah do

1167
00:44:36,280 --> 00:44:41,440
you have any yeah it's that without

1168
00:44:39,190 --> 00:44:42,880
customization and early understanding

1169
00:44:41,440 --> 00:44:45,310
part that you tacked on the at the end

1170
00:44:42,880 --> 00:44:47,470
that I think makes it tough it's so if

1171
00:44:45,310 --> 00:44:49,390
you control all the micro services and

1172
00:44:47,470 --> 00:44:52,810
you you could just treat this as an

1173
00:44:49,390 --> 00:44:54,100
aggregate analysis problem and so

1174
00:44:52,810 --> 00:44:56,110
there's not too much difference in a

1175
00:44:54,100 --> 00:44:59,860
micro service architecture from calling

1176
00:44:56,110 --> 00:45:02,230
between modules or something and in an

1177
00:44:59,860 --> 00:45:04,090
RPC call or some sort of API call so in

1178
00:45:02,230 --> 00:45:06,250
theory it's not shouldn't be much

1179
00:45:04,090 --> 00:45:08,980
different in practice it can be tricky

1180
00:45:06,250 --> 00:45:12,120
and so there's no we don't have

1181
00:45:08,980 --> 00:45:12,120
excellent solutions for you

1182
00:45:19,039 --> 00:45:22,039
does

1183
00:45:27,150 --> 00:45:31,810
and it might depend on what you're

1184
00:45:29,140 --> 00:45:34,690
looking for so you might be able to do

1185
00:45:31,810 --> 00:45:36,610
some sort of dynamic taint technique

1186
00:45:34,690 --> 00:45:40,360
where you have to then instrument and

1187
00:45:36,610 --> 00:45:42,540
modify how the API is used and just then

1188
00:45:40,360 --> 00:45:46,360
propagate across

1189
00:45:42,540 --> 00:45:48,130
micro-services but it certainly it gets

1190
00:45:46,360 --> 00:45:50,970
trickier micro-services are definitely a

1191
00:45:48,130 --> 00:45:50,970
more difficult problem

1192
00:45:52,050 --> 00:46:02,290
yeah any final questions okay cool feel

1193
00:46:00,040 --> 00:46:04,090
to feel free to come up after and chat

1194
00:46:02,290 --> 00:46:06,660
we'd love to talk about this and thanks

1195
00:46:04,090 --> 00:46:06,660
again for your time

1196
00:46:07,710 --> 00:46:13,449
[Applause]

