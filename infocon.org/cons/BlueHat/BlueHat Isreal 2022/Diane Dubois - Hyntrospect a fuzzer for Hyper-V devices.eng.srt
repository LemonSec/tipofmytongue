1
00:00:00,930 --> 00:00:08,260
[Music]

2
00:00:12,310 --> 00:00:17,920
[Music]

3
00:00:17,920 --> 00:00:20,000
hi everyone thank you for joining this

4
00:00:20,000 --> 00:00:22,000
talk on fuzzing hyper-v microsoft

5
00:00:22,000 --> 00:00:23,519
hypervisor

6
00:00:23,519 --> 00:00:24,640
i'm going with

7
00:00:24,640 --> 00:00:27,119
to start with a few words um introduce

8
00:00:27,119 --> 00:00:28,880
myself a few more words because you know

9
00:00:28,880 --> 00:00:31,519
the most important part obviously

10
00:00:31,519 --> 00:00:33,760
so i'm a security engineer i work at

11
00:00:33,760 --> 00:00:36,000
google

12
00:00:36,000 --> 00:00:37,280
i'm passionate about vulnerability

13
00:00:37,280 --> 00:00:40,399
research on low-level layers systems

14
00:00:40,399 --> 00:00:42,000
also i'm an active member of women's

15
00:00:42,000 --> 00:00:44,800
security networks like blackhoody.re

16
00:00:44,800 --> 00:00:47,360
like note for the women in the room

17
00:00:47,360 --> 00:00:49,039
and the research project that i'm going

18
00:00:49,039 --> 00:00:50,879
to present was done as a twenty person

19
00:00:50,879 --> 00:00:53,440
project with project zero so a twenty

20
00:00:53,440 --> 00:00:54,960
percent tell google is the opportunity

21
00:00:54,960 --> 00:00:56,879
we have to spend up to twenty percent of

22
00:00:56,879 --> 00:00:59,520
our time on the project of our choice

23
00:00:59,520 --> 00:01:03,120
other than our primary projects

24
00:01:03,920 --> 00:01:06,479
so the first question you may wonder is

25
00:01:06,479 --> 00:01:09,600
as a googler why choose hyper-v that

26
00:01:09,600 --> 00:01:11,040
might sound a little bit

27
00:01:11,040 --> 00:01:12,720
counter-intuitive

28
00:01:12,720 --> 00:01:14,320
so first it is aligned with project zero

29
00:01:14,320 --> 00:01:15,920
mission

30
00:01:15,920 --> 00:01:17,840
beyond that

31
00:01:17,840 --> 00:01:20,159
also hyper-v is

32
00:01:20,159 --> 00:01:21,360
a key

33
00:01:21,360 --> 00:01:22,720
target

34
00:01:22,720 --> 00:01:25,119
for security researchers because it is

35
00:01:25,119 --> 00:01:27,200
the hypervisor running azure

36
00:01:27,200 --> 00:01:28,799
microsoft cloud

37
00:01:28,799 --> 00:01:31,200
and it's also running on all the modern

38
00:01:31,200 --> 00:01:33,520
version of windows

39
00:01:33,520 --> 00:01:34,400
because of the feature of

40
00:01:34,400 --> 00:01:36,720
virtualization-based security

41
00:01:36,720 --> 00:01:38,720
it can run on modern versions of windows

42
00:01:38,720 --> 00:01:39,680
so

43
00:01:39,680 --> 00:01:43,680
any zero day may have a huge impact

44
00:01:43,680 --> 00:01:45,280
and that's why it's a particular

45
00:01:45,280 --> 00:01:47,439
interesting target for researchers

46
00:01:47,439 --> 00:01:50,000
beyond that at a personal level

47
00:01:50,000 --> 00:01:51,600
virtualization is

48
00:01:51,600 --> 00:01:54,000
particularly fun because it covers

49
00:01:54,000 --> 00:01:55,439
several layers

50
00:01:55,439 --> 00:01:57,360
it's endless

51
00:01:57,360 --> 00:01:59,360
analysis topics so

52
00:01:59,360 --> 00:02:01,280
really fun to work on that like

53
00:02:01,280 --> 00:02:04,640
yeah nice playground

54
00:02:05,040 --> 00:02:08,160
so the goals of the research was to find

55
00:02:08,160 --> 00:02:10,720
vulnerabilities on hyper-v report and to

56
00:02:10,720 --> 00:02:12,080
microsoft

57
00:02:12,080 --> 00:02:14,000
and the strategy to do so was to

58
00:02:14,000 --> 00:02:16,160
instrument hyper-v for vulnerability

59
00:02:16,160 --> 00:02:18,319
research and to do so a feather was

60
00:02:18,319 --> 00:02:20,720
written it's called introspect here is

61
00:02:20,720 --> 00:02:22,959
the link it's open source

62
00:02:22,959 --> 00:02:24,319
in a few words

63
00:02:24,319 --> 00:02:26,560
it's covering part of hyper-v

64
00:02:26,560 --> 00:02:28,080
the approach that was taken is very

65
00:02:28,080 --> 00:02:30,720
pragmatic i'm going to explain why

66
00:02:30,720 --> 00:02:32,480
because there are a few constraints also

67
00:02:32,480 --> 00:02:36,280
that i had to work around

68
00:02:36,480 --> 00:02:37,840
so first i'm going to cover some

69
00:02:37,840 --> 00:02:39,840
background on hyper-v

70
00:02:39,840 --> 00:02:41,760
then i'm going to talk about the

71
00:02:41,760 --> 00:02:44,000
research target that i chose

72
00:02:44,000 --> 00:02:45,599
the fuzzer itself and then i will

73
00:02:45,599 --> 00:02:47,360
present the results

74
00:02:47,360 --> 00:02:50,879
and eventually the future endeavors

75
00:02:50,879 --> 00:02:53,360
okay so first some background i want

76
00:02:53,360 --> 00:02:55,599
everybody to be on the same page to

77
00:02:55,599 --> 00:02:57,040
start with so

78
00:02:57,040 --> 00:02:59,280
let's get started with what hyper-v

79
00:02:59,280 --> 00:03:00,959
looks like

80
00:03:00,959 --> 00:03:02,640
yeah i'm not going to explain everything

81
00:03:02,640 --> 00:03:04,879
don't worry let's get to the most

82
00:03:04,879 --> 00:03:06,319
essential parts so

83
00:03:06,319 --> 00:03:08,720
to start with hyper-v is a hypervisor

84
00:03:08,720 --> 00:03:10,560
type 1 hypervisor

85
00:03:10,560 --> 00:03:11,920
which means

86
00:03:11,920 --> 00:03:13,840
it's the equivalent of an operating

87
00:03:13,840 --> 00:03:16,800
system running directly on hardware

88
00:03:16,800 --> 00:03:17,599
to

89
00:03:17,599 --> 00:03:18,400
run

90
00:03:18,400 --> 00:03:21,360
several virtual machines or vms

91
00:03:21,360 --> 00:03:23,440
and virtualize environments

92
00:03:23,440 --> 00:03:25,519
so here the hypervisor is there on the

93
00:03:25,519 --> 00:03:27,280
stack

94
00:03:27,280 --> 00:03:28,080
and

95
00:03:28,080 --> 00:03:30,560
hyper-v has a specific structure it

96
00:03:30,560 --> 00:03:32,640
differs from other hypervisors

97
00:03:32,640 --> 00:03:35,280
because it has a privileged vm which is

98
00:03:35,280 --> 00:03:36,959
called the root partition

99
00:03:36,959 --> 00:03:38,720
and the virtualization is not only

100
00:03:38,720 --> 00:03:41,760
implemented in the hypervisor but also

101
00:03:41,760 --> 00:03:44,720
in the root partition

102
00:03:45,040 --> 00:03:47,680
and as opposed to that we we talk about

103
00:03:47,680 --> 00:03:50,080
child partition children partitions

104
00:03:50,080 --> 00:03:51,280
which are

105
00:03:51,280 --> 00:03:54,400
regular virtual machines or vms and by

106
00:03:54,400 --> 00:03:55,599
the way in that talk i'm going to talk

107
00:03:55,599 --> 00:03:58,159
about vms when i talk to vms i refer to

108
00:03:58,159 --> 00:04:01,760
child children partitions

109
00:04:01,760 --> 00:04:02,799
and

110
00:04:02,799 --> 00:04:04,000
something that is

111
00:04:04,000 --> 00:04:06,400
really important to note is the vmworker

112
00:04:06,400 --> 00:04:09,439
process because it will be helpful later

113
00:04:09,439 --> 00:04:10,319
so

114
00:04:10,319 --> 00:04:12,239
this is a process in the user end of the

115
00:04:12,239 --> 00:04:14,239
root partition which is part of the

116
00:04:14,239 --> 00:04:16,079
virtualization stack

117
00:04:16,079 --> 00:04:19,120
and every time a child partition starts

118
00:04:19,120 --> 00:04:21,918
the vm worker process is created so it

119
00:04:21,918 --> 00:04:24,800
kind of holds the vm in a way

120
00:04:24,800 --> 00:04:27,120
so i hope i didn't lose everybody i said

121
00:04:27,120 --> 00:04:31,120
it i wouldn't detail everything

122
00:04:31,360 --> 00:04:34,160
so what i was looking for was

123
00:04:34,160 --> 00:04:36,080
a familiar attack called guest to host

124
00:04:36,080 --> 00:04:38,080
escape

125
00:04:38,080 --> 00:04:41,680
so the idea is to gain good execution

126
00:04:41,680 --> 00:04:42,400
from

127
00:04:42,400 --> 00:04:44,000
a virtual machine

128
00:04:44,000 --> 00:04:45,680
into the hypervisor so the perspective

129
00:04:45,680 --> 00:04:47,759
taken is the one of an attacker azure

130
00:04:47,759 --> 00:04:49,840
attacker so let's say

131
00:04:49,840 --> 00:04:51,840
you create a vm on azure

132
00:04:51,840 --> 00:04:53,919
you have a you are in the chat partition

133
00:04:53,919 --> 00:04:54,960
and you want to get back to the

134
00:04:54,960 --> 00:04:56,639
hypervisor to get code execution in the

135
00:04:56,639 --> 00:04:58,320
hypervisor because it's interesting

136
00:04:58,320 --> 00:05:01,520
because lots of things happen there

137
00:05:01,520 --> 00:05:02,320
so

138
00:05:02,320 --> 00:05:03,520
you may be interested in different

139
00:05:03,520 --> 00:05:05,520
layers because of the architecture of

140
00:05:05,520 --> 00:05:06,880
hyper-v you may be interested in the

141
00:05:06,880 --> 00:05:08,320
hypervisor but you may be interested

142
00:05:08,320 --> 00:05:09,759
also in the root partition kernel the

143
00:05:09,759 --> 00:05:12,080
root partition user hand so all those

144
00:05:12,080 --> 00:05:14,080
are interesting

145
00:05:14,080 --> 00:05:16,240
so this is what i was looking for

146
00:05:16,240 --> 00:05:18,240
also on hyper-v

147
00:05:18,240 --> 00:05:20,000
there are

148
00:05:20,000 --> 00:05:21,199
other types of attacks that are

149
00:05:21,199 --> 00:05:22,720
interesting like for example leaking

150
00:05:22,720 --> 00:05:24,560
information from the hypervisor is

151
00:05:24,560 --> 00:05:26,400
interesting but also

152
00:05:26,400 --> 00:05:29,039
denier service on the hypervisor as a

153
00:05:29,039 --> 00:05:31,440
note i'm not going to consider vm2vm for

154
00:05:31,440 --> 00:05:33,840
example

155
00:05:33,919 --> 00:05:35,039
so

156
00:05:35,039 --> 00:05:36,639
let's zoom out

157
00:05:36,639 --> 00:05:38,639
the attack surface on hypervisors is

158
00:05:38,639 --> 00:05:40,320
pretty large and this is a slide i've

159
00:05:40,320 --> 00:05:44,000
taken from alice serge at zerocon 2020

160
00:05:44,000 --> 00:05:46,639
because i think it self explains

161
00:05:46,639 --> 00:05:48,560
everything that was added so let's go

162
00:05:48,560 --> 00:05:50,320
back to what i was saying a hypervisor

163
00:05:50,320 --> 00:05:52,080
is some software that is added on

164
00:05:52,080 --> 00:05:53,840
directly on hardware which means lots of

165
00:05:53,840 --> 00:05:55,440
software added and lots of things to

166
00:05:55,440 --> 00:05:56,720
deal with

167
00:05:56,720 --> 00:05:59,280
so also very complex code on large

168
00:05:59,280 --> 00:06:01,840
attack surface so we could for example

169
00:06:01,840 --> 00:06:04,319
speak about the hyper core handlers that

170
00:06:04,319 --> 00:06:05,600
are handling the communication with the

171
00:06:05,600 --> 00:06:06,960
hypervisor

172
00:06:06,960 --> 00:06:09,680
also the peripherals graphics networking

173
00:06:09,680 --> 00:06:12,400
i mean lots of software is added

174
00:06:12,400 --> 00:06:15,280
when implementing a hypervisor

175
00:06:15,280 --> 00:06:17,680
and indeed that translates as it is

176
00:06:17,680 --> 00:06:19,759
complex into lots of cvs so this is not

177
00:06:19,759 --> 00:06:21,600
only for hyper-v by the way this is for

178
00:06:21,600 --> 00:06:23,600
lots of different hypervisors

179
00:06:23,600 --> 00:06:26,800
hyper-v also had some cves

180
00:06:26,800 --> 00:06:29,199
so you can see that it's complex code

181
00:06:29,199 --> 00:06:31,600
worth investigating

182
00:06:31,600 --> 00:06:34,479
so this is about the motivation

183
00:06:34,479 --> 00:06:37,680
and if we zoom in and talk about hyper-v

184
00:06:37,680 --> 00:06:39,759
again because of its archer we can

185
00:06:39,759 --> 00:06:42,720
consider different attack surfaces so in

186
00:06:42,720 --> 00:06:46,240
the root partition but also

187
00:06:46,400 --> 00:06:48,639
in the hypervisor itself all those are

188
00:06:48,639 --> 00:06:50,479
interesting so this is not exhaustive

189
00:06:50,479 --> 00:06:52,400
i'm not going to get into details you

190
00:06:52,400 --> 00:06:54,479
can find more things on first steps in

191
00:06:54,479 --> 00:06:56,639
hyper-v research

192
00:06:56,639 --> 00:06:59,440
and also it depends on the vm generation

193
00:06:59,440 --> 00:07:02,400
varies a bit

194
00:07:02,400 --> 00:07:03,840
so there was lots of research already

195
00:07:03,840 --> 00:07:05,440
done uh i'm not the first one looking

196
00:07:05,440 --> 00:07:07,680
into that obviously uh first

197
00:07:07,680 --> 00:07:10,400
microsoft and msrc is a very active

198
00:07:10,400 --> 00:07:12,080
contributor for the community and i

199
00:07:12,080 --> 00:07:13,919
think it's a good time as it is blue had

200
00:07:13,919 --> 00:07:16,400
to say thank you microsoft for that

201
00:07:16,400 --> 00:07:20,160
[Applause]

202
00:07:20,160 --> 00:07:23,120
so there were several blog posts

203
00:07:23,120 --> 00:07:24,880
for example first steps in hyper-v

204
00:07:24,880 --> 00:07:27,039
research that really helped researchers

205
00:07:27,039 --> 00:07:29,039
get started on hyper-v

206
00:07:29,039 --> 00:07:30,639
also there are some posts on hyperbolic

207
00:07:30,639 --> 00:07:33,360
components on msdn

208
00:07:33,360 --> 00:07:36,240
talks on vulnerability found internally

209
00:07:36,240 --> 00:07:37,599
there have been lots of talks at

210
00:07:37,599 --> 00:07:40,880
blackhat usa these past years

211
00:07:40,880 --> 00:07:43,039
and eventually microsoft makes our life

212
00:07:43,039 --> 00:07:44,800
a bit easier because there are symbols

213
00:07:44,800 --> 00:07:46,800
for some of the key components not all

214
00:07:46,800 --> 00:07:48,720
the components like not for microsoft

215
00:07:48,720 --> 00:07:50,560
but not all the components but some of

216
00:07:50,560 --> 00:07:53,759
the key components and also well debug

217
00:07:53,759 --> 00:07:55,280
strings in the code but i'm going back

218
00:07:55,280 --> 00:07:57,759
to that a bit later

219
00:07:57,759 --> 00:07:59,680
and there are also

220
00:07:59,680 --> 00:08:01,199
quite some external contributors the

221
00:08:01,199 --> 00:08:03,120
community is quite active so i want to

222
00:08:03,120 --> 00:08:05,680
mention a few like gerhard for example

223
00:08:05,680 --> 00:08:08,800
who has the dedicated blog post github

224
00:08:08,800 --> 00:08:11,360
and quotes several research

225
00:08:11,360 --> 00:08:13,599
researchers on that one ali says but

226
00:08:13,599 --> 00:08:15,599
also offia arpas and peleg hadar who

227
00:08:15,599 --> 00:08:18,400
presented last year black at usa

228
00:08:18,400 --> 00:08:20,240
on a different further

229
00:08:20,240 --> 00:08:22,080
targeting a different player

230
00:08:22,080 --> 00:08:24,840
great great

231
00:08:24,840 --> 00:08:28,240
dog so now that you can see a bit more

232
00:08:28,240 --> 00:08:30,879
the research um the attack surface

233
00:08:30,879 --> 00:08:33,120
the question is what to target and why

234
00:08:33,120 --> 00:08:34,799
because the research target and target

235
00:08:34,799 --> 00:08:36,799
is quite

236
00:08:36,799 --> 00:08:39,200
the attack surface is quite large so

237
00:08:39,200 --> 00:08:41,839
where to start

238
00:08:41,919 --> 00:08:44,560
and i chose to focus on the immunity

239
00:08:44,560 --> 00:08:46,399
devices controllers so

240
00:08:46,399 --> 00:08:48,080
i'm going to explain what it is to start

241
00:08:48,080 --> 00:08:49,200
with

242
00:08:49,200 --> 00:08:50,800
let's say let's start with something

243
00:08:50,800 --> 00:08:53,200
simple regular windows without

244
00:08:53,200 --> 00:08:54,959
hypervisors

245
00:08:54,959 --> 00:08:57,040
that windows may want to write to disk

246
00:08:57,040 --> 00:08:59,519
or may want to access some resources

247
00:08:59,519 --> 00:09:01,360
peripherals and

248
00:09:01,360 --> 00:09:03,360
it will talk directly to the almost

249
00:09:03,360 --> 00:09:04,480
directly

250
00:09:04,480 --> 00:09:05,920
let's make it simple

251
00:09:05,920 --> 00:09:09,519
to the devices controllers

252
00:09:09,519 --> 00:09:11,600
but when there are several vms uh

253
00:09:11,600 --> 00:09:12,959
several vms want i mean there's

254
00:09:12,959 --> 00:09:15,120
competing access to the resources

255
00:09:15,120 --> 00:09:17,680
so in some way the hypervisor needs to

256
00:09:17,680 --> 00:09:19,040
deal with that

257
00:09:19,040 --> 00:09:22,160
and one way is to give direct access

258
00:09:22,160 --> 00:09:25,120
from the vm to the hardware controllers

259
00:09:25,120 --> 00:09:26,880
which is called pass-through and there

260
00:09:26,880 --> 00:09:28,880
are two other techniques uh emulation

261
00:09:28,880 --> 00:09:30,800
and power virtualization i'm going to

262
00:09:30,800 --> 00:09:32,080
talk about

263
00:09:32,080 --> 00:09:33,600
emulation

264
00:09:33,600 --> 00:09:36,399
so with emulation what happens is the

265
00:09:36,399 --> 00:09:39,279
hypervisor acts as a proxy

266
00:09:39,279 --> 00:09:42,800
and the requests the guest is unmodified

267
00:09:42,800 --> 00:09:45,760
it sends requests to the hypervisor the

268
00:09:45,760 --> 00:09:47,360
hypervisor then

269
00:09:47,360 --> 00:09:50,320
deals with it as if it was the

270
00:09:50,320 --> 00:09:52,399
controller so it either sends it to the

271
00:09:52,399 --> 00:09:53,920
real controller

272
00:09:53,920 --> 00:09:56,959
or it aborts or it handles it software

273
00:09:56,959 --> 00:09:59,200
wise so you can imagine that there's

274
00:09:59,200 --> 00:10:01,040
lots of code added to do that and it's

275
00:10:01,040 --> 00:10:04,000
complex

276
00:10:04,000 --> 00:10:05,839
microsoft they are called virtual

277
00:10:05,839 --> 00:10:08,880
devices or vdfs

278
00:10:10,000 --> 00:10:12,560
and concretely on hyper-v this is what

279
00:10:12,560 --> 00:10:15,200
it looks like so coming back to the root

280
00:10:15,200 --> 00:10:17,600
partition trade partition

281
00:10:17,600 --> 00:10:21,040
the devices are implemented in the

282
00:10:21,040 --> 00:10:23,440
in dlls that are loaded by the vmware

283
00:10:23,440 --> 00:10:25,360
process so in the user end of the root

284
00:10:25,360 --> 00:10:27,600
partition

285
00:10:27,600 --> 00:10:30,399
this is true only for generation one vms

286
00:10:30,399 --> 00:10:31,600
so if you're not familiar with that

287
00:10:31,600 --> 00:10:33,519
there are two generations generation one

288
00:10:33,519 --> 00:10:35,440
is more legacy generation two has more

289
00:10:35,440 --> 00:10:37,040
modern features

290
00:10:37,040 --> 00:10:39,839
um so when i started this research azure

291
00:10:39,839 --> 00:10:41,760
was mostly running generation one i

292
00:10:41,760 --> 00:10:43,120
assume it's

293
00:10:43,120 --> 00:10:45,360
moving a bit because of windows 11 i

294
00:10:45,360 --> 00:10:47,519
don't know the status right now but

295
00:10:47,519 --> 00:10:50,959
it seems to be still widely used

296
00:10:50,959 --> 00:10:53,760
and some examples of those devices are

297
00:10:53,760 --> 00:10:55,120
ps2

298
00:10:55,120 --> 00:10:58,079
or floppy or ide also

299
00:10:58,079 --> 00:10:59,920
all those are emulated devices in

300
00:10:59,920 --> 00:11:02,720
generation one vms

301
00:11:02,720 --> 00:11:05,279
so now coming back to the question why

302
00:11:05,279 --> 00:11:08,160
choose the immunity devices

303
00:11:08,160 --> 00:11:10,240
first they are complex usually they are

304
00:11:10,240 --> 00:11:12,480
state machines

305
00:11:12,480 --> 00:11:14,560
for example with status registers

306
00:11:14,560 --> 00:11:16,399
different updates preconditions i mean

307
00:11:16,399 --> 00:11:19,360
conditional commands so it's quickly

308
00:11:19,360 --> 00:11:21,920
very complicated

309
00:11:21,920 --> 00:11:23,839
it's an area that has been proven to be

310
00:11:23,839 --> 00:11:26,560
prone to bugs in the past for

311
00:11:26,560 --> 00:11:29,360
several hypervisors including

312
00:11:29,360 --> 00:11:31,600
hyper-v

313
00:11:31,600 --> 00:11:33,839
and also as i was saying azure still

314
00:11:33,839 --> 00:11:36,560
uses generation one vms so it's still an

315
00:11:36,560 --> 00:11:39,120
interesting target

316
00:11:39,120 --> 00:11:41,200
hyper-v is developed in c plus plus

317
00:11:41,200 --> 00:11:42,959
which leaves room for memory corruption

318
00:11:42,959 --> 00:11:45,040
bugs

319
00:11:45,040 --> 00:11:46,320
and finally

320
00:11:46,320 --> 00:11:48,320
as it's as they are

321
00:11:48,320 --> 00:11:50,079
leaving in some way in the user end of

322
00:11:50,079 --> 00:11:51,680
the root partition

323
00:11:51,680 --> 00:11:53,920
it leaves room for potential guests to

324
00:11:53,920 --> 00:11:56,720
root partition escapes so all that makes

325
00:11:56,720 --> 00:11:59,680
it an interesting target

326
00:12:00,079 --> 00:12:01,760
so if we look at

327
00:12:01,760 --> 00:12:04,320
what the requests look like coming back

328
00:12:04,320 --> 00:12:06,560
to my request to my disk

329
00:12:06,560 --> 00:12:09,279
so the vm issues a request to a disk as

330
00:12:09,279 --> 00:12:11,440
if it was a real disk

331
00:12:11,440 --> 00:12:14,000
talking to a real controller

332
00:12:14,000 --> 00:12:16,320
which manifests in io ports are your

333
00:12:16,320 --> 00:12:18,480
comments

334
00:12:18,480 --> 00:12:20,720
so these are cpu instructions sent from

335
00:12:20,720 --> 00:12:23,519
the kernel of the guests

336
00:12:23,519 --> 00:12:27,120
in ex dx for example out dxex like dx is

337
00:12:27,120 --> 00:12:29,839
the port ex is the value

338
00:12:29,839 --> 00:12:31,200
you can read more about that in the

339
00:12:31,200 --> 00:12:32,959
intel manuals if you're interested so

340
00:12:32,959 --> 00:12:35,600
these are intel instructions

341
00:12:35,600 --> 00:12:38,160
and those instructions are sent the

342
00:12:38,160 --> 00:12:40,560
hypervisor intercepts it

343
00:12:40,560 --> 00:12:42,959
in the intercept them then redirect them

344
00:12:42,959 --> 00:12:45,040
through the vid with callbacks and

345
00:12:45,040 --> 00:12:47,040
eventually it lands in the user end of

346
00:12:47,040 --> 00:12:49,760
the root partition

347
00:12:51,600 --> 00:12:52,399
so

348
00:12:52,399 --> 00:12:54,639
this is a simplified view though it

349
00:12:54,639 --> 00:12:56,880
works for some of them it doesn't work

350
00:12:56,880 --> 00:12:58,560
for all of them

351
00:12:58,560 --> 00:13:00,240
some videos are a bit more complex with

352
00:13:00,240 --> 00:13:03,200
mmio handling also with some

353
00:13:03,200 --> 00:13:06,720
vm bus communication so the vm bus is

354
00:13:06,720 --> 00:13:08,800
it's an interview communication channel

355
00:13:08,800 --> 00:13:11,360
but i'm not going to get into details

356
00:13:11,360 --> 00:13:15,200
with that i'm going to stick to the ios

357
00:13:16,720 --> 00:13:19,040
and if you want to read more there's a

358
00:13:19,040 --> 00:13:21,040
good blog post attacking the vmworker

359
00:13:21,040 --> 00:13:23,439
process

360
00:13:23,920 --> 00:13:26,800
so the starting points for me

361
00:13:26,800 --> 00:13:29,040
now that we know that the code is in

362
00:13:29,040 --> 00:13:30,240
dlls

363
00:13:30,240 --> 00:13:32,800
loaded by the worker process this is the

364
00:13:32,800 --> 00:13:34,320
starting point to get to know what's

365
00:13:34,320 --> 00:13:36,720
going on we want to look at those in-art

366
00:13:36,720 --> 00:13:38,959
instructions where they are issued

367
00:13:38,959 --> 00:13:40,399
what's going on

368
00:13:40,399 --> 00:13:43,120
and the flow and eventually what's going

369
00:13:43,120 --> 00:13:45,120
on those dlls to handle those

370
00:13:45,120 --> 00:13:47,120
instructions

371
00:13:47,120 --> 00:13:48,959
so the first step is to reverse those

372
00:13:48,959 --> 00:13:51,920
dlls and to find the handlers that

373
00:13:51,920 --> 00:13:54,079
hold all the information so the io port

374
00:13:54,079 --> 00:13:58,240
the length and the value when it applies

375
00:13:58,240 --> 00:14:00,320
this is an example the vm emulated

376
00:14:00,320 --> 00:14:03,360
storage.dll for example and actually for

377
00:14:03,360 --> 00:14:05,040
all the devices

378
00:14:05,040 --> 00:14:06,399
there are two entry points that are

379
00:14:06,399 --> 00:14:07,920
always implemented which are notifier

380
00:14:07,920 --> 00:14:09,360
your portrait and notifier your bot

381
00:14:09,360 --> 00:14:12,000
right and we can see the parts length

382
00:14:12,000 --> 00:14:13,839
value there so that's

383
00:14:13,839 --> 00:14:15,040
exactly

384
00:14:15,040 --> 00:14:18,160
what we want to look at

385
00:14:18,959 --> 00:14:20,800
so on the plus side

386
00:14:20,800 --> 00:14:22,399
there are the symbols that are available

387
00:14:22,399 --> 00:14:24,399
for those dlls there's no particular

388
00:14:24,399 --> 00:14:26,079
difficulty there are even some debug

389
00:14:26,079 --> 00:14:28,639
strings so great

390
00:14:28,639 --> 00:14:29,519
on the

391
00:14:29,519 --> 00:14:31,279
not so good side it's simplest plus with

392
00:14:31,279 --> 00:14:34,000
indirect course but nothing

393
00:14:34,000 --> 00:14:38,320
specific like just separate person

394
00:14:38,480 --> 00:14:39,440
so

395
00:14:39,440 --> 00:14:41,040
now we know where to start the question

396
00:14:41,040 --> 00:14:42,720
is what do we want to do with stats

397
00:14:42,720 --> 00:14:45,440
because we know where it's implemented

398
00:14:45,440 --> 00:14:47,519
we can see what's going on

399
00:14:47,519 --> 00:14:49,120
although as i was saying it's very

400
00:14:49,120 --> 00:14:50,800
complex code so

401
00:14:50,800 --> 00:14:52,560
there are different strategies from

402
00:14:52,560 --> 00:14:53,360
there

403
00:14:53,360 --> 00:14:54,480
one strategy is to look at

404
00:14:54,480 --> 00:14:56,880
vulnerabilities manually look at

405
00:14:56,880 --> 00:15:00,320
the different devices

406
00:15:00,320 --> 00:15:02,560
check for error logics for example

407
00:15:02,560 --> 00:15:04,240
another approach as it is complex code

408
00:15:04,240 --> 00:15:05,600
is to write furthers and that's the one

409
00:15:05,600 --> 00:15:07,600
i took

410
00:15:07,600 --> 00:15:09,360
and the inspiration for me came from

411
00:15:09,360 --> 00:15:11,279
different factors so

412
00:15:11,279 --> 00:15:14,000
first i was working on some open source

413
00:15:14,000 --> 00:15:14,959
code

414
00:15:14,959 --> 00:15:17,440
and i usually further which is a further

415
00:15:17,440 --> 00:15:19,040
for open source

416
00:15:19,040 --> 00:15:20,560
and that was extremely efficient because

417
00:15:20,560 --> 00:15:23,199
it's using a coverage-guided

418
00:15:23,199 --> 00:15:26,079
technique approach so coverage guided

419
00:15:26,079 --> 00:15:29,120
fuzzing is the fact that the um the

420
00:15:29,120 --> 00:15:32,000
coverage is tracked on the target so

421
00:15:32,000 --> 00:15:35,120
the code that is executed is tracked

422
00:15:35,120 --> 00:15:37,680
and the input uh that increases that

423
00:15:37,680 --> 00:15:40,320
coverage is deemed interesting and helps

424
00:15:40,320 --> 00:15:41,839
creating more interesting input for the

425
00:15:41,839 --> 00:15:43,759
future so you can see that it's a

426
00:15:43,759 --> 00:15:45,920
positive loop and it helps covering more

427
00:15:45,920 --> 00:15:46,959
code

428
00:15:46,959 --> 00:15:48,720
so i found the technique very efficient

429
00:15:48,720 --> 00:15:50,399
and i was wondering how to do that

430
00:15:50,399 --> 00:15:52,399
knowing that in that case the problem is

431
00:15:52,399 --> 00:15:56,160
that the binaries are not open source

432
00:15:56,160 --> 00:15:58,320
more complicated

433
00:15:58,320 --> 00:16:01,680
also microsoft published under coverage

434
00:16:01,680 --> 00:16:03,839
three years ago i blew out here and this

435
00:16:03,839 --> 00:16:06,160
is a slide from that presentation a case

436
00:16:06,160 --> 00:16:07,600
study and i was wondering how to get

437
00:16:07,600 --> 00:16:09,519
back to that result

438
00:16:09,519 --> 00:16:11,920
from an external perspective

439
00:16:11,920 --> 00:16:13,199
and finally the last source of

440
00:16:13,199 --> 00:16:15,519
inspiration was a blog post

441
00:16:15,519 --> 00:16:19,519
on cv published in 2018

442
00:16:19,519 --> 00:16:20,959
about id

443
00:16:20,959 --> 00:16:23,839
and the bug that was found on ide so

444
00:16:23,839 --> 00:16:25,199
my question was

445
00:16:25,199 --> 00:16:26,639
i would like to do the same i'm not

446
00:16:26,639 --> 00:16:28,000
working at microsoft i don't have the

447
00:16:28,000 --> 00:16:29,680
sources

448
00:16:29,680 --> 00:16:33,439
how can i do the same closed source

449
00:16:35,120 --> 00:16:37,040
and to do that there are some existing

450
00:16:37,040 --> 00:16:39,120
tools already for windows so just to

451
00:16:39,120 --> 00:16:41,199
summarize we are in new zealand without

452
00:16:41,199 --> 00:16:43,440
the sources and

453
00:16:43,440 --> 00:16:45,199
together the coverage for example we can

454
00:16:45,199 --> 00:16:47,120
talk about dynamorio we can talk about

455
00:16:47,120 --> 00:16:49,920
intel pin mesos tineins there are some

456
00:16:49,920 --> 00:16:50,880
options

457
00:16:50,880 --> 00:16:52,720
also for phrasing we may offer with the

458
00:16:52,720 --> 00:16:55,759
memory jackalope to code some of them

459
00:16:55,759 --> 00:16:57,600
um for memory corruption detection this

460
00:16:57,600 --> 00:16:59,440
is important because this is c plus plus

461
00:16:59,440 --> 00:17:01,920
so you want to catch memory um

462
00:17:01,920 --> 00:17:02,839
corruption

463
00:17:02,839 --> 00:17:04,559
errors and

464
00:17:04,559 --> 00:17:06,720
when we have the this was code it's much

465
00:17:06,720 --> 00:17:08,720
easier because we can use

466
00:17:08,720 --> 00:17:11,839
address syntaxer asan

467
00:17:11,839 --> 00:17:14,799
now it's not the same but

468
00:17:14,799 --> 00:17:16,799
good news page heap

469
00:17:16,799 --> 00:17:20,400
with g flags helps doing that

470
00:17:21,359 --> 00:17:22,559
so

471
00:17:22,559 --> 00:17:24,000
there are plenty of tools and the

472
00:17:24,000 --> 00:17:25,760
question is why

473
00:17:25,760 --> 00:17:28,160
create yet another tool

474
00:17:28,160 --> 00:17:29,280
that's because of the different

475
00:17:29,280 --> 00:17:31,440
constraints of the environment so i'm

476
00:17:31,440 --> 00:17:32,720
going to

477
00:17:32,720 --> 00:17:33,919
give you more details about those

478
00:17:33,919 --> 00:17:35,919
constraints

479
00:17:35,919 --> 00:17:37,919
first the target is a dln it's not an

480
00:17:37,919 --> 00:17:39,520
executable which discards some of the

481
00:17:39,520 --> 00:17:42,880
phrases that do not apply to dlls

482
00:17:42,880 --> 00:17:43,919
second

483
00:17:43,919 --> 00:17:46,000
a very common technique when fuzzing is

484
00:17:46,000 --> 00:17:48,000
to extract the code that is deemed

485
00:17:48,000 --> 00:17:49,120
interesting

486
00:17:49,120 --> 00:17:51,039
to emulate it and deal with the side

487
00:17:51,039 --> 00:17:53,039
effects on context which means

488
00:17:53,039 --> 00:17:54,880
recreating a context that works but here

489
00:17:54,880 --> 00:17:57,120
we are speaking about virtualization vm

490
00:17:57,120 --> 00:17:59,120
states so it's quite heavy so that's why

491
00:17:59,120 --> 00:18:00,480
i didn't go for that approach because it

492
00:18:00,480 --> 00:18:01,600
seemed

493
00:18:01,600 --> 00:18:06,080
quite a heavier quite a heavy approach

494
00:18:06,160 --> 00:18:07,360
also

495
00:18:07,360 --> 00:18:09,039
some furthers require starting the

496
00:18:09,039 --> 00:18:11,520
target with the instrumentation

497
00:18:11,520 --> 00:18:12,559
well

498
00:18:12,559 --> 00:18:14,880
let's rewind i was saying

499
00:18:14,880 --> 00:18:18,000
the vm workout process starts vm starts

500
00:18:18,000 --> 00:18:19,840
which means that if you want to start

501
00:18:19,840 --> 00:18:21,280
instrumentation on the vmwork process

502
00:18:21,280 --> 00:18:22,320
you will

503
00:18:22,320 --> 00:18:24,480
it will make your vm restart

504
00:18:24,480 --> 00:18:25,919
which is not too desirable because

505
00:18:25,919 --> 00:18:29,799
starting a vm is quite slow

506
00:18:29,840 --> 00:18:31,919
also the runtime operations are very

507
00:18:31,919 --> 00:18:35,600
specific injecting ios

508
00:18:36,080 --> 00:18:37,679
something also i want to

509
00:18:37,679 --> 00:18:38,880
talk about

510
00:18:38,880 --> 00:18:41,039
when i started developing some tools did

511
00:18:41,039 --> 00:18:43,120
not exist at that time and i'm thinking

512
00:18:43,120 --> 00:18:45,200
about jacket up for example developed by

513
00:18:45,200 --> 00:18:46,400
project zero

514
00:18:46,400 --> 00:18:49,120
and that's also possible for future

515
00:18:49,120 --> 00:18:50,720
optimizations to

516
00:18:50,720 --> 00:18:52,559
modify the implementation to include

517
00:18:52,559 --> 00:18:55,600
those that could be helpful

518
00:18:55,600 --> 00:18:57,840
and something i added to myself as a

519
00:18:57,840 --> 00:18:59,600
constraint was to use a minimal set of

520
00:18:59,600 --> 00:19:01,360
programming languages because i wanted

521
00:19:01,360 --> 00:19:04,080
it to be easy to maintain in the future

522
00:19:04,080 --> 00:19:06,160
so added constraints

523
00:19:06,160 --> 00:19:07,679
and eventually i wanted the phaser to be

524
00:19:07,679 --> 00:19:10,080
portable to other cases so portable to

525
00:19:10,080 --> 00:19:11,440
other cases in the user end of the root

526
00:19:11,440 --> 00:19:14,480
partition so i wanted something generic

527
00:19:14,480 --> 00:19:16,799
enough

528
00:19:18,160 --> 00:19:18,960
so

529
00:19:18,960 --> 00:19:20,160
i

530
00:19:20,160 --> 00:19:22,080
i restricted the scope to

531
00:19:22,080 --> 00:19:23,760
windows guest vms

532
00:19:23,760 --> 00:19:25,200
intel cpus

533
00:19:25,200 --> 00:19:26,960
not arm

534
00:19:26,960 --> 00:19:29,840
generation one vms and binaries in the

535
00:19:29,840 --> 00:19:31,280
user end of the root partition to

536
00:19:31,280 --> 00:19:32,720
summarize everything

537
00:19:32,720 --> 00:19:33,760
and

538
00:19:33,760 --> 00:19:36,840
yeah there you go so the design choices

539
00:19:36,840 --> 00:19:39,919
were emulation versus execution as i was

540
00:19:39,919 --> 00:19:42,400
saying i went for execution

541
00:19:42,400 --> 00:19:44,160
so i decided to

542
00:19:44,160 --> 00:19:45,919
run a real vm

543
00:19:45,919 --> 00:19:47,520
and to run it

544
00:19:47,520 --> 00:19:49,120
inside the debugger which is called

545
00:19:49,120 --> 00:19:50,799
debug share which is a wrapper around

546
00:19:50,799 --> 00:19:53,120
windows debugging engine

547
00:19:53,120 --> 00:19:53,840
so

548
00:19:53,840 --> 00:19:55,520
we are on time

549
00:19:55,520 --> 00:19:57,200
for the coverage

550
00:19:57,200 --> 00:19:58,640
i use the technique i'm going to get

551
00:19:58,640 --> 00:20:00,320
more details about that to give more

552
00:20:00,320 --> 00:20:01,840
details about that later

553
00:20:01,840 --> 00:20:04,080
the in three technique described by

554
00:20:04,080 --> 00:20:06,880
samuel gross for traffic and brendon

555
00:20:06,880 --> 00:20:09,760
folk for mesos

556
00:20:10,000 --> 00:20:11,760
for the memory corruption detection i

557
00:20:11,760 --> 00:20:13,919
used to pay a page chip it was already

558
00:20:13,919 --> 00:20:15,600
there handy

559
00:20:15,600 --> 00:20:17,840
and the type of bugs that can be found

560
00:20:17,840 --> 00:20:20,320
are memory corruption bugs state

561
00:20:20,320 --> 00:20:22,480
machine logic errors

562
00:20:22,480 --> 00:20:24,960
possibly use after free it depends uh if

563
00:20:24,960 --> 00:20:27,840
i get a blue screen or not

564
00:20:27,840 --> 00:20:30,080
race conditions are off the table

565
00:20:30,080 --> 00:20:31,440
because the further is not

566
00:20:31,440 --> 00:20:34,080
multi-threaded so no that's not going

567
00:20:34,080 --> 00:20:37,280
something that would be good

568
00:20:38,080 --> 00:20:39,840
also something that is extremely

569
00:20:39,840 --> 00:20:41,360
important when fuzzing is to come back

570
00:20:41,360 --> 00:20:43,200
to a reference state so we want to come

571
00:20:43,200 --> 00:20:45,120
back to a clean state for every fuzzing

572
00:20:45,120 --> 00:20:46,880
loop and that's extremely important

573
00:20:46,880 --> 00:20:50,159
because worst case you modify your vm

574
00:20:50,159 --> 00:20:52,320
lots of things happen you get a crash

575
00:20:52,320 --> 00:20:54,320
and you cannot reproduce it because of

576
00:20:54,320 --> 00:20:55,600
everything that happened before that you

577
00:20:55,600 --> 00:20:58,400
cannot trace and that's very sad you

578
00:20:58,400 --> 00:20:59,840
don't want that so

579
00:20:59,840 --> 00:21:01,120
so the idea was to come back to a clean

580
00:21:01,120 --> 00:21:03,600
environment so every time the new

581
00:21:03,600 --> 00:21:06,000
further input was

582
00:21:06,000 --> 00:21:07,120
processed

583
00:21:07,120 --> 00:21:08,880
it would start on a new environment and

584
00:21:08,880 --> 00:21:10,720
this was done using hyper-v checkpoints

585
00:21:10,720 --> 00:21:12,159
which are the equivalent of snapshots

586
00:21:12,159 --> 00:21:15,640
for other hypervisors

587
00:21:16,960 --> 00:21:19,600
so to be clear coming back to a clean vm

588
00:21:19,600 --> 00:21:22,320
image before every loop

589
00:21:22,320 --> 00:21:24,480
the mutation strategy chosen was custom

590
00:21:24,480 --> 00:21:26,799
the language was powershell which may

591
00:21:26,799 --> 00:21:28,559
sound funny for a fuzzer because

592
00:21:28,559 --> 00:21:30,640
powershell is a scripting language and

593
00:21:30,640 --> 00:21:32,880
scripting means slow

594
00:21:32,880 --> 00:21:33,600
but

595
00:21:33,600 --> 00:21:35,919
the big plus of powershot is that it's

596
00:21:35,919 --> 00:21:37,919
it integrates very well in windows it's

597
00:21:37,919 --> 00:21:40,480
done for that so it enables interacting

598
00:21:40,480 --> 00:21:42,559
with lots of apis on windows like for

599
00:21:42,559 --> 00:21:44,480
example sending comments to a vm

600
00:21:44,480 --> 00:21:47,840
interacting with hyper-v manager so

601
00:21:47,840 --> 00:21:50,320
very handy

602
00:21:50,320 --> 00:21:52,960
and as i was saying the idea was to

603
00:21:52,960 --> 00:21:55,360
minimize the work and reuse as much as

604
00:21:55,360 --> 00:21:56,400
possible

605
00:21:56,400 --> 00:21:58,960
existing tools so that's why i use debug

606
00:21:58,960 --> 00:21:59,840
shell

607
00:21:59,840 --> 00:22:01,280
the debugger

608
00:22:01,280 --> 00:22:02,480
chipset

609
00:22:02,480 --> 00:22:05,360
in the guest vm to send the ios so

610
00:22:05,360 --> 00:22:07,760
chipset is a utility

611
00:22:07,760 --> 00:22:09,840
that does lots of things for uefi and so

612
00:22:09,840 --> 00:22:11,039
on but

613
00:22:11,039 --> 00:22:14,880
here the idea was to leverage um sending

614
00:22:14,880 --> 00:22:16,320
io ports

615
00:22:16,320 --> 00:22:18,960
and their drivers

616
00:22:18,960 --> 00:22:22,159
pagehip optionally on lighthouse and ida

617
00:22:22,159 --> 00:22:23,679
optionally also to visualize the

618
00:22:23,679 --> 00:22:25,520
coverage and to set

619
00:22:25,520 --> 00:22:27,600
to prepare a list of breakpoints going

620
00:22:27,600 --> 00:22:30,400
back to that a bit later

621
00:22:30,400 --> 00:22:33,120
and this is what introspect looks like

622
00:22:33,120 --> 00:22:34,320
so

623
00:22:34,320 --> 00:22:36,400
the fuzzer runs at the same level as the

624
00:22:36,400 --> 00:22:37,919
debugger

625
00:22:37,919 --> 00:22:41,039
and the target so it starts the debugger

626
00:22:41,039 --> 00:22:42,720
which attaches to the vmworker process

627
00:22:42,720 --> 00:22:44,559
that close the dll

628
00:22:44,559 --> 00:22:46,000
has already loaded the dll actually when

629
00:22:46,000 --> 00:22:47,520
it's attached

630
00:22:47,520 --> 00:22:49,679
at the same time the further injects

631
00:22:49,679 --> 00:22:51,360
commands

632
00:22:51,360 --> 00:22:53,200
in the vm

633
00:22:53,200 --> 00:22:54,559
to chipset

634
00:22:54,559 --> 00:22:55,840
in new zealand

635
00:22:55,840 --> 00:22:58,000
chipset communicates with its driver in

636
00:22:58,000 --> 00:23:00,159
kernel that sends the ios

637
00:23:00,159 --> 00:23:02,880
then they are sent to the hypervisor and

638
00:23:02,880 --> 00:23:04,320
redirected to the username of dual

639
00:23:04,320 --> 00:23:05,679
partition

640
00:23:05,679 --> 00:23:09,440
also the further monitors the vm

641
00:23:09,440 --> 00:23:11,679
so that's how everything

642
00:23:11,679 --> 00:23:14,320
well is together works together

643
00:23:14,320 --> 00:23:16,320
one more note you can run it like that

644
00:23:16,320 --> 00:23:19,280
but usually i run it nested

645
00:23:19,280 --> 00:23:20,799
this is much easier to come back to

646
00:23:20,799 --> 00:23:23,520
something and well to deal with

647
00:23:23,520 --> 00:23:25,760
everything and make sure that if i get

648
00:23:25,760 --> 00:23:27,679
a hypervisor crash it will be contained

649
00:23:27,679 --> 00:23:30,000
also

650
00:23:30,960 --> 00:23:32,960
so the workflow is as follow

651
00:23:32,960 --> 00:23:35,120
first the user and that's the only

652
00:23:35,120 --> 00:23:36,640
mandatory input needs to prepare a

653
00:23:36,640 --> 00:23:38,720
config.json file with

654
00:23:38,720 --> 00:23:40,880
some minimal data like

655
00:23:40,880 --> 00:23:42,080
the vm

656
00:23:42,080 --> 00:23:42,880
name

657
00:23:42,880 --> 00:23:44,880
checkpoint name

658
00:23:44,880 --> 00:23:47,760
vm username password io ports those kind

659
00:23:47,760 --> 00:23:49,840
of details

660
00:23:49,840 --> 00:23:51,440
also

661
00:23:51,440 --> 00:23:53,600
if possible it's encouraged blocks

662
00:23:53,600 --> 00:23:55,520
addresses i'm going back to that later

663
00:23:55,520 --> 00:23:59,200
and then the domain can be started

664
00:23:59,200 --> 00:24:01,039
if the arguments are valid the further

665
00:24:01,039 --> 00:24:03,120
master starts

666
00:24:03,120 --> 00:24:05,440
then it starts the input generator which

667
00:24:05,440 --> 00:24:09,600
represent file for the fuzzer to work on

668
00:24:09,600 --> 00:24:11,760
then it starts the debugger which

669
00:24:11,760 --> 00:24:14,000
attaches to the vmworker process that

670
00:24:14,000 --> 00:24:15,520
holds the vm and eventually your

671
00:24:15,520 --> 00:24:17,840
monitoring process is started so this is

672
00:24:17,840 --> 00:24:20,959
what it looks like in the end

673
00:24:21,360 --> 00:24:23,120
i'm going to get more details

674
00:24:23,120 --> 00:24:24,720
to get into more details on some of

675
00:24:24,720 --> 00:24:26,320
those aspects so

676
00:24:26,320 --> 00:24:28,159
first coverage collection this is

677
00:24:28,159 --> 00:24:29,760
important for coverage guided further

678
00:24:29,760 --> 00:24:31,919
obviously so

679
00:24:31,919 --> 00:24:33,840
i'm using block coverage so it means

680
00:24:33,840 --> 00:24:35,039
that

681
00:24:35,039 --> 00:24:37,200
if you disassemble dll

682
00:24:37,200 --> 00:24:41,279
for example with ida git draw it will be

683
00:24:41,279 --> 00:24:43,600
disassembled in blocks

684
00:24:43,600 --> 00:24:45,520
and the idea is to take the addresses of

685
00:24:45,520 --> 00:24:46,400
those blocks

686
00:24:46,400 --> 00:24:47,760
put them in a list

687
00:24:47,760 --> 00:24:49,760
and here a and d have already been

688
00:24:49,760 --> 00:24:51,360
executed so they are no longer in the

689
00:24:51,360 --> 00:24:53,600
list b and c have not been executed so

690
00:24:53,600 --> 00:24:55,440
they are still in the list

691
00:24:55,440 --> 00:24:57,200
b gets executed it's removed from the

692
00:24:57,200 --> 00:24:59,200
list then c gets executed it's removed

693
00:24:59,200 --> 00:25:01,279
from the list you get the idea and this

694
00:25:01,279 --> 00:25:04,000
differs from as a note edge coverage

695
00:25:04,000 --> 00:25:06,000
edge coverage can be

696
00:25:06,000 --> 00:25:07,919
better in some aspects harder to

697
00:25:07,919 --> 00:25:10,159
implement so it's a choice

698
00:25:10,159 --> 00:25:12,159
and also i'm not using counters so

699
00:25:12,159 --> 00:25:14,000
either the block is executed or it's not

700
00:25:14,000 --> 00:25:15,520
executed

701
00:25:15,520 --> 00:25:17,840
could be an option also later to modify

702
00:25:17,840 --> 00:25:20,240
the further

703
00:25:20,480 --> 00:25:22,559
and the in three techniques so

704
00:25:22,559 --> 00:25:25,120
something what is an m3 first an e3 is

705
00:25:25,120 --> 00:25:27,520
actually a software breakpoint

706
00:25:27,520 --> 00:25:29,600
used by the debuggers so it's an

707
00:25:29,600 --> 00:25:31,840
interrupt

708
00:25:31,840 --> 00:25:32,799
and

709
00:25:32,799 --> 00:25:34,480
that's where the bookshark comes into

710
00:25:34,480 --> 00:25:35,600
interplay

711
00:25:35,600 --> 00:25:37,039
because i'm

712
00:25:37,039 --> 00:25:38,320
at the beginning of each block that has

713
00:25:38,320 --> 00:25:40,480
not been executed and ent3 is set by the

714
00:25:40,480 --> 00:25:42,559
debugger then

715
00:25:42,559 --> 00:25:44,960
once the execution gets there the

716
00:25:44,960 --> 00:25:48,000
debugger is notified removes

717
00:25:48,000 --> 00:25:48,720
the

718
00:25:48,720 --> 00:25:50,080
n3

719
00:25:50,080 --> 00:25:51,840
does whatever needs to be to be done

720
00:25:51,840 --> 00:25:53,440
about the input because at this point it

721
00:25:53,440 --> 00:25:54,960
means the input is interesting because

722
00:25:54,960 --> 00:25:57,200
it enabled extending the coverage

723
00:25:57,200 --> 00:25:59,520
and then resumes execution later with

724
00:25:59,520 --> 00:26:02,240
the regular code

725
00:26:02,400 --> 00:26:04,320
one note also at the beginning there are

726
00:26:04,320 --> 00:26:06,640
plenty of addresses in the file so it's

727
00:26:06,640 --> 00:26:08,159
pretty slow because the debugger needs

728
00:26:08,159 --> 00:26:10,400
to stop for every new block that is

729
00:26:10,400 --> 00:26:11,600
executed

730
00:26:11,600 --> 00:26:13,279
over time it becomes faster and faster

731
00:26:13,279 --> 00:26:14,720
because there are less and less blocks

732
00:26:14,720 --> 00:26:16,480
that have not been executed and those

733
00:26:16,480 --> 00:26:17,840
are the most interesting ones actually

734
00:26:17,840 --> 00:26:20,240
usually

735
00:26:21,039 --> 00:26:22,720
one more aspect is which is very

736
00:26:22,720 --> 00:26:24,640
important when fuzzing is the gene the

737
00:26:24,640 --> 00:26:26,080
input files

738
00:26:26,080 --> 00:26:29,200
so to be clear the input files here are

739
00:26:29,200 --> 00:26:32,559
io operations that are encoded

740
00:26:32,559 --> 00:26:34,960
so first it's very encouraged to record

741
00:26:34,960 --> 00:26:36,720
seeds and our helpers for that i'm not

742
00:26:36,720 --> 00:26:38,000
going to talk about helpers because we

743
00:26:38,000 --> 00:26:39,279
won't have time but there are different

744
00:26:39,279 --> 00:26:43,039
helpers one is to help generate seeds

745
00:26:43,039 --> 00:26:45,600
of legitimate traffic

746
00:26:45,600 --> 00:26:47,039
there are two types of fails that are

747
00:26:47,039 --> 00:26:48,559
considered for the further the corpus

748
00:26:48,559 --> 00:26:49,600
fails

749
00:26:49,600 --> 00:26:50,640
which are

750
00:26:50,640 --> 00:26:52,960
permanent residents that are deemed

751
00:26:52,960 --> 00:26:55,360
interesting and

752
00:26:55,360 --> 00:26:57,919
input files that are that will be tested

753
00:26:57,919 --> 00:26:59,279
and every time does the coverage

754
00:26:59,279 --> 00:27:00,400
increase

755
00:27:00,400 --> 00:27:02,799
the input file that is being processed

756
00:27:02,799 --> 00:27:05,440
is kept aside truncated at the latest

757
00:27:05,440 --> 00:27:07,200
change and kept the sides put in the

758
00:27:07,200 --> 00:27:09,039
corpus

759
00:27:09,039 --> 00:27:10,720
and there are three strategies to create

760
00:27:10,720 --> 00:27:12,960
new input files mutation

761
00:27:12,960 --> 00:27:14,559
appends

762
00:27:14,559 --> 00:27:15,919
and

763
00:27:15,919 --> 00:27:19,120
random generation to cover new cases

764
00:27:19,120 --> 00:27:20,320
also and

765
00:27:20,320 --> 00:27:22,480
give more opportunities to cover

766
00:27:22,480 --> 00:27:25,120
something completely different

767
00:27:25,120 --> 00:27:27,679
so the format is as follow

768
00:27:27,679 --> 00:27:29,760
first in out operation then decide on

769
00:27:29,760 --> 00:27:32,240
the on the part with the second byte

770
00:27:32,240 --> 00:27:34,799
then the length and if it applies a

771
00:27:34,799 --> 00:27:37,279
value is red given the length

772
00:27:37,279 --> 00:27:40,720
and so on and so forth in the file

773
00:27:42,000 --> 00:27:43,679
something also that is critical when

774
00:27:43,679 --> 00:27:45,200
fuzzing and building a further is to

775
00:27:45,200 --> 00:27:47,840
think about crash

776
00:27:47,840 --> 00:27:49,440
because you want to catch them all you

777
00:27:49,440 --> 00:27:52,399
don't want to miss some crashes

778
00:27:52,399 --> 00:27:54,799
so it happens at two levels here first

779
00:27:54,799 --> 00:27:56,320
at the debugger level because if the

780
00:27:56,320 --> 00:27:58,799
debugger receives a fault or interrupt

781
00:27:58,799 --> 00:28:00,720
that is not an ent3 that it's supposed

782
00:28:00,720 --> 00:28:02,480
to receive

783
00:28:02,480 --> 00:28:04,559
there's a problem so the monitor the

784
00:28:04,559 --> 00:28:06,159
debugger will

785
00:28:06,159 --> 00:28:07,120
create

786
00:28:07,120 --> 00:28:10,720
a crash uh folder with all the artifacts

787
00:28:10,720 --> 00:28:11,919
that are required and there's also a

788
00:28:11,919 --> 00:28:13,520
monitoring process that is started by

789
00:28:13,520 --> 00:28:16,640
the debugger just in case um second

790
00:28:16,640 --> 00:28:17,760
level

791
00:28:17,760 --> 00:28:21,440
and it tracks the vm uptime because

792
00:28:21,440 --> 00:28:23,679
it does some polling and if in between

793
00:28:23,679 --> 00:28:25,840
the vm up time goes down it means the vm

794
00:28:25,840 --> 00:28:28,720
has restarted basically

795
00:28:28,720 --> 00:28:31,360
so the crash folder is composed of uh

796
00:28:31,360 --> 00:28:33,520
logs event logs everything and

797
00:28:33,520 --> 00:28:35,679
everything needed to um replay also the

798
00:28:35,679 --> 00:28:36,720
case

799
00:28:36,720 --> 00:28:38,480
so this is how the photo is built and

800
00:28:38,480 --> 00:28:40,080
optionally it's possible to visualize

801
00:28:40,080 --> 00:28:42,559
the coverage in ida also

802
00:28:42,559 --> 00:28:44,720
with lighthouse

803
00:28:44,720 --> 00:28:46,320
so now you've seen all the components to

804
00:28:46,320 --> 00:28:48,480
make the further um

805
00:28:48,480 --> 00:28:51,360
so you have an idea of how it works um

806
00:28:51,360 --> 00:28:53,840
you got all most of the details and this

807
00:28:53,840 --> 00:28:55,440
is what it looks like in practice so i

808
00:28:55,440 --> 00:28:56,880
know it's small but i'm going to explain

809
00:28:56,880 --> 00:28:58,880
quickly um

810
00:28:58,880 --> 00:29:00,880
top right hand corner this is the main

811
00:29:00,880 --> 00:29:03,279
console top left hand corner debug shell

812
00:29:03,279 --> 00:29:05,360
most of the other windows are hidden and

813
00:29:05,360 --> 00:29:07,200
these are folders with the different

814
00:29:07,200 --> 00:29:09,360
artifacts introspect and

815
00:29:09,360 --> 00:29:11,919
input files so this is what this is what

816
00:29:11,919 --> 00:29:15,360
it may look like on your own computer

817
00:29:16,000 --> 00:29:18,559
so now let's dive into the the results

818
00:29:18,559 --> 00:29:20,559
of the fuzzer

819
00:29:20,559 --> 00:29:22,799
so first the fuzzer was only run luckily

820
00:29:22,799 --> 00:29:24,640
for now

821
00:29:24,640 --> 00:29:28,200
it was run on i um on four devices

822
00:29:28,200 --> 00:29:30,080
iat42

823
00:29:30,080 --> 00:29:31,600
ps2

824
00:29:31,600 --> 00:29:34,159
video s3 floppy and id

825
00:29:34,159 --> 00:29:35,760
the local setup was a dedicated

826
00:29:35,760 --> 00:29:39,039
workstation um 32 gigs of ram i'm just

827
00:29:39,039 --> 00:29:40,880
sharing that it's a bit boring details i

828
00:29:40,880 --> 00:29:42,080
guess but just in case you want to

829
00:29:42,080 --> 00:29:44,799
reproduce that

830
00:29:44,799 --> 00:29:46,720
it's possible to do that with

831
00:29:46,720 --> 00:29:50,480
well a dedicated workshop at home

832
00:29:50,640 --> 00:29:52,320
and also

833
00:29:52,320 --> 00:29:54,000
the first thing i noticed is speed

834
00:29:54,000 --> 00:29:55,919
limitation and i would say it's the main

835
00:29:55,919 --> 00:29:57,600
bottleneck

836
00:29:57,600 --> 00:30:00,000
and it's not tied to restoring a

837
00:30:00,000 --> 00:30:01,760
checkpoint actually

838
00:30:01,760 --> 00:30:04,159
it's tied to setting breakpoints in the

839
00:30:04,159 --> 00:30:05,279
debugger

840
00:30:05,279 --> 00:30:07,200
and it's not something linear so if you

841
00:30:07,200 --> 00:30:09,279
want to set 150

842
00:30:09,279 --> 00:30:10,960
breakpoints

843
00:30:10,960 --> 00:30:11,919
it takes

844
00:30:11,919 --> 00:30:13,760
it takes less than a second

845
00:30:13,760 --> 00:30:14,960
super easy

846
00:30:14,960 --> 00:30:18,480
500 six seconds and so on so that's why

847
00:30:18,480 --> 00:30:20,480
also you want to be very focused when

848
00:30:20,480 --> 00:30:22,159
you when you set your breakpoints at the

849
00:30:22,159 --> 00:30:24,480
beginning

850
00:30:24,880 --> 00:30:26,720
the next goal is to put the fuzzers to

851
00:30:26,720 --> 00:30:29,919
clouds so gcp are azure to get more runs

852
00:30:29,919 --> 00:30:31,120
and

853
00:30:31,120 --> 00:30:34,239
get more wider results

854
00:30:34,399 --> 00:30:37,279
so after three days of run look luckily

855
00:30:37,279 --> 00:30:39,279
uh the coverage is about 40 for the

856
00:30:39,279 --> 00:30:41,679
devices which may sound low but actually

857
00:30:41,679 --> 00:30:43,760
you need to remember uh that the start

858
00:30:43,760 --> 00:30:45,520
init and stop functions are never called

859
00:30:45,520 --> 00:30:47,360
because we are attaching to a

860
00:30:47,360 --> 00:30:51,039
working um to a running vm

861
00:30:51,039 --> 00:30:52,720
and the debug strings blocks are skipped

862
00:30:52,720 --> 00:30:54,799
and actually if we if we can consider

863
00:30:54,799 --> 00:30:58,080
all the functions that uh at runtime

864
00:30:58,080 --> 00:31:00,159
most of them are covered like almost all

865
00:31:00,159 --> 00:31:02,720
of them were covered so the coverage is

866
00:31:02,720 --> 00:31:04,480
doesn't look that high but it's actually

867
00:31:04,480 --> 00:31:06,159
pretty high in terms of runtime

868
00:31:06,159 --> 00:31:08,960
functions covered

869
00:31:09,440 --> 00:31:11,519
one result i got but it was a bit of a

870
00:31:11,519 --> 00:31:12,799
rollercoaster for me i'm sharing the

871
00:31:12,799 --> 00:31:14,480
roller coaster with you

872
00:31:14,480 --> 00:31:17,279
was the guest vm crash phone so

873
00:31:17,279 --> 00:31:21,519
it was on i80 42 device reproducible all

874
00:31:21,519 --> 00:31:23,919
the time consistently

875
00:31:23,919 --> 00:31:25,519
and

876
00:31:25,519 --> 00:31:27,200
you may wonder at this point why are we

877
00:31:27,200 --> 00:31:28,880
talking about a guest vm crash because

878
00:31:28,880 --> 00:31:30,399
there are so many ways to crash a vm

879
00:31:30,399 --> 00:31:31,760
actually when we are administrator of

880
00:31:31,760 --> 00:31:34,000
the vm right

881
00:31:34,000 --> 00:31:36,320
well in that case it was so interesting

882
00:31:36,320 --> 00:31:38,240
it still caught my attention because

883
00:31:38,240 --> 00:31:41,919
there was a blue screen consistently but

884
00:31:41,919 --> 00:31:44,880
with different error messages every time

885
00:31:44,880 --> 00:31:47,440
so i was getting error messages like pfn

886
00:31:47,440 --> 00:31:49,519
is corrupt for example or

887
00:31:49,519 --> 00:31:50,640
attempted

888
00:31:50,640 --> 00:31:53,440
rights to read-only memory or kernel

889
00:31:53,440 --> 00:31:55,600
security check failure so that's

890
00:31:55,600 --> 00:31:57,840
triggered my attention because these are

891
00:31:57,840 --> 00:31:58,840
interesting

892
00:31:58,840 --> 00:32:01,279
messages so it was actually kind of a

893
00:32:01,279 --> 00:32:02,960
memory corruption error i was wondering

894
00:32:02,960 --> 00:32:05,039
what was going on and investigated

895
00:32:05,039 --> 00:32:06,720
i narrowed down

896
00:32:06,720 --> 00:32:08,640
the case to a sequence of

897
00:32:08,640 --> 00:32:10,799
two out operations

898
00:32:10,799 --> 00:32:13,840
one was a fixed one the other one was

899
00:32:13,840 --> 00:32:15,519
the value could depend a bit two bits

900
00:32:15,519 --> 00:32:18,240
needed to be set in a certain way

901
00:32:18,240 --> 00:32:19,760
and this was because of a state machine

902
00:32:19,760 --> 00:32:21,440
because it was getting into a

903
00:32:21,440 --> 00:32:24,720
precondition and then getting to a given

904
00:32:24,720 --> 00:32:26,240
function and actually it was because of

905
00:32:26,240 --> 00:32:28,399
the legacy 820 device

906
00:32:28,399 --> 00:32:30,559
and what was happening it was is that it

907
00:32:30,559 --> 00:32:32,799
was updating the host memory mapping

908
00:32:32,799 --> 00:32:34,399
but the guest was keeping the same

909
00:32:34,399 --> 00:32:35,679
mapping so

910
00:32:35,679 --> 00:32:38,799
everything was failing

911
00:32:38,799 --> 00:32:40,320
and i was wondering i was really

912
00:32:40,320 --> 00:32:41,360
wondering if it was possible to

913
00:32:41,360 --> 00:32:42,880
compromise vbs and that's why i was

914
00:32:42,880 --> 00:32:44,320
interested in that one

915
00:32:44,320 --> 00:32:46,880
virtualization-based security what i was

916
00:32:46,880 --> 00:32:48,880
wondering if is that

917
00:32:48,880 --> 00:32:52,000
is was it possible to read some memory

918
00:32:52,000 --> 00:32:53,679
from the guest that it's not supposed to

919
00:32:53,679 --> 00:32:55,120
read

920
00:32:55,120 --> 00:32:56,799
well it was kind of a roller coaster but

921
00:32:56,799 --> 00:32:58,080
in eventually

922
00:32:58,080 --> 00:32:59,919
no unfortunately because the problem is

923
00:32:59,919 --> 00:33:01,039
that

924
00:33:01,039 --> 00:33:02,799
the vm is about to crash

925
00:33:02,799 --> 00:33:05,519
we want to save some memory in that case

926
00:33:05,519 --> 00:33:06,640
to do that

927
00:33:06,640 --> 00:33:08,320
which is not possible because it means

928
00:33:08,320 --> 00:33:09,919
rating too distracting this is super

929
00:33:09,919 --> 00:33:11,840
slow it requires access to memory well

930
00:33:11,840 --> 00:33:13,919
there's a loophole here it doesn't work

931
00:33:13,919 --> 00:33:18,799
so had it been possible not exploitable

932
00:33:19,279 --> 00:33:21,840
so i shared it with msrc it's not a

933
00:33:21,840 --> 00:33:23,440
security bug

934
00:33:23,440 --> 00:33:26,159
although the good news is that it

935
00:33:26,159 --> 00:33:29,919
validated the behavior of the further

936
00:33:29,919 --> 00:33:32,559
crash handling reproduction everything

937
00:33:32,559 --> 00:33:33,440
worked

938
00:33:33,440 --> 00:33:36,480
like a charm so good news on that

939
00:33:36,480 --> 00:33:38,880
and also it highlights that this surface

940
00:33:38,880 --> 00:33:40,640
has probably received plenty of

941
00:33:40,640 --> 00:33:42,559
attention already and

942
00:33:42,559 --> 00:33:44,240
there's probably not much to be found

943
00:33:44,240 --> 00:33:46,720
anymore

944
00:33:47,679 --> 00:33:48,480
so

945
00:33:48,480 --> 00:33:50,640
getting back to the future endeavors

946
00:33:50,640 --> 00:33:52,240
there are two limitations for now i

947
00:33:52,240 --> 00:33:53,760
would say

948
00:33:53,760 --> 00:33:55,840
space because i restrict the further to

949
00:33:55,840 --> 00:33:57,039
the user end of

950
00:33:57,039 --> 00:33:58,720
the partition

951
00:33:58,720 --> 00:34:00,880
and as of today this is not something i

952
00:34:00,880 --> 00:34:03,279
want to change in the future because in

953
00:34:03,279 --> 00:34:05,039
between some other tools were developed

954
00:34:05,039 --> 00:34:06,960
like hifr one and two

955
00:34:06,960 --> 00:34:08,639
which already

956
00:34:08,639 --> 00:34:11,359
fill the gap reach the gap

957
00:34:11,359 --> 00:34:13,860
time is a limitation that

958
00:34:13,860 --> 00:34:15,359
[Music]

959
00:34:15,359 --> 00:34:17,679
is a bit different and could be some

960
00:34:17,679 --> 00:34:21,040
things could be done to optimize that so

961
00:34:21,040 --> 00:34:22,639
the future work will mostly be around

962
00:34:22,639 --> 00:34:24,000
that

963
00:34:24,000 --> 00:34:26,239
first developing the further internals

964
00:34:26,239 --> 00:34:27,918
so

965
00:34:27,918 --> 00:34:29,359
in terms of speed

966
00:34:29,359 --> 00:34:32,399
replacing debug share by something else

967
00:34:32,399 --> 00:34:34,879
for example minimal debugger

968
00:34:34,879 --> 00:34:38,000
or um also in terms of speed uh

969
00:34:38,000 --> 00:34:40,000
replacing some parts by the by c plus

970
00:34:40,000 --> 00:34:42,560
plus or c sharp to get more speed also

971
00:34:42,560 --> 00:34:44,000
on the execution and get rid of some of

972
00:34:44,000 --> 00:34:46,320
the scripting

973
00:34:46,320 --> 00:34:48,480
enhance the mutation strategy also by

974
00:34:48,480 --> 00:34:49,440
using

975
00:34:49,440 --> 00:34:51,679
exiting engines

976
00:34:51,679 --> 00:34:53,839
not that the engines could be used as a

977
00:34:53,839 --> 00:34:57,520
whole but at least use the logic

978
00:34:58,000 --> 00:35:01,520
according to gcp azure get more runs

979
00:35:01,520 --> 00:35:04,960
and adapting to other targets so other

980
00:35:04,960 --> 00:35:06,079
devices

981
00:35:06,079 --> 00:35:08,160
also ports to

982
00:35:08,160 --> 00:35:09,359
other

983
00:35:09,359 --> 00:35:11,680
cases in new zealand because right now

984
00:35:11,680 --> 00:35:13,119
we can consider that the tool is kind of

985
00:35:13,119 --> 00:35:14,880
a shell and it's possible to modify some

986
00:35:14,880 --> 00:35:16,400
functions that are sent

987
00:35:16,400 --> 00:35:18,720
to the vm and some input handling and it

988
00:35:18,720 --> 00:35:22,000
could be used for other cases

989
00:35:23,200 --> 00:35:25,040
so as a conclusion

990
00:35:25,040 --> 00:35:26,880
the instrumentation goal was reached a

991
00:35:26,880 --> 00:35:28,320
further was written it is coverage

992
00:35:28,320 --> 00:35:30,480
guided it covers the

993
00:35:30,480 --> 00:35:31,920
some binaries in the user end of the

994
00:35:31,920 --> 00:35:34,000
root partition for hyper-v

995
00:35:34,000 --> 00:35:36,160
it's now open source and contributors

996
00:35:36,160 --> 00:35:38,640
are very welcome to participate

997
00:35:38,640 --> 00:35:40,000
the first version was published a few

998
00:35:40,000 --> 00:35:41,680
months ago

999
00:35:41,680 --> 00:35:43,280
and it's still ongoing work

1000
00:35:43,280 --> 00:35:45,599
with more runs expected and some more

1001
00:35:45,599 --> 00:35:48,560
targets in the future

1002
00:35:48,640 --> 00:35:49,839
well thank you very much for your

1003
00:35:49,839 --> 00:35:52,839
attention

1004
00:35:57,630 --> 00:35:58,880
[Music]

1005
00:35:58,880 --> 00:36:00,480
and i will be around if you have any

1006
00:36:00,480 --> 00:36:03,440
questions or you can dm me as well yeah

1007
00:36:03,440 --> 00:36:06,680
thank you

1008
00:36:11,120 --> 00:36:13,760
[Music]

1009
00:36:13,760 --> 00:36:15,839
you

