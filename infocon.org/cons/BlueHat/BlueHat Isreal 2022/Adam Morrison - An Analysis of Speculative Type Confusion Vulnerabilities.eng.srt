1
00:00:00,930 --> 00:00:08,260
[Music]

2
00:00:13,120 --> 00:00:18,160
[Music]

3
00:00:18,160 --> 00:00:19,760
hello everyone

4
00:00:19,760 --> 00:00:22,000
it's great to be here

5
00:00:22,000 --> 00:00:25,359
so i just want to say a few unanimated

6
00:00:25,359 --> 00:00:28,000
words about myself

7
00:00:28,000 --> 00:00:30,160
i'm a professor of computer science at

8
00:00:30,160 --> 00:00:32,079
tel aviv university

9
00:00:32,079 --> 00:00:34,320
but i actually started my career in

10
00:00:34,320 --> 00:00:37,280
computing doing vulnerability research

11
00:00:37,280 --> 00:00:39,440
and then i spent several more years

12
00:00:39,440 --> 00:00:43,200
doing security research in the industry

13
00:00:43,200 --> 00:00:45,760
and then i moved to academia and now i'm

14
00:00:45,760 --> 00:00:48,160
interested in all things that are low

15
00:00:48,160 --> 00:00:50,399
level and involving software hardware

16
00:00:50,399 --> 00:00:52,399
interactions so i'm working on

17
00:00:52,399 --> 00:00:54,399
everything from computer micro

18
00:00:54,399 --> 00:00:57,360
architecture to operating systems but as

19
00:00:57,360 --> 00:01:00,160
we're going to see that still tends to

20
00:01:00,160 --> 00:01:02,960
involve security as well

21
00:01:02,960 --> 00:01:05,199
uh one more important thing to note is

22
00:01:05,199 --> 00:01:07,200
that everything in this talk

23
00:01:07,200 --> 00:01:09,680
is joint work with other kirchner

24
00:01:09,680 --> 00:01:12,159
who did this research for his master's

25
00:01:12,159 --> 00:01:14,400
studies at tel aviv university

26
00:01:14,400 --> 00:01:16,960
and we wrote an academic paper about

27
00:01:16,960 --> 00:01:18,320
this work

28
00:01:18,320 --> 00:01:20,159
it goes into many details that i won't

29
00:01:20,159 --> 00:01:22,159
have time to cover in this talk so if

30
00:01:22,159 --> 00:01:24,320
you find it interesting i encourage you

31
00:01:24,320 --> 00:01:26,799
to look the paper up online and read it

32
00:01:26,799 --> 00:01:29,520
for a very deep dive on all the topics

33
00:01:29,520 --> 00:01:32,799
that i'm going to be talking about here

34
00:01:32,799 --> 00:01:34,640
so this talk is going to be about

35
00:01:34,640 --> 00:01:36,880
speculative execution attacks which are

36
00:01:36,880 --> 00:01:38,720
also called spectre attacks and they

37
00:01:38,720 --> 00:01:41,119
have this cute logo

38
00:01:41,119 --> 00:01:42,960
and you may remember them a few years

39
00:01:42,960 --> 00:01:44,799
ago there were a lot of headlines in the

40
00:01:44,799 --> 00:01:47,520
newspapers about bugs in cpus

41
00:01:47,520 --> 00:01:50,560
particularly intels so these are these

42
00:01:50,560 --> 00:01:53,680
attacks and these are these bugs

43
00:01:53,680 --> 00:01:55,200
and what we're going to do i'm going to

44
00:01:55,200 --> 00:01:56,880
talk about a specific type of

45
00:01:56,880 --> 00:01:59,040
speculative execution attack called

46
00:01:59,040 --> 00:02:01,680
spectre variant one and this is a really

47
00:02:01,680 --> 00:02:03,280
interesting attack

48
00:02:03,280 --> 00:02:05,360
because the cpu vendors said that they

49
00:02:05,360 --> 00:02:07,680
are not going to fix it in hardware what

50
00:02:07,680 --> 00:02:09,280
they want to do is for software

51
00:02:09,280 --> 00:02:10,878
developers to deploy software

52
00:02:10,878 --> 00:02:13,440
mitigations to block these attacks in

53
00:02:13,440 --> 00:02:15,280
software

54
00:02:15,280 --> 00:02:18,080
and software developers usually look at

55
00:02:18,080 --> 00:02:21,200
this attack as being a certain type of

56
00:02:21,200 --> 00:02:24,239
exploit that involves bypassing array

57
00:02:24,239 --> 00:02:25,680
bounce checks

58
00:02:25,680 --> 00:02:27,599
and that's how they do the mitigations

59
00:02:27,599 --> 00:02:29,520
but what i'm going to show you

60
00:02:29,520 --> 00:02:31,760
is that actually

61
00:02:31,760 --> 00:02:33,519
there are many other

62
00:02:33,519 --> 00:02:35,680
attack vectors for exploiting spectral

63
00:02:35,680 --> 00:02:38,080
variant one and these mitigations that

64
00:02:38,080 --> 00:02:40,000
people currently deploy are not always

65
00:02:40,000 --> 00:02:42,160
effective

66
00:02:42,160 --> 00:02:43,040
so

67
00:02:43,040 --> 00:02:45,120
the takeaway here is going to be that

68
00:02:45,120 --> 00:02:46,879
defending from specter variant one is

69
00:02:46,879 --> 00:02:48,640
not a solved problem and current

70
00:02:48,640 --> 00:02:52,640
mitigations may need to be rethought

71
00:02:52,640 --> 00:02:55,200
so let me start with a quick background

72
00:02:55,200 --> 00:02:57,519
about spectre attacks

73
00:02:57,519 --> 00:03:00,319
so in general a spectre attack is any

74
00:03:00,319 --> 00:03:03,680
attack that uses speculative execution

75
00:03:03,680 --> 00:03:06,879
of some gadget code gadget in a victim

76
00:03:06,879 --> 00:03:07,920
program

77
00:03:07,920 --> 00:03:10,400
in order to steal information from the

78
00:03:10,400 --> 00:03:12,480
address space of that program that the

79
00:03:12,480 --> 00:03:14,720
attacker doesn't otherwise have access

80
00:03:14,720 --> 00:03:17,440
to so these are not attacks that do code

81
00:03:17,440 --> 00:03:19,040
execution these are information

82
00:03:19,040 --> 00:03:20,800
disclosure attacks they steal

83
00:03:20,800 --> 00:03:24,080
information from the victim

84
00:03:24,080 --> 00:03:26,400
and specifically spectre variant one is

85
00:03:26,400 --> 00:03:29,120
the subclass of attacks that uses

86
00:03:29,120 --> 00:03:32,080
a conditional branch misprediction for

87
00:03:32,080 --> 00:03:34,560
the speculative execution part

88
00:03:34,560 --> 00:03:36,560
and this is usually described as being a

89
00:03:36,560 --> 00:03:38,720
bounce check bypass attack so that's the

90
00:03:38,720 --> 00:03:40,319
way i'm going to introduce it here as

91
00:03:40,319 --> 00:03:41,840
well

92
00:03:41,840 --> 00:03:44,720
so what happens in this attack is that

93
00:03:44,720 --> 00:03:46,560
there is a code gadget in the victim and

94
00:03:46,560 --> 00:03:49,440
there is some value x that the attacker

95
00:03:49,440 --> 00:03:52,640
can control and the victim uses it to

96
00:03:52,640 --> 00:03:55,120
index into some array and because of

97
00:03:55,120 --> 00:03:55,840
that

98
00:03:55,840 --> 00:03:58,159
it does a bound check before indexing

99
00:03:58,159 --> 00:04:01,519
into the array so in the attack what the

100
00:04:01,519 --> 00:04:03,280
attacker does

101
00:04:03,280 --> 00:04:05,840
they start by executing invoking the

102
00:04:05,840 --> 00:04:08,879
victim many times with an inbound value

103
00:04:08,879 --> 00:04:11,760
of x that passes the bounce check

104
00:04:11,760 --> 00:04:14,400
and this causes the branch prediction

105
00:04:14,400 --> 00:04:18,000
unit of the cpu to learn that the result

106
00:04:18,000 --> 00:04:21,120
of this condition is usually true

107
00:04:21,120 --> 00:04:23,040
then to perform the attack

108
00:04:23,040 --> 00:04:26,160
the attacker causes the cpu to execute

109
00:04:26,160 --> 00:04:28,720
this gadget with an out of bounds value

110
00:04:28,720 --> 00:04:30,080
of x

111
00:04:30,080 --> 00:04:32,320
now in order to compute whether x is

112
00:04:32,320 --> 00:04:34,160
within bounds or not the cpu needs to

113
00:04:34,160 --> 00:04:36,720
read the length of the array for memory

114
00:04:36,720 --> 00:04:39,199
dix this takes its time so in the

115
00:04:39,199 --> 00:04:42,000
meanwhile it predicts what the result of

116
00:04:42,000 --> 00:04:43,840
this condition will be

117
00:04:43,840 --> 00:04:45,440
and because of what it learned

118
00:04:45,440 --> 00:04:47,360
previously it predict it predicts that

119
00:04:47,360 --> 00:04:49,440
the result is going to be true

120
00:04:49,440 --> 00:04:51,919
so it starts executing this code

121
00:04:51,919 --> 00:04:53,520
speculatively

122
00:04:53,520 --> 00:04:55,680
and when it acts when it performs this

123
00:04:55,680 --> 00:04:58,720
code speculatively it uses x to index

124
00:04:58,720 --> 00:05:01,520
into the array x is out of bounds so

125
00:05:01,520 --> 00:05:04,160
basically it reads from some address

126
00:05:04,160 --> 00:05:06,400
that the attacker specified and it reads

127
00:05:06,400 --> 00:05:09,680
the reads it into this variable y

128
00:05:09,680 --> 00:05:12,240
now in order for spectrovant 1 to be

129
00:05:12,240 --> 00:05:14,720
exploitable the code gadget needs to

130
00:05:14,720 --> 00:05:16,800
have the property that the value that

131
00:05:16,800 --> 00:05:20,320
was just read gets passed as and indexed

132
00:05:20,320 --> 00:05:22,080
into another array

133
00:05:22,080 --> 00:05:24,800
and when the cpu executes

134
00:05:24,800 --> 00:05:28,320
this second array access speculatively

135
00:05:28,320 --> 00:05:31,680
what happens is that the cache set that

136
00:05:31,680 --> 00:05:33,919
the value gets loaded into the cache set

137
00:05:33,919 --> 00:05:36,240
that z gets loaded into

138
00:05:36,240 --> 00:05:38,800
depends on the value of y that was read

139
00:05:38,800 --> 00:05:40,639
it depends on the secret that the

140
00:05:40,639 --> 00:05:42,960
attacker wanted to read

141
00:05:42,960 --> 00:05:44,000
okay

142
00:05:44,000 --> 00:05:45,600
and basically this means that in some

143
00:05:45,600 --> 00:05:48,080
sense the state of the cache now encodes

144
00:05:48,080 --> 00:05:49,919
the secret

145
00:05:49,919 --> 00:05:52,880
so eventually the cpu gets the length of

146
00:05:52,880 --> 00:05:54,960
the array for memory and realizes that

147
00:05:54,960 --> 00:05:56,560
everything he did until now was because

148
00:05:56,560 --> 00:05:58,639
of a misprediction this is not code that

149
00:05:58,639 --> 00:06:00,319
was supposed to execute

150
00:06:00,319 --> 00:06:03,199
so it flashes the pipeline and resumes

151
00:06:03,199 --> 00:06:04,960
execution from the condition this time

152
00:06:04,960 --> 00:06:08,080
executing the correct flow of the code

153
00:06:08,080 --> 00:06:11,039
the problem is that unlike the pipeline

154
00:06:11,039 --> 00:06:13,199
the changes made to the cache state are

155
00:06:13,199 --> 00:06:15,199
not flushed and so the cache state

156
00:06:15,199 --> 00:06:17,520
remains dependent on the value of the

157
00:06:17,520 --> 00:06:18,800
secret

158
00:06:18,800 --> 00:06:21,520
and this allows the attacker program to

159
00:06:21,520 --> 00:06:23,520
use some certain sequence of memory

160
00:06:23,520 --> 00:06:26,400
operations that they time in order to

161
00:06:26,400 --> 00:06:30,319
decode the secret from the cash state

162
00:06:30,319 --> 00:06:33,360
so one important thing to note is that

163
00:06:33,360 --> 00:06:35,600
this last part of decoding the secret

164
00:06:35,600 --> 00:06:37,520
from the cache state this is something

165
00:06:37,520 --> 00:06:39,600
called the cache side channel

166
00:06:39,600 --> 00:06:42,000
and more generally a microarchitectural

167
00:06:42,000 --> 00:06:44,880
side channel is any condition in which

168
00:06:44,880 --> 00:06:47,759
some state of the cpu like the cache or

169
00:06:47,759 --> 00:06:50,880
the tlb or the branch predictor becomes

170
00:06:50,880 --> 00:06:53,440
a function of some secret in a way that

171
00:06:53,440 --> 00:06:55,680
allows interacting with this uh

172
00:06:55,680 --> 00:06:58,960
structure and decoding the secret okay

173
00:06:58,960 --> 00:06:59,919
but

174
00:06:59,919 --> 00:07:02,080
side channels these are not new these

175
00:07:02,080 --> 00:07:05,039
are not what made spectre interesting

176
00:07:05,039 --> 00:07:06,639
these were known for a long time in the

177
00:07:06,639 --> 00:07:09,120
context of cryptographic attacks

178
00:07:09,120 --> 00:07:11,360
what made spectre interesting

179
00:07:11,360 --> 00:07:14,160
is the ability to use or abuse

180
00:07:14,160 --> 00:07:16,639
speculative execution in order to read

181
00:07:16,639 --> 00:07:18,639
from anywhere in the victim's program

182
00:07:18,639 --> 00:07:21,199
memory and pass that value through a

183
00:07:21,199 --> 00:07:23,120
side channel to the attacker

184
00:07:23,120 --> 00:07:24,960
so this is what i'm going to focus in

185
00:07:24,960 --> 00:07:27,759
this talk it's about the ability to read

186
00:07:27,759 --> 00:07:29,599
anywhere from memory using speculative

187
00:07:29,599 --> 00:07:32,000
execution not the mechanism that

188
00:07:32,000 --> 00:07:34,240
afterwards gets used in order to leak

189
00:07:34,240 --> 00:07:35,440
the value

190
00:07:35,440 --> 00:07:37,680
okay

191
00:07:37,919 --> 00:07:39,759
and you might ask yourselves

192
00:07:39,759 --> 00:07:41,520
where do we find a situation in which an

193
00:07:41,520 --> 00:07:43,840
attacker program runs on the same cpu as

194
00:07:43,840 --> 00:07:45,680
the victim in order to read from the

195
00:07:45,680 --> 00:07:47,280
side channel

196
00:07:47,280 --> 00:07:50,240
and one good answer is the operating

197
00:07:50,240 --> 00:07:52,319
system kernel specifically in this case

198
00:07:52,319 --> 00:07:53,280
linux

199
00:07:53,280 --> 00:07:55,280
because the operating system

200
00:07:55,280 --> 00:07:57,680
is by definition a program that has to

201
00:07:57,680 --> 00:08:00,319
share the cpu with interested parties

202
00:08:00,319 --> 00:08:02,479
these are the untrusted and privileged

203
00:08:02,479 --> 00:08:04,240
processes that the operating system

204
00:08:04,240 --> 00:08:05,199
manages

205
00:08:05,199 --> 00:08:06,479
so if we

206
00:08:06,479 --> 00:08:09,039
continue this the example in the context

207
00:08:09,039 --> 00:08:12,240
of our operating system this gadget full

208
00:08:12,240 --> 00:08:14,400
can be something that that gets executed

209
00:08:14,400 --> 00:08:16,560
in the flow of some system call that the

210
00:08:16,560 --> 00:08:19,440
process can invoke and by exploiting the

211
00:08:19,440 --> 00:08:21,680
attack the process can read

212
00:08:21,680 --> 00:08:23,360
from any address in the kernel adder

213
00:08:23,360 --> 00:08:25,840
space and this means that basically it

214
00:08:25,840 --> 00:08:27,440
can read from any address in the

215
00:08:27,440 --> 00:08:29,599
physical memory of the machine because

216
00:08:29,599 --> 00:08:31,840
the kernel maps all physical memory into

217
00:08:31,840 --> 00:08:33,760
its address space so this attack allows

218
00:08:33,760 --> 00:08:35,039
the process to read from anywhere in

219
00:08:35,039 --> 00:08:37,760
memory read passwords read credit cards

220
00:08:37,760 --> 00:08:40,080
whatever it wants can it can read from

221
00:08:40,080 --> 00:08:43,200
from the physical memory

222
00:08:43,360 --> 00:08:44,480
and

223
00:08:44,480 --> 00:08:47,279
spectre variant one is caused in some

224
00:08:47,279 --> 00:08:48,959
sense by the speculative execution

225
00:08:48,959 --> 00:08:51,040
feature of the hardware but it also

226
00:08:51,040 --> 00:08:53,760
requires like you saw the victim to have

227
00:08:53,760 --> 00:08:55,920
a certain code gadget so i'm not sure

228
00:08:55,920 --> 00:08:58,800
but perhaps because of this cpu vendor

229
00:08:58,800 --> 00:09:00,480
said that they are not going to fix it

230
00:09:00,480 --> 00:09:01,760
in hardware they are not going to

231
00:09:01,760 --> 00:09:03,680
disable speculative execution because

232
00:09:03,680 --> 00:09:05,839
it's very important for performance

233
00:09:05,839 --> 00:09:08,640
instead they direct developers to use

234
00:09:08,640 --> 00:09:10,640
software mitigations

235
00:09:10,640 --> 00:09:14,000
in order to block these kinds of attacks

236
00:09:14,000 --> 00:09:16,320
so let's look at what developers did so

237
00:09:16,320 --> 00:09:19,200
what they did in linux is they use a

238
00:09:19,200 --> 00:09:21,360
manual mitigation approach basically if

239
00:09:21,360 --> 00:09:23,440
you're a linux developer you need

240
00:09:23,440 --> 00:09:25,040
whenever you have an array access you

241
00:09:25,040 --> 00:09:27,279
need to think about can the index into

242
00:09:27,279 --> 00:09:28,880
the array be something that is

243
00:09:28,880 --> 00:09:31,600
controlled by an attacker and if so you

244
00:09:31,600 --> 00:09:34,080
need to use a special api to do the

245
00:09:34,080 --> 00:09:36,000
indexing you don't do regular indexing

246
00:09:36,000 --> 00:09:39,200
you use this array index no spec api

247
00:09:39,200 --> 00:09:41,120
and this is an api that internally makes

248
00:09:41,120 --> 00:09:43,600
sure that the access is going to always

249
00:09:43,600 --> 00:09:46,160
going to be within bounds even under

250
00:09:46,160 --> 00:09:48,399
incorrect speculation and of course it's

251
00:09:48,399 --> 00:09:51,680
a bit slower than a regular array access

252
00:09:51,680 --> 00:09:52,800
okay

253
00:09:52,800 --> 00:09:54,480
but

254
00:09:54,480 --> 00:09:56,880
this mitigation has a conceptual problem

255
00:09:56,880 --> 00:09:59,760
because it's only targeting array bounce

256
00:09:59,760 --> 00:10:02,240
checking and if you go back and read the

257
00:10:02,240 --> 00:10:04,399
spectral paper and see the definition of

258
00:10:04,399 --> 00:10:06,560
spectral variant one it's much more

259
00:10:06,560 --> 00:10:09,040
general it says that spectral variant

260
00:10:09,040 --> 00:10:11,440
one is any case where a branch

261
00:10:11,440 --> 00:10:13,920
misprediction causes the cpu to

262
00:10:13,920 --> 00:10:16,640
temporarily violate program semantics by

263
00:10:16,640 --> 00:10:18,399
executing code that would not have been

264
00:10:18,399 --> 00:10:21,519
executed otherwise so in principle there

265
00:10:21,519 --> 00:10:23,279
can be many other ways to exploit

266
00:10:23,279 --> 00:10:25,040
spectral variant one

267
00:10:25,040 --> 00:10:27,120
and i'm going to talk about exactly one

268
00:10:27,120 --> 00:10:29,600
such way which is called speculative

269
00:10:29,600 --> 00:10:31,519
type confusion

270
00:10:31,519 --> 00:10:33,600
so speculative type confusion

271
00:10:33,600 --> 00:10:35,920
is an incorrect execution in which the

272
00:10:35,920 --> 00:10:37,760
wrong speculation

273
00:10:37,760 --> 00:10:39,680
causes the code to execute with some

274
00:10:39,680 --> 00:10:42,000
variables having values of the wrong

275
00:10:42,000 --> 00:10:44,320
type and because of this

276
00:10:44,320 --> 00:10:47,200
the program leaks information

277
00:10:47,200 --> 00:10:48,000
okay

278
00:10:48,000 --> 00:10:50,640
so let me show you an example

279
00:10:50,640 --> 00:10:53,440
so speculative type confusion was mainly

280
00:10:53,440 --> 00:10:55,839
theorized about and even these theories

281
00:10:55,839 --> 00:10:58,240
were in the context of most only

282
00:10:58,240 --> 00:11:00,720
polymorphic object-oriented code like in

283
00:11:00,720 --> 00:11:03,279
this example so what we see here is a

284
00:11:03,279 --> 00:11:05,040
function that is maybe called by some

285
00:11:05,040 --> 00:11:06,880
system call

286
00:11:06,880 --> 00:11:08,959
and the argument to this function is

287
00:11:08,959 --> 00:11:12,000
some object from a base class

288
00:11:12,000 --> 00:11:14,880
the function uses the type field in the

289
00:11:14,880 --> 00:11:18,240
object to derive a specific type a

290
00:11:18,240 --> 00:11:20,640
subtype of the object

291
00:11:20,640 --> 00:11:23,279
and then it acts accordingly so if the

292
00:11:23,279 --> 00:11:25,839
it gets past an object of type one it

293
00:11:25,839 --> 00:11:28,560
does this code which reads some value

294
00:11:28,560 --> 00:11:30,800
from the object and then does some

295
00:11:30,800 --> 00:11:32,959
operation that maybe leaks this value

296
00:11:32,959 --> 00:11:35,040
over a side channel

297
00:11:35,040 --> 00:11:35,920
okay

298
00:11:35,920 --> 00:11:38,240
now how what does speculative type

299
00:11:38,240 --> 00:11:40,000
confusion mean

300
00:11:40,000 --> 00:11:42,160
what happens if this function is called

301
00:11:42,160 --> 00:11:44,240
with an object of type two

302
00:11:44,240 --> 00:11:46,640
but because of branch misprediction it's

303
00:11:46,640 --> 00:11:49,279
still the cpu still executes the code of

304
00:11:49,279 --> 00:11:50,480
type one

305
00:11:50,480 --> 00:11:52,240
then what happens it's going to read

306
00:11:52,240 --> 00:11:54,639
some field but it's going to be a field

307
00:11:54,639 --> 00:11:57,600
in the type 2 object not type 1 and this

308
00:11:57,600 --> 00:11:59,440
might field might contain secret

309
00:11:59,440 --> 00:12:01,920
information that again that then is

310
00:12:01,920 --> 00:12:04,000
going to get leaked

311
00:12:04,000 --> 00:12:05,440
okay so

312
00:12:05,440 --> 00:12:07,440
not sure if you are very impressed by

313
00:12:07,440 --> 00:12:10,639
this example maybe it seems contrived

314
00:12:10,639 --> 00:12:13,440
but the main observation of our work was

315
00:12:13,440 --> 00:12:15,760
that speculative type confusion can be

316
00:12:15,760 --> 00:12:18,399
much more prevalent than just what this

317
00:12:18,399 --> 00:12:20,160
example shows

318
00:12:20,160 --> 00:12:21,040
and

319
00:12:21,040 --> 00:12:23,600
in fact it can be even

320
00:12:23,600 --> 00:12:25,920
exist in benign code without the

321
00:12:25,920 --> 00:12:28,480
programmer realizing that it's there

322
00:12:28,480 --> 00:12:30,800
so we did an analysis of the linux

323
00:12:30,800 --> 00:12:32,800
kernel looking for speculative type

324
00:12:32,800 --> 00:12:34,399
confusion

325
00:12:34,399 --> 00:12:36,320
and we actually found new types of

326
00:12:36,320 --> 00:12:38,959
specular type confusion we found both

327
00:12:38,959 --> 00:12:41,760
exploitable vulnerabilities and latent

328
00:12:41,760 --> 00:12:43,519
vulnerabilities which currently are not

329
00:12:43,519 --> 00:12:45,680
exploitable but they can

330
00:12:45,680 --> 00:12:47,600
but they're not exploitable by luck not

331
00:12:47,600 --> 00:12:50,399
by design and any small code change

332
00:12:50,399 --> 00:12:52,959
might might make them exploitable

333
00:12:52,959 --> 00:12:55,440
so what i'm going to show you

334
00:12:55,440 --> 00:12:56,720
we found

335
00:12:56,720 --> 00:12:59,600
that attackers can introduce

336
00:12:59,600 --> 00:13:02,240
vulnerabilities into the linux ebpf

337
00:13:02,240 --> 00:13:04,240
subsystem

338
00:13:04,240 --> 00:13:06,399
we found that the compiler can

339
00:13:06,399 --> 00:13:08,880
inadvertently introduce vulnerabilities

340
00:13:08,880 --> 00:13:11,760
when compiling benign code

341
00:13:11,760 --> 00:13:13,839
and we found many many latent

342
00:13:13,839 --> 00:13:17,839
vulnerabilities related to polymorphism

343
00:13:17,839 --> 00:13:19,839
so let's start with speculative type

344
00:13:19,839 --> 00:13:23,519
confusion in the ebpf subsystem

345
00:13:23,519 --> 00:13:25,200
what is ebpf

346
00:13:25,200 --> 00:13:27,920
ebpf is a feature of linux which allows

347
00:13:27,920 --> 00:13:30,480
unprivileged processes to load small

348
00:13:30,480 --> 00:13:32,959
programs into the kernel that then run

349
00:13:32,959 --> 00:13:35,200
in kernel context and this is useful for

350
00:13:35,200 --> 00:13:37,279
performance monitoring and all kinds of

351
00:13:37,279 --> 00:13:38,480
other things

352
00:13:38,480 --> 00:13:40,560
of course it seems also very dangerous

353
00:13:40,560 --> 00:13:43,199
right we allow untrusted code to

354
00:13:43,199 --> 00:13:45,360
intercept processes to upload code into

355
00:13:45,360 --> 00:13:47,440
the kernel so how does how is this

356
00:13:47,440 --> 00:13:49,600
supposed to be secure

357
00:13:49,600 --> 00:13:52,160
the idea is that the program is written

358
00:13:52,160 --> 00:13:54,399
in a special byte code called an ebpf

359
00:13:54,399 --> 00:13:55,600
byte code

360
00:13:55,600 --> 00:13:57,760
and then gets uploaded into the kernel

361
00:13:57,760 --> 00:13:59,440
with a system call

362
00:13:59,440 --> 00:14:01,839
before the kernel executes the program

363
00:14:01,839 --> 00:14:03,920
it does some analysis to make sure that

364
00:14:03,920 --> 00:14:05,839
the program is safe

365
00:14:05,839 --> 00:14:07,760
so one thing the kernel does

366
00:14:07,760 --> 00:14:10,639
is it runs a static analysis in order to

367
00:14:10,639 --> 00:14:12,480
verify that the program is safe that it

368
00:14:12,480 --> 00:14:14,959
doesn't try to read from kernel memory

369
00:14:14,959 --> 00:14:17,600
but it doesn't have buffer overflows but

370
00:14:17,600 --> 00:14:19,120
running this program will be safe for

371
00:14:19,120 --> 00:14:20,320
the kernel

372
00:14:20,320 --> 00:14:23,040
and after spectre was discovered they

373
00:14:23,040 --> 00:14:26,240
also started adding spectral variant

374
00:14:26,240 --> 00:14:29,199
spectral mitigations into the bytecode

375
00:14:29,199 --> 00:14:31,360
specifically for spectral variant one

376
00:14:31,360 --> 00:14:33,920
they add mitigations for array bounds

377
00:14:33,920 --> 00:14:35,760
checking so essentially they put this

378
00:14:35,760 --> 00:14:38,639
array index no spec type of thing into

379
00:14:38,639 --> 00:14:40,959
the uploaded ebpf code

380
00:14:40,959 --> 00:14:43,040
and after all of this happens

381
00:14:43,040 --> 00:14:46,240
the ebpf bytecode gets compiled into x86

382
00:14:46,240 --> 00:14:48,199
bytecode and

383
00:14:48,199 --> 00:14:51,360
x8x6x86 native code which can then run

384
00:14:51,360 --> 00:14:54,079
inside the kernel

385
00:14:54,079 --> 00:14:55,760
so what's the problem what's the

386
00:14:55,760 --> 00:14:58,720
vulnerability that we found in evps

387
00:14:58,720 --> 00:14:59,680
so

388
00:14:59,680 --> 00:15:01,920
let me show you this by example

389
00:15:01,920 --> 00:15:04,399
consider this ebpf program that can get

390
00:15:04,399 --> 00:15:06,240
uploaded into the kernel

391
00:15:06,240 --> 00:15:08,800
what this program does it reads from

392
00:15:08,800 --> 00:15:10,000
some

393
00:15:10,000 --> 00:15:12,720
value in memory from some array

394
00:15:12,720 --> 00:15:15,760
it reads the value into register r0 and

395
00:15:15,760 --> 00:15:18,399
then it checks what the value was and

396
00:15:18,399 --> 00:15:20,320
act accordingly

397
00:15:20,320 --> 00:15:22,160
if r0

398
00:15:22,160 --> 00:15:23,519
equals 0

399
00:15:23,519 --> 00:15:25,680
the program does a register to register

400
00:15:25,680 --> 00:15:29,199
transfer it overwrites register r6 with

401
00:15:29,199 --> 00:15:32,720
the value of register r9 and register r9

402
00:15:32,720 --> 00:15:34,480
initially in the program contains some

403
00:15:34,480 --> 00:15:36,320
scalar some constant

404
00:15:36,320 --> 00:15:38,320
that is a stacker control because it's

405
00:15:38,320 --> 00:15:40,079
part of the program and remember the

406
00:15:40,079 --> 00:15:41,759
attacker supplies the program an

407
00:15:41,759 --> 00:15:44,720
untrusted process supplies the program

408
00:15:44,720 --> 00:15:48,240
if r0 is not 0 if r0 is 1

409
00:15:48,240 --> 00:15:50,320
the program does something else it

410
00:15:50,320 --> 00:15:53,040
dereferences register r6

411
00:15:53,040 --> 00:15:54,560
which originally

412
00:15:54,560 --> 00:15:56,320
points to some local variable on the

413
00:15:56,320 --> 00:15:59,360
stack so it does a read from the stack

414
00:15:59,360 --> 00:16:01,759
and then it uses it to index an array

415
00:16:01,759 --> 00:16:03,759
which also leaks the value but that's

416
00:16:03,759 --> 00:16:05,600
okay because it's some local variable on

417
00:16:05,600 --> 00:16:07,600
the stack it doesn't contain anything

418
00:16:07,600 --> 00:16:09,040
sensitive

419
00:16:09,040 --> 00:16:11,040
okay so this is the program

420
00:16:11,040 --> 00:16:12,320
now what does the

421
00:16:12,320 --> 00:16:14,880
ebpf verifier do in order to decide that

422
00:16:14,880 --> 00:16:17,440
this program is safe to run

423
00:16:17,440 --> 00:16:19,120
the way it works is that it basically

424
00:16:19,120 --> 00:16:21,519
enumerates all possible executions of

425
00:16:21,519 --> 00:16:24,000
the program checks it's actually that

426
00:16:24,000 --> 00:16:26,720
each each execution is safe and if all

427
00:16:26,720 --> 00:16:28,320
executions are safe then it lets the

428
00:16:28,320 --> 00:16:30,399
program execute so let's see what it

429
00:16:30,399 --> 00:16:31,839
does

430
00:16:31,839 --> 00:16:33,839
first it looks into the execution in

431
00:16:33,839 --> 00:16:37,199
which the first condition evaluates to

432
00:16:37,199 --> 00:16:38,240
false

433
00:16:38,240 --> 00:16:40,800
in this case it means that

434
00:16:40,800 --> 00:16:42,399
what the program does is register to

435
00:16:42,399 --> 00:16:44,800
register transfer this is safe

436
00:16:44,800 --> 00:16:47,519
and the ebpf verifier also learns that

437
00:16:47,519 --> 00:16:50,639
r0 must be zero and because of this it

438
00:16:50,639 --> 00:16:53,040
cannot be that the second condition

439
00:16:53,040 --> 00:16:55,519
evaluates to false so overall this

440
00:16:55,519 --> 00:16:58,639
execution is considered to be safe

441
00:16:58,639 --> 00:17:00,880
another possible execution is the one in

442
00:17:00,880 --> 00:17:01,680
which

443
00:17:01,680 --> 00:17:03,839
the first condition evaluates to true

444
00:17:03,839 --> 00:17:05,439
and the second condition evaluates to

445
00:17:05,439 --> 00:17:06,559
false

446
00:17:06,559 --> 00:17:08,720
in this execution the program reads for

447
00:17:08,720 --> 00:17:10,959
memory which is potentially risky but

448
00:17:10,959 --> 00:17:14,000
the ebpf verify knows that r6 points to

449
00:17:14,000 --> 00:17:16,559
a local variable on the stack so this is

450
00:17:16,559 --> 00:17:18,559
also okay and it considers this

451
00:17:18,559 --> 00:17:20,720
execution safe as well

452
00:17:20,720 --> 00:17:22,559
and finally there is an execution in

453
00:17:22,559 --> 00:17:23,359
which

454
00:17:23,359 --> 00:17:25,839
both of these conditions value to true

455
00:17:25,839 --> 00:17:28,079
so the program does basically nothing

456
00:17:28,079 --> 00:17:30,799
and of course this is safe overall the

457
00:17:30,799 --> 00:17:33,280
ebpf verifier checked all the flows and

458
00:17:33,280 --> 00:17:35,200
it concludes that this is a safe program

459
00:17:35,200 --> 00:17:36,960
to execute

460
00:17:36,960 --> 00:17:38,559
but what's the issue what's the

461
00:17:38,559 --> 00:17:40,799
vulnerability the problem is that the

462
00:17:40,799 --> 00:17:43,840
verifier doesn't consider flows that can

463
00:17:43,840 --> 00:17:46,000
happen because of speculative execution

464
00:17:46,000 --> 00:17:48,160
incorrect flows that can happen because

465
00:17:48,160 --> 00:17:50,480
of speculative execution

466
00:17:50,480 --> 00:17:52,640
and if we have an execution in which the

467
00:17:52,640 --> 00:17:55,760
first condition is predicted false

468
00:17:55,760 --> 00:17:57,520
and the second condition is also

469
00:17:57,520 --> 00:17:59,039
predicted false

470
00:17:59,039 --> 00:18:01,679
then we get this kind of funny execution

471
00:18:01,679 --> 00:18:05,760
in which r0 is both zero and one

472
00:18:05,760 --> 00:18:07,600
and the sequence of instructions that

473
00:18:07,600 --> 00:18:10,160
the cpu will speculatively execute will

474
00:18:10,160 --> 00:18:13,440
put r9 into r6 so r6 will now have an

475
00:18:13,440 --> 00:18:15,440
attacker controlled scalar

476
00:18:15,440 --> 00:18:17,840
the reference r6 so read from the

477
00:18:17,840 --> 00:18:20,160
address the attacker supplied and then

478
00:18:20,160 --> 00:18:22,400
leak it over a side channel and this

479
00:18:22,400 --> 00:18:23,919
allows the attacker to read from

480
00:18:23,919 --> 00:18:26,400
anywhere in physical memory

481
00:18:26,400 --> 00:18:27,760
okay

482
00:18:27,760 --> 00:18:29,919
what's the problem the main challenge of

483
00:18:29,919 --> 00:18:32,160
making this attack work

484
00:18:32,160 --> 00:18:34,400
how do we get the cpu to do this kind of

485
00:18:34,400 --> 00:18:36,400
prediction predicting that both of these

486
00:18:36,400 --> 00:18:38,400
branches will be false

487
00:18:38,400 --> 00:18:40,720
and the issue is that if you try to do

488
00:18:40,720 --> 00:18:42,880
something like what i described earlier

489
00:18:42,880 --> 00:18:45,120
basically running the program many times

490
00:18:45,120 --> 00:18:47,039
giving it values hoping that the branch

491
00:18:47,039 --> 00:18:50,400
predictor will learn the outcome that we

492
00:18:50,400 --> 00:18:51,200
want

493
00:18:51,200 --> 00:18:52,720
this will never work because these

494
00:18:52,720 --> 00:18:54,960
branches are mutually exclusive

495
00:18:54,960 --> 00:18:57,360
if the first one evaluates to false then

496
00:18:57,360 --> 00:18:58,799
the second one will not evaluate to

497
00:18:58,799 --> 00:19:01,039
false and vice versa so no matter how

498
00:19:01,039 --> 00:19:02,799
you run this program the branch

499
00:19:02,799 --> 00:19:05,360
predictor will never be convinced that

500
00:19:05,360 --> 00:19:07,600
both of these branches should be false

501
00:19:07,600 --> 00:19:09,039
the both of the conditions should be

502
00:19:09,039 --> 00:19:12,559
false in the same time

503
00:19:12,559 --> 00:19:13,440
so

504
00:19:13,440 --> 00:19:14,160
to

505
00:19:14,160 --> 00:19:15,760
solve this challenge

506
00:19:15,760 --> 00:19:18,720
we use a technique called out of place

507
00:19:18,720 --> 00:19:19,840
training

508
00:19:19,840 --> 00:19:22,400
instead of running the actual invoking

509
00:19:22,400 --> 00:19:24,960
the actual ebpf program

510
00:19:24,960 --> 00:19:26,640
we allocate

511
00:19:26,640 --> 00:19:29,200
some code gadget in the address space of

512
00:19:29,200 --> 00:19:31,280
the attacking process this is called the

513
00:19:31,280 --> 00:19:34,000
shadow gadget it contains contains

514
00:19:34,000 --> 00:19:37,520
exactly the same x86 code that the

515
00:19:37,520 --> 00:19:40,480
compiled ebpf code will contain

516
00:19:40,480 --> 00:19:42,559
with one small difference

517
00:19:42,559 --> 00:19:44,400
the conditions here are slightly

518
00:19:44,400 --> 00:19:46,400
different now now instead of mutually

519
00:19:46,400 --> 00:19:49,039
exclusive they are the same condition

520
00:19:49,039 --> 00:19:51,440
and then it can it's automatically the

521
00:19:51,440 --> 00:19:53,280
case that if one of them is false then

522
00:19:53,280 --> 00:19:55,120
both of them are false

523
00:19:55,120 --> 00:19:57,440
and the trick is that

524
00:19:57,440 --> 00:19:59,600
the address in the process memory where

525
00:19:59,600 --> 00:20:01,679
we put the shadow gadget

526
00:20:01,679 --> 00:20:03,840
is picked very carefully

527
00:20:03,840 --> 00:20:06,799
so that the a branch predictor unit

528
00:20:06,799 --> 00:20:09,760
entries that these branches mapped to

529
00:20:09,760 --> 00:20:11,679
are exactly the same branch predictor

530
00:20:11,679 --> 00:20:13,760
unit entries that the branches in the

531
00:20:13,760 --> 00:20:15,919
ebpf code in the kernel mapped to the

532
00:20:15,919 --> 00:20:18,640
cpu only has one branch predictor so

533
00:20:18,640 --> 00:20:19,679
everything

534
00:20:19,679 --> 00:20:21,679
maps to the same branch predictor unit

535
00:20:21,679 --> 00:20:23,360
and this means that by training the

536
00:20:23,360 --> 00:20:24,960
shadow gadget

537
00:20:24,960 --> 00:20:28,159
we also influence actually determine the

538
00:20:28,159 --> 00:20:29,919
decisions that the branch predictor will

539
00:20:29,919 --> 00:20:32,400
make when it executes the ebpf program

540
00:20:32,400 --> 00:20:34,240
in the kernel

541
00:20:34,240 --> 00:20:36,320
so after doing this kind of training we

542
00:20:36,320 --> 00:20:38,080
can actually perform the attack that i

543
00:20:38,080 --> 00:20:40,080
just described well there actually

544
00:20:40,080 --> 00:20:41,919
there's a lot more work involved but

545
00:20:41,919 --> 00:20:43,919
that's the high level idea

546
00:20:43,919 --> 00:20:46,320
and we're able to have an unprivileged

547
00:20:46,320 --> 00:20:47,440
process

548
00:20:47,440 --> 00:20:50,159
read from any others in physical memory

549
00:20:50,159 --> 00:20:53,760
at a rate of 6.5 kilobytes per second

550
00:20:53,760 --> 00:20:56,320
which doesn't sound like a lot but for a

551
00:20:56,320 --> 00:20:59,200
side channel it's not bad

552
00:20:59,200 --> 00:21:01,039
okay and this is something that we

553
00:21:01,039 --> 00:21:03,520
disclosed to the linux community and it

554
00:21:03,520 --> 00:21:07,360
was fixed a few months ago

555
00:21:07,360 --> 00:21:09,679
next i'm going to talk about compiler

556
00:21:09,679 --> 00:21:12,640
introduce speculative type confusion

557
00:21:12,640 --> 00:21:15,760
so the observation here is that benign

558
00:21:15,760 --> 00:21:16,799
code

559
00:21:16,799 --> 00:21:19,760
might the compiler might inadvertently

560
00:21:19,760 --> 00:21:22,080
introduce speculative type confusion

561
00:21:22,080 --> 00:21:24,400
vulnerabilities into completely benign

562
00:21:24,400 --> 00:21:26,960
code because the compiler the compiler

563
00:21:26,960 --> 00:21:29,840
does optimizations that

564
00:21:29,840 --> 00:21:32,159
depend on reasoning about only correct

565
00:21:32,159 --> 00:21:34,559
flows and not incorrect flows so let me

566
00:21:34,559 --> 00:21:36,640
show you an example

567
00:21:36,640 --> 00:21:38,799
let's consider this flow this is a c

568
00:21:38,799 --> 00:21:41,200
function that maybe exists in the kernel

569
00:21:41,200 --> 00:21:43,120
it has these two mutually exclusive

570
00:21:43,120 --> 00:21:45,520
brand conditions similar to what we have

571
00:21:45,520 --> 00:21:47,280
in the ebpf gadget

572
00:21:47,280 --> 00:21:49,600
and in the second condition it's the

573
00:21:49,600 --> 00:21:51,039
reference says

574
00:21:51,039 --> 00:21:53,840
a some pointer sorry it references some

575
00:21:53,840 --> 00:21:56,080
pointer which is trusted it's a kernel

576
00:21:56,080 --> 00:21:59,200
supplied supplied the pointer

577
00:21:59,200 --> 00:22:00,080
now

578
00:22:00,080 --> 00:22:02,559
when the compiler compiles this code it

579
00:22:02,559 --> 00:22:05,039
might reason that because these branches

580
00:22:05,039 --> 00:22:07,919
are mutually exclusive it doesn't if if

581
00:22:07,919 --> 00:22:10,559
the first condition is true then nothing

582
00:22:10,559 --> 00:22:13,120
that happens inside this is block can

583
00:22:13,120 --> 00:22:15,360
affect what happens in the second block

584
00:22:15,360 --> 00:22:17,520
so the compiler might put may put might

585
00:22:17,520 --> 00:22:19,200
put here some code

586
00:22:19,200 --> 00:22:22,000
that overwrites register rsi

587
00:22:22,000 --> 00:22:23,679
which is the register that contains the

588
00:22:23,679 --> 00:22:26,320
ptr argument overwrite it with some

589
00:22:26,320 --> 00:22:29,440
value a scalar value x that is

590
00:22:29,440 --> 00:22:31,200
controlled by an attacker that is not

591
00:22:31,200 --> 00:22:33,600
trusted by the kernel

592
00:22:33,600 --> 00:22:36,000
and then you know what's coming next

593
00:22:36,000 --> 00:22:38,400
next if an attacker is able to train the

594
00:22:38,400 --> 00:22:40,080
branches

595
00:22:40,080 --> 00:22:42,240
such that both of them predict to be

596
00:22:42,240 --> 00:22:43,520
true

597
00:22:43,520 --> 00:22:46,000
then we get an execution in which the

598
00:22:46,000 --> 00:22:48,240
value x is a

599
00:22:48,240 --> 00:22:50,559
written to rsi and then the cpu

600
00:22:50,559 --> 00:22:52,400
continues and happily executes the

601
00:22:52,400 --> 00:22:54,640
reference but instead of the referencing

602
00:22:54,640 --> 00:22:56,880
the ptr argument it dereferences the

603
00:22:56,880 --> 00:22:59,039
attacker-supplied address x

604
00:22:59,039 --> 00:23:01,280
leaks the value and again allows the

605
00:23:01,280 --> 00:23:02,720
attacker to read from anywhere in

606
00:23:02,720 --> 00:23:04,320
physical memory

607
00:23:04,320 --> 00:23:06,080
okay and the

608
00:23:06,080 --> 00:23:08,720
scary thing about this example is that

609
00:23:08,720 --> 00:23:12,159
the untrusted value x is not used in any

610
00:23:12,159 --> 00:23:13,679
dangerous way in the code it's not an

611
00:23:13,679 --> 00:23:16,559
indexed into an array um nothing depends

612
00:23:16,559 --> 00:23:19,039
on it here and so a programmer looking

613
00:23:19,039 --> 00:23:20,799
at this code would have no idea that

614
00:23:20,799 --> 00:23:23,840
they need to put some manual mitigation

615
00:23:23,840 --> 00:23:25,679
in order to stop speculative execution

616
00:23:25,679 --> 00:23:27,520
attacks

617
00:23:27,520 --> 00:23:28,960
now

618
00:23:28,960 --> 00:23:30,960
we wanted to see we came up with this

619
00:23:30,960 --> 00:23:33,039
example and we wanted to see does it

620
00:23:33,039 --> 00:23:35,440
actually happen in the kernel in the

621
00:23:35,440 --> 00:23:37,200
real in real life

622
00:23:37,200 --> 00:23:40,880
so we ran a binary analysis of multiple

623
00:23:40,880 --> 00:23:42,720
linux binaries

624
00:23:42,720 --> 00:23:45,200
and we focused on analyzing the code of

625
00:23:45,200 --> 00:23:47,200
system calls because that's the main way

626
00:23:47,200 --> 00:23:48,720
for processes to interact with the

627
00:23:48,720 --> 00:23:50,400
kernel

628
00:23:50,400 --> 00:23:52,400
and the thing that we looked for is the

629
00:23:52,400 --> 00:23:55,200
ability of speculative execution to read

630
00:23:55,200 --> 00:23:57,279
from an attacker's supplied value we

631
00:23:57,279 --> 00:23:58,960
didn't really care if it gets leaked

632
00:23:58,960 --> 00:24:00,880
afterwards because there are many ways

633
00:24:00,880 --> 00:24:02,799
for things to leak and it can depend on

634
00:24:02,799 --> 00:24:05,200
how the code changes over time

635
00:24:05,200 --> 00:24:06,880
the the interesting thing here is can

636
00:24:06,880 --> 00:24:09,120
the attacker like break the

637
00:24:09,120 --> 00:24:11,360
architectural contract and make the

638
00:24:11,360 --> 00:24:14,720
kernel read from an address they supply

639
00:24:14,720 --> 00:24:17,279
and the summary of our results is that

640
00:24:17,279 --> 00:24:19,279
we've actually found

641
00:24:19,279 --> 00:24:21,600
a compiler introduced vulnerabilities in

642
00:24:21,600 --> 00:24:24,000
the kernel and interestingly they were

643
00:24:24,000 --> 00:24:25,840
not like the example that they just gave

644
00:24:25,840 --> 00:24:27,760
they were different so let me show you a

645
00:24:27,760 --> 00:24:29,760
couple of examples

646
00:24:29,760 --> 00:24:32,559
so one gadget that we found

647
00:24:32,559 --> 00:24:35,120
quite a few instances of looks something

648
00:24:35,120 --> 00:24:36,400
like this

649
00:24:36,400 --> 00:24:39,520
you have a system call that takes

650
00:24:39,520 --> 00:24:42,480
some pointer supplied by user space

651
00:24:42,480 --> 00:24:45,679
and it checks if the pointer is not null

652
00:24:45,679 --> 00:24:47,919
then it copies it this is a safe copy

653
00:24:47,919 --> 00:24:50,400
from user memory into kernel memory

654
00:24:50,400 --> 00:24:52,400
copies it into some local variable on

655
00:24:52,400 --> 00:24:53,679
the stack

656
00:24:53,679 --> 00:24:56,080
and then it passes it to some helper

657
00:24:56,080 --> 00:24:57,039
function

658
00:24:57,039 --> 00:24:59,520
and if the user pointer is null then the

659
00:24:59,520 --> 00:25:01,279
helper function is called with the value

660
00:25:01,279 --> 00:25:02,400
null

661
00:25:02,400 --> 00:25:03,279
okay

662
00:25:03,279 --> 00:25:05,039
so this looks

663
00:25:05,039 --> 00:25:06,720
okay this looks safe

664
00:25:06,720 --> 00:25:08,799
but now let's look at how this code gets

665
00:25:08,799 --> 00:25:10,799
compiled

666
00:25:10,799 --> 00:25:12,559
and if you look at the assembly what

667
00:25:12,559 --> 00:25:14,480
happens is that the

668
00:25:14,480 --> 00:25:16,880
use the user pointer is in the rdi

669
00:25:16,880 --> 00:25:19,120
register which is the rdi that

670
00:25:19,120 --> 00:25:22,000
the register that is used to hold the

671
00:25:22,000 --> 00:25:24,080
first argument of a function

672
00:25:24,080 --> 00:25:25,360
so

673
00:25:25,360 --> 00:25:28,240
what the compiler does is it checks if

674
00:25:28,240 --> 00:25:31,520
rdi is null and if so it immediately

675
00:25:31,520 --> 00:25:34,559
jumps to the helper function it doesn't

676
00:25:34,559 --> 00:25:36,159
do so it doesn't do what the c code

677
00:25:36,159 --> 00:25:40,000
would make you think which is past null

678
00:25:40,000 --> 00:25:42,400
write the argument to be null it uses

679
00:25:42,400 --> 00:25:44,559
the knowledge that it just tested that

680
00:25:44,559 --> 00:25:47,120
rdi is null and invokes the helper

681
00:25:47,120 --> 00:25:49,360
function passing it rdi

682
00:25:49,360 --> 00:25:51,679
and if rdi is not null then it goes into

683
00:25:51,679 --> 00:25:54,320
some code that does the memory copy it

684
00:25:54,320 --> 00:25:56,559
and in the end it moves

685
00:25:56,559 --> 00:25:59,760
uh the stack pointer into rdi so that

686
00:25:59,760 --> 00:26:01,520
the function runs and this time the

687
00:26:01,520 --> 00:26:03,840
argument will be the pointed to the

688
00:26:03,840 --> 00:26:06,000
stack variable

689
00:26:06,000 --> 00:26:07,360
and now i hope you can see what the

690
00:26:07,360 --> 00:26:09,840
problem here is which is

691
00:26:09,840 --> 00:26:12,240
if we run this

692
00:26:12,240 --> 00:26:16,000
system call with a non-null pointer

693
00:26:16,000 --> 00:26:19,360
but the branch gets mispredicted to jump

694
00:26:19,360 --> 00:26:21,279
to the function immediately like in the

695
00:26:21,279 --> 00:26:23,840
null case we get again a funny execution

696
00:26:23,840 --> 00:26:26,320
in which rdi is not null but the code of

697
00:26:26,320 --> 00:26:28,880
rda null gets run and the helper is

698
00:26:28,880 --> 00:26:30,559
called with the attacker supplied

699
00:26:30,559 --> 00:26:33,679
address and potentially could it does

700
00:26:33,679 --> 00:26:35,039
the reference it and it potentially

701
00:26:35,039 --> 00:26:37,120
could also leak it

702
00:26:37,120 --> 00:26:38,480
okay

703
00:26:38,480 --> 00:26:40,640
and another interesting gadget that we

704
00:26:40,640 --> 00:26:43,279
found happened to be not exploitable but

705
00:26:43,279 --> 00:26:45,520
by luck and i want to show it because

706
00:26:45,520 --> 00:26:48,080
it's very interesting how insidious

707
00:26:48,080 --> 00:26:50,159
these gadgets are and how hard it is for

708
00:26:50,159 --> 00:26:52,559
a programmer to look at code and figure

709
00:26:52,559 --> 00:26:54,559
out if it's safe or not

710
00:26:54,559 --> 00:26:56,480
so this is a function called from the

711
00:26:56,480 --> 00:26:59,520
key ctl system call

712
00:26:59,520 --> 00:27:01,679
and it calls the helper function passing

713
00:27:01,679 --> 00:27:03,360
it a pointer to some local stack

714
00:27:03,360 --> 00:27:05,120
variable and the idea is that this

715
00:27:05,120 --> 00:27:07,279
helper is going to write a value to this

716
00:27:07,279 --> 00:27:09,600
variable and after the function returns

717
00:27:09,600 --> 00:27:10,559
if it

718
00:27:10,559 --> 00:27:13,440
if there was no error then this variable

719
00:27:13,440 --> 00:27:15,919
gets passed to another helper function

720
00:27:15,919 --> 00:27:18,080
and inside is the references

721
00:27:18,080 --> 00:27:20,880
this local variable okay

722
00:27:20,880 --> 00:27:23,520
so again this looks very safe

723
00:27:23,520 --> 00:27:26,320
but now look at what happens when this

724
00:27:26,320 --> 00:27:29,360
code gets compiled with a gcc flag that

725
00:27:29,360 --> 00:27:31,760
means says optimize for minimal code

726
00:27:31,760 --> 00:27:33,279
size

727
00:27:33,279 --> 00:27:35,840
what we see is that the space on the

728
00:27:35,840 --> 00:27:38,559
stack for the local variable

729
00:27:38,559 --> 00:27:40,720
is not allocated by subtracting from the

730
00:27:40,720 --> 00:27:43,520
stack pointer like you would expect

731
00:27:43,520 --> 00:27:46,080
it's allocated by pushing the rcx

732
00:27:46,080 --> 00:27:47,120
register

733
00:27:47,120 --> 00:27:50,640
because a push rcx is a one byte op code

734
00:27:50,640 --> 00:27:52,960
and subtracting from the stack is a four

735
00:27:52,960 --> 00:27:54,559
byte op code

736
00:27:54,559 --> 00:27:57,200
and it so happens that rcx is a color

737
00:27:57,200 --> 00:28:00,000
saved register that contains an attacker

738
00:28:00,000 --> 00:28:03,440
supplied value in the caller context

739
00:28:03,440 --> 00:28:06,880
so now what would happen if

740
00:28:06,880 --> 00:28:09,200
the function this the first helper would

741
00:28:09,200 --> 00:28:12,000
return an arrow so it wouldn't touch

742
00:28:12,000 --> 00:28:13,679
the local variable

743
00:28:13,679 --> 00:28:15,840
that got passed to it this test keying

744
00:28:15,840 --> 00:28:16,880
variable

745
00:28:16,880 --> 00:28:18,880
and the error checking branch gets

746
00:28:18,880 --> 00:28:21,279
mispredicted to instead of taking the

747
00:28:21,279 --> 00:28:24,880
error flow call the second helper anyway

748
00:28:24,880 --> 00:28:26,640
what happens is that the value of the

749
00:28:26,640 --> 00:28:28,799
local variable is read from the stack

750
00:28:28,799 --> 00:28:31,520
since it wasn't updated by the helper

751
00:28:31,520 --> 00:28:34,399
function the value read is the original

752
00:28:34,399 --> 00:28:37,279
value of rcx which was attacker control

753
00:28:37,279 --> 00:28:40,159
from the caller context and again we get

754
00:28:40,159 --> 00:28:42,720
a function call in the kernel that

755
00:28:42,720 --> 00:28:44,640
executes speculatively

756
00:28:44,640 --> 00:28:48,000
on an attacker supplied pointer

757
00:28:48,000 --> 00:28:49,679
and the only reason that this was not

758
00:28:49,679 --> 00:28:51,840
exploitable is because it turned out

759
00:28:51,840 --> 00:28:54,559
that the first helper was i don't know

760
00:28:54,559 --> 00:28:57,039
maybe paranoid and it took care to

761
00:28:57,039 --> 00:28:59,919
overwrite the this output parameter on

762
00:28:59,919 --> 00:29:02,159
every flow so there was no way to go

763
00:29:02,159 --> 00:29:04,240
into this function and go out without

764
00:29:04,240 --> 00:29:06,080
overwriting the value of the of the

765
00:29:06,080 --> 00:29:08,080
output parameter

766
00:29:08,080 --> 00:29:09,840
but of course this is not something that

767
00:29:09,840 --> 00:29:12,240
has to happen and if somebody changes

768
00:29:12,240 --> 00:29:13,840
this code or if something similar

769
00:29:13,840 --> 00:29:16,240
happens in another place in the kernel

770
00:29:16,240 --> 00:29:18,320
where they don't do this then this would

771
00:29:18,320 --> 00:29:20,320
be completely exploitable

772
00:29:20,320 --> 00:29:21,279
and

773
00:29:21,279 --> 00:29:23,200
how could the programmer look at this

774
00:29:23,200 --> 00:29:24,799
and figure out that something is going

775
00:29:24,799 --> 00:29:26,240
on because the way of the way the

776
00:29:26,240 --> 00:29:28,640
compiler decided to compile a stack a

777
00:29:28,640 --> 00:29:30,720
location of a local variable it's very

778
00:29:30,720 --> 00:29:32,960
hard

779
00:29:33,120 --> 00:29:34,480
and

780
00:29:34,480 --> 00:29:36,559
finally i want to talk about

781
00:29:36,559 --> 00:29:39,440
a speculative type confusion related to

782
00:29:39,440 --> 00:29:41,760
polymorphism in the kernel

783
00:29:41,760 --> 00:29:44,320
and the funny thing about this um

784
00:29:44,320 --> 00:29:47,440
analysis is that the problem is caused

785
00:29:47,440 --> 00:29:50,320
by another spectrum mitigation this time

786
00:29:50,320 --> 00:29:52,240
this time of another variant called

787
00:29:52,240 --> 00:29:55,279
spectral variant two so spectral variant

788
00:29:55,279 --> 00:29:57,200
two is about exploiting the

789
00:29:57,200 --> 00:30:00,799
misprediction of indirect call targets

790
00:30:00,799 --> 00:30:03,360
so it tries to predict where an indirect

791
00:30:03,360 --> 00:30:05,360
call will will jump to

792
00:30:05,360 --> 00:30:07,440
and the attack was able to get

793
00:30:07,440 --> 00:30:09,360
indirect calls to jump to any location

794
00:30:09,360 --> 00:30:12,000
to arbitrary locations

795
00:30:12,000 --> 00:30:14,960
the way this is mitigated in software

796
00:30:14,960 --> 00:30:17,200
is by replacing

797
00:30:17,200 --> 00:30:18,559
indirect call

798
00:30:18,559 --> 00:30:19,919
opcodes

799
00:30:19,919 --> 00:30:22,000
with a short code segment called

800
00:30:22,000 --> 00:30:23,520
eretpolin

801
00:30:23,520 --> 00:30:25,840
and the red pauline executes the

802
00:30:25,840 --> 00:30:28,240
indirect call but it does it in a way

803
00:30:28,240 --> 00:30:30,080
that is speculation safe

804
00:30:30,080 --> 00:30:31,679
which is another way of saying that it

805
00:30:31,679 --> 00:30:34,880
disables speculation in software so this

806
00:30:34,880 --> 00:30:37,440
is safe but there's a huge performance

807
00:30:37,440 --> 00:30:39,039
penalty

808
00:30:39,039 --> 00:30:41,520
and because of this linux started moving

809
00:30:41,520 --> 00:30:44,480
in the direction of replacing certain

810
00:30:44,480 --> 00:30:46,399
code locations certain on indirect

811
00:30:46,399 --> 00:30:48,960
certain indirect calls replacing red

812
00:30:48,960 --> 00:30:50,159
pollins

813
00:30:50,159 --> 00:30:52,240
with another approach this is an

814
00:30:52,240 --> 00:30:53,919
approach that instead of disabling

815
00:30:53,919 --> 00:30:55,360
speculation

816
00:30:55,360 --> 00:30:59,200
checks has a sequence of checks that the

817
00:30:59,200 --> 00:31:01,919
address thread for memory which the

818
00:31:01,919 --> 00:31:04,240
function is supposed to jump to is one

819
00:31:04,240 --> 00:31:07,279
of a set of possible targets

820
00:31:07,279 --> 00:31:10,399
and if so it jumps directly to that

821
00:31:10,399 --> 00:31:11,600
address

822
00:31:11,600 --> 00:31:13,919
so what happens is is that now

823
00:31:13,919 --> 00:31:16,000
speculation is possible because we have

824
00:31:16,000 --> 00:31:16,840
these

825
00:31:16,840 --> 00:31:19,919
jumps but mis misspeculation

826
00:31:19,919 --> 00:31:22,399
misprediction can only cause the kernel

827
00:31:22,399 --> 00:31:25,840
to go into one of a set of legal targets

828
00:31:25,840 --> 00:31:27,919
so not any arbitrary address like

829
00:31:27,919 --> 00:31:31,120
inspector v2 but one of a set of valid

830
00:31:31,120 --> 00:31:32,480
targets

831
00:31:32,480 --> 00:31:34,720
unfortunately this can still be

832
00:31:34,720 --> 00:31:38,240
vulnerable to speculative type confusion

833
00:31:38,240 --> 00:31:40,159
and let me show you how

834
00:31:40,159 --> 00:31:42,720
so the problem comes from the way that

835
00:31:42,720 --> 00:31:44,000
linux does

836
00:31:44,000 --> 00:31:47,519
a data inheritance and polymorphism in c

837
00:31:47,519 --> 00:31:50,080
so in in many locations there is this

838
00:31:50,080 --> 00:31:51,600
structure where there is some common

839
00:31:51,600 --> 00:31:54,399
interface like the api of a file system

840
00:31:54,399 --> 00:31:56,960
or the api of some driver

841
00:31:56,960 --> 00:31:59,120
and the specific modules define their

842
00:31:59,120 --> 00:32:01,519
own structures that start with a common

843
00:32:01,519 --> 00:32:03,200
interface

844
00:32:03,200 --> 00:32:05,120
and then they extend it with their own

845
00:32:05,120 --> 00:32:06,000
fields

846
00:32:06,000 --> 00:32:07,919
so in this example we have module a that

847
00:32:07,919 --> 00:32:10,720
has a field with a trusted pointer and

848
00:32:10,720 --> 00:32:12,480
module b that has a field with an

849
00:32:12,480 --> 00:32:14,880
untrusted scalar maybe this is something

850
00:32:14,880 --> 00:32:16,880
that can be set from user space by an

851
00:32:16,880 --> 00:32:19,440
ioctl or something

852
00:32:19,440 --> 00:32:21,039
and the idea is that there is some code

853
00:32:21,039 --> 00:32:23,840
path that gets past the common interface

854
00:32:23,840 --> 00:32:26,399
that belongs to the specific module

855
00:32:26,399 --> 00:32:30,480
and the is to find the module-specific

856
00:32:30,480 --> 00:32:32,960
method to execute and then it executes

857
00:32:32,960 --> 00:32:35,600
it so for example the

858
00:32:35,600 --> 00:32:38,640
method of module a would cast the common

859
00:32:38,640 --> 00:32:41,279
structure into its a model-specific

860
00:32:41,279 --> 00:32:43,679
structure then dereference the pointer

861
00:32:43,679 --> 00:32:45,440
and potentially do something that clicks

862
00:32:45,440 --> 00:32:46,720
it

863
00:32:46,720 --> 00:32:47,679
okay

864
00:32:47,679 --> 00:32:49,760
and module b will do something similar

865
00:32:49,760 --> 00:32:52,240
but with its own field

866
00:32:52,240 --> 00:32:54,640
but now let's think about what happens

867
00:32:54,640 --> 00:32:56,880
if this code instead of being done

868
00:32:56,880 --> 00:32:59,600
secured securely with the red polling is

869
00:32:59,600 --> 00:33:02,880
done by checking is the method equal to

870
00:33:02,880 --> 00:33:06,399
4a then jump to 4a easy to equal to 4b

871
00:33:06,399 --> 00:33:08,080
then jump to 4b

872
00:33:08,080 --> 00:33:10,720
then what can happen is that

873
00:33:10,720 --> 00:33:13,760
this code gets executed with the pointer

874
00:33:13,760 --> 00:33:16,080
the argument pointing to a structure of

875
00:33:16,080 --> 00:33:17,519
module b

876
00:33:17,519 --> 00:33:20,000
but maybe the branch mispredicts or the

877
00:33:20,000 --> 00:33:22,320
attacker causes the branch to mispredict

878
00:33:22,320 --> 00:33:25,440
and cause the cpu to execute the method

879
00:33:25,440 --> 00:33:27,440
of module a

880
00:33:27,440 --> 00:33:29,760
and then what happens

881
00:33:29,760 --> 00:33:32,480
module a will dereference what it thinks

882
00:33:32,480 --> 00:33:34,880
is the pointer the trusted pointer field

883
00:33:34,880 --> 00:33:37,440
in the structure but since it got past

884
00:33:37,440 --> 00:33:39,519
the structure of module b it's actually

885
00:33:39,519 --> 00:33:41,440
going to use an attacker controlled

886
00:33:41,440 --> 00:33:44,399
value dereference it and lick it like we

887
00:33:44,399 --> 00:33:46,799
saw several times in this talk

888
00:33:46,799 --> 00:33:48,320
okay so

889
00:33:48,320 --> 00:33:49,760
we wanted to check

890
00:33:49,760 --> 00:33:50,480
how

891
00:33:50,480 --> 00:33:51,519
a

892
00:33:51,519 --> 00:33:53,679
problematic this approach might be if

893
00:33:53,679 --> 00:33:56,159
linux extended extended from just a

894
00:33:56,159 --> 00:33:57,679
handful of

895
00:33:57,679 --> 00:33:59,760
indirect calls to maybe all indirect

896
00:33:59,760 --> 00:34:02,880
calls so we did a source level analysis

897
00:34:02,880 --> 00:34:05,360
of indirect calls in linux looking for

898
00:34:05,360 --> 00:34:07,200
these types of cases where you have two

899
00:34:07,200 --> 00:34:10,320
functions with the same interface one of

900
00:34:10,320 --> 00:34:12,879
them has a pointer dereference and the

901
00:34:12,879 --> 00:34:15,679
second has a scalar attacker controlled

902
00:34:15,679 --> 00:34:17,280
scalar

903
00:34:17,280 --> 00:34:19,359
at the same offset in the structure

904
00:34:19,359 --> 00:34:21,040
which would make this kind of thing

905
00:34:21,040 --> 00:34:22,719
exploitable

906
00:34:22,719 --> 00:34:24,320
and we actually found that there are

907
00:34:24,320 --> 00:34:25,440
thousands

908
00:34:25,440 --> 00:34:27,599
examples like this of potentially

909
00:34:27,599 --> 00:34:30,079
vulnerable function pairs

910
00:34:30,079 --> 00:34:31,440
of these

911
00:34:31,440 --> 00:34:34,000
hundreds actually use the value that is

912
00:34:34,000 --> 00:34:36,800
the referenced and pass it as an index

913
00:34:36,800 --> 00:34:39,359
to another array so they actually leaked

914
00:34:39,359 --> 00:34:41,040
the value

915
00:34:41,040 --> 00:34:43,199
and we looked at this manually and

916
00:34:43,199 --> 00:34:45,520
concluded not with a hundred percent

917
00:34:45,520 --> 00:34:48,480
certainty but it seemed to us that

918
00:34:48,480 --> 00:34:50,159
despite that the fact that a lot of

919
00:34:50,159 --> 00:34:52,879
these they seem to be not exploitable

920
00:34:52,879 --> 00:34:55,440
again by luck because maybe the value

921
00:34:55,440 --> 00:34:57,200
that the attacker controlled they don't

922
00:34:57,200 --> 00:34:59,280
have full control so they can't put a

923
00:34:59,280 --> 00:35:01,359
pointer there either because the kernel

924
00:35:01,359 --> 00:35:03,359
limits what they put there or because

925
00:35:03,359 --> 00:35:06,240
it's too small it's a 16-bit value and

926
00:35:06,240 --> 00:35:08,720
not a 64-bit value the all these kind of

927
00:35:08,720 --> 00:35:10,480
things that can change from one version

928
00:35:10,480 --> 00:35:12,320
to another potentially become

929
00:35:12,320 --> 00:35:14,079
exploitable

930
00:35:14,079 --> 00:35:16,880
let me show you an example so

931
00:35:16,880 --> 00:35:19,359
here is an actual method from a of a

932
00:35:19,359 --> 00:35:22,400
driver from from linux uh it accepts a

933
00:35:22,400 --> 00:35:23,920
struct device this is the common

934
00:35:23,920 --> 00:35:26,400
structure converts it to the model

935
00:35:26,400 --> 00:35:28,400
specific structure

936
00:35:28,400 --> 00:35:30,720
and prints a value of some field called

937
00:35:30,720 --> 00:35:33,040
max frequency

938
00:35:33,040 --> 00:35:36,400
and now let's look at a a

939
00:35:36,480 --> 00:35:38,480
the same method

940
00:35:38,480 --> 00:35:40,800
from another mod from another driver the

941
00:35:40,800 --> 00:35:42,240
usb driver

942
00:35:42,240 --> 00:35:44,720
what it does is it converts the

943
00:35:44,720 --> 00:35:47,680
structure the star the shared structure

944
00:35:47,680 --> 00:35:50,000
into a module specific structure but

945
00:35:50,000 --> 00:35:52,560
this time it dereferences some pointer

946
00:35:52,560 --> 00:35:55,359
in a field called cap and it passes the

947
00:35:55,359 --> 00:35:58,480
value that was read as an array index

948
00:35:58,480 --> 00:36:00,240
into some array

949
00:36:00,240 --> 00:36:03,520
and the cap field is in exactly the same

950
00:36:03,520 --> 00:36:05,760
offset as the max frequency field

951
00:36:05,760 --> 00:36:08,560
so this would be exploitable but for the

952
00:36:08,560 --> 00:36:11,119
fact that if you look at how this max

953
00:36:11,119 --> 00:36:12,800
freak freak

954
00:36:12,800 --> 00:36:15,200
field is set then it's through some

955
00:36:15,200 --> 00:36:18,240
functions some ioctl some ioctl that

956
00:36:18,240 --> 00:36:19,920
doesn't take the value directly from the

957
00:36:19,920 --> 00:36:22,800
attacker but it sets it into one of some

958
00:36:22,800 --> 00:36:24,560
pre-selected

959
00:36:24,560 --> 00:36:26,320
small set of values so the attacker

960
00:36:26,320 --> 00:36:28,720
can't put an arbitrary address there but

961
00:36:28,720 --> 00:36:30,800
again if this changes or something

962
00:36:30,800 --> 00:36:32,880
similar happens in another module this

963
00:36:32,880 --> 00:36:35,119
would be exploitable

964
00:36:35,119 --> 00:36:37,520
so the conclusion from this is that

965
00:36:37,520 --> 00:36:39,119
right now

966
00:36:39,119 --> 00:36:40,800
this type of thing is not done in a lot

967
00:36:40,800 --> 00:36:43,520
of indirect calls but if they extend

968
00:36:43,520 --> 00:36:45,200
this and start doing it in many indirect

969
00:36:45,200 --> 00:36:47,359
calls then this would put the security

970
00:36:47,359 --> 00:36:49,760
of the kernel on very shaky grounds

971
00:36:49,760 --> 00:36:51,839
because anytime a small code change

972
00:36:51,839 --> 00:36:53,119
happens this might create a

973
00:36:53,119 --> 00:36:54,960
vulnerability and you can't really

974
00:36:54,960 --> 00:36:56,880
expect somebody working on the usb

975
00:36:56,880 --> 00:36:59,200
driver to go and check all the other

976
00:36:59,200 --> 00:37:01,520
drivers that use the same interface and

977
00:37:01,520 --> 00:37:03,200
see if there is a potential speculative

978
00:37:03,200 --> 00:37:06,640
type confusion happening there

979
00:37:06,640 --> 00:37:09,040
so i want to emphasize that all of this

980
00:37:09,040 --> 00:37:12,079
was done with pretty naive analysis

981
00:37:12,079 --> 00:37:14,880
static analysis it was not exhaustive it

982
00:37:14,880 --> 00:37:17,920
could have false negatives

983
00:37:17,920 --> 00:37:19,920
and it could have false positives so i

984
00:37:19,920 --> 00:37:21,680
think that there is much more room for

985
00:37:21,680 --> 00:37:23,440
improvement here and potentially there

986
00:37:23,440 --> 00:37:25,119
are a lot more vulnerabilities to be

987
00:37:25,119 --> 00:37:27,200
found

988
00:37:27,200 --> 00:37:27,920
and

989
00:37:27,920 --> 00:37:30,240
concluding where does that put us in

990
00:37:30,240 --> 00:37:32,800
terms of mitigating spectrovariant one

991
00:37:32,800 --> 00:37:34,240
so

992
00:37:34,240 --> 00:37:36,160
manual the manual approach doesn't seem

993
00:37:36,160 --> 00:37:38,400
to be workable given all of these

994
00:37:38,400 --> 00:37:40,240
insidious gadgets

995
00:37:40,240 --> 00:37:42,400
fortunately there are comprehensive

996
00:37:42,400 --> 00:37:44,160
protections that can be enabled in the

997
00:37:44,160 --> 00:37:46,880
compiler for example lvm has something

998
00:37:46,880 --> 00:37:49,200
called speculative load hardening but

999
00:37:49,200 --> 00:37:50,560
these are comprehensive because they

1000
00:37:50,560 --> 00:37:53,119
protect every branch in the program so

1001
00:37:53,119 --> 00:37:55,119
they have a lot of overhead

1002
00:37:55,119 --> 00:37:57,440
we did a benchmark of

1003
00:37:57,440 --> 00:38:00,640
linux with slh enabled and we saw that

1004
00:38:00,640 --> 00:38:02,560
system calls got slowed down by an

1005
00:38:02,560 --> 00:38:06,800
average 1.5 x sometimes even 2.5 x so

1006
00:38:06,800 --> 00:38:08,800
this doesn't seem like an acceptable

1007
00:38:08,800 --> 00:38:10,079
overhead

1008
00:38:10,079 --> 00:38:11,839
and so i think that it might be the case

1009
00:38:11,839 --> 00:38:13,440
that there's no choice and hardware

1010
00:38:13,440 --> 00:38:15,520
needs to help so maybe not disable

1011
00:38:15,520 --> 00:38:17,920
speculative execution but do something

1012
00:38:17,920 --> 00:38:20,000
that helps software mitigations maybe

1013
00:38:20,000 --> 00:38:22,320
become more efficient

1014
00:38:22,320 --> 00:38:24,000
and to conclude

1015
00:38:24,000 --> 00:38:25,680
i showed you that speculative type

1016
00:38:25,680 --> 00:38:27,680
confusion vulnerabilities exist in the

1017
00:38:27,680 --> 00:38:30,560
wild both exploitable and latent

1018
00:38:30,560 --> 00:38:33,200
vulnerabilities these gadgets are very

1019
00:38:33,200 --> 00:38:35,440
insidious they can materialize because

1020
00:38:35,440 --> 00:38:37,839
of compiler optimization programmers

1021
00:38:37,839 --> 00:38:39,680
have a very hard time of reasoning about

1022
00:38:39,680 --> 00:38:40,560
them

1023
00:38:40,560 --> 00:38:42,320
and so the takeaways is that if you are

1024
00:38:42,320 --> 00:38:44,560
an attacker go look for these i think

1025
00:38:44,560 --> 00:38:46,400
the analysis we did is just the first

1026
00:38:46,400 --> 00:38:48,880
step and if you're a defender we need to

1027
00:38:48,880 --> 00:38:50,800
rethink how we are defending for

1028
00:38:50,800 --> 00:38:52,960
spectrovent one it's not a solved

1029
00:38:52,960 --> 00:38:54,000
problem

1030
00:38:54,000 --> 00:38:58,760
thank you very much it was a pleasure

1031
00:39:03,240 --> 00:39:05,920
[Music]

1032
00:39:05,920 --> 00:39:08,000
you

