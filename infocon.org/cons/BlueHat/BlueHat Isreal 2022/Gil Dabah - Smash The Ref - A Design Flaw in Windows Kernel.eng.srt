1
00:00:00,930 --> 00:00:08,260
[Music]

2
00:00:13,310 --> 00:00:16,560
[Music]

3
00:00:16,560 --> 00:00:18,320
hey everybody

4
00:00:18,320 --> 00:00:20,640
i'm so excited to be here

5
00:00:20,640 --> 00:00:22,800
uh shalom everyone

6
00:00:22,800 --> 00:00:25,920
my name is gil everybody calls me dhaba

7
00:00:25,920 --> 00:00:28,560
and let's see how it works all right

8
00:00:28,560 --> 00:00:31,359
so two years ago i wasn't working i was

9
00:00:31,359 --> 00:00:33,680
pretty bored and what i love to do is

10
00:00:33,680 --> 00:00:35,920
reverse engineering and i said okay

11
00:00:35,920 --> 00:00:37,840
there is a favorite component it's

12
00:00:37,840 --> 00:00:40,399
called win32k which i'm going to tell

13
00:00:40,399 --> 00:00:42,559
you more about and i said let's take a

14
00:00:42,559 --> 00:00:45,200
look and see what's there oh sorry my

15
00:00:45,200 --> 00:00:46,559
bed

16
00:00:46,559 --> 00:00:48,160
and

17
00:00:48,160 --> 00:00:50,480
and i said okay let's take a look

18
00:00:50,480 --> 00:00:53,600
and somehow i find a crazy design flow

19
00:00:53,600 --> 00:00:55,760
and the point today is to go over it and

20
00:00:55,760 --> 00:00:57,440
show you

21
00:00:57,440 --> 00:00:59,760
again it's going to be out core but i'm

22
00:00:59,760 --> 00:01:01,520
going to go slowly and teach you

23
00:01:01,520 --> 00:01:03,520
everything to understand it hopefully

24
00:01:03,520 --> 00:01:05,920
i'm going to do a good job so this tweet

25
00:01:05,920 --> 00:01:08,560
was about like uh april's fools telling

26
00:01:08,560 --> 00:01:12,080
everybody i found like 15 cvs and nobody

27
00:01:12,080 --> 00:01:14,479
believed me but then i dropped like tons

28
00:01:14,479 --> 00:01:17,360
of uh pocs on github

29
00:01:17,360 --> 00:01:19,600
so

30
00:01:19,920 --> 00:01:22,159
you know we are here in a security

31
00:01:22,159 --> 00:01:23,280
conference

32
00:01:23,280 --> 00:01:25,040
and then there is another part in the

33
00:01:25,040 --> 00:01:27,600
world that my art goes out to the

34
00:01:27,600 --> 00:01:30,320
ukrainian people so i cannot just ignore

35
00:01:30,320 --> 00:01:34,000
it and i have to to be saying that

36
00:01:34,000 --> 00:01:36,000
okay so now about our agenda

37
00:01:36,000 --> 00:01:38,960
introduction is going to be very basic

38
00:01:38,960 --> 00:01:41,200
it's something everybody knows it's

39
00:01:41,200 --> 00:01:43,600
gonna be easy make sure you keep with

40
00:01:43,600 --> 00:01:44,880
the pace

41
00:01:44,880 --> 00:01:47,600
uh no pressure there and then zombies

42
00:01:47,600 --> 00:01:49,040
it's all about zombies we're gonna

43
00:01:49,040 --> 00:01:51,040
explain what it is and then we'll see

44
00:01:51,040 --> 00:01:53,280
why it's interesting exploitation

45
00:01:53,280 --> 00:01:55,119
obviously the good stuff

46
00:01:55,119 --> 00:01:58,399
and then we see why it was like cool

47
00:01:58,399 --> 00:01:59,920
wrap up

48
00:01:59,920 --> 00:02:02,960
so the first thing about win32k

49
00:02:02,960 --> 00:02:05,200
it's that everything in the kernel is

50
00:02:05,200 --> 00:02:06,320
doing

51
00:02:06,320 --> 00:02:08,399
sorry gui is being done in the kernel

52
00:02:08,399 --> 00:02:10,639
okay so graphical user interface in the

53
00:02:10,639 --> 00:02:12,400
kernel right

54
00:02:12,400 --> 00:02:15,280
and then we talk about ui objects like

55
00:02:15,280 --> 00:02:17,599
windows menus buttons all this kind of

56
00:02:17,599 --> 00:02:19,760
stuff and they're all in the kernel okay

57
00:02:19,760 --> 00:02:21,680
so you can imagine

58
00:02:21,680 --> 00:02:24,160
what can go wrong lots of things

59
00:02:24,160 --> 00:02:26,319
and the good thing about

60
00:02:26,319 --> 00:02:28,239
putting it in the kernel is that now we

61
00:02:28,239 --> 00:02:30,319
don't have a transition from user to

62
00:02:30,319 --> 00:02:32,000
kernel sorry

63
00:02:32,000 --> 00:02:33,920
now we have a transition from user to

64
00:02:33,920 --> 00:02:36,239
kernel so it's better performance than

65
00:02:36,239 --> 00:02:38,239
transition from user mode to another

66
00:02:38,239 --> 00:02:40,959
process in user mode so back in nt4 they

67
00:02:40,959 --> 00:02:43,200
said let's take it down it's going to be

68
00:02:43,200 --> 00:02:45,360
faster everybody is happy so the bad

69
00:02:45,360 --> 00:02:47,360
thing is now if you if you took a

70
00:02:47,360 --> 00:02:49,120
component from user mode and you put it

71
00:02:49,120 --> 00:02:50,879
down in the kernel

72
00:02:50,879 --> 00:02:52,720
now you need sometimes to call back to

73
00:02:52,720 --> 00:02:54,879
user mode for windows messages for

74
00:02:54,879 --> 00:02:56,800
example so that's going to create lots

75
00:02:56,800 --> 00:02:59,440
of problems and then the ugly thing is

76
00:02:59,440 --> 00:03:01,599
the code quality

77
00:03:01,599 --> 00:03:02,560
so

78
00:03:02,560 --> 00:03:05,840
not me it's a leaked source code you can

79
00:03:05,840 --> 00:03:08,720
check it out for yourself so now

80
00:03:08,720 --> 00:03:10,239
the first thing you need to know about

81
00:03:10,239 --> 00:03:12,560
it everything is about user callbacks

82
00:03:12,560 --> 00:03:15,040
okay so there is kernel calling back to

83
00:03:15,040 --> 00:03:18,319
user mode to some stuff that we can

84
00:03:18,319 --> 00:03:20,560
manipulate and that's going to create

85
00:03:20,560 --> 00:03:23,760
tons of mess and now i want to tell you

86
00:03:23,760 --> 00:03:26,080
something you're going to see xxx it's

87
00:03:26,080 --> 00:03:28,640
not what you think but it is

88
00:03:28,640 --> 00:03:31,040
the meaning of it is to

89
00:03:31,040 --> 00:03:33,360
um to tell everybody else when they see

90
00:03:33,360 --> 00:03:35,840
the codex success might go back to the

91
00:03:35,840 --> 00:03:38,560
kernel yeah from kernel to user sorry

92
00:03:38,560 --> 00:03:39,840
still excited

93
00:03:39,840 --> 00:03:43,280
so from kernel to user that's xxx

94
00:03:43,280 --> 00:03:45,599
and there is a critical section so if

95
00:03:45,599 --> 00:03:47,760
you try to do it twice from two threads

96
00:03:47,760 --> 00:03:49,519
going down to the kernel only one the

97
00:03:49,519 --> 00:03:53,120
faster one is gonna do it and then up if

98
00:03:53,120 --> 00:03:55,120
it's needs okay

99
00:03:55,120 --> 00:03:57,360
so this is a third example

100
00:03:57,360 --> 00:04:01,840
okay just some simplified code

101
00:04:02,480 --> 00:04:04,400
okay i'm looking at the wrong one

102
00:04:04,400 --> 00:04:07,840
nobody tells me anything thank you

103
00:04:07,840 --> 00:04:10,640
amazing okay so

104
00:04:10,640 --> 00:04:12,640
all the callbacks to user mode good

105
00:04:12,640 --> 00:04:16,798
thing and and then the xxx so we said

106
00:04:16,798 --> 00:04:20,160
xxx goes back to user mode okay

107
00:04:20,160 --> 00:04:21,918
good now in review

108
00:04:21,918 --> 00:04:24,720
so this example what we are doing here

109
00:04:24,720 --> 00:04:27,919
is to show you like a cisco from

110
00:04:27,919 --> 00:04:30,160
user mode calling kernel and then we

111
00:04:30,160 --> 00:04:32,080
create a window

112
00:04:32,080 --> 00:04:34,160
and then we call xxx

113
00:04:34,160 --> 00:04:37,199
okay and then we call we use p again so

114
00:04:37,199 --> 00:04:39,840
the set window style uses p again

115
00:04:39,840 --> 00:04:42,479
and now can you imagine where's the bug

116
00:04:42,479 --> 00:04:45,680
so we said xxx can go back to user mode

117
00:04:45,680 --> 00:04:48,080
in user mode we can do the bad things

118
00:04:48,080 --> 00:04:48,960
okay

119
00:04:48,960 --> 00:04:51,440
so the point now

120
00:04:51,440 --> 00:04:52,240
is

121
00:04:52,240 --> 00:04:55,199
how we can abuse it okay

122
00:04:55,199 --> 00:04:57,520
so let's see how it looks in a normal

123
00:04:57,520 --> 00:05:00,080
flow so the first thing we do we start

124
00:05:00,080 --> 00:05:03,440
from our user mode application we call

125
00:05:03,440 --> 00:05:06,960
down to the kernel and then we

126
00:05:06,960 --> 00:05:09,039
inside the kernel there is the window

127
00:05:09,039 --> 00:05:11,440
created there is some callback then the

128
00:05:11,440 --> 00:05:14,320
callback goes back to user mode

129
00:05:14,320 --> 00:05:16,720
okay so get it kernel goes back to user

130
00:05:16,720 --> 00:05:20,000
mode and now we destroy the window

131
00:05:20,000 --> 00:05:22,000
and it goes back to the kernel to really

132
00:05:22,000 --> 00:05:24,560
destroy the window goes back to user

133
00:05:24,560 --> 00:05:27,039
mode goes back to kernel and now what

134
00:05:27,039 --> 00:05:30,000
happens p is used but it's already freed

135
00:05:30,000 --> 00:05:32,160
because somebody destroyed it okay but

136
00:05:32,160 --> 00:05:34,800
this is the basic stuff so the point is

137
00:05:34,800 --> 00:05:35,680
that

138
00:05:35,680 --> 00:05:36,720
now

139
00:05:36,720 --> 00:05:38,639
there is no p we have the use after

140
00:05:38,639 --> 00:05:40,639
three and we have a problem

141
00:05:40,639 --> 00:05:42,960
so obviously they thought of it and they

142
00:05:42,960 --> 00:05:44,720
fixed it

143
00:05:44,720 --> 00:05:46,880
but before we get to the fix

144
00:05:46,880 --> 00:05:48,479
or

145
00:05:48,479 --> 00:05:50,320
just that so

146
00:05:50,320 --> 00:05:52,800
objects are being locked okay there are

147
00:05:52,800 --> 00:05:54,639
two types of locks

148
00:05:54,639 --> 00:05:56,479
uh one is like

149
00:05:56,479 --> 00:05:57,840
the scope lock

150
00:05:57,840 --> 00:06:00,160
and we will see how it works

151
00:06:00,160 --> 00:06:01,759
and then there is another one that i'm

152
00:06:01,759 --> 00:06:04,240
going to skip now for brevity but the

153
00:06:04,240 --> 00:06:05,840
point is for all the objects in the

154
00:06:05,840 --> 00:06:06,800
kernel

155
00:06:06,800 --> 00:06:09,199
you you can just call some cisco to

156
00:06:09,199 --> 00:06:11,600
create them to destroy them and this is

157
00:06:11,600 --> 00:06:13,919
the important thing all the objects

158
00:06:13,919 --> 00:06:16,240
start with zero ref count

159
00:06:16,240 --> 00:06:18,000
maybe it's not like that intuitive but

160
00:06:18,000 --> 00:06:20,560
that's the case but the destroy

161
00:06:20,560 --> 00:06:21,759
functions

162
00:06:21,759 --> 00:06:23,919
and this is also very important will

163
00:06:23,919 --> 00:06:26,560
only free the object in the kernel when

164
00:06:26,560 --> 00:06:28,880
there are zero references which makes

165
00:06:28,880 --> 00:06:30,160
sense right

166
00:06:30,160 --> 00:06:32,319
and then we talked about treadlock and

167
00:06:32,319 --> 00:06:35,560
thread unlock

168
00:06:35,840 --> 00:06:37,360
i'm like

169
00:06:37,360 --> 00:06:38,800
a sec

170
00:06:38,800 --> 00:06:40,160
this is

171
00:06:40,160 --> 00:06:43,440
okay we're good

172
00:06:44,880 --> 00:06:47,120
so the treadlock now is the solution for

173
00:06:47,120 --> 00:06:48,720
what happened earlier and let's see why

174
00:06:48,720 --> 00:06:50,800
it's a solution so now we are in the

175
00:06:50,800 --> 00:06:52,560
snippet of the kernel

176
00:06:52,560 --> 00:06:55,280
we we lock the pointer as you see it's a

177
00:06:55,280 --> 00:06:57,360
manual locking if if the developer

178
00:06:57,360 --> 00:06:58,960
forgets to do it

179
00:06:58,960 --> 00:07:02,080
then there's a problem we call back to

180
00:07:02,080 --> 00:07:04,800
user mode if we now destroy the window

181
00:07:04,800 --> 00:07:06,319
in user mode

182
00:07:06,319 --> 00:07:08,400
okay what's going to happen now

183
00:07:08,400 --> 00:07:10,319
nothing why because the reference count

184
00:07:10,319 --> 00:07:11,520
is

185
00:07:11,520 --> 00:07:13,440
still one okay

186
00:07:13,440 --> 00:07:17,680
and now we have this special situation

187
00:07:17,680 --> 00:07:19,520
that's the zombie

188
00:07:19,520 --> 00:07:20,960
and the reason it's a zombie it's

189
00:07:20,960 --> 00:07:23,759
because it's in between weird states

190
00:07:23,759 --> 00:07:25,680
because on one end somebody tried to

191
00:07:25,680 --> 00:07:27,840
kill it from user mode because we got

192
00:07:27,840 --> 00:07:30,240
back to user mode on the other end there

193
00:07:30,240 --> 00:07:32,080
are still references

194
00:07:32,080 --> 00:07:34,000
so now we have a weird situation and

195
00:07:34,000 --> 00:07:36,400
let's see why it's so interesting

196
00:07:36,400 --> 00:07:38,160
and now we are going to talk about the

197
00:07:38,160 --> 00:07:40,639
zombies the reason it's called zombies

198
00:07:40,639 --> 00:07:42,080
is just because

199
00:07:42,080 --> 00:07:43,360
i saw the

200
00:07:43,360 --> 00:07:44,879
in some of the comments in the league

201
00:07:44,879 --> 00:07:46,800
source code they said zombies so i said

202
00:07:46,800 --> 00:07:48,800
okay it makes sense but let's see what's

203
00:07:48,800 --> 00:07:52,000
the point with the zombies

204
00:07:53,919 --> 00:07:57,919
um okay so we said if we try to destroy

205
00:07:57,919 --> 00:08:01,360
a window or any ui object with more than

206
00:08:01,360 --> 00:08:03,919
zero references then nothing is going to

207
00:08:03,919 --> 00:08:07,520
happen but in reality it trus it it will

208
00:08:07,520 --> 00:08:10,160
destroy it and soon we are going to to

209
00:08:10,160 --> 00:08:12,720
understand exactly why the first

210
00:08:12,720 --> 00:08:14,960
destruction does something and then it

211
00:08:14,960 --> 00:08:18,160
leaves us with some problem okay so

212
00:08:18,160 --> 00:08:21,120
so now let's see this uh snippet when we

213
00:08:21,120 --> 00:08:23,759
get back from xxx some callback and we

214
00:08:23,759 --> 00:08:25,520
destroy it in user mode

215
00:08:25,520 --> 00:08:27,759
then there is a trade unlock

216
00:08:27,759 --> 00:08:29,360
so now what happens is the last

217
00:08:29,360 --> 00:08:32,880
reference count goes from one to zero

218
00:08:32,880 --> 00:08:33,760
and

219
00:08:33,760 --> 00:08:35,760
the object was marked

220
00:08:35,760 --> 00:08:38,159
to be destroyed so so we try to destroy

221
00:08:38,159 --> 00:08:40,240
it it's not going to be destroyed

222
00:08:40,240 --> 00:08:42,000
because there is a reference count it's

223
00:08:42,000 --> 00:08:44,480
now one but in this line of code it goes

224
00:08:44,480 --> 00:08:46,959
from one to zero okay

225
00:08:46,959 --> 00:08:49,519
and the problem is

226
00:08:49,519 --> 00:08:51,040
actually there is still no problem so

227
00:08:51,040 --> 00:08:52,800
now everything is safe p is going to be

228
00:08:52,800 --> 00:08:55,120
freed after the thread unlock nobody

229
00:08:55,120 --> 00:08:58,320
uses it and we are good

230
00:08:58,320 --> 00:09:00,320
but let's see where the story starts to

231
00:09:00,320 --> 00:09:02,800
become more complicated okay

232
00:09:02,800 --> 00:09:03,760
if

233
00:09:03,760 --> 00:09:06,000
if we destroy object and they still have

234
00:09:06,000 --> 00:09:08,000
references obviously they are called

235
00:09:08,000 --> 00:09:10,240
zombies otherwise if they don't have any

236
00:09:10,240 --> 00:09:12,000
references they are free for good so

237
00:09:12,000 --> 00:09:14,320
there is no limbo situation you know

238
00:09:14,320 --> 00:09:16,720
there is no zombie situation so zombies

239
00:09:16,720 --> 00:09:17,920
still exist

240
00:09:17,920 --> 00:09:20,240
because if they weren't existing

241
00:09:20,240 --> 00:09:21,600
you know in case there are like

242
00:09:21,600 --> 00:09:23,200
reference to them

243
00:09:23,200 --> 00:09:24,399
then

244
00:09:24,399 --> 00:09:26,800
like the the situation with the memory

245
00:09:26,800 --> 00:09:28,399
is going to be weird you know because

246
00:09:28,399 --> 00:09:30,399
again it's still somebody is still using

247
00:09:30,399 --> 00:09:33,360
it so it makes sense and then

248
00:09:33,360 --> 00:09:36,240
okay this is now complicates everything

249
00:09:36,240 --> 00:09:38,000
and that's why it's so hard and that's

250
00:09:38,000 --> 00:09:39,839
why nobody like ever thought of

251
00:09:39,839 --> 00:09:41,680
exploiting it because

252
00:09:41,680 --> 00:09:43,839
if we destroyed a window

253
00:09:43,839 --> 00:09:45,120
that is

254
00:09:45,120 --> 00:09:47,440
now in a zombie situation user mode

255
00:09:47,440 --> 00:09:49,760
cannot access it so if we have like a

256
00:09:49,760 --> 00:09:52,480
handle to window edgewind and we try to

257
00:09:52,480 --> 00:09:54,160
call another cisco

258
00:09:54,160 --> 00:09:56,720
it's gonna say like invalid endell and

259
00:09:56,720 --> 00:09:59,440
good luck okay so the point is like we

260
00:09:59,440 --> 00:10:01,360
need to find a way and soon you will see

261
00:10:01,360 --> 00:10:04,240
why to do something about it so every

262
00:10:04,240 --> 00:10:06,160
object has different functionality to

263
00:10:06,160 --> 00:10:08,880
destroy it and every time we will see

264
00:10:08,880 --> 00:10:11,200
maybe in this one only one example how

265
00:10:11,200 --> 00:10:13,040
to exploit it

266
00:10:13,040 --> 00:10:15,040
okay so now

267
00:10:15,040 --> 00:10:17,600
as we said once the zombie reaches the

268
00:10:17,600 --> 00:10:20,000
last reference count from one to zero

269
00:10:20,000 --> 00:10:21,360
then it really

270
00:10:21,360 --> 00:10:23,440
frees the object and doing the

271
00:10:23,440 --> 00:10:25,920
destruction so let's take a look at

272
00:10:25,920 --> 00:10:28,240
destroy window api everybody knows the

273
00:10:28,240 --> 00:10:29,279
windows

274
00:10:29,279 --> 00:10:33,760
the window object in in the kernel and

275
00:10:33,760 --> 00:10:35,519
the first time the first time we called

276
00:10:35,519 --> 00:10:37,440
to destroy window what is going to

277
00:10:37,440 --> 00:10:39,760
happen is that immediately all the

278
00:10:39,760 --> 00:10:40,720
linked

279
00:10:40,720 --> 00:10:43,519
objects like child windows like the icon

280
00:10:43,519 --> 00:10:44,959
like so many

281
00:10:44,959 --> 00:10:46,800
other objects sub-objects or

282
00:10:46,800 --> 00:10:49,680
sub-resources are getting freed okay or

283
00:10:49,680 --> 00:10:51,360
getting disconnected

284
00:10:51,360 --> 00:10:53,920
so they try to create a situation where

285
00:10:53,920 --> 00:10:55,279
there is no

286
00:10:55,279 --> 00:10:59,120
no pro problem going to be happening

287
00:10:59,120 --> 00:11:01,279
so that's the first call okay the second

288
00:11:01,279 --> 00:11:02,560
time

289
00:11:02,560 --> 00:11:04,160
and this is the crazy part the second

290
00:11:04,160 --> 00:11:06,560
time is when you go again from the last

291
00:11:06,560 --> 00:11:08,800
reference it's about smash the ref okay

292
00:11:08,800 --> 00:11:11,600
so the last reference goes from one to

293
00:11:11,600 --> 00:11:14,000
zero and then what it does in the thread

294
00:11:14,000 --> 00:11:16,800
unlock because that's a manual like

295
00:11:16,800 --> 00:11:18,880
uh reference count

296
00:11:18,880 --> 00:11:22,320
it calls again xxx destroy window so the

297
00:11:22,320 --> 00:11:24,399
same function that we can trigger from

298
00:11:24,399 --> 00:11:27,440
user mode is now being called on a

299
00:11:27,440 --> 00:11:29,839
second time but the second time is

300
00:11:29,839 --> 00:11:32,000
becoming interesting because there might

301
00:11:32,000 --> 00:11:33,920
be some side effects

302
00:11:33,920 --> 00:11:35,279
okay

303
00:11:35,279 --> 00:11:37,839
so now this is the key to the to the

304
00:11:37,839 --> 00:11:40,399
exploit until now

305
00:11:40,399 --> 00:11:42,959
the background was like okay we call

306
00:11:42,959 --> 00:11:44,959
user mode we destroy something they

307
00:11:44,959 --> 00:11:48,320
forgot to lock it kaboom use after free

308
00:11:48,320 --> 00:11:50,720
but now everything is still like zombie

309
00:11:50,720 --> 00:11:53,360
stuff we cannot re-access it once it's

310
00:11:53,360 --> 00:11:55,760
destroyed from user mode and there is a

311
00:11:55,760 --> 00:11:57,680
situation that we need to find a way to

312
00:11:57,680 --> 00:11:59,600
bypass to exploit it

313
00:11:59,600 --> 00:12:02,240
so like object-oriented programming

314
00:12:02,240 --> 00:12:04,639
when a destructor is called right when

315
00:12:04,639 --> 00:12:06,639
the object is is dying

316
00:12:06,639 --> 00:12:08,880
it caused the destructors of the rest of

317
00:12:08,880 --> 00:12:11,200
its members to say

318
00:12:11,200 --> 00:12:13,440
everything is going to get freed

319
00:12:13,440 --> 00:12:14,880
together

320
00:12:14,880 --> 00:12:17,200
with the parent okay so can you start

321
00:12:17,200 --> 00:12:19,519
calculating some

322
00:12:19,519 --> 00:12:23,040
something here okay so

323
00:12:23,519 --> 00:12:26,480
the smashup smashable site this is the

324
00:12:26,480 --> 00:12:30,399
recipe so the point was like let's find

325
00:12:30,399 --> 00:12:33,040
let's give a recipe for exactly finding

326
00:12:33,040 --> 00:12:35,360
all the places in the code where we can

327
00:12:35,360 --> 00:12:36,959
find this

328
00:12:36,959 --> 00:12:39,040
extreme case where we have this

329
00:12:39,040 --> 00:12:41,120
situation and i will give an example but

330
00:12:41,120 --> 00:12:43,519
try to follow these guidelines okay dumb

331
00:12:43,519 --> 00:12:45,440
pointer and see it's all the pointers so

332
00:12:45,440 --> 00:12:48,880
the kernel we talk about is like c

333
00:12:48,880 --> 00:12:51,600
and it's a sign like we saw p

334
00:12:51,600 --> 00:12:54,959
equal xxx create window so you get that

335
00:12:54,959 --> 00:12:57,279
and then the last decrease decrement

336
00:12:57,279 --> 00:13:00,560
reference functionality like goes thread

337
00:13:00,560 --> 00:13:02,959
unlock from one to zero that's something

338
00:13:02,959 --> 00:13:05,279
we want to know because that's where we

339
00:13:05,279 --> 00:13:07,279
call the second time destruction with

340
00:13:07,279 --> 00:13:09,839
the side effects and we want to control

341
00:13:09,839 --> 00:13:12,480
it okay some sometimes we cannot have

342
00:13:12,480 --> 00:13:14,480
exactly where we want

343
00:13:14,480 --> 00:13:15,360
to

344
00:13:15,360 --> 00:13:17,040
free other objects

345
00:13:17,040 --> 00:13:19,120
at the right location

346
00:13:19,120 --> 00:13:21,519
and then if we manage to control the

347
00:13:21,519 --> 00:13:22,880
last place

348
00:13:22,880 --> 00:13:24,959
and load

349
00:13:24,959 --> 00:13:27,600
extra members so the destructor might

350
00:13:27,600 --> 00:13:29,600
take with it other members

351
00:13:29,600 --> 00:13:31,200
okay so you see what we are doing here

352
00:13:31,200 --> 00:13:33,200
we chain objects together so the

353
00:13:33,200 --> 00:13:34,639
destructor

354
00:13:34,639 --> 00:13:36,959
once it's called taking down with it

355
00:13:36,959 --> 00:13:38,720
more objects and we're going to see how

356
00:13:38,720 --> 00:13:41,199
it's happening so then we are going to

357
00:13:41,199 --> 00:13:44,240
have use after free of the first pointer

358
00:13:44,240 --> 00:13:45,199
and

359
00:13:45,199 --> 00:13:47,360
now there is a situation here if the

360
00:13:47,360 --> 00:13:49,920
first time we call destroy window

361
00:13:49,920 --> 00:13:51,600
is

362
00:13:51,600 --> 00:13:54,240
kind of cleaned all of its members so

363
00:13:54,240 --> 00:13:55,680
how are we going

364
00:13:55,680 --> 00:13:58,079
to reconnect another window for example

365
00:13:58,079 --> 00:14:01,040
or another timer or whatever ui objects

366
00:14:01,040 --> 00:14:02,399
out there

367
00:14:02,399 --> 00:14:05,360
to be part of it okay so this is why

368
00:14:05,360 --> 00:14:08,560
things are getting more complicated

369
00:14:08,560 --> 00:14:10,079
okay so let's see

370
00:14:10,079 --> 00:14:13,040
like the the cell record implementation

371
00:14:13,040 --> 00:14:15,839
of xxx destroyer window as you can see

372
00:14:15,839 --> 00:14:17,600
first thing it does or not really first

373
00:14:17,600 --> 00:14:20,240
but the interesting thing it destroys

374
00:14:20,240 --> 00:14:21,839
all the children

375
00:14:21,839 --> 00:14:24,160
windows okay so imagine you have a

376
00:14:24,160 --> 00:14:26,880
window you created more windows saying

377
00:14:26,880 --> 00:14:29,199
this is my print window if you take down

378
00:14:29,199 --> 00:14:32,240
the normal without this exploitation so

379
00:14:32,240 --> 00:14:34,079
the parent window will kill all of its

380
00:14:34,079 --> 00:14:35,920
windows together with it okay so that's

381
00:14:35,920 --> 00:14:37,440
one example of

382
00:14:37,440 --> 00:14:39,600
like the sub resources being leaked and

383
00:14:39,600 --> 00:14:42,000
being destroyed together so just so you

384
00:14:42,000 --> 00:14:44,399
start to understand how it works and

385
00:14:44,399 --> 00:14:46,320
then another example you can release a

386
00:14:46,320 --> 00:14:47,920
capture it doesn't mean

387
00:14:47,920 --> 00:14:49,920
never mind what a capture is

388
00:14:49,920 --> 00:14:52,000
um it's old stuff but it's another

389
00:14:52,000 --> 00:14:54,000
object that you can crawl and and do

390
00:14:54,000 --> 00:14:56,320
like exploitation then you dereference

391
00:14:56,320 --> 00:14:57,360
the class

392
00:14:57,360 --> 00:14:58,480
lots of

393
00:14:58,480 --> 00:15:01,199
class bugs also in win32k

394
00:15:01,199 --> 00:15:02,959
and then this is the interesting part

395
00:15:02,959 --> 00:15:04,959
okay this is where they check the

396
00:15:04,959 --> 00:15:07,680
reference number because as you see the

397
00:15:07,680 --> 00:15:10,160
object destroy it checks for zero

398
00:15:10,160 --> 00:15:12,320
references if there are zero it can

399
00:15:12,320 --> 00:15:15,040
really free the object if there are more

400
00:15:15,040 --> 00:15:17,440
it's gonna do one thing to say you know

401
00:15:17,440 --> 00:15:20,079
what remember that somebody said let's

402
00:15:20,079 --> 00:15:22,639
destroy it later when you go from one to

403
00:15:22,639 --> 00:15:25,199
zero please destroy it for good because

404
00:15:25,199 --> 00:15:28,000
that's that's like the last reference

405
00:15:28,000 --> 00:15:30,880
and that's like a destroyer object okay

406
00:15:30,880 --> 00:15:33,279
otherwise it stays a zombie it skips the

407
00:15:33,279 --> 00:15:35,199
if statement it stays a

408
00:15:35,199 --> 00:15:37,440
zombie and that's the interesting in

409
00:15:37,440 --> 00:15:40,959
between mode we want to be okay so now

410
00:15:40,959 --> 00:15:42,079
let's see

411
00:15:42,079 --> 00:15:44,320
a super simplified example but just to

412
00:15:44,320 --> 00:15:46,079
give you an idea of

413
00:15:46,079 --> 00:15:48,240
how it's um

414
00:15:48,240 --> 00:15:51,120
how it is okay so this is like a certain

415
00:15:51,120 --> 00:15:52,079
code

416
00:15:52,079 --> 00:15:54,240
or just a simplified real example of

417
00:15:54,240 --> 00:15:56,959
something i exploited okay so so it's

418
00:15:56,959 --> 00:15:58,639
tons of code and then we get to the

419
00:15:58,639 --> 00:16:00,959
thread lock we lock the parent window

420
00:16:00,959 --> 00:16:02,800
okay so now whatever

421
00:16:02,800 --> 00:16:05,279
number of references that window had now

422
00:16:05,279 --> 00:16:09,519
it has plus one okay so p wind some damn

423
00:16:09,519 --> 00:16:12,720
c pointer is equal x success create

424
00:16:12,720 --> 00:16:13,839
window but

425
00:16:13,839 --> 00:16:16,000
can you see something interesting about

426
00:16:16,000 --> 00:16:17,120
it

427
00:16:17,120 --> 00:16:18,320
there is

428
00:16:18,320 --> 00:16:20,240
a link between the child window and the

429
00:16:20,240 --> 00:16:22,880
parent window okay so now after you know

430
00:16:22,880 --> 00:16:25,279
how xxx the story window

431
00:16:25,279 --> 00:16:26,800
is working you say huh there is

432
00:16:26,800 --> 00:16:28,079
something here

433
00:16:28,079 --> 00:16:31,519
okay and then we go next to tread unlock

434
00:16:31,519 --> 00:16:33,600
of the parent window because we got it

435
00:16:33,600 --> 00:16:36,880
one reference up now one reference down

436
00:16:36,880 --> 00:16:39,440
and this is where the magic happens okay

437
00:16:39,440 --> 00:16:41,360
so by now i know it's been a lot to

438
00:16:41,360 --> 00:16:43,440
catch up so i will try to go over it

439
00:16:43,440 --> 00:16:44,880
slowly and say

440
00:16:44,880 --> 00:16:47,040
what we try to do here

441
00:16:47,040 --> 00:16:49,199
is the thread unlock that you are seeing

442
00:16:49,199 --> 00:16:52,000
on the screen okay

443
00:16:52,000 --> 00:16:54,800
we want to take to make sure at that

444
00:16:54,800 --> 00:16:58,000
exact point the last reference of the

445
00:16:58,000 --> 00:16:59,120
the

446
00:16:59,120 --> 00:17:01,680
window the parent window is going from

447
00:17:01,680 --> 00:17:04,240
one to zero okay and now we know there

448
00:17:04,240 --> 00:17:05,919
is a cascading effect of all the

449
00:17:05,919 --> 00:17:08,079
destructors of the members

450
00:17:08,079 --> 00:17:10,559
of that part window going down with it

451
00:17:10,559 --> 00:17:12,799
so who is it that is going down with it

452
00:17:12,799 --> 00:17:14,640
that's the child window that we just

453
00:17:14,640 --> 00:17:15,679
created

454
00:17:15,679 --> 00:17:19,160
but if you remember

455
00:17:19,919 --> 00:17:21,520
if we go back

456
00:17:21,520 --> 00:17:23,359
destroy all children

457
00:17:23,359 --> 00:17:25,119
it will destroy anything with it it

458
00:17:25,119 --> 00:17:26,559
doesn't matter if it was destroyed

459
00:17:26,559 --> 00:17:30,240
before or after okay so now when we said

460
00:17:30,240 --> 00:17:32,480
the first ui object reference account

461
00:17:32,480 --> 00:17:35,280
upon creation is zero right

462
00:17:35,280 --> 00:17:37,840
so when we unlock and destroy the parent

463
00:17:37,840 --> 00:17:40,799
window because xxx create window calls

464
00:17:40,799 --> 00:17:42,799
back to user mode we are going to see it

465
00:17:42,799 --> 00:17:43,919
in a second

466
00:17:43,919 --> 00:17:46,480
but the point is that this location both

467
00:17:46,480 --> 00:17:48,880
objects are destroyed

468
00:17:48,880 --> 00:17:51,520
and then they will check for null

469
00:17:51,520 --> 00:17:53,520
but now it's used after free

470
00:17:53,520 --> 00:17:56,799
uh xxx create window thinks like it

471
00:17:56,799 --> 00:17:58,400
doesn't think everything there was

472
00:17:58,400 --> 00:18:01,039
alright so it returns a valid pointer

473
00:18:01,039 --> 00:18:02,880
because it actually

474
00:18:02,880 --> 00:18:05,039
succeeded in creating a window trade

475
00:18:05,039 --> 00:18:07,760
unlock will take both of them down the

476
00:18:07,760 --> 00:18:10,000
if statement is going to pass

477
00:18:10,000 --> 00:18:12,480
and then xxx send message p wind is like

478
00:18:12,480 --> 00:18:16,080
used after free very easy to explore

479
00:18:16,080 --> 00:18:18,799
okay so this is how the stack looks

480
00:18:18,799 --> 00:18:20,720
and it starts from

481
00:18:20,720 --> 00:18:21,840
the bottom

482
00:18:21,840 --> 00:18:23,840
you can see the open hierarchy and then

483
00:18:23,840 --> 00:18:25,120
trade unlock

484
00:18:25,120 --> 00:18:27,280
that's the thread unlock you're seeing

485
00:18:27,280 --> 00:18:28,640
here okay

486
00:18:28,640 --> 00:18:30,000
and then it will

487
00:18:30,000 --> 00:18:32,640
xxx destroy the window you can see it's

488
00:18:32,640 --> 00:18:35,120
gonna do assignment unlock so assignment

489
00:18:35,120 --> 00:18:38,480
unlock is binding two objects for longer

490
00:18:38,480 --> 00:18:40,640
period of time with like

491
00:18:40,640 --> 00:18:43,360
uh incrementing the reference count okay

492
00:18:43,360 --> 00:18:45,200
so the point is now

493
00:18:45,200 --> 00:18:47,360
the child is gonna be

494
00:18:47,360 --> 00:18:48,720
freed as well

495
00:18:48,720 --> 00:18:50,880
okay as you can see i cheated a bit

496
00:18:50,880 --> 00:18:52,640
because this is the real stack but i i

497
00:18:52,640 --> 00:18:54,240
was trying to make it easy with the

498
00:18:54,240 --> 00:18:56,960
destroyed children but now there will be

499
00:18:56,960 --> 00:18:59,840
another xxx destroy window on the child

500
00:18:59,840 --> 00:19:02,240
okay so now two windows both the parent

501
00:19:02,240 --> 00:19:03,520
and the child

502
00:19:03,520 --> 00:19:05,520
are getting killed and that's why we

503
00:19:05,520 --> 00:19:06,799
have this

504
00:19:06,799 --> 00:19:09,280
uh crazy situation that the zombie is

505
00:19:09,280 --> 00:19:11,039
killing another is something that it

506
00:19:11,039 --> 00:19:13,520
shouldn't have so as you can see

507
00:19:13,520 --> 00:19:15,919
we kill them both in this kind of chain

508
00:19:15,919 --> 00:19:18,160
effect

509
00:19:18,160 --> 00:19:20,400
um

510
00:19:20,400 --> 00:19:22,240
i just want to make sure it's clear

511
00:19:22,240 --> 00:19:24,880
because i know it's very hard and to

512
00:19:24,880 --> 00:19:27,760
make sure like i'm in the logic so

513
00:19:27,760 --> 00:19:30,160
normally

514
00:19:30,799 --> 00:19:32,880
any questions from the crowd about it

515
00:19:32,880 --> 00:19:34,799
because i want to make sure it's

516
00:19:34,799 --> 00:19:38,360
it's like clear

517
00:19:38,720 --> 00:19:40,480
okay

518
00:19:40,480 --> 00:19:42,640
okay so now we need to reload the zombie

519
00:19:42,640 --> 00:19:44,720
okay and reloading a zombie is very hard

520
00:19:44,720 --> 00:19:47,039
because we said it's not accessible from

521
00:19:47,039 --> 00:19:48,240
user mode

522
00:19:48,240 --> 00:19:50,799
so if actually if you look at this code

523
00:19:50,799 --> 00:19:53,200
you tell me gil you are a liar because i

524
00:19:53,200 --> 00:19:55,600
don't see how you can connect

525
00:19:55,600 --> 00:19:56,799
the

526
00:19:56,799 --> 00:19:59,200
both windows and destroy the window and

527
00:19:59,200 --> 00:20:00,720
what's going on like you're not telling

528
00:20:00,720 --> 00:20:03,039
me something okay and that's really true

529
00:20:03,039 --> 00:20:05,520
because i'm trying to simplify it and

530
00:20:05,520 --> 00:20:08,000
soon you will see why it gets crazy but

531
00:20:08,000 --> 00:20:09,840
this is how the stack looks

532
00:20:09,840 --> 00:20:12,159
when we try to kill it

533
00:20:12,159 --> 00:20:14,240
so you know it works trust me

534
00:20:14,240 --> 00:20:16,159
okay

535
00:20:16,159 --> 00:20:19,120
so if we destroyed a window and we said

536
00:20:19,120 --> 00:20:21,039
the first time we call destroy window it

537
00:20:21,039 --> 00:20:24,240
disconnects all the sub resources okay

538
00:20:24,240 --> 00:20:25,600
but then

539
00:20:25,600 --> 00:20:27,760
something is is missing here so now we

540
00:20:27,760 --> 00:20:30,400
need to stack another operation

541
00:20:30,400 --> 00:20:33,039
before we destroy the window but

542
00:20:33,039 --> 00:20:35,120
something will happen after that it's

543
00:20:35,120 --> 00:20:36,720
destroyed okay so

544
00:20:36,720 --> 00:20:38,799
yeah it's kind of of

545
00:20:38,799 --> 00:20:41,440
a weird situation okay

546
00:20:41,440 --> 00:20:42,559
let's see

547
00:20:42,559 --> 00:20:45,679
like in a very easy way how it looks so

548
00:20:45,679 --> 00:20:47,120
the point is

549
00:20:47,120 --> 00:20:49,520
again starting from main we call you

550
00:20:49,520 --> 00:20:52,080
know from user mode some kernel cisco

551
00:20:52,080 --> 00:20:54,480
set window long for this example and

552
00:20:54,480 --> 00:20:57,520
then inside the cisco xxx what happens

553
00:20:57,520 --> 00:20:59,280
next is

554
00:20:59,280 --> 00:21:01,760
doing some xxx send message

555
00:21:01,760 --> 00:21:03,520
goes back

556
00:21:03,520 --> 00:21:05,760
to userland and then what we do there we

557
00:21:05,760 --> 00:21:08,159
destroy the window as we know goes back

558
00:21:08,159 --> 00:21:10,480
to number four the kernel kills the

559
00:21:10,480 --> 00:21:12,799
window but you remember the window still

560
00:21:12,799 --> 00:21:15,919
has a reference so it's really destroyed

561
00:21:15,919 --> 00:21:18,159
disconnects everything from it but then

562
00:21:18,159 --> 00:21:21,440
it goes back to number three back to

563
00:21:21,440 --> 00:21:23,440
number two right it's all in the stack

564
00:21:23,440 --> 00:21:25,280
all the return addresses

565
00:21:25,280 --> 00:21:27,440
and then look what happens next

566
00:21:27,440 --> 00:21:30,640
so the situation of number five exactly

567
00:21:30,640 --> 00:21:32,480
is the most critical thing about this

568
00:21:32,480 --> 00:21:34,960
exploitation okay because now that

569
00:21:34,960 --> 00:21:37,039
window was destroyed

570
00:21:37,039 --> 00:21:39,360
it disconnected all its members from

571
00:21:39,360 --> 00:21:41,679
itself but now what we are trying to do

572
00:21:41,679 --> 00:21:44,000
reload the zombies to attach again some

573
00:21:44,000 --> 00:21:45,280
member to it

574
00:21:45,280 --> 00:21:47,360
without accessing it again from user

575
00:21:47,360 --> 00:21:49,520
mode so what we have here is a situation

576
00:21:49,520 --> 00:21:52,559
where where it's a zombie but now look

577
00:21:52,559 --> 00:21:55,360
at this it's gonna change the style

578
00:21:55,360 --> 00:21:57,520
okay so let's suppose the style was

579
00:21:57,520 --> 00:22:00,159
reset now it changes the style

580
00:22:00,159 --> 00:22:02,159
to a zombie window something that

581
00:22:02,159 --> 00:22:04,320
shouldn't be happening okay because we

582
00:22:04,320 --> 00:22:06,000
said we cannot just free the object

583
00:22:06,000 --> 00:22:08,240
because if we free it

584
00:22:08,240 --> 00:22:09,919
like we're gonna crush the system or

585
00:22:09,919 --> 00:22:12,480
easily exploit it okay so this is the

586
00:22:12,480 --> 00:22:14,960
example of how we stack something

587
00:22:14,960 --> 00:22:17,760
because once we come back from destroy

588
00:22:17,760 --> 00:22:19,840
we want to reach a point where we know

589
00:22:19,840 --> 00:22:22,559
in the kernel it continues to do

590
00:22:22,559 --> 00:22:25,440
uh work on that object okay so that's

591
00:22:25,440 --> 00:22:27,520
the technique to reload it with extra

592
00:22:27,520 --> 00:22:29,919
stuff so instead of changing

593
00:22:29,919 --> 00:22:32,240
the style here what we can do is for

594
00:22:32,240 --> 00:22:33,440
example

595
00:22:33,440 --> 00:22:35,600
just link another window to it or just

596
00:22:35,600 --> 00:22:37,520
link another menu to it or do lots of

597
00:22:37,520 --> 00:22:40,400
stuff so we bypass the first

598
00:22:40,400 --> 00:22:42,480
destruction that cleans everything and

599
00:22:42,480 --> 00:22:44,559
then we cause it to return

600
00:22:44,559 --> 00:22:47,520
like link more uh stuff to it

601
00:22:47,520 --> 00:22:49,360
okay

602
00:22:49,360 --> 00:22:51,039
so now we're going to talk a bit about

603
00:22:51,039 --> 00:22:52,559
the exploitation

604
00:22:52,559 --> 00:22:54,640
and the problem is the last reference

605
00:22:54,640 --> 00:22:57,360
count it goes from one to zero and there

606
00:22:57,360 --> 00:23:00,159
is one obstacle like big obstacle that

607
00:23:00,159 --> 00:23:02,480
the destruction at the second time and

608
00:23:02,480 --> 00:23:05,440
this is all by design i mean they they

609
00:23:05,440 --> 00:23:07,200
know what they are doing okay with all

610
00:23:07,200 --> 00:23:09,600
the manual reference count

611
00:23:09,600 --> 00:23:12,240
and what they said is the second time

612
00:23:12,240 --> 00:23:14,880
we are not going to call any callbacks

613
00:23:14,880 --> 00:23:17,039
because remember thread unlock

614
00:23:17,039 --> 00:23:19,520
is not a safe place to call

615
00:23:19,520 --> 00:23:22,400
user mode why because it's not xxx so

616
00:23:22,400 --> 00:23:25,200
other developers might get confused and

617
00:23:25,200 --> 00:23:26,960
that's what we are doing here confusing

618
00:23:26,960 --> 00:23:27,760
them

619
00:23:27,760 --> 00:23:29,600
so the problem is

620
00:23:29,600 --> 00:23:32,480
if it doesn't go back to user mode now

621
00:23:32,480 --> 00:23:34,400
we have a race condition situation that

622
00:23:34,400 --> 00:23:36,640
we need to exploit and you know being in

623
00:23:36,640 --> 00:23:39,120
race condition situations

624
00:23:39,120 --> 00:23:42,159
is really like not fun and i said okay

625
00:23:42,159 --> 00:23:45,039
maybe i can try okay and remember that

626
00:23:45,039 --> 00:23:47,440
as long as the user critical section

627
00:23:47,440 --> 00:23:49,919
from kernel is is

628
00:23:49,919 --> 00:23:50,799
held

629
00:23:50,799 --> 00:23:52,720
then another thread cannot just get into

630
00:23:52,720 --> 00:23:54,960
the same code in the kernel and just

631
00:23:54,960 --> 00:23:57,760
like catch the freed block or something

632
00:23:57,760 --> 00:23:59,840
like that so the point is

633
00:23:59,840 --> 00:24:02,320
there is no good good way to

634
00:24:02,320 --> 00:24:05,840
to exploit it actually empty gdi is not

635
00:24:05,840 --> 00:24:08,240
protected with the same critical section

636
00:24:08,240 --> 00:24:10,480
so i found some ciscos that we invented

637
00:24:10,480 --> 00:24:12,799
gdi i could get in at the same time and

638
00:24:12,799 --> 00:24:15,600
spin on allocation try to catch the free

639
00:24:15,600 --> 00:24:16,480
block

640
00:24:16,480 --> 00:24:19,120
that's too tiring it's statistical i

641
00:24:19,120 --> 00:24:20,480
don't like that

642
00:24:20,480 --> 00:24:22,000
and then there are other mitigations i'm

643
00:24:22,000 --> 00:24:23,760
going to skip for now

644
00:24:23,760 --> 00:24:26,799
so the point was

645
00:24:26,799 --> 00:24:29,200
like asking myself how do i

646
00:24:29,200 --> 00:24:31,360
get back to user mode exactly at the

647
00:24:31,360 --> 00:24:33,360
thread unlock because if i manage to do

648
00:24:33,360 --> 00:24:34,240
that

649
00:24:34,240 --> 00:24:35,679
then it's like a synchronous

650
00:24:35,679 --> 00:24:37,919
exploitation there is no ways and

651
00:24:37,919 --> 00:24:40,000
everything is easy so imagine at the

652
00:24:40,000 --> 00:24:42,880
thread unlock it goes back to user mode

653
00:24:42,880 --> 00:24:44,559
i can do pretty much whatever i want

654
00:24:44,559 --> 00:24:46,880
from there catch the blocks i have tons

655
00:24:46,880 --> 00:24:48,960
of time until i get back to kernel

656
00:24:48,960 --> 00:24:51,360
everything is deterministic piece of

657
00:24:51,360 --> 00:24:52,720
cake

658
00:24:52,720 --> 00:24:55,440
okay so that's what i call the ultimate

659
00:24:55,440 --> 00:24:56,960
reloading

660
00:24:56,960 --> 00:24:57,919
and

661
00:24:57,919 --> 00:25:00,080
at that time i was like okay i need to

662
00:25:00,080 --> 00:25:02,720
find something and i went over

663
00:25:02,720 --> 00:25:05,039
reverse engineering everything about how

664
00:25:05,039 --> 00:25:07,200
window is created and how the

665
00:25:07,200 --> 00:25:08,880
destruction works

666
00:25:08,880 --> 00:25:11,919
and eventually i found one place

667
00:25:11,919 --> 00:25:14,320
that they forgot to check and i told you

668
00:25:14,320 --> 00:25:15,919
the second time

669
00:25:15,919 --> 00:25:18,559
like the last uh reference when it goes

670
00:25:18,559 --> 00:25:21,039
in the thread unlock from one to zero

671
00:25:21,039 --> 00:25:23,760
they know not to call back user mode and

672
00:25:23,760 --> 00:25:25,840
what i'm trying to do here is to bypass

673
00:25:25,840 --> 00:25:28,400
that so everything is synchronous okay

674
00:25:28,400 --> 00:25:29,919
so i found

675
00:25:29,919 --> 00:25:31,919
that whenever they

676
00:25:31,919 --> 00:25:33,919
create whenever i create a window from

677
00:25:33,919 --> 00:25:37,200
user mode i can give some extra window

678
00:25:37,200 --> 00:25:39,360
bytes doesn't matter what it it does for

679
00:25:39,360 --> 00:25:41,760
now but the point is they they take some

680
00:25:41,760 --> 00:25:43,120
pointer

681
00:25:43,120 --> 00:25:45,360
uh from user mode and once they see that

682
00:25:45,360 --> 00:25:47,039
they need to

683
00:25:47,039 --> 00:25:49,120
again they allocated something they want

684
00:25:49,120 --> 00:25:50,320
in the free

685
00:25:50,320 --> 00:25:53,919
in the destruction to free it okay

686
00:25:53,919 --> 00:25:55,760
so now

687
00:25:55,760 --> 00:25:58,320
that you understand how we can do

688
00:25:58,320 --> 00:25:59,600
like

689
00:25:59,600 --> 00:26:01,279
this kind of stuff

690
00:26:01,279 --> 00:26:03,840
it should be obvious

691
00:26:03,840 --> 00:26:04,960
kind of

692
00:26:04,960 --> 00:26:06,400
um

693
00:26:06,400 --> 00:26:09,120
that at the xxx co look

694
00:26:09,120 --> 00:26:11,039
there is something wrong okay or

695
00:26:11,039 --> 00:26:13,039
something like we can exploit

696
00:26:13,039 --> 00:26:15,360
um or before that

697
00:26:15,360 --> 00:26:16,400
so

698
00:26:16,400 --> 00:26:18,159
okay it goes like this

699
00:26:18,159 --> 00:26:20,240
create window in kernel goes back with

700
00:26:20,240 --> 00:26:22,400
client alloc window and then we can

701
00:26:22,400 --> 00:26:24,640
destroy the window okay

702
00:26:24,640 --> 00:26:26,799
destroy the window while it's being

703
00:26:26,799 --> 00:26:29,440
created what the heck that works but the

704
00:26:29,440 --> 00:26:32,720
problem is that if it goes to the end of

705
00:26:32,720 --> 00:26:34,880
create window create window is going to

706
00:26:34,880 --> 00:26:37,120
say is the window really

707
00:26:37,120 --> 00:26:39,600
fully created or is it destroyed if it

708
00:26:39,600 --> 00:26:41,440
sees that it's somehow destroyed it

709
00:26:41,440 --> 00:26:44,000
returns null if it returns null like we

710
00:26:44,000 --> 00:26:46,159
saw earlier it's not gonna work so i

711
00:26:46,159 --> 00:26:48,240
needed to do something

712
00:26:48,240 --> 00:26:49,840
to keep it in

713
00:26:49,840 --> 00:26:52,640
extra limbo situation on top of a zombie

714
00:26:52,640 --> 00:26:54,880
okay and the question what was that so

715
00:26:54,880 --> 00:26:57,440
let's see what i try to do here okay

716
00:26:57,440 --> 00:27:00,880
i'm registering a class with some like

717
00:27:00,880 --> 00:27:03,520
forcing it to allocate back memory in

718
00:27:03,520 --> 00:27:06,000
user mode okay and what we see create

719
00:27:06,000 --> 00:27:08,559
window goes back to the kernel the

720
00:27:08,559 --> 00:27:11,039
kernel goes back to number three

721
00:27:11,039 --> 00:27:12,960
some hook that i need to do in user

722
00:27:12,960 --> 00:27:14,000
space

723
00:27:14,000 --> 00:27:16,880
and there i call destroy window

724
00:27:16,880 --> 00:27:17,840
and

725
00:27:17,840 --> 00:27:20,159
now the window partially created not

726
00:27:20,159 --> 00:27:24,320
even fully initialized already destroyed

727
00:27:24,320 --> 00:27:26,640
and then it goes back

728
00:27:26,640 --> 00:27:30,960
to number four you can see the xxx

729
00:27:31,120 --> 00:27:33,520
yeah call hook and the hook is something

730
00:27:33,520 --> 00:27:35,760
that you can easily sign up for and

731
00:27:35,760 --> 00:27:37,919
get the hooks and then what happens at

732
00:27:37,919 --> 00:27:39,200
five

733
00:27:39,200 --> 00:27:40,159
okay

734
00:27:40,159 --> 00:27:43,120
now i need to do something crazy at five

735
00:27:43,120 --> 00:27:44,480
that will

736
00:27:44,480 --> 00:27:46,240
not reach to the end of the create

737
00:27:46,240 --> 00:27:48,320
window in the kernel because if we reach

738
00:27:48,320 --> 00:27:49,360
that

739
00:27:49,360 --> 00:27:51,520
like the create the create window is

740
00:27:51,520 --> 00:27:53,440
busted

741
00:27:53,440 --> 00:27:55,039
any ideas

742
00:27:55,039 --> 00:27:58,559
okay so let me let me reiterate why i'm

743
00:27:58,559 --> 00:28:00,399
doing what i'm doing because

744
00:28:00,399 --> 00:28:01,760
once

745
00:28:01,760 --> 00:28:05,200
we manage to do this crazy um

746
00:28:05,200 --> 00:28:07,360
like side effect reloading

747
00:28:07,360 --> 00:28:09,919
when the last reference goes from one to

748
00:28:09,919 --> 00:28:13,440
zero at the thread unlock it will see oh

749
00:28:13,440 --> 00:28:14,720
i need to

750
00:28:14,720 --> 00:28:16,480
freeze something in user mode so let's

751
00:28:16,480 --> 00:28:19,360
call back to user mode but this time

752
00:28:19,360 --> 00:28:20,960
they forgot to

753
00:28:20,960 --> 00:28:22,159
make sure

754
00:28:22,159 --> 00:28:23,760
it shouldn't go because it's the last

755
00:28:23,760 --> 00:28:25,600
reference we said last reference trade

756
00:28:25,600 --> 00:28:27,600
unlock it shouldn't go this is the only

757
00:28:27,600 --> 00:28:30,720
code that they forgot to check that flag

758
00:28:30,720 --> 00:28:32,880
like internal flag and that's the

759
00:28:32,880 --> 00:28:35,360
exploit so now i need to make sure

760
00:28:35,360 --> 00:28:36,320
that

761
00:28:36,320 --> 00:28:38,480
nobody is messing up with the window

762
00:28:38,480 --> 00:28:41,440
once i get back to the kernel okay so

763
00:28:41,440 --> 00:28:43,200
let's see how i did it

764
00:28:43,200 --> 00:28:46,080
and that's a spoiler

765
00:28:46,080 --> 00:28:47,840
so at number five

766
00:28:47,840 --> 00:28:50,480
we managed to tell the window to reload

767
00:28:50,480 --> 00:28:52,880
it with a user mode pointer so when it

768
00:28:52,880 --> 00:28:55,279
goes back to kill the object the last

769
00:28:55,279 --> 00:28:57,760
reference it will call back

770
00:28:57,760 --> 00:28:58,880
the

771
00:28:58,880 --> 00:29:00,640
the free uh

772
00:29:00,640 --> 00:29:03,520
the memory free in in user mode but now

773
00:29:03,520 --> 00:29:06,080
what i did was i needed a way

774
00:29:06,080 --> 00:29:07,600
to cut

775
00:29:07,600 --> 00:29:08,559
the

776
00:29:08,559 --> 00:29:11,279
window creation inside the kernel and

777
00:29:11,279 --> 00:29:13,520
the only way to do it without somebody

778
00:29:13,520 --> 00:29:15,360
coming in in between

779
00:29:15,360 --> 00:29:17,279
the rest of the windowed creation and

780
00:29:17,279 --> 00:29:19,760
resetting my pointer because then

781
00:29:19,760 --> 00:29:21,440
it's not going to work at the last

782
00:29:21,440 --> 00:29:22,720
reference

783
00:29:22,720 --> 00:29:25,600
is by calling exit thread so i actually

784
00:29:25,600 --> 00:29:27,039
kill the thread in the middle of the

785
00:29:27,039 --> 00:29:28,559
initialization

786
00:29:28,559 --> 00:29:30,480
the user mode pointer

787
00:29:30,480 --> 00:29:31,279
is

788
00:29:31,279 --> 00:29:34,799
keep pointing to my user mode memory and

789
00:29:34,799 --> 00:29:37,039
then at the last reference what happens

790
00:29:37,039 --> 00:29:40,559
is that it's going to call me to free it

791
00:29:40,559 --> 00:29:42,960
okay so this was like the craziest part

792
00:29:42,960 --> 00:29:45,200
of the whole thing even though it's like

793
00:29:45,200 --> 00:29:47,679
your old design flow i was like super

794
00:29:47,679 --> 00:29:50,640
excited that it was so easy to exploit

795
00:29:50,640 --> 00:29:53,279
it now and now it also unlocked new

796
00:29:53,279 --> 00:29:55,760
opportunities okay like like we used to

797
00:29:55,760 --> 00:29:58,640
see before so imagine now there is some

798
00:29:58,640 --> 00:30:01,600
unlock notify window whatever it means

799
00:30:01,600 --> 00:30:05,279
it goes over it iterates over some array

800
00:30:05,279 --> 00:30:07,760
and now we see that it calls itself

801
00:30:07,760 --> 00:30:10,399
recursively but the point is

802
00:30:10,399 --> 00:30:13,120
you can see that unlock the last line we

803
00:30:13,120 --> 00:30:15,440
know that there the unlock

804
00:30:15,440 --> 00:30:18,159
might be if we carefully craft it that

805
00:30:18,159 --> 00:30:20,720
it goes from one to zero and then we can

806
00:30:20,720 --> 00:30:23,200
call back to user mode but this time we

807
00:30:23,200 --> 00:30:25,360
don't need to change more objects this

808
00:30:25,360 --> 00:30:27,919
time we just need to reallocate the

809
00:30:27,919 --> 00:30:30,559
array items like the

810
00:30:30,559 --> 00:30:32,960
sub menus of a menu and then it's going

811
00:30:32,960 --> 00:30:34,799
to be used after free because the

812
00:30:34,799 --> 00:30:36,559
pointer as you see it just

813
00:30:36,559 --> 00:30:38,640
keeps on jumping to the next one so

814
00:30:38,640 --> 00:30:42,399
that's like a new way to to do something

815
00:30:42,399 --> 00:30:45,600
okay so to wrap up

816
00:30:45,679 --> 00:30:48,159
um

817
00:30:49,200 --> 00:30:50,799
so we see that when we call some

818
00:30:50,799 --> 00:30:52,880
destructors and there are plenty of

819
00:30:52,880 --> 00:30:55,520
objects okay it might be destroy wind

820
00:30:55,520 --> 00:30:57,039
menu or window

821
00:30:57,039 --> 00:30:59,360
or free timer or lots of other stuff

822
00:30:59,360 --> 00:31:01,679
there but the point is that

823
00:31:01,679 --> 00:31:04,720
there is one primary object that i try

824
00:31:04,720 --> 00:31:06,640
to destroy

825
00:31:06,640 --> 00:31:09,440
but whenever that primary object is

826
00:31:09,440 --> 00:31:12,320
freed in certain locations i try to take

827
00:31:12,320 --> 00:31:15,519
down with it extra objects like you saw

828
00:31:15,519 --> 00:31:16,640
okay

829
00:31:16,640 --> 00:31:18,720
and the only way to do it

830
00:31:18,720 --> 00:31:21,279
it it is with the zombie giant zombie

831
00:31:21,279 --> 00:31:24,320
chain sorry or reloading a zombie like

832
00:31:24,320 --> 00:31:26,559
we saw in the previous code snippet okay

833
00:31:26,559 --> 00:31:28,159
so that's together gives me like

834
00:31:28,159 --> 00:31:30,720
ultimate power to go to lots of

835
00:31:30,720 --> 00:31:34,159
places inside the code where there is a

836
00:31:34,159 --> 00:31:38,240
smashable site like the last decrep

837
00:31:38,240 --> 00:31:40,640
can actually free another object that

838
00:31:40,640 --> 00:31:43,120
wasn't even locked yet okay so that's

839
00:31:43,120 --> 00:31:44,559
the idea of that

840
00:31:44,559 --> 00:31:46,880
and microsoft themselves decided to call

841
00:31:46,880 --> 00:31:49,919
it primary versus secondary

842
00:31:49,919 --> 00:31:51,840
and remember that it doesn't leave the

843
00:31:51,840 --> 00:31:54,240
crit and the only way to do it is with

844
00:31:54,240 --> 00:31:56,640
the crazy trick with the user mode

845
00:31:56,640 --> 00:31:57,760
allocation

846
00:31:57,760 --> 00:31:59,679
pointer

847
00:31:59,679 --> 00:32:02,159
so the crazy stuff about this design

848
00:32:02,159 --> 00:32:03,200
flow

849
00:32:03,200 --> 00:32:05,440
is that it is a design flaw so i'm very

850
00:32:05,440 --> 00:32:07,600
lucky to be finding it i'm

851
00:32:07,600 --> 00:32:09,919
kind of grateful

852
00:32:09,919 --> 00:32:12,080
but the other thing is that the same

853
00:32:12,080 --> 00:32:14,080
problem happened in another mechanism in

854
00:32:14,080 --> 00:32:16,159
the kernel in the same windows ui

855
00:32:16,159 --> 00:32:18,559
component but another

856
00:32:18,559 --> 00:32:20,559
another kind of component miss the same

857
00:32:20,559 --> 00:32:24,480
kind of bug so that's kind of crazy

858
00:32:24,480 --> 00:32:26,159
okay so

859
00:32:26,159 --> 00:32:28,960
then i reversed engineered actually

860
00:32:28,960 --> 00:32:30,880
kind of worked together with them but

861
00:32:30,880 --> 00:32:32,480
the point was that

862
00:32:32,480 --> 00:32:35,039
they came up with a crazy

863
00:32:35,039 --> 00:32:37,360
um kind of not fun to implement

864
00:32:37,360 --> 00:32:40,000
mitigation for this exploit okay because

865
00:32:40,000 --> 00:32:42,559
they said okay let's start to use c plus

866
00:32:42,559 --> 00:32:44,720
plus it's going to be easier to scope

867
00:32:44,720 --> 00:32:45,840
some stuff

868
00:32:45,840 --> 00:32:47,600
but the point was that

869
00:32:47,600 --> 00:32:49,600
we know that we changed the destruction

870
00:32:49,600 --> 00:32:52,640
of a second object okay so they said

871
00:32:52,640 --> 00:32:54,960
if we find this weird situation where

872
00:32:54,960 --> 00:32:58,159
there is a second object being destroyed

873
00:32:58,159 --> 00:33:01,519
from another primary object we shouldn't

874
00:33:01,519 --> 00:33:03,120
free it right

875
00:33:03,120 --> 00:33:04,799
at the same point because now it's going

876
00:33:04,799 --> 00:33:07,120
to be used after free so what they said

877
00:33:07,120 --> 00:33:09,840
is they added a lot of code that again

878
00:33:09,840 --> 00:33:12,240
in a very sensitive place that they said

879
00:33:12,240 --> 00:33:13,840
let's cue it

880
00:33:13,840 --> 00:33:16,159
for a later destruction and when is a

881
00:33:16,159 --> 00:33:19,440
good timing to destroy objects and

882
00:33:19,440 --> 00:33:21,840
being sure it's not going to like screw

883
00:33:21,840 --> 00:33:24,320
up things once it goes back to user mode

884
00:33:24,320 --> 00:33:25,360
okay

885
00:33:25,360 --> 00:33:27,519
so

886
00:33:28,240 --> 00:33:30,320
the crazy thing it was for me like

887
00:33:30,320 --> 00:33:32,399
achievement unlocked a big one because

888
00:33:32,399 --> 00:33:34,880
for the first time the guy responsible

889
00:33:34,880 --> 00:33:37,679
for the windows ui kernel

890
00:33:37,679 --> 00:33:40,159
got over with me on teams

891
00:33:40,159 --> 00:33:41,279
and

892
00:33:41,279 --> 00:33:43,519
and then he just shared his screen and

893
00:33:43,519 --> 00:33:45,519
started to show me the patch for the

894
00:33:45,519 --> 00:33:48,159
code and i was doing a code review and

895
00:33:48,159 --> 00:33:50,080
actually

896
00:33:50,080 --> 00:33:52,559
i found the bug there something that

897
00:33:52,559 --> 00:33:54,880
they weren't sure no it's really like

898
00:33:54,880 --> 00:33:57,440
complicated stuff i'm really trying to

899
00:33:57,440 --> 00:34:00,480
narrow it down but it's in practice it's

900
00:34:00,480 --> 00:34:02,559
really crazy and this is something you

901
00:34:02,559 --> 00:34:04,960
send me in a personal email like talking

902
00:34:04,960 --> 00:34:07,919
with another friend he said yeah like

903
00:34:07,919 --> 00:34:10,079
we had nine people in the team working

904
00:34:10,079 --> 00:34:12,879
together on the same kind of design flow

905
00:34:12,879 --> 00:34:15,119
bugs so you can imagine it was like

906
00:34:15,119 --> 00:34:17,199
pretty big

907
00:34:17,199 --> 00:34:19,599
and i think you know as one reverse

908
00:34:19,599 --> 00:34:22,239
engineers to to you i think the most

909
00:34:22,239 --> 00:34:24,000
interesting thing about the research is

910
00:34:24,000 --> 00:34:27,119
not okay we exploited it okay it's cool

911
00:34:27,119 --> 00:34:29,359
yeah we all do that but the biggest

912
00:34:29,359 --> 00:34:32,000
question is like how i started the

913
00:34:32,000 --> 00:34:34,879
journey of coming up with this madness

914
00:34:34,879 --> 00:34:36,000
okay

915
00:34:36,000 --> 00:34:37,040
and

916
00:34:37,040 --> 00:34:39,839
one day uh i sat down i said okay i want

917
00:34:39,839 --> 00:34:41,918
to find only one bug only one bug to see

918
00:34:41,918 --> 00:34:43,918
i'm still you know in shape and finding

919
00:34:43,918 --> 00:34:46,879
bugs and then i found this but you can

920
00:34:46,879 --> 00:34:49,599
see the last line the thread unlock

921
00:34:49,599 --> 00:34:51,599
i looked at the code and i saw there is

922
00:34:51,599 --> 00:34:53,839
some pointer here being used

923
00:34:53,839 --> 00:34:55,280
and

924
00:34:55,280 --> 00:34:57,280
i saw something is weird like this p

925
00:34:57,280 --> 00:34:59,599
desk info you can see the pointer being

926
00:34:59,599 --> 00:35:02,880
used in the while nobody is locking it

927
00:35:02,880 --> 00:35:04,640
and i said like okay if nobody is

928
00:35:04,640 --> 00:35:06,960
locking it and then we have somebody

929
00:35:06,960 --> 00:35:09,359
calling me back to user mode maybe i can

930
00:35:09,359 --> 00:35:11,119
do something about it

931
00:35:11,119 --> 00:35:12,000
okay

932
00:35:12,000 --> 00:35:14,320
so this was the first line it took me

933
00:35:14,320 --> 00:35:18,400
two days i'm like staring at the screen

934
00:35:18,400 --> 00:35:20,240
like i know it's wrong i know it's wrong

935
00:35:20,240 --> 00:35:21,920
i don't know how to do it and then after

936
00:35:21,920 --> 00:35:24,320
two days i'm like okay i haven't i have

937
00:35:24,320 --> 00:35:26,960
an idea and now you know what the idea

938
00:35:26,960 --> 00:35:29,599
was and how crazy it was so that was the

939
00:35:29,599 --> 00:35:31,359
first exploit of

940
00:35:31,359 --> 00:35:34,480
uh proving that from trade unlock i

941
00:35:34,480 --> 00:35:35,839
managed to

942
00:35:35,839 --> 00:35:38,160
free the pdesk info and that was used

943
00:35:38,160 --> 00:35:40,160
after free the next iteration

944
00:35:40,160 --> 00:35:41,920
and the crazy stuff

945
00:35:41,920 --> 00:35:44,560
was that at this time i looked at the

946
00:35:44,560 --> 00:35:46,079
code and i said

947
00:35:46,079 --> 00:35:49,520
okay you just want to exploit like crazy

948
00:35:49,520 --> 00:35:52,240
crazy exploit but just one of it

949
00:35:52,240 --> 00:35:54,960
and it didn't sink on me at that time

950
00:35:54,960 --> 00:35:57,440
that there is the old design flow yet so

951
00:35:57,440 --> 00:35:59,920
that was over time i started to realize

952
00:35:59,920 --> 00:36:02,160
to generalize what happened here and to

953
00:36:02,160 --> 00:36:04,960
say yeah maybe i can make it a pattern

954
00:36:04,960 --> 00:36:06,720
and then i came with the smashable

955
00:36:06,720 --> 00:36:09,040
recipe and suddenly i found like

956
00:36:09,040 --> 00:36:11,040
thousands of it so

957
00:36:11,040 --> 00:36:13,440
these are the number of pocs that i

958
00:36:13,440 --> 00:36:14,800
actually send them

959
00:36:14,800 --> 00:36:17,839
for uh everything now each one of them

960
00:36:17,839 --> 00:36:20,400
each one of these pocs in reality i

961
00:36:20,400 --> 00:36:23,200
didn't even start to tell you how hard

962
00:36:23,200 --> 00:36:25,760
it was to change the object and to make

963
00:36:25,760 --> 00:36:27,520
sure that the last reference is the one

964
00:36:27,520 --> 00:36:29,520
that i can change stuff with it and take

965
00:36:29,520 --> 00:36:32,400
down everything and that was really so

966
00:36:32,400 --> 00:36:34,400
hard and each of them took like a week

967
00:36:34,400 --> 00:36:35,920
to to work on

968
00:36:35,920 --> 00:36:37,920
so in total i worked on the thing for

969
00:36:37,920 --> 00:36:40,400
like six months

970
00:36:40,400 --> 00:36:42,480
and that's what i came up with

971
00:36:42,480 --> 00:36:44,720
so i got like 11 cvs or something like

972
00:36:44,720 --> 00:36:47,200
that and then if it's not enough

973
00:36:47,200 --> 00:36:50,320
this was like more places more instances

974
00:36:50,320 --> 00:36:52,960
of the same recipe that i i manually

975
00:36:52,960 --> 00:36:55,200
found because i was lazy to use like

976
00:36:55,200 --> 00:36:57,200
code qr or something like that after all

977
00:36:57,200 --> 00:36:59,200
i do it for fun so it's cool

978
00:36:59,200 --> 00:37:01,920
but then all these places were like okay

979
00:37:01,920 --> 00:37:04,000
i can exploit it i'm too tired it looks

980
00:37:04,000 --> 00:37:06,480
good it looks like i can manipulate all

981
00:37:06,480 --> 00:37:09,359
the chaining together it's gonna be fine

982
00:37:09,359 --> 00:37:10,320
and

983
00:37:10,320 --> 00:37:12,079
maybe the biggest thing

984
00:37:12,079 --> 00:37:15,359
is the number or you know the the size

985
00:37:15,359 --> 00:37:17,119
of the bounty that i got

986
00:37:17,119 --> 00:37:18,960
so i really want to thank thomas

987
00:37:18,960 --> 00:37:20,960
schwartz and sal ammar for being the

988
00:37:20,960 --> 00:37:23,599
other side the friendly side of mslc

989
00:37:23,599 --> 00:37:26,160
israel to help me achieving this

990
00:37:26,160 --> 00:37:28,240
and

991
00:37:28,240 --> 00:37:32,680
yeah thank you very much everybody

992
00:37:38,500 --> 00:37:41,650
[Music]

