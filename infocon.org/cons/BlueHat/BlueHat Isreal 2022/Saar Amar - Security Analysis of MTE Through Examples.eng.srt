1
00:00:00,930 --> 00:00:08,260
[Music]

2
00:00:14,380 --> 00:00:22,410
[Music]

3
00:00:22,560 --> 00:00:25,279
seriously every time it looks bigger it

4
00:00:25,279 --> 00:00:26,880
just looks bigger

5
00:00:26,880 --> 00:00:28,320
hi hi

6
00:00:28,320 --> 00:00:30,080
everybody and thank you so much for

7
00:00:30,080 --> 00:00:31,920
attending this session my name is sarah

8
00:00:31,920 --> 00:00:33,520
mark i'm a security researcher at the

9
00:00:33,520 --> 00:00:36,000
msrc my whole life is about reversing

10
00:00:36,000 --> 00:00:38,000
and exploiting vulnerabilities i'm also

11
00:00:38,000 --> 00:00:39,680
highly addicted to ctfs i play with

12
00:00:39,680 --> 00:00:41,680
boston which i hope that you heard of us

13
00:00:41,680 --> 00:00:44,079
by now and here well we have so much

14
00:00:44,079 --> 00:00:45,840
content to cover today so let's just get

15
00:00:45,840 --> 00:00:47,760
right into it as you all know we have

16
00:00:47,760 --> 00:00:50,000
this huge memory safety problem we've

17
00:00:50,000 --> 00:00:52,480
built our entire ecosystem upon unsafe

18
00:00:52,480 --> 00:00:54,399
memory languages such as c and c plus

19
00:00:54,399 --> 00:00:56,320
plus and this of course introduces many

20
00:00:56,320 --> 00:00:58,239
memory safety vulnerabilities and the

21
00:00:58,239 --> 00:01:00,000
problem is that you cannot just throw

22
00:01:00,000 --> 00:01:01,520
away all of this legacy code because

23
00:01:01,520 --> 00:01:03,600
it's just too expensive it's unrealistic

24
00:01:03,600 --> 00:01:06,320
and this is why you have mitigations

25
00:01:06,320 --> 00:01:08,320
and in the past two decades we've seen a

26
00:01:08,320 --> 00:01:09,760
lot of software mitigations which is

27
00:01:09,760 --> 00:01:12,400
really nice but in the past two few

28
00:01:12,400 --> 00:01:14,799
years actually we've seen a lot of hard

29
00:01:14,799 --> 00:01:17,360
assisted mitigations which is fantastic

30
00:01:17,360 --> 00:01:18,720
the reason that mitigations at the

31
00:01:18,720 --> 00:01:20,960
silicon level are so powerful is because

32
00:01:20,960 --> 00:01:22,720
well first of all we get much better

33
00:01:22,720 --> 00:01:24,400
performance because the new piece of

34
00:01:24,400 --> 00:01:26,080
logic is actually implemented at the

35
00:01:26,080 --> 00:01:28,560
silicon level and it's not just another

36
00:01:28,560 --> 00:01:30,720
layer of software and because it's not

37
00:01:30,720 --> 00:01:32,720
just another layer of software we have

38
00:01:32,720 --> 00:01:34,479
much more power and much more abilities

39
00:01:34,479 --> 00:01:36,159
than we had before

40
00:01:36,159 --> 00:01:37,600
here is a short list of some great

41
00:01:37,600 --> 00:01:38,960
examples for hardware resistant

42
00:01:38,960 --> 00:01:41,360
mitigations we have no time today at all

43
00:01:41,360 --> 00:01:43,759
so let's just get right into mte so

44
00:01:43,759 --> 00:01:46,079
memory tagging extension

45
00:01:46,079 --> 00:01:48,320
as you all know

46
00:01:48,320 --> 00:01:51,119
sorry um so

47
00:01:51,119 --> 00:01:53,600
so empty adds a new type of memory to

48
00:01:53,600 --> 00:01:56,159
the arm architecture it's supported only

49
00:01:56,159 --> 00:01:58,560
on like 64 bits of course

50
00:01:58,560 --> 00:02:00,880
and basically this whole new thing of mp

51
00:02:00,880 --> 00:02:03,360
comes down to the following each 10 hex

52
00:02:03,360 --> 00:02:04,880
a line of physical memory line is

53
00:02:04,880 --> 00:02:08,479
assigned with a tag this tag is just a

54
00:02:08,479 --> 00:02:11,360
numerical value 4 bit size so we have 16

55
00:02:11,360 --> 00:02:13,280
different possibilities for tags and the

56
00:02:13,280 --> 00:02:14,959
way that it works is that each pointer

57
00:02:14,959 --> 00:02:16,480
that responds to a virtual address that

58
00:02:16,480 --> 00:02:18,640
maps a physical address from this new

59
00:02:18,640 --> 00:02:21,120
type of a memory has to be a tagged

60
00:02:21,120 --> 00:02:22,879
pointer which means that we encode some

61
00:02:22,879 --> 00:02:24,480
bits

62
00:02:24,480 --> 00:02:26,560
some information in the unused bits of

63
00:02:26,560 --> 00:02:28,800
the pointer and in this case we just set

64
00:02:28,800 --> 00:02:30,720
the tag in the most significant byte in

65
00:02:30,720 --> 00:02:32,720
the msb and now every time that you

66
00:02:32,720 --> 00:02:34,400
dereference some address every time that

67
00:02:34,400 --> 00:02:36,720
you do load or store the architecture

68
00:02:36,720 --> 00:02:38,560
itself the cpu will compare both of

69
00:02:38,560 --> 00:02:40,640
these tags the physical tag from the

70
00:02:40,640 --> 00:02:42,720
underlying physical memory and the logic

71
00:02:42,720 --> 00:02:45,040
tag from the msb part of your pointer

72
00:02:45,040 --> 00:02:47,440
and if these two pointers are different

73
00:02:47,440 --> 00:02:49,840
an exception will be raised by the cpu

74
00:02:49,840 --> 00:02:51,200
and here you can see a very simple

75
00:02:51,200 --> 00:02:53,040
illustration of that so on the right

76
00:02:53,040 --> 00:02:54,959
hand side you have your physical memory

77
00:02:54,959 --> 00:02:57,440
with this unaddressable tags these tags

78
00:02:57,440 --> 00:02:59,760
could be only modified via a specific

79
00:02:59,760 --> 00:03:02,159
set of new instructions and you cannot

80
00:03:02,159 --> 00:03:04,400
reach to this memory area via the page

81
00:03:04,400 --> 00:03:06,560
tables and etcetera and on the right

82
00:03:06,560 --> 00:03:07,760
hand side you have your virtual

83
00:03:07,760 --> 00:03:09,680
addresses which just are tagged pointers

84
00:03:09,680 --> 00:03:12,080
with these tags at msb's and if these

85
00:03:12,080 --> 00:03:14,159
two tags are different an exception will

86
00:03:14,159 --> 00:03:16,319
be raised okay so this is really cool

87
00:03:16,319 --> 00:03:18,879
but clearly you cannot just dereference

88
00:03:18,879 --> 00:03:20,640
these stacked pointers right they are

89
00:03:20,640 --> 00:03:21,920
not canonical addresses you will

90
00:03:21,920 --> 00:03:25,120
segfault these tags the msbs will mess

91
00:03:25,120 --> 00:03:28,400
up the other address translation process

92
00:03:28,400 --> 00:03:30,239
and it's unacceptable to expect people

93
00:03:30,239 --> 00:03:31,920
to do all of these wise operations

94
00:03:31,920 --> 00:03:34,560
before every single load and so and this

95
00:03:34,560 --> 00:03:36,239
is why we have a great

96
00:03:36,239 --> 00:03:38,959
c like cpu feature from arm called tbi

97
00:03:38,959 --> 00:03:40,720
or talk by tigno

98
00:03:40,720 --> 00:03:43,680
this feature does exactly what its name

99
00:03:43,680 --> 00:03:45,519
suggests when you enable this feature

100
00:03:45,519 --> 00:03:47,360
the cpu just ignores the most

101
00:03:47,360 --> 00:03:49,760
significant bytes in every pointer

102
00:03:49,760 --> 00:03:51,680
and and this is exactly what we need

103
00:03:51,680 --> 00:03:53,280
because it means that the tags won't be

104
00:03:53,280 --> 00:03:54,959
into account into the address

105
00:03:54,959 --> 00:03:56,560
translation process this is from the

106
00:03:56,560 --> 00:03:58,480
spec of arm i highly encourage you to

107
00:03:58,480 --> 00:04:00,959
check it out if you haven't already okay

108
00:04:00,959 --> 00:04:03,200
so far it's very simple

109
00:04:03,200 --> 00:04:04,959
our proposes two modes for empty you

110
00:04:04,959 --> 00:04:06,239
have synchronous mode and you have

111
00:04:06,239 --> 00:04:08,319
asynchronous mode each mode clearly has

112
00:04:08,319 --> 00:04:11,120
its own pros and cons and just before we

113
00:04:11,120 --> 00:04:13,120
are gonna go into detail i just want to

114
00:04:13,120 --> 00:04:14,959
mention here that you have full control

115
00:04:14,959 --> 00:04:17,120
over the configuration of this per

116
00:04:17,120 --> 00:04:18,639
process so you can have one process

117
00:04:18,639 --> 00:04:20,160
within honest mode and another process

118
00:04:20,160 --> 00:04:21,759
with asynchronous mode and everything

119
00:04:21,759 --> 00:04:24,880
works so what is synchronous mode

120
00:04:24,880 --> 00:04:26,320
with this mode you have this guarantee

121
00:04:26,320 --> 00:04:28,240
from the architecture that when some

122
00:04:28,240 --> 00:04:30,880
instruction violates memory tagging

123
00:04:30,880 --> 00:04:32,160
the cpu

124
00:04:32,160 --> 00:04:34,160
raise a synchronous exception on this

125
00:04:34,160 --> 00:04:37,040
very specific instruction this means

126
00:04:37,040 --> 00:04:38,479
that you have this guarantee from the

127
00:04:38,479 --> 00:04:40,639
architecture from the cpu that this

128
00:04:40,639 --> 00:04:42,880
instruction cannot retire it means that

129
00:04:42,880 --> 00:04:45,120
no further damage could happen

130
00:04:45,120 --> 00:04:46,880
and it also means that we have accurate

131
00:04:46,880 --> 00:04:49,199
information on the crash we know exactly

132
00:04:49,199 --> 00:04:50,960
which instruction faulted we know

133
00:04:50,960 --> 00:04:53,120
exactly what is that of the registers

134
00:04:53,120 --> 00:04:54,320
and the call stack and basically

135
00:04:54,320 --> 00:04:56,160
everything and while there are many

136
00:04:56,160 --> 00:04:59,120
upsides here the one major downside is

137
00:04:59,120 --> 00:05:02,240
that this mod is probably less performed

138
00:05:02,240 --> 00:05:04,240
because load and stores cannot retire

139
00:05:04,240 --> 00:05:06,400
until the tags have been read for memory

140
00:05:06,400 --> 00:05:07,520
and checked

141
00:05:07,520 --> 00:05:09,680
okay we also have asynchronous mode with

142
00:05:09,680 --> 00:05:12,240
this mode we have no exceptions here the

143
00:05:12,240 --> 00:05:14,639
cpu just sets up some bits in a system

144
00:05:14,639 --> 00:05:16,479
register when it detects a memory tag in

145
00:05:16,479 --> 00:05:18,479
violation and it's the job of the

146
00:05:18,479 --> 00:05:20,639
operating system it's up for you in your

147
00:05:20,639 --> 00:05:23,520
code to periodically scan this register

148
00:05:23,520 --> 00:05:26,240
and looks for a synchronous issues

149
00:05:26,240 --> 00:05:28,800
clearly in this mode the defaulted

150
00:05:28,800 --> 00:05:30,560
instruction could retire which means

151
00:05:30,560 --> 00:05:32,639
that factor damage could happen this is

152
00:05:32,639 --> 00:05:34,560
really bad news from like mitigation

153
00:05:34,560 --> 00:05:36,160
development point of view because you

154
00:05:36,160 --> 00:05:38,479
clearly have this window to waste

155
00:05:38,479 --> 00:05:40,960
and also you have no inaccurate

156
00:05:40,960 --> 00:05:42,560
information on the crash

157
00:05:42,560 --> 00:05:44,639
whatsoever so it's really funny

158
00:05:44,639 --> 00:05:46,639
you know that some trade or some process

159
00:05:46,639 --> 00:05:48,720
has crashed at some point in time but

160
00:05:48,720 --> 00:05:51,440
you have no idea where why how what's

161
00:05:51,440 --> 00:05:52,560
going on here

162
00:05:52,560 --> 00:05:54,479
um and while there are many many

163
00:05:54,479 --> 00:05:57,680
downsides here there is one major upside

164
00:05:57,680 --> 00:06:00,319
that this mod should be much better

165
00:06:00,319 --> 00:06:02,800
performance now i also want to be fair

166
00:06:02,800 --> 00:06:04,639
and to mention that you can create some

167
00:06:04,639 --> 00:06:06,240
really interesting properties out of

168
00:06:06,240 --> 00:06:08,639
this mode right it will just modify your

169
00:06:08,639 --> 00:06:10,479
trade context switch mechanism and

170
00:06:10,479 --> 00:06:12,720
you'll make sure to loop up for this bit

171
00:06:12,720 --> 00:06:14,479
you could create this really nice

172
00:06:14,479 --> 00:06:16,960
property that memory target violations

173
00:06:16,960 --> 00:06:19,280
will be detected until the next context

174
00:06:19,280 --> 00:06:22,000
switch which is a fair property to have

175
00:06:22,000 --> 00:06:23,600
and now that you are all super high

176
00:06:23,600 --> 00:06:25,199
experts about memory targeting we can

177
00:06:25,199 --> 00:06:27,039
see some code so

178
00:06:27,039 --> 00:06:29,919
mt has some new op codes some new like

179
00:06:29,919 --> 00:06:31,600
instructions of course here you can see

180
00:06:31,600 --> 00:06:35,600
irg and stg irg gets a pointer generates

181
00:06:35,600 --> 00:06:37,840
a new random tag and sets this new

182
00:06:37,840 --> 00:06:39,600
random target the msb part of your

183
00:06:39,600 --> 00:06:42,240
pointer this handles the logic tags

184
00:06:42,240 --> 00:06:45,600
sdg takes a target pointer and sets the

185
00:06:45,600 --> 00:06:48,560
the msb value in sponsor is the physical

186
00:06:48,560 --> 00:06:50,560
tag in the underlying physical memory

187
00:06:50,560 --> 00:06:52,720
this handles the physical tags and now

188
00:06:52,720 --> 00:06:54,000
we can write some code so the first

189
00:06:54,000 --> 00:06:55,759
thing that i'm doing here is just check

190
00:06:55,759 --> 00:06:57,680
that the underlying cpu has support for

191
00:06:57,680 --> 00:07:00,479
mt if not we just get out now i call

192
00:07:00,479 --> 00:07:02,080
peon control because i want to configure

193
00:07:02,080 --> 00:07:04,639
my process to support tbi mte and some

194
00:07:04,639 --> 00:07:07,360
past 10 stuff and you can just see this

195
00:07:07,360 --> 00:07:08,880
like send flag which means that we have

196
00:07:08,880 --> 00:07:10,720
synchronous mode okay we have seen

197
00:07:10,720 --> 00:07:12,560
chronos exceptions

198
00:07:12,560 --> 00:07:14,160
and now i call m up because i want to

199
00:07:14,160 --> 00:07:16,000
map one page that is both read broad

200
00:07:16,000 --> 00:07:18,800
right and port mte this flag just tells

201
00:07:18,800 --> 00:07:20,560
the memory management hey please make

202
00:07:20,560 --> 00:07:22,400
sure that this page will be supported

203
00:07:22,400 --> 00:07:24,240
with mp

204
00:07:24,240 --> 00:07:26,240
and now we got a pointer to a new page

205
00:07:26,240 --> 00:07:27,919
and we can write two bytes and read two

206
00:07:27,919 --> 00:07:29,759
bytes and like everything works the tag

207
00:07:29,759 --> 00:07:31,280
is now zero because all the tags by

208
00:07:31,280 --> 00:07:33,520
default are zeros and now i want to set

209
00:07:33,520 --> 00:07:37,039
one tag one single tag so we execute irg

210
00:07:37,039 --> 00:07:39,199
and then sdg and now i print out the

211
00:07:39,199 --> 00:07:40,800
pointer so you will see that it is like

212
00:07:40,800 --> 00:07:42,639
a target pointer and i write the

213
00:07:42,639 --> 00:07:44,400
character c and i read two bytes and

214
00:07:44,400 --> 00:07:46,479
again everything works

215
00:07:46,479 --> 00:07:47,759
okay great

216
00:07:47,759 --> 00:07:49,360
and now i want to intentionally trigger

217
00:07:49,360 --> 00:07:50,960
a sec fold i want to drag it receivable

218
00:07:50,960 --> 00:07:52,319
to show you that everything works just

219
00:07:52,319 --> 00:07:53,840
as we expect so let's write the

220
00:07:53,840 --> 00:07:57,440
character d44 into offset 16. this is

221
00:07:57,440 --> 00:07:59,440
guaranteed to circle because we only set

222
00:07:59,440 --> 00:08:02,240
one tag and each tag is for 16 bytes of

223
00:08:02,240 --> 00:08:04,879
aligned physical memory and because we

224
00:08:04,879 --> 00:08:06,879
did not set the tag the physical target

225
00:08:06,879 --> 00:08:09,039
is offset it will still be zero but the

226
00:08:09,039 --> 00:08:12,879
msb part of ptr over here is still some

227
00:08:12,879 --> 00:08:14,639
like random tag right so this will

228
00:08:14,639 --> 00:08:17,120
helpful and if you try to execute code

229
00:08:17,120 --> 00:08:20,319
this is uh on my ubuntu over the m1 so

230
00:08:20,319 --> 00:08:22,400
if you just try to execute it natively

231
00:08:22,400 --> 00:08:23,840
you'll see that mt is not supported

232
00:08:23,840 --> 00:08:26,560
because the m1 does not support mte but

233
00:08:26,560 --> 00:08:28,960
qmu has all the support for mt with the

234
00:08:28,960 --> 00:08:30,400
emulation of the feature and all of the

235
00:08:30,400 --> 00:08:31,840
support in the memory management and

236
00:08:31,840 --> 00:08:33,760
stuff so we just can use that this is

237
00:08:33,760 --> 00:08:35,839
what we do in this stock and as you can

238
00:08:35,839 --> 00:08:38,320
see it works just as we expected ptr got

239
00:08:38,320 --> 00:08:40,958
the drug of one by random okay but it's

240
00:08:40,958 --> 00:08:42,719
not enough i need to show you with the

241
00:08:42,719 --> 00:08:45,440
gdp that this sec fault is indeed on the

242
00:08:45,440 --> 00:08:47,600
store by instruction so let's execute it

243
00:08:47,600 --> 00:08:48,959
again

244
00:08:48,959 --> 00:08:51,120
this time with a like debugger attached

245
00:08:51,120 --> 00:08:53,440
by the way note that ptr got the tag of

246
00:08:53,440 --> 00:08:55,360
seven which is great because it was one

247
00:08:55,360 --> 00:08:56,800
before and we do expect to have some

248
00:08:56,800 --> 00:08:59,200
source of randomness like with the tag

249
00:08:59,200 --> 00:09:01,680
and let's just attach like a gdp and you

250
00:09:01,680 --> 00:09:03,200
can see that the segment is on the store

251
00:09:03,200 --> 00:09:05,120
bytes instruction when you try to write

252
00:09:05,120 --> 00:09:07,440
to offset 16

253
00:09:07,440 --> 00:09:09,519
x9 is 44 the

254
00:09:09,519 --> 00:09:11,360
the character d and i just down here the

255
00:09:11,360 --> 00:09:13,120
memory so you'll see the tbi works just

256
00:09:13,120 --> 00:09:14,800
as we expect

257
00:09:14,800 --> 00:09:17,600
okay applications mt is clearly a great

258
00:09:17,600 --> 00:09:20,560
tool for testing and it's actually a

259
00:09:20,560 --> 00:09:22,160
very good alternative to asan because it

260
00:09:22,160 --> 00:09:24,800
hits it has much smaller code size which

261
00:09:24,800 --> 00:09:27,839
is great and mt is fantastic for finding

262
00:09:27,839 --> 00:09:30,000
bugs in production this is actually what

263
00:09:30,000 --> 00:09:32,560
mt was built for right because empty

264
00:09:32,560 --> 00:09:34,320
should has much better performance than

265
00:09:34,320 --> 00:09:36,320
all of the software equivalents you

266
00:09:36,320 --> 00:09:38,480
could hopefully enable mt in your

267
00:09:38,480 --> 00:09:40,720
production environment and now you are

268
00:09:40,720 --> 00:09:42,720
much more likely to trigger some bugs

269
00:09:42,720 --> 00:09:44,399
that are much less likely to be

270
00:09:44,399 --> 00:09:47,040
triggered in your testing environments

271
00:09:47,040 --> 00:09:48,959
and even though mt was not designed for

272
00:09:48,959 --> 00:09:51,120
like memory safety mitigation we still

273
00:09:51,120 --> 00:09:53,120
see some potential some interesting

274
00:09:53,120 --> 00:09:55,600
properties that we want to get from

275
00:09:55,600 --> 00:09:58,480
from empty for memory safety mitigation

276
00:09:58,480 --> 00:10:00,560
and it's very important to be fair and

277
00:10:00,560 --> 00:10:02,640
honest and realize that because mt was

278
00:10:02,640 --> 00:10:05,040
not designed for such purposes it won't

279
00:10:05,040 --> 00:10:07,120
be a perfect candidate which is good

280
00:10:07,120 --> 00:10:08,959
because otherwise i have no reason to be

281
00:10:08,959 --> 00:10:11,279
here um and

282
00:10:11,279 --> 00:10:12,640
this is something that i really want you

283
00:10:12,640 --> 00:10:15,519
to just keep in mind mt has one hardware

284
00:10:15,519 --> 00:10:18,160
binary compatibility with that existing

285
00:10:18,160 --> 00:10:19,040
code

286
00:10:19,040 --> 00:10:22,160
almost 100 so it means that it won't be

287
00:10:22,160 --> 00:10:25,120
perfect for memory receptive mitigation

288
00:10:25,120 --> 00:10:27,279
okay now if we want to talk about like

289
00:10:27,279 --> 00:10:28,880
memory safety we need to talk about heap

290
00:10:28,880 --> 00:10:30,959
safety so clearly i need to implement

291
00:10:30,959 --> 00:10:32,240
all of the support in the memory

292
00:10:32,240 --> 00:10:34,160
management i need all of all of the

293
00:10:34,160 --> 00:10:35,920
allocators because the allocators are

294
00:10:35,920 --> 00:10:37,760
the ones that generate new allocation

295
00:10:37,760 --> 00:10:39,600
and we need a location api to actually

296
00:10:39,600 --> 00:10:41,839
re-tag all of the memory lines in your

297
00:10:41,839 --> 00:10:44,000
location right and you clearly need to

298
00:10:44,000 --> 00:10:46,000
get a tag pointer back now this is

299
00:10:46,000 --> 00:10:48,240
optional on frame you could actually

300
00:10:48,240 --> 00:10:50,000
retarget locations on free this will

301
00:10:50,000 --> 00:10:52,000
help you to catch some use after freeze

302
00:10:52,000 --> 00:10:54,240
even before reallocation which is really

303
00:10:54,240 --> 00:10:55,680
really nice

304
00:10:55,680 --> 00:10:57,839
now this is critical with deal malloc

305
00:10:57,839 --> 00:11:00,480
and with some other allocators that has

306
00:11:00,480 --> 00:11:02,240
some pointers inside of like three

307
00:11:02,240 --> 00:11:05,040
charts but if you allocate or don't have

308
00:11:05,040 --> 00:11:06,959
pointers or secrets inside like three

309
00:11:06,959 --> 00:11:08,720
chunks you could give it up and you'll

310
00:11:08,720 --> 00:11:10,480
get all of the performance back because

311
00:11:10,480 --> 00:11:13,040
re-tagging the locations is expensive

312
00:11:13,040 --> 00:11:14,480
and this is

313
00:11:14,480 --> 00:11:16,640
of course up to you or up to the window

314
00:11:16,640 --> 00:11:18,399
the tldr is that we get probabilistic

315
00:11:18,399 --> 00:11:20,079
mitigations for most of the memory

316
00:11:20,079 --> 00:11:21,519
safety bar classes and i want to show

317
00:11:21,519 --> 00:11:23,600
some examples so if you just try to

318
00:11:23,600 --> 00:11:25,279
allocate some chunk on the hip and read

319
00:11:25,279 --> 00:11:27,200
or write out of bound you are very

320
00:11:27,200 --> 00:11:28,800
likely to thankful actually with the

321
00:11:28,800 --> 00:11:32,079
probability of 15 out of 16 you will

322
00:11:32,079 --> 00:11:34,000
crash because the tag out of bound is

323
00:11:34,000 --> 00:11:36,959
very likely to be different

324
00:11:36,959 --> 00:11:38,640
same goes for yours after if you do

325
00:11:38,640 --> 00:11:40,880
retarget locations during free you are

326
00:11:40,880 --> 00:11:42,560
very lucky to crash because if you do

327
00:11:42,560 --> 00:11:44,079
malloc free and then try to read the

328
00:11:44,079 --> 00:11:45,839
right through your dangling pointer the

329
00:11:45,839 --> 00:11:48,720
tag is very likely to be different okay

330
00:11:48,720 --> 00:11:50,480
now it's true mt mostly gives us

331
00:11:50,480 --> 00:11:52,720
probabilistic mitigation but we still

332
00:11:52,720 --> 00:11:54,000
believe that we can get one

333
00:11:54,000 --> 00:11:55,920
deterministic mitigation very specific

334
00:11:55,920 --> 00:11:58,079
one out of empty and this is for very

335
00:11:58,079 --> 00:12:00,399
specific backlash this is for strictly

336
00:12:00,399 --> 00:12:02,320
linear overflows or

337
00:12:02,320 --> 00:12:04,800
underflows and this cannot get any

338
00:12:04,800 --> 00:12:08,079
simpler we just go to the allocation api

339
00:12:08,079 --> 00:12:09,920
and we modify it such that it will

340
00:12:09,920 --> 00:12:11,519
assign random tags for all of the

341
00:12:11,519 --> 00:12:14,480
allocations that it generates with one

342
00:12:14,480 --> 00:12:16,399
minor restriction that adjacent

343
00:12:16,399 --> 00:12:18,800
allocations always have different tags

344
00:12:18,800 --> 00:12:21,040
and this is super cool because now it

345
00:12:21,040 --> 00:12:23,200
actually breaks exploitability of all of

346
00:12:23,200 --> 00:12:25,519
the memcop style bugs right so now we

347
00:12:25,519 --> 00:12:27,519
could actually take a bunch of bugs and

348
00:12:27,519 --> 00:12:29,519
tell people that hey on this new piece

349
00:12:29,519 --> 00:12:31,680
of hardware these bugs are not

350
00:12:31,680 --> 00:12:33,600
exploitable by definition and it's not a

351
00:12:33,600 --> 00:12:35,600
question of by passing this mitigation

352
00:12:35,600 --> 00:12:38,639
because the cpu the architecture itself

353
00:12:38,639 --> 00:12:40,880
will raise an exception on the very

354
00:12:40,880 --> 00:12:43,279
first bytes that you read all right out

355
00:12:43,279 --> 00:12:45,680
of bound this is insane this is really

356
00:12:45,680 --> 00:12:49,519
powerful property to have okay so here

357
00:12:49,519 --> 00:12:51,760
it's the value of empty sdm services

358
00:12:51,760 --> 00:12:53,440
sees it you can see it's there like back

359
00:12:53,440 --> 00:12:54,800
classes that it mitigates we talked

360
00:12:54,800 --> 00:12:56,560
about probabilistic mitigations and

361
00:12:56,560 --> 00:12:58,320
about deterministic mitigation and now

362
00:12:58,320 --> 00:13:01,839
the actual fund could begin finally

363
00:13:01,839 --> 00:13:04,079
okay so every time that you build a new

364
00:13:04,079 --> 00:13:06,160
mitigation it's mandatory it's necessary

365
00:13:06,160 --> 00:13:08,639
to consider some like

366
00:13:08,639 --> 00:13:11,200
bypasses and weak spots and etc and in

367
00:13:11,200 --> 00:13:13,200
my own opinion one of the best ways in

368
00:13:13,200 --> 00:13:15,680
order to achieve such evaluations is by

369
00:13:15,680 --> 00:13:17,839
writing exploits also building experts

370
00:13:17,839 --> 00:13:19,360
is the better meaning of life so we have

371
00:13:19,360 --> 00:13:22,240
a really nice opportunity here um and i

372
00:13:22,240 --> 00:13:24,240
just want to set up some words okay so

373
00:13:24,240 --> 00:13:26,079
precise mode which means synchronous

374
00:13:26,079 --> 00:13:28,560
exception empty is always in like

375
00:13:28,560 --> 00:13:30,720
like in place uh

376
00:13:30,720 --> 00:13:32,079
clearly

377
00:13:32,079 --> 00:13:34,639
like adjacent sharks have like just like

378
00:13:34,639 --> 00:13:36,560
different tags because like why not

379
00:13:36,560 --> 00:13:38,160
calling free with an incorrect tag

380
00:13:38,160 --> 00:13:40,240
segfaults this is really reasonable

381
00:13:40,240 --> 00:13:42,160
right and i want to mention here that i

382
00:13:42,160 --> 00:13:44,160
use qmu for all of the like memory

383
00:13:44,160 --> 00:13:45,680
management supports and for all of the

384
00:13:45,680 --> 00:13:47,600
accumulation of the feature support but

385
00:13:47,600 --> 00:13:49,600
unfortunately gelipsi

386
00:13:49,600 --> 00:13:53,360
wow gelepsi um don't really have stable

387
00:13:53,360 --> 00:13:55,600
and like official support for mp so for

388
00:13:55,600 --> 00:13:57,440
these lectures i just built my own

389
00:13:57,440 --> 00:13:59,199
wrappers on top of

390
00:13:59,199 --> 00:14:01,279
on top of like ellipses with malloc

391
00:14:01,279 --> 00:14:03,680
reallock estiardo free and basically

392
00:14:03,680 --> 00:14:05,519
everything so in my own implementation i

393
00:14:05,519 --> 00:14:07,360
made sure that calling free with an

394
00:14:07,360 --> 00:14:08,800
incorrect tag segfaults i think that

395
00:14:08,800 --> 00:14:10,480
it's very important

396
00:14:10,480 --> 00:14:12,720
and clearly i only tucked the hip

397
00:14:12,720 --> 00:14:14,959
okay so let's talk about corruption of

398
00:14:14,959 --> 00:14:16,720
pointers right with mt we can corrupt

399
00:14:16,720 --> 00:14:18,079
pointers because

400
00:14:18,079 --> 00:14:20,320
the logic tags all of these msbs in all

401
00:14:20,320 --> 00:14:22,480
of the pointers are clearly readable and

402
00:14:22,480 --> 00:14:25,360
writable so if i can leak pointers i can

403
00:14:25,360 --> 00:14:27,680
sorry so if i can lick tags i can fake

404
00:14:27,680 --> 00:14:29,600
pointers right so if you want for

405
00:14:29,600 --> 00:14:31,600
instance to just corrupt some absolute

406
00:14:31,600 --> 00:14:34,079
64-bit pointers you can do that as long

407
00:14:34,079 --> 00:14:36,399
as you know the tag of your this address

408
00:14:36,399 --> 00:14:37,760
if you want to do this trick that i

409
00:14:37,760 --> 00:14:39,120
personally find

410
00:14:39,120 --> 00:14:41,680
like very very useful to corrupt the lsb

411
00:14:41,680 --> 00:14:43,120
part of your pointer just move it

412
00:14:43,120 --> 00:14:45,199
backward or fold in memory you can still

413
00:14:45,199 --> 00:14:47,600
do that as long as you make sure to to

414
00:14:47,600 --> 00:14:50,079
not move your pointer out of bound or

415
00:14:50,079 --> 00:14:51,920
that you do move it out of bound but you

416
00:14:51,920 --> 00:14:53,760
know that the tag at your out of bound

417
00:14:53,760 --> 00:14:56,880
memory area is the same intra object

418
00:14:56,880 --> 00:14:59,440
corruption this is a really nice

419
00:14:59,440 --> 00:15:01,199
backlash of bugs this is the case where

420
00:15:01,199 --> 00:15:02,800
you have a really big structure and you

421
00:15:02,800 --> 00:15:05,120
have an internal bi like buffer or array

422
00:15:05,120 --> 00:15:06,959
or container inside of it and you can

423
00:15:06,959 --> 00:15:09,360
drag it out of bound from your buffer

424
00:15:09,360 --> 00:15:11,360
now as long as you never trigger out of

425
00:15:11,360 --> 00:15:13,120
bound from the entire structure from the

426
00:15:13,120 --> 00:15:15,600
entire allocation mte has nothing to do

427
00:15:15,600 --> 00:15:17,360
about it because from the allocator

428
00:15:17,360 --> 00:15:19,199
point of view there

429
00:15:19,199 --> 00:15:20,880
you didn't actually trigger it out of

430
00:15:20,880 --> 00:15:23,199
bound right and inside the same location

431
00:15:23,199 --> 00:15:26,000
all of the tags have to be identical so

432
00:15:26,000 --> 00:15:27,760
intra object corruptions are clearly

433
00:15:27,760 --> 00:15:31,040
exploitable deterministically with mt

434
00:15:31,040 --> 00:15:33,120
now licking stuff information

435
00:15:33,120 --> 00:15:34,959
disclosures are really problematic for

436
00:15:34,959 --> 00:15:37,120
mt which means that it's great for us

437
00:15:37,120 --> 00:15:38,720
because if you can shape your hip and

438
00:15:38,720 --> 00:15:40,320
lick a lot of pointers you can know a

439
00:15:40,320 --> 00:15:42,000
lot of tags and with the knowledge of

440
00:15:42,000 --> 00:15:44,639
the tags we can fake pointers

441
00:15:44,639 --> 00:15:46,560
and generic information disclosures are

442
00:15:46,560 --> 00:15:48,000
not the only thing that i'm concerned

443
00:15:48,000 --> 00:15:49,519
about just think about all of the

444
00:15:49,519 --> 00:15:51,519
speculative execution variants that we

445
00:15:51,519 --> 00:15:52,240
see

446
00:15:52,240 --> 00:15:53,920
new stuff on the daily right just think

447
00:15:53,920 --> 00:15:56,000
about many side channels right

448
00:15:56,000 --> 00:15:58,079
everything that leak you pointed give

449
00:15:58,079 --> 00:16:00,079
you tag which is the knowledge which is

450
00:16:00,079 --> 00:16:02,160
the secrets that you need in order to

451
00:16:02,160 --> 00:16:05,040
fake pointers um and just consider this

452
00:16:05,040 --> 00:16:07,360
really classic bug in a javascript where

453
00:16:07,360 --> 00:16:09,040
you cannot control the base but you have

454
00:16:09,040 --> 00:16:10,959
full control over the index or offset

455
00:16:10,959 --> 00:16:12,720
that goes like out of bound if you can

456
00:16:12,720 --> 00:16:14,959
trigger side channels you can know tags

457
00:16:14,959 --> 00:16:16,959
and now you can choose your out of bound

458
00:16:16,959 --> 00:16:18,959
index to be to a memory area that you

459
00:16:18,959 --> 00:16:20,959
know that has the same tag as you and

460
00:16:20,959 --> 00:16:23,120
this is how some probabilistically like

461
00:16:23,120 --> 00:16:24,639
mitigated bugs could be

462
00:16:24,639 --> 00:16:27,120
deterministically exploitable and i

463
00:16:27,120 --> 00:16:29,360
think that this is really cool

464
00:16:29,360 --> 00:16:31,519
now type confusions of course empty has

465
00:16:31,519 --> 00:16:32,959
nothing to do with app confusions they

466
00:16:32,959 --> 00:16:34,240
are absolutely exploitable

467
00:16:34,240 --> 00:16:36,160
deterministically i just want to mention

468
00:16:36,160 --> 00:16:39,680
here that i'm not considering here like

469
00:16:39,680 --> 00:16:41,440
type confusion scenario that you built

470
00:16:41,440 --> 00:16:43,920
on top of like other bug if you have

471
00:16:43,920 --> 00:16:45,360
some out of bound or some use after

472
00:16:45,360 --> 00:16:47,279
frame you created some type confusion

473
00:16:47,279 --> 00:16:50,000
scenario your first order primitive will

474
00:16:50,000 --> 00:16:52,320
be probabilistically mitigated

475
00:16:52,320 --> 00:16:54,639
but if you first order primitive just a

476
00:16:54,639 --> 00:16:57,680
beautiful beautiful type confusion

477
00:16:57,680 --> 00:16:59,600
it's absolutely deterministically

478
00:16:59,600 --> 00:17:01,600
exploitable and now the actual talk

479
00:17:01,600 --> 00:17:03,839
could begin finally so let's see some

480
00:17:03,839 --> 00:17:05,839
practical examples and as i've said

481
00:17:05,839 --> 00:17:08,559
before we need support for empty right

482
00:17:08,559 --> 00:17:10,720
so qmu has all the support for the

483
00:17:10,720 --> 00:17:12,880
memory management and it works great and

484
00:17:12,880 --> 00:17:14,640
emulation of the feature of course i've

485
00:17:14,640 --> 00:17:16,240
built my own wrappers on top of

486
00:17:16,240 --> 00:17:19,039
fragilipsi for this research works great

487
00:17:19,039 --> 00:17:20,880
and now we can begin now before we start

488
00:17:20,880 --> 00:17:22,720
to write exploits i just want to show

489
00:17:22,720 --> 00:17:25,280
some examples for famous bugs cvs from

490
00:17:25,280 --> 00:17:27,439
real life that are deterministically

491
00:17:27,439 --> 00:17:29,679
exploitable with mt the first one is a

492
00:17:29,679 --> 00:17:31,200
very famous one i'm sure that you've

493
00:17:31,200 --> 00:17:32,640
seen it this is a

494
00:17:32,640 --> 00:17:34,799
horrible horrible bug in like nss found

495
00:17:34,799 --> 00:17:38,000
by tavis omandi gpz great find this is a

496
00:17:38,000 --> 00:17:39,360
great example for intra-object

497
00:17:39,360 --> 00:17:41,600
corruption you have fixed size buffer

498
00:17:41,600 --> 00:17:44,320
with full control over the content and

499
00:17:44,320 --> 00:17:46,559
length and stuff and you can actually

500
00:17:46,559 --> 00:17:48,559
trigger your like overflow inside the

501
00:17:48,559 --> 00:17:50,320
same structure

502
00:17:50,320 --> 00:17:53,120
so this bug is clearly exploitable with

503
00:17:53,120 --> 00:17:54,720
mt we don't have time to cover this in

504
00:17:54,720 --> 00:17:57,280
detail but you can visit the blog post

505
00:17:57,280 --> 00:17:59,440
by gpg it's really really good check

506
00:17:59,440 --> 00:18:00,559
this out

507
00:18:00,559 --> 00:18:03,039
the second bug is an amazing fight

508
00:18:03,039 --> 00:18:04,960
defined by sailor again

509
00:18:04,960 --> 00:18:07,200
gpz this is a beautiful bugs one of the

510
00:18:07,200 --> 00:18:09,440
most beautiful that like i've seen

511
00:18:09,440 --> 00:18:11,120
really this is a great example for

512
00:18:11,120 --> 00:18:13,039
straight four type confusion this is in

513
00:18:13,039 --> 00:18:15,280
fjst and

514
00:18:15,280 --> 00:18:16,640
i'm really sorry that we don't have time

515
00:18:16,640 --> 00:18:18,400
to cover this because it's so so

516
00:18:18,400 --> 00:18:21,200
beautiful but again check out the

517
00:18:21,200 --> 00:18:24,400
amazing like blackhead stock

518
00:18:24,400 --> 00:18:26,799
like about it the first order primitive

519
00:18:26,799 --> 00:18:29,039
is here is basically fake object other

520
00:18:29,039 --> 00:18:30,880
off which are clearly everything that

521
00:18:30,880 --> 00:18:32,720
you need in life and i actually really

522
00:18:32,720 --> 00:18:34,880
wanted to build the demo in this talk

523
00:18:34,880 --> 00:18:37,760
about this bug but unfortunately jsc

524
00:18:37,760 --> 00:18:39,919
does not have support for mt and while i

525
00:18:39,919 --> 00:18:42,080
was very happy to build this really

526
00:18:42,080 --> 00:18:44,000
simple wrappers on top of of like

527
00:18:44,000 --> 00:18:46,640
gillipsie porting jsc to support mt is

528
00:18:46,640 --> 00:18:47,840
not something that i find really

529
00:18:47,840 --> 00:18:50,480
interesting so no and but i just want to

530
00:18:50,480 --> 00:18:52,000
mention here that because we know how to

531
00:18:52,000 --> 00:18:54,000
explore this bug and we have a type

532
00:18:54,000 --> 00:18:55,440
confusion we could maintain this

533
00:18:55,440 --> 00:18:57,600
property and this is the important part

534
00:18:57,600 --> 00:18:59,280
we can maintain this property that we

535
00:18:59,280 --> 00:19:01,760
never dereference a pointer

536
00:19:01,760 --> 00:19:04,000
without being absolutely sure that the

537
00:19:04,000 --> 00:19:05,760
tags are identical and because you have

538
00:19:05,760 --> 00:19:08,000
a beautiful type confusion you can lick

539
00:19:08,000 --> 00:19:09,600
a lot of tags

540
00:19:09,600 --> 00:19:10,400
okay

541
00:19:10,400 --> 00:19:12,240
and now the really interesting part

542
00:19:12,240 --> 00:19:15,360
begins uh i want to show you some

543
00:19:15,360 --> 00:19:18,320
exploit example like end-to-end so we

544
00:19:18,320 --> 00:19:19,760
are going to exploit a pawn challenge

545
00:19:19,760 --> 00:19:22,320
for 2020 some metadata and some info

546
00:19:22,320 --> 00:19:24,240
about the challenge it used to run on

547
00:19:24,240 --> 00:19:26,240
like ubuntu

548
00:19:26,240 --> 00:19:28,960
sorry and 18.804 and therefore the

549
00:19:28,960 --> 00:19:30,960
intended solution plus the published

550
00:19:30,960 --> 00:19:32,640
solutions only targeted this version

551
00:19:32,640 --> 00:19:34,880
they just did it raw double free on t

552
00:19:34,880 --> 00:19:38,880
cash it was possible 500 years ago but

553
00:19:38,880 --> 00:19:41,200
it's not like possible anymore so

554
00:19:41,200 --> 00:19:42,720
all of this stuff will just crash for

555
00:19:42,720 --> 00:19:45,120
you deterministic about on upon 2 like

556
00:19:45,120 --> 00:19:47,200
2004

557
00:19:47,200 --> 00:19:48,640
and also the challenge lacks a lot of

558
00:19:48,640 --> 00:19:51,360
mitigation so i just took out one wicked

559
00:19:51,360 --> 00:19:53,760
i enabled all of these litigations and i

560
00:19:53,760 --> 00:19:56,240
served it for like one to 2004 and

561
00:19:56,240 --> 00:19:58,000
because the latest version of ubuntu has

562
00:19:58,000 --> 00:20:00,400
some further hardening i solved this for

563
00:20:00,400 --> 00:20:03,039
this version as well all of that is all

564
00:20:03,039 --> 00:20:04,559
is like already published in my blog

565
00:20:04,559 --> 00:20:06,080
post with all of the exploits you can

566
00:20:06,080 --> 00:20:08,320
check it out but i know i like actually

567
00:20:08,320 --> 00:20:09,520
want to cover

568
00:20:09,520 --> 00:20:12,000
the challenge exploit it without empty

569
00:20:12,000 --> 00:20:14,159
and then enablemt see what breaks and

570
00:20:14,159 --> 00:20:15,520
bypass this

571
00:20:15,520 --> 00:20:18,480
and we have 18 minutes which is great

572
00:20:18,480 --> 00:20:20,400
okay so we have a challenge that

573
00:20:20,400 --> 00:20:22,240
implements a list of elements each

574
00:20:22,240 --> 00:20:24,080
element could be long double or a

575
00:20:24,080 --> 00:20:26,080
pointer to a string

576
00:20:26,080 --> 00:20:28,720
and our data structure supports add get

577
00:20:28,720 --> 00:20:31,280
edit and delete operations okay cool and

578
00:20:31,280 --> 00:20:32,559
i just want you to keep in mind this

579
00:20:32,559 --> 00:20:34,559
structure in the middle the list one it

580
00:20:34,559 --> 00:20:35,919
has a pointer to the array of the

581
00:20:35,919 --> 00:20:38,000
keywords which are all of the elements

582
00:20:38,000 --> 00:20:40,320
it has size which is the current number

583
00:20:40,320 --> 00:20:42,240
of like elements in the array and it has

584
00:20:42,240 --> 00:20:44,480
the maximum capacity

585
00:20:44,480 --> 00:20:46,880
now a very trivial problem here is that

586
00:20:46,880 --> 00:20:48,960
when you do get an edit

587
00:20:48,960 --> 00:20:50,799
the code has no way to know which type

588
00:20:50,799 --> 00:20:52,960
of element it is interacting with and

589
00:20:52,960 --> 00:20:54,960
the ctf auto just solve this in a really

590
00:20:54,960 --> 00:20:56,000
nice way

591
00:20:56,000 --> 00:20:58,240
when you do get an edit the code asks

592
00:20:58,240 --> 00:20:59,919
for you for both the index and the type

593
00:20:59,919 --> 00:21:01,679
of the elements and this is how you have

594
00:21:01,679 --> 00:21:03,919
a really straightforward type confusion

595
00:21:03,919 --> 00:21:05,760
so the first primitive that we have is

596
00:21:05,760 --> 00:21:08,000
that we can type a hip pointer

597
00:21:08,000 --> 00:21:09,039
sorry

598
00:21:09,039 --> 00:21:11,039
as an integer and we can read it and we

599
00:21:11,039 --> 00:21:13,280
can treat an integer as a string pointer

600
00:21:13,280 --> 00:21:15,200
the reference it and read its content so

601
00:21:15,200 --> 00:21:17,679
basically have arbitrary read by design

602
00:21:17,679 --> 00:21:19,200
this is just to give you a good sense of

603
00:21:19,200 --> 00:21:21,200
it this is the get function from the

604
00:21:21,200 --> 00:21:22,720
challenge and as you can see the

605
00:21:22,720 --> 00:21:25,360
challenge asks for us for the

606
00:21:25,360 --> 00:21:26,960
index and then for the type and then we

607
00:21:26,960 --> 00:21:28,400
just do the job

608
00:21:28,400 --> 00:21:30,240
okay we also need ability to corrupt

609
00:21:30,240 --> 00:21:32,799
memory uh so there is like another

610
00:21:32,799 --> 00:21:35,440
vulnerability in the delete function and

611
00:21:35,440 --> 00:21:36,960
when you delete some elements the

612
00:21:36,960 --> 00:21:38,799
challenge needs a way to know if it's an

613
00:21:38,799 --> 00:21:40,880
integer which does not require a frame

614
00:21:40,880 --> 00:21:42,880
or if it's a string pointer which does

615
00:21:42,880 --> 00:21:44,799
require a frame

616
00:21:44,799 --> 00:21:46,400
and it's true that the code could ask

617
00:21:46,400 --> 00:21:49,200
for uh like from us for the type here as

618
00:21:49,200 --> 00:21:51,760
well but it doesn't instead it maintains

619
00:21:51,760 --> 00:21:54,080
a like global array they call it full

620
00:21:54,080 --> 00:21:55,840
this array just contains all of the

621
00:21:55,840 --> 00:21:57,360
virtual addresses of all of the

622
00:21:57,360 --> 00:21:59,520
allocated strings ever so every time

623
00:21:59,520 --> 00:22:01,919
that you add a new string the address of

624
00:22:01,919 --> 00:22:04,080
the new string goes into this buffer now

625
00:22:04,080 --> 00:22:06,320
this buffer is static inside and it

626
00:22:06,320 --> 00:22:08,480
doesn't increase and also the challenge

627
00:22:08,480 --> 00:22:09,840
does not

628
00:22:09,840 --> 00:22:11,840
like remove pointers after its freedom

629
00:22:11,840 --> 00:22:14,320
and it doesn't null them out so besides

630
00:22:14,320 --> 00:22:15,679
the obvious leak that you have here and

631
00:22:15,679 --> 00:22:17,600
many many other problems

632
00:22:17,600 --> 00:22:20,480
you can just call free as many times as

633
00:22:20,480 --> 00:22:22,960
you want on the same virtual addresses

634
00:22:22,960 --> 00:22:24,559
of course as long as this virtual

635
00:22:24,559 --> 00:22:27,039
address is in the fpool array or in like

636
00:22:27,039 --> 00:22:29,120
other words as long as it's used to

637
00:22:29,120 --> 00:22:31,520
serve in a location of a string okay

638
00:22:31,520 --> 00:22:33,679
very simple and this could be converted

639
00:22:33,679 --> 00:22:35,600
into an arbitrary free by just making

640
00:22:35,600 --> 00:22:37,039
sure that the object that you want to

641
00:22:37,039 --> 00:22:39,679
arbitrary frame was used to serve

642
00:22:39,679 --> 00:22:41,679
in like a location of a string from

643
00:22:41,679 --> 00:22:43,679
before and this is the code this is from

644
00:22:43,679 --> 00:22:45,919
the list add function as you can see

645
00:22:45,919 --> 00:22:47,919
each time that you do add or finish

646
00:22:47,919 --> 00:22:50,080
training we call s2 like just like ester

647
00:22:50,080 --> 00:22:51,919
dope we add the new string to the list

648
00:22:51,919 --> 00:22:54,320
data array and to the f4 array if we

649
00:22:54,320 --> 00:22:56,240
have like enough space and when you

650
00:22:56,240 --> 00:22:58,159
delete some element you just scan the f4

651
00:22:58,159 --> 00:23:00,240
array to see if you

652
00:23:00,240 --> 00:23:02,799
like deleted keyword is inside a full

653
00:23:02,799 --> 00:23:05,039
array and if so this indicates that it

654
00:23:05,039 --> 00:23:07,120
needs to be freed

655
00:23:07,120 --> 00:23:08,960
okay so we know that we works with

656
00:23:08,960 --> 00:23:10,799
string so we can't have nulls like in

657
00:23:10,799 --> 00:23:12,480
the middle there is no coalesce and no

658
00:23:12,480 --> 00:23:14,240
consolidates

659
00:23:14,240 --> 00:23:15,840
in the t cache and now we could start to

660
00:23:15,840 --> 00:23:18,080
exploit it and as i've said many many

661
00:23:18,080 --> 00:23:19,679
times before the meaning in life is

662
00:23:19,679 --> 00:23:21,520
together with reading right so let's

663
00:23:21,520 --> 00:23:25,120
start by our grid and this is possible

664
00:23:25,120 --> 00:23:26,720
by design you just take the address that

665
00:23:26,720 --> 00:23:29,120
you want to arbitrary read you add it as

666
00:23:29,120 --> 00:23:30,960
a type log

667
00:23:30,960 --> 00:23:32,960
you call get we type string you have

668
00:23:32,960 --> 00:23:35,120
arbitrary read the reason that i call

669
00:23:35,120 --> 00:23:36,400
delete here is just to make sure that

670
00:23:36,400 --> 00:23:39,440
this cute python function wants effect

671
00:23:39,440 --> 00:23:42,000
on the internal states of the array

672
00:23:42,000 --> 00:23:43,039
that's it

673
00:23:43,039 --> 00:23:45,520
okay so we have an arbitrary reads and

674
00:23:45,520 --> 00:23:47,360
we can leak all of the hip addresses

675
00:23:47,360 --> 00:23:49,039
because of the type confusion so we can

676
00:23:49,039 --> 00:23:50,400
get lipsy right

677
00:23:50,400 --> 00:23:52,159
because we can just freeze some chunk

678
00:23:52,159 --> 00:23:54,159
into the unsorted bins you have a point

679
00:23:54,159 --> 00:23:56,159
of do the main arena symbol you just

680
00:23:56,159 --> 00:23:57,600
lick it and because deepsea has a

681
00:23:57,600 --> 00:23:59,120
pointer to environment i can lick the

682
00:23:59,120 --> 00:24:00,240
stack as well

683
00:24:00,240 --> 00:24:02,799
okay now we need to get some arbitrary

684
00:24:02,799 --> 00:24:05,120
rights of course and we cannot do the

685
00:24:05,120 --> 00:24:07,440
double free attack because again it was

686
00:24:07,440 --> 00:24:08,880
the mitigator

687
00:24:08,880 --> 00:24:11,039
but we can do something else we can just

688
00:24:11,039 --> 00:24:13,279
corrupt the fd pointer inside of a free

689
00:24:13,279 --> 00:24:15,120
chunk this will give us the ability to

690
00:24:15,120 --> 00:24:16,960
control over the next next return value

691
00:24:16,960 --> 00:24:18,720
of malloc this is a very common

692
00:24:18,720 --> 00:24:20,880
exploitation technique

693
00:24:20,880 --> 00:24:22,640
in enochs you can see it's basically in

694
00:24:22,640 --> 00:24:25,200
every pawn challenge in like every ctf

695
00:24:25,200 --> 00:24:26,799
and the only question here is how would

696
00:24:26,799 --> 00:24:28,640
you gain the ability to write into a

697
00:24:28,640 --> 00:24:31,039
free chunk this is very simple i just

698
00:24:31,039 --> 00:24:32,880
need to make sure that the list data the

699
00:24:32,880 --> 00:24:35,279
array of the elements reclaim a free

700
00:24:35,279 --> 00:24:37,360
string because then it's in therefore

701
00:24:37,360 --> 00:24:38,880
array and now we can call arbitrary

702
00:24:38,880 --> 00:24:40,799
three on that and i can write through

703
00:24:40,799 --> 00:24:43,679
the dangling pointer into the like fd

704
00:24:43,679 --> 00:24:45,919
value so this is the hip the first

705
00:24:45,919 --> 00:24:48,080
structure to get allocated is like the

706
00:24:48,080 --> 00:24:50,159
list and then we have the array now i

707
00:24:50,159 --> 00:24:51,919
want to add a string and i want to

708
00:24:51,919 --> 00:24:54,240
freeze and now i want the list data to

709
00:24:54,240 --> 00:24:56,159
reclaim the free stream so let's just

710
00:24:56,159 --> 00:24:57,600
add more elements

711
00:24:57,600 --> 00:25:00,640
we have reallocation and i can do

712
00:25:00,640 --> 00:25:02,720
more elements and we have another

713
00:25:02,720 --> 00:25:04,799
reallocation and now the list data is in

714
00:25:04,799 --> 00:25:08,159
the f4 array call arbitrary free and use

715
00:25:08,159 --> 00:25:09,679
edits to corrupt the fd and we have

716
00:25:09,679 --> 00:25:12,640
arbitrary rights okay and now on ubuntu

717
00:25:12,640 --> 00:25:15,279
24 you can corrupt the free hook symbol

718
00:25:15,279 --> 00:25:19,039
past 10 it's over on ubuntu 21.10 the

719
00:25:19,039 --> 00:25:21,919
like malloc hooks were mitigated

720
00:25:21,919 --> 00:25:24,559
sadly so you can just do rope

721
00:25:24,559 --> 00:25:26,640
back on the stack and it's a game over

722
00:25:26,640 --> 00:25:28,320
this is the exploit this is how it looks

723
00:25:28,320 --> 00:25:29,919
like again it's all

724
00:25:29,919 --> 00:25:32,799
published and now we can begin with mte

725
00:25:32,799 --> 00:25:33,760
so

726
00:25:33,760 --> 00:25:35,440
i want to enable empty and see what

727
00:25:35,440 --> 00:25:37,039
breaks and because i want to have a soft

728
00:25:37,039 --> 00:25:39,120
landing let's just enable empty and

729
00:25:39,120 --> 00:25:40,960
assume that we only re-tag allocations

730
00:25:40,960 --> 00:25:44,559
during malloc but not during free

731
00:25:44,559 --> 00:25:45,360
so

732
00:25:45,360 --> 00:25:46,640
and because we don't have time we

733
00:25:46,640 --> 00:25:49,120
absolutely don't have time we only do

734
00:25:49,120 --> 00:25:51,679
the exploits end to end on ubuntu 2004

735
00:25:51,679 --> 00:25:54,240
so i will corrupt the free hook function

736
00:25:54,240 --> 00:25:56,080
but the same tricks the same primitives

737
00:25:56,080 --> 00:25:58,000
the same everything could be repeated to

738
00:25:58,000 --> 00:26:01,600
do up on the stack on ubuntu 2110 so we

739
00:26:01,600 --> 00:26:03,760
have some news the good news is that all

740
00:26:03,760 --> 00:26:05,840
of the references to free chance are

741
00:26:05,840 --> 00:26:07,679
safe because we did not return locations

742
00:26:07,679 --> 00:26:10,240
on free the interesting news is that our

743
00:26:10,240 --> 00:26:12,159
arbitrary right is via malloc right we

744
00:26:12,159 --> 00:26:15,039
control the next return value of malloc

745
00:26:15,039 --> 00:26:17,279
and malloc returned the entire

746
00:26:17,279 --> 00:26:19,520
allocation entire memory that

747
00:26:19,520 --> 00:26:21,440
you get so if you target with your

748
00:26:21,440 --> 00:26:23,360
arbitrary right the stack of some or

749
00:26:23,360 --> 00:26:25,200
some globals you are fine because it's

750
00:26:25,200 --> 00:26:27,120
not attacked memory but if you tuck the

751
00:26:27,120 --> 00:26:29,279
hip you actually returned it under the

752
00:26:29,279 --> 00:26:31,039
legs of some other thread so this could

753
00:26:31,039 --> 00:26:33,360
be problematic the really bad news is

754
00:26:33,360 --> 00:26:35,039
that boda with ray right and arbitrary

755
00:26:35,039 --> 00:26:37,360
free are very likely to crash and i want

756
00:26:37,360 --> 00:26:38,960
to show you why and i want to show you

757
00:26:38,960 --> 00:26:41,279
how we can bypass this

758
00:26:41,279 --> 00:26:42,159
so

759
00:26:42,159 --> 00:26:44,640
why the arbitrary write fails with such

760
00:26:44,640 --> 00:26:46,240
high probability so just a short

761
00:26:46,240 --> 00:26:49,039
reminder we just

762
00:26:49,039 --> 00:26:51,279
trigger arbitrary free on the array of

763
00:26:51,279 --> 00:26:53,360
the elements right and now we just

764
00:26:53,360 --> 00:26:56,000
corrupt the fd pointer we reallocate

765
00:26:56,000 --> 00:26:58,159
this array and now the next return value

766
00:26:58,159 --> 00:27:00,720
of malloc is fully under our control the

767
00:27:00,720 --> 00:27:02,159
problem is that your allocation

768
00:27:02,159 --> 00:27:04,320
primitive actually works like this you

769
00:27:04,320 --> 00:27:06,240
call ester dope and now you add the new

770
00:27:06,240 --> 00:27:08,240
string to the list data array

771
00:27:08,240 --> 00:27:09,840
this is really funny because the call to

772
00:27:09,840 --> 00:27:12,080
ester dope will reclaim the list data

773
00:27:12,080 --> 00:27:14,640
location so the allocator will re-tag

774
00:27:14,640 --> 00:27:16,159
all of the memory lines of this

775
00:27:16,159 --> 00:27:18,720
allocation and now the physical tag does

776
00:27:18,720 --> 00:27:21,600
not equal to the whatever msb value of

777
00:27:21,600 --> 00:27:24,480
your daily pointer so this is really

778
00:27:24,480 --> 00:27:26,640
really likely to crash

779
00:27:26,640 --> 00:27:28,159
and this actually look what happens if

780
00:27:28,159 --> 00:27:30,960
you just attach gdb to your expert you

781
00:27:30,960 --> 00:27:33,039
can see that inside of this head we just

782
00:27:33,039 --> 00:27:35,360
said fault when you try to add the list

783
00:27:35,360 --> 00:27:37,919
data which is 14 2fo to itself attack

784
00:27:37,919 --> 00:27:39,440
index 2 and you can see that the two

785
00:27:39,440 --> 00:27:42,240
tags here 6 and d are just different

786
00:27:42,240 --> 00:27:44,320
okay we can fix this no problem but

787
00:27:44,320 --> 00:27:45,679
before we do i just want to show you

788
00:27:45,679 --> 00:27:48,480
really quick white arbitrary crushes and

789
00:27:48,480 --> 00:27:50,640
the arbitrary free again so demander

790
00:27:50,640 --> 00:27:52,720
works as following you just malloc

791
00:27:52,720 --> 00:27:55,600
string you lick its address you free it

792
00:27:55,600 --> 00:27:57,919
you do shaping so you array will reclaim

793
00:27:57,919 --> 00:28:00,000
this string and now you call arbitrary

794
00:28:00,000 --> 00:28:01,600
free with the absolute pointer of the

795
00:28:01,600 --> 00:28:03,440
string that you licked

796
00:28:03,440 --> 00:28:05,039
you cannot call free on that this

797
00:28:05,039 --> 00:28:07,279
pointer has a different tag than the

798
00:28:07,279 --> 00:28:09,520
current existing physical tag of the new

799
00:28:09,520 --> 00:28:11,919
array right and again calling free with

800
00:28:11,919 --> 00:28:14,799
an incorrect tag will segment so

801
00:28:14,799 --> 00:28:17,919
if we lick the current tag of the list

802
00:28:17,919 --> 00:28:20,399
like data array we could call

803
00:28:20,399 --> 00:28:22,480
arbitrary free and we are very lucky

804
00:28:22,480 --> 00:28:24,399
because we have arbitrary

805
00:28:24,399 --> 00:28:26,320
we have a really deterministic allocator

806
00:28:26,320 --> 00:28:27,760
and we know exactly where the list

807
00:28:27,760 --> 00:28:29,919
structure is this is the structure that

808
00:28:29,919 --> 00:28:32,320
i showed you at the beginning of

809
00:28:32,320 --> 00:28:34,399
of our talk and the structure clearly

810
00:28:34,399 --> 00:28:36,000
has a pointer to this data so let's just

811
00:28:36,000 --> 00:28:37,600
use arbitrary read

812
00:28:37,600 --> 00:28:39,840
and leak this tag and we are done so not

813
00:28:39,840 --> 00:28:41,600
really because you cannot trigger

814
00:28:41,600 --> 00:28:43,360
arbitrary read on the list structure

815
00:28:43,360 --> 00:28:46,320
because we have no idea which target has

816
00:28:46,320 --> 00:28:48,640
right this address is not in the array

817
00:28:48,640 --> 00:28:50,559
so the type confusion does not give me

818
00:28:50,559 --> 00:28:51,919
this address

819
00:28:51,919 --> 00:28:54,159
but this is really funny because we know

820
00:28:54,159 --> 00:28:55,919
that the main stack frame has a pointer

821
00:28:55,919 --> 00:28:58,320
to the list structure and i know where

822
00:28:58,320 --> 00:29:00,640
the stack is i have an arbitrary read so

823
00:29:00,640 --> 00:29:02,960
i can just scan the scan the whole stack

824
00:29:02,960 --> 00:29:05,279
remotely and i can get the pointer to

825
00:29:05,279 --> 00:29:07,200
the list structure along which it's

826
00:29:07,200 --> 00:29:09,440
stuck in the msb and now i can do

827
00:29:09,440 --> 00:29:11,919
another arbitrary read to leak the tag

828
00:29:11,919 --> 00:29:14,480
of the list data and this works

829
00:29:14,480 --> 00:29:16,159
so okay this is really nice and we

830
00:29:16,159 --> 00:29:18,880
actually stopped stopped like rushing

831
00:29:18,880 --> 00:29:20,480
but if you will take a look you'll see

832
00:29:20,480 --> 00:29:23,039
that the expert fails because the array

833
00:29:23,039 --> 00:29:25,520
has not actually been freed and this is

834
00:29:25,520 --> 00:29:27,840
because in order to the free function to

835
00:29:27,840 --> 00:29:30,320
actually get called our pointer with the

836
00:29:30,320 --> 00:29:32,720
new tag has to be in the full array and

837
00:29:32,720 --> 00:29:34,159
there is no reason it will be there

838
00:29:34,159 --> 00:29:36,399
because in my expert in my shape i just

839
00:29:36,399 --> 00:29:38,640
allocated a string and i free it once

840
00:29:38,640 --> 00:29:40,720
this is their full array for 1024 is the

841
00:29:40,720 --> 00:29:41,840
least data

842
00:29:41,840 --> 00:29:44,399
and we only has one instance of it with

843
00:29:44,399 --> 00:29:46,720
only one tag and with extremely high

844
00:29:46,720 --> 00:29:49,120
probability this tag does not equal to

845
00:29:49,120 --> 00:29:51,919
the new tag that the list data array got

846
00:29:51,919 --> 00:29:55,200
okay we can fix that right just like

847
00:29:55,200 --> 00:29:57,360
instead doing malloc free once let's do

848
00:29:57,360 --> 00:30:00,000
it 200 times let's have let's have a lot

849
00:30:00,000 --> 00:30:02,320
of pointers of the same virtual address

850
00:30:02,320 --> 00:30:04,080
in the full array with many many

851
00:30:04,080 --> 00:30:05,679
different tags and with extremely high

852
00:30:05,679 --> 00:30:08,399
probability all of the 16 possibilities

853
00:30:08,399 --> 00:30:10,320
of the tags will be there and now the

854
00:30:10,320 --> 00:30:11,840
arbitrary three is saved and like

855
00:30:11,840 --> 00:30:14,559
everything works and we actually have

856
00:30:14,559 --> 00:30:16,480
an exploit that works with a probability

857
00:30:16,480 --> 00:30:19,520
of one out of 16 instead of one out of

858
00:30:19,520 --> 00:30:22,000
16 square it is really nice especially

859
00:30:22,000 --> 00:30:23,840
compared to the really minimal efforts

860
00:30:23,840 --> 00:30:25,120
that we just did

861
00:30:25,120 --> 00:30:26,799
now i really want to have demos but

862
00:30:26,799 --> 00:30:28,480
instead i will do all of the three like

863
00:30:28,480 --> 00:30:30,000
demos together because we don't have

864
00:30:30,000 --> 00:30:32,080
time so i have scan shots but again you

865
00:30:32,080 --> 00:30:33,600
you will see it live in about two

866
00:30:33,600 --> 00:30:35,039
minutes

867
00:30:35,039 --> 00:30:36,640
this is the base exploit this is what

868
00:30:36,640 --> 00:30:38,480
happens if you just run my exploits in a

869
00:30:38,480 --> 00:30:40,000
loop okay

870
00:30:40,000 --> 00:30:42,159
hopefully that's like some good like

871
00:30:42,159 --> 00:30:45,840
random happen and after 153 times it

872
00:30:45,840 --> 00:30:47,919
just so happened that both the tags in

873
00:30:47,919 --> 00:30:49,760
the arbitrary and in the arbitrary

874
00:30:49,760 --> 00:30:51,679
rights are okay

875
00:30:51,679 --> 00:30:53,039
and we got a shell

876
00:30:53,039 --> 00:30:54,559
if you implement the bypass of the

877
00:30:54,559 --> 00:30:56,960
arbitrary three that we just saw then it

878
00:30:56,960 --> 00:30:59,200
works after four times which is really

879
00:30:59,200 --> 00:31:00,159
nice

880
00:31:00,159 --> 00:31:02,000
and now we can fix the arbitrary right

881
00:31:02,000 --> 00:31:04,000
and we'll get like deterministic expert

882
00:31:04,000 --> 00:31:06,159
and then i could finally get my whiskey

883
00:31:06,159 --> 00:31:07,120
so

884
00:31:07,120 --> 00:31:09,519
um just like a short reminder what's

885
00:31:09,519 --> 00:31:11,679
going on here is that we

886
00:31:11,679 --> 00:31:14,000
reallocate the list data and therefore

887
00:31:14,000 --> 00:31:16,320
the allocator re-tag the entire location

888
00:31:16,320 --> 00:31:18,399
and then we write the new string into

889
00:31:18,399 --> 00:31:20,640
the list data array this store bothers

890
00:31:20,640 --> 00:31:21,360
me

891
00:31:21,360 --> 00:31:23,200
the the fact that the challenge writes

892
00:31:23,200 --> 00:31:25,279
the pointer to the new string into the

893
00:31:25,279 --> 00:31:27,760
newly tagged chunk really bothers me so

894
00:31:27,760 --> 00:31:30,159
i can just shape my heap such that the

895
00:31:30,159 --> 00:31:32,399
the like this data won't be freed into

896
00:31:32,399 --> 00:31:34,159
the ticket it will be free into the

897
00:31:34,159 --> 00:31:36,720
small bins and now i can just

898
00:31:36,720 --> 00:31:38,720
reclaim part of the location and

899
00:31:38,720 --> 00:31:40,799
therefore the allocator will just re-tag

900
00:31:40,799 --> 00:31:43,279
the beginning of it and not all of it

901
00:31:43,279 --> 00:31:44,960
let's see it's

902
00:31:44,960 --> 00:31:47,039
in action so like this is the hip the

903
00:31:47,039 --> 00:31:49,200
background color thank you so much eda

904
00:31:49,200 --> 00:31:52,159
the background color is the tag okay so

905
00:31:52,159 --> 00:31:54,640
we have three elements and i want to add

906
00:31:54,640 --> 00:31:56,240
more i want to add more because i want

907
00:31:56,240 --> 00:31:59,039
the list size to be really close to the

908
00:31:59,039 --> 00:32:01,200
end of the array to the end of the

909
00:32:01,200 --> 00:32:03,120
location and now i call i'll be trading

910
00:32:03,120 --> 00:32:04,320
free

911
00:32:04,320 --> 00:32:07,279
because we do not return on free the tag

912
00:32:07,279 --> 00:32:09,360
like remains the same but this chunk is

913
00:32:09,360 --> 00:32:12,000
now freed and i can add one more string

914
00:32:12,000 --> 00:32:13,919
and this is the super important part we

915
00:32:13,919 --> 00:32:16,000
add one more string so the allocator

916
00:32:16,000 --> 00:32:18,080
re-tag the beginning of the allocation

917
00:32:18,080 --> 00:32:19,760
and it store the pointer to the string

918
00:32:19,760 --> 00:32:22,159
to this offset but this offset has the

919
00:32:22,159 --> 00:32:24,880
same tag as the dangling pointer the

920
00:32:24,880 --> 00:32:26,640
physical tag and the logic tag are

921
00:32:26,640 --> 00:32:29,279
identical so we are safe

922
00:32:29,279 --> 00:32:31,279
okay so now we can free the string and

923
00:32:31,279 --> 00:32:33,039
corrupt the f3 pointer and we are done

924
00:32:33,039 --> 00:32:35,120
right so not really because again in

925
00:32:35,120 --> 00:32:37,279
order to corrupt the electricity pointer

926
00:32:37,279 --> 00:32:39,039
we need to write through our dangling

927
00:32:39,039 --> 00:32:42,080
pointer but the msb of the list data

928
00:32:42,080 --> 00:32:44,399
does not equal to the new some random

929
00:32:44,399 --> 00:32:45,760
tag that we got

930
00:32:45,760 --> 00:32:47,519
but we have a type confusion and i can

931
00:32:47,519 --> 00:32:49,679
lick this pointer i can make the s1

932
00:32:49,679 --> 00:32:52,159
along with its tag and i can check if

933
00:32:52,159 --> 00:32:54,399
this tag is identical to the tag that i

934
00:32:54,399 --> 00:32:56,320
already have and i can do it again and

935
00:32:56,320 --> 00:32:57,919
again and again malloc free malloc free

936
00:32:57,919 --> 00:33:00,799
mark free and until i get the same tag

937
00:33:00,799 --> 00:33:03,120
and now we have a full expert that works

938
00:33:03,120 --> 00:33:04,799
deterministically and now let's have

939
00:33:04,799 --> 00:33:07,440
some fun with some random if we can go

940
00:33:07,440 --> 00:33:11,320
to the demo please

941
00:33:13,440 --> 00:33:15,919
might take some time

942
00:33:15,919 --> 00:33:19,440
okay awesome so let's start the docker

943
00:33:19,440 --> 00:33:21,679
okay so we have bluetooth demo nice and

944
00:33:21,679 --> 00:33:23,840
we have bluet and we have like empty plc

945
00:33:23,840 --> 00:33:25,360
and i just want to build like the

946
00:33:25,360 --> 00:33:26,799
challenge so you will see that we have

947
00:33:26,799 --> 00:33:27,600
here

948
00:33:27,600 --> 00:33:28,960
the like

949
00:33:28,960 --> 00:33:31,600
rmv 8.5 plus mem tag this is how you

950
00:33:31,600 --> 00:33:34,559
build with the campaign okay and we have

951
00:33:34,559 --> 00:33:36,720
three exploits we have the base expert

952
00:33:36,720 --> 00:33:38,880
with zero like awareness for like

953
00:33:38,880 --> 00:33:41,200
work empty we have the arbitrary free

954
00:33:41,200 --> 00:33:42,960
works as i've showed you and we have

955
00:33:42,960 --> 00:33:45,200
that the deterministic exploits

956
00:33:45,200 --> 00:33:46,320
so

957
00:33:46,320 --> 00:33:48,480
if we just try to run

958
00:33:48,480 --> 00:33:50,159
the like base exploit with zero like

959
00:33:50,159 --> 00:33:52,799
awareness for

960
00:33:52,799 --> 00:33:54,960
it will run and run and run and it fails

961
00:33:54,960 --> 00:33:57,519
20 times 30 times like 40 times we can

962
00:33:57,519 --> 00:33:59,200
keep it going but it doesn't really

963
00:33:59,200 --> 00:34:01,200
interesting to play with random numbers

964
00:34:01,200 --> 00:34:04,080
so let's just run an exploit that has

965
00:34:04,080 --> 00:34:07,440
much better like probability to

966
00:34:07,440 --> 00:34:10,639
to succeed and

967
00:34:10,639 --> 00:34:13,199
yep sometimes they like docker does like

968
00:34:13,199 --> 00:34:15,520
funny stuff um

969
00:34:15,520 --> 00:34:17,839
and again it's a condom but

970
00:34:17,839 --> 00:34:20,000
after some attempts

971
00:34:20,000 --> 00:34:22,079
okay so after two attempts it's it's

972
00:34:22,079 --> 00:34:23,839
like walk and we have the flag

973
00:34:23,839 --> 00:34:25,520
um

974
00:34:25,520 --> 00:34:27,359
and you can see that it works after the

975
00:34:27,359 --> 00:34:29,359
second attempt

976
00:34:29,359 --> 00:34:32,639
and just to and just to like do it

977
00:34:32,639 --> 00:34:35,119
correctly thank you we can do the

978
00:34:35,119 --> 00:34:37,199
deterministic exploits

979
00:34:37,199 --> 00:34:40,480
it ran only one time

980
00:34:41,918 --> 00:34:44,000
and it works

981
00:34:44,000 --> 00:34:47,040
and this is the parts

982
00:34:47,040 --> 00:34:48,560
this is the part when we do like malloc

983
00:34:48,560 --> 00:34:50,719
free malloc free until we got the same

984
00:34:50,719 --> 00:34:51,760
tag

985
00:34:51,760 --> 00:34:53,359
all of this code will be published with

986
00:34:53,359 --> 00:34:55,119
the slides i really encourage you to get

987
00:34:55,119 --> 00:34:57,040
your hands dirty and to try to mess

988
00:34:57,040 --> 00:34:59,440
around with it it's really fun and we

989
00:34:59,440 --> 00:35:01,760
can execute it again

990
00:35:01,760 --> 00:35:03,920
and again

991
00:35:03,920 --> 00:35:05,680
and again it will and it will always

992
00:35:05,680 --> 00:35:07,680
work because we only the reference

993
00:35:07,680 --> 00:35:10,320
pointers where we have the knowledge

994
00:35:10,320 --> 00:35:12,480
that the tags are identical it will

995
00:35:12,480 --> 00:35:14,320
always work

996
00:35:14,320 --> 00:35:16,160
okay now we can go back to the slide

997
00:35:16,160 --> 00:35:18,240
thank you

998
00:35:18,240 --> 00:35:19,599
okay so

999
00:35:19,599 --> 00:35:22,000
let's face the fact that notary tag on

1000
00:35:22,000 --> 00:35:23,839
free with like deal malloc is really

1001
00:35:23,839 --> 00:35:26,000
unwise because you have pointers inside

1002
00:35:26,000 --> 00:35:28,079
of three chunks right we have the fd

1003
00:35:28,079 --> 00:35:29,760
pointer that gives us like arbitrary

1004
00:35:29,760 --> 00:35:31,680
right so we really need to re-target

1005
00:35:31,680 --> 00:35:33,920
locations on free and this is what this

1006
00:35:33,920 --> 00:35:36,160
sample show you this show you that it's

1007
00:35:36,160 --> 00:35:38,079
really important to return locations on

1008
00:35:38,079 --> 00:35:40,720
free if your allocator has no awareness

1009
00:35:40,720 --> 00:35:43,440
for security whatsoever so if you do it

1010
00:35:43,440 --> 00:35:45,839
again free this is what happens

1011
00:35:45,839 --> 00:35:48,800
the like leak of eclipse will fail right

1012
00:35:48,800 --> 00:35:51,200
because we read the content of a free

1013
00:35:51,200 --> 00:35:53,359
chunk so there is a reference there and

1014
00:35:53,359 --> 00:35:55,680
if you will try to corrupt the fd you

1015
00:35:55,680 --> 00:35:57,760
will crash again so the entire exploit

1016
00:35:57,760 --> 00:36:00,640
work with the probability of 1 out of 16

1017
00:36:00,640 --> 00:36:02,320
square and this is really bad

1018
00:36:02,320 --> 00:36:03,200
so

1019
00:36:03,200 --> 00:36:07,119
the main messages here are that well

1020
00:36:07,119 --> 00:36:10,000
the attack mt broke some of the x of the

1021
00:36:10,000 --> 00:36:11,920
exploitation method right for instance

1022
00:36:11,920 --> 00:36:14,320
every read and write into a free chunk

1023
00:36:14,320 --> 00:36:16,240
are really problematic now

1024
00:36:16,240 --> 00:36:17,839
uh and

1025
00:36:17,839 --> 00:36:20,240
and and the and the funny part is that

1026
00:36:20,240 --> 00:36:22,000
it did not break the exploitability of

1027
00:36:22,000 --> 00:36:24,320
bugs bugs are still ex

1028
00:36:24,320 --> 00:36:26,480
are still exploitable because first of

1029
00:36:26,480 --> 00:36:28,480
all you can do probabilistic exploits

1030
00:36:28,480 --> 00:36:30,880
right and it will work eventually it

1031
00:36:30,880 --> 00:36:32,960
really sucks but it will work and second

1032
00:36:32,960 --> 00:36:35,520
of all this just was a ctf challenge i

1033
00:36:35,520 --> 00:36:38,000
only had strings here and it's not even

1034
00:36:38,000 --> 00:36:41,040
std string it's just buffer of bytes but

1035
00:36:41,040 --> 00:36:43,599
if instead of the edit of like a new

1036
00:36:43,599 --> 00:36:45,440
string with s2 dope i would actually

1037
00:36:45,440 --> 00:36:47,440
like allocate a c plus object with a v

1038
00:36:47,440 --> 00:36:49,680
table i could leak libsy and i could

1039
00:36:49,680 --> 00:36:52,480
bypass like the slr without the need to

1040
00:36:52,480 --> 00:36:54,640
let the reference free chunk same goes

1041
00:36:54,640 --> 00:36:56,480
for arbitrary right if you have many

1042
00:36:56,480 --> 00:36:58,560
many structures as you do in like real

1043
00:36:58,560 --> 00:37:01,119
life you actually could to gain

1044
00:37:01,119 --> 00:37:02,880
arbitrary right through these pointers

1045
00:37:02,880 --> 00:37:05,119
and you don't need to actually reference

1046
00:37:05,119 --> 00:37:06,960
free chunks so this is why i believe

1047
00:37:06,960 --> 00:37:09,040
that in real life scenarios type

1048
00:37:09,040 --> 00:37:11,280
confusions first first order type

1049
00:37:11,280 --> 00:37:14,640
confusion will compromise your system um

1050
00:37:14,640 --> 00:37:16,320
i just want to mention here that this

1051
00:37:16,320 --> 00:37:18,000
probabilistic exploit could be really

1052
00:37:18,000 --> 00:37:20,240
problematic with some demon and services

1053
00:37:20,240 --> 00:37:23,040
that keep relaunching like themselves so

1054
00:37:23,040 --> 00:37:24,160
if you

1055
00:37:24,160 --> 00:37:25,680
are not in like a kernel-like

1056
00:37:25,680 --> 00:37:27,119
environment that you really don't want

1057
00:37:27,119 --> 00:37:29,520
to crash you have a problem but on the

1058
00:37:29,520 --> 00:37:31,599
other side of it people that exploit

1059
00:37:31,599 --> 00:37:34,400
bugs don't really want their exploits to

1060
00:37:34,400 --> 00:37:36,720
crash with just higher probability first

1061
00:37:36,720 --> 00:37:38,079
of all because it's really suck and it's

1062
00:37:38,079 --> 00:37:40,000
really sad and it's really lame and also

1063
00:37:40,000 --> 00:37:42,160
because the like probability that your

1064
00:37:42,160 --> 00:37:45,040
bug will get disclosed is much more

1065
00:37:45,040 --> 00:37:47,520
high right and this is a really funny

1066
00:37:47,520 --> 00:37:49,200
part we don't have time for this so just

1067
00:37:49,200 --> 00:37:52,000
check it out at home and but just like

1068
00:37:52,000 --> 00:37:54,800
to sum up uh we have probabilistic

1069
00:37:54,800 --> 00:37:57,040
mitigations for most of the memory

1070
00:37:57,040 --> 00:37:58,480
safety backlashes we have one

1071
00:37:58,480 --> 00:38:00,720
deterministic mitigation really cute

1072
00:38:00,720 --> 00:38:02,480
from copy and for

1073
00:38:02,480 --> 00:38:04,880
like strictly like linear overflow and

1074
00:38:04,880 --> 00:38:07,280
like underflows and i have serious

1075
00:38:07,280 --> 00:38:09,359
concern about information disclosures

1076
00:38:09,359 --> 00:38:11,280
about straightforward type confusions

1077
00:38:11,280 --> 00:38:13,280
and clearly about the fact that we only

1078
00:38:13,280 --> 00:38:15,359
have 16 possibilities for tax this is

1079
00:38:15,359 --> 00:38:16,800
really small number

1080
00:38:16,800 --> 00:38:19,359
um but again mt was not designed for

1081
00:38:19,359 --> 00:38:21,680
mmos anti-mitigation so it's fine i just

1082
00:38:21,680 --> 00:38:23,119
think that it's really nice to take a

1083
00:38:23,119 --> 00:38:25,839
new silicone feature enable it and just

1084
00:38:25,839 --> 00:38:27,520
mess around with it see like what's

1085
00:38:27,520 --> 00:38:28,800
going on

1086
00:38:28,800 --> 00:38:30,400
and i really hope that you have fun

1087
00:38:30,400 --> 00:38:31,839
shout outs to all of my friends at the

1088
00:38:31,839 --> 00:38:34,560
msrc msr arm cambridge

1089
00:38:34,560 --> 00:38:36,400
and all of the stuff here are some links

1090
00:38:36,400 --> 00:38:38,079
that you could follow and thank you so

1091
00:38:38,079 --> 00:38:41,079
much

1092
00:38:44,740 --> 00:38:47,440
[Music]

1093
00:38:47,440 --> 00:38:49,520
you

