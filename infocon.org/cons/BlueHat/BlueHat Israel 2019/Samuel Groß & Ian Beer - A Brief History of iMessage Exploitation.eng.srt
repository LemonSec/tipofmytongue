1
00:00:00,930 --> 00:00:08,260
[Music]

2
00:00:14,160 --> 00:00:16,320
yeah thanks everyone

3
00:00:16,320 --> 00:00:17,199
um

4
00:00:17,199 --> 00:00:19,199
great introduction yeah thanks uh

5
00:00:19,199 --> 00:00:22,160
welcome to our talk a brief history of

6
00:00:22,160 --> 00:00:24,000
imessage exploitation

7
00:00:24,000 --> 00:00:25,199
i'm sam

8
00:00:25,199 --> 00:00:27,599
uh unfortunately ian couldn't make it

9
00:00:27,599 --> 00:00:30,080
short notice so i'll be covering his

10
00:00:30,080 --> 00:00:32,079
part as well

11
00:00:32,079 --> 00:00:34,320
now for those of you who don't know

12
00:00:34,320 --> 00:00:37,600
imessage is apple's messaging service

13
00:00:37,600 --> 00:00:39,600
that they use on their platforms you

14
00:00:39,600 --> 00:00:41,680
know when you send a message from your

15
00:00:41,680 --> 00:00:43,600
iphone to your friends

16
00:00:43,600 --> 00:00:45,200
macbook or ipad

17
00:00:45,200 --> 00:00:46,480
this is

18
00:00:46,480 --> 00:00:48,640
going over imessage

19
00:00:48,640 --> 00:00:49,760
um

20
00:00:49,760 --> 00:00:51,600
and yeah so

21
00:00:51,600 --> 00:00:53,680
this this history or this story of

22
00:00:53,680 --> 00:00:55,440
imessage security

23
00:00:55,440 --> 00:00:57,360
i'm going to tell it in in three

24
00:00:57,360 --> 00:00:59,039
chapters

25
00:00:59,039 --> 00:01:00,320
um

26
00:01:00,320 --> 00:01:03,199
i i only have 40 minutes so i kind of

27
00:01:03,199 --> 00:01:05,119
can't go into much detail

28
00:01:05,119 --> 00:01:07,680
but every chapter there's a blog post

29
00:01:07,680 --> 00:01:09,360
for it you can find the link on the

30
00:01:09,360 --> 00:01:12,640
slide and those slides end up on twitter

31
00:01:12,640 --> 00:01:13,520
also

32
00:01:13,520 --> 00:01:16,880
and there you can find many more details

33
00:01:16,880 --> 00:01:19,840
okay so why is imessage interesting for

34
00:01:19,840 --> 00:01:21,840
security researchers

35
00:01:21,840 --> 00:01:23,520
well

36
00:01:23,520 --> 00:01:26,159
if you as an attacker if you are able to

37
00:01:26,159 --> 00:01:29,759
find and exploit a bug in imessage

38
00:01:29,759 --> 00:01:32,000
then you can basically remotely

39
00:01:32,000 --> 00:01:34,000
compromise kind of every pretty much

40
00:01:34,000 --> 00:01:36,240
every apple device

41
00:01:36,240 --> 00:01:38,880
without the user doing anything and

42
00:01:38,880 --> 00:01:41,439
without the user noticing so it's really

43
00:01:41,439 --> 00:01:42,799
kind of scary

44
00:01:42,799 --> 00:01:44,320
and i think it's very

45
00:01:44,320 --> 00:01:46,240
uh very interesting to look into these

46
00:01:46,240 --> 00:01:47,439
attacks

47
00:01:47,439 --> 00:01:49,119
but okay so let's start with the first

48
00:01:49,119 --> 00:01:50,079
chapter

49
00:01:50,079 --> 00:01:52,880
uh this starts in 2019

50
00:01:52,880 --> 00:01:53,920
when

51
00:01:53,920 --> 00:01:56,399
my team at project zero when we

52
00:01:56,399 --> 00:01:58,880
developed one of these exploits against

53
00:01:58,880 --> 00:02:01,200
imessage

54
00:02:01,200 --> 00:02:04,799
so i go walk you through how this worked

55
00:02:04,799 --> 00:02:06,079
now

56
00:02:06,079 --> 00:02:08,560
before we can exploit anything

57
00:02:08,560 --> 00:02:10,639
well we need a bug right

58
00:02:10,639 --> 00:02:13,280
but even before we have a bug we need an

59
00:02:13,280 --> 00:02:15,520
attack service so

60
00:02:15,520 --> 00:02:17,920
some kind of of software

61
00:02:17,920 --> 00:02:20,319
that we can supply input to that's going

62
00:02:20,319 --> 00:02:23,040
to process that input and where we can

63
00:02:23,040 --> 00:02:25,200
then look for bugs

64
00:02:25,200 --> 00:02:26,959
right so this is going to be the first

65
00:02:26,959 --> 00:02:28,720
step

66
00:02:28,720 --> 00:02:30,800
finding an attack surface

67
00:02:30,800 --> 00:02:33,040
how would you go about it i think the

68
00:02:33,040 --> 00:02:35,519
straight straightforward way is

69
00:02:35,519 --> 00:02:38,480
you look at how imessage works uh like

70
00:02:38,480 --> 00:02:39,519
how the

71
00:02:39,519 --> 00:02:42,400
how an imessage looks on the wire right

72
00:02:42,400 --> 00:02:44,239
so when you like take one of these

73
00:02:44,239 --> 00:02:46,560
phones you send a message

74
00:02:46,560 --> 00:02:47,440
um

75
00:02:47,440 --> 00:02:49,760
this here is what actually goes over the

76
00:02:49,760 --> 00:02:50,720
wire

77
00:02:50,720 --> 00:02:52,879
it's called it's it's a property list

78
00:02:52,879 --> 00:02:54,080
it's like the

79
00:02:54,080 --> 00:02:56,560
the name of this like format it's apple

80
00:02:56,560 --> 00:02:59,200
specific but you can think of it like a

81
00:02:59,200 --> 00:03:00,480
json

82
00:03:00,480 --> 00:03:02,720
dictionary

83
00:03:02,720 --> 00:03:05,040
i guess some of these fields they will

84
00:03:05,040 --> 00:03:07,360
make immediate sense like p

85
00:03:07,360 --> 00:03:09,519
that's the participants in this case

86
00:03:09,519 --> 00:03:13,440
it's a two two person chat um

87
00:03:13,440 --> 00:03:15,840
t that's the

88
00:03:15,840 --> 00:03:18,239
uh the plain text message like hello

89
00:03:18,239 --> 00:03:19,920
bluehead

90
00:03:19,920 --> 00:03:23,040
there's some what looks like it's html

91
00:03:23,040 --> 00:03:24,720
in there in the x key but it's not

92
00:03:24,720 --> 00:03:26,720
really html it's

93
00:03:26,720 --> 00:03:29,519
parse this xml is kind of weird

94
00:03:29,519 --> 00:03:32,560
some uu ids to identify this message

95
00:03:32,560 --> 00:03:35,040
but what's really standing out

96
00:03:35,040 --> 00:03:37,440
at least when we looked at this

97
00:03:37,440 --> 00:03:39,680
is this ati key

98
00:03:39,680 --> 00:03:41,920
where it has some

99
00:03:41,920 --> 00:03:43,920
what's called an ns keyed archiver

100
00:03:43,920 --> 00:03:46,319
payload in it so it's like raw bytes

101
00:03:46,319 --> 00:03:48,480
that they then go into some

102
00:03:48,480 --> 00:03:50,959
some other decoder

103
00:03:50,959 --> 00:03:53,120
so what is the ns keyed archiver if you

104
00:03:53,120 --> 00:03:54,959
look into the documentation

105
00:03:54,959 --> 00:03:58,239
it says nskt archiver provides a way to

106
00:03:58,239 --> 00:04:01,280
encode objects and scalar values into an

107
00:04:01,280 --> 00:04:03,680
architecture independent format suitable

108
00:04:03,680 --> 00:04:05,599
for storage in a file

109
00:04:05,599 --> 00:04:08,080
or you know in this case suitable for

110
00:04:08,080 --> 00:04:10,319
sending it over the wire

111
00:04:10,319 --> 00:04:12,400
now this is a pretty powerful

112
00:04:12,400 --> 00:04:14,480
serialization format

113
00:04:14,480 --> 00:04:17,440
it even supports cycles

114
00:04:17,440 --> 00:04:19,839
so json for example it doesn't support

115
00:04:19,839 --> 00:04:22,240
circles but this one does so for here in

116
00:04:22,240 --> 00:04:23,919
this bottom

117
00:04:23,919 --> 00:04:25,360
image you see

118
00:04:25,360 --> 00:04:28,160
like an ns area ns is just the prefix

119
00:04:28,160 --> 00:04:29,840
they use for these objects so you have

120
00:04:29,840 --> 00:04:32,080
like an array contains a number and

121
00:04:32,080 --> 00:04:34,639
dictionary and now the dictionary links

122
00:04:34,639 --> 00:04:36,240
back to the array

123
00:04:36,240 --> 00:04:38,560
so you have a circle and this you can

124
00:04:38,560 --> 00:04:41,440
serialize just fine with this format so

125
00:04:41,440 --> 00:04:43,440
it's really quite complex

126
00:04:43,440 --> 00:04:45,120
it has a lot of

127
00:04:45,120 --> 00:04:46,880
a lot of features

128
00:04:46,880 --> 00:04:48,960
and so we immediately like went into

129
00:04:48,960 --> 00:04:51,199
this as our attack surface this looks

130
00:04:51,199 --> 00:04:52,240
complex

131
00:04:52,240 --> 00:04:54,479
there could be bugs here

132
00:04:54,479 --> 00:04:56,800
and now to make it even more uh even

133
00:04:56,800 --> 00:04:57,919
nicer

134
00:04:57,919 --> 00:05:00,240
we realized that one of these so there

135
00:05:00,240 --> 00:05:02,160
were multiple payloads in these

136
00:05:02,160 --> 00:05:04,639
imessages but one of them was actually

137
00:05:04,639 --> 00:05:07,759
being decoded in springboard and

138
00:05:07,759 --> 00:05:10,479
springboard is the main ui process and

139
00:05:10,479 --> 00:05:12,960
it's unsandboxed so what that means is

140
00:05:12,960 --> 00:05:15,039
if you find a bug in this format and you

141
00:05:15,039 --> 00:05:15,919
trigger

142
00:05:15,919 --> 00:05:18,479
and you can exploit it over imessage

143
00:05:18,479 --> 00:05:20,320
you immediately get code execution

144
00:05:20,320 --> 00:05:23,360
outside the sandbox like it's done

145
00:05:23,360 --> 00:05:25,680
so this looks really good let's go into

146
00:05:25,680 --> 00:05:27,680
that

147
00:05:27,680 --> 00:05:29,520
so here's where we are this is kind of

148
00:05:29,520 --> 00:05:31,919
i'm going to like draw a picture of how

149
00:05:31,919 --> 00:05:34,560
these attacks work they look like this

150
00:05:34,560 --> 00:05:37,840
the colors are a bit ad hoc so orange is

151
00:05:37,840 --> 00:05:39,600
something that's required

152
00:05:39,600 --> 00:05:43,120
red is the the exploit flow

153
00:05:43,120 --> 00:05:45,199
so we now have the attack surface that's

154
00:05:45,199 --> 00:05:48,000
the ns keyed unarchiver stuff we have a

155
00:05:48,000 --> 00:05:49,600
bug i didn't mention the bug it doesn't

156
00:05:49,600 --> 00:05:52,639
really matter we found a bug there

157
00:05:52,639 --> 00:05:54,880
and we also have seen that if we can

158
00:05:54,880 --> 00:05:57,280
exploit it we have unsandboxed code

159
00:05:57,280 --> 00:05:59,360
execution

160
00:05:59,360 --> 00:06:02,240
so now we're in the exploitation part

161
00:06:02,240 --> 00:06:04,720
um and the first thing with these memory

162
00:06:04,720 --> 00:06:06,560
corruption bugs the first thing we need

163
00:06:06,560 --> 00:06:10,000
to deal with is aslr

164
00:06:10,000 --> 00:06:12,000
what is aslr so it's address-based

165
00:06:12,000 --> 00:06:15,039
layout randomization

166
00:06:15,039 --> 00:06:18,319
here is like a schematic of a process

167
00:06:18,319 --> 00:06:21,120
address space it can address everything

168
00:06:21,120 --> 00:06:23,759
from zero to address hex seven

169
00:06:23,759 --> 00:06:25,840
fff and so on

170
00:06:25,840 --> 00:06:26,639
and

171
00:06:26,639 --> 00:06:28,960
we now need to find a certain mapping

172
00:06:28,960 --> 00:06:30,800
like a certain object in the address

173
00:06:30,800 --> 00:06:33,360
space it's called the dyld shared cache

174
00:06:33,360 --> 00:06:34,880
it's not really important what's in

175
00:06:34,880 --> 00:06:36,880
there it's basically all the code

176
00:06:36,880 --> 00:06:39,199
libraries linked together all the code

177
00:06:39,199 --> 00:06:40,639
is in there

178
00:06:40,639 --> 00:06:43,759
and we need to find it to then continue

179
00:06:43,759 --> 00:06:45,600
the exploit because we don't know where

180
00:06:45,600 --> 00:06:48,639
anything is in the process

181
00:06:48,639 --> 00:06:50,880
so this is our next task

182
00:06:50,880 --> 00:06:53,759
now why is this hard

183
00:06:53,759 --> 00:06:56,000
so if you think about how a

184
00:06:56,000 --> 00:06:58,160
kind of on an abstract level

185
00:06:58,160 --> 00:07:00,240
how a typical memory corruption exploit

186
00:07:00,240 --> 00:07:02,720
works it's these three steps that you

187
00:07:02,720 --> 00:07:04,240
have at the bottom

188
00:07:04,240 --> 00:07:06,479
so the first step is

189
00:07:06,479 --> 00:07:08,560
you have to leak a valid address from

190
00:07:08,560 --> 00:07:10,240
the target process right you don't know

191
00:07:10,240 --> 00:07:12,160
where addresses are you have to leak an

192
00:07:12,160 --> 00:07:13,840
address of something

193
00:07:13,840 --> 00:07:15,680
and then you can figure out where some

194
00:07:15,680 --> 00:07:17,919
library is for example

195
00:07:17,919 --> 00:07:20,000
and so what you then do with that is you

196
00:07:20,000 --> 00:07:22,319
have your what i call abstract payload

197
00:07:22,319 --> 00:07:23,680
here

198
00:07:23,680 --> 00:07:26,080
for example you might have a rob chain

199
00:07:26,080 --> 00:07:27,919
that is just offsets

200
00:07:27,919 --> 00:07:29,520
so that is your abstract payload just

201
00:07:29,520 --> 00:07:31,520
that rob chain with offsets into some

202
00:07:31,520 --> 00:07:32,479
library

203
00:07:32,479 --> 00:07:34,800
then you take that abstract payload and

204
00:07:34,800 --> 00:07:38,000
you instantiate a concrete one if you

205
00:07:38,000 --> 00:07:39,039
will

206
00:07:39,039 --> 00:07:40,240
right and so

207
00:07:40,240 --> 00:07:42,560
you do that by adding those offsets onto

208
00:07:42,560 --> 00:07:44,800
that address you leak and now you have a

209
00:07:44,800 --> 00:07:47,280
real payload that is valid in the target

210
00:07:47,280 --> 00:07:48,800
process

211
00:07:48,800 --> 00:07:50,879
and has like the correct addresses and

212
00:07:50,879 --> 00:07:53,360
then you deliver that

213
00:07:53,360 --> 00:07:55,520
this is kind of what you need to do but

214
00:07:55,520 --> 00:07:57,280
for this to work you need a

215
00:07:57,280 --> 00:07:59,280
communication channel

216
00:07:59,280 --> 00:08:01,759
between the target process

217
00:08:01,759 --> 00:08:03,919
and the exploit logic

218
00:08:03,919 --> 00:08:06,160
now in some cases this is not a problem

219
00:08:06,160 --> 00:08:08,479
at all if you think about typical web

220
00:08:08,479 --> 00:08:10,560
browser exploits

221
00:08:10,560 --> 00:08:12,800
there the exploit logic is implemented

222
00:08:12,800 --> 00:08:14,240
in javascript

223
00:08:14,240 --> 00:08:16,800
and so it runs in the process that's

224
00:08:16,800 --> 00:08:19,120
being exploited so of course you have a

225
00:08:19,120 --> 00:08:20,720
communication channel you just read

226
00:08:20,720 --> 00:08:23,520
memory it's the same process

227
00:08:23,520 --> 00:08:26,400
but for us in imessage this is much more

228
00:08:26,400 --> 00:08:29,120
of a problem because there is of course

229
00:08:29,120 --> 00:08:32,399
no message that sends back addresses to

230
00:08:32,399 --> 00:08:34,240
to like the attacker so we have to

231
00:08:34,240 --> 00:08:36,240
figure out how to like communicate in a

232
00:08:36,240 --> 00:08:37,200
way that

233
00:08:37,200 --> 00:08:42,399
lets us uh infer aslr addresses

234
00:08:42,399 --> 00:08:44,560
so how we're going to do this um

235
00:08:44,560 --> 00:08:46,880
we will use something called delivery

236
00:08:46,880 --> 00:08:48,080
receipts

237
00:08:48,080 --> 00:08:50,480
if you've ever sent an imessage probably

238
00:08:50,480 --> 00:08:52,240
have seen something like this image here

239
00:08:52,240 --> 00:08:54,160
on the left

240
00:08:54,160 --> 00:08:56,640
so a message it can basically have three

241
00:08:56,640 --> 00:08:59,200
different states it can be sent

242
00:08:59,200 --> 00:09:01,680
delivered red

243
00:09:01,680 --> 00:09:03,920
red meaning the user looked at it

244
00:09:03,920 --> 00:09:06,480
delivered meaning it got to the device

245
00:09:06,480 --> 00:09:08,480
the way this is implemented

246
00:09:08,480 --> 00:09:11,279
is that when the service the daemon that

247
00:09:11,279 --> 00:09:13,760
processes imessages when it gets the

248
00:09:13,760 --> 00:09:16,080
message it sends back

249
00:09:16,080 --> 00:09:18,560
another message to the sender saying yep

250
00:09:18,560 --> 00:09:20,480
this message i got it and then the

251
00:09:20,480 --> 00:09:23,279
sender marks it as delivered

252
00:09:23,279 --> 00:09:26,080
now this gives us an interesting oracle

253
00:09:26,080 --> 00:09:27,519
because if

254
00:09:27,519 --> 00:09:30,560
during the processing of our imessage if

255
00:09:30,560 --> 00:09:32,320
the service crashes

256
00:09:32,320 --> 00:09:35,360
then it never sends the delivery receipt

257
00:09:35,360 --> 00:09:38,000
and so we have this like one bit

258
00:09:38,000 --> 00:09:40,560
channel that says did it crash or did it

259
00:09:40,560 --> 00:09:41,920
not crash

260
00:09:41,920 --> 00:09:44,720
and this is enough to break aslr so

261
00:09:44,720 --> 00:09:46,720
here's how

262
00:09:46,720 --> 00:09:48,640
what we do is we construct the payload

263
00:09:48,640 --> 00:09:51,120
from the memory corruption bug

264
00:09:51,120 --> 00:09:54,240
that just like reads from some address

265
00:09:54,240 --> 00:09:56,320
that we tell it to

266
00:09:56,320 --> 00:09:57,200
right

267
00:09:57,200 --> 00:09:59,600
and we send this payload over imessage

268
00:09:59,600 --> 00:10:02,160
to the target device and then we check

269
00:10:02,160 --> 00:10:04,560
did we get a delivery receipt or did we

270
00:10:04,560 --> 00:10:05,360
not

271
00:10:05,360 --> 00:10:06,560
and if not

272
00:10:06,560 --> 00:10:08,880
then the address was not valid otherwise

273
00:10:08,880 --> 00:10:10,240
it's valid

274
00:10:10,240 --> 00:10:13,040
and so we then like we started some some

275
00:10:13,040 --> 00:10:15,279
low address

276
00:10:15,279 --> 00:10:17,279
maybe this one here and it crashes we

277
00:10:17,279 --> 00:10:20,079
don't get a receipt that's why it's red

278
00:10:20,079 --> 00:10:21,839
we check another one

279
00:10:21,839 --> 00:10:24,240
aha and now we get a delivery received

280
00:10:24,240 --> 00:10:26,880
so this address must be valid right

281
00:10:26,880 --> 00:10:28,880
and at this point we just kind of do a

282
00:10:28,880 --> 00:10:31,920
binary search to find the base address

283
00:10:31,920 --> 00:10:33,760
in reality it's a little more complex

284
00:10:33,760 --> 00:10:36,000
but the idea is exactly this

285
00:10:36,000 --> 00:10:38,640
so in this case we you know try the

286
00:10:38,640 --> 00:10:39,839
middle

287
00:10:39,839 --> 00:10:42,320
that doesn't work it crashes okay so we

288
00:10:42,320 --> 00:10:44,320
take the upper half again go to the

289
00:10:44,320 --> 00:10:45,360
middle

290
00:10:45,360 --> 00:10:48,640
this doesn't crash okay lower half right

291
00:10:48,640 --> 00:10:51,279
and so on and so on um and if you do

292
00:10:51,279 --> 00:10:53,279
this a couple of times then

293
00:10:53,279 --> 00:10:55,839
you end up leaking the the correct base

294
00:10:55,839 --> 00:10:56,800
address

295
00:10:56,800 --> 00:10:59,279
takes like 20 to 30 messages

296
00:10:59,279 --> 00:11:02,079
so i think this exploit took maybe three

297
00:11:02,079 --> 00:11:04,800
to five minutes total it's i think

298
00:11:04,800 --> 00:11:07,040
acceptable

299
00:11:07,040 --> 00:11:09,760
okay so here's where we are

300
00:11:09,760 --> 00:11:11,519
right we have the attack surface and the

301
00:11:11,519 --> 00:11:12,480
bug

302
00:11:12,480 --> 00:11:15,360
and we've broken aslr and what we needed

303
00:11:15,360 --> 00:11:17,600
are all of these four things here so we

304
00:11:17,600 --> 00:11:19,920
needed what i didn't mention at all we

305
00:11:19,920 --> 00:11:21,440
need this shared cache to be at a

306
00:11:21,440 --> 00:11:23,680
constant address across crashes which

307
00:11:23,680 --> 00:11:26,240
was the case like the process restarts

308
00:11:26,240 --> 00:11:28,480
but this thing is at the same address

309
00:11:28,480 --> 00:11:30,800
we need the crash oracle

310
00:11:30,800 --> 00:11:32,320
we do need some heat spraying which i

311
00:11:32,320 --> 00:11:34,640
also didn't mention

312
00:11:34,640 --> 00:11:36,880
and we need to be able to make repeated

313
00:11:36,880 --> 00:11:38,079
attempts

314
00:11:38,079 --> 00:11:40,240
so back then you could just send a

315
00:11:40,240 --> 00:11:42,320
message get the service to crash 10

316
00:11:42,320 --> 00:11:44,079
seconds later it would come back you try

317
00:11:44,079 --> 00:11:45,680
again right so

318
00:11:45,680 --> 00:11:47,920
you have a lot of attempts

319
00:11:47,920 --> 00:11:50,079
so this is where we are final step is we

320
00:11:50,079 --> 00:11:52,079
need a pack bypass

321
00:11:52,079 --> 00:11:53,600
what is pack

322
00:11:53,600 --> 00:11:55,519
pointer authentication

323
00:11:55,519 --> 00:11:56,880
it's a

324
00:11:56,880 --> 00:11:59,680
new wish hardware security feature on

325
00:11:59,680 --> 00:12:01,920
apple's platforms

326
00:12:01,920 --> 00:12:03,360
the idea is that you can

327
00:12:03,360 --> 00:12:05,519
cryptographically sign

328
00:12:05,519 --> 00:12:08,880
pointers and then verify that they are

329
00:12:08,880 --> 00:12:11,279
legitimate right

330
00:12:11,279 --> 00:12:14,399
and so this effectively breaks rob and

331
00:12:14,399 --> 00:12:16,079
job and these kinds of

332
00:12:16,079 --> 00:12:18,000
standard expert tricks

333
00:12:18,000 --> 00:12:20,399
because they all rely on

334
00:12:20,399 --> 00:12:22,240
you faking or

335
00:12:22,240 --> 00:12:24,639
creating your own pointers into code

336
00:12:24,639 --> 00:12:25,440
yeah

337
00:12:25,440 --> 00:12:28,560
so at the bottom you can kind of see

338
00:12:28,560 --> 00:12:31,040
how pack works very briefly like you

339
00:12:31,040 --> 00:12:33,200
take a normal pointer the top bits are

340
00:12:33,200 --> 00:12:34,560
all unused

341
00:12:34,560 --> 00:12:36,240
you run it through one of these pack

342
00:12:36,240 --> 00:12:38,639
sign instructions and that puts the

343
00:12:38,639 --> 00:12:40,720
signature and the top bits

344
00:12:40,720 --> 00:12:42,399
and then if you want to use this pointer

345
00:12:42,399 --> 00:12:43,200
you

346
00:12:43,200 --> 00:12:44,720
first run it through one of these

347
00:12:44,720 --> 00:12:46,079
authentication

348
00:12:46,079 --> 00:12:47,920
instructions

349
00:12:47,920 --> 00:12:49,839
if that succeeds if the signature is

350
00:12:49,839 --> 00:12:52,240
valid then the top bits are cleared to

351
00:12:52,240 --> 00:12:54,399
zero the address is valid if the

352
00:12:54,399 --> 00:12:57,680
authentication fails the top bits become

353
00:12:57,680 --> 00:12:59,920
some garbage and if you then try to use

354
00:12:59,920 --> 00:13:01,760
it you crash

355
00:13:01,760 --> 00:13:04,959
yeah so this breaks rob

356
00:13:04,959 --> 00:13:07,760
but if you think about it really

357
00:13:07,760 --> 00:13:11,040
arbitrary code execution isn't necessary

358
00:13:11,040 --> 00:13:12,000
for you

359
00:13:12,000 --> 00:13:15,040
right like whatever you would want to do

360
00:13:15,040 --> 00:13:17,680
after your first stage payload all the

361
00:13:17,680 --> 00:13:19,839
functionality is there like the all the

362
00:13:19,839 --> 00:13:22,079
syscall

363
00:13:22,079 --> 00:13:24,160
functions also all the objective-c

364
00:13:24,160 --> 00:13:26,639
methods it's all there so really all you

365
00:13:26,639 --> 00:13:29,360
need to do is figure out how to just

366
00:13:29,360 --> 00:13:31,680
call existing methods

367
00:13:31,680 --> 00:13:32,480
and

368
00:13:32,480 --> 00:13:34,880
this is not too hard with objective c

369
00:13:34,880 --> 00:13:37,839
objective c is kind of very dynamic

370
00:13:37,839 --> 00:13:40,000
and and the runtime around it

371
00:13:40,000 --> 00:13:42,720
and so one of the objects that was very

372
00:13:42,720 --> 00:13:46,079
convenient back then is ns invocation

373
00:13:46,079 --> 00:13:48,240
which essentially represents like a

374
00:13:48,240 --> 00:13:50,720
bound function call or bound method call

375
00:13:50,720 --> 00:13:52,800
so it looks like this uh maybe a bit

376
00:13:52,800 --> 00:13:55,120
weird if you've never seen objective c

377
00:13:55,120 --> 00:13:58,079
uh but this makes an ns invocation then

378
00:13:58,079 --> 00:14:01,600
sets the target object to foo then sets

379
00:14:01,600 --> 00:14:04,399
the selector which is the method to bar

380
00:14:04,399 --> 00:14:06,079
and then if you call invoke on the

381
00:14:06,079 --> 00:14:07,279
invocation

382
00:14:07,279 --> 00:14:09,199
this calls foo dot bar

383
00:14:09,199 --> 00:14:11,440
right and so if you control one of these

384
00:14:11,440 --> 00:14:12,959
objects

385
00:14:12,959 --> 00:14:16,399
you can call whatever you want so

386
00:14:16,399 --> 00:14:17,519
you win

387
00:14:17,519 --> 00:14:19,920
and so this is the full exploit um this

388
00:14:19,920 --> 00:14:22,399
is how it looked like in 2019

389
00:14:22,399 --> 00:14:23,519
um

390
00:14:23,519 --> 00:14:25,760
and uh yeah

391
00:14:25,760 --> 00:14:28,079
so first chapter is over

392
00:14:28,079 --> 00:14:30,000
let's go to the next one so what

393
00:14:30,000 --> 00:14:33,760
happened afterwards we did this 2019

394
00:14:33,760 --> 00:14:35,279
mid-2019

395
00:14:35,279 --> 00:14:37,680
we sent all of this to apple

396
00:14:37,680 --> 00:14:40,079
and they got very busy fixing stuff

397
00:14:40,079 --> 00:14:41,920
right and so this is the next chapter

398
00:14:41,920 --> 00:14:44,959
all the things that apple did in

399
00:14:44,959 --> 00:14:46,160
afterwards

400
00:14:46,160 --> 00:14:47,519
so

401
00:14:47,519 --> 00:14:49,600
one of the very first things and this

402
00:14:49,600 --> 00:14:51,519
happened i think

403
00:14:51,519 --> 00:14:53,360
the only days after we

404
00:14:53,360 --> 00:14:55,680
sent them this stuff

405
00:14:55,680 --> 00:14:58,480
well they fixed the bug of course

406
00:14:58,480 --> 00:15:00,000
but they also did a lot of attack

407
00:15:00,000 --> 00:15:02,000
surface reduction and this is really

408
00:15:02,000 --> 00:15:04,880
powerful because not only does this

409
00:15:04,880 --> 00:15:07,199
like make this bug unexploitable it

410
00:15:07,199 --> 00:15:09,519
makes all other bugs that are like in

411
00:15:09,519 --> 00:15:10,839
the same area

412
00:15:10,839 --> 00:15:13,279
unreachable and so they yeah they

413
00:15:13,279 --> 00:15:15,040
basically blocked a whole bunch of this

414
00:15:15,040 --> 00:15:18,639
ns archiver attack surface in imessage

415
00:15:18,639 --> 00:15:20,639
so that's really nice

416
00:15:20,639 --> 00:15:22,399
let's look at what they what else they

417
00:15:22,399 --> 00:15:24,240
did

418
00:15:24,240 --> 00:15:25,360
one of the

419
00:15:25,360 --> 00:15:27,440
biggest changes is they did some

420
00:15:27,440 --> 00:15:29,199
re-architecturing

421
00:15:29,199 --> 00:15:31,519
for imessage and they introduced

422
00:15:31,519 --> 00:15:33,680
something called blastoir

423
00:15:33,680 --> 00:15:36,639
or messages blast or service

424
00:15:36,639 --> 00:15:39,199
which is essentially a super tightly

425
00:15:39,199 --> 00:15:42,639
sandboxed process that sits in between

426
00:15:42,639 --> 00:15:44,560
the imessage processing and does all the

427
00:15:44,560 --> 00:15:47,120
parsing so i am agent here that's the

428
00:15:47,120 --> 00:15:48,959
demon that

429
00:15:48,959 --> 00:15:51,040
gets the incoming imessage

430
00:15:51,040 --> 00:15:52,240
and this

431
00:15:52,240 --> 00:15:54,639
pretty much directly forwards everything

432
00:15:54,639 --> 00:15:56,000
to blast or

433
00:15:56,000 --> 00:15:58,480
blast or does all the parsing all the

434
00:15:58,480 --> 00:16:02,160
p-list parting the xml parsing the

435
00:16:02,160 --> 00:16:04,720
ns keyed archiver parsing whatever is in

436
00:16:04,720 --> 00:16:07,279
there and then sends the result back to

437
00:16:07,279 --> 00:16:08,800
i am agent

438
00:16:08,800 --> 00:16:10,079
it also has

439
00:16:10,079 --> 00:16:12,000
high level logic implemented in swift

440
00:16:12,000 --> 00:16:13,839
it's kind of nice it's a

441
00:16:13,839 --> 00:16:16,720
bit more of a safe language

442
00:16:16,720 --> 00:16:19,040
but also this

443
00:16:19,040 --> 00:16:22,480
also like besides sandboxing stuff this

444
00:16:22,480 --> 00:16:25,120
also breaks the crash oracle

445
00:16:25,120 --> 00:16:28,959
because um no longer is like the the

446
00:16:28,959 --> 00:16:31,040
sending of the delivery received is

447
00:16:31,040 --> 00:16:32,720
decoupled from the

448
00:16:32,720 --> 00:16:34,959
from the it's not no longer happening in

449
00:16:34,959 --> 00:16:37,839
the process that crashes right so if you

450
00:16:37,839 --> 00:16:40,320
send a crashing payload blast or crashes

451
00:16:40,320 --> 00:16:42,560
but i am agent is the thing sending the

452
00:16:42,560 --> 00:16:43,759
receipt so

453
00:16:43,759 --> 00:16:45,839
this no longer works right

454
00:16:45,839 --> 00:16:48,639
and so they fixed this box here

455
00:16:48,639 --> 00:16:50,880
and this already breaks the

456
00:16:50,880 --> 00:16:52,800
aslr bypass

457
00:16:52,800 --> 00:16:54,639
but that's not all

458
00:16:54,639 --> 00:16:57,120
so the next thing they did is

459
00:16:57,120 --> 00:16:59,360
the constant address of the shared cache

460
00:16:59,360 --> 00:17:01,279
that's gone

461
00:17:01,279 --> 00:17:03,519
they implemented some shared cache

462
00:17:03,519 --> 00:17:05,679
re-sliding it's actually quite

463
00:17:05,679 --> 00:17:08,319
interesting it seems to specifically

464
00:17:08,319 --> 00:17:10,319
look for this attack where you kind of

465
00:17:10,319 --> 00:17:13,119
probe memory around the shared cache to

466
00:17:13,119 --> 00:17:14,559
figure out where it is

467
00:17:14,559 --> 00:17:16,880
and when they detect you doing that they

468
00:17:16,880 --> 00:17:19,760
just re-randomized the shared cache

469
00:17:19,760 --> 00:17:22,880
so this technique is also broken

470
00:17:22,880 --> 00:17:25,679
and also they stopped you

471
00:17:25,679 --> 00:17:26,720
they

472
00:17:26,720 --> 00:17:29,360
try to stop you from

473
00:17:29,360 --> 00:17:31,520
subsequent like crashing a service and

474
00:17:31,520 --> 00:17:33,600
then having it restart

475
00:17:33,600 --> 00:17:35,520
quickly by introducing something called

476
00:17:35,520 --> 00:17:37,679
exponential throttling

477
00:17:37,679 --> 00:17:39,520
um the idea being well if the service

478
00:17:39,520 --> 00:17:41,840
crashes once it restarts 10 seconds

479
00:17:41,840 --> 00:17:42,720
later

480
00:17:42,720 --> 00:17:44,080
crashes again

481
00:17:44,080 --> 00:17:46,640
20 seconds delay crashes again 40

482
00:17:46,640 --> 00:17:49,840
seconds delay this goes up to 20 minutes

483
00:17:49,840 --> 00:17:52,240
and so very quickly you only get one

484
00:17:52,240 --> 00:17:54,480
attempt every 20 minutes and so this

485
00:17:54,480 --> 00:17:56,799
exploit from 2019

486
00:17:56,799 --> 00:17:58,240
wouldn't have taken three to five

487
00:17:58,240 --> 00:17:59,600
minutes it probably would have taken a

488
00:17:59,600 --> 00:18:00,880
few hours

489
00:18:00,880 --> 00:18:04,480
so still not terrible but yeah

490
00:18:04,480 --> 00:18:07,039
okay so this already looks pretty solid

491
00:18:07,039 --> 00:18:09,440
but then they also

492
00:18:09,440 --> 00:18:12,799
try to to fix all of these techniques so

493
00:18:12,799 --> 00:18:15,360
the 2019 exploit it would just

494
00:18:15,360 --> 00:18:18,240
fake uh these ns invocations objects in

495
00:18:18,240 --> 00:18:19,280
memory

496
00:18:19,280 --> 00:18:22,000
uh but they fixed that by by assigning

497
00:18:22,000 --> 00:18:23,600
them with pack so there's a pack

498
00:18:23,600 --> 00:18:26,160
signature in these classes now you can

499
00:18:26,160 --> 00:18:27,440
no longer

500
00:18:27,440 --> 00:18:30,160
just create these things from scratch

501
00:18:30,160 --> 00:18:32,000
they also did some hardening of these ns

502
00:18:32,000 --> 00:18:33,600
invocations so

503
00:18:33,600 --> 00:18:37,280
that also doesn't use doesn't work sorry

504
00:18:37,280 --> 00:18:39,520
right um so this

505
00:18:39,520 --> 00:18:41,280
this looks pretty solid right like kind

506
00:18:41,280 --> 00:18:43,919
of every every aspect of this exploit

507
00:18:43,919 --> 00:18:45,360
with the exception of heap spraying

508
00:18:45,360 --> 00:18:48,000
which i think still works um all of the

509
00:18:48,000 --> 00:18:49,919
other stuff is fixed

510
00:18:49,919 --> 00:18:51,360
and so

511
00:18:51,360 --> 00:18:54,320
you you would expect a new exploit like

512
00:18:54,320 --> 00:18:56,240
it would have to be quite fundamentally

513
00:18:56,240 --> 00:18:59,520
different right all of this is gone

514
00:18:59,520 --> 00:19:02,480
and yeah it was quite fundamentally

515
00:19:02,480 --> 00:19:03,440
different

516
00:19:03,440 --> 00:19:06,080
so last year citizen lab

517
00:19:06,080 --> 00:19:07,360
found

518
00:19:07,360 --> 00:19:08,880
an expert

519
00:19:08,880 --> 00:19:10,720
titled forest entry

520
00:19:10,720 --> 00:19:12,880
which was actually used in the wild an

521
00:19:12,880 --> 00:19:15,360
imessage exploit and they

522
00:19:15,360 --> 00:19:18,720
found traces of it they found

523
00:19:18,720 --> 00:19:20,960
a file containing the exploit basically

524
00:19:20,960 --> 00:19:22,960
and they gave it to us and we looked at

525
00:19:22,960 --> 00:19:25,840
it so we didn't write this exploit but

526
00:19:25,840 --> 00:19:28,720
we analyzed it

527
00:19:30,080 --> 00:19:32,720
again i'll walk you through how it works

528
00:19:32,720 --> 00:19:34,559
again we have to start with the text

529
00:19:34,559 --> 00:19:37,039
surface because the previous one is gone

530
00:19:37,039 --> 00:19:38,480
okay

531
00:19:38,480 --> 00:19:39,760
so

532
00:19:39,760 --> 00:19:41,679
i showed you this image before right

533
00:19:41,679 --> 00:19:43,600
where like blasto came in and how the

534
00:19:43,600 --> 00:19:44,799
parsing works

535
00:19:44,799 --> 00:19:47,039
it's not like it was obviously a

536
00:19:47,039 --> 00:19:49,600
simplification uh one of the other

537
00:19:49,600 --> 00:19:51,360
things that happens is there is another

538
00:19:51,360 --> 00:19:54,720
process called i am transcoder agent

539
00:19:54,720 --> 00:19:55,679
which

540
00:19:55,679 --> 00:19:58,880
does some image transcoding for example

541
00:19:58,880 --> 00:20:02,080
so this one is important

542
00:20:02,159 --> 00:20:03,840
now

543
00:20:03,840 --> 00:20:06,720
what imessage wanted to do is when you

544
00:20:06,720 --> 00:20:08,880
send a gif file so like an animated

545
00:20:08,880 --> 00:20:10,880
picture

546
00:20:10,880 --> 00:20:12,799
what they wanted to make sure is that it

547
00:20:12,799 --> 00:20:14,000
effectively

548
00:20:14,000 --> 00:20:16,240
looped forever

549
00:20:16,240 --> 00:20:18,320
right so it wouldn't stop like repeating

550
00:20:18,320 --> 00:20:20,799
itself so here you just saw the left

551
00:20:20,799 --> 00:20:23,280
image just like repeated once and the

552
00:20:23,280 --> 00:20:26,960
right image keeps spinning and so on um

553
00:20:26,960 --> 00:20:29,679
now in the in the gif file format the

554
00:20:29,679 --> 00:20:32,000
way you say this this is supposed to

555
00:20:32,000 --> 00:20:33,280
loop forever

556
00:20:33,280 --> 00:20:35,840
is to set some loop counter to zero

557
00:20:35,840 --> 00:20:38,080
right so you see kind of a hex dump of

558
00:20:38,080 --> 00:20:40,880
these two files the only difference is

559
00:20:40,880 --> 00:20:42,799
one of them has a zero which means

560
00:20:42,799 --> 00:20:45,440
infinite repeats and one has a one which

561
00:20:45,440 --> 00:20:48,159
means one repeat

562
00:20:48,159 --> 00:20:49,840
so that's what they wanted to implement

563
00:20:49,840 --> 00:20:52,159
on the receiver side so you get a gif

564
00:20:52,159 --> 00:20:55,039
incoming they would try to set this loop

565
00:20:55,039 --> 00:20:57,280
count to zero

566
00:20:57,280 --> 00:21:00,000
the way they did it is um

567
00:21:00,000 --> 00:21:02,159
there's a helper function that would be

568
00:21:02,159 --> 00:21:05,360
called by im agent when when it like

569
00:21:05,360 --> 00:21:07,120
downloaded those attachments or those

570
00:21:07,120 --> 00:21:09,200
images it would call a function called

571
00:21:09,200 --> 00:21:12,480
copy jiff from pass to destination

572
00:21:12,480 --> 00:21:14,159
and this actually

573
00:21:14,159 --> 00:21:15,840
ended up

574
00:21:15,840 --> 00:21:18,559
running in this im transcoder agent

575
00:21:18,559 --> 00:21:21,200
and this transcoder agent it would call

576
00:21:21,200 --> 00:21:23,280
a method like something read file

577
00:21:23,280 --> 00:21:25,120
properties blah blah blah

578
00:21:25,120 --> 00:21:27,600
with updated loop count

579
00:21:27,600 --> 00:21:30,480
and then gave it a loop count of zero

580
00:21:30,480 --> 00:21:32,240
right and so

581
00:21:32,240 --> 00:21:34,400
this kind of seems simple like i mean

582
00:21:34,400 --> 00:21:36,880
just you know read the file set the loop

583
00:21:36,880 --> 00:21:39,600
count to zero write it back

584
00:21:39,600 --> 00:21:43,039
but funnily or maybe not so funny

585
00:21:43,039 --> 00:21:45,200
this is an actual stack trace from the

586
00:21:45,200 --> 00:21:48,480
exploit crashing so from it failing

587
00:21:48,480 --> 00:21:49,520
and

588
00:21:49,520 --> 00:21:51,840
well you see it starts in imessage it

589
00:21:51,840 --> 00:21:54,240
starts exactly in this copy gif from

590
00:21:54,240 --> 00:21:56,320
from file and so on goes to the read

591
00:21:56,320 --> 00:21:59,440
file properties it then goes into image

592
00:21:59,440 --> 00:22:00,720
i o

593
00:22:00,720 --> 00:22:04,640
which is their image parsing library

594
00:22:04,640 --> 00:22:06,880
and then it goes into core graphics

595
00:22:06,880 --> 00:22:08,400
right and you kind of see it's like

596
00:22:08,400 --> 00:22:11,520
starting to do pdf stuff

597
00:22:11,520 --> 00:22:13,840
why is it doing pdf stuff

598
00:22:13,840 --> 00:22:15,280
and then it's going into something

599
00:22:15,280 --> 00:22:18,000
called jbig2 which is a compression

600
00:22:18,000 --> 00:22:20,960
format used in pdf so what you see here

601
00:22:20,960 --> 00:22:22,559
is that this

602
00:22:22,559 --> 00:22:24,960
seemingly harmless

603
00:22:24,960 --> 00:22:27,679
call of like just you know take this gif

604
00:22:27,679 --> 00:22:29,919
make the loop count infinite this ended

605
00:22:29,919 --> 00:22:33,360
up doing pdf parsing

606
00:22:33,360 --> 00:22:36,159
um so it's kind of like

607
00:22:36,159 --> 00:22:38,799
iceberg um attack surface right like you

608
00:22:38,799 --> 00:22:41,600
see the top just this top bit of like ah

609
00:22:41,600 --> 00:22:43,520
this is just a bit of a you know file

610
00:22:43,520 --> 00:22:45,600
copying no no

611
00:22:45,600 --> 00:22:47,760
pdf parsing all kinds of stuff is

612
00:22:47,760 --> 00:22:50,880
happening under the surface um

613
00:22:50,880 --> 00:22:52,559
how much stuff is happening under the

614
00:22:52,559 --> 00:22:55,520
surface so here's a list of all the

615
00:22:55,520 --> 00:22:57,679
supported file formats

616
00:22:57,679 --> 00:23:00,559
that image io will will parse for you

617
00:23:00,559 --> 00:23:02,960
right and so the the trick here is that

618
00:23:02,960 --> 00:23:05,440
i mean the the reason this happens is

619
00:23:05,440 --> 00:23:08,320
because image i o it tries to auto

620
00:23:08,320 --> 00:23:11,039
detect the file format so even though

621
00:23:11,039 --> 00:23:14,480
you send something ending with dot gif

622
00:23:14,480 --> 00:23:16,720
image io will look at the header and

623
00:23:16,720 --> 00:23:19,440
determine ah no this is a pdf i know how

624
00:23:19,440 --> 00:23:20,159
to

625
00:23:20,159 --> 00:23:22,559
work with this right um

626
00:23:22,559 --> 00:23:23,760
so yeah this list may be a bit

627
00:23:23,760 --> 00:23:26,799
surprising right i mean you see the

628
00:23:26,799 --> 00:23:30,240
i guess typical image formats jpeg png

629
00:23:30,240 --> 00:23:32,000
and stuff um

630
00:23:32,000 --> 00:23:34,159
but but just for for fun

631
00:23:34,159 --> 00:23:36,159
raise your hands if you know what dot

632
00:23:36,159 --> 00:23:39,360
psd is the top top right okay it's

633
00:23:39,360 --> 00:23:42,320
pretty good so it's a photoshop file

634
00:23:42,320 --> 00:23:43,600
um

635
00:23:43,600 --> 00:23:46,080
raise your hands if you know what astc

636
00:23:46,080 --> 00:23:47,760
is

637
00:23:47,760 --> 00:23:49,840
okay there's like one person

638
00:23:49,840 --> 00:23:52,960
adaptive scalable texture compression

639
00:23:52,960 --> 00:23:55,039
i don't even know um

640
00:23:55,039 --> 00:23:59,120
anyone know what mpo is

641
00:23:59,440 --> 00:24:02,240
no okay so i mean i didn't either it

642
00:24:02,240 --> 00:24:04,480
apparently it's some kind of image

643
00:24:04,480 --> 00:24:07,679
format used on nintendo 3ds where you

644
00:24:07,679 --> 00:24:09,840
could like because it has two cameras

645
00:24:09,840 --> 00:24:11,520
you can take like some kind of

646
00:24:11,520 --> 00:24:14,720
stereoscopic image and

647
00:24:14,720 --> 00:24:15,760
yeah

648
00:24:15,760 --> 00:24:16,799
i don't know

649
00:24:16,799 --> 00:24:19,520
so it's it's pretty crazy um

650
00:24:19,520 --> 00:24:21,039
but the point i want to make here is

651
00:24:21,039 --> 00:24:22,080
this

652
00:24:22,080 --> 00:24:24,640
this is not a like apple specific

653
00:24:24,640 --> 00:24:26,880
problem right like this is how we

654
00:24:26,880 --> 00:24:29,600
develop software in a way right like if

655
00:24:29,600 --> 00:24:30,559
you are

656
00:24:30,559 --> 00:24:33,120
writing a library you want that library

657
00:24:33,120 --> 00:24:35,679
to be as useful as possible and so if

658
00:24:35,679 --> 00:24:37,200
you're writing an image library that

659
00:24:37,200 --> 00:24:39,360
means you want to support as many

660
00:24:39,360 --> 00:24:42,240
formats as possible for your users to be

661
00:24:42,240 --> 00:24:43,919
really useful

662
00:24:43,919 --> 00:24:46,720
but then this just ends up

663
00:24:46,720 --> 00:24:48,960
being this gigantic attack surface of

664
00:24:48,960 --> 00:24:50,799
like these dozens of

665
00:24:50,799 --> 00:24:53,600
of file formats right

666
00:24:53,600 --> 00:24:54,400
okay

667
00:24:54,400 --> 00:24:56,559
so um

668
00:24:56,559 --> 00:24:59,039
anyway back to jbc2 right so that's the

669
00:24:59,039 --> 00:25:00,880
compression

670
00:25:00,880 --> 00:25:05,039
code in in pdf um this is the bug that

671
00:25:05,039 --> 00:25:08,480
was ultimately exploited it's not really

672
00:25:08,480 --> 00:25:10,400
that interesting it's kind of a standard

673
00:25:10,400 --> 00:25:12,640
heap buffer overflow coming from an

674
00:25:12,640 --> 00:25:15,760
integer overflow so

675
00:25:15,760 --> 00:25:18,960
you have this num num symbols integer

676
00:25:18,960 --> 00:25:21,200
you want to allocate some buffer to hold

677
00:25:21,200 --> 00:25:23,360
all the i don't know symbol dictionaries

678
00:25:23,360 --> 00:25:24,559
also

679
00:25:24,559 --> 00:25:26,880
so you first figure out how many are

680
00:25:26,880 --> 00:25:28,799
there so you add up all the

681
00:25:28,799 --> 00:25:30,159
dictionaries

682
00:25:30,159 --> 00:25:32,320
this thing ends up overflowing from like

683
00:25:32,320 --> 00:25:35,360
4 billion to 10 or whatever

684
00:25:35,360 --> 00:25:37,600
you allocate a buffer for 10

685
00:25:37,600 --> 00:25:39,360
simple dictionaries

686
00:25:39,360 --> 00:25:41,440
and then you copy 4 billion into it

687
00:25:41,440 --> 00:25:42,880
right so that

688
00:25:42,880 --> 00:25:46,240
of course corrupts memory

689
00:25:47,279 --> 00:25:48,960
so we are here again

690
00:25:48,960 --> 00:25:51,360
looks kind of familiar right we have a

691
00:25:51,360 --> 00:25:53,679
new attack surface we have a different

692
00:25:53,679 --> 00:25:54,640
bug

693
00:25:54,640 --> 00:25:56,400
we know what we're going to end up with

694
00:25:56,400 --> 00:25:58,240
or we're going to end up in an im

695
00:25:58,240 --> 00:26:00,080
transcoder agent

696
00:26:00,080 --> 00:26:01,840
if we can exploit this

697
00:26:01,840 --> 00:26:04,799
and again we have to bypass aslr

698
00:26:04,799 --> 00:26:06,240
and this time we have to do different

699
00:26:06,240 --> 00:26:08,640
thing because the last

700
00:26:08,640 --> 00:26:12,720
approach was completely fixed

701
00:26:12,720 --> 00:26:14,720
so the first thing we're going to do is

702
00:26:14,720 --> 00:26:16,320
we will

703
00:26:16,320 --> 00:26:18,799
what we just call unbounding here will

704
00:26:18,799 --> 00:26:22,240
make more memory available to jbc2

705
00:26:22,240 --> 00:26:25,440
so jbc2 it operates on bitmaps

706
00:26:25,440 --> 00:26:27,679
you can supply operations to perform on

707
00:26:27,679 --> 00:26:29,919
bitmaps we'll see that in a second

708
00:26:29,919 --> 00:26:33,360
and in memory a bitmap looks like this

709
00:26:33,360 --> 00:26:34,640
v table

710
00:26:34,640 --> 00:26:36,640
so on so on and then there's a width and

711
00:26:36,640 --> 00:26:39,600
a height right and so if you just

712
00:26:39,600 --> 00:26:41,440
overflow

713
00:26:41,440 --> 00:26:43,840
corrupt one of these bitmap objects with

714
00:26:43,840 --> 00:26:45,760
this heat buffer overflow you end up

715
00:26:45,760 --> 00:26:47,520
corrupting the width

716
00:26:47,520 --> 00:26:49,520
now the bitmap looks really large and

717
00:26:49,520 --> 00:26:51,360
you can perform your operations on kind

718
00:26:51,360 --> 00:26:53,279
of all of memory

719
00:26:53,279 --> 00:26:56,000
this is a fairly standard exploitation

720
00:26:56,000 --> 00:26:56,960
trick

721
00:26:56,960 --> 00:26:58,960
just make some buffer look really big

722
00:26:58,960 --> 00:27:01,919
and then use it

723
00:27:02,640 --> 00:27:04,240
so the next thing is we need to

724
00:27:04,240 --> 00:27:08,960
understand a bit more about what jbc2 is

725
00:27:08,960 --> 00:27:11,279
so it's a compression algorithm designed

726
00:27:11,279 --> 00:27:13,679
originally for i believe

727
00:27:13,679 --> 00:27:16,400
kind of black and white scans of

728
00:27:16,400 --> 00:27:18,080
documents

729
00:27:18,080 --> 00:27:20,080
and one thing it can do it it can figure

730
00:27:20,080 --> 00:27:23,360
out similar looking pixel patterns like

731
00:27:23,360 --> 00:27:26,000
it might identify all of these e's

732
00:27:26,000 --> 00:27:28,559
as being similar in this document

733
00:27:28,559 --> 00:27:30,799
and it can group them together and what

734
00:27:30,799 --> 00:27:32,159
it can then do

735
00:27:32,159 --> 00:27:35,039
is just take one representative

736
00:27:35,039 --> 00:27:37,440
like the one one e

737
00:27:37,440 --> 00:27:39,679
and replace all of the other e's in the

738
00:27:39,679 --> 00:27:41,360
document with this one

739
00:27:41,360 --> 00:27:43,679
right and so now you no longer need to

740
00:27:43,679 --> 00:27:47,520
store six e's you just need to store one

741
00:27:47,520 --> 00:27:49,039
that's kind of neat

742
00:27:49,039 --> 00:27:50,960
except that this can go horribly wrong

743
00:27:50,960 --> 00:27:52,960
if it like replaces one character with

744
00:27:52,960 --> 00:27:55,360
another that looks a bit similar and i

745
00:27:55,360 --> 00:27:58,480
think this happens what happened

746
00:27:58,480 --> 00:28:01,440
and so the way you can fix that problem

747
00:28:01,440 --> 00:28:04,159
is by uh just kind of computing the

748
00:28:04,159 --> 00:28:05,440
difference

749
00:28:05,440 --> 00:28:07,039
between the

750
00:28:07,039 --> 00:28:09,919
reference or the substituted e and the

751
00:28:09,919 --> 00:28:12,960
original e right so here

752
00:28:12,960 --> 00:28:15,200
left e that that's the reference one

753
00:28:15,200 --> 00:28:17,200
that's going to substitute the others

754
00:28:17,200 --> 00:28:18,880
the middle one is the

755
00:28:18,880 --> 00:28:21,279
real e so you compute the difference you

756
00:28:21,279 --> 00:28:23,600
store the difference which has a less

757
00:28:23,600 --> 00:28:25,760
entropy so it can be encoded more

758
00:28:25,760 --> 00:28:28,240
efficiently and then when you decode or

759
00:28:28,240 --> 00:28:30,799
decompress the stream

760
00:28:30,799 --> 00:28:33,279
you apply the difference again to the

761
00:28:33,279 --> 00:28:34,799
substituted

762
00:28:34,799 --> 00:28:36,159
one

763
00:28:36,159 --> 00:28:38,880
so in this case this just needs an x or

764
00:28:38,880 --> 00:28:40,559
operation

765
00:28:40,559 --> 00:28:42,720
xor is not the only one

766
00:28:42,720 --> 00:28:45,600
j big two supports these four kind of

767
00:28:45,600 --> 00:28:47,120
fundamental

768
00:28:47,120 --> 00:28:52,960
um logic operations and or x or x nor

769
00:28:52,960 --> 00:28:54,720
um

770
00:28:54,720 --> 00:28:56,399
and uh well

771
00:28:56,399 --> 00:28:58,320
if you have these four gates you can

772
00:28:58,320 --> 00:29:00,559
build other gates right like if you for

773
00:29:00,559 --> 00:29:02,559
example combine an and

774
00:29:02,559 --> 00:29:05,760
with an x or with a constant of one that

775
00:29:05,760 --> 00:29:08,159
gives gives you a non-gate right the the

776
00:29:08,159 --> 00:29:10,720
xor is a negation so this makes a

777
00:29:10,720 --> 00:29:13,760
non-gate and now will the non-gate

778
00:29:13,760 --> 00:29:16,240
that lets you build all kinds of stuff

779
00:29:16,240 --> 00:29:18,320
like you can kind of build every circuit

780
00:29:18,320 --> 00:29:20,399
from none there's a website where you

781
00:29:20,399 --> 00:29:21,679
can go to

782
00:29:21,679 --> 00:29:24,320
where they teach you uh how to

783
00:29:24,320 --> 00:29:26,399
how to build like full full-scale

784
00:29:26,399 --> 00:29:28,799
computer just from non-gates and then

785
00:29:28,799 --> 00:29:30,559
write tetris for it

786
00:29:30,559 --> 00:29:32,480
what they what they don't tell you in

787
00:29:32,480 --> 00:29:34,559
this course but what i can tell you is

788
00:29:34,559 --> 00:29:35,840
you can also

789
00:29:35,840 --> 00:29:38,559
take non-gates and like build an im

790
00:29:38,559 --> 00:29:41,600
transcoder sandbox uh escape from it

791
00:29:41,600 --> 00:29:42,880
yeah

792
00:29:42,880 --> 00:29:45,360
so nand is really powerful um

793
00:29:45,360 --> 00:29:47,440
this here is an actual gate that was

794
00:29:47,440 --> 00:29:50,480
used in the exploit so this is um

795
00:29:50,480 --> 00:29:52,320
an adder

796
00:29:52,320 --> 00:29:53,440
built

797
00:29:53,440 --> 00:29:56,480
right from these basic circuits um and

798
00:29:56,480 --> 00:29:59,600
so what this now lets you do is

799
00:29:59,600 --> 00:30:01,760
because we have unbounded the jbc2

800
00:30:01,760 --> 00:30:04,559
stream right we can now add

801
00:30:04,559 --> 00:30:07,120
arbitrary stuff in memory together and

802
00:30:07,120 --> 00:30:09,919
like perform logical operations on other

803
00:30:09,919 --> 00:30:12,480
parts of the process memory

804
00:30:12,480 --> 00:30:14,960
so how does this help us with aslr

805
00:30:14,960 --> 00:30:17,919
let's go back to this slide

806
00:30:17,919 --> 00:30:20,080
remember from before

807
00:30:20,080 --> 00:30:22,000
before we needed this communication

808
00:30:22,000 --> 00:30:23,600
channel right because

809
00:30:23,600 --> 00:30:25,919
the exploit logic was running

810
00:30:25,919 --> 00:30:28,080
on the server on the attacker's machine

811
00:30:28,080 --> 00:30:28,799
and

812
00:30:28,799 --> 00:30:31,279
the target process was on the device but

813
00:30:31,279 --> 00:30:34,799
now with this um jbig2 like virtual

814
00:30:34,799 --> 00:30:36,559
machine thing

815
00:30:36,559 --> 00:30:38,559
really what we're doing is we're now

816
00:30:38,559 --> 00:30:41,200
running the export logic also inside the

817
00:30:41,200 --> 00:30:43,919
target process right it's really quite

818
00:30:43,919 --> 00:30:46,399
similar to the browser exploit

819
00:30:46,399 --> 00:30:48,159
where you would write all of the expert

820
00:30:48,159 --> 00:30:50,799
logic in javascript and run it in the

821
00:30:50,799 --> 00:30:53,679
attack process and here we're

822
00:30:53,679 --> 00:30:55,039
you know we're not using javascript

823
00:30:55,039 --> 00:30:57,120
we're using jpeg 2 virtual machine

824
00:30:57,120 --> 00:30:59,279
something something but it's effectively

825
00:30:59,279 --> 00:31:01,760
the same thing right and so this means

826
00:31:01,760 --> 00:31:03,919
we no longer need this communication

827
00:31:03,919 --> 00:31:06,240
channel

828
00:31:06,399 --> 00:31:09,279
yeah so here here's where we're at

829
00:31:09,279 --> 00:31:11,600
we have the attack server and the bug

830
00:31:11,600 --> 00:31:13,840
and we break aslr

831
00:31:13,840 --> 00:31:16,080
essentially by you know implementing a

832
00:31:16,080 --> 00:31:19,519
mini cpu from j big two compression

833
00:31:19,519 --> 00:31:20,880
operators

834
00:31:20,880 --> 00:31:24,000
yeah it's definitely not like a weekend

835
00:31:24,000 --> 00:31:26,159
ctf project building this thing so

836
00:31:26,159 --> 00:31:28,640
that's quite

837
00:31:28,640 --> 00:31:32,080
i think it's quite a lot of effort

838
00:31:32,080 --> 00:31:34,480
so what's left is the pack bypass i'm

839
00:31:34,480 --> 00:31:36,320
just going to show this slide

840
00:31:36,320 --> 00:31:38,159
i mentioned it before like objective c

841
00:31:38,159 --> 00:31:40,640
is really quite dynamic and this runtime

842
00:31:40,640 --> 00:31:41,519
it

843
00:31:41,519 --> 00:31:43,279
like really lets you do a lot of things

844
00:31:43,279 --> 00:31:45,440
like you can add methods to existing

845
00:31:45,440 --> 00:31:47,360
classes at runtime

846
00:31:47,360 --> 00:31:49,360
stuff like this

847
00:31:49,360 --> 00:31:51,360
and here's another class that you have

848
00:31:51,360 --> 00:31:53,760
available called ns expression and if

849
00:31:53,760 --> 00:31:55,279
you just kind of scroll down in the

850
00:31:55,279 --> 00:31:58,399
documentation it literally says

851
00:31:58,399 --> 00:32:00,720
you know since mac os whatever function

852
00:32:00,720 --> 00:32:02,960
expressions also support arbitrary

853
00:32:02,960 --> 00:32:05,600
method invocations right i mean

854
00:32:05,600 --> 00:32:08,799
that's all we've been looking for um so

855
00:32:08,799 --> 00:32:11,039
this is a kind of

856
00:32:11,039 --> 00:32:12,880
yeah easy substitute for the ns

857
00:32:12,880 --> 00:32:15,279
invocation stuff this is again how you

858
00:32:15,279 --> 00:32:16,720
can call

859
00:32:16,720 --> 00:32:19,679
arbitrary stuff

860
00:32:20,559 --> 00:32:24,480
this is how the final thing looks like

861
00:32:24,640 --> 00:32:26,399
so yeah we're creating these ns

862
00:32:26,399 --> 00:32:27,519
expressions

863
00:32:27,519 --> 00:32:29,760
remember we we can't fake them we can't

864
00:32:29,760 --> 00:32:31,919
just create our own ns expressions in

865
00:32:31,919 --> 00:32:34,799
memory anymore because apple added the

866
00:32:34,799 --> 00:32:37,039
signature to objects you can make your

867
00:32:37,039 --> 00:32:37,840
own

868
00:32:37,840 --> 00:32:39,440
what you can still do and what this

869
00:32:39,440 --> 00:32:42,399
exploit does is it just deserializes

870
00:32:42,399 --> 00:32:46,480
them so remember the ns archive it can

871
00:32:46,480 --> 00:32:49,360
decode arbitrary objects

872
00:32:49,360 --> 00:32:51,519
so if you can

873
00:32:51,519 --> 00:32:54,080
put pass input to one of these decoders

874
00:32:54,080 --> 00:32:56,960
you can just create every object you

875
00:32:56,960 --> 00:32:58,399
want right you can like

876
00:32:58,399 --> 00:33:01,039
deserialize ns expressions it's it's

877
00:33:01,039 --> 00:33:03,519
going to work so that's how this

878
00:33:03,519 --> 00:33:06,240
expert got this object

879
00:33:06,240 --> 00:33:08,080
right and yeah here's the

880
00:33:08,080 --> 00:33:10,880
kind of end of end of chapter three

881
00:33:10,880 --> 00:33:14,000
the final exploit flow um

882
00:33:14,000 --> 00:33:16,799
so i think the the story continues

883
00:33:16,799 --> 00:33:19,600
i i did took take a brief look yesterday

884
00:33:19,600 --> 00:33:21,840
and from what i can tell apple has

885
00:33:21,840 --> 00:33:23,760
already again done some attack surface

886
00:33:23,760 --> 00:33:27,200
reduction and removed a lot of this like

887
00:33:27,200 --> 00:33:28,799
this copied gif stuff seemed to be

888
00:33:28,799 --> 00:33:30,880
completely gone

889
00:33:30,880 --> 00:33:33,360
so i expect there to be more changes

890
00:33:33,360 --> 00:33:36,240
will be interesting to see

891
00:33:36,240 --> 00:33:38,880
right so let's go to the conclusion

892
00:33:38,880 --> 00:33:40,799
i think there are kind of two main

893
00:33:40,799 --> 00:33:43,600
points that i want to make um the first

894
00:33:43,600 --> 00:33:47,039
point is yeah if you do make the right

895
00:33:47,039 --> 00:33:49,279
hardenings right mitigations they can

896
00:33:49,279 --> 00:33:52,559
make a big difference right here we saw

897
00:33:52,559 --> 00:33:55,360
that the old 2019 exploited was

898
00:33:55,360 --> 00:33:57,440
kind of fundamentally broken

899
00:33:57,440 --> 00:33:59,679
um the new exploit had to be written

900
00:33:59,679 --> 00:34:01,600
from scratch go a completely different

901
00:34:01,600 --> 00:34:02,559
route

902
00:34:02,559 --> 00:34:04,559
if you compare that with typical browser

903
00:34:04,559 --> 00:34:07,039
exploits they kind of all look the same

904
00:34:07,039 --> 00:34:08,719
right they will all pretty much do the

905
00:34:08,719 --> 00:34:10,719
same thing and they have been doing that

906
00:34:10,719 --> 00:34:12,560
for the last couple of years

907
00:34:12,560 --> 00:34:14,079
this one here is like completely

908
00:34:14,079 --> 00:34:16,879
different completely different thing

909
00:34:16,879 --> 00:34:18,639
on the other hand right

910
00:34:18,639 --> 00:34:20,399
the fact that this

911
00:34:20,399 --> 00:34:23,040
second export was possible at all um

912
00:34:23,040 --> 00:34:24,000
it's

913
00:34:24,000 --> 00:34:26,000
good to keep in mind i think

914
00:34:26,000 --> 00:34:27,918
we should assume that if you have memory

915
00:34:27,918 --> 00:34:29,679
corruption

916
00:34:29,679 --> 00:34:31,679
it's probably still exploitable in some

917
00:34:31,679 --> 00:34:34,159
way i mean when we did this research

918
00:34:34,159 --> 00:34:36,719
back in 2019 i think many people were

919
00:34:36,719 --> 00:34:38,800
saying that these kinds of bugs in

920
00:34:38,800 --> 00:34:41,440
imessage they can't be exploitable

921
00:34:41,440 --> 00:34:43,359
but yeah now we've seen it at least two

922
00:34:43,359 --> 00:34:44,960
times so

923
00:34:44,960 --> 00:34:47,040
it's really like memory corruption is

924
00:34:47,040 --> 00:34:49,918
really still very powerful

925
00:34:49,918 --> 00:34:52,399
maybe two smaller points here so i think

926
00:34:52,399 --> 00:34:54,560
sometimes can be quite hard to reason

927
00:34:54,560 --> 00:34:55,679
about

928
00:34:55,679 --> 00:34:58,720
where a specific piece of code runs so

929
00:34:58,720 --> 00:35:00,880
we've seen this here we we had this

930
00:35:00,880 --> 00:35:02,640
blast or process

931
00:35:02,640 --> 00:35:04,880
but somehow this parsing still ended up

932
00:35:04,880 --> 00:35:07,520
being an im transcoder agent

933
00:35:07,520 --> 00:35:10,640
because of yeah whatever the gif gif

934
00:35:10,640 --> 00:35:13,119
transformation stuff um

935
00:35:13,119 --> 00:35:16,160
it was also similar in 2019 where one of

936
00:35:16,160 --> 00:35:17,839
these payloads was decoded in

937
00:35:17,839 --> 00:35:20,640
springboard which seemed really weird

938
00:35:20,640 --> 00:35:23,200
um because it's on sandbox this is maybe

939
00:35:23,200 --> 00:35:25,280
one interesting thing and the other is

940
00:35:25,280 --> 00:35:27,040
like look out for this hidden attack

941
00:35:27,040 --> 00:35:30,400
surface right like this it looks very

942
00:35:30,400 --> 00:35:32,480
you know not not dangerous like just

943
00:35:32,480 --> 00:35:34,960
this copy gif thing but then it throws

944
00:35:34,960 --> 00:35:37,440
you into this huge sea of

945
00:35:37,440 --> 00:35:39,200
of like image formats that it will

946
00:35:39,200 --> 00:35:40,560
suddenly parse

947
00:35:40,560 --> 00:35:42,560
so yeah

948
00:35:42,560 --> 00:35:43,680
yeah and that's the end of my

949
00:35:43,680 --> 00:35:44,880
presentation

950
00:35:44,880 --> 00:35:47,680
thank you all for for listening

951
00:35:47,680 --> 00:35:50,160
i guess

952
00:35:57,520 --> 00:35:59,440
i guess we do have four minutes if there

953
00:35:59,440 --> 00:36:01,920
are any questions but otherwise i'll be

954
00:36:01,920 --> 00:36:02,880
around

955
00:36:02,880 --> 00:36:05,839
feel free to find me ask me whatever's

956
00:36:05,839 --> 00:36:08,320
on your mind

957
00:36:08,640 --> 00:36:11,640
thanks

958
00:36:16,760 --> 00:36:19,440
[Music]

959
00:36:19,440 --> 00:36:21,520
you

