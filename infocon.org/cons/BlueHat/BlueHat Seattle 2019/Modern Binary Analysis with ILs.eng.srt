1
00:00:01,040 --> 00:00:05,210
[Applause]

2
00:00:02,510 --> 00:00:07,000
please welcome to the stage Jordan wines

3
00:00:05,210 --> 00:00:11,219
and Peter Lafosse

4
00:00:07,000 --> 00:00:13,270
[Music]

5
00:00:11,220 --> 00:00:18,410
[Applause]

6
00:00:13,270 --> 00:00:25,070
hello like to thank Elvis for waking

7
00:00:18,410 --> 00:00:28,300
everyone up where so we are going to be

8
00:00:25,070 --> 00:00:32,119
talking about bonhart binary analysis

9
00:00:28,300 --> 00:00:35,500
with intermediate languages so a bit

10
00:00:32,119 --> 00:00:39,530
about us first I am Peter Lafosse

11
00:00:35,500 --> 00:00:41,570
co-founder of vector 35 and longtime

12
00:00:39,530 --> 00:00:45,440
reverse engineer from vulnerability

13
00:00:41,570 --> 00:00:50,059
researcher and now I'm the program

14
00:00:45,440 --> 00:00:51,829
manager for binary ninja and this is I'm

15
00:00:50,059 --> 00:00:54,589
Jordan wines well the other cofounders

16
00:00:51,829 --> 00:00:56,210
of vector 35 and we're not lawyers I

17
00:00:54,590 --> 00:00:57,410
know we put lasers on but we just

18
00:00:56,210 --> 00:00:59,320
thought we'd mix it up a little bit we

19
00:00:57,410 --> 00:01:01,699
believe it or not we're actually hackers

20
00:00:59,320 --> 00:01:03,559
pretending to be developers and run a

21
00:01:01,699 --> 00:01:07,850
company making reverse engineering tools

22
00:01:03,559 --> 00:01:09,850
yeah so how about all of you everyone

23
00:01:07,850 --> 00:01:12,619
wake up put your hands in the air

24
00:01:09,850 --> 00:01:15,919
everybody everybody there you go all

25
00:01:12,620 --> 00:01:18,290
right and keep them up if you have ever

26
00:01:15,920 --> 00:01:20,210
done any binary reverse engineering I

27
00:01:18,290 --> 00:01:22,720
know there's a big group over here that

28
00:01:20,210 --> 00:01:27,410
should be doing a lot of it yeah I see

29
00:01:22,720 --> 00:01:29,420
if you use the D compiler have you ever

30
00:01:27,410 --> 00:01:32,720
written any code to automate reverse

31
00:01:29,420 --> 00:01:35,750
engineering less hands have you ever

32
00:01:32,720 --> 00:01:39,530
done it on an intermediate language okay

33
00:01:35,750 --> 00:01:42,320
lessons and have used our an IL for any

34
00:01:39,530 --> 00:01:45,350
kind of other compilation tasks LLVM

35
00:01:42,320 --> 00:01:47,059
pass or anything like that and have you

36
00:01:45,350 --> 00:01:49,429
written a paper that published some

37
00:01:47,060 --> 00:01:53,720
research leveraging iOS

38
00:01:49,430 --> 00:01:56,740
I don't see any but you are come meet us

39
00:01:53,720 --> 00:01:59,660
afterwards we'd like to talk alright so

40
00:01:56,740 --> 00:02:02,330
what our talk about is we're gonna first

41
00:01:59,660 --> 00:02:05,600
kind of talk about what binary analysis

42
00:02:02,330 --> 00:02:09,139
actually is then we're gonna go into why

43
00:02:05,600 --> 00:02:12,260
you would actually want to use a and

44
00:02:09,139 --> 00:02:15,670
then Jordan's gonna go over what the

45
00:02:12,260 --> 00:02:21,350
existing kind of state-of-the-art is and

46
00:02:15,670 --> 00:02:25,670
we're gonna do some demos so what

47
00:02:21,350 --> 00:02:29,459
actually is binary analysis well for

48
00:02:25,670 --> 00:02:32,790
remember how compilers work we start

49
00:02:29,460 --> 00:02:34,230
with some source code we are going to

50
00:02:32,790 --> 00:02:37,799
run it through some kind of parser to

51
00:02:34,230 --> 00:02:39,959
produce an abstract syntax tree that's

52
00:02:37,800 --> 00:02:43,050
going to be then converted into some

53
00:02:39,960 --> 00:02:45,420
kind of intermediate representation and

54
00:02:43,050 --> 00:02:48,090
then we do our passes on this

55
00:02:45,420 --> 00:02:51,839
intermediate representation to produce

56
00:02:48,090 --> 00:02:53,790
an optimized form of the the code and

57
00:02:51,840 --> 00:02:59,130
then it's going to be emitted to a

58
00:02:53,790 --> 00:03:01,200
machine code whatever the target is so D

59
00:02:59,130 --> 00:03:05,060
compilation is kind of the opposite of

60
00:03:01,200 --> 00:03:08,910
this it's the process of lifting these

61
00:03:05,060 --> 00:03:11,580
the analysis or the the native

62
00:03:08,910 --> 00:03:15,930
architecture to a representation that's

63
00:03:11,580 --> 00:03:20,610
easier to reason over so the purposes of

64
00:03:15,930 --> 00:03:22,950
our talk everything we've talked about

65
00:03:20,610 --> 00:03:25,160
so far could be static or dynamic but

66
00:03:22,950 --> 00:03:31,890
for our talk we're gonna really focus on

67
00:03:25,160 --> 00:03:33,540
just static binary analysis so one thing

68
00:03:31,890 --> 00:03:37,290
everyone should be aware of this binary

69
00:03:33,540 --> 00:03:40,140
analysis is not source analysis these

70
00:03:37,290 --> 00:03:43,230
are a lot of people try to combine these

71
00:03:40,140 --> 00:03:48,320
two and say that they're kind of the

72
00:03:43,230 --> 00:03:52,410
same thing and you can't really do that

73
00:03:48,320 --> 00:03:54,840
there is a lot of intricacies involved

74
00:03:52,410 --> 00:03:57,720
in binary analysis that you don't have

75
00:03:54,840 --> 00:04:01,620
to do with source analysis and vice

76
00:03:57,720 --> 00:04:04,410
versa in fact the the problem here is

77
00:04:01,620 --> 00:04:09,180
that compilers they mess everything up

78
00:04:04,410 --> 00:04:11,310
for us necessarily so but one of the

79
00:04:09,180 --> 00:04:14,880
things that they have to do is you have

80
00:04:11,310 --> 00:04:16,950
in your your source code potentially

81
00:04:14,880 --> 00:04:20,089
infinite number of variables that you

82
00:04:16,950 --> 00:04:22,860
have to map to a finite set of registers

83
00:04:20,089 --> 00:04:27,690
what happens when you run out of

84
00:04:22,860 --> 00:04:31,200
registers well these this thing called

85
00:04:27,690 --> 00:04:33,479
the register allocator has to determine

86
00:04:31,200 --> 00:04:36,000
where each of these variables go and if

87
00:04:33,479 --> 00:04:37,349
it runs out a variable registers then it

88
00:04:36,000 --> 00:04:38,180
has to put the variable somewhere

89
00:04:37,350 --> 00:04:44,720
it puts

90
00:04:38,180 --> 00:04:48,169
on the stack and similarly with function

91
00:04:44,720 --> 00:04:49,940
calling conventions you typically have a

92
00:04:48,169 --> 00:04:52,008
number of registers that are used and

93
00:04:49,940 --> 00:04:55,250
then it starts writing these parameters

94
00:04:52,009 --> 00:04:56,720
on the stack so now you have local

95
00:04:55,250 --> 00:04:59,810
variables written to the stack you have

96
00:04:56,720 --> 00:05:01,490
parameters written to the stack and your

97
00:04:59,810 --> 00:05:05,919
binary analysis is going to have to

98
00:05:01,490 --> 00:05:08,539
disambiguate between these two and

99
00:05:05,919 --> 00:05:11,240
variable and function names and types

100
00:05:08,539 --> 00:05:13,130
well they're they're no more we don't

101
00:05:11,240 --> 00:05:18,970
have these when we're doing binary

102
00:05:13,130 --> 00:05:23,900
analysis typically we have to indirectly

103
00:05:18,970 --> 00:05:28,340
infer any of these things if at all

104
00:05:23,900 --> 00:05:32,948
possible so the things that the compiler

105
00:05:28,340 --> 00:05:35,810
does then leads us to this set of

106
00:05:32,949 --> 00:05:39,289
undecidable problems and an undecidable

107
00:05:35,810 --> 00:05:42,289
problem is is a problem that requires a

108
00:05:39,289 --> 00:05:45,710
yes or no answer but it's essentially

109
00:05:42,289 --> 00:05:49,010
company it's infeasible to answer that

110
00:05:45,710 --> 00:05:52,940
yes or no question and this is usually

111
00:05:49,010 --> 00:05:58,070
due to some lack of a piece of context

112
00:05:52,940 --> 00:06:01,039
that that doesn't actually exist in the

113
00:05:58,070 --> 00:06:03,440
code that you're analyzing so things

114
00:06:01,039 --> 00:06:06,349
that you might think are very simple

115
00:06:03,440 --> 00:06:09,889
like identifying where all of the

116
00:06:06,349 --> 00:06:13,159
functions are disambiguating code from

117
00:06:09,889 --> 00:06:15,289
data determining where strings are what

118
00:06:13,159 --> 00:06:17,650
what pieces of data are actually

119
00:06:15,289 --> 00:06:22,099
pointers these are all things that are

120
00:06:17,650 --> 00:06:26,570
undecidable and then these undecidable

121
00:06:22,099 --> 00:06:30,830
problems lead to a set of unique failure

122
00:06:26,570 --> 00:06:33,940
conditions for binary analysis and so

123
00:06:30,830 --> 00:06:38,508
you need to be able to handle these

124
00:06:33,940 --> 00:06:41,570
unique failure conditions you need to be

125
00:06:38,509 --> 00:06:43,520
prepared to handle them so what happens

126
00:06:41,570 --> 00:06:46,789
when stack resolution fails when you

127
00:06:43,520 --> 00:06:50,219
can't figure out where all of the

128
00:06:46,789 --> 00:06:52,349
variables are what happens when you

129
00:06:50,220 --> 00:06:56,160
you think there are too many parameters

130
00:06:52,350 --> 00:06:58,470
to a function or your switch resolution

131
00:06:56,160 --> 00:07:01,650
fails you are unable to determine the

132
00:06:58,470 --> 00:07:07,050
outgoing indirect edges from a indirect

133
00:07:01,650 --> 00:07:10,140
jump instruction or what happens when

134
00:07:07,050 --> 00:07:11,850
you've misidentified a function that you

135
00:07:10,140 --> 00:07:14,460
know you may have a false positive or

136
00:07:11,850 --> 00:07:20,580
false negative when miss identifying

137
00:07:14,460 --> 00:07:24,599
those so we don't say this to like scare

138
00:07:20,580 --> 00:07:27,570
you away it's a really interesting field

139
00:07:24,600 --> 00:07:30,750
that a lot of research is going into and

140
00:07:27,570 --> 00:07:34,620
it's necessary to understand all of the

141
00:07:30,750 --> 00:07:40,250
issues that you might run into before

142
00:07:34,620 --> 00:07:43,910
you try to choose a solution or try to

143
00:07:40,250 --> 00:07:46,950
do some binary analysis on your own so

144
00:07:43,910 --> 00:07:51,180
why would we want to talk about ILS

145
00:07:46,950 --> 00:07:54,360
first before we get into this the the

146
00:07:51,180 --> 00:08:00,620
great twitter war of 2018 was fought

147
00:07:54,360 --> 00:08:03,180
over the these terms for our purposes

148
00:08:00,620 --> 00:08:07,500
intermediate language is the same as

149
00:08:03,180 --> 00:08:11,100
intermediate representation and won't

150
00:08:07,500 --> 00:08:13,560
belabor that point as well as these

151
00:08:11,100 --> 00:08:15,690
other things bit code virtual machine

152
00:08:13,560 --> 00:08:20,190
opcode P code there they're all

153
00:08:15,690 --> 00:08:22,380
synonymous for our purposes so here's

154
00:08:20,190 --> 00:08:25,740
kind of the fundamental premise here is

155
00:08:22,380 --> 00:08:29,460
that reverse engineering is fundamental

156
00:08:25,740 --> 00:08:33,479
to understanding how binary code is

157
00:08:29,460 --> 00:08:38,280
works and intermediate languages are

158
00:08:33,479 --> 00:08:40,410
also fundamental to modern compiler

159
00:08:38,280 --> 00:08:43,829
design therefore if you're going to be

160
00:08:40,409 --> 00:08:45,300
doing by a binary analysis these

161
00:08:43,830 --> 00:08:47,250
intermediate languages should be

162
00:08:45,300 --> 00:08:52,550
fundamental to how you know your

163
00:08:47,250 --> 00:08:56,400
analysis is going to work so these

164
00:08:52,550 --> 00:09:00,089
intermediate languages they're generally

165
00:08:56,400 --> 00:09:01,860
a smaller set of instructions more RISC

166
00:09:00,089 --> 00:09:06,570
like

167
00:09:01,860 --> 00:09:08,720
then most of the instruction sets out

168
00:09:06,570 --> 00:09:11,460
there you can see you know thousands of

169
00:09:08,720 --> 00:09:15,360
instructions for x86 and hundreds were

170
00:09:11,460 --> 00:09:19,290
armed even something that is considered

171
00:09:15,360 --> 00:09:22,910
very risk like MIPS it still has more

172
00:09:19,290 --> 00:09:25,110
instructions than most of the

173
00:09:22,910 --> 00:09:27,300
intermediate languages out there the

174
00:09:25,110 --> 00:09:30,840
intermediate languages are in yellow and

175
00:09:27,300 --> 00:09:33,569
the lighter yellow is the native

176
00:09:30,840 --> 00:09:35,540
instruction sets so the other thing

177
00:09:33,570 --> 00:09:39,660
intermediate languages get you is an

178
00:09:35,540 --> 00:09:45,800
architecture agnostic layer so if you're

179
00:09:39,660 --> 00:09:49,469
writing a code to detect a malware on an

180
00:09:45,800 --> 00:09:54,290
x86 platform and they recompile it for

181
00:09:49,470 --> 00:09:57,570
armed you should be able to have a

182
00:09:54,290 --> 00:09:59,280
detection mechanism that works even

183
00:09:57,570 --> 00:10:04,560
though it's been compiled for a

184
00:09:59,280 --> 00:10:07,110
different architecture so this is kind

185
00:10:04,560 --> 00:10:10,290
of an example of why we would want to

186
00:10:07,110 --> 00:10:11,910
use these intermediate languages when we

187
00:10:10,290 --> 00:10:13,650
first release binary ninja we had a

188
00:10:11,910 --> 00:10:15,780
friend that was like okay I'm gonna

189
00:10:13,650 --> 00:10:19,680
write a simple script using your API

190
00:10:15,780 --> 00:10:21,569
we're gonna iterate we're gonna we're

191
00:10:19,680 --> 00:10:23,790
going to go through and find all of the

192
00:10:21,570 --> 00:10:25,920
system call instructions and figure out

193
00:10:23,790 --> 00:10:32,640
what the the system called parameter is

194
00:10:25,920 --> 00:10:36,930
so we can then so we can know what a API

195
00:10:32,640 --> 00:10:39,330
is that this is calling so i he did he

196
00:10:36,930 --> 00:10:41,640
looked for at the string representation

197
00:10:39,330 --> 00:10:45,470
tried to find the SVC instruction and

198
00:10:41,640 --> 00:10:48,090
then step back and figured in his

199
00:10:45,470 --> 00:10:50,910
particular binary the previous

200
00:10:48,090 --> 00:10:57,170
instruction always set the x8 register

201
00:10:50,910 --> 00:11:02,699
this is arm b8 and would would set arm

202
00:10:57,170 --> 00:11:05,790
x8 to the system call number that he was

203
00:11:02,700 --> 00:11:09,600
interested in so it he wrote it really

204
00:11:05,790 --> 00:11:12,459
quickly and it did what he wanted but if

205
00:11:09,600 --> 00:11:16,270
we look over at the

206
00:11:12,460 --> 00:11:17,980
the right hand side if you use the we

207
00:11:16,270 --> 00:11:20,020
had to show him the way you actually

208
00:11:17,980 --> 00:11:22,330
would want to do it if you're using an

209
00:11:20,020 --> 00:11:25,120
intermediate language and this is you

210
00:11:22,330 --> 00:11:27,790
step through the i/o instructions and

211
00:11:25,120 --> 00:11:30,820
you ask if it's a system call and then

212
00:11:27,790 --> 00:11:33,880
you just read the zero of the value of

213
00:11:30,820 --> 00:11:36,370
the zeroth parameter so quite a bit

214
00:11:33,880 --> 00:11:42,850
easier and now it works across all the

215
00:11:36,370 --> 00:11:45,690
platforms forever right so if we were

216
00:11:42,850 --> 00:11:49,780
going to do binary analysis why not just

217
00:11:45,690 --> 00:11:52,570
use a D compiler and then we can run all

218
00:11:49,780 --> 00:11:52,870
of our static source scanning tools on

219
00:11:52,570 --> 00:11:58,150
it

220
00:11:52,870 --> 00:12:00,850
well source scanning tools it take a lot

221
00:11:58,150 --> 00:12:04,270
of have a lot of sumption built into

222
00:12:00,850 --> 00:12:09,940
them many of those surround the types

223
00:12:04,270 --> 00:12:13,319
that are available D compilers try to

224
00:12:09,940 --> 00:12:15,640
recover types the best they can but

225
00:12:13,320 --> 00:12:18,760
compound types like structures and

226
00:12:15,640 --> 00:12:20,170
arrays are actually quite difficult and

227
00:12:18,760 --> 00:12:23,830
there's lots of ongoing research to

228
00:12:20,170 --> 00:12:27,390
actually discover how to to recover

229
00:12:23,830 --> 00:12:30,250
these things in an efficient manner and

230
00:12:27,390 --> 00:12:32,890
these source code scanning tools rely on

231
00:12:30,250 --> 00:12:34,960
the fact that everything isn't just a

232
00:12:32,890 --> 00:12:38,730
bunch of pointer math which is generally

233
00:12:34,960 --> 00:12:42,790
what you get out of a decompiler

234
00:12:38,730 --> 00:12:45,220
additionally as you take steps towards D

235
00:12:42,790 --> 00:12:48,130
compilation you have different

236
00:12:45,220 --> 00:12:50,640
abstractions at every layer and each one

237
00:12:48,130 --> 00:12:55,330
of those layers has the potential to

238
00:12:50,640 --> 00:12:59,860
actually lose information and increase

239
00:12:55,330 --> 00:13:04,510
errors so you might not want to use the

240
00:12:59,860 --> 00:13:06,310
deke a fully decompiled binary you might

241
00:13:04,510 --> 00:13:10,810
want to use some intermediate

242
00:13:06,310 --> 00:13:14,140
representation so and why wouldn't we

243
00:13:10,810 --> 00:13:14,650
just use C you know decompile straight

244
00:13:14,140 --> 00:13:18,760
to sea

245
00:13:14,650 --> 00:13:23,890
well a lot of people tend to think that

246
00:13:18,760 --> 00:13:25,240
okay C is the ultimate goal of D

247
00:13:23,890 --> 00:13:28,869
compilation

248
00:13:25,240 --> 00:13:31,869
we feel like this is not a great end

249
00:13:28,869 --> 00:13:33,809
goal because there's a lot of constructs

250
00:13:31,869 --> 00:13:37,119
in C that are not generally

251
00:13:33,809 --> 00:13:40,059
representable like a stack layout right

252
00:13:37,119 --> 00:13:42,519
that is something that's represented in

253
00:13:40,059 --> 00:13:44,860
the binary but by the time you get to

254
00:13:42,519 --> 00:13:47,110
see everything's just variables and you

255
00:13:44,860 --> 00:13:49,449
you don't really know what order those

256
00:13:47,110 --> 00:13:51,429
variables are going to end up on the

257
00:13:49,449 --> 00:13:55,809
stack you have other issues like

258
00:13:51,429 --> 00:13:58,540
variable aliasing like two pointers are

259
00:13:55,809 --> 00:14:04,319
coming into a function you don't know

260
00:13:58,540 --> 00:14:09,069
whether or not in C that these are

261
00:14:04,319 --> 00:14:13,149
aliased or not there's no C syntax for

262
00:14:09,069 --> 00:14:15,579
saying this pointer can or may not point

263
00:14:13,149 --> 00:14:17,230
to another but in an intermediate

264
00:14:15,579 --> 00:14:21,089
representation you can have that

265
00:14:17,230 --> 00:14:23,740
information available to you and

266
00:14:21,089 --> 00:14:25,600
semantic bindings between variables this

267
00:14:23,740 --> 00:14:28,920
is a kind of a similar concept if you

268
00:14:25,600 --> 00:14:31,389
have a pointer in the length they they

269
00:14:28,920 --> 00:14:34,229
they're kind of semantically bound

270
00:14:31,389 --> 00:14:36,100
together and C doesn't have this

271
00:14:34,230 --> 00:14:39,490
representation and that's the whole

272
00:14:36,100 --> 00:14:42,639
point behind the cell that Microsoft has

273
00:14:39,490 --> 00:14:46,199
which is kind of a cool way to annotate

274
00:14:42,639 --> 00:14:52,629
parameters so you know how these

275
00:14:46,199 --> 00:14:54,758
components are bound together so with

276
00:14:52,629 --> 00:14:59,619
that I'm going to turn it over to Jordan

277
00:14:54,759 --> 00:15:01,720
- okay great so hopefully you see some

278
00:14:59,619 --> 00:15:03,279
value in using an intermediate language

279
00:15:01,720 --> 00:15:05,230
for reverse engineering if not we still

280
00:15:03,279 --> 00:15:07,720
have a few more chances to convert you

281
00:15:05,230 --> 00:15:09,069
but in the meantime I'm just gonna talk

282
00:15:07,720 --> 00:15:10,600
about some of the design decisions oh

283
00:15:09,069 --> 00:15:13,269
not the demo yet I'm gonna talk about

284
00:15:10,600 --> 00:15:14,949
some of the design decisions that kind

285
00:15:13,269 --> 00:15:17,499
of go into using an intermediate

286
00:15:14,949 --> 00:15:20,229
language the choices of the interview

287
00:15:17,499 --> 00:15:22,629
languages that you can use and it's it's

288
00:15:20,230 --> 00:15:24,189
a fairly large list but there's a lot of

289
00:15:22,629 --> 00:15:25,839
trade-offs and and one thing I want to

290
00:15:24,189 --> 00:15:27,189
emphasize is that we're not here to say

291
00:15:25,839 --> 00:15:28,600
like any particular intermediate

292
00:15:27,189 --> 00:15:30,069
language is bad I mean there are a

293
00:15:28,600 --> 00:15:32,319
couple probably that are bad but for the

294
00:15:30,069 --> 00:15:34,059
most part there's just sort of different

295
00:15:32,319 --> 00:15:35,139
design choices right so different ILS

296
00:15:34,059 --> 00:15:37,660
are going to be useful for different

297
00:15:35,139 --> 00:15:38,769
purposes and so this is a nice kind of

298
00:15:37,660 --> 00:15:40,569
summary of one

299
00:15:38,769 --> 00:15:44,970
kind of access that influence is a bunch

300
00:15:40,569 --> 00:15:49,269
of things so if you have a very verbose

301
00:15:44,970 --> 00:15:50,050
amount of I'll instructions that's going

302
00:15:49,269 --> 00:15:52,029
to come from a very simplified

303
00:15:50,050 --> 00:15:54,488
instruction set if I have a very small

304
00:15:52,029 --> 00:15:56,860
number of kind of op codes in my Ilir

305
00:15:54,489 --> 00:15:59,049
I'm going to necessarily have a lot of

306
00:15:56,860 --> 00:15:59,829
them to represent some of these native

307
00:15:59,049 --> 00:16:02,470
instructions

308
00:15:59,829 --> 00:16:04,209
conversely if I have a very explicit

309
00:16:02,470 --> 00:16:06,399
instruction set I have lots of

310
00:16:04,209 --> 00:16:08,679
complicated instructions they're gonna

311
00:16:06,399 --> 00:16:10,420
produce much smaller intermediate

312
00:16:08,679 --> 00:16:12,249
results but now my analysis code that I

313
00:16:10,420 --> 00:16:13,660
want to write to find a particular

314
00:16:12,249 --> 00:16:15,249
pattern or whatever I'm doing with it

315
00:16:13,660 --> 00:16:17,079
I have to account for all of these

316
00:16:15,249 --> 00:16:18,699
different opt outs there's also some

317
00:16:17,079 --> 00:16:20,109
implications in terms of how difficult

318
00:16:18,699 --> 00:16:22,420
something is to live versus how

319
00:16:20,110 --> 00:16:24,160
difficult it is to parse there's a bunch

320
00:16:22,420 --> 00:16:25,719
of other ones as well for example does

321
00:16:24,160 --> 00:16:27,040
your intermediate language I deal with

322
00:16:25,720 --> 00:16:29,499
type information or is it going to

323
00:16:27,040 --> 00:16:31,360
remain untyped power Flags dealt with

324
00:16:29,499 --> 00:16:33,249
you'll find it in a lot of intermediate

325
00:16:31,360 --> 00:16:34,989
languages the way that they handle flags

326
00:16:33,249 --> 00:16:38,290
will determine how sort of readable they

327
00:16:34,989 --> 00:16:40,149
are because if you explicitly enumerate

328
00:16:38,290 --> 00:16:41,529
every flag for every operation it gets

329
00:16:40,149 --> 00:16:44,589
very large it makes it hard to kind of

330
00:16:41,529 --> 00:16:45,819
visually use and to as a human read but

331
00:16:44,589 --> 00:16:46,959
maybe it makes some of your analysis

332
00:16:45,819 --> 00:16:48,759
easier if you just want to be able to at

333
00:16:46,959 --> 00:16:50,559
any given point query the state of a

334
00:16:48,759 --> 00:16:51,730
flag although really you could probably

335
00:16:50,559 --> 00:16:52,929
just do it just at the conditionals

336
00:16:51,730 --> 00:16:54,069
right so I think it's one kind of way

337
00:16:52,929 --> 00:16:55,240
you can you could choose to handle it

338
00:16:54,069 --> 00:16:58,479
but different aisles are going to choose

339
00:16:55,240 --> 00:16:59,709
different decisions here another another

340
00:16:58,480 --> 00:17:02,709
good point is that the more sort of like

341
00:16:59,709 --> 00:17:06,188
generic your your framework is for your

342
00:17:02,709 --> 00:17:08,168
il you're gonna choose how adaptable you

343
00:17:06,189 --> 00:17:11,459
are to different weird native machine

344
00:17:08,169 --> 00:17:16,750
code instructions right so if you have a

345
00:17:11,459 --> 00:17:19,720
very odd architecture that makes strange

346
00:17:16,750 --> 00:17:20,919
you know like delay slots and I don't

347
00:17:19,720 --> 00:17:22,510
sounds actually that bad but there's a

348
00:17:20,919 --> 00:17:24,970
number of other design decisions that

349
00:17:22,510 --> 00:17:27,029
can make it much more difficult for you

350
00:17:24,970 --> 00:17:29,950
to lift and if you handle that in a

351
00:17:27,029 --> 00:17:31,179
specific architectural lifter to some

352
00:17:29,950 --> 00:17:32,620
sort of generic representation then

353
00:17:31,179 --> 00:17:35,350
maybe it's not going to be that hard but

354
00:17:32,620 --> 00:17:36,580
if you want to have a more generic if

355
00:17:35,350 --> 00:17:38,350
you want to have your interview trep

356
00:17:36,580 --> 00:17:40,510
resent ation account for all possible

357
00:17:38,350 --> 00:17:41,709
architectures that requires really kind

358
00:17:40,510 --> 00:17:43,929
of looking at what are all the screw

359
00:17:41,710 --> 00:17:46,090
things that they can do ok so here's an

360
00:17:43,929 --> 00:17:47,799
example you're not meant to read that

361
00:17:46,090 --> 00:17:49,959
that's perfectly fine I don't know that

362
00:17:47,799 --> 00:17:51,309
anybody will that's that's okay but on

363
00:17:49,960 --> 00:17:52,840
the right we actually have real we'll

364
00:17:51,309 --> 00:17:55,750
talk a little bit more about that later

365
00:17:52,840 --> 00:17:58,330
this is just test eax EAX from 32-bit

366
00:17:55,750 --> 00:17:59,950
x86 right that's a lot of IL that's

367
00:17:58,330 --> 00:18:02,918
being produced because real is a very

368
00:17:59,950 --> 00:18:05,049
very small instruction set it's being

369
00:18:02,919 --> 00:18:07,630
very explicit with flags and it produces

370
00:18:05,049 --> 00:18:09,309
much more complicated I'll than you

371
00:18:07,630 --> 00:18:11,980
would you would think about conversely

372
00:18:09,309 --> 00:18:13,389
if you have in Exodus if you have an il

373
00:18:11,980 --> 00:18:15,040
that can handle floating-point

374
00:18:13,390 --> 00:18:16,450
instructions for example you might have

375
00:18:15,040 --> 00:18:18,700
something very concise this is a

376
00:18:16,450 --> 00:18:20,380
floating-point load of integer 1 which

377
00:18:18,700 --> 00:18:21,490
if we were doing this and I don't even

378
00:18:20,380 --> 00:18:24,520
know if any was actually done this in

379
00:18:21,490 --> 00:18:25,720
real my guess is not because trying to

380
00:18:24,520 --> 00:18:27,910
implement the I Triple E floating point

381
00:18:25,720 --> 00:18:30,730
in a very simple instruction set would

382
00:18:27,910 --> 00:18:32,980
just be pages and pages and pages of il

383
00:18:30,730 --> 00:18:35,679
whereas it's literally a single line in

384
00:18:32,980 --> 00:18:36,790
in a more concise representation because

385
00:18:35,679 --> 00:18:39,160
they're actually just floating-point

386
00:18:36,790 --> 00:18:42,490
operations in that particular aisle okay

387
00:18:39,160 --> 00:18:43,660
so there's a lot of ILs again you're not

388
00:18:42,490 --> 00:18:45,940
expected to kind of go through this list

389
00:18:43,660 --> 00:18:47,470
you can see the slides afterwards we'll

390
00:18:45,940 --> 00:18:48,610
put them online and you can click all

391
00:18:47,470 --> 00:18:50,020
the references links and look at them a

392
00:18:48,610 --> 00:18:52,510
little bit more closely we'll talk about

393
00:18:50,020 --> 00:18:54,879
a couple of these but these are just the

394
00:18:52,510 --> 00:18:56,799
ILS that are used for binary reverse

395
00:18:54,880 --> 00:18:59,230
engineering or security purposes right

396
00:18:56,799 --> 00:19:01,510
so these are ILS they're specifically

397
00:18:59,230 --> 00:19:02,830
designed to go from machine code up to

398
00:19:01,510 --> 00:19:04,840
an intermediate representations for you

399
00:19:02,830 --> 00:19:07,178
to do reverse engineering or security

400
00:19:04,840 --> 00:19:09,490
analysis on top of a binary it's a

401
00:19:07,179 --> 00:19:13,390
pretty long list and many of you astute

402
00:19:09,490 --> 00:19:15,910
readers who are viewers readers might be

403
00:19:13,390 --> 00:19:18,280
familiar with like LLVM I arm extend

404
00:19:15,910 --> 00:19:19,660
some other projects that use that those

405
00:19:18,280 --> 00:19:21,730
aren't even on the slide that's actually

406
00:19:19,660 --> 00:19:23,410
a separate slide so these are just the

407
00:19:21,730 --> 00:19:26,590
implementations that are going to use

408
00:19:23,410 --> 00:19:28,360
LVM ir to do their analysis and there's

409
00:19:26,590 --> 00:19:29,830
a whole long list of those right so

410
00:19:28,360 --> 00:19:32,678
there's there's a large number of these

411
00:19:29,830 --> 00:19:34,389
let's talk about specifically six of

412
00:19:32,679 --> 00:19:35,620
them we'll go over kind of a little bit

413
00:19:34,390 --> 00:19:38,440
of like a quick summary of them will

414
00:19:35,620 --> 00:19:40,000
show some examples we've got LLVM as you

415
00:19:38,440 --> 00:19:41,290
just mentioned going to elevate my r

416
00:19:40,000 --> 00:19:43,510
there's actually several projects that

417
00:19:41,290 --> 00:19:44,918
will do that translation but we'll talk

418
00:19:43,510 --> 00:19:47,230
about the advantages and disadvantages

419
00:19:44,919 --> 00:19:49,419
that ir giedrius p code we'll talk about

420
00:19:47,230 --> 00:19:52,240
Eisel from a dare we'll talk about micro

421
00:19:49,419 --> 00:19:57,549
code and ida dynamics is real and binary

422
00:19:52,240 --> 00:20:00,280
and Joe's BN il il so LOV mi r we want

423
00:19:57,549 --> 00:20:02,770
to discourage you from from using l vm r

424
00:20:00,280 --> 00:20:05,490
in the general case there's a couple of

425
00:20:02,770 --> 00:20:06,809
reasons that this seems appealing and

426
00:20:05,490 --> 00:20:09,840
be a good idea but we would sort of

427
00:20:06,809 --> 00:20:12,779
caution you about doing this the biggest

428
00:20:09,840 --> 00:20:15,090
explanation why is because L of AMR was

429
00:20:12,779 --> 00:20:16,679
built to emit machine code right it was

430
00:20:15,090 --> 00:20:19,199
built as a part of a compiler tool chain

431
00:20:16,679 --> 00:20:21,120
to go forward engineering not reverse

432
00:20:19,200 --> 00:20:22,350
engineering and so that there's there's

433
00:20:21,120 --> 00:20:23,610
several issues with trying to go

434
00:20:22,350 --> 00:20:25,559
straight from machine code all the way

435
00:20:23,610 --> 00:20:26,879
back to an L of a Maya but it is

436
00:20:25,559 --> 00:20:28,678
tempting right so one of the reasons you

437
00:20:26,880 --> 00:20:30,270
might want to do this is because you get

438
00:20:28,679 --> 00:20:32,580
a whole bunch of analysis passes there's

439
00:20:30,270 --> 00:20:34,470
a lot of very useful analyses that you

440
00:20:32,580 --> 00:20:37,379
can get by just running these these LVM

441
00:20:34,470 --> 00:20:38,970
our analysis passes on top of l vm and

442
00:20:37,380 --> 00:20:40,559
so if you can get something that's a

443
00:20:38,970 --> 00:20:43,740
binary that you don't have source go to

444
00:20:40,559 --> 00:20:45,600
and you can lift it back up into l vm ir

445
00:20:43,740 --> 00:20:47,490
it seems like it might be appealing but

446
00:20:45,600 --> 00:20:49,350
the problem with that is that there's

447
00:20:47,490 --> 00:20:51,179
again it's not meant to do that

448
00:20:49,350 --> 00:20:53,820
and so what you can sort of see this as

449
00:20:51,179 --> 00:20:54,840
a byproduct of the number of those if

450
00:20:53,820 --> 00:20:56,850
you go through the projects that i

451
00:20:54,840 --> 00:20:58,709
listed on the the spreadsheet or the the

452
00:20:56,850 --> 00:21:01,139
previous table and you look at how many

453
00:20:58,710 --> 00:21:03,029
architectures they support most of them

454
00:21:01,140 --> 00:21:05,700
don't support very many architectures if

455
00:21:03,029 --> 00:21:07,620
not just one or maybe two or three and

456
00:21:05,700 --> 00:21:09,480
part of that reason is because there's

457
00:21:07,620 --> 00:21:11,039
sort of no cost savings in your analysis

458
00:21:09,480 --> 00:21:14,669
right you can't just do a kind of a

459
00:21:11,039 --> 00:21:16,080
small a bit of translation and then it

460
00:21:14,669 --> 00:21:17,429
goes to the higher level of

461
00:21:16,080 --> 00:21:19,460
representation which which handles the

462
00:21:17,429 --> 00:21:21,929
analysis things like tracking stack

463
00:21:19,460 --> 00:21:23,490
variables doing dataflow analysis are

464
00:21:21,929 --> 00:21:25,679
sort of necessary to recover some of

465
00:21:23,490 --> 00:21:28,260
this type information and you don't get

466
00:21:25,679 --> 00:21:29,789
that anywhere kind of in between LEM yes

467
00:21:28,260 --> 00:21:31,289
I'll sort of do it all per architecture

468
00:21:29,789 --> 00:21:32,879
all right and so it's just a lot of work

469
00:21:31,289 --> 00:21:35,250
to go for each architecture back up to

470
00:21:32,880 --> 00:21:37,080
that and again it wasn't designed to go

471
00:21:35,250 --> 00:21:39,120
that direction so it's certainly doable

472
00:21:37,080 --> 00:21:40,949
there are many great tools there is one

473
00:21:39,120 --> 00:21:43,080
other advantage to it I want to admit I

474
00:21:40,950 --> 00:21:45,299
want to mention which is it's good to

475
00:21:43,080 --> 00:21:47,580
re-emit so a lot of the projects that

476
00:21:45,299 --> 00:21:48,720
use LVM are all of emi are are doing it

477
00:21:47,580 --> 00:21:50,250
because they want to be able to lift to

478
00:21:48,720 --> 00:21:52,049
from one architecture and remit to

479
00:21:50,250 --> 00:21:53,190
another so it's a kind of neat trick

480
00:21:52,049 --> 00:21:54,929
where if you want to take something that

481
00:21:53,190 --> 00:21:56,429
was compiled for x86 and run it on arm

482
00:21:54,929 --> 00:21:57,840
you can do that without source and

483
00:21:56,429 --> 00:21:59,520
without a full emulator because you're

484
00:21:57,840 --> 00:22:00,720
actually sort of lifting it up to this

485
00:21:59,520 --> 00:22:02,700
intermediate resident ation and then

486
00:22:00,720 --> 00:22:04,260
using all the you know claiming

487
00:22:02,700 --> 00:22:05,820
infrastructure to recompile it back down

488
00:22:04,260 --> 00:22:08,129
to another architecture and so that's

489
00:22:05,820 --> 00:22:10,668
actually one nice advantage that none of

490
00:22:08,130 --> 00:22:13,409
the other IRS I think the initial table

491
00:22:10,669 --> 00:22:15,659
are built for and can do well if at all

492
00:22:13,409 --> 00:22:16,889
so that is one one good advantage of

493
00:22:15,659 --> 00:22:18,389
that all right

494
00:22:16,889 --> 00:22:19,139
so most people who have done a reverse

495
00:22:18,389 --> 00:22:20,939
engineering or problem

496
00:22:19,140 --> 00:22:22,650
familiar with ina although their

497
00:22:20,940 --> 00:22:25,530
microcode is still relatively new so

498
00:22:22,650 --> 00:22:27,480
people may not be as familiar with how

499
00:22:25,530 --> 00:22:29,639
that works but it's been in the products

500
00:22:27,480 --> 00:22:31,320
since they've had x-rays decompiler it

501
00:22:29,640 --> 00:22:34,110
just wasn't exposed until I think last

502
00:22:31,320 --> 00:22:35,370
year is when they first published api's

503
00:22:34,110 --> 00:22:37,080
and started kind of opening up in

504
00:22:35,370 --> 00:22:38,550
exactly how it works we like to think

505
00:22:37,080 --> 00:22:39,990
that biner named Josiah was a little bit

506
00:22:38,550 --> 00:22:41,129
of that motivation but I don't know if

507
00:22:39,990 --> 00:22:43,140
that's true or not

508
00:22:41,130 --> 00:22:45,420
so in fact give a talk at recon last

509
00:22:43,140 --> 00:22:47,070
year with this slides kind of the

510
00:22:45,420 --> 00:22:48,690
content the left comes out of you can

511
00:22:47,070 --> 00:22:51,750
see in this little snippet of assembly

512
00:22:48,690 --> 00:22:53,580
we've got a very verbose amount of micro

513
00:22:51,750 --> 00:22:55,380
code that's kind of emitted it's not

514
00:22:53,580 --> 00:22:57,300
designed for reading and the very

515
00:22:55,380 --> 00:22:59,010
initial lifting is fairly verbose but

516
00:22:57,300 --> 00:23:00,960
there's these optimization passes and so

517
00:22:59,010 --> 00:23:02,310
they're taking the il and they're

518
00:23:00,960 --> 00:23:03,930
transforming out through these different

519
00:23:02,310 --> 00:23:05,129
maturity levels they call it internally

520
00:23:03,930 --> 00:23:06,360
and there's a whole bunch of these sort

521
00:23:05,130 --> 00:23:08,370
of maturity levels and these analysis

522
00:23:06,360 --> 00:23:10,469
passes that happen where they transform

523
00:23:08,370 --> 00:23:12,659
the il and you see it's kind of smaller

524
00:23:10,470 --> 00:23:14,430
and smaller until this last step which

525
00:23:12,660 --> 00:23:15,960
is where the one right before it goes to

526
00:23:14,430 --> 00:23:17,820
the decompiler and it produces just an

527
00:23:15,960 --> 00:23:20,040
if statement in this particular example

528
00:23:17,820 --> 00:23:22,110
they also have the C tree API as well

529
00:23:20,040 --> 00:23:23,250
internally which is another way to

530
00:23:22,110 --> 00:23:24,780
access the sort of intermediate

531
00:23:23,250 --> 00:23:27,870
representation that's not quite just

532
00:23:24,780 --> 00:23:30,899
text source but another state that you

533
00:23:27,870 --> 00:23:34,290
that you can access so where Daris C

534
00:23:30,900 --> 00:23:35,880
soul is a string based il and so there's

535
00:23:34,290 --> 00:23:37,050
there's no really kind of API to get to

536
00:23:35,880 --> 00:23:38,850
it you can just get these strings and

537
00:23:37,050 --> 00:23:40,860
you could sort of parse them but they're

538
00:23:38,850 --> 00:23:43,080
postfix notation so it's it's a little

539
00:23:40,860 --> 00:23:45,689
bit awkward in my mind because it's not

540
00:23:43,080 --> 00:23:47,040
quite for people like it's it's string

541
00:23:45,690 --> 00:23:48,960
based so you might think it's like meant

542
00:23:47,040 --> 00:23:50,190
for a reading but it's not because it's

543
00:23:48,960 --> 00:23:51,960
post text notation so it's harder to

544
00:23:50,190 --> 00:23:54,540
kind of parse but they have a lot of

545
00:23:51,960 --> 00:23:55,590
architectures that are supported and so

546
00:23:54,540 --> 00:23:57,659
there's a whole bunch of different

547
00:23:55,590 --> 00:24:00,330
architectures that you might find ESL

548
00:23:57,660 --> 00:24:02,430
support for and if you want to kind of

549
00:24:00,330 --> 00:24:03,240
wire up into like r2 pipe and manipulate

550
00:24:02,430 --> 00:24:05,160
over it you have to do a little bit

551
00:24:03,240 --> 00:24:06,900
string parsing but once you get it into

552
00:24:05,160 --> 00:24:08,760
something more reasonable you can still

553
00:24:06,900 --> 00:24:10,290
do a lot of analysis and on top of it is

554
00:24:08,760 --> 00:24:11,360
a little more concise than many of the

555
00:24:10,290 --> 00:24:14,340
other aisles

556
00:24:11,360 --> 00:24:15,570
Deidre's P code is sort of the new kid

557
00:24:14,340 --> 00:24:16,620
on the block it's actually not at all

558
00:24:15,570 --> 00:24:18,409
right it's been around for many years

559
00:24:16,620 --> 00:24:21,149
has just now been made public this year

560
00:24:18,410 --> 00:24:22,290
they have a sort of unique design in

561
00:24:21,150 --> 00:24:24,180
that they have what's called slay

562
00:24:22,290 --> 00:24:27,149
definitions and so this is actually a

563
00:24:24,180 --> 00:24:31,800
kind of a pun on some research by dr.

564
00:24:27,150 --> 00:24:32,480
Kristina cifuentes that was in 1998 was

565
00:24:31,800 --> 00:24:34,820
the first

566
00:24:32,480 --> 00:24:35,980
series of papers that came out of the

567
00:24:34,820 --> 00:24:38,870
group in the lab she was working with

568
00:24:35,980 --> 00:24:40,640
that described how decompilers could

569
00:24:38,870 --> 00:24:43,340
work and they had a specification called

570
00:24:40,640 --> 00:24:44,720
sled and so Ghidorah has sleigh so you

571
00:24:43,340 --> 00:24:48,020
can tell they were reading the same the

572
00:24:44,720 --> 00:24:50,960
same papers there and the the sleigh

573
00:24:48,020 --> 00:24:52,879
definition is a is a cpu description

574
00:24:50,960 --> 00:24:54,770
language right so they describe the CPU

575
00:24:52,880 --> 00:24:57,260
and then there's a compiler that takes

576
00:24:54,770 --> 00:25:00,470
this sleigh and turns it into the P code

577
00:24:57,260 --> 00:25:02,629
P code is used both generically - oh

578
00:25:00,470 --> 00:25:05,030
it's not pseudocode what's the other I

579
00:25:02,630 --> 00:25:08,810
was what if the other guys wanna help me

580
00:25:05,030 --> 00:25:10,850
out P code stands for I don't remember

581
00:25:08,810 --> 00:25:12,290
it's killing me now it's not pseudocode

582
00:25:10,850 --> 00:25:13,699
that's what I keep saying that but it's

583
00:25:12,290 --> 00:25:15,920
not it's not actually pseudocode it

584
00:25:13,700 --> 00:25:17,690
stands for partial to know something

585
00:25:15,920 --> 00:25:19,400
machine code I forgot it anyway but so

586
00:25:17,690 --> 00:25:21,800
it's usable generically as I mentioned

587
00:25:19,400 --> 00:25:23,750
earlier a bit code VM opcode are used

588
00:25:21,800 --> 00:25:25,129
for these intermediate languages P code

589
00:25:23,750 --> 00:25:28,270
is another generic term but it's also

590
00:25:25,130 --> 00:25:30,590
this specific name of Deidre's

591
00:25:28,270 --> 00:25:32,360
intermediate representation it's

592
00:25:30,590 --> 00:25:33,740
actually pretty concise you saw on the

593
00:25:32,360 --> 00:25:35,510
label on that table earlier it doesn't

594
00:25:33,740 --> 00:25:36,920
have a lot of opcodes and produces

595
00:25:35,510 --> 00:25:38,420
relatively reasonable stuff it also has

596
00:25:36,920 --> 00:25:40,970
floating point support has pretty good

597
00:25:38,420 --> 00:25:42,980
architecture support and it's it's a

598
00:25:40,970 --> 00:25:44,450
from the sleigh to the P code and then

599
00:25:42,980 --> 00:25:48,320
there D compiler works directly on the P

600
00:25:44,450 --> 00:25:50,540
code so real from dynamics is one that's

601
00:25:48,320 --> 00:25:52,730
kind of fun to make fun of and I love

602
00:25:50,540 --> 00:25:54,080
how far and those dynamics guys did good

603
00:25:52,730 --> 00:25:57,320
work on it Bend if and bit na'vi are

604
00:25:54,080 --> 00:25:59,750
great tools but as an IL real only has

605
00:25:57,320 --> 00:26:03,020
17 instructions so it produces just the

606
00:25:59,750 --> 00:26:04,760
most horrific ILD you'll ever see if you

607
00:26:03,020 --> 00:26:05,900
want actually kind of debug it but this

608
00:26:04,760 --> 00:26:07,940
is a good point where I wouldn't

609
00:26:05,900 --> 00:26:10,370
recommend it for general analysis for

610
00:26:07,940 --> 00:26:11,840
example type information a lot of the

611
00:26:10,370 --> 00:26:12,979
other things you would want from a

612
00:26:11,840 --> 00:26:14,810
reverse engineering intermediate

613
00:26:12,980 --> 00:26:17,000
language they don't have but for their

614
00:26:14,810 --> 00:26:18,350
purposes of doing binary diffing it

615
00:26:17,000 --> 00:26:19,940
works fairly well I mean to this day

616
00:26:18,350 --> 00:26:23,330
that bin diff is still one of the main

617
00:26:19,940 --> 00:26:24,680
tools for binary diffing because of this

618
00:26:23,330 --> 00:26:26,629
intermediate representation they had so

619
00:26:24,680 --> 00:26:29,120
it may not work for all cases but it did

620
00:26:26,630 --> 00:26:32,600
work for that particular problem okay so

621
00:26:29,120 --> 00:26:33,919
binary ninjas got BN il which is we've

622
00:26:32,600 --> 00:26:35,030
sort of been like beating this drum like

623
00:26:33,920 --> 00:26:36,440
intermediate languages are great

624
00:26:35,030 --> 00:26:38,389
compilers use them reverse injuring

625
00:26:36,440 --> 00:26:41,540
tools should use them so let's put nine

626
00:26:38,390 --> 00:26:43,190
in our in our tool and so we're not

627
00:26:41,540 --> 00:26:44,180
going to talk about all of these we

628
00:26:43,190 --> 00:26:45,620
would love to talk with you afterwards

629
00:26:44,180 --> 00:26:45,770
about the differences and how you kind

630
00:26:45,620 --> 00:26:47,090
of

631
00:26:45,770 --> 00:26:49,040
between them but I do want to highlight

632
00:26:47,090 --> 00:26:51,409
a couple and some of the differences

633
00:26:49,040 --> 00:26:54,800
kind of kind of between them so first

634
00:26:51,410 --> 00:26:56,240
this is a family of Isles so you're

635
00:26:54,800 --> 00:26:57,980
going to initially you've got assembly

636
00:26:56,240 --> 00:26:59,450
that's going to go to lifted il and that

637
00:26:57,980 --> 00:27:00,890
translation layer is kind of done by an

638
00:26:59,450 --> 00:27:02,810
architecture plug-in when you implement

639
00:27:00,890 --> 00:27:03,860
a plugin on top of it you'll just write

640
00:27:02,810 --> 00:27:06,080
that layer and then all the other ones

641
00:27:03,860 --> 00:27:08,060
are sort of internal transformations so

642
00:27:06,080 --> 00:27:10,520
a little bit the way that Ida has their

643
00:27:08,060 --> 00:27:12,200
their microcode maturity levels except

644
00:27:10,520 --> 00:27:14,360
these are actually explicitly different

645
00:27:12,200 --> 00:27:16,640
ILS with different op codes in some

646
00:27:14,360 --> 00:27:17,929
cases in different functions I think

647
00:27:16,640 --> 00:27:19,730
that's one of the the things that like a

648
00:27:17,930 --> 00:27:21,110
gear and a pico don't get you is this

649
00:27:19,730 --> 00:27:23,030
sort of like where do you want to look

650
00:27:21,110 --> 00:27:24,169
and do your analysis Ida as maturity

651
00:27:23,030 --> 00:27:26,330
levels have that a little bit which is

652
00:27:24,170 --> 00:27:28,700
nice and by ninja has that explicitly

653
00:27:26,330 --> 00:27:30,830
with all these different different ILS

654
00:27:28,700 --> 00:27:32,270
it's tree based and so that means you

655
00:27:30,830 --> 00:27:33,980
can kind of fold up instructions kind of

656
00:27:32,270 --> 00:27:35,870
nicely make em concise for reading has I

657
00:27:33,980 --> 00:27:37,190
think I'll deferred flags it's don't

658
00:27:35,870 --> 00:27:38,629
wanna go the details now come talk to us

659
00:27:37,190 --> 00:27:40,310
later so let's look at a piece of

660
00:27:38,630 --> 00:27:41,810
assembly so this is a much bigger block

661
00:27:40,310 --> 00:27:42,830
of assembly you'll notice then the

662
00:27:41,810 --> 00:27:44,960
snippets I was doing for the other

663
00:27:42,830 --> 00:27:46,790
aisles because one of these properties

664
00:27:44,960 --> 00:27:49,220
of being il is that it's very concise

665
00:27:46,790 --> 00:27:51,830
and so I went to low-level al which

666
00:27:49,220 --> 00:27:53,330
actually got the image got bigger the

667
00:27:51,830 --> 00:27:55,010
font gets bigger because the actual

668
00:27:53,330 --> 00:27:57,230
lines of text gets smaller right so this

669
00:27:55,010 --> 00:27:58,820
is actually more readable than assembly

670
00:27:57,230 --> 00:28:00,170
in a lot of ways so it's meant to kind

671
00:27:58,820 --> 00:28:01,460
of get more and more concise so you'll

672
00:28:00,170 --> 00:28:02,900
see the higher level I go

673
00:28:01,460 --> 00:28:04,670
we still things up we still have things

674
00:28:02,900 --> 00:28:06,620
like the stack though at Lil Alejo and

675
00:28:04,670 --> 00:28:08,480
then we go to medium level il which is a

676
00:28:06,620 --> 00:28:10,760
low medium high alright it's obviously

677
00:28:08,480 --> 00:28:12,110
getting more and more abstract at this

678
00:28:10,760 --> 00:28:13,910
media love lyall the stack has gone away

679
00:28:12,110 --> 00:28:15,020
things are now just variables but the

680
00:28:13,910 --> 00:28:17,300
point is that when you're doing your

681
00:28:15,020 --> 00:28:18,050
analysis if you care about the stack and

682
00:28:17,300 --> 00:28:20,510
you want to know where things are on the

683
00:28:18,050 --> 00:28:22,490
stack this may make more sense to ask at

684
00:28:20,510 --> 00:28:23,810
the low-level i/o when you're doing data

685
00:28:22,490 --> 00:28:25,580
flow you may want to use one of the SSA

686
00:28:23,810 --> 00:28:26,810
forms there's these other things that

687
00:28:25,580 --> 00:28:29,300
you're gonna you may want to care about

688
00:28:26,810 --> 00:28:31,190
and you can use the il for that purpose

689
00:28:29,300 --> 00:28:33,440
and then this is this is kind of a first

690
00:28:31,190 --> 00:28:36,110
so this is still in development but this

691
00:28:33,440 --> 00:28:37,640
is our high-level il and it's basically

692
00:28:36,110 --> 00:28:40,760
a decompiler so this is actually the

693
00:28:37,640 --> 00:28:41,990
entire function that the other snippets

694
00:28:40,760 --> 00:28:44,330
were just showing kind of like this is

695
00:28:41,990 --> 00:28:45,590
like that first three lines of this been

696
00:28:44,330 --> 00:28:47,629
a source code we're what we were showing

697
00:28:45,590 --> 00:28:49,370
on this particular slide right here gets

698
00:28:47,630 --> 00:28:51,890
turned into just this high-level I'll

699
00:28:49,370 --> 00:28:52,850
and that's very pseudo clutter I like

700
00:28:51,890 --> 00:28:54,950
this is meant to be kind of a fully

701
00:28:52,850 --> 00:28:56,929
compiler so it's still an il you can

702
00:28:54,950 --> 00:28:59,220
still walk over this tree of IL

703
00:28:56,930 --> 00:29:02,040
instructions but it's going to

704
00:28:59,220 --> 00:29:03,840
not be source per se it's just gonna be

705
00:29:02,040 --> 00:29:05,399
this this high-level il and then you can

706
00:29:03,840 --> 00:29:06,449
you can you give a semicolons on the end

707
00:29:05,400 --> 00:29:07,050
you can make things look like see if you

708
00:29:06,450 --> 00:29:09,180
want to later

709
00:29:07,050 --> 00:29:11,610
but that could see that that analysis

710
00:29:09,180 --> 00:29:14,370
okay so why do we have so many I think

711
00:29:11,610 --> 00:29:15,899
xkcd nails it on the head situation

712
00:29:14,370 --> 00:29:18,000
there are 14 committing standards that's

713
00:29:15,900 --> 00:29:19,620
terrible let's make the one standard to

714
00:29:18,000 --> 00:29:21,030
rule them all now we have 15 I think

715
00:29:19,620 --> 00:29:22,889
that's part of the reason why we get so

716
00:29:21,030 --> 00:29:24,629
many ILS there's there's many good

717
00:29:22,890 --> 00:29:25,710
reasons why we have a lot of different

718
00:29:24,630 --> 00:29:27,090
aisles and you may have to sort of

719
00:29:25,710 --> 00:29:29,490
choose which one when you want to build

720
00:29:27,090 --> 00:29:31,649
your analysis many different

721
00:29:29,490 --> 00:29:33,090
requirements right so for example there

722
00:29:31,650 --> 00:29:35,400
may be certain abstractions that do or

723
00:29:33,090 --> 00:29:36,419
don't exist on one il that you want to

724
00:29:35,400 --> 00:29:37,530
have support for maybe you know the

725
00:29:36,420 --> 00:29:39,360
existing analyst meets your needs in

726
00:29:37,530 --> 00:29:42,330
that regard maybe there's a language

727
00:29:39,360 --> 00:29:43,919
that you want to have support for maybe

728
00:29:42,330 --> 00:29:45,300
there is a particular architecture

729
00:29:43,920 --> 00:29:46,860
that's not implement in an existing il

730
00:29:45,300 --> 00:29:49,590
and you find it easier to make your own

731
00:29:46,860 --> 00:29:51,419
il for that architecture but there are a

732
00:29:49,590 --> 00:29:52,530
lot of sort of unmaintained aisles

733
00:29:51,420 --> 00:29:54,090
there's a lot of these that have not

734
00:29:52,530 --> 00:29:55,560
been touched in a while they were just a

735
00:29:54,090 --> 00:29:56,970
single kind of went off there may also

736
00:29:55,560 --> 00:29:58,830
be licensing reasons why you don't want

737
00:29:56,970 --> 00:30:00,660
to use a particular il there's a couple

738
00:29:58,830 --> 00:30:03,540
of bad reasons though that there's a lot

739
00:30:00,660 --> 00:30:04,710
of I ELLs not invented here I don't need

740
00:30:03,540 --> 00:30:07,290
to explain to a room technical people

741
00:30:04,710 --> 00:30:08,430
what that means lack of awareness though

742
00:30:07,290 --> 00:30:10,170
I think is one that we're hoping to

743
00:30:08,430 --> 00:30:12,990
solve one of the reasons we're trying to

744
00:30:10,170 --> 00:30:15,150
do talks like this is to make people

745
00:30:12,990 --> 00:30:16,560
more aware of the the breadth of the

746
00:30:15,150 --> 00:30:18,450
aisles out there give people sort of a

747
00:30:16,560 --> 00:30:20,010
flavor that ask some questions get them

748
00:30:18,450 --> 00:30:21,000
thinking about what are the good

749
00:30:20,010 --> 00:30:22,410
properties that they would want to be

750
00:30:21,000 --> 00:30:24,680
aware of and that how can they use these

751
00:30:22,410 --> 00:30:26,520
aisles and then there's another

752
00:30:24,680 --> 00:30:28,560
unfortunate region which is sort of

753
00:30:26,520 --> 00:30:32,040
publish or perish a lot of the great

754
00:30:28,560 --> 00:30:34,050
research in this in this topic comes

755
00:30:32,040 --> 00:30:35,520
from academia there's a lot of work in

756
00:30:34,050 --> 00:30:36,750
programming languages and compilers and

757
00:30:35,520 --> 00:30:38,460
reverse engineering coming out of

758
00:30:36,750 --> 00:30:41,730
universities but there's an unfortunate

759
00:30:38,460 --> 00:30:43,350
tendency in academia to do something new

760
00:30:41,730 --> 00:30:44,640
and different and you can't just iterate

761
00:30:43,350 --> 00:30:45,899
on something that's been around and so

762
00:30:44,640 --> 00:30:47,460
you'll see a lot of new AI ELLs come out

763
00:30:45,900 --> 00:30:48,660
because it's sort of like well we're

764
00:30:47,460 --> 00:30:50,070
gonna like solve the problem instead of

765
00:30:48,660 --> 00:30:51,750
tweaking it in this existing open source

766
00:30:50,070 --> 00:30:54,659
one we're just gonna make a brand new

767
00:30:51,750 --> 00:30:57,300
one so here are some this is our

768
00:30:54,660 --> 00:31:00,240
BuzzFeed sort of like questions to ask

769
00:30:57,300 --> 00:31:01,470
your il before committing just wait to

770
00:31:00,240 --> 00:31:03,720
see number 10

771
00:31:01,470 --> 00:31:05,640
what architectures are supported what

772
00:31:03,720 --> 00:31:08,100
language no we laughed I'm sorry was it

773
00:31:05,640 --> 00:31:10,920
that bad really you guys okay pity laugh

774
00:31:08,100 --> 00:31:12,570
whatever I'll take it what are the

775
00:31:10,920 --> 00:31:13,510
architectures that are supported what

776
00:31:12,570 --> 00:31:15,490
languages are

777
00:31:13,510 --> 00:31:17,350
supported four and again languages that

778
00:31:15,490 --> 00:31:19,630
you want to use to query the il maybe or

779
00:31:17,350 --> 00:31:21,699
what are their different aisles suited

780
00:31:19,630 --> 00:31:22,420
towards a particular native source code

781
00:31:21,700 --> 00:31:23,920
language because you're gonna get

782
00:31:22,420 --> 00:31:26,680
different abstractions there how

783
00:31:23,920 --> 00:31:28,450
complete is the lifting very I don't

784
00:31:26,680 --> 00:31:30,220
know of any il that actually is fully

785
00:31:28,450 --> 00:31:32,710
complete to x86 because they ain't

786
00:31:30,220 --> 00:31:34,540
nobody that crazy right like there's a

787
00:31:32,710 --> 00:31:37,690
lot of ways you can do a lot of

788
00:31:34,540 --> 00:31:39,280
instructions in x86 and so if there are

789
00:31:37,690 --> 00:31:40,480
particular instructions you care about

790
00:31:39,280 --> 00:31:42,010
or architectures that you care but you

791
00:31:40,480 --> 00:31:43,210
need to go and see if the aisles you

792
00:31:42,010 --> 00:31:44,860
want to supports those or you can always

793
00:31:43,210 --> 00:31:46,540
just add it how our stack variables

794
00:31:44,860 --> 00:31:48,639
handle how our function is discovered it

795
00:31:46,540 --> 00:31:49,899
is actually interesting to me that

796
00:31:48,640 --> 00:31:53,500
especially if you read a lot of like

797
00:31:49,900 --> 00:31:55,300
research papers doing analysis in this

798
00:31:53,500 --> 00:31:56,620
area they'll say okay start with the

799
00:31:55,300 --> 00:31:58,600
control flow graph that we got from Ida

800
00:31:56,620 --> 00:31:59,620
and then run this analysis and look at

801
00:31:58,600 --> 00:32:00,459
all the great analysis we can provide

802
00:31:59,620 --> 00:32:01,840
and you're like well hold on you just

803
00:32:00,460 --> 00:32:03,550
you just skipped one of the hardest

804
00:32:01,840 --> 00:32:06,280
problems like as Peter mentioned earlier

805
00:32:03,550 --> 00:32:08,440
finding where the code is is deceptively

806
00:32:06,280 --> 00:32:10,780
hard like literally just is this byte in

807
00:32:08,440 --> 00:32:12,580
instruction or data is much harder than

808
00:32:10,780 --> 00:32:14,410
you might think at first glance it's

809
00:32:12,580 --> 00:32:16,090
easy to get right most of the time it's

810
00:32:14,410 --> 00:32:18,700
very hard to get right all the time and

811
00:32:16,090 --> 00:32:19,780
possibly right all of the time and you

812
00:32:18,700 --> 00:32:21,610
know you can think about that trivially

813
00:32:19,780 --> 00:32:23,320
because data that comes in from the

814
00:32:21,610 --> 00:32:24,969
users can direct control flow right so

815
00:32:23,320 --> 00:32:26,649
that's at the worst case means you

816
00:32:24,970 --> 00:32:28,290
cannot know and so trying to recover

817
00:32:26,650 --> 00:32:30,610
that information is is really important

818
00:32:28,290 --> 00:32:32,440
but like you need to make sure that if

819
00:32:30,610 --> 00:32:34,330
you care about the accuracy of your of

820
00:32:32,440 --> 00:32:36,400
your system where is it getting this

821
00:32:34,330 --> 00:32:37,720
control flow information from how our

822
00:32:36,400 --> 00:32:39,430
function parameters determine our types

823
00:32:37,720 --> 00:32:39,700
recover well the API is for manipulating

824
00:32:39,430 --> 00:32:41,590
it

825
00:32:39,700 --> 00:32:43,390
do you have data flow ap is many api's

826
00:32:41,590 --> 00:32:45,070
will give you data flow queries or you

827
00:32:43,390 --> 00:32:47,260
can just say like where did this value

828
00:32:45,070 --> 00:32:48,850
come from is this the value set analysis

829
00:32:47,260 --> 00:32:50,260
so can I tell it's a ranged value like

830
00:32:48,850 --> 00:32:51,429
less than this and greater than this or

831
00:32:50,260 --> 00:32:52,690
does it just give me kind of static data

832
00:32:51,430 --> 00:32:54,570
flows it could be no data flow many

833
00:32:52,690 --> 00:32:56,770
don't give you any of these api's

834
00:32:54,570 --> 00:32:59,860
documentation for a paucity and you care

835
00:32:56,770 --> 00:33:02,379
about support okay now I can take a

836
00:32:59,860 --> 00:33:04,840
breath and we can show some demos so the

837
00:33:02,380 --> 00:33:06,610
goal here excellent thank you

838
00:33:04,840 --> 00:33:08,350
is there was two different demos that

839
00:33:06,610 --> 00:33:09,699
we're gonna run we're gonna show the

840
00:33:08,350 --> 00:33:11,439
problem we'll look at the source code

841
00:33:09,700 --> 00:33:12,670
and then we'll see you in action and

842
00:33:11,440 --> 00:33:14,110
we'll cross our fingers that it works

843
00:33:12,670 --> 00:33:16,420
and we don't get hit by the the demo

844
00:33:14,110 --> 00:33:18,820
gods so I went to Stack Overflow

845
00:33:16,420 --> 00:33:20,320
as one does and grabbed a copy of some

846
00:33:18,820 --> 00:33:22,929
md5 source code right and I just googled

847
00:33:20,320 --> 00:33:25,340
like you know md5 implementation and so

848
00:33:22,930 --> 00:33:28,100
I built this md5

849
00:33:25,340 --> 00:33:32,090
into a library compiled it and we can

850
00:33:28,100 --> 00:33:34,399
open it up in in binary ninja where I've

851
00:33:32,090 --> 00:33:36,289
got maybe five in it every five update

852
00:33:34,399 --> 00:33:37,998
and if I final I've got the names of

853
00:33:36,289 --> 00:33:39,950
these of these functions here for

854
00:33:37,999 --> 00:33:41,629
example because I compiled it with

855
00:33:39,950 --> 00:33:44,059
symbols but you don't often have that

856
00:33:41,629 --> 00:33:47,918
when the binary we lose our stilt there

857
00:33:44,059 --> 00:33:51,408
okay just my confidence is out we are

858
00:33:47,919 --> 00:33:52,999
you don't often have these symbols how

859
00:33:51,409 --> 00:33:54,350
many people have reverse-engineered md5

860
00:33:52,999 --> 00:33:57,619
before only to realize like after

861
00:33:54,350 --> 00:33:59,840
several hours that it was md5 or any

862
00:33:57,619 --> 00:34:01,009
encryption okay the people that have

863
00:33:59,840 --> 00:34:02,720
yeah you're lying if you don't raise

864
00:34:01,009 --> 00:34:04,340
your hand so like this has happened and

865
00:34:02,720 --> 00:34:07,159
this is a terrible thing like when you

866
00:34:04,340 --> 00:34:09,109
yeah I'm sorry for your loss like this

867
00:34:07,159 --> 00:34:10,399
is like a painful thing when you reverse

868
00:34:09,109 --> 00:34:12,259
engineer something that's really just a

869
00:34:10,399 --> 00:34:14,929
statically compiled library right and so

870
00:34:12,260 --> 00:34:17,000
finding these crypto functions is a very

871
00:34:14,929 --> 00:34:18,470
useful thing there are several plugins

872
00:34:17,000 --> 00:34:19,849
that will do this either ships one in

873
00:34:18,469 --> 00:34:21,319
their default API is there's several

874
00:34:19,849 --> 00:34:22,819
other third-party ones there's one

875
00:34:21,319 --> 00:34:25,520
somebody wrote on binary ninja called

876
00:34:22,819 --> 00:34:27,319
like crypto skin and all they do is they

877
00:34:25,520 --> 00:34:29,629
go through the binary and they look for

878
00:34:27,319 --> 00:34:31,009
particular constant values because if we

879
00:34:29,629 --> 00:34:33,168
look back at our source code here for

880
00:34:31,010 --> 00:34:34,460
md5 we can see like in this init there's

881
00:34:33,168 --> 00:34:35,859
literally it's we're just seeding it

882
00:34:34,460 --> 00:34:38,329
with these constant values there's these

883
00:34:35,859 --> 00:34:41,719
transforms that are gonna happen these

884
00:34:38,329 --> 00:34:42,770
these sort of magic values if you do

885
00:34:41,719 --> 00:34:43,879
pull out of like Overson during these

886
00:34:42,770 --> 00:34:45,339
areas you literally can just recognize

887
00:34:43,879 --> 00:34:47,540
them but it sure is nice to have a

888
00:34:45,339 --> 00:34:48,980
plugin that will just go find them for

889
00:34:47,540 --> 00:34:51,500
you and tell you like yeah these are all

890
00:34:48,980 --> 00:34:54,500
a md5 don't waste you know your time

891
00:34:51,500 --> 00:34:56,480
reversing them so let's go ahead and run

892
00:34:54,500 --> 00:34:58,400
this particular plugin we've got our

893
00:34:56,480 --> 00:35:01,069
binary we're gonna do is cause gain for

894
00:34:58,400 --> 00:35:02,329
crypto and it's gonna go look for all

895
00:35:01,069 --> 00:35:03,470
the constants and we're gonna find some

896
00:35:02,329 --> 00:35:06,740
results like okay so there's two

897
00:35:03,470 --> 00:35:09,799
separate sections this font is a little

898
00:35:06,740 --> 00:35:11,450
bit small it's the zoom it up here we've

899
00:35:09,800 --> 00:35:13,490
got our data constants and we've got our

900
00:35:11,450 --> 00:35:15,950
IL constants right and so you can see in

901
00:35:13,490 --> 00:35:17,479
this case it turns out md5 and kasumi

902
00:35:15,950 --> 00:35:18,950
which i've never heard from apparently

903
00:35:17,480 --> 00:35:20,089
share or have there's different

904
00:35:18,950 --> 00:35:22,368
constants but they're both in this

905
00:35:20,089 --> 00:35:24,560
sample so maybe this is a variant of md5

906
00:35:22,369 --> 00:35:26,630
like the kasumi implementation only five

907
00:35:24,560 --> 00:35:27,920
i didn't know that so that's a lesson

908
00:35:26,630 --> 00:35:31,970
learned and i can click any address and

909
00:35:27,920 --> 00:35:33,410
I can go see where that where that

910
00:35:31,970 --> 00:35:35,779
constant kind of came from like you can

911
00:35:33,410 --> 00:35:38,299
see yep there's our data in our data

912
00:35:35,780 --> 00:35:39,050
segment here data section they contain

913
00:35:38,299 --> 00:35:40,700
some of these constants

914
00:35:39,050 --> 00:35:42,080
great we found them okay but what

915
00:35:40,700 --> 00:35:44,299
happens off a piece of malware just like

916
00:35:42,080 --> 00:35:47,990
decides to obfuscate these constants at

917
00:35:44,300 --> 00:35:49,610
all like maybe they're going to let's go

918
00:35:47,990 --> 00:35:51,830
here to my modified one and now

919
00:35:49,610 --> 00:35:55,970
literally all I'm doing is I'm gonna XOR

920
00:35:51,830 --> 00:35:58,460
it with ace before before I initialize

921
00:35:55,970 --> 00:35:59,959
that structure right so I built that as

922
00:35:58,460 --> 00:36:05,620
a library and now if we open up that

923
00:35:59,960 --> 00:36:05,620
binary we've got our obfuscated version

924
00:36:06,640 --> 00:36:13,129
scan for crypto we still find some stuff

925
00:36:11,330 --> 00:36:14,750
now like why is that right so if we look

926
00:36:13,130 --> 00:36:16,400
here now we've just got these il

927
00:36:14,750 --> 00:36:17,810
constants so those data constants are

928
00:36:16,400 --> 00:36:20,240
gone because if we look in the data

929
00:36:17,810 --> 00:36:22,299
section we're not gonna find so if we

930
00:36:20,240 --> 00:36:29,799
look before we were at address 1 1 7 0

931
00:36:22,300 --> 00:36:29,800
so let's go to misty here

932
00:36:35,080 --> 00:36:38,860
so these particular constants here it's

933
00:36:37,780 --> 00:36:41,080
actually the address is different on

934
00:36:38,860 --> 00:36:42,790
this one are not the same constants

935
00:36:41,080 --> 00:36:44,470
right because they got X or like this is

936
00:36:42,790 --> 00:36:46,150
this is not hard but the problem now is

937
00:36:44,470 --> 00:36:47,740
that our our sort of library isn't gonna

938
00:36:46,150 --> 00:36:49,320
be able to find them but this plugin

939
00:36:47,740 --> 00:36:51,609
still worked like how did this plugin

940
00:36:49,320 --> 00:36:53,320
still solve this problem and if we look

941
00:36:51,610 --> 00:36:55,330
at the source code here for crypto scan

942
00:36:53,320 --> 00:36:57,190
we can see what they're doing is they're

943
00:36:55,330 --> 00:36:59,080
actually pulling their constants out of

944
00:36:57,190 --> 00:37:00,190
the intermediate representation they're

945
00:36:59,080 --> 00:37:02,230
pulling it out of in this case the

946
00:37:00,190 --> 00:37:03,460
medium level of il because again I

947
00:37:02,230 --> 00:37:04,300
didn't care about stack and so they just

948
00:37:03,460 --> 00:37:06,430
want to do the kind of higher level

949
00:37:04,300 --> 00:37:09,130
abstraction and so if we go back and

950
00:37:06,430 --> 00:37:12,190
look let's take just a second it's worth

951
00:37:09,130 --> 00:37:14,050
commenting that this is because by 9

952
00:37:12,190 --> 00:37:16,270
inches il is sort of tree based you're

953
00:37:14,050 --> 00:37:17,770
gonna either need like a work queue or a

954
00:37:16,270 --> 00:37:20,290
visitor function you can't just kind of

955
00:37:17,770 --> 00:37:21,640
like linearly scan over each instruction

956
00:37:20,290 --> 00:37:23,259
you have to kind of recurse then into

957
00:37:21,640 --> 00:37:25,480
into it because each instruction could

958
00:37:23,260 --> 00:37:26,290
be a tree of expressions and so you'll

959
00:37:25,480 --> 00:37:27,910
see that this is a pretty

960
00:37:26,290 --> 00:37:30,550
straightforward here this is a recursive

961
00:37:27,910 --> 00:37:31,930
tree of constants and it works the way

962
00:37:30,550 --> 00:37:34,300
you'd expect if it's currently a

963
00:37:31,930 --> 00:37:35,890
constant value it adds that to the the

964
00:37:34,300 --> 00:37:37,660
results list otherwise it recursively

965
00:37:35,890 --> 00:37:38,680
goes through all the operands all right

966
00:37:37,660 --> 00:37:40,270
so it will just literally take every

967
00:37:38,680 --> 00:37:41,890
instruction or cursive look through it

968
00:37:40,270 --> 00:37:43,180
for these these constants and like

969
00:37:41,890 --> 00:37:44,589
that's it there's actually lots of other

970
00:37:43,180 --> 00:37:45,700
code in this thing to handle the library

971
00:37:44,590 --> 00:37:47,290
and to build a list and to generate the

972
00:37:45,700 --> 00:37:48,730
report like that's it though

973
00:37:47,290 --> 00:37:52,870
that's all it takes to find this

974
00:37:48,730 --> 00:37:57,060
constants and if we go back to our fine

975
00:37:52,870 --> 00:38:00,009
if we go back to our binary in the

976
00:37:57,060 --> 00:38:02,440
initialization function we can see that

977
00:38:00,010 --> 00:38:04,330
we just see this is one of those magic

978
00:38:02,440 --> 00:38:06,490
constants right there it's showing up an

979
00:38:04,330 --> 00:38:07,779
annotation on the side because the

980
00:38:06,490 --> 00:38:09,759
dataflow system is like well I'm just

981
00:38:07,780 --> 00:38:10,900
reading this constant value comes out of

982
00:38:09,760 --> 00:38:12,790
the data section so I know it's

983
00:38:10,900 --> 00:38:15,760
read-only it's being XOR with this other

984
00:38:12,790 --> 00:38:17,290
constant value therefore I know that the

985
00:38:15,760 --> 00:38:18,520
cost of value is currently this like

986
00:38:17,290 --> 00:38:19,630
that doesn't actually appear anywhere in

987
00:38:18,520 --> 00:38:22,390
the disassembly if you look at bugger

988
00:38:19,630 --> 00:38:23,950
you'll see it only in the registers at

989
00:38:22,390 --> 00:38:25,270
that moment but you'll never see it in

990
00:38:23,950 --> 00:38:26,680
the in estatic this assembly so that's

991
00:38:25,270 --> 00:38:29,130
one of the nice things you get by like

992
00:38:26,680 --> 00:38:32,319
having this kind of dataflow analysis

993
00:38:29,130 --> 00:38:34,680
the next problem that we're gonna have

994
00:38:32,320 --> 00:38:34,680
is

995
00:38:39,010 --> 00:38:44,090
fireEye did a great blog post a couple

996
00:38:42,530 --> 00:38:46,550
years back where they talked about a

997
00:38:44,090 --> 00:38:47,630
dynamic a function resolution so they

998
00:38:46,550 --> 00:38:49,070
were talking about a particular piece of

999
00:38:47,630 --> 00:38:50,180
malware that was hiding its

1000
00:38:49,070 --> 00:38:52,400
functionality so like you know one of

1001
00:38:50,180 --> 00:38:53,779
the most kind of the two quick quickest

1002
00:38:52,400 --> 00:38:55,190
ways to find out the functionality of a

1003
00:38:53,780 --> 00:38:57,109
binary are look for all the strings and

1004
00:38:55,190 --> 00:38:58,490
look for all the imports right like what

1005
00:38:57,109 --> 00:39:01,430
are all the libraries that this thing

1006
00:38:58,490 --> 00:39:04,040
calls in to unfortunately many pieces of

1007
00:39:01,430 --> 00:39:05,990
code will dynamically resolve libraries

1008
00:39:04,040 --> 00:39:07,369
so they use DL sim they use git proc

1009
00:39:05,990 --> 00:39:09,439
adder depending on the platform and

1010
00:39:07,369 --> 00:39:10,880
they'll actually load these libraries

1011
00:39:09,440 --> 00:39:11,900
they'll get a function out of it and

1012
00:39:10,880 --> 00:39:13,580
then they'll call in to that function

1013
00:39:11,900 --> 00:39:14,869
but you'll never see it in the import

1014
00:39:13,580 --> 00:39:16,460
list and so if you're just trying to

1015
00:39:14,869 --> 00:39:18,530
kind of quickly scan a binary you won't

1016
00:39:16,460 --> 00:39:19,970
see what this functionality is so like

1017
00:39:18,530 --> 00:39:21,920
this is like this it's called a tree as

1018
00:39:19,970 --> 00:39:23,959
you it just shows the imports on a

1019
00:39:21,920 --> 00:39:25,880
particular binary and this is actually

1020
00:39:23,960 --> 00:39:28,880
one of our binary ninja libraries we

1021
00:39:25,880 --> 00:39:30,200
have a Python loader because it can work

1022
00:39:28,880 --> 00:39:32,150
with different versions of Python will

1023
00:39:30,200 --> 00:39:33,230
actually load the library for Python on

1024
00:39:32,150 --> 00:39:34,400
the fly and you can have different

1025
00:39:33,230 --> 00:39:37,270
settings for different versions of

1026
00:39:34,400 --> 00:39:39,680
Python but we don't see any Python api's

1027
00:39:37,270 --> 00:39:41,180
here because they're dynamically loaded

1028
00:39:39,680 --> 00:39:42,710
they're actually called in here with I

1029
00:39:41,180 --> 00:39:44,750
see this one is a elf so this one's

1030
00:39:42,710 --> 00:39:47,359
going to be DL sim that's going to work

1031
00:39:44,750 --> 00:39:49,280
on and if I do this load dynamic imports

1032
00:39:47,359 --> 00:39:50,990
and it works yeah we got some more

1033
00:39:49,280 --> 00:39:53,600
things down here so now we can actually

1034
00:39:50,990 --> 00:39:55,160
see that we've got new imports that are

1035
00:39:53,600 --> 00:39:57,259
actually showing up so these are Python

1036
00:39:55,160 --> 00:39:58,940
API is that are being called from we can

1037
00:39:57,260 --> 00:40:02,000
and most importantly we don't just see

1038
00:39:58,940 --> 00:40:03,830
so like this was somewhere in the the

1039
00:40:02,000 --> 00:40:05,150
BSS right so it's gonna be initialize to

1040
00:40:03,830 --> 00:40:07,819
zero if we actually go over and open

1041
00:40:05,150 --> 00:40:15,350
this binary again and go to that same

1042
00:40:07,820 --> 00:40:17,600
address we copy the address outs and go

1043
00:40:15,350 --> 00:40:19,160
to address right these are just there's

1044
00:40:17,600 --> 00:40:21,589
nothing there like the normal binary has

1045
00:40:19,160 --> 00:40:22,640
just zeros but because the deal sim is

1046
00:40:21,590 --> 00:40:24,320
going to be loading these function

1047
00:40:22,640 --> 00:40:26,810
pointers at that location

1048
00:40:24,320 --> 00:40:29,020
this load dynamic function pointers is

1049
00:40:26,810 --> 00:40:32,210
actually going to create pointers here

1050
00:40:29,020 --> 00:40:33,710
to to these functions and now we

1051
00:40:32,210 --> 00:40:34,550
actually have cross references and so

1052
00:40:33,710 --> 00:40:37,430
that's actually what makes it really

1053
00:40:34,550 --> 00:40:38,570
nice is anything that calls that calls

1054
00:40:37,430 --> 00:40:39,919
through that you can see there's an

1055
00:40:38,570 --> 00:40:41,750
indirect crawl through that pointer

1056
00:40:39,920 --> 00:40:44,210
address we've actually got that that

1057
00:40:41,750 --> 00:40:46,880
symbol name and I can switch over to the

1058
00:40:44,210 --> 00:40:48,109
il view and actually looks like a call

1059
00:40:46,880 --> 00:40:49,310
like it's got a call to that function

1060
00:40:48,109 --> 00:40:50,750
you can see all that kind of useful

1061
00:40:49,310 --> 00:40:52,040
stuff so this is a little bit like a

1062
00:40:50,750 --> 00:40:53,720
dynamic bit of function

1063
00:40:52,040 --> 00:40:55,850
normally to get this kind of dynamic

1064
00:40:53,720 --> 00:40:57,859
resolution you would actually have to do

1065
00:40:55,850 --> 00:40:58,759
it on a debugger and you have to

1066
00:40:57,860 --> 00:40:59,840
breakpoint there you have to pull it

1067
00:40:58,760 --> 00:41:02,000
back out make sure you got it or you

1068
00:40:59,840 --> 00:41:02,990
have to manually fix these up so this is

1069
00:41:02,000 --> 00:41:04,730
a nice way that the intermediate

1070
00:41:02,990 --> 00:41:06,310
language kind of gives you some that you

1071
00:41:04,730 --> 00:41:09,140
can even propagate type information

1072
00:41:06,310 --> 00:41:11,779
little more that so the the code for

1073
00:41:09,140 --> 00:41:14,299
that one is actually primarily right

1074
00:41:11,780 --> 00:41:16,790
here where it's looking for calls to the

1075
00:41:14,300 --> 00:41:18,350
addresses and then it's going to create

1076
00:41:16,790 --> 00:41:20,930
the type information and just apply it

1077
00:41:18,350 --> 00:41:23,270
at at that address so again it's going

1078
00:41:20,930 --> 00:41:26,089
to be this recursive like walk over the

1079
00:41:23,270 --> 00:41:27,380
whole thing look for the calls and then

1080
00:41:26,090 --> 00:41:30,050
make sure it's one of the things that we

1081
00:41:27,380 --> 00:41:31,550
care about and it's going to pull out

1082
00:41:30,050 --> 00:41:34,220
the argument to the deal same or get

1083
00:41:31,550 --> 00:41:36,230
proc adder the advantage of the i/o here

1084
00:41:34,220 --> 00:41:38,990
one of the advantages is that this works

1085
00:41:36,230 --> 00:41:40,790
out of the box on both Pease and elfs

1086
00:41:38,990 --> 00:41:42,770
Mac Linux windows or works on all of

1087
00:41:40,790 --> 00:41:44,540
them because at the top all it does is

1088
00:41:42,770 --> 00:41:46,070
to say well on Windows I'm looking for

1089
00:41:44,540 --> 00:41:48,230
get proc address and get proc outages

1090
00:41:46,070 --> 00:41:49,640
out ite entries and on linux freebsd at

1091
00:41:48,230 --> 00:41:51,500
mac i'm looking for these other api's

1092
00:41:49,640 --> 00:41:53,150
but they actually just work essentially

1093
00:41:51,500 --> 00:41:54,260
the same so it can resolve all these and

1094
00:41:53,150 --> 00:41:55,970
this is literally the only

1095
00:41:54,260 --> 00:41:58,190
platform-specific code kind of in the

1096
00:41:55,970 --> 00:41:59,870
whole thing and so you get that sort of

1097
00:41:58,190 --> 00:42:01,010
portability of platform and even

1098
00:41:59,870 --> 00:42:02,540
architecture right if this was something

1099
00:42:01,010 --> 00:42:05,150
compiled for the architecture it would

1100
00:42:02,540 --> 00:42:08,320
just work with with no changes all right

1101
00:42:05,150 --> 00:42:11,360
so we go back to the slides

1102
00:42:08,320 --> 00:42:13,010
there are demos if you have any

1103
00:42:11,360 --> 00:42:14,780
questions we would love to talk to you

1104
00:42:13,010 --> 00:42:16,720
we're going to over the side thanks for

1105
00:42:14,780 --> 00:42:22,120
staying with us thanks for staying awake

1106
00:42:16,720 --> 00:42:22,120
[Applause]

