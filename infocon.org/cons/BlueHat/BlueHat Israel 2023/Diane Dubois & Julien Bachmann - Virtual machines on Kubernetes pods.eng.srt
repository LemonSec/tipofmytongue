1
00:00:00,000 --> 00:00:08,700
[Music]

2
00:00:09,679 --> 00:00:11,440
thank you

3
00:00:11,440 --> 00:00:13,500
[Music]

4
00:00:13,500 --> 00:00:15,780
hi everyone thanks for joining us today

5
00:00:15,780 --> 00:00:17,640
for our talk on Virtual machines on

6
00:00:17,640 --> 00:00:19,920
kubernetes pads one more of a year of

7
00:00:19,920 --> 00:00:23,939
security right and also we want to thank

8
00:00:23,939 --> 00:00:26,580
you for welcoming Us in Tel Aviv at Blue

9
00:00:26,580 --> 00:00:30,198
hatiel we are delighted to be here

10
00:00:33,680 --> 00:00:35,760
thank you

11
00:00:35,760 --> 00:00:37,500
so we are going to start by introducing

12
00:00:37,500 --> 00:00:40,020
ourselves my name is Jan I'm a security

13
00:00:40,020 --> 00:00:42,780
engineer at Google I work as a varnavity

14
00:00:42,780 --> 00:00:45,420
researcher on cloud products so in other

15
00:00:45,420 --> 00:00:47,820
words our motto is High Cloud

16
00:00:47,820 --> 00:00:50,100
and I focused on low-level platforms

17
00:00:50,100 --> 00:00:52,680
such as the hypervisors the firmware

18
00:00:52,680 --> 00:00:55,440
operating systems let's say presented

19
00:00:55,440 --> 00:00:57,360
here on hypervising this year it will be

20
00:00:57,360 --> 00:00:58,739
a bit of a different topic

21
00:00:58,739 --> 00:01:00,239
and I'm also an active Community

22
00:01:00,239 --> 00:01:02,940
contributor entering participating at

23
00:01:02,940 --> 00:01:04,379
for example reviewing papers for

24
00:01:04,379 --> 00:01:06,540
conferences being a proud member of

25
00:01:06,540 --> 00:01:10,700
women in security associations also

26
00:01:11,220 --> 00:01:12,960
um my name is Julian and also a security

27
00:01:12,960 --> 00:01:15,960
engineer at Google I focus on cloud

28
00:01:15,960 --> 00:01:18,720
product ordering so we also try to find

29
00:01:18,720 --> 00:01:20,580
vulnerabilities in product but we also

30
00:01:20,580 --> 00:01:22,320
look at root causes of vulnerabilities

31
00:01:22,320 --> 00:01:25,439
and to propose mitigation to and and

32
00:01:25,439 --> 00:01:28,439
auditing solutions to tackle

33
00:01:28,439 --> 00:01:30,840
vulnerability classes at scale

34
00:01:30,840 --> 00:01:34,140
and also a member of the blackals.ch

35
00:01:34,140 --> 00:01:39,020
organizer and our cfp will open soon so

36
00:01:39,840 --> 00:01:42,140
so what are we going to talk about today

37
00:01:42,140 --> 00:01:44,880
first let's go back to the title virtual

38
00:01:44,880 --> 00:01:47,640
machines on kubernetes spots first what

39
00:01:47,640 --> 00:01:49,560
is kubernetes so I don't know in case

40
00:01:49,560 --> 00:01:51,180
some people have never heard of it I've

41
00:01:51,180 --> 00:01:53,460
never used it you can think of

42
00:01:53,460 --> 00:01:55,920
kubernetes as being kind of Docker on

43
00:01:55,920 --> 00:01:59,040
cloud platforms so in other words it's

44
00:01:59,040 --> 00:02:01,680
an open source system for automating the

45
00:02:01,680 --> 00:02:04,020
deployment and scaling and management

46
00:02:04,020 --> 00:02:08,299
also of containerized applications

47
00:02:10,160 --> 00:02:13,260
that enables running virtual machines on

48
00:02:13,260 --> 00:02:14,819
kubernetes parts

49
00:02:14,819 --> 00:02:17,760
so I'm going to insist a bit on that we

50
00:02:17,760 --> 00:02:19,319
are not speaking about kubernetes

51
00:02:19,319 --> 00:02:22,440
running possibly on Virtual machines we

52
00:02:22,440 --> 00:02:24,180
are speaking about virtual machines

53
00:02:24,180 --> 00:02:27,599
running inside kubernetes spots

54
00:02:27,599 --> 00:02:31,920
and also you may wonder why uh why do

55
00:02:31,920 --> 00:02:34,800
you why do that this is to support some

56
00:02:34,800 --> 00:02:37,260
customers who want it I mean who used to

57
00:02:37,260 --> 00:02:39,120
render applications on the other

58
00:02:39,120 --> 00:02:41,040
machines and wanted to put those use

59
00:02:41,040 --> 00:02:43,860
cases to kubernetes and to make it more

60
00:02:43,860 --> 00:02:47,360
seamless for them to watch

61
00:02:48,840 --> 00:02:51,780
so some people may think I'm not saying

62
00:02:51,780 --> 00:02:53,940
this is true but some people may think

63
00:02:53,940 --> 00:02:55,980
that containerization in place

64
00:02:55,980 --> 00:02:58,440
sandboxing and some people may think

65
00:02:58,440 --> 00:03:01,319
that virtualizations means more security

66
00:03:01,319 --> 00:03:03,780
okay so those people may think oh great

67
00:03:03,780 --> 00:03:06,360
so then there's more security so this is

68
00:03:06,360 --> 00:03:08,879
a kind of sandboxing plus plus awesome

69
00:03:08,879 --> 00:03:11,459
and actually we wanted to question that

70
00:03:11,459 --> 00:03:15,120
that was one of our main motivations to

71
00:03:15,120 --> 00:03:17,099
look at that stack

72
00:03:17,099 --> 00:03:20,340
so could it be deceptively secure

73
00:03:20,340 --> 00:03:24,360
and also we are working at Google and

74
00:03:24,360 --> 00:03:26,220
this is used on Google Cloud so we

75
00:03:26,220 --> 00:03:27,720
wanted to make sure that the product was

76
00:03:27,720 --> 00:03:28,860
safe

77
00:03:28,860 --> 00:03:32,459
secure it's used for example for enters

78
00:03:32,459 --> 00:03:35,580
for distributed Cloud Edge and hosted

79
00:03:35,580 --> 00:03:37,680
and also we have the support of an

80
00:03:37,680 --> 00:03:39,300
internal engineering team which helped

81
00:03:39,300 --> 00:03:42,239
quite a lot and as it's kind of new we

82
00:03:42,239 --> 00:03:45,000
are not going back in time too far but

83
00:03:45,000 --> 00:03:47,459
that was also a motivation like looking

84
00:03:47,459 --> 00:03:48,840
at some new piece of code that does

85
00:03:48,840 --> 00:03:51,440
virtualization

86
00:03:51,840 --> 00:03:53,580
so first we're going to cover some

87
00:03:53,580 --> 00:03:55,080
background information on Cuba today

88
00:03:55,080 --> 00:03:57,060
then we're going to talk about our

89
00:03:57,060 --> 00:04:00,000
findings what we broke then talk about

90
00:04:00,000 --> 00:04:01,980
the remediation and hardening how to fix

91
00:04:01,980 --> 00:04:04,159
it

92
00:04:06,480 --> 00:04:08,459
so first some background information on

93
00:04:08,459 --> 00:04:11,000
cubits

94
00:04:11,459 --> 00:04:13,739
let's make sure to start with that we

95
00:04:13,739 --> 00:04:17,339
speak the same language so first you may

96
00:04:17,339 --> 00:04:20,339
have heard me talk about buds pods

97
00:04:20,339 --> 00:04:23,060
container container but the same

98
00:04:23,060 --> 00:04:26,880
also we're going to talk about crds crds

99
00:04:26,880 --> 00:04:30,360
stands for custom resource decorations

100
00:04:30,360 --> 00:04:33,180
these are definitions that are added to

101
00:04:33,180 --> 00:04:35,699
the default kubernetes to extend use

102
00:04:35,699 --> 00:04:38,580
cases and Define new types new objects

103
00:04:38,580 --> 00:04:41,160
new apis to allow for more unique use

104
00:04:41,160 --> 00:04:42,120
cases

105
00:04:42,120 --> 00:04:44,460
also we are going to talk about CML file

106
00:04:44,460 --> 00:04:46,740
so yaml is a file format and it's used

107
00:04:46,740 --> 00:04:50,400
to define the specifications to Define

108
00:04:50,400 --> 00:04:53,599
new objects for example

109
00:04:55,199 --> 00:04:58,020
so when looking at the whole stack let's

110
00:04:58,020 --> 00:05:01,500
take a server that runs in Cloud

111
00:05:01,500 --> 00:05:03,720
um first layer is the hardware layer the

112
00:05:03,720 --> 00:05:05,400
physical layer on top of that that's the

113
00:05:05,400 --> 00:05:08,280
operating system with KVM and actually

114
00:05:08,280 --> 00:05:11,220
this is important for what comes next

115
00:05:11,220 --> 00:05:13,440
the operating system runs on top of that

116
00:05:13,440 --> 00:05:15,540
there's the kubernetes stack with the

117
00:05:15,540 --> 00:05:18,560
orchestrator the container runtime

118
00:05:18,560 --> 00:05:21,720
scheduling everything kubernetes related

119
00:05:21,720 --> 00:05:24,060
and that you know yet on top of that

120
00:05:24,060 --> 00:05:25,919
there's keywords

121
00:05:25,919 --> 00:05:29,580
and at that level we can find libert qmu

122
00:05:29,580 --> 00:05:32,460
and that qmu is actually here using the

123
00:05:32,460 --> 00:05:35,780
KVM we were mentioning before

124
00:05:37,740 --> 00:05:41,039
so how does it work internally so we

125
00:05:41,039 --> 00:05:43,320
have two set of components we have one

126
00:05:43,320 --> 00:05:45,479
first set that is running on a control

127
00:05:45,479 --> 00:05:48,060
plane node but what we call named

128
00:05:48,060 --> 00:05:50,100
cluster component in in this so those

129
00:05:50,100 --> 00:05:52,020
are special node running privileged

130
00:05:52,020 --> 00:05:54,840
containers we have some new set of

131
00:05:54,840 --> 00:05:57,060
controllers or per deployer by

132
00:05:57,060 --> 00:05:59,160
equivalent so we are controller virt API

133
00:05:59,160 --> 00:06:01,280
and we also have a worker node

134
00:06:01,280 --> 00:06:04,080
kubernetes cluster that are running

135
00:06:04,080 --> 00:06:06,180
typically the workload that you want to

136
00:06:06,180 --> 00:06:08,699
deploy let's say a web front-end or

137
00:06:08,699 --> 00:06:10,680
anything else like that and in the case

138
00:06:10,680 --> 00:06:13,740
of cubework it will be virtual machines

139
00:06:13,740 --> 00:06:16,500
so how does it start

140
00:06:16,500 --> 00:06:20,220
it's taught by a yaml file that you will

141
00:06:20,220 --> 00:06:22,199
you so you will Define your virtual

142
00:06:22,199 --> 00:06:25,080
machine using a specific type of object

143
00:06:25,080 --> 00:06:28,199
as a new crd for virtual machine you

144
00:06:28,199 --> 00:06:31,020
will write this file use Capital command

145
00:06:31,020 --> 00:06:34,919
line tool to push it so on kubernetes

146
00:06:34,919 --> 00:06:37,560
side it will be received by the API

147
00:06:37,560 --> 00:06:40,139
server the API server will analyze the

148
00:06:40,139 --> 00:06:42,360
XML file and internally the virt

149
00:06:42,360 --> 00:06:45,180
controller is watching for new event the

150
00:06:45,180 --> 00:06:47,759
creation of a new virtual machine so it

151
00:06:47,759 --> 00:06:50,639
will take this ml file analyze it

152
00:06:50,639 --> 00:06:53,100
and then later on when you will start

153
00:06:53,100 --> 00:06:55,020
the virtual machine through the virtual

154
00:06:55,020 --> 00:06:57,600
API that will receive this request the

155
00:06:57,600 --> 00:07:00,180
virtual machine object will get

156
00:07:00,180 --> 00:07:02,160
scheduled onto a specific worker node

157
00:07:02,160 --> 00:07:04,800
and on this working node we will have a

158
00:07:04,800 --> 00:07:07,860
specific pod named virtendler that's

159
00:07:07,860 --> 00:07:09,780
deployed as a demon set so it's running

160
00:07:09,780 --> 00:07:12,060
on all the nodes of your cluster

161
00:07:12,060 --> 00:07:16,080
and in that case then it will analyze

162
00:07:16,080 --> 00:07:19,080
the the yaml file it will instantiate a

163
00:07:19,080 --> 00:07:22,319
new a new pod that's named VF launcher

164
00:07:22,319 --> 00:07:24,539
that we see here and in this new part

165
00:07:24,539 --> 00:07:26,940
we'll have an instance of Liberty that

166
00:07:26,940 --> 00:07:29,039
will be running and we will also later

167
00:07:29,039 --> 00:07:31,500
on have an instance of Q new

168
00:07:31,500 --> 00:07:34,020
so this file from yaml will be

169
00:07:34,020 --> 00:07:38,160
translated to XML it's the domain domain

170
00:07:38,160 --> 00:07:41,120
XML format from Libya G

171
00:07:41,120 --> 00:07:43,800
received by the path to the launcher

172
00:07:43,800 --> 00:07:46,819
through a communication mechanism

173
00:07:46,819 --> 00:07:50,520
and then libyod will use this XML to use

174
00:07:50,520 --> 00:07:53,639
vrsh and then create an instance of qmu

175
00:07:53,639 --> 00:07:56,220
using this uh this file and if you're

176
00:07:56,220 --> 00:07:58,380
using Hardware acceleration it will also

177
00:07:58,380 --> 00:08:01,919
use KVM behind and one important thing

178
00:08:01,919 --> 00:08:05,220
to note is that it's not a new CRI like

179
00:08:05,220 --> 00:08:07,500
virtual machine and kubernetes sometimes

180
00:08:07,500 --> 00:08:09,720
you can you might have heard of gvisor

181
00:08:09,720 --> 00:08:12,539
or Kata container which are CRI and in

182
00:08:12,539 --> 00:08:15,120
this case you you create your pod within

183
00:08:15,120 --> 00:08:17,639
the VM in this case we have standard pod

184
00:08:17,639 --> 00:08:20,940
running Linux processors so qmu that

185
00:08:20,940 --> 00:08:23,400
will then create the virtual machines

186
00:08:23,400 --> 00:08:25,139
and if you create multiple virtual

187
00:08:25,139 --> 00:08:26,819
machines you will have multiple

188
00:08:26,819 --> 00:08:30,319
instances of um

189
00:08:30,319 --> 00:08:33,539
launcher pod with each one each time

190
00:08:33,539 --> 00:08:37,020
it's in some sense of Libya D and qmu

191
00:08:37,020 --> 00:08:39,659
so that means that we have new crg new

192
00:08:39,659 --> 00:08:42,839
type of resources new backend function

193
00:08:42,839 --> 00:08:46,020
to handle those and new API so in the

194
00:08:46,020 --> 00:08:47,760
sense of documentaries cluster you're

195
00:08:47,760 --> 00:08:51,140
increasing your attack surface

196
00:08:51,480 --> 00:08:53,580
so let's say you want to start using

197
00:08:53,580 --> 00:08:55,920
convert where do you start it's actually

198
00:08:55,920 --> 00:08:57,360
quite easy so you you have your

199
00:08:57,360 --> 00:09:00,360
kubernetes instance you need to enable

200
00:09:00,360 --> 00:09:02,940
first the convert add-on then you will

201
00:09:02,940 --> 00:09:04,399
install the

202
00:09:04,399 --> 00:09:08,459
vietcato which is a helper here you will

203
00:09:08,459 --> 00:09:10,800
create a yaml file to describe what VM

204
00:09:10,800 --> 00:09:12,660
you want to create and this is an

205
00:09:12,660 --> 00:09:14,339
example of a functional EML file like a

206
00:09:14,339 --> 00:09:15,440
small one so

207
00:09:15,440 --> 00:09:18,959
so for example here you will Define you

208
00:09:18,959 --> 00:09:20,700
define it as the kind virtual machine

209
00:09:20,700 --> 00:09:22,860
and some fields are mandatory like for

210
00:09:22,860 --> 00:09:25,440
example the VM name and this is the

211
00:09:25,440 --> 00:09:26,940
place where you can specify all the

212
00:09:26,940 --> 00:09:28,980
specifications for your VM like for

213
00:09:28,980 --> 00:09:30,600
example the number of CPUs you may want

214
00:09:30,600 --> 00:09:34,140
the kind of storage you may want all

215
00:09:34,140 --> 00:09:36,240
those details or if you want the GPU I

216
00:09:36,240 --> 00:09:38,640
mean you got it

217
00:09:38,640 --> 00:09:40,980
so you create your yaml file and then

218
00:09:40,980 --> 00:09:44,880
with Cube Kettle you can apply it so

219
00:09:44,880 --> 00:09:46,500
cubecutor play

220
00:09:46,500 --> 00:09:49,080
your specifications if everything is

221
00:09:49,080 --> 00:09:52,980
correct then it will create the VM once

222
00:09:52,980 --> 00:09:54,300
it is created you can start it with yet

223
00:09:54,300 --> 00:09:56,880
Kettle and then once the VMware is

224
00:09:56,880 --> 00:09:58,860
started you can get to share onto it

225
00:09:58,860 --> 00:10:01,459
with console

226
00:10:03,660 --> 00:10:05,700
so we had to think about the threat

227
00:10:05,700 --> 00:10:09,240
model as a cloud provider we wanted to

228
00:10:09,240 --> 00:10:12,600
stay in that scope and we considered uh

229
00:10:12,600 --> 00:10:14,820
just the Viet handlers trusted so the

230
00:10:14,820 --> 00:10:16,920
vet hundred is kind of the broker for

231
00:10:16,920 --> 00:10:19,080
the virtual machine so dealing with the

232
00:10:19,080 --> 00:10:20,880
whole logic and also the cluster

233
00:10:20,880 --> 00:10:22,920
components like everything related to

234
00:10:22,920 --> 00:10:24,600
kubernetes because we consider it was a

235
00:10:24,600 --> 00:10:26,279
bit out of scope here

236
00:10:26,279 --> 00:10:28,620
and we considered untrusted everything

237
00:10:28,620 --> 00:10:31,019
tied to the user or related to the user

238
00:10:31,019 --> 00:10:33,660
like for example the Viet launcher the

239
00:10:33,660 --> 00:10:38,580
VMS and also all the workloads on the on

240
00:10:38,580 --> 00:10:40,260
the other work so on the kubernetes

241
00:10:40,260 --> 00:10:41,940
cluster

242
00:10:41,940 --> 00:10:44,820
and we had to think about the ways to

243
00:10:44,820 --> 00:10:48,240
attack cuberts next and actually first

244
00:10:48,240 --> 00:10:50,760
as its virtualization solution like all

245
00:10:50,760 --> 00:10:53,459
the virtualization typical threads had

246
00:10:53,459 --> 00:10:54,720
to be considered like for example

247
00:10:54,720 --> 00:10:57,540
devices pass through to name it to name

248
00:10:57,540 --> 00:11:00,420
one of them but also threats coming from

249
00:11:00,420 --> 00:11:03,060
the combination of containerization and

250
00:11:03,060 --> 00:11:06,180
digitalization like for example guest 2

251
00:11:06,180 --> 00:11:08,279
host by passing The Sandbox using the

252
00:11:08,279 --> 00:11:11,279
file system the network reporting but

253
00:11:11,279 --> 00:11:13,140
also other kinds of problems like

254
00:11:13,140 --> 00:11:15,839
encryption or race conditions or

255
00:11:15,839 --> 00:11:18,480
actually many other ones so I'm going

256
00:11:18,480 --> 00:11:20,279
I'm not going to go over all of them but

257
00:11:20,279 --> 00:11:22,800
just to say yes okay we consider the

258
00:11:22,800 --> 00:11:25,860
bunch of thread vectors so looking at

259
00:11:25,860 --> 00:11:27,959
all that where to start

260
00:11:27,959 --> 00:11:30,480
so the approach was to start Gathering

261
00:11:30,480 --> 00:11:32,040
some background information then Define

262
00:11:32,040 --> 00:11:34,620
the threat model do some scoping we got

263
00:11:34,620 --> 00:11:36,240
some first bugs at that point which was

264
00:11:36,240 --> 00:11:38,820
very encouraging but also we scaled it a

265
00:11:38,820 --> 00:11:41,640
bit we defined the security roadmap at

266
00:11:41,640 --> 00:11:43,019
some point we had nine Security reviews

267
00:11:43,019 --> 00:11:45,300
then reviewers on it we created some

268
00:11:45,300 --> 00:11:46,920
ramp up material to help them well that

269
00:11:46,920 --> 00:11:48,540
was kind of big at some points some

270
00:11:48,540 --> 00:11:50,820
magic happens and here we are to present

271
00:11:50,820 --> 00:11:54,920
the findings reports fixes

272
00:11:55,440 --> 00:11:59,360
so yeah let's get to the findings now

273
00:11:59,820 --> 00:12:01,860
um so first thing something we didn't

274
00:12:01,860 --> 00:12:02,959
mention

275
00:12:02,959 --> 00:12:05,579
Cube vert is written in go

276
00:12:05,579 --> 00:12:08,519
and go can be to some extent consider

277
00:12:08,519 --> 00:12:11,660
two memories as a memory safe language

278
00:12:11,660 --> 00:12:14,820
well to some extent because there's a

279
00:12:14,820 --> 00:12:17,399
garbage collector but it doesn't give

280
00:12:17,399 --> 00:12:20,940
the same Assurance as for example rust

281
00:12:20,940 --> 00:12:23,279
okay but we looked at some so we didn't

282
00:12:23,279 --> 00:12:24,779
look at those kind of bugs but we looked

283
00:12:24,779 --> 00:12:27,420
at uh other books such as batch

284
00:12:27,420 --> 00:12:30,300
reversals which are very common in go

285
00:12:30,300 --> 00:12:32,820
and actually for that Oliver Brooks and

286
00:12:32,820 --> 00:12:34,980
James clubchic of NC group raised

287
00:12:34,980 --> 00:12:38,339
Awareness on risky patterns for keywords

288
00:12:38,339 --> 00:12:40,560
so risky functions that maybe these

289
00:12:40,560 --> 00:12:43,320
susceptible to um I mean maybe prone to

290
00:12:43,320 --> 00:12:45,660
such attacks

291
00:12:45,660 --> 00:12:48,240
and here is the kind of syntax that's

292
00:12:48,240 --> 00:12:50,940
maybe problematic like file paths that

293
00:12:50,940 --> 00:12:54,899
join uh on a root on the child path so a

294
00:12:54,899 --> 00:12:56,700
function that joins root and childbirth

295
00:12:56,700 --> 00:12:58,980
together to form a new path so why is it

296
00:12:58,980 --> 00:13:00,420
a problem why may it be a problem

297
00:13:00,420 --> 00:13:02,519
actually

298
00:13:02,519 --> 00:13:05,639
well if one of the arguments is derived

299
00:13:05,639 --> 00:13:08,120
from user inputs without synthetization

300
00:13:08,120 --> 00:13:11,519
also if that function is in a piece of

301
00:13:11,519 --> 00:13:13,260
code that does sensitive operations such

302
00:13:13,260 --> 00:13:15,240
as for example mounting path from the

303
00:13:15,240 --> 00:13:17,220
host into the pad

304
00:13:17,220 --> 00:13:19,560
and if there's no security policy that

305
00:13:19,560 --> 00:13:21,839
applies then you may consider that code

306
00:13:21,839 --> 00:13:25,440
as a problem like if you take unmutable

307
00:13:25,440 --> 00:13:27,600
routes but a child pass that is for

308
00:13:27,600 --> 00:13:29,160
example that that stash that that slash

309
00:13:29,160 --> 00:13:31,980
Texas txt then the joint may not have

310
00:13:31,980 --> 00:13:35,519
the expected outcome

311
00:13:36,120 --> 00:13:39,660
so that's what we were looking for first

312
00:13:39,660 --> 00:13:41,600
attempt was to do a grab on such

313
00:13:41,600 --> 00:13:43,620
functions and there were lots of results

314
00:13:43,620 --> 00:13:46,680
so next thing was to trace the arguments

315
00:13:46,680 --> 00:13:48,060
app

316
00:13:48,060 --> 00:13:51,180
then create some tailored VM

317
00:13:51,180 --> 00:13:53,279
specifications so why do that that's

318
00:13:53,279 --> 00:13:55,500
because the user actually can choose

319
00:13:55,500 --> 00:13:59,639
what VM they want so they can manipulate

320
00:13:59,639 --> 00:14:01,800
the parameters and that's how we craft

321
00:14:01,800 --> 00:14:04,500
something derived from user inputs

322
00:14:04,500 --> 00:14:08,639
so creating some VM specifications which

323
00:14:08,639 --> 00:14:11,300
parameters are then used by the

324
00:14:11,300 --> 00:14:14,339
potentially vulnerable functions

325
00:14:14,339 --> 00:14:16,680
so this is an example like with name

326
00:14:16,680 --> 00:14:19,920
being that that slash that that's VM

327
00:14:19,920 --> 00:14:21,600
because one of the functions was

328
00:14:21,600 --> 00:14:23,040
consuming that

329
00:14:23,040 --> 00:14:26,399
however this didn't work because there

330
00:14:26,399 --> 00:14:28,920
are some checks done by something that

331
00:14:28,920 --> 00:14:31,560
is called the admitters that checks all

332
00:14:31,560 --> 00:14:33,540
the the content of the Via of the VM

333
00:14:33,540 --> 00:14:34,920
specifications

334
00:14:34,920 --> 00:14:37,079
so

335
00:14:37,079 --> 00:14:39,660
okay how to work around that looking

336
00:14:39,660 --> 00:14:42,240
closer at those VM admitters there are a

337
00:14:42,240 --> 00:14:43,860
list of functions that handle specific

338
00:14:43,860 --> 00:14:45,899
arguments which means that by default

339
00:14:45,899 --> 00:14:48,839
everything is allowed but the admitters

340
00:14:48,839 --> 00:14:50,699
check for some values or check for some

341
00:14:50,699 --> 00:14:52,500
parameters in particular

342
00:14:52,500 --> 00:14:54,300
so for example here it checks some

343
00:14:54,300 --> 00:14:57,300
behaviors on devices inputs

344
00:14:57,300 --> 00:14:59,040
the question is how can we find

345
00:14:59,040 --> 00:15:00,660
something and find a hole in that like

346
00:15:00,660 --> 00:15:02,100
how can we find the parameter that is

347
00:15:02,100 --> 00:15:03,300
not filtered

348
00:15:03,300 --> 00:15:06,060
or not enough

349
00:15:06,060 --> 00:15:08,820
and one of the cases was super

350
00:15:08,820 --> 00:15:11,760
interesting it was in containerdisc.go

351
00:15:11,760 --> 00:15:14,639
there was a join function and that

352
00:15:14,639 --> 00:15:17,040
function was mounting path so from the

353
00:15:17,040 --> 00:15:19,139
host into the bed

354
00:15:19,139 --> 00:15:22,139
and this parameter like image path the

355
00:15:22,139 --> 00:15:23,579
second one was derived from three

356
00:15:23,579 --> 00:15:25,560
different sources and one of them

357
00:15:25,560 --> 00:15:28,560
actually was not checked by the emitters

358
00:15:28,560 --> 00:15:30,740
so the next attempt was to create

359
00:15:30,740 --> 00:15:34,139
specifications create a container disk

360
00:15:34,139 --> 00:15:36,300
and natural you can see it but in the

361
00:15:36,300 --> 00:15:38,399
specification there's volumes under that

362
00:15:38,399 --> 00:15:39,899
there's container disk

363
00:15:39,899 --> 00:15:42,839
a legitimate image but the path is

364
00:15:42,839 --> 00:15:43,800
crafted

365
00:15:43,800 --> 00:15:47,940
test 3 then lots of Slash dot dots and

366
00:15:47,940 --> 00:15:49,500
Etc password because that's what we want

367
00:15:49,500 --> 00:15:53,000
to read to to check that it works

368
00:15:53,000 --> 00:15:56,760
and from in within the VM it worked so

369
00:15:56,760 --> 00:15:59,399
crafting the the VM specifications

370
00:15:59,399 --> 00:16:02,579
we start the VM and then from the VM we

371
00:16:02,579 --> 00:16:04,680
can read this password from The Host

372
00:16:04,680 --> 00:16:08,959
so from the VM from the container

373
00:16:11,760 --> 00:16:17,040
so thank you and that was CV 2022 1798

374
00:16:17,040 --> 00:16:18,959
and there are more details in the

375
00:16:18,959 --> 00:16:21,859
security advisors

376
00:16:22,440 --> 00:16:25,040
then something else that we looked at is

377
00:16:25,040 --> 00:16:30,000
cougar design that's well made they

378
00:16:30,000 --> 00:16:33,300
they made so they split the the virtual

379
00:16:33,300 --> 00:16:35,519
machine handling on the Node uh in two

380
00:16:35,519 --> 00:16:39,240
parts virtendler and Jet launcher and

381
00:16:39,240 --> 00:16:41,820
qmu is running in the virtual instance

382
00:16:41,820 --> 00:16:44,279
but this is an unprivileged pod so no

383
00:16:44,279 --> 00:16:46,980
privilege on the system but qmu if you

384
00:16:46,980 --> 00:16:48,779
use other acceleration it requires

385
00:16:48,779 --> 00:16:51,380
access to the fkvm so how can you be

386
00:16:51,380 --> 00:16:53,519
unprivileged and still get access to

387
00:16:53,519 --> 00:16:56,220
something that interact with the kernel

388
00:16:56,220 --> 00:16:58,199
so

389
00:16:58,199 --> 00:17:00,720
that's how it's using actually the

390
00:17:00,720 --> 00:17:02,880
device plugin framework this is a

391
00:17:02,880 --> 00:17:04,679
component of kubernetes that allows you

392
00:17:04,679 --> 00:17:08,459
to develop specific pod that allow to

393
00:17:08,459 --> 00:17:11,459
allows to expose a device that's local

394
00:17:11,459 --> 00:17:15,240
to a node onto other pods on on the Node

395
00:17:15,240 --> 00:17:17,400
so you need a privileged pod that will

396
00:17:17,400 --> 00:17:19,439
be the device plugin that will be

397
00:17:19,439 --> 00:17:21,599
privileged that using its privilege to

398
00:17:21,599 --> 00:17:24,240
expose something onto the cluster

399
00:17:24,240 --> 00:17:26,760
a local to a node

400
00:17:26,760 --> 00:17:29,940
um so when you want to to develop one

401
00:17:29,940 --> 00:17:31,740
you specify the device you want to

402
00:17:31,740 --> 00:17:33,660
expose and then you register some

403
00:17:33,660 --> 00:17:35,520
callbacks that will be called when a

404
00:17:35,520 --> 00:17:38,400
device will get a pod will be will be

405
00:17:38,400 --> 00:17:40,440
scheduled requesting this device and

406
00:17:40,440 --> 00:17:42,059
when you want to request access to this

407
00:17:42,059 --> 00:17:44,100
device in alpad you specify the spec

408
00:17:44,100 --> 00:17:45,780
containers resources requests

409
00:17:45,780 --> 00:17:48,000
information and you say I want to access

410
00:17:48,000 --> 00:17:50,460
this device and then if you have

411
00:17:50,460 --> 00:17:53,340
privilege to develop to deploy a pod you

412
00:17:53,340 --> 00:17:55,080
will get scheduled onto a node providing

413
00:17:55,080 --> 00:17:57,539
this type of device plugin and get

414
00:17:57,539 --> 00:17:58,799
access to this device

415
00:17:58,799 --> 00:18:01,020
in the case of cubeville they use this

416
00:18:01,020 --> 00:18:03,600
method to expose multiple devices Dave

417
00:18:03,600 --> 00:18:06,919
KVM devtan and Devi CV

418
00:18:06,919 --> 00:18:09,419
if you have a device plugin that's

419
00:18:09,419 --> 00:18:11,760
deployed on a node if you look into the

420
00:18:11,760 --> 00:18:15,960
specification of a node using cap cutter

421
00:18:15,960 --> 00:18:18,419
and display the the information like as

422
00:18:18,419 --> 00:18:20,340
a yaml file if you look under the

423
00:18:20,340 --> 00:18:22,380
capacity section you will see in this

424
00:18:22,380 --> 00:18:23,720
case that you have

425
00:18:23,720 --> 00:18:27,539
devices.cuber.io KVM SCV and 10 and in

426
00:18:27,539 --> 00:18:30,600
this case we have a thousand device of

427
00:18:30,600 --> 00:18:34,080
tape type KVM and if you want to use it

428
00:18:34,080 --> 00:18:36,120
then in this case you have your yaml

429
00:18:36,120 --> 00:18:38,640
file and you just specify that it's a

430
00:18:38,640 --> 00:18:41,400
pod you choose your image what you want

431
00:18:41,400 --> 00:18:45,059
to execute as a as a command and then in

432
00:18:45,059 --> 00:18:46,799
the resource section you say that you

433
00:18:46,799 --> 00:18:48,200
want at least

434
00:18:48,200 --> 00:18:52,320
maximum one and at least one quantity of

435
00:18:52,320 --> 00:18:54,960
a device the quantity is useful when you

436
00:18:54,960 --> 00:18:55,679
have

437
00:18:55,679 --> 00:18:57,840
um really like physical devices like

438
00:18:57,840 --> 00:19:00,179
let's say a GPU a network card because

439
00:19:00,179 --> 00:19:02,460
you have a maximum number of

440
00:19:02,460 --> 00:19:05,100
client or VM that can connect to it in

441
00:19:05,100 --> 00:19:08,220
the case of Dave of KVM it's

442
00:19:08,220 --> 00:19:10,679
almost Limitless

443
00:19:10,679 --> 00:19:13,559
and then you use Capital to deploy your

444
00:19:13,559 --> 00:19:15,780
your pod and inside your pod if you

445
00:19:15,780 --> 00:19:18,120
execute code in it you just look at Dave

446
00:19:18,120 --> 00:19:20,700
KVM it's existing and if you use a tool

447
00:19:20,700 --> 00:19:24,179
such as KVM okay it will just tell you

448
00:19:24,179 --> 00:19:27,660
that KVM acceleration is can be used

449
00:19:27,660 --> 00:19:29,760
the catch the cache is that there is no

450
00:19:29,760 --> 00:19:32,360
Auto authorization mechanism in place

451
00:19:32,360 --> 00:19:35,880
on this framework so even if you use for

452
00:19:35,880 --> 00:19:37,860
example the handlers that you you

453
00:19:37,860 --> 00:19:39,660
register when you create a device plugin

454
00:19:39,660 --> 00:19:42,299
you don't receive enough information to

455
00:19:42,299 --> 00:19:44,400
do any authorization at that level so

456
00:19:44,400 --> 00:19:46,500
you have to rely on something else like

457
00:19:46,500 --> 00:19:48,539
an admission controller to do some

458
00:19:48,539 --> 00:19:49,860
authorization

459
00:19:49,860 --> 00:19:52,200
so if you're like me and you knew little

460
00:19:52,200 --> 00:19:55,140
on devkvm I didn't look into the

461
00:19:55,140 --> 00:19:57,059
internal of the hqvm you'll think okay

462
00:19:57,059 --> 00:19:59,640
cool no I have that I can deploy a pod

463
00:19:59,640 --> 00:20:01,500
and I can access all the VMS that are

464
00:20:01,500 --> 00:20:03,299
deployed there and mess with the VM

465
00:20:03,299 --> 00:20:06,179
except it doesn't work like that

466
00:20:06,179 --> 00:20:09,600
devkvm and then little did I knew is

467
00:20:09,600 --> 00:20:12,780
that Dave KVM has a so KVM as a peer

468
00:20:12,780 --> 00:20:15,480
process isolation so when you open the

469
00:20:15,480 --> 00:20:18,600
fkvm you receive a file descriptor and

470
00:20:18,600 --> 00:20:20,940
then in any iotrs that you perform you

471
00:20:20,940 --> 00:20:24,120
have to pass this file descriptor and in

472
00:20:24,120 --> 00:20:26,120
the module implementation it will

473
00:20:26,120 --> 00:20:30,240
isolate every client that connects to it

474
00:20:30,240 --> 00:20:32,160
so you have a pair process installation

475
00:20:32,160 --> 00:20:34,500
so if you have process B creating a VM

476
00:20:34,500 --> 00:20:36,780
and process process a creating a VM

477
00:20:36,780 --> 00:20:39,480
process B creating a VM process B cannot

478
00:20:39,480 --> 00:20:42,419
mess with the VM from process a unless

479
00:20:42,419 --> 00:20:44,940
process B has some kind of you can

480
00:20:44,940 --> 00:20:47,280
inject memory in process a like a Shell

481
00:20:47,280 --> 00:20:48,840
Code and then make the Shell Code access

482
00:20:48,840 --> 00:20:51,539
it but that's that's something else but

483
00:20:51,539 --> 00:20:53,340
by default you don't have that and

484
00:20:53,340 --> 00:20:57,059
looking at the iotls that we have

485
00:20:57,059 --> 00:20:59,820
um okay you can create a VM that's fine

486
00:20:59,820 --> 00:21:01,799
but to elevate your privilege you might

487
00:21:01,799 --> 00:21:04,679
want to expose or exit exploit some

488
00:21:04,679 --> 00:21:07,080
vulnerability and we can say that the

489
00:21:07,080 --> 00:21:09,179
ioctls that you have in this case they

490
00:21:09,179 --> 00:21:11,240
couldn't be considered as pretty safe

491
00:21:11,240 --> 00:21:13,740
because they have been audited quite a

492
00:21:13,740 --> 00:21:16,020
quite a bunch and also further than

493
00:21:16,020 --> 00:21:17,220
everything so

494
00:21:17,220 --> 00:21:19,980
no such luck in this case then for

495
00:21:19,980 --> 00:21:22,500
defton you need to have cabinet admin

496
00:21:22,500 --> 00:21:24,419
privileges and then you can do something

497
00:21:24,419 --> 00:21:26,880
on the network level but still it work

498
00:21:26,880 --> 00:21:29,220
it requires some privileges and what you

499
00:21:29,220 --> 00:21:31,500
wanted to to see was if you have no

500
00:21:31,500 --> 00:21:33,659
privilege also written deploy your pod

501
00:21:33,659 --> 00:21:35,039
on a cluster

502
00:21:35,039 --> 00:21:37,620
yet for Dev ATV that's something else

503
00:21:37,620 --> 00:21:41,700
Deva CV is related to AMD ACV which is a

504
00:21:41,700 --> 00:21:43,799
technology that allows on the processor

505
00:21:43,799 --> 00:21:46,380
level to encrypt the memory pages of a

506
00:21:46,380 --> 00:21:47,880
virtual machine

507
00:21:47,880 --> 00:21:51,179
and and prevents the hypervisor from

508
00:21:51,179 --> 00:21:54,600
accessing the virtual memory of a of a

509
00:21:54,600 --> 00:21:56,640
guest that's using confidential

510
00:21:56,640 --> 00:21:59,100
computing

511
00:21:59,100 --> 00:22:03,240
um in each case the fkvm tune an SUV

512
00:22:03,240 --> 00:22:05,460
that allows you to interact with the

513
00:22:05,460 --> 00:22:07,620
kernel and as such you have an increased

514
00:22:07,620 --> 00:22:10,679
attack surface and here it didn't show

515
00:22:10,679 --> 00:22:12,059
during our research because the

516
00:22:12,059 --> 00:22:14,039
developer of cube directly removed

517
00:22:14,039 --> 00:22:16,980
access to the CV and put it behind a

518
00:22:16,980 --> 00:22:19,020
feature flag that's not enabled by

519
00:22:19,020 --> 00:22:21,659
default so it was actually uh there's no

520
00:22:21,659 --> 00:22:24,419
safe but a few months later our

521
00:22:24,419 --> 00:22:27,240
colleague Andy known as the flow did a

522
00:22:27,240 --> 00:22:29,760
research on the sov Kernel module and

523
00:22:29,760 --> 00:22:31,559
discovered multiple memory leak

524
00:22:31,559 --> 00:22:33,360
vulnerability

525
00:22:33,360 --> 00:22:35,659
that allows to so retrieve information

526
00:22:35,659 --> 00:22:37,980
memory from the kernel from New Zealand

527
00:22:37,980 --> 00:22:40,919
so that's a clear example that by

528
00:22:40,919 --> 00:22:43,200
exposing more devices you you increase

529
00:22:43,200 --> 00:22:46,080
the attack surface so in our case

530
00:22:46,080 --> 00:22:48,299
um they have SUV

531
00:22:48,299 --> 00:22:51,539
um was was removed

532
00:22:51,539 --> 00:22:53,880
then we looked at something else

533
00:22:53,880 --> 00:22:56,220
in this case we have no findings but we

534
00:22:56,220 --> 00:22:57,780
still put it because it's interesting

535
00:22:57,780 --> 00:22:59,820
considering the attack surface and what

536
00:22:59,820 --> 00:23:02,700
we have with curb weight so we we ask

537
00:23:02,700 --> 00:23:05,400
ourselves okay if I can create a VM can

538
00:23:05,400 --> 00:23:07,919
I request any device on the host let's

539
00:23:07,919 --> 00:23:09,900
say the host has a GPU can I just

540
00:23:09,900 --> 00:23:12,299
request access to GPU

541
00:23:12,299 --> 00:23:15,179
or any other type of device we can think

542
00:23:15,179 --> 00:23:17,340
about other type of deployment or you

543
00:23:17,340 --> 00:23:19,380
can have a specific device developed

544
00:23:19,380 --> 00:23:22,620
deployed on the the node but what we

545
00:23:22,620 --> 00:23:24,960
found is that all those all type of

546
00:23:24,960 --> 00:23:27,299
devices that we can say as pass through

547
00:23:27,299 --> 00:23:30,900
devices migrated devices and sriov are

548
00:23:30,900 --> 00:23:32,820
requiring a configuration at the host

549
00:23:32,820 --> 00:23:35,580
level so unless an administrator on the

550
00:23:35,580 --> 00:23:37,380
the node

551
00:23:37,380 --> 00:23:39,539
could be done by ansible or through

552
00:23:39,539 --> 00:23:41,159
script but you need administrative

553
00:23:41,159 --> 00:23:43,440
access to the host and do some setup

554
00:23:43,440 --> 00:23:46,380
before you can assign it to VM in the

555
00:23:46,380 --> 00:23:48,020
case of pass-through devices

556
00:23:48,020 --> 00:23:50,700
if you want to

557
00:23:50,700 --> 00:23:53,340
to share your GPU with a VM you have to

558
00:23:53,340 --> 00:23:55,919
Unbound it from the host to allow it to

559
00:23:55,919 --> 00:23:57,840
be bound to a VM because there is a one

560
00:23:57,840 --> 00:24:01,200
one mapping between those devices like

561
00:24:01,200 --> 00:24:05,460
standard GPU card and uh a user or

562
00:24:05,460 --> 00:24:07,740
client of this device

563
00:24:07,740 --> 00:24:10,559
and on top of that there is a field in

564
00:24:10,559 --> 00:24:12,659
quebeard that's called permitted auth

565
00:24:12,659 --> 00:24:15,539
devices that you where you have to list

566
00:24:15,539 --> 00:24:18,600
the allowed devices that VMS are allowed

567
00:24:18,600 --> 00:24:20,100
to use

568
00:24:20,100 --> 00:24:24,360
and just a related cases sriov that

569
00:24:24,360 --> 00:24:27,080
falls back to those permitted OS devices

570
00:24:27,080 --> 00:24:29,820
sriov if you're not familiar with it it

571
00:24:29,820 --> 00:24:33,080
allows a graphic card to kind of

572
00:24:33,080 --> 00:24:35,120
duplicate itself

573
00:24:35,120 --> 00:24:38,280
but the duplication is kind of made on

574
00:24:38,280 --> 00:24:41,580
the the device level so that allows for

575
00:24:41,580 --> 00:24:44,100
example if you want to play Windows game

576
00:24:44,100 --> 00:24:46,919
on Linux so you have a Windows Virtual

577
00:24:46,919 --> 00:24:48,900
Machine and you have your Linux host you

578
00:24:48,900 --> 00:24:52,020
can have the both the Linux host and the

579
00:24:52,020 --> 00:24:54,600
windows guest sharing the same graphic

580
00:24:54,600 --> 00:24:56,400
card but there are some

581
00:24:56,400 --> 00:25:00,419
code in the graphical that handle that

582
00:25:00,419 --> 00:25:03,299
creates a kind of virtual clone but when

583
00:25:03,299 --> 00:25:05,340
you do enable or create a virtual clone

584
00:25:05,340 --> 00:25:08,460
then it it appears in the PCI device

585
00:25:08,460 --> 00:25:11,880
Tree on the host as a device and then

586
00:25:11,880 --> 00:25:13,380
you have to

587
00:25:13,380 --> 00:25:15,780
to list it in the parameters device as

588
00:25:15,780 --> 00:25:18,179
well so in this case same you have to do

589
00:25:18,179 --> 00:25:22,080
some some configuration there and the

590
00:25:22,080 --> 00:25:24,840
case for Medici device is the is another

591
00:25:24,840 --> 00:25:27,059
type of device and you need also

592
00:25:27,059 --> 00:25:30,240
configuration at the host level then we

593
00:25:30,240 --> 00:25:31,740
look at something else related to

594
00:25:31,740 --> 00:25:33,720
kubernetes which are privileged service

595
00:25:33,720 --> 00:25:35,100
accounts that's something that was

596
00:25:35,100 --> 00:25:39,179
alighted during kubecon EU 2022 so last

597
00:25:39,179 --> 00:25:41,940
year and in short this is uh something

598
00:25:41,940 --> 00:25:44,279
that is related to over privileged

599
00:25:44,279 --> 00:25:46,620
service accounts so let's say you have a

600
00:25:46,620 --> 00:25:48,600
pod running on the cluster and this pod

601
00:25:48,600 --> 00:25:50,520
needs to do some specific action on the

602
00:25:50,520 --> 00:25:53,580
cluster maybe list the other pod on the

603
00:25:53,580 --> 00:25:55,919
cluster maybe do some management of the

604
00:25:55,919 --> 00:25:58,740
node to do that you need some privilege

605
00:25:58,740 --> 00:26:00,720
on the kubernetes cluster itself and

606
00:26:00,720 --> 00:26:02,039
what you can do is create a service

607
00:26:02,039 --> 00:26:03,840
account on kubernetes

608
00:26:03,840 --> 00:26:06,000
give it some privileges like modify

609
00:26:06,000 --> 00:26:08,880
nodes modify pods Or List data and then

610
00:26:08,880 --> 00:26:10,320
bounce this

611
00:26:10,320 --> 00:26:12,720
um this to to a pod

612
00:26:12,720 --> 00:26:15,539
the issue is that then the KSA so

613
00:26:15,539 --> 00:26:17,880
community service account the token is

614
00:26:17,880 --> 00:26:20,400
available on the pods file system and

615
00:26:20,400 --> 00:26:22,200
this means that if you have Roots

616
00:26:22,200 --> 00:26:24,659
privilege on the host then you can just

617
00:26:24,659 --> 00:26:28,200
go to the the Pod file system and access

618
00:26:28,200 --> 00:26:30,360
the file if you have those root

619
00:26:30,360 --> 00:26:32,940
privilege and the thing is that we don't

620
00:26:32,940 --> 00:26:34,799
consider Linux namespaces as a security

621
00:26:34,799 --> 00:26:36,840
demand array because they are currently

622
00:26:36,840 --> 00:26:39,539
a lot of Kernel vulnerabilities you can

623
00:26:39,539 --> 00:26:42,360
also have a misconfigured pod that

624
00:26:42,360 --> 00:26:44,340
allows like host pass that logs directly

625
00:26:44,340 --> 00:26:46,799
to mount a port so it's difficult to

626
00:26:46,799 --> 00:26:50,820
consider that as a security boundary so

627
00:26:50,820 --> 00:26:53,220
we say that anytime you have a pod

628
00:26:53,220 --> 00:26:55,260
that's either normal issues by default

629
00:26:55,260 --> 00:26:57,419
or that gets compromised then we can get

630
00:26:57,419 --> 00:27:00,840
access to the KSA token of any port that

631
00:27:00,840 --> 00:27:03,360
deployed on this spot as well and then

632
00:27:03,360 --> 00:27:05,460
if you get access to a KC token you can

633
00:27:05,460 --> 00:27:06,960
do probably lateral movement or

634
00:27:06,960 --> 00:27:08,700
privilege escalation depending on the

635
00:27:08,700 --> 00:27:10,799
the privilege of this this service

636
00:27:10,799 --> 00:27:12,440
account

637
00:27:12,440 --> 00:27:16,080
we didn't found any KSA and there is

638
00:27:16,080 --> 00:27:17,760
also a proper result no desolation

639
00:27:17,760 --> 00:27:19,320
meaning that everything that's

640
00:27:19,320 --> 00:27:21,179
privileged like the virt controller and

641
00:27:21,179 --> 00:27:23,039
virtual API they do have service account

642
00:27:23,039 --> 00:27:24,659
with high privilege but they are running

643
00:27:24,659 --> 00:27:27,360
on control plane node so anything you

644
00:27:27,360 --> 00:27:29,580
will Deploy on the the cluster will not

645
00:27:29,580 --> 00:27:32,640
get on the same the same node by default

646
00:27:32,640 --> 00:27:35,880
due to a tension mechanism in kubernetes

647
00:27:35,880 --> 00:27:38,880
but in the solution that we have edited

648
00:27:38,880 --> 00:27:41,220
we found that we deploy additional

649
00:27:41,220 --> 00:27:43,380
components and one of those is deployed

650
00:27:43,380 --> 00:27:44,880
as a demon set meaning that it's

651
00:27:44,880 --> 00:27:47,400
deployed on all the parts of the all the

652
00:27:47,400 --> 00:27:49,380
nodes of the cluster so that's a win

653
00:27:49,380 --> 00:27:51,059
because if you compromise one pod on the

654
00:27:51,059 --> 00:27:52,919
cluster you are sure that you will get

655
00:27:52,919 --> 00:27:54,960
this privileged node according to

656
00:27:54,960 --> 00:27:57,059
running on the same node and this

657
00:27:57,059 --> 00:28:00,000
service account had to get watch list

658
00:28:00,000 --> 00:28:02,100
update and Patch privilege on nodes and

659
00:28:02,100 --> 00:28:04,620
pods object so if you have a get and

660
00:28:04,620 --> 00:28:07,140
list on pods for example you can list

661
00:28:07,140 --> 00:28:11,640
the EML or the definition of a pod and

662
00:28:11,640 --> 00:28:13,620
if for example you do something that is

663
00:28:13,620 --> 00:28:17,760
not a good practice but passing Secrets

664
00:28:17,760 --> 00:28:19,380
through environment variable you can

665
00:28:19,380 --> 00:28:21,179
just access the environment variable and

666
00:28:21,179 --> 00:28:22,980
get access to the secret

667
00:28:22,980 --> 00:28:25,620
and if you have access to the nodes you

668
00:28:25,620 --> 00:28:28,140
can probably steer away a pod onto a

669
00:28:28,140 --> 00:28:30,539
node and then try some other types of

670
00:28:30,539 --> 00:28:31,919
attack

671
00:28:31,919 --> 00:28:34,440
then we also look at third party attack

672
00:28:34,440 --> 00:28:35,580
surface

673
00:28:35,580 --> 00:28:37,799
because you might want to add additional

674
00:28:37,799 --> 00:28:39,659
components for example if you use a

675
00:28:39,659 --> 00:28:41,460
graphic card for ML workloads or things

676
00:28:41,460 --> 00:28:45,539
like that in this case we did some some

677
00:28:45,539 --> 00:28:49,020
checks and so check for something like a

678
00:28:49,020 --> 00:28:51,720
curl type sh which doesn't give you

679
00:28:51,720 --> 00:28:54,360
provenance validation on the the things

680
00:28:54,360 --> 00:28:56,580
that you installed also check the

681
00:28:56,580 --> 00:28:58,380
version of the driver so you get an

682
00:28:58,380 --> 00:29:00,840
alert when there is a new cve or some

683
00:29:00,840 --> 00:29:03,240
things that could be specific to your

684
00:29:03,240 --> 00:29:05,760
thread model but if you have a VM using

685
00:29:05,760 --> 00:29:09,299
a GPU and the chip the VM is the

686
00:29:09,299 --> 00:29:11,340
allocated the GPU is then used by

687
00:29:11,340 --> 00:29:13,440
another VM if you get the compromise of

688
00:29:13,440 --> 00:29:16,080
the GPU in between an attacker with

689
00:29:16,080 --> 00:29:17,820
specific privilege might be able to

690
00:29:17,820 --> 00:29:20,159
bounce between the VMS so you might want

691
00:29:20,159 --> 00:29:22,380
to also reset the GPU when the VM is

692
00:29:22,380 --> 00:29:24,000
deallocated

693
00:29:24,000 --> 00:29:26,340
then we also look at other areas like

694
00:29:26,340 --> 00:29:29,640
cryptography networking internal API and

695
00:29:29,640 --> 00:29:31,020
we found

696
00:29:31,020 --> 00:29:33,899
other findings like for example didn't

697
00:29:33,899 --> 00:29:36,899
have didn't have any fuzzing harnesses

698
00:29:36,899 --> 00:29:39,059
so that's now something that's work in

699
00:29:39,059 --> 00:29:42,179
progress even if go with memory safe in

700
00:29:42,179 --> 00:29:44,340
a way then you you also have other types

701
00:29:44,340 --> 00:29:45,899
of vulnerability and their fusing

702
00:29:45,899 --> 00:29:48,179
analysis can help you find those and

703
00:29:48,179 --> 00:29:50,100
also like help the stability of the the

704
00:29:50,100 --> 00:29:52,140
project we also did found some

705
00:29:52,140 --> 00:29:54,779
concurrency issues that didn't lead to

706
00:29:54,779 --> 00:29:57,600
security issue but that's still good

707
00:29:57,600 --> 00:29:59,640
that allows to override some some

708
00:29:59,640 --> 00:30:02,179
information

709
00:30:02,880 --> 00:30:05,039
and we would like to thanks our

710
00:30:05,039 --> 00:30:07,200
colleague in security who also worked on

711
00:30:07,200 --> 00:30:09,419
the review with us and especially uh

712
00:30:09,419 --> 00:30:11,820
Roman Moore who his point of contact for

713
00:30:11,820 --> 00:30:14,700
Cubit and doing a great an amazing

714
00:30:14,700 --> 00:30:17,600
amazing job there

715
00:30:18,179 --> 00:30:20,279
then speaking of remediation and

716
00:30:20,279 --> 00:30:22,860
hardening

717
00:30:22,860 --> 00:30:24,720
um some common kubernetes recommendation

718
00:30:24,720 --> 00:30:26,399
that we want to give

719
00:30:26,399 --> 00:30:28,380
those are not exhaustive but those are

720
00:30:28,380 --> 00:30:30,240
ground rules like the first rule of the

721
00:30:30,240 --> 00:30:32,640
kubernetes security club is that you dot

722
00:30:32,640 --> 00:30:34,440
mix worker and control plane node

723
00:30:34,440 --> 00:30:36,600
control plane node are running high

724
00:30:36,600 --> 00:30:39,480
privilege pod that have privilege over

725
00:30:39,480 --> 00:30:42,179
the cluster and if you have worker node

726
00:30:42,179 --> 00:30:44,100
that are supposed to run your end user

727
00:30:44,100 --> 00:30:46,260
workload you don't want those engines or

728
00:30:46,260 --> 00:30:48,480
workload schedule in the control plane

729
00:30:48,480 --> 00:30:51,240
node as the they have access to the KSA

730
00:30:51,240 --> 00:30:53,100
of the control plate

731
00:30:53,100 --> 00:30:55,559
um but you also want to review the

732
00:30:55,559 --> 00:30:57,960
airbag manifest when you you create

733
00:30:57,960 --> 00:31:01,080
those overly privileged service account

734
00:31:01,080 --> 00:31:02,520
um and you

735
00:31:02,520 --> 00:31:04,980
you want to do this using either you can

736
00:31:04,980 --> 00:31:07,140
do your own tooling or use commercial

737
00:31:07,140 --> 00:31:09,299
solution that will integrate in your CI

738
00:31:09,299 --> 00:31:10,679
CD pipeline

739
00:31:10,679 --> 00:31:13,020
if this is not enough and you want to

740
00:31:13,020 --> 00:31:14,779
have more fine-grained

741
00:31:14,779 --> 00:31:16,740
validation you can use admission

742
00:31:16,740 --> 00:31:20,159
controller to fix those airbag gaps and

743
00:31:20,159 --> 00:31:21,960
you also want to implement further as

744
00:31:21,960 --> 00:31:23,820
said before

745
00:31:23,820 --> 00:31:25,919
then regarding the admission controller

746
00:31:25,919 --> 00:31:28,440
before you had the security policies

747
00:31:28,440 --> 00:31:31,260
that has been deprecated and now you

748
00:31:31,260 --> 00:31:32,640
have pod security standards and

749
00:31:32,640 --> 00:31:34,679
admission so that allows you to have

750
00:31:34,679 --> 00:31:37,460
three big classes of policy that you can

751
00:31:37,460 --> 00:31:40,559
deploy and then assign a pod to a

752
00:31:40,559 --> 00:31:43,020
specific group of of policy and you can

753
00:31:43,020 --> 00:31:45,179
say for example I don't want to have a

754
00:31:45,179 --> 00:31:48,059
privileged pod start by by anyone on the

755
00:31:48,059 --> 00:31:51,980
cluster or in specific namespace

756
00:31:52,020 --> 00:31:54,000
um and then if you need more fine grain

757
00:31:54,000 --> 00:31:56,159
outside of those three big classes that

758
00:31:56,159 --> 00:31:58,200
they have you can use a custom admission

759
00:31:58,200 --> 00:32:01,620
controller or existing one like Opa

760
00:32:01,620 --> 00:32:04,559
gatekeeper or other like killino those

761
00:32:04,559 --> 00:32:07,500
kind of solutions so those are also

762
00:32:07,500 --> 00:32:09,179
recommendations that you you want to

763
00:32:09,179 --> 00:32:11,820
have like privilege pod no access to OS

764
00:32:11,820 --> 00:32:14,520
pass network access also to be limited

765
00:32:14,520 --> 00:32:16,620
and access to devices

766
00:32:16,620 --> 00:32:18,779
then regarding Cube yards you might want

767
00:32:18,779 --> 00:32:21,299
to disable some features so features are

768
00:32:21,299 --> 00:32:23,820
behind something named feature gate in

769
00:32:23,820 --> 00:32:26,220
Cubit and for example here you might

770
00:32:26,220 --> 00:32:28,440
want to disable OS disk and experimental

771
00:32:28,440 --> 00:32:30,360
virtual ufs support because those by

772
00:32:30,360 --> 00:32:32,760
default allows you to like get access to

773
00:32:32,760 --> 00:32:34,740
all file system

774
00:32:34,740 --> 00:32:37,980
at the virtual Hardware level anytime

775
00:32:37,980 --> 00:32:39,840
you have a virtual device that you you

776
00:32:39,840 --> 00:32:42,419
add or is accessible from a VM you have

777
00:32:42,419 --> 00:32:43,799
an increased attacks your face as well

778
00:32:43,799 --> 00:32:46,320
those devices are implemented in the vmm

779
00:32:46,320 --> 00:32:47,880
so qmu

780
00:32:47,880 --> 00:32:50,159
and the more you have the more attack

781
00:32:50,159 --> 00:32:51,779
surface you have so here you want to

782
00:32:51,779 --> 00:32:53,820
keep things in check and have a limited

783
00:32:53,820 --> 00:32:56,279
number of virtual devices the thing is

784
00:32:56,279 --> 00:32:58,799
that Kubler for no is not exposing all

785
00:32:58,799 --> 00:33:00,720
the qmu devices that you might have if

786
00:33:00,720 --> 00:33:03,299
you run just qmu and list devices Qbert

787
00:33:03,299 --> 00:33:05,399
is making that so that's a good thing

788
00:33:05,399 --> 00:33:07,320
but still something you might want to do

789
00:33:07,320 --> 00:33:08,880
for example if you want to enable

790
00:33:08,880 --> 00:33:11,340
inspector V2 mitigation using your

791
00:33:11,340 --> 00:33:13,140
animation controller you want to limit

792
00:33:13,140 --> 00:33:15,720
that the CPU type for example is ending

793
00:33:15,720 --> 00:33:19,380
with ibrs so you have only the VMS with

794
00:33:19,380 --> 00:33:21,899
spectral V2 mitigations

795
00:33:21,899 --> 00:33:25,500
then also on the virtualization side you

796
00:33:25,500 --> 00:33:26,880
might want to take a look at an estate

797
00:33:26,880 --> 00:33:30,120
virtualization that's a part of KVM

798
00:33:30,120 --> 00:33:32,700
that's complex enough to probably still

799
00:33:32,700 --> 00:33:34,919
have some bugs lying around because it's

800
00:33:34,919 --> 00:33:38,580
it's a complex topic and there is a blog

801
00:33:38,580 --> 00:33:41,340
post from Project zero on that

802
00:33:41,340 --> 00:33:42,720
um

803
00:33:42,720 --> 00:33:45,419
should you be using it you can use for

804
00:33:45,419 --> 00:33:47,940
example second rules on the the Pod

805
00:33:47,940 --> 00:33:50,720
level to limit the ioctl that it can use

806
00:33:50,720 --> 00:33:53,279
if you want to have a look divisor

807
00:33:53,279 --> 00:33:56,580
provide some filters like that in the

808
00:33:56,580 --> 00:33:59,039
The Source Code of gvisor should you

809
00:33:59,039 --> 00:34:02,240
need nested virtualization

810
00:34:02,820 --> 00:34:05,240
regarding the CV we mentioned earlier

811
00:34:05,240 --> 00:34:08,460
first the developers need some time to

812
00:34:08,460 --> 00:34:11,520
fix it so we use some workarounds

813
00:34:11,520 --> 00:34:13,800
so as you just said it's better to

814
00:34:13,800 --> 00:34:16,020
disable features that are not used so

815
00:34:16,020 --> 00:34:20,159
the hot plug volumes were disabled also

816
00:34:20,159 --> 00:34:22,040
it's possible to set admission

817
00:34:22,040 --> 00:34:26,099
controller policies to tighten it

818
00:34:26,099 --> 00:34:27,359
and

819
00:34:27,359 --> 00:34:30,418
if srinux was enabled it was not

820
00:34:30,418 --> 00:34:32,940
possible to exploit the vulnerability

821
00:34:32,940 --> 00:34:35,940
and then the proper fixed was issued a

822
00:34:35,940 --> 00:34:38,639
package was added to the keywords code

823
00:34:38,639 --> 00:34:40,679
that is called safe path and that

824
00:34:40,679 --> 00:34:42,359
handles all the problems created with

825
00:34:42,359 --> 00:34:44,940
the path and it was patched in version

826
00:34:44,940 --> 00:34:47,580
0.55.1

827
00:34:47,580 --> 00:34:49,440
and an example of that is the function

828
00:34:49,440 --> 00:34:51,659
join no follow that replies that

829
00:34:51,659 --> 00:34:54,418
replaces some joint cases

830
00:34:54,418 --> 00:34:56,280
this is not something standard to the go

831
00:34:56,280 --> 00:34:58,560
Library by the way so this is a problem

832
00:34:58,560 --> 00:35:02,400
for many goal code many projects using

833
00:35:02,400 --> 00:35:04,260
Google code

834
00:35:04,260 --> 00:35:06,420
so there's a conclusion even if we

835
00:35:06,420 --> 00:35:08,460
presented some findings

836
00:35:08,460 --> 00:35:10,619
we can start by saying that overall we

837
00:35:10,619 --> 00:35:12,480
witnessed a good architecture and good

838
00:35:12,480 --> 00:35:14,040
quality

839
00:35:14,040 --> 00:35:17,040
also it was an interesting topic because

840
00:35:17,040 --> 00:35:19,380
it's a virtualization solution and yet

841
00:35:19,380 --> 00:35:22,440
the threat model and attack vectors were

842
00:35:22,440 --> 00:35:23,520
different from traditional

843
00:35:23,520 --> 00:35:26,540
virtualization solution

844
00:35:28,859 --> 00:35:30,480
um lots of problems were on the

845
00:35:30,480 --> 00:35:32,099
integration layer no not on the product

846
00:35:32,099 --> 00:35:34,920
itself multi-tenancy is also a risk

847
00:35:34,920 --> 00:35:36,660
factor that you want to minimize as much

848
00:35:36,660 --> 00:35:39,240
as possible for such problems

849
00:35:39,240 --> 00:35:41,640
and some healthy guidelines can be

850
00:35:41,640 --> 00:35:44,880
followed as we explained earlier

851
00:35:44,880 --> 00:35:46,770
thank you for your attention

852
00:35:46,770 --> 00:35:48,550
[Applause]

853
00:35:48,550 --> 00:35:55,349
[Music]

