1
00:00:00,000 --> 00:00:08,700
[Music]

2
00:00:09,679 --> 00:00:11,440
thank you

3
00:00:11,440 --> 00:00:13,860
[Music]

4
00:00:13,860 --> 00:00:15,780
thanks so it's it's you know it's it's

5
00:00:15,780 --> 00:00:17,820
an amazing welcome here to get Applause

6
00:00:17,820 --> 00:00:20,039
before I've even said anything and it's

7
00:00:20,039 --> 00:00:22,140
it's really been like that all week you

8
00:00:22,140 --> 00:00:24,359
know I arrived we got off the plane

9
00:00:24,359 --> 00:00:27,000
practically everyone in Tel Aviv was on

10
00:00:27,000 --> 00:00:30,480
the streets waving flags to welcome me

11
00:00:30,480 --> 00:00:31,380
um

12
00:00:31,380 --> 00:00:34,320
so the first thing that happened when I

13
00:00:34,320 --> 00:00:36,120
came to write these slides was I

14
00:00:36,120 --> 00:00:38,100
realized I couldn't actually fit the

15
00:00:38,100 --> 00:00:41,160
title on the title slide

16
00:00:41,160 --> 00:00:43,860
um so if you look in the present in the

17
00:00:43,860 --> 00:00:46,379
program you'll notice that the title

18
00:00:46,379 --> 00:00:48,360
talks about compartmentalization and

19
00:00:48,360 --> 00:00:49,739
memory safety

20
00:00:49,739 --> 00:00:54,360
and if in like a minute's time you all

21
00:00:54,360 --> 00:00:56,579
fall asleep and remember nothing else of

22
00:00:56,579 --> 00:00:58,079
this talk

23
00:00:58,079 --> 00:01:00,180
I really want to get across that these

24
00:01:00,180 --> 00:01:03,059
are not two separate problems if you

25
00:01:03,059 --> 00:01:05,459
build strong non-by-passable memory

26
00:01:05,459 --> 00:01:07,439
safety you get compartmentalization

27
00:01:07,439 --> 00:01:09,360
basically for free

28
00:01:09,360 --> 00:01:10,740
if you try and build

29
00:01:10,740 --> 00:01:12,900
compartmentalization without memory

30
00:01:12,900 --> 00:01:15,479
safety you end up with something that

31
00:01:15,479 --> 00:01:17,520
just doesn't have a program model that

32
00:01:17,520 --> 00:01:19,920
anyone understands and if you look at

33
00:01:19,920 --> 00:01:22,259
the most aggressively compartmentalized

34
00:01:22,259 --> 00:01:23,939
applications in the world they've got

35
00:01:23,939 --> 00:01:27,240
like seven compartments and if you want

36
00:01:27,240 --> 00:01:29,280
to really compartmentalize really deploy

37
00:01:29,280 --> 00:01:30,720
the principle of least privilege

38
00:01:30,720 --> 00:01:33,060
everywhere you should be able to ship

39
00:01:33,060 --> 00:01:35,159
things with hundreds of compartments

40
00:01:35,159 --> 00:01:37,740
thousands of compartments and that means

41
00:01:37,740 --> 00:01:41,220
you need a programmer model that someone

42
00:01:41,220 --> 00:01:43,740
writing code who's not a security expert

43
00:01:43,740 --> 00:01:45,720
can look at and go yeah I kind of

44
00:01:45,720 --> 00:01:49,220
understand what that software is doing

45
00:01:49,619 --> 00:01:51,600
so

46
00:01:51,600 --> 00:01:54,140
I'm going to talk about a bunch of stuff

47
00:01:54,140 --> 00:01:57,479
none of this is is secret Microsoft

48
00:01:57,479 --> 00:01:59,820
proprietary everything that we're doing

49
00:01:59,820 --> 00:02:02,759
in this project is open source from the

50
00:02:02,759 --> 00:02:05,100
ISA which we're contributing to risk 5

51
00:02:05,100 --> 00:02:07,320
International that we want to get

52
00:02:07,320 --> 00:02:09,419
standardized as a risk five extension

53
00:02:09,419 --> 00:02:12,180
through the reference implementation of

54
00:02:12,180 --> 00:02:14,459
that on top of the Ibex core from low

55
00:02:14,459 --> 00:02:16,879
risk to the Clean Slate

56
00:02:16,879 --> 00:02:19,020
compartmentalized rtos which I'm going

57
00:02:19,020 --> 00:02:21,599
to be talking about a lot today and the

58
00:02:21,599 --> 00:02:23,700
compiler so the entire Hardware software

59
00:02:23,700 --> 00:02:27,239
stack here is open source if you want to

60
00:02:27,239 --> 00:02:30,300
grab the RTL for the core or build your

61
00:02:30,300 --> 00:02:33,660
own risk 5 Core implementing these Fab a

62
00:02:33,660 --> 00:02:35,940
load of chips and Chip devices built on

63
00:02:35,940 --> 00:02:38,340
it please do

64
00:02:38,340 --> 00:02:40,340
um

65
00:02:40,860 --> 00:02:43,019
so this is this is kind of where we are

66
00:02:43,019 --> 00:02:45,720
we've all seen this before right

67
00:02:45,720 --> 00:02:48,540
um you know I can't stop people

68
00:02:48,540 --> 00:02:51,959
connecting light bulbs or thermostats or

69
00:02:51,959 --> 00:02:54,540
aluminum smelting plants or x-ray

70
00:02:54,540 --> 00:02:56,879
machines to the internet I've tried

71
00:02:56,879 --> 00:02:59,819
seriously it just doesn't work

72
00:02:59,819 --> 00:03:01,560
um so what we really wanted to try and

73
00:03:01,560 --> 00:03:04,920
do with this project was see if we could

74
00:03:04,920 --> 00:03:07,920
design a chip that was about as cheap to

75
00:03:07,920 --> 00:03:10,019
build as ones with absolutely no

76
00:03:10,019 --> 00:03:12,480
security so you know same sort of area

77
00:03:12,480 --> 00:03:14,280
cost as

78
00:03:14,280 --> 00:03:17,580
M profile arm core or or Baseline risk

79
00:03:17,580 --> 00:03:20,700
five without even the basic you know

80
00:03:20,700 --> 00:03:22,500
multiple privilege Rings or all the

81
00:03:22,500 --> 00:03:24,239
kinds of things you take for granted on

82
00:03:24,239 --> 00:03:27,000
on larger systems

83
00:03:27,000 --> 00:03:29,700
um and then that same sort of cost build

84
00:03:29,700 --> 00:03:31,980
something that gave us really game

85
00:03:31,980 --> 00:03:33,780
changing security

86
00:03:33,780 --> 00:03:36,000
and and you know I look everyone pokes

87
00:03:36,000 --> 00:03:38,879
fun at iot but it's a really cost driven

88
00:03:38,879 --> 00:03:41,879
ecosystem you know if you're six months

89
00:03:41,879 --> 00:03:44,099
late to Market or you're a dollar more

90
00:03:44,099 --> 00:03:46,440
than your competitors then that

91
00:03:46,440 --> 00:03:49,379
translates to no sales

92
00:03:49,379 --> 00:03:50,940
um there's there's very little

93
00:03:50,940 --> 00:03:52,620
regulatory pressure there's very little

94
00:03:52,620 --> 00:03:55,379
consumer pressure to be secure there's a

95
00:03:55,379 --> 00:03:57,599
lot of consumer pressure to get to

96
00:03:57,599 --> 00:04:00,000
Market quickly

97
00:04:00,000 --> 00:04:03,000
um so our Hope Was That by co-designing

98
00:04:03,000 --> 00:04:05,760
our instruction set architecture the

99
00:04:05,760 --> 00:04:07,519
implementation of that the

100
00:04:07,519 --> 00:04:09,900
compartmentalization model and the

101
00:04:09,900 --> 00:04:11,459
operating system that ties it all

102
00:04:11,459 --> 00:04:13,620
together we'd be able to build something

103
00:04:13,620 --> 00:04:16,440
that that could really change the

104
00:04:16,440 --> 00:04:19,199
absolute lowest Baseline security

105
00:04:19,199 --> 00:04:22,019
guarantees for the cheapest possible

106
00:04:22,019 --> 00:04:23,940
devices you know internet enabled light

107
00:04:23,940 --> 00:04:26,699
bulbs that kind of thing

108
00:04:26,699 --> 00:04:28,380
so if you look if you look at the iot

109
00:04:28,380 --> 00:04:29,820
ecosystem

110
00:04:29,820 --> 00:04:32,600
it's kind of a mess right there are

111
00:04:32,600 --> 00:04:35,580
loads of chunks of Legacy code usually

112
00:04:35,580 --> 00:04:37,680
in C occasionally if you're lucky in C

113
00:04:37,680 --> 00:04:39,840
plus plus although often it's like 20

114
00:04:39,840 --> 00:04:42,000
year old C plus plus you're actually not

115
00:04:42,000 --> 00:04:43,800
that lucky

116
00:04:43,800 --> 00:04:47,580
um these things were often written with

117
00:04:47,580 --> 00:04:49,259
the assumption that no one would ever

118
00:04:49,259 --> 00:04:51,300
connect this device to a network so your

119
00:04:51,300 --> 00:04:55,199
adversary model is someone connecting

120
00:04:55,199 --> 00:04:57,960
physical probes to some pins and and

121
00:04:57,960 --> 00:05:00,060
trying to break the device it's not in

122
00:05:00,060 --> 00:05:03,720
any way assuming a software attacker

123
00:05:03,720 --> 00:05:05,720
um

124
00:05:05,880 --> 00:05:07,979
it comes from all over the place it's in

125
00:05:07,979 --> 00:05:10,860
unsafe languages it's not deployed with

126
00:05:10,860 --> 00:05:12,960
mitigations

127
00:05:12,960 --> 00:05:15,180
and so you know what we'd like to do in

128
00:05:15,180 --> 00:05:17,340
a lot of places is just say well we've

129
00:05:17,340 --> 00:05:19,139
got safe languages now let's let's just

130
00:05:19,139 --> 00:05:20,639
rewrite the code

131
00:05:20,639 --> 00:05:22,259
um and that's great but now you need to

132
00:05:22,259 --> 00:05:24,600
find people who are expert rust

133
00:05:24,600 --> 00:05:27,300
programmers and that's kind of hard you

134
00:05:27,300 --> 00:05:30,000
need to find people who are experts as

135
00:05:30,000 --> 00:05:31,680
embedded systems development and that's

136
00:05:31,680 --> 00:05:34,259
actually really hard and you need to

137
00:05:34,259 --> 00:05:36,000
find people who are experts in network

138
00:05:36,000 --> 00:05:38,160
security and and that's also pretty hard

139
00:05:38,160 --> 00:05:39,780
so now you need to find people who are

140
00:05:39,780 --> 00:05:42,660
at the intersection of three areas with

141
00:05:42,660 --> 00:05:44,759
skill shortages

142
00:05:44,759 --> 00:05:46,740
um and did I mention that this is a cost

143
00:05:46,740 --> 00:05:49,919
driven ecosystem so yeah you also need

144
00:05:49,919 --> 00:05:53,100
to not pay them any money

145
00:05:53,100 --> 00:05:54,300
um

146
00:05:54,300 --> 00:05:55,919
it actually gets worse than that because

147
00:05:55,919 --> 00:05:58,500
a bunch of the things that we're often

148
00:05:58,500 --> 00:06:00,539
seeing people do on on these embedded

149
00:06:00,539 --> 00:06:03,180
devices are intrinsically unsafe right

150
00:06:03,180 --> 00:06:05,220
there's code that is just below the

151
00:06:05,220 --> 00:06:07,139
level of an abstract machine for a safe

152
00:06:07,139 --> 00:06:09,780
language that's doing memory allocation

153
00:06:09,780 --> 00:06:12,180
or more often it's talking directly to

154
00:06:12,180 --> 00:06:15,180
Hardware devices and the kind of of

155
00:06:15,180 --> 00:06:16,860
properties that you need to be able to

156
00:06:16,860 --> 00:06:19,139
express just

157
00:06:19,139 --> 00:06:21,900
aren't there in in any safe language and

158
00:06:21,900 --> 00:06:23,220
if you can write things in safe

159
00:06:23,220 --> 00:06:25,139
languages please do so in fact our

160
00:06:25,139 --> 00:06:28,080
reference implementation uh has a

161
00:06:28,080 --> 00:06:30,560
JavaScript interpreter which is uh

162
00:06:30,560 --> 00:06:33,240
adopted from the microbium project which

163
00:06:33,240 --> 00:06:35,940
is just a phenomenal piece of work

164
00:06:35,940 --> 00:06:38,220
um and so you know we can take

165
00:06:38,220 --> 00:06:40,400
JavaScript code we can run it

166
00:06:40,400 --> 00:06:43,259
compartmentalized uh on one of these

167
00:06:43,259 --> 00:06:44,819
devices and if you can get away with

168
00:06:44,819 --> 00:06:46,620
writing your embedded software in a

169
00:06:46,620 --> 00:06:48,319
typesafe garbage collected language

170
00:06:48,319 --> 00:06:52,319
awesome just do that but for the bits

171
00:06:52,319 --> 00:06:56,400
that really need to be low level code we

172
00:06:56,400 --> 00:06:59,639
want to be able to get some very strong

173
00:06:59,639 --> 00:07:00,960
properties

174
00:07:00,960 --> 00:07:02,400
so

175
00:07:02,400 --> 00:07:05,280
I could very easily stand here for two

176
00:07:05,280 --> 00:07:07,680
three hours and send everyone in the

177
00:07:07,680 --> 00:07:10,560
audience to sleep talking about Cherry

178
00:07:10,560 --> 00:07:11,220
um

179
00:07:11,220 --> 00:07:13,319
I promise not to do that

180
00:07:13,319 --> 00:07:15,960
so if you want a really good Deep dive

181
00:07:15,960 --> 00:07:18,840
into charity uh Sarah ma gave a talk at

182
00:07:18,840 --> 00:07:20,580
Black Cat a couple of years ago it's

183
00:07:20,580 --> 00:07:22,919
online it's fantastic

184
00:07:22,919 --> 00:07:25,500
um go go and watch it but for anyone who

185
00:07:25,500 --> 00:07:27,240
doesn't want me to pause for a while

186
00:07:27,240 --> 00:07:29,699
while you all go and grab the phones and

187
00:07:29,699 --> 00:07:32,220
and look at YouTube

188
00:07:32,220 --> 00:07:34,800
um I just want to give a sort of very

189
00:07:34,800 --> 00:07:36,840
brief overview so

190
00:07:36,840 --> 00:07:39,599
cherries is a project that started

191
00:07:39,599 --> 00:07:42,840
funded by DARPA in 2010 so this is not

192
00:07:42,840 --> 00:07:45,720
really exciting and new anymore I

193
00:07:45,720 --> 00:07:49,080
started working I was in 2012 so you

194
00:07:49,080 --> 00:07:51,300
know it's been around

195
00:07:51,300 --> 00:07:52,259
um

196
00:07:52,259 --> 00:07:56,039
the really key thing about Cherry is it

197
00:07:56,039 --> 00:07:58,020
teaches the hardware that pointers and

198
00:07:58,020 --> 00:08:00,780
integers are not the same thing

199
00:08:00,780 --> 00:08:01,500
um

200
00:08:01,500 --> 00:08:03,180
you have

201
00:08:03,180 --> 00:08:05,460
a type that the hardware understands

202
00:08:05,460 --> 00:08:08,819
that not just identifies a a region of

203
00:08:08,819 --> 00:08:11,280
memory but conveys access to that so

204
00:08:11,280 --> 00:08:14,340
this contains bounds information that

205
00:08:14,340 --> 00:08:16,460
contains permissions and the hardware

206
00:08:16,460 --> 00:08:19,080
understands the set of operations that

207
00:08:19,080 --> 00:08:21,360
are allowed on this so if I give you a

208
00:08:21,360 --> 00:08:24,300
pointer to an object you can derive a

209
00:08:24,300 --> 00:08:26,280
pointer to a single field and pass that

210
00:08:26,280 --> 00:08:30,479
on but you can't derive a pointer to the

211
00:08:30,479 --> 00:08:32,700
slab that the allocator carved that out

212
00:08:32,700 --> 00:08:35,000
from

213
00:08:35,458 --> 00:08:37,380
um and the Really key thing is this is

214
00:08:37,380 --> 00:08:39,599
not advisory this is not something that

215
00:08:39,599 --> 00:08:41,940
involves lookup tables so it really

216
00:08:41,940 --> 00:08:43,799
takes the principle of intentionality

217
00:08:43,799 --> 00:08:46,380
down to the hardware level every memory

218
00:08:46,380 --> 00:08:48,540
access takes one of these Hardware

219
00:08:48,540 --> 00:08:51,959
defined pointer types as the operands

220
00:08:51,959 --> 00:08:54,839
that identifies the Base address so if

221
00:08:54,839 --> 00:08:57,420
you do a load or a store or a jump you

222
00:08:57,420 --> 00:08:59,220
have to provide a hardware defined

223
00:08:59,220 --> 00:09:02,720
pointer and you have to have the right

224
00:09:02,720 --> 00:09:05,700
through that specific pointer to access

225
00:09:05,700 --> 00:09:08,040
that object so if you go out of bounds

226
00:09:08,040 --> 00:09:11,399
in a an array for example just because

227
00:09:11,399 --> 00:09:13,200
you happen to have the rights to the

228
00:09:13,200 --> 00:09:14,880
object that was allocated immediately

229
00:09:14,880 --> 00:09:18,060
after that doesn't mean that hooray

230
00:09:18,060 --> 00:09:20,519
you're out of bounds access will work

231
00:09:20,519 --> 00:09:22,620
there's one other feature of cherry that

232
00:09:22,620 --> 00:09:25,560
I want to briefly mention that we build

233
00:09:25,560 --> 00:09:28,560
on quite a lot which is this notion of

234
00:09:28,560 --> 00:09:31,320
ceiling where you have a single

235
00:09:31,320 --> 00:09:33,899
instruction that takes two of these

236
00:09:33,899 --> 00:09:35,820
pointer-like values one of them really

237
00:09:35,820 --> 00:09:37,800
is a pointer the other is it's sort of

238
00:09:37,800 --> 00:09:39,440
like a pointer but in a different

239
00:09:39,440 --> 00:09:41,580
identifier space

240
00:09:41,580 --> 00:09:44,640
and the thing you get out of this is

241
00:09:44,640 --> 00:09:47,220
a sealed pointer so so this is sort of

242
00:09:47,220 --> 00:09:50,040
like a pointer to an opaque type but

243
00:09:50,040 --> 00:09:53,220
that opacity is enforced in Hardware if

244
00:09:53,220 --> 00:09:55,200
I use that as the base for a load or a

245
00:09:55,200 --> 00:09:57,480
store instruction I'll get a trap saying

246
00:09:57,480 --> 00:09:59,339
sorry this is a seal pointer you can't

247
00:09:59,339 --> 00:10:00,839
do anything with it

248
00:10:00,839 --> 00:10:02,820
the only thing that I can do with it

249
00:10:02,820 --> 00:10:04,680
other than you know delete it you know

250
00:10:04,680 --> 00:10:07,620
overwrite it with data is parted as one

251
00:10:07,620 --> 00:10:10,440
of the inputs to an unseal operation and

252
00:10:10,440 --> 00:10:13,140
that unseal operation will fail unless I

253
00:10:13,140 --> 00:10:16,260
also pass it the thing that was used to

254
00:10:16,260 --> 00:10:18,959
seal it in the first place

255
00:10:18,959 --> 00:10:20,100
um

256
00:10:20,100 --> 00:10:23,220
if I give you some other data and you

257
00:10:23,220 --> 00:10:26,220
try and unseal it then you get an

258
00:10:26,220 --> 00:10:28,260
untagged value so a thing that we know

259
00:10:28,260 --> 00:10:30,959
in Hardware is not a valid pointer and

260
00:10:30,959 --> 00:10:32,220
if you try and use that for anything

261
00:10:32,220 --> 00:10:34,440
it'll trap and you can easily test it

262
00:10:34,440 --> 00:10:38,459
and say is this a valid pointer

263
00:10:38,459 --> 00:10:40,800
so this is this is sort of where we were

264
00:10:40,800 --> 00:10:43,140
at the start of the project and I said

265
00:10:43,140 --> 00:10:45,420
Cherry's been around for a while but

266
00:10:45,420 --> 00:10:48,899
most of the work has been on 64-bit

267
00:10:48,899 --> 00:10:50,880
systems and actually if how many of you

268
00:10:50,880 --> 00:10:52,320
are following the conference Twitter

269
00:10:52,320 --> 00:10:54,120
feed

270
00:10:54,120 --> 00:10:55,860
a few people

271
00:10:55,860 --> 00:10:57,720
um so if you've seen the video that we

272
00:10:57,720 --> 00:11:00,180
just put up there of The Chariot system

273
00:11:00,180 --> 00:11:02,100
sitting on my desk if you squint a

274
00:11:02,100 --> 00:11:04,560
little bit and look in the corner of

275
00:11:04,560 --> 00:11:07,740
that you'll see uh there's an armorello

276
00:11:07,740 --> 00:11:11,279
system which is one of the 64-bit uh

277
00:11:11,279 --> 00:11:13,740
neoverse N1 derived systems that arms

278
00:11:13,740 --> 00:11:15,600
produce these are absolutely fantastic

279
00:11:15,600 --> 00:11:17,760
machines and I'm kind of sad I only have

280
00:11:17,760 --> 00:11:20,279
one at work and not one at home

281
00:11:20,279 --> 00:11:21,000
um

282
00:11:21,000 --> 00:11:23,880
but to go from from these large systems

283
00:11:23,880 --> 00:11:25,860
designed to run Unix or Windows

284
00:11:25,860 --> 00:11:28,740
operating systems and to scale it really

285
00:11:28,740 --> 00:11:32,700
down to Tiny embedded devices uh

286
00:11:32,700 --> 00:11:35,519
we we had a lot of work to do

287
00:11:35,519 --> 00:11:39,060
when you start with a cherry system you

288
00:11:39,060 --> 00:11:42,060
have your normal address in a pointer so

289
00:11:42,060 --> 00:11:44,100
if you've got a 64-bit system you've got

290
00:11:44,100 --> 00:11:46,680
a 64-bit address field and you double

291
00:11:46,680 --> 00:11:49,680
that so you've got 64 bits available for

292
00:11:49,680 --> 00:11:51,899
metadata and that lets you encode the

293
00:11:51,899 --> 00:11:53,700
bass and the permissions and all the

294
00:11:53,700 --> 00:11:54,959
other nice stuff

295
00:11:54,959 --> 00:11:57,899
when you shrink it to 32 bits you also

296
00:11:57,899 --> 00:12:00,180
half the metadata size and some of those

297
00:12:00,180 --> 00:12:03,180
things scale reasonably well so the

298
00:12:03,180 --> 00:12:06,540
bounds encoding it's not quite ideal

299
00:12:06,540 --> 00:12:08,339
because there's a lot of redundancy

300
00:12:08,339 --> 00:12:10,800
between the base of an object the top of

301
00:12:10,800 --> 00:12:13,740
an object and the address within that

302
00:12:13,740 --> 00:12:16,500
object that a pointer refers to which

303
00:12:16,500 --> 00:12:18,779
allows us to fit effectively three

304
00:12:18,779 --> 00:12:22,940
64-bit values in in less than 128 bits

305
00:12:22,940 --> 00:12:25,440
and some of that redundancy is is

306
00:12:25,440 --> 00:12:28,079
reduced when you try and Shrink things

307
00:12:28,079 --> 00:12:30,360
down but the number of permissions and

308
00:12:30,360 --> 00:12:32,339
everything else just doesn't

309
00:12:32,339 --> 00:12:34,500
intrinsically change so we needed to

310
00:12:34,500 --> 00:12:37,740
find a way of taking twice as much

311
00:12:37,740 --> 00:12:41,100
information as we could fit and

312
00:12:41,100 --> 00:12:43,320
squeezing it into that that tiny space

313
00:12:43,320 --> 00:12:45,839
so one of the things that we did with

314
00:12:45,839 --> 00:12:48,600
the big Cherry systems is guarantee that

315
00:12:48,600 --> 00:12:51,060
out of bounds accesses are representable

316
00:12:51,060 --> 00:12:53,339
for at least 4K because it turns out

317
00:12:53,339 --> 00:12:55,980
people who write C code for big Unix

318
00:12:55,980 --> 00:12:58,800
systems do terrible terrible things with

319
00:12:58,800 --> 00:13:01,680
pointers and as long as you bring them

320
00:13:01,680 --> 00:13:03,480
back into bounce before you dereference

321
00:13:03,480 --> 00:13:04,820
them it's fine

322
00:13:04,820 --> 00:13:07,920
embedded code it turns out people are a

323
00:13:07,920 --> 00:13:09,480
lot more careful they have to Target

324
00:13:09,480 --> 00:13:12,720
weird architectures like pick 24 and

325
00:13:12,720 --> 00:13:14,880
Harvard architectures and things with

326
00:13:14,880 --> 00:13:17,160
split memory layouts and so they

327
00:13:17,160 --> 00:13:19,500
actually tend to follow the rules of C

328
00:13:19,500 --> 00:13:22,320
or the intersection of the rules of 12

329
00:13:22,320 --> 00:13:26,160
different weird sea dialects a lot more

330
00:13:26,160 --> 00:13:27,240
carefully

331
00:13:27,240 --> 00:13:30,300
so we were able to get good bounce

332
00:13:30,300 --> 00:13:33,839
Precision but by not guaranteeing an out

333
00:13:33,839 --> 00:13:35,660
of bounds region

334
00:13:35,660 --> 00:13:38,339
on the Morello system I think we have 18

335
00:13:38,339 --> 00:13:40,620
bits for the the type that we use for

336
00:13:40,620 --> 00:13:42,060
the ceiling mechanism from the last

337
00:13:42,060 --> 00:13:43,040
slide

338
00:13:43,040 --> 00:13:46,139
We Shrunk that down to three bits and

339
00:13:46,139 --> 00:13:48,240
added a software mechanism to virtualize

340
00:13:48,240 --> 00:13:49,079
that

341
00:13:49,079 --> 00:13:52,680
and we also took a really hard look at

342
00:13:52,680 --> 00:13:55,860
the permissions to identify which ones

343
00:13:55,860 --> 00:13:58,560
just never make sense together so one of

344
00:13:58,560 --> 00:14:00,480
the things that I wanted to do on the

345
00:14:00,480 --> 00:14:02,459
larger Cherry systems was say it's just

346
00:14:02,459 --> 00:14:06,139
Impossible by construction to implement

347
00:14:06,139 --> 00:14:09,540
a pointer that allows both executes you

348
00:14:09,540 --> 00:14:11,000
can jump to it

349
00:14:11,000 --> 00:14:13,800
and write access so if you want to write

350
00:14:13,800 --> 00:14:15,899
a jit you need to have a writable

351
00:14:15,899 --> 00:14:19,260
pointer and an executable pointer and

352
00:14:19,260 --> 00:14:24,060
then mmap came along and it made me sad

353
00:14:24,060 --> 00:14:27,300
uh but again on on embedded systems we

354
00:14:27,300 --> 00:14:30,779
we don't have Legacy apis that were

355
00:14:30,779 --> 00:14:33,000
designed for PDP 11s and slightly

356
00:14:33,000 --> 00:14:36,000
updated for vaxxers uh to deal with we

357
00:14:36,000 --> 00:14:38,040
have other exciting Legacy apis that

358
00:14:38,040 --> 00:14:40,740
give us different constraints

359
00:14:40,740 --> 00:14:42,360
um and of course the the first thing

360
00:14:42,360 --> 00:14:45,779
that you do when you're told okay you

361
00:14:45,779 --> 00:14:47,519
need to squeeze this thing into half as

362
00:14:47,519 --> 00:14:49,260
much space as you started with this go

363
00:14:49,260 --> 00:14:52,019
right what can we add

364
00:14:52,019 --> 00:14:52,860
um

365
00:14:52,860 --> 00:14:55,860
so we've added a few things that that I

366
00:14:55,860 --> 00:14:57,720
think are really useful in the embedded

367
00:14:57,720 --> 00:14:59,880
space one is is a pair of transitive

368
00:14:59,880 --> 00:15:01,199
permissions actually one of these we

369
00:15:01,199 --> 00:15:03,600
managed to get added to Morello

370
00:15:03,600 --> 00:15:05,579
um these don't just apply to a pointer

371
00:15:05,579 --> 00:15:08,100
they apply to any pointer that you load

372
00:15:08,100 --> 00:15:10,440
at any level of indirection through that

373
00:15:10,440 --> 00:15:13,139
pointer so we can use one of these to

374
00:15:13,139 --> 00:15:15,120
express deeper mutability and that means

375
00:15:15,120 --> 00:15:18,660
with a single bit flip in a register I

376
00:15:18,660 --> 00:15:21,300
can take a pointer to some object pass

377
00:15:21,300 --> 00:15:24,420
it to you and at no level of indirection

378
00:15:24,420 --> 00:15:26,579
following pointers that you load through

379
00:15:26,579 --> 00:15:28,199
that object can you end up with

380
00:15:28,199 --> 00:15:30,000
something that's writable so I can get

381
00:15:30,000 --> 00:15:33,000
really strong guarantees that if I pass

382
00:15:33,000 --> 00:15:35,279
a pointer to some complex object graph

383
00:15:35,279 --> 00:15:37,860
from one compartment to another

384
00:15:37,860 --> 00:15:41,579
it's not going to modify it at all and I

385
00:15:41,579 --> 00:15:42,899
can do the same thing with the no

386
00:15:42,899 --> 00:15:44,339
capture guarantee so the global

387
00:15:44,339 --> 00:15:46,800
permission in our system is is

388
00:15:46,800 --> 00:15:48,420
effectively the one that allows you to

389
00:15:48,420 --> 00:15:50,519
store that pointer

390
00:15:50,519 --> 00:15:52,860
um anywhere other than the stack

391
00:15:52,860 --> 00:15:55,079
and if I remove that and I remove your

392
00:15:55,079 --> 00:15:57,320
ability to load pointers that have that

393
00:15:57,320 --> 00:16:00,420
then you can store that pointer on the

394
00:16:00,420 --> 00:16:02,699
stack but when you return I know you

395
00:16:02,699 --> 00:16:04,440
haven't captured a copy of that pointer

396
00:16:04,440 --> 00:16:05,880
anywhere

397
00:16:05,880 --> 00:16:08,519
we've also added support for temporal

398
00:16:08,519 --> 00:16:10,260
safety and I'll talk about that in a

399
00:16:10,260 --> 00:16:12,060
second so

400
00:16:12,060 --> 00:16:14,240
the temporal safety support

401
00:16:14,240 --> 00:16:16,740
you can think of it as being kind of

402
00:16:16,740 --> 00:16:19,560
similar to a one bit mte scheme

403
00:16:19,560 --> 00:16:22,920
we have one bit of Shadow memory for

404
00:16:22,920 --> 00:16:27,240
every eight byte granule of real normal

405
00:16:27,240 --> 00:16:29,399
addressable memory

406
00:16:29,399 --> 00:16:31,680
every time you load a pointer the

407
00:16:31,680 --> 00:16:33,300
hardware will look up

408
00:16:33,300 --> 00:16:35,820
it will calculate the Base address of

409
00:16:35,820 --> 00:16:37,620
that pointer so I remember pointers in

410
00:16:37,620 --> 00:16:40,019
the Cherry system have a base in the top

411
00:16:40,019 --> 00:16:42,440
and an address somewhere in the middle

412
00:16:42,440 --> 00:16:45,600
we know that the bass is always within

413
00:16:45,600 --> 00:16:48,600
the range that the allocator handed out

414
00:16:48,600 --> 00:16:50,399
because we have that monotonicity

415
00:16:50,399 --> 00:16:53,459
property so you can reduce the range but

416
00:16:53,459 --> 00:16:56,519
you can't ever increase it

417
00:16:56,519 --> 00:16:58,860
um if that base is within the range

418
00:16:58,860 --> 00:17:01,019
that's designated as usable by the Heap

419
00:17:01,019 --> 00:17:03,360
then the hardware will do an additional

420
00:17:03,360 --> 00:17:06,720
read to the shadow space look up that

421
00:17:06,720 --> 00:17:09,540
bit in the bitmap and if it's set to a

422
00:17:09,540 --> 00:17:12,359
one it invalidates the pointer so

423
00:17:12,359 --> 00:17:15,299
this is a really simple degenerate

424
00:17:15,299 --> 00:17:17,280
example of a use after free you know we

425
00:17:17,280 --> 00:17:19,859
malloc some memory we log the pointer

426
00:17:19,859 --> 00:17:22,319
that's allocated we free and then we log

427
00:17:22,319 --> 00:17:24,599
the dangling pointer

428
00:17:24,599 --> 00:17:26,520
and when we

429
00:17:26,520 --> 00:17:28,679
print these two you know you can see on

430
00:17:28,679 --> 00:17:32,340
on a cherry system uh when you print a

431
00:17:32,340 --> 00:17:34,080
pointer it's not just an address we've

432
00:17:34,080 --> 00:17:37,080
got the address we've got the the range

433
00:17:37,080 --> 00:17:39,000
that it covers

434
00:17:39,000 --> 00:17:40,799
um at the far right we've got the set of

435
00:17:40,799 --> 00:17:42,960
permissions it contains so G is the

436
00:17:42,960 --> 00:17:45,480
global permission I was talking about R

437
00:17:45,480 --> 00:17:47,820
and W are read and write and then the

438
00:17:47,820 --> 00:17:49,860
lowercase ones are

439
00:17:49,860 --> 00:17:50,460
um

440
00:17:50,460 --> 00:17:52,799
dependent permission so they're ones

441
00:17:52,799 --> 00:17:55,260
that modify some existing permissions

442
00:17:55,260 --> 00:17:58,559
you have so c means if you're allowed to

443
00:17:58,559 --> 00:18:01,020
read and write you're also allowed to

444
00:18:01,020 --> 00:18:03,360
read pointers and write pointers as well

445
00:18:03,360 --> 00:18:05,280
as just data so I can give you a buffer

446
00:18:05,280 --> 00:18:07,080
that you can read data from but you

447
00:18:07,080 --> 00:18:09,299
can't read pointers from it

448
00:18:09,299 --> 00:18:12,660
um G is is the transitive thing that

449
00:18:12,660 --> 00:18:14,520
says you're allowed to load things that

450
00:18:14,520 --> 00:18:17,160
have the global permission and M is the

451
00:18:17,160 --> 00:18:20,460
transitive mutable permission so it

452
00:18:20,460 --> 00:18:22,140
permits you to load things that have

453
00:18:22,140 --> 00:18:24,419
right permission

454
00:18:24,419 --> 00:18:26,520
um and when I when when you see this

455
00:18:26,520 --> 00:18:28,140
pointer printed twice you'll see that

456
00:18:28,140 --> 00:18:30,059
only one of these bits has changed which

457
00:18:30,059 --> 00:18:32,880
is the one labeled V over here uh this

458
00:18:32,880 --> 00:18:34,440
is the valid bit which is not

459
00:18:34,440 --> 00:18:37,799
addressable in normal operation uh this

460
00:18:37,799 --> 00:18:40,080
is the bit that is an attestation from

461
00:18:40,080 --> 00:18:41,880
the hardware saying

462
00:18:41,880 --> 00:18:43,919
the things stored at this memory address

463
00:18:43,919 --> 00:18:46,679
is something that I have seen a valid

464
00:18:46,679 --> 00:18:48,960
chain of derivations from the initial

465
00:18:48,960 --> 00:18:50,940
pointers that covered the whole address

466
00:18:50,940 --> 00:18:54,480
space that I gave to the bootloader

467
00:18:54,480 --> 00:18:56,640
um and this is a hundred percent

468
00:18:56,640 --> 00:18:59,160
deterministic if you run this in in any

469
00:18:59,160 --> 00:19:01,679
configuration you'll always see that

470
00:19:01,679 --> 00:19:04,980
this thing is now not a usable pointer

471
00:19:04,980 --> 00:19:08,520
so the Baseline security that we have in

472
00:19:08,520 --> 00:19:11,460
this system is no pointer injection so

473
00:19:11,460 --> 00:19:13,620
you can't just materialize a pointer out

474
00:19:13,620 --> 00:19:16,440
of an integer if you've got some ability

475
00:19:16,440 --> 00:19:18,840
to inject arbitrary data from the

476
00:19:18,840 --> 00:19:21,299
network or whatever you can still inject

477
00:19:21,299 --> 00:19:23,880
arbitrary data you can still do data

478
00:19:23,880 --> 00:19:26,280
oriented attacks but you can't just say

479
00:19:26,280 --> 00:19:28,260
hey I know the address of this object

480
00:19:28,260 --> 00:19:30,600
I'm going to materialize a pointer there

481
00:19:30,600 --> 00:19:34,080
uh We've guarantee no bounce violation

482
00:19:34,080 --> 00:19:35,880
so whether you've got a pointer to a

483
00:19:35,880 --> 00:19:38,280
global to a spec allocation or to a heap

484
00:19:38,280 --> 00:19:40,919
allocation the hardware will trap if you

485
00:19:40,919 --> 00:19:43,440
try and access out of bounds and

486
00:19:43,440 --> 00:19:45,299
similarly we've got no use after free so

487
00:19:45,299 --> 00:19:48,000
how many people here do offensive work

488
00:19:48,000 --> 00:19:50,940
can I see some hands

489
00:19:50,940 --> 00:19:54,000
so so how many of you will have some of

490
00:19:54,000 --> 00:19:56,460
your favorite Primitives broken by this

491
00:19:56,460 --> 00:19:59,360
set of guarantees

492
00:19:59,580 --> 00:20:02,700
I'm seeing a few sad people

493
00:20:02,700 --> 00:20:05,039
um and that is my job to make all of you

494
00:20:05,039 --> 00:20:06,600
sad

495
00:20:06,600 --> 00:20:07,740
um

496
00:20:07,740 --> 00:20:09,000
so

497
00:20:09,000 --> 00:20:11,039
from from that set of Baseline security

498
00:20:11,039 --> 00:20:12,720
guarantees which everything in the

499
00:20:12,720 --> 00:20:15,360
operating system can depend on we want

500
00:20:15,360 --> 00:20:17,820
to build a compartmentalization model

501
00:20:17,820 --> 00:20:21,419
and at the the most fundamental level a

502
00:20:21,419 --> 00:20:23,280
compartment for us is really just two

503
00:20:23,280 --> 00:20:24,780
things that we point to from two

504
00:20:24,780 --> 00:20:27,419
registers one is some code and one is

505
00:20:27,419 --> 00:20:30,179
some globals and this is really just the

506
00:20:30,179 --> 00:20:32,880
stuff that's written in a c source file

507
00:20:32,880 --> 00:20:35,580
it's you know a set of functions and a

508
00:20:35,580 --> 00:20:38,700
set of globals so the program counter

509
00:20:38,700 --> 00:20:40,740
Which Intel calls an instruction pointer

510
00:20:40,740 --> 00:20:42,419
which makes this make a lot more sense

511
00:20:42,419 --> 00:20:45,240
that it's now a pointer and so it

512
00:20:45,240 --> 00:20:46,860
conveys bounds and permissions and

513
00:20:46,860 --> 00:20:48,419
everything

514
00:20:48,419 --> 00:20:51,419
um refers to the code for the currently

515
00:20:51,419 --> 00:20:53,760
running program compartment

516
00:20:53,760 --> 00:20:55,620
the global pointer is just another

517
00:20:55,620 --> 00:20:57,480
general purpose register that we happen

518
00:20:57,480 --> 00:20:59,700
to have designated for use in a special

519
00:20:59,700 --> 00:21:02,880
purpose and this has read and write and

520
00:21:02,880 --> 00:21:05,640
Global permissions and this is the

521
00:21:05,640 --> 00:21:09,780
currently executing compartments globals

522
00:21:09,780 --> 00:21:11,160
and that's a little bit of an

523
00:21:11,160 --> 00:21:13,320
oversimplification so in in the code

524
00:21:13,320 --> 00:21:15,720
section we also have read-only data so

525
00:21:15,720 --> 00:21:17,760
that we can use program counter relative

526
00:21:17,760 --> 00:21:19,320
addressing to get at all of those

527
00:21:19,320 --> 00:21:20,700
globals

528
00:21:20,700 --> 00:21:23,220
and we also have a thing called an

529
00:21:23,220 --> 00:21:25,440
export table which I'll talk through a

530
00:21:25,440 --> 00:21:27,179
little bit in a second

531
00:21:27,179 --> 00:21:29,760
and these are all readable by the

532
00:21:29,760 --> 00:21:31,980
compartment but they're not writable by

533
00:21:31,980 --> 00:21:33,299
the compartment

534
00:21:33,299 --> 00:21:35,220
we also have one more data structure

535
00:21:35,220 --> 00:21:36,900
that's associated with the compartment

536
00:21:36,900 --> 00:21:39,600
but which isn't accessible at all

537
00:21:39,600 --> 00:21:43,020
directly from the compartment and this

538
00:21:43,020 --> 00:21:46,620
this pair of Import and Export table tie

539
00:21:46,620 --> 00:21:49,080
together and and this is how we manage

540
00:21:49,080 --> 00:21:52,080
the cross-compartment transitions so if

541
00:21:52,080 --> 00:21:54,000
you look in the export table for any

542
00:21:54,000 --> 00:21:57,960
compartment the first entry is a copy of

543
00:21:57,960 --> 00:22:00,120
the program counter that you need to

544
00:22:00,120 --> 00:22:02,220
have in your program counter register to

545
00:22:02,220 --> 00:22:03,900
be executing code in that compartment

546
00:22:03,900 --> 00:22:07,039
and you can use that to derive

547
00:22:07,039 --> 00:22:09,900
pointers that you can jump to for for

548
00:22:09,900 --> 00:22:13,080
entry points in that compartment

549
00:22:13,080 --> 00:22:15,179
um it has similarly the global pointer

550
00:22:15,179 --> 00:22:17,100
for the compartment so it has the the

551
00:22:17,100 --> 00:22:19,919
two things that I said before identify

552
00:22:19,919 --> 00:22:22,260
and describe the contents of a

553
00:22:22,260 --> 00:22:23,340
compartment

554
00:22:23,340 --> 00:22:26,820
and beyond that it has a load of 32-bit

555
00:22:26,820 --> 00:22:29,640
entries that describe an entry point so

556
00:22:29,640 --> 00:22:31,500
they say where is it within the program

557
00:22:31,500 --> 00:22:34,860
counter uh how many

558
00:22:34,860 --> 00:22:36,000
um

559
00:22:36,000 --> 00:22:38,220
uh how many argument registers are used

560
00:22:38,220 --> 00:22:40,500
so that the switcher that handles our

561
00:22:40,500 --> 00:22:42,299
compartment transition can clear the

562
00:22:42,299 --> 00:22:44,760
others does it run with interrupt

563
00:22:44,760 --> 00:22:47,940
enabled or interrupts disabled

564
00:22:47,940 --> 00:22:49,020
um

565
00:22:49,020 --> 00:22:53,280
and then on the other side we have

566
00:22:53,280 --> 00:22:56,100
entries in the import table which are

567
00:22:56,100 --> 00:22:58,080
sealed capabilities that refer to

568
00:22:58,080 --> 00:23:01,200
another compartments export table so

569
00:23:01,200 --> 00:23:02,880
these have the bounds of the export

570
00:23:02,880 --> 00:23:05,820
table they have the address of a

571
00:23:05,820 --> 00:23:08,460
particular entry point entry and they're

572
00:23:08,460 --> 00:23:10,140
sealed which means that the compartment

573
00:23:10,140 --> 00:23:12,120
that can load them can't actually look

574
00:23:12,120 --> 00:23:15,059
inside them all it can do with them is

575
00:23:15,059 --> 00:23:16,860
hand them to the compartments which

576
00:23:16,860 --> 00:23:20,940
which is then able to unseal them

577
00:23:20,940 --> 00:23:24,059
finds the start of the export table

578
00:23:24,059 --> 00:23:26,340
load the program counter load the global

579
00:23:26,340 --> 00:23:31,020
pointer and handle that transition

580
00:23:31,020 --> 00:23:33,020
um

581
00:23:34,200 --> 00:23:36,659
the the really key point there with the

582
00:23:36,659 --> 00:23:39,240
ceiling is it it guarantees Integrity

583
00:23:39,240 --> 00:23:40,980
for those so

584
00:23:40,980 --> 00:23:43,500
nothing in the system can just fabricate

585
00:23:43,500 --> 00:23:46,260
one of these and hand it to the uh to

586
00:23:46,260 --> 00:23:48,720
the compartments which are these have to

587
00:23:48,720 --> 00:23:51,539
be set up when when we load the firmware

588
00:23:51,539 --> 00:23:54,539
image at the very first boot time

589
00:23:54,539 --> 00:23:57,780
so I've sort of hand waved a bit and and

590
00:23:57,780 --> 00:23:59,640
talked about this in the abstract let's

591
00:23:59,640 --> 00:24:01,620
let's look at really what the register

592
00:24:01,620 --> 00:24:03,480
and memory layout look like when we're

593
00:24:03,480 --> 00:24:06,539
doing a a compartment transition

594
00:24:06,539 --> 00:24:08,700
so we've got our program counter

595
00:24:08,700 --> 00:24:10,260
register and it's pointing at the

596
00:24:10,260 --> 00:24:12,000
currently executing compartments code

597
00:24:12,000 --> 00:24:14,700
we've got the global pointer and it's

598
00:24:14,700 --> 00:24:16,200
pointing again at the currently

599
00:24:16,200 --> 00:24:19,380
executing compartment globals

600
00:24:19,380 --> 00:24:21,539
and we've got the stack pointer which is

601
00:24:21,539 --> 00:24:24,020
the third thing that really identifies

602
00:24:24,020 --> 00:24:27,360
one of the roots of of available memory

603
00:24:27,360 --> 00:24:29,220
for a part of the running system so this

604
00:24:29,220 --> 00:24:31,740
refers to the current thread stack

605
00:24:31,740 --> 00:24:35,039
and again it's a cherry pointer it

606
00:24:35,039 --> 00:24:37,620
conveys bounds and permissions for the

607
00:24:37,620 --> 00:24:38,880
current stack

608
00:24:38,880 --> 00:24:40,980
and we probably have some Heap objects

609
00:24:40,980 --> 00:24:43,140
so one of the nice properties of this

610
00:24:43,140 --> 00:24:46,080
system is that we have a shared Heap

611
00:24:46,080 --> 00:24:49,380
that allows you to use the same really

612
00:24:49,380 --> 00:24:51,840
small chunk of SRAM that backs your HEAP

613
00:24:51,840 --> 00:24:53,460
between mutually distrusting

614
00:24:53,460 --> 00:24:55,860
compartments and one of the things we

615
00:24:55,860 --> 00:24:57,900
heard about yesterday was post Quantum

616
00:24:57,900 --> 00:24:59,760
crypto and the need for crypto agility

617
00:24:59,760 --> 00:25:01,799
there which unfortunately means doing it

618
00:25:01,799 --> 00:25:03,600
in software on a lot of these embedded

619
00:25:03,600 --> 00:25:05,580
systems

620
00:25:05,580 --> 00:25:08,120
um most post-quantum crypto algorithms

621
00:25:08,120 --> 00:25:12,120
have really high memory requirements but

622
00:25:12,120 --> 00:25:14,460
for an embedded device like this we only

623
00:25:14,460 --> 00:25:17,039
need to use that memory when we're doing

624
00:25:17,039 --> 00:25:19,980
initial key exchange at boot when we

625
00:25:19,980 --> 00:25:21,659
connect to the server

626
00:25:21,659 --> 00:25:24,900
so having a shared Heap is really useful

627
00:25:24,900 --> 00:25:27,720
for that kind of thing because we start

628
00:25:27,720 --> 00:25:29,940
running we do the key exchange we

629
00:25:29,940 --> 00:25:32,220
allocate a load of memory now we've got

630
00:25:32,220 --> 00:25:34,200
our symmetric keys

631
00:25:34,200 --> 00:25:36,360
and now we can free all of those objects

632
00:25:36,360 --> 00:25:38,100
and now whatever needs to run in the

633
00:25:38,100 --> 00:25:40,080
next phase of computation can reuse that

634
00:25:40,080 --> 00:25:42,000
memory and on big systems that's not a

635
00:25:42,000 --> 00:25:43,740
thing that you'd even think about

636
00:25:43,740 --> 00:25:46,799
talking about because the idea that you

637
00:25:46,799 --> 00:25:48,720
would statically allocate memory for

638
00:25:48,720 --> 00:25:51,059
everything is just crazy if you're

639
00:25:51,059 --> 00:25:52,740
looking at a Linux or a Windows system

640
00:25:52,740 --> 00:25:55,320
but in in embedded systems it's really

641
00:25:55,320 --> 00:25:59,100
common because you don't have a secure

642
00:25:59,100 --> 00:26:01,980
way of of guaranteeing non-interference

643
00:26:01,980 --> 00:26:06,000
between mutually distrusting Parts

644
00:26:06,000 --> 00:26:08,700
um in the presence of a shared Heap okay

645
00:26:08,700 --> 00:26:10,980
so so in in this example we've got some

646
00:26:10,980 --> 00:26:12,900
Heap objects some are reachable from the

647
00:26:12,900 --> 00:26:15,020
stack some are reachable from globals

648
00:26:15,020 --> 00:26:18,900
and we want to transition to running in

649
00:26:18,900 --> 00:26:20,580
compartment B

650
00:26:20,580 --> 00:26:23,820
so the first thing we we need to think

651
00:26:23,820 --> 00:26:25,620
about is

652
00:26:25,620 --> 00:26:27,900
we kind of want compartment B to do

653
00:26:27,900 --> 00:26:30,299
something with some data we give it and

654
00:26:30,299 --> 00:26:32,580
and if you remember two things from this

655
00:26:32,580 --> 00:26:34,620
talk the second thing I'd like everyone

656
00:26:34,620 --> 00:26:37,919
to try and remember is isolation is easy

657
00:26:37,919 --> 00:26:39,960
sharing is hard

658
00:26:39,960 --> 00:26:42,179
you know we know how to build isolated

659
00:26:42,179 --> 00:26:45,059
systems you you have a computer you

660
00:26:45,059 --> 00:26:47,760
don't connect any wires to it right and

661
00:26:47,760 --> 00:26:50,520
now we've got fantastic security we

662
00:26:50,520 --> 00:26:52,500
don't have great

663
00:26:52,500 --> 00:26:55,440
usability because you know we actually

664
00:26:55,440 --> 00:26:58,080
need these things to interact

665
00:26:58,080 --> 00:26:59,039
um

666
00:26:59,039 --> 00:27:01,679
and so when you want to build a system

667
00:27:01,679 --> 00:27:04,500
for for isolation the first thing you

668
00:27:04,500 --> 00:27:06,840
need to think about is how do we do

669
00:27:06,840 --> 00:27:09,360
sharing and if you can do sharing well

670
00:27:09,360 --> 00:27:11,640
the isolation bid is basically free but

671
00:27:11,640 --> 00:27:13,640
if you start by thinking about isolation

672
00:27:13,640 --> 00:27:16,380
and then try and build sharing on later

673
00:27:16,380 --> 00:27:18,900
then you'll be in for a whole world of

674
00:27:18,900 --> 00:27:21,659
pain and suffering

675
00:27:21,659 --> 00:27:23,640
um so in our world you know we I've just

676
00:27:23,640 --> 00:27:25,500
added another register to this list on

677
00:27:25,500 --> 00:27:27,539
on the left this is the first argument

678
00:27:27,539 --> 00:27:31,020
register and we put a pointer in there

679
00:27:31,020 --> 00:27:32,700
um and this is a pointer to one of the

680
00:27:32,700 --> 00:27:35,640
Heap objects and because this is a

681
00:27:35,640 --> 00:27:37,320
cherry pointer this is a thing that

682
00:27:37,320 --> 00:27:39,179
purely by owning it

683
00:27:39,179 --> 00:27:42,659
uh it conveys the rights that allow you

684
00:27:42,659 --> 00:27:44,700
to access that object

685
00:27:44,700 --> 00:27:47,100
and this is this is exactly the same way

686
00:27:47,100 --> 00:27:50,039
that you pass uh a pointer to some

687
00:27:50,039 --> 00:27:52,260
arbitrary object to any other function

688
00:27:52,260 --> 00:27:54,299
not necessarily one that's across the

689
00:27:54,299 --> 00:27:56,760
main call so it it really mirrors what

690
00:27:56,760 --> 00:28:00,419
the compiler already knows how to do

691
00:28:00,419 --> 00:28:02,520
so when we invoke the compartment

692
00:28:02,520 --> 00:28:05,700
switcher it's going to end up updating

693
00:28:05,700 --> 00:28:08,100
the program counter to the new

694
00:28:08,100 --> 00:28:10,140
compartments code and it'll be at a

695
00:28:10,140 --> 00:28:13,140
specific offset in there that's based on

696
00:28:13,140 --> 00:28:16,919
the entry point that you handed it from

697
00:28:16,919 --> 00:28:19,559
the import table

698
00:28:19,559 --> 00:28:20,880
um it's going to update the global

699
00:28:20,880 --> 00:28:24,900
pointer to the new compartments globals

700
00:28:24,900 --> 00:28:26,760
it's going to do all of these things as

701
00:28:26,760 --> 00:28:28,380
an atomic step

702
00:28:28,380 --> 00:28:30,240
at least from the perspective of the

703
00:28:30,240 --> 00:28:32,760
caller it's not you know actually

704
00:28:32,760 --> 00:28:34,799
stopping the world and doing everything

705
00:28:34,799 --> 00:28:37,140
in one clock cycle

706
00:28:37,140 --> 00:28:38,640
um

707
00:28:38,640 --> 00:28:41,820
the most important thing it does is

708
00:28:41,820 --> 00:28:45,840
subset that stack region so when you're

709
00:28:45,840 --> 00:28:48,419
executing in compartment B you've now

710
00:28:48,419 --> 00:28:50,460
lost access to the chunk of the stack

711
00:28:50,460 --> 00:28:53,220
that compartment a was using

712
00:28:53,220 --> 00:28:56,700
and actually to to preserve uh

713
00:28:56,700 --> 00:28:58,980
confidentiality it'll zero that chunk of

714
00:28:58,980 --> 00:29:00,840
the stack both on call and return and

715
00:29:00,840 --> 00:29:02,700
again this is something I would love to

716
00:29:02,700 --> 00:29:06,179
do on the 64-bit systems but on systems

717
00:29:06,179 --> 00:29:09,299
where a two kilobyte stack is huge it's

718
00:29:09,299 --> 00:29:11,940
totally feasible on systems where a two

719
00:29:11,940 --> 00:29:15,960
megabyte stack is small not so much

720
00:29:15,960 --> 00:29:16,740
um

721
00:29:16,740 --> 00:29:19,980
so when we finish this transition we've

722
00:29:19,980 --> 00:29:21,899
lost access to all of the objects that

723
00:29:21,899 --> 00:29:24,480
we no longer hold pointers to so we've

724
00:29:24,480 --> 00:29:26,159
lost access to the top of the stack

725
00:29:26,159 --> 00:29:28,200
we've lost access to compartment A's

726
00:29:28,200 --> 00:29:30,480
code and globals and we've also lost

727
00:29:30,480 --> 00:29:32,880
access to any of the Heap objects that

728
00:29:32,880 --> 00:29:34,559
aren't reachable from that argument

729
00:29:34,559 --> 00:29:35,760
register

730
00:29:35,760 --> 00:29:38,100
and if you think about this in terms of

731
00:29:38,100 --> 00:29:40,500
C source code you you'll never actually

732
00:29:40,500 --> 00:29:42,659
go through a process that looks like

733
00:29:42,659 --> 00:29:45,179
this you just write a function call and

734
00:29:45,179 --> 00:29:46,860
you slap an annotation on it and you're

735
00:29:46,860 --> 00:29:48,899
done

736
00:29:48,899 --> 00:29:52,500
so now we're in a world where we have

737
00:29:52,500 --> 00:29:55,860
some really strong guarantees across

738
00:29:55,860 --> 00:29:58,679
compartments we've got no implicit

739
00:29:58,679 --> 00:30:01,020
sharing if you want to share data from

740
00:30:01,020 --> 00:30:02,820
one compartment to another you pass a

741
00:30:02,820 --> 00:30:04,919
pointer so that's something that's

742
00:30:04,919 --> 00:30:07,500
visible in your source code you don't

743
00:30:07,500 --> 00:30:09,840
need to go and look at some other policy

744
00:30:09,840 --> 00:30:13,860
described in a different file you just

745
00:30:13,860 --> 00:30:15,360
look at the entry points for a

746
00:30:15,360 --> 00:30:17,399
compartment you say what arguments do

747
00:30:17,399 --> 00:30:19,140
they take okay those are the things that

748
00:30:19,140 --> 00:30:22,200
are shared and you can clear permissions

749
00:30:22,200 --> 00:30:25,140
on some of those you can do a lot before

750
00:30:25,140 --> 00:30:27,059
you make the call to restrict what it

751
00:30:27,059 --> 00:30:30,240
can do so we can guarantee that a

752
00:30:30,240 --> 00:30:32,580
compartment that you call can't capture

753
00:30:32,580 --> 00:30:34,440
a pointer that you've passed it we can

754
00:30:34,440 --> 00:30:37,440
guarantee you that it can't modify the

755
00:30:37,440 --> 00:30:40,140
object that you're pointing to and we

756
00:30:40,140 --> 00:30:42,299
can provide those as either deep or

757
00:30:42,299 --> 00:30:44,760
shallow properties so I can give you an

758
00:30:44,760 --> 00:30:47,880
immutable object that contains pointers

759
00:30:47,880 --> 00:30:49,500
to things that you are allowed to modify

760
00:30:49,500 --> 00:30:52,200
so if I want to have my metadata at the

761
00:30:52,200 --> 00:30:54,120
start and then a pointer to a buffer

762
00:30:54,120 --> 00:30:55,919
that you're allowed to modify that's

763
00:30:55,919 --> 00:30:58,200
totally fine

764
00:30:58,200 --> 00:30:58,860
um

765
00:30:58,860 --> 00:31:00,899
and we're really only just starting to

766
00:31:00,899 --> 00:31:02,520
explore the kinds of things that you can

767
00:31:02,520 --> 00:31:04,740
build with this

768
00:31:04,740 --> 00:31:05,480
um

769
00:31:05,480 --> 00:31:07,080
so

770
00:31:07,080 --> 00:31:09,299
in in the software stack there are

771
00:31:09,299 --> 00:31:11,880
really four trusted compartments or I

772
00:31:11,880 --> 00:31:14,279
think people in this audience call these

773
00:31:14,279 --> 00:31:17,039
things targets

774
00:31:17,039 --> 00:31:18,960
um

775
00:31:18,960 --> 00:31:21,539
and as I said before all of this is on

776
00:31:21,539 --> 00:31:23,580
GitHub there are a few known

777
00:31:23,580 --> 00:31:26,580
vulnerabilities that we have solutions

778
00:31:26,580 --> 00:31:29,640
for we just haven't had time to fix

779
00:31:29,640 --> 00:31:31,679
please find more

780
00:31:31,679 --> 00:31:34,799
ideally tell us about them

781
00:31:34,799 --> 00:31:36,899
um actually ideally give us fixes you

782
00:31:36,899 --> 00:31:38,460
know we we would welcome more

783
00:31:38,460 --> 00:31:40,559
contributors but you know at least

784
00:31:40,559 --> 00:31:42,779
finding them is is a great start

785
00:31:42,779 --> 00:31:45,779
so when the system starts running the

786
00:31:45,779 --> 00:31:48,419
hardware gives you the the root pointers

787
00:31:48,419 --> 00:31:51,179
that Grant you execute access to whole

788
00:31:51,179 --> 00:31:53,820
of memory right access to the whole of

789
00:31:53,820 --> 00:31:57,240
memory and seal and unseal access to the

790
00:31:57,240 --> 00:32:00,419
whole ceiling space so when the loader

791
00:32:00,419 --> 00:32:02,460
starts running it can do absolutely

792
00:32:02,460 --> 00:32:05,220
anything this is the most privileged

793
00:32:05,220 --> 00:32:08,340
thing in the system and it tries really

794
00:32:08,340 --> 00:32:11,279
aggressively to drop privileges

795
00:32:11,279 --> 00:32:13,440
um the the main

796
00:32:13,440 --> 00:32:15,539
reason I'm not too worried about the

797
00:32:15,539 --> 00:32:17,820
loader is it never runs on untrusted

798
00:32:17,820 --> 00:32:19,919
data it runs on the firmware image

799
00:32:19,919 --> 00:32:22,320
that's sent to your device which in a

800
00:32:22,320 --> 00:32:24,179
real deployment would be signed and

801
00:32:24,179 --> 00:32:26,399
would have been audited

802
00:32:26,399 --> 00:32:27,600
um

803
00:32:27,600 --> 00:32:31,320
if you are building a device that has

804
00:32:31,320 --> 00:32:34,260
flash memory with execute in place that

805
00:32:34,260 --> 00:32:36,419
can store pointers you actually don't

806
00:32:36,419 --> 00:32:38,460
need the loader at all this is entirely

807
00:32:38,460 --> 00:32:41,580
a link time thing but for a lot of the

808
00:32:41,580 --> 00:32:43,260
potential deployments we want to be able

809
00:32:43,260 --> 00:32:44,899
to dynamically

810
00:32:44,899 --> 00:32:48,480
load code over JTAG or from existing

811
00:32:48,480 --> 00:32:51,960
serial flash directly into SRAM

812
00:32:51,960 --> 00:32:53,340
um

813
00:32:53,340 --> 00:32:55,320
the last thing that the loader does is

814
00:32:55,320 --> 00:32:56,700
erase itself

815
00:32:56,700 --> 00:32:58,980
so before it actually starts the

816
00:32:58,980 --> 00:33:00,779
scheduler running before we're actually

817
00:33:00,779 --> 00:33:02,640
running any of the code that was in the

818
00:33:02,640 --> 00:33:04,039
firmware image

819
00:33:04,039 --> 00:33:06,600
the loader has a little Loop that goes

820
00:33:06,600 --> 00:33:08,399
and scrubs the stack that it was using

821
00:33:08,399 --> 00:33:11,520
it raises all of the code and all of

822
00:33:11,520 --> 00:33:13,740
that then gets recycled for use as Heap

823
00:33:13,740 --> 00:33:15,720
memory

824
00:33:15,720 --> 00:33:18,179
so the next most privileged thing is the

825
00:33:18,179 --> 00:33:20,760
switcher and this is the thing that can

826
00:33:20,760 --> 00:33:23,760
unseal those export table entries it's

827
00:33:23,760 --> 00:33:27,360
the thing that handles exceptions when

828
00:33:27,360 --> 00:33:29,399
you get an interrupt when you take a

829
00:33:29,399 --> 00:33:33,419
fault from going out of bounds

830
00:33:33,419 --> 00:33:34,019
um

831
00:33:34,019 --> 00:33:36,899
this is the only thing in the system

832
00:33:36,899 --> 00:33:40,860
that can violate our compartment

833
00:33:40,860 --> 00:33:43,320
isolation or thread isolation guarantees

834
00:33:43,320 --> 00:33:46,019
if you find a bug in it

835
00:33:46,019 --> 00:33:48,240
um it's about 300 instructions so to put

836
00:33:48,240 --> 00:33:51,480
that in perspective uh the cell for

837
00:33:51,480 --> 00:33:54,539
formally verified micro kernel has about

838
00:33:54,539 --> 00:33:57,600
as many unverified assembly instructions

839
00:33:57,600 --> 00:34:00,899
in their TCB as we do

840
00:34:00,899 --> 00:34:03,779
um but in our case that all of our TCB

841
00:34:03,779 --> 00:34:06,360
for confidentiality and integrity

842
00:34:06,360 --> 00:34:09,780
and we really would like to engage with

843
00:34:09,780 --> 00:34:12,000
people who can formally verify it we

844
00:34:12,000 --> 00:34:14,820
have a formal model of the ISA

845
00:34:14,820 --> 00:34:16,980
um the control flow in this is

846
00:34:16,980 --> 00:34:19,219
relatively easy to reason about

847
00:34:19,219 --> 00:34:21,480
a lot of it runs with interrupts

848
00:34:21,480 --> 00:34:23,820
disabled so it's actually well within

849
00:34:23,820 --> 00:34:25,800
scope to be feasible for formal

850
00:34:25,800 --> 00:34:28,020
verification

851
00:34:28,020 --> 00:34:30,659
and then we've got the scheduler

852
00:34:30,659 --> 00:34:34,199
um the scheduler is by definition core

853
00:34:34,199 --> 00:34:36,119
of your TCB for availability the

854
00:34:36,119 --> 00:34:38,460
scheduler is really just a thing that is

855
00:34:38,460 --> 00:34:39,540
told

856
00:34:39,540 --> 00:34:41,639
which thread should I run now and it

857
00:34:41,639 --> 00:34:43,739
replies and so it can obviously just say

858
00:34:43,739 --> 00:34:45,899
I don't want to run any threads now or

859
00:34:45,899 --> 00:34:47,760
or just I don't like that one that

860
00:34:47,760 --> 00:34:49,800
thread's not going to run

861
00:34:49,800 --> 00:34:52,260
um when this happens

862
00:34:52,260 --> 00:34:53,820
you know you've got an availability

863
00:34:53,820 --> 00:34:55,859
compromise if you

864
00:34:55,859 --> 00:34:58,080
the scheduler runs it in a compartment

865
00:34:58,080 --> 00:34:59,760
like everything else in the system if

866
00:34:59,760 --> 00:35:01,619
you manage to get complete control of

867
00:35:01,619 --> 00:35:03,599
that compartment you can choose which

868
00:35:03,599 --> 00:35:05,400
threads run you can choose which threads

869
00:35:05,400 --> 00:35:07,140
don't run

870
00:35:07,140 --> 00:35:10,440
but you can't see the register files you

871
00:35:10,440 --> 00:35:12,359
can't see the stacks of any of the

872
00:35:12,359 --> 00:35:15,060
threads that run when we take an

873
00:35:15,060 --> 00:35:16,140
interrupt

874
00:35:16,140 --> 00:35:20,280
switcher spills the register frame into

875
00:35:20,280 --> 00:35:22,500
the save area associated with the

876
00:35:22,500 --> 00:35:24,720
current thread and it then seals that

877
00:35:24,720 --> 00:35:27,060
pointer and hands it to the scheduler

878
00:35:27,060 --> 00:35:29,220
and this means the scheduler just has no

879
00:35:29,220 --> 00:35:31,140
peak token for every thread that's

880
00:35:31,140 --> 00:35:32,160
running

881
00:35:32,160 --> 00:35:34,619
when it returns from the entry point

882
00:35:34,619 --> 00:35:37,320
that the switcher calls it gives back

883
00:35:37,320 --> 00:35:38,940
one of these things the switcher

884
00:35:38,940 --> 00:35:40,800
unseales it and the switcher then tries

885
00:35:40,800 --> 00:35:42,420
to use it

886
00:35:42,420 --> 00:35:45,079
um if it's not a valid

887
00:35:45,079 --> 00:35:48,540
thread entry point sealed by the

888
00:35:48,540 --> 00:35:51,359
um by the switcher that unseal operation

889
00:35:51,359 --> 00:35:54,359
fails and we determine the system's

890
00:35:54,359 --> 00:35:56,220
under attack and we just

891
00:35:56,220 --> 00:35:57,960
but actually we go through a slightly

892
00:35:57,960 --> 00:36:01,260
convoluted path into an infinite Loop

893
00:36:01,260 --> 00:36:03,720
um but we we hit something that can be

894
00:36:03,720 --> 00:36:05,460
detected in the hardware to trigger a

895
00:36:05,460 --> 00:36:07,260
reset

896
00:36:07,260 --> 00:36:09,900
final bit of rtcb is is the memory

897
00:36:09,900 --> 00:36:11,820
allocates that I talked about so the

898
00:36:11,820 --> 00:36:14,460
hardware will enforce temporal safety it

899
00:36:14,460 --> 00:36:15,859
will enforce

900
00:36:15,859 --> 00:36:19,500
spatial safety but it needs someone to

901
00:36:19,500 --> 00:36:21,240
tell it what the bounds of an allocation

902
00:36:21,240 --> 00:36:23,820
are it needs someone to tell it when an

903
00:36:23,820 --> 00:36:26,460
object's being deallocated

904
00:36:26,460 --> 00:36:28,859
um so the scheduler sorry the scheduler

905
00:36:28,859 --> 00:36:31,079
the allocator is responsible for doing

906
00:36:31,079 --> 00:36:32,940
that and it's also responsible for some

907
00:36:32,940 --> 00:36:35,700
availability properties like enforcing

908
00:36:35,700 --> 00:36:38,760
quotas on different compartments

909
00:36:38,760 --> 00:36:41,220
it's really important to note that the

910
00:36:41,220 --> 00:36:44,099
allocator is not in your TCB for

911
00:36:44,099 --> 00:36:47,099
anything other than heat memory so it's

912
00:36:47,099 --> 00:36:49,619
not a super privileged thing it holds a

913
00:36:49,619 --> 00:36:52,380
pointer to the entire Heap and it holds

914
00:36:52,380 --> 00:36:55,740
a pointer to the entire Shadow memory it

915
00:36:55,740 --> 00:36:57,780
can tamper with whatever it likes in the

916
00:36:57,780 --> 00:37:00,060
Heap but it has no access to anyone

917
00:37:00,060 --> 00:37:02,579
else's Stacks it has no access to any

918
00:37:02,579 --> 00:37:05,579
register save areas has no access to any

919
00:37:05,579 --> 00:37:09,320
other compartments globals or code

920
00:37:09,839 --> 00:37:11,880
um so a couple of times I I mentioned

921
00:37:11,880 --> 00:37:13,320
auditing

922
00:37:13,320 --> 00:37:15,300
when you link one of these firmware

923
00:37:15,300 --> 00:37:18,300
images you build those Import and Export

924
00:37:18,300 --> 00:37:22,619
tables and they describe everything

925
00:37:22,619 --> 00:37:24,900
where the loader has to set up pointers

926
00:37:24,900 --> 00:37:27,180
that point outside of a compartment's

927
00:37:27,180 --> 00:37:31,500
own code and globals region

928
00:37:31,500 --> 00:37:34,079
if the loader doesn't provide you with a

929
00:37:34,079 --> 00:37:37,980
pointer you can't access memory so

930
00:37:37,980 --> 00:37:41,760
everything in these tables describes the

931
00:37:41,760 --> 00:37:44,940
entire state of of any cross-compartment

932
00:37:44,940 --> 00:37:49,380
interaction and this is actually uh the

933
00:37:49,380 --> 00:37:51,900
output of of the Linker on one of our

934
00:37:51,900 --> 00:37:54,540
tiny examples uh

935
00:37:54,540 --> 00:37:56,640
fed through some python that someone on

936
00:37:56,640 --> 00:37:58,140
my team wrote to generate a pretty

937
00:37:58,140 --> 00:38:01,260
picture we don't expect that people

938
00:38:01,260 --> 00:38:03,000
would audit these by looking at the

939
00:38:03,000 --> 00:38:04,980
pictures because you know security

940
00:38:04,980 --> 00:38:07,440
through obscurity is then really easy by

941
00:38:07,440 --> 00:38:10,140
just making the font too small

942
00:38:10,140 --> 00:38:11,220
um

943
00:38:11,220 --> 00:38:14,400
but this is a just a visualization of of

944
00:38:14,400 --> 00:38:16,140
what you can actually see so we've got

945
00:38:16,140 --> 00:38:18,720
that this is I think example two if

946
00:38:18,720 --> 00:38:20,520
anyone wants to look in the the repo

947
00:38:20,520 --> 00:38:22,560
where we start with a Hello World and we

948
00:38:22,560 --> 00:38:24,540
try and split it into two compartments

949
00:38:24,540 --> 00:38:27,180
one that has access to the uart and one

950
00:38:27,180 --> 00:38:30,060
that calls that one so we can see that

951
00:38:30,060 --> 00:38:33,000
that the hello world compartment calls

952
00:38:33,000 --> 00:38:35,880
into the uart's write function

953
00:38:35,880 --> 00:38:37,380
um and we can see that that function

954
00:38:37,380 --> 00:38:39,359
will run with interrupts disabled so

955
00:38:39,359 --> 00:38:41,599
that we don't get interleaving of output

956
00:38:41,599 --> 00:38:44,220
and then we can see all the other places

957
00:38:44,220 --> 00:38:47,400
it calls and if you look at this black

958
00:38:47,400 --> 00:38:51,060
line here you can see that we had a bug

959
00:38:51,060 --> 00:38:53,940
in this example and we accidentally

960
00:38:53,940 --> 00:38:56,099
granted the uart compartment and the

961
00:38:56,099 --> 00:38:59,700
hello world compartment both access to

962
00:38:59,700 --> 00:39:03,060
the uart device which was kind of what

963
00:39:03,060 --> 00:39:04,920
this example was supposed to show you

964
00:39:04,920 --> 00:39:06,839
not doing

965
00:39:06,839 --> 00:39:09,119
um but we can audit it and we can

966
00:39:09,119 --> 00:39:11,220
statically write a policy that says

967
00:39:11,220 --> 00:39:14,040
things only the uart compartment must

968
00:39:14,040 --> 00:39:18,060
have access to the uart device and you

969
00:39:18,060 --> 00:39:19,920
can feed the Json output from the Linker

970
00:39:19,920 --> 00:39:22,020
into it and that policy engine can then

971
00:39:22,020 --> 00:39:26,160
say no sorry security goals not met try

972
00:39:26,160 --> 00:39:28,020
again

973
00:39:28,020 --> 00:39:29,339
so

974
00:39:29,339 --> 00:39:31,619
with this system we can give you

975
00:39:31,619 --> 00:39:33,599
fine-grained memory safety guarantees

976
00:39:33,599 --> 00:39:36,839
for existing CNC plus plus code bases

977
00:39:36,839 --> 00:39:39,020
we give you tools for lightweight

978
00:39:39,020 --> 00:39:41,220
compartmentalization for decomposing

979
00:39:41,220 --> 00:39:44,040
those things into multiple mutually

980
00:39:44,040 --> 00:39:47,760
distrusting isolated environments we

981
00:39:47,760 --> 00:39:50,700
give you safe cross-compartment sharing

982
00:39:50,700 --> 00:39:53,460
and we also give you a way of of

983
00:39:53,460 --> 00:39:55,859
building strong attestation signing

984
00:39:55,859 --> 00:39:58,619
policies over the structure of this

985
00:39:58,619 --> 00:40:02,280
thing so if you've got two vendors both

986
00:40:02,280 --> 00:40:04,140
needing to run things on the same device

987
00:40:04,140 --> 00:40:06,720
we give you a way of building an audit

988
00:40:06,720 --> 00:40:09,180
Trail for all of that

989
00:40:09,180 --> 00:40:11,160
um I'm going to be around for the rest

990
00:40:11,160 --> 00:40:12,960
of the day please come and ask me

991
00:40:12,960 --> 00:40:16,020
questions if you're not able to find me

992
00:40:16,020 --> 00:40:18,540
or you're someone watching us on the

993
00:40:18,540 --> 00:40:20,700
video feed and therefore not able to

994
00:40:20,700 --> 00:40:24,359
find me please add questions on the

995
00:40:24,359 --> 00:40:28,020
chariota chariotatos discussions page

996
00:40:28,020 --> 00:40:30,540
and I'll get to them hopefully over the

997
00:40:30,540 --> 00:40:32,390
weekend

998
00:40:32,390 --> 00:40:34,840
[Applause]

999
00:40:34,840 --> 00:40:41,539
[Music]

