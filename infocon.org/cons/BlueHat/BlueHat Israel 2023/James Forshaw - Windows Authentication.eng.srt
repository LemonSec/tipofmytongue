1
00:00:00,000 --> 00:00:08,700
[Music]

2
00:00:09,679 --> 00:00:11,440
thank you

3
00:00:11,440 --> 00:00:13,740
[Music]

4
00:00:13,740 --> 00:00:15,480
good evening blue hat it's good to be

5
00:00:15,480 --> 00:00:17,279
back in Israel for the first time in

6
00:00:17,279 --> 00:00:19,800
about four years I'm really excited to

7
00:00:19,800 --> 00:00:22,320
be asked back to speak about Windows

8
00:00:22,320 --> 00:00:24,240
authentication it seems at a Microsoft

9
00:00:24,240 --> 00:00:25,740
conference talking about Windows is

10
00:00:25,740 --> 00:00:28,199
quite a rarity so

11
00:00:28,199 --> 00:00:30,480
it's nice to nice to be in my wheelhouse

12
00:00:30,480 --> 00:00:31,980
again

13
00:00:31,980 --> 00:00:34,500
so for people who don't know who I am

14
00:00:34,500 --> 00:00:37,380
I'm James I work at Google in the

15
00:00:37,380 --> 00:00:38,880
project zero team

16
00:00:38,880 --> 00:00:41,760
and I specialize in Windows as the topic

17
00:00:41,760 --> 00:00:43,079
would probably suggest

18
00:00:43,079 --> 00:00:45,899
now I tend to look for logical security

19
00:00:45,899 --> 00:00:48,480
vulnerabilities but as we'll see in this

20
00:00:48,480 --> 00:00:51,180
presentation sometimes memory corruption

21
00:00:51,180 --> 00:00:53,039
just presents itself and I I can't

22
00:00:53,039 --> 00:00:57,000
resist I have to uh have to take them

23
00:00:57,000 --> 00:00:59,399
so a quick agenda so I wanted to do a

24
00:00:59,399 --> 00:01:01,620
talk about the research I've been doing

25
00:01:01,620 --> 00:01:04,739
in the windows authentication area

26
00:01:04,739 --> 00:01:07,020
but also to give you kind of an idea of

27
00:01:07,020 --> 00:01:09,540
of the types of things that would help

28
00:01:09,540 --> 00:01:11,520
you review it yourself if you wanted to

29
00:01:11,520 --> 00:01:15,659
do a similar research project

30
00:01:15,659 --> 00:01:17,600
so we're going to talk about my review

31
00:01:17,600 --> 00:01:20,040
methodologies some reverse engineering

32
00:01:20,040 --> 00:01:22,380
tricks and then of course we'll see some

33
00:01:22,380 --> 00:01:25,280
example vulnerabilities

34
00:01:25,439 --> 00:01:27,060
so I'm not expecting you to read this

35
00:01:27,060 --> 00:01:29,700
but it's just kind of a illustrative of

36
00:01:29,700 --> 00:01:31,080
the kind of thing you're likely to find

37
00:01:31,080 --> 00:01:34,500
in mscn if you search for Authentication

38
00:01:34,500 --> 00:01:36,840
um the key thing of Windows

39
00:01:36,840 --> 00:01:39,420
authentication the authentication stack

40
00:01:39,420 --> 00:01:41,460
is in the local security authority of

41
00:01:41,460 --> 00:01:43,740
the LSA this is kind of the sort of

42
00:01:43,740 --> 00:01:46,560
central Nexus of authentication on a

43
00:01:46,560 --> 00:01:49,619
Windows system you'll see it uh commonly

44
00:01:49,619 --> 00:01:52,560
it's running inside the lsas process

45
00:01:52,560 --> 00:01:56,700
subsystem process and it is pretty much

46
00:01:56,700 --> 00:01:59,280
key to all authentication on a Windows

47
00:01:59,280 --> 00:02:01,579
machine or at least sort of the Legacy

48
00:02:01,579 --> 00:02:03,720
Windows authentication this is the type

49
00:02:03,720 --> 00:02:07,200
of stuff which has been in since NT 3.1

50
00:02:07,200 --> 00:02:09,360
now of course in your web browser you

51
00:02:09,360 --> 00:02:10,560
might be using sort of oauth

52
00:02:10,560 --> 00:02:12,360
authentication or some other protocol

53
00:02:12,360 --> 00:02:14,940
that potentially won't touch the LSA at

54
00:02:14,940 --> 00:02:17,340
all but if you're speaking typical

55
00:02:17,340 --> 00:02:20,220
Windows authentication LSA is where to

56
00:02:20,220 --> 00:02:22,080
be

57
00:02:22,080 --> 00:02:26,099
now the LSA is not static so in NT 3.1

58
00:02:26,099 --> 00:02:28,260
ntlm was the primary Authentication

59
00:02:28,260 --> 00:02:30,959
Protocol that people used but over the

60
00:02:30,959 --> 00:02:33,900
years things like Kerberos was added in

61
00:02:33,900 --> 00:02:35,160
modern versions of Windows you have

62
00:02:35,160 --> 00:02:37,140
Cloud AP which is used to authenticate

63
00:02:37,140 --> 00:02:40,260
against say as your ad using sort of

64
00:02:40,260 --> 00:02:42,840
web-based authentication protocols

65
00:02:42,840 --> 00:02:44,760
so in order to support this sort of

66
00:02:44,760 --> 00:02:46,500
level of

67
00:02:46,500 --> 00:02:49,200
um uh customization you can actually

68
00:02:49,200 --> 00:02:51,360
write your own authentication packages

69
00:02:51,360 --> 00:02:53,819
which can be loaded into the LSA and

70
00:02:53,819 --> 00:02:55,800
provide new and novel authentication

71
00:02:55,800 --> 00:02:58,400
schemes

72
00:02:58,620 --> 00:03:00,180
now to interact with that from an

73
00:03:00,180 --> 00:03:02,580
application you use a set of apis called

74
00:03:02,580 --> 00:03:04,379
the security support provider interface

75
00:03:04,379 --> 00:03:06,000
or sspi

76
00:03:06,000 --> 00:03:07,620
and usually you would have your

77
00:03:07,620 --> 00:03:10,739
application and somewhere in privileged

78
00:03:10,739 --> 00:03:14,519
privileged context is the LSA and you

79
00:03:14,519 --> 00:03:17,400
want to talk to it so you first talk to

80
00:03:17,400 --> 00:03:19,140
a client dll

81
00:03:19,140 --> 00:03:21,420
which contains all the sort of user mode

82
00:03:21,420 --> 00:03:24,659
apis for this service that uses an RPC

83
00:03:24,659 --> 00:03:27,780
channel to a system service running

84
00:03:27,780 --> 00:03:30,659
inside the lsas process

85
00:03:30,659 --> 00:03:33,180
that's actually pretty much a shim all

86
00:03:33,180 --> 00:03:34,980
it does is it kind of forwards that onto

87
00:03:34,980 --> 00:03:37,140
the LSA process itself where most of the

88
00:03:37,140 --> 00:03:40,500
implementation is actually based

89
00:03:40,500 --> 00:03:43,860
now the support provider dll if you want

90
00:03:43,860 --> 00:03:46,500
to say speak ntlm it's got to load a

91
00:03:46,500 --> 00:03:49,319
specific dll for the ntlm Authentication

92
00:03:49,319 --> 00:03:50,400
Protocol

93
00:03:50,400 --> 00:03:52,379
and this is actually a shared dll the

94
00:03:52,379 --> 00:03:56,099
dll acts is loaded both into the LSA

95
00:03:56,099 --> 00:03:59,640
and provides a LSA specific API

96
00:03:59,640 --> 00:04:01,739
and it's loaded into the user mode

97
00:04:01,739 --> 00:04:03,599
process to provide a user mode API

98
00:04:03,599 --> 00:04:05,879
typically the user API is used for

99
00:04:05,879 --> 00:04:07,440
things like encryption like you can

100
00:04:07,440 --> 00:04:10,500
negotiate a a session key for your

101
00:04:10,500 --> 00:04:12,720
Authentication Protocol typically it

102
00:04:12,720 --> 00:04:14,099
will do the encryption in your

103
00:04:14,099 --> 00:04:16,199
application because otherwise you're

104
00:04:16,199 --> 00:04:18,540
going all the way around to the LSA over

105
00:04:18,540 --> 00:04:20,820
RPC and back maybe just to encrypt a

106
00:04:20,820 --> 00:04:22,500
single byte the performance would be

107
00:04:22,500 --> 00:04:23,639
pretty poor

108
00:04:23,639 --> 00:04:26,100
but I wanted to really focus on the LSA

109
00:04:26,100 --> 00:04:28,620
API itself because that's where all the

110
00:04:28,620 --> 00:04:31,580
privileged cool stuff is

111
00:04:32,280 --> 00:04:34,919
so over two types of apis that you can

112
00:04:34,919 --> 00:04:37,680
call depend very much on the type of

113
00:04:37,680 --> 00:04:39,540
operation you're trying to achieve if

114
00:04:39,540 --> 00:04:41,160
it's like local or interactive

115
00:04:41,160 --> 00:04:43,139
authentication like you're typing into a

116
00:04:43,139 --> 00:04:46,020
into your desktop that's using the LSA

117
00:04:46,020 --> 00:04:49,639
logon user API

118
00:04:49,860 --> 00:04:51,120
if you're trying to do Network

119
00:04:51,120 --> 00:04:52,800
authentication for example you're trying

120
00:04:52,800 --> 00:04:54,660
to connect to an SMB server on a remote

121
00:04:54,660 --> 00:04:56,520
system you're going to do some sort of

122
00:04:56,520 --> 00:04:58,680
network authentication and this in this

123
00:04:58,680 --> 00:05:00,720
case there's actually multiple apis

124
00:05:00,720 --> 00:05:02,220
you've got to call it's like a

125
00:05:02,220 --> 00:05:03,900
state-based model we'll have a quick

126
00:05:03,900 --> 00:05:06,479
look of the sort of basics of that in a

127
00:05:06,479 --> 00:05:07,800
second

128
00:05:07,800 --> 00:05:10,320
then the other main one I'm highlighting

129
00:05:10,320 --> 00:05:12,419
is there's kind of like an escape hatch

130
00:05:12,419 --> 00:05:15,780
for any other functionality that that

131
00:05:15,780 --> 00:05:18,840
authentication dll wants to provide so

132
00:05:18,840 --> 00:05:20,520
there is this call authentication

133
00:05:20,520 --> 00:05:22,800
package API which basically it's like an

134
00:05:22,800 --> 00:05:24,600
eye octal in that sense like you can

135
00:05:24,600 --> 00:05:27,000
just pass it like a blob and it's up to

136
00:05:27,000 --> 00:05:28,560
the package to determine whether it's

137
00:05:28,560 --> 00:05:32,120
interested or not with that but

138
00:05:32,220 --> 00:05:34,560
so in terms of local authentication you

139
00:05:34,560 --> 00:05:36,300
have your application you have the LSA

140
00:05:36,300 --> 00:05:38,460
you have your provided dll and at some

141
00:05:38,460 --> 00:05:40,500
somewhere is your authentication Service

142
00:05:40,500 --> 00:05:43,139
now this could be locally this could be

143
00:05:43,139 --> 00:05:45,300
the Sam on your local machine it could

144
00:05:45,300 --> 00:05:47,940
be a Kerberos KDC it could be as your

145
00:05:47,940 --> 00:05:49,380
authentication endpoint it doesn't

146
00:05:49,380 --> 00:05:52,199
really matter but you call LSA logon

147
00:05:52,199 --> 00:05:55,199
user and it will talk to the provider

148
00:05:55,199 --> 00:05:57,419
and make that authentication process

149
00:05:57,419 --> 00:05:59,639
happen it will speak speak the correct

150
00:05:59,639 --> 00:06:01,620
protocol to the authentication Service

151
00:06:01,620 --> 00:06:04,080
say hey do these credentials match

152
00:06:04,080 --> 00:06:05,759
something in your database

153
00:06:05,759 --> 00:06:08,280
if that's the case it will say yes and

154
00:06:08,280 --> 00:06:09,720
the LSA can then create something called

155
00:06:09,720 --> 00:06:12,120
access token and this is used for

156
00:06:12,120 --> 00:06:14,460
identifying you on the local system so

157
00:06:14,460 --> 00:06:16,500
it can be used for process creation and

158
00:06:16,500 --> 00:06:19,440
it can be used for impersonation

159
00:06:19,440 --> 00:06:21,539
never called authentication is subtly

160
00:06:21,539 --> 00:06:22,979
different in this case you basically

161
00:06:22,979 --> 00:06:24,720
have the same stack but on two different

162
00:06:24,720 --> 00:06:27,720
systems you have a client system and you

163
00:06:27,720 --> 00:06:29,460
have your server system

164
00:06:29,460 --> 00:06:31,199
so the application again talks to the

165
00:06:31,199 --> 00:06:33,319
provider dll

166
00:06:33,319 --> 00:06:36,600
it then gets back from LSA some sort of

167
00:06:36,600 --> 00:06:39,060
opaque blob which just says this is a

168
00:06:39,060 --> 00:06:41,220
token for authentication and the purpose

169
00:06:41,220 --> 00:06:42,780
here is you pass that across your

170
00:06:42,780 --> 00:06:46,080
bespoke protocol say S and B to the

171
00:06:46,080 --> 00:06:48,660
server application which then passes

172
00:06:48,660 --> 00:06:50,819
that up to its own copy of

173
00:06:50,819 --> 00:06:53,880
ntlm or Kerberos running in the LSA and

174
00:06:53,880 --> 00:06:55,860
effectively you keep doing this until

175
00:06:55,860 --> 00:06:58,440
some sort of authentication is achieved

176
00:06:58,440 --> 00:07:01,800
between those two systems

177
00:07:01,800 --> 00:07:04,620
and again this time on the server the

178
00:07:04,620 --> 00:07:06,780
server can access for an access token

179
00:07:06,780 --> 00:07:08,400
this can be used for authentication

180
00:07:08,400 --> 00:07:10,680
purposes a verification that you have

181
00:07:10,680 --> 00:07:14,039
access to say certain files or creating

182
00:07:14,039 --> 00:07:15,419
new processes pretending on the

183
00:07:15,419 --> 00:07:17,819
depending on the protocol

184
00:07:17,819 --> 00:07:19,860
and then finally call LSA provide is

185
00:07:19,860 --> 00:07:20,880
pretty simple

186
00:07:20,880 --> 00:07:22,580
it's basically you pass it a structure

187
00:07:22,580 --> 00:07:25,020
you tell it I want to send it to the

188
00:07:25,020 --> 00:07:27,419
ntlm provider or the Kerberos provider

189
00:07:27,419 --> 00:07:29,099
and then it's the provider's dll which

190
00:07:29,099 --> 00:07:31,620
will just go okay I'm going to say

191
00:07:31,620 --> 00:07:34,500
operation zero is called implements this

192
00:07:34,500 --> 00:07:36,360
function operation n implements this

193
00:07:36,360 --> 00:07:38,759
function so as I say pretty much like a

194
00:07:38,759 --> 00:07:40,740
generic escape hatch for any other

195
00:07:40,740 --> 00:07:42,840
functionality you care to care to think

196
00:07:42,840 --> 00:07:45,020
about

197
00:07:45,240 --> 00:07:48,500
so let's go into the review methodology

198
00:07:48,500 --> 00:07:51,960
bug class wise I thought hey I better go

199
00:07:51,960 --> 00:07:54,479
all in and try and find everything right

200
00:07:54,479 --> 00:07:55,080
um

201
00:07:55,080 --> 00:07:57,360
no pointer

202
00:07:57,360 --> 00:07:59,099
not going for at least our object code

203
00:07:59,099 --> 00:08:00,599
execution like if you've got an

204
00:08:00,599 --> 00:08:02,160
authentication system where you can get

205
00:08:02,160 --> 00:08:03,960
object code execution it's probably

206
00:08:03,960 --> 00:08:06,360
probably not good

207
00:08:06,360 --> 00:08:07,979
um and of course you've got

208
00:08:07,979 --> 00:08:09,599
authentication bypass authorization

209
00:08:09,599 --> 00:08:12,300
bypass which are pretty pretty damning

210
00:08:12,300 --> 00:08:14,580
for any sort of authentication system

211
00:08:14,580 --> 00:08:17,039
and information disclosure of course if

212
00:08:17,039 --> 00:08:18,300
you're trying to log on to a system

213
00:08:18,300 --> 00:08:21,379
there's probably

214
00:08:22,560 --> 00:08:24,240
excuse me

215
00:08:24,240 --> 00:08:27,660
um there's probably uh like passwords

216
00:08:27,660 --> 00:08:29,400
Keys all that sort of stuff if you can

217
00:08:29,400 --> 00:08:31,919
leak that out from say else ass or from

218
00:08:31,919 --> 00:08:34,679
the authentication scheme well you might

219
00:08:34,679 --> 00:08:37,440
be able to compromise like basically

220
00:08:37,440 --> 00:08:39,419
bypass authentication or just leak

221
00:08:39,419 --> 00:08:42,079
interesting information

222
00:08:42,299 --> 00:08:44,339
so as I wanted to focus very much on the

223
00:08:44,339 --> 00:08:46,020
LSA side of things I thought okay well

224
00:08:46,020 --> 00:08:47,519
I'll just look at the security packages

225
00:08:47,519 --> 00:08:50,820
right like each of those packages are

226
00:08:50,820 --> 00:08:53,399
bespoke code like generally written by

227
00:08:53,399 --> 00:08:55,740
Microsoft you can get third-party ones

228
00:08:55,740 --> 00:08:58,800
but it's much more rare to see this

229
00:08:58,800 --> 00:09:01,019
and windows gives you a nice function

230
00:09:01,019 --> 00:09:03,180
the enumerate security packages so

231
00:09:03,180 --> 00:09:04,440
that's pretty much all you should need

232
00:09:04,440 --> 00:09:06,959
to find what current packages are

233
00:09:06,959 --> 00:09:09,000
installed on your local system or

234
00:09:09,000 --> 00:09:10,440
provider sorry

235
00:09:10,440 --> 00:09:12,300
the documentation is unclear whether its

236
00:09:12,300 --> 00:09:14,459
packages or providers it depends on the

237
00:09:14,459 --> 00:09:17,399
depends on the day of the week I think

238
00:09:17,399 --> 00:09:20,040
um so this returns this structure now it

239
00:09:20,040 --> 00:09:22,200
has things like some Flags so packages

240
00:09:22,200 --> 00:09:25,740
can say I actually support interactive

241
00:09:25,740 --> 00:09:27,660
local authentication but I do not

242
00:09:27,660 --> 00:09:29,339
support network authentication so Cloud

243
00:09:29,339 --> 00:09:31,800
IP for example is only a local

244
00:09:31,800 --> 00:09:34,860
authentication provider whereas ntlm can

245
00:09:34,860 --> 00:09:38,100
be both local authentication and network

246
00:09:38,100 --> 00:09:39,959
authentication so the flags will will

247
00:09:39,959 --> 00:09:42,000
give that sort of idea of what it can be

248
00:09:42,000 --> 00:09:43,560
used for

249
00:09:43,560 --> 00:09:46,200
the other main piece of information is

250
00:09:46,200 --> 00:09:48,360
there is the name when you actually try

251
00:09:48,360 --> 00:09:49,980
and use this package with one of the

252
00:09:49,980 --> 00:09:52,620
apis you have to give this name so ntlm

253
00:09:52,620 --> 00:09:56,459
is ntlm Kerberos is Kerberos Etc and

254
00:09:56,459 --> 00:09:58,260
this is kind of like the key to

255
00:09:58,260 --> 00:10:00,720
unlocking the particular package for the

256
00:10:00,720 --> 00:10:02,839
LSA

257
00:10:02,839 --> 00:10:06,480
but the key thing here that structure

258
00:10:06,480 --> 00:10:08,399
does not have any dll information so

259
00:10:08,399 --> 00:10:10,500
where is the dll

260
00:10:10,500 --> 00:10:11,339
um

261
00:10:11,339 --> 00:10:13,920
so the reason I'm using my own laptop is

262
00:10:13,920 --> 00:10:16,500
I'm crazy enough to actually try and do

263
00:10:16,500 --> 00:10:18,720
demos

264
00:10:18,720 --> 00:10:20,779
um

265
00:10:23,880 --> 00:10:26,220
trust me it's not that exciting

266
00:10:26,220 --> 00:10:26,820
um

267
00:10:26,820 --> 00:10:29,820
so it turns out that the dll is provided

268
00:10:29,820 --> 00:10:31,920
but they just don't expose it using the

269
00:10:31,920 --> 00:10:33,540
standard apis you've got to call the

270
00:10:33,540 --> 00:10:36,779
internal apis so in this particular case

271
00:10:36,779 --> 00:10:38,880
I can just pull out the RPC interface

272
00:10:38,880 --> 00:10:42,839
for the sspi service

273
00:10:42,839 --> 00:10:45,300
um attached to it and then I can call

274
00:10:45,300 --> 00:10:46,320
this

275
00:10:46,320 --> 00:10:48,959
uh call RPC which is again one of these

276
00:10:48,959 --> 00:10:51,360
just do something which we couldn't be

277
00:10:51,360 --> 00:10:53,880
bothered to have a specific function for

278
00:10:53,880 --> 00:10:55,140
thanks

279
00:10:55,140 --> 00:10:56,519
um passing this buffer which basically

280
00:10:56,519 --> 00:10:58,620
says I want to use the function LSA get

281
00:10:58,620 --> 00:11:02,160
binding and then hopefully if this

282
00:11:02,160 --> 00:11:04,860
if the demo gods are with me

283
00:11:04,860 --> 00:11:05,880
um

284
00:11:05,880 --> 00:11:08,640
this now gives you the list of packages

285
00:11:08,640 --> 00:11:10,260
the name on the side is the one you

286
00:11:10,260 --> 00:11:12,420
would use and the dlls you can now go

287
00:11:12,420 --> 00:11:14,700
and take the dll and go cool I can now

288
00:11:14,700 --> 00:11:16,920
reverse engineer it and find all the

289
00:11:16,920 --> 00:11:20,420
bugs that I could possibly find

290
00:11:20,579 --> 00:11:22,920
okay so you've got this dll and it gets

291
00:11:22,920 --> 00:11:25,140
loaded into the LSA process

292
00:11:25,140 --> 00:11:27,540
now I want to reverse engineer it so how

293
00:11:27,540 --> 00:11:30,000
do I go about understanding what this

294
00:11:30,000 --> 00:11:31,440
thing does

295
00:11:31,440 --> 00:11:34,380
well first let's let's discuss how that

296
00:11:34,380 --> 00:11:37,019
dll is initialized in the LSA

297
00:11:37,019 --> 00:11:40,380
every package should expose a specific

298
00:11:40,380 --> 00:11:43,380
this SP LSA mode initialize function as

299
00:11:43,380 --> 00:11:46,320
a dll export and this exported function

300
00:11:46,320 --> 00:11:48,839
is going to be called afterload library

301
00:11:48,839 --> 00:11:52,800
is called on that dll by the LSA

302
00:11:52,800 --> 00:11:54,720
um but the interesting thing here is

303
00:11:54,720 --> 00:11:57,839
that one of the return values of this is

304
00:11:57,839 --> 00:12:00,240
a list of security functions that the

305
00:12:00,240 --> 00:12:03,120
package provided so this is all things

306
00:12:03,120 --> 00:12:06,720
like the logon user function and the

307
00:12:06,720 --> 00:12:08,459
network authentication functions and

308
00:12:08,459 --> 00:12:11,160
this must be passed back to the LSA so

309
00:12:11,160 --> 00:12:13,800
that it can when it gets to the specific

310
00:12:13,800 --> 00:12:16,500
call on its RPC Channel it can hand it

311
00:12:16,500 --> 00:12:18,480
off to the correct part of your provider

312
00:12:18,480 --> 00:12:19,500
dll

313
00:12:19,500 --> 00:12:21,540
so this is really really simple way of

314
00:12:21,540 --> 00:12:23,339
going okay these are all the exposed

315
00:12:23,339 --> 00:12:25,019
functions so that I can because they

316
00:12:25,019 --> 00:12:27,000
won't be exported as just standard dll

317
00:12:27,000 --> 00:12:29,300
exports

318
00:12:29,300 --> 00:12:31,440
now of course when it comes to reverse

319
00:12:31,440 --> 00:12:32,760
engineering there's loads of complexity

320
00:12:32,760 --> 00:12:34,440
here because this is a system which has

321
00:12:34,440 --> 00:12:37,140
been built up over 20 plus years so

322
00:12:37,140 --> 00:12:39,120
there's four versions of the logon user

323
00:12:39,120 --> 00:12:40,320
function

324
00:12:40,320 --> 00:12:42,300
um in typical Microsoft style it goes

325
00:12:42,300 --> 00:12:45,240
from ex to ex2 and EX3 I'm surprised

326
00:12:45,240 --> 00:12:47,519
there's not any XEX but

327
00:12:47,519 --> 00:12:49,860
you live in hope one day

328
00:12:49,860 --> 00:12:51,600
um and LSA will basically just call the

329
00:12:51,600 --> 00:12:54,180
highest supportive one it can see and in

330
00:12:54,180 --> 00:12:55,920
general you'll find that say an

331
00:12:55,920 --> 00:12:58,680
implementation May support ex and ex2

332
00:12:58,680 --> 00:13:01,320
but ex is just a wrapper around calling

333
00:13:01,320 --> 00:13:03,779
the ex2 implementation so in general

334
00:13:03,779 --> 00:13:05,459
there's only sort of a single entry

335
00:13:05,459 --> 00:13:08,639
point and LSA logon user is kind of like

336
00:13:08,639 --> 00:13:10,440
a One-Shot thing you just call it with

337
00:13:10,440 --> 00:13:12,600
some credentials and it will return You

338
00:13:12,600 --> 00:13:13,500
Back

339
00:13:13,500 --> 00:13:17,399
success or failure and an access token

340
00:13:17,399 --> 00:13:19,320
Network authentication on the other hand

341
00:13:19,320 --> 00:13:22,440
is much more of a state model so you

342
00:13:22,440 --> 00:13:24,600
need to when you actually program it you

343
00:13:24,600 --> 00:13:26,220
need to call this acquire credentials

344
00:13:26,220 --> 00:13:27,480
handle function

345
00:13:27,480 --> 00:13:31,200
and this allows the provider to uh

346
00:13:31,200 --> 00:13:33,660
say look up your current user's

347
00:13:33,660 --> 00:13:35,760
credentials which are currently stored

348
00:13:35,760 --> 00:13:38,180
in the LSA and

349
00:13:38,180 --> 00:13:40,320
allocate some sort of structure which

350
00:13:40,320 --> 00:13:42,060
can be used as a context

351
00:13:42,060 --> 00:13:44,399
that structure then needs to be passed

352
00:13:44,399 --> 00:13:47,519
to a secondary function either in it

353
00:13:47,519 --> 00:13:50,700
um LSA mode context or accept LSA mode

354
00:13:50,700 --> 00:13:53,820
context and one of the like in it is for

355
00:13:53,820 --> 00:13:56,760
clients and acceptors for servers

356
00:13:56,760 --> 00:13:58,680
um and so you've got of course the

357
00:13:58,680 --> 00:14:00,839
problem that you need to it's not just a

358
00:14:00,839 --> 00:14:02,820
case of reverse engineering a single

359
00:14:02,820 --> 00:14:04,380
function you potentially have to reverse

360
00:14:04,380 --> 00:14:07,019
engineer the structure of the context

361
00:14:07,019 --> 00:14:09,120
being passed around and like a flag

362
00:14:09,120 --> 00:14:10,920
could be being checked in one function

363
00:14:10,920 --> 00:14:12,660
which was actually set in a completely

364
00:14:12,660 --> 00:14:15,360
unrelated function and so there's a lot

365
00:14:15,360 --> 00:14:17,160
of sort of inter intertwining you've got

366
00:14:17,160 --> 00:14:18,959
to deal with there's also things like

367
00:14:18,959 --> 00:14:21,000
attributes you can set which again are

368
00:14:21,000 --> 00:14:22,800
kind of like a catch-all

369
00:14:22,800 --> 00:14:25,079
just allow me to set like a specific

370
00:14:25,079 --> 00:14:28,200
operation on this on this context so

371
00:14:28,200 --> 00:14:29,700
again it's something you have to have to

372
00:14:29,700 --> 00:14:32,160
deal with when reverse engineering

373
00:14:32,160 --> 00:14:34,320
and then just to be contrarian the core

374
00:14:34,320 --> 00:14:37,620
provider entry points there's freedom

375
00:14:37,620 --> 00:14:39,000
but again it's a completely different

376
00:14:39,000 --> 00:14:40,860
reason for having multiple entry points

377
00:14:40,860 --> 00:14:44,339
the first one is only for will be used

378
00:14:44,339 --> 00:14:46,740
if a caller has TCB privilege which is

379
00:14:46,740 --> 00:14:50,040
basically local system and no one else

380
00:14:50,040 --> 00:14:53,279
um so of course authentication is a very

381
00:14:53,279 --> 00:14:56,220
very important and potentially dangerous

382
00:14:56,220 --> 00:14:59,040
operation to perform so some things are

383
00:14:59,040 --> 00:15:00,720
gated by whether you're a trusted

384
00:15:00,720 --> 00:15:02,279
application or not

385
00:15:02,279 --> 00:15:04,620
and so if you're trusted and have TCP

386
00:15:04,620 --> 00:15:07,560
privilege you get core package if you're

387
00:15:07,560 --> 00:15:10,079
untrusted which potentially means you're

388
00:15:10,079 --> 00:15:11,880
still an administrator you just don't

389
00:15:11,880 --> 00:15:14,279
happen to have TCB privilege it will

390
00:15:14,279 --> 00:15:16,440
call the untrusted variant now what

391
00:15:16,440 --> 00:15:18,720
would typically happen is the untrusted

392
00:15:18,720 --> 00:15:21,480
variant would filter out maybe really

393
00:15:21,480 --> 00:15:23,639
dangerous operations that it supports

394
00:15:23,639 --> 00:15:26,399
and then just generally hand it back off

395
00:15:26,399 --> 00:15:28,320
to to core package

396
00:15:28,320 --> 00:15:31,199
the final one is probably something you

397
00:15:31,199 --> 00:15:33,240
won't need to worry about too much this

398
00:15:33,240 --> 00:15:35,639
is basically just used if one one

399
00:15:35,639 --> 00:15:38,339
package dll provided dll in the LSA

400
00:15:38,339 --> 00:15:41,339
process wants to directly call into

401
00:15:41,339 --> 00:15:44,579
another provider dll and so this

402
00:15:44,579 --> 00:15:46,620
potentially allows it to do really crazy

403
00:15:46,620 --> 00:15:48,360
things like passing function pointers

404
00:15:48,360 --> 00:15:50,339
and all manner of crazy stuff but in

405
00:15:50,339 --> 00:15:51,779
general you shouldn't be able to see

406
00:15:51,779 --> 00:15:55,199
that from the user mode context if

407
00:15:55,199 --> 00:15:57,000
you're trying to sort of attack it that

408
00:15:57,000 --> 00:15:58,800
way

409
00:15:58,800 --> 00:16:00,480
now when you actually look at the code

410
00:16:00,480 --> 00:16:03,660
itself you'll see loads of patterns like

411
00:16:03,660 --> 00:16:05,699
this it'll read some sort of global

412
00:16:05,699 --> 00:16:07,620
variable typically called like LSA

413
00:16:07,620 --> 00:16:09,720
functions and then it will read a value

414
00:16:09,720 --> 00:16:12,180
from that pointer and then dispatch it

415
00:16:12,180 --> 00:16:14,220
as an indirect function call so where is

416
00:16:14,220 --> 00:16:16,019
LSA functions coming from because this

417
00:16:16,019 --> 00:16:17,579
really is like what the heck is this

418
00:16:17,579 --> 00:16:19,320
doing at this point

419
00:16:19,320 --> 00:16:21,420
um this comes down to a second

420
00:16:21,420 --> 00:16:23,459
initialization function one is clearly

421
00:16:23,459 --> 00:16:25,860
not enough you need to have two

422
00:16:25,860 --> 00:16:26,579
um

423
00:16:26,579 --> 00:16:29,220
in the security functions returned

424
00:16:29,220 --> 00:16:32,880
during the initial initialization

425
00:16:32,880 --> 00:16:34,860
um there is this SP initialize function

426
00:16:34,860 --> 00:16:38,279
and this takes as an inbound parameter a

427
00:16:38,279 --> 00:16:40,620
list of functions that the LSA provides

428
00:16:40,620 --> 00:16:43,139
for the footer provider to use so for

429
00:16:43,139 --> 00:16:46,320
example like it has one to create a new

430
00:16:46,320 --> 00:16:48,120
log on session or add or remove

431
00:16:48,120 --> 00:16:50,160
credentials

432
00:16:50,160 --> 00:16:52,079
and that would then just that points

433
00:16:52,079 --> 00:16:53,339
will generally just be stored in the

434
00:16:53,339 --> 00:16:55,920
global variable and then used uh

435
00:16:55,920 --> 00:16:58,620
later on and this these structures are

436
00:16:58,620 --> 00:17:01,320
documented in in Windows headers so you

437
00:17:01,320 --> 00:17:03,899
can just take them into say either or

438
00:17:03,899 --> 00:17:06,179
gidra and just apply that to that

439
00:17:06,179 --> 00:17:07,980
pointer and then you get it to decode

440
00:17:07,980 --> 00:17:10,939
your operations

441
00:17:11,099 --> 00:17:12,299
um but just to highlight a few

442
00:17:12,299 --> 00:17:13,980
interesting operations that you want to

443
00:17:13,980 --> 00:17:16,319
look out for the first one is get client

444
00:17:16,319 --> 00:17:19,199
info this function basically says give

445
00:17:19,199 --> 00:17:20,520
me the information the security

446
00:17:20,520 --> 00:17:23,280
information for the caller of the RPC

447
00:17:23,280 --> 00:17:24,419
Channel

448
00:17:24,419 --> 00:17:27,140
and this is used for example to gate

449
00:17:27,140 --> 00:17:30,179
dangerous functionality common one is to

450
00:17:30,179 --> 00:17:31,220
say

451
00:17:31,220 --> 00:17:34,559
checking this has TCB privilege function

452
00:17:34,559 --> 00:17:36,960
um Boolean like it will go okay this

453
00:17:36,960 --> 00:17:39,240
operation is is generally safe except

454
00:17:39,240 --> 00:17:41,280
for this very specific one at which

455
00:17:41,280 --> 00:17:43,200
point I just need to make sure that the

456
00:17:43,200 --> 00:17:45,660
caller has TCB privilege

457
00:17:45,660 --> 00:17:46,919
um and a few other things they can do

458
00:17:46,919 --> 00:17:49,320
access checks on on the client token it

459
00:17:49,320 --> 00:17:51,419
also has process ID and thread ID so you

460
00:17:51,419 --> 00:17:53,640
can directly talk to the the process

461
00:17:53,640 --> 00:17:54,900
itself

462
00:17:54,900 --> 00:17:56,520
which is actually kind of important

463
00:17:56,520 --> 00:17:58,559
because the way in which a lot of the

464
00:17:58,559 --> 00:18:00,960
RPC calls are structured uh it doesn't

465
00:18:00,960 --> 00:18:04,740
know necessarily the RPC marshalling

466
00:18:04,740 --> 00:18:06,179
doesn't know

467
00:18:06,179 --> 00:18:08,520
whether the

468
00:18:08,520 --> 00:18:09,360
um

469
00:18:09,360 --> 00:18:10,919
the structure of these buffers it's

470
00:18:10,919 --> 00:18:12,780
trying to pass across

471
00:18:12,780 --> 00:18:14,880
so instead of doing that what actually

472
00:18:14,880 --> 00:18:16,679
happens is usually it passes some sort

473
00:18:16,679 --> 00:18:17,820
of pointer

474
00:18:17,820 --> 00:18:21,360
in the client process and then the LSA

475
00:18:21,360 --> 00:18:24,600
process asks to read memory from that

476
00:18:24,600 --> 00:18:27,179
client process into a buffer into the

477
00:18:27,179 --> 00:18:29,400
LSA and vice versa if you want to copy

478
00:18:29,400 --> 00:18:32,520
it back out so the first two are used

479
00:18:32,520 --> 00:18:34,440
mainly for logon user and core package

480
00:18:34,440 --> 00:18:36,539
where you just get sort of raw pointers

481
00:18:36,539 --> 00:18:38,400
and map buffer is used for Network

482
00:18:38,400 --> 00:18:39,900
authentication where they use these

483
00:18:39,900 --> 00:18:41,580
specialized security buffer structures

484
00:18:41,580 --> 00:18:43,620
which have a type and and the size and

485
00:18:43,620 --> 00:18:45,240
data

486
00:18:45,240 --> 00:18:47,640
um so you need to of course see that

487
00:18:47,640 --> 00:18:49,140
where it's actually pulling data in

488
00:18:49,140 --> 00:18:50,880
because of course there could potential

489
00:18:50,880 --> 00:18:52,860
there's there is potential things like

490
00:18:52,860 --> 00:18:55,520
timer check time use issues due to

491
00:18:55,520 --> 00:18:59,480
incorrect calling of these apis

492
00:18:59,520 --> 00:19:02,640
and the final thing to note is of course

493
00:19:02,640 --> 00:19:05,039
I'm sure someone here has probably tried

494
00:19:05,039 --> 00:19:07,020
this just attaching say windy bug to

495
00:19:07,020 --> 00:19:10,200
lsas run it as admin test to Wendy LSS

496
00:19:10,200 --> 00:19:13,620
be fine right uh well more than likely

497
00:19:13,620 --> 00:19:16,799
your machine will just hang because so

498
00:19:16,799 --> 00:19:19,559
much of of the OS is dependent on LSUS

499
00:19:19,559 --> 00:19:20,400
running

500
00:19:20,400 --> 00:19:22,140
including probably some parts of

501
00:19:22,140 --> 00:19:25,440
windybug so if you do that you'll likely

502
00:19:25,440 --> 00:19:26,820
have a bad time

503
00:19:26,820 --> 00:19:29,940
so the best way I found to debug it is

504
00:19:29,940 --> 00:19:31,799
to just use a kernel debugger because

505
00:19:31,799 --> 00:19:34,140
then you can obviously you run it in a

506
00:19:34,140 --> 00:19:36,660
VM run account debugger and you can add

507
00:19:36,660 --> 00:19:38,940
break points to lsas and debug it to

508
00:19:38,940 --> 00:19:40,620
your heart's content

509
00:19:40,620 --> 00:19:44,760
okay so results of the research

510
00:19:44,760 --> 00:19:46,679
so this was over sort of an 18-month

511
00:19:46,679 --> 00:19:49,440
process

512
00:19:49,440 --> 00:19:52,200
I found one or two

513
00:19:52,200 --> 00:19:53,880
um

514
00:19:53,880 --> 00:19:56,220
and yes it's kind of surprising when you

515
00:19:56,220 --> 00:19:58,140
like when I say object code execution

516
00:19:58,140 --> 00:19:59,700
that doesn't necessarily mean remote

517
00:19:59,700 --> 00:20:01,500
code execution although in some cases it

518
00:20:01,500 --> 00:20:03,480
does and that could also be just like

519
00:20:03,480 --> 00:20:05,340
memory corruption and giving me

520
00:20:05,340 --> 00:20:06,900
privilege escalation but yeah

521
00:20:06,900 --> 00:20:08,340
authentication bypass authorization

522
00:20:08,340 --> 00:20:11,280
bypass and info disclosure

523
00:20:11,280 --> 00:20:13,200
never great

524
00:20:13,200 --> 00:20:16,140
um anyway so let's look at some some of

525
00:20:16,140 --> 00:20:18,120
the more interesting bugs or or

526
00:20:18,120 --> 00:20:20,280
potentially impactful bugs

527
00:20:20,280 --> 00:20:24,720
um so the first one is bypassing

528
00:20:24,720 --> 00:20:28,140
um app container uh authentication

529
00:20:28,140 --> 00:20:30,539
requirements so an app container is a

530
00:20:30,539 --> 00:20:32,160
Sandbox which was introduced in Windows

531
00:20:32,160 --> 00:20:33,900
8 and

532
00:20:33,900 --> 00:20:36,419
in order to prevent you from potentially

533
00:20:36,419 --> 00:20:39,059
escaping that sandbox by just using the

534
00:20:39,059 --> 00:20:42,299
user's authentication to talk to say a

535
00:20:42,299 --> 00:20:44,660
remote s b server or something like that

536
00:20:44,660 --> 00:20:46,860
Microsoft made it so about the only way

537
00:20:46,860 --> 00:20:49,679
to use the default credentials of that

538
00:20:49,679 --> 00:20:52,220
user is if you have a special Enterprise

539
00:20:52,220 --> 00:20:54,780
authentication capability in app

540
00:20:54,780 --> 00:20:57,299
container and the capabilities like just

541
00:20:57,299 --> 00:20:59,280
grants you access to certain resources

542
00:20:59,280 --> 00:21:01,200
so in this case you could have ones

543
00:21:01,200 --> 00:21:03,000
which say give me access to reading

544
00:21:03,000 --> 00:21:04,919
password registry and in this case it

545
00:21:04,919 --> 00:21:07,980
says allow me access to the

546
00:21:07,980 --> 00:21:10,020
authentication of the default

547
00:21:10,020 --> 00:21:13,200
authentication now in most cases you

548
00:21:13,200 --> 00:21:15,179
will not see any app container processes

549
00:21:15,179 --> 00:21:17,220
with this capability and there's a good

550
00:21:17,220 --> 00:21:19,320
reason for that like it's probably a bad

551
00:21:19,320 --> 00:21:22,080
idea to Grant this right

552
00:21:22,080 --> 00:21:24,960
um and it is considered to be well what

553
00:21:24,960 --> 00:21:26,460
Microsoft considered to be a restricted

554
00:21:26,460 --> 00:21:29,340
capability so it's fine if you're doing

555
00:21:29,340 --> 00:21:31,620
side loading and using Enterprise line

556
00:21:31,620 --> 00:21:33,600
of business applications that you need

557
00:21:33,600 --> 00:21:37,260
this network authentication to work

558
00:21:37,260 --> 00:21:40,640
but it's entirely different if you're

559
00:21:40,640 --> 00:21:44,039
adding like a a simple game on on the

560
00:21:44,039 --> 00:21:46,440
Microsoft store running a nap container

561
00:21:46,440 --> 00:21:48,240
it probably doesn't need access to your

562
00:21:48,240 --> 00:21:49,980
network authentication so in that case

563
00:21:49,980 --> 00:21:52,140
if you tried to submit a store

564
00:21:52,140 --> 00:21:53,820
application sandbox store application

565
00:21:53,820 --> 00:21:56,400
with this capability almost certainly

566
00:21:56,400 --> 00:21:58,200
Microsoft should reject it I've not

567
00:21:58,200 --> 00:21:59,419
tried that

568
00:21:59,419 --> 00:22:02,220
you never know maybe uh someone will

569
00:22:02,220 --> 00:22:04,080
miss it but pretty much I'm pretty sure

570
00:22:04,080 --> 00:22:06,419
this is so easy to automate that pretty

571
00:22:06,419 --> 00:22:07,919
much any application for this will be

572
00:22:07,919 --> 00:22:10,500
rejected so of course if say you want to

573
00:22:10,500 --> 00:22:12,720
use Kerberos to do authentication well

574
00:22:12,720 --> 00:22:14,700
if you get stuck in an app container

575
00:22:14,700 --> 00:22:18,299
sandbox you can about a look right

576
00:22:18,299 --> 00:22:20,280
um but when I was doing the research I

577
00:22:20,280 --> 00:22:23,220
noticed that while things like LSA logon

578
00:22:23,220 --> 00:22:25,919
user and the network authentication apis

579
00:22:25,919 --> 00:22:28,260
were checking whether the caller was an

580
00:22:28,260 --> 00:22:29,640
app container or not

581
00:22:29,640 --> 00:22:34,380
the cool LSA provider API did not check

582
00:22:34,380 --> 00:22:35,760
whether you're an app container or not

583
00:22:35,760 --> 00:22:38,340
so it's like oh interesting maybe it's

584
00:22:38,340 --> 00:22:40,200
obviously server down but perhaps

585
00:22:40,200 --> 00:22:41,460
there's a

586
00:22:41,460 --> 00:22:43,799
interesting API we can call which allows

587
00:22:43,799 --> 00:22:45,539
us to get access to network

588
00:22:45,539 --> 00:22:48,059
authentication information

589
00:22:48,059 --> 00:22:49,860
um so I looked at the Kerberos one this

590
00:22:49,860 --> 00:22:52,260
is kind of like a small subset of the of

591
00:22:52,260 --> 00:22:55,020
the Kerberos list of supported uh

592
00:22:55,020 --> 00:22:56,820
operations that you can pass to the call

593
00:22:56,820 --> 00:22:59,940
a core provider interface

594
00:22:59,940 --> 00:23:03,600
um and one of them is retrieving coded

595
00:23:03,600 --> 00:23:05,159
ticket

596
00:23:05,159 --> 00:23:07,500
um and you pass this this specific

597
00:23:07,500 --> 00:23:09,960
structure and if you give it a Target

598
00:23:09,960 --> 00:23:12,480
name of these the service principal name

599
00:23:12,480 --> 00:23:14,880
the Kerberos service principle name of a

600
00:23:14,880 --> 00:23:16,860
service you want to access

601
00:23:16,860 --> 00:23:20,820
well it will get you a a ticket for that

602
00:23:20,820 --> 00:23:23,159
service and give you the session key

603
00:23:23,159 --> 00:23:25,500
which allows you to build the

604
00:23:25,500 --> 00:23:27,659
appropriate request information the AP

605
00:23:27,659 --> 00:23:30,360
request information to log on to any

606
00:23:30,360 --> 00:23:32,640
machine so because they forgot to check

607
00:23:32,640 --> 00:23:34,980
that this shouldn't be working in that

608
00:23:34,980 --> 00:23:37,140
container you can actually get access to

609
00:23:37,140 --> 00:23:39,360
Kerberos authentication from an app

610
00:23:39,360 --> 00:23:40,559
container

611
00:23:40,559 --> 00:23:42,600
so

612
00:23:42,600 --> 00:23:46,100
fingers crossed on this one

613
00:23:46,860 --> 00:23:48,179
um

614
00:23:48,179 --> 00:23:49,559
so

615
00:23:49,559 --> 00:23:52,320
again just a bit of Powershell

616
00:23:52,320 --> 00:23:53,940
um

617
00:23:53,940 --> 00:23:55,620
you can clear that so just to

618
00:23:55,620 --> 00:23:58,140
demonstrate this is is creating a token

619
00:23:58,140 --> 00:24:00,059
an app container token and then just for

620
00:24:00,059 --> 00:24:01,980
Simplicity it's impersonating it and

621
00:24:01,980 --> 00:24:04,140
then trying to perform the the network

622
00:24:04,140 --> 00:24:06,780
authentication operations so if we run

623
00:24:06,780 --> 00:24:08,100
this

624
00:24:08,100 --> 00:24:10,760
without the Enterprise capability

625
00:24:10,760 --> 00:24:12,480
we get

626
00:24:12,480 --> 00:24:15,000
big red errors saying your logon session

627
00:24:15,000 --> 00:24:17,940
doesn't exist okay that's fine

628
00:24:17,940 --> 00:24:20,220
um of course if you were if you were

629
00:24:20,220 --> 00:24:22,020
lucky enough to end up with this

630
00:24:22,020 --> 00:24:24,840
Enterprise authentication capability

631
00:24:24,840 --> 00:24:29,280
um well it just works right so you can

632
00:24:29,280 --> 00:24:31,140
um

633
00:24:31,140 --> 00:24:34,440
you can obviously see that is your AP

634
00:24:34,440 --> 00:24:36,240
request for Kerberos but of course the

635
00:24:36,240 --> 00:24:37,500
whole point of this is that we don't

636
00:24:37,500 --> 00:24:40,799
have access to that so finally we do the

637
00:24:40,799 --> 00:24:42,900
same thing again but in this case I call

638
00:24:42,900 --> 00:24:44,820
my get Kerberos ticket function which

639
00:24:44,820 --> 00:24:47,400
actually calls into this LSA call

640
00:24:47,400 --> 00:24:50,760
authentication package function with the

641
00:24:50,760 --> 00:24:54,960
appropriate retrieve encoded ticket API

642
00:24:54,960 --> 00:24:59,880
uh we run that again no error in this

643
00:24:59,880 --> 00:25:02,400
case we can now do format cover us

644
00:25:02,400 --> 00:25:06,000
ticket a ticket dot ticket

645
00:25:06,000 --> 00:25:07,500
and we have

646
00:25:07,500 --> 00:25:09,480
our appropriate ticket for our

647
00:25:09,480 --> 00:25:11,640
particular SPM we we requested and of

648
00:25:11,640 --> 00:25:12,360
course

649
00:25:12,360 --> 00:25:14,280
we should have

650
00:25:14,280 --> 00:25:16,620
in here

651
00:25:16,620 --> 00:25:19,679
a session key obviously base64 encoded

652
00:25:19,679 --> 00:25:20,880
so

653
00:25:20,880 --> 00:25:22,940
um

654
00:25:27,299 --> 00:25:28,559
okay

655
00:25:28,559 --> 00:25:30,059
so

656
00:25:30,059 --> 00:25:32,220
on to the next one

657
00:25:32,220 --> 00:25:34,279
um

658
00:25:34,320 --> 00:25:35,720
so

659
00:25:35,720 --> 00:25:39,650
everyone loves movie cats right

660
00:25:39,650 --> 00:25:43,080
[Applause]

661
00:25:43,080 --> 00:25:46,380
um except maybe Microsoft but

662
00:25:46,380 --> 00:25:47,940
maybe cast of course if you don't know

663
00:25:47,940 --> 00:25:50,039
what it is is a tool which basically

664
00:25:50,039 --> 00:25:53,159
just Hoovers up all credentials or Keys

665
00:25:53,159 --> 00:25:56,340
Etc from the lsos process and present it

666
00:25:56,340 --> 00:25:58,020
to you in a nice easy way for you to

667
00:25:58,020 --> 00:26:00,299
just use for the purposes of of being

668
00:26:00,299 --> 00:26:02,880
malicious now

669
00:26:02,880 --> 00:26:05,039
um over the years Microsoft have tried

670
00:26:05,039 --> 00:26:06,360
various different approaches things like

671
00:26:06,360 --> 00:26:09,480
making lsas protect the process at which

672
00:26:09,480 --> 00:26:12,059
point Benjamin Delphi just created a

673
00:26:12,059 --> 00:26:15,000
driver to bypass that and a bit of a bit

674
00:26:15,000 --> 00:26:18,240
of a chicken egg problem so

675
00:26:18,240 --> 00:26:20,460
credential guard was the final nail in

676
00:26:20,460 --> 00:26:22,559
mimika's coffin right

677
00:26:22,559 --> 00:26:25,080
um and what it what it did was it used

678
00:26:25,080 --> 00:26:26,940
uh the new feature a new feature of

679
00:26:26,940 --> 00:26:28,919
Windows 10 this virtual secure mode

680
00:26:28,919 --> 00:26:31,679
which used a hyper-v hypervisor to

681
00:26:31,679 --> 00:26:34,080
isolate basically a a separate kernel

682
00:26:34,080 --> 00:26:37,020
and process model

683
00:26:37,020 --> 00:26:39,779
from the rest of the system so the

684
00:26:39,779 --> 00:26:41,880
normal user system can't reach out reach

685
00:26:41,880 --> 00:26:44,159
in and read its memory or directly

686
00:26:44,159 --> 00:26:46,679
interact with its with its functions it

687
00:26:46,679 --> 00:26:49,440
can't call functions directly

688
00:26:49,440 --> 00:26:50,100
um

689
00:26:50,100 --> 00:26:52,640
and so you can use this to basically

690
00:26:52,640 --> 00:26:55,799
encrypt and secure the key material and

691
00:26:55,799 --> 00:26:58,260
credential material from prying eyes so

692
00:26:58,260 --> 00:26:59,880
it's never actually exposed in plain

693
00:26:59,880 --> 00:27:03,000
text inside the lsas process

694
00:27:03,000 --> 00:27:03,720
um

695
00:27:03,720 --> 00:27:06,539
now what would usually happen when you

696
00:27:06,539 --> 00:27:07,860
were trying to say do Network

697
00:27:07,860 --> 00:27:09,480
authentication is of course you'd call

698
00:27:09,480 --> 00:27:11,640
into lsas and that would call the LSA

699
00:27:11,640 --> 00:27:13,679
API in the provided dll now what

700
00:27:13,679 --> 00:27:15,840
credential guard did was

701
00:27:15,840 --> 00:27:17,520
um they changed the provided or what

702
00:27:17,520 --> 00:27:19,080
micro did is they changed the provider

703
00:27:19,080 --> 00:27:21,179
dll so instead of implementing

704
00:27:21,179 --> 00:27:25,320
everything locally added some glue logic

705
00:27:25,320 --> 00:27:28,740
and this glue logic could be implemented

706
00:27:28,740 --> 00:27:31,919
inside the provided dll itself or it

707
00:27:31,919 --> 00:27:34,320
could end up calling RPC over to this

708
00:27:34,320 --> 00:27:36,720
virtual secure mode it's LSA isolated

709
00:27:36,720 --> 00:27:39,299
process which ends up calling into some

710
00:27:39,299 --> 00:27:41,340
sort of shared dll for like Kerberos or

711
00:27:41,340 --> 00:27:42,419
ntlm

712
00:27:42,419 --> 00:27:45,299
and so of course this is

713
00:27:45,299 --> 00:27:46,020
um

714
00:27:46,020 --> 00:27:48,360
now protecting those keys so about when

715
00:27:48,360 --> 00:27:50,580
mimikats does come along well it's going

716
00:27:50,580 --> 00:27:52,559
to be out of luck because all the keys

717
00:27:52,559 --> 00:27:54,120
are going to be encrypted and they can't

718
00:27:54,120 --> 00:27:57,179
just break into virtual secure mode

719
00:27:57,179 --> 00:27:59,520
now I could have tried to go after the

720
00:27:59,520 --> 00:28:01,679
hyper-v component of this this feature

721
00:28:01,679 --> 00:28:04,080
but that sounded like a lot of work so

722
00:28:04,080 --> 00:28:07,080
instead I played to my strengths and I

723
00:28:07,080 --> 00:28:08,640
thought okay I'll look at the RPC

724
00:28:08,640 --> 00:28:10,740
interfaces and it turns out they're just

725
00:28:10,740 --> 00:28:14,039
standard msrpc interfaces between the

726
00:28:14,039 --> 00:28:16,200
two there's some special magic to allow

727
00:28:16,200 --> 00:28:18,299
things like alpc ports to work across

728
00:28:18,299 --> 00:28:21,179
that virtualization boundary but you can

729
00:28:21,179 --> 00:28:23,400
just read them all out and there's like

730
00:28:23,400 --> 00:28:24,960
in that case the seven there's probably

731
00:28:24,960 --> 00:28:26,820
even more now this is taken on a Windows

732
00:28:26,820 --> 00:28:28,799
10 machine

733
00:28:28,799 --> 00:28:30,539
um so I spent a bit of time looking

734
00:28:30,539 --> 00:28:32,820
through each ones and you I think I

735
00:28:32,820 --> 00:28:35,460
found about 10 bugs in credential guard

736
00:28:35,460 --> 00:28:38,520
all just through the RPC interface so it

737
00:28:38,520 --> 00:28:41,159
was pretty pretty fruitful to look at

738
00:28:41,159 --> 00:28:42,360
um

739
00:28:42,360 --> 00:28:44,400
now one of the things I noticed is there

740
00:28:44,400 --> 00:28:46,559
was most of the apis could only be

741
00:28:46,559 --> 00:28:48,059
called from lsas

742
00:28:48,059 --> 00:28:50,820
directly but there was one set of apis

743
00:28:50,820 --> 00:28:52,860
this decrypt apis which could be called

744
00:28:52,860 --> 00:28:55,799
by any user on the system so that got me

745
00:28:55,799 --> 00:28:57,179
kind of interested because of course if

746
00:28:57,179 --> 00:28:59,159
there's an attack service in this

747
00:28:59,159 --> 00:29:01,820
implementation then I don't have to

748
00:29:01,820 --> 00:29:06,720
elevate to say admin to get access to

749
00:29:06,720 --> 00:29:09,960
the Elsas apis

750
00:29:09,960 --> 00:29:12,419
so for example this basically is a

751
00:29:12,419 --> 00:29:15,419
wrapper for the bcrypt apis which you

752
00:29:15,419 --> 00:29:17,700
can call locally but the advantage here

753
00:29:17,700 --> 00:29:19,980
is of course you can store your keys

754
00:29:19,980 --> 00:29:21,899
securely inside

755
00:29:21,899 --> 00:29:24,120
um LSA ISO in the virtual secure mode

756
00:29:24,120 --> 00:29:26,399
and not get them exposed and not get

757
00:29:26,399 --> 00:29:28,200
mimikats stealing them or whoever else

758
00:29:28,200 --> 00:29:30,120
stealing them

759
00:29:30,120 --> 00:29:32,100
um so you have a simple function like

760
00:29:32,100 --> 00:29:35,220
open algorithm provider which basically

761
00:29:35,220 --> 00:29:36,480
just forwards it off to the actual

762
00:29:36,480 --> 00:29:39,000
decrypt implementation

763
00:29:39,000 --> 00:29:40,460
um and then of course it can't

764
00:29:40,460 --> 00:29:43,320
necessarily just return the results of

765
00:29:43,320 --> 00:29:45,299
that operation back so it it wraps them

766
00:29:45,299 --> 00:29:47,279
up in a locally allocated buffer inside

767
00:29:47,279 --> 00:29:50,159
here puts just the magic value in just

768
00:29:50,159 --> 00:29:52,020
so it can identify that it's the correct

769
00:29:52,020 --> 00:29:54,899
type of thing store the algorithm handle

770
00:29:54,899 --> 00:29:57,179
and then get that gets returned back to

771
00:29:57,179 --> 00:30:00,720
the caller as an outbound pointer

772
00:30:00,720 --> 00:30:03,299
and like there's a corresponding closed

773
00:30:03,299 --> 00:30:05,580
one it goes okay does that magic exist

774
00:30:05,580 --> 00:30:08,220
at that pointer if it does I can close

775
00:30:08,220 --> 00:30:10,380
the algorithm everything's fine I can

776
00:30:10,380 --> 00:30:12,360
just free the object job done

777
00:30:12,360 --> 00:30:15,240
now how this is supposed to work in most

778
00:30:15,240 --> 00:30:17,700
RPC implementations is using something

779
00:30:17,700 --> 00:30:20,580
called context handles so the idea here

780
00:30:20,580 --> 00:30:23,279
is that a context handle is actually a

781
00:30:23,279 --> 00:30:27,059
guide and what the RPC runtime does is

782
00:30:27,059 --> 00:30:28,620
when it sees one of these pointers

783
00:30:28,620 --> 00:30:30,779
instead of passing the pointer back to

784
00:30:30,779 --> 00:30:33,120
the caller it allocates a new guide

785
00:30:33,120 --> 00:30:35,700
which you can actually hand back then

786
00:30:35,700 --> 00:30:37,620
when the client wants to talk back and

787
00:30:37,620 --> 00:30:40,380
say I want to use this pointer in my

788
00:30:40,380 --> 00:30:43,320
operation it passes the good across the

789
00:30:43,320 --> 00:30:45,840
RPC runtime looks up the pointer and and

790
00:30:45,840 --> 00:30:47,520
it that is what gets passed to the

791
00:30:47,520 --> 00:30:50,520
implementation on in the service

792
00:30:50,520 --> 00:30:53,399
so in general this it looks a bit

793
00:30:53,399 --> 00:30:55,679
sketchy but it is perfectly fine like as

794
00:30:55,679 --> 00:30:57,539
long as the RPC interface is correctly

795
00:30:57,539 --> 00:30:59,460
implemented unfortunately the RPC

796
00:30:59,460 --> 00:31:03,179
interface is not correctly implemented

797
00:31:03,179 --> 00:31:07,020
like okay it knows the developer knew

798
00:31:07,020 --> 00:31:08,880
about context handles enough to use them

799
00:31:08,880 --> 00:31:11,100
in a bit of the apis but when it comes

800
00:31:11,100 --> 00:31:13,740
to returning this point this buffer

801
00:31:13,740 --> 00:31:17,179
it returns an in64. just returns a

802
00:31:17,179 --> 00:31:19,140
64-bit integer

803
00:31:19,140 --> 00:31:21,480
and you can guess probably what it's

804
00:31:21,480 --> 00:31:24,059
doing it's literally returning the raw

805
00:31:24,059 --> 00:31:27,240
pointer from virtual secure mode to the

806
00:31:27,240 --> 00:31:28,200
client

807
00:31:28,200 --> 00:31:31,320
that sounds bad

808
00:31:31,320 --> 00:31:34,200
um so okay I thought let's let's try and

809
00:31:34,200 --> 00:31:37,020
make sure that this actually works

810
00:31:37,020 --> 00:31:39,600
the problem is debugging virtual secure

811
00:31:39,600 --> 00:31:42,899
mode apis is pretty pretty challenging

812
00:31:42,899 --> 00:31:45,000
um I I've tried to do it through the

813
00:31:45,000 --> 00:31:47,820
hypervisor debugger just it's just I

814
00:31:47,820 --> 00:31:50,700
couldn't be bothered so in the end it's

815
00:31:50,700 --> 00:31:52,740
actually relatively easy to get this LSA

816
00:31:52,740 --> 00:31:55,740
ISO process to run as just a normal user

817
00:31:55,740 --> 00:31:57,299
application

818
00:31:57,299 --> 00:31:59,580
um if you pass the credit guard a

819
00:31:59,580 --> 00:32:01,320
command line argument it goes okay I

820
00:32:01,320 --> 00:32:03,419
need to run its credential guard

821
00:32:03,419 --> 00:32:05,039
um because you're running as non-admin

822
00:32:05,039 --> 00:32:07,140
you should disable a couple of functions

823
00:32:07,140 --> 00:32:09,000
this basically just patches it to X or

824
00:32:09,000 --> 00:32:12,419
eax eax red and so just return zero

825
00:32:12,419 --> 00:32:14,580
they're not particularly required for

826
00:32:14,580 --> 00:32:17,460
the types of tests you're likely to do

827
00:32:17,460 --> 00:32:19,260
um I would not recommend running this as

828
00:32:19,260 --> 00:32:21,779
admin because if you do it turns itself

829
00:32:21,779 --> 00:32:23,820
into a critical process then the minute

830
00:32:23,820 --> 00:32:25,740
you crash it or close windybug your

831
00:32:25,740 --> 00:32:28,320
machine blue screens which is usually a

832
00:32:28,320 --> 00:32:31,380
sub-optimal um to your development

833
00:32:31,380 --> 00:32:34,799
process if you happen to have credential

834
00:32:34,799 --> 00:32:37,140
guard already running like if you're

835
00:32:37,140 --> 00:32:38,700
running Windows 11 it's probably running

836
00:32:38,700 --> 00:32:41,279
credential guard this final patch just

837
00:32:41,279 --> 00:32:44,580
basically changes the aopc name so that

838
00:32:44,580 --> 00:32:46,320
it doesn't conflict because if you don't

839
00:32:46,320 --> 00:32:47,700
change it it'll go well I'm already

840
00:32:47,700 --> 00:32:49,620
registered so I'm not going to do it of

841
00:32:49,620 --> 00:32:50,880
course you don't need to make sure

842
00:32:50,880 --> 00:32:53,640
you're actually calling the the New alpc

843
00:32:53,640 --> 00:32:55,260
Port not the old one otherwise you'll

844
00:32:55,260 --> 00:32:58,260
crash the real credential guard

845
00:32:58,260 --> 00:33:01,320
okay demo time

846
00:33:01,320 --> 00:33:04,140
so because this is basically a memory

847
00:33:04,140 --> 00:33:06,000
corruption type vulnerability I'm far

848
00:33:06,000 --> 00:33:08,940
too lazy to exploit that properly so

849
00:33:08,940 --> 00:33:10,559
um in this particular case I'm just

850
00:33:10,559 --> 00:33:11,940
going to demonstrate that it is actually

851
00:33:11,940 --> 00:33:15,000
an issue so I've got my LSA ISO process

852
00:33:15,000 --> 00:33:18,480
running happily in user mode

853
00:33:18,480 --> 00:33:20,220
um I've got I just patched out those

854
00:33:20,220 --> 00:33:23,100
functions it's running in the background

855
00:33:23,100 --> 00:33:24,539
um

856
00:33:24,539 --> 00:33:27,620
then if I

857
00:33:29,460 --> 00:33:31,799
um go to demo three

858
00:33:31,799 --> 00:33:34,500
so we can just pull out the RPC

859
00:33:34,500 --> 00:33:37,980
interface again in this case I open a

860
00:33:37,980 --> 00:33:40,860
algorithm provider pull out its context

861
00:33:40,860 --> 00:33:43,799
pointer and then just close it twice and

862
00:33:43,799 --> 00:33:45,480
of course what that's going to do is

863
00:33:45,480 --> 00:33:46,919
it's going to double free on that that

864
00:33:46,919 --> 00:33:49,559
funk that pointer

865
00:33:49,559 --> 00:33:50,159
um

866
00:33:50,159 --> 00:33:51,960
and in fact you don't even have to

867
00:33:51,960 --> 00:33:54,179
actually open a known provider you can

868
00:33:54,179 --> 00:33:56,460
just pass any number you like as a

869
00:33:56,460 --> 00:33:58,200
pointer so it doesn't have to be like

870
00:33:58,200 --> 00:34:01,260
this but this way because the memory

871
00:34:01,260 --> 00:34:03,779
doesn't get cleared after it's freed

872
00:34:03,779 --> 00:34:05,700
um it will still look to be valid from

873
00:34:05,700 --> 00:34:06,960
the perspective of that sort of

874
00:34:06,960 --> 00:34:08,940
verification process in the closed but

875
00:34:08,940 --> 00:34:10,739
then of course when it hits local free

876
00:34:10,739 --> 00:34:12,119
it should blow up

877
00:34:12,119 --> 00:34:14,879
so

878
00:34:14,879 --> 00:34:17,639
if I run that

879
00:34:17,639 --> 00:34:20,359
hopefully

880
00:34:21,199 --> 00:34:23,940
uh oh yeah what am I doing I should

881
00:34:23,940 --> 00:34:26,280
actually look at the debugger right

882
00:34:26,280 --> 00:34:27,179
um

883
00:34:27,179 --> 00:34:28,859
so we've now got

884
00:34:28,859 --> 00:34:31,560
uh RTL report critical failure because

885
00:34:31,560 --> 00:34:33,899
we've double freed

886
00:34:33,899 --> 00:34:35,820
um the Heap manager doesn't like that

887
00:34:35,820 --> 00:34:37,440
one bit

888
00:34:37,440 --> 00:34:40,739
um we should have hopefully on here

889
00:34:40,739 --> 00:34:44,119
well if it's uh

890
00:34:44,119 --> 00:34:46,320
I can't actually get to the pointer it

891
00:34:46,320 --> 00:34:48,119
printed to print it off but trust me

892
00:34:48,119 --> 00:34:50,699
when I say that the the buffer if I if I

893
00:34:50,699 --> 00:34:52,440
dumped it would actually

894
00:34:52,440 --> 00:34:54,418
um come up with the the correct

895
00:34:54,418 --> 00:34:56,940
information so again you you would have

896
00:34:56,940 --> 00:34:58,619
to do a bit of work to get this to run

897
00:34:58,619 --> 00:35:00,900
but basically you've just got a double

898
00:35:00,900 --> 00:35:03,660
free or or manner of horrendous memory

899
00:35:03,660 --> 00:35:05,760
corruption potential inside is

900
00:35:05,760 --> 00:35:08,160
supposedly super secure process which

901
00:35:08,160 --> 00:35:11,280
contains all your authentication Secrets

902
00:35:11,280 --> 00:35:13,560
which is accessible from a normal user

903
00:35:13,560 --> 00:35:14,880
application

904
00:35:14,880 --> 00:35:17,640
again probably not a great thing

905
00:35:17,640 --> 00:35:20,180
okay

906
00:35:21,000 --> 00:35:24,660
so let's finish up with uh remote

907
00:35:24,660 --> 00:35:27,780
credential guard this time

908
00:35:27,780 --> 00:35:29,099
um

909
00:35:29,099 --> 00:35:30,720
so

910
00:35:30,720 --> 00:35:34,020
in the in the good old days of

911
00:35:34,020 --> 00:35:36,180
um remote desktop

912
00:35:36,180 --> 00:35:38,400
it it tended to work a bit like this so

913
00:35:38,400 --> 00:35:40,380
you would have your RDP client speaking

914
00:35:40,380 --> 00:35:43,980
RDP protocol to your RDP endpoint

915
00:35:43,980 --> 00:35:46,440
I need to keep stop saying RDP but

916
00:35:46,440 --> 00:35:47,820
that's your terminal service so this is

917
00:35:47,820 --> 00:35:49,859
your protocol to communicate with the

918
00:35:49,859 --> 00:35:51,960
terminal service

919
00:35:51,960 --> 00:35:53,820
and what when you make a connection what

920
00:35:53,820 --> 00:35:55,079
would happen is the terminal service

921
00:35:55,079 --> 00:35:57,240
would spin up a brand new log on session

922
00:35:57,240 --> 00:36:00,300
for you it would go okay here's the the

923
00:36:00,300 --> 00:36:02,400
username and password box please log on

924
00:36:02,400 --> 00:36:04,920
to your system thank you

925
00:36:04,920 --> 00:36:05,640
um

926
00:36:05,640 --> 00:36:08,760
then of course once that's is spun up it

927
00:36:08,760 --> 00:36:11,220
attaches its graphics and input channels

928
00:36:11,220 --> 00:36:13,859
and then that's reflected on the client

929
00:36:13,859 --> 00:36:16,200
the client user can then literally

930
00:36:16,200 --> 00:36:17,760
manually type in their username and

931
00:36:17,760 --> 00:36:20,339
password into that box and

932
00:36:20,339 --> 00:36:22,920
authentication proceeds and you've

933
00:36:22,920 --> 00:36:25,140
authenticated it to that machine but the

934
00:36:25,140 --> 00:36:27,780
trouble with this is it's really bad

935
00:36:27,780 --> 00:36:29,880
from a resource perspective

936
00:36:29,880 --> 00:36:31,859
anybody could potentially connect your

937
00:36:31,859 --> 00:36:35,280
RDP port and say hey I want to log on

938
00:36:35,280 --> 00:36:38,040
please at which point the terminal

939
00:36:38,040 --> 00:36:40,680
service has to spin up this quite

940
00:36:40,680 --> 00:36:43,980
expensive desktop for you in order to

941
00:36:43,980 --> 00:36:46,320
actually allow you to log on so that

942
00:36:46,320 --> 00:36:47,940
doesn't that's not very good and it

943
00:36:47,940 --> 00:36:49,619
could lead to denial of service you're a

944
00:36:49,619 --> 00:36:52,160
terminal service

945
00:36:52,380 --> 00:36:54,839
so Microsoft changed that in by

946
00:36:54,839 --> 00:36:55,740
implementing Network level

947
00:36:55,740 --> 00:36:58,020
authentication and what they did was

948
00:36:58,020 --> 00:37:00,119
they added a new Security package cred

949
00:37:00,119 --> 00:37:03,780
SSP which uh allowed you to sort of make

950
00:37:03,780 --> 00:37:05,940
this less of an issue so in this

951
00:37:05,940 --> 00:37:08,820
particular case what actually happens

952
00:37:08,820 --> 00:37:12,420
is it first does Network authentication

953
00:37:12,420 --> 00:37:13,859
and network authentication is pretty

954
00:37:13,859 --> 00:37:16,440
lightweight and it does this network

955
00:37:16,440 --> 00:37:18,540
authentication that ultimately ends up

956
00:37:18,540 --> 00:37:20,940
with an access token and the terminal

957
00:37:20,940 --> 00:37:23,940
service can then go okay is this user

958
00:37:23,940 --> 00:37:26,400
actually allowed to talk to my terminal

959
00:37:26,400 --> 00:37:28,560
server or not at which point if if it's

960
00:37:28,560 --> 00:37:31,619
not it can say goodbye not interested go

961
00:37:31,619 --> 00:37:33,180
away

962
00:37:33,180 --> 00:37:35,579
um however at this point you've got a

963
00:37:35,579 --> 00:37:37,020
slight problem you can't just use the

964
00:37:37,020 --> 00:37:39,420
network authentication directly to log

965
00:37:39,420 --> 00:37:41,520
on to the system because usually people

966
00:37:41,520 --> 00:37:43,560
expect to be able to then from that

967
00:37:43,560 --> 00:37:46,500
system log on further so what credit SSP

968
00:37:46,500 --> 00:37:49,200
does is it passes your plain text

969
00:37:49,200 --> 00:37:51,060
credentials although it encrypts it over

970
00:37:51,060 --> 00:37:52,560
the network link

971
00:37:52,560 --> 00:37:55,440
to the server and the server can now use

972
00:37:55,440 --> 00:37:57,540
that to log in as if you were actually

973
00:37:57,540 --> 00:37:59,700
typing it into the login box

974
00:37:59,700 --> 00:38:01,800
so of course sitting on this system now

975
00:38:01,800 --> 00:38:04,920
is your use your plain text credentials

976
00:38:04,920 --> 00:38:06,960
and again Benjamin Delphi is probably

977
00:38:06,960 --> 00:38:08,820
like rubbing his hands going aha I'm

978
00:38:08,820 --> 00:38:11,339
going to get your credentials now

979
00:38:11,339 --> 00:38:12,300
um

980
00:38:12,300 --> 00:38:15,180
so this of course is a bit of a risk

981
00:38:15,180 --> 00:38:16,680
because of course a lot of time your

982
00:38:16,680 --> 00:38:18,960
terminal services are probably shared

983
00:38:18,960 --> 00:38:21,119
systems and if a domain admin for

984
00:38:21,119 --> 00:38:22,920
example logged on you don't that domain

985
00:38:22,920 --> 00:38:24,480
admin doesn't know that that machine

986
00:38:24,480 --> 00:38:26,820
hasn't been compromised

987
00:38:26,820 --> 00:38:29,460
um so it's best to best to avoid that

988
00:38:29,460 --> 00:38:30,900
so one of the first things Microsoft

989
00:38:30,900 --> 00:38:32,400
tried to do was Implement something

990
00:38:32,400 --> 00:38:34,440
called restricted admin mode and what

991
00:38:34,440 --> 00:38:36,300
this actually did was just use the

992
00:38:36,300 --> 00:38:38,579
network authentication part to establish

993
00:38:38,579 --> 00:38:40,619
the the connection and the user session

994
00:38:40,619 --> 00:38:43,500
but of course because you've not passed

995
00:38:43,500 --> 00:38:46,140
credentials you're no longer actually

996
00:38:46,140 --> 00:38:48,780
able to authenticate to any system

997
00:38:48,780 --> 00:38:51,180
further on from that machine which which

998
00:38:51,180 --> 00:38:52,320
isn't great if you're trying to connect

999
00:38:52,320 --> 00:38:54,060
to say a Bastion host or something like

1000
00:38:54,060 --> 00:38:55,619
that

1001
00:38:55,619 --> 00:38:57,720
so this is where remote credential guard

1002
00:38:57,720 --> 00:38:59,280
comes into play

1003
00:38:59,280 --> 00:39:01,380
um it uses a new type of credentials

1004
00:39:01,380 --> 00:39:02,820
instead of just a username and password

1005
00:39:02,820 --> 00:39:04,859
it has basically sort of Kerberos ticket

1006
00:39:04,859 --> 00:39:06,420
and

1007
00:39:06,420 --> 00:39:09,300
um a TGT but crucially it encrypts the

1008
00:39:09,300 --> 00:39:10,920
session key so the session key

1009
00:39:10,920 --> 00:39:13,260
associated with the TGT is encrypted by

1010
00:39:13,260 --> 00:39:15,300
a key held by the client

1011
00:39:15,300 --> 00:39:16,859
and

1012
00:39:16,859 --> 00:39:18,839
in theory that shouldn't be able to leak

1013
00:39:18,839 --> 00:39:20,280
and the target shouldn't be able to

1014
00:39:20,280 --> 00:39:22,619
decrypt it directly but in order to use

1015
00:39:22,619 --> 00:39:24,480
that what happens is a channel is

1016
00:39:24,480 --> 00:39:26,820
established back using that same glue

1017
00:39:26,820 --> 00:39:29,099
logic used in credential guard to

1018
00:39:29,099 --> 00:39:30,540
basically forward that authentication

1019
00:39:30,540 --> 00:39:32,460
request back to the client

1020
00:39:32,460 --> 00:39:35,220
so this has the advantage that a your

1021
00:39:35,220 --> 00:39:38,520
key is not directly disclosed to the uh

1022
00:39:38,520 --> 00:39:40,380
to the terminal server and if that

1023
00:39:40,380 --> 00:39:42,180
client decides to disconnect but not log

1024
00:39:42,180 --> 00:39:44,640
out then because that client doesn't

1025
00:39:44,640 --> 00:39:46,320
exist even if an attacker comes on later

1026
00:39:46,320 --> 00:39:48,599
they can't actually talk to the client

1027
00:39:48,599 --> 00:39:50,880
to even try and negotiate that that key

1028
00:39:50,880 --> 00:39:53,220
material

1029
00:39:53,220 --> 00:39:54,300
um

1030
00:39:54,300 --> 00:39:55,740
of course you still need to log on to it

1031
00:39:55,740 --> 00:39:57,300
so that that buffer with like the

1032
00:39:57,300 --> 00:40:00,240
Kerberos ticket and the TGT is handled

1033
00:40:00,240 --> 00:40:04,380
by credit SSP and I saw this code in in

1034
00:40:04,380 --> 00:40:06,960
the implementation inside LSA

1035
00:40:06,960 --> 00:40:09,839
uh it builds up some sort of magic some

1036
00:40:09,839 --> 00:40:11,880
sort of magic buffer containing function

1037
00:40:11,880 --> 00:40:12,900
pointers

1038
00:40:12,900 --> 00:40:16,020
good sign pointed to the credentials and

1039
00:40:16,020 --> 00:40:18,240
then encrypts it using a key only known

1040
00:40:18,240 --> 00:40:21,839
by the local uh local security Authority

1041
00:40:21,839 --> 00:40:24,660
then if you look at the uh the Kerberos

1042
00:40:24,660 --> 00:40:25,680
side where it actually does the

1043
00:40:25,680 --> 00:40:29,099
authentication with this information it

1044
00:40:29,099 --> 00:40:31,680
um decrypts it and assumes that if you

1045
00:40:31,680 --> 00:40:33,480
can decrypt it it must have been

1046
00:40:33,480 --> 00:40:35,760
encrypted using this special key and

1047
00:40:35,760 --> 00:40:38,520
therefore it must be secure so passing

1048
00:40:38,520 --> 00:40:40,200
this binary data with arbitrary function

1049
00:40:40,200 --> 00:40:42,599
points this should be fine

1050
00:40:42,599 --> 00:40:43,980
um and of course so it goes well it must

1051
00:40:43,980 --> 00:40:45,000
be trusted so I'm just going to

1052
00:40:45,000 --> 00:40:47,040
de-reference that function pointer and

1053
00:40:47,040 --> 00:40:50,160
call it awesome

1054
00:40:50,160 --> 00:40:52,740
um the trouble is the normal user

1055
00:40:52,740 --> 00:40:55,200
password authentication uses the exact

1056
00:40:55,200 --> 00:40:57,900
same key and these passwords are counted

1057
00:40:57,900 --> 00:41:01,619
strings so you can craft that exact same

1058
00:41:01,619 --> 00:41:03,960
buffer using the guide and all the

1059
00:41:03,960 --> 00:41:06,119
material information but pretend you're

1060
00:41:06,119 --> 00:41:08,460
just a normal authenticating user using

1061
00:41:08,460 --> 00:41:10,140
the username and password it will

1062
00:41:10,140 --> 00:41:12,960
happily encrypt it for you and you

1063
00:41:12,960 --> 00:41:14,579
bypass that restriction and you've got

1064
00:41:14,579 --> 00:41:16,740
arbitrary code execution inside the LSA

1065
00:41:16,740 --> 00:41:19,980
process from a remote attacker

1066
00:41:19,980 --> 00:41:22,560
so demo it again being a memory

1067
00:41:22,560 --> 00:41:24,660
corruption I'm just going to demo it

1068
00:41:24,660 --> 00:41:25,980
sort of locally

1069
00:41:25,980 --> 00:41:29,339
now in this particular case

1070
00:41:29,339 --> 00:41:32,099
um this is just building this buffer and

1071
00:41:32,099 --> 00:41:33,540
so my function pointers are all going to

1072
00:41:33,540 --> 00:41:34,859
be CCC

1073
00:41:34,859 --> 00:41:37,079
uh it's a it's a classic value I could

1074
00:41:37,079 --> 00:41:39,060
change it to anything and then all we do

1075
00:41:39,060 --> 00:41:41,700
is we basically just negotiate this cred

1076
00:41:41,700 --> 00:41:45,480
SSP locally so

1077
00:41:45,480 --> 00:41:49,320
if I just run this

1078
00:41:49,320 --> 00:41:50,339
um

1079
00:41:50,339 --> 00:41:54,119
okay so I'm not too invested in ASCII

1080
00:41:54,119 --> 00:41:56,280
art but this is my ASCII art of of an

1081
00:41:56,280 --> 00:41:58,099
encrypted password which is about to

1082
00:41:58,099 --> 00:42:01,980
cause lsas to die horribly

1083
00:42:01,980 --> 00:42:04,940
um if I hit enter

1084
00:42:10,320 --> 00:42:13,560
yeah LSA blows up and of course you can

1085
00:42:13,560 --> 00:42:15,180
do that you could access that remotely

1086
00:42:15,180 --> 00:42:16,859
right

1087
00:42:16,859 --> 00:42:18,900
um so just key takeaways just to finish

1088
00:42:18,900 --> 00:42:20,220
off

1089
00:42:20,220 --> 00:42:22,859
um Windows authentication is really

1090
00:42:22,859 --> 00:42:25,140
complex loads of bugs right for bugs

1091
00:42:25,140 --> 00:42:27,359
amazing and of course if you can find

1092
00:42:27,359 --> 00:42:29,940
like a remote code execution in lsas

1093
00:42:29,940 --> 00:42:32,099
that's pretty much game over for that

1094
00:42:32,099 --> 00:42:33,900
for that machine if you can find it

1095
00:42:33,900 --> 00:42:36,720
remote to uh virtual secure mode even

1096
00:42:36,720 --> 00:42:39,119
better that'd be fantastic

1097
00:42:39,119 --> 00:42:40,920
um and it's also worth pointing out that

1098
00:42:40,920 --> 00:42:43,800
those last two bugs were pretty new new

1099
00:42:43,800 --> 00:42:45,839
code like remote credential guard and

1100
00:42:45,839 --> 00:42:48,060
credential guard is probably only less

1101
00:42:48,060 --> 00:42:49,980
than five years old

1102
00:42:49,980 --> 00:42:52,859
yeah like that was potentially as bad as

1103
00:42:52,859 --> 00:42:54,480
some code which is like 20 plus years

1104
00:42:54,480 --> 00:42:57,720
old so thank you very much for uh for

1105
00:42:57,720 --> 00:43:00,740
listening to me and

1106
00:43:07,200 --> 00:43:10,200
I hope you have a the last few uh good

1107
00:43:10,200 --> 00:43:12,720
talks of the conference so uh safe

1108
00:43:12,720 --> 00:43:13,800
travels

1109
00:43:13,800 --> 00:43:16,520
thank you

1110
00:43:18,760 --> 00:43:21,019
[Music]

