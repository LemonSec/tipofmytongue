1
00:00:11,630 --> 00:00:17,460
hi my name is Mira vu cough and my talk

2
00:00:15,270 --> 00:00:18,660
is about Cisco lower cover coverage

3
00:00:17,460 --> 00:00:21,509
cadet Colonel Fussell

4
00:00:18,660 --> 00:00:24,630
so first I'm going to talk about

5
00:00:21,509 --> 00:00:27,239
background about problem space then

6
00:00:24,630 --> 00:00:29,700
about implementation details then about

7
00:00:27,239 --> 00:00:33,149
results that we get and then a bit about

8
00:00:29,700 --> 00:00:35,300
future work so work at Google and

9
00:00:33,149 --> 00:00:38,880
dynamic tools team and we do a set of

10
00:00:35,300 --> 00:00:41,250
tools also do some bug provocation tools

11
00:00:38,880 --> 00:00:44,130
in particular lip phaser or go phazon

12
00:00:41,250 --> 00:00:46,769
sis color and also some fuzz and

13
00:00:44,130 --> 00:00:49,230
automation and coverage tools so some of

14
00:00:46,770 --> 00:00:52,230
them are older and you hopefully know

15
00:00:49,230 --> 00:00:54,989
about them some of them are pretty new

16
00:00:52,230 --> 00:00:57,360
for example we pass on and KC's on our

17
00:00:54,990 --> 00:01:01,620
latest hotness so maybe you want to

18
00:00:57,360 --> 00:01:05,519
check them out later so we did our tools

19
00:01:01,620 --> 00:01:07,590
for user space initially and around 2014

20
00:01:05,519 --> 00:01:11,939
we started looking at the kernel and by

21
00:01:07,590 --> 00:01:13,560
colonel I mean Linux kernel we started

22
00:01:11,939 --> 00:01:15,990
looking at the kernel as a place where

23
00:01:13,560 --> 00:01:18,960
we can bring the expertise and also

24
00:01:15,990 --> 00:01:21,179
create tools so first of all who created

25
00:01:18,960 --> 00:01:22,770
prototype of address Signet Iser which

26
00:01:21,180 --> 00:01:24,659
finds use of the free and out of bounds

27
00:01:22,770 --> 00:01:28,500
so this is the first tool you want to

28
00:01:24,659 --> 00:01:32,400
have in your toolbox but then we hit a

29
00:01:28,500 --> 00:01:33,810
problem so those are dynamic tools which

30
00:01:32,400 --> 00:01:37,409
means there are only as good as your

31
00:01:33,810 --> 00:01:40,830
tests are they only do that box that

32
00:01:37,409 --> 00:01:43,170
actually happened on some load so if you

33
00:01:40,830 --> 00:01:46,670
don't have any good lord then they will

34
00:01:43,170 --> 00:01:49,020
not find any bugs and we couldn't find

35
00:01:46,670 --> 00:01:51,810
tests use for kernel or we couldn't

36
00:01:49,020 --> 00:01:54,210
build them or we couldn't run them we

37
00:01:51,810 --> 00:01:56,490
booted kernel we run some user space

38
00:01:54,210 --> 00:01:58,919
programs who found few boxes address in

39
00:01:56,490 --> 00:02:00,990
Taizo but it feel that like it's not

40
00:01:58,920 --> 00:02:04,380
enough we're not getting enough benefit

41
00:02:00,990 --> 00:02:06,990
of the tool and around the same time we

42
00:02:04,380 --> 00:02:10,439
started looking at frozen can user space

43
00:02:06,990 --> 00:02:13,140
as a technique to actually get some load

44
00:02:10,439 --> 00:02:16,409
and provoke more box and detect more

45
00:02:13,140 --> 00:02:17,879
bugs so innocent fuzzing is a very

46
00:02:16,409 --> 00:02:20,999
simple thing you generate the random

47
00:02:17,879 --> 00:02:21,810
input you feed it in the program and you

48
00:02:20,999 --> 00:02:25,260
see what happens

49
00:02:21,810 --> 00:02:27,890
like did it crash or no

50
00:02:25,260 --> 00:02:31,140
but if you feed completely random data

51
00:02:27,890 --> 00:02:33,958
most likely you will not find lots of

52
00:02:31,140 --> 00:02:36,358
bugs because most likely execution will

53
00:02:33,959 --> 00:02:38,099
bail out on the first if condition and

54
00:02:36,359 --> 00:02:40,349
the code and you will not actually cover

55
00:02:38,099 --> 00:02:43,170
a majority of the code right if you feed

56
00:02:40,349 --> 00:02:44,909
completely white noise so the current

57
00:02:43,170 --> 00:02:47,129
state-of-the-art in in fuzzing is

58
00:02:44,909 --> 00:02:49,500
considered to be code coverage guide

59
00:02:47,129 --> 00:02:53,099
advising and in particular tools like

60
00:02:49,500 --> 00:02:57,150
AFL confers go fast leap files are all

61
00:02:53,099 --> 00:02:59,819
coverage guide advisors so what is

62
00:02:57,150 --> 00:03:02,250
coverage guide advising you start by

63
00:02:59,819 --> 00:03:05,250
building your program with code coverage

64
00:03:02,250 --> 00:03:08,939
instrumentation and then you collect

65
00:03:05,250 --> 00:03:10,680
corpus of inputs you may take them from

66
00:03:08,939 --> 00:03:13,260
unit tests or somewhere else

67
00:03:10,680 --> 00:03:17,639
this step is actually optional you can

68
00:03:13,260 --> 00:03:19,379
start let's say was just one input then

69
00:03:17,639 --> 00:03:22,769
you choose one random input from the

70
00:03:19,379 --> 00:03:24,870
corpus and you move slightly mutate this

71
00:03:22,769 --> 00:03:28,379
input for example we flip some bits or

72
00:03:24,870 --> 00:03:30,269
you insert or remove bytes then you

73
00:03:28,379 --> 00:03:33,209
execute this program and collect code

74
00:03:30,269 --> 00:03:35,489
coverage and then you see if this

75
00:03:33,209 --> 00:03:37,560
program gives new coverage so it covers

76
00:03:35,489 --> 00:03:40,139
some code that you never covered before

77
00:03:37,560 --> 00:03:42,000
with any of the previous programs then

78
00:03:40,139 --> 00:03:44,669
you add this program back to the corpus

79
00:03:42,000 --> 00:03:49,199
and this this was part repeats in an

80
00:03:44,669 --> 00:03:51,090
infinite loop essentially so let's see

81
00:03:49,199 --> 00:03:53,609
how how it works in practice let's say

82
00:03:51,090 --> 00:03:56,099
we have this piece of code which parses

83
00:03:53,609 --> 00:03:59,759
an input and to get to the last line

84
00:03:56,099 --> 00:04:04,560
that potentially may contain but we need

85
00:03:59,759 --> 00:04:06,869
to provide an input ABCD so ABCD is 4

86
00:04:04,560 --> 00:04:10,470
bytes and if you try to guess it

87
00:04:06,870 --> 00:04:12,599
completely blindly we will need about 2

88
00:04:10,470 --> 00:04:15,659
to the power of 32 iterations to guess

89
00:04:12,599 --> 00:04:17,519
this right so even for this simple and

90
00:04:15,659 --> 00:04:19,969
small piece of code we'll need 4 billion

91
00:04:17,519 --> 00:04:22,289
attempts which is doesn't sound too good

92
00:04:19,970 --> 00:04:24,479
so what happens with coverage guided

93
00:04:22,289 --> 00:04:27,560
fighting let's say we start generating

94
00:04:24,479 --> 00:04:30,150
some random inputs and in approximately

95
00:04:27,560 --> 00:04:33,240
256 iteration which generate input that

96
00:04:30,150 --> 00:04:35,070
starts with the byte a at this point

97
00:04:33,240 --> 00:04:36,870
when I execute we'll get to the second

98
00:04:35,070 --> 00:04:37,340
line of the code and we will say oh we

99
00:04:36,870 --> 00:04:39,500
actually

100
00:04:37,340 --> 00:04:42,469
never get to the second line of the code

101
00:04:39,500 --> 00:04:45,410
this new coverage so add input a back to

102
00:04:42,470 --> 00:04:48,380
the corpus then we'll continue this

103
00:04:45,410 --> 00:04:51,770
process and approximately in 256

104
00:04:48,380 --> 00:04:53,210
iteration we will get input a B and at

105
00:04:51,770 --> 00:04:55,250
this point we'll get to the third line

106
00:04:53,210 --> 00:04:58,609
of the code again it's new coverage have

107
00:04:55,250 --> 00:05:01,699
added to the corpus and so on and we

108
00:04:58,610 --> 00:05:03,620
will guess the ABC and then ABC DM so in

109
00:05:01,699 --> 00:05:05,530
toto it will take approximately two to

110
00:05:03,620 --> 00:05:08,240
the power of ten or thousand iterations

111
00:05:05,530 --> 00:05:12,190
now to guess this input so you may

112
00:05:08,240 --> 00:05:14,720
compare this to 4 billion iterations

113
00:05:12,190 --> 00:05:17,200
coverage gated pheasant Mallis turns

114
00:05:14,720 --> 00:05:19,970
exponential problem into polynomial

115
00:05:17,200 --> 00:05:22,070
because of this incremental progress and

116
00:05:19,970 --> 00:05:24,740
constantly persisting the progress in

117
00:05:22,070 --> 00:05:27,860
the corpus so it's a bit reminds of a

118
00:05:24,740 --> 00:05:31,400
dynamic program and and there's a famous

119
00:05:27,860 --> 00:05:34,960
example for IFL how it generates

120
00:05:31,400 --> 00:05:37,400
valid G badly much out of out of nothing

121
00:05:34,960 --> 00:05:40,460
so the advantages of this approach is

122
00:05:37,400 --> 00:05:42,500
that it's efficient it also gives rep

123
00:05:40,460 --> 00:05:44,930
reducers because those inputs are by

124
00:05:42,500 --> 00:05:47,210
definition immediately and reproducers

125
00:05:44,930 --> 00:05:50,180
if they trigger a crash and it's also

126
00:05:47,210 --> 00:05:53,000
great for regression testing because the

127
00:05:50,180 --> 00:05:54,380
corpus by construction it's the set of

128
00:05:53,000 --> 00:05:59,840
programs that gives us the maximum

129
00:05:54,380 --> 00:06:02,810
coverage okay

130
00:05:59,840 --> 00:06:05,679
so existing kernel fuzzers they were a

131
00:06:02,810 --> 00:06:08,330
bit simpler what they did essentially

132
00:06:05,680 --> 00:06:10,610
they executed an infinite sequence of

133
00:06:08,330 --> 00:06:14,000
system of random system calls is random

134
00:06:10,610 --> 00:06:16,490
arguments so they had some knowledge of

135
00:06:14,000 --> 00:06:18,770
argument types for example if cisco

136
00:06:16,490 --> 00:06:20,419
accepts a file descriptor they will try

137
00:06:18,770 --> 00:06:22,789
the pass and file descriptor in that

138
00:06:20,419 --> 00:06:24,409
position and so on but still it's just

139
00:06:22,789 --> 00:06:27,200
that it's just an infinite sequence of

140
00:06:24,410 --> 00:06:28,880
system calls and that the problems is

141
00:06:27,200 --> 00:06:31,760
this approach is that it tends to find

142
00:06:28,880 --> 00:06:33,710
much more shallow box and it frequently

143
00:06:31,760 --> 00:06:35,870
doesn't provide reproducers so you can

144
00:06:33,710 --> 00:06:38,810
restart it with the same seed but if you

145
00:06:35,870 --> 00:06:41,900
run it for an hour the chances that you

146
00:06:38,810 --> 00:06:45,320
will trigger the same bug again our are

147
00:06:41,900 --> 00:06:47,239
close to zero it also doesn't help with

148
00:06:45,320 --> 00:06:49,930
regression test and every time you start

149
00:06:47,240 --> 00:06:52,960
from scratch and at the existent

150
00:06:49,930 --> 00:06:55,630
some issues with automations because for

151
00:06:52,960 --> 00:07:00,310
Colonel it's not as simple as as simple

152
00:06:55,630 --> 00:07:02,169
as a small batch script okay the

153
00:07:00,310 --> 00:07:04,660
question is how how can we apply this

154
00:07:02,169 --> 00:07:09,580
nice idea of coverage guided fastened to

155
00:07:04,660 --> 00:07:11,289
the kernel and it turned out to be not

156
00:07:09,580 --> 00:07:14,080
that simple there are several problems

157
00:07:11,289 --> 00:07:18,310
first of all what is an input a user

158
00:07:14,080 --> 00:07:21,659
space fuzzers usually consider input as

159
00:07:18,310 --> 00:07:24,610
a just an array of bytes some blob and

160
00:07:21,660 --> 00:07:26,740
which doesn't have any structure so how

161
00:07:24,610 --> 00:07:29,320
do you turn this blob into some load on

162
00:07:26,740 --> 00:07:34,630
the kernel and then how do you mutate

163
00:07:29,320 --> 00:07:37,060
this load on the kernel then userspace

164
00:07:34,630 --> 00:07:38,880
fuzzers usually usually assume that all

165
00:07:37,060 --> 00:07:42,430
inputs are completely isolated

166
00:07:38,880 --> 00:07:44,320
deterministic and reproducible so if you

167
00:07:42,430 --> 00:07:46,210
run the same program second time it yet

168
00:07:44,320 --> 00:07:48,099
exactly the same coverage and the same

169
00:07:46,210 --> 00:07:52,210
result and this is totally not true for

170
00:07:48,099 --> 00:07:55,599
kernel also for kernel we have enormous

171
00:07:52,210 --> 00:07:58,000
input space so one system pole can have

172
00:07:55,599 --> 00:08:00,370
input space that is similar to that of a

173
00:07:58,000 --> 00:08:02,169
typical user space puzzler

174
00:08:00,370 --> 00:08:04,599
and we have thousands of system calls

175
00:08:02,169 --> 00:08:06,039
and well-secured need to choose some set

176
00:08:04,599 --> 00:08:08,979
of them and execute in a particular

177
00:08:06,039 --> 00:08:11,320
order so I think input space is at least

178
00:08:08,979 --> 00:08:14,949
three orders of magnitude larger maybe

179
00:08:11,320 --> 00:08:17,830
even five or six then there are some

180
00:08:14,949 --> 00:08:20,740
issues with coverage user space fuzzers

181
00:08:17,830 --> 00:08:23,680
again assume that coverage is completely

182
00:08:20,740 --> 00:08:27,099
deterministic stable and the function of

183
00:08:23,680 --> 00:08:28,720
the input but it's not true for kernel

184
00:08:27,099 --> 00:08:31,050
because there are other processes there

185
00:08:28,720 --> 00:08:33,479
are background threads or interrupt

186
00:08:31,050 --> 00:08:36,969
sometimes kernel even contains some

187
00:08:33,479 --> 00:08:39,190
intentional non determinism and we'll

188
00:08:36,969 --> 00:08:41,620
get flakes from Malik and scheduler for

189
00:08:39,190 --> 00:08:43,779
example malloc on low memory can sorta

190
00:08:41,620 --> 00:08:46,089
do swapping and they call in the file

191
00:08:43,779 --> 00:08:49,209
system and we see all of these this kind

192
00:08:46,089 --> 00:08:51,820
of coverage for our input then there are

193
00:08:49,209 --> 00:08:53,800
issues other set of wishes for example

194
00:08:51,820 --> 00:08:56,110
if we create a pipe and try to read from

195
00:08:53,800 --> 00:08:58,329
it it will block because the pipe is

196
00:08:56,110 --> 00:09:01,870
empty so we don't want to like stall

197
00:08:58,329 --> 00:09:02,859
forever on this read now also provoking

198
00:09:01,870 --> 00:09:05,160
raises is import

199
00:09:02,860 --> 00:09:07,450
userspace fuzzers usually assume that

200
00:09:05,160 --> 00:09:10,270
multi-threading just doesn't exist that

201
00:09:07,450 --> 00:09:13,570
all programs the single threaded traces

202
00:09:10,270 --> 00:09:15,880
don'tdon't cows box and so on but the

203
00:09:13,570 --> 00:09:19,540
kernel is very important to also provoke

204
00:09:15,880 --> 00:09:22,480
races now there's a set of operational

205
00:09:19,540 --> 00:09:24,880
issues for example user space buzzer

206
00:09:22,480 --> 00:09:26,830
typically after triggering a crash it

207
00:09:24,880 --> 00:09:28,540
will save the input to disk but if the

208
00:09:26,830 --> 00:09:31,120
kernel underneath you just collapsed

209
00:09:28,540 --> 00:09:34,750
like you can do anything anymore maybe

210
00:09:31,120 --> 00:09:36,700
the image is destroyed as well and for

211
00:09:34,750 --> 00:09:39,130
example if you try to fasten if I see a

212
00:09:36,700 --> 00:09:40,810
new call reboot system call then it will

213
00:09:39,130 --> 00:09:41,890
appear as you can have crashed the

214
00:09:40,810 --> 00:09:43,839
machine but it's actually very

215
00:09:41,890 --> 00:09:46,720
intentional and reboot system call is

216
00:09:43,840 --> 00:09:49,980
very obvious instance of this but there

217
00:09:46,720 --> 00:09:54,460
are more and there are lots of more

218
00:09:49,980 --> 00:09:56,650
complex scenarios that has the same same

219
00:09:54,460 --> 00:10:01,810
outcome when you crash the kernel that's

220
00:09:56,650 --> 00:10:04,110
actually intentional orido's kernel okay

221
00:10:01,810 --> 00:10:09,459
so kernel fasten is different and took

222
00:10:04,110 --> 00:10:11,140
two key key takeaways one is that you

223
00:10:09,460 --> 00:10:14,080
need to be smart being smart becomes

224
00:10:11,140 --> 00:10:15,610
really important because both the input

225
00:10:14,080 --> 00:10:17,590
space is at least three orders of

226
00:10:15,610 --> 00:10:19,570
magnitude larger and your execution

227
00:10:17,590 --> 00:10:21,430
speed is at least three orders of

228
00:10:19,570 --> 00:10:23,800
magnitude slower because you need to

229
00:10:21,430 --> 00:10:26,709
create processes you do system calls you

230
00:10:23,800 --> 00:10:30,099
block on on blocking system calls and so

231
00:10:26,710 --> 00:10:31,900
on so six orders of magnitude at least

232
00:10:30,100 --> 00:10:33,940
and to give you kind of so they

233
00:10:31,900 --> 00:10:37,510
understand how how bad it is in user

234
00:10:33,940 --> 00:10:41,350
space you can get something like 100,000

235
00:10:37,510 --> 00:10:44,370
inputs per second tested so it's pretty

236
00:10:41,350 --> 00:10:47,110
good you can effort to say executive of

237
00:10:44,370 --> 00:10:49,180
inputs that completely nonsense and

238
00:10:47,110 --> 00:10:52,180
doesn't help you in any way and it's -

239
00:10:49,180 --> 00:10:54,370
you don't care but if you scale the

240
00:10:52,180 --> 00:10:57,160
sixers of magnitude to you now get one

241
00:10:54,370 --> 00:10:59,800
input per minute so you want to choose

242
00:10:57,160 --> 00:11:01,990
that one input very very very very

243
00:10:59,800 --> 00:11:04,660
carefully because you will be able to

244
00:11:01,990 --> 00:11:08,890
execute the next one on the next minute

245
00:11:04,660 --> 00:11:10,660
and the second thing is that the further

246
00:11:08,890 --> 00:11:12,370
needs to be best effort because you can

247
00:11:10,660 --> 00:11:15,730
get definitive answers for almost

248
00:11:12,370 --> 00:11:16,160
anything you can can understand does it

249
00:11:15,730 --> 00:11:19,160
give me

250
00:11:16,160 --> 00:11:21,319
coverage or even did it crash or is this

251
00:11:19,160 --> 00:11:25,480
program represents the same crash we

252
00:11:21,319 --> 00:11:30,250
seen here and the father a mystic and

253
00:11:25,480 --> 00:11:32,750
operate in this in this context still

254
00:11:30,250 --> 00:11:34,990
okay so this is the problem space now

255
00:11:32,750 --> 00:11:37,610
how we solved those problems

256
00:11:34,990 --> 00:11:39,680
first of all let's alter the input so

257
00:11:37,610 --> 00:11:41,569
what what we would want to have as an

258
00:11:39,680 --> 00:11:44,000
input for Colonel phasor is something

259
00:11:41,569 --> 00:11:47,019
like this and like AC program that

260
00:11:44,000 --> 00:11:49,850
executes some system calls right

261
00:11:47,019 --> 00:11:51,709
and initially women consider the

262
00:11:49,850 --> 00:11:54,319
possibility of taking user space phasor

263
00:11:51,709 --> 00:11:56,628
and then trying to compile as output as

264
00:11:54,319 --> 00:11:59,599
AC program and then execute that C

265
00:11:56,629 --> 00:12:01,519
program but we decided that's probably

266
00:11:59,600 --> 00:12:06,220
one bit too efficient because most of

267
00:12:01,519 --> 00:12:08,360
the time it will just want compile so we

268
00:12:06,220 --> 00:12:10,040
decided to go with the approach called

269
00:12:08,360 --> 00:12:11,389
structured files and construction

270
00:12:10,040 --> 00:12:13,339
facilities when the father actually

271
00:12:11,389 --> 00:12:17,660
knows about the structure of the input

272
00:12:13,339 --> 00:12:22,970
and can do you know much more sensible

273
00:12:17,660 --> 00:12:24,199
mutation of the input and we started

274
00:12:22,970 --> 00:12:26,660
with the system code description

275
00:12:24,199 --> 00:12:29,779
language which we now call sis length

276
00:12:26,660 --> 00:12:31,790
you can see example of the description

277
00:12:29,779 --> 00:12:35,389
on the slide and hopefully you can read

278
00:12:31,790 --> 00:12:38,060
it mostly and because those descriptions

279
00:12:35,389 --> 00:12:40,339
are similar to C function declarations

280
00:12:38,060 --> 00:12:42,410
so we say that there is an open system

281
00:12:40,339 --> 00:12:45,019
call which has first sir command file

282
00:12:42,410 --> 00:12:47,480
which is a pointer to file name and the

283
00:12:45,019 --> 00:12:50,269
second arguments and flags and returns a

284
00:12:47,480 --> 00:12:53,750
file descriptor and we can enumerate the

285
00:12:50,269 --> 00:12:55,639
values for the flags we can pass let me

286
00:12:53,750 --> 00:12:59,120
say there is a closed system call that

287
00:12:55,639 --> 00:13:01,130
accept the file descriptor so we would

288
00:12:59,120 --> 00:13:04,220
look we will look at more features of

289
00:13:01,130 --> 00:13:06,470
this language but question you may have

290
00:13:04,220 --> 00:13:09,380
now is why why don't we just reuse the

291
00:13:06,470 --> 00:13:12,110
existing C headers because they already

292
00:13:09,380 --> 00:13:14,540
contain rate definitions of those

293
00:13:12,110 --> 00:13:16,790
functions so there is a seller wishes

294
00:13:14,540 --> 00:13:19,250
for example file descriptor is usually

295
00:13:16,790 --> 00:13:21,740
described just as an integer rather well

296
00:13:19,250 --> 00:13:24,230
it's not exactly the integer it's quite

297
00:13:21,740 --> 00:13:26,240
special type of integer for us and most

298
00:13:24,230 --> 00:13:29,540
likely want to know that it's a file

299
00:13:26,240 --> 00:13:32,250
descriptor or constructs are

300
00:13:29,540 --> 00:13:33,780
you may guess that it's a string but

301
00:13:32,250 --> 00:13:35,820
what type of string is it this is the

302
00:13:33,780 --> 00:13:38,310
file system name is the crypto great

303
00:13:35,820 --> 00:13:41,160
name or is it a file name which is also

304
00:13:38,310 --> 00:13:44,099
quite special in the context of a system

305
00:13:41,160 --> 00:13:47,640
called phaser right and there are lots

306
00:13:44,100 --> 00:13:50,310
of things like this integer must be must

307
00:13:47,640 --> 00:13:54,060
specific size of that array or size of

308
00:13:50,310 --> 00:13:55,800
that object or some things that you just

309
00:13:54,060 --> 00:13:57,449
simply cannot describe and see for

310
00:13:55,800 --> 00:13:59,699
example if you have a variable size

311
00:13:57,450 --> 00:14:03,090
array inside of structure C can only

312
00:13:59,700 --> 00:14:04,680
describe statically aesthetic layout it

313
00:14:03,090 --> 00:14:08,580
can just describe something like a

314
00:14:04,680 --> 00:14:10,319
network packet format now other cases

315
00:14:08,580 --> 00:14:13,110
for example I hope the log write which

316
00:14:10,320 --> 00:14:14,940
is just accept a weight star but there's

317
00:14:13,110 --> 00:14:17,280
actually a like very interesting and

318
00:14:14,940 --> 00:14:20,280
complex feelings behind that void star

319
00:14:17,280 --> 00:14:22,380
there are more issue so if that would be

320
00:14:20,280 --> 00:14:24,990
just one of those things we may be trade

321
00:14:22,380 --> 00:14:28,830
over somehow work around that but

322
00:14:24,990 --> 00:14:31,290
because it's this whole set of issues we

323
00:14:28,830 --> 00:14:34,490
decided that it's just C see Heather's

324
00:14:31,290 --> 00:14:36,900
don't contain enough information for us

325
00:14:34,490 --> 00:14:39,270
okay let's look at other fishes one of

326
00:14:36,900 --> 00:14:41,939
the main features called resources and

327
00:14:39,270 --> 00:14:44,850
resources something that we need to pass

328
00:14:41,940 --> 00:14:47,490
from output of one system call to input

329
00:14:44,850 --> 00:14:51,030
of another system call and the best

330
00:14:47,490 --> 00:14:52,920
example of this is a file descriptor so

331
00:14:51,030 --> 00:14:54,660
the language allows you to describe is

332
00:14:52,920 --> 00:14:57,930
you say that there is a resource called

333
00:14:54,660 --> 00:15:00,270
FG and the base type for it is an int 32

334
00:14:57,930 --> 00:15:02,400
so if it's inside of a structure it will

335
00:15:00,270 --> 00:15:04,500
take 4 bytes and optionally you can

336
00:15:02,400 --> 00:15:07,470
specify a set of special values for this

337
00:15:04,500 --> 00:15:10,170
resource those values are something that

338
00:15:07,470 --> 00:15:12,090
father can use directly doesn't need to

339
00:15:10,170 --> 00:15:15,270
call other system calls to can obtain

340
00:15:12,090 --> 00:15:17,130
those those values and then we say that

341
00:15:15,270 --> 00:15:19,170
open system color returns this thing

342
00:15:17,130 --> 00:15:24,570
called FG and the closed system call

343
00:15:19,170 --> 00:15:26,160
accepts this thing called FD and we can

344
00:15:24,570 --> 00:15:28,230
describe more complex things in

345
00:15:26,160 --> 00:15:30,540
particular we have resource inheritance

346
00:15:28,230 --> 00:15:33,690
you can say that there is FG c d---rom

347
00:15:30,540 --> 00:15:36,839
which is which is FD but it's more

348
00:15:33,690 --> 00:15:39,990
specialized type of FF d and if you open

349
00:15:36,840 --> 00:15:42,120
this particular file the F slash cd-rom

350
00:15:39,990 --> 00:15:44,640
then this gives you not

351
00:15:42,120 --> 00:15:47,250
d but this more specialized type and

352
00:15:44,640 --> 00:15:49,350
then you can attach for example set of I

353
00:15:47,250 --> 00:15:54,330
hope those two this more specialized

354
00:15:49,350 --> 00:15:56,640
type okay we also can describe

355
00:15:54,330 --> 00:15:59,430
structures so for structure you you give

356
00:15:56,640 --> 00:16:01,319
it a name and on the Left we have field

357
00:15:59,430 --> 00:16:05,099
names and the right way of type so it's

358
00:16:01,320 --> 00:16:06,839
a swap from C you deal with it and for

359
00:16:05,100 --> 00:16:09,420
fuels we have such simple things that

360
00:16:06,839 --> 00:16:11,279
say integer but we also can describe

361
00:16:09,420 --> 00:16:14,670
some things that you cannot describe in

362
00:16:11,279 --> 00:16:16,650
C for example we can place in a variable

363
00:16:14,670 --> 00:16:18,930
size array inside in the middle of a

364
00:16:16,650 --> 00:16:21,569
structure so in this case it doesn't

365
00:16:18,930 --> 00:16:23,459
mean an interactions it's not a pointer

366
00:16:21,570 --> 00:16:26,760
to an array it's literally array within

367
00:16:23,460 --> 00:16:28,290
the within the structure itself and in

368
00:16:26,760 --> 00:16:30,540
this case frequently also have another

369
00:16:28,290 --> 00:16:32,699
field integer field that will contain

370
00:16:30,540 --> 00:16:34,589
the size of this array so that kernel

371
00:16:32,700 --> 00:16:40,440
can actually parse this structure and

372
00:16:34,589 --> 00:16:42,029
also can describe that as well so when

373
00:16:40,440 --> 00:16:43,470
we generate a particular instance of

374
00:16:42,029 --> 00:16:45,900
this structure as I said this will be

375
00:16:43,470 --> 00:16:50,100
just a single chunk of memory where we

376
00:16:45,900 --> 00:16:52,829
will have say for free integer first and

377
00:16:50,100 --> 00:16:57,660
then some number of elements for their

378
00:16:52,830 --> 00:16:59,850
race okay we also have support for

379
00:16:57,660 --> 00:17:01,560
unions and for unions important thing is

380
00:16:59,850 --> 00:17:03,630
that they are denoted by the square

381
00:17:01,560 --> 00:17:06,300
bracket where structured you know that

382
00:17:03,630 --> 00:17:09,829
by the curly brace so that's how you

383
00:17:06,300 --> 00:17:13,230
distinguish them you can use any any M

384
00:17:09,829 --> 00:17:15,119
and you can have several options and you

385
00:17:13,230 --> 00:17:18,120
can use any types for them so at runtime

386
00:17:15,119 --> 00:17:19,708
one of them will be chosen an

387
00:17:18,119 --> 00:17:21,479
interesting thing is this varlyn

388
00:17:19,709 --> 00:17:24,329
attribute which stands for variable

389
00:17:21,480 --> 00:17:27,150
length it's again an extensions for for

390
00:17:24,329 --> 00:17:29,850
C so if you don't specify this attribute

391
00:17:27,150 --> 00:17:33,390
then this Union will will work as a

392
00:17:29,850 --> 00:17:35,730
normal C Union which means that that the

393
00:17:33,390 --> 00:17:38,160
total size of the Union will be equal to

394
00:17:35,730 --> 00:17:40,290
the maximum size of all options and if

395
00:17:38,160 --> 00:17:42,840
you actually use smaller option that

396
00:17:40,290 --> 00:17:45,450
there will be some pageant at the end to

397
00:17:42,840 --> 00:17:48,300
the maximum size but if you specify this

398
00:17:45,450 --> 00:17:50,160
varlyn attribute then the dynamic size

399
00:17:48,300 --> 00:17:52,230
of the Union will be equal exactly to

400
00:17:50,160 --> 00:17:54,450
the option that we choose and there will

401
00:17:52,230 --> 00:17:55,250
no be there will be no pattern at the

402
00:17:54,450 --> 00:17:58,100
end

403
00:17:55,250 --> 00:18:01,580
this also used quite extensively for for

404
00:17:58,100 --> 00:18:03,500
kernel interfaces okay so let's look at

405
00:18:01,580 --> 00:18:05,720
an example how we can describe for

406
00:18:03,500 --> 00:18:07,760
example this thing let's say we want to

407
00:18:05,720 --> 00:18:10,250
describe mount system call and it

408
00:18:07,760 --> 00:18:13,160
accepts in particular stream which

409
00:18:10,250 --> 00:18:16,970
contains a set of arguments each of

410
00:18:13,160 --> 00:18:19,070
which has a name equals and the value of

411
00:18:16,970 --> 00:18:22,640
values can be different some arguments

412
00:18:19,070 --> 00:18:25,220
don't have failures so let's start

413
00:18:22,640 --> 00:18:27,610
bottom-up first of all we described UID

414
00:18:25,220 --> 00:18:31,070
option as a structure first field

415
00:18:27,610 --> 00:18:33,560
contains a string key ID equals then a

416
00:18:31,070 --> 00:18:36,550
second field contains UID resource

417
00:18:33,560 --> 00:18:39,169
formatted as a decimal number

418
00:18:36,550 --> 00:18:42,700
similarly we describe adoption which is

419
00:18:39,170 --> 00:18:46,430
uses the PD resource and similarly block

420
00:18:42,700 --> 00:18:48,440
options but here we use flex type which

421
00:18:46,430 --> 00:18:50,350
allows you to specify concrete values

422
00:18:48,440 --> 00:18:55,100
that are interesting for this particular

423
00:18:50,350 --> 00:18:58,060
variable and then weigh the option as a

424
00:18:55,100 --> 00:19:01,070
union of with all of our existing

425
00:18:58,060 --> 00:19:03,040
options and we use this varlyn attribute

426
00:19:01,070 --> 00:19:08,030
because we've done any button at the end

427
00:19:03,040 --> 00:19:09,290
and finally we describe option with coma

428
00:19:08,030 --> 00:19:11,720
which contains which is again a

429
00:19:09,290 --> 00:19:15,560
structure it contains our option Union

430
00:19:11,720 --> 00:19:17,240
and a coma byte after it and finally we

431
00:19:15,560 --> 00:19:19,850
can describe the mount system call as

432
00:19:17,240 --> 00:19:23,300
exception pointer to an array of such

433
00:19:19,850 --> 00:19:25,909
option with coma so you may not think as

434
00:19:23,300 --> 00:19:28,460
a of a string as an array of structures

435
00:19:25,910 --> 00:19:30,890
but why not we actually can describe it

436
00:19:28,460 --> 00:19:33,400
this way and this is descriptions will

437
00:19:30,890 --> 00:19:37,400
allow to generate at buzzer to generate

438
00:19:33,400 --> 00:19:39,560
strings that look like this with just

439
00:19:37,400 --> 00:19:41,720
this random number of arguments with

440
00:19:39,560 --> 00:19:46,550
random order of arguments with random

441
00:19:41,720 --> 00:19:48,950
values and so on okay and some other

442
00:19:46,550 --> 00:19:51,110
features have mentioned briefly well so

443
00:19:48,950 --> 00:19:54,830
we have plain integers we have constants

444
00:19:51,110 --> 00:19:57,110
we have flags which work like SIA noms

445
00:19:54,830 --> 00:20:00,949
we have ranged integers we have support

446
00:19:57,110 --> 00:20:02,870
for bid fields also big integer became

447
00:20:00,950 --> 00:20:06,140
10 integers and you can say for example

448
00:20:02,870 --> 00:20:06,929
something like in 32 which is beacon

449
00:20:06,140 --> 00:20:09,810
dancing

450
00:20:06,930 --> 00:20:12,570
into small bites but it's in the middle

451
00:20:09,810 --> 00:20:15,570
of a bit fields and only take 11 beats

452
00:20:12,570 --> 00:20:18,750
and for the values we want values in the

453
00:20:15,570 --> 00:20:21,960
range from 100 to 200 with a step 3sl

454
00:20:18,750 --> 00:20:24,090
100 hundred 306 so it's a bit of an

455
00:20:21,960 --> 00:20:25,950
extreme example but all those features

456
00:20:24,090 --> 00:20:30,780
are composable and and you can write

457
00:20:25,950 --> 00:20:34,110
this OCS have fixed size erase range

458
00:20:30,780 --> 00:20:37,860
size erase we have structures at the

459
00:20:34,110 --> 00:20:39,629
park the line pad that we can say that

460
00:20:37,860 --> 00:20:42,300
this integer is the length of that array

461
00:20:39,630 --> 00:20:44,520
of size of that object and bytes or size

462
00:20:42,300 --> 00:20:48,030
of that objects and for byte units or in

463
00:20:44,520 --> 00:20:51,350
beads and we even have templates and

464
00:20:48,030 --> 00:20:56,220
with templates also get the voit type

465
00:20:51,350 --> 00:20:59,189
and some other features okay so this for

466
00:20:56,220 --> 00:21:01,950
descriptions the next thing is programs

467
00:20:59,190 --> 00:21:03,360
and programs is what actually represent

468
00:21:01,950 --> 00:21:05,700
an input and our phaser

469
00:21:03,360 --> 00:21:10,229
so that's what we rotate that's what we

470
00:21:05,700 --> 00:21:11,940
add to the corpus and program is what

471
00:21:10,230 --> 00:21:13,980
you what you may expect it is it is a

472
00:21:11,940 --> 00:21:18,750
sequence of system calls with concrete

473
00:21:13,980 --> 00:21:21,450
values for arguments so for pointers we

474
00:21:18,750 --> 00:21:23,970
have have chosen exact addresses of

475
00:21:21,450 --> 00:21:25,860
integers which using exact values and so

476
00:21:23,970 --> 00:21:28,110
on and here you can see how resources

477
00:21:25,860 --> 00:21:31,939
work and why we bother to describe them

478
00:21:28,110 --> 00:21:34,889
so we have notion of local variables and

479
00:21:31,940 --> 00:21:41,160
open returns NFD we assign it to a local

480
00:21:34,890 --> 00:21:43,500
variable 0 and then later we use it okay

481
00:21:41,160 --> 00:21:45,960
so if descriptions is something that you

482
00:21:43,500 --> 00:21:48,390
write and you give it to the father then

483
00:21:45,960 --> 00:21:50,340
programs they are manipulated by the

484
00:21:48,390 --> 00:21:52,170
father itself normally you don't you

485
00:21:50,340 --> 00:21:54,689
don't write them and you don't even see

486
00:21:52,170 --> 00:21:56,760
them because based on the description

487
00:21:54,690 --> 00:21:58,800
father can generate the programs from

488
00:21:56,760 --> 00:22:01,650
scratch it can also mutate existing

489
00:21:58,800 --> 00:22:03,450
programs it can also minimize programs

490
00:22:01,650 --> 00:22:05,640
for example does it does this minimize

491
00:22:03,450 --> 00:22:07,710
programs to give still gives the same

492
00:22:05,640 --> 00:22:10,890
new coverage or does it still crash the

493
00:22:07,710 --> 00:22:12,540
kernel or we can do some analysis on the

494
00:22:10,890 --> 00:22:14,850
program we can also interpret the

495
00:22:12,540 --> 00:22:17,970
program or execute actually execute the

496
00:22:14,850 --> 00:22:20,129
system calls and we can also convert

497
00:22:17,970 --> 00:22:22,080
them to more or less equivalence

498
00:22:20,130 --> 00:22:24,030
programs and we can serialize and

499
00:22:22,080 --> 00:22:26,909
deserialize them to such text

500
00:22:24,030 --> 00:22:28,830
representation so let's look at some of

501
00:22:26,910 --> 00:22:31,170
the mutations because we're we have lots

502
00:22:28,830 --> 00:22:35,340
of information about the structure we

503
00:22:31,170 --> 00:22:37,050
can do very smart mutations so for

504
00:22:35,340 --> 00:22:40,169
example we can insert or remove new

505
00:22:37,050 --> 00:22:43,460
system calls or we can change a

506
00:22:40,170 --> 00:22:45,720
particular argument and we do this

507
00:22:43,460 --> 00:22:47,880
having the knowledge about the the type

508
00:22:45,720 --> 00:22:50,490
of this concrete argument so we can

509
00:22:47,880 --> 00:22:54,480
change size of an array so we can change

510
00:22:50,490 --> 00:22:56,730
options and unions we can you know

511
00:22:54,480 --> 00:23:00,990
generate a file name knowing that this

512
00:22:56,730 --> 00:23:03,120
is file name and so on if there are any

513
00:23:00,990 --> 00:23:05,760
blobs involve we also use traditional

514
00:23:03,120 --> 00:23:09,030
mutations of blobs like flip and bite so

515
00:23:05,760 --> 00:23:11,850
in certain or flipping bit so inserting

516
00:23:09,030 --> 00:23:13,800
or removing bytes and we can also do

517
00:23:11,850 --> 00:23:15,750
splice enough programs on system called

518
00:23:13,800 --> 00:23:18,240
levels so splicing is when you take two

519
00:23:15,750 --> 00:23:20,910
programs or some subset of system calls

520
00:23:18,240 --> 00:23:23,700
and you merge them in some way and we do

521
00:23:20,910 --> 00:23:26,660
this based on resources the resources

522
00:23:23,700 --> 00:23:29,760
help to first of all choose the program

523
00:23:26,660 --> 00:23:31,200
say this program works with its socket

524
00:23:29,760 --> 00:23:33,780
so we probably want to take another

525
00:23:31,200 --> 00:23:36,990
program that that makes them use of TCP

526
00:23:33,780 --> 00:23:38,840
socket to stew splice and also helps to

527
00:23:36,990 --> 00:23:41,880
sell at system calls that we want to

528
00:23:38,840 --> 00:23:44,220
nurse for example if we take a set so

529
00:23:41,880 --> 00:23:45,990
called system called we probably also

530
00:23:44,220 --> 00:23:51,420
want to take the Soviet system call that

531
00:23:45,990 --> 00:23:55,350
creates that Soviet as well okay so this

532
00:23:51,420 --> 00:23:59,640
is descriptions help help being smarter

533
00:23:55,350 --> 00:24:01,290
but another part is prioritization the

534
00:23:59,640 --> 00:24:04,890
thing is that the whole search space is

535
00:24:01,290 --> 00:24:07,290
enormous but actually the interesting

536
00:24:04,890 --> 00:24:09,690
part of that search space is very tiny

537
00:24:07,290 --> 00:24:11,940
and this the part that actually will

538
00:24:09,690 --> 00:24:13,680
give any meaningful coverage because the

539
00:24:11,940 --> 00:24:17,490
majority will just bail out immediately

540
00:24:13,680 --> 00:24:20,160
and if it just sample this this whole

541
00:24:17,490 --> 00:24:22,200
large space uniformly then most likely

542
00:24:20,160 --> 00:24:23,850
will test and not interesting programs

543
00:24:22,200 --> 00:24:25,950
all the times actually what you want to

544
00:24:23,850 --> 00:24:28,919
aim this this small part that is

545
00:24:25,950 --> 00:24:30,810
interesting so for this we use

546
00:24:28,920 --> 00:24:33,059
prioritization throughout the fuzzer

547
00:24:30,810 --> 00:24:35,639
for example when we choose a probe

548
00:24:33,059 --> 00:24:38,009
from a corpus will look at its

549
00:24:35,639 --> 00:24:40,229
complexity and coverage for example you

550
00:24:38,009 --> 00:24:42,600
may have an one program with just one

551
00:24:40,230 --> 00:24:45,450
system call for example shed yield which

552
00:24:42,600 --> 00:24:47,699
doesn't accept any arguments and we have

553
00:24:45,450 --> 00:24:50,639
another program with ten system calls

554
00:24:47,700 --> 00:24:53,129
with complex arguments right we want to

555
00:24:50,639 --> 00:24:55,229
rotate both of them but we want to drive

556
00:24:53,129 --> 00:24:58,769
more mutations so that more complex and

557
00:24:55,230 --> 00:25:00,929
larger program also when we choose

558
00:24:58,769 --> 00:25:03,090
mutation action for example do we want

559
00:25:00,929 --> 00:25:04,950
to insert the call or remove a call or

560
00:25:03,090 --> 00:25:07,889
change an argument there are some

561
00:25:04,950 --> 00:25:10,409
priorities for example it turns out that

562
00:25:07,889 --> 00:25:12,508
it's much more profitable to insert

563
00:25:10,409 --> 00:25:15,179
system call rather than remove removing

564
00:25:12,509 --> 00:25:21,509
a system call can give some use some new

565
00:25:15,179 --> 00:25:23,669
behaviors but usually it doesn't also

566
00:25:21,509 --> 00:25:26,090
when we uncertain a new system call will

567
00:25:23,669 --> 00:25:28,409
have set of set of priorities for this

568
00:25:26,090 --> 00:25:31,980
first of all we'll look at argument

569
00:25:28,409 --> 00:25:33,570
complexity again we may have shed yield

570
00:25:31,980 --> 00:25:36,059
system call which doesn't have any

571
00:25:33,570 --> 00:25:38,100
arguments and another system call with

572
00:25:36,059 --> 00:25:41,519
with very complex arguments and watch

573
00:25:38,100 --> 00:25:43,350
such space so we want to test both but

574
00:25:41,519 --> 00:25:45,210
again we want a drive can't even test

575
00:25:43,350 --> 00:25:48,509
drive tests and towards that more

576
00:25:45,210 --> 00:25:50,820
complex system call we also look at the

577
00:25:48,509 --> 00:25:52,470
static relations between system calls if

578
00:25:50,820 --> 00:25:54,418
you have a program that works with the

579
00:25:52,470 --> 00:25:56,549
circuits we probably want to add another

580
00:25:54,419 --> 00:26:00,929
system call that works circuits rather

581
00:25:56,549 --> 00:26:03,749
than say with a file system and we learn

582
00:26:00,929 --> 00:26:06,179
some dynamic relations which is similar

583
00:26:03,749 --> 00:26:08,249
to reinforcement learning for example we

584
00:26:06,179 --> 00:26:11,159
notice that in corpus those two system

585
00:26:08,249 --> 00:26:13,169
calls frequently appear together we

586
00:26:11,159 --> 00:26:15,360
don't know why they appear together but

587
00:26:13,169 --> 00:26:17,519
we just see that like there's there's

588
00:26:15,360 --> 00:26:20,549
must be some relation between them so if

589
00:26:17,519 --> 00:26:23,340
we see that we start also inserting

590
00:26:20,549 --> 00:26:28,529
those two system calls into programs

591
00:26:23,340 --> 00:26:30,990
more frequently when we select argument

592
00:26:28,529 --> 00:26:35,840
for mutations where again we have some

593
00:26:30,990 --> 00:26:39,179
objective criteria which is based on the

594
00:26:35,840 --> 00:26:43,289
know the main space of this argument for

595
00:26:39,179 --> 00:26:45,230
example we have in 8 and in 64 and right

596
00:26:43,289 --> 00:26:48,020
we want to mutate in 64

597
00:26:45,230 --> 00:26:50,900
just because there's much more Elias to

598
00:26:48,020 --> 00:26:52,730
try and also have some some subjective

599
00:26:50,900 --> 00:26:56,929
criteria which is based on heuristics

600
00:26:52,730 --> 00:26:59,809
for example we noticed that changing

601
00:26:56,929 --> 00:27:01,850
exact values of PO enters it usually

602
00:26:59,809 --> 00:27:04,309
doesn't provoke any new behaviors and

603
00:27:01,850 --> 00:27:08,030
usually doesn't trigger box so initially

604
00:27:04,309 --> 00:27:10,280
we assume that it's important but later

605
00:27:08,030 --> 00:27:12,649
turned out that it's not too important

606
00:27:10,280 --> 00:27:15,889
so we started doing doing this mutation

607
00:27:12,650 --> 00:27:18,140
less frequently and when we generate a

608
00:27:15,890 --> 00:27:19,910
bit change a particular argument type

609
00:27:18,140 --> 00:27:21,260
will set up lots of heuristics for

610
00:27:19,910 --> 00:27:25,130
example if it's a resource how

611
00:27:21,260 --> 00:27:27,410
frequently pass - one for FGM or if you

612
00:27:25,130 --> 00:27:29,030
have an in how frequently use zero value

613
00:27:27,410 --> 00:27:31,040
which is kind of special so you want to

614
00:27:29,030 --> 00:27:34,610
use it more than than all other values

615
00:27:31,040 --> 00:27:36,610
but right with you need to choose some

616
00:27:34,610 --> 00:27:39,590
some probability for this

617
00:27:36,610 --> 00:27:45,010
so this prioritization is you threw out

618
00:27:39,590 --> 00:27:47,418
the father on on multiple levels ok

619
00:27:45,010 --> 00:27:49,460
broken system calls I mentioned if you

620
00:27:47,419 --> 00:27:51,350
if you say create a pipe and I try to

621
00:27:49,460 --> 00:27:54,080
read from this pipe this little blob

622
00:27:51,350 --> 00:27:55,459
because the pipe is empty but later you

623
00:27:54,080 --> 00:27:57,260
may have a call that that actually

624
00:27:55,460 --> 00:27:59,450
writes to the pipe and this right woman

625
00:27:57,260 --> 00:28:01,760
would unblock the rate if we execute it

626
00:27:59,450 --> 00:28:04,640
so here we want two things one we want

627
00:28:01,760 --> 00:28:06,980
to get past the read in some way and

628
00:28:04,640 --> 00:28:09,470
second we actually want to execute this

629
00:28:06,980 --> 00:28:11,120
unblock Ian's pattern in the read and

630
00:28:09,470 --> 00:28:14,750
collect the coverage from it because

631
00:28:11,120 --> 00:28:17,870
most likely this path from unblocking is

632
00:28:14,750 --> 00:28:22,250
different from the pass when you go for

633
00:28:17,870 --> 00:28:25,070
read without blocking so what we do is

634
00:28:22,250 --> 00:28:27,740
pretty simple we encode Fred attacks

635
00:28:25,070 --> 00:28:31,040
acute mode we dispatch each system

636
00:28:27,740 --> 00:28:32,960
called a separate worker Fred and if we

637
00:28:31,040 --> 00:28:34,580
see that and we have some time out if we

638
00:28:32,960 --> 00:28:36,590
see that the system call doesn't return

639
00:28:34,580 --> 00:28:39,350
after that timeout we consider that it

640
00:28:36,590 --> 00:28:41,928
blocked and which is dispatch the next

641
00:28:39,350 --> 00:28:44,059
system call to another worker Fred but

642
00:28:41,929 --> 00:28:45,830
we still look further for the previous

643
00:28:44,059 --> 00:28:48,320
system call and if that read waiter

644
00:28:45,830 --> 00:28:50,059
returns then we still collect the

645
00:28:48,320 --> 00:28:53,870
coverage from it and handle and

646
00:28:50,059 --> 00:28:56,030
understand that it was unblocked so no

647
00:28:53,870 --> 00:28:58,939
rocket science here but more interesting

648
00:28:56,030 --> 00:29:04,460
thing is called collide mode and it how

649
00:28:58,940 --> 00:29:05,150
to provoke data races so it works in the

650
00:29:04,460 --> 00:29:07,250
following way

651
00:29:05,150 --> 00:29:11,840
we simply consider that every second

652
00:29:07,250 --> 00:29:13,970
system call is blocked right away let's

653
00:29:11,840 --> 00:29:16,669
look at the following program so we

654
00:29:13,970 --> 00:29:18,350
start executing first open we dispatch

655
00:29:16,670 --> 00:29:19,790
it thread and then we immediately

656
00:29:18,350 --> 00:29:22,070
consider that it's blocked and

657
00:29:19,790 --> 00:29:24,409
immediately start the second one so we

658
00:29:22,070 --> 00:29:28,310
start the two opens at roughly the same

659
00:29:24,410 --> 00:29:30,590
time then we wait for the second of the

660
00:29:28,310 --> 00:29:33,620
system calls and then we again dispatch

661
00:29:30,590 --> 00:29:36,320
next to system calls almost together and

662
00:29:33,620 --> 00:29:38,929
this potentially may help provoke the

663
00:29:36,320 --> 00:29:41,240
race between those system calls this

664
00:29:38,930 --> 00:29:45,550
pretty simple strategy but it helped us

665
00:29:41,240 --> 00:29:45,550
to find lots and lots of races already

666
00:29:46,540 --> 00:29:51,560
then the next feature related execution

667
00:29:49,700 --> 00:29:54,530
is fault injection fault injection is

668
00:29:51,560 --> 00:29:56,629
when you specifically fail some things

669
00:29:54,530 --> 00:30:00,350
for the purposes of testing error

670
00:29:56,630 --> 00:30:02,540
handling pass you can fail malloc you

671
00:30:00,350 --> 00:30:05,719
can fail I operations some other things

672
00:30:02,540 --> 00:30:07,820
and it's actually a meaningful for

673
00:30:05,720 --> 00:30:10,280
kernel so lots of user most of user

674
00:30:07,820 --> 00:30:13,399
space programs even if they try to

675
00:30:10,280 --> 00:30:15,230
handle out of memory usually that's not

676
00:30:13,400 --> 00:30:17,990
tested and usually they they simply

677
00:30:15,230 --> 00:30:19,820
crash but the kernel actually needs to

678
00:30:17,990 --> 00:30:22,610
survive it means to survive low memory

679
00:30:19,820 --> 00:30:25,550
conditions and needs to survive hardware

680
00:30:22,610 --> 00:30:28,969
failures and so on and it turns out that

681
00:30:25,550 --> 00:30:31,040
since kernel is written in C with man

682
00:30:28,970 --> 00:30:33,530
our source management approximately one

683
00:30:31,040 --> 00:30:36,550
third of kernel code is actually error

684
00:30:33,530 --> 00:30:42,470
handling paths and they're specifically

685
00:30:36,550 --> 00:30:44,360
tested very very well almost untested

686
00:30:42,470 --> 00:30:46,280
and most of them contain box like use of

687
00:30:44,360 --> 00:30:48,290
the free and double freeze because that

688
00:30:46,280 --> 00:30:52,910
that's a pass when you actually enough

689
00:30:48,290 --> 00:30:55,870
free things and so on so there was

690
00:30:52,910 --> 00:30:55,870
existent Fulton

691
00:30:58,050 --> 00:31:01,790
I stopped working

692
00:31:10,740 --> 00:31:19,150
it's just thank you

693
00:31:15,299 --> 00:31:21,250
sorry so there was old fault injection

694
00:31:19,150 --> 00:31:23,170
vessels in the kernel and it worked in

695
00:31:21,250 --> 00:31:25,780
the following way he just can just ask

696
00:31:23,170 --> 00:31:29,110
kernel to fail its percent of potential

697
00:31:25,780 --> 00:31:33,399
failure sites for example say fail 1% of

698
00:31:29,110 --> 00:31:35,678
things this approach will both fail

699
00:31:33,400 --> 00:31:37,240
things that we don't want to fail and it

700
00:31:35,679 --> 00:31:39,880
will not necessary fail the things we

701
00:31:37,240 --> 00:31:41,380
want to fail and it just doesn't tell us

702
00:31:39,880 --> 00:31:43,960
to understand how well we actually

703
00:31:41,380 --> 00:31:45,580
tested the kernel so we did a slightly

704
00:31:43,960 --> 00:31:49,780
different thing we did what we call

705
00:31:45,580 --> 00:31:52,178
systematic systematic fault injection it

706
00:31:49,780 --> 00:31:56,168
has two two primitives one you can ask

707
00:31:52,179 --> 00:31:59,710
kernel to fail the next and failure site

708
00:31:56,169 --> 00:32:01,870
in the current fret and the second thing

709
00:31:59,710 --> 00:32:05,380
you can ask Colonel if the failure was

710
00:32:01,870 --> 00:32:07,149
injected and this can be used in the

711
00:32:05,380 --> 00:32:09,940
following way let's say we we see new

712
00:32:07,150 --> 00:32:11,919
coverage on some system call so what we

713
00:32:09,940 --> 00:32:14,380
do with then execute this program again

714
00:32:11,919 --> 00:32:19,630
and was kernel to fail first failure

715
00:32:14,380 --> 00:32:22,690
site in this system call then if the

716
00:32:19,630 --> 00:32:25,059
failure was injected then we execute

717
00:32:22,690 --> 00:32:27,429
this program again and but now asked to

718
00:32:25,059 --> 00:32:30,100
fail the second failure site in the

719
00:32:27,429 --> 00:32:32,080
system call again if it was injected we

720
00:32:30,100 --> 00:32:34,270
try to fail the third side and so on

721
00:32:32,080 --> 00:32:36,668
until we actually kernel says the

722
00:32:34,270 --> 00:32:39,520
failure wasn't injected which means that

723
00:32:36,669 --> 00:32:41,799
we tested all error paths in the system

724
00:32:39,520 --> 00:32:46,000
called one by one and since we do this

725
00:32:41,799 --> 00:32:47,770
when now we will get new coverage the

726
00:32:46,000 --> 00:32:50,169
expectation is that we actually tested

727
00:32:47,770 --> 00:32:53,440
all our paths and in the whole code that

728
00:32:50,169 --> 00:32:55,870
we ever covered so this mode works much

729
00:32:53,440 --> 00:32:57,790
better and actually like with a minimum

730
00:32:55,870 --> 00:33:00,070
number of iterations that allow you to

731
00:32:57,790 --> 00:33:04,230
to have some understanding that they

732
00:33:00,070 --> 00:33:04,230
actually tested all all possible cases

733
00:33:04,980 --> 00:33:09,610
okay coverage so for coverage we use

734
00:33:07,630 --> 00:33:13,540
compiler instrumentation is supported

735
00:33:09,610 --> 00:33:15,790
both by GCN alluvium and compiler

736
00:33:13,540 --> 00:33:18,428
inserts a function call into every basic

737
00:33:15,790 --> 00:33:21,610
block of code basic block is roughly

738
00:33:18,429 --> 00:33:26,260
piece of code without branches

739
00:33:21,610 --> 00:33:29,290
and the rest happens in the runtime so

740
00:33:26,260 --> 00:33:31,510
we have buffer that is shared between

741
00:33:29,290 --> 00:33:36,220
kernel and user space and this buffer

742
00:33:31,510 --> 00:33:39,070
contains a trace of traces kernel code

743
00:33:36,220 --> 00:33:41,260
execution so the first word of this

744
00:33:39,070 --> 00:33:43,750
buffer contains number of subsequent

745
00:33:41,260 --> 00:33:47,260
element and elements in the trace buffer

746
00:33:43,750 --> 00:33:50,620
and the Romanian elements at the program

747
00:33:47,260 --> 00:33:53,679
counters from the kernel so the kernel

748
00:33:50,620 --> 00:33:55,840
the kernel coverage callback does two

749
00:33:53,679 --> 00:33:59,350
things first of all it increments the

750
00:33:55,840 --> 00:34:02,470
first word and it adds the current PC to

751
00:33:59,350 --> 00:34:04,389
the end of the trace buffer and the user

752
00:34:02,470 --> 00:34:06,160
space can do two things first of all it

753
00:34:04,390 --> 00:34:08,350
can write zero to the first element

754
00:34:06,160 --> 00:34:10,000
which will effectively reset the

755
00:34:08,350 --> 00:34:12,368
coverage because then the kernel will

756
00:34:10,000 --> 00:34:15,129
continue again fill in this buffer from

757
00:34:12,369 --> 00:34:19,980
the beginning and it can read the

758
00:34:15,129 --> 00:34:19,980
current currently filled part and use it

759
00:34:20,760 --> 00:34:25,690
so a few things to note first of all

760
00:34:23,050 --> 00:34:28,389
this is per fret so the the the tracing

761
00:34:25,690 --> 00:34:31,149
happens a fret but you can set up those

762
00:34:28,389 --> 00:34:34,659
buffers for multiple threads

763
00:34:31,149 --> 00:34:36,759
independently interrupts are in

764
00:34:34,659 --> 00:34:38,470
completely ignored with on trace them

765
00:34:36,760 --> 00:34:41,530
only trace the the currently executing

766
00:34:38,469 --> 00:34:44,259
system call and some parts of the kernel

767
00:34:41,530 --> 00:34:46,320
are not instrumented for coverage for

768
00:34:44,260 --> 00:34:49,450
example memory allocator and scheduler

769
00:34:46,320 --> 00:34:51,580
so this helps so this organization is

770
00:34:49,449 --> 00:34:55,029
quite efficient because don't need to do

771
00:34:51,580 --> 00:34:56,710
any system calls to start tracing start

772
00:34:55,030 --> 00:34:59,800
collecting coverage finish collecting

773
00:34:56,710 --> 00:35:02,740
coverage user stays can just directly

774
00:34:59,800 --> 00:35:05,380
read the buffer and also it helps some

775
00:35:02,740 --> 00:35:07,569
of the flakes because we ignore

776
00:35:05,380 --> 00:35:10,300
interrupts ignore schedulers the flex is

777
00:35:07,570 --> 00:35:12,040
some coverage that you see on on when

778
00:35:10,300 --> 00:35:14,470
you execute a system call but then you

779
00:35:12,040 --> 00:35:17,290
execute the next time and you don't see

780
00:35:14,470 --> 00:35:20,439
this coverage and this is a problem for

781
00:35:17,290 --> 00:35:22,600
kernel and kick off doesn't doesn't

782
00:35:20,440 --> 00:35:26,200
completely solve it so we have another

783
00:35:22,600 --> 00:35:29,680
logical layer on top doom to remove more

784
00:35:26,200 --> 00:35:33,899
flakes in userspace you usually have a

785
00:35:29,680 --> 00:35:36,569
concept of corpus coverage so it's a

786
00:35:33,900 --> 00:35:38,190
union of coverage of all inputs in the

787
00:35:36,569 --> 00:35:41,279
corpus and that's what you use to

788
00:35:38,190 --> 00:35:44,670
understand if current input gives you

789
00:35:41,280 --> 00:35:47,640
new coverage on top of it so first of

790
00:35:44,670 --> 00:35:50,880
all we don't have one coverage we have

791
00:35:47,640 --> 00:35:53,040
now max coverage and min coverage so if

792
00:35:50,880 --> 00:35:55,069
we get some coverage within the max

793
00:35:53,040 --> 00:35:58,349
coverage then this is not new we just

794
00:35:55,069 --> 00:36:00,089
immediately discard those inputs but if

795
00:35:58,349 --> 00:36:02,579
we have something that that is this new

796
00:36:00,089 --> 00:36:04,020
coverage on top of max coverage then at

797
00:36:02,579 --> 00:36:07,130
this point this may be something

798
00:36:04,020 --> 00:36:10,550
interesting maybe we get new coverage

799
00:36:07,130 --> 00:36:13,559
but it still doesn't mean that that it's

800
00:36:10,550 --> 00:36:16,710
necessary new coverage because it may be

801
00:36:13,559 --> 00:36:18,780
just flakes we want to ensure that we

802
00:36:16,710 --> 00:36:20,609
actually can get reliable coverage so

803
00:36:18,780 --> 00:36:23,849
what we do it then executes the system

804
00:36:20,609 --> 00:36:26,160
call again several times and we see what

805
00:36:23,849 --> 00:36:28,530
coverage we get so and we remove the

806
00:36:26,160 --> 00:36:30,629
parts that we that that were flakes that

807
00:36:28,530 --> 00:36:32,880
we didn't get on the next subsequent

808
00:36:30,630 --> 00:36:34,589
iterations potentially we will remove

809
00:36:32,880 --> 00:36:36,869
all of the new coverage and then we will

810
00:36:34,589 --> 00:36:41,328
say ok all new coverage is actually

811
00:36:36,869 --> 00:36:41,329
flake so it's not not the new coverage

812
00:36:42,170 --> 00:36:47,609
in that case we'll throw the input away

813
00:36:45,240 --> 00:36:49,379
otherwise if we still if even after

814
00:36:47,609 --> 00:36:51,630
several iterations we still see that

815
00:36:49,380 --> 00:36:56,160
we're getting new coverage at that point

816
00:36:51,630 --> 00:36:57,990
only we added to the corpus but in our

817
00:36:56,160 --> 00:37:00,420
case we added to the max coverage

818
00:36:57,990 --> 00:37:02,578
because we seen this coverage and we

819
00:37:00,420 --> 00:37:07,440
don't want to handle this flake again

820
00:37:02,579 --> 00:37:09,390
and future okay so this is it for

821
00:37:07,440 --> 00:37:09,809
implementation now the question you may

822
00:37:09,390 --> 00:37:13,230
have

823
00:37:09,809 --> 00:37:17,329
does it work and is all of all of this

824
00:37:13,230 --> 00:37:20,250
complexity worth it and I can say oh yes

825
00:37:17,329 --> 00:37:22,849
so this is just one one randomly picked

826
00:37:20,250 --> 00:37:25,680
example on the left you can see the

827
00:37:22,849 --> 00:37:28,200
random program that the father generated

828
00:37:25,680 --> 00:37:31,950
it tried open some device and then also

829
00:37:28,200 --> 00:37:35,250
my octo on the left you can see a son

830
00:37:31,950 --> 00:37:37,618
out of bounds report similar to what you

831
00:37:35,250 --> 00:37:40,890
usually see in userspace with with a

832
00:37:37,619 --> 00:37:45,119
cold trace location stack and freed

833
00:37:40,890 --> 00:37:46,900
stack so when we when I implemented the

834
00:37:45,119 --> 00:37:48,910
father all the basic parts

835
00:37:46,900 --> 00:37:51,250
we started getting box and then as we

836
00:37:48,910 --> 00:37:53,620
made it more smart and where that more

837
00:37:51,250 --> 00:37:54,520
descriptions we started started getting

838
00:37:53,620 --> 00:37:57,310
even more box

839
00:37:54,520 --> 00:37:59,680
and at some point was heard given so

840
00:37:57,310 --> 00:38:02,980
many box that my full-time job become

841
00:37:59,680 --> 00:38:05,620
just sending back reports so which way I

842
00:38:02,980 --> 00:38:07,750
see it every day and just entered emails

843
00:38:05,620 --> 00:38:10,359
composed like this is the this is the

844
00:38:07,750 --> 00:38:12,790
crash this represent and that commit

845
00:38:10,360 --> 00:38:16,240
find the people to send it and send it

846
00:38:12,790 --> 00:38:18,430
and I did it literally for months so

847
00:38:16,240 --> 00:38:24,520
initially it was fun but soon it stopped

848
00:38:18,430 --> 00:38:27,430
being fun I reported about 500 bucks at

849
00:38:24,520 --> 00:38:35,620
which point I decided that we probably

850
00:38:27,430 --> 00:38:37,210
need to somehow solve it okay and we

851
00:38:35,620 --> 00:38:39,279
build a system called sis bot which

852
00:38:37,210 --> 00:38:41,260
automates which provides even higher

853
00:38:39,280 --> 00:38:43,150
level automation on top of the father

854
00:38:41,260 --> 00:38:45,460
so there's several things it does

855
00:38:43,150 --> 00:38:47,500
continuous kernel build it also does

856
00:38:45,460 --> 00:38:51,210
continuous this caller builds updates

857
00:38:47,500 --> 00:38:53,560
both and then it serves fuzzy and

858
00:38:51,210 --> 00:38:55,930
Fuzzy's include cells deduplication

859
00:38:53,560 --> 00:38:59,799
reports embolization and other things

860
00:38:55,930 --> 00:39:02,740
some point it finds a bug and maybe even

861
00:38:59,800 --> 00:39:05,260
a reproducer for this bug if you get a

862
00:39:02,740 --> 00:39:07,660
rep reducer we can do by section and

863
00:39:05,260 --> 00:39:09,820
then we can report the bug will find the

864
00:39:07,660 --> 00:39:12,759
people to send this bug report we can

865
00:39:09,820 --> 00:39:16,450
post actual email text and we send it to

866
00:39:12,760 --> 00:39:19,360
the kernel mailing list then it will

867
00:39:16,450 --> 00:39:21,819
occur on all developer may ask bottom

868
00:39:19,360 --> 00:39:26,230
sis both the tested potential fix for

869
00:39:21,820 --> 00:39:28,330
this bug and it can also say that this

870
00:39:26,230 --> 00:39:30,310
bug is fixed by a particular commit and

871
00:39:28,330 --> 00:39:33,190
developers do this by including a

872
00:39:30,310 --> 00:39:35,140
special tag into in the commit message

873
00:39:33,190 --> 00:39:38,290
which says that this commit fixes that

874
00:39:35,140 --> 00:39:39,940
sees both back at this point sees both

875
00:39:38,290 --> 00:39:42,430
will understand that there is a fix for

876
00:39:39,940 --> 00:39:44,550
that bug and it will wait when this

877
00:39:42,430 --> 00:39:47,799
weeks actually reaches all of the bills

878
00:39:44,550 --> 00:39:49,990
that we have and when we have it in our

879
00:39:47,800 --> 00:39:51,880
bills we know that this crash will not

880
00:39:49,990 --> 00:39:55,839
happen anymore and at this point will

881
00:39:51,880 --> 00:39:58,360
close the bug was a few potential

882
00:39:55,840 --> 00:40:00,200
alternative paths one is that developer

883
00:39:58,360 --> 00:40:02,210
may say that this book is the

884
00:40:00,200 --> 00:40:07,359
blicket of that other book or this book

885
00:40:02,210 --> 00:40:09,740
is invalid or if we can do fix bisection

886
00:40:07,359 --> 00:40:13,790
for example even notice that it stopped

887
00:40:09,740 --> 00:40:16,098
happening for some time we can do fixed

888
00:40:13,790 --> 00:40:19,190
by section and say hey we think that

889
00:40:16,099 --> 00:40:21,020
this buck was fixed by this commit well

890
00:40:19,190 --> 00:40:23,089
if it doesn't have a rep reducer we have

891
00:40:21,020 --> 00:40:27,560
some logic doll to close the box after

892
00:40:23,089 --> 00:40:30,589
some time okay here it is an example of

893
00:40:27,560 --> 00:40:32,480
an email that the sis pot has composed

894
00:40:30,589 --> 00:40:36,170
it and read some information about the

895
00:40:32,480 --> 00:40:42,500
commit links the rep reducers two other

896
00:40:36,170 --> 00:40:44,810
crashes a son report message and some

897
00:40:42,500 --> 00:40:47,089
footer so this message took a lot of

898
00:40:44,810 --> 00:40:49,460
time to kind of refine and when we just

899
00:40:47,089 --> 00:40:51,619
let the boat loose and start sending

900
00:40:49,460 --> 00:40:54,680
emails the mail increase this is very

901
00:40:51,619 --> 00:40:57,320
fun time so for example this table at

902
00:40:54,680 --> 00:40:59,180
the top it it was a topic of very

903
00:40:57,320 --> 00:41:02,300
lengthy discussion of how exactly the

904
00:40:59,180 --> 00:41:05,390
table formatted and like how you know

905
00:41:02,300 --> 00:41:07,220
how he into a tout or the bottom would

906
00:41:05,390 --> 00:41:09,920
say this buck was generated by a boat

907
00:41:07,220 --> 00:41:12,649
previously we said this buck is

908
00:41:09,920 --> 00:41:14,569
generated by a dump boat because they

909
00:41:12,650 --> 00:41:16,760
thought this kind of you know fun irony

910
00:41:14,569 --> 00:41:18,440
but some people were angry on the boat

911
00:41:16,760 --> 00:41:20,690
and they used it as an offence and they

912
00:41:18,440 --> 00:41:22,700
said hey you yourself said it that you

913
00:41:20,690 --> 00:41:25,849
bought these dumps away to you that it

914
00:41:22,700 --> 00:41:28,939
sent emails for us so then we remove

915
00:41:25,849 --> 00:41:31,010
that warden and also this is boat

916
00:41:28,940 --> 00:41:33,440
engineer engineers can be reached that

917
00:41:31,010 --> 00:41:35,930
was also very specifically requested

918
00:41:33,440 --> 00:41:41,089
like sentence that we need to include in

919
00:41:35,930 --> 00:41:44,440
the text okay so could rewind to today

920
00:41:41,089 --> 00:41:47,328
for upstream Linux kernel found about

921
00:41:44,440 --> 00:41:49,640
2,900 bucks that were automatically

922
00:41:47,329 --> 00:41:54,680
reported by the system about 2,000

923
00:41:49,640 --> 00:41:56,359
affixed 800 are still not fixed so the

924
00:41:54,680 --> 00:41:59,419
system runs for about two and a half

925
00:41:56,359 --> 00:42:02,180
years which which makes it three bucks

926
00:41:59,420 --> 00:42:04,609
per day reported each day and two of

927
00:42:02,180 --> 00:42:06,589
which are fixed and before that was

928
00:42:04,609 --> 00:42:09,529
reported about thousands of bucks man

929
00:42:06,589 --> 00:42:10,940
all day so we have a web dashboard which

930
00:42:09,530 --> 00:42:13,160
has all of the bugs and all of the

931
00:42:10,940 --> 00:42:13,880
statuses which are open which a fix here

932
00:42:13,160 --> 00:42:17,259
you can see

933
00:42:13,880 --> 00:42:19,910
a snippet of open box for Linux kernel

934
00:42:17,260 --> 00:42:22,580
some section misuse of the freeze and

935
00:42:19,910 --> 00:42:24,410
out of bounds we say when it was

936
00:42:22,580 --> 00:42:26,569
reported summer report let's say two

937
00:42:24,410 --> 00:42:32,810
years ago but they still happen has a

938
00:42:26,570 --> 00:42:37,640
rep reducer this number of box will

939
00:42:32,810 --> 00:42:41,029
report per month now we will report both

940
00:42:37,640 --> 00:42:43,029
from about one hundred hundred bucks per

941
00:42:41,030 --> 00:42:45,170
month you can see it pretty random

942
00:42:43,030 --> 00:42:46,850
sometimes we had some new features

943
00:42:45,170 --> 00:42:51,500
sometimes you know there's a new code

944
00:42:46,850 --> 00:42:52,880
being merged in the kernel people ask if

945
00:42:51,500 --> 00:42:54,680
it's getting better

946
00:42:52,880 --> 00:42:59,740
so why I can say that it's getting

947
00:42:54,680 --> 00:43:02,629
better it's still pretty random but

948
00:42:59,740 --> 00:43:05,919
support allowed us to scale the system

949
00:43:02,630 --> 00:43:09,440
even more subsets upstream Linux vs.

950
00:43:05,920 --> 00:43:12,170
several kernel releases with test

951
00:43:09,440 --> 00:43:14,240
several Android releases we test

952
00:43:12,170 --> 00:43:17,090
number of internal kernels and

953
00:43:14,240 --> 00:43:19,450
well-supported Cisco Lord a set of other

954
00:43:17,090 --> 00:43:23,300
person systems like G bizarre fuchsia

955
00:43:19,450 --> 00:43:25,250
FreeBSD NetBSD OpenBSD sin total it

956
00:43:23,300 --> 00:43:27,770
reported actually close to seven

957
00:43:25,250 --> 00:43:29,840
thousand bucks by now and this doesn't

958
00:43:27,770 --> 00:43:35,240
include all of the invalid and dublicate

959
00:43:29,840 --> 00:43:37,100
box so you may wonder what types of bugs

960
00:43:35,240 --> 00:43:39,319
were finding so we're finding all types

961
00:43:37,100 --> 00:43:42,200
of bugs not necessary use of the free

962
00:43:39,320 --> 00:43:45,590
out-of-bounds we enable us of debugging

963
00:43:42,200 --> 00:43:47,899
tools and you'll find that just some mix

964
00:43:45,590 --> 00:43:50,450
of them we I think we found at least

965
00:43:47,900 --> 00:43:52,310
thousand several thousands of security

966
00:43:50,450 --> 00:43:56,240
bugs but very few of them actually were

967
00:43:52,310 --> 00:43:58,910
assessed and have CDs but for kernel we

968
00:43:56,240 --> 00:44:00,649
know we noticed some interesting box for

969
00:43:58,910 --> 00:44:03,350
example things like warning which is

970
00:44:00,650 --> 00:44:05,390
kind of an assert in the kernel world

971
00:44:03,350 --> 00:44:07,730
can be very interesting back we seen the

972
00:44:05,390 --> 00:44:09,650
case where we get a warning but this is

973
00:44:07,730 --> 00:44:12,140
actually a warning to restore register

974
00:44:09,650 --> 00:44:14,750
on the context switch to a guest virtual

975
00:44:12,140 --> 00:44:17,060
machine which means that we leak all of

976
00:44:14,750 --> 00:44:18,980
the hosts registers to the guest which

977
00:44:17,060 --> 00:44:21,890
is pretty substantial information leak

978
00:44:18,980 --> 00:44:23,720
and we seen some remote exploits and we

979
00:44:21,890 --> 00:44:25,819
see also case when the machine was

980
00:44:23,720 --> 00:44:27,810
unresponsive but they turned out to be

981
00:44:25,820 --> 00:44:29,640
full yes the hosts

982
00:44:27,810 --> 00:44:32,940
because there was a page reference leap

983
00:44:29,640 --> 00:44:35,069
triggered by a guest so by executing one

984
00:44:32,940 --> 00:44:37,260
instruction just could trigger a

985
00:44:35,070 --> 00:44:42,180
reference page reference leak on the

986
00:44:37,260 --> 00:44:44,310
host okay I'm running out of time so

987
00:44:42,180 --> 00:44:47,460
future work we have was a work we need

988
00:44:44,310 --> 00:44:49,740
more descriptions we need we are working

989
00:44:47,460 --> 00:44:52,080
on how to generation some descriptions

990
00:44:49,740 --> 00:44:53,910
we want smarter fashion because we have

991
00:44:52,080 --> 00:44:56,610
lots and lots of information about all

992
00:44:53,910 --> 00:45:00,960
of the structure and resources and

993
00:44:56,610 --> 00:45:07,680
system cultural values we also want to

994
00:45:00,960 --> 00:45:09,750
make raise children racist smarter and

995
00:45:07,680 --> 00:45:12,540
we want to extend it maybe things they

996
00:45:09,750 --> 00:45:15,360
hypervisors maybe even some user space

997
00:45:12,540 --> 00:45:17,340
land libraries because this was an

998
00:45:15,360 --> 00:45:19,350
engine is pretty generic so there are

999
00:45:17,340 --> 00:45:22,650
parts of the kernel specific but parcel

1000
00:45:19,350 --> 00:45:24,210
is very generic windows so you seen

1001
00:45:22,650 --> 00:45:24,960
windows mentioned yesterday in the

1002
00:45:24,210 --> 00:45:27,240
keynote

1003
00:45:24,960 --> 00:45:30,600
I said windows mentioned yesterday

1004
00:45:27,240 --> 00:45:33,620
another talk and you see there's another

1005
00:45:30,600 --> 00:45:36,750
port to Windows done by other people and

1006
00:45:33,620 --> 00:45:38,730
there's yet another port done by yet

1007
00:45:36,750 --> 00:45:41,430
another people all of those ports are

1008
00:45:38,730 --> 00:45:43,560
closed worst some people if they want to

1009
00:45:41,430 --> 00:45:45,419
open-source their work and contribute

1010
00:45:43,560 --> 00:45:47,009
back and they said no we will not make

1011
00:45:45,420 --> 00:45:51,420
it public in this in a year because

1012
00:45:47,010 --> 00:45:55,500
still finds in too many good bugs and

1013
00:45:51,420 --> 00:45:59,940
some of the bugs are for DSL well let's

1014
00:45:55,500 --> 00:46:02,990
say that not to elaborate ok so I hope

1015
00:45:59,940 --> 00:46:08,570
to see Windows port in some future and

1016
00:46:02,990 --> 00:46:08,569
thank you all of this open source

1017
00:46:10,690 --> 00:46:14,289
[Applause]

