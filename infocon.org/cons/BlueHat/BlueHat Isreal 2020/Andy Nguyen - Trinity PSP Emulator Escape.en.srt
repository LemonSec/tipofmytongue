1
00:00:11,719 --> 00:00:17,970
hi everybody and welcome to my

2
00:00:15,179 --> 00:00:21,060
presentation about Trinity PSP emulator

3
00:00:17,970 --> 00:00:23,520
escape I'm happy and excited to be on

4
00:00:21,060 --> 00:00:26,340
stage today and talk in front of such an

5
00:00:23,520 --> 00:00:29,189
amazing audience so my name is andy

6
00:00:26,340 --> 00:00:31,730
jillian the hardest last name in the

7
00:00:29,189 --> 00:00:34,860
world and the fun fact about me is that

8
00:00:31,730 --> 00:00:37,559
I'm a Google engineer at the Microsoft

9
00:00:34,860 --> 00:00:42,840
conference talking about the product by

10
00:00:37,559 --> 00:00:45,809
Sony but this is all private research

11
00:00:42,840 --> 00:00:49,440
and is not affiliated or associated with

12
00:00:45,809 --> 00:00:51,860
the companies above in any way so what's

13
00:00:49,440 --> 00:00:53,940
the product it's the PlayStation Vita

14
00:00:51,860 --> 00:00:56,160
which is the successor to the

15
00:00:53,940 --> 00:01:00,570
PlayStation Portable and it was released

16
00:00:56,160 --> 00:01:03,898
in 2012 to me in my opinion it's twice

17
00:01:00,570 --> 00:01:06,750
as good as the PSP it has got doubled

18
00:01:03,899 --> 00:01:09,240
the resolution yet because two analog

19
00:01:06,750 --> 00:01:13,160
sticks it has a touchscreen and a

20
00:01:09,240 --> 00:01:16,229
touchpad on the back and it runs with

21
00:01:13,160 --> 00:01:21,689
444 megahertz and is capable of running

22
00:01:16,229 --> 00:01:24,000
HD games unfortunately it wasn't so

23
00:01:21,689 --> 00:01:26,908
successful and I looked up the sales

24
00:01:24,000 --> 00:01:30,390
information the PS Vita sold 10 million

25
00:01:26,909 --> 00:01:33,659
of units whereas the PSP sold 70 million

26
00:01:30,390 --> 00:01:37,380
of units and in comparison the Nintendo

27
00:01:33,659 --> 00:01:40,649
switch thought 50 million but the home

28
00:01:37,380 --> 00:01:43,079
road seemed great even though Sony led

29
00:01:40,649 --> 00:01:45,630
the console die with the homebrew scene

30
00:01:43,079 --> 00:01:48,449
decided to revive and we brought a lot

31
00:01:45,630 --> 00:01:52,020
of homebrew games applications emulators

32
00:01:48,450 --> 00:01:54,329
and blockings to overflowed at to

33
00:01:52,020 --> 00:01:57,509
overclock the device or increase the

34
00:01:54,329 --> 00:02:00,689
resolution and games and it was all

35
00:01:57,509 --> 00:02:06,119
possible thanks to a JPEG released in

36
00:02:00,689 --> 00:02:08,820
2016 by T molecule now what about the

37
00:02:06,119 --> 00:02:11,280
hardware architecture the relevant part

38
00:02:08,820 --> 00:02:15,299
for us is it runs now arm cortex a9

39
00:02:11,280 --> 00:02:19,019
processor which is 32-bit it also has a

40
00:02:15,299 --> 00:02:21,329
trust zone implemented and there's a

41
00:02:19,019 --> 00:02:23,990
processor integrated for PlayStation

42
00:02:21,329 --> 00:02:26,820
Portable game support

43
00:02:23,990 --> 00:02:30,390
now the interesting part what about its

44
00:02:26,820 --> 00:02:33,959
security considering that this device is

45
00:02:30,390 --> 00:02:36,390
almost 10 years old it's amazing how

46
00:02:33,960 --> 00:02:38,160
many security medications they are they

47
00:02:36,390 --> 00:02:41,399
have implemented address space layout

48
00:02:38,160 --> 00:02:44,760
randomization and execute never bit in

49
00:02:41,400 --> 00:02:47,700
user land and kernel and basically that

50
00:02:44,760 --> 00:02:49,260
means that to exploit the memory

51
00:02:47,700 --> 00:02:52,350
corruption bug you also need an

52
00:02:49,260 --> 00:02:55,290
information leak and as a consequence of

53
00:02:52,350 --> 00:02:59,070
xn you cannot execute your shellcode in

54
00:02:55,290 --> 00:03:01,920
some data segment but you need to use

55
00:02:59,070 --> 00:03:04,590
the rope chain this domain access

56
00:03:01,920 --> 00:03:06,299
control register which is similar

57
00:03:04,590 --> 00:03:08,430
technology to this map and map and

58
00:03:06,300 --> 00:03:12,330
prevents you from accessing user memory

59
00:03:08,430 --> 00:03:14,160
or executing user code in kernel they

60
00:03:12,330 --> 00:03:16,800
have also element in stack protection in

61
00:03:14,160 --> 00:03:19,200
user land and kernel and the stack cook

62
00:03:16,800 --> 00:03:21,750
it not the constant and I have

63
00:03:19,200 --> 00:03:24,149
implemented sandboxing and Cisco random

64
00:03:21,750 --> 00:03:26,580
you see where the main restriction is

65
00:03:24,150 --> 00:03:29,820
that you're only allowed to invoke these

66
00:03:26,580 --> 00:03:31,830
girls from the current process in Furion

67
00:03:29,820 --> 00:03:35,549
you may be able to invoke other syscalls

68
00:03:31,830 --> 00:03:37,470
if you only have a reference and that's

69
00:03:35,550 --> 00:03:40,470
exactly what this current initiation is

70
00:03:37,470 --> 00:03:42,900
trying to prevent they have also applied

71
00:03:40,470 --> 00:03:45,420
coarse-grained locking which is bad for

72
00:03:42,900 --> 00:03:48,420
performance but it does avoid race

73
00:03:45,420 --> 00:03:52,589
conditions not sure if that is intended

74
00:03:48,420 --> 00:03:55,019
or developers but just lazy and to

75
00:03:52,590 --> 00:03:57,540
prevent stupid mistakes they have

76
00:03:55,020 --> 00:03:59,790
removed or unsafe Lipsy functions from

77
00:03:57,540 --> 00:04:04,109
the operating system such as string copy

78
00:03:59,790 --> 00:04:06,750
string printf and there's no cheat which

79
00:04:04,110 --> 00:04:08,250
is not really a security mitigation it

80
00:04:06,750 --> 00:04:11,970
makes it harder to exploit something

81
00:04:08,250 --> 00:04:15,090
because you need to write objects so

82
00:04:11,970 --> 00:04:17,519
what are the attack vectors you should

83
00:04:15,090 --> 00:04:20,820
attack vectors for gaming and source or

84
00:04:17,519 --> 00:04:24,299
file format like lip TIFF corruptions or

85
00:04:20,820 --> 00:04:26,610
so which were used on the PP but on the

86
00:04:24,300 --> 00:04:32,780
PS Vita it's difficult to pull them off

87
00:04:26,610 --> 00:04:36,050
due to a SLR the PS Vita so another

88
00:04:32,780 --> 00:04:38,210
possibility is to abuse safe games

89
00:04:36,050 --> 00:04:41,030
and interestingly it's possible because

90
00:04:38,210 --> 00:04:43,789
old games were compared to without pi

91
00:04:41,030 --> 00:04:47,508
and without stat protection so you can

92
00:04:43,789 --> 00:04:51,800
easily find buffer overflows and smash

93
00:04:47,509 --> 00:04:54,379
the stack PS Vita's got the dev kit app

94
00:04:51,800 --> 00:04:57,110
so it's got the internet browser which

95
00:04:54,379 --> 00:04:59,629
uses a WebKit and given the amount of

96
00:04:57,110 --> 00:05:03,560
public vulnerabilities it's quite easy

97
00:04:59,629 --> 00:05:05,240
to exploit it and it's also at the best

98
00:05:03,560 --> 00:05:10,639
entry point because it offers the

99
00:05:05,240 --> 00:05:13,280
end-user the easiest installation but it

100
00:05:10,639 --> 00:05:17,500
is fully sandbox and has only low

101
00:05:13,280 --> 00:05:23,679
privileges even lo can say safe games

102
00:05:17,500 --> 00:05:25,940
and a remote attack may be possible so

103
00:05:23,680 --> 00:05:28,879
differently from file formats you

104
00:05:25,940 --> 00:05:30,860
usually send some message and expect

105
00:05:28,879 --> 00:05:34,610
some response and if there's some buck

106
00:05:30,860 --> 00:05:36,080
in the response you can leak some

107
00:05:34,610 --> 00:05:39,770
information and use that to further

108
00:05:36,080 --> 00:05:43,758
exploit it and that's a challenge for me

109
00:05:39,770 --> 00:05:45,849
and an attack surface is the PSP

110
00:05:43,759 --> 00:05:48,500
emulator it's especially interesting

111
00:05:45,849 --> 00:05:53,449
because it runs with system privileges

112
00:05:48,500 --> 00:05:55,610
which are equivalent route and also we

113
00:05:53,449 --> 00:05:59,870
can use the MIPS processor for doing

114
00:05:55,610 --> 00:06:02,360
logic now first a bit about the PSP

115
00:05:59,870 --> 00:06:03,860
emulator internals so as mentioned

116
00:06:02,360 --> 00:06:09,259
before there submits processor

117
00:06:03,860 --> 00:06:11,810
integrated and so other frames which are

118
00:06:09,259 --> 00:06:15,050
emulated is out your memory stick or the

119
00:06:11,810 --> 00:06:18,259
media and chain network or to control

120
00:06:15,050 --> 00:06:20,479
and because the MIPS processor has not

121
00:06:18,259 --> 00:06:22,460
access to these hardware devices it has

122
00:06:20,479 --> 00:06:26,150
to communicate with the ARM processor

123
00:06:22,460 --> 00:06:31,659
over RPC and for that it uses a shared

124
00:06:26,150 --> 00:06:36,620
SRAM oath and also a shared CGI Ram

125
00:06:31,659 --> 00:06:38,389
where it's only a subset of the RAM so

126
00:06:36,620 --> 00:06:40,580
basically if you have code execution in

127
00:06:38,389 --> 00:06:43,190
the ARM processor you can easily

128
00:06:40,580 --> 00:06:45,770
manipulate the memory and at code

129
00:06:43,190 --> 00:06:48,469
execution in the MIPS processor but vice

130
00:06:45,770 --> 00:06:50,380
versa is more difficult and that's the

131
00:06:48,469 --> 00:06:53,600
task of the day

132
00:06:50,380 --> 00:06:57,260
so the plan of attack is to start in

133
00:06:53,600 --> 00:07:01,580
mips user ant and somehow find holes in

134
00:06:57,260 --> 00:07:03,950
the RPC server and attack it but for

135
00:07:01,580 --> 00:07:07,310
that we need the ability say an

136
00:07:03,950 --> 00:07:10,130
arbitrary RPC commands and for that we

137
00:07:07,310 --> 00:07:12,320
require mips privileges it's gonna be

138
00:07:10,130 --> 00:07:15,170
villages and assume you were able to

139
00:07:12,320 --> 00:07:17,450
break out of the emulator the last goal

140
00:07:15,170 --> 00:07:23,210
would be to explain villages to armed

141
00:07:17,450 --> 00:07:25,099
colonel alright let's get started so the

142
00:07:23,210 --> 00:07:27,229
security medications that I have

143
00:07:25,100 --> 00:07:30,590
described before applied to the ARM

144
00:07:27,230 --> 00:07:32,330
processor and beat the firmware but the

145
00:07:30,590 --> 00:07:34,460
MIPS processor and the business VMware

146
00:07:32,330 --> 00:07:38,500
is less secure and it's no surprise

147
00:07:34,460 --> 00:07:40,909
because it's almost 15 years old

148
00:07:38,500 --> 00:07:43,010
previous hacks usually exploit the

149
00:07:40,910 --> 00:07:45,830
out-of-bounds writes know about

150
00:07:43,010 --> 00:07:49,610
instructions and the strategy is to

151
00:07:45,830 --> 00:07:51,520
fight indirect jumps in Cisco which use

152
00:07:49,610 --> 00:07:55,190
registers that come from userland and

153
00:07:51,520 --> 00:07:58,760
they know about instructions such that

154
00:07:55,190 --> 00:08:02,150
your army would be picked instead the

155
00:07:58,760 --> 00:08:07,240
ps3 also had a BT emulator however it's

156
00:08:02,150 --> 00:08:09,859
all hype done on high level and

157
00:08:07,240 --> 00:08:13,330
especially the crypto engine is emulated

158
00:08:09,860 --> 00:08:16,190
which contains private keys and

159
00:08:13,330 --> 00:08:19,099
unfortunately the ps3 contact by G or

160
00:08:16,190 --> 00:08:23,300
hot and people were able to derive these

161
00:08:19,100 --> 00:08:25,690
keys to sign executables on the PSP the

162
00:08:23,300 --> 00:08:28,070
same thing can be used for the PS Vita

163
00:08:25,690 --> 00:08:29,930
so that means that MIPS user code

164
00:08:28,070 --> 00:08:34,429
execution is for free

165
00:08:29,930 --> 00:08:37,820
and we can already check market the next

166
00:08:34,429 --> 00:08:39,739
step is to hack the mips kernel so

167
00:08:37,820 --> 00:08:41,780
there's an important data structure in

168
00:08:39,740 --> 00:08:45,290
kernel which is used for resource

169
00:08:41,780 --> 00:08:48,050
tracking using new IDs and each UID

170
00:08:45,290 --> 00:08:51,110
points to a control block which contains

171
00:08:48,050 --> 00:08:52,969
information of the resource and every

172
00:08:51,110 --> 00:08:56,300
control block structured in a tree

173
00:08:52,970 --> 00:08:58,370
hierarchy the problem is the UID is not

174
00:08:56,300 --> 00:09:01,790
random it doesn't really need to be

175
00:08:58,370 --> 00:09:04,150
random but the design is it's calculated

176
00:09:01,790 --> 00:09:08,000
from the Metro block address

177
00:09:04,150 --> 00:09:10,880
so for example if you open a file such a

178
00:09:08,000 --> 00:09:14,240
UID is returned and when you operate on

179
00:09:10,880 --> 00:09:16,700
the file you pass the UID to kernel and

180
00:09:14,240 --> 00:09:19,610
the inverted equation is used to

181
00:09:16,700 --> 00:09:23,180
calculate the control block address from

182
00:09:19,610 --> 00:09:27,130
the UID and the design flaw is you can

183
00:09:23,180 --> 00:09:34,040
pass any UID so the kernel will just

184
00:09:27,130 --> 00:09:37,010
dereference an untrusted pointer so the

185
00:09:34,040 --> 00:09:40,910
way we attack is is similar to a heap

186
00:09:37,010 --> 00:09:45,319
unlink but you may be familiar with like

187
00:09:40,910 --> 00:09:48,260
linkedlist exploitation so we plant a

188
00:09:45,320 --> 00:09:51,640
fake control block in kernel and code it

189
00:09:48,260 --> 00:09:54,920
as a string and then calculated CBD and

190
00:09:51,640 --> 00:09:58,460
the control block contains a function

191
00:09:54,920 --> 00:10:02,240
pointer as parent and I use their

192
00:09:58,460 --> 00:10:04,730
address at next child then we delete the

193
00:10:02,240 --> 00:10:08,630
UID and overwrite the kernel function

194
00:10:04,730 --> 00:10:10,670
pointer with that address and finally we

195
00:10:08,630 --> 00:10:12,400
can just invoke it and enjoy a kernel

196
00:10:10,670 --> 00:10:15,979
mode execution

197
00:10:12,400 --> 00:10:19,939
however this vulnerability was mitigated

198
00:10:15,980 --> 00:10:23,180
with an interpretive check namely by

199
00:10:19,940 --> 00:10:26,870
storing the UID itself in control block

200
00:10:23,180 --> 00:10:30,949
and X or innate with a random seat which

201
00:10:26,870 --> 00:10:33,620
is globally initialized so if we find

202
00:10:30,950 --> 00:10:38,720
out that seat we can craft our control

203
00:10:33,620 --> 00:10:41,200
block and then do the exploit the second

204
00:10:38,720 --> 00:10:45,170
vulnerability is in this vehicle here

205
00:10:41,200 --> 00:10:48,950
their parameters come from userland

206
00:10:45,170 --> 00:10:51,620
and pointers point to use memory that's

207
00:10:48,950 --> 00:10:55,580
a side effect of not having supervisor

208
00:10:51,620 --> 00:10:59,600
mode X access prevention the syscall is

209
00:10:55,580 --> 00:11:03,920
simple it returns an error code if the

210
00:10:59,600 --> 00:11:07,160
index is too large and it returns 5 if

211
00:11:03,920 --> 00:11:12,709
the index is 0 where 5 is the value of

212
00:11:07,160 --> 00:11:15,040
the global global array not a buck is n

213
00:11:12,709 --> 00:11:17,768
points to use the memory

214
00:11:15,040 --> 00:11:20,139
and it fetched twice and there's no luck

215
00:11:17,769 --> 00:11:23,230
involved so that means that there's a

216
00:11:20,139 --> 00:11:28,120
small window where the value of anyone

217
00:11:23,230 --> 00:11:30,850
can change and it's a so called time of

218
00:11:28,120 --> 00:11:34,149
check - time of use and that's how we

219
00:11:30,850 --> 00:11:37,120
exploited respond to threats where the

220
00:11:34,149 --> 00:11:39,490
first execute the Cisco in the second

221
00:11:37,120 --> 00:11:43,500
and the change of plea swaps the value

222
00:11:39,490 --> 00:11:46,240
of N 1 scene 1 and 1 that is advance if

223
00:11:43,500 --> 00:11:49,180
the error code if the result is the

224
00:11:46,240 --> 00:11:52,420
error code it means that we swap too

225
00:11:49,180 --> 00:11:55,359
early if they're if the result is 5 it

226
00:11:52,420 --> 00:11:56,290
means that we swap too late and if it's

227
00:11:55,360 --> 00:11:58,690
nothing in between

228
00:11:56,290 --> 00:12:01,689
it means that we were able to swap just

229
00:11:58,690 --> 00:12:04,600
in that tiny window and the result is

230
00:12:01,690 --> 00:12:06,880
the value we want now we do the

231
00:12:04,600 --> 00:12:09,279
procedure in two rounds in the first

232
00:12:06,880 --> 00:12:11,170
round we want to know where the array is

233
00:12:09,279 --> 00:12:14,399
stored because actually there's some

234
00:12:11,170 --> 00:12:17,529
randomization and in the second round

235
00:12:14,399 --> 00:12:21,940
based on the result we calculate the

236
00:12:17,529 --> 00:12:24,430
index to our arbitrary location now

237
00:12:21,940 --> 00:12:27,459
talking to it together we leap the

238
00:12:24,430 --> 00:12:30,729
random seat by racing and then for chip

239
00:12:27,459 --> 00:12:33,699
and row block with the UID XOR with the

240
00:12:30,730 --> 00:12:35,860
seat in itself and then delete the UID

241
00:12:33,699 --> 00:12:39,040
and redirect the kernel function pointer

242
00:12:35,860 --> 00:12:41,680
and then we invoke this let's go and

243
00:12:39,040 --> 00:12:43,510
enjoy a kernel code execution now we

244
00:12:41,680 --> 00:12:45,760
can't stay too long in kernel mode

245
00:12:43,510 --> 00:12:49,120
because there's a watchdog that will

246
00:12:45,760 --> 00:12:53,290
catch you so instead we install as cisco

247
00:12:49,120 --> 00:12:55,810
bridge to that RPC interface all right

248
00:12:53,290 --> 00:12:58,620
we have exploited MIPS kernel and the

249
00:12:55,810 --> 00:13:01,510
next step is to explore the RPC server

250
00:12:58,620 --> 00:13:05,079
the RPC server looks similarly like that

251
00:13:01,510 --> 00:13:08,670
and it sleeps and waits for inquest and

252
00:13:05,079 --> 00:13:11,560
if there's some requests it wakes up and

253
00:13:08,670 --> 00:13:14,800
fetches the command and the arguments

254
00:13:11,560 --> 00:13:17,410
and translates them to native address if

255
00:13:14,800 --> 00:13:20,589
necessary then handles the requests and

256
00:13:17,410 --> 00:13:24,089
writes back the cache and finally

257
00:13:20,589 --> 00:13:27,370
returns the result back to the client

258
00:13:24,089 --> 00:13:28,360
now there are dozens of commands and sub

259
00:13:27,370 --> 00:13:30,700
commands

260
00:13:28,360 --> 00:13:35,070
and I wrote a dump faster which would

261
00:13:30,700 --> 00:13:38,620
pass random arguments and random command

262
00:13:35,070 --> 00:13:41,290
commands with random buffers and it was

263
00:13:38,620 --> 00:13:43,890
not sophisticated because the only feed

264
00:13:41,290 --> 00:13:47,529
packet God was whether he crashed or not

265
00:13:43,890 --> 00:13:50,319
but interestingly it was able to find a

266
00:13:47,529 --> 00:13:52,420
lot of null pointer dereferences so it

267
00:13:50,320 --> 00:13:56,050
means that this code hasn't been

268
00:13:52,420 --> 00:13:58,319
sufficiently reviewed I black listed

269
00:13:56,050 --> 00:14:01,750
some of the uninteresting commands and

270
00:13:58,320 --> 00:14:06,600
then I found a really promising crash

271
00:14:01,750 --> 00:14:09,490
and for reference the Kermit here is

272
00:14:06,600 --> 00:14:11,740
because they only named the protocol

273
00:14:09,490 --> 00:14:14,290
Kermit and it suits really well because

274
00:14:11,740 --> 00:14:17,880
it's for the buck and the buck is right

275
00:14:14,290 --> 00:14:20,949
here it's a trivial buffer overflow

276
00:14:17,880 --> 00:14:23,500
where buff size is too large it's not

277
00:14:20,950 --> 00:14:27,040
validated and can be too large and the

278
00:14:23,500 --> 00:14:32,380
probability that the fossil was able to

279
00:14:27,040 --> 00:14:34,630
find crash was near 50% now the crash

280
00:14:32,380 --> 00:14:36,959
happened because of the stack protection

281
00:14:34,630 --> 00:14:39,820
and there's that cookie didn't match and

282
00:14:36,959 --> 00:14:44,349
that's something we need to find out for

283
00:14:39,820 --> 00:14:47,019
successful exploitation now common way

284
00:14:44,350 --> 00:14:49,660
to I passed the stack protection is to

285
00:14:47,019 --> 00:14:52,839
find to use some uninitialized memory

286
00:14:49,660 --> 00:14:54,969
read vulnerability of the stack but

287
00:14:52,839 --> 00:14:57,699
unfortunately I wasn't able to find such

288
00:14:54,970 --> 00:15:01,329
a thing and it seemed like Sony made

289
00:14:57,699 --> 00:15:04,779
sure to mem say every single buff that

290
00:15:01,329 --> 00:15:07,719
got returned to the client so instead I

291
00:15:04,779 --> 00:15:10,630
had to find to look for some other pop

292
00:15:07,720 --> 00:15:14,320
classes instead like out-of-bounds reads

293
00:15:10,630 --> 00:15:18,430
and one of the null pointer dereferences

294
00:15:14,320 --> 00:15:20,980
was quite interesting it's in the meteor

295
00:15:18,430 --> 00:15:27,939
and chin color space conversion commands

296
00:15:20,980 --> 00:15:31,769
and what does is it gets ycbcr buffer

297
00:15:27,940 --> 00:15:34,480
and converts it into a RGB a buffer

298
00:15:31,769 --> 00:15:37,930
these pointers come from user memory

299
00:15:34,480 --> 00:15:41,770
from PSP user memory and they get

300
00:15:37,930 --> 00:15:42,189
translated to native address now we have

301
00:15:41,770 --> 00:15:44,620
these

302
00:15:42,190 --> 00:15:46,510
copies here because the components are

303
00:15:44,620 --> 00:15:50,940
differently sized and there's some

304
00:15:46,510 --> 00:15:54,040
adjustment needed and they copied the

305
00:15:50,940 --> 00:15:56,910
content into a temporary buffer which is

306
00:15:54,040 --> 00:16:01,120
allocated at the constant address and

307
00:15:56,910 --> 00:16:05,199
the pop in this coat is that the row is

308
00:16:01,120 --> 00:16:08,800
not validated and it is a 30 bit integer

309
00:16:05,200 --> 00:16:14,710
and as touch we can arbitrarily control

310
00:16:08,800 --> 00:16:18,280
the source pointer now we have an

311
00:16:14,710 --> 00:16:20,800
arbitrary read but the content is

312
00:16:18,280 --> 00:16:25,810
written to that temporary buffer and 10

313
00:16:20,800 --> 00:16:28,569
CSC is applied on that buffer and that's

314
00:16:25,810 --> 00:16:31,209
the formula of CSC I don't really

315
00:16:28,570 --> 00:16:34,390
understand it but what is obvious is

316
00:16:31,210 --> 00:16:36,760
that we lose information due to a

317
00:16:34,390 --> 00:16:43,510
floating point imprecision or 8-bit

318
00:16:36,760 --> 00:16:48,340
truncation so what if can set CP and Zr

319
00:16:43,510 --> 00:16:50,710
to 128 then the rest of the terms would

320
00:16:48,340 --> 00:16:56,080
cancel out and we would be left with

321
00:16:50,710 --> 00:16:58,030
Archie be equal to Y but still we can't

322
00:16:56,080 --> 00:17:01,140
just point to an arbitrary address and

323
00:16:58,030 --> 00:17:04,420
expect to control their values there

324
00:17:01,140 --> 00:17:10,270
because the ycbcr buffers are stored

325
00:17:04,420 --> 00:17:12,640
consecutively and it took me a bit of

326
00:17:10,270 --> 00:17:14,680
creativity and I made the observation

327
00:17:12,640 --> 00:17:17,260
that that frame buffer was allocated at

328
00:17:14,680 --> 00:17:20,290
the constant address and that the frame

329
00:17:17,260 --> 00:17:24,430
buffer was not cleared of the conversion

330
00:17:20,290 --> 00:17:27,329
so that's how we exploited we filled the

331
00:17:24,430 --> 00:17:29,920
cbcr frame buffer with the value hex 80

332
00:17:27,329 --> 00:17:33,450
this can be done by just calling the

333
00:17:29,920 --> 00:17:36,610
command without abusing anything and

334
00:17:33,450 --> 00:17:39,790
then we copy the content of our our

335
00:17:36,610 --> 00:17:43,389
arbitrary source into the y component

336
00:17:39,790 --> 00:17:45,010
and we do that by choosing a size such

337
00:17:43,390 --> 00:17:49,060
that only a third of the buffer is

338
00:17:45,010 --> 00:17:52,420
filled now we have the constellation

339
00:17:49,060 --> 00:17:55,210
where the Y component contains the

340
00:17:52,420 --> 00:17:56,970
information we want to disclose and the

341
00:17:55,210 --> 00:18:01,059
rest Ponte

342
00:17:56,970 --> 00:18:03,370
xat sorry now we want to apply CSC on

343
00:18:01,059 --> 00:18:07,299
that buffer but we don't want to change

344
00:18:03,370 --> 00:18:10,449
content of it how can we achieve that by

345
00:18:07,299 --> 00:18:14,769
choosing the same address for the source

346
00:18:10,450 --> 00:18:17,679
as destination and as such mempie will

347
00:18:14,769 --> 00:18:21,190
not have any effect and we can then

348
00:18:17,679 --> 00:18:25,990
apply CSC and it will gray fully output

349
00:18:21,190 --> 00:18:28,510
the Y component to us and the last step

350
00:18:25,990 --> 00:18:33,309
is to read every fourth byte of the

351
00:18:28,510 --> 00:18:37,330
output Y every fourth byte because our

352
00:18:33,309 --> 00:18:41,769
GP is equal to Y so it's the same

353
00:18:37,330 --> 00:18:46,389
information now what is it all about

354
00:18:41,769 --> 00:18:48,760
again we had a stack smash and we wanted

355
00:18:46,389 --> 00:18:52,750
to find out the stack cookie and now we

356
00:18:48,760 --> 00:18:55,179
have it well we have obtained an

357
00:18:52,750 --> 00:18:58,630
arbitrary primitive and we still need

358
00:18:55,179 --> 00:19:00,909
find out that value that cookie is

359
00:18:58,630 --> 00:19:03,779
stored in a data type meant of some

360
00:19:00,909 --> 00:19:06,730
module but where's that data segment

361
00:19:03,779 --> 00:19:10,179
remember there is a SLR and it can be

362
00:19:06,730 --> 00:19:13,090
our anywhere and we definitely don't

363
00:19:10,179 --> 00:19:15,070
want to breathe somewhere and hit an

364
00:19:13,090 --> 00:19:20,289
invalid page and make the application

365
00:19:15,070 --> 00:19:23,620
crash fortunately there is an easy

366
00:19:20,289 --> 00:19:27,580
approach the piece between where is 12

367
00:19:23,620 --> 00:19:30,668
megabytes big and is stored in the PHP

368
00:19:27,580 --> 00:19:33,580
data segment and it's always allocated

369
00:19:30,669 --> 00:19:37,179
at these two addresses which means that

370
00:19:33,580 --> 00:19:40,320
there's only an entropy of 5 bits and it

371
00:19:37,179 --> 00:19:44,320
also means that can read at that address

372
00:19:40,320 --> 00:19:47,439
safely because in the first case it's 1

373
00:19:44,320 --> 00:19:50,549
megabytes within a segment in the second

374
00:19:47,440 --> 00:19:53,889
it's only slightly of this to start and

375
00:19:50,549 --> 00:19:57,399
from that point on we iterate backwards

376
00:19:53,889 --> 00:20:00,189
and search for some unique constant once

377
00:19:57,399 --> 00:20:03,250
we find that we can determine the ASRs

378
00:20:00,190 --> 00:20:06,159
light and from that point on we can

379
00:20:03,250 --> 00:20:09,240
determine all basis and know the exact

380
00:20:06,159 --> 00:20:09,240
location of the star cookie

381
00:20:09,670 --> 00:20:16,000
now we can put it together we put a

382
00:20:12,800 --> 00:20:19,850
stock key at the right position and

383
00:20:16,000 --> 00:20:23,600
overflow the buffer and get that

384
00:20:19,850 --> 00:20:27,469
exception we can control PC arbitrarily

385
00:20:23,600 --> 00:20:33,379
and that's always something cool to see

386
00:20:27,470 --> 00:20:35,180
that will value here all right we were

387
00:20:33,380 --> 00:20:37,430
able to execute that we are able to

388
00:20:35,180 --> 00:20:40,160
execute Rob chains with system

389
00:20:37,430 --> 00:20:42,680
privileges but we want to stay in MIPS

390
00:20:40,160 --> 00:20:44,750
world and orchestrate arm function calls

391
00:20:42,680 --> 00:20:47,780
instead because we don't want to write

392
00:20:44,750 --> 00:20:50,960
complex rope chains so for every

393
00:20:47,780 --> 00:20:53,389
function call in our world we prepare a

394
00:20:50,960 --> 00:20:56,540
small rope chain that contains set

395
00:20:53,390 --> 00:20:58,970
function and the arguments and we smash

396
00:20:56,540 --> 00:21:01,820
the stack with it and then the Rope

397
00:20:58,970 --> 00:21:05,150
chain will store the context and receive

398
00:21:01,820 --> 00:21:07,600
the execution intent the return value

399
00:21:05,150 --> 00:21:11,000
will be returned back to the client and

400
00:21:07,600 --> 00:21:14,649
for pointers we can just use the PSP RAM

401
00:21:11,000 --> 00:21:16,940
and map it to the native address space

402
00:21:14,650 --> 00:21:20,330
but we need to be careful with the MIPS

403
00:21:16,940 --> 00:21:22,310
cache so before we send the command we

404
00:21:20,330 --> 00:21:24,949
need to write the write back the cache

405
00:21:22,310 --> 00:21:27,470
such that the ARM processor and see the

406
00:21:24,950 --> 00:21:30,110
real contents and we also need to

407
00:21:27,470 --> 00:21:32,450
invalidate it such that we can see that

408
00:21:30,110 --> 00:21:35,929
the changes that were made from the ARM

409
00:21:32,450 --> 00:21:39,890
processor and finally we are able to

410
00:21:35,930 --> 00:21:45,770
write hybrid code which used native API

411
00:21:39,890 --> 00:21:48,710
but run on the MIPS processor now we

412
00:21:45,770 --> 00:21:53,170
have already at the arm userland and the

413
00:21:48,710 --> 00:21:53,170
last step is to attack the arm kernel

414
00:21:53,320 --> 00:21:59,110
while developing I noticed something

415
00:21:55,820 --> 00:22:02,240
weird of the multiple arm function calls

416
00:21:59,110 --> 00:22:05,389
wireless LAN would stop working how was

417
00:22:02,240 --> 00:22:07,730
it possible we oh we only escaped the

418
00:22:05,390 --> 00:22:11,150
emulator and we didn't touch the kernel

419
00:22:07,730 --> 00:22:14,300
yet it turned out that the buffer we

420
00:22:11,150 --> 00:22:16,490
used to smash the stack was passed to a

421
00:22:14,300 --> 00:22:19,129
wireless LAN I have control command and

422
00:22:16,490 --> 00:22:21,690
this command would notice that the

423
00:22:19,130 --> 00:22:24,600
buffer was not valid and bailed out

424
00:22:21,690 --> 00:22:29,430
but while bailing out it forgot to free

425
00:22:24,600 --> 00:22:32,070
some heap allocation and in the baddest

426
00:22:29,430 --> 00:22:35,280
land driver there are only eight slots

427
00:22:32,070 --> 00:22:36,960
available for heap allocations so that

428
00:22:35,280 --> 00:22:41,010
means that after eight function calls

429
00:22:36,960 --> 00:22:44,040
you would already run out of memory with

430
00:22:41,010 --> 00:22:46,830
the same mindset as before if there's

431
00:22:44,040 --> 00:22:50,820
such a buck means that there's potential

432
00:22:46,830 --> 00:22:54,679
for more severe bugs and I found a hip

433
00:22:50,820 --> 00:22:59,389
overflow just right after looking at it

434
00:22:54,680 --> 00:23:03,690
it looks like that so it allocates

435
00:22:59,390 --> 00:23:07,350
temporary buffer and copies use the data

436
00:23:03,690 --> 00:23:11,160
into it and then it allocates a work

437
00:23:07,350 --> 00:23:15,000
butter and paste the data from temporary

438
00:23:11,160 --> 00:23:18,240
buffer into it with a size choosable by

439
00:23:15,000 --> 00:23:22,470
us and then it frees the locations in

440
00:23:18,240 --> 00:23:26,220
last in first out order and this

441
00:23:22,470 --> 00:23:29,460
overflow is on a custom heap now why do

442
00:23:26,220 --> 00:23:33,110
we even have a custom heap because the

443
00:23:29,460 --> 00:23:35,400
network stack is based net bsd 4.0 and

444
00:23:33,110 --> 00:23:37,740
the base Victor doesn't really have

445
00:23:35,400 --> 00:23:40,230
malloc and free in kernel so that's why

446
00:23:37,740 --> 00:23:43,860
they had to implement their own custom

447
00:23:40,230 --> 00:23:47,220
male malloc free API so the cusp

448
00:23:43,860 --> 00:23:50,399
implements a best fit algorithm which is

449
00:23:47,220 --> 00:23:53,790
good for performance which is memory

450
00:23:50,400 --> 00:23:56,220
efficient bad for performance the heap

451
00:23:53,790 --> 00:24:00,570
maintains a free list as well as a busy

452
00:23:56,220 --> 00:24:03,330
list and free chunks are always Qualis

453
00:24:00,570 --> 00:24:06,419
so it means that no two free chunk can

454
00:24:03,330 --> 00:24:09,419
consecutive in memory and the heap

455
00:24:06,420 --> 00:24:11,970
contains heap cookies which indicate

456
00:24:09,420 --> 00:24:17,130
whether chunk is free or whether it is

457
00:24:11,970 --> 00:24:19,680
busy and it also contains a heap cookie

458
00:24:17,130 --> 00:24:22,470
at the end of every tank to prevent

459
00:24:19,680 --> 00:24:24,720
buffer overflows but because these

460
00:24:22,470 --> 00:24:27,480
cookies are instant and because we

461
00:24:24,720 --> 00:24:31,320
control the buffer of the overflow we

462
00:24:27,480 --> 00:24:33,720
can just simply fake it and the last the

463
00:24:31,320 --> 00:24:34,820
last last but not least the heap grows

464
00:24:33,720 --> 00:24:37,250
backwards

465
00:24:34,820 --> 00:24:41,149
high too low which is benefited for us

466
00:24:37,250 --> 00:24:44,830
as you can see later now we have a

467
00:24:41,149 --> 00:24:48,408
diagram which shows the initial state

468
00:24:44,830 --> 00:24:52,519
where we allocated a buffer on the

469
00:24:48,409 --> 00:24:57,350
bottom and the word buffer on the top

470
00:24:52,519 --> 00:25:01,970
and the busy head points the word buffer

471
00:24:57,350 --> 00:25:05,980
and now data from the temporary buffer

472
00:25:01,970 --> 00:25:08,600
will be copied into the work buffer and

473
00:25:05,980 --> 00:25:13,190
overflow into temporary buffer itself

474
00:25:08,600 --> 00:25:16,490
and because we know what we over flow

475
00:25:13,190 --> 00:25:18,019
like we know what chunks there is we

476
00:25:16,490 --> 00:25:20,659
know we only corrupt the chunk header

477
00:25:18,019 --> 00:25:25,100
and that's something we need to restore

478
00:25:20,659 --> 00:25:28,669
after exploitation now after the

479
00:25:25,100 --> 00:25:30,889
overflow we plan to fake chunks where

480
00:25:28,669 --> 00:25:34,039
the first is a basic chunk and the

481
00:25:30,889 --> 00:25:38,928
second is a fake free chunk and they

482
00:25:34,039 --> 00:25:42,370
point to arbitrary addresses now why

483
00:25:38,929 --> 00:25:46,190
does the on the bottom need to be free

484
00:25:42,370 --> 00:25:48,860
because when freeing the preview the

485
00:25:46,190 --> 00:25:52,009
physical next chunk is considered as

486
00:25:48,860 --> 00:25:57,168
free if it is different from the logical

487
00:25:52,009 --> 00:26:01,009
next chunk so if we freed the jump on

488
00:25:57,169 --> 00:26:04,580
the top it will look at the pointer and

489
00:26:01,009 --> 00:26:08,000
it sees that the logical next is same as

490
00:26:04,580 --> 00:26:11,090
the physical next in case it needs to

491
00:26:08,000 --> 00:26:14,899
repeat the procedure and in the second

492
00:26:11,090 --> 00:26:17,779
round the next the logical next chunk

493
00:26:14,899 --> 00:26:20,479
points to an arbitrary address which is

494
00:26:17,779 --> 00:26:23,259
not equal to the physical next that

495
00:26:20,480 --> 00:26:26,269
means that the chunk bottom must be free

496
00:26:23,259 --> 00:26:28,549
and that's exactly what happens when we

497
00:26:26,269 --> 00:26:35,360
free the junk on the top and the

498
00:26:28,549 --> 00:26:38,000
basically busy head also changes and the

499
00:26:35,360 --> 00:26:42,740
fake return now points back to the work

500
00:26:38,000 --> 00:26:46,129
buffer and what do we have above we have

501
00:26:42,740 --> 00:26:49,510
the work point written to arbitrary

502
00:26:46,129 --> 00:26:51,709
next and that's our write limit

503
00:26:49,510 --> 00:26:53,809
now we're not finished

504
00:26:51,710 --> 00:26:59,840
we still need to free the temporary

505
00:26:53,809 --> 00:27:01,580
buffer and after bring that the busy

506
00:26:59,840 --> 00:27:05,709
list head changed again

507
00:27:01,580 --> 00:27:09,040
and now we destroyed the whole structure

508
00:27:05,710 --> 00:27:14,150
null is also written to arbitrary ref

509
00:27:09,040 --> 00:27:18,260
and now we have three chunks left ready

510
00:27:14,150 --> 00:27:18,800
to be merged after merging the first two

511
00:27:18,260 --> 00:27:21,559
chunks

512
00:27:18,800 --> 00:27:23,928
we have taste consolation so nothing

513
00:27:21,559 --> 00:27:27,490
really interesting happened but we still

514
00:27:23,929 --> 00:27:31,040
have two terms left to be merged and

515
00:27:27,490 --> 00:27:33,470
once again we have a right primitive

516
00:27:31,040 --> 00:27:39,559
where the work pointer is written to

517
00:27:33,470 --> 00:27:43,100
arbitrary pref overall f3 writes the

518
00:27:39,559 --> 00:27:47,059
book a pointer is written to our top

519
00:27:43,100 --> 00:27:51,050
null is written to our right and again

520
00:27:47,059 --> 00:27:55,360
work is written to our bottom and let's

521
00:27:51,050 --> 00:27:59,389
use that to redirect a kernel pointer

522
00:27:55,360 --> 00:28:04,639
this code is used to allocate the hex

523
00:27:59,390 --> 00:28:09,460
800 bytes work buffer now we want to

524
00:28:04,640 --> 00:28:13,580
overwrite the value of V 4 plus hex 580

525
00:28:09,460 --> 00:28:16,120
why because by doing that and by

526
00:28:13,580 --> 00:28:19,220
executing that code we can dereference

527
00:28:16,120 --> 00:28:23,360
the kernel pointer from the world buffer

528
00:28:19,220 --> 00:28:27,530
which we control but for that we need to

529
00:28:23,360 --> 00:28:31,070
know where we for it so we need an new

530
00:28:27,530 --> 00:28:34,760
information leak so now we've system

531
00:28:31,070 --> 00:28:37,250
privileges I was looking for sis calls

532
00:28:34,760 --> 00:28:39,230
that are that were only accessible with

533
00:28:37,250 --> 00:28:43,520
system privileges and they found that

534
00:28:39,230 --> 00:28:46,910
one it's a simple bug where hex 40 bytes

535
00:28:43,520 --> 00:28:50,780
are allocated on the stack but only 8

536
00:28:46,910 --> 00:28:52,220
bytes are initialized the whole buffer

537
00:28:50,780 --> 00:28:56,090
is returned back to userland

538
00:28:52,220 --> 00:28:58,790
and to exploit which is caused some

539
00:28:56,090 --> 00:29:01,520
interesting Cisco's before and then

540
00:28:58,790 --> 00:29:05,059
invoke that Cisco

541
00:29:01,520 --> 00:29:09,800
to leak the contents all right we can

542
00:29:05,059 --> 00:29:14,899
use that primitive to leak text pointers

543
00:29:09,800 --> 00:29:17,000
or leak the kernel stack base and most

544
00:29:14,900 --> 00:29:21,679
importantly we can leak the value of V

545
00:29:17,000 --> 00:29:25,040
for now with that information we prepare

546
00:29:21,679 --> 00:29:28,670
a kernel Rob chain which we plant in the

547
00:29:25,040 --> 00:29:33,500
kernel stack and we prepare a small stop

548
00:29:28,670 --> 00:29:37,670
to pivot the stack this stop is stored

549
00:29:33,500 --> 00:29:41,900
in the world buffer now we launch the

550
00:29:37,670 --> 00:29:47,420
unlink attack and redirect the v4 + hex

551
00:29:41,900 --> 00:29:51,320
580 value to the stuff and we can voke

552
00:29:47,420 --> 00:29:55,480
the victim code and kick off our corner

553
00:29:51,320 --> 00:29:59,120
of chain that's it of their exploitation

554
00:29:55,480 --> 00:30:01,790
we allocate a readwrite page we copy our

555
00:29:59,120 --> 00:30:04,729
payload into the page and we mark it as

556
00:30:01,790 --> 00:30:07,790
read and executable and then we execute

557
00:30:04,730 --> 00:30:10,190
it in the payload we restore the heap

558
00:30:07,790 --> 00:30:12,290
data structure and remove signature

559
00:30:10,190 --> 00:30:17,059
checks and load the custom firmware

560
00:30:12,290 --> 00:30:19,220
framework and that's it that was the

561
00:30:17,059 --> 00:30:22,330
whole journey from MIPS userland

562
00:30:19,220 --> 00:30:22,330
to Arkana

563
00:30:22,880 --> 00:30:31,190
[Applause]

564
00:30:26,140 --> 00:30:36,020
sorry now I wanna showcase you the

565
00:30:31,190 --> 00:30:43,780
exploit chain all right so so customized

566
00:30:36,020 --> 00:30:47,920
PS Vita which a friend of mine made so

567
00:30:43,780 --> 00:30:52,129
we now have the Trinity application

568
00:30:47,920 --> 00:31:05,810
which is a PSP application and I we run

569
00:30:52,130 --> 00:31:12,050
it and we have a pool animation and I

570
00:31:05,810 --> 00:31:15,010
will get into the bootstrap called

571
00:31:12,050 --> 00:31:18,740
construct it's a reference to matrix and

572
00:31:15,010 --> 00:31:23,260
now we have the ability to launch

573
00:31:18,740 --> 00:31:30,410
homebrews example Vita shell which is a

574
00:31:23,260 --> 00:31:32,710
file manager that I created and welcome

575
00:31:30,410 --> 00:31:32,710
to head

576
00:31:33,660 --> 00:31:36,979
[Applause]

577
00:31:38,679 --> 00:31:45,649
now I want to show you some other things

578
00:31:41,509 --> 00:31:49,279
that I made for example adrenaline so as

579
00:31:45,649 --> 00:31:51,949
mentioned before like though there's a

580
00:31:49,279 --> 00:31:56,720
MIPS processor you can only play PSP

581
00:31:51,950 --> 00:31:59,480
games and I extended it and lo loaded

582
00:31:56,720 --> 00:32:04,519
the whole film we're into it such that

583
00:31:59,480 --> 00:32:16,990
we have a two in one device and if you

584
00:32:04,519 --> 00:32:20,509
had the PSP you would recognize it and

585
00:32:16,990 --> 00:32:23,750
the last thing we wanna show is Enzo is

586
00:32:20,509 --> 00:32:30,500
a it's a bootloader hack by T molecule

587
00:32:23,750 --> 00:32:33,529
and it allows you to hack the piece B

588
00:32:30,500 --> 00:32:42,409
this bit at the earliest stage and I

589
00:32:33,529 --> 00:32:45,950
will reboot the device and have a custom

590
00:32:42,409 --> 00:32:53,450
logo from T molecule and we put into

591
00:32:45,950 --> 00:32:56,240
Casper firmware directly alright back to

592
00:32:53,450 --> 00:32:58,850
the slide so chief connect code

593
00:32:56,240 --> 00:33:00,259
execution in the me processor by

594
00:32:58,850 --> 00:33:02,779
exploiting a type confusion

595
00:33:00,259 --> 00:33:06,169
vulnerability and by a race condition

596
00:33:02,779 --> 00:33:08,620
vulnerability and we escaped the PSP

597
00:33:06,169 --> 00:33:11,629
emulator by reading arbitrary memory

598
00:33:08,620 --> 00:33:14,899
using color space conversion and by

599
00:33:11,629 --> 00:33:19,219
smashing a stack and finally we

600
00:33:14,899 --> 00:33:21,229
escalated to our kernel privileges using

601
00:33:19,220 --> 00:33:25,220
a kernel stack info leak and a heap

602
00:33:21,230 --> 00:33:27,679
unlink attack the source code and a more

603
00:33:25,220 --> 00:33:30,529
tip right up is available at a blink

604
00:33:27,679 --> 00:33:35,110
please check it out if you want to see

605
00:33:30,529 --> 00:33:37,879
how all the things were implemented and

606
00:33:35,110 --> 00:33:40,779
in my final words I want to encourage

607
00:33:37,879 --> 00:33:43,969
you to join to see there are a lot of

608
00:33:40,779 --> 00:33:46,220
cool challenges so as mentioned before

609
00:33:43,970 --> 00:33:49,850
the network stack is based on net bsd

610
00:33:46,220 --> 00:33:51,660
4.0 which is quite old so maybe you can

611
00:33:49,850 --> 00:33:54,330
search for some box that

612
00:33:51,660 --> 00:33:56,640
have been fixed between 4.0 and the

613
00:33:54,330 --> 00:34:02,399
current version and applied them to the

614
00:33:56,640 --> 00:34:05,370
PS Vita for example a Buckeye found in

615
00:34:02,400 --> 00:34:08,040
ED PST I originally did current on the

616
00:34:05,370 --> 00:34:10,469
PS Vita but then I realize it was still

617
00:34:08,040 --> 00:34:13,679
available in the current version if

618
00:34:10,469 --> 00:34:15,689
you're into reverse engineering you can

619
00:34:13,679 --> 00:34:19,230
try to find vulnerabilities in the boot

620
00:34:15,690 --> 00:34:21,690
ROM or boot loader or you can try to

621
00:34:19,230 --> 00:34:24,469
reverse it in your driver and port into

622
00:34:21,690 --> 00:34:27,300
Linux which is work in progress and

623
00:34:24,469 --> 00:34:29,699
myself I have been working on a safe

624
00:34:27,300 --> 00:34:32,490
state feature which allows you to make a

625
00:34:29,699 --> 00:34:36,359
snapshot at any point and the later

626
00:34:32,489 --> 00:34:41,219
restore it which is technically really

627
00:34:36,360 --> 00:34:43,800
fun and I would like to express my

628
00:34:41,219 --> 00:34:47,178
gratitude towards T molecule for the

629
00:34:43,800 --> 00:34:50,100
driver prior research without them I

630
00:34:47,179 --> 00:34:50,399
wouldn't be able to all to do all this

631
00:34:50,100 --> 00:34:53,429
stuff

632
00:34:50,399 --> 00:34:56,040
I want to thank quick racer for the MIPS

633
00:34:53,429 --> 00:34:57,960
kernel vulnerabilities I want to thank

634
00:34:56,040 --> 00:35:00,090
my manager and my team for encouraging

635
00:34:57,960 --> 00:35:03,240
me and for supporting me

636
00:35:00,090 --> 00:35:06,270
thanks Apache and lip lower for the four

637
00:35:03,240 --> 00:35:08,959
slides ideas and for their friendship it

638
00:35:06,270 --> 00:35:12,860
tends to my family for everything and

639
00:35:08,960 --> 00:35:12,860
thank you for your attention

640
00:35:14,640 --> 00:35:16,700
you

