1
00:00:12,549 --> 00:00:18,259
hi everybody listen the technical team

2
00:00:16,430 --> 00:00:21,230
advised us to tell you that you should

3
00:00:18,260 --> 00:00:22,700
all stand up and kind of shake your legs

4
00:00:21,230 --> 00:00:25,250
so you're all awake for the last talk

5
00:00:22,700 --> 00:00:28,970
okay come on come on because our time is

6
00:00:25,250 --> 00:00:31,790
counting here you know okay okay

7
00:00:28,970 --> 00:00:37,430
everybody's awake hi I'm not sure if we

8
00:00:31,790 --> 00:00:39,140
did that right oh okay yeah so thanks

9
00:00:37,430 --> 00:00:41,480
for coming to our talk I know it's the

10
00:00:39,140 --> 00:00:44,390
last one of the day and it's actually

11
00:00:41,480 --> 00:00:47,538
the last one for blue hat so we'll try

12
00:00:44,390 --> 00:00:50,899
not to keep you here for past happy hour

13
00:00:47,539 --> 00:00:53,089
right so our talk is staying sharp and

14
00:00:50,899 --> 00:00:56,210
bringing covert Injection tradecraft oh

15
00:00:53,089 --> 00:00:59,149
man I'm working on IBM's Red Team

16
00:00:56,210 --> 00:01:02,539
x-force red and we're doing adversary

17
00:00:59,149 --> 00:01:06,110
emulation or for me it's more simulation

18
00:01:02,539 --> 00:01:08,000
if that distinction makes sense and the

19
00:01:06,110 --> 00:01:10,909
goal is hopefully to make our clients

20
00:01:08,000 --> 00:01:13,610
better prepared for when adversaries

21
00:01:10,909 --> 00:01:16,160
eventually come along to steal all their

22
00:01:13,610 --> 00:01:20,180
stuff basically their money their IP all

23
00:01:16,160 --> 00:01:21,950
of that stuff I should mention as well

24
00:01:20,180 --> 00:01:24,770
as it has some relation to what we're

25
00:01:21,950 --> 00:01:27,440
talking about that I was working for

26
00:01:24,770 --> 00:01:29,630
fire I before on the tour team so if

27
00:01:27,440 --> 00:01:31,940
there are any defenders I know the pain

28
00:01:29,630 --> 00:01:34,810
you feel when you have to put out fires

29
00:01:31,940 --> 00:01:38,210
every day left right and center and

30
00:01:34,810 --> 00:01:39,890
develop detections that scale you know

31
00:01:38,210 --> 00:01:43,309
that don't break your environment or

32
00:01:39,890 --> 00:01:48,410
your clients environments okay and I'm

33
00:01:43,310 --> 00:01:53,450
the wolverhampton soar strolling on the

34
00:01:48,410 --> 00:01:54,950
side okay short and sweet I like that so

35
00:01:53,450 --> 00:01:57,230
why are we talking about a memory

36
00:01:54,950 --> 00:01:59,690
tradecraft and there's like kind of two

37
00:01:57,230 --> 00:02:01,580
stories to that okay the red team's

38
00:01:59,690 --> 00:02:03,770
story and the blue team's story

39
00:02:01,580 --> 00:02:05,660
so on the red team's side we've been

40
00:02:03,770 --> 00:02:07,580
using in memory tradecraft for a long

41
00:02:05,660 --> 00:02:09,889
time it's not like a new thing right

42
00:02:07,580 --> 00:02:12,650
think about Steph and viewers a

43
00:02:09,889 --> 00:02:14,750
reflective DLL injection but we've not

44
00:02:12,650 --> 00:02:18,249
always been good at keeping that

45
00:02:14,750 --> 00:02:21,200
tradecraft up to date why mostly because

46
00:02:18,249 --> 00:02:23,840
what we've been doing just works right

47
00:02:21,200 --> 00:02:26,299
nobody is picking up on what we're doing

48
00:02:23,840 --> 00:02:28,220
however that situation is like changing

49
00:02:26,300 --> 00:02:31,220
the last two to three years a lot of

50
00:02:28,220 --> 00:02:33,349
security vendors and products are

51
00:02:31,220 --> 00:02:35,959
getting better at least some of the

52
00:02:33,349 --> 00:02:39,069
vendors okay we're not gonna name any

53
00:02:35,959 --> 00:02:41,930
names so you have things like breaking

54
00:02:39,069 --> 00:02:43,518
parent and child relationships right so

55
00:02:41,930 --> 00:02:44,090
those detection zhh can go out the

56
00:02:43,519 --> 00:02:46,459
window

57
00:02:44,090 --> 00:02:49,250
there's no magic right you just call

58
00:02:46,459 --> 00:02:51,980
create process with like startup info X

59
00:02:49,250 --> 00:02:54,530
and specify the parent or some

60
00:02:51,980 --> 00:02:57,768
undocumented functions like anti create

61
00:02:54,530 --> 00:02:59,750
user process and specify a handle the

62
00:02:57,769 --> 00:03:01,640
other thing is command-line argument

63
00:02:59,750 --> 00:03:04,610
detections can go out the window as well

64
00:03:01,640 --> 00:03:07,369
an attacker can spawn a process with

65
00:03:04,610 --> 00:03:09,650
innocuous arguments in a suspended State

66
00:03:07,370 --> 00:03:11,930
and then you're logging infrastructure

67
00:03:09,650 --> 00:03:13,880
picks up all of that data and then the

68
00:03:11,930 --> 00:03:16,280
attacker comes in and rewrites the peb

69
00:03:13,880 --> 00:03:18,680
and then when that process is resumed

70
00:03:16,280 --> 00:03:21,470
malicious arguments execute right

71
00:03:18,680 --> 00:03:23,540
you also have in-memory evasions that

72
00:03:21,470 --> 00:03:25,700
have been added so when cobol strike

73
00:03:23,540 --> 00:03:28,459
reflectively loads a module you can

74
00:03:25,700 --> 00:03:30,920
stomp the module headers in memory

75
00:03:28,459 --> 00:03:32,859
presumably some memory scanners are

76
00:03:30,920 --> 00:03:35,869
looking for some of that stuff and

77
00:03:32,859 --> 00:03:38,209
finally you have so-called module

78
00:03:35,870 --> 00:03:39,859
stamping where you can load a legitimate

79
00:03:38,209 --> 00:03:41,840
module into the process and then

80
00:03:39,859 --> 00:03:44,989
override it with the malicious module

81
00:03:41,840 --> 00:03:46,459
right and then when that module executes

82
00:03:44,989 --> 00:03:48,890
it looks like it's coming from that

83
00:03:46,459 --> 00:03:50,989
legitimate module we have something

84
00:03:48,890 --> 00:03:53,000
similar we're gonna talk about later

85
00:03:50,989 --> 00:03:55,519
today the over we'll discuss that in

86
00:03:53,000 --> 00:03:59,299
more detail and then on the blue team

87
00:03:55,519 --> 00:04:01,760
side it's pretty simple offense informs

88
00:03:59,299 --> 00:04:04,160
defense right so changes in offense

89
00:04:01,760 --> 00:04:06,638
either through our security community or

90
00:04:04,160 --> 00:04:09,739
malicious actors highlight problem

91
00:04:06,639 --> 00:04:12,739
problem areas and then defense kind of

92
00:04:09,739 --> 00:04:15,709
adapts and creates visibility or data

93
00:04:12,739 --> 00:04:21,019
that defenders can use in those areas a

94
00:04:15,709 --> 00:04:23,000
good example is OMSI so first there was

95
00:04:21,019 --> 00:04:24,830
a MIDI in PowerShell then it came to

96
00:04:23,000 --> 00:04:29,410
office for phishing payloads and now

97
00:04:24,830 --> 00:04:31,789
it's in dotnet right and why are we

98
00:04:29,410 --> 00:04:33,979
talking about this today and releasing

99
00:04:31,789 --> 00:04:36,229
some tools one of the reasons is that

100
00:04:33,979 --> 00:04:37,248
defenders need models they can use to

101
00:04:36,229 --> 00:04:39,679
reproduce that

102
00:04:37,249 --> 00:04:42,049
trade craft and develop detections okay

103
00:04:39,679 --> 00:04:46,279
now these things we're talking about are

104
00:04:42,049 --> 00:04:48,308
not like net new techniques okay thread

105
00:04:46,279 --> 00:04:50,149
groups already doing these things and

106
00:04:48,309 --> 00:04:53,119
unfortunately I should tell you that

107
00:04:50,149 --> 00:04:56,299
even like some low-rent crypto miners

108
00:04:53,119 --> 00:04:57,889
that we might consider to be trash they

109
00:04:56,299 --> 00:05:01,669
are doing that as well because they may

110
00:04:57,889 --> 00:05:03,439
be purchasing like loaders from the

111
00:05:01,669 --> 00:05:08,089
black market or whatever they do

112
00:05:03,439 --> 00:05:09,889
basically final point is not super

113
00:05:08,089 --> 00:05:12,349
important but it's just a note that

114
00:05:09,889 --> 00:05:14,239
whenever you can as a defender you

115
00:05:12,349 --> 00:05:16,989
should focus on principles and

116
00:05:14,239 --> 00:05:19,039
primitives to catch behavior instead of

117
00:05:16,989 --> 00:05:20,779
signature ink tooling right I'm not

118
00:05:19,039 --> 00:05:24,110
saying you shouldn't signature tooling

119
00:05:20,779 --> 00:05:25,759
you should okay so specifically we're

120
00:05:24,110 --> 00:05:28,339
going to be talking about doing in

121
00:05:25,759 --> 00:05:30,829
memory tradecraft using.net so dotnet

122
00:05:28,339 --> 00:05:32,569
has been used by adversaries a lot using

123
00:05:30,829 --> 00:05:34,459
c-sharp to write your mouth

124
00:05:32,569 --> 00:05:37,749
malware people thought you were probably

125
00:05:34,459 --> 00:05:39,979
a skidding but it's changed recently

126
00:05:37,749 --> 00:05:42,079
dotnet has become a lot more powerful

127
00:05:39,979 --> 00:05:43,998
it's the permed platform for development

128
00:05:42,079 --> 00:05:46,429
on Windows for application development

129
00:05:43,999 --> 00:05:49,459
as such it has access to a lot of API is

130
00:05:46,429 --> 00:05:52,909
both nedp eyes and access to the

131
00:05:49,459 --> 00:05:54,919
underlying 132 NT comm api's all the

132
00:05:52,909 --> 00:05:57,919
other normal API is available on Windows

133
00:05:54,919 --> 00:05:59,508
as dotnet has become more powerful so

134
00:05:57,919 --> 00:06:02,269
has the malware that's leveraged it and

135
00:05:59,509 --> 00:06:04,759
the modern dotnet malware as well takes

136
00:06:02,269 --> 00:06:06,439
advantage of features that are specific

137
00:06:04,759 --> 00:06:09,379
to dotnet and not available in other

138
00:06:06,439 --> 00:06:11,959
api's the main reason people are able to

139
00:06:09,379 --> 00:06:14,629
abuse it so easily is that in like two

140
00:06:11,959 --> 00:06:17,059
lines of code you can load and execute a

141
00:06:14,629 --> 00:06:19,549
dotnet assembly which is a dotnet exe or

142
00:06:17,059 --> 00:06:21,499
DLL from memory and execute it without

143
00:06:19,549 --> 00:06:23,269
touching anything on disk and that's not

144
00:06:21,499 --> 00:06:27,559
a bug that's actually a feature of

145
00:06:23,269 --> 00:06:29,899
dotnet for some reason so it can be run

146
00:06:27,559 --> 00:06:32,929
from memory it's hard to inspect at

147
00:06:29,899 --> 00:06:35,029
scale across the whole enterprise also

148
00:06:32,929 --> 00:06:36,979
the reason people have shifted to it

149
00:06:35,029 --> 00:06:39,199
recently the past year for a lot of

150
00:06:36,979 --> 00:06:40,849
their post exploitation is they have

151
00:06:39,199 --> 00:06:42,559
been relying on PowerShell for the past

152
00:06:40,849 --> 00:06:43,878
few years a lot of attackers have been

153
00:06:42,559 --> 00:06:47,179
using PowerShell and getting away with

154
00:06:43,879 --> 00:06:49,579
it but recently when Microsoft has added

155
00:06:47,179 --> 00:06:50,929
a lot of introspection to PowerShell the

156
00:06:49,579 --> 00:06:53,600
vetted script block logging

157
00:06:50,930 --> 00:06:55,520
to log in command logging MZ with all of

158
00:06:53,600 --> 00:06:57,259
these new features it's getting harder

159
00:06:55,520 --> 00:06:59,440
to get away with using power so even if

160
00:06:57,259 --> 00:07:02,810
you're doing it from memory so as such

161
00:06:59,440 --> 00:07:04,130
because PowerShell is net and writing a

162
00:07:02,810 --> 00:07:06,650
c-sharp or whatever other done that

163
00:07:04,130 --> 00:07:08,210
language you want is also done it you

164
00:07:06,650 --> 00:07:09,948
just have to go a layer deeper from

165
00:07:08,210 --> 00:07:11,719
powershell and now you can still load

166
00:07:09,949 --> 00:07:13,490
your tools from memory but you're not

167
00:07:11,720 --> 00:07:15,380
subject to all of the introspection of

168
00:07:13,490 --> 00:07:17,930
powershell so this is what they're doing

169
00:07:15,380 --> 00:07:20,210
they have added MZ to net assembly

170
00:07:17,930 --> 00:07:21,470
loading now in version 4.8 that's not

171
00:07:20,210 --> 00:07:23,840
installing everything and it can be

172
00:07:21,470 --> 00:07:25,789
bypassed in some ways the other thing is

173
00:07:23,840 --> 00:07:27,049
C sharp or whatever your preferred done

174
00:07:25,789 --> 00:07:28,639
that language is is really easy to

175
00:07:27,050 --> 00:07:30,710
develop in there been a lot of new

176
00:07:28,639 --> 00:07:32,930
toolkits released that you leverage

177
00:07:30,710 --> 00:07:34,400
dotnet some examples are covenant and

178
00:07:32,930 --> 00:07:36,440
silent trinity which are used by red

179
00:07:34,400 --> 00:07:38,659
teams and also by some real world thread

180
00:07:36,440 --> 00:07:39,800
actors and it's important to note that

181
00:07:38,660 --> 00:07:43,610
everything we're talking about here

182
00:07:39,800 --> 00:07:45,410
there are no 0 days or no exploits per

183
00:07:43,610 --> 00:07:47,930
se there are no bugs all of these are

184
00:07:45,410 --> 00:07:51,500
abusive illegitimate features for post

185
00:07:47,930 --> 00:07:55,699
exploitation and export and executing on

186
00:07:51,500 --> 00:07:58,940
target covertly so the other thing is

187
00:07:55,699 --> 00:08:00,620
that even though you can load the stuff

188
00:07:58,940 --> 00:08:03,440
from memory if you inject medicine

189
00:08:00,620 --> 00:08:04,970
bleated on that code into a process you

190
00:08:03,440 --> 00:08:07,639
will still get some anomalous behavior

191
00:08:04,970 --> 00:08:10,280
we part of why we've been doing this

192
00:08:07,639 --> 00:08:12,530
work is to provide options for tool

193
00:08:10,280 --> 00:08:13,460
developers to reduce that noise but you

194
00:08:12,530 --> 00:08:16,929
do get some anomalous behavior

195
00:08:13,460 --> 00:08:20,599
especially assembly image loads and

196
00:08:16,930 --> 00:08:23,360
module loads so everything we're talking

197
00:08:20,599 --> 00:08:24,590
about as well our existing TTP's they've

198
00:08:23,360 --> 00:08:26,120
been used for years they've been

199
00:08:24,590 --> 00:08:27,710
observed in the real world we're not

200
00:08:26,120 --> 00:08:30,949
showing anything new though we do have

201
00:08:27,710 --> 00:08:32,360
some new twists on things the other

202
00:08:30,949 --> 00:08:35,570
point that was going to make was that

203
00:08:32,360 --> 00:08:37,279
because attackers are using dotnet for

204
00:08:35,570 --> 00:08:39,320
post exploitation a lot of time so say

205
00:08:37,279 --> 00:08:40,760
they have some interactive tool yet they

206
00:08:39,320 --> 00:08:43,010
have an implant already on the system

207
00:08:40,760 --> 00:08:45,890
all of their post exploitation tools are

208
00:08:43,010 --> 00:08:47,029
done that assemblies because they're

209
00:08:45,890 --> 00:08:48,860
using that for all their post

210
00:08:47,029 --> 00:08:50,810
exploitation that can be a single point

211
00:08:48,860 --> 00:08:52,940
of failure so if you can catch it

212
00:08:50,810 --> 00:08:54,560
reliably then it could be a pretty good

213
00:08:52,940 --> 00:08:55,700
detection mechanism to catch whatever

214
00:08:54,560 --> 00:09:00,680
they're doing after they've gained

215
00:08:55,700 --> 00:09:02,480
access so specifically all the work that

216
00:09:00,680 --> 00:09:04,339
we've been doing has put has been put

217
00:09:02,480 --> 00:09:04,730
into sharps Floyd no sharps Lloyd was

218
00:09:04,339 --> 00:09:06,800
not

219
00:09:04,730 --> 00:09:10,430
created by us it was created by Ryan

220
00:09:06,800 --> 00:09:12,680
Cobb at Specter ops it is a library of

221
00:09:10,430 --> 00:09:15,290
post exploitation tactics techniques and

222
00:09:12,680 --> 00:09:17,689
procedures it's been integrated into

223
00:09:15,290 --> 00:09:19,969
many remote access tools many implants

224
00:09:17,690 --> 00:09:21,760
both used by real whatever series and

225
00:09:19,970 --> 00:09:24,050
created by red teams such as covenant

226
00:09:21,760 --> 00:09:27,019
covenant we actually I'm gonna show the

227
00:09:24,050 --> 00:09:28,880
demo at a time however it's a done net

228
00:09:27,019 --> 00:09:31,279
based command control framework that

229
00:09:28,880 --> 00:09:32,899
allows you to write c-sharp script sort

230
00:09:31,279 --> 00:09:34,730
of like you previously would be able to

231
00:09:32,899 --> 00:09:36,620
use for power show and run those

232
00:09:34,730 --> 00:09:37,880
dynamically compile them send them to

233
00:09:36,620 --> 00:09:40,070
the implant load it from memory

234
00:09:37,880 --> 00:09:42,380
but it has access to sharps way to all

235
00:09:40,070 --> 00:09:45,139
the post exploitation tax tasks have

236
00:09:42,380 --> 00:09:50,209
access to sharps void as the library for

237
00:09:45,139 --> 00:09:52,160
techniques yeah okay so you already got

238
00:09:50,209 --> 00:09:53,959
like kind of an introduction on sharps

239
00:09:52,160 --> 00:09:56,660
lloyd wright's so in these slides i just

240
00:09:53,959 --> 00:09:59,510
want to briefly explain some of the core

241
00:09:56,660 --> 00:10:01,790
principles of dynamic invoke that's

242
00:09:59,510 --> 00:10:03,350
probably not the right term but you'll

243
00:10:01,790 --> 00:10:06,170
see you'll see what i'm talking about so

244
00:10:03,350 --> 00:10:08,990
the first thing is we are plus plus

245
00:10:06,170 --> 00:10:13,040
undocumented okay so whenever we're

246
00:10:08,990 --> 00:10:15,529
using AP is in dynamic invoke we're

247
00:10:13,040 --> 00:10:17,810
always at that undocumented layer right

248
00:10:15,529 --> 00:10:21,130
you can see an example here of a kind of

249
00:10:17,810 --> 00:10:24,229
API call sink so usually you have

250
00:10:21,130 --> 00:10:26,959
documented api's that call into extended

251
00:10:24,230 --> 00:10:30,769
api's and then call into undocumented

252
00:10:26,959 --> 00:10:33,469
api's you may ask like why are we doing

253
00:10:30,769 --> 00:10:36,709
that and there's two reasons simple

254
00:10:33,470 --> 00:10:39,709
reasons a lot of times undocumented the

255
00:10:36,709 --> 00:10:41,420
api is give you some easy access to

256
00:10:39,709 --> 00:10:44,479
functionality that you don't have in the

257
00:10:41,420 --> 00:10:46,339
documented version or you simply don't

258
00:10:44,480 --> 00:10:48,110
have those features at all in the

259
00:10:46,339 --> 00:10:50,889
document subversions right that's one

260
00:10:48,110 --> 00:10:54,079
reason and the other reason is if you

261
00:10:50,889 --> 00:10:56,800
are facing some kind of security product

262
00:10:54,079 --> 00:10:59,630
which is doing hooking hopefully

263
00:10:56,800 --> 00:11:01,729
statistically if you if you're here at

264
00:10:59,630 --> 00:11:04,490
the undocumented layer you're gonna be

265
00:11:01,730 --> 00:11:06,800
evading some percentage of detections

266
00:11:04,490 --> 00:11:09,709
right if somebody is hooking load

267
00:11:06,800 --> 00:11:13,439
library exw you'll be fine right just

268
00:11:09,709 --> 00:11:16,979
some percentage game they were playing

269
00:11:13,440 --> 00:11:19,920
now in dynamic in vogue we're not using

270
00:11:16,980 --> 00:11:22,560
P invoke at all the woven we'll talk a

271
00:11:19,920 --> 00:11:24,300
bit about why that is later but the

272
00:11:22,560 --> 00:11:27,388
question is how do we replace that

273
00:11:24,300 --> 00:11:29,969
functionality so we use our or at least

274
00:11:27,389 --> 00:11:32,910
my most favorite class in that the

275
00:11:29,970 --> 00:11:35,699
Marshall class love I love it okay

276
00:11:32,910 --> 00:11:38,189
and we're using get delegate for a

277
00:11:35,699 --> 00:11:39,689
function pointer there so if you're

278
00:11:38,189 --> 00:11:42,269
unfamiliar with how that works

279
00:11:39,689 --> 00:11:44,160
a delicate is kind of is kind of like a

280
00:11:42,269 --> 00:11:46,529
definition for a function you have like

281
00:11:44,160 --> 00:11:48,420
a return type the arguments and the

282
00:11:46,529 --> 00:11:51,269
argument types and then if you have a

283
00:11:48,420 --> 00:11:53,250
pointer to a function you can say this

284
00:11:51,269 --> 00:11:56,129
pointer is like this delegate

285
00:11:53,250 --> 00:11:58,649
essentially and then you can just call

286
00:11:56,129 --> 00:12:02,670
that function as normal and that gets us

287
00:11:58,649 --> 00:12:04,740
around using P invoke however we need to

288
00:12:02,670 --> 00:12:07,529
be able to resolve function pointers so

289
00:12:04,740 --> 00:12:10,529
we're just doing some stuff there to do

290
00:12:07,529 --> 00:12:12,839
that manually okay so normally you'd

291
00:12:10,529 --> 00:12:14,790
call like load library and then you'd

292
00:12:12,839 --> 00:12:17,189
get a handle to the library but that's

293
00:12:14,790 --> 00:12:20,519
really a base address right it's not a

294
00:12:17,189 --> 00:12:22,589
real handle and then you'd call get proc

295
00:12:20,519 --> 00:12:25,920
address to get the the address of the

296
00:12:22,589 --> 00:12:30,389
function so we need to replace these two

297
00:12:25,920 --> 00:12:31,829
components okay so for load library what

298
00:12:30,389 --> 00:12:35,939
we can do is just simply read the

299
00:12:31,829 --> 00:12:38,508
process peb all of these entries are not

300
00:12:35,939 --> 00:12:41,130
super important but you have like a

301
00:12:38,509 --> 00:12:43,050
belly our data structure which has some

302
00:12:41,130 --> 00:12:45,930
linked lists of modules that are loaded

303
00:12:43,050 --> 00:12:47,699
by the process such as the in load order

304
00:12:45,930 --> 00:12:50,250
module list and then if you loop that

305
00:12:47,699 --> 00:12:52,139
list you can get all the modules that

306
00:12:50,250 --> 00:12:55,079
are loaded by the process and their base

307
00:12:52,139 --> 00:12:57,600
address so that kind of replaces the

308
00:12:55,079 --> 00:13:00,000
functionality of load library and then

309
00:12:57,600 --> 00:13:02,250
to actually get the address of the

310
00:13:00,000 --> 00:13:06,240
functions we're interested in you can

311
00:13:02,250 --> 00:13:09,149
just do some pointer math in the in the

312
00:13:06,240 --> 00:13:11,699
PE you check out the PE headers you find

313
00:13:09,149 --> 00:13:13,879
the image export directory and then you

314
00:13:11,699 --> 00:13:16,949
can loop all of the exports of that

315
00:13:13,879 --> 00:13:18,930
module right kind of like I'm sure

316
00:13:16,949 --> 00:13:22,019
you've seen that in malware if you're in

317
00:13:18,930 --> 00:13:23,969
defense so we're just on par there okay

318
00:13:22,019 --> 00:13:26,490
and then you can look up by name by

319
00:13:23,970 --> 00:13:29,630
ordinal and I added like eight

320
00:13:26,490 --> 00:13:34,620
Mack md5 which is like a keyed hash

321
00:13:29,630 --> 00:13:36,450
lookup that you can do okay yeah one of

322
00:13:34,620 --> 00:13:39,270
the core features of dynamic invoke is

323
00:13:36,450 --> 00:13:42,930
the ability to manually map executables

324
00:13:39,270 --> 00:13:45,480
and DLLs and call them either by their

325
00:13:42,930 --> 00:13:49,859
entry point or by DLL main process

326
00:13:45,480 --> 00:13:53,310
attached right and also call exports of

327
00:13:49,860 --> 00:13:57,680
dll's etc so I implemented a manual

328
00:13:53,310 --> 00:14:00,719
mapper which is more work than it seems

329
00:13:57,680 --> 00:14:04,319
it's a bit crude currently it needs a

330
00:14:00,720 --> 00:14:05,940
bit of loving ok but it does the work

331
00:14:04,320 --> 00:14:08,010
mostly right you can't kind of see the

332
00:14:05,940 --> 00:14:10,350
process here you allocate the size of

333
00:14:08,010 --> 00:14:12,899
the image from the optional header then

334
00:14:10,350 --> 00:14:15,320
you write the header the sections then

335
00:14:12,899 --> 00:14:17,430
you have to relocate the module because

336
00:14:15,320 --> 00:14:19,740
it's not going to be at its preferred

337
00:14:17,430 --> 00:14:21,719
base then you have to fix the import

338
00:14:19,740 --> 00:14:24,089
address tables so that any functions

339
00:14:21,720 --> 00:14:26,339
from that module can be resolved and

340
00:14:24,089 --> 00:14:28,730
then you have to set the permissions

341
00:14:26,339 --> 00:14:35,790
right so like the headers are read-only

342
00:14:28,730 --> 00:14:37,500
the text section is read execute etc and

343
00:14:35,790 --> 00:14:40,050
then the last thing that we wanted to do

344
00:14:37,500 --> 00:14:43,079
was implement a generic syscall wrapper

345
00:14:40,050 --> 00:14:47,099
so Cisco's are great if you can use them

346
00:14:43,079 --> 00:14:50,430
operationally but the problem is that

347
00:14:47,100 --> 00:14:53,310
sis calls the call stubs for those sis

348
00:14:50,430 --> 00:14:57,540
calls changed slightly from OS to OS and

349
00:14:53,310 --> 00:15:03,119
most certainly between 32 and 64-bit and

350
00:14:57,540 --> 00:15:05,069
on whoa 64 right that's one problem and

351
00:15:03,120 --> 00:15:07,649
the other problem is that sis calls are

352
00:15:05,070 --> 00:15:09,990
essentially identified by an ID an

353
00:15:07,649 --> 00:15:13,140
integer and that integer is changing all

354
00:15:09,990 --> 00:15:15,480
the time so we don't want to maintain

355
00:15:13,140 --> 00:15:22,470
lists of those integers like on

356
00:15:15,480 --> 00:15:25,770
jerusaiem functionality to manually map

357
00:15:22,470 --> 00:15:29,839
so we're mapping a duplicate of anti dll

358
00:15:25,770 --> 00:15:32,459
into the process and then we can just

359
00:15:29,839 --> 00:15:36,779
resolve the address of that cisco and

360
00:15:32,459 --> 00:15:39,160
copy out like 50 bytes or 60 bytes into

361
00:15:36,779 --> 00:15:43,060
our process as our

362
00:15:39,160 --> 00:15:47,770
and then we can just call this his call

363
00:15:43,060 --> 00:15:51,819
normally why are we mapping a duplicate

364
00:15:47,770 --> 00:15:53,890
the reason is that your security product

365
00:15:51,820 --> 00:15:56,620
may be hooking those sis calls so if

366
00:15:53,890 --> 00:15:58,480
you're copying from anti dll that's

367
00:15:56,620 --> 00:16:03,700
already loaded by your process you may

368
00:15:58,480 --> 00:16:04,930
be copying those hooks as well so why

369
00:16:03,700 --> 00:16:06,820
did we go to all the effort of

370
00:16:04,930 --> 00:16:08,859
developing the invoke so specifically

371
00:16:06,820 --> 00:16:10,990
this was designed to give offensive tool

372
00:16:08,860 --> 00:16:12,970
developers options say you're writing

373
00:16:10,990 --> 00:16:14,590
some post exploitation tool you want to

374
00:16:12,970 --> 00:16:17,590
have be able to determine how you

375
00:16:14,590 --> 00:16:19,300
reference unmanaged API calls normally

376
00:16:17,590 --> 00:16:21,370
if you're just using P invoke then there

377
00:16:19,300 --> 00:16:23,170
are two main indicators from the result

378
00:16:21,370 --> 00:16:24,760
of that first of all if you're done that

379
00:16:23,170 --> 00:16:26,410
assembly has dropped to disk then you

380
00:16:24,760 --> 00:16:28,150
will have a static import static

381
00:16:26,410 --> 00:16:30,209
reference in your IAT of that dotnet

382
00:16:28,150 --> 00:16:32,260
assembly so anything that scans that

383
00:16:30,210 --> 00:16:34,090
executable on disk will see that

384
00:16:32,260 --> 00:16:37,240
reference but additionally as well

385
00:16:34,090 --> 00:16:39,190
you're making calls to call to the API

386
00:16:37,240 --> 00:16:41,740
calls that you're referencing which will

387
00:16:39,190 --> 00:16:44,230
be caught in any hooks so we wanted to

388
00:16:41,740 --> 00:16:45,880
give tool developers the option and how

389
00:16:44,230 --> 00:16:47,620
they reference those that avoids P

390
00:16:45,880 --> 00:16:49,810
invoked so one of the main things that

391
00:16:47,620 --> 00:16:51,520
you want to avoid is image load events

392
00:16:49,810 --> 00:16:52,780
so when you've injected into a process

393
00:16:51,520 --> 00:16:54,850
and you start running things from that

394
00:16:52,780 --> 00:16:56,199
process you're gonna generate image load

395
00:16:54,850 --> 00:16:59,170
events or otherwise known as mod load

396
00:16:56,200 --> 00:17:00,610
events you want to avoid generating mod

397
00:16:59,170 --> 00:17:02,079
load of vents that are anomalous for

398
00:17:00,610 --> 00:17:04,540
that process especially if you've

399
00:17:02,080 --> 00:17:06,490
injected into a legitimate process a

400
00:17:04,540 --> 00:17:08,290
process that normally runs on Windows

401
00:17:06,490 --> 00:17:10,000
you don't want to start loading things

402
00:17:08,290 --> 00:17:12,250
that that process has never in history

403
00:17:10,000 --> 00:17:14,500
loaded before that's pretty enormous so

404
00:17:12,250 --> 00:17:16,839
using a manually map using manual

405
00:17:14,500 --> 00:17:18,459
mapping you can instead map your own

406
00:17:16,839 --> 00:17:20,139
copy of whatever DLL that you want to

407
00:17:18,459 --> 00:17:22,689
use and reference calls from that

408
00:17:20,140 --> 00:17:24,010
completely bypassing any hook any hooks

409
00:17:22,689 --> 00:17:26,079
that have been placed in the normal

410
00:17:24,010 --> 00:17:28,270
normally loaded versions of those

411
00:17:26,079 --> 00:17:29,919
modules or you can walk the pad which

412
00:17:28,270 --> 00:17:32,110
will bypass some versions of API hooking

413
00:17:29,920 --> 00:17:33,940
so generally speaking the options that

414
00:17:32,110 --> 00:17:37,120
we provided allows you to bypass many

415
00:17:33,940 --> 00:17:38,950
types of API hooking x' api hooks with

416
00:17:37,120 --> 00:17:42,459
manual mapping you can theoretically

417
00:17:38,950 --> 00:17:45,550
bypass all of the user land versions of

418
00:17:42,460 --> 00:17:48,450
API hooking although you won't bypass

419
00:17:45,550 --> 00:17:50,639
any hooks that the module you've mapped

420
00:17:48,450 --> 00:17:52,260
is right they give it's referencing

421
00:17:50,639 --> 00:17:54,000
another module that's already loaded in

422
00:17:52,260 --> 00:17:55,559
there hooks in that module and of course

423
00:17:54,000 --> 00:17:58,350
you won't you will still trigger those

424
00:17:55,559 --> 00:18:00,269
but any any calls that you make into the

425
00:17:58,350 --> 00:18:02,610
module that you've manually mapped will

426
00:18:00,269 --> 00:18:04,139
not be hooked so the other things is

427
00:18:02,610 --> 00:18:06,449
that you want to avoid memory scanners

428
00:18:04,139 --> 00:18:07,949
now manual mapping is nice because you

429
00:18:06,450 --> 00:18:10,350
can avoid the API hooks when it comes

430
00:18:07,950 --> 00:18:12,389
with the downside that now you have this

431
00:18:10,350 --> 00:18:15,600
giant D file just sitting around in

432
00:18:12,389 --> 00:18:17,490
memory which is not normal so if you

433
00:18:15,600 --> 00:18:19,230
want to avoid memory scanners you're

434
00:18:17,490 --> 00:18:21,779
gonna have to find ways to hide your

435
00:18:19,230 --> 00:18:24,539
code into what appear to be more

436
00:18:21,779 --> 00:18:26,730
legitimate parts of the memory in your

437
00:18:24,539 --> 00:18:28,679
process there's a good blog post by

438
00:18:26,730 --> 00:18:30,630
Forster or about how to do this with

439
00:18:28,679 --> 00:18:33,029
shellcode where he hides show code in

440
00:18:30,630 --> 00:18:35,639
the exports of legit legitimately loaded

441
00:18:33,029 --> 00:18:36,990
modules so when you call that show code

442
00:18:35,639 --> 00:18:39,689
it looks like you're executing a

443
00:18:36,990 --> 00:18:42,000
legitimate export of a yellow so the

444
00:18:39,690 --> 00:18:45,539
other thing is that you want to when you

445
00:18:42,000 --> 00:18:48,230
manually map map that module into memory

446
00:18:45,539 --> 00:18:50,639
that's backed by a file on disk so

447
00:18:48,230 --> 00:18:53,460
normally if you just manually map you're

448
00:18:50,639 --> 00:18:56,039
mapping the DLL into dynamically

449
00:18:53,460 --> 00:18:58,169
allocated memory generally speaking if

450
00:18:56,039 --> 00:18:59,639
you're dynamically allocating code into

451
00:18:58,169 --> 00:19:01,139
memory and then executing if there's

452
00:18:59,639 --> 00:19:03,479
some sort of injection going on that

453
00:19:01,139 --> 00:19:05,428
doesn't normally happen so you want to

454
00:19:03,480 --> 00:19:10,679
be able to hide your code inside of

455
00:19:05,429 --> 00:19:11,940
legitimate modules so specifically when

456
00:19:10,679 --> 00:19:14,460
you're using the invoke you should

457
00:19:11,940 --> 00:19:16,649
always try to use D invoke whenever

458
00:19:14,460 --> 00:19:18,480
possible rather than folks to avoid

459
00:19:16,649 --> 00:19:20,729
those static imports and the IE and

460
00:19:18,480 --> 00:19:22,590
those image loaded events don't use load

461
00:19:20,730 --> 00:19:25,019
library because that will be subject to

462
00:19:22,590 --> 00:19:27,029
the eye hooks instead use map module to

463
00:19:25,019 --> 00:19:30,210
memory so that's the manual mapping

464
00:19:27,029 --> 00:19:31,980
function that we've added lets you point

465
00:19:30,210 --> 00:19:33,480
to a file on disk in a will manually map

466
00:19:31,980 --> 00:19:34,740
that and then give you the address the

467
00:19:33,480 --> 00:19:36,809
base address of where it's been mapped

468
00:19:34,740 --> 00:19:39,059
in the memory there there are overloads

469
00:19:36,809 --> 00:19:40,740
as well to give it a byte array so you

470
00:19:39,059 --> 00:19:43,408
can just give it a byte array instead of

471
00:19:40,740 --> 00:19:44,850
a file on disk right right so most of

472
00:19:43,409 --> 00:19:46,620
the stuff we have an option of being

473
00:19:44,850 --> 00:19:49,019
able to mail in map from disk or

474
00:19:46,620 --> 00:19:52,110
manually map from a byte array in C

475
00:19:49,019 --> 00:19:54,000
sharp so also avoid get proc address we

476
00:19:52,110 --> 00:19:55,918
provide a function we call get export

477
00:19:54,000 --> 00:19:57,899
address which regardless of where a

478
00:19:55,919 --> 00:20:00,389
module has been mapped into it in memory

479
00:19:57,899 --> 00:20:02,399
it will walk the export table of that

480
00:20:00,389 --> 00:20:04,560
module and memory to find the a guy

481
00:20:02,400 --> 00:20:06,000
you want to use and then you will give

482
00:20:04,560 --> 00:20:08,460
it you a pointer which you can then use

483
00:20:06,000 --> 00:20:09,870
to past addy invoke and call that

484
00:20:08,460 --> 00:20:12,210
passing in whatever function signature

485
00:20:09,870 --> 00:20:13,979
you want returning whatever type of

486
00:20:12,210 --> 00:20:16,650
variable you want passing in whatever

487
00:20:13,980 --> 00:20:18,510
arguments you want additionally that

488
00:20:16,650 --> 00:20:20,490
function is provided with dynamic

489
00:20:18,510 --> 00:20:22,860
function invoke there's also dynamic API

490
00:20:20,490 --> 00:20:24,630
invoke which automates a lot of this

491
00:20:22,860 --> 00:20:27,020
process you don't have to go manually

492
00:20:24,630 --> 00:20:29,850
find all that stuff it will look in the

493
00:20:27,020 --> 00:20:32,250
pad or the currently loaded modules or

494
00:20:29,850 --> 00:20:34,320
load the thing using load or load do low

495
00:20:32,250 --> 00:20:35,640
if it's not already been loaded it just

496
00:20:34,320 --> 00:20:37,050
doesn't do the manual mapping that

497
00:20:35,640 --> 00:20:40,950
you're gonna have to decide to do on

498
00:20:37,050 --> 00:20:42,270
your own so one component of this is

499
00:20:40,950 --> 00:20:44,340
module overloading we talked about

500
00:20:42,270 --> 00:20:46,920
hiding a module and disk but how you

501
00:20:44,340 --> 00:20:49,290
actually do that it turns out that in D

502
00:20:46,920 --> 00:20:54,180
create section which is a sis call has

503
00:20:49,290 --> 00:20:56,040
these options SEC image and a file

504
00:20:54,180 --> 00:20:58,320
handle if you pass in a file handle and

505
00:20:56,040 --> 00:21:01,860
the special second image flag it will

506
00:20:58,320 --> 00:21:02,909
actually map that file into memory into

507
00:21:01,860 --> 00:21:06,240
memory back

508
00:21:02,910 --> 00:21:09,270
so I file back to memory doing a lot of

509
00:21:06,240 --> 00:21:11,640
the work of normally loading any module

510
00:21:09,270 --> 00:21:14,460
it doesn't use the normal load or load

511
00:21:11,640 --> 00:21:17,520
DLL but it does generate an image load

512
00:21:14,460 --> 00:21:20,310
event so you create a section from a

513
00:21:17,520 --> 00:21:22,500
file passing in that special flag then

514
00:21:20,310 --> 00:21:24,389
you map a view of that shared memory

515
00:21:22,500 --> 00:21:26,370
section to either your current process

516
00:21:24,390 --> 00:21:29,280
or a different process and you will have

517
00:21:26,370 --> 00:21:32,010
a copy of that module in memory now you

518
00:21:29,280 --> 00:21:35,129
have access to some file back to memory

519
00:21:32,010 --> 00:21:36,780
so from there you overwrite the module

520
00:21:35,130 --> 00:21:38,850
that it automatically mapped for you

521
00:21:36,780 --> 00:21:41,730
with the module that you want to execute

522
00:21:38,850 --> 00:21:43,740
from memory then when you execute from

523
00:21:41,730 --> 00:21:45,450
that section of memory it appears like

524
00:21:43,740 --> 00:21:48,270
you're executing from file back to

525
00:21:45,450 --> 00:21:49,770
memory so we have a couple ways to do

526
00:21:48,270 --> 00:21:52,230
this you can either pass in a byte array

527
00:21:49,770 --> 00:21:56,310
or you can pass in a file on disk it'll

528
00:21:52,230 --> 00:21:57,930
do that over loading for you so to walk

529
00:21:56,310 --> 00:22:00,240
through this in more detail first of all

530
00:21:57,930 --> 00:22:03,840
we choose a random legitimately signed

531
00:22:00,240 --> 00:22:05,670
module in system 32 or 64 we call NT

532
00:22:03,840 --> 00:22:07,590
create section passing the file handle

533
00:22:05,670 --> 00:22:09,450
with a sec image then we take the

534
00:22:07,590 --> 00:22:10,830
payload which is a byte array or

535
00:22:09,450 --> 00:22:12,870
whatever PE that you want to use from

536
00:22:10,830 --> 00:22:15,439
memory we write PE to the base address

537
00:22:12,870 --> 00:22:18,340
of the view of that section and

538
00:22:15,440 --> 00:22:22,820
do all the normal virtualization and

539
00:22:18,340 --> 00:22:24,529
module mapping the end result looks

540
00:22:22,820 --> 00:22:27,408
something like this where you have in

541
00:22:24,529 --> 00:22:29,210
red the module that we mapped and in

542
00:22:27,409 --> 00:22:31,639
blue the original version of user

543
00:22:29,210 --> 00:22:34,070
thirty-two DLL so this is me me cats

544
00:22:31,639 --> 00:22:37,639
running from what appears to be memory

545
00:22:34,070 --> 00:22:40,100
backed by user 32 DLL on disk as you can

546
00:22:37,639 --> 00:22:41,928
see from the addresses the address the

547
00:22:40,100 --> 00:22:44,209
entry point of mini cats is in the one

548
00:22:41,929 --> 00:22:45,889
that we manually can manually mapped now

549
00:22:44,210 --> 00:22:47,179
this is actually a good screen shot

550
00:22:45,889 --> 00:22:49,850
because it shows some of the anomalies

551
00:22:47,179 --> 00:22:51,860
that can be a result of manual map or of

552
00:22:49,850 --> 00:22:53,809
module overloading which is specifically

553
00:22:51,860 --> 00:22:57,019
that in this case we have two copies of

554
00:22:53,809 --> 00:22:58,639
user 32 DLL in the process that's not

555
00:22:57,019 --> 00:22:59,870
normal you have the one that is normally

556
00:22:58,639 --> 00:23:01,789
mapped in the process when the process

557
00:22:59,870 --> 00:23:03,350
is created you shouldn't have a second

558
00:23:01,789 --> 00:23:05,480
one especially with that second one not

559
00:23:03,350 --> 00:23:07,158
being referenced in the loaded module

560
00:23:05,480 --> 00:23:09,769
list in the process so the mere fact

561
00:23:07,159 --> 00:23:11,269
that you have two copies of the DLL

562
00:23:09,769 --> 00:23:17,870
loaded into memory is a pretty good

563
00:23:11,269 --> 00:23:20,120
indicator yeah okay so the over kind of

564
00:23:17,870 --> 00:23:24,080
talked about a process injection

565
00:23:20,120 --> 00:23:27,018
technique kind of you you may get like

566
00:23:24,080 --> 00:23:29,330
back something like this some of them

567
00:23:27,019 --> 00:23:31,970
are holistic techniques like reflective

568
00:23:29,330 --> 00:23:35,178
loading and doppelganger others are

569
00:23:31,970 --> 00:23:38,360
execution methods like set windows hook

570
00:23:35,179 --> 00:23:41,029
X set thread contra set thread context

571
00:23:38,360 --> 00:23:43,789
anti create thread X etc some of them

572
00:23:41,029 --> 00:23:47,629
are ways to pass data between processes

573
00:23:43,789 --> 00:23:49,908
like for example with WN f States like

574
00:23:47,629 --> 00:23:52,820
you can push data to a state and then

575
00:23:49,909 --> 00:23:54,799
read it in another process or atom

576
00:23:52,820 --> 00:23:57,730
bombing where you create a global atom

577
00:23:54,799 --> 00:24:00,289
and read it in another process right

578
00:23:57,730 --> 00:24:02,629
none of those things are actually

579
00:24:00,289 --> 00:24:05,870
process injection the reality is that

580
00:24:02,629 --> 00:24:08,449
you have allocation and execution

581
00:24:05,870 --> 00:24:10,360
primitives and that's like many to many

582
00:24:08,450 --> 00:24:13,250
relationship right

583
00:24:10,360 --> 00:24:15,740
also not totally accurate because you

584
00:24:13,250 --> 00:24:18,549
have primitives that allocate that write

585
00:24:15,740 --> 00:24:21,350
and execute but we are simplifying here

586
00:24:18,549 --> 00:24:23,720
you can you can see some examples at the

587
00:24:21,350 --> 00:24:25,658
top there and they're not totally

588
00:24:23,720 --> 00:24:29,130
important but what I want to say is that

589
00:24:25,659 --> 00:24:31,620
on each side they can kind of extend

590
00:24:29,130 --> 00:24:36,419
the more complex than they're shown here

591
00:24:31,620 --> 00:24:38,129
so as an example you could use an T

592
00:24:36,419 --> 00:24:39,660
allocate virtual memory to allocate some

593
00:24:38,130 --> 00:24:42,270
memory you write your payload in there

594
00:24:39,660 --> 00:24:45,059
and then you want to use an APC to

595
00:24:42,270 --> 00:24:46,950
execute it but the problem is with

596
00:24:45,059 --> 00:24:50,639
reliability are you gonna have to wait

597
00:24:46,950 --> 00:24:53,340
for that APC to fire so you do something

598
00:24:50,640 --> 00:24:55,049
more complicated for example you call an

599
00:24:53,340 --> 00:25:00,149
t create thread X and you create a

600
00:24:55,049 --> 00:25:02,460
thread at RTL exit user thread so when

601
00:25:00,150 --> 00:25:04,470
that thread runs it'll just exit but the

602
00:25:02,460 --> 00:25:07,049
thread is currently suspended right and

603
00:25:04,470 --> 00:25:11,010
then you queue your ABC on top of it

604
00:25:07,049 --> 00:25:14,639
with NT Q ABC thread and then when you

605
00:25:11,010 --> 00:25:19,039
resume the thread it executes the

606
00:25:14,640 --> 00:25:22,049
payload and then exits gracefully right

607
00:25:19,039 --> 00:25:25,158
so things can be more complex than they

608
00:25:22,049 --> 00:25:25,158
appear here okay

609
00:25:25,409 --> 00:25:30,270
so the reality is that process injection

610
00:25:28,140 --> 00:25:33,390
is just a set of like it's an assembly

611
00:25:30,270 --> 00:25:35,929
line of components that you can kind of

612
00:25:33,390 --> 00:25:40,230
put together in whatever way you prefer

613
00:25:35,929 --> 00:25:43,740
and any components that we put into

614
00:25:40,230 --> 00:25:46,909
sharps Floyd give users flexibility on

615
00:25:43,740 --> 00:25:49,409
how they want to do things now currently

616
00:25:46,909 --> 00:25:51,630
those building blocks are limited but

617
00:25:49,409 --> 00:25:55,880
we'll put some more in there over time

618
00:25:51,630 --> 00:26:00,320
right and then you have a pick-your-own

619
00:25:55,880 --> 00:26:02,669
adventure or poison-type storyline okay

620
00:26:00,320 --> 00:26:03,689
this this approach is similar to

621
00:26:02,669 --> 00:26:05,549
panchetta

622
00:26:03,690 --> 00:26:09,630
if anybody watched that presentation

623
00:26:05,549 --> 00:26:11,760
from blackhat last year so we have a few

624
00:26:09,630 --> 00:26:13,980
design goals for building a process and

625
00:26:11,760 --> 00:26:16,289
Jake injection API primarily we wanted

626
00:26:13,980 --> 00:26:18,120
it to be modular extensible and simply

627
00:26:16,289 --> 00:26:20,220
like we don't have to have a separate

628
00:26:18,120 --> 00:26:21,928
into allocation write and execution we

629
00:26:20,220 --> 00:26:24,210
just have allocation and execution

630
00:26:21,929 --> 00:26:26,190
partly because it doesn't always matter

631
00:26:24,210 --> 00:26:28,919
what write primitive you use for each

632
00:26:26,190 --> 00:26:31,049
allocation primitive so we built an API

633
00:26:28,919 --> 00:26:32,880
that allows you to just combine these

634
00:26:31,049 --> 00:26:37,500
different components and build your own

635
00:26:32,880 --> 00:26:39,270
injector on the fly so specifically we

636
00:26:37,500 --> 00:26:40,500
have a payload type we have an execution

637
00:26:39,270 --> 00:26:41,250
technique and we have an allocation

638
00:26:40,500 --> 00:26:42,780
technique

639
00:26:41,250 --> 00:26:45,630
and these come implemented in different

640
00:26:42,780 --> 00:26:47,490
subclasses so by default we have a pH

641
00:26:45,630 --> 00:26:50,010
CIC payload a position independent code

642
00:26:47,490 --> 00:26:51,570
which we show code we have execution we

643
00:26:50,010 --> 00:26:54,810
have remote thread creation and then for

644
00:26:51,570 --> 00:26:58,290
allocation we have section mapping the

645
00:26:54,810 --> 00:27:00,000
key the key is that the functionality

646
00:26:58,290 --> 00:27:01,889
for each of these is implemented in

647
00:27:00,000 --> 00:27:06,720
subclasses and it's called dynamically

648
00:27:01,890 --> 00:27:09,000
via polymorphism so to walk through the

649
00:27:06,720 --> 00:27:11,580
example we have so far we have section

650
00:27:09,000 --> 00:27:14,150
mapping which creates a new section

651
00:27:11,580 --> 00:27:16,290
that's not backed by anything on disk

652
00:27:14,150 --> 00:27:18,510
maps of view of that section to the

653
00:27:16,290 --> 00:27:21,300
current process writes the payload into

654
00:27:18,510 --> 00:27:23,310
the current view of that section then

655
00:27:21,300 --> 00:27:25,590
maps a view of that section to a

656
00:27:23,310 --> 00:27:27,450
different process and now the payload is

657
00:27:25,590 --> 00:27:29,699
available in the target process without

658
00:27:27,450 --> 00:27:32,100
ever actually writing to that target

659
00:27:29,700 --> 00:27:33,900
process for execution we have remote

660
00:27:32,100 --> 00:27:35,459
thread creation so one thing that we

661
00:27:33,900 --> 00:27:38,400
wanted to make sure when we design this

662
00:27:35,460 --> 00:27:40,320
API was that every every technique that

663
00:27:38,400 --> 00:27:42,360
we implement here has as many options

664
00:27:40,320 --> 00:27:44,879
exposed to the user as possible so

665
00:27:42,360 --> 00:27:46,590
ideally even the operator can decide at

666
00:27:44,880 --> 00:27:49,050
runtime as they're doing an operation

667
00:27:46,590 --> 00:27:50,580
what techniques that they want to use in

668
00:27:49,050 --> 00:27:53,190
order to execute each post exploitation

669
00:27:50,580 --> 00:27:55,260
payload so for remote thread creation we

670
00:27:53,190 --> 00:27:57,300
don't just have one technique or one API

671
00:27:55,260 --> 00:27:59,040
call like rate row thread we have create

672
00:27:57,300 --> 00:28:03,750
remote thread RTL create user thread in

673
00:27:59,040 --> 00:28:05,450
D create thread X etc so to build an

674
00:28:03,750 --> 00:28:08,280
injector all you have to do is

675
00:28:05,450 --> 00:28:09,750
instantiate a class of the payload type

676
00:28:08,280 --> 00:28:11,760
that you want instantiate a class of the

677
00:28:09,750 --> 00:28:13,140
allocation and the execution techniques

678
00:28:11,760 --> 00:28:15,600
that you want to pass and the options

679
00:28:13,140 --> 00:28:18,150
and you call injector inject pass them

680
00:28:15,600 --> 00:28:20,969
in and voila it magically calls all of

681
00:28:18,150 --> 00:28:22,920
the all the functions are defined in

682
00:28:20,970 --> 00:28:24,300
each of those classes and performs the

683
00:28:22,920 --> 00:28:26,340
injection in whatever process you

684
00:28:24,300 --> 00:28:28,740
specify we're actually going to have

685
00:28:26,340 --> 00:28:32,340
this demo available when we release the

686
00:28:28,740 --> 00:28:34,380
blog posts and we'll show using covenant

687
00:28:32,340 --> 00:28:37,320
which has char plate loaded will show

688
00:28:34,380 --> 00:28:39,330
how you can have access to a target and

689
00:28:37,320 --> 00:28:41,280
be able to end memory on the fly build

690
00:28:39,330 --> 00:28:43,740
an injector so the key points there is

691
00:28:41,280 --> 00:28:45,480
say your red teamer and you're doing an

692
00:28:43,740 --> 00:28:48,420
operation and you're in an environment

693
00:28:45,480 --> 00:28:49,950
where they have some NM our ETR that's

694
00:28:48,420 --> 00:28:52,350
caching the injection technique that's

695
00:28:49,950 --> 00:28:53,970
built-in by default to your tool well if

696
00:28:52,350 --> 00:28:54,540
you have this sort of modular process

697
00:28:53,970 --> 00:28:57,150
injection

698
00:28:54,540 --> 00:28:59,100
vii you can literally on-the-fly in less

699
00:28:57,150 --> 00:29:00,840
than 5 min but five minutes build a new

700
00:28:59,100 --> 00:29:02,639
injector by assembling these components

701
00:29:00,840 --> 00:29:08,520
keep trying and mount until one of them

702
00:29:02,640 --> 00:29:11,790
works yeah okay so I'm a defender as

703
00:29:08,520 --> 00:29:14,310
well okay not just an attacker so I want

704
00:29:11,790 --> 00:29:17,040
to talk about detection strategies now

705
00:29:14,310 --> 00:29:19,530
unfortunately maybe you can imagine but

706
00:29:17,040 --> 00:29:22,950
it's not all like sunshine lollipops and

707
00:29:19,530 --> 00:29:25,670
rainbows okay but we can try to do some

708
00:29:22,950 --> 00:29:28,170
things to detect this type of tradecraft

709
00:29:25,670 --> 00:29:30,510
so since we're talking about dotnet

710
00:29:28,170 --> 00:29:34,310
specifically and our tooling is in.net

711
00:29:30,510 --> 00:29:38,610
one of the core things we should do is

712
00:29:34,310 --> 00:29:41,399
correlate module load events okay so if

713
00:29:38,610 --> 00:29:43,260
attackers are injecting net assemblies

714
00:29:41,400 --> 00:29:45,300
into processes like with execute

715
00:29:43,260 --> 00:29:47,640
assembly in COBOL strike and those

716
00:29:45,300 --> 00:29:49,350
processes don't usually have the CL are

717
00:29:47,640 --> 00:29:53,430
loaded that's gonna create a lot of

718
00:29:49,350 --> 00:29:56,159
module load events okay so here we can

719
00:29:53,430 --> 00:29:59,360
see or maybe you can't really see but

720
00:29:56,160 --> 00:30:05,460
this is a notepad pre injection okay and

721
00:29:59,360 --> 00:30:07,740
then in a next step we inject some shell

722
00:30:05,460 --> 00:30:12,480
code which loads a dotnet assembly and

723
00:30:07,740 --> 00:30:13,890
then our message box pops here and we

724
00:30:12,480 --> 00:30:17,880
can see that a whole bunch of modules

725
00:30:13,890 --> 00:30:20,850
get loaded into notepad like MS core Lib

726
00:30:17,880 --> 00:30:24,390
Emma score e Emma scourge it all that

727
00:30:20,850 --> 00:30:27,330
stuff right so if you have the ability

728
00:30:24,390 --> 00:30:30,030
to correlate module load events within

729
00:30:27,330 --> 00:30:33,179
your detection stack you should

730
00:30:30,030 --> 00:30:34,950
definitely do that because if you can

731
00:30:33,180 --> 00:30:37,530
filter out those cases where such

732
00:30:34,950 --> 00:30:38,850
behavior occurs naturally you'll

733
00:30:37,530 --> 00:30:42,240
definitely find like a good

734
00:30:38,850 --> 00:30:44,760
concentration of evil okay however it

735
00:30:42,240 --> 00:30:47,820
does require silent testing and FB

736
00:30:44,760 --> 00:30:50,490
tuning obviously because you will find

737
00:30:47,820 --> 00:30:52,649
many cases where that stuff happens

738
00:30:50,490 --> 00:30:55,110
naturally right and if you have clients

739
00:30:52,650 --> 00:30:57,330
and you've ever written any detection

740
00:30:55,110 --> 00:30:59,520
rules you know that no matter how good

741
00:30:57,330 --> 00:31:01,379
your rule is you'll always find the

742
00:30:59,520 --> 00:31:03,030
client who's doing some crazy stuff that

743
00:31:01,380 --> 00:31:05,840
you never thought about which triggers

744
00:31:03,030 --> 00:31:05,840
your rule right

745
00:31:06,610 --> 00:31:13,209
yeah this is my favorite to be honest

746
00:31:09,640 --> 00:31:15,190
right Microsoft Windows mm runtime so

747
00:31:13,210 --> 00:31:17,770
there is an e TW provider for dotnet

748
00:31:15,190 --> 00:31:18,910
which has a lot of visibility into the

749
00:31:17,770 --> 00:31:22,629
runtime okay

750
00:31:18,910 --> 00:31:25,150
now the issue is that this provider is

751
00:31:22,630 --> 00:31:28,090
not really exposed to end users

752
00:31:25,150 --> 00:31:29,980
however programmatically you can

753
00:31:28,090 --> 00:31:31,240
subscribe to it right there is no

754
00:31:29,980 --> 00:31:35,100
problem

755
00:31:31,240 --> 00:31:37,900
so last year I wrote a tool silky TW and

756
00:31:35,100 --> 00:31:42,040
later silk service which is a service

757
00:31:37,900 --> 00:31:45,720
version of silk and you can subscribe to

758
00:31:42,040 --> 00:31:49,950
a provider or a set of providers and

759
00:31:45,720 --> 00:31:52,720
just Hoover up all of that data okay so

760
00:31:49,950 --> 00:31:56,200
you have a lot of options to filter

761
00:31:52,720 --> 00:31:58,720
based on event types up codes all of

762
00:31:56,200 --> 00:32:02,410
that stuff and I also added support for

763
00:31:58,720 --> 00:32:04,750
Yara so you can have a whole bunch of

764
00:32:02,410 --> 00:32:07,480
collectors defined and a whole set of

765
00:32:04,750 --> 00:32:12,310
Yara rules and every time an event comes

766
00:32:07,480 --> 00:32:14,620
in it comes in you scan it right so what

767
00:32:12,310 --> 00:32:17,110
we can see here is that are manually

768
00:32:14,620 --> 00:32:21,129
mapping me me cats and then I wrote some

769
00:32:17,110 --> 00:32:23,409
Yara rules which are detecting this

770
00:32:21,130 --> 00:32:26,650
behavior very well right we can see

771
00:32:23,410 --> 00:32:29,500
there are some rules for loading modules

772
00:32:26,650 --> 00:32:32,800
from disk other ones which are specific

773
00:32:29,500 --> 00:32:35,110
to manual mapping in sharps ployed even

774
00:32:32,800 --> 00:32:37,930
other ones which are detecting some

775
00:32:35,110 --> 00:32:42,479
native function calls and some

776
00:32:37,930 --> 00:32:45,490
suspicious isle method signatures okay

777
00:32:42,480 --> 00:32:47,320
now when we put our slides on github

778
00:32:45,490 --> 00:32:49,180
I'll upload all of those yarra rules so

779
00:32:47,320 --> 00:32:51,639
you can have a look at them but the

780
00:32:49,180 --> 00:32:57,730
process to write this is really easy and

781
00:32:51,640 --> 00:33:00,520
straightforward uh-huh uh-huh so mz4

782
00:32:57,730 --> 00:33:04,330
double net 4.8 we already talked about

783
00:33:00,520 --> 00:33:08,290
this this is a great addition to the MZ

784
00:33:04,330 --> 00:33:13,030
family if it's enabled support is back

785
00:33:08,290 --> 00:33:16,480
ported to 4.0 anything below 4 is still

786
00:33:13,030 --> 00:33:17,460
like without telemetry but hopefully you

787
00:33:16,480 --> 00:33:20,529
can

788
00:33:17,460 --> 00:33:24,250
through policy make sure that your users

789
00:33:20,529 --> 00:33:25,269
or certain user groups don't have those

790
00:33:24,250 --> 00:33:29,380
versions of.net

791
00:33:25,269 --> 00:33:31,600
installed okay just a side note here

792
00:33:29,380 --> 00:33:35,500
that I think everybody kind of knows

793
00:33:31,600 --> 00:33:36,279
that but MCS attack surface remains

794
00:33:35,500 --> 00:33:39,130
intact

795
00:33:36,279 --> 00:33:41,230
so if MZ is monitoring a space which has

796
00:33:39,130 --> 00:33:45,220
the ability to read and write memory

797
00:33:41,230 --> 00:33:49,000
then that space has the ability to break

798
00:33:45,220 --> 00:33:52,059
an Zee essentially so the challenge

799
00:33:49,000 --> 00:33:55,259
becomes to detect those operations where

800
00:33:52,059 --> 00:33:58,360
users are trying to make am C inoperable

801
00:33:55,259 --> 00:34:04,000
but that's not to say anything bad about

802
00:33:58,360 --> 00:34:06,549
AM Z ok it's a grey edition then yeah ok

803
00:34:04,000 --> 00:34:08,469
application introspection I like to term

804
00:34:06,549 --> 00:34:12,579
it like this because we're really

805
00:34:08,469 --> 00:34:15,339
talking about hooking but a lot of

806
00:34:12,579 --> 00:34:16,810
defenders when I talk about that they

807
00:34:15,339 --> 00:34:18,668
look at me as if I'm mentioning

808
00:34:16,810 --> 00:34:21,279
something evil or some kind of taboo or

809
00:34:18,668 --> 00:34:23,379
we're not those kind of defenders we're

810
00:34:21,280 --> 00:34:27,700
not hooking our users or something like

811
00:34:23,379 --> 00:34:31,750
that but the reality is that hooking

812
00:34:27,699 --> 00:34:34,839
remains a very powerful tool to detect

813
00:34:31,750 --> 00:34:37,540
suspicious API calls or sequences of

814
00:34:34,839 --> 00:34:40,899
calls or some kind of aberrant parameter

815
00:34:37,540 --> 00:34:43,659
usage so if you have a heuristic which

816
00:34:40,899 --> 00:34:45,940
is like these seven API calls happen and

817
00:34:43,659 --> 00:34:49,119
these four API calls have these weird

818
00:34:45,940 --> 00:34:53,139
parameters then you know like something

819
00:34:49,119 --> 00:34:55,869
evil happened there okay the other thing

820
00:34:53,139 --> 00:34:57,520
that people usually don't mention when

821
00:34:55,869 --> 00:35:00,099
they talk about hooking for defense is

822
00:34:57,520 --> 00:35:02,290
that hooking inherently brings blocking

823
00:35:00,099 --> 00:35:05,380
capabilities to the table so you're in

824
00:35:02,290 --> 00:35:07,869
line in the process right once that

825
00:35:05,380 --> 00:35:10,450
heuristic triggers you can just drop the

826
00:35:07,869 --> 00:35:13,420
API call and execution doesn't continue

827
00:35:10,450 --> 00:35:16,000
at that point or since you're executing

828
00:35:13,420 --> 00:35:18,790
from inside the process you can do some

829
00:35:16,000 --> 00:35:21,069
post detection mitigation actions right

830
00:35:18,790 --> 00:35:24,430
you can kill the process or some other

831
00:35:21,069 --> 00:35:28,839
more complicated heuristic here we can

832
00:35:24,430 --> 00:35:30,879
see it's another tool I wrote fermium

833
00:35:28,839 --> 00:35:33,519
it's an electron front

834
00:35:30,880 --> 00:35:35,950
for Frieda with like an integrated

835
00:35:33,519 --> 00:35:39,008
Monaco editors so you have linting and

836
00:35:35,950 --> 00:35:41,589
stuff like that but what I'm doing here

837
00:35:39,009 --> 00:35:44,650
essentially is installing two hooks one

838
00:35:41,589 --> 00:35:47,650
for anti write virtual memory and one

839
00:35:44,650 --> 00:35:50,920
for anti create thread X so what I'm

840
00:35:47,650 --> 00:35:53,259
doing here is basically anytime anti

841
00:35:50,920 --> 00:35:56,349
write virtual memory occurs I try to

842
00:35:53,259 --> 00:35:59,730
inspect that buffer and see if it's a P

843
00:35:56,349 --> 00:36:03,519
right I checked like MZ and then I read

844
00:35:59,730 --> 00:36:05,289
e.l.f a new to find where the P header

845
00:36:03,519 --> 00:36:08,319
is and then I check some magic bytes

846
00:36:05,289 --> 00:36:10,839
there and then if that all checks out I

847
00:36:08,319 --> 00:36:14,410
know like a PE was written to memory and

848
00:36:10,839 --> 00:36:17,109
I I tell the user okay wait something

849
00:36:14,410 --> 00:36:19,029
not good is going on here right and I

850
00:36:17,109 --> 00:36:20,828
print out the architecture of the binary

851
00:36:19,029 --> 00:36:24,009
I'm not sure if you can really read that

852
00:36:20,829 --> 00:36:26,349
and the entry point okay and that entry

853
00:36:24,009 --> 00:36:29,740
point gets added to an array of entry

854
00:36:26,349 --> 00:36:31,960
points and then later any time when anti

855
00:36:29,740 --> 00:36:34,269
create thread X is called I check the

856
00:36:31,960 --> 00:36:36,250
start address of that thread and if it's

857
00:36:34,269 --> 00:36:39,038
part of that array I know now that

858
00:36:36,250 --> 00:36:42,460
something bad definitely happened right

859
00:36:39,039 --> 00:36:45,039
first P was allocated into memory and

860
00:36:42,460 --> 00:36:47,920
then later a thread was created at the

861
00:36:45,039 --> 00:36:51,579
entry point of that PE now while this is

862
00:36:47,920 --> 00:36:53,140
like a simplistic heuristic that I

863
00:36:51,579 --> 00:36:56,740
wouldn't recommend anybody put into

864
00:36:53,140 --> 00:36:59,200
production okay but it didn't take a lot

865
00:36:56,740 --> 00:37:01,990
of time to develop that and I'm sure

866
00:36:59,200 --> 00:37:04,808
that some more capable people in product

867
00:37:01,990 --> 00:37:09,819
can work on really good heuristics to

868
00:37:04,809 --> 00:37:11,500
detect some bad stuff basically so how

869
00:37:09,819 --> 00:37:13,089
can you contribute a lot of the api's

870
00:37:11,500 --> 00:37:14,500
that we just we put into Sharps way

871
00:37:13,089 --> 00:37:16,808
we're specifically designed so that they

872
00:37:14,500 --> 00:37:19,660
can be built awful and we encourage

873
00:37:16,809 --> 00:37:22,269
adding on new techniques we will also

874
00:37:19,660 --> 00:37:24,038
provide a set of suggestions that we

875
00:37:22,269 --> 00:37:25,750
recommend things that if we had the

876
00:37:24,039 --> 00:37:27,700
infinite amount of time in the world we

877
00:37:25,750 --> 00:37:29,559
would develop and add into this giant

878
00:37:27,700 --> 00:37:31,058
library but we don't so we're gonna have

879
00:37:29,559 --> 00:37:33,880
those if you want to contribute on the

880
00:37:31,059 --> 00:37:36,069
offensive side but I also recommend that

881
00:37:33,880 --> 00:37:38,799
if you have detection strategies or

882
00:37:36,069 --> 00:37:40,089
techniques that you want to go say into

883
00:37:38,799 --> 00:37:42,369
our blog post when we announce this

884
00:37:40,089 --> 00:37:44,140
stuff or you want to share with us or

885
00:37:42,369 --> 00:37:44,800
share with other people we would greatly

886
00:37:44,140 --> 00:37:47,080
recommend

887
00:37:44,800 --> 00:37:49,690
and I appreciate you reaching out to us

888
00:37:47,080 --> 00:37:52,299
on Twitter or any other mechanism we

889
00:37:49,690 --> 00:37:56,290
would be glad to credit you in our blog

890
00:37:52,300 --> 00:37:58,540
posts or however you would prefer it so

891
00:37:56,290 --> 00:38:02,080
in conclusion the release for all this

892
00:37:58,540 --> 00:38:03,430
stuff will be coordinated approximately

893
00:38:02,080 --> 00:38:05,319
around when the video goes up maybe a

894
00:38:03,430 --> 00:38:07,299
little bit after and will also release

895
00:38:05,320 --> 00:38:10,570
blog posts along with more details

896
00:38:07,300 --> 00:38:12,850
covering the D in vogue API process

897
00:38:10,570 --> 00:38:16,390
injection API module overloading

898
00:38:12,850 --> 00:38:18,250
separately and in the meantime all of

899
00:38:16,390 --> 00:38:22,270
the code that we have available right

900
00:38:18,250 --> 00:38:25,090
now is in APR to the main github repos

901
00:38:22,270 --> 00:38:27,940
so it's being approved this week

902
00:38:25,090 --> 00:38:29,350
hopefully but either way you can go look

903
00:38:27,940 --> 00:38:31,960
at the code right now if you want to

904
00:38:29,350 --> 00:38:34,000
yeah we we dropped like three thousand

905
00:38:31,960 --> 00:38:36,910
lines of code on the maintainer so he

906
00:38:34,000 --> 00:38:38,740
needs some time to look at that yeah I

907
00:38:36,910 --> 00:38:42,009
just want to say as well that when we

908
00:38:38,740 --> 00:38:44,290
put our slides on github and at that

909
00:38:42,010 --> 00:38:47,820
point I'll add those euro rules and how

910
00:38:44,290 --> 00:38:50,350
you can set up silky TW and also add any

911
00:38:47,820 --> 00:38:52,900
JavaScript hooks for frida that you can

912
00:38:50,350 --> 00:38:55,930
run and test out you know those kind of

913
00:38:52,900 --> 00:38:57,070
detections okay I think that's all we've

914
00:38:55,930 --> 00:38:59,770
got that's all we've got

915
00:38:57,070 --> 00:39:03,369
thank you very much for having us

916
00:38:59,770 --> 00:39:03,369
[Applause]

