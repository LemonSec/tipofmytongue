1
00:00:11,860 --> 00:00:17,450
hello everyone I'm look at disco and as

2
00:00:15,110 --> 00:00:20,750
the introduction or video mentioned I do

3
00:00:17,450 --> 00:00:22,640
by a security research independently and

4
00:00:20,750 --> 00:00:26,150
I've been doing it for quite a few years

5
00:00:22,640 --> 00:00:29,660
now in this talk we're gonna be

6
00:00:26,150 --> 00:00:32,650
discussing about securom today I'm here

7
00:00:29,660 --> 00:00:36,949
speaking on behalf of the chakram team

8
00:00:32,650 --> 00:00:39,830
which is more than just myself and

9
00:00:36,949 --> 00:00:42,140
especially I want to thank AXA max

10
00:00:39,830 --> 00:00:43,460
little later in C Goethe for the

11
00:00:42,140 --> 00:00:45,559
underlying bug and the exploration

12
00:00:43,460 --> 00:00:48,620
strategies that were used in the

13
00:00:45,559 --> 00:00:50,360
specific exploit and again the entire

14
00:00:48,620 --> 00:00:52,579
track foreign team for the work that was

15
00:00:50,360 --> 00:00:55,219
put into building the infrastructure and

16
00:00:52,579 --> 00:00:59,360
software to turn these vulnerability in

17
00:00:55,219 --> 00:01:02,360
full jailbreak so the checkering team is

18
00:00:59,360 --> 00:01:05,990
composed of some of the best security

19
00:01:02,360 --> 00:01:09,530
researchers on the iOS scene you can see

20
00:01:05,990 --> 00:01:15,199
some of these names are very popular in

21
00:01:09,530 --> 00:01:17,479
the jabra community and again these are

22
00:01:15,200 --> 00:01:20,119
people that came from all over the

23
00:01:17,479 --> 00:01:22,429
community that usually do a lot of

24
00:01:20,119 --> 00:01:26,179
different things but we came together

25
00:01:22,429 --> 00:01:27,890
and we decided to put in a lot of effort

26
00:01:26,179 --> 00:01:31,130
to make the best job work that we

27
00:01:27,890 --> 00:01:32,470
possibly could and me personally I'm

28
00:01:31,130 --> 00:01:35,750
very grateful for this opportunity

29
00:01:32,470 --> 00:01:40,640
because it's not every day that you work

30
00:01:35,750 --> 00:01:43,479
with so many great people anyway we'll

31
00:01:40,640 --> 00:01:46,789
get to the actual point which is securom

32
00:01:43,479 --> 00:01:49,039
securom is the very first code that runs

33
00:01:46,789 --> 00:01:53,509
on your iPhone's application processor

34
00:01:49,039 --> 00:01:55,880
when you boot it up and it's based out

35
00:01:53,509 --> 00:01:59,200
of the iboot bootloader that iPod uses

36
00:01:55,880 --> 00:02:01,729
across its mobile platform stack and

37
00:01:59,200 --> 00:02:03,590
specifically securom is interesting

38
00:02:01,729 --> 00:02:05,840
because it's patterned into the mask

39
00:02:03,590 --> 00:02:07,849
from so it's now actually mutable and

40
00:02:05,840 --> 00:02:10,310
any vulnerability that's present in

41
00:02:07,849 --> 00:02:12,739
securom will not be passable by apple

42
00:02:10,310 --> 00:02:15,200
without a new hardware revision and it's

43
00:02:12,739 --> 00:02:18,650
also the most trusted code to run on the

44
00:02:15,200 --> 00:02:20,599
application processor and its main goal

45
00:02:18,650 --> 00:02:23,379
is to load a first stage bootloader

46
00:02:20,599 --> 00:02:27,399
which is still gonna be ID with a more

47
00:02:23,379 --> 00:02:30,969
feature complete version and load it in

48
00:02:27,400 --> 00:02:33,069
memory however it also provides an

49
00:02:30,969 --> 00:02:36,069
emergency mechanism that allows you to

50
00:02:33,069 --> 00:02:38,379
reset the device in case the first-stage

51
00:02:36,069 --> 00:02:40,510
bootloader is corrupted or something bad

52
00:02:38,379 --> 00:02:42,518
happened to it and you can enter the

53
00:02:40,510 --> 00:02:48,250
special mode by holding the key

54
00:02:42,519 --> 00:02:50,799
combination during boot and secure boot

55
00:02:48,250 --> 00:02:53,049
I do say that iOS pioneered the concept

56
00:02:50,799 --> 00:02:55,810
of secure boot but I have been corrected

57
00:02:53,049 --> 00:03:00,040
blackberry apparently did it first but

58
00:02:55,810 --> 00:03:03,909
iOS has had secure boot from basically

59
00:03:00,040 --> 00:03:05,260
the very start on all devices secure ROM

60
00:03:03,909 --> 00:03:07,900
does implement some verification

61
00:03:05,260 --> 00:03:11,469
tracking mechanism when uploading an

62
00:03:07,900 --> 00:03:14,620
image over DFU however on the original

63
00:03:11,469 --> 00:03:16,599
iPhone the only such images were

64
00:03:14,620 --> 00:03:21,189
validated and not images already flashed

65
00:03:16,599 --> 00:03:23,138
into non-volatile storage however from

66
00:03:21,189 --> 00:03:26,129
the very start these were the mechanisms

67
00:03:23,139 --> 00:03:28,209
that jailbreakers were against and

68
00:03:26,129 --> 00:03:29,649
jailbreak in general do rely on my

69
00:03:28,209 --> 00:03:32,049
passing these mitigations and the

70
00:03:29,650 --> 00:03:33,909
security mechanisms in order to get

71
00:03:32,049 --> 00:03:38,859
around it and allow people to load

72
00:03:33,909 --> 00:03:40,209
arbitrary code and going back to the

73
00:03:38,859 --> 00:03:40,859
emergency system I was talking about

74
00:03:40,209 --> 00:03:44,109
earlier

75
00:03:40,859 --> 00:03:46,479
it's called DF view and it's a fairly

76
00:03:44,109 --> 00:03:50,229
simple protocol that allows you to

77
00:03:46,479 --> 00:03:52,780
upload data to the securom over USB and

78
00:03:50,229 --> 00:03:54,699
it's a very simplified protocol you

79
00:03:52,780 --> 00:03:57,849
upload some data chunks of your image

80
00:03:54,699 --> 00:04:00,519
and when your transfer is done you reset

81
00:03:57,849 --> 00:04:03,810
the USB connection and securom will try

82
00:04:00,519 --> 00:04:06,430
to exit the fu and boot the image and

83
00:04:03,810 --> 00:04:09,609
there's actually several ways to exit

84
00:04:06,430 --> 00:04:11,590
the fu one of them is another USB

85
00:04:09,609 --> 00:04:13,419
command one of them is as I said the

86
00:04:11,590 --> 00:04:19,720
reset even just unplugging and plugging

87
00:04:13,419 --> 00:04:22,150
a cable will exit the fu and this is

88
00:04:19,720 --> 00:04:24,669
implemented on top of USB control

89
00:04:22,150 --> 00:04:29,258
transfers and use the control transfers

90
00:04:24,669 --> 00:04:31,900
are designed to issue some sort of

91
00:04:29,259 --> 00:04:35,560
remote command from the host to the

92
00:04:31,900 --> 00:04:37,060
device and a successful USB enumeration

93
00:04:35,560 --> 00:04:41,020
requires devices to

94
00:04:37,060 --> 00:04:42,700
implement a few of these and every

95
00:04:41,020 --> 00:04:44,500
control transfer will start with the

96
00:04:42,700 --> 00:04:45,940
setup packet which is an eight by

97
00:04:44,500 --> 00:04:48,100
structure that contains a bunch of

98
00:04:45,940 --> 00:04:53,830
information on the transfer that's about

99
00:04:48,100 --> 00:04:56,440
to happen and additionally if the length

100
00:04:53,830 --> 00:04:59,500
is nonzero the setup packet is going to

101
00:04:56,440 --> 00:05:02,080
be followed by a data phase which for

102
00:04:59,500 --> 00:05:04,180
instance in DFU is how the data chunks

103
00:05:02,080 --> 00:05:08,440
are being transferred from the host

104
00:05:04,180 --> 00:05:11,260
device however USB control transfers

105
00:05:08,440 --> 00:05:14,770
might also request data from the device

106
00:05:11,260 --> 00:05:19,060
to the host depending on the request

107
00:05:14,770 --> 00:05:21,880
type is specified and the data phase

108
00:05:19,060 --> 00:05:24,040
will have the data chunked in sizes

109
00:05:21,880 --> 00:05:27,040
ranging from zero bytes to 64 bytes

110
00:05:24,040 --> 00:05:30,040
based on the USB speed and it will be

111
00:05:27,040 --> 00:05:31,840
sent sequentially to the device and when

112
00:05:30,040 --> 00:05:34,180
once the transfer is done of status

113
00:05:31,840 --> 00:05:36,310
phase follows which marks the end of the

114
00:05:34,180 --> 00:05:37,900
control transfer and optionally there is

115
00:05:36,310 --> 00:05:41,260
going to be at zero length packet sent

116
00:05:37,900 --> 00:05:46,000
between the two to mark the end of data

117
00:05:41,260 --> 00:05:49,030
transmission and then the USB stack that

118
00:05:46,000 --> 00:05:51,900
I bought uses a temporary buffer is

119
00:05:49,030 --> 00:05:55,539
allocated while turning the USB stack on

120
00:05:51,900 --> 00:05:58,390
where all these chunks from the data

121
00:05:55,539 --> 00:06:03,930
phase will be queued in order to

122
00:05:58,390 --> 00:06:06,849
reassemble them on the device side and

123
00:06:03,930 --> 00:06:09,220
the interactions between the USB stack

124
00:06:06,850 --> 00:06:12,220
and the Fu are interesting because the

125
00:06:09,220 --> 00:06:16,930
USB stack is turned on when entering the

126
00:06:12,220 --> 00:06:18,940
Fu and when you turn on the stack you do

127
00:06:16,930 --> 00:06:23,110
the initial allocation of the buffer

128
00:06:18,940 --> 00:06:24,760
used for the temporary data then you

129
00:06:23,110 --> 00:06:27,669
issue a control transfer specify a

130
00:06:24,760 --> 00:06:30,010
length and a pointer to this buffer will

131
00:06:27,669 --> 00:06:32,799
be copied to a global variable and the

132
00:06:30,010 --> 00:06:35,139
USB stack will write each chunk of data

133
00:06:32,800 --> 00:06:39,700
that it receives on top of this pointer

134
00:06:35,139 --> 00:06:42,880
and when you do a DF you exit the USB

135
00:06:39,700 --> 00:06:46,060
stack is turned off again and the buffer

136
00:06:42,880 --> 00:06:50,210
is freed now

137
00:06:46,060 --> 00:06:51,919
the key points here is that a pointer to

138
00:06:50,210 --> 00:06:54,888
this buffer is going to be copied into a

139
00:06:51,919 --> 00:06:58,609
global variable and upon the F you exit

140
00:06:54,889 --> 00:07:00,530
f3 is going to be triggered because the

141
00:06:58,610 --> 00:07:02,740
global variable is never actually node

142
00:07:00,530 --> 00:07:05,150
out and so the end result is going to be

143
00:07:02,740 --> 00:07:10,610
used after free type of vulnerability

144
00:07:05,150 --> 00:07:14,060
and so the general idea for how to get a

145
00:07:10,610 --> 00:07:17,990
trigger start from normal USB control

146
00:07:14,060 --> 00:07:21,110
transfer with some data phase and as the

147
00:07:17,990 --> 00:07:24,440
data phase is going out you stop sending

148
00:07:21,110 --> 00:07:26,449
data to the device and following these

149
00:07:24,440 --> 00:07:29,599
you issued the F your birth control

150
00:07:26,449 --> 00:07:33,590
transfer which will shut down the F you

151
00:07:29,599 --> 00:07:35,120
turning off the USB stack and the

152
00:07:33,590 --> 00:07:38,359
temporary buffer is going to be freed at

153
00:07:35,120 --> 00:07:41,120
a point in time however the data that

154
00:07:38,360 --> 00:07:44,150
was sent is a valid image and so DFU is

155
00:07:41,120 --> 00:07:47,449
going to re-enter and reinitialize the

156
00:07:44,150 --> 00:07:51,710
USB stack and then you can just keep

157
00:07:47,449 --> 00:07:55,340
sending data without issuing a new

158
00:07:51,710 --> 00:07:56,870
control transfer over USB and the data

159
00:07:55,340 --> 00:08:00,549
will be mem copied on top of the

160
00:07:56,870 --> 00:08:06,919
previous point previously copied pointer

161
00:08:00,550 --> 00:08:10,130
and from these little latency Goethe

162
00:08:06,919 --> 00:08:12,770
actually managed to make practical way

163
00:08:10,130 --> 00:08:15,889
of triggering this by using an Arduino

164
00:08:12,770 --> 00:08:17,779
with a USB host mode shield which allows

165
00:08:15,889 --> 00:08:21,349
them to have full control over the USB

166
00:08:17,779 --> 00:08:25,330
stack on the host side because obviously

167
00:08:21,349 --> 00:08:28,900
sending partial transfers is usually not

168
00:08:25,330 --> 00:08:32,240
standard thing that USB allows you to do

169
00:08:28,900 --> 00:08:34,309
and by using the Arduino it was very

170
00:08:32,240 --> 00:08:37,899
reliable and they could have perfect

171
00:08:34,309 --> 00:08:42,588
control transfers with very controlled

172
00:08:37,899 --> 00:08:45,589
100% reliable exit code execution and XC

173
00:08:42,589 --> 00:08:47,720
max had a different approach which was

174
00:08:45,589 --> 00:08:50,000
to abuse a race condition in the USB

175
00:08:47,720 --> 00:08:53,089
stack on Mac OS in order to have a

176
00:08:50,000 --> 00:08:55,040
transfer aborted midway and this is not

177
00:08:53,089 --> 00:08:56,320
actually a monistic but you can do

178
00:08:55,040 --> 00:08:59,020
multiple attempts

179
00:08:56,320 --> 00:09:03,460
and many us this tax will actually tell

180
00:08:59,020 --> 00:09:06,300
you whether you send some data whether

181
00:09:03,460 --> 00:09:09,220
the transfer was completely done and

182
00:09:06,300 --> 00:09:11,189
also how much data has been transferred

183
00:09:09,220 --> 00:09:14,110
in some cases on some USB controllers

184
00:09:11,190 --> 00:09:17,250
and this allows you to have a very

185
00:09:14,110 --> 00:09:21,840
reliable trigger almost on par on the

186
00:09:17,250 --> 00:09:22,960
Arduino host shield based trigger and

187
00:09:21,840 --> 00:09:26,350
yep

188
00:09:22,960 --> 00:09:28,510
this was the Arduino host shield trigger

189
00:09:26,350 --> 00:09:33,390
this was the first device that ran this

190
00:09:28,510 --> 00:09:33,390
exploit from sig was a little Layla and

191
00:09:34,080 --> 00:09:37,900
most devices however if you actually

192
00:09:36,310 --> 00:09:41,170
attempted to do these nothing at all

193
00:09:37,900 --> 00:09:44,079
would happen with the one exception of a

194
00:09:41,170 --> 00:09:47,860
eight and a nine because of a bug in the

195
00:09:44,080 --> 00:09:50,230
DF you exceeded functionality latency

196
00:09:47,860 --> 00:09:52,420
goods are analyzed this specific crash

197
00:09:50,230 --> 00:09:55,570
and this was their starting point and

198
00:09:52,420 --> 00:09:59,800
they realized that every time the DF you

199
00:09:55,570 --> 00:10:01,690
abort is performed a task structure is

200
00:09:59,800 --> 00:10:03,490
leaked onto the heap and the task

201
00:10:01,690 --> 00:10:06,460
structure is a very interesting

202
00:10:03,490 --> 00:10:10,990
structure because it contains a bunch of

203
00:10:06,460 --> 00:10:13,270
register state and when a task gets one

204
00:10:10,990 --> 00:10:15,540
of those yields register state is going

205
00:10:13,270 --> 00:10:19,060
to be saved onto this task structure and

206
00:10:15,540 --> 00:10:20,920
when you schedule this task those

207
00:10:19,060 --> 00:10:24,280
registers are going to be restored and

208
00:10:20,920 --> 00:10:26,500
so you get a use of the free right that

209
00:10:24,280 --> 00:10:30,250
happens on top of a currently scheduled

210
00:10:26,500 --> 00:10:33,160
task so while it's a very powerful

211
00:10:30,250 --> 00:10:34,900
primitive by itself you are not going to

212
00:10:33,160 --> 00:10:37,360
be able to do much with it because the

213
00:10:34,900 --> 00:10:39,600
registers are currently in use and so

214
00:10:37,360 --> 00:10:42,750
your corrupted registers are going to be

215
00:10:39,600 --> 00:10:45,570
overwritten when you schedule off

216
00:10:42,750 --> 00:10:48,790
however there is also a linked list that

217
00:10:45,570 --> 00:10:50,680
contains a pointer to the next task so

218
00:10:48,790 --> 00:10:52,990
what you can actually do is corrupt that

219
00:10:50,680 --> 00:10:54,520
linked list instead and create a fake

220
00:10:52,990 --> 00:10:57,550
task structure somewhere else

221
00:10:54,520 --> 00:10:59,949
and once your current thread will yield

222
00:10:57,550 --> 00:11:02,349
you got full control of our register

223
00:10:59,950 --> 00:11:04,870
state and from these basically don't

224
00:11:02,350 --> 00:11:07,240
need no wrap and no job because on those

225
00:11:04,870 --> 00:11:10,160
specific versions of securom there are

226
00:11:07,240 --> 00:11:11,959
no execute

227
00:11:10,160 --> 00:11:18,620
execute the mitigations present on the

228
00:11:11,959 --> 00:11:20,930
heap so it's pretty powerful however all

229
00:11:18,620 --> 00:11:23,600
the rounds and newer rounds can't use

230
00:11:20,930 --> 00:11:26,060
this strategy because the task structure

231
00:11:23,600 --> 00:11:30,439
leak was only present on those two

232
00:11:26,060 --> 00:11:32,449
specifics socks and no crash is

233
00:11:30,439 --> 00:11:34,550
triggered at all on other devices

234
00:11:32,449 --> 00:11:37,969
because the ROM is deterministic enough

235
00:11:34,550 --> 00:11:39,859
that every single time you relocate that

236
00:11:37,970 --> 00:11:42,709
buffer it will be relocated in the same

237
00:11:39,860 --> 00:11:45,230
pointer every single time and so what

238
00:11:42,709 --> 00:11:47,959
you really need is a way to break the

239
00:11:45,230 --> 00:11:50,930
determinism of the ROM heap a locator in

240
00:11:47,959 --> 00:11:52,969
order to get a proper use after free and

241
00:11:50,930 --> 00:11:58,219
you get a right on top of something

242
00:11:52,970 --> 00:12:00,949
that's valuable and the heap allocation

243
00:11:58,220 --> 00:12:03,290
securom is quite interesting because it

244
00:12:00,949 --> 00:12:06,319
will return the smallest possible hole

245
00:12:03,290 --> 00:12:08,949
for a given size and by doing hip thank

246
00:12:06,319 --> 00:12:12,199
schooi you can actually create that

247
00:12:08,949 --> 00:12:12,769
perfectly a sized hole somewhere else in

248
00:12:12,199 --> 00:12:17,529
the heap

249
00:12:12,769 --> 00:12:22,040
while the buffer is still present and

250
00:12:17,529 --> 00:12:24,110
once you restart the USB stack the

251
00:12:22,040 --> 00:12:27,259
perfectly sized hole is going to be used

252
00:12:24,110 --> 00:12:28,939
instead of the previous hole thus

253
00:12:27,259 --> 00:12:31,910
creating an actual exploitable use of

254
00:12:28,939 --> 00:12:34,099
the recognition however in order to do

255
00:12:31,910 --> 00:12:40,009
this we need control allocation

256
00:12:34,100 --> 00:12:43,639
primitives now on the USB stack on

257
00:12:40,009 --> 00:12:48,139
securom when you have an in-flight USB

258
00:12:43,639 --> 00:12:50,269
transfer from the device to the host you

259
00:12:48,139 --> 00:12:53,959
will have an associated structure

260
00:12:50,269 --> 00:12:56,269
allocated on the heap and the host might

261
00:12:53,959 --> 00:12:59,449
actually request multiple transfers from

262
00:12:56,269 --> 00:13:01,639
the device to the host at the same time

263
00:12:59,449 --> 00:13:05,689
while other requests are still being

264
00:13:01,639 --> 00:13:07,490
processed and if you don't acknowledge

265
00:13:05,689 --> 00:13:11,059
the data that you're getting from the

266
00:13:07,490 --> 00:13:14,000
device the device is not going to be

267
00:13:11,059 --> 00:13:15,709
able to send further data packets and so

268
00:13:14,000 --> 00:13:17,930
they have some queuing mechanism that

269
00:13:15,709 --> 00:13:20,239
allows them to wait until the host is

270
00:13:17,930 --> 00:13:21,640
ready to receive the data in order to

271
00:13:20,240 --> 00:13:23,820
send the data

272
00:13:21,640 --> 00:13:28,980
and every time that you send a setup

273
00:13:23,820 --> 00:13:31,690
packet for a device to host request such

274
00:13:28,980 --> 00:13:34,060
such a buffer is going to stay in a

275
00:13:31,690 --> 00:13:39,580
queue and it will stay around for quite

276
00:13:34,060 --> 00:13:43,119
a while and this allows us to repeatedly

277
00:13:39,580 --> 00:13:44,470
do a single allocation and delay the

278
00:13:43,120 --> 00:13:47,500
point in time at which the free will

279
00:13:44,470 --> 00:13:50,290
happen which will be whenever the stall

280
00:13:47,500 --> 00:13:52,690
conditions are cleared or the USB stack

281
00:13:50,290 --> 00:13:55,120
is getting shut down however the issue

282
00:13:52,690 --> 00:13:58,300
is that we really need a way for

283
00:13:55,120 --> 00:14:01,510
allocations to persist across the SU

284
00:13:58,300 --> 00:14:03,160
exit and the DFU reenter for our hip

285
00:14:01,510 --> 00:14:05,620
shaping to influence the next location

286
00:14:03,160 --> 00:14:08,170
of our buffer and of course these are

287
00:14:05,620 --> 00:14:10,660
based on the USB stack which is turned

288
00:14:08,170 --> 00:14:14,110
down and realized every time the fu is X

289
00:14:10,660 --> 00:14:16,060
to the entered and so this is not good

290
00:14:14,110 --> 00:14:21,100
and it's not going to be very useful for

291
00:14:16,060 --> 00:14:23,410
us alone however there is also another

292
00:14:21,100 --> 00:14:25,630
issue in the USB stack that was very

293
00:14:23,410 --> 00:14:29,860
interesting there is a state machine bug

294
00:14:25,630 --> 00:14:32,020
in the USB stack that allows you to leak

295
00:14:29,860 --> 00:14:33,900
a locations across destruction and

296
00:14:32,020 --> 00:14:39,160
creation of the USB stack itself and

297
00:14:33,900 --> 00:14:42,459
this happens because of destructor for

298
00:14:39,160 --> 00:14:45,670
USB requests basically when you have a

299
00:14:42,460 --> 00:14:48,340
USB request from a device to the host it

300
00:14:45,670 --> 00:14:50,020
has to send that 0 LANs packet in order

301
00:14:48,340 --> 00:14:52,780
to inform the host that the data

302
00:14:50,020 --> 00:14:56,829
transfer is done and Apple does this in

303
00:14:52,780 --> 00:15:00,610
the destructor of the specific transfer

304
00:14:56,830 --> 00:15:04,380
in the queue so when you shut the USB

305
00:15:00,610 --> 00:15:07,780
stack down the zero length packet the

306
00:15:04,380 --> 00:15:10,450
destructor for a huge transfer is going

307
00:15:07,780 --> 00:15:12,880
to be invoked and the zero lines packet

308
00:15:10,450 --> 00:15:14,770
is going to be sent into the void

309
00:15:12,880 --> 00:15:16,960
basically because the USB stack is

310
00:15:14,770 --> 00:15:20,110
wiping itself is removing all its state

311
00:15:16,960 --> 00:15:22,240
and so you queue a packet that will

312
00:15:20,110 --> 00:15:24,070
never be sent and the queue is going to

313
00:15:22,240 --> 00:15:26,110
be destroyed and the packet is never

314
00:15:24,070 --> 00:15:27,970
going to be freed again and you can

315
00:15:26,110 --> 00:15:30,820
actually trigger these conditionally

316
00:15:27,970 --> 00:15:33,160
because only packets that have specific

317
00:15:30,820 --> 00:15:35,079
conditions will trigger this leak

318
00:15:33,160 --> 00:15:38,709
and for instance if you have a request

319
00:15:35,079 --> 00:15:40,779
that's not a multiple of 64 bytes it

320
00:15:38,709 --> 00:15:43,000
will not call the destructor in the same

321
00:15:40,779 --> 00:15:47,769
way and these allows you to perfectly

322
00:15:43,000 --> 00:15:49,420
heap shape as you want and yes as I

323
00:15:47,769 --> 00:15:51,279
mentioned you can use these to very

324
00:15:49,420 --> 00:15:53,500
carefully craft the state of the heap

325
00:15:51,279 --> 00:15:57,009
and you can end up with the hole in the

326
00:15:53,500 --> 00:15:58,839
heap that has the exact size for the USB

327
00:15:57,009 --> 00:16:01,560
buffer and that's might be the preferred

328
00:15:58,839 --> 00:16:04,240
place on the next real location and

329
00:16:01,560 --> 00:16:10,599
additionally these callback mechanism

330
00:16:04,240 --> 00:16:12,910
that cause the memory leak is stored on

331
00:16:10,600 --> 00:16:15,670
the heap itself and so every time that

332
00:16:12,910 --> 00:16:18,399
you do a USB request that goes into this

333
00:16:15,670 --> 00:16:21,430
queue you do have this function pointer

334
00:16:18,399 --> 00:16:23,680
to target and since we can now we

335
00:16:21,430 --> 00:16:26,319
allocate a few of those in place after

336
00:16:23,680 --> 00:16:29,079
we start in the USB stack we can perform

337
00:16:26,319 --> 00:16:32,110
the use after free right and have full

338
00:16:29,079 --> 00:16:34,329
control over an indirect branch and this

339
00:16:32,110 --> 00:16:37,870
strategy can successfully be used on

340
00:16:34,329 --> 00:16:40,388
basically any other vulnerable verse six

341
00:16:37,870 --> 00:16:45,579
children version other than a eight and

342
00:16:40,389 --> 00:16:48,069
a nine and however and other devices

343
00:16:45,579 --> 00:16:51,040
this is not workable because there is a

344
00:16:48,069 --> 00:16:54,729
lack of the conditional part of the info

345
00:16:51,040 --> 00:16:57,550
of memory leak and so the strategy using

346
00:16:54,730 --> 00:17:00,250
those devices instead was to almost feel

347
00:16:57,550 --> 00:17:02,410
the heat completely - exactly the size

348
00:17:00,250 --> 00:17:04,569
of the buffer that we want to target and

349
00:17:02,410 --> 00:17:06,428
this will create a hole at the very end

350
00:17:04,569 --> 00:17:10,629
of the heap that will be preferred by

351
00:17:06,429 --> 00:17:13,360
malloc and by doing this we have

352
00:17:10,630 --> 00:17:17,980
checkmate the actual vulnerability that

353
00:17:13,359 --> 00:17:19,839
I just presented and with these we have

354
00:17:17,980 --> 00:17:22,120
code execution however out of code

355
00:17:19,839 --> 00:17:25,359
execution as jailbreakers that we really

356
00:17:22,119 --> 00:17:27,760
want is the ability to have code

357
00:17:25,359 --> 00:17:32,139
execution a much later point and to do

358
00:17:27,760 --> 00:17:34,179
this we need to develop a boot kit to

359
00:17:32,140 --> 00:17:38,110
recap we have code execution in secure

360
00:17:34,179 --> 00:17:41,169
arms DFU mode which is the earliest code

361
00:17:38,110 --> 00:17:44,678
that runs from your device and our goal

362
00:17:41,169 --> 00:17:46,049
is to now take the device and have it

363
00:17:44,679 --> 00:17:50,039
restart the boot sequence

364
00:17:46,049 --> 00:17:52,470
and continue it normally and eventually

365
00:17:50,039 --> 00:17:54,600
the bootloader will get the kernel and

366
00:17:52,470 --> 00:17:57,330
it will branch into the entry point and

367
00:17:54,600 --> 00:17:59,820
our real goal is to patch the kernel at

368
00:17:57,330 --> 00:18:01,889
that point in time because there is

369
00:17:59,820 --> 00:18:04,470
curdled integrity protection on iPhones

370
00:18:01,889 --> 00:18:06,059
and at the point in time the kernel

371
00:18:04,470 --> 00:18:07,710
itself is still writable eyes so we can

372
00:18:06,059 --> 00:18:10,710
still do all kinds of patches that we

373
00:18:07,710 --> 00:18:13,649
want you however this is actually kind

374
00:18:10,710 --> 00:18:17,340
of tricky especially because basically

375
00:18:13,649 --> 00:18:19,350
any - until the iPhone access is

376
00:18:17,340 --> 00:18:22,799
vulnerable and there's many versions of

377
00:18:19,350 --> 00:18:24,959
iOS and we also want to have support for

378
00:18:22,799 --> 00:18:27,450
future versions without much effort and

379
00:18:24,960 --> 00:18:29,340
so we had to actually come up with some

380
00:18:27,450 --> 00:18:32,580
resilient patch finding strategies and

381
00:18:29,340 --> 00:18:35,100
some you know clever way in order to do

382
00:18:32,580 --> 00:18:38,639
this without invasive patches that

383
00:18:35,100 --> 00:18:43,738
require time every on every update on

384
00:18:38,639 --> 00:18:45,539
our part to maintain and in order to

385
00:18:43,739 --> 00:18:47,279
make this happen we abused what's called

386
00:18:45,539 --> 00:18:50,549
the boot trampoline which is a piece of

387
00:18:47,279 --> 00:18:53,190
code in I boot the wipes the CPU

388
00:18:50,549 --> 00:18:56,340
state-backed with an initial one which

389
00:18:53,190 --> 00:18:59,340
is done when a bootloader stage boots

390
00:18:56,340 --> 00:19:01,408
into the next stage and this is done in

391
00:18:59,340 --> 00:19:04,529
order to remove possible information

392
00:19:01,409 --> 00:19:06,389
leaks this will also wipe the contents

393
00:19:04,529 --> 00:19:08,879
of the previous bootloader image in

394
00:19:06,389 --> 00:19:10,590
order for security researchers to have a

395
00:19:08,879 --> 00:19:13,619
bad time extracting it from physical

396
00:19:10,590 --> 00:19:14,999
memory the memory management unit is

397
00:19:13,619 --> 00:19:17,189
going to be disabled in this trampoline

398
00:19:14,999 --> 00:19:19,529
and all the registered state is a 2-0

399
00:19:17,190 --> 00:19:21,739
and this is actually quite interesting

400
00:19:19,529 --> 00:19:24,480
because some registers are never used

401
00:19:21,739 --> 00:19:28,679
normally in code that's compiled for the

402
00:19:24,480 --> 00:19:31,289
iOS API and one of such registers X 80

403
00:19:28,679 --> 00:19:33,330
and by just searching for a move exiting

404
00:19:31,289 --> 00:19:34,889
0 instruction you will always find the

405
00:19:33,330 --> 00:19:37,859
boot trampoline on any I would base

406
00:19:34,889 --> 00:19:39,149
bootloader image and we can just write

407
00:19:37,859 --> 00:19:44,158
some shell code in order to find the

408
00:19:39,149 --> 00:19:46,439
specific opcode patch it out and once we

409
00:19:44,159 --> 00:19:49,139
do that we have the ability to patch the

410
00:19:46,440 --> 00:19:51,299
next image however we also have another

411
00:19:49,139 --> 00:19:55,559
issue with this we have a chicken and

412
00:19:51,299 --> 00:19:58,408
egg issue because as I said it will wipe

413
00:19:55,559 --> 00:19:59,220
the current stage bootloader so the

414
00:19:58,409 --> 00:20:01,559
action would try

415
00:19:59,220 --> 00:20:05,610
has to be relocated somewhere else in

416
00:20:01,559 --> 00:20:07,379
memory which is never wiped and to do

417
00:20:05,610 --> 00:20:09,270
these Apple action reserves a special

418
00:20:07,380 --> 00:20:12,450
region that's reserved only for the boot

419
00:20:09,270 --> 00:20:14,490
trampoline however the boot trampoline

420
00:20:12,450 --> 00:20:17,190
depending on which version you are is

421
00:20:14,490 --> 00:20:18,870
copy the different points in time so for

422
00:20:17,190 --> 00:20:21,870
our exploit to work on every single

423
00:20:18,870 --> 00:20:25,168
platform we had to make sure that the

424
00:20:21,870 --> 00:20:29,370
patches were done depending on the

425
00:20:25,169 --> 00:20:32,909
version on some versions you'd have to

426
00:20:29,370 --> 00:20:35,428
patch it in the relegated region in some

427
00:20:32,909 --> 00:20:38,850
versions you had to patch them on the

428
00:20:35,429 --> 00:20:41,789
original copy of it before it gets

429
00:20:38,850 --> 00:20:43,830
relocated by a boot itself and this is

430
00:20:41,789 --> 00:20:46,140
actually freaking Sakura because securom

431
00:20:43,830 --> 00:20:48,780
is read-only and they only get code

432
00:20:46,140 --> 00:20:52,070
execution before the relocation happens

433
00:20:48,780 --> 00:20:54,780
so patching it out was quite tricky

434
00:20:52,070 --> 00:20:58,260
however we were able to relocate the

435
00:20:54,780 --> 00:21:01,500
entirety of securom into SRAM and patch

436
00:20:58,260 --> 00:21:04,020
the page table entries in order to remap

437
00:21:01,500 --> 00:21:06,950
the ROM into this writable region

438
00:21:04,020 --> 00:21:10,200
instead and on some devices there is a

439
00:21:06,950 --> 00:21:13,320
512 kilobytes area that's very useful

440
00:21:10,200 --> 00:21:15,470
because we can just put any data wander

441
00:21:13,320 --> 00:21:18,299
and it's not going to be used by the

442
00:21:15,470 --> 00:21:20,640
legitimate code and you can relegate it

443
00:21:18,299 --> 00:21:22,379
there however on some other devices it's

444
00:21:20,640 --> 00:21:25,320
a bit more tricky because there is less

445
00:21:22,380 --> 00:21:27,690
as Frommer's available and on those

446
00:21:25,320 --> 00:21:30,120
areas we ended up just remapping the

447
00:21:27,690 --> 00:21:32,570
single page where the trampoline is

448
00:21:30,120 --> 00:21:34,530
located and patching the trampoline

449
00:21:32,570 --> 00:21:37,289
however there could also be other

450
00:21:34,530 --> 00:21:39,840
approaches taken such as reserving more

451
00:21:37,289 --> 00:21:45,140
l2 cache as addressable astrum or

452
00:21:39,840 --> 00:21:47,908
resizing the heap used by securom and

453
00:21:45,140 --> 00:21:49,710
once we have this we need to find an

454
00:21:47,909 --> 00:21:51,990
area where we can stash our shell code

455
00:21:49,710 --> 00:21:54,659
at because we do have code execution and

456
00:21:51,990 --> 00:21:59,370
we can patch single up codes but we want

457
00:21:54,659 --> 00:22:02,250
to have some more powerful code loaded

458
00:21:59,370 --> 00:22:04,139
and again we're still restricted by the

459
00:22:02,250 --> 00:22:07,169
available SRAM which is very little and

460
00:22:04,140 --> 00:22:11,070
we also need to do a normal boot which

461
00:22:07,169 --> 00:22:12,100
itself will make use of some SRAM and so

462
00:22:11,070 --> 00:22:15,129
we figured maybe

463
00:22:12,100 --> 00:22:16,659
we can just go and use DRM however the

464
00:22:15,130 --> 00:22:19,059
issue with DRM is that it's not

465
00:22:16,660 --> 00:22:21,309
initialized while securom is happening

466
00:22:19,059 --> 00:22:26,080
the first stage bootloader is in fact in

467
00:22:21,309 --> 00:22:28,600
charge of initializing DRM and so well

468
00:22:26,080 --> 00:22:31,000
we ended up going for was abusing a

469
00:22:28,600 --> 00:22:33,010
feature called soft DFU which is

470
00:22:31,000 --> 00:22:35,830
something Apple put in in order to

471
00:22:33,010 --> 00:22:41,020
simulate a DFU mode but instead of being

472
00:22:35,830 --> 00:22:44,320
on the first unpassable code base it

473
00:22:41,020 --> 00:22:47,770
runs on the first stage bootloader which

474
00:22:44,320 --> 00:22:50,200
can be altered by Apple and DRM is

475
00:22:47,770 --> 00:22:53,139
already initialized when soft DSU is

476
00:22:50,200 --> 00:22:55,990
started so that larger images can be

477
00:22:53,140 --> 00:22:58,809
uploaded and we end up abusing these in

478
00:22:55,990 --> 00:23:01,539
order to basically have the ability to

479
00:22:58,809 --> 00:23:04,210
load any data we want in even large

480
00:23:01,539 --> 00:23:07,299
amounts in the RAM without having to

481
00:23:04,210 --> 00:23:09,340
initialize it ourselves and risking say

482
00:23:07,299 --> 00:23:14,879
setting some incorrect voltages or doing

483
00:23:09,340 --> 00:23:17,740
some bad testing on the DRM cells and

484
00:23:14,880 --> 00:23:20,650
another issue we had was the large

485
00:23:17,740 --> 00:23:23,860
portions of DRM are sometimes cleared by

486
00:23:20,650 --> 00:23:25,929
boot and we do have a hook around iWork

487
00:23:23,860 --> 00:23:28,629
run for this by hooking bit 0 and

488
00:23:25,929 --> 00:23:31,000
detecting whether the range of the bit 0

489
00:23:28,630 --> 00:23:33,100
overlaps with our shellcode and we just

490
00:23:31,000 --> 00:23:35,080
knock out the bit 0 and this is not

491
00:23:33,100 --> 00:23:36,658
really nice because it will leave large

492
00:23:35,080 --> 00:23:39,490
swaths of theorem basically

493
00:23:36,659 --> 00:23:44,640
uninitialized but it works pretty well

494
00:23:39,490 --> 00:23:44,640
and yeah we just ended up going for it

495
00:23:45,690 --> 00:23:52,750
once you have the trampoline hook and

496
00:23:48,220 --> 00:23:54,760
the bit 0 hook in place you can run the

497
00:23:52,750 --> 00:23:58,600
same code to patch the next trampoline

498
00:23:54,760 --> 00:24:00,760
in a recursive fashion and devices

499
00:23:58,600 --> 00:24:03,668
before 810 for instance we use multiple

500
00:24:00,760 --> 00:24:05,530
stages of boot loaders and so this whole

501
00:24:03,669 --> 00:24:08,289
trampoline who can be through hook has

502
00:24:05,530 --> 00:24:11,080
to be reapplied twice on a tenon later

503
00:24:08,289 --> 00:24:13,390
this is not really needed but we still

504
00:24:11,080 --> 00:24:17,408
do it even there in case it's necessary

505
00:24:13,390 --> 00:24:21,280
if you do say a wrister boot chain from

506
00:24:17,409 --> 00:24:22,919
the recovery mode and eventually the

507
00:24:21,280 --> 00:24:25,230
boot loader itself

508
00:24:22,919 --> 00:24:27,090
we'll decide to put the kernel and it

509
00:24:25,230 --> 00:24:29,639
will have the kernel image prepared in

510
00:24:27,090 --> 00:24:33,238
memory and it will invoke the trampoline

511
00:24:29,639 --> 00:24:36,840
again this time to boot the kernel on

512
00:24:33,239 --> 00:24:38,999
devices were there is a l3 the secure

513
00:24:36,840 --> 00:24:42,029
Monitor entry point is going to be used

514
00:24:38,999 --> 00:24:43,919
instead of the kernel one and the kernel

515
00:24:42,029 --> 00:24:45,570
arguments and the actual kernel entry

516
00:24:43,919 --> 00:24:48,690
point are themselves going to be passed

517
00:24:45,570 --> 00:24:53,220
as a kernel as a secure monitor argument

518
00:24:48,690 --> 00:24:55,529
and since we can do a hook on the on the

519
00:24:53,220 --> 00:24:58,529
trampoline we can override the branch

520
00:24:55,529 --> 00:25:02,070
target run our shell code before running

521
00:24:58,529 --> 00:25:06,299
the original function and at that point

522
00:25:02,070 --> 00:25:09,389
in time we can keep a copy of the actual

523
00:25:06,299 --> 00:25:12,749
original entry point and from there we

524
00:25:09,389 --> 00:25:14,129
can apply our patches and with all these

525
00:25:12,749 --> 00:25:17,159
primitives we are now able to actually

526
00:25:14,129 --> 00:25:19,859
patch the kernel image at boot however

527
00:25:17,159 --> 00:25:21,809
since as I mentioned earlier we want to

528
00:25:19,859 --> 00:25:25,889
have support for arbitrary device and

529
00:25:21,809 --> 00:25:28,799
version pairs hard patches that are

530
00:25:25,889 --> 00:25:31,199
constantly defined are not really useful

531
00:25:28,799 --> 00:25:33,119
here and the only sane strategy for us

532
00:25:31,200 --> 00:25:37,169
was to do dynamic patch finding from

533
00:25:33,119 --> 00:25:39,539
this point and the issue is that the

534
00:25:37,169 --> 00:25:41,999
patches that we've done so far are in

535
00:25:39,539 --> 00:25:44,190
the boot trampolines tail end where

536
00:25:41,999 --> 00:25:47,580
there is no mm you know caching know

537
00:25:44,190 --> 00:25:49,739
anything enabled and unfortunately these

538
00:25:47,580 --> 00:25:52,710
becomes very slow the kernel image on

539
00:25:49,739 --> 00:25:54,539
iOS is roughly 30 megabytes and by doing

540
00:25:52,710 --> 00:25:58,710
genomic patch finding we have to scan

541
00:25:54,539 --> 00:26:02,158
the entire range of 30 mags multiple

542
00:25:58,710 --> 00:26:05,009
times and you get up any caching without

543
00:26:02,159 --> 00:26:07,470
the MU this becomes very very very slow

544
00:26:05,009 --> 00:26:09,840
and so we have to set the MMU back on

545
00:26:07,470 --> 00:26:11,850
and create that set of page table

546
00:26:09,840 --> 00:26:14,549
entries that map a view of DM as

547
00:26:11,850 --> 00:26:15,748
cashable memory and by doing these the

548
00:26:14,549 --> 00:26:19,440
patch render can actually work

549
00:26:15,749 --> 00:26:26,279
efficiently and find other patches in

550
00:26:19,440 --> 00:26:29,159
basically less than a second now on iOS

551
00:26:26,279 --> 00:26:32,519
in the past several years the patching

552
00:26:29,159 --> 00:26:34,020
strategies usually involved bypassing

553
00:26:32,519 --> 00:26:36,990
kernel patch production and kernel

554
00:26:34,020 --> 00:26:38,910
integrity mechanisms however here since

555
00:26:36,990 --> 00:26:41,370
we are able to do patches as such an

556
00:26:38,910 --> 00:26:44,250
early stage in the boot process it is

557
00:26:41,370 --> 00:26:47,189
not required to even work around patch

558
00:26:44,250 --> 00:26:52,050
protection and this means that it's

559
00:26:47,190 --> 00:26:53,910
basically like it's ios8 over again some

560
00:26:52,050 --> 00:26:57,210
of the patches that have not been able

561
00:26:53,910 --> 00:26:59,700
to be performed in the past several

562
00:26:57,210 --> 00:27:03,420
years were for instance VM map protect

563
00:26:59,700 --> 00:27:07,590
which allows emulator developers to

564
00:27:03,420 --> 00:27:10,290
develop JIT vm fault enter which is also

565
00:27:07,590 --> 00:27:13,199
going to be useful for people that want

566
00:27:10,290 --> 00:27:16,379
to develop cheats on iphone we patch the

567
00:27:13,200 --> 00:27:19,770
AMF I trust cache loading so basically

568
00:27:16,380 --> 00:27:22,800
any marker can be loaded without about

569
00:27:19,770 --> 00:27:26,960
its signature we patch out the sandbox

570
00:27:22,800 --> 00:27:30,750
in order to weaken it so people can load

571
00:27:26,960 --> 00:27:32,550
tweaks which might make use of files in

572
00:27:30,750 --> 00:27:35,760
some shared folders that are normally

573
00:27:32,550 --> 00:27:37,770
not accessible we allow the root

574
00:27:35,760 --> 00:27:42,210
filesystem to be remounted as read/write

575
00:27:37,770 --> 00:27:44,340
and we give the ability to get kernel

576
00:27:42,210 --> 00:27:47,840
with right to user space processes that

577
00:27:44,340 --> 00:27:47,840
have a special signature

578
00:27:48,830 --> 00:27:55,260
however kernel patching alone is not

579
00:27:51,990 --> 00:27:58,170
enough it's a good starting point we do

580
00:27:55,260 --> 00:28:00,210
need to retain code execution after user

581
00:27:58,170 --> 00:28:02,160
mode user mode starts in order to

582
00:28:00,210 --> 00:28:05,010
prepare the sub working State for

583
00:28:02,160 --> 00:28:08,820
instance we want to place and package

584
00:28:05,010 --> 00:28:11,280
manager or SSH daemon into the device so

585
00:28:08,820 --> 00:28:15,000
we need to have user mode code execution

586
00:28:11,280 --> 00:28:17,520
in order to do so and to accomplish this

587
00:28:15,000 --> 00:28:20,070
we can embed a tiny ramdisk in our shell

588
00:28:17,520 --> 00:28:25,139
code in order to hide the code execution

589
00:28:20,070 --> 00:28:27,480
on the l0 and once we do this we can

590
00:28:25,140 --> 00:28:30,420
patch device three to tell the colonel

591
00:28:27,480 --> 00:28:34,710
that there is a ram disk in DRAM and to

592
00:28:30,420 --> 00:28:37,050
use that as the root filesystem and yep

593
00:28:34,710 --> 00:28:39,960
this is the end result of our patch

594
00:28:37,050 --> 00:28:41,820
finder being run we have a driver for

595
00:28:39,960 --> 00:28:44,460
the screen so we can display the status

596
00:28:41,820 --> 00:28:45,939
of the patches being applied and we have

597
00:28:44,460 --> 00:28:49,269
our logo being

598
00:28:45,940 --> 00:28:57,220
on top of the Apple logo for some cool

599
00:28:49,269 --> 00:28:58,679
effect and once we get to that point we

600
00:28:57,220 --> 00:29:02,740
basically started from the very bottom

601
00:28:58,679 --> 00:29:05,350
from securom code execution which is the

602
00:29:02,740 --> 00:29:07,929
lowest layer possible for iOS code

603
00:29:05,350 --> 00:29:11,139
execution to happen and they got all the

604
00:29:07,929 --> 00:29:14,769
way to yield zero user mode which is the

605
00:29:11,139 --> 00:29:20,080
highest level us code execution can

606
00:29:14,769 --> 00:29:23,200
happen at and our RAM disk has some

607
00:29:20,080 --> 00:29:25,299
intrinsic limitations because we are

608
00:29:23,200 --> 00:29:27,669
using the DF few transfers as a way to

609
00:29:25,299 --> 00:29:31,418
transfer this data and this is quite

610
00:29:27,669 --> 00:29:33,250
slow so if we had say Apple uses a

611
00:29:31,419 --> 00:29:35,559
hundred megabyte from disks these days

612
00:29:33,250 --> 00:29:37,419
if we had to actually upload the hundred

613
00:29:35,559 --> 00:29:40,000
megabyte by using the DF you transfer

614
00:29:37,419 --> 00:29:41,679
mechanism it would take probably around

615
00:29:40,000 --> 00:29:46,840
a minute to actually complete such a

616
00:29:41,679 --> 00:29:48,730
transfer so we went for a very very tiny

617
00:29:46,840 --> 00:29:50,918
random disk for this particular reason

618
00:29:48,730 --> 00:29:53,289
but also there is copyright concerns

619
00:29:50,919 --> 00:29:55,539
because brand disks will usually contain

620
00:29:53,289 --> 00:29:57,490
Apple dynamic libraries and we're not

621
00:29:55,539 --> 00:30:01,570
able to redistribute apple dynamic

622
00:29:57,490 --> 00:30:05,200
libraries without a license and yeah I

623
00:30:01,570 --> 00:30:07,389
mean the lack of Apple libraries and the

624
00:30:05,200 --> 00:30:10,090
need we have a small Ram disk will

625
00:30:07,389 --> 00:30:12,370
compound because essentially we have

626
00:30:10,090 --> 00:30:15,100
nothing available to us in user space we

627
00:30:12,370 --> 00:30:17,649
have a no dynamic linker we have no

628
00:30:15,100 --> 00:30:19,570
libraries whatsoever and so we had to

629
00:30:17,649 --> 00:30:21,850
start writing our own totally legitimate

630
00:30:19,570 --> 00:30:23,678
dynamic linker now this is not an actual

631
00:30:21,850 --> 00:30:26,049
dynamic linker we'll just say it is and

632
00:30:23,679 --> 00:30:28,269
what this actually does it will wait for

633
00:30:26,049 --> 00:30:31,179
the real root filesystem to show up and

634
00:30:28,269 --> 00:30:35,409
once the real filesystem shows up it

635
00:30:31,179 --> 00:30:36,759
will call exactly again after Union

636
00:30:35,409 --> 00:30:41,379
mounting it on top of the RAM disk

637
00:30:36,759 --> 00:30:43,990
itself so these will wait overwrite the

638
00:30:41,379 --> 00:30:48,219
RAM disk load shared libraries in place

639
00:30:43,990 --> 00:30:54,789
from the root filesystem and then once

640
00:30:48,220 --> 00:30:56,590
we execute the real launch D we are we

641
00:30:54,789 --> 00:30:57,980
have dynamic linking and all the

642
00:30:56,590 --> 00:31:00,770
libraries available

643
00:30:57,980 --> 00:31:05,180
so at this point in time we have full

644
00:31:00,770 --> 00:31:07,670
code execution as PID 1 with everything

645
00:31:05,180 --> 00:31:13,520
that iOS usually gives you available to

646
00:31:07,670 --> 00:31:16,850
us and at this point however it's still

647
00:31:13,520 --> 00:31:18,379
read-only and we actually thought that

648
00:31:16,850 --> 00:31:21,439
it would be nice to keep the root file

649
00:31:18,380 --> 00:31:25,430
system itself read-only unless the user

650
00:31:21,440 --> 00:31:28,250
explicitly asks to change this now for

651
00:31:25,430 --> 00:31:31,610
the unfamiliar people with job breaking

652
00:31:28,250 --> 00:31:33,620
Iowa's most jailbreakers one to the root

653
00:31:31,610 --> 00:31:35,620
file system to be writable in order to

654
00:31:33,620 --> 00:31:38,419
add a package manager for instance

655
00:31:35,620 --> 00:31:41,780
however we thought that some use cases

656
00:31:38,420 --> 00:31:45,290
and some research tooling did not need

657
00:31:41,780 --> 00:31:47,360
to have any of these and the readwrite

658
00:31:45,290 --> 00:31:49,700
part of the root file system can be

659
00:31:47,360 --> 00:31:51,709
sketchy can damage your device or in

660
00:31:49,700 --> 00:31:54,980
some cases it can invalidate forensic

661
00:31:51,710 --> 00:31:56,780
integrity of the device so we ended up

662
00:31:54,980 --> 00:31:58,970
figuring out a way to keep it read only

663
00:31:56,780 --> 00:32:02,930
but also having the ability to drop some

664
00:31:58,970 --> 00:32:06,860
extra files in it only temporarily while

665
00:32:02,930 --> 00:32:08,570
our code is running and in order to do

666
00:32:06,860 --> 00:32:11,209
this we do need to have the data

667
00:32:08,570 --> 00:32:15,080
partition available to us we're normally

668
00:32:11,210 --> 00:32:17,330
data is copied into from applications

669
00:32:15,080 --> 00:32:19,370
and something like that then needs to

670
00:32:17,330 --> 00:32:21,590
have non-volatile storage however the

671
00:32:19,370 --> 00:32:24,020
data partition itself requires data

672
00:32:21,590 --> 00:32:26,990
protection which needs to be initialized

673
00:32:24,020 --> 00:32:30,830
for this to work and lounge D is

674
00:32:26,990 --> 00:32:36,650
responsible for initialization of the

675
00:32:30,830 --> 00:32:39,409
data protection basically now we were

676
00:32:36,650 --> 00:32:41,210
branding code before launch D and so we

677
00:32:39,410 --> 00:32:44,840
actually need to be able to hook code

678
00:32:41,210 --> 00:32:47,540
execution later on but still early

679
00:32:44,840 --> 00:32:49,639
enough that everything else in the file

680
00:32:47,540 --> 00:32:53,240
in the operating system hasn't run yet

681
00:32:49,640 --> 00:32:56,690
and so in order to do this we keep using

682
00:32:53,240 --> 00:32:59,150
Union mounting with disk images and this

683
00:32:56,690 --> 00:33:01,190
time we will overlay a disk image on top

684
00:32:59,150 --> 00:33:04,460
of user Lib exactly which is the folder

685
00:33:01,190 --> 00:33:06,380
where system demon binaries are stored

686
00:33:04,460 --> 00:33:08,090
and by doing this we can override any

687
00:33:06,380 --> 00:33:10,060
system demon we have code sign

688
00:33:08,090 --> 00:33:11,709
enforcement disabled with

689
00:33:10,060 --> 00:33:14,889
Colonel patches I told you about before

690
00:33:11,710 --> 00:33:16,450
and we picked system status check as a

691
00:33:14,890 --> 00:33:19,270
system diamond that we could overwrite

692
00:33:16,450 --> 00:33:23,170
because these will be executed before

693
00:33:19,270 --> 00:33:25,270
the userspace gets launched by lunch d

694
00:33:23,170 --> 00:33:27,880
but after that the production is

695
00:33:25,270 --> 00:33:30,520
initialized and once we get code

696
00:33:27,880 --> 00:33:33,250
execution there we can execute something

697
00:33:30,520 --> 00:33:35,830
back in the original RAM disk and force

698
00:33:33,250 --> 00:33:38,050
amount the disk image amounted on user a

699
00:33:35,830 --> 00:33:39,610
little bit sack and by doing these the

700
00:33:38,050 --> 00:33:43,450
system state will go back to the normal

701
00:33:39,610 --> 00:33:45,100
and we can later on we execute the real

702
00:33:43,450 --> 00:33:50,320
systems that this jackass do not have

703
00:33:45,100 --> 00:33:51,790
any potential issue and yep at this

704
00:33:50,320 --> 00:33:54,939
point we can just let launch the

705
00:33:51,790 --> 00:33:57,639
continue booting and we can further it

706
00:33:54,940 --> 00:34:00,910
before doing so so we can have some

707
00:33:57,640 --> 00:34:06,210
demon remain around as the system boots

708
00:34:00,910 --> 00:34:09,970
up and we wait until way we wait until

709
00:34:06,210 --> 00:34:12,310
USB is initialized by iOS and we wait

710
00:34:09,969 --> 00:34:14,560
for the host to upload a disk image

711
00:34:12,310 --> 00:34:16,690
containing all the required activities

712
00:34:14,560 --> 00:34:19,690
for basic jailbreaking as I mentioned

713
00:34:16,690 --> 00:34:21,520
earlier as a sage daemon and an app that

714
00:34:19,690 --> 00:34:22,450
allows you to install a package manager

715
00:34:21,520 --> 00:34:25,389
if you so wish

716
00:34:22,449 --> 00:34:29,409
and we mount this on bin pack and we

717
00:34:25,389 --> 00:34:31,900
start the SSH daemon and this is a root

718
00:34:29,409 --> 00:34:36,159
shell on fully updated at the time

719
00:34:31,900 --> 00:34:37,570
iPhone and to this day you can still

720
00:34:36,159 --> 00:34:39,489
download the latest version of iOS

721
00:34:37,570 --> 00:34:41,830
install it download the latest version

722
00:34:39,489 --> 00:34:45,399
of check-rein and it will give your

723
00:34:41,830 --> 00:34:48,029
shell on vulnerable iPhones without any

724
00:34:45,400 --> 00:34:48,030
issue

725
00:34:53,110 --> 00:35:02,710
and so today I actually have some new

726
00:34:58,990 --> 00:35:04,529
things we had mostly positive reviews

727
00:35:02,710 --> 00:35:08,160
from the doubler community for this

728
00:35:04,530 --> 00:35:10,810
however two major issues still remain

729
00:35:08,160 --> 00:35:12,370
people want a Linux and the Windows

730
00:35:10,810 --> 00:35:14,980
version of check-rein because right now

731
00:35:12,370 --> 00:35:17,650
this entire thing is for my quest only

732
00:35:14,980 --> 00:35:20,020
and today we are actually introducing

733
00:35:17,650 --> 00:35:28,390
the Linux part thanks to the hard work

734
00:35:20,020 --> 00:35:32,230
of Nikias and Daniel so it's not just a

735
00:35:28,390 --> 00:35:35,910
Linux part actually because we ended up

736
00:35:32,230 --> 00:35:35,910
maybe over-engineering it

737
00:35:44,990 --> 00:35:54,069
I think so

738
00:35:50,359 --> 00:35:59,450
we made a web server basically that

739
00:35:54,070 --> 00:36:00,920
displays live and curses you I and this

740
00:35:59,450 --> 00:36:02,419
is the Linux version so you I mean you

741
00:36:00,920 --> 00:36:04,520
can open these and see it on your

742
00:36:02,420 --> 00:36:06,980
terminal but the nice thing about these

743
00:36:04,520 --> 00:36:10,099
is that you can run this on a Raspberry

744
00:36:06,980 --> 00:36:13,010
Pi and then connect to it and see the

745
00:36:10,099 --> 00:36:15,560
terminal output of the anchors window

746
00:36:13,010 --> 00:36:17,869
and it's fully functional it's on par

747
00:36:15,560 --> 00:36:22,400
with the actual GUI that we have a Mac

748
00:36:17,869 --> 00:36:24,440
OS literally it's the same except it's

749
00:36:22,400 --> 00:36:29,180
textual and you can access it from the

750
00:36:24,440 --> 00:36:33,260
web and it's it's pretty cool to

751
00:36:29,180 --> 00:36:37,339
actually see it work and you again it

752
00:36:33,260 --> 00:36:45,680
might be over engineered but it's worth

753
00:36:37,339 --> 00:36:47,839
it and again very usefully like you can

754
00:36:45,680 --> 00:36:49,640
imagine having a phone that you want to

755
00:36:47,839 --> 00:36:52,130
jailbreak and you have to do this

756
00:36:49,640 --> 00:36:54,049
procedure every time on to turn it on so

757
00:36:52,130 --> 00:36:57,800
if you have a headless thing like

758
00:36:54,050 --> 00:37:01,570
Raspberry Pi 0 it's gonna be very very

759
00:36:57,800 --> 00:37:01,570
very convenient to have such a web UI

760
00:37:02,560 --> 00:37:10,580
and the next slide is gonna be probably

761
00:37:07,670 --> 00:37:12,609
the most requested thing I've had my

762
00:37:10,580 --> 00:37:16,339
twitter over the past three months

763
00:37:12,609 --> 00:37:19,098
constant mentions for a Windows version

764
00:37:16,339 --> 00:37:22,160
of checkering and unfortunately in order

765
00:37:19,099 --> 00:37:26,330
to make this happen it required us to

766
00:37:22,160 --> 00:37:28,390
make some custom drivers and you can see

767
00:37:26,330 --> 00:37:28,390
it

768
00:37:32,150 --> 00:37:37,350
run this is a common line on diversion

769
00:37:36,060 --> 00:37:38,790
it's very early we're not releasing

770
00:37:37,350 --> 00:37:42,450
these just yet but this is the very

771
00:37:38,790 --> 00:37:46,560
first time that we show Windows based

772
00:37:42,450 --> 00:37:48,870
version of Jack Crane run and this was

773
00:37:46,560 --> 00:37:50,730
actually developed mostly by cellebrite

774
00:37:48,870 --> 00:37:52,620
so I do want to thank them for the

775
00:37:50,730 --> 00:37:56,880
contribution that they've made to the

776
00:37:52,620 --> 00:37:59,279
project and the custom driver I believe

777
00:37:56,880 --> 00:38:01,050
will also be signed so normal people

778
00:37:59,280 --> 00:38:03,660
will be able to just use this

779
00:38:01,050 --> 00:38:07,680
application without having to boot their

780
00:38:03,660 --> 00:38:09,450
computer in any special mode and we

781
00:38:07,680 --> 00:38:12,750
first enter recovery mode and then

782
00:38:09,450 --> 00:38:15,149
entered the fu mode for data integrity

783
00:38:12,750 --> 00:38:23,040
reasons and the device is now entering

784
00:38:15,150 --> 00:38:25,830
the fu mode and it's been detected we do

785
00:38:23,040 --> 00:38:31,080
some initial testing and we were able to

786
00:38:25,830 --> 00:38:33,650
send the partial data transfer Shou code

787
00:38:31,080 --> 00:38:33,650
is being uploaded

788
00:38:38,230 --> 00:38:42,310
and this is the soft efu phase and there

789
00:38:41,829 --> 00:38:44,290
we go

790
00:38:42,310 --> 00:38:56,230
device is booting and our payload is

791
00:38:44,290 --> 00:39:00,099
running we're live

792
00:38:56,230 --> 00:39:01,720
okay so actually the Linux version of

793
00:39:00,099 --> 00:39:04,510
sectoring that I just introduced I

794
00:39:01,720 --> 00:39:06,310
wasn't sure if it would be live during

795
00:39:04,510 --> 00:39:09,790
this talk or not but it's available

796
00:39:06,310 --> 00:39:12,339
right now so you can go on check rate

797
00:39:09,790 --> 00:39:14,560
that I am and get it and many people are

798
00:39:12,339 --> 00:39:17,078
gonna be very thankful for this we took

799
00:39:14,560 --> 00:39:19,359
quite a long while to actually end up

800
00:39:17,079 --> 00:39:21,460
with a Linux version but we encountered

801
00:39:19,359 --> 00:39:24,520
many issues along the way and we had to

802
00:39:21,460 --> 00:39:27,460
make something that worked on many

803
00:39:24,520 --> 00:39:29,079
platforms some without the UI and so it

804
00:39:27,460 --> 00:39:33,180
took us a while to get the anchors

805
00:39:29,079 --> 00:39:36,640
things running smoothly but in the end

806
00:39:33,180 --> 00:39:38,169
it's pretty cool to see like what we

807
00:39:36,640 --> 00:39:40,359
accomplished over the past couple months

808
00:39:38,170 --> 00:39:42,490
so I I do want to thank all the people

809
00:39:40,359 --> 00:39:53,319
involved with this because it's been

810
00:39:42,490 --> 00:39:55,779
really great so I'll be wrapping up

811
00:39:53,319 --> 00:39:57,040
early I think because I had another five

812
00:39:55,780 --> 00:39:59,290
minutes available

813
00:39:57,040 --> 00:40:05,140
I love the demos I thought would take

814
00:39:59,290 --> 00:40:07,440
more I think we're good yep thank you

815
00:40:05,140 --> 00:40:07,440
very much

