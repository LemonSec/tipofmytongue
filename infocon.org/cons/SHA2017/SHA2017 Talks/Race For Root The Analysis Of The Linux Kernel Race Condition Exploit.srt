1
00:00:00,000 --> 00:00:08,800
[Music]

2
00:00:14,179 --> 00:00:21,240
our next talk will be<font color="#E5E5E5"> presented by</font>

3
00:00:17,160 --> 00:00:25,350
Alexander Popov<font color="#E5E5E5"> he is a Linux kernel</font>

4
00:00:21,240 --> 00:00:27,720
developer<font color="#E5E5E5"> specialized in security and he</font>

5
00:00:25,350 --> 00:00:29,640
will tell us<font color="#E5E5E5"> about the race for the</font>

6
00:00:27,720 --> 00:00:32,610
<font color="#CCCCCC">route and analysis of</font><font color="#E5E5E5"> the Linux kernel</font>

7
00:00:29,640 --> 00:00:44,760
race condition<font color="#E5E5E5"> exploit give him a</font>

8
00:00:32,610 --> 00:00:48,870
welcoming warm applause hello thanks for

9
00:00:44,760 --> 00:00:51,510
<font color="#CCCCCC">coming</font><font color="#E5E5E5"> I'm Alexander Popov and the name</font>

10
00:00:48,870 --> 00:00:55,078
of<font color="#CCCCCC"> my</font><font color="#E5E5E5"> talk is race for route I will tell</font>

11
00:00:51,510 --> 00:00:57,660
you about the exploitation of<font color="#E5E5E5"> the race</font>

12
00:00:55,079 --> 00:01:00,510
condition in the Linux kernel<font color="#CCCCCC"> and first</font>

13
00:00:57,660 --> 00:01:06,119
of<font color="#E5E5E5"> all I would like to</font><font color="#CCCCCC"> ask who you have</font>

14
00:01:00,510 --> 00:01:12,030
have never heard about Linux<font color="#E5E5E5"> nice I'm at</font>

15
00:01:06,119 --> 00:01:14,040
the right<font color="#E5E5E5"> place</font><font color="#CCCCCC"> so yes I'm a Linux</font>

16
00:01:12,030 --> 00:01:17,520
kernel developer and<font color="#CCCCCC"> I am</font><font color="#E5E5E5"> a security</font>

17
00:01:14,040 --> 00:01:20,490
<font color="#E5E5E5">researcher at positive technologist mmm</font>

18
00:01:17,520 --> 00:01:22,470
<font color="#CCCCCC">the plan</font><font color="#E5E5E5"> of the talk first of all I will</font>

19
00:01:20,490 --> 00:01:27,449
tell you about the vulnerability which I

20
00:01:22,470 --> 00:01:31,049
found show<font color="#CCCCCC"> the exploit demo</font><font color="#E5E5E5"> video and</font>

21
00:01:27,450 --> 00:01:33,990
then describe<font color="#CCCCCC"> the steps they exploit</font>

22
00:01:31,049 --> 00:01:36,119
<font color="#E5E5E5">step by step how to hit the race</font>

23
00:01:33,990 --> 00:01:39,929
condition and get double free out<font color="#CCCCCC"> of it</font>

24
00:01:36,119 --> 00:01:42,530
<font color="#E5E5E5">how to turn double free into user free</font>

25
00:01:39,930 --> 00:01:46,170
and<font color="#E5E5E5"> exploited and finally how to bypass</font>

26
00:01:42,530 --> 00:01:48,540
SM<font color="#E5E5E5"> EP supervisor mode execution</font>

27
00:01:46,170 --> 00:01:51,060
prevention<font color="#E5E5E5"> without return oriented</font>

28
00:01:48,540 --> 00:01:55,880
<font color="#E5E5E5">programming I will show another way to</font>

29
00:01:51,060 --> 00:01:55,880
do it<font color="#CCCCCC"> and finally</font><font color="#E5E5E5"> about their defense</font>

30
00:01:57,750 --> 00:02:03,420
this<font color="#E5E5E5"> vulnerability is a local privilege</font>

31
00:02:01,299 --> 00:02:07,500
escalations<font color="#E5E5E5"> law in the linux kernel and</font>

32
00:02:03,420 --> 00:02:13,750
it has a race condition<font color="#CCCCCC"> in the n hdl-c</font>

33
00:02:07,500 --> 00:02:17,230
kernel driver<font color="#CCCCCC"> this driver is is provided</font>

34
00:02:13,750 --> 00:02:21,730
by all major<font color="#CCCCCC"> destroys it is it goes as a</font>

35
00:02:17,230 --> 00:02:26,290
loadable kernel module and that's why

36
00:02:21,730 --> 00:02:31,290
all majors<font color="#CCCCCC"> districts were affected what</font>

37
00:02:26,290 --> 00:02:34,359
is what this driver<font color="#E5E5E5"> is used for it has a</font>

38
00:02:31,290 --> 00:02:38,200
driver supporting the line discipline

39
00:02:34,360 --> 00:02:40,360
for the<font color="#CCCCCC"> tty subsystem which supports</font>

40
00:02:38,200 --> 00:02:43,298
<font color="#CCCCCC">high-level data link control protocol it</font>

41
00:02:40,360 --> 00:02:48,160
<font color="#CCCCCC">is a data link control data link</font>

42
00:02:43,299 --> 00:02:51,069
protocol and<font color="#CCCCCC"> it's frames can be sent by</font>

43
00:02:48,160 --> 00:02:55,630
<font color="#CCCCCC">a serial lines and now it's mainly used</font>

44
00:02:51,069 --> 00:03:01,600
for for<font color="#E5E5E5"> device to device communication</font>

45
00:02:55,630 --> 00:03:04,269
and<font color="#E5E5E5"> this bug this particular bug was</font>

46
00:03:01,600 --> 00:03:08,858
introduced quite<font color="#CCCCCC"> a long time ago in</font><font color="#E5E5E5"> 2009</font>

47
00:03:04,269 --> 00:03:11,019
and more than<font color="#E5E5E5"> seven years later</font><font color="#CCCCCC"> the SIS</font>

48
00:03:08,859 --> 00:03:13,930
<font color="#CCCCCC">caller</font><font color="#E5E5E5"> father on my machine</font>

49
00:03:11,019 --> 00:03:15,670
give me a suspicious crush this<font color="#CCCCCC"> caller</font>

50
00:03:13,930 --> 00:03:22,980
<font color="#CCCCCC">is a really good project you should</font>

51
00:03:15,670 --> 00:03:30,208
check out check out it it allowed to

52
00:03:22,980 --> 00:03:34,450
make<font color="#E5E5E5"> Linux kernel code much better</font><font color="#CCCCCC"> and</font>

53
00:03:30,209 --> 00:03:41,620
several<font color="#E5E5E5"> D days after that I had a stable</font>

54
00:03:34,450 --> 00:03:45,578
<font color="#E5E5E5">rest condition repre and then was a very</font>

55
00:03:41,620 --> 00:03:48,010
intensive<font color="#E5E5E5"> working time and at the end of</font>

56
00:03:45,579 --> 00:03:49,989
the month I had an exploit<font color="#E5E5E5"> proof of</font>

57
00:03:48,010 --> 00:03:53,380
concept and<font color="#E5E5E5"> the patch fixing this</font>

58
00:03:49,989 --> 00:03:56,440
particular bug then at the<font color="#CCCCCC"> end of</font>

59
00:03:53,380 --> 00:04:00,670
<font color="#E5E5E5">February I contacted</font><font color="#CCCCCC"> security at</font>

60
00:03:56,440 --> 00:04:03,190
kernel.org<font color="#CCCCCC"> and several D days after that</font>

61
00:04:00,670 --> 00:04:06,909
<font color="#E5E5E5">all</font><font color="#CCCCCC"> major distress</font><font color="#E5E5E5"> which were affected</font>

62
00:04:03,190 --> 00:04:10,260
<font color="#E5E5E5">were informed</font><font color="#CCCCCC"> about this vulnerability</font>

63
00:04:06,909 --> 00:04:14,609
<font color="#CCCCCC">and they were giving my</font>

64
00:04:10,260 --> 00:04:17,760
my<font color="#E5E5E5"> patch was provided to them their 7th</font>

65
00:04:14,610 --> 00:04:21,329
of March was the<font color="#E5E5E5"> end of embargo and I</font>

66
00:04:17,760 --> 00:04:24,630
announced this vulnerability on the

67
00:04:21,329 --> 00:04:29,460
public mailing list<font color="#E5E5E5"> and at that</font>

68
00:04:24,630 --> 00:04:33,560
<font color="#E5E5E5">particular day</font><font color="#CCCCCC"> these</font><font color="#E5E5E5"> drawers provided</font>

69
00:04:29,460 --> 00:04:40,919
the update<font color="#E5E5E5"> a kernel update for for Linux</font>

70
00:04:33,560 --> 00:04:43,410
<font color="#CCCCCC">and several weeks after that I published</font>

71
00:04:40,919 --> 00:04:47,880
a<font color="#E5E5E5"> write-up</font><font color="#CCCCCC"> about this</font><font color="#E5E5E5"> that vulnerability</font>

72
00:04:43,410 --> 00:04:50,639
<font color="#CCCCCC">and currently there is a patch</font><font color="#E5E5E5"> from me</font>

73
00:04:47,880 --> 00:04:55,010
to a Linux<font color="#E5E5E5"> kernel mainline</font><font color="#CCCCCC"> which allows</font>

74
00:04:50,639 --> 00:04:57,210
<font color="#CCCCCC">to block similar attacks and it is</font><font color="#E5E5E5"> now</font>

75
00:04:55,010 --> 00:05:02,520
discussed in the Linux kernel mailing

76
00:04:57,210 --> 00:05:05,580
<font color="#E5E5E5">list</font><font color="#CCCCCC"> what was wrong</font><font color="#E5E5E5"> in the code first of</font>

77
00:05:02,520 --> 00:05:08,370
all the original<font color="#CCCCCC"> driver I used some</font>

78
00:05:05,580 --> 00:05:12,090
<font color="#E5E5E5">self-made singly-linked</font><font color="#CCCCCC"> list to store</font>

79
00:05:08,370 --> 00:05:16,860
the buffer to store the buffers for

80
00:05:12,090 --> 00:05:21,000
<font color="#E5E5E5">sending where the line and it used a</font>

81
00:05:16,860 --> 00:05:23,789
special variable<font color="#CCCCCC"> T buff to store</font><font color="#E5E5E5"> the</font>

82
00:05:21,000 --> 00:05:26,700
pointer to a<font color="#E5E5E5"> buffer which we need to</font>

83
00:05:23,789 --> 00:05:31,680
resend<font color="#E5E5E5"> in case of transmit error</font>

84
00:05:26,700 --> 00:05:34,260
it was quite fine but later in<font color="#CCCCCC"> that</font>

85
00:05:31,680 --> 00:05:37,169
commit the buffer<font color="#CCCCCC"> flushing feature was</font>

86
00:05:34,260 --> 00:05:40,909
added and it introduced<font color="#E5E5E5"> racy</font>

87
00:05:37,169 --> 00:05:43,590
access to<font color="#E5E5E5"> t buff variable</font><font color="#CCCCCC"> now the</font>

88
00:05:40,910 --> 00:05:48,630
sending function and flushing function

89
00:05:43,590 --> 00:05:53,400
can put this<font color="#E5E5E5"> particular buffer to the</font>

90
00:05:48,630 --> 00:05:59,370
<font color="#E5E5E5">free</font><font color="#CCCCCC"> list twice and it would</font><font color="#E5E5E5"> it went</font>

91
00:05:53,400 --> 00:06:02,700
<font color="#E5E5E5">under insane</font><font color="#CCCCCC"> some wrong locking and when</font>

92
00:05:59,370 --> 00:06:06,389
you close the show the terminal<font color="#E5E5E5"> later</font>

93
00:06:02,700 --> 00:06:09,000
the release functions religious function

94
00:06:06,389 --> 00:06:12,479
can free this buffer twice<font color="#E5E5E5"> which is</font><font color="#CCCCCC"> a</font>

95
00:06:09,000 --> 00:06:17,700
double free error it is<font color="#E5E5E5"> really dangerous</font>

96
00:06:12,479 --> 00:06:24,380
as it looks<font color="#CCCCCC"> and now</font><font color="#E5E5E5"> I'll show</font><font color="#CCCCCC"> the demo</font>

97
00:06:17,700 --> 00:06:24,380
how<font color="#E5E5E5"> to get root out of it</font>

98
00:06:25,220 --> 00:06:31,580
it was a fresh<font color="#E5E5E5"> Linux</font><font color="#CCCCCC"> meat installation</font>

99
00:06:32,840 --> 00:06:42,359
now I'm showing that the<font color="#E5E5E5"> machine which I</font>

100
00:06:37,110 --> 00:06:45,080
used<font color="#E5E5E5"> to run the exploit didn't have a SM</font>

101
00:06:42,360 --> 00:06:48,210
<font color="#E5E5E5">ap feature which is which stands for</font>

102
00:06:45,080 --> 00:06:54,180
<font color="#E5E5E5">supervisor mode</font><font color="#CCCCCC"> access</font><font color="#E5E5E5"> prevention</font>

103
00:06:48,210 --> 00:07:00,859
I'll give the details later<font color="#CCCCCC"> but</font><font color="#E5E5E5"> this</font>

104
00:06:54,180 --> 00:07:00,860
machine has<font color="#E5E5E5"> SM EP feature you can see it</font>

105
00:07:01,850 --> 00:07:12,870
<font color="#CCCCCC">now I show that I run I'm going</font><font color="#E5E5E5"> to run</font>

106
00:07:05,670 --> 00:07:16,800
this exploit as<font color="#E5E5E5"> unprivileged user now</font>

107
00:07:12,870 --> 00:07:27,800
<font color="#CCCCCC">show in the code sensor</font><font color="#E5E5E5"> the little bit</font>

108
00:07:16,800 --> 00:07:27,800
against<font color="#E5E5E5"> the script kiddies then compile</font>

109
00:07:35,430 --> 00:07:46,650
and run<font color="#CCCCCC"> the exploit</font><font color="#E5E5E5"> is really stable</font><font color="#CCCCCC"> it</font>

110
00:07:43,410 --> 00:07:59,220
doesn't<font color="#CCCCCC"> crash the kernel and it gets at</font>

111
00:07:46,650 --> 00:08:01,950
the<font color="#CCCCCC"> root really fast so that's it now I</font>

112
00:07:59,220 --> 00:08:06,780
will describe the exploit step by step

113
00:08:01,950 --> 00:08:09,180
<font color="#E5E5E5">what I've done to do that</font><font color="#CCCCCC"> and the main</font>

114
00:08:06,780 --> 00:08:14,309
steps are first<font color="#E5E5E5"> of all prepare the</font>

115
00:08:09,180 --> 00:08:17,550
<font color="#CCCCCC">environment for risk for for the race to</font>

116
00:08:14,310 --> 00:08:19,880
<font color="#E5E5E5">get the race condition then</font><font color="#CCCCCC"> hitting this</font>

117
00:08:17,550 --> 00:08:24,090
race condition and getting double free

118
00:08:19,880 --> 00:08:25,980
then<font color="#E5E5E5"> keep spraying number one to turn</font>

119
00:08:24,090 --> 00:08:30,690
this double free<font color="#E5E5E5"> and to use after free</font>

120
00:08:25,980 --> 00:08:33,030
which is exploitable<font color="#E5E5E5"> and hip spring</font>

121
00:08:30,690 --> 00:08:36,620
number<font color="#E5E5E5"> two to exploit this use of the</font>

122
00:08:33,030 --> 00:08:41,220
free<font color="#E5E5E5"> finally</font><font color="#CCCCCC"> heap stabilization for</font>

123
00:08:36,620 --> 00:08:43,350
turning system into initial<font color="#E5E5E5"> State</font><font color="#CCCCCC"> if we</font>

124
00:08:41,220 --> 00:08:46,920
didn't hit<font color="#E5E5E5"> the race condition we should</font>

125
00:08:43,350 --> 00:08:48,660
start<font color="#E5E5E5"> the exploit once again</font><font color="#CCCCCC"> I mean</font><font color="#E5E5E5"> go</font>

126
00:08:46,920 --> 00:08:53,819
<font color="#E5E5E5">to the next iteration of the exploit and</font>

127
00:08:48,660 --> 00:08:57,689
finally I<font color="#CCCCCC"> will show</font><font color="#E5E5E5"> a</font><font color="#CCCCCC"> new way how</font><font color="#E5E5E5"> to</font>

128
00:08:53,820 --> 00:08:59,820
bypass<font color="#E5E5E5"> SM EP defense feature without</font>

129
00:08:57,690 --> 00:09:02,820
return-oriented programming<font color="#CCCCCC"> quite simple</font>

130
00:08:59,820 --> 00:09:07,020
and nice now

131
00:09:02,820 --> 00:09:11,880
first prepare<font color="#E5E5E5"> for the race</font><font color="#CCCCCC"> first</font><font color="#E5E5E5"> of</font><font color="#CCCCCC"> all</font>

132
00:09:07,020 --> 00:09:16,189
I'll show what is how the so did show

133
00:09:11,880 --> 00:09:20,250
the terminal works and where the

134
00:09:16,190 --> 00:09:24,630
vulnerable driver works in this diagram

135
00:09:20,250 --> 00:09:28,380
<font color="#E5E5E5">so so the terminal is created when we</font>

136
00:09:24,630 --> 00:09:32,600
open the to the terminal<font color="#E5E5E5"> master side and</font>

137
00:09:28,380 --> 00:09:39,689
get<font color="#CCCCCC"> the file descriptor for it from it</font>

138
00:09:32,600 --> 00:09:45,930
<font color="#CCCCCC">the terminal emulator</font><font color="#E5E5E5"> works on this side</font>

139
00:09:39,690 --> 00:09:49,329
on the master side and the program which

140
00:09:45,930 --> 00:09:51,878
is<font color="#CCCCCC"> run in this passivity terminal</font>

141
00:09:49,329 --> 00:09:56,378
<font color="#CCCCCC">Ron</font><font color="#E5E5E5"> is running at the slave side and the</font>

142
00:09:51,879 --> 00:09:59,649
main logic is<font color="#CCCCCC"> going is happening here in</font>

143
00:09:56,379 --> 00:10:02,889
the line discipline<font color="#CCCCCC"> line discipline is a</font>

144
00:09:59,649 --> 00:10:07,749
piece<font color="#E5E5E5"> of kernel code which provides a</font>

145
00:10:02,889 --> 00:10:10,989
logic like clearing<font color="#E5E5E5"> the last character</font>

146
00:10:07,749 --> 00:10:13,420
if you hit backspace or<font color="#E5E5E5"> echoing the</font>

147
00:10:10,989 --> 00:10:17,939
input which you just put to the episode

148
00:10:13,420 --> 00:10:21,040
terminal back to X term for example<font color="#CCCCCC"> and</font>

149
00:10:17,939 --> 00:10:26,290
the vulnerable<font color="#E5E5E5"> vulnerable driver and</font>

150
00:10:21,040 --> 00:10:28,949
<font color="#E5E5E5">hdl-c driver is providing the hdl-c line</font>

151
00:10:26,290 --> 00:10:33,129
discipline and we will go<font color="#CCCCCC"> into exploit</font>

152
00:10:28,949 --> 00:10:35,378
this particular part<font color="#CCCCCC"> so to prepare for</font>

153
00:10:33,129 --> 00:10:42,730
the race<font color="#CCCCCC"> first</font><font color="#E5E5E5"> we stick to one single</font>

154
00:10:35,379 --> 00:10:45,279
CPU<font color="#CCCCCC"> to make all the driver vulnerable</font>

155
00:10:42,730 --> 00:10:49,829
driver<font color="#E5E5E5"> memory allocations going on on</font>

156
00:10:45,279 --> 00:10:50,949
the single allocated cache which are

157
00:10:49,829 --> 00:10:55,118
allocator

158
00:10:50,949 --> 00:10:59,199
caches are pure<font color="#E5E5E5"> CPU and we want to have</font>

159
00:10:55,119 --> 00:11:02,470
all the work done in one cache so then

160
00:10:59,199 --> 00:11:06,479
we open as I said we open the third

161
00:11:02,470 --> 00:11:10,629
terminal master side and the terminal

162
00:11:06,480 --> 00:11:14,169
<font color="#E5E5E5">master and slave pair is created then we</font>

163
00:11:10,629 --> 00:11:17,139
set the<font color="#E5E5E5"> line discipline for this</font><font color="#CCCCCC"> third</font>

164
00:11:14,169 --> 00:11:20,199
<font color="#E5E5E5">terminal</font><font color="#CCCCCC"> and the vulnerable module is</font>

165
00:11:17,139 --> 00:11:24,669
automatically loaded we can<font color="#E5E5E5"> now exploit</font>

166
00:11:20,199 --> 00:11:27,790
it<font color="#CCCCCC"> then as I said the race condition</font>

167
00:11:24,669 --> 00:11:32,579
<font color="#E5E5E5">happening between sending and flushing</font>

168
00:11:27,790 --> 00:11:38,439
<font color="#E5E5E5">in case of previous sending era and to</font>

169
00:11:32,579 --> 00:11:41,258
make this we I suspend the<font color="#CCCCCC"> third</font>

170
00:11:38,439 --> 00:11:46,689
<font color="#E5E5E5">terminal output and the buffer which I</font>

171
00:11:41,259 --> 00:11:49,319
put<font color="#CCCCCC"> on it</font><font color="#E5E5E5"> sending is failed and it is</font>

172
00:11:46,689 --> 00:11:53,769
the pointer<font color="#CCCCCC"> to it</font><font color="#E5E5E5"> is saved to</font><font color="#CCCCCC"> t</font><font color="#E5E5E5"> buff</font>

173
00:11:49,319 --> 00:11:58,149
variable<font color="#E5E5E5"> now we are ready for the race</font>

174
00:11:53,769 --> 00:12:00,519
<font color="#E5E5E5">and we allow the threads of our exploit</font>

175
00:11:58,149 --> 00:12:04,200
work on all CPU and<font color="#CCCCCC"> compete to each</font>

176
00:12:00,519 --> 00:12:07,540
other<font color="#E5E5E5"> now the racing itself</font>

177
00:12:04,200 --> 00:12:11,230
first thread will flush the data it will

178
00:12:07,540 --> 00:12:15,370
call this<font color="#E5E5E5"> are you control and the second</font>

179
00:12:11,230 --> 00:12:18,670
thread will start the<font color="#E5E5E5"> suspended output</font>

180
00:12:15,370 --> 00:12:21,250
and it will try to send the buffer which

181
00:12:18,670 --> 00:12:27,160
is<font color="#E5E5E5"> stored at debuff race' very variable</font>

182
00:12:21,250 --> 00:12:32,500
<font color="#E5E5E5">and it turned out that introducing legs</font>

183
00:12:27,160 --> 00:12:34,839
<font color="#CCCCCC">in this threads</font><font color="#E5E5E5"> make the</font><font color="#CCCCCC"> whole</font><font color="#E5E5E5"> make</font>

184
00:12:32,500 --> 00:12:38,800
exploit<font color="#E5E5E5"> work faster</font><font color="#CCCCCC"> and hit the race</font>

185
00:12:34,840 --> 00:12:41,920
condition earlier<font color="#CCCCCC"> so what do threads do</font>

186
00:12:38,800 --> 00:12:47,010
first they synchronize<font color="#E5E5E5"> @p thread barrier</font>

187
00:12:41,920 --> 00:12:51,010
<font color="#E5E5E5">you see it on</font><font color="#CCCCCC"> the left hand</font><font color="#E5E5E5"> side and</font>

188
00:12:47,010 --> 00:12:53,890
then one of the thread for example

189
00:12:51,010 --> 00:12:58,960
flushing thread is spinning in a busy

190
00:12:53,890 --> 00:13:00,130
loop<font color="#E5E5E5"> but another thread already starts</font>

191
00:12:58,960 --> 00:13:02,980
<font color="#CCCCCC">to take communication with the</font>

192
00:13:00,130 --> 00:13:06,670
vulnerable vulnerable driver<font color="#E5E5E5"> and then at</font>

193
00:13:02,980 --> 00:13:11,140
this special<font color="#E5E5E5"> moment</font><font color="#CCCCCC"> they both use the</font>

194
00:13:06,670 --> 00:13:16,479
<font color="#E5E5E5">tip of variable and we have the race</font>

195
00:13:11,140 --> 00:13:19,330
condition here<font color="#CCCCCC"> I might have said that</font>

196
00:13:16,480 --> 00:13:22,450
race condition is such situation in the

197
00:13:19,330 --> 00:13:27,060
system when the result of the computing

198
00:13:22,450 --> 00:13:31,050
depends on the order of the<font color="#CCCCCC"> operations</font>

199
00:13:27,060 --> 00:13:34,510
it is<font color="#E5E5E5"> so it has some non-deterministic</font>

200
00:13:31,050 --> 00:13:39,280
situation in the system and here<font color="#CCCCCC"> the</font>

201
00:13:34,510 --> 00:13:43,230
result<font color="#CCCCCC"> of working</font><font color="#E5E5E5"> with</font><font color="#CCCCCC"> tip of variable</font>

202
00:13:39,280 --> 00:13:46,360
depends on how the threads collide

203
00:13:43,230 --> 00:13:50,560
<font color="#E5E5E5">before choosing the leg length</font>

204
00:13:46,360 --> 00:13:54,880
<font color="#CCCCCC">I used this code</font><font color="#E5E5E5"> so legs are introduced</font>

205
00:13:50,560 --> 00:13:57,670
in turn for one second thread for<font color="#CCCCCC"> for</font>

206
00:13:54,880 --> 00:14:04,860
first thread for second thread<font color="#E5E5E5"> and it is</font>

207
00:13:57,670 --> 00:14:10,420
growing and<font color="#E5E5E5"> it has maximized by 50</font>

208
00:14:04,860 --> 00:14:14,350
milliseconds microseconds<font color="#E5E5E5"> yes and that</font>

209
00:14:10,420 --> 00:14:16,870
<font color="#E5E5E5">makes the exploit go faster and threads</font>

210
00:14:14,350 --> 00:14:21,400
collide<font color="#E5E5E5"> earlier we have</font>

211
00:14:16,870 --> 00:14:25,120
<font color="#E5E5E5">faster exploit now</font><font color="#CCCCCC"> triggering actual</font>

212
00:14:21,400 --> 00:14:27,069
double<font color="#CCCCCC"> three we stick to the first</font><font color="#E5E5E5"> CPU</font>

213
00:14:25,120 --> 00:14:29,280
<font color="#E5E5E5">core again and close observe the</font>

214
00:14:27,070 --> 00:14:32,830
terminal and<font color="#E5E5E5"> the release function here</font>

215
00:14:29,280 --> 00:14:35,350
works and<font color="#CCCCCC"> frees the buffers in the free</font>

216
00:14:32,830 --> 00:14:37,840
list<font color="#E5E5E5"> if we had the rest condition we</font>

217
00:14:35,350 --> 00:14:40,600
have double buffer and have double free

218
00:14:37,840 --> 00:14:42,850
and kernel dress sanitizer can detect it

219
00:14:40,600 --> 00:14:46,030
and the report of the kernel dress

220
00:14:42,850 --> 00:14:49,660
sanitizer<font color="#E5E5E5"> was in fact the report from</font>

221
00:14:46,030 --> 00:14:52,300
Cisco Larry which I got<font color="#CCCCCC"> when I start and</font>

222
00:14:49,660 --> 00:14:56,829
<font color="#E5E5E5">after that I started to</font><font color="#CCCCCC"> investigate this</font>

223
00:14:52,300 --> 00:15:00,939
<font color="#E5E5E5">issue now we need to exploit the double</font>

224
00:14:56,830 --> 00:15:05,230
<font color="#E5E5E5">free we try to do it and if we got the</font>

225
00:15:00,940 --> 00:15:10,390
<font color="#E5E5E5">root ID we run the shell otherwise go</font>

226
00:15:05,230 --> 00:15:13,480
and race again<font color="#CCCCCC"> now I want to show you</font>

227
00:15:10,390 --> 00:15:15,630
how<font color="#CCCCCC"> double free exploitation works in</font>

228
00:15:13,480 --> 00:15:18,460
general

229
00:15:15,630 --> 00:15:23,230
the<font color="#E5E5E5"> idea is quite beautiful</font><font color="#CCCCCC"> I</font><font color="#E5E5E5"> would say</font>

230
00:15:18,460 --> 00:15:28,320
first<font color="#E5E5E5"> we allocate some object and later</font>

231
00:15:23,230 --> 00:15:32,200
it is freed<font color="#E5E5E5"> it's fine but we have an</font>

232
00:15:28,320 --> 00:15:39,660
error<font color="#E5E5E5"> we</font><font color="#CCCCCC"> have the second freeing of this</font>

233
00:15:32,200 --> 00:15:42,700
object a and<font color="#E5E5E5"> we will use it now we</font>

234
00:15:39,660 --> 00:15:45,819
allocate some another object which is

235
00:15:42,700 --> 00:15:48,640
which has<font color="#CCCCCC"> the</font><font color="#E5E5E5"> same size and the kernel</font>

236
00:15:45,820 --> 00:15:51,760
allocator<font color="#CCCCCC"> for example tends</font><font color="#E5E5E5"> to give you</font>

237
00:15:48,640 --> 00:15:56,610
the same<font color="#E5E5E5"> address</font><font color="#CCCCCC"> that was that has been</font>

238
00:15:51,760 --> 00:16:01,270
already<font color="#E5E5E5"> freed just freed because it is</font>

239
00:15:56,610 --> 00:16:07,510
it can<font color="#CCCCCC"> be</font><font color="#E5E5E5"> accessed very fast it was just</font>

240
00:16:01,270 --> 00:16:10,960
used so we allocate<font color="#CCCCCC"> our object be at the</font>

241
00:16:07,510 --> 00:16:13,270
same place here but here the second

242
00:16:10,960 --> 00:16:15,520
freeing<font color="#E5E5E5"> the bug by deferring of the</font>

243
00:16:13,270 --> 00:16:20,560
first<font color="#E5E5E5"> object</font><font color="#CCCCCC"> a happens and it actually</font>

244
00:16:15,520 --> 00:16:22,840
<font color="#E5E5E5">frees the object B so now after the</font>

245
00:16:20,560 --> 00:16:24,880
<font color="#CCCCCC">object B is freed we can do the heap</font>

246
00:16:22,840 --> 00:16:27,850
spring number<font color="#E5E5E5"> two well locate another</font>

247
00:16:24,880 --> 00:16:30,430
<font color="#CCCCCC">object</font><font color="#E5E5E5"> over the same size it has put at</font>

248
00:16:27,850 --> 00:16:34,960
<font color="#E5E5E5">the place of object B but</font>

249
00:16:30,430 --> 00:16:38,229
it has our controllable payload and then

250
00:16:34,960 --> 00:16:42,279
the code which actually<font color="#E5E5E5"> uses</font><font color="#CCCCCC"> the object</font>

251
00:16:38,230 --> 00:16:46,839
<font color="#E5E5E5">B will work with the</font><font color="#CCCCCC"> pilote of object</font><font color="#E5E5E5"> X</font>

252
00:16:42,279 --> 00:16:49,120
and can do a malicious activity that is

253
00:16:46,839 --> 00:16:51,970
<font color="#E5E5E5">the main</font><font color="#CCCCCC"> idea of exploiting double free</font>

254
00:16:49,120 --> 00:16:54,550
<font color="#E5E5E5">so first keep spraying</font><font color="#CCCCCC"> to turn double</font>

255
00:16:51,970 --> 00:17:00,279
free<font color="#CCCCCC"> into use after free and using the</font>

256
00:16:54,550 --> 00:17:06,459
object B is the exploitation of<font color="#CCCCCC"> the this</font>

257
00:17:00,279 --> 00:17:09,429
use of<font color="#E5E5E5"> the free error now about this</font>

258
00:17:06,459 --> 00:17:14,530
particular exploit the buffer which we

259
00:17:09,429 --> 00:17:16,900
are exploiting<font color="#E5E5E5"> is allocated in that</font><font color="#CCCCCC"> slop</font>

260
00:17:14,530 --> 00:17:20,829
cache<font color="#CCCCCC"> a Linux kernel alligator is called</font>

261
00:17:16,900 --> 00:17:22,839
slab alligator<font color="#E5E5E5"> it prepares some several</font>

262
00:17:20,829 --> 00:17:26,470
objects of the same size<font color="#E5E5E5"> say eight</font>

263
00:17:22,839 --> 00:17:29,919
kilobytes<font color="#CCCCCC"> and is ready</font><font color="#E5E5E5"> to give them this</font>

264
00:17:26,470 --> 00:17:35,500
object<font color="#E5E5E5"> to the code which are called the</font>

265
00:17:29,920 --> 00:17:39,790
key malloc<font color="#E5E5E5"> so we will exploit double 3</font>

266
00:17:35,500 --> 00:17:42,550
in this particular cache so we need two

267
00:17:39,790 --> 00:17:45,100
types of objects first<font color="#E5E5E5"> object for first</font>

268
00:17:42,550 --> 00:17:47,020
<font color="#E5E5E5">keep</font><font color="#CCCCCC"> spring which has</font><font color="#E5E5E5"> a function pointer</font>

269
00:17:45,100 --> 00:17:49,059
<font color="#E5E5E5">and second one when the controllable</font>

270
00:17:47,020 --> 00:17:54,610
payload to override<font color="#E5E5E5"> this function</font>

271
00:17:49,059 --> 00:17:59,678
pointer and run our<font color="#CCCCCC"> shell code</font><font color="#E5E5E5"> and it it</font>

272
00:17:54,610 --> 00:18:02,860
turns out that socket buffer<font color="#E5E5E5"> in the</font>

273
00:17:59,679 --> 00:18:04,870
<font color="#E5E5E5">Linux kernel</font><font color="#CCCCCC"> works</font><font color="#E5E5E5"> very well as a first</font>

274
00:18:02,860 --> 00:18:07,419
object it<font color="#E5E5E5"> has a function</font><font color="#CCCCCC"> pointer which</font>

275
00:18:04,870 --> 00:18:12,250
we can<font color="#E5E5E5"> override it can be allocated</font><font color="#CCCCCC"> in</font>

276
00:18:07,420 --> 00:18:17,980
the needed cash and I would say that it

277
00:18:12,250 --> 00:18:22,210
<font color="#CCCCCC">is the object</font><font color="#E5E5E5"> for storing</font><font color="#CCCCCC"> network frames</font>

278
00:18:17,980 --> 00:18:28,120
in the Linux kernel<font color="#E5E5E5"> so the actual</font>

279
00:18:22,210 --> 00:18:33,520
network data is stored<font color="#CCCCCC"> here</font><font color="#E5E5E5"> and struct</font>

280
00:18:28,120 --> 00:18:38,469
<font color="#CCCCCC">Eska both sk both stores a meta</font>

281
00:18:33,520 --> 00:18:44,670
information so but it turned out that

282
00:18:38,470 --> 00:18:48,430
<font color="#E5E5E5">first clip spring the overwriting of the</font>

283
00:18:44,670 --> 00:18:50,440
double free<font color="#E5E5E5"> doubly free object doesn't</font>

284
00:18:48,430 --> 00:18:55,330
<font color="#E5E5E5">work so simple because the release</font>

285
00:18:50,440 --> 00:18:59,290
function<font color="#CCCCCC"> frees</font><font color="#E5E5E5"> 13 buffers straight away</font>

286
00:18:55,330 --> 00:19:04,889
there<font color="#E5E5E5"> are 13 by buffers in the list</font><font color="#CCCCCC"> in a</font>

287
00:18:59,290 --> 00:19:07,720
and a in<font color="#E5E5E5"> the hdl-c driver and it freezes</font>

288
00:19:04,890 --> 00:19:11,500
<font color="#CCCCCC">straightaway and all</font><font color="#E5E5E5"> of them are put to</font>

289
00:19:07,720 --> 00:19:14,760
the<font color="#E5E5E5"> free</font><font color="#CCCCCC"> list</font><font color="#E5E5E5"> of the allocator and it</font>

290
00:19:11,500 --> 00:19:17,770
<font color="#E5E5E5">turned out in it turns out that the</font>

291
00:19:14,760 --> 00:19:20,470
doubly freed item is at the<font color="#CCCCCC"> beginning of</font>

292
00:19:17,770 --> 00:19:24,520
the free list<font color="#CCCCCC"> and it's not easy to get</font>

293
00:19:20,470 --> 00:19:26,830
<font color="#E5E5E5">it back again</font><font color="#CCCCCC"> I was trying to</font><font color="#E5E5E5"> put to</font>

294
00:19:24,520 --> 00:19:28,690
create some<font color="#E5E5E5"> network packet between the</font>

295
00:19:26,830 --> 00:19:31,240
doubly freed at the beginning<font color="#CCCCCC"> of this</font>

296
00:19:28,690 --> 00:19:37,030
free list but I didn't succeed<font color="#E5E5E5"> because</font>

297
00:19:31,240 --> 00:19:43,480
this and<font color="#E5E5E5"> hdl-c release function goes on</font>

298
00:19:37,030 --> 00:19:49,240
a single CPU<font color="#E5E5E5"> doesn't interrupt is not</font>

299
00:19:43,480 --> 00:19:51,970
interrupted<font color="#E5E5E5"> so still puzzled anyway but</font>

300
00:19:49,240 --> 00:19:54,610
if we look carefully we<font color="#CCCCCC"> see</font><font color="#E5E5E5"> that this</font>

301
00:19:51,970 --> 00:19:56,890
function<font color="#E5E5E5"> which frees freezes that the</font>

302
00:19:54,610 --> 00:20:00,428
buffers<font color="#E5E5E5"> doesn't crash the kernel and</font>

303
00:19:56,890 --> 00:20:03,190
that means that the allocate<font color="#E5E5E5"> a kernel</font><font color="#CCCCCC"> a</font>

304
00:20:00,429 --> 00:20:06,160
<font color="#CCCCCC">locator accepts consecutive ring</font><font color="#E5E5E5"> of the</font>

305
00:20:03,190 --> 00:20:09,100
same address over<font color="#E5E5E5"> the same buffer it has</font>

306
00:20:06,160 --> 00:20:12,940
strange it is<font color="#E5E5E5"> nave but that's it so if</font>

307
00:20:09,100 --> 00:20:18,040
we if I spray after<font color="#CCCCCC"> the release function</font>

308
00:20:12,940 --> 00:20:22,630
<font color="#E5E5E5">I can get the buffers from the free list</font>

309
00:20:18,040 --> 00:20:25,090
one by<font color="#E5E5E5"> one and finally have such a cool</font>

310
00:20:22,630 --> 00:20:27,970
situation<font color="#CCCCCC"> when I have to</font><font color="#E5E5E5"> socket buffers</font>

311
00:20:25,090 --> 00:20:30,159
pointing to the same data and it<font color="#E5E5E5"> is very</font>

312
00:20:27,970 --> 00:20:32,350
nice because<font color="#CCCCCC"> if we receive one of</font><font color="#E5E5E5"> this</font>

313
00:20:30,160 --> 00:20:33,130
buffers we can have a<font color="#E5E5E5"> user after</font><font color="#CCCCCC"> three</font>

314
00:20:32,350 --> 00:20:38,020
on the second one

315
00:20:33,130 --> 00:20:41,740
really nice so for turning double<font color="#CCCCCC"> frame</font>

316
00:20:38,020 --> 00:20:44,320
<font color="#CCCCCC">to use after free I spawn spawn</font><font color="#E5E5E5"> a lot</font><font color="#CCCCCC"> of</font>

317
00:20:41,740 --> 00:20:49,330
<font color="#CCCCCC">eight kilobytes UDP packets</font><font color="#E5E5E5"> after the</font>

318
00:20:44,320 --> 00:20:52,090
race and give them allocated in the

319
00:20:49,330 --> 00:20:54,850
<font color="#E5E5E5">kernel memory it's not easy because the</font>

320
00:20:52,090 --> 00:20:57,760
<font color="#E5E5E5">socket queue for network packets is</font>

321
00:20:54,850 --> 00:20:59,649
limited in size and that's<font color="#E5E5E5"> why I have a</font>

322
00:20:57,760 --> 00:21:04,360
a lot<font color="#E5E5E5"> of circuit</font><font color="#CCCCCC"> Q's</font><font color="#E5E5E5"> not to overflow</font>

323
00:20:59,650 --> 00:21:06,700
them and keep all my packets in the

324
00:21:04,360 --> 00:21:09,760
<font color="#E5E5E5">kernel memory and well and then I</font>

325
00:21:06,700 --> 00:21:11,890
<font color="#CCCCCC">received one of</font><font color="#E5E5E5"> the twin circuit buffers</font>

326
00:21:09,760 --> 00:21:17,470
and have a use of the<font color="#E5E5E5"> free error on</font>

327
00:21:11,890 --> 00:21:19,810
another one that's<font color="#E5E5E5"> nice so the heap</font>

328
00:21:17,470 --> 00:21:23,230
spring implementation looks<font color="#E5E5E5"> like that I</font>

329
00:21:19,810 --> 00:21:26,740
have<font color="#CCCCCC"> 200 service circuits for the heap</font>

330
00:21:23,230 --> 00:21:29,820
spray and send packets to them

331
00:21:26,740 --> 00:21:34,660
and empirically I know which packets<font color="#E5E5E5"> are</font>

332
00:21:29,820 --> 00:21:38,620
likely to be 2.2 the<font color="#E5E5E5"> same data</font><font color="#CCCCCC"> I send it</font>

333
00:21:34,660 --> 00:21:40,720
to<font color="#CCCCCC"> a dedicated</font><font color="#E5E5E5"> service circuit to have a</font>

334
00:21:38,620 --> 00:21:44,320
use of<font color="#E5E5E5"> the free error later on it and</font>

335
00:21:40,720 --> 00:21:46,770
then I after receiving some packets from

336
00:21:44,320 --> 00:21:51,189
the<font color="#E5E5E5"> dedicated service circuit</font><font color="#CCCCCC"> I need to</font>

337
00:21:46,770 --> 00:21:57,639
return the state of the allocator<font color="#E5E5E5"> to the</font>

338
00:21:51,190 --> 00:22:01,380
initial position not to crush the kernel

339
00:21:57,640 --> 00:22:05,440
that's<font color="#E5E5E5"> why I sent some packets to other</font>

340
00:22:01,380 --> 00:22:08,950
200 service circuits to exhaust<font color="#CCCCCC"> their</font>

341
00:22:05,440 --> 00:22:13,450
<font color="#E5E5E5">partially freed</font><font color="#CCCCCC"> slobs</font><font color="#E5E5E5"> with</font><font color="#CCCCCC"> slub objects</font>

342
00:22:08,950 --> 00:22:15,610
in the kernel or<font color="#CCCCCC"> allocator</font><font color="#E5E5E5"> and start</font>

343
00:22:13,450 --> 00:22:17,920
from scratch<font color="#E5E5E5"> the next round of the</font>

344
00:22:15,610 --> 00:22:19,290
racing and the next right around of the

345
00:22:17,920 --> 00:22:24,310
exploit

346
00:22:19,290 --> 00:22:27,970
so<font color="#E5E5E5"> first</font><font color="#CCCCCC"> hip spring already</font><font color="#E5E5E5"> done now we</font>

347
00:22:24,310 --> 00:22:31,300
need to<font color="#CCCCCC"> wow</font><font color="#E5E5E5"> now we need after receiving</font>

348
00:22:27,970 --> 00:22:36,510
one<font color="#CCCCCC"> of twin packets</font><font color="#E5E5E5"> overwrite the</font>

349
00:22:31,300 --> 00:22:40,149
contents of the second one to have a

350
00:22:36,510 --> 00:22:43,230
local privilege escalation so now we are

351
00:22:40,150 --> 00:22:47,890
focused on<font color="#E5E5E5"> the second keep spraying and</font>

352
00:22:43,230 --> 00:22:51,370
executing the<font color="#CCCCCC"> shellcode he's spraying</font>

353
00:22:47,890 --> 00:22:55,150
number<font color="#CCCCCC"> two should override destructor</font>

354
00:22:51,370 --> 00:22:56,770
arc in the socket buffer and another

355
00:22:55,150 --> 00:23:03,010
socket<font color="#E5E5E5"> buffer doesn't work for that</font>

356
00:22:56,770 --> 00:23:06,040
<font color="#CCCCCC">because they the structure with the data</font>

357
00:23:03,010 --> 00:23:08,230
which<font color="#CCCCCC"> we want override is put at the</font>

358
00:23:06,040 --> 00:23:11,800
<font color="#E5E5E5">same offset from the beginning all the</font>

359
00:23:08,230 --> 00:23:13,660
<font color="#CCCCCC">time so we</font><font color="#E5E5E5"> don't control</font><font color="#CCCCCC"> it that's</font><font color="#E5E5E5"> why</font>

360
00:23:11,800 --> 00:23:18,909
I needed another<font color="#CCCCCC"> kernel</font><font color="#E5E5E5"> object to</font>

361
00:23:13,660 --> 00:23:21,850
override the destructor<font color="#E5E5E5"> and I was</font>

362
00:23:18,910 --> 00:23:24,580
<font color="#E5E5E5">searching for it for</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> long</font><font color="#CCCCCC"> time I tried</font>

363
00:23:21,850 --> 00:23:28,209
a<font color="#CCCCCC"> lot of kernel objects and finally I</font>

364
00:23:24,580 --> 00:23:29,980
<font color="#E5E5E5">found that EDC</font><font color="#CCCCCC"> skull can store</font><font color="#E5E5E5"> the</font>

365
00:23:28,210 --> 00:23:33,190
controllable payload in the kernel

366
00:23:29,980 --> 00:23:36,880
memory and can be allocated<font color="#CCCCCC"> in the cache</font>

367
00:23:33,190 --> 00:23:41,680
which I'm interested<font color="#CCCCCC"> in nice</font><font color="#E5E5E5"> so let's</font>

368
00:23:36,880 --> 00:23:45,100
<font color="#CCCCCC">see how the destructor is used if if the</font>

369
00:23:41,680 --> 00:23:50,830
packet has this particular flag and the

370
00:23:45,100 --> 00:23:57,850
destructor is not now our callback is

371
00:23:50,830 --> 00:24:01,000
called so the second hip spring should

372
00:23:57,850 --> 00:24:04,659
override the data and put this

373
00:24:01,000 --> 00:24:07,890
particular<font color="#E5E5E5"> flag and override the</font>

374
00:24:04,660 --> 00:24:12,220
destructor to our payload which is

375
00:24:07,890 --> 00:24:13,990
allocated<font color="#CCCCCC"> in</font><font color="#E5E5E5"> the user space so you both</font>

376
00:24:12,220 --> 00:24:15,760
infrastructure with the callback is

377
00:24:13,990 --> 00:24:18,280
<font color="#E5E5E5">allocated in the user space and the</font>

378
00:24:15,760 --> 00:24:23,200
shellcode<font color="#CCCCCC"> is also in the user space</font>

379
00:24:18,280 --> 00:24:27,040
memory<font color="#E5E5E5"> and here when the destructor will</font>

380
00:24:23,200 --> 00:24:32,290
be instructor destructor pointer will be

381
00:24:27,040 --> 00:24:36,430
<font color="#E5E5E5">dereferenced the SM ap can block our</font>

382
00:24:32,290 --> 00:24:42,790
exploit again<font color="#E5E5E5"> SM ap is a supervisor</font>

383
00:24:36,430 --> 00:24:47,560
<font color="#E5E5E5">memory</font><font color="#CCCCCC"> execute access prevention and it</font>

384
00:24:42,790 --> 00:24:52,720
gives a fault<font color="#E5E5E5"> if you fetch the</font><font color="#CCCCCC"> if you</font><font color="#E5E5E5"> do</font>

385
00:24:47,560 --> 00:24:54,899
reference the pointer which points to

386
00:24:52,720 --> 00:24:57,520
use a space<font color="#CCCCCC"> memory in the kernel space</font>

387
00:24:54,900 --> 00:25:02,890
<font color="#CCCCCC">there are some</font><font color="#E5E5E5"> techniques how</font><font color="#CCCCCC"> to bypass</font>

388
00:24:57,520 --> 00:25:08,200
<font color="#CCCCCC">it</font><font color="#E5E5E5"> and in my particular exploit I will</font>

389
00:25:02,890 --> 00:25:11,470
bypass the<font color="#E5E5E5"> second defense feature it is</font>

390
00:25:08,200 --> 00:25:14,080
called<font color="#E5E5E5"> SM EP which is</font><font color="#CCCCCC"> supervising memory</font>

391
00:25:11,470 --> 00:25:18,880
execution prevention the processor gives

392
00:25:14,080 --> 00:25:21,820
a fault<font color="#E5E5E5"> if the instructor</font><font color="#CCCCCC"> if the</font><font color="#E5E5E5"> CPU</font>

393
00:25:18,880 --> 00:25:24,310
<font color="#E5E5E5">instruction is fetched from</font><font color="#CCCCCC"> the user</font>

394
00:25:21,820 --> 00:25:25,689
space address at the kernel space and I

395
00:25:24,310 --> 00:25:30,519
will show how<font color="#CCCCCC"> to bypass</font>

396
00:25:25,690 --> 00:25:32,500
that one but it turns out<font color="#E5E5E5"> that</font><font color="#CCCCCC"> keeps</font>

397
00:25:30,519 --> 00:25:35,559
<font color="#CCCCCC">praying number</font><font color="#E5E5E5"> two to override the</font>

398
00:25:32,500 --> 00:25:39,820
network packet<font color="#CCCCCC"> doesn't go so easy</font>

399
00:25:35,559 --> 00:25:43,029
because we<font color="#CCCCCC"> have so-called key data</font>

400
00:25:39,820 --> 00:25:47,439
quotas<font color="#CCCCCC"> they are controlled by route and</font>

401
00:25:43,029 --> 00:25:49,840
the maximum<font color="#E5E5E5"> size of their of our payload</font>

402
00:25:47,440 --> 00:25:52,210
which we have<font color="#CCCCCC"> can have in the kernel</font>

403
00:25:49,840 --> 00:25:55,389
space is<font color="#CCCCCC"> only</font><font color="#E5E5E5"> two thousand bytes</font><font color="#CCCCCC"> that</font>

404
00:25:52,210 --> 00:25:58,690
<font color="#CCCCCC">means that we can call</font><font color="#E5E5E5"> only two at</font>

405
00:25:55,389 --> 00:26:03,449
kisses calls which which will succeed

406
00:25:58,690 --> 00:26:09,549
and it's not enough for<font color="#E5E5E5"> spraying so</font>

407
00:26:03,450 --> 00:26:11,500
puzzled again but then I saw the bright

408
00:26:09,549 --> 00:26:14,860
idea in the slides of<font color="#CCCCCC"> dish Chen</font><font color="#E5E5E5"> from</font>

409
00:26:11,500 --> 00:26:19,409
<font color="#E5E5E5">insecurity lab thanks for to him for</font>

410
00:26:14,860 --> 00:26:23,289
<font color="#CCCCCC">that</font><font color="#E5E5E5"> for that work it turns out that</font>

411
00:26:19,409 --> 00:26:28,000
successful<font color="#E5E5E5"> keep spraying doesn't depend</font>

412
00:26:23,289 --> 00:26:32,350
<font color="#CCCCCC">on</font><font color="#E5E5E5"> the success</font><font color="#CCCCCC"> of the</font><font color="#E5E5E5"> Cisco logical so</font>

413
00:26:28,000 --> 00:26:36,580
my I allow my<font color="#CCCCCC"> eight</font><font color="#E5E5E5"> keys is called fail</font>

414
00:26:32,350 --> 00:26:39,039
but the payload is actually was in<font color="#E5E5E5"> the</font>

415
00:26:36,580 --> 00:26:42,428
kernel memory and it could override the

416
00:26:39,039 --> 00:26:46,210
circuit buffer that's fine<font color="#E5E5E5"> so just allow</font>

417
00:26:42,429 --> 00:26:49,480
<font color="#E5E5E5">it to fail so final spring</font>

418
00:26:46,210 --> 00:26:51,970
implementation looks<font color="#E5E5E5"> like that 20</font>

419
00:26:49,480 --> 00:26:55,450
packets to<font color="#CCCCCC"> the server circuits for</font>

420
00:26:51,970 --> 00:26:58,299
spring<font color="#E5E5E5"> then empirically I understood</font>

421
00:26:55,450 --> 00:27:01,029
that<font color="#E5E5E5"> packets number 12 13 14 and</font><font color="#CCCCCC"> 15 are</font>

422
00:26:58,299 --> 00:27:04,418
<font color="#E5E5E5">likely to be doubled to point to the</font>

423
00:27:01,029 --> 00:27:08,250
<font color="#E5E5E5">same data and I send it</font><font color="#CCCCCC"> to the dedicated</font>

424
00:27:04,419 --> 00:27:11,350
<font color="#CCCCCC">service circuit</font><font color="#E5E5E5"> to receive later</font><font color="#CCCCCC"> and I</font>

425
00:27:08,250 --> 00:27:15,129
receive this<font color="#CCCCCC"> four packets one by one and</font>

426
00:27:11,350 --> 00:27:19,120
call some at<font color="#E5E5E5"> key syscalls in between to</font>

427
00:27:15,129 --> 00:27:22,719
<font color="#CCCCCC">overwrite</font><font color="#E5E5E5"> the second two</font><font color="#CCCCCC"> in circuit</font>

428
00:27:19,120 --> 00:27:24,969
buffer finally<font color="#E5E5E5"> after receiving so</font>

429
00:27:22,720 --> 00:27:27,580
receiving is free

430
00:27:24,970 --> 00:27:32,769
<font color="#E5E5E5">I restore the initial state of the</font>

431
00:27:27,580 --> 00:27:35,789
allocator<font color="#CCCCCC"> by sending this 15 additional</font>

432
00:27:32,769 --> 00:27:38,980
packets to another<font color="#E5E5E5"> service and it</font><font color="#CCCCCC"> has</font>

433
00:27:35,789 --> 00:27:39,670
the main<font color="#E5E5E5"> thing which makes the exploit</font>

434
00:27:38,980 --> 00:27:43,810
<font color="#E5E5E5">be sauce</font>

435
00:27:39,670 --> 00:27:49,390
table<font color="#E5E5E5"> without that we have a</font><font color="#CCCCCC"> colonel</font>

436
00:27:43,810 --> 00:27:53,669
<font color="#CCCCCC">crush when it when</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> slab is</font><font color="#E5E5E5"> fully</font>

437
00:27:49,390 --> 00:27:56,620
freed and it detects that it had a

438
00:27:53,670 --> 00:28:00,090
double<font color="#E5E5E5"> free need so to avoid this</font>

439
00:27:56,620 --> 00:28:02,949
<font color="#CCCCCC">colonel crush and make our exploit work</font>

440
00:28:00,090 --> 00:28:07,840
<font color="#E5E5E5">we should</font><font color="#CCCCCC"> restore and this technique</font>

441
00:28:02,950 --> 00:28:10,920
called<font color="#CCCCCC"> slab exertion and the there are</font>

442
00:28:07,840 --> 00:28:15,850
examples<font color="#E5E5E5"> of working with at kisses</font><font color="#CCCCCC"> call</font>

443
00:28:10,920 --> 00:28:18,550
this one is for storing our<font color="#E5E5E5"> payload in</font>

444
00:28:15,850 --> 00:28:23,699
the kernel space and the invalidation

445
00:28:18,550 --> 00:28:23,700
<font color="#CCCCCC">for first</font><font color="#E5E5E5"> to attic equals which succeed</font>

446
00:28:23,730 --> 00:28:33,090
<font color="#E5E5E5">so finally about bypassing</font><font color="#CCCCCC"> SMTP</font><font color="#E5E5E5"> I'm</font>

447
00:28:30,130 --> 00:28:33,090
showing that again

448
00:28:33,730 --> 00:28:42,340
when the<font color="#CCCCCC"> kernel tries</font><font color="#E5E5E5"> to execute the</font>

449
00:28:39,190 --> 00:28:48,100
instruction at the<font color="#CCCCCC"> user space we have a</font>

450
00:28:42,340 --> 00:28:51,790
<font color="#E5E5E5">fault and there are several first of all</font>

451
00:28:48,100 --> 00:28:56,530
I will say that it has not<font color="#E5E5E5"> software but</font>

452
00:28:51,790 --> 00:29:00,490
<font color="#E5E5E5">hardware feature the x86 CPU provides it</font>

453
00:28:56,530 --> 00:29:05,680
and it<font color="#CCCCCC"> is controlled at the</font><font color="#E5E5E5"> twenties bit</font>

454
00:29:00,490 --> 00:29:09,520
of<font color="#CCCCCC"> seer for register so if we can write</font>

455
00:29:05,680 --> 00:29:11,980
to this<font color="#CCCCCC"> register and set this bit</font><font color="#E5E5E5"> this</font>

456
00:29:09,520 --> 00:29:16,870
particular bit to<font color="#E5E5E5"> zero we</font><font color="#CCCCCC"> have that</font>

457
00:29:11,980 --> 00:29:21,100
feature disabled and there are several

458
00:29:16,870 --> 00:29:27,129
ways<font color="#CCCCCC"> how</font><font color="#E5E5E5"> to bypass it already known in</font>

459
00:29:21,100 --> 00:29:33,969
<font color="#CCCCCC">public</font><font color="#E5E5E5"> you can look at it later they</font>

460
00:29:27,130 --> 00:29:40,300
quite complex because the first one uses

461
00:29:33,970 --> 00:29:46,330
<font color="#E5E5E5">return arrays in programming and both</font><font color="#CCCCCC"> of</font>

462
00:29:40,300 --> 00:29:49,690
them need the arbitrary memory<font color="#CCCCCC"> right to</font>

463
00:29:46,330 --> 00:29:51,939
bypass SM EP and SM IP and I will so

464
00:29:49,690 --> 00:29:54,790
<font color="#E5E5E5">show another easy way</font>

465
00:29:51,940 --> 00:29:58,120
it turns out<font color="#CCCCCC"> that the colonel already</font>

466
00:29:54,790 --> 00:30:01,899
had the needed function there is<font color="#CCCCCC"> a</font>

467
00:29:58,120 --> 00:30:05,709
native rights here for which just rights

468
00:30:01,900 --> 00:30:09,430
<font color="#CCCCCC">its argument to zero for register</font><font color="#E5E5E5"> and</font>

469
00:30:05,710 --> 00:30:14,440
let's look more<font color="#CCCCCC"> carefully how the</font>

470
00:30:09,430 --> 00:30:19,750
destructor is used the callback is

471
00:30:14,440 --> 00:30:22,090
called<font color="#E5E5E5"> with the address</font><font color="#CCCCCC"> of you boof</font>

472
00:30:19,750 --> 00:30:28,420
infrastructure<font color="#E5E5E5"> as a first argument which</font>

473
00:30:22,090 --> 00:30:33,280
is also<font color="#E5E5E5"> long and sign long so Erica</font><font color="#CCCCCC"> if</font>

474
00:30:28,420 --> 00:30:36,340
we if I use native rights therefore<font color="#E5E5E5"> at</font>

475
00:30:33,280 --> 00:30:40,240
the<font color="#E5E5E5"> callback and if I reside you</font><font color="#CCCCCC"> buffin</font>

476
00:30:36,340 --> 00:30:45,490
for at the<font color="#E5E5E5"> memory which was got from a</font>

477
00:30:40,240 --> 00:30:49,840
map system call<font color="#E5E5E5"> and if our you buff and</font>

478
00:30:45,490 --> 00:30:52,660
for reset at this particular address the

479
00:30:49,840 --> 00:30:55,689
<font color="#CCCCCC">SME P is disabled</font><font color="#E5E5E5"> because this</font>

480
00:30:52,660 --> 00:30:58,570
<font color="#E5E5E5">particular address is the right value of</font>

481
00:30:55,690 --> 00:31:02,350
<font color="#CCCCCC">zero</font><font color="#E5E5E5"> for register without</font><font color="#CCCCCC"> s I mean</font><font color="#E5E5E5"> SM EP</font>

482
00:30:58,570 --> 00:31:05,590
enabled on my machine so just a map<font color="#E5E5E5"> put</font>

483
00:31:02,350 --> 00:31:10,300
the payload on it and have the<font color="#E5E5E5"> SME</font><font color="#CCCCCC"> be</font>

484
00:31:05,590 --> 00:31:17,889
disabled everything<font color="#E5E5E5"> Israel is already</font>

485
00:31:10,300 --> 00:31:23,639
<font color="#CCCCCC">generating in</font><font color="#E5E5E5"> the kernel and after SM EP</font>

486
00:31:17,890 --> 00:31:27,610
disabled<font color="#CCCCCC"> I can race again</font><font color="#E5E5E5"> to execute the</font>

487
00:31:23,640 --> 00:31:33,040
<font color="#E5E5E5">shell code on the second successful</font>

488
00:31:27,610 --> 00:31:36,820
looks exploit iteration and I would like

489
00:31:33,040 --> 00:31:39,190
to<font color="#CCCCCC"> add that this correct value</font><font color="#E5E5E5"> the</font>

490
00:31:36,820 --> 00:31:43,649
correct value<font color="#CCCCCC"> of zero register is</font>

491
00:31:39,190 --> 00:31:46,870
<font color="#E5E5E5">machine specific and but it can be</font>

492
00:31:43,650 --> 00:31:51,930
determined<font color="#CCCCCC"> from the user space by CPU</font>

493
00:31:46,870 --> 00:31:51,929
and the CPU<font color="#E5E5E5"> ID instruction on x86</font>

494
00:31:52,320 --> 00:31:59,050
finally about<font color="#CCCCCC"> the fix as I said I</font>

495
00:31:56,250 --> 00:32:03,330
approached the<font color="#E5E5E5"> mainline maintainer</font>

496
00:31:59,050 --> 00:32:05,860
with the watch for this race condition

497
00:32:03,330 --> 00:32:09,360
and it the user

498
00:32:05,860 --> 00:32:13,809
just standard<font color="#CCCCCC"> colonel</font><font color="#E5E5E5"> linked lists</font>

499
00:32:09,360 --> 00:32:18,309
instead of those<font color="#E5E5E5"> self-made and I got rid</font>

500
00:32:13,809 --> 00:32:21,850
of the racy<font color="#E5E5E5"> debuff variable</font><font color="#CCCCCC"> and if</font>

501
00:32:18,309 --> 00:32:24,670
they're<font color="#E5E5E5"> sending fails the buffer which</font>

502
00:32:21,850 --> 00:32:29,559
was not sent is<font color="#CCCCCC"> just put at the head of</font>

503
00:32:24,670 --> 00:32:30,820
the queue for to send it later<font color="#E5E5E5"> for</font>

504
00:32:29,559 --> 00:32:35,500
<font color="#E5E5E5">sending the it later</font>

505
00:32:30,820 --> 00:32:38,379
and as I showed<font color="#CCCCCC"> you the colonel</font><font color="#E5E5E5"> locator</font>

506
00:32:35,500 --> 00:32:41,410
behaves quite strange allowing freeing

507
00:32:38,380 --> 00:32:45,070
the Canseco's a consecutive freeing of

508
00:32:41,410 --> 00:32:48,520
the<font color="#E5E5E5"> similar addresses and for example</font>

509
00:32:45,070 --> 00:32:51,909
ignosi<font color="#E5E5E5"> library has</font><font color="#CCCCCC"> so called fast top</font>

510
00:32:48,520 --> 00:32:54,760
<font color="#CCCCCC">check when we</font><font color="#E5E5E5"> put when we free another</font>

511
00:32:51,910 --> 00:32:57,400
object<font color="#E5E5E5"> and put it to the free list we</font>

512
00:32:54,760 --> 00:33:02,770
check that that that<font color="#E5E5E5"> the address of that</font>

513
00:32:57,400 --> 00:33:07,240
<font color="#E5E5E5">object is not equal</font><font color="#CCCCCC"> to the previous free</font>

514
00:33:02,770 --> 00:33:12,280
<font color="#E5E5E5">freed object so I did the same for the</font>

515
00:33:07,240 --> 00:33:16,929
main line<font color="#E5E5E5"> and it's quite cheap it is</font><font color="#CCCCCC"> a</font>

516
00:33:12,280 --> 00:33:20,770
cheap check which can block<font color="#E5E5E5"> the double</font>

517
00:33:16,929 --> 00:33:22,990
free exploitation and currently it is

518
00:33:20,770 --> 00:33:27,340
<font color="#E5E5E5">discussed in the Linux kernel mailing</font>

519
00:33:22,990 --> 00:33:31,140
list<font color="#E5E5E5"> and I</font><font color="#CCCCCC"> will and I hope</font><font color="#E5E5E5"> that it will</font>

520
00:33:27,340 --> 00:33:34,389
get<font color="#CCCCCC"> to</font><font color="#E5E5E5"> the main line behind this</font>

521
00:33:31,140 --> 00:33:40,059
<font color="#CCCCCC">particular configuration so they didn't</font>

522
00:33:34,390 --> 00:33:42,059
allow me to<font color="#CCCCCC"> put it by default in the to</font>

523
00:33:40,059 --> 00:33:47,220
the kernel

524
00:33:42,059 --> 00:33:47,220
<font color="#CCCCCC">thanks</font><font color="#E5E5E5"> that's all and</font>

525
00:33:54,100 --> 00:34:00,840
<font color="#CCCCCC">I would really appreciate</font><font color="#E5E5E5"> your questions</font>

526
00:33:57,280 --> 00:34:03,580
<font color="#E5E5E5">I have nice souvenirs for best questions</font>

527
00:34:00,840 --> 00:34:06,039
thank you<font color="#CCCCCC"> very</font><font color="#E5E5E5"> much Alexander</font><font color="#CCCCCC"> and indeed</font>

528
00:34:03,580 --> 00:34:08,290
we have<font color="#CCCCCC"> a lot of time for questions so</font>

529
00:34:06,039 --> 00:34:11,259
<font color="#CCCCCC">please go to</font><font color="#E5E5E5"> the center of the stage</font>

530
00:34:08,290 --> 00:34:16,600
where you<font color="#CCCCCC"> will find microphones and post</font>

531
00:34:11,260 --> 00:34:19,419
<font color="#E5E5E5">your questions please I music that the</font>

532
00:34:16,600 --> 00:34:23,350
<font color="#CCCCCC">Linux</font><font color="#E5E5E5"> kernel</font><font color="#CCCCCC"> May 10 is did not want</font><font color="#E5E5E5"> to</font>

533
00:34:19,418 --> 00:34:25,540
add the mitigation by default<font color="#CCCCCC"> why thanks</font>

534
00:34:23,350 --> 00:34:27,580
for the question first of all<font color="#E5E5E5"> they</font>

535
00:34:25,540 --> 00:34:32,918
already have all the corresponding

536
00:34:27,580 --> 00:34:35,859
checks<font color="#CCCCCC"> in the slub debug feature if you</font>

537
00:34:32,918 --> 00:34:39,368
run your kernel with slub debug<font color="#E5E5E5"> in the</font>

538
00:34:35,859 --> 00:34:42,069
kernel parameters<font color="#E5E5E5"> the allocator checks</font>

539
00:34:39,369 --> 00:34:46,330
whether it has double free or other

540
00:34:42,070 --> 00:34:49,720
errors<font color="#E5E5E5"> for example</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> locator method</font>

541
00:34:46,330 --> 00:34:53,460
actor corruption so they didn't<font color="#E5E5E5"> want</font>

542
00:34:49,719 --> 00:34:56,230
have the same feature in two places so

543
00:34:53,460 --> 00:34:59,350
but the<font color="#E5E5E5"> problem is that the default</font>

544
00:34:56,230 --> 00:35:04,180
<font color="#E5E5E5">kernel which</font><font color="#CCCCCC"> destroy provides doesn't</font>

545
00:34:59,350 --> 00:35:06,730
have this option<font color="#E5E5E5"> and so it just the</font>

546
00:35:04,180 --> 00:35:10,509
allocator just accepts freeing the same

547
00:35:06,730 --> 00:35:12,880
address<font color="#E5E5E5"> twice did</font><font color="#CCCCCC"> I relied any solutions</font>

548
00:35:10,510 --> 00:35:17,910
for the fact that nobody<font color="#E5E5E5"> ships</font><font color="#CCCCCC"> with this</font>

549
00:35:12,880 --> 00:35:25,270
enabled<font color="#E5E5E5"> they allowed</font><font color="#CCCCCC"> me to have this</font>

550
00:35:17,910 --> 00:35:28,299
<font color="#E5E5E5">check under the the specific kernel</font>

551
00:35:25,270 --> 00:35:32,650
config option and I hope that several

552
00:35:28,300 --> 00:35:35,080
distributions<font color="#E5E5E5"> which are which want to</font>

553
00:35:32,650 --> 00:35:39,369
provide<font color="#E5E5E5"> security for the users we use</font>

554
00:35:35,080 --> 00:35:43,390
this<font color="#E5E5E5"> option</font><font color="#CCCCCC"> this particular option</font><font color="#E5E5E5"> has a</font>

555
00:35:39,369 --> 00:35:46,990
nice feature it randomizes<font color="#E5E5E5"> the</font><font color="#CCCCCC"> address</font>

556
00:35:43,390 --> 00:35:51,339
of the items in the free list<font color="#E5E5E5"> so if the</font>

557
00:35:46,990 --> 00:35:52,330
attacker has the<font color="#CCCCCC"> hippo flaw exploit and</font>

558
00:35:51,340 --> 00:35:55,690
it

559
00:35:52,330 --> 00:35:59,799
he wants to override the next pointer in

560
00:35:55,690 --> 00:36:05,310
the free list<font color="#CCCCCC"> it will have to guess the</font>

561
00:35:59,800 --> 00:36:07,460
<font color="#E5E5E5">cookie which is stored in which is</font>

562
00:36:05,310 --> 00:36:12,980
unique<font color="#CCCCCC"> for</font>

563
00:36:07,460 --> 00:36:15,500
all CPU all allocated caches<font color="#E5E5E5"> and I hope</font>

564
00:36:12,980 --> 00:36:17,900
that my check will be<font color="#CCCCCC"> also</font><font color="#E5E5E5"> included</font><font color="#CCCCCC"> in</font>

565
00:36:15,500 --> 00:36:21,710
this config files

566
00:36:17,900 --> 00:36:24,410
thank you next question please

567
00:36:21,710 --> 00:36:26,750
<font color="#CCCCCC">hey</font><font color="#E5E5E5"> do we understand correctly that this</font>

568
00:36:24,410 --> 00:36:28,100
only works<font color="#CCCCCC"> if you have</font><font color="#E5E5E5"> both</font><font color="#CCCCCC"> the user</font>

569
00:36:26,750 --> 00:36:29,840
space and<font color="#E5E5E5"> kind of space in the same</font>

570
00:36:28,100 --> 00:36:31,910
mapping<font color="#CCCCCC"> so if you have the current that</font>

571
00:36:29,840 --> 00:36:33,710
does not map user space in the same

572
00:36:31,910 --> 00:36:36,440
amount of<font color="#E5E5E5"> space as</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> kernel would this</font>

573
00:36:33,710 --> 00:36:41,140
<font color="#E5E5E5">still work some architectures</font><font color="#CCCCCC"> down map</font>

574
00:36:36,440 --> 00:36:41,140
<font color="#E5E5E5">the user space in the kernel under space</font>

575
00:36:44,890 --> 00:36:54,589
<font color="#CCCCCC">Linux has it by design right now so</font>

576
00:36:49,490 --> 00:36:57,109
until<font color="#CCCCCC"> it until an interview map colonel</font>

577
00:36:54,590 --> 00:36:59,450
and user space in the same<font color="#E5E5E5"> address</font><font color="#CCCCCC"> space</font>

578
00:36:57,110 --> 00:37:01,310
<font color="#E5E5E5">but you map the kernel you mark the</font>

579
00:36:59,450 --> 00:37:03,109
kernel as<font color="#CCCCCC"> colonel so that the user space</font>

580
00:37:01,310 --> 00:37:05,600
cannot access it<font color="#E5E5E5"> but</font><font color="#CCCCCC"> completely some</font>

581
00:37:03,110 --> 00:37:11,270
other architectures don't do that yes on

582
00:37:05,600 --> 00:37:15,850
x86<font color="#E5E5E5"> the segmentation is not used it is</font>

583
00:37:11,270 --> 00:37:19,009
historically like that so it<font color="#E5E5E5"> is all</font>

584
00:37:15,850 --> 00:37:21,710
mapped yeah but not all architectures

585
00:37:19,010 --> 00:37:24,260
doodads<font color="#E5E5E5"> yes for example</font><font color="#CCCCCC"> juror security</font>

586
00:37:21,710 --> 00:37:27,470
<font color="#CCCCCC">patch set has so-called huge area</font>

587
00:37:24,260 --> 00:37:29,510
feature which uses the segmentation<font color="#E5E5E5"> and</font>

588
00:37:27,470 --> 00:37:31,459
helps against this attack it's not about

589
00:37:29,510 --> 00:37:34,070
segmentation I'm talking<font color="#E5E5E5"> like all the</font>

590
00:37:31,460 --> 00:37:38,720
architectures<font color="#CCCCCC"> no no I interr like</font><font color="#E5E5E5"> I</font>

591
00:37:34,070 --> 00:37:40,370
don't<font color="#E5E5E5"> know</font><font color="#CCCCCC"> said where you don't have the</font>

592
00:37:38,720 --> 00:37:45,109
user space map in the same address<font color="#CCCCCC"> space</font>

593
00:37:40,370 --> 00:37:48,560
<font color="#CCCCCC">altogether so if you like</font><font color="#E5E5E5"> that forearm</font>

594
00:37:45,110 --> 00:37:49,840
<font color="#E5E5E5">is it for Linux maybe I don't know about</font>

595
00:37:48,560 --> 00:37:52,610
<font color="#E5E5E5">our model</font>

596
00:37:49,840 --> 00:37:54,230
so would your exploit still work if you

597
00:37:52,610 --> 00:37:59,300
<font color="#E5E5E5">don't have a user space in the same</font>

598
00:37:54,230 --> 00:38:01,340
<font color="#E5E5E5">other spaces the kernel may be some</font>

599
00:37:59,300 --> 00:38:05,600
return-oriented programming will help

600
00:38:01,340 --> 00:38:09,530
against it but<font color="#E5E5E5"> the technique which</font><font color="#CCCCCC"> i</font>

601
00:38:05,600 --> 00:38:13,310
showed Battaglini<font color="#CCCCCC"> kolenka provided it</font>

602
00:38:09,530 --> 00:38:16,880
it also<font color="#CCCCCC"> maps</font><font color="#E5E5E5"> it is called</font><font color="#CCCCCC"> stuck piloting</font>

603
00:38:13,310 --> 00:38:19,970
when you move your kernel stack on to

604
00:38:16,880 --> 00:38:22,190
user space memory<font color="#E5E5E5"> and then</font>

605
00:38:19,970 --> 00:38:24,730
the kernel stack is controlled and you

606
00:38:22,190 --> 00:38:27,760
can do whatever you want with<font color="#CCCCCC"> return</font>

607
00:38:24,730 --> 00:38:30,680
<font color="#CCCCCC">oriented programming but it also uses</font>

608
00:38:27,760 --> 00:38:34,599
this fact<font color="#E5E5E5"> that the user space memory is</font>

609
00:38:30,680 --> 00:38:38,480
mapped at the kernel space the kernel

610
00:38:34,599 --> 00:38:40,460
when you run this is a system call the

611
00:38:38,480 --> 00:38:45,440
kernel works in the kernel space<font color="#E5E5E5"> on</font>

612
00:38:40,460 --> 00:38:48,799
behalf of the process which called<font color="#E5E5E5"> the</font>

613
00:38:45,440 --> 00:38:51,319
<font color="#E5E5E5">siskel so my exploit is the user space</font>

614
00:38:48,799 --> 00:38:54,440
program<font color="#E5E5E5"> it calls some system calls and</font>

615
00:38:51,319 --> 00:38:57,230
the kernel works<font color="#E5E5E5"> on</font><font color="#CCCCCC"> behalf of the</font>

616
00:38:54,440 --> 00:39:00,980
exploit in<font color="#E5E5E5"> the kernel space so the</font>

617
00:38:57,230 --> 00:39:07,030
kernel when it executes<font color="#E5E5E5"> the system call</font>

618
00:39:00,980 --> 00:39:07,030
<font color="#E5E5E5">knows which process asked for that and</font>

619
00:39:08,650 --> 00:39:15,710
that need to work<font color="#CCCCCC"> and if we don't map</font>

620
00:39:13,369 --> 00:39:17,809
user space<font color="#E5E5E5"> drill</font><font color="#CCCCCC"> user space memory</font><font color="#E5E5E5"> to</font>

621
00:39:15,710 --> 00:39:20,510
the kernel space we<font color="#E5E5E5"> should provide this</font>

622
00:39:17,809 --> 00:39:26,829
feature the kernel<font color="#CCCCCC"> should know which</font>

623
00:39:20,510 --> 00:39:26,829
process is executed right now thank<font color="#E5E5E5"> you</font>

624
00:39:27,279 --> 00:39:33,049
more<font color="#CCCCCC"> questions</font><font color="#E5E5E5"> from the</font><font color="#CCCCCC"> audience</font>

625
00:39:30,490 --> 00:39:40,430
you<font color="#E5E5E5"> have funded specialist please come</font>

626
00:39:33,049 --> 00:39:44,509
to the mic<font color="#CCCCCC"> I hi</font><font color="#E5E5E5"> could you tell some more</font>

627
00:39:40,430 --> 00:39:47,299
<font color="#E5E5E5">about the process</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> informing the</font><font color="#CCCCCC"> Linux</font>

628
00:39:44,510 --> 00:39:51,319
kernel or other Linux kernel developers

629
00:39:47,299 --> 00:39:52,670
and the distros etc because you in the

630
00:39:51,319 --> 00:39:53,960
beginning<font color="#CCCCCC"> of your talk you gave the</font>

631
00:39:52,670 --> 00:39:56,299
timeline yes

632
00:39:53,960 --> 00:39:57,950
and it<font color="#CCCCCC"> could took a</font><font color="#E5E5E5"> couple of days</font><font color="#CCCCCC"> ok I</font>

633
00:39:56,299 --> 00:39:59,869
<font color="#E5E5E5">tell how it worked</font>

634
00:39:57,950 --> 00:40:03,939
<font color="#E5E5E5">did it work smoothly where any issues</font>

635
00:39:59,869 --> 00:40:07,279
etc<font color="#E5E5E5"> etc yes thank you for</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> question</font>

636
00:40:03,940 --> 00:40:10,190
<font color="#CCCCCC">first I conducted security at kernel the</font>

637
00:40:07,279 --> 00:40:13,779
torque and it took us some<font color="#CCCCCC"> time to</font>

638
00:40:10,190 --> 00:40:17,539
<font color="#E5E5E5">understand that the</font><font color="#CCCCCC"> vulnerability is</font>

639
00:40:13,779 --> 00:40:19,849
<font color="#E5E5E5">serious because it affects the all major</font>

640
00:40:17,539 --> 00:40:20,750
distress are affected<font color="#E5E5E5"> at first</font><font color="#CCCCCC"> a</font>

641
00:40:19,849 --> 00:40:26,089
<font color="#CCCCCC">maintainer</font>

642
00:40:20,750 --> 00:40:28,190
didn't didn't get that it has this

643
00:40:26,089 --> 00:40:33,770
option<font color="#E5E5E5"> is</font><font color="#CCCCCC"> enabled on</font><font color="#E5E5E5"> all these drawers</font>

644
00:40:28,190 --> 00:40:39,130
<font color="#E5E5E5">and three days</font><font color="#CCCCCC"> late a left</font><font color="#E5E5E5"> later</font>

645
00:40:33,770 --> 00:40:44,329
one of the<font color="#E5E5E5"> kernel security engineers</font>

646
00:40:39,130 --> 00:40:47,480
contacted the<font color="#CCCCCC"> district</font><font color="#E5E5E5"> and described the</font>

647
00:40:44,329 --> 00:40:49,160
vulnerability my patch which I sent to

648
00:40:47,480 --> 00:40:53,960
security at<font color="#E5E5E5"> kernel.org</font>

649
00:40:49,160 --> 00:40:58,700
was sent to<font color="#CCCCCC"> the distros</font><font color="#E5E5E5"> but there was</font>

650
00:40:53,960 --> 00:41:01,339
some additional<font color="#E5E5E5"> work needed because all</font>

651
00:40:58,700 --> 00:41:03,319
stable<font color="#E5E5E5"> kernel release was also affected</font>

652
00:41:01,339 --> 00:41:07,940
<font color="#CCCCCC">because the vulnerability</font><font color="#E5E5E5"> was introduced</font>

653
00:41:03,319 --> 00:41:08,869
in 2009<font color="#E5E5E5"> as you say as you see</font><font color="#CCCCCC"> so quite a</font>

654
00:41:07,940 --> 00:41:11,119
long time ago

655
00:41:08,869 --> 00:41:13,550
so not<font color="#CCCCCC"> only all major distress was</font>

656
00:41:11,119 --> 00:41:17,450
affected all stable<font color="#E5E5E5"> kernel releases was</font>

657
00:41:13,550 --> 00:41:24,770
affected as<font color="#CCCCCC"> well</font><font color="#E5E5E5"> and some of them didn't</font>

658
00:41:17,450 --> 00:41:29,000
<font color="#CCCCCC">have the today's standard kernel linked</font>

659
00:41:24,770 --> 00:41:32,630
lists<font color="#E5E5E5"> so I worked with</font><font color="#CCCCCC"> digital</font>

660
00:41:29,000 --> 00:41:35,089
developers and to provide a patch which

661
00:41:32,630 --> 00:41:41,809
will work which will fix the issue on

662
00:41:35,089 --> 00:41:46,359
<font color="#E5E5E5">the old stable kernel releases and the</font>

663
00:41:41,809 --> 00:41:52,849
embargo which I noticed<font color="#E5E5E5"> is a special</font>

664
00:41:46,359 --> 00:41:55,180
date<font color="#E5E5E5"> when I'm allowed</font><font color="#CCCCCC"> to share the</font>

665
00:41:52,849 --> 00:42:00,130
<font color="#E5E5E5">information about</font><font color="#CCCCCC"> this vulnerability</font><font color="#E5E5E5"> and</font>

666
00:41:55,180 --> 00:42:03,799
at this<font color="#E5E5E5"> particular did the distros give</font>

667
00:42:00,130 --> 00:42:11,500
the kernel update for their users so it

668
00:42:03,799 --> 00:42:14,089
is it happens<font color="#E5E5E5"> almost simultaneously to</font>

669
00:42:11,500 --> 00:42:17,470
decrease the<font color="#E5E5E5"> channel chances of</font>

670
00:42:14,089 --> 00:42:24,020
blackheads<font color="#E5E5E5"> to attack this vulnerability</font>

671
00:42:17,470 --> 00:42:29,240
<font color="#E5E5E5">in case they can reproduce the bug and</font>

672
00:42:24,020 --> 00:42:33,650
write the exploit very fast so that's

673
00:42:29,240 --> 00:42:37,129
<font color="#E5E5E5">why security researchers usually don't</font>

674
00:42:33,650 --> 00:42:39,859
give the exploit<font color="#E5E5E5"> straight away</font><font color="#CCCCCC"> but wait</font>

675
00:42:37,130 --> 00:42:42,920
for<font color="#CCCCCC"> some time</font><font color="#E5E5E5"> exploit proof of concept I</font>

676
00:42:39,859 --> 00:42:45,799
mean but they wait for<font color="#CCCCCC"> some time to</font>

677
00:42:42,920 --> 00:42:46,790
<font color="#E5E5E5">allow all these three users update their</font>

678
00:42:45,799 --> 00:42:49,100
systems

679
00:42:46,790 --> 00:42:52,060
of course unfortunately not<font color="#CCCCCC"> all people</font>

680
00:42:49,100 --> 00:42:58,750
do that<font color="#E5E5E5"> not on all people update their</font>

681
00:42:52,060 --> 00:43:02,450
systems and<font color="#E5E5E5"> they stay vulnerable and</font>

682
00:42:58,750 --> 00:43:07,930
when I wrote to security at kernel.org

683
00:43:02,450 --> 00:43:12,980
<font color="#CCCCCC">the security engineers</font><font color="#E5E5E5"> maintainer</font>

684
00:43:07,930 --> 00:43:18,850
got<font color="#CCCCCC"> CB I ID</font><font color="#E5E5E5"> themselves now it it has</font>

685
00:43:12,980 --> 00:43:23,360
changed<font color="#CCCCCC"> there is a special organization</font>

686
00:43:18,850 --> 00:43:25,339
called<font color="#E5E5E5"> Mitra which gives the CV numbers</font>

687
00:43:23,360 --> 00:43:29,030
to the vulnerabilities<font color="#E5E5E5"> and now you</font>

688
00:43:25,340 --> 00:43:34,010
should contact mitra yourself describe

689
00:43:29,030 --> 00:43:35,740
the vulnerability<font color="#CCCCCC"> so the impact and you</font>

690
00:43:34,010 --> 00:43:40,010
will get the<font color="#CCCCCC"> CVE</font>

691
00:43:35,740 --> 00:43:42,229
identifier for<font color="#E5E5E5"> this vulnerability</font><font color="#CCCCCC"> so now</font>

692
00:43:40,010 --> 00:43:46,040
it is<font color="#CCCCCC"> your responsibility to</font><font color="#E5E5E5"> get this</font>

693
00:43:42,230 --> 00:43:50,260
number<font color="#E5E5E5"> and this number is important</font>

694
00:43:46,040 --> 00:43:56,090
because it<font color="#E5E5E5"> helps to track whether your</font>

695
00:43:50,260 --> 00:43:59,630
system has all current security<font color="#E5E5E5"> updates</font>

696
00:43:56,090 --> 00:44:01,430
it helps to understand whether<font color="#E5E5E5"> you have</font>

697
00:43:59,630 --> 00:44:07,550
all recent<font color="#E5E5E5"> patches for the</font>

698
00:44:01,430 --> 00:44:10,069
vulnerabilities that's it<font color="#E5E5E5"> thank you for</font>

699
00:44:07,550 --> 00:44:13,750
<font color="#E5E5E5">the question thank you very much someone</font>

700
00:44:10,070 --> 00:44:13,750
else<font color="#E5E5E5"> more questions from the public</font>

701
00:44:13,990 --> 00:44:20,919
<font color="#CCCCCC">no I would like to continue on that</font>

702
00:44:17,300 --> 00:44:25,010
question<font color="#E5E5E5"> who sets the time for embargo</font>

703
00:44:20,920 --> 00:44:26,720
<font color="#CCCCCC">colonel maintainer they in collaboration</font>

704
00:44:25,010 --> 00:44:30,680
<font color="#CCCCCC">with the district decide</font><font color="#E5E5E5"> how much time</font>

705
00:44:26,720 --> 00:44:33,680
do<font color="#CCCCCC"> they need to fix the issue and to</font>

706
00:44:30,680 --> 00:44:36,649
prepare their new<font color="#E5E5E5"> Colonels for the for</font>

707
00:44:33,680 --> 00:44:40,660
the users<font color="#E5E5E5"> what if they get wrong this</font>

708
00:44:36,650 --> 00:44:40,660
<font color="#CCCCCC">time of embargo that you can also update</font>

709
00:44:40,900 --> 00:44:49,100
<font color="#CCCCCC">straightaway</font><font color="#E5E5E5"> so change let's say we need</font>

710
00:44:44,120 --> 00:44:52,460
one<font color="#CCCCCC"> more month or one more week it</font>

711
00:44:49,100 --> 00:44:55,069
doesn't look good<font color="#E5E5E5"> to stay vulnerable</font><font color="#CCCCCC"> if</font>

712
00:44:52,460 --> 00:44:59,610
the information about the vulnerability

713
00:44:55,070 --> 00:45:04,540
<font color="#E5E5E5">is already available so</font>

714
00:44:59,610 --> 00:45:11,020
as you saw<font color="#E5E5E5"> less than a week and</font><font color="#CCCCCC"> Aldi</font>

715
00:45:04,540 --> 00:45:13,540
<font color="#CCCCCC">stores provided the patch next</font><font color="#E5E5E5"> question</font>

716
00:45:11,020 --> 00:45:18,730
please<font color="#CCCCCC"> the man behind at the back first</font>

717
00:45:13,540 --> 00:45:20,410
three what miss you<font color="#E5E5E5"> know what</font><font color="#CCCCCC"> misuse</font>

718
00:45:18,730 --> 00:45:24,720
does the colonel take in<font color="#E5E5E5"> order</font><font color="#CCCCCC"> to</font>

719
00:45:20,410 --> 00:45:27,430
prevent panic on<font color="#CCCCCC"> the same stone</font><font color="#E5E5E5"> twice</font>

720
00:45:24,720 --> 00:45:29,620
<font color="#CCCCCC">could you</font><font color="#E5E5E5"> repeat please yes</font>

721
00:45:27,430 --> 00:45:31,390
what misuse<font color="#E5E5E5"> is the colonel taking in</font>

722
00:45:29,620 --> 00:45:31,930
<font color="#E5E5E5">order to prevent stepping on the same</font>

723
00:45:31,390 --> 00:45:37,420
stone

724
00:45:31,930 --> 00:45:41,049
twice<font color="#CCCCCC"> if I understood you right you are</font>

725
00:45:37,420 --> 00:45:44,410
asking<font color="#E5E5E5"> what did I do to prevent double</font>

726
00:45:41,050 --> 00:45:47,710
freeing right now<font color="#E5E5E5"> I'm asking holistic</font>

727
00:45:44,410 --> 00:45:49,960
get closer to the mic please<font color="#E5E5E5"> I'm asking</font>

728
00:45:47,710 --> 00:45:51,280
how<font color="#CCCCCC"> does how does the colonel prevent</font>

729
00:45:49,960 --> 00:45:55,060
this from happening again

730
00:45:51,280 --> 00:45:58,180
<font color="#CCCCCC">I you mean this</font><font color="#E5E5E5"> particular book the race</font>

731
00:45:55,060 --> 00:46:04,299
condition or this particular<font color="#CCCCCC"> clay</font><font color="#E5E5E5"> class</font>

732
00:45:58,180 --> 00:46:07,210
of paths or problems<font color="#E5E5E5"> there is no general</font>

733
00:46:04,300 --> 00:46:09,430
<font color="#E5E5E5">defense against the race condition the</font>

734
00:46:07,210 --> 00:46:18,370
proper defense is proper code with

735
00:46:09,430 --> 00:46:20,529
proper<font color="#E5E5E5"> locking and yes and the result of</font>

736
00:46:18,370 --> 00:46:22,720
the race<font color="#E5E5E5"> condition can be different</font><font color="#CCCCCC"> in</font>

737
00:46:20,530 --> 00:46:26,620
this<font color="#E5E5E5"> particular case it was double free</font>

738
00:46:22,720 --> 00:46:30,850
and it can be detected<font color="#CCCCCC"> for example slop</font>

739
00:46:26,620 --> 00:46:33,009
debug option for the colonel<font color="#CCCCCC"> makes the</font>

740
00:46:30,850 --> 00:46:36,520
colonel drop at the<font color="#E5E5E5"> second three of the</font>

741
00:46:33,010 --> 00:46:38,470
same item so it on every frame it goes

742
00:46:36,520 --> 00:46:39,130
through the free list or in the

743
00:46:38,470 --> 00:46:43,029
allocator

744
00:46:39,130 --> 00:46:48,310
<font color="#E5E5E5">and drops the current frame if we</font>

745
00:46:43,030 --> 00:46:51,280
already<font color="#CCCCCC"> freed this item and mmm I can't</font>

746
00:46:48,310 --> 00:46:54,250
say<font color="#E5E5E5"> that I</font><font color="#CCCCCC"> like it</font><font color="#E5E5E5"> very much</font><font color="#CCCCCC"> because</font><font color="#E5E5E5"> if</font>

747
00:46:51,280 --> 00:46:57,580
double free happened<font color="#E5E5E5"> it that means that</font>

748
00:46:54,250 --> 00:47:01,090
the buck already was hit some way in<font color="#E5E5E5"> the</font>

749
00:46:57,580 --> 00:47:03,490
<font color="#E5E5E5">colonel it's already bad so maybe it is</font>

750
00:47:01,090 --> 00:47:07,060
not<font color="#E5E5E5"> good to trust the process</font><font color="#CCCCCC"> which</font>

751
00:47:03,490 --> 00:47:12,899
caused this<font color="#E5E5E5"> double free error but anyway</font>

752
00:47:07,060 --> 00:47:12,900
<font color="#CCCCCC">slop debug provides that there are</font>

753
00:47:14,109 --> 00:47:22,000
maybe there are other defenses against

754
00:47:17,540 --> 00:47:27,320
the results of the race<font color="#E5E5E5"> conditions</font><font color="#CCCCCC"> but I</font>

755
00:47:22,000 --> 00:47:29,660
yes there is<font color="#E5E5E5"> the nice project called</font>

756
00:47:27,320 --> 00:47:33,260
<font color="#CCCCCC">threat sanitizer</font><font color="#E5E5E5"> you may heard about</font>

757
00:47:29,660 --> 00:47:39,009
that<font color="#E5E5E5"> it is a brother of Colonel dress</font>

758
00:47:33,260 --> 00:47:42,440
sanitizer<font color="#CCCCCC"> and so on and it provides some</font>

759
00:47:39,010 --> 00:47:45,440
<font color="#CCCCCC">compile-time instrumentation to detect</font>

760
00:47:42,440 --> 00:47:48,680
the race<font color="#E5E5E5"> conditions the race access to</font>

761
00:47:45,440 --> 00:47:52,310
some memory<font color="#CCCCCC"> it</font><font color="#E5E5E5"> stores the meta</font>

762
00:47:48,680 --> 00:47:54,649
information about the memory in a

763
00:47:52,310 --> 00:47:56,840
separate place and<font color="#E5E5E5"> just check it all the</font>

764
00:47:54,650 --> 00:48:00,859
time<font color="#E5E5E5"> when you have</font><font color="#CCCCCC"> the access it doesn't</font>

765
00:47:56,840 --> 00:48:05,470
work<font color="#CCCCCC"> very fast but</font><font color="#E5E5E5"> anyway it can be used</font>

766
00:48:00,859 --> 00:48:08,720
<font color="#E5E5E5">for debugging</font><font color="#CCCCCC"> the kernel</font><font color="#E5E5E5"> and that it is</font>

767
00:48:05,470 --> 00:48:11,740
not currently in<font color="#CCCCCC"> the main line because</font>

768
00:48:08,720 --> 00:48:16,009
it has a lot<font color="#CCCCCC"> of false positive errors</font>

769
00:48:11,740 --> 00:48:19,160
but anyway you can<font color="#E5E5E5"> apply the patch and</font>

770
00:48:16,010 --> 00:48:23,270
try to run your kernel with this debug

771
00:48:19,160 --> 00:48:25,520
option and see all the reports<font color="#CCCCCC"> and fix</font>

772
00:48:23,270 --> 00:48:29,900
the code so it is<font color="#E5E5E5"> a debugging feature</font>

773
00:48:25,520 --> 00:48:33,410
<font color="#CCCCCC">thread sanitizer thank you</font><font color="#E5E5E5"> for a</font>

774
00:48:29,900 --> 00:48:37,550
<font color="#CCCCCC">question I</font><font color="#E5E5E5"> know the question is</font><font color="#CCCCCC"> it</font>

775
00:48:33,410 --> 00:48:40,700
exploitable<font color="#E5E5E5"> on the amd64</font><font color="#CCCCCC"> and the second</font>

776
00:48:37,550 --> 00:48:44,200
question<font color="#CCCCCC"> is when it will be like script</font>

777
00:48:40,700 --> 00:48:49,910
<font color="#CCCCCC">script</font><font color="#E5E5E5"> kiddies version will be available</font>

778
00:48:44,200 --> 00:48:56,990
<font color="#CCCCCC">ok yes it can be exploited on AMD</font><font color="#E5E5E5"> sure</font>

779
00:48:49,910 --> 00:48:59,420
and<font color="#E5E5E5"> I already wrote a detailed write-up</font>

780
00:48:56,990 --> 00:49:03,950
about<font color="#CCCCCC"> this</font><font color="#E5E5E5"> vulnerability and the exploit</font>

781
00:48:59,420 --> 00:49:06,410
it has some parts of the code<font color="#E5E5E5"> and this</font>

782
00:49:03,950 --> 00:49:09,700
talk provided some details<font color="#CCCCCC"> I didn't</font>

783
00:49:06,410 --> 00:49:17,529
really want<font color="#CCCCCC"> to give the full exploit</font>

784
00:49:09,700 --> 00:49:17,529
just because there<font color="#E5E5E5"> are anyway</font><font color="#CCCCCC"> a lot of</font>

785
00:49:18,280 --> 00:49:24,550
out<font color="#E5E5E5"> out-of-date kernels on the systems</font>

786
00:49:22,369 --> 00:49:26,950
of different people

787
00:49:24,550 --> 00:49:29,170
sometimes people<font color="#E5E5E5"> say just we have</font>

788
00:49:26,950 --> 00:49:31,930
defended the perimeter of our own

789
00:49:29,170 --> 00:49:35,470
network<font color="#E5E5E5"> it's fine to have out of Daved</font>

790
00:49:31,930 --> 00:49:38,819
systems inside<font color="#CCCCCC"> so that's</font><font color="#E5E5E5"> why I don't</font>

791
00:49:35,470 --> 00:49:42,669
give the full exploit thank you

792
00:49:38,820 --> 00:49:45,490
next question please since this book is

793
00:49:42,670 --> 00:49:50,160
in such a hot<font color="#E5E5E5"> path</font><font color="#CCCCCC"> do you think it</font><font color="#E5E5E5"> is</font>

794
00:49:45,490 --> 00:49:55,029
<font color="#CCCCCC">possible to wife Patchett life budget</font>

795
00:49:50,160 --> 00:50:00,819
yes<font color="#CCCCCC"> thanks for your question</font>

796
00:49:55,030 --> 00:50:05,410
<font color="#CCCCCC">I well working</font><font color="#E5E5E5"> on the fix with the</font>

797
00:50:00,820 --> 00:50:08,340
distros<font color="#E5E5E5"> I was conducted with a developer</font>

798
00:50:05,410 --> 00:50:14,560
from<font color="#E5E5E5"> Oracle they have some life</font><font color="#CCCCCC"> patching</font>

799
00:50:08,340 --> 00:50:20,110
subsystem and<font color="#E5E5E5"> we were working on some</font>

800
00:50:14,560 --> 00:50:24,670
<font color="#E5E5E5">really small fix which can be applied</font>

801
00:50:20,110 --> 00:50:27,790
with<font color="#E5E5E5"> that this life</font><font color="#CCCCCC"> patches are working</font>

802
00:50:24,670 --> 00:50:30,700
as the kernel modules you just load this

803
00:50:27,790 --> 00:50:35,560
patch module into your kernel<font color="#E5E5E5"> and the</font>

804
00:50:30,700 --> 00:50:38,980
code path has paths are fixed<font color="#CCCCCC"> but it</font>

805
00:50:35,560 --> 00:50:42,820
should<font color="#E5E5E5"> not be really big that's why we</font>

806
00:50:38,980 --> 00:50:45,670
<font color="#E5E5E5">work to make it as smaller as we can to</font>

807
00:50:42,820 --> 00:50:47,860
life<font color="#CCCCCC"> let date the systems you're talking</font>

808
00:50:45,670 --> 00:50:51,460
about<font color="#E5E5E5"> case</font><font color="#CCCCCC"> PI's I'm talking about</font><font color="#E5E5E5"> K</font>

809
00:50:47,860 --> 00:50:55,050
patch<font color="#E5E5E5"> yes a vanilla kernel wife patching</font>

810
00:50:51,460 --> 00:50:58,480
mechanism<font color="#E5E5E5"> yes both of</font><font color="#CCCCCC"> them can do it</font>

811
00:50:55,050 --> 00:50:59,260
<font color="#E5E5E5">think for a</font><font color="#CCCCCC"> Curson yes question in the</font>

812
00:50:58,480 --> 00:51:02,530
front<font color="#E5E5E5"> please</font>

813
00:50:59,260 --> 00:51:04,090
I have not a<font color="#E5E5E5"> question for you you said</font>

814
00:51:02,530 --> 00:51:06,520
<font color="#E5E5E5">somewhere near the start of the</font>

815
00:51:04,090 --> 00:51:09,820
presentation<font color="#CCCCCC"> that</font><font color="#E5E5E5"> the cause of this was</font>

816
00:51:06,520 --> 00:51:13,030
<font color="#E5E5E5">a homegrown linked list implementation</font><font color="#CCCCCC"> I</font>

817
00:51:09,820 --> 00:51:14,650
<font color="#CCCCCC">can't imagine</font><font color="#E5E5E5"> that a lot</font><font color="#CCCCCC"> of these kind</font>

818
00:51:13,030 --> 00:51:17,590
of homegrown implementations are going

819
00:51:14,650 --> 00:51:19,600
to be wrong in some way how common are

820
00:51:17,590 --> 00:51:21,460
these in the<font color="#E5E5E5"> Linux kernel homegrown</font>

821
00:51:19,600 --> 00:51:23,140
implementations of something that should

822
00:51:21,460 --> 00:51:27,760
<font color="#CCCCCC">really</font><font color="#E5E5E5"> be</font><font color="#CCCCCC"> using a standardized kernel</font>

823
00:51:23,140 --> 00:51:30,940
implementation<font color="#CCCCCC"> I would say that this</font>

824
00:51:27,760 --> 00:51:34,420
particular driver is quite old and it

825
00:51:30,940 --> 00:51:36,760
would not used very<font color="#E5E5E5"> intensively so it</font>

826
00:51:34,420 --> 00:51:39,610
isn't not<font color="#E5E5E5"> some</font>

827
00:51:36,760 --> 00:51:44,020
<font color="#CCCCCC">kernel code which has a lot of</font>

828
00:51:39,610 --> 00:51:46,960
developers<font color="#E5E5E5"> looking into it and there are</font>

829
00:51:44,020 --> 00:51:52,630
a<font color="#CCCCCC"> lot of such code in a</font><font color="#E5E5E5"> Linux kernel</font><font color="#CCCCCC"> it</font>

830
00:51:46,960 --> 00:51:56,320
is more<font color="#CCCCCC"> than 20 million</font><font color="#E5E5E5"> strings of code</font>

831
00:51:52,630 --> 00:51:58,900
as I remember<font color="#E5E5E5"> so it's quite big</font><font color="#CCCCCC"> but</font><font color="#E5E5E5"> this</font>

832
00:51:56,320 --> 00:52:01,840
particular<font color="#E5E5E5"> buck was I was lucky to find</font>

833
00:51:58,900 --> 00:52:06,670
<font color="#E5E5E5">it because it was enabled</font><font color="#CCCCCC"> on all distros</font>

834
00:52:01,840 --> 00:52:10,030
<font color="#E5E5E5">so I guess it can</font><font color="#CCCCCC"> be possible to write a</font>

835
00:52:06,670 --> 00:52:12,850
simple program which finds<font color="#E5E5E5"> you or the</font>

836
00:52:10,030 --> 00:52:17,620
oldest code which your district provides

837
00:52:12,850 --> 00:52:18,730
you and for<font color="#E5E5E5"> example</font><font color="#CCCCCC"> fuzz it alright</font>

838
00:52:17,620 --> 00:52:22,150
thanks<font color="#CCCCCC"> thank you</font>

839
00:52:18,730 --> 00:52:24,520
question in the back please yes I'd like

840
00:52:22,150 --> 00:52:26,500
<font color="#CCCCCC">to</font><font color="#E5E5E5"> hear more about how this</font><font color="#CCCCCC"> bug was</font>

841
00:52:24,520 --> 00:52:28,540
detected<font color="#E5E5E5"> in the first place one of</font><font color="#CCCCCC"> your</font>

842
00:52:26,500 --> 00:52:31,030
<font color="#CCCCCC">early</font><font color="#E5E5E5"> slides said that somebody</font>

843
00:52:28,540 --> 00:52:33,040
<font color="#E5E5E5">contacted you do you have more</font>

844
00:52:31,030 --> 00:52:38,010
information<font color="#E5E5E5"> how this was originally</font>

845
00:52:33,040 --> 00:52:38,009
detected and a white came to you

846
00:52:38,400 --> 00:52:47,950
<font color="#CCCCCC">originally it</font><font color="#E5E5E5"> was detected on my system</font>

847
00:52:41,620 --> 00:52:51,580
<font color="#E5E5E5">so I ran</font><font color="#CCCCCC"> sis</font><font color="#E5E5E5"> color father on my machines</font>

848
00:52:47,950 --> 00:52:56,169
and got the suspicious crush<font color="#CCCCCC"> that</font>

849
00:52:51,580 --> 00:53:01,330
suspicious<font color="#E5E5E5"> then I investigated why this</font>

850
00:52:56,170 --> 00:53:02,470
<font color="#CCCCCC">crush</font><font color="#E5E5E5"> happened and the cool feature</font>

851
00:53:01,330 --> 00:53:05,110
about<font color="#E5E5E5"> this</font><font color="#CCCCCC"> color</font>

852
00:53:02,470 --> 00:53:08,680
it can provide<font color="#E5E5E5"> seed program</font><font color="#CCCCCC"> which</font>

853
00:53:05,110 --> 00:53:11,020
reproduces this crush it it just caused

854
00:53:08,680 --> 00:53:16,180
a lot of<font color="#CCCCCC"> sis calls on a virtual</font><font color="#E5E5E5"> machine</font>

855
00:53:11,020 --> 00:53:18,940
and then<font color="#E5E5E5"> you can run the result again so</font>

856
00:53:16,180 --> 00:53:22,000
you can<font color="#E5E5E5"> reproduce the bug again and see</font>

857
00:53:18,940 --> 00:53:25,030
this particular crush and then after hey

858
00:53:22,000 --> 00:53:28,330
<font color="#CCCCCC">I had a stable repre</font><font color="#E5E5E5"> I started to</font>

859
00:53:25,030 --> 00:53:33,250
<font color="#CCCCCC">investigate how to exploit it not to</font>

860
00:53:28,330 --> 00:53:35,910
have a<font color="#CCCCCC"> crush</font><font color="#E5E5E5"> but have a root and so it</font>

861
00:53:33,250 --> 00:53:39,070
all happened on my machine<font color="#E5E5E5"> and you can</font>

862
00:53:35,910 --> 00:53:42,730
install<font color="#E5E5E5"> and use this color - it's quite</font>

863
00:53:39,070 --> 00:53:49,120
easy<font color="#E5E5E5"> and they have nice wiki on github</font>

864
00:53:42,730 --> 00:53:52,360
<font color="#CCCCCC">so I really</font><font color="#E5E5E5"> like people who develop it</font>

865
00:53:49,120 --> 00:53:54,880
<font color="#E5E5E5">thank you more questions</font><font color="#CCCCCC"> from the</font>

866
00:53:52,360 --> 00:54:05,650
<font color="#CCCCCC">audience you can still enjoy</font><font color="#E5E5E5"> about seven</font>

867
00:53:54,880 --> 00:54:10,330
<font color="#E5E5E5">minutes of open question time nobody</font>

868
00:54:05,650 --> 00:54:12,400
else well in that case I<font color="#E5E5E5"> will close the</font>

869
00:54:10,330 --> 00:54:13,900
session<font color="#CCCCCC"> thank you very</font><font color="#E5E5E5"> much Alex thank</font>

870
00:54:12,400 --> 00:54:14,350
you<font color="#CCCCCC"> all right</font><font color="#E5E5E5"> big round of applause for</font>

871
00:54:13,900 --> 00:54:26,770
<font color="#CCCCCC">here</font>

872
00:54:14,350 --> 00:54:38,920
[Applause]

873
00:54:26,770 --> 00:54:38,920
[Music]

