1
00:00:03,040 --> 00:00:04,080
hey guys

2
00:00:04,080 --> 00:00:07,120
welcome to join our talk today

3
00:00:07,120 --> 00:00:10,000
we'll be demonstrating our engine clock

4
00:00:10,000 --> 00:00:12,160
it is an obfuscation neglect

5
00:00:12,160 --> 00:00:15,440
android malware scoring system

6
00:00:15,440 --> 00:00:18,000
so my name is kunyu chen i'm a security

7
00:00:18,000 --> 00:00:18,800
researcher

8
00:00:18,800 --> 00:00:21,680
and founder of kwaken jung and we also

9
00:00:21,680 --> 00:00:23,039
have another speaker

10
00:00:23,039 --> 00:00:25,519
jin bae song he's the co-founder of

11
00:00:25,519 --> 00:00:26,400
quake engine

12
00:00:26,400 --> 00:00:27,920
and he gave talks in security

13
00:00:27,920 --> 00:00:30,080
conferences like hitb

14
00:00:30,080 --> 00:00:32,800
and defcon

15
00:00:33,120 --> 00:00:37,040
so this is the outline number one

16
00:00:37,040 --> 00:00:39,120
we will introduce our malware scoring

17
00:00:39,120 --> 00:00:40,399
system

18
00:00:40,399 --> 00:00:42,399
number two we will show you how we

19
00:00:42,399 --> 00:00:45,039
design the delby biker loader

20
00:00:45,039 --> 00:00:47,200
and number three we will go through two

21
00:00:47,200 --> 00:00:49,360
cases of real malware analysis

22
00:00:49,360 --> 00:00:52,399
using quark engine number four

23
00:00:52,399 --> 00:00:54,800
we will share our strategy of generating

24
00:00:54,800 --> 00:00:56,960
the detection rules

25
00:00:56,960 --> 00:01:00,640
and the last thing yes the future works

26
00:01:00,640 --> 00:01:04,160
we still have a lot of things to do

27
00:01:04,400 --> 00:01:06,640
all right so let's introduce the malware

28
00:01:06,640 --> 00:01:09,119
scoring system

29
00:01:09,119 --> 00:01:12,880
as we know when developing a malware

30
00:01:12,880 --> 00:01:14,960
when developing a malware analysis

31
00:01:14,960 --> 00:01:17,759
engine it is important to have a scoring

32
00:01:17,759 --> 00:01:18,880
system

33
00:01:18,880 --> 00:01:21,280
however those systems are either

34
00:01:21,280 --> 00:01:22,799
business secrets or

35
00:01:22,799 --> 00:01:26,320
too complicated so therefore we decided

36
00:01:26,320 --> 00:01:27,280
to create

37
00:01:27,280 --> 00:01:30,479
a simple but solid one and take that

38
00:01:30,479 --> 00:01:33,920
as a challenge and since we wanted to

39
00:01:33,920 --> 00:01:34,880
decide

40
00:01:34,880 --> 00:01:37,280
a novel scoring system we stopped

41
00:01:37,280 --> 00:01:39,439
reading and decoding what other people

42
00:01:39,439 --> 00:01:42,720
do in the field of cyber security

43
00:01:42,720 --> 00:01:44,640
because we don't want our ideas to be

44
00:01:44,640 --> 00:01:48,560
subjected to the existing systems

45
00:01:48,560 --> 00:01:51,040
so we started to find ideas and fields

46
00:01:51,040 --> 00:01:51,840
other than

47
00:01:51,840 --> 00:01:56,799
cyber security and luckily we found one

48
00:01:56,799 --> 00:01:59,680
yes the best practice we found is the

49
00:01:59,680 --> 00:02:02,079
criminal law

50
00:02:02,079 --> 00:02:04,719
so when sentenced the penalty for the

51
00:02:04,719 --> 00:02:05,600
criminal

52
00:02:05,600 --> 00:02:08,080
the judge awaits the penalties based on

53
00:02:08,080 --> 00:02:09,440
the criminal law

54
00:02:09,440 --> 00:02:11,840
and after defaulting the law we find

55
00:02:11,840 --> 00:02:14,160
principles behind it

56
00:02:14,160 --> 00:02:16,080
and we develop a scoring system for

57
00:02:16,080 --> 00:02:18,640
android malware

58
00:02:18,640 --> 00:02:20,800
there are only eight principles decoded

59
00:02:20,800 --> 00:02:22,400
from the criminal law

60
00:02:22,400 --> 00:02:24,080
and i'll go through it in the following

61
00:02:24,080 --> 00:02:25,920
slide

62
00:02:25,920 --> 00:02:28,560
now let's see principle number one

63
00:02:28,560 --> 00:02:29,200
malware

64
00:02:29,200 --> 00:02:32,239
a malware crime consists of action

65
00:02:32,239 --> 00:02:35,440
and targets in criminal law

66
00:02:35,440 --> 00:02:37,920
the definition of a crime consists of

67
00:02:37,920 --> 00:02:38,720
action

68
00:02:38,720 --> 00:02:43,120
and targets for example you steal money

69
00:02:43,120 --> 00:02:46,800
or kill people so with this principle in

70
00:02:46,800 --> 00:02:47,360
mind

71
00:02:47,360 --> 00:02:50,400
we developed this definition of a crime

72
00:02:50,400 --> 00:02:53,680
for android malware and the definition

73
00:02:53,680 --> 00:02:54,080
is

74
00:02:54,080 --> 00:02:57,440
the malware crime consists of action

75
00:02:57,440 --> 00:03:01,360
and targets for example steal photos

76
00:03:01,360 --> 00:03:05,760
or steal your banking account passwords

77
00:03:05,760 --> 00:03:08,640
so now let's see principle number two we

78
00:03:08,640 --> 00:03:09,760
consider

79
00:03:09,760 --> 00:03:12,319
the loss of fame is greater than the

80
00:03:12,319 --> 00:03:14,560
loss of wealth

81
00:03:14,560 --> 00:03:17,360
in a criminal law physical body injury

82
00:03:17,360 --> 00:03:18,879
is more serious than

83
00:03:18,879 --> 00:03:21,840
psychological injury so the principle we

84
00:03:21,840 --> 00:03:22,959
decoded here

85
00:03:22,959 --> 00:03:26,159
is when things are hard to recover

86
00:03:26,159 --> 00:03:29,519
we consider it a family with this

87
00:03:29,519 --> 00:03:31,040
principle decoded

88
00:03:31,040 --> 00:03:33,519
we developed our second principle we

89
00:03:33,519 --> 00:03:35,280
consider the loss of fame

90
00:03:35,280 --> 00:03:37,840
is greater than the loss of wealth

91
00:03:37,840 --> 00:03:40,640
because it's easier to make money back

92
00:03:40,640 --> 00:03:44,159
than rebuild your reputation

93
00:03:44,560 --> 00:03:46,480
okay now let's see principle number

94
00:03:46,480 --> 00:03:47,599
three

95
00:03:47,599 --> 00:03:51,920
arithmetic sequence in a criminal law

96
00:03:51,920 --> 00:03:54,159
when the number when a murderer is

97
00:03:54,159 --> 00:03:55,040
sentenced

98
00:03:55,040 --> 00:03:58,159
20 years in prison and a robber

99
00:03:58,159 --> 00:04:00,879
is sentenced seven years in prison for

100
00:04:00,879 --> 00:04:02,879
his crime

101
00:04:02,879 --> 00:04:05,599
white twenty and seven years wider

102
00:04:05,599 --> 00:04:06,799
number

103
00:04:06,799 --> 00:04:08,640
we found no obvious principles in the

104
00:04:08,640 --> 00:04:09,920
criminal law

105
00:04:09,920 --> 00:04:12,959
so we use arithmetic sequence to weight

106
00:04:12,959 --> 00:04:16,079
the penalty for of each frame

107
00:04:16,079 --> 00:04:19,600
for example the penalty weight of y1

108
00:04:19,600 --> 00:04:22,639
is 10 and y2 is 20

109
00:04:22,639 --> 00:04:26,960
y3 30 etc

110
00:04:26,960 --> 00:04:29,040
so now let's see the most important part

111
00:04:29,040 --> 00:04:30,880
of the scoring system

112
00:04:30,880 --> 00:04:34,479
we create an author theory

113
00:04:34,479 --> 00:04:36,479
which consists of three principles they

114
00:04:36,479 --> 00:04:38,479
are principle number four

115
00:04:38,479 --> 00:04:42,080
five and number six

116
00:04:42,080 --> 00:04:43,919
uh let's first look at principle number

117
00:04:43,919 --> 00:04:46,400
four the later the stage

118
00:04:46,400 --> 00:04:48,800
the more we are sure that the crime is

119
00:04:48,800 --> 00:04:50,400
practiced

120
00:04:50,400 --> 00:04:52,800
as mentioned in chapter four of taiwan

121
00:04:52,800 --> 00:04:54,320
criminal law

122
00:04:54,320 --> 00:04:56,639
each crime consists of a sequence of

123
00:04:56,639 --> 00:04:58,160
behaviors

124
00:04:58,160 --> 00:05:00,400
and those behaviors can be categorized

125
00:05:00,400 --> 00:05:03,120
in a specific order

126
00:05:03,120 --> 00:05:05,360
so let's make that let's take a murder

127
00:05:05,360 --> 00:05:07,360
for example

128
00:05:07,360 --> 00:05:10,720
in stage one determined it means

129
00:05:10,720 --> 00:05:13,919
somebody decided to kill someone

130
00:05:13,919 --> 00:05:17,199
and in stage two conspiracy

131
00:05:17,199 --> 00:05:20,720
it means he or she just started to make

132
00:05:20,720 --> 00:05:21,440
a plan

133
00:05:21,440 --> 00:05:24,880
for the murder and in stage three

134
00:05:24,880 --> 00:05:28,800
uh preparation it means buying steps for

135
00:05:28,800 --> 00:05:30,479
example weapons

136
00:05:30,479 --> 00:05:32,800
or arranging services for the murder

137
00:05:32,800 --> 00:05:34,560
plane

138
00:05:34,560 --> 00:05:38,880
and stage four start it means

139
00:05:38,880 --> 00:05:41,440
when things are all set the murderer

140
00:05:41,440 --> 00:05:42,320
takes action

141
00:05:42,320 --> 00:05:45,360
and is on the way to kill someone

142
00:05:45,360 --> 00:05:48,400
and the last stage stage five

143
00:05:48,400 --> 00:05:52,080
practice it means the murderer goes the

144
00:05:52,080 --> 00:05:52,960
mother does

145
00:05:52,960 --> 00:05:56,000
pull the trigger and shoot someone

146
00:05:56,000 --> 00:05:59,199
so as we can see here the later the

147
00:05:59,199 --> 00:05:59,919
stage

148
00:05:59,919 --> 00:06:02,160
the more we are sure that a crime is

149
00:06:02,160 --> 00:06:04,240
practiced

150
00:06:04,240 --> 00:06:06,400
so with the principle in mind we

151
00:06:06,400 --> 00:06:08,800
developed android malware crime order

152
00:06:08,800 --> 00:06:09,840
theory

153
00:06:09,840 --> 00:06:12,240
and in this theory we also have five

154
00:06:12,240 --> 00:06:14,000
stages for the crime

155
00:06:14,000 --> 00:06:16,800
for example if a maleware tries to send

156
00:06:16,800 --> 00:06:20,160
out your location data by using sms in

157
00:06:20,160 --> 00:06:21,680
stage one

158
00:06:21,680 --> 00:06:25,440
we will check if the related permission

159
00:06:25,440 --> 00:06:28,960
is requested by the malware and then

160
00:06:28,960 --> 00:06:31,520
we will check if the key native api is

161
00:06:31,520 --> 00:06:33,039
called

162
00:06:33,039 --> 00:06:36,400
and number three in stage three we will

163
00:06:36,400 --> 00:06:37,520
we will see

164
00:06:37,520 --> 00:06:40,639
if certain combination of native api

165
00:06:40,639 --> 00:06:44,240
exists and then we will check if the

166
00:06:44,240 --> 00:06:45,199
apis are

167
00:06:45,199 --> 00:06:49,039
called in a specific order and finally

168
00:06:49,039 --> 00:06:52,080
we check if the apis are handling the

169
00:06:52,080 --> 00:06:55,039
same register

170
00:06:55,919 --> 00:06:57,680
okay so now you can see from this

171
00:06:57,680 --> 00:07:00,400
picture this is a two dimension

172
00:07:00,400 --> 00:07:03,360
two dimensional map for android malware

173
00:07:03,360 --> 00:07:04,560
crime

174
00:07:04,560 --> 00:07:08,720
and for the crimes we put them in y-axis

175
00:07:08,720 --> 00:07:12,240
and for each crime we use x-axis

176
00:07:12,240 --> 00:07:14,400
to see the evidence we caught for the

177
00:07:14,400 --> 00:07:15,599
crime

178
00:07:15,599 --> 00:07:18,880
so x5 y1

179
00:07:18,880 --> 00:07:21,919
means in crime number one

180
00:07:21,919 --> 00:07:24,080
we have found native apis that are

181
00:07:24,080 --> 00:07:25,440
called in a correct

182
00:07:25,440 --> 00:07:28,840
sequence and they are handling the same

183
00:07:28,840 --> 00:07:32,240
register and x3y5 means

184
00:07:32,240 --> 00:07:34,800
in crime number five we have found a

185
00:07:34,800 --> 00:07:37,840
certain combination of native apis

186
00:07:37,840 --> 00:07:41,840
that is used in this apk

187
00:07:41,919 --> 00:07:43,680
so now let's look at the principle

188
00:07:43,680 --> 00:07:45,039
number five

189
00:07:45,039 --> 00:07:47,520
the more evidence we caught the more

190
00:07:47,520 --> 00:07:48,639
penalty weight

191
00:07:48,639 --> 00:07:52,319
we give so we give stage two more

192
00:07:52,319 --> 00:07:54,639
weights than stage one and stage three

193
00:07:54,639 --> 00:07:56,080
more weights than

194
00:07:56,080 --> 00:07:59,599
stage two etc

195
00:07:59,599 --> 00:08:02,560
okay uh principle number six

196
00:08:02,560 --> 00:08:04,720
proportional sequence

197
00:08:04,720 --> 00:08:07,440
as we decode it from the criminal law

198
00:08:07,440 --> 00:08:09,039
the later the stage

199
00:08:09,039 --> 00:08:11,360
the more we're sure that the crime is

200
00:08:11,360 --> 00:08:12,879
practiced

201
00:08:12,879 --> 00:08:15,120
so we consider proportional sequence for

202
00:08:15,120 --> 00:08:16,240
example

203
00:08:16,240 --> 00:08:19,199
2 to the power of n to present such

204
00:08:19,199 --> 00:08:22,800
principle in our scoring system

205
00:08:22,800 --> 00:08:26,560
all right principle number 7. crimes are

206
00:08:26,560 --> 00:08:28,639
independence events

207
00:08:28,639 --> 00:08:32,320
so for simplicity we assume crimes are

208
00:08:32,320 --> 00:08:35,039
independent events and penalty ways can

209
00:08:35,039 --> 00:08:38,240
be added up directly

210
00:08:38,240 --> 00:08:40,799
so this is an example of adding up to

211
00:08:40,799 --> 00:08:41,919
crimes

212
00:08:41,919 --> 00:08:44,560
in the malware we find two crimes there

213
00:08:44,560 --> 00:08:44,959
are

214
00:08:44,959 --> 00:08:46,640
stilling photos and stealing your

215
00:08:46,640 --> 00:08:48,480
banking account password

216
00:08:48,480 --> 00:08:50,640
so the calculation of a total penalty

217
00:08:50,640 --> 00:08:52,880
weight is quite simple

218
00:08:52,880 --> 00:08:55,279
for each crime we use penalty weight of

219
00:08:55,279 --> 00:08:57,360
crime to multiply

220
00:08:57,360 --> 00:09:00,080
proportion of court evidence and add up

221
00:09:00,080 --> 00:09:03,360
the results of the two

222
00:09:03,360 --> 00:09:05,760
the last principle principle number

223
00:09:05,760 --> 00:09:06,640
eight

224
00:09:06,640 --> 00:09:09,760
threshold generate system after

225
00:09:09,760 --> 00:09:11,920
calculating the total penalty weight of

226
00:09:11,920 --> 00:09:15,279
uh for the crime for the malware we need

227
00:09:15,279 --> 00:09:16,880
to have threat level

228
00:09:16,880 --> 00:09:20,000
threshold so that we can tell which

229
00:09:20,000 --> 00:09:23,040
threat level does malware fit in

230
00:09:23,040 --> 00:09:26,399
unfortunately we can't find them

231
00:09:26,399 --> 00:09:29,519
we can't find them in a criminal law

232
00:09:29,519 --> 00:09:32,959
but we know we need to design a threat

233
00:09:32,959 --> 00:09:36,000
a threshold generate system for that not

234
00:09:36,000 --> 00:09:37,440
just give any number

235
00:09:37,440 --> 00:09:40,480
by intuition

236
00:09:40,800 --> 00:09:44,160
so we decide that threshold for each

237
00:09:44,160 --> 00:09:44,640
level

238
00:09:44,640 --> 00:09:48,320
is the sum of the same proportion

239
00:09:48,320 --> 00:09:51,760
of cod evidence multiplies

240
00:09:51,760 --> 00:09:55,440
penalty ways of crimes yeah we know

241
00:09:55,440 --> 00:09:58,000
it's not a perfect one but we're sure

242
00:09:58,000 --> 00:09:59,760
that we build a foundation

243
00:09:59,760 --> 00:10:04,079
for future optimization

244
00:10:04,079 --> 00:10:05,760
all right now let's talk about the

245
00:10:05,760 --> 00:10:08,160
design logic of dalvik by co-loader and

246
00:10:08,160 --> 00:10:08,959
jin way

247
00:10:08,959 --> 00:10:12,399
keep a take care of this part

248
00:10:14,880 --> 00:10:17,440
hi everyone my name is jin wei and i

249
00:10:17,440 --> 00:10:18,000
will take

250
00:10:18,000 --> 00:10:22,160
care of this part our delphi by code

251
00:10:22,160 --> 00:10:22,880
loader

252
00:10:22,880 --> 00:10:25,920
is actually the implementation of the

253
00:10:25,920 --> 00:10:29,360
android malware crime odor theory

254
00:10:29,360 --> 00:10:33,360
we interpret every stage of the theory

255
00:10:33,360 --> 00:10:36,480
there are five stages the first three

256
00:10:36,480 --> 00:10:37,200
days

257
00:10:37,200 --> 00:10:40,320
are easy we simply use apis

258
00:10:40,320 --> 00:10:43,040
in another open source tool android

259
00:10:43,040 --> 00:10:43,680
guide

260
00:10:43,680 --> 00:10:47,839
to implement the first three stages

261
00:10:47,839 --> 00:10:50,959
as i just mentioned the implementation

262
00:10:50,959 --> 00:10:54,160
of the first three days are easy

263
00:10:54,160 --> 00:10:57,360
but in stage four we need to do a little

264
00:10:57,360 --> 00:10:58,880
bit more

265
00:10:58,880 --> 00:11:02,079
so before the implementation we need to

266
00:11:02,079 --> 00:11:02,640
know

267
00:11:02,640 --> 00:11:07,040
what does stage 4 do in stage 4

268
00:11:07,040 --> 00:11:10,480
we find the calling sequence of native

269
00:11:10,480 --> 00:11:14,000
apis and check if they are code

270
00:11:14,000 --> 00:11:17,760
in a specific order for example

271
00:11:17,760 --> 00:11:20,560
if a malware sends out your location

272
00:11:20,560 --> 00:11:21,440
data

273
00:11:21,440 --> 00:11:24,480
by sns then first

274
00:11:24,480 --> 00:11:27,680
it will call native api get cell

275
00:11:27,680 --> 00:11:28,720
location

276
00:11:28,720 --> 00:11:32,480
to get your location data and then

277
00:11:32,480 --> 00:11:36,399
code native api send text message

278
00:11:36,399 --> 00:11:41,360
to send your location data by sns

279
00:11:41,360 --> 00:11:44,399
normally native apis are work

280
00:11:44,399 --> 00:11:47,440
in functions so we trash back

281
00:11:47,440 --> 00:11:50,000
to see which function is course

282
00:11:50,000 --> 00:11:50,959
reference

283
00:11:50,959 --> 00:11:54,880
from the native apis and we call those

284
00:11:54,880 --> 00:11:58,160
functions the parent function

285
00:11:58,160 --> 00:12:01,279
and we will keep tracing back until we

286
00:12:01,279 --> 00:12:02,000
find

287
00:12:02,000 --> 00:12:05,040
the mutual parent function for both

288
00:12:05,040 --> 00:12:09,680
the native apis here is the example

289
00:12:09,680 --> 00:12:12,880
send text message is called by

290
00:12:12,880 --> 00:12:17,200
send sns which is the parent function

291
00:12:17,200 --> 00:12:20,880
of send text message and guest cell

292
00:12:20,880 --> 00:12:21,680
location

293
00:12:21,680 --> 00:12:25,360
is called by get location which is

294
00:12:25,360 --> 00:12:27,920
the parent function of guest cell

295
00:12:27,920 --> 00:12:29,440
location

296
00:12:29,440 --> 00:12:32,560
and if we keep tracing back we will see

297
00:12:32,560 --> 00:12:33,120
that

298
00:12:33,120 --> 00:12:37,360
both send ss and get location

299
00:12:37,360 --> 00:12:40,480
shares the same parent function send

300
00:12:40,480 --> 00:12:42,880
messaging

301
00:12:42,880 --> 00:12:45,760
and after we find the mutual parent

302
00:12:45,760 --> 00:12:46,800
function

303
00:12:46,800 --> 00:12:50,160
we will scan through a small united code

304
00:12:50,160 --> 00:12:53,760
of the mutual parent function and check

305
00:12:53,760 --> 00:12:56,800
which function is called first

306
00:12:56,800 --> 00:13:00,079
so this is the small line code of same

307
00:13:00,079 --> 00:13:01,519
message

308
00:13:01,519 --> 00:13:04,880
we can see that get location is called

309
00:13:04,880 --> 00:13:05,760
first

310
00:13:05,760 --> 00:13:09,680
to get location data of the cell phone

311
00:13:09,680 --> 00:13:13,440
and the send ss is code to send out the

312
00:13:13,440 --> 00:13:16,320
location data

313
00:13:16,320 --> 00:13:20,320
in stage 4 we found out that our design

314
00:13:20,320 --> 00:13:23,440
can also overcome the obfuscation

315
00:13:23,440 --> 00:13:24,560
techniques

316
00:13:24,560 --> 00:13:27,600
used by the malware when applying

317
00:13:27,600 --> 00:13:29,839
obfuscation techniques

318
00:13:29,839 --> 00:13:34,160
function except native apis are renamed

319
00:13:34,160 --> 00:13:37,519
this has made the decompile source core

320
00:13:37,519 --> 00:13:40,959
hard to read for human but machine can

321
00:13:40,959 --> 00:13:42,399
still run the code

322
00:13:42,399 --> 00:13:45,440
because the login of the code remains

323
00:13:45,440 --> 00:13:47,040
the same

324
00:13:47,040 --> 00:13:49,920
here is the example when applying

325
00:13:49,920 --> 00:13:52,240
obfuscation techniques

326
00:13:52,240 --> 00:13:55,600
native api send text message

327
00:13:55,600 --> 00:13:59,920
is called by function k and function k

328
00:13:59,920 --> 00:14:04,079
is code by function f the alternative

329
00:14:04,079 --> 00:14:07,519
api guess cell location is code

330
00:14:07,519 --> 00:14:10,560
by function e and both function

331
00:14:10,560 --> 00:14:15,040
e and f shares the same parent function

332
00:14:15,040 --> 00:14:18,079
a you see if you start

333
00:14:18,079 --> 00:14:21,360
reading the decompile source code of a

334
00:14:21,360 --> 00:14:24,320
it will be hard to figure out what is

335
00:14:24,320 --> 00:14:25,920
going on there

336
00:14:25,920 --> 00:14:29,839
and by the way since our goal is to find

337
00:14:29,839 --> 00:14:32,240
the mutual parent function

338
00:14:32,240 --> 00:14:35,440
so it doesn't matter how many layers the

339
00:14:35,440 --> 00:14:36,160
wrappers

340
00:14:36,160 --> 00:14:39,600
are now let's see

341
00:14:39,600 --> 00:14:42,639
the implementation of stage five

342
00:14:42,639 --> 00:14:46,240
yes this is the most important part

343
00:14:46,240 --> 00:14:49,600
in stage five we need to confirm that

344
00:14:49,600 --> 00:14:53,199
if the native apis are handling the same

345
00:14:53,199 --> 00:14:54,560
register

346
00:14:54,560 --> 00:14:58,720
let's see let's use the send example

347
00:14:58,720 --> 00:15:02,079
send out your location data by using

348
00:15:02,079 --> 00:15:06,240
sns so when native api

349
00:15:06,240 --> 00:15:10,000
gets our location is code it will return

350
00:15:10,000 --> 00:15:14,160
the location data of the cell phone

351
00:15:14,160 --> 00:15:18,160
and what we do in stage five is to check

352
00:15:18,160 --> 00:15:21,519
if if the outer native api

353
00:15:21,519 --> 00:15:24,160
send text messaging sends out the

354
00:15:24,160 --> 00:15:26,560
location data returned

355
00:15:26,560 --> 00:15:29,759
from guest cell location

356
00:15:29,759 --> 00:15:33,120
so in stage 5 we simulate

357
00:15:33,120 --> 00:15:37,360
the cpu operation we read line by line

358
00:15:37,360 --> 00:15:40,480
of the small light source code and

359
00:15:40,480 --> 00:15:44,720
operate like cpus to get two things

360
00:15:44,720 --> 00:15:48,480
first the value of every register

361
00:15:48,480 --> 00:15:51,680
second the information like functions

362
00:15:51,680 --> 00:15:55,920
who have operate the cell register

363
00:15:55,920 --> 00:15:58,560
to make this happen we create a

364
00:15:58,560 --> 00:16:00,959
self-defined data type

365
00:16:00,959 --> 00:16:04,399
we call as register object

366
00:16:04,399 --> 00:16:07,440
in each register object we store

367
00:16:07,440 --> 00:16:11,040
three kinds of information number one

368
00:16:11,040 --> 00:16:14,880
we register n number two the value

369
00:16:14,880 --> 00:16:17,839
of the register number three the

370
00:16:17,839 --> 00:16:18,480
function

371
00:16:18,480 --> 00:16:21,920
could use this register let's see the

372
00:16:21,920 --> 00:16:23,440
example

373
00:16:23,440 --> 00:16:27,199
so register nan is v7

374
00:16:27,199 --> 00:16:29,920
and the value of the register is the

375
00:16:29,920 --> 00:16:31,360
string

376
00:16:31,360 --> 00:16:34,399
and the string appends the value of

377
00:16:34,399 --> 00:16:36,959
string 1. and the result

378
00:16:36,959 --> 00:16:40,320
of function1 and then we

379
00:16:40,320 --> 00:16:43,440
we can see that the register is used

380
00:16:43,440 --> 00:16:48,320
as the input resource of the function2

381
00:16:48,320 --> 00:16:51,279
by the way when filling the value of

382
00:16:51,279 --> 00:16:52,079
used by

383
00:16:52,079 --> 00:16:55,680
which function in a register object

384
00:16:55,680 --> 00:16:58,959
we extend every register

385
00:16:58,959 --> 00:17:02,639
by cross-referencing our register object

386
00:17:02,639 --> 00:17:06,240
in the table so for example

387
00:17:06,240 --> 00:17:10,400
by course referencing we know that va

388
00:17:10,400 --> 00:17:13,919
is a string called user location

389
00:17:13,919 --> 00:17:17,359
and v3 is a function called

390
00:17:17,359 --> 00:17:21,280
get location as you can see in the lower

391
00:17:21,280 --> 00:17:22,480
right corner

392
00:17:22,480 --> 00:17:26,079
the result of get location is append

393
00:17:26,079 --> 00:17:29,520
to the string user location

394
00:17:29,520 --> 00:17:32,880
and the new string is sent out by using

395
00:17:32,880 --> 00:17:36,000
function sent as ns

396
00:17:36,000 --> 00:17:40,400
in other words the value of register v7

397
00:17:40,400 --> 00:17:43,520
is generated by using function

398
00:17:43,520 --> 00:17:47,440
get location which has native api 1

399
00:17:47,440 --> 00:17:50,640
in it and the value is used

400
00:17:50,640 --> 00:17:53,760
as the input for function sam

401
00:17:53,760 --> 00:17:57,440
sns which has native api 2

402
00:17:57,440 --> 00:18:00,720
in it so now we prove that

403
00:18:00,720 --> 00:18:03,919
by using the register objects we can

404
00:18:03,919 --> 00:18:07,440
check if the apis are handling the send

405
00:18:07,440 --> 00:18:09,200
register

406
00:18:09,200 --> 00:18:12,720
so after we scan through the source code

407
00:18:12,720 --> 00:18:17,039
we produce lots of register objects

408
00:18:17,039 --> 00:18:19,679
and those register objects will be

409
00:18:19,679 --> 00:18:20,480
organized

410
00:18:20,480 --> 00:18:24,000
with a two dimensional python list

411
00:18:24,000 --> 00:18:28,160
it is a singular idea like hash table we

412
00:18:28,160 --> 00:18:29,039
use it

413
00:18:29,039 --> 00:18:33,520
to boost on the re and right of the list

414
00:18:33,520 --> 00:18:36,799
so now let's see the table

415
00:18:36,799 --> 00:18:40,400
as you can see here register v4

416
00:18:40,400 --> 00:18:44,240
has three register objects that means

417
00:18:44,240 --> 00:18:47,520
in a source code we scan v4

418
00:18:47,520 --> 00:18:50,559
was used three times and

419
00:18:50,559 --> 00:18:54,080
every time when it was used we store

420
00:18:54,080 --> 00:18:57,360
the present value of the register

421
00:18:57,360 --> 00:19:00,240
and the function who use it if there's

422
00:19:00,240 --> 00:19:01,440
one

423
00:19:01,440 --> 00:19:04,240
so basically the whole table is the

424
00:19:04,240 --> 00:19:05,280
history

425
00:19:05,280 --> 00:19:08,880
of the registers so

426
00:19:08,880 --> 00:19:11,600
when we finish constructing the table we

427
00:19:11,600 --> 00:19:12,160
then

428
00:19:12,160 --> 00:19:15,120
get through all register objects in a

429
00:19:15,120 --> 00:19:16,080
table

430
00:19:16,080 --> 00:19:20,080
to check if the native apis are handling

431
00:19:20,080 --> 00:19:24,799
the send register so now let's see

432
00:19:24,799 --> 00:19:28,320
how to use clock engine to analyze

433
00:19:28,320 --> 00:19:31,840
the malware now let's get back

434
00:19:31,840 --> 00:19:34,480
to queen eu

435
00:19:37,039 --> 00:19:40,160
hi it's me again

436
00:19:40,160 --> 00:19:42,799
so in this section we prepare two

437
00:19:42,799 --> 00:19:44,000
malware

438
00:19:44,000 --> 00:19:46,960
one is non-obfuscated and the other one

439
00:19:46,960 --> 00:19:47,280
is

440
00:19:47,280 --> 00:19:50,400
obfuscated and for each

441
00:19:50,400 --> 00:19:52,799
and for each malware we will show how we

442
00:19:52,799 --> 00:19:54,559
detect the behavior

443
00:19:54,559 --> 00:19:59,280
of the malware with the detection rule

444
00:19:59,280 --> 00:20:01,760
now let's look at the first malware this

445
00:20:01,760 --> 00:20:02,679
is a

446
00:20:02,679 --> 00:20:05,520
non-obfuscated one and we will use the

447
00:20:05,520 --> 00:20:08,000
rule in quark engine to detect

448
00:20:08,000 --> 00:20:09,919
whether if the malware sends out cell

449
00:20:09,919 --> 00:20:11,440
phone location data

450
00:20:11,440 --> 00:20:14,559
by using sms

451
00:20:14,720 --> 00:20:17,520
so this is the detailed report of quark

452
00:20:17,520 --> 00:20:18,320
engine

453
00:20:18,320 --> 00:20:20,720
in this report the engine shows the

454
00:20:20,720 --> 00:20:22,159
detection results of

455
00:20:22,159 --> 00:20:24,720
one single malware behavior or you can

456
00:20:24,720 --> 00:20:25,440
say

457
00:20:25,440 --> 00:20:28,960
one single memory crime so for example

458
00:20:28,960 --> 00:20:30,720
we try to find if the malware

459
00:20:30,720 --> 00:20:34,559
send out your location data by using sms

460
00:20:34,559 --> 00:20:36,960
in this report we list out the evidence

461
00:20:36,960 --> 00:20:39,280
we found in each stage of the android

462
00:20:39,280 --> 00:20:41,760
malware crime order theory

463
00:20:41,760 --> 00:20:44,320
and this report shows we find evidence

464
00:20:44,320 --> 00:20:45,840
in every stage

465
00:20:45,840 --> 00:20:47,760
which means we have 100 percent of

466
00:20:47,760 --> 00:20:49,840
confidence that the malware has this

467
00:20:49,840 --> 00:20:51,280
behavior

468
00:20:51,280 --> 00:20:54,480
so let's see in stage one permissions

469
00:20:54,480 --> 00:20:55,200
like

470
00:20:55,200 --> 00:20:59,280
send sms access course locations

471
00:20:59,280 --> 00:21:02,480
and find locations are requested in the

472
00:21:02,480 --> 00:21:03,760
second stage

473
00:21:03,760 --> 00:21:06,559
key native apis like get cell locations

474
00:21:06,559 --> 00:21:06,960
and

475
00:21:06,960 --> 00:21:10,960
send text messages are used in stage 3

476
00:21:10,960 --> 00:21:13,120
we find certain combinations of native

477
00:21:13,120 --> 00:21:14,720
api exist

478
00:21:14,720 --> 00:21:16,960
and in stage four we found out that

479
00:21:16,960 --> 00:21:18,640
functions like send message

480
00:21:18,640 --> 00:21:21,840
and do byte the apis are called

481
00:21:21,840 --> 00:21:25,039
in the right sequence and in stage five

482
00:21:25,039 --> 00:21:25,840
in function

483
00:21:25,840 --> 00:21:28,720
send message we found out that those

484
00:21:28,720 --> 00:21:30,159
apis are handling

485
00:21:30,159 --> 00:21:34,640
the same register so now let's think

486
00:21:34,640 --> 00:21:36,960
if you're analyzing this malware and you

487
00:21:36,960 --> 00:21:39,360
want to trace the compile source code to

488
00:21:39,360 --> 00:21:40,640
see the evidence

489
00:21:40,640 --> 00:21:43,840
how do you do it our suggestion is you

490
00:21:43,840 --> 00:21:45,600
start reading the report

491
00:21:45,600 --> 00:21:48,640
backwards that means you start from

492
00:21:48,640 --> 00:21:50,240
stage five

493
00:21:50,240 --> 00:21:52,799
for example in stage five we know that

494
00:21:52,799 --> 00:21:54,000
inside the function

495
00:21:54,000 --> 00:21:56,559
of send message it has two functions

496
00:21:56,559 --> 00:21:58,000
that contains the two native

497
00:21:58,000 --> 00:22:01,039
api respectively and are handling the

498
00:22:01,039 --> 00:22:02,960
same register

499
00:22:02,960 --> 00:22:06,000
so you start to locate function send

500
00:22:06,000 --> 00:22:06,799
message

501
00:22:06,799 --> 00:22:10,320
in a decompiled source code and in stage

502
00:22:10,320 --> 00:22:11,840
four we know that

503
00:22:11,840 --> 00:22:14,159
those two those two functions are called

504
00:22:14,159 --> 00:22:15,840
in the right sequence

505
00:22:15,840 --> 00:22:18,000
so we can start to find functions that

506
00:22:18,000 --> 00:22:19,039
contain the

507
00:22:19,039 --> 00:22:21,679
contains the native apis and check if

508
00:22:21,679 --> 00:22:22,960
they are greedy called

509
00:22:22,960 --> 00:22:26,000
in the right sequence the information

510
00:22:26,000 --> 00:22:27,840
of the two functions and the sequence

511
00:22:27,840 --> 00:22:29,679
will be shown in the next version of

512
00:22:29,679 --> 00:22:32,320
quark engine

513
00:22:32,320 --> 00:22:34,799
and recently we have developed a new

514
00:22:34,799 --> 00:22:35,760
feature

515
00:22:35,760 --> 00:22:38,320
a call graph for high potential

516
00:22:38,320 --> 00:22:40,480
malicious activity

517
00:22:40,480 --> 00:22:43,280
i call it the google map for malware

518
00:22:43,280 --> 00:22:45,039
analysis

519
00:22:45,039 --> 00:22:48,320
now let's see on top of the graph

520
00:22:48,320 --> 00:22:51,120
we start our journey from the mutual

521
00:22:51,120 --> 00:22:52,799
parent function

522
00:22:52,799 --> 00:22:55,760
and then according to the map we can see

523
00:22:55,760 --> 00:22:56,640
we can see it

524
00:22:56,640 --> 00:22:59,600
clearly that which function wrapped the

525
00:22:59,600 --> 00:23:02,080
native apis

526
00:23:02,080 --> 00:23:04,880
and calling and the calling sequence of

527
00:23:04,880 --> 00:23:06,320
these functions

528
00:23:06,320 --> 00:23:08,640
wow this is amazing isn't it so now

529
00:23:08,640 --> 00:23:10,400
let's start the journey

530
00:23:10,400 --> 00:23:13,600
we start from uh send message

531
00:23:13,600 --> 00:23:15,520
the mutual parent function of the key

532
00:23:15,520 --> 00:23:17,360
native apis

533
00:23:17,360 --> 00:23:19,919
and we can see in this map it first

534
00:23:19,919 --> 00:23:21,440
called two

535
00:23:21,440 --> 00:23:25,280
first first call function get location

536
00:23:25,280 --> 00:23:29,360
and then it calls function send sms

537
00:23:29,360 --> 00:23:32,799
and in function get location it calls

538
00:23:32,799 --> 00:23:36,159
native api get cell location

539
00:23:36,159 --> 00:23:38,640
so let's see the other wrapped function

540
00:23:38,640 --> 00:23:40,159
send sms

541
00:23:40,159 --> 00:23:43,039
in this function it calls native api

542
00:23:43,039 --> 00:23:45,039
send text message

543
00:23:45,039 --> 00:23:48,159
now we have the road map and let's read

544
00:23:48,159 --> 00:23:51,360
the source code

545
00:23:51,360 --> 00:23:54,080
let's locate function send message and

546
00:23:54,080 --> 00:23:56,400
we found out two functions that contains

547
00:23:56,400 --> 00:23:58,080
the two native apis

548
00:23:58,080 --> 00:24:01,360
respectively there are sent sms and get

549
00:24:01,360 --> 00:24:02,480
location

550
00:24:02,480 --> 00:24:04,240
and if we dive into the source code of

551
00:24:04,240 --> 00:24:06,559
the function get location

552
00:24:06,559 --> 00:24:09,120
we will see that it contains native api

553
00:24:09,120 --> 00:24:10,880
get cell location

554
00:24:10,880 --> 00:24:13,200
and if we dive in the source code of

555
00:24:13,200 --> 00:24:14,240
function

556
00:24:14,240 --> 00:24:17,360
send that send sms we will see that it

557
00:24:17,360 --> 00:24:19,279
contains native api

558
00:24:19,279 --> 00:24:23,039
send text message so the code here

559
00:24:23,039 --> 00:24:25,840
means it first collect your cell phone

560
00:24:25,840 --> 00:24:27,200
location data

561
00:24:27,200 --> 00:24:31,360
and send it out through sms

562
00:24:31,440 --> 00:24:33,520
so now let's dive into the source code

563
00:24:33,520 --> 00:24:34,480
of

564
00:24:34,480 --> 00:24:37,840
function get location as you can see in

565
00:24:37,840 --> 00:24:38,880
the source code

566
00:24:38,880 --> 00:24:42,000
it tries to call native api get sale

567
00:24:42,000 --> 00:24:42,960
location

568
00:24:42,960 --> 00:24:46,000
and return this information at the end

569
00:24:46,000 --> 00:24:49,760
of the code and now let's dive into the

570
00:24:49,760 --> 00:24:50,880
source code

571
00:24:50,880 --> 00:24:55,200
of function send sms native api

572
00:24:55,200 --> 00:24:57,760
send text message is used to send out

573
00:24:57,760 --> 00:24:59,679
the location information

574
00:24:59,679 --> 00:25:03,039
it's quite simple isn't it now let's

575
00:25:03,039 --> 00:25:04,720
look at the second malware

576
00:25:04,720 --> 00:25:08,080
this is a and obfuscated one

577
00:25:08,080 --> 00:25:10,240
we will use the rule in quark engine to

578
00:25:10,240 --> 00:25:11,120
find whether

579
00:25:11,120 --> 00:25:13,919
if the malware detect wi-fi hotspot by

580
00:25:13,919 --> 00:25:15,039
gathering information

581
00:25:15,039 --> 00:25:18,240
like active network info and

582
00:25:18,240 --> 00:25:21,520
cell phone location okay so

583
00:25:21,520 --> 00:25:24,640
as a malware analysis we need to read

584
00:25:24,640 --> 00:25:25,520
the report

585
00:25:25,520 --> 00:25:29,039
backwards as you can see in stage five

586
00:25:29,039 --> 00:25:31,279
there are functions like p dot a

587
00:25:31,279 --> 00:25:34,799
at view the c and af run

588
00:25:34,799 --> 00:25:36,640
and those functions has two functions

589
00:25:36,640 --> 00:25:38,880
that contains the native apis

590
00:25:38,880 --> 00:25:41,279
respectively and they're handling the

591
00:25:41,279 --> 00:25:43,440
same register

592
00:25:43,440 --> 00:25:46,000
and in stage four these two functions

593
00:25:46,000 --> 00:25:46,799
are

594
00:25:46,799 --> 00:25:49,279
are also called in the right sequence in

595
00:25:49,279 --> 00:25:50,080
function

596
00:25:50,080 --> 00:25:54,000
p dot a at w dot c and af dot run

597
00:25:54,000 --> 00:25:56,559
so according to the reports we can see

598
00:25:56,559 --> 00:25:58,960
that the malware has the behavior of

599
00:25:58,960 --> 00:26:01,440
wi-fi hotspot detection in three parts

600
00:26:01,440 --> 00:26:02,960
of the source code

601
00:26:02,960 --> 00:26:05,440
and we pick and we can pick any parts

602
00:26:05,440 --> 00:26:07,039
for further analysis

603
00:26:07,039 --> 00:26:11,279
so we pick uh function p a

604
00:26:11,279 --> 00:26:14,400
so again let's start a journey let's

605
00:26:14,400 --> 00:26:14,880
choose

606
00:26:14,880 --> 00:26:18,000
parent function p a

607
00:26:18,000 --> 00:26:20,880
as we can see in the map it first calls

608
00:26:20,880 --> 00:26:21,520
function

609
00:26:21,520 --> 00:26:24,559
ap dot a and then the cost function

610
00:26:24,559 --> 00:26:27,840
f dot f and in the function ap dot a

611
00:26:27,840 --> 00:26:31,039
it calls native api get active network

612
00:26:31,039 --> 00:26:32,320
info

613
00:26:32,320 --> 00:26:35,039
and let's look another wrapped function

614
00:26:35,039 --> 00:26:36,640
f dot f

615
00:26:36,640 --> 00:26:39,760
in this function it calls native api get

616
00:26:39,760 --> 00:26:41,520
cell location

617
00:26:41,520 --> 00:26:43,679
so now we know the roadmap to trace the

618
00:26:43,679 --> 00:26:45,840
code

619
00:26:45,840 --> 00:26:49,120
okay so let's locate function p

620
00:26:49,120 --> 00:26:51,919
a and we found out that two functions

621
00:26:51,919 --> 00:26:52,480
that

622
00:26:52,480 --> 00:26:54,559
contains the two native apis

623
00:26:54,559 --> 00:26:56,400
respectively

624
00:26:56,400 --> 00:26:59,760
there are ap dot a and f.f and if we

625
00:26:59,760 --> 00:27:01,840
dive into the source code of function

626
00:27:01,840 --> 00:27:04,880
of ap dot a we will see that it contains

627
00:27:04,880 --> 00:27:06,080
native api

628
00:27:06,080 --> 00:27:09,200
get active network info and if we dive

629
00:27:09,200 --> 00:27:11,039
into the source code of function

630
00:27:11,039 --> 00:27:13,520
f.a.f we will see that it contains

631
00:27:13,520 --> 00:27:14,640
native api

632
00:27:14,640 --> 00:27:18,159
get cell location so the code here means

633
00:27:18,159 --> 00:27:20,080
after collecting information from

634
00:27:20,080 --> 00:27:21,440
function ap dot a

635
00:27:21,440 --> 00:27:24,799
and aff.af they send the information as

636
00:27:24,799 --> 00:27:25,039
an

637
00:27:25,039 --> 00:27:29,360
input for function am dot a

638
00:27:29,360 --> 00:27:31,120
so now let's dive into the source code

639
00:27:31,120 --> 00:27:33,679
of function a ap dot a

640
00:27:33,679 --> 00:27:35,520
as you can see in the source code it

641
00:27:35,520 --> 00:27:36,720
tries to call

642
00:27:36,720 --> 00:27:39,840
native api get active network info

643
00:27:39,840 --> 00:27:42,640
and return the related information at

644
00:27:42,640 --> 00:27:44,720
some point

645
00:27:44,720 --> 00:27:46,480
and now let's dive into the source code

646
00:27:46,480 --> 00:27:48,480
of af.aft

647
00:27:48,480 --> 00:27:51,440
native api get cell location is used to

648
00:27:51,440 --> 00:27:54,080
get the cell phone location data

649
00:27:54,080 --> 00:27:56,080
and this is and this information is

650
00:27:56,080 --> 00:27:58,000
processed with some other screens

651
00:27:58,000 --> 00:28:01,200
at the end of this function it returns

652
00:28:01,200 --> 00:28:04,000
the stream with information

653
00:28:04,000 --> 00:28:06,640
as mentioned earlier after collecting

654
00:28:06,640 --> 00:28:08,080
information from from

655
00:28:08,080 --> 00:28:11,840
from function ap dot a and after rf

656
00:28:11,840 --> 00:28:14,720
they use the information as an input for

657
00:28:14,720 --> 00:28:15,360
function

658
00:28:15,360 --> 00:28:19,840
am.a and we notice one thing

659
00:28:19,840 --> 00:28:22,399
that function am dot a used by the rate

660
00:28:22,399 --> 00:28:24,080
output stream as one of its

661
00:28:24,080 --> 00:28:26,960
input parameter and we know when seen by

662
00:28:26,960 --> 00:28:28,159
the rate upper string

663
00:28:28,159 --> 00:28:30,000
it means the function is probably trying

664
00:28:30,000 --> 00:28:31,200
to write the data

665
00:28:31,200 --> 00:28:34,480
into the file this is amazing isn't it

666
00:28:34,480 --> 00:28:37,039
so with quack engine malware analysis

667
00:28:37,039 --> 00:28:38,399
can really boost out

668
00:28:38,399 --> 00:28:42,240
their productivity okay so now i will

669
00:28:42,240 --> 00:28:42,960
introduce

670
00:28:42,960 --> 00:28:45,440
our detection rule generates generate

671
00:28:45,440 --> 00:28:47,279
strategy

672
00:28:47,279 --> 00:28:48,720
so why do we need to develop the

673
00:28:48,720 --> 00:28:50,960
detection rules generate strategy

674
00:28:50,960 --> 00:28:54,240
because to make our engine practical

675
00:28:54,240 --> 00:28:56,640
and easy to use we need to have more

676
00:28:56,640 --> 00:28:58,320
detection rules

677
00:28:58,320 --> 00:29:00,960
however the speed of rule generated by

678
00:29:00,960 --> 00:29:01,440
human

679
00:29:01,440 --> 00:29:05,039
is quite slow and human generated rule

680
00:29:05,039 --> 00:29:08,960
is subjected to his or her experiences

681
00:29:08,960 --> 00:29:12,000
of malware analysis

682
00:29:12,000 --> 00:29:14,159
so we developed a rule generate strategy

683
00:29:14,159 --> 00:29:15,440
to prove to boost

684
00:29:15,440 --> 00:29:19,200
up the production of detection rules

685
00:29:19,200 --> 00:29:21,440
since our goal is to find all kinds of

686
00:29:21,440 --> 00:29:23,279
behavior in the malware

687
00:29:23,279 --> 00:29:25,679
so if we use permissions and negative

688
00:29:25,679 --> 00:29:27,840
apis to generate all

689
00:29:27,840 --> 00:29:30,399
possible rules we will have an amazing

690
00:29:30,399 --> 00:29:31,120
amount

691
00:29:31,120 --> 00:29:34,080
of rules after generating the rules we

692
00:29:34,080 --> 00:29:36,159
then use park engine to find

693
00:29:36,159 --> 00:29:38,960
the intersection between those amazing

694
00:29:38,960 --> 00:29:40,000
amounts of rules

695
00:29:40,000 --> 00:29:42,799
and the malware we prepared in other

696
00:29:42,799 --> 00:29:43,279
words

697
00:29:43,279 --> 00:29:46,240
we find rules that matched the malware

698
00:29:46,240 --> 00:29:47,279
behaviors

699
00:29:47,279 --> 00:29:49,520
however this is not a good way to

700
00:29:49,520 --> 00:29:51,039
generate detection rules

701
00:29:51,039 --> 00:29:54,960
because it's time and resource consuming

702
00:29:54,960 --> 00:29:57,760
so we develop a seven step rule generate

703
00:29:57,760 --> 00:29:59,200
strategy

704
00:29:59,200 --> 00:30:02,320
step one we crawl down all native api

705
00:30:02,320 --> 00:30:05,360
information on android official api

706
00:30:05,360 --> 00:30:06,480
reference

707
00:30:06,480 --> 00:30:09,520
for example this is the native api

708
00:30:09,520 --> 00:30:12,640
information of send text message you can

709
00:30:12,640 --> 00:30:14,720
see the input parameters return

710
00:30:14,720 --> 00:30:18,399
values and the description of this api

711
00:30:18,399 --> 00:30:21,200
okay step two we did a little bit

712
00:30:21,200 --> 00:30:22,000
modification

713
00:30:22,000 --> 00:30:24,880
to our engine we ignore the permission

714
00:30:24,880 --> 00:30:27,200
checks in stage one of the android

715
00:30:27,200 --> 00:30:28,240
android

716
00:30:28,240 --> 00:30:31,039
malware crime author theory and step

717
00:30:31,039 --> 00:30:31,600
three

718
00:30:31,600 --> 00:30:34,720
we find all kinds of api combination

719
00:30:34,720 --> 00:30:36,880
and generate rules without permission

720
00:30:36,880 --> 00:30:38,880
information

721
00:30:38,880 --> 00:30:42,320
and instead step four we use the

722
00:30:42,320 --> 00:30:43,840
modified quark engine

723
00:30:43,840 --> 00:30:46,240
to find the intersection of the rules

724
00:30:46,240 --> 00:30:48,159
and the malwares

725
00:30:48,159 --> 00:30:50,559
we call rules in the intersection the

726
00:30:50,559 --> 00:30:52,960
first stage verified rules

727
00:30:52,960 --> 00:30:54,960
in other words these rules need to be

728
00:30:54,960 --> 00:30:57,360
verified again

729
00:30:57,360 --> 00:30:59,360
and since we don't need to generate

730
00:30:59,360 --> 00:31:01,519
rules with permissions and verify the

731
00:31:01,519 --> 00:31:03,279
permissions in quake engine

732
00:31:03,279 --> 00:31:05,600
the whole process of broad production

733
00:31:05,600 --> 00:31:08,159
speeds up

734
00:31:08,159 --> 00:31:10,880
in stage five we try to generate rules

735
00:31:10,880 --> 00:31:12,640
with permissions

736
00:31:12,640 --> 00:31:14,960
inside the intersection we have first

737
00:31:14,960 --> 00:31:16,240
stage rules

738
00:31:16,240 --> 00:31:19,120
first stage verified rules matched with

739
00:31:19,120 --> 00:31:20,720
the malwares

740
00:31:20,720 --> 00:31:24,000
we then use the first stage rules

741
00:31:24,000 --> 00:31:27,039
and permissions in the mass malware to

742
00:31:27,039 --> 00:31:28,320
generate rules

743
00:31:28,320 --> 00:31:30,720
with permission which is the second

744
00:31:30,720 --> 00:31:32,799
stage rules

745
00:31:32,799 --> 00:31:36,320
in step six we then use quake engine

746
00:31:36,320 --> 00:31:38,960
the full version full function version

747
00:31:38,960 --> 00:31:39,840
of clock engine

748
00:31:39,840 --> 00:31:42,880
to find again the intersection

749
00:31:42,880 --> 00:31:45,679
of the second stage rules which are the

750
00:31:45,679 --> 00:31:46,080
one

751
00:31:46,080 --> 00:31:49,200
with the permission and malware we

752
00:31:49,200 --> 00:31:50,720
prepared

753
00:31:50,720 --> 00:31:53,360
after that for each rules we label the

754
00:31:53,360 --> 00:31:54,080
number of

755
00:31:54,080 --> 00:31:57,840
matched malware for example the behavior

756
00:31:57,840 --> 00:31:58,960
of rule number one

757
00:31:58,960 --> 00:32:01,519
can be found in a hundred in a hundred

758
00:32:01,519 --> 00:32:03,919
hour

759
00:32:04,000 --> 00:32:06,880
in step seven

760
00:32:07,039 --> 00:32:09,600
after labeling the rules we then sort

761
00:32:09,600 --> 00:32:11,200
the rules by number of

762
00:32:11,200 --> 00:32:15,279
massed malware will review the rules

763
00:32:15,279 --> 00:32:19,039
for the highest best one

764
00:32:19,760 --> 00:32:22,799
all right the last part future works

765
00:32:22,799 --> 00:32:25,279
as i mentioned earlier we still have a

766
00:32:25,279 --> 00:32:26,799
lot of things to do

767
00:32:26,799 --> 00:32:28,399
for example we need to have more

768
00:32:28,399 --> 00:32:30,640
detection rules and we also need to deal

769
00:32:30,640 --> 00:32:31,360
with dot

770
00:32:31,360 --> 00:32:34,880
so files and pack the apks

771
00:32:34,880 --> 00:32:36,640
and we want to have more features of

772
00:32:36,640 --> 00:32:38,640
delving biker loader for example the

773
00:32:38,640 --> 00:32:39,840
downloader

774
00:32:39,840 --> 00:32:42,640
and applying the scoring system to other

775
00:32:42,640 --> 00:32:44,799
binary formats is also in order to do

776
00:32:44,799 --> 00:32:46,399
the list

777
00:32:46,399 --> 00:32:48,559
and we notice that api changes in

778
00:32:48,559 --> 00:32:50,080
different versions of mail

779
00:32:50,080 --> 00:32:53,279
of android will also take care of this

780
00:32:53,279 --> 00:32:54,240
part

781
00:32:54,240 --> 00:32:57,519
in the next version of clock engine oh

782
00:32:57,519 --> 00:32:59,120
and we probably would change the core

783
00:32:59,120 --> 00:33:01,519
library uh since endergon is quite

784
00:33:01,519 --> 00:33:04,399
inactive recently

785
00:33:04,399 --> 00:33:06,720
and one more things i would like to say

786
00:33:06,720 --> 00:33:08,000
actually

787
00:33:08,000 --> 00:33:10,080
we make quack itself easier to be

788
00:33:10,080 --> 00:33:12,320
integrated to other tools

789
00:33:12,320 --> 00:33:15,440
for example users now can

790
00:33:15,440 --> 00:33:18,480
import quark as a python library and

791
00:33:18,480 --> 00:33:20,880
output the analysis resort as a json

792
00:33:20,880 --> 00:33:22,320
file

793
00:33:22,320 --> 00:33:24,880
also quark is collected in black r

794
00:33:24,880 --> 00:33:25,600
clinics

795
00:33:25,600 --> 00:33:27,600
and is integrated to a threat

796
00:33:27,600 --> 00:33:29,760
intelligence analysis tool

797
00:33:29,760 --> 00:33:32,799
intel all you can just install them and

798
00:33:32,799 --> 00:33:35,519
give it a shot

799
00:33:35,840 --> 00:33:37,440
and there is one nugget i would like to

800
00:33:37,440 --> 00:33:38,880
share here

801
00:33:38,880 --> 00:33:41,919
we work at the limit of our tools

802
00:33:41,919 --> 00:33:44,640
when new tools come along new things are

803
00:33:44,640 --> 00:33:46,000
possible

804
00:33:46,000 --> 00:33:48,640
okay that's all for today and if you

805
00:33:48,640 --> 00:33:49,919
have any question

806
00:33:49,919 --> 00:33:53,279
please feel free to de-end our twitter

807
00:33:53,279 --> 00:33:54,240
accounts

808
00:33:54,240 --> 00:34:01,919
thank you

