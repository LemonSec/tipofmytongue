1
00:00:12,320 --> 00:00:15,040
why the options pattern is great for

2
00:00:15,040 --> 00:00:17,760
security

3
00:00:17,760 --> 00:00:20,480
hello my name is dima kotek i'm an

4
00:00:20,480 --> 00:00:22,480
application security engineer at

5
00:00:22,480 --> 00:00:25,359
security journey we provide training for

6
00:00:25,359 --> 00:00:28,160
all matters related to security

7
00:00:28,160 --> 00:00:31,840
that is for developers and by developers

8
00:00:31,840 --> 00:00:34,640
i am obsessed with service reliability

9
00:00:34,640 --> 00:00:37,760
and i'm also excited about goaling

10
00:00:37,760 --> 00:00:39,520
examples in this presentation will be in

11
00:00:39,520 --> 00:00:42,879
go because i like it and they fit very

12
00:00:42,879 --> 00:00:44,879
nicely on the slide

13
00:00:44,879 --> 00:00:46,640
there is my twitter handle if you would

14
00:00:46,640 --> 00:00:49,680
like to have a conversation after this

15
00:00:49,680 --> 00:00:52,320
presentation

16
00:00:52,320 --> 00:00:54,480
today we have four goals that we would

17
00:00:54,480 --> 00:00:56,079
want to accomplish

18
00:00:56,079 --> 00:00:58,559
with our exploration of the options

19
00:00:58,559 --> 00:00:59,920
pattern

20
00:00:59,920 --> 00:01:01,280
and those are

21
00:01:01,280 --> 00:01:03,359
first we're going to review the options

22
00:01:03,359 --> 00:01:05,360
pattern for complex object

23
00:01:05,360 --> 00:01:06,880
initialization

24
00:01:06,880 --> 00:01:09,520
second we will discover the types of

25
00:01:09,520 --> 00:01:11,840
vulnerabilities that the pattern can

26
00:01:11,840 --> 00:01:13,760
help us prevent

27
00:01:13,760 --> 00:01:14,880
third

28
00:01:14,880 --> 00:01:17,200
we will improve the classic paradigm to

29
00:01:17,200 --> 00:01:20,080
maximize the security and we can do that

30
00:01:20,080 --> 00:01:21,360
very well

31
00:01:21,360 --> 00:01:23,840
and finally i hope this talk

32
00:01:23,840 --> 00:01:25,520
inspires you

33
00:01:25,520 --> 00:01:27,439
and other developers to adopt the

34
00:01:27,439 --> 00:01:28,320
pattern

35
00:01:28,320 --> 00:01:30,960
when it fits there's much to be gained

36
00:01:30,960 --> 00:01:33,279
here

37
00:01:33,600 --> 00:01:36,159
to get started let's define the problem

38
00:01:36,159 --> 00:01:38,799
we're trying to solve

39
00:01:38,799 --> 00:01:42,399
o wasp top 10 for 2021

40
00:01:42,399 --> 00:01:46,399
number five is security misconfiguration

41
00:01:46,399 --> 00:01:49,280
last year this was number six

42
00:01:49,280 --> 00:01:52,240
so this particular problem has increased

43
00:01:52,240 --> 00:01:54,399
it doesn't matter how strong your

44
00:01:54,399 --> 00:01:56,479
application is how many different

45
00:01:56,479 --> 00:01:58,560
firewalls it has and

46
00:01:58,560 --> 00:02:00,799
different analytical tools and testing

47
00:02:00,799 --> 00:02:01,680
tools

48
00:02:01,680 --> 00:02:03,840
all the ci cd magic

49
00:02:03,840 --> 00:02:06,240
if it is misconfigured

50
00:02:06,240 --> 00:02:08,639
it will be taken advantage of

51
00:02:08,639 --> 00:02:12,400
and this category in a wasp testifies

52
00:02:12,400 --> 00:02:15,280
that this happens a lot a lot more often

53
00:02:15,280 --> 00:02:17,760
than many other vulnerabilities that we

54
00:02:17,760 --> 00:02:19,680
are afraid of

55
00:02:19,680 --> 00:02:20,640
second

56
00:02:20,640 --> 00:02:23,120
now o-wasp has added a category called

57
00:02:23,120 --> 00:02:26,160
insecure design

58
00:02:26,160 --> 00:02:28,879
i would argue that programs that can can

59
00:02:28,879 --> 00:02:30,640
be misconfigured

60
00:02:30,640 --> 00:02:33,599
and are misconfigured are insecure by

61
00:02:33,599 --> 00:02:35,280
design and there are some things that we

62
00:02:35,280 --> 00:02:38,480
can do about it to prevent that

63
00:02:38,480 --> 00:02:41,360
so this is a prevalent a problem

64
00:02:41,360 --> 00:02:43,760
and attackers love this

65
00:02:43,760 --> 00:02:45,599
you can have a situation where your

66
00:02:45,599 --> 00:02:46,800
program has

67
00:02:46,800 --> 00:02:49,680
a hamstrung cipher it may be capable of

68
00:02:49,680 --> 00:02:53,040
using all the best ciphers but it has

69
00:02:53,040 --> 00:02:55,440
support for some of the legacy ones

70
00:02:55,440 --> 00:02:57,920
which were enabled by a faulty

71
00:02:57,920 --> 00:03:00,640
configuration

72
00:03:00,879 --> 00:03:04,480
a short key was provided by mistake

73
00:03:04,480 --> 00:03:07,360
or an insecure source of random

74
00:03:07,360 --> 00:03:10,080
this happens and to attacker this

75
00:03:10,080 --> 00:03:13,440
opportunity is like a piece of candy

76
00:03:13,440 --> 00:03:15,840
how often we have programs that have

77
00:03:15,840 --> 00:03:18,560
missing access controls

78
00:03:18,560 --> 00:03:21,360
or a misconfigured access control that

79
00:03:21,360 --> 00:03:23,760
expected a certain user group that was

80
00:03:23,760 --> 00:03:27,200
left blank and the program interpreted

81
00:03:27,200 --> 00:03:29,840
as no access control

82
00:03:29,840 --> 00:03:30,799
at all

83
00:03:30,799 --> 00:03:33,120
so an attacker who belongs to no group

84
00:03:33,120 --> 00:03:34,000
at all

85
00:03:34,000 --> 00:03:36,560
just waltzes right past all the access

86
00:03:36,560 --> 00:03:39,200
controls and accesses an endpoint that

87
00:03:39,200 --> 00:03:41,360
should have been secure

88
00:03:41,360 --> 00:03:43,920
this happens a lot

89
00:03:43,920 --> 00:03:47,360
we also have debug back doors

90
00:03:47,360 --> 00:03:49,200
left in our services

91
00:03:49,200 --> 00:03:51,200
we need additional instrumentation we

92
00:03:51,200 --> 00:03:53,760
need additional observability in our

93
00:03:53,760 --> 00:03:55,120
services

94
00:03:55,120 --> 00:03:56,239
and

95
00:03:56,239 --> 00:03:58,560
designing them and building them into

96
00:03:58,560 --> 00:04:00,560
our application can help us in the

97
00:04:00,560 --> 00:04:02,799
development stage

98
00:04:02,799 --> 00:04:05,200
it is often the situation that they are

99
00:04:05,200 --> 00:04:08,400
left by mistake to run in production the

100
00:04:08,400 --> 00:04:10,400
service is deployed but all those

101
00:04:10,400 --> 00:04:12,239
additional helpers

102
00:04:12,239 --> 00:04:13,599
remained

103
00:04:13,599 --> 00:04:15,760
and perhaps they were not supposed to be

104
00:04:15,760 --> 00:04:17,759
there because they were behind a feature

105
00:04:17,759 --> 00:04:21,120
flag or a little environmental variable

106
00:04:21,120 --> 00:04:23,440
called debug equals

107
00:04:23,440 --> 00:04:25,440
true

108
00:04:25,440 --> 00:04:28,720
and it was set to true at the time

109
00:04:28,720 --> 00:04:31,199
and now an attacker found a way to do

110
00:04:31,199 --> 00:04:32,560
whatever they would like with their

111
00:04:32,560 --> 00:04:33,680
service

112
00:04:33,680 --> 00:04:35,440
this is just a few examples but you can

113
00:04:35,440 --> 00:04:37,759
imagine so many more all of those go

114
00:04:37,759 --> 00:04:40,720
back to miss configuration

115
00:04:40,720 --> 00:04:43,040
and you can see how easy it is for the

116
00:04:43,040 --> 00:04:45,280
attackers to exploit those opportunities

117
00:04:45,280 --> 00:04:47,440
and so they usually check for those

118
00:04:47,440 --> 00:04:50,560
things first because it is the most

119
00:04:50,560 --> 00:04:52,479
power given to them with the least

120
00:04:52,479 --> 00:04:56,320
amount of effort on their part

121
00:04:56,320 --> 00:04:58,800
the problem with security advice that's

122
00:04:58,800 --> 00:05:00,720
currently out there regarding this

123
00:05:00,720 --> 00:05:03,600
configuration is that it's not really

124
00:05:03,600 --> 00:05:06,560
all that helpful we have basically

125
00:05:06,560 --> 00:05:09,680
two different categories of advice

126
00:05:09,680 --> 00:05:11,199
one is we're called to stop

127
00:05:11,199 --> 00:05:14,160
misconfiguring services yes double check

128
00:05:14,160 --> 00:05:15,759
everything

129
00:05:15,759 --> 00:05:18,080
don't make those types of mistakes and i

130
00:05:18,080 --> 00:05:20,000
don't think that will really help us

131
00:05:20,000 --> 00:05:20,960
much

132
00:05:20,960 --> 00:05:23,039
because our services

133
00:05:23,039 --> 00:05:25,520
are more sophisticated than ever

134
00:05:25,520 --> 00:05:27,520
there's more of them then there's the

135
00:05:27,520 --> 00:05:30,800
whole cloud layer which is a very opaque

136
00:05:30,800 --> 00:05:33,039
sometimes and difficult to work with and

137
00:05:33,039 --> 00:05:35,919
also our teams are large

138
00:05:35,919 --> 00:05:38,880
and they're more remote they span time

139
00:05:38,880 --> 00:05:40,400
zones and they spend languages and

140
00:05:40,400 --> 00:05:42,880
cultures and it's just a matter of time

141
00:05:42,880 --> 00:05:45,520
before somebody misunderstands

142
00:05:45,520 --> 00:05:47,840
by accident loads an older version of

143
00:05:47,840 --> 00:05:49,919
the configuration file

144
00:05:49,919 --> 00:05:52,639
or removes a commented outline by

145
00:05:52,639 --> 00:05:55,039
mistake that leads to misconfiguration

146
00:05:55,039 --> 00:05:57,360
and simply telling people to stop doing

147
00:05:57,360 --> 00:05:58,960
it is like telling them to stop being

148
00:05:58,960 --> 00:06:02,160
human we are human we will make mistakes

149
00:06:02,160 --> 00:06:04,479
so it's good to be reminded but it's not

150
00:06:04,479 --> 00:06:07,360
really practical business strategy

151
00:06:07,360 --> 00:06:09,039
the second one

152
00:06:09,039 --> 00:06:12,400
category is also the call to use scanner

153
00:06:12,400 --> 00:06:13,919
of some sort

154
00:06:13,919 --> 00:06:16,639
policy validation um

155
00:06:16,639 --> 00:06:18,960
policy based validation or perhaps a

156
00:06:18,960 --> 00:06:20,880
static analysis tool dynamic analysis

157
00:06:20,880 --> 00:06:22,800
tool we have hundreds of configuration

158
00:06:22,800 --> 00:06:24,639
validators these days

159
00:06:24,639 --> 00:06:26,639
uh things that are based for example on

160
00:06:26,639 --> 00:06:30,720
open policy agent or q-lang you can run

161
00:06:30,720 --> 00:06:33,840
configuration files through validators

162
00:06:33,840 --> 00:06:35,360
written written

163
00:06:35,360 --> 00:06:39,039
using for you written for policies right

164
00:06:39,039 --> 00:06:41,280
but the problem is for you to catch

165
00:06:41,280 --> 00:06:44,160
misconfiguration you need to forecast

166
00:06:44,160 --> 00:06:46,720
what the problem is going to be the tool

167
00:06:46,720 --> 00:06:48,639
needs to know

168
00:06:48,639 --> 00:06:51,199
um the problem ahead of time or the

169
00:06:51,199 --> 00:06:52,720
person writing the policy needs to know

170
00:06:52,720 --> 00:06:55,680
it and the cost of discovering ms

171
00:06:55,680 --> 00:06:58,720
configuration is tremendously expensive

172
00:06:58,720 --> 00:07:01,120
you already lost your data you already

173
00:07:01,120 --> 00:07:03,280
compromised your users and now of course

174
00:07:03,280 --> 00:07:05,840
you will write that policy but that may

175
00:07:05,840 --> 00:07:06,800
be

176
00:07:06,800 --> 00:07:08,000
too late

177
00:07:08,000 --> 00:07:08,960
so

178
00:07:08,960 --> 00:07:10,800
this is great we should be using

179
00:07:10,800 --> 00:07:12,880
scanning tools but we need to remember

180
00:07:12,880 --> 00:07:15,919
that they catch mostly the most obvious

181
00:07:15,919 --> 00:07:18,160
and egregious misconfiguration cases but

182
00:07:18,160 --> 00:07:19,840
when we have custom solutions or we

183
00:07:19,840 --> 00:07:21,840
combine multiple solutions

184
00:07:21,840 --> 00:07:24,240
there's just no way to foresee every

185
00:07:24,240 --> 00:07:25,840
different way something can be

186
00:07:25,840 --> 00:07:28,560
misconfigured and how configurations

187
00:07:28,560 --> 00:07:30,639
interact across boundaries there's just

188
00:07:30,639 --> 00:07:31,840
no way

189
00:07:31,840 --> 00:07:34,319
so the question here really is can we do

190
00:07:34,319 --> 00:07:36,960
something engineering-wise

191
00:07:36,960 --> 00:07:39,120
to help with this problem and the answer

192
00:07:39,120 --> 00:07:40,880
is yes we can

193
00:07:40,880 --> 00:07:43,039
enter the options pattern so what is the

194
00:07:43,039 --> 00:07:44,800
options pattern the options pattern is a

195
00:07:44,800 --> 00:07:47,280
flexible object provisioning strategy

196
00:07:47,280 --> 00:07:49,440
using a list of independent object

197
00:07:49,440 --> 00:07:50,720
modifiers

198
00:07:50,720 --> 00:07:53,440
so let's imagine that our package or our

199
00:07:53,440 --> 00:07:56,240
class is an engine and we're going to

200
00:07:56,240 --> 00:07:59,440
just go and take it through stages of

201
00:07:59,440 --> 00:08:02,319
applying different tools to it and each

202
00:08:02,319 --> 00:08:05,280
tool is only designed to tweak one or

203
00:08:05,280 --> 00:08:08,000
two parameters to get our engine ready

204
00:08:08,000 --> 00:08:10,160
to run in production

205
00:08:10,160 --> 00:08:12,479
each tool is narrow in scope and each

206
00:08:12,479 --> 00:08:15,440
tool is applied only once this is the

207
00:08:15,440 --> 00:08:17,360
basic idea behind

208
00:08:17,360 --> 00:08:20,080
the options pattern to grasp it let's go

209
00:08:20,080 --> 00:08:22,720
back to a java classic which will help

210
00:08:22,720 --> 00:08:25,039
us understand how this whole thing works

211
00:08:25,039 --> 00:08:26,560
and the java classic is of course the

212
00:08:26,560 --> 00:08:28,160
builder pattern for object

213
00:08:28,160 --> 00:08:30,879
initialization the options pattern works

214
00:08:30,879 --> 00:08:33,039
similarly on the surface but there are

215
00:08:33,039 --> 00:08:34,479
some significant

216
00:08:34,479 --> 00:08:37,039
differences that have ramifications for

217
00:08:37,039 --> 00:08:39,440
strong software design and security so

218
00:08:39,440 --> 00:08:41,360
in our first example here's an example

219
00:08:41,360 --> 00:08:43,039
of using a classic

220
00:08:43,039 --> 00:08:44,640
builder pattern where we have say we

221
00:08:44,640 --> 00:08:46,880
want to have a bank account builder

222
00:08:46,880 --> 00:08:48,480
and it will be a class that will

223
00:08:48,480 --> 00:08:50,480
construct another class called bank

224
00:08:50,480 --> 00:08:52,800
account and we will supply

225
00:08:52,800 --> 00:08:55,519
by calling methods different parameters

226
00:08:55,519 --> 00:08:57,600
to our builder and finally we will call

227
00:08:57,600 --> 00:08:59,279
the build method

228
00:08:59,279 --> 00:09:01,920
and have our bank account

229
00:09:01,920 --> 00:09:04,399
in the second example is the same idea

230
00:09:04,399 --> 00:09:06,640
but using the options pattern and the

231
00:09:06,640 --> 00:09:09,120
difference here is that instead of using

232
00:09:09,120 --> 00:09:11,440
a class we will use a constructor

233
00:09:11,440 --> 00:09:13,680
function that will take a list

234
00:09:13,680 --> 00:09:16,560
of object modifiers a list of options

235
00:09:16,560 --> 00:09:19,600
and um by convention we start those with

236
00:09:19,600 --> 00:09:21,120
the word with

237
00:09:21,120 --> 00:09:23,440
and we'll take those parameters each one

238
00:09:23,440 --> 00:09:26,720
of those options typically a closure

239
00:09:26,720 --> 00:09:27,519
will

240
00:09:27,519 --> 00:09:29,519
tweak that parameter for our bank

241
00:09:29,519 --> 00:09:30,640
account

242
00:09:30,640 --> 00:09:33,519
and there's no need to run the build

243
00:09:33,519 --> 00:09:35,279
method because the options

244
00:09:35,279 --> 00:09:36,880
initialization

245
00:09:36,880 --> 00:09:39,920
step the constructor will will apply

246
00:09:39,920 --> 00:09:41,680
the series of those modifiers and return

247
00:09:41,680 --> 00:09:43,680
the result

248
00:09:43,680 --> 00:09:45,360
so uh the options pattern is kind of

249
00:09:45,360 --> 00:09:47,360
like a cousin of the builder pattern

250
00:09:47,360 --> 00:09:49,519
it's superficially very similar but one

251
00:09:49,519 --> 00:09:51,440
way to differentiate them is to think of

252
00:09:51,440 --> 00:09:54,560
the constructor pattern as one object

253
00:09:54,560 --> 00:09:57,040
preparing another for the options

254
00:09:57,040 --> 00:10:00,000
pattern the object is prepared using a

255
00:10:00,000 --> 00:10:02,800
list of modifiers a list of options

256
00:10:02,800 --> 00:10:05,279
those are typically closures

257
00:10:05,279 --> 00:10:07,519
let's look um at the classic this is how

258
00:10:07,519 --> 00:10:09,279
i first learned functional options from

259
00:10:09,279 --> 00:10:10,720
the go community

260
00:10:10,720 --> 00:10:12,399
and it took me a while to appreciate the

261
00:10:12,399 --> 00:10:14,160
value of it this is

262
00:10:14,160 --> 00:10:16,959
just a really simple example first we

263
00:10:16,959 --> 00:10:19,839
will define a type called option

264
00:10:19,839 --> 00:10:22,800
and an option will be just a function

265
00:10:22,800 --> 00:10:24,880
that will take a pointer to the thing

266
00:10:24,880 --> 00:10:26,480
we're trying to construct in our example

267
00:10:26,480 --> 00:10:28,240
is a bank account

268
00:10:28,240 --> 00:10:30,720
and once we have defined the type let's

269
00:10:30,720 --> 00:10:33,120
create one option we can make as many as

270
00:10:33,120 --> 00:10:34,800
we want but let's create one option and

271
00:10:34,800 --> 00:10:37,360
call this option with email with email

272
00:10:37,360 --> 00:10:40,320
we'll take a string and return an option

273
00:10:40,320 --> 00:10:42,079
this is a closure a second order

274
00:10:42,079 --> 00:10:42,959
function

275
00:10:42,959 --> 00:10:45,120
right and so it will return a function

276
00:10:45,120 --> 00:10:46,480
wrapped or hidden inside another

277
00:10:46,480 --> 00:10:47,920
function

278
00:10:47,920 --> 00:10:49,680
and inside the other function we will

279
00:10:49,680 --> 00:10:53,279
actually take our object b which is bank

280
00:10:53,279 --> 00:10:56,320
account and we'll apply that supplied

281
00:10:56,320 --> 00:11:00,079
email to our parameter client email

282
00:11:00,079 --> 00:11:03,120
please note that of course in golang

283
00:11:03,120 --> 00:11:05,440
client email

284
00:11:05,440 --> 00:11:07,600
is with a lowercase letter and that

285
00:11:07,600 --> 00:11:10,240
means that it is a private parameter

286
00:11:10,240 --> 00:11:12,640
when we're using options pattern object

287
00:11:12,640 --> 00:11:14,480
initialization we want to protect our

288
00:11:14,480 --> 00:11:16,959
private parameters and not make them

289
00:11:16,959 --> 00:11:18,320
accessible

290
00:11:18,320 --> 00:11:19,040
by

291
00:11:19,040 --> 00:11:20,800
external

292
00:11:20,800 --> 00:11:22,160
modification right so we don't want

293
00:11:22,160 --> 00:11:23,920
people to go and change our values

294
00:11:23,920 --> 00:11:25,360
without going through proper

295
00:11:25,360 --> 00:11:27,839
modification channel safe modification

296
00:11:27,839 --> 00:11:31,279
channel which is our closure so only we

297
00:11:31,279 --> 00:11:32,800
want to have access directly to the

298
00:11:32,800 --> 00:11:34,399
parameter otherwise if people want to

299
00:11:34,399 --> 00:11:36,160
change and they have to go through the

300
00:11:36,160 --> 00:11:37,279
option

301
00:11:37,279 --> 00:11:40,399
and uh that's the the main point here

302
00:11:40,399 --> 00:11:41,440
right so

303
00:11:41,440 --> 00:11:43,600
we keep those parameters hidden under

304
00:11:43,600 --> 00:11:46,399
wraps and private

305
00:11:46,399 --> 00:11:48,320
can we improve this pattern this

306
00:11:48,320 --> 00:11:49,680
classical pattern

307
00:11:49,680 --> 00:11:51,279
in in any way

308
00:11:51,279 --> 00:11:53,760
and um we can

309
00:11:53,760 --> 00:11:57,760
we can improve it by applying for

310
00:11:57,760 --> 00:11:59,200
classical

311
00:11:59,200 --> 00:12:01,600
failure conditions safe or secure

312
00:12:01,600 --> 00:12:03,519
failure conditions

313
00:12:03,519 --> 00:12:05,600
we want to make sure that if our program

314
00:12:05,600 --> 00:12:08,240
fails there's four

315
00:12:08,240 --> 00:12:11,279
trays that it has in the process of

316
00:12:11,279 --> 00:12:13,360
failing and those are that the failure

317
00:12:13,360 --> 00:12:15,200
is early and of course object

318
00:12:15,200 --> 00:12:17,360
initialization is about as early as you

319
00:12:17,360 --> 00:12:19,519
can your program is just starting is

320
00:12:19,519 --> 00:12:22,560
warming up we want to fail safely so

321
00:12:22,560 --> 00:12:26,399
there's no leaks or memory dumps or any

322
00:12:26,399 --> 00:12:29,600
kind of crashes that leave

323
00:12:29,600 --> 00:12:31,360
threads open or something like that we

324
00:12:31,360 --> 00:12:33,360
want to have a safe failure we want to

325
00:12:33,360 --> 00:12:35,279
fail explicitly so the reason for the

326
00:12:35,279 --> 00:12:39,920
failure is known so that upstream uh

327
00:12:39,920 --> 00:12:42,560
services can deal with the error and so

328
00:12:42,560 --> 00:12:45,440
there's a way to catalog it and

329
00:12:45,440 --> 00:12:47,920
document it and maybe trigger an alert

330
00:12:47,920 --> 00:12:49,760
or response of some sort so that has to

331
00:12:49,760 --> 00:12:52,079
be very specific and finally we want to

332
00:12:52,079 --> 00:12:54,399
have a singular point of failure it is

333
00:12:54,399 --> 00:12:57,360
terrible to have to deal with a program

334
00:12:57,360 --> 00:12:59,839
that cascaded into

335
00:12:59,839 --> 00:13:01,920
a myriad of different failure causes

336
00:13:01,920 --> 00:13:03,600
when you have five potential problems

337
00:13:03,600 --> 00:13:04,639
that could go wrong and you don't know

338
00:13:04,639 --> 00:13:07,040
you just have like this giant giant log

339
00:13:07,040 --> 00:13:08,720
dump and you're trying to figure it out

340
00:13:08,720 --> 00:13:09,440
right

341
00:13:09,440 --> 00:13:11,680
so um can we

342
00:13:11,680 --> 00:13:13,200
use those four conditions in the

343
00:13:13,200 --> 00:13:15,839
planetary options pattern yes we can and

344
00:13:15,839 --> 00:13:17,120
we must

345
00:13:17,120 --> 00:13:19,680
the main point here is that in securely

346
00:13:19,680 --> 00:13:21,600
configured services

347
00:13:21,600 --> 00:13:23,839
should not even start

348
00:13:23,839 --> 00:13:25,120
if something

349
00:13:25,120 --> 00:13:26,560
can be misconfigured it will be

350
00:13:26,560 --> 00:13:29,440
misconfigured as just a matter of time

351
00:13:29,440 --> 00:13:32,000
our engineering should be up to the task

352
00:13:32,000 --> 00:13:33,760
it needs to be advanced enough to

353
00:13:33,760 --> 00:13:37,680
anticipate problems and to quit

354
00:13:37,680 --> 00:13:40,240
naming the reason for the failure

355
00:13:40,240 --> 00:13:42,320
naming the exact reason for the failure

356
00:13:42,320 --> 00:13:45,440
gracefully so the whole thing spins down

357
00:13:45,440 --> 00:13:47,600
and we know what to do

358
00:13:47,600 --> 00:13:48,880
how do we do this with the option

359
00:13:48,880 --> 00:13:50,639
pattern well there's a small adjustment

360
00:13:50,639 --> 00:13:52,959
that we're going to make to the classic

361
00:13:52,959 --> 00:13:55,519
and the adjustment is this to our type

362
00:13:55,519 --> 00:13:57,519
when we define our option we will also

363
00:13:57,519 --> 00:14:00,160
add a return type

364
00:14:00,160 --> 00:14:01,920
error

365
00:14:01,920 --> 00:14:03,279
so now it's not just a function that

366
00:14:03,279 --> 00:14:04,800
takes a pointer to the bank account it

367
00:14:04,800 --> 00:14:07,600
also returns an error

368
00:14:07,600 --> 00:14:11,519
uh so our validation logic will be now

369
00:14:11,519 --> 00:14:13,279
inside our option

370
00:14:13,279 --> 00:14:15,519
it's not just a setter method it's not

371
00:14:15,519 --> 00:14:17,040
just

372
00:14:17,040 --> 00:14:19,120
doing enough modification it's also

373
00:14:19,120 --> 00:14:21,279
going to do some checking some

374
00:14:21,279 --> 00:14:22,480
validation to make sure that the

375
00:14:22,480 --> 00:14:26,320
parameter is correct so once we um have

376
00:14:26,320 --> 00:14:29,519
added this capability now when we create

377
00:14:29,519 --> 00:14:32,639
our option with email we will return the

378
00:14:32,639 --> 00:14:33,440
same

379
00:14:33,440 --> 00:14:34,480
closure

380
00:14:34,480 --> 00:14:36,399
but this time it has the capability of

381
00:14:36,399 --> 00:14:37,839
checking for an errors and we will

382
00:14:37,839 --> 00:14:40,480
validate the email inside the closure

383
00:14:40,480 --> 00:14:42,000
for example by using a regular

384
00:14:42,000 --> 00:14:43,120
expression

385
00:14:43,120 --> 00:14:45,519
and return an error if it doesn't

386
00:14:45,519 --> 00:14:46,720
validate

387
00:14:46,720 --> 00:14:48,480
in some languages

388
00:14:48,480 --> 00:14:49,839
we can use

389
00:14:49,839 --> 00:14:51,760
uh we can just throw an error that's

390
00:14:51,760 --> 00:14:54,800
just a style question right so go

391
00:14:54,800 --> 00:14:57,440
returns errors as values

392
00:14:57,440 --> 00:14:59,120
i think that's better

393
00:14:59,120 --> 00:15:01,199
but throwing is also an option the point

394
00:15:01,199 --> 00:15:02,880
being is that this will translate into

395
00:15:02,880 --> 00:15:05,440
other languages nicely this is just an

396
00:15:05,440 --> 00:15:06,560
example

397
00:15:06,560 --> 00:15:09,360
but what you are doing is checking is

398
00:15:09,360 --> 00:15:12,480
this parameter absolutely legit in every

399
00:15:12,480 --> 00:15:15,839
possible way can it mess me up somehow

400
00:15:15,839 --> 00:15:18,480
and once i know that it can't

401
00:15:18,480 --> 00:15:21,600
now it's safe to ascribe or to assign to

402
00:15:21,600 --> 00:15:23,440
our main object and finally we will

403
00:15:23,440 --> 00:15:26,639
return and no meaning that nothing went

404
00:15:26,639 --> 00:15:28,399
wrong if the execution went all the way

405
00:15:28,399 --> 00:15:30,800
to the end of the function

406
00:15:30,800 --> 00:15:34,000
that's a safer um options

407
00:15:34,000 --> 00:15:35,440
type

408
00:15:35,440 --> 00:15:37,360
how do we use those in a constructor

409
00:15:37,360 --> 00:15:39,040
well that's what a typical constructor

410
00:15:39,040 --> 00:15:41,279
will look like we'll call ours new bank

411
00:15:41,279 --> 00:15:43,199
account it will take

412
00:15:43,199 --> 00:15:44,560
a list

413
00:15:44,560 --> 00:15:46,560
of options called we'll name it with

414
00:15:46,560 --> 00:15:49,199
options and return a pointer to our bank

415
00:15:49,199 --> 00:15:52,000
account and an error

416
00:15:52,000 --> 00:15:54,079
so our resulting banking account will be

417
00:15:54,079 --> 00:15:55,440
just blank we're not going to do

418
00:15:55,440 --> 00:15:56,880
anything with it to start with and then

419
00:15:56,880 --> 00:15:59,680
what we will do is we will iterate one

420
00:15:59,680 --> 00:16:02,959
by one through every provided option

421
00:16:02,959 --> 00:16:06,000
evaluate it apply it to our result

422
00:16:06,000 --> 00:16:08,480
and if there is an error we'll return it

423
00:16:08,480 --> 00:16:10,560
and of course when we're returning the

424
00:16:10,560 --> 00:16:13,519
error we also should be wrapping it so

425
00:16:13,519 --> 00:16:15,279
it is clear upstream that this is

426
00:16:15,279 --> 00:16:18,000
initialization failure that there was

427
00:16:18,000 --> 00:16:19,680
not something that went wrong in the

428
00:16:19,680 --> 00:16:21,199
execution stage it went at the

429
00:16:21,199 --> 00:16:23,759
initialization stage this helps with

430
00:16:23,759 --> 00:16:26,560
clarity and the stability of our service

431
00:16:26,560 --> 00:16:28,160
finally at the end of the constructor we

432
00:16:28,160 --> 00:16:30,800
want to validate the result uh itself

433
00:16:30,800 --> 00:16:32,639
but not the parameters so what this

434
00:16:32,639 --> 00:16:34,320
means basically we want to check if

435
00:16:34,320 --> 00:16:36,880
mandatory parameters were set if it has

436
00:16:36,880 --> 00:16:39,199
all the right things it needs to is have

437
00:16:39,199 --> 00:16:42,000
and then we can return it and return no

438
00:16:42,000 --> 00:16:44,959
for an error not too difficult very

439
00:16:44,959 --> 00:16:47,680
basic example there is some boilerplate

440
00:16:47,680 --> 00:16:48,639
but

441
00:16:48,639 --> 00:16:51,360
trust me it pays off i doing this when

442
00:16:51,360 --> 00:16:53,040
it fits

443
00:16:53,040 --> 00:16:54,880
uh how does it pay off what does this

444
00:16:54,880 --> 00:16:56,800
really get us in the end

445
00:16:56,800 --> 00:17:00,000
well uh rigorous or well-designed

446
00:17:00,000 --> 00:17:02,399
documented on application of the options

447
00:17:02,399 --> 00:17:04,480
pattern allows us to

448
00:17:04,480 --> 00:17:06,319
deal with three different things at the

449
00:17:06,319 --> 00:17:08,319
very least and those are invalid and in

450
00:17:08,319 --> 00:17:10,240
secure state right we don't want to

451
00:17:10,240 --> 00:17:12,000
launch an object with something that's

452
00:17:12,000 --> 00:17:14,880
nil or something that's misconfigured

453
00:17:14,880 --> 00:17:17,520
and just broken

454
00:17:17,520 --> 00:17:19,919
capable of carrying out a critical task

455
00:17:19,919 --> 00:17:22,720
which could have security ramifications

456
00:17:22,720 --> 00:17:25,280
the second one is we want to prevent

457
00:17:25,280 --> 00:17:28,160
failures originating in parameters

458
00:17:28,160 --> 00:17:29,679
those are actually very common because

459
00:17:29,679 --> 00:17:31,840
as programs get more sophisticated a lot

460
00:17:31,840 --> 00:17:34,000
of times a parameter being passed is a

461
00:17:34,000 --> 00:17:35,840
behavior

462
00:17:35,840 --> 00:17:37,600
like a cache for example so you're

463
00:17:37,600 --> 00:17:40,160
passing that to your object and that can

464
00:17:40,160 --> 00:17:42,160
have a lot of complexity and you have to

465
00:17:42,160 --> 00:17:43,600
ask the question

466
00:17:43,600 --> 00:17:45,760
how was that configured who configured

467
00:17:45,760 --> 00:17:47,200
it who provided

468
00:17:47,200 --> 00:17:49,760
values to that parameter do i know if it

469
00:17:49,760 --> 00:17:50,799
works

470
00:17:50,799 --> 00:17:53,840
um usually we assume that just because

471
00:17:53,840 --> 00:17:55,679
the interface was satisfied or just

472
00:17:55,679 --> 00:17:57,520
because the thing was given to us inside

473
00:17:57,520 --> 00:17:58,880
the program so we think well if it came

474
00:17:58,880 --> 00:18:00,240
from inside our program it should be

475
00:18:00,240 --> 00:18:03,360
fine well no it should be validated all

476
00:18:03,360 --> 00:18:06,000
right there should be some basic checks

477
00:18:06,000 --> 00:18:07,919
because otherwise there will be failure

478
00:18:07,919 --> 00:18:09,440
originating in the parameter that that

479
00:18:09,440 --> 00:18:11,440
can affect the rest of the program so we

480
00:18:11,440 --> 00:18:12,320
want to

481
00:18:12,320 --> 00:18:13,919
guard against it and the options pattern

482
00:18:13,919 --> 00:18:16,320
can help with that and finally uh

483
00:18:16,320 --> 00:18:18,400
conflicting parameters a lot of times

484
00:18:18,400 --> 00:18:20,640
what will really mess you up

485
00:18:20,640 --> 00:18:23,200
is not one misconfigured thing it's

486
00:18:23,200 --> 00:18:24,240
usually

487
00:18:24,240 --> 00:18:25,280
uh

488
00:18:25,280 --> 00:18:28,400
an interaction between parameters that

489
00:18:28,400 --> 00:18:32,240
can undermine or cancel out another

490
00:18:32,240 --> 00:18:34,000
and those are also difficult to detect

491
00:18:34,000 --> 00:18:36,080
because the configuration itself can

492
00:18:36,080 --> 00:18:38,559
look rather benign and something that's

493
00:18:38,559 --> 00:18:40,000
obscure and

494
00:18:40,000 --> 00:18:42,880
not as noticeable can uh critically

495
00:18:42,880 --> 00:18:43,840
impact

496
00:18:43,840 --> 00:18:45,600
something else another part of your

497
00:18:45,600 --> 00:18:46,880
execution

498
00:18:46,880 --> 00:18:51,440
the options pattern can help with this

499
00:18:51,679 --> 00:18:53,919
i'm talking about how wonderful this

500
00:18:53,919 --> 00:18:55,520
thing is and hopefully i can convince

501
00:18:55,520 --> 00:18:57,440
you but there is definitely usage

502
00:18:57,440 --> 00:18:59,120
criteria we should not be using this

503
00:18:59,120 --> 00:19:00,400
everywhere

504
00:19:00,400 --> 00:19:02,799
where should we use it typically i use

505
00:19:02,799 --> 00:19:06,320
it if i do use it maybe once per package

506
00:19:06,320 --> 00:19:07,840
once per program

507
00:19:07,840 --> 00:19:10,480
not more often than that whatever you're

508
00:19:10,480 --> 00:19:12,400
configuring has to be sophisticated

509
00:19:12,400 --> 00:19:13,760
enough

510
00:19:13,760 --> 00:19:16,160
and there's three criteria you can go by

511
00:19:16,160 --> 00:19:18,400
to choose if you want to really

512
00:19:18,400 --> 00:19:20,240
work with the options pattern as and the

513
00:19:20,240 --> 00:19:23,039
first criteria is flexible behavior

514
00:19:23,039 --> 00:19:25,919
so does your object change the way it

515
00:19:25,919 --> 00:19:28,799
behaves based on environment based on

516
00:19:28,799 --> 00:19:30,799
the configuration values provided are

517
00:19:30,799 --> 00:19:32,240
you passing

518
00:19:32,240 --> 00:19:34,880
providers or drivers or caches or

519
00:19:34,880 --> 00:19:37,520
networking layer adapters or any kind of

520
00:19:37,520 --> 00:19:39,760
adapter to your object if you are this

521
00:19:39,760 --> 00:19:42,799
flexible behavior and that means those

522
00:19:42,799 --> 00:19:44,320
parameters with behavior should be

523
00:19:44,320 --> 00:19:46,080
validated so you'll need the options

524
00:19:46,080 --> 00:19:47,039
pattern

525
00:19:47,039 --> 00:19:48,799
second if you have some mandatory

526
00:19:48,799 --> 00:19:50,640
parameters or

527
00:19:50,640 --> 00:19:52,559
but not others or if you have a

528
00:19:52,559 --> 00:19:55,200
situation where uh the list of mandatory

529
00:19:55,200 --> 00:19:57,280
parameters can change

530
00:19:57,280 --> 00:19:59,520
uh circumstantially right so that's

531
00:19:59,520 --> 00:20:01,360
fairly sophisticated

532
00:20:01,360 --> 00:20:02,720
and also

533
00:20:02,720 --> 00:20:04,720
if you they were all mandatory you would

534
00:20:04,720 --> 00:20:07,120
be probably better off with something

535
00:20:07,120 --> 00:20:09,360
more straightforward like a dictionary

536
00:20:09,360 --> 00:20:11,840
keyword initialization strategy

537
00:20:11,840 --> 00:20:14,320
because that's uh

538
00:20:14,320 --> 00:20:17,200
that will be clearer right but if that's

539
00:20:17,200 --> 00:20:18,000
um

540
00:20:18,000 --> 00:20:19,840
not so easy right that some are

541
00:20:19,840 --> 00:20:21,520
mandatory others are not the options

542
00:20:21,520 --> 00:20:23,600
pattern is probably a better

543
00:20:23,600 --> 00:20:24,320
bet

544
00:20:24,320 --> 00:20:25,919
and finally if you have entangled

545
00:20:25,919 --> 00:20:28,159
parameters and what are those it's a

546
00:20:28,159 --> 00:20:31,280
class of conflicting parameters where

547
00:20:31,280 --> 00:20:34,400
changing one produces a side effect

548
00:20:34,400 --> 00:20:37,919
that can cause problems or

549
00:20:37,919 --> 00:20:40,480
warnings or errors for another

550
00:20:40,480 --> 00:20:42,799
let me give you an example of what that

551
00:20:42,799 --> 00:20:44,720
would look like

552
00:20:44,720 --> 00:20:46,000
let's suppose we're writing a

553
00:20:46,000 --> 00:20:48,240
hypothetical asset encoder and let's

554
00:20:48,240 --> 00:20:52,080
just put together an option for it

555
00:20:52,080 --> 00:20:54,320
and um

556
00:20:54,320 --> 00:20:56,960
it's let's say it's for an iot device it

557
00:20:56,960 --> 00:20:58,559
will be some it will be kind of

558
00:20:58,559 --> 00:21:00,060
something simple um

559
00:21:00,060 --> 00:21:01,520
[Music]

560
00:21:01,520 --> 00:21:03,520
not too sophisticated but you know who

561
00:21:03,520 --> 00:21:05,360
knows so we're writing it and we're

562
00:21:05,360 --> 00:21:07,440
going to write an option called with

563
00:21:07,440 --> 00:21:09,280
block size and memory

564
00:21:09,280 --> 00:21:12,080
limit and we're putting size and limit

565
00:21:12,080 --> 00:21:14,159
in the same option

566
00:21:14,159 --> 00:21:15,360
um

567
00:21:15,360 --> 00:21:18,640
and why well here's the reason because

568
00:21:18,640 --> 00:21:22,720
size block size and memory limit have

569
00:21:22,720 --> 00:21:24,559
several conditions

570
00:21:24,559 --> 00:21:26,159
several interactions with each other

571
00:21:26,159 --> 00:21:28,400
they are intertwined

572
00:21:28,400 --> 00:21:29,200
first

573
00:21:29,200 --> 00:21:30,640
those are just three things i can think

574
00:21:30,640 --> 00:21:32,480
of from the top of my head but if you

575
00:21:32,480 --> 00:21:34,320
thought about this problem or had to

576
00:21:34,320 --> 00:21:36,559
write an asset encoder you can think of

577
00:21:36,559 --> 00:21:38,400
more right but first of all the limit

578
00:21:38,400 --> 00:21:40,400
has to be greater than zero

579
00:21:40,400 --> 00:21:42,640
and it has to be greater than size the

580
00:21:42,640 --> 00:21:45,120
limit has to be a multiple of the size

581
00:21:45,120 --> 00:21:47,600
because we don't want to end up with

582
00:21:47,600 --> 00:21:50,320
a block that's overflowing a buffer or

583
00:21:50,320 --> 00:21:52,960
underflowing above for in the end like

584
00:21:52,960 --> 00:21:54,799
that will just create a

585
00:21:54,799 --> 00:21:57,440
complex logic in the encoder itself so

586
00:21:57,440 --> 00:21:59,440
to prevent that we can just

587
00:21:59,440 --> 00:22:01,200
check for so limit has to be multiple of

588
00:22:01,200 --> 00:22:02,240
the size

589
00:22:02,240 --> 00:22:03,679
and third we may have protocol

590
00:22:03,679 --> 00:22:05,440
constraints like we just for example

591
00:22:05,440 --> 00:22:08,080
know that in the protocol for this

592
00:22:08,080 --> 00:22:10,400
encoder there's only two bytes for the

593
00:22:10,400 --> 00:22:12,720
block sequence and that puts a limit on

594
00:22:12,720 --> 00:22:16,320
how many uh blocks total there can be

595
00:22:16,320 --> 00:22:17,039
so

596
00:22:17,039 --> 00:22:19,679
those three things are significant

597
00:22:19,679 --> 00:22:22,960
issues um of inter and significant areas

598
00:22:22,960 --> 00:22:24,320
of interaction between those two

599
00:22:24,320 --> 00:22:26,400
parameters so if you change

600
00:22:26,400 --> 00:22:27,520
size

601
00:22:27,520 --> 00:22:29,120
a limit will be affected and if you

602
00:22:29,120 --> 00:22:31,760
change limit size will be affected

603
00:22:31,760 --> 00:22:34,960
in low level languages like c

604
00:22:34,960 --> 00:22:35,919
those

605
00:22:35,919 --> 00:22:37,840
simple things are deadly

606
00:22:37,840 --> 00:22:40,400
potentially right um

607
00:22:40,400 --> 00:22:43,360
missing this can result into

608
00:22:43,360 --> 00:22:46,080
a remote code execution a buffer

609
00:22:46,080 --> 00:22:48,960
overflow a dos attack a crash i mean you

610
00:22:48,960 --> 00:22:50,640
can just imagine just about anything

611
00:22:50,640 --> 00:22:51,440
right

612
00:22:51,440 --> 00:22:55,039
so even with stronger languages like go

613
00:22:55,039 --> 00:22:56,240
and rush

614
00:22:56,240 --> 00:22:58,960
even if memory is not corrupted the

615
00:22:58,960 --> 00:23:00,799
interactions between parameters can

616
00:23:00,799 --> 00:23:02,000
still

617
00:23:02,000 --> 00:23:06,240
unbalance it and toss the service over

618
00:23:06,240 --> 00:23:07,840
so what are we going to do about it well

619
00:23:07,840 --> 00:23:10,480
we write an option in such a way that we

620
00:23:10,480 --> 00:23:11,760
validate

621
00:23:11,760 --> 00:23:14,480
all those areas of interaction we try to

622
00:23:14,480 --> 00:23:16,880
forecast them a threat model a little

623
00:23:16,880 --> 00:23:19,520
bit and build that threat modeling into

624
00:23:19,520 --> 00:23:21,679
the code in such a way that when we

625
00:23:21,679 --> 00:23:23,520
finally assign

626
00:23:23,520 --> 00:23:25,600
block size and memory limit to our

627
00:23:25,600 --> 00:23:26,880
encoder

628
00:23:26,880 --> 00:23:29,200
they were proven to be

629
00:23:29,200 --> 00:23:31,840
correct they were proven to be safe

630
00:23:31,840 --> 00:23:34,840
and then we return a

631
00:23:34,840 --> 00:23:38,240
no you can see here right away that this

632
00:23:38,240 --> 00:23:40,720
also creates what we call self

633
00:23:40,720 --> 00:23:42,960
documenting code

634
00:23:42,960 --> 00:23:45,919
when the person is using your package

635
00:23:45,919 --> 00:23:47,840
id will give them hints right so they

636
00:23:47,840 --> 00:23:49,440
start typing and they start selecting

637
00:23:49,440 --> 00:23:51,440
options so they'll type something like

638
00:23:51,440 --> 00:23:53,440
well i want to change block size and

639
00:23:53,440 --> 00:23:56,240
memory limit and they'll see

640
00:23:56,240 --> 00:23:58,559
by typing either one as it comes up

641
00:23:58,559 --> 00:24:00,240
using the fuzzy search

642
00:24:00,240 --> 00:24:03,039
that they go together and the programmer

643
00:24:03,039 --> 00:24:05,760
may not understand the full extent of

644
00:24:05,760 --> 00:24:07,679
the relationship between those two

645
00:24:07,679 --> 00:24:09,039
variables

646
00:24:09,039 --> 00:24:12,159
but just by consuming it

647
00:24:12,159 --> 00:24:14,480
this way through the ide they have a

648
00:24:14,480 --> 00:24:16,640
hint that they are

649
00:24:16,640 --> 00:24:20,400
connected and this is documenting this

650
00:24:20,400 --> 00:24:21,919
is hinting

651
00:24:21,919 --> 00:24:24,400
to another developer that those

652
00:24:24,400 --> 00:24:25,840
parameters

653
00:24:25,840 --> 00:24:28,400
are significantly connected and this

654
00:24:28,400 --> 00:24:31,039
creates documentation that's implicit

655
00:24:31,039 --> 00:24:33,679
it's very convenient and very helpful

656
00:24:33,679 --> 00:24:36,559
and more secure

657
00:24:36,559 --> 00:24:37,919
can we

658
00:24:37,919 --> 00:24:41,440
improve this even further yes we can

659
00:24:41,440 --> 00:24:42,480
we can

660
00:24:42,480 --> 00:24:44,400
improve the options pattern even more by

661
00:24:44,400 --> 00:24:46,880
adding option grouping

662
00:24:46,880 --> 00:24:48,000
this can

663
00:24:48,000 --> 00:24:50,720
help us with isolation clarity and

664
00:24:50,720 --> 00:24:54,320
safety when we combine multiple options

665
00:24:54,320 --> 00:24:55,200
as

666
00:24:55,200 --> 00:24:56,720
one

667
00:24:56,720 --> 00:24:58,960
and those options could be private or

668
00:24:58,960 --> 00:25:01,360
public let's look at

669
00:25:01,360 --> 00:25:03,440
how we would go about doing that

670
00:25:03,440 --> 00:25:05,440
we will write a little helper and we'll

671
00:25:05,440 --> 00:25:08,320
call it with options that will take a

672
00:25:08,320 --> 00:25:12,080
list of options and return one option

673
00:25:12,080 --> 00:25:14,480
why would we ever want to do that

674
00:25:14,480 --> 00:25:17,200
um because it's wonderful

675
00:25:17,200 --> 00:25:19,200
um i'll explain

676
00:25:19,200 --> 00:25:21,039
so let's uh

677
00:25:21,039 --> 00:25:22,880
make that work right so let's make that

678
00:25:22,880 --> 00:25:25,360
option we'll make a function that takes

679
00:25:25,360 --> 00:25:27,919
our bank account and returns an error

680
00:25:27,919 --> 00:25:30,720
and we will iterate through every option

681
00:25:30,720 --> 00:25:31,600
and

682
00:25:31,600 --> 00:25:34,799
apply that option to our b our main

683
00:25:34,799 --> 00:25:36,960
object check for an error and if there's

684
00:25:36,960 --> 00:25:39,120
no error we can return

685
00:25:39,120 --> 00:25:42,159
well this loop right there looks exactly

686
00:25:42,159 --> 00:25:44,320
like the loop we already wrote for the

687
00:25:44,320 --> 00:25:45,840
constructor

688
00:25:45,840 --> 00:25:47,840
and um

689
00:25:47,840 --> 00:25:50,000
we can just externalize it right we can

690
00:25:50,000 --> 00:25:52,400
pull that functionality out so while

691
00:25:52,400 --> 00:25:54,480
we're at it let's just replace the

692
00:25:54,480 --> 00:25:56,720
iteration inside the constructor by

693
00:25:56,720 --> 00:25:58,159
using our

694
00:25:58,159 --> 00:26:00,480
little helper with options and not

695
00:26:00,480 --> 00:26:02,159
forget to

696
00:26:02,159 --> 00:26:05,200
include also the error wrapping

697
00:26:05,200 --> 00:26:06,799
to to characterize the error as an

698
00:26:06,799 --> 00:26:09,600
initialization error

699
00:26:09,600 --> 00:26:11,279
so this is a little bit of more

700
00:26:11,279 --> 00:26:13,760
boilerplate why what's the point of

701
00:26:13,760 --> 00:26:15,760
doing that combining multiple options

702
00:26:15,760 --> 00:26:16,799
into one

703
00:26:16,799 --> 00:26:18,880
well this allows us to unleash our

704
00:26:18,880 --> 00:26:20,240
little helper

705
00:26:20,240 --> 00:26:22,720
and create option sets and one of the

706
00:26:22,720 --> 00:26:24,960
best option sets you can have is called

707
00:26:24,960 --> 00:26:26,720
with default

708
00:26:26,720 --> 00:26:28,480
options

709
00:26:28,480 --> 00:26:30,080
that's what it means to have a program

710
00:26:30,080 --> 00:26:32,320
secure by default right is actually

711
00:26:32,320 --> 00:26:34,880
having secure defaults and that means

712
00:26:34,880 --> 00:26:36,720
functionality that configures the object

713
00:26:36,720 --> 00:26:38,480
securely securely

714
00:26:38,480 --> 00:26:41,679
but also singularly how convenient is it

715
00:26:41,679 --> 00:26:44,159
to just find out what are the

716
00:26:44,159 --> 00:26:47,039
proper decent configuration values

717
00:26:47,039 --> 00:26:48,799
that i should be using

718
00:26:48,799 --> 00:26:51,120
with this class just by clicking on that

719
00:26:51,120 --> 00:26:52,880
list with default options and then

720
00:26:52,880 --> 00:26:56,320
immediately i can see the entire list

721
00:26:56,320 --> 00:26:58,080
uh the values that

722
00:26:58,080 --> 00:27:01,120
are expected and it helps me decide

723
00:27:01,120 --> 00:27:03,679
what i might want to change right or

724
00:27:03,679 --> 00:27:06,559
helps me see what things are mandatory

725
00:27:06,559 --> 00:27:09,200
from a single location that's excellent

726
00:27:09,200 --> 00:27:10,640
for clarity

727
00:27:10,640 --> 00:27:12,960
and security

728
00:27:12,960 --> 00:27:16,320
with default options it's great

729
00:27:16,320 --> 00:27:18,960
something else you can also write on an

730
00:27:18,960 --> 00:27:22,960
option set called with debug options

731
00:27:22,960 --> 00:27:24,960
and those are wonderful why would we

732
00:27:24,960 --> 00:27:27,760
want to do that well because

733
00:27:27,760 --> 00:27:29,440
we can

734
00:27:29,440 --> 00:27:32,840
write special unsafe private

735
00:27:32,840 --> 00:27:35,440
options for example like administrative

736
00:27:35,440 --> 00:27:37,520
backdoor that we don't want anybody just

737
00:27:37,520 --> 00:27:39,120
using frivolously

738
00:27:39,120 --> 00:27:41,279
and we can hide that administrative

739
00:27:41,279 --> 00:27:43,279
backdoor option called with

740
00:27:43,279 --> 00:27:45,440
administrative backdoor

741
00:27:45,440 --> 00:27:46,840
we can hide it

742
00:27:46,840 --> 00:27:50,080
inside an options set called with debug

743
00:27:50,080 --> 00:27:53,679
options this way it is entirely clear

744
00:27:53,679 --> 00:27:57,039
to the user of our api that this

745
00:27:57,039 --> 00:27:58,640
backdoor should not be used by itself it

746
00:27:58,640 --> 00:28:01,200
should be used together with

747
00:28:01,200 --> 00:28:04,080
as a part of a set and also allows us to

748
00:28:04,080 --> 00:28:06,320
attach uh instrumentation and all the

749
00:28:06,320 --> 00:28:08,240
other things we may need for debugging

750
00:28:08,240 --> 00:28:12,000
uh trace logging etc together because

751
00:28:12,000 --> 00:28:13,600
you'll never have a situation where

752
00:28:13,600 --> 00:28:16,480
administrative backdoor is deployed but

753
00:28:16,480 --> 00:28:18,399
there's no logger attached to it you

754
00:28:18,399 --> 00:28:20,480
know or anything like that

755
00:28:20,480 --> 00:28:22,799
and while we're at it while we're making

756
00:28:22,799 --> 00:28:23,600
those

757
00:28:23,600 --> 00:28:25,520
lists of debug options

758
00:28:25,520 --> 00:28:28,000
why don't we also add a little check

759
00:28:28,000 --> 00:28:30,320
just to see if our service is running in

760
00:28:30,320 --> 00:28:31,840
production

761
00:28:31,840 --> 00:28:33,600
because if it is we should be crashing

762
00:28:33,600 --> 00:28:35,360
it right we should not be deploying

763
00:28:35,360 --> 00:28:38,320
debug options into production

764
00:28:38,320 --> 00:28:41,039
that makes it very insecure and this way

765
00:28:41,039 --> 00:28:44,000
our little helper allows us to do it and

766
00:28:44,000 --> 00:28:45,760
finally we can also use our little

767
00:28:45,760 --> 00:28:48,960
helper for visual grouping and nesting

768
00:28:48,960 --> 00:28:51,279
sometimes three things are not really

769
00:28:51,279 --> 00:28:52,799
tangled

770
00:28:52,799 --> 00:28:54,480
but it is helpful

771
00:28:54,480 --> 00:28:56,880
to see them on the same line and perhaps

772
00:28:56,880 --> 00:28:59,760
add a comment for clarity's sake

773
00:28:59,760 --> 00:29:02,399
the little helper with options allows us

774
00:29:02,399 --> 00:29:06,399
to do this ergonomically and beautifully

775
00:29:06,399 --> 00:29:09,120
let's put all of this together

776
00:29:09,120 --> 00:29:11,360
so we can see the value let's look at

777
00:29:11,360 --> 00:29:13,360
some things that are more sophisticated

778
00:29:13,360 --> 00:29:14,960
than the simple examples that we were

779
00:29:14,960 --> 00:29:16,399
discussing

780
00:29:16,399 --> 00:29:18,480
suppose we're writing a hypothetical

781
00:29:18,480 --> 00:29:21,600
distributed secrets manager is that

782
00:29:21,600 --> 00:29:24,000
complicated enough oh yes it is this is

783
00:29:24,000 --> 00:29:25,279
hard to write

784
00:29:25,279 --> 00:29:28,000
and since it's distributed we will have

785
00:29:28,000 --> 00:29:29,120
peers

786
00:29:29,120 --> 00:29:30,559
and we'll need a way to provide those

787
00:29:30,559 --> 00:29:33,200
peers to our constructor maybe a pure

788
00:29:33,200 --> 00:29:35,039
discovery protocol

789
00:29:35,039 --> 00:29:37,120
maybe both why not

790
00:29:37,120 --> 00:29:39,200
also we want to have a caching layer

791
00:29:39,200 --> 00:29:41,600
because it was distributed it can be

792
00:29:41,600 --> 00:29:42,559
very

793
00:29:42,559 --> 00:29:44,880
impractical to wait for the round trip

794
00:29:44,880 --> 00:29:47,039
for the network layer so we may want to

795
00:29:47,039 --> 00:29:50,000
have a cache redis is great so let's

796
00:29:50,000 --> 00:29:52,799
just take a stack of redis settings and

797
00:29:52,799 --> 00:29:55,360
wrap them in the adapter

798
00:29:55,360 --> 00:29:57,520
we may want to do

799
00:29:57,520 --> 00:29:59,760
basic cryptography without revealing

800
00:29:59,760 --> 00:30:01,440
keys and if we do

801
00:30:01,440 --> 00:30:03,120
then we will need the option for

802
00:30:03,120 --> 00:30:04,880
providing ciphers

803
00:30:04,880 --> 00:30:07,440
to our secrets manager so there's a way

804
00:30:07,440 --> 00:30:10,159
to control allowed ciphers we want to

805
00:30:10,159 --> 00:30:12,320
also limit them to a certain list and we

806
00:30:12,320 --> 00:30:13,760
can check for that list inside the

807
00:30:13,760 --> 00:30:14,640
option

808
00:30:14,640 --> 00:30:16,960
and also of course the rotation window

809
00:30:16,960 --> 00:30:18,240
right what's the point of having a

810
00:30:18,240 --> 00:30:21,440
secrets manager if there is no rotation

811
00:30:21,440 --> 00:30:23,600
uh is absolutely critical so we want to

812
00:30:23,600 --> 00:30:26,159
have a duration

813
00:30:26,159 --> 00:30:28,960
between uh between which

814
00:30:28,960 --> 00:30:30,480
at the end of which

815
00:30:30,480 --> 00:30:31,919
uh we

816
00:30:31,919 --> 00:30:34,399
are expecting that the keys will rotate

817
00:30:34,399 --> 00:30:38,080
and also we want to set max key lifetime

818
00:30:38,080 --> 00:30:40,000
when you look at those two things you

819
00:30:40,000 --> 00:30:42,880
realize that wait a second those two are

820
00:30:42,880 --> 00:30:44,960
pretzeled those two values have a

821
00:30:44,960 --> 00:30:48,799
significant relationship to each other

822
00:30:48,799 --> 00:30:51,760
the rotation window cannot be

823
00:30:51,760 --> 00:30:53,440
shorter

824
00:30:53,440 --> 00:30:56,480
cannot be uh longer than max key

825
00:30:56,480 --> 00:30:58,480
lifetime right because if it is we will

826
00:30:58,480 --> 00:31:00,399
have service outage because the key

827
00:31:00,399 --> 00:31:02,799
expired but it wasn't rotated in so it

828
00:31:02,799 --> 00:31:04,559
has to be shorter than

829
00:31:04,559 --> 00:31:07,039
max key lifetime but also max key

830
00:31:07,039 --> 00:31:09,760
lifetime cannot be too long if it's more

831
00:31:09,760 --> 00:31:11,279
than like five times longer than the

832
00:31:11,279 --> 00:31:12,960
rotation window

833
00:31:12,960 --> 00:31:13,919
uh

834
00:31:13,919 --> 00:31:16,000
then that defeats the entire purpose of

835
00:31:16,000 --> 00:31:17,600
the rotation

836
00:31:17,600 --> 00:31:20,000
right so it persists much longer and

837
00:31:20,000 --> 00:31:22,000
increases the attack surface

838
00:31:22,000 --> 00:31:24,080
and it creates you know other types of

839
00:31:24,080 --> 00:31:25,919
problems

840
00:31:25,919 --> 00:31:27,120
but

841
00:31:27,120 --> 00:31:29,039
if we think harder about it there's

842
00:31:29,039 --> 00:31:30,240
actually

843
00:31:30,240 --> 00:31:34,080
more potential problems because

844
00:31:34,080 --> 00:31:36,399
if we try to combine those two options

845
00:31:36,399 --> 00:31:38,320
rotation window and max key lifetime

846
00:31:38,320 --> 00:31:40,399
inside the same option like we did with

847
00:31:40,399 --> 00:31:42,240
size and limit in the previous example

848
00:31:42,240 --> 00:31:44,399
it just will not work very well

849
00:31:44,399 --> 00:31:47,440
first of all uh that whole option uh

850
00:31:47,440 --> 00:31:49,440
declaration with rotation window and max

851
00:31:49,440 --> 00:31:51,919
key lifetime is very wordy

852
00:31:51,919 --> 00:31:52,720
um

853
00:31:52,720 --> 00:31:55,279
and then we realized that actually there

854
00:31:55,279 --> 00:31:56,720
could be more parameters that could

855
00:31:56,720 --> 00:31:57,840
affect us

856
00:31:57,840 --> 00:31:59,360
down the line maybe right now we can't

857
00:31:59,360 --> 00:32:01,600
think of any but this could this could

858
00:32:01,600 --> 00:32:02,559
change

859
00:32:02,559 --> 00:32:04,159
as the uh

860
00:32:04,159 --> 00:32:05,360
our secrets manager gets more

861
00:32:05,360 --> 00:32:07,919
sophisticated but something else comes

862
00:32:07,919 --> 00:32:08,880
up

863
00:32:08,880 --> 00:32:10,960
what if the cash

864
00:32:10,960 --> 00:32:14,399
invalidation was misconfigured

865
00:32:14,399 --> 00:32:16,320
a red is cache

866
00:32:16,320 --> 00:32:18,000
how is that configured

867
00:32:18,000 --> 00:32:20,080
what if it's set up in such a way

868
00:32:20,080 --> 00:32:22,080
that the keys

869
00:32:22,080 --> 00:32:23,440
persist

870
00:32:23,440 --> 00:32:24,640
longer

871
00:32:24,640 --> 00:32:26,640
than their max key lifetime we could

872
00:32:26,640 --> 00:32:28,480
have a situation where

873
00:32:28,480 --> 00:32:32,000
ghost keys are still in cash even though

874
00:32:32,000 --> 00:32:34,399
the secrets manager has already expired

875
00:32:34,399 --> 00:32:35,919
them

876
00:32:35,919 --> 00:32:38,240
that would be a bypassed access control

877
00:32:38,240 --> 00:32:40,880
and it's very easy to imagine a scenario

878
00:32:40,880 --> 00:32:42,880
where this configuration causes it to

879
00:32:42,880 --> 00:32:45,679
persist for all eternity so how can we

880
00:32:45,679 --> 00:32:46,799
address this

881
00:32:46,799 --> 00:32:48,799
how can we do this securely

882
00:32:48,799 --> 00:32:50,720
well we can lean on another

883
00:32:50,720 --> 00:32:52,960
initialization strategy and instead of

884
00:32:52,960 --> 00:32:55,279
combining those into one option we can

885
00:32:55,279 --> 00:32:57,279
just create another option we'll call it

886
00:32:57,279 --> 00:32:59,440
synchronization strategy

887
00:32:59,440 --> 00:33:01,679
and we'll take a list of keywords in the

888
00:33:01,679 --> 00:33:03,120
structure called synchronization

889
00:33:03,120 --> 00:33:04,320
settings

890
00:33:04,320 --> 00:33:06,080
and we'll put the rotation window and

891
00:33:06,080 --> 00:33:09,120
key lifetime there leave a comment

892
00:33:09,120 --> 00:33:11,279
because we expect that maybe there'll be

893
00:33:11,279 --> 00:33:13,760
more synchronization settings later

894
00:33:13,760 --> 00:33:15,679
we can deal with them later

895
00:33:15,679 --> 00:33:18,559
but now we can pass the synchronization

896
00:33:18,559 --> 00:33:21,919
settings structure to our redis

897
00:33:21,919 --> 00:33:23,360
cache adapter

898
00:33:23,360 --> 00:33:26,000
and synchronize the two so they are the

899
00:33:26,000 --> 00:33:26,880
same

900
00:33:26,880 --> 00:33:30,159
that the max key lifetime matches

901
00:33:30,159 --> 00:33:31,039
the

902
00:33:31,039 --> 00:33:33,360
asset expiration the value expiration

903
00:33:33,360 --> 00:33:36,320
inside the redis cache

904
00:33:36,320 --> 00:33:39,440
the options pattern help us helps us

905
00:33:39,440 --> 00:33:41,919
think and threat model

906
00:33:41,919 --> 00:33:44,000
maybe we could call it something like

907
00:33:44,000 --> 00:33:46,720
options driven design

908
00:33:46,720 --> 00:33:47,919
um

909
00:33:47,919 --> 00:33:50,880
maybe not i'm just kidding

910
00:33:50,880 --> 00:33:52,640
let's keep going

911
00:33:52,640 --> 00:33:55,120
uh new hypothetical micro service right

912
00:33:55,120 --> 00:33:57,039
so we're writing a micro service and of

913
00:33:57,039 --> 00:33:59,039
course we want to provide a host on the

914
00:33:59,039 --> 00:34:01,360
port we want to have a port as an

915
00:34:01,360 --> 00:34:03,279
integer so we can lean on the type

916
00:34:03,279 --> 00:34:06,480
system we'll need a tls configurator of

917
00:34:06,480 --> 00:34:08,399
some sort acme is great so we'll just

918
00:34:08,399 --> 00:34:09,520
use that

919
00:34:09,520 --> 00:34:11,359
and then of course timeout settings

920
00:34:11,359 --> 00:34:13,599
timeouts are so critical for

921
00:34:13,599 --> 00:34:16,320
microservices if the microservice is

922
00:34:16,320 --> 00:34:19,520
getting tarpeded or is

923
00:34:19,520 --> 00:34:20,399
you know

924
00:34:20,399 --> 00:34:23,040
getting connections which cause it to

925
00:34:23,040 --> 00:34:25,520
respond very slowly or to

926
00:34:25,520 --> 00:34:27,918
uh or the other way

927
00:34:27,918 --> 00:34:30,000
to hold long sessions it can bring down

928
00:34:30,000 --> 00:34:31,440
the whole microservice it can affect

929
00:34:31,440 --> 00:34:33,040
other microservices

930
00:34:33,040 --> 00:34:35,440
so we can externalize that as well by

931
00:34:35,440 --> 00:34:36,960
making a structure called timeout

932
00:34:36,960 --> 00:34:37,918
settings

933
00:34:37,918 --> 00:34:40,000
and divide it into ingress egress and

934
00:34:40,000 --> 00:34:41,599
idle session timeout

935
00:34:41,599 --> 00:34:45,359
and that timeout can be actually shared

936
00:34:45,359 --> 00:34:47,679
not just with the http stack but with

937
00:34:47,679 --> 00:34:50,159
other parts of the microservice so the

938
00:34:50,159 --> 00:34:51,359
entire

939
00:34:51,359 --> 00:34:53,440
microservice is secured with all of us

940
00:34:53,440 --> 00:34:56,000
interactions internal and external you

941
00:34:56,000 --> 00:34:57,599
can use the same timeouts for

942
00:34:57,599 --> 00:35:00,320
interactions with the database

943
00:35:00,320 --> 00:35:01,680
we may want to have an option for a

944
00:35:01,680 --> 00:35:03,520
secrets manager because if we're running

945
00:35:03,520 --> 00:35:05,839
microservice it needs to have secrets

946
00:35:05,839 --> 00:35:08,320
kms adapter to it sure

947
00:35:08,320 --> 00:35:10,720
a throttling strategy right if it's if

948
00:35:10,720 --> 00:35:11,520
we're

949
00:35:11,520 --> 00:35:13,520
not throttling services they are

950
00:35:13,520 --> 00:35:14,640
unstable

951
00:35:14,640 --> 00:35:17,599
and of course a retry strategy we can

952
00:35:17,599 --> 00:35:20,000
call it immediate retry we can swap it

953
00:35:20,000 --> 00:35:21,760
out for something else later those are

954
00:35:21,760 --> 00:35:23,680
behaviors and if we're passing behaviors

955
00:35:23,680 --> 00:35:25,599
we need to be checking them

956
00:35:25,599 --> 00:35:28,079
with the options pattern and finally we

957
00:35:28,079 --> 00:35:30,079
have a choice for a back-end and a

958
00:35:30,079 --> 00:35:31,680
logger

959
00:35:31,680 --> 00:35:33,359
if we are writing something so

960
00:35:33,359 --> 00:35:35,119
sophisticated that require the options

961
00:35:35,119 --> 00:35:38,800
pattern a logger is

962
00:35:38,800 --> 00:35:41,119
pretty much required yeah right we don't

963
00:35:41,119 --> 00:35:42,480
want to put loggers everywhere because

964
00:35:42,480 --> 00:35:44,240
they create side effects but they're

965
00:35:44,240 --> 00:35:45,920
excellent for something

966
00:35:45,920 --> 00:35:47,440
this um

967
00:35:47,440 --> 00:35:50,000
this complicated right so uh and then of

968
00:35:50,000 --> 00:35:52,000
course you can write an interface and

969
00:35:52,000 --> 00:35:54,079
satisfy it with a logger of your choice

970
00:35:54,079 --> 00:35:56,160
and you can actually write the option in

971
00:35:56,160 --> 00:35:58,480
such a way that they are appended to a

972
00:35:58,480 --> 00:36:02,000
list so we have now multi-directional

973
00:36:02,000 --> 00:36:03,599
logging

974
00:36:03,599 --> 00:36:06,160
um suppose we're writing a far gate

975
00:36:06,160 --> 00:36:08,160
containerized task launcher i had to

976
00:36:08,160 --> 00:36:10,320
write one of those the other day this is

977
00:36:10,320 --> 00:36:12,880
not easy so fargit is an api on top of

978
00:36:12,880 --> 00:36:14,960
kubernetes which is a nightmare to

979
00:36:14,960 --> 00:36:15,920
secure

980
00:36:15,920 --> 00:36:18,400
uh so fargate is a little bit easier in

981
00:36:18,400 --> 00:36:19,599
that regard

982
00:36:19,599 --> 00:36:21,839
um but still we have to be vigilant and

983
00:36:21,839 --> 00:36:25,200
we have to check the aws config that is

984
00:36:25,200 --> 00:36:28,560
correct right that it's not using uh

985
00:36:28,560 --> 00:36:30,480
static keys or anything like that so

986
00:36:30,480 --> 00:36:34,000
we're using um the configurator properly

987
00:36:34,000 --> 00:36:36,079
that is getting its identity and its

988
00:36:36,079 --> 00:36:38,400
role from the ec2 instance where it's

989
00:36:38,400 --> 00:36:40,800
running on not from an environmental

990
00:36:40,800 --> 00:36:42,800
variable we can check for that

991
00:36:42,800 --> 00:36:44,480
we want to provide a cluster name so we

992
00:36:44,480 --> 00:36:46,400
have a single point of failure a url

993
00:36:46,400 --> 00:36:50,240
factory sure and then private subnet ids

994
00:36:50,240 --> 00:36:53,040
and public subnet ids well see uh

995
00:36:53,040 --> 00:36:55,839
fargate does not differentiate

996
00:36:55,839 --> 00:36:58,079
subnets public and private it just has

997
00:36:58,079 --> 00:36:59,359
one

998
00:36:59,359 --> 00:37:00,960
place to put a subnet it just asks for

999
00:37:00,960 --> 00:37:03,440
subnet ids or a list of ids

1000
00:37:03,440 --> 00:37:06,960
but that's a problem because um

1001
00:37:06,960 --> 00:37:09,760
if we if we put

1002
00:37:09,760 --> 00:37:12,160
a private service out on the public

1003
00:37:12,160 --> 00:37:13,520
subnet

1004
00:37:13,520 --> 00:37:16,079
we could be leaking information or

1005
00:37:16,079 --> 00:37:17,119
giving

1006
00:37:17,119 --> 00:37:18,640
an attacker

1007
00:37:18,640 --> 00:37:20,400
server side request

1008
00:37:20,400 --> 00:37:22,720
forgery type of vector anything you can

1009
00:37:22,720 --> 00:37:24,400
imagine so we have to be really careful

1010
00:37:24,400 --> 00:37:27,359
about that and even if fargate

1011
00:37:27,359 --> 00:37:29,520
does not differentiate private and

1012
00:37:29,520 --> 00:37:32,720
public uh subnets

1013
00:37:32,720 --> 00:37:34,880
we should

1014
00:37:34,880 --> 00:37:37,040
we should the same goes for security

1015
00:37:37,040 --> 00:37:38,960
groups like in aws security group is

1016
00:37:38,960 --> 00:37:41,520
like a firewall set of rules it's very

1017
00:37:41,520 --> 00:37:44,320
significant so how can we differentiate

1018
00:37:44,320 --> 00:37:46,640
well we can for example when we get the

1019
00:37:46,640 --> 00:37:48,960
subnet id we can check for that ip

1020
00:37:48,960 --> 00:37:51,760
address and see if it starts with 10.0

1021
00:37:51,760 --> 00:37:53,760
that would indicate an internet uh

1022
00:37:53,760 --> 00:37:55,920
subnet that just an example you can get

1023
00:37:55,920 --> 00:37:56,880
more

1024
00:37:56,880 --> 00:37:58,720
sophisticated than that but the point

1025
00:37:58,720 --> 00:38:00,000
being is that

1026
00:38:00,000 --> 00:38:02,800
even if the api

1027
00:38:02,800 --> 00:38:05,359
is not enforce a public private division

1028
00:38:05,359 --> 00:38:07,599
our implementation can and our

1029
00:38:07,599 --> 00:38:09,839
configuration checker can we can check

1030
00:38:09,839 --> 00:38:14,880
for that at initialization and we should

1031
00:38:14,880 --> 00:38:16,480
suppose we're writing hypothetical

1032
00:38:16,480 --> 00:38:18,480
encrypted network tunnel we want to

1033
00:38:18,480 --> 00:38:22,240
specify a certain packet size

1034
00:38:22,240 --> 00:38:25,359
a key provider yes of course a behavior

1035
00:38:25,359 --> 00:38:27,200
and we want we may want to have recovery

1036
00:38:27,200 --> 00:38:29,200
fallback if our

1037
00:38:29,200 --> 00:38:30,839
network tunnel is

1038
00:38:30,839 --> 00:38:33,839
stateful uh a journal fallback is great

1039
00:38:33,839 --> 00:38:36,000
sure let's provide that on and of course

1040
00:38:36,000 --> 00:38:38,240
validate it as we're uh leaning on that

1041
00:38:38,240 --> 00:38:39,280
behavior

1042
00:38:39,280 --> 00:38:41,920
we'll need a non-factory that's always a

1043
00:38:41,920 --> 00:38:44,000
complicated thing uh with encryption

1044
00:38:44,000 --> 00:38:46,240
synchronizing nonsense against

1045
00:38:46,240 --> 00:38:47,920
across services

1046
00:38:47,920 --> 00:38:49,760
at scale is very hard

1047
00:38:49,760 --> 00:38:52,240
and finally we can even use an option

1048
00:38:52,240 --> 00:38:54,880
called with error handler those are

1049
00:38:54,880 --> 00:38:55,760
great

1050
00:38:55,760 --> 00:38:57,520
and this is an example another one where

1051
00:38:57,520 --> 00:38:59,839
we can pass a closure

1052
00:38:59,839 --> 00:39:02,000
as an option and that is so convenient

1053
00:39:02,000 --> 00:39:03,200
because

1054
00:39:03,200 --> 00:39:05,520
sometimes we don't even care about every

1055
00:39:05,520 --> 00:39:07,280
error like sometimes we want to set up

1056
00:39:07,280 --> 00:39:08,400
an alert

1057
00:39:08,400 --> 00:39:10,800
or we we're looking for a report on a

1058
00:39:10,800 --> 00:39:13,839
particular error and we can do that with

1059
00:39:13,839 --> 00:39:15,599
an options pattern using the error

1060
00:39:15,599 --> 00:39:18,560
handler append it to a list of handlers

1061
00:39:18,560 --> 00:39:21,200
and rock on right that's a really

1062
00:39:21,200 --> 00:39:22,960
flexible great way

1063
00:39:22,960 --> 00:39:24,400
of of dealing

1064
00:39:24,400 --> 00:39:26,079
with errors and of course we can have a

1065
00:39:26,079 --> 00:39:29,599
default one in there as well um

1066
00:39:29,599 --> 00:39:31,520
that would make our you know service

1067
00:39:31,520 --> 00:39:33,200
more secure

1068
00:39:33,200 --> 00:39:35,440
error handling is a big part of security

1069
00:39:35,440 --> 00:39:38,560
so those are just examples

1070
00:39:38,560 --> 00:39:40,640
of some things i got to work on and some

1071
00:39:40,640 --> 00:39:42,400
things you can think of yourself but

1072
00:39:42,400 --> 00:39:44,240
here's an elephant in the room that i i

1073
00:39:44,240 --> 00:39:46,400
did not even bring up something i didn't

1074
00:39:46,400 --> 00:39:47,839
even talk about this whole time that's

1075
00:39:47,839 --> 00:39:51,119
so important just think back

1076
00:39:51,119 --> 00:39:52,640
what are we doing

1077
00:39:52,640 --> 00:39:55,040
with this right we're pulling that

1078
00:39:55,040 --> 00:39:56,720
sophisticated

1079
00:39:56,720 --> 00:40:00,160
logic validation logic into isolated

1080
00:40:00,160 --> 00:40:02,560
closures into functions

1081
00:40:02,560 --> 00:40:04,319
that are localized

1082
00:40:04,319 --> 00:40:06,800
that each have to do with one area or

1083
00:40:06,800 --> 00:40:08,880
two areas of concern and that are

1084
00:40:08,880 --> 00:40:10,720
sensitive to each other

1085
00:40:10,720 --> 00:40:14,319
but are very limited in scope

1086
00:40:14,319 --> 00:40:18,319
we are setting up our options for easy

1087
00:40:18,319 --> 00:40:20,319
unit testing

1088
00:40:20,319 --> 00:40:21,599
here's the truth

1089
00:40:21,599 --> 00:40:24,240
there is no better initialization

1090
00:40:24,240 --> 00:40:26,560
strategy for unit testing than the

1091
00:40:26,560 --> 00:40:28,160
options pattern

1092
00:40:28,160 --> 00:40:30,400
and once you have a strong battery of

1093
00:40:30,400 --> 00:40:31,760
unit tests

1094
00:40:31,760 --> 00:40:33,599
that check for many different types of

1095
00:40:33,599 --> 00:40:35,520
failure conditions

1096
00:40:35,520 --> 00:40:38,400
you add security and you make it in such

1097
00:40:38,400 --> 00:40:41,520
a way that it's modular and flexible and

1098
00:40:41,520 --> 00:40:44,079
extendable right you know you're not

1099
00:40:44,079 --> 00:40:46,880
break gonna break any apis if you add

1100
00:40:46,880 --> 00:40:48,800
additional options etc

1101
00:40:48,800 --> 00:40:50,839
uh it just makes it

1102
00:40:50,839 --> 00:40:53,599
great a tested code thoroughly tested

1103
00:40:53,599 --> 00:40:56,319
code is safe and the option pattern

1104
00:40:56,319 --> 00:41:00,079
gives you a hand by lending itself

1105
00:41:00,079 --> 00:41:01,920
to easy

1106
00:41:01,920 --> 00:41:05,280
automated testing

1107
00:41:05,280 --> 00:41:08,400
oh wasp top 10 20 21 number five and

1108
00:41:08,400 --> 00:41:10,880
number four security misconfiguration

1109
00:41:10,880 --> 00:41:13,200
insecure design

1110
00:41:13,200 --> 00:41:14,000
this

1111
00:41:14,000 --> 00:41:15,920
this is a problem that should not be in

1112
00:41:15,920 --> 00:41:18,319
top ten right we can solve this we have

1113
00:41:18,319 --> 00:41:20,640
the tools for it we have the know-how it

1114
00:41:20,640 --> 00:41:22,560
requires a little bit of discipline a

1115
00:41:22,560 --> 00:41:24,480
little bit of a different mindset this

1116
00:41:24,480 --> 00:41:26,240
is coming from functional paradigm

1117
00:41:26,240 --> 00:41:28,960
functional programming paradigm is good

1118
00:41:28,960 --> 00:41:31,440
you can apply it but most importantly it

1119
00:41:31,440 --> 00:41:34,000
can help you think and threat model and

1120
00:41:34,000 --> 00:41:36,160
anticipate problems

1121
00:41:36,160 --> 00:41:37,440
ahead of time

1122
00:41:37,440 --> 00:41:40,000
and if we use the options pattern we can

1123
00:41:40,000 --> 00:41:42,800
make a big chunk in

1124
00:41:42,800 --> 00:41:45,680
in this work that's required to resolve

1125
00:41:45,680 --> 00:41:47,920
secure misconfiguration and insecure

1126
00:41:47,920 --> 00:41:48,960
design

1127
00:41:48,960 --> 00:41:50,720
let's sum up

1128
00:41:50,720 --> 00:41:53,440
if something can be misused it will be

1129
00:41:53,440 --> 00:41:54,800
misused

1130
00:41:54,800 --> 00:41:57,839
be secure by default weekend services

1131
00:41:57,839 --> 00:42:01,040
should not even start

1132
00:42:01,040 --> 00:42:02,880
the options pattern guards against

1133
00:42:02,880 --> 00:42:05,119
configuration invalid initialization

1134
00:42:05,119 --> 00:42:06,079
states

1135
00:42:06,079 --> 00:42:09,200
and other vulnerabilities

1136
00:42:09,200 --> 00:42:11,920
the options pattern is convenient for

1137
00:42:11,920 --> 00:42:14,400
automated testing

1138
00:42:14,400 --> 00:42:17,040
it is the best strategy objectivization

1139
00:42:17,040 --> 00:42:19,040
strategy for automated testing

1140
00:42:19,040 --> 00:42:20,240
and finally

1141
00:42:20,240 --> 00:42:22,000
implement the options pattern in your

1142
00:42:22,000 --> 00:42:24,400
next major version release to bolster

1143
00:42:24,400 --> 00:42:26,800
security with a boost of code

1144
00:42:26,800 --> 00:42:29,280
readability reliability

1145
00:42:29,280 --> 00:42:31,200
and resilience

1146
00:42:31,200 --> 00:42:35,359
this stuff really works use it

1147
00:42:36,960 --> 00:42:38,960
if you enjoyed this presentation you can

1148
00:42:38,960 --> 00:42:42,000
find a full compilable example at that

1149
00:42:42,000 --> 00:42:43,359
qr code

1150
00:42:43,359 --> 00:42:45,520
i also want to bring to your attention a

1151
00:42:45,520 --> 00:42:47,520
few resources one of them was the

1152
00:42:47,520 --> 00:42:50,240
classic presentation by dave cheney this

1153
00:42:50,240 --> 00:42:51,599
is one of the early

1154
00:42:51,599 --> 00:42:54,000
discovery opportunities for me how i

1155
00:42:54,000 --> 00:42:55,200
learned the options pattern and he

1156
00:42:55,200 --> 00:42:57,599
explains even more all the great

1157
00:42:57,599 --> 00:42:59,920
benefits of it there's also a very

1158
00:42:59,920 --> 00:43:03,200
detailed good blog by mark uh sagi kazar

1159
00:43:03,200 --> 00:43:04,720
that is excellent

1160
00:43:04,720 --> 00:43:06,720
and there's an interesting article about

1161
00:43:06,720 --> 00:43:09,440
how can this can be applied to database

1162
00:43:09,440 --> 00:43:11,040
queries

1163
00:43:11,040 --> 00:43:13,520
thank you so much for your attention

1164
00:43:13,520 --> 00:43:16,160
i enjoyed sharing

1165
00:43:16,160 --> 00:43:18,079
the options pattern with you

1166
00:43:18,079 --> 00:43:20,240
i hope you learned something new and

1167
00:43:20,240 --> 00:43:22,800
keep in touch

1168
00:43:22,800 --> 00:43:25,800
bye

