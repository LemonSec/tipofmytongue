1
00:00:10,960 --> 00:00:13,840
hello welcome to hexcon my name is rogan

2
00:00:13,840 --> 00:00:15,440
dawes and i'm going to be sharing with

3
00:00:15,440 --> 00:00:18,000
you what i learned about keylock remote

4
00:00:18,000 --> 00:00:20,960
control systems

5
00:00:22,720 --> 00:00:25,439
i am a researcher for orange cyber

6
00:00:25,439 --> 00:00:26,560
defense

7
00:00:26,560 --> 00:00:27,359
and

8
00:00:27,359 --> 00:00:28,880
we hack

9
00:00:28,880 --> 00:00:33,679
build train scan and do research

10
00:00:34,640 --> 00:00:36,800
so what is this presentation about

11
00:00:36,800 --> 00:00:38,800
this whole adventure started when my

12
00:00:38,800 --> 00:00:40,399
neighborhood decided to apply for

13
00:00:40,399 --> 00:00:43,280
permission to close the street entrances

14
00:00:43,280 --> 00:00:44,960
we had automated gates at two of the

15
00:00:44,960 --> 00:00:47,440
entrances and wanted to allow residents

16
00:00:47,440 --> 00:00:49,200
to open and close them

17
00:00:49,200 --> 00:00:50,800
this would be done using a remote

18
00:00:50,800 --> 00:00:53,039
transmitter much like many have in their

19
00:00:53,039 --> 00:00:54,239
homes

20
00:00:54,239 --> 00:00:56,640
this talk covers a few aspects of this

21
00:00:56,640 --> 00:00:59,199
journey why we chose keylock what

22
00:00:59,199 --> 00:01:01,680
keylock actually is and how it works

23
00:01:01,680 --> 00:01:03,760
as well as my experiences obtaining full

24
00:01:03,760 --> 00:01:06,320
access to the hardware both receiver and

25
00:01:06,320 --> 00:01:07,520
transmitter

26
00:01:07,520 --> 00:01:11,040
as well as repurposing it for use around

27
00:01:11,040 --> 00:01:12,799
my home

28
00:01:12,799 --> 00:01:14,400
while it does focus on a particular

29
00:01:14,400 --> 00:01:16,560
manufacturer i won't be revealing the

30
00:01:16,560 --> 00:01:18,880
manufacturer key or too much detail

31
00:01:18,880 --> 00:01:21,119
about how i was able to find it as it

32
00:01:21,119 --> 00:01:23,520
would expose a significant number of

33
00:01:23,520 --> 00:01:27,600
people to attacks including myself

34
00:01:27,600 --> 00:01:28,560
so

35
00:01:28,560 --> 00:01:30,320
choosing remotes

36
00:01:30,320 --> 00:01:32,079
we wanted transmitters that could be

37
00:01:32,079 --> 00:01:34,560
enabled and disabled individually

38
00:01:34,560 --> 00:01:36,240
having lived in a townhouse complex

39
00:01:36,240 --> 00:01:37,360
previously

40
00:01:37,360 --> 00:01:39,360
i was familiar with the flag days where

41
00:01:39,360 --> 00:01:41,119
the code on the receiver gets changed

42
00:01:41,119 --> 00:01:43,439
because one transmitter has been lost or

43
00:01:43,439 --> 00:01:45,840
stolen and everybody has to come to the

44
00:01:45,840 --> 00:01:47,680
gate to get their transmitters updated

45
00:01:47,680 --> 00:01:49,200
to the new code

46
00:01:49,200 --> 00:01:51,200
these are rather inconvenient for 26

47
00:01:51,200 --> 00:01:53,520
households i definitely did not want to

48
00:01:53,520 --> 00:01:54,399
try that

49
00:01:54,399 --> 00:01:57,680
in an even larger group

50
00:01:59,119 --> 00:02:00,880
we also wanted to have something a bit

51
00:02:00,880 --> 00:02:02,640
better than the average gate remote

52
00:02:02,640 --> 00:02:04,479
because of smart people like andrew

53
00:02:04,479 --> 00:02:08,239
mohawk who demonstrated in 2012 how to

54
00:02:08,239 --> 00:02:11,200
snoop and replay fixed code remotes

55
00:02:11,200 --> 00:02:13,280
he managed to read to decode the bit

56
00:02:13,280 --> 00:02:16,000
pattern transmitted and replay arbitrary

57
00:02:16,000 --> 00:02:18,400
codes using a cheap transmitter

58
00:02:18,400 --> 00:02:20,879
not great for a community of 150

59
00:02:20,879 --> 00:02:22,560
households to have to go out and buy a

60
00:02:22,560 --> 00:02:24,959
whole new set of remotes when this sort

61
00:02:24,959 --> 00:02:27,360
of thing starts getting out

62
00:02:27,360 --> 00:02:29,920
so right off the bat we wanted something

63
00:02:29,920 --> 00:02:33,679
that would be a bit better

64
00:02:35,360 --> 00:02:37,120
centurion gate motors are pretty much

65
00:02:37,120 --> 00:02:38,720
the gold standard for gate motors in

66
00:02:38,720 --> 00:02:40,959
south africa i think i'm really not

67
00:02:40,959 --> 00:02:42,800
aware of anyone else that has close to

68
00:02:42,800 --> 00:02:44,640
the market penetration that centurion

69
00:02:44,640 --> 00:02:45,519
does

70
00:02:45,519 --> 00:02:48,000
we ended up going with the d5 evo which

71
00:02:48,000 --> 00:02:50,480
was well suited to our requirements

72
00:02:50,480 --> 00:02:52,560
this is quite a smart controller with

73
00:02:52,560 --> 00:02:54,400
time of day settings to open and close

74
00:02:54,400 --> 00:02:56,959
the gates perfect for our access permit

75
00:02:56,959 --> 00:02:58,319
conditions

76
00:02:58,319 --> 00:03:00,000
it also has a built-in receiver for

77
00:03:00,000 --> 00:03:02,319
remotes which use the key lock system

78
00:03:02,319 --> 00:03:05,839
sounds perfect right

79
00:03:07,120 --> 00:03:09,280
looking at the documentation it turns

80
00:03:09,280 --> 00:03:11,040
out that the controller is capable of

81
00:03:11,040 --> 00:03:13,040
learning up to 500

82
00:03:13,040 --> 00:03:14,000
nova

83
00:03:14,000 --> 00:03:18,239
rolling code remote control buttons

84
00:03:18,239 --> 00:03:19,680
while this may have been feasible to

85
00:03:19,680 --> 00:03:22,080
manage the remotes for 150 households

86
00:03:22,080 --> 00:03:24,159
directly on the gate controller and it

87
00:03:24,159 --> 00:03:25,680
would start getting tight if each

88
00:03:25,680 --> 00:03:28,159
household had more than three remotes it

89
00:03:28,159 --> 00:03:29,680
was not possible to coordinate the

90
00:03:29,680 --> 00:03:31,840
configuration between two gates

91
00:03:31,840 --> 00:03:33,840
at the top and bottom of the street

92
00:03:33,840 --> 00:03:36,239
and that at the time at any rate

93
00:03:36,239 --> 00:03:36,959
and

94
00:03:36,959 --> 00:03:39,680
and then their super helix receiver was

95
00:03:39,680 --> 00:03:42,720
not yet available

96
00:03:45,040 --> 00:03:47,120
so this is where we ended up a receiver

97
00:03:47,120 --> 00:03:49,360
that can accommodate up to 8000 enrolled

98
00:03:49,360 --> 00:03:52,959
transmitters splits across two relays

99
00:03:52,959 --> 00:03:55,040
and then the matter of of managing the

100
00:03:55,040 --> 00:03:57,200
transmitters arose since we had two

101
00:03:57,200 --> 00:03:58,720
gates we'd need to enroll the

102
00:03:58,720 --> 00:04:01,040
transmitters into both receivers as well

103
00:04:01,040 --> 00:04:02,879
as having backups in case anything

104
00:04:02,879 --> 00:04:04,879
happened to the receivers

105
00:04:04,879 --> 00:04:07,280
fortunately the vendor provides an app

106
00:04:07,280 --> 00:04:09,040
to manage the database including in

107
00:04:09,040 --> 00:04:12,400
rolling transmitters via usb cable which

108
00:04:12,400 --> 00:04:13,519
was nice

109
00:04:13,519 --> 00:04:15,760
unfortunately the app was not exactly

110
00:04:15,760 --> 00:04:18,079
designed for mass enrollment requiring

111
00:04:18,079 --> 00:04:20,079
multiple clicks just to enroll a single

112
00:04:20,079 --> 00:04:22,880
transmitter on one relay then scroll

113
00:04:22,880 --> 00:04:24,960
through 4000 entries to get to this

114
00:04:24,960 --> 00:04:27,680
corresponding entry for the second relay

115
00:04:27,680 --> 00:04:29,040
and then back again for the next

116
00:04:29,040 --> 00:04:30,720
transmitter

117
00:04:30,720 --> 00:04:32,800
fortunately the app was written in dot

118
00:04:32,800 --> 00:04:34,960
net making it relatively easy to

119
00:04:34,960 --> 00:04:37,680
decompile and figure out how to speak to

120
00:04:37,680 --> 00:04:39,680
the receiver and capture the details of

121
00:04:39,680 --> 00:04:42,160
the buttons that were being pressed so i

122
00:04:42,160 --> 00:04:44,240
wrote the java app because that's what i

123
00:04:44,240 --> 00:04:46,400
know

124
00:04:46,639 --> 00:04:48,560
to interface with the receiver and

125
00:04:48,560 --> 00:04:50,320
simply increment the slot for each

126
00:04:50,320 --> 00:04:52,400
button alternating between the two

127
00:04:52,400 --> 00:04:54,560
relays dumping the data into the same

128
00:04:54,560 --> 00:04:56,960
sqlite database format used by the

129
00:04:56,960 --> 00:04:58,880
vendor app it would then export the

130
00:04:58,880 --> 00:05:01,039
database into a text file which could be

131
00:05:01,039 --> 00:05:03,840
saved onto a microsd card and taken to

132
00:05:03,840 --> 00:05:05,919
each gate to be loaded

133
00:05:05,919 --> 00:05:10,599
and so it worked for several years

134
00:05:12,400 --> 00:05:16,159
so let's talk about key lock itself

135
00:05:16,960 --> 00:05:18,639
in order for a

136
00:05:18,639 --> 00:05:21,280
secure remote control system

137
00:05:21,280 --> 00:05:24,000
to be implemented it's only possible if

138
00:05:24,000 --> 00:05:25,840
two conditions are met

139
00:05:25,840 --> 00:05:27,840
a large number of possible combinations

140
00:05:27,840 --> 00:05:30,080
must be available and the system may

141
00:05:30,080 --> 00:05:31,680
never respond twice to the same

142
00:05:31,680 --> 00:05:34,320
transmitted code

143
00:05:34,320 --> 00:05:36,320
so keylock was designed with these

144
00:05:36,320 --> 00:05:38,800
principle in mind back in the 80s right

145
00:05:38,800 --> 00:05:41,120
here in south africa

146
00:05:41,120 --> 00:05:43,280
it was then purchased by microchip in

147
00:05:43,280 --> 00:05:45,680
the mid 90s and ended up being used in

148
00:05:45,680 --> 00:05:47,919
remotes around the world including many

149
00:05:47,919 --> 00:05:50,479
motor car

150
00:05:50,840 --> 00:05:53,680
manufacturers the first requirement

151
00:05:53,680 --> 00:05:56,639
is achieved by transmitting a 66-bit

152
00:05:56,639 --> 00:05:59,039
code word resulting in a much larger

153
00:05:59,039 --> 00:06:01,120
search space than the 10-bit code word

154
00:06:01,120 --> 00:06:03,919
that andrew was able to brute-force

155
00:06:03,919 --> 00:06:06,560
the second requirement is achieved by

156
00:06:06,560 --> 00:06:09,120
including a 16 bit incrementing counter

157
00:06:09,120 --> 00:06:10,560
that is synchronized between the

158
00:06:10,560 --> 00:06:12,479
transmitter and the receiver the

159
00:06:12,479 --> 00:06:14,880
receiver will only react if the counter

160
00:06:14,880 --> 00:06:17,120
is greater than the last one it's seen

161
00:06:17,120 --> 00:06:21,199
or so a simple replay attack is foiled

162
00:06:21,199 --> 00:06:23,600
but hold on you might be thinking

163
00:06:23,600 --> 00:06:26,000
if it's just a single simple increment

164
00:06:26,000 --> 00:06:28,400
encounter surely the attacker can also

165
00:06:28,400 --> 00:06:30,240
increment the counter and play the next

166
00:06:30,240 --> 00:06:32,479
one in the sequence

167
00:06:32,479 --> 00:06:34,800
that attack is prevented by encrypting

168
00:06:34,800 --> 00:06:37,440
the counter and some other data

169
00:06:37,440 --> 00:06:39,280
using a shared key that is unique to

170
00:06:39,280 --> 00:06:40,720
each transmitter

171
00:06:40,720 --> 00:06:43,199
resulting in a 32-bit scrambled block

172
00:06:43,199 --> 00:06:45,120
making up part of those previously

173
00:06:45,120 --> 00:06:48,560
mentioned 66 bits so no it's not truly a

174
00:06:48,560 --> 00:06:52,080
66 bit random space only 32 bits the

175
00:06:52,080 --> 00:06:54,960
remaining 34 bits have specific meanings

176
00:06:54,960 --> 00:06:58,000
and are not random

177
00:06:58,880 --> 00:07:00,880
so the fact that it's reduced from 66

178
00:07:00,880 --> 00:07:03,919
down to 32 bits is less of an issue if

179
00:07:03,919 --> 00:07:06,400
you don't have an offline oracle to tell

180
00:07:06,400 --> 00:07:08,560
you when you find the right value though

181
00:07:08,560 --> 00:07:11,280
and have to actually do the transmission

182
00:07:11,280 --> 00:07:14,000
and observe the receiver's actions

183
00:07:14,000 --> 00:07:16,080
the vendor estimated that it would take

184
00:07:16,080 --> 00:07:17,840
in the order of billions of years to

185
00:07:17,840 --> 00:07:19,120
iterate all through all the

186
00:07:19,120 --> 00:07:21,440
possibilities making it

187
00:07:21,440 --> 00:07:23,440
pretty infeasible to attack using brute

188
00:07:23,440 --> 00:07:25,120
force

189
00:07:25,120 --> 00:07:27,120
this is analogous to running hashcat on

190
00:07:27,120 --> 00:07:28,880
a leaked password hash

191
00:07:28,880 --> 00:07:30,720
compared to attempting a brute force

192
00:07:30,720 --> 00:07:33,840
attack login via the login form of your

193
00:07:33,840 --> 00:07:36,239
target

194
00:07:38,000 --> 00:07:39,360
one of the things that they had to

195
00:07:39,360 --> 00:07:41,479
consider in their design was

196
00:07:41,479 --> 00:07:44,319
desynchronization though if the

197
00:07:44,319 --> 00:07:45,599
transmitter

198
00:07:45,599 --> 00:07:47,680
button is pressed outside of the range

199
00:07:47,680 --> 00:07:50,319
of the receiver at some point that

200
00:07:50,319 --> 00:07:52,319
counter is going to be

201
00:07:52,319 --> 00:07:55,919
larger than the gates counter

202
00:07:55,919 --> 00:07:59,360
so logic was designed to

203
00:07:59,360 --> 00:08:01,039
account for this

204
00:08:01,039 --> 00:08:04,080
generally what happens is that if the

205
00:08:04,080 --> 00:08:07,840
received value is within 16

206
00:08:07,840 --> 00:08:09,919
of the

207
00:08:09,919 --> 00:08:13,199
of the last value seen by the receiver

208
00:08:13,199 --> 00:08:15,919
it will immediately update

209
00:08:15,919 --> 00:08:18,800
its stored value and operate

210
00:08:18,800 --> 00:08:20,639
its action

211
00:08:20,639 --> 00:08:23,280
if it's more than 16 values away

212
00:08:23,280 --> 00:08:25,840
it will simply store the last value that

213
00:08:25,840 --> 00:08:28,240
it's seen temporarily

214
00:08:28,240 --> 00:08:30,240
and then if the very next value that it

215
00:08:30,240 --> 00:08:31,120
sees

216
00:08:31,120 --> 00:08:33,839
is the next sequence number it will

217
00:08:33,839 --> 00:08:36,880
update the value that is stored for that

218
00:08:36,880 --> 00:08:39,360
particular transmitter

219
00:08:39,360 --> 00:08:41,760
and so the synchronization

220
00:08:41,760 --> 00:08:44,800
can be restored

221
00:08:50,800 --> 00:08:53,519
some failure modes of these transmitters

222
00:08:53,519 --> 00:08:54,560
well

223
00:08:54,560 --> 00:08:57,440
there's two which is actually

224
00:08:57,440 --> 00:08:59,440
slightly different to

225
00:08:59,440 --> 00:09:00,959
the

226
00:09:00,959 --> 00:09:03,120
more conventional

227
00:09:03,120 --> 00:09:04,399
transmitters

228
00:09:04,399 --> 00:09:05,839
in this case

229
00:09:05,839 --> 00:09:07,680
if you can clone

230
00:09:07,680 --> 00:09:10,160
with enough information you can clone a

231
00:09:10,160 --> 00:09:12,320
remote and you can

232
00:09:12,320 --> 00:09:14,160
trigger its actions

233
00:09:14,160 --> 00:09:16,959
similarly to the legitimate remote

234
00:09:16,959 --> 00:09:18,640
but there's a second

235
00:09:18,640 --> 00:09:22,000
failure mode which is denial of service

236
00:09:22,000 --> 00:09:25,920
if i can convince the

237
00:09:25,920 --> 00:09:26,720
the

238
00:09:26,720 --> 00:09:28,240
receiver

239
00:09:28,240 --> 00:09:31,519
to accept a forged transmission i can

240
00:09:31,519 --> 00:09:33,440
increment that

241
00:09:33,440 --> 00:09:35,279
that counter value

242
00:09:35,279 --> 00:09:38,320
beyond the 32 000

243
00:09:38,320 --> 00:09:40,080
32k window

244
00:09:40,080 --> 00:09:41,360
and

245
00:09:41,360 --> 00:09:44,000
stop the prevent the original

246
00:09:44,000 --> 00:09:49,000
transmitter from functioning at all

247
00:09:51,440 --> 00:09:53,839
so let's talk about about the

248
00:09:53,839 --> 00:09:55,600
what the transmissions look like over

249
00:09:55,600 --> 00:09:56,959
the air

250
00:09:56,959 --> 00:09:58,560
transmitters use

251
00:09:58,560 --> 00:10:01,760
amplitude shift keying and on off keying

252
00:10:01,760 --> 00:10:04,800
to transmit the 66 bits surrounded by a

253
00:10:04,800 --> 00:10:07,040
preamble and a header and ended by a

254
00:10:07,040 --> 00:10:10,880
guide period of no transmission

255
00:10:11,120 --> 00:10:13,360
the

256
00:10:13,360 --> 00:10:17,519
transmitters use varying lengths of

257
00:10:17,519 --> 00:10:20,399
positives and zero

258
00:10:20,800 --> 00:10:23,680
ones and zeros or should i say highs and

259
00:10:23,680 --> 00:10:24,959
lows

260
00:10:24,959 --> 00:10:29,040
to convey a logic zero or a logic one

261
00:10:29,040 --> 00:10:31,360
those are then combined

262
00:10:31,360 --> 00:10:34,720
into a complete transmission

263
00:10:34,720 --> 00:10:37,200
starting with the preamble the header

264
00:10:37,200 --> 00:10:38,480
the encrypted portion of the

265
00:10:38,480 --> 00:10:41,120
transmission being 32 bits the fixed

266
00:10:41,120 --> 00:10:43,760
portion of the transmission being 34

267
00:10:43,760 --> 00:10:46,640
bits and then the guard time to signal

268
00:10:46,640 --> 00:10:50,079
the end of the transmission

269
00:10:52,000 --> 00:10:53,440
then the

270
00:10:53,440 --> 00:10:56,720
breakdown of the encrypted and

271
00:10:56,720 --> 00:10:59,040
clear text portions and note that it is

272
00:10:59,040 --> 00:11:00,800
back to front because it's transmitted

273
00:11:00,800 --> 00:11:04,160
least significant but first

274
00:11:04,720 --> 00:11:07,760
the encrypted portion contains the

275
00:11:07,760 --> 00:11:10,160
synchronization counter which is a 16

276
00:11:10,160 --> 00:11:11,920
bit value

277
00:11:11,920 --> 00:11:14,480
it contains 10 bits used for

278
00:11:14,480 --> 00:11:16,079
discrimination

279
00:11:16,079 --> 00:11:17,920
that allows you to verify that you've

280
00:11:17,920 --> 00:11:20,240
decrypted the correct portion

281
00:11:20,240 --> 00:11:21,279
um

282
00:11:21,279 --> 00:11:24,399
you know the correct

283
00:11:25,680 --> 00:11:28,240
that what you have decrypted matches the

284
00:11:28,240 --> 00:11:31,200
fixed portion of the transmission

285
00:11:31,200 --> 00:11:32,320
there are

286
00:11:32,320 --> 00:11:34,959
two bits for overflows

287
00:11:34,959 --> 00:11:37,440
and then there are the four bits of the

288
00:11:37,440 --> 00:11:39,760
battens that were being pressed

289
00:11:39,760 --> 00:11:41,920
then in the fixed portion you've got the

290
00:11:41,920 --> 00:11:44,399
serial number of the transmitter being

291
00:11:44,399 --> 00:11:46,000
28 bits

292
00:11:46,000 --> 00:11:48,160
the button's repeated which allows you

293
00:11:48,160 --> 00:11:51,120
to verify that the transmission

294
00:11:51,120 --> 00:11:52,639
the fixed portion and the encrypted

295
00:11:52,639 --> 00:11:54,639
portion matches up

296
00:11:54,639 --> 00:11:57,839
then two bits for statuses

297
00:11:57,839 --> 00:12:00,320
voltage low and repeat

298
00:12:00,320 --> 00:12:02,320
allow you to determine whether the

299
00:12:02,320 --> 00:12:04,560
button has been held down and also

300
00:12:04,560 --> 00:12:08,920
whether the battery is about to die

301
00:12:10,320 --> 00:12:12,639
okay so the counter is encrypted

302
00:12:12,639 --> 00:12:14,639
to prevent it from being

303
00:12:14,639 --> 00:12:16,399
tampered with

304
00:12:16,399 --> 00:12:18,560
and this is done using a

305
00:12:18,560 --> 00:12:20,399
shared key

306
00:12:20,399 --> 00:12:22,560
symmetric key known by both the

307
00:12:22,560 --> 00:12:25,839
transmitter and the receiver

308
00:12:26,000 --> 00:12:27,120
how is this

309
00:12:27,120 --> 00:12:29,920
key shared between the receiver and the

310
00:12:29,920 --> 00:12:31,519
transmitter then

311
00:12:31,519 --> 00:12:33,519
well the key lock documentation actually

312
00:12:33,519 --> 00:12:36,160
leaves the key derivation function up to

313
00:12:36,160 --> 00:12:38,000
the implementer although there is a

314
00:12:38,000 --> 00:12:40,160
reference implementation that appears to

315
00:12:40,160 --> 00:12:43,200
be used in practice

316
00:12:43,200 --> 00:12:44,800
there are two forms of learning or

317
00:12:44,800 --> 00:12:47,200
enrollment in classic keylock normal

318
00:12:47,200 --> 00:12:49,920
learn and secure learn

319
00:12:49,920 --> 00:12:52,320
in the normal learn process the key is

320
00:12:52,320 --> 00:12:55,120
derived from a combination of a 64-bit

321
00:12:55,120 --> 00:12:57,360
manufacturer key which must be kept

322
00:12:57,360 --> 00:12:58,959
completely secret

323
00:12:58,959 --> 00:13:01,200
and the unique 28-bit serial number of

324
00:13:01,200 --> 00:13:03,839
the transmitter used as input into the

325
00:13:03,839 --> 00:13:06,320
manufacturer's chosen key derivation

326
00:13:06,320 --> 00:13:07,440
function

327
00:13:07,440 --> 00:13:09,440
the same function is used when

328
00:13:09,440 --> 00:13:11,600
programming the transmitter to generate

329
00:13:11,600 --> 00:13:13,519
a unique key that is written to the

330
00:13:13,519 --> 00:13:15,519
right only memory in the chip

331
00:13:15,519 --> 00:13:17,680
as is

332
00:13:17,680 --> 00:13:19,600
used in the receiver to derive the

333
00:13:19,600 --> 00:13:20,880
shared key

334
00:13:20,880 --> 00:13:23,040
in this way the receiver does not need

335
00:13:23,040 --> 00:13:24,480
to know the keys of all possible

336
00:13:24,480 --> 00:13:26,800
transmitters in advance but can derive

337
00:13:26,800 --> 00:13:28,639
them when needed

338
00:13:28,639 --> 00:13:30,560
unfortunately this does mean that the

339
00:13:30,560 --> 00:13:33,040
receiver by necessity must contain a

340
00:13:33,040 --> 00:13:35,760
copy of the 64-bit manufacturer key and

341
00:13:35,760 --> 00:13:38,079
therefore needs to implement controls to

342
00:13:38,079 --> 00:13:40,240
ensure that this key does not leak or

343
00:13:40,240 --> 00:13:42,800
else the entire ecosystem that shares

344
00:13:42,800 --> 00:13:45,680
that manufacturer key and key derivation

345
00:13:45,680 --> 00:13:49,040
function would be compromised

346
00:13:49,040 --> 00:13:50,480
the problem with the normal learn

347
00:13:50,480 --> 00:13:52,880
process is that one of the inputs into

348
00:13:52,880 --> 00:13:55,360
the key derivation function is exposed

349
00:13:55,360 --> 00:13:57,279
every time the remote is operated

350
00:13:57,279 --> 00:13:59,279
because the serial number is included in

351
00:13:59,279 --> 00:14:00,800
the transmission

352
00:14:00,800 --> 00:14:02,639
an attacker who knows the manufacturer

353
00:14:02,639 --> 00:14:04,880
key and the key derivation function can

354
00:14:04,880 --> 00:14:06,959
derive the same encryption key and

355
00:14:06,959 --> 00:14:10,560
generate forged transmissions

356
00:14:11,040 --> 00:14:13,760
as a result keylock included a secure

357
00:14:13,760 --> 00:14:15,839
learn process

358
00:14:15,839 --> 00:14:18,160
in this process the key is derived from

359
00:14:18,160 --> 00:14:20,639
a combination of the 64-bit manufacturer

360
00:14:20,639 --> 00:14:23,839
key and a 32-bit random seed used as

361
00:14:23,839 --> 00:14:26,560
input into the chosen key derivation

362
00:14:26,560 --> 00:14:27,680
function

363
00:14:27,680 --> 00:14:30,880
the random seed is only transmitted when

364
00:14:30,880 --> 00:14:33,360
a combination of keys or buttons on the

365
00:14:33,360 --> 00:14:36,480
transmitter are pressed

366
00:14:36,480 --> 00:14:38,480
and is only used

367
00:14:38,480 --> 00:14:40,000
and this is only done

368
00:14:40,000 --> 00:14:43,279
when enrolling a transmitter onto a

369
00:14:43,279 --> 00:14:44,800
receiver

370
00:14:44,800 --> 00:14:47,120
in the normal way of things the seed is

371
00:14:47,120 --> 00:14:50,399
never transmitted

372
00:14:50,720 --> 00:14:51,839
in fact

373
00:14:51,839 --> 00:14:54,480
the transmitters can be programmed that

374
00:14:54,480 --> 00:14:57,199
after a few operations that seed may

375
00:14:57,199 --> 00:15:00,719
never be transmitted again

376
00:15:01,199 --> 00:15:05,519
this helps to keep the seed protected

377
00:15:07,120 --> 00:15:08,880
so let's talk about the key derivation

378
00:15:08,880 --> 00:15:10,160
functions then

379
00:15:10,160 --> 00:15:11,839
the manufacturer knows the key

380
00:15:11,839 --> 00:15:14,240
derivation function and the manufacturer

381
00:15:14,240 --> 00:15:16,000
key

382
00:15:16,000 --> 00:15:18,000
they use this

383
00:15:18,000 --> 00:15:20,240
kdf in the manufacturer key

384
00:15:20,240 --> 00:15:22,639
and the transmitter serial number to

385
00:15:22,639 --> 00:15:24,959
program the transmitter with a shared

386
00:15:24,959 --> 00:15:28,639
key and that serial number

387
00:15:28,639 --> 00:15:31,120
the receiver contains an implementation

388
00:15:31,120 --> 00:15:33,279
of the key derivation function as well

389
00:15:33,279 --> 00:15:35,199
as the manufacturer key

390
00:15:35,199 --> 00:15:36,880
it receives the transmitter serial

391
00:15:36,880 --> 00:15:40,160
number or the seed and from that it can

392
00:15:40,160 --> 00:15:43,199
derive a shared key

393
00:15:43,199 --> 00:15:45,360
so the transmitter then

394
00:15:45,360 --> 00:15:46,720
will

395
00:15:46,720 --> 00:15:48,800
encrypt its counter using that shared

396
00:15:48,800 --> 00:15:49,680
key

397
00:15:49,680 --> 00:15:51,680
and the receiver can then

398
00:15:51,680 --> 00:15:52,880
decrypt

399
00:15:52,880 --> 00:15:55,839
that as well

400
00:15:58,320 --> 00:16:00,000
so this is the

401
00:16:00,000 --> 00:16:02,800
manufacturer's suggested

402
00:16:02,800 --> 00:16:04,800
key generation function or key

403
00:16:04,800 --> 00:16:06,639
derivation function

404
00:16:06,639 --> 00:16:08,959
based on the serial number

405
00:16:08,959 --> 00:16:13,360
which is 28 bits so we mask off the top

406
00:16:13,360 --> 00:16:15,040
four bits to make sure that the function

407
00:16:15,040 --> 00:16:16,800
code is not included

408
00:16:16,800 --> 00:16:20,000
and then we decrypt the serial number

409
00:16:20,000 --> 00:16:21,279
combined

410
00:16:21,279 --> 00:16:24,959
with a 6 in those first 4 bits

411
00:16:24,959 --> 00:16:25,920
and then

412
00:16:25,920 --> 00:16:28,639
we combine that we shift that over 32

413
00:16:28,639 --> 00:16:29,519
bits

414
00:16:29,519 --> 00:16:31,600
and combine that

415
00:16:31,600 --> 00:16:32,480
with

416
00:16:32,480 --> 00:16:33,759
the same

417
00:16:33,759 --> 00:16:35,120
process

418
00:16:35,120 --> 00:16:39,199
just simply changing the six for a two

419
00:16:41,360 --> 00:16:42,560
it's relatively simple and

420
00:16:42,560 --> 00:16:43,759
straightforward

421
00:16:43,759 --> 00:16:45,759
but as you can see if you do know what

422
00:16:45,759 --> 00:16:48,320
that serial number is and the the

423
00:16:48,320 --> 00:16:51,120
manufacturer key then you can derive

424
00:16:51,120 --> 00:16:54,000
those shared keys

425
00:16:55,279 --> 00:16:57,279
so what attacks have been tried against

426
00:16:57,279 --> 00:16:59,759
keylock

427
00:17:00,399 --> 00:17:03,360
environments or ecosystems

428
00:17:03,360 --> 00:17:04,880
one approach has been to perform

429
00:17:04,880 --> 00:17:07,280
cryptanalysis

430
00:17:07,280 --> 00:17:09,760
and they have found specific weaknesses

431
00:17:09,760 --> 00:17:13,839
primarily due to implementation flaws

432
00:17:13,839 --> 00:17:14,799
their

433
00:17:14,799 --> 00:17:16,799
calculations

434
00:17:16,799 --> 00:17:19,359
based in 2007

435
00:17:19,359 --> 00:17:21,359
were able to reduce the effort

436
00:17:21,359 --> 00:17:24,480
to crack a single transmission down to

437
00:17:24,480 --> 00:17:27,679
approximately two weeks of fpga assisted

438
00:17:27,679 --> 00:17:29,280
calculations

439
00:17:29,280 --> 00:17:31,760
not really practical

440
00:17:31,760 --> 00:17:34,640
depending on

441
00:17:35,440 --> 00:17:37,039
exactly what it is that you're trying to

442
00:17:37,039 --> 00:17:40,559
approach or trying to attack

443
00:17:41,280 --> 00:17:44,720
another approach which has been

444
00:17:44,880 --> 00:17:46,400
much more effective

445
00:17:46,400 --> 00:17:49,120
is to perform side channel attacks

446
00:17:49,120 --> 00:17:51,520
in this way they performed a

447
00:17:51,520 --> 00:17:53,760
differential power analysis

448
00:17:53,760 --> 00:17:56,720
by monitoring the

449
00:17:56,720 --> 00:17:59,600
the use of

450
00:17:59,600 --> 00:18:01,919
or the power use of the receiver or the

451
00:18:01,919 --> 00:18:04,000
transmitter

452
00:18:04,000 --> 00:18:06,160
while it's performing its cryptographic

453
00:18:06,160 --> 00:18:08,960
operations they were able to determine

454
00:18:08,960 --> 00:18:12,960
what values the keys had

455
00:18:13,280 --> 00:18:15,520
by looking at the precise power

456
00:18:15,520 --> 00:18:16,880
consumption

457
00:18:16,880 --> 00:18:18,720
using very

458
00:18:18,720 --> 00:18:20,400
accurate

459
00:18:20,400 --> 00:18:23,360
monitoring systems

460
00:18:23,360 --> 00:18:24,880
and in this way they were able to

461
00:18:24,880 --> 00:18:27,520
extract the key the unique key from a

462
00:18:27,520 --> 00:18:28,799
transmitter

463
00:18:28,799 --> 00:18:31,039
or the manufacturer key from the

464
00:18:31,039 --> 00:18:32,559
receiver

465
00:18:32,559 --> 00:18:35,919
and this is ultimately a complete break

466
00:18:35,919 --> 00:18:39,600
however it does require you to

467
00:18:39,600 --> 00:18:41,280
customize your attack

468
00:18:41,280 --> 00:18:44,640
for the particular transmitter

469
00:18:44,640 --> 00:18:46,799
well if you attack a single transmitter

470
00:18:46,799 --> 00:18:48,720
you get one key and you would need to

471
00:18:48,720 --> 00:18:51,360
repeat it for each transmitter

472
00:18:51,360 --> 00:18:52,799
and then

473
00:18:52,799 --> 00:18:54,400
you would need to customize your attack

474
00:18:54,400 --> 00:18:57,360
and understand the implementation

475
00:18:57,360 --> 00:18:59,280
of the crypto algorithms on each

476
00:18:59,280 --> 00:19:01,840
receiver as well as

477
00:19:01,840 --> 00:19:03,120
performing it

478
00:19:03,120 --> 00:19:03,919
for

479
00:19:03,919 --> 00:19:05,520
each

480
00:19:05,520 --> 00:19:08,559
cpu architecture or implementation for

481
00:19:08,559 --> 00:19:11,039
each different manufacturer

482
00:19:11,039 --> 00:19:12,720
so depending on

483
00:19:12,720 --> 00:19:15,440
which cpu family or microprocessor

484
00:19:15,440 --> 00:19:18,400
family the vendor is using you may need

485
00:19:18,400 --> 00:19:20,640
to

486
00:19:20,799 --> 00:19:22,480
conduct this attack

487
00:19:22,480 --> 00:19:25,760
several times

488
00:19:25,760 --> 00:19:26,720
and then

489
00:19:26,720 --> 00:19:28,799
in 2015

490
00:19:28,799 --> 00:19:31,039
sammy camkar demonstrated

491
00:19:31,039 --> 00:19:32,720
replay attacks

492
00:19:32,720 --> 00:19:33,919
which

493
00:19:33,919 --> 00:19:36,240
supposedly should be impossible

494
00:19:36,240 --> 00:19:40,240
but he realized that if he jammed one's

495
00:19:40,240 --> 00:19:42,720
transmission while recording it

496
00:19:42,720 --> 00:19:45,200
and you can jam

497
00:19:45,200 --> 00:19:47,760
you can allow the first 60 or so bits to

498
00:19:47,760 --> 00:19:49,840
be passed through and then override the

499
00:19:49,840 --> 00:19:53,039
last four which you can

500
00:19:53,039 --> 00:19:54,720
reconstruct yourself so you don't need

501
00:19:54,720 --> 00:19:57,200
to know what they were

502
00:19:57,200 --> 00:19:59,440
then jam and record a second

503
00:19:59,440 --> 00:20:03,600
transmission while replaying the first

504
00:20:03,600 --> 00:20:08,559
and in doing so you would end up with a

505
00:20:08,559 --> 00:20:11,039
a single transmission that you could use

506
00:20:11,039 --> 00:20:13,120
at a later point

507
00:20:13,120 --> 00:20:15,440
while the user

508
00:20:15,440 --> 00:20:16,240
is

509
00:20:16,240 --> 00:20:20,640
you know has walked away from their car

510
00:20:20,640 --> 00:20:22,240
the problem with this is that it only

511
00:20:22,240 --> 00:20:24,000
gets you that single opportunity to

512
00:20:24,000 --> 00:20:26,240
reuse your capture transmission and

513
00:20:26,240 --> 00:20:29,280
probably a limited window to use it in

514
00:20:29,280 --> 00:20:30,640
of course if the

515
00:20:30,640 --> 00:20:33,360
user if you haven't used it by the time

516
00:20:33,360 --> 00:20:35,360
the

517
00:20:35,360 --> 00:20:38,320
the car or the driver comes back and

518
00:20:38,320 --> 00:20:40,320
unlocks their car

519
00:20:40,320 --> 00:20:42,400
that captured transmission is

520
00:20:42,400 --> 00:20:46,440
immediately invalidated

521
00:20:50,640 --> 00:20:52,400
but there's another attack

522
00:20:52,400 --> 00:20:54,559
that you could possibly perform

523
00:20:54,559 --> 00:20:56,880
that doesn't rely on differential power

524
00:20:56,880 --> 00:21:00,799
analysis or super complex equipment and

525
00:21:00,799 --> 00:21:03,679
so on it doesn't actually require a

526
00:21:03,679 --> 00:21:04,960
whole lot of

527
00:21:04,960 --> 00:21:07,200
deep technical knowledge either which is

528
00:21:07,200 --> 00:21:09,280
good

529
00:21:09,280 --> 00:21:11,840
in my case

530
00:21:11,840 --> 00:21:14,480
and that attack is to actually extract

531
00:21:14,480 --> 00:21:15,840
the firmware

532
00:21:15,840 --> 00:21:16,720
from

533
00:21:16,720 --> 00:21:17,600
the

534
00:21:17,600 --> 00:21:18,960
receiver

535
00:21:18,960 --> 00:21:20,640
and

536
00:21:20,640 --> 00:21:22,799
reverse engineer it to

537
00:21:22,799 --> 00:21:25,520
retrieve that manufacturer key

538
00:21:25,520 --> 00:21:26,720
now of course

539
00:21:26,720 --> 00:21:30,000
in most cases this shouldn't be possible

540
00:21:30,000 --> 00:21:33,360
if the vendor has set up their receivers

541
00:21:33,360 --> 00:21:34,480
properly

542
00:21:34,480 --> 00:21:37,600
in my case it turns out that

543
00:21:37,600 --> 00:21:40,720
they hadn't disabled debugging

544
00:21:40,720 --> 00:21:43,440
and it was possible to extract that

545
00:21:43,440 --> 00:21:47,120
probe now that firmware

546
00:21:52,159 --> 00:21:54,080
and so

547
00:21:54,080 --> 00:21:56,320
i did my i was able to extract the

548
00:21:56,320 --> 00:21:57,440
firmware

549
00:21:57,440 --> 00:21:59,039
and

550
00:21:59,039 --> 00:22:02,000
started learning how to use gedra

551
00:22:02,000 --> 00:22:03,919
which has support for bare metal arm

552
00:22:03,919 --> 00:22:07,280
binaries in this particular case the cpu

553
00:22:07,280 --> 00:22:09,919
in question is a

554
00:22:09,919 --> 00:22:12,480
made by st microelectronics and

555
00:22:12,480 --> 00:22:15,480
stm32f103

556
00:22:18,720 --> 00:22:20,720
so gidro has support for

557
00:22:20,720 --> 00:22:22,960
for on binaries

558
00:22:22,960 --> 00:22:24,080
and

559
00:22:24,080 --> 00:22:27,280
so i started out like loading it up into

560
00:22:27,280 --> 00:22:29,280
ghetto and trying to make head or tail

561
00:22:29,280 --> 00:22:31,039
of what was going on

562
00:22:31,039 --> 00:22:33,360
it was quite a learning curve

563
00:22:33,360 --> 00:22:35,360
never having done any reverse

564
00:22:35,360 --> 00:22:37,440
engineering at a machine code level

565
00:22:37,440 --> 00:22:40,640
before i decompile java but that's not

566
00:22:40,640 --> 00:22:43,440
the same thing at all

567
00:22:43,440 --> 00:22:45,039
fortunately for me

568
00:22:45,039 --> 00:22:46,480
gedra has

569
00:22:46,480 --> 00:22:49,200
a mode where it can decompile the

570
00:22:49,200 --> 00:22:53,039
machine code into approximate c code

571
00:22:53,039 --> 00:22:55,440
and that certainly made my life a lot

572
00:22:55,440 --> 00:22:57,919
easier

573
00:22:59,280 --> 00:23:00,960
one very useful tool

574
00:23:00,960 --> 00:23:02,960
which i found quite helpful

575
00:23:02,960 --> 00:23:05,360
was svd loader

576
00:23:05,360 --> 00:23:08,480
what this does is it automates

577
00:23:08,480 --> 00:23:10,799
the complete generation of peripheral

578
00:23:10,799 --> 00:23:13,520
structures and memory maps for

579
00:23:13,520 --> 00:23:15,200
microcontrollers

580
00:23:15,200 --> 00:23:17,520
by parsing the system view description

581
00:23:17,520 --> 00:23:18,960
files

582
00:23:18,960 --> 00:23:22,080
svd loader is able to annotate all the

583
00:23:22,080 --> 00:23:24,080
peripherals of the controller

584
00:23:24,080 --> 00:23:26,000
simplifying reverse engineering

585
00:23:26,000 --> 00:23:27,520
significantly

586
00:23:27,520 --> 00:23:29,280
and what it does essentially is it

587
00:23:29,280 --> 00:23:32,240
translates memory offsets into

588
00:23:32,240 --> 00:23:34,720
peripheral names and labels

589
00:23:34,720 --> 00:23:38,960
so for example you can see that

590
00:23:39,039 --> 00:23:40,240
the value

591
00:23:40,240 --> 00:23:44,240
dat 4 double 0 0 double 0 0

592
00:23:44,240 --> 00:23:46,799
order with 0xc

593
00:23:46,799 --> 00:23:49,520
etc is actually

594
00:23:49,520 --> 00:23:52,159
part of the bluetooth controller of

595
00:23:52,159 --> 00:23:54,400
the particular chip being used in this

596
00:23:54,400 --> 00:23:56,880
example

597
00:23:58,320 --> 00:24:00,240
while it ended up not leading me to the

598
00:24:00,240 --> 00:24:02,720
relevant functions nonetheless it did

599
00:24:02,720 --> 00:24:04,880
make understanding what i was looking at

600
00:24:04,880 --> 00:24:07,679
a lot easier

601
00:24:08,720 --> 00:24:10,960
the next approach

602
00:24:10,960 --> 00:24:13,120
was to try following the code based on

603
00:24:13,120 --> 00:24:15,120
the strings which were displayed while

604
00:24:15,120 --> 00:24:16,840
enrolling a

605
00:24:16,840 --> 00:24:18,559
transmitter

606
00:24:18,559 --> 00:24:19,840
in particular

607
00:24:19,840 --> 00:24:21,200
you know press

608
00:24:21,200 --> 00:24:23,840
any key to

609
00:24:24,880 --> 00:24:26,400
to enroll

610
00:24:26,400 --> 00:24:28,960
was the the key so i tried to follow it

611
00:24:28,960 --> 00:24:31,440
by looking at references to the string

612
00:24:31,440 --> 00:24:32,559
press

613
00:24:32,559 --> 00:24:34,480
and

614
00:24:34,480 --> 00:24:37,840
went down a rabbit hole and ended up not

615
00:24:37,840 --> 00:24:39,520
being able to find it

616
00:24:39,520 --> 00:24:41,120
i think

617
00:24:41,120 --> 00:24:42,720
the problem was that

618
00:24:42,720 --> 00:24:43,600
the

619
00:24:43,600 --> 00:24:44,799
i ended up

620
00:24:44,799 --> 00:24:47,039
down a rabbit hole of display related

621
00:24:47,039 --> 00:24:50,080
code rather than finding anything using

622
00:24:50,080 --> 00:24:51,520
the radios

623
00:24:51,520 --> 00:24:54,159
and i also suspect that the radio

624
00:24:54,159 --> 00:24:56,559
related code was interrupt based

625
00:24:56,559 --> 00:24:59,039
rather than being part of

626
00:24:59,039 --> 00:25:02,000
a continuous loop

627
00:25:02,000 --> 00:25:03,919
so even though i was

628
00:25:03,919 --> 00:25:07,679
looking potentially in the right place

629
00:25:08,240 --> 00:25:12,600
i ended up not finding it this way

630
00:25:14,080 --> 00:25:16,640
then i ran into

631
00:25:16,640 --> 00:25:21,039
a blog post by a guy named david lodge

632
00:25:21,120 --> 00:25:23,840
tips for reverse engineering crypto code

633
00:25:23,840 --> 00:25:27,520
and this was invaluable to me

634
00:25:27,520 --> 00:25:29,360
although it did take me down some

635
00:25:29,360 --> 00:25:33,039
unproductive rabbit holes initially

636
00:25:33,520 --> 00:25:35,120
so always looking for strings and

637
00:25:35,120 --> 00:25:37,679
constants strings didn't help me but

638
00:25:37,679 --> 00:25:42,159
looking for constants absolutely did um

639
00:25:42,159 --> 00:25:44,640
make guesses about the original source

640
00:25:44,640 --> 00:25:45,600
or

641
00:25:45,600 --> 00:25:47,360
if you can find it

642
00:25:47,360 --> 00:25:49,279
find you know look for the actual source

643
00:25:49,279 --> 00:25:52,240
code the good news is that the source

644
00:25:52,240 --> 00:25:54,799
code for the key lock algorithms have

645
00:25:54,799 --> 00:25:57,440
actually been leaked on the internet

646
00:25:57,440 --> 00:25:59,520
it is supposedly protected by

647
00:25:59,520 --> 00:26:01,600
non-disclosure agreements but you can

648
00:26:01,600 --> 00:26:03,760
find it out there and there are a number

649
00:26:03,760 --> 00:26:06,559
of independent implementations

650
00:26:06,559 --> 00:26:10,080
of those crypto algorithms

651
00:26:10,080 --> 00:26:12,159
so that helps you to

652
00:26:12,159 --> 00:26:14,400
avoid making those guesses

653
00:26:14,400 --> 00:26:17,039
although it still doesn't entirely help

654
00:26:17,039 --> 00:26:17,220
you

655
00:26:17,220 --> 00:26:18,559
[Music]

656
00:26:18,559 --> 00:26:23,039
know exactly what is in the firmware

657
00:26:23,600 --> 00:26:24,960
um

658
00:26:24,960 --> 00:26:26,960
so i ended up looking for constants in

659
00:26:26,960 --> 00:26:29,840
the algorithms that i found online and

660
00:26:29,840 --> 00:26:32,720
that did take me down a number of

661
00:26:32,720 --> 00:26:35,039
rabbit holes the constants that i was

662
00:26:35,039 --> 00:26:37,120
looking for simply didn't exist in the

663
00:26:37,120 --> 00:26:40,239
firmware at all

664
00:26:40,559 --> 00:26:41,360
and

665
00:26:41,360 --> 00:26:44,159
so that left me scratching my head

666
00:26:44,159 --> 00:26:45,600
it turned out

667
00:26:45,600 --> 00:26:47,120
that

668
00:26:47,120 --> 00:26:48,240
because there are multiple

669
00:26:48,240 --> 00:26:50,080
implementations of the key lock

670
00:26:50,080 --> 00:26:51,120
algorithm

671
00:26:51,120 --> 00:26:54,640
i was looking at a rather more

672
00:26:54,640 --> 00:26:57,520
refined version

673
00:26:57,520 --> 00:27:00,159
than the original manufacturer code

674
00:27:00,159 --> 00:27:02,320
and

675
00:27:02,320 --> 00:27:03,760
as a result

676
00:27:03,760 --> 00:27:05,840
the the constants that i was looking for

677
00:27:05,840 --> 00:27:07,760
simply weren't present

678
00:27:07,760 --> 00:27:09,120
the

679
00:27:09,120 --> 00:27:11,360
constants in the manufacturer provided

680
00:27:11,360 --> 00:27:14,480
code were present and those quickly led

681
00:27:14,480 --> 00:27:17,520
me to the relevant functions

682
00:27:17,520 --> 00:27:19,120
so i'm not going to go as i mentioned

683
00:27:19,120 --> 00:27:20,880
i'm not going to go through the details

684
00:27:20,880 --> 00:27:22,880
of exactly how i found the manufacturer

685
00:27:22,880 --> 00:27:26,159
key because it's still in wide use and

686
00:27:26,159 --> 00:27:28,080
there is no plan from the vendor on how

687
00:27:28,080 --> 00:27:30,000
to rotate it

688
00:27:30,000 --> 00:27:32,640
i can imagine that this is a

689
00:27:32,640 --> 00:27:34,799
particularly complex problem they've

690
00:27:34,799 --> 00:27:37,200
sold thousands of these remotes and

691
00:27:37,200 --> 00:27:39,039
receivers out into

692
00:27:39,039 --> 00:27:40,960
south africa and

693
00:27:40,960 --> 00:27:42,880
out into africa as well

694
00:27:42,880 --> 00:27:44,640
and

695
00:27:44,640 --> 00:27:46,240
they don't actually have any way of

696
00:27:46,240 --> 00:27:49,360
getting hold of them as well as

697
00:27:49,360 --> 00:27:52,480
reprogramming all of them would be an

698
00:27:52,480 --> 00:27:54,480
incredibly

699
00:27:54,480 --> 00:27:57,120
complicated task

700
00:27:57,120 --> 00:28:00,080
so suffice to say if a noob like me can

701
00:28:00,080 --> 00:28:04,960
find it it was not too well protected

702
00:28:06,159 --> 00:28:06,960
so

703
00:28:06,960 --> 00:28:09,840
decoding the keylock code word

704
00:28:09,840 --> 00:28:11,440
i first wanted to make sure that i could

705
00:28:11,440 --> 00:28:13,600
decode the incoming transmissions from

706
00:28:13,600 --> 00:28:16,399
the radio chip using my pc

707
00:28:16,399 --> 00:28:18,240
before trying to implement the algorithm

708
00:28:18,240 --> 00:28:21,440
in c in a microcontroller it just

709
00:28:21,440 --> 00:28:24,080
is a much more friendly development

710
00:28:24,080 --> 00:28:25,520
environment

711
00:28:25,520 --> 00:28:28,880
and so what i did was i used a

712
00:28:28,880 --> 00:28:31,600
a cheap logic analyzer to tap the line

713
00:28:31,600 --> 00:28:33,679
between the rf decoder chip

714
00:28:33,679 --> 00:28:35,520
on the receiver board

715
00:28:35,520 --> 00:28:38,720
and the microprocessor and after much

716
00:28:38,720 --> 00:28:41,200
trial and error i was able to isolate

717
00:28:41,200 --> 00:28:44,080
the isolate the actual transmissions

718
00:28:44,080 --> 00:28:45,919
from the surrounding noise

719
00:28:45,919 --> 00:28:48,799
and start trying to decode them

720
00:28:48,799 --> 00:28:51,120
i use the cigarette project's pulse view

721
00:28:51,120 --> 00:28:53,840
ui to look at the results

722
00:28:53,840 --> 00:28:57,600
now there was no key lock decoder

723
00:28:57,600 --> 00:29:00,480
implemented and so

724
00:29:00,480 --> 00:29:03,120
i had to implement my own

725
00:29:03,120 --> 00:29:06,399
initially i was trying to decode

726
00:29:06,399 --> 00:29:08,320
an entirely incorrect portion of the

727
00:29:08,320 --> 00:29:09,520
captcha

728
00:29:09,520 --> 00:29:11,120
i finally managed to correlate the

729
00:29:11,120 --> 00:29:13,520
transmissions by soldering a wire to the

730
00:29:13,520 --> 00:29:15,840
transmitter button and monitoring that

731
00:29:15,840 --> 00:29:18,000
line at the same time as the radio

732
00:29:18,000 --> 00:29:19,440
receiver

733
00:29:19,440 --> 00:29:21,520
by focusing on the portion where the

734
00:29:21,520 --> 00:29:24,000
line was high i was able to identify the

735
00:29:24,000 --> 00:29:26,240
actual transmission and start trying to

736
00:29:26,240 --> 00:29:27,919
decode it

737
00:29:27,919 --> 00:29:30,159
eventually i had a python decoder

738
00:29:30,159 --> 00:29:32,000
implemented that gave me the same

739
00:29:32,000 --> 00:29:34,480
results as the original vendor firmwares

740
00:29:34,480 --> 00:29:37,520
for a specified transmission

741
00:29:37,520 --> 00:29:40,000
and this will be open source when i get

742
00:29:40,000 --> 00:29:42,240
around to submitting a pull request and

743
00:29:42,240 --> 00:29:46,000
share putting it through the process

744
00:29:46,720 --> 00:29:49,039
as you can see

745
00:29:49,039 --> 00:29:50,159
the

746
00:29:50,159 --> 00:29:51,840
individual nibbles

747
00:29:51,840 --> 00:29:53,039
can be

748
00:29:53,039 --> 00:29:55,840
extracted

749
00:29:56,880 --> 00:30:01,120
0 e c 8 etc but then those need to be

750
00:30:01,120 --> 00:30:03,840
read backwards because it is transmitted

751
00:30:03,840 --> 00:30:06,559
least significant but first

752
00:30:06,559 --> 00:30:10,240
and then you can see the serial number

753
00:30:10,240 --> 00:30:12,320
and then the button that was being

754
00:30:12,320 --> 00:30:14,000
transmitted or the buttons that were

755
00:30:14,000 --> 00:30:17,320
being pressed

756
00:30:25,039 --> 00:30:27,520
so that corresponds fairly closely to

757
00:30:27,520 --> 00:30:28,960
the diagram

758
00:30:28,960 --> 00:30:33,399
provided in the data sheet

759
00:30:37,840 --> 00:30:39,279
once i had

760
00:30:39,279 --> 00:30:42,399
a working decoder i then had to try and

761
00:30:42,399 --> 00:30:45,840
figure out how i was going to

762
00:30:45,840 --> 00:30:48,000
implement this on the hardware

763
00:30:48,000 --> 00:30:51,200
i went down an initial rabbit hole

764
00:30:51,200 --> 00:30:53,919
looking at lib open cm3

765
00:30:53,919 --> 00:30:56,240
which is a

766
00:30:56,240 --> 00:30:58,399
firmware environment for a number of

767
00:30:58,399 --> 00:31:02,480
arm-based microprocessors

768
00:31:02,480 --> 00:31:04,960
while it does provide a bunch of drivers

769
00:31:04,960 --> 00:31:06,880
and a whole lot of you know useful

770
00:31:06,880 --> 00:31:08,880
peripheral drivers

771
00:31:08,880 --> 00:31:10,399
um

772
00:31:10,399 --> 00:31:12,000
it would still have been quite an

773
00:31:12,000 --> 00:31:14,720
onerous process to re-implement

774
00:31:14,720 --> 00:31:17,919
based you know all of the functionality

775
00:31:17,919 --> 00:31:20,000
that i wanted

776
00:31:20,000 --> 00:31:21,919
for

777
00:31:21,919 --> 00:31:23,679
for managing the

778
00:31:23,679 --> 00:31:26,640
remote receiver as well as the relays

779
00:31:26,640 --> 00:31:30,080
and the buttons etc that existed on the

780
00:31:30,080 --> 00:31:31,760
existing hardware

781
00:31:31,760 --> 00:31:33,679
as well as things like over-the-air

782
00:31:33,679 --> 00:31:36,320
updates and such like

783
00:31:36,320 --> 00:31:38,080
and so i came across a project called

784
00:31:38,080 --> 00:31:39,360
esp home

785
00:31:39,360 --> 00:31:42,120
which is a system to control

786
00:31:42,120 --> 00:31:46,720
esp8266 and esp32 microprocessors

787
00:31:46,720 --> 00:31:51,440
using simple configuration files

788
00:31:52,440 --> 00:31:56,200
esp8266 and esp32 are

789
00:31:56,200 --> 00:31:59,279
microprocessors that have got built-in

790
00:31:59,279 --> 00:32:02,080
wi-fi interfaces and so you can

791
00:32:02,080 --> 00:32:04,000
interface with these

792
00:32:04,000 --> 00:32:07,919
from the rest of your wi-fi network

793
00:32:07,919 --> 00:32:12,000
however so this looked rather attractive

794
00:32:12,000 --> 00:32:14,559
but unfortunately this is a very

795
00:32:14,559 --> 00:32:18,559
different beast to the stm32 f-103

796
00:32:18,559 --> 00:32:21,919
arm-based microcontroller on the complex

797
00:32:21,919 --> 00:32:24,720
receiver that i had

798
00:32:24,720 --> 00:32:27,039
fortunately there is an arduino

799
00:32:27,039 --> 00:32:30,000
implementation for the stm32 family of

800
00:32:30,000 --> 00:32:31,200
chips

801
00:32:31,200 --> 00:32:33,200
and with a little bit of work i managed

802
00:32:33,200 --> 00:32:36,519
to get esp home running natively on the

803
00:32:36,519 --> 00:32:40,720
stm32 and on that complex receiver board

804
00:32:40,720 --> 00:32:42,320
one reason i think that this was a good

805
00:32:42,320 --> 00:32:43,360
decision

806
00:32:43,360 --> 00:32:44,960
is that

807
00:32:44,960 --> 00:32:47,519
esp home actually has built-in support

808
00:32:47,519 --> 00:32:49,760
for transmitting and receiving infrared

809
00:32:49,760 --> 00:32:52,880
and rf remote control signals

810
00:32:52,880 --> 00:32:55,200
and this ended up saving me quite a lot

811
00:32:55,200 --> 00:32:57,679
of time while keylock was not amongst

812
00:32:57,679 --> 00:32:58,799
those

813
00:32:58,799 --> 00:33:00,799
implemented actually implementing the

814
00:33:00,799 --> 00:33:03,440
decoder was a relatively simple matter

815
00:33:03,440 --> 00:33:05,519
using the existing implementations as a

816
00:33:05,519 --> 00:33:08,000
guideline

817
00:33:08,080 --> 00:33:10,960
and as you can see it only needed

818
00:33:10,960 --> 00:33:11,919
a

819
00:33:11,919 --> 00:33:14,320
fairly small amount of code

820
00:33:14,320 --> 00:33:15,360
to

821
00:33:15,360 --> 00:33:20,439
get esp home running on the stm32

822
00:33:20,960 --> 00:33:23,679
and a bit more code to implement the key

823
00:33:23,679 --> 00:33:26,320
lock protocol

824
00:33:26,320 --> 00:33:28,559
to

825
00:33:29,200 --> 00:33:32,080
to implement the encryption algorithms

826
00:33:32,080 --> 00:33:34,720
and then finally to implement

827
00:33:34,720 --> 00:33:37,760
a programming algorithm for the keylock

828
00:33:37,760 --> 00:33:39,120
transmitters

829
00:33:39,120 --> 00:33:41,120
that i had

830
00:33:41,120 --> 00:33:43,519
what this allows me to do is actually

831
00:33:43,519 --> 00:33:46,559
program a duplicate transmitter with my

832
00:33:46,559 --> 00:33:49,679
chosen serial number and derived key as

833
00:33:49,679 --> 00:33:52,559
well as choosing the starting

834
00:33:52,559 --> 00:33:55,840
replay counter value

835
00:33:57,600 --> 00:34:00,880
so a quick demonstration of

836
00:34:00,880 --> 00:34:03,360
what the

837
00:34:04,640 --> 00:34:06,399
the esp home

838
00:34:06,399 --> 00:34:07,840
system looks like

839
00:34:07,840 --> 00:34:10,399
this is just looking

840
00:34:10,399 --> 00:34:11,440
at

841
00:34:11,440 --> 00:34:13,599
the serial output

842
00:34:13,599 --> 00:34:15,679
the logs from the esp home firmware

843
00:34:15,679 --> 00:34:18,719
running directly on the stm32 based

844
00:34:18,719 --> 00:34:21,440
complex receiver board the orange block

845
00:34:21,440 --> 00:34:23,918
is purely to focus your attention on the

846
00:34:23,918 --> 00:34:26,000
important details

847
00:34:26,000 --> 00:34:28,320
so you can see a text sensor being

848
00:34:28,320 --> 00:34:30,639
updated both as the built-in button

849
00:34:30,639 --> 00:34:33,040
repeater goes

850
00:34:33,040 --> 00:34:35,280
and is cleared as well as when further

851
00:34:35,280 --> 00:34:37,440
buttons are pressed in the leftmost

852
00:34:37,440 --> 00:34:39,280
colon separated field is the serial

853
00:34:39,280 --> 00:34:41,280
number then the button which is being

854
00:34:41,280 --> 00:34:44,079
pressed followed by the counter value

855
00:34:44,079 --> 00:34:46,879
and two status bits battery low and

856
00:34:46,879 --> 00:34:50,480
repeat so there's the serial number

857
00:34:50,480 --> 00:34:51,520
the button

858
00:34:51,520 --> 00:34:53,119
the counter value which you can see

859
00:34:53,119 --> 00:34:55,280
incrementing a b

860
00:34:55,280 --> 00:34:56,800
c and d

861
00:34:56,800 --> 00:35:01,320
and then the two status bits

862
00:35:10,240 --> 00:35:12,640
as you saw in the previous demonstration

863
00:35:12,640 --> 00:35:13,920
it was possible to observe the

864
00:35:13,920 --> 00:35:15,599
transmissions picked up by the complex

865
00:35:15,599 --> 00:35:16,480
receiver

866
00:35:16,480 --> 00:35:18,560
using the usb serial port

867
00:35:18,560 --> 00:35:21,200
of course that then requires a pc to be

868
00:35:21,200 --> 00:35:23,359
powered up and an additional program

869
00:35:23,359 --> 00:35:26,079
written to translate the serial output

870
00:35:26,079 --> 00:35:28,560
into home assistant sensor states

871
00:35:28,560 --> 00:35:30,240
i decided that i wanted to have it as

872
00:35:30,240 --> 00:35:32,160
self-contained as possible

873
00:35:32,160 --> 00:35:34,800
and using as little little power as

874
00:35:34,800 --> 00:35:37,280
possible

875
00:35:39,280 --> 00:35:40,800
so this brings me

876
00:35:40,800 --> 00:35:42,800
back around to

877
00:35:42,800 --> 00:35:45,040
the esp

878
00:35:45,040 --> 00:35:47,520
to esp home

879
00:35:47,520 --> 00:35:50,800
i happen to have an esp32 dev board

880
00:35:50,800 --> 00:35:52,480
a development board

881
00:35:52,480 --> 00:35:54,880
handy

882
00:35:55,520 --> 00:35:57,280
which brings us back into supported

883
00:35:57,280 --> 00:36:00,480
territory in esp home

884
00:36:00,480 --> 00:36:02,720
the complex receiver board originally

885
00:36:02,720 --> 00:36:04,640
had a display board

886
00:36:04,640 --> 00:36:06,320
attached by the double row header

887
00:36:06,320 --> 00:36:08,160
between the program header and the

888
00:36:08,160 --> 00:36:09,839
mounting holes

889
00:36:09,839 --> 00:36:12,400
over here

890
00:36:12,400 --> 00:36:14,640
the pins available on the header

891
00:36:14,640 --> 00:36:17,040
included power and ground and

892
00:36:17,040 --> 00:36:21,759
fortunately also included a serial port

893
00:36:22,560 --> 00:36:24,800
the remaining question was what is the

894
00:36:24,800 --> 00:36:27,680
best way to take the esp home entities

895
00:36:27,680 --> 00:36:29,920
things like switches sensors the key

896
00:36:29,920 --> 00:36:32,880
lock receiver etc and expose those to an

897
00:36:32,880 --> 00:36:34,800
external client

898
00:36:34,800 --> 00:36:35,680
well

899
00:36:35,680 --> 00:36:38,640
esp home already had an api defined for

900
00:36:38,640 --> 00:36:41,359
connections made over tcp connections

901
00:36:41,359 --> 00:36:43,520
from home assistant using google

902
00:36:43,520 --> 00:36:45,760
protobufs i figured it would be a

903
00:36:45,760 --> 00:36:48,000
relatively straightforward solution to

904
00:36:48,000 --> 00:36:49,760
implement the same protocol over a

905
00:36:49,760 --> 00:36:52,079
serial port and then write a client

906
00:36:52,079 --> 00:36:54,560
implementation that would map remote

907
00:36:54,560 --> 00:36:57,440
entities on the stm32

908
00:36:57,440 --> 00:36:59,920
into the local esp home instance on the

909
00:36:59,920 --> 00:37:02,720
esp32

910
00:37:02,720 --> 00:37:05,760
in this way updates from the stm32 would

911
00:37:05,760 --> 00:37:08,880
be sent to the esp32 and forwarded onto

912
00:37:08,880 --> 00:37:10,960
home assistant and instructions from

913
00:37:10,960 --> 00:37:13,200
home assistant for example to activate a

914
00:37:13,200 --> 00:37:16,560
relay would be sent to the esp32 and

915
00:37:16,560 --> 00:37:20,240
then forwarded on to the stm32

916
00:37:20,240 --> 00:37:22,640
and finally home assistant also has a

917
00:37:22,640 --> 00:37:26,400
predefined interface for rfid tags which

918
00:37:26,400 --> 00:37:27,760
essentially presents a string

919
00:37:27,760 --> 00:37:30,560
representation of the tag id

920
00:37:30,560 --> 00:37:33,440
this sounded quite similar to what we're

921
00:37:33,440 --> 00:37:35,920
dealing with with the key lock

922
00:37:35,920 --> 00:37:38,640
transmitters

923
00:37:40,240 --> 00:37:41,839
and so

924
00:37:41,839 --> 00:37:44,480
a few hundred lines of code later

925
00:37:44,480 --> 00:37:48,079
i had a client interface

926
00:37:48,079 --> 00:37:50,880
a client api implementation

927
00:37:50,880 --> 00:37:53,440
well it's incomplete because i only

928
00:37:53,440 --> 00:37:55,200
implemented the sensors and other

929
00:37:55,200 --> 00:37:56,800
entities that i actually needed for this

930
00:37:56,800 --> 00:37:57,839
project

931
00:37:57,839 --> 00:38:00,240
so things like covers garage doors and

932
00:38:00,240 --> 00:38:02,640
blinds and so forth are not supported

933
00:38:02,640 --> 00:38:05,799
for example

934
00:38:06,480 --> 00:38:09,839
so here is a demonstration showing

935
00:38:09,839 --> 00:38:10,880
the

936
00:38:10,880 --> 00:38:12,240
home assistant

937
00:38:12,240 --> 00:38:16,720
receiving transmissions from

938
00:38:17,520 --> 00:38:20,400
from the receiver

939
00:38:20,720 --> 00:38:22,560
if you look

940
00:38:22,560 --> 00:38:23,440
on

941
00:38:23,440 --> 00:38:25,119
to the right you can see the button

942
00:38:25,119 --> 00:38:27,200
incrementing as well as the counter

943
00:38:27,200 --> 00:38:30,200
incrementing

944
00:38:33,359 --> 00:38:34,560
and then

945
00:38:34,560 --> 00:38:36,320
if we go to the

946
00:38:36,320 --> 00:38:38,000
rfid

947
00:38:38,000 --> 00:38:39,599
tag interface

948
00:38:39,599 --> 00:38:43,280
we can see a similar approach

949
00:38:43,280 --> 00:38:45,359
you can see the serial number and the

950
00:38:45,359 --> 00:38:46,400
button

951
00:38:46,400 --> 00:38:49,440
without the counter

952
00:38:50,640 --> 00:38:54,000
the counter value was removed simply to

953
00:38:54,000 --> 00:38:55,520
make it

954
00:38:55,520 --> 00:38:58,079
easier to map a constant value rather

955
00:38:58,079 --> 00:39:01,119
than a constantly changing value

956
00:39:01,119 --> 00:39:05,119
to actions in home assistant

957
00:39:08,400 --> 00:39:10,480
this is the

958
00:39:10,480 --> 00:39:12,400
the logic that is followed

959
00:39:12,400 --> 00:39:13,920
this is a snippet actually of the

960
00:39:13,920 --> 00:39:17,280
configuration file for the stm32 version

961
00:39:17,280 --> 00:39:21,680
of home assistant of esp home

962
00:39:22,400 --> 00:39:23,520
the

963
00:39:23,520 --> 00:39:26,160
trans the remote receiver

964
00:39:26,160 --> 00:39:28,560
calls the on keylock function

965
00:39:28,560 --> 00:39:31,359
with a value

966
00:39:31,359 --> 00:39:33,680
representing the the

967
00:39:33,680 --> 00:39:35,200
the decoded

968
00:39:35,200 --> 00:39:38,079
fixed and hopping portions of the

969
00:39:38,079 --> 00:39:40,160
of the transmission

970
00:39:40,160 --> 00:39:41,040
so

971
00:39:41,040 --> 00:39:43,440
if the key lock decrypter i.e the

972
00:39:43,440 --> 00:39:45,440
implementation of the the crypto

973
00:39:45,440 --> 00:39:46,800
algorithms

974
00:39:46,800 --> 00:39:49,280
can decrypt the transmission

975
00:39:49,280 --> 00:39:50,800
then

976
00:39:50,800 --> 00:39:53,119
format the details the serial number the

977
00:39:53,119 --> 00:39:54,240
button

978
00:39:54,240 --> 00:39:54,960
the

979
00:39:54,960 --> 00:39:58,720
counter and the various flags into a

980
00:39:58,720 --> 00:39:59,680
buffer

981
00:39:59,680 --> 00:40:01,119
and send those

982
00:40:01,119 --> 00:40:03,359
to

983
00:40:03,599 --> 00:40:07,000
to home assistant

984
00:40:13,359 --> 00:40:15,599
this is an example of a configuration of

985
00:40:15,599 --> 00:40:19,520
the hts 301 transmitter and a script to

986
00:40:19,520 --> 00:40:21,359
program one with a specified serial

987
00:40:21,359 --> 00:40:24,000
number and key using the normal key gen

988
00:40:24,000 --> 00:40:26,240
key derivation function and a serial

989
00:40:26,240 --> 00:40:28,079
number of zero

990
00:40:28,079 --> 00:40:30,400
in this case i'm programming serial

991
00:40:30,400 --> 00:40:34,319
number of da342b

992
00:40:34,319 --> 00:40:39,560
with an initial sequence number of zero

993
00:40:43,920 --> 00:40:47,200
so some outstanding features

994
00:40:47,200 --> 00:40:49,520
i haven't yet implemented persistent

995
00:40:49,520 --> 00:40:51,200
recording of counters and replay

996
00:40:51,200 --> 00:40:53,280
detection

997
00:40:53,280 --> 00:40:55,520
that needs an implementation of a

998
00:40:55,520 --> 00:40:59,119
storage api for the spi eeprom which is

999
00:40:59,119 --> 00:41:01,200
already on the board

1000
00:41:01,200 --> 00:41:02,400
i've done the design of the store

1001
00:41:02,400 --> 00:41:05,880
marriage format which will support

1002
00:41:05,880 --> 00:41:08,400
4096 transmitters with up to 14

1003
00:41:08,400 --> 00:41:09,680
functions each

1004
00:41:09,680 --> 00:41:12,880
as well as logging of up to 8 000 events

1005
00:41:12,880 --> 00:41:14,640
within the eeprom

1006
00:41:14,640 --> 00:41:17,520
the current manufacturer firmware

1007
00:41:17,520 --> 00:41:21,040
will only log to an sd card which is not

1008
00:41:21,040 --> 00:41:24,160
necessarily a problem

1009
00:41:24,480 --> 00:41:26,400
but it is an additional

1010
00:41:26,400 --> 00:41:28,480
component

1011
00:41:28,480 --> 00:41:29,760
in addition

1012
00:41:29,760 --> 00:41:31,359
the

1013
00:41:31,359 --> 00:41:33,440
the client api

1014
00:41:33,440 --> 00:41:35,280
and the server occasionally get

1015
00:41:35,280 --> 00:41:38,079
desynchronized

1016
00:41:38,079 --> 00:41:41,280
and at the moment that does not recover

1017
00:41:41,280 --> 00:41:46,319
gracefully so i need to to fix that

1018
00:41:46,640 --> 00:41:49,440
before this could be a robust

1019
00:41:49,440 --> 00:41:51,359
deployed

1020
00:41:51,359 --> 00:41:52,800
setup

1021
00:41:52,800 --> 00:41:54,400
and then

1022
00:41:54,400 --> 00:41:56,560
enhancements to the client api to

1023
00:41:56,560 --> 00:41:57,839
implement

1024
00:41:57,839 --> 00:42:00,000
the remaining entity types that i

1025
00:42:00,000 --> 00:42:01,200
haven't yet

1026
00:42:01,200 --> 00:42:03,119
implemented

1027
00:42:03,119 --> 00:42:04,720
and then finally

1028
00:42:04,720 --> 00:42:09,480
there is a problem with the hcs-301

1029
00:42:09,839 --> 00:42:11,520
transmitter

1030
00:42:11,520 --> 00:42:13,440
algorithm and i'm not too sure whether

1031
00:42:13,440 --> 00:42:15,680
it's a problem with the algorithm or not

1032
00:42:15,680 --> 00:42:16,400
because

1033
00:42:16,400 --> 00:42:18,319
i've confirmed that the value which gets

1034
00:42:18,319 --> 00:42:20,960
programmed

1035
00:42:21,520 --> 00:42:23,599
is in fact

1036
00:42:23,599 --> 00:42:25,599
received by the transmitter because you

1037
00:42:25,599 --> 00:42:27,839
can read back the value during the

1038
00:42:27,839 --> 00:42:29,599
programming sequence

1039
00:42:29,599 --> 00:42:32,319
you simply can't ever read it again

1040
00:42:32,319 --> 00:42:34,000
after that

1041
00:42:34,000 --> 00:42:36,319
so the problem that i've encountered is

1042
00:42:36,319 --> 00:42:38,319
that trying to program an initial

1043
00:42:38,319 --> 00:42:40,800
sequence number

1044
00:42:40,800 --> 00:42:43,200
greater than about 60 or so

1045
00:42:43,200 --> 00:42:44,400
ends up

1046
00:42:44,400 --> 00:42:47,520
with a corrupted value and so the value

1047
00:42:47,520 --> 00:42:50,319
that you've programmed is not the next

1048
00:42:50,319 --> 00:42:55,839
value used when starting a transmission

1049
00:42:56,960 --> 00:42:59,200
i suspect that this might actually be

1050
00:42:59,200 --> 00:43:00,640
broken silicon

1051
00:43:00,640 --> 00:43:03,920
i'm pretty sure that 99.99

1052
00:43:03,920 --> 00:43:06,319
of vendors simply program a sequence

1053
00:43:06,319 --> 00:43:08,079
number starting at zero

1054
00:43:08,079 --> 00:43:12,160
and have never encountered the spike

1055
00:43:12,160 --> 00:43:14,079
but yeah that is something that i'd

1056
00:43:14,079 --> 00:43:18,000
really like to try and solve because

1057
00:43:18,000 --> 00:43:19,520
without it

1058
00:43:19,520 --> 00:43:21,119
it's a bit more difficult to actually

1059
00:43:21,119 --> 00:43:24,720
transmit or to create a forged

1060
00:43:24,720 --> 00:43:27,720
transmitter

1061
00:43:28,880 --> 00:43:31,839
so the code for this is available in my

1062
00:43:31,839 --> 00:43:35,040
esp home fork there are three branches

1063
00:43:35,040 --> 00:43:37,680
the code for the stm32 the code for the

1064
00:43:37,680 --> 00:43:41,200
key lock and the api client

1065
00:43:41,200 --> 00:43:44,160
if you want to try and replicate my work

1066
00:43:44,160 --> 00:43:46,720
in your own environment using a complex

1067
00:43:46,720 --> 00:43:48,640
receiver you'll probably want to merge

1068
00:43:48,640 --> 00:43:52,078
those three branches together

1069
00:43:53,760 --> 00:43:56,000
in order to to have it all function on

1070
00:43:56,000 --> 00:43:58,319
that stm32

1071
00:43:58,319 --> 00:44:00,000
they were created separately because

1072
00:44:00,000 --> 00:44:01,440
they are

1073
00:44:01,440 --> 00:44:03,839
pretty much independent pieces of work

1074
00:44:03,839 --> 00:44:05,920
and the key lock and api client work

1075
00:44:05,920 --> 00:44:09,040
does not depend on the stm32

1076
00:44:09,040 --> 00:44:10,560
although they're completely independent

1077
00:44:10,560 --> 00:44:12,960
in fact

1078
00:44:15,440 --> 00:44:18,400
so that is the summary of my journey

1079
00:44:18,400 --> 00:44:20,240
through a

1080
00:44:20,240 --> 00:44:22,560
the keylock environment thank you very

1081
00:44:22,560 --> 00:44:24,640
much for

1082
00:44:24,640 --> 00:44:26,000
for

1083
00:44:26,000 --> 00:44:28,160
coming along on this journey with me

1084
00:44:28,160 --> 00:44:32,240
and if you have any questions i will be

1085
00:44:32,240 --> 00:44:33,440
in the chat

1086
00:44:33,440 --> 00:44:34,400
for

1087
00:44:34,400 --> 00:44:35,520
um

1088
00:44:35,520 --> 00:44:37,359
for a while so that

1089
00:44:37,359 --> 00:44:39,440
so that i can answer them

1090
00:44:39,440 --> 00:44:42,920
thank you very much

