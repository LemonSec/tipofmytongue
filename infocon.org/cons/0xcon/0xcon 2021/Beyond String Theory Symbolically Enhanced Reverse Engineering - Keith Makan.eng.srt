1
00:00:09,679 --> 00:00:11,599
hi my name is keith mcconne and my talk

2
00:00:11,599 --> 00:00:13,519
is titled beyond string theory

3
00:00:13,519 --> 00:00:14,719
symbolically enhanced reverse

4
00:00:14,719 --> 00:00:18,480
engineering so let's get to it

5
00:00:18,480 --> 00:00:21,279
um the agenda who am i um i'm going to

6
00:00:21,279 --> 00:00:22,320
talk about you know why you should

7
00:00:22,320 --> 00:00:24,160
listen to me what i've done

8
00:00:24,160 --> 00:00:27,199
um i i'm going to talk about binary

9
00:00:27,199 --> 00:00:28,560
reverse engineering some of the hard

10
00:00:28,560 --> 00:00:30,880
problems that exist why it's you know

11
00:00:30,880 --> 00:00:33,360
challenging to actually just

12
00:00:33,360 --> 00:00:34,880
to walk through some boundaries what can

13
00:00:34,880 --> 00:00:36,880
make it really recruiting process we

14
00:00:36,880 --> 00:00:38,320
talk we're going to talk about symbolic

15
00:00:38,320 --> 00:00:40,559
execution and we talk about what what

16
00:00:40,559 --> 00:00:42,960
anger is and how it can facilitate this

17
00:00:42,960 --> 00:00:44,800
to walk through some of the basic steps

18
00:00:44,800 --> 00:00:47,039
in setting up a session

19
00:00:47,039 --> 00:00:48,160
and then we're going to talk about some

20
00:00:48,160 --> 00:00:50,079
of the power that it has to help you

21
00:00:50,079 --> 00:00:52,320
find bugs explore program for program

22
00:00:52,320 --> 00:00:54,960
paths autonomously and actually automate

23
00:00:54,960 --> 00:00:58,239
some reverse engineering processes um

24
00:00:58,239 --> 00:00:59,359
and i got to talk about the hard

25
00:00:59,359 --> 00:01:01,920
problems before i i get to get to anger

26
00:01:01,920 --> 00:01:03,440
so you're aware of that and then we'll

27
00:01:03,440 --> 00:01:05,280
cover some applications that other folks

28
00:01:05,280 --> 00:01:07,119
came up with just quickly run through

29
00:01:07,119 --> 00:01:08,880
some of the cool things people have done

30
00:01:08,880 --> 00:01:11,680
contemporary research and at the end uh

31
00:01:11,680 --> 00:01:12,960
you know if you want to ask questions

32
00:01:12,960 --> 00:01:15,600
you can contact me um so who am i i'm a

33
00:01:15,600 --> 00:01:18,159
security researcher my name's keith as i

34
00:01:18,159 --> 00:01:20,640
mentioned i do penetration testing i do

35
00:01:20,640 --> 00:01:22,479
want to buddy assessment source code and

36
00:01:22,479 --> 00:01:24,320
source code review it's my favorite

37
00:01:24,320 --> 00:01:26,159
verse engineer is my favorite so if you

38
00:01:26,159 --> 00:01:28,560
have code you need me to read for secure

39
00:01:28,560 --> 00:01:30,720
uh for secure analysis you wanna know if

40
00:01:30,720 --> 00:01:32,640
there's any bugs that people can use to

41
00:01:32,640 --> 00:01:35,200
break it or standard secure standard

42
00:01:35,200 --> 00:01:37,840
it's standards it's not adhering to

43
00:01:37,840 --> 00:01:39,759
contact me i've got a company set up to

44
00:01:39,759 --> 00:01:41,439
handle this kind of stuff

45
00:01:41,439 --> 00:01:43,280
i also wrote two books one of them is

46
00:01:43,280 --> 00:01:44,799
called the android security cookbook

47
00:01:44,799 --> 00:01:46,960
which i released in 2012.

48
00:01:46,960 --> 00:01:48,799
it has you know it's a collection of

49
00:01:48,799 --> 00:01:51,840
recipes that you can use to break open

50
00:01:51,840 --> 00:01:53,600
an android app reverse engineer it and

51
00:01:53,600 --> 00:01:55,600
assess it for vulnerabilities

52
00:01:55,600 --> 00:01:57,040
and the other book i wrote is called the

53
00:01:57,040 --> 00:01:59,200
penetration testing with a bash shell

54
00:01:59,200 --> 00:02:01,759
and it it's basically also a collection

55
00:02:01,759 --> 00:02:04,560
of small recipes that make it easier to

56
00:02:04,560 --> 00:02:06,719
use bash for automating penetration

57
00:02:06,719 --> 00:02:08,800
testing tasks and currently i'm working

58
00:02:08,800 --> 00:02:11,280
on my on my masters which focuses on

59
00:02:11,280 --> 00:02:13,360
symbolic execution for race condition

60
00:02:13,360 --> 00:02:15,200
detection so i'm going to use a symbolic

61
00:02:15,200 --> 00:02:18,160
execution engine to find autonomously

62
00:02:18,160 --> 00:02:21,680
find race conditions in binaries

63
00:02:21,680 --> 00:02:23,760
some quick terminology reverse

64
00:02:23,760 --> 00:02:25,120
engineering i'm going to throw that word

65
00:02:25,120 --> 00:02:26,959
around a lot it's basically the process

66
00:02:26,959 --> 00:02:28,800
of unpacking a program to detail its

67
00:02:28,800 --> 00:02:31,120
behavior here we're focused on binary

68
00:02:31,120 --> 00:02:33,280
programs okay

69
00:02:33,280 --> 00:02:34,720
and if you're unpacking your programs

70
00:02:34,720 --> 00:02:36,319
behavior you're going to have a lot of

71
00:02:36,319 --> 00:02:38,800
this word thrown around a block of a

72
00:02:38,800 --> 00:02:40,800
program a block is just a contiguous

73
00:02:40,800 --> 00:02:41,920
section of

74
00:02:41,920 --> 00:02:44,080
instructions separated by jumps and

75
00:02:44,080 --> 00:02:45,040
calls

76
00:02:45,040 --> 00:02:46,640
you know conditional separations of

77
00:02:46,640 --> 00:02:47,440
stuff

78
00:02:47,440 --> 00:02:48,879
you want to know which blocks follow

79
00:02:48,879 --> 00:02:50,560
which and if you're going to do that you

80
00:02:50,560 --> 00:02:52,000
want to know the precedence of blocks

81
00:02:52,000 --> 00:02:53,840
you're going to have to derive a control

82
00:02:53,840 --> 00:02:56,239
flow graph and this is directed graph

83
00:02:56,239 --> 00:02:58,319
that shows you which block will follow

84
00:02:58,319 --> 00:03:00,560
which and how the branch and and split

85
00:03:00,560 --> 00:03:02,560
off into one another very important if

86
00:03:02,560 --> 00:03:04,720
you're doing reverse engineering

87
00:03:04,720 --> 00:03:06,080
and again we're going to talk about

88
00:03:06,080 --> 00:03:08,400
symbolic execution and somali execution

89
00:03:08,400 --> 00:03:10,159
is all about the association of symbolic

90
00:03:10,159 --> 00:03:12,480
states

91
00:03:12,720 --> 00:03:14,800
and a state is basically a hazy

92
00:03:14,800 --> 00:03:16,400
collection of

93
00:03:16,400 --> 00:03:17,200
of

94
00:03:17,200 --> 00:03:18,560
instructions

95
00:03:18,560 --> 00:03:19,760
which uh

96
00:03:19,760 --> 00:03:22,319
which loosely represents

97
00:03:22,319 --> 00:03:23,360
um

98
00:03:23,360 --> 00:03:24,239
a

99
00:03:24,239 --> 00:03:27,040
which loosely represents um a block you

100
00:03:27,040 --> 00:03:30,159
know it's it's associated to a set of uh

101
00:03:30,159 --> 00:03:32,480
uh metadata which is you know vector

102
00:03:32,480 --> 00:03:35,760
register memory values um you know uh so

103
00:03:35,760 --> 00:03:38,000
you can make sense of how what will

104
00:03:38,000 --> 00:03:40,000
happen when you reach the state in the

105
00:03:40,000 --> 00:03:42,400
program a block doesn't have that so

106
00:03:42,400 --> 00:03:44,080
that's why i'm saying state is is this

107
00:03:44,080 --> 00:03:46,640
association of metadata so the typical

108
00:03:46,640 --> 00:03:49,280
process with reverse engineering um

109
00:03:49,280 --> 00:03:51,599
you know you typically take load up your

110
00:03:51,599 --> 00:03:53,439
binary if it's loadable you know you

111
00:03:53,439 --> 00:03:55,519
might have elf sections or

112
00:03:55,519 --> 00:03:57,840
things that are broken um you know

113
00:03:57,840 --> 00:03:59,680
program state program load statements

114
00:03:59,680 --> 00:04:01,439
that are all messed up in the wrong

115
00:04:01,439 --> 00:04:04,239
place um but you load it up in binary uh

116
00:04:04,239 --> 00:04:06,560
the binary in binary ninja either pro

117
00:04:06,560 --> 00:04:08,799
hopper hydra radari what have you is a

118
00:04:08,799 --> 00:04:10,400
suite of tools now that make this very

119
00:04:10,400 --> 00:04:11,680
easy

120
00:04:11,680 --> 00:04:12,959
you would then typically check the

121
00:04:12,959 --> 00:04:15,680
strings try to disassemble stuff to do

122
00:04:15,680 --> 00:04:17,918
do cross-referencing of function calls

123
00:04:17,918 --> 00:04:20,320
and variable references um you know you

124
00:04:20,320 --> 00:04:22,320
you try you know hope that there isn't a

125
00:04:22,320 --> 00:04:25,600
lot of obfuscation that makes us hard um

126
00:04:25,600 --> 00:04:28,080
you know in terms of like complex cfgs

127
00:04:28,080 --> 00:04:30,560
obfuscated function names etc and you

128
00:04:30,560 --> 00:04:33,040
hope that's kind of the general approach

129
00:04:33,040 --> 00:04:34,160
but um

130
00:04:34,160 --> 00:04:36,639
uh so so this is the typical process but

131
00:04:36,639 --> 00:04:38,880
what makes us hard uh

132
00:04:38,880 --> 00:04:40,560
what number one thing that makes it

133
00:04:40,560 --> 00:04:42,880
difficult is complex cfgs so if you're

134
00:04:42,880 --> 00:04:44,960
trying to in your head derive what will

135
00:04:44,960 --> 00:04:47,919
happen in a cfg

136
00:04:47,919 --> 00:04:49,440
these these are the kind of hard edges

137
00:04:49,440 --> 00:04:50,880
to the problem you could have nested

138
00:04:50,880 --> 00:04:53,040
loops and if you don't know what this is

139
00:04:53,040 --> 00:04:54,720
like i just took a snapshot of a binary

140
00:04:54,720 --> 00:04:56,880
i was looking at and this these blue

141
00:04:56,880 --> 00:04:59,520
lines they're all individual ways to

142
00:04:59,520 --> 00:05:01,840
enter a loop so if you're reading this

143
00:05:01,840 --> 00:05:03,199
by hand you can understand this is going

144
00:05:03,199 --> 00:05:05,360
to be extremely grueling making sense of

145
00:05:05,360 --> 00:05:07,360
how this loop actually behaves

146
00:05:07,360 --> 00:05:09,600
in summation

147
00:05:09,600 --> 00:05:10,720
the other thing that makes it very

148
00:05:10,720 --> 00:05:13,280
difficult is complex pointer arithmetic

149
00:05:13,280 --> 00:05:14,880
so you might have these references to

150
00:05:14,880 --> 00:05:17,680
memory based on registers that are you

151
00:05:17,680 --> 00:05:20,160
know summing and multiplying and scaling

152
00:05:20,160 --> 00:05:22,960
indexing and basing

153
00:05:22,960 --> 00:05:25,120
uh based on registers that take a long

154
00:05:25,120 --> 00:05:27,280
time to work out where exactly a memory

155
00:05:27,280 --> 00:05:29,840
this is trying to trying to point

156
00:05:29,840 --> 00:05:32,080
and here we even have like a

157
00:05:32,080 --> 00:05:34,160
a complex point of arithmetic

158
00:05:34,160 --> 00:05:35,680
for a a

159
00:05:35,680 --> 00:05:39,840
a comparison to break up a block

160
00:05:40,320 --> 00:05:41,840
you might also have

161
00:05:41,840 --> 00:05:44,639
data dependent branching and calling and

162
00:05:44,639 --> 00:05:47,440
here is an example from a ctf but it's

163
00:05:47,440 --> 00:05:49,440
it's not so uncommon to happen in actual

164
00:05:49,440 --> 00:05:50,800
rule of binaries

165
00:05:50,800 --> 00:05:53,039
what this does is f gets from from it

166
00:05:53,039 --> 00:05:55,520
called calls f gets which reads a string

167
00:05:55,520 --> 00:05:57,120
from a file descriptor the file

168
00:05:57,120 --> 00:05:59,440
descriptor we're using is scdn and it's

169
00:05:59,440 --> 00:06:01,840
actually writing this into the stack the

170
00:06:01,840 --> 00:06:03,840
the result and then branching to that

171
00:06:03,840 --> 00:06:05,440
part of the stack as though it's a as

172
00:06:05,440 --> 00:06:07,280
though it's a valid function pointer

173
00:06:07,280 --> 00:06:08,639
which is which is

174
00:06:08,639 --> 00:06:11,360
pretty harrowing and and like a glaring

175
00:06:11,360 --> 00:06:12,560
example of a

176
00:06:12,560 --> 00:06:14,800
of a code execution vulnerability but it

177
00:06:14,800 --> 00:06:16,160
means that if you're actually reverse

178
00:06:16,160 --> 00:06:17,919
engineering this binary you're not going

179
00:06:17,919 --> 00:06:19,440
to know what will happen you know just

180
00:06:19,440 --> 00:06:21,120
by reading the source code in a

181
00:06:21,120 --> 00:06:22,720
straightforward way

182
00:06:22,720 --> 00:06:23,440
um

183
00:06:23,440 --> 00:06:25,120
so why are we looking at binaries you

184
00:06:25,120 --> 00:06:26,880
know why are binary so important well

185
00:06:26,880 --> 00:06:29,840
there's a big chism between source code

186
00:06:29,840 --> 00:06:32,720
and actual binary behavior sometimes and

187
00:06:32,720 --> 00:06:35,280
and you can see this in terms of how you

188
00:06:35,280 --> 00:06:36,880
know people of security people have

189
00:06:36,880 --> 00:06:39,120
panicked about compiler optimizations

190
00:06:39,120 --> 00:06:40,319
over the years and one of the good

191
00:06:40,319 --> 00:06:42,479
examples is something called memsad

192
00:06:42,479 --> 00:06:46,000
which is um a vulnerability or a kind of

193
00:06:46,000 --> 00:06:48,639
a lack of of code etiquette that causes

194
00:06:48,639 --> 00:06:50,960
optimizations to remove

195
00:06:50,960 --> 00:06:53,199
certain secure operations so in this

196
00:06:53,199 --> 00:06:55,280
example we have a password that's being

197
00:06:55,280 --> 00:06:58,280
stored on the stack in the in the

198
00:06:58,280 --> 00:07:00,560
psspasswd variable

199
00:07:00,560 --> 00:07:01,919
and at the end you obviously don't want

200
00:07:01,919 --> 00:07:04,000
to have this lying around in the stack

201
00:07:04,000 --> 00:07:05,280
so you try to clear the variable you

202
00:07:05,280 --> 00:07:07,199
want to mim set it to zero

203
00:07:07,199 --> 00:07:08,960
but unfortunately under certain compiler

204
00:07:08,960 --> 00:07:11,440
optimizations um it will actually just

205
00:07:11,440 --> 00:07:12,800
remove this

206
00:07:12,800 --> 00:07:15,440
mem set because the compiler checks that

207
00:07:15,440 --> 00:07:16,319
you're

208
00:07:16,319 --> 00:07:17,919
referencing a variable you're not going

209
00:07:17,919 --> 00:07:19,919
to use so this operation is useless to

210
00:07:19,919 --> 00:07:22,479
me i don't need to actually um

211
00:07:22,479 --> 00:07:23,919
run this membership it's setting it to

212
00:07:23,919 --> 00:07:24,960
zero

213
00:07:24,960 --> 00:07:26,639
and you're not using it it'll optimize

214
00:07:26,639 --> 00:07:28,240
it out which means that possible will

215
00:07:28,240 --> 00:07:30,560
stay on the stack um and you know if you

216
00:07:30,560 --> 00:07:32,240
don't if you don't still know why it's a

217
00:07:32,240 --> 00:07:33,680
problem you've got to think about

218
00:07:33,680 --> 00:07:35,599
problems like stack leaks things like

219
00:07:35,599 --> 00:07:38,720
heart bleed um you know things like out

220
00:07:38,720 --> 00:07:40,560
of bounds reads those kind of things

221
00:07:40,560 --> 00:07:42,160
make this very very dangerous to have

222
00:07:42,160 --> 00:07:44,639
lying around especially for sensitive

223
00:07:44,639 --> 00:07:46,240
data like a password

224
00:07:46,240 --> 00:07:48,240
another another glaring example which i

225
00:07:48,240 --> 00:07:50,879
stole from someone's blog is this idea

226
00:07:50,879 --> 00:07:52,080
that um

227
00:07:52,080 --> 00:07:53,840
you know when you when you have two

228
00:07:53,840 --> 00:07:55,680
threads uh working on something at the

229
00:07:55,680 --> 00:07:58,080
same time a typical setup is that you

230
00:07:58,080 --> 00:08:00,560
have a context variable so ctx is the

231
00:08:00,560 --> 00:08:03,199
context and it has a variable n and in

232
00:08:03,199 --> 00:08:06,560
this nested loop n is going to be used

233
00:08:06,560 --> 00:08:08,879
to exit that loop so

234
00:08:08,879 --> 00:08:11,360
so when you have this data and you mod

235
00:08:11,360 --> 00:08:13,680
it by two you check if it's even or odd

236
00:08:13,680 --> 00:08:16,400
another thread will will actually flip

237
00:08:16,400 --> 00:08:18,080
in on and off so it'll make it one or

238
00:08:18,080 --> 00:08:20,560
zero and uh you know you can control

239
00:08:20,560 --> 00:08:23,440
essentially um when this when this while

240
00:08:23,440 --> 00:08:26,240
loop will exit otherwise it'll just keep

241
00:08:26,240 --> 00:08:28,000
spinning in that while loop now when you

242
00:08:28,000 --> 00:08:30,080
compile this into a binary it turns out

243
00:08:30,080 --> 00:08:32,240
that like compiler optimizations can

244
00:08:32,240 --> 00:08:34,799
drastically change the picture of what's

245
00:08:34,799 --> 00:08:36,719
going to happen in that indefinite loop

246
00:08:36,719 --> 00:08:38,640
because look at the code again

247
00:08:38,640 --> 00:08:41,440
you're referencing this n and in the the

248
00:08:41,440 --> 00:08:42,719
compiler will have different

249
00:08:42,719 --> 00:08:45,200
optimizations for it because in this

250
00:08:45,200 --> 00:08:47,120
function n doesn't change you don't

251
00:08:47,120 --> 00:08:49,040
actually change n something out of

252
00:08:49,040 --> 00:08:51,360
context changes it so what happens is

253
00:08:51,360 --> 00:08:52,959
when you compile this under certain

254
00:08:52,959 --> 00:08:55,680
optimizations it drastically changes

255
00:08:55,680 --> 00:08:57,440
the the picture and and will actually

256
00:08:57,440 --> 00:08:59,680
introduce an undefined state that can

257
00:08:59,680 --> 00:09:03,279
cause a a memory uh um

258
00:09:03,279 --> 00:09:05,920
a race condition because it just skips

259
00:09:05,920 --> 00:09:08,240
the check of the sentinel entirely and

260
00:09:08,240 --> 00:09:11,120
just makes like an indefinite loop um so

261
00:09:11,120 --> 00:09:13,040
this will introduce a race condition if

262
00:09:13,040 --> 00:09:14,800
if you're if you're not entirely sure so

263
00:09:14,800 --> 00:09:16,560
on the one one hand you're checking it

264
00:09:16,560 --> 00:09:18,800
faithfully on the other hand you you

265
00:09:18,800 --> 00:09:20,880
optimize so aggressively that it says oh

266
00:09:20,880 --> 00:09:21,839
you're not going to change this end

267
00:09:21,839 --> 00:09:24,800
variable so it optimizes out completely

268
00:09:24,800 --> 00:09:26,720
so that shows you there's a chasm that

269
00:09:26,720 --> 00:09:29,120
can open between binary and source code

270
00:09:29,120 --> 00:09:30,880
and you probably want to

271
00:09:30,880 --> 00:09:33,040
check your analysis against an actual

272
00:09:33,040 --> 00:09:34,240
literal

273
00:09:34,240 --> 00:09:36,399
binary definition before trusting that

274
00:09:36,399 --> 00:09:39,519
the source code is secure or not

275
00:09:39,519 --> 00:09:40,399
um

276
00:09:40,399 --> 00:09:42,160
so just a summary of the hard problems

277
00:09:42,160 --> 00:09:43,920
in reverse engineering you have binary

278
00:09:43,920 --> 00:09:45,600
formats that need to be interpreted and

279
00:09:45,600 --> 00:09:47,040
the other kind of key point is

280
00:09:47,040 --> 00:09:48,880
derivation of control flow graphs are

281
00:09:48,880 --> 00:09:50,399
very hard because you have data

282
00:09:50,399 --> 00:09:52,480
dependent branching

283
00:09:52,480 --> 00:09:54,080
complex point of arithmetic dynamic

284
00:09:54,080 --> 00:09:56,480
loading resolution and optimizations

285
00:09:56,480 --> 00:09:58,080
that can change the view

286
00:09:58,080 --> 00:09:58,800
so

287
00:09:58,800 --> 00:10:00,480
now we know it's hard about reverse

288
00:10:00,480 --> 00:10:02,000
engineering

289
00:10:02,000 --> 00:10:04,800
but symbolic execution this kind of new

290
00:10:04,800 --> 00:10:07,120
emerging technology not really new but

291
00:10:07,120 --> 00:10:09,519
like for analyzing binaries it's pretty

292
00:10:09,519 --> 00:10:11,760
contemporary we can now approach these

293
00:10:11,760 --> 00:10:14,640
problems in sort of a scientific way

294
00:10:14,640 --> 00:10:17,120
chipping out different like uh you know

295
00:10:17,120 --> 00:10:19,839
program exploration methods chipping out

296
00:10:19,839 --> 00:10:22,399
like carving out um you know the the

297
00:10:22,399 --> 00:10:25,519
slow approaches of of of symbolizing

298
00:10:25,519 --> 00:10:27,760
program paths and analyzing things like

299
00:10:27,760 --> 00:10:29,279
algebra

300
00:10:29,279 --> 00:10:31,200
and um you know

301
00:10:31,200 --> 00:10:33,279
constraint solving but uh so what what

302
00:10:33,279 --> 00:10:35,200
what is symbolic execution before we can

303
00:10:35,200 --> 00:10:36,880
get to how this is going to help reverse

304
00:10:36,880 --> 00:10:39,040
engineering symbolic execution is

305
00:10:39,040 --> 00:10:40,959
basically a marriage of two

306
00:10:40,959 --> 00:10:42,560
uh pieces of technology constraint

307
00:10:42,560 --> 00:10:45,839
solving which exists in formal proof

308
00:10:45,839 --> 00:10:47,200
theory

309
00:10:47,200 --> 00:10:50,320
you know formal logic it's it's a way of

310
00:10:50,320 --> 00:10:52,480
automating theory improving for certain

311
00:10:52,480 --> 00:10:55,360
fields of mathematics and it's a way of

312
00:10:55,360 --> 00:10:58,160
verifying circuit behavior

313
00:10:58,160 --> 00:11:00,000
for people who engineer hardware so if

314
00:11:00,000 --> 00:11:01,680
you actually you know bake your own

315
00:11:01,680 --> 00:11:03,760
chips you write your own verilog there's

316
00:11:03,760 --> 00:11:05,680
um there's all these tools that exist

317
00:11:05,680 --> 00:11:07,360
for checking that you're very that your

318
00:11:07,360 --> 00:11:09,440
verilog circuit is not going to have

319
00:11:09,440 --> 00:11:12,000
certain states and the way it guarantees

320
00:11:12,000 --> 00:11:13,360
it's not going to take certain states

321
00:11:13,360 --> 00:11:15,200
under given input is by relying on

322
00:11:15,200 --> 00:11:16,880
constraint solving and symbolic

323
00:11:16,880 --> 00:11:19,760
execution as well um and it marries this

324
00:11:19,760 --> 00:11:22,000
old constraint solving technology with

325
00:11:22,000 --> 00:11:23,839
the big scary new source code analysis

326
00:11:23,839 --> 00:11:26,320
we want to do these days um and it kind

327
00:11:26,320 --> 00:11:27,920
of sandwiches them together but

328
00:11:27,920 --> 00:11:30,240
essentially the process is it takes um

329
00:11:30,240 --> 00:11:32,240
the the variables the if statements the

330
00:11:32,240 --> 00:11:33,600
conditionals

331
00:11:33,600 --> 00:11:35,360
and the various states a program can

332
00:11:35,360 --> 00:11:38,160
have and it distills that into stuff

333
00:11:38,160 --> 00:11:40,560
that a theorem prover constraint solver

334
00:11:40,560 --> 00:11:43,440
will enjoy working through

335
00:11:43,440 --> 00:11:44,560
and if you don't know what constraint

336
00:11:44,560 --> 00:11:46,800
solving is uh just a quick crash course

337
00:11:46,800 --> 00:11:49,120
it's just a reference to the boolean

338
00:11:49,120 --> 00:11:51,600
satisfiability problem um in computer

339
00:11:51,600 --> 00:11:54,320
science which is uh basically

340
00:11:54,320 --> 00:11:57,200
basically the problem of given a formula

341
00:11:57,200 --> 00:11:59,360
of boolean variables you know ands or

342
00:11:59,360 --> 00:12:01,200
ors and xors and all these kind of

343
00:12:01,200 --> 00:12:04,720
boolean operations can you work out the

344
00:12:04,720 --> 00:12:06,959
vector of bits that will evaluate that

345
00:12:06,959 --> 00:12:08,399
to true

346
00:12:08,399 --> 00:12:10,399
and when you talk about smt solving the

347
00:12:10,399 --> 00:12:12,800
terminology becomes can you determine a

348
00:12:12,800 --> 00:12:15,120
satisfiable solution to this or

349
00:12:15,120 --> 00:12:17,200
determine that it's unsatisfiable

350
00:12:17,200 --> 00:12:19,120
there's also a third option because this

351
00:12:19,120 --> 00:12:21,040
doesn't have a definite approach there's

352
00:12:21,040 --> 00:12:23,200
no approach to this problem that well

353
00:12:23,200 --> 00:12:25,760
well for any formula be able to say yes

354
00:12:25,760 --> 00:12:27,519
you can definitely solve it no you can't

355
00:12:27,519 --> 00:12:28,959
there's certain forms that will break

356
00:12:28,959 --> 00:12:30,959
down and become soluble in certain forms

357
00:12:30,959 --> 00:12:33,200
that won't and the third option will be

358
00:12:33,200 --> 00:12:35,279
it's uh you know i don't know i don't

359
00:12:35,279 --> 00:12:37,600
know if it's if it's satisfiable and

360
00:12:37,600 --> 00:12:39,279
there's a there's a third answer that

361
00:12:39,279 --> 00:12:40,880
can come out and this basically happens

362
00:12:40,880 --> 00:12:44,000
when the smt solver gives up it it says

363
00:12:44,000 --> 00:12:45,200
i i got it you know i don't know how

364
00:12:45,200 --> 00:12:46,639
long i have to guess but it's definitely

365
00:12:46,639 --> 00:12:49,200
too long and it stops guessing it um

366
00:12:49,200 --> 00:12:50,880
this is directly related to the halting

367
00:12:50,880 --> 00:12:52,000
problem

368
00:12:52,000 --> 00:12:54,560
you can reduce one to the other or you

369
00:12:54,560 --> 00:12:55,519
know

370
00:12:55,519 --> 00:12:57,279
dress one up as the other problem

371
00:12:57,279 --> 00:12:58,959
because if you can answer the boolean

372
00:12:58,959 --> 00:13:01,760
satisfiability problem as we see here um

373
00:13:01,760 --> 00:13:03,920
you know you're saying that like why not

374
00:13:03,920 --> 00:13:05,680
just reduce a program

375
00:13:05,680 --> 00:13:07,440
and it's variables to this form thereby

376
00:13:07,440 --> 00:13:08,880
solving the whole thing problem if

377
00:13:08,880 --> 00:13:10,399
you're looking for whole thing in a

378
00:13:10,399 --> 00:13:12,639
program you can contrive it as a boolean

379
00:13:12,639 --> 00:13:14,160
satisfiability problem or boolean

380
00:13:14,160 --> 00:13:16,320
satisfiability problem can be dressed up

381
00:13:16,320 --> 00:13:18,560
as a holding problem what have you and

382
00:13:18,560 --> 00:13:20,720
the basic process of constraint solving

383
00:13:20,720 --> 00:13:22,160
is you take

384
00:13:22,160 --> 00:13:24,240
all the conditional statements again as

385
00:13:24,240 --> 00:13:25,680
we see in this picture here you start

386
00:13:25,680 --> 00:13:27,839
with a c program you rewrite those

387
00:13:27,839 --> 00:13:29,600
variables the if statements in a way

388
00:13:29,600 --> 00:13:32,320
that's um friendly to conversion to to

389
00:13:32,320 --> 00:13:34,800
constraints which is here here the

390
00:13:34,800 --> 00:13:37,440
person is doing single static assignment

391
00:13:37,440 --> 00:13:40,399
um a form which means like each variable

392
00:13:40,399 --> 00:13:42,000
is only assigned once you don't have

393
00:13:42,000 --> 00:13:43,519
like multiple assignments for the same

394
00:13:43,519 --> 00:13:44,480
variable

395
00:13:44,480 --> 00:13:46,880
um and once that's there you can you can

396
00:13:46,880 --> 00:13:48,160
you know more easily convert it to

397
00:13:48,160 --> 00:13:49,360
boolean constraints you're going to

398
00:13:49,360 --> 00:13:51,360
break this down into

399
00:13:51,360 --> 00:13:53,440
symbolic bit vectors when you have an

400
00:13:53,440 --> 00:13:54,959
int you're not going to just have one

401
00:13:54,959 --> 00:13:57,360
variable you're going to have you know a

402
00:13:57,360 --> 00:14:00,000
variable for each bit in the int and you

403
00:14:00,000 --> 00:14:01,920
know break it down like that not going

404
00:14:01,920 --> 00:14:03,839
to get into the mechanics of it too much

405
00:14:03,839 --> 00:14:06,000
but you're converting a program and it's

406
00:14:06,000 --> 00:14:08,079
conditional statements because let's say

407
00:14:08,079 --> 00:14:11,040
you have uh if statement uh nested if

408
00:14:11,040 --> 00:14:12,959
statements that reach a certain place

409
00:14:12,959 --> 00:14:14,720
what will happen is if you want to know

410
00:14:14,720 --> 00:14:16,639
what's what's what's required to reach

411
00:14:16,639 --> 00:14:18,880
that place you'll actually have to you

412
00:14:18,880 --> 00:14:21,360
have to latch on to the to the variables

413
00:14:21,360 --> 00:14:24,160
these conditions of if this and that and

414
00:14:24,160 --> 00:14:25,920
that if statement and the if statement

415
00:14:25,920 --> 00:14:27,920
and this this is why you see these you

416
00:14:27,920 --> 00:14:30,399
know upside down kind of lambda looking

417
00:14:30,399 --> 00:14:31,920
um a

418
00:14:31,920 --> 00:14:34,399
kind of symbols that's the and symbol um

419
00:14:34,399 --> 00:14:35,600
i don't know if my mouse is going to

420
00:14:35,600 --> 00:14:38,480
record now but this is the and symbol

421
00:14:38,480 --> 00:14:40,720
and this is how you can see various if

422
00:14:40,720 --> 00:14:43,519
statements get latched on in a program

423
00:14:43,519 --> 00:14:45,920
path we'll talk about program path in a

424
00:14:45,920 --> 00:14:48,959
second um so the basic process is that

425
00:14:48,959 --> 00:14:52,000
you you're going to take a a c program

426
00:14:52,000 --> 00:14:54,240
or a program in our case it's a binary

427
00:14:54,240 --> 00:14:57,040
it doesn't matter what the source

428
00:14:57,040 --> 00:14:59,360
type is this works for any programming

429
00:14:59,360 --> 00:15:02,000
language um even works it works for ir

430
00:15:02,000 --> 00:15:04,720
intermediate languages it and as we saw

431
00:15:04,720 --> 00:15:06,079
it works for hardware language if it

432
00:15:06,079 --> 00:15:08,639
works with verilog then surely it will

433
00:15:08,639 --> 00:15:10,160
work for the for the you know the higher

434
00:15:10,160 --> 00:15:13,519
level languages as well so

435
00:15:13,519 --> 00:15:14,800
you basically have if you want to

436
00:15:14,800 --> 00:15:16,639
describe a symbolic state and build a

437
00:15:16,639 --> 00:15:18,720
symbolic state map

438
00:15:18,720 --> 00:15:19,920
you're going to have three things you

439
00:15:19,920 --> 00:15:22,320
describe one is the variable store to

440
00:15:22,320 --> 00:15:24,560
the path condition and you're going to

441
00:15:24,560 --> 00:15:26,880
have to be able to describe the um

442
00:15:26,880 --> 00:15:28,399
the state uh

443
00:15:28,399 --> 00:15:30,160
as unique you're gonna have to state id

444
00:15:30,160 --> 00:15:32,320
you don't wanna confuse states with one

445
00:15:32,320 --> 00:15:33,680
another so you'll have to be able to

446
00:15:33,680 --> 00:15:35,040
uniquely

447
00:15:35,040 --> 00:15:37,040
identify them and the way this works is

448
00:15:37,040 --> 00:15:38,800
as you encounter statements you

449
00:15:38,800 --> 00:15:41,199
symbolize the variables involved and you

450
00:15:41,199 --> 00:15:43,120
record the past statements required to

451
00:15:43,120 --> 00:15:46,399
reach that those those statements so

452
00:15:46,399 --> 00:15:48,959
our first state is representing the path

453
00:15:48,959 --> 00:15:51,839
that's required the the the stuff that

454
00:15:51,839 --> 00:15:54,399
will it represents the

455
00:15:54,399 --> 00:15:55,759
the way that the variable still will be

456
00:15:55,759 --> 00:15:58,079
affected and the and the path condition

457
00:15:58,079 --> 00:16:00,320
that needs to be satisfied

458
00:16:00,320 --> 00:16:01,600
to reach

459
00:16:01,600 --> 00:16:04,000
statement one two three that statement

460
00:16:04,000 --> 00:16:05,920
uh program statement one two three that

461
00:16:05,920 --> 00:16:08,240
symbolic state number i number one and

462
00:16:08,240 --> 00:16:10,079
you can see in in the variable store all

463
00:16:10,079 --> 00:16:11,759
we've done is symbolize x and y we've

464
00:16:11,759 --> 00:16:14,720
said x has to be symbolizes a and y has

465
00:16:14,720 --> 00:16:16,560
to be symbolized as b and the path

466
00:16:16,560 --> 00:16:18,639
condition is just simply a true because

467
00:16:18,639 --> 00:16:20,000
nothing needs to happen to actually

468
00:16:20,000 --> 00:16:21,199
reach it you'll always reach it no

469
00:16:21,199 --> 00:16:23,360
matter what so it's just a true and then

470
00:16:23,360 --> 00:16:24,560
at the bottom you know just for

471
00:16:24,560 --> 00:16:26,560
documentation say we're showing the

472
00:16:26,560 --> 00:16:28,639
program state associated to this now

473
00:16:28,639 --> 00:16:30,079
when you encounter an if statement this

474
00:16:30,079 --> 00:16:31,440
is very important you can actually

475
00:16:31,440 --> 00:16:33,519
envelop both sides of the if statement

476
00:16:33,519 --> 00:16:35,440
in analysis you can immediately have a

477
00:16:35,440 --> 00:16:37,120
view of both sides of this if statement

478
00:16:37,120 --> 00:16:38,639
when you want to make decisions so

479
00:16:38,639 --> 00:16:40,800
imagine fuzzing using this like you're

480
00:16:40,800 --> 00:16:42,880
not going to have the fuzzer blindly

481
00:16:42,880 --> 00:16:44,959
guess like oh just guess until you get

482
00:16:44,959 --> 00:16:46,880
both sides the fuzzer can actually have

483
00:16:46,880 --> 00:16:49,199
view of i need if i want to reach the

484
00:16:49,199 --> 00:16:50,560
one side

485
00:16:50,560 --> 00:16:52,240
i'm gonna i'm gonna look at statement

486
00:16:52,240 --> 00:16:55,120
state number two the successor state and

487
00:16:55,120 --> 00:16:57,199
i'm gonna say okay my path variable

488
00:16:57,199 --> 00:16:59,759
requires symbolized variable a plus

489
00:16:59,759 --> 00:17:01,279
symbolize variable b to be bigger than

490
00:17:01,279 --> 00:17:04,400
ten and um it it's gonna mean that my

491
00:17:04,400 --> 00:17:06,160
variable stall will update in this way

492
00:17:06,160 --> 00:17:08,079
once i've reached it it'll it'll it'll

493
00:17:08,079 --> 00:17:11,359
update a as uh b minus one and so this

494
00:17:11,359 --> 00:17:13,119
and so the other side is just a not

495
00:17:13,119 --> 00:17:15,439
condition of that it just says p has to

496
00:17:15,439 --> 00:17:18,720
be a plus b has to be um smaller or

497
00:17:18,720 --> 00:17:20,640
equal to ten okay that's that's the

498
00:17:20,640 --> 00:17:23,119
that's a not condition of the other side

499
00:17:23,119 --> 00:17:25,039
so now so now we immediately and you

500
00:17:25,039 --> 00:17:27,599
have both sides and we can decide um

501
00:17:27,599 --> 00:17:29,280
whether they're interesting like you can

502
00:17:29,280 --> 00:17:31,120
you can say is it interesting to our

503
00:17:31,120 --> 00:17:34,160
analysis that a should be b minus 10 you

504
00:17:34,160 --> 00:17:36,400
know we don't want to subtract um too

505
00:17:36,400 --> 00:17:38,559
much from y maybe in our path we know

506
00:17:38,559 --> 00:17:40,640
that for our analysis we want to look at

507
00:17:40,640 --> 00:17:42,320
all the cases where y

508
00:17:42,320 --> 00:17:45,440
is um is only subtracted from once so

509
00:17:45,440 --> 00:17:47,120
therefore the only parts we're going to

510
00:17:47,120 --> 00:17:50,000
be interested in is is the ones where y

511
00:17:50,000 --> 00:17:50,880
um

512
00:17:50,880 --> 00:17:52,480
it doesn't have the subtraction you can

513
00:17:52,480 --> 00:17:54,799
immediately see that here from just

514
00:17:54,799 --> 00:17:56,240
looking at the if statement so that's

515
00:17:56,240 --> 00:17:58,480
kind of the power of this analysis but

516
00:17:58,480 --> 00:18:00,720
this is how we build the path path

517
00:18:00,720 --> 00:18:03,120
conditions we update the variable store

518
00:18:03,120 --> 00:18:04,960
and we associate the program statements

519
00:18:04,960 --> 00:18:06,400
to it so we can make decisions going

520
00:18:06,400 --> 00:18:08,559
forward so you need to imagine this map

521
00:18:08,559 --> 00:18:10,240
but like involving thousands of

522
00:18:10,240 --> 00:18:12,320
different states you know

523
00:18:12,320 --> 00:18:13,520
and again

524
00:18:13,520 --> 00:18:16,160
states will grow pretty fast um they can

525
00:18:16,160 --> 00:18:18,799
grow so fast in fact that they overwhelm

526
00:18:18,799 --> 00:18:20,080
a um

527
00:18:20,080 --> 00:18:21,360
analysis and that's called state

528
00:18:21,360 --> 00:18:23,679
explosion because as you've just noticed

529
00:18:23,679 --> 00:18:26,320
every time you introduce another state

530
00:18:26,320 --> 00:18:27,280
um

531
00:18:27,280 --> 00:18:28,640
another if statement you're gonna you're

532
00:18:28,640 --> 00:18:31,039
gonna fork that state into two at least

533
00:18:31,039 --> 00:18:32,960
two successes you know you could have

534
00:18:32,960 --> 00:18:35,679
you could have if then else or if if if

535
00:18:35,679 --> 00:18:36,960
then um

536
00:18:36,960 --> 00:18:39,919
if else else else you know you else if

537
00:18:39,919 --> 00:18:41,520
else of else if you get a bunch of

538
00:18:41,520 --> 00:18:43,200
different if statements which means you

539
00:18:43,200 --> 00:18:45,840
explode into even more states um and

540
00:18:45,840 --> 00:18:47,520
what they can do is actually make sure

541
00:18:47,520 --> 00:18:50,000
that your analysis has so many paths to

542
00:18:50,000 --> 00:18:52,320
look at that it just becomes infeasible

543
00:18:52,320 --> 00:18:54,320
to look at all of these paths and that's

544
00:18:54,320 --> 00:18:57,039
called state explosion um

545
00:18:57,039 --> 00:18:58,960
uh and obviously the other problem with

546
00:18:58,960 --> 00:19:01,039
this is that it's um dependent on

547
00:19:01,039 --> 00:19:02,559
constraint solving which means you have

548
00:19:02,559 --> 00:19:04,160
to churn through

549
00:19:04,160 --> 00:19:06,480
an undefinable amount of time to

550
00:19:06,480 --> 00:19:08,160
actually get your answer so there's just

551
00:19:08,160 --> 00:19:10,480
two hard edges to it

552
00:19:10,480 --> 00:19:12,320
which we have to rely on optimization

553
00:19:12,320 --> 00:19:13,600
problems to get around and they're

554
00:19:13,600 --> 00:19:15,600
pretty elaborate optimization problems

555
00:19:15,600 --> 00:19:17,679
you can cache um constraint solving

556
00:19:17,679 --> 00:19:19,840
results it turns out that like

557
00:19:19,840 --> 00:19:21,600
normal programs they don't tend to have

558
00:19:21,600 --> 00:19:24,720
like wild you know um introduction of

559
00:19:24,720 --> 00:19:27,280
variables um in if statements they tend

560
00:19:27,280 --> 00:19:30,000
to incrementally add um conditions so

561
00:19:30,000 --> 00:19:31,840
you would say like you know if a is

562
00:19:31,840 --> 00:19:33,840
bigger than c and then next time you're

563
00:19:33,840 --> 00:19:35,280
not going to do like x and y maybe

564
00:19:35,280 --> 00:19:36,720
you're going to be like if a is bigger

565
00:19:36,720 --> 00:19:39,280
than c or bigger than d you know you you

566
00:19:39,280 --> 00:19:41,039
you'll kind of latch on

567
00:19:41,039 --> 00:19:43,360
um to a core form you're going to core

568
00:19:43,360 --> 00:19:45,679
form of constraints you you tend to pick

569
00:19:45,679 --> 00:19:46,400
up

570
00:19:46,400 --> 00:19:47,200
um

571
00:19:47,200 --> 00:19:49,440
you know little adages of constraints

572
00:19:49,440 --> 00:19:52,080
which means you can probably reuse

573
00:19:52,080 --> 00:19:54,320
solutions every time you ask a question

574
00:19:54,320 --> 00:19:55,760
it's very useful it's very useful it

575
00:19:55,760 --> 00:19:57,360
turns out to do that then there's also

576
00:19:57,360 --> 00:19:59,120
something called state merging which

577
00:19:59,120 --> 00:20:00,400
means that like

578
00:20:00,400 --> 00:20:03,600
if you if you split a state if statement

579
00:20:03,600 --> 00:20:05,200
and let's look at the previous example

580
00:20:05,200 --> 00:20:07,360
again it's a good example to work from

581
00:20:07,360 --> 00:20:09,280
if you split the successor states you'll

582
00:20:09,280 --> 00:20:11,360
see that in this program they end up

583
00:20:11,360 --> 00:20:12,960
reaching the same point they're both

584
00:20:12,960 --> 00:20:14,960
going to reach the same return statement

585
00:20:14,960 --> 00:20:18,000
which means if you don't have any use

586
00:20:18,000 --> 00:20:19,200
you know let's say let's say there's a

587
00:20:19,200 --> 00:20:21,039
longer program beneath this before the

588
00:20:21,039 --> 00:20:22,880
return statement if you don't have any

589
00:20:22,880 --> 00:20:25,120
use in maintaining both paths and

590
00:20:25,120 --> 00:20:26,320
latching on

591
00:20:26,320 --> 00:20:28,400
the same information to both paths you

592
00:20:28,400 --> 00:20:30,880
can just merge them um at the end and

593
00:20:30,880 --> 00:20:32,480
say okay these split at a certain point

594
00:20:32,480 --> 00:20:35,120
but they merge again because both both

595
00:20:35,120 --> 00:20:36,880
sides will exit the same if statement

596
00:20:36,880 --> 00:20:38,320
essentially and that's called state

597
00:20:38,320 --> 00:20:41,360
merging it avoids having to maintain two

598
00:20:41,360 --> 00:20:43,360
separate paths that will behave exactly

599
00:20:43,360 --> 00:20:44,320
the same

600
00:20:44,320 --> 00:20:45,760
and then there's also directed

601
00:20:45,760 --> 00:20:47,600
exploration methods randomized

602
00:20:47,600 --> 00:20:49,840
exploration methods which uh tell you

603
00:20:49,840 --> 00:20:51,200
like look you don't have to explore

604
00:20:51,200 --> 00:20:53,600
every single path every single go down

605
00:20:53,600 --> 00:20:54,880
every single

606
00:20:54,880 --> 00:20:58,240
state association or follow every single

607
00:20:58,240 --> 00:21:00,000
direction in the state map you can just

608
00:21:00,000 --> 00:21:01,280
stick to the ones that are interesting

609
00:21:01,280 --> 00:21:03,280
to your analysis for instance you can

610
00:21:03,280 --> 00:21:05,039
explore states that will always end in a

611
00:21:05,039 --> 00:21:07,360
mem copy and there's ways to optimize it

612
00:21:07,360 --> 00:21:09,200
so you never step down states that don't

613
00:21:09,200 --> 00:21:10,480
end up there that's called directed

614
00:21:10,480 --> 00:21:12,640
execution which i'll show an example of

615
00:21:12,640 --> 00:21:14,559
in a second now i talked about state

616
00:21:14,559 --> 00:21:16,320
explosion and this is what it looks like

617
00:21:16,320 --> 00:21:18,159
you this is a typical map of some random

618
00:21:18,159 --> 00:21:21,919
binaries on an ubuntu 20.4 machine

619
00:21:21,919 --> 00:21:24,000
and what happens here is i'm graphing

620
00:21:24,000 --> 00:21:25,840
execution steps which is the x-axis

621
00:21:25,840 --> 00:21:27,360
versus

622
00:21:27,360 --> 00:21:28,960
active state which is the y and i'm

623
00:21:28,960 --> 00:21:30,720
showing how fast they grow so you can

624
00:21:30,720 --> 00:21:33,679
look at um kind of in relative terms how

625
00:21:33,679 --> 00:21:35,280
many steps you'll get before you

626
00:21:35,280 --> 00:21:37,360
probably start exploding so the yellow

627
00:21:37,360 --> 00:21:39,120
line the first yellow line obviously

628
00:21:39,120 --> 00:21:41,360
that's you know exploded like you you're

629
00:21:41,360 --> 00:21:43,280
never going to get to 50 steps unless

630
00:21:43,280 --> 00:21:44,720
you maybe have a super computer right

631
00:21:44,720 --> 00:21:45,840
like

632
00:21:45,840 --> 00:21:47,520
it grows pretty fast and as i said it's

633
00:21:47,520 --> 00:21:49,280
an exponential graph you know it's a

634
00:21:49,280 --> 00:21:51,919
logarithmic graph so uh it looks like a

635
00:21:51,919 --> 00:21:54,320
logarithmic graph so this kind of

636
00:21:54,320 --> 00:21:56,720
tells my you know

637
00:21:56,720 --> 00:21:59,120
makes my point pretty successfully um

638
00:21:59,120 --> 00:22:00,880
and so this is another picture of how

639
00:22:00,880 --> 00:22:03,520
states grow these this is um something i

640
00:22:03,520 --> 00:22:05,600
graphed put together with a little tool

641
00:22:05,600 --> 00:22:08,240
i wrote again based on anger all it does

642
00:22:08,240 --> 00:22:12,320
is step through states it collects up um

643
00:22:12,320 --> 00:22:14,159
it collects up

644
00:22:14,159 --> 00:22:14,960
the

645
00:22:14,960 --> 00:22:17,840
the uh symbolic states and works out how

646
00:22:17,840 --> 00:22:20,080
they're associated to each other in a

647
00:22:20,080 --> 00:22:22,159
directed graph format so you're looking

648
00:22:22,159 --> 00:22:23,200
at

649
00:22:23,200 --> 00:22:25,520
one state becomes two states and is

650
00:22:25,520 --> 00:22:27,039
reachable from this state to that state

651
00:22:27,039 --> 00:22:28,559
this is actually how this works it's

652
00:22:28,559 --> 00:22:31,280
kind of like a cfg four state for four

653
00:22:31,280 --> 00:22:33,039
symbolic states on the one side we have

654
00:22:33,039 --> 00:22:35,120
gnu debugger and you can see the actual

655
00:22:35,120 --> 00:22:36,640
point where states start exploding and

656
00:22:36,640 --> 00:22:38,480
growing at an exponential rate on the

657
00:22:38,480 --> 00:22:40,159
other hand we have object dump and the

658
00:22:40,159 --> 00:22:42,000
interesting thing here is there's

659
00:22:42,000 --> 00:22:44,159
definitely loops that you can you can

660
00:22:44,159 --> 00:22:46,080
see um you know just loosely with your

661
00:22:46,080 --> 00:22:47,679
eye and the gnu debuggers in the new

662
00:22:47,679 --> 00:22:49,840
debugger picture and that's obviously

663
00:22:49,840 --> 00:22:51,200
because new debugger actually wants to

664
00:22:51,200 --> 00:22:52,880
run a program that could happen

665
00:22:52,880 --> 00:22:54,320
indefinitely so you'll definitely have

666
00:22:54,320 --> 00:22:57,280
loops that uh try to try to iterate the

667
00:22:57,280 --> 00:23:00,000
program over and over um and on the

668
00:23:00,000 --> 00:23:01,360
other side you have object dump which

669
00:23:01,360 --> 00:23:02,960
isn't going to run anything it's just

670
00:23:02,960 --> 00:23:04,640
going to read a file and if it doesn't

671
00:23:04,640 --> 00:23:06,720
see what it wants it'll exit so you're

672
00:23:06,720 --> 00:23:07,919
looking at this you know this nice

673
00:23:07,919 --> 00:23:10,320
dragon on the one side and a scorpion or

674
00:23:10,320 --> 00:23:12,159
something on the other um or what what

675
00:23:12,159 --> 00:23:13,840
have you but it's interesting to see the

676
00:23:13,840 --> 00:23:16,320
actual behaviors reflected in in the

677
00:23:16,320 --> 00:23:18,880
symbolic states it's very very cool

678
00:23:18,880 --> 00:23:21,200
so what is anger well basically anger is

679
00:23:21,200 --> 00:23:23,360
a collection of technologies it comes

680
00:23:23,360 --> 00:23:25,440
from um

681
00:23:25,440 --> 00:23:27,280
some technology that was submitted to

682
00:23:27,280 --> 00:23:29,200
the cyber grand challenge that darpa

683
00:23:29,200 --> 00:23:31,440
hosted in 2016.

684
00:23:31,440 --> 00:23:34,240
and basically it was it was uh it came

685
00:23:34,240 --> 00:23:35,919
together as a bunch of stuff that was

686
00:23:35,919 --> 00:23:38,240
meant to help automate vulnerability

687
00:23:38,240 --> 00:23:41,440
discovery in binary programs and the the

688
00:23:41,440 --> 00:23:43,760
technology that's involved um is first

689
00:23:43,760 --> 00:23:45,840
of all the capstone disassembly library

690
00:23:45,840 --> 00:23:47,919
so when you throw a binary in capstone

691
00:23:47,919 --> 00:23:49,360
is going to be doing the heavy lifting

692
00:23:49,360 --> 00:23:51,440
in terms of disassembling and making

693
00:23:51,440 --> 00:23:54,720
sense of actual um executable format um

694
00:23:54,720 --> 00:23:56,720
it also relies on something that the

695
00:23:56,720 --> 00:23:58,400
anger team wrote you know anger teams

696
00:23:58,400 --> 00:24:00,080
from uc santa barbara the other thing

697
00:24:00,080 --> 00:24:02,159
that they contributed you know in-house

698
00:24:02,159 --> 00:24:05,120
to this is cli the the actual binary

699
00:24:05,120 --> 00:24:07,440
loader which centrally loads everything

700
00:24:07,440 --> 00:24:09,200
if you have a unix beard you kind of

701
00:24:09,200 --> 00:24:11,520
know about these cool um recursive

702
00:24:11,520 --> 00:24:13,679
acronyms please trying to trying to

703
00:24:13,679 --> 00:24:15,600
evoke memory of those

704
00:24:15,600 --> 00:24:18,320
and the the ir language if you know

705
00:24:18,320 --> 00:24:19,600
anything about compilers you know that

706
00:24:19,600 --> 00:24:21,760
an ir language or intermediate

707
00:24:21,760 --> 00:24:23,600
representation language is going to be

708
00:24:23,600 --> 00:24:24,880
part of this whole process and the one

709
00:24:24,880 --> 00:24:27,600
that this is based on is called vex ir

710
00:24:27,600 --> 00:24:30,720
so it's vex ir comes from valgrind you

711
00:24:30,720 --> 00:24:33,440
know the hal grind technologies um it's

712
00:24:33,440 --> 00:24:36,240
uh it's stuff that uh that uh

713
00:24:36,240 --> 00:24:39,200
used to i believe thread sanitizer used

714
00:24:39,200 --> 00:24:41,919
to be uh based on on this stuff um and

715
00:24:41,919 --> 00:24:44,480
then they moved to to llvm

716
00:24:44,480 --> 00:24:46,400
they're not mistaken but vex ir is

717
00:24:46,400 --> 00:24:47,520
integrated into a lot of different

718
00:24:47,520 --> 00:24:49,840
projects because it's just works well um

719
00:24:49,840 --> 00:24:52,080
or used to be and if you want synergy

720
00:24:52,080 --> 00:24:54,000
with those things you want to implement

721
00:24:54,000 --> 00:24:55,840
the solutions that they implement for

722
00:24:55,840 --> 00:24:57,760
program analysis you can immediately do

723
00:24:57,760 --> 00:24:59,360
that in anger now because of because of

724
00:24:59,360 --> 00:25:01,760
the way that they supported this stuff

725
00:25:01,760 --> 00:25:04,159
and to turn vex ir into something that a

726
00:25:04,159 --> 00:25:06,159
constraint solver likes it relies on

727
00:25:06,159 --> 00:25:08,080
something called clarify

728
00:25:08,080 --> 00:25:10,159
which takes um you know

729
00:25:10,159 --> 00:25:12,559
types and splits them out into like if

730
00:25:12,559 --> 00:25:14,080
you have an integer and you want the

731
00:25:14,080 --> 00:25:16,159
integer to be symbolized it'll spit it

732
00:25:16,159 --> 00:25:16,960
out

733
00:25:16,960 --> 00:25:18,880
into into z3 in

734
00:25:18,880 --> 00:25:20,640
a way that it likes so you can actually

735
00:25:20,640 --> 00:25:22,320
solve constraints based on that and

736
00:25:22,320 --> 00:25:23,919
anger is the thing that kind of mediates

737
00:25:23,919 --> 00:25:25,360
this whole process

738
00:25:25,360 --> 00:25:28,000
models memory associates stack and you

739
00:25:28,000 --> 00:25:29,440
know block count depth and all these

740
00:25:29,440 --> 00:25:31,200
nice things to the actual constraint

741
00:25:31,200 --> 00:25:33,919
solving you're doing um and obviously if

742
00:25:33,919 --> 00:25:36,000
you want to actually host a session in

743
00:25:36,000 --> 00:25:38,720
anger and and and somatically execute a

744
00:25:38,720 --> 00:25:40,480
binary you're going to need to need to

745
00:25:40,480 --> 00:25:42,400
know about three key things the first

746
00:25:42,400 --> 00:25:44,400
one is the project the angular project

747
00:25:44,400 --> 00:25:45,919
the simulation manager and the some

748
00:25:45,919 --> 00:25:47,760
state

749
00:25:47,760 --> 00:25:49,760
what happens is you load your binary up

750
00:25:49,760 --> 00:25:52,159
into a project you uh

751
00:25:52,159 --> 00:25:54,000
you set up a simulation manager and you

752
00:25:54,000 --> 00:25:56,880
step through simulation

753
00:25:56,880 --> 00:25:58,159
step through the simulation i'll show

754
00:25:58,159 --> 00:26:00,400
you how how that looks in a second um

755
00:26:00,400 --> 00:26:02,799
and out of that step will come

756
00:26:02,799 --> 00:26:04,960
anger states some states and then some

757
00:26:04,960 --> 00:26:07,039
states allow you to evoke the solver so

758
00:26:07,039 --> 00:26:08,480
once you have a some state you can say

759
00:26:08,480 --> 00:26:09,840
hey

760
00:26:09,840 --> 00:26:11,039
solver

761
00:26:11,039 --> 00:26:12,960
from the swim state what do i need in

762
00:26:12,960 --> 00:26:14,960
terms of my symbolic variables to reach

763
00:26:14,960 --> 00:26:17,200
this some state and you can also look at

764
00:26:17,200 --> 00:26:18,799
where what the registers will look like

765
00:26:18,799 --> 00:26:20,080
what the memory will look like in that

766
00:26:20,080 --> 00:26:21,919
state you can even add your own plugins

767
00:26:21,919 --> 00:26:24,320
to this process as well

768
00:26:24,320 --> 00:26:26,400
as i mentioned i i haven't mentioned

769
00:26:26,400 --> 00:26:28,159
this yet

770
00:26:28,159 --> 00:26:30,159
but the simulation manager has stashes

771
00:26:30,159 --> 00:26:32,720
so the stashers will have active dead

772
00:26:32,720 --> 00:26:35,360
ended de-prioritized states as a couple

773
00:26:35,360 --> 00:26:36,799
of there's a couple of categories you

774
00:26:36,799 --> 00:26:38,240
can even add your own stashes

775
00:26:38,240 --> 00:26:39,840
arbitrarily if you want it's just an

776
00:26:39,840 --> 00:26:42,159
associative dictionary but the default

777
00:26:42,159 --> 00:26:44,400
ones that you need to know about are um

778
00:26:44,400 --> 00:26:47,440
unset uh the active dead-ended and

779
00:26:47,440 --> 00:26:49,520
unsatisfiable and unsatisfiable states

780
00:26:49,520 --> 00:26:50,640
those are i think the ones you're going

781
00:26:50,640 --> 00:26:52,240
to be worried about the most the active

782
00:26:52,240 --> 00:26:53,600
states are the ones that can still be

783
00:26:53,600 --> 00:26:55,120
stepped forward in execution the

784
00:26:55,120 --> 00:26:57,039
dead-ended ones are the ones that aren't

785
00:26:57,039 --> 00:26:58,480
and the unsatisfiable states are the

786
00:26:58,480 --> 00:27:01,039
ones whose constraints are not

787
00:27:01,039 --> 00:27:03,600
satisfiable um

788
00:27:03,600 --> 00:27:05,360
uh the answers and there's also like

789
00:27:05,360 --> 00:27:07,760
unconstrained states stuff states that i

790
00:27:07,760 --> 00:27:11,520
believe um rely on on symbolized

791
00:27:11,520 --> 00:27:13,679
in input um

792
00:27:13,679 --> 00:27:15,440
but you can also stuff into the

793
00:27:15,440 --> 00:27:17,039
simulation manager

794
00:27:17,039 --> 00:27:19,840
exploration techniques of your own which

795
00:27:19,840 --> 00:27:21,919
there's some nice built-in exploration

796
00:27:21,919 --> 00:27:23,600
techniques already things that help you

797
00:27:23,600 --> 00:27:25,760
save memory that uh that keep the

798
00:27:25,760 --> 00:27:28,559
program going um there's things that uh

799
00:27:28,559 --> 00:27:30,799
actually direct execution towards

800
00:27:30,799 --> 00:27:32,720
certain program states and i'll show you

801
00:27:32,720 --> 00:27:34,720
how they look in a second but that's

802
00:27:34,720 --> 00:27:36,480
basically the spiel

803
00:27:36,480 --> 00:27:38,559
so the workflow is pretty simple you're

804
00:27:38,559 --> 00:27:39,600
going to

805
00:27:39,600 --> 00:27:41,440
load a binary into anger and this is

806
00:27:41,440 --> 00:27:43,039
what the python looks like for that very

807
00:27:43,039 --> 00:27:45,840
simple angular project give me a binary

808
00:27:45,840 --> 00:27:47,679
and at this point you know i'm not going

809
00:27:47,679 --> 00:27:49,360
to show this now but you can derive a

810
00:27:49,360 --> 00:27:51,840
cfg you can check out the sections and

811
00:27:51,840 --> 00:27:54,159
the symbols and and expect actually the

812
00:27:54,159 --> 00:27:57,200
alf like alphas properties of the binary

813
00:27:57,200 --> 00:27:59,200
and ask questions around that

814
00:27:59,200 --> 00:28:00,320
um

815
00:28:00,320 --> 00:28:02,080
the the second thing is like once you

816
00:28:02,080 --> 00:28:03,200
have your binary loaded you want to

817
00:28:03,200 --> 00:28:05,039
build an initial state and as you can

818
00:28:05,039 --> 00:28:07,840
see here you you your your initial state

819
00:28:07,840 --> 00:28:09,520
you just go product or factory give me

820
00:28:09,520 --> 00:28:11,520
an entry state and you can actually ask

821
00:28:11,520 --> 00:28:13,200
for a full state where everything is

822
00:28:13,200 --> 00:28:15,919
symbolized a blank state where basically

823
00:28:15,919 --> 00:28:18,000
nothing is and a custom state which is

824
00:28:18,000 --> 00:28:19,679
you know whatever you want to symbolize

825
00:28:19,679 --> 00:28:21,200
here's a custom state i'm kind of

826
00:28:21,200 --> 00:28:24,559
building where i'm saying look um i want

827
00:28:24,559 --> 00:28:27,520
og v you know i want to symbolize aug v

828
00:28:27,520 --> 00:28:30,640
um the array and i want you know um

829
00:28:30,640 --> 00:28:33,840
eight position you want i want um

830
00:28:33,840 --> 00:28:36,399
you know odd count amount of amount of

831
00:28:36,399 --> 00:28:38,240
rgv arguments and they got to be eight

832
00:28:38,240 --> 00:28:40,000
bits um

833
00:28:40,000 --> 00:28:41,679
times whatever length i give it and then

834
00:28:41,679 --> 00:28:45,039
also naming them og something you know

835
00:28:45,039 --> 00:28:47,039
argh 1 or 2 3 whatever

836
00:28:47,039 --> 00:28:48,240
and then you just stick that in the

837
00:28:48,240 --> 00:28:50,080
entry state and bob's your uncle the

838
00:28:50,080 --> 00:28:51,919
other thing that i'm mentioning is

839
00:28:51,919 --> 00:28:53,520
optional here is you can actually hook

840
00:28:53,520 --> 00:28:56,320
symbols so you can tell it hey project

841
00:28:56,320 --> 00:28:58,240
whenever you're in execution and you

842
00:28:58,240 --> 00:29:01,200
reach let's say p thread create um

843
00:29:01,200 --> 00:29:02,880
please call this function and once you

844
00:29:02,880 --> 00:29:05,200
call that function um it's called a sim

845
00:29:05,200 --> 00:29:07,600
procedure you can actually call another

846
00:29:07,600 --> 00:29:09,520
function if you like do a bunch of stuff

847
00:29:09,520 --> 00:29:11,760
with the arguments return from whatever

848
00:29:11,760 --> 00:29:14,159
call you made then continue executing

849
00:29:14,159 --> 00:29:16,559
it's it's basically like hosting a break

850
00:29:16,559 --> 00:29:18,720
point in in a debugging session if you

851
00:29:18,720 --> 00:29:19,840
like

852
00:29:19,840 --> 00:29:21,360
um so

853
00:29:21,360 --> 00:29:22,640
you build the state you model your

854
00:29:22,640 --> 00:29:24,720
variables and kind of this this is

855
00:29:24,720 --> 00:29:26,880
already shown in the previous slide but

856
00:29:26,880 --> 00:29:28,960
um modeling variables means you know

857
00:29:28,960 --> 00:29:31,120
modeling files registers memory

858
00:29:31,120 --> 00:29:32,960
environments and what have you

859
00:29:32,960 --> 00:29:35,440
and once you have your binary loaded

860
00:29:35,440 --> 00:29:36,880
your um

861
00:29:36,880 --> 00:29:38,559
environment modeled you can just step

862
00:29:38,559 --> 00:29:40,240
through the simulation manager and this

863
00:29:40,240 --> 00:29:42,000
is your straightforward how you do this

864
00:29:42,000 --> 00:29:44,399
you go angular simulation manager step

865
00:29:44,399 --> 00:29:46,799
and you tell it hey um this the stash i

866
00:29:46,799 --> 00:29:49,760
want to um step is this stash it doesn't

867
00:29:49,760 --> 00:29:51,679
have to be the active status it can be

868
00:29:51,679 --> 00:29:53,360
the unconstrained states it could be the

869
00:29:53,360 --> 00:29:55,919
unsatisfiable straight

870
00:29:55,919 --> 00:29:56,960
states

871
00:29:56,960 --> 00:29:59,279
but for argument's sake you probably

872
00:29:59,279 --> 00:30:01,440
you know default by default

873
00:30:01,440 --> 00:30:02,640
you'll be stepping through the active

874
00:30:02,640 --> 00:30:04,960
states um and let's look at a quick

875
00:30:04,960 --> 00:30:07,120
example now the typical thing that you

876
00:30:07,120 --> 00:30:08,640
do when you get a binary is you maybe

877
00:30:08,640 --> 00:30:10,399
want to check the static strings that

878
00:30:10,399 --> 00:30:12,320
typically tends to get you some some

879
00:30:12,320 --> 00:30:14,640
metadata on what to expect it'll tell

880
00:30:14,640 --> 00:30:16,480
you like oh it's going to print this

881
00:30:16,480 --> 00:30:18,240
string somewhere and it's going to do

882
00:30:18,240 --> 00:30:19,360
something with that string somewhere

883
00:30:19,360 --> 00:30:21,760
else so it gives you some some semantic

884
00:30:21,760 --> 00:30:23,520
information not much there's not much

885
00:30:23,520 --> 00:30:25,360
context to it but here's an example

886
00:30:25,360 --> 00:30:27,039
where that wins you nothing if you look

887
00:30:27,039 --> 00:30:29,840
at this binary it's uh it's checking og

888
00:30:29,840 --> 00:30:31,679
v against you know the string called km

889
00:30:31,679 --> 00:30:33,600
sec and anyone can tell you if they can

890
00:30:33,600 --> 00:30:36,559
read c that it basically wants argv 1 to

891
00:30:36,559 --> 00:30:39,440
be the string km sec um but if i strings

892
00:30:39,440 --> 00:30:41,200
this i will not see the string km sec

893
00:30:41,200 --> 00:30:42,640
i'll not see that at all

894
00:30:42,640 --> 00:30:45,679
but when i run this in a tool that i

895
00:30:45,679 --> 00:30:47,840
that i wrote based on anger it very

896
00:30:47,840 --> 00:30:50,080
easily works out you know to get to that

897
00:30:50,080 --> 00:30:51,840
string copy and again this is the

898
00:30:51,840 --> 00:30:54,240
directed execution i was talking about

899
00:30:54,240 --> 00:30:55,520
the the tool that i wrote here called

900
00:30:55,520 --> 00:30:57,360
sport crawler will actually go through

901
00:30:57,360 --> 00:30:59,760
the binary and work out how to get to

902
00:30:59,760 --> 00:31:02,159
memory sensitive calls so it'll look for

903
00:31:02,159 --> 00:31:03,840
how do i get to mem copies how do i get

904
00:31:03,840 --> 00:31:06,399
the mem set string copy string n copies

905
00:31:06,399 --> 00:31:08,399
how do i get to functions

906
00:31:08,399 --> 00:31:10,799
from a known execution state which is

907
00:31:10,799 --> 00:31:13,440
like just the first executable state how

908
00:31:13,440 --> 00:31:15,440
do i get from that to these dangerous

909
00:31:15,440 --> 00:31:17,919
functions and what does my what is my

910
00:31:17,919 --> 00:31:20,159
actual input need to be so if you read

911
00:31:20,159 --> 00:31:21,760
code for vulnerabilities this is

912
00:31:21,760 --> 00:31:23,519
extremely helpful because it means you

913
00:31:23,519 --> 00:31:25,279
don't have to go and cross-reference in

914
00:31:25,279 --> 00:31:27,519
the binary on your own you could be

915
00:31:27,519 --> 00:31:29,440
cross-influencing stuff that will never

916
00:31:29,440 --> 00:31:30,880
be reached and it'll take you ages to

917
00:31:30,880 --> 00:31:32,240
work that out because of those

918
00:31:32,240 --> 00:31:34,399
difficulties i mentioned earlier on but

919
00:31:34,399 --> 00:31:36,399
here anger is automating that process

920
00:31:36,399 --> 00:31:38,559
completely it's telling me immediately

921
00:31:38,559 --> 00:31:40,640
you reach this you reach the string copy

922
00:31:40,640 --> 00:31:43,760
by giving it the string in in in the obv

923
00:31:43,760 --> 00:31:47,760
variable and um another ctf ctf example

924
00:31:47,760 --> 00:31:49,279
of this that was a contrived one but

925
00:31:49,279 --> 00:31:52,480
here's a simple ctf example um uh you

926
00:31:52,480 --> 00:31:54,559
know just if if you're some if you're

927
00:31:54,559 --> 00:31:56,640
using symbolic execution to solve a cdf

928
00:31:56,640 --> 00:31:58,480
the process is incredibly simple and

929
00:31:58,480 --> 00:32:00,480
i'll show you how this works you you

930
00:32:00,480 --> 00:32:02,080
first step you want to disassemble it

931
00:32:02,080 --> 00:32:03,519
just to get a picture of it you don't

932
00:32:03,519 --> 00:32:05,519
have to you don't have to but you do you

933
00:32:05,519 --> 00:32:07,120
do want to kind of see

934
00:32:07,120 --> 00:32:10,159
where where are we going to aim our

935
00:32:10,159 --> 00:32:12,320
session and it needs it needs it means

936
00:32:12,320 --> 00:32:13,760
you need to actually at least be able to

937
00:32:13,760 --> 00:32:14,399
see

938
00:32:14,399 --> 00:32:15,600
where certain stuff happens in the

939
00:32:15,600 --> 00:32:17,279
binary and a quick read of this one will

940
00:32:17,279 --> 00:32:19,919
show you hey it's going to end up in you

941
00:32:19,919 --> 00:32:23,279
know putting either a bad

942
00:32:23,279 --> 00:32:24,799
string to the it's going to print out

943
00:32:24,799 --> 00:32:26,480
either bad or good we obviously want to

944
00:32:26,480 --> 00:32:29,519
get to good so we might not even know

945
00:32:29,519 --> 00:32:31,840
this we don't even know that like

946
00:32:31,840 --> 00:32:33,360
which one is the good and bad because if

947
00:32:33,360 --> 00:32:35,760
we look at the actual disassembly um

948
00:32:35,760 --> 00:32:37,840
here's the two puts instructions

949
00:32:37,840 --> 00:32:39,840
and we don't know really which one's

950
00:32:39,840 --> 00:32:42,080
good but what we can do because the

951
00:32:42,080 --> 00:32:43,600
power of symbolic execution is we can

952
00:32:43,600 --> 00:32:45,919
just like break point at the string

953
00:32:45,919 --> 00:32:47,279
compare

954
00:32:47,279 --> 00:32:49,279
and we can say hey uh the reason we want

955
00:32:49,279 --> 00:32:50,960
it we want to break point here is just

956
00:32:50,960 --> 00:32:52,240
so that um

957
00:32:52,240 --> 00:32:54,399
everything that needs to be loaded and

958
00:32:54,399 --> 00:32:56,480
referenced is there for us it's not

959
00:32:56,480 --> 00:32:59,519
always true because of lazy loading but

960
00:32:59,519 --> 00:33:01,519
um this typically means like you've got

961
00:33:01,519 --> 00:33:02,720
everything in front of you that you need

962
00:33:02,720 --> 00:33:04,960
once you break point in context

963
00:33:04,960 --> 00:33:07,200
of the actual program run so just to

964
00:33:07,200 --> 00:33:08,720
make things a bit easier i'm going to

965
00:33:08,720 --> 00:33:11,279
break point right there

966
00:33:11,279 --> 00:33:12,559
there might be other debugging tricks

967
00:33:12,559 --> 00:33:14,159
you've got to get around but for

968
00:33:14,159 --> 00:33:15,039
ourselves we're just going to break

969
00:33:15,039 --> 00:33:16,480
point there and then we're going to say

970
00:33:16,480 --> 00:33:18,640
look i want to target one of these two

971
00:33:18,640 --> 00:33:20,880
puts calls so i want to ask anger hey

972
00:33:20,880 --> 00:33:24,000
how do i reach one of these two puts so

973
00:33:24,000 --> 00:33:25,440
just for just for argument's sake i'm

974
00:33:25,440 --> 00:33:29,200
going to guess that um you know plus 143

975
00:33:29,200 --> 00:33:32,080
the the the the you know in the listing

976
00:33:32,080 --> 00:33:35,679
at um address ox 417

977
00:33:35,679 --> 00:33:37,360
i'm gonna guess that that's a good one

978
00:33:37,360 --> 00:33:39,519
i'm gonna tell my my my symbolic

979
00:33:39,519 --> 00:33:42,399
execution tool to search for whatever i

980
00:33:42,399 --> 00:33:44,000
need to get there so that's this is what

981
00:33:44,000 --> 00:33:46,640
you're seeing with scidb search so it's

982
00:33:46,640 --> 00:33:49,519
like a this is a gnu debugger plugin

983
00:33:49,519 --> 00:33:51,600
that i wrote based on anger and it's

984
00:33:51,600 --> 00:33:53,679
going to target just that it's going to

985
00:33:53,679 --> 00:33:54,799
go hey

986
00:33:54,799 --> 00:33:56,399
tell me what input i need and it

987
00:33:56,399 --> 00:33:58,480
actually here you can see it work out

988
00:33:58,480 --> 00:34:00,960
that you need to put into std in not

989
00:34:00,960 --> 00:34:02,880
even one of the args it worked out that

990
00:34:02,880 --> 00:34:04,720
you've got to put into std in this the

991
00:34:04,720 --> 00:34:05,760
string

992
00:34:05,760 --> 00:34:07,840
that's exactly what i do and you can see

993
00:34:07,840 --> 00:34:10,879
here um in in in the script sort of

994
00:34:10,879 --> 00:34:12,960
chopped up chopped out screenshot on on

995
00:34:12,960 --> 00:34:15,440
the left over here you can see that it

996
00:34:15,440 --> 00:34:17,280
actually worked it out properly over

997
00:34:17,280 --> 00:34:20,399
here um yeah my mouse is there so that's

998
00:34:20,399 --> 00:34:22,639
incredible like i just uh i just told it

999
00:34:22,639 --> 00:34:24,639
go for this is this the right answer and

1000
00:34:24,639 --> 00:34:27,280
it was like yes you solved it um so just

1001
00:34:27,280 --> 00:34:30,399
reviewing what we just did um it's even

1002
00:34:30,399 --> 00:34:32,960
you know sort of embarrassingly quick to

1003
00:34:32,960 --> 00:34:34,560
describe what just happened but that's

1004
00:34:34,560 --> 00:34:37,040
how powerful it is you kind of can

1005
00:34:37,040 --> 00:34:39,280
automatically discover input paths you

1006
00:34:39,280 --> 00:34:41,760
can target um you can work out what's

1007
00:34:41,760 --> 00:34:44,399
required to reach memory sensitive calls

1008
00:34:44,399 --> 00:34:46,239
thread calls

1009
00:34:46,239 --> 00:34:47,839
you know if you have if you have

1010
00:34:47,839 --> 00:34:49,440
specific functions that are unique to

1011
00:34:49,440 --> 00:34:51,040
your binary you can hook based on those

1012
00:34:51,040 --> 00:34:54,159
as well um and you can even uh you know

1013
00:34:54,159 --> 00:34:56,560
if you don't have program symbols

1014
00:34:56,560 --> 00:34:58,160
available you can actually filter

1015
00:34:58,160 --> 00:34:59,760
through paths based on other metadata

1016
00:34:59,760 --> 00:35:02,320
you could say look my fuzzer seems to

1017
00:35:02,320 --> 00:35:04,480
get stuck at this block depth so i'll

1018
00:35:04,480 --> 00:35:06,800
let the symbolic execution engine run

1019
00:35:06,800 --> 00:35:09,200
until it reaches you know

1020
00:35:09,200 --> 00:35:12,000
that block diff depth plus one

1021
00:35:12,000 --> 00:35:14,400
or i'll let it run until the eip is at

1022
00:35:14,400 --> 00:35:16,800
least calling this library

1023
00:35:16,800 --> 00:35:18,000
et cetera et cetera you have all this

1024
00:35:18,000 --> 00:35:20,720
metadata that you can rely on to

1025
00:35:20,720 --> 00:35:23,200
automatically explore the binary so

1026
00:35:23,200 --> 00:35:25,280
let's make it pretty powerful and this

1027
00:35:25,280 --> 00:35:27,440
ability to ask where the states are

1028
00:35:27,440 --> 00:35:29,839
reachable is extremely powerful because

1029
00:35:29,839 --> 00:35:31,680
you can now do amazing things like

1030
00:35:31,680 --> 00:35:34,240
automatically generate exploits um which

1031
00:35:34,240 --> 00:35:35,200
i'll show you

1032
00:35:35,200 --> 00:35:36,560
i'll show you a reference to a paper in

1033
00:35:36,560 --> 00:35:38,400
a second that does literally that like

1034
00:35:38,400 --> 00:35:40,880
it it uses anger to

1035
00:35:40,880 --> 00:35:41,839
um

1036
00:35:41,839 --> 00:35:43,119
you know there's a tool called anger

1037
00:35:43,119 --> 00:35:45,599
rock that actually takes your binary and

1038
00:35:45,599 --> 00:35:47,119
works out rob gadgets with certain

1039
00:35:47,119 --> 00:35:49,599
properties for you automatically um so

1040
00:35:49,599 --> 00:35:51,599
forget monada pi you know there was the

1041
00:35:51,599 --> 00:35:53,839
old classic back in the name mona dot pi

1042
00:35:53,839 --> 00:35:56,640
works out everyone's rub gadgets

1043
00:35:56,640 --> 00:35:59,440
to like glue and tape and very archaic

1044
00:35:59,440 --> 00:36:01,680
methods but this one actually uses

1045
00:36:01,680 --> 00:36:04,079
symbolic execution to churn through a

1046
00:36:04,079 --> 00:36:05,599
constraint folder to work out exactly

1047
00:36:05,599 --> 00:36:07,839
what you need from your properties um

1048
00:36:07,839 --> 00:36:09,839
from the properties of the rob gadget um

1049
00:36:09,839 --> 00:36:13,200
it's a much more autonomously suited

1050
00:36:13,200 --> 00:36:14,480
process

1051
00:36:14,480 --> 00:36:16,640
and the other cool thing that's cool is

1052
00:36:16,640 --> 00:36:18,400
with symbolic execution once you know

1053
00:36:18,400 --> 00:36:20,640
the path you know the actual test case

1054
00:36:20,640 --> 00:36:22,400
and you can sometimes do this without

1055
00:36:22,400 --> 00:36:24,079
running the program at all you can take

1056
00:36:24,079 --> 00:36:27,280
binaries that are for obscure um

1057
00:36:27,280 --> 00:36:28,720
environments that you don't actually

1058
00:36:28,720 --> 00:36:30,960
have the metal to run and you can learn

1059
00:36:30,960 --> 00:36:32,720
very elaborate things about them you

1060
00:36:32,720 --> 00:36:34,000
know without without without the actual

1061
00:36:34,000 --> 00:36:36,240
environments again um

1062
00:36:36,240 --> 00:36:38,720
so another cool example of of this whole

1063
00:36:38,720 --> 00:36:40,640
sport crawler um tool that i was talking

1064
00:36:40,640 --> 00:36:42,800
about in the previous slide is just so

1065
00:36:42,800 --> 00:36:44,400
just so you get the idea it shows the

1066
00:36:44,400 --> 00:36:46,640
associated sim state um and this you can

1067
00:36:46,640 --> 00:36:48,400
use to work out the the actual memory

1068
00:36:48,400 --> 00:36:51,200
address that's being called or the the

1069
00:36:51,200 --> 00:36:53,280
the block that this thing applies in it

1070
00:36:53,280 --> 00:36:55,119
it shows you the blocks here we have a

1071
00:36:55,119 --> 00:36:57,680
lot of meme copies in the same block it

1072
00:36:57,680 --> 00:36:58,960
shows you

1073
00:36:58,960 --> 00:37:01,280
the actual arguments as well and there's

1074
00:37:01,280 --> 00:37:03,200
a bit of a trick to making sure you

1075
00:37:03,200 --> 00:37:04,960
actually interpret the arguments

1076
00:37:04,960 --> 00:37:07,280
properly because they come in

1077
00:37:07,280 --> 00:37:10,079
they might come from the solver as like

1078
00:37:10,079 --> 00:37:12,320
an unconstrained state um or they might

1079
00:37:12,320 --> 00:37:14,000
be actually have to be worked out

1080
00:37:14,000 --> 00:37:15,599
through through uh

1081
00:37:15,599 --> 00:37:18,079
again solving into action but you get

1082
00:37:18,079 --> 00:37:21,040
all this context to to to where things

1083
00:37:21,040 --> 00:37:22,320
are referenced and here's another

1084
00:37:22,320 --> 00:37:24,560
example of that these mem copies are

1085
00:37:24,560 --> 00:37:26,800
referencing strings and because i run

1086
00:37:26,800 --> 00:37:29,040
this tool i immediately know what those

1087
00:37:29,040 --> 00:37:31,920
strings are being used for so if i see a

1088
00:37:31,920 --> 00:37:34,160
a file name here it's not just an empty

1089
00:37:34,160 --> 00:37:35,680
string in the binary that i have to kind

1090
00:37:35,680 --> 00:37:37,599
of like hope um

1091
00:37:37,599 --> 00:37:39,520
what will be called i know immediately

1092
00:37:39,520 --> 00:37:41,440
it's reachable i know it's referenced in

1093
00:37:41,440 --> 00:37:43,599
a meme copy and then i know well i want

1094
00:37:43,599 --> 00:37:45,200
the fuzzer to target this file right

1095
00:37:45,200 --> 00:37:46,880
like i want the fuzzer to open this file

1096
00:37:46,880 --> 00:37:48,880
and do all kinds of crazy stuff to it

1097
00:37:48,880 --> 00:37:51,359
because um i definitely will be hearing

1098
00:37:51,359 --> 00:37:53,440
like lucrative code and so that's that's

1099
00:37:53,440 --> 00:37:55,200
the kind of elaborate power it gives you

1100
00:37:55,200 --> 00:37:56,880
and just to close

1101
00:37:56,880 --> 00:37:59,200
i'm going to talk about uh some of the

1102
00:37:59,200 --> 00:38:01,839
the other applications um there's uh

1103
00:38:01,839 --> 00:38:04,400
this really cool project called firm usb

1104
00:38:04,400 --> 00:38:06,240
which someone used i believe someone

1105
00:38:06,240 --> 00:38:09,119
used anger in in this case to search

1106
00:38:09,119 --> 00:38:11,680
through usb firmware using symbolic

1107
00:38:11,680 --> 00:38:13,599
execution and basically what it does is

1108
00:38:13,599 --> 00:38:16,320
it checks for cases of bad usb so bad

1109
00:38:16,320 --> 00:38:19,359
usb was when um you you have these uh

1110
00:38:19,359 --> 00:38:21,920
usb devices that pretend to be multiple

1111
00:38:21,920 --> 00:38:23,599
different peripherals so what this

1112
00:38:23,599 --> 00:38:25,839
program does is it looks at the firmware

1113
00:38:25,839 --> 00:38:27,839
usb and says hey you've got all these

1114
00:38:27,839 --> 00:38:30,320
different descriptors for usb functions

1115
00:38:30,320 --> 00:38:33,280
um do you actually use them in reachable

1116
00:38:33,280 --> 00:38:35,200
code and if you use contrasting

1117
00:38:35,200 --> 00:38:37,599
descriptors in reachable executable code

1118
00:38:37,599 --> 00:38:39,599
again determined by symbolic execution

1119
00:38:39,599 --> 00:38:40,960
then we know you're a piece of malware

1120
00:38:40,960 --> 00:38:43,200
like why would why would the same

1121
00:38:43,200 --> 00:38:45,440
usb tool have all these different

1122
00:38:45,440 --> 00:38:46,880
descriptors it does it doesn't make

1123
00:38:46,880 --> 00:38:48,560
sense um

1124
00:38:48,560 --> 00:38:50,800
obviously it's down to you what's what's

1125
00:38:50,800 --> 00:38:53,040
the same set of descriptors the other

1126
00:38:53,040 --> 00:38:54,640
thing that um people have done that's

1127
00:38:54,640 --> 00:38:56,640
pretty cool is key spectre this is not

1128
00:38:56,640 --> 00:38:58,160
based on angular it's based on cli

1129
00:38:58,160 --> 00:39:00,079
another another symbolic execution

1130
00:39:00,079 --> 00:39:02,400
engine um but basically they they said

1131
00:39:02,400 --> 00:39:04,560
hey symbolic execution can unearth all

1132
00:39:04,560 --> 00:39:06,480
these different properties of reachable

1133
00:39:06,480 --> 00:39:08,400
code so we want to see if there's

1134
00:39:08,400 --> 00:39:10,320
actually cache implications that make

1135
00:39:10,320 --> 00:39:11,599
spectre

1136
00:39:11,599 --> 00:39:13,520
sort of exploitable for the code another

1137
00:39:13,520 --> 00:39:15,440
cool example is just you know general

1138
00:39:15,440 --> 00:39:17,680
cache side channels um

1139
00:39:17,680 --> 00:39:19,760
being being available in code and again

1140
00:39:19,760 --> 00:39:22,800
the the novel example i like is is arg

1141
00:39:22,800 --> 00:39:24,560
which actually uses symbolic execution

1142
00:39:24,560 --> 00:39:26,880
to generate return oriented

1143
00:39:26,880 --> 00:39:28,560
oriented

1144
00:39:28,560 --> 00:39:30,880
exploit payload so it takes a binary it

1145
00:39:30,880 --> 00:39:33,200
strips out all the gadgets and then it

1146
00:39:33,200 --> 00:39:35,680
uses um you know it combines them under

1147
00:39:35,680 --> 00:39:38,000
certain certain analysis and then solves

1148
00:39:38,000 --> 00:39:40,079
for which one should come before which

1149
00:39:40,079 --> 00:39:42,560
one using symbolic execution if you want

1150
00:39:42,560 --> 00:39:45,280
your program to behave a certain way

1151
00:39:45,280 --> 00:39:47,280
so that's very very cool

1152
00:39:47,280 --> 00:39:49,200
these are my references

1153
00:39:49,200 --> 00:39:51,200
please go look at them if you want a lot

1154
00:39:51,200 --> 00:39:53,040
more elaborate uh you know

1155
00:39:53,040 --> 00:39:55,359
discussion on symbolic execution and its

1156
00:39:55,359 --> 00:39:57,119
applications i also want to make sure

1157
00:39:57,119 --> 00:39:58,560
that people know where i stole some of

1158
00:39:58,560 --> 00:40:00,240
my cool pictures from

1159
00:40:00,240 --> 00:40:02,880
and yeah that's it for me um that's my

1160
00:40:02,880 --> 00:40:05,359
website that's my blog and my gitlab

1161
00:40:05,359 --> 00:40:06,960
thanks for listening i hope everyone had

1162
00:40:06,960 --> 00:40:09,960
fun

1163
00:40:12,240 --> 00:40:14,319
you

