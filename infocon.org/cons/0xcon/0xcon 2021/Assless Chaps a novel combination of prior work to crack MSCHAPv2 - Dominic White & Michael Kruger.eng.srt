1
00:00:09,040 --> 00:00:11,120
hi everyone uh welcome to our talk

2
00:00:11,120 --> 00:00:12,400
askles chaps

3
00:00:12,400 --> 00:00:14,719
um

4
00:00:14,960 --> 00:00:16,480
a novel combination of prior work to

5
00:00:16,480 --> 00:00:17,359
crap

6
00:00:17,359 --> 00:00:21,359
crack ms chapman ntlmv1 or why uh ms

7
00:00:21,359 --> 00:00:23,439
chatv2 doesn't cover sauce

8
00:00:23,439 --> 00:00:25,840
uh i'm michael kruger or i'm just

9
00:00:25,840 --> 00:00:28,000
underscore cable thief on twitter this

10
00:00:28,000 --> 00:00:32,000
is dominic white or singe on twitter

11
00:00:32,000 --> 00:00:34,079
today i'm going to be discussing well

12
00:00:34,079 --> 00:00:36,239
i'll be taking you through

13
00:00:36,239 --> 00:00:38,800
an ms chap challenge response i'll be

14
00:00:38,800 --> 00:00:41,600
taking you through why we can use hash

15
00:00:41,600 --> 00:00:43,360
lists rather than wordless for cracking

16
00:00:43,360 --> 00:00:44,640
these things

17
00:00:44,640 --> 00:00:47,440
and also some ideas around that dominic

18
00:00:47,440 --> 00:00:48,960
is going to take over about halfway

19
00:00:48,960 --> 00:00:50,079
through

20
00:00:50,079 --> 00:00:53,039
and he's going to take you through

21
00:00:53,039 --> 00:00:55,199
how he

22
00:00:55,199 --> 00:00:59,199
went in depth into the des uh into into

23
00:00:59,199 --> 00:01:00,800
the days cryptography

24
00:01:00,800 --> 00:01:03,280
on the on the challenge response he's

25
00:01:03,280 --> 00:01:05,280
going to talk about how he created a

26
00:01:05,280 --> 00:01:07,600
tool to do this a bit faster

27
00:01:07,600 --> 00:01:09,680
and he's probably going to go down his

28
00:01:09,680 --> 00:01:11,760
optimizations and things that he

29
00:01:11,760 --> 00:01:13,200
took to get there

30
00:01:13,200 --> 00:01:17,119
anyway switch over to these slides

31
00:01:17,439 --> 00:01:18,240
cool

32
00:01:18,240 --> 00:01:20,240
so

33
00:01:20,240 --> 00:01:23,600
basically the entire

34
00:01:25,040 --> 00:01:28,080
the entire industry has been carrying on

35
00:01:28,080 --> 00:01:32,799
using uh ms chap or ntl mp1 so ms chat

36
00:01:32,799 --> 00:01:35,119
peep specifically because it's very very

37
00:01:35,119 --> 00:01:36,880
convenient for wi-fi you don't have to

38
00:01:36,880 --> 00:01:38,880
set up

39
00:01:38,880 --> 00:01:42,079
certificates and well you don't have to

40
00:01:42,079 --> 00:01:43,759
set up certificates for it to actually

41
00:01:43,759 --> 00:01:44,799
work

42
00:01:44,799 --> 00:01:46,720
but you do need to set up certificates

43
00:01:46,720 --> 00:01:48,479
if you wanted to be secure

44
00:01:48,479 --> 00:01:51,119
but so

45
00:01:51,200 --> 00:01:55,520
industry they keep using it we hackers

46
00:01:55,520 --> 00:01:58,719
keep saying uh this is definitely dead

47
00:01:58,719 --> 00:02:00,799
industry keeps going no it's definitely

48
00:02:00,799 --> 00:02:03,119
alive

49
00:02:03,200 --> 00:02:04,960
so

50
00:02:04,960 --> 00:02:08,878
to show you why it has problems and why

51
00:02:08,878 --> 00:02:10,800
we think it's technically dead or it

52
00:02:10,800 --> 00:02:12,080
should be

53
00:02:12,080 --> 00:02:13,760
put the last bullet in it

54
00:02:13,760 --> 00:02:15,840
uh let's go through the ms chap exchange

55
00:02:15,840 --> 00:02:18,400
so you can get a better idea of

56
00:02:18,400 --> 00:02:20,560
what tool we created and then sort of

57
00:02:20,560 --> 00:02:22,800
what optimizations domineck has has

58
00:02:22,800 --> 00:02:24,640
implemented

59
00:02:24,640 --> 00:02:26,560
so

60
00:02:26,560 --> 00:02:29,200
the ms chap challenge response

61
00:02:29,200 --> 00:02:32,879
the idea behind it is to

62
00:02:32,879 --> 00:02:34,000
transfer

63
00:02:34,000 --> 00:02:35,760
prove knowledge of a secret without

64
00:02:35,760 --> 00:02:38,959
transferring that secret of the wire

65
00:02:38,959 --> 00:02:41,120
so

66
00:02:41,120 --> 00:02:42,400
to do that

67
00:02:42,400 --> 00:02:44,000
we're going to go through this example

68
00:02:44,000 --> 00:02:46,160
using king arthur and a frenchman from

69
00:02:46,160 --> 00:02:48,080
monty python's holy grail

70
00:02:48,080 --> 00:02:48,800
so

71
00:02:48,800 --> 00:02:51,280
the user or client will come along give

72
00:02:51,280 --> 00:02:52,720
his username

73
00:02:52,720 --> 00:02:55,760
the authenticator this in this instance

74
00:02:55,760 --> 00:02:57,440
would be the access point we're wanting

75
00:02:57,440 --> 00:03:00,480
to get onto will provide a challenge

76
00:03:00,480 --> 00:03:03,280
this challenge uh in the ms chat world

77
00:03:03,280 --> 00:03:04,959
is a 16 byte

78
00:03:04,959 --> 00:03:06,640
or 16 octet

79
00:03:06,640 --> 00:03:08,560
uh random string of

80
00:03:08,560 --> 00:03:10,640
bytes

81
00:03:10,640 --> 00:03:11,599
um

82
00:03:11,599 --> 00:03:13,360
at which point the

83
00:03:13,360 --> 00:03:15,920
author will submit his own challenge to

84
00:03:15,920 --> 00:03:17,200
the frenchman

85
00:03:17,200 --> 00:03:21,440
this will be a also 16 random bites

86
00:03:21,440 --> 00:03:23,920
and he will include an nt response this

87
00:03:23,920 --> 00:03:26,640
nt response

88
00:03:26,640 --> 00:03:27,599
is

89
00:03:27,599 --> 00:03:30,159
created by taking the challenge that the

90
00:03:30,159 --> 00:03:32,239
frenchman gave him the challenge that he

91
00:03:32,239 --> 00:03:35,040
has putting it together and then taking

92
00:03:35,040 --> 00:03:37,680
the password that he has and encrypting

93
00:03:37,680 --> 00:03:38,879
that challenge

94
00:03:38,879 --> 00:03:41,040
so that it uh

95
00:03:41,040 --> 00:03:42,720
generates this random string of bites he

96
00:03:42,720 --> 00:03:45,280
won't then submit to the frenchman the

97
00:03:45,280 --> 00:03:47,599
frenchman can then just inspect this

98
00:03:47,599 --> 00:03:50,000
he now has the frenchman has the peer

99
00:03:50,000 --> 00:03:51,840
challenge he can take this peer

100
00:03:51,840 --> 00:03:53,680
challenge combine it with the challenge

101
00:03:53,680 --> 00:03:55,280
that he sent over

102
00:03:55,280 --> 00:03:57,519
basically redo all the same operations

103
00:03:57,519 --> 00:04:00,080
and if it matches the nt response then

104
00:04:00,080 --> 00:04:01,760
he knows okay cool

105
00:04:01,760 --> 00:04:05,280
uh arthur has the same password i do

106
00:04:05,280 --> 00:04:06,560
right

107
00:04:06,560 --> 00:04:09,599
but ms chap is a

108
00:04:09,599 --> 00:04:10,959
synchronous

109
00:04:10,959 --> 00:04:13,120
authentication

110
00:04:13,120 --> 00:04:16,079
challenge response thing whereby

111
00:04:16,079 --> 00:04:18,639
not only is arthur authenticating to the

112
00:04:18,639 --> 00:04:19,839
frenchman

113
00:04:19,839 --> 00:04:22,079
it is the frenchman also authenticating

114
00:04:22,079 --> 00:04:23,360
to arthur

115
00:04:23,360 --> 00:04:25,680
so the frenchman now that he has all

116
00:04:25,680 --> 00:04:27,840
this information generates his own

117
00:04:27,840 --> 00:04:30,560
response which is essentially all the

118
00:04:30,560 --> 00:04:33,040
the same info about all the information

119
00:04:33,040 --> 00:04:35,680
that's transferred till now as well as

120
00:04:35,680 --> 00:04:38,000
some bit of the password which he will

121
00:04:38,000 --> 00:04:41,280
then send back to arthur after having

122
00:04:41,280 --> 00:04:44,720
a prepended and s equals for success

123
00:04:44,720 --> 00:04:46,880
however

124
00:04:46,880 --> 00:04:49,600
if he fails arthur gets sent to big fat

125
00:04:49,600 --> 00:04:50,560
f

126
00:04:50,560 --> 00:04:54,240
and gets told to bugger off

127
00:04:54,240 --> 00:04:56,000
cool so let's dive into this a bit

128
00:04:56,000 --> 00:04:58,400
deeper

129
00:04:59,280 --> 00:05:01,758
we have

130
00:05:02,320 --> 00:05:06,400
we have the challenge generation now

131
00:05:07,039 --> 00:05:08,880
when i say challenge generation i'm

132
00:05:08,880 --> 00:05:11,039
going to be talking about the

133
00:05:11,039 --> 00:05:13,840
challenge that is ultimately used

134
00:05:13,840 --> 00:05:16,800
in generating the nt response as well as

135
00:05:16,800 --> 00:05:19,039
the authenticator's response

136
00:05:19,039 --> 00:05:20,080
so

137
00:05:20,080 --> 00:05:22,240
you'd think it was that 16 bytes that

138
00:05:22,240 --> 00:05:24,800
the the frenchman sent over however that

139
00:05:24,800 --> 00:05:27,440
is not the case it is actually

140
00:05:27,440 --> 00:05:29,360
the username

141
00:05:29,360 --> 00:05:31,680
the challenge provided by the frenchman

142
00:05:31,680 --> 00:05:33,919
and the challenge provided by arthur all

143
00:05:33,919 --> 00:05:36,400
these things are put together in a sha

144
00:05:36,400 --> 00:05:38,639
and then the first eight bytes are taken

145
00:05:38,639 --> 00:05:40,560
from that and that is used in the

146
00:05:40,560 --> 00:05:42,560
equation for

147
00:05:42,560 --> 00:05:44,160
future hashing

148
00:05:44,160 --> 00:05:47,680
uh this is important to know because uh

149
00:05:47,680 --> 00:05:49,759
the way ms chap cracks is the same way

150
00:05:49,759 --> 00:05:51,840
that

151
00:05:51,840 --> 00:05:52,880
cracks

152
00:05:52,880 --> 00:05:55,759
however ntlm v1 generates its challenge

153
00:05:55,759 --> 00:05:58,000
in a different way so meanwhile while

154
00:05:58,000 --> 00:06:00,560
both these things crack the same

155
00:06:00,560 --> 00:06:01,360
um

156
00:06:01,360 --> 00:06:02,639
they generate their challenges

157
00:06:02,639 --> 00:06:04,080
differently

158
00:06:04,080 --> 00:06:05,120
anyway

159
00:06:05,120 --> 00:06:07,360
so from here on the challenge is going

160
00:06:07,360 --> 00:06:09,199
to be this amalgamation of the two

161
00:06:09,199 --> 00:06:12,400
challenges as well as the username

162
00:06:12,400 --> 00:06:13,919
right

163
00:06:13,919 --> 00:06:16,639
the thing that arthur generates is he

164
00:06:16,639 --> 00:06:18,400
takes his password

165
00:06:18,400 --> 00:06:19,199
he

166
00:06:19,199 --> 00:06:21,759
anti-hashes it anti-hashing is basically

167
00:06:21,759 --> 00:06:24,240
just an md4 sum

168
00:06:24,240 --> 00:06:26,720
he then adds that to the challenge

169
00:06:26,720 --> 00:06:29,360
essentially he encrypts the challenge

170
00:06:29,360 --> 00:06:32,560
using his nt hash

171
00:06:32,560 --> 00:06:35,120
this generates the nt response which is

172
00:06:35,120 --> 00:06:37,120
what he submits so you can see he's

173
00:06:37,120 --> 00:06:39,600
encrypted the challenge with his nt hash

174
00:06:39,600 --> 00:06:41,520
this gives the frenchman the opportunity

175
00:06:41,520 --> 00:06:43,280
to encrypt the same challenge with the

176
00:06:43,280 --> 00:06:45,680
nt hash that he knows and if it ends up

177
00:06:45,680 --> 00:06:47,360
in the same response

178
00:06:47,360 --> 00:06:48,880
he knows that arthur has the correct

179
00:06:48,880 --> 00:06:51,280
password

180
00:06:51,280 --> 00:06:53,280
from the frenchman side he does some

181
00:06:53,280 --> 00:06:55,759
slightly different work because

182
00:06:55,759 --> 00:06:57,919
otherwise he could just submit arthur's

183
00:06:57,919 --> 00:07:00,080
challenge back to arthur sorry arthur's

184
00:07:00,080 --> 00:07:01,680
response back to arthur

185
00:07:01,680 --> 00:07:04,080
and arthur wouldn't

186
00:07:04,080 --> 00:07:06,240
we won't really get the the desired

187
00:07:06,240 --> 00:07:08,960
result so what the frenchman will do

188
00:07:08,960 --> 00:07:11,120
is he'll take the password

189
00:07:11,120 --> 00:07:13,599
he'll md for it into an empty hash he'll

190
00:07:13,599 --> 00:07:16,800
md for it again into an nth hash

191
00:07:16,800 --> 00:07:19,520
uh in which case he'll add the username

192
00:07:19,520 --> 00:07:21,680
he'll add some static magic that's in

193
00:07:21,680 --> 00:07:23,680
the rfc so he'll sprinkle on a little

194
00:07:23,680 --> 00:07:25,919
bit of magic he'll add in that same

195
00:07:25,919 --> 00:07:27,120
challenge

196
00:07:27,120 --> 00:07:28,800
and then he will add in the nt

197
00:07:28,800 --> 00:07:31,120
anti-response that arthur provided him

198
00:07:31,120 --> 00:07:33,680
and that is the response he submits

199
00:07:33,680 --> 00:07:35,520
the shock all that is the response he

200
00:07:35,520 --> 00:07:38,160
submits to arthur if arthur

201
00:07:38,160 --> 00:07:41,759
was successful in authenticating

202
00:07:41,759 --> 00:07:43,360
right so if we look at this a bit

203
00:07:43,360 --> 00:07:45,680
closely especially at the anti-response

204
00:07:45,680 --> 00:07:48,479
generation you'll notice that

205
00:07:48,479 --> 00:07:51,599
what actually goes into the final

206
00:07:51,599 --> 00:07:53,919
entity response is not necessarily a

207
00:07:53,919 --> 00:07:56,639
password we can skip the password stage

208
00:07:56,639 --> 00:07:58,879
and just use the anti-hash it's the same

209
00:07:58,879 --> 00:08:02,240
from the other side with the frenchman

210
00:08:02,400 --> 00:08:04,560
we have the password we convert it into

211
00:08:04,560 --> 00:08:06,319
an anti-hash and then we start using the

212
00:08:06,319 --> 00:08:08,720
empty hash so once again

213
00:08:08,720 --> 00:08:10,639
we can skip that step if we have the nt

214
00:08:10,639 --> 00:08:13,280
hash

215
00:08:13,280 --> 00:08:14,080
so

216
00:08:14,080 --> 00:08:17,199
i was saying they're thinking

217
00:08:17,280 --> 00:08:18,639
about this

218
00:08:18,639 --> 00:08:21,120
and i thought well if we only need the

219
00:08:21,120 --> 00:08:22,720
nt hash

220
00:08:22,720 --> 00:08:27,039
and we have sources of nt hashes such as

221
00:08:27,039 --> 00:08:28,560
active directory

222
00:08:28,560 --> 00:08:29,520
or

223
00:08:29,520 --> 00:08:31,680
things like have i been pwned

224
00:08:31,680 --> 00:08:34,479
can't i use that and sort of pass the

225
00:08:34,479 --> 00:08:36,240
hash to get onto

226
00:08:36,240 --> 00:08:39,360
wireless networks given them

227
00:08:39,360 --> 00:08:41,519
passing the hashes essentially within

228
00:08:41,519 --> 00:08:42,799
the

229
00:08:42,799 --> 00:08:44,640
within the challenge response

230
00:08:44,640 --> 00:08:48,240
all we have to do is skip the first step

231
00:08:48,399 --> 00:08:49,279
so

232
00:08:49,279 --> 00:08:53,120
empty hash and then pass the hash

233
00:08:53,120 --> 00:08:56,000
right so i went researching

234
00:08:56,000 --> 00:08:58,720
host apd and wpa supplicant both support

235
00:08:58,720 --> 00:09:01,279
this you can see in these uh example

236
00:09:01,279 --> 00:09:03,200
configs i've provided

237
00:09:03,200 --> 00:09:05,279
the main difference is you just prepend

238
00:09:05,279 --> 00:09:07,519
hash and colon and then you give it the

239
00:09:07,519 --> 00:09:10,240
hash in both cases so in the supplicant

240
00:09:10,240 --> 00:09:13,440
case your password equals hash colon and

241
00:09:13,440 --> 00:09:16,080
then in the eep user file case for host

242
00:09:16,080 --> 00:09:17,519
apd at the bottom

243
00:09:17,519 --> 00:09:19,279
uh it's a case of where you would

244
00:09:19,279 --> 00:09:21,120
usually put the password you just say

245
00:09:21,120 --> 00:09:24,399
hash colon

246
00:09:24,959 --> 00:09:26,399
so

247
00:09:26,399 --> 00:09:28,560
now we can use hash list and say word

248
00:09:28,560 --> 00:09:29,760
lists

249
00:09:29,760 --> 00:09:31,760
current current ms chat modes take very

250
00:09:31,760 --> 00:09:32,720
long

251
00:09:32,720 --> 00:09:35,680
there's a lot of wasted nt hashes if you

252
00:09:35,680 --> 00:09:37,360
only use cracked ones

253
00:09:37,360 --> 00:09:38,800
and there are places you can go to get

254
00:09:38,800 --> 00:09:43,920
anti-hashes so the idea behind this was

255
00:09:44,000 --> 00:09:45,760
why

256
00:09:45,760 --> 00:09:48,000
why bother cracking when we can get like

257
00:09:48,000 --> 00:09:49,839
word lists of actual passwords from

258
00:09:49,839 --> 00:09:51,200
somewhere and then just use them and

259
00:09:51,200 --> 00:09:54,080
pass the hash and what really intrigued

260
00:09:54,080 --> 00:09:57,040
me was uh troy hunt from have i been

261
00:09:57,040 --> 00:09:59,519
pwned providing nt hashes

262
00:09:59,519 --> 00:10:01,839
right this means we have a

263
00:10:01,839 --> 00:10:04,079
really large database of real world

264
00:10:04,079 --> 00:10:05,839
passwords that it's possible people have

265
00:10:05,839 --> 00:10:08,079
chosen as their active directory

266
00:10:08,079 --> 00:10:11,120
passwords and should we capture an ms

267
00:10:11,120 --> 00:10:13,279
chat challenge response we can use that

268
00:10:13,279 --> 00:10:16,720
as a word list to quickly check whether

269
00:10:16,720 --> 00:10:19,120
this person has reused a password

270
00:10:19,120 --> 00:10:22,800
so i thought it would be very convenient

271
00:10:22,959 --> 00:10:23,839
so

272
00:10:23,839 --> 00:10:26,720
i went looking on how i would go about

273
00:10:26,720 --> 00:10:28,320
cracking

274
00:10:28,320 --> 00:10:30,640
nt

275
00:10:31,360 --> 00:10:34,399
ms chap v2 using an anti-hash

276
00:10:34,399 --> 00:10:37,360
and i found uh the hashcat forums in

277
00:10:37,360 --> 00:10:38,959
2016

278
00:10:38,959 --> 00:10:41,120
two um

279
00:10:41,120 --> 00:10:42,959
two forum posts

280
00:10:42,959 --> 00:10:46,640
uh where they break the

281
00:10:46,640 --> 00:10:49,200
the challenge response into multiple

282
00:10:49,200 --> 00:10:51,360
anti-hash segments sorry into multiple

283
00:10:51,360 --> 00:10:52,880
des sections

284
00:10:52,880 --> 00:10:55,360
and then they crack the des section

285
00:10:55,360 --> 00:10:59,519
so reading through these two form posts

286
00:10:59,519 --> 00:11:01,680
what they do is they

287
00:11:01,680 --> 00:11:03,920
basically given that the des key is only

288
00:11:03,920 --> 00:11:04,880
eight

289
00:11:04,880 --> 00:11:06,320
eight bytes long

290
00:11:06,320 --> 00:11:07,120
they

291
00:11:07,120 --> 00:11:08,880
go through it and crack the entire des

292
00:11:08,880 --> 00:11:11,600
key space to get back the anti-hash so i

293
00:11:11,600 --> 00:11:13,600
thought ah okay cool we don't even need

294
00:11:13,600 --> 00:11:15,279
to use hash list we have a way of

295
00:11:15,279 --> 00:11:16,640
guaranteed

296
00:11:16,640 --> 00:11:18,000
getting back

297
00:11:18,000 --> 00:11:18,959
the

298
00:11:18,959 --> 00:11:20,720
the user's nt hash

299
00:11:20,720 --> 00:11:23,600
so i promptly put that into my little uh

300
00:11:23,600 --> 00:11:25,519
macbook

301
00:11:25,519 --> 00:11:27,279
press enter to brute force the entire

302
00:11:27,279 --> 00:11:29,440
key space i'd said something like four

303
00:11:29,440 --> 00:11:30,800
years or something like that so i went

304
00:11:30,800 --> 00:11:34,399
back to my idea of using cash lists

305
00:11:34,399 --> 00:11:35,279
so

306
00:11:35,279 --> 00:11:36,560
i tried going through the whole

307
00:11:36,560 --> 00:11:39,120
rigmarole of setting up this multi-phase

308
00:11:39,120 --> 00:11:42,000
dez cracking where i split up my nt

309
00:11:42,000 --> 00:11:44,560
hashes into little sections and trying

310
00:11:44,560 --> 00:11:46,560
using those however this became a

311
00:11:46,560 --> 00:11:48,720
mission so i thought

312
00:11:48,720 --> 00:11:50,959
why not create new hashcat modes how

313
00:11:50,959 --> 00:11:53,600
difficult can it be

314
00:11:53,600 --> 00:11:55,200
essentially all i'm going to be doing is

315
00:11:55,200 --> 00:11:57,680
taking mode 5500

316
00:11:57,680 --> 00:12:01,200
and taking out one md4 right

317
00:12:01,200 --> 00:12:03,839
and then it basically is perfect right

318
00:12:03,839 --> 00:12:04,170
so

319
00:12:04,170 --> 00:12:05,279
[Music]

320
00:12:05,279 --> 00:12:06,079
uh

321
00:12:06,079 --> 00:12:08,399
last sense con which is a internal

322
00:12:08,399 --> 00:12:12,320
hackathon i got a team together and we

323
00:12:12,320 --> 00:12:14,800
built these new hash modes so we built

324
00:12:14,800 --> 00:12:16,560
uh 27

325
00:12:16,560 --> 00:12:20,639
and 27 100 a one for a net ntl mv1 which

326
00:12:20,639 --> 00:12:22,720
can apply to ms chap and then one for

327
00:12:22,720 --> 00:12:25,839
net ntlm v2

328
00:12:26,000 --> 00:12:27,200
um

329
00:12:27,200 --> 00:12:29,200
it wasn't as easy as i thought it would

330
00:12:29,200 --> 00:12:32,160
be with just removing one md5 one md4

331
00:12:32,160 --> 00:12:33,040
sum

332
00:12:33,040 --> 00:12:35,360
but uh it now works and it should be in

333
00:12:35,360 --> 00:12:37,279
in hash cut so

334
00:12:37,279 --> 00:12:39,360
now we have a way to provide just a long

335
00:12:39,360 --> 00:12:41,200
list of hashes so a hash list rather

336
00:12:41,200 --> 00:12:42,639
than a word list

337
00:12:42,639 --> 00:12:45,600
and then that uh

338
00:12:45,600 --> 00:12:46,639
gets us

339
00:12:46,639 --> 00:12:49,120
well rev well we can crack nt hashes

340
00:12:49,120 --> 00:12:51,839
sorry and netentilm v1 hashes with uh

341
00:12:51,839 --> 00:12:54,079
with hash lists so we can use

342
00:12:54,079 --> 00:12:57,120
uh troy hunt's power bin pawn database

343
00:12:57,120 --> 00:13:00,160
right so let me just demo this to you

344
00:13:00,160 --> 00:13:04,399
i have created my fancy new hash mode

345
00:13:04,399 --> 00:13:07,120
we're going to take use the

346
00:13:07,120 --> 00:13:09,519
uh example hash provided by hash cap now

347
00:13:09,519 --> 00:13:11,600
that's now that's there

348
00:13:11,600 --> 00:13:13,200
and we should see that we crack

349
00:13:13,200 --> 00:13:14,639
successfully

350
00:13:14,639 --> 00:13:17,360
uh using an nt hash

351
00:13:17,360 --> 00:13:19,760
and you'll notice at the end

352
00:13:19,760 --> 00:13:23,600
b4b9 that is a ntlm hash for the word

353
00:13:23,600 --> 00:13:24,880
hashcat

354
00:13:24,880 --> 00:13:27,600
right so brilliant so now

355
00:13:27,600 --> 00:13:30,160
considering that

356
00:13:30,160 --> 00:13:32,240
i've taken away an operation there

357
00:13:32,240 --> 00:13:35,120
should be a big speed increase right so

358
00:13:35,120 --> 00:13:37,279
i was all excited we can see that my

359
00:13:37,279 --> 00:13:38,560
hash gets me

360
00:13:38,560 --> 00:13:41,360
uh 6 000 kilo hashes a second

361
00:13:41,360 --> 00:13:42,800
if we compare that to the old mode that

362
00:13:42,800 --> 00:13:45,199
has an entire operation more

363
00:13:45,199 --> 00:13:46,839
we

364
00:13:46,839 --> 00:13:49,199
get 22

365
00:13:49,199 --> 00:13:52,720
oh 220 mega hashes which is

366
00:13:52,720 --> 00:13:55,600
a lot faster right

367
00:13:55,600 --> 00:13:57,040
so

368
00:13:57,040 --> 00:13:59,920
why is this the case well after some

369
00:13:59,920 --> 00:14:02,480
questions to the hashtag people uh

370
00:14:02,480 --> 00:14:04,399
hashcat has the

371
00:14:04,399 --> 00:14:07,199
concept of amplifiers so

372
00:14:07,199 --> 00:14:08,079
with

373
00:14:08,079 --> 00:14:10,480
the normal mode we are essentially

374
00:14:10,480 --> 00:14:12,480
transferring over

375
00:14:12,480 --> 00:14:13,920
a word

376
00:14:13,920 --> 00:14:15,839
and then potentially applying a big

377
00:14:15,839 --> 00:14:17,680
bunch of rules to it

378
00:14:17,680 --> 00:14:19,440
at which point we

379
00:14:19,440 --> 00:14:21,920
that word now on the gpu blows up into a

380
00:14:21,920 --> 00:14:23,600
few thousand

381
00:14:23,600 --> 00:14:26,399
uh different words right

382
00:14:26,399 --> 00:14:28,320
if we think about what we're doing with

383
00:14:28,320 --> 00:14:32,079
my hash mode we are taking a hash

384
00:14:32,079 --> 00:14:35,600
transferring it to the gpu checking it

385
00:14:35,600 --> 00:14:37,360
and then we can't do any additional

386
00:14:37,360 --> 00:14:39,680
modifiers to it so we throw it away and

387
00:14:39,680 --> 00:14:41,920
we go to the next hash in the next hash

388
00:14:41,920 --> 00:14:44,720
so what happens is we get throttled by

389
00:14:44,720 --> 00:14:45,920
the

390
00:14:45,920 --> 00:14:48,560
bus to the gpu a lot

391
00:14:48,560 --> 00:14:50,399
and this adds a hell of a lot of

392
00:14:50,399 --> 00:14:52,480
overhead and makes it

393
00:14:52,480 --> 00:14:54,639
infinitely slower

394
00:14:54,639 --> 00:14:56,160
um

395
00:14:56,160 --> 00:14:59,440
so to get around this uh dominic is

396
00:14:59,440 --> 00:15:00,800
going to take over from this point

397
00:15:00,800 --> 00:15:02,240
forward

398
00:15:02,240 --> 00:15:03,120
right

399
00:15:03,120 --> 00:15:03,920
so

400
00:15:03,920 --> 00:15:06,240
let me pass this over to dominic now and

401
00:15:06,240 --> 00:15:08,560
he can talk about his new approach

402
00:15:08,560 --> 00:15:10,800
uh of how he sort of optimized and got

403
00:15:10,800 --> 00:15:12,480
around those optimization problems that

404
00:15:12,480 --> 00:15:14,160
i had

405
00:15:14,160 --> 00:15:18,160
right over to you dominic

406
00:15:18,240 --> 00:15:20,720
thanks michael

407
00:15:20,720 --> 00:15:22,160
hello everyone

408
00:15:22,160 --> 00:15:25,519
uh okay so michael did all the hard work

409
00:15:25,519 --> 00:15:28,000
and talked a lot about arses i'm gonna

410
00:15:28,000 --> 00:15:30,399
do the easy work and talk talk more

411
00:15:30,399 --> 00:15:32,800
about asses

412
00:15:32,800 --> 00:15:34,399
so

413
00:15:34,399 --> 00:15:35,120
the

414
00:15:35,120 --> 00:15:36,079
uh

415
00:15:36,079 --> 00:15:37,759
what michael showed you in the exchange

416
00:15:37,759 --> 00:15:39,519
is that at some point you've got this

417
00:15:39,519 --> 00:15:41,199
this password hash

418
00:15:41,199 --> 00:15:43,440
which is turned into

419
00:15:43,440 --> 00:15:45,519
an empty response and the way that's

420
00:15:45,519 --> 00:15:47,759
done in a little more detail is we take

421
00:15:47,759 --> 00:15:49,519
the password hash and split it up into

422
00:15:49,519 --> 00:15:50,800
three keys

423
00:15:50,800 --> 00:15:54,560
and then each of those keys is

424
00:15:54,560 --> 00:15:57,440
used to with the challenge separately in

425
00:15:57,440 --> 00:15:59,519
a separate cryptographic operation so

426
00:15:59,519 --> 00:16:01,600
it's not like triple des where you it's

427
00:16:01,600 --> 00:16:03,600
three des rounds these are literally

428
00:16:03,600 --> 00:16:06,240
three separate single des rounds the

429
00:16:06,240 --> 00:16:08,079
other thing that's interesting here is

430
00:16:08,079 --> 00:16:10,480
because there isn't enough

431
00:16:10,480 --> 00:16:12,800
bytes in the password hash and dez key

432
00:16:12,800 --> 00:16:14,720
is seven bytes long

433
00:16:14,720 --> 00:16:16,880
for the last key they end up padding it

434
00:16:16,880 --> 00:16:18,560
with five

435
00:16:18,560 --> 00:16:20,240
five bytes

436
00:16:20,240 --> 00:16:21,040
so

437
00:16:21,040 --> 00:16:22,720
when each of those things are encrypted

438
00:16:22,720 --> 00:16:24,959
we produce the the nt the entity

439
00:16:24,959 --> 00:16:26,880
response now when we're cracking this

440
00:16:26,880 --> 00:16:29,279
we're going the other way around

441
00:16:29,279 --> 00:16:30,399
we've got the challenge and we've got

442
00:16:30,399 --> 00:16:31,680
the entity response and we're trying to

443
00:16:31,680 --> 00:16:33,360
get the password hash and we know that

444
00:16:33,360 --> 00:16:35,759
this is three des operations so we need

445
00:16:35,759 --> 00:16:37,519
to figure out these three keys we've got

446
00:16:37,519 --> 00:16:39,360
the challenge we've got the ciphertext

447
00:16:39,360 --> 00:16:41,120
that gets generated

448
00:16:41,120 --> 00:16:42,800
so we're going to go in reverse

449
00:16:42,800 --> 00:16:45,120
now the thing that pops out is kind of

450
00:16:45,120 --> 00:16:47,360
the most obvious is this key three which

451
00:16:47,360 --> 00:16:50,079
has these two bytes that are are padded

452
00:16:50,079 --> 00:16:51,440
and what we can do with those is we can

453
00:16:51,440 --> 00:16:53,199
brute force the

454
00:16:53,199 --> 00:16:54,560
brute force them because the key space

455
00:16:54,560 --> 00:16:57,759
for that is 65 535

456
00:16:57,759 --> 00:17:00,000
only uh des operations are pretty

457
00:17:00,000 --> 00:17:02,160
efficient on modern hardware that's not

458
00:17:02,160 --> 00:17:03,519
a lot of des operations and that's

459
00:17:03,519 --> 00:17:05,679
that's the maximum key space so average

460
00:17:05,679 --> 00:17:07,119
time you're going to find that in half

461
00:17:07,119 --> 00:17:08,000
that

462
00:17:08,000 --> 00:17:10,160
so we can brute force those two bytes

463
00:17:10,160 --> 00:17:12,400
and then we'll get the last two bytes of

464
00:17:12,400 --> 00:17:14,400
the password hash

465
00:17:14,400 --> 00:17:15,919
and we just need to recover the other

466
00:17:15,919 --> 00:17:17,599
two keys at this point

467
00:17:17,599 --> 00:17:19,760
now that's not a new observation this is

468
00:17:19,760 --> 00:17:22,400
a slide from joshua wright's deck at

469
00:17:22,400 --> 00:17:25,919
defcon 11 at alexis park in 2003 and you

470
00:17:25,919 --> 00:17:27,760
can see in the middle of the slide there

471
00:17:27,760 --> 00:17:30,160
he's got weak des key selection permits

472
00:17:30,160 --> 00:17:32,880
recovery of two bytes of the anti-hash

473
00:17:32,880 --> 00:17:35,679
so we've known this for for a long time

474
00:17:35,679 --> 00:17:36,720
and

475
00:17:36,720 --> 00:17:38,640
later on when moxie marlin spike and

476
00:17:38,640 --> 00:17:42,240
david hulton at uh dc20 in 2012

477
00:17:42,240 --> 00:17:44,320
presented their work they they used this

478
00:17:44,320 --> 00:17:45,840
but they took it one step further

479
00:17:45,840 --> 00:17:47,600
another optimization

480
00:17:47,600 --> 00:17:49,360
and that was instead of going through

481
00:17:49,360 --> 00:17:51,520
the des key space twice brute forcing

482
00:17:51,520 --> 00:17:52,320
the

483
00:17:52,320 --> 00:17:54,320
the two keys that goes to the des key

484
00:17:54,320 --> 00:17:56,799
space once because they do one

485
00:17:56,799 --> 00:17:58,720
cryptographic operation and two compare

486
00:17:58,720 --> 00:18:01,840
operations so we're looking for this key

487
00:18:01,840 --> 00:18:03,760
at these two different keys so we can

488
00:18:03,760 --> 00:18:05,360
perform this cryptographic operation and

489
00:18:05,360 --> 00:18:07,600
then go does it match either of the keys

490
00:18:07,600 --> 00:18:09,679
so that was another optimization they

491
00:18:09,679 --> 00:18:13,200
came up with in in 2012

492
00:18:13,200 --> 00:18:15,120
uh and if we look at the history of the

493
00:18:15,120 --> 00:18:17,440
speed here so the the other work that

494
00:18:17,440 --> 00:18:19,360
moxie and david halton did was they

495
00:18:19,360 --> 00:18:21,039
introduced fpgas but it's useful to

496
00:18:21,039 --> 00:18:23,600
understand the history um to

497
00:18:23,600 --> 00:18:25,919
to understand the future so in 1998 the

498
00:18:25,919 --> 00:18:26,880
eff

499
00:18:26,880 --> 00:18:29,679
produced these custom chips a6

500
00:18:29,679 --> 00:18:32,320
and at an exorbitant cost of 250

501
00:18:32,320 --> 00:18:33,840
thousand dollars

502
00:18:33,840 --> 00:18:35,039
and that could brute force all of the

503
00:18:35,039 --> 00:18:38,720
des key space uh within 227 hours

504
00:18:38,720 --> 00:18:40,400
and you can see the keys per second on

505
00:18:40,400 --> 00:18:42,160
the right there now what's interesting

506
00:18:42,160 --> 00:18:43,280
is if you look

507
00:18:43,280 --> 00:18:46,400
going forward from 1998 to 2020

508
00:18:46,400 --> 00:18:48,960
there isn't massive jumps in

509
00:18:48,960 --> 00:18:51,120
in key at the number of keys per second

510
00:18:51,120 --> 00:18:53,200
well there is a big jump between 2006

511
00:18:53,200 --> 00:18:55,600
and 2012 then after that it actually

512
00:18:55,600 --> 00:18:57,600
goes backwards before we go forward

513
00:18:57,600 --> 00:19:00,080
what there is a big change in is price

514
00:19:00,080 --> 00:19:02,799
between 1998 and 2006.

515
00:19:02,799 --> 00:19:05,760
so the 250 000 to 10 thousand dollars is

516
00:19:05,760 --> 00:19:06,880
a big difference and that was because

517
00:19:06,880 --> 00:19:09,679
fpgas allow us to effectively create

518
00:19:09,679 --> 00:19:12,160
custom programmable

519
00:19:12,160 --> 00:19:13,760
chip pathways without needing to design

520
00:19:13,760 --> 00:19:15,440
custom chips

521
00:19:15,440 --> 00:19:18,000
and so in 2006 the copacabana team did

522
00:19:18,000 --> 00:19:19,679
that with an fpga

523
00:19:19,679 --> 00:19:21,360
it actually took longer but at only ten

524
00:19:21,360 --> 00:19:23,280
thousand dollars big improvement then

525
00:19:23,280 --> 00:19:26,559
what moxie and dave did in 2012 they

526
00:19:26,559 --> 00:19:29,120
also used fpgas

527
00:19:29,120 --> 00:19:30,720
but with their optimizations they were

528
00:19:30,720 --> 00:19:33,600
able to reduce the

529
00:19:33,600 --> 00:19:35,760
the time down to 23 hours as well as a

530
00:19:35,760 --> 00:19:38,080
dramatic speed improvement using their

531
00:19:38,080 --> 00:19:40,480
their fpga approach and they built cloud

532
00:19:40,480 --> 00:19:43,280
cracker if some of you remember that

533
00:19:43,280 --> 00:19:45,760
but then by 2016 hashcat was starting to

534
00:19:45,760 --> 00:19:49,120
catch up here so uh here i've used 32

535
00:19:49,120 --> 00:19:51,679
rtx 980s as an example with what they

536
00:19:51,679 --> 00:19:53,039
would have cost at the time in that

537
00:19:53,039 --> 00:19:55,039
speed and the reason i've used 32 of

538
00:19:55,039 --> 00:19:57,039
them is because that gives us a

539
00:19:57,039 --> 00:20:00,160
comparable cost to the 2006 copacabana

540
00:20:00,160 --> 00:20:01,039
team

541
00:20:01,039 --> 00:20:03,440
so of course you could use more or less

542
00:20:03,440 --> 00:20:06,000
and then in 2020

543
00:20:06,000 --> 00:20:07,520
using

544
00:20:07,520 --> 00:20:09,440
chicken summer chicken man's stats for

545
00:20:09,440 --> 00:20:12,400
the gtx 3 30 80s we're still sitting

546
00:20:12,400 --> 00:20:14,960
around 10 000 we're actually 11 000 but

547
00:20:14,960 --> 00:20:17,200
we've now managed to get to speeds that

548
00:20:17,200 --> 00:20:20,080
the fpgas were doing in 2012.

549
00:20:20,080 --> 00:20:21,360
what you should take from all of this

550
00:20:21,360 --> 00:20:23,840
though is it's slow it all requires des

551
00:20:23,840 --> 00:20:25,760
brute forcing and it's slow so what that

552
00:20:25,760 --> 00:20:27,120
means is you're guaranteed to get a

553
00:20:27,120 --> 00:20:30,080
response but uh it's not necessarily

554
00:20:30,080 --> 00:20:31,760
well optimized so we can improve on that

555
00:20:31,760 --> 00:20:34,000
pretty dramatically

556
00:20:34,000 --> 00:20:35,600
with asless and that's that's what we

557
00:20:35,600 --> 00:20:36,400
did

558
00:20:36,400 --> 00:20:38,720
so ms chap version two and ntlm version

559
00:20:38,720 --> 00:20:40,720
one doesn't protect its ass because

560
00:20:40,720 --> 00:20:41,919
you've got these two bytes that you can

561
00:20:41,919 --> 00:20:43,600
brute force really easily

562
00:20:43,600 --> 00:20:45,039
now this is known it's been used by

563
00:20:45,039 --> 00:20:47,520
others uh in hashcat for example it

564
00:20:47,520 --> 00:20:49,520
doesn't early discard that if the last

565
00:20:49,520 --> 00:20:51,440
two bytes don't match

566
00:20:51,440 --> 00:20:53,360
or the hash it doesn't uh doesn't send

567
00:20:53,360 --> 00:20:54,320
them through

568
00:20:54,320 --> 00:20:56,159
what i did is is something different and

569
00:20:56,159 --> 00:20:58,320
it's it's really nothing more

570
00:20:58,320 --> 00:21:00,720
interesting than reducing the hash list

571
00:21:00,720 --> 00:21:03,600
up front by looking for the two to buy

572
00:21:03,600 --> 00:21:05,280
so here's an example grep saying show me

573
00:21:05,280 --> 00:21:06,880
all the empty hashes from an empty hash

574
00:21:06,880 --> 00:21:08,640
list like they have i've been pointless

575
00:21:08,640 --> 00:21:11,200
that michael spoke about

576
00:21:11,200 --> 00:21:13,679
that match those last two bytes

577
00:21:13,679 --> 00:21:15,600
so if we take that the hashcat example

578
00:21:15,600 --> 00:21:17,039
instead of doing an early discard and

579
00:21:17,039 --> 00:21:19,360
hashcats code what i'm doing is just

580
00:21:19,360 --> 00:21:21,760
sending a reduced list to hashcat in the

581
00:21:21,760 --> 00:21:23,360
first place

582
00:21:23,360 --> 00:21:26,000
and when i did that as an initial poc

583
00:21:26,000 --> 00:21:28,720
what i saw is that hashcat was running

584
00:21:28,720 --> 00:21:31,520
around eight seconds and my crappy poc

585
00:21:31,520 --> 00:21:33,280
was under a second

586
00:21:33,280 --> 00:21:35,679
uh so there's two sample hashes with two

587
00:21:35,679 --> 00:21:37,520
word lists a small word list and they

588
00:21:37,520 --> 00:21:38,880
have i've been prone word list we're

589
00:21:38,880 --> 00:21:39,919
going from

590
00:21:39,919 --> 00:21:41,600
two two and a half minutes one actually

591
00:21:41,600 --> 00:21:43,280
nearly three minutes sorry

592
00:21:43,280 --> 00:21:44,960
to 46 seconds

593
00:21:44,960 --> 00:21:47,360
or a minute to 41 seconds or 10 seconds

594
00:21:47,360 --> 00:21:48,880
to under a second

595
00:21:48,880 --> 00:21:51,039
now that's not amazing but it's enough

596
00:21:51,039 --> 00:21:53,120
to tinker my spidey senses and tell me

597
00:21:53,120 --> 00:21:55,679
there's something there

598
00:21:55,679 --> 00:21:58,960
so like sir robin i bravely went forth

599
00:21:58,960 --> 00:21:59,840
and

600
00:21:59,840 --> 00:22:01,600
traveled down this dark path and this

601
00:22:01,600 --> 00:22:02,960
dark path is the dark path of

602
00:22:02,960 --> 00:22:05,120
performance optimization if any of you

603
00:22:05,120 --> 00:22:06,720
have ever gotten stuck in this it can be

604
00:22:06,720 --> 00:22:08,720
quite rewarding but there's a lot of

605
00:22:08,720 --> 00:22:10,320
misleading pathways that can take you

606
00:22:10,320 --> 00:22:11,120
down

607
00:22:11,120 --> 00:22:14,400
so the first thing that i did

608
00:22:14,400 --> 00:22:16,320
simplistically is instead of using grep

609
00:22:16,320 --> 00:22:18,080
i used rip grap any of you familiar with

610
00:22:18,080 --> 00:22:19,679
rip graph it's quite a lot faster for

611
00:22:19,679 --> 00:22:21,840
big files and normal graph written in

612
00:22:21,840 --> 00:22:22,960
rust and it's got a bunch of other

613
00:22:22,960 --> 00:22:25,280
optimizations that got me a bunch of

614
00:22:25,280 --> 00:22:26,480
extra speed

615
00:22:26,480 --> 00:22:28,240
and then i simplistically

616
00:22:28,240 --> 00:22:29,840
started operating on the hashes that

617
00:22:29,840 --> 00:22:31,919
were returned from rip graph as they

618
00:22:31,919 --> 00:22:33,440
were returned rather than waiting for

619
00:22:33,440 --> 00:22:35,120
the whole command to finish before

620
00:22:35,120 --> 00:22:37,120
working on them things like that started

621
00:22:37,120 --> 00:22:39,120
giving me a bit of a speed up and more

622
00:22:39,120 --> 00:22:41,760
importantly i started building a python

623
00:22:41,760 --> 00:22:43,520
poc

624
00:22:43,520 --> 00:22:45,520
i then worked out that

625
00:22:45,520 --> 00:22:48,000
there were two sets of optimizations we

626
00:22:48,000 --> 00:22:49,760
could do on the lookup of the last two

627
00:22:49,760 --> 00:22:51,280
bytes so instead of brute forcing

628
00:22:51,280 --> 00:22:52,960
through the key space

629
00:22:52,960 --> 00:22:56,720
of 65 535 i did a frequency analysis and

630
00:22:56,720 --> 00:22:58,720
notice that some sets of two bytes were

631
00:22:58,720 --> 00:23:00,480
more common than others in an otherwise

632
00:23:00,480 --> 00:23:02,159
randomized set

633
00:23:02,159 --> 00:23:03,760
outside of that

634
00:23:03,760 --> 00:23:05,039
some passwords are more common than

635
00:23:05,039 --> 00:23:06,559
others so something like password one is

636
00:23:06,559 --> 00:23:08,720
going to be more common than

637
00:23:08,720 --> 00:23:11,600
a password manager generated password

638
00:23:11,600 --> 00:23:13,280
and the last two bytes and password one

639
00:23:13,280 --> 00:23:15,840
then within a frequency set go up so

640
00:23:15,840 --> 00:23:17,360
using a combination of a frequency

641
00:23:17,360 --> 00:23:19,600
sorted list so where i didn't unique the

642
00:23:19,600 --> 00:23:23,039
the passwords as well as

643
00:23:23,039 --> 00:23:25,039
a bunch of two bytes it gave me a pretty

644
00:23:25,039 --> 00:23:26,480
decent lookup that's actually in the

645
00:23:26,480 --> 00:23:28,320
github repository for this if you want

646
00:23:28,320 --> 00:23:30,240
it i later removed this so that gave me

647
00:23:30,240 --> 00:23:32,720
a pretty decent speed up with python and

648
00:23:32,720 --> 00:23:34,400
the des operations

649
00:23:34,400 --> 00:23:36,559
it didn't give me a speed up use when i

650
00:23:36,559 --> 00:23:38,400
eventually moved to what i'll get to in

651
00:23:38,400 --> 00:23:39,760
a bit

652
00:23:39,760 --> 00:23:41,360
then i started doing a bunch of file

653
00:23:41,360 --> 00:23:45,200
tricks so can i uh can i seek from

654
00:23:45,200 --> 00:23:46,640
different places in the file can i

655
00:23:46,640 --> 00:23:48,320
reduce the file size so that i've got

656
00:23:48,320 --> 00:23:51,279
less to seek through and what i realized

657
00:23:51,279 --> 00:23:52,960
was i was actually just doing the same

658
00:23:52,960 --> 00:23:54,799
kind of stuff databases already do just

659
00:23:54,799 --> 00:23:56,240
really badly

660
00:23:56,240 --> 00:23:58,559
so at that point i moved to a database i

661
00:23:58,559 --> 00:24:00,559
first tried mariahdb

662
00:24:00,559 --> 00:24:02,960
and it was much slower i then tried

663
00:24:02,960 --> 00:24:05,679
sqlite and it was even slower

664
00:24:05,679 --> 00:24:06,799
but i re

665
00:24:06,799 --> 00:24:07,919
i sort of scratched my head at this

666
00:24:07,919 --> 00:24:09,600
because databases should be able to

667
00:24:09,600 --> 00:24:12,320
handle millions of lines quite easily

668
00:24:12,320 --> 00:24:14,080
until a developer friend pointed out

669
00:24:14,080 --> 00:24:15,840
that actually indexes are the things

670
00:24:15,840 --> 00:24:18,960
that make databases fast not just using

671
00:24:18,960 --> 00:24:20,400
a database

672
00:24:20,400 --> 00:24:23,440
so putting indexes on

673
00:24:23,440 --> 00:24:25,679
on my hash lookups managed to improve

674
00:24:25,679 --> 00:24:27,200
things quite dramatically so you can

675
00:24:27,200 --> 00:24:28,960
imagine i'm

676
00:24:28,960 --> 00:24:30,640
searching for hashes that have these two

677
00:24:30,640 --> 00:24:33,120
bytes so i can index the two bytes

678
00:24:33,120 --> 00:24:34,799
that are put into a database and that

679
00:24:34,799 --> 00:24:36,640
gives me pretty efficient lookup uses

680
00:24:36,640 --> 00:24:40,159
binary trees balance trees

681
00:24:40,159 --> 00:24:41,360
which gives you

682
00:24:41,360 --> 00:24:43,120
big in bigger notation log n performance

683
00:24:43,120 --> 00:24:44,720
which is important for

684
00:24:44,720 --> 00:24:48,240
in a moment and then i built it in rust

685
00:24:48,240 --> 00:24:49,760
rust obviously being compiled it's

686
00:24:49,760 --> 00:24:53,200
faster than python or janky bash script

687
00:24:53,200 --> 00:24:54,799
and rust also just sort of encourages

688
00:24:54,799 --> 00:24:56,799
good programming habits that make your

689
00:24:56,799 --> 00:24:59,520
your stuff go a bit faster

690
00:24:59,520 --> 00:25:02,240
then tried a bunch of threading

691
00:25:02,240 --> 00:25:05,039
threading things which which have been

692
00:25:05,039 --> 00:25:07,200
quite misleading for the most part they

693
00:25:07,200 --> 00:25:08,880
either gave me the same performance as

694
00:25:08,880 --> 00:25:10,559
not using them or worse performance or

695
00:25:10,559 --> 00:25:12,840
in some cases very slight performance

696
00:25:12,840 --> 00:25:15,039
improvements so i'm actually only using

697
00:25:15,039 --> 00:25:16,720
threading at this point for the two

698
00:25:16,720 --> 00:25:18,400
bytes lookup

699
00:25:18,400 --> 00:25:19,760
with a couple of threads which gives me

700
00:25:19,760 --> 00:25:21,919
a slight speed optimization on average

701
00:25:21,919 --> 00:25:23,679
but threading wasn't wasn't more

702
00:25:23,679 --> 00:25:24,960
efficient

703
00:25:24,960 --> 00:25:26,559
which is very different from the fpga

704
00:25:26,559 --> 00:25:28,240
type stuff and it's really just because

705
00:25:28,240 --> 00:25:31,520
so few operations are happening

706
00:25:31,520 --> 00:25:33,679
so let's get into things that look like

707
00:25:33,679 --> 00:25:35,520
i know what i'm talking about

708
00:25:35,520 --> 00:25:37,360
so if we were to map the performance

709
00:25:37,360 --> 00:25:39,600
comparative performance of

710
00:25:39,600 --> 00:25:42,400
a des brute force so going through the

711
00:25:42,400 --> 00:25:44,480
the key space of dez versus the approach

712
00:25:44,480 --> 00:25:47,279
we're taking the asylus so in asylus we

713
00:25:47,279 --> 00:25:49,760
we do the lookup uh which is a b tree

714
00:25:49,760 --> 00:25:52,559
lookup and then for the returned hashes

715
00:25:52,559 --> 00:25:53,679
we need to

716
00:25:53,679 --> 00:25:55,200
crack the remaining keys so there are

717
00:25:55,200 --> 00:25:57,600
some des operations now if we assume the

718
00:25:57,600 --> 00:25:59,120
lookup and the des operations are the

719
00:25:59,120 --> 00:26:00,080
same

720
00:26:00,080 --> 00:26:02,159
we can kind of plot some some bigger

721
00:26:02,159 --> 00:26:03,919
notation on the graph

722
00:26:03,919 --> 00:26:05,919
so i've got two two axes there the

723
00:26:05,919 --> 00:26:07,760
y-axis is the number of operations and

724
00:26:07,760 --> 00:26:09,679
the x-axis axis is the number of hashes

725
00:26:09,679 --> 00:26:11,440
so how many hashes do we get per number

726
00:26:11,440 --> 00:26:12,720
of operations

727
00:26:12,720 --> 00:26:14,159
both of those scales are logarithmic

728
00:26:14,159 --> 00:26:17,279
scales so a straight line is actually a

729
00:26:17,279 --> 00:26:18,559
a curve

730
00:26:18,559 --> 00:26:20,640
a logarithmic curve and what you'll see

731
00:26:20,640 --> 00:26:21,919
at some point they cross over so the

732
00:26:21,919 --> 00:26:23,919
blue line is a desperate force and the

733
00:26:23,919 --> 00:26:26,400
red line is is the asless approach

734
00:26:26,400 --> 00:26:27,760
and the point at which they cross over

735
00:26:27,760 --> 00:26:30,159
for worst case performance is about 4.3

736
00:26:30,159 --> 00:26:33,279
billion hashes so what that means is if

737
00:26:33,279 --> 00:26:35,840
you have an asless database that has 4.3

738
00:26:35,840 --> 00:26:38,000
billion hashes in it

739
00:26:38,000 --> 00:26:40,000
then a des operation and assuming worst

740
00:26:40,000 --> 00:26:42,080
case performance so the hash isn't

741
00:26:42,080 --> 00:26:44,320
uh is at the end and you have to look up

742
00:26:44,320 --> 00:26:45,520
everything

743
00:26:45,520 --> 00:26:46,400
then

744
00:26:46,400 --> 00:26:49,760
a des brute force would be the same

745
00:26:49,760 --> 00:26:51,600
for the median case that turns into 17

746
00:26:51,600 --> 00:26:53,679
billion hashes

747
00:26:53,679 --> 00:26:55,120
so that's that's pretty big so if you

748
00:26:55,120 --> 00:26:56,320
think about the have i been pointless

749
00:26:56,320 --> 00:26:59,440
that's about 600 million hashes so 17

750
00:26:59,440 --> 00:27:00,880
billion or even 4.3 billion for the

751
00:27:00,880 --> 00:27:03,520
worst cases is pretty significant

752
00:27:03,520 --> 00:27:04,880
but if you're going bigger than that

753
00:27:04,880 --> 00:27:07,200
it's worth worth recognizing that that

754
00:27:07,200 --> 00:27:09,279
dez is going to be a des brute force can

755
00:27:09,279 --> 00:27:10,400
be better

756
00:27:10,400 --> 00:27:12,159
plus a des brute force is guaranteed to

757
00:27:12,159 --> 00:27:13,760
give you a hash so for computer hashes

758
00:27:13,760 --> 00:27:15,279
or non-readable

759
00:27:15,279 --> 00:27:16,400
hashes

760
00:27:16,400 --> 00:27:18,159
that's a better approach but if you're

761
00:27:18,159 --> 00:27:19,840
looking for human readable hashes you

762
00:27:19,840 --> 00:27:20,960
know the kind of things the user's

763
00:27:20,960 --> 00:27:22,880
actually chosen then aslis is going to

764
00:27:22,880 --> 00:27:24,960
have a an obvious advantage because it's

765
00:27:24,960 --> 00:27:27,360
going to favor those over a random walk

766
00:27:27,360 --> 00:27:28,159
through

767
00:27:28,159 --> 00:27:30,960
through dez key space

768
00:27:30,960 --> 00:27:33,360
all right so this is the the money shot

769
00:27:33,360 --> 00:27:37,039
here on my on my my now old laptop we

770
00:27:37,039 --> 00:27:39,279
need to rerun the benchmarks on the mac

771
00:27:39,279 --> 00:27:40,960
m1

772
00:27:40,960 --> 00:27:42,960
using three different hashes so hash

773
00:27:42,960 --> 00:27:45,600
three was not present in

774
00:27:45,600 --> 00:27:48,080
uh in any of those word lists and then

775
00:27:48,080 --> 00:27:49,520
there's three word lists a small private

776
00:27:49,520 --> 00:27:50,559
word list

777
00:27:50,559 --> 00:27:52,240
the roku database obviously and then

778
00:27:52,240 --> 00:27:54,159
they have ibn perm database

779
00:27:54,159 --> 00:27:56,000
so bottom right shows worst case

780
00:27:56,000 --> 00:27:57,679
performance so that's a hash that wasn't

781
00:27:57,679 --> 00:27:59,039
found so we effectively had to go

782
00:27:59,039 --> 00:28:00,640
through all of the have i been put in

783
00:28:00,640 --> 00:28:01,840
database to get there and you can see

784
00:28:01,840 --> 00:28:03,440
worst case performance was sitting at 63

785
00:28:03,440 --> 00:28:04,960
milliseconds

786
00:28:04,960 --> 00:28:06,799
uh best case performance was sitting at

787
00:28:06,799 --> 00:28:09,440
11 milliseconds and the median case is

788
00:28:09,440 --> 00:28:11,279
sort of 15 19

789
00:28:11,279 --> 00:28:13,520
um oh i've got it written down there 13

790
00:28:13,520 --> 00:28:15,760
milliseconds i should read my own slides

791
00:28:15,760 --> 00:28:18,240
now if you think about the rip van

792
00:28:18,240 --> 00:28:20,720
winkle slide and you think about how we

793
00:28:20,720 --> 00:28:23,360
were measuring the performance in hours

794
00:28:23,360 --> 00:28:25,520
this is a massive improvement at the

795
00:28:25,520 --> 00:28:27,520
cost of not getting a guaranteed result

796
00:28:27,520 --> 00:28:28,720
so the hash has to be in your hash

797
00:28:28,720 --> 00:28:30,559
database but if you're doing a really

798
00:28:30,559 --> 00:28:32,480
quick look

799
00:28:32,480 --> 00:28:33,919
that gives you an immediate result that

800
00:28:33,919 --> 00:28:35,520
at least tells you okay now it's

801
00:28:35,520 --> 00:28:38,080
worthwhile to engage in a in a des key

802
00:28:38,080 --> 00:28:40,320
space brute force then

803
00:28:40,320 --> 00:28:42,480
then great

804
00:28:42,480 --> 00:28:44,320
all right so this is available right now

805
00:28:44,320 --> 00:28:45,120
on

806
00:28:45,120 --> 00:28:48,240
our github github.com sensepost slash

807
00:28:48,240 --> 00:28:50,480
aslist-chaps

808
00:28:50,480 --> 00:28:52,159
and i'm going to give you a quick demo

809
00:28:52,159 --> 00:28:53,360
on that

810
00:28:53,360 --> 00:28:55,520
okay so now we've switched over to the

811
00:28:55,520 --> 00:28:58,159
demo and the first thing we need is a

812
00:28:58,159 --> 00:29:01,200
word list or more importantly a hash so

813
00:29:01,200 --> 00:29:03,200
if we look at rock u we've got clear

814
00:29:03,200 --> 00:29:04,640
text passwords

815
00:29:04,640 --> 00:29:06,720
so we're going to need to convert that

816
00:29:06,720 --> 00:29:09,600
into the the as database format it's a

817
00:29:09,600 --> 00:29:11,600
sqlite database

818
00:29:11,600 --> 00:29:13,679
i've already created one here

819
00:29:13,679 --> 00:29:15,440
if you look inside of it

820
00:29:15,440 --> 00:29:18,640
what it has are empty hashes split up

821
00:29:18,640 --> 00:29:21,360
into the the three key components

822
00:29:21,360 --> 00:29:23,600
so here i'm just looking at the top five

823
00:29:23,600 --> 00:29:25,360
from here a little bit later i'll show

824
00:29:25,360 --> 00:29:27,200
you how to generate

825
00:29:27,200 --> 00:29:29,200
this hash list

826
00:29:29,200 --> 00:29:31,600
okay so now that we we've got our

827
00:29:31,600 --> 00:29:33,760
database what we need is a hash

828
00:29:33,760 --> 00:29:36,640
so if we look here i've got an examples

829
00:29:36,640 --> 00:29:38,480
hash we've captured from a user called

830
00:29:38,480 --> 00:29:40,799
sally it's got the anti-response and

831
00:29:40,799 --> 00:29:42,399
it's got the challenge

832
00:29:42,399 --> 00:29:44,799
we look at assets chaps we give it the

833
00:29:44,799 --> 00:29:47,120
challenge and we give it the response

834
00:29:47,120 --> 00:29:48,640
and then we give it the database so here

835
00:29:48,640 --> 00:29:51,919
we're using rocky.db when we run it

836
00:29:51,919 --> 00:29:54,000
we get our response very quickly if we

837
00:29:54,000 --> 00:29:56,520
run it with time you can see it took

838
00:29:56,520 --> 00:30:00,240
0.015 seconds in total

839
00:30:00,240 --> 00:30:02,720
which is pretty cool okay now if we were

840
00:30:02,720 --> 00:30:05,600
to compare it with hashcats 5500 mode

841
00:30:05,600 --> 00:30:07,840
which gives us the clear text using a

842
00:30:07,840 --> 00:30:10,320
clear text password list

843
00:30:10,320 --> 00:30:12,880
i'm using the same hash

844
00:30:12,880 --> 00:30:15,520
and i'm going to make it quiet disable

845
00:30:15,520 --> 00:30:17,039
the pod file

846
00:30:17,039 --> 00:30:18,159
and let's

847
00:30:18,159 --> 00:30:20,559
i'm using some apple silicon i need to

848
00:30:20,559 --> 00:30:23,520
say d2 when i run it i'm able to get the

849
00:30:23,520 --> 00:30:26,480
password if we now run that with a timer

850
00:30:26,480 --> 00:30:29,080
you can see that takes

851
00:30:29,080 --> 00:30:32,000
1.166 seconds in total

852
00:30:32,000 --> 00:30:34,559
so that's a 100 times speed difference

853
00:30:34,559 --> 00:30:37,919
almost between the two okay so switching

854
00:30:37,919 --> 00:30:40,640
back to the slides from our demo

855
00:30:40,640 --> 00:30:42,559
the next optimization we wanted to talk

856
00:30:42,559 --> 00:30:43,679
about is

857
00:30:43,679 --> 00:30:45,039
when you're looking at the have i been

858
00:30:45,039 --> 00:30:46,880
prone list you've got a lot of passwords

859
00:30:46,880 --> 00:30:48,960
in there that typically aren't chosen by

860
00:30:48,960 --> 00:30:50,960
corporate active directory domain users

861
00:30:50,960 --> 00:30:52,720
and when you're cracking an ms chap hash

862
00:30:52,720 --> 00:30:54,880
from a wi-fi exchange that's probably

863
00:30:54,880 --> 00:30:57,519
from a microsoft active directory um

864
00:30:57,519 --> 00:30:59,519
controlled wi-fi network which means the

865
00:30:59,519 --> 00:31:01,360
user is going to be using

866
00:31:01,360 --> 00:31:02,640
something that needs an upper case a

867
00:31:02,640 --> 00:31:04,960
lower case and a number in it like the

868
00:31:04,960 --> 00:31:07,440
password ones capital ps but have i been

869
00:31:07,440 --> 00:31:09,440
pwned has got things like one two three

870
00:31:09,440 --> 00:31:12,080
four five six and michael or lowercase

871
00:31:12,080 --> 00:31:14,320
stupid name if you ask me

872
00:31:14,320 --> 00:31:16,559
uh and those sorts of things here some

873
00:31:16,559 --> 00:31:18,399
stats from the nscs

874
00:31:18,399 --> 00:31:20,480
and sc

875
00:31:20,480 --> 00:31:22,960
and csc get some just late-night

876
00:31:22,960 --> 00:31:24,640
dyslexia here

877
00:31:24,640 --> 00:31:26,799
about what's what's in there so this is

878
00:31:26,799 --> 00:31:28,960
not a great hash list for for corporate

879
00:31:28,960 --> 00:31:31,440
passwords what is a good hash list

880
00:31:31,440 --> 00:31:33,519
what produces good hash list is hash

881
00:31:33,519 --> 00:31:36,000
cats rules based attacks so i thought it

882
00:31:36,000 --> 00:31:37,440
would be really nice if we could use

883
00:31:37,440 --> 00:31:39,519
hashcat's rule-based attacks to generate

884
00:31:39,519 --> 00:31:42,240
asless databases

885
00:31:42,240 --> 00:31:45,039
so this is what hashcat does with

886
00:31:45,039 --> 00:31:46,240
an overly simplistic view of what

887
00:31:46,240 --> 00:31:48,240
hashtag does with rules if you take a

888
00:31:48,240 --> 00:31:50,080
password list that has password and the

889
00:31:50,080 --> 00:31:51,519
company name in it

890
00:31:51,519 --> 00:31:52,880
and it's got three simple rules of

891
00:31:52,880 --> 00:31:54,480
adding numbers adding dates and changing

892
00:31:54,480 --> 00:31:56,880
the case then you can get the the kind

893
00:31:56,880 --> 00:31:59,200
of clear text examples you get on the

894
00:31:59,200 --> 00:32:01,200
right

895
00:32:01,200 --> 00:32:04,960
so i built some hashcat uh what's a very

896
00:32:04,960 --> 00:32:07,039
simple modification to one of the

897
00:32:07,039 --> 00:32:09,519
hashcat kernels to effectively generate

898
00:32:09,519 --> 00:32:11,600
csv files for you that have the hashes

899
00:32:11,600 --> 00:32:13,760
in that can then be consumed by the

900
00:32:13,760 --> 00:32:16,799
database creation utility in aslis

901
00:32:16,799 --> 00:32:19,440
as well as you can then use the normal

902
00:32:19,440 --> 00:32:22,159
hashcat functionality to pass rules

903
00:32:22,159 --> 00:32:23,760
so i'm going to give you a quick demo of

904
00:32:23,760 --> 00:32:25,279
that this is all available on the github

905
00:32:25,279 --> 00:32:26,960
repository

906
00:32:26,960 --> 00:32:29,200
okay so we're going to give you the the

907
00:32:29,200 --> 00:32:31,600
demo of generating hash lists

908
00:32:31,600 --> 00:32:34,320
if we look at our rocky clear text

909
00:32:34,320 --> 00:32:35,840
database

910
00:32:35,840 --> 00:32:37,440
we've got clear text passwords in there

911
00:32:37,440 --> 00:32:39,760
we need to turn that into into a hash

912
00:32:39,760 --> 00:32:41,760
list there's two ways we can do that the

913
00:32:41,760 --> 00:32:43,279
one is to convert it directly into a

914
00:32:43,279 --> 00:32:45,840
hash list using a python program that's

915
00:32:45,840 --> 00:32:47,760
uh included within aslis and that's what

916
00:32:47,760 --> 00:32:49,120
i'm going to show you first and then the

917
00:32:49,120 --> 00:32:51,519
second is to expand it using the rules

918
00:32:51,519 --> 00:32:52,559
from

919
00:32:52,559 --> 00:32:54,080
from hashcat

920
00:32:54,080 --> 00:32:56,000
okay so antihash from here just takes

921
00:32:56,000 --> 00:32:58,559
the database and spits out actions so

922
00:32:58,559 --> 00:32:59,840
i'm not going to do all of them i'm just

923
00:32:59,840 --> 00:33:01,600
going to do the head you can see it puts

924
00:33:01,600 --> 00:33:03,519
it in this special format with the first

925
00:33:03,519 --> 00:33:06,000
the last two bytes in the beginning

926
00:33:06,000 --> 00:33:08,080
and then the

927
00:33:08,080 --> 00:33:11,039
first seven bytes and then the second

928
00:33:11,039 --> 00:33:13,519
seven bytes

929
00:33:13,519 --> 00:33:16,399
so that is the the format the csv file

930
00:33:16,399 --> 00:33:18,559
needs to be in to

931
00:33:18,559 --> 00:33:20,880
be imported into the sqlite database

932
00:33:20,880 --> 00:33:22,640
all right next i'll show you how you can

933
00:33:22,640 --> 00:33:24,880
use hashcat and the reason i want to use

934
00:33:24,880 --> 00:33:27,039
hashcat to do this is because then i can

935
00:33:27,039 --> 00:33:28,000
get

936
00:33:28,000 --> 00:33:29,360
rules to increase the number of

937
00:33:29,360 --> 00:33:31,200
passwords that are generated i'm giving

938
00:33:31,200 --> 00:33:33,360
it an impossible to crack hash so that

939
00:33:33,360 --> 00:33:35,679
it doesn't match the hash and then exit

940
00:33:35,679 --> 00:33:37,760
early and i've applied the modifications

941
00:33:37,760 --> 00:33:40,640
from the asylus repository on the um

942
00:33:40,640 --> 00:33:42,880
1000 mode

943
00:33:42,880 --> 00:33:44,799
so you can see dash r is the rule file

944
00:33:44,799 --> 00:33:46,320
for the best 64 rule which just comes

945
00:33:46,320 --> 00:33:48,720
with hashtag you can use whatever rule

946
00:33:48,720 --> 00:33:50,640
you like and then we can output that to

947
00:33:50,640 --> 00:33:53,679
the csv file it can take some time

948
00:33:53,679 --> 00:33:54,480
so

949
00:33:54,480 --> 00:33:55,760
instead i'm just going to use the csv

950
00:33:55,760 --> 00:33:57,120
file we generated before for the

951
00:33:57,120 --> 00:33:59,279
purposes of this demo if you look at it

952
00:33:59,279 --> 00:34:00,799
there's our

953
00:34:00,799 --> 00:34:02,720
there's our hashes it's the full rock u

954
00:34:02,720 --> 00:34:04,720
that's just the the top of it so there's

955
00:34:04,720 --> 00:34:06,559
another file included in the atlas

956
00:34:06,559 --> 00:34:08,960
repository called make sequel ipb

957
00:34:08,960 --> 00:34:10,159
you give it the name of the database you

958
00:34:10,159 --> 00:34:12,639
want to create you give it the csv file

959
00:34:12,639 --> 00:34:16,960
it'll first import all of those into the

960
00:34:16,960 --> 00:34:18,639
sqlite database

961
00:34:18,639 --> 00:34:20,719
after it's finished importing them it

962
00:34:20,719 --> 00:34:23,359
will create the the index on it

963
00:34:23,359 --> 00:34:25,280
for something like rocky that can take a

964
00:34:25,280 --> 00:34:27,199
couple of minutes

965
00:34:27,199 --> 00:34:29,280
uh for something like have i been pwned

966
00:34:29,280 --> 00:34:31,839
that can take tens of minutes

967
00:34:31,839 --> 00:34:33,839
so it depends on the the size thing but

968
00:34:33,839 --> 00:34:35,440
it's a once off cost once you've got it

969
00:34:35,440 --> 00:34:36,560
you're done

970
00:34:36,560 --> 00:34:37,918
and then

971
00:34:37,918 --> 00:34:39,679
the the database with the index

972
00:34:39,679 --> 00:34:43,280
increases the size by about 63 percent

973
00:34:43,280 --> 00:34:46,159
so the rock udb is about 63 percent

974
00:34:46,159 --> 00:34:48,480
bigger than rocky.txt which is worth

975
00:34:48,480 --> 00:34:50,879
bearing in mind but it's really not

976
00:34:50,879 --> 00:34:51,918
massive

977
00:34:51,918 --> 00:34:55,839
massive hash requirements at this point

978
00:34:55,839 --> 00:34:57,599
so there's one more thing that i want to

979
00:34:57,599 --> 00:35:00,480
show you which is if you've got an ntlm

980
00:35:00,480 --> 00:35:03,839
ssp or ntlm ess hash here's an example

981
00:35:03,839 --> 00:35:06,160
of one taken from the hash cat example

982
00:35:06,160 --> 00:35:08,720
hashes and what you'll see is when i put

983
00:35:08,720 --> 00:35:09,920
what looks like the challenge and

984
00:35:09,920 --> 00:35:12,720
response into asless

985
00:35:12,720 --> 00:35:15,440
it just hangs i haven't managed to track

986
00:35:15,440 --> 00:35:18,400
down this this bug yet but if you ever

987
00:35:18,400 --> 00:35:20,400
have asked this just hanging like this

988
00:35:20,400 --> 00:35:23,760
uh it means you've got a an ssp hash so

989
00:35:23,760 --> 00:35:26,000
evilmog has some scripts to to fix that

990
00:35:26,000 --> 00:35:27,520
up i found them quite complicated so

991
00:35:27,520 --> 00:35:29,119
i've just written something very simple

992
00:35:29,119 --> 00:35:31,119
it's called ntlm ssp

993
00:35:31,119 --> 00:35:34,160
and you give it the the lm part and you

994
00:35:34,160 --> 00:35:35,839
give it the

995
00:35:35,839 --> 00:35:38,560
and the challenge part from the ssp hash

996
00:35:38,560 --> 00:35:40,720
it'll split out the server challenge

997
00:35:40,720 --> 00:35:42,960
which is what you can then use as the

998
00:35:42,960 --> 00:35:45,040
challenge to pass to you to atlas so

999
00:35:45,040 --> 00:35:46,640
it's a small conversion step that you

1000
00:35:46,640 --> 00:35:50,079
need to do for ntlm version 1 ess

1001
00:35:50,079 --> 00:35:53,200
or ssp hashes i'm not going to go into

1002
00:35:53,200 --> 00:35:55,359
to all of the specifics there but it's

1003
00:35:55,359 --> 00:35:57,440
worthwhile noting if you're dealing with

1004
00:35:57,440 --> 00:35:59,520
uh ntlm version one so you can see i

1005
00:35:59,520 --> 00:36:01,119
first tried it with rocky it wasn't in

1006
00:36:01,119 --> 00:36:03,119
there so then i tried it with have i

1007
00:36:03,119 --> 00:36:05,680
been phoned

1008
00:36:06,480 --> 00:36:09,040
okay so that was demoing the hash list

1009
00:36:09,040 --> 00:36:10,400
creation and that's how you can create

1010
00:36:10,400 --> 00:36:12,640
your own databases for for use with

1011
00:36:12,640 --> 00:36:14,320
aslis

1012
00:36:14,320 --> 00:36:16,640
that brings me to the end of my section

1013
00:36:16,640 --> 00:36:19,440
and just a quick recap really what i was

1014
00:36:19,440 --> 00:36:23,119
showing is how because

1015
00:36:23,119 --> 00:36:25,359
ms chap and ntlm version 1 don't protect

1016
00:36:25,359 --> 00:36:26,880
their ass that you can do this easy

1017
00:36:26,880 --> 00:36:28,800
brute force of the last two bytes you

1018
00:36:28,800 --> 00:36:30,720
can use that to reduce the number of

1019
00:36:30,720 --> 00:36:32,720
hashes you look at in the first place

1020
00:36:32,720 --> 00:36:34,640
and the way you can very efficiently

1021
00:36:34,640 --> 00:36:36,240
reduce those number of hashes is using a

1022
00:36:36,240 --> 00:36:38,800
database lookup with some some compiled

1023
00:36:38,800 --> 00:36:40,880
code and doing that has produced a

1024
00:36:40,880 --> 00:36:42,960
utility which improves the state of the

1025
00:36:42,960 --> 00:36:45,040
art with with this cracking

1026
00:36:45,040 --> 00:36:47,359
it's important to to mention that this

1027
00:36:47,359 --> 00:36:49,280
also works for ntlan version one or ntlm

1028
00:36:49,280 --> 00:36:52,079
version one ssp there's a utility in the

1029
00:36:52,079 --> 00:36:54,000
github repository if you want to convert

1030
00:36:54,000 --> 00:36:56,160
an ssp hash

1031
00:36:56,160 --> 00:36:56,960
so

1032
00:36:56,960 --> 00:36:59,040
if you've got an ntlm version one hash

1033
00:36:59,040 --> 00:37:01,520
like something from petipotent maybe

1034
00:37:01,520 --> 00:37:03,680
i still need to look into that then uh

1035
00:37:03,680 --> 00:37:05,200
you might be able to recover it quite

1036
00:37:05,200 --> 00:37:06,839
quickly using ashley's

1037
00:37:06,839 --> 00:37:09,200
assless and on that note i'm going to

1038
00:37:09,200 --> 00:37:12,799
hand back to michael

1039
00:37:14,480 --> 00:37:16,640
cool thank you dominic

1040
00:37:16,640 --> 00:37:17,760
hi

1041
00:37:17,760 --> 00:37:20,800
so just to recap everything everything

1042
00:37:20,800 --> 00:37:22,400
uh why are we doing this we want to

1043
00:37:22,400 --> 00:37:24,560
recover nt hashes quickly as i showed

1044
00:37:24,560 --> 00:37:26,560
you with an anti-hash you can pass the

1045
00:37:26,560 --> 00:37:27,680
hash

1046
00:37:27,680 --> 00:37:28,120
um

1047
00:37:28,120 --> 00:37:29,839
[Music]

1048
00:37:29,839 --> 00:37:31,760
we can then pass dash to connect to

1049
00:37:31,760 --> 00:37:34,000
wi-fi we can pass dash to connect to

1050
00:37:34,000 --> 00:37:36,079
vpns

1051
00:37:36,079 --> 00:37:37,119
you can use

1052
00:37:37,119 --> 00:37:39,680
pass the hash on normal windows networks

1053
00:37:39,680 --> 00:37:40,800
as well

1054
00:37:40,800 --> 00:37:43,839
the last one is also to host access

1055
00:37:43,839 --> 00:37:45,359
points that hopefully

1056
00:37:45,359 --> 00:37:47,040
you can trick people into connecting to

1057
00:37:47,040 --> 00:37:48,160
you

1058
00:37:48,160 --> 00:37:49,839
so that you can do sort of person in the

1059
00:37:49,839 --> 00:37:52,320
middle attacks and attack them further

1060
00:37:52,320 --> 00:37:54,480
as it were

1061
00:37:54,480 --> 00:37:57,200
okay so in summary ms chaff v2 use the

1062
00:37:57,200 --> 00:37:59,200
nt hash not the clear text password you

1063
00:37:59,200 --> 00:38:01,200
can use full empty hash lists including

1064
00:38:01,200 --> 00:38:03,040
the uncracked ones

1065
00:38:03,040 --> 00:38:06,480
new hashcat modes we created with two

1066
00:38:06,480 --> 00:38:08,320
twenty seven thousand twenty seven

1067
00:38:08,320 --> 00:38:10,480
thousand one hundred for ntl mv1 and

1068
00:38:10,480 --> 00:38:13,680
ntlmv2 ntlmv1 of course being the same

1069
00:38:13,680 --> 00:38:16,640
way you crack ms chap

1070
00:38:16,640 --> 00:38:19,359
ms chap exposes his ass easy brute of

1071
00:38:19,359 --> 00:38:20,960
the last two bytes

1072
00:38:20,960 --> 00:38:22,960
these can reduce the hash list to crack

1073
00:38:22,960 --> 00:38:25,520
against so it makes it very very quick

1074
00:38:25,520 --> 00:38:27,599
uh indexed db lookups cost less than

1075
00:38:27,599 --> 00:38:29,359
their brute forces

1076
00:38:29,359 --> 00:38:30,560
at least

1077
00:38:30,560 --> 00:38:32,640
at less than 17 billion hashes on the

1078
00:38:32,640 --> 00:38:35,359
average case

1079
00:38:35,520 --> 00:38:36,400
so

1080
00:38:36,400 --> 00:38:38,000
people to thank

1081
00:38:38,000 --> 00:38:38,800
uh

1082
00:38:38,800 --> 00:38:39,920
my

1083
00:38:39,920 --> 00:38:42,000
hackathon team from

1084
00:38:42,000 --> 00:38:44,079
uh or in cyber defense this is the

1085
00:38:44,079 --> 00:38:47,280
people who helped me create the initial

1086
00:38:47,280 --> 00:38:51,119
proof of concept for the hashcat module

1087
00:38:51,119 --> 00:38:52,400
once we

1088
00:38:52,400 --> 00:38:54,160
once i had the hashcat module in a pull

1089
00:38:54,160 --> 00:38:57,359
request atom and chickenman gave me a

1090
00:38:57,359 --> 00:39:00,079
lot of help making it an actual good

1091
00:39:00,079 --> 00:39:01,680
hashcat module

1092
00:39:01,680 --> 00:39:03,839
uh we then want to thank joshua wright

1093
00:39:03,839 --> 00:39:04,960
for asleep

1094
00:39:04,960 --> 00:39:07,599
um basically all workers built off the

1095
00:39:07,599 --> 00:39:09,599
shoulders of giants sort of thing moxie

1096
00:39:09,599 --> 00:39:12,000
and david for cloud crack and then if

1097
00:39:12,000 --> 00:39:13,760
you are interested in this sort of

1098
00:39:13,760 --> 00:39:16,480
technique of

1099
00:39:16,480 --> 00:39:18,640
cracking hashes but

1100
00:39:18,640 --> 00:39:21,040
skipping some steps in the front

1101
00:39:21,040 --> 00:39:22,240
chicken man

1102
00:39:22,240 --> 00:39:24,880
did a talk at defcon for hash shucking

1103
00:39:24,880 --> 00:39:27,040
which is the name of this technique

1104
00:39:27,040 --> 00:39:29,920
and then once again you can get the

1105
00:39:29,920 --> 00:39:34,240
atlas chaps from the repo listed

1106
00:39:34,400 --> 00:39:35,520
the end

1107
00:39:35,520 --> 00:39:36,880
and

1108
00:39:36,880 --> 00:39:40,520
cool thank you

1109
00:40:00,560 --> 00:40:02,480
do you

1110
00:40:02,480 --> 00:40:06,680
oh no i should put my head in there

