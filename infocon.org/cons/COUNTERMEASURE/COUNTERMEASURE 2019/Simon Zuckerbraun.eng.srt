1
00:00:00,000 --> 00:00:09,269
Oh everyone thank you for coming this is

2
00:00:09,269 --> 00:00:11,880
the brave new world of JavaScript engine

3
00:00:11,880 --> 00:00:14,610
vulnerabilities on Simon zu curb run I'm

4
00:00:14,610 --> 00:00:17,369
technical lead at the Trend Micro zero

5
00:00:17,369 --> 00:00:19,920
day initiative well first it's just a

6
00:00:19,920 --> 00:00:22,380
few words about who we are zero day

7
00:00:22,380 --> 00:00:25,260
initiative is the world's largest vendor

8
00:00:25,260 --> 00:00:28,470
agnostic bug bounty program each year we

9
00:00:28,470 --> 00:00:31,730
purchase over 1,000 vulnerabilities from

10
00:00:31,730 --> 00:00:35,010
independent researchers worldwide and

11
00:00:35,010 --> 00:00:37,290
these researchers who choose to disclose

12
00:00:37,290 --> 00:00:41,149
responsibly are paid for their hard work

13
00:00:41,149 --> 00:00:44,010
Trend Micro research uses the

14
00:00:44,010 --> 00:00:46,020
intelligence that we gain from these

15
00:00:46,020 --> 00:00:49,800
zero day reports to defend our customers

16
00:00:49,800 --> 00:00:52,379
and every vulnerability that we purchase

17
00:00:52,379 --> 00:00:55,379
is also reported promptly and free of

18
00:00:55,379 --> 00:00:57,780
charge to the vendor of the vulnerable

19
00:00:57,780 --> 00:01:03,629
product for resolution a discussion of

20
00:01:03,629 --> 00:01:06,299
JavaScript security let's begin with the

21
00:01:06,299 --> 00:01:10,170
web browser from the outset web browsers

22
00:01:10,170 --> 00:01:12,930
have been a major contributor to the

23
00:01:12,930 --> 00:01:15,689
attack surface of desktop and mobile

24
00:01:15,689 --> 00:01:18,869
devices if you consider what typically

25
00:01:18,869 --> 00:01:21,659
runs on the end users device it's plain

26
00:01:21,659 --> 00:01:24,119
to see that the browser tends to

27
00:01:24,119 --> 00:01:26,729
dominate both in terms of complexity of

28
00:01:26,729 --> 00:01:30,270
the application and also in terms of the

29
00:01:30,270 --> 00:01:32,670
number of interactions that it has with

30
00:01:32,670 --> 00:01:35,340
external entities over the Internet on a

31
00:01:35,340 --> 00:01:38,659
typical day a user will visit dozens of

32
00:01:38,659 --> 00:01:42,390
websites which will bring in additional

33
00:01:42,390 --> 00:01:45,930
resources from hundreds of secondary

34
00:01:45,930 --> 00:01:48,479
internet locations and each one of those

35
00:01:48,479 --> 00:01:51,930
has access to many thousands of API s

36
00:01:51,930 --> 00:01:54,479
and other features that the browser

37
00:01:54,479 --> 00:01:57,570
offers every time it processes remote

38
00:01:57,570 --> 00:02:02,250
content looking specifically at what

39
00:02:02,250 --> 00:02:04,890
parts of the browser attack surface have

40
00:02:04,890 --> 00:02:08,520
yielded the most vulnerabilities from

41
00:02:08,520 --> 00:02:10,440
our vantage point at the zero day

42
00:02:10,440 --> 00:02:13,750
initiative we have noticed a major

43
00:02:13,750 --> 00:02:18,880
take place prior to 2016 most vulnerable

44
00:02:18,880 --> 00:02:20,980
--'tis discovered were in the

45
00:02:20,980 --> 00:02:24,250
implementation of the various api's that

46
00:02:24,250 --> 00:02:28,150
be the various API is that the browser's

47
00:02:28,150 --> 00:02:31,870
offer and specifically in the Dom API

48
00:02:31,870 --> 00:02:35,050
and the Dom EAP is are the the methods

49
00:02:35,050 --> 00:02:36,550
that they're implemented by the browser

50
00:02:36,550 --> 00:02:39,190
that that webpages invoke in order to

51
00:02:39,190 --> 00:02:41,500
manipulate displayed HTML in an

52
00:02:41,500 --> 00:02:44,860
object-oriented fashion in fact when the

53
00:02:44,860 --> 00:02:47,680
Dom API Valle 'nor abilities were at

54
00:02:47,680 --> 00:02:51,459
their peak in 2014 the zero day

55
00:02:51,459 --> 00:02:53,530
initiative was purchasing approximately

56
00:02:53,530 --> 00:02:56,650
40 Dom vulnerabilities in Internet

57
00:02:56,650 --> 00:03:01,270
Explorer per month since then Dom API

58
00:03:01,270 --> 00:03:03,730
vulnerabilities have been in steep

59
00:03:03,730 --> 00:03:06,190
decline and this is largely due to

60
00:03:06,190 --> 00:03:08,890
effective mitigations that have been put

61
00:03:08,890 --> 00:03:12,910
in place so today in late 2019 it is

62
00:03:12,910 --> 00:03:16,810
rare to see an exploitable Dom API bug

63
00:03:16,810 --> 00:03:21,700
discovered from 2016 and on however

64
00:03:21,700 --> 00:03:24,100
there has been a another less happy

65
00:03:24,100 --> 00:03:27,250
pattern as vulnerabilities began to

66
00:03:27,250 --> 00:03:30,190
emerge in an entirely different area of

67
00:03:30,190 --> 00:03:33,370
the code base of major browsers and that

68
00:03:33,370 --> 00:03:37,480
is in the JavaScript engine to be clear

69
00:03:37,480 --> 00:03:40,780
on this point a JavaScript engine is the

70
00:03:40,780 --> 00:03:43,209
code that parses and execute the

71
00:03:43,209 --> 00:03:46,480
JavaScript language itself the engine

72
00:03:46,480 --> 00:03:48,910
does not include the implementations of

73
00:03:48,910 --> 00:03:51,760
all of their various api's that can be

74
00:03:51,760 --> 00:03:54,970
invoked through JavaScript in recent

75
00:03:54,970 --> 00:03:56,530
years the JavaScript engines of the

76
00:03:56,530 --> 00:03:59,860
major browsers have become a rich source

77
00:03:59,860 --> 00:04:03,750
of vulnerabilities what is worse

78
00:04:03,750 --> 00:04:06,100
vulnerabilities in JavaScript engines

79
00:04:06,100 --> 00:04:09,480
tend to be highly critical in impact

80
00:04:09,480 --> 00:04:11,320
contrast this with the Dom

81
00:04:11,320 --> 00:04:13,239
vulnerabilities of years past

82
00:04:13,239 --> 00:04:16,269
a typical Dom vulnerability would give

83
00:04:16,269 --> 00:04:19,029
the attacker the ability to perform a

84
00:04:19,029 --> 00:04:21,880
very tightly constrained form of memory

85
00:04:21,880 --> 00:04:25,120
disclosure or memory corruption for

86
00:04:25,120 --> 00:04:27,639
example perhaps some Dom API

87
00:04:27,639 --> 00:04:30,280
could be tricked into writing a fixed

88
00:04:30,280 --> 00:04:34,300
value to a single memory location to

89
00:04:34,300 --> 00:04:37,509
exploit such a bug an attacker first

90
00:04:37,509 --> 00:04:39,789
needs to perform a large number of

91
00:04:39,789 --> 00:04:43,659
carefully choreographed operations to

92
00:04:43,659 --> 00:04:47,409
arrange allocations in memory in just

93
00:04:47,409 --> 00:04:49,599
the right way so that the memory

94
00:04:49,599 --> 00:04:51,069
corruption that's triggered by the

95
00:04:51,069 --> 00:04:54,129
vulnerability will affect some

96
00:04:54,129 --> 00:04:56,349
particular structure that the attacker

97
00:04:56,349 --> 00:04:59,590
can use to their advantage in many cases

98
00:04:59,590 --> 00:05:02,139
who is even necessary to combine two

99
00:05:02,139 --> 00:05:05,169
dumb vulnerabilities in a chain one Dom

100
00:05:05,169 --> 00:05:08,110
vulnerability to disclose sensitive

101
00:05:08,110 --> 00:05:12,219
information from from memory that was

102
00:05:12,219 --> 00:05:13,960
necessary for setting setting up the

103
00:05:13,960 --> 00:05:16,090
next stage of the attack and then a

104
00:05:16,090 --> 00:05:19,150
second Dom vulnerability to actually do

105
00:05:19,150 --> 00:05:21,430
the memory corruption that results in

106
00:05:21,430 --> 00:05:24,849
remote code execution in contrast a

107
00:05:24,849 --> 00:05:28,419
JavaScript engine vulnerability almost

108
00:05:28,419 --> 00:05:31,300
is always catastrophic to process

109
00:05:31,300 --> 00:05:33,789
security exploiting a JavaScript

110
00:05:33,789 --> 00:05:35,800
vulnerability immediately gives an

111
00:05:35,800 --> 00:05:39,370
attacker everything they need to execute

112
00:05:39,370 --> 00:05:41,740
arbitrary code within the browser

113
00:05:41,740 --> 00:05:44,770
process although modern process wide

114
00:05:44,770 --> 00:05:47,919
mitigations can still throw as few speed

115
00:05:47,919 --> 00:05:52,870
bumps in a way now it may seem somewhat

116
00:05:52,870 --> 00:05:55,899
surprising that JavaScript engines

117
00:05:55,899 --> 00:05:59,379
harbor large numbers of bugs after all

118
00:05:59,379 --> 00:06:03,009
javascript is only a language it has a

119
00:06:03,009 --> 00:06:05,319
fairly modest library of standard

120
00:06:05,319 --> 00:06:09,339
objects unlike the Dom API JavaScript by

121
00:06:09,339 --> 00:06:11,649
itself does not offer a sprawling

122
00:06:11,649 --> 00:06:14,649
menagerie of objects and methods so why

123
00:06:14,649 --> 00:06:18,279
is it that the JavaScript engine is so

124
00:06:18,279 --> 00:06:21,909
hard to secure well the fundamental

125
00:06:21,909 --> 00:06:24,580
answer is that javascript is a highly

126
00:06:24,580 --> 00:06:28,029
dynamic loosely typed language also for

127
00:06:28,029 --> 00:06:29,789
historical reasons it has a lot of

128
00:06:29,789 --> 00:06:32,649
idiosyncrasies and in the slides to come

129
00:06:32,649 --> 00:06:34,449
I'm going to go into some detail about

130
00:06:34,449 --> 00:06:36,729
what that means but the bottom line is

131
00:06:36,729 --> 00:06:39,279
that javascript is a language that does

132
00:06:39,279 --> 00:06:41,320
not lend itself well to

133
00:06:41,320 --> 00:06:45,250
high-performance execution but as of

134
00:06:45,250 --> 00:06:47,650
today javascript has become the language

135
00:06:47,650 --> 00:06:49,870
that powers the entire client-side

136
00:06:49,870 --> 00:06:52,590
portion of the web plus a significant

137
00:06:52,590 --> 00:06:55,240
chunk of the server-side portion as well

138
00:06:55,240 --> 00:06:58,180
plus many other things such as apps

139
00:06:58,180 --> 00:07:01,450
written using the elektron framework so

140
00:07:01,450 --> 00:07:03,340
to meet the demands of all of these

141
00:07:03,340 --> 00:07:05,560
applications high performance is a

142
00:07:05,560 --> 00:07:08,890
necessity this means that the developers

143
00:07:08,890 --> 00:07:12,870
of JavaScript engines have had to expend

144
00:07:12,870 --> 00:07:15,490
enormous effort on the problem of

145
00:07:15,490 --> 00:07:18,030
performance and it's an enormous

146
00:07:18,030 --> 00:07:22,570
implementation challenge I believe that

147
00:07:22,570 --> 00:07:24,550
there's a dynamic at work here that's

148
00:07:24,550 --> 00:07:28,600
known as a Red Queen's race which is an

149
00:07:28,600 --> 00:07:31,600
interplay between stakeholders that roll

150
00:07:31,600 --> 00:07:34,050
results in a continually shifting

151
00:07:34,050 --> 00:07:37,390
goalpost originally javascript was

152
00:07:37,390 --> 00:07:40,510
envisioned as a scripting language for

153
00:07:40,510 --> 00:07:43,240
performing lightweight operations within

154
00:07:43,240 --> 00:07:45,820
webpages for example the user clicks on

155
00:07:45,820 --> 00:07:49,300
a button and the script displays warning

156
00:07:49,300 --> 00:07:51,790
messages for any required fields that

157
00:07:51,790 --> 00:07:55,420
haven't been filled in simple operations

158
00:07:55,420 --> 00:07:57,550
like that did not require any special

159
00:07:57,550 --> 00:08:01,840
effort to achieve good performance over

160
00:08:01,840 --> 00:08:04,690
time web developers began to push the

161
00:08:04,690 --> 00:08:07,120
envelope on what javascript could

162
00:08:07,120 --> 00:08:09,250
deliver and since the original

163
00:08:09,250 --> 00:08:12,640
JavaScript implementations were naive in

164
00:08:12,640 --> 00:08:14,620
regards to performance that soon

165
00:08:14,620 --> 00:08:16,600
resulted in laggy webpages

166
00:08:16,600 --> 00:08:20,080
in an effort to make their browsers

167
00:08:20,080 --> 00:08:22,720
highly responsive again the browser

168
00:08:22,720 --> 00:08:25,000
providers started to soup up their

169
00:08:25,000 --> 00:08:27,040
JavaScript engines with more

170
00:08:27,040 --> 00:08:30,090
sophisticated code in order to help

171
00:08:30,090 --> 00:08:34,690
JavaScript run more quickly but when web

172
00:08:34,690 --> 00:08:36,789
developers found that there was

173
00:08:36,789 --> 00:08:39,370
significantly improved JavaScript

174
00:08:39,370 --> 00:08:42,099
performance at their disposal then they

175
00:08:42,099 --> 00:08:43,900
started to push the envelope even

176
00:08:43,900 --> 00:08:47,980
further necessitating another round of

177
00:08:47,980 --> 00:08:50,050
performance improvements on the engine

178
00:08:50,050 --> 00:08:54,010
side and so forth also not surprisingly

179
00:08:54,010 --> 00:08:55,220
we've also seen

180
00:08:55,220 --> 00:08:58,279
lively rivalry between the major players

181
00:08:58,279 --> 00:09:01,540
as they compete to offer the most

182
00:09:01,540 --> 00:09:07,129
responsive browser experience so now

183
00:09:07,129 --> 00:09:09,290
let's start to drill down a bit into

184
00:09:09,290 --> 00:09:11,899
what makes it challenging to execute

185
00:09:11,899 --> 00:09:14,560
JavaScript with decent performance

186
00:09:14,560 --> 00:09:18,620
here's a little example let's say the

187
00:09:18,620 --> 00:09:20,990
browser is executing some JavaScript

188
00:09:20,990 --> 00:09:23,329
code on a web page and the JavaScript

189
00:09:23,329 --> 00:09:25,759
code creates some objects that have

190
00:09:25,759 --> 00:09:29,240
width and height properties and within

191
00:09:29,240 --> 00:09:31,459
the JavaScript code there's a function

192
00:09:31,459 --> 00:09:33,529
written just like this one here totaled

193
00:09:33,529 --> 00:09:35,870
with that's just supposed to calculate

194
00:09:35,870 --> 00:09:38,000
the total width when it's given two

195
00:09:38,000 --> 00:09:41,389
objects now when the engine goes to

196
00:09:41,389 --> 00:09:43,550
execute this function it's clear what

197
00:09:43,550 --> 00:09:44,990
it's supposed to do right it should

198
00:09:44,990 --> 00:09:47,089
retrieve the width property from the

199
00:09:47,089 --> 00:09:49,639
object specified in parameter a and then

200
00:09:49,639 --> 00:09:51,529
it should retrieve the width property of

201
00:09:51,529 --> 00:09:53,810
the object specified by a parameter B

202
00:09:53,810 --> 00:09:55,550
and add the two numbers together and

203
00:09:55,550 --> 00:09:58,790
return the result it's pretty easy and

204
00:09:58,790 --> 00:10:01,220
it's clear that if we hope to get any

205
00:10:01,220 --> 00:10:03,589
kind of decent performance out of our

206
00:10:03,589 --> 00:10:06,559
JavaScript execution the engine had

207
00:10:06,559 --> 00:10:08,660
better be able to execute this simple

208
00:10:08,660 --> 00:10:12,790
function very quickly and efficiently

209
00:10:12,879 --> 00:10:16,639
shown here is what we'd like to achieve

210
00:10:16,639 --> 00:10:20,600
in an ideal sense this is how total

211
00:10:20,600 --> 00:10:23,779
width could theoretically be compiled -

212
00:10:23,779 --> 00:10:26,990
made of x64 machine code ideally the

213
00:10:26,990 --> 00:10:28,490
total width function would be

214
00:10:28,490 --> 00:10:30,769
implemented in just a few machine

215
00:10:30,769 --> 00:10:32,870
instructions the idea is that the

216
00:10:32,870 --> 00:10:35,779
compiler would know where the width

217
00:10:35,779 --> 00:10:39,170
property is located within the objects

218
00:10:39,170 --> 00:10:40,550
of the type we're dealing with here

219
00:10:40,550 --> 00:10:42,189
let's say that the width property

220
00:10:42,189 --> 00:10:45,379
appears in memory at 8 bytes from the

221
00:10:45,379 --> 00:10:48,620
start of each object so all the compiled

222
00:10:48,620 --> 00:10:51,680
code needs to do is to retrieve a

223
00:10:51,680 --> 00:10:55,370
numeric value from offset 8 within each

224
00:10:55,370 --> 00:10:58,639
object a and B and the two numbers

225
00:10:58,639 --> 00:11:01,670
together check for overflow and return

226
00:11:01,670 --> 00:11:05,509
so is this possible is it possible for a

227
00:11:05,509 --> 00:11:07,910
javascript compiler to just go ahead and

228
00:11:07,910 --> 00:11:08,600
compile

229
00:11:08,600 --> 00:11:11,630
the total width function in this way and

230
00:11:11,630 --> 00:11:14,029
the answer is no the main thing that

231
00:11:14,029 --> 00:11:17,149
gets in a way is that by looking at this

232
00:11:17,149 --> 00:11:20,120
function total with the compiler cannot

233
00:11:20,120 --> 00:11:25,069
see or infer any type information so is

234
00:11:25,069 --> 00:11:27,170
it possible for the compiler to know

235
00:11:27,170 --> 00:11:29,480
that this width property is going to be

236
00:11:29,480 --> 00:11:32,209
located at a particular offset like 8

237
00:11:32,209 --> 00:11:36,019
from the start of object a or B no

238
00:11:36,019 --> 00:11:39,050
because the compiler is stuck with not

239
00:11:39,050 --> 00:11:40,819
having any knowledge about the type of

240
00:11:40,819 --> 00:11:44,089
object a or object B or what those

241
00:11:44,089 --> 00:11:49,250
memory layouts might be so the compiled

242
00:11:49,250 --> 00:11:52,190
code will first have to go to some

243
00:11:52,190 --> 00:11:55,940
lengths to search for and obtain the

244
00:11:55,940 --> 00:11:59,540
width of property of a and of B it's not

245
00:11:59,540 --> 00:12:02,329
at all as simple as looking up something

246
00:12:02,329 --> 00:12:06,560
at a well-known offset after

247
00:12:06,560 --> 00:12:09,170
successfully obtaining the value of the

248
00:12:09,170 --> 00:12:12,319
width properties another issue comes up

249
00:12:12,319 --> 00:12:14,930
which is that there's no guarantee that

250
00:12:14,930 --> 00:12:17,420
the value of the width properties are in

251
00:12:17,420 --> 00:12:19,459
fact numbers that's not something the

252
00:12:19,459 --> 00:12:23,630
compiler can just assume and if they're

253
00:12:23,630 --> 00:12:26,839
not both numbers then plenty more logic

254
00:12:26,839 --> 00:12:28,910
is going to be needed in order to

255
00:12:28,910 --> 00:12:32,649
implement Java scripts extremely complex

256
00:12:32,649 --> 00:12:36,500
rules for applying the plus operator to

257
00:12:36,500 --> 00:12:40,459
operands of various types all of this

258
00:12:40,459 --> 00:12:43,040
trouble fundamentally stems from the

259
00:12:43,040 --> 00:12:46,579
loosely typed nature of JavaScript which

260
00:12:46,579 --> 00:12:50,029
leaves any compiler with very few hard

261
00:12:50,029 --> 00:12:54,139
facts to work with so the final answer

262
00:12:54,139 --> 00:12:58,339
is no total width can't be compiled in

263
00:12:58,339 --> 00:13:01,189
such a simple way instead it's going to

264
00:13:01,189 --> 00:13:04,370
take far more effort to implement total

265
00:13:04,370 --> 00:13:07,639
width and that is very bad news because

266
00:13:07,639 --> 00:13:09,560
if we can't execute something as simple

267
00:13:09,560 --> 00:13:12,620
as total width in a small efficient

268
00:13:12,620 --> 00:13:14,720
manner then the engine is going to have

269
00:13:14,720 --> 00:13:16,459
a major problem getting decent

270
00:13:16,459 --> 00:13:19,069
performance when running any JavaScript

271
00:13:19,069 --> 00:13:22,670
programs of realistic complexity

272
00:13:22,670 --> 00:13:24,900
so we are still left with this

273
00:13:24,900 --> 00:13:27,630
fundamental problem how is it possible

274
00:13:27,630 --> 00:13:32,060
to execute JavaScript at high speed an

275
00:13:32,060 --> 00:13:34,650
interpreter won't work because it's far

276
00:13:34,650 --> 00:13:37,560
too slow but as we explore it on the

277
00:13:37,560 --> 00:13:40,620
previous slide a compiler is not going

278
00:13:40,620 --> 00:13:43,410
to solve our problems either because the

279
00:13:43,410 --> 00:13:46,410
lack of type information will hamstring

280
00:13:46,410 --> 00:13:48,690
the compilers ability to generate

281
00:13:48,690 --> 00:13:52,290
efficient code there's also a second

282
00:13:52,290 --> 00:13:54,420
problem with using a compiler which is

283
00:13:54,420 --> 00:13:57,030
that the compliation process itself

284
00:13:57,030 --> 00:14:00,240
takes a lot of CPU cycles and that would

285
00:14:00,240 --> 00:14:06,090
make webpages load far too slowly the

286
00:14:06,090 --> 00:14:08,400
solution used by all of the major

287
00:14:08,400 --> 00:14:12,420
engines is multi-stage execution and

288
00:14:12,420 --> 00:14:14,300
here's how it works

289
00:14:14,300 --> 00:14:17,340
when loading new JavaScript code to

290
00:14:17,340 --> 00:14:20,040
execute the engine first starts by

291
00:14:20,040 --> 00:14:22,290
executing it within a and interpreter

292
00:14:22,290 --> 00:14:25,350
and this allows JavaScript execution to

293
00:14:25,350 --> 00:14:27,720
begin as promptly as possible so

294
00:14:27,720 --> 00:14:31,710
webpages can load fast the interpreter

295
00:14:31,710 --> 00:14:34,200
has a second job while it's executing

296
00:14:34,200 --> 00:14:38,400
code it collects one-time type

297
00:14:38,400 --> 00:14:40,980
information about the values found in

298
00:14:40,980 --> 00:14:45,620
variables and this is known as profiling

299
00:14:45,620 --> 00:14:48,780
eventually those areas of the JavaScript

300
00:14:48,780 --> 00:14:51,510
code that are running hot such as loop

301
00:14:51,510 --> 00:14:53,820
bodies or functions that are called many

302
00:14:53,820 --> 00:14:57,870
times those are sent for just-in-time or

303
00:14:57,870 --> 00:15:02,010
JIT compilation and by this time enough

304
00:15:02,010 --> 00:15:04,920
type information has been collected so

305
00:15:04,920 --> 00:15:06,690
that the compiler can make some

306
00:15:06,690 --> 00:15:09,150
optimistic assumptions about the types

307
00:15:09,150 --> 00:15:11,970
that it will encounter and on this basis

308
00:15:11,970 --> 00:15:14,400
the JIT compiler can emit code that is

309
00:15:14,400 --> 00:15:17,840
really quite highly optimized

310
00:15:17,840 --> 00:15:20,610
incidentally some engines expand this

311
00:15:20,610 --> 00:15:23,880
paradigm to include multiple stages of

312
00:15:23,880 --> 00:15:26,760
JIT compilation the interpreter and the

313
00:15:26,760 --> 00:15:29,850
earlier JIT stages have faster startup

314
00:15:29,850 --> 00:15:33,570
times but executes less efficiently the

315
00:15:33,570 --> 00:15:35,490
later JIT stages have taken

316
00:15:35,490 --> 00:15:37,649
longer to startup but final execution

317
00:15:37,649 --> 00:15:43,350
has better efficiency now as we just

318
00:15:43,350 --> 00:15:45,990
said the JIT compiler is able to emit

319
00:15:45,990 --> 00:15:48,959
efficient compile code because it

320
00:15:48,959 --> 00:15:51,060
optimistically relies on certain

321
00:15:51,060 --> 00:15:53,310
assumptions about the types of variables

322
00:15:53,310 --> 00:15:55,470
in accordance with the profiling data

323
00:15:55,470 --> 00:15:58,430
that was gathered but these are only

324
00:15:58,430 --> 00:16:01,860
assumptions not guarantees since

325
00:16:01,860 --> 00:16:04,110
javascript has known strict type

326
00:16:04,110 --> 00:16:06,690
guarantees any assumptions about type

327
00:16:06,690 --> 00:16:10,529
could fail at any time so the JIT

328
00:16:10,529 --> 00:16:13,649
compiled code still needs to contain

329
00:16:13,649 --> 00:16:17,130
type checks at strategic locations to

330
00:16:17,130 --> 00:16:18,959
make sure that its assumptions are still

331
00:16:18,959 --> 00:16:21,510
valid and if it finds that some

332
00:16:21,510 --> 00:16:25,050
assumption no longer holds true then the

333
00:16:25,050 --> 00:16:27,300
JIT compiled code needs to stop

334
00:16:27,300 --> 00:16:30,089
executing and immediately fall back to

335
00:16:30,089 --> 00:16:33,600
the interpreter in midstream chromium's

336
00:16:33,600 --> 00:16:36,360
v8 JavaScript engine calls this D

337
00:16:36,360 --> 00:16:38,160
optimization and we'll use that

338
00:16:38,160 --> 00:16:42,120
terminology so this adds an enormous

339
00:16:42,120 --> 00:16:45,089
amount of complexity both in the type

340
00:16:45,089 --> 00:16:48,060
checking logic and in the infrastructure

341
00:16:48,060 --> 00:16:50,490
needed to make it possible to switch

342
00:16:50,490 --> 00:16:53,459
from compiled code back into the

343
00:16:53,459 --> 00:16:55,680
interpreter in the middle of executing a

344
00:16:55,680 --> 00:17:00,959
function but that's not all not only our

345
00:17:00,959 --> 00:17:03,300
JavaScript engines algorithmically

346
00:17:03,300 --> 00:17:06,059
complex as we have just described but

347
00:17:06,059 --> 00:17:08,280
the data structures that they use are

348
00:17:08,280 --> 00:17:12,390
complex as well for example when storing

349
00:17:12,390 --> 00:17:15,630
a JavaScript array the data structure

350
00:17:15,630 --> 00:17:18,569
must be able to efficiently represent

351
00:17:18,569 --> 00:17:22,470
both sparse and dense arrays a sparse

352
00:17:22,470 --> 00:17:25,619
array is an array that contains values

353
00:17:25,619 --> 00:17:28,470
at various indexes with gaps in between

354
00:17:28,470 --> 00:17:32,400
the indexes where values are defined as

355
00:17:32,400 --> 00:17:34,230
opposed to a dense array which is the

356
00:17:34,230 --> 00:17:36,870
more traditional sort of an array where

357
00:17:36,870 --> 00:17:39,210
there is a single continuous range of

358
00:17:39,210 --> 00:17:43,679
indexes where values are defined and if

359
00:17:43,679 --> 00:17:47,160
the array contains all integers or all

360
00:17:47,160 --> 00:17:48,900
floating-point numerics

361
00:17:48,900 --> 00:17:51,210
those are very important special cases

362
00:17:51,210 --> 00:17:54,560
that have to be optimized for it

363
00:17:54,560 --> 00:17:58,020
furthermore javascript allows arrays to

364
00:17:58,020 --> 00:18:01,440
define get and set methods on specific

365
00:18:01,440 --> 00:18:04,320
indexes meaning that custom javascript

366
00:18:04,320 --> 00:18:06,060
methods will be invoked when those

367
00:18:06,060 --> 00:18:08,640
particular array indexes are accessed

368
00:18:08,640 --> 00:18:13,290
and all javascript objects including

369
00:18:13,290 --> 00:18:15,840
arrays are allowed to have any

370
00:18:15,840 --> 00:18:19,890
combination of names and numeric indexed

371
00:18:19,890 --> 00:18:23,540
properties each of these combinations

372
00:18:23,540 --> 00:18:26,940
calls for certain optimizations in the

373
00:18:26,940 --> 00:18:30,990
way objects are laid out in memory but

374
00:18:30,990 --> 00:18:32,940
what makes things really dangerous is

375
00:18:32,940 --> 00:18:34,860
that all of the above

376
00:18:34,860 --> 00:18:37,380
object characteristics can change at any

377
00:18:37,380 --> 00:18:39,990
time during execution and this may

378
00:18:39,990 --> 00:18:42,900
require in-place modifications to the

379
00:18:42,900 --> 00:18:46,020
objects met memory layout clearly

380
00:18:46,020 --> 00:18:48,270
there's a lot of room for things to go

381
00:18:48,270 --> 00:18:50,840
wrong very wrong

382
00:18:50,840 --> 00:18:55,290
in fact array operations are one of the

383
00:18:55,290 --> 00:18:57,150
very most perilous areas within

384
00:18:57,150 --> 00:19:00,090
JavaScript app implementation so here

385
00:19:00,090 --> 00:19:01,860
we're going to do a brief drill down

386
00:19:01,860 --> 00:19:05,010
into some of the specifics of how array

387
00:19:05,010 --> 00:19:07,800
elements are stored in memory please

388
00:19:07,800 --> 00:19:09,360
note that some of these details are

389
00:19:09,360 --> 00:19:12,570
specific to the way microsoft's chakra

390
00:19:12,570 --> 00:19:15,480
javascript engine operates although the

391
00:19:15,480 --> 00:19:17,040
theory carries over in a pretty

392
00:19:17,040 --> 00:19:19,020
straightforward way to google's v8

393
00:19:19,020 --> 00:19:22,980
engine as well if you create a

394
00:19:22,980 --> 00:19:25,400
JavaScript array containing only

395
00:19:25,400 --> 00:19:28,080
floating-point values that's an

396
00:19:28,080 --> 00:19:31,500
important special case so the engine

397
00:19:31,500 --> 00:19:34,860
will represent it in memory as a native

398
00:19:34,860 --> 00:19:37,320
float array this means that the

399
00:19:37,320 --> 00:19:39,900
JavaScript engine will allocate a

400
00:19:39,900 --> 00:19:42,780
continuous block of memory and pack it

401
00:19:42,780 --> 00:19:45,600
full of Vote floating point array values

402
00:19:45,600 --> 00:19:48,570
each stored in native form by which we

403
00:19:48,570 --> 00:19:51,420
mean the natural and the hence the most

404
00:19:51,420 --> 00:19:54,210
efficient form for the machine or

405
00:19:54,210 --> 00:19:57,000
architecture that you're running on ok

406
00:19:57,000 --> 00:19:59,460
so now let's say you take that array and

407
00:19:59,460 --> 00:20:02,700
now you place a new value into the

408
00:20:02,700 --> 00:20:05,460
ray that's not a numeric let's say it's

409
00:20:05,460 --> 00:20:06,920
a JavaScript object

410
00:20:06,920 --> 00:20:09,900
now the array can't be stored as a

411
00:20:09,900 --> 00:20:13,560
native float array anymore so the engine

412
00:20:13,560 --> 00:20:16,020
will do an in-place conversion of the

413
00:20:16,020 --> 00:20:20,430
array into a general array type general

414
00:20:20,430 --> 00:20:22,800
arrays allow for storage of elements

415
00:20:22,800 --> 00:20:25,830
that can be of any JavaScript type which

416
00:20:25,830 --> 00:20:29,550
includes objects the storage for each

417
00:20:29,550 --> 00:20:31,680
element in memory must be able to

418
00:20:31,680 --> 00:20:35,310
represent either a numeric or a pointer

419
00:20:35,310 --> 00:20:38,040
to a JavaScript object in memory now the

420
00:20:38,040 --> 00:20:40,710
float elements can't be stored so simply

421
00:20:40,710 --> 00:20:43,700
as before because the data in memory

422
00:20:43,700 --> 00:20:46,800
backing each element must also contain

423
00:20:46,800 --> 00:20:49,800
some additional information indicating

424
00:20:49,800 --> 00:20:51,690
whether the value is supposed to be

425
00:20:51,690 --> 00:20:55,380
understood as a numeric or as a pointer

426
00:20:55,380 --> 00:20:58,980
to an object this should all become much

427
00:20:58,980 --> 00:21:02,190
clearer with an example suppose we

428
00:21:02,190 --> 00:21:05,580
create an array a and into this array we

429
00:21:05,580 --> 00:21:08,930
put two floating point values and two

430
00:21:08,930 --> 00:21:12,930
JavaScript objects since this array does

431
00:21:12,930 --> 00:21:16,470
not contain exclusively numerix the

432
00:21:16,470 --> 00:21:19,050
engine cannot store it as simply as a

433
00:21:19,050 --> 00:21:21,590
block of floating point values in memory

434
00:21:21,590 --> 00:21:24,540
instead each element in memory must be

435
00:21:24,540 --> 00:21:27,240
capable of representing either a numeric

436
00:21:27,240 --> 00:21:30,480
or a pointer to an object and this is

437
00:21:30,480 --> 00:21:32,730
what we call a general array as opposed

438
00:21:32,730 --> 00:21:35,370
to a native array as you can see in the

439
00:21:35,370 --> 00:21:37,650
illustration where there are indexes

440
00:21:37,650 --> 00:21:41,850
that point to a javascript object as in

441
00:21:41,850 --> 00:21:46,470
to the last two indexes there then the

442
00:21:46,470 --> 00:21:49,620
storage for array a simply contains the

443
00:21:49,620 --> 00:21:54,330
pointers to those objects but for the

444
00:21:54,330 --> 00:21:56,640
first two indexes we need to store the

445
00:21:56,640 --> 00:22:00,390
floating point values 1.1 and 2.2

446
00:22:00,390 --> 00:22:04,560
respectively for these the engine takes

447
00:22:04,560 --> 00:22:07,200
each floating-point value to be stored

448
00:22:07,200 --> 00:22:11,100
and it encodes it in a special form that

449
00:22:11,100 --> 00:22:13,920
is clearly not valid to interpret as a

450
00:22:13,920 --> 00:22:16,530
pointer and those are the in Val

451
00:22:16,530 --> 00:22:19,140
Poynter values that you see in the first

452
00:22:19,140 --> 00:22:23,670
two elements when reading values out of

453
00:22:23,670 --> 00:22:26,160
this array the engine can reverse the

454
00:22:26,160 --> 00:22:29,610
process after reading an item out of the

455
00:22:29,610 --> 00:22:33,360
arrays memory it will check whether the

456
00:22:33,360 --> 00:22:36,420
value is valid to interpret as a pointer

457
00:22:36,420 --> 00:22:39,000
if so it knows that the value is

458
00:22:39,000 --> 00:22:41,640
intended as a pointer to an object if

459
00:22:41,640 --> 00:22:44,520
not it knows that the value is an

460
00:22:44,520 --> 00:22:47,850
encoded numeric and it will then reverse

461
00:22:47,850 --> 00:22:50,280
the encoding to reveal the original

462
00:22:50,280 --> 00:22:53,670
numeric value we're going to need to

463
00:22:53,670 --> 00:22:56,520
refer to this detail later on so please

464
00:22:56,520 --> 00:22:58,980
keep this point in mind when reading

465
00:22:58,980 --> 00:23:01,620
data out of the memory of a general

466
00:23:01,620 --> 00:23:05,640
array the engine tests the data to see

467
00:23:05,640 --> 00:23:08,130
whether or not it is a valid pointer and

468
00:23:08,130 --> 00:23:10,230
it does this to figure out whether the

469
00:23:10,230 --> 00:23:12,870
data is supposed to be understood as a

470
00:23:12,870 --> 00:23:17,190
pointer to an object or two as a numeric

471
00:23:17,190 --> 00:23:24,870
in encoded form one final technical note

472
00:23:24,870 --> 00:23:27,620
on how JavaScript arrays are stored a

473
00:23:27,620 --> 00:23:31,110
JavaScript array will not always be

474
00:23:31,110 --> 00:23:34,290
represented in memory using a single

475
00:23:34,290 --> 00:23:36,900
monolithic buffer for the sake of

476
00:23:36,900 --> 00:23:39,660
efficient storage of highly sparse

477
00:23:39,660 --> 00:23:43,470
arrays the engine also must support an

478
00:23:43,470 --> 00:23:46,980
alternative storage format for this v8

479
00:23:46,980 --> 00:23:50,190
uses a hash table structure but in

480
00:23:50,190 --> 00:23:52,800
microsoft's sakura javascript engine an

481
00:23:52,800 --> 00:23:56,310
array can be split among several buffers

482
00:23:56,310 --> 00:23:59,580
each representing a different range of

483
00:23:59,580 --> 00:24:03,450
indexes furthermore the first buffer of

484
00:24:03,450 --> 00:24:06,330
the array might be stored in line

485
00:24:06,330 --> 00:24:08,580
meaning that it appears in memory

486
00:24:08,580 --> 00:24:11,430
immediately following the array metadata

487
00:24:11,430 --> 00:24:14,220
together with it as a single allocation

488
00:24:14,220 --> 00:24:17,690
again for performance and there are also

489
00:24:17,690 --> 00:24:20,480
metadata structures to help an array

490
00:24:20,480 --> 00:24:23,460
locate all of its buffers efficiently

491
00:24:23,460 --> 00:24:26,310
the bottom line is internal storage of

492
00:24:26,310 --> 00:24:29,080
JavaScript arrays is not a simple

493
00:24:29,080 --> 00:24:32,620
at all and as I mentioned previously all

494
00:24:32,620 --> 00:24:34,690
of these details of internal

495
00:24:34,690 --> 00:24:38,230
representations are subject to in-place

496
00:24:38,230 --> 00:24:41,770
conversion during script execution these

497
00:24:41,770 --> 00:24:43,690
are some of the considerations that make

498
00:24:43,690 --> 00:24:46,750
JavaScript array handling prone to

499
00:24:46,750 --> 00:24:51,370
mishap it can be summed up in the truism

500
00:24:51,370 --> 00:24:54,130
that complexity is the enemy of security

501
00:24:54,130 --> 00:24:57,130
everything we've discussed so far can be

502
00:24:57,130 --> 00:24:59,710
described as an incredible overhead of

503
00:24:59,710 --> 00:25:03,280
complexity all introduced in order to

504
00:25:03,280 --> 00:25:06,130
fill the nearly impossible tall order of

505
00:25:06,130 --> 00:25:09,310
boosting JavaScript performance to the

506
00:25:09,310 --> 00:25:14,080
levels demanded today finally I'm going

507
00:25:14,080 --> 00:25:16,420
to round out my remarks on what makes

508
00:25:16,420 --> 00:25:19,030
JavaScript challenging to implement by

509
00:25:19,030 --> 00:25:20,920
pointing out that JavaScript has a ton

510
00:25:20,920 --> 00:25:23,230
of features that can interact in

511
00:25:23,230 --> 00:25:25,780
unexpected ways to create potentially

512
00:25:25,780 --> 00:25:27,970
hazardous conditions I'm just going to

513
00:25:27,970 --> 00:25:30,160
quickly mention some of these property

514
00:25:30,160 --> 00:25:33,070
get set methods prototype chains custom

515
00:25:33,070 --> 00:25:35,710
coercion functions species constructors

516
00:25:35,710 --> 00:25:38,320
proxy objects dynamic scopes created

517
00:25:38,320 --> 00:25:40,660
with eval or through iframes the

518
00:25:40,660 --> 00:25:42,700
abilities for script to redefine

519
00:25:42,700 --> 00:25:45,520
built-in functions the list goes on for

520
00:25:45,520 --> 00:25:47,560
a while and there are a lot of

521
00:25:47,560 --> 00:25:54,040
opportunities here for abuse after that

522
00:25:54,040 --> 00:25:56,170
introduction we're going to start

523
00:25:56,170 --> 00:25:59,020
looking at some actual classes of

524
00:25:59,020 --> 00:26:00,760
vulnerabilities that come up and see

525
00:26:00,760 --> 00:26:05,800
exactly what it is that goes wrong so to

526
00:26:05,800 --> 00:26:07,810
start with it's a bit scary to say but

527
00:26:07,810 --> 00:26:10,180
even the implementation of the built-in

528
00:26:10,180 --> 00:26:13,390
JavaScript library methods has seen

529
00:26:13,390 --> 00:26:15,490
significant numbers of bugs and this is

530
00:26:15,490 --> 00:26:17,830
going to be the first category we'll

531
00:26:17,830 --> 00:26:21,370
examine where you really see this is in

532
00:26:21,370 --> 00:26:23,760
the array handling routines

533
00:26:23,760 --> 00:26:26,770
interestingly array dot splice has

534
00:26:26,770 --> 00:26:28,570
proven itself to be particularly

535
00:26:28,570 --> 00:26:31,540
difficult to get right and we've already

536
00:26:31,540 --> 00:26:33,430
discussed quite a bit about what makes

537
00:26:33,430 --> 00:26:37,540
array representation tricky so what goes

538
00:26:37,540 --> 00:26:40,690
wrong in the array methods often it's

539
00:26:40,690 --> 00:26:42,190
because an attacker

540
00:26:42,190 --> 00:26:44,649
can get script execution to happen in

541
00:26:44,649 --> 00:26:48,909
the middle of a library routine and some

542
00:26:48,909 --> 00:26:51,700
ways of doing this include defining get

543
00:26:51,700 --> 00:26:53,679
set methods that will execute when a

544
00:26:53,679 --> 00:26:56,409
particular index is accessed or by

545
00:26:56,409 --> 00:26:58,809
defining a custom species constructor or

546
00:26:58,809 --> 00:27:00,669
something else that will be called

547
00:27:00,669 --> 00:27:03,009
during the operation like is concat

548
00:27:03,009 --> 00:27:08,679
spreadable if an attacker can get script

549
00:27:08,679 --> 00:27:10,990
execution in the middle of a library

550
00:27:10,990 --> 00:27:13,299
routine they might be able to use that

551
00:27:13,299 --> 00:27:16,029
to violate the assumptions of the

552
00:27:16,029 --> 00:27:18,690
routine in progress and this might mean

553
00:27:18,690 --> 00:27:22,029
changing the arrays size or type or

554
00:27:22,029 --> 00:27:25,179
otherwise modifying some parts of the

555
00:27:25,179 --> 00:27:27,730
internal representation of the array

556
00:27:27,730 --> 00:27:31,149
that the library routine is assuming to

557
00:27:31,149 --> 00:27:36,639
be immutable during the operation this

558
00:27:36,639 --> 00:27:40,450
bug here is a great example of problem

559
00:27:40,450 --> 00:27:43,200
in array handling in the JavaScript

560
00:27:43,200 --> 00:27:46,179
chakra JavaScript runtime and this one

561
00:27:46,179 --> 00:27:49,299
wound up being ultra critical I love

562
00:27:49,299 --> 00:27:51,039
this one if you take a look at the

563
00:27:51,039 --> 00:27:54,759
bottommost red rectangle there dot dot

564
00:27:54,759 --> 00:27:56,620
dot is actually part of the source code

565
00:27:56,620 --> 00:27:58,870
it's called the spread operator and that

566
00:27:58,870 --> 00:28:03,549
turns array X into an argument list for

567
00:28:03,549 --> 00:28:07,179
function f and when this line of code

568
00:28:07,179 --> 00:28:10,480
executes the runtime will iterate over

569
00:28:10,480 --> 00:28:13,960
array X to read its elements and copy

570
00:28:13,960 --> 00:28:17,950
them into a stack based buffer but as

571
00:28:17,950 --> 00:28:21,549
you see at the top the attacker has

572
00:28:21,549 --> 00:28:24,580
defined a get method for index 1

573
00:28:24,580 --> 00:28:27,730
so when index 1 gets read that script at

574
00:28:27,730 --> 00:28:30,519
the top runs and when that runs it

575
00:28:30,519 --> 00:28:33,730
changes the length of the array making

576
00:28:33,730 --> 00:28:37,509
it either larger or smaller by shrinking

577
00:28:37,509 --> 00:28:40,840
the array in mid iteration part of the

578
00:28:40,840 --> 00:28:43,080
stack based buffer will get left

579
00:28:43,080 --> 00:28:45,220
uninitialized which gives you an

580
00:28:45,220 --> 00:28:48,490
information leak or by enlarging the

581
00:28:48,490 --> 00:28:50,950
array you can get a buffer overflow in

582
00:28:50,950 --> 00:28:54,700
fact it can overwrite a local pointer

583
00:28:54,700 --> 00:28:55,480
variable on

584
00:28:55,480 --> 00:28:58,450
stack and yield a very nice right what

585
00:28:58,450 --> 00:29:01,600
we're primitive so with this one bug you

586
00:29:01,600 --> 00:29:05,280
easily compromise the whole process

587
00:29:07,650 --> 00:29:09,490
where things get really interesting

588
00:29:09,490 --> 00:29:12,660
though is in the JIT compiler

589
00:29:12,660 --> 00:29:15,010
specifically what's often found is that

590
00:29:15,010 --> 00:29:17,890
the JIT compiler emits code that fails

591
00:29:17,890 --> 00:29:22,020
to account for all possibilities

592
00:29:22,020 --> 00:29:25,500
recall that the JIT compiler writes

593
00:29:25,500 --> 00:29:27,700
high-performance code based on

594
00:29:27,700 --> 00:29:29,860
assumptions about the types of data that

595
00:29:29,860 --> 00:29:32,380
will be founded variables the compiled

596
00:29:32,380 --> 00:29:35,110
code needs to perform type checks to

597
00:29:35,110 --> 00:29:38,140
validate those assumptions violation of

598
00:29:38,140 --> 00:29:40,180
an assumption may require fallback to

599
00:29:40,180 --> 00:29:42,400
the interpreter known as the

600
00:29:42,400 --> 00:29:46,270
optimization if it performs too many

601
00:29:46,270 --> 00:29:49,270
type checks then performance suffers

602
00:29:49,270 --> 00:29:52,030
which defeats the purpose of the

603
00:29:52,030 --> 00:29:56,350
compliation so the compiler contains a

604
00:29:56,350 --> 00:29:59,800
lot of logic around determining exactly

605
00:29:59,800 --> 00:30:02,830
when type checks are needed and it's a

606
00:30:02,830 --> 00:30:03,700
tightrope

607
00:30:03,700 --> 00:30:07,300
if the JIT compiler makes one subtle

608
00:30:07,300 --> 00:30:10,510
logic error and leaves out a necessary

609
00:30:10,510 --> 00:30:13,150
type check it's typically catastrophic

610
00:30:13,150 --> 00:30:17,110
and I'm oversimplifying a bit here when

611
00:30:17,110 --> 00:30:19,540
I speak about type checks more generally

612
00:30:19,540 --> 00:30:21,370
we should really speak of state checks

613
00:30:21,370 --> 00:30:24,130
type being one specific example of state

614
00:30:24,130 --> 00:30:27,100
and other forms of state include whether

615
00:30:27,100 --> 00:30:30,220
an array length has changed or if the

616
00:30:30,220 --> 00:30:32,860
array has changed in internal

617
00:30:32,860 --> 00:30:35,530
representation such as from dense to

618
00:30:35,530 --> 00:30:37,900
sparse or whether the in-memory

619
00:30:37,900 --> 00:30:40,290
representation of any object has been

620
00:30:40,290 --> 00:30:46,690
converted to a less optimized form array

621
00:30:46,690 --> 00:30:49,750
type checks are a frequent source of

622
00:30:49,750 --> 00:30:53,020
trouble whenever the engine manipulates

623
00:30:53,020 --> 00:30:55,420
memory that stores array elements it

624
00:30:55,420 --> 00:30:57,430
first has to know the correct array type

625
00:30:57,430 --> 00:31:00,160
meaning whether the array is a native

626
00:31:00,160 --> 00:31:03,700
array or a general array and also

627
00:31:03,700 --> 00:31:05,680
whether it is stored in a form capable

628
00:31:05,680 --> 00:31:08,200
of representing gaps for missing

629
00:31:08,200 --> 00:31:08,860
elements

630
00:31:08,860 --> 00:31:12,850
and so forth let's say we want to trick

631
00:31:12,850 --> 00:31:16,059
the JIT compiler into leaving out a

632
00:31:16,059 --> 00:31:18,910
check on the type of an array how could

633
00:31:18,910 --> 00:31:20,220
we go about doing that

634
00:31:20,220 --> 00:31:23,470
well we're gonna have to figure out how

635
00:31:23,470 --> 00:31:26,080
to write some gimmick that the compiler

636
00:31:26,080 --> 00:31:29,620
will think is harmless while it really

637
00:31:29,620 --> 00:31:32,679
changes the type of the array because

638
00:31:32,679 --> 00:31:34,929
the compiler thinks that the gimmick

639
00:31:34,929 --> 00:31:36,730
cannot change the type of the array

640
00:31:36,730 --> 00:31:40,120
it won't insert a second type check

641
00:31:40,120 --> 00:31:43,380
before that second array access shown

642
00:31:43,380 --> 00:31:46,210
for the sake of performance it will

643
00:31:46,210 --> 00:31:49,210
relay it will rely on the type check

644
00:31:49,210 --> 00:31:51,460
that it performed at the first array

645
00:31:51,460 --> 00:31:57,220
access let's see what could happen in

646
00:31:57,220 --> 00:32:00,730
this case as you can see here originally

647
00:32:00,730 --> 00:32:04,419
array a is a native array because it

648
00:32:04,419 --> 00:32:07,809
contains exclusively numerix so its

649
00:32:07,809 --> 00:32:10,179
contents are written in memory as just a

650
00:32:10,179 --> 00:32:11,919
sequence of floating-point values

651
00:32:11,919 --> 00:32:15,870
written in the standard native format

652
00:32:15,870 --> 00:32:19,750
suppose that our gimmick over writes the

653
00:32:19,750 --> 00:32:24,880
last array index with a with an object

654
00:32:24,880 --> 00:32:28,030
then the engine is going to convert the

655
00:32:28,030 --> 00:32:31,900
entire array in place into a general

656
00:32:31,900 --> 00:32:34,330
array form recall that in a general

657
00:32:34,330 --> 00:32:37,510
array if there are some numeric values

658
00:32:37,510 --> 00:32:39,610
they are stored in a special encoded

659
00:32:39,610 --> 00:32:42,010
form that distinguishes them from

660
00:32:42,010 --> 00:32:44,410
pointers and what you see there on the

661
00:32:44,410 --> 00:32:46,990
right-hand side of this slide is what

662
00:32:46,990 --> 00:32:49,419
the array looks like in memory after the

663
00:32:49,419 --> 00:32:54,970
in-place conversion takes place now

664
00:32:54,970 --> 00:32:57,580
consider what happens if the JIT

665
00:32:57,580 --> 00:33:00,220
compiler fails to realize that our

666
00:33:00,220 --> 00:33:03,730
gimmick may have changed the array from

667
00:33:03,730 --> 00:33:06,370
a native array to a general right when

668
00:33:06,370 --> 00:33:09,520
the last line of JavaScript showed the

669
00:33:09,520 --> 00:33:12,840
last line of JavaScript code shown here

670
00:33:12,840 --> 00:33:17,080
executes the JIT optimized code thinks

671
00:33:17,080 --> 00:33:19,809
that the array is still in native form

672
00:33:19,809 --> 00:33:22,300
so it thinks that in order to store the

673
00:33:22,300 --> 00:33:22,630
value

674
00:33:22,630 --> 00:33:26,370
4.4 it simply needs to write a native

675
00:33:26,370 --> 00:33:34,240
4.4 into the arrays memory like so but

676
00:33:34,240 --> 00:33:38,100
this is very wrong because a native

677
00:33:38,100 --> 00:33:41,470
unencoded floating-point value should

678
00:33:41,470 --> 00:33:44,220
never get written into a general array

679
00:33:44,220 --> 00:33:47,380
in fact this is already a critical

680
00:33:47,380 --> 00:33:51,490
vulnerability why because later one when

681
00:33:51,490 --> 00:33:54,220
this array element is read at some point

682
00:33:54,220 --> 00:33:56,890
in the future at that point the

683
00:33:56,890 --> 00:33:59,320
JavaScript engine will be in a state

684
00:33:59,320 --> 00:34:02,110
where it correctly identifies the array

685
00:34:02,110 --> 00:34:05,650
as a general type array so when it reads

686
00:34:05,650 --> 00:34:09,030
that native 4.4 it will apply the

687
00:34:09,030 --> 00:34:11,409
invalid pointer test to determine

688
00:34:11,409 --> 00:34:13,210
whether it should be interpreting this

689
00:34:13,210 --> 00:34:17,679
value as a pointer or as especially

690
00:34:17,679 --> 00:34:20,889
encoded numeric and here the attacker

691
00:34:20,889 --> 00:34:24,100
has the upper hand because the attacker

692
00:34:24,100 --> 00:34:26,290
can easily choose this native

693
00:34:26,290 --> 00:34:29,139
floating-point value so that it will be

694
00:34:29,139 --> 00:34:32,679
treated as a valid pointer and this

695
00:34:32,679 --> 00:34:35,620
allows the attacker to forge a pointer

696
00:34:35,620 --> 00:34:42,610
of any desired value but it actually

697
00:34:42,610 --> 00:34:46,719
gets even worse consider this code here

698
00:34:46,719 --> 00:34:50,190
all we've done is to replace the final

699
00:34:50,190 --> 00:34:55,418
line of code with an array read instead

700
00:34:55,418 --> 00:34:57,880
of an array right and in this case we're

701
00:34:57,880 --> 00:35:01,210
reading from the last index here what's

702
00:35:01,210 --> 00:35:02,460
going to happen

703
00:35:02,460 --> 00:35:05,680
since the JIT compiler has failed to

704
00:35:05,680 --> 00:35:08,110
recognize that our gimmick may have

705
00:35:08,110 --> 00:35:10,330
changed the type of the array it

706
00:35:10,330 --> 00:35:12,670
continues with its assumption that the

707
00:35:12,670 --> 00:35:15,310
array is still in native representation

708
00:35:15,310 --> 00:35:18,910
so it implements this final array access

709
00:35:18,910 --> 00:35:22,390
as a simple read of a native float from

710
00:35:22,390 --> 00:35:25,050
memory but what's in memory there now

711
00:35:25,050 --> 00:35:28,000
it's not a float it's a pointer to a

712
00:35:28,000 --> 00:35:30,520
JavaScript object and whatever the

713
00:35:30,520 --> 00:35:33,460
numerical value of that pointer is it's

714
00:35:33,460 --> 00:35:35,890
going to get revealed to the attackers

715
00:35:35,890 --> 00:35:38,440
javascript code in the form of a

716
00:35:38,440 --> 00:35:39,490
floating-point number

717
00:35:39,490 --> 00:35:41,500
and granted this number is going to look

718
00:35:41,500 --> 00:35:43,660
rather garbled to the naked eye but it

719
00:35:43,660 --> 00:35:45,580
only takes a few short lines of

720
00:35:45,580 --> 00:35:49,140
JavaScript to decode it and recover the

721
00:35:49,140 --> 00:35:55,320
exact 64 bit pointer value bit for bit

722
00:35:55,320 --> 00:35:58,570
so we see that with one cunning gimmick

723
00:35:58,570 --> 00:36:02,470
an attacker can both reveal arbitrary

724
00:36:02,470 --> 00:36:05,410
object pointers as well as forge

725
00:36:05,410 --> 00:36:08,110
arbitrary pointers to be injected into

726
00:36:08,110 --> 00:36:11,140
the JavaScript execution these two

727
00:36:11,140 --> 00:36:13,440
capabilities are sufficient to

728
00:36:13,440 --> 00:36:16,150
compromise the security of the entire

729
00:36:16,150 --> 00:36:22,120
process so what can we use for the

730
00:36:22,120 --> 00:36:24,940
gimmick they're having lots of things

731
00:36:24,940 --> 00:36:27,100
that have worked here is one example

732
00:36:27,100 --> 00:36:31,180
it's simplified slightly for clarity the

733
00:36:31,180 --> 00:36:34,230
attacker defines an object evil ang

734
00:36:34,230 --> 00:36:37,570
which is a JavaScript proxy object

735
00:36:37,570 --> 00:36:40,360
having an enumerate trap and that means

736
00:36:40,360 --> 00:36:42,610
that any time that you enumerate over

737
00:36:42,610 --> 00:36:46,200
the properties of this object IVA Lodge

738
00:36:46,200 --> 00:36:49,390
custom script is going to run and this

739
00:36:49,390 --> 00:36:53,200
custom script changes or a a from a

740
00:36:53,200 --> 00:36:56,170
native float array to a general array by

741
00:36:56,170 --> 00:36:58,900
inserting a non float value namely an

742
00:36:58,900 --> 00:37:04,180
object then the gimmick is to run a four

743
00:37:04,180 --> 00:37:08,860
in loop over evil odds and as we have

744
00:37:08,860 --> 00:37:12,790
discussed the JIT compiler fails to

745
00:37:12,790 --> 00:37:15,310
recognize that executing this gimmick in

746
00:37:15,310 --> 00:37:19,390
this case the empty for in loop can have

747
00:37:19,390 --> 00:37:22,540
an effect on array a so it does not

748
00:37:22,540 --> 00:37:25,150
protect the final array access with a

749
00:37:25,150 --> 00:37:27,870
type check

750
00:37:29,910 --> 00:37:32,640
sometimes the gimmick can modify the

751
00:37:32,640 --> 00:37:35,940
array without actually having to achieve

752
00:37:35,940 --> 00:37:38,430
arbitrary script execution like in the

753
00:37:38,430 --> 00:37:40,319
previous case where we had a custom

754
00:37:40,319 --> 00:37:43,700
method that would execute in the middle

755
00:37:43,700 --> 00:37:46,049
have a look at this gimmick which was

756
00:37:46,049 --> 00:37:48,000
discovered by Loki heart of Google

757
00:37:48,000 --> 00:37:50,970
project zero here the gimmick is to

758
00:37:50,970 --> 00:37:55,369
assign an object into an index of this

759
00:37:55,369 --> 00:37:58,109
now there's a JavaScript feature called

760
00:37:58,109 --> 00:38:00,809
function that call that allows you to

761
00:38:00,809 --> 00:38:03,390
specify anything you want as the this

762
00:38:03,390 --> 00:38:05,460
parameter when calling a function and

763
00:38:05,460 --> 00:38:08,160
the JIT compiler fails to take into

764
00:38:08,160 --> 00:38:11,970
account the possibility that this could

765
00:38:11,970 --> 00:38:15,240
be an alias to a so when the head code

766
00:38:15,240 --> 00:38:17,819
signs into this sub two it's actually

767
00:38:17,819 --> 00:38:21,140
causing an unexpected change to array a

768
00:38:21,140 --> 00:38:23,609
this is a good example of one of Java

769
00:38:23,609 --> 00:38:26,609
scripts many idiosyncratic features that

770
00:38:26,609 --> 00:38:29,849
can produce strange interactions that

771
00:38:29,849 --> 00:38:31,740
the JIT compiler then has to deal with

772
00:38:31,740 --> 00:38:36,450
properly I here's an incomplete list of

773
00:38:36,450 --> 00:38:38,430
gimmicks that have worked the first

774
00:38:38,430 --> 00:38:41,460
group shows coercion issues in each

775
00:38:41,460 --> 00:38:44,190
example leaf in the first group evil is

776
00:38:44,190 --> 00:38:46,529
an object that will be coerced to either

777
00:38:46,529 --> 00:38:49,109
a numeric or a string which will then

778
00:38:49,109 --> 00:38:51,750
invoke the attacker wicker attacker

779
00:38:51,750 --> 00:38:54,089
specified coercion script function and

780
00:38:54,089 --> 00:38:57,569
that the JIT compiler was not foreseeing

781
00:38:57,569 --> 00:39:00,210
that to occur and the second group shows

782
00:39:00,210 --> 00:39:02,849
various other techniques not related to

783
00:39:02,849 --> 00:39:08,329
coercion as a part of new evil class

784
00:39:08,329 --> 00:39:11,369
parentheses a it's creating a new object

785
00:39:11,369 --> 00:39:15,539
of type evil class and the trick is is

786
00:39:15,539 --> 00:39:19,410
that if evil class is simultaneously a

787
00:39:19,410 --> 00:39:22,500
proxy then it is possible to run script

788
00:39:22,500 --> 00:39:24,900
within the proxies handler method and

789
00:39:24,900 --> 00:39:26,940
this is a great example of how weird

790
00:39:26,940 --> 00:39:29,279
JavaScript can get where you can have a

791
00:39:29,279 --> 00:39:34,440
class that simultaneously a proxy v

792
00:39:34,440 --> 00:39:37,319
equal evil dot X the Jake compiler was

793
00:39:37,319 --> 00:39:39,059
thinking that this was a simple property

794
00:39:39,059 --> 00:39:43,109
that property access whereas in fact

795
00:39:43,109 --> 00:39:46,289
it was calling in a custom get prototype

796
00:39:46,289 --> 00:39:50,009
of method in one very special case where

797
00:39:50,009 --> 00:39:52,440
evil is an object that originates from a

798
00:39:52,440 --> 00:39:55,579
separate script context like an iframe

799
00:39:55,579 --> 00:39:57,960
and finally that bottom one there

800
00:39:57,960 --> 00:40:00,900
math dot max dot apply was found to

801
00:40:00,900 --> 00:40:03,779
cause unexpected script execution if the

802
00:40:03,779 --> 00:40:06,630
attacker named squats on the built in

803
00:40:06,630 --> 00:40:10,410
math dot max function and in each case

804
00:40:10,410 --> 00:40:11,999
on this entire slide when script

805
00:40:11,999 --> 00:40:14,039
execution happens the attacker can use

806
00:40:14,039 --> 00:40:16,559
that as an opportunity to make an

807
00:40:16,559 --> 00:40:21,319
unexpected modification to array state

808
00:40:21,319 --> 00:40:23,970
and sometimes you can find the gimmick

809
00:40:23,970 --> 00:40:25,950
that has the desired effect of modifying

810
00:40:25,950 --> 00:40:28,499
an array without going through the route

811
00:40:28,499 --> 00:40:31,170
of arbitrary script execution we already

812
00:40:31,170 --> 00:40:33,450
saw one of these examples before that's

813
00:40:33,450 --> 00:40:35,220
the top one here's a couple more

814
00:40:35,220 --> 00:40:38,999
examples very interesting setting any

815
00:40:38,999 --> 00:40:41,970
objects proto property to an array

816
00:40:41,970 --> 00:40:44,640
instance will automatically convert that

817
00:40:44,640 --> 00:40:47,069
array to a general array in chakra but

818
00:40:47,069 --> 00:40:49,079
the G compiler was not accounting for

819
00:40:49,079 --> 00:40:53,069
that possibility finally if you prepared

820
00:40:53,069 --> 00:40:58,019
a special array evil R that had a target

821
00:40:58,019 --> 00:41:01,470
array in its prototype chain then

822
00:41:01,470 --> 00:41:04,589
calling evil r dot reverse was affecting

823
00:41:04,589 --> 00:41:06,749
the target array and again the checker

824
00:41:06,749 --> 00:41:09,029
JIT compiler did not account for that

825
00:41:09,029 --> 00:41:12,109
possibility there's a lot more examples

826
00:41:12,109 --> 00:41:14,759
these is just to provide and window and

827
00:41:14,759 --> 00:41:16,680
how difficult it is for the JIT compiler

828
00:41:16,680 --> 00:41:22,650
to implement correct logic this final

829
00:41:22,650 --> 00:41:25,079
section we're going to examine one more

830
00:41:25,079 --> 00:41:26,970
class of JIT compiler vulnerabilities

831
00:41:26,970 --> 00:41:28,739
having to do with errors in a component

832
00:41:28,739 --> 00:41:33,089
known as the typer the typer is one

833
00:41:33,089 --> 00:41:35,239
major component of chromium's v8

834
00:41:35,239 --> 00:41:38,359
JavaScript engine it's responsible for

835
00:41:38,359 --> 00:41:40,859
deducing known facts about the types

836
00:41:40,859 --> 00:41:44,519
found within variables and it also deals

837
00:41:44,519 --> 00:41:47,309
with partially known information for

838
00:41:47,309 --> 00:41:49,619
example if it can be deduced that a

839
00:41:49,619 --> 00:41:51,690
variable must contain one of several

840
00:41:51,690 --> 00:41:53,910
known types such as if it may be known

841
00:41:53,910 --> 00:41:55,089
that it can

842
00:41:55,089 --> 00:41:57,549
contains an array but it is not known

843
00:41:57,549 --> 00:42:00,969
which type of array in particular when

844
00:42:00,969 --> 00:42:03,190
it comes to integers the type er takes

845
00:42:03,190 --> 00:42:05,920
on an additional responsibility it also

846
00:42:05,920 --> 00:42:08,589
tracks what may be known about the range

847
00:42:08,589 --> 00:42:12,130
in which the integer can fall for

848
00:42:12,130 --> 00:42:14,380
example it may be known that the integer

849
00:42:14,380 --> 00:42:16,539
must be within the range from one to a

850
00:42:16,539 --> 00:42:17,170
hundred

851
00:42:17,170 --> 00:42:19,739
as the data then flows through

852
00:42:19,739 --> 00:42:22,479
arithmetic operations the typer does

853
00:42:22,479 --> 00:42:25,390
what it can to propagate deductions

854
00:42:25,390 --> 00:42:27,670
about the possible range of resulting

855
00:42:27,670 --> 00:42:32,259
values the codes shown here provides an

856
00:42:32,259 --> 00:42:34,660
example of why it is useful for the

857
00:42:34,660 --> 00:42:36,910
typer to be able to track the range of

858
00:42:36,910 --> 00:42:43,089
integers this is in a loop that iterates

859
00:42:43,089 --> 00:42:47,710
over there over an array and am before

860
00:42:47,710 --> 00:42:50,529
in a naive implementation before each

861
00:42:50,529 --> 00:42:52,839
array access it would have to perform a

862
00:42:52,839 --> 00:42:55,660
balanced check but the typer can help a

863
00:42:55,660 --> 00:42:58,269
great deal in this case because it can

864
00:42:58,269 --> 00:43:00,489
propagate deductions about the variable

865
00:43:00,489 --> 00:43:03,160
I and it can establish that I will

866
00:43:03,160 --> 00:43:04,989
always be an integer and that it will

867
00:43:04,989 --> 00:43:07,119
always be within the proper range and

868
00:43:07,119 --> 00:43:09,999
capital e is capitalizing on this the

869
00:43:09,999 --> 00:43:12,969
JIT compiler can remove all bounds

870
00:43:12,969 --> 00:43:15,190
checks shown here significantly

871
00:43:15,190 --> 00:43:18,609
enhancing performance of the loop from a

872
00:43:18,609 --> 00:43:20,589
security perspective though this place

873
00:43:20,589 --> 00:43:23,049
is a heavy responsibility on the typer

874
00:43:23,049 --> 00:43:25,839
to get all of its deductions exactly

875
00:43:25,839 --> 00:43:28,869
right because any error could result in

876
00:43:28,869 --> 00:43:31,180
the erroneous removal of a bounced check

877
00:43:31,180 --> 00:43:33,700
in a case where the check really needs

878
00:43:33,700 --> 00:43:40,150
to be performed let's take an example of

879
00:43:40,150 --> 00:43:42,640
how faulty output from a typer could

880
00:43:42,640 --> 00:43:46,569
impact security in the red rectangle

881
00:43:46,569 --> 00:43:48,700
that you see here the JavaScript code is

882
00:43:48,700 --> 00:43:51,369
making a strict comparison between an

883
00:43:51,369 --> 00:43:54,279
integer and a string the typer can

884
00:43:54,279 --> 00:43:56,259
deduce that these two values will never

885
00:43:56,259 --> 00:44:00,670
be strictly equal so that the variable B

886
00:44:00,670 --> 00:44:04,920
has the known type of boolean false in

887
00:44:04,920 --> 00:44:08,980
the next line variable B is being used

888
00:44:08,980 --> 00:44:11,140
in an arithmetic multiplication and

889
00:44:11,140 --> 00:44:12,910
according to the rules of the JavaScript

890
00:44:12,910 --> 00:44:16,000
language a boolean value used in this

891
00:44:16,000 --> 00:44:18,430
way it will be coerced into either a 0

892
00:44:18,430 --> 00:44:22,060
or a 1 0 false 1 for true

893
00:44:22,060 --> 00:44:25,720
as a result variable C will result will

894
00:44:25,720 --> 00:44:29,290
receive either 0 or 1 3 3 7 depending on

895
00:44:29,290 --> 00:44:31,900
the value of B this is a technique that

896
00:44:31,900 --> 00:44:35,430
can be used to amplify any error in B

897
00:44:35,430 --> 00:44:38,589
but in our case here the typer correctly

898
00:44:38,589 --> 00:44:40,960
determines that B will always be false

899
00:44:40,960 --> 00:44:44,050
so it reduces that C will always be 0

900
00:44:44,050 --> 00:44:47,079
and on this basis the JIT compiler will

901
00:44:47,079 --> 00:44:49,119
omit the bounds check before the array

902
00:44:49,119 --> 00:44:51,670
access on the last line in this case all

903
00:44:51,670 --> 00:45:01,300
goes well to produce a failure scenario

904
00:45:01,300 --> 00:45:03,220
we'll need to replace what's in the red

905
00:45:03,220 --> 00:45:06,040
rectangle with some other expression one

906
00:45:06,040 --> 00:45:08,140
where the typer draws an incorrect

907
00:45:08,140 --> 00:45:09,849
conclusion about whether it will

908
00:45:09,849 --> 00:45:14,710
evaluate to true or false an example of

909
00:45:14,710 --> 00:45:18,400
this came in November 2018 with the xm1

910
00:45:18,400 --> 00:45:21,569
bug found by a row of Google project 0

911
00:45:21,569 --> 00:45:24,040
he found that a circumstance where the

912
00:45:24,040 --> 00:45:26,410
typer would incorrectly identify the

913
00:45:26,410 --> 00:45:29,170
output of a certain obscure built-in

914
00:45:29,170 --> 00:45:33,609
function called math dot X m1 and this

915
00:45:33,609 --> 00:45:35,619
is the tricky part of the specification

916
00:45:35,619 --> 00:45:38,290
of this function is that it's possible

917
00:45:38,290 --> 00:45:46,109
to get out a value of negative 0 and

918
00:45:46,109 --> 00:45:49,030
this happens when you pass in a value of

919
00:45:49,030 --> 00:45:52,210
negative 0 and this is the essence of

920
00:45:52,210 --> 00:45:56,290
the bug the math dot X m1 of negative 0

921
00:45:56,290 --> 00:45:58,420
will produce negative zero but the typer

922
00:45:58,420 --> 00:46:01,720
wrongly assumes that a return value of

923
00:46:01,720 --> 00:46:04,900
negative zero is not a possibility so

924
00:46:04,900 --> 00:46:06,760
when the typer tries to determine the

925
00:46:06,760 --> 00:46:09,280
result of the above expression it will

926
00:46:09,280 --> 00:46:11,260
wrongly conclude that the answer is

927
00:46:11,260 --> 00:46:12,400
false

928
00:46:12,400 --> 00:46:15,630
when in fact it's going to be true and

929
00:46:15,630 --> 00:46:17,710
plugging this back into the bounds

930
00:46:17,710 --> 00:46:19,540
checking scenario that we explored a

931
00:46:19,540 --> 00:46:22,060
couple of slides back this is basically

932
00:46:22,060 --> 00:46:22,900
what you would

933
00:46:22,900 --> 00:46:26,440
want to do in order to exploit the xm1

934
00:46:26,440 --> 00:46:29,650
bug the idea is that the typer would one

935
00:46:29,650 --> 00:46:33,849
Li conclude that B is false and that's

936
00:46:33,849 --> 00:46:37,029
consequently C is zero so no bounds

937
00:46:37,029 --> 00:46:39,910
check is needed on the last line while

938
00:46:39,910 --> 00:46:44,260
in reality B will be true and C will be

939
00:46:44,260 --> 00:46:48,480
a large number and then according to the

940
00:46:48,480 --> 00:46:50,380
large number according to the

941
00:46:50,380 --> 00:46:52,539
amplification factor and then the

942
00:46:52,539 --> 00:46:55,630
attacker can read or write outside the

943
00:46:55,630 --> 00:46:58,720
bounds of this array I see every red

944
00:46:58,720 --> 00:47:00,490
light I was going to go into a bit more

945
00:47:00,490 --> 00:47:03,130
about the exploitation of this district

946
00:47:03,130 --> 00:47:04,869
another couple of minutes is a good ok

947
00:47:04,869 --> 00:47:05,319
great

948
00:47:05,319 --> 00:47:07,539
in practice if you were to try this it

949
00:47:07,539 --> 00:47:10,390
will not work by which I mean that even

950
00:47:10,390 --> 00:47:12,690
at the time the bug was originally found

951
00:47:12,690 --> 00:47:15,730
and the typer was still XX exhibiting

952
00:47:15,730 --> 00:47:17,770
the incorrect behavior and was not yet

953
00:47:17,770 --> 00:47:21,279
patched this method of exploitation did

954
00:47:21,279 --> 00:47:23,829
still still did not quite work and for

955
00:47:23,829 --> 00:47:25,869
this reason Google originally believed

956
00:47:25,869 --> 00:47:27,849
that this bug was not exploitable and

957
00:47:27,849 --> 00:47:30,880
they assigned it a lower priority and

958
00:47:30,880 --> 00:47:33,700
the essential difficulty in exploiting

959
00:47:33,700 --> 00:47:36,880
exploiting this was that the incorrect

960
00:47:36,880 --> 00:47:40,170
hyper result which indicated that

961
00:47:40,170 --> 00:47:43,839
exponet 2 was also being used elsewhere

962
00:47:43,839 --> 00:47:47,349
in the JIT compiler to inform how Vale

963
00:47:47,349 --> 00:47:49,869
values needed to be converted when

964
00:47:49,869 --> 00:47:53,319
passing parameters into object dot is

965
00:47:53,319 --> 00:47:55,210
and with that what was happening because

966
00:47:55,210 --> 00:47:57,819
of that is that the negative 0 value was

967
00:47:57,819 --> 00:48:00,069
being silently replaced with positive

968
00:48:00,069 --> 00:48:03,579
zero before object is that ever got to

969
00:48:03,579 --> 00:48:07,359
see it eventually Google researchers did

970
00:48:07,359 --> 00:48:09,609
discover a route to making this bug

971
00:48:09,609 --> 00:48:13,869
exploitable and then these was made as

972
00:48:13,869 --> 00:48:15,880
an exploitation challenge as part of the

973
00:48:15,880 --> 00:48:20,440
35c 3 CTF in December 2018 leading to

974
00:48:20,440 --> 00:48:23,410
multiple outside researchers finding

975
00:48:23,410 --> 00:48:25,839
their own solutions among those was

976
00:48:25,839 --> 00:48:28,359
Andrea Biondo who is also a member of

977
00:48:28,359 --> 00:48:30,970
the winning team and the essence of his

978
00:48:30,970 --> 00:48:34,089
solution is shown here most critically

979
00:48:34,089 --> 00:48:36,640
what he did was

980
00:48:36,640 --> 00:48:40,029
that negative zero value to pass into X

981
00:48:40,029 --> 00:48:43,809
m1 was provided through a parameter X

982
00:48:43,809 --> 00:48:48,130
and during a preparatory call X is set

983
00:48:48,130 --> 00:48:52,720
to a numeric value in string form since

984
00:48:52,720 --> 00:48:55,210
now the profiling information indicates

985
00:48:55,210 --> 00:48:58,480
that X is not always in numeric the JIT

986
00:48:58,480 --> 00:49:02,019
compiler is forced to treat X m1 as a

987
00:49:02,019 --> 00:49:04,480
full-fledged call into the JavaScript

988
00:49:04,480 --> 00:49:08,500
runtime library and ice a side effect of

989
00:49:08,500 --> 00:49:12,130
that is that when X m1 is executed in

990
00:49:12,130 --> 00:49:14,920
that way no further internal conversions

991
00:49:14,920 --> 00:49:17,769
are needed between the output of Expo on

992
00:49:17,769 --> 00:49:20,500
and the input of object that is so the

993
00:49:20,500 --> 00:49:23,829
negative zero flows right in also in the

994
00:49:23,829 --> 00:49:27,190
second parameter to object that is it's

995
00:49:27,190 --> 00:49:29,710
provided via a field on a locally

996
00:49:29,710 --> 00:49:32,589
defined object and this helps to ensure

997
00:49:32,589 --> 00:49:35,829
that the compiler does not realize too

998
00:49:35,829 --> 00:49:38,109
early that the second parameter is the

999
00:49:38,109 --> 00:49:42,130
fixed value negative zero otherwise the

1000
00:49:42,130 --> 00:49:44,259
compiler would omit this entire

1001
00:49:44,259 --> 00:49:47,190
operation again based on the type Earth

1002
00:49:47,190 --> 00:49:50,140
incorrect assurance that XM one never

1003
00:49:50,140 --> 00:49:53,980
returns a negative zero and then after

1004
00:49:53,980 --> 00:49:56,589
these tweaks the JIT compiler will be

1005
00:49:56,589 --> 00:49:58,690
will omit the necessary balance check

1006
00:49:58,690 --> 00:50:01,539
and so far from being non exploitable

1007
00:50:01,539 --> 00:50:03,869
this expand but is highly critical

1008
00:50:03,869 --> 00:50:07,000
allowing out-of-bounds array reads and

1009
00:50:07,000 --> 00:50:11,650
writes and that is how the obscure xm1

1010
00:50:11,650 --> 00:50:14,259
math function and the value negative

1011
00:50:14,259 --> 00:50:18,220
zero became legend in JavaScript engine

1012
00:50:18,220 --> 00:50:25,119
security research we're a little late on

1013
00:50:25,119 --> 00:50:27,539
time so I'm just gonna skip the summary

1014
00:50:27,539 --> 00:50:29,160
thank you so much

1015
00:50:29,160 --> 00:50:32,360
[Applause]

1016
00:50:32,360 --> 00:50:45,320
[Music]

