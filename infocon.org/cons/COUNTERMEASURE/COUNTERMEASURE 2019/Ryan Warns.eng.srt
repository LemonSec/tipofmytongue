1
00:00:00,230 --> 00:00:02,299
[Music]

2
00:00:05,660 --> 00:00:09,090
the essence is going like a rim said I'm

3
00:00:09,090 --> 00:00:11,070
Ryan so tightly I work for the flare

4
00:00:11,070 --> 00:00:12,870
team right but you know officially I

5
00:00:12,870 --> 00:00:14,130
work for the group that supports our

6
00:00:14,130 --> 00:00:15,839
kind of red teaming operation I'll do

7
00:00:15,839 --> 00:00:18,600
all in the intro but this talk is both

8
00:00:18,600 --> 00:00:22,560
sort of a it's an interesting bug that

9
00:00:22,560 --> 00:00:26,250
we found kind of spread across a bunch

10
00:00:26,250 --> 00:00:29,039
of drivers right but it's also sort of a

11
00:00:29,039 --> 00:00:30,660
walkthrough and a how-to about what is

12
00:00:30,660 --> 00:00:32,308
device driver exploitation what does it

13
00:00:32,308 --> 00:00:32,940
involve

14
00:00:32,940 --> 00:00:34,559
and then there's some gotchas that

15
00:00:34,559 --> 00:00:36,809
popped up with this primitive that we

16
00:00:36,809 --> 00:00:38,520
get with this bug specifically so I'll

17
00:00:38,520 --> 00:00:39,750
go through the intro I'll give you a

18
00:00:39,750 --> 00:00:42,090
quick little rundown of what being a

19
00:00:42,090 --> 00:00:44,219
device driver means on Windows and then

20
00:00:44,219 --> 00:00:46,110
I'll talk about the bug and then the

21
00:00:46,110 --> 00:00:47,570
kind of the second half of the talk is

22
00:00:47,570 --> 00:00:49,500
sort of the the nitty-gritty

23
00:00:49,500 --> 00:00:51,210
exploitation details because you know a

24
00:00:51,210 --> 00:00:52,590
lot of talks are just like oh this is

25
00:00:52,590 --> 00:00:54,449
exploitable so we're done right so I

26
00:00:54,449 --> 00:00:57,800
wanted to go through end end to show you

27
00:00:57,800 --> 00:01:00,090
you know what like a fully functioning

28
00:01:00,090 --> 00:01:04,140
kind of exploit would look like so like

29
00:01:04,140 --> 00:01:06,390
I said I'm Ryan I work for the flair

30
00:01:06,390 --> 00:01:09,270
team if you guys aren't familiar the

31
00:01:09,270 --> 00:01:12,030
flare team and fireEye we support sort

32
00:01:12,030 --> 00:01:13,200
of all of the reverse engineering

33
00:01:13,200 --> 00:01:14,400
efforts so we're kind of like the

34
00:01:14,400 --> 00:01:15,570
whipping blowing for the rest of the

35
00:01:15,570 --> 00:01:17,939
company so if our products find

36
00:01:17,939 --> 00:01:19,770
something we get the binaries if our red

37
00:01:19,770 --> 00:01:22,350
team needs help we help them if you know

38
00:01:22,350 --> 00:01:23,850
there's an incident we're kind of always

39
00:01:23,850 --> 00:01:25,830
supporting sort of whatever fireEye's

40
00:01:25,830 --> 00:01:27,210
doing it kind of like a low-level type

41
00:01:27,210 --> 00:01:29,460
thing and then specifically the

42
00:01:29,460 --> 00:01:31,320
offensive task force is relatively new

43
00:01:31,320 --> 00:01:35,850
but it its goal is kind of to support

44
00:01:35,850 --> 00:01:37,979
our red team so we do a lot of payload

45
00:01:37,979 --> 00:01:40,500
development and we do a lot of you know

46
00:01:40,500 --> 00:01:42,720
debugging we kind of are like the

47
00:01:42,720 --> 00:01:44,640
support line if something goes wrong on

48
00:01:44,640 --> 00:01:46,049
an engagement they need some kind of

49
00:01:46,049 --> 00:01:48,420
help to get along then my twitter is up

50
00:01:48,420 --> 00:01:51,030
there I never tweet but you know I think

51
00:01:51,030 --> 00:01:52,860
that's you kind of have to have one

52
00:01:52,860 --> 00:01:56,280
right so that's what I am so in terms of

53
00:01:56,280 --> 00:01:59,159
what this talk represents and why I'm

54
00:01:59,159 --> 00:02:00,659
giving it right like usually when you

55
00:02:00,659 --> 00:02:02,399
hear about privilege escalation issues

56
00:02:02,399 --> 00:02:06,270
on Windows it's in win32 K or AV drivers

57
00:02:06,270 --> 00:02:08,340
or something like that right but at the

58
00:02:08,340 --> 00:02:10,530
end of the day there's a bunch of

59
00:02:10,530 --> 00:02:12,780
binaries kind of running in kernel space

60
00:02:12,780 --> 00:02:13,800
on Windows

61
00:02:13,800 --> 00:02:16,770
that are maybe it's not obvious

62
00:02:16,770 --> 00:02:18,300
depending on what application you're

63
00:02:18,300 --> 00:02:19,650
using but basically they're all over the

64
00:02:19,650 --> 00:02:21,030
place right and then I'll talk about

65
00:02:21,030 --> 00:02:25,580
this a little bit later but we've seen

66
00:02:25,580 --> 00:02:29,070
sort of sophisticated actors use issues

67
00:02:29,070 --> 00:02:30,540
like what I'm gonna describe here where

68
00:02:30,540 --> 00:02:31,890
even if they already have quote unquote

69
00:02:31,890 --> 00:02:34,620
like higher access privileges they've

70
00:02:34,620 --> 00:02:36,240
used these issues to kind of hop around

71
00:02:36,240 --> 00:02:39,000
and avoid security products or antivirus

72
00:02:39,000 --> 00:02:42,240
signatures or whatever right so in you

73
00:02:42,240 --> 00:02:44,520
know in a lot of cases if you've ever

74
00:02:44,520 --> 00:02:46,290
used like process Explorer or process

75
00:02:46,290 --> 00:02:49,020
monitor they have a driver component on

76
00:02:49,020 --> 00:02:50,460
their back-end that kind of drives their

77
00:02:50,460 --> 00:02:51,810
GUI right so I just doing all the actual

78
00:02:51,810 --> 00:02:54,510
work and the other the other place where

79
00:02:54,510 --> 00:02:56,100
you sees pop up is like like I said

80
00:02:56,100 --> 00:02:59,130
antivirus obviously has them any cheat

81
00:02:59,130 --> 00:03:00,960
stuff for games has them so they're kind

82
00:03:00,960 --> 00:03:05,070
of all over the place and like I said

83
00:03:05,070 --> 00:03:07,290
some of the sort of exploitation stuff

84
00:03:07,290 --> 00:03:08,820
that you have to do if you find a bug is

85
00:03:08,820 --> 00:03:10,680
sort of unique to this kind of workflow

86
00:03:10,680 --> 00:03:15,090
right like I already said we've seen

87
00:03:15,090 --> 00:03:18,840
some of these be used in the wild so

88
00:03:18,840 --> 00:03:20,760
what will normally happen from a kind of

89
00:03:20,760 --> 00:03:24,239
malicious perspective is you'll get

90
00:03:24,239 --> 00:03:26,190
infected with malware and kind of the

91
00:03:26,190 --> 00:03:30,209
big boy actors will either search for

92
00:03:30,209 --> 00:03:32,250
these exploits or we'll talk about it in

93
00:03:32,250 --> 00:03:34,170
in a second but you can drop and load

94
00:03:34,170 --> 00:03:36,510
these to exploit and it's kind of a

95
00:03:36,510 --> 00:03:38,130
weird exposure thing because basically

96
00:03:38,130 --> 00:03:39,840
if you have one of these issues present

97
00:03:39,840 --> 00:03:42,810
then the way device drivers work on

98
00:03:42,810 --> 00:03:44,880
window and on most operating systems is

99
00:03:44,880 --> 00:03:47,370
once you compromise one of these you're

100
00:03:47,370 --> 00:03:48,959
running code kind of at parity with the

101
00:03:48,959 --> 00:03:51,810
rest of the operating system so anything

102
00:03:51,810 --> 00:03:54,050
that you can do with stuff like this

103
00:03:54,050 --> 00:03:56,220
kind of leads a total system compromise

104
00:03:56,220 --> 00:03:58,350
like one of the benefits is even if you

105
00:03:58,350 --> 00:04:02,130
say all up on this box I already have an

106
00:04:02,130 --> 00:04:05,959
even administrator access right because

107
00:04:05,959 --> 00:04:08,630
antivirus vendors and the security stuff

108
00:04:08,630 --> 00:04:10,440
operating system we're all running at

109
00:04:10,440 --> 00:04:11,580
the same level it's like these things

110
00:04:11,580 --> 00:04:13,290
that I'm talking about you can use it to

111
00:04:13,290 --> 00:04:15,810
kind of avoid detection right and so

112
00:04:15,810 --> 00:04:17,579
we've seen it in some Red Team toolkits

113
00:04:17,579 --> 00:04:19,350
I mean it's already out there like if

114
00:04:19,350 --> 00:04:20,730
you ever looked at how Mimi Katz works

115
00:04:20,730 --> 00:04:22,500
they have a driver that they package and

116
00:04:22,500 --> 00:04:25,140
ship that can do some of this right so

117
00:04:25,140 --> 00:04:27,910
you know Mimi Katz uses their specific

118
00:04:27,910 --> 00:04:30,550
to make sure a subset of their

119
00:04:30,550 --> 00:04:32,380
functionality can work across kind of OS

120
00:04:32,380 --> 00:04:35,530
versions but so yeah I'll talk about

121
00:04:35,530 --> 00:04:37,420
kind of the the interplay with this in a

122
00:04:37,420 --> 00:04:38,680
little bit once we talk about the bug

123
00:04:38,680 --> 00:04:41,050
right but before we can talk about the

124
00:04:41,050 --> 00:04:43,420
actual issues that we found I'm gonna

125
00:04:43,420 --> 00:04:45,250
give you a quick primer on like what

126
00:04:45,250 --> 00:04:46,900
again what it means to be a device

127
00:04:46,900 --> 00:04:47,950
driver on Windows

128
00:04:47,950 --> 00:04:52,930
so usually drivers are tied to hardware

129
00:04:52,930 --> 00:04:55,150
right so like you know you have a mouse

130
00:04:55,150 --> 00:04:56,560
a keyboard or whatever and they have a

131
00:04:56,560 --> 00:04:58,360
driver that's responsible for

132
00:04:58,360 --> 00:04:59,920
communicating back and forth with that

133
00:04:59,920 --> 00:05:02,980
peripheral the kinds of drivers that

134
00:05:02,980 --> 00:05:05,650
we're gonna talk about today are what's

135
00:05:05,650 --> 00:05:07,900
called like software drivers and they're

136
00:05:07,900 --> 00:05:10,240
basically just binaries that kind of run

137
00:05:10,240 --> 00:05:12,160
in the background in ring zero they're

138
00:05:12,160 --> 00:05:16,150
not responsible for handling hardware

139
00:05:16,150 --> 00:05:17,410
specifically but they are responsible

140
00:05:17,410 --> 00:05:20,230
for doing like I said kind of basically

141
00:05:20,230 --> 00:05:22,630
like callbacks in the kernel to do stuff

142
00:05:22,630 --> 00:05:23,830
so there's a bunch of reasons why you

143
00:05:23,830 --> 00:05:25,780
would do this like for example if you

144
00:05:25,780 --> 00:05:28,780
wanted to track process creation or you

145
00:05:28,780 --> 00:05:30,940
wanted to see what was going on it's a

146
00:05:30,940 --> 00:05:32,500
lot easier to do that from a ring 0

147
00:05:32,500 --> 00:05:34,540
perspective versus kind of writing a

148
00:05:34,540 --> 00:05:35,800
user I have to pull everything or

149
00:05:35,800 --> 00:05:37,960
whatever now when you have one of these

150
00:05:37,960 --> 00:05:40,810
issues like I said you're at parity with

151
00:05:40,810 --> 00:05:42,250
the operating system but also the

152
00:05:42,250 --> 00:05:43,600
operating system doesn't buy you

153
00:05:43,600 --> 00:05:46,840
anything in terms of security right so

154
00:05:46,840 --> 00:05:49,860
if you write a device driver you're also

155
00:05:49,860 --> 00:05:52,090
configuring who can talk to you who has

156
00:05:52,090 --> 00:05:53,230
permissions that talk to you and things

157
00:05:53,230 --> 00:05:54,640
like that so that that's kind of where

158
00:05:54,640 --> 00:05:59,440
some of this issue comes from right and

159
00:05:59,440 --> 00:06:00,550
then like I said you know you'll

160
00:06:00,550 --> 00:06:03,190
commonly see these both to do hardware

161
00:06:03,190 --> 00:06:04,810
support and also you know if you think

162
00:06:04,810 --> 00:06:06,870
about like processes to Explorer

163
00:06:06,870 --> 00:06:08,830
since I already said there's a driver

164
00:06:08,830 --> 00:06:10,600
process Explorer doesn't need to do any

165
00:06:10,600 --> 00:06:12,310
communication with hardware right but it

166
00:06:12,310 --> 00:06:14,560
does do a bunch of stuff to like look at

167
00:06:14,560 --> 00:06:16,480
process memory or try creation there's

168
00:06:16,480 --> 00:06:18,190
all this kind of sort of all of these

169
00:06:18,190 --> 00:06:20,190
events it's all kind of filtered through

170
00:06:20,190 --> 00:06:22,390
this brings zero callback kind of

171
00:06:22,390 --> 00:06:24,400
mechanism so in terms of how do I

172
00:06:24,400 --> 00:06:27,570
communicate with a device driver right

173
00:06:27,570 --> 00:06:31,660
when you're on Windows kind of the

174
00:06:31,660 --> 00:06:33,790
terminology is the lowest level

175
00:06:33,790 --> 00:06:35,380
communication mechanism is called

176
00:06:35,380 --> 00:06:37,690
interrupt or sorry an i/o request

177
00:06:37,690 --> 00:06:40,150
packets or an herb right and what

178
00:06:40,150 --> 00:06:41,320
happens is

179
00:06:41,320 --> 00:06:44,740
you your driver gets installed you start

180
00:06:44,740 --> 00:06:46,450
up and you say here's all the kinds of

181
00:06:46,450 --> 00:06:47,860
requests that I can handle so there's

182
00:06:47,860 --> 00:06:51,250
kind of a pre-canned list of callbacks

183
00:06:51,250 --> 00:06:53,500
as you can provide so Microsoft defines

184
00:06:53,500 --> 00:06:55,960
28 different codes at each code is

185
00:06:55,960 --> 00:06:57,280
generally tied to like an i/o operation

186
00:06:57,280 --> 00:07:00,700
right so if I read a file or I write a

187
00:07:00,700 --> 00:07:03,190
file or I want to you know we're gonna

188
00:07:03,190 --> 00:07:05,110
talk specifically about the one that

189
00:07:05,110 --> 00:07:07,480
most of them use but each function

190
00:07:07,480 --> 00:07:09,190
callback is basically a kernel function

191
00:07:09,190 --> 00:07:10,930
that's responsible for doing some kind

192
00:07:10,930 --> 00:07:14,140
of i/o right so usually the one that we

193
00:07:14,140 --> 00:07:15,520
care about when we're talking about

194
00:07:15,520 --> 00:07:17,380
assessing device drivers is the one I

195
00:07:17,380 --> 00:07:18,970
have on the bottom of this list so our

196
00:07:18,970 --> 00:07:21,400
pmj device control is tied to a specific

197
00:07:21,400 --> 00:07:25,030
sort of API call and user Mullane but at

198
00:07:25,030 --> 00:07:26,650
the end of the day I'll walk you through

199
00:07:26,650 --> 00:07:28,750
kind of the the chain in a second but

200
00:07:28,750 --> 00:07:31,780
you issue some kind of i/o request and

201
00:07:31,780 --> 00:07:33,940
like the OS Maps everything to a

202
00:07:33,940 --> 00:07:35,680
function pointer for you and then it'll

203
00:07:35,680 --> 00:07:38,560
call some device driver somewhere in the

204
00:07:38,560 --> 00:07:42,010
kernel space for you so this is kind of

205
00:07:42,010 --> 00:07:43,450
where we're going to start fuzzing

206
00:07:43,450 --> 00:07:44,740
unsurprisingly writes is how you

207
00:07:44,740 --> 00:07:46,900
communicate with these components like I

208
00:07:46,900 --> 00:07:48,400
said most of the bugs you're gonna find

209
00:07:48,400 --> 00:07:49,900
are gonna be in the device control

210
00:07:49,900 --> 00:07:52,270
callback but you know every once in a

211
00:07:52,270 --> 00:07:56,200
while you can say like there's other

212
00:07:56,200 --> 00:07:57,790
handlers it's kind of depends on the

213
00:07:57,790 --> 00:07:59,530
architecture but for software drivers

214
00:07:59,530 --> 00:08:03,130
it's usually kind of there's only a sort

215
00:08:03,130 --> 00:08:04,720
of one standard way to communicate with

216
00:08:04,720 --> 00:08:06,400
them so we're gonna focus on the urban

217
00:08:06,400 --> 00:08:08,470
device control and that's where we would

218
00:08:08,470 --> 00:08:11,130
want to look at our fuzzing right so

219
00:08:11,130 --> 00:08:14,320
again I'm not gonna go super deep and

220
00:08:14,320 --> 00:08:16,240
inherent mechanics of how this works but

221
00:08:16,240 --> 00:08:18,670
essentially at a high level in user mode

222
00:08:18,670 --> 00:08:20,740
when you want to do some kind of i/o

223
00:08:20,740 --> 00:08:23,320
operation right so create file refile

224
00:08:23,320 --> 00:08:26,590
write file what will happen is you'll

225
00:08:26,590 --> 00:08:28,960
issue this API call the OS will do a

226
00:08:28,960 --> 00:08:31,000
bunch of stuff for you and then there's

227
00:08:31,000 --> 00:08:31,960
all of these I'm gonna click through

228
00:08:31,960 --> 00:08:33,370
them really quick and just kind of talk

229
00:08:33,370 --> 00:08:35,289
through it at the end there's all these

230
00:08:35,289 --> 00:08:37,510
kind of underlying objects that the

231
00:08:37,510 --> 00:08:39,280
operating system uses to kind of manage

232
00:08:39,280 --> 00:08:41,229
IO operations right so if you're

233
00:08:41,229 --> 00:08:43,719
familiar with the windows API a lot of

234
00:08:43,719 --> 00:08:45,790
things that you do involve using handles

235
00:08:45,790 --> 00:08:47,410
right which are similar to kind of file

236
00:08:47,410 --> 00:08:48,880
descriptors on Linux right

237
00:08:48,880 --> 00:08:50,890
so each handle corresponds to a file

238
00:08:50,890 --> 00:08:53,560
object and then each file object has

239
00:08:53,560 --> 00:08:55,089
stuff in it that space

240
00:08:55,089 --> 00:08:56,709
he says like when you're trying to do

241
00:08:56,709 --> 00:08:58,809
something on me like go call this guy

242
00:08:58,809 --> 00:09:01,870
right so the full chain is you could

243
00:09:01,870 --> 00:09:03,790
handle to a file object file objects

244
00:09:03,790 --> 00:09:06,790
have device objects and what we care

245
00:09:06,790 --> 00:09:08,079
about is kind of the driver object

246
00:09:08,079 --> 00:09:11,079
associated with it so again without

247
00:09:11,079 --> 00:09:12,850
going too deep basically the driver

248
00:09:12,850 --> 00:09:16,120
object is like the the thing that you

249
00:09:16,120 --> 00:09:17,559
define that says what all the

250
00:09:17,559 --> 00:09:19,779
functionality you have is and each

251
00:09:19,779 --> 00:09:21,129
device object is sort of like a

252
00:09:21,129 --> 00:09:22,779
particular instance of that so it's

253
00:09:22,779 --> 00:09:25,509
similar to like if you've ever done C++

254
00:09:25,509 --> 00:09:27,519
like the driver object to be like your

255
00:09:27,519 --> 00:09:28,870
class definition and then you could have

256
00:09:28,870 --> 00:09:31,540
device objects that are corresponding

257
00:09:31,540 --> 00:09:33,970
implementations of it but most of this

258
00:09:33,970 --> 00:09:35,529
you can usually ignore it was just kind

259
00:09:35,529 --> 00:09:37,300
of a sort of a background thing so what

260
00:09:37,300 --> 00:09:38,559
we really care about is this driver

261
00:09:38,559 --> 00:09:41,829
object because the driver object is

262
00:09:41,829 --> 00:09:44,199
where those Erb codes that I was talking

263
00:09:44,199 --> 00:09:45,670
about a couple slides are defined so

264
00:09:45,670 --> 00:09:47,769
what I have up here is kind of a dump of

265
00:09:47,769 --> 00:09:50,259
something that I you know I was loading

266
00:09:50,259 --> 00:09:52,959
in window bug and what you can see the

267
00:09:52,959 --> 00:09:55,540
bottom that sort of big list of stuff at

268
00:09:55,540 --> 00:09:58,230
the sort of lower half is all of those

269
00:09:58,230 --> 00:10:00,850
API calls or all those function calls

270
00:10:00,850 --> 00:10:01,959
that correspond to different i/o

271
00:10:01,959 --> 00:10:04,449
operations that we talked about right so

272
00:10:04,449 --> 00:10:06,490
because Microsoft defines them they're

273
00:10:06,490 --> 00:10:08,110
all in kind of a standard location and

274
00:10:08,110 --> 00:10:09,550
you'll usually see something like this

275
00:10:09,550 --> 00:10:11,709
where by default when a driver gets

276
00:10:11,709 --> 00:10:14,740
loaded it can't handle any i/o and then

277
00:10:14,740 --> 00:10:16,629
sort of at startup it'll say like oh no

278
00:10:16,629 --> 00:10:18,490
if you try to call read file on my

279
00:10:18,490 --> 00:10:19,959
handle called this function if you call

280
00:10:19,959 --> 00:10:21,579
device i/o control in my handle you call

281
00:10:21,579 --> 00:10:24,550
this function right so for us like I

282
00:10:24,550 --> 00:10:25,660
said the one that we really care about

283
00:10:25,660 --> 00:10:27,339
is at the bottom there so rpm Jade

284
00:10:27,339 --> 00:10:29,019
device control that's the one that gets

285
00:10:29,019 --> 00:10:32,980
called there's a special sort of API in

286
00:10:32,980 --> 00:10:34,959
userland called device i/o control where

287
00:10:34,959 --> 00:10:36,999
you send kind of user-defined requests

288
00:10:36,999 --> 00:10:42,449
to an arbitrary device right so then

289
00:10:42,449 --> 00:10:45,819
again from a how do I assess these what

290
00:10:45,819 --> 00:10:48,790
am I looking at kind of perspective on

291
00:10:48,790 --> 00:10:51,550
in kernel space what usually happens is

292
00:10:51,550 --> 00:10:53,679
because like I said device i/o control

293
00:10:53,679 --> 00:10:57,429
is for developer defined requests so the

294
00:10:57,429 --> 00:10:59,620
this parts not microsoft's standard or

295
00:10:59,620 --> 00:11:01,029
anything like that but what will happen

296
00:11:01,029 --> 00:11:04,779
is when the driver you know is compiled

297
00:11:04,779 --> 00:11:06,579
or whatever it'll say like here's all

298
00:11:06,579 --> 00:11:08,380
the request codes that I can accept and

299
00:11:08,380 --> 00:11:10,120
can run and to do different stuff so

300
00:11:10,120 --> 00:11:12,370
what's shown on the slide here is kind

301
00:11:12,370 --> 00:11:13,840
of what it would usually look like when

302
00:11:13,840 --> 00:11:14,860
you're assessing one of these drivers

303
00:11:14,860 --> 00:11:16,360
but it's basically just a big kind of

304
00:11:16,360 --> 00:11:18,910
switch statement and it says hey you

305
00:11:18,910 --> 00:11:21,820
know command code eight five F whatever

306
00:11:21,820 --> 00:11:23,800
whatever that course like I need to do

307
00:11:23,800 --> 00:11:24,910
this thing right so these are all

308
00:11:24,910 --> 00:11:27,370
developer to find but again when you're

309
00:11:27,370 --> 00:11:29,950
talking about fuzzing you know these are

310
00:11:29,950 --> 00:11:32,800
important because this is how you kind

311
00:11:32,800 --> 00:11:34,180
of tell the driver what's actually do

312
00:11:34,180 --> 00:11:36,310
right so this is kind of your first

313
00:11:36,310 --> 00:11:37,210
entry point when you talk about

314
00:11:37,210 --> 00:11:39,310
assessing these things and then like I

315
00:11:39,310 --> 00:11:40,720
said that kind of only thing for members

316
00:11:40,720 --> 00:11:42,850
that they're all they're all specific to

317
00:11:42,850 --> 00:11:49,210
a particular driver so in terms of sort

318
00:11:49,210 --> 00:11:51,040
of device driver vulnerabilities I think

319
00:11:51,040 --> 00:11:52,690
it's kind of an interesting class of

320
00:11:52,690 --> 00:11:54,940
software to look at because you know

321
00:11:54,940 --> 00:11:57,430
even if you argue that like they're not

322
00:11:57,430 --> 00:12:00,820
super critical device driver vendors and

323
00:12:00,820 --> 00:12:02,920
authors they do a lot of dumb stuff so

324
00:12:02,920 --> 00:12:05,440
you you kind of have all of the usual

325
00:12:05,440 --> 00:12:07,720
bugs you have stack overflows and

326
00:12:07,720 --> 00:12:09,820
integer issues and things like that but

327
00:12:09,820 --> 00:12:11,400
you also have stuff we're like just

328
00:12:11,400 --> 00:12:13,990
people that don't understand how

329
00:12:13,990 --> 00:12:15,550
security works or how the operating

330
00:12:15,550 --> 00:12:17,800
system works just like turning security

331
00:12:17,800 --> 00:12:20,200
features on and off or you know there

332
00:12:20,200 --> 00:12:21,580
was a pretty popular one that came out

333
00:12:21,580 --> 00:12:23,140
in like a game driver where they would

334
00:12:23,140 --> 00:12:25,000
just turn off kind of OS mitigation so

335
00:12:25,000 --> 00:12:26,410
they could run an arbitrary function a

336
00:12:26,410 --> 00:12:28,600
you know it's so you kind of have this

337
00:12:28,600 --> 00:12:32,350
situation where in addition to all the

338
00:12:32,350 --> 00:12:33,730
usual stuff you would look at when

339
00:12:33,730 --> 00:12:35,530
you're doing exploitation you also have

340
00:12:35,530 --> 00:12:36,940
like a bunch of dumb stuff that's just

341
00:12:36,940 --> 00:12:39,280
you know kind of cool and we'll talk a

342
00:12:39,280 --> 00:12:40,510
little bit about kind of what I think

343
00:12:40,510 --> 00:12:42,340
the impact of this is it's kind of like

344
00:12:42,340 --> 00:12:45,280
a it'll be a soapbox moment for me

345
00:12:45,280 --> 00:12:48,070
basically but you know it's one of those

346
00:12:48,070 --> 00:12:50,890
things where it is very clear once you

347
00:12:50,890 --> 00:12:52,450
start assessing these that a lot of

348
00:12:52,450 --> 00:12:54,880
people do not understand sort of what

349
00:12:54,880 --> 00:12:56,320
not they understand what they're doing

350
00:12:56,320 --> 00:12:59,770
but they don't understand why it's bad

351
00:12:59,770 --> 00:13:03,490
kind of thing so the specific bug we're

352
00:13:03,490 --> 00:13:06,280
gonna talk about is unfiltered

353
00:13:06,280 --> 00:13:08,020
unmitigated access to kind of a critical

354
00:13:08,020 --> 00:13:10,270
system resource which if you've been

355
00:13:10,270 --> 00:13:12,910
following the title of the talk is this

356
00:13:12,910 --> 00:13:15,150
thing called mono specific registers so

357
00:13:15,150 --> 00:13:17,080
I'm gonna go over a little bit about

358
00:13:17,080 --> 00:13:20,440
what they are what they're for and then

359
00:13:20,440 --> 00:13:21,370
we're gonna talk about what the actual

360
00:13:21,370 --> 00:13:22,130
exploitation

361
00:13:22,130 --> 00:13:25,340
Kanak looks like so a mono specific

362
00:13:25,340 --> 00:13:30,470
register or an MSR or CPU like basically

363
00:13:30,470 --> 00:13:32,180
there's special registers in different

364
00:13:32,180 --> 00:13:36,340
processors that do hardware maintenance

365
00:13:36,340 --> 00:13:39,650
stuff right so you know Intel kind of

366
00:13:39,650 --> 00:13:41,510
has their own set AMD has their own set

367
00:13:41,510 --> 00:13:43,460
and then most of them are our

368
00:13:43,460 --> 00:13:45,680
agreed-upon but basically it's dependent

369
00:13:45,680 --> 00:13:48,440
on the vendor to say like what can my

370
00:13:48,440 --> 00:13:53,000
processor support then when you're

371
00:13:53,000 --> 00:13:54,410
actually like using them and what are

372
00:13:54,410 --> 00:13:56,589
they for

373
00:13:57,370 --> 00:13:59,120
like I said they handle kind of

374
00:13:59,120 --> 00:14:00,920
low-level like hardware management

375
00:14:00,920 --> 00:14:02,960
maintenance stuff so if you've ever

376
00:14:02,960 --> 00:14:04,820
overclocked a processor you can do some

377
00:14:04,820 --> 00:14:07,700
of that with an MSR temperature checks

378
00:14:07,700 --> 00:14:11,060
you can do that with an MSR intel has

379
00:14:11,060 --> 00:14:13,280
like a branch tracing thing so you can

380
00:14:13,280 --> 00:14:15,680
see I ran this application what kind of

381
00:14:15,680 --> 00:14:17,060
path did it take that's all done with an

382
00:14:17,060 --> 00:14:19,490
MSR and the one that we really care

383
00:14:19,490 --> 00:14:21,950
about is when you make a system call so

384
00:14:21,950 --> 00:14:24,530
if you're not familiar system calls are

385
00:14:24,530 --> 00:14:26,090
kind of the mechanism to go from user

386
00:14:26,090 --> 00:14:29,270
mode to kernel mode the function

387
00:14:29,270 --> 00:14:31,130
responsible for handling that system

388
00:14:31,130 --> 00:14:33,890
call is also present in MSRs

389
00:14:33,890 --> 00:14:35,630
right so that's kind of the that's why

390
00:14:35,630 --> 00:14:37,940
it's in red that's kind of that's what

391
00:14:37,940 --> 00:14:39,170
I'm going to talk about for most of this

392
00:14:39,170 --> 00:14:40,490
talk like that's where the issue is

393
00:14:40,490 --> 00:14:42,380
right because like I said they're kind

394
00:14:42,380 --> 00:14:45,440
of low level sort of OS management stuff

395
00:14:45,440 --> 00:14:47,810
right then if you have a kernel debugger

396
00:14:47,810 --> 00:14:50,210
attached or Llorona system you can use

397
00:14:50,210 --> 00:14:51,920
these two commands I have at the bottom

398
00:14:51,920 --> 00:14:54,110
to read and write them so you can kind

399
00:14:54,110 --> 00:14:55,280
of poke around and see what they are and

400
00:14:55,280 --> 00:14:56,420
I'm going to show you what it looks like

401
00:14:56,420 --> 00:15:00,020
in a second but just to make sure we're

402
00:15:00,020 --> 00:15:02,510
all on the same page this is kind of

403
00:15:02,510 --> 00:15:04,670
like I said create files like the most

404
00:15:04,670 --> 00:15:06,770
sort of common API call in Windows right

405
00:15:06,770 --> 00:15:10,040
so this staircase thing shows you sort

406
00:15:10,040 --> 00:15:11,960
of the life cycle of what happens when

407
00:15:11,960 --> 00:15:13,850
you actually say create file read file

408
00:15:13,850 --> 00:15:16,760
write file whatever and most of it we

409
00:15:16,760 --> 00:15:18,560
can ignore for this talk but you know at

410
00:15:18,560 --> 00:15:20,900
a high level basically most of these

411
00:15:20,900 --> 00:15:23,840
api's come from kernel 32 and then the

412
00:15:23,840 --> 00:15:25,640
implementation for them is an other sort

413
00:15:25,640 --> 00:15:26,870
of system dll that you probably won't

414
00:15:26,870 --> 00:15:29,030
call directly right so if I call create

415
00:15:29,030 --> 00:15:32,480
file a it'll go from kernel32 to kernel

416
00:15:32,480 --> 00:15:33,680
base which is a sort of an

417
00:15:33,680 --> 00:15:35,360
implementation layer for a lot of these

418
00:15:35,360 --> 00:15:36,140
and it'll keep

419
00:15:36,140 --> 00:15:37,820
down and it'll translate for me ask you

420
00:15:37,820 --> 00:15:38,960
to unicode and do all this other stuff

421
00:15:38,960 --> 00:15:41,210
but at the end of the day the bottom of

422
00:15:41,210 --> 00:15:44,960
this slide says you know anti DLL dot

423
00:15:44,960 --> 00:15:49,790
anti create file the exports in this dll

424
00:15:49,790 --> 00:15:51,410
are only responsible for making system

425
00:15:51,410 --> 00:15:53,660
calls basically so if you look at the

426
00:15:53,660 --> 00:15:55,160
disassembly of one of these functions

427
00:15:55,160 --> 00:15:56,180
which i'll show you in a second

428
00:15:56,180 --> 00:15:58,520
basically all they do is say like you

429
00:15:58,520 --> 00:16:00,350
called NT create file here's the system

430
00:16:00,350 --> 00:16:02,660
call number off we go

431
00:16:02,660 --> 00:16:04,040
right so Windows is a little different

432
00:16:04,040 --> 00:16:06,710
from Linux because Windows system call

433
00:16:06,710 --> 00:16:08,630
numbers change pretty frequently which

434
00:16:08,630 --> 00:16:11,540
Linux doesn't really do right so auntie

435
00:16:11,540 --> 00:16:13,310
DLL is kind of the thing you're supposed

436
00:16:13,310 --> 00:16:14,990
to use to actually do system calls

437
00:16:14,990 --> 00:16:16,700
because that DLL will be updated and

438
00:16:16,700 --> 00:16:18,500
it'll have the right number in it for

439
00:16:18,500 --> 00:16:22,690
whatever version of Windows you're on so

440
00:16:22,690 --> 00:16:25,760
like I mentioned on the last two slides

441
00:16:25,760 --> 00:16:28,040
the transition from user space to kernel

442
00:16:28,040 --> 00:16:30,650
space is done via at MSR the MSR that I

443
00:16:30,650 --> 00:16:32,990
have listed on this slide are all

444
00:16:32,990 --> 00:16:35,300
responsible for handling system calls in

445
00:16:35,300 --> 00:16:36,950
sort of different scenarios right so

446
00:16:36,950 --> 00:16:39,050
we're really only gonna talk about the

447
00:16:39,050 --> 00:16:41,150
top one or sorry the second one I guess

448
00:16:41,150 --> 00:16:43,130
so that 82 MSR because that's kind of

449
00:16:43,130 --> 00:16:45,860
the default one but the other MSR that I

450
00:16:45,860 --> 00:16:48,200
have listed are responsible for like if

451
00:16:48,200 --> 00:16:49,820
you're running in compatibility mode on

452
00:16:49,820 --> 00:16:51,170
the system or something so you have like

453
00:16:51,170 --> 00:16:53,300
kind of old legacy 32-bit code on a

454
00:16:53,300 --> 00:16:56,000
64-bit system that's where those come

455
00:16:56,000 --> 00:16:57,890
into play and then like I said you can

456
00:16:57,890 --> 00:17:00,110
use is our DMS our instruction to read

457
00:17:00,110 --> 00:17:02,000
them and inspect them with a to see what

458
00:17:02,000 --> 00:17:04,190
they should normally look like so what

459
00:17:04,190 --> 00:17:06,770
will end up happening is what I have on

460
00:17:06,770 --> 00:17:09,470
this slide so you see we have this ZW

461
00:17:09,470 --> 00:17:11,030
crate file which if you're familiar with

462
00:17:11,030 --> 00:17:13,339
Windows in userspace it's the same thing

463
00:17:13,339 --> 00:17:15,740
as anti cray file which I showed in the

464
00:17:15,740 --> 00:17:18,050
last slide if you look at that exported

465
00:17:18,050 --> 00:17:19,730
function that corresponds to the create

466
00:17:19,730 --> 00:17:21,380
file call you can see that that's it

467
00:17:21,380 --> 00:17:23,140
that's three instructions and that's how

468
00:17:23,140 --> 00:17:26,329
that's how mostly every export from anti

469
00:17:26,329 --> 00:17:28,520
DLL looks right so we load a sis call

470
00:17:28,520 --> 00:17:31,670
number which is that hex 52 that goes

471
00:17:31,670 --> 00:17:33,320
into EAX and then we issue this call

472
00:17:33,320 --> 00:17:35,900
instruction then when the processor sees

473
00:17:35,900 --> 00:17:38,570
that instruction it goes and it reads

474
00:17:38,570 --> 00:17:42,050
from C 0 0 0 0 82 it finds whatever

475
00:17:42,050 --> 00:17:44,000
handler is responsible for running

476
00:17:44,000 --> 00:17:45,110
that's this call and it goes and

477
00:17:45,110 --> 00:17:48,230
transitions execution there so it's you

478
00:17:48,230 --> 00:17:49,190
know we're going to talk about this when

479
00:17:49,190 --> 00:17:49,940
we talk about

480
00:17:49,940 --> 00:17:52,120
how to kind of exploit these issues but

481
00:17:52,120 --> 00:17:54,590
this is kind of like a direct transition

482
00:17:54,590 --> 00:17:56,419
like the the CPU is like oh I'm just in

483
00:17:56,419 --> 00:17:58,370
I'm just in kernel mode now right like

484
00:17:58,370 --> 00:18:01,100
I'm calling this function so it's ki

485
00:18:01,100 --> 00:18:04,009
system calling 64 his job to do some of

486
00:18:04,009 --> 00:18:07,129
the kind of spin up work to say what you

487
00:18:07,129 --> 00:18:08,690
know the kernel has its own stack and

488
00:18:08,690 --> 00:18:10,159
its own kind of contacts and things like

489
00:18:10,159 --> 00:18:11,419
that so that that function is

490
00:18:11,419 --> 00:18:13,190
responsible for doing all of that and

491
00:18:13,190 --> 00:18:17,870
then figuring out what oh X 52 means and

492
00:18:17,870 --> 00:18:19,580
what function it should actually go call

493
00:18:19,580 --> 00:18:20,870
it a hand or whatever the system call

494
00:18:20,870 --> 00:18:27,590
was so I don't think it's too much of a

495
00:18:27,590 --> 00:18:29,809
plot twist if you've been following the

496
00:18:29,809 --> 00:18:31,309
breadcrumbs and the rest of the slide

497
00:18:31,309 --> 00:18:33,950
but the issue that we're talking about

498
00:18:33,950 --> 00:18:37,059
for this presentation is that

499
00:18:37,059 --> 00:18:40,429
essentially any access Emma SARS is all

500
00:18:40,429 --> 00:18:42,470
done you need to be running in ring zero

501
00:18:42,470 --> 00:18:43,909
so you need to be running in kernel mode

502
00:18:43,909 --> 00:18:45,620
to be able to execute the actual

503
00:18:45,620 --> 00:18:47,570
assembly instructions that correspond

504
00:18:47,570 --> 00:18:50,240
with that our DMS R and W RMS are

505
00:18:50,240 --> 00:18:53,269
commanded window bug so the issue is

506
00:18:53,269 --> 00:18:56,480
basically I don't know if it's people

507
00:18:56,480 --> 00:18:58,669
didn't understand what the impact was

508
00:18:58,669 --> 00:19:02,360
you know second but the issues we have a

509
00:19:02,360 --> 00:19:04,360
bunch of these device drivers that

510
00:19:04,360 --> 00:19:08,269
expose this instruction just willy-nilly

511
00:19:08,269 --> 00:19:10,909
right so if you think like like I said a

512
00:19:10,909 --> 00:19:12,529
lot of this comes into play with like

513
00:19:12,529 --> 00:19:14,240
overclocking software because you could

514
00:19:14,240 --> 00:19:15,590
tweak voltages and things like that

515
00:19:15,590 --> 00:19:17,990
using one of these MSRs so what it looks

516
00:19:17,990 --> 00:19:19,460
like on the backend is you have this

517
00:19:19,460 --> 00:19:21,440
binary running and ring 0 and on the

518
00:19:21,440 --> 00:19:23,450
slide here I've shown sort of a subset

519
00:19:23,450 --> 00:19:26,539
of the command handler for that device

520
00:19:26,539 --> 00:19:28,370
IO control function and you can see that

521
00:19:28,370 --> 00:19:30,049
we just kind of whatever you pass in

522
00:19:30,049 --> 00:19:33,529
they just call arbitrary MSR writes

523
00:19:33,529 --> 00:19:36,110
arbitrary MSR reads you can kind of set

524
00:19:36,110 --> 00:19:38,389
in any MSR to anything that you want

525
00:19:38,389 --> 00:19:43,909
right so once you do that once you if

526
00:19:43,909 --> 00:19:45,590
you kind of combine that well we talked

527
00:19:45,590 --> 00:19:47,840
about in the past couple slides if they

528
00:19:47,840 --> 00:19:49,730
don't filter the MSR access then you can

529
00:19:49,730 --> 00:19:51,019
basically overwrite the system call

530
00:19:51,019 --> 00:19:53,179
Handler and then now you can that's how

531
00:19:53,179 --> 00:19:54,769
you get to rings their execution so once

532
00:19:54,769 --> 00:19:57,110
you execute a system call it goes to

533
00:19:57,110 --> 00:19:59,119
your overwritten callback function

534
00:19:59,119 --> 00:20:00,619
instead of whatever the OS kind of has

535
00:20:00,619 --> 00:20:02,440
pre can't to do

536
00:20:02,440 --> 00:20:05,870
so in terms of impact we redo a couple

537
00:20:05,870 --> 00:20:08,060
slides in terms like what I think sort

538
00:20:08,060 --> 00:20:10,640
of the severity of this is but this

539
00:20:10,640 --> 00:20:14,090
issue where this bug was found we found

540
00:20:14,090 --> 00:20:16,600
it in 20 drivers it's probably in more

541
00:20:16,600 --> 00:20:21,770
in a lot of cases it looks like the code

542
00:20:21,770 --> 00:20:23,960
was almost reused so that either tells

543
00:20:23,960 --> 00:20:25,280
me it's coming from like a standard

544
00:20:25,280 --> 00:20:28,070
library somewhere or people just didn't

545
00:20:28,070 --> 00:20:29,510
consider it a security issue so they

546
00:20:29,510 --> 00:20:32,360
just went ahead and did it right so in a

547
00:20:32,360 --> 00:20:34,160
lot of cases this is in like

548
00:20:34,160 --> 00:20:37,580
overclocking software or like device

549
00:20:37,580 --> 00:20:39,050
management stuff that you would get from

550
00:20:39,050 --> 00:20:41,120
like a laptop vendor so some of they

551
00:20:41,120 --> 00:20:45,320
came pre-installed some of it you know

552
00:20:45,320 --> 00:20:47,540
some of it we like is from like sort of

553
00:20:47,540 --> 00:20:49,190
big-name hardware people and I'm not

554
00:20:49,190 --> 00:20:50,720
gonna talk about specific bugs here to

555
00:20:50,720 --> 00:20:53,480
call anybody out but in a lot of cases

556
00:20:53,480 --> 00:20:57,560
if you went by sort of just like the

557
00:20:57,560 --> 00:20:59,180
amount of work we had to do to translate

558
00:20:59,180 --> 00:21:00,680
from one bug to the next it was just

559
00:21:00,680 --> 00:21:03,080
there was no filter all the input was

560
00:21:03,080 --> 00:21:04,490
always the same so we kind of had this

561
00:21:04,490 --> 00:21:06,350
implementation where it was like I could

562
00:21:06,350 --> 00:21:09,230
run one exploit and just by changing the

563
00:21:09,230 --> 00:21:10,940
name of the driver that I was talking to

564
00:21:10,940 --> 00:21:12,320
and one of those numbers that we talked

565
00:21:12,320 --> 00:21:13,640
about it would work exactly the same

566
00:21:13,640 --> 00:21:15,410
across sort of all of these these

567
00:21:15,410 --> 00:21:19,040
devices so at a glance so like I said

568
00:21:19,040 --> 00:21:21,490
20-plus drivers if you went by download

569
00:21:21,490 --> 00:21:23,810
numbers we're talking hundreds of

570
00:21:23,810 --> 00:21:26,960
millions of devices some of them were

571
00:21:26,960 --> 00:21:29,210
default installed on like I said there

572
00:21:29,210 --> 00:21:31,520
would be device management software with

573
00:21:31,520 --> 00:21:33,020
your hardware when you bought a new

574
00:21:33,020 --> 00:21:35,510
laptop or whatever out of the twenty

575
00:21:35,510 --> 00:21:37,160
that we're talking about today fourteen

576
00:21:37,160 --> 00:21:38,960
of them use the exact same format so

577
00:21:38,960 --> 00:21:39,740
that's what I was talking about before

578
00:21:39,740 --> 00:21:42,290
so I change what device I'm talking to

579
00:21:42,290 --> 00:21:43,580
and I change whatever that special

580
00:21:43,580 --> 00:21:45,440
number is but then my input is all the

581
00:21:45,440 --> 00:21:47,960
same so you could just do a big switch

582
00:21:47,960 --> 00:21:50,090
case it you could essentially own all of

583
00:21:50,090 --> 00:21:52,820
these drivers with like no additional

584
00:21:52,820 --> 00:21:56,690
effort right so one of the things that

585
00:21:56,690 --> 00:21:57,470
I'm going to talk about on the next

586
00:21:57,470 --> 00:22:02,570
slide is a lot of them well I guess half

587
00:22:02,570 --> 00:22:04,610
right some of them require to

588
00:22:04,610 --> 00:22:06,290
administrator access to kind of access

589
00:22:06,290 --> 00:22:08,600
these things so it's super bad if they

590
00:22:08,600 --> 00:22:10,250
didn't do this right because now you can

591
00:22:10,250 --> 00:22:12,140
have an unprivileged user just executing

592
00:22:12,140 --> 00:22:13,810
arbitrary ring zero code

593
00:22:13,810 --> 00:22:15,970
about half of them had some kind of

594
00:22:15,970 --> 00:22:18,400
access control when you actually open

595
00:22:18,400 --> 00:22:22,720
the handle to talk to a device but that

596
00:22:22,720 --> 00:22:24,700
was you know that we're gonna say I'm

597
00:22:24,700 --> 00:22:26,110
gonna say that's not sufficient so

598
00:22:26,110 --> 00:22:28,990
that's that's the way it goes right and

599
00:22:28,990 --> 00:22:30,010
then one of them was fixed bits and

600
00:22:30,010 --> 00:22:32,710
reported it and another one tried to

601
00:22:32,710 --> 00:22:34,750
filter these are Massaro accesses but

602
00:22:34,750 --> 00:22:36,430
they're filter function had a different

603
00:22:36,430 --> 00:22:37,810
vulnerability in it so you could still

604
00:22:37,810 --> 00:22:40,870
chain it together so again you know if

605
00:22:40,870 --> 00:22:43,480
we're talking about 20 you say four to

606
00:22:43,480 --> 00:22:45,070
six of them had some kind of extra

607
00:22:45,070 --> 00:22:47,050
effort put in but like I said that the

608
00:22:47,050 --> 00:22:49,270
big punchline for us was it's the same

609
00:22:49,270 --> 00:22:51,760
code same bug the same exploit and you

610
00:22:51,760 --> 00:22:53,830
just you can just blast it to all these

611
00:22:53,830 --> 00:22:55,630
hardware vendors and we're all it would

612
00:22:55,630 --> 00:22:58,620
all work easy-peasy

613
00:22:58,750 --> 00:23:02,830
so to kind of drive that home this is

614
00:23:02,830 --> 00:23:05,940
this is our structures that we used for

615
00:23:05,940 --> 00:23:07,930
when we're actually exploiting the bug

616
00:23:07,930 --> 00:23:09,390
so at the top of the slide you'll see

617
00:23:09,390 --> 00:23:14,260
these are the sort of the data formats

618
00:23:14,260 --> 00:23:15,700
that all these device drivers accepted

619
00:23:15,700 --> 00:23:18,010
so we use these across like every

620
00:23:18,010 --> 00:23:21,340
exploit that we did and so because the

621
00:23:21,340 --> 00:23:24,940
bug was so similar and like I said

622
00:23:24,940 --> 00:23:28,000
either a library or people just didn't

623
00:23:28,000 --> 00:23:29,710
think it was an issue we could just

624
00:23:29,710 --> 00:23:31,540
reuse this across every every driver so

625
00:23:31,540 --> 00:23:33,280
in terms of like an exploitation thing

626
00:23:33,280 --> 00:23:34,660
like this is pretty good right because

627
00:23:34,660 --> 00:23:36,250
it's just I have one function and it

628
00:23:36,250 --> 00:23:38,650
always gives me a ring zero callback and

629
00:23:38,650 --> 00:23:40,270
then the second half of this

630
00:23:40,270 --> 00:23:41,650
presentation is sort of all the

631
00:23:41,650 --> 00:23:43,150
difficulties that go along with actually

632
00:23:43,150 --> 00:23:45,880
exploit it but the the bug triggering

633
00:23:45,880 --> 00:23:48,070
half of it is super easy right so this

634
00:23:48,070 --> 00:23:50,740
is our input data and that right atmos

635
00:23:50,740 --> 00:23:52,600
our function is the one over rights for

636
00:23:52,600 --> 00:23:59,590
all of these drivers so like I said is

637
00:23:59,590 --> 00:24:03,910
really quick like I said the the

638
00:24:03,910 --> 00:24:05,740
exposure tended to be overclocking

639
00:24:05,740 --> 00:24:08,200
software device management stuff there's

640
00:24:08,200 --> 00:24:09,610
some other something like firmware kind

641
00:24:09,610 --> 00:24:11,320
of low-level Hardware interactions like

642
00:24:11,320 --> 00:24:13,330
all of those were vulnerable the same

643
00:24:13,330 --> 00:24:16,690
issues and the same kinds of problems in

644
00:24:16,690 --> 00:24:18,670
terms of administrator access this is

645
00:24:18,670 --> 00:24:20,560
the only time I'm gonna soapbox for this

646
00:24:20,560 --> 00:24:26,110
talk right but multiple vendors when we

647
00:24:26,110 --> 00:24:26,860
reported

648
00:24:26,860 --> 00:24:32,110
said well it is behead but you can't

649
00:24:32,110 --> 00:24:33,490
talk to our device if you're not already

650
00:24:33,490 --> 00:24:34,840
at an administrator and kind of the

651
00:24:34,840 --> 00:24:37,809
freaking the pre-canned line is well if

652
00:24:37,809 --> 00:24:39,250
you're an administrator you can do

653
00:24:39,250 --> 00:24:41,020
whatever you want right like you can

654
00:24:41,020 --> 00:24:42,460
reboot the system you can turn off our

655
00:24:42,460 --> 00:24:44,620
security product or whatever it is so

656
00:24:44,620 --> 00:24:48,309
they I don't say they were resistant but

657
00:24:48,309 --> 00:24:49,450
they were like isn't it's kind of good

658
00:24:49,450 --> 00:24:52,390
enough but from our perspective like I

659
00:24:52,390 --> 00:24:54,910
said we've already seen things like apt

660
00:24:54,910 --> 00:24:57,460
groups use sign drivers to avoid

661
00:24:57,460 --> 00:24:59,350
detection or to have a ring zero

662
00:24:59,350 --> 00:25:01,500
callback or to install a rootkit or they

663
00:25:01,500 --> 00:25:04,870
you have all this kind of exposed like

664
00:25:04,870 --> 00:25:08,260
surface where in my mind if I was a

665
00:25:08,260 --> 00:25:09,820
defender or I was a system administrator

666
00:25:09,820 --> 00:25:11,830
there's a pretty big difference between

667
00:25:11,830 --> 00:25:14,830
I have admin so I turned your security

668
00:25:14,830 --> 00:25:16,660
product off and rebooted your system

669
00:25:16,660 --> 00:25:19,630
versus I have admin and I can silently

670
00:25:19,630 --> 00:25:21,400
install my rootkit and you won't see any

671
00:25:21,400 --> 00:25:22,660
alerts because like I said the big

672
00:25:22,660 --> 00:25:24,130
punchline is once you're in ring zero

673
00:25:24,130 --> 00:25:26,620
you're at parity with all security

674
00:25:26,620 --> 00:25:27,910
products in the system which means you

675
00:25:27,910 --> 00:25:30,520
can avoid them because you know it's

676
00:25:30,520 --> 00:25:33,010
kind of like a you know a rat race in a

677
00:25:33,010 --> 00:25:34,690
way right but attackers always win that

678
00:25:34,690 --> 00:25:37,470
battle when you're on equal ground so

679
00:25:37,470 --> 00:25:41,679
that happened quite a few times and you

680
00:25:41,679 --> 00:25:44,309
know kind of our sort of summary is that

681
00:25:44,309 --> 00:25:46,600
security boundaries when you're going

682
00:25:46,600 --> 00:25:49,120
from you know user mode to ring zero or

683
00:25:49,120 --> 00:25:50,980
whatever it's kind of weird on Windows

684
00:25:50,980 --> 00:25:53,160
because officially you need to have a

685
00:25:53,160 --> 00:25:56,559
code signature to run sort of like load

686
00:25:56,559 --> 00:25:58,929
a driver on modern Windows systems but a

687
00:25:58,929 --> 00:26:00,429
lot of people don't consider that as a

688
00:26:00,429 --> 00:26:01,929
security boundary for whatever reason

689
00:26:01,929 --> 00:26:03,730
and I think that's one of the things

690
00:26:03,730 --> 00:26:05,740
it's one of the takeaways where we kind

691
00:26:05,740 --> 00:26:07,000
of had to update how we think about

692
00:26:07,000 --> 00:26:09,820
these issues because if you're looking

693
00:26:09,820 --> 00:26:12,220
to defend from sophisticated attackers

694
00:26:12,220 --> 00:26:14,530
things like sign driver loads that are

695
00:26:14,530 --> 00:26:19,390
being exploited are they're not super

696
00:26:19,390 --> 00:26:21,130
common in terms of an attack toolkit or

697
00:26:21,130 --> 00:26:23,320
a chain or whatever but if they do

698
00:26:23,320 --> 00:26:24,700
happen like I said they can kind of

699
00:26:24,700 --> 00:26:26,410
silently avoid all of your products and

700
00:26:26,410 --> 00:26:30,250
then like then you're super hosed so so

701
00:26:30,250 --> 00:26:31,600
yeah basically that the punchline for

702
00:26:31,600 --> 00:26:33,760
this slide is Microsoft doesn't really

703
00:26:33,760 --> 00:26:35,080
consider admin a system of security

704
00:26:35,080 --> 00:26:37,000
boundary but in sort of the modern

705
00:26:37,000 --> 00:26:39,070
landscape that we live in at all

706
00:26:39,070 --> 00:26:43,710
probably sufficient right so I'm gonna

707
00:26:43,710 --> 00:26:46,929
go over so so far I've talked about the

708
00:26:46,929 --> 00:26:48,940
bug what it means how you communicate

709
00:26:48,940 --> 00:26:50,110
with the device driver how you trigger

710
00:26:50,110 --> 00:26:53,500
it I want to go over sort of the

711
00:26:53,500 --> 00:26:55,450
workflow that we use to actually exploit

712
00:26:55,450 --> 00:26:57,490
this because why me one I feel like a

713
00:26:57,490 --> 00:26:59,740
lot of places will just say like oh this

714
00:26:59,740 --> 00:27:01,360
this bug gives you an arbitrary right

715
00:27:01,360 --> 00:27:03,159
and you can use that to you know do

716
00:27:03,159 --> 00:27:05,559
remote code execution or whatever so I

717
00:27:05,559 --> 00:27:07,690
wanted to walk through sort of a baby's

718
00:27:07,690 --> 00:27:09,309
first how to do device driver

719
00:27:09,309 --> 00:27:11,080
exploitation so if you have one of these

720
00:27:11,080 --> 00:27:13,149
bugs you can kind of understand you know

721
00:27:13,149 --> 00:27:15,070
mechanically what you need to do and

722
00:27:15,070 --> 00:27:16,600
then also what you'll see when I go

723
00:27:16,600 --> 00:27:19,120
through these slides is kind of our

724
00:27:19,120 --> 00:27:21,789
thought process because every Windows

725
00:27:21,789 --> 00:27:23,889
version added a little bit of trouble or

726
00:27:23,889 --> 00:27:26,320
pain or whatever so how do we tweak our

727
00:27:26,320 --> 00:27:28,779
payload across stuff to kind of make

728
00:27:28,779 --> 00:27:31,450
sure we're we were running on any OS

729
00:27:31,450 --> 00:27:33,009
because like I said the device driver

730
00:27:33,009 --> 00:27:34,389
like that's where the bug is right so

731
00:27:34,389 --> 00:27:36,129
you're not tied to Windows 7 or Windows

732
00:27:36,129 --> 00:27:38,320
10 or whatever but when you're running

733
00:27:38,320 --> 00:27:39,940
on those operating systems you have kind

734
00:27:39,940 --> 00:27:44,139
of extra work you need to do so I'm a

735
00:27:44,139 --> 00:27:47,350
little short for this half but I'll go

736
00:27:47,350 --> 00:27:49,570
relatively quickly so feel free to yell

737
00:27:49,570 --> 00:27:51,039
out questions or we can talk after or

738
00:27:51,039 --> 00:27:53,529
whatever but basically when you have a

739
00:27:53,529 --> 00:27:56,080
professed bug on Windows on surprise

740
00:27:56,080 --> 00:27:57,879
like many exploits you'll use shell code

741
00:27:57,879 --> 00:27:59,919
right the kernel shell code that you're

742
00:27:59,919 --> 00:28:01,990
gonna write is a little different if

743
00:28:01,990 --> 00:28:03,549
you've ever done like an RCE bug or

744
00:28:03,549 --> 00:28:05,259
anything like that there's some things

745
00:28:05,259 --> 00:28:07,059
that are easier to do for an LP and

746
00:28:07,059 --> 00:28:08,830
there's some things that are harder to

747
00:28:08,830 --> 00:28:13,029
do most most bugs you see out there that

748
00:28:13,029 --> 00:28:15,279
are LP ease the shell code tends to do

749
00:28:15,279 --> 00:28:17,649
something like a like a token swap or to

750
00:28:17,649 --> 00:28:19,120
give your system privileges or whatever

751
00:28:19,120 --> 00:28:21,580
what we're gonna talk about is that's

752
00:28:21,580 --> 00:28:26,559
fine but for again if we're emulating

753
00:28:26,559 --> 00:28:28,149
like a sophisticated attacker we

754
00:28:28,149 --> 00:28:29,440
probably want to do something kind of

755
00:28:29,440 --> 00:28:32,950
more involved right so for this next

756
00:28:32,950 --> 00:28:34,809
couple slides the payload that we're

757
00:28:34,809 --> 00:28:36,700
writing is something that's capable of

758
00:28:36,700 --> 00:28:38,350
like reflectively loading a rootkit

759
00:28:38,350 --> 00:28:40,690
binary so you'll be able to do whatever

760
00:28:40,690 --> 00:28:42,789
you want once you're in ring zero and

761
00:28:42,789 --> 00:28:45,279
what that means from a practical

762
00:28:45,279 --> 00:28:47,529
perspective is when you're running a

763
00:28:47,529 --> 00:28:50,620
bigger payload you also run into more

764
00:28:50,620 --> 00:28:52,200
stability issues

765
00:28:52,200 --> 00:28:54,450
for for various reasons so that's why

766
00:28:54,450 --> 00:28:55,860
we're kind of doing a deep dive in terms

767
00:28:55,860 --> 00:28:57,690
of like well this happens when you do

768
00:28:57,690 --> 00:28:59,549
this and how do we craft our payload to

769
00:28:59,549 --> 00:29:03,360
say like you know 99.99% accuracy or

770
00:29:03,360 --> 00:29:07,080
whatever so that's kind of what this

771
00:29:07,080 --> 00:29:11,760
slide is saying but these next couple

772
00:29:11,760 --> 00:29:13,889
bullets are all of the things that we

773
00:29:13,889 --> 00:29:16,110
need to worry about when we're going and

774
00:29:16,110 --> 00:29:17,850
we're saying hey we can trigger out on

775
00:29:17,850 --> 00:29:20,370
Windows 7 it's really easy but what we

776
00:29:20,370 --> 00:29:22,799
found was as new versions kept coming

777
00:29:22,799 --> 00:29:24,090
out we kept bumping up into like

778
00:29:24,090 --> 00:29:25,590
slightly different stuff and it was

779
00:29:25,590 --> 00:29:27,809
never you know a direct bitte Gatien for

780
00:29:27,809 --> 00:29:29,399
our vulnerabilities but it made our

781
00:29:29,399 --> 00:29:31,019
payloads like a lot harder to kind of

782
00:29:31,019 --> 00:29:32,580
write so I'm gonna walk through each

783
00:29:32,580 --> 00:29:37,860
step the next couple slides most pocs

784
00:29:37,860 --> 00:29:40,649
like I said sorry like I said most pcs

785
00:29:40,649 --> 00:29:43,289
are gonna stop a token swaps so I can

786
00:29:43,289 --> 00:29:45,330
just drive at home if you've never

787
00:29:45,330 --> 00:29:46,679
written one of these exploits like a

788
00:29:46,679 --> 00:29:48,450
token swap is a super easy payload to

789
00:29:48,450 --> 00:29:50,130
write like it's only you know it's not

790
00:29:50,130 --> 00:29:52,380
that many in terms of like size or

791
00:29:52,380 --> 00:29:55,049
assembly instructions or whatever when

792
00:29:55,049 --> 00:29:56,850
we're exporting these bugs in particular

793
00:29:56,850 --> 00:30:00,059
if you remember what I said was once you

794
00:30:00,059 --> 00:30:01,409
do this just call instruction you're

795
00:30:01,409 --> 00:30:03,990
automatically in ring 0 but ring 0 is

796
00:30:03,990 --> 00:30:05,399
not the same thing as you're running in

797
00:30:05,399 --> 00:30:07,320
kernel space right because normally the

798
00:30:07,320 --> 00:30:09,299
system call handler has to do all of the

799
00:30:09,299 --> 00:30:11,490
stuff to handle the transition from user

800
00:30:11,490 --> 00:30:13,769
to kernel mode and because this

801
00:30:13,769 --> 00:30:15,960
primitive is kind of weird we're

802
00:30:15,960 --> 00:30:18,149
executing in ring 0 but we're not like

803
00:30:18,149 --> 00:30:19,380
we have to handle a lot of that work

804
00:30:19,380 --> 00:30:22,649
ourselves basically so in addition to

805
00:30:22,649 --> 00:30:24,809
having our kind of whatever our final

806
00:30:24,809 --> 00:30:26,460
payload is we also have to make sure

807
00:30:26,460 --> 00:30:29,220
that you know we don't go too crazy

808
00:30:29,220 --> 00:30:30,659
because if we don't handle the

809
00:30:30,659 --> 00:30:32,159
transition and kind of the same way that

810
00:30:32,159 --> 00:30:35,220
the operating system expects one of the

811
00:30:35,220 --> 00:30:37,169
other sort of not gotchas but one of the

812
00:30:37,169 --> 00:30:39,389
other extra-spicy pieces of LP ease

813
00:30:39,389 --> 00:30:41,730
right as if you mess up the whole system

814
00:30:41,730 --> 00:30:44,669
goes down right so how do we handle all

815
00:30:44,669 --> 00:30:47,010
of that and how do we be stable so for

816
00:30:47,010 --> 00:30:48,450
Windows 7 is the relatively

817
00:30:48,450 --> 00:30:49,980
straightforward process once you've done

818
00:30:49,980 --> 00:30:51,090
what we've already talked about you

819
00:30:51,090 --> 00:30:53,299
overwrite the system call handler you

820
00:30:53,299 --> 00:30:56,880
basically just that's it like you're

821
00:30:56,880 --> 00:30:58,380
done you kind of like the only thing you

822
00:30:58,380 --> 00:31:00,299
really have to worry about is the

823
00:31:00,299 --> 00:31:01,769
transition that I was just talking about

824
00:31:01,769 --> 00:31:03,539
so we kind of to emulate what the OS

825
00:31:03,539 --> 00:31:05,440
would normally do in you

826
00:31:05,440 --> 00:31:09,039
the kernel mode so from that the other

827
00:31:09,039 --> 00:31:11,799
thing that we have to worry about is a

828
00:31:11,799 --> 00:31:13,629
mess ours are shared per processor for

829
00:31:13,629 --> 00:31:16,090
the whole system right so you know in

830
00:31:16,090 --> 00:31:18,159
like legacy rootkits or whatever that

831
00:31:18,159 --> 00:31:20,409
would be a place where you could hook to

832
00:31:20,409 --> 00:31:23,649
say I want to bob'll install my own

833
00:31:23,649 --> 00:31:24,940
system call handler because what that

834
00:31:24,940 --> 00:31:27,669
means it's like system calls are

835
00:31:27,669 --> 00:31:29,799
responsible for basically any i/o or any

836
00:31:29,799 --> 00:31:31,659
low-level operation on the system so

837
00:31:31,659 --> 00:31:32,649
they're kind of like a one-stop shop

838
00:31:32,649 --> 00:31:34,779
from an analysis perspective because

839
00:31:34,779 --> 00:31:38,529
every application every time they read a

840
00:31:38,529 --> 00:31:40,000
file write a file or whatever it all

841
00:31:40,000 --> 00:31:41,379
calls the same function all goes through

842
00:31:41,379 --> 00:31:43,450
the same mechanism so what this means is

843
00:31:43,450 --> 00:31:46,779
when our payload is running we need to

844
00:31:46,779 --> 00:31:51,100
take some time and care to say between

845
00:31:51,100 --> 00:31:53,110
the point where we overwrite the MSR and

846
00:31:53,110 --> 00:31:55,750
where our payload actually runs anybody

847
00:31:55,750 --> 00:31:56,860
that makes the system call in the middle

848
00:31:56,860 --> 00:31:58,269
will call our function and will

849
00:31:58,269 --> 00:32:00,340
potentially crash right there you know

850
00:32:00,340 --> 00:32:02,110
there's kind of payload things that you

851
00:32:02,110 --> 00:32:03,250
could do to address that but we're gonna

852
00:32:03,250 --> 00:32:04,929
talk about sort of another way to

853
00:32:04,929 --> 00:32:06,639
massage our execution to make sure we

854
00:32:06,639 --> 00:32:09,120
don't like I said break the whole system

855
00:32:09,120 --> 00:32:11,769
and then so that's kind of on the way in

856
00:32:11,769 --> 00:32:14,320
and then we also have this problem of if

857
00:32:14,320 --> 00:32:16,210
I'm handling the transition by the way

858
00:32:16,210 --> 00:32:18,149
into the kernel how do I get out without

859
00:32:18,149 --> 00:32:21,190
again crashing or you know confusing the

860
00:32:21,190 --> 00:32:22,960
system in terms of like where we've been

861
00:32:22,960 --> 00:32:24,789
and then where do we put our code we're

862
00:32:24,789 --> 00:32:28,509
in cycle in a second so another problem

863
00:32:28,509 --> 00:32:32,049
that happens is if you remember our snot

864
00:32:32,049 --> 00:32:33,460
if you remember but I just said that

865
00:32:33,460 --> 00:32:35,529
system calls are shared for the whole

866
00:32:35,529 --> 00:32:39,610
system right so when I'm exploiting this

867
00:32:39,610 --> 00:32:42,490
vulnerability I am in like one process

868
00:32:42,490 --> 00:32:44,169
and I send the request to the driver and

869
00:32:44,169 --> 00:32:46,659
the driver over writes the function

870
00:32:46,659 --> 00:32:47,710
pointer with whatever I tell it's you

871
00:32:47,710 --> 00:32:50,440
right one of the sort of consequences of

872
00:32:50,440 --> 00:32:54,279
that is I need to stay running because

873
00:32:54,279 --> 00:32:56,080
the only kind of data that I have

874
00:32:56,080 --> 00:32:58,000
control over when I do the overwrite is

875
00:32:58,000 --> 00:33:00,759
memory that's local to my process so

876
00:33:00,759 --> 00:33:02,080
it's a little different from like a

877
00:33:02,080 --> 00:33:03,759
win32 Kay bug where you're controlling

878
00:33:03,759 --> 00:33:05,470
the whole transaction and you're messing

879
00:33:05,470 --> 00:33:07,870
with like a particular object because in

880
00:33:07,870 --> 00:33:09,100
this case like I said they're shared

881
00:33:09,100 --> 00:33:11,500
system-wide but I need to allocate

882
00:33:11,500 --> 00:33:12,820
memory and use remote that has my

883
00:33:12,820 --> 00:33:16,090
payload in it so there's sort of a extra

884
00:33:16,090 --> 00:33:17,379
work that needs to go into making sure

885
00:33:17,379 --> 00:33:18,950
like you stay running while your

886
00:33:18,950 --> 00:33:22,309
it's kind of in progress and for us

887
00:33:22,309 --> 00:33:24,080
basically what this comes down to is

888
00:33:24,080 --> 00:33:27,350
when you issue a novel Windows has or

889
00:33:27,350 --> 00:33:28,610
you know most operating systems they

890
00:33:28,610 --> 00:33:30,860
have an idea of like process context so

891
00:33:30,860 --> 00:33:34,250
on Windows your process context is if

892
00:33:34,250 --> 00:33:35,179
you're in ring 0

893
00:33:35,179 --> 00:33:37,789
what handles and what virtual memory is

894
00:33:37,789 --> 00:33:41,090
valid right so if I'm in you know normal

895
00:33:41,090 --> 00:33:42,740
kernel space and I'm allocating kernel

896
00:33:42,740 --> 00:33:44,360
memory that's kind of shared for all

897
00:33:44,360 --> 00:33:46,130
device drivers in the OS and everything

898
00:33:46,130 --> 00:33:47,960
else that's running there but for user

899
00:33:47,960 --> 00:33:50,929
mode stuff virtual memory is basically

900
00:33:50,929 --> 00:33:52,610
there to kind of divide up access to

901
00:33:52,610 --> 00:33:55,850
physical resources right so the virtual

902
00:33:55,850 --> 00:33:58,070
memory mapping for Cal Tech Z is totally

903
00:33:58,070 --> 00:33:59,690
different from notepad to Daisy so every

904
00:33:59,690 --> 00:34:01,309
address could be the same it could be

905
00:34:01,309 --> 00:34:02,480
different it could be invalid or

906
00:34:02,480 --> 00:34:04,700
whatever but we need to put our payload

907
00:34:04,700 --> 00:34:08,659
in virtual memory so we can only kind of

908
00:34:08,659 --> 00:34:10,520
execute the full kind of attack for this

909
00:34:10,520 --> 00:34:12,349
exploit in the context of our process

910
00:34:12,349 --> 00:34:17,270
because we're running in user mode so

911
00:34:17,270 --> 00:34:18,859
what that means is from a stability

912
00:34:18,859 --> 00:34:22,219
perspective if we get switched off so we

913
00:34:22,219 --> 00:34:23,569
get contexts which another process

914
00:34:23,569 --> 00:34:26,569
executes that thing that we put into the

915
00:34:26,569 --> 00:34:28,219
system call handlers not valid anymore

916
00:34:28,219 --> 00:34:30,020
so if somebody again makes a system call

917
00:34:30,020 --> 00:34:32,359
they're gonna get some random unmapped

918
00:34:32,359 --> 00:34:34,369
user address and we're probably almost

919
00:34:34,369 --> 00:34:38,449
certainly gonna crash right and then

920
00:34:38,449 --> 00:34:41,300
like I said so all these issues we have

921
00:34:41,300 --> 00:34:42,859
to deal with in our payloads we need to

922
00:34:42,859 --> 00:34:45,770
make sure one our actual exploit is

923
00:34:45,770 --> 00:34:47,929
super small in terms of the code that

924
00:34:47,929 --> 00:34:49,069
we're using to trigger it but then we

925
00:34:49,069 --> 00:34:51,710
also need to see if we can massage kind

926
00:34:51,710 --> 00:34:53,030
of the execution state to make sure like

927
00:34:53,030 --> 00:34:54,349
we're probably gonna stay running

928
00:34:54,349 --> 00:34:56,690
throughout the whole thing and we'll

929
00:34:56,690 --> 00:34:58,460
talk about kind of how I did this but

930
00:34:58,460 --> 00:35:00,410
like this this is true across all OS

931
00:35:00,410 --> 00:35:01,790
versions right so there's a bunch of

932
00:35:01,790 --> 00:35:03,290
kind of exploit mitigations that we run

933
00:35:03,290 --> 00:35:06,920
into later but this is always the case

934
00:35:06,920 --> 00:35:08,150
because virtual memory is kind of more

935
00:35:08,150 --> 00:35:10,849
or less the same right so all of these

936
00:35:10,849 --> 00:35:12,260
things can all happen while we're

937
00:35:12,260 --> 00:35:13,790
running so we can get paged out we could

938
00:35:13,790 --> 00:35:15,890
switch it off the memory could be or

939
00:35:15,890 --> 00:35:17,660
sorry the the memory could be paged out

940
00:35:17,660 --> 00:35:20,390
or we could be switched off or something

941
00:35:20,390 --> 00:35:21,740
else could just happen to make a system

942
00:35:21,740 --> 00:35:23,270
call on that processor while we're

943
00:35:23,270 --> 00:35:24,410
running so there's a bunch of kind of

944
00:35:24,410 --> 00:35:27,260
edge cases that we need to deal with and

945
00:35:27,260 --> 00:35:30,200
it kind of if it does crash in this

946
00:35:30,200 --> 00:35:32,270
context because we're not

947
00:35:32,270 --> 00:35:34,070
lean caramel mode is kind of a pain to

948
00:35:34,070 --> 00:35:35,650
debug it's kind of the punchline there

949
00:35:35,650 --> 00:35:38,150
so the first problem we need to address

950
00:35:38,150 --> 00:35:39,560
is how do I get in and out of kernel

951
00:35:39,560 --> 00:35:42,200
mode similar to what the OS would

952
00:35:42,200 --> 00:35:43,820
actually do and in this case if you

953
00:35:43,820 --> 00:35:47,000
remember I said ki system call 34 64 is

954
00:35:47,000 --> 00:35:49,130
the function that's usually occupying

955
00:35:49,130 --> 00:35:51,710
that MSR sort of address so we can kind

956
00:35:51,710 --> 00:35:54,530
of consult that to say this is the first

957
00:35:54,530 --> 00:35:56,780
part of our payload so in our case swap

958
00:35:56,780 --> 00:35:58,550
GS if you're not familiar with this does

959
00:35:58,550 --> 00:36:00,530
it doesn't really matter but like this

960
00:36:00,530 --> 00:36:03,320
is a control register thing that lets

961
00:36:03,320 --> 00:36:06,320
the kernel know oh when you say when

962
00:36:06,320 --> 00:36:07,820
you're accessing things like where the

963
00:36:07,820 --> 00:36:09,350
peb would be in user mode it's kind of a

964
00:36:09,350 --> 00:36:11,540
different mapping I mean kernel mode so

965
00:36:11,540 --> 00:36:13,010
the first part of our payload is

966
00:36:13,010 --> 00:36:14,540
basically gonna copy code from here to

967
00:36:14,540 --> 00:36:16,040
say like how much do I need to do to

968
00:36:16,040 --> 00:36:16,940
make sure so the first couple

969
00:36:16,940 --> 00:36:18,860
instructions swapped yes which is like

970
00:36:18,860 --> 00:36:21,530
the kernel mode switch and then you can

971
00:36:21,530 --> 00:36:23,210
see it does some stuff with RSP so it's

972
00:36:23,210 --> 00:36:24,890
essentially preserving the user mode

973
00:36:24,890 --> 00:36:26,330
stack and swap into a kernel

974
00:36:26,330 --> 00:36:28,820
because remember kernel mode has their

975
00:36:28,820 --> 00:36:31,220
own view of data they have their own

976
00:36:31,220 --> 00:36:32,570
stacks and things like that because you

977
00:36:32,570 --> 00:36:34,070
don't want kind of user mode callers to

978
00:36:34,070 --> 00:36:36,830
collaborate then similarly when I'm

979
00:36:36,830 --> 00:36:38,210
getting out you'll see that swap gos

980
00:36:38,210 --> 00:36:40,010
instruction again and then we do a sis

981
00:36:40,010 --> 00:36:41,930
right cue which you know you can read

982
00:36:41,930 --> 00:36:43,400
the Intel manual but it's basically like

983
00:36:43,400 --> 00:36:45,080
it's basically to return between buttons

984
00:36:45,080 --> 00:36:49,910
so we kind of have this sandwich

985
00:36:49,910 --> 00:36:52,310
situation well so we have the minimum

986
00:36:52,310 --> 00:36:54,110
amount of transition in a kernel mode

987
00:36:54,110 --> 00:36:55,400
and we have the minimum of transition

988
00:36:55,400 --> 00:36:58,010
out and we're saying minimum because

989
00:36:58,010 --> 00:36:59,150
again we have to worry about all these

990
00:36:59,150 --> 00:37:01,340
sort of considerations of what happens

991
00:37:01,340 --> 00:37:02,630
if we get switched off and we've car as

992
00:37:02,630 --> 00:37:06,380
a system or whatever so how do we

993
00:37:06,380 --> 00:37:08,210
address the issue where we might get

994
00:37:08,210 --> 00:37:09,890
paged out or somebody might do a system

995
00:37:09,890 --> 00:37:11,420
call while we're running or whatever it

996
00:37:11,420 --> 00:37:14,090
is so in this case there's three user

997
00:37:14,090 --> 00:37:15,650
mode ap is that we can use the kind of

998
00:37:15,650 --> 00:37:17,780
influence the execution state while our

999
00:37:17,780 --> 00:37:19,550
payload is running and essentially

1000
00:37:19,550 --> 00:37:21,230
trying to trick the scheduler to be like

1001
00:37:21,230 --> 00:37:23,240
no like you know I'm really important

1002
00:37:23,240 --> 00:37:25,700
right now kind of thing so set thread

1003
00:37:25,700 --> 00:37:28,550
priority and is does exactly what you

1004
00:37:28,550 --> 00:37:29,780
might think you can say my thread is

1005
00:37:29,780 --> 00:37:30,650
very important

1006
00:37:30,650 --> 00:37:33,260
police did not scheduled me off set

1007
00:37:33,260 --> 00:37:35,000
processor affinity if you remember a

1008
00:37:35,000 --> 00:37:36,890
couple slides ago I said m/s ours are

1009
00:37:36,890 --> 00:37:39,620
shared per processor so we can say I'm

1010
00:37:39,620 --> 00:37:41,870
gonna overwrite MSR in processor to only

1011
00:37:41,870 --> 00:37:43,850
keep me running on processor two right

1012
00:37:43,850 --> 00:37:45,740
because that's almost like the opposite

1013
00:37:45,740 --> 00:37:46,099
problem

1014
00:37:46,099 --> 00:37:48,049
if we get switched between processors

1015
00:37:48,049 --> 00:37:49,249
we're like we'll do a system call

1016
00:37:49,249 --> 00:37:50,960
thinking we had a overwritten and then

1017
00:37:50,960 --> 00:37:53,690
like it just agent works right and then

1018
00:37:53,690 --> 00:37:56,089
sleep is kind of a this is more of I

1019
00:37:56,089 --> 00:37:57,650
don't want to call it a trick but it's

1020
00:37:57,650 --> 00:38:00,799
more of a indirect mechanism but if we

1021
00:38:00,799 --> 00:38:03,920
sleep right before we call our payloads

1022
00:38:03,920 --> 00:38:06,619
what that tells like schedulers is oh

1023
00:38:06,619 --> 00:38:08,979
this guy hasn't really run for a while

1024
00:38:08,979 --> 00:38:12,049
so I'm gonna sort of de prioritize

1025
00:38:12,049 --> 00:38:13,789
switching him off because he already had

1026
00:38:13,789 --> 00:38:15,710
his kind of wait period but that's like

1027
00:38:15,710 --> 00:38:17,029
that's like an OS thing that I'm not

1028
00:38:17,029 --> 00:38:19,519
gonna really go into here so this slides

1029
00:38:19,519 --> 00:38:22,210
just an explanation of what I just said

1030
00:38:22,210 --> 00:38:25,430
then when we're talking about how to do

1031
00:38:25,430 --> 00:38:28,339
the transition the good news is almost

1032
00:38:28,339 --> 00:38:31,549
every register is preserved when we do a

1033
00:38:31,549 --> 00:38:34,009
system call so when I'm writing my

1034
00:38:34,009 --> 00:38:35,809
actual payload if I write it in raw

1035
00:38:35,809 --> 00:38:37,910
assembly versus kind of regular C code

1036
00:38:37,910 --> 00:38:40,369
to trigger the bug then I can say oh Rd

1037
00:38:40,369 --> 00:38:42,019
X is always gonna have a pointer to this

1038
00:38:42,019 --> 00:38:44,180
or that or whatever it is so I can kind

1039
00:38:44,180 --> 00:38:46,640
of I have a lot of control which you

1040
00:38:46,640 --> 00:38:47,599
know if you're familiar with binary

1041
00:38:47,599 --> 00:38:49,369
exploitation like that's a super

1042
00:38:49,369 --> 00:38:50,930
important kind of primitive to use when

1043
00:38:50,930 --> 00:38:52,009
they're writing payloads because it

1044
00:38:52,009 --> 00:38:54,170
gives you flexibility in what you could

1045
00:38:54,170 --> 00:38:55,489
do with things like Rob gadgets or

1046
00:38:55,489 --> 00:38:59,719
whatever and then you have the

1047
00:38:59,719 --> 00:39:00,950
transitioning internet I don't want to

1048
00:39:00,950 --> 00:39:02,239
keep hammering on on that but basically

1049
00:39:02,239 --> 00:39:04,279
like I said we need to emulate what that

1050
00:39:04,279 --> 00:39:07,460
ki system call function does so we sort

1051
00:39:07,460 --> 00:39:09,229
of are pretending to be a valid system

1052
00:39:09,229 --> 00:39:11,329
call which again for Windows 7 is super

1053
00:39:11,329 --> 00:39:13,400
easy because basically we just have our

1054
00:39:13,400 --> 00:39:15,680
assembly blob that's our payload we call

1055
00:39:15,680 --> 00:39:17,719
this swap GS instruction we call sis

1056
00:39:17,719 --> 00:39:18,799
write queue at the end and then we're

1057
00:39:18,799 --> 00:39:22,099
good to go so this is that sandwich

1058
00:39:22,099 --> 00:39:23,420
situation I was talking about so

1059
00:39:23,420 --> 00:39:24,769
whatever your kernel shellcode would be

1060
00:39:24,769 --> 00:39:27,140
which again could be token swamps or in

1061
00:39:27,140 --> 00:39:28,339
our case we're talking about kind of a

1062
00:39:28,339 --> 00:39:32,089
bigger chunk you have the swab GS and

1063
00:39:32,089 --> 00:39:34,339
whatever stack setup is necessary you've

1064
00:39:34,339 --> 00:39:36,019
run your payload then you just kind of

1065
00:39:36,019 --> 00:39:37,130
eggs it out as if you were a normal

1066
00:39:37,130 --> 00:39:38,450
system call and you're all good to go

1067
00:39:38,450 --> 00:39:40,219
there's some stuff that happens kind of

1068
00:39:40,219 --> 00:39:41,150
mechanically that we can talk about

1069
00:39:41,150 --> 00:39:45,160
after this that can mess you up if your

1070
00:39:45,160 --> 00:39:47,269
payload does certain things but that's

1071
00:39:47,269 --> 00:39:49,849
you know just kind of a gotcha for your

1072
00:39:49,849 --> 00:39:53,869
for your reference so Windows 7 is super

1073
00:39:53,869 --> 00:39:55,309
old I don't know if you guys know it's

1074
00:39:55,309 --> 00:39:57,890
actually it's almost dead right well

1075
00:39:57,890 --> 00:39:59,550
theoretically

1076
00:39:59,550 --> 00:40:03,600
so in Windows 8 they added something or

1077
00:40:03,600 --> 00:40:05,430
they started supporting this processor

1078
00:40:05,430 --> 00:40:07,380
feature called snap on Windows so what's

1079
00:40:07,380 --> 00:40:11,610
map means is stance or supervisory mode

1080
00:40:11,610 --> 00:40:13,380
execution protection and basically what

1081
00:40:13,380 --> 00:40:15,150
it means is in this scenario we're

1082
00:40:15,150 --> 00:40:17,190
talking about where I have code

1083
00:40:17,190 --> 00:40:20,790
allocated in user space that code cannot

1084
00:40:20,790 --> 00:40:23,490
be executed from my kernel context so

1085
00:40:23,490 --> 00:40:25,500
what will happen is if we kind of run it

1086
00:40:25,500 --> 00:40:27,510
like I just described I do my system

1087
00:40:27,510 --> 00:40:28,890
call I get the function call back no

1088
00:40:28,890 --> 00:40:31,440
problem but then the box will still

1089
00:40:31,440 --> 00:40:33,450
crash and in blue screen because now

1090
00:40:33,450 --> 00:40:35,130
it's saying the processors in kernel

1091
00:40:35,130 --> 00:40:36,480
mode but I'm executing it use remote

1092
00:40:36,480 --> 00:40:42,240
address so the kind of the way to get

1093
00:40:42,240 --> 00:40:44,340
around Smet is the same way you get

1094
00:40:44,340 --> 00:40:46,380
around depth which is good they rhyme so

1095
00:40:46,380 --> 00:40:47,820
it's kind of an easy way to keep track

1096
00:40:47,820 --> 00:40:49,260
right

1097
00:40:49,260 --> 00:40:50,430
but in DEP you use something called

1098
00:40:50,430 --> 00:40:53,070
return oriented programming or Rob where

1099
00:40:53,070 --> 00:40:55,410
you're reusing is listening pieces of

1100
00:40:55,410 --> 00:40:57,210
code and that's kinda what we're gonna

1101
00:40:57,210 --> 00:40:58,980
do here so we can't execute our user

1102
00:40:58,980 --> 00:41:01,350
mode payload directly in a SMAP scenario

1103
00:41:01,350 --> 00:41:03,360
but what we can do is instead of

1104
00:41:03,360 --> 00:41:05,550
pointing that MSR at like a random user

1105
00:41:05,550 --> 00:41:07,590
mode buffer we can point it at existing

1106
00:41:07,590 --> 00:41:10,050
pieces of kernel code and because we

1107
00:41:10,050 --> 00:41:11,610
have all this control that I was talking

1108
00:41:11,610 --> 00:41:13,560
about those registers we're gonna reuse

1109
00:41:13,560 --> 00:41:16,110
those pieces to basically either copy

1110
00:41:16,110 --> 00:41:18,450
our code into kernel space before we

1111
00:41:18,450 --> 00:41:21,030
execute it or we can turn snip off in

1112
00:41:21,030 --> 00:41:25,950
the actual processor so this is one of

1113
00:41:25,950 --> 00:41:27,450
the situations it's a lot easier from

1114
00:41:27,450 --> 00:41:29,640
NLP if you've ever written a remote

1115
00:41:29,640 --> 00:41:31,350
exploit you know one of the problems is

1116
00:41:31,350 --> 00:41:33,660
always like well a SLR is usually on so

1117
00:41:33,660 --> 00:41:35,070
you need some kind of memory read

1118
00:41:35,070 --> 00:41:37,620
primitive to figure out like where your

1119
00:41:37,620 --> 00:41:40,950
stuff is for LP ease it's actually super

1120
00:41:40,950 --> 00:41:43,320
easy because you can just ask and the OS

1121
00:41:43,320 --> 00:41:44,610
will just tell you where the kernel is

1122
00:41:44,610 --> 00:41:45,930
so it's one of the like helpful things

1123
00:41:45,930 --> 00:41:49,710
on Windows so mechanically that's using

1124
00:41:49,710 --> 00:41:51,840
this API call a new device drivers and

1125
00:41:51,840 --> 00:41:53,130
that just gives you a big list of all

1126
00:41:53,130 --> 00:41:54,420
the drivers that are loaded and we'll

1127
00:41:54,420 --> 00:41:57,060
say n toss kernel is here when 32 K is

1128
00:41:57,060 --> 00:41:59,550
here and then you can scan those to find

1129
00:41:59,550 --> 00:42:00,900
a rock edges and kind of build them

1130
00:42:00,900 --> 00:42:05,010
dynamically and then so the fool kind of

1131
00:42:05,010 --> 00:42:06,660
workflow that you would use so you would

1132
00:42:06,660 --> 00:42:08,730
load library if your that's kind of how

1133
00:42:08,730 --> 00:42:10,890
you load and unload dll's but it's

1134
00:42:10,890 --> 00:42:12,210
really just any kind of p

1135
00:42:12,210 --> 00:42:15,750
file so you load library and user space

1136
00:42:15,750 --> 00:42:17,670
you know where it is a user space then

1137
00:42:17,670 --> 00:42:19,200
you can ask where it is in kernel space

1138
00:42:19,200 --> 00:42:20,580
you can just calculate the difference

1139
00:42:20,580 --> 00:42:21,450
and that's how you would find your op

1140
00:42:21,450 --> 00:42:24,930
gadgets dynamically so how do we turn

1141
00:42:24,930 --> 00:42:27,330
snip off there's a couple ways to do it

1142
00:42:27,330 --> 00:42:29,400
we could copy our code from user space

1143
00:42:29,400 --> 00:42:30,960
to kernel space because that won't

1144
00:42:30,960 --> 00:42:32,820
trigger the SMAP thing that says you

1145
00:42:32,820 --> 00:42:34,290
know you're running sort of on map code

1146
00:42:34,290 --> 00:42:37,290
it's a little easier and a little faster

1147
00:42:37,290 --> 00:42:39,480
to just turn SMAP off for the whole

1148
00:42:39,480 --> 00:42:41,099
system so this is actually the thing

1149
00:42:41,099 --> 00:42:42,780
that I mentioned like a video game

1150
00:42:42,780 --> 00:42:44,730
driver was doing a little while ago is

1151
00:42:44,730 --> 00:42:46,470
they ran into the same issue where they

1152
00:42:46,470 --> 00:42:47,940
had some kind of callback that was doing

1153
00:42:47,940 --> 00:42:50,609
some kind of integrity check and they

1154
00:42:50,609 --> 00:42:52,020
kept crashing because of snip so they

1155
00:42:52,020 --> 00:42:54,630
would just turn it off so snip is

1156
00:42:54,630 --> 00:42:56,640
controlled by cr4 which is like another

1157
00:42:56,640 --> 00:42:59,040
special register on the processor again

1158
00:42:59,040 --> 00:43:00,450
you can only access this from kernel

1159
00:43:00,450 --> 00:43:01,980
space but since we're running a kernel

1160
00:43:01,980 --> 00:43:04,230
payload we can build a rock chain to

1161
00:43:04,230 --> 00:43:06,570
toggle the appropriate bit off in this

1162
00:43:06,570 --> 00:43:08,190
special process or an executor code that

1163
00:43:08,190 --> 00:43:12,240
way I'm not gonna go over this for time

1164
00:43:12,240 --> 00:43:14,849
but basically like I said cr4 is faster

1165
00:43:14,849 --> 00:43:17,160
if you want to do the copy from user

1166
00:43:17,160 --> 00:43:18,780
mode to kernel mode like allocating

1167
00:43:18,780 --> 00:43:20,640
kernel memory can potentially be a big

1168
00:43:20,640 --> 00:43:22,560
operation depending on how big your

1169
00:43:22,560 --> 00:43:24,000
payload is so there's a lot of extra

1170
00:43:24,000 --> 00:43:29,430
concerns so one of the other problems we

1171
00:43:29,430 --> 00:43:31,560
have is if you remember I said one of

1172
00:43:31,560 --> 00:43:32,940
the first things we need to do is we

1173
00:43:32,940 --> 00:43:34,890
need to look like kernel mode on the way

1174
00:43:34,890 --> 00:43:36,960
in and on the way out now that we're

1175
00:43:36,960 --> 00:43:41,430
wrapping we're using pre-canned code so

1176
00:43:41,430 --> 00:43:43,050
like we need to find a proper gadget

1177
00:43:43,050 --> 00:43:44,430
that will execute that swab guess

1178
00:43:44,430 --> 00:43:45,630
instruction that we were talking about

1179
00:43:45,630 --> 00:43:49,950
and unfortunately there is no swap GS

1180
00:43:49,950 --> 00:43:51,810
ret so if you're familiar with wrapping

1181
00:43:51,810 --> 00:43:53,099
like usually it's like one or two

1182
00:43:53,099 --> 00:43:54,869
instructions followed by a return so you

1183
00:43:54,869 --> 00:43:56,339
can kind of just chain little pieces of

1184
00:43:56,339 --> 00:43:58,290
logic together we don't have a good

1185
00:43:58,290 --> 00:44:01,320
gadget for this so the approach we ended

1186
00:44:01,320 --> 00:44:02,880
up taking is you can search for other

1187
00:44:02,880 --> 00:44:05,760
kinds of returns and in this case we

1188
00:44:05,760 --> 00:44:09,180
found one that looks like this

1189
00:44:09,180 --> 00:44:12,599
so technically if you look so swap GS we

1190
00:44:12,599 --> 00:44:16,130
have our instruction and IRET q is a

1191
00:44:16,130 --> 00:44:18,630
it's usually used to return from

1192
00:44:18,630 --> 00:44:20,550
interrupts versus like normal function

1193
00:44:20,550 --> 00:44:23,339
calls right so in this case the first

1194
00:44:23,339 --> 00:44:25,119
gadget in our wrap chain is going to be

1195
00:44:25,119 --> 00:44:28,900
sudo interrupt return thing so the the

1196
00:44:28,900 --> 00:44:31,720
lesson here is again it's a bunch of

1197
00:44:31,720 --> 00:44:34,089
weird execution scenarios but if you

1198
00:44:34,089 --> 00:44:36,279
kind of tweak the box in terms of what

1199
00:44:36,279 --> 00:44:37,539
you're looking at a little bit you can

1200
00:44:37,539 --> 00:44:41,769
find these extra options so this also is

1201
00:44:41,769 --> 00:44:43,599
consistent across versions which is good

1202
00:44:43,599 --> 00:44:45,670
for us it's in some like arbitrary kind

1203
00:44:45,670 --> 00:44:49,539
of return handler thing and then the the

1204
00:44:49,539 --> 00:44:50,740
details at the bottom of the slide you

1205
00:44:50,740 --> 00:44:52,539
can you can read Africa but basically

1206
00:44:52,539 --> 00:44:54,130
there's extra work that goes in actually

1207
00:44:54,130 --> 00:44:55,509
using this instruction because like

1208
00:44:55,509 --> 00:44:57,730
return just says whatever is on the

1209
00:44:57,730 --> 00:44:59,740
stack I'm gonna go there this has some

1210
00:44:59,740 --> 00:45:01,720
extra kind of information I'm going

1211
00:45:01,720 --> 00:45:03,880
along with it

1212
00:45:03,880 --> 00:45:07,269
the cr4 edge is super easy we can load

1213
00:45:07,269 --> 00:45:09,069
it we can toggle the appropriate bit in

1214
00:45:09,069 --> 00:45:10,569
our Rob changes by doing like an xor

1215
00:45:10,569 --> 00:45:12,670
type operation so this one wasn't really

1216
00:45:12,670 --> 00:45:14,799
like a problem for us and then we put a

1217
00:45:14,799 --> 00:45:16,299
payload that looks like this so this is

1218
00:45:16,299 --> 00:45:18,130
kind of our wrap chain we still do our

1219
00:45:18,130 --> 00:45:21,279
swap GS via that I write Q gadget then

1220
00:45:21,279 --> 00:45:23,170
we modify CR 4 then we execute our

1221
00:45:23,170 --> 00:45:24,549
kernel shell code then once we're in

1222
00:45:24,549 --> 00:45:27,099
kernel mode we can you know manually put

1223
00:45:27,099 --> 00:45:28,299
everything back the way it's supposed to

1224
00:45:28,299 --> 00:45:30,309
be and we still do the swap GS just

1225
00:45:30,309 --> 00:45:33,880
write Q at the end this is the last

1226
00:45:33,880 --> 00:45:36,160
thing so I have a couple minutes for Q&A

1227
00:45:36,160 --> 00:45:38,140
right so I'm gonna I'm gonna dive into

1228
00:45:38,140 --> 00:45:40,450
this a little bit and we'll cut QA a

1229
00:45:40,450 --> 00:45:44,140
little short so another weird thing that

1230
00:45:44,140 --> 00:45:47,410
happened with this bug is between the

1231
00:45:47,410 --> 00:45:49,239
time where we found them and between the

1232
00:45:49,239 --> 00:45:51,519
time when we talked about them

1233
00:45:51,519 --> 00:45:53,710
meltdown inspector happened right so if

1234
00:45:53,710 --> 00:45:55,509
you're not familiar with those they were

1235
00:45:55,509 --> 00:45:58,809
like hardcore like CPU problems where

1236
00:45:58,809 --> 00:46:00,880
you could leak or influence kind of

1237
00:46:00,880 --> 00:46:03,130
kernel-mode stuff from user mode based

1238
00:46:03,130 --> 00:46:05,380
on weaknesses in the actual hardware so

1239
00:46:05,380 --> 00:46:07,930
the way that Microsoft mitigated this is

1240
00:46:07,930 --> 00:46:09,789
with something called kernel page table

1241
00:46:09,789 --> 00:46:11,920
isolation where basically they've

1242
00:46:11,920 --> 00:46:14,049
changed kind of what memory was mapped

1243
00:46:14,049 --> 00:46:15,910
when you do the translation so like

1244
00:46:15,910 --> 00:46:18,039
normally or not normally but on older

1245
00:46:18,039 --> 00:46:20,470
systems if I did like a device i/o

1246
00:46:20,470 --> 00:46:23,079
control once I was in kernel mode those

1247
00:46:23,079 --> 00:46:24,849
kernel mode pages were shared across

1248
00:46:24,849 --> 00:46:29,019
every process with Colonel or kpti what

1249
00:46:29,019 --> 00:46:32,019
ended up happening is they instead of

1250
00:46:32,019 --> 00:46:34,150
mapping all kernel addresses in a user

1251
00:46:34,150 --> 00:46:35,780
mode context they only have one page

1252
00:46:35,780 --> 00:46:38,720
and that pages job is to go and finally

1253
00:46:38,720 --> 00:46:40,790
the real page table and load it which

1254
00:46:40,790 --> 00:46:43,010
normally doesn't matter right even from

1255
00:46:43,010 --> 00:46:44,960
NLP II like usually you're exploiting

1256
00:46:44,960 --> 00:46:46,910
win32 K and everything is already set up

1257
00:46:46,910 --> 00:46:48,350
but because we have this weird thing

1258
00:46:48,350 --> 00:46:50,780
where we're not fully in kernel mode

1259
00:46:50,780 --> 00:46:53,480
what would happen is we could figure out

1260
00:46:53,480 --> 00:46:55,130
where all of our Rob gadgets should be

1261
00:46:55,130 --> 00:46:56,810
but when we made the actual transition

1262
00:46:56,810 --> 00:46:59,720
we only had one page to work with so

1263
00:46:59,720 --> 00:47:01,430
it's kind of like a weird situation

1264
00:47:01,430 --> 00:47:03,770
where k PT I was meant to clobber

1265
00:47:03,770 --> 00:47:05,330
something like a totally different issue

1266
00:47:05,330 --> 00:47:07,280
but that it impacted our payload because

1267
00:47:07,280 --> 00:47:09,530
we now have to figure out like can I

1268
00:47:09,530 --> 00:47:12,290
find where all of my actual intended rob

1269
00:47:12,290 --> 00:47:16,820
gadgets are and this one was a little

1270
00:47:16,820 --> 00:47:20,060
trickier to deal with because again you

1271
00:47:20,060 --> 00:47:23,390
only have one page of code but

1272
00:47:23,390 --> 00:47:26,450
essentially we need to search so we can

1273
00:47:26,450 --> 00:47:28,400
talk we can see if kpti is on with a

1274
00:47:28,400 --> 00:47:29,840
system call that i showed in the last

1275
00:47:29,840 --> 00:47:34,880
slide but when we are on a kpti system

1276
00:47:34,880 --> 00:47:36,950
we only have this one page from this

1277
00:47:36,950 --> 00:47:40,310
cave ass code thing actually Matt so any

1278
00:47:40,310 --> 00:47:42,500
wrapping that we're gonna do we need to

1279
00:47:42,500 --> 00:47:44,030
be able to find a gadget in that page so

1280
00:47:44,030 --> 00:47:46,220
it's a lot where it basically undoes all

1281
00:47:46,220 --> 00:47:47,390
the stuff that I just said was super

1282
00:47:47,390 --> 00:47:50,420
easy because now we don't have access to

1283
00:47:50,420 --> 00:47:51,980
whatever kernel binary we need we only

1284
00:47:51,980 --> 00:47:54,410
have one page right and this is one of

1285
00:47:54,410 --> 00:47:56,930
the ones that we that differs per

1286
00:47:56,930 --> 00:47:58,400
version that we're exploiting but

1287
00:47:58,400 --> 00:47:59,900
basically the punchline like what we

1288
00:47:59,900 --> 00:48:01,910
need to do is we need to find the normal

1289
00:48:01,910 --> 00:48:05,810
CR 3 so if you're unfamiliar CR 3 is the

1290
00:48:05,810 --> 00:48:07,700
another special register that maintains

1291
00:48:07,700 --> 00:48:09,230
all the mappings for what memory

1292
00:48:09,230 --> 00:48:10,700
addresses are valid and where they are

1293
00:48:10,700 --> 00:48:13,760
in RAM and normally this pages job is to

1294
00:48:13,760 --> 00:48:16,640
go ahead find CR 3 for like normal

1295
00:48:16,640 --> 00:48:18,140
kernel mode and then swap that in so we

1296
00:48:18,140 --> 00:48:19,610
kind of have to replicate the same thing

1297
00:48:19,610 --> 00:48:24,710
in our payload so getting a CR 3

1298
00:48:24,710 --> 00:48:26,480
modification gadgets pretty easy just

1299
00:48:26,480 --> 00:48:28,070
because that's something that happens

1300
00:48:28,070 --> 00:48:29,690
all the time actually so like when you

1301
00:48:29,690 --> 00:48:31,430
do a system call the kernel has to say

1302
00:48:31,430 --> 00:48:33,230
like here's all the memory that's valid

1303
00:48:33,230 --> 00:48:36,080
in kernel mode so this ki kernel exit is

1304
00:48:36,080 --> 00:48:38,990
the gadget we use here like you can see

1305
00:48:38,990 --> 00:48:41,630
there's a pretty it's pretty short so it

1306
00:48:41,630 --> 00:48:43,280
doesn't impact our rock chain too much

1307
00:48:43,280 --> 00:48:46,610
on 18:09 it changed it got a lot bigger

1308
00:48:46,610 --> 00:48:48,920
I got a lot harder and you can see one

1309
00:48:48,920 --> 00:48:49,280
of the we

1310
00:48:49,280 --> 00:48:51,530
things is that in the middle of this

1311
00:48:51,530 --> 00:48:54,710
chain there's another WR MSR instruction

1312
00:48:54,710 --> 00:48:57,080
so we're overwriting in MSR as part of

1313
00:48:57,080 --> 00:48:59,540
our Rock gain but one of the cool things

1314
00:48:59,540 --> 00:49:02,180
about these bugs is they usually let you

1315
00:49:02,180 --> 00:49:03,920
read arbitrary MSR is just like writing

1316
00:49:03,920 --> 00:49:05,480
them so we can build our rap chain to

1317
00:49:05,480 --> 00:49:08,150
basically put the right value back there

1318
00:49:08,150 --> 00:49:12,190
so that's the kernel-mode piece of it

1319
00:49:12,190 --> 00:49:14,180
okay you know I want to give shout outs

1320
00:49:14,180 --> 00:49:15,740
where shout outs are due right so we

1321
00:49:15,740 --> 00:49:17,960
still have a problem of we need to

1322
00:49:17,960 --> 00:49:19,970
figure out what the right value for cr3

1323
00:49:19,970 --> 00:49:22,220
is and in this case we consulted so

1324
00:49:22,220 --> 00:49:25,010
Ionesco did a talk a couple years ago

1325
00:49:25,010 --> 00:49:26,450
about how you leaked this

1326
00:49:26,450 --> 00:49:29,450
so we reuse his technique to basically

1327
00:49:29,450 --> 00:49:31,520
use WMI to link what the actual system

1328
00:49:31,520 --> 00:49:33,200
called thing or with the right CR

1329
00:49:33,200 --> 00:49:34,280
through your value is supposed to be

1330
00:49:34,280 --> 00:49:36,830
then we can preload dad into our rap

1331
00:49:36,830 --> 00:49:38,240
chain and kind of build it dynamically

1332
00:49:38,240 --> 00:49:39,500
that way so when we run these gadgets

1333
00:49:39,500 --> 00:49:40,910
you know our payload doesn't mess

1334
00:49:40,910 --> 00:49:43,520
everything up so the full chain right is

1335
00:49:43,520 --> 00:49:46,310
we romp to that swamp GSI wreck you

1336
00:49:46,310 --> 00:49:48,440
because that gadgets still there we do

1337
00:49:48,440 --> 00:49:51,230
this weird cr3 modification thing so we

1338
00:49:51,230 --> 00:49:52,580
kind of have to we have to build our

1339
00:49:52,580 --> 00:49:54,110
stack to handle sort of all of these

1340
00:49:54,110 --> 00:49:56,480
weird situations but we can read the MSR

1341
00:49:56,480 --> 00:49:57,890
value which is the big kind of gotcha

1342
00:49:57,890 --> 00:50:01,010
for us and then from there we Rob to a

1343
00:50:01,010 --> 00:50:03,290
CR for modification gadget turns map off

1344
00:50:03,290 --> 00:50:12,590
so easy peasy right the clicker so long

1345
00:50:12,590 --> 00:50:17,150
oh there we go okay so this is kind of a

1346
00:50:17,150 --> 00:50:19,220
full view of our payload and like I said

1347
00:50:19,220 --> 00:50:20,390
there was a lot of kind of nitty-gritty

1348
00:50:20,390 --> 00:50:22,520
technical details but the punchline is

1349
00:50:22,520 --> 00:50:26,120
like it was a weird situation where we

1350
00:50:26,120 --> 00:50:27,860
were running into different kernel

1351
00:50:27,860 --> 00:50:29,360
mitigations we were running into stuff

1352
00:50:29,360 --> 00:50:30,710
that wasn't intended to break our

1353
00:50:30,710 --> 00:50:32,150
payload but it was breaking our payload

1354
00:50:32,150 --> 00:50:34,280
and then on top of that we also had to

1355
00:50:34,280 --> 00:50:36,410
make sure we were handling cases were

1356
00:50:36,410 --> 00:50:37,520
like we didn't want to get switched off

1357
00:50:37,520 --> 00:50:38,750
and we don't want across the system

1358
00:50:38,750 --> 00:50:40,520
because we weren't running kind of fast

1359
00:50:40,520 --> 00:50:42,770
enough sort of thing then in user mode

1360
00:50:42,770 --> 00:50:44,450
we handle some of the scheduling stuff

1361
00:50:44,450 --> 00:50:47,600
with as much kind of luck as we can and

1362
00:50:47,600 --> 00:50:51,380
we use this cr3 leak to build the full

1363
00:50:51,380 --> 00:50:52,670
rock show this is the kind of option

1364
00:50:52,670 --> 00:50:54,410
that we would do on 18:09 which is like

1365
00:50:54,410 --> 00:50:58,210
the newest version that we tested on so

1366
00:50:58,210 --> 00:51:00,290
most of this we've already talked to you

1367
00:51:00,290 --> 00:51:02,240
so I'm gonna kind of rind

1368
00:51:02,240 --> 00:51:05,300
winddown then the last consideration is

1369
00:51:05,300 --> 00:51:06,770
where we actually put the rap chain so

1370
00:51:06,770 --> 00:51:11,060
similar to our payload problem we are

1371
00:51:11,060 --> 00:51:13,610
allocating memory and executing it from

1372
00:51:13,610 --> 00:51:18,050
user mode boy you still have all the

1373
00:51:18,050 --> 00:51:19,460
same problems that I just described of

1374
00:51:19,460 --> 00:51:21,140
like what if our user mode Rob chain

1375
00:51:21,140 --> 00:51:22,940
gets paged out or what if you know we

1376
00:51:22,940 --> 00:51:24,260
get switched off the user it's not

1377
00:51:24,260 --> 00:51:25,820
validated so you have the same problem

1378
00:51:25,820 --> 00:51:27,620
but it's worse than dropping because

1379
00:51:27,620 --> 00:51:29,750
like you have less control over what's

1380
00:51:29,750 --> 00:51:32,710
actually happening on the system for us

1381
00:51:32,710 --> 00:51:35,870
kind of the easy mode is you can

1382
00:51:35,870 --> 00:51:37,550
allocate a user mode stack and then call

1383
00:51:37,550 --> 00:51:39,950
a virtual lock API to kind of make sure

1384
00:51:39,950 --> 00:51:41,720
your memories always resident while

1385
00:51:41,720 --> 00:51:43,280
you're executing and there's some other

1386
00:51:43,280 --> 00:51:44,750
what you can go pretty crazy in terms of

1387
00:51:44,750 --> 00:51:46,760
the actual Rob chain allocation stuff

1388
00:51:46,760 --> 00:51:48,560
like the the kind of correct way to do

1389
00:51:48,560 --> 00:51:50,990
it would be to like leak a kernel

1390
00:51:50,990 --> 00:51:53,210
address and then spray the stack in

1391
00:51:53,210 --> 00:51:56,030
kernel mode and then Rob there but that

1392
00:51:56,030 --> 00:51:57,800
usually wasn't that different so I mean

1393
00:51:57,800 --> 00:51:59,720
again it's kind of a when you're writing

1394
00:51:59,720 --> 00:52:01,880
these payloads you need to make sure you

1395
00:52:01,880 --> 00:52:03,650
don't go too hard if you don't have to

1396
00:52:03,650 --> 00:52:04,820
because we already have a lot of weird

1397
00:52:04,820 --> 00:52:06,830
stuff to deal with so like it doesn't

1398
00:52:06,830 --> 00:52:09,760
believe us to add extra exploitation

1399
00:52:09,760 --> 00:52:14,600
problems and then I'm not gonna really

1400
00:52:14,600 --> 00:52:19,400
talk about mitigations because so but

1401
00:52:19,400 --> 00:52:22,280
basically only newer systems with

1402
00:52:22,280 --> 00:52:24,130
hyper-v they'll block the MSR access

1403
00:52:24,130 --> 00:52:26,180
theoretically Microsoft could also add

1404
00:52:26,180 --> 00:52:27,890
some kind of like cookie check when

1405
00:52:27,890 --> 00:52:29,030
you're doing this just call transition

1406
00:52:29,030 --> 00:52:31,970
stuff but I don't I mean they're not

1407
00:52:31,970 --> 00:52:35,180
gonna do that so that's fine and then

1408
00:52:35,180 --> 00:52:38,120
the CRS really already works so I had a

1409
00:52:38,120 --> 00:52:40,130
demo I guess it'll be in the slides when

1410
00:52:40,130 --> 00:52:42,200
they get uploaded but it's kind of it

1411
00:52:42,200 --> 00:52:43,580
just walks you through each step of our

1412
00:52:43,580 --> 00:52:45,470
payload in terms of like what we did

1413
00:52:45,470 --> 00:52:47,480
here where do we put our code and things

1414
00:52:47,480 --> 00:52:50,510
like that so I was only a little over

1415
00:52:50,510 --> 00:52:55,270
but I can do questions or Q&A now

1416
00:52:55,780 --> 00:53:09,809
[Music]

