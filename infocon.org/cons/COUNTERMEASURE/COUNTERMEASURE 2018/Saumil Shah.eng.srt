1
00:00:00,330 --> 00:00:11,599
[Music]

2
00:00:11,599 --> 00:00:13,920
this is gonna be a very technical talk

3
00:00:13,920 --> 00:00:19,080
so forewarning this talk basically comes

4
00:00:19,080 --> 00:00:22,140
up from all my thinking around with

5
00:00:22,140 --> 00:00:25,400
exploit writing with shellcode writing

6
00:00:25,400 --> 00:00:29,310
with arm assembly and then my personal

7
00:00:29,310 --> 00:00:33,570
vendetta against how signatures rules

8
00:00:33,570 --> 00:00:35,850
and updates are the only three ways that

9
00:00:35,850 --> 00:00:39,629
people know how to do InfoSec defense it

10
00:00:39,629 --> 00:00:41,370
it ends up being one of my personal

11
00:00:41,370 --> 00:00:43,770
goals to defeat any signature mechanisms

12
00:00:43,770 --> 00:00:45,930
not because I want to do evil things but

13
00:00:45,930 --> 00:00:49,050
because I just want to make boxes with

14
00:00:49,050 --> 00:00:53,610
blinking lights useless right so my name

15
00:00:53,610 --> 00:00:55,739
is Samuel I've been doing InfoSec for a

16
00:00:55,739 --> 00:00:57,270
very long time let me skip the

17
00:00:57,270 --> 00:00:58,859
introduction and get straight to the

18
00:00:58,859 --> 00:01:04,559
agenda a little bit of background when

19
00:01:04,559 --> 00:01:06,420
we talking about shellcode these days

20
00:01:06,420 --> 00:01:07,979
most of the research out there in the

21
00:01:07,979 --> 00:01:11,040
public is x86 ago it's a little bit of

22
00:01:11,040 --> 00:01:13,710
arm shellcode in out there for the two

23
00:01:13,710 --> 00:01:15,570
of you who suffered my class for the

24
00:01:15,570 --> 00:01:17,040
past three days you've written on

25
00:01:17,040 --> 00:01:19,200
shellcode from the ground up and that's

26
00:01:19,200 --> 00:01:22,380
fine it it's good but arm shellcode is

27
00:01:22,380 --> 00:01:27,439
still in its nation see it's largely

28
00:01:27,439 --> 00:01:30,780
published on a few sites simple

29
00:01:30,780 --> 00:01:33,900
shellcode exists out there and i thought

30
00:01:33,900 --> 00:01:35,040
to myself okay

31
00:01:35,040 --> 00:01:37,229
let's let's take shellcode a step

32
00:01:37,229 --> 00:01:39,960
further so i was working on three

33
00:01:39,960 --> 00:01:42,329
projects out of which one project got

34
00:01:42,329 --> 00:01:44,189
solved really trevallies are not going

35
00:01:44,189 --> 00:01:46,439
to present that trivial stuff on how to

36
00:01:46,439 --> 00:01:50,820
solve cache coherency issues we will

37
00:01:50,820 --> 00:01:56,729
instead talk about two types of R&D that

38
00:01:56,729 --> 00:01:58,710
I've done with arm shellcode one is

39
00:01:58,710 --> 00:02:00,450
whenever you are trying to inject

40
00:02:00,450 --> 00:02:02,899
shellcode and you have space limitations

41
00:02:02,899 --> 00:02:06,149
how do you get around tight spaces how

42
00:02:06,149 --> 00:02:09,179
do you get around confined spaces and in

43
00:02:09,179 --> 00:02:11,760
the x86 world most of us are familiar

44
00:02:11,760 --> 00:02:13,380
with the egg hunting

45
00:02:13,380 --> 00:02:16,080
technique your shellcode itself lives

46
00:02:16,080 --> 00:02:18,330
completely in a different memory area

47
00:02:18,330 --> 00:02:20,840
but you inject a very small

48
00:02:20,840 --> 00:02:23,310
search-and-destroy routine called an egg

49
00:02:23,310 --> 00:02:25,890
hunter which scans your entire process

50
00:02:25,890 --> 00:02:28,610
for the presence of the larger shellcode

51
00:02:28,610 --> 00:02:31,800
jumps to it and execute it so again

52
00:02:31,800 --> 00:02:33,660
nothing new as far as egg hunting goes

53
00:02:33,660 --> 00:02:36,300
but I adapted I made a few modifications

54
00:02:36,300 --> 00:02:38,280
to the egg hunter which I will talk

55
00:02:38,280 --> 00:02:40,710
about but then most of the talk is going

56
00:02:40,710 --> 00:02:43,890
to be focused on polyglot tricks with

57
00:02:43,890 --> 00:02:46,770
our shellcode I also like polyglot

58
00:02:46,770 --> 00:02:50,370
techniques very much and and polyglot

59
00:02:50,370 --> 00:02:55,340
techniques is where the same data means

60
00:02:55,340 --> 00:02:57,750
carries two completely different

61
00:02:57,750 --> 00:03:00,600
meanings when viewed in completely

62
00:03:00,600 --> 00:03:03,210
different context one of my research

63
00:03:03,210 --> 00:03:05,730
areas with with polyglots was stego

64
00:03:05,730 --> 00:03:09,480
sploit which got more misunderstood than

65
00:03:09,480 --> 00:03:11,340
it was understood was about how to

66
00:03:11,340 --> 00:03:15,210
deliver browser exploits encoded as

67
00:03:15,210 --> 00:03:18,630
pixels on a picture so if you view the

68
00:03:18,630 --> 00:03:20,760
if you view the data in a JPEG here it

69
00:03:20,760 --> 00:03:22,590
looks like pure pixels on a browser it

70
00:03:22,590 --> 00:03:24,750
just shows you an image but if you treat

71
00:03:24,750 --> 00:03:26,970
the data as JavaScript then it actually

72
00:03:26,970 --> 00:03:28,200
executes in the browser

73
00:03:28,200 --> 00:03:30,900
that's a polyglot it's the arm polyglot

74
00:03:30,900 --> 00:03:32,490
is not as cool as that one but it's

75
00:03:32,490 --> 00:03:36,060
still a polyglot and then of course

76
00:03:36,060 --> 00:03:39,810
there's demos so without further ado let

77
00:03:39,810 --> 00:03:42,030
me just give you a very brief context

78
00:03:42,030 --> 00:03:45,390
about arm and an arm assembly and arm

79
00:03:45,390 --> 00:03:49,920
shellcode in exactly 59 seconds arm is a

80
00:03:49,920 --> 00:03:55,590
RISC processer arm has two instruction

81
00:03:55,590 --> 00:03:58,440
sets overlaid into it there is what we

82
00:03:58,440 --> 00:04:00,690
call as a 32-bit instruction set called

83
00:04:00,690 --> 00:04:02,640
the arm instruction set all instructions

84
00:04:02,640 --> 00:04:05,070
are fixed with and then there is a

85
00:04:05,070 --> 00:04:08,150
subset of most popular instructions

86
00:04:08,150 --> 00:04:11,520
available as thump instructions where a

87
00:04:11,520 --> 00:04:14,970
thumb is much smaller than an arm we're

88
00:04:14,970 --> 00:04:16,950
actually in the case of arm thumbies

89
00:04:16,950 --> 00:04:18,420
half the size of foam which is quite

90
00:04:18,420 --> 00:04:21,120
kind of weird but it is it is what it is

91
00:04:21,120 --> 00:04:23,850
so thumb instructions are more compact

92
00:04:23,850 --> 00:04:25,770
and shellcode writers prefer to write

93
00:04:25,770 --> 00:04:26,940
all their she'll Corinth

94
00:04:26,940 --> 00:04:28,560
because shellcode has to be compact and

95
00:04:28,560 --> 00:04:29,790
shellcode has to be free of bad

96
00:04:29,790 --> 00:04:32,450
characters and whatever have you however

97
00:04:32,450 --> 00:04:35,460
whenever you're writing arm shellcode if

98
00:04:35,460 --> 00:04:37,470
you're if you're a shellcode developer

99
00:04:37,470 --> 00:04:40,650
the first thing you want to do is you'll

100
00:04:40,650 --> 00:04:42,780
always start out in arm mode that is all

101
00:04:42,780 --> 00:04:44,430
your instructions initially will be

102
00:04:44,430 --> 00:04:47,250
decoded as 32 bits you want to switch

103
00:04:47,250 --> 00:04:49,500
over to thumb mode very quickly as as

104
00:04:49,500 --> 00:04:52,410
soon as possible so you do something

105
00:04:52,410 --> 00:04:53,640
called what's called an arm to thumb

106
00:04:53,640 --> 00:04:57,060
switch that one my laser pointer is weak

107
00:04:57,060 --> 00:04:59,340
so the blue text is the arm to thumb

108
00:04:59,340 --> 00:05:01,380
switch these are two 32-bit instructions

109
00:05:01,380 --> 00:05:05,130
which will immediately flip you over to

110
00:05:05,130 --> 00:05:07,200
thumb mode and the green instructions

111
00:05:07,200 --> 00:05:09,630
are all thumb as you can see from the

112
00:05:09,630 --> 00:05:11,850
disassembly and the shellcode execute

113
00:05:11,850 --> 00:05:14,130
this one is basically launching you bin

114
00:05:14,130 --> 00:05:18,630
shell so with this little background I'm

115
00:05:18,630 --> 00:05:20,700
going to give you the two demos first

116
00:05:20,700 --> 00:05:22,110
I'm going to give you the egg Hunter

117
00:05:22,110 --> 00:05:26,370
demo where we will load the shellcode in

118
00:05:26,370 --> 00:05:28,620
random areas of the process like the

119
00:05:28,620 --> 00:05:31,020
heap and then the egg hunter will come

120
00:05:31,020 --> 00:05:33,450
searching around find it trigger it and

121
00:05:33,450 --> 00:05:35,760
launch a shell there are some

122
00:05:35,760 --> 00:05:39,150
complexities because it's 2018 we now

123
00:05:39,150 --> 00:05:41,070
have exploited mitigation technologies

124
00:05:41,070 --> 00:05:43,020
available called data execution

125
00:05:43,020 --> 00:05:46,140
prevention is one of them where there

126
00:05:46,140 --> 00:05:48,090
the data in the stack and the heap is

127
00:05:48,090 --> 00:05:53,220
not executable so therefore we basically

128
00:05:53,220 --> 00:05:57,690
need to we basically need to do some

129
00:05:57,690 --> 00:05:59,520
memory protection techniques and that's

130
00:05:59,520 --> 00:06:03,720
where this research comes in ok so let

131
00:06:03,720 --> 00:06:06,030
me set the context for the egg hunter

132
00:06:06,030 --> 00:06:09,120
what happens if basically your payload

133
00:06:09,120 --> 00:06:13,470
exceeds the size contains in this in

134
00:06:13,470 --> 00:06:15,810
this example you have a stack overflow a

135
00:06:15,810 --> 00:06:18,740
local buffer has very limited space and

136
00:06:18,740 --> 00:06:21,780
you're the programmer has encoded it

137
00:06:21,780 --> 00:06:24,300
properly as usual blame the programmer

138
00:06:24,300 --> 00:06:25,890
for everything that's why we have jobs

139
00:06:25,890 --> 00:06:29,910
in InfoSec so you're going to attack it

140
00:06:29,910 --> 00:06:31,320
you're going to overflow this thing

141
00:06:31,320 --> 00:06:33,000
you're going to put in your rob chain

142
00:06:33,000 --> 00:06:37,080
the rob chain will basically do the

143
00:06:37,080 --> 00:06:39,330
fancy step and stuff and bypass data

144
00:06:39,330 --> 00:06:40,710
execution prevention making

145
00:06:40,710 --> 00:06:43,140
like executable and then you have your

146
00:06:43,140 --> 00:06:47,370
shellcode but what happens if the

147
00:06:47,370 --> 00:06:50,520
shellcode is too long there are several

148
00:06:50,520 --> 00:06:53,010
conditions sometimes you might overwrite

149
00:06:53,010 --> 00:06:55,920
a local pointer in in the local variable

150
00:06:55,920 --> 00:06:58,110
space and this the pointer is executed

151
00:06:58,110 --> 00:07:00,960
or any reference it causes a seg fault

152
00:07:00,960 --> 00:07:03,870
if you hit the bottom of the stack you

153
00:07:03,870 --> 00:07:05,880
may you may hit a seg fault

154
00:07:05,880 --> 00:07:10,560
so if space is a limitation we have

155
00:07:10,560 --> 00:07:14,460
solutions like the egg hunter so what

156
00:07:14,460 --> 00:07:17,280
does the egg hunt or do basically the

157
00:07:17,280 --> 00:07:19,290
egg hunt like I mentioned it searches

158
00:07:19,290 --> 00:07:22,500
for an egg in the process memory layer

159
00:07:22,500 --> 00:07:24,720
the egg is nothing but a four byte value

160
00:07:24,720 --> 00:07:27,150
but then it searches for two consecutive

161
00:07:27,150 --> 00:07:29,400
occurrences of the egg because sometimes

162
00:07:29,400 --> 00:07:30,870
you may have that for byte value

163
00:07:30,870 --> 00:07:32,100
occurring somewhere else and that's a

164
00:07:32,100 --> 00:07:35,100
false positive so the egg hunter is a

165
00:07:35,100 --> 00:07:37,440
shellcode which keeps on going page

166
00:07:37,440 --> 00:07:39,690
after page after page looking to see if

167
00:07:39,690 --> 00:07:41,550
you have two instances of the string

168
00:07:41,550 --> 00:07:42,530
somewhere

169
00:07:42,530 --> 00:07:46,800
followed by real shellcode when it finds

170
00:07:46,800 --> 00:07:49,050
it it jumps to that real shellcode and

171
00:07:49,050 --> 00:07:51,120
that's that's the end of it it's it's a

172
00:07:51,120 --> 00:07:53,910
generic technique the way the egg hunter

173
00:07:53,910 --> 00:07:58,640
works is essentially the egg hunter uses

174
00:07:58,640 --> 00:08:00,290
syscalls

175
00:08:00,290 --> 00:08:03,060
to determine whether memory pages exists

176
00:08:03,060 --> 00:08:03,360
or not

177
00:08:03,360 --> 00:08:05,520
so you're traversing through process

178
00:08:05,520 --> 00:08:07,290
virtual memory go page after page of

179
00:08:07,290 --> 00:08:09,300
page all of us are new land into an

180
00:08:09,300 --> 00:08:11,760
unmapped memory region if you try and

181
00:08:11,760 --> 00:08:14,160
dereference it in user land you're going

182
00:08:14,160 --> 00:08:15,960
to seg for your own set which isn't cool

183
00:08:15,960 --> 00:08:18,630
so you do a sis call to see if the page

184
00:08:18,630 --> 00:08:19,710
exists or not

185
00:08:19,710 --> 00:08:22,200
using some you know senses call which

186
00:08:22,200 --> 00:08:24,720
returns you either ino mem or success

187
00:08:24,720 --> 00:08:28,230
and then once you find the page you scan

188
00:08:28,230 --> 00:08:31,140
it see see if the eggs there and then

189
00:08:31,140 --> 00:08:33,210
transfer control now the egg hunter is

190
00:08:33,210 --> 00:08:34,860
nothing new I mean there's nothing

191
00:08:34,860 --> 00:08:36,780
radically new about the egg hunter this

192
00:08:36,780 --> 00:08:39,120
has been done before but the problem

193
00:08:39,120 --> 00:08:40,740
exists with data execution prevention

194
00:08:40,740 --> 00:08:42,330
that's what I'm going to talk to you

195
00:08:42,330 --> 00:08:45,090
about so I'm going to give you the egg

196
00:08:45,090 --> 00:08:47,010
Hunter demo first I'm going to explain

197
00:08:47,010 --> 00:08:48,990
this thing with pictures what I just

198
00:08:48,990 --> 00:08:51,540
said in words you have the process

199
00:08:51,540 --> 00:08:53,460
memory layout over here you have the Buy

200
00:08:53,460 --> 00:08:56,790
a heap stack and everything you have the

201
00:08:56,790 --> 00:09:00,060
shellcode pre-loaded in the heap somehow

202
00:09:00,060 --> 00:09:01,710
through some input or whatever have you

203
00:09:01,710 --> 00:09:03,720
you've injected the shellcode in the

204
00:09:03,720 --> 00:09:05,280
heap you don't know where it is but it's

205
00:09:05,280 --> 00:09:08,040
living in the heap and the the two pink

206
00:09:08,040 --> 00:09:10,830
words which a hack hack that is the egg

207
00:09:10,830 --> 00:09:13,620
the string of your choice and then the

208
00:09:13,620 --> 00:09:17,460
shellcode that follows it now when you

209
00:09:17,460 --> 00:09:19,770
have your stack overflow you stuff in

210
00:09:19,770 --> 00:09:22,350
your rob chain the rob chain will

211
00:09:22,350 --> 00:09:25,080
basically turn the memory of the stack

212
00:09:25,080 --> 00:09:30,150
read write and execute and then after

213
00:09:30,150 --> 00:09:34,770
the Rob chain you basically jump to the

214
00:09:34,770 --> 00:09:36,780
egg hunt or shellcode which is what I'm

215
00:09:36,780 --> 00:09:39,090
going to present the egg hunter is going

216
00:09:39,090 --> 00:09:41,330
to travel through the memory space

217
00:09:41,330 --> 00:09:44,280
searching for the string hack hack one

218
00:09:44,280 --> 00:09:46,800
page at a time this is going to keep on

219
00:09:46,800 --> 00:09:49,830
looking if it hits the bottom it's going

220
00:09:49,830 --> 00:09:52,020
to wrapper on at the top and scan these

221
00:09:52,020 --> 00:09:56,430
pages until it does find two occurrences

222
00:09:56,430 --> 00:09:58,440
of the string and then it's going to

223
00:09:58,440 --> 00:10:02,700
jump to it the problem is the heap is

224
00:10:02,700 --> 00:10:06,180
not executable so this is where it's

225
00:10:06,180 --> 00:10:10,410
going to fail and you're gonna run into

226
00:10:10,410 --> 00:10:12,180
a problem so with this let me give you a

227
00:10:12,180 --> 00:10:15,030
very quick demo of the of the egg hunter

228
00:10:15,030 --> 00:10:21,030
and how it's laid out there can you

229
00:10:21,030 --> 00:10:24,570
folks all read this stuff great

230
00:10:24,570 --> 00:10:26,270
excellent

231
00:10:26,270 --> 00:10:32,310
cheat sheets so I have a I have a simple

232
00:10:32,310 --> 00:10:37,710
program with a vulnerability and here's

233
00:10:37,710 --> 00:10:39,570
your classic vulnerability you have a

234
00:10:39,570 --> 00:10:42,120
string copy in a buffer and you overflow

235
00:10:42,120 --> 00:10:45,060
the buffer with more than 128 you get a

236
00:10:45,060 --> 00:10:48,210
buffer overflow you get shellcode here's

237
00:10:48,210 --> 00:10:49,920
the shellcode right now the shellcode is

238
00:10:49,920 --> 00:10:52,940
basically breakpoint instructions and

239
00:10:52,940 --> 00:10:55,680
because there's a toy example I'm just

240
00:10:55,680 --> 00:10:58,530
loading it in the heap myself suffixed

241
00:10:58,530 --> 00:11:02,640
after these two hack hack signs in the

242
00:11:02,640 --> 00:11:04,050
shellcode I'm going to inject the egg

243
00:11:04,050 --> 00:11:06,030
hunter and then show you how this whole

244
00:11:06,030 --> 00:11:06,930
game

245
00:11:06,930 --> 00:11:12,390
goes right so let me load this in the

246
00:11:12,390 --> 00:11:14,779
debugger

247
00:11:19,620 --> 00:11:22,890
if I run a regular buffer or full buffer

248
00:11:22,890 --> 00:11:25,410
overflow like I just give it a very

249
00:11:25,410 --> 00:11:30,290
large string we it's gonna crash and

250
00:11:30,290 --> 00:11:33,330
there it is you're gonna get a

251
00:11:33,330 --> 00:11:34,620
segmentation fault

252
00:11:34,620 --> 00:11:36,750
we control the program counter all that

253
00:11:36,750 --> 00:11:41,400
fun stuff if we search the memory space

254
00:11:41,400 --> 00:11:44,760
of this process your heap is that hack

255
00:11:44,760 --> 00:11:47,250
in this case at address 11,000 your

256
00:11:47,250 --> 00:11:49,080
stacks over here both of them are non

257
00:11:49,080 --> 00:11:53,250
executable as they should be and if I

258
00:11:53,250 --> 00:12:10,680
search the heap there's a problem of

259
00:12:10,680 --> 00:12:12,510
live demos a Europe type out everything

260
00:12:12,510 --> 00:12:15,600
pretty fast okay so I'm going to search

261
00:12:15,600 --> 00:12:17,850
the heap for the string hack if it if it

262
00:12:17,850 --> 00:12:19,830
occurs in the heap and sure enough it

263
00:12:19,830 --> 00:12:22,020
occurs at two locations I'm going to

264
00:12:22,020 --> 00:12:24,030
dump the string over at the first

265
00:12:24,030 --> 00:12:27,690
location and yeah this is where it is

266
00:12:27,690 --> 00:12:29,670
this is the egg hack hack and this is

267
00:12:29,670 --> 00:12:31,860
the rest of the shellcode right now the

268
00:12:31,860 --> 00:12:34,890
page permission for this address if I

269
00:12:34,890 --> 00:12:38,070
look at it is the page permission is

270
00:12:38,070 --> 00:12:40,589
just read and write Sivan if we jump to

271
00:12:40,589 --> 00:12:44,490
it it's going to fail ok let me now show

272
00:12:44,490 --> 00:12:51,540
you the egg Hunter code and this is

273
00:12:51,540 --> 00:12:55,110
where the EM protect Egg hunter enters

274
00:12:55,110 --> 00:12:57,720
this is the modifications that I made to

275
00:12:57,720 --> 00:13:00,360
the egg hunter so this is basically a

276
00:13:00,360 --> 00:13:02,730
generic egg hunting shell code I

277
00:13:02,730 --> 00:13:05,130
mentioned to you the whole process of

278
00:13:05,130 --> 00:13:07,200
searching for the memory pages whether

279
00:13:07,200 --> 00:13:09,959
they exist or not I just did a very

280
00:13:09,959 --> 00:13:12,420
simple trick instead of searching for

281
00:13:12,420 --> 00:13:15,300
the pages using any other random syscall

282
00:13:15,300 --> 00:13:18,330
I will search the pages using the empro

283
00:13:18,330 --> 00:13:21,150
texas call itself so as i go searching

284
00:13:21,150 --> 00:13:23,730
the pages i'm going to mark the pages

285
00:13:23,730 --> 00:13:28,160
executable as we go along

286
00:13:28,160 --> 00:13:31,160
so

287
00:13:32,200 --> 00:13:35,740
basically this is what we're going to do

288
00:13:35,740 --> 00:13:38,780
the emperor tied egg hunter the moment

289
00:13:38,780 --> 00:13:41,090
you invoke it it's going to search the

290
00:13:41,090 --> 00:13:43,370
memory pages and as it goes it's going

291
00:13:43,370 --> 00:13:46,220
to mark them rwx when it finds a valid

292
00:13:46,220 --> 00:13:48,710
one so by the time we reach the heap the

293
00:13:48,710 --> 00:13:51,740
pages already are WX and our shell code

294
00:13:51,740 --> 00:13:55,180
is ready to be executed and this is the

295
00:13:55,180 --> 00:14:04,820
demo that I'm going to give you right so

296
00:14:04,820 --> 00:14:06,800
the the EM protect egg hunter is already

297
00:14:06,800 --> 00:14:09,970
in place I'm going to run this program

298
00:14:09,970 --> 00:14:16,730
again with the exploit which has the egg

299
00:14:16,730 --> 00:14:20,270
Hunter attached to it now when I run it

300
00:14:20,270 --> 00:14:22,760
the exploit is right now just triggered

301
00:14:22,760 --> 00:14:28,070
to stop at at a program counter and if I

302
00:14:28,070 --> 00:14:31,040
look at the memory map right now the

303
00:14:31,040 --> 00:14:34,910
stack is executable the heap is still

304
00:14:34,910 --> 00:14:38,600
not executable so this is basically the

305
00:14:38,600 --> 00:14:40,760
same exploit with the rob chain now

306
00:14:40,760 --> 00:14:41,990
after the rapture and I'm going to

307
00:14:41,990 --> 00:14:49,070
invoke the egg hunter and now that I do

308
00:14:49,070 --> 00:14:53,510
this final notice that instead of

309
00:14:53,510 --> 00:14:55,400
landing its instead of my program

310
00:14:55,400 --> 00:14:57,530
counter crashing my program counter

311
00:14:57,530 --> 00:14:59,780
ended up in the heap at the breakpoint

312
00:14:59,780 --> 00:15:01,520
instructions which have placed in the

313
00:15:01,520 --> 00:15:04,100
shellcode these two highlighted areas

314
00:15:04,100 --> 00:15:08,330
are the words hack hack program counters

315
00:15:08,330 --> 00:15:12,080
at 11,000 X 10 and if I now look at the

316
00:15:12,080 --> 00:15:15,020
VM map the egg hunter went and painted

317
00:15:15,020 --> 00:15:18,140
all these pages rwx so now the heap is

318
00:15:18,140 --> 00:15:22,520
rwx shellcode can execute and I will

319
00:15:22,520 --> 00:15:25,220
give you the final demo with egg victim

320
00:15:25,220 --> 00:15:28,310
1 where we have real shellcode loaded in

321
00:15:28,310 --> 00:15:30,800
the heap which is going to launch your

322
00:15:30,800 --> 00:15:35,120
bin shell and if I run the final attack

323
00:15:35,120 --> 00:15:36,920
that I did just previously instead of

324
00:15:36,920 --> 00:15:40,670
the breakpoints this should drop us into

325
00:15:40,670 --> 00:15:43,790
a shell which which it does and doesn't

326
00:15:43,790 --> 00:15:46,060
crash on us

327
00:15:46,060 --> 00:15:50,120
right so this was just the this was just

328
00:15:50,120 --> 00:15:53,480
a demo on about the egg hunter and the

329
00:15:53,480 --> 00:15:56,180
exploit that contains egg hunting this

330
00:15:56,180 --> 00:15:58,040
could be applied to any armed exploit

331
00:15:58,040 --> 00:16:01,670
wherever you have space limitations go

332
00:16:01,670 --> 00:16:05,930
ahead do the egg hunting okay now next

333
00:16:05,930 --> 00:16:11,180
one next we want to talk about the

334
00:16:11,180 --> 00:16:12,680
polyglot shellcode and where does a

335
00:16:12,680 --> 00:16:15,290
polyglot shellcode comment and this also

336
00:16:15,290 --> 00:16:19,360
brings me to my whole discussion on

337
00:16:19,360 --> 00:16:23,510
signature based defenses several people

338
00:16:23,510 --> 00:16:25,070
pointed out whenever I teach armed

339
00:16:25,070 --> 00:16:25,820
shellcode

340
00:16:25,820 --> 00:16:27,710
they say oh hey but you know we can

341
00:16:27,710 --> 00:16:29,480
always write a signature for this we can

342
00:16:29,480 --> 00:16:32,270
detect the arm to thumb switch and this

343
00:16:32,270 --> 00:16:34,370
is going to be very much the same with

344
00:16:34,370 --> 00:16:36,170
every shellcode so if we see an arm to

345
00:16:36,170 --> 00:16:37,640
thumb switch with some thump

346
00:16:37,640 --> 00:16:39,290
instructions we're gonna flag it bad

347
00:16:39,290 --> 00:16:44,050
saying that and then all your bro Yara

348
00:16:44,050 --> 00:16:46,700
IPS s are going to start screaming and

349
00:16:46,700 --> 00:16:48,680
and then all the DF air folks are going

350
00:16:48,680 --> 00:16:51,440
to start jumping around well that's

351
00:16:51,440 --> 00:16:53,690
that's all classic so I said I

352
00:16:53,690 --> 00:16:55,310
have to put an end to this signature

353
00:16:55,310 --> 00:16:58,010
thing like once and for all not by just

354
00:16:58,010 --> 00:16:59,960
by passing a signature but coming up

355
00:16:59,960 --> 00:17:03,080
with an entire different class of shell

356
00:17:03,080 --> 00:17:07,180
coding which cannot really be signature

357
00:17:07,180 --> 00:17:11,270
attractively and then I also came to it

358
00:17:11,270 --> 00:17:13,940
came to know that in several embedded

359
00:17:13,940 --> 00:17:16,490
situations this is a nice side benefit

360
00:17:16,490 --> 00:17:18,770
of the polyglot there are some processor

361
00:17:18,770 --> 00:17:20,390
which do not implement the arm

362
00:17:20,390 --> 00:17:22,220
instruction said their thumb only

363
00:17:22,220 --> 00:17:24,920
processors all the cortex-m processors

364
00:17:24,920 --> 00:17:27,050
the microcontroller processors they

365
00:17:27,050 --> 00:17:29,480
don't have the arm instruction set so I

366
00:17:29,480 --> 00:17:31,730
have basically ended up creating this

367
00:17:31,730 --> 00:17:34,700
one shellcode which can run in arm mode

368
00:17:34,700 --> 00:17:38,120
and switch your thumb or the same piece

369
00:17:38,120 --> 00:17:41,390
of data can be a polyglot if you force

370
00:17:41,390 --> 00:17:43,640
it to run in thumb mode it literally

371
00:17:43,640 --> 00:17:45,770
passes through and keeps you in thumb

372
00:17:45,770 --> 00:17:48,920
mode the instructions are basically

373
00:17:48,920 --> 00:17:52,520
chosen the same instructions do

374
00:17:52,520 --> 00:17:55,340
different things in arm and thumb so if

375
00:17:55,340 --> 00:17:58,280
you start in our mode the instructions

376
00:17:58,280 --> 00:18:00,010
we

377
00:18:00,010 --> 00:18:02,720
leap you to some more this word quantum

378
00:18:02,720 --> 00:18:05,690
leap was coined by a student at 44 Khan

379
00:18:05,690 --> 00:18:08,390
in September I like that terms right now

380
00:18:08,390 --> 00:18:10,370
instead of calling it universal mode

381
00:18:10,370 --> 00:18:12,500
shellcode which is nice quantum leap

382
00:18:12,500 --> 00:18:15,679
sounds cooler so you have to have the

383
00:18:15,679 --> 00:18:17,059
right nomenclature otherwise people

384
00:18:17,059 --> 00:18:18,710
don't pay attention to you an info sake

385
00:18:18,710 --> 00:18:21,740
or you have a right logo or something

386
00:18:21,740 --> 00:18:22,039
like that

387
00:18:22,039 --> 00:18:26,809
anyway so if you start an arm mode these

388
00:18:26,809 --> 00:18:28,880
the quantum leap instructions will

389
00:18:28,880 --> 00:18:30,620
switch you over to thumb mode but if you

390
00:18:30,620 --> 00:18:32,990
start in thumb mode these same

391
00:18:32,990 --> 00:18:35,029
instructions will literally just pass

392
00:18:35,029 --> 00:18:37,700
through and do nothing keep you in thumb

393
00:18:37,700 --> 00:18:40,130
mode and byte by byte these instructions

394
00:18:40,130 --> 00:18:42,230
are exactly the same so the starting

395
00:18:42,230 --> 00:18:44,389
mode of the processor the shellcode

396
00:18:44,389 --> 00:18:46,639
switch part is agnostic to the starting

397
00:18:46,639 --> 00:18:48,919
mode of the processor now how do you

398
00:18:48,919 --> 00:18:52,220
cook all of this stuff up to do this you

399
00:18:52,220 --> 00:18:54,799
kind of have to have a warped mind in to

400
00:18:54,799 --> 00:18:57,590
think in terms of polyglots but most

401
00:18:57,590 --> 00:18:59,899
importantly you need to be able to

402
00:18:59,899 --> 00:19:01,760
understand arm and some instruction

403
00:19:01,760 --> 00:19:04,940
encoding very very well and playing

404
00:19:04,940 --> 00:19:07,250
around with RISC processors instruction

405
00:19:07,250 --> 00:19:09,679
encoding in RISC processors is is a

406
00:19:09,679 --> 00:19:12,230
sense but it's actually also an art it

407
00:19:12,230 --> 00:19:15,500
basically depends upon how how clever

408
00:19:15,500 --> 00:19:17,299
can the engineers be to pack as much

409
00:19:17,299 --> 00:19:20,139
information in a single bit as possible

410
00:19:20,139 --> 00:19:23,990
so we want to choose instructions which

411
00:19:23,990 --> 00:19:25,909
will do something meaningful when

412
00:19:25,909 --> 00:19:28,940
running our mode but the same arm

413
00:19:28,940 --> 00:19:31,159
instruction it is four bytes long you

414
00:19:31,159 --> 00:19:33,529
split an arm instruction into to thump

415
00:19:33,529 --> 00:19:35,690
instructions each of these thurman

416
00:19:35,690 --> 00:19:37,700
structions simply does nothing lets you

417
00:19:37,700 --> 00:19:41,779
pass through to understand this we also

418
00:19:41,779 --> 00:19:44,299
will talk about conditional execution in

419
00:19:44,299 --> 00:19:46,039
our which is really useful now that's

420
00:19:46,039 --> 00:19:48,350
what makes the polyglot support happen

421
00:19:48,350 --> 00:19:50,120
and then we need some luck and

422
00:19:50,120 --> 00:19:55,179
perseverance okay so kind of get to to

423
00:19:55,179 --> 00:20:00,769
the the arm to some switch if we take

424
00:20:00,769 --> 00:20:02,960
this blue code which is the arm to thumb

425
00:20:02,960 --> 00:20:06,830
cell code switch code and forcibly

426
00:20:06,830 --> 00:20:11,090
convert these eight bytes of arm

427
00:20:11,090 --> 00:20:12,290
instruction

428
00:20:12,290 --> 00:20:16,490
into forcibly convert these two arm

429
00:20:16,490 --> 00:20:18,380
instructions into four thump

430
00:20:18,380 --> 00:20:20,660
instructions this is what the conversion

431
00:20:20,660 --> 00:20:25,100
looks like so byte by byte the first add

432
00:20:25,100 --> 00:20:27,200
instruction becomes an arithmetic shift

433
00:20:27,200 --> 00:20:30,380
right and a branch instruction and then

434
00:20:30,380 --> 00:20:33,050
the second branch instruction in arm

435
00:20:33,050 --> 00:20:36,470
becomes a I don't know what the hell

436
00:20:36,470 --> 00:20:38,720
this up code means I just call it very

437
00:20:38,720 --> 00:20:40,660
horrible add instruction it's like a

438
00:20:40,660 --> 00:20:42,920
vector floating point instruction but

439
00:20:42,920 --> 00:20:45,290
you have no idea what it does right but

440
00:20:45,290 --> 00:20:47,630
basically I don't want that so now when

441
00:20:47,630 --> 00:20:49,280
you're doing this polyglot stuff you

442
00:20:49,280 --> 00:20:51,170
want to you want the good instructions

443
00:20:51,170 --> 00:20:53,000
to stay through this one's a good

444
00:20:53,000 --> 00:20:55,130
instruction the ASRs arithmetic shift

445
00:20:55,130 --> 00:20:57,590
right no problem I can live with that

446
00:20:57,590 --> 00:21:00,110
doesn't destroy me but the destructive

447
00:21:00,110 --> 00:21:02,000
ones are the branch instructions they

448
00:21:02,000 --> 00:21:03,860
transfer my program control screw me up

449
00:21:03,860 --> 00:21:06,740
can't have a branch this vector horrible

450
00:21:06,740 --> 00:21:08,120
instruction I don't want that either

451
00:21:08,120 --> 00:21:09,970
because I don't know what it does and

452
00:21:09,970 --> 00:21:13,310
then I also wanted some better goals for

453
00:21:13,310 --> 00:21:14,720
myself that this should work on the

454
00:21:14,720 --> 00:21:16,460
lowest possible lowest common

455
00:21:16,460 --> 00:21:19,910
denominators of arm the arm v6 or mv5 we

456
00:21:19,910 --> 00:21:21,980
don't need special some instructions we

457
00:21:21,980 --> 00:21:24,410
don't need illegal instructions so with

458
00:21:24,410 --> 00:21:28,580
this objectives I started playing around

459
00:21:28,580 --> 00:21:36,140
with arm and thumb decoding if we take

460
00:21:36,140 --> 00:21:38,810
the first add instruction the add PC

461
00:21:38,810 --> 00:21:41,170
comma one is basically responsible for

462
00:21:41,170 --> 00:21:43,790
setting the thumb flag and then the

463
00:21:43,790 --> 00:21:46,370
branch will switch to thumb if we take

464
00:21:46,370 --> 00:21:48,620
that add instruction and decode it bit

465
00:21:48,620 --> 00:21:52,790
by bit all the four bytes decoded every

466
00:21:52,790 --> 00:21:56,920
arm instruction always has fixed areas

467
00:21:56,920 --> 00:21:59,180
like the first four bits will be the

468
00:21:59,180 --> 00:22:01,220
conditional bits then immediate opcode

469
00:22:01,220 --> 00:22:03,770
status first operand destination

470
00:22:03,770 --> 00:22:06,110
register and second operand this is the

471
00:22:06,110 --> 00:22:09,320
format of decoding is fixed now if we

472
00:22:09,320 --> 00:22:13,190
take the least significant 16 bits that

473
00:22:13,190 --> 00:22:15,260
is the first thump instruction now we're

474
00:22:15,260 --> 00:22:17,210
going to split that and view them as two

475
00:22:17,210 --> 00:22:20,450
thumbs and the most significant 16 bits

476
00:22:20,450 --> 00:22:23,030
are the second thumb instruction what

477
00:22:23,030 --> 00:22:25,490
will influence each of these thumb

478
00:22:25,490 --> 00:22:26,270
instruction

479
00:22:26,270 --> 00:22:29,240
so they forced some instruction the

480
00:22:29,240 --> 00:22:33,200
instruction itself is controlled largely

481
00:22:33,200 --> 00:22:37,010
by the destination register that is they

482
00:22:37,010 --> 00:22:40,280
are one over here and the operands of

483
00:22:40,280 --> 00:22:43,220
the arm instruction is the second half

484
00:22:43,220 --> 00:22:44,840
of the arm instruction controls this

485
00:22:44,840 --> 00:22:47,120
instruction it's easier to control

486
00:22:47,120 --> 00:22:48,410
because you can choose or to put in

487
00:22:48,410 --> 00:22:52,580
there the first I mean the second time

488
00:22:52,580 --> 00:22:54,920
instructions basically control largely

489
00:22:54,920 --> 00:22:59,300
by the opcode and conditional Flags this

490
00:22:59,300 --> 00:23:01,310
is tricky because if you want to do an

491
00:23:01,310 --> 00:23:03,770
ADD then you only get a limited few

492
00:23:03,770 --> 00:23:05,390
choices of thumb instructions which the

493
00:23:05,390 --> 00:23:07,550
ad will translate into and that's what

494
00:23:07,550 --> 00:23:11,300
screws us up fortunately for us we have

495
00:23:11,300 --> 00:23:14,180
the conditionals to help us out so if I

496
00:23:14,180 --> 00:23:17,900
do the decoding the second thumb means I

497
00:23:17,900 --> 00:23:19,910
mean there's the second half the first

498
00:23:19,910 --> 00:23:22,040
some instruction is easy that results

499
00:23:22,040 --> 00:23:26,090
into a SRS and it is this r1 in the arm

500
00:23:26,090 --> 00:23:29,150
operand that is responsible for the

501
00:23:29,150 --> 00:23:33,260
choice of opcode in the thumb mode in

502
00:23:33,260 --> 00:23:37,390
the second instruction the opcode is

503
00:23:37,390 --> 00:23:40,990
influenced by the conditional flags

504
00:23:40,990 --> 00:23:44,090
which means that I have to now if I want

505
00:23:44,090 --> 00:23:46,610
the valid decoding to happen in in the

506
00:23:46,610 --> 00:23:49,220
in the thumb mode and I don't want the

507
00:23:49,220 --> 00:23:51,170
branch instruction if I want to change

508
00:23:51,170 --> 00:23:53,630
the branch I have to play around with

509
00:23:53,630 --> 00:23:59,180
conditional Flags now in our mode any

510
00:23:59,180 --> 00:24:01,640
instruction can be made conditional that

511
00:24:01,640 --> 00:24:04,340
is instead of add you can have an

512
00:24:04,340 --> 00:24:06,590
instruction variation like add if equals

513
00:24:06,590 --> 00:24:08,240
that if not equals that if greater than

514
00:24:08,240 --> 00:24:09,860
add if not not greater than something

515
00:24:09,860 --> 00:24:13,220
like this but if an arm instruction is

516
00:24:13,220 --> 00:24:14,720
made conditional we don't have any

517
00:24:14,720 --> 00:24:17,030
guarantee of it executing what if the

518
00:24:17,030 --> 00:24:18,590
conditional situation is different it

519
00:24:18,590 --> 00:24:20,360
doesn't execute then that screws us up

520
00:24:20,360 --> 00:24:23,180
so how can we make arm instructions

521
00:24:23,180 --> 00:24:25,400
conditional yet execute them

522
00:24:25,400 --> 00:24:28,430
unconditionally force them to be

523
00:24:28,430 --> 00:24:30,820
executed under conditionally and the

524
00:24:30,820 --> 00:24:34,400
guarantee is made by using complementary

525
00:24:34,400 --> 00:24:37,790
conditions so instead of one instruction

526
00:24:37,790 --> 00:24:39,360
add

527
00:24:39,360 --> 00:24:42,120
you always place two instructions but

528
00:24:42,120 --> 00:24:44,040
the conditional flags are complimentary

529
00:24:44,040 --> 00:24:47,160
the first one is a DIF not equals okay

530
00:24:47,160 --> 00:24:48,330
if that doesn't go through the second

531
00:24:48,330 --> 00:24:50,880
one is a difficult one of them is bound

532
00:24:50,880 --> 00:24:52,320
to go through no matter what the

533
00:24:52,320 --> 00:24:55,380
conditions are but by adding the

534
00:24:55,380 --> 00:24:57,510
conditional flags I have changed the

535
00:24:57,510 --> 00:25:00,530
first four bits of the resultant

536
00:25:00,530 --> 00:25:05,550
encoding now if I do the decoding things

537
00:25:05,550 --> 00:25:09,900
look a lot better so the first

538
00:25:09,900 --> 00:25:12,470
instruction if it's a DIF not equals I

539
00:25:12,470 --> 00:25:15,270
decode it okay the the first time

540
00:25:15,270 --> 00:25:17,490
instructions still a SRS that's okay

541
00:25:17,490 --> 00:25:20,880
the second thumb instruction is now

542
00:25:20,880 --> 00:25:24,420
based on the not equals condition in the

543
00:25:24,420 --> 00:25:27,120
first instruction and that also results

544
00:25:27,120 --> 00:25:29,970
in an A SRS which is fine then if we go

545
00:25:29,970 --> 00:25:32,340
to the second one again in a SRS and

546
00:25:32,340 --> 00:25:36,060
then the next condition equals results

547
00:25:36,060 --> 00:25:39,690
in LS LS by playing around with instra

548
00:25:39,690 --> 00:25:42,120
with conditions correctly I can

549
00:25:42,120 --> 00:25:46,230
therefore control what instructions will

550
00:25:46,230 --> 00:25:48,840
be generated when viewed in thumb mode

551
00:25:48,840 --> 00:25:51,750
and in this case all the instructions

552
00:25:51,750 --> 00:25:55,320
are okay and I'm not I'm not bothered or

553
00:25:55,320 --> 00:25:58,110
not limited with any of these issues

554
00:25:58,110 --> 00:26:01,860
no destructive instructions so with this

555
00:26:01,860 --> 00:26:05,750
theory how to come up with the final

556
00:26:05,750 --> 00:26:10,370
shellcode let me show you

557
00:26:16,520 --> 00:26:20,240
so I made one iteration basically you

558
00:26:20,240 --> 00:26:21,950
have to add some odd number to the

559
00:26:21,950 --> 00:26:23,840
program counter and branch that is

560
00:26:23,840 --> 00:26:25,220
what's going to switch you into thumb

561
00:26:25,220 --> 00:26:30,290
mode so my first attempt I made several

562
00:26:30,290 --> 00:26:32,750
attempts as you can plainly see from

563
00:26:32,750 --> 00:26:35,150
from all this I'm not going to go into

564
00:26:35,150 --> 00:26:36,920
each and every micro detail of the

565
00:26:36,920 --> 00:26:40,040
attempts but let me show a good attempt

566
00:26:40,040 --> 00:26:44,060
that succeeded not succeeded sorry okay

567
00:26:44,060 --> 00:26:49,210
universe so I tried the oops

568
00:26:49,210 --> 00:26:52,670
the first one was rather simple I just

569
00:26:52,670 --> 00:26:56,030
did two ads with complementary instruct

570
00:26:56,030 --> 00:26:57,650
complementary conditions and then

571
00:26:57,650 --> 00:27:00,080
instead of a branch I did a move PC

572
00:27:00,080 --> 00:27:04,820
comma r1 this had promised but it didn't

573
00:27:04,820 --> 00:27:07,670
do well when when I forced decoded them

574
00:27:07,670 --> 00:27:10,760
this into thumb so then I went instead

575
00:27:10,760 --> 00:27:16,610
of then I started playing with a choice

576
00:27:16,610 --> 00:27:18,980
of registers instead of r1 I started

577
00:27:18,980 --> 00:27:21,590
playing around with our for our for

578
00:27:21,590 --> 00:27:26,090
started giving better choices so if I do

579
00:27:26,090 --> 00:27:36,530
the object dump with in arm mode the

580
00:27:36,530 --> 00:27:38,960
object dump in our mode is normal this

581
00:27:38,960 --> 00:27:42,560
is how it's supposed to be and if I

582
00:27:42,560 --> 00:27:46,810
force the object dump into thumb mode

583
00:27:47,860 --> 00:27:52,280
then you notice that the thumb mode this

584
00:27:52,280 --> 00:27:55,190
stuff is kind of okay add move and no

585
00:27:55,190 --> 00:27:58,220
problem these two instructions are valid

586
00:27:58,220 --> 00:27:59,900
instructions but their thumb two

587
00:27:59,900 --> 00:28:03,140
instructions it is only work for an v7

588
00:28:03,140 --> 00:28:05,300
the newer course and v6 course don't

589
00:28:05,300 --> 00:28:07,340
support thumb too so while this code

590
00:28:07,340 --> 00:28:10,160
will work I this I wasn't very happy

591
00:28:10,160 --> 00:28:12,350
with it I want pure code which works in

592
00:28:12,350 --> 00:28:15,620
the lowest common denominators and this

593
00:28:15,620 --> 00:28:18,410
basically leads us to the final

594
00:28:18,410 --> 00:28:23,750
iteration of the code this is the final

595
00:28:23,750 --> 00:28:27,890
shell code that I created this is the

596
00:28:27,890 --> 00:28:29,140
switch

597
00:28:29,140 --> 00:28:34,600
you do the ad you then basically store

598
00:28:34,600 --> 00:28:37,180
save the stack pointer you push the

599
00:28:37,180 --> 00:28:41,770
register you push this destination

600
00:28:41,770 --> 00:28:43,570
register on the stack and pop it in to

601
00:28:43,570 --> 00:28:45,520
the program counter so instead of the

602
00:28:45,520 --> 00:28:47,710
branch I did a push and pop push on the

603
00:28:47,710 --> 00:28:49,540
stack and pop in to program counter and

604
00:28:49,540 --> 00:28:53,040
this avoids any destructive infamy

605
00:28:53,040 --> 00:28:55,680
instructions this is basically took like

606
00:28:55,680 --> 00:28:59,710
four nights of work you can only work at

607
00:28:59,710 --> 00:29:01,180
night because then you get eight hours

608
00:29:01,180 --> 00:29:04,210
of uninterrupted time your req during

609
00:29:04,210 --> 00:29:07,420
the day but it's good output so four

610
00:29:07,420 --> 00:29:09,640
nights have gone into this but now you

611
00:29:09,640 --> 00:29:11,530
can see the resultant instructions are

612
00:29:11,530 --> 00:29:15,070
all non-destructive you have ad move add

613
00:29:15,070 --> 00:29:16,480
move

614
00:29:16,480 --> 00:29:18,880
compare compare nothing nothing wrong

615
00:29:18,880 --> 00:29:21,970
with this so now let me give you the

616
00:29:21,970 --> 00:29:27,870
demo I have two demos one is if I start

617
00:29:28,200 --> 00:29:32,380
if I start in our mode I should switch

618
00:29:32,380 --> 00:29:36,790
to thumb mode so I have the test in our

619
00:29:36,790 --> 00:29:39,160
mode I'm going to start an arm or this

620
00:29:39,160 --> 00:29:42,460
is the quantum leap stub which will

621
00:29:42,460 --> 00:29:44,320
switch me to thumb mode and the rest of

622
00:29:44,320 --> 00:29:47,680
the shellcode is in thumb this should

623
00:29:47,680 --> 00:29:52,360
work seamlessly and the second demo is

624
00:29:52,360 --> 00:29:56,980
if I start in thumb mode then I should

625
00:29:56,980 --> 00:29:59,740
stay in thumb mode so this is the thumb

626
00:29:59,740 --> 00:30:02,830
test where my processor right now is an

627
00:30:02,830 --> 00:30:04,750
ARM processor so first I will switch it

628
00:30:04,750 --> 00:30:07,390
to thumb then here is a quantum leap

629
00:30:07,390 --> 00:30:10,630
code in thumb which should stay in thumb

630
00:30:10,630 --> 00:30:15,660
and still execute the shell so first

631
00:30:15,660 --> 00:30:19,020
debug demo

632
00:30:23,350 --> 00:30:29,040
right load it up I hope this works

633
00:30:29,040 --> 00:30:35,320
yeah otherwise I look like a fool who is

634
00:30:35,320 --> 00:30:36,640
a greater fool we'll have to debate

635
00:30:36,640 --> 00:30:39,580
about it okay me for screwing up or you

636
00:30:39,580 --> 00:30:42,820
for having me here anyways so here we

637
00:30:42,820 --> 00:30:45,460
are the right now you're an armed mode

638
00:30:45,460 --> 00:30:47,530
basically the debugger tells you the

639
00:30:47,530 --> 00:30:50,110
thumb flag is off so you you're an armed

640
00:30:50,110 --> 00:30:52,720
mode and the program counter is going to

641
00:30:52,720 --> 00:30:55,510
start this is going this is the quantum

642
00:30:55,510 --> 00:30:58,420
leap stub it's going to execute these

643
00:30:58,420 --> 00:31:01,000
instructions let me dump out these

644
00:31:01,000 --> 00:31:04,900
instructions so these are the

645
00:31:04,900 --> 00:31:06,340
instructions that the program counter is

646
00:31:06,340 --> 00:31:10,000
going to execute and then after that you

647
00:31:10,000 --> 00:31:12,160
have thump instructions so I'm going to

648
00:31:12,160 --> 00:31:14,110
step through these instructions step

649
00:31:14,110 --> 00:31:17,770
through all eight straightaway and now

650
00:31:17,770 --> 00:31:20,530
this quantum leap code is done let's

651
00:31:20,530 --> 00:31:22,330
check the mode Wow

652
00:31:22,330 --> 00:31:23,500
now we've been placed into the thumb

653
00:31:23,500 --> 00:31:26,830
mode so the switch happened and the rest

654
00:31:26,830 --> 00:31:29,170
of the shellcode is in thumb if I

655
00:31:29,170 --> 00:31:32,200
continue I'll get a shell and this is

656
00:31:32,200 --> 00:31:35,470
this is working so if you start an arm

657
00:31:35,470 --> 00:31:38,760
you switch to thumb and then things work

658
00:31:38,760 --> 00:31:43,020
now the last one if you start in thumb

659
00:31:43,020 --> 00:31:45,490
then you should stay in thumb the

660
00:31:45,490 --> 00:31:47,080
instructions shouldn't destroy you

661
00:31:47,080 --> 00:31:52,320
and that's the the last demo coming up

662
00:31:55,140 --> 00:31:58,900
start it so first I will forcibly switch

663
00:31:58,900 --> 00:32:01,450
to thumb mode before doing the quantum

664
00:32:01,450 --> 00:32:03,640
leap code so I'll step two instructions

665
00:32:03,640 --> 00:32:07,420
which now have switched me into thumb

666
00:32:07,420 --> 00:32:09,430
mode so this will consider this as a

667
00:32:09,430 --> 00:32:12,400
starting point if I now dump the

668
00:32:12,400 --> 00:32:17,590
instructions in arm these are this is

669
00:32:17,590 --> 00:32:19,570
the quantum leap shell code when viewed

670
00:32:19,570 --> 00:32:22,630
in arm mode if I view the same

671
00:32:22,630 --> 00:32:26,050
instructions in thumb mode eight

672
00:32:26,050 --> 00:32:28,330
instructions result in 216 thump

673
00:32:28,330 --> 00:32:32,080
instructions and these are this the same

674
00:32:32,080 --> 00:32:35,200
instructions when viewed in thumb now

675
00:32:35,200 --> 00:32:36,580
I'm in some modes I'm going to basically

676
00:32:36,580 --> 00:32:37,299
stay

677
00:32:37,299 --> 00:32:41,739
through all 16 of these and the nein

678
00:32:41,739 --> 00:32:46,119
result is I should stay in thumb mode so

679
00:32:46,119 --> 00:32:48,190
I stepped through all 16 I'm still in

680
00:32:48,190 --> 00:32:50,710
thumb mode and then if I continue

681
00:32:50,710 --> 00:32:55,330
forward I get my shell again so

682
00:32:55,330 --> 00:32:58,919
basically what's now done with this

683
00:32:58,919 --> 00:33:00,899
quantum leap code

684
00:33:00,899 --> 00:33:05,409
yes polyglots turned is okay not only

685
00:33:05,409 --> 00:33:10,950
have a achieved more independence but

686
00:33:12,960 --> 00:33:15,700
there's no way you can signature a

687
00:33:15,700 --> 00:33:16,960
polyglot like this

688
00:33:16,960 --> 00:33:20,320
good luck writing those yarra rules you

689
00:33:20,320 --> 00:33:23,379
know and if you do write a clumsy or a

690
00:33:23,379 --> 00:33:25,299
rule which matches this then I will

691
00:33:25,299 --> 00:33:27,100
change the conditioners I will change

692
00:33:27,100 --> 00:33:30,369
the registers and mutate this probably I

693
00:33:30,369 --> 00:33:33,609
can create like damn nearly endless

694
00:33:33,609 --> 00:33:37,359
mutations and change the order and you

695
00:33:37,359 --> 00:33:40,960
will not be able to write any regular

696
00:33:40,960 --> 00:33:42,999
expression then of course then what you

697
00:33:42,999 --> 00:33:44,619
do is you throw machine learning at it

698
00:33:44,619 --> 00:33:46,809
was that so gonna solve everything but

699
00:33:46,809 --> 00:33:48,489
anyway by that time happens I'm sure

700
00:33:48,489 --> 00:33:49,929
we'll put out another talk in another

701
00:33:49,929 --> 00:33:51,879
polyglot to beat the out of that as

702
00:33:51,879 --> 00:33:55,509
well right so the final stuff in the

703
00:33:55,509 --> 00:33:57,609
quantum leap code this this basically

704
00:33:57,609 --> 00:34:03,249
worked I did the demo conclusion so

705
00:34:03,249 --> 00:34:05,919
there's a lot of opportunity not only

706
00:34:05,919 --> 00:34:08,379
for exploring arm shellcode but also

707
00:34:08,379 --> 00:34:10,510
explore tricks with arm shellcodes are

708
00:34:10,510 --> 00:34:13,239
just two tricks that I presented if you

709
00:34:13,239 --> 00:34:14,559
want to play with them the codes

710
00:34:14,559 --> 00:34:17,500
available on github take it modify it if

711
00:34:17,500 --> 00:34:19,059
you find better tricks please let me

712
00:34:19,059 --> 00:34:22,659
know I'll buy your beers and or or any

713
00:34:22,659 --> 00:34:26,109
beverage of a choice and then that's

714
00:34:26,109 --> 00:34:27,940
about it thank you very much for your

715
00:34:27,940 --> 00:34:30,629
time and attention

716
00:34:31,480 --> 00:34:44,659
[Music]

