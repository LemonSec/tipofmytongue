1
00:00:02,270 --> 00:00:24,009
[Music]

2
00:00:31,310 --> 00:00:35,729
[Music]

3
00:00:43,930 --> 00:00:49,480
okay hello everybody I'm really excited

4
00:00:47,980 --> 00:00:51,610
to be here thank you for coming to my

5
00:00:49,480 --> 00:00:53,830
talk shadow reloaded where I'll talk

6
00:00:51,610 --> 00:00:56,050
about how we revived shadow attacks in

7
00:00:53,830 --> 00:00:59,110
order to escape sandboxes and evade

8
00:00:56,050 --> 00:01:03,699
endpoint security products so a little

9
00:00:59,110 --> 00:01:05,289
bit about myself my name is Ron I am the

10
00:01:03,700 --> 00:01:08,980
engineering lead for Accenture security

11
00:01:05,290 --> 00:01:10,800
Israel as part of the R&D team so now

12
00:01:08,980 --> 00:01:13,360
let's dive right into the matter at hand

13
00:01:10,800 --> 00:01:15,509
so a bit abettor about the history of

14
00:01:13,360 --> 00:01:18,820
shadow attacks how it all started

15
00:01:15,510 --> 00:01:22,360
Soto started in one rainy day in 2002

16
00:01:18,820 --> 00:01:24,220
where this guy crisp packets published

17
00:01:22,360 --> 00:01:26,770
an article titled exploiting design

18
00:01:24,220 --> 00:01:29,320
flaws in the win32 api for privileged

19
00:01:26,770 --> 00:01:32,800
escalation or shadow attacks how to

20
00:01:29,320 --> 00:01:35,770
break windows so in this paper he

21
00:01:32,800 --> 00:01:38,080
describes this attack that he has where

22
00:01:35,770 --> 00:01:41,830
he uses a WM time or Windows message

23
00:01:38,080 --> 00:01:44,289
sent to a target process and that

24
00:01:41,830 --> 00:01:46,960
message has a pointer to a callback that

25
00:01:44,290 --> 00:01:49,630
would be executed now this callback he

26
00:01:46,960 --> 00:01:53,919
injects some code using a an edit box

27
00:01:49,630 --> 00:01:56,170
control and then the pointer to the

28
00:01:53,920 --> 00:01:58,870
callback points to that code the target

29
00:01:56,170 --> 00:02:01,060
process would usually be some win32

30
00:01:58,870 --> 00:02:04,180
service running as system and showing

31
00:02:01,060 --> 00:02:06,730
some GUI to the users the way this

32
00:02:04,180 --> 00:02:08,980
attack would work is first of all the

33
00:02:06,730 --> 00:02:11,739
attacker would find the Edit box in the

34
00:02:08,979 --> 00:02:14,049
target process and call send message to

35
00:02:11,739 --> 00:02:16,989
it sending it the WM set text message

36
00:02:14,050 --> 00:02:20,110
this segment set text message would

37
00:02:16,989 --> 00:02:23,410
receive a buffer which would be copied

38
00:02:20,110 --> 00:02:24,820
over to the target process this buffer

39
00:02:23,410 --> 00:02:27,220
would obviously contain the shell codes

40
00:02:24,820 --> 00:02:29,590
now the second step he would find the

41
00:02:27,220 --> 00:02:30,760
shell code inside the target process so

42
00:02:29,590 --> 00:02:32,650
he could do that in one of two ways

43
00:02:30,760 --> 00:02:34,570
either by scanning the memory of the

44
00:02:32,650 --> 00:02:36,330
target process or just running it in a

45
00:02:34,570 --> 00:02:38,320
lab environment using a debugger and

46
00:02:36,330 --> 00:02:41,100
assuming that the address will be the

47
00:02:38,320 --> 00:02:43,269
same always which was true at the time

48
00:02:41,100 --> 00:02:46,000
once he has the address of that shell

49
00:02:43,269 --> 00:02:47,860
code he would then send a second message

50
00:02:46,000 --> 00:02:49,810
to the target process this time a WM

51
00:02:47,860 --> 00:02:52,870
timer containing a pointer to that

52
00:02:49,810 --> 00:02:57,090
address that he found thus achieving

53
00:02:52,870 --> 00:02:58,950
code execution now Microsoft saw this

54
00:02:57,090 --> 00:03:00,269
and they said okay how can we stop this

55
00:02:58,950 --> 00:03:03,268
so eventually what they did is they

56
00:03:00,269 --> 00:03:06,450
patched the WM timer so that it won't be

57
00:03:03,269 --> 00:03:08,430
able to execute any timer that wasn't

58
00:03:06,450 --> 00:03:12,569
previously registered with the set timer

59
00:03:08,430 --> 00:03:14,580
API also they started a move to stop

60
00:03:12,569 --> 00:03:19,079
those services from showing GUI to the

61
00:03:14,580 --> 00:03:20,670
users because that's a bad practice but

62
00:03:19,080 --> 00:03:23,280
that's not good enough because WM timer

63
00:03:20,670 --> 00:03:24,629
is just one example of a Windows message

64
00:03:23,280 --> 00:03:26,250
that can do that because there are other

65
00:03:24,629 --> 00:03:28,649
Windows messages that also receive a

66
00:03:26,250 --> 00:03:30,690
pointer to a callback and then just

67
00:03:28,650 --> 00:03:33,480
execute it so rich edit controls has a

68
00:03:30,690 --> 00:03:35,220
few ListView has one for sorting items

69
00:03:33,480 --> 00:03:38,819
and a treeview also has one for sorting

70
00:03:35,220 --> 00:03:40,500
its children so let's take a step

71
00:03:38,819 --> 00:03:43,170
backward and see why were these attacks

72
00:03:40,500 --> 00:03:44,579
even possible in the first place so the

73
00:03:43,170 --> 00:03:46,589
first reason is that there were no

74
00:03:44,579 --> 00:03:48,989
access control mechanisms for Windows

75
00:03:46,590 --> 00:03:51,690
messages between processes in the same

76
00:03:48,989 --> 00:03:54,269
desktop so any process even one running

77
00:03:51,690 --> 00:03:56,040
as guest could send a Windows message to

78
00:03:54,269 --> 00:03:59,700
any other process in the same desktop

79
00:03:56,040 --> 00:04:03,120
even one running a system the second

80
00:03:59,700 --> 00:04:05,700
thing is that there were services

81
00:04:03,120 --> 00:04:08,180
running inside the users desktop so the

82
00:04:05,700 --> 00:04:12,060
same desktop has both user processes and

83
00:04:08,180 --> 00:04:14,250
services running our system the third

84
00:04:12,060 --> 00:04:16,649
thing is that some services running our

85
00:04:14,250 --> 00:04:18,779
system expose a GUI to the user and

86
00:04:16,649 --> 00:04:20,310
that's bad because if they expose a GUI

87
00:04:18,779 --> 00:04:24,690
that means they can be interacted with

88
00:04:20,310 --> 00:04:27,240
by normal users and fourth remotes

89
00:04:24,690 --> 00:04:29,010
windows messages could contain pointers

90
00:04:27,240 --> 00:04:32,280
to a shell code that will then be

91
00:04:29,010 --> 00:04:34,440
executed by the target process so the

92
00:04:32,280 --> 00:04:38,669
combination of all these together allows

93
00:04:34,440 --> 00:04:40,889
us to achieve this shatter attack then

94
00:04:38,669 --> 00:04:44,250
came Windows Vista and Windows Vista put

95
00:04:40,889 --> 00:04:46,470
in a few security fixes to prevent these

96
00:04:44,250 --> 00:04:47,849
things from happening so the first thing

97
00:04:46,470 --> 00:04:49,740
they did they introduced a mechanism

98
00:04:47,849 --> 00:04:53,400
called user interface privileged

99
00:04:49,740 --> 00:04:55,590
isolation or you IPI this held something

100
00:04:53,400 --> 00:04:57,810
called mandatory integrity control or in

101
00:04:55,590 --> 00:05:00,239
other words each process will receive an

102
00:04:57,810 --> 00:05:03,060
integrity level low medium high or

103
00:05:00,240 --> 00:05:07,140
system normal processes would usually

104
00:05:03,060 --> 00:05:09,330
get normal sorry medium level elevated

105
00:05:07,140 --> 00:05:10,800
processes would get high and system

106
00:05:09,330 --> 00:05:12,690
processes would get system

107
00:05:10,800 --> 00:05:15,720
and this mechanism would prevent Windows

108
00:05:12,690 --> 00:05:18,090
messages from being sent from a one

109
00:05:15,720 --> 00:05:21,389
process to another if the target process

110
00:05:18,090 --> 00:05:23,250
has a higher integrity level another

111
00:05:21,389 --> 00:05:24,750
thing they did is a introduced Windows

112
00:05:23,250 --> 00:05:27,629
session zero isolation

113
00:05:24,750 --> 00:05:29,069
so if until now the first years are

114
00:05:27,629 --> 00:05:32,129
connecting into the computer logging in

115
00:05:29,069 --> 00:05:34,110
would log into session zero this is no

116
00:05:32,129 --> 00:05:35,849
longer the case now a new user would

117
00:05:34,110 --> 00:05:38,099
receive session one two and so on

118
00:05:35,849 --> 00:05:41,639
and session zero is reserved only for

119
00:05:38,099 --> 00:05:42,900
these system services also they

120
00:05:41,639 --> 00:05:44,789
introduced the interactive service

121
00:05:42,900 --> 00:05:46,770
protection which is a mechanism that

122
00:05:44,789 --> 00:05:49,740
said if there is a service that tries to

123
00:05:46,770 --> 00:05:51,930
show gooey to the user then it will open

124
00:05:49,740 --> 00:05:54,509
up this ugly message box this ugly pop

125
00:05:51,930 --> 00:05:56,550
up and say to the user you know there's

126
00:05:54,509 --> 00:05:58,740
a service trying to show you some user

127
00:05:56,550 --> 00:06:00,330
interface on another desktop do you want

128
00:05:58,740 --> 00:06:03,780
to go over to that desktop and see it

129
00:06:00,330 --> 00:06:05,940
and this kind of forced all vendors

130
00:06:03,780 --> 00:06:11,309
Microsoft and third-party vendors to

131
00:06:05,940 --> 00:06:13,680
stop showing GUI in their services so

132
00:06:11,310 --> 00:06:16,620
this basically put a stop to shatter

133
00:06:13,680 --> 00:06:19,770
attacks being able to escalate the

134
00:06:16,620 --> 00:06:22,860
privileges so then they were soon for

135
00:06:19,770 --> 00:06:25,979
God and never to be used again that's

136
00:06:22,860 --> 00:06:28,590
until we came along so we looked at some

137
00:06:25,979 --> 00:06:31,380
modern use cases and saw how we can use

138
00:06:28,590 --> 00:06:33,479
shatter attacks in them so a first use

139
00:06:31,380 --> 00:06:37,500
case is a commercial sandbox that we got

140
00:06:33,479 --> 00:06:38,880
to check now how this sandbox worked it

141
00:06:37,500 --> 00:06:40,699
divided all the processes in the

142
00:06:38,880 --> 00:06:43,289
computer into two separate groups

143
00:06:40,699 --> 00:06:45,360
trusted processes and untrusted

144
00:06:43,289 --> 00:06:47,279
processes trusted processes are

145
00:06:45,360 --> 00:06:48,900
basically or your corporate apps so

146
00:06:47,279 --> 00:06:51,120
every app that has access to your

147
00:06:48,900 --> 00:06:53,128
corporate data and those apps would not

148
00:06:51,120 --> 00:06:55,289
have access to the Internet or external

149
00:06:53,129 --> 00:06:57,240
facing networks then you have the

150
00:06:55,289 --> 00:06:59,759
untrusted processes which are everything

151
00:06:57,240 --> 00:07:02,219
else basically all the apps that come

152
00:06:59,759 --> 00:07:03,779
from unknown sources or all the ones

153
00:07:02,219 --> 00:07:05,849
that communicate with the Internet

154
00:07:03,779 --> 00:07:08,759
and these would not have access to your

155
00:07:05,849 --> 00:07:11,219
corporate data now the isolation would

156
00:07:08,759 --> 00:07:13,409
be implemented over multiple domains so

157
00:07:11,219 --> 00:07:15,419
file system and registry for example all

158
00:07:13,409 --> 00:07:17,969
untrusted processes would receive a

159
00:07:15,419 --> 00:07:19,680
different view of the file system and of

160
00:07:17,969 --> 00:07:21,779
the registry so they wouldn't be able to

161
00:07:19,680 --> 00:07:24,400
see all the files that are naturally

162
00:07:21,779 --> 00:07:26,350
there on the computer so if you have

163
00:07:24,400 --> 00:07:27,969
folder with some files an untrusted

164
00:07:26,350 --> 00:07:30,040
process might see that folder open or

165
00:07:27,970 --> 00:07:34,210
not even existing at all and also write

166
00:07:30,040 --> 00:07:36,639
operations would be isolated also on

167
00:07:34,210 --> 00:07:40,080
network isolation as we said trusted

168
00:07:36,639 --> 00:07:42,940
processes could not access the network

169
00:07:40,080 --> 00:07:45,159
the isolation was also on process

170
00:07:42,940 --> 00:07:47,770
boundaries so opening another process

171
00:07:45,160 --> 00:07:50,500
for writing was no longer possible it

172
00:07:47,770 --> 00:07:52,240
was possible for reading sandbox did not

173
00:07:50,500 --> 00:07:54,280
stop opening another process for reading

174
00:07:52,240 --> 00:07:56,130
and more about that later but we

175
00:07:54,280 --> 00:07:59,440
couldn't open it for writing so the

176
00:07:56,130 --> 00:08:01,120
usual use case of say virtual a low key

177
00:07:59,440 --> 00:08:02,229
X to allocate some executable memory in

178
00:08:01,120 --> 00:08:04,510
the target process and write process

179
00:08:02,229 --> 00:08:08,550
memory to injector shekel our shellcode

180
00:08:04,510 --> 00:08:11,080
into it didn't no longer work also

181
00:08:08,550 --> 00:08:12,669
sending messages windows messages from

182
00:08:11,080 --> 00:08:15,849
an untrusted process to a trusted

183
00:08:12,669 --> 00:08:19,389
process that was also blocked by the

184
00:08:15,849 --> 00:08:21,039
sandbox reading a clipboard from an

185
00:08:19,389 --> 00:08:24,610
untrusted process written by in a

186
00:08:21,039 --> 00:08:27,400
trusted process printing the screen such

187
00:08:24,610 --> 00:08:31,660
as with bit bit BLT all those were

188
00:08:27,400 --> 00:08:33,490
blocked by the sandbox so we looked at

189
00:08:31,660 --> 00:08:34,779
it a little bit more and we said ok what

190
00:08:33,490 --> 00:08:37,900
can we do with it how can we still

191
00:08:34,779 --> 00:08:39,880
exploit it so we looked at the file

192
00:08:37,900 --> 00:08:41,439
system and registry and we saw that

193
00:08:39,880 --> 00:08:43,929
those were pretty well implemented they

194
00:08:41,440 --> 00:08:47,260
used mini filters in the kernel so we

195
00:08:43,929 --> 00:08:49,239
couldn't bypass debt then we went on and

196
00:08:47,260 --> 00:08:51,189
we looked at the process boundaries so

197
00:08:49,240 --> 00:08:53,589
can we open another process and write to

198
00:08:51,190 --> 00:08:55,540
it and that will was also implemented

199
00:08:53,589 --> 00:08:57,910
pretty well they use the mechanism

200
00:08:55,540 --> 00:09:00,579
called object callbacks or the function

201
00:08:57,910 --> 00:09:02,920
Oh be register callbacks and what that

202
00:09:00,580 --> 00:09:04,839
function lets it lets you is it lets you

203
00:09:02,920 --> 00:09:07,510
define a callback that will be called

204
00:09:04,839 --> 00:09:09,010
whenever according to configuration one

205
00:09:07,510 --> 00:09:13,600
of the following happens either you

206
00:09:09,010 --> 00:09:16,000
create open or duplicate the handle to a

207
00:09:13,600 --> 00:09:17,529
process thread or desktop so they could

208
00:09:16,000 --> 00:09:19,870
set a callback that will be called

209
00:09:17,529 --> 00:09:21,700
whenever someone tries to open a handle

210
00:09:19,870 --> 00:09:24,580
to an existing process and if that

211
00:09:21,700 --> 00:09:27,370
request is with writes access then they

212
00:09:24,580 --> 00:09:30,010
would deny it so again we couldn't

213
00:09:27,370 --> 00:09:33,490
bypass that so how can we still escape

214
00:09:30,010 --> 00:09:36,220
that sandbox so then we looked at

215
00:09:33,490 --> 00:09:38,060
sending Windows messages and what we saw

216
00:09:36,220 --> 00:09:40,160
is that this sandbox

217
00:09:38,060 --> 00:09:42,829
implemented this isolation using user

218
00:09:40,160 --> 00:09:44,660
mode hooks now the problem with the user

219
00:09:42,830 --> 00:09:46,820
mode hooks is that they are found in

220
00:09:44,660 --> 00:09:50,390
user mode that is entirely inside the

221
00:09:46,820 --> 00:09:52,220
user mode memory space and thus since

222
00:09:50,390 --> 00:09:54,949
they are in our processes memory space

223
00:09:52,220 --> 00:09:57,020
our process can remove those hooks it

224
00:09:54,950 --> 00:09:58,790
can it's gonna unhook itself and that's

225
00:09:57,020 --> 00:10:01,040
exactly what we did we unhooked

226
00:09:58,790 --> 00:10:03,050
ourselves from these user mode hooks and

227
00:10:01,040 --> 00:10:06,010
lo and behold we could now send a

228
00:10:03,050 --> 00:10:08,709
Windows message to a trusted process

229
00:10:06,010 --> 00:10:13,120
does this scenario ring a bell

230
00:10:08,710 --> 00:10:15,140
can't see how that could be useful so

231
00:10:13,120 --> 00:10:19,070
bringing back shadow attacks from the

232
00:10:15,140 --> 00:10:21,620
dead we researched a little bit and we

233
00:10:19,070 --> 00:10:24,140
found this triple in attack and this

234
00:10:21,620 --> 00:10:25,520
attack what it did it is is it used a

235
00:10:24,140 --> 00:10:27,860
different Windows message from the

236
00:10:25,520 --> 00:10:29,660
original chatter attack it used TVM sort

237
00:10:27,860 --> 00:10:32,660
children CB which is a message sent to

238
00:10:29,660 --> 00:10:34,550
tree views and they would inject their

239
00:10:32,660 --> 00:10:36,410
code using virtual a low key X and right

240
00:10:34,550 --> 00:10:38,329
process memory to get their code into

241
00:10:36,410 --> 00:10:40,339
the target process and then use this

242
00:10:38,330 --> 00:10:42,950
window message to the tree view in order

243
00:10:40,340 --> 00:10:45,920
to pass a pointer to that callback and

244
00:10:42,950 --> 00:10:47,390
execute it so this is nice but we need a

245
00:10:45,920 --> 00:10:49,430
different method to inject our code

246
00:10:47,390 --> 00:10:53,750
because we cannot open another process

247
00:10:49,430 --> 00:10:55,640
for writing so let's assume for a second

248
00:10:53,750 --> 00:10:57,080
and we'll soon see why we need this

249
00:10:55,640 --> 00:10:59,150
assumption and what can we do with it

250
00:10:57,080 --> 00:11:02,930
let's assume we have a trusted process

251
00:10:59,150 --> 00:11:05,540
in the machine and it has an edit box a

252
00:11:02,930 --> 00:11:07,579
status bar a tree view and some readable

253
00:11:05,540 --> 00:11:11,120
writable and executable memory sounds

254
00:11:07,580 --> 00:11:13,580
far fetched I know but wait for it so to

255
00:11:11,120 --> 00:11:16,670
inject our shell code first of all we

256
00:11:13,580 --> 00:11:19,010
look for the Edit box and we call we

257
00:11:16,670 --> 00:11:22,459
send it to our Windows message of WM set

258
00:11:19,010 --> 00:11:24,800
text to send it our of shell code now a

259
00:11:22,460 --> 00:11:26,990
small improvement that we did is that

260
00:11:24,800 --> 00:11:29,959
instead of sending it instead of calling

261
00:11:26,990 --> 00:11:31,700
the normal send message a function we

262
00:11:29,960 --> 00:11:34,100
called the unicode version of it and

263
00:11:31,700 --> 00:11:36,380
then we can pass any shell code that

264
00:11:34,100 --> 00:11:38,810
even has nulls null bytes just not

265
00:11:36,380 --> 00:11:41,300
double nose so that was a small

266
00:11:38,810 --> 00:11:44,119
improvement then the next stage we would

267
00:11:41,300 --> 00:11:46,130
find our shell code inside that target

268
00:11:44,120 --> 00:11:47,870
process now since the sandbox did not

269
00:11:46,130 --> 00:11:50,180
block opening another process for

270
00:11:47,870 --> 00:11:51,830
reading we can open it for reading go

271
00:11:50,180 --> 00:11:55,160
over all this allocated memory

272
00:11:51,830 --> 00:11:57,560
and find our shellcodes now back in the

273
00:11:55,160 --> 00:12:00,530
day in 2002 depth or data execution

274
00:11:57,560 --> 00:12:02,780
prevention did not exist yet but today

275
00:12:00,530 --> 00:12:05,000
it does so once we injected our

276
00:12:02,780 --> 00:12:07,699
shellcode into this edit box buffer

277
00:12:05,000 --> 00:12:10,250
that's no longer enough because that

278
00:12:07,700 --> 00:12:13,780
memory is not executable so we have to

279
00:12:10,250 --> 00:12:16,190
somehow transfer it into some rwx memory

280
00:12:13,780 --> 00:12:18,890
so what we do is first of all we find

281
00:12:16,190 --> 00:12:22,370
this rwx memory that we assume that we

282
00:12:18,890 --> 00:12:24,350
have then we use the status bar that

283
00:12:22,370 --> 00:12:26,510
again we assume that this process has in

284
00:12:24,350 --> 00:12:30,110
order to do the following we send it to

285
00:12:26,510 --> 00:12:34,100
Windows messages the first is a set text

286
00:12:30,110 --> 00:12:35,600
message and the set text message to

287
00:12:34,100 --> 00:12:38,150
differentiate from the edit box it's a

288
00:12:35,600 --> 00:12:40,220
text edit box a set text message assumes

289
00:12:38,150 --> 00:12:43,459
that the pointer gets points to a memory

290
00:12:40,220 --> 00:12:45,320
range in the source product process for

291
00:12:43,460 --> 00:12:47,480
a status bar that is not the case the

292
00:12:45,320 --> 00:12:50,720
pointer points to an address in the

293
00:12:47,480 --> 00:12:53,540
target process so set text to the status

294
00:12:50,720 --> 00:12:55,580
bar means copy something from somewhere

295
00:12:53,540 --> 00:12:59,870
inside the target processes memory range

296
00:12:55,580 --> 00:13:01,850
into the status bars buffer so we send

297
00:12:59,870 --> 00:13:03,260
it the pointer of the shell code of our

298
00:13:01,850 --> 00:13:05,270
shell code that we found earlier and

299
00:13:03,260 --> 00:13:08,030
then we send it another message this

300
00:13:05,270 --> 00:13:10,280
time get text and gave it a pointer to

301
00:13:08,030 --> 00:13:12,250
the rwx memory that we found to some

302
00:13:10,280 --> 00:13:15,829
code cave that we selected in there and

303
00:13:12,250 --> 00:13:18,350
that would copy the shell code from the

304
00:13:15,830 --> 00:13:21,500
status bars buffer and into the rwx

305
00:13:18,350 --> 00:13:23,780
memory once we have that we have our

306
00:13:21,500 --> 00:13:25,940
shell code inside rwx memory and all

307
00:13:23,780 --> 00:13:29,300
that is left is to send a treeview a

308
00:13:25,940 --> 00:13:31,970
message of TVM sort children CB give it

309
00:13:29,300 --> 00:13:36,439
a pointer to our shell codes and our

310
00:13:31,970 --> 00:13:40,580
shell code executes now apparently a new

311
00:13:36,440 --> 00:13:42,560
Windows 7 x64 has all of the above the

312
00:13:40,580 --> 00:13:45,530
Windows Explorer Explorer it out exit it

313
00:13:42,560 --> 00:13:47,089
has right there on the top right it has

314
00:13:45,530 --> 00:13:49,250
an edit box where we can search for

315
00:13:47,090 --> 00:13:50,570
files on the left we have a tree view

316
00:13:49,250 --> 00:13:53,000
where we can see a nice tree of all the

317
00:13:50,570 --> 00:13:54,950
files on our system on the bottom we

318
00:13:53,000 --> 00:13:56,480
have a status bar it's actually not the

319
00:13:54,950 --> 00:13:58,610
one you see there the real one is hidden

320
00:13:56,480 --> 00:14:00,080
and we can't see it but it's there and

321
00:13:58,610 --> 00:14:01,580
that's all that's important we don't

322
00:14:00,080 --> 00:14:03,310
need to see it in order to interact with

323
00:14:01,580 --> 00:14:07,120
it and

324
00:14:03,310 --> 00:14:10,660
this explorer.exe had one single page of

325
00:14:07,120 --> 00:14:13,360
rwx memory right there off the box you

326
00:14:10,660 --> 00:14:16,420
know no change is needed it already has

327
00:14:13,360 --> 00:14:18,339
all these things so we can then move on

328
00:14:16,420 --> 00:14:19,839
with our attack basically given a

329
00:14:18,339 --> 00:14:22,480
shellcode that doesn't have any double

330
00:14:19,839 --> 00:14:26,319
mouths what we did is first of all we

331
00:14:22,480 --> 00:14:28,899
find the addresses the handles to all

332
00:14:26,319 --> 00:14:30,959
those UI elements that we need so the

333
00:14:28,899 --> 00:14:34,269
Edit box the treeview and the status bar

334
00:14:30,959 --> 00:14:36,609
we find the rwx memory region inside the

335
00:14:34,269 --> 00:14:38,559
process and we select our code cave

336
00:14:36,610 --> 00:14:42,160
inside it in this case we chose the end

337
00:14:38,559 --> 00:14:45,790
of that region then number three we

338
00:14:42,160 --> 00:14:47,800
create a buffer that will serve for the

339
00:14:45,790 --> 00:14:49,719
window message for the TVM sort children

340
00:14:47,800 --> 00:14:53,109
CD message because it needs to receive

341
00:14:49,720 --> 00:14:54,850
some struct with the data and number

342
00:14:53,110 --> 00:14:56,980
four we created a buffer that holds our

343
00:14:54,850 --> 00:14:59,399
shell code and that buffer from number

344
00:14:56,980 --> 00:15:02,230
three together so we can inject it

345
00:14:59,399 --> 00:15:05,290
number five we sent the Edit box the WM

346
00:15:02,230 --> 00:15:08,079
set text message with this buffer to

347
00:15:05,290 --> 00:15:10,839
inject it to the target process we scan

348
00:15:08,079 --> 00:15:14,949
the memory I was explored at exam we

349
00:15:10,839 --> 00:15:16,809
find our shell code inside it then in

350
00:15:14,949 --> 00:15:19,300
number eight we send a message to the

351
00:15:16,809 --> 00:15:23,559
status bar of set text and give it the

352
00:15:19,300 --> 00:15:27,459
address of our shell code and get text

353
00:15:23,559 --> 00:15:29,620
from that to copy that shell code into

354
00:15:27,459 --> 00:15:32,888
the rwx memory that we found in step

355
00:15:29,620 --> 00:15:36,129
number two finally we send a treeview

356
00:15:32,889 --> 00:15:38,050
ATVM sort children CB message giving it

357
00:15:36,129 --> 00:15:42,430
the pointer to our circle our shell code

358
00:15:38,050 --> 00:15:45,878
inside that our WX memory and again we

359
00:15:42,430 --> 00:15:48,339
achieve code execution now this worked

360
00:15:45,879 --> 00:15:50,620
fine for proof of concept but when we

361
00:15:48,339 --> 00:15:52,540
came to weaponize it we encountered two

362
00:15:50,620 --> 00:15:54,160
small problems now the first one the

363
00:15:52,540 --> 00:15:55,870
first pitfall is that the compare

364
00:15:54,160 --> 00:15:58,569
functions could be potentially called

365
00:15:55,870 --> 00:15:59,829
many many times why is that because if

366
00:15:58,569 --> 00:16:03,579
you have a treeview and it has a lot of

367
00:15:59,829 --> 00:16:05,529
children then all those children need to

368
00:16:03,579 --> 00:16:08,229
be compared to each other to see what

369
00:16:05,529 --> 00:16:09,850
the sorting of the tree will be so what

370
00:16:08,230 --> 00:16:12,220
we did to solve this is we added this

371
00:16:09,850 --> 00:16:16,389
assembly line this move by PTR our EP -

372
00:16:12,220 --> 00:16:17,050
7 0 XC 3 we prepared our shellcode with

373
00:16:16,389 --> 00:16:19,300
that and

374
00:16:17,050 --> 00:16:20,829
that line does is basically it's over

375
00:16:19,300 --> 00:16:23,680
writes the first bite of the shellcode

376
00:16:20,830 --> 00:16:26,470
or rather the first bite of this line to

377
00:16:23,680 --> 00:16:28,510
be a ret opcode and what this does is

378
00:16:26,470 --> 00:16:31,660
that every subsequent call to this

379
00:16:28,510 --> 00:16:34,689
shellcode will just execute ret and

380
00:16:31,660 --> 00:16:37,060
return back to the caller so then our

381
00:16:34,690 --> 00:16:39,180
shellcode would run only once now the

382
00:16:37,060 --> 00:16:41,800
second thing we saw is that sometimes

383
00:16:39,180 --> 00:16:44,229
the Explorer the File Explorer window is

384
00:16:41,800 --> 00:16:46,300
not open now if the window is not open

385
00:16:44,230 --> 00:16:49,660
then we have no status bar no edit box

386
00:16:46,300 --> 00:16:51,719
and no treeview to interact with so we

387
00:16:49,660 --> 00:16:54,399
have to open one of our cell of our own

388
00:16:51,720 --> 00:16:57,010
what we did is we called shall execute

389
00:16:54,399 --> 00:16:58,990
giving it a parameter of open and a

390
00:16:57,010 --> 00:17:01,360
valid path such as C cones

391
00:16:58,990 --> 00:17:03,760
yeah backslash and gave it a parameter a

392
00:17:01,360 --> 00:17:05,679
flag of SW hide this flag tells the

393
00:17:03,760 --> 00:17:08,099
system to open the window in a hidden

394
00:17:05,679 --> 00:17:10,720
mode so the user would not see anything

395
00:17:08,099 --> 00:17:12,909
we then inject our shellcode as before

396
00:17:10,720 --> 00:17:14,740
and we can even close the window because

397
00:17:12,910 --> 00:17:18,250
now our code is running from the memory

398
00:17:14,740 --> 00:17:20,109
space of that process so that was the

399
00:17:18,250 --> 00:17:23,079
the first use case that we saw for this

400
00:17:20,109 --> 00:17:25,089
chatter attack this sandbox and the

401
00:17:23,079 --> 00:17:29,970
second use case is that we wanted to

402
00:17:25,089 --> 00:17:32,280
inject code and whilst evading EDRs so

403
00:17:29,970 --> 00:17:35,440
modern EDRs or endpoint security

404
00:17:32,280 --> 00:17:37,120
mechanisms they are very sensitive and

405
00:17:35,440 --> 00:17:38,559
they really don't like it that you try

406
00:17:37,120 --> 00:17:43,979
to inject code from one process to

407
00:17:38,559 --> 00:17:46,540
another and if for example you try the

408
00:17:43,980 --> 00:17:48,400
classic method of code injection using

409
00:17:46,540 --> 00:17:50,649
open process you open the remote process

410
00:17:48,400 --> 00:17:52,360
for writing then virtual alkie x to

411
00:17:50,650 --> 00:17:55,210
allocate some writable memory inside it

412
00:17:52,360 --> 00:17:56,620
a writable executable sorry write

413
00:17:55,210 --> 00:17:59,020
process memory to write your shell code

414
00:17:56,620 --> 00:18:01,178
into that process and create remote

415
00:17:59,020 --> 00:18:03,910
threads to run that shell code that you

416
00:18:01,179 --> 00:18:07,440
injected any self-respecting edr today

417
00:18:03,910 --> 00:18:11,710
would block you from doing that thing

418
00:18:07,440 --> 00:18:13,809
so shatter attack to the rescue however

419
00:18:11,710 --> 00:18:16,360
this test was not done in Windows 7 was

420
00:18:13,809 --> 00:18:18,129
done on Windows 10 and apparently in

421
00:18:16,360 --> 00:18:20,439
Windows 10 it is no longer true that

422
00:18:18,130 --> 00:18:24,640
explorer.exe has some rwx memory inside

423
00:18:20,440 --> 00:18:27,460
it so we said ok we need our WX memory

424
00:18:24,640 --> 00:18:29,710
in order to execute our code from so

425
00:18:27,460 --> 00:18:32,830
what can we do with that

426
00:18:29,710 --> 00:18:35,470
so what we can do is we can send T VMs

427
00:18:32,830 --> 00:18:37,810
or children's TV messages and what those

428
00:18:35,470 --> 00:18:39,520
do is they receive a pointer and they

429
00:18:37,810 --> 00:18:42,370
call this compare function according to

430
00:18:39,520 --> 00:18:44,620
the pointer that we give them so let's

431
00:18:42,370 --> 00:18:47,139
look at the signature of this callback

432
00:18:44,620 --> 00:18:48,939
function so this callback function right

433
00:18:47,140 --> 00:18:52,570
on the bottom it receives three

434
00:18:48,940 --> 00:18:56,050
parameters l / m 1 l / m 2 and l / m

435
00:18:52,570 --> 00:18:58,450
sort the third parameter it receives

436
00:18:56,050 --> 00:19:00,610
from this truck that we provide to the

437
00:18:58,450 --> 00:19:02,830
TV m short message so children CB

438
00:19:00,610 --> 00:19:06,060
message so if you see on the top we have

439
00:19:02,830 --> 00:19:10,330
this truck this TV sort CB struct and

440
00:19:06,060 --> 00:19:12,730
its second field is the pointer to the

441
00:19:10,330 --> 00:19:14,830
compare function the third field is the

442
00:19:12,730 --> 00:19:17,470
L / M that will be passed as a third

443
00:19:14,830 --> 00:19:20,679
parameter to all calls of this compare

444
00:19:17,470 --> 00:19:23,350
function now the first two parameters L

445
00:19:20,680 --> 00:19:25,600
program 1 and L / M 2 are received from

446
00:19:23,350 --> 00:19:27,159
the treeview items so if you want to

447
00:19:25,600 --> 00:19:29,110
compare two items we need to get some

448
00:19:27,160 --> 00:19:33,030
data from each one of them in order for

449
00:19:29,110 --> 00:19:35,620
some comparing logic to occur so

450
00:19:33,030 --> 00:19:38,080
basically each element in the tree each

451
00:19:35,620 --> 00:19:39,850
child there has an L / am Val you and

452
00:19:38,080 --> 00:19:43,360
those L params are passed to this

453
00:19:39,850 --> 00:19:45,429
function so what we can do is we can

454
00:19:43,360 --> 00:19:48,159
remotely enumerate the children of this

455
00:19:45,430 --> 00:19:50,080
tree view and we can call set item for

456
00:19:48,160 --> 00:19:54,250
each of them thus setting the value of

457
00:19:50,080 --> 00:19:55,960
the L / M so that way we can control all

458
00:19:54,250 --> 00:19:58,840
the values that are passed to this

459
00:19:55,960 --> 00:20:00,280
function only small problem is we don't

460
00:19:58,840 --> 00:20:02,620
know the order in which windows will

461
00:20:00,280 --> 00:20:06,760
decide to call to compare the elements

462
00:20:02,620 --> 00:20:08,979
so maybe if we have two elements maybe

463
00:20:06,760 --> 00:20:10,629
this will be the one called for L / M 1

464
00:20:08,980 --> 00:20:13,210
and this for l / M 2 and maybe this one

465
00:20:10,630 --> 00:20:17,710
will be for L / M 1 and this 1 for 4 l /

466
00:20:13,210 --> 00:20:19,540
M - but we'll so see why we don't care

467
00:20:17,710 --> 00:20:22,270
really about the order between the first

468
00:20:19,540 --> 00:20:24,310
two elements so but bottom line is we

469
00:20:22,270 --> 00:20:30,220
can call any three argument function

470
00:20:24,310 --> 00:20:32,830
that we want so we need some rwx memory

471
00:20:30,220 --> 00:20:34,480
so in order to generate some to allocate

472
00:20:32,830 --> 00:20:37,030
some readable writable and executable

473
00:20:34,480 --> 00:20:39,550
memory we looked at virtual Alec which

474
00:20:37,030 --> 00:20:42,280
is the obvious choice for this only

475
00:20:39,550 --> 00:20:43,360
problem is that virtual Alec gets four

476
00:20:42,280 --> 00:20:47,139
parameters

477
00:20:43,360 --> 00:20:49,149
and the fourth parameter is the one of

478
00:20:47,140 --> 00:20:51,070
the protection flags the one in which we

479
00:20:49,150 --> 00:20:54,040
need to specify that we want this to be

480
00:20:51,070 --> 00:20:55,960
an rwx memory so we must control this

481
00:20:54,040 --> 00:20:58,570
parameter and since we can't then this

482
00:20:55,960 --> 00:21:00,340
function is not good for us also the

483
00:20:58,570 --> 00:21:02,649
other versions of these of this function

484
00:21:00,340 --> 00:21:05,620
very whether it be virtual Alec e^x

485
00:21:02,650 --> 00:21:07,570
virtual key X Numa virtual Alec from app

486
00:21:05,620 --> 00:21:09,610
virtual Alec to virtual Alec to from app

487
00:21:07,570 --> 00:21:12,189
and even the lower level ntdll

488
00:21:09,610 --> 00:21:14,379
NT allocate virtual memory all of those

489
00:21:12,190 --> 00:21:15,820
receive at least four parameters and we

490
00:21:14,380 --> 00:21:20,290
need to control at least one parameter

491
00:21:15,820 --> 00:21:21,970
which is fourth or higher so then we

492
00:21:20,290 --> 00:21:24,280
said okay if we can't allocate some new

493
00:21:21,970 --> 00:21:25,990
rwx memory maybe we can change some

494
00:21:24,280 --> 00:21:28,780
existing memory to be readable writable

495
00:21:25,990 --> 00:21:31,600
and executable so that's what virtual

496
00:21:28,780 --> 00:21:34,030
protect is for however virtual protect

497
00:21:31,600 --> 00:21:35,409
also receives four parameters now it

498
00:21:34,030 --> 00:21:37,149
seems on first sight that the

499
00:21:35,410 --> 00:21:39,430
interesting parameters of are the first

500
00:21:37,150 --> 00:21:41,170
three because you got the address of the

501
00:21:39,430 --> 00:21:43,690
memory that you want to change the size

502
00:21:41,170 --> 00:21:46,210
of it and the new protection flags and

503
00:21:43,690 --> 00:21:48,580
the fourth parameter is simply a pointer

504
00:21:46,210 --> 00:21:50,410
to a D word that will receive the old

505
00:21:48,580 --> 00:21:53,560
protection flags that were true for this

506
00:21:50,410 --> 00:21:56,320
memory range now we thought okay maybe

507
00:21:53,560 --> 00:22:00,310
we can just like wing it somehow somehow

508
00:21:56,320 --> 00:22:01,780
pass null to it and thus are telling the

509
00:22:00,310 --> 00:22:04,389
function that we don't care about the

510
00:22:01,780 --> 00:22:06,610
old protection flags but Microsoft were

511
00:22:04,390 --> 00:22:08,800
pretty clear in their documentation and

512
00:22:06,610 --> 00:22:10,929
they said that if this parameter is null

513
00:22:08,800 --> 00:22:14,290
or does not point to a very valid

514
00:22:10,930 --> 00:22:15,610
variable the function fails so we must

515
00:22:14,290 --> 00:22:17,530
control this fourth parameter as well

516
00:22:15,610 --> 00:22:20,350
and we can't use virtual protect either

517
00:22:17,530 --> 00:22:22,510
also the other versions of virtual

518
00:22:20,350 --> 00:22:24,129
protect are also not good for us virtual

519
00:22:22,510 --> 00:22:26,770
protect DX and virtual protect from app

520
00:22:24,130 --> 00:22:28,720
and ntdll anti protect virtual memory

521
00:22:26,770 --> 00:22:30,430
all of those receive at least four

522
00:22:28,720 --> 00:22:32,470
parameters and in all of them we need to

523
00:22:30,430 --> 00:22:35,410
control at least one parameter fourth or

524
00:22:32,470 --> 00:22:37,000
higher so we thought about this some

525
00:22:35,410 --> 00:22:39,400
more we could scratch our heads we

526
00:22:37,000 --> 00:22:42,820
googled a bit we looked around and

527
00:22:39,400 --> 00:22:45,220
finally we found this function heap

528
00:22:42,820 --> 00:22:48,250
create now what heap create does is

529
00:22:45,220 --> 00:22:49,480
creates a new heap other than the you

530
00:22:48,250 --> 00:22:52,240
know you have the default heap for each

531
00:22:49,480 --> 00:22:54,970
process he creates a new one and he

532
00:22:52,240 --> 00:22:56,710
creates is perfect for us and why is it

533
00:22:54,970 --> 00:22:57,220
perfect well first of all it receives

534
00:22:56,710 --> 00:22:58,810
only

535
00:22:57,220 --> 00:23:01,090
parameters and that's great because we

536
00:22:58,810 --> 00:23:03,700
can call a free parameter function now

537
00:23:01,090 --> 00:23:06,340
the first parameter is the options flag

538
00:23:03,700 --> 00:23:08,260
and apparently he creates supports a

539
00:23:06,340 --> 00:23:10,689
flag that is heap create enable execute

540
00:23:08,260 --> 00:23:13,390
which makes all the memory inside the

541
00:23:10,690 --> 00:23:16,330
created heap executable in addition to

542
00:23:13,390 --> 00:23:18,160
already being readable and writeable the

543
00:23:16,330 --> 00:23:19,810
second parameter is the initial size of

544
00:23:18,160 --> 00:23:22,390
the heap and the third parameter is a

545
00:23:19,810 --> 00:23:25,050
maximum size and luckily for us heap

546
00:23:22,390 --> 00:23:27,190
create creates all this memory already

547
00:23:25,050 --> 00:23:31,060
committed and ready to use that thoughts

548
00:23:27,190 --> 00:23:34,570
it's not just reserved or something so

549
00:23:31,060 --> 00:23:36,730
basically what we did is first of all we

550
00:23:34,570 --> 00:23:40,179
enumerated the children of the tree view

551
00:23:36,730 --> 00:23:42,220
and we set item for each of them setting

552
00:23:40,180 --> 00:23:44,440
their L program values to this heap

553
00:23:42,220 --> 00:23:48,460
create and they will execute flag which

554
00:23:44,440 --> 00:23:50,320
is 0 X 40000 because we don't know if it

555
00:23:48,460 --> 00:23:54,520
will be passed as a first or as a second

556
00:23:50,320 --> 00:23:56,110
parameter to our function now since we

557
00:23:54,520 --> 00:23:58,800
don't know the order and and we set all

558
00:23:56,110 --> 00:24:01,330
of them to this value this means that

559
00:23:58,800 --> 00:24:03,040
also the second parameter of heap

560
00:24:01,330 --> 00:24:08,919
creates will be called with this value

561
00:24:03,040 --> 00:24:12,820
now 0 X 40000 is 256 kilobytes so that's

562
00:24:08,920 --> 00:24:16,390
also fine because it's probably not as

563
00:24:12,820 --> 00:24:18,010
large to make an allocation fail but

564
00:24:16,390 --> 00:24:20,620
it's large enough to contain any

565
00:24:18,010 --> 00:24:25,000
shellcode know to mankind and obviously

566
00:24:20,620 --> 00:24:26,439
also good enough for us and third

567
00:24:25,000 --> 00:24:28,570
parameter as we said we can fully

568
00:24:26,440 --> 00:24:30,520
control it so we can just pass 0 for

569
00:24:28,570 --> 00:24:32,020
example which tells heap creates to

570
00:24:30,520 --> 00:24:36,460
create a heap that can grow as much as

571
00:24:32,020 --> 00:24:38,950
we need so then once we have these we

572
00:24:36,460 --> 00:24:41,260
can basically create our own rwx memory

573
00:24:38,950 --> 00:24:42,820
and shatter attack can work as it did in

574
00:24:41,260 --> 00:24:46,270
Windows 7 right

575
00:24:42,820 --> 00:24:50,050
well almost we had one more challenge to

576
00:24:46,270 --> 00:24:52,120
fix apparently the statusbar filters

577
00:24:50,050 --> 00:24:54,669
some bad characters from unprintable

578
00:24:52,120 --> 00:24:57,040
characters so any character any white

579
00:24:54,670 --> 00:24:59,440
character of the form something null

580
00:24:57,040 --> 00:25:02,620
byte where something is between 1 and 0

581
00:24:59,440 --> 00:25:05,800
X 1 F except for nine which is tab all

582
00:25:02,620 --> 00:25:09,060
of those would be converted to 0 x 20

583
00:25:05,800 --> 00:25:11,379
and in all bytes which is a space

584
00:25:09,060 --> 00:25:12,909
now this is okay if we only need to

585
00:25:11,380 --> 00:25:14,740
transfer a shell code because shell

586
00:25:12,910 --> 00:25:16,990
codes can be encoded to only have

587
00:25:14,740 --> 00:25:19,060
printable characters or alphanumeric

588
00:25:16,990 --> 00:25:24,280
characters or not have no bytes or not

589
00:25:19,060 --> 00:25:27,669
have bad characters but we also need to

590
00:25:24,280 --> 00:25:29,139
transfer our set item structs or TV

591
00:25:27,670 --> 00:25:33,630
items trucks which are needed for the

592
00:25:29,140 --> 00:25:35,770
set item calls and those trucks have

593
00:25:33,630 --> 00:25:37,450
sequences of null bytes and they have

594
00:25:35,770 --> 00:25:39,430
all these bad characters in them and

595
00:25:37,450 --> 00:25:43,630
they can't be encoded they need to be

596
00:25:39,430 --> 00:25:44,700
transferred as is so how can we solve

597
00:25:43,630 --> 00:25:47,890
that

598
00:25:44,700 --> 00:25:52,900
what we did is some special handling for

599
00:25:47,890 --> 00:25:55,450
those white characters so let's say that

600
00:25:52,900 --> 00:25:59,800
we had a source buffer that is the one

601
00:25:55,450 --> 00:26:02,620
here AABB 0 5 0 0 and CC and we want to

602
00:25:59,800 --> 00:26:06,250
transfer that structure that buffer to

603
00:26:02,620 --> 00:26:08,139
the target process so we looked at the

604
00:26:06,250 --> 00:26:11,560
first we look at the first white

605
00:26:08,140 --> 00:26:14,110
character and we see it's a ABB which is

606
00:26:11,560 --> 00:26:16,179
not a filtered character so we can just

607
00:26:14,110 --> 00:26:18,850
transfer it in the normal way we can

608
00:26:16,180 --> 00:26:22,810
call we can send the Edit box set text

609
00:26:18,850 --> 00:26:25,060
message then set text for the status bar

610
00:26:22,810 --> 00:26:30,280
from the Edit box and get text from the

611
00:26:25,060 --> 00:26:32,020
status bar into a target address now we

612
00:26:30,280 --> 00:26:33,730
looked at the second we look at the

613
00:26:32,020 --> 00:26:36,400
second white character and we see it's

614
00:26:33,730 --> 00:26:38,200
zero five zero zero now this is a

615
00:26:36,400 --> 00:26:41,650
filtered character so we can't just copy

616
00:26:38,200 --> 00:26:44,410
it as is so what we do is we go 1 byte

617
00:26:41,650 --> 00:26:47,980
backwards and once we do that we see

618
00:26:44,410 --> 00:26:50,890
that we have BB 0 5 that's a character a

619
00:26:47,980 --> 00:26:53,080
white character that we can copy so then

620
00:26:50,890 --> 00:26:57,070
we copy that over but not to offset too

621
00:26:53,080 --> 00:26:58,840
but to offset one of our buffer so then

622
00:26:57,070 --> 00:27:01,210
the BB overrides the previous maybe

623
00:26:58,840 --> 00:27:04,209
that's fine we don't care and 0 5 is

624
00:27:01,210 --> 00:27:07,390
also appended to that buffer we go on

625
00:27:04,210 --> 00:27:09,970
and then we see that we have 0 0 and CC

626
00:27:07,390 --> 00:27:13,330
that's not a filter character so we can

627
00:27:09,970 --> 00:27:16,480
just copy it as before through the Edit

628
00:27:13,330 --> 00:27:19,540
box and the status bar that way copying

629
00:27:16,480 --> 00:27:22,330
one white character at a time and going

630
00:27:19,540 --> 00:27:24,720
back one byte if needed we can copy

631
00:27:22,330 --> 00:27:27,519
any buffer that we want even one with

632
00:27:24,720 --> 00:27:30,220
multiple null bites in a row and with

633
00:27:27,519 --> 00:27:34,720
bad characters so once we did that we

634
00:27:30,220 --> 00:27:37,090
managed to copy or TV items structs for

635
00:27:34,720 --> 00:27:39,340
set items we can set all the items l

636
00:27:37,090 --> 00:27:40,750
params and call heath create to get some

637
00:27:39,340 --> 00:27:42,879
readable writable and executable memory

638
00:27:40,750 --> 00:27:48,820
and then we could continue as before and

639
00:27:42,880 --> 00:27:51,309
achieve code execution once again so we

640
00:27:48,820 --> 00:27:53,950
want to check this on those EDRs so we

641
00:27:51,309 --> 00:27:56,860
took one leading EDR in the market and

642
00:27:53,950 --> 00:28:01,539
we said okay let's see how our code

643
00:27:56,860 --> 00:28:03,490
behaves with it so first of all we tried

644
00:28:01,539 --> 00:28:05,799
some good old create remote thread to

645
00:28:03,490 --> 00:28:07,480
load library injection to see that the

646
00:28:05,799 --> 00:28:08,429
EDR indeed works and does what it's

647
00:28:07,480 --> 00:28:12,130
supposed to do

648
00:28:08,429 --> 00:28:14,740
so as expected we did that and all the

649
00:28:12,130 --> 00:28:17,470
alarm bells went off and the EDR said ok

650
00:28:14,740 --> 00:28:20,760
I saw that this process is trying to

651
00:28:17,470 --> 00:28:23,889
inject some memory into explore a DEXA

652
00:28:20,760 --> 00:28:25,360
and run it with creative mode thread and

653
00:28:23,889 --> 00:28:29,049
that's bad and I'm stopping you from

654
00:28:25,360 --> 00:28:31,928
doing that so that was blocked then we

655
00:28:29,049 --> 00:28:34,350
said ok now let's try our code and when

656
00:28:31,929 --> 00:28:37,600
we tried our code there were no alerts

657
00:28:34,350 --> 00:28:38,949
so what the EDR did find is it found

658
00:28:37,600 --> 00:28:41,500
that we did open process on ourselves

659
00:28:38,950 --> 00:28:44,019
and NT protect virtual memory and front

660
00:28:41,500 --> 00:28:46,570
find first file uxw which are all part

661
00:28:44,019 --> 00:28:49,960
of the PI to X's loader setting up the

662
00:28:46,570 --> 00:28:52,240
embedded Python interpreter then he saw

663
00:28:49,960 --> 00:28:54,490
that we did create window exw which is

664
00:28:52,240 --> 00:28:55,840
probably caused by the shell execute

665
00:28:54,490 --> 00:28:58,389
that we ran in order to create our

666
00:28:55,840 --> 00:29:00,370
window and the query system information

667
00:28:58,389 --> 00:29:03,519
to find the PID the process ID of

668
00:29:00,370 --> 00:29:05,918
Explorer dot X ax and finally open

669
00:29:03,519 --> 00:29:08,889
process for Explorer dot X ax but a read

670
00:29:05,919 --> 00:29:10,870
only open and he does not VD or did not

671
00:29:08,889 --> 00:29:12,789
consider that as malicious and let us do

672
00:29:10,870 --> 00:29:15,370
it and that was the last thing he saw us

673
00:29:12,789 --> 00:29:18,879
do everything else went completely under

674
00:29:15,370 --> 00:29:27,580
the radar so once again code execution

675
00:29:18,880 --> 00:29:29,830
win so to recap what we did is we took

676
00:29:27,580 --> 00:29:34,029
an eighteen-year-old security-related

677
00:29:29,830 --> 00:29:36,010
design issue in the win32 GUI we brought

678
00:29:34,029 --> 00:29:36,730
it back from the dead to see how it

679
00:29:36,010 --> 00:29:39,370
could be you

680
00:29:36,730 --> 00:29:43,390
in modern operating systems and in

681
00:29:39,370 --> 00:29:46,000
modern use cases and what we saw is that

682
00:29:43,390 --> 00:29:48,220
basically the root cause for this to be

683
00:29:46,000 --> 00:29:50,350
able to happen is that there is all this

684
00:29:48,220 --> 00:29:53,350
complex and dangerous behavior with

685
00:29:50,350 --> 00:29:56,020
pointers inside Windows messages so

686
00:29:53,350 --> 00:29:58,330
sometimes a pointer is considered to be

687
00:29:56,020 --> 00:30:00,550
pointing to data in the source process

688
00:29:58,330 --> 00:30:03,310
like in the case of the Edit box as it's

689
00:30:00,550 --> 00:30:05,230
a text and they did that data should be

690
00:30:03,310 --> 00:30:07,870
copied from the source process to the

691
00:30:05,230 --> 00:30:10,060
target process sometimes these pointers

692
00:30:07,870 --> 00:30:12,580
were pointers to data inside the local

693
00:30:10,060 --> 00:30:15,669
process like the status bars set text

694
00:30:12,580 --> 00:30:17,139
and get text those meant that data

695
00:30:15,670 --> 00:30:19,750
should be copied inside the target

696
00:30:17,140 --> 00:30:21,820
processes memory range and sometimes

697
00:30:19,750 --> 00:30:24,310
these pointers point to a callback to

698
00:30:21,820 --> 00:30:27,730
some code that should be executed by the

699
00:30:24,310 --> 00:30:30,909
target process combining these together

700
00:30:27,730 --> 00:30:33,310
we could and we had enabled the allocate

701
00:30:30,910 --> 00:30:36,340
rwx memory write to arbitrary address

702
00:30:33,310 --> 00:30:38,440
and execute arbitrary address primitives

703
00:30:36,340 --> 00:30:42,790
and with those we could inject and

704
00:30:38,440 --> 00:30:45,910
execute any code so some possible

705
00:30:42,790 --> 00:30:49,560
mitigation ideas well one thing we could

706
00:30:45,910 --> 00:30:52,420
do is we can hook send message and

707
00:30:49,560 --> 00:30:56,620
prevent or block all kinds of dangerous

708
00:30:52,420 --> 00:30:59,770
win32 messages so for example things

709
00:30:56,620 --> 00:31:02,189
like set text and get text for a status

710
00:30:59,770 --> 00:31:04,960
bar coming from a different process or

711
00:31:02,190 --> 00:31:07,360
the TVM store children CB coming from a

712
00:31:04,960 --> 00:31:10,360
different process or any of the list of

713
00:31:07,360 --> 00:31:11,590
messages that contain a callback they

714
00:31:10,360 --> 00:31:14,199
should not be coming from a different

715
00:31:11,590 --> 00:31:16,600
process so if we hook this and prevent

716
00:31:14,200 --> 00:31:20,080
those from happening then that could be

717
00:31:16,600 --> 00:31:22,120
better however as we said user mode

718
00:31:20,080 --> 00:31:25,149
hooks are not good enough because they

719
00:31:22,120 --> 00:31:27,580
can just be unhooked so a different

720
00:31:25,150 --> 00:31:31,210
thing we can do is use a mechanism from

721
00:31:27,580 --> 00:31:33,210
Windows called windows hooks which is

722
00:31:31,210 --> 00:31:37,150
called by calling the set window hooky X

723
00:31:33,210 --> 00:31:40,300
callback sorry a function and we can

724
00:31:37,150 --> 00:31:41,560
call it with either the call win proc or

725
00:31:40,300 --> 00:31:44,530
the get message

726
00:31:41,560 --> 00:31:47,230
arguments what those would do is they

727
00:31:44,530 --> 00:31:50,690
would inject DLL into all the processes

728
00:31:47,230 --> 00:31:53,360
inside this desktop and specify

729
00:31:50,690 --> 00:31:55,340
that would be called whenever either the

730
00:31:53,360 --> 00:31:58,040
windows procedure is going to be called

731
00:31:55,340 --> 00:32:02,030
or a messages are received in a process

732
00:31:58,040 --> 00:32:04,639
and that callback could verify the

733
00:32:02,030 --> 00:32:06,980
safety or the security of this message

734
00:32:04,640 --> 00:32:10,100
coming along and could lock any

735
00:32:06,980 --> 00:32:12,890
dangerous messages so luckily for us

736
00:32:10,100 --> 00:32:18,669
Windows has this mechanism it just needs

737
00:32:12,890 --> 00:32:22,010
to be used so a few closing thoughts

738
00:32:18,670 --> 00:32:25,250
first of all we should not rely on user

739
00:32:22,010 --> 00:32:27,860
mode hooks because they are not good

740
00:32:25,250 --> 00:32:29,900
enough since Windows introduced patch

741
00:32:27,860 --> 00:32:32,929
guard we can no longer hook in the

742
00:32:29,900 --> 00:32:35,420
kernel we can't put kernel hooks so all

743
00:32:32,930 --> 00:32:37,070
that is left is just user mode hooks but

744
00:32:35,420 --> 00:32:39,230
that's not good enough that's a gap that

745
00:32:37,070 --> 00:32:42,700
exists here because any user mode hook

746
00:32:39,230 --> 00:32:45,590
can be unhooked or detoured in some way

747
00:32:42,700 --> 00:32:49,250
so Microsoft really needs to come in

748
00:32:45,590 --> 00:32:52,790
here and put in some new mechanism to

749
00:32:49,250 --> 00:32:55,940
allow security products to secure us by

750
00:32:52,790 --> 00:32:59,540
hooking the correct functions but not in

751
00:32:55,940 --> 00:33:01,460
user mode in addition I believe Windows

752
00:32:59,540 --> 00:33:03,620
can really benefit from something like

753
00:33:01,460 --> 00:33:05,720
Linux as LSM or the Linux security

754
00:33:03,620 --> 00:33:08,270
modules which is something that allows

755
00:33:05,720 --> 00:33:11,720
to implement things like app armor or

756
00:33:08,270 --> 00:33:15,170
SELinux above it those will allow to

757
00:33:11,720 --> 00:33:19,250
define some per process per API policies

758
00:33:15,170 --> 00:33:20,750
and they can mitigate or stop certain

759
00:33:19,250 --> 00:33:24,520
kinds of attacks certain kinds of

760
00:33:20,750 --> 00:33:24,520
dangerous operations from happening so

761
00:33:25,180 --> 00:33:31,420
before we part to finish up let's watch

762
00:33:28,940 --> 00:33:31,420
a little demo

763
00:33:34,960 --> 00:33:37,960
second

764
00:33:41,680 --> 00:33:48,880
okay

765
00:33:43,660 --> 00:33:52,370
so there we have Windows 10 machine and

766
00:33:48,880 --> 00:33:54,470
I'm gonna run our code which what's it

767
00:33:52,370 --> 00:33:56,540
gonna do is basically it's gonna do all

768
00:33:54,470 --> 00:33:58,850
the steps that we saw before so it's

769
00:33:56,540 --> 00:34:01,970
gonna call shell execute in order to

770
00:33:58,850 --> 00:34:03,830
open a new hidden Windows Explorer

771
00:34:01,970 --> 00:34:05,929
window now because it's hidden we won't

772
00:34:03,830 --> 00:34:07,580
see anything on the screen and will then

773
00:34:05,929 --> 00:34:09,560
find all the controls all the UI

774
00:34:07,580 --> 00:34:11,989
elements that it needs its sighted so

775
00:34:09,560 --> 00:34:15,049
the Edit box the status bar and the

776
00:34:11,989 --> 00:34:17,239
treeview it will then enumerate all the

777
00:34:15,050 --> 00:34:18,889
treeview children and for each of them

778
00:34:17,239 --> 00:34:21,259
it will copy a buffer over to the other

779
00:34:18,889 --> 00:34:24,379
side and call set item with that buffer

780
00:34:21,260 --> 00:34:28,700
the setting the L program value to 0 X

781
00:34:24,379 --> 00:34:30,859
40000 once that is done it will send the

782
00:34:28,699 --> 00:34:34,759
treeview a a message of TVM sort

783
00:34:30,859 --> 00:34:37,399
children CB that will with a pointer to

784
00:34:34,760 --> 00:34:38,869
the heap create function that will call

785
00:34:37,399 --> 00:34:41,270
heap create with the correct parameters

786
00:34:38,869 --> 00:34:44,770
and allocate us some readable writable

787
00:34:41,270 --> 00:34:48,710
and executable memory inside the process

788
00:34:44,770 --> 00:34:51,530
then it will inject our shellcode with

789
00:34:48,710 --> 00:34:52,668
all the like how we saw it with the edit

790
00:34:51,530 --> 00:34:54,440
box and the status bar

791
00:34:52,668 --> 00:34:57,890
full injector show code into the target

792
00:34:54,440 --> 00:34:59,540
process and finally it will call TV it

793
00:34:57,890 --> 00:35:02,390
will send another message of TVM sword

794
00:34:59,540 --> 00:35:04,609
shield Rijn CB with the pointer to our

795
00:35:02,390 --> 00:35:06,710
shell code that will run our show code

796
00:35:04,609 --> 00:35:08,960
where our shell code does is simply just

797
00:35:06,710 --> 00:35:11,720
pop up a message box which we will see

798
00:35:08,960 --> 00:35:16,359
that it opens up from explorer sorry

799
00:35:11,720 --> 00:35:20,080
will run this code one second

800
00:35:16,359 --> 00:35:20,080
yep there we go

801
00:35:20,390 --> 00:35:28,230
and a message pop message box pops-up if

802
00:35:23,760 --> 00:35:35,220
we look at the source process sorry one

803
00:35:28,230 --> 00:35:38,940
second wait I lost it

804
00:35:35,220 --> 00:35:40,558
oh there it is if we look at this

805
00:35:38,940 --> 00:35:44,069
process we can see that it comes from

806
00:35:40,559 --> 00:35:48,750
Explorer Alexa and we can also bring to

807
00:35:44,069 --> 00:35:55,710
front and see that it is and one second

808
00:35:48,750 --> 00:35:57,079
wait that's not good and we can see the

809
00:35:55,710 --> 00:36:00,539
icon here on the bottom which is

810
00:35:57,079 --> 00:36:04,400
explorers icon so there we have it code

811
00:36:00,539 --> 00:36:04,400
execution from Explorer

812
00:36:11,589 --> 00:36:18,910
so I thank you all for coming to my talk

813
00:36:14,920 --> 00:36:21,599
and we have some more time for questions

814
00:36:18,910 --> 00:36:21,598
if anyone got it

815
00:36:25,330 --> 00:36:33,069
[Applause]

816
00:36:40,789 --> 00:36:54,059
sorry how much time so the the sandbox

817
00:36:49,109 --> 00:36:59,700
was about one month of research and Edie

818
00:36:54,059 --> 00:37:02,150
ours was maybe another few weeks any

819
00:36:59,700 --> 00:37:02,149
more questions

820
00:37:03,380 --> 00:37:06,980
okay thank you very much

821
00:37:07,450 --> 00:37:11,009
[Applause]

