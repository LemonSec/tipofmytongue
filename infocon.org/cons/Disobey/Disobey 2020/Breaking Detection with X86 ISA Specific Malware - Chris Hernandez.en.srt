1
00:00:04,220 --> 00:00:23,619
[Music]

2
00:00:30,880 --> 00:00:36,200
[Music]

3
00:00:34,780 --> 00:00:39,649
hey guys

4
00:00:36,200 --> 00:00:40,970
thanks for coming out to my talk I'm

5
00:00:39,649 --> 00:00:44,750
gonna be talking about breaking

6
00:00:40,970 --> 00:00:47,140
detection with exit 86 is a specific

7
00:00:44,750 --> 00:00:47,140
malware

8
00:00:47,629 --> 00:00:54,019
my name is Chris Hernandez it's my

9
00:00:50,360 --> 00:00:58,670
twitter handle i'm the red team program

10
00:00:54,019 --> 00:01:02,920
manager at code 42 former sysadmin pen

11
00:00:58,670 --> 00:01:06,080
tester and built a few red team programs

12
00:01:02,920 --> 00:01:07,820
company in the u.s. called target and

13
00:01:06,080 --> 00:01:10,270
before that i was a consultant at

14
00:01:07,820 --> 00:01:13,758
various group adaptive threat division

15
00:01:10,270 --> 00:01:15,770
done some that group has done some

16
00:01:13,759 --> 00:01:22,400
offensive PowerShell development that

17
00:01:15,770 --> 00:01:24,229
you guys might be familiar with but for

18
00:01:22,400 --> 00:01:27,970
today's agenda what we're going to be

19
00:01:24,229 --> 00:01:30,289
talking about is the state of detection

20
00:01:27,970 --> 00:01:34,490
malware detection in the enterprise the

21
00:01:30,290 --> 00:01:37,760
state of AV evasion or what adversaries

22
00:01:34,490 --> 00:01:41,419
typically try to do to you know hide

23
00:01:37,760 --> 00:01:46,790
their payloads I will go into a high

24
00:01:41,420 --> 00:01:49,729
level overview of the x86 is a and go

25
00:01:46,790 --> 00:01:51,440
through some thought process hypotheses

26
00:01:49,729 --> 00:01:57,799
and testing and then finally we'll have

27
00:01:51,440 --> 00:02:00,170
a few proof-of-concept videos so before

28
00:01:57,799 --> 00:02:02,810
I get started I wanted to acknowledge a

29
00:02:00,170 --> 00:02:05,060
few researchers who've done really

30
00:02:02,810 --> 00:02:08,509
interesting work on sort of like

31
00:02:05,060 --> 00:02:10,220
similarly themed topics so Josh Pitts

32
00:02:08,508 --> 00:02:12,379
and Travis Mauro have done some really

33
00:02:10,220 --> 00:02:15,500
interesting work on genetic mal warlike

34
00:02:12,379 --> 00:02:16,609
keyed malware and then Christopher Domus

35
00:02:15,500 --> 00:02:19,940
has done a lot of really interesting

36
00:02:16,610 --> 00:02:22,129
work just on x86 in general and this

37
00:02:19,940 --> 00:02:27,140
talk tries to kind of combine both of

38
00:02:22,129 --> 00:02:29,629
those tracks and then one of the quotes

39
00:02:27,140 --> 00:02:31,700
that kind of got me thinking about

40
00:02:29,629 --> 00:02:34,220
actually presenting this research is

41
00:02:31,700 --> 00:02:36,619
from matt graver and he said as an

42
00:02:34,220 --> 00:02:38,810
offensive researcher if you can dream it

43
00:02:36,620 --> 00:02:40,430
someone has likely already done it and

44
00:02:38,810 --> 00:02:41,990
that person isn't the kind of person who

45
00:02:40,430 --> 00:02:45,400
speaks at security cons

46
00:02:41,990 --> 00:02:49,810
so here I am talking out a security con

47
00:02:45,400 --> 00:02:53,630
so sort of the genesis for this idea was

48
00:02:49,810 --> 00:02:56,930
really I wanted to ask the question can

49
00:02:53,630 --> 00:03:00,710
I make sure that my malware or my agent

50
00:02:56,930 --> 00:03:04,190
runs on my target and not other places

51
00:03:00,710 --> 00:03:05,720
to the best that I can control and what

52
00:03:04,190 --> 00:03:08,359
can I do to ensure that this doesn't

53
00:03:05,720 --> 00:03:12,530
take place in code because if your

54
00:03:08,360 --> 00:03:14,900
malware sample gets caught by any sort

55
00:03:12,530 --> 00:03:17,570
of Detective capability right eventually

56
00:03:14,900 --> 00:03:21,440
it's going to get to a reverse engineer

57
00:03:17,570 --> 00:03:26,060
and you know really no malware can

58
00:03:21,440 --> 00:03:28,010
sustain the you know the work of a group

59
00:03:26,060 --> 00:03:30,200
of trained reverse engineers for long

60
00:03:28,010 --> 00:03:34,070
enough but as somebody who does

61
00:03:30,200 --> 00:03:36,769
adversary emulation my job is to really

62
00:03:34,070 --> 00:03:38,870
make that make their job as hard as

63
00:03:36,770 --> 00:03:41,060
possible so that I can like persist and

64
00:03:38,870 --> 00:03:45,680
have access as long as possible in order

65
00:03:41,060 --> 00:03:48,080
to achieve my objectives so this is kind

66
00:03:45,680 --> 00:03:51,500
of what the state of malware detection

67
00:03:48,080 --> 00:03:54,580
looks like in most enterprises or most

68
00:03:51,500 --> 00:03:58,070
enterprises that care about security

69
00:03:54,580 --> 00:04:03,010
will do things like block suspicious or

70
00:03:58,070 --> 00:04:05,510
malicious domains check DNS will block

71
00:04:03,010 --> 00:04:07,519
suspicious or unusual emails and

72
00:04:05,510 --> 00:04:09,790
attachments with some sort of mail

73
00:04:07,520 --> 00:04:14,240
security appliance now we block

74
00:04:09,790 --> 00:04:16,659
untrusted code with either you know app

75
00:04:14,240 --> 00:04:20,350
white listing or black listing or

76
00:04:16,660 --> 00:04:25,180
certificate validation we might block

77
00:04:20,350 --> 00:04:28,310
malicious code with machine learning or

78
00:04:25,180 --> 00:04:32,660
signatures or magic pixie dust whatever

79
00:04:28,310 --> 00:04:34,660
the newest you know trend is in the

80
00:04:32,660 --> 00:04:37,640
detection space

81
00:04:34,660 --> 00:04:40,760
hopefully we're scanning and ingesting

82
00:04:37,640 --> 00:04:42,370
all of the unusual traffic that we see

83
00:04:40,760 --> 00:04:46,190
in our environment so whether that's

84
00:04:42,370 --> 00:04:50,419
files crossing the you know crossing the

85
00:04:46,190 --> 00:04:54,620
wire or unusual files on an endpoint so

86
00:04:50,419 --> 00:04:55,639
for example there's a number of like

87
00:04:54,620 --> 00:04:57,949
next-gen

88
00:04:55,639 --> 00:05:00,800
solutions that like if you drop a binary

89
00:04:57,949 --> 00:05:03,710
to disk and that binary has not been

90
00:05:00,800 --> 00:05:06,199
seen by that software before they

91
00:05:03,710 --> 00:05:09,859
immediately grab the binary and ship it

92
00:05:06,199 --> 00:05:12,740
back to their sand boxes for their own

93
00:05:09,860 --> 00:05:15,919
analysis and then presumably you know

94
00:05:12,740 --> 00:05:19,669
your organization might be subscribing

95
00:05:15,919 --> 00:05:22,340
to some threat Intel feeds looking at IO

96
00:05:19,669 --> 00:05:23,900
sees and then searching for those

97
00:05:22,340 --> 00:05:26,150
particular IRCs

98
00:05:23,900 --> 00:05:31,938
IO sees in your environment pivoting on

99
00:05:26,150 --> 00:05:35,150
that and trying to find bad stuff so at

100
00:05:31,939 --> 00:05:36,439
a high level the state of malware

101
00:05:35,150 --> 00:05:41,179
detection in the enterprise kind of

102
00:05:36,439 --> 00:05:43,009
looks like this the the bottom level of

103
00:05:41,180 --> 00:05:45,590
the pyramid is just an alert gets

104
00:05:43,009 --> 00:05:49,099
generated and something about that alert

105
00:05:45,590 --> 00:05:51,758
is interesting to a triage analyst or

106
00:05:49,099 --> 00:05:56,900
your entry level analysts in your sock

107
00:05:51,759 --> 00:06:00,169
and our job as red teamers or as

108
00:05:56,900 --> 00:06:04,849
adversaries is to either make our

109
00:06:00,169 --> 00:06:07,878
payload look as normal as possible try

110
00:06:04,849 --> 00:06:10,938
to hide the evil that we're doing or if

111
00:06:07,879 --> 00:06:13,490
that isn't possible make their job of

112
00:06:10,939 --> 00:06:15,860
understanding our payload as difficult

113
00:06:13,490 --> 00:06:18,229
as possible so in this case our goal is

114
00:06:15,860 --> 00:06:20,029
if an alert is generated we want that

115
00:06:18,229 --> 00:06:21,649
alert to get passed to a triage analyst

116
00:06:20,029 --> 00:06:23,629
so you want the triage analyst to not be

117
00:06:21,649 --> 00:06:28,069
able to understand what's happening and

118
00:06:23,629 --> 00:06:30,680
we want them to escalate that to a more

119
00:06:28,069 --> 00:06:34,849
senior analyst or a reverse engineer all

120
00:06:30,680 --> 00:06:37,159
of those steps are going to be buying us

121
00:06:34,849 --> 00:06:39,710
adversaries a little bit more time in

122
00:06:37,159 --> 00:06:41,930
your environment so that's on the

123
00:06:39,710 --> 00:06:45,318
detection side what does the offensive

124
00:06:41,930 --> 00:06:48,740
side typically look like so things

125
00:06:45,319 --> 00:06:50,810
you've probably seen before are your

126
00:06:48,740 --> 00:06:54,199
some of your payload or some of your

127
00:06:50,810 --> 00:06:57,710
payload stages being encrypted along

128
00:06:54,199 --> 00:07:00,589
with anti debugging techniques anti VM

129
00:06:57,710 --> 00:07:03,068
techniques obfuscation and environmental

130
00:07:00,589 --> 00:07:06,830
keying or that's that genetic malware

131
00:07:03,069 --> 00:07:08,000
that Josh Pitt's had presented on and my

132
00:07:06,830 --> 00:07:09,169
thought was that like all of these

133
00:07:08,000 --> 00:07:11,659
things are current

134
00:07:09,169 --> 00:07:14,438
deployed in code and yes it's a computer

135
00:07:11,659 --> 00:07:18,259
so you can never fully get away from

136
00:07:14,439 --> 00:07:20,629
code right ultimately it has to execute

137
00:07:18,259 --> 00:07:22,460
at some point I thought was what if the

138
00:07:20,629 --> 00:07:25,729
code that I'm trying to execute is

139
00:07:22,460 --> 00:07:27,650
allowed to execute on my target systems

140
00:07:25,729 --> 00:07:30,590
or specific target systems that I'm

141
00:07:27,650 --> 00:07:33,020
interested in and due to some form of

142
00:07:30,590 --> 00:07:34,758
hardware incompatibility it's not able

143
00:07:33,020 --> 00:07:37,878
to be executed on things like the

144
00:07:34,759 --> 00:07:43,939
sandbox or even even better the

145
00:07:37,879 --> 00:07:47,150
reverse-engineer system so in order to

146
00:07:43,939 --> 00:07:49,999
set up this testing environment there's

147
00:07:47,150 --> 00:07:53,210
a few you know few things that we had to

148
00:07:49,999 --> 00:07:55,460
think about and that is that the x86

149
00:07:53,210 --> 00:07:56,719
instruction set is not a static

150
00:07:55,460 --> 00:07:58,818
instruction set you've probably heard

151
00:07:56,719 --> 00:08:03,259
that it's a Sisk architecture meaning

152
00:07:58,819 --> 00:08:07,509
it's complex and more and more op codes

153
00:08:03,259 --> 00:08:07,509
or registers or features can be added

154
00:08:08,139 --> 00:08:16,399
it's also a fact that if you have a

155
00:08:11,569 --> 00:08:20,479
newer x86 CPU it might be capable of

156
00:08:16,399 --> 00:08:22,339
doing something that older systems are

157
00:08:20,479 --> 00:08:24,349
not capable of doing and that's actually

158
00:08:22,339 --> 00:08:26,529
taking place in hardware like if there's

159
00:08:24,349 --> 00:08:28,699
new registers or new instructions

160
00:08:26,529 --> 00:08:33,948
specifically registers like those things

161
00:08:28,699 --> 00:08:36,169
wouldn't exist on the older cpus and so

162
00:08:33,948 --> 00:08:41,120
the other thing to consider is there's

163
00:08:36,169 --> 00:08:44,360
probably no environment that anyone uses

164
00:08:41,120 --> 00:08:47,839
that's a monolith meaning everyone has

165
00:08:44,360 --> 00:08:49,579
the exact same computer on workstations

166
00:08:47,839 --> 00:08:52,640
and servers and in the cloud so

167
00:08:49,579 --> 00:08:55,069
typically we have different CPUs and as

168
00:08:52,640 --> 00:08:58,069
a result different ISA features on our

169
00:08:55,069 --> 00:08:59,990
desktops versus our servers versus what

170
00:08:58,069 --> 00:09:03,620
we're using in the cloud some of that we

171
00:08:59,990 --> 00:09:06,860
can control and some of it we can't so

172
00:09:03,620 --> 00:09:10,190
as I mentioned before x86 is a complex

173
00:09:06,860 --> 00:09:12,829
instruction set over time there's more

174
00:09:10,190 --> 00:09:15,589
and more op codes that get added to the

175
00:09:12,829 --> 00:09:18,260
instruction set some can even be taken

176
00:09:15,589 --> 00:09:20,839
away there's lots of undocumented

177
00:09:18,260 --> 00:09:23,089
instructions and then there's some

178
00:09:20,839 --> 00:09:27,529
really old research on

179
00:09:23,089 --> 00:09:30,739
thirty two-bit malware and legitimate

180
00:09:27,529 --> 00:09:33,199
binaries that was done in 2006 and where

181
00:09:30,739 --> 00:09:36,969
roughly 90% of all the opcodes present

182
00:09:33,199 --> 00:09:39,889
in the binaries that were tested was

183
00:09:36,969 --> 00:09:43,399
accounted for by like 14 opcode so the

184
00:09:39,889 --> 00:09:45,199
majority of x86 instructions while

185
00:09:43,399 --> 00:09:47,269
there's like hundreds of actual op codes

186
00:09:45,199 --> 00:09:50,389
available there's very few that

187
00:09:47,269 --> 00:09:56,859
typically get executed in your your

188
00:09:50,389 --> 00:10:00,169
average you know executable file format

189
00:09:56,859 --> 00:10:01,849
so as I was doing the research I I

190
00:10:00,169 --> 00:10:04,098
realized that there's a lot of

191
00:10:01,849 --> 00:10:07,909
similarities between what we're doing

192
00:10:04,099 --> 00:10:10,789
here and keed malware right but I think

193
00:10:07,909 --> 00:10:12,949
the key difference is that for Ketan

194
00:10:10,789 --> 00:10:16,639
malware you're deriving you're deriving

195
00:10:12,949 --> 00:10:22,569
the key from something in the operating

196
00:10:16,639 --> 00:10:26,749
system or something that is part of

197
00:10:22,569 --> 00:10:29,449
maybe the network or the domain or a

198
00:10:26,749 --> 00:10:31,639
driver and typically you'll read that

199
00:10:29,449 --> 00:10:34,909
key and then use that key to decrypt

200
00:10:31,639 --> 00:10:37,489
your second-stage payload here I would

201
00:10:34,909 --> 00:10:39,619
call something like this maybe is a

202
00:10:37,489 --> 00:10:43,809
keyed malware because what we're doing

203
00:10:39,619 --> 00:10:48,739
is we're not we never read a value from

204
00:10:43,809 --> 00:10:50,689
the system such that reverse engineer

205
00:10:48,739 --> 00:10:55,219
could never wouldn't be able to see like

206
00:10:50,689 --> 00:10:57,439
oh the this binary is say for example

207
00:10:55,219 --> 00:11:00,169
reading the domain name and using that

208
00:10:57,439 --> 00:11:03,738
as the key to try to decrypt this stub

209
00:11:00,169 --> 00:11:05,929
so if I supply the right domain name I'm

210
00:11:03,739 --> 00:11:07,999
supplying the right key in this case a

211
00:11:05,929 --> 00:11:11,179
reverse engineer would have to supply

212
00:11:07,999 --> 00:11:17,359
the right CPU so there's definitely ways

213
00:11:11,179 --> 00:11:21,589
to you know work around any of these you

214
00:11:17,359 --> 00:11:25,189
know techniques however it's a little

215
00:11:21,589 --> 00:11:27,139
bit more complicated to go find the

216
00:11:25,189 --> 00:11:33,679
correct hardware than like patch a

217
00:11:27,139 --> 00:11:36,320
binary again in software so historically

218
00:11:33,679 --> 00:11:42,170
what we've seen is that

219
00:11:36,320 --> 00:11:44,480
intel has added new registers and new op

220
00:11:42,170 --> 00:11:48,349
codes or instruction sets with every

221
00:11:44,480 --> 00:11:51,079
major release of CPUs and what I thought

222
00:11:48,350 --> 00:11:53,930
when I started doing this was that each

223
00:11:51,079 --> 00:11:57,620
CPU was going to iterate exactly on top

224
00:11:53,930 --> 00:12:00,680
of the next one meaning like every CPU

225
00:11:57,620 --> 00:12:02,779
that comes out today will be backwards

226
00:12:00,680 --> 00:12:05,479
compatible with all of the prior

227
00:12:02,779 --> 00:12:07,160
instruction sets and when I was looking

228
00:12:05,480 --> 00:12:11,470
into it that actually wasn't the case so

229
00:12:07,160 --> 00:12:14,180
you can if you think of our CPU

230
00:12:11,470 --> 00:12:17,600
fabricators as software developers

231
00:12:14,180 --> 00:12:21,229
they're trying new things instead of in

232
00:12:17,600 --> 00:12:23,389
code they're fabricating CPUs and some

233
00:12:21,230 --> 00:12:25,160
of those things don't work and so they

234
00:12:23,389 --> 00:12:28,959
go a different direction much like a

235
00:12:25,160 --> 00:12:34,189
developer would so here we can see in

236
00:12:28,959 --> 00:12:37,609
the early West aamir Xeon processors

237
00:12:34,190 --> 00:12:41,470
they added support for 128 bit registers

238
00:12:37,610 --> 00:12:45,980
and enhanced SSE instructions and then

239
00:12:41,470 --> 00:12:48,709
the xeon e5 family added support for the

240
00:12:45,980 --> 00:12:52,220
AVX instruction set and 256 bit

241
00:12:48,709 --> 00:12:54,709
registers previous the next generation

242
00:12:52,220 --> 00:12:58,250
after that added additional AVX

243
00:12:54,709 --> 00:13:00,349
instructions still at 256 bit registers

244
00:12:58,250 --> 00:13:03,860
and then something interesting happens

245
00:13:00,350 --> 00:13:06,860
in the middle there's the Xeon Phi

246
00:13:03,860 --> 00:13:11,410
coprocessor and Intel came out with this

247
00:13:06,860 --> 00:13:13,940
it had support for 512 bit registers

248
00:13:11,410 --> 00:13:16,219
however it had no backwards

249
00:13:13,940 --> 00:13:20,149
compatibility with any of the previous

250
00:13:16,220 --> 00:13:21,860
instruction sets and then at some point

251
00:13:20,149 --> 00:13:24,079
Intel realized that that wasn't really a

252
00:13:21,860 --> 00:13:26,089
good idea so they sort of abandoned that

253
00:13:24,079 --> 00:13:29,149
architecture and in the second

254
00:13:26,089 --> 00:13:31,819
generation of the xeon phi processor

255
00:13:29,149 --> 00:13:34,370
they they changed that and they went

256
00:13:31,819 --> 00:13:38,029
back to backwards compatibility as well

257
00:13:34,370 --> 00:13:39,829
as adding avx-512 instructions and on

258
00:13:38,029 --> 00:13:43,519
the last column the important thing to

259
00:13:39,829 --> 00:13:46,609
note is that they added some avx-512

260
00:13:43,519 --> 00:13:49,490
instruction sets from the previous xeon

261
00:13:46,610 --> 00:13:52,730
phi processor not all of them and then

262
00:13:49,490 --> 00:13:55,490
added new ones so in the in the recent

263
00:13:52,730 --> 00:13:58,070
years there's quite a variety in the

264
00:13:55,490 --> 00:14:01,610
number of in the types of op codes that

265
00:13:58,070 --> 00:14:04,220
your processor could actually support as

266
00:14:01,610 --> 00:14:08,149
a result there's a ton of different

267
00:14:04,220 --> 00:14:10,610
registers that exist on your CPU and I

268
00:14:08,149 --> 00:14:12,320
realize that this slide is pretty small

269
00:14:10,610 --> 00:14:13,490
but on the right hand side are all the

270
00:14:12,320 --> 00:14:16,070
registers that you might be familiar

271
00:14:13,490 --> 00:14:17,810
with like the instruction pointer stack

272
00:14:16,070 --> 00:14:21,140
pointer base pointer all those kinds of

273
00:14:17,810 --> 00:14:22,579
things however on the left hand side

274
00:14:21,140 --> 00:14:26,959
those are all the things that we're

275
00:14:22,580 --> 00:14:29,830
interested in using for is a specific

276
00:14:26,959 --> 00:14:35,089
malware because those are the

277
00:14:29,830 --> 00:14:38,120
potentially missing registers in certain

278
00:14:35,089 --> 00:14:40,760
CPUs so on the right hand side the blue

279
00:14:38,120 --> 00:14:44,720
column are the 128-bit registers purple

280
00:14:40,760 --> 00:14:47,510
column is 256 bit registers and the

281
00:14:44,720 --> 00:14:50,300
final pink column is a 512 bit register

282
00:14:47,510 --> 00:14:54,220
so there's actually a lot of registers

283
00:14:50,300 --> 00:14:57,920
that have been added and as somebody who

284
00:14:54,220 --> 00:15:00,079
hasn't done a lot of like assembly

285
00:14:57,920 --> 00:15:03,430
programming that was pretty interesting

286
00:15:00,079 --> 00:15:06,949
to me so now we need to move into

287
00:15:03,430 --> 00:15:09,920
testing our hypothesis so in my

288
00:15:06,950 --> 00:15:15,170
environment our testing sandbox was

289
00:15:09,920 --> 00:15:17,270
running an older xeon e5 processor so op

290
00:15:15,170 --> 00:15:23,770
codes that we might want to test would

291
00:15:17,270 --> 00:15:27,040
be 256 bit or 512 bit op codes and using

292
00:15:23,770 --> 00:15:29,510
either of those sizeof registers as well

293
00:15:27,040 --> 00:15:31,310
but first we've got to do some

294
00:15:29,510 --> 00:15:35,060
baselining so we're gonna generate some

295
00:15:31,310 --> 00:15:38,149
like standard vanilla x86 malware and

296
00:15:35,060 --> 00:15:39,680
see how our sandbox is score it and then

297
00:15:38,149 --> 00:15:43,190
we're gonna see if we can enumerate the

298
00:15:39,680 --> 00:15:46,760
hardware on certain sand boxes without

299
00:15:43,190 --> 00:15:50,180
having access to it of course our test

300
00:15:46,760 --> 00:15:50,870
sandbox we do have access to but as a

301
00:15:50,180 --> 00:15:53,839
red teamer

302
00:15:50,870 --> 00:15:56,450
or adversaries potentially won't have

303
00:15:53,839 --> 00:15:58,459
access to your sandbox so they need to

304
00:15:56,450 --> 00:16:03,050
figure out a way to get that data out of

305
00:15:58,459 --> 00:16:07,130
the sandbox so okay

306
00:16:03,050 --> 00:16:10,189
our basic test case with general generic

307
00:16:07,130 --> 00:16:12,140
like x86 and x64 opcodes it was a

308
00:16:10,190 --> 00:16:13,550
meterpreter linux reverse shell we

309
00:16:12,140 --> 00:16:15,050
uploaded it to a couple of different

310
00:16:13,550 --> 00:16:18,380
sandboxes and virustotal

311
00:16:15,050 --> 00:16:23,329
and it was scored appropriately so out

312
00:16:18,380 --> 00:16:26,390
of you know a hundred being completely

313
00:16:23,329 --> 00:16:31,310
bad it scored at 91 or ranked malicious

314
00:16:26,390 --> 00:16:33,860
and then 11 out of roughly 60 AV

315
00:16:31,310 --> 00:16:37,609
engine's detected the file no surprise

316
00:16:33,860 --> 00:16:39,760
there right some interpreter second test

317
00:16:37,610 --> 00:16:44,029
case was the same thing only for Windows

318
00:16:39,760 --> 00:16:45,110
and it actually scored worse even though

319
00:16:44,029 --> 00:16:47,660
it's essentially the same thing

320
00:16:45,110 --> 00:16:49,730
different operating system and because

321
00:16:47,660 --> 00:16:53,510
it's a Windows binary we had support for

322
00:16:49,730 --> 00:16:55,880
more sandboxes uploaded to all the

323
00:16:53,510 --> 00:17:02,060
sandboxes and it was appropriately

324
00:16:55,880 --> 00:17:04,819
scored as being really bad stuff so you

325
00:17:02,060 --> 00:17:08,800
know we ran into the problem of again we

326
00:17:04,819 --> 00:17:10,909
could test our own sandbox and

327
00:17:08,800 --> 00:17:14,000
intuitively know what type of hardware

328
00:17:10,910 --> 00:17:16,790
it's running but how can we get that

329
00:17:14,000 --> 00:17:21,319
information from other people's

330
00:17:16,790 --> 00:17:23,510
sandboxes there's a really easy way some

331
00:17:21,319 --> 00:17:25,220
of them some of the sand boxes will

332
00:17:23,510 --> 00:17:26,720
generate a report for you certainly the

333
00:17:25,220 --> 00:17:32,150
free sandbox is will and they'll take

334
00:17:26,720 --> 00:17:36,050
screenshots so in this case we uploaded

335
00:17:32,150 --> 00:17:39,350
a payload that just popped up the cpu ID

336
00:17:36,050 --> 00:17:42,860
the cpu version and the specific is a

337
00:17:39,350 --> 00:17:46,129
instructions that are supported so the

338
00:17:42,860 --> 00:17:47,928
the font is really small it was taken

339
00:17:46,130 --> 00:17:50,570
out of a report but on the left hand

340
00:17:47,929 --> 00:17:53,240
side there's a commercial sandbox that

341
00:17:50,570 --> 00:17:54,918
is running a xeon e5 processor and the

342
00:17:53,240 --> 00:17:58,610
interesting part is on the left hand

343
00:17:54,919 --> 00:18:01,940
side it's I believe is like Intel Core 2

344
00:17:58,610 --> 00:18:03,830
CPU which is pretty old is a free

345
00:18:01,940 --> 00:18:05,919
sandbox and I'm not sure if they're just

346
00:18:03,830 --> 00:18:08,809
like running it on donated hardware or

347
00:18:05,919 --> 00:18:11,720
you can't if it's if it's actually

348
00:18:08,809 --> 00:18:13,230
running in a VM certain VMs allow you to

349
00:18:11,720 --> 00:18:15,570
like patch the

350
00:18:13,230 --> 00:18:17,880
their response back from the CPUID

351
00:18:15,570 --> 00:18:20,129
instruction that might be possible but

352
00:18:17,880 --> 00:18:25,130
there's still ways that we can really

353
00:18:20,130 --> 00:18:27,090
understand and figure out what CPU is

354
00:18:25,130 --> 00:18:30,929
actually running on the system whether

355
00:18:27,090 --> 00:18:36,809
or not it reports it as such so what if

356
00:18:30,929 --> 00:18:41,340
you don't have access to your report one

357
00:18:36,809 --> 00:18:45,809
option is to create a payload that again

358
00:18:41,340 --> 00:18:48,030
runs the CPUID instruction base64 encode

359
00:18:45,809 --> 00:18:51,540
that value and then creates a web

360
00:18:48,030 --> 00:18:53,820
request and connects back to your web

361
00:18:51,540 --> 00:18:55,710
server makes a get request for the

362
00:18:53,820 --> 00:18:58,439
base64 encoded value and then you just

363
00:18:55,710 --> 00:19:01,290
decode that and it's your it it's the

364
00:18:58,440 --> 00:19:04,350
string of your processor another one

365
00:19:01,290 --> 00:19:08,309
would be any sort of sandbox that makes

366
00:19:04,350 --> 00:19:12,709
a report on what DNS or what HTTP

367
00:19:08,309 --> 00:19:18,270
requests your payload makes then your

368
00:19:12,710 --> 00:19:20,640
the CPU string is the base64 encoded URL

369
00:19:18,270 --> 00:19:24,030
in the network communications section of

370
00:19:20,640 --> 00:19:27,210
the report so we made this sort of proof

371
00:19:24,030 --> 00:19:29,010
of concept payload and sent it to

372
00:19:27,210 --> 00:19:36,140
virustotal to see what we could get back

373
00:19:29,010 --> 00:19:39,270
and these were our results the number of

374
00:19:36,140 --> 00:19:43,559
sandboxes that executed our malware was

375
00:19:39,270 --> 00:19:45,809
a pretty good amount and for the most

376
00:19:43,559 --> 00:19:48,418
part they were roughly running the intel

377
00:19:45,809 --> 00:19:50,549
core processor we didn't deduplicate it

378
00:19:48,419 --> 00:19:52,620
so I think actually that that bottom

379
00:19:50,549 --> 00:19:55,379
column is the same sandbox running it

380
00:19:52,620 --> 00:19:59,250
multiple times but if we were looking at

381
00:19:55,380 --> 00:20:03,120
making malware they could generally run

382
00:19:59,250 --> 00:20:05,940
on most systems and avoid detection in

383
00:20:03,120 --> 00:20:11,428
most sand boxes I would again target

384
00:20:05,940 --> 00:20:14,309
something like the AV X 256 instruction

385
00:20:11,429 --> 00:20:17,280
set or avx-512 because there were there

386
00:20:14,309 --> 00:20:20,370
was only two xeon cpus in the in the

387
00:20:17,280 --> 00:20:26,350
results that could possibly execute

388
00:20:20,370 --> 00:20:29,559
those op codes so now we need to

389
00:20:26,350 --> 00:20:31,750
now that we've gotten our hardware

390
00:20:29,559 --> 00:20:34,320
information out of sand boxes we need to

391
00:20:31,750 --> 00:20:38,350
create our proof of concept and get a

392
00:20:34,320 --> 00:20:40,029
hopefully a shell and to do that I took

393
00:20:38,350 --> 00:20:42,539
the reverse shell payload and compiled

394
00:20:40,029 --> 00:20:48,909
it with the visual studio compiler

395
00:20:42,539 --> 00:20:51,370
adding avx-512 support and so this is an

396
00:20:48,909 --> 00:20:53,980
example of the payload running in a

397
00:20:51,370 --> 00:20:58,209
system that doesn't support the avx-512

398
00:20:53,980 --> 00:21:05,200
instruction set so its core i9 desktop

399
00:20:58,210 --> 00:21:07,629
processor and we see that double click

400
00:21:05,200 --> 00:21:10,210
on the payload it just crashes we'll go

401
00:21:07,629 --> 00:21:14,918
into our debugger look at the

402
00:21:10,210 --> 00:21:17,980
instructions and see that I set a

403
00:21:14,919 --> 00:21:20,460
breakpoint right before the avx-512

404
00:21:17,980 --> 00:21:22,870
instructions where what we're

405
00:21:20,460 --> 00:21:26,370
dereferencing a value and putting it

406
00:21:22,870 --> 00:21:29,289
into an avx-512 register because the CPU

407
00:21:26,370 --> 00:21:35,158
physically doesn't have an avx-512

408
00:21:29,289 --> 00:21:38,139
register it just throws an exception and

409
00:21:35,159 --> 00:21:41,190
so now what does it look like when we

410
00:21:38,139 --> 00:21:46,090
have support for those instruction sets

411
00:21:41,190 --> 00:21:49,570
here we're running on a Xeon Platinum

412
00:21:46,090 --> 00:21:52,928
system in AWS and for good measure we're

413
00:21:49,570 --> 00:21:54,519
running our Windows Defender and double

414
00:21:52,929 --> 00:21:57,039
click on the file and we immediately get

415
00:21:54,519 --> 00:21:59,620
a shell back where administrator and we

416
00:21:57,039 --> 00:22:03,340
can see that we have access to files in

417
00:21:59,620 --> 00:22:05,949
the local file system so as intended the

418
00:22:03,340 --> 00:22:07,750
payload is running on the system that we

419
00:22:05,950 --> 00:22:12,730
want it to but not running on the

420
00:22:07,750 --> 00:22:15,580
systems that we are trying to avoid so

421
00:22:12,730 --> 00:22:19,350
in in order to see how this would work

422
00:22:15,580 --> 00:22:23,320
in the real world we took our avx-512

423
00:22:19,350 --> 00:22:25,000
compiled payload and uploaded it to all

424
00:22:23,320 --> 00:22:28,470
the sand boxes that we could find and

425
00:22:25,000 --> 00:22:31,600
there is really you know no good

426
00:22:28,470 --> 00:22:33,669
analysis or detection on it we did get

427
00:22:31,600 --> 00:22:36,399
information that analysis failed or that

428
00:22:33,669 --> 00:22:38,290
there was an exception to engines scored

429
00:22:36,399 --> 00:22:41,679
it as malicious although I'm not

430
00:22:38,290 --> 00:22:43,780
really sure why I hadn't heard of those

431
00:22:41,680 --> 00:22:47,440
AV engines before so they might score

432
00:22:43,780 --> 00:22:49,000
everything pretty aggressively so what

433
00:22:47,440 --> 00:22:51,490
are the detection options that you have

434
00:22:49,000 --> 00:22:53,590
if you run your own sandbox in your

435
00:22:51,490 --> 00:22:57,660
environment and you detonate a payload

436
00:22:53,590 --> 00:23:00,510
in cuckoo sandbox for example you'll

437
00:22:57,660 --> 00:23:04,360
record that an exception was caught

438
00:23:00,510 --> 00:23:06,100
it'll be a null exception address and a

439
00:23:04,360 --> 00:23:09,250
hex five exception code so you could

440
00:23:06,100 --> 00:23:12,179
potentially look for that if you are

441
00:23:09,250 --> 00:23:16,750
using a cloud-based sandbox you could

442
00:23:12,180 --> 00:23:19,450
potentially download any faulting or

443
00:23:16,750 --> 00:23:23,170
failing samples for your own analysis

444
00:23:19,450 --> 00:23:24,580
and I think the important thing to take

445
00:23:23,170 --> 00:23:28,660
away from this or that we took away from

446
00:23:24,580 --> 00:23:30,340
it is that any code that executes in

447
00:23:28,660 --> 00:23:32,140
your sandbox but fails doesn't

448
00:23:30,340 --> 00:23:36,179
necessarily mean that the binary was bad

449
00:23:32,140 --> 00:23:38,710
we need to go and investigate why those

450
00:23:36,180 --> 00:23:41,650
payloads failed or why those binaries

451
00:23:38,710 --> 00:23:44,980
failed and not just assume that there's

452
00:23:41,650 --> 00:23:47,710
not an issue there so future research

453
00:23:44,980 --> 00:23:50,080
for me at Intel is sort of branching out

454
00:23:47,710 --> 00:23:52,300
and a lot of into a lot of really

455
00:23:50,080 --> 00:23:57,060
different ways one of the interesting

456
00:23:52,300 --> 00:24:00,480
things is there they have some CPUs with

457
00:23:57,060 --> 00:24:02,560
embedded FPGAs so again you could

458
00:24:00,480 --> 00:24:06,880
potentially do some really weird stuff

459
00:24:02,560 --> 00:24:09,129
where on a traditional x86 processor you

460
00:24:06,880 --> 00:24:11,440
have access to an embedded FPGA and

461
00:24:09,130 --> 00:24:13,300
they're doing a bunch of other stuff

462
00:24:11,440 --> 00:24:19,150
additionally I thought there would be

463
00:24:13,300 --> 00:24:21,639
ways to combine the leaking data from

464
00:24:19,150 --> 00:24:24,670
the sandbox piece with delivering the

465
00:24:21,640 --> 00:24:28,840
appropriate payload so you asked the CPU

466
00:24:24,670 --> 00:24:30,960
like what version of the x86 is a ru and

467
00:24:28,840 --> 00:24:36,159
then your second stage payload would

468
00:24:30,960 --> 00:24:39,790
ship it the most appropriate is a

469
00:24:36,160 --> 00:24:42,930
version payload for it so we've got one

470
00:24:39,790 --> 00:24:42,930
minute left does anybody have questions

