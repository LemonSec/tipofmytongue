1
00:00:04,490 --> 00:00:23,890
[Music]

2
00:00:32,558 --> 00:00:35,980
hello everyone

3
00:00:37,239 --> 00:00:43,640
great so hi everyone good evening my

4
00:00:41,750 --> 00:00:46,220
name is Gabriella and I'm here to talk

5
00:00:43,640 --> 00:00:48,680
to you about trustworthy platforms in

6
00:00:46,220 --> 00:00:53,660
practice or as I like to call it I have

7
00:00:48,680 --> 00:00:56,720
a TPM know what so a little bit about me

8
00:00:53,660 --> 00:00:59,319
first the traditional Who am I I'm a

9
00:00:56,720 --> 00:01:02,809
security researcher at Nokia Bell Labs

10
00:00:59,320 --> 00:01:05,479
during my day job during the evenings

11
00:01:02,809 --> 00:01:08,270
I'm a compulsive Nader as this car can

12
00:01:05,479 --> 00:01:10,520
clearly show I've been doing research

13
00:01:08,270 --> 00:01:12,830
for the past two years in trusted

14
00:01:10,520 --> 00:01:15,229
computing and root cause analysis and

15
00:01:12,830 --> 00:01:17,390
lately I've been taking a look into

16
00:01:15,229 --> 00:01:21,500
firmware security so that's a bit of

17
00:01:17,390 --> 00:01:23,840
what I'm gonna discuss today so a simple

18
00:01:21,500 --> 00:01:27,979
question what happens when you boot your

19
00:01:23,840 --> 00:01:29,780
machine usually you power it on then

20
00:01:27,979 --> 00:01:35,479
after some time you see the bootloader

21
00:01:29,780 --> 00:01:38,119
and oh and then you go into your

22
00:01:35,479 --> 00:01:40,939
favorite Linux distribution or when

23
00:01:38,119 --> 00:01:43,159
those are whatever floats your boat but

24
00:01:40,939 --> 00:01:46,548
I actually started wondering what

25
00:01:43,159 --> 00:01:49,039
happens in this little bit between the

26
00:01:46,549 --> 00:01:51,200
power-on and the actual bootloader

27
00:01:49,039 --> 00:01:53,030
there's quite important thing and quite

28
00:01:51,200 --> 00:01:55,960
quite a lot of things happening during

29
00:01:53,030 --> 00:01:58,729
this time so this one firmware runs and

30
00:01:55,960 --> 00:02:01,729
firmware sits like if you think of your

31
00:01:58,729 --> 00:02:04,130
computer as a stack you can think of it

32
00:02:01,729 --> 00:02:05,859
as there's a layer of hardware then

33
00:02:04,130 --> 00:02:08,090
there's a layer of firmware that

34
00:02:05,859 --> 00:02:10,699
abstracts this Hardware on to the

35
00:02:08,090 --> 00:02:13,160
operating system and then on top of the

36
00:02:10,699 --> 00:02:15,589
operating system you have the hypervisor

37
00:02:13,160 --> 00:02:17,030
or your bare metal applications and then

38
00:02:15,590 --> 00:02:20,930
further up you can have your cloud

39
00:02:17,030 --> 00:02:23,810
applications so firmware has quite an

40
00:02:20,930 --> 00:02:27,770
important role it provides abstractions

41
00:02:23,810 --> 00:02:29,959
and Hardware initialization it provides

42
00:02:27,770 --> 00:02:32,959
the interface to actually start your

43
00:02:29,959 --> 00:02:36,560
operating system and it restricts access

44
00:02:32,959 --> 00:02:39,710
to privileged resources like the SPI

45
00:02:36,560 --> 00:02:42,100
flash so you can't just write into

46
00:02:39,710 --> 00:02:42,100
firmware

47
00:02:42,310 --> 00:02:47,530
another thing about firmware is that for

48
00:02:44,980 --> 00:02:49,450
Morris everywhere it's in every device

49
00:02:47,530 --> 00:02:54,190
you connect into your computer it's in

50
00:02:49,450 --> 00:02:56,440
your computer's it's in your phones it's

51
00:02:54,190 --> 00:03:00,130
in so many places that there's actually

52
00:02:56,440 --> 00:03:03,010
this nice talk called battery firmware

53
00:03:00,130 --> 00:03:05,410
hacking where this guy talked to this

54
00:03:03,010 --> 00:03:07,870
guy called Tarly Miller the talks about

55
00:03:05,410 --> 00:03:10,810
how he reverse engineer and hacked the

56
00:03:07,870 --> 00:03:12,760
firmware of some Apple batteries because

57
00:03:10,810 --> 00:03:18,130
batteries have firmware to allow the OS

58
00:03:12,760 --> 00:03:19,959
to measure the temperature how long how

59
00:03:18,130 --> 00:03:22,480
much battery you have left and so on and

60
00:03:19,959 --> 00:03:25,690
this research had actually made it so

61
00:03:22,480 --> 00:03:27,548
that you could make this battery catch

62
00:03:25,690 --> 00:03:30,160
on fire or something by modifying the

63
00:03:27,549 --> 00:03:32,110
firmware so hey it's everywhere it's

64
00:03:30,160 --> 00:03:34,450
quite privileged code maybe we should be

65
00:03:32,110 --> 00:03:37,450
taking a look at it and the main

66
00:03:34,450 --> 00:03:40,500
motivation for like firmware research or

67
00:03:37,450 --> 00:03:45,518
this research I do I always talk about

68
00:03:40,500 --> 00:03:47,920
the Snowden leaks so back in 2013-14

69
00:03:45,519 --> 00:03:50,829
when Snowden was revealing all his

70
00:03:47,920 --> 00:03:52,750
secret documents from the NSA one of

71
00:03:50,829 --> 00:03:54,970
these revelations was the fact that the

72
00:03:52,750 --> 00:03:57,760
NSA was hmm

73
00:03:54,970 --> 00:04:00,220
spying on Cisco and other big companies

74
00:03:57,760 --> 00:04:03,519
they were inserting backdoors in their

75
00:04:00,220 --> 00:04:05,560
firmware and the way they did it is that

76
00:04:03,519 --> 00:04:08,010
well Cisco would create their products

77
00:04:05,560 --> 00:04:11,260
and send it over to the customers and

78
00:04:08,010 --> 00:04:13,450
then the NSA would actually intercept

79
00:04:11,260 --> 00:04:16,450
this liveries move them to a secret

80
00:04:13,450 --> 00:04:18,519
little room modify the firmware reflash

81
00:04:16,450 --> 00:04:20,500
it with a firmware version that had a

82
00:04:18,519 --> 00:04:24,130
backdoor and then send them over on

83
00:04:20,500 --> 00:04:26,039
their way and that way they could they

84
00:04:24,130 --> 00:04:28,680
had a backdoor into these products and

85
00:04:26,039 --> 00:04:31,690
well the customers had no way of knowing

86
00:04:28,680 --> 00:04:35,590
if their firmware was ok or not

87
00:04:31,690 --> 00:04:37,180
Cisco didn't know about this and not

88
00:04:35,590 --> 00:04:39,520
only Cisco they did this and many other

89
00:04:37,180 --> 00:04:42,789
companies it's actually funny if you go

90
00:04:39,520 --> 00:04:45,669
to this a and T Product data database

91
00:04:42,789 --> 00:04:48,010
they have this webpage that collects all

92
00:04:45,669 --> 00:04:49,750
these documents of the Snowden

93
00:04:48,010 --> 00:04:51,400
revelations and it's like browsing a

94
00:04:49,750 --> 00:04:53,050
catalogue for your favorite exploits

95
00:04:51,400 --> 00:04:56,020
depending on whether you want to exploit

96
00:04:53,050 --> 00:04:59,140
a server a firewall

97
00:04:56,020 --> 00:05:01,710
phone you name it and I find it funny

98
00:04:59,140 --> 00:05:06,159
also that it's quite old technology this

99
00:05:01,710 --> 00:05:07,870
exploit is from 2008 for example makes

100
00:05:06,160 --> 00:05:12,880
you wonder what are they coming up with

101
00:05:07,870 --> 00:05:15,220
now and well firmware is quite important

102
00:05:12,880 --> 00:05:18,640
nowadays a couple of years ago they

103
00:05:15,220 --> 00:05:22,000
discovered the first UEFI boot kit in

104
00:05:18,640 --> 00:05:24,190
the wild this was quite an interesting

105
00:05:22,000 --> 00:05:26,560
attack because I don't know if you're

106
00:05:24,190 --> 00:05:28,990
familiar with a module called computer

107
00:05:26,560 --> 00:05:30,760
ace a lot of laptops specially corporate

108
00:05:28,990 --> 00:05:33,340
laptops have this module in their

109
00:05:30,760 --> 00:05:36,180
firmware so the way this module behaves

110
00:05:33,340 --> 00:05:38,859
is that on boot the computer ace

111
00:05:36,180 --> 00:05:41,650
firmware code gets executed and it

112
00:05:38,860 --> 00:05:44,830
basically implants a backdoor into the

113
00:05:41,650 --> 00:05:46,929
OS so that you can always have access or

114
00:05:44,830 --> 00:05:49,450
a backdoor into that computer in case it

115
00:05:46,930 --> 00:05:51,310
gets stolen or lost or something so that

116
00:05:49,450 --> 00:05:53,800
you can recover files or wipe the

117
00:05:51,310 --> 00:05:56,740
machine or something so it's just like a

118
00:05:53,800 --> 00:05:58,480
boot kit except that's good so what

119
00:05:56,740 --> 00:06:01,210
these attackers did is that they

120
00:05:58,480 --> 00:06:03,520
actually took this firmware module and

121
00:06:01,210 --> 00:06:05,950
they modified it so that the bacteria

122
00:06:03,520 --> 00:06:08,460
that they implanted was malicious and

123
00:06:05,950 --> 00:06:13,870
they get a remote code execution

124
00:06:08,460 --> 00:06:16,239
vulnerability and well the nice nice

125
00:06:13,870 --> 00:06:18,550
thing about this boot kit is that it can

126
00:06:16,240 --> 00:06:21,400
actually survive across reboots and

127
00:06:18,550 --> 00:06:24,100
across hard drive changes so since the

128
00:06:21,400 --> 00:06:25,450
code is in the firmware itself even if

129
00:06:24,100 --> 00:06:27,760
you change the hard drive where you have

130
00:06:25,450 --> 00:06:30,370
your OS and you plug in a new hard drive

131
00:06:27,760 --> 00:06:34,210
you're still gonna get that backdoor so

132
00:06:30,370 --> 00:06:35,830
hey firmware is quite powerful and maybe

133
00:06:34,210 --> 00:06:37,599
we should be looking at it and a lot of

134
00:06:35,830 --> 00:06:41,740
researchers are looking at it which is

135
00:06:37,600 --> 00:06:45,940
quite cool so this is how I decided to

136
00:06:41,740 --> 00:06:47,770
get started in this research and let's

137
00:06:45,940 --> 00:06:50,469
get a bit of context let's take a look

138
00:06:47,770 --> 00:06:53,080
at how does UEFI boot work because up

139
00:06:50,470 --> 00:06:55,900
until a few months ago I didn't know

140
00:06:53,080 --> 00:06:58,359
either myself and I just want to have a

141
00:06:55,900 --> 00:07:01,570
little disclaimer today I'm just gonna

142
00:06:58,360 --> 00:07:04,330
be talking about x86 food for UEFI

143
00:07:01,570 --> 00:07:08,219
machines any other architectures and

144
00:07:04,330 --> 00:07:11,010
platforms out of the scope of this talk

145
00:07:08,220 --> 00:07:13,500
so you know so the boot process it

146
00:07:11,010 --> 00:07:15,690
usually starts out with you power on

147
00:07:13,500 --> 00:07:18,630
your machine and then the first stage of

148
00:07:15,690 --> 00:07:22,350
the UEFI boot process is the secure boot

149
00:07:18,630 --> 00:07:24,930
up stage so this is code that is run

150
00:07:22,350 --> 00:07:28,350
from a little piece of the spi flash

151
00:07:24,930 --> 00:07:30,690
that is read-only memory it's called the

152
00:07:28,350 --> 00:07:32,580
initial initial boot block so you run

153
00:07:30,690 --> 00:07:34,710
the first code that gets everything

154
00:07:32,580 --> 00:07:37,710
initialized and your platform so that

155
00:07:34,710 --> 00:07:42,539
the next stage called the pre efi init

156
00:07:37,710 --> 00:07:44,400
code can run this component has a like

157
00:07:42,540 --> 00:07:47,130
an easy responsibility it's supposed to

158
00:07:44,400 --> 00:07:49,020
enumerate all the devices that it finds

159
00:07:47,130 --> 00:07:52,080
attached to the motherboard

160
00:07:49,020 --> 00:07:54,659
it doesn't initialize them but it does

161
00:07:52,080 --> 00:07:56,550
like a recon phase of going okay so I

162
00:07:54,660 --> 00:07:58,980
have this Network Devices hard drive

163
00:07:56,550 --> 00:08:01,140
this and this and that and it prepares

164
00:07:58,980 --> 00:08:04,169
the environment so that the driver

165
00:08:01,140 --> 00:08:07,969
execution engine can run in this stage

166
00:08:04,169 --> 00:08:11,010
the driver execution engine is a sort of

167
00:08:07,970 --> 00:08:14,220
Orchestrator so it's responsibility is

168
00:08:11,010 --> 00:08:17,520
to take this table of devices that the

169
00:08:14,220 --> 00:08:19,620
pre efi component found and tell them

170
00:08:17,520 --> 00:08:21,960
hey I see you you're a network interface

171
00:08:19,620 --> 00:08:25,200
card go initialize yourself and then

172
00:08:21,960 --> 00:08:26,700
tell me if it worked or not so all of

173
00:08:25,200 --> 00:08:28,490
these devices that are attached to your

174
00:08:26,700 --> 00:08:31,590
computer get to execute their own

175
00:08:28,490 --> 00:08:34,589
firmware to initialize themselves so

176
00:08:31,590 --> 00:08:37,860
this is a place where a lot of code gets

177
00:08:34,589 --> 00:08:40,400
executed and then it moves into a boot

178
00:08:37,860 --> 00:08:42,690
device selection this is the part of the

179
00:08:40,400 --> 00:08:44,670
this is part of the boot where you look

180
00:08:42,690 --> 00:08:46,410
at the driver you can boot from and

181
00:08:44,670 --> 00:08:48,270
according to the boot order to find in

182
00:08:46,410 --> 00:08:50,100
your firmware then you decide ok I'm

183
00:08:48,270 --> 00:08:53,850
booting from my hard drive or my USB

184
00:08:50,100 --> 00:08:56,430
stick and then you move all of this up

185
00:08:53,850 --> 00:09:00,030
until now had been executed code from

186
00:08:56,430 --> 00:09:02,160
the SPI flash and now when you move to

187
00:09:00,030 --> 00:09:05,250
the transient system load and final

188
00:09:02,160 --> 00:09:05,880
bootloader stage this stage for a grub

189
00:09:05,250 --> 00:09:07,950
will run

190
00:09:05,880 --> 00:09:09,900
so UEFI has this what they call a

191
00:09:07,950 --> 00:09:12,710
transient boot loader which is just a

192
00:09:09,900 --> 00:09:15,839
piece of code that will find where your

193
00:09:12,710 --> 00:09:18,709
grub bootloader or your Windows EFI boot

194
00:09:15,839 --> 00:09:21,540
loader is and it'll let this run and

195
00:09:18,709 --> 00:09:24,630
finally when you

196
00:09:21,540 --> 00:09:28,380
five stops executing it still keeps some

197
00:09:24,630 --> 00:09:31,439
code some functions that it exports as

198
00:09:28,380 --> 00:09:34,410
runtime services for the OS to use so

199
00:09:31,440 --> 00:09:36,690
all these privileged so doing firmware

200
00:09:34,410 --> 00:09:39,300
updates for example are still managed by

201
00:09:36,690 --> 00:09:41,430
the UEFI code and they provide this code

202
00:09:39,300 --> 00:09:47,008
as some some sort of interrupts or calls

203
00:09:41,430 --> 00:09:48,810
in a runtime services table so we're

204
00:09:47,009 --> 00:09:51,389
talking about this because we want to

205
00:09:48,810 --> 00:09:55,380
know well where can you EFI be attacked

206
00:09:51,389 --> 00:09:59,130
and well the first obvious candidate is

207
00:09:55,380 --> 00:10:01,319
the spi flash so a part of the spi flash

208
00:09:59,130 --> 00:10:03,509
is read-only memory the initial boot

209
00:10:01,319 --> 00:10:06,199
block but the rest of the spi flash

210
00:10:03,509 --> 00:10:09,360
where most of the firmware code lives is

211
00:10:06,199 --> 00:10:12,300
modifiable so if an attacker manages to

212
00:10:09,360 --> 00:10:14,519
rewrite some of the modules in UEFI so

213
00:10:12,300 --> 00:10:18,508
that they execute malicious code bam

214
00:10:14,519 --> 00:10:20,100
they get a hmm well they get code that

215
00:10:18,509 --> 00:10:23,100
gets executed right before you're always

216
00:10:20,100 --> 00:10:27,649
or any of your main protections get in

217
00:10:23,100 --> 00:10:31,440
place and then x86 machines have this

218
00:10:27,649 --> 00:10:33,920
interesting mode this SMM which is the

219
00:10:31,440 --> 00:10:36,660
system management mode which is the most

220
00:10:33,920 --> 00:10:38,579
privileged level at which code can run

221
00:10:36,660 --> 00:10:41,149
this is the kind of code that will take

222
00:10:38,579 --> 00:10:48,569
care of things like upgrading firmware

223
00:10:41,149 --> 00:10:52,560
it's one attack vector is to actually

224
00:10:48,569 --> 00:10:54,569
modify SMM code so do some privilege

225
00:10:52,560 --> 00:10:57,359
escalation the SMM code is actually

226
00:10:54,569 --> 00:11:00,019
located in a different part of physical

227
00:10:57,360 --> 00:11:03,959
memory it's protected when smm code runs

228
00:11:00,019 --> 00:11:06,510
all the like the cpu stops any other

229
00:11:03,959 --> 00:11:08,638
thing that's being executed it suspends

230
00:11:06,510 --> 00:11:11,519
everything and only lets that code run

231
00:11:08,639 --> 00:11:14,279
so it's the most privileged mode that

232
00:11:11,519 --> 00:11:18,600
the CPU can run in so it is a target for

233
00:11:14,279 --> 00:11:20,279
attackers so you if I actually have some

234
00:11:18,600 --> 00:11:22,800
write protections to the SPI flash

235
00:11:20,279 --> 00:11:25,620
because it would be kind of dumb to left

236
00:11:22,800 --> 00:11:29,800
let anyone modify the SPI flash

237
00:11:25,620 --> 00:11:33,079
so the first protection

238
00:11:29,800 --> 00:11:36,979
control that the bias offers is called

239
00:11:33,079 --> 00:11:39,109
the bias control bit protection it's

240
00:11:36,980 --> 00:11:41,209
just a bit that's turned on or off and

241
00:11:39,110 --> 00:11:44,810
it tells you if you can write to the SPI

242
00:11:41,209 --> 00:11:46,849
flash or not and this is not very useful

243
00:11:44,810 --> 00:11:50,089
because if an attacker actually manages

244
00:11:46,850 --> 00:11:52,009
to get SMM privileges they can just

245
00:11:50,089 --> 00:11:54,920
rewrite that bit to be whatever they

246
00:11:52,009 --> 00:11:57,620
want then there's a second kind of

247
00:11:54,920 --> 00:12:00,079
protection for the SPI flash which is

248
00:11:57,620 --> 00:12:02,269
called a protected range so this is a

249
00:12:00,079 --> 00:12:04,790
bit more advanced with this kind of

250
00:12:02,269 --> 00:12:06,949
protection you can divide the SPI flash

251
00:12:04,790 --> 00:12:09,110
into different regions and you're gonna

252
00:12:06,949 --> 00:12:11,930
find policies for each of these regions

253
00:12:09,110 --> 00:12:14,779
that say whether you can write or not to

254
00:12:11,930 --> 00:12:17,479
them and the interesting thing is that

255
00:12:14,779 --> 00:12:19,699
the SMM code doesn't have the privileges

256
00:12:17,480 --> 00:12:22,160
to change these policies so this would

257
00:12:19,699 --> 00:12:24,229
be quite a good protection except for

258
00:12:22,160 --> 00:12:26,540
the fact that many vendors don't

259
00:12:24,230 --> 00:12:29,569
implement this and the reason I find a

260
00:12:26,540 --> 00:12:33,139
bit stupid so when these protect

261
00:12:29,569 --> 00:12:35,120
protected ranges are in place if you

262
00:12:33,139 --> 00:12:37,939
want to update the firmware which is

263
00:12:35,120 --> 00:12:39,740
something that the OS will want to do if

264
00:12:37,939 --> 00:12:42,410
you want to update the firmware from the

265
00:12:39,740 --> 00:12:44,899
OS you have to write the new firmware

266
00:12:42,410 --> 00:12:47,810
you download into memory and trigger a

267
00:12:44,899 --> 00:12:49,819
reboot automatically so that upon reboot

268
00:12:47,810 --> 00:12:52,369
that code gets copied to the SPI flash

269
00:12:49,819 --> 00:12:54,319
and you boot from it but many vendors

270
00:12:52,370 --> 00:12:57,529
actually want to write directly to the

271
00:12:54,319 --> 00:12:59,540
SPI flash so that they can delay the

272
00:12:57,529 --> 00:13:01,189
reboot because the user doesn't want to

273
00:12:59,540 --> 00:13:03,199
reboot everything like if you download

274
00:13:01,189 --> 00:13:07,880
an update the user will probably try to

275
00:13:03,199 --> 00:13:09,709
say ah later you know and then user

276
00:13:07,880 --> 00:13:12,290
satisfaction is the most important thing

277
00:13:09,709 --> 00:13:14,209
which means these protections often go

278
00:13:12,290 --> 00:13:19,849
unimplemented just to make the user's

279
00:13:14,209 --> 00:13:22,670
life easier then another target of

280
00:13:19,850 --> 00:13:24,620
attacks are the option roms that get

281
00:13:22,670 --> 00:13:27,290
executed during the driver execution

282
00:13:24,620 --> 00:13:29,389
engine stage so during this stage this

283
00:13:27,290 --> 00:13:32,599
component tells let's say I have a

284
00:13:29,389 --> 00:13:34,220
network interface card and the UEFI bios

285
00:13:32,600 --> 00:13:38,290
knows about it and it says hey

286
00:13:34,220 --> 00:13:41,870
initializes initialize yourself if this

287
00:13:38,290 --> 00:13:43,399
device has compromised firmware itself

288
00:13:41,870 --> 00:13:46,220
this option

289
00:13:43,399 --> 00:13:49,130
code that is being loaded then it gets

290
00:13:46,220 --> 00:13:53,930
executed and it can potentially put in a

291
00:13:49,130 --> 00:13:55,760
backdoor into our system there's

292
00:13:53,930 --> 00:13:58,219
actually a nice example of this kind of

293
00:13:55,760 --> 00:14:01,670
attack called Thunder strike two by

294
00:13:58,220 --> 00:14:04,339
Tramel Hudson they actually modified the

295
00:14:01,670 --> 00:14:06,260
firmware of a thunderbolt cable so that

296
00:14:04,339 --> 00:14:08,779
when you connected the Thunderbolt cable

297
00:14:06,260 --> 00:14:11,569
it executed malicious code that would

298
00:14:08,779 --> 00:14:14,510
put a backdoor in your system and if you

299
00:14:11,570 --> 00:14:16,700
plugged a new like cable that was clean

300
00:14:14,510 --> 00:14:20,660
it would infect the new cable so it was

301
00:14:16,700 --> 00:14:24,980
this kind of malware in option roms so

302
00:14:20,660 --> 00:14:26,899
it is a valid attack vector then if you

303
00:14:24,980 --> 00:14:29,990
go higher up in the in the layers you

304
00:14:26,899 --> 00:14:32,180
can modify the bootloader for example if

305
00:14:29,990 --> 00:14:33,860
you take rub you can modify what grub is

306
00:14:32,180 --> 00:14:37,189
loading what commands it's executing

307
00:14:33,860 --> 00:14:39,290
that is one thing to do or you can add a

308
00:14:37,190 --> 00:14:42,380
new boot loader or a new boot option

309
00:14:39,290 --> 00:14:46,219
altogether stick your evil USB stick let

310
00:14:42,380 --> 00:14:48,650
some code run so UEFI

311
00:14:46,220 --> 00:14:50,330
to protect itself from this they

312
00:14:48,650 --> 00:14:54,770
implemented something called UEFI secure

313
00:14:50,330 --> 00:14:58,300
boot and this works as follows so your

314
00:14:54,770 --> 00:15:00,860
computer turns on and then the firmware

315
00:14:58,300 --> 00:15:02,870
will take the code from that initial

316
00:15:00,860 --> 00:15:06,279
boot block it would check that it's

317
00:15:02,870 --> 00:15:09,770
signed by the key from the manufacturer

318
00:15:06,279 --> 00:15:12,020
it all well it'll check that it is

319
00:15:09,770 --> 00:15:14,689
correctly signed and if it is it'll let

320
00:15:12,020 --> 00:15:17,240
this code run then the firmware code

321
00:15:14,690 --> 00:15:19,100
will do this same verification for the

322
00:15:17,240 --> 00:15:21,470
bootloader before it lets the bootloader

323
00:15:19,100 --> 00:15:23,450
execute so that if it's correctly sign

324
00:15:21,470 --> 00:15:24,920
then the bootloader can run and then the

325
00:15:23,450 --> 00:15:27,350
bootloader will check the kernel

326
00:15:24,920 --> 00:15:30,589
signature and then let the current the

327
00:15:27,350 --> 00:15:32,209
kernel run if it's ok sign and the

328
00:15:30,589 --> 00:15:34,339
kernel will check the kernel module so

329
00:15:32,209 --> 00:15:38,449
that only sign kernel modules get loaded

330
00:15:34,339 --> 00:15:41,329
and if any of these signatures are not

331
00:15:38,450 --> 00:15:44,630
valid then we get this nice secure boot

332
00:15:41,329 --> 00:15:46,219
violation screen and it halts boot and

333
00:15:44,630 --> 00:15:48,770
your machine doesn't boot until you fix

334
00:15:46,220 --> 00:15:53,120
it until you load actually sign

335
00:15:48,770 --> 00:15:55,540
components so secure boot relies on four

336
00:15:53,120 --> 00:15:58,390
different databases

337
00:15:55,540 --> 00:16:00,550
the first one is the platform key this

338
00:15:58,390 --> 00:16:07,590
is a key from your firmware manufacturer

339
00:16:00,550 --> 00:16:10,930
it it tells you who's allowed to sign

340
00:16:07,590 --> 00:16:14,290
the firmware or the firmware modules

341
00:16:10,930 --> 00:16:16,540
that go into your system so for example

342
00:16:14,290 --> 00:16:19,719
from my machine my platform key this is

343
00:16:16,540 --> 00:16:23,319
a Lenovo laptop so I have a Lenovo key

344
00:16:19,720 --> 00:16:25,330
in my platform key that makes sense then

345
00:16:23,320 --> 00:16:28,120
the next database we have is the key

346
00:16:25,330 --> 00:16:31,330
exchange key database so this database

347
00:16:28,120 --> 00:16:34,720
contains all the keys or certificates

348
00:16:31,330 --> 00:16:39,010
that are allowed to sign UEFI code and

349
00:16:34,720 --> 00:16:41,410
kernel modules so here I have Lenovo

350
00:16:39,010 --> 00:16:44,500
keys and Microsoft keys because well

351
00:16:41,410 --> 00:16:46,920
this machine comes with Windows usually

352
00:16:44,500 --> 00:16:51,010
and Microsoft has their own signing keys

353
00:16:46,920 --> 00:16:53,400
then we have the DB database very

354
00:16:51,010 --> 00:16:57,490
creative naming this is a whitelist

355
00:16:53,400 --> 00:17:00,220
database so this contains hashes of good

356
00:16:57,490 --> 00:17:02,290
components so when you are checking the

357
00:17:00,220 --> 00:17:04,060
component do you take a hash of it hey

358
00:17:02,290 --> 00:17:08,379
check the signature if it's in this

359
00:17:04,060 --> 00:17:11,589
database it's good to go and well here I

360
00:17:08,380 --> 00:17:15,640
have a different I have two microsoft

361
00:17:11,589 --> 00:17:18,550
keys that will be able to sign my ufi

362
00:17:15,640 --> 00:17:20,530
components and then finally there's the

363
00:17:18,550 --> 00:17:23,399
dbx database which is just like a

364
00:17:20,530 --> 00:17:25,899
revocation list so if you have any known

365
00:17:23,400 --> 00:17:28,090
bad modules you would add their

366
00:17:25,900 --> 00:17:29,950
signature to this database and my

367
00:17:28,089 --> 00:17:32,740
database is quite a big I don't really

368
00:17:29,950 --> 00:17:34,870
know what's in there but it's a

369
00:17:32,740 --> 00:17:38,530
revocation list so if any signature is

370
00:17:34,870 --> 00:17:40,000
in here that is a bad component but

371
00:17:38,530 --> 00:17:41,680
usually when I talk about secure boot

372
00:17:40,000 --> 00:17:43,600
even though it's my quite nice

373
00:17:41,680 --> 00:17:45,850
technology and it will prevent these

374
00:17:43,600 --> 00:17:49,060
unauthorized code modules from running

375
00:17:45,850 --> 00:17:52,270
on your machine I argue that verifying

376
00:17:49,060 --> 00:17:56,290
signatures it's not enough it's good but

377
00:17:52,270 --> 00:17:58,930
it it's not the whole picture so one

378
00:17:56,290 --> 00:18:01,180
example why I say verifying signatures

379
00:17:58,930 --> 00:18:04,300
it's not enough it's the shadow hammer

380
00:18:01,180 --> 00:18:05,530
attack against Asus so I think this

381
00:18:04,300 --> 00:18:07,960
attack has been discussed in this

382
00:18:05,530 --> 00:18:09,070
community quite a lot but just to make

383
00:18:07,960 --> 00:18:11,860
the story short

384
00:18:09,070 --> 00:18:15,309
and the asus live update tool got

385
00:18:11,860 --> 00:18:18,039
compromised so that it would actually do

386
00:18:15,309 --> 00:18:20,918
a firmware upgrade on the system and it

387
00:18:18,039 --> 00:18:23,080
was a malicious downgrade so to speak

388
00:18:20,919 --> 00:18:25,419
and they introduced the backdoor into

389
00:18:23,080 --> 00:18:27,908
the firmware and this all went unnoticed

390
00:18:25,419 --> 00:18:29,950
for quite a long time because all the

391
00:18:27,909 --> 00:18:33,460
binaries were assigned with asus keys

392
00:18:29,950 --> 00:18:37,029
they were old keys but they were still a

393
00:18:33,460 --> 00:18:41,350
szyskii so signing is not always the

394
00:18:37,029 --> 00:18:44,529
answer so ok if we can't if verifying is

395
00:18:41,350 --> 00:18:48,699
not enough what else can we do and let

396
00:18:44,529 --> 00:18:52,210
me introduce you to the TPM the TPM is

397
00:18:48,700 --> 00:18:54,970
this little tip that's available in many

398
00:18:52,210 --> 00:18:59,350
server class hardware laptops I think

399
00:18:54,970 --> 00:19:03,399
both of these laptops have one and it

400
00:18:59,350 --> 00:19:05,049
has nice little features so the first of

401
00:19:03,399 --> 00:19:08,949
them is the notion of a permanent

402
00:19:05,049 --> 00:19:11,320
identity so this little tip comes with a

403
00:19:08,950 --> 00:19:15,399
seed that's burned into the tip at

404
00:19:11,320 --> 00:19:17,740
manufacture time and this is unique for

405
00:19:15,399 --> 00:19:20,229
each chip that gets manufactured and

406
00:19:17,740 --> 00:19:22,690
from this seed you can generate two key

407
00:19:20,230 --> 00:19:25,120
pairs an endorsement key and an

408
00:19:22,690 --> 00:19:28,000
attestation key and these are keys that

409
00:19:25,120 --> 00:19:30,129
are the endorsement key is a key that's

410
00:19:28,000 --> 00:19:32,649
limited to doing encryption and

411
00:19:30,129 --> 00:19:34,539
decryption in the chip itself and the

412
00:19:32,649 --> 00:19:37,479
attestation key is a key that's

413
00:19:34,539 --> 00:19:40,149
restricted to doing signing inside the

414
00:19:37,480 --> 00:19:42,159
tip itself and these two keys give the

415
00:19:40,149 --> 00:19:45,639
chip a sense of identity because no

416
00:19:42,159 --> 00:19:48,879
other tip so you can't read the private

417
00:19:45,639 --> 00:19:51,309
part of these key pairs the the TPM can

418
00:19:48,879 --> 00:19:53,500
use them but you can never retrieve them

419
00:19:51,309 --> 00:19:55,690
so if you get something that's signed

420
00:19:53,500 --> 00:19:58,240
with one of these keys it means that it

421
00:19:55,690 --> 00:20:01,090
it will sign inside this TPM chip and

422
00:19:58,240 --> 00:20:03,970
this permanent identity idea is quite

423
00:20:01,090 --> 00:20:06,610
nice then it can do some crypto

424
00:20:03,970 --> 00:20:09,129
operations so encryption decryption key

425
00:20:06,610 --> 00:20:12,428
generation and so on it's quite slow but

426
00:20:09,129 --> 00:20:14,980
it has those capabilities it has a

427
00:20:12,429 --> 00:20:17,950
random number generator it has several

428
00:20:14,980 --> 00:20:20,139
counters like a clock counter number of

429
00:20:17,950 --> 00:20:22,210
times that the chip is power cycled

430
00:20:20,139 --> 00:20:22,969
number of times it goes into hibernation

431
00:20:22,210 --> 00:20:25,159
mode

432
00:20:22,970 --> 00:20:27,470
these kind of things and then perhaps

433
00:20:25,159 --> 00:20:30,020
the most important or the most relevant

434
00:20:27,470 --> 00:20:32,690
feature for my talk today is the secure

435
00:20:30,020 --> 00:20:35,179
storage the TPM provides secure storage

436
00:20:32,690 --> 00:20:39,409
in the form of non-volatile Ram and

437
00:20:35,179 --> 00:20:40,490
platform configuration registers so here

438
00:20:39,409 --> 00:20:42,860
we're gonna be focusing on these

439
00:20:40,490 --> 00:20:46,909
platform configuration registers these

440
00:20:42,860 --> 00:20:50,990
are 24 registers that can store hashes

441
00:20:46,909 --> 00:20:54,110
either sha-1 hash 256 hash and you can

442
00:20:50,990 --> 00:20:57,110
store into these registers hashes to

443
00:20:54,110 --> 00:20:58,969
represent what state your computer is in

444
00:20:57,110 --> 00:21:02,209
so we'll take a look at how that's done

445
00:20:58,970 --> 00:21:05,030
a bit later but I just want to make

446
00:21:02,210 --> 00:21:08,720
clear that when I talk about TPM I talk

447
00:21:05,030 --> 00:21:10,250
about the standard or TPM as a standard

448
00:21:08,720 --> 00:21:13,820
may be made by the trusted computing

449
00:21:10,250 --> 00:21:16,970
group and many different companies have

450
00:21:13,820 --> 00:21:19,370
their own version of TPM Google has open

451
00:21:16,970 --> 00:21:22,549
Titan which is a TPM with a little bit

452
00:21:19,370 --> 00:21:25,340
of extra functionality on top same as

453
00:21:22,549 --> 00:21:29,330
Microsoft has project servers which is a

454
00:21:25,340 --> 00:21:31,520
TPM for their cloud platforms Amazon has

455
00:21:29,330 --> 00:21:34,760
the nitro security chip and Apple has

456
00:21:31,520 --> 00:21:38,270
their two t-t-to tip so it's technology

457
00:21:34,760 --> 00:21:40,010
that's been widely used so many

458
00:21:38,270 --> 00:21:42,860
companies are actually using this

459
00:21:40,010 --> 00:21:45,830
technology and one nice thing you can do

460
00:21:42,860 --> 00:21:48,320
with TPMS on top of secure boot is

461
00:21:45,830 --> 00:21:50,510
something called measure boot so the

462
00:21:48,320 --> 00:21:53,149
idea in measured boot is we don't want

463
00:21:50,510 --> 00:21:55,429
to stop any components from running we

464
00:21:53,150 --> 00:21:58,730
want to let anything run but we want to

465
00:21:55,429 --> 00:22:01,429
measure each component that runs so we

466
00:21:58,730 --> 00:22:03,559
know what it was ran in our computer so

467
00:22:01,429 --> 00:22:06,679
here we start from the initial boot

468
00:22:03,559 --> 00:22:08,299
block this the initial part of the

469
00:22:06,679 --> 00:22:11,210
firmware is the core root of trust

470
00:22:08,299 --> 00:22:14,150
measurement that's why the CR TM name

471
00:22:11,210 --> 00:22:17,030
it'll verify itself in the form of it'll

472
00:22:14,150 --> 00:22:18,919
take a hash of that code and it'll store

473
00:22:17,030 --> 00:22:21,440
it in the TPM it doesn't do the

474
00:22:18,919 --> 00:22:25,010
signature verification it just stores a

475
00:22:21,440 --> 00:22:28,640
hash into the one of the PCRs one of the

476
00:22:25,010 --> 00:22:29,990
registers in TPM then before it lets the

477
00:22:28,640 --> 00:22:31,789
firmware the rest of the firmware

478
00:22:29,990 --> 00:22:35,230
execute it'll take a measurement of that

479
00:22:31,789 --> 00:22:37,150
firmware a store it in the TPM

480
00:22:35,230 --> 00:22:38,530
then let the firmware execute firmware

481
00:22:37,150 --> 00:22:40,179
in turn where we'll measure the

482
00:22:38,530 --> 00:22:42,879
bootloader store the measurement than

483
00:22:40,179 --> 00:22:45,040
the TPM let it run and the bootloader

484
00:22:42,880 --> 00:22:46,929
does the same for in a kernel take

485
00:22:45,040 --> 00:22:50,049
measurements store them and let it run

486
00:22:46,929 --> 00:22:53,470
and nice thing about these registers

487
00:22:50,049 --> 00:22:55,629
that the TPM has is that you don't just

488
00:22:53,470 --> 00:22:58,450
write to them in order to write a value

489
00:22:55,630 --> 00:23:01,360
into one of these registers in the TPM

490
00:22:58,450 --> 00:23:03,030
you have to extend it so when you take a

491
00:23:01,360 --> 00:23:06,820
hash of some code

492
00:23:03,030 --> 00:23:09,700
you tell the TPM ok store this hash and

493
00:23:06,820 --> 00:23:11,620
what the TPM will do is it'll take the

494
00:23:09,700 --> 00:23:14,080
value that's already in the register

495
00:23:11,620 --> 00:23:17,110
it'll concatenate the new value that

496
00:23:14,080 --> 00:23:19,059
you're telling it to write hash this

497
00:23:17,110 --> 00:23:21,639
together and this is what actually gets

498
00:23:19,059 --> 00:23:22,990
stored in the TPM which means that

499
00:23:21,640 --> 00:23:25,900
effectively by the time we're done

500
00:23:22,990 --> 00:23:27,880
booting we have a chain of trust

501
00:23:25,900 --> 00:23:29,799
established by all the components that

502
00:23:27,880 --> 00:23:32,980
were extended into each of these

503
00:23:29,799 --> 00:23:35,860
registers which is a nice feature

504
00:23:32,980 --> 00:23:38,679
because it enables us to do this thing

505
00:23:35,860 --> 00:23:41,969
called remote at the station so remote

506
00:23:38,679 --> 00:23:44,440
at the station is the process by which

507
00:23:41,970 --> 00:23:45,850
we can retrieve these measurements from

508
00:23:44,440 --> 00:23:48,820
platform and then make a judgment

509
00:23:45,850 --> 00:23:51,659
whether this platform is in a good State

510
00:23:48,820 --> 00:23:54,100
or in a bad state so notice that the

511
00:23:51,660 --> 00:23:56,700
there's a shift here in thinking so

512
00:23:54,100 --> 00:23:59,020
insecure boudu you just prevent any

513
00:23:56,700 --> 00:24:00,940
unauthorized code from running whereas

514
00:23:59,020 --> 00:24:04,530
here we let it run but then we check

515
00:24:00,940 --> 00:24:07,059
later if it's what we expect or not so

516
00:24:04,530 --> 00:24:09,280
remote at the station is the process by

517
00:24:07,059 --> 00:24:11,860
which a challenger will easily contact

518
00:24:09,280 --> 00:24:14,710
some sort of attestation server and ask

519
00:24:11,860 --> 00:24:18,219
about some platform let's say platform a

520
00:24:14,710 --> 00:24:21,130
with a TPM so the Challenger asks is a

521
00:24:18,220 --> 00:24:23,590
trusted then the attestation server has

522
00:24:21,130 --> 00:24:26,770
the responsibility to actually ask this

523
00:24:23,590 --> 00:24:29,530
server computer IOT device whatever it

524
00:24:26,770 --> 00:24:31,600
is hey can I get your measurements the

525
00:24:29,530 --> 00:24:34,780
device will return these measurements

526
00:24:31,600 --> 00:24:36,820
which are signed with one of the keys I

527
00:24:34,780 --> 00:24:40,510
talked about earlier that are unique to

528
00:24:36,820 --> 00:24:42,760
that TPM then the authorization server

529
00:24:40,510 --> 00:24:45,700
will check if this measurement is what I

530
00:24:42,760 --> 00:24:48,700
expect it to be so usually according to

531
00:24:45,700 --> 00:24:51,190
some sort of reference machine with good

532
00:24:48,700 --> 00:24:53,980
good software and firmware stack built

533
00:24:51,190 --> 00:24:57,880
and then it'll make a judgment and say

534
00:24:53,980 --> 00:25:02,290
hey yes ace trusted or a is not trusted

535
00:24:57,880 --> 00:25:04,180
and one thing you might be wondering is

536
00:25:02,290 --> 00:25:07,720
well what do these measurements look

537
00:25:04,180 --> 00:25:09,160
like they sound interesting and they're

538
00:25:07,720 --> 00:25:10,990
not really that interesting there are a

539
00:25:09,160 --> 00:25:14,200
bunch of hashes so these are the

540
00:25:10,990 --> 00:25:16,360
platform configuration registers and you

541
00:25:14,200 --> 00:25:20,500
store hashes in them and these represent

542
00:25:16,360 --> 00:25:23,050
the state of one of my machines and the

543
00:25:20,500 --> 00:25:25,540
thing is that you might be wondering

544
00:25:23,050 --> 00:25:27,879
well what does that mean that's just a

545
00:25:25,540 --> 00:25:31,120
bunch of hex numbers what do I do with

546
00:25:27,880 --> 00:25:32,920
this and the thing is that each one of

547
00:25:31,120 --> 00:25:36,520
these registers has a meaning and

548
00:25:32,920 --> 00:25:38,530
whenever you boot the firmware has a

549
00:25:36,520 --> 00:25:41,530
responsibility to create a boot log

550
00:25:38,530 --> 00:25:44,649
every time you measure anything from

551
00:25:41,530 --> 00:25:47,980
firmware or or your bootloader or your

552
00:25:44,650 --> 00:25:50,590
kernel a boot log event gets generated

553
00:25:47,980 --> 00:25:53,110
and gets stored somewhere in your

554
00:25:50,590 --> 00:25:56,169
machine so the trusted computing group

555
00:25:53,110 --> 00:25:57,850
also defines a standard for what what

556
00:25:56,170 --> 00:25:59,490
kind of logs do we get what kind of

557
00:25:57,850 --> 00:26:03,100
things can we measure in firmware

558
00:25:59,490 --> 00:26:06,040
according to this TCG PC client platform

559
00:26:03,100 --> 00:26:07,510
firmware profile specification oh that's

560
00:26:06,040 --> 00:26:10,659
a mouthful

561
00:26:07,510 --> 00:26:14,650
so yeah they define an event log that is

562
00:26:10,660 --> 00:26:16,540
generated during boot time and in the

563
00:26:14,650 --> 00:26:19,180
event log you're gonna store the hash

564
00:26:16,540 --> 00:26:22,510
that you're telling the TPM to extend

565
00:26:19,180 --> 00:26:25,060
into the registers so effectively if you

566
00:26:22,510 --> 00:26:27,820
get the event log you're able to rebuild

567
00:26:25,060 --> 00:26:30,730
the PC our measurements and know well

568
00:26:27,820 --> 00:26:34,810
what things generated this end hash and

569
00:26:30,730 --> 00:26:37,540
that's gonna become useful later on so

570
00:26:34,810 --> 00:26:40,750
these event logs are exposed through a

571
00:26:37,540 --> 00:26:43,330
runtime service from UEFI to the OS and

572
00:26:40,750 --> 00:26:45,880
the OS can choose to store it somewhere

573
00:26:43,330 --> 00:26:48,310
move it from boot time to run time so

574
00:26:45,880 --> 00:26:52,240
usually they can store it in security FS

575
00:26:48,310 --> 00:26:54,100
or something similar and yeah as I said

576
00:26:52,240 --> 00:26:56,950
before the log will allow the Challenger

577
00:26:54,100 --> 00:26:59,379
to verify how where the registers

578
00:26:56,950 --> 00:27:01,840
actually constructed because it has all

579
00:26:59,380 --> 00:27:07,140
the values that you tell the TPM 2x

580
00:27:01,840 --> 00:27:10,178
into the registers so the event dog an

581
00:27:07,140 --> 00:27:14,350
event log entry can be in one of two

582
00:27:10,179 --> 00:27:18,789
formats the first one is a sha-1 format

583
00:27:14,350 --> 00:27:22,809
which is a legacy format for TPM version

584
00:27:18,789 --> 00:27:25,210
1.2 so there's these old 1.2 TPM version

585
00:27:22,809 --> 00:27:30,360
which is now obsolete and now there's

586
00:27:25,210 --> 00:27:34,390
TPM 2.0 version so this legacy mode

587
00:27:30,360 --> 00:27:37,000
event log format has the every entry has

588
00:27:34,390 --> 00:27:40,539
the PCR you're writing to what kind of

589
00:27:37,000 --> 00:27:43,179
event this is some identifier the hash

590
00:27:40,539 --> 00:27:45,520
that you're extending to the PCR the

591
00:27:43,179 --> 00:27:47,830
size of the event data and then some

592
00:27:45,520 --> 00:27:51,250
sort of event data that describes what

593
00:27:47,830 --> 00:27:54,520
do you measured then in TPM 2 we have

594
00:27:51,250 --> 00:27:56,740
the crypto agile log format which is

595
00:27:54,520 --> 00:27:59,379
kind of similar to the previous log

596
00:27:56,740 --> 00:28:01,450
format except that it supports more

597
00:27:59,380 --> 00:28:05,500
hashing algorithms so the first format

598
00:28:01,450 --> 00:28:08,289
only supports sha-1 hash hashes and then

599
00:28:05,500 --> 00:28:14,110
the second format can have up to us many

600
00:28:08,289 --> 00:28:17,080
hashes as your TPM supports so as I said

601
00:28:14,110 --> 00:28:19,870
before every PCR has a meaning so PCR

602
00:28:17,080 --> 00:28:22,299
zero is usually this initial boot block

603
00:28:19,870 --> 00:28:25,510
the core root of trust for measurements

604
00:28:22,299 --> 00:28:27,309
and then PCR one is usually your BIOS

605
00:28:25,510 --> 00:28:29,590
configuration so everything you change

606
00:28:27,309 --> 00:28:31,570
in the BIOS if you turn on secure boot

607
00:28:29,590 --> 00:28:33,580
turn off secure boot

608
00:28:31,570 --> 00:28:37,480
I don't know change the boot order these

609
00:28:33,580 --> 00:28:41,139
kind of things PCR 2 and 3 store

610
00:28:37,480 --> 00:28:44,649
measurements for the UEFI code and the

611
00:28:41,140 --> 00:28:49,559
configuration for this UEFI code PCR for

612
00:28:44,649 --> 00:28:52,779
storts boot manager code so usually your

613
00:28:49,559 --> 00:28:57,070
bootloader and how many boot attempts it

614
00:28:52,779 --> 00:29:00,419
can store event logs for every time you

615
00:28:57,070 --> 00:29:04,529
try to boot into some boot option and

616
00:29:00,419 --> 00:29:06,940
yeah PCR 6 is manufacturer specific so

617
00:29:04,529 --> 00:29:08,289
usually there's not much there unless

618
00:29:06,940 --> 00:29:11,500
your manufacturer tells you what they're

619
00:29:08,289 --> 00:29:15,200
loading PCR 7 is used for a secure boot

620
00:29:11,500 --> 00:29:19,730
policy 8 to 15 are

621
00:29:15,200 --> 00:29:21,620
for the OS 16s debug debug and 23's

622
00:29:19,730 --> 00:29:22,070
application support and this sounds

623
00:29:21,620 --> 00:29:25,129
great

624
00:29:22,070 --> 00:29:28,970
every PCR has a meaning so it must be

625
00:29:25,130 --> 00:29:32,480
super easy to figure out what it means

626
00:29:28,970 --> 00:29:33,799
what's happening with my platform but

627
00:29:32,480 --> 00:29:35,269
then I started wondering well what

628
00:29:33,799 --> 00:29:37,549
happens when things go wrong what

629
00:29:35,269 --> 00:29:39,200
happens when your measurements are not

630
00:29:37,549 --> 00:29:42,260
what do you expect them to be how do you

631
00:29:39,200 --> 00:29:43,760
deal with this situation so there's two

632
00:29:42,260 --> 00:29:46,940
ways of thinking about it the secure

633
00:29:43,760 --> 00:29:48,649
boot way means well you're verifying

634
00:29:46,940 --> 00:29:50,480
signature so you don't let that code

635
00:29:48,649 --> 00:29:51,949
execute a measure boot

636
00:29:50,480 --> 00:29:54,500
since we're storing hashes of every

637
00:29:51,950 --> 00:29:59,019
component you let any code run and then

638
00:29:54,500 --> 00:30:01,039
you verify later like what

639
00:29:59,019 --> 00:30:05,539
what were the measurements of these

640
00:30:01,039 --> 00:30:08,769
components that you run and here I'm - I

641
00:30:05,539 --> 00:30:12,559
try to go for the measured boot option

642
00:30:08,769 --> 00:30:14,809
because if a platform fails like if it's

643
00:30:12,559 --> 00:30:17,120
a consumer laptop it's okay to use

644
00:30:14,809 --> 00:30:19,220
secure boot you probably don't want your

645
00:30:17,120 --> 00:30:22,189
machine to boot any unauthorized code

646
00:30:19,220 --> 00:30:24,649
but if you think of like a large data

647
00:30:22,190 --> 00:30:26,630
centers maybe some more critical

648
00:30:24,649 --> 00:30:29,449
platforms you might actually want to

649
00:30:26,630 --> 00:30:31,490
investigate what is happening so my

650
00:30:29,450 --> 00:30:33,590
machine is not in the state I expect it

651
00:30:31,490 --> 00:30:35,809
to be but I want to know why I don't

652
00:30:33,590 --> 00:30:37,820
want to just stop it from executing the

653
00:30:35,809 --> 00:30:40,428
code I want to know what happens and do

654
00:30:37,820 --> 00:30:43,519
some forensics and some investigation so

655
00:30:40,429 --> 00:30:45,340
my goal was to use logs to actually

656
00:30:43,519 --> 00:30:48,230
investigate these trust failures

657
00:30:45,340 --> 00:30:51,649
building some sort of framework so that

658
00:30:48,230 --> 00:30:53,360
I can pinpoint what part of my system I

659
00:30:51,649 --> 00:30:56,389
should be checking in detail because

660
00:30:53,360 --> 00:30:59,870
it's not realistic to all the time take

661
00:30:56,389 --> 00:31:02,779
all the parts of my machine especially

662
00:30:59,870 --> 00:31:04,908
if I have many many machines so I

663
00:31:02,779 --> 00:31:09,409
started wondering okay can I use the

664
00:31:04,909 --> 00:31:10,820
event logs for this and then I started

665
00:31:09,409 --> 00:31:12,559
working with the logs in practice

666
00:31:10,820 --> 00:31:15,110
according to the standard it should be

667
00:31:12,559 --> 00:31:18,559
fairly easy everything's to fine

668
00:31:15,110 --> 00:31:20,269
standards are always great right well

669
00:31:18,559 --> 00:31:23,450
not necessarily

670
00:31:20,269 --> 00:31:27,679
the Linux kernel actually added support

671
00:31:23,450 --> 00:31:28,580
for moving the event log from the UEFI

672
00:31:27,679 --> 00:31:31,370
boot time

673
00:31:28,580 --> 00:31:37,399
to the runtime into the OS ever since

674
00:31:31,370 --> 00:31:39,260
kernel 4.11 but I found that these locks

675
00:31:37,399 --> 00:31:41,809
are actually hard to find so far the

676
00:31:39,260 --> 00:31:45,860
only Linux distro I can find the logs

677
00:31:41,809 --> 00:31:47,779
during the runtime is fedora so here I

678
00:31:45,860 --> 00:31:52,668
have examples from some machines I have

679
00:31:47,779 --> 00:31:55,519
Fedora has my boot log-in security FS

680
00:31:52,669 --> 00:31:58,190
but then I think this is CentOS and

681
00:31:55,519 --> 00:31:59,570
Ubuntu they're not moving the log even

682
00:31:58,190 --> 00:32:01,970
though the code is in the kernel and

683
00:31:59,570 --> 00:32:04,850
these things are running same kernel

684
00:32:01,970 --> 00:32:06,710
version some some distros actually

685
00:32:04,850 --> 00:32:09,408
provide you with these logs some other

686
00:32:06,710 --> 00:32:11,269
distros oh you don't need them it's

687
00:32:09,409 --> 00:32:15,590
probably that no one is asking for it

688
00:32:11,269 --> 00:32:17,059
so that was one struggle I found when

689
00:32:15,590 --> 00:32:21,408
working with these logs I actually had

690
00:32:17,059 --> 00:32:23,870
to use some specific OS then there's a

691
00:32:21,409 --> 00:32:26,990
problem that in the standards there's a

692
00:32:23,870 --> 00:32:32,299
lot of these manufacturer-specific log

693
00:32:26,990 --> 00:32:34,460
entries so parsing this logs is quite

694
00:32:32,299 --> 00:32:37,760
tedious you have to like figure out each

695
00:32:34,460 --> 00:32:39,409
event has a different kind of data in it

696
00:32:37,760 --> 00:32:41,360
and you have to parse them and some of

697
00:32:39,409 --> 00:32:43,370
them you don't know how to parse because

698
00:32:41,360 --> 00:32:45,080
the manufacturer decides what they put

699
00:32:43,370 --> 00:32:47,719
in there and the manufacturer usually

700
00:32:45,080 --> 00:32:52,539
doesn't document what they're putting in

701
00:32:47,720 --> 00:32:55,580
there then I had the problem of

702
00:32:52,539 --> 00:32:57,950
different event log formats so some

703
00:32:55,580 --> 00:33:01,010
machines and some machines the firmware

704
00:32:57,950 --> 00:33:02,960
and actually lets you pick what kind of

705
00:33:01,010 --> 00:33:05,090
log format do you want to use whether

706
00:33:02,960 --> 00:33:07,309
you want to use the legacy mode with

707
00:33:05,090 --> 00:33:12,799
only the sha-1 hashes or if you want to

708
00:33:07,309 --> 00:33:14,899
use the new 2.0 mode and I found some

709
00:33:12,799 --> 00:33:18,168
platforms where the logs even though

710
00:33:14,899 --> 00:33:20,510
there was a TPM 2.0 the logs were stored

711
00:33:18,169 --> 00:33:22,760
in legacy mode and there was no way of

712
00:33:20,510 --> 00:33:24,169
changing this so it changes the whole

713
00:33:22,760 --> 00:33:27,559
way then you have to write two different

714
00:33:24,169 --> 00:33:29,960
parsers for the logs and it dispels up I

715
00:33:27,559 --> 00:33:32,750
just wanted to do something and oh wait

716
00:33:29,960 --> 00:33:35,600
there's there's a lot of rocks little

717
00:33:32,750 --> 00:33:37,850
rocks in the way and then the final

718
00:33:35,600 --> 00:33:40,850
problem I had dealing with these logs

719
00:33:37,850 --> 00:33:41,260
were missing events so when I would see

720
00:33:40,850 --> 00:33:43,870
something

721
00:33:41,260 --> 00:33:47,620
like this I would say hey cool I'm

722
00:33:43,870 --> 00:33:50,050
getting nine different no 11 different

723
00:33:47,620 --> 00:33:52,659
registers with measurements I must be

724
00:33:50,050 --> 00:33:55,570
measuring a lot of things like I'm I'm

725
00:33:52,660 --> 00:33:58,150
verifying everything in my firmware but

726
00:33:55,570 --> 00:34:00,689
if you actually notice these events

727
00:33:58,150 --> 00:34:03,280
these hashes are all the same which was

728
00:34:00,690 --> 00:34:06,040
wait a minute that that's not very

729
00:34:03,280 --> 00:34:08,620
realistic what's happening here and once

730
00:34:06,040 --> 00:34:10,779
they actually got to parse the logs and

731
00:34:08,620 --> 00:34:14,109
check what was happening I found out

732
00:34:10,780 --> 00:34:17,350
that well only one event is being stored

733
00:34:14,110 --> 00:34:20,980
in these PCRs which is a separator event

734
00:34:17,350 --> 00:34:22,870
that tells you that the booth that the

735
00:34:20,980 --> 00:34:24,730
firmware has moved execution from boot

736
00:34:22,870 --> 00:34:27,969
time to run time so it's not really

737
00:34:24,730 --> 00:34:31,600
measuring much which okay it can be a

738
00:34:27,969 --> 00:34:34,209
bit misleading so it takes me to my main

739
00:34:31,600 --> 00:34:38,199
problem with firmware which is the fact

740
00:34:34,210 --> 00:34:40,510
that you have the open source

741
00:34:38,199 --> 00:34:45,460
implementation for UEFI firmware it's

742
00:34:40,510 --> 00:34:48,129
called Tiano core so the UEFI standard

743
00:34:45,460 --> 00:34:48,970
defines what you if I should be like and

744
00:34:48,129 --> 00:34:51,790
there's a reference implementation

745
00:34:48,969 --> 00:34:54,310
that's open source that's cool then

746
00:34:51,790 --> 00:34:57,279
manufacturers and original equipment

747
00:34:54,310 --> 00:34:59,259
manufacturers so OEMs they take this

748
00:34:57,280 --> 00:35:01,150
open source reference implementation and

749
00:34:59,260 --> 00:35:06,130
they modify it for their specific

750
00:35:01,150 --> 00:35:07,930
platforms they add a magic and then what

751
00:35:06,130 --> 00:35:11,560
you end up is with absolutely

752
00:35:07,930 --> 00:35:12,669
proprietary software or firmware and you

753
00:35:11,560 --> 00:35:15,160
don't really know what it's doing

754
00:35:12,670 --> 00:35:18,430
because a lot of features just don't get

755
00:35:15,160 --> 00:35:21,730
documented and you're they're stuck like

756
00:35:18,430 --> 00:35:23,950
okay well what do I do now what how can

757
00:35:21,730 --> 00:35:26,830
I still you see sucks but I was

758
00:35:23,950 --> 00:35:31,029
determined to use these locks somehow

759
00:35:26,830 --> 00:35:32,680
and I started wondering well how far

760
00:35:31,030 --> 00:35:34,960
will this open source UEFI

761
00:35:32,680 --> 00:35:37,330
implementation take us what what can we

762
00:35:34,960 --> 00:35:40,810
actually measure and guarantee if we're

763
00:35:37,330 --> 00:35:44,799
gonna talk call our platforms trusted so

764
00:35:40,810 --> 00:35:49,210
I set up a small demo I decided to go

765
00:35:44,800 --> 00:35:51,700
the virtualized way so I set up a qmo

766
00:35:49,210 --> 00:35:53,920
virtual machine that was running with a

767
00:35:51,700 --> 00:35:57,009
TPM 2.0 Emily

768
00:35:53,920 --> 00:36:00,730
and the open-source implementation for

769
00:35:57,010 --> 00:36:04,300
UEFI for that's called ovm f the open

770
00:36:00,730 --> 00:36:06,820
virtual machine firmware and I used

771
00:36:04,300 --> 00:36:10,150
fedora server 31 to be able to get boot

772
00:36:06,820 --> 00:36:12,460
logs and I decided well let's build a

773
00:36:10,150 --> 00:36:16,270
visualizer for logs so that I can

774
00:36:12,460 --> 00:36:20,080
investigate trust failures from the TPM

775
00:36:16,270 --> 00:36:22,450
and well now I have a small demo of what

776
00:36:20,080 --> 00:36:25,990
I actually built so I can show you what

777
00:36:22,450 --> 00:36:30,029
we can change and I think the screen

778
00:36:25,990 --> 00:36:40,859
should change now into my other laptop

779
00:36:30,030 --> 00:36:40,860
went to sleep just a second demo effect

780
00:36:43,020 --> 00:36:57,369
ok there we go ok so first of all I

781
00:36:51,570 --> 00:37:05,260
start my TPM 2.0 emulator and then I

782
00:36:57,369 --> 00:37:09,730
start a my virtual machine which is

783
00:37:05,260 --> 00:37:12,460
running and the OMF open-source

784
00:37:09,730 --> 00:37:20,260
implementation of the ufi firmware that

785
00:37:12,460 --> 00:37:24,190
i compiled so i start running that so I

786
00:37:20,260 --> 00:37:27,190
can enter my password yeah so we can see

787
00:37:24,190 --> 00:37:29,050
that things are getting written into the

788
00:37:27,190 --> 00:37:32,770
TPM it's doing something

789
00:37:29,050 --> 00:37:37,750
well it's putting my open-source UEFI

790
00:37:32,770 --> 00:37:40,720
firmware so ok let's load Fedora 5.4 and

791
00:37:37,750 --> 00:37:44,970
it starts initializing all the modules

792
00:37:40,720 --> 00:37:48,368
so you can see where's my cursor here

793
00:37:44,970 --> 00:37:50,919
the some things get written into the TPM

794
00:37:48,369 --> 00:37:53,619
while it's booting takes a while it's

795
00:37:50,920 --> 00:37:58,530
doing all the measurement initialization

796
00:37:53,619 --> 00:37:58,530
and so on so we can wait for it to boot

797
00:38:02,259 --> 00:38:10,029
right okay it's doing stuff

798
00:38:13,090 --> 00:38:19,300
and there we go I have my Fedora machine

799
00:38:15,640 --> 00:38:22,420
so I can log into it and the first thing

800
00:38:19,300 --> 00:38:25,390
I'm gonna show you is what remote at the

801
00:38:22,420 --> 00:38:27,910
station looks like so I have my

802
00:38:25,390 --> 00:38:30,940
attestation server which is this entity

803
00:38:27,910 --> 00:38:33,609
I can ask hey tell me if a machine is

804
00:38:30,940 --> 00:38:35,440
stressed it or not so I have my Fedora

805
00:38:33,610 --> 00:38:39,400
virtual machine being monitored by the

806
00:38:35,440 --> 00:38:41,860
server and well I have some details

807
00:38:39,400 --> 00:38:44,110
about my virtual machine I have the IP

808
00:38:41,860 --> 00:38:45,820
which is conveniently localhost because

809
00:38:44,110 --> 00:38:48,940
I didn't want to connect to the network

810
00:38:45,820 --> 00:38:51,820
here then I have these keys that

811
00:38:48,940 --> 00:38:54,760
identify the TPM the public key the

812
00:38:51,820 --> 00:38:56,080
private key sorry the two public keys

813
00:38:54,760 --> 00:38:59,410
they're at the station and the

814
00:38:56,080 --> 00:39:04,600
endorsement key I have information about

815
00:38:59,410 --> 00:39:09,339
what kernel is running but OS and then I

816
00:39:04,600 --> 00:39:11,980
have a policy for my machine firmware

817
00:39:09,340 --> 00:39:14,020
policy this policy is simply a mapping

818
00:39:11,980 --> 00:39:16,570
between what kind of measurement I can

819
00:39:14,020 --> 00:39:19,240
take and what's the value I expect it to

820
00:39:16,570 --> 00:39:22,000
have and then based on this I do some

821
00:39:19,240 --> 00:39:24,549
very simple rules to evaluate if my

822
00:39:22,000 --> 00:39:27,880
machine is stressed it or not so I can

823
00:39:24,550 --> 00:39:29,050
you actually see I check that the

824
00:39:27,880 --> 00:39:31,930
machine has the correct system

825
00:39:29,050 --> 00:39:34,000
measurements that it that the

826
00:39:31,930 --> 00:39:36,730
measurements are signed in a valid

827
00:39:34,000 --> 00:39:39,940
manner and then that it has some valid

828
00:39:36,730 --> 00:39:43,900
fields in the structure so I can

829
00:39:39,940 --> 00:39:45,940
actually go and check that my virtual

830
00:39:43,900 --> 00:39:49,510
machine is in a good state I can

831
00:39:45,940 --> 00:39:52,180
reattached my virtual machine and you

832
00:39:49,510 --> 00:39:57,460
can see well it went by too fast but

833
00:39:52,180 --> 00:39:59,589
when I do the at the station it's doing

834
00:39:57,460 --> 00:40:01,990
stuff on my TPM so it's getting the

835
00:39:59,590 --> 00:40:05,920
measurements and then well I get the

836
00:40:01,990 --> 00:40:08,259
results the machine is it's good so what

837
00:40:05,920 --> 00:40:11,020
I'm gonna do now is we're gonna tamper

838
00:40:08,260 --> 00:40:15,600
with this machine so for this demo I

839
00:40:11,020 --> 00:40:18,759
actually prepared a different version of

840
00:40:15,600 --> 00:40:20,860
the ovm F firmware where I've modified

841
00:40:18,760 --> 00:40:24,870
with one of the components that gets run

842
00:40:20,860 --> 00:40:24,870
during boot time so I

843
00:40:29,530 --> 00:40:40,010
just a second right so here I'm running

844
00:40:36,560 --> 00:40:44,450
my virtual machine but now the firmware

845
00:40:40,010 --> 00:40:46,840
that's being running is ovm F disobey so

846
00:40:44,450 --> 00:40:49,970
once I actually run this virtual machine

847
00:40:46,840 --> 00:40:53,750
have tampered with it and we can soon

848
00:40:49,970 --> 00:40:56,750
see that I've changed the boot image so

849
00:40:53,750 --> 00:40:59,510
it's a simple simple change I'm not

850
00:40:56,750 --> 00:41:01,310
really injecting malicious code but I am

851
00:40:59,510 --> 00:41:02,960
changing something in the firmware I am

852
00:41:01,310 --> 00:41:06,529
this would be the equivalent of

853
00:41:02,960 --> 00:41:08,720
rewriting the SPI flash and now just to

854
00:41:06,530 --> 00:41:10,340
show another kind of tampering that can

855
00:41:08,720 --> 00:41:13,669
be done I'm actually going to boot from

856
00:41:10,340 --> 00:41:16,820
a different kernel a previous version of

857
00:41:13,670 --> 00:41:18,830
the Fedora core and also 5.3 which is

858
00:41:16,820 --> 00:41:23,540
different from what we booted in before

859
00:41:18,830 --> 00:41:26,360
and yeah well it's gonna take a little

860
00:41:23,540 --> 00:41:30,430
while to boot again and we can see that

861
00:41:26,360 --> 00:41:35,770
measurements are happening in our TPM so

862
00:41:30,430 --> 00:41:35,770
just wait a second

863
00:41:40,640 --> 00:41:43,299
yeah

864
00:41:43,820 --> 00:41:46,480
uh-huh

865
00:41:49,590 --> 00:41:55,350
yeah it's doing things it's measuring

866
00:41:52,170 --> 00:41:57,930
the components again it takes a while

867
00:41:55,350 --> 00:42:07,170
and I should get my login prompt soon

868
00:41:57,930 --> 00:42:10,919
yes yes and now we can actually go and

869
00:42:07,170 --> 00:42:12,840
reattach the machine so this would be

870
00:42:10,920 --> 00:42:15,240
done automatically in the normal setting

871
00:42:12,840 --> 00:42:18,540
their mo effects may make it so that I

872
00:42:15,240 --> 00:42:20,970
have to press buttons but we take our

873
00:42:18,540 --> 00:42:24,779
Fedora virtual machine and we re attest

874
00:42:20,970 --> 00:42:28,020
it and when i refresh the page you can

875
00:42:24,780 --> 00:42:30,290
actually see that it's not trusted

876
00:42:28,020 --> 00:42:34,290
anymore so something turned red okay

877
00:42:30,290 --> 00:42:35,790
then I can actually go into the details

878
00:42:34,290 --> 00:42:38,670
of the machine and it's gonna tell me

879
00:42:35,790 --> 00:42:41,160
hey your measurements are all they're

880
00:42:38,670 --> 00:42:43,050
all wrong and okay that is something now

881
00:42:41,160 --> 00:42:45,839
I know my Fedora virtual machine is not

882
00:42:43,050 --> 00:42:47,670
trusted but I want to do more than that

883
00:42:45,840 --> 00:42:50,100
I want to know well what part of it is

884
00:42:47,670 --> 00:42:53,790
it not trust it is the whole thing bad

885
00:42:50,100 --> 00:42:56,960
like what should I focus on so I have

886
00:42:53,790 --> 00:43:01,290
this little script that will take the

887
00:42:56,960 --> 00:43:04,730
logs from the virtual machine and then

888
00:43:01,290 --> 00:43:04,730
how I can show you my visualizer

889
00:43:11,760 --> 00:43:16,770
so the latest - just a second

890
00:43:29,030 --> 00:43:34,250
right so I start my visualizer with the

891
00:43:31,610 --> 00:43:36,470
two latest log so I have a boot log from

892
00:43:34,250 --> 00:43:39,290
the previous time I booted and I have a

893
00:43:36,470 --> 00:43:44,180
boot log from this time I booted my

894
00:43:39,290 --> 00:43:47,270
machine and it should be available here

895
00:43:44,180 --> 00:43:49,790
and you can see well I have a list of my

896
00:43:47,270 --> 00:43:54,980
PC RS and there's quite some changes so

897
00:43:49,790 --> 00:43:59,180
I can see PC R 0 changed PCR for change

898
00:43:54,980 --> 00:44:01,010
PC R 8 and 9 change so ok this gives me

899
00:43:59,180 --> 00:44:03,200
more of an indication so if we go by the

900
00:44:01,010 --> 00:44:05,630
standards we remember these all have

901
00:44:03,200 --> 00:44:08,390
different meanings depending like they

902
00:44:05,630 --> 00:44:11,150
all represent roughly one component or

903
00:44:08,390 --> 00:44:13,879
the other in the BIOS and then I created

904
00:44:11,150 --> 00:44:16,490
this kind of like visualization that

905
00:44:13,880 --> 00:44:19,730
lets me know how many events are there

906
00:44:16,490 --> 00:44:22,100
for each PCR so the inner ring each

907
00:44:19,730 --> 00:44:24,560
number represents a PCR and then the

908
00:44:22,100 --> 00:44:26,180
bigger the slice the more events or the

909
00:44:24,560 --> 00:44:32,180
more things that were measured into each

910
00:44:26,180 --> 00:44:34,190
PCR so PC R 0 I can actually see there

911
00:44:32,180 --> 00:44:39,740
was a change something was different

912
00:44:34,190 --> 00:44:42,170
before and I can see if I well I'm gonna

913
00:44:39,740 --> 00:44:44,029
move really quickly into like between

914
00:44:42,170 --> 00:44:47,000
these two events and you should see that

915
00:44:44,030 --> 00:44:49,250
these hashes change so some part of the

916
00:44:47,000 --> 00:44:51,710
firmware something that starts in this

917
00:44:49,250 --> 00:44:54,260
address has changed its contents and

918
00:44:51,710 --> 00:44:56,690
this would be the disobey logo showing

919
00:44:54,260 --> 00:44:59,150
when I bought my machine so then this

920
00:44:56,690 --> 00:45:01,190
would give me the indicator so according

921
00:44:59,150 --> 00:45:04,850
to this this is a platform firmware

922
00:45:01,190 --> 00:45:07,610
event so since PCR 0 change and I can

923
00:45:04,850 --> 00:45:08,990
see from the log that this specific hash

924
00:45:07,610 --> 00:45:10,670
changed I know

925
00:45:08,990 --> 00:45:13,330
okay maybe I should go into the firmware

926
00:45:10,670 --> 00:45:15,380
image and check what has changed in this

927
00:45:13,330 --> 00:45:21,860
address so I get some extra information

928
00:45:15,380 --> 00:45:24,560
for doing my forensics then then we can

929
00:45:21,860 --> 00:45:27,560
do the same for each PCR that change

930
00:45:24,560 --> 00:45:29,779
basically so right now it's very rough

931
00:45:27,560 --> 00:45:31,460
and manual but ideally this could be

932
00:45:29,780 --> 00:45:36,530
automated because all the information is

933
00:45:31,460 --> 00:45:39,700
there so for oh so for BC r4

934
00:45:36,530 --> 00:45:41,730
I can see that

935
00:45:39,700 --> 00:45:41,730
ah

936
00:45:46,930 --> 00:45:54,129
let's go to PCR and I'm having a bit of

937
00:45:50,770 --> 00:45:55,630
them more effect PCR 9 contains the

938
00:45:54,130 --> 00:45:57,130
measurements of the kernel that's being

939
00:45:55,630 --> 00:46:00,130
loaded which is the other thing I

940
00:45:57,130 --> 00:46:02,470
tampered with so you can see here that

941
00:46:00,130 --> 00:46:05,109
the measurements of the kernel and the

942
00:46:02,470 --> 00:46:08,410
init Rd have actually changed because I

943
00:46:05,109 --> 00:46:11,230
bought it from a different kernel so the

944
00:46:08,410 --> 00:46:14,828
idea of this demo is to kind of guide my

945
00:46:11,230 --> 00:46:17,920
forensics analysis so if I have many

946
00:46:14,829 --> 00:46:19,690
machines and one of them has a trust

947
00:46:17,920 --> 00:46:22,900
failure one of them gets compromised

948
00:46:19,690 --> 00:46:25,270
changed attack whatever you name it then

949
00:46:22,900 --> 00:46:27,279
I I can detect it using remote at the

950
00:46:25,270 --> 00:46:30,279
station and I can use the logs to

951
00:46:27,279 --> 00:46:35,049
actually do a deeper analysis on what

952
00:46:30,279 --> 00:46:37,420
has changed in that machine so then you

953
00:46:35,049 --> 00:46:39,520
can use tools like there's this thing

954
00:46:37,420 --> 00:46:44,079
called UEFI tool and I don't know how

955
00:46:39,520 --> 00:46:45,700
visible it is there but you can dump the

956
00:46:44,079 --> 00:46:48,549
firmware image and then you can actually

957
00:46:45,700 --> 00:46:50,828
go do detailed analysis and see what

958
00:46:48,549 --> 00:46:53,829
address what offsets things are and you

959
00:46:50,829 --> 00:46:58,390
can see differences between previous

960
00:46:53,829 --> 00:47:00,880
States and current states so that is the

961
00:46:58,390 --> 00:47:05,078
end of my demo and I guess we should

962
00:47:00,880 --> 00:47:08,770
change screens back yes so as I was

963
00:47:05,079 --> 00:47:11,049
saying a little while ago well why why

964
00:47:08,770 --> 00:47:12,549
are we doing this at all and main

965
00:47:11,049 --> 00:47:15,279
motivation is this if you think in

966
00:47:12,549 --> 00:47:18,339
larger scale we're not gonna really have

967
00:47:15,279 --> 00:47:20,559
UEFI tools for each one of our machines

968
00:47:18,339 --> 00:47:23,078
in the data center to check that the

969
00:47:20,559 --> 00:47:25,660
firmware hasn't changed that's not

970
00:47:23,079 --> 00:47:27,520
really realistic so I think that remote

971
00:47:25,660 --> 00:47:32,049
at the station can be used as the like

972
00:47:27,520 --> 00:47:34,599
first detection protection so to speak

973
00:47:32,049 --> 00:47:37,119
and then when something changes we can

974
00:47:34,599 --> 00:47:39,789
go and do a deep deep analysis and we

975
00:47:37,119 --> 00:47:43,750
can use these locks to guide where we go

976
00:47:39,789 --> 00:47:46,809
and do this analysis so well this

977
00:47:43,750 --> 00:47:49,150
incomplete yes their event logs are not

978
00:47:46,809 --> 00:47:51,369
perfect but I don't think it's a waste

979
00:47:49,150 --> 00:47:54,369
of time because there's a lot of things

980
00:47:51,369 --> 00:47:58,420
we can measure with the logs that give

981
00:47:54,369 --> 00:48:00,670
that UEFI measures so we can detect

982
00:47:58,420 --> 00:48:03,280
things like changes in the BIOS

983
00:48:00,670 --> 00:48:06,400
changes some firmware changes in the

984
00:48:03,280 --> 00:48:08,440
secure boot keys and databases changes

985
00:48:06,400 --> 00:48:10,900
in the boot order and changes in the

986
00:48:08,440 --> 00:48:12,640
kernel so ok there are some things

987
00:48:10,900 --> 00:48:14,920
defined by the standards which would be

988
00:48:12,640 --> 00:48:17,830
really cool to detect that I haven't

989
00:48:14,920 --> 00:48:20,860
been able to detect yet like measuring

990
00:48:17,830 --> 00:48:23,980
the BMC code if you think of like data

991
00:48:20,860 --> 00:48:26,770
center servers measuring non host

992
00:48:23,980 --> 00:48:28,690
platforms and measuring the table of

993
00:48:26,770 --> 00:48:30,009
devices that are actually attached to

994
00:48:28,690 --> 00:48:32,020
your motherboard these are things that

995
00:48:30,010 --> 00:48:35,410
should be possible to measure but then

996
00:48:32,020 --> 00:48:36,610
it's up to the firmware manufacturer the

997
00:48:35,410 --> 00:48:38,560
person who actually writes the firmware

998
00:48:36,610 --> 00:48:42,490
it to decide what they think is

999
00:48:38,560 --> 00:48:43,990
important to measure or not so does it

1000
00:48:42,490 --> 00:48:46,419
mean we should stop caring about this

1001
00:48:43,990 --> 00:48:48,790
because it's not perfect yet I don't

1002
00:48:46,420 --> 00:48:50,350
think so so I liked what Benjamin was

1003
00:48:48,790 --> 00:48:52,990
saying this morning that we shouldn't

1004
00:48:50,350 --> 00:48:55,779
complain that things were much harder

1005
00:48:52,990 --> 00:48:57,520
back in the days and that we should be

1006
00:48:55,780 --> 00:49:01,780
looking forward to how we can improve

1007
00:48:57,520 --> 00:49:04,360
things so um to end this talk I just

1008
00:49:01,780 --> 00:49:06,250
want to raise a bit of awareness I'm I'm

1009
00:49:04,360 --> 00:49:10,180
actually quite happy that lately there

1010
00:49:06,250 --> 00:49:12,310
seemed to be a sway a shift towards open

1011
00:49:10,180 --> 00:49:14,109
source firmware so a lot of security

1012
00:49:12,310 --> 00:49:15,700
researchers are taking a look into

1013
00:49:14,109 --> 00:49:18,220
firmware and there's a lot of

1014
00:49:15,700 --> 00:49:21,790
initiatives to actually build firmware

1015
00:49:18,220 --> 00:49:25,740
open source so well we already have open

1016
00:49:21,790 --> 00:49:27,670
source OSS and if you see the like

1017
00:49:25,740 --> 00:49:31,868
attackers how they have a moving day

1018
00:49:27,670 --> 00:49:35,980
it's been like a race down to to the

1019
00:49:31,869 --> 00:49:38,440
bottom of the machine so to speak so I

1020
00:49:35,980 --> 00:49:40,060
think with the more firmware attacks we

1021
00:49:38,440 --> 00:49:41,560
can benefit from actually having these

1022
00:49:40,060 --> 00:49:43,960
kind of open source platforms and

1023
00:49:41,560 --> 00:49:45,730
transparency and well knowing what's

1024
00:49:43,960 --> 00:49:48,460
happening because we can only defend

1025
00:49:45,730 --> 00:49:50,830
against the things we can measure or

1026
00:49:48,460 --> 00:49:54,250
guarantee so security by obscurity is

1027
00:49:50,830 --> 00:49:56,980
not really gonna cut it so on that happy

1028
00:49:54,250 --> 00:49:58,690
note I'll finish my talk and thank you

1029
00:49:56,980 --> 00:50:01,290
for your attention I'll be happy to take

1030
00:49:58,690 --> 00:50:08,760
any questions now

1031
00:50:01,290 --> 00:50:08,759
[Applause]

