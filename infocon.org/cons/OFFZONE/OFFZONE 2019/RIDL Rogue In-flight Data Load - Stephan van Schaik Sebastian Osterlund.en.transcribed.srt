1
00:00:04,460 --> 00:00:09,620
okay welcome everyone my name is Bosnia

2
00:00:07,919 --> 00:00:12,660
saloon and this is Stefan first hike

3
00:00:09,620 --> 00:00:14,790
hello today I'm going to we are going to

4
00:00:12,660 --> 00:00:18,119
talk about riddle and organ flight data

5
00:00:14,790 --> 00:00:20,340
load so you might have seen it in the

6
00:00:18,119 --> 00:00:22,340
news new speculative execution berkeley

7
00:00:20,340 --> 00:00:27,240
zeta for mental ship's internal buffers

8
00:00:22,340 --> 00:00:29,220
this is another one other one so this

9
00:00:27,240 --> 00:00:31,709
has been in the news and yes attacks or

10
00:00:29,220 --> 00:00:34,890
also sometimes pacific Lea's riddle and

11
00:00:31,710 --> 00:00:37,380
fallout but before I can actually start

12
00:00:34,890 --> 00:00:38,879
talking about what nds attacks are I

13
00:00:37,380 --> 00:00:40,140
want to give you a bit of a background

14
00:00:38,879 --> 00:00:43,710
so I want to talk a bit about cache

15
00:00:40,140 --> 00:00:46,620
attacks first so at the top we have four

16
00:00:43,710 --> 00:00:48,239
CPU registers in the CPU and below we

17
00:00:46,620 --> 00:00:52,078
have like our main memory and this

18
00:00:48,239 --> 00:00:54,480
storage and a big problem is that the

19
00:00:52,079 --> 00:00:56,430
CPU registers are very fast but there

20
00:00:54,480 --> 00:00:58,169
are very few of them whereas what main

21
00:00:56,430 --> 00:01:00,090
memory and destroy register they're huge

22
00:00:58,170 --> 00:01:03,239
like usually gigabytes terabytes

23
00:01:00,090 --> 00:01:05,339
nowadays but you're super slow so one

24
00:01:03,239 --> 00:01:07,259
solution to overcome this is to put

25
00:01:05,339 --> 00:01:09,830
caches in between so smaller pieces of

26
00:01:07,260 --> 00:01:12,510
memory that are faster than main memory

27
00:01:09,830 --> 00:01:14,369
so this is what you see in the error so

28
00:01:12,510 --> 00:01:16,380
and the more up you go the smaller and

29
00:01:14,369 --> 00:01:19,680
faster this the lower you go the large

30
00:01:16,380 --> 00:01:21,750
and slow edges and a very specific

31
00:01:19,680 --> 00:01:25,290
terminology in cache attacks are like

32
00:01:21,750 --> 00:01:27,720
cache misses and gas hits so if you miss

33
00:01:25,290 --> 00:01:29,939
a memory load then it's called a cache

34
00:01:27,720 --> 00:01:31,979
miss if it's in one of the caches it's

35
00:01:29,939 --> 00:01:33,270
called a cache hit and it's exactly this

36
00:01:31,979 --> 00:01:35,700
time in difference that we're going to

37
00:01:33,270 --> 00:01:37,920
use for cache attack so what does a

38
00:01:35,700 --> 00:01:39,119
cache attack look like so for this

39
00:01:37,920 --> 00:01:42,229
presentation I'm going to talk about

40
00:01:39,119 --> 00:01:45,780
flushing reload so you have three stages

41
00:01:42,229 --> 00:01:48,360
at the flush part the victim and reload

42
00:01:45,780 --> 00:01:51,149
and an attacker usually allocates a

43
00:01:48,360 --> 00:01:53,340
proper way so the first step that the

44
00:01:51,149 --> 00:01:55,140
attacker does is the flush tap in which

45
00:01:53,340 --> 00:01:57,659
case on the attacker will basically

46
00:01:55,140 --> 00:02:00,240
flush every entry in the proper way and

47
00:01:57,659 --> 00:02:02,009
form the cache such as this on main

48
00:02:00,240 --> 00:02:03,658
memory and what this means is that the

49
00:02:02,009 --> 00:02:06,360
entries in the probe array will now be

50
00:02:03,659 --> 00:02:08,970
slow to access then the victim once so

51
00:02:06,360 --> 00:02:11,819
the victim for instance accesses a table

52
00:02:08,970 --> 00:02:13,410
using the secret as an index and for

53
00:02:11,819 --> 00:02:15,269
instance it's the third entry here that

54
00:02:13,410 --> 00:02:17,090
contains the secrets now what can you

55
00:02:15,270 --> 00:02:20,430
attack or do the attacker can do we like

56
00:02:17,090 --> 00:02:22,710
attack now and he can just access every

57
00:02:20,430 --> 00:02:25,560
entry first entry is from DM so it's

58
00:02:22,710 --> 00:02:28,230
slow second entry from d1 so it's slow

59
00:02:25,560 --> 00:02:31,500
third entry is from the cache so he

60
00:02:28,230 --> 00:02:34,769
knows which entry was used by the victim

61
00:02:31,500 --> 00:02:37,550
so back in 2018 you might have seen Mel

62
00:02:34,770 --> 00:02:40,080
done inspector and after that foreshadow

63
00:02:37,550 --> 00:02:41,790
so these are previous attacks and for

64
00:02:40,080 --> 00:02:43,950
this part I'm going to talk a bit about

65
00:02:41,790 --> 00:02:47,400
Melton because it's more related to

66
00:02:43,950 --> 00:02:49,980
riddle so what does a meltdown attack

67
00:02:47,400 --> 00:02:52,170
look like so it's very similar to flush

68
00:02:49,980 --> 00:02:55,619
wheeler detects so basically you

69
00:02:52,170 --> 00:02:57,920
allocate a program a and what changes is

70
00:02:55,620 --> 00:03:00,180
basically the part before reloading so

71
00:02:57,920 --> 00:03:02,250
what happens now is that we have a

72
00:03:00,180 --> 00:03:03,930
victim and ok is the kernel that leaks

73
00:03:02,250 --> 00:03:06,450
some excesses some kernel address and

74
00:03:03,930 --> 00:03:08,130
what happens is that um this kernel data

75
00:03:06,450 --> 00:03:10,859
is now in the level 1 d cache when it

76
00:03:08,130 --> 00:03:12,570
does that so now we do the flush part

77
00:03:10,860 --> 00:03:14,160
again so we flush the proper way to make

78
00:03:12,570 --> 00:03:16,859
sure that all the entries are slow to

79
00:03:14,160 --> 00:03:18,299
access and now we do the meltdown part

80
00:03:16,860 --> 00:03:20,340
and the interesting part about meltdown

81
00:03:18,300 --> 00:03:23,070
is that basically the access a kernel

82
00:03:20,340 --> 00:03:24,660
address and which is now in the left on

83
00:03:23,070 --> 00:03:27,570
D cache and they do this speculatively

84
00:03:24,660 --> 00:03:30,720
and then they basically use that address

85
00:03:27,570 --> 00:03:33,060
to access as an index to access the

86
00:03:30,720 --> 00:03:35,580
proper way so now that can leak the

87
00:03:33,060 --> 00:03:37,530
secret by loading an entry in the proper

88
00:03:35,580 --> 00:03:40,110
way now to do the fourth step which is

89
00:03:37,530 --> 00:03:42,120
reloading so the access every entry

90
00:03:40,110 --> 00:03:44,730
first one is flow second one is flow

91
00:03:42,120 --> 00:03:46,230
third one is fast and what this means is

92
00:03:44,730 --> 00:03:49,560
that the byte that actually leaked from

93
00:03:46,230 --> 00:03:53,179
the kernel address is bytes 0 X 3 for

94
00:03:49,560 --> 00:03:56,400
instance so how did the mitigate this

95
00:03:53,180 --> 00:03:58,140
they're different mitigation so a few of

96
00:03:56,400 --> 00:04:01,560
the proposed mitigation czar array index

97
00:03:58,140 --> 00:04:03,540
masking so masking for Spector and for

98
00:04:01,560 --> 00:04:05,610
shadow we don't really care about this

99
00:04:03,540 --> 00:04:07,410
about those for this presentation we

100
00:04:05,610 --> 00:04:10,200
covered more about kernel page level

101
00:04:07,410 --> 00:04:10,829
isolation and so what does it so what

102
00:04:10,200 --> 00:04:14,070
does that look like

103
00:04:10,830 --> 00:04:16,560
so before meltdown

104
00:04:14,070 --> 00:04:18,870
we just had one process space so we had

105
00:04:16,560 --> 00:04:20,940
the user space program and the kernel in

106
00:04:18,870 --> 00:04:23,910
the same memory address space layout and

107
00:04:20,940 --> 00:04:26,130
the problem is with meltdown you can Li

108
00:04:23,910 --> 00:04:27,800
kernel data from just by accessing

109
00:04:26,130 --> 00:04:30,000
virtual addresses speculatively

110
00:04:27,800 --> 00:04:32,820
so what's the solution you basically

111
00:04:30,000 --> 00:04:35,090
introduce to address spaces one without

112
00:04:32,820 --> 00:04:37,409
the kernel and one with the kernel and

113
00:04:35,090 --> 00:04:39,179
basically once you're in user mode you

114
00:04:37,410 --> 00:04:42,690
basically don't have any access to the

115
00:04:39,180 --> 00:04:45,300
kernel addresses so now we have a system

116
00:04:42,690 --> 00:04:48,630
with all the mitigations in place which

117
00:04:45,300 --> 00:04:53,070
looks like this so ever intel core i7

118
00:04:48,630 --> 00:04:54,870
700 800 x sky like X CPU so that's what

119
00:04:53,070 --> 00:04:57,599
the first line shows we see that it's

120
00:04:54,870 --> 00:04:59,669
were novo for all these books and if you

121
00:04:57,600 --> 00:05:01,620
look at the the mitigations all the

122
00:04:59,669 --> 00:05:06,659
mitigations are actually going to be in

123
00:05:01,620 --> 00:05:08,430
place and of course there's also assist

124
00:05:06,660 --> 00:05:09,810
devices system CPU foreign abilities

125
00:05:08,430 --> 00:05:12,990
which also shows that all the

126
00:05:09,810 --> 00:05:14,520
mitigations are in place so the question

127
00:05:12,990 --> 00:05:17,490
is of course what can we still do is an

128
00:05:14,520 --> 00:05:19,229
attacker to search assistant well here

129
00:05:17,490 --> 00:05:20,970
we see that's a - a shadow so if you

130
00:05:19,229 --> 00:05:22,950
normally access it as a normal user you

131
00:05:20,970 --> 00:05:24,960
get permission denied but if you access

132
00:05:22,950 --> 00:05:27,599
it as root you can actually for instance

133
00:05:24,960 --> 00:05:30,239
see the first line being the hash of the

134
00:05:27,600 --> 00:05:32,280
password of the root account and what we

135
00:05:30,240 --> 00:05:34,710
show here is a riddle program just

136
00:05:32,280 --> 00:05:37,710
leaking the same hash by continuously

137
00:05:34,710 --> 00:05:39,390
running the passwd program and this is

138
00:05:37,710 --> 00:05:42,719
just as a normal user so this is

139
00:05:39,390 --> 00:05:44,250
something you shouldn't be able to do so

140
00:05:42,720 --> 00:05:46,229
meet welcome flight data loader will

141
00:05:44,250 --> 00:05:47,760
it's a new class of speculative

142
00:05:46,229 --> 00:05:50,640
execution attacks that knows no

143
00:05:47,760 --> 00:05:51,060
boundaries and to show that knows no

144
00:05:50,640 --> 00:05:52,800
boundaries

145
00:05:51,060 --> 00:05:54,840
first I'm going to talk about previous

146
00:05:52,800 --> 00:05:58,260
levels which are just a social construct

147
00:05:54,840 --> 00:06:00,810
so what we show with real is that we can

148
00:05:58,260 --> 00:06:02,460
leak between hardware threats that can

149
00:06:00,810 --> 00:06:05,039
will actually leak across other security

150
00:06:02,460 --> 00:06:08,130
domains and yes we can so we can leak

151
00:06:05,039 --> 00:06:12,000
from the kernel for across VMs from the

152
00:06:08,130 --> 00:06:13,680
hypervisor and from SDX enclaves and we

153
00:06:12,000 --> 00:06:16,890
leak across all security domains and

154
00:06:13,680 --> 00:06:18,630
more another question that's important

155
00:06:16,890 --> 00:06:20,909
here is can actually leak from the web

156
00:06:18,630 --> 00:06:23,280
browser so in the web class and the

157
00:06:20,910 --> 00:06:25,229
answer is again yes we can so we

158
00:06:23,280 --> 00:06:26,700
reproduce riddle and Mozilla Firefox for

159
00:06:25,229 --> 00:06:28,229
instance and this shows that we actually

160
00:06:26,700 --> 00:06:31,590
have no need for any special

161
00:06:28,229 --> 00:06:34,830
instructions so we leak across security

162
00:06:31,590 --> 00:06:36,060
domains and in the browser another

163
00:06:34,830 --> 00:06:38,370
social construct here are memory

164
00:06:36,060 --> 00:06:39,300
addresses so previous attacks are

165
00:06:38,370 --> 00:06:40,740
meltdown as

166
00:06:39,300 --> 00:06:43,290
the first out of the show that we can

167
00:06:40,740 --> 00:06:46,050
specifically and speculatively leaked

168
00:06:43,290 --> 00:06:49,140
from addresses our mitigation efforts

169
00:06:46,050 --> 00:06:52,860
basically focus on isolating or masking

170
00:06:49,140 --> 00:06:54,870
these addresses because of that and so

171
00:06:52,860 --> 00:06:56,310
to give you some examples so Spector I'm

172
00:06:54,870 --> 00:06:58,410
sure that you can access out-of-band

173
00:06:56,310 --> 00:07:00,510
addresses meltdown shows that you can

174
00:06:58,410 --> 00:07:03,030
leak kernel data just from virtual

175
00:07:00,510 --> 00:07:04,349
addresses from the kernel determine and

176
00:07:03,030 --> 00:07:07,530
foreshadow shows that you can actually

177
00:07:04,350 --> 00:07:09,420
leak from physical addresses and so what

178
00:07:07,530 --> 00:07:12,030
our solutions to that we master way

179
00:07:09,420 --> 00:07:13,980
index to limit the address range that

180
00:07:12,030 --> 00:07:15,479
you can access for Specter and from

181
00:07:13,980 --> 00:07:17,400
meltdown we simply unmapped the kernel

182
00:07:15,480 --> 00:07:18,900
addresses I for foreshadow we actually

183
00:07:17,400 --> 00:07:22,950
have to invalidate the physical error

184
00:07:18,900 --> 00:07:25,530
since and page table so previous attacks

185
00:07:22,950 --> 00:07:27,180
they exploit addressing and that means

186
00:07:25,530 --> 00:07:28,890
that the mitigation efforts are

187
00:07:27,180 --> 00:07:32,040
currently focuses to focus on just

188
00:07:28,890 --> 00:07:33,570
isolating or masking these addresses and

189
00:07:32,040 --> 00:07:35,670
riddle on the other hand it does not

190
00:07:33,570 --> 00:07:37,950
depend on addressing at all so what this

191
00:07:35,670 --> 00:07:40,340
means is that the by process all address

192
00:07:37,950 --> 00:07:42,539
based security checks and this is

193
00:07:40,340 --> 00:07:45,900
actually the reason why will was hard to

194
00:07:42,540 --> 00:07:48,870
mitigate so one question is of course

195
00:07:45,900 --> 00:07:51,659
what CPUs does little effect so we

196
00:07:48,870 --> 00:07:55,290
bought Intel and AMD CPUs from every

197
00:07:51,660 --> 00:07:56,940
generation since 2008 and of course we

198
00:07:55,290 --> 00:07:59,790
opposed PC student so we send the

199
00:07:56,940 --> 00:08:02,790
invoices to a professor who gladly pays

200
00:07:59,790 --> 00:08:04,590
for our system and this is what it looks

201
00:08:02,790 --> 00:08:06,330
like so we build an IKEA rack with all

202
00:08:04,590 --> 00:08:08,310
the hardware that we bought all the

203
00:08:06,330 --> 00:08:11,669
motherboards a mess of line cables

204
00:08:08,310 --> 00:08:14,760
connected and we test all over nobility

205
00:08:11,670 --> 00:08:16,140
on all of these CPUs and what we find is

206
00:08:14,760 --> 00:08:19,560
that will actually work some all

207
00:08:16,140 --> 00:08:21,120
mainstream Intel CPUs since 2008 so

208
00:08:19,560 --> 00:08:25,170
these are the CPUs we actually tested

209
00:08:21,120 --> 00:08:27,090
the film then at some point we looked at

210
00:08:25,170 --> 00:08:29,010
the Intel website and we saw that they

211
00:08:27,090 --> 00:08:32,669
were announcing the ninth generation of

212
00:08:29,010 --> 00:08:35,939
CPUs so also known as coffee like

213
00:08:32,669 --> 00:08:39,000
refresh and we found the 9900 k very

214
00:08:35,940 --> 00:08:40,920
interesting so because it has like in

215
00:08:39,000 --> 00:08:42,390
silicon mitigations again smell down and

216
00:08:40,919 --> 00:08:44,039
foreshadow so this means that they now

217
00:08:42,390 --> 00:08:47,580
try to solve this at a hardware level at

218
00:08:44,039 --> 00:08:49,459
until rather than a software level so we

219
00:08:47,580 --> 00:08:51,840
decided to actually buy the CPU and

220
00:08:49,460 --> 00:08:52,370
again since the invoices through a

221
00:08:51,840 --> 00:08:55,279
professor

222
00:08:52,370 --> 00:08:57,860
repor PhD students and we got it today

223
00:08:55,279 --> 00:09:01,689
after we submitted our paper to as in

224
00:08:57,860 --> 00:09:04,190
the Auckland as we academics usually do

225
00:09:01,690 --> 00:09:07,160
so we tested on these and we found that

226
00:09:04,190 --> 00:09:10,190
it's also vulnerable on the 9900 K as

227
00:09:07,160 --> 00:09:11,390
you can see at the top and then of

228
00:09:10,190 --> 00:09:14,330
course an important question is like

229
00:09:11,390 --> 00:09:16,370
okay what about AMD so we also tried to

230
00:09:14,330 --> 00:09:19,730
reproduce it on AMD and we found that

231
00:09:16,370 --> 00:09:21,620
real does not actually affect AMD and in

232
00:09:19,730 --> 00:09:23,690
the also made an official statement

233
00:09:21,620 --> 00:09:26,810
about it is that we lost not affected

234
00:09:23,690 --> 00:09:29,089
that end is not affected by real and so

235
00:09:26,810 --> 00:09:31,849
did arm also make a statement about this

236
00:09:29,089 --> 00:09:34,580
so we tested on these threes CPUs from

237
00:09:31,850 --> 00:09:37,580
AMD and they were also not affected by

238
00:09:34,580 --> 00:09:40,010
writable so a riddle insight it runs

239
00:09:37,580 --> 00:09:44,330
great on Intel but where are we actually

240
00:09:40,010 --> 00:09:47,569
leaking from so this is a part of the

241
00:09:44,330 --> 00:09:51,020
diagram I made so here you can see the

242
00:09:47,570 --> 00:09:53,150
Intel skylake CPU and more specifically

243
00:09:51,020 --> 00:09:54,829
if you look at the highlighted boxes you

244
00:09:53,150 --> 00:09:56,959
see the caches so previous attacks they

245
00:09:54,830 --> 00:09:59,690
had it a bit easy and they just leaked

246
00:09:56,959 --> 00:10:01,760
from these caches and the thing with

247
00:09:59,690 --> 00:10:03,380
caches is that they're well documented

248
00:10:01,760 --> 00:10:06,470
and well understood now so we have been

249
00:10:03,380 --> 00:10:09,470
studying them for more than more than

250
00:10:06,470 --> 00:10:10,880
the past decade but the problem is that

251
00:10:09,470 --> 00:10:13,100
will does not actually leak from these

252
00:10:10,880 --> 00:10:15,800
caches so what else is there actually to

253
00:10:13,100 --> 00:10:17,510
league form so there are other internal

254
00:10:15,800 --> 00:10:19,660
CPU buffers so for instance lightful

255
00:10:17,510 --> 00:10:23,660
buffer the store and forward buffer and

256
00:10:19,660 --> 00:10:25,579
load ports and there's also more servers

257
00:10:23,660 --> 00:10:27,469
also for instance and cache memory that

258
00:10:25,580 --> 00:10:30,589
is partially handled by the memory

259
00:10:27,470 --> 00:10:32,209
controller and what we show with realize

260
00:10:30,589 --> 00:10:35,330
that we can actually leak from various

261
00:10:32,209 --> 00:10:37,099
internal CPU buffers so riddle is

262
00:10:35,330 --> 00:10:39,980
actually just a class of speculative

263
00:10:37,100 --> 00:10:42,170
execution attacks that is also known by

264
00:10:39,980 --> 00:10:46,279
Intel as micro architectural data

265
00:10:42,170 --> 00:10:47,870
sampling or MDS so for this talk let's

266
00:10:46,279 --> 00:10:51,320
focus on just one particular instance

267
00:10:47,870 --> 00:10:53,089
which is mindful buffers so what we

268
00:10:51,320 --> 00:10:55,370
first it is here's an excerpt from the

269
00:10:53,089 --> 00:10:57,529
Intel manual and we first read the

270
00:10:55,370 --> 00:10:59,390
manuals and what we saw there's like

271
00:10:57,529 --> 00:11:01,070
some references to these internal CPU

272
00:10:59,390 --> 00:11:03,410
buffers but there is no further

273
00:11:01,070 --> 00:11:05,260
explanation so where would you even

274
00:11:03,410 --> 00:11:06,850
start

275
00:11:05,260 --> 00:11:08,800
that's why we started reading the

276
00:11:06,850 --> 00:11:10,810
patterns in stats so we read a lot of

277
00:11:08,800 --> 00:11:12,849
patterns here's a overview of all the

278
00:11:10,810 --> 00:11:14,410
patterns that I had to print out

279
00:11:12,850 --> 00:11:17,170
actually we do figure these things out

280
00:11:14,410 --> 00:11:20,290
and so today I can actually tell you a

281
00:11:17,170 --> 00:11:21,670
bit more about these things so the

282
00:11:20,290 --> 00:11:22,959
question is of course what are these

283
00:11:21,670 --> 00:11:24,969
mindful buffers so you might not

284
00:11:22,960 --> 00:11:26,650
actually have heard of them so they are

285
00:11:24,970 --> 00:11:29,130
actually essential buffers so you have

286
00:11:26,650 --> 00:11:31,930
two caches and the execution units and

287
00:11:29,130 --> 00:11:34,870
the landfill buffers themselves are a

288
00:11:31,930 --> 00:11:36,640
central buffer between these execution

289
00:11:34,870 --> 00:11:39,580
units and the caches to improve memory

290
00:11:36,640 --> 00:11:40,930
to boots and in Intel CPUs they have the

291
00:11:39,580 --> 00:11:42,790
following wall so they allow for a

292
00:11:40,930 --> 00:11:44,739
synchronous memory request load

293
00:11:42,790 --> 00:11:47,230
squashing white combining and they also

294
00:11:44,740 --> 00:11:48,880
allow for an cache memory and for this

295
00:11:47,230 --> 00:11:50,380
talk I'm just going to focus a bit on

296
00:11:48,880 --> 00:11:54,250
the first one circuit a synchronous

297
00:11:50,380 --> 00:11:57,160
memory requests so if your CPU designer

298
00:11:54,250 --> 00:11:58,900
computer architect you very much

299
00:11:57,160 --> 00:12:01,089
interested in improving the memory to

300
00:11:58,900 --> 00:12:03,670
put so your your question is well what

301
00:12:01,090 --> 00:12:06,100
should I do in the cache miss so what

302
00:12:03,670 --> 00:12:08,829
happens you in a naive way is you send

303
00:12:06,100 --> 00:12:10,990
out a memory request and you'd like a

304
00:12:08,830 --> 00:12:12,580
load in a story and you wait for the

305
00:12:10,990 --> 00:12:14,920
data to come back from the memory if

306
00:12:12,580 --> 00:12:16,240
it's not in the cache and what this

307
00:12:14,920 --> 00:12:17,829
means is that you basically block

308
00:12:16,240 --> 00:12:21,220
everything else in the system basically

309
00:12:17,830 --> 00:12:23,860
you drop all the work and do nothing

310
00:12:21,220 --> 00:12:25,750
else until you actually get the data so

311
00:12:23,860 --> 00:12:27,490
what's the solution and I love bees

312
00:12:25,750 --> 00:12:28,900
actually keep track of the memory

313
00:12:27,490 --> 00:12:31,840
address so you send out the memory

314
00:12:28,900 --> 00:12:34,030
request and if you see that you have a

315
00:12:31,840 --> 00:12:36,790
cache miss you basically allocate an

316
00:12:34,030 --> 00:12:38,770
entry in the line for buffers and that's

317
00:12:36,790 --> 00:12:41,079
where you then store the address of the

318
00:12:38,770 --> 00:12:42,400
memory you're waiting for and in the

319
00:12:41,080 --> 00:12:43,930
meanwhile you can do other things so you

320
00:12:42,400 --> 00:12:46,329
can serve order loads and stores and you

321
00:12:43,930 --> 00:12:48,250
can execute any other instructions while

322
00:12:46,330 --> 00:12:49,630
you're waiting for the memory to the

323
00:12:48,250 --> 00:12:52,090
action for the actual data to come to

324
00:12:49,630 --> 00:12:53,830
the CPU and then at some point this

325
00:12:52,090 --> 00:12:57,250
memory request will eventually complete

326
00:12:53,830 --> 00:12:58,870
and you have two data and the

327
00:12:57,250 --> 00:13:01,440
interesting part for real is basically

328
00:12:58,870 --> 00:13:04,990
allocation of an alert out of the entry

329
00:13:01,440 --> 00:13:07,030
so what it means is that if you don't

330
00:13:04,990 --> 00:13:09,340
zero out the data that's in the LSB and

331
00:13:07,030 --> 00:13:11,319
my it may actually contain data from the

332
00:13:09,340 --> 00:13:14,890
previous loads and this is exactly the

333
00:13:11,320 --> 00:13:17,780
problem that riddle exports so we have a

334
00:13:14,890 --> 00:13:20,120
bunch of experiments and the paper

335
00:13:17,780 --> 00:13:22,130
but the conclusion of these experiences

336
00:13:20,120 --> 00:13:26,080
what we found is that or primary real

337
00:13:22,130 --> 00:13:26,080
instance leaks from wine for reference

338
00:13:26,350 --> 00:13:34,130
okay thank you very much Stefan so now

339
00:13:31,280 --> 00:13:37,189
you've got a bit of background on riddle

340
00:13:34,130 --> 00:13:39,020
and these underlying buffers so let's

341
00:13:37,190 --> 00:13:41,270
have a more practical look at what we

342
00:13:39,020 --> 00:13:43,880
actually can do with this riddle attacks

343
00:13:41,270 --> 00:13:47,900
what's practical at attack attempts can

344
00:13:43,880 --> 00:13:49,820
we do so well you know now is that we

345
00:13:47,900 --> 00:13:51,199
can leak in flight data right Stefan

346
00:13:49,820 --> 00:13:53,060
told you about the line fill buffers and

347
00:13:51,200 --> 00:13:56,360
basically all day that goes through the

348
00:13:53,060 --> 00:13:59,540
line for buffers so let's just get some

349
00:13:56,360 --> 00:14:01,340
sensitive data in flight so we started

350
00:13:59,540 --> 00:14:03,620
thinking about how can we as a normal

351
00:14:01,340 --> 00:14:06,050
user get sensitive data in flight on a

352
00:14:03,620 --> 00:14:08,210
normal UNIX system and what we came up

353
00:14:06,050 --> 00:14:10,550
with this that you can invoke the

354
00:14:08,210 --> 00:14:13,100
password utility to change your password

355
00:14:10,550 --> 00:14:15,349
and this has to read to read the EDC

356
00:14:13,100 --> 00:14:17,540
shadow file which contains the password

357
00:14:15,350 --> 00:14:21,650
hashes of all user and especially of the

358
00:14:17,540 --> 00:14:24,140
root user so what we also can do is

359
00:14:21,650 --> 00:14:27,890
control the affinity so we're a process

360
00:14:24,140 --> 00:14:31,069
scheduled using the task set utility so

361
00:14:27,890 --> 00:14:33,650
we can let two programs be co-located

362
00:14:31,070 --> 00:14:37,280
share the same hyper threads there for

363
00:14:33,650 --> 00:14:40,370
sharing the same line for buffers so

364
00:14:37,280 --> 00:14:44,630
what we want to do is leap repeatedly

365
00:14:40,370 --> 00:14:46,370
invoke the password utility and execute

366
00:14:44,630 --> 00:14:48,050
a riddle attack from the shared hyper

367
00:14:46,370 --> 00:14:51,070
tread with that one so that we actually

368
00:14:48,050 --> 00:14:53,599
can get the contents of the EDC shadow

369
00:14:51,070 --> 00:14:55,850
well turned out in practice this is not

370
00:14:53,600 --> 00:14:57,680
so easy so what you have to do is either

371
00:14:55,850 --> 00:14:59,840
synchronize so that you leak at the

372
00:14:57,680 --> 00:15:02,930
exact point when the data is in flight

373
00:14:59,840 --> 00:15:07,400
or you have to do some post-processing

374
00:15:02,930 --> 00:15:08,689
so first of all synchronizing a we

375
00:15:07,400 --> 00:15:10,040
didn't find any way to do this

376
00:15:08,690 --> 00:15:12,920
synchronization because you can't change

377
00:15:10,040 --> 00:15:15,469
the binary as an unprivileged user so we

378
00:15:12,920 --> 00:15:17,510
just have to do supports processing but

379
00:15:15,470 --> 00:15:19,040
note that we can actually repeat the

380
00:15:17,510 --> 00:15:22,520
measurement we can invoke the password

381
00:15:19,040 --> 00:15:24,020
utility many many times so what we do is

382
00:15:22,520 --> 00:15:26,810
repeated many times and station

383
00:15:24,020 --> 00:15:29,660
measurements together so we have a way

384
00:15:26,810 --> 00:15:31,369
of getting data in flight

385
00:15:29,660 --> 00:15:33,380
well if we can leak the stuff with

386
00:15:31,370 --> 00:15:37,430
riddle which we'll explain now

387
00:15:33,380 --> 00:15:39,470
so here is what our fiddle attacker

388
00:15:37,430 --> 00:15:41,089
program looks like so first like Stefan

389
00:15:39,470 --> 00:15:44,420
explain you have a flush every load so

390
00:15:41,090 --> 00:15:46,840
the first flash part is simple you evict

391
00:15:44,420 --> 00:15:50,930
everything from the buff from the caches

392
00:15:46,840 --> 00:15:54,290
so that they laid it so that it has to

393
00:15:50,930 --> 00:15:57,229
load everything from memory then in the

394
00:15:54,290 --> 00:15:59,150
actual riddle parts we start a PSX

395
00:15:57,230 --> 00:16:04,100
transaction so that we can suppress a

396
00:15:59,150 --> 00:16:06,069
fault at a later stage so what we do is

397
00:16:04,100 --> 00:16:09,440
just simply read from a nil pointer just

398
00:16:06,070 --> 00:16:11,540
science is really counterintuitive but

399
00:16:09,440 --> 00:16:14,360
since this address translation won't

400
00:16:11,540 --> 00:16:16,550
work we will the speculative execution

401
00:16:14,360 --> 00:16:18,620
will just use in-flight data in the

402
00:16:16,550 --> 00:16:22,640
continuation went continues executing

403
00:16:18,620 --> 00:16:25,340
and by the way this also works for other

404
00:16:22,640 --> 00:16:28,880
addresses that are not mapped so I'll

405
00:16:25,340 --> 00:16:32,210
come back to that a bit later so what we

406
00:16:28,880 --> 00:16:37,040
do is use this value that we leaked as

407
00:16:32,210 --> 00:16:40,670
an offset into our probe array and then

408
00:16:37,040 --> 00:16:42,290
later we simply time every access to do

409
00:16:40,670 --> 00:16:44,630
our probe array and yeah we see the

410
00:16:42,290 --> 00:16:47,689
first one slow second one is slow third

411
00:16:44,630 --> 00:16:51,520
one slow the fourth one is actually fast

412
00:16:47,690 --> 00:16:55,220
so we know that leaked value here is 3

413
00:16:51,520 --> 00:16:58,490
so we can leak data using this program

414
00:16:55,220 --> 00:17:00,910
so a riddle attack so now the next point

415
00:16:58,490 --> 00:17:03,320
is actually filtering the data because

416
00:17:00,910 --> 00:17:06,800
as you might have imagined you get all

417
00:17:03,320 --> 00:17:08,990
the data in that same flight so we liken

418
00:17:06,800 --> 00:17:12,970
it to like drinking from a firehose you

419
00:17:08,990 --> 00:17:16,660
just get all kinds of data spewed at you

420
00:17:12,970 --> 00:17:19,850
so how can we actually filter this data

421
00:17:16,660 --> 00:17:23,120
well in this attack what we want to do

422
00:17:19,849 --> 00:17:24,708
is sleep for e.t.c shadow and typically

423
00:17:23,119 --> 00:17:29,510
the first line in the e.t.c shadow file

424
00:17:24,709 --> 00:17:31,220
is of the root user so and it's always

425
00:17:29,510 --> 00:17:32,480
known that this line starts with the

426
00:17:31,220 --> 00:17:34,880
following characters root and a

427
00:17:32,480 --> 00:17:36,800
semicolon so let's do some pattern

428
00:17:34,880 --> 00:17:40,040
matching here just consider samples

429
00:17:36,800 --> 00:17:41,629
where we actually get start with this

430
00:17:40,040 --> 00:17:44,730
message measurement

431
00:17:41,630 --> 00:17:46,470
so what we do is we start saying okay we

432
00:17:44,730 --> 00:17:48,600
know that we should start only leak

433
00:17:46,470 --> 00:17:50,820
stuff with this prefix then we start

434
00:17:48,600 --> 00:17:52,830
doing measurements here for example to

435
00:17:50,820 --> 00:17:54,030
get the measurement that's start of URL

436
00:17:52,830 --> 00:17:57,020
but that's not consistent with our

437
00:17:54,030 --> 00:17:59,940
previous samples so we discard it

438
00:17:57,020 --> 00:18:02,430
here you see okay the first part matches

439
00:17:59,940 --> 00:18:04,830
and we have some other stuff behind that

440
00:18:02,430 --> 00:18:08,340
so let's consider this next byte as a

441
00:18:04,830 --> 00:18:10,710
candidate by it the next thing we leak

442
00:18:08,340 --> 00:18:12,449
is also something else just discard it

443
00:18:10,710 --> 00:18:14,870
and here we see okay

444
00:18:12,450 --> 00:18:17,400
the first bytes are consistent with our

445
00:18:14,870 --> 00:18:19,830
what we have leaked so far so just take

446
00:18:17,400 --> 00:18:21,750
next byte athletes and so on and so on

447
00:18:19,830 --> 00:18:23,879
you can build up a whole string leak the

448
00:18:21,750 --> 00:18:25,350
actual contents of EDC shadow so now we

449
00:18:23,880 --> 00:18:29,010
have all the things to actually lash

450
00:18:25,350 --> 00:18:30,620
complete attack so yeah what we can do

451
00:18:29,010 --> 00:18:34,140
is leak the root password hash from

452
00:18:30,620 --> 00:18:36,750
privileged user on Linux but let's

453
00:18:34,140 --> 00:18:38,790
extend this a bit this is who cares

454
00:18:36,750 --> 00:18:40,920
about if you can make from like local

455
00:18:38,790 --> 00:18:43,050
user usually don't give anyone access to

456
00:18:40,920 --> 00:18:45,120
your computer anyway maybe you can do it

457
00:18:43,050 --> 00:18:50,310
in a library or something but let's take

458
00:18:45,120 --> 00:18:52,889
it to the cloud so in this attack what

459
00:18:50,310 --> 00:18:56,580
we do is we have a victim VM in a cloud

460
00:18:52,890 --> 00:18:59,010
which we go.look make sure that our

461
00:18:56,580 --> 00:19:02,340
attacker VM is co-located with this

462
00:18:59,010 --> 00:19:04,200
victim VM so that's they actually share

463
00:19:02,340 --> 00:19:07,050
the line fill buffer so typically cloud

464
00:19:04,200 --> 00:19:08,640
providers give you shared high birth

465
00:19:07,050 --> 00:19:11,030
rates with other so nowadays there's

466
00:19:08,640 --> 00:19:15,020
some mitigation is in place for this but

467
00:19:11,030 --> 00:19:18,240
some cloud providers still do this

468
00:19:15,020 --> 00:19:20,190
typically normal VMs run SSH servers

469
00:19:18,240 --> 00:19:24,090
right so you always want to access your

470
00:19:20,190 --> 00:19:26,310
your VMs so what we seem to do is yeah

471
00:19:24,090 --> 00:19:29,399
how can we get the EDC shadow in fly it

472
00:19:26,310 --> 00:19:32,100
so that's its simple idea on an attacker

473
00:19:29,400 --> 00:19:35,520
VM they have a SSH client repeatedly set

474
00:19:32,100 --> 00:19:38,490
up connections to the victim VM which

475
00:19:35,520 --> 00:19:41,610
well we load a TC shadow into the line

476
00:19:38,490 --> 00:19:43,380
fill buffers and well now similar to the

477
00:19:41,610 --> 00:19:46,830
previous track the it's the shadow is in

478
00:19:43,380 --> 00:19:48,630
flight and we can of course link it with

479
00:19:46,830 --> 00:19:52,770
the exact same a riddle programmed as he

480
00:19:48,630 --> 00:19:54,690
had so we have a few more examples of

481
00:19:52,770 --> 00:19:56,729
attacks in our paper so we can

482
00:19:54,690 --> 00:19:59,729
leaked internal CPU data like page

483
00:19:56,729 --> 00:20:02,129
tables breaking ksl R we can also do an

484
00:19:59,729 --> 00:20:03,509
arbitrary Colonel read and make in the

485
00:20:02,129 --> 00:20:04,369
browser so I'll discuss the last two

486
00:20:03,509 --> 00:20:08,190
ones now

487
00:20:04,369 --> 00:20:10,228
so the arbitrary kernel leak so one

488
00:20:08,190 --> 00:20:12,899
thing that you know notice is that you

489
00:20:10,229 --> 00:20:16,470
can actually combine Spector with Radel

490
00:20:12,899 --> 00:20:18,508
so you can use so-called Spector gadgets

491
00:20:16,470 --> 00:20:24,359
to pull data in flight and then reuse

492
00:20:18,509 --> 00:20:26,369
riddle to leak this latest data so what

493
00:20:24,359 --> 00:20:28,139
we can do is train the branch predictor

494
00:20:26,369 --> 00:20:31,769
to allow an arbitrary out-of-bounds read

495
00:20:28,139 --> 00:20:34,590
and yeah so for example in the copied

496
00:20:31,769 --> 00:20:37,499
from user it's possible to do something

497
00:20:34,590 --> 00:20:40,769
like this and this was worked on by

498
00:20:37,499 --> 00:20:43,919
Georgie at Microsoft Research roughly a

499
00:20:40,769 --> 00:20:45,690
year ago so what he did is for another

500
00:20:43,919 --> 00:20:48,119
okay you can call set our limits with an

501
00:20:45,690 --> 00:20:53,460
arbitrary pointer so you can train the

502
00:20:48,119 --> 00:20:55,889
branch predictor so first we train it to

503
00:20:53,460 --> 00:20:59,279
with a valid user pointer so that it

504
00:20:55,889 --> 00:21:01,349
actually goes the expected path and then

505
00:20:59,279 --> 00:21:03,479
at some points we give it an wrong

506
00:21:01,349 --> 00:21:08,340
pointer so a kernel pointer and then we

507
00:21:03,479 --> 00:21:12,509
leak the contents of that data so let's

508
00:21:08,340 --> 00:21:14,220
look at code for the stack so first you

509
00:21:12,509 --> 00:21:15,960
have the attacker starts training it

510
00:21:14,220 --> 00:21:19,529
with calling set our limit with the

511
00:21:15,960 --> 00:21:22,590
valid user pointer call set a limit goes

512
00:21:19,529 --> 00:21:25,529
to copy from user it will take this

513
00:21:22,590 --> 00:21:27,840
branch and copy it from user it's fine

514
00:21:25,529 --> 00:21:30,239
and repeat this a few times to train a

515
00:21:27,840 --> 00:21:33,149
branch predictor and at some point you

516
00:21:30,239 --> 00:21:36,690
give it an invalid address inspect the

517
00:21:33,149 --> 00:21:38,728
execution now this will just space the

518
00:21:36,690 --> 00:21:41,669
CPU will speculate on the value and just

519
00:21:38,729 --> 00:21:43,289
miss speculate at this branch actually

520
00:21:41,669 --> 00:21:45,570
pulling this data into the line fill

521
00:21:43,289 --> 00:21:48,149
buffer this will actually be retired at

522
00:21:45,570 --> 00:21:50,158
some later point but this the data will

523
00:21:48,149 --> 00:21:52,018
definitely be in flight so what you can

524
00:21:50,159 --> 00:21:54,239
do is use a riddle attack and leak this

525
00:21:52,019 --> 00:21:58,169
data so we have an arbitrary a kernel

526
00:21:54,239 --> 00:22:00,239
read and we had attack on the cloud so

527
00:21:58,169 --> 00:22:03,299
for this Lex you still need a local

528
00:22:00,239 --> 00:22:07,249
account on the targets so let's go one

529
00:22:03,299 --> 00:22:07,249
step further to the web browser

530
00:22:08,540 --> 00:22:12,389
so first of all in these kinds of

531
00:22:11,010 --> 00:22:14,280
constrained environments like their

532
00:22:12,390 --> 00:22:17,070
browsers you don't have access to fans

533
00:22:14,280 --> 00:22:19,620
fitch like DSX and you don't have access

534
00:22:17,070 --> 00:22:25,020
to flash instructions that we need for

535
00:22:19,620 --> 00:22:27,449
our flash and reload attack so well for

536
00:22:25,020 --> 00:22:29,730
seal flush it's kind of easy you replace

537
00:22:27,450 --> 00:22:32,160
it with a evict plus reload I won't go

538
00:22:29,730 --> 00:22:33,000
into detail for this now you can read

539
00:22:32,160 --> 00:22:35,910
more about it

540
00:22:33,000 --> 00:22:38,490
but basically you can do the same thing

541
00:22:35,910 --> 00:22:42,540
as flash and reload without needing the

542
00:22:38,490 --> 00:22:44,730
seal flash instruction well we also have

543
00:22:42,540 --> 00:22:46,200
don't have transactions to suppress the

544
00:22:44,730 --> 00:22:48,390
warning when you dereference the null

545
00:22:46,200 --> 00:22:52,140
pointer but as already said you can use

546
00:22:48,390 --> 00:22:55,890
a page like an address that's not mapped

547
00:22:52,140 --> 00:22:58,680
in act at this moment and what we can do

548
00:22:55,890 --> 00:23:00,630
is use demand paging which operating

549
00:22:58,680 --> 00:23:02,910
system feature where patients are

550
00:23:00,630 --> 00:23:09,150
actually mapped in when you access them

551
00:23:02,910 --> 00:23:10,500
for the first time so then the code for

552
00:23:09,150 --> 00:23:11,940
the riddle attack will look something

553
00:23:10,500 --> 00:23:16,590
like this so first you victus

554
00:23:11,940 --> 00:23:19,140
make the caches the buffer and then you

555
00:23:16,590 --> 00:23:21,270
have a new page so called new page which

556
00:23:19,140 --> 00:23:23,370
is demand pages so it's not mapped in at

557
00:23:21,270 --> 00:23:25,740
the address you haven't accessed it yet

558
00:23:23,370 --> 00:23:27,780
and then you do exactly the same thing

559
00:23:25,740 --> 00:23:29,880
as for the other attacks so the

560
00:23:27,780 --> 00:23:34,530
difference is that we don't have tsx

561
00:23:29,880 --> 00:23:37,110
here but to use demand paging well

562
00:23:34,530 --> 00:23:38,550
that's code think it's fairly simple and

563
00:23:37,110 --> 00:23:40,110
what we found out is that we can

564
00:23:38,550 --> 00:23:43,800
generate something similar from

565
00:23:40,110 --> 00:23:45,600
webassembly and i was going to show you

566
00:23:43,800 --> 00:23:47,520
a live demo of this but I couldn't

567
00:23:45,600 --> 00:23:49,020
connect my computer here so we've made

568
00:23:47,520 --> 00:23:51,230
some animations that we have in the

569
00:23:49,020 --> 00:23:51,230
slide

570
00:23:56,340 --> 00:24:01,350
okay there's something wrong with the

571
00:23:58,410 --> 00:24:04,470
demo well last-minute things of course

572
00:24:01,350 --> 00:24:08,090
so let's have a look at the mitigations

573
00:24:04,470 --> 00:24:10,980
that have been proposed for a riddle

574
00:24:08,090 --> 00:24:13,980
story about the demo too bad

575
00:24:10,980 --> 00:24:16,050
well so into propose a few mitigation so

576
00:24:13,980 --> 00:24:18,000
the same trade version of riddle where

577
00:24:16,050 --> 00:24:21,389
you basically don't have hyper trading

578
00:24:18,000 --> 00:24:24,240
it's relatively easy to mitigate so

579
00:24:21,390 --> 00:24:25,830
intel added this feature to the very

580
00:24:24,240 --> 00:24:30,300
instruction to actually flush the

581
00:24:25,830 --> 00:24:31,679
affected buffers if you don't have the

582
00:24:30,300 --> 00:24:33,450
newest microcode update you can use a

583
00:24:31,680 --> 00:24:35,910
number of special assembly snippets to

584
00:24:33,450 --> 00:24:38,400
achieve the same thing so for example

585
00:24:35,910 --> 00:24:40,740
this you can use this if your hypervisor

586
00:24:38,400 --> 00:24:42,510
host hasn't been updated to actually

587
00:24:40,740 --> 00:24:46,440
have the new micro code that does the

588
00:24:42,510 --> 00:24:48,629
modified verb instruction for cross

589
00:24:46,440 --> 00:24:50,340
thread so for the hyper training

590
00:24:48,630 --> 00:24:55,290
instance of riddle it's a bit more

591
00:24:50,340 --> 00:24:57,570
complex because the thing is like if you

592
00:24:55,290 --> 00:24:59,520
have two hyper threads doing things at

593
00:24:57,570 --> 00:25:01,350
the same time it's you have to

594
00:24:59,520 --> 00:25:03,950
synchronize them somehow because you can

595
00:25:01,350 --> 00:25:07,669
just leak anything that's in flight and

596
00:25:03,950 --> 00:25:11,730
so they came up with something like this

597
00:25:07,670 --> 00:25:14,850
as you can see this is a very complex

598
00:25:11,730 --> 00:25:16,740
state diagram of how you should schedule

599
00:25:14,850 --> 00:25:19,260
hyper threading basically what it boils

600
00:25:16,740 --> 00:25:21,870
down to is that hyper threads should

601
00:25:19,260 --> 00:25:22,830
never be in different security domain so

602
00:25:21,870 --> 00:25:24,629
this should always be in the same

603
00:25:22,830 --> 00:25:25,919
security domain so if you have one hyper

604
00:25:24,630 --> 00:25:27,750
threading kernel the other one should

605
00:25:25,920 --> 00:25:29,730
also be in the kernel and it has to wait

606
00:25:27,750 --> 00:25:33,660
to leave the kernel until the other one

607
00:25:29,730 --> 00:25:35,820
is going to leave the kernel so this

608
00:25:33,660 --> 00:25:37,890
looks fairly complex and of course the

609
00:25:35,820 --> 00:25:40,350
overhead might be really high so as far

610
00:25:37,890 --> 00:25:42,420
as I know this hasn't been completely

611
00:25:40,350 --> 00:25:46,050
implemented yet so I've seen some Linux

612
00:25:42,420 --> 00:25:47,730
kernel patches for this but it's it's a

613
00:25:46,050 --> 00:25:50,280
lot of efforts to change the scheduling

614
00:25:47,730 --> 00:25:51,930
policy so at the moment we just

615
00:25:50,280 --> 00:25:54,629
recommend disable hyper threading

616
00:25:51,930 --> 00:25:57,290
because these things have not been

617
00:25:54,630 --> 00:25:57,290
deployed yet

618
00:25:57,930 --> 00:26:03,260
well while reading patents Stephan made

619
00:26:00,990 --> 00:26:06,480
this nice diagram of the whole sky like

620
00:26:03,260 --> 00:26:08,590
microarchitecture and one thing I want

621
00:26:06,480 --> 00:26:10,480
to point out is that okay

622
00:26:08,590 --> 00:26:12,159
we and other researchers found a number

623
00:26:10,480 --> 00:26:15,220
of these buffers that you can leak from

624
00:26:12,160 --> 00:26:18,490
but looking at how complex this is who

625
00:26:15,220 --> 00:26:22,510
knows how many of these other things you

626
00:26:18,490 --> 00:26:24,520
can utilize to actually leak data so

627
00:26:22,510 --> 00:26:26,379
what we see here is basically another

628
00:26:24,520 --> 00:26:30,250
spot mitigation it's not a fundamental

629
00:26:26,380 --> 00:26:32,260
fix and our point here is that these

630
00:26:30,250 --> 00:26:33,760
things need to be fixed because at some

631
00:26:32,260 --> 00:26:36,400
point attackers will start using this

632
00:26:33,760 --> 00:26:39,220
attacks in the wild so we have not

633
00:26:36,400 --> 00:26:42,030
observed anyone using like specter of

634
00:26:39,220 --> 00:26:45,100
meltdown for malicious intent

635
00:26:42,030 --> 00:26:46,690
until now but who knows the code is

636
00:26:45,100 --> 00:26:48,850
readily available for these things an

637
00:26:46,690 --> 00:26:53,590
attacker can just just take them and

638
00:26:48,850 --> 00:26:57,159
crater an exploit so talk a bit about

639
00:26:53,590 --> 00:26:59,800
the disclosure process so this is from

640
00:26:57,160 --> 00:27:02,860
our view points from the information we

641
00:26:59,800 --> 00:27:07,300
got from Intel so this started in

642
00:27:02,860 --> 00:27:10,510
September our group we discovered the

643
00:27:07,300 --> 00:27:14,190
line fill buffer in sense of of MDS or

644
00:27:10,510 --> 00:27:16,600
riddle and reported the info next day

645
00:27:14,190 --> 00:27:18,970
well of course we're academic so we

646
00:27:16,600 --> 00:27:21,040
started writing a paper and submitted as

647
00:27:18,970 --> 00:27:25,990
fast as possible to not get scooped by

648
00:27:21,040 --> 00:27:28,090
anyone else on same per second in totals

649
00:27:25,990 --> 00:27:29,920
that there's three other finders that

650
00:27:28,090 --> 00:27:32,850
also found similar vulnerabilities or

651
00:27:29,920 --> 00:27:39,850
the same vulnerabilities names are here

652
00:27:32,850 --> 00:27:41,620
Georgie Dunn and Vladimir so we

653
00:27:39,850 --> 00:27:43,750
contacted them asked them if they wanted

654
00:27:41,620 --> 00:27:45,189
to collaborate on a paper and Georgie

655
00:27:43,750 --> 00:27:49,240
was the only one that actually wanted to

656
00:27:45,190 --> 00:27:50,890
collaborate on a paper well then we go

657
00:27:49,240 --> 00:27:53,440
further a few months in the dispersion

658
00:27:50,890 --> 00:27:56,440
to say procedure so we agree to

659
00:27:53,440 --> 00:27:59,140
disclosure date of May 14th four days

660
00:27:56,440 --> 00:28:01,240
before disclosure date in the context as

661
00:27:59,140 --> 00:28:02,800
I said oh by the way there's a bunch of

662
00:28:01,240 --> 00:28:06,520
other people who also found related

663
00:28:02,800 --> 00:28:08,649
issues and there's a bunch of people

664
00:28:06,520 --> 00:28:13,389
also working on other papers and it

665
00:28:08,650 --> 00:28:15,220
became a bit of a chaos so here's a word

666
00:28:13,390 --> 00:28:17,590
cloud of all kinds of names of people

667
00:28:15,220 --> 00:28:19,720
that have been involved or found similar

668
00:28:17,590 --> 00:28:20,530
issues so we want to try to credit

669
00:28:19,720 --> 00:28:25,360
everyone

670
00:28:20,530 --> 00:28:26,710
to create this website so if you are one

671
00:28:25,360 --> 00:28:28,330
of these people have found this please

672
00:28:26,710 --> 00:28:30,490
come up to us and talk if you haven't

673
00:28:28,330 --> 00:28:32,980
credit you will try to add you to the

674
00:28:30,490 --> 00:28:37,230
timeline and everything to set make the

675
00:28:32,980 --> 00:28:37,230
point straight that who found everything

676
00:28:37,500 --> 00:28:43,300
besides this well we created this

677
00:28:41,140 --> 00:28:46,270
website with a lot of aim for about this

678
00:28:43,300 --> 00:28:47,490
this is really hyped at the moment right

679
00:28:46,270 --> 00:28:50,770
to create websites for this

680
00:28:47,490 --> 00:28:53,080
vulnerabilities but Stefan wrote a nice

681
00:28:50,770 --> 00:28:54,790
tool that used to be used to verify

682
00:28:53,080 --> 00:28:58,030
their system for all of these

683
00:28:54,790 --> 00:28:59,260
speculative execution at X so for

684
00:28:58,030 --> 00:29:02,290
example you can check if your sisters

685
00:28:59,260 --> 00:29:05,740
vulnerable to meltdown or for shadow or

686
00:29:02,290 --> 00:29:07,629
also for raid oh so it's available on

687
00:29:05,740 --> 00:29:09,850
websites who download it and check your

688
00:29:07,630 --> 00:29:14,020
computer you can get a lot of

689
00:29:09,850 --> 00:29:17,919
information out of this so with that I'd

690
00:29:14,020 --> 00:29:21,790
like to conclude we thought Spectre

691
00:29:17,920 --> 00:29:23,440
meltdown for just one instance of these

692
00:29:21,790 --> 00:29:27,030
attacks and we thought ok maybe we have

693
00:29:23,440 --> 00:29:29,170
fixed this but turned out not to be true

694
00:29:27,030 --> 00:29:30,760
we've discussed a new class of

695
00:29:29,170 --> 00:29:33,910
speculative execution attacks called

696
00:29:30,760 --> 00:29:36,820
riddle we can leak from many of these

697
00:29:33,910 --> 00:29:41,890
internal buffers besides just the caches

698
00:29:36,820 --> 00:29:44,409
that previous attacks did and since our

699
00:29:41,890 --> 00:29:46,540
attacks do not rely on addressing it's

700
00:29:44,410 --> 00:29:48,550
really hard to come up with mitigations

701
00:29:46,540 --> 00:29:51,490
that they're easy to deploy so it needs

702
00:29:48,550 --> 00:29:53,440
more fundamental fixes preferably just

703
00:29:51,490 --> 00:29:57,400
Hardware fixes but of course takes a few

704
00:29:53,440 --> 00:29:59,260
years to deploy in your hardware what we

705
00:29:57,400 --> 00:30:01,330
can do is leak across basically all

706
00:29:59,260 --> 00:30:03,520
security domains and we can even leak

707
00:30:01,330 --> 00:30:07,179
from the browser so malicious attacker

708
00:30:03,520 --> 00:30:09,340
can inject a piece of JavaScript in an

709
00:30:07,180 --> 00:30:13,270
ad or webassembly and try to steal your

710
00:30:09,340 --> 00:30:16,179
data yeah you can follow us on Twitter

711
00:30:13,270 --> 00:30:19,360
Stefan or me or a few SEC's or group and

712
00:30:16,180 --> 00:30:22,890
have a look at mb/s attacks to come for

713
00:30:19,360 --> 00:30:22,889
more information thank you very much

