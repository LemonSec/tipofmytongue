1
00:00:12,230 --> 00:00:18,029
joke Alex welcome thank you for joining

2
00:00:14,969 --> 00:00:19,680
will be speaking about assess and how

3
00:00:18,029 --> 00:00:22,948
the system helps us to find with

4
00:00:19,680 --> 00:00:25,410
vulnerability I am from the PLS studio

5
00:00:22,949 --> 00:00:28,890
my name is silky and we are building the

6
00:00:25,410 --> 00:00:31,380
code static analyzer 40 as you see

7
00:00:28,890 --> 00:00:33,750
applause Paul C sharp in Java languages

8
00:00:31,380 --> 00:00:35,430
we have been doing this for about 10

9
00:00:33,750 --> 00:00:38,190
years we've been writing different

10
00:00:35,430 --> 00:00:42,450
articles about the Czech in open source

11
00:00:38,190 --> 00:00:53,699
projects and sell and promote our

12
00:00:42,450 --> 00:00:56,730
product now why are we here and what am

13
00:00:53,699 --> 00:00:58,858
I going to speak about lately we can say

14
00:00:56,730 --> 00:01:01,260
that the more and more software there

15
00:00:58,859 --> 00:01:03,629
are a lot of different problems one of

16
00:01:01,260 --> 00:01:06,869
the main topics is that the companies

17
00:01:03,629 --> 00:01:08,490
which are developing software they're

18
00:01:06,869 --> 00:01:10,770
usually working with the code they're

19
00:01:08,490 --> 00:01:12,839
testing the code in one way or another

20
00:01:10,770 --> 00:01:14,310
they always have to break their brains

21
00:01:12,840 --> 00:01:17,070
about what should they do with their

22
00:01:14,310 --> 00:01:20,240
increasing volumes of code because old

23
00:01:17,070 --> 00:01:23,309
methods aren't working anymore which

24
00:01:20,240 --> 00:01:26,339
would enable us to keep the code under

25
00:01:23,310 --> 00:01:28,380
control what I mean by that to ensure

26
00:01:26,340 --> 00:01:30,270
the quality and the safety of the code

27
00:01:28,380 --> 00:01:33,600
and to make sure that the code is

28
00:01:30,270 --> 00:01:35,850
reliable would be well functioning and

29
00:01:33,600 --> 00:01:40,110
there will be less glitches and other

30
00:01:35,850 --> 00:01:41,908
problems now people are used to high

31
00:01:40,110 --> 00:01:43,290
quality of the code people are used to

32
00:01:41,909 --> 00:01:46,350
the fact that the code is of high

33
00:01:43,290 --> 00:01:47,909
quality I doubted your issue of any

34
00:01:46,350 --> 00:01:48,750
commercial products which will be

35
00:01:47,909 --> 00:01:50,520
malfunctioning

36
00:01:48,750 --> 00:01:53,549
but there are other problems one of them

37
00:01:50,520 --> 00:01:55,469
is code security

38
00:01:53,549 --> 00:01:57,479
and lately we hear a lot of

39
00:01:55,469 --> 00:02:00,210
conversations about the safety and

40
00:01:57,479 --> 00:02:04,408
security about the software security all

41
00:02:00,210 --> 00:02:06,530
kind of hackers attacks so they we have

42
00:02:04,409 --> 00:02:09,660
a lot of safety and security

43
00:02:06,530 --> 00:02:11,340
requirements for the code so this is the

44
00:02:09,660 --> 00:02:16,410
topic of my presentation how to make a

45
00:02:11,340 --> 00:02:18,780
code safer in one example of for the

46
00:02:16,410 --> 00:02:21,180
increasing volumes of the code with time

47
00:02:18,780 --> 00:02:24,959
I could have taken a different project

48
00:02:21,180 --> 00:02:26,880
with any story of several years were

49
00:02:24,959 --> 00:02:31,290
speaking about the attempts and thousand

50
00:02:26,880 --> 00:02:34,590
times of more code and and the code of

51
00:02:31,290 --> 00:02:36,269
several millions lines and um and the

52
00:02:34,590 --> 00:02:39,569
team has to work with this code maybe

53
00:02:36,269 --> 00:02:42,360
not every day but from time to time it's

54
00:02:39,569 --> 00:02:45,359
a legacy and you have to go back to you

55
00:02:42,360 --> 00:02:48,000
fail legacy code anyway and it's quite

56
00:02:45,360 --> 00:02:49,680
complex and people do not know what to

57
00:02:48,000 --> 00:02:51,959
do with this millions of lines of code

58
00:02:49,680 --> 00:02:54,090
if you are facing the challenge of to

59
00:02:51,959 --> 00:02:58,170
look something into this code or to

60
00:02:54,090 --> 00:03:00,600
refactor it or to make it safer usually

61
00:02:58,170 --> 00:03:05,059
it takes using different tools and

62
00:03:00,600 --> 00:03:08,040
instruments different technologies and

63
00:03:05,060 --> 00:03:10,620
basically as for the increase in

64
00:03:08,040 --> 00:03:14,608
mistakes in the code this is the main

65
00:03:10,620 --> 00:03:17,459
problem the errors include increasing

66
00:03:14,609 --> 00:03:19,980
the more the bigger is the code and the

67
00:03:17,459 --> 00:03:22,139
more examples wave in it there are no

68
00:03:19,980 --> 00:03:23,459
software without mistakes without errors

69
00:03:22,139 --> 00:03:25,680
but there is some kind of different

70
00:03:23,459 --> 00:03:28,530
research based on which we can

71
00:03:25,680 --> 00:03:31,200
understand that the more or the bigger

72
00:03:28,530 --> 00:03:35,370
your program is and more errors you have

73
00:03:31,200 --> 00:03:37,290
it but it's not a linear dependency the

74
00:03:35,370 --> 00:03:40,769
growth is happening more and if you look

75
00:03:37,290 --> 00:03:43,638
at this graph or on day x-axis you can

76
00:03:40,769 --> 00:03:46,319
see a thousand lines of codes and by the

77
00:03:43,639 --> 00:03:48,359
equal client you can see the numbers of

78
00:03:46,319 --> 00:03:52,819
mistakes per thousand lines since an

79
00:03:48,359 --> 00:03:56,329
average growth with increases of data

80
00:03:52,819 --> 00:03:59,280
512 thousand lines and the growth of

81
00:03:56,329 --> 00:04:01,979
mistakes the rate of mistakes is growing

82
00:03:59,280 --> 00:04:04,680
if you have several millions of code

83
00:04:01,979 --> 00:04:05,770
lines the problem is even more expressed

84
00:04:04,680 --> 00:04:08,020
you can have many more

85
00:04:05,770 --> 00:04:11,620
mistakes and the team has maybe not

86
00:04:08,020 --> 00:04:16,410
aware of it somehow the code may be

87
00:04:11,620 --> 00:04:18,610
functioning and very often people who

88
00:04:16,410 --> 00:04:19,959
like our products they say why do we

89
00:04:18,610 --> 00:04:23,020
need your instrument because you where

90
00:04:19,959 --> 00:04:24,820
the project is 15 years old it's working

91
00:04:23,020 --> 00:04:28,690
fine yes we do have some errors but

92
00:04:24,820 --> 00:04:30,070
they're not critical we answer what

93
00:04:28,690 --> 00:04:32,740
shall we do with a new code because you

94
00:04:30,070 --> 00:04:34,240
are supposedly writing a new code and

95
00:04:32,740 --> 00:04:37,840
you're probably making mistakes in it

96
00:04:34,240 --> 00:04:40,720
you're spending money to to debug your

97
00:04:37,840 --> 00:04:42,940
code it makes sense with an old code you

98
00:04:40,720 --> 00:04:45,090
can work more like slow-paced but the

99
00:04:42,940 --> 00:04:48,040
new code you're spending money on it and

100
00:04:45,090 --> 00:04:49,929
basically this is like the whole history

101
00:04:48,040 --> 00:04:52,330
which I'm sharing about the day it's

102
00:04:49,930 --> 00:04:54,490
about the new code freshly written code

103
00:04:52,330 --> 00:05:00,070
but you have to take into account these

104
00:04:54,490 --> 00:05:02,140
stats next would be the couple words

105
00:05:00,070 --> 00:05:06,010
about a very old approach which is

106
00:05:02,140 --> 00:05:10,300
working it's a code review with the code

107
00:05:06,010 --> 00:05:13,000
review previously maybe five or ten

108
00:05:10,300 --> 00:05:16,990
years ago you could even try to look for

109
00:05:13,000 --> 00:05:20,050
errors in your programs and try to fix

110
00:05:16,990 --> 00:05:21,940
them but now it's working less and less

111
00:05:20,050 --> 00:05:23,830
and when a person is given a code if

112
00:05:21,940 --> 00:05:26,440
it's a legacy code it's an older code

113
00:05:23,830 --> 00:05:29,080
you know please look find some errors in

114
00:05:26,440 --> 00:05:32,400
it probably it will be just a waste of

115
00:05:29,080 --> 00:05:36,880
time or it may take indeed a lot of time

116
00:05:32,400 --> 00:05:38,469
and also usually you have to use the

117
00:05:36,880 --> 00:05:40,570
best professionals for the code review

118
00:05:38,470 --> 00:05:43,210
it's considered to be more efficient

119
00:05:40,570 --> 00:05:45,599
which is more costly because you are

120
00:05:43,210 --> 00:05:48,010
using the time of the highly skilled

121
00:05:45,600 --> 00:05:52,900
personnel

122
00:05:48,010 --> 00:05:55,980
so basically as an example just imagine

123
00:05:52,900 --> 00:05:59,260
that you are a qualified programmer and

124
00:05:55,980 --> 00:06:05,740
you get this code for your code review

125
00:05:59,260 --> 00:06:08,320
this code contains a mistake you can

126
00:06:05,740 --> 00:06:11,260
even try to look for this error in in a

127
00:06:08,320 --> 00:06:12,849
matter of several seconds it's a mono

128
00:06:11,260 --> 00:06:17,680
project that's a source code on a

129
00:06:12,850 --> 00:06:19,300
c-sharp it's simple just an illustration

130
00:06:17,680 --> 00:06:21,280
about the code review it's very

131
00:06:19,300 --> 00:06:23,410
difficult to analyze this big of the

132
00:06:21,280 --> 00:06:25,780
code because you cannot find their own

133
00:06:23,410 --> 00:06:27,820
line if you do it around the clock of

134
00:06:25,780 --> 00:06:32,559
course your efficiency level will be

135
00:06:27,820 --> 00:06:36,280
less endless this is the mistake the

136
00:06:32,560 --> 00:06:40,270
error I'm going to close it up and here

137
00:06:36,280 --> 00:06:43,690
the programmer did a misprint he or she

138
00:06:40,270 --> 00:06:46,630
just and a copy pasted it in this

139
00:06:43,690 --> 00:06:50,469
information and it is a matter what on

140
00:06:46,630 --> 00:06:52,780
condition you do use system colors what

141
00:06:50,470 --> 00:06:55,120
will be the value of them change this is

142
00:06:52,780 --> 00:06:57,880
the piece of the code it's the same

143
00:06:55,120 --> 00:07:00,520
value will be assigned maybe this

144
00:06:57,880 --> 00:07:02,560
mistake may not be that critical you

145
00:07:00,520 --> 00:07:05,169
know okay it'll be the same color

146
00:07:02,560 --> 00:07:08,380
assigned for example but as a matter of

147
00:07:05,170 --> 00:07:10,120
fact it's a very indicative example this

148
00:07:08,380 --> 00:07:12,730
kind of mistake could result in more

149
00:07:10,120 --> 00:07:16,870
critical or even fatal error in problems

150
00:07:12,730 --> 00:07:19,840
and the aesthetical analyzer these kind

151
00:07:16,870 --> 00:07:22,420
of tools I'm going to speak about they

152
00:07:19,840 --> 00:07:24,130
enable a very quickly identify these

153
00:07:22,420 --> 00:07:29,500
kind of errors but there is also a

154
00:07:24,130 --> 00:07:33,719
warning which says that with this color

155
00:07:29,500 --> 00:07:33,720
which may be assigned while

156
00:07:41,819 --> 00:07:46,590
yeah speaking about the program is very

157
00:07:44,650 --> 00:07:49,870
highly skilled and qualified

158
00:07:46,590 --> 00:07:51,340
unfortunately they may not be aware of

159
00:07:49,870 --> 00:08:03,039
the full picture

160
00:07:51,340 --> 00:08:04,599
you know people cannot know it all some

161
00:08:03,039 --> 00:08:07,870
people try to improve their code just by

162
00:08:04,599 --> 00:08:09,400
looking browsing it again it's a

163
00:08:07,870 --> 00:08:11,410
specialized instrument which has been

164
00:08:09,400 --> 00:08:15,270
developed by a team by many years any

165
00:08:11,410 --> 00:08:17,949
instrument for that matter will still be

166
00:08:15,270 --> 00:08:22,299
the head and shoulders above the most

167
00:08:17,949 --> 00:08:24,370
skilled human human coder we cannot

168
00:08:22,300 --> 00:08:26,410
cancel the human error and human factor

169
00:08:24,370 --> 00:08:30,250
this underwater part of the iceberg I'm

170
00:08:26,410 --> 00:08:32,560
going to speak about of how can we catch

171
00:08:30,250 --> 00:08:35,110
it how can we identify it what's its

172
00:08:32,559 --> 00:08:38,500
underwater and how can we deal with it

173
00:08:35,110 --> 00:08:40,419
in a contract with it couple words about

174
00:08:38,500 --> 00:08:42,940
the aesthetical analysis of the code

175
00:08:40,419 --> 00:08:45,189
what it's all about know that you may be

176
00:08:42,940 --> 00:08:49,810
aware of it but just again to give you a

177
00:08:45,190 --> 00:08:52,360
refresher here we have quite a humorous

178
00:08:49,810 --> 00:08:54,939
picture it's a cartoon but as a matter

179
00:08:52,360 --> 00:08:58,270
of fact we may have some real problems

180
00:08:54,940 --> 00:09:02,890
within with a wrong code which sometimes

181
00:08:58,270 --> 00:09:05,649
even result in in human human fatalities

182
00:09:02,890 --> 00:09:09,279
it's a code written on C++ and this is

183
00:09:05,649 --> 00:09:12,700
chronic classic error here and we can

184
00:09:09,279 --> 00:09:16,420
see that this condition has been

185
00:09:12,700 --> 00:09:19,060
verified and instead of double checking

186
00:09:16,420 --> 00:09:21,459
instead of two they they've written a

187
00:09:19,060 --> 00:09:23,380
cause one C++ enables you to do it and

188
00:09:21,459 --> 00:09:25,959
as a result instead of double che

189
00:09:23,380 --> 00:09:28,240
chicken you can always just assign the

190
00:09:25,959 --> 00:09:30,369
true and the condition is always like a

191
00:09:28,240 --> 00:09:32,860
by torture and the robot is going to

192
00:09:30,370 --> 00:09:35,020
kill people whatever happens and this is

193
00:09:32,860 --> 00:09:37,329
also like kind of an in the way of

194
00:09:35,020 --> 00:09:39,939
joking but it's also illustrates of why

195
00:09:37,329 --> 00:09:41,949
we need esthetical analysis we are

196
00:09:39,940 --> 00:09:43,839
looking for quite a simple things I

197
00:09:41,950 --> 00:09:46,899
would say but actually they're not that

198
00:09:43,839 --> 00:09:48,400
simple and we're going to go through the

199
00:09:46,899 --> 00:09:50,949
aesthetic or analysis technologies

200
00:09:48,400 --> 00:09:52,030
what's inside of it what works what does

201
00:09:50,949 --> 00:09:55,030
not work

202
00:09:52,030 --> 00:09:58,120
after that we will be able to understand

203
00:09:55,030 --> 00:10:00,100
of how these technologies are used like

204
00:09:58,120 --> 00:10:03,270
Anna would stick was the code security

205
00:10:00,100 --> 00:10:03,270
is playing its role in it

206
00:10:56,760 --> 00:11:07,020
amounts of data and in my the negative

207
00:11:04,950 --> 00:11:10,080
or the corn is that there's a lot of

208
00:11:07,020 --> 00:11:13,020
noise and the statistical analyzers

209
00:11:10,080 --> 00:11:16,440
would give some percentage of false

210
00:11:13,020 --> 00:11:19,020
positives and when the analyzer will say

211
00:11:16,440 --> 00:11:22,320
there is an an error there and it's not

212
00:11:19,020 --> 00:11:25,699
there so we split it for the most

213
00:11:22,320 --> 00:11:29,280
critical high probability of criticality

214
00:11:25,700 --> 00:11:32,880
medium minimal but there is definitely

215
00:11:29,280 --> 00:11:37,110
is all the analyzers have it and it can

216
00:11:32,880 --> 00:11:39,060
depend and good analyzes would minimize

217
00:11:37,110 --> 00:11:41,700
that knowledge so that the programmer

218
00:11:39,060 --> 00:11:44,390
doesn't have to go through ten tens of

219
00:11:41,700 --> 00:11:46,890
thousands of messages that are false

220
00:11:44,390 --> 00:11:50,819
cannot be understand and but anyways the

221
00:11:46,890 --> 00:11:52,860
developer makes the decision and he

222
00:11:50,820 --> 00:11:55,440
understands the code here he's written

223
00:11:52,860 --> 00:12:00,050
and then I was just showing those places

224
00:11:55,440 --> 00:12:04,910
to him so those are the main issues here

225
00:12:00,050 --> 00:12:10,290
regarding the technology we often hear

226
00:12:04,910 --> 00:12:12,680
or our analyzed at least they say you

227
00:12:10,290 --> 00:12:17,189
probably just have regular expressions

228
00:12:12,680 --> 00:12:21,000
inside and it's very works very simply

229
00:12:17,190 --> 00:12:22,830
why don't you let us and your rules

230
00:12:21,000 --> 00:12:25,860
because just adding another regular

231
00:12:22,830 --> 00:12:27,690
expression we usually answer that now it

232
00:12:25,860 --> 00:12:30,540
doesn't work this way those technologies

233
00:12:27,690 --> 00:12:33,690
don't work as well as we would want

234
00:12:30,540 --> 00:12:36,959
using just simple regular expressions

235
00:12:33,690 --> 00:12:40,830
you just can find very very simple

236
00:12:36,960 --> 00:12:43,470
constructs that and there are a couple

237
00:12:40,830 --> 00:12:46,740
of examples where this doesn't work like

238
00:12:43,470 --> 00:12:50,010
a plus B equals people are say these

239
00:12:46,740 --> 00:12:54,210
things people understand and the program

240
00:12:50,010 --> 00:12:58,110
will be logical a program will show that

241
00:12:54,210 --> 00:13:01,710
the same expression that process but you

242
00:12:58,110 --> 00:13:03,480
to process it using the string matching

243
00:13:01,710 --> 00:13:06,080
using regular expressions doesn't work

244
00:13:03,480 --> 00:13:07,589
and there are even more complicated

245
00:13:06,080 --> 00:13:11,879
situations

246
00:13:07,589 --> 00:13:14,759
those things don't work there there are

247
00:13:11,879 --> 00:13:19,439
analyzers that solve those issues and

248
00:13:14,759 --> 00:13:23,370
there are positive traits here and reg

249
00:13:19,439 --> 00:13:27,029
apps based analyzers I can just put some

250
00:13:23,370 --> 00:13:31,740
source code through them and they will

251
00:13:27,029 --> 00:13:34,949
try to parse it but for full-blown

252
00:13:31,740 --> 00:13:36,559
analysis it is not enough it is

253
00:13:34,949 --> 00:13:39,809
important that the project it is

254
00:13:36,559 --> 00:13:42,329
compatible and because the compiling

255
00:13:39,809 --> 00:13:44,399
information gives you a lot of data if

256
00:13:42,329 --> 00:13:46,729
the analyzer is able to gather all that

257
00:13:44,399 --> 00:13:51,089
data that gives you the opportunity to

258
00:13:46,730 --> 00:13:55,309
make deep analysis and understand what's

259
00:13:51,089 --> 00:13:59,399
going on with inside the variables using

260
00:13:55,309 --> 00:14:06,120
arrays and other functions which makes

261
00:13:59,399 --> 00:14:08,339
analysis more functional here are the

262
00:14:06,120 --> 00:14:10,949
main statistical functions fused we will

263
00:14:08,339 --> 00:14:13,199
look into them in more detail all the

264
00:14:10,949 --> 00:14:19,969
technologies are quite complicated but

265
00:14:13,199 --> 00:14:23,008
there's no magic here so first of all

266
00:14:19,970 --> 00:14:25,110
button latest analysis comparing with a

267
00:14:23,009 --> 00:14:28,220
part and then always looks through your

268
00:14:25,110 --> 00:14:31,670
code and finds some situations that

269
00:14:28,220 --> 00:14:37,680
analyze and knows and here we have

270
00:14:31,670 --> 00:14:41,250
suspicious situation when for example in

271
00:14:37,680 --> 00:14:43,949
the string array there is no comma and

272
00:14:41,250 --> 00:14:46,920
it's very suspicious she was allowed

273
00:14:43,949 --> 00:14:51,149
that suppose we'll just concatenate

274
00:14:46,920 --> 00:14:55,079
those strings but the chances of the

275
00:14:51,149 --> 00:14:58,290
program really wishing this to happen

276
00:14:55,079 --> 00:15:02,910
it's quite loud the analyser is not very

277
00:14:58,290 --> 00:15:05,969
sure but he says dear developer please

278
00:15:02,910 --> 00:15:08,879
have a look and yeah it's true the comma

279
00:15:05,970 --> 00:15:11,809
is missing and this is an example of a

280
00:15:08,879 --> 00:15:11,809
pattern matching

281
00:15:13,279 --> 00:15:21,510
search for suspicious situations and

282
00:15:17,550 --> 00:15:24,839
behaviors we find interesting errors

283
00:15:21,510 --> 00:15:30,569
this one is a real error from Linux

284
00:15:24,839 --> 00:15:34,589
ghost we had an article quite a while

285
00:15:30,570 --> 00:15:39,320
ago about this they know I have found it

286
00:15:34,589 --> 00:15:41,730
and this is one example of part matching

287
00:15:39,320 --> 00:15:46,410
going further

288
00:15:41,730 --> 00:15:51,630
typing inference gives us a chance to

289
00:15:46,410 --> 00:15:54,860
understand what's happening inside this

290
00:15:51,630 --> 00:15:58,470
is in part already a dynamic analysis

291
00:15:54,860 --> 00:16:03,329
present in statistical analyzers it

292
00:15:58,470 --> 00:16:05,640
gives you helps you to really deepen the

293
00:16:03,329 --> 00:16:09,479
analysis we see a template of the

294
00:16:05,640 --> 00:16:16,649
structure here an array is initialized

295
00:16:09,480 --> 00:16:21,329
and there's a function where we try to

296
00:16:16,649 --> 00:16:25,100
feel with zeros the area of memory that

297
00:16:21,329 --> 00:16:28,769
that is inside there the mistake is

298
00:16:25,100 --> 00:16:40,110
intentional here size of T is multiplied

299
00:16:28,769 --> 00:16:44,240
by 10 even though it should be x by n it

300
00:16:40,110 --> 00:16:44,240
was intentional here and the analyzer

301
00:16:45,050 --> 00:16:50,849
understand that with the scaling of this

302
00:16:48,990 --> 00:16:54,120
template something will go wrong because

303
00:16:50,850 --> 00:16:57,810
you have announced an array of 5

304
00:16:54,120 --> 00:17:03,779
elements and you will put zeros in into

305
00:16:57,810 --> 00:17:07,099
y should become much more and this

306
00:17:03,779 --> 00:17:09,750
sample shows that the analyzer was

307
00:17:07,099 --> 00:17:14,369
understanding the types

308
00:17:09,750 --> 00:17:17,789
it looked at what axes understood how

309
00:17:14,369 --> 00:17:21,688
its instantiated and understood it will

310
00:17:17,789 --> 00:17:25,260
be an issue because the area memory area

311
00:17:21,689 --> 00:17:28,890
filled with zeros will be much bigger so

312
00:17:25,260 --> 00:17:31,470
here's one of the examples they

313
00:17:28,890 --> 00:17:34,230
technologies used as part of the

314
00:17:31,470 --> 00:17:40,340
statistical analysis moving further

315
00:17:34,230 --> 00:17:44,309
symbolic execution it's easier to

316
00:17:40,340 --> 00:17:48,389
analyze and understand and analyze is

317
00:17:44,309 --> 00:17:50,490
just solving a simple equation we have a

318
00:17:48,390 --> 00:17:56,240
and B here we don't know what X means

319
00:17:50,490 --> 00:18:00,480
here it can have any value but we can

320
00:17:56,240 --> 00:18:03,770
think that conclude that in in such a

321
00:18:00,480 --> 00:18:09,169
situation if we try to use a and B

322
00:18:03,770 --> 00:18:13,710
variables as the index of array by

323
00:18:09,169 --> 00:18:15,840
deducting the a from B we will be

324
00:18:13,710 --> 00:18:19,799
addressing the element that is outside

325
00:18:15,840 --> 00:18:22,649
the boundaries of the array and everyone

326
00:18:19,799 --> 00:18:25,049
is quite pretty much guaranteed

327
00:18:22,650 --> 00:18:31,740
so then long as I will be able to find

328
00:18:25,049 --> 00:18:35,510
those situations and make this

329
00:18:31,740 --> 00:18:40,950
conclusion so some interesting examples

330
00:18:35,510 --> 00:18:45,809
regarding the dataflow analysis what is

331
00:18:40,950 --> 00:18:48,260
it it's when inside some method the

332
00:18:45,809 --> 00:18:56,610
analyzer for each and every variable

333
00:18:48,260 --> 00:19:00,629
saves it saves it state it understands

334
00:18:56,610 --> 00:19:04,500
how it can change if it's humor integer

335
00:19:00,630 --> 00:19:07,470
for example number whether it's a now or

336
00:19:04,500 --> 00:19:13,169
not and based on the information about

337
00:19:07,470 --> 00:19:17,020
the values it's always a scope are

338
00:19:13,169 --> 00:19:18,850
of alias analyzer knows and can make a

339
00:19:17,020 --> 00:19:24,120
conclusion that something is going wrong

340
00:19:18,850 --> 00:19:24,120
this is a real chromium example and we

341
00:19:24,600 --> 00:19:34,209
actually used to demo it as part of our

342
00:19:28,809 --> 00:19:35,740
stand how both on the exhibitions and we

343
00:19:34,210 --> 00:19:37,830
have a function here checking the

344
00:19:35,740 --> 00:19:40,500
validate validity and it works

345
00:19:37,830 --> 00:19:43,750
incorrectly

346
00:19:40,500 --> 00:19:48,120
it's called validate date time and each

347
00:19:43,750 --> 00:19:50,230
pay attention to time months variable

348
00:19:48,120 --> 00:19:58,239
look what's happening here

349
00:19:50,230 --> 00:20:00,039
a static array is announced which has a

350
00:19:58,240 --> 00:20:06,820
number of days in each and every month

351
00:20:00,039 --> 00:20:08,529
and as the array is addressed starting

352
00:20:06,820 --> 00:20:09,668
from zero then the first zero doesn't

353
00:20:08,529 --> 00:20:13,390
doesn't make any sense

354
00:20:09,669 --> 00:20:16,809
so the analyzer looks for time lands

355
00:20:13,390 --> 00:20:23,860
variable and understand it's limited by

356
00:20:16,809 --> 00:20:28,149
one to two to twelve there's some more

357
00:20:23,860 --> 00:20:30,250
checks but coming to the second if the

358
00:20:28,149 --> 00:20:37,529
analyzer knows that time ones can be

359
00:20:30,250 --> 00:20:37,529
from 1 to 12 then time mass is limited

360
00:20:38,010 --> 00:20:47,230
by being equal to zero and here look

361
00:20:43,840 --> 00:20:56,709
it's compared to any value here it will

362
00:20:47,230 --> 00:21:01,000
be 2 and we see that 2 is less or equal

363
00:20:56,710 --> 00:21:03,789
than 28 plus 1 and the analyzer says now

364
00:21:01,000 --> 00:21:06,190
this if is definitely true always and if

365
00:21:03,789 --> 00:21:10,500
we look at the second if

366
00:21:06,190 --> 00:21:18,340
which has the same error Hamas is

367
00:21:10,500 --> 00:21:21,580
limited by being from 1 to 12 and of

368
00:21:18,340 --> 00:21:25,030
course we see that any value from 1 to

369
00:21:21,580 --> 00:21:28,389
12 is less or equal to any of those

370
00:21:25,030 --> 00:21:31,330
values and this is always true again so

371
00:21:28,390 --> 00:21:33,040
this is time instead of time months it

372
00:21:31,330 --> 00:21:35,889
should be time day of course because we

373
00:21:33,040 --> 00:21:38,740
are comparing day to days with days but

374
00:21:35,890 --> 00:21:43,330
the problem has made a misprint

375
00:21:38,740 --> 00:21:48,940
this type typo big and it doesn't look

376
00:21:43,330 --> 00:21:52,389
very very special here if it wasn't

377
00:21:48,940 --> 00:21:57,100
highlighted in red it doesn't draw the

378
00:21:52,390 --> 00:22:01,900
eye so here's how you can analyze the

379
00:21:57,100 --> 00:22:04,949
data flow and use it to find errors it's

380
00:22:01,900 --> 00:22:11,350
a real real mistake in chromium project

381
00:22:04,950 --> 00:22:13,900
finally quite a simple technology but

382
00:22:11,350 --> 00:22:20,040
it's very useful but when we know how

383
00:22:13,900 --> 00:22:20,040
method should work method annotation

384
00:22:20,160 --> 00:22:27,190
imagine you have a library method and we

385
00:22:22,990 --> 00:22:34,630
know how to use it like equals for

386
00:22:27,190 --> 00:22:37,660
example here and of course making equals

387
00:22:34,630 --> 00:22:39,480
function compared to exactly two

388
00:22:37,660 --> 00:22:41,340
variables that are exactly the same

389
00:22:39,480 --> 00:22:45,790
makes no sense

390
00:22:41,340 --> 00:22:49,899
how does the analyzer works it knows

391
00:22:45,790 --> 00:22:53,830
that equals should not receive the same

392
00:22:49,900 --> 00:22:57,640
arguments and if it catches such a

393
00:22:53,830 --> 00:23:02,260
situation then it says we have an issue

394
00:22:57,640 --> 00:23:04,420
here we have already rounds with

395
00:23:02,260 --> 00:23:09,879
thousands of methods and libraries and

396
00:23:04,420 --> 00:23:14,580
this works work continues but it really

397
00:23:09,880 --> 00:23:14,580
works so if you have

398
00:23:14,680 --> 00:23:25,560
describe the method ones example saying

399
00:23:18,450 --> 00:23:32,110
we should always have the return return

400
00:23:25,560 --> 00:23:35,889
format or which was never used then it

401
00:23:32,110 --> 00:23:38,500
works and again to reiterate on the

402
00:23:35,890 --> 00:23:43,060
thought I have started with there's no

403
00:23:38,500 --> 00:23:47,260
magic it's not very simple but no rocket

404
00:23:43,060 --> 00:23:52,149
science and we are going to next part

405
00:23:47,260 --> 00:23:54,700
asking what is SAS since these are

406
00:23:52,150 --> 00:24:00,760
statistical code analysis and a couple

407
00:23:54,700 --> 00:24:03,010
of words about vulnerabilities there's

408
00:24:00,760 --> 00:24:06,129
huge interest to vulnerability Sara I

409
00:24:03,010 --> 00:24:10,690
would save and jump in interest and if

410
00:24:06,130 --> 00:24:17,290
you have a look at the graph of the

411
00:24:10,690 --> 00:24:21,490
amount of the vulnerabilities found we

412
00:24:17,290 --> 00:24:25,210
saw five point five thousand plus cases

413
00:24:21,490 --> 00:24:28,180
in 2008 like dot well-documented that

414
00:24:25,210 --> 00:24:33,970
you could use if they were not fix it

415
00:24:28,180 --> 00:24:38,140
and look at 2018 it's more than three

416
00:24:33,970 --> 00:24:39,910
times this huge growth only it's not

417
00:24:38,140 --> 00:24:42,220
connected with the fact that there's

418
00:24:39,910 --> 00:24:44,800
more mistakes and vulnerabilities I

419
00:24:42,220 --> 00:24:51,120
think it's because there's more interest

420
00:24:44,800 --> 00:24:54,820
and usually it's community work or

421
00:24:51,120 --> 00:24:58,479
enthusiasts working looking for mistakes

422
00:24:54,820 --> 00:25:02,070
or abilities in the code are special

423
00:24:58,480 --> 00:25:08,460
sites special programs to to do it and

424
00:25:02,070 --> 00:25:12,490
we have now sites that allow you to

425
00:25:08,460 --> 00:25:16,150
describe those vulnerabilities and find

426
00:25:12,490 --> 00:25:19,290
them and this growth is has a lot to do

427
00:25:16,150 --> 00:25:22,030
with the interest and we see that

428
00:25:19,290 --> 00:25:24,159
there's more and more of our abilities

429
00:25:22,030 --> 00:25:26,389
and the statistics for this year should

430
00:25:24,160 --> 00:25:29,300
I think you mean higher

431
00:25:26,390 --> 00:25:33,530
here's the link down there where I took

432
00:25:29,300 --> 00:25:36,440
it but I think you can also find it in

433
00:25:33,530 --> 00:25:39,440
other sources so what is fast

434
00:25:36,440 --> 00:25:43,060
it's classic statistical analysis but

435
00:25:39,440 --> 00:25:46,640
it's just targeted at finding potential

436
00:25:43,060 --> 00:25:51,379
vulnerabilities why do we say potential

437
00:25:46,640 --> 00:25:55,820
here because the real vulnerability will

438
00:25:51,380 --> 00:25:58,580
not be findable using statistical

439
00:25:55,820 --> 00:26:01,970
analysis the real vulnerability is when

440
00:25:58,580 --> 00:26:06,620
some researcher has found some some gap

441
00:26:01,970 --> 00:26:08,570
in the code and he used it the

442
00:26:06,620 --> 00:26:11,360
statistical analysis can just say that

443
00:26:08,570 --> 00:26:14,330
this place in the code can potentially

444
00:26:11,360 --> 00:26:17,379
be used or potentially be dangerous so

445
00:26:14,330 --> 00:26:21,080
if something goes wrong then the

446
00:26:17,380 --> 00:26:26,120
software will not work as designed or as

447
00:26:21,080 --> 00:26:28,699
the programmer expected and this s story

448
00:26:26,120 --> 00:26:33,260
is very important here because by

449
00:26:28,700 --> 00:26:35,930
removing the vulnerability you in many

450
00:26:33,260 --> 00:26:40,970
cases remove the real vulnerability and

451
00:26:35,930 --> 00:26:45,890
you don't need to care that the code you

452
00:26:40,970 --> 00:26:48,620
have created can be dangerous or can be

453
00:26:45,890 --> 00:26:51,530
exploited and the main thing here is

454
00:26:48,620 --> 00:26:54,050
that the statistical analysis correlates

455
00:26:51,530 --> 00:26:56,060
well with those standards and

456
00:26:54,050 --> 00:27:00,370
technologies I've mentioned a couple of

457
00:26:56,060 --> 00:27:03,200
them here is definitely more there are

458
00:27:00,370 --> 00:27:07,129
standards where those vulnerabilities

459
00:27:03,200 --> 00:27:09,920
are mentioned they listed and the

460
00:27:07,130 --> 00:27:16,760
patterns that the statistical analyzer

461
00:27:09,920 --> 00:27:19,760
will show you those issues and saying

462
00:27:16,760 --> 00:27:23,840
like hey Fran you have some security

463
00:27:19,760 --> 00:27:27,290
vulnerabilities security issues here the

464
00:27:23,840 --> 00:27:30,679
correlation between traditional errors

465
00:27:27,290 --> 00:27:33,830
and vulnerabilities can be quite high

466
00:27:30,680 --> 00:27:35,020
and it's more than 60% based on some

467
00:27:33,830 --> 00:27:39,580
research

468
00:27:35,020 --> 00:27:44,408
a picture for your information like it's

469
00:27:39,580 --> 00:27:49,928
very fancy now there's a cop's SAS

470
00:27:44,409 --> 00:27:53,020
technology and is part of deaf deaf part

471
00:27:49,929 --> 00:27:55,470
of their scopes as part of the

472
00:27:53,020 --> 00:27:57,730
development and the program is using

473
00:27:55,470 --> 00:28:01,270
statistical analyzers or cest

474
00:27:57,730 --> 00:28:07,179
instruments on the is her machine

475
00:28:01,270 --> 00:28:09,190
it's the most well appreciated way

476
00:28:07,179 --> 00:28:13,529
because the program knows the code and

477
00:28:09,190 --> 00:28:18,360
he's written it himself and of course he

478
00:28:13,529 --> 00:28:22,690
can just run it between the commits and

479
00:28:18,360 --> 00:28:25,059
look at them and fix them so it's it's

480
00:28:22,690 --> 00:28:36,429
all done on the developers machine and

481
00:28:25,059 --> 00:28:38,289
it's part of deaf circles and speaking

482
00:28:36,429 --> 00:28:41,260
about how to spell my abilities are

483
00:28:38,289 --> 00:28:43,690
found using statistical analysis you can

484
00:28:41,260 --> 00:28:48,210
use two ways you can be looking for old

485
00:28:43,690 --> 00:28:54,700
code but there it's more like antivirus

486
00:28:48,210 --> 00:28:56,890
antivirus works imagine you have

487
00:28:54,700 --> 00:29:00,850
libraries well-known libraries of

488
00:28:56,890 --> 00:29:03,399
well-known versions the code is not

489
00:29:00,850 --> 00:29:06,039
changing there and there will be

490
00:29:03,399 --> 00:29:10,689
vulnerable it is found there probably

491
00:29:06,039 --> 00:29:13,179
you'll have less false positives but

492
00:29:10,690 --> 00:29:15,870
this is the code result what do you do

493
00:29:13,179 --> 00:29:15,870
with the new code

494
00:29:17,270 --> 00:29:22,670
first thing comes to mind our new

495
00:29:20,570 --> 00:29:28,389
technologies and new language constructs

496
00:29:22,670 --> 00:29:31,880
that you cannot find when you're just

497
00:29:28,390 --> 00:29:34,660
searching the old code so the second way

498
00:29:31,880 --> 00:29:40,130
when you analyze the source code is more

499
00:29:34,660 --> 00:29:43,390
favorable but and and you try to longer

500
00:29:40,130 --> 00:29:46,240
be so prevent funner abilities there

501
00:29:43,390 --> 00:29:50,120
during co-creation

502
00:29:46,240 --> 00:29:52,220
it still works for the old code but the

503
00:29:50,120 --> 00:29:54,620
amount of work you have to do is much

504
00:29:52,220 --> 00:30:03,460
bigger so our analyzer

505
00:29:54,620 --> 00:30:06,409
works the using this second way we reuse

506
00:30:03,460 --> 00:30:09,470
the recommendation as I said is that the

507
00:30:06,410 --> 00:30:13,730
developer uses the technology of course

508
00:30:09,470 --> 00:30:17,300
you can use it and this server by QA and

509
00:30:13,730 --> 00:30:20,180
during testing but this all increases

510
00:30:17,300 --> 00:30:24,770
the spend significantly and if you

511
00:30:20,180 --> 00:30:26,990
missed the the error

512
00:30:24,770 --> 00:30:32,120
and it went to the deployment server

513
00:30:26,990 --> 00:30:33,980
then someone needs to find it and send

514
00:30:32,120 --> 00:30:39,310
those happy mails

515
00:30:33,980 --> 00:30:47,330
it was principal time the program will

516
00:30:39,310 --> 00:30:50,690
receive the feedback and test will be

517
00:30:47,330 --> 00:30:54,020
done so of course it's it's harder and

518
00:30:50,690 --> 00:30:56,420
of course if you missed the the error

519
00:30:54,020 --> 00:30:58,840
and they plan to release them the losses

520
00:30:56,420 --> 00:31:02,840
are much higher so some research here

521
00:30:58,840 --> 00:31:05,750
stating that it's quite quite simple

522
00:31:02,840 --> 00:31:08,600
quite understandable so to minimize

523
00:31:05,750 --> 00:31:11,320
risks you need of course to find those

524
00:31:08,600 --> 00:31:13,879
issues earlier and the reputational

525
00:31:11,320 --> 00:31:17,500
losses can be high not only the

526
00:31:13,880 --> 00:31:17,500
financial ones and

527
00:31:18,910 --> 00:31:29,050
I said there are two well-known

528
00:31:23,350 --> 00:31:33,179
technologies for potential vulnerable so

529
00:31:29,050 --> 00:31:36,129
cwe is common weakness enumeration and

530
00:31:33,180 --> 00:31:41,380
CV are real vulnerabilities

531
00:31:36,130 --> 00:31:47,760
look at this funnel of they're very

532
00:31:41,380 --> 00:31:47,760
different some part of those errors

533
00:31:48,360 --> 00:31:58,240
usually 60% or more common weaknesses

534
00:31:53,850 --> 00:32:02,469
they're constructs in the code that are

535
00:31:58,240 --> 00:32:04,960
suspicious in terms of security and

536
00:32:02,470 --> 00:32:06,550
under some circumstances this code can

537
00:32:04,960 --> 00:32:09,760
work incorrectly

538
00:32:06,550 --> 00:32:11,860
not as the program I expected and based

539
00:32:09,760 --> 00:32:15,550
on that small number of potential

540
00:32:11,860 --> 00:32:17,080
vulnerabilities we can have some some

541
00:32:15,550 --> 00:32:19,240
part of them becoming the real

542
00:32:17,080 --> 00:32:23,970
vulnerable is when the community has

543
00:32:19,240 --> 00:32:27,220
worked or research has shown and it's

544
00:32:23,970 --> 00:32:30,670
already mentioned and documented as

545
00:32:27,220 --> 00:32:32,710
something found in your code we know

546
00:32:30,670 --> 00:32:34,600
what this owner ability is how you can

547
00:32:32,710 --> 00:32:41,260
exploit it or is it fix it whether it

548
00:32:34,600 --> 00:32:43,929
was not fix it this is a very thin line

549
00:32:41,260 --> 00:32:45,250
of difference that you need to

550
00:32:43,930 --> 00:32:51,550
understand sir

551
00:32:45,250 --> 00:33:00,220
the methods we are talking about looking

552
00:32:51,550 --> 00:33:03,899
for cwe's see ee is there's a lot of

553
00:33:00,220 --> 00:33:07,000
rules they correlate well with the

554
00:33:03,900 --> 00:33:09,760
mistakes that found by statistical

555
00:33:07,000 --> 00:33:15,400
analysis and when we were implementing

556
00:33:09,760 --> 00:33:19,870
those C into analyzer from more than 800

557
00:33:15,400 --> 00:33:22,950
of rules we were already covering a lot

558
00:33:19,870 --> 00:33:22,949
and the totals

559
00:33:23,170 --> 00:33:31,520
actually cow cover quite quite a

560
00:33:26,690 --> 00:33:36,530
significant amount of potential is like

561
00:33:31,520 --> 00:33:42,379
going out of the array boundaries cross

562
00:33:36,530 --> 00:33:45,830
links etc etc you can walk through those

563
00:33:42,380 --> 00:33:48,500
at least get some examples and try to

564
00:33:45,830 --> 00:33:51,530
understand what it can lead to whether

565
00:33:48,500 --> 00:33:55,790
it will be vulnerability or not it's

566
00:33:51,530 --> 00:33:58,129
best to remove it it will not be your

567
00:33:55,790 --> 00:34:02,389
issue no longer after that so some

568
00:33:58,130 --> 00:34:08,990
examples like compiler can remove some

569
00:34:02,390 --> 00:34:09,859
code or optimize something uncheck data

570
00:34:08,989 --> 00:34:14,689
usage

571
00:34:09,859 --> 00:34:19,520
non non initialized variables etcetera

572
00:34:14,690 --> 00:34:24,230
etcetera so a MySQL example quite quite

573
00:34:19,520 --> 00:34:32,810
well-known one it's a real error we see

574
00:34:24,230 --> 00:34:35,389
here they analyze a same we have the

575
00:34:32,810 --> 00:34:40,340
compiler can optimize it yes the

576
00:34:35,389 --> 00:34:42,800
compiler has the task to has the task to

577
00:34:40,340 --> 00:34:45,399
make here called optimal so in the

578
00:34:42,800 --> 00:34:53,540
release it will remove that lamp set

579
00:34:45,399 --> 00:34:57,700
because this win32 of is not used but

580
00:34:53,540 --> 00:35:01,369
the program I used uses it he wants to

581
00:34:57,700 --> 00:35:04,790
fill it with zeros but the compiler

582
00:35:01,369 --> 00:35:06,920
knows doesn't know a lot about what the

583
00:35:04,790 --> 00:35:10,009
program at once the compiler would say

584
00:35:06,920 --> 00:35:12,230
hey this is not really needed and it

585
00:35:10,010 --> 00:35:14,420
won't that will be right so this

586
00:35:12,230 --> 00:35:16,730
construct will not work in the way that

587
00:35:14,420 --> 00:35:21,730
the developer has designed this line

588
00:35:16,730 --> 00:35:25,040
will not make it into the binary that is

589
00:35:21,730 --> 00:35:28,970
finally deployed and the memory will not

590
00:35:25,040 --> 00:35:33,410
be cleaned so the actor

591
00:35:28,970 --> 00:35:35,810
can actually use it so the beta is still

592
00:35:33,410 --> 00:35:39,700
in the memory and also this code has

593
00:35:35,810 --> 00:35:46,369
mother issues look different type of

594
00:35:39,700 --> 00:35:51,560
Diagnostics 579 says that the internal

595
00:35:46,369 --> 00:35:54,349
variable of when 32 of is used and it

596
00:35:51,560 --> 00:35:57,920
has the same structure and size of even

597
00:35:54,349 --> 00:36:00,290
if that meant that would would be used

598
00:35:57,920 --> 00:36:03,230
then everything would go wrong

599
00:36:00,290 --> 00:36:06,950
because instead of the size of the

600
00:36:03,230 --> 00:36:09,079
structure it sends the size of the

601
00:36:06,950 --> 00:36:11,930
pointer and of course the size of

602
00:36:09,079 --> 00:36:14,210
pointer will be smaller and some part of

603
00:36:11,930 --> 00:36:19,240
that structure will not be filled by

604
00:36:14,210 --> 00:36:23,180
zeros this line actually has two errors

605
00:36:19,240 --> 00:36:26,450
classical analyzers look for those and

606
00:36:23,180 --> 00:36:33,828
whether you should be fixing those those

607
00:36:26,450 --> 00:36:38,290
bugs is your decision and next examples

608
00:36:33,829 --> 00:36:39,819
amazon web services based on sharp it's

609
00:36:38,290 --> 00:36:44,540
[Music]

610
00:36:39,819 --> 00:36:47,089
in the first block of if someone forgot

611
00:36:44,540 --> 00:36:49,670
that they put the return and the based

612
00:36:47,089 --> 00:36:55,759
on the program logic the same variable

613
00:36:49,670 --> 00:36:58,520
is has is assigned the value it's looks

614
00:36:55,760 --> 00:37:01,730
stupid so the analyzer warns us about

615
00:36:58,520 --> 00:37:08,300
this this is potentially vulnerable it

616
00:37:01,730 --> 00:37:10,970
has a number five six three it's

617
00:37:08,300 --> 00:37:14,329
described and whether we will use it or

618
00:37:10,970 --> 00:37:16,669
not we don't know but yeah the issues

619
00:37:14,329 --> 00:37:19,910
here another example from Amazon Web

620
00:37:16,670 --> 00:37:22,609
Services is endless recursion my

621
00:37:19,910 --> 00:37:25,578
analyzer says that this code will

622
00:37:22,609 --> 00:37:28,220
probably not execute very well the

623
00:37:25,579 --> 00:37:34,380
classical association with the on

624
00:37:28,220 --> 00:37:40,390
failure field announcement and the

625
00:37:34,380 --> 00:37:43,599
name of the and the property differ

626
00:37:40,390 --> 00:37:46,239
different by just one letter and as the

627
00:37:43,599 --> 00:37:48,729
program I made a mistake by typing a

628
00:37:46,239 --> 00:37:54,029
capital o instead of small then the

629
00:37:48,729 --> 00:37:57,609
recursion occurs well honey discover

630
00:37:54,029 --> 00:38:01,209
looks like it didn't work I looked at it

631
00:37:57,609 --> 00:38:05,189
it was not used but the good analyzer

632
00:38:01,209 --> 00:38:10,928
would check an unused code also and

633
00:38:05,189 --> 00:38:14,709
because if this is an uncommanded and

634
00:38:10,929 --> 00:38:19,439
goes into the real execution code

635
00:38:14,709 --> 00:38:19,439
yeah it's CWM control the curse

636
00:38:23,220 --> 00:38:26,970
so here we talk about real

637
00:38:25,020 --> 00:38:33,200
vulnerabilities things that were

638
00:38:26,970 --> 00:38:36,660
documented as same meter or association

639
00:38:33,200 --> 00:38:45,480
documented them and here are the real

640
00:38:36,660 --> 00:38:51,450
ones look first example from MySQL this

641
00:38:45,480 --> 00:38:54,980
one was found in 2012 its CV all ability

642
00:38:51,450 --> 00:38:57,450
21 22 it's a real one that was removed

643
00:38:54,980 --> 00:39:02,849
what the guys did here they like

644
00:38:57,450 --> 00:39:08,430
comparing using MEMS EMP to arrays and

645
00:39:02,849 --> 00:39:12,560
the result they are putting into HR so

646
00:39:08,430 --> 00:39:17,399
they have created their own type Bible

647
00:39:12,560 --> 00:39:22,500
so MCP would return its result as as an

648
00:39:17,400 --> 00:39:26,070
int int will be concatenated to HR and

649
00:39:22,500 --> 00:39:33,960
the all the higher bits would be lost

650
00:39:26,070 --> 00:39:37,800
and the check scrambler will be working

651
00:39:33,960 --> 00:39:43,319
when you just have a lot of BS as an

652
00:39:37,800 --> 00:39:51,200
input in one case out of 128 it's a set

653
00:39:43,319 --> 00:39:54,300
up so it's a long and well-defined

654
00:39:51,200 --> 00:39:58,348
description statistical analyzer can

655
00:39:54,300 --> 00:40:05,160
find this thing if you compare int with

656
00:39:58,349 --> 00:40:08,540
char usually this issue will arise and

657
00:40:05,160 --> 00:40:10,799
we see that the statistical analyzer

658
00:40:08,540 --> 00:40:14,609
actually throw an exception here and

659
00:40:10,800 --> 00:40:17,339
show point this code out to you how did

660
00:40:14,609 --> 00:40:21,560
we find it we found we put this code

661
00:40:17,339 --> 00:40:21,560
into the analyze and

662
00:40:22,440 --> 00:40:27,460
so if developers were using statistical

663
00:40:25,090 --> 00:40:30,060
analysis then they will be definite

664
00:40:27,460 --> 00:40:30,060
relative

665
00:40:35,250 --> 00:40:40,960
they're using the methods of brain for

666
00:40:38,380 --> 00:40:45,040
their writing who they're trying to

667
00:40:40,960 --> 00:40:47,740
print out some some debugging

668
00:40:45,040 --> 00:40:49,480
information in this booth which they're

669
00:40:47,740 --> 00:40:51,189
selling it's basically the specific

670
00:40:49,480 --> 00:40:55,119
ators like in print

671
00:40:51,190 --> 00:40:58,000
it's percentage a percentage the prints

672
00:40:55,119 --> 00:40:59,470
like a size long is putting the data on

673
00:40:58,000 --> 00:41:05,500
the stack and stack is collecting the

674
00:40:59,470 --> 00:41:07,270
data so if you have at the supply the

675
00:41:05,500 --> 00:41:09,940
list of incorrect specific address then

676
00:41:07,270 --> 00:41:11,670
it can extract data which has no

677
00:41:09,940 --> 00:41:14,230
relation to this case whatsoever you can

678
00:41:11,670 --> 00:41:16,839
write the line of specific a trace and

679
00:41:14,230 --> 00:41:18,869
go all the way up to a different area of

680
00:41:16,839 --> 00:41:21,430
memory and to see what's in the memory

681
00:41:18,869 --> 00:41:24,640
so it's a real vulnerability which has

682
00:41:21,430 --> 00:41:27,549
been described and because they have

683
00:41:24,640 --> 00:41:30,700
used here specific ATAR and not in an

684
00:41:27,550 --> 00:41:32,500
overt version you could you could supply

685
00:41:30,700 --> 00:41:34,359
your own specific ATAR and they dig into

686
00:41:32,500 --> 00:41:37,150
the memory of the processor in the real

687
00:41:34,359 --> 00:41:39,700
time and to extract something some

688
00:41:37,150 --> 00:41:42,450
information which is not up your level

689
00:41:39,700 --> 00:41:47,410
it's a real vulnerability identified in

690
00:41:42,450 --> 00:41:50,439
2013 in the Naas project next case quite

691
00:41:47,410 --> 00:41:52,629
interesting in iOS back in 2014 had been

692
00:41:50,440 --> 00:41:54,490
identified you can see the programmer at

693
00:41:52,630 --> 00:41:56,230
the written two times go to you it's a

694
00:41:54,490 --> 00:41:59,589
nonsense even to use go-to but they're

695
00:41:56,230 --> 00:42:02,500
using go-to but it's been double printed

696
00:41:59,589 --> 00:42:05,259
here and it makes sense that the logic

697
00:42:02,500 --> 00:42:07,900
of the program has been broken here it

698
00:42:05,260 --> 00:42:10,570
had they used any analyzer and it could

699
00:42:07,900 --> 00:42:12,700
give them empty warning in addition to

700
00:42:10,570 --> 00:42:15,040
logic violation there also could be the

701
00:42:12,700 --> 00:42:18,129
unachievable code and strange formatting

702
00:42:15,040 --> 00:42:22,300
go to two times and of course the last

703
00:42:18,130 --> 00:42:24,910
if had not been worked out they put some

704
00:42:22,300 --> 00:42:27,430
signatures some key and it's been very

705
00:42:24,910 --> 00:42:31,118
bad and all these things have been fixed

706
00:42:27,430 --> 00:42:34,419
by now but as an illustration all of

707
00:42:31,119 --> 00:42:37,750
this has been documented now quickly I'm

708
00:42:34,420 --> 00:42:41,650
going to go over different standards

709
00:42:37,750 --> 00:42:43,330
not the wrong words by standards misra

710
00:42:41,650 --> 00:42:45,400
is another very good standard which has

711
00:42:43,330 --> 00:42:47,920
been used in our automotive industry

712
00:42:45,400 --> 00:42:49,960
it's also about a very safe development

713
00:42:47,920 --> 00:42:51,340
but it's about development per se this

714
00:42:49,960 --> 00:42:54,250
is the way you should be writing your

715
00:42:51,340 --> 00:42:55,690
code in such a way that you could

716
00:42:54,250 --> 00:42:58,510
minimize number of mistakes and

717
00:42:55,690 --> 00:43:01,270
vulnerabilities basically this means is

718
00:42:58,510 --> 00:43:04,780
really really popular by embedded

719
00:43:01,270 --> 00:43:08,470
systems manufacturers it's for the C C++

720
00:43:04,780 --> 00:43:11,050
and a lot of rules comes with it and the

721
00:43:08,470 --> 00:43:13,480
rules are like never use go-to for

722
00:43:11,050 --> 00:43:15,250
example it's one of the rules and other

723
00:43:13,480 --> 00:43:18,760
rules is like there should be one exit

724
00:43:15,250 --> 00:43:20,980
from the function type of the cases and

725
00:43:18,760 --> 00:43:22,750
different things so the standard is wide

726
00:43:20,980 --> 00:43:25,750
complex in the sense that if you're

727
00:43:22,750 --> 00:43:27,940
using this standard in a legacy project

728
00:43:25,750 --> 00:43:30,070
there will be a lot of ticks off but if

729
00:43:27,940 --> 00:43:35,470
you follow all the conditions in this

730
00:43:30,070 --> 00:43:37,330
mess right there about 143 220 28 you

731
00:43:35,470 --> 00:43:39,490
may believe that your code is quite safe

732
00:43:37,330 --> 00:43:42,340
now couple words about this mitra

733
00:43:39,490 --> 00:43:46,930
another standard siert which is quite

734
00:43:42,340 --> 00:43:51,940
well known and it's for C C++ and Java

735
00:43:46,930 --> 00:43:54,879
Perl languages it's very very common to

736
00:43:51,940 --> 00:43:57,430
the CV the idea is the same certain

737
00:43:54,880 --> 00:44:00,430
patters of mistakes which will enable

738
00:43:57,430 --> 00:44:03,600
you to find some structures of the

739
00:44:00,430 --> 00:44:06,089
entrance to to fix them not fix but

740
00:44:03,600 --> 00:44:08,440
minimize the number of potential

741
00:44:06,090 --> 00:44:10,710
vulnerabilities and the rule searches

742
00:44:08,440 --> 00:44:14,410
like that very much to what we've been

743
00:44:10,710 --> 00:44:15,670
saying before it's about optimization

744
00:44:14,410 --> 00:44:17,950
that the compiler can optimize

745
00:44:15,670 --> 00:44:19,090
everything without your knowledge so

746
00:44:17,950 --> 00:44:20,799
these kind of things have to be

747
00:44:19,090 --> 00:44:22,150
controlled in your code basically that's

748
00:44:20,800 --> 00:44:25,120
it about technologies about the

749
00:44:22,150 --> 00:44:28,810
standards and couple more words as I'm

750
00:44:25,120 --> 00:44:31,810
finishing up of how we recommend to use

751
00:44:28,810 --> 00:44:34,210
your s ast esthetical analysis and all

752
00:44:31,810 --> 00:44:36,880
the technologies it is true for all

753
00:44:34,210 --> 00:44:38,740
these static analyzers not only about

754
00:44:36,880 --> 00:44:43,020
our analyzer

755
00:44:38,740 --> 00:44:45,490
and you have to identify your own tool

756
00:44:43,020 --> 00:44:47,800
which will be fitting your project

757
00:44:45,490 --> 00:44:51,430
because analyzer has to be chosen there

758
00:44:47,800 --> 00:44:53,140
are no perfect analyzers some analyzers

759
00:44:51,430 --> 00:44:55,899
there looking for different smells in

760
00:44:53,140 --> 00:44:57,940
the code and others looking for the

761
00:44:55,900 --> 00:44:59,080
vulnerabilities in the code potential

762
00:44:57,940 --> 00:45:01,300
ones and real ones

763
00:44:59,080 --> 00:45:02,740
analyzing legacy codes the certain

764
00:45:01,300 --> 00:45:05,520
analyzers which are working with a

765
00:45:02,740 --> 00:45:08,979
binary code we've been working with

766
00:45:05,520 --> 00:45:11,109
source code while other analyzers

767
00:45:08,980 --> 00:45:13,960
analyzing binary code it has certain

768
00:45:11,109 --> 00:45:15,670
advantages and disadvantages so once

769
00:45:13,960 --> 00:45:18,550
you've chosen your analyzers you have to

770
00:45:15,670 --> 00:45:21,190
set it up the right setup or will help

771
00:45:18,550 --> 00:45:23,830
you to minimize numbers of or false

772
00:45:21,190 --> 00:45:25,480
positives like by by one order or to

773
00:45:23,830 --> 00:45:28,509
order of magnitude sometimes people take

774
00:45:25,480 --> 00:45:30,520
our own analyzer analyzer and take their

775
00:45:28,510 --> 00:45:32,050
projects with a 5min of lines of codes

776
00:45:30,520 --> 00:45:33,369
there they say there are hundred

777
00:45:32,050 --> 00:45:35,440
thousands of checks what shall we do

778
00:45:33,369 --> 00:45:37,390
that they're given recommendation they

779
00:45:35,440 --> 00:45:40,330
do the tune-up instead of one hundred

780
00:45:37,390 --> 00:45:42,609
thousand a for one thousand or warnings

781
00:45:40,330 --> 00:45:44,500
it can work with it but you have to work

782
00:45:42,609 --> 00:45:49,270
with the new warnings it's a main idea

783
00:45:44,500 --> 00:45:52,900
of the esthetical analysis that when we

784
00:45:49,270 --> 00:45:56,080
write articles we check the projects

785
00:45:52,900 --> 00:45:58,240
where you get the 1000 articles and 1000

786
00:45:56,080 --> 00:46:01,060
errands and write articles but in real

787
00:45:58,240 --> 00:46:02,830
life you take analyzer you find 10,000

788
00:46:01,060 --> 00:46:06,339
errors which you will definitely have

789
00:46:02,830 --> 00:46:09,759
and you put them off you you put them

790
00:46:06,339 --> 00:46:14,500
aside so respect a good analyzer enables

791
00:46:09,760 --> 00:46:15,970
you to to put them away for a while and

792
00:46:14,500 --> 00:46:18,310
start working with the new ones the most

793
00:46:15,970 --> 00:46:20,200
interesting thing is a new code which

794
00:46:18,310 --> 00:46:22,810
your team is right and at the moment you

795
00:46:20,200 --> 00:46:25,299
can always go back to a legacy code and

796
00:46:22,810 --> 00:46:26,710
you can correct it any any time because

797
00:46:25,300 --> 00:46:28,720
your project has been developing for

798
00:46:26,710 --> 00:46:31,359
many years and your old code is working

799
00:46:28,720 --> 00:46:33,700
yes you can you can make it perfect if

800
00:46:31,359 --> 00:46:37,569
you'll find time for this so you embed

801
00:46:33,700 --> 00:46:39,399
analyzer on a canvas integration to the

802
00:46:37,570 --> 00:46:43,060
collection service because you have to

803
00:46:39,400 --> 00:46:45,490
have some final point if your coders

804
00:46:43,060 --> 00:46:47,230
have found some mistakes at the assembly

805
00:46:45,490 --> 00:46:50,439
server during that night assemblies I

806
00:46:47,230 --> 00:46:51,690
let the analyzer again to go through

807
00:46:50,440 --> 00:46:53,579
your code

808
00:46:51,690 --> 00:46:56,220
but the most optimal optimal thing is to

809
00:46:53,579 --> 00:47:00,119
use SI st at your workplaces when a

810
00:46:56,220 --> 00:47:02,098
developer has written a code made some

811
00:47:00,119 --> 00:47:02,819
mistakes double-checked it and corrected

812
00:47:02,099 --> 00:47:05,280
it themselves

813
00:47:02,819 --> 00:47:07,109
the company has sustains no losses

814
00:47:05,280 --> 00:47:11,069
because there were no losses and the

815
00:47:07,109 --> 00:47:13,109
program is feeling great because if if

816
00:47:11,069 --> 00:47:16,170
their flows will go to the level of

817
00:47:13,109 --> 00:47:17,640
continuous integration then managers get

818
00:47:16,170 --> 00:47:19,880
all these notifications and messages

819
00:47:17,640 --> 00:47:22,410
that mr. such-and-such has made mistakes

820
00:47:19,880 --> 00:47:25,290
which is a redundancy works and couple

821
00:47:22,410 --> 00:47:28,859
more slides about losses whenever we

822
00:47:25,290 --> 00:47:31,020
have a vulnerability it's a certain

823
00:47:28,859 --> 00:47:32,819
algorithm or a sequence of what may be

824
00:47:31,020 --> 00:47:35,790
happening and this is how it is

825
00:47:32,819 --> 00:47:37,349
happening we have a vulnerability we

826
00:47:35,790 --> 00:47:41,779
have different losses correction some

827
00:47:37,349 --> 00:47:44,849
dates but if in this chain you you embed

828
00:47:41,780 --> 00:47:47,010
si st or any other instruments for

829
00:47:44,849 --> 00:47:49,770
minimizing mistakes and early detection

830
00:47:47,010 --> 00:47:52,170
this is what it looks like yes you have

831
00:47:49,770 --> 00:47:54,930
an error there are no programs without

832
00:47:52,170 --> 00:47:58,349
any errors but having fixed it you cut

833
00:47:54,930 --> 00:48:00,990
off all the possible problems including

834
00:47:58,349 --> 00:48:03,900
the real vulnerabilities and potential

835
00:48:00,990 --> 00:48:07,169
ones and it does work and we have to

836
00:48:03,900 --> 00:48:09,630
take advantage of that and some of the

837
00:48:07,170 --> 00:48:11,430
takeaways are one of the most obvious

838
00:48:09,630 --> 00:48:13,650
one you have to use all kind of

839
00:48:11,430 --> 00:48:15,598
technologies available even if I review

840
00:48:13,650 --> 00:48:17,160
I've been speaking about the code review

841
00:48:15,599 --> 00:48:18,750
in the very beginning it may not be the

842
00:48:17,160 --> 00:48:21,660
best technologist but it has some

843
00:48:18,750 --> 00:48:25,589
advantages you can you can train your

844
00:48:21,660 --> 00:48:27,629
juniors for example or or or

845
00:48:25,589 --> 00:48:30,170
double-check certain standards in your

846
00:48:27,630 --> 00:48:33,270
company and simply to look for errors so

847
00:48:30,170 --> 00:48:34,980
to look for any errors in the code using

848
00:48:33,270 --> 00:48:38,339
the code review is not efficient if you

849
00:48:34,980 --> 00:48:40,310
can afford and you have to go ahead and

850
00:48:38,339 --> 00:48:43,078
use all the instruments static and and

851
00:48:40,310 --> 00:48:45,089
dynamic analyzers which is very classy

852
00:48:43,079 --> 00:48:47,040
and good thing but you should not limit

853
00:48:45,089 --> 00:48:48,839
yourself only to these things use

854
00:48:47,040 --> 00:48:52,290
everything you can afford it's simpler

855
00:48:48,839 --> 00:48:55,170
one of the barriers on the way to errors

856
00:48:52,290 --> 00:48:57,190
and a company which today is trying to

857
00:48:55,170 --> 00:48:58,750
make money on it

858
00:48:57,190 --> 00:49:00,430
have to understand it and they have to

859
00:48:58,750 --> 00:49:02,710
use it otherwise they will not be

860
00:49:00,430 --> 00:49:04,930
competitive unfortunately in the modern

861
00:49:02,710 --> 00:49:07,260
realities this is the 80s thank you for

862
00:49:04,930 --> 00:49:07,259
your attention

