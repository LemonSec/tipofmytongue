1
00:00:03,580 --> 00:00:07,660
Nash first lady in the cloud Savoy near

2
00:00:06,279 --> 00:00:09,370
Nash of here pass leading in the cloud

3
00:00:07,660 --> 00:00:10,690
my convenience a boot shows the

4
00:00:09,370 --> 00:00:12,250
precision and slow monitoring the cloud

5
00:00:10,690 --> 00:00:14,410
not the same the cloud

6
00:00:12,250 --> 00:00:19,000
I play iSpy cryptography in NATO Tara's

7
00:00:14,410 --> 00:00:21,669
bra kakuta brother Raghu Drago aspect

8
00:00:19,000 --> 00:00:26,710
but when you observe dad's crackpot

9
00:00:21,669 --> 00:00:28,810
OpenSSL he up she cut it about

10
00:00:26,710 --> 00:00:30,220
you come ok secure software engineering

11
00:00:28,810 --> 00:00:32,379
Adama which there is about you said he

12
00:00:30,220 --> 00:00:35,829
means private sedan car a Suribachi come

13
00:00:32,380 --> 00:00:37,719
but the mean each really sad c-clip the

14
00:00:35,829 --> 00:00:38,920
perimeter biblioteca Kotori I knew who

15
00:00:37,719 --> 00:00:41,109
she is falsehood

16
00:00:38,920 --> 00:00:44,530
yes LuAnn is near to dosed of a column

17
00:00:41,109 --> 00:00:46,840
that the system as a roboticist emma in

18
00:00:44,530 --> 00:00:49,359
service Oh Tommy yes katate crypto

19
00:00:46,840 --> 00:00:51,489
Blaziken a premier OpenSSL yes the be

20
00:00:49,359 --> 00:00:55,390
pointless to lose my shot per minute

21
00:00:51,489 --> 00:00:58,780
kakoton emotionally to me Meadows picado

22
00:00:55,390 --> 00:01:02,190
a battle nebraska shot ignite security

23
00:00:58,780 --> 00:01:05,620
so challenging here combining CloudFlare

24
00:01:02,190 --> 00:01:08,649
Kotori iranian eras then he was a

25
00:01:05,620 --> 00:01:10,690
passion gamble necessary Caqueta career

26
00:01:08,650 --> 00:01:13,290
in the rosna the right of every

27
00:01:10,690 --> 00:01:13,289
wrestling matter

28
00:01:15,270 --> 00:01:20,890
Seba vividly present absolute ungli

29
00:01:19,120 --> 00:01:23,050
scheme is akia

30
00:01:20,890 --> 00:01:24,880
know if it's an evolution was not gain

31
00:01:23,050 --> 00:01:27,009
the strands of another table Natasha

32
00:01:24,880 --> 00:01:30,039
Hetty live pollution Ebola interiors nah

33
00:01:27,010 --> 00:01:32,170
yes I'll never say exactly one Matano

34
00:01:30,040 --> 00:01:34,420
conveniently cienaga compagnia sleep

35
00:01:32,170 --> 00:01:35,380
Adam prosthetic with boustrophedon

36
00:01:34,420 --> 00:01:37,630
Goulet Lana

37
00:01:35,380 --> 00:01:43,360
yes the community of master Gavrilov

38
00:01:37,630 --> 00:01:45,070
eating me up capito me pyl meet you had

39
00:01:43,360 --> 00:01:46,510
said but I was still nice precise

40
00:01:45,070 --> 00:01:53,139
Shapira what Oh

41
00:01:46,510 --> 00:01:54,730
Elita no she could be give me P 1 ok so

42
00:01:53,140 --> 00:01:56,710
today we're going to talk about life

43
00:01:54,730 --> 00:02:01,500
patching with crypto with open SSL

44
00:01:56,710 --> 00:02:07,419
engines so well who here doesn't know

45
00:02:01,500 --> 00:02:10,209
golfer who here have a website and

46
00:02:07,420 --> 00:02:15,000
doesn't know what cloud fur is oh really

47
00:02:10,209 --> 00:02:15,000
ok good otherwise you're missing out

48
00:02:15,040 --> 00:02:18,220
I worked at Crawford performance and

49
00:02:17,500 --> 00:02:21,690
security

50
00:02:18,220 --> 00:02:24,940
I like low-level stuff I'm dealing with

51
00:02:21,690 --> 00:02:28,030
open SSL crypto boot loaders Linux

52
00:02:24,940 --> 00:02:29,859
kernel and many other and in singing

53
00:02:28,030 --> 00:02:33,180
today I'm going to tell you about how to

54
00:02:29,860 --> 00:02:37,090
patch we crypto in your open SSL based

55
00:02:33,180 --> 00:02:40,959
proprietary tools why focus on open SSL

56
00:02:37,090 --> 00:02:44,230
because actually open SSL is very widely

57
00:02:40,959 --> 00:02:48,400
used like some statistics say that 80%

58
00:02:44,230 --> 00:02:50,379
of the software crypto tools are using

59
00:02:48,400 --> 00:02:52,239
open SSL so also we're limiting

60
00:02:50,379 --> 00:02:54,940
ourselves to a single crypto library

61
00:02:52,239 --> 00:02:58,060
were actually covering a wide specter of

62
00:02:54,940 --> 00:02:59,950
software okay so what does it mean we

63
00:02:58,060 --> 00:03:02,739
crypto like what is the difference

64
00:02:59,950 --> 00:03:04,660
between weak and strong crypto and

65
00:03:02,739 --> 00:03:07,090
because this is a final talk I will not

66
00:03:04,660 --> 00:03:09,010
bore you with formulas and math I'll

67
00:03:07,090 --> 00:03:13,030
just have this simple picture with this

68
00:03:09,010 --> 00:03:15,940
place we crypto so this is your house it

69
00:03:13,030 --> 00:03:20,590
looks like it's secure it does the fact

70
00:03:15,940 --> 00:03:23,019
but if your attacker has sufficient

71
00:03:20,590 --> 00:03:26,169
resources they can just blow away your

72
00:03:23,019 --> 00:03:28,900
security in like that versus like strong

73
00:03:26,169 --> 00:03:31,269
crypto is is a brick house right so no

74
00:03:28,900 --> 00:03:34,090
matter how hard the attacker tries over

75
00:03:31,269 --> 00:03:39,130
time you're still secure and they they

76
00:03:34,090 --> 00:03:41,859
just can break so this is like like okay

77
00:03:39,130 --> 00:03:43,418
so there is weak crypto is bad strong

78
00:03:41,859 --> 00:03:44,919
crypto is good like why do people

79
00:03:43,419 --> 00:03:48,040
usually group them in the first place

80
00:03:44,919 --> 00:03:50,260
and there are a couple of reasons like

81
00:03:48,040 --> 00:03:52,269
some of them like developers do not know

82
00:03:50,260 --> 00:03:54,790
what to use not all of us are crypto

83
00:03:52,269 --> 00:03:57,250
engineers the crypto experts and when

84
00:03:54,790 --> 00:03:59,500
you go to open SSL you see a wide range

85
00:03:57,250 --> 00:04:01,209
of choice of algorithms you can pick

86
00:03:59,500 --> 00:04:03,250
from and you just don't know what to

87
00:04:01,209 --> 00:04:05,049
pick and if you do pick an algorithm

88
00:04:03,250 --> 00:04:07,419
there is also like these additional

89
00:04:05,049 --> 00:04:09,840
parameters like initialization vectors

90
00:04:07,419 --> 00:04:12,190
we just seen that they have to be unique

91
00:04:09,840 --> 00:04:14,799
requirements to them so people just do

92
00:04:12,190 --> 00:04:18,010
not know what to do like some people

93
00:04:14,799 --> 00:04:20,199
select ECB mode just because it doesn't

94
00:04:18,010 --> 00:04:21,699
require any initialization vector

95
00:04:20,199 --> 00:04:23,950
because they don't know what to put

96
00:04:21,699 --> 00:04:27,340
there right there is also these

97
00:04:23,950 --> 00:04:29,080
government regulations this in famous US

98
00:04:27,340 --> 00:04:32,549
export cryptography were free

99
00:04:29,080 --> 00:04:34,900
really in the 90s united states allowed

100
00:04:32,550 --> 00:04:38,710
exporting cryptography was very weak

101
00:04:34,900 --> 00:04:41,770
wikis not more than 40 bit entropy which

102
00:04:38,710 --> 00:04:44,859
is basically no crypto is we crypto it

103
00:04:41,770 --> 00:04:47,229
can be blown away and you can't do

104
00:04:44,860 --> 00:04:49,780
anything about it and and finally a

105
00:04:47,229 --> 00:04:53,409
strong crypto actually becomes weak over

106
00:04:49,780 --> 00:04:57,159
time so first of all here is some advice

107
00:04:53,409 --> 00:04:59,319
if you don't know what to use we've been

108
00:04:57,159 --> 00:05:01,569
repeating here over and over never roll

109
00:04:59,319 --> 00:05:04,629
or your own crypto and not only don't

110
00:05:01,569 --> 00:05:08,050
invent your own algorithm if you even

111
00:05:04,629 --> 00:05:10,469
pick the algorithm like available

112
00:05:08,050 --> 00:05:13,240
algorithm but not know exactly how to

113
00:05:10,469 --> 00:05:13,719
generate a proper IV or something like

114
00:05:13,240 --> 00:05:16,979
that

115
00:05:13,719 --> 00:05:20,259
don't guess just ask people for help

116
00:05:16,979 --> 00:05:23,740
don't copy/paste from other projects on

117
00:05:20,259 --> 00:05:26,860
the internet from Stack Overflow this is

118
00:05:23,740 --> 00:05:29,020
basically because they might didn't know

119
00:05:26,860 --> 00:05:30,849
what to use as well so they say choice

120
00:05:29,020 --> 00:05:33,389
may be wrong they might have a different

121
00:05:30,849 --> 00:05:36,969
use case and in their implementation

122
00:05:33,389 --> 00:05:38,440
this choice is good and the system is

123
00:05:36,969 --> 00:05:42,550
secure but in your case it will be

124
00:05:38,440 --> 00:05:44,830
insecure right and finally don't try to

125
00:05:42,550 --> 00:05:47,589
use low level primitives if you really

126
00:05:44,830 --> 00:05:49,810
don't know what to use you better not

127
00:05:47,589 --> 00:05:51,969
use like low level crypto libraries but

128
00:05:49,810 --> 00:05:55,139
pick a high level crypto libraries which

129
00:05:51,969 --> 00:05:58,419
provides you as some use case based

130
00:05:55,139 --> 00:06:00,190
primitives for example if you need file

131
00:05:58,419 --> 00:06:01,930
encryption pick a library which says

132
00:06:00,190 --> 00:06:05,319
here is a function to securely encrypted

133
00:06:01,930 --> 00:06:07,990
file and under the knees this function

134
00:06:05,319 --> 00:06:10,360
will make proper security choices for

135
00:06:07,990 --> 00:06:12,669
you so some of the examples us time is

136
00:06:10,360 --> 00:06:16,089
from kazakh labs which I helped to

137
00:06:12,669 --> 00:06:20,289
actually bootstrap lit sodium or Google

138
00:06:16,089 --> 00:06:22,289
ting so why strong crypto becomes weak

139
00:06:20,289 --> 00:06:27,339
over time there are basically two

140
00:06:22,289 --> 00:06:29,770
reasons first one is just there is the

141
00:06:27,339 --> 00:06:32,979
research is ongoing and people come up

142
00:06:29,770 --> 00:06:37,448
with new algorithms how to break crypto

143
00:06:32,979 --> 00:06:39,159
so a these algorithms were secure in the

144
00:06:37,449 --> 00:06:40,560
past but now a new techniques were

145
00:06:39,159 --> 00:06:43,830
developed which

146
00:06:40,560 --> 00:06:46,410
ALPA help the attackers to more

147
00:06:43,830 --> 00:06:49,680
efficiently crack the algorithm this is

148
00:06:46,410 --> 00:06:53,690
basic science and second is is just pure

149
00:06:49,680 --> 00:06:56,520
rapid technological advancement so

150
00:06:53,690 --> 00:06:58,469
computing power becomes cheap resources

151
00:06:56,520 --> 00:07:01,770
become cheap now we have the technology

152
00:06:58,470 --> 00:07:04,139
to combine many small computers and the

153
00:07:01,770 --> 00:07:06,060
big clusters and we have access to

154
00:07:04,139 --> 00:07:08,820
tremendous resource which we can reuse

155
00:07:06,060 --> 00:07:10,590
to crack algorithms also there is life

156
00:07:08,820 --> 00:07:12,630
and this is like evolutional there is

157
00:07:10,590 --> 00:07:15,000
also the revolution all parts something

158
00:07:12,630 --> 00:07:17,219
like quantum computers somebody builds a

159
00:07:15,000 --> 00:07:19,169
quantum computer elliptic curve

160
00:07:17,220 --> 00:07:21,050
cryptography which is today is

161
00:07:19,169 --> 00:07:23,430
considered the state of the art of

162
00:07:21,050 --> 00:07:27,690
cryptography will be completely broken

163
00:07:23,430 --> 00:07:30,360
so like crypto become even strong crypto

164
00:07:27,690 --> 00:07:32,490
at some point will become weak and then

165
00:07:30,360 --> 00:07:35,419
you need to do crypto maintenance you

166
00:07:32,490 --> 00:07:40,350
need to replace it all right

167
00:07:35,419 --> 00:07:44,430
so what do you do but replacing crypto

168
00:07:40,350 --> 00:07:46,169
is not that easy right so if you develop

169
00:07:44,430 --> 00:07:47,580
your own product if you have your own

170
00:07:46,169 --> 00:07:49,890
software you kind of change the

171
00:07:47,580 --> 00:07:51,840
algorithms but get some advice and

172
00:07:49,890 --> 00:07:54,950
replace the weak crypto with strong

173
00:07:51,840 --> 00:07:57,869
crypto but many of us are using services

174
00:07:54,950 --> 00:08:01,770
proprietary tools vendors and external

175
00:07:57,870 --> 00:08:04,110
sources and you don't always have the

176
00:08:01,770 --> 00:08:06,240
opportunity just go and swap algorithms

177
00:08:04,110 --> 00:08:08,250
and then you go to the to your vendor

178
00:08:06,240 --> 00:08:10,560
but vendor is either slow they will say

179
00:08:08,250 --> 00:08:12,210
yeah yeah we'll update it in the next

180
00:08:10,560 --> 00:08:15,479
release cycle and it will be in a year

181
00:08:12,210 --> 00:08:17,370
or they don't want to do it you also

182
00:08:15,479 --> 00:08:19,680
have the problem of abandoned software

183
00:08:17,370 --> 00:08:22,350
you have the problem of software which

184
00:08:19,680 --> 00:08:24,450
has no source code available the source

185
00:08:22,350 --> 00:08:26,550
code was lost and there are also

186
00:08:24,450 --> 00:08:28,500
additional cost Van Dorma say yeah we'll

187
00:08:26,550 --> 00:08:31,200
do it but we consider it a feature

188
00:08:28,500 --> 00:08:34,049
request so pay us additional two million

189
00:08:31,200 --> 00:08:37,409
dollars to do that it's not always great

190
00:08:34,049 --> 00:08:39,390
right so let's imagine we're in such a

191
00:08:37,409 --> 00:08:42,599
scenario alright so we have a

192
00:08:39,390 --> 00:08:45,990
proprietary system but it's an open SSL

193
00:08:42,599 --> 00:08:49,650
which uses with crypto and we want to

194
00:08:45,990 --> 00:08:51,690
replace it right so what is the system

195
00:08:49,650 --> 00:08:53,949
let's imagine islem some kind of

196
00:08:51,690 --> 00:08:56,589
proprietary storage solution

197
00:08:53,950 --> 00:08:58,240
it's either relational database or an

198
00:08:56,589 --> 00:09:02,620
object storage but it doesn't matter in

199
00:08:58,240 --> 00:09:06,100
this case the key point is that it index

200
00:09:02,620 --> 00:09:09,070
its data or objects it stores by a hash

201
00:09:06,100 --> 00:09:11,410
function so it creates an index of an

202
00:09:09,070 --> 00:09:13,630
object by a hash function and uses

203
00:09:11,410 --> 00:09:15,370
OpenSSL as the crypto back-end to

204
00:09:13,630 --> 00:09:17,470
actually take this hash function and

205
00:09:15,370 --> 00:09:20,070
permutation so you're good you bought

206
00:09:17,470 --> 00:09:24,480
this software for great amount of money

207
00:09:20,070 --> 00:09:26,980
and you use it for two years and later a

208
00:09:24,480 --> 00:09:30,010
at some point later you invite a

209
00:09:26,980 --> 00:09:31,600
so-called external audit which is the

210
00:09:30,010 --> 00:09:37,630
guys who presented on the stage

211
00:09:31,600 --> 00:09:40,630
yesterday right and they like you asked

212
00:09:37,630 --> 00:09:44,800
what's happened like say you're using

213
00:09:40,630 --> 00:09:48,550
sha-1 and say yeah so what and didn't

214
00:09:44,800 --> 00:09:52,000
you hear about this this everyone know

215
00:09:48,550 --> 00:09:54,310
that this is even an old stuff there is

216
00:09:52,000 --> 00:09:56,829
new stuff coming up now and like the

217
00:09:54,310 --> 00:09:58,599
TLDR of this is like we have broken

218
00:09:56,829 --> 00:10:01,510
sha-1 in practice you go to this website

219
00:09:58,600 --> 00:10:05,470
and you will see the first line and yeah

220
00:10:01,510 --> 00:10:07,300
yeah and if the auditors say if you

221
00:10:05,470 --> 00:10:10,240
don't fix it in two weeks you will lose

222
00:10:07,300 --> 00:10:12,939
your compliance right you go to your

223
00:10:10,240 --> 00:10:14,529
vendor and say please replace your one

224
00:10:12,940 --> 00:10:17,890
but the vendor will usually say like

225
00:10:14,529 --> 00:10:19,839
yeah this is fine if you read the paper

226
00:10:17,890 --> 00:10:21,850
they say the shamon broken in these

227
00:10:19,839 --> 00:10:24,519
cases but in these cases it is still

228
00:10:21,850 --> 00:10:27,100
secure we believe that we're not

229
00:10:24,519 --> 00:10:29,740
vulnerable will like or we will need

230
00:10:27,100 --> 00:10:31,959
like two years to do it right and use

231
00:10:29,740 --> 00:10:38,890
somehow to have to deal with that so

232
00:10:31,959 --> 00:10:42,430
yeah okay we'll do it ourselves right so

233
00:10:38,890 --> 00:10:43,899
to understand how to patch proprietary

234
00:10:42,430 --> 00:10:46,000
software you have to understand how

235
00:10:43,899 --> 00:10:48,279
shared libraries work because most

236
00:10:46,000 --> 00:10:50,260
likely hopefully they will use shared

237
00:10:48,279 --> 00:10:54,160
libraries so imagine you have two

238
00:10:50,260 --> 00:10:58,029
processes you have like a privacy client

239
00:10:54,160 --> 00:11:01,350
and you have a database so any by the

240
00:10:58,029 --> 00:11:04,290
way any resemblance to real software is

241
00:11:01,350 --> 00:11:06,699
coincidental so yeah and they both use

242
00:11:04,290 --> 00:11:07,839
requires some cryptographic services

243
00:11:06,699 --> 00:11:10,779
they need cryptography

244
00:11:07,840 --> 00:11:12,490
and what the shelter is does it provides

245
00:11:10,779 --> 00:11:14,910
these services so you have a library

246
00:11:12,490 --> 00:11:18,910
says yeah I have this cryptography and

247
00:11:14,910 --> 00:11:21,219
software uses it it's cool it's what

248
00:11:18,910 --> 00:11:24,010
makes it here it is that the shelter at

249
00:11:21,220 --> 00:11:25,720
libraries libraries which are not part

250
00:11:24,010 --> 00:11:27,730
of the main application they are more

251
00:11:25,720 --> 00:11:30,820
like a separate package and they're

252
00:11:27,730 --> 00:11:33,250
dynamically linked in runtime the code

253
00:11:30,820 --> 00:11:36,670
is shared between programs that's why

254
00:11:33,250 --> 00:11:38,890
they're called shell rivalries the nice

255
00:11:36,670 --> 00:11:41,560
part about shared libraries is the code

256
00:11:38,890 --> 00:11:44,319
is loaded only once in the memory so if

257
00:11:41,560 --> 00:11:46,329
you have like 10,000 processes which

258
00:11:44,320 --> 00:11:49,690
need open SSL you have only one copy of

259
00:11:46,330 --> 00:11:52,839
open SSL and because it's not part of

260
00:11:49,690 --> 00:11:54,790
the main application you can update them

261
00:11:52,839 --> 00:11:56,890
independently so you can update your

262
00:11:54,790 --> 00:11:59,170
open SSL and all the application

263
00:11:56,890 --> 00:12:03,520
requiring it will magically use the

264
00:11:59,170 --> 00:12:05,500
updated version which is cool so let's I

265
00:12:03,520 --> 00:12:07,630
know I told you that the software is

266
00:12:05,500 --> 00:12:09,970
proprietary but let's imagine where

267
00:12:07,630 --> 00:12:11,680
sneak peeking on the vendor side and we

268
00:12:09,970 --> 00:12:13,450
kind of see the source code so you have

269
00:12:11,680 --> 00:12:15,989
the basic understanding what's going on

270
00:12:13,450 --> 00:12:19,240
and this is our stripped-down

271
00:12:15,990 --> 00:12:21,130
proprietary database I will only

272
00:12:19,240 --> 00:12:23,410
implementing the hash part here the

273
00:12:21,130 --> 00:12:26,500
index calculation and this is basically

274
00:12:23,410 --> 00:12:29,140
a common line tool which calculates the

275
00:12:26,500 --> 00:12:33,160
hash of a file simple as that and this

276
00:12:29,140 --> 00:12:35,680
is a main function I will will have

277
00:12:33,160 --> 00:12:37,449
several iterations of the tool but all

278
00:12:35,680 --> 00:12:40,599
of them will have the same main function

279
00:12:37,450 --> 00:12:43,930
form showing them only once and so the

280
00:12:40,600 --> 00:12:45,820
main function just takes a file as a sea

281
00:12:43,930 --> 00:12:48,489
level file object and passes to a

282
00:12:45,820 --> 00:12:51,220
function called hash and then the

283
00:12:48,490 --> 00:12:54,310
different implementation calculate the

284
00:12:51,220 --> 00:12:56,860
hash so the first iteration of the two

285
00:12:54,310 --> 00:12:59,770
you received looks like this if you're

286
00:12:56,860 --> 00:13:02,980
not very good at digesting C code I will

287
00:12:59,770 --> 00:13:05,140
quickly go through what what's happening

288
00:13:02,980 --> 00:13:08,260
so first of all what you have here is

289
00:13:05,140 --> 00:13:11,050
you have a fixed buffer you read all the

290
00:13:08,260 --> 00:13:15,069
file into the buffer and then you call

291
00:13:11,050 --> 00:13:17,229
open SSL with sha-1 calculate the hash

292
00:13:15,070 --> 00:13:21,510
of the buffer and then print the result

293
00:13:17,230 --> 00:13:24,870
easy right let's check if it works by

294
00:13:21,510 --> 00:13:26,850
this supposed to be a demo and I really

295
00:13:24,870 --> 00:13:29,459
promise you this was copied from a real

296
00:13:26,850 --> 00:13:31,769
terminal but like the visibility is much

297
00:13:29,459 --> 00:13:34,949
better so pretend this is a real demo

298
00:13:31,769 --> 00:13:37,829
right so yeah let's try like Lex hack

299
00:13:34,949 --> 00:13:40,649
ABC using our custom tool we see some

300
00:13:37,829 --> 00:13:42,989
hash and we may suspect it's sha-1

301
00:13:40,649 --> 00:13:45,990
because we were told by auditors so

302
00:13:42,990 --> 00:13:47,910
let's check it with cross-check it with

303
00:13:45,990 --> 00:13:52,410
a well-known implementation right so you

304
00:13:47,910 --> 00:13:56,510
can also hash ABC in the sha-1 some tool

305
00:13:52,410 --> 00:13:59,430
and you'll see the same output right and

306
00:13:56,510 --> 00:14:02,399
using the LPP common you can also check

307
00:13:59,430 --> 00:14:04,709
which libraries this tool needs so if

308
00:14:02,399 --> 00:14:06,930
you run led custom hash you will see

309
00:14:04,709 --> 00:14:11,160
that this tool requires open SSL which

310
00:14:06,930 --> 00:14:15,870
is called lip crypto in Linux usually ok

311
00:14:11,160 --> 00:14:17,969
so how to understand this swap apart we

312
00:14:15,870 --> 00:14:19,709
need to understand the lazy binding on

313
00:14:17,970 --> 00:14:22,649
the shared libraries so let's say you

314
00:14:19,709 --> 00:14:26,099
have a process you start the process how

315
00:14:22,649 --> 00:14:28,980
does the process find functionality in

316
00:14:26,100 --> 00:14:31,769
the shared libraries so the first thing

317
00:14:28,980 --> 00:14:33,420
the process does is process talk to a

318
00:14:31,769 --> 00:14:35,579
special piece of software on your

319
00:14:33,420 --> 00:14:39,599
opening or operating system which called

320
00:14:35,579 --> 00:14:41,910
dynamic loader it doesn't actually talk

321
00:14:39,600 --> 00:14:44,790
it's actually the dynamic loader reads

322
00:14:41,910 --> 00:14:47,459
the image of the executable and finds

323
00:14:44,790 --> 00:14:49,889
out which libraries does it need then

324
00:14:47,459 --> 00:14:52,849
the dynamic loader will load all the

325
00:14:49,889 --> 00:14:56,279
libraries needed for the process and

326
00:14:52,850 --> 00:14:58,800
that's it nothing happens and the

327
00:14:56,279 --> 00:15:01,589
process starts executing so no function

328
00:14:58,800 --> 00:15:03,870
resolving happens at this stage later

329
00:15:01,589 --> 00:15:06,660
that's why it's called lazy binding when

330
00:15:03,870 --> 00:15:10,290
the process needs to calculate the hash

331
00:15:06,660 --> 00:15:12,439
it needs the sha-1 it talks to dynamic

332
00:15:10,290 --> 00:15:17,339
loader again says hey I need the sha-1

333
00:15:12,440 --> 00:15:20,579
where is my sha-1 and so and the dynamic

334
00:15:17,339 --> 00:15:23,550
loader says a cool view libraries has

335
00:15:20,579 --> 00:15:26,388
sha-1 here and most likely one of the

336
00:15:23,550 --> 00:15:31,069
library will say yeah I have sha-1 and

337
00:15:26,389 --> 00:15:31,069
then the process can use show on

338
00:15:33,410 --> 00:15:39,879
and in this case usually if you compile

339
00:15:36,769 --> 00:15:43,190
your program normally for each function

340
00:15:39,879 --> 00:15:44,959
you will have at most one library which

341
00:15:43,190 --> 00:15:48,529
is implementing it so although the

342
00:15:44,959 --> 00:15:51,109
dynamic lawyer asks who has usually only

343
00:15:48,529 --> 00:15:53,089
one library will respond right but you

344
00:15:51,110 --> 00:15:56,839
can change that and the way how you do

345
00:15:53,089 --> 00:16:00,290
it you can use this magic environment

346
00:15:56,839 --> 00:16:04,459
variable called LD preload who doesn't

347
00:16:00,290 --> 00:16:07,189
know what LD preload does okay there are

348
00:16:04,459 --> 00:16:10,189
people soil I'll describe it yeah so LD

349
00:16:07,189 --> 00:16:13,310
preload tells your dynamic loader or

350
00:16:10,189 --> 00:16:15,889
linker to load additional libraries into

351
00:16:13,310 --> 00:16:20,359
the process space which are not even

352
00:16:15,889 --> 00:16:22,160
required by the process right and why

353
00:16:20,360 --> 00:16:24,500
it's called preload these libraries are

354
00:16:22,160 --> 00:16:26,389
law that before even all the main code

355
00:16:24,500 --> 00:16:29,350
is loaded in the memory so it's the

356
00:16:26,389 --> 00:16:33,259
first thing your program gets and

357
00:16:29,350 --> 00:16:36,800
they're mostly useful to override modify

358
00:16:33,259 --> 00:16:40,069
hook or tap exported functions from

359
00:16:36,800 --> 00:16:42,050
shared libraries if you want to read

360
00:16:40,069 --> 00:16:44,569
more here is the link on the Linux Monde

361
00:16:42,050 --> 00:16:47,630
pages on the dynamic law doorman page

362
00:16:44,569 --> 00:16:50,719
actually so when you use the final deep

363
00:16:47,630 --> 00:16:53,509
reward you change a picture slightly so

364
00:16:50,720 --> 00:16:56,620
the program didn't even start but the

365
00:16:53,509 --> 00:16:59,779
dynamic loader or already loaded your

366
00:16:56,620 --> 00:17:03,290
custom library then the usual things

367
00:16:59,779 --> 00:17:06,260
happens it checks which libraries does

368
00:17:03,290 --> 00:17:09,020
application needs Lourdes libraries then

369
00:17:06,260 --> 00:17:11,929
at some point when the program needs the

370
00:17:09,020 --> 00:17:13,750
sha-1 implementation it goes to dynamic

371
00:17:11,929 --> 00:17:15,860
loader ask hey who has chuang

372
00:17:13,750 --> 00:17:18,289
implementation the dynamic load acquires

373
00:17:15,859 --> 00:17:20,990
all the libraries but now two libraries

374
00:17:18,289 --> 00:17:24,280
response we have sha-1 if you implement

375
00:17:20,990 --> 00:17:27,260
another sha-1 in your library right and

376
00:17:24,280 --> 00:17:29,389
the magic of the loader will go it will

377
00:17:27,260 --> 00:17:31,549
divert the program to the first library

378
00:17:29,390 --> 00:17:34,340
which was loaded and because we use the

379
00:17:31,549 --> 00:17:37,010
leap reload our library was loaded first

380
00:17:34,340 --> 00:17:39,139
right so the program will then go to our

381
00:17:37,010 --> 00:17:43,789
library for sha-1 and not to the

382
00:17:39,140 --> 00:17:46,070
standard OpenSSL one so now we just need

383
00:17:43,789 --> 00:17:46,760
to figure out we have a way to hook

384
00:17:46,070 --> 00:17:49,129
function

385
00:17:46,760 --> 00:17:52,280
on OpenSSL now we need to figure out

386
00:17:49,130 --> 00:17:55,640
what to hook right and we can do some

387
00:17:52,280 --> 00:17:58,129
symbol analysis on the on the executive

388
00:17:55,640 --> 00:18:01,070
ball and we can see that it requires two

389
00:17:58,130 --> 00:18:02,809
functions from OpenSSL if you then you

390
00:18:01,070 --> 00:18:04,700
go to read the descriptions of the

391
00:18:02,809 --> 00:18:06,830
function and then you try to understand

392
00:18:04,700 --> 00:18:08,990
how to hook it in eventually you will

393
00:18:06,830 --> 00:18:11,720
come up something like that so you will

394
00:18:08,990 --> 00:18:13,880
write your own library with the function

395
00:18:11,720 --> 00:18:16,600
with the same name as the OpenSSL

396
00:18:13,880 --> 00:18:19,700
function but you will override the code

397
00:18:16,600 --> 00:18:21,469
the typical approach for hooking the

398
00:18:19,700 --> 00:18:23,480
function is you you don't want to

399
00:18:21,470 --> 00:18:25,100
override the function completely you at

400
00:18:23,480 --> 00:18:27,080
some point you want to do just some

401
00:18:25,100 --> 00:18:29,178
pre-processing and post-processing and

402
00:18:27,080 --> 00:18:31,399
at some point you want to call to use

403
00:18:29,179 --> 00:18:33,890
the real function so the first thing you

404
00:18:31,400 --> 00:18:36,049
do you resolve you find the address of

405
00:18:33,890 --> 00:18:40,790
the real OpenSSL function so you can use

406
00:18:36,049 --> 00:18:42,379
it later right then you do your magic

407
00:18:40,790 --> 00:18:45,110
you do a pre-processing magic and in

408
00:18:42,380 --> 00:18:48,169
this case what we do is if the caller

409
00:18:45,110 --> 00:18:51,320
calls us and ask us to calculate sha-1

410
00:18:48,169 --> 00:18:54,020
hash we actually call back the real

411
00:18:51,320 --> 00:18:59,480
OpenSSL implementation but replace the

412
00:18:54,020 --> 00:19:01,549
identifier from sha-1 to shut 256 and we

413
00:18:59,480 --> 00:19:04,669
also add some debugging output in this

414
00:19:01,549 --> 00:19:06,770
case just to ensure our code runs so we

415
00:19:04,669 --> 00:19:09,410
can see it and finally what we need to

416
00:19:06,770 --> 00:19:13,129
do we need to remember that sha-1 is

417
00:19:09,410 --> 00:19:16,130
shorter than shut 256 so sha-1 is 20

418
00:19:13,130 --> 00:19:18,080
bytes chapter 56 is 32 bytes so we can't

419
00:19:16,130 --> 00:19:21,260
just return to the color 32 bytes

420
00:19:18,080 --> 00:19:23,840
because they might not expect they might

421
00:19:21,260 --> 00:19:26,450
not have a buffer large enough to hold

422
00:19:23,840 --> 00:19:29,750
32 bytes so we just cut the buffer to 20

423
00:19:26,450 --> 00:19:31,850
bytes right so let's see how it works we

424
00:19:29,750 --> 00:19:35,150
can buy a compile this code into a

425
00:19:31,850 --> 00:19:38,290
shared library of our own and we start

426
00:19:35,150 --> 00:19:40,850
the process specifying the LD preload

427
00:19:38,290 --> 00:19:43,280
environment variable and 22 our library

428
00:19:40,850 --> 00:19:45,678
now we see the our debug output and we

429
00:19:43,280 --> 00:19:47,629
see a slightly different hash we can

430
00:19:45,679 --> 00:19:49,220
cross-check it with a real sha-256

431
00:19:47,630 --> 00:19:51,020
implementation and we will see they

432
00:19:49,220 --> 00:19:53,720
match so we now successfully replaced

433
00:19:51,020 --> 00:19:58,220
shall 1 which are 256 although like with

434
00:19:53,720 --> 00:19:59,870
carrot good so what we did here

435
00:19:58,220 --> 00:20:02,210
eventually

436
00:19:59,870 --> 00:20:06,979
these pictures so we had our custom tool

437
00:20:02,210 --> 00:20:09,470
it used a function from OpenSSL we just

438
00:20:06,980 --> 00:20:12,230
cut off this connection and divert it to

439
00:20:09,470 --> 00:20:16,279
our custom library which does two things

440
00:20:12,230 --> 00:20:18,950
it replace the identifier to shut 256 so

441
00:20:16,279 --> 00:20:21,140
it tells OpenSSL calculate our 256

442
00:20:18,950 --> 00:20:23,210
instead of sha-1 and then cuts the

443
00:20:21,140 --> 00:20:28,070
result back to 20 bytes not to confuse

444
00:20:23,210 --> 00:20:30,260
the calling application if you were

445
00:20:28,070 --> 00:20:33,139
attempting enough you'll notice that the

446
00:20:30,260 --> 00:20:34,970
previous vendor tools had a flaw it had

447
00:20:33,140 --> 00:20:38,539
a fixed buffer on the stack which was

448
00:20:34,970 --> 00:20:41,690
only four kilobytes so it means that

449
00:20:38,539 --> 00:20:43,940
they the two cannot calculate the hash

450
00:20:41,690 --> 00:20:45,409
of files more than two kilobytes right

451
00:20:43,940 --> 00:20:48,140
because it reads the whole file in the

452
00:20:45,409 --> 00:20:50,179
buffer and calculates the hash of the

453
00:20:48,140 --> 00:20:52,580
buffer and this is a bug and you might

454
00:20:50,179 --> 00:20:54,890
reported it to the vendor you might find

455
00:20:52,580 --> 00:20:59,510
it out and they they fix it right they

456
00:20:54,890 --> 00:21:02,059
modify the code to calculate hashes of

457
00:20:59,510 --> 00:21:04,610
files of arbitrary size but they need to

458
00:21:02,059 --> 00:21:07,549
change their program so instead of

459
00:21:04,610 --> 00:21:10,309
calculating hash in one call from a

460
00:21:07,549 --> 00:21:12,710
buffer they switch the implementation to

461
00:21:10,309 --> 00:21:15,399
use a so called cache interactive mode

462
00:21:12,710 --> 00:21:18,140
so they basically create a hash object

463
00:21:15,399 --> 00:21:20,479
they read the file by chunks and feed

464
00:21:18,140 --> 00:21:23,090
these chunks into this if to iteratively

465
00:21:20,480 --> 00:21:26,679
into this hash object and then finally

466
00:21:23,090 --> 00:21:29,928
they get the result and print it right

467
00:21:26,679 --> 00:21:31,520
but now when we ask the vendor to fix

468
00:21:29,929 --> 00:21:33,679
the bug they fix the bug they provided

469
00:21:31,520 --> 00:21:35,450
the update our fees does not work

470
00:21:33,679 --> 00:21:39,080
anymore so we don't see the debug output

471
00:21:35,450 --> 00:21:41,210
and if you good at remembering numbers

472
00:21:39,080 --> 00:21:46,100
you will remember that this is a how one

473
00:21:41,210 --> 00:21:48,799
hash of ABC not sha-256 right so what

474
00:21:46,100 --> 00:21:51,020
happened here is we'd no longer

475
00:21:48,799 --> 00:21:53,539
intercept the function calls and because

476
00:21:51,020 --> 00:21:55,730
they change the implementation although

477
00:21:53,539 --> 00:21:57,860
they didn't change the interface and now

478
00:21:55,730 --> 00:22:00,140
they're using different functions we're

479
00:21:57,860 --> 00:22:03,350
hooking one functions but they use

480
00:22:00,140 --> 00:22:08,830
different functions from OpenSSL so we

481
00:22:03,350 --> 00:22:11,780
need to fix our fix right so instead of

482
00:22:08,830 --> 00:22:13,789
our fix we now need to hook two

483
00:22:11,780 --> 00:22:16,759
functions again

484
00:22:13,789 --> 00:22:20,059
as before we resolve the addresses of

485
00:22:16,759 --> 00:22:21,559
the real OpenSSL functions then secondly

486
00:22:20,059 --> 00:22:24,109
in the first function we'll replace the

487
00:22:21,559 --> 00:22:27,859
intent afire from sha-1 to shatter 56

488
00:22:24,109 --> 00:22:30,080
and in the final function we provide our

489
00:22:27,859 --> 00:22:33,049
own buffer and cut the result to 20

490
00:22:30,080 --> 00:22:36,379
bytes to return to the caller add our

491
00:22:33,049 --> 00:22:38,479
debug output ya and return to the caller

492
00:22:36,379 --> 00:22:44,090
our cut-down

493
00:22:38,479 --> 00:22:48,039
ash let's try if it works now yeah we

494
00:22:44,090 --> 00:22:53,649
see the debug output we see the shot 256

495
00:22:48,039 --> 00:22:56,899
so we're good again right but the vendor

496
00:22:53,649 --> 00:23:00,408
again doesn't update so they hired a new

497
00:22:56,899 --> 00:23:03,109
engineer which says nobody calls in open

498
00:23:00,409 --> 00:23:05,359
SSL like hash functions directly they

499
00:23:03,109 --> 00:23:08,109
have these nice abstractions called bio

500
00:23:05,359 --> 00:23:11,299
which stands for basic input/output

501
00:23:08,109 --> 00:23:13,460
which obstructs anything to a stream and

502
00:23:11,299 --> 00:23:16,309
you can stack streams on top so you can

503
00:23:13,460 --> 00:23:19,999
have more much nicer implementation you

504
00:23:16,309 --> 00:23:22,309
can and the abstract the file is a

505
00:23:19,999 --> 00:23:25,099
stream you abstract after system then

506
00:23:22,309 --> 00:23:27,229
you like yeah so you could create two

507
00:23:25,099 --> 00:23:30,109
streams one is files to be one is hash

508
00:23:27,229 --> 00:23:32,599
stream then you stack them together then

509
00:23:30,109 --> 00:23:34,580
you just read from the stream and in

510
00:23:32,599 --> 00:23:36,918
this in the same function call you are

511
00:23:34,580 --> 00:23:38,899
reading a file and calculating the hash

512
00:23:36,919 --> 00:23:42,769
at the same time it looks much nicer

513
00:23:38,899 --> 00:23:46,969
let's use this yeah we just return the

514
00:23:42,769 --> 00:23:48,679
result does it koala when they deliver

515
00:23:46,970 --> 00:23:51,619
their base of course our fix doesn't

516
00:23:48,679 --> 00:23:53,659
work anymore because again they modified

517
00:23:51,619 --> 00:23:55,340
the functions right if we analyze now

518
00:23:53,659 --> 00:23:58,609
they're using complete different set of

519
00:23:55,340 --> 00:24:02,238
functions which we never hook so we need

520
00:23:58,609 --> 00:24:04,939
to fix it again so we create another fix

521
00:24:02,239 --> 00:24:07,340
for our fix we hook different functions

522
00:24:04,940 --> 00:24:10,009
names but we basically the approach is

523
00:24:07,340 --> 00:24:14,119
the same you find the real functions you

524
00:24:10,009 --> 00:24:16,220
replace the ID you print our debug

525
00:24:14,119 --> 00:24:18,408
output and you return the stripped-down

526
00:24:16,220 --> 00:24:21,320
result of the caller right so let's

527
00:24:18,409 --> 00:24:26,659
check if it works again yeah it works

528
00:24:21,320 --> 00:24:27,790
now good but this is just like a wacky

529
00:24:26,659 --> 00:24:30,280
race right like

530
00:24:27,790 --> 00:24:32,470
we each time the vendor doesn't update

531
00:24:30,280 --> 00:24:37,030
we have to update our fix so is there a

532
00:24:32,470 --> 00:24:39,670
better way and in general no but we can

533
00:24:37,030 --> 00:24:41,920
focus that we're using open SSL and can

534
00:24:39,670 --> 00:24:44,800
we do something open SSL specific but

535
00:24:41,920 --> 00:24:48,520
still cover like 80% of world crypto

536
00:24:44,800 --> 00:24:52,060
usage right and the answer is is called

537
00:24:48,520 --> 00:24:55,110
open SSL engine so it's a less known

538
00:24:52,060 --> 00:24:57,760
feature of open SSL that open SSL has

539
00:24:55,110 --> 00:25:00,360
the kind of extension framework you can

540
00:24:57,760 --> 00:25:03,550
write extension modules for open SSL and

541
00:25:00,360 --> 00:25:06,070
you can use this to add new crypto

542
00:25:03,550 --> 00:25:08,680
algorithms into open SSL or replace

543
00:25:06,070 --> 00:25:10,330
existing cryptographic algorithm

544
00:25:08,680 --> 00:25:11,770
implementation so for example if you

545
00:25:10,330 --> 00:25:14,919
don't like their implementation of

546
00:25:11,770 --> 00:25:16,960
Charles one or shut 256 and you can come

547
00:25:14,920 --> 00:25:19,630
up with much faster one you can just

548
00:25:16,960 --> 00:25:24,520
replace it dynamically and it will work

549
00:25:19,630 --> 00:25:27,160
and this is mostly useful for to pair

550
00:25:24,520 --> 00:25:29,350
open SSL with some kind of hardware by

551
00:25:27,160 --> 00:25:30,340
scripted devices like crypto keys or

552
00:25:29,350 --> 00:25:32,500
HSMs

553
00:25:30,340 --> 00:25:35,169
they usually provide their own engine so

554
00:25:32,500 --> 00:25:37,420
you stick it into open SSL and any open

555
00:25:35,170 --> 00:25:41,620
SSL based product now can use the crypto

556
00:25:37,420 --> 00:25:43,600
device if you want to read more healers

557
00:25:41,620 --> 00:25:47,860
in link which is an intro how to write a

558
00:25:43,600 --> 00:25:50,370
simple and so let's write our own open

559
00:25:47,860 --> 00:25:52,360
SSL engine and we will replace the sha-1

560
00:25:50,370 --> 00:25:54,820
implementation but we will replace it

561
00:25:52,360 --> 00:25:57,120
without 256 implementation we pretend

562
00:25:54,820 --> 00:25:59,860
we're sha-1 but we will be calculating

563
00:25:57,120 --> 00:26:02,739
sha-256 under the hood so for hash

564
00:25:59,860 --> 00:26:04,750
engines you need to implement three

565
00:26:02,740 --> 00:26:07,960
functions like three callbacks it's like

566
00:26:04,750 --> 00:26:12,130
init update and final and basically what

567
00:26:07,960 --> 00:26:14,290
you do is in each function you pass the

568
00:26:12,130 --> 00:26:16,060
callback to the corresponding open SSL

569
00:26:14,290 --> 00:26:19,330
function but instead of sha-1 you pass

570
00:26:16,060 --> 00:26:22,270
it to sha-256 variant and let's not

571
00:26:19,330 --> 00:26:24,939
forget in the final function we will

572
00:26:22,270 --> 00:26:28,680
reduce our debug output just for

573
00:26:24,940 --> 00:26:28,680
ourselves and also

574
00:26:34,650 --> 00:26:36,710
you

