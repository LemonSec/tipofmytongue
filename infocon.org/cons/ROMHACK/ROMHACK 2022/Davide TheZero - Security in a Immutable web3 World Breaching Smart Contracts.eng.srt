1
00:00:01,800 --> 00:00:05,179
can you hear me okay

2
00:00:05,640 --> 00:00:09,120
thank you for the introduction so this

3
00:00:09,120 --> 00:00:12,719
is me while I do Cliff jump and I am a

4
00:00:12,719 --> 00:00:15,240
security researcher at schilder with a

5
00:00:15,240 --> 00:00:16,440
wonderful team

6
00:00:16,440 --> 00:00:19,920
and I also I am also part of a NGO

7
00:00:19,920 --> 00:00:23,279
called the observatorius.org

8
00:00:23,279 --> 00:00:26,039
and you can find me on Twitter at the

9
00:00:26,039 --> 00:00:28,080
end of the zero

10
00:00:28,080 --> 00:00:31,199
and this is the agenda for today we will

11
00:00:31,199 --> 00:00:33,899
start with an introduction on the

12
00:00:33,899 --> 00:00:37,739
blockchain and on Smart contracts then

13
00:00:37,739 --> 00:00:41,160
the second part will be uh the web free

14
00:00:41,160 --> 00:00:44,040
perspective from a web through developer

15
00:00:44,040 --> 00:00:47,160
going into uh web free

16
00:00:47,160 --> 00:00:50,340
then we will switch our point of view to

17
00:00:50,340 --> 00:00:53,700
security researchers from web 2 going

18
00:00:53,700 --> 00:00:57,239
into web free then one we have some

19
00:00:57,239 --> 00:00:59,879
basic concept we will do some root cause

20
00:00:59,879 --> 00:01:02,340
analysis of the sum of the best

21
00:01:02,340 --> 00:01:05,180
vulnerabilities in the web free world

22
00:01:05,180 --> 00:01:07,920
and at the end we will do some closing

23
00:01:07,920 --> 00:01:09,900
remarks about the concept that we

24
00:01:09,900 --> 00:01:11,280
learned

25
00:01:11,280 --> 00:01:14,220
so some disclaimers this will not be a

26
00:01:14,220 --> 00:01:17,880
buzzword talk I will not try to sell you

27
00:01:17,880 --> 00:01:20,460
Fielder coin in an Ico

28
00:01:20,460 --> 00:01:23,400
and instead the objective of the talk

29
00:01:23,400 --> 00:01:26,340
are to understand the concept behind web

30
00:01:26,340 --> 00:01:29,640
free and these smart contracts and to

31
00:01:29,640 --> 00:01:33,540
learn new offensive and defensive

32
00:01:33,540 --> 00:01:36,180
concept both from uh for security

33
00:01:36,180 --> 00:01:39,180
Searchers and Developers

34
00:01:39,180 --> 00:01:42,659
and please don't use the code that you

35
00:01:42,659 --> 00:01:44,159
will see in the slides in production

36
00:01:44,159 --> 00:01:46,799
because it's not safe it's not reviewed

37
00:01:46,799 --> 00:01:49,619
and you shouldn't do it

38
00:01:49,619 --> 00:01:53,280
so let's start our journey with a brief

39
00:01:53,280 --> 00:01:57,840
introduction uh in this new word

40
00:01:57,840 --> 00:02:01,020
and nowadays everybody knows what the

41
00:02:01,020 --> 00:02:03,180
blockchain is and raise your hand if you

42
00:02:03,180 --> 00:02:05,579
ever heard the word blockchain or smart

43
00:02:05,579 --> 00:02:08,639
contract or something like that

44
00:02:08,639 --> 00:02:11,760
okay I see quite a few ends and

45
00:02:11,760 --> 00:02:14,220
basically the blockchain is a public

46
00:02:14,220 --> 00:02:17,340
distributed immutable database and what

47
00:02:17,340 --> 00:02:18,720
does this mean

48
00:02:18,720 --> 00:02:23,220
uh it is database so it is a place where

49
00:02:23,220 --> 00:02:26,280
we can store different type of data and

50
00:02:26,280 --> 00:02:30,120
it depends on the type of blockchain and

51
00:02:30,120 --> 00:02:33,720
it is immutable because once some data

52
00:02:33,720 --> 00:02:36,540
is added to the blockchain it cannot be

53
00:02:36,540 --> 00:02:39,599
altered or modified and it's there

54
00:02:39,599 --> 00:02:42,540
essentially forever

55
00:02:42,540 --> 00:02:46,080
and it is public and distributed because

56
00:02:46,080 --> 00:02:50,819
every node and every party peer of the

57
00:02:50,819 --> 00:02:53,819
network gets a copy of the data and this

58
00:02:53,819 --> 00:02:57,000
data is public so everyone that gets a

59
00:02:57,000 --> 00:03:01,260
copy can look into it and have access to

60
00:03:01,260 --> 00:03:02,940
this data

61
00:03:02,940 --> 00:03:07,140
and the blockchain started to evolve and

62
00:03:07,140 --> 00:03:10,019
at some point uh ethereum came up with

63
00:03:10,019 --> 00:03:12,840
the concept of smart contract and smart

64
00:03:12,840 --> 00:03:15,900
contracts are like digital contracts

65
00:03:15,900 --> 00:03:18,959
between parties without a third party

66
00:03:18,959 --> 00:03:22,680
that rules over the contract so we don't

67
00:03:22,680 --> 00:03:24,900
have a public notary

68
00:03:24,900 --> 00:03:27,120
like we have in Italy

69
00:03:27,120 --> 00:03:30,420
and a smart contract is a collection of

70
00:03:30,420 --> 00:03:33,540
code so the function of the contract and

71
00:03:33,540 --> 00:03:36,480
the data so the state of the contract

72
00:03:36,480 --> 00:03:40,260
that reside at a specific address on the

73
00:03:40,260 --> 00:03:43,040
blockchain and it is the code that

74
00:03:43,040 --> 00:03:46,140
enforce the rules of the contracts

75
00:03:46,140 --> 00:03:48,120
programmatically

76
00:03:48,120 --> 00:03:50,580
and like everything else on the

77
00:03:50,580 --> 00:03:53,400
blockchain a smart contract can hold and

78
00:03:53,400 --> 00:03:56,280
send money so it can transfer money it

79
00:03:56,280 --> 00:03:57,900
cannot be deleted

80
00:03:57,900 --> 00:04:00,180
and it cannot be altered once the

81
00:04:00,180 --> 00:04:03,239
contract is deployed that's it and the

82
00:04:03,239 --> 00:04:06,000
interaction of a contract and to a

83
00:04:06,000 --> 00:04:09,060
contract are irreversible

84
00:04:09,060 --> 00:04:12,120
this is an example of a small contract

85
00:04:12,120 --> 00:04:15,900
and it is uh developed in the solidity

86
00:04:15,900 --> 00:04:18,600
programming language and at the first

87
00:04:18,600 --> 00:04:21,120
line we have the Declaration of the

88
00:04:21,120 --> 00:04:23,280
solidity version and the compiler

89
00:04:23,280 --> 00:04:25,740
version that we will be using to compile

90
00:04:25,740 --> 00:04:26,880
this code

91
00:04:26,880 --> 00:04:29,940
outline free we have the definition of

92
00:04:29,940 --> 00:04:32,100
the contract in this case the contract

93
00:04:32,100 --> 00:04:34,020
is called greeter

94
00:04:34,020 --> 00:04:36,360
at line four we have a variable inside

95
00:04:36,360 --> 00:04:39,780
the contract called grid of type string

96
00:04:39,780 --> 00:04:42,840
then we have a Constructor and this

97
00:04:42,840 --> 00:04:46,020
Constructor is only executed once per

98
00:04:46,020 --> 00:04:49,139
contract so this contract will this

99
00:04:49,139 --> 00:04:51,000
contract Constructor will be executed

100
00:04:51,000 --> 00:04:54,780
once when the contract is deployed and

101
00:04:54,780 --> 00:04:57,600
then we have atline 10 a function that

102
00:04:57,600 --> 00:05:00,060
is called greetings and this function

103
00:05:00,060 --> 00:05:03,840
accept a string it's public and returns

104
00:05:03,840 --> 00:05:05,460
a string

105
00:05:05,460 --> 00:05:09,240
and how can we go from the source code

106
00:05:09,240 --> 00:05:12,360
that we just seen to the blockchain and

107
00:05:12,360 --> 00:05:15,300
basically we start uh the flow with the

108
00:05:15,300 --> 00:05:18,600
source code we fed it to the Soul C

109
00:05:18,600 --> 00:05:22,020
compiler the solidity compiler and the

110
00:05:22,020 --> 00:05:25,199
compiler gives us output three main

111
00:05:25,199 --> 00:05:27,780
parts so the bytecode

112
00:05:27,780 --> 00:05:31,199
on the left of the contract

113
00:05:31,199 --> 00:05:32,340
you

114
00:05:32,340 --> 00:05:35,039
and then we have the runtime at the

115
00:05:35,039 --> 00:05:37,800
center that is a special type of byte

116
00:05:37,800 --> 00:05:41,759
code that is executed only once and it's

117
00:05:41,759 --> 00:05:44,220
used to deploy the contract on the

118
00:05:44,220 --> 00:05:46,320
blockchain and in the runtime we

119
00:05:46,320 --> 00:05:50,160
actually have uh the Constructor

120
00:05:50,160 --> 00:05:53,160
and then we have the Json API that is an

121
00:05:53,160 --> 00:05:56,400
abstract binary interface in inside the

122
00:05:56,400 --> 00:05:59,520
Json structure that is used for contract

123
00:05:59,520 --> 00:06:02,100
to contract interaction and you can

124
00:06:02,100 --> 00:06:06,000
think of that like uh zwagger or vusdl

125
00:06:06,000 --> 00:06:08,940
file or a symbolic file for if you are

126
00:06:08,940 --> 00:06:12,180
like into reversing and binary

127
00:06:12,180 --> 00:06:13,440
and

128
00:06:13,440 --> 00:06:17,039
I talked about bytecode because the

129
00:06:17,039 --> 00:06:18,960
bytecode of the smart contract is

130
00:06:18,960 --> 00:06:20,639
executed inside a virtual machine

131
00:06:20,639 --> 00:06:22,740
specifically for the ethereum

132
00:06:22,740 --> 00:06:26,220
cryptocurrency inside the evm

133
00:06:26,220 --> 00:06:29,940
and this virtual machine allow us to

134
00:06:29,940 --> 00:06:31,979
build a distributed computing

135
00:06:31,979 --> 00:06:36,240
infrastructure and the state of the

136
00:06:36,240 --> 00:06:39,060
execution is stored on the ethereum

137
00:06:39,060 --> 00:06:41,759
blockchain so we are executing stuff

138
00:06:41,759 --> 00:06:44,460
in a distributed way and the state is on

139
00:06:44,460 --> 00:06:46,680
the blockchain and this virtual machine

140
00:06:46,680 --> 00:06:49,740
has a risk instruction set and we will

141
00:06:49,740 --> 00:06:52,620
talk about it later

142
00:06:52,620 --> 00:06:56,160
so once a participant of the network

143
00:06:56,160 --> 00:06:59,580
wants to do and interact with a smart

144
00:06:59,580 --> 00:07:02,639
contract basically a broadcast they

145
00:07:02,639 --> 00:07:04,919
broadcast an execution request to the

146
00:07:04,919 --> 00:07:09,240
network and the execution causes a state

147
00:07:09,240 --> 00:07:12,120
change that is committed inside a

148
00:07:12,120 --> 00:07:15,240
transaction and propagated to all the

149
00:07:15,240 --> 00:07:17,100
peers of the network and these results

150
00:07:17,100 --> 00:07:19,740
in distributed execution

151
00:07:19,740 --> 00:07:23,759
let's see in depth our uh this works

152
00:07:23,759 --> 00:07:26,759
this is Bob and Bob wants to interact

153
00:07:26,759 --> 00:07:29,220
with a smart contract so broadcast his

154
00:07:29,220 --> 00:07:32,880
uh execution request let's say and to

155
00:07:32,880 --> 00:07:36,300
the uh to the network and then every uh

156
00:07:36,300 --> 00:07:38,940
node of the network get uh the execution

157
00:07:38,940 --> 00:07:42,960
request executed verify that that the

158
00:07:42,960 --> 00:07:46,319
execution is uh correct and then update

159
00:07:46,319 --> 00:07:50,220
uh the local blockchain after a minor uh

160
00:07:50,220 --> 00:07:52,440
validate the transaction

161
00:07:52,440 --> 00:07:55,500
so how can we prevent the flooding of

162
00:07:55,500 --> 00:07:57,180
the network with execution requests

163
00:07:57,180 --> 00:07:59,539
because every peer can request

164
00:07:59,539 --> 00:08:03,120
executions and the ethereum developers

165
00:08:03,120 --> 00:08:06,740
came up with the concept of gas that is

166
00:08:06,740 --> 00:08:10,440
uh to waive the computational effort and

167
00:08:10,440 --> 00:08:13,440
the state change that an execution will

168
00:08:13,440 --> 00:08:18,599
make and so make the user pay for it

169
00:08:18,599 --> 00:08:20,879
accordingly

170
00:08:20,879 --> 00:08:25,139
so these Concepts make the evm a quasi

171
00:08:25,139 --> 00:08:27,300
through incomplete machine and we don't

172
00:08:27,300 --> 00:08:30,479
have altering problem here because once

173
00:08:30,479 --> 00:08:31,640
the gas

174
00:08:31,640 --> 00:08:34,559
is done you need to send a certain

175
00:08:34,559 --> 00:08:37,320
amount of amount of gas and when the gas

176
00:08:37,320 --> 00:08:40,559
is done the execution is stopped and

177
00:08:40,559 --> 00:08:43,140
smart contracts need to be deterministic

178
00:08:43,140 --> 00:08:45,300
because everybody in the networks need

179
00:08:45,300 --> 00:08:47,880
to have the same results and this is

180
00:08:47,880 --> 00:08:49,200
important

181
00:08:49,200 --> 00:08:54,600
so let's start our journey uh looking at

182
00:08:54,600 --> 00:08:57,779
web free with a webview developer point

183
00:08:57,779 --> 00:09:00,720
of view and for the develop developers

184
00:09:00,720 --> 00:09:03,420
in the audience let's assume that your

185
00:09:03,420 --> 00:09:05,700
boss works in your office and asks to

186
00:09:05,700 --> 00:09:09,060
you hey we need to make a web free

187
00:09:09,060 --> 00:09:12,779
version of our product and so the first

188
00:09:12,779 --> 00:09:16,140
concept that you will encounter is that

189
00:09:16,140 --> 00:09:18,600
as I said the public execution and the

190
00:09:18,600 --> 00:09:21,959
public state of the execution uh is

191
00:09:21,959 --> 00:09:25,019
distributed and everybody can see the

192
00:09:25,019 --> 00:09:26,940
smart contract bytecode and the smart

193
00:09:26,940 --> 00:09:29,339
contract state so everybody can see the

194
00:09:29,339 --> 00:09:32,220
values of the variables that you are

195
00:09:32,220 --> 00:09:34,019
using during the execution of your

196
00:09:34,019 --> 00:09:37,440
contract so smart contract should be

197
00:09:37,440 --> 00:09:40,320
treated as client code like the

198
00:09:40,320 --> 00:09:42,899
JavaScript that runs on your browser or

199
00:09:42,899 --> 00:09:45,720
the mobile application on your phone

200
00:09:45,720 --> 00:09:48,420
and since you wouldn't check an admin

201
00:09:48,420 --> 00:09:50,820
password inside the browser you wouldn't

202
00:09:50,820 --> 00:09:54,360
do it inside smart contract and if

203
00:09:54,360 --> 00:09:57,600
you're doing it consider upgrading and

204
00:09:57,600 --> 00:10:01,080
changing and fixing this bug but then

205
00:10:01,080 --> 00:10:03,600
you come up with the second big concept

206
00:10:03,600 --> 00:10:06,800
that is that you cannot really update

207
00:10:06,800 --> 00:10:09,540
your implementation one is once it's

208
00:10:09,540 --> 00:10:11,820
live on the blockchain

209
00:10:11,820 --> 00:10:13,800
and your contact will be available

210
00:10:13,800 --> 00:10:15,120
forever

211
00:10:15,120 --> 00:10:17,459
until you call the self-destruct

212
00:10:17,459 --> 00:10:19,680
instruction inside it

213
00:10:19,680 --> 00:10:22,680
and the self-destructure instruction is

214
00:10:22,680 --> 00:10:24,420
a special instruction in the virtual

215
00:10:24,420 --> 00:10:27,420
machine that tells everybody that this

216
00:10:27,420 --> 00:10:29,760
contact cannot be used and you cannot

217
00:10:29,760 --> 00:10:32,580
interact with it anymore but the state

218
00:10:32,580 --> 00:10:35,519
of the contract and its bytecode will

219
00:10:35,519 --> 00:10:37,980
still be in the blockchain because it

220
00:10:37,980 --> 00:10:41,100
was deployed in a previous transaction

221
00:10:41,100 --> 00:10:43,500
so how can you prevent pushing

222
00:10:43,500 --> 00:10:45,300
vulnerable code on the blockchain

223
00:10:45,300 --> 00:10:48,899
forever by testing before deploy here is

224
00:10:48,899 --> 00:10:50,760
really important and you should avoid

225
00:10:50,760 --> 00:10:53,279
fast prototyping so going live as soon

226
00:10:53,279 --> 00:10:56,040
as possible and there are a lot of

227
00:10:56,040 --> 00:10:58,800
development tools that can help

228
00:10:58,800 --> 00:11:01,620
developers uh with these and you can

229
00:11:01,620 --> 00:11:04,320
also use testnet blockchain or offline

230
00:11:04,320 --> 00:11:06,660
blockchain for it

231
00:11:06,660 --> 00:11:10,860
and a mechanism like updates can be done

232
00:11:10,860 --> 00:11:12,899
with proxy contract and this is Bob

233
00:11:12,899 --> 00:11:15,180
again that wants to interact with your

234
00:11:15,180 --> 00:11:18,720
contract and instead instead of making

235
00:11:18,720 --> 00:11:20,820
Bob interact with the smart contract

236
00:11:20,820 --> 00:11:24,180
direct directly we installed build a

237
00:11:24,180 --> 00:11:26,459
proxy contract in the middle and then

238
00:11:26,459 --> 00:11:28,860
the real implementation contract behind

239
00:11:28,860 --> 00:11:33,360
it so you as a as the owner and the

240
00:11:33,360 --> 00:11:36,300
developer of the contracts at some point

241
00:11:36,300 --> 00:11:37,920
can change

242
00:11:37,920 --> 00:11:41,040
the linking of the proxy contract

243
00:11:41,040 --> 00:11:44,519
tooling to a different contract and all

244
00:11:44,519 --> 00:11:47,339
the proxy contract is doing is taking

245
00:11:47,339 --> 00:11:50,040
the input from the users and forwarding

246
00:11:50,040 --> 00:11:53,820
it to a Smart contract and you ask

247
00:11:53,820 --> 00:11:56,700
why these don't violate the immutability

248
00:11:56,700 --> 00:11:59,519
property that we saw and this is the

249
00:11:59,519 --> 00:12:01,860
code that is used to implement it

250
00:12:01,860 --> 00:12:05,040
we have a proxy contract and inside the

251
00:12:05,040 --> 00:12:08,839
Constructor uh we set the contract set

252
00:12:08,839 --> 00:12:13,200
its owner as the user that's deployed it

253
00:12:13,200 --> 00:12:16,980
and set the default implementation with

254
00:12:16,980 --> 00:12:19,440
an address of a different contract so

255
00:12:19,440 --> 00:12:21,600
inside the implementation variable you

256
00:12:21,600 --> 00:12:24,540
have the address of the contract that

257
00:12:24,540 --> 00:12:27,959
will be uh linked and when you want to

258
00:12:27,959 --> 00:12:29,940
upgrade the contract

259
00:12:29,940 --> 00:12:32,120
you can call the upgrade function

260
00:12:32,120 --> 00:12:35,279
passing an address as the Imp variable

261
00:12:35,279 --> 00:12:38,040
and it will change the implementation

262
00:12:38,040 --> 00:12:41,399
address and from now on all the input

263
00:12:41,399 --> 00:12:43,920
from the user will be forwarded to a

264
00:12:43,920 --> 00:12:46,860
different uh contract and this function

265
00:12:46,860 --> 00:12:49,339
can be called only by the proxy owner

266
00:12:49,339 --> 00:12:52,380
since we have a modifier that checks for

267
00:12:52,380 --> 00:12:54,720
it without require

268
00:12:54,720 --> 00:12:58,860
and so this way the proxy contract byte

269
00:12:58,860 --> 00:13:01,560
code is still immutable per cap so

270
00:13:01,560 --> 00:13:04,139
because all it is doing is forwarding

271
00:13:04,139 --> 00:13:07,079
stuff uh input to a different contract

272
00:13:07,079 --> 00:13:09,180
and

273
00:13:09,180 --> 00:13:12,420
you are lucky because uh as we have seen

274
00:13:12,420 --> 00:13:15,420
uh smart contracts are usually small so

275
00:13:15,420 --> 00:13:18,300
you can read the whole code and spot

276
00:13:18,300 --> 00:13:23,040
easy bugs and uh so also the efficiency

277
00:13:23,040 --> 00:13:26,220
is uh greater because they are small

278
00:13:26,220 --> 00:13:29,000
and

279
00:13:29,040 --> 00:13:32,639
if yeah but it's JavaScript so you are

280
00:13:32,639 --> 00:13:36,180
reading JavaScript and in reality it's

281
00:13:36,180 --> 00:13:38,940
worse than JavaScript and this is a

282
00:13:38,940 --> 00:13:41,940
quote from materials Master thesis that

283
00:13:41,940 --> 00:13:44,339
says that solidity type system is not

284
00:13:44,339 --> 00:13:47,639
safe and contract interfaces are only

285
00:13:47,639 --> 00:13:51,600
consulted and looked up at runtime not

286
00:13:51,600 --> 00:13:54,480
at compile time so if there is a problem

287
00:13:54,480 --> 00:13:58,380
in contract interfaces uh the evm raise

288
00:13:58,380 --> 00:14:01,440
an exception and the user wastes their

289
00:14:01,440 --> 00:14:04,440
gas because for executing it you need to

290
00:14:04,440 --> 00:14:06,180
pay gas

291
00:14:06,180 --> 00:14:09,420
and another funny thing of the solidity

292
00:14:09,420 --> 00:14:12,660
compiler is that at some point decided

293
00:14:12,660 --> 00:14:16,579
to calculate one with the exponentiation

294
00:14:16,579 --> 00:14:20,579
and actually a lot of smart contracts

295
00:14:20,579 --> 00:14:23,639
were doing 2056 to the power of 0

296
00:14:23,639 --> 00:14:28,019
instead of putting one as a constant and

297
00:14:28,019 --> 00:14:30,660
these cost people money

298
00:14:30,660 --> 00:14:32,940
and this is a big Watts

299
00:14:32,940 --> 00:14:35,639
and remind me about Gary Bernard talk

300
00:14:35,639 --> 00:14:38,339
that explains other funny stuff in

301
00:14:38,339 --> 00:14:41,519
programming languages and compilers

302
00:14:41,519 --> 00:14:46,260
and yeah solid is bad but it's still in

303
00:14:46,260 --> 00:14:49,560
an early stage and unlike CPUs the evm

304
00:14:49,560 --> 00:14:51,860
and the compiler cannot bold at speed

305
00:14:51,860 --> 00:14:54,959
and most of the time we can kill

306
00:14:54,959 --> 00:14:57,120
vulnerability classes with breaking

307
00:14:57,120 --> 00:14:59,579
changes either in the VM or in the

308
00:14:59,579 --> 00:15:01,019
compiler

309
00:15:01,019 --> 00:15:03,899
for example this is a vulnerable smart

310
00:15:03,899 --> 00:15:07,079
contract with a buy function and inside

311
00:15:07,079 --> 00:15:09,899
the buy function we can see that it

312
00:15:09,899 --> 00:15:14,160
takes a variable called num tokens and

313
00:15:14,160 --> 00:15:16,260
these variable num tokens is Multiplied

314
00:15:16,260 --> 00:15:20,220
for the price per token constant and

315
00:15:20,220 --> 00:15:22,920
then we have a required that checks if

316
00:15:22,920 --> 00:15:25,620
this condition holds true and is

317
00:15:25,620 --> 00:15:28,199
checking if how many coins we are

318
00:15:28,199 --> 00:15:31,139
sending is equal to the number of token

319
00:15:31,139 --> 00:15:34,019
we are asking times the price per token

320
00:15:34,019 --> 00:15:37,980
but if we ask for a big enough number of

321
00:15:37,980 --> 00:15:39,660
token what happens is that the

322
00:15:39,660 --> 00:15:40,800
multiplication

323
00:15:40,800 --> 00:15:43,920
will overflow and wrap around so we can

324
00:15:43,920 --> 00:15:47,339
send few coin and get a lot of token and

325
00:15:47,339 --> 00:15:49,860
this is funny because uh the ethereum

326
00:15:49,860 --> 00:15:51,959
developers managed to implement like

327
00:15:51,959 --> 00:15:54,660
overflow in a language that was released

328
00:15:54,660 --> 00:15:59,820
like in 20 uh 16. or so and we have

329
00:15:59,820 --> 00:16:03,899
another bug here uh namely Seoul 2018

330
00:16:03,899 --> 00:16:05,459
for

331
00:16:05,459 --> 00:16:10,560
with a smart uh small smart contract and

332
00:16:10,560 --> 00:16:13,199
inline free we have a declaration of a

333
00:16:13,199 --> 00:16:16,680
exp variable of Type U intake and it can

334
00:16:16,680 --> 00:16:19,680
store up to 255

335
00:16:19,680 --> 00:16:22,740
and we assigned to It 2 to the power of

336
00:16:22,740 --> 00:16:24,860
8 that is

337
00:16:24,860 --> 00:16:29,579
256. so uh we will wrap around the X

338
00:16:29,579 --> 00:16:32,459
variable and so uh the value inside it

339
00:16:32,459 --> 00:16:34,980
will become zero then in the following

340
00:16:34,980 --> 00:16:39,899
line basically we do 0 to the power of X

341
00:16:39,899 --> 00:16:42,480
So in theory we should be doing 0 to the

342
00:16:42,480 --> 00:16:44,639
power of 0 and

343
00:16:44,639 --> 00:16:46,639
in version

344
00:16:46,639 --> 00:16:50,519
0.4 or less of solidity this outputs 0

345
00:16:50,519 --> 00:16:54,800
and that's what it's it's wrong

346
00:16:54,800 --> 00:16:57,800
and in solidity

347
00:16:57,800 --> 00:17:02,820
0.4.25 the output is 1 so it's coherent

348
00:17:02,820 --> 00:17:07,199
with math but still not ideal because we

349
00:17:07,199 --> 00:17:11,059
are silver flowing and with solidity uh

350
00:17:11,059 --> 00:17:14,160
0.8.x the execution is reverted because

351
00:17:14,160 --> 00:17:18,660
the compiler the actually the evm uh see

352
00:17:18,660 --> 00:17:21,720
that uh overflow happened and so the

353
00:17:21,720 --> 00:17:25,640
entire uh execution is reverted and

354
00:17:25,640 --> 00:17:28,940
how uh Soul C

355
00:17:28,940 --> 00:17:32,040
o.8.x reverted the execution on overflow

356
00:17:32,040 --> 00:17:36,179
and basically it's adds new byte code at

357
00:17:36,179 --> 00:17:39,720
compile time that guards against uh

358
00:17:39,720 --> 00:17:42,419
these uh kind of scenario like stock

359
00:17:42,419 --> 00:17:44,520
Canary and

360
00:17:44,520 --> 00:17:47,580
this version of solidity is pretty uh

361
00:17:47,580 --> 00:17:50,780
new and it's came out like this year

362
00:17:50,780 --> 00:17:54,960
and these adding uh this new byte code

363
00:17:54,960 --> 00:17:57,179
that is ADD obviously is more gas

364
00:17:57,179 --> 00:17:59,400
expensive because everybody could and

365
00:17:59,400 --> 00:18:02,039
every extraction that is executed in the

366
00:18:02,039 --> 00:18:06,840
evm use guess and so developers started

367
00:18:06,840 --> 00:18:09,120
using the uncheckable keyword in order

368
00:18:09,120 --> 00:18:12,960
to disable those checks and save gas and

369
00:18:12,960 --> 00:18:16,500
you shouldn't be doing this

370
00:18:16,500 --> 00:18:19,559
and yeah it's important to minimize gas

371
00:18:19,559 --> 00:18:22,080
requirement but we need to do it uh you

372
00:18:22,080 --> 00:18:24,120
need to do it in a safe way

373
00:18:24,120 --> 00:18:27,240
and we need to minimize the uh the

374
00:18:27,240 --> 00:18:29,640
instructions that are executed and the

375
00:18:29,640 --> 00:18:32,600
storage that is used

376
00:18:32,700 --> 00:18:35,820
and for example here we have two uh

377
00:18:35,820 --> 00:18:37,980
contracts

378
00:18:37,980 --> 00:18:41,760
and they have the same function beside

379
00:18:41,760 --> 00:18:44,220
the first one that implements another

380
00:18:44,220 --> 00:18:49,320
Circle that checks if the input array

381
00:18:49,320 --> 00:18:53,280
length is less than 256 and in both

382
00:18:53,280 --> 00:18:56,820
contract function we have a fourth cycle

383
00:18:56,820 --> 00:19:01,140
with a uint 8 index

384
00:19:01,140 --> 00:19:04,559
and a condition that says if the index

385
00:19:04,559 --> 00:19:08,700
is less than array length

386
00:19:08,700 --> 00:19:12,419
and here you can see the upgrades that

387
00:19:12,419 --> 00:19:15,840
uh Implement their Circle and how much

388
00:19:15,840 --> 00:19:20,760
gas they take and if we send to the two

389
00:19:20,760 --> 00:19:22,919
different contracts as small enough

390
00:19:22,919 --> 00:19:25,380
input we can see that

391
00:19:25,380 --> 00:19:29,700
without the asserts we gain uh 26 units

392
00:19:29,700 --> 00:19:34,260
of gas but what happens if we send a

393
00:19:34,260 --> 00:19:37,020
large enough array in the first case the

394
00:19:37,020 --> 00:19:41,280
assert will stop the execution and use a

395
00:19:41,280 --> 00:19:45,720
limited amount of gas instead in if we

396
00:19:45,720 --> 00:19:49,320
uh don't have the assert the index was

397
00:19:49,320 --> 00:19:52,799
declared I used I as you intake and the

398
00:19:52,799 --> 00:19:56,400
input length here overflows and so it

399
00:19:56,400 --> 00:19:59,400
will become an infinite Loop since the

400
00:19:59,400 --> 00:20:01,919
condition of the loop will never be uh

401
00:20:01,919 --> 00:20:03,840
true

402
00:20:03,840 --> 00:20:07,020
and in this case the user that is

403
00:20:07,020 --> 00:20:09,299
calling the smart contract lose money

404
00:20:09,299 --> 00:20:13,020
but there are also cases where the owner

405
00:20:13,020 --> 00:20:15,840
of the contract lose money for example

406
00:20:15,840 --> 00:20:19,140
this is the case of party wallet and

407
00:20:19,140 --> 00:20:22,080
maybe you heard about it and at some

408
00:20:22,080 --> 00:20:25,260
point a random guy on the internet uh

409
00:20:25,260 --> 00:20:26,160
like

410
00:20:26,160 --> 00:20:29,400
killed the contract and how was this

411
00:20:29,400 --> 00:20:33,419
possible basically parity was working in

412
00:20:33,419 --> 00:20:37,679
a library way so kind of a proxy

413
00:20:37,679 --> 00:20:40,799
but the first contract that the user

414
00:20:40,799 --> 00:20:43,020
interacts with is a personal contract

415
00:20:43,020 --> 00:20:46,320
and the owner is the user himself and

416
00:20:46,320 --> 00:20:49,200
then we have a library contract that is

417
00:20:49,200 --> 00:20:52,380
used to implement all the logic so we

418
00:20:52,380 --> 00:20:54,960
can minimize the gas costs and if we

419
00:20:54,960 --> 00:20:58,140
have multiple users each user have a

420
00:20:58,140 --> 00:21:00,600
personal contact and all the personal

421
00:21:00,600 --> 00:21:05,360
contract interact with the same Library

422
00:21:05,940 --> 00:21:09,660
my contract and what happens what

423
00:21:09,660 --> 00:21:12,600
happened is that uh the contact at the

424
00:21:12,600 --> 00:21:15,000
bottom was created and deployed on the

425
00:21:15,000 --> 00:21:17,780
blockchain at some point on July 2017

426
00:21:17,780 --> 00:21:21,179
and the attacker noticed that nobody

427
00:21:21,179 --> 00:21:24,299
actually initialized the contract and so

428
00:21:24,299 --> 00:21:28,140
at in November 2017 he called the

429
00:21:28,140 --> 00:21:31,140
initialize function setting himself as

430
00:21:31,140 --> 00:21:34,080
the owner of the contract and at that

431
00:21:34,080 --> 00:21:37,080
point he killed the smart contract

432
00:21:37,080 --> 00:21:39,720
calling the self-destruct op code and

433
00:21:39,720 --> 00:21:42,179
here we can see the contract is not

434
00:21:42,179 --> 00:21:45,360
possible to interact with it it's uh

435
00:21:45,360 --> 00:21:48,539
it's self-destructed at some point and

436
00:21:48,539 --> 00:21:52,220
the balance here is uh only a couple of

437
00:21:52,220 --> 00:21:55,020
milliseconds of ether because all the

438
00:21:55,020 --> 00:21:58,440
money was in the personal wallets of the

439
00:21:58,440 --> 00:22:02,600
users not in the library wallet

440
00:22:02,760 --> 00:22:06,299
so uh I hope I haven't heard too much

441
00:22:06,299 --> 00:22:09,059
the developers in the audience and we

442
00:22:09,059 --> 00:22:12,539
will now change our Focus to uh security

443
00:22:12,539 --> 00:22:15,480
researchers and

444
00:22:15,480 --> 00:22:17,880
uh maybe

445
00:22:17,880 --> 00:22:20,340
uh there is this trend among security

446
00:22:20,340 --> 00:22:23,100
researchers that web free exploitation

447
00:22:23,100 --> 00:22:27,419
is uh like binary exploitation is a

448
00:22:27,419 --> 00:22:30,240
trend and everybody wants to go as low

449
00:22:30,240 --> 00:22:32,580
as possible and I have to tell you that

450
00:22:32,580 --> 00:22:35,159
web free exploitation is as low as

451
00:22:35,159 --> 00:22:37,440
binary exploitation

452
00:22:37,440 --> 00:22:39,000
and

453
00:22:39,000 --> 00:22:41,220
we will start

454
00:22:41,220 --> 00:22:44,940
with the evm and the evm as I said

455
00:22:44,940 --> 00:22:47,880
before is a risk Carver architect

456
00:22:47,880 --> 00:22:49,799
architecture

457
00:22:49,799 --> 00:22:53,039
and is risk because there are only uh

458
00:22:53,039 --> 00:22:55,980
140 defined op code and instructions

459
00:22:55,980 --> 00:22:58,700
with a hard limit of

460
00:22:58,700 --> 00:23:04,020
255 and it is a stock machine so values

461
00:23:04,020 --> 00:23:06,659
are put in the stock and then we can

462
00:23:06,659 --> 00:23:09,720
execute operations on the value in the

463
00:23:09,720 --> 00:23:12,360
stock and get the results in the stack

464
00:23:12,360 --> 00:23:14,820
as well and if you ever played with

465
00:23:14,820 --> 00:23:18,539
Dalvik or Lua they are stock machine as

466
00:23:18,539 --> 00:23:20,179
well

467
00:23:20,179 --> 00:23:24,539
and you can easily prophesy for the

468
00:23:24,539 --> 00:23:26,820
architecture since it is really simple

469
00:23:26,820 --> 00:23:30,299
and you can uh like emulate it with

470
00:23:30,299 --> 00:23:33,000
python and with uh all your favorite

471
00:23:33,000 --> 00:23:35,940
programming language and doing research

472
00:23:35,940 --> 00:23:39,179
uh for the evm is like doing Cutting

473
00:23:39,179 --> 00:23:42,780
Edge uh binary live research because we

474
00:23:42,780 --> 00:23:44,700
have symbolic execution and formal

475
00:23:44,700 --> 00:23:47,220
verification as the norm and there are

476
00:23:47,220 --> 00:23:50,400
like a lot a lot of tools that allow you

477
00:23:50,400 --> 00:23:53,700
to do uh this kind of stuff for example

478
00:23:53,700 --> 00:23:57,720
Manticore me thrill chilling and if you

479
00:23:57,720 --> 00:23:58,500
haven't

480
00:23:58,500 --> 00:24:01,100
I've uh post a blog post on

481
00:24:01,100 --> 00:24:03,480
shielder.heat about using cheating to

482
00:24:03,480 --> 00:24:05,400
reverse smart contracts

483
00:24:05,400 --> 00:24:08,700
and so since we have all these kind of

484
00:24:08,700 --> 00:24:12,059
uh fancy stuff finding Landy low angling

485
00:24:12,059 --> 00:24:15,059
fluids is really really easy and

486
00:24:15,059 --> 00:24:18,240
symbolic execution can give you the

487
00:24:18,240 --> 00:24:21,059
exact input that you can send to a

488
00:24:21,059 --> 00:24:23,760
contract in order to exploit it like

489
00:24:23,760 --> 00:24:27,000
Auto up for from pontoon if you are a

490
00:24:27,000 --> 00:24:32,159
poner and the key here is automating all

491
00:24:32,159 --> 00:24:34,919
this stuff and scan new blocks in the

492
00:24:34,919 --> 00:24:38,039
blockchain and so exploit vulnerable

493
00:24:38,039 --> 00:24:40,860
smart contract as scale

494
00:24:40,860 --> 00:24:43,380
but the bad news is that

495
00:24:43,380 --> 00:24:46,080
also developers have this kind of tools

496
00:24:46,080 --> 00:24:48,419
so they kill low hanging fruits before

497
00:24:48,419 --> 00:24:51,480
going into production and most of the

498
00:24:51,480 --> 00:24:54,240
live bugs are either logical or

499
00:24:54,240 --> 00:24:58,380
financial and I have to teach you some

500
00:24:58,380 --> 00:25:01,679
uh New Concepts about financial and

501
00:25:01,679 --> 00:25:05,340
economics and it will be easy the first

502
00:25:05,340 --> 00:25:08,419
concept is shorting so selling an assert

503
00:25:08,419 --> 00:25:12,320
asset Without Really owning it so

504
00:25:12,320 --> 00:25:16,320
lending it from someone else and buying

505
00:25:16,320 --> 00:25:20,039
it later when the price is lower

506
00:25:20,039 --> 00:25:22,559
and the concept of stablecoin that is a

507
00:25:22,559 --> 00:25:26,039
cryptocurrency whose value is fixed to

508
00:25:26,039 --> 00:25:27,720
the value of another currency for

509
00:25:27,720 --> 00:25:30,779
example the US dollar and this kind of

510
00:25:30,779 --> 00:25:34,140
cryptocurrency uh like they have uh uh

511
00:25:34,140 --> 00:25:38,100
one dollar value fixed for example and

512
00:25:38,100 --> 00:25:43,200
some uh month ago an attacker tried to a

513
00:25:43,200 --> 00:25:47,220
short Bitcoin and used the Terra stable

514
00:25:47,220 --> 00:25:49,860
coin in order to do it and basically

515
00:25:49,860 --> 00:25:53,220
this was the plan so first launch some

516
00:25:53,220 --> 00:25:57,500
Bitcoin a big amount of Bitcoin than

517
00:25:57,500 --> 00:26:01,080
buying a lot of Tara coin with the

518
00:26:01,080 --> 00:26:02,220
Bitcoin

519
00:26:02,220 --> 00:26:08,400
and selling uh 35k of Terra for 34k of

520
00:26:08,400 --> 00:26:12,179
US dollar coin and these two areas are

521
00:26:12,179 --> 00:26:14,880
two dollar stable coin so they should

522
00:26:14,880 --> 00:26:18,059
have a value of one dollar but if you

523
00:26:18,059 --> 00:26:20,940
sold if you sell different amount of

524
00:26:20,940 --> 00:26:24,059
them obviously one of them needs to have

525
00:26:24,059 --> 00:26:25,520
a

526
00:26:25,520 --> 00:26:29,400
smaller value than the other and so the

527
00:26:29,400 --> 00:26:32,820
value of Pera started to go down and

528
00:26:32,820 --> 00:26:35,640
people went literally panic mode and

529
00:26:35,640 --> 00:26:39,600
started selling all their uh para coin

530
00:26:39,600 --> 00:26:42,240
crash in the market and this is what

531
00:26:42,240 --> 00:26:45,000
happened and that's a really bad slow

532
00:26:45,000 --> 00:26:46,620
Pro in economics

533
00:26:46,620 --> 00:26:49,740
and so the pera Foundation the

534
00:26:49,740 --> 00:26:52,740
developers behind the Terra stablecoin

535
00:26:52,740 --> 00:26:55,440
started selling big amount of Bitcoin in

536
00:26:55,440 --> 00:26:58,260
order to keep the price high and keep

537
00:26:58,260 --> 00:27:01,080
their reputation high and at this point

538
00:27:01,080 --> 00:27:03,960
the attacker simply sold everything and

539
00:27:03,960 --> 00:27:07,320
buy back Bitcoin at our much much lower

540
00:27:07,320 --> 00:27:11,039
price at uh at this point they uh the

541
00:27:11,039 --> 00:27:13,679
attacker also closed uh the law on the

542
00:27:13,679 --> 00:27:17,779
initial loan making a big profit

543
00:27:17,779 --> 00:27:21,539
but if you want to stay uh Technical and

544
00:27:21,539 --> 00:27:23,779
not go into financial and economical

545
00:27:23,779 --> 00:27:26,159
vulnerabilities we'll still have

546
00:27:26,159 --> 00:27:30,120
technical vulnerabilities uh not limited

547
00:27:30,120 --> 00:27:33,179
to Smart contracts you can find bugs in

548
00:27:33,179 --> 00:27:36,360
the compiler or the virtual machine you

549
00:27:36,360 --> 00:27:38,340
can find bugs in other virtual machine

550
00:27:38,340 --> 00:27:41,340
for example the optimism attack by sarik

551
00:27:41,340 --> 00:27:45,000
the guy behind Cydia for iPhone

552
00:27:45,000 --> 00:27:48,840
and you can find cross-enteration uh

553
00:27:48,840 --> 00:27:52,679
cross chain interaction box flash loan

554
00:27:52,679 --> 00:27:56,100
box and you can even come up with new

555
00:27:56,100 --> 00:27:58,799
attack classes and attack scenario and

556
00:27:58,799 --> 00:28:02,159
this field is really wild

557
00:28:02,159 --> 00:28:03,360
and

558
00:28:03,360 --> 00:28:07,740
now we can that now that we have some uh

559
00:28:07,740 --> 00:28:10,679
basic uh knowledge we can start some

560
00:28:10,679 --> 00:28:12,659
root cause analysis of web free

561
00:28:12,659 --> 00:28:16,640
vulnerabilities and maybe you saw the

562
00:28:16,640 --> 00:28:21,360
Workshop from yesterday by riando and uh

563
00:28:21,360 --> 00:28:24,299
here we will do some root cause analysis

564
00:28:24,299 --> 00:28:27,240
in depth and the first big

565
00:28:27,240 --> 00:28:30,179
vulnerabilities that happen is the Diego

566
00:28:30,179 --> 00:28:34,020
Arc maybe you maybe you heard about it

567
00:28:34,020 --> 00:28:35,400
and

568
00:28:35,400 --> 00:28:39,480
the deal is a stand for decentralized

569
00:28:39,480 --> 00:28:41,880
autonomous organization and basically is

570
00:28:41,880 --> 00:28:45,960
a uh distributed investment found where

571
00:28:45,960 --> 00:28:49,799
there is no Authority that select where

572
00:28:49,799 --> 00:28:53,760
the found is going but uh there is a

573
00:28:53,760 --> 00:28:57,360
voting system that decide which proposal

574
00:28:57,360 --> 00:28:59,580
gets the investment from the investor

575
00:28:59,580 --> 00:29:02,159
and this is all done with the smart

576
00:29:02,159 --> 00:29:04,980
contracts so there are smart contracts

577
00:29:04,980 --> 00:29:09,000
that raised found from investor and

578
00:29:09,000 --> 00:29:11,340
there there are smart contracts where

579
00:29:11,340 --> 00:29:15,840
voters can vote proposal and then

580
00:29:15,840 --> 00:29:18,960
when a proposal is founded the profit

581
00:29:18,960 --> 00:29:21,720
inside the smart contract can go and

582
00:29:21,720 --> 00:29:24,840
will go to the investor that actually uh

583
00:29:24,840 --> 00:29:26,100
invested in it

584
00:29:26,100 --> 00:29:29,820
and there is a concept in the Dao that

585
00:29:29,820 --> 00:29:33,480
is that if a minority of the investors

586
00:29:33,480 --> 00:29:36,779
object to a proposal of funding and this

587
00:29:36,779 --> 00:29:40,740
proposal is going to be founded then the

588
00:29:40,740 --> 00:29:43,799
smart contracts literally splits the

589
00:29:43,799 --> 00:29:45,059
founding

590
00:29:45,059 --> 00:29:48,299
and allow the minority to retrieve the

591
00:29:48,299 --> 00:29:49,880
found at a later time

592
00:29:49,880 --> 00:29:51,980
and I

593
00:29:51,980 --> 00:29:55,380
written as mole an easier version of

594
00:29:55,380 --> 00:29:58,980
these Dao uh contract and it was like

595
00:29:58,980 --> 00:30:02,460
really big and basically there are three

596
00:30:02,460 --> 00:30:04,080
main parts

597
00:30:04,080 --> 00:30:06,779
the third first part inside the buy

598
00:30:06,779 --> 00:30:10,679
token function uh is implemented to send

599
00:30:10,679 --> 00:30:13,799
coin to the contract and store them

600
00:30:13,799 --> 00:30:15,000
inside a pot

601
00:30:15,000 --> 00:30:17,399
then there are the there is the transfer

602
00:30:17,399 --> 00:30:20,220
token function that is used to found a

603
00:30:20,220 --> 00:30:21,240
proposal

604
00:30:21,240 --> 00:30:24,179
so to transfer transfer money to other

605
00:30:24,179 --> 00:30:26,460
people and then there is the withdraw

606
00:30:26,460 --> 00:30:29,279
function that is used to retrieve coin

607
00:30:29,279 --> 00:30:31,320
whenever like a split happen

608
00:30:31,320 --> 00:30:35,640
and the vulnerability lies here inside

609
00:30:35,640 --> 00:30:37,799
the withdraw function

610
00:30:37,799 --> 00:30:41,220
because the contract is transferring the

611
00:30:41,220 --> 00:30:45,480
coins before updating the balance of the

612
00:30:45,480 --> 00:30:49,380
user that requested the transfer and if

613
00:30:49,380 --> 00:30:52,440
we zoom in we can see that the function

614
00:30:52,440 --> 00:30:55,440
withdraw accepts a recipient and

615
00:30:55,440 --> 00:30:58,320
recipient is of type address so it can

616
00:30:58,320 --> 00:31:01,860
be a wallet from a user but can also be

617
00:31:01,860 --> 00:31:03,419
as smart contract

618
00:31:03,419 --> 00:31:09,000
and at line 16 we just check if uh who

619
00:31:09,000 --> 00:31:11,279
is asking for a withdraw have some money

620
00:31:11,279 --> 00:31:16,380
actually and then at line 17 uh the call

621
00:31:16,380 --> 00:31:20,159
method is used on the recipient and this

622
00:31:20,159 --> 00:31:23,880
call method will transfer money but if

623
00:31:23,880 --> 00:31:25,860
the recipient is a smart contract will

624
00:31:25,860 --> 00:31:29,039
also transfer the execution to the smart

625
00:31:29,039 --> 00:31:32,039
contract and it will be transferred the

626
00:31:32,039 --> 00:31:35,159
execution to the uh recipient fallback

627
00:31:35,159 --> 00:31:36,539
function

628
00:31:36,539 --> 00:31:39,179
and in this way the fullback function

629
00:31:39,179 --> 00:31:42,240
inside the recipient can basically call

630
00:31:42,240 --> 00:31:46,500
again a new withdrawal with his address

631
00:31:46,500 --> 00:31:50,159
as the recipient and this will be a

632
00:31:50,159 --> 00:31:53,580
recursive function uh function call and

633
00:31:53,580 --> 00:31:55,799
the balance will never be updated

634
00:31:55,799 --> 00:31:59,279
because we arrive at line 17 and then we

635
00:31:59,279 --> 00:32:02,279
call again withdraw at line 15.

636
00:32:02,279 --> 00:32:05,820
and if you lost me at explaining the

637
00:32:05,820 --> 00:32:08,580
code there is a simple flowchart and

638
00:32:08,580 --> 00:32:11,700
there is a malicious contract on the

639
00:32:11,700 --> 00:32:14,399
right and the Dao contract on the left

640
00:32:14,399 --> 00:32:16,620
we start from an entry point of the

641
00:32:16,620 --> 00:32:19,380
malicious contract that call the

642
00:32:19,380 --> 00:32:23,580
withdraw function of the Dao putting uh

643
00:32:23,580 --> 00:32:27,720
himself his address inside the

644
00:32:27,720 --> 00:32:30,600
the recipient variable then from the

645
00:32:30,600 --> 00:32:32,460
Withrow we execute

646
00:32:32,460 --> 00:32:38,039
the call method of the recipient and the

647
00:32:38,039 --> 00:32:41,760
execution and the coin are sent back to

648
00:32:41,760 --> 00:32:43,559
the fallback function of the malicious

649
00:32:43,559 --> 00:32:46,320
contract and at this point the malicious

650
00:32:46,320 --> 00:32:49,500
contract coal withdraw again and the

651
00:32:49,500 --> 00:32:53,460
cycle repeats without ever updating the

652
00:32:53,460 --> 00:32:57,000
balance of the user in the Dao contract

653
00:32:57,000 --> 00:33:00,000
I know this is confusing but if you ever

654
00:33:00,000 --> 00:33:02,640
heard about Rand trans vulnerability

655
00:33:02,640 --> 00:33:06,679
this is what is all about

656
00:33:07,820 --> 00:33:11,340
and the attackers that exploited this

657
00:33:11,340 --> 00:33:15,120
vulnerability gained uh 55 million of

658
00:33:15,120 --> 00:33:19,080
dollars and actually it didn't really

659
00:33:19,080 --> 00:33:23,940
gained this uh sum of money because uh

660
00:33:23,940 --> 00:33:28,140
the network decided in to perform a hard

661
00:33:28,140 --> 00:33:32,940
fork and exclude the hackers transaction

662
00:33:32,940 --> 00:33:36,120
from happening and this was only

663
00:33:36,120 --> 00:33:38,279
possible because the majority of the

664
00:33:38,279 --> 00:33:42,000
network decided to do so because as I

665
00:33:42,000 --> 00:33:44,460
said before transactions are not

666
00:33:44,460 --> 00:33:48,899
reversible but if enough peers of the

667
00:33:48,899 --> 00:33:53,539
network decide so that it can happen

668
00:33:53,880 --> 00:33:57,360
another nice vulnerability that I will

669
00:33:57,360 --> 00:34:02,039
explain is uh the fomo 3D Arc and fomo3d

670
00:34:02,039 --> 00:34:04,200
is a gambling game made of smart

671
00:34:04,200 --> 00:34:07,740
contracts where players can buy keys

672
00:34:07,740 --> 00:34:10,739
from a contract and the money will go

673
00:34:10,739 --> 00:34:12,300
inside a pot

674
00:34:12,300 --> 00:34:16,159
and a Time counter will be initialized

675
00:34:16,159 --> 00:34:20,040
counting back from 24 hours and every

676
00:34:20,040 --> 00:34:23,219
time a user buys a new key 30 seconds

677
00:34:23,219 --> 00:34:27,599
are added to the counter and also the

678
00:34:27,599 --> 00:34:31,080
key price uh the key price increase

679
00:34:31,080 --> 00:34:34,859
and when the counter hits zero the last

680
00:34:34,859 --> 00:34:36,960
player wins the majority of the ball

681
00:34:36,960 --> 00:34:40,918
like a downward action sort of

682
00:34:40,918 --> 00:34:42,300
and

683
00:34:42,300 --> 00:34:45,719
we need to find a way to delay others

684
00:34:45,719 --> 00:34:49,918
transaction and these vulnerabilities

685
00:34:49,918 --> 00:34:52,739
called block stuffing and basically what

686
00:34:52,739 --> 00:34:56,280
the attackers can do is to submit a lot

687
00:34:56,280 --> 00:34:59,280
of transactions that will use all the

688
00:34:59,280 --> 00:35:03,000
gas and there is a hard limit for gas

689
00:35:03,000 --> 00:35:06,300
inside a block and if we reach that hard

690
00:35:06,300 --> 00:35:10,400
limit and we pay enough fee for the gas

691
00:35:10,400 --> 00:35:13,560
miners will prioritize our transactions

692
00:35:13,560 --> 00:35:17,040
since they are more profitable and so

693
00:35:17,040 --> 00:35:21,300
we'll delay others user transaction and

694
00:35:21,300 --> 00:35:24,359
these uh evidence of the attack going

695
00:35:24,359 --> 00:35:27,660
from the bottom to the top we can see a

696
00:35:27,660 --> 00:35:31,140
block that contained at the center 103

697
00:35:31,140 --> 00:35:34,380
transactions and only taking 50 percent

698
00:35:34,380 --> 00:35:38,160
of the gas on the left and from that

699
00:35:38,160 --> 00:35:41,900
block on uh the number of transaction

700
00:35:41,900 --> 00:35:45,599
decreased as low as free transactions

701
00:35:45,599 --> 00:35:48,660
inside a single block with all the gas

702
00:35:48,660 --> 00:35:52,500
for the block limit used up and when the

703
00:35:52,500 --> 00:35:55,320
attack finished we have on the top a

704
00:35:55,320 --> 00:35:59,579
block with 166 transaction and all the

705
00:35:59,579 --> 00:36:02,820
gas and basically this attacker throws

706
00:36:02,820 --> 00:36:06,180
the blockchain for everybody else and

707
00:36:06,180 --> 00:36:07,160
only

708
00:36:07,160 --> 00:36:10,260
they could do a transaction and only

709
00:36:10,260 --> 00:36:14,099
they could buy key for from o3d but also

710
00:36:14,099 --> 00:36:16,500
using transaction for the whole

711
00:36:16,500 --> 00:36:18,960
blockchain

712
00:36:18,960 --> 00:36:22,440
and was it worth it and the attackers

713
00:36:22,440 --> 00:36:25,560
spend more than 80k units of gas worth

714
00:36:25,560 --> 00:36:29,460
of money and gas and ether so ethereum

715
00:36:29,460 --> 00:36:31,500
are the same thing

716
00:36:31,500 --> 00:36:37,220
but gained much much more uh ether

717
00:36:37,500 --> 00:36:40,619
so this is the end of our journey let's

718
00:36:40,619 --> 00:36:42,780
see some closing remarks

719
00:36:42,780 --> 00:36:46,440
for the developers in the audience

720
00:36:46,440 --> 00:36:49,920
remember to avoid rapid prototyping if

721
00:36:49,920 --> 00:36:52,800
your boss come up to you and is strict

722
00:36:52,800 --> 00:36:55,200
about deadlines tell him that you have

723
00:36:55,200 --> 00:36:59,160
my approval and do a careful design

724
00:36:59,160 --> 00:37:02,040
before actually deploying Your solution

725
00:37:02,040 --> 00:37:05,400
inside the blockchain and test before

726
00:37:05,400 --> 00:37:06,900
deploy

727
00:37:06,900 --> 00:37:09,780
for the security people in the audience

728
00:37:09,780 --> 00:37:12,839
my uh advice is to jump on the web free

729
00:37:12,839 --> 00:37:15,599
train we are doing a lot of cool stuff

730
00:37:15,599 --> 00:37:18,180
and it's an opportunity to learn new

731
00:37:18,180 --> 00:37:20,640
stuff and to apply your knowledge to a

732
00:37:20,640 --> 00:37:21,839
different field

733
00:37:21,839 --> 00:37:25,380
and maybe you can find the next million

734
00:37:25,380 --> 00:37:30,300
bug and offer me or as a beer and let's

735
00:37:30,300 --> 00:37:32,400
see top that you have learned something

736
00:37:32,400 --> 00:37:34,110
new today

737
00:37:34,110 --> 00:37:42,800
[Applause]

738
00:37:48,420 --> 00:37:52,099
yeah if you have some question

739
00:37:56,000 --> 00:37:58,920
so the the lunch is approaching I will

740
00:37:58,920 --> 00:38:03,180
be short okay uh just in your opinion uh

741
00:38:03,180 --> 00:38:04,980
what will be the

742
00:38:04,980 --> 00:38:09,560
the technique that someone will use

743
00:38:09,560 --> 00:38:13,800
to deploy some attacks after the proof

744
00:38:13,800 --> 00:38:15,300
of stake merge

745
00:38:15,300 --> 00:38:16,440
uh

746
00:38:16,440 --> 00:38:19,560
the proof of tape will not like change

747
00:38:19,560 --> 00:38:22,740
so much because it's just the way that

748
00:38:22,740 --> 00:38:25,740
new blocks are created and we will not

749
00:38:25,740 --> 00:38:27,900
have uh block stuffing vulnerability

750
00:38:27,900 --> 00:38:30,960
anymore for example because that based

751
00:38:30,960 --> 00:38:35,040
on uh proof of work and but all the

752
00:38:35,040 --> 00:38:37,320
vulnerabilities inside smart contract

753
00:38:37,320 --> 00:38:41,940
and inside like the evm or compiler

754
00:38:41,940 --> 00:38:45,060
there they will still be there so they

755
00:38:45,060 --> 00:38:50,420
will still apply after the the merge

756
00:38:50,520 --> 00:38:52,380
thank you

757
00:38:52,380 --> 00:38:55,339
other questions

758
00:38:56,760 --> 00:38:59,579
yeah as we are from the others uh from

759
00:38:59,579 --> 00:39:01,440
the first two talks uh lots of about

760
00:39:01,440 --> 00:39:03,839
back bounties is there something similar

761
00:39:03,839 --> 00:39:06,060
into web3 uh how things are doing there

762
00:39:06,060 --> 00:39:10,440
yeah uh their the field is moving there

763
00:39:10,440 --> 00:39:13,680
are a lot of uh companies that accept uh

764
00:39:13,680 --> 00:39:19,619
bug bounties uh so also the uh like the

765
00:39:19,619 --> 00:39:23,000
price for the bounties are like

766
00:39:23,000 --> 00:39:25,800
higher than for other type of

767
00:39:25,800 --> 00:39:28,800
vulnerabilities and the payout is uh

768
00:39:28,800 --> 00:39:31,760
like is well

769
00:39:34,740 --> 00:39:37,279
thank you

