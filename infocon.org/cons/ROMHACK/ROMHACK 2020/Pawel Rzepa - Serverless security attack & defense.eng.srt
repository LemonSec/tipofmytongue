1
00:00:16,079 --> 00:00:19,919
if you are

2
00:00:16,800 --> 00:00:22,400
interested in getting

3
00:00:19,920 --> 00:00:23,439
staying up to date with latest cloud

4
00:00:22,400 --> 00:00:25,359
security news

5
00:00:23,439 --> 00:00:26,640
i encourage you to follow me on my

6
00:00:25,359 --> 00:00:30,080
twitter and

7
00:00:26,640 --> 00:00:32,480
linkedin accounts all right

8
00:00:30,080 --> 00:00:33,600
before we can talk about serverless

9
00:00:32,479 --> 00:00:36,160
security

10
00:00:33,600 --> 00:00:36,960
let's start from the fundamentals

11
00:00:36,160 --> 00:00:40,800
meaning

12
00:00:36,960 --> 00:00:43,440
what is serverless so

13
00:00:40,800 --> 00:00:44,718
i prefer to explain things on the

14
00:00:43,440 --> 00:00:48,239
example so

15
00:00:44,719 --> 00:00:50,800
just imagine that you have a blog

16
00:00:48,239 --> 00:00:51,440
nothing special there's just a static

17
00:00:50,800 --> 00:00:54,239
content

18
00:00:51,440 --> 00:00:55,120
and this is a blog let's say about cute

19
00:00:54,239 --> 00:00:58,000
dogs

20
00:00:55,120 --> 00:01:00,160
but one day you see that there are more

21
00:00:58,000 --> 00:01:03,600
and more visitors on your

22
00:01:00,160 --> 00:01:05,759
blog so you decided that well what about

23
00:01:03,600 --> 00:01:09,280
making a profit on it

24
00:01:05,760 --> 00:01:12,400
so you've decided that you will sell

25
00:01:09,280 --> 00:01:16,159
a curse called how to make your dog

26
00:01:12,400 --> 00:01:19,280
love you and before you get

27
00:01:16,159 --> 00:01:22,479
become a millionaire there are some

28
00:01:19,280 --> 00:01:26,000
technical problems you have to overcome

29
00:01:22,479 --> 00:01:29,439
so you will put the buy button

30
00:01:26,000 --> 00:01:32,880
on your blog blog but then

31
00:01:29,439 --> 00:01:35,758
you have to somehow handle the

32
00:01:32,880 --> 00:01:36,960
payment process so you need to get the

33
00:01:35,759 --> 00:01:40,079
confirmation from

34
00:01:36,960 --> 00:01:43,520
from the payment provider that

35
00:01:40,079 --> 00:01:46,158
someone really paid for your course

36
00:01:43,520 --> 00:01:46,640
and then you would like to automatically

37
00:01:46,159 --> 00:01:49,680
send

38
00:01:46,640 --> 00:01:50,720
an email to your customer with the url

39
00:01:49,680 --> 00:01:54,560
to your

40
00:01:50,720 --> 00:01:57,520
lovely course and finally you want to

41
00:01:54,560 --> 00:01:58,240
get you want to get a report at the end

42
00:01:57,520 --> 00:02:01,280
of the day

43
00:01:58,240 --> 00:02:05,520
about the amount of all the

44
00:02:01,280 --> 00:02:08,560
courses sent you in this day

45
00:02:05,520 --> 00:02:10,959
so if you consider

46
00:02:08,560 --> 00:02:13,120
solving those problems uh using the

47
00:02:10,959 --> 00:02:13,920
monolithic architecture the classic

48
00:02:13,120 --> 00:02:16,959
approach

49
00:02:13,920 --> 00:02:18,000
then you probably need to refactor whole

50
00:02:16,959 --> 00:02:21,040
website

51
00:02:18,000 --> 00:02:23,760
uh so maybe you will use wordpress

52
00:02:21,040 --> 00:02:24,720
maybe other solution however it requires

53
00:02:23,760 --> 00:02:28,160
from you some

54
00:02:24,720 --> 00:02:29,599
research then you don't know how big

55
00:02:28,160 --> 00:02:32,239
traffic you will have

56
00:02:29,599 --> 00:02:33,200
you have big expectations about big

57
00:02:32,239 --> 00:02:36,000
money that

58
00:02:33,200 --> 00:02:36,640
everyone in the car in every corner of

59
00:02:36,000 --> 00:02:40,160
the world

60
00:02:36,640 --> 00:02:43,440
will go to your site and buy your

61
00:02:40,160 --> 00:02:46,079
uh super course however that's just

62
00:02:43,440 --> 00:02:46,959
your assumptions and based on the these

63
00:02:46,080 --> 00:02:50,000
assumptions

64
00:02:46,959 --> 00:02:53,360
you need to choose the

65
00:02:50,000 --> 00:02:56,560
proper hosting plan and finally

66
00:02:53,360 --> 00:02:58,400
you have to maintain your server on a

67
00:02:56,560 --> 00:03:00,800
daily basis like

68
00:02:58,400 --> 00:03:02,720
care about patch management about

69
00:03:00,800 --> 00:03:05,920
network issues

70
00:03:02,720 --> 00:03:08,159
stuff like this and if you

71
00:03:05,920 --> 00:03:10,079
try to solve those problems using the

72
00:03:08,159 --> 00:03:13,280
serverless architecture

73
00:03:10,080 --> 00:03:15,920
that becomes much easier

74
00:03:13,280 --> 00:03:18,319
because you can be focused only on

75
00:03:15,920 --> 00:03:21,518
providing the functionality and

76
00:03:18,319 --> 00:03:25,040
this functionality can be provided by

77
00:03:21,519 --> 00:03:28,480
uh just several

78
00:03:25,040 --> 00:03:31,679
functions which will handle each of the

79
00:03:28,480 --> 00:03:35,119
tasks so let's say you are

80
00:03:31,680 --> 00:03:35,760
exposing you are using the amazon web

81
00:03:35,120 --> 00:03:40,080
services

82
00:03:35,760 --> 00:03:43,280
so you are exposing the public

83
00:03:40,080 --> 00:03:46,640
api gateway endpoint and waiting

84
00:03:43,280 --> 00:03:48,080
for the payment confirmation from your

85
00:03:46,640 --> 00:03:51,359
payment provider

86
00:03:48,080 --> 00:03:53,920
once it come it is validated

87
00:03:51,360 --> 00:03:54,480
by your lambda so the confirmation comes

88
00:03:53,920 --> 00:03:56,798
from the

89
00:03:54,480 --> 00:03:58,079
third party from the payment provider

90
00:03:56,799 --> 00:04:01,120
then the

91
00:03:58,080 --> 00:04:04,560
lambda function is invoked

92
00:04:01,120 --> 00:04:06,640
and this this

93
00:04:04,560 --> 00:04:08,319
request from the payment provider is

94
00:04:06,640 --> 00:04:10,720
handled is validated

95
00:04:08,319 --> 00:04:11,679
and if everything is okay then you are

96
00:04:10,720 --> 00:04:14,799
automatically

97
00:04:11,680 --> 00:04:15,680
sent an email to your uh to your

98
00:04:14,799 --> 00:04:19,199
customers

99
00:04:15,680 --> 00:04:21,120
with the url to your course and finally

100
00:04:19,199 --> 00:04:22,800
at the end of the day every let's say

101
00:04:21,120 --> 00:04:26,080
every day at 10 pm

102
00:04:22,800 --> 00:04:26,840
you want to that you want your lamp that

103
00:04:26,080 --> 00:04:29,919
to be

104
00:04:26,840 --> 00:04:33,198
invoked and to create

105
00:04:29,919 --> 00:04:33,599
a report and then put this report let's

106
00:04:33,199 --> 00:04:36,800
say

107
00:04:33,600 --> 00:04:41,040
in s3 bucket or in dynamodb

108
00:04:36,800 --> 00:04:44,320
whatever so now you can see that

109
00:04:41,040 --> 00:04:46,880
you can you can use those

110
00:04:44,320 --> 00:04:47,599
lambda functions which are generally the

111
00:04:46,880 --> 00:04:50,560
function

112
00:04:47,600 --> 00:04:51,360
as a service and every serverless

113
00:04:50,560 --> 00:04:55,120
application

114
00:04:51,360 --> 00:04:58,560
is built from such code of blocks called

115
00:04:55,120 --> 00:05:01,840
function as a service and every provider

116
00:04:58,560 --> 00:05:05,120
every big cloud security provider has

117
00:05:01,840 --> 00:05:06,799
their own implementation of the function

118
00:05:05,120 --> 00:05:09,840
as a service in aws

119
00:05:06,800 --> 00:05:13,120
it is called lambda function

120
00:05:09,840 --> 00:05:14,159
in azure is it is called the azure

121
00:05:13,120 --> 00:05:17,520
function

122
00:05:14,160 --> 00:05:21,280
and in gcp uh the google cloud platform

123
00:05:17,520 --> 00:05:25,120
it is called the gcp function

124
00:05:21,280 --> 00:05:25,520
and today we will go we will go through

125
00:05:25,120 --> 00:05:29,039
the

126
00:05:25,520 --> 00:05:32,719
security concepts around those

127
00:05:29,039 --> 00:05:35,919
serverless functions

128
00:05:32,720 --> 00:05:39,680
so first thing first the

129
00:05:35,919 --> 00:05:43,280
term serverless is actually pretty bad

130
00:05:39,680 --> 00:05:45,360
because there is nothing like serverless

131
00:05:43,280 --> 00:05:47,039
the serverless actually means that

132
00:05:45,360 --> 00:05:50,880
somebody else

133
00:05:47,039 --> 00:05:54,639
will care about your uh your

134
00:05:50,880 --> 00:05:55,440
server that is a runtime environment for

135
00:05:54,639 --> 00:05:59,600
your

136
00:05:55,440 --> 00:06:01,840
function code so

137
00:05:59,600 --> 00:06:03,039
to prove you and if you want to play a

138
00:06:01,840 --> 00:06:06,159
little bit with the

139
00:06:03,039 --> 00:06:09,159
server on which is run the

140
00:06:06,160 --> 00:06:11,199
function as a service you can go to the

141
00:06:09,160 --> 00:06:14,639
lambdashell.com

142
00:06:11,199 --> 00:06:15,520
website and you don't even need the aws

143
00:06:14,639 --> 00:06:18,720
account

144
00:06:15,520 --> 00:06:19,758
there to play around with lambda

145
00:06:18,720 --> 00:06:23,759
function

146
00:06:19,759 --> 00:06:27,520
so as you can see

147
00:06:23,759 --> 00:06:30,720
it is it it uses oops sorry

148
00:06:27,520 --> 00:06:34,240
as as you can see the lambda

149
00:06:30,720 --> 00:06:37,600
function works on a micro

150
00:06:34,240 --> 00:06:41,280
virtual machine based on amazon linux

151
00:06:37,600 --> 00:06:45,280
image so basically it's like a container

152
00:06:41,280 --> 00:06:48,719
that is invoked uh to

153
00:06:45,280 --> 00:06:49,919
that contains a runtime environment for

154
00:06:48,720 --> 00:06:53,280
your code

155
00:06:49,919 --> 00:06:56,400
executes this code and

156
00:06:53,280 --> 00:06:59,039
and should disappear i i call it

157
00:06:56,400 --> 00:07:00,239
i call it shoot because there are

158
00:06:59,039 --> 00:07:03,599
concepts like the

159
00:07:00,240 --> 00:07:06,960
the cold and hot hot starts but

160
00:07:03,599 --> 00:07:10,080
i do let's say let's stay with the very

161
00:07:06,960 --> 00:07:13,440
general concepts of it so

162
00:07:10,080 --> 00:07:16,479
the this this runtime environment

163
00:07:13,440 --> 00:07:20,479
is a pla is run on the

164
00:07:16,479 --> 00:07:22,318
amazon linux image and the

165
00:07:20,479 --> 00:07:24,800
source code of your lambda function is

166
00:07:22,319 --> 00:07:28,080
stored in the var task directory

167
00:07:24,800 --> 00:07:31,360
and there you can see

168
00:07:28,080 --> 00:07:32,159
the whole uh source code of your

169
00:07:31,360 --> 00:07:34,400
function

170
00:07:32,160 --> 00:07:35,280
in this particular example you you could

171
00:07:34,400 --> 00:07:38,719
see that

172
00:07:35,280 --> 00:07:41,520
uh the it was this is the code of

173
00:07:38,720 --> 00:07:42,000
responsible for this reverse shell to

174
00:07:41,520 --> 00:07:45,198
this

175
00:07:42,000 --> 00:07:47,120
particular lambda function now from the

176
00:07:45,199 --> 00:07:49,280
security point of view the most

177
00:07:47,120 --> 00:07:50,240
interesting is are actually the

178
00:07:49,280 --> 00:07:52,559
environment

179
00:07:50,240 --> 00:07:54,560
variables so when you print out the

180
00:07:52,560 --> 00:07:57,919
environment variables

181
00:07:54,560 --> 00:07:59,840
you would see every plain text

182
00:07:57,919 --> 00:08:01,120
secrets that are stored as environment

183
00:07:59,840 --> 00:08:04,960
variables there

184
00:08:01,120 --> 00:08:08,400
but also you will find there the aws

185
00:08:04,960 --> 00:08:11,440
access keys so those

186
00:08:08,400 --> 00:08:12,000
aws access keys meaning the aws access

187
00:08:11,440 --> 00:08:15,199
key id

188
00:08:12,000 --> 00:08:18,639
aws secret key and a aws

189
00:08:15,199 --> 00:08:23,280
session token all those three are

190
00:08:18,639 --> 00:08:26,960
responsible to are required

191
00:08:23,280 --> 00:08:29,599
to assume the role

192
00:08:26,960 --> 00:08:30,799
which is attached to this particular

193
00:08:29,599 --> 00:08:33,360
lambda function

194
00:08:30,800 --> 00:08:34,399
so let's say let's go back to our

195
00:08:33,360 --> 00:08:38,240
example

196
00:08:34,399 --> 00:08:41,200
that every day once the lambda is

197
00:08:38,240 --> 00:08:42,000
invoked it should generate a report and

198
00:08:41,200 --> 00:08:46,240
store it

199
00:08:42,000 --> 00:08:49,360
in the s3 bucket and the the lambda

200
00:08:46,240 --> 00:08:52,839
has to be authorized to put this

201
00:08:49,360 --> 00:08:56,399
generated report in this particular s3

202
00:08:52,839 --> 00:08:59,680
bucket and to give the permissions

203
00:08:56,399 --> 00:09:01,680
to lambda function to be authorized to

204
00:08:59,680 --> 00:09:05,680
put this object there

205
00:09:01,680 --> 00:09:08,719
you need to attach a role to this

206
00:09:05,680 --> 00:09:12,239
to this lambda function and

207
00:09:08,720 --> 00:09:15,519
those keys like aws key id secret key

208
00:09:12,240 --> 00:09:18,560
and the session token all those can

209
00:09:15,519 --> 00:09:22,399
give you or the attacker can give

210
00:09:18,560 --> 00:09:25,279
it can give you the role so anyone can

211
00:09:22,399 --> 00:09:27,600
assume this role outside the lambda and

212
00:09:25,279 --> 00:09:28,480
has the same permission so for example

213
00:09:27,600 --> 00:09:31,519
to

214
00:09:28,480 --> 00:09:32,959
put arbitrary content or read the

215
00:09:31,519 --> 00:09:36,080
content of this esprit

216
00:09:32,959 --> 00:09:39,599
bucket all right um

217
00:09:36,080 --> 00:09:40,000
enough introduction uh let's let's start

218
00:09:39,600 --> 00:09:43,120
with

219
00:09:40,000 --> 00:09:46,240
the story i prepared for you today uh

220
00:09:43,120 --> 00:09:46,720
so i want to tell you a story about the

221
00:09:46,240 --> 00:09:50,000
junior

222
00:09:46,720 --> 00:09:53,760
developer whose name is bob

223
00:09:50,000 --> 00:09:56,560
and bob is responsible for developing

224
00:09:53,760 --> 00:09:57,600
few serverless functions and just for

225
00:09:56,560 --> 00:09:59,518
internal usage

226
00:09:57,600 --> 00:10:02,000
and this is important because when i'm

227
00:09:59,519 --> 00:10:05,279
doing the cloud security assessments i

228
00:10:02,000 --> 00:10:08,399
i hear it very often that it is only for

229
00:10:05,279 --> 00:10:09,200
internal usage uh so there shouldn't be

230
00:10:08,399 --> 00:10:12,320
public

231
00:10:09,200 --> 00:10:16,399
uh so there there is no actual

232
00:10:12,320 --> 00:10:19,600
need to put any security

233
00:10:16,399 --> 00:10:22,079
uh efforts in those

234
00:10:19,600 --> 00:10:22,959
functions because they are just for

235
00:10:22,079 --> 00:10:26,880
internal

236
00:10:22,959 --> 00:10:29,680
usage furthermore

237
00:10:26,880 --> 00:10:30,399
bob uses serverless frameworks so

238
00:10:29,680 --> 00:10:32,560
usually

239
00:10:30,399 --> 00:10:34,640
developers when they are developing the

240
00:10:32,560 --> 00:10:35,920
serverless applications they are using

241
00:10:34,640 --> 00:10:39,360
the abstraction

242
00:10:35,920 --> 00:10:42,719
layer or which helps them

243
00:10:39,360 --> 00:10:45,600
makes easier the process of

244
00:10:42,720 --> 00:10:46,560
deploying the serverless applications so

245
00:10:45,600 --> 00:10:49,519
as

246
00:10:46,560 --> 00:10:50,719
just imagine that you are writing your

247
00:10:49,519 --> 00:10:55,519
code of your

248
00:10:50,720 --> 00:11:01,360
functions um locally on your computer

249
00:10:55,519 --> 00:11:04,399
and then uh in the very easy yamu

250
00:11:01,360 --> 00:11:07,680
format you are defining all the

251
00:11:04,399 --> 00:11:09,600
resources required uh by your

252
00:11:07,680 --> 00:11:11,839
serverless application so for example

253
00:11:09,600 --> 00:11:12,480
that you require that there will be

254
00:11:11,839 --> 00:11:15,760
created

255
00:11:12,480 --> 00:11:19,200
a new s3 bucket or there will be

256
00:11:15,760 --> 00:11:22,079
created a role for this

257
00:11:19,200 --> 00:11:24,320
serverless application all of it you are

258
00:11:22,079 --> 00:11:29,199
putting in the serverless configuration

259
00:11:24,320 --> 00:11:31,200
yaml file and serverless framework uh

260
00:11:29,200 --> 00:11:32,320
based on this serverless configuration

261
00:11:31,200 --> 00:11:36,640
file is

262
00:11:32,320 --> 00:11:39,360
generating a cloud formation template

263
00:11:36,640 --> 00:11:40,720
and based on them all those resources

264
00:11:39,360 --> 00:11:44,160
are deployed

265
00:11:40,720 --> 00:11:44,720
in your aws the serverless framework

266
00:11:44,160 --> 00:11:48,959
uses

267
00:11:44,720 --> 00:11:52,320
your local aws access keys

268
00:11:48,959 --> 00:11:56,000
of your iim user and also

269
00:11:52,320 --> 00:12:01,040
it zip the lambda source code and

270
00:11:56,000 --> 00:12:01,040
put it in the in the cloud

271
00:12:02,079 --> 00:12:07,599
the first challenge that bob's received

272
00:12:05,120 --> 00:12:09,279
and need to solve is to create the proof

273
00:12:07,600 --> 00:12:12,720
of concept application

274
00:12:09,279 --> 00:12:16,480
where internal candidates can submit

275
00:12:12,720 --> 00:12:18,399
their cvs so bob wright

276
00:12:16,480 --> 00:12:21,200
writes something like this the static

277
00:12:18,399 --> 00:12:24,480
content of it is in polish but

278
00:12:21,200 --> 00:12:26,160
don't worry it is not important in this

279
00:12:24,480 --> 00:12:29,760
demo

280
00:12:26,160 --> 00:12:32,000
the important thing is the url that you

281
00:12:29,760 --> 00:12:35,920
are providing so you are providing the

282
00:12:32,000 --> 00:12:37,760
url with the doc file of your cv

283
00:12:35,920 --> 00:12:40,240
and there's the submit button and that's

284
00:12:37,760 --> 00:12:41,439
all so you are sending the url to your

285
00:12:40,240 --> 00:12:44,079
doc cv

286
00:12:41,440 --> 00:12:46,000
and then you are getting uh from the

287
00:12:44,079 --> 00:12:49,040
application you are getting the

288
00:12:46,000 --> 00:12:51,519
confirmation that hey thank you

289
00:12:49,040 --> 00:12:52,319
we received your submission your

290
00:12:51,519 --> 00:12:55,760
application

291
00:12:52,320 --> 00:12:57,440
so will be in contact however if you use

292
00:12:55,760 --> 00:13:00,720
a very basic

293
00:12:57,440 --> 00:13:04,399
fuzzing like adding the semicolon

294
00:13:00,720 --> 00:13:04,399
in the end of this

295
00:13:04,880 --> 00:13:10,320
url you will see that uh in the error

296
00:13:08,639 --> 00:13:13,440
message that

297
00:13:10,320 --> 00:13:14,160
what actually happens uh behind the

298
00:13:13,440 --> 00:13:17,200
scene

299
00:13:14,160 --> 00:13:20,880
so there is the this uh cv

300
00:13:17,200 --> 00:13:24,000
uh in the doc format is downloaded

301
00:13:20,880 --> 00:13:24,959
and then it is piped to the cat stock

302
00:13:24,000 --> 00:13:29,120
file

303
00:13:24,959 --> 00:13:32,160
so if you if we put the semicolon here

304
00:13:29,120 --> 00:13:35,680
uh we actually can inject

305
00:13:32,160 --> 00:13:38,719
any arbitrary uh comment

306
00:13:35,680 --> 00:13:40,560
here so if you remember from the

307
00:13:38,720 --> 00:13:44,000
beginning of this presentation

308
00:13:40,560 --> 00:13:48,079
uh if we are the attacker then we can

309
00:13:44,000 --> 00:13:51,360
uh instead of just semicolon put there

310
00:13:48,079 --> 00:13:55,120
the nf command which is responsible for

311
00:13:51,360 --> 00:13:58,560
printing out the environment variables

312
00:13:55,120 --> 00:14:01,920
so now you can

313
00:13:58,560 --> 00:14:02,719
you can see the aws session token aws

314
00:14:01,920 --> 00:14:05,839
access key

315
00:14:02,720 --> 00:14:08,959
and aws

316
00:14:05,839 --> 00:14:12,079
secret so

317
00:14:08,959 --> 00:14:16,079
and using all those three

318
00:14:12,079 --> 00:14:19,519
parts you can assume a role that is

319
00:14:16,079 --> 00:14:20,079
attached to this uh to this particular

320
00:14:19,519 --> 00:14:24,399
lambda

321
00:14:20,079 --> 00:14:28,839
and do uh whatever is allowed by this

322
00:14:24,399 --> 00:14:32,399
uh role if you want to play by yourself

323
00:14:28,839 --> 00:14:35,839
with let's say the

324
00:14:32,399 --> 00:14:38,399
vulnerable by design lambda functions

325
00:14:35,839 --> 00:14:39,199
i totally recommend you the serverless

326
00:14:38,399 --> 00:14:42,000
gold it's an

327
00:14:39,199 --> 00:14:42,479
open source project you can deploy it in

328
00:14:42,000 --> 00:14:45,360
your

329
00:14:42,480 --> 00:14:47,440
aws infrastructure but be careful

330
00:14:45,360 --> 00:14:50,079
remember that you are

331
00:14:47,440 --> 00:14:51,519
deploying the vulnerable application

332
00:14:50,079 --> 00:14:54,160
function

333
00:14:51,519 --> 00:14:55,440
or you can use the infrastructure that

334
00:14:54,160 --> 00:14:58,639
is

335
00:14:55,440 --> 00:15:02,160
given you by the authors of this

336
00:14:58,639 --> 00:15:02,160
uh awesome project

337
00:15:02,320 --> 00:15:09,199
so to visualize you there there is the

338
00:15:05,360 --> 00:15:10,480
uh the c the application for the

339
00:15:09,199 --> 00:15:13,760
internal usage

340
00:15:10,480 --> 00:15:17,120
uh was accessible

341
00:15:13,760 --> 00:15:20,880
via the api gateway so once the

342
00:15:17,120 --> 00:15:24,240
user sends this request with the

343
00:15:20,880 --> 00:15:25,600
doc file then it was possible to

344
00:15:24,240 --> 00:15:28,760
exfiltrate

345
00:15:25,600 --> 00:15:30,320
by injecting the environment

346
00:15:28,760 --> 00:15:33,600
[Music]

347
00:15:30,320 --> 00:15:36,560
command it was possible to exfiltrate

348
00:15:33,600 --> 00:15:38,079
the roles keys and then using those

349
00:15:36,560 --> 00:15:41,518
roles keys you can do

350
00:15:38,079 --> 00:15:42,880
whatever you want in this uh in this aws

351
00:15:41,519 --> 00:15:45,920
account

352
00:15:42,880 --> 00:15:49,279
what is allowed by this particular

353
00:15:45,920 --> 00:15:52,800
role and the over permissive roles

354
00:15:49,279 --> 00:15:53,519
are the biggest block of serverless

355
00:15:52,800 --> 00:15:58,319
application

356
00:15:53,519 --> 00:16:01,040
no matter of what provider you are using

357
00:15:58,320 --> 00:16:02,800
so by default if you are using the

358
00:16:01,040 --> 00:16:05,920
serverless framework

359
00:16:02,800 --> 00:16:08,959
uh you can create uh

360
00:16:05,920 --> 00:16:12,319
just one role for

361
00:16:08,959 --> 00:16:12,719
a per application what means it is just

362
00:16:12,320 --> 00:16:16,160
one

363
00:16:12,720 --> 00:16:16,959
role per all lambda functions so let's

364
00:16:16,160 --> 00:16:20,800
assume

365
00:16:16,959 --> 00:16:24,319
that here that is that the left function

366
00:16:20,800 --> 00:16:28,719
really requires all those dynamodb and

367
00:16:24,320 --> 00:16:31,199
s3 permissions however all those two

368
00:16:28,720 --> 00:16:31,759
to other lambda functions doesn't

369
00:16:31,199 --> 00:16:35,359
require

370
00:16:31,759 --> 00:16:36,079
it but if you are using the serverless

371
00:16:35,360 --> 00:16:40,399
framework

372
00:16:36,079 --> 00:16:43,758
in the default configuration then

373
00:16:40,399 --> 00:16:44,480
then you will create one role that is

374
00:16:43,759 --> 00:16:47,120
shared

375
00:16:44,480 --> 00:16:48,399
through all three lambda functions so if

376
00:16:47,120 --> 00:16:50,880
you compromise

377
00:16:48,399 --> 00:16:51,519
just one of it then you are getting the

378
00:16:50,880 --> 00:16:54,800
role

379
00:16:51,519 --> 00:16:55,360
which has the permissions totally uh not

380
00:16:54,800 --> 00:16:57,758
needed

381
00:16:55,360 --> 00:16:59,839
but you were able to get those

382
00:16:57,759 --> 00:17:03,600
permissions

383
00:16:59,839 --> 00:17:06,559
and to fix it you can use a plugin

384
00:17:03,600 --> 00:17:07,199
that is serverless iim roles per

385
00:17:06,559 --> 00:17:10,240
function

386
00:17:07,199 --> 00:17:13,919
that allows you to create a role

387
00:17:10,240 --> 00:17:17,679
per function so if there is only

388
00:17:13,919 --> 00:17:18,000
if for example this function doesn't

389
00:17:17,679 --> 00:17:21,439
need

390
00:17:18,000 --> 00:17:23,439
a big privileges you are giving their

391
00:17:21,439 --> 00:17:24,559
the minimum of permissions to this

392
00:17:23,439 --> 00:17:28,880
lambda function

393
00:17:24,559 --> 00:17:34,240
and in this way you are minimizing the

394
00:17:28,880 --> 00:17:34,240
potential attack surface

395
00:17:34,559 --> 00:17:41,600
now in asia when you are deploying

396
00:17:38,400 --> 00:17:44,400
the azure functions uh the situation

397
00:17:41,600 --> 00:17:46,000
is a little bit different because you

398
00:17:44,400 --> 00:17:49,679
are deploying them

399
00:17:46,000 --> 00:17:53,440
as logical apps in the app service

400
00:17:49,679 --> 00:17:54,640
so you cannot just the deploy just the

401
00:17:53,440 --> 00:17:58,400
azure function

402
00:17:54,640 --> 00:18:01,760
like it is in aws but you have to also

403
00:17:58,400 --> 00:18:05,280
deploy the storage account where your

404
00:18:01,760 --> 00:18:08,320
uh where your uh lambda function

405
00:18:05,280 --> 00:18:12,840
is uh where your asian function is

406
00:18:08,320 --> 00:18:16,080
stored and also any other resources that

407
00:18:12,840 --> 00:18:19,918
requires this

408
00:18:16,080 --> 00:18:23,039
that is required by by your uh functions

409
00:18:19,919 --> 00:18:27,280
and all of those logical apps

410
00:18:23,039 --> 00:18:27,760
uh are has the access to the resource

411
00:18:27,280 --> 00:18:31,440
group

412
00:18:27,760 --> 00:18:32,000
that is assigned to this that is used by

413
00:18:31,440 --> 00:18:36,400
this

414
00:18:32,000 --> 00:18:40,559
logical app furthermore

415
00:18:36,400 --> 00:18:43,760
you are deploying those azure functions

416
00:18:40,559 --> 00:18:47,760
are not separated but they

417
00:18:43,760 --> 00:18:51,120
are sharing the runtime environment

418
00:18:47,760 --> 00:18:54,080
so let me show you on the example so

419
00:18:51,120 --> 00:18:54,479
so take a look that here is the demo

420
00:18:54,080 --> 00:18:57,360
shell

421
00:18:54,480 --> 00:18:59,440
it is triggered by the http request

422
00:18:57,360 --> 00:19:02,000
however you have the

423
00:18:59,440 --> 00:19:03,440
the other azure function which is the

424
00:19:02,000 --> 00:19:07,360
time based func

425
00:19:03,440 --> 00:19:09,760
and it is triggered only in the part

426
00:19:07,360 --> 00:19:11,840
in the particular type so let's say

427
00:19:09,760 --> 00:19:14,480
every day at 10 pm

428
00:19:11,840 --> 00:19:14,879
so normally as an attacker you wouldn't

429
00:19:14,480 --> 00:19:17,919
have

430
00:19:14,880 --> 00:19:21,120
access to this to

431
00:19:17,919 --> 00:19:24,799
to this function but if you are able to

432
00:19:21,120 --> 00:19:28,000
for example inject code to compromise

433
00:19:24,799 --> 00:19:29,360
the demo shell function then you are

434
00:19:28,000 --> 00:19:32,160
getting control over

435
00:19:29,360 --> 00:19:34,320
all the all the function and you are

436
00:19:32,160 --> 00:19:37,280
getting the permissions to

437
00:19:34,320 --> 00:19:38,559
all resources in this particular

438
00:19:37,280 --> 00:19:42,160
resource group

439
00:19:38,559 --> 00:19:43,120
let me show it on the example so here i

440
00:19:42,160 --> 00:19:46,559
created

441
00:19:43,120 --> 00:19:49,918
the azure shell demo application

442
00:19:46,559 --> 00:19:53,440
uh so here it is the the name of the

443
00:19:49,919 --> 00:19:57,120
your your logical app and then

444
00:19:53,440 --> 00:20:02,000
after api you can see the name of the

445
00:19:57,120 --> 00:20:02,000
azure function so here i deployed the

446
00:20:02,559 --> 00:20:09,120
demo shell which allows me to give

447
00:20:06,080 --> 00:20:12,720
any command in the cmd

448
00:20:09,120 --> 00:20:16,559
parameter if

449
00:20:12,720 --> 00:20:18,400
if i will uh print a use the command

450
00:20:16,559 --> 00:20:22,240
dear you will see that

451
00:20:18,400 --> 00:20:25,520
it is run in the windows environment

452
00:20:22,240 --> 00:20:29,520
however it can be also in azure

453
00:20:25,520 --> 00:20:32,799
you can use also the linux environment

454
00:20:29,520 --> 00:20:36,000
in the folder home site www

455
00:20:32,799 --> 00:20:39,120
root there are stored

456
00:20:36,000 --> 00:20:39,919
all your asian functions which are in

457
00:20:39,120 --> 00:20:43,120
the different

458
00:20:39,919 --> 00:20:45,760
directories so let's let's go

459
00:20:43,120 --> 00:20:46,559
into one of them and here you can see

460
00:20:45,760 --> 00:20:49,600
that

461
00:20:46,559 --> 00:20:50,320
there's the function json file where you

462
00:20:49,600 --> 00:20:53,039
can

463
00:20:50,320 --> 00:20:54,559
see the configuration of your azure

464
00:20:53,039 --> 00:20:57,919
function so for example

465
00:20:54,559 --> 00:21:01,280
um if this azure function is a

466
00:20:57,919 --> 00:21:04,880
trigger is triggered by a time

467
00:21:01,280 --> 00:21:08,080
event or it is triggered by http

468
00:21:04,880 --> 00:21:10,960
uh if each http should you give

469
00:21:08,080 --> 00:21:12,000
the api key or it can be invoked

470
00:21:10,960 --> 00:21:15,440
anonymously

471
00:21:12,000 --> 00:21:17,919
things like this and

472
00:21:15,440 --> 00:21:19,200
also in this folder you can find the run

473
00:21:17,919 --> 00:21:24,080
csx file

474
00:21:19,200 --> 00:21:27,600
which stores the source code of your

475
00:21:24,080 --> 00:21:31,520
of your azure function so

476
00:21:27,600 --> 00:21:33,678
uh just to show you let's print out

477
00:21:31,520 --> 00:21:35,120
in a windows environment you can do it

478
00:21:33,679 --> 00:21:38,640
by the type command

479
00:21:35,120 --> 00:21:40,559
so type and the path to the run csx file

480
00:21:38,640 --> 00:21:41,600
and you can see the source code of this

481
00:21:40,559 --> 00:21:44,639
particular

482
00:21:41,600 --> 00:21:46,879
azure function now uh

483
00:21:44,640 --> 00:21:47,760
let's print out the environment variable

484
00:21:46,880 --> 00:21:50,240
which in

485
00:21:47,760 --> 00:21:52,000
in uh windows environment you can do it

486
00:21:50,240 --> 00:21:55,200
by the command set

487
00:21:52,000 --> 00:21:58,960
uh and yes you what you can do

488
00:21:55,200 --> 00:22:01,120
so you just imagine if you have the

489
00:21:58,960 --> 00:22:02,400
remote code execution in the azure

490
00:22:01,120 --> 00:22:04,158
function

491
00:22:02,400 --> 00:22:06,080
then you can print out all the

492
00:22:04,159 --> 00:22:09,440
environment variables

493
00:22:06,080 --> 00:22:12,960
and you can as you can see

494
00:22:09,440 --> 00:22:16,159
there are stored all the

495
00:22:12,960 --> 00:22:18,880
all the secrets that

496
00:22:16,159 --> 00:22:20,880
that are stored in the environment

497
00:22:18,880 --> 00:22:21,919
variables they are in the plain text we

498
00:22:20,880 --> 00:22:25,679
will talk about it

499
00:22:21,919 --> 00:22:29,520
later uh however there is also the

500
00:22:25,679 --> 00:22:31,840
string to your storage account

501
00:22:29,520 --> 00:22:32,799
so once you print out the environment

502
00:22:31,840 --> 00:22:37,678
variables

503
00:22:32,799 --> 00:22:40,720
you can just simply copy this

504
00:22:37,679 --> 00:22:44,240
connection string to the storage account

505
00:22:40,720 --> 00:22:47,600
and in a moment i will i will show you

506
00:22:44,240 --> 00:22:48,159
what you can do with that so if you have

507
00:22:47,600 --> 00:22:51,199
the

508
00:22:48,159 --> 00:22:54,559
connection string to your uh storage

509
00:22:51,200 --> 00:22:55,840
account then you basically uh already

510
00:22:54,559 --> 00:22:58,399
compromised whole

511
00:22:55,840 --> 00:22:59,039
environment and you have control over

512
00:22:58,400 --> 00:23:02,000
all the

513
00:22:59,039 --> 00:23:02,640
azure functions in this particular logic

514
00:23:02,000 --> 00:23:04,880
app so

515
00:23:02,640 --> 00:23:06,400
basically in other words this is game

516
00:23:04,880 --> 00:23:08,960
over for the victim

517
00:23:06,400 --> 00:23:10,240
let me show you on it on the example so

518
00:23:08,960 --> 00:23:13,280
here i'm trying

519
00:23:10,240 --> 00:23:15,679
as an attacker who has the

520
00:23:13,280 --> 00:23:17,039
connection string to the storage account

521
00:23:15,679 --> 00:23:19,520
uh i'm trying to

522
00:23:17,039 --> 00:23:21,440
invoke the the azure function that is

523
00:23:19,520 --> 00:23:25,200
called pond

524
00:23:21,440 --> 00:23:28,240
of course i'm getting 404 error because

525
00:23:25,200 --> 00:23:28,799
there is no such function so because i

526
00:23:28,240 --> 00:23:31,280
have the

527
00:23:28,799 --> 00:23:31,840
this storage account then i can use the

528
00:23:31,280 --> 00:23:35,520
storage

529
00:23:31,840 --> 00:23:38,879
explorer uh which is the tool azure tool

530
00:23:35,520 --> 00:23:42,240
and here uh just by pasting this

531
00:23:38,880 --> 00:23:45,520
search this connection string

532
00:23:42,240 --> 00:23:48,720
then i can see that i have access to

533
00:23:45,520 --> 00:23:49,520
those all three functions and if i

534
00:23:48,720 --> 00:23:52,960
upload

535
00:23:49,520 --> 00:23:53,279
a new file a new function just by you

536
00:23:52,960 --> 00:23:55,520
know

537
00:23:53,279 --> 00:23:57,679
upload and in the phone there are this

538
00:23:55,520 --> 00:23:58,480
this as you remember function.json and

539
00:23:57,679 --> 00:24:01,039
the run

540
00:23:58,480 --> 00:24:02,400
csx file the readme of course is not

541
00:24:01,039 --> 00:24:05,840
required

542
00:24:02,400 --> 00:24:09,039
um then you can see

543
00:24:05,840 --> 00:24:11,918
you have immediately access

544
00:24:09,039 --> 00:24:12,720
for this function and you of course can

545
00:24:11,919 --> 00:24:15,760
remove

546
00:24:12,720 --> 00:24:18,080
the the function or

547
00:24:15,760 --> 00:24:20,400
overwrite them with the totally new

548
00:24:18,080 --> 00:24:23,039
content so just imagine that all the

549
00:24:20,400 --> 00:24:23,840
custom all the customers of your victim

550
00:24:23,039 --> 00:24:26,640
now

551
00:24:23,840 --> 00:24:28,799
uh you can inject the code that it will

552
00:24:26,640 --> 00:24:28,799
be

553
00:24:29,039 --> 00:24:36,640
invoked in the cons run in the

554
00:24:32,480 --> 00:24:36,640
context of your victims

555
00:24:37,679 --> 00:24:46,720
in gcp situation is

556
00:24:41,679 --> 00:24:49,760
is also different so here let me uh

557
00:24:46,720 --> 00:24:51,600
i set up the netcup listener on the lead

558
00:24:49,760 --> 00:24:55,039
port 1337

559
00:24:51,600 --> 00:24:57,918
and then i'm invoking my gcp function to

560
00:24:55,039 --> 00:25:00,960
get the reverse shell to the

561
00:24:57,919 --> 00:25:04,480
gcp environment as you can see what is

562
00:25:00,960 --> 00:25:07,440
pretty pretty interesting that

563
00:25:04,480 --> 00:25:08,000
it is running all the gcp functions are

564
00:25:07,440 --> 00:25:11,760
running

565
00:25:08,000 --> 00:25:12,080
under the root account in aws in azure

566
00:25:11,760 --> 00:25:15,440
the

567
00:25:12,080 --> 00:25:16,879
the account is the the user under which

568
00:25:15,440 --> 00:25:19,840
it they are

569
00:25:16,880 --> 00:25:20,640
run is limited with their limited

570
00:25:19,840 --> 00:25:23,520
permissions

571
00:25:20,640 --> 00:25:24,880
here is the pretty interesting concept

572
00:25:23,520 --> 00:25:27,120
from google

573
00:25:24,880 --> 00:25:28,080
uh if you print out the environment

574
00:25:27,120 --> 00:25:31,199
variables

575
00:25:28,080 --> 00:25:34,639
uh then unlike in aws or

576
00:25:31,200 --> 00:25:38,159
azure you will not see any

577
00:25:34,640 --> 00:25:41,760
secrets that are related with the

578
00:25:38,159 --> 00:25:44,960
role assigned to this gcp

579
00:25:41,760 --> 00:25:49,039
function so you may think hey so how

580
00:25:44,960 --> 00:25:52,799
the gcp function is authorized to access

581
00:25:49,039 --> 00:25:56,400
other entries like the storage resource

582
00:25:52,799 --> 00:26:00,400
in your gcp project

583
00:25:56,400 --> 00:26:04,320
well surprisingly

584
00:26:00,400 --> 00:26:07,600
every gcp function by default

585
00:26:04,320 --> 00:26:10,720
is run under the service account

586
00:26:07,600 --> 00:26:14,080
editor role and the editor role

587
00:26:10,720 --> 00:26:16,799
means that you have almost full

588
00:26:14,080 --> 00:26:18,158
read and write permissions to all

589
00:26:16,799 --> 00:26:22,400
resources

590
00:26:18,159 --> 00:26:25,440
in this particular gcp project

591
00:26:22,400 --> 00:26:29,120
so basically if you compromise

592
00:26:25,440 --> 00:26:33,200
just one gcp function then you can

593
00:26:29,120 --> 00:26:36,639
do almost everything in this

594
00:26:33,200 --> 00:26:40,000
gcp project with the right permissions

595
00:26:36,640 --> 00:26:43,440
what is pretty scary uh so

596
00:26:40,000 --> 00:26:45,440
now how you can access as an attacker

597
00:26:43,440 --> 00:26:48,480
with the remote code execution

598
00:26:45,440 --> 00:26:51,600
on the gcp function you may ask

599
00:26:48,480 --> 00:26:55,120
how can you access the um

600
00:26:51,600 --> 00:26:59,199
this role this editor role

601
00:26:55,120 --> 00:27:03,199
it is uh stored in the metadata service

602
00:26:59,200 --> 00:27:05,600
and if you are familiar with the cloud

603
00:27:03,200 --> 00:27:07,200
cloud technology the the metadata

604
00:27:05,600 --> 00:27:10,240
services always start

605
00:27:07,200 --> 00:27:13,520
no matter of the provider you are using

606
00:27:10,240 --> 00:27:16,960
the metadata service is uh

607
00:27:13,520 --> 00:27:20,960
accessible under the link local address

608
00:27:16,960 --> 00:27:24,080
which is one six 169 two five four

609
00:27:20,960 --> 00:27:27,600
now league local means that

610
00:27:24,080 --> 00:27:28,320
it is uh not rootable it is accessible

611
00:27:27,600 --> 00:27:31,520
only

612
00:27:28,320 --> 00:27:32,320
in the one network segment uh so in

613
00:27:31,520 --> 00:27:36,399
other words

614
00:27:32,320 --> 00:27:39,840
if you have the shell to to this uh

615
00:27:36,399 --> 00:27:40,559
to this environment you can access this

616
00:27:39,840 --> 00:27:43,520
address

617
00:27:40,559 --> 00:27:44,799
but if you are outside of of this

618
00:27:43,520 --> 00:27:48,639
environment then

619
00:27:44,799 --> 00:27:49,918
you cannot furthermore uh to access the

620
00:27:48,640 --> 00:27:53,120
metadata service

621
00:27:49,919 --> 00:27:53,679
of the gcp function you need to add the

622
00:27:53,120 --> 00:27:57,279
header

623
00:27:53,679 --> 00:27:59,840
called metadata flavor google so

624
00:27:57,279 --> 00:28:02,799
so if you have the server site request

625
00:27:59,840 --> 00:28:05,918
forgery in your gcp function code

626
00:28:02,799 --> 00:28:08,320
this is not enough to just

627
00:28:05,919 --> 00:28:10,080
access this address because you also

628
00:28:08,320 --> 00:28:14,559
need to put this

629
00:28:10,080 --> 00:28:17,600
header now if you do this

630
00:28:14,559 --> 00:28:21,039
then you can uh let's

631
00:28:17,600 --> 00:28:25,600
let's see the scopes of the row

632
00:28:21,039 --> 00:28:28,640
uh and as you can see this is um

633
00:28:25,600 --> 00:28:31,840
as you can see uh in this endpoint

634
00:28:28,640 --> 00:28:34,480
of the metadata service you

635
00:28:31,840 --> 00:28:35,199
can see the scopes of the service

636
00:28:34,480 --> 00:28:38,320
account

637
00:28:35,200 --> 00:28:41,919
that is attached to this gcp function

638
00:28:38,320 --> 00:28:44,240
and here is the default

639
00:28:41,919 --> 00:28:46,640
here's the default configuration what

640
00:28:44,240 --> 00:28:49,760
means you are using the editor role

641
00:28:46,640 --> 00:28:52,960
so it gives you the the

642
00:28:49,760 --> 00:28:53,600
full editor role to editor permissions

643
00:28:52,960 --> 00:28:56,799
to the

644
00:28:53,600 --> 00:28:59,439
calendar contacts drive

645
00:28:56,799 --> 00:29:00,080
google drive and the cloud platform

646
00:28:59,440 --> 00:29:04,080
meaning

647
00:29:00,080 --> 00:29:08,080
all resources in this particular gcp

648
00:29:04,080 --> 00:29:11,918
project now

649
00:29:08,080 --> 00:29:12,799
what about defense well you definitely

650
00:29:11,919 --> 00:29:15,679
you have to

651
00:29:12,799 --> 00:29:18,158
follow the list privilege principle uh

652
00:29:15,679 --> 00:29:21,919
because the over permissive roles

653
00:29:18,159 --> 00:29:24,000
as i said this are the the this is the

654
00:29:21,919 --> 00:29:25,600
biggest plug of the serverless

655
00:29:24,000 --> 00:29:27,679
applications

656
00:29:25,600 --> 00:29:29,520
if you are using the serverless

657
00:29:27,679 --> 00:29:32,399
framework

658
00:29:29,520 --> 00:29:33,440
consider using the serverless iim roles

659
00:29:32,399 --> 00:29:36,959
per function

660
00:29:33,440 --> 00:29:37,919
so then you can you can define the

661
00:29:36,960 --> 00:29:41,279
functions

662
00:29:37,919 --> 00:29:44,640
just for this just for

663
00:29:41,279 --> 00:29:48,080
the single row furthermore

664
00:29:44,640 --> 00:29:49,679
you can also use the api gateway request

665
00:29:48,080 --> 00:29:53,039
validation

666
00:29:49,679 --> 00:29:55,919
what means that if you are expecting

667
00:29:53,039 --> 00:29:58,158
in the parame in one of the parameter of

668
00:29:55,919 --> 00:29:59,520
the request you are expecting just the

669
00:29:58,159 --> 00:30:02,159
integer value

670
00:29:59,520 --> 00:30:04,000
uh then in the gateway request

671
00:30:02,159 --> 00:30:08,000
validation you are defining this

672
00:30:04,000 --> 00:30:10,000
has to be integer now even if you have

673
00:30:08,000 --> 00:30:11,279
if you have the vulnerability in your

674
00:30:10,000 --> 00:30:14,559
code

675
00:30:11,279 --> 00:30:17,200
this request will not any kind

676
00:30:14,559 --> 00:30:18,320
of injection that is not just the

677
00:30:17,200 --> 00:30:22,320
integer

678
00:30:18,320 --> 00:30:23,360
uh will be denied on the api gateway

679
00:30:22,320 --> 00:30:25,840
level so it's

680
00:30:23,360 --> 00:30:28,320
not even invoke the lambda and you will

681
00:30:25,840 --> 00:30:31,918
not pay for it

682
00:30:28,320 --> 00:30:32,559
and as another solution you can consider

683
00:30:31,919 --> 00:30:34,880
using

684
00:30:32,559 --> 00:30:36,000
a web application framework that is

685
00:30:34,880 --> 00:30:39,279
accessible in

686
00:30:36,000 --> 00:30:41,279
for all uh free providers for for amazon

687
00:30:39,279 --> 00:30:45,120
microsoft and google

688
00:30:41,279 --> 00:30:48,640
um now however as you probably know

689
00:30:45,120 --> 00:30:49,120
every waff requires the the tuning

690
00:30:48,640 --> 00:30:53,039
process

691
00:30:49,120 --> 00:30:56,080
it's not as you know the

692
00:30:53,039 --> 00:30:59,840
super box that you are just enabling it

693
00:30:56,080 --> 00:31:03,039
and all the all the magic is done

694
00:30:59,840 --> 00:31:07,918
uh without any of your

695
00:31:03,039 --> 00:31:12,080
effort in the gcp

696
00:31:07,919 --> 00:31:14,399
you have to well at least

697
00:31:12,080 --> 00:31:15,600
from the security point of view you have

698
00:31:14,399 --> 00:31:18,559
to consider

699
00:31:15,600 --> 00:31:19,519
creating the unique service account to

700
00:31:18,559 --> 00:31:22,639
each function

701
00:31:19,519 --> 00:31:25,200
because otherwise uh you

702
00:31:22,640 --> 00:31:27,200
you are running every function under the

703
00:31:25,200 --> 00:31:30,720
editor role

704
00:31:27,200 --> 00:31:34,080
in azure the situation the situation is

705
00:31:30,720 --> 00:31:37,360
also pretty uh pretty tough

706
00:31:34,080 --> 00:31:39,360
because if if someone is able to

707
00:31:37,360 --> 00:31:42,000
compromise one of your

708
00:31:39,360 --> 00:31:42,879
function the attacker will get the

709
00:31:42,000 --> 00:31:45,919
permissions to

710
00:31:42,880 --> 00:31:48,880
all the resources in the resource group

711
00:31:45,919 --> 00:31:50,080
so consider applying the role-based

712
00:31:48,880 --> 00:31:53,360
access control

713
00:31:50,080 --> 00:31:56,320
so you there are no full rights to the

714
00:31:53,360 --> 00:31:58,320
resources but only uh but in the

715
00:31:56,320 --> 00:31:58,639
role-based access control you can make

716
00:31:58,320 --> 00:32:01,600
it

717
00:31:58,640 --> 00:32:02,480
more granular furthermore there is

718
00:32:01,600 --> 00:32:05,120
something called

719
00:32:02,480 --> 00:32:07,440
shared access signature tokens so uh

720
00:32:05,120 --> 00:32:11,360
using this token you can

721
00:32:07,440 --> 00:32:15,519
make the um your permission model

722
00:32:11,360 --> 00:32:18,240
even more granular

723
00:32:15,519 --> 00:32:20,720
and above all test your code because no

724
00:32:18,240 --> 00:32:22,320
matter if you are using the

725
00:32:20,720 --> 00:32:24,080
application you are deploying

726
00:32:22,320 --> 00:32:25,840
application on the monolithic

727
00:32:24,080 --> 00:32:27,039
architecture or the serverless

728
00:32:25,840 --> 00:32:30,399
architecture

729
00:32:27,039 --> 00:32:34,000
bad code is a bad code so

730
00:32:30,399 --> 00:32:38,879
always remember about testing your

731
00:32:34,000 --> 00:32:42,640
your released code now

732
00:32:38,880 --> 00:32:46,000
bob received also the second challenge

733
00:32:42,640 --> 00:32:49,760
that another function that bob

734
00:32:46,000 --> 00:32:53,039
should write should

735
00:32:49,760 --> 00:32:56,240
should solve the following problem files

736
00:32:53,039 --> 00:32:59,039
uploaded to particular as free bucket

737
00:32:56,240 --> 00:32:59,440
should be automatically renamed with

738
00:32:59,039 --> 00:33:02,720
some

739
00:32:59,440 --> 00:33:06,720
prefix so the idea here is simple

740
00:33:02,720 --> 00:33:07,360
if if you as the if you as the internal

741
00:33:06,720 --> 00:33:11,519
user

742
00:33:07,360 --> 00:33:15,039
you are deploying that test new png file

743
00:33:11,519 --> 00:33:18,480
to the s3 bucket then

744
00:33:15,039 --> 00:33:22,080
this uploading should trigger

745
00:33:18,480 --> 00:33:24,640
an event an event is basically the

746
00:33:22,080 --> 00:33:25,360
json file where you can find such

747
00:33:24,640 --> 00:33:28,080
information

748
00:33:25,360 --> 00:33:30,158
as the bucket name or the name of the

749
00:33:28,080 --> 00:33:33,120
file that is uploaded

750
00:33:30,159 --> 00:33:36,159
to this bucket and this event should

751
00:33:33,120 --> 00:33:40,559
invoke the lambda

752
00:33:36,159 --> 00:33:44,320
then the lambda runtime environment is

753
00:33:40,559 --> 00:33:48,158
is run and your lambda function is

754
00:33:44,320 --> 00:33:50,000
executed and so the file is renamed and

755
00:33:48,159 --> 00:33:54,080
the old file

756
00:33:50,000 --> 00:33:57,919
is removed from the bucket pretty simple

757
00:33:54,080 --> 00:34:01,760
so bob like many other developers

758
00:33:57,919 --> 00:34:05,039
don't didn't want to

759
00:34:01,760 --> 00:34:08,480
write the code from scratch

760
00:34:05,039 --> 00:34:11,599
and decided to find ready to use code

761
00:34:08,480 --> 00:34:13,760
in the internet so he went through the

762
00:34:11,599 --> 00:34:18,000
places like stack overflow

763
00:34:13,760 --> 00:34:22,320
and npm js repository

764
00:34:18,000 --> 00:34:22,800
and luckily in the npm.js repository he

765
00:34:22,320 --> 00:34:26,720
found

766
00:34:22,800 --> 00:34:29,760
the package called s3 rename

767
00:34:26,719 --> 00:34:34,000
analyzing the usage

768
00:34:29,760 --> 00:34:37,200
of this package both

769
00:34:34,000 --> 00:34:40,480
bob realized that it is doing exactly

770
00:34:37,199 --> 00:34:42,960
what he needs so he was

771
00:34:40,480 --> 00:34:45,440
so happy that he didn't didn't notice

772
00:34:42,960 --> 00:34:49,280
that there are just weekly downloads

773
00:34:45,440 --> 00:34:52,079
and this this is pretty

774
00:34:49,280 --> 00:34:53,280
fresh package but well let's give it a

775
00:34:52,079 --> 00:34:56,639
give it a shot

776
00:34:53,280 --> 00:34:59,680
maybe maybe it can uh solve

777
00:34:56,639 --> 00:35:02,720
the bob's problem so bob

778
00:34:59,680 --> 00:35:06,000
wrote the following code

779
00:35:02,720 --> 00:35:09,359
from the even json file he

780
00:35:06,000 --> 00:35:13,119
pulled the bucket name

781
00:35:09,359 --> 00:35:16,400
from also from the event json file he

782
00:35:13,119 --> 00:35:18,640
pulled the name of the file that is

783
00:35:16,400 --> 00:35:22,240
uploaded to this bucket

784
00:35:18,640 --> 00:35:26,000
and then the new name

785
00:35:22,240 --> 00:35:26,560
is is created by adding the prefix scan

786
00:35:26,000 --> 00:35:30,079
me

787
00:35:26,560 --> 00:35:33,200
to the old name and the magic

788
00:35:30,079 --> 00:35:35,599
is done by the s3 rename

789
00:35:33,200 --> 00:35:35,598
package

790
00:35:38,000 --> 00:35:44,960
after uploading a file then

791
00:35:41,599 --> 00:35:48,240
bob realized that well actually it

792
00:35:44,960 --> 00:35:50,960
added the prefix and even more

793
00:35:48,240 --> 00:35:52,160
in the cloud watch logs there are no

794
00:35:50,960 --> 00:35:55,280
indicators of

795
00:35:52,160 --> 00:35:58,640
any error of any problems

796
00:35:55,280 --> 00:36:02,240
so well it started celebrating

797
00:35:58,640 --> 00:36:05,759
how easily and quickly he was able to

798
00:36:02,240 --> 00:36:09,040
solve this task but

799
00:36:05,760 --> 00:36:12,320
if you analyze the source code of

800
00:36:09,040 --> 00:36:15,839
the s3 rename package you would see

801
00:36:12,320 --> 00:36:16,400
that there is the obfuscated javascript

802
00:36:15,839 --> 00:36:20,240
code

803
00:36:16,400 --> 00:36:23,599
which basically is doing the following

804
00:36:20,240 --> 00:36:24,399
it verifies if there is the aws access

805
00:36:23,599 --> 00:36:27,760
key id

806
00:36:24,400 --> 00:36:30,560
in the environment variables and if so

807
00:36:27,760 --> 00:36:31,280
please send the value of this variable

808
00:36:30,560 --> 00:36:34,480
to this

809
00:36:31,280 --> 00:36:38,000
ip address using in the key

810
00:36:34,480 --> 00:36:40,960
parameter uh using the get

811
00:36:38,000 --> 00:36:41,520
request and guess what guess who's the

812
00:36:40,960 --> 00:36:44,720
owner

813
00:36:41,520 --> 00:36:47,759
of this server uh of course

814
00:36:44,720 --> 00:36:51,279
it was it was me and

815
00:36:47,760 --> 00:36:53,680
i created this package just for the uh

816
00:36:51,280 --> 00:36:55,119
demo purpose of this of this

817
00:36:53,680 --> 00:36:58,399
presentation

818
00:36:55,119 --> 00:36:59,200
uh however so this is the reason why i'm

819
00:36:58,400 --> 00:37:02,320
uh

820
00:36:59,200 --> 00:37:05,118
stealing only aws access key id not

821
00:37:02,320 --> 00:37:08,320
the secret and session token because i

822
00:37:05,119 --> 00:37:11,680
didn't want to harm anybody and

823
00:37:08,320 --> 00:37:15,599
we with just the access key id you can

824
00:37:11,680 --> 00:37:18,960
do much you cannot do much

825
00:37:15,599 --> 00:37:23,200
and what was pretty scary

826
00:37:18,960 --> 00:37:27,760
was the fact that i received not only

827
00:37:23,200 --> 00:37:31,680
access key from from bob

828
00:37:27,760 --> 00:37:35,440
functions so other developers

829
00:37:31,680 --> 00:37:39,040
were simply running those

830
00:37:35,440 --> 00:37:42,880
this package and indeed

831
00:37:39,040 --> 00:37:46,800
there were the aws access key id

832
00:37:42,880 --> 00:37:50,000
among their environment variables

833
00:37:46,800 --> 00:37:54,079
and there are no any protection

834
00:37:50,000 --> 00:37:54,400
mechanisms in um npmjs repository that

835
00:37:54,079 --> 00:37:57,520
is

836
00:37:54,400 --> 00:38:00,240
blocking you from uploading the

837
00:37:57,520 --> 00:38:04,480
malicious code

838
00:38:00,240 --> 00:38:07,919
so how to defend uh well you can run

839
00:38:04,480 --> 00:38:10,960
lambda in your vpc because by default

840
00:38:07,920 --> 00:38:12,880
it is run outside of your vpc and you

841
00:38:10,960 --> 00:38:14,000
can put this lambda in the private

842
00:38:12,880 --> 00:38:17,040
subnet

843
00:38:14,000 --> 00:38:19,839
if you don't need that there is

844
00:38:17,040 --> 00:38:21,440
any outgoing traffic from your lambda

845
00:38:19,839 --> 00:38:24,480
outside of your

846
00:38:21,440 --> 00:38:27,760
uh vpc then simply

847
00:38:24,480 --> 00:38:29,599
block the traffic uh using the security

848
00:38:27,760 --> 00:38:31,359
group and attach it to the private

849
00:38:29,599 --> 00:38:34,400
subnet

850
00:38:31,359 --> 00:38:37,839
furthermore if you require any

851
00:38:34,400 --> 00:38:40,800
um interaction with your internal aws

852
00:38:37,839 --> 00:38:43,920
resources like for example the s3 bucket

853
00:38:40,800 --> 00:38:46,640
then you can use the vpc endpoints

854
00:38:43,920 --> 00:38:48,320
and specify the permissions using the

855
00:38:46,640 --> 00:38:52,319
vpc endpoint policies

856
00:38:48,320 --> 00:38:55,760
and similar approach can be

857
00:38:52,320 --> 00:38:58,839
applied also in

858
00:38:55,760 --> 00:39:01,839
in azure and in google

859
00:38:58,839 --> 00:39:01,839
functions

860
00:39:02,079 --> 00:39:09,520
time for bob's third challenge that

861
00:39:05,520 --> 00:39:12,640
uh he need to extend his previous code

862
00:39:09,520 --> 00:39:15,759
and add some extensions

863
00:39:12,640 --> 00:39:18,240
uh some filtering of

864
00:39:15,760 --> 00:39:18,880
extensions because only some extensions

865
00:39:18,240 --> 00:39:22,078
should be

866
00:39:18,880 --> 00:39:25,359
scanned so bob again

867
00:39:22,079 --> 00:39:29,040
instead of creating his own

868
00:39:25,359 --> 00:39:32,960
regular expression he just

869
00:39:29,040 --> 00:39:37,040
mixed up various regular expressions and

870
00:39:32,960 --> 00:39:40,079
he created something like this just to

871
00:39:37,040 --> 00:39:43,359
filter those extensions

872
00:39:40,079 --> 00:39:46,480
um and if we

873
00:39:43,359 --> 00:39:47,920
analyze this regular expression uh you

874
00:39:46,480 --> 00:39:51,040
would see that if the

875
00:39:47,920 --> 00:39:52,320
name of the file is test uh there's no

876
00:39:51,040 --> 00:39:55,599
match which is good

877
00:39:52,320 --> 00:39:58,000
if test pdf there's again no match

878
00:39:55,599 --> 00:39:59,359
and test png yeah there's the full match

879
00:39:58,000 --> 00:40:02,079
which is good

880
00:39:59,359 --> 00:40:02,720
however if the internal user named the

881
00:40:02,079 --> 00:40:05,760
file

882
00:40:02,720 --> 00:40:08,078
like the like this like many a's

883
00:40:05,760 --> 00:40:09,280
a letters then you would see the

884
00:40:08,079 --> 00:40:11,280
catastrophic

885
00:40:09,280 --> 00:40:12,800
backtracking and the catastrophic

886
00:40:11,280 --> 00:40:16,400
backtracking is

887
00:40:12,800 --> 00:40:19,680
support supported by most of regex

888
00:40:16,400 --> 00:40:22,640
engines what basically means that

889
00:40:19,680 --> 00:40:23,680
if there are like if there are places

890
00:40:22,640 --> 00:40:28,240
like here

891
00:40:23,680 --> 00:40:31,598
with the plus sign that there could be

892
00:40:28,240 --> 00:40:35,040
made the different decision

893
00:40:31,599 --> 00:40:38,160
about matching or not matching then

894
00:40:35,040 --> 00:40:39,359
the the whole process is going to the

895
00:40:38,160 --> 00:40:42,319
last point when they

896
00:40:39,359 --> 00:40:43,279
when the other decision could be made

897
00:40:42,319 --> 00:40:45,759
and

898
00:40:43,280 --> 00:40:46,480
if there is no match then again go to

899
00:40:45,760 --> 00:40:48,480
the

900
00:40:46,480 --> 00:40:49,520
last point where the other decision

901
00:40:48,480 --> 00:40:53,040
could be made

902
00:40:49,520 --> 00:40:54,560
and um and again and again and again and

903
00:40:53,040 --> 00:40:57,920
there are so many

904
00:40:54,560 --> 00:40:58,400
uh attempts of checking that actually

905
00:40:57,920 --> 00:41:01,920
that

906
00:40:58,400 --> 00:41:04,960
uh took all the uh

907
00:41:01,920 --> 00:41:08,960
it takes a lot of time

908
00:41:04,960 --> 00:41:11,520
and can consume all your memory

909
00:41:08,960 --> 00:41:12,800
and now if you use the and this is

910
00:41:11,520 --> 00:41:16,480
called basically the

911
00:41:12,800 --> 00:41:20,480
red vulnerability uh the the regex

912
00:41:16,480 --> 00:41:23,599
denial of service if you apply this

913
00:41:20,480 --> 00:41:24,400
redless attack in the serverless

914
00:41:23,599 --> 00:41:27,760
application

915
00:41:24,400 --> 00:41:31,359
in the function as a service

916
00:41:27,760 --> 00:41:35,040
that actually may create a

917
00:41:31,359 --> 00:41:37,000
financial loss for your victim so if you

918
00:41:35,040 --> 00:41:38,400
uh send those

919
00:41:37,000 --> 00:41:41,839
[Music]

920
00:41:38,400 --> 00:41:45,599
those such if you loop

921
00:41:41,839 --> 00:41:46,078
uploading the file named abracadabra

922
00:41:45,599 --> 00:41:49,119
like

923
00:41:46,079 --> 00:41:52,640
here for 100

924
00:41:49,119 --> 00:41:55,920
000 times and each is billed for

925
00:41:52,640 --> 00:41:59,040
for and let's say that bob created the

926
00:41:55,920 --> 00:41:59,839
15 minutes timeout then it is uh it

927
00:41:59,040 --> 00:42:04,960
would cost

928
00:41:59,839 --> 00:42:09,759
the the victim 1500 of us dollars

929
00:42:04,960 --> 00:42:13,440
and the denial of wallet can be also

930
00:42:09,760 --> 00:42:14,000
uh of course there is uh it can be also

931
00:42:13,440 --> 00:42:17,760
applied

932
00:42:14,000 --> 00:42:21,280
in azure function and the gcp function

933
00:42:17,760 --> 00:42:24,400
so yeah you have to also

934
00:42:21,280 --> 00:42:28,319
take into consideration uh this problem

935
00:42:24,400 --> 00:42:31,520
that what if somebody

936
00:42:28,319 --> 00:42:34,240
by purpose or just by a mistake

937
00:42:31,520 --> 00:42:34,960
would invoke many times of your lambda

938
00:42:34,240 --> 00:42:38,160
and there is

939
00:42:34,960 --> 00:42:41,200
a lambda or asian function or the

940
00:42:38,160 --> 00:42:44,799
gcp function then you can pay

941
00:42:41,200 --> 00:42:47,279
a lot for it so what you can do

942
00:42:44,800 --> 00:42:49,040
first of all if you have the regular

943
00:42:47,280 --> 00:42:52,000
expression that you are not sure

944
00:42:49,040 --> 00:42:53,279
about it you can use the website called

945
00:42:52,000 --> 00:42:56,480
redos checker search

946
00:42:53,280 --> 00:42:59,839
sh and you can simply just copy paste

947
00:42:56,480 --> 00:43:04,079
the the regex there and you would be

948
00:42:59,839 --> 00:43:08,560
notified if it is vulnerable or not

949
00:43:04,079 --> 00:43:11,599
and furthermore you should verify that

950
00:43:08,560 --> 00:43:13,279
any animal is in logs you can also set

951
00:43:11,599 --> 00:43:16,000
up the billing alarm

952
00:43:13,280 --> 00:43:17,040
that will notify you if your billing is

953
00:43:16,000 --> 00:43:20,480
going

954
00:43:17,040 --> 00:43:23,200
too high time for the bob's

955
00:43:20,480 --> 00:43:25,680
fourth challenge about that he needs to

956
00:43:23,200 --> 00:43:29,598
create the new entry in dynamodb

957
00:43:25,680 --> 00:43:33,520
a very common practice is

958
00:43:29,599 --> 00:43:36,640
the developers are putting the secrets

959
00:43:33,520 --> 00:43:38,800
as the environment variables

960
00:43:36,640 --> 00:43:42,240
and as you remember that was possible to

961
00:43:38,800 --> 00:43:42,240
print out in every

962
00:43:42,800 --> 00:43:46,960
provider environment to print out the

963
00:43:45,119 --> 00:43:50,240
environment variables

964
00:43:46,960 --> 00:43:51,440
so furthermore if you are using the

965
00:43:50,240 --> 00:43:54,479
serverless framework

966
00:43:51,440 --> 00:43:55,680
then all those serverless configuration

967
00:43:54,480 --> 00:43:57,359
file

968
00:43:55,680 --> 00:43:58,960
based on which the cloud formation

969
00:43:57,359 --> 00:44:02,640
templates are generated

970
00:43:58,960 --> 00:44:05,920
they are stored in the s3 bucket and

971
00:44:02,640 --> 00:44:08,960
the this s3 bucket can be

972
00:44:05,920 --> 00:44:12,560
read by all your internal users

973
00:44:08,960 --> 00:44:15,760
because there are no any uh

974
00:44:12,560 --> 00:44:19,920
bucket policy that

975
00:44:15,760 --> 00:44:23,440
that are protecting you

976
00:44:19,920 --> 00:44:26,960
that are limiting the access to this

977
00:44:23,440 --> 00:44:29,359
uh bucket for other users

978
00:44:26,960 --> 00:44:30,480
so basically if you have the if you

979
00:44:29,359 --> 00:44:32,880
compromise the

980
00:44:30,480 --> 00:44:34,000
internal user or you are the internal

981
00:44:32,880 --> 00:44:36,960
user

982
00:44:34,000 --> 00:44:39,520
that want to get this secret and you

983
00:44:36,960 --> 00:44:43,040
have only permissions to the s3

984
00:44:39,520 --> 00:44:45,599
uh bucket then you can

985
00:44:43,040 --> 00:44:46,400
you can see in such bucket all the

986
00:44:45,599 --> 00:44:50,240
versions

987
00:44:46,400 --> 00:44:54,319
of the uploaded lambda function

988
00:44:50,240 --> 00:44:54,959
and in the cloud formation template json

989
00:44:54,319 --> 00:44:58,000
file

990
00:44:54,960 --> 00:45:02,560
you can simply read all the

991
00:44:58,000 --> 00:45:02,560
secrets in the plain text

992
00:45:03,200 --> 00:45:10,560
so always encrypt uh all the secrets

993
00:45:07,040 --> 00:45:14,240
uh in aws you can do it using the kms

994
00:45:10,560 --> 00:45:16,319
service uh and also store the secrets

995
00:45:14,240 --> 00:45:17,598
in the secret manager or the ssm

996
00:45:16,319 --> 00:45:21,440
parameter store

997
00:45:17,599 --> 00:45:24,160
so then you are referring

998
00:45:21,440 --> 00:45:25,359
to the the secret so the secret is

999
00:45:24,160 --> 00:45:27,440
stored in the

1000
00:45:25,359 --> 00:45:29,040
secret manager and then you are

1001
00:45:27,440 --> 00:45:32,079
referring in the code

1002
00:45:29,040 --> 00:45:35,599
using the following syntax so there you

1003
00:45:32,079 --> 00:45:38,640
never store the secret as a plain text

1004
00:45:35,599 --> 00:45:41,520
in the uh in your source code and

1005
00:45:38,640 --> 00:45:44,000
in azure uh you can store secrets in the

1006
00:45:41,520 --> 00:45:45,440
keyboard and in gcp you can store the

1007
00:45:44,000 --> 00:45:48,640
secrets in the secret

1008
00:45:45,440 --> 00:45:52,720
manager now last uh

1009
00:45:48,640 --> 00:45:55,759
thing i want to erase uh are all those

1010
00:45:52,720 --> 00:45:57,680
um dangling resources

1011
00:45:55,760 --> 00:46:01,119
and when i'm doing the cloud security

1012
00:45:57,680 --> 00:46:04,640
assessments uh there are almost

1013
00:46:01,119 --> 00:46:08,000
always uh the resources that

1014
00:46:04,640 --> 00:46:08,960
actually shouldn't shouldn't be there

1015
00:46:08,000 --> 00:46:12,079
because

1016
00:46:08,960 --> 00:46:15,200
they they are from the old

1017
00:46:12,079 --> 00:46:15,680
project which is already dead or this is

1018
00:46:15,200 --> 00:46:19,040
just

1019
00:46:15,680 --> 00:46:22,399
a test of some developers some teams

1020
00:46:19,040 --> 00:46:23,359
but they are still not removed and they

1021
00:46:22,400 --> 00:46:26,720
are just

1022
00:46:23,359 --> 00:46:30,000
waiting and sometimes you can

1023
00:46:26,720 --> 00:46:33,598
it is an awesome attack vector

1024
00:46:30,000 --> 00:46:37,040
for uh for entering your

1025
00:46:33,599 --> 00:46:42,480
cloud because it is exposed by uh

1026
00:46:37,040 --> 00:46:45,680
the you know the api gateway endpoints

1027
00:46:42,480 --> 00:46:48,720
or other resources

1028
00:46:45,680 --> 00:46:51,919
so always remember about removing

1029
00:46:48,720 --> 00:46:55,598
all not used resources and

1030
00:46:51,920 --> 00:46:57,680
if you get the the access then

1031
00:46:55,599 --> 00:46:59,200
from the attacker's perspective it is

1032
00:46:57,680 --> 00:47:02,560
just a beginning

1033
00:46:59,200 --> 00:47:04,399
so i encourage you to take a look on my

1034
00:47:02,560 --> 00:47:07,440
previous presentation about

1035
00:47:04,400 --> 00:47:07,839
the further steps what attackers would

1036
00:47:07,440 --> 00:47:11,599
do

1037
00:47:07,839 --> 00:47:15,279
and how to escalate privileges and uh

1038
00:47:11,599 --> 00:47:18,560
remove any fingerprints in the

1039
00:47:15,280 --> 00:47:21,839
in the logs that's all

1040
00:47:18,560 --> 00:47:26,240
from my side i hope

1041
00:47:21,839 --> 00:47:29,599
i i fix to the time

1042
00:47:26,240 --> 00:47:34,078
so if there are any questions

1043
00:47:29,599 --> 00:47:37,200
if there are any feedback i would be

1044
00:47:34,079 --> 00:47:53,839
more than happy to um

1045
00:47:37,200 --> 00:47:53,839
to answer it

1046
00:47:55,359 --> 00:47:57,440
you

