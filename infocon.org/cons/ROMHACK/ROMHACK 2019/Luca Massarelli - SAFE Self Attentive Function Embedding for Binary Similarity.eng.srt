1
00:00:03,210 --> 00:00:10,440
good afternoon I want to thank Cyprus

2
00:00:07,080 --> 00:00:14,219
ion to let me be here today and in

3
00:00:10,440 --> 00:00:17,330
distort I will talk about research we

4
00:00:14,219 --> 00:00:20,910
did in the last year at Sofia University

5
00:00:17,330 --> 00:00:23,189
doing research is called ad safe self

6
00:00:20,910 --> 00:00:25,470
attentive function embedding for binary

7
00:00:23,189 --> 00:00:29,550
similarity I hope you will enjoy my a

8
00:00:25,470 --> 00:00:32,420
talk so let me present myself I am Luca

9
00:00:29,550 --> 00:00:35,390
Massarelli from I'm a PhD student on

10
00:00:32,420 --> 00:00:39,600
excellence a University of Rome and

11
00:00:35,390 --> 00:00:42,360
during my PhD I'm trying to explore how

12
00:00:39,600 --> 00:00:46,680
we can leverage artificial intelligence

13
00:00:42,360 --> 00:00:49,140
in order to improve security so one

14
00:00:46,680 --> 00:00:52,500
important task in security is of course

15
00:00:49,140 --> 00:00:55,250
reverse engineering as other talks point

16
00:00:52,500 --> 00:00:59,700
out today this is not a simple process

17
00:00:55,250 --> 00:01:02,310
because it requires a lot of skills but

18
00:00:59,700 --> 00:01:05,220
also a lot of times because often Europe

19
00:01:02,310 --> 00:01:08,789
you you have to take out problems that

20
00:01:05,220 --> 00:01:10,500
are always different and I think that if

21
00:01:08,789 --> 00:01:12,750
you are the worst engineer you know very

22
00:01:10,500 --> 00:01:17,460
well it and you also drink a lot of

23
00:01:12,750 --> 00:01:20,670
coffee so the field of reverse engineer

24
00:01:17,460 --> 00:01:23,699
is very wide but actually in this

25
00:01:20,670 --> 00:01:25,979
research we focus on a very important

26
00:01:23,700 --> 00:01:28,109
problem this is the problem of binary

27
00:01:25,979 --> 00:01:29,880
similarity let me explain you so

28
00:01:28,109 --> 00:01:31,979
consider that we have these two

29
00:01:29,880 --> 00:01:34,530
functions function area function B and

30
00:01:31,979 --> 00:01:36,479
you want to understand if these two

31
00:01:34,530 --> 00:01:39,359
functions have been compared from the

32
00:01:36,479 --> 00:01:42,960
same source code you know that if I take

33
00:01:39,359 --> 00:01:44,880
the same C code I I can compile it with

34
00:01:42,960 --> 00:01:48,030
different compilers with different

35
00:01:44,880 --> 00:01:50,729
optimization and in that case I will end

36
00:01:48,030 --> 00:01:53,819
up with totally different binary code

37
00:01:50,729 --> 00:01:55,979
for example function a function we have

38
00:01:53,819 --> 00:01:59,399
been compiled from the same three lines

39
00:01:55,979 --> 00:02:02,399
of C code that actually perform a swap

40
00:01:59,399 --> 00:02:04,590
of true location in two of an array but

41
00:02:02,399 --> 00:02:08,038
function a has been compared with

42
00:02:04,590 --> 00:02:10,350
optimization 0 while function 3 for

43
00:02:08,038 --> 00:02:13,410
function B was compiled we optimization

44
00:02:10,350 --> 00:02:16,019
3 so as you can imagine it is not

45
00:02:13,410 --> 00:02:17,490
trivial to understand that actually this

46
00:02:16,020 --> 00:02:19,980
two functions implements the same

47
00:02:17,490 --> 00:02:22,860
semantics and came from the same source

48
00:02:19,980 --> 00:02:26,310
code and oh we can do it in different

49
00:02:22,860 --> 00:02:29,490
ways but first let me show you why this

50
00:02:26,310 --> 00:02:31,860
problem is very important we can have at

51
00:02:29,490 --> 00:02:34,680
least three application that will

52
00:02:31,860 --> 00:02:37,440
benefit from binary similarity the first

53
00:02:34,680 --> 00:02:40,980
is the vulnerability detection imagine

54
00:02:37,440 --> 00:02:43,770
that you have a programs or a femur and

55
00:02:40,980 --> 00:02:47,670
you want to find out if inside this

56
00:02:43,770 --> 00:02:50,340
femur you have some some characteristic

57
00:02:47,670 --> 00:02:52,109
vulnerability what you can do is if you

58
00:02:50,340 --> 00:02:54,660
are able to solve the binary similarity

59
00:02:52,110 --> 00:02:56,730
problem you take a copy of the

60
00:02:54,660 --> 00:02:59,760
vulnerable function that we suppose you

61
00:02:56,730 --> 00:03:02,459
know and you try to find it function

62
00:02:59,760 --> 00:03:05,429
similar to that into your programs of

63
00:03:02,460 --> 00:03:07,260
favor but also you can use binary

64
00:03:05,430 --> 00:03:10,050
similarity for library function

65
00:03:07,260 --> 00:03:11,760
identification let's imagine that you

66
00:03:10,050 --> 00:03:14,220
are a reverse engineer you have to

67
00:03:11,760 --> 00:03:16,679
reverse a malware and the writer of this

68
00:03:14,220 --> 00:03:20,580
malware statically link at a lot of

69
00:03:16,680 --> 00:03:23,340
libraries you know if the mother is

70
00:03:20,580 --> 00:03:26,450
treated as it's often the case you will

71
00:03:23,340 --> 00:03:30,060
lost lot of time into analyzing in to

72
00:03:26,450 --> 00:03:32,280
try to understand which functions came

73
00:03:30,060 --> 00:03:34,290
from libraries and which functions are

74
00:03:32,280 --> 00:03:37,020
actually typical of this malware and

75
00:03:34,290 --> 00:03:40,260
require more and more attention so this

76
00:03:37,020 --> 00:03:42,090
is another important problem finally you

77
00:03:40,260 --> 00:03:46,560
can also imagine to use binary

78
00:03:42,090 --> 00:03:49,050
similarity in order to take to hunt for

79
00:03:46,560 --> 00:03:53,030
malware in the wild because if you can

80
00:03:49,050 --> 00:03:55,800
determine that a given function is a

81
00:03:53,030 --> 00:03:58,940
particular of a given malware family

82
00:03:55,800 --> 00:04:03,510
then you can try to find out if these

83
00:03:58,940 --> 00:04:06,450
dysfunctions is inside a given sample so

84
00:04:03,510 --> 00:04:09,510
we were not the first to try to solve

85
00:04:06,450 --> 00:04:12,450
this problem in the past year there

86
00:04:09,510 --> 00:04:15,540
there have been multiple solution but

87
00:04:12,450 --> 00:04:18,209
each of this solution presents some

88
00:04:15,540 --> 00:04:21,209
issue the most famous one is probably

89
00:04:18,209 --> 00:04:24,140
belief belief is a plug-in for the

90
00:04:21,209 --> 00:04:27,479
familes disassembled Ida Pro and

91
00:04:24,140 --> 00:04:28,610
basically what it tries to do is to

92
00:04:27,479 --> 00:04:30,349
compare the

93
00:04:28,610 --> 00:04:32,659
control flow graph of true binary

94
00:04:30,349 --> 00:04:35,389
function and it try to compare this

95
00:04:32,659 --> 00:04:38,719
graph this graph comparing basic blocks

96
00:04:35,389 --> 00:04:41,060
and if when it found that some basic

97
00:04:38,719 --> 00:04:44,389
blocks are different we eat will point

98
00:04:41,060 --> 00:04:47,569
out it to the user belief is very useful

99
00:04:44,389 --> 00:04:49,490
if you want to analyze a patch but it is

100
00:04:47,569 --> 00:04:51,740
not very useful if we want to compare

101
00:04:49,490 --> 00:04:54,319
similar need similarity between lot of

102
00:04:51,740 --> 00:04:56,930
functions because comparing graph is not

103
00:04:54,319 --> 00:04:59,360
a scalable computation and it will

104
00:04:56,930 --> 00:05:04,039
require basically impossible time to do

105
00:04:59,360 --> 00:05:08,029
lot of comparison another nice tool that

106
00:05:04,039 --> 00:05:10,340
in some way so this problem is I'd

107
00:05:08,029 --> 00:05:13,069
applaud for technology this is a

108
00:05:10,340 --> 00:05:16,188
proprietary technology of either that

109
00:05:13,069 --> 00:05:19,099
actually is very useful when you you

110
00:05:16,189 --> 00:05:21,349
have a three-bed battle and and it

111
00:05:19,099 --> 00:05:23,840
permits you to detect library functions

112
00:05:21,349 --> 00:05:26,419
in this binary the main problem of this

113
00:05:23,840 --> 00:05:29,810
technology is that it is signature

114
00:05:26,419 --> 00:05:32,870
method so basically it try to look into

115
00:05:29,810 --> 00:05:35,479
the banner if it if it found some

116
00:05:32,870 --> 00:05:38,060
signature of a known library function

117
00:05:35,479 --> 00:05:40,758
here the problem is that using signature

118
00:05:38,060 --> 00:05:43,759
you need to create a knowledge base that

119
00:05:40,759 --> 00:05:46,099
actually contain a copy a very similar

120
00:05:43,759 --> 00:05:49,400
copy of the library functions you have

121
00:05:46,099 --> 00:05:52,729
been your binary then we have the Opera

122
00:05:49,400 --> 00:05:55,729
the Opera is a very nice plugin it is an

123
00:05:52,729 --> 00:05:57,710
open source plugin and it is all it is

124
00:05:55,729 --> 00:06:00,469
for either prevent radar show and

125
00:05:57,710 --> 00:06:03,438
actually this plug-in implements

126
00:06:00,469 --> 00:06:05,659
different heuristics that try to give

127
00:06:03,439 --> 00:06:07,819
you a similarity score between two

128
00:06:05,659 --> 00:06:10,789
functions the main problem of the Opera

129
00:06:07,819 --> 00:06:14,479
is that actually if you use low eristic

130
00:06:10,789 --> 00:06:17,870
it works pretty well but if you use fast

131
00:06:14,479 --> 00:06:21,050
eristic this does not work very well so

132
00:06:17,870 --> 00:06:24,050
it can be improved and finally we have

133
00:06:21,050 --> 00:06:27,379
Yarra Yarra is not actually built for

134
00:06:24,050 --> 00:06:30,110
binary similarity but it is an engine in

135
00:06:27,379 --> 00:06:32,890
which you can write rule and

136
00:06:30,110 --> 00:06:36,860
and it will trigger a double if it found

137
00:06:32,890 --> 00:06:39,080
some particular pattern of bytes in the

138
00:06:36,860 --> 00:06:41,870
binary that we are analyzing you can

139
00:06:39,080 --> 00:06:44,650
imagine to use yara to build a custom

140
00:06:41,870 --> 00:06:47,690
rule in order to target a specific

141
00:06:44,650 --> 00:06:49,940
functions but in that case you will

142
00:06:47,690 --> 00:06:53,000
require a human analyst that will write

143
00:06:49,940 --> 00:06:55,640
their world so to wake up existing

144
00:06:53,000 --> 00:06:58,310
solution of three main issue the first

145
00:06:55,640 --> 00:07:00,650
is the scalability the second is that

146
00:06:58,310 --> 00:07:02,540
they require an exact copy of the

147
00:07:00,650 --> 00:07:06,020
functions you want to match and the

148
00:07:02,540 --> 00:07:08,180
third one is that basically in your base

149
00:07:06,020 --> 00:07:12,049
approach you need analysts that write

150
00:07:08,180 --> 00:07:14,960
fuel but let me spend some word more

151
00:07:12,050 --> 00:07:17,710
about recompilation you know that if you

152
00:07:14,960 --> 00:07:20,390
have a malware it is very easy to

153
00:07:17,710 --> 00:07:22,940
recompile it instead of obfuscating

154
00:07:20,390 --> 00:07:25,700
because when you are compiling you don't

155
00:07:22,940 --> 00:07:27,980
you are sure that the application will

156
00:07:25,700 --> 00:07:30,620
work but it is also very effective

157
00:07:27,980 --> 00:07:33,080
because we've just a careful

158
00:07:30,620 --> 00:07:35,510
recompilation you can try to avoid

159
00:07:33,080 --> 00:07:38,330
different antivirus engine but also you

160
00:07:35,510 --> 00:07:44,000
can make the derive of the analyst very

161
00:07:38,330 --> 00:07:47,570
very hard so in our research our goal

162
00:07:44,000 --> 00:07:50,480
was to find out if we can make something

163
00:07:47,570 --> 00:07:53,450
more and if we can build a new solution

164
00:07:50,480 --> 00:07:55,580
that are both efficient and effective in

165
00:07:53,450 --> 00:07:57,969
order to solve the binary similarity

166
00:07:55,580 --> 00:08:01,130
problem and we found out that actually

167
00:07:57,970 --> 00:08:03,440
using some techniques that we borrow

168
00:08:01,130 --> 00:08:08,390
from natural language processing field

169
00:08:03,440 --> 00:08:11,660
is where can can actually give us a very

170
00:08:08,390 --> 00:08:14,270
good solution to this problem so the

171
00:08:11,660 --> 00:08:17,330
technique we use is based on the famous

172
00:08:14,270 --> 00:08:20,000
model that is called worth work this is

173
00:08:17,330 --> 00:08:22,820
a model that has been built some years

174
00:08:20,000 --> 00:08:25,340
ago and basically it permits to to

175
00:08:22,820 --> 00:08:29,000
associate to associate to a given world

176
00:08:25,340 --> 00:08:32,510
in a text an embedding writer

177
00:08:29,000 --> 00:08:35,260
so let me explain what is an embedding

178
00:08:32,510 --> 00:08:38,140
vector an embedding vector is actually a

179
00:08:35,260 --> 00:08:41,340
series of number and array you

180
00:08:38,140 --> 00:08:43,750
imagine that represents an entity and

181
00:08:41,340 --> 00:08:45,970
for example in the natural language

182
00:08:43,750 --> 00:08:49,330
processing field you can build

183
00:08:45,970 --> 00:08:52,240
embeddings forward sentences order all

184
00:08:49,330 --> 00:08:55,210
world documents but what is very nice of

185
00:08:52,240 --> 00:08:58,090
demanding is that if I have a good model

186
00:08:55,210 --> 00:09:00,280
that is able to take as input words or

187
00:08:58,090 --> 00:09:02,830
sentences and to give us out route

188
00:09:00,280 --> 00:09:05,620
embeddings these abandons actually will

189
00:09:02,830 --> 00:09:07,990
preserve some information of the entity

190
00:09:05,620 --> 00:09:10,210
they represent for example in the case

191
00:09:07,990 --> 00:09:11,860
of words embeddings are able to

192
00:09:10,210 --> 00:09:15,490
represent the semantic similarity

193
00:09:11,860 --> 00:09:18,280
between words to make an example imagine

194
00:09:15,490 --> 00:09:22,030
that you have two words binary and

195
00:09:18,280 --> 00:09:24,970
banners if with your worth work model

196
00:09:22,030 --> 00:09:27,130
you can associate to these chores to

197
00:09:24,970 --> 00:09:31,600
embedding vector this empathic water

198
00:09:27,130 --> 00:09:34,120
will be not randomly the since the word

199
00:09:31,600 --> 00:09:36,610
binary manatees have a very similar

200
00:09:34,120 --> 00:09:38,560
meanings when you will compute the dot

201
00:09:36,610 --> 00:09:41,680
product between these two abandon

202
00:09:38,560 --> 00:09:44,800
vectors if they are if the model is good

203
00:09:41,680 --> 00:09:47,229
there the dot product will be very close

204
00:09:44,800 --> 00:09:50,589
to one

205
00:09:47,230 --> 00:09:52,960
so why embeddings are so important they

206
00:09:50,590 --> 00:09:56,070
are so important because basically it

207
00:09:52,960 --> 00:10:00,070
deeper meets to make fast computation

208
00:09:56,070 --> 00:10:03,090
because working with vectors it's really

209
00:10:00,070 --> 00:10:06,760
easy if and fast if you use for example

210
00:10:03,090 --> 00:10:07,420
GPU and NVIDIA and also are very easy to

211
00:10:06,760 --> 00:10:09,730
share

212
00:10:07,420 --> 00:10:12,760
so embedding sorry very good candidate

213
00:10:09,730 --> 00:10:15,010
in order to represent functions our idea

214
00:10:12,760 --> 00:10:17,290
was to associate to each binary

215
00:10:15,010 --> 00:10:19,689
functions and embedding better and then

216
00:10:17,290 --> 00:10:21,370
computing the similarity between the

217
00:10:19,690 --> 00:10:23,800
Zeeman dissimilarity between the

218
00:10:21,370 --> 00:10:26,620
functions using the same bindings the

219
00:10:23,800 --> 00:10:28,990
idea is very simple but the main problem

220
00:10:26,620 --> 00:10:32,710
is how we create this embedding how we

221
00:10:28,990 --> 00:10:34,810
can train a model that is able to take

222
00:10:32,710 --> 00:10:36,730
as input a binary functions add to

223
00:10:34,810 --> 00:10:41,170
output a semantic preserving the

224
00:10:36,730 --> 00:10:43,600
bandings let me show you how does the

225
00:10:41,170 --> 00:10:46,780
world work model works and how we apply

226
00:10:43,600 --> 00:10:49,160
it to the binary code so they the idea

227
00:10:46,780 --> 00:10:51,230
were to AK is very simple they

228
00:10:49,160 --> 00:10:54,589
underline assumption is that actually

229
00:10:51,230 --> 00:10:57,860
the meaning of each sentence into a text

230
00:10:54,589 --> 00:11:00,379
is represented also by its context so

231
00:10:57,860 --> 00:11:04,240
what the word Toorak model tries to do

232
00:11:00,379 --> 00:11:07,730
he tries to predict a sentences a word

233
00:11:04,240 --> 00:11:10,850
inside the sentences given its context

234
00:11:07,730 --> 00:11:13,220
so for example in the third line the the

235
00:11:10,850 --> 00:11:16,189
model try to predict the word Brown

236
00:11:13,220 --> 00:11:19,459
given given the word the quick and fox

237
00:11:16,189 --> 00:11:21,769
jumps in this way at each iteration the

238
00:11:19,459 --> 00:11:24,500
model update the bendings of each word

239
00:11:21,769 --> 00:11:26,120
that are initially the randomly and at

240
00:11:24,500 --> 00:11:28,279
the end of the training we will get

241
00:11:26,120 --> 00:11:33,470
embeddings that actually represent very

242
00:11:28,279 --> 00:11:36,439
well the semantics of the world in order

243
00:11:33,470 --> 00:11:40,040
to show that this works I I have this

244
00:11:36,439 --> 00:11:43,519
plot and for example if we plot the

245
00:11:40,040 --> 00:11:46,730
bedding of the world into a plane we can

246
00:11:43,519 --> 00:11:49,069
see that this embedding preserve

247
00:11:46,730 --> 00:11:52,610
relationship between words we can also

248
00:11:49,069 --> 00:11:54,949
imagine to ask to our model some kind of

249
00:11:52,610 --> 00:11:57,230
relationship for example the research

250
00:11:54,949 --> 00:12:00,620
that first developed both to that model

251
00:11:57,230 --> 00:12:04,610
try to answer to the model this relation

252
00:12:00,620 --> 00:12:08,360
man is to women as king is to and they

253
00:12:04,610 --> 00:12:10,759
they measure that effectively the the

254
00:12:08,360 --> 00:12:13,250
embeddings curve that correspond to the

255
00:12:10,759 --> 00:12:16,939
to the solution of this sort of equation

256
00:12:13,250 --> 00:12:19,970
was the bedding of the world queen so if

257
00:12:16,939 --> 00:12:24,500
this model works very very well it is

258
00:12:19,970 --> 00:12:27,800
also able to associate two nations their

259
00:12:24,500 --> 00:12:31,069
capitals for example and we decided to

260
00:12:27,800 --> 00:12:34,550
try to apply it to the binary code so

261
00:12:31,069 --> 00:12:37,610
basically we resemble a lot of binaries

262
00:12:34,550 --> 00:12:39,949
we create a very huge corpus of binaries

263
00:12:37,610 --> 00:12:42,529
and we train the model over and over

264
00:12:39,949 --> 00:12:45,649
them basically our model was traded in

265
00:12:42,529 --> 00:12:49,970
order to predict and assembly

266
00:12:45,649 --> 00:12:52,370
instructions given its neighbor so when

267
00:12:49,970 --> 00:12:55,939
we trade out when we train our model

268
00:12:52,370 --> 00:12:59,180
then we also start to ask to our model

269
00:12:55,939 --> 00:13:02,120
some questions for example this one push

270
00:12:59,180 --> 00:13:06,258
air BP is to pop our BP as

271
00:13:02,120 --> 00:13:09,050
push Erick's is to and we see that the

272
00:13:06,259 --> 00:13:12,290
model answer with Papa Reich's

273
00:13:09,050 --> 00:13:14,479
so the embeddings effectively represent

274
00:13:12,290 --> 00:13:16,639
in some ways the semantics of the

275
00:13:14,480 --> 00:13:19,970
instructions we can also visualize this

276
00:13:16,639 --> 00:13:22,670
in 2d planes where we project the

277
00:13:19,970 --> 00:13:24,589
bending of each instructions and we see

278
00:13:22,670 --> 00:13:27,229
that actually this embedding a clustered

279
00:13:24,589 --> 00:13:28,970
together according to this to the

280
00:13:27,230 --> 00:13:31,249
semantics of the instructions for

281
00:13:28,970 --> 00:13:32,959
example in the circle we have been

282
00:13:31,249 --> 00:13:34,819
weddings that represent move

283
00:13:32,959 --> 00:13:39,109
instructions from the memory to the

284
00:13:34,819 --> 00:13:41,209
register R 0 Y in in the triangle we

285
00:13:39,110 --> 00:13:44,209
have all the instructions that represent

286
00:13:41,209 --> 00:13:48,319
a move from register to register so

287
00:13:44,209 --> 00:13:51,018
these work really well but this not this

288
00:13:48,319 --> 00:13:54,979
does not solve our problem because our

289
00:13:51,019 --> 00:13:55,970
final goal is to have embedding not for

290
00:13:54,980 --> 00:13:59,209
instructions

291
00:13:55,970 --> 00:14:02,350
but for functions so what we need is to

292
00:13:59,209 --> 00:14:05,660
take the embedding of instructions and

293
00:14:02,350 --> 00:14:08,929
aggregate them in order to build an

294
00:14:05,660 --> 00:14:11,870
embedding for able binary functions we

295
00:14:08,929 --> 00:14:14,689
tried different strategy in order to do

296
00:14:11,870 --> 00:14:16,629
it and we found out that this one was

297
00:14:14,689 --> 00:14:20,300
the one that performed the best

298
00:14:16,629 --> 00:14:22,699
basically what we do is we take a self

299
00:14:20,300 --> 00:14:25,969
attentive recurrent neural network that

300
00:14:22,699 --> 00:14:28,490
I will show a bit later and we take the

301
00:14:25,970 --> 00:14:31,309
list of instructions that are in a

302
00:14:28,490 --> 00:14:34,670
functions and we take pair of functions

303
00:14:31,309 --> 00:14:36,800
we build a desert in which we know if

304
00:14:34,670 --> 00:14:39,529
two functions were similar or not and

305
00:14:36,800 --> 00:14:42,258
with a pair of similar and similar

306
00:14:39,529 --> 00:14:45,649
functions then we fed this pair of

307
00:14:42,259 --> 00:14:50,990
functions into into our network and the

308
00:14:45,649 --> 00:14:53,059
red layer on the the red layer represent

309
00:14:50,990 --> 00:14:55,639
actually debating so we train the

310
00:14:53,059 --> 00:14:58,519
network using the similarity score

311
00:14:55,639 --> 00:15:01,009
between the two embeddings of the input

312
00:14:58,519 --> 00:15:03,620
pairs and with this similarity score we

313
00:15:01,009 --> 00:15:05,990
build our loss functions that actually

314
00:15:03,620 --> 00:15:08,660
permit to the model to learn how to

315
00:15:05,990 --> 00:15:14,240
represent if two functions are similar

316
00:15:08,660 --> 00:15:15,089
or not the model is it's called self

317
00:15:14,240 --> 00:15:17,639
attentive

318
00:15:15,089 --> 00:15:20,969
because it employs a mechanism that

319
00:15:17,639 --> 00:15:23,849
nowadays is very common in deep learning

320
00:15:20,969 --> 00:15:27,209
that actually permits to the model to

321
00:15:23,849 --> 00:15:30,479
focus on on a specific part of the input

322
00:15:27,209 --> 00:15:33,358
so for example in in our case we see

323
00:15:30,479 --> 00:15:35,209
that the model focuses on the

324
00:15:33,359 --> 00:15:38,219
instructions that actually are

325
00:15:35,209 --> 00:15:41,549
Conservatoire compiled a code for

326
00:15:38,219 --> 00:15:43,529
example it focuses on calls that often

327
00:15:41,549 --> 00:15:46,619
are conserved if you use another

328
00:15:43,529 --> 00:15:51,809
compiler and in this way students on how

329
00:15:46,619 --> 00:15:54,839
to represent two functions so the the

330
00:15:51,809 --> 00:15:58,259
world pipeline is this one we take our

331
00:15:54,839 --> 00:15:59,939
binary functions first we use the

332
00:15:58,259 --> 00:16:02,219
instruction to work model that we

333
00:15:59,939 --> 00:16:04,709
trained before in that permits us to

334
00:16:02,219 --> 00:16:07,199
associate to each instructions and

335
00:16:04,709 --> 00:16:09,988
imbedding then we take the same body we

336
00:16:07,199 --> 00:16:13,019
fed them into our trainer surfactant in

337
00:16:09,989 --> 00:16:15,179
for a courier network and as output we

338
00:16:13,019 --> 00:16:19,619
have the embedding of death of the input

339
00:16:15,179 --> 00:16:21,749
functions so now that we are we are we

340
00:16:19,619 --> 00:16:24,439
have a way to compute this embedding we

341
00:16:21,749 --> 00:16:28,709
want to know if actually these words and

342
00:16:24,439 --> 00:16:31,228
but first let me point out something

343
00:16:28,709 --> 00:16:34,459
that is very important the main problem

344
00:16:31,229 --> 00:16:38,069
in nowadays in building deep learning

345
00:16:34,459 --> 00:16:42,089
techniques is that actually you need a

346
00:16:38,069 --> 00:16:44,669
very huge data set but when you want to

347
00:16:42,089 --> 00:16:47,549
apply deep learning to binaries it is

348
00:16:44,669 --> 00:16:50,069
not difficult to have a larger because

349
00:16:47,549 --> 00:16:55,019
you can download lot of projects from

350
00:16:50,069 --> 00:16:58,139
open source repository like beat up and

351
00:16:55,019 --> 00:17:00,869
you can compile it with different

352
00:16:58,139 --> 00:17:03,629
compilers each compiler has at least

353
00:17:00,869 --> 00:17:07,169
different optimization you can also use

354
00:17:03,629 --> 00:17:10,740
different flags and so basically you can

355
00:17:07,169 --> 00:17:13,169
create in few day is a very large data

356
00:17:10,740 --> 00:17:18,089
set when you have lot of binary what you

357
00:17:13,169 --> 00:17:20,730
do is you take powerful machine with

358
00:17:18,089 --> 00:17:23,309
some demas assembler you start to

359
00:17:20,730 --> 00:17:25,919
disassemble all your binaries and you

360
00:17:23,309 --> 00:17:27,689
will obtain your data set it is

361
00:17:25,919 --> 00:17:28,290
important that also when you compile you

362
00:17:27,689 --> 00:17:31,470
cannot see

363
00:17:28,290 --> 00:17:34,260
so it's also easy to build your ground

364
00:17:31,470 --> 00:17:36,810
hood and actually we see that in this

365
00:17:34,260 --> 00:17:40,650
way these techniques works really well

366
00:17:36,810 --> 00:17:42,659
in this plot this is a receiver

367
00:17:40,650 --> 00:17:46,140
operating characteristic curve basically

368
00:17:42,660 --> 00:17:48,390
this curve or tell us how well a

369
00:17:46,140 --> 00:17:50,460
classifier is able to distinguish

370
00:17:48,390 --> 00:17:53,940
between the two class in our case it

371
00:17:50,460 --> 00:17:56,610
tell us how well safe is able to

372
00:17:53,940 --> 00:17:59,130
distinguish between similar and similar

373
00:17:56,610 --> 00:18:01,860
functions if if we have a perfect

374
00:17:59,130 --> 00:18:04,560
classifier the area under this curve

375
00:18:01,860 --> 00:18:07,379
will be one and actually the curve will

376
00:18:04,560 --> 00:18:09,570
be a rectangle but as you can see safe

377
00:18:07,380 --> 00:18:13,290
that is represented by the green curve

378
00:18:09,570 --> 00:18:16,830
perform very close to the perfection

379
00:18:13,290 --> 00:18:18,750
while other two solution that we try one

380
00:18:16,830 --> 00:18:22,169
was Gemini that was an old research

381
00:18:18,750 --> 00:18:26,630
paper and yet the blue one was another

382
00:18:22,170 --> 00:18:29,010
paper that we made perform not so well

383
00:18:26,630 --> 00:18:31,950
for example they are and that they cook

384
00:18:29,010 --> 00:18:37,860
that in the perfect case a one for safe

385
00:18:31,950 --> 00:18:41,250
was was 0.99 so it is really good but we

386
00:18:37,860 --> 00:18:44,490
also try to use safe as a to evaluate

387
00:18:41,250 --> 00:18:47,540
safe as a function search engine so what

388
00:18:44,490 --> 00:18:50,220
we did is we take different version of

389
00:18:47,540 --> 00:18:52,649
PostgreSQL we compile it with different

390
00:18:50,220 --> 00:18:54,780
compilers and we build basically a

391
00:18:52,650 --> 00:18:57,390
knowledge base with all the functions

392
00:18:54,780 --> 00:18:58,920
from progress then we select randomly

393
00:18:57,390 --> 00:19:01,170
some functions from this knowledge

394
00:18:58,920 --> 00:19:03,030
knowledge base and we compute the

395
00:19:01,170 --> 00:19:05,550
bedding for they work they all function

396
00:19:03,030 --> 00:19:07,410
in the right base and we start to worry

397
00:19:05,550 --> 00:19:11,220
the knowledge base as a search engine

398
00:19:07,410 --> 00:19:14,430
using searching functions using safe

399
00:19:11,220 --> 00:19:16,380
embedding and we see that for example if

400
00:19:14,430 --> 00:19:20,790
we retrieve the 10 most similar

401
00:19:16,380 --> 00:19:23,130
functions to a query safe is able to

402
00:19:20,790 --> 00:19:25,770
reach an accuracy on distance of 10

403
00:19:23,130 --> 00:19:30,420
functions a precision on the state

404
00:19:25,770 --> 00:19:32,550
function of 0.9 so basically if you

405
00:19:30,420 --> 00:19:34,830
retrieve 10 functions from your

406
00:19:32,550 --> 00:19:36,850
knowledge base nine of them are actually

407
00:19:34,830 --> 00:19:39,639
similar to your query

408
00:19:36,850 --> 00:19:42,010
I think that this is a very important a

409
00:19:39,640 --> 00:19:46,260
very good and important a result that

410
00:19:42,010 --> 00:19:51,700
actually I that actually permits if to

411
00:19:46,260 --> 00:19:54,850
be at the state of the art but what is

412
00:19:51,700 --> 00:19:58,360
what I like also dramatics is that on

413
00:19:54,850 --> 00:20:02,260
top of embeddings you can try to build

414
00:19:58,360 --> 00:20:04,479
different classifier when you have a

415
00:20:02,260 --> 00:20:07,870
mathematical representation of an end it

416
00:20:04,480 --> 00:20:12,100
is basically the limit is only your

417
00:20:07,870 --> 00:20:14,110
creativity so what we did is we create a

418
00:20:12,100 --> 00:20:16,719
new data set where we manually

419
00:20:14,110 --> 00:20:19,780
classified functions according to their

420
00:20:16,720 --> 00:20:22,350
semantics in our data set we have four

421
00:20:19,780 --> 00:20:24,700
different semantic classes that were

422
00:20:22,350 --> 00:20:27,070
function that implements sorting

423
00:20:24,700 --> 00:20:30,429
encryption swingman emulation and

424
00:20:27,070 --> 00:20:31,540
mathematical operation and we compile at

425
00:20:30,429 --> 00:20:34,330
all these functions with different

426
00:20:31,540 --> 00:20:36,100
compilers we compute the embeddings for

427
00:20:34,330 --> 00:20:38,678
these functions with the training model

428
00:20:36,100 --> 00:20:41,980
and then we project the design methods

429
00:20:38,679 --> 00:20:45,130
onto a 2d planes and actually what we

430
00:20:41,980 --> 00:20:47,040
see is that as in this figure the

431
00:20:45,130 --> 00:20:49,059
embeddings are clustered together

432
00:20:47,040 --> 00:20:51,428
according to the functions they

433
00:20:49,059 --> 00:20:54,220
represent this means that actually if I

434
00:20:51,429 --> 00:20:57,340
have two encryptions functions their

435
00:20:54,220 --> 00:21:00,280
embedding will be similar and I can I

436
00:20:57,340 --> 00:21:04,659
can be able to distinguish them from two

437
00:21:00,280 --> 00:21:06,910
functions that implement sorting and we

438
00:21:04,660 --> 00:21:09,429
build on a classifier on top of it in

439
00:21:06,910 --> 00:21:11,650
order to evaluate also the ability on

440
00:21:09,429 --> 00:21:14,679
discriminating between the four

441
00:21:11,650 --> 00:21:18,190
different classes and we see that safe

442
00:21:14,679 --> 00:21:20,860
this safe as an active the using safe

443
00:21:18,190 --> 00:21:23,980
embedding with support vector machine

444
00:21:20,860 --> 00:21:28,000
class classifier that is the basic one

445
00:21:23,980 --> 00:21:30,970
we have an accuracy of 0.25 so quite

446
00:21:28,000 --> 00:21:34,179
near to the perfection also in this case

447
00:21:30,970 --> 00:21:37,299
I liked very much this application of

448
00:21:34,179 --> 00:21:40,510
safe because it paved the way for very

449
00:21:37,299 --> 00:21:43,720
interesting solution for reverse

450
00:21:40,510 --> 00:21:46,658
engineering that I will show you so now

451
00:21:43,720 --> 00:21:48,540
this is the nice part where I will show

452
00:21:46,659 --> 00:21:51,360
you some application of the

453
00:21:48,540 --> 00:21:53,639
if and I will start with an application

454
00:21:51,360 --> 00:21:56,969
of the semantic classification where we

455
00:21:53,640 --> 00:21:59,730
try to identify an encryption function

456
00:21:56,970 --> 00:22:02,400
the encryption function order of arizim

457
00:21:59,730 --> 00:22:04,890
on a Avera somewhere without looking mad

458
00:22:02,400 --> 00:22:07,740
manually did but only using safe and

459
00:22:04,890 --> 00:22:10,800
battle then I can I will also show you

460
00:22:07,740 --> 00:22:13,110
how we can find a vulnerable functions

461
00:22:10,800 --> 00:22:16,560
inside the firmware we've saved and

462
00:22:13,110 --> 00:22:18,629
finally we'll present a tool that I also

463
00:22:16,560 --> 00:22:22,590
present at blackhat this year that is

464
00:22:18,630 --> 00:22:25,320
PRS if this is a plugin for the femoral

465
00:22:22,590 --> 00:22:27,870
search for the famous pattern matching

466
00:22:25,320 --> 00:22:32,189
engineer that actually permits you to

467
00:22:27,870 --> 00:22:35,010
use safe embedding inside aerial let's

468
00:22:32,190 --> 00:22:37,560
start with the first one so our goal in

469
00:22:35,010 --> 00:22:40,410
this case was to try to find out if

470
00:22:37,560 --> 00:22:43,350
using safe embedding we were able to

471
00:22:40,410 --> 00:22:46,320
identify which functions inside Arizona

472
00:22:43,350 --> 00:22:50,189
perform encryptions so we take a sample

473
00:22:46,320 --> 00:22:52,350
of Tesla crypt reservoir and we

474
00:22:50,190 --> 00:22:54,840
disassemble it with either and we

475
00:22:52,350 --> 00:22:56,909
compute the embeddings for all the

476
00:22:54,840 --> 00:23:00,149
functions we found inside it

477
00:22:56,910 --> 00:23:03,210
then we take the same body we apply our

478
00:23:00,150 --> 00:23:07,350
trainer classifier on this and with and

479
00:23:03,210 --> 00:23:09,810
we realized that actually six functions

480
00:23:07,350 --> 00:23:15,030
of the 200 functions that were inside

481
00:23:09,810 --> 00:23:17,240
this sample were are classified as seven

482
00:23:15,030 --> 00:23:21,360
functions were classified as encryptions

483
00:23:17,240 --> 00:23:23,940
so we we manually look at these

484
00:23:21,360 --> 00:23:27,899
functions in order to understand if our

485
00:23:23,940 --> 00:23:29,940
classifier was right or not and we see

486
00:23:27,900 --> 00:23:33,420
that six of them were effectively

487
00:23:29,940 --> 00:23:36,630
performing encryption for example this

488
00:23:33,420 --> 00:23:39,090
one you can see that this is a

489
00:23:36,630 --> 00:23:42,330
performing encryption because it does a

490
00:23:39,090 --> 00:23:45,149
lot of math operation and we also look

491
00:23:42,330 --> 00:23:46,800
at the call to these functions but after

492
00:23:45,150 --> 00:23:49,380
a while we arrive that actually this is

493
00:23:46,800 --> 00:23:52,110
a functional deployment sha-1 so

494
00:23:49,380 --> 00:23:56,070
effectively the classifier was able to

495
00:23:52,110 --> 00:23:59,010
see to give a very important information

496
00:23:56,070 --> 00:23:59,639
to the reverse engineer that is where is

497
00:23:59,010 --> 00:24:05,129
the

498
00:23:59,640 --> 00:24:07,890
krypter function this application can be

499
00:24:05,130 --> 00:24:10,410
really useful if you imagine that you

500
00:24:07,890 --> 00:24:13,500
have a firmer for example we have an

501
00:24:10,410 --> 00:24:16,680
Ethernet switch and you want to analyze

502
00:24:13,500 --> 00:24:19,230
this framework if you can if you have a

503
00:24:16,680 --> 00:24:21,390
methodology in order to automatically

504
00:24:19,230 --> 00:24:23,520
see the semantics of the function to

505
00:24:21,390 --> 00:24:27,140
automatically detect the semantics of

506
00:24:23,520 --> 00:24:30,450
the function you find inside this fever

507
00:24:27,140 --> 00:24:31,770
you can have a sort of alert system

508
00:24:30,450 --> 00:24:35,070
because let's imagine that we have this

509
00:24:31,770 --> 00:24:37,560
Ethernet switch and looking at the femur

510
00:24:35,070 --> 00:24:40,439
with this automatic tool you see that

511
00:24:37,560 --> 00:24:43,139
there is some function that performs for

512
00:24:40,440 --> 00:24:44,910
example encryption why you have any

513
00:24:43,140 --> 00:24:48,180
kitchen functions inside the nether and

514
00:24:44,910 --> 00:24:48,750
with that you scope is only two forward

515
00:24:48,180 --> 00:24:52,110
packets

516
00:24:48,750 --> 00:24:54,600
this does not sound good and so you can

517
00:24:52,110 --> 00:24:58,050
try to reverse engineer it hardly and

518
00:24:54,600 --> 00:25:01,110
try to understand what's going on so

519
00:24:58,050 --> 00:25:05,730
this is I think one of the very useful

520
00:25:01,110 --> 00:25:09,419
use case for this research then the

521
00:25:05,730 --> 00:25:12,360
second one is another problem we have

522
00:25:09,420 --> 00:25:14,850
always a filmer and we want to analyze

523
00:25:12,360 --> 00:25:18,270
the femur in order for example to

524
00:25:14,850 --> 00:25:21,629
understand if this femur is affected by

525
00:25:18,270 --> 00:25:25,110
the heartbleed bug or not as we see

526
00:25:21,630 --> 00:25:29,460
before often embedded systems employ all

527
00:25:25,110 --> 00:25:31,199
libraries and so it is important to to

528
00:25:29,460 --> 00:25:36,150
to understand if they have some

529
00:25:31,200 --> 00:25:39,570
vulnerability or not and so how we can

530
00:25:36,150 --> 00:25:43,020
do it with safe is very simple because

531
00:25:39,570 --> 00:25:46,260
what we need is just a functions of the

532
00:25:43,020 --> 00:25:48,480
earth bleed pool is just a copy of the

533
00:25:46,260 --> 00:25:50,370
earth bleed venerable functions so what

534
00:25:48,480 --> 00:25:52,050
we can do is basically go to the

535
00:25:50,370 --> 00:25:55,080
repository of OpenSSL

536
00:25:52,050 --> 00:25:57,379
clone it compile it and take the

537
00:25:55,080 --> 00:25:59,520
vulnerable function that is know and

538
00:25:57,380 --> 00:26:02,070
compute the embedding for these

539
00:25:59,520 --> 00:26:05,340
vulnerable functions and then we can try

540
00:26:02,070 --> 00:26:07,740
to disassembly fever and compute the

541
00:26:05,340 --> 00:26:10,199
padding for all the functions we find

542
00:26:07,740 --> 00:26:12,919
inside with fever and then comparing

543
00:26:10,200 --> 00:26:15,350
these functions with our target

544
00:26:12,919 --> 00:26:17,419
if we find some candidates probably we

545
00:26:15,350 --> 00:26:21,439
will analyze them manually in order to

546
00:26:17,419 --> 00:26:24,950
see if they actually the the system is

547
00:26:21,440 --> 00:26:27,889
vulnerable or not but in order to make

548
00:26:24,950 --> 00:26:31,309
this process fast we develop a tool on

549
00:26:27,889 --> 00:26:32,178
top of yarra that we call era safe so

550
00:26:31,309 --> 00:26:35,539
how does

551
00:26:32,179 --> 00:26:39,110
Yossef works basically first of all the

552
00:26:35,539 --> 00:26:42,950
analysts use december like either it

553
00:26:39,110 --> 00:26:45,529
opened the vulnerable copy of the

554
00:26:42,950 --> 00:26:47,960
programs it detects the vulnerable

555
00:26:45,529 --> 00:26:50,360
functions it compute with a plugin that

556
00:26:47,960 --> 00:26:53,299
we develop the embedding for this

557
00:26:50,360 --> 00:26:56,449
function basically the plugin takes the

558
00:26:53,299 --> 00:26:59,240
binary code send it to a server where

559
00:26:56,450 --> 00:27:02,899
the model is run and the server hands

560
00:26:59,240 --> 00:27:04,970
work with the embedding for the for the

561
00:27:02,899 --> 00:27:08,360
functions then the analysts take

562
00:27:04,970 --> 00:27:11,269
disembody put them bedding into a year

563
00:27:08,360 --> 00:27:13,779
rule and then it starts to scan yeah are

564
00:27:11,269 --> 00:27:17,779
the programs that you want to analyze

565
00:27:13,779 --> 00:27:20,090
yada-yada what we'll do is to decompile

566
00:27:17,779 --> 00:27:22,909
it is to disassemble the programs and

567
00:27:20,090 --> 00:27:25,129
then it will start to query always our

568
00:27:22,909 --> 00:27:27,889
server in order to compute the bending

569
00:27:25,129 --> 00:27:28,248
for all the function that are inside the

570
00:27:27,889 --> 00:27:30,619
program

571
00:27:28,249 --> 00:27:32,809
and finally if there are some function

572
00:27:30,619 --> 00:27:35,449
that actually has a similarity with the

573
00:27:32,809 --> 00:27:38,090
target one in the rule that is above a

574
00:27:35,450 --> 00:27:42,409
given threshold the you will the rule

575
00:27:38,090 --> 00:27:45,470
will be triggered so our rule is made

576
00:27:42,409 --> 00:27:48,889
basically first of all a year a thief

577
00:27:45,470 --> 00:27:51,440
you'll import our model safe then what

578
00:27:48,889 --> 00:27:53,990
is very important is the condition for

579
00:27:51,440 --> 00:27:57,259
the condition you just call the function

580
00:27:53,990 --> 00:27:59,389
safe dot similarity and the argument of

581
00:27:57,259 --> 00:28:02,450
these functions is the bedding of the

582
00:27:59,389 --> 00:28:05,090
function you want to match then if this

583
00:28:02,450 --> 00:28:09,200
embedding is above a given threshold for

584
00:28:05,090 --> 00:28:13,730
example 0.97 this rule we will be

585
00:28:09,200 --> 00:28:17,539
triggered so let me show you how that it

586
00:28:13,730 --> 00:28:18,530
works practically the we in this video I

587
00:28:17,539 --> 00:28:22,460
will compute

588
00:28:18,530 --> 00:28:24,860
the embedding for the function that is

589
00:28:22,460 --> 00:28:28,240
vulnerable to the earth bed bug so

590
00:28:24,860 --> 00:28:31,070
basically now I'm loading into my

591
00:28:28,240 --> 00:28:34,850
disassembler the vulnerable executable

592
00:28:31,070 --> 00:28:36,679
that that is this one this is the

593
00:28:34,850 --> 00:28:37,840
function or this is the version of

594
00:28:36,680 --> 00:28:42,020
OpenSSL

595
00:28:37,840 --> 00:28:46,070
1:01 a high load it now I will try to

596
00:28:42,020 --> 00:28:51,050
detect the what the vulnerable function

597
00:28:46,070 --> 00:28:54,740
that is TLS one process earth bit I will

598
00:28:51,050 --> 00:28:57,110
select selected and now we were shortcut

599
00:28:54,740 --> 00:29:00,920
I will compute them binding that will

600
00:28:57,110 --> 00:29:03,649
appear in the console here here AB

601
00:29:00,920 --> 00:29:08,660
depending so what I have to do now is

602
00:29:03,650 --> 00:29:13,670
just copy it and paste it into my yard

603
00:29:08,660 --> 00:29:25,550
and now I will show you life if they

604
00:29:13,670 --> 00:29:29,330
will work so this is the rule that I

605
00:29:25,550 --> 00:29:32,659
have just computed and now I will scan

606
00:29:29,330 --> 00:29:36,290
three version of OpenSSL in order to see

607
00:29:32,660 --> 00:29:41,180
if they are vulnerable or not the first

608
00:29:36,290 --> 00:29:45,530
one is 1 0 1 a that is the one that I

609
00:29:41,180 --> 00:29:51,790
use to make the rule and that luckily it

610
00:29:45,530 --> 00:29:54,440
will match and after a while now Yara is

611
00:29:51,790 --> 00:29:58,010
disassembling and as you can see there

612
00:29:54,440 --> 00:30:00,830
you will trigger it and this is obvious

613
00:29:58,010 --> 00:30:03,020
because this is the same program that I

614
00:30:00,830 --> 00:30:05,360
used to build the road now I will try

615
00:30:03,020 --> 00:30:08,389
another version of OpenSSL

616
00:30:05,360 --> 00:30:10,370
that is 1 0 1 e that is the last one

617
00:30:08,390 --> 00:30:13,280
before the patch so probably this is

618
00:30:10,370 --> 00:30:18,590
quite different from the first one but

619
00:30:13,280 --> 00:30:20,660
it is still vulnerable and and as you

620
00:30:18,590 --> 00:30:23,449
can see also in this case the rule is

621
00:30:20,660 --> 00:30:28,070
has been triggered so also this version

622
00:30:23,450 --> 00:30:31,070
is affected by the bug finally if I you

623
00:30:28,070 --> 00:30:31,899
I take the function OpenSSL one zero one

624
00:30:31,070 --> 00:30:35,918
you

625
00:30:31,900 --> 00:30:37,840
this is a budget version and this

626
00:30:35,919 --> 00:30:42,640
version does not digger the river so

627
00:30:37,840 --> 00:30:50,620
this is not vulnerable and what is very

628
00:30:42,640 --> 00:30:57,010
nice is that actually the de pet

629
00:30:50,620 --> 00:31:01,658
it's very very small I mean the earthly

630
00:30:57,010 --> 00:31:05,440
bug was caused by a buffer overflow that

631
00:31:01,659 --> 00:31:07,690
was solved with an if condition and as

632
00:31:05,440 --> 00:31:10,750
you can see this is the de compilot code

633
00:31:07,690 --> 00:31:14,500
for the vulnerable functions there is

634
00:31:10,750 --> 00:31:17,409
only one if here and if we look to the

635
00:31:14,500 --> 00:31:19,929
to the compiling code for the budget

636
00:31:17,409 --> 00:31:23,049
version you can see that we have two if

637
00:31:19,929 --> 00:31:26,350
condition so the patch was not so big

638
00:31:23,049 --> 00:31:29,110
but in this codes in this case safe was

639
00:31:26,350 --> 00:31:31,570
able to understand which version of

640
00:31:29,110 --> 00:31:36,010
OpenSSL contains the patch and which

641
00:31:31,570 --> 00:31:43,510
version not and finally I want also to

642
00:31:36,010 --> 00:31:47,649
show how we can use safe to to perform

643
00:31:43,510 --> 00:31:49,960
malware hunting so here I have a sample

644
00:31:47,649 --> 00:31:52,959
of Vipers on Arizona this is also

645
00:31:49,960 --> 00:31:57,640
another Arizona that we take example in

646
00:31:52,960 --> 00:32:00,460
the paper and yeah we I prepare a jewel

647
00:31:57,640 --> 00:32:03,370
this jewel is quite different from the

648
00:32:00,460 --> 00:32:06,070
previous one because in this case what I

649
00:32:03,370 --> 00:32:08,529
did was to combine the embedding for two

650
00:32:06,070 --> 00:32:11,049
functions in that way I hope to build

651
00:32:08,529 --> 00:32:14,710
review that will be more resilient and

652
00:32:11,049 --> 00:32:19,809
will be more useful when you want to use

653
00:32:14,710 --> 00:32:23,890
it for malware hunting so now I will run

654
00:32:19,809 --> 00:32:29,279
the rule for example on V Poisson

655
00:32:23,890 --> 00:32:29,279
example it will take yes

656
00:32:30,510 --> 00:32:36,810
it will take a while less than one

657
00:32:34,050 --> 00:32:39,090
minutes because here the bottleneck is

658
00:32:36,810 --> 00:32:41,399
the disassembler that is to disassemble

659
00:32:39,090 --> 00:32:44,909
and this sample contains lot of

660
00:32:41,400 --> 00:32:47,670
functions but then it will compute all

661
00:32:44,910 --> 00:32:50,670
the embeddings and hopefully the rule

662
00:32:47,670 --> 00:32:56,180
will be triggered what is nice is that

663
00:32:50,670 --> 00:32:58,710
actually the rule is is computed totally

664
00:32:56,180 --> 00:33:01,830
Ultimatum Attica li you don't need an

665
00:32:58,710 --> 00:33:04,070
analyst that analyzed the sample and try

666
00:33:01,830 --> 00:33:07,080
to understand which part of the function

667
00:33:04,070 --> 00:33:09,570
change when you recompile it and use

668
00:33:07,080 --> 00:33:12,090
wildcard and so on but as you can see

669
00:33:09,570 --> 00:33:14,520
the river layer has been triggered but

670
00:33:12,090 --> 00:33:18,360
the computation of the rule is made by

671
00:33:14,520 --> 00:33:20,460
the model that is learn to compute this

672
00:33:18,360 --> 00:33:23,219
embedding during the training stage and

673
00:33:20,460 --> 00:33:25,920
with this you you can basically create

674
00:33:23,220 --> 00:33:28,220
loft of fuel to match malware in an

675
00:33:25,920 --> 00:33:31,770
automatic in an automatic in

676
00:33:28,220 --> 00:33:34,650
automatically and now I will try to run

677
00:33:31,770 --> 00:33:41,340
the same rule on something that is not

678
00:33:34,650 --> 00:33:44,010
the same Walla the same malware this is

679
00:33:41,340 --> 00:33:48,419
a sample of the infirm was one a try

680
00:33:44,010 --> 00:33:51,360
reservoir in this case they will will

681
00:33:48,420 --> 00:33:55,500
not match so this is another application

682
00:33:51,360 --> 00:33:58,919
for function embeddings that can

683
00:33:55,500 --> 00:34:02,520
basically simplify the life of a reverse

684
00:33:58,920 --> 00:34:04,860
engineer because took the process for

685
00:34:02,520 --> 00:34:11,239
vetting rule is just to run a shortcut

686
00:34:04,860 --> 00:34:11,239
on the disassembly and I think I'm

687
00:34:14,989 --> 00:34:23,178
okay I have sometimes more so if you

688
00:34:20,089 --> 00:34:25,730
have some question in the meantime if

689
00:34:23,179 --> 00:34:29,089
you want to live as a star on our

690
00:34:25,730 --> 00:34:33,619
research on say for years if we publish

691
00:34:29,089 --> 00:34:35,750
all the data sets and models on our ski

692
00:34:33,619 --> 00:34:37,849
table but also if you want to have a

693
00:34:35,750 --> 00:34:40,159
look to our paper you can download it

694
00:34:37,849 --> 00:34:42,090
from archive and thank you for your

695
00:34:40,159 --> 00:34:53,679
attention

696
00:34:42,090 --> 00:34:53,679
[Applause]

697
00:34:55,579 --> 00:35:06,229
okay the one day

698
00:34:59,069 --> 00:35:06,229
Kaluga nab llamo they ready Shaku okay

699
00:35:06,289 --> 00:35:13,650
just speculative a question yes if

700
00:35:09,650 --> 00:35:16,799
enable malware programmer knows that his

701
00:35:13,650 --> 00:35:20,369
code will be checkered with the earth

702
00:35:16,799 --> 00:35:25,259
safe software theoretically it could be

703
00:35:20,369 --> 00:35:28,589
been able to these guys your softer to

704
00:35:25,259 --> 00:35:31,709
write something so that you you're safe

705
00:35:28,589 --> 00:35:35,630
soft would be not effective yes probably

706
00:35:31,709 --> 00:35:38,940
yes of course as every antivirus engine

707
00:35:35,630 --> 00:35:41,910
you can always be trick advisor in some

708
00:35:38,940 --> 00:35:43,739
ways that also seeks lot of techniques

709
00:35:41,910 --> 00:35:45,479
that are called adversarial machine

710
00:35:43,739 --> 00:35:48,529
learning that actually these are

711
00:35:45,479 --> 00:35:52,109
techniques that given a model try to

712
00:35:48,529 --> 00:35:56,130
make it miss classifying something

713
00:35:52,109 --> 00:35:58,140
and so yes but I have to say that there

714
00:35:56,130 --> 00:36:00,930
are also techniques in order to improve

715
00:35:58,140 --> 00:36:03,839
the resiliency to this type of attacks

716
00:36:00,930 --> 00:36:06,899
we didn't employ it in our study because

717
00:36:03,839 --> 00:36:09,808
we start from a research question that

718
00:36:06,900 --> 00:36:11,489
is that was basically we can't compute

719
00:36:09,809 --> 00:36:13,529
the similarity between two functions

720
00:36:11,489 --> 00:36:15,469
compiled from the same sir code and we

721
00:36:13,529 --> 00:36:18,150
have in mind an application that was

722
00:36:15,469 --> 00:36:21,390
detecting vulnerable function but

723
00:36:18,150 --> 00:36:22,859
actually yes if you imagine to the case

724
00:36:21,390 --> 00:36:25,348
of malware

725
00:36:22,859 --> 00:36:27,900
there can be possibility in which an

726
00:36:25,349 --> 00:36:30,890
outer try to fool your system with some

727
00:36:27,900 --> 00:36:30,890
versatile technique

728
00:36:36,859 --> 00:36:43,490
that's curiosity

729
00:36:39,089 --> 00:36:44,880
yes how many people then how much time a

730
00:36:43,490 --> 00:36:50,220
project

731
00:36:44,880 --> 00:36:55,500
yes our research group was made by five

732
00:36:50,220 --> 00:36:57,959
people and the time was basically one

733
00:36:55,500 --> 00:37:01,049
year the first year of my PhD actually

734
00:36:57,960 --> 00:37:06,779
we start with an idea where we does not

735
00:37:01,049 --> 00:37:09,960
use a self attentive neural network but

736
00:37:06,779 --> 00:37:12,299
we use a network that was trained in a

737
00:37:09,960 --> 00:37:17,970
similar way but take as input the

738
00:37:12,299 --> 00:37:20,460
control flow graph of a function so in

739
00:37:17,970 --> 00:37:23,578
our initial idea using the control flow

740
00:37:20,460 --> 00:37:28,019
graph could improve the results but then

741
00:37:23,579 --> 00:37:30,839
we found out that it is not fitting this

742
00:37:28,019 --> 00:37:34,769
way basically if you consider the list

743
00:37:30,839 --> 00:37:36,690
of its function it works well but we

744
00:37:34,769 --> 00:37:38,519
realize it after a while because we

745
00:37:36,690 --> 00:37:41,069
spend a lot of time in order to create

746
00:37:38,519 --> 00:37:44,129
the data set build the first system and

747
00:37:41,069 --> 00:37:46,259
after a while we realized that this one

748
00:37:44,130 --> 00:37:49,740
was the best way in order to compute

749
00:37:46,259 --> 00:37:52,259
similarity but it was I have to say that

750
00:37:49,740 --> 00:37:55,288
it was a really nice project and I have

751
00:37:52,259 --> 00:37:56,910
to I have worked with people that are

752
00:37:55,289 --> 00:38:08,000
really good and I have really enjoyed

753
00:37:56,910 --> 00:38:13,598
doing this work ok you're not tell you

754
00:38:08,000 --> 00:38:13,599
[Applause]

