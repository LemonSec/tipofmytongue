1
00:00:04,180 --> 00:00:10,360
buongiorno a tutti

2
00:00:05,990 --> 00:00:10,360
Ben Ben will butea to theorem

3
00:00:14,840 --> 00:00:19,460
and that was all the Italian that I

4
00:00:17,869 --> 00:00:23,210
could pick up in the last year was in

5
00:00:19,460 --> 00:00:26,960
Rome thank you so much and my name is

6
00:00:23,210 --> 00:00:29,599
summit I work for Citrix in India and my

7
00:00:26,960 --> 00:00:31,399
talk is about what what is an open

8
00:00:29,599 --> 00:00:34,190
standard for token-based delegated

9
00:00:31,399 --> 00:00:37,579
authorization in simple terms it means

10
00:00:34,190 --> 00:00:39,260
that I as an end-user can grant a third

11
00:00:37,579 --> 00:00:43,430
party application access to the

12
00:00:39,260 --> 00:00:45,949
resources that I own so my talk will

13
00:00:43,430 --> 00:00:48,559
cover some of the attacks that can arise

14
00:00:45,950 --> 00:00:50,739
when there are implementation pitfalls

15
00:00:48,559 --> 00:00:56,959
involved in the OAuth implementation and

16
00:00:50,739 --> 00:00:59,568
how we can mitigate them as well so a

17
00:00:56,960 --> 00:01:01,670
little bit about myself my full name is

18
00:00:59,569 --> 00:01:04,280
Sam it unwith I work for the product

19
00:01:01,670 --> 00:01:07,220
security team at Citrix web mobile app

20
00:01:04,280 --> 00:01:09,110
security enthusiast and I've spoken at a

21
00:01:07,220 --> 00:01:11,570
bunch of conferences including security

22
00:01:09,110 --> 00:01:13,220
fest Def Con China blackhat Asia apps

23
00:01:11,570 --> 00:01:21,008
accuracy and code blue in the recent

24
00:01:13,220 --> 00:01:23,299
past we'll be covering why do we need

25
00:01:21,009 --> 00:01:27,920
some information about access and

26
00:01:23,299 --> 00:01:29,540
identity tokens so earth also offers

27
00:01:27,920 --> 00:01:31,340
various grant types and we'll be

28
00:01:29,540 --> 00:01:34,939
covering a couple of them in the

29
00:01:31,340 --> 00:01:37,369
interest of time then we'll be touching

30
00:01:34,939 --> 00:01:41,990
upon earth flow for native applications

31
00:01:37,369 --> 00:01:43,340
and then we'll come to some of the

32
00:01:41,990 --> 00:01:45,048
attacks that can happen and the

33
00:01:43,340 --> 00:01:49,759
mitigation followed by a short Q&A

34
00:01:45,049 --> 00:01:51,500
session a quick disclaimer ideas

35
00:01:49,759 --> 00:01:53,719
presented a personnel have nothing to do

36
00:01:51,500 --> 00:01:55,490
with my employer some content has been

37
00:01:53,719 --> 00:01:58,309
borrowed from ran David Campbell's

38
00:01:55,490 --> 00:02:02,839
slides on or 2.0 and mobile devices

39
00:01:58,310 --> 00:02:04,789
Earth's zero and the RFC documents I'm a

40
00:02:02,840 --> 00:02:06,710
big Marvel fan so you can expect some

41
00:02:04,789 --> 00:02:07,759
references to Avengers infinity war

42
00:02:06,710 --> 00:02:14,000
throughout the course of the

43
00:02:07,759 --> 00:02:16,250
presentation all right coming to a first

44
00:02:14,000 --> 00:02:18,800
question why do we need a wot right

45
00:02:16,250 --> 00:02:21,380
let's just understand this using an

46
00:02:18,800 --> 00:02:24,980
example scenario assume you are

47
00:02:21,380 --> 00:02:27,599
accessing linkdin comm you just log in

48
00:02:24,980 --> 00:02:31,499
and then you see your home screen

49
00:02:27,599 --> 00:02:35,280
now Lingnan wants to get access to your

50
00:02:31,499 --> 00:02:37,319
gmail contacts in order to do so it

51
00:02:35,280 --> 00:02:41,790
needs some form of authentication

52
00:02:37,319 --> 00:02:44,040
authorization on your behalf so let's

53
00:02:41,790 --> 00:02:49,319
just say that linden asks you for your

54
00:02:44,040 --> 00:02:51,569
gmail contacts on LinkedIn but this is

55
00:02:49,319 --> 00:02:54,179
not a good idea because linden is asking

56
00:02:51,569 --> 00:02:56,250
for your credentials on linkedin calm

57
00:02:54,180 --> 00:02:57,780
and Lingnan calm is a third party

58
00:02:56,250 --> 00:03:00,269
application which is trying to access

59
00:02:57,780 --> 00:03:02,010
your Google resources so you do not want

60
00:03:00,269 --> 00:03:04,439
to share your Google credentials with

61
00:03:02,010 --> 00:03:08,578
LinkedIn that's a very bad practice and

62
00:03:04,439 --> 00:03:10,918
the reasons are that the knowledge of

63
00:03:08,579 --> 00:03:13,500
your Gmail password allows LinkedIn to

64
00:03:10,919 --> 00:03:15,870
get far more access then you want to

65
00:03:13,500 --> 00:03:17,819
give it it not only gets access to your

66
00:03:15,870 --> 00:03:19,919
credit contacts but it can do anything

67
00:03:17,819 --> 00:03:23,909
on your behalf you can access your drive

68
00:03:19,919 --> 00:03:26,459
it can do everything pretty much plus

69
00:03:23,909 --> 00:03:29,879
you cannot revoke access just from

70
00:03:26,459 --> 00:03:32,280
LinkedIn because your access sharing

71
00:03:29,879 --> 00:03:34,259
mechanism is based on a password and all

72
00:03:32,280 --> 00:03:36,659
the third-party applications that you

73
00:03:34,259 --> 00:03:38,399
have shared your password with will get

74
00:03:36,659 --> 00:03:40,530
revoked because if you change your

75
00:03:38,400 --> 00:03:43,259
password everybody gets revoked not just

76
00:03:40,530 --> 00:03:45,209
one so it's difficult to selectively

77
00:03:43,259 --> 00:03:50,129
revoke access from one third-party

78
00:03:45,209 --> 00:03:52,310
application the third drawback is that

79
00:03:50,129 --> 00:03:55,560
LinkedIn would be required to store your

80
00:03:52,310 --> 00:03:58,560
Gmail credentials which you do not want

81
00:03:55,560 --> 00:04:00,030
to do the fourth one is that Google will

82
00:03:58,560 --> 00:04:05,639
be forced to support password-based

83
00:04:00,030 --> 00:04:07,769
authentication so considering all these

84
00:04:05,639 --> 00:04:09,720
disadvantages this is where what came

85
00:04:07,769 --> 00:04:12,509
into being and it's a protocol for

86
00:04:09,720 --> 00:04:17,009
delegating access supported by all the

87
00:04:12,509 --> 00:04:18,659
platforms the scope of access granted to

88
00:04:17,009 --> 00:04:24,690
a third party application can be

89
00:04:18,659 --> 00:04:28,590
restricted and we can selectively revoke

90
00:04:24,690 --> 00:04:30,479
access from a specific third party it

91
00:04:28,590 --> 00:04:34,109
avoids sharing your credentials with the

92
00:04:30,479 --> 00:04:35,580
third party and the best part is that it

93
00:04:34,110 --> 00:04:37,560
also gives you a foundation for an

94
00:04:35,580 --> 00:04:39,948
authentication protocol named open ID

95
00:04:37,560 --> 00:04:39,949
Connect

96
00:04:41,160 --> 00:04:47,440
so before we go ahead and discuss the

97
00:04:43,990 --> 00:04:49,510
flow of Earth we want to introduce some

98
00:04:47,440 --> 00:04:52,540
entities that are involved in a typical

99
00:04:49,510 --> 00:04:57,370
earth flow the first one is the resource

100
00:04:52,540 --> 00:04:59,320
owner this is the end user who who can

101
00:04:57,370 --> 00:05:03,310
grant access to the protected resources

102
00:04:59,320 --> 00:05:05,680
he owns then you have the client or the

103
00:05:03,310 --> 00:05:08,200
application or the relying party this is

104
00:05:05,680 --> 00:05:10,350
the entity that is requesting access to

105
00:05:08,200 --> 00:05:14,320
the resources owned by the end user

106
00:05:10,350 --> 00:05:15,640
this was linked in in our case and then

107
00:05:14,320 --> 00:05:17,740
we have the resource server this is the

108
00:05:15,640 --> 00:05:22,030
server that hosts the resources this was

109
00:05:17,740 --> 00:05:24,700
Gmail in the previous example and then

110
00:05:22,030 --> 00:05:27,429
we have the auth server this is the

111
00:05:24,700 --> 00:05:30,070
server that authenticates the resource

112
00:05:27,430 --> 00:05:32,380
owner or the end user and grants access

113
00:05:30,070 --> 00:05:36,849
tokens to the king a client or relying

114
00:05:32,380 --> 00:05:43,060
party and finally the browser of the

115
00:05:36,850 --> 00:05:45,130
user so before moving ahead there is an

116
00:05:43,060 --> 00:05:48,040
offline step required or called client

117
00:05:45,130 --> 00:05:50,400
registration wherein the client provides

118
00:05:48,040 --> 00:05:53,470
some information to the auth server and

119
00:05:50,400 --> 00:05:56,950
that information includes a redirect URI

120
00:05:53,470 --> 00:06:00,070
as well this redirect URI is used by the

121
00:05:56,950 --> 00:06:03,450
auth server to send back auth code and

122
00:06:00,070 --> 00:06:06,159
the access tokens back to the client

123
00:06:03,450 --> 00:06:08,380
once the authorization server receives

124
00:06:06,160 --> 00:06:10,150
this information it generates a client

125
00:06:08,380 --> 00:06:13,060
ID and a client secret for the client

126
00:06:10,150 --> 00:06:17,469
and then stores this mapping of client

127
00:06:13,060 --> 00:06:19,210
ID to the redirect URI with itself in

128
00:06:17,470 --> 00:06:22,020
return the client ID and the client

129
00:06:19,210 --> 00:06:26,140
secret is sent back to the client

130
00:06:22,020 --> 00:06:28,330
so client secret we'll be using when we

131
00:06:26,140 --> 00:06:30,700
are learning about the OAuth flow it is

132
00:06:28,330 --> 00:06:34,840
used for client authentication with the

133
00:06:30,700 --> 00:06:37,270
auth server the client ID as expected is

134
00:06:34,840 --> 00:06:39,789
not is it can be a public information

135
00:06:37,270 --> 00:06:46,240
what the client secret must be kept

136
00:06:39,790 --> 00:06:48,040
confidential at all times but if an

137
00:06:46,240 --> 00:06:50,770
application cannot keep the client

138
00:06:48,040 --> 00:06:53,770
secret confidential like a single page

139
00:06:50,770 --> 00:06:54,490
application or a mobile application then

140
00:06:53,770 --> 00:07:02,198
the client

141
00:06:54,490 --> 00:07:04,840
secret is not used at all so this brings

142
00:07:02,199 --> 00:07:06,819
us to the earth flow at a high level and

143
00:07:04,840 --> 00:07:09,000
I've listed down all the entities that

144
00:07:06,819 --> 00:07:12,280
are involved starting with the end user

145
00:07:09,000 --> 00:07:16,810
the client the auth server and the

146
00:07:12,280 --> 00:07:18,638
resource server so let's say the end

147
00:07:16,810 --> 00:07:21,460
user is visiting this client stack

148
00:07:18,639 --> 00:07:23,789
exchange and stack exchange wants to

149
00:07:21,460 --> 00:07:27,580
access some of the end users information

150
00:07:23,789 --> 00:07:30,159
hosted on Google so I'll show you that

151
00:07:27,580 --> 00:07:32,258
these are the two odd servers that the

152
00:07:30,159 --> 00:07:34,599
client has registered with so it will

153
00:07:32,259 --> 00:07:37,990
show you this these two options and once

154
00:07:34,599 --> 00:07:40,599
the user chooses Google an authorization

155
00:07:37,990 --> 00:07:43,509
request is generated and the user is

156
00:07:40,599 --> 00:07:46,840
redirected to Google's or server where

157
00:07:43,509 --> 00:07:50,979
he's supposed to log in after logging in

158
00:07:46,840 --> 00:07:52,659
the authorized endpoint is where the

159
00:07:50,979 --> 00:07:54,250
Google's auth server is going to show

160
00:07:52,659 --> 00:07:58,509
the authorization request to the end

161
00:07:54,250 --> 00:08:03,009
user and once the user approves of this

162
00:07:58,509 --> 00:08:05,199
authorization request the client will

163
00:08:03,009 --> 00:08:10,090
get access to the information listed on

164
00:08:05,199 --> 00:08:18,150
this request by getting an authorization

165
00:08:10,090 --> 00:08:21,638
code so once the authorization code is

166
00:08:18,150 --> 00:08:25,948
reaches the client the client can get an

167
00:08:21,639 --> 00:08:28,990
access token on behalf of the user

168
00:08:25,949 --> 00:08:31,270
for this request the authorization codes

169
00:08:28,990 --> 00:08:34,360
need needs to be sent in the forth step

170
00:08:31,270 --> 00:08:39,399
and the access token can then be used by

171
00:08:34,360 --> 00:08:41,500
the client to access the resources so as

172
00:08:39,399 --> 00:08:44,020
you can notice there's no step where in

173
00:08:41,500 --> 00:08:46,480
the end user had to exchange credentials

174
00:08:44,020 --> 00:08:48,310
with the client the client or the end

175
00:08:46,480 --> 00:08:55,000
users credentials were always with the

176
00:08:48,310 --> 00:08:56,829
authorization server open ID Connect is

177
00:08:55,000 --> 00:08:58,930
an authentication layer on top of OAuth

178
00:08:56,829 --> 00:09:01,120
and the flow pretty much remains the

179
00:08:58,930 --> 00:09:02,949
same except the fact that in the last

180
00:09:01,120 --> 00:09:05,020
step you get back an additional token

181
00:09:02,949 --> 00:09:07,120
known as identity token which is

182
00:09:05,020 --> 00:09:07,610
consumed by the client application and

183
00:09:07,120 --> 00:09:10,250
not

184
00:09:07,610 --> 00:09:12,470
resource over the identity token is

185
00:09:10,250 --> 00:09:14,600
meant to authenticate the end user to

186
00:09:12,470 --> 00:09:21,350
the client and not for accessing the

187
00:09:14,600 --> 00:09:23,779
resource so this is how and an access

188
00:09:21,350 --> 00:09:26,750
token would look like it is a it is an

189
00:09:23,779 --> 00:09:28,970
opaque token you cannot decode it to you

190
00:09:26,750 --> 00:09:31,220
know get some more information about the

191
00:09:28,970 --> 00:09:34,310
end user and it conveys authorization

192
00:09:31,220 --> 00:09:36,370
have you've already uh we already know

193
00:09:34,310 --> 00:09:38,839
it is consumed by the resource server

194
00:09:36,370 --> 00:09:41,810
the identity tokens on the other hand

195
00:09:38,839 --> 00:09:43,610
can be decoded to fetch users can

196
00:09:41,810 --> 00:09:47,449
authenticate in contextual information

197
00:09:43,610 --> 00:09:49,130
and the information could be user's name

198
00:09:47,450 --> 00:09:52,130
email address his profile information

199
00:09:49,130 --> 00:09:57,800
etc and it is consumed by the client

200
00:09:52,130 --> 00:09:59,660
application for populating the UI these

201
00:09:57,800 --> 00:10:03,050
tokens by the way are called JSON web

202
00:09:59,660 --> 00:10:08,779
tokens and the this portion of the JSON

203
00:10:03,050 --> 00:10:11,089
web token is the payload portion so this

204
00:10:08,779 --> 00:10:13,850
brings us to the auth grant types so

205
00:10:11,089 --> 00:10:16,250
what provides vidas Granta is based on

206
00:10:13,850 --> 00:10:18,320
what kind of situation there is we'll be

207
00:10:16,250 --> 00:10:20,060
studying the first two because that's

208
00:10:18,320 --> 00:10:25,010
more or less less relevant to our

209
00:10:20,060 --> 00:10:27,619
current discourse before I go ahead

210
00:10:25,010 --> 00:10:31,370
discussing auth code grant let me just

211
00:10:27,620 --> 00:10:33,529
create an analogy for you and the

212
00:10:31,370 --> 00:10:36,320
resource server let's say it is the soul

213
00:10:33,529 --> 00:10:39,949
stone now soul stone if you remember on

214
00:10:36,320 --> 00:10:43,699
in infinity war was placed on war meat

215
00:10:39,949 --> 00:10:47,300
and Red Skull had access to the soul

216
00:10:43,699 --> 00:10:51,260
stone by the way this is just Avenger

217
00:10:47,300 --> 00:10:54,670
stuff so yeah so red skull had access to

218
00:10:51,260 --> 00:11:00,079
the resource server right now but Thanos

219
00:10:54,670 --> 00:11:01,699
wanted access to the resource and that's

220
00:11:00,079 --> 00:11:06,229
why Thanos will be a client or

221
00:11:01,699 --> 00:11:10,069
application or relying party and then we

222
00:11:06,230 --> 00:11:12,529
have Gamora since she knew where the

223
00:11:10,070 --> 00:11:14,120
soul stone is she'll play as the

224
00:11:12,529 --> 00:11:16,899
authorization server and supervise the

225
00:11:14,120 --> 00:11:16,899
authorization

226
00:11:18,370 --> 00:11:22,600
so here's the flow diagram for you so

227
00:11:20,649 --> 00:11:24,309
Tanis goes to the resource server and

228
00:11:22,600 --> 00:11:27,639
tries to access it when he gets an

229
00:11:24,309 --> 00:11:30,819
unauthorized message so Tanis the client

230
00:11:27,639 --> 00:11:33,100
now redirects the request to the real he

231
00:11:30,819 --> 00:11:35,729
redirects the resource owner to the

232
00:11:33,100 --> 00:11:39,910
authorization endpoint on the odd server

233
00:11:35,730 --> 00:11:41,529
now here the end user will accept this

234
00:11:39,910 --> 00:11:44,490
authorization he'll grant the

235
00:11:41,529 --> 00:11:46,779
authorization and get back an auth code

236
00:11:44,490 --> 00:11:49,329
the auth code is sent back to the

237
00:11:46,779 --> 00:11:51,040
redirect URI of the client that was

238
00:11:49,329 --> 00:11:54,550
registered in the client registration

239
00:11:51,040 --> 00:11:56,829
step now once the client has this auth

240
00:11:54,550 --> 00:11:59,620
code it can hit the token endpoint and

241
00:11:56,829 --> 00:12:01,209
exchange it for an access token and you

242
00:11:59,620 --> 00:12:02,709
will also notice that the client needs

243
00:12:01,209 --> 00:12:04,748
to authenticate using the client

244
00:12:02,709 --> 00:12:08,949
credentials that were given out in the

245
00:12:04,749 --> 00:12:11,680
client registration step once the client

246
00:12:08,949 --> 00:12:13,420
has the access token it can hit the

247
00:12:11,680 --> 00:12:17,709
resource server's endpoints to access

248
00:12:13,420 --> 00:12:20,769
the resource if you look at the traffic

249
00:12:17,709 --> 00:12:22,748
on the wild you're hitting the earth's

250
00:12:20,769 --> 00:12:24,939
authorized endpoint here of the

251
00:12:22,749 --> 00:12:28,209
authorization server along with the

252
00:12:24,939 --> 00:12:30,370
redirect URI which is example AB com

253
00:12:28,209 --> 00:12:34,149
let's say then you have the scope

254
00:12:30,370 --> 00:12:36,670
parameter which tells the auth server

255
00:12:34,149 --> 00:12:40,179
that what kind of information the client

256
00:12:36,670 --> 00:12:42,819
wants to access and the state parameter

257
00:12:40,179 --> 00:12:45,910
is used for avoiding CSRF attacks which

258
00:12:42,819 --> 00:12:51,670
we'll come to when we're going through

259
00:12:45,910 --> 00:12:53,740
the section for the attacks and in the

260
00:12:51,670 --> 00:12:56,949
response to this authorization request

261
00:12:53,740 --> 00:12:58,660
an auth code is generated and sent back

262
00:12:56,949 --> 00:13:03,998
at the client redirect URI in the

263
00:12:58,660 --> 00:13:05,800
response the token exchange request

264
00:13:03,999 --> 00:13:08,499
looks something like this you will have

265
00:13:05,800 --> 00:13:10,329
the auth code and the client credentials

266
00:13:08,499 --> 00:13:13,600
in this request and you get back an

267
00:13:10,329 --> 00:13:15,969
access token as a response now the

268
00:13:13,600 --> 00:13:17,290
advantages of using auth quadrant are

269
00:13:15,970 --> 00:13:19,509
that it provides the ability to

270
00:13:17,290 --> 00:13:24,189
authenticate the client using the client

271
00:13:19,509 --> 00:13:26,529
secret and the transmission of access

272
00:13:24,189 --> 00:13:28,599
token is never through the browser so

273
00:13:26,529 --> 00:13:29,920
your access token will not be leaked

274
00:13:28,600 --> 00:13:32,429
through the browser history or the

275
00:13:29,920 --> 00:13:32,429
different header

276
00:13:33,360 --> 00:13:39,430
in comparison to odd code grant the

277
00:13:36,730 --> 00:13:42,850
implicit ground is pretty much same

278
00:13:39,430 --> 00:13:45,910
except for the fact that you do not have

279
00:13:42,850 --> 00:13:47,260
an auth code request instead you know

280
00:13:45,910 --> 00:13:50,170
there's no authorization code involved

281
00:13:47,260 --> 00:13:54,490
instead the authorized endpoint will

282
00:13:50,170 --> 00:13:56,589
directly give you back a token and using

283
00:13:54,490 --> 00:14:00,100
that token the client can access the

284
00:13:56,590 --> 00:14:04,090
resources the traffic is very

285
00:14:00,100 --> 00:14:05,710
straightforward just there's just one

286
00:14:04,090 --> 00:14:08,020
request and the response has the access

287
00:14:05,710 --> 00:14:10,360
token but there are many disadvantages

288
00:14:08,020 --> 00:14:13,900
of this flow there's no client

289
00:14:10,360 --> 00:14:15,730
authentication so if your access token

290
00:14:13,900 --> 00:14:18,010
has chances of leaking through the

291
00:14:15,730 --> 00:14:21,810
browser history and you know referent

292
00:14:18,010 --> 00:14:21,810
header can also leak your access token

293
00:14:24,690 --> 00:14:32,830
now we'll be considering how what works

294
00:14:28,780 --> 00:14:36,130
on mobile clients the gist of the flow

295
00:14:32,830 --> 00:14:39,640
remains same client initiates or

296
00:14:36,130 --> 00:14:42,430
requests the end user authenticates and

297
00:14:39,640 --> 00:14:44,740
approves the server returns control with

298
00:14:42,430 --> 00:14:46,750
the auth code the auth code is traded

299
00:14:44,740 --> 00:14:48,670
for an access token and the protected

300
00:14:46,750 --> 00:14:50,760
API is are then invoked using the access

301
00:14:48,670 --> 00:14:53,079
token but there are subtle differences

302
00:14:50,760 --> 00:14:55,060
because your native application is

303
00:14:53,080 --> 00:14:57,160
running on the end-users device and

304
00:14:55,060 --> 00:14:59,170
there can't be a server to server call

305
00:14:57,160 --> 00:14:59,949
to fetch back the auth code or the

306
00:14:59,170 --> 00:15:02,140
access token

307
00:14:59,950 --> 00:15:04,750
so everything travels to the end-users

308
00:15:02,140 --> 00:15:08,890
device and we'll see that what are the

309
00:15:04,750 --> 00:15:10,870
problems related to so here the native

310
00:15:08,890 --> 00:15:13,000
application on the device is requesting

311
00:15:10,870 --> 00:15:15,310
the browser to hit the authorized end

312
00:15:13,000 --> 00:15:16,810
point and the end user will hit C the

313
00:15:15,310 --> 00:15:20,979
authorization endpoint he'll

314
00:15:16,810 --> 00:15:25,719
authenticate approve this authorization

315
00:15:20,980 --> 00:15:28,210
request and after the approval the auth

316
00:15:25,720 --> 00:15:30,070
code is sent back to the browser but the

317
00:15:28,210 --> 00:15:33,970
browser still doesn't know which app to

318
00:15:30,070 --> 00:15:37,500
return the auth code to so this this

319
00:15:33,970 --> 00:15:40,290
sort of communication requires a

320
00:15:37,500 --> 00:15:43,000
registration of a callback handler and

321
00:15:40,290 --> 00:15:43,990
generally how apps do it is that they

322
00:15:43,000 --> 00:15:46,810
use something known as

323
00:15:43,990 --> 00:15:50,170
custom URL schemes so here you will see

324
00:15:46,810 --> 00:15:54,310
that the scheme is XCOM my quat dot my

325
00:15:50,170 --> 00:15:56,319
app and this custom URL scheme is

326
00:15:54,310 --> 00:15:59,170
registered by the native application on

327
00:15:56,320 --> 00:16:01,180
the device so the browser knows that if

328
00:15:59,170 --> 00:16:03,459
any response is coming for this URL

329
00:16:01,180 --> 00:16:09,130
scheme it needs to go to this particular

330
00:16:03,459 --> 00:16:11,349
native application and this is how you

331
00:16:09,130 --> 00:16:13,089
register custom URI schemes they

332
00:16:11,350 --> 00:16:18,100
registered in the Android manifest file

333
00:16:13,089 --> 00:16:20,380
like so so once the browser gets the

334
00:16:18,100 --> 00:16:22,600
auth code it'll send back to the native

335
00:16:20,380 --> 00:16:25,450
application here and the native

336
00:16:22,600 --> 00:16:27,339
application can then exchange it for an

337
00:16:25,450 --> 00:16:31,959
access token by hitting the token

338
00:16:27,339 --> 00:16:35,050
endpoint once the access token is

339
00:16:31,959 --> 00:16:37,060
received the native application can

340
00:16:35,050 --> 00:16:44,349
directly hit the cloud API and get back

341
00:16:37,060 --> 00:16:46,359
all the resources that it wanted so

342
00:16:44,350 --> 00:16:47,740
we've covered the top four so we've

343
00:16:46,360 --> 00:16:49,750
covered pretty much all the theory that

344
00:16:47,740 --> 00:16:51,670
we had to and now we'll come to the

345
00:16:49,750 --> 00:16:58,060
attacks and then we'll go ahead with the

346
00:16:51,670 --> 00:17:00,279
questions so this attack known as

347
00:16:58,060 --> 00:17:02,170
authorization code intercept attack can

348
00:17:00,279 --> 00:17:04,270
happen on mobile clients and that's why

349
00:17:02,170 --> 00:17:08,920
we discussed the theory behind what on

350
00:17:04,270 --> 00:17:10,809
mobile devices so assume here this is

351
00:17:08,920 --> 00:17:12,520
the end users device you have a

352
00:17:10,809 --> 00:17:14,500
legitimate application and you have the

353
00:17:12,520 --> 00:17:17,139
malicious application on it and there's

354
00:17:14,500 --> 00:17:18,640
a browser and the auth server so there

355
00:17:17,140 --> 00:17:20,890
are some preconditions for this attack

356
00:17:18,640 --> 00:17:23,020
that need to be true so that the attack

357
00:17:20,890 --> 00:17:25,660
can happen so since it's a mobile device

358
00:17:23,020 --> 00:17:28,000
we cannot have a client secret provision

359
00:17:25,660 --> 00:17:29,890
for the client because it goes over the

360
00:17:28,000 --> 00:17:31,540
wire the user can easily intercept it

361
00:17:29,890 --> 00:17:34,000
and figure out what the client secret is

362
00:17:31,540 --> 00:17:35,500
or it can the user can even reverse

363
00:17:34,000 --> 00:17:37,630
engineer the application to figure out

364
00:17:35,500 --> 00:17:39,490
the client secret so there's no need for

365
00:17:37,630 --> 00:17:44,230
a client secret because it will never be

366
00:17:39,490 --> 00:17:46,900
secret so the client secret is not

367
00:17:44,230 --> 00:17:48,820
provisioned and the attacker manages to

368
00:17:46,900 --> 00:17:51,809
install the malicious application on the

369
00:17:48,820 --> 00:17:54,460
device and the malicious applications

370
00:17:51,809 --> 00:17:56,440
registers for the same custom urs scheme

371
00:17:54,460 --> 00:17:57,040
that is registered by the legitimate

372
00:17:56,440 --> 00:17:59,290
application

373
00:17:57,040 --> 00:18:01,480
so you can see where this is going right

374
00:17:59,290 --> 00:18:04,840
when the authorization request is

375
00:18:01,480 --> 00:18:06,490
generated by the laser tap it is sent to

376
00:18:04,840 --> 00:18:08,740
the odd server what server returns the

377
00:18:06,490 --> 00:18:10,300
auth cord and now the browser sees that

378
00:18:08,740 --> 00:18:11,830
there have two applications that have

379
00:18:10,300 --> 00:18:13,659
registered for the same customer a

380
00:18:11,830 --> 00:18:16,780
scheme and it ends up giving the auth

381
00:18:13,660 --> 00:18:18,490
code to both of them so the malicious

382
00:18:16,780 --> 00:18:20,920
application will also receive the auth

383
00:18:18,490 --> 00:18:25,020
code and it can fetch the access token

384
00:18:20,920 --> 00:18:25,020
on behalf of the legitimate application

385
00:18:27,450 --> 00:18:32,650
so in order to mitigate this sort of

386
00:18:30,040 --> 00:18:35,860
attack you should avoid using custom URL

387
00:18:32,650 --> 00:18:37,450
scheme redirection as we've already seen

388
00:18:35,860 --> 00:18:38,770
the custom URL scheme some looks

389
00:18:37,450 --> 00:18:42,310
something like this where the

390
00:18:38,770 --> 00:18:46,540
application package name is the URL

391
00:18:42,310 --> 00:18:48,820
scheme instead we should fall back on

392
00:18:46,540 --> 00:18:51,430
something known as claimed HTTP scheme

393
00:18:48,820 --> 00:18:54,490
your airy direction so here the scheme

394
00:18:51,430 --> 00:18:57,910
remains the same HTTPS followed by the

395
00:18:54,490 --> 00:19:00,040
fqdn of the application the advantage of

396
00:18:57,910 --> 00:19:04,480
using claimed HTTP scheme your every

397
00:19:00,040 --> 00:19:06,100
direction is that the the operating

398
00:19:04,480 --> 00:19:08,290
system provides the guarantee to the

399
00:19:06,100 --> 00:19:09,850
authorization server that this is the

400
00:19:08,290 --> 00:19:11,770
genuine application that has registered

401
00:19:09,850 --> 00:19:14,560
for it because the application would

402
00:19:11,770 --> 00:19:17,410
have to prove that it is owning this

403
00:19:14,560 --> 00:19:19,210
particular fqdn so the ownership of this

404
00:19:17,410 --> 00:19:22,600
fqdn needs to be proved by the

405
00:19:19,210 --> 00:19:25,000
application whereas this is not so in

406
00:19:22,600 --> 00:19:32,620
the case of custom URL schemes there is

407
00:19:25,000 --> 00:19:34,960
no naming authority at all but if you

408
00:19:32,620 --> 00:19:36,760
end up using custom URL schemes you

409
00:19:34,960 --> 00:19:39,310
could also use something known as proof

410
00:19:36,760 --> 00:19:45,040
key for code exchange which is also

411
00:19:39,310 --> 00:19:47,649
known as pixie so let's go through the

412
00:19:45,040 --> 00:19:49,780
flow for pixie and see how pixie can

413
00:19:47,650 --> 00:19:53,050
help you mitigate against the auth code

414
00:19:49,780 --> 00:19:55,570
intercept attack so here the additional

415
00:19:53,050 --> 00:19:57,370
step that is required is that the client

416
00:19:55,570 --> 00:19:59,399
generates a code verifier which is

417
00:19:57,370 --> 00:20:01,959
nothing but an alphanumeric value and

418
00:19:59,400 --> 00:20:05,050
this alpha numeric value called code

419
00:20:01,960 --> 00:20:09,940
verified is hashed and sent in the

420
00:20:05,050 --> 00:20:11,210
authorization request TM is the hashing

421
00:20:09,940 --> 00:20:13,850
method that is used

422
00:20:11,210 --> 00:20:14,950
and the decode verifier is called port

423
00:20:13,850 --> 00:20:18,139
challenge

424
00:20:14,950 --> 00:20:19,700
so the code challenge will go reach the

425
00:20:18,140 --> 00:20:21,980
authorization endpoint and the

426
00:20:19,700 --> 00:20:23,270
authorization server will store this

427
00:20:21,980 --> 00:20:26,620
code challenge value which is nothing

428
00:20:23,270 --> 00:20:29,059
but the hashed value of code verifier

429
00:20:26,620 --> 00:20:31,729
so once the authorization code is sent

430
00:20:29,059 --> 00:20:34,850
back it can reach the ledger tap plus

431
00:20:31,730 --> 00:20:37,610
the malicious client but when you are

432
00:20:34,850 --> 00:20:40,010
hitting the token endpoint the auth

433
00:20:37,610 --> 00:20:42,709
server expects the code verifier to come

434
00:20:40,010 --> 00:20:44,870
in the request and this code verifier is

435
00:20:42,710 --> 00:20:48,289
just known to the legitimate client and

436
00:20:44,870 --> 00:20:50,320
not the malicious client so once the

437
00:20:48,289 --> 00:20:52,850
code verifier reaches the token endpoint

438
00:20:50,320 --> 00:20:54,830
the auth server is supposed to take a

439
00:20:52,850 --> 00:20:57,110
hash of this code verifier value and

440
00:20:54,830 --> 00:21:00,080
compare it to the code challenge it

441
00:20:57,110 --> 00:21:04,580
saved earlier and if both of them match

442
00:21:00,080 --> 00:21:07,039
the access token is returned back now

443
00:21:04,580 --> 00:21:09,678
this avoids this profits the attacker

444
00:21:07,039 --> 00:21:11,320
was on the malicious client to exchange

445
00:21:09,679 --> 00:21:14,120
the auth code for an access token

446
00:21:11,320 --> 00:21:19,970
because he cannot know the code verifies

447
00:21:14,120 --> 00:21:22,389
value so this is a bug i found with

448
00:21:19,970 --> 00:21:24,830
microsoft's implementation of pixie and

449
00:21:22,390 --> 00:21:27,890
microsoft's identity provider which is

450
00:21:24,830 --> 00:21:30,199
login dot windows.net had a faulty

451
00:21:27,890 --> 00:21:33,309
implementation of pixie so we're going

452
00:21:30,200 --> 00:21:33,309
to go through the demo here

453
00:21:40,259 --> 00:21:44,039
so here you can see that there is the

454
00:21:42,330 --> 00:21:45,689
login end point there is an authorized

455
00:21:44,039 --> 00:21:48,239
end point and there's a token end point

456
00:21:45,690 --> 00:21:54,359
I'm hitting so once and they are all

457
00:21:48,239 --> 00:21:56,369
hosted on login windows.net so in the

458
00:21:54,359 --> 00:21:58,499
login request you can see that the code

459
00:21:56,369 --> 00:22:00,149
challenge value is present this is again

460
00:21:58,499 --> 00:22:02,700
the hashed value of the code verifier

461
00:22:00,149 --> 00:22:06,439
and then I am redirected to the login

462
00:22:02,700 --> 00:22:06,440
end point where I'm supposed to login

463
00:22:07,730 --> 00:22:14,690
once I log in the auth server will

464
00:22:11,940 --> 00:22:17,039
return an authorization code back to me

465
00:22:14,690 --> 00:22:19,049
and when I say me returns it to the

466
00:22:17,039 --> 00:22:23,039
native application this is the auth code

467
00:22:19,049 --> 00:22:25,710
and then the client can exchange this

468
00:22:23,039 --> 00:22:28,080
auth code for an access token at the

469
00:22:25,710 --> 00:22:31,739
token endpoint but it requires the code

470
00:22:28,080 --> 00:22:33,449
verifier to be sent so I've just sent

471
00:22:31,739 --> 00:22:34,919
the request to the repeater and you can

472
00:22:33,450 --> 00:22:37,100
see that the code verifier is present

473
00:22:34,919 --> 00:22:41,070
and the authorization code is present

474
00:22:37,100 --> 00:22:42,988
and in response I can see the access

475
00:22:41,070 --> 00:22:44,869
token identity tokens and the Refresh

476
00:22:42,989 --> 00:22:47,639
tokens coming back to me

477
00:22:44,869 --> 00:22:49,289
the problem with Microsoft's IDP was

478
00:22:47,639 --> 00:22:51,629
that it wasn't validating the code

479
00:22:49,289 --> 00:22:54,149
verifies value and even if you remove

480
00:22:51,629 --> 00:22:55,678
this code verifier value this request

481
00:22:54,149 --> 00:23:01,678
will go through successfully and you'll

482
00:22:55,679 --> 00:23:03,960
get still get back the tokens like so so

483
00:23:01,679 --> 00:23:07,200
very simple mistake but you know were

484
00:23:03,960 --> 00:23:09,509
the short so in case of authorization

485
00:23:07,200 --> 00:23:10,889
code leaks you could misuse the

486
00:23:09,509 --> 00:23:12,720
authorization code to you know exchange

487
00:23:10,889 --> 00:23:14,580
for access tokens as many times as you

488
00:23:12,720 --> 00:23:18,330
want because the authorization code is

489
00:23:14,580 --> 00:23:21,119
not one-time use here so you get a

490
00:23:18,330 --> 00:23:28,320
lifelong validity of access to the

491
00:23:21,119 --> 00:23:30,689
resources of the end user so if you go

492
00:23:28,320 --> 00:23:32,189
through the RFC of Roth for native

493
00:23:30,690 --> 00:23:35,220
applications you will see the statement

494
00:23:32,190 --> 00:23:37,739
that native application must implement

495
00:23:35,220 --> 00:23:40,019
pixi and the authorization service must

496
00:23:37,739 --> 00:23:42,659
support pixie for such clans so yeah

497
00:23:40,019 --> 00:23:45,090
that proves that you know Microsoft made

498
00:23:42,659 --> 00:23:51,509
a kind of a mistake they should have

499
00:23:45,090 --> 00:23:54,149
probably fixed that so this brings us to

500
00:23:51,509 --> 00:23:56,699
the CSRF attack CSRF

501
00:23:54,149 --> 00:24:00,149
happens on the clients redirect URI and

502
00:23:56,699 --> 00:24:03,689
in this attack the attacker tries to

503
00:24:00,149 --> 00:24:08,309
inject an authorization request at the

504
00:24:03,689 --> 00:24:09,899
redirect URL of the client this can

505
00:24:08,309 --> 00:24:13,589
cause the client to access resources

506
00:24:09,899 --> 00:24:15,329
under the control of the attacker let's

507
00:24:13,589 --> 00:24:17,039
see how let's say that there is a

508
00:24:15,329 --> 00:24:18,299
malicious attacker and we have all the

509
00:24:17,039 --> 00:24:20,158
other entities involved

510
00:24:18,299 --> 00:24:23,579
he just publishes the malicious website

511
00:24:20,159 --> 00:24:27,689
and lures the end user or victim into

512
00:24:23,579 --> 00:24:30,089
going to the malicious website once this

513
00:24:27,689 --> 00:24:33,319
happens the malicious website generates

514
00:24:30,089 --> 00:24:36,299
a forged authorization response and

515
00:24:33,319 --> 00:24:39,299
instead of the end use of the auth code

516
00:24:36,299 --> 00:24:42,269
the attacker injects his own earth code

517
00:24:39,299 --> 00:24:44,009
and the client is still thinking that

518
00:24:42,269 --> 00:24:46,979
this is a genuine request made by the

519
00:24:44,009 --> 00:24:49,499
end user and this this is basically the

520
00:24:46,979 --> 00:24:54,299
end users orth code but it is in reality

521
00:24:49,499 --> 00:24:56,849
it is the attackers auth code so the

522
00:24:54,299 --> 00:24:59,429
client tries to exchange this attackers

523
00:24:56,849 --> 00:25:02,999
auth code at the token endpoint and gets

524
00:24:59,429 --> 00:25:05,069
back an attackers access token and when

525
00:25:02,999 --> 00:25:07,319
it tries to access the resources instead

526
00:25:05,069 --> 00:25:11,359
of the end users resources the client

527
00:25:07,319 --> 00:25:11,359
will get access to attackers resources

528
00:25:11,449 --> 00:25:17,819
so this is sort of a login CSRF when you

529
00:25:15,379 --> 00:25:20,519
you know move it left and shift it to

530
00:25:17,819 --> 00:25:22,859
auth and the client still thinks it's

531
00:25:20,519 --> 00:25:24,929
accessing end users resources but in

532
00:25:22,859 --> 00:25:27,448
reality it's the attackers resource that

533
00:25:24,929 --> 00:25:32,459
it has fetched so the mitigation is a

534
00:25:27,449 --> 00:25:35,579
very simple step which is to add a CSRF

535
00:25:32,459 --> 00:25:37,579
token in the authorization request the

536
00:25:35,579 --> 00:25:40,938
client needs to make this request and

537
00:25:37,579 --> 00:25:44,158
attach this parameter in at the end and

538
00:25:40,939 --> 00:25:48,959
in the response the client expects the

539
00:25:44,159 --> 00:25:52,379
same value to be copied back and if

540
00:25:48,959 --> 00:25:55,229
that's not true then the authorization

541
00:25:52,379 --> 00:25:56,759
response is forced if that is true then

542
00:25:55,229 --> 00:25:58,559
the authorization response will go

543
00:25:56,759 --> 00:26:01,159
through and client can proceed with step

544
00:25:58,559 --> 00:26:01,158
number 4

545
00:26:03,020 --> 00:26:08,658
yeah this is a widely known

546
00:26:06,039 --> 00:26:11,240
vulnerability on the client side if the

547
00:26:08,659 --> 00:26:14,840
client is leaving open redirects there

548
00:26:11,240 --> 00:26:16,760
are a lot of problems that can arise so

549
00:26:14,840 --> 00:26:18,110
the assumptions for this attack here

550
00:26:16,760 --> 00:26:20,179
will be that the client is using

551
00:26:18,110 --> 00:26:22,189
implicit ground although we are just

552
00:26:20,179 --> 00:26:23,899
using implicit ground for simplicity in

553
00:26:22,190 --> 00:26:28,279
explaining it could be worth cold ground

554
00:26:23,899 --> 00:26:30,080
flow as well the redirect URL pattern

555
00:26:28,279 --> 00:26:32,090
that is registered by the client with

556
00:26:30,080 --> 00:26:32,658
the auth server looks something like

557
00:26:32,090 --> 00:26:36,350
this

558
00:26:32,659 --> 00:26:39,919
so it's client some site dot example /cb

559
00:26:36,350 --> 00:26:42,320
question mark star the star allows any

560
00:26:39,919 --> 00:26:44,510
number of characters to be appended to

561
00:26:42,320 --> 00:26:46,760
this URL and when the auth server

562
00:26:44,510 --> 00:26:50,169
receives this authorization request from

563
00:26:46,760 --> 00:26:52,429
the client it will match it against the

564
00:26:50,169 --> 00:26:56,690
pattern that is registered so this is

565
00:26:52,429 --> 00:26:58,250
the pattern and the client has exposed

566
00:26:56,690 --> 00:27:00,620
and open redirect on the same endpoint

567
00:26:58,250 --> 00:27:04,220
so you can add a redirect to parameter

568
00:27:00,620 --> 00:27:06,500
and basically redirect the you know user

569
00:27:04,220 --> 00:27:13,039
who's I am trying to access this URL to

570
00:27:06,500 --> 00:27:15,860
any other website so let's see how this

571
00:27:13,039 --> 00:27:18,919
happens the attacker publishes the

572
00:27:15,860 --> 00:27:23,178
malicious website which is evil dot

573
00:27:18,919 --> 00:27:27,080
example the victim clicks on that link

574
00:27:23,179 --> 00:27:29,120
and the evil website creates an

575
00:27:27,080 --> 00:27:32,449
authorization request with the redirect

576
00:27:29,120 --> 00:27:35,029
URI as the one underlined so if you

577
00:27:32,450 --> 00:27:39,679
decode this redirect URI you will get

578
00:27:35,029 --> 00:27:41,330
this so if you remember the pattern it

579
00:27:39,679 --> 00:27:43,220
is matching the pattern because there

580
00:27:41,330 --> 00:27:45,678
was a star at the end so the attacker

581
00:27:43,220 --> 00:27:48,200
has successfully injected this redirect

582
00:27:45,679 --> 00:27:52,490
to and probably misused this redirect to

583
00:27:48,200 --> 00:27:56,630
parameter here to inject his client evil

584
00:27:52,490 --> 00:27:59,659
example web site and the pattern matches

585
00:27:56,630 --> 00:28:02,899
so the odd server will approve of this

586
00:27:59,659 --> 00:28:04,909
and redirect the user back to the client

587
00:28:02,899 --> 00:28:08,809
with an access token since this is an

588
00:28:04,909 --> 00:28:11,870
implicit grant the access token is

589
00:28:08,809 --> 00:28:13,940
attached as a fragment and redirected to

590
00:28:11,870 --> 00:28:15,779
the client he will occur to redirect it

591
00:28:13,940 --> 00:28:18,239
to the client some site example

592
00:28:15,779 --> 00:28:23,729
and when the request arrives at land

593
00:28:18,239 --> 00:28:26,789
some cite example the clamp is setup to

594
00:28:23,729 --> 00:28:31,009
redirect using the redirect to parameter

595
00:28:26,789 --> 00:28:34,489
so it watches this particular underlined

596
00:28:31,009 --> 00:28:42,690
URL which is client evil example and

597
00:28:34,489 --> 00:28:45,840
redirects the end-user back to the evil

598
00:28:42,690 --> 00:28:48,629
example web site and since the access

599
00:28:45,840 --> 00:28:51,029
token fragment was missing here the

600
00:28:48,629 --> 00:28:54,359
browser will attach this access token to

601
00:28:51,029 --> 00:28:56,339
this request as well and eventually the

602
00:28:54,359 --> 00:29:04,649
attacker will get access to the access

603
00:28:56,339 --> 00:29:05,969
token so client Thanos exposed open

604
00:29:04,649 --> 00:29:07,559
redirects and it just cost him

605
00:29:05,969 --> 00:29:09,749
everything so please don't do that

606
00:29:07,559 --> 00:29:11,279
because even if you're using OAuth code

607
00:29:09,749 --> 00:29:13,589
grant you will end up losing your

608
00:29:11,279 --> 00:29:24,119
authorization code which is again not so

609
00:29:13,589 --> 00:29:30,960
cool so that brings us to fishing using

610
00:29:24,119 --> 00:29:33,509
users trust in auth server so let's just

611
00:29:30,960 --> 00:29:35,759
assume here that the attacker here has

612
00:29:33,509 --> 00:29:40,529
registered this redirect URI call

613
00:29:35,759 --> 00:29:43,080
datacom with the auth server and the

614
00:29:40,529 --> 00:29:46,200
attacker can now create this particular

615
00:29:43,080 --> 00:29:48,899
forge request with the auth servers

616
00:29:46,200 --> 00:29:52,830
endpoint and the redirect URI is set up

617
00:29:48,899 --> 00:29:55,649
to attacker calm so when the end user

618
00:29:52,830 --> 00:29:58,379
sees this sort of URL he will trust the

619
00:29:55,649 --> 00:30:01,139
auth server because he knows Google is a

620
00:29:58,379 --> 00:30:03,779
nice party so I'm gonna click on it

621
00:30:01,139 --> 00:30:06,449
anyway but the redirect URI is set up to

622
00:30:03,779 --> 00:30:08,099
redirect to attacker comm and the auth

623
00:30:06,450 --> 00:30:11,070
server has decided to trust this

624
00:30:08,099 --> 00:30:13,439
attackers redirect URI so basically the

625
00:30:11,070 --> 00:30:19,529
end user ends up on this redirect URI

626
00:30:13,440 --> 00:30:21,599
after clicking it and from there the

627
00:30:19,529 --> 00:30:24,839
attacker can basically do a phishing

628
00:30:21,599 --> 00:30:27,168
attack and get whatever it can from the

629
00:30:24,839 --> 00:30:27,168
end user

630
00:30:27,660 --> 00:30:33,600
so as a mitigation the auth server must

631
00:30:31,050 --> 00:30:35,879
necessarily inform the end-user that

632
00:30:33,600 --> 00:30:45,929
he's redirecting to another website

633
00:30:35,880 --> 00:30:48,150
that's the best it can do yeah this is

634
00:30:45,930 --> 00:30:51,150
an interesting one because this involves

635
00:30:48,150 --> 00:30:55,890
a particular client to be registered

636
00:30:51,150 --> 00:30:58,290
with multiple lot servers so if the

637
00:30:55,890 --> 00:31:02,010
client has registered itself with Google

638
00:30:58,290 --> 00:31:03,510
and Facebook then and let's just assume

639
00:31:02,010 --> 00:31:07,170
that one of the auth server turns

640
00:31:03,510 --> 00:31:09,510
malicious let's see what it can do so

641
00:31:07,170 --> 00:31:11,730
the intent of the attacker or the

642
00:31:09,510 --> 00:31:14,430
malicious odds over here would be to

643
00:31:11,730 --> 00:31:16,620
trick the client to obtain the auth code

644
00:31:14,430 --> 00:31:21,240
or access token from a different odd

645
00:31:16,620 --> 00:31:23,820
server and the only requirement here is

646
00:31:21,240 --> 00:31:25,980
that the client is using the same

647
00:31:23,820 --> 00:31:35,159
redirect URL for Google as well as

648
00:31:25,980 --> 00:31:36,630
Facebook or any other odd server so

649
00:31:35,160 --> 00:31:38,760
again I have listed all the entities

650
00:31:36,630 --> 00:31:41,790
that are involved this is the end user

651
00:31:38,760 --> 00:31:43,980
and this is linked in our client and

652
00:31:41,790 --> 00:31:45,990
Google's odd server as well as Facebook

653
00:31:43,980 --> 00:31:48,570
sort server Facebook sort server we

654
00:31:45,990 --> 00:31:50,280
assuming is malicious and then there are

655
00:31:48,570 --> 00:31:55,320
resources specific to both the odd

656
00:31:50,280 --> 00:31:58,889
servers so the end end user goes ahead

657
00:31:55,320 --> 00:32:02,040
and clicks on Facebook the authorization

658
00:31:58,890 --> 00:32:05,280
request is generated to Facebook's odd

659
00:32:02,040 --> 00:32:08,639
server and once the authorization

660
00:32:05,280 --> 00:32:10,320
request reaches Facebook Facebook can

661
00:32:08,640 --> 00:32:13,620
redirect the end user to Google's

662
00:32:10,320 --> 00:32:16,409
authorization server page and the end

663
00:32:13,620 --> 00:32:18,300
user ends up watching Google's

664
00:32:16,410 --> 00:32:20,910
authorization server page instead of

665
00:32:18,300 --> 00:32:23,430
Facebook sought server page and if this

666
00:32:20,910 --> 00:32:25,920
step is missed by the end user and he

667
00:32:23,430 --> 00:32:29,520
doesn't notice this change and grants

668
00:32:25,920 --> 00:32:31,530
the axis then the authorization code

669
00:32:29,520 --> 00:32:34,139
will be sent back to LinkedIn and

670
00:32:31,530 --> 00:32:38,090
LinkedIn will try to redeem redeem this

671
00:32:34,140 --> 00:32:40,590
auth code at Facebook's end point and

672
00:32:38,090 --> 00:32:41,158
when Facebook receives this auth code

673
00:32:40,590 --> 00:32:43,139
its

674
00:32:41,159 --> 00:32:47,159
going to redeem the code at Google's

675
00:32:43,139 --> 00:32:49,580
also odd servers in point and get back

676
00:32:47,159 --> 00:32:53,159
the access token

677
00:32:49,580 --> 00:32:55,259
now the token is basically for Google's

678
00:32:53,159 --> 00:32:57,539
resources so Facebook goes ahead and

679
00:32:55,259 --> 00:33:01,919
access Google's resources on behalf of

680
00:32:57,539 --> 00:33:03,658
the end-user so that's why it's called

681
00:33:01,919 --> 00:33:05,609
the mix-up attack because we are mixing

682
00:33:03,659 --> 00:33:07,440
up two different odd servers and getting

683
00:33:05,609 --> 00:33:13,379
access to resources of different auth

684
00:33:07,440 --> 00:33:15,720
service so as a mitigation the clients

685
00:33:13,379 --> 00:33:18,719
must register different redirect you

686
00:33:15,720 --> 00:33:20,340
arise for every odd server so something

687
00:33:18,720 --> 00:33:23,309
like Google Reader cura and Facebook

688
00:33:20,340 --> 00:33:25,289
redirect URI would suffice how this

689
00:33:23,309 --> 00:33:27,809
helps is that when the client initiates

690
00:33:25,289 --> 00:33:30,899
the authorization request it knows that

691
00:33:27,809 --> 00:33:33,418
it is requested Facebook but when the

692
00:33:30,899 --> 00:33:34,918
auth code is redirected back it is

693
00:33:33,419 --> 00:33:37,379
getting rewriter back to Google's

694
00:33:34,919 --> 00:33:39,539
redirect URL now so there is a

695
00:33:37,379 --> 00:33:41,908
discrepancy here and the client should

696
00:33:39,539 --> 00:33:48,499
be able to figure this out and stop the

697
00:33:41,909 --> 00:33:51,029
processing of next step so in summary

698
00:33:48,499 --> 00:33:52,649
we've studied that Roth is used for

699
00:33:51,029 --> 00:33:56,729
delegating resource access to a third

700
00:33:52,649 --> 00:33:58,969
party we also know that access tokens

701
00:33:56,729 --> 00:34:01,019
and identity tokens are used to prove

702
00:33:58,970 --> 00:34:02,519
authentication or authorization and

703
00:34:01,019 --> 00:34:06,090
authentication respectively

704
00:34:02,519 --> 00:34:08,429
and it is recommended to use earth code

705
00:34:06,090 --> 00:34:11,730
grant for web applications you need not

706
00:34:08,429 --> 00:34:18,059
have pixie but with mobile clients you

707
00:34:11,730 --> 00:34:24,659
should always use pixie and then we

708
00:34:18,059 --> 00:34:26,609
covered some of the attacks so there are

709
00:34:24,659 --> 00:34:28,679
a few bunch a bunch of references that

710
00:34:26,609 --> 00:34:31,558
are important if you want to get a head

711
00:34:28,679 --> 00:34:32,730
start with the war 2.0 and you want to

712
00:34:31,559 --> 00:34:36,809
go through the security considerations

713
00:34:32,730 --> 00:34:39,029
and best practices especially or the

714
00:34:36,809 --> 00:34:41,460
RFC's are pretty informative so I would

715
00:34:39,029 --> 00:34:43,409
recommend anybody who wants to go ahead

716
00:34:41,460 --> 00:34:46,319
with auth and practicing security on it

717
00:34:43,409 --> 00:34:50,250
to read through these references it will

718
00:34:46,319 --> 00:34:51,650
come in very handy and just click test

719
00:34:50,250 --> 00:34:55,800
fingers

720
00:34:51,650 --> 00:34:57,600
all right so that's some of my contact

721
00:34:55,800 --> 00:35:00,630
information if you would like to get

722
00:34:57,600 --> 00:35:03,569
back to me or available through my email

723
00:35:00,630 --> 00:35:05,210
address or Lindon I'll be happy to take

724
00:35:03,570 --> 00:35:08,210
some questions

725
00:35:05,210 --> 00:35:08,210
gotcha

726
00:35:17,630 --> 00:35:24,869
okay so we have time for a few questions

727
00:35:21,029 --> 00:35:28,190
if someone want to ask question about

728
00:35:24,869 --> 00:35:32,729
this Eastern interesting talk please

729
00:35:28,190 --> 00:35:37,979
stand up or no question

730
00:35:32,729 --> 00:35:44,939
oh really guys I okay Maori take his

731
00:35:37,979 --> 00:35:47,848
Maori often did you see problems

732
00:35:44,940 --> 00:35:50,930
regarding the referral leakage er where

733
00:35:47,849 --> 00:35:53,910
the actual token is passed the client

734
00:35:50,930 --> 00:35:56,190
connected to tracking system so for

735
00:35:53,910 --> 00:35:59,058
example analytics Google Analytics or

736
00:35:56,190 --> 00:36:03,539
things like that I mean it happens that

737
00:35:59,059 --> 00:36:07,339
analytics platform is able to retrieve

738
00:36:03,539 --> 00:36:12,209
those tokens and use it that's right

739
00:36:07,339 --> 00:36:14,099
thank you hello okay yeah it's quite

740
00:36:12,209 --> 00:36:15,959
often because I have seen it in practice

741
00:36:14,099 --> 00:36:17,309
myself for a few times the definite

742
00:36:15,959 --> 00:36:19,979
header leakage is a very common problem

743
00:36:17,309 --> 00:36:23,130
and as you said analytics is one case

744
00:36:19,979 --> 00:36:26,368
but even if let's say that you're trying

745
00:36:23,130 --> 00:36:28,319
to access some resources or

746
00:36:26,369 --> 00:36:30,599
advertisements are shown on your website

747
00:36:28,319 --> 00:36:32,459
the advertisement websites are a be even

748
00:36:30,599 --> 00:36:35,430
major concern compared to Google because

749
00:36:32,459 --> 00:36:37,669
Google you can still trust but you can't

750
00:36:35,430 --> 00:36:40,140
trust advertisement agencies with your

751
00:36:37,670 --> 00:36:42,449
specific credentials access tokens and

752
00:36:40,140 --> 00:36:47,479
odd code so it's a very common problem

753
00:36:42,449 --> 00:36:54,029
and you know it's worth looking at them

754
00:36:47,479 --> 00:36:56,368
sorry sorry I'm sorry do you think just

755
00:36:54,029 --> 00:36:59,430
a tapping proper a fair policies enough

756
00:36:56,369 --> 00:37:03,410
to prevent all of them or of those

757
00:36:59,430 --> 00:37:06,839
leakages I mean as a general fix without

758
00:37:03,410 --> 00:37:10,949
editing the client code just set up

759
00:37:06,839 --> 00:37:13,819
being the referral policy yeah that's

760
00:37:10,949 --> 00:37:16,529
that's one good users but also while

761
00:37:13,819 --> 00:37:18,509
doing code reviews as a pen tester you

762
00:37:16,529 --> 00:37:21,049
must be aware of any other third party

763
00:37:18,509 --> 00:37:24,330
integration with your client website so

764
00:37:21,049 --> 00:37:26,400
any other website that is there

765
00:37:24,330 --> 00:37:29,190
be you know totally look true we need

766
00:37:26,400 --> 00:37:33,960
after her a check should be properly in

767
00:37:29,190 --> 00:37:38,340
place so yeah but that's their thank you

768
00:37:33,960 --> 00:37:41,630
if you have a more question please again

769
00:37:38,340 --> 00:37:44,970
let's see no question

770
00:37:41,630 --> 00:37:47,480
okay thank you summit for your talk

771
00:37:44,970 --> 00:37:47,480
thank you

772
00:37:56,880 --> 00:37:58,940
you

