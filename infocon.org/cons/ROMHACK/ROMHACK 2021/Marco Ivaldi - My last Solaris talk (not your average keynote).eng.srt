1
00:00:05,200 --> 00:00:06,399
good morning

2
00:00:06,399 --> 00:00:09,120
welcome to romaheck

3
00:00:09,120 --> 00:00:10,960
when giovanni asked me

4
00:00:10,960 --> 00:00:13,519
like in january

5
00:00:13,519 --> 00:00:15,360
to open this year's edition of the

6
00:00:15,360 --> 00:00:17,600
conference with a keynote speech i

7
00:00:17,600 --> 00:00:20,880
didn't have the slightest idea of what i

8
00:00:20,880 --> 00:00:22,480
could talk about

9
00:00:22,480 --> 00:00:23,519
you see

10
00:00:23,519 --> 00:00:26,560
never been a fan of keynotes myself i

11
00:00:26,560 --> 00:00:28,160
always preferred

12
00:00:28,160 --> 00:00:30,560
technical talks that usually give you a

13
00:00:30,560 --> 00:00:33,680
bit more a bit more substance in my

14
00:00:33,680 --> 00:00:34,800
opinion

15
00:00:34,800 --> 00:00:36,960
so i was in dubbed for a while and then

16
00:00:36,960 --> 00:00:38,160
it hit me

17
00:00:38,160 --> 00:00:42,079
what if i tried something different

18
00:00:42,079 --> 00:00:44,559
and so today i would like to do an

19
00:00:44,559 --> 00:00:47,360
experiment with you instead of the usual

20
00:00:47,360 --> 00:00:50,800
perhaps even boring keynote i'd like to

21
00:00:50,800 --> 00:00:52,079
talk about

22
00:00:52,079 --> 00:00:54,640
memory corruption bugs

23
00:00:54,640 --> 00:00:57,920
i'd like to show younger generations

24
00:00:57,920 --> 00:00:59,680
that's supposed to be you

25
00:00:59,680 --> 00:01:00,800
that

26
00:01:00,800 --> 00:01:02,399
at least some of you

27
00:01:02,399 --> 00:01:03,359
that

28
00:01:03,359 --> 00:01:06,010
beside those related to

29
00:01:06,010 --> 00:01:07,760
[Music]

30
00:01:07,760 --> 00:01:09,360
web technologies that you might be

31
00:01:09,360 --> 00:01:11,360
familiar with other kinds of weird

32
00:01:11,360 --> 00:01:14,640
machines can be extremely fun to play

33
00:01:14,640 --> 00:01:15,600
with

34
00:01:15,600 --> 00:01:19,439
so let's begin with a quick survey

35
00:01:19,439 --> 00:01:22,799
who among you has ever exploited a

36
00:01:22,799 --> 00:01:24,640
memory corruption bug

37
00:01:24,640 --> 00:01:27,360
please let's have a show of hands

38
00:01:27,360 --> 00:01:30,640
okay okay i see a few hands good

39
00:01:30,640 --> 00:01:32,960
and who has

40
00:01:32,960 --> 00:01:36,400
ever uh exploited a former string bug

41
00:01:36,400 --> 00:01:39,119
specifically these are a bit old

42
00:01:39,119 --> 00:01:41,920
okay okay we have some people good

43
00:01:41,920 --> 00:01:44,320
last question who has ever exploited

44
00:01:44,320 --> 00:01:48,000
anything on solaris

45
00:01:48,000 --> 00:01:50,560
come on i know ah i see one hand hello

46
00:01:50,560 --> 00:01:52,399
oh old timers

47
00:01:52,399 --> 00:01:55,439
hello okay so regardless of your level

48
00:01:55,439 --> 00:01:58,320
of familiarity with these topics

49
00:01:58,320 --> 00:02:00,880
i hope you will enjoy my last solaris

50
00:02:00,880 --> 00:02:02,240
talk

51
00:02:02,240 --> 00:02:06,159
so today i'm going to dissect a

52
00:02:06,159 --> 00:02:08,318
particularly challenging exploit at

53
00:02:08,318 --> 00:02:09,440
least for me

54
00:02:09,440 --> 00:02:11,038
that i

55
00:02:11,038 --> 00:02:13,520
put together and published a few months

56
00:02:13,520 --> 00:02:14,319
ago

57
00:02:14,319 --> 00:02:16,400
it's a form of string exploit that

58
00:02:16,400 --> 00:02:20,319
targets solaris spark systems so it

59
00:02:20,319 --> 00:02:22,160
doesn't get much more old-school than

60
00:02:22,160 --> 00:02:23,680
these

61
00:02:23,680 --> 00:02:25,280
of course this is not going to be a

62
00:02:25,280 --> 00:02:26,879
crash course on solaris spark

63
00:02:26,879 --> 00:02:29,040
exploitation because we don't have the

64
00:02:29,040 --> 00:02:30,400
time

65
00:02:30,400 --> 00:02:32,160
however if you are interested in this

66
00:02:32,160 --> 00:02:34,879
topic i encourage you to take a look at

67
00:02:34,879 --> 00:02:36,640
my article

68
00:02:36,640 --> 00:02:39,840
that it's about to be published in a

69
00:02:39,840 --> 00:02:42,480
major hacker magazine

70
00:02:42,480 --> 00:02:45,040
unfortunately at the moment i can't say

71
00:02:45,040 --> 00:02:47,599
anything else but if you stay tuned you

72
00:02:47,599 --> 00:02:49,360
will see

73
00:02:49,360 --> 00:02:51,440
that the article will be published and

74
00:02:51,440 --> 00:02:52,879
more importantly

75
00:02:52,879 --> 00:02:54,879
this major

76
00:02:54,879 --> 00:02:57,280
magazine that i'm not going to name

77
00:02:57,280 --> 00:03:00,400
will have a new issue very soon and

78
00:03:00,400 --> 00:03:02,480
that's a good a great event in my

79
00:03:02,480 --> 00:03:03,599
opinion

80
00:03:03,599 --> 00:03:05,840
okay

81
00:03:06,480 --> 00:03:09,120
time to talk about solaris

82
00:03:09,120 --> 00:03:11,519
solaris is a commercial unix operating

83
00:03:11,519 --> 00:03:13,680
system that was developed by some

84
00:03:13,680 --> 00:03:16,800
ecosystems in the 90s and was later

85
00:03:16,800 --> 00:03:20,000
acquired by oracle in 2010.

86
00:03:20,000 --> 00:03:21,920
it's one

87
00:03:21,920 --> 00:03:24,400
of the most successful in my opinion

88
00:03:24,400 --> 00:03:28,159
unix or operating systems and you really

89
00:03:28,159 --> 00:03:30,879
could find uh in the early 2000s you

90
00:03:30,879 --> 00:03:32,640
could find it anywhere in all kinds of

91
00:03:32,640 --> 00:03:35,359
enterprises

92
00:03:35,519 --> 00:03:39,840
a little bit like windows is today

93
00:03:39,840 --> 00:03:42,400
nowadays unfortunately in my opinion

94
00:03:42,400 --> 00:03:44,400
it's considered legacy technology but

95
00:03:44,400 --> 00:03:46,159
it's still maintained and it will be for

96
00:03:46,159 --> 00:03:49,440
a very long time until at least 20 35 i

97
00:03:49,440 --> 00:03:51,760
guess

98
00:03:52,159 --> 00:03:55,120
but you can still find it in many

99
00:03:55,120 --> 00:03:57,360
some critical environments especially

100
00:03:57,360 --> 00:03:59,040
turquoise

101
00:03:59,040 --> 00:04:02,239
i've been hacking solaris for quite some

102
00:04:02,239 --> 00:04:03,439
time

103
00:04:03,439 --> 00:04:05,519
here you can see my first and last

104
00:04:05,519 --> 00:04:07,439
release for this platform according to

105
00:04:07,439 --> 00:04:09,920
pakistan and as you can see

106
00:04:09,920 --> 00:04:13,840
they have a time span of about 20 years

107
00:04:13,840 --> 00:04:16,720
i started hacking solaris in the early

108
00:04:16,720 --> 00:04:19,839
2000s because as a pentester back then

109
00:04:19,839 --> 00:04:22,400
as i said i was encountering it very

110
00:04:22,400 --> 00:04:25,600
often almost on a daily basis and so i

111
00:04:25,600 --> 00:04:28,400
wanted to be able to

112
00:04:28,400 --> 00:04:30,320
hack into it

113
00:04:30,320 --> 00:04:34,000
to do a better job as a pen tester

114
00:04:34,000 --> 00:04:37,600
to put things into perspective

115
00:04:37,600 --> 00:04:39,680
the early 2000s

116
00:04:39,680 --> 00:04:43,919
were still the years of

117
00:04:43,919 --> 00:04:46,560
war dialing we were still doing it

118
00:04:46,560 --> 00:04:48,400
as a matter of fact we should still be

119
00:04:48,400 --> 00:04:50,960
doing it also today in my opinion

120
00:04:50,960 --> 00:04:52,960
but anyway back then it was still

121
00:04:52,960 --> 00:04:55,280
sort of popular so we were still using

122
00:04:55,280 --> 00:04:58,320
dunlock we used minicom and we even had

123
00:04:58,320 --> 00:05:01,280
still had x25 networks even though they

124
00:05:01,280 --> 00:05:04,080
died shortly after a few years later

125
00:05:04,080 --> 00:05:06,960
what we didn't have where the

126
00:05:06,960 --> 00:05:08,880
amount of captured the flags that you

127
00:05:08,880 --> 00:05:11,199
have today and of course we also we

128
00:05:11,199 --> 00:05:13,520
didn't have a bug bounties

129
00:05:13,520 --> 00:05:16,160
so hackers from my generation had to

130
00:05:16,160 --> 00:05:17,919
invent something else to pass the time

131
00:05:17,919 --> 00:05:19,600
and this is how together with some

132
00:05:19,600 --> 00:05:23,520
friends and co-workers we decided to

133
00:05:23,520 --> 00:05:25,680
buy some old hardware on which we could

134
00:05:25,680 --> 00:05:29,280
install solaris to play with it

135
00:05:29,280 --> 00:05:30,960
solaris

136
00:05:30,960 --> 00:05:34,560
can run on intel but you usually find it

137
00:05:34,560 --> 00:05:36,880
on the spark architecture

138
00:05:36,880 --> 00:05:38,400
spark is

139
00:05:38,400 --> 00:05:41,120
an early risk architecture

140
00:05:41,120 --> 00:05:43,840
arguably the most successful early risk

141
00:05:43,840 --> 00:05:47,039
architecture that paved the way to more

142
00:05:47,039 --> 00:05:49,840
modern risk processes that you might be

143
00:05:49,840 --> 00:05:52,400
familiar with such as mips and of course

144
00:05:52,400 --> 00:05:54,320
the ubiquitous arm

145
00:05:54,320 --> 00:05:57,680
that's in everybody's pockets today

146
00:05:57,680 --> 00:05:59,919
okay so um

147
00:05:59,919 --> 00:06:02,960
we talked about solaris we talked about

148
00:06:02,960 --> 00:06:06,240
spark we just missed one thing

149
00:06:06,240 --> 00:06:09,039
what the heck are former string bugs

150
00:06:09,039 --> 00:06:10,160
well

151
00:06:10,160 --> 00:06:12,800
story time it was the summer of the year

152
00:06:12,800 --> 00:06:16,960
2000 after a couple ftpd exploits hit

153
00:06:16,960 --> 00:06:19,120
the backtrack mailing list

154
00:06:19,120 --> 00:06:22,400
two authors la magra and tim newsham

155
00:06:22,400 --> 00:06:24,639
published the first white papers on this

156
00:06:24,639 --> 00:06:27,840
new attack class on this new black class

157
00:06:27,840 --> 00:06:29,840
the former swing bugs

158
00:06:29,840 --> 00:06:30,720
and

159
00:06:30,720 --> 00:06:32,400
then the fun began

160
00:06:32,400 --> 00:06:34,800
everything was vulnerable uh beside the

161
00:06:34,800 --> 00:06:38,080
network services also uh local uh city

162
00:06:38,080 --> 00:06:40,479
binaries were vulnerable uh even

163
00:06:40,479 --> 00:06:41,600
libraries

164
00:06:41,600 --> 00:06:43,919
and everybody was writing exploits for

165
00:06:43,919 --> 00:06:46,160
these new fund bugs

166
00:06:46,160 --> 00:06:47,520
but

167
00:06:47,520 --> 00:06:49,199
what are they

168
00:06:49,199 --> 00:06:51,520
from where do they come from

169
00:06:51,520 --> 00:06:53,039
uh like

170
00:06:53,039 --> 00:06:54,000
many

171
00:06:54,000 --> 00:06:55,199
other

172
00:06:55,199 --> 00:06:57,199
bug classes

173
00:06:57,199 --> 00:06:58,800
former stringbugs

174
00:06:58,800 --> 00:07:01,440
stem from the laziness of programmers

175
00:07:01,440 --> 00:07:04,400
who instead of writing this

176
00:07:04,400 --> 00:07:07,919
they prefer to write this

177
00:07:07,919 --> 00:07:10,479
saving time effort and six bytes of

178
00:07:10,479 --> 00:07:12,639
source code

179
00:07:12,639 --> 00:07:14,479
but what's the implication

180
00:07:14,479 --> 00:07:17,759
well if an attacker can control the

181
00:07:17,759 --> 00:07:20,000
string that gets passed to a printf

182
00:07:20,000 --> 00:07:22,319
family function this way

183
00:07:22,319 --> 00:07:25,520
he or she is able to provide some

184
00:07:25,520 --> 00:07:28,639
special characters some sort of metadata

185
00:07:28,639 --> 00:07:32,000
in the form of percent d percent x uh so

186
00:07:32,000 --> 00:07:34,720
the formatting directives and influence

187
00:07:34,720 --> 00:07:37,520
the behavior of this kind of function

188
00:07:37,520 --> 00:07:39,440
if you think about it it's just another

189
00:07:39,440 --> 00:07:42,479
example of mixing data and metadata in

190
00:07:42,479 --> 00:07:44,800
the same channel so it's a little bit of

191
00:07:44,800 --> 00:07:47,039
what happens when you exploit a sql

192
00:07:47,039 --> 00:07:49,919
injection or other kinds of injection

193
00:07:49,919 --> 00:07:52,879
or uh even what makes possible to

194
00:07:52,879 --> 00:07:54,000
exploit

195
00:07:54,000 --> 00:07:56,879
buffer overflow either stack based or

196
00:07:56,879 --> 00:07:59,520
hip hip-based

197
00:08:00,080 --> 00:08:02,479
but in this specific case

198
00:08:02,479 --> 00:08:04,960
if you control the form of string

199
00:08:04,960 --> 00:08:07,520
you can at least

200
00:08:07,520 --> 00:08:09,840
have an information leak

201
00:08:09,840 --> 00:08:12,400
because you can read the content of the

202
00:08:12,400 --> 00:08:13,440
memory

203
00:08:13,440 --> 00:08:15,280
this is usually done

204
00:08:15,280 --> 00:08:18,879
via the percent x percent d or similar

205
00:08:18,879 --> 00:08:21,199
formatting directive that take

206
00:08:21,199 --> 00:08:23,360
parameters straight from the stack so

207
00:08:23,360 --> 00:08:24,800
you can read the stack memory and that's

208
00:08:24,800 --> 00:08:26,639
really useful for instance to bypass

209
00:08:26,639 --> 00:08:30,400
aslr or other similar counter measures

210
00:08:30,400 --> 00:08:32,958
what may not be so obvious is that this

211
00:08:32,958 --> 00:08:34,958
little mistake

212
00:08:34,958 --> 00:08:38,080
enables an attacker to

213
00:08:38,080 --> 00:08:40,880
execute arbitrary code usually not

214
00:08:40,880 --> 00:08:43,120
always but that's usually the case this

215
00:08:43,120 --> 00:08:46,160
is done by the percent n formatting

216
00:08:46,160 --> 00:08:47,279
directive

217
00:08:47,279 --> 00:08:48,560
that's uh

218
00:08:48,560 --> 00:08:50,560
with some tricks enables you basically

219
00:08:50,560 --> 00:08:52,320
to write whatever you want wherever you

220
00:08:52,320 --> 00:08:54,800
want in memory and this usually leads to

221
00:08:54,800 --> 00:08:58,719
called execution as we will see

222
00:09:01,760 --> 00:09:03,839
as you can imagine formal string bugs

223
00:09:03,839 --> 00:09:06,240
are extremely powerful because they give

224
00:09:06,240 --> 00:09:08,000
you an information leakage primitive

225
00:09:08,000 --> 00:09:09,839
they give you a right what where

226
00:09:09,839 --> 00:09:12,000
primitive and they're very fun to play

227
00:09:12,000 --> 00:09:14,640
with but unfortunately for us exploit

228
00:09:14,640 --> 00:09:17,920
writers the fun didn't last much

229
00:09:17,920 --> 00:09:19,279
because

230
00:09:19,279 --> 00:09:22,720
they as it turns out are quite easy to

231
00:09:22,720 --> 00:09:25,600
spot by means of static analysis

232
00:09:25,600 --> 00:09:27,519
techniques so they were quickly

233
00:09:27,519 --> 00:09:29,440
eradicated

234
00:09:29,440 --> 00:09:31,120
or were they

235
00:09:31,120 --> 00:09:34,080
please allow me to introduce our bug of

236
00:09:34,080 --> 00:09:37,240
the day

237
00:09:41,600 --> 00:09:43,920
sorry

238
00:09:44,320 --> 00:09:45,839
in 2018

239
00:09:45,839 --> 00:09:47,680
at infiltrate in miami

240
00:09:47,680 --> 00:09:51,440
i told the story of a zero-day bug that

241
00:09:51,440 --> 00:09:53,360
was 18 years old

242
00:09:53,360 --> 00:09:54,800
in

243
00:09:54,800 --> 00:09:58,000
the common desktop environment or cd

244
00:09:58,000 --> 00:09:59,839
that is a software that's distributed

245
00:09:59,839 --> 00:10:02,320
with solaris among other commercial

246
00:10:02,320 --> 00:10:05,279
operating systems

247
00:10:05,279 --> 00:10:07,360
cde is a software that would be

248
00:10:07,360 --> 00:10:10,399
remembered fondly by all hackers who

249
00:10:10,399 --> 00:10:12,320
were active in the

250
00:10:12,320 --> 00:10:15,360
19th or early 2000s not just because of

251
00:10:15,360 --> 00:10:17,680
its looks

252
00:10:17,680 --> 00:10:19,040
that's a little bit

253
00:10:19,040 --> 00:10:21,920
too much of school even for me that cd

254
00:10:21,920 --> 00:10:24,320
if you haven't never seen it before

255
00:10:24,320 --> 00:10:26,959
um so not because of its looks but

256
00:10:26,959 --> 00:10:29,200
mostly because it was ubiquitous you

257
00:10:29,200 --> 00:10:31,680
could find it in all kinds of unix

258
00:10:31,680 --> 00:10:33,600
systems almost all kinds and even on

259
00:10:33,600 --> 00:10:36,480
non-unix systems you have it on open bms

260
00:10:36,480 --> 00:10:38,480
for instance

261
00:10:38,480 --> 00:10:40,560
and it was then vulnerable so as a pen

262
00:10:40,560 --> 00:10:41,600
tester

263
00:10:41,600 --> 00:10:44,399
if you found a system with cde you could

264
00:10:44,399 --> 00:10:47,040
almost certainly be able to

265
00:10:47,040 --> 00:10:49,760
hack into it remotely or

266
00:10:49,760 --> 00:10:52,079
leverage some vulnerability to

267
00:10:52,079 --> 00:10:55,440
increase your privileges locally

268
00:10:55,440 --> 00:10:58,160
so my talk

269
00:10:58,720 --> 00:11:01,680
reminiscing of these golden days of

270
00:11:01,680 --> 00:11:04,560
unmitigated exploitation of cde

271
00:11:04,560 --> 00:11:07,680
inspired marty a young researcher from

272
00:11:07,680 --> 00:11:10,480
spain who watched the talk and decided

273
00:11:10,480 --> 00:11:12,000
to

274
00:11:12,000 --> 00:11:14,320
follow my advice and so he decided to

275
00:11:14,320 --> 00:11:16,560
take a look at cde himself

276
00:11:16,560 --> 00:11:19,760
and see if he could find some new bugs

277
00:11:19,760 --> 00:11:22,240
of course cde is closest source so at

278
00:11:22,240 --> 00:11:24,399
least that the one that's distributed

279
00:11:24,399 --> 00:11:26,320
with unix there's also an open source

280
00:11:26,320 --> 00:11:29,120
version that you can take a look at

281
00:11:29,120 --> 00:11:32,800
so he reversed uh some binaries and he

282
00:11:32,800 --> 00:11:35,440
eventually find found one bug

283
00:11:35,440 --> 00:11:37,680
let's see if you can spot the bug

284
00:11:37,680 --> 00:11:39,360
yourself

285
00:11:39,360 --> 00:11:42,320
i'll leave you a few seconds

286
00:11:42,320 --> 00:11:44,720
so this is the the compile of the check

287
00:11:44,720 --> 00:11:46,800
div function of the dt printing for

288
00:11:46,800 --> 00:11:48,160
binary that's the binary that's

289
00:11:48,160 --> 00:11:50,639
distributed with the cde that was

290
00:11:50,639 --> 00:11:52,399
plagued by

291
00:11:52,399 --> 00:11:54,399
i don't know many many vulnerabilities

292
00:11:54,399 --> 00:11:57,920
in the past so anyone can see

293
00:11:57,920 --> 00:11:59,920
where the bug is

294
00:11:59,920 --> 00:12:01,839
of course it's in the highlighted line

295
00:12:01,839 --> 00:12:03,760
of code the one market with the one

296
00:12:03,760 --> 00:12:06,240
comment that was too easy but actually

297
00:12:06,240 --> 00:12:07,760
that was a little bit of a trick

298
00:12:07,760 --> 00:12:08,880
question

299
00:12:08,880 --> 00:12:11,040
only in this screen i see at least four

300
00:12:11,040 --> 00:12:12,959
bugs only in the highlighted line of

301
00:12:12,959 --> 00:12:15,839
code ic2 there is a stack based buffer

302
00:12:15,839 --> 00:12:18,399
overflow and a formal string bug

303
00:12:18,399 --> 00:12:22,560
this really was called from another era

304
00:12:22,560 --> 00:12:24,000
today we we're going to focus on the

305
00:12:24,000 --> 00:12:25,680
format string bug

306
00:12:25,680 --> 00:12:27,519
as you can see in the lighter line of

307
00:12:27,519 --> 00:12:31,600
code the sprintf function um parses the

308
00:12:31,600 --> 00:12:36,480
format variable that comes from the

309
00:12:36,480 --> 00:12:37,680
rec dear

310
00:12:37,680 --> 00:12:39,440
environment variable

311
00:12:39,440 --> 00:12:42,399
so this means that a local attacker who

312
00:12:42,399 --> 00:12:44,240
is in control of the rec deer

313
00:12:44,240 --> 00:12:47,360
environment variable can pass arbitrary

314
00:12:47,360 --> 00:12:49,360
from an arbitrary format string to the

315
00:12:49,360 --> 00:12:52,720
sprintf function and this means that

316
00:12:52,720 --> 00:12:54,800
it's game over right

317
00:12:54,800 --> 00:12:57,440
well not so fast

318
00:12:57,440 --> 00:13:00,079
took me almost two weeks

319
00:13:00,079 --> 00:13:02,480
to put together his exploit which i know

320
00:13:02,480 --> 00:13:04,720
is not a lot compared to modern

321
00:13:04,720 --> 00:13:06,800
exploitation efforts i'm aware of it of

322
00:13:06,800 --> 00:13:10,000
it but in my experience it's a long time

323
00:13:10,000 --> 00:13:12,320
for me it's a long time i encountered

324
00:13:12,320 --> 00:13:14,480
many roadblocks and complications during

325
00:13:14,480 --> 00:13:16,560
the development of this exploit and i

326
00:13:16,560 --> 00:13:19,200
came close to giving up a couple of

327
00:13:19,200 --> 00:13:21,839
times so let's see what happened and how

328
00:13:21,839 --> 00:13:25,040
i uh overcome the difficulties

329
00:13:25,040 --> 00:13:27,920
first problem i faced was the fact that

330
00:13:27,920 --> 00:13:30,880
as i mentioned there were two bugs

331
00:13:30,880 --> 00:13:32,880
the former string and also the buffer

332
00:13:32,880 --> 00:13:34,800
overflow and i wanted to exploit both of

333
00:13:34,800 --> 00:13:35,920
them

334
00:13:35,920 --> 00:13:37,920
i was able to do that on the intel

335
00:13:37,920 --> 00:13:40,480
architecture no problem

336
00:13:40,480 --> 00:13:43,440
but on spark i wasn't that

337
00:13:43,440 --> 00:13:44,639
lucky

338
00:13:44,639 --> 00:13:47,440
why is that well as a general rule

339
00:13:47,440 --> 00:13:50,160
exploitation on spark is much

340
00:13:50,160 --> 00:13:53,680
more painful and fun that on intel yeah

341
00:13:53,680 --> 00:13:55,199
there's a little bit of masochistic

342
00:13:55,199 --> 00:13:57,360
thing in exploiting stuff if you've done

343
00:13:57,360 --> 00:13:59,920
it you know

344
00:14:00,480 --> 00:14:02,399
in this specific case the problem is

345
00:14:02,399 --> 00:14:05,040
related to how stack manager how spark

346
00:14:05,040 --> 00:14:06,720
manages the stack

347
00:14:06,720 --> 00:14:09,040
and without entering into the gory

348
00:14:09,040 --> 00:14:10,079
details

349
00:14:10,079 --> 00:14:12,480
uh suffice to say that if you have a

350
00:14:12,480 --> 00:14:16,639
stack based buffer overflow on spark you

351
00:14:16,639 --> 00:14:18,959
cannot overwrite the save the return

352
00:14:18,959 --> 00:14:20,320
address of

353
00:14:20,320 --> 00:14:22,560
the function where the vulnerability

354
00:14:22,560 --> 00:14:24,959
lies you usually are only able to

355
00:14:24,959 --> 00:14:27,199
overwrite the saved return address of

356
00:14:27,199 --> 00:14:30,000
the caller of the vulnerable function

357
00:14:30,000 --> 00:14:32,800
this means that you have to survive two

358
00:14:32,800 --> 00:14:34,880
returns one additional return compared

359
00:14:34,880 --> 00:14:36,560
to other architectures

360
00:14:36,560 --> 00:14:38,320
depending on your target binary this

361
00:14:38,320 --> 00:14:39,279
might be

362
00:14:39,279 --> 00:14:41,519
easy

363
00:14:41,519 --> 00:14:44,160
hard or impossible in this case i'm not

364
00:14:44,160 --> 00:14:46,639
saying it's impossible because probably

365
00:14:46,639 --> 00:14:48,480
it's feasible somehow

366
00:14:48,480 --> 00:14:50,720
but it's definitely hard because when

367
00:14:50,720 --> 00:14:52,720
you perform the overwrite you overwrite

368
00:14:52,720 --> 00:14:54,800
also a lot of pointers critical pointers

369
00:14:54,800 --> 00:14:58,079
that are used by the target program and

370
00:14:58,079 --> 00:15:00,320
this is problematic because the target

371
00:15:00,320 --> 00:15:03,760
crashes so you cannot really

372
00:15:03,760 --> 00:15:06,160
elevate your privileges

373
00:15:06,160 --> 00:15:09,360
so i decided to solve this problem by

374
00:15:09,360 --> 00:15:12,000
completely ignoring it and focusing on

375
00:15:12,000 --> 00:15:15,600
the format stream bug instead why not

376
00:15:15,600 --> 00:15:17,760
let's see

377
00:15:17,760 --> 00:15:20,240
as another example of the nice

378
00:15:20,240 --> 00:15:23,040
cd interface let's see now a couple of

379
00:15:23,040 --> 00:15:26,880
prerequisites for our exploit um well

380
00:15:26,880 --> 00:15:28,880
first thing as i mentioned the tt print

381
00:15:28,880 --> 00:15:30,639
info is

382
00:15:30,639 --> 00:15:33,440
a binary it's a set with binary and by

383
00:15:33,440 --> 00:15:35,440
the way i have no idea why it's set with

384
00:15:35,440 --> 00:15:37,839
uh there must be some reason but i i

385
00:15:37,839 --> 00:15:39,199
don't know why i don't care because

386
00:15:39,199 --> 00:15:41,199
that's the only reason why we are able

387
00:15:41,199 --> 00:15:43,199
to exploit it in order to elevate our

388
00:15:43,199 --> 00:15:44,399
privileges to roots so i'm not

389
00:15:44,399 --> 00:15:46,880
complaining

390
00:15:46,880 --> 00:15:49,360
when you launch it you see this

391
00:15:49,360 --> 00:15:52,000
interface that displays information

392
00:15:52,000 --> 00:15:54,480
about printers and print jobs and this

393
00:15:54,480 --> 00:15:56,000
kind of stuff

394
00:15:56,000 --> 00:15:57,680
the prerequisite one of the requisites

395
00:15:57,680 --> 00:15:59,279
for our vulnerability to reach the

396
00:15:59,279 --> 00:16:01,920
vulnerable code path is to be able to

397
00:16:01,920 --> 00:16:03,759
double click on a configured printer

398
00:16:03,759 --> 00:16:07,120
like the one that you see here

399
00:16:07,600 --> 00:16:09,360
if you have a configured printer on your

400
00:16:09,360 --> 00:16:10,639
target system

401
00:16:10,639 --> 00:16:13,440
you're in luck you can go you can go on

402
00:16:13,440 --> 00:16:15,680
but if you don't then you have a problem

403
00:16:15,680 --> 00:16:17,600
because as a regular user as far as i

404
00:16:17,600 --> 00:16:19,759
know you cannot configure a printer

405
00:16:19,759 --> 00:16:21,199
yourself

406
00:16:21,199 --> 00:16:24,480
what you can do instead is to use an old

407
00:16:24,480 --> 00:16:25,839
trick

408
00:16:25,839 --> 00:16:29,040
an old bug that's part of the box that i

409
00:16:29,040 --> 00:16:31,839
disclosed at the infiltrate in 2019

410
00:16:31,839 --> 00:16:33,920
that basically can be used among other

411
00:16:33,920 --> 00:16:36,240
things to fake the presence of a printer

412
00:16:36,240 --> 00:16:37,839
of course you need to have a system

413
00:16:37,839 --> 00:16:40,240
that's not patched

414
00:16:40,240 --> 00:16:41,680
we don't have the time to see how this

415
00:16:41,680 --> 00:16:43,120
works but if you are interested you

416
00:16:43,120 --> 00:16:46,959
should check out my old talk

417
00:16:46,959 --> 00:16:49,360
going a bit further in my exploit code

418
00:16:49,360 --> 00:16:51,040
here we

419
00:16:51,040 --> 00:16:53,759
set up the environment and some

420
00:16:53,759 --> 00:16:56,000
variables before we execute the

421
00:16:56,000 --> 00:16:58,079
vulnerable program the most important

422
00:16:58,079 --> 00:16:59,360
thing to notice here is that we are

423
00:16:59,360 --> 00:17:02,000
using two buffers that i with a lot of

424
00:17:02,000 --> 00:17:05,280
fantasy i named buff and buff two

425
00:17:05,280 --> 00:17:07,839
in bath we are gonna put our hostile

426
00:17:07,839 --> 00:17:10,000
from a string that will exploit

427
00:17:10,000 --> 00:17:11,280
the bug

428
00:17:11,280 --> 00:17:13,520
and in buff two it doesn't really matter

429
00:17:13,520 --> 00:17:15,119
what's on the side there i put a lot of

430
00:17:15,119 --> 00:17:16,959
these

431
00:17:16,959 --> 00:17:18,640
it's just a padding

432
00:17:18,640 --> 00:17:21,599
that's useful because as a side effect

433
00:17:21,599 --> 00:17:24,400
our sprint f the vulnerability function

434
00:17:24,400 --> 00:17:27,599
when it parses our hostel from a string

435
00:17:27,599 --> 00:17:28,480
it

436
00:17:28,480 --> 00:17:30,480
needs to write a lot of stuff

437
00:17:30,480 --> 00:17:33,600
on the stack and so it might reach past

438
00:17:33,600 --> 00:17:34,960
it try to reach past the end of the

439
00:17:34,960 --> 00:17:38,320
stack that's crashing uh our target

440
00:17:38,320 --> 00:17:40,400
program and that's invalidating our

441
00:17:40,400 --> 00:17:41,679
exploit

442
00:17:41,679 --> 00:17:43,120
so i don't

443
00:17:43,120 --> 00:17:44,720
i hope you're still with me because i

444
00:17:44,720 --> 00:17:47,600
think i see some puzzled faces

445
00:17:47,600 --> 00:17:51,200
because now it's time for the hard part

446
00:17:51,200 --> 00:17:52,720
in order to be

447
00:17:52,720 --> 00:17:56,320
able to turn our memory corruption into

448
00:17:56,320 --> 00:17:58,480
a nice weird machine

449
00:17:58,480 --> 00:18:01,120
we must be able to

450
00:18:01,120 --> 00:18:04,160
have a bright what where

451
00:18:04,160 --> 00:18:06,640
primitive so we must be able to craft

452
00:18:06,640 --> 00:18:08,960
perform a string that's able to write

453
00:18:08,960 --> 00:18:12,080
wherever we want whatever we want in in

454
00:18:12,080 --> 00:18:14,799
memory this is usually done with a

455
00:18:14,799 --> 00:18:17,440
percent and formatting directive as i

456
00:18:17,440 --> 00:18:18,480
mentioned

457
00:18:18,480 --> 00:18:20,720
um this is usually

458
00:18:20,720 --> 00:18:22,480
done like on intel and other

459
00:18:22,480 --> 00:18:23,600
architecture

460
00:18:23,600 --> 00:18:24,559
just

461
00:18:24,559 --> 00:18:26,720
this is abused to write one byte at a

462
00:18:26,720 --> 00:18:28,480
time but this unfortunately it's not

463
00:18:28,480 --> 00:18:31,440
possible on spark because that's another

464
00:18:31,440 --> 00:18:33,360
typical problem with spark

465
00:18:33,360 --> 00:18:35,840
it's a risk architecture and most maybe

466
00:18:35,840 --> 00:18:38,160
all risk architectures complain if you

467
00:18:38,160 --> 00:18:40,799
don't access memory

468
00:18:40,799 --> 00:18:43,360
at specific

469
00:18:43,360 --> 00:18:47,120
offsets so you need to access memory uh

470
00:18:47,120 --> 00:18:49,520
with addresses that are all a multiple

471
00:18:49,520 --> 00:18:50,720
of four

472
00:18:50,720 --> 00:18:53,200
so you cannot address each byte

473
00:18:53,200 --> 00:18:54,840
separately

474
00:18:54,840 --> 00:18:58,480
um this there are some tricks that can

475
00:18:58,480 --> 00:19:02,080
be used to bypass this and exploit

476
00:19:02,080 --> 00:19:03,840
this kind of vulnerabilities on solaris

477
00:19:03,840 --> 00:19:05,840
but for some reasons related to the fact

478
00:19:05,840 --> 00:19:08,000
that the vulnerable function tries to

479
00:19:08,000 --> 00:19:11,360
reach past the end of the stack

480
00:19:11,360 --> 00:19:13,120
it was they weren't really applicable to

481
00:19:13,120 --> 00:19:14,400
this case

482
00:19:14,400 --> 00:19:15,600
so what

483
00:19:15,600 --> 00:19:17,600
i did

484
00:19:17,600 --> 00:19:19,840
in desperation after

485
00:19:19,840 --> 00:19:25,200
a long time of trying and debugging is

486
00:19:25,200 --> 00:19:27,039
to figure out

487
00:19:27,039 --> 00:19:28,400
a possibly

488
00:19:28,400 --> 00:19:31,360
novel technique to exploit form a string

489
00:19:31,360 --> 00:19:34,160
in order on spark in order to

490
00:19:34,160 --> 00:19:37,039
uh write one byte at a time

491
00:19:37,039 --> 00:19:38,559
i don't know i haven't read about it

492
00:19:38,559 --> 00:19:40,559
anywhere so maybe it's something new i'm

493
00:19:40,559 --> 00:19:42,080
not sure

494
00:19:42,080 --> 00:19:43,679
uh let's

495
00:19:43,679 --> 00:19:46,000
see the code that implements this

496
00:19:46,000 --> 00:19:47,679
i'm not going to comment this because

497
00:19:47,679 --> 00:19:48,640
it's

498
00:19:48,640 --> 00:19:50,000
i don't know maybe it's a bit too

499
00:19:50,000 --> 00:19:51,440
complicated to read if you're not

500
00:19:51,440 --> 00:19:53,840
familiar with c code i will just show

501
00:19:53,840 --> 00:19:55,600
you how it works

502
00:19:55,600 --> 00:19:57,600
with the help of gdb

503
00:19:57,600 --> 00:19:58,720
um

504
00:19:58,720 --> 00:20:00,320
sorry

505
00:20:00,320 --> 00:20:04,799
spoiler spoiler okay let's see we have

506
00:20:04,799 --> 00:20:07,760
a shell code like this one and we want

507
00:20:07,760 --> 00:20:10,080
to write it somewhere in memory let's

508
00:20:10,080 --> 00:20:13,200
see how the code that we you saw earlier

509
00:20:13,200 --> 00:20:15,679
um implements my technique to write the

510
00:20:15,679 --> 00:20:19,039
first four bytes of this shellcode oh by

511
00:20:19,039 --> 00:20:22,240
the way spark is big endian so you will

512
00:20:22,240 --> 00:20:24,720
see that the bytes in memory are

513
00:20:24,720 --> 00:20:26,559
represented in the natural order they're

514
00:20:26,559 --> 00:20:28,960
not inverted like it happens on little

515
00:20:28,960 --> 00:20:32,960
indian architectures such as intel

516
00:20:32,960 --> 00:20:35,440
okay we write the first byte the least

517
00:20:35,440 --> 00:20:37,760
significant byte using the percent and

518
00:20:37,760 --> 00:20:40,880
directive uh pointed to the target

519
00:20:40,880 --> 00:20:43,440
address so so far so good

520
00:20:43,440 --> 00:20:47,600
then we use the percent hn directive to

521
00:20:47,600 --> 00:20:50,159
write the third

522
00:20:50,159 --> 00:20:51,440
byte

523
00:20:51,440 --> 00:20:52,559
also that's

524
00:20:52,559 --> 00:20:54,159
pretty normal

525
00:20:54,159 --> 00:20:56,159
then we use the less known

526
00:20:56,159 --> 00:20:59,120
hhn directive to write the most

527
00:20:59,120 --> 00:21:00,880
significant byte

528
00:21:00,880 --> 00:21:02,559
but then we're left with a problem how

529
00:21:02,559 --> 00:21:05,600
can we override the remaining byte

530
00:21:05,600 --> 00:21:08,720
um there's no real real uh

531
00:21:08,720 --> 00:21:09,760
there's no

532
00:21:09,760 --> 00:21:12,240
uh directive that enables you to do that

533
00:21:12,240 --> 00:21:15,600
directly so i experimented a lot and out

534
00:21:15,600 --> 00:21:18,320
of desperation again i tried something

535
00:21:18,320 --> 00:21:20,159
that was not supposed to work that is

536
00:21:20,159 --> 00:21:23,919
not supposed to work i tried this

537
00:21:23,919 --> 00:21:26,400
so as you can see i referenced a memory

538
00:21:26,400 --> 00:21:28,880
address that was not a multiple of 4

539
00:21:28,880 --> 00:21:31,440
because i added two to the base address

540
00:21:31,440 --> 00:21:34,480
and so our program was supposed to to to

541
00:21:34,480 --> 00:21:37,440
crash with a bus error but it didn't it

542
00:21:37,440 --> 00:21:39,120
worked so i don't know why i don't

543
00:21:39,120 --> 00:21:40,880
explain this but you know i'm not

544
00:21:40,880 --> 00:21:42,880
complaining this is what enables our

545
00:21:42,880 --> 00:21:44,960
exploit to work and this happens a lot

546
00:21:44,960 --> 00:21:46,480
if you have written exploits yourself

547
00:21:46,480 --> 00:21:48,880
you know that sometimes it just works

548
00:21:48,880 --> 00:21:50,960
maybe you don't feel like investigating

549
00:21:50,960 --> 00:21:53,440
the reason why

550
00:21:53,440 --> 00:21:56,400
so if you leave our exploit

551
00:21:56,400 --> 00:21:58,480
running you see that it's able to craft

552
00:21:58,480 --> 00:22:00,159
all the shell code in memory we'll see

553
00:22:00,159 --> 00:22:02,400
shortly what the shell code does

554
00:22:02,400 --> 00:22:04,400
but first we need

555
00:22:04,400 --> 00:22:07,200
the final piece of the puzzle we need to

556
00:22:07,200 --> 00:22:08,799
decide

557
00:22:08,799 --> 00:22:09,760
where

558
00:22:09,760 --> 00:22:12,640
we perform our over overwrite in memory

559
00:22:12,640 --> 00:22:16,240
what we overwrite so i turn to my

560
00:22:16,240 --> 00:22:18,559
old with you know yellowing pages and

561
00:22:18,559 --> 00:22:20,400
all uh

562
00:22:20,400 --> 00:22:22,240
shellcoders handbook published more than

563
00:22:22,240 --> 00:22:24,799
15 years ago in search of inspiration

564
00:22:24,799 --> 00:22:27,120
and based on this book and my experience

565
00:22:27,120 --> 00:22:30,000
i identified a few candidates a few

566
00:22:30,000 --> 00:22:32,240
memory artists that are good candidates

567
00:22:32,240 --> 00:22:33,280
for

568
00:22:33,280 --> 00:22:35,360
overwriting in order to hijack the

569
00:22:35,360 --> 00:22:38,080
control flow

570
00:22:39,520 --> 00:22:40,960
unfortunately

571
00:22:40,960 --> 00:22:43,760
all of them seems like seemed like dead

572
00:22:43,760 --> 00:22:47,280
hands uh for instance the plt entries

573
00:22:47,280 --> 00:22:49,520
that are similar with gota entries on

574
00:22:49,520 --> 00:22:52,080
spark but let's not go too much into

575
00:22:52,080 --> 00:22:53,280
details here because it's a bit

576
00:22:53,280 --> 00:22:55,280
complicated anyway

577
00:22:55,280 --> 00:22:57,200
they're like jump codes that get called

578
00:22:57,200 --> 00:23:00,080
when you call a library function

579
00:23:00,080 --> 00:23:02,480
in the binary they started with a null

580
00:23:02,480 --> 00:23:05,200
byte so this was a no-go we cannot use

581
00:23:05,200 --> 00:23:07,520
that in this kind of overflow

582
00:23:07,520 --> 00:23:09,520
i even meddled with the function

583
00:23:09,520 --> 00:23:11,679
activation records

584
00:23:11,679 --> 00:23:13,440
which is not really at least in my

585
00:23:13,440 --> 00:23:15,919
opinion a terrible target because it's

586
00:23:15,919 --> 00:23:17,919
not very reliable they move

587
00:23:17,919 --> 00:23:21,120
a bit in the stack

588
00:23:21,120 --> 00:23:23,760
i even managed to write a perfectly

589
00:23:23,760 --> 00:23:25,360
working exploit

590
00:23:25,360 --> 00:23:28,159
with just one small program

591
00:23:28,159 --> 00:23:29,280
it works

592
00:23:29,280 --> 00:23:31,280
yes i published it you can try it

593
00:23:31,280 --> 00:23:33,440
yourself if you have a spark machine

594
00:23:33,440 --> 00:23:35,440
but it works only when a debugger is

595
00:23:35,440 --> 00:23:37,120
attached to the target

596
00:23:37,120 --> 00:23:38,960
program so

597
00:23:38,960 --> 00:23:41,120
that's not really useful in a real life

598
00:23:41,120 --> 00:23:44,559
scenario that's another perk of spark

599
00:23:44,559 --> 00:23:47,600
related to caching

600
00:23:47,760 --> 00:23:50,799
so long story short after a lot of dead

601
00:23:50,799 --> 00:23:53,679
ends i noticed something i noticed that

602
00:23:53,679 --> 00:23:54,960
library

603
00:23:54,960 --> 00:23:58,080
libraries so library binaries

604
00:23:58,080 --> 00:24:00,559
not just regular executable binaries

605
00:24:00,559 --> 00:24:01,919
also have

606
00:24:01,919 --> 00:24:05,279
a plt section and this plt section

607
00:24:05,279 --> 00:24:07,600
doesn't start with a null byte

608
00:24:07,600 --> 00:24:10,320
it's writable and it's executable so it

609
00:24:10,320 --> 00:24:12,559
looks like a perfect target to me

610
00:24:12,559 --> 00:24:14,799
if we take a look there in that memory

611
00:24:14,799 --> 00:24:17,679
area you see that you have indeed code

612
00:24:17,679 --> 00:24:20,720
that's executable code in spark assembly

613
00:24:20,720 --> 00:24:23,760
and it basically is implements some

614
00:24:23,760 --> 00:24:26,799
jumps some branches to

615
00:24:26,799 --> 00:24:28,640
the the code of the function that you

616
00:24:28,640 --> 00:24:29,840
call depending on the function that

617
00:24:29,840 --> 00:24:31,600
you're calling it branches to that

618
00:24:31,600 --> 00:24:33,120
function

619
00:24:33,120 --> 00:24:34,480
okay

620
00:24:34,480 --> 00:24:36,880
so coming back to our pseudocode our

621
00:24:36,880 --> 00:24:39,840
plan is to

622
00:24:39,840 --> 00:24:41,520
exploit the format string bug in the

623
00:24:41,520 --> 00:24:43,440
lighter line of code in order to

624
00:24:43,440 --> 00:24:44,720
override

625
00:24:44,720 --> 00:24:48,080
the jump code in the plt section of the

626
00:24:48,080 --> 00:24:49,840
lib c

627
00:24:49,840 --> 00:24:52,000
of the string length function that gets

628
00:24:52,000 --> 00:24:53,679
called right after our vulnerable

629
00:24:53,679 --> 00:24:55,919
function in order to hijack the program

630
00:24:55,919 --> 00:24:57,600
control flow

631
00:24:57,600 --> 00:25:00,320
but with what should we overwrite it

632
00:25:00,320 --> 00:25:02,240
well we have two options basically we

633
00:25:02,240 --> 00:25:03,520
either

634
00:25:03,520 --> 00:25:05,840
overwrite the target of the branch of

635
00:25:05,840 --> 00:25:06,960
the jump

636
00:25:06,960 --> 00:25:09,919
or we can craft our shellcode directly

637
00:25:09,919 --> 00:25:12,080
in memory

638
00:25:12,080 --> 00:25:15,360
i like to keep my exploits as

639
00:25:15,360 --> 00:25:17,840
simple as possible in order to keep them

640
00:25:17,840 --> 00:25:20,799
as reliable as possible and therefore i

641
00:25:20,799 --> 00:25:23,200
went for the second option but of course

642
00:25:23,200 --> 00:25:26,080
we have one problem the last problem

643
00:25:26,080 --> 00:25:29,679
hopefully we are limited to a 36 byte

644
00:25:29,679 --> 00:25:31,520
override here

645
00:25:31,520 --> 00:25:33,520
uh i don't know why i don't know if it's

646
00:25:33,520 --> 00:25:35,200
a problem with sprint f or something

647
00:25:35,200 --> 00:25:37,520
else but you know i really don't care at

648
00:25:37,520 --> 00:25:40,000
this point uh 36 bytes are more than

649
00:25:40,000 --> 00:25:41,679
enough for a share code

650
00:25:41,679 --> 00:25:43,760
so i wrote this custom shell code that

651
00:25:43,760 --> 00:25:47,120
you already viewed in a previous slide

652
00:25:47,120 --> 00:25:48,960
unfortunately we don't have the time to

653
00:25:48,960 --> 00:25:50,559
see

654
00:25:50,559 --> 00:25:52,000
how it works

655
00:25:52,000 --> 00:25:54,000
because sharecoding on spark is really

656
00:25:54,000 --> 00:25:56,880
fascinating in my opinion

657
00:25:56,880 --> 00:25:59,600
but what it does is to change

658
00:25:59,600 --> 00:26:02,960
to set the set with bit on a target

659
00:26:02,960 --> 00:26:04,400
binary

660
00:26:04,400 --> 00:26:07,279
as a matter of fact to set all bits

661
00:26:07,279 --> 00:26:09,360
on on a target binary on disk in this

662
00:26:09,360 --> 00:26:12,080
case the me binary

663
00:26:12,080 --> 00:26:14,240
so putting everything together we first

664
00:26:14,240 --> 00:26:16,480
create a

665
00:26:16,480 --> 00:26:18,000
directory tree

666
00:26:18,000 --> 00:26:20,000
that enables us to reach the vulnerable

667
00:26:20,000 --> 00:26:22,559
code path we create a

668
00:26:22,559 --> 00:26:23,600
sim link

669
00:26:23,600 --> 00:26:27,440
from the me file to the corn shell

670
00:26:27,440 --> 00:26:29,120
the system-wide corner shell in the bin

671
00:26:29,120 --> 00:26:30,400
directory

672
00:26:30,400 --> 00:26:32,480
maybe that's not very elegant but who

673
00:26:32,480 --> 00:26:35,120
cares everybody's root on the system now

674
00:26:35,120 --> 00:26:36,880
uh then we use the trick that i

675
00:26:36,880 --> 00:26:38,559
mentioned earlier to fake the presence

676
00:26:38,559 --> 00:26:41,440
of a printer and finally we'll populate

677
00:26:41,440 --> 00:26:43,440
the environment and we run the

678
00:26:43,440 --> 00:26:46,000
vulnerable program let's see

679
00:26:46,000 --> 00:26:49,960
the exploit in action

680
00:26:56,960 --> 00:26:58,559
as you can see the corn shell has

681
00:26:58,559 --> 00:27:00,240
regular permissions

682
00:27:00,240 --> 00:27:04,240
then we execute the exploit

683
00:27:05,600 --> 00:27:07,039
that's normal the legal illegal

684
00:27:07,039 --> 00:27:09,279
instruction is normal and then the corn

685
00:27:09,279 --> 00:27:12,799
shell is set with root and we are root

686
00:27:12,799 --> 00:27:14,960
applause

687
00:27:14,960 --> 00:27:17,960
thanks

688
00:27:22,000 --> 00:27:23,919
yeah that's very satisfying after two

689
00:27:23,919 --> 00:27:25,919
weeks of work it is

690
00:27:25,919 --> 00:27:30,000
um so hard to believe but um

691
00:27:30,000 --> 00:27:32,559
21 years almost to the day have passed

692
00:27:32,559 --> 00:27:35,039
since that fateful summer when the

693
00:27:35,039 --> 00:27:36,799
former stringbucks were

694
00:27:36,799 --> 00:27:39,440
first disclosed to the general public to

695
00:27:39,440 --> 00:27:41,760
through the backtrack mailing list and

696
00:27:41,760 --> 00:27:43,279
it's also hard to believe that they

697
00:27:43,279 --> 00:27:45,760
weren't completely eradicated because as

698
00:27:45,760 --> 00:27:46,960
i mentioned

699
00:27:46,960 --> 00:27:49,520
they should be quite easy to spot just

700
00:27:49,520 --> 00:27:51,279
by looking at the source code even with

701
00:27:51,279 --> 00:27:53,520
automated means

702
00:27:53,520 --> 00:27:55,760
but unfortunately or fortunately depends

703
00:27:55,760 --> 00:27:58,000
on your perspective this kind of bugs

704
00:27:58,000 --> 00:27:59,919
have a way to creep back

705
00:27:59,919 --> 00:28:02,640
even into modern code

706
00:28:02,640 --> 00:28:03,520
just

707
00:28:03,520 --> 00:28:06,320
a few months ago in june

708
00:28:06,320 --> 00:28:07,760
this bug

709
00:28:07,760 --> 00:28:09,120
made

710
00:28:09,120 --> 00:28:11,440
some news made in the news

711
00:28:11,440 --> 00:28:14,159
so basically if you had an iphone and if

712
00:28:14,159 --> 00:28:16,880
you connected to a wi-fi network with

713
00:28:16,880 --> 00:28:20,080
this kind of ssid which is obviously a

714
00:28:20,080 --> 00:28:22,720
form of string

715
00:28:22,720 --> 00:28:25,279
that exploits something

716
00:28:25,279 --> 00:28:26,559
your

717
00:28:26,559 --> 00:28:28,960
iphone your the functionality the wi-fi

718
00:28:28,960 --> 00:28:30,880
functionality of your iphone will be

719
00:28:30,880 --> 00:28:33,039
bricked basically until you do some

720
00:28:33,039 --> 00:28:35,120
recovery but it's quite complicated so

721
00:28:35,120 --> 00:28:36,480
as you can see

722
00:28:36,480 --> 00:28:37,840
uh

723
00:28:37,840 --> 00:28:40,799
these kind of bugs can still affect even

724
00:28:40,799 --> 00:28:45,840
modern code such as the ios code

725
00:28:45,840 --> 00:28:48,240
the specific bikes that i told

726
00:28:48,240 --> 00:28:51,039
about today were fixed by oracle in the

727
00:28:51,039 --> 00:28:54,159
aftermath of my recent vulnerability

728
00:28:54,159 --> 00:28:56,559
disclosures there were there was like a

729
00:28:56,559 --> 00:28:58,960
general cleanup of cde code that still

730
00:28:58,960 --> 00:29:01,440
distributed with solaris 10

731
00:29:01,440 --> 00:29:04,080
uh however i have the feeling that there

732
00:29:04,080 --> 00:29:07,039
are still many bugs lurking just beneath

733
00:29:07,039 --> 00:29:08,640
the surface just waiting for some

734
00:29:08,640 --> 00:29:11,679
inspired hackers to find them that's

735
00:29:11,679 --> 00:29:13,840
just my idea

736
00:29:13,840 --> 00:29:15,520
with this

737
00:29:15,520 --> 00:29:17,679
i think i'm done uh i'm done with the

738
00:29:17,679 --> 00:29:20,960
talk and i'm also i guess done with

739
00:29:20,960 --> 00:29:23,919
solaris took me a while

740
00:29:23,919 --> 00:29:24,720
but

741
00:29:24,720 --> 00:29:27,679
i think i will do something something

742
00:29:27,679 --> 00:29:30,240
else from our now on

743
00:29:30,240 --> 00:29:31,279
um

744
00:29:31,279 --> 00:29:33,520
i would just like to leave you with one

745
00:29:33,520 --> 00:29:35,120
last thing

746
00:29:35,120 --> 00:29:37,679
uh as an infosec professional if you all

747
00:29:37,679 --> 00:29:40,559
remember one thing out of this

748
00:29:40,559 --> 00:29:45,520
weird keynote speech it should be this

749
00:29:45,679 --> 00:29:48,640
hack the planet

750
00:29:50,559 --> 00:29:53,559
seriously

751
00:29:54,320 --> 00:29:56,640
that's the moral of the story you know

752
00:29:56,640 --> 00:29:59,520
seriously uh do a little bit less or

753
00:29:59,520 --> 00:30:01,760
whatever you do in your day job do a bit

754
00:30:01,760 --> 00:30:04,559
less of zoom do a bit less of

755
00:30:04,559 --> 00:30:07,440
outlook or powerpoint

756
00:30:07,440 --> 00:30:08,559
whatever

757
00:30:08,559 --> 00:30:09,520
and

758
00:30:09,520 --> 00:30:11,600
go get your hands dirty write some

759
00:30:11,600 --> 00:30:14,399
actual code and have fun that's my

760
00:30:14,399 --> 00:30:15,919
message to you

761
00:30:15,919 --> 00:30:17,919
so thank you very much and enjoy the

762
00:30:17,919 --> 00:30:19,760
rest of rom hack

763
00:30:19,760 --> 00:30:22,760
thanks

