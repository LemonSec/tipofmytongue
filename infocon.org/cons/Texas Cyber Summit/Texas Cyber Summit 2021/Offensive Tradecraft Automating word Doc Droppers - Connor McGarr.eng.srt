1
00:00:01,280 --> 00:00:03,040
hi everyone and thanks for joining me

2
00:00:03,040 --> 00:00:04,960
today and thank you to texas cyber

3
00:00:04,960 --> 00:00:07,279
summit for inviting me to speak today

4
00:00:07,279 --> 00:00:09,440
my name is conor mcgarr and today i

5
00:00:09,440 --> 00:00:11,040
wanted to take a closer look at

6
00:00:11,040 --> 00:00:13,920
automation from a red team perspective

7
00:00:13,920 --> 00:00:16,000
by really taking a deep look at rolling

8
00:00:16,000 --> 00:00:18,400
your own framework for initial access

9
00:00:18,400 --> 00:00:21,680
dropper generation leveraging c-sharp

10
00:00:21,680 --> 00:00:23,359
while maintaining the ability to

11
00:00:23,359 --> 00:00:26,560
leverage more custom shell code loaders

12
00:00:26,560 --> 00:00:28,080
additionally we'll take a look at the

13
00:00:28,080 --> 00:00:30,560
benefit of creating more custom loaders

14
00:00:30,560 --> 00:00:33,120
in order to evade kernel mode detection

15
00:00:33,120 --> 00:00:35,440
logic and achieve remote process

16
00:00:35,440 --> 00:00:38,160
injection without actually spawning any

17
00:00:38,160 --> 00:00:40,160
new remote threads

18
00:00:40,160 --> 00:00:41,600
and with that let's go ahead and get

19
00:00:41,600 --> 00:00:45,280
into the agenda for today's talk

20
00:00:45,280 --> 00:00:47,200
so we'll begin this talk by going over

21
00:00:47,200 --> 00:00:49,280
why we would want to create an entirely

22
00:00:49,280 --> 00:00:50,559
new framework

23
00:00:50,559 --> 00:00:52,320
we'll go over the architecture of our

24
00:00:52,320 --> 00:00:53,680
maldoc

25
00:00:53,680 --> 00:00:55,760
we'll talk about how to perform remote

26
00:00:55,760 --> 00:00:57,840
injection without spawning remote

27
00:00:57,840 --> 00:00:59,039
threads

28
00:00:59,039 --> 00:01:00,640
we'll talk about automating this with

29
00:01:00,640 --> 00:01:02,399
c-sharp

30
00:01:02,399 --> 00:01:04,720
we'll talk about a tool i created that

31
00:01:04,720 --> 00:01:06,640
incorporates everything we'll talk about

32
00:01:06,640 --> 00:01:10,000
today into a tool called little corporal

33
00:01:10,000 --> 00:01:11,760
we'll give a quick demo

34
00:01:11,760 --> 00:01:13,439
and then before we end we'll allocate

35
00:01:13,439 --> 00:01:16,720
some time for some questions

36
00:01:16,720 --> 00:01:18,720
before we get into today's talk let's

37
00:01:18,720 --> 00:01:22,799
begin with the obligatory who am i

38
00:01:22,799 --> 00:01:25,200
so my name is conor mcgarr and i'm a red

39
00:01:25,200 --> 00:01:27,200
teamer here at crowdstrike

40
00:01:27,200 --> 00:01:28,560
i'm pretty much passionate about

41
00:01:28,560 --> 00:01:31,280
anything offensive tradecraft but more

42
00:01:31,280 --> 00:01:33,360
specifically i really like binary

43
00:01:33,360 --> 00:01:35,600
exploitation and vulnerability research

44
00:01:35,600 --> 00:01:38,159
specifically on windows systems

45
00:01:38,159 --> 00:01:40,000
i maintain a blog where i talk about

46
00:01:40,000 --> 00:01:43,119
many of these topics

47
00:01:44,320 --> 00:01:46,560
so let's begin today's talk by going

48
00:01:46,560 --> 00:01:48,799
over why would we would want to create

49
00:01:48,799 --> 00:01:52,320
an entire new framework

50
00:01:52,880 --> 00:01:55,759
so if you're in the red team consultancy

51
00:01:55,759 --> 00:01:58,399
space red teaming or any consultancy

52
00:01:58,399 --> 00:02:00,560
space for that matter you know that it's

53
00:02:00,560 --> 00:02:03,280
high octane so we're constantly keeping

54
00:02:03,280 --> 00:02:05,840
up to date with adversary ttps we're

55
00:02:05,840 --> 00:02:08,239
mimicking those ttps constantly doing

56
00:02:08,239 --> 00:02:10,080
research and evolving as red team

57
00:02:10,080 --> 00:02:12,239
operators

58
00:02:12,239 --> 00:02:14,560
we also are constantly rolling on to new

59
00:02:14,560 --> 00:02:16,640
engagements and rolling off of old ones

60
00:02:16,640 --> 00:02:18,800
so we're in a ton of environments that

61
00:02:18,800 --> 00:02:20,959
are quite diverse

62
00:02:20,959 --> 00:02:22,640
and we're in those environments every

63
00:02:22,640 --> 00:02:25,120
few weeks

64
00:02:25,120 --> 00:02:26,319
so

65
00:02:26,319 --> 00:02:28,800
with the fact that we're managing so

66
00:02:28,800 --> 00:02:30,400
many different operations it's a

67
00:02:30,400 --> 00:02:32,800
no-brainer that we need to automate some

68
00:02:32,800 --> 00:02:35,120
of the infrastructure of a red team

69
00:02:35,120 --> 00:02:36,720
engagement so today we'll talk about

70
00:02:36,720 --> 00:02:38,720
automating the initial access dropper

71
00:02:38,720 --> 00:02:40,160
piece

72
00:02:40,160 --> 00:02:43,280
but the main focus here today is

73
00:02:43,280 --> 00:02:45,519
if you talk about integrating a custom

74
00:02:45,519 --> 00:02:46,959
capability

75
00:02:46,959 --> 00:02:49,519
that infers that automation may not be

76
00:02:49,519 --> 00:02:52,319
possible if the capability requires some

77
00:02:52,319 --> 00:02:54,319
kind of custom or low level

78
00:02:54,319 --> 00:02:56,080
understanding

79
00:02:56,080 --> 00:02:58,000
so with that if we would like to

80
00:02:58,000 --> 00:02:59,680
automate there are pretty much two

81
00:02:59,680 --> 00:03:01,920
options here we can either leverage an

82
00:03:01,920 --> 00:03:03,840
existing open source framework and

83
00:03:03,840 --> 00:03:05,760
integrated capability

84
00:03:05,760 --> 00:03:07,280
but with that we're relying on the

85
00:03:07,280 --> 00:03:10,239
support of the creator of that project

86
00:03:10,239 --> 00:03:12,319
and if not you may need to become the

87
00:03:12,319 --> 00:03:14,560
supporter of that project and there may

88
00:03:14,560 --> 00:03:16,480
be a lack of support for some features

89
00:03:16,480 --> 00:03:17,599
you may need

90
00:03:17,599 --> 00:03:19,440
or we can just roll our own which we'll

91
00:03:19,440 --> 00:03:22,319
talk about here today

92
00:03:23,440 --> 00:03:26,239
so creation of this automation framework

93
00:03:26,239 --> 00:03:28,159
this is not a comprehensive list and

94
00:03:28,159 --> 00:03:30,400
this is just a list that i arbitrarily

95
00:03:30,400 --> 00:03:31,760
put together

96
00:03:31,760 --> 00:03:33,200
everyone is going to have different

97
00:03:33,200 --> 00:03:35,760
experiences this from my experience is

98
00:03:35,760 --> 00:03:37,440
what i look for in an automation

99
00:03:37,440 --> 00:03:39,200
framework

100
00:03:39,200 --> 00:03:41,280
i look for

101
00:03:41,280 --> 00:03:43,120
the ability to write it in a high level

102
00:03:43,120 --> 00:03:45,040
language that's easily understandable

103
00:03:45,040 --> 00:03:47,280
and is common

104
00:03:47,280 --> 00:03:49,360
i look for the fact that this language

105
00:03:49,360 --> 00:03:51,840
we're writing in has integration with

106
00:03:51,840 --> 00:03:54,000
whatever dropper mechanism we want to

107
00:03:54,000 --> 00:03:56,640
use so in our case we want to generate

108
00:03:56,640 --> 00:04:00,080
some microsoft word documents so c sharp

109
00:04:00,080 --> 00:04:01,760
has the ability to integrate with the

110
00:04:01,760 --> 00:04:05,840
office api to programmatically do this

111
00:04:05,840 --> 00:04:08,159
we want to be able to support any c2

112
00:04:08,159 --> 00:04:10,239
framework so essentially we don't want

113
00:04:10,239 --> 00:04:13,360
it to be specific to one c2 framework

114
00:04:13,360 --> 00:04:16,639
if a c2 framework can create shell code

115
00:04:16,639 --> 00:04:18,478
in order to generate

116
00:04:18,478 --> 00:04:21,199
the artifact used for the engagement

117
00:04:21,199 --> 00:04:23,120
that is what we need and that's what we

118
00:04:23,120 --> 00:04:25,600
should be able to support and keep it c2

119
00:04:25,600 --> 00:04:27,120
agnostic

120
00:04:27,120 --> 00:04:29,199
and then we want the potential to always

121
00:04:29,199 --> 00:04:33,199
be improving through modularity

122
00:04:33,759 --> 00:04:35,680
so now let's get into the architecture

123
00:04:35,680 --> 00:04:37,840
of this maldoc by outlining the

124
00:04:37,840 --> 00:04:39,120
objectives

125
00:04:39,120 --> 00:04:41,440
and what we're looking for here again to

126
00:04:41,440 --> 00:04:42,880
reiterate

127
00:04:42,880 --> 00:04:45,440
this varies across operators and what

128
00:04:45,440 --> 00:04:48,720
various operators adversaries or whoever

129
00:04:48,720 --> 00:04:51,040
deems as what's needed for a given

130
00:04:51,040 --> 00:04:54,000
engagement for me this talk these are

131
00:04:54,000 --> 00:04:55,600
the things that i look for in the

132
00:04:55,600 --> 00:04:57,840
architecture of a maldoc

133
00:04:57,840 --> 00:04:59,360
and so let's go ahead and get into that

134
00:04:59,360 --> 00:05:01,440
here

135
00:05:01,440 --> 00:05:03,440
so the maldoc obviously needs the

136
00:05:03,440 --> 00:05:05,840
ability to persistently store the

137
00:05:05,840 --> 00:05:08,000
payload we would like to execute and

138
00:05:08,000 --> 00:05:10,240
this normally comes in the form of a

139
00:05:10,240 --> 00:05:13,120
reflective dll that's ported to shell

140
00:05:13,120 --> 00:05:14,960
code

141
00:05:14,960 --> 00:05:16,720
we want the ability to decouple

142
00:05:16,720 --> 00:05:19,280
execution of the payload so we do not

143
00:05:19,280 --> 00:05:21,120
want the payload to be running directly

144
00:05:21,120 --> 00:05:24,320
within the word.exe process as this is

145
00:05:24,320 --> 00:05:27,360
an ioc for adverse for

146
00:05:27,360 --> 00:05:29,280
blue teams

147
00:05:29,280 --> 00:05:30,720
additionally we want the ability to

148
00:05:30,720 --> 00:05:32,800
integrate a custom loader and avoid

149
00:05:32,800 --> 00:05:35,759
these common windows api calls

150
00:05:35,759 --> 00:05:38,000
the chain of calls i should say of

151
00:05:38,000 --> 00:05:39,919
allocating memory with virtual

152
00:05:39,919 --> 00:05:40,800
x

153
00:05:40,800 --> 00:05:42,720
right process memory and then creating a

154
00:05:42,720 --> 00:05:45,199
remote thread we want to try to avoid

155
00:05:45,199 --> 00:05:46,240
these

156
00:05:46,240 --> 00:05:47,919
more popular

157
00:05:47,919 --> 00:05:51,039
injection techniques

158
00:05:51,600 --> 00:05:53,840
so kind of answering these questions for

159
00:05:53,840 --> 00:05:55,360
our purposes the way that we will

160
00:05:55,360 --> 00:05:57,120
actually persistently store the payload

161
00:05:57,120 --> 00:05:58,240
artifact

162
00:05:58,240 --> 00:05:59,840
is through the inline

163
00:05:59,840 --> 00:06:01,520
shape.alternativetext

164
00:06:01,520 --> 00:06:03,120
word property which we'll talk about

165
00:06:03,120 --> 00:06:05,280
shortly

166
00:06:05,280 --> 00:06:07,360
the way we decouple execution of the

167
00:06:07,360 --> 00:06:11,280
payload is we will use local injection

168
00:06:11,280 --> 00:06:14,160
to actually execute the remote injection

169
00:06:14,160 --> 00:06:16,960
capability which will remotely inject

170
00:06:16,960 --> 00:06:18,160
our

171
00:06:18,160 --> 00:06:21,039
c2 payload into another process this may

172
00:06:21,039 --> 00:06:22,720
sound kind of confusing but we'll get

173
00:06:22,720 --> 00:06:24,560
into the lower level details here

174
00:06:24,560 --> 00:06:26,960
shortly

175
00:06:27,120 --> 00:06:29,360
um and then integrating the custom

176
00:06:29,360 --> 00:06:32,560
loader um we want to use a technique

177
00:06:32,560 --> 00:06:34,319
known as thread hijacking which

178
00:06:34,319 --> 00:06:36,319
essentially will locate a remote thread

179
00:06:36,319 --> 00:06:38,240
within a remote process

180
00:06:38,240 --> 00:06:40,560
hijack that thread in order to execute

181
00:06:40,560 --> 00:06:43,120
our shell code and then restore

182
00:06:43,120 --> 00:06:45,039
execution

183
00:06:45,039 --> 00:06:46,560
of the thread

184
00:06:46,560 --> 00:06:49,199
this avoids new remote thread

185
00:06:49,199 --> 00:06:51,759
creation

186
00:06:53,840 --> 00:06:55,520
so beginning with how we're going to

187
00:06:55,520 --> 00:06:57,520
store our payload let's talk about

188
00:06:57,520 --> 00:06:59,680
inline shape.alternativetext word

189
00:06:59,680 --> 00:07:00,800
property

190
00:07:00,800 --> 00:07:02,880
so this is a property in word as we can

191
00:07:02,880 --> 00:07:04,160
see from the screenshot on the right

192
00:07:04,160 --> 00:07:06,800
hand side which sets a string that

193
00:07:06,800 --> 00:07:08,720
represents the alternative text

194
00:07:08,720 --> 00:07:11,199
associated with the shape in a web page

195
00:07:11,199 --> 00:07:14,479
for our purposes this will be an image

196
00:07:14,479 --> 00:07:16,400
that's pulled down remotely from the

197
00:07:16,400 --> 00:07:18,800
internet into our document and then we

198
00:07:18,800 --> 00:07:20,720
can use this property in order to

199
00:07:20,720 --> 00:07:23,599
actually store our full payload there

200
00:07:23,599 --> 00:07:25,440
so basically if you have the ability to

201
00:07:25,440 --> 00:07:27,360
embed an image into the document you

202
00:07:27,360 --> 00:07:29,360
have a way to store the payload with the

203
00:07:29,360 --> 00:07:31,520
architecture of how our maldoc is going

204
00:07:31,520 --> 00:07:33,919
to look

205
00:07:34,880 --> 00:07:37,120
so with the ability to store the payload

206
00:07:37,120 --> 00:07:39,840
persistently the goal now is to perform

207
00:07:39,840 --> 00:07:41,840
the loading of the payload that we've

208
00:07:41,840 --> 00:07:43,360
stored

209
00:07:43,360 --> 00:07:44,720
in memory

210
00:07:44,720 --> 00:07:46,479
and for our purposes we're going to use

211
00:07:46,479 --> 00:07:48,240
process injection

212
00:07:48,240 --> 00:07:50,560
so just a quick quick brief word on

213
00:07:50,560 --> 00:07:52,479
process injection

214
00:07:52,479 --> 00:07:54,240
if you're a red teamer or blue teamer

215
00:07:54,240 --> 00:07:56,560
you know that this is highly scrutinized

216
00:07:56,560 --> 00:07:58,800
so i just want to put that out there

217
00:07:58,800 --> 00:08:00,800
having said that there still is a time

218
00:08:00,800 --> 00:08:03,759
and a place for process injection

219
00:08:03,759 --> 00:08:05,440
for example if there's a brittle

220
00:08:05,440 --> 00:08:07,039
detection

221
00:08:07,039 --> 00:08:09,520
that relies on a known good

222
00:08:09,520 --> 00:08:12,080
such as we can expect only a given

223
00:08:12,080 --> 00:08:14,800
process of x y z name

224
00:08:14,800 --> 00:08:16,960
to perform a given action

225
00:08:16,960 --> 00:08:19,199
that can be circumvented by getting in

226
00:08:19,199 --> 00:08:22,879
context of these known good processes

227
00:08:22,879 --> 00:08:24,720
through process injection so for

228
00:08:24,720 --> 00:08:28,400
instance if we deem a certain process as

229
00:08:28,400 --> 00:08:30,639
always doing something that's benign

230
00:08:30,639 --> 00:08:32,799
which again is not a very good detection

231
00:08:32,799 --> 00:08:35,679
but this is something you you do see

232
00:08:35,679 --> 00:08:38,240
if you're able to get in context of this

233
00:08:38,240 --> 00:08:40,479
process by performing injection

234
00:08:40,479 --> 00:08:42,958
you then may be able to blend into the

235
00:08:42,958 --> 00:08:44,399
environment more

236
00:08:44,399 --> 00:08:46,080
readily

237
00:08:46,080 --> 00:08:48,480
and again process injection is not

238
00:08:48,480 --> 00:08:51,440
always nefarious so there are legitimate

239
00:08:51,440 --> 00:08:53,279
reasons why process injection takes

240
00:08:53,279 --> 00:08:54,480
place

241
00:08:54,480 --> 00:08:57,600
one of the reasons as we'll see shortly

242
00:08:57,600 --> 00:09:00,640
are browsers that map dynamically

243
00:09:00,640 --> 00:09:02,640
generated machine code through a process

244
00:09:02,640 --> 00:09:05,360
called just-in-time compilation

245
00:09:05,360 --> 00:09:08,399
into a renderer process which a user

246
00:09:08,399 --> 00:09:10,800
interfaces with

247
00:09:10,800 --> 00:09:12,399
this is done through what's known as

248
00:09:12,399 --> 00:09:15,360
out-of-process j engines

249
00:09:15,360 --> 00:09:18,080
and again as underlined there is always

250
00:09:18,080 --> 00:09:20,560
room for improvement

251
00:09:20,560 --> 00:09:22,880
so this talk outlines the beginning of

252
00:09:22,880 --> 00:09:25,200
leveraging more custom loaders i'm not

253
00:09:25,200 --> 00:09:26,800
going to say that the loaders we will

254
00:09:26,800 --> 00:09:28,399
show have never been seen before there

255
00:09:28,399 --> 00:09:30,720
are plenty of cases that are public with

256
00:09:30,720 --> 00:09:33,200
these loaders available but they're less

257
00:09:33,200 --> 00:09:34,480
well known

258
00:09:34,480 --> 00:09:37,040
and because of this each technique needs

259
00:09:37,040 --> 00:09:39,600
to be vetted and studied for the

260
00:09:39,600 --> 00:09:41,279
indicators of compromise that are left

261
00:09:41,279 --> 00:09:43,760
behind and adjusted accordingly for

262
00:09:43,760 --> 00:09:46,560
better opsec

263
00:09:47,279 --> 00:09:48,959
so with that said let's talk about how

264
00:09:48,959 --> 00:09:51,120
our process injection will look our

265
00:09:51,120 --> 00:09:52,000
process

266
00:09:52,000 --> 00:09:55,360
process injection will be twofold

267
00:09:55,360 --> 00:09:56,240
so

268
00:09:56,240 --> 00:09:58,800
we'll begin with an initial local

269
00:09:58,800 --> 00:10:01,120
injection into the word process

270
00:10:01,120 --> 00:10:03,600
so this injection

271
00:10:03,600 --> 00:10:06,240
will actually load a second stage which

272
00:10:06,240 --> 00:10:07,800
is actually going to be a full

273
00:10:07,800 --> 00:10:10,000
c-sharp.net assembly

274
00:10:10,000 --> 00:10:12,560
which has the capability to perform

275
00:10:12,560 --> 00:10:16,800
remote injection into the target process

276
00:10:16,800 --> 00:10:18,880
and again our payload here does not

277
00:10:18,880 --> 00:10:21,200
necessarily have to be c sharp

278
00:10:21,200 --> 00:10:22,560
that's just what we're using for the

279
00:10:22,560 --> 00:10:26,479
purposes of this talk today

280
00:10:26,560 --> 00:10:28,720
the reason why we want to perform

281
00:10:28,720 --> 00:10:31,040
local injection is

282
00:10:31,040 --> 00:10:32,560
um twofold

283
00:10:32,560 --> 00:10:33,519
one

284
00:10:33,519 --> 00:10:36,480
we can decouple execution so the final

285
00:10:36,480 --> 00:10:38,320
payload will not actually run within the

286
00:10:38,320 --> 00:10:39,760
word process

287
00:10:39,760 --> 00:10:41,760
injecting in the to the word process is

288
00:10:41,760 --> 00:10:44,399
just simply a means to an end to perform

289
00:10:44,399 --> 00:10:46,880
remote injection

290
00:10:46,880 --> 00:10:49,440
also local injection is less scrutinized

291
00:10:49,440 --> 00:10:51,600
than remote injection it's a lot harder

292
00:10:51,600 --> 00:10:54,000
to detect

293
00:10:54,000 --> 00:10:56,480
so everything that's loaded into memory

294
00:10:56,480 --> 00:10:58,800
will be done everything will be loaded

295
00:10:58,800 --> 00:11:01,360
into memory through the local injection

296
00:11:01,360 --> 00:11:04,480
before any remote injection is performed

297
00:11:04,480 --> 00:11:06,640
and so now that we have some primitive

298
00:11:06,640 --> 00:11:08,880
to actually perform remote injection a

299
00:11:08,880 --> 00:11:11,839
la our local injection into the word.exe

300
00:11:11,839 --> 00:11:12,800
process

301
00:11:12,800 --> 00:11:14,959
this gives an operator extensibility

302
00:11:14,959 --> 00:11:18,000
into the ability to choose a process

303
00:11:18,000 --> 00:11:20,480
which perhaps may blend in better within

304
00:11:20,480 --> 00:11:22,160
the environment so think about earlier

305
00:11:22,160 --> 00:11:24,640
what i spoke of with brittle detections

306
00:11:24,640 --> 00:11:27,680
that just purely rely on a given process

307
00:11:27,680 --> 00:11:29,120
name

308
00:11:29,120 --> 00:11:31,200
but again this is highly dependent on

309
00:11:31,200 --> 00:11:33,120
the target environment and this actually

310
00:11:33,120 --> 00:11:36,320
falls more under conjecture versus data

311
00:11:36,320 --> 00:11:37,279
that can

312
00:11:37,279 --> 00:11:39,920
back this up

313
00:11:41,519 --> 00:11:43,440
so starting with the local injection

314
00:11:43,440 --> 00:11:45,600
into the word process we know that we're

315
00:11:45,600 --> 00:11:48,160
going to have a net assembly which we

316
00:11:48,160 --> 00:11:50,800
need to inject locally so in order to do

317
00:11:50,800 --> 00:11:53,360
that we need to first convert this.net

318
00:11:53,360 --> 00:11:55,920
assembly into position independent shell

319
00:11:55,920 --> 00:11:58,240
code and the way we do this is with an

320
00:11:58,240 --> 00:12:00,720
open source tool called donut

321
00:12:00,720 --> 00:12:03,040
um so i'm not going to get into the

322
00:12:03,040 --> 00:12:04,959
technical details of donut if you would

323
00:12:04,959 --> 00:12:07,680
like to do that um the wover has a

324
00:12:07,680 --> 00:12:11,440
beautiful blog post bringing donut to

325
00:12:11,440 --> 00:12:13,200
light and explaining how it actually

326
00:12:13,200 --> 00:12:14,160
works

327
00:12:14,160 --> 00:12:16,079
but for our purposes just know that

328
00:12:16,079 --> 00:12:19,279
donut converts a.net assembly and more

329
00:12:19,279 --> 00:12:21,600
technically into position independent

330
00:12:21,600 --> 00:12:23,279
code which then can be used for

331
00:12:23,279 --> 00:12:26,240
injection purposes

332
00:12:27,519 --> 00:12:29,040
so

333
00:12:29,040 --> 00:12:31,360
after we use donut to convert the.net

334
00:12:31,360 --> 00:12:33,120
assembly which performs the remote

335
00:12:33,120 --> 00:12:35,120
injection

336
00:12:35,120 --> 00:12:37,360
we can actually load that into memory

337
00:12:37,360 --> 00:12:40,160
using a simple vba macro which calls a

338
00:12:40,160 --> 00:12:42,320
few windows apis

339
00:12:42,320 --> 00:12:44,560
so first of all the payload is first

340
00:12:44,560 --> 00:12:47,519
base64 decoded because in the future we

341
00:12:47,519 --> 00:12:50,320
will be encoding this in basic c4

342
00:12:50,320 --> 00:12:52,920
and it's stored in the inline

343
00:12:52,920 --> 00:12:55,680
shapes.alternativetext word property

344
00:12:55,680 --> 00:12:57,360
and so what we do is

345
00:12:57,360 --> 00:13:00,560
using the vba macro we

346
00:13:00,560 --> 00:13:02,079
index the

347
00:13:02,079 --> 00:13:04,560
inline shapes.alternativetext

348
00:13:04,560 --> 00:13:06,079
property from the image that we've

349
00:13:06,079 --> 00:13:07,040
stored

350
00:13:07,040 --> 00:13:09,440
we base64 decode it

351
00:13:09,440 --> 00:13:11,839
then we perform local injection using

352
00:13:11,839 --> 00:13:14,320
virtual alloc and create thread

353
00:13:14,320 --> 00:13:16,160
again as i've mentioned with remote

354
00:13:16,160 --> 00:13:18,079
injection there is or excuse me with

355
00:13:18,079 --> 00:13:20,880
injection there are always room there's

356
00:13:20,880 --> 00:13:22,880
always room for improvement this is just

357
00:13:22,880 --> 00:13:25,200
for the purposes of the talk today and

358
00:13:25,200 --> 00:13:28,720
to outline a proof of concept

359
00:13:29,680 --> 00:13:31,839
so this all may seem very confusing thus

360
00:13:31,839 --> 00:13:34,000
far but let's talk about the actual

361
00:13:34,000 --> 00:13:36,240
execution flow

362
00:13:36,240 --> 00:13:38,720
so as we mentioned local injection first

363
00:13:38,720 --> 00:13:41,199
happens into the word process so as we

364
00:13:41,199 --> 00:13:42,720
can see in the screenshot the dot net

365
00:13:42,720 --> 00:13:44,240
assembly is actually loaded into

366
00:13:44,240 --> 00:13:47,199
word.exe

367
00:13:47,279 --> 00:13:49,440
and once this.net assembly is loaded

368
00:13:49,440 --> 00:13:50,800
into word

369
00:13:50,800 --> 00:13:53,199
and it's executed the net assembly

370
00:13:53,199 --> 00:13:56,240
actually performs remote injection into

371
00:13:56,240 --> 00:13:58,480
a specified process by the operator in

372
00:13:58,480 --> 00:14:01,519
this case it would be ms edge.exe which

373
00:14:01,519 --> 00:14:04,399
is microsoft edge that runs on the

374
00:14:04,399 --> 00:14:07,279
chromium engine

375
00:14:07,839 --> 00:14:09,360
so now that we kind of have a clear

376
00:14:09,360 --> 00:14:10,480
picture

377
00:14:10,480 --> 00:14:12,160
of what our goals are

378
00:14:12,160 --> 00:14:14,959
and knowing remote process injection is

379
00:14:14,959 --> 00:14:16,720
not only the end goal but is highly

380
00:14:16,720 --> 00:14:19,120
scrutinized let's formulate a remote

381
00:14:19,120 --> 00:14:22,480
process injection technique

382
00:14:23,519 --> 00:14:24,240
so

383
00:14:24,240 --> 00:14:26,480
our base condition for the purposes of

384
00:14:26,480 --> 00:14:27,920
this talk

385
00:14:27,920 --> 00:14:31,199
is that remote thread creation is the a

386
00:14:31,199 --> 00:14:32,880
great indicator of compromise that can

387
00:14:32,880 --> 00:14:34,560
be used to detect remote process

388
00:14:34,560 --> 00:14:37,119
injection

389
00:14:38,639 --> 00:14:40,320
so knowing this let's talk about remote

390
00:14:40,320 --> 00:14:42,320
injection without the need to create new

391
00:14:42,320 --> 00:14:45,519
remote threads

392
00:14:45,519 --> 00:14:46,240
so

393
00:14:46,240 --> 00:14:49,920
as a quote unquote mock sensor

394
00:14:49,920 --> 00:14:52,800
we will use kernel mode telemetry

395
00:14:52,800 --> 00:14:54,160
as a

396
00:14:54,160 --> 00:14:56,160
target to

397
00:14:56,160 --> 00:14:59,040
bypass some detection logic

398
00:14:59,040 --> 00:15:00,720
so i won't get into the full details

399
00:15:00,720 --> 00:15:03,279
here but within kernel mode you have

400
00:15:03,279 --> 00:15:04,560
something on the windows operating

401
00:15:04,560 --> 00:15:06,240
system called the kernel mode callback

402
00:15:06,240 --> 00:15:08,560
table and these are basically arrays of

403
00:15:08,560 --> 00:15:10,639
functions that are called when a certain

404
00:15:10,639 --> 00:15:13,040
action happens so in the screenshot

405
00:15:13,040 --> 00:15:14,720
below we see that the kernel callback

406
00:15:14,720 --> 00:15:17,199
table here is called psp create process

407
00:15:17,199 --> 00:15:18,720
notify routine

408
00:15:18,720 --> 00:15:21,360
as the name suggests anytime a new

409
00:15:21,360 --> 00:15:23,199
process is created

410
00:15:23,199 --> 00:15:24,959
all of these functions here would be

411
00:15:24,959 --> 00:15:27,920
called so indexing this array

412
00:15:27,920 --> 00:15:29,920
and performing a few bitwise operations

413
00:15:29,920 --> 00:15:32,720
to actually extract the memory address

414
00:15:32,720 --> 00:15:35,120
of a registered function here we can see

415
00:15:35,120 --> 00:15:37,920
that tcpip driver actually registers a

416
00:15:37,920 --> 00:15:39,759
function called create process notify

417
00:15:39,759 --> 00:15:42,079
routine x which again is one of those

418
00:15:42,079 --> 00:15:43,680
functions that is called every time a

419
00:15:43,680 --> 00:15:46,719
process is created

420
00:15:47,920 --> 00:15:50,880
so building off of that we have a

421
00:15:50,880 --> 00:15:52,000
another

422
00:15:52,000 --> 00:15:54,240
one of these function callbacks called

423
00:15:54,240 --> 00:15:57,600
ps set create thread notify routine

424
00:15:57,600 --> 00:15:59,519
and this is kernel mode telemetry that

425
00:15:59,519 --> 00:16:02,639
detects any time a new thread is created

426
00:16:02,639 --> 00:16:04,959
and so what our mock sensor will do is

427
00:16:04,959 --> 00:16:07,600
compare the injector and the inject e

428
00:16:07,600 --> 00:16:08,720
process

429
00:16:08,720 --> 00:16:11,040
to determine if they are different if

430
00:16:11,040 --> 00:16:12,720
they are we can

431
00:16:12,720 --> 00:16:15,600
infer that remote injection has

432
00:16:15,600 --> 00:16:18,079
occurred

433
00:16:18,720 --> 00:16:20,480
so if we take a look at the screenshot

434
00:16:20,480 --> 00:16:22,320
here on the right hand side this is a

435
00:16:22,320 --> 00:16:23,519
test

436
00:16:23,519 --> 00:16:25,759
quote unquote mock sensor i wrote for

437
00:16:25,759 --> 00:16:27,920
the purposes of this talk

438
00:16:27,920 --> 00:16:30,000
and all it does is register a user

439
00:16:30,000 --> 00:16:32,480
defined function into that

440
00:16:32,480 --> 00:16:34,800
kernel callback table to detect every

441
00:16:34,800 --> 00:16:36,480
time a new thread is created

442
00:16:36,480 --> 00:16:39,279
and then what it will do is it will say

443
00:16:39,279 --> 00:16:42,399
hey is the current process different

444
00:16:42,399 --> 00:16:45,519
from the process that created the thread

445
00:16:45,519 --> 00:16:48,320
if it is we assume that this thread was

446
00:16:48,320 --> 00:16:51,199
injected by a remote process thus

447
00:16:51,199 --> 00:16:55,519
indicative of remote process injection

448
00:16:56,639 --> 00:16:59,360
so as we run the mock sensor as we can

449
00:16:59,360 --> 00:17:01,279
see below we can see that there are many

450
00:17:01,279 --> 00:17:03,519
false positives

451
00:17:03,519 --> 00:17:05,039
the example below as we mentioned

452
00:17:05,039 --> 00:17:07,520
earlier an out of process jit server is

453
00:17:07,520 --> 00:17:09,760
mapping compiled code into a browser

454
00:17:09,760 --> 00:17:12,720
renderer process so javascript is an

455
00:17:12,720 --> 00:17:15,280
interpreted language

456
00:17:15,280 --> 00:17:16,799
but there's something known as just in

457
00:17:16,799 --> 00:17:18,480
time compilation which is used for

458
00:17:18,480 --> 00:17:20,160
performance benefits interpreted

459
00:17:20,160 --> 00:17:22,400
languages are much slower so what

460
00:17:22,400 --> 00:17:24,240
happens is if a certain javascript

461
00:17:24,240 --> 00:17:26,079
function is constantly called and called

462
00:17:26,079 --> 00:17:28,000
and called it becomes what's known as

463
00:17:28,000 --> 00:17:28,960
hot

464
00:17:28,960 --> 00:17:31,039
and when that happens there are very

465
00:17:31,039 --> 00:17:33,280
varying degrees of optimization that

466
00:17:33,280 --> 00:17:35,440
adjusts in time engine will take in

467
00:17:35,440 --> 00:17:37,440
order to actually compile that code into

468
00:17:37,440 --> 00:17:40,240
machine code for performance benefits

469
00:17:40,240 --> 00:17:41,840
and so because you have an out of

470
00:17:41,840 --> 00:17:44,960
process just-in-time server it actually

471
00:17:44,960 --> 00:17:46,960
needs to perform process injection to

472
00:17:46,960 --> 00:17:49,200
map that optimized code into a render

473
00:17:49,200 --> 00:17:51,520
process

474
00:17:51,520 --> 00:17:53,440
so we know that there will be many false

475
00:17:53,440 --> 00:17:55,919
positives but this is what we call our

476
00:17:55,919 --> 00:17:57,520
baseline condition

477
00:17:57,520 --> 00:17:59,840
so this baseline condition makes an

478
00:17:59,840 --> 00:18:01,520
inference about remote injection which

479
00:18:01,520 --> 00:18:03,440
we spoke of earlier that remote

480
00:18:03,440 --> 00:18:05,760
injection always results in a thread

481
00:18:05,760 --> 00:18:08,480
that's created by a process

482
00:18:08,480 --> 00:18:11,120
that is different from the process the

483
00:18:11,120 --> 00:18:14,559
thread was housed in or created

484
00:18:14,559 --> 00:18:16,240
so if we think of our standard remote

485
00:18:16,240 --> 00:18:18,240
injections such as create remote thread

486
00:18:18,240 --> 00:18:21,360
apcs or similar apis

487
00:18:21,360 --> 00:18:23,520
these all rely on

488
00:18:23,520 --> 00:18:26,080
creating a new thread within a remote

489
00:18:26,080 --> 00:18:27,760
process

490
00:18:27,760 --> 00:18:29,679
and this condition would be true at the

491
00:18:29,679 --> 00:18:33,039
kernel level as we've seen

492
00:18:33,440 --> 00:18:34,799
so

493
00:18:34,799 --> 00:18:36,559
there could be many more detections that

494
00:18:36,559 --> 00:18:39,440
are built off of this baseline condition

495
00:18:39,440 --> 00:18:41,440
in order to minimize the false positives

496
00:18:41,440 --> 00:18:42,799
that we see here

497
00:18:42,799 --> 00:18:45,600
however as a quote-unquote last line of

498
00:18:45,600 --> 00:18:48,080
defense this baseline condition should

499
00:18:48,080 --> 00:18:50,320
always be true therefore detecting

500
00:18:50,320 --> 00:18:52,240
remote injection if all of the more

501
00:18:52,240 --> 00:18:56,240
fine-grained detections are circumvented

502
00:18:56,240 --> 00:18:57,360
knowing this

503
00:18:57,360 --> 00:19:00,240
as an adversary we want to target either

504
00:19:00,240 --> 00:19:03,120
the baseline condition or the telemetry

505
00:19:03,120 --> 00:19:04,559
source itself

506
00:19:04,559 --> 00:19:07,520
if we convey this baseline condition the

507
00:19:07,520 --> 00:19:09,520
sensor will then just simply gather the

508
00:19:09,520 --> 00:19:11,679
telemetry of the thread creation

509
00:19:11,679 --> 00:19:13,200
and be done with it and it won't

510
00:19:13,200 --> 00:19:15,120
actually alert

511
00:19:15,120 --> 00:19:17,760
but please note that a sensor

512
00:19:17,760 --> 00:19:20,880
sees everything and this telemetry could

513
00:19:20,880 --> 00:19:22,799
be used as the basis for future

514
00:19:22,799 --> 00:19:24,640
detections

515
00:19:24,640 --> 00:19:27,039
the point here is to outline

516
00:19:27,039 --> 00:19:29,760
what i myself consider an evasion

517
00:19:29,760 --> 00:19:31,200
opportunity

518
00:19:31,200 --> 00:19:32,880
this depends

519
00:19:32,880 --> 00:19:35,039
and varies on who you ask what their

520
00:19:35,039 --> 00:19:37,520
definition of evasion or bypassing is

521
00:19:37,520 --> 00:19:38,960
but for me

522
00:19:38,960 --> 00:19:42,000
what i view as an evasion opportunity is

523
00:19:42,000 --> 00:19:44,400
not tempering tampering with the sensor

524
00:19:44,400 --> 00:19:46,160
in order to neuter it so it cannot see

525
00:19:46,160 --> 00:19:49,679
telemetry but find weaknesses not based

526
00:19:49,679 --> 00:19:52,480
on conjecture but actual data

527
00:19:52,480 --> 00:19:55,360
and take advantage of it so in this case

528
00:19:55,360 --> 00:19:57,120
how the sensor is actually detecting

529
00:19:57,120 --> 00:19:59,200
remote injection that is what we would

530
00:19:59,200 --> 00:20:02,960
like to directly attack

531
00:20:03,280 --> 00:20:05,919
so that just is my little spiel on

532
00:20:05,919 --> 00:20:07,360
detection

533
00:20:07,360 --> 00:20:10,240
and evasion

534
00:20:11,280 --> 00:20:13,440
so

535
00:20:13,679 --> 00:20:15,760
excuse me

536
00:20:15,760 --> 00:20:17,600
how do we avoid this detection and

537
00:20:17,600 --> 00:20:20,400
attack that baseline

538
00:20:20,400 --> 00:20:22,640
logic for evasion

539
00:20:22,640 --> 00:20:24,400
we can actually do this through thread

540
00:20:24,400 --> 00:20:26,960
hijacking so instead of creating a new

541
00:20:26,960 --> 00:20:28,480
remote thread

542
00:20:28,480 --> 00:20:30,400
let's see if there's not a way to

543
00:20:30,400 --> 00:20:34,559
use an existing remote thread

544
00:20:34,559 --> 00:20:36,000
so

545
00:20:36,000 --> 00:20:38,080
as i mentioned instead of creating a new

546
00:20:38,080 --> 00:20:40,480
remote thread within a remote process we

547
00:20:40,480 --> 00:20:42,960
can simply identify an existing remote

548
00:20:42,960 --> 00:20:44,000
thread

549
00:20:44,000 --> 00:20:45,600
suspend it

550
00:20:45,600 --> 00:20:48,080
update that thread somehow to force it

551
00:20:48,080 --> 00:20:50,320
to execute our shell code and then

552
00:20:50,320 --> 00:20:52,080
resume the thread

553
00:20:52,080 --> 00:20:54,159
i released a blog that has more

554
00:20:54,159 --> 00:20:57,280
comprehensive technical details on this

555
00:20:57,280 --> 00:20:59,840
ttp that can be found here

556
00:20:59,840 --> 00:21:01,919
we'll go over at a technical level

557
00:21:01,919 --> 00:21:04,320
everything but not as in-depth as this

558
00:21:04,320 --> 00:21:06,799
blog due to time

559
00:21:06,799 --> 00:21:09,918
for time's sake

560
00:21:10,320 --> 00:21:11,120
so

561
00:21:11,120 --> 00:21:13,360
the first thing we need to do is

562
00:21:13,360 --> 00:21:15,840
target a remote process so what process

563
00:21:15,840 --> 00:21:18,400
would we like to inject into

564
00:21:18,400 --> 00:21:20,320
for our purposes

565
00:21:20,320 --> 00:21:21,840
this can be anything

566
00:21:21,840 --> 00:21:23,280
but what you need to do once you've

567
00:21:23,280 --> 00:21:25,520
targeted this process is open what's

568
00:21:25,520 --> 00:21:27,200
known as a handle to it so a handle

569
00:21:27,200 --> 00:21:29,600
basically is a kernel mode object

570
00:21:29,600 --> 00:21:32,000
that allows one process to

571
00:21:32,000 --> 00:21:33,520
intermediately

572
00:21:33,520 --> 00:21:35,679
interact with another process

573
00:21:35,679 --> 00:21:37,840
that's very simplified but for our

574
00:21:37,840 --> 00:21:40,400
purposes since a handle is an object in

575
00:21:40,400 --> 00:21:42,960
kernel mode we can't directly or yeah

576
00:21:42,960 --> 00:21:46,640
since um excuse me let me rephrase

577
00:21:46,640 --> 00:21:48,000
since

578
00:21:48,000 --> 00:21:48,880
uh

579
00:21:48,880 --> 00:21:51,280
processes are kernel mode objects we

580
00:21:51,280 --> 00:21:54,000
cannot just directly access them

581
00:21:54,000 --> 00:21:57,600
so what we do is we need some kind of um

582
00:21:57,600 --> 00:22:00,400
intermediary way to interact with that

583
00:22:00,400 --> 00:22:02,400
process and we do this through a handle

584
00:22:02,400 --> 00:22:04,720
since it's a kernel mode object we can't

585
00:22:04,720 --> 00:22:06,240
directly just start interacting with

586
00:22:06,240 --> 00:22:08,080
other processes this is the way that we

587
00:22:08,080 --> 00:22:11,199
need to do it on windows

588
00:22:11,440 --> 00:22:13,840
so once we have the ability to interact

589
00:22:13,840 --> 00:22:16,559
with that process through a

590
00:22:16,559 --> 00:22:17,840
handle

591
00:22:17,840 --> 00:22:20,000
what we like to do is call a few windows

592
00:22:20,000 --> 00:22:22,320
apis and the screenshots here

593
00:22:22,320 --> 00:22:24,159
that basically will loop through the

594
00:22:24,159 --> 00:22:25,360
threads

595
00:22:25,360 --> 00:22:27,600
um on the

596
00:22:27,600 --> 00:22:30,960
system and break upon encountering a

597
00:22:30,960 --> 00:22:33,679
thread of the first thread determined

598
00:22:33,679 --> 00:22:35,120
within the remote process we're

599
00:22:35,120 --> 00:22:37,360
targeting

600
00:22:37,360 --> 00:22:39,200
and then once we've identified the

601
00:22:39,200 --> 00:22:41,200
thread that exists within the remote

602
00:22:41,200 --> 00:22:43,440
process that we want to hijack what we

603
00:22:43,440 --> 00:22:44,960
need to do is put the thread in a

604
00:22:44,960 --> 00:22:48,159
suspended state this is required for

605
00:22:48,159 --> 00:22:50,000
modifying threads they need to be

606
00:22:50,000 --> 00:22:53,039
suspended generally speaking first

607
00:22:53,039 --> 00:22:54,799
and these are the windows apis that we

608
00:22:54,799 --> 00:22:56,480
do it we first actually need to open a

609
00:22:56,480 --> 00:22:59,200
handle to this thread and then once we

610
00:22:59,200 --> 00:23:02,640
do we can suspend it

611
00:23:02,720 --> 00:23:05,360
so at the current point we have a remote

612
00:23:05,360 --> 00:23:07,840
process that we've targeted and we have

613
00:23:07,840 --> 00:23:10,480
a thread within that process that we've

614
00:23:10,480 --> 00:23:12,480
suspended and we have a way to interact

615
00:23:12,480 --> 00:23:14,720
with that process and interact with this

616
00:23:14,720 --> 00:23:16,559
thread

617
00:23:16,559 --> 00:23:18,400
so a thread is also an object that's

618
00:23:18,400 --> 00:23:21,280
managed by the kernel and it has an

619
00:23:21,280 --> 00:23:23,679
associated context

620
00:23:23,679 --> 00:23:26,320
and basically a threat's context is a

621
00:23:26,320 --> 00:23:28,960
representation of execution at the time

622
00:23:28,960 --> 00:23:30,880
the thread was executing uh this is

623
00:23:30,880 --> 00:23:33,360
represented through cpu registers that

624
00:23:33,360 --> 00:23:36,640
the thread uses for execution

625
00:23:36,640 --> 00:23:39,840
recall each thread gets its own stack

626
00:23:39,840 --> 00:23:43,120
and this context is represented by a

627
00:23:43,120 --> 00:23:46,879
context structure on

628
00:23:48,840 --> 00:23:51,200
windows so as we can see from the

629
00:23:51,200 --> 00:23:52,640
screenshot here

630
00:23:52,640 --> 00:23:54,799
this is a context structure on windows

631
00:23:54,799 --> 00:23:57,760
it's a bit truncated um but as we can

632
00:23:57,760 --> 00:23:59,840
see these are the various cpu registers

633
00:23:59,840 --> 00:24:02,400
that we are probably all familiar with

634
00:24:02,400 --> 00:24:04,159
we can see the stack pointer the

635
00:24:04,159 --> 00:24:06,080
instruction pointer

636
00:24:06,080 --> 00:24:07,760
and the various other things like the

637
00:24:07,760 --> 00:24:11,039
accumulator etc

638
00:24:14,159 --> 00:24:16,880
so we know that a thread has an

639
00:24:16,880 --> 00:24:19,840
associated context that represents all

640
00:24:19,840 --> 00:24:22,080
of its cpu registers

641
00:24:22,080 --> 00:24:23,760
we have a way to interact with the

642
00:24:23,760 --> 00:24:26,080
desired thread so we can actually do is

643
00:24:26,080 --> 00:24:28,080
call another windows api called get

644
00:24:28,080 --> 00:24:30,159
thread context which will actually

645
00:24:30,159 --> 00:24:33,200
retrieve an associated context structure

646
00:24:33,200 --> 00:24:35,200
for a given thread

647
00:24:35,200 --> 00:24:37,200
so what we can do here is actually get

648
00:24:37,200 --> 00:24:39,919
the context of the thread we would like

649
00:24:39,919 --> 00:24:42,880
to later hijack

650
00:24:43,919 --> 00:24:46,720
and just a little spiel on windows

651
00:24:46,720 --> 00:24:48,720
memory so

652
00:24:48,720 --> 00:24:51,600
the address space on windows systems

653
00:24:51,600 --> 00:24:54,640
is private on a per process basis so

654
00:24:54,640 --> 00:24:56,559
each process essentially has its own

655
00:24:56,559 --> 00:24:58,880
private mapped view of memory

656
00:24:58,880 --> 00:25:00,799
and if you want to take this further you

657
00:25:00,799 --> 00:25:02,880
can open up a kernel mode debugging

658
00:25:02,880 --> 00:25:05,919
session and change the value of the cr3

659
00:25:05,919 --> 00:25:07,760
register which contains basically the

660
00:25:07,760 --> 00:25:09,039
base

661
00:25:09,039 --> 00:25:11,039
memory paging structure in order to

662
00:25:11,039 --> 00:25:13,440
investigate this more

663
00:25:13,440 --> 00:25:15,440
but with this in mind

664
00:25:15,440 --> 00:25:18,000
we know that each process has it has its

665
00:25:18,000 --> 00:25:19,919
own privately mapped view of memory so

666
00:25:19,919 --> 00:25:22,720
if we have a given payload

667
00:25:22,720 --> 00:25:25,039
if it's stored within the local process

668
00:25:25,039 --> 00:25:27,120
the remote process is not going to be

669
00:25:27,120 --> 00:25:28,799
able to see that which is our target

670
00:25:28,799 --> 00:25:31,120
process we want to execute in

671
00:25:31,120 --> 00:25:34,159
so the first step is once we've actually

672
00:25:34,159 --> 00:25:36,320
gained the once we've actually captured

673
00:25:36,320 --> 00:25:38,799
the context of our thread is actually to

674
00:25:38,799 --> 00:25:42,000
inject the remote blob which in our case

675
00:25:42,000 --> 00:25:44,480
is a cobalt strike stageless shell code

676
00:25:44,480 --> 00:25:46,720
blob we want to place that in the remote

677
00:25:46,720 --> 00:25:49,039
process we're not executing it we're

678
00:25:49,039 --> 00:25:51,279
just placing it in the remote process

679
00:25:51,279 --> 00:25:54,400
for future use

680
00:25:55,039 --> 00:25:56,960
and the way we do this again

681
00:25:56,960 --> 00:25:58,720
everyone has seen these um function

682
00:25:58,720 --> 00:26:00,880
calls before you have virtual x and

683
00:26:00,880 --> 00:26:03,200
write process memory and again as i've

684
00:26:03,200 --> 00:26:06,400
been reiterating this can be changed

685
00:26:06,400 --> 00:26:08,159
these can be updated these can be

686
00:26:08,159 --> 00:26:10,559
improved how we actually call these

687
00:26:10,559 --> 00:26:12,960
functions

688
00:26:13,760 --> 00:26:15,679
so once the payload is actually stored

689
00:26:15,679 --> 00:26:18,159
in the remote process

690
00:26:18,159 --> 00:26:21,279
the goal is to eventually execute this

691
00:26:21,279 --> 00:26:22,320
payload

692
00:26:22,320 --> 00:26:24,159
so what we want to do is we want to

693
00:26:24,159 --> 00:26:27,679
inject a huge not necessarily huge it

694
00:26:27,679 --> 00:26:29,520
will be big but the goal is not for it

695
00:26:29,520 --> 00:26:30,880
to be big

696
00:26:30,880 --> 00:26:33,679
what we want to do is inject a fo a

697
00:26:33,679 --> 00:26:35,520
first staged

698
00:26:35,520 --> 00:26:37,760
show code essentially that will call

699
00:26:37,760 --> 00:26:40,480
create thread in context of the remote

700
00:26:40,480 --> 00:26:42,000
process

701
00:26:42,000 --> 00:26:43,039
um

702
00:26:43,039 --> 00:26:44,320
this is because

703
00:26:44,320 --> 00:26:47,200
the the cobalt strike beacon a payload

704
00:26:47,200 --> 00:26:49,120
for our purposes this could be any

705
00:26:49,120 --> 00:26:51,200
payload we want it to live within its

706
00:26:51,200 --> 00:26:54,159
own thread and the way we do that is by

707
00:26:54,159 --> 00:26:57,840
using a call to create thread

708
00:26:58,080 --> 00:27:00,000
like i mentioned earlier local injection

709
00:27:00,000 --> 00:27:02,400
is much less scrutinized than remote

710
00:27:02,400 --> 00:27:03,919
injection and it's a bit harder to

711
00:27:03,919 --> 00:27:06,919
detect

712
00:27:07,039 --> 00:27:09,200
excuse me

713
00:27:09,200 --> 00:27:11,440
and because of that we want

714
00:27:11,440 --> 00:27:14,480
the api call to happen in the remote

715
00:27:14,480 --> 00:27:18,080
process to create a local thread in

716
00:27:18,080 --> 00:27:21,440
context of the remote process

717
00:27:21,440 --> 00:27:23,200
so the way we do this is actually at the

718
00:27:23,200 --> 00:27:25,600
assembly level we'll write some custom

719
00:27:25,600 --> 00:27:29,120
op codes basically custom shell code

720
00:27:29,120 --> 00:27:32,640
that will dynamically call create thread

721
00:27:32,640 --> 00:27:35,039
while supplying the beacon payload as

722
00:27:35,039 --> 00:27:39,120
the routine we would like to execute

723
00:27:39,360 --> 00:27:40,960
so the way we do this first is we need

724
00:27:40,960 --> 00:27:42,799
to see how createthread is actually

725
00:27:42,799 --> 00:27:44,480
prototyped

726
00:27:44,480 --> 00:27:47,120
and this can be viewed on the microsoft

727
00:27:47,120 --> 00:27:48,960
through microsoft docs formerly known as

728
00:27:48,960 --> 00:27:51,600
msdn

729
00:27:51,679 --> 00:27:54,000
and we see a bunch of

730
00:27:54,000 --> 00:27:56,799
parameters that this function expects

731
00:27:56,799 --> 00:27:58,640
the main one we want to focus on is this

732
00:27:58,640 --> 00:28:00,480
lp thread start routine which is a

733
00:28:00,480 --> 00:28:02,799
pointer to a function that's to be

734
00:28:02,799 --> 00:28:04,640
queued for execution when the thread is

735
00:28:04,640 --> 00:28:07,120
created

736
00:28:08,720 --> 00:28:10,880
and again for our purposes we are

737
00:28:10,880 --> 00:28:14,960
assuming a 64-bit system

738
00:28:15,120 --> 00:28:17,279
and with the 64-bit system we then

739
00:28:17,279 --> 00:28:20,000
assume a what's known as the fast call

740
00:28:20,000 --> 00:28:22,880
call-in convention on on windows

741
00:28:22,880 --> 00:28:25,679
um so the first four arguments

742
00:28:25,679 --> 00:28:27,679
for a given function that's called

743
00:28:27,679 --> 00:28:29,760
through this calling convention

744
00:28:29,760 --> 00:28:31,679
for our purposes are passed through

745
00:28:31,679 --> 00:28:37,279
these registers rcx rdx r8 and r9

746
00:28:37,279 --> 00:28:39,919
every argument after that is passed

747
00:28:39,919 --> 00:28:41,279
through the stack

748
00:28:41,279 --> 00:28:43,679
similarly to standard call which uses a

749
00:28:43,679 --> 00:28:46,000
stack for passing arguments

750
00:28:46,000 --> 00:28:48,240
but we start at an offset of 20 on the

751
00:28:48,240 --> 00:28:52,960
stack and then every 8 bytes afterwards

752
00:28:56,000 --> 00:28:58,080
so knowing the calling convention here

753
00:28:58,080 --> 00:29:00,000
is how we would need to set up our call

754
00:29:00,000 --> 00:29:01,520
to create thread

755
00:29:01,520 --> 00:29:03,360
these are the various parameters that it

756
00:29:03,360 --> 00:29:05,760
expects and these are the registers we

757
00:29:05,760 --> 00:29:09,200
use to pass the arguments

758
00:29:11,120 --> 00:29:14,000
so what we do is we create a shell code

759
00:29:14,000 --> 00:29:15,120
routine

760
00:29:15,120 --> 00:29:17,520
in this case it's called create thread

761
00:29:17,520 --> 00:29:18,399
um

762
00:29:18,399 --> 00:29:20,720
and what we also do is

763
00:29:20,720 --> 00:29:23,760
we perform a typecast on the previously

764
00:29:23,760 --> 00:29:25,600
allocated region of memory we use with

765
00:29:25,600 --> 00:29:28,799
virtualic x in order to cast it to an lp

766
00:29:28,799 --> 00:29:31,200
thread start routine

767
00:29:31,200 --> 00:29:34,320
and so that begins the process

768
00:29:34,320 --> 00:29:35,919
i included this

769
00:29:35,919 --> 00:29:39,200
slide for the purposes of the

770
00:29:39,200 --> 00:29:41,760
engaged viewer or reader

771
00:29:41,760 --> 00:29:43,600
i'm not going to go through this

772
00:29:43,600 --> 00:29:45,039
verbatim

773
00:29:45,039 --> 00:29:47,120
it's here and it's heavily commented and

774
00:29:47,120 --> 00:29:48,799
it's also available on my github if you

775
00:29:48,799 --> 00:29:51,279
would like to look at it

776
00:29:51,279 --> 00:29:52,960
but just at a high level as we can see

777
00:29:52,960 --> 00:29:54,720
through the comments we start with the

778
00:29:54,720 --> 00:29:57,760
rcx register and we work our way down in

779
00:29:57,760 --> 00:30:00,159
order to satisfy all of the function

780
00:30:00,159 --> 00:30:02,960
calls through custom op codes

781
00:30:02,960 --> 00:30:05,120
so when this would be executed it would

782
00:30:05,120 --> 00:30:07,840
call create thread at the assembly level

783
00:30:07,840 --> 00:30:11,520
within the remote process

784
00:30:12,720 --> 00:30:15,520
so now we have a piece of shell code

785
00:30:15,520 --> 00:30:18,320
that when executed in context of the

786
00:30:18,320 --> 00:30:19,840
remote process

787
00:30:19,840 --> 00:30:22,880
will spawn a local thread that houses

788
00:30:22,880 --> 00:30:25,760
the beacon implant

789
00:30:25,760 --> 00:30:27,520
knowing this though

790
00:30:27,520 --> 00:30:30,080
in order to execute the code what we

791
00:30:30,080 --> 00:30:32,399
actually need to do is perform the

792
00:30:32,399 --> 00:30:34,240
thread hijacking to kick off this

793
00:30:34,240 --> 00:30:37,279
execution right and the thread hijacking

794
00:30:37,279 --> 00:30:39,760
is going to rely on corrupting that

795
00:30:39,760 --> 00:30:43,440
previously captured context structure

796
00:30:43,440 --> 00:30:45,679
because we will be manipulating it and

797
00:30:45,679 --> 00:30:47,840
when the when the shell code is actually

798
00:30:47,840 --> 00:30:50,880
executed the state of the cp registers

799
00:30:50,880 --> 00:30:51,919
will

800
00:30:51,919 --> 00:30:54,960
be basically foreign um at that point

801
00:30:54,960 --> 00:30:58,000
and um it will cause a crash of our

802
00:30:58,000 --> 00:31:00,320
thread um because we're we're

803
00:31:00,320 --> 00:31:02,399
invalidating the integrity of that

804
00:31:02,399 --> 00:31:05,600
contact structure and the cpu registers

805
00:31:05,600 --> 00:31:08,799
will be haywired essentially and when

806
00:31:08,799 --> 00:31:10,640
that thread crashes in all likelihood

807
00:31:10,640 --> 00:31:12,159
it's going to cause

808
00:31:12,159 --> 00:31:14,640
the process housing that thread to also

809
00:31:14,640 --> 00:31:15,600
crash

810
00:31:15,600 --> 00:31:18,159
so what we need to do is we need to bake

811
00:31:18,159 --> 00:31:20,159
in a routine

812
00:31:20,159 --> 00:31:22,799
that's appended to the shell code that

813
00:31:22,799 --> 00:31:25,519
calls createthread that will handle this

814
00:31:25,519 --> 00:31:29,039
and will resume execution

815
00:31:29,039 --> 00:31:31,039
so there is a beautiful function on

816
00:31:31,039 --> 00:31:33,919
windows known as nt continue

817
00:31:33,919 --> 00:31:36,159
and it's used to resume execution after

818
00:31:36,159 --> 00:31:38,399
an exception and

819
00:31:38,399 --> 00:31:40,559
knowing this we can actually use this

820
00:31:40,559 --> 00:31:42,000
functionality

821
00:31:42,000 --> 00:31:46,240
to resume execution automatically

822
00:31:46,240 --> 00:31:49,440
so with nt continue um

823
00:31:49,440 --> 00:31:51,120
we need to

824
00:31:51,120 --> 00:31:53,840
pass it a context structure of

825
00:31:53,840 --> 00:31:56,000
essentially the context we would like a

826
00:31:56,000 --> 00:31:58,840
given thread to resume

827
00:31:58,840 --> 00:32:01,519
right so this

828
00:32:01,519 --> 00:32:04,880
con this nt continue call will happen in

829
00:32:04,880 --> 00:32:08,320
context of being executed by this remote

830
00:32:08,320 --> 00:32:09,200
thread

831
00:32:09,200 --> 00:32:11,360
so this is all very confusing and it

832
00:32:11,360 --> 00:32:13,840
will make more more sense in the future

833
00:32:13,840 --> 00:32:15,919
but essentially if we think about it

834
00:32:15,919 --> 00:32:18,240
hard enough we're taking a remote thread

835
00:32:18,240 --> 00:32:20,159
that we've enumerated within the remote

836
00:32:20,159 --> 00:32:21,840
process

837
00:32:21,840 --> 00:32:24,399
we're corrupting that context structure

838
00:32:24,399 --> 00:32:27,919
in order to point it to our custom shell

839
00:32:27,919 --> 00:32:28,960
code

840
00:32:28,960 --> 00:32:30,080
so this

841
00:32:30,080 --> 00:32:32,799
uh shell code is actually being executed

842
00:32:32,799 --> 00:32:35,440
from the remote thread it just was not

843
00:32:35,440 --> 00:32:39,120
remotely spawned um but artificially by

844
00:32:39,120 --> 00:32:39,840
us

845
00:32:39,840 --> 00:32:42,240
so knowing this if we can make a call to

846
00:32:42,240 --> 00:32:43,840
nt continue

847
00:32:43,840 --> 00:32:46,240
which will resume the calling thread

848
00:32:46,240 --> 00:32:48,480
essentially this is actually the remote

849
00:32:48,480 --> 00:32:50,559
process the remote thread that we

850
00:32:50,559 --> 00:32:53,039
hijacked earlier right

851
00:32:53,039 --> 00:32:56,480
so knowing this nt continue accepts a

852
00:32:56,480 --> 00:32:59,760
pointer to a context structure

853
00:32:59,760 --> 00:33:02,159
that is to be resumed by the calling

854
00:33:02,159 --> 00:33:03,039
thread

855
00:33:03,039 --> 00:33:05,279
so basically nt continue is going to say

856
00:33:05,279 --> 00:33:06,159
hey

857
00:33:06,159 --> 00:33:07,200
thread

858
00:33:07,200 --> 00:33:08,720
i see that you're passing in this

859
00:33:08,720 --> 00:33:10,799
context structure i know that's how you

860
00:33:10,799 --> 00:33:12,880
would like to be resumed let's go ahead

861
00:33:12,880 --> 00:33:15,039
and update that for you

862
00:33:15,039 --> 00:33:16,480
and this is going to happen after the

863
00:33:16,480 --> 00:33:18,720
call to create thread

864
00:33:18,720 --> 00:33:21,440
so remember again the address space on

865
00:33:21,440 --> 00:33:23,200
windows is private

866
00:33:23,200 --> 00:33:25,919
so from our quote unquote exploiting

867
00:33:25,919 --> 00:33:28,399
process that we're performing this

868
00:33:28,399 --> 00:33:30,080
capability through

869
00:33:30,080 --> 00:33:33,039
that address space is diff it's the same

870
00:33:33,039 --> 00:33:35,360
essentially in terms of what's map so

871
00:33:35,360 --> 00:33:38,320
ntdlo kernel 32 etc but it has its own

872
00:33:38,320 --> 00:33:40,880
privately mapped view of that memory

873
00:33:40,880 --> 00:33:42,720
so the contact structure right now is

874
00:33:42,720 --> 00:33:44,960
within our current process the

875
00:33:44,960 --> 00:33:46,799
quote-unquote exploiting process that's

876
00:33:46,799 --> 00:33:48,880
where that contact structure lives

877
00:33:48,880 --> 00:33:51,279
so since the address space is private we

878
00:33:51,279 --> 00:33:54,320
need to first inject it into that remote

879
00:33:54,320 --> 00:33:55,519
process

880
00:33:55,519 --> 00:33:59,200
so the the remote process has a way to

881
00:33:59,200 --> 00:34:01,600
pass the pointer to that structure to

882
00:34:01,600 --> 00:34:04,240
resume execution

883
00:34:04,240 --> 00:34:07,440
so after that long-winded uh explanation

884
00:34:07,440 --> 00:34:09,199
the call to nt continue would look like

885
00:34:09,199 --> 00:34:10,879
this at the assembly level in the fast

886
00:34:10,879 --> 00:34:12,639
call calling convention

887
00:34:12,639 --> 00:34:14,719
we passed the context that we would like

888
00:34:14,719 --> 00:34:17,839
to resume and then there's a bull um

889
00:34:17,839 --> 00:34:20,000
that can also be passed here

890
00:34:20,000 --> 00:34:20,960
which

891
00:34:20,960 --> 00:34:22,480
we don't necessarily care about for our

892
00:34:22,480 --> 00:34:26,079
purposes at the current moment

893
00:34:26,480 --> 00:34:28,879
so after we've injected that context

894
00:34:28,879 --> 00:34:30,000
structure

895
00:34:30,000 --> 00:34:32,399
into the remote process

896
00:34:32,399 --> 00:34:34,079
we know that this remote process will

897
00:34:34,079 --> 00:34:36,639
then be executing the the op codes we

898
00:34:36,639 --> 00:34:38,000
see on the screen

899
00:34:38,000 --> 00:34:40,480
um so in the rcx register we locate

900
00:34:40,480 --> 00:34:43,280
where that context uh structure is

901
00:34:43,280 --> 00:34:45,359
we pop it into the rcx register

902
00:34:45,359 --> 00:34:46,879
essentially

903
00:34:46,879 --> 00:34:50,879
and then we set the rdx register to

904
00:34:50,879 --> 00:34:52,960
false by xor

905
00:34:52,960 --> 00:34:55,520
operation

906
00:34:57,040 --> 00:34:59,760
so now we have a way to spawn a local

907
00:34:59,760 --> 00:35:01,839
thread to house the beacon implant and

908
00:35:01,839 --> 00:35:04,000
then we have a cleanup routine after

909
00:35:04,000 --> 00:35:05,440
that

910
00:35:05,440 --> 00:35:07,280
but we also want to make sure that the

911
00:35:07,280 --> 00:35:10,000
stack is first 16 by aligned before we

912
00:35:10,000 --> 00:35:11,920
make any api calls

913
00:35:11,920 --> 00:35:13,520
the reason is this is the fast call

914
00:35:13,520 --> 00:35:15,920
calling connection requires the stack to

915
00:35:15,920 --> 00:35:18,320
be 16 by aligned

916
00:35:18,320 --> 00:35:21,200
and so all we do basically is we prepend

917
00:35:21,200 --> 00:35:22,320
everything

918
00:35:22,320 --> 00:35:25,680
with a bitwise and operation that will

919
00:35:25,680 --> 00:35:28,320
basically make sure the stack is 16 by

920
00:35:28,320 --> 00:35:31,839
aligned and that we're good to go

921
00:35:32,560 --> 00:35:35,280
and so now that we have that long-winded

922
00:35:35,280 --> 00:35:37,760
explanation of the shell code blob we

923
00:35:37,760 --> 00:35:39,440
want to execute within the remote

924
00:35:39,440 --> 00:35:41,440
process the last step is actually to

925
00:35:41,440 --> 00:35:43,839
kick off execution of this

926
00:35:43,839 --> 00:35:45,680
and so what we do is that previously

927
00:35:45,680 --> 00:35:48,320
captured context record this is now

928
00:35:48,320 --> 00:35:51,200
where we corrupt it and we hijack it so

929
00:35:51,200 --> 00:35:53,760
the instruction pointer on windows or

930
00:35:53,760 --> 00:35:56,320
any cpu for that matter is responsible

931
00:35:56,320 --> 00:35:58,880
for the currently executing instruction

932
00:35:58,880 --> 00:36:00,640
so whatever is loaded in the rip

933
00:36:00,640 --> 00:36:02,240
register that's what the program is

934
00:36:02,240 --> 00:36:04,800
going to be executing and so we do is we

935
00:36:04,800 --> 00:36:07,200
take that rip member

936
00:36:07,200 --> 00:36:07,920
the

937
00:36:07,920 --> 00:36:11,119
instruction pointer and we actually

938
00:36:11,119 --> 00:36:13,280
corrupt it in order to force it to point

939
00:36:13,280 --> 00:36:16,880
to our previously allocated shell code

940
00:36:16,880 --> 00:36:20,079
so as i mentioned we inject all of this

941
00:36:20,079 --> 00:36:22,240
capability into the remote process

942
00:36:22,240 --> 00:36:24,000
there's a memory address which

943
00:36:24,000 --> 00:36:26,880
corresponds to this large blob we update

944
00:36:26,880 --> 00:36:30,160
that rip member in order to point it

945
00:36:30,160 --> 00:36:31,280
to

946
00:36:31,280 --> 00:36:34,240
our user specified shell code blob so

947
00:36:34,240 --> 00:36:35,680
what happens is when this thread

948
00:36:35,680 --> 00:36:38,000
actually resumes

949
00:36:38,000 --> 00:36:40,800
the rip member will be pointing to our

950
00:36:40,800 --> 00:36:43,440
shell code and so execution will kick

951
00:36:43,440 --> 00:36:46,720
off to our shell code

952
00:36:47,680 --> 00:36:50,240
um so after updating the hijack thread

953
00:36:50,240 --> 00:36:52,160
we resume the thread as mentioned and

954
00:36:52,160 --> 00:36:54,960
that will spawn our execution

955
00:36:54,960 --> 00:36:57,839
um and so this all sounds very confusing

956
00:36:57,839 --> 00:36:59,440
and this next image may look very

957
00:36:59,440 --> 00:37:01,119
confusing but i'll walk through it uh

958
00:37:01,119 --> 00:37:04,000
what that looks like

959
00:37:05,760 --> 00:37:07,520
so here how here's how this looks in the

960
00:37:07,520 --> 00:37:09,839
debugger

961
00:37:10,079 --> 00:37:13,359
so we first have a stack alignment plus

962
00:37:13,359 --> 00:37:15,119
create thread routine so as we can see

963
00:37:15,119 --> 00:37:17,280
in this first outline box this first

964
00:37:17,280 --> 00:37:19,920
call instruction it calls this memory

965
00:37:19,920 --> 00:37:21,599
address and if we look at what this

966
00:37:21,599 --> 00:37:24,079
memory address shows it has our bitwise

967
00:37:24,079 --> 00:37:26,000
and operation

968
00:37:26,000 --> 00:37:28,960
it has the move r8

969
00:37:28,960 --> 00:37:32,079
instruction which again is that lp start

970
00:37:32,079 --> 00:37:33,520
thread routine

971
00:37:33,520 --> 00:37:35,680
which we want the createthread function

972
00:37:35,680 --> 00:37:37,200
to execute

973
00:37:37,200 --> 00:37:40,640
this is the start of the beacon payload

974
00:37:40,640 --> 00:37:43,280
as we can see in the last screenshot or

975
00:37:43,280 --> 00:37:45,280
in the last box below which is prepended

976
00:37:45,280 --> 00:37:48,240
within no ops

977
00:37:48,240 --> 00:37:51,839
once this executes and the um call

978
00:37:51,839 --> 00:37:53,440
occurs

979
00:37:53,440 --> 00:37:56,480
the next thing that happens is the nt

980
00:37:56,480 --> 00:37:59,200
continue routine is called um so we can

981
00:37:59,200 --> 00:38:04,079
see in the move rax offset uh in the um

982
00:38:04,079 --> 00:38:07,680
uh instructions uh below um the call

983
00:38:07,680 --> 00:38:08,880
that happens

984
00:38:08,880 --> 00:38:11,200
we can see that nt continues being moved

985
00:38:11,200 --> 00:38:13,920
into our ax register and then we call

986
00:38:13,920 --> 00:38:16,839
the rax register and when this call

987
00:38:16,839 --> 00:38:20,000
happens this should resume execution of

988
00:38:20,000 --> 00:38:22,160
the thread and the process should be

989
00:38:22,160 --> 00:38:24,640
usable

990
00:38:25,760 --> 00:38:27,520
so after the components of the thread

991
00:38:27,520 --> 00:38:29,920
hijacking are placed into the remote

992
00:38:29,920 --> 00:38:32,560
process the hijack thread is resumed and

993
00:38:32,560 --> 00:38:34,320
execution kicks off

994
00:38:34,320 --> 00:38:36,720
um we'll take a look at this in the

995
00:38:36,720 --> 00:38:38,240
final demo

996
00:38:38,240 --> 00:38:40,560
at the end of the um presentation but

997
00:38:40,560 --> 00:38:42,640
that's kind of how our remote injection

998
00:38:42,640 --> 00:38:45,440
is performed without actually creating a

999
00:38:45,440 --> 00:38:48,400
new remote thread

1000
00:38:49,359 --> 00:38:51,839
um so how do we automate this all in c

1001
00:38:51,839 --> 00:38:53,760
sharp how do we put all these pieces

1002
00:38:53,760 --> 00:38:57,119
together automatically

1003
00:38:57,119 --> 00:38:59,280
so we have a loader

1004
00:38:59,280 --> 00:39:00,640
a shell code loader that performs a

1005
00:39:00,640 --> 00:39:03,280
remote injection that we just showed in

1006
00:39:03,280 --> 00:39:04,480
the previous

1007
00:39:04,480 --> 00:39:07,760
slides and this is done

1008
00:39:07,760 --> 00:39:09,520
in c sharp

1009
00:39:09,520 --> 00:39:12,320
so for modularity purposes

1010
00:39:12,320 --> 00:39:15,760
we can actually basically templatize um

1011
00:39:15,760 --> 00:39:17,119
the uh

1012
00:39:17,119 --> 00:39:20,720
dot cs file to allow an operator to

1013
00:39:20,720 --> 00:39:23,760
dynamically specify a given process and

1014
00:39:23,760 --> 00:39:25,040
the shell code they would like to

1015
00:39:25,040 --> 00:39:26,320
execute

1016
00:39:26,320 --> 00:39:27,920
so basically in the automation

1017
00:39:27,920 --> 00:39:30,800
executable it would look for the string

1018
00:39:30,800 --> 00:39:33,760
replace one and update it with a user

1019
00:39:33,760 --> 00:39:35,920
specified process and the same with

1020
00:39:35,920 --> 00:39:39,760
replace two that would be um uh replaced

1021
00:39:39,760 --> 00:39:41,520
with the shell code you would like to

1022
00:39:41,520 --> 00:39:43,760
execute which in our case was a beacon

1023
00:39:43,760 --> 00:39:46,240
payload

1024
00:39:47,760 --> 00:39:49,040
as i mentioned in the beginning of the

1025
00:39:49,040 --> 00:39:51,040
talk we want to choose a high level

1026
00:39:51,040 --> 00:39:53,040
language that has some kind of way to

1027
00:39:53,040 --> 00:39:55,520
interact with the mechanism for dropping

1028
00:39:55,520 --> 00:39:58,240
for the dropper in this case we're using

1029
00:39:58,240 --> 00:40:00,480
a microsoft word document so c sharp

1030
00:40:00,480 --> 00:40:03,520
actually exposes a way to

1031
00:40:03,520 --> 00:40:06,160
leverage microsoft interrupt objects to

1032
00:40:06,160 --> 00:40:09,119
interact with the office api

1033
00:40:09,119 --> 00:40:11,200
and so we start all this off basically

1034
00:40:11,200 --> 00:40:13,599
by creating a new instance of word

1035
00:40:13,599 --> 00:40:17,920
within c-sharp that we can interact with

1036
00:40:20,000 --> 00:40:22,400
so as mentioned earlier we have a word

1037
00:40:22,400 --> 00:40:24,800
macro that will perform the local

1038
00:40:24,800 --> 00:40:28,079
injection of the donut generated shell

1039
00:40:28,079 --> 00:40:30,240
code which basically is just a shell

1040
00:40:30,240 --> 00:40:32,240
code representation of our remote

1041
00:40:32,240 --> 00:40:36,240
process injection.net assembly

1042
00:40:36,240 --> 00:40:38,640
but in order to programmatically insert

1043
00:40:38,640 --> 00:40:41,760
a macro into a word document um you have

1044
00:40:41,760 --> 00:40:44,480
to update a registry key

1045
00:40:44,480 --> 00:40:47,680
in order to bypass the protection

1046
00:40:47,680 --> 00:40:49,200
so obviously if you're running this on a

1047
00:40:49,200 --> 00:40:50,800
development machine

1048
00:40:50,800 --> 00:40:53,119
this is definitely okay to do

1049
00:40:53,119 --> 00:40:55,200
because we need some way to

1050
00:40:55,200 --> 00:40:57,119
automate the process of injecting that

1051
00:40:57,119 --> 00:40:59,119
macro into the document so we need to

1052
00:40:59,119 --> 00:41:00,720
basically programmatically edit the

1053
00:41:00,720 --> 00:41:03,200
registry in order to allow pro

1054
00:41:03,200 --> 00:41:07,839
programmatic access to visual basic

1055
00:41:07,920 --> 00:41:10,319
once that's done we can actually create

1056
00:41:10,319 --> 00:41:12,640
the word document

1057
00:41:12,640 --> 00:41:13,440
that's

1058
00:41:13,440 --> 00:41:15,760
and obviously this is needed for us to

1059
00:41:15,760 --> 00:41:17,920
write the macro to

1060
00:41:17,920 --> 00:41:21,440
in a future step so here we can call

1061
00:41:21,440 --> 00:41:24,000
the um some interrupt objects in order

1062
00:41:24,000 --> 00:41:27,839
to actually create the document itself

1063
00:41:29,359 --> 00:41:31,599
so after we've created the document as

1064
00:41:31,599 --> 00:41:34,400
mentioned we first need to convert our c

1065
00:41:34,400 --> 00:41:36,400
sharp loader into shell code through

1066
00:41:36,400 --> 00:41:39,440
donut so we actually automate this

1067
00:41:39,440 --> 00:41:42,240
through sub processes on c sharp and the

1068
00:41:42,240 --> 00:41:46,200
code can be shown below

1069
00:41:48,560 --> 00:41:50,040
so with

1070
00:41:50,040 --> 00:41:52,319
this.net loader that performs the thread

1071
00:41:52,319 --> 00:41:55,119
hijacking capability now in shell code

1072
00:41:55,119 --> 00:41:57,760
we then want to store this blob within

1073
00:41:57,760 --> 00:41:59,440
the word document and as talked about

1074
00:41:59,440 --> 00:42:01,200
throughout this talk we do this through

1075
00:42:01,200 --> 00:42:03,839
the inline shape the alternative text

1076
00:42:03,839 --> 00:42:05,599
word property

1077
00:42:05,599 --> 00:42:08,000
so basically for a proof of concept here

1078
00:42:08,000 --> 00:42:10,160
we're just choosing a random blank image

1079
00:42:10,160 --> 00:42:11,599
from the web

1080
00:42:11,599 --> 00:42:13,920
and then we're updating the alternative

1081
00:42:13,920 --> 00:42:14,880
text

1082
00:42:14,880 --> 00:42:15,839
to

1083
00:42:15,839 --> 00:42:19,200
basically store our base64 encoded donut

1084
00:42:19,200 --> 00:42:20,160
blob

1085
00:42:20,160 --> 00:42:23,520
that we previously created

1086
00:42:25,599 --> 00:42:28,000
so the next step then is to templatize

1087
00:42:28,000 --> 00:42:30,960
our vba macro for local injection so

1088
00:42:30,960 --> 00:42:33,359
this is basically a template that won't

1089
00:42:33,359 --> 00:42:36,160
change it does the same thing base 64

1090
00:42:36,160 --> 00:42:38,800
decodes the shell code blob which was

1091
00:42:38,800 --> 00:42:41,119
which is retrieved from the uh inline

1092
00:42:41,119 --> 00:42:43,920
shape style alternative text property

1093
00:42:43,920 --> 00:42:45,680
and then it performs a local injection

1094
00:42:45,680 --> 00:42:48,160
so basically you take this vba macro you

1095
00:42:48,160 --> 00:42:50,640
would then store it in a text file and

1096
00:42:50,640 --> 00:42:52,640
then in your automation you would

1097
00:42:52,640 --> 00:42:55,119
basically read in this text file and

1098
00:42:55,119 --> 00:42:56,880
store this as a macro within the

1099
00:42:56,880 --> 00:42:58,720
document

1100
00:42:58,720 --> 00:43:00,720
and that's exactly what we do here

1101
00:43:00,720 --> 00:43:03,119
so we we look at this vba underscore

1102
00:43:03,119 --> 00:43:04,880
template.txt

1103
00:43:04,880 --> 00:43:07,839
we basically read in the template

1104
00:43:07,839 --> 00:43:13,240
and we uh inject this into the document

1105
00:43:14,000 --> 00:43:16,720
so this creates a weaponized word

1106
00:43:16,720 --> 00:43:19,040
document um so now that we've gone

1107
00:43:19,040 --> 00:43:21,040
through all the steps if only this was

1108
00:43:21,040 --> 00:43:24,720
available for use already

1109
00:43:25,040 --> 00:43:28,160
um a little cheeky here but uh this is

1110
00:43:28,160 --> 00:43:29,760
available for use through a tool that i

1111
00:43:29,760 --> 00:43:31,280
created called little corporal which is

1112
00:43:31,280 --> 00:43:34,480
a c-sharp automated maldoc generator

1113
00:43:34,480 --> 00:43:36,480
so as mentioned this is a project that i

1114
00:43:36,480 --> 00:43:39,119
wrote that automates everything shown it

1115
00:43:39,119 --> 00:43:41,520
performs thread hijacking via local

1116
00:43:41,520 --> 00:43:43,599
injection of the.net assembly through

1117
00:43:43,599 --> 00:43:44,720
donut

1118
00:43:44,720 --> 00:43:46,800
and it automates the document creation

1119
00:43:46,800 --> 00:43:50,880
and vba macro insertion

1120
00:43:52,480 --> 00:43:54,240
um and it can be found on my github as

1121
00:43:54,240 --> 00:43:56,800
previously shown so here's the help menu

1122
00:43:56,800 --> 00:43:58,720
uh basically all you need is the shell

1123
00:43:58,720 --> 00:44:00,720
code you want to inject into a remote

1124
00:44:00,720 --> 00:44:04,480
process and the name of a target process

1125
00:44:04,480 --> 00:44:08,240
and here's a quick demo on that

1126
00:44:08,240 --> 00:44:11,119
so here is how document generation looks

1127
00:44:11,119 --> 00:44:14,000
uh you specify the shell code and the

1128
00:44:14,000 --> 00:44:15,839
name of the process you'd like to inject

1129
00:44:15,839 --> 00:44:18,000
into and it's as simple as running it

1130
00:44:18,000 --> 00:44:20,800
and a word document then is spit out for

1131
00:44:20,800 --> 00:44:23,800
you

1132
00:44:25,119 --> 00:44:27,280
and then looking at the actual execution

1133
00:44:27,280 --> 00:44:29,119
of this word document we have another

1134
00:44:29,119 --> 00:44:30,400
demo here

1135
00:44:30,400 --> 00:44:32,400
so once the dem once the document is

1136
00:44:32,400 --> 00:44:35,520
created we then open the word doc and we

1137
00:44:35,520 --> 00:44:38,240
can see that our cobalt strike beacon is

1138
00:44:38,240 --> 00:44:40,319
phoning home under the process of

1139
00:44:40,319 --> 00:44:44,240
explorer which we specified

1140
00:44:46,160 --> 00:44:49,319
now re-running this poc to inject into

1141
00:44:49,319 --> 00:44:52,000
notepad.exe to make things very clear we

1142
00:44:52,000 --> 00:44:53,920
can see that we've bypassed the

1143
00:44:53,920 --> 00:44:56,960
detection logic of our sensor so in this

1144
00:44:56,960 --> 00:44:59,560
case notepad is running under the pid

1145
00:44:59,560 --> 00:45:03,680
5392 and in this case our driver prints

1146
00:45:03,680 --> 00:45:04,400
out

1147
00:45:04,400 --> 00:45:06,560
every time remote injection occurs and

1148
00:45:06,560 --> 00:45:08,640
as we can see there are no instances of

1149
00:45:08,640 --> 00:45:11,920
this process id notepad is still running

1150
00:45:11,920 --> 00:45:14,240
and if we look in the next slide

1151
00:45:14,240 --> 00:45:16,640
just for proof of access as good measure

1152
00:45:16,640 --> 00:45:18,720
we can see that we have a beacon phoning

1153
00:45:18,720 --> 00:45:22,640
home with this process id

1154
00:45:23,440 --> 00:45:25,280
so to summarize everything we've talked

1155
00:45:25,280 --> 00:45:27,680
about today you do not have to sacrifice

1156
00:45:27,680 --> 00:45:29,280
custom capabilities in the name of

1157
00:45:29,280 --> 00:45:32,240
automation although it's not the path of

1158
00:45:32,240 --> 00:45:34,560
least resistance in some cases it is

1159
00:45:34,560 --> 00:45:36,319
possible to create your own automation

1160
00:45:36,319 --> 00:45:38,079
um frameworks

1161
00:45:38,079 --> 00:45:40,319
and then to keep those modular with

1162
00:45:40,319 --> 00:45:43,119
those custom capabilities built in

1163
00:45:43,119 --> 00:45:45,680
with a modular approach you can support

1164
00:45:45,680 --> 00:45:48,400
other techniques for shell code loading

1165
00:45:48,400 --> 00:45:49,280
so

1166
00:45:49,280 --> 00:45:51,040
kind of building off of this

1167
00:45:51,040 --> 00:45:52,960
we have a word document that pulls in a

1168
00:45:52,960 --> 00:45:56,160
remote image and stores shell code blob

1169
00:45:56,160 --> 00:45:58,079
within that image through a property

1170
00:45:58,079 --> 00:45:59,599
within word

1171
00:45:59,599 --> 00:46:00,960
so if you're sending out a phishing

1172
00:46:00,960 --> 00:46:02,480
campaign and you want your word document

1173
00:46:02,480 --> 00:46:04,480
to look more believable

1174
00:46:04,480 --> 00:46:07,680
you could host a remote image that is

1175
00:46:07,680 --> 00:46:11,440
well crafted and use that not only as

1176
00:46:11,440 --> 00:46:14,079
the premise for your social engineering

1177
00:46:14,079 --> 00:46:18,000
for the document but it also works in a

1178
00:46:18,000 --> 00:46:21,119
second manner a double whammy in order

1179
00:46:21,119 --> 00:46:22,960
to store your payload and then

1180
00:46:22,960 --> 00:46:25,520
additionally almost a triple whammy

1181
00:46:25,520 --> 00:46:28,480
you could even take that further and

1182
00:46:28,480 --> 00:46:29,440
collect

1183
00:46:29,440 --> 00:46:31,680
phishing statistics if the word document

1184
00:46:31,680 --> 00:46:33,119
itself

1185
00:46:33,119 --> 00:46:35,200
when it pulls down that image because

1186
00:46:35,200 --> 00:46:37,440
it's specified through a url

1187
00:46:37,440 --> 00:46:39,839
if you if you are the one hosting that

1188
00:46:39,839 --> 00:46:41,680
image you could additionally collect

1189
00:46:41,680 --> 00:46:44,400
phishing statistics here

1190
00:46:44,400 --> 00:46:46,720
and as my old manager mike felch once

1191
00:46:46,720 --> 00:46:49,119
said craig creds are king

1192
00:46:49,119 --> 00:46:50,720
i myself say

1193
00:46:50,720 --> 00:46:52,640
data is also king

1194
00:46:52,640 --> 00:46:55,040
so if we can understand how telemetry is

1195
00:46:55,040 --> 00:46:57,760
actually gathered by a sensor this is

1196
00:46:57,760 --> 00:47:00,240
more useful to a red team for evasion

1197
00:47:00,240 --> 00:47:02,480
purposes in the long run versus your

1198
00:47:02,480 --> 00:47:05,520
more quote-unquote conjecture bypasses

1199
00:47:05,520 --> 00:47:08,240
so these conjecture bypasses

1200
00:47:08,240 --> 00:47:10,480
they may be something like adding a null

1201
00:47:10,480 --> 00:47:13,119
byte on the end to of an exe to bypass

1202
00:47:13,119 --> 00:47:14,480
some signature

1203
00:47:14,480 --> 00:47:17,040
um or some other action where you don't

1204
00:47:17,040 --> 00:47:18,560
necessarily have

1205
00:47:18,560 --> 00:47:21,920
the um data to prove what you're what

1206
00:47:21,920 --> 00:47:23,520
what you're bypassing you're just kind

1207
00:47:23,520 --> 00:47:24,480
of

1208
00:47:24,480 --> 00:47:26,480
shooting in the dark almost

1209
00:47:26,480 --> 00:47:28,480
these may evade some of the more fine

1210
00:47:28,480 --> 00:47:30,000
grain detection logic that's very

1211
00:47:30,000 --> 00:47:31,200
specific

1212
00:47:31,200 --> 00:47:33,280
but don't expect this to evade your

1213
00:47:33,280 --> 00:47:35,440
baseline conditions or telemetry source

1214
00:47:35,440 --> 00:47:37,359
in general

1215
00:47:37,359 --> 00:47:38,800
and then with that i would like to just

1216
00:47:38,800 --> 00:47:40,160
say thank you

1217
00:47:40,160 --> 00:47:42,640
um and i am very happy to answer any

1218
00:47:42,640 --> 00:47:46,640
further questions thank you

