1
00:00:04,480 --> 00:00:07,200
why the options pattern is great for

2
00:00:07,200 --> 00:00:09,839
security

3
00:00:09,920 --> 00:00:11,040
hello

4
00:00:11,040 --> 00:00:13,200
my name is dima kotek

5
00:00:13,200 --> 00:00:15,120
i'm an application security engineer at

6
00:00:15,120 --> 00:00:16,480
security journey

7
00:00:16,480 --> 00:00:18,560
we provide training for developers by

8
00:00:18,560 --> 00:00:20,560
developers for all matters

9
00:00:20,560 --> 00:00:23,680
related to security

10
00:00:24,000 --> 00:00:25,760
the goals of our presentation are the

11
00:00:25,760 --> 00:00:27,199
following

12
00:00:27,199 --> 00:00:29,119
we will review the options pattern for

13
00:00:29,119 --> 00:00:31,920
complex object initialization

14
00:00:31,920 --> 00:00:33,520
we will discover the types of

15
00:00:33,520 --> 00:00:36,399
vulnerabilities it can prevent

16
00:00:36,399 --> 00:00:37,920
we will try to improve the classic

17
00:00:37,920 --> 00:00:40,559
paradigm to maximize security

18
00:00:40,559 --> 00:00:42,559
and finally i hope this talk inspires

19
00:00:42,559 --> 00:00:46,160
you to adopt the pattern when it fits

20
00:00:46,160 --> 00:00:48,719
the examples will be provided in golang

21
00:00:48,719 --> 00:00:50,640
because i like it very much and they fit

22
00:00:50,640 --> 00:00:54,079
very nicely on slides

23
00:00:54,079 --> 00:00:56,079
well let's get started first by defining

24
00:00:56,079 --> 00:00:58,160
the problem and the problem we have this

25
00:00:58,160 --> 00:01:02,079
year is the o wasp top 10 number six

26
00:01:02,079 --> 00:01:05,680
security misconfiguration

27
00:01:06,000 --> 00:01:08,320
it doesn't matter how well your

28
00:01:08,320 --> 00:01:10,159
application is protected

29
00:01:10,159 --> 00:01:11,840
by static code analysis enemy code

30
00:01:11,840 --> 00:01:12,880
analysis

31
00:01:12,880 --> 00:01:15,759
firewalls all sorts of great tools if it

32
00:01:15,759 --> 00:01:19,200
is insecurely misconfigured

33
00:01:19,200 --> 00:01:21,200
so many services in production right now

34
00:01:21,200 --> 00:01:23,040
are securely misconfigured and are

35
00:01:23,040 --> 00:01:24,840
attacked and exploited

36
00:01:24,840 --> 00:01:26,799
easily

37
00:01:26,799 --> 00:01:28,640
attackers love

38
00:01:28,640 --> 00:01:30,560
different types of misconfiguration

39
00:01:30,560 --> 00:01:35,280
notably for example a hamstrung cipher

40
00:01:35,840 --> 00:01:37,200
you can provide

41
00:01:37,200 --> 00:01:39,840
a weak source of random for your crypto

42
00:01:39,840 --> 00:01:42,399
a weak algorithm a weak key length or a

43
00:01:42,399 --> 00:01:45,200
set of parameters that makes the cipher

44
00:01:45,200 --> 00:01:46,880
unusable

45
00:01:46,880 --> 00:01:48,479
it is also common to see services

46
00:01:48,479 --> 00:01:49,360
shipped

47
00:01:49,360 --> 00:01:51,759
with missing access controls

48
00:01:51,759 --> 00:01:53,680
something that was supposed to be not

49
00:01:53,680 --> 00:01:54,720
accessible

50
00:01:54,720 --> 00:01:56,479
protected by credentials

51
00:01:56,479 --> 00:01:58,320
was shipped without

52
00:01:58,320 --> 00:02:01,680
and of course debug backdoors

53
00:02:01,680 --> 00:02:04,079
to get our services running well we need

54
00:02:04,079 --> 00:02:05,600
instrumentation we need additional

55
00:02:05,600 --> 00:02:08,800
facility and observability to find out

56
00:02:08,800 --> 00:02:10,318
what's wrong

57
00:02:10,318 --> 00:02:12,879
so many of our services are running with

58
00:02:12,879 --> 00:02:15,680
those additional observability helpers

59
00:02:15,680 --> 00:02:17,920
and back doors in production

60
00:02:17,920 --> 00:02:20,879
and when attacker discovers

61
00:02:20,879 --> 00:02:22,959
backdoor especially if it's using a weak

62
00:02:22,959 --> 00:02:24,480
or default password

63
00:02:24,480 --> 00:02:26,400
it is for them like candy

64
00:02:26,400 --> 00:02:29,280
easy to take

65
00:02:29,280 --> 00:02:31,040
the difficulty with security

66
00:02:31,040 --> 00:02:32,959
misconfiguration is that two common

67
00:02:32,959 --> 00:02:35,280
pieces of advice on the street are not

68
00:02:35,280 --> 00:02:36,640
super helpful

69
00:02:36,640 --> 00:02:38,160
the first one is of course we're called

70
00:02:38,160 --> 00:02:40,879
to stop misconfiguring services and yes

71
00:02:40,879 --> 00:02:42,560
we can try

72
00:02:42,560 --> 00:02:44,640
but with sophistication and with growing

73
00:02:44,640 --> 00:02:46,319
complexity of our networks and

74
00:02:46,319 --> 00:02:48,840
applications it's very difficult to keep

75
00:02:48,840 --> 00:02:52,080
up the second one is to use an analysis

76
00:02:52,080 --> 00:02:53,760
tool a static or dynamic analysis tool

77
00:02:53,760 --> 00:02:56,239
that can detect ms configuration problem

78
00:02:56,239 --> 00:02:58,959
and that's good and helpful however the

79
00:02:58,959 --> 00:03:01,200
cost of discovery

80
00:03:01,200 --> 00:03:03,840
of a misconfiguration problem is great

81
00:03:03,840 --> 00:03:05,840
and the static analysis tool cannot

82
00:03:05,840 --> 00:03:07,599
detect it unless it has seen somewhere

83
00:03:07,599 --> 00:03:10,640
else in the wild do you want to risk it

84
00:03:10,640 --> 00:03:13,280
the real question is can we do something

85
00:03:13,280 --> 00:03:15,040
on the engineering side

86
00:03:15,040 --> 00:03:17,599
to make our application resistant

87
00:03:17,599 --> 00:03:19,599
to misconfiguration

88
00:03:19,599 --> 00:03:21,120
and yes we can

89
00:03:21,120 --> 00:03:23,440
enter the options pattern the options

90
00:03:23,440 --> 00:03:25,120
pattern is a flexible object

91
00:03:25,120 --> 00:03:27,280
provisioning strategy using a list of

92
00:03:27,280 --> 00:03:29,360
independent object modifiers

93
00:03:29,360 --> 00:03:30,840
those are typically

94
00:03:30,840 --> 00:03:33,360
functions imagine your application is an

95
00:03:33,360 --> 00:03:34,239
engine

96
00:03:34,239 --> 00:03:36,720
and you will have a list of tweaks

97
00:03:36,720 --> 00:03:39,120
applied sequentially to your engine each

98
00:03:39,120 --> 00:03:41,840
one helping with one or two parameters

99
00:03:41,840 --> 00:03:43,200
in isolation

100
00:03:43,200 --> 00:03:45,680
to get our engine to get our application

101
00:03:45,680 --> 00:03:48,159
ready to run in production in a secure

102
00:03:48,159 --> 00:03:50,400
way

103
00:03:50,640 --> 00:03:52,799
to demonstrate this let's go back to a

104
00:03:52,799 --> 00:03:56,560
java classic the builder pattern

105
00:03:56,560 --> 00:03:58,319
suppose we need a bank account and we

106
00:03:58,319 --> 00:04:01,920
will call bank account builder a class

107
00:04:01,920 --> 00:04:04,080
that creates a class

108
00:04:04,080 --> 00:04:05,599
and each

109
00:04:05,599 --> 00:04:07,680
step of the builder pattern

110
00:04:07,680 --> 00:04:09,040
uses

111
00:04:09,040 --> 00:04:11,920
a list of options or a list of settings

112
00:04:11,920 --> 00:04:14,159
that are sequentially applied to the

113
00:04:14,159 --> 00:04:16,079
object and then the final build

114
00:04:16,079 --> 00:04:18,560
method returns our bank account

115
00:04:18,560 --> 00:04:20,639
this is very familiar

116
00:04:20,639 --> 00:04:22,160
the options pattern is like an odd

117
00:04:22,160 --> 00:04:23,919
cousin of the builder pattern there's a

118
00:04:23,919 --> 00:04:25,840
lot of superficial similarity but

119
00:04:25,840 --> 00:04:28,639
there's a great difference for security

120
00:04:28,639 --> 00:04:30,240
as we will see

121
00:04:30,240 --> 00:04:32,400
in our second example i'm showing you

122
00:04:32,400 --> 00:04:33,360
how to

123
00:04:33,360 --> 00:04:35,919
apply an options pattern also to

124
00:04:35,919 --> 00:04:37,759
initialize our bank account

125
00:04:37,759 --> 00:04:39,680
and what we do is instead of calling a

126
00:04:39,680 --> 00:04:42,160
string of methods we're passing a list

127
00:04:42,160 --> 00:04:43,600
of options

128
00:04:43,600 --> 00:04:45,360
to our constructor

129
00:04:45,360 --> 00:04:47,040
we're using an option with client with

130
00:04:47,040 --> 00:04:50,240
email and with newsletter preference

131
00:04:50,240 --> 00:04:52,240
on the surface it looks the same very

132
00:04:52,240 --> 00:04:53,840
similar syntax

133
00:04:53,840 --> 00:04:56,400
but again in application it's very

134
00:04:56,400 --> 00:04:57,919
very different and there is one

135
00:04:57,919 --> 00:04:59,919
significant difference but an easy way

136
00:04:59,919 --> 00:05:01,600
to think about it is that a builder

137
00:05:01,600 --> 00:05:04,000
pattern is when an object constructs

138
00:05:04,000 --> 00:05:06,240
another object an options pattern is

139
00:05:06,240 --> 00:05:08,400
when an object is constructed using a

140
00:05:08,400 --> 00:05:12,000
list of functions typically closures

141
00:05:12,000 --> 00:05:13,919
how do we write the option well this is

142
00:05:13,919 --> 00:05:15,840
the classic that i first learned in the

143
00:05:15,840 --> 00:05:17,520
go community

144
00:05:17,520 --> 00:05:19,759
first let's define the option type and

145
00:05:19,759 --> 00:05:21,280
an option type is going to be just a

146
00:05:21,280 --> 00:05:24,639
function which takes the pointer to our

147
00:05:24,639 --> 00:05:26,639
engine to our main thing that we're

148
00:05:26,639 --> 00:05:28,160
trying to configure in this instance is

149
00:05:28,160 --> 00:05:30,479
this the bank account

150
00:05:30,479 --> 00:05:32,160
and we will

151
00:05:32,160 --> 00:05:34,800
then spell out one option and we'll call

152
00:05:34,800 --> 00:05:36,639
it with email it will take a string

153
00:05:36,639 --> 00:05:39,360
email and return an option

154
00:05:39,360 --> 00:05:40,800
you can see the closure here being

155
00:05:40,800 --> 00:05:42,160
returned

156
00:05:42,160 --> 00:05:44,000
and the closure will simply

157
00:05:44,000 --> 00:05:45,120
modify

158
00:05:45,120 --> 00:05:46,800
client email by applying the email

159
00:05:46,800 --> 00:05:48,880
string provided earlier

160
00:05:48,880 --> 00:05:51,280
in golang lowercase letter parameter

161
00:05:51,280 --> 00:05:53,120
means a private parameter

162
00:05:53,120 --> 00:05:54,960
we want to make sure that nobody can

163
00:05:54,960 --> 00:05:57,440
misconfigure our parameters by accessing

164
00:05:57,440 --> 00:06:00,000
them directly without going through the

165
00:06:00,000 --> 00:06:02,160
proper channel through the proper option

166
00:06:02,160 --> 00:06:03,360
so to speak

167
00:06:03,360 --> 00:06:05,680
and so this way we're protecting

168
00:06:05,680 --> 00:06:07,759
our object from the configuration not

169
00:06:07,759 --> 00:06:10,160
just by the wrong setting but also by

170
00:06:10,160 --> 00:06:12,319
bypassing the proper mechanism of

171
00:06:12,319 --> 00:06:15,039
setting so we use private

172
00:06:15,039 --> 00:06:17,520
parameter

173
00:06:17,759 --> 00:06:20,639
how can we improve this classic

174
00:06:20,639 --> 00:06:22,960
we improve it by applying four

175
00:06:22,960 --> 00:06:26,240
categories of correct security failure

176
00:06:26,240 --> 00:06:29,440
to our application we want to fail early

177
00:06:29,440 --> 00:06:31,360
as soon as a problem is detected and of

178
00:06:31,360 --> 00:06:33,280
course object initialization is about as

179
00:06:33,280 --> 00:06:35,840
early as you can fail we want to fail

180
00:06:35,840 --> 00:06:38,400
safely so that the failure is handled

181
00:06:38,400 --> 00:06:40,639
upstream and the program just doesn't

182
00:06:40,639 --> 00:06:43,840
crash with a stack trace we want to fail

183
00:06:43,840 --> 00:06:46,240
explicitly so the cause of the failure

184
00:06:46,240 --> 00:06:48,720
is known right away and of course

185
00:06:48,720 --> 00:06:50,160
singularly

186
00:06:50,160 --> 00:06:51,919
nobody wants to observe a cascade of

187
00:06:51,919 --> 00:06:54,400
failures of five or six failures without

188
00:06:54,400 --> 00:06:56,319
knowing which one is the real cause in

189
00:06:56,319 --> 00:06:58,319
production the cause needs to be

190
00:06:58,319 --> 00:06:59,840
singular

191
00:06:59,840 --> 00:07:02,000
and the truth is if you're serious about

192
00:07:02,000 --> 00:07:03,280
security

193
00:07:03,280 --> 00:07:05,599
insecurely configured services should

194
00:07:05,599 --> 00:07:06,319
not

195
00:07:06,319 --> 00:07:08,560
even start

196
00:07:08,560 --> 00:07:10,400
it is the responsibility of your

197
00:07:10,400 --> 00:07:13,599
application not to start if it was given

198
00:07:13,599 --> 00:07:14,960
wrong settings

199
00:07:14,960 --> 00:07:18,720
weak settings are also a failure state

200
00:07:18,720 --> 00:07:20,400
how can we improve the classic options

201
00:07:20,400 --> 00:07:23,440
pattern to account for this the four

202
00:07:23,440 --> 00:07:25,440
failure states or ideal failure

203
00:07:25,440 --> 00:07:26,560
conditions

204
00:07:26,560 --> 00:07:28,800
we will simply do this by modifying our

205
00:07:28,800 --> 00:07:31,440
signature of our definition there of the

206
00:07:31,440 --> 00:07:33,360
option definition it will still be a

207
00:07:33,360 --> 00:07:36,160
function taking a pointer to the object

208
00:07:36,160 --> 00:07:38,639
being configured by equal return and

209
00:07:38,639 --> 00:07:39,599
error

210
00:07:39,599 --> 00:07:41,280
of course in many languages you may want

211
00:07:41,280 --> 00:07:44,879
to throw an error in go we return errors

212
00:07:44,879 --> 00:07:47,039
this is just a common idiom

213
00:07:47,039 --> 00:07:49,680
in effect it doesn't matter so much

214
00:07:49,680 --> 00:07:51,680
um but that's the that's the best way to

215
00:07:51,680 --> 00:07:53,280
write it and going

216
00:07:53,280 --> 00:07:54,560
so what kind of difference does this

217
00:07:54,560 --> 00:07:56,000
make so

218
00:07:56,000 --> 00:07:58,160
we're having the same option with email

219
00:07:58,160 --> 00:07:59,919
that will take email as a string and

220
00:07:59,919 --> 00:08:01,440
return the closure

221
00:08:01,440 --> 00:08:04,000
but this time we will validate the email

222
00:08:04,000 --> 00:08:05,360
inside the option

223
00:08:05,360 --> 00:08:07,280
and return an error

224
00:08:07,280 --> 00:08:09,680
if there was one detected or throw in

225
00:08:09,680 --> 00:08:11,280
there if you're writing in something

226
00:08:11,280 --> 00:08:13,120
other than go

227
00:08:13,120 --> 00:08:15,599
it is a subtle difference but it makes a

228
00:08:15,599 --> 00:08:17,280
great difference

229
00:08:17,280 --> 00:08:19,680
to apply those options

230
00:08:19,680 --> 00:08:21,919
all we do is we have a constructor let's

231
00:08:21,919 --> 00:08:23,759
call our constructor a new bank account

232
00:08:23,759 --> 00:08:26,080
which will take a list of options and

233
00:08:26,080 --> 00:08:28,160
return a pointer to a bank account and

234
00:08:28,160 --> 00:08:30,800
an error if there was one discovered

235
00:08:30,800 --> 00:08:33,519
we will initialize a blank bank account

236
00:08:33,519 --> 00:08:35,519
and then we will iterate

237
00:08:35,519 --> 00:08:37,200
through every option provided to the

238
00:08:37,200 --> 00:08:38,559
constructor

239
00:08:38,559 --> 00:08:40,958
apply that option to our resulting

240
00:08:40,958 --> 00:08:44,159
object and check if there was an error

241
00:08:44,159 --> 00:08:46,240
if there was one we want to halt the

242
00:08:46,240 --> 00:08:48,240
execution immediately

243
00:08:48,240 --> 00:08:51,440
return nothing for a pointer and also

244
00:08:51,440 --> 00:08:53,200
return wrapped

245
00:08:53,200 --> 00:08:54,880
error which we will mark as

246
00:08:54,880 --> 00:08:56,959
initialization failure so that that can

247
00:08:56,959 --> 00:09:01,040
be aggressively handled upstream

248
00:09:01,519 --> 00:09:03,360
later on in the constructor we will

249
00:09:03,360 --> 00:09:05,760
check if mandatory parameters were set

250
00:09:05,760 --> 00:09:07,839
but we will not validate our object in

251
00:09:07,839 --> 00:09:10,640
the constructor all the validation code

252
00:09:10,640 --> 00:09:14,959
should be moved inside the option

253
00:09:19,200 --> 00:09:21,120
how does this help us

254
00:09:21,120 --> 00:09:23,120
what is the outcome

255
00:09:23,120 --> 00:09:25,120
the option pattern helps us prevent

256
00:09:25,120 --> 00:09:27,680
three categories of problems the first

257
00:09:27,680 --> 00:09:31,200
one is invalid or in secure state

258
00:09:31,200 --> 00:09:33,600
if something is missing something is no

259
00:09:33,600 --> 00:09:35,839
or improperly configured is missing a

260
00:09:35,839 --> 00:09:37,839
port or an address or some kind of

261
00:09:37,839 --> 00:09:40,160
critical setting we want to detect it at

262
00:09:40,160 --> 00:09:42,399
initialization

263
00:09:42,399 --> 00:09:44,160
second we want to detect failures

264
00:09:44,160 --> 00:09:46,160
originating in parameters

265
00:09:46,160 --> 00:09:49,200
sophisticated objects can take behaviors

266
00:09:49,200 --> 00:09:51,360
for parameters

267
00:09:51,360 --> 00:09:52,480
do you know

268
00:09:52,480 --> 00:09:54,560
how those parameters providing behavior

269
00:09:54,560 --> 00:09:57,200
were configured who configured them what

270
00:09:57,200 --> 00:09:59,040
config was used

271
00:09:59,040 --> 00:10:00,560
are they actually

272
00:10:00,560 --> 00:10:02,640
working

273
00:10:02,640 --> 00:10:05,600
the option pattern allows you to examine

274
00:10:05,600 --> 00:10:07,839
a sophisticated parameter that has

275
00:10:07,839 --> 00:10:09,680
behavior or passes behavior to your

276
00:10:09,680 --> 00:10:12,240
object to make sure that it actually is

277
00:10:12,240 --> 00:10:14,880
fully functioning like it's supposed to

278
00:10:14,880 --> 00:10:17,279
and it is properly initialized

279
00:10:17,279 --> 00:10:20,800
and finally conflicting parameters

280
00:10:20,800 --> 00:10:22,480
it is very common for a security

281
00:10:22,480 --> 00:10:24,880
vulnerability to emerge not from one or

282
00:10:24,880 --> 00:10:27,760
two parameters but from interactions

283
00:10:27,760 --> 00:10:29,200
between them

284
00:10:29,200 --> 00:10:31,680
one parameter can undermine or make and

285
00:10:31,680 --> 00:10:32,880
secure

286
00:10:32,880 --> 00:10:35,120
another or the combination of several

287
00:10:35,120 --> 00:10:37,920
can put your program into insecure state

288
00:10:37,920 --> 00:10:39,920
the option pattern can help you detect

289
00:10:39,920 --> 00:10:41,680
those conditions

290
00:10:41,680 --> 00:10:44,480
and cancel the execution before

291
00:10:44,480 --> 00:10:47,680
everything gets out of control

292
00:10:47,680 --> 00:10:49,680
of course i'm saying how great all of

293
00:10:49,680 --> 00:10:52,160
this is but there needs to be some

294
00:10:52,160 --> 00:10:54,320
limits placed on when to use this

295
00:10:54,320 --> 00:10:56,000
there are at least three usage criteria

296
00:10:56,000 --> 00:10:57,360
that you need to look for before you're

297
00:10:57,360 --> 00:10:59,120
using an options pattern typically you

298
00:10:59,120 --> 00:11:02,000
will use it only one time per package

299
00:11:02,000 --> 00:11:03,680
and the package has to be sufficiently

300
00:11:03,680 --> 00:11:06,720
sophisticated to warrant this additional

301
00:11:06,720 --> 00:11:08,480
work

302
00:11:08,480 --> 00:11:10,000
three things to look for first is

303
00:11:10,000 --> 00:11:11,680
flexible behavior

304
00:11:11,680 --> 00:11:14,560
does your initialized object change its

305
00:11:14,560 --> 00:11:18,320
behavior based on settings given to it

306
00:11:18,320 --> 00:11:21,120
for example are you using providers

307
00:11:21,120 --> 00:11:22,240
drivers

308
00:11:22,240 --> 00:11:24,720
caches a networking layer of some sort

309
00:11:24,720 --> 00:11:27,120
or protocol if you are taking those as

310
00:11:27,120 --> 00:11:29,600
parameters an options pattern can really

311
00:11:29,600 --> 00:11:31,760
help you validate them

312
00:11:31,760 --> 00:11:33,760
second if you have some parameters that

313
00:11:33,760 --> 00:11:36,000
are mandatory but not others

314
00:11:36,000 --> 00:11:37,519
the options pattern can really help you

315
00:11:37,519 --> 00:11:38,480
a lot

316
00:11:38,480 --> 00:11:40,880
if all your parameters are mandatory you

317
00:11:40,880 --> 00:11:42,560
may be better off with something more

318
00:11:42,560 --> 00:11:44,000
straightforward

319
00:11:44,000 --> 00:11:45,279
and easy

320
00:11:45,279 --> 00:11:47,200
but when you have some mandatory and

321
00:11:47,200 --> 00:11:49,920
they're not and they can even change

322
00:11:49,920 --> 00:11:51,600
which ones are mandatory depending on

323
00:11:51,600 --> 00:11:53,440
which parameters are provided

324
00:11:53,440 --> 00:11:55,040
the options pattern is much better for

325
00:11:55,040 --> 00:11:57,519
that and finally if you have entangled

326
00:11:57,519 --> 00:11:58,720
parameters

327
00:11:58,720 --> 00:12:00,160
those are a class of conflicting

328
00:12:00,160 --> 00:12:03,200
parameters that affect each other

329
00:12:03,200 --> 00:12:05,440
the options pattern can help you resolve

330
00:12:05,440 --> 00:12:07,519
gracefully at initialization any kind of

331
00:12:07,519 --> 00:12:09,120
entanglement

332
00:12:09,120 --> 00:12:10,959
in such a way that it precludes or

333
00:12:10,959 --> 00:12:13,760
prevents security vulnerabilities

334
00:12:13,760 --> 00:12:16,800
let's look at an example

335
00:12:17,279 --> 00:12:19,760
suppose you have

336
00:12:19,760 --> 00:12:22,079
a hypothetical asset encoder that will

337
00:12:22,079 --> 00:12:23,120
take

338
00:12:23,120 --> 00:12:25,440
a stream of bytes and encode it and we

339
00:12:25,440 --> 00:12:27,519
will use it in our iot device so it will

340
00:12:27,519 --> 00:12:29,440
be pretty straightforward and simple and

341
00:12:29,440 --> 00:12:30,720
it will stream

342
00:12:30,720 --> 00:12:31,440
the

343
00:12:31,440 --> 00:12:33,200
encoded information out of the iot

344
00:12:33,200 --> 00:12:35,040
device and let's say we're writing an

345
00:12:35,040 --> 00:12:36,959
option and we'll call our option with

346
00:12:36,959 --> 00:12:39,440
block size and memory limit

347
00:12:39,440 --> 00:12:41,519
and we're putting size and limit as

348
00:12:41,519 --> 00:12:44,160
parameters of the same option why are we

349
00:12:44,160 --> 00:12:46,560
doing this because those two are related

350
00:12:46,560 --> 00:12:47,680
to each other

351
00:12:47,680 --> 00:12:49,920
there are at least three conditions

352
00:12:49,920 --> 00:12:51,360
of entanglement

353
00:12:51,360 --> 00:12:53,920
that affect both of those

354
00:12:53,920 --> 00:12:55,760
first of all the limit has to be greater

355
00:12:55,760 --> 00:12:58,079
than zero and greater than size

356
00:12:58,079 --> 00:12:59,600
second the limit has to be a multiple of

357
00:12:59,600 --> 00:13:01,040
the size because we don't want to end up

358
00:13:01,040 --> 00:13:03,040
with a buffer that's overfilled or

359
00:13:03,040 --> 00:13:04,320
under-filled eventually when we get to

360
00:13:04,320 --> 00:13:05,680
the last block

361
00:13:05,680 --> 00:13:08,000
and finally you may know you have some

362
00:13:08,000 --> 00:13:10,000
protocol based requirements or

363
00:13:10,000 --> 00:13:11,839
limitations for example in this instance

364
00:13:11,839 --> 00:13:13,440
there's only two bytes for block

365
00:13:13,440 --> 00:13:15,360
sequence so you know there's going to be

366
00:13:15,360 --> 00:13:17,200
a limit imposed on that

367
00:13:17,200 --> 00:13:19,600
just from the protocol

368
00:13:19,600 --> 00:13:21,360
in golang all those three things are

369
00:13:21,360 --> 00:13:23,200
fairly benign but if you

370
00:13:23,200 --> 00:13:24,800
they may lead to vulnerability but if

371
00:13:24,800 --> 00:13:27,440
you're using low level language

372
00:13:27,440 --> 00:13:28,240
uh

373
00:13:28,240 --> 00:13:30,399
like c for example

374
00:13:30,399 --> 00:13:33,920
or even rust any one of those three

375
00:13:33,920 --> 00:13:36,320
right in certain conditions can cause

376
00:13:36,320 --> 00:13:38,880
you trouble they can create a state for

377
00:13:38,880 --> 00:13:41,680
dos remote code execution

378
00:13:41,680 --> 00:13:44,320
buffer overflow anything you can imagine

379
00:13:44,320 --> 00:13:46,320
and of course you want to check those to

380
00:13:46,320 --> 00:13:48,480
preclude that possibility inside the

381
00:13:48,480 --> 00:13:50,480
option and after you validate them

382
00:13:50,480 --> 00:13:52,880
together

383
00:13:52,880 --> 00:13:55,199
then you assign both of them to your

384
00:13:55,199 --> 00:13:56,240
object

385
00:13:56,240 --> 00:13:58,000
this helps you prevent entanglement

386
00:13:58,000 --> 00:13:59,519
because if somebody else goes and

387
00:13:59,519 --> 00:14:01,360
modifies the size independently they

388
00:14:01,360 --> 00:14:03,519
will not be able to do that outside of

389
00:14:03,519 --> 00:14:06,240
this very helpful protective

390
00:14:06,240 --> 00:14:08,079
option

391
00:14:08,079 --> 00:14:10,079
also please note

392
00:14:10,079 --> 00:14:11,120
that

393
00:14:11,120 --> 00:14:12,880
this creates what we call self

394
00:14:12,880 --> 00:14:15,680
documenting code when a person is using

395
00:14:15,680 --> 00:14:17,040
your object

396
00:14:17,040 --> 00:14:19,360
and they're using an ide ide will give

397
00:14:19,360 --> 00:14:21,360
them hints on how to initialize it

398
00:14:21,360 --> 00:14:24,000
properly and with the list of options

399
00:14:24,000 --> 00:14:26,480
the consumer of the your api will see

400
00:14:26,480 --> 00:14:28,560
that size and limit are together in the

401
00:14:28,560 --> 00:14:31,120
same option it hints to them that they

402
00:14:31,120 --> 00:14:33,680
have a significant relationship between

403
00:14:33,680 --> 00:14:35,600
each other and it makes

404
00:14:35,600 --> 00:14:37,360
your initialization procedure even more

405
00:14:37,360 --> 00:14:40,480
secure because the person using it knows

406
00:14:40,480 --> 00:14:43,040
something is up this is self-documenting

407
00:14:43,040 --> 00:14:46,240
code we can keep going there is another

408
00:14:46,240 --> 00:14:47,519
improvement to be made here and it's

409
00:14:47,519 --> 00:14:50,240
called option grouping option grouping

410
00:14:50,240 --> 00:14:52,880
can allow you to use isolation clarity

411
00:14:52,880 --> 00:14:54,320
and safety

412
00:14:54,320 --> 00:14:57,360
by combining options together

413
00:14:57,360 --> 00:14:59,839
how does this work well let's write a

414
00:14:59,839 --> 00:15:01,920
little helping function we'll call it

415
00:15:01,920 --> 00:15:04,560
our little helper with options that will

416
00:15:04,560 --> 00:15:06,720
take a list of options and sequentially

417
00:15:06,720 --> 00:15:08,560
apply them to the pointer of our main

418
00:15:08,560 --> 00:15:10,320
object and return an error if there is

419
00:15:10,320 --> 00:15:11,279
one

420
00:15:11,279 --> 00:15:12,959
we have already written something like

421
00:15:12,959 --> 00:15:14,639
this on the constructor so why are we

422
00:15:14,639 --> 00:15:18,000
pulling this out into a separate routine

423
00:15:18,000 --> 00:15:19,519
good question

424
00:15:19,519 --> 00:15:21,839
we'll look at it in a second but first

425
00:15:21,839 --> 00:15:23,360
of all note that we will change our

426
00:15:23,360 --> 00:15:25,920
constructor and replace that whole loop

427
00:15:25,920 --> 00:15:27,600
that was iterating through options with

428
00:15:27,600 --> 00:15:30,399
our little helper and again wrap the

429
00:15:30,399 --> 00:15:32,959
resulting error as initialization

430
00:15:32,959 --> 00:15:34,079
failure

431
00:15:34,079 --> 00:15:36,720
what does this helper allow us to do

432
00:15:36,720 --> 00:15:40,160
we can set up option sets

433
00:15:40,160 --> 00:15:42,480
we will unleash our little helper by

434
00:15:42,480 --> 00:15:45,199
designing default options

435
00:15:45,199 --> 00:15:47,839
how convenient is it to have your object

436
00:15:47,839 --> 00:15:50,800
configured securely by default but also

437
00:15:50,800 --> 00:15:53,120
make it easy for the consumer of the api

438
00:15:53,120 --> 00:15:55,920
to click on just one routine and without

439
00:15:55,920 --> 00:15:58,079
having to parse through many setters and

440
00:15:58,079 --> 00:16:00,480
getters and factory functions know

441
00:16:00,480 --> 00:16:03,680
exactly how it's supposed to be used

442
00:16:03,680 --> 00:16:05,600
with a list of all the modifications

443
00:16:05,600 --> 00:16:08,320
that are secure by default and also know

444
00:16:08,320 --> 00:16:10,560
which ones they may want to change

445
00:16:10,560 --> 00:16:12,639
this makes for a very lean and easy to

446
00:16:12,639 --> 00:16:14,480
use api

447
00:16:14,480 --> 00:16:16,720
another way to set up a set of options

448
00:16:16,720 --> 00:16:19,199
is to use an option set called with

449
00:16:19,199 --> 00:16:21,040
debug option

450
00:16:21,040 --> 00:16:22,720
with debug options we'll take a list of

451
00:16:22,720 --> 00:16:24,720
options and present them together as a

452
00:16:24,720 --> 00:16:25,759
set

453
00:16:25,759 --> 00:16:29,199
well in that list you could use unsafe

454
00:16:29,199 --> 00:16:30,880
private options

455
00:16:30,880 --> 00:16:32,880
why private because for example like a

456
00:16:32,880 --> 00:16:34,560
debug backdoor

457
00:16:34,560 --> 00:16:36,079
is not something we will ever want to

458
00:16:36,079 --> 00:16:38,720
see in production or someone use

459
00:16:38,720 --> 00:16:40,240
carelessly

460
00:16:40,240 --> 00:16:44,639
or flaunt without careful consideration

461
00:16:44,639 --> 00:16:45,440
and

462
00:16:45,440 --> 00:16:47,920
by accident include it in our object and

463
00:16:47,920 --> 00:16:48,839
ship

464
00:16:48,839 --> 00:16:52,720
it by bundling unsafe private options

465
00:16:52,720 --> 00:16:55,279
together in an option set we make it

466
00:16:55,279 --> 00:16:58,480
very clear and exact

467
00:16:58,480 --> 00:17:01,199
that those types of vulnerabilities will

468
00:17:01,199 --> 00:17:03,759
not end up or those types of dangerous

469
00:17:03,759 --> 00:17:05,280
or weak options will not end up where

470
00:17:05,280 --> 00:17:07,439
they're not supposed to because a person

471
00:17:07,439 --> 00:17:09,919
will have to either use that entire set

472
00:17:09,919 --> 00:17:12,079
or refuse that entire set and they can

473
00:17:12,079 --> 00:17:13,199
see right away from object

474
00:17:13,199 --> 00:17:15,839
initialization which set is being used

475
00:17:15,839 --> 00:17:17,520
and of course since your writing an

476
00:17:17,520 --> 00:17:20,079
option set just for debugging why don't

477
00:17:20,079 --> 00:17:21,439
you just check

478
00:17:21,439 --> 00:17:23,359
right away that your instance is not

479
00:17:23,359 --> 00:17:25,919
running in production because if it is

480
00:17:25,919 --> 00:17:27,439
you guessed it you need to raise an

481
00:17:27,439 --> 00:17:30,400
exception and halt execution

482
00:17:30,400 --> 00:17:32,720
finally you can use option sets for

483
00:17:32,720 --> 00:17:35,440
visual grouping sometimes you don't have

484
00:17:35,440 --> 00:17:37,600
entangled parameters but for clarity you

485
00:17:37,600 --> 00:17:39,840
want to have on the same line through

486
00:17:39,840 --> 00:17:41,919
related things and comment on them

487
00:17:41,919 --> 00:17:43,039
together

488
00:17:43,039 --> 00:17:45,120
you can group and nest by using our

489
00:17:45,120 --> 00:17:47,039
little helper as much as you want

490
00:17:47,039 --> 00:17:48,799
to your heart's content in the end it

491
00:17:48,799 --> 00:17:49,840
will not make a difference for

492
00:17:49,840 --> 00:17:52,160
initialization but it will provide you a

493
00:17:52,160 --> 00:17:54,720
convenient and well documented way to

494
00:17:54,720 --> 00:17:55,840
present

495
00:17:55,840 --> 00:17:57,679
the way you're using your object to your

496
00:17:57,679 --> 00:17:59,840
team

497
00:17:59,840 --> 00:18:01,440
let's put all this together and look at

498
00:18:01,440 --> 00:18:03,679
a few examples which are

499
00:18:03,679 --> 00:18:06,000
a little bit more complicated

500
00:18:06,000 --> 00:18:07,919
so suppose we're writing a hypothetical

501
00:18:07,919 --> 00:18:10,160
distributed secrets manager

502
00:18:10,160 --> 00:18:12,000
is that sophisticated enough oh yes it

503
00:18:12,000 --> 00:18:12,720
is

504
00:18:12,720 --> 00:18:14,559
so we'll use

505
00:18:14,559 --> 00:18:16,720
a set of peers that we can pass or even

506
00:18:16,720 --> 00:18:18,880
a pure discovery protocol

507
00:18:18,880 --> 00:18:20,320
we can write an option for that and

508
00:18:20,320 --> 00:18:22,880
validate each one of the parameters

509
00:18:22,880 --> 00:18:23,919
being set

510
00:18:23,919 --> 00:18:25,440
of course we'll use a caching layer

511
00:18:25,440 --> 00:18:28,000
because that's very good for performance

512
00:18:28,000 --> 00:18:29,760
redis is kind of a standard caching

513
00:18:29,760 --> 00:18:31,360
layer and we'll have to write an adapter

514
00:18:31,360 --> 00:18:32,080
for

515
00:18:32,080 --> 00:18:33,919
our object but we'll set it up as an

516
00:18:33,919 --> 00:18:35,039
option

517
00:18:35,039 --> 00:18:36,559
we will also need a list of allowed

518
00:18:36,559 --> 00:18:39,120
ciphers we want to do cryptography

519
00:18:39,120 --> 00:18:40,799
without releasing the keys

520
00:18:40,799 --> 00:18:43,039
and we'll need for secret manager

521
00:18:43,039 --> 00:18:46,640
rotation window and a max key lifetime

522
00:18:46,640 --> 00:18:48,480
as you are drafting the options you're

523
00:18:48,480 --> 00:18:50,960
realizing okay that those two rotation

524
00:18:50,960 --> 00:18:52,720
window and max key lifetime are

525
00:18:52,720 --> 00:18:54,640
pretzeled they have a relationship

526
00:18:54,640 --> 00:18:55,679
between them

527
00:18:55,679 --> 00:18:57,120
so let's think about this for a second

528
00:18:57,120 --> 00:18:58,960
what can we do

529
00:18:58,960 --> 00:19:01,360
should we combine them into one option

530
00:19:01,360 --> 00:19:04,240
like an example i showed earlier

531
00:19:04,240 --> 00:19:05,039
well

532
00:19:05,039 --> 00:19:07,120
uh perhaps but what if there are more

533
00:19:07,120 --> 00:19:08,960
options that come up

534
00:19:08,960 --> 00:19:12,240
later that can affect those two

535
00:19:12,240 --> 00:19:13,919
then there's another question what if

536
00:19:13,919 --> 00:19:17,520
the cache layer was misconfigured

537
00:19:17,520 --> 00:19:19,679
what will happen

538
00:19:19,679 --> 00:19:21,919
it could lead to broken access control

539
00:19:21,919 --> 00:19:23,520
or ghost keys

540
00:19:23,520 --> 00:19:25,760
that should be long expired but they're

541
00:19:25,760 --> 00:19:27,200
hanging out in a cache layer because

542
00:19:27,200 --> 00:19:30,720
somebody wrote the config incorrectly or

543
00:19:30,720 --> 00:19:33,360
provided incorrect configuration

544
00:19:33,360 --> 00:19:35,280
in production

545
00:19:35,280 --> 00:19:36,799
but also

546
00:19:36,799 --> 00:19:38,640
the cache configuration needs to account

547
00:19:38,640 --> 00:19:41,919
for the rotation lifetimes as well

548
00:19:41,919 --> 00:19:44,160
the max key lifetime cannot be greater

549
00:19:44,160 --> 00:19:45,919
than five times the rotation window

550
00:19:45,919 --> 00:19:47,039
because then it defeats the whole

551
00:19:47,039 --> 00:19:49,280
purpose of key rotation

552
00:19:49,280 --> 00:19:50,960
those things all have to be accounted

553
00:19:50,960 --> 00:19:53,440
for and we realize all of a sudden it's

554
00:19:53,440 --> 00:19:54,960
not just two things that are pretzel

555
00:19:54,960 --> 00:19:56,880
it's at least three things and maybe

556
00:19:56,880 --> 00:19:58,000
more

557
00:19:58,000 --> 00:19:59,520
what's a good way to handle this with

558
00:19:59,520 --> 00:20:01,919
the option pattern

559
00:20:01,919 --> 00:20:04,240
well instead of combining the two

560
00:20:04,240 --> 00:20:06,720
rotation window and max key lifetime

561
00:20:06,720 --> 00:20:09,440
let's take a hybrid approach and write

562
00:20:09,440 --> 00:20:11,520
an option called with synchronization

563
00:20:11,520 --> 00:20:13,039
strategy

564
00:20:13,039 --> 00:20:15,919
and provide a list of keyword settings

565
00:20:15,919 --> 00:20:18,320
to initialize our strategy

566
00:20:18,320 --> 00:20:19,600
you can see there

567
00:20:19,600 --> 00:20:21,039
at number one we'll leave a comment

568
00:20:21,039 --> 00:20:22,960
because we expect perhaps that maybe

569
00:20:22,960 --> 00:20:24,559
more parameters will join the

570
00:20:24,559 --> 00:20:26,799
synchronization strategy later

571
00:20:26,799 --> 00:20:28,640
that we don't know yet and second of

572
00:20:28,640 --> 00:20:30,960
course since we're using a structure

573
00:20:30,960 --> 00:20:32,880
with keywords to initialize those

574
00:20:32,880 --> 00:20:35,039
settings we're in effect combining two

575
00:20:35,039 --> 00:20:36,400
different installation approaches

576
00:20:36,400 --> 00:20:37,919
options pattern plus keyword

577
00:20:37,919 --> 00:20:39,840
installation we can actually use that

578
00:20:39,840 --> 00:20:40,960
structure

579
00:20:40,960 --> 00:20:43,280
and share it internally between our

580
00:20:43,280 --> 00:20:45,280
different option sets

581
00:20:45,280 --> 00:20:46,799
and we can use those parameters to

582
00:20:46,799 --> 00:20:48,720
present them to our caching layer to

583
00:20:48,720 --> 00:20:49,840
make sure

584
00:20:49,840 --> 00:20:53,120
that key expiration in cache matches the

585
00:20:53,120 --> 00:20:54,480
key lifetime

586
00:20:54,480 --> 00:20:57,360
provided for the rotation

587
00:20:57,360 --> 00:20:58,640
this process

588
00:20:58,640 --> 00:21:00,640
makes our api

589
00:21:00,640 --> 00:21:02,640
hard to misuse

590
00:21:02,640 --> 00:21:03,919
if it's well written it will be

591
00:21:03,919 --> 00:21:06,159
impossible to misuse

592
00:21:06,159 --> 00:21:08,880
notice the pattern helps you think the

593
00:21:08,880 --> 00:21:10,080
options pattern

594
00:21:10,080 --> 00:21:12,960
maybe we can write a book and call it

595
00:21:12,960 --> 00:21:15,120
options pattern design

596
00:21:15,120 --> 00:21:17,280
i'm just kidding

597
00:21:17,280 --> 00:21:19,360
let's look at some more examples suppose

598
00:21:19,360 --> 00:21:20,320
we're writing a hypothetical

599
00:21:20,320 --> 00:21:21,760
microservice

600
00:21:21,760 --> 00:21:23,520
and let's write some options for that

601
00:21:23,520 --> 00:21:26,400
with host and port those two are related

602
00:21:26,400 --> 00:21:28,320
to each other they're entangled you can

603
00:21:28,320 --> 00:21:30,720
see the port is an integer not a string

604
00:21:30,720 --> 00:21:32,159
because we want to lean on the type

605
00:21:32,159 --> 00:21:34,400
system to make this even more secure we

606
00:21:34,400 --> 00:21:37,679
will need a tls layer acme is a good way

607
00:21:37,679 --> 00:21:39,840
to go so we'll write an option for that

608
00:21:39,840 --> 00:21:43,039
and also timeouts microservices are very

609
00:21:43,039 --> 00:21:45,360
very reliant on timeouts

610
00:21:45,360 --> 00:21:47,520
regarding security right we don't want

611
00:21:47,520 --> 00:21:50,159
our apis and our calls to hang

612
00:21:50,159 --> 00:21:53,280
or to tie up resources by having really

613
00:21:53,280 --> 00:21:55,280
long targeted

614
00:21:55,280 --> 00:21:56,640
connections

615
00:21:56,640 --> 00:21:58,000
all sorts of things can go wrong and

616
00:21:58,000 --> 00:22:00,799
here we will use a keyword

617
00:22:00,799 --> 00:22:02,159
setting

618
00:22:02,159 --> 00:22:04,720
in a structure by defining ingress

619
00:22:04,720 --> 00:22:06,960
egress and idle session timeouts that

620
00:22:06,960 --> 00:22:09,520
can be shared between both internal and

621
00:22:09,520 --> 00:22:12,960
external api calls to make a service

622
00:22:12,960 --> 00:22:15,120
stable and resilient against the dos

623
00:22:15,120 --> 00:22:16,559
attack

624
00:22:16,559 --> 00:22:18,240
of course we'll need a secrets manager

625
00:22:18,240 --> 00:22:20,400
because microservices need a rotating

626
00:22:20,400 --> 00:22:22,320
secrets manager and we'll use a kms

627
00:22:22,320 --> 00:22:23,440
adapter

628
00:22:23,440 --> 00:22:25,440
that will write later a throttling

629
00:22:25,440 --> 00:22:26,480
strategy

630
00:22:26,480 --> 00:22:28,880
that's a requirement if our service does

631
00:22:28,880 --> 00:22:30,960
not throttle it is

632
00:22:30,960 --> 00:22:33,919
very rickety and vulnerable and let's

633
00:22:33,919 --> 00:22:36,320
take a strategy that will throttle by p

634
00:22:36,320 --> 00:22:39,200
you notice a behavior is being passed

635
00:22:39,200 --> 00:22:40,960
great for the options pattern

636
00:22:40,960 --> 00:22:42,559
we'll have a retry strategy another

637
00:22:42,559 --> 00:22:44,799
behavior and we'll use immediate retry

638
00:22:44,799 --> 00:22:46,000
two times

639
00:22:46,000 --> 00:22:48,799
uh when a call fails or a connection

640
00:22:48,799 --> 00:22:50,080
fails

641
00:22:50,080 --> 00:22:52,320
of course we'll need a state backend

642
00:22:52,320 --> 00:22:54,799
redis is great with an adapter and of

643
00:22:54,799 --> 00:22:57,919
course a logger

644
00:22:57,919 --> 00:23:00,320
it's a good question where is a good

645
00:23:00,320 --> 00:23:02,559
point to put loggers

646
00:23:02,559 --> 00:23:04,320
sometimes you want you want to be

647
00:23:04,320 --> 00:23:05,919
tempted to put them everywhere but they

648
00:23:05,919 --> 00:23:07,600
create side effects and they make things

649
00:23:07,600 --> 00:23:10,159
that are not so testable

650
00:23:10,159 --> 00:23:11,679
it's an additional complication but when

651
00:23:11,679 --> 00:23:13,520
you're using a sophisticated

652
00:23:13,520 --> 00:23:15,520
object that requires options pattern

653
00:23:15,520 --> 00:23:16,960
typically you should have an option

654
00:23:16,960 --> 00:23:18,720
called with logger and what you really

655
00:23:18,720 --> 00:23:20,960
want to do is write an interface so you

656
00:23:20,960 --> 00:23:22,880
can satisfy it with a logger of your

657
00:23:22,880 --> 00:23:24,880
choice or perhaps

658
00:23:24,880 --> 00:23:28,240
multiple loggers that's a good way to go

659
00:23:28,240 --> 00:23:31,120
observability adds to security and

660
00:23:31,120 --> 00:23:33,760
here's an option to do that

661
00:23:33,760 --> 00:23:35,360
let's look at another example how about

662
00:23:35,360 --> 00:23:38,480
we write aws fargate containerized

663
00:23:38,480 --> 00:23:40,080
task launcher

664
00:23:40,080 --> 00:23:43,360
so a task launcher we will define tasks

665
00:23:43,360 --> 00:23:45,760
fargate is basically a layer over

666
00:23:45,760 --> 00:23:48,480
kubernetes cluster

667
00:23:48,480 --> 00:23:51,200
all sorts of fun comes with kubernetes

668
00:23:51,200 --> 00:23:52,720
clusters and security right they're

669
00:23:52,720 --> 00:23:54,640
difficult to secure

670
00:23:54,640 --> 00:23:57,039
so fargate is already uh easier because

671
00:23:57,039 --> 00:23:58,640
it's an api right on top of it so you

672
00:23:58,640 --> 00:24:00,159
don't have to worry nearly about as much

673
00:24:00,159 --> 00:24:01,679
for security

674
00:24:01,679 --> 00:24:05,840
but still there are things to check

675
00:24:06,880 --> 00:24:08,640
the first thing of course is aws

676
00:24:08,640 --> 00:24:09,840
configuration

677
00:24:09,840 --> 00:24:11,600
object right so we need to have a proper

678
00:24:11,600 --> 00:24:13,279
config that has all the right roles

679
00:24:13,279 --> 00:24:17,039
configured and access to the right

680
00:24:17,039 --> 00:24:19,520
access control points and the right uh

681
00:24:19,520 --> 00:24:22,559
apis to to launch our tasks

682
00:24:22,559 --> 00:24:24,400
so we'll make an option for that and we

683
00:24:24,400 --> 00:24:25,919
will validate configuration inside the

684
00:24:25,919 --> 00:24:28,000
option of course the cluster name

685
00:24:28,000 --> 00:24:29,440
because we don't want to just be

686
00:24:29,440 --> 00:24:31,200
launching uh containers all over the

687
00:24:31,200 --> 00:24:32,400
place we'll want to restrict them to a

688
00:24:32,400 --> 00:24:34,640
certain cluster so there's some control

689
00:24:34,640 --> 00:24:36,720
uh singular point of control when we can

690
00:24:36,720 --> 00:24:38,720
turn off the whole cluster and shut the

691
00:24:38,720 --> 00:24:40,720
servers if something goes wrong

692
00:24:40,720 --> 00:24:43,039
uh we'll need a url factory right

693
00:24:43,039 --> 00:24:44,880
because eventually those containers will

694
00:24:44,880 --> 00:24:45,840
need to be

695
00:24:45,840 --> 00:24:48,960
accessed somehow and the public ip will

696
00:24:48,960 --> 00:24:50,960
need to be converted to a link maybe

697
00:24:50,960 --> 00:24:54,000
we'll be passing a token of some sort

698
00:24:54,000 --> 00:24:56,720
as well for access management and a url

699
00:24:56,720 --> 00:24:59,279
factory method a behavior is very

700
00:24:59,279 --> 00:25:00,880
convenient way to do that we're passing

701
00:25:00,880 --> 00:25:04,240
behavior using an options pattern

702
00:25:04,240 --> 00:25:08,240
next on fargate takes subnet

703
00:25:08,240 --> 00:25:09,679
configuration and security group

704
00:25:09,679 --> 00:25:11,919
configuration a security group in aws is

705
00:25:11,919 --> 00:25:14,559
basically a firewall set of rules

706
00:25:14,559 --> 00:25:15,600
and

707
00:25:15,600 --> 00:25:18,480
the way fargate is set up is that it

708
00:25:18,480 --> 00:25:20,960
takes both subnets and security groups

709
00:25:20,960 --> 00:25:23,200
without differentiating between them

710
00:25:23,200 --> 00:25:25,039
it doesn't care if they're private or

711
00:25:25,039 --> 00:25:26,400
public

712
00:25:26,400 --> 00:25:28,400
but we care right

713
00:25:28,400 --> 00:25:30,320
because we need to make sure our

714
00:25:30,320 --> 00:25:32,799
containers are either public or private

715
00:25:32,799 --> 00:25:34,320
we never want to have one that's

716
00:25:34,320 --> 00:25:37,600
supposed to be uh internet private

717
00:25:37,600 --> 00:25:39,440
launched with a public subnet

718
00:25:39,440 --> 00:25:41,039
configuration

719
00:25:41,039 --> 00:25:43,120
to preclude that we can actually write

720
00:25:43,120 --> 00:25:45,520
an option that will differentiate and

721
00:25:45,520 --> 00:25:48,640
protect the fargate api

722
00:25:48,640 --> 00:25:49,919
by checking

723
00:25:49,919 --> 00:25:51,279
our settings

724
00:25:51,279 --> 00:25:53,600
so that when we provide the subnet id

725
00:25:53,600 --> 00:25:56,000
let's go ahead and just peek at that ip

726
00:25:56,000 --> 00:25:58,559
address of that subnet

727
00:25:58,559 --> 00:26:01,919
and see maybe if it starts from 10.0

728
00:26:01,919 --> 00:26:04,080
right because that will indicate

729
00:26:04,080 --> 00:26:06,320
a private ip most likely that's just a

730
00:26:06,320 --> 00:26:07,600
simple check but you can be more

731
00:26:07,600 --> 00:26:09,600
sophisticated than that but the point

732
00:26:09,600 --> 00:26:11,360
being is that when a person configures

733
00:26:11,360 --> 00:26:14,080
your object this will prevent them from

734
00:26:14,080 --> 00:26:16,159
publicly exposing the container when

735
00:26:16,159 --> 00:26:19,679
they did not intend to

736
00:26:19,679 --> 00:26:22,559
otherwise you're just relying

737
00:26:22,559 --> 00:26:25,919
on that id to be pointing to the correct

738
00:26:25,919 --> 00:26:27,200
subnet

739
00:26:27,200 --> 00:26:29,200
a person chasing a deadline will they

740
00:26:29,200 --> 00:26:30,880
present you the correct one

741
00:26:30,880 --> 00:26:34,080
yes you guessed it very likely not so

742
00:26:34,080 --> 00:26:37,120
have your option check for it similarly

743
00:26:37,120 --> 00:26:38,960
a security group id

744
00:26:38,960 --> 00:26:41,200
option can access that security group

745
00:26:41,200 --> 00:26:44,320
and check the ingress and ingress

746
00:26:44,320 --> 00:26:46,640
firewall rules to make sure that only

747
00:26:46,640 --> 00:26:48,640
certain types of traffic gets in and out

748
00:26:48,640 --> 00:26:50,320
of your container

749
00:26:50,320 --> 00:26:51,679
and for each one of those options you

750
00:26:51,679 --> 00:26:54,080
can also wrap them with additional

751
00:26:54,080 --> 00:26:56,240
functionality when you are presenting

752
00:26:56,240 --> 00:26:56,960
them

753
00:26:56,960 --> 00:26:59,039
to your fargate containerized task

754
00:26:59,039 --> 00:27:00,080
launcher

755
00:27:00,080 --> 00:27:02,000
this is called security

756
00:27:02,000 --> 00:27:04,720
built in and even if the api itself did

757
00:27:04,720 --> 00:27:07,039
not account for those failure states

758
00:27:07,039 --> 00:27:09,520
you're accounting for it in your

759
00:27:09,520 --> 00:27:12,240
implementation

760
00:27:13,679 --> 00:27:15,520
fargate api does not differentiate

761
00:27:15,520 --> 00:27:16,640
public and private networking

762
00:27:16,640 --> 00:27:19,120
dependencies but we must

763
00:27:19,120 --> 00:27:21,360
and the option pattern here will help us

764
00:27:21,360 --> 00:27:23,760
do that

765
00:27:24,000 --> 00:27:26,320
let's look at a hypothetical encrypted

766
00:27:26,320 --> 00:27:28,960
network tunnel those are fun to write

767
00:27:28,960 --> 00:27:31,520
and we'll need to have it very flexible

768
00:27:31,520 --> 00:27:33,120
and configurable

769
00:27:33,120 --> 00:27:35,440
and let's set it up with a certain

770
00:27:35,440 --> 00:27:37,200
packet size

771
00:27:37,200 --> 00:27:38,799
large packet size

772
00:27:38,799 --> 00:27:41,120
means greater efficiency for processing

773
00:27:41,120 --> 00:27:44,000
but also greater latency and who knows

774
00:27:44,000 --> 00:27:46,720
where this encrypted tunnel will be used

775
00:27:46,720 --> 00:27:49,520
we will be an iot device

776
00:27:49,520 --> 00:27:51,919
a backup server who knows we want that

777
00:27:51,919 --> 00:27:53,679
to be configurable

778
00:27:53,679 --> 00:27:55,679
and so we're going to make an option for

779
00:27:55,679 --> 00:27:57,679
that second of course if it's encrypted

780
00:27:57,679 --> 00:28:00,000
it will need a key provider and we'll

781
00:28:00,000 --> 00:28:01,760
need to write some adapters for

782
00:28:01,760 --> 00:28:03,679
different key providers that we're using

783
00:28:03,679 --> 00:28:06,240
so there's a security built in not just

784
00:28:06,240 --> 00:28:08,159
in initializing the key provider but

785
00:28:08,159 --> 00:28:10,240
also validating that it's working

786
00:28:10,240 --> 00:28:11,760
correctly

787
00:28:11,760 --> 00:28:13,679
we will also need a recovery fallback

788
00:28:13,679 --> 00:28:15,039
right what if our

789
00:28:15,039 --> 00:28:17,039
instance that's providing the network

790
00:28:17,039 --> 00:28:19,919
tunnel is rebooted our protocol could be

791
00:28:19,919 --> 00:28:21,520
stateless like

792
00:28:21,520 --> 00:28:23,679
wireguard or maybe it's stateful if it

793
00:28:23,679 --> 00:28:25,200
is stateful we'll need a recovery

794
00:28:25,200 --> 00:28:26,480
strategy

795
00:28:26,480 --> 00:28:28,640
and we could write a journal rollback

796
00:28:28,640 --> 00:28:30,320
strategy so that even if there is a

797
00:28:30,320 --> 00:28:33,200
reboot or some kind of a a problem that

798
00:28:33,200 --> 00:28:35,039
shuts down the network tunnel it can

799
00:28:35,039 --> 00:28:38,080
rebuild itself when it wakes up

800
00:28:38,080 --> 00:28:40,720
enough's factory is so important because

801
00:28:40,720 --> 00:28:42,840
nonsense will have to be synchronized

802
00:28:42,840 --> 00:28:45,440
centrally uh if we're using multiple

803
00:28:45,440 --> 00:28:47,360
instances or if we're managing

804
00:28:47,360 --> 00:28:49,600
connections at scale

805
00:28:49,600 --> 00:28:51,679
and there of course we can decide if we

806
00:28:51,679 --> 00:28:54,880
can use like a local nonce cache or a

807
00:28:54,880 --> 00:28:56,720
networked one or even use something

808
00:28:56,720 --> 00:28:59,679
really fancy like fcd with raft a

809
00:28:59,679 --> 00:29:03,039
protocol for synchronization

810
00:29:03,200 --> 00:29:05,200
of course we want to handle errors

811
00:29:05,200 --> 00:29:08,559
gratefully and with error handler is a

812
00:29:08,559 --> 00:29:10,880
way to pass a closure

813
00:29:10,880 --> 00:29:12,399
to respond to an error

814
00:29:12,399 --> 00:29:14,080
that's so convenient to have on just

815
00:29:14,080 --> 00:29:17,200
about any object sometimes you want to

816
00:29:17,200 --> 00:29:18,880
respond to a particular error state but

817
00:29:18,880 --> 00:29:20,480
maybe you're just hunting for one type

818
00:29:20,480 --> 00:29:22,159
of error or you're interested in a

819
00:29:22,159 --> 00:29:23,840
particular type of error

820
00:29:23,840 --> 00:29:26,159
pass an error handler and by the way

821
00:29:26,159 --> 00:29:28,720
nothing stops you from repeating the

822
00:29:28,720 --> 00:29:30,720
option multiple times

823
00:29:30,720 --> 00:29:32,000
if you would like multiple error

824
00:29:32,000 --> 00:29:34,240
handlers you can write it in such a way

825
00:29:34,240 --> 00:29:36,720
that they're appended to a list that

826
00:29:36,720 --> 00:29:38,480
will be iterated when an error does

827
00:29:38,480 --> 00:29:39,919
occur and this will give you

828
00:29:39,919 --> 00:29:41,520
instrumentation for

829
00:29:41,520 --> 00:29:45,039
logging for recovery for alerts

830
00:29:45,039 --> 00:29:48,080
and alerts are good for security

831
00:29:48,080 --> 00:29:50,000
well there is an elephant in the room

832
00:29:50,000 --> 00:29:52,399
here that i did not even mention this

833
00:29:52,399 --> 00:29:55,440
whole time

834
00:29:55,440 --> 00:29:57,679
think back you know what are we actually

835
00:29:57,679 --> 00:29:59,919
doing

836
00:30:00,399 --> 00:30:03,200
we are pulling out complex validation

837
00:30:03,200 --> 00:30:04,240
code

838
00:30:04,240 --> 00:30:05,760
out of the constructor

839
00:30:05,760 --> 00:30:09,760
and isolating it by concern and behavior

840
00:30:09,760 --> 00:30:11,279
inside singular

841
00:30:11,279 --> 00:30:13,760
functions

842
00:30:15,120 --> 00:30:17,039
the options pattern

843
00:30:17,039 --> 00:30:18,320
is the most

844
00:30:18,320 --> 00:30:20,799
testable initialization strategy

845
00:30:20,799 --> 00:30:23,360
you you're ever going to get

846
00:30:23,360 --> 00:30:25,039
because you're isolating one or two

847
00:30:25,039 --> 00:30:27,919
parameters per function you're already

848
00:30:27,919 --> 00:30:31,039
setting up code that's testable without

849
00:30:31,039 --> 00:30:33,039
having to go through multiple factories

850
00:30:33,039 --> 00:30:35,200
or multiple builders and validate each

851
00:30:35,200 --> 00:30:38,640
one you are isolating concerns

852
00:30:38,640 --> 00:30:42,480
and make them easy to discover for bugs

853
00:30:42,480 --> 00:30:45,279
and to check for security by writing a

854
00:30:45,279 --> 00:30:46,960
battery of unit tests

855
00:30:46,960 --> 00:30:48,960
on each

856
00:30:48,960 --> 00:30:51,279
this is a wonderful benefit of the

857
00:30:51,279 --> 00:30:53,520
options pattern and of course we know

858
00:30:53,520 --> 00:30:56,000
that testability and security are

859
00:30:56,000 --> 00:30:58,720
closely related the earlier you can test

860
00:30:58,720 --> 00:31:00,399
the more thoroughly you can test the

861
00:31:00,399 --> 00:31:02,000
more you can isolate the better your

862
00:31:02,000 --> 00:31:03,600
security will be

863
00:31:03,600 --> 00:31:06,000
and this will give you the advantage of

864
00:31:06,000 --> 00:31:09,360
writing your tests in such a way

865
00:31:09,360 --> 00:31:11,360
that you can handle

866
00:31:11,360 --> 00:31:15,519
high complexity with great security

867
00:31:15,519 --> 00:31:16,720
o wasp

868
00:31:16,720 --> 00:31:18,399
top 10 number six

869
00:31:18,399 --> 00:31:21,679
security misconfiguration

870
00:31:21,679 --> 00:31:23,600
number six

871
00:31:23,600 --> 00:31:26,880
can we remove this vulnerability type

872
00:31:26,880 --> 00:31:29,440
from a wasp.10

873
00:31:29,440 --> 00:31:31,200
i believe we can

874
00:31:31,200 --> 00:31:33,760
use the options pattern

875
00:31:33,760 --> 00:31:35,600
it is not the responsibility of the

876
00:31:35,600 --> 00:31:37,760
consumer to keep your app secure it is

877
00:31:37,760 --> 00:31:40,159
your responsibility as a programmer to

878
00:31:40,159 --> 00:31:42,480
write your app secure an insecure

879
00:31:42,480 --> 00:31:44,720
configuration is a failure state that

880
00:31:44,720 --> 00:31:46,799
needs to be detected

881
00:31:46,799 --> 00:31:48,880
and needs to be rejected

882
00:31:48,880 --> 00:31:51,760
early in the program execution and then

883
00:31:51,760 --> 00:31:54,480
this will go away

884
00:31:54,480 --> 00:31:56,720
some key takeaways

885
00:31:56,720 --> 00:31:58,880
if something can be misused

886
00:31:58,880 --> 00:32:01,360
it will be misused

887
00:32:01,360 --> 00:32:03,360
be secure by default and that means

888
00:32:03,360 --> 00:32:04,960
weekend services

889
00:32:04,960 --> 00:32:07,039
should not even start

890
00:32:07,039 --> 00:32:09,600
in the cloud

891
00:32:09,600 --> 00:32:12,480
in a sophisticated system

892
00:32:12,480 --> 00:32:14,320
it's just a matter of time before

893
00:32:14,320 --> 00:32:15,600
somebody

894
00:32:15,600 --> 00:32:17,600
presents a wrong configuration or all

895
00:32:17,600 --> 00:32:20,880
configuration and the service falls over

896
00:32:20,880 --> 00:32:23,200
build the security into

897
00:32:23,200 --> 00:32:25,519
the into the program use the options

898
00:32:25,519 --> 00:32:27,679
pattern to detect the problem

899
00:32:27,679 --> 00:32:29,840
and fix it or prevent the program from

900
00:32:29,840 --> 00:32:30,799
running

901
00:32:30,799 --> 00:32:32,799
if if there is one

902
00:32:32,799 --> 00:32:33,760
second

903
00:32:33,760 --> 00:32:35,760
the options pattern guards against

904
00:32:35,760 --> 00:32:38,000
misconfiguration invalid initialization

905
00:32:38,000 --> 00:32:42,600
states and other vulnerabilities

906
00:32:42,880 --> 00:32:44,080
third

907
00:32:44,080 --> 00:32:46,159
the options pattern is convenient for

908
00:32:46,159 --> 00:32:47,679
automated testing

909
00:32:47,679 --> 00:32:49,600
i would contend it is the most

910
00:32:49,600 --> 00:32:51,840
convenient initialization strategy for

911
00:32:51,840 --> 00:32:55,120
automated testing

912
00:32:55,279 --> 00:32:58,080
testable code is reliable and secure

913
00:32:58,080 --> 00:33:00,159
use the options pattern

914
00:33:00,159 --> 00:33:02,880
and fourth i hope i'm able to inspire

915
00:33:02,880 --> 00:33:04,960
you to implement the options pattern in

916
00:33:04,960 --> 00:33:06,960
your next major version release to

917
00:33:06,960 --> 00:33:09,039
bolster security with a boost of code

918
00:33:09,039 --> 00:33:14,320
readability reliability and resilience

919
00:33:15,840 --> 00:33:18,799
your program your api your library will

920
00:33:18,799 --> 00:33:22,159
be easier to use it will be fun to use

921
00:33:22,159 --> 00:33:25,600
and secure to use if it has the options

922
00:33:25,600 --> 00:33:30,799
pattern at its top api interface

923
00:33:33,360 --> 00:33:35,200
if you're interested in the subject here

924
00:33:35,200 --> 00:33:37,519
are a few more resources to consider

925
00:33:37,519 --> 00:33:38,640
first of all there's a classic

926
00:33:38,640 --> 00:33:40,960
presentation by dave cheney on the

927
00:33:40,960 --> 00:33:43,440
options pattern which is very excellent

928
00:33:43,440 --> 00:33:45,200
there's an article if you're more into

929
00:33:45,200 --> 00:33:46,320
reading

930
00:33:46,320 --> 00:33:49,840
explained by mark sagi kazar

931
00:33:49,840 --> 00:33:52,240
there's also a really good blog on how

932
00:33:52,240 --> 00:33:54,080
to apply the options pattern to database

933
00:33:54,080 --> 00:33:56,640
queries um it's a very interesting use

934
00:33:56,640 --> 00:33:58,880
case of a similar approach

935
00:33:58,880 --> 00:34:00,159
and finally

936
00:34:00,159 --> 00:34:02,399
there is a full example source code just

937
00:34:02,399 --> 00:34:05,200
with comments of the options pattern as

938
00:34:05,200 --> 00:34:08,159
i presented it in this talk

939
00:34:08,159 --> 00:34:10,399
that you can access but that qr code

940
00:34:10,399 --> 00:34:12,639
it's compilable it will run and it gives

941
00:34:12,639 --> 00:34:14,639
you an opportunity to study this in more

942
00:34:14,639 --> 00:34:17,040
detail

943
00:34:17,119 --> 00:34:20,599
thank you so much

944
00:34:22,000 --> 00:34:24,079
you

