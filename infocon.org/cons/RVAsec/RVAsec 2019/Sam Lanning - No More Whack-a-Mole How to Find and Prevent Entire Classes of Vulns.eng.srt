1
00:00:25,590 --> 00:00:30,150
so

2
00:00:27,420 --> 00:00:32,130
talk is gonna be a little bit technical

3
00:00:30,150 --> 00:00:34,350
a little bit high-level hopefully

4
00:00:32,130 --> 00:00:36,650
there'll be a little bit of humor in

5
00:00:34,350 --> 00:00:40,200
there ultimately that depends on kind of

6
00:00:36,650 --> 00:00:42,379
individuals tastes but I'm hoping

7
00:00:40,200 --> 00:00:45,360
there'll be something for everyone today

8
00:00:42,380 --> 00:00:54,930
speak up all right

9
00:00:45,360 --> 00:00:57,720
speak up can I volume up as well so yeah

10
00:00:54,930 --> 00:01:01,229
so this this talk is in particular for

11
00:00:57,720 --> 00:01:02,640
people who are in any way involved in

12
00:01:01,229 --> 00:01:04,890
software development if you are a

13
00:01:02,640 --> 00:01:07,170
developer yourself or you are in on a

14
00:01:04,890 --> 00:01:08,790
Security Response Team for a company or

15
00:01:07,170 --> 00:01:09,510
you're a consultant for a company that

16
00:01:08,790 --> 00:01:11,370
does software

17
00:01:09,510 --> 00:01:15,090
there'll be probably some relevant

18
00:01:11,370 --> 00:01:17,010
takeaways for you today everyone okay

19
00:01:15,090 --> 00:01:19,320
with the sound levels at the back can I

20
00:01:17,010 --> 00:01:25,159
couldn't hear me okay cool

21
00:01:19,320 --> 00:01:30,449
all right so to start with I am going to

22
00:01:25,159 --> 00:01:34,859
start with the story so on the 7th of

23
00:01:30,450 --> 00:01:37,409
September 2017 my colleague Moe found a

24
00:01:34,859 --> 00:01:42,298
vulnerability in the spring framework

25
00:01:37,409 --> 00:01:44,009
now this vulnerability was in related to

26
00:01:42,299 --> 00:01:46,679
what's called the spring expression

27
00:01:44,009 --> 00:01:49,469
language or spell which is a type of

28
00:01:46,679 --> 00:01:51,990
language that can be used internally in

29
00:01:49,469 --> 00:01:54,479
spraying to access certain bits of

30
00:01:51,990 --> 00:01:58,770
information now the vulnerability occurs

31
00:01:54,479 --> 00:02:01,289
when we treat incoming user data as an

32
00:01:58,770 --> 00:02:04,229
expression that we evaluate which gives

33
00:02:01,289 --> 00:02:05,490
rise to a remote code execution now this

34
00:02:04,229 --> 00:02:07,649
particular vulnerability was a remote

35
00:02:05,490 --> 00:02:10,560
code execution which allowed any user or

36
00:02:07,649 --> 00:02:14,180
any visitor to your website to craft a

37
00:02:10,560 --> 00:02:17,630
HTTP request to effectively run any

38
00:02:14,180 --> 00:02:19,380
command they want on your server this

39
00:02:17,630 --> 00:02:23,460
particular vulnerability actually

40
00:02:19,380 --> 00:02:26,640
required to request in sequence but you

41
00:02:23,460 --> 00:02:30,590
could saw run anything you wanted so a

42
00:02:26,640 --> 00:02:33,440
reported the vulnerability to pivotal

43
00:02:30,590 --> 00:02:35,909
and on the 21st of September pivotal

44
00:02:33,440 --> 00:02:39,840
released a patch that fixed the

45
00:02:35,909 --> 00:02:41,310
vulnerability and they also got a CVE

46
00:02:39,840 --> 00:02:44,730
allocated for it

47
00:02:41,310 --> 00:02:47,220
made an announcement now the day after

48
00:02:44,730 --> 00:02:51,859
that my colleague took a look at the

49
00:02:47,220 --> 00:02:54,440
patch realized it wasn't really a patch

50
00:02:51,860 --> 00:02:57,720
didn't really fix the vulnerability and

51
00:02:54,440 --> 00:03:00,030
he updated his exploit to take a

52
00:02:57,720 --> 00:03:01,230
slightly different code path and still

53
00:03:00,030 --> 00:03:04,349
trigger the RCE and send that

54
00:03:01,230 --> 00:03:08,099
information to pivotal a few days after

55
00:03:04,349 --> 00:03:09,839
that pivotal this time rather than going

56
00:03:08,099 --> 00:03:12,540
ahead in public publishing it straight

57
00:03:09,840 --> 00:03:15,120
away he privately sent a details of the

58
00:03:12,540 --> 00:03:18,298
patch to me for him to verify whether or

59
00:03:15,120 --> 00:03:20,100
not it was actually complete the next

60
00:03:18,299 --> 00:03:23,540
day Mary discovered it was incomplete

61
00:03:20,100 --> 00:03:25,799
and sent an updated exploit to pivotal

62
00:03:23,540 --> 00:03:27,569
it was at this point they decided that

63
00:03:25,799 --> 00:03:30,599
their approach wasn't really working and

64
00:03:27,569 --> 00:03:33,208
and decided to actually refactor that

65
00:03:30,599 --> 00:03:34,440
part of the codebase to significantly

66
00:03:33,209 --> 00:03:37,200
reduce the chances of those sorts of

67
00:03:34,440 --> 00:03:39,090
mistakes happening and then on the 25th

68
00:03:37,200 --> 00:03:41,880
of October they actually released their

69
00:03:39,090 --> 00:03:44,730
final patch which did address the

70
00:03:41,880 --> 00:03:45,980
vulnerability properly let me tell you a

71
00:03:44,730 --> 00:03:51,660
different story

72
00:03:45,980 --> 00:03:54,630
also about some vulnerabilities so on

73
00:03:51,660 --> 00:03:56,910
the 27th of April 2016 there was a CVE

74
00:03:54,630 --> 00:04:00,019
in Apache struts - that was announced

75
00:03:56,910 --> 00:04:03,840
and the CVE works similarly to the ones

76
00:04:00,019 --> 00:04:06,120
previously in spring what happened here

77
00:04:03,840 --> 00:04:07,829
is Apache had this language called

78
00:04:06,120 --> 00:04:10,650
adrianel which works similar to spell

79
00:04:07,829 --> 00:04:12,329
which is supposed to be predominately

80
00:04:10,650 --> 00:04:14,069
used internally for an application and

81
00:04:12,329 --> 00:04:17,039
not exposed to the user the

82
00:04:14,069 --> 00:04:18,810
vulnerability arised when Apache was

83
00:04:17,039 --> 00:04:21,149
treating user data is an expression and

84
00:04:18,810 --> 00:04:23,070
evaluating it allowing the user to run

85
00:04:21,149 --> 00:04:30,179
anything they wanted on the struts

86
00:04:23,070 --> 00:04:32,700
server on the 12th of May 2016 less than

87
00:04:30,180 --> 00:04:36,510
a month later a new RCE was discovered

88
00:04:32,700 --> 00:04:39,840
that was triggered by interpreting user

89
00:04:36,510 --> 00:04:42,419
data as adrianel on the 20th of June

90
00:04:39,840 --> 00:04:46,500
2016 a new CVE was discovered and

91
00:04:42,419 --> 00:04:49,830
announced that arises when user data is

92
00:04:46,500 --> 00:04:53,039
treated as an adrenal expression on the

93
00:04:49,830 --> 00:04:55,190
19th of March 2017 and RCE was announced

94
00:04:53,039 --> 00:04:59,180
because they were treating you

95
00:04:55,190 --> 00:05:03,050
data as an adrianel expression and again

96
00:04:59,180 --> 00:05:05,750
on the 22nd of September this time three

97
00:05:03,050 --> 00:05:08,030
separate reports I believe from a couple

98
00:05:05,750 --> 00:05:10,120
of former names you see earlier on in

99
00:05:08,030 --> 00:05:13,090
the timeline

100
00:05:10,120 --> 00:05:15,440
another RCE another code path

101
00:05:13,090 --> 00:05:18,409
interpreting user data as a Janelle and

102
00:05:15,440 --> 00:05:19,640
then on the 24th of September my

103
00:05:18,410 --> 00:05:21,340
coworker mo who discovered the

104
00:05:19,640 --> 00:05:25,340
vulnerability on the previous slide

105
00:05:21,340 --> 00:05:27,530
reported a new RCE to Apache which

106
00:05:25,340 --> 00:05:29,239
treats the user data as AG now and

107
00:05:27,530 --> 00:05:31,599
there's only so much room I have on my

108
00:05:29,240 --> 00:05:34,040
slide but this actually isn't the

109
00:05:31,600 --> 00:05:37,040
complete list of remote code execution

110
00:05:34,040 --> 00:05:40,070
vulnerabilities due to interpreting use

111
00:05:37,040 --> 00:05:43,160
it original' these five CVEs

112
00:05:40,070 --> 00:05:47,330
are just some of the other ones that do

113
00:05:43,160 --> 00:05:49,910
that and it might seem like I'm

114
00:05:47,330 --> 00:05:52,190
potentially picking on pivotal or Apache

115
00:05:49,910 --> 00:05:54,190
here but I'm really not this is

116
00:05:52,190 --> 00:05:57,110
something that is quite systemic

117
00:05:54,190 --> 00:06:00,680
throughout all of software development

118
00:05:57,110 --> 00:06:03,380
anyone that has done any large software

119
00:06:00,680 --> 00:06:09,340
project that has had a significant user

120
00:06:03,380 --> 00:06:15,169
base probably feels some recognition

121
00:06:09,340 --> 00:06:16,460
with with these two stories so we're

122
00:06:15,169 --> 00:06:18,560
kind of playing the game of whack-a-mole

123
00:06:16,460 --> 00:06:19,849
like this cat is here we're seeing

124
00:06:18,560 --> 00:06:21,410
something come up and we were like

125
00:06:19,850 --> 00:06:25,130
rushing to fix it and then get it out

126
00:06:21,410 --> 00:06:27,110
the door and repaired and then it pops

127
00:06:25,130 --> 00:06:31,610
is hell up again and then fix it again

128
00:06:27,110 --> 00:06:35,540
and so on and so forth and this isn't

129
00:06:31,610 --> 00:06:36,650
really great the more the more that we

130
00:06:35,540 --> 00:06:38,210
do this the more we sort of like

131
00:06:36,650 --> 00:06:40,219
reacting and responding to things the

132
00:06:38,210 --> 00:06:42,560
less were actually able to focus on

133
00:06:40,220 --> 00:06:45,500
properly securing things so how can we

134
00:06:42,560 --> 00:06:46,820
solve this how do we like prevent the

135
00:06:45,500 --> 00:06:47,930
fires from starting rather than just

136
00:06:46,820 --> 00:06:51,500
trying to put them out when we notice

137
00:06:47,930 --> 00:06:52,850
them well what if we used the

138
00:06:51,500 --> 00:06:55,090
information of these new vulnerabilities

139
00:06:52,850 --> 00:07:00,500
as they come in as an opportunity

140
00:06:55,090 --> 00:07:03,349
instead what if when a new mistake is

141
00:07:00,500 --> 00:07:04,729
discovered you know we say to ourselves

142
00:07:03,350 --> 00:07:07,610
I wonder if this mistake is happening

143
00:07:04,729 --> 00:07:10,250
anywhere else and we try and find this

144
00:07:07,610 --> 00:07:11,120
see where these mistakes are once you

145
00:07:10,250 --> 00:07:13,879
found the root cause of the

146
00:07:11,120 --> 00:07:15,680
vulnerability so they could for example

147
00:07:13,879 --> 00:07:18,259
be something architectural II that means

148
00:07:15,680 --> 00:07:19,669
that the son class is more a certain

149
00:07:18,259 --> 00:07:21,590
class of vulnerability is more likely to

150
00:07:19,669 --> 00:07:23,180
happen for your application your use of

151
00:07:21,590 --> 00:07:24,650
C for example might increase your

152
00:07:23,180 --> 00:07:27,680
chances of having memory corruption

153
00:07:24,650 --> 00:07:29,929
issues using something like Apache

154
00:07:27,680 --> 00:07:32,530
adrianel or Spring expression language

155
00:07:29,930 --> 00:07:37,069
may make you more vulnerable to RCE

156
00:07:32,530 --> 00:07:38,479
vulnerabilities over HTTP so you should

157
00:07:37,069 --> 00:07:40,719
try to find some of the mistakes and the

158
00:07:38,479 --> 00:07:43,279
chances are that you will find something

159
00:07:40,719 --> 00:07:45,139
and companies such as Google and

160
00:07:43,279 --> 00:07:48,529
Microsoft here have been doing this for

161
00:07:45,139 --> 00:07:53,210
a while now call this process variant

162
00:07:48,529 --> 00:07:55,250
analysis so this is a quote from a blog

163
00:07:53,210 --> 00:07:57,799
post by Steven hunter of the Microsoft

164
00:07:55,250 --> 00:07:59,210
Security Response Center who deal with a

165
00:07:57,800 --> 00:08:01,219
lot of Microsoft's incoming

166
00:07:59,210 --> 00:08:04,370
vulnerability reports and try arching

167
00:08:01,219 --> 00:08:06,469
and getting fixes out and he says after

168
00:08:04,370 --> 00:08:08,750
doing root cause analysis our next step

169
00:08:06,469 --> 00:08:10,460
is variant analysis finding and

170
00:08:08,750 --> 00:08:12,319
investigating any variants of the

171
00:08:10,460 --> 00:08:13,878
vulnerability it's important that we

172
00:08:12,319 --> 00:08:16,219
find all such variants and patch them

173
00:08:13,879 --> 00:08:17,719
simultaneously otherwise we bear the

174
00:08:16,219 --> 00:08:20,659
risk of these being exploited in the

175
00:08:17,719 --> 00:08:22,250
wild so it's a stage of their

176
00:08:20,659 --> 00:08:25,069
vulnerability response process that

177
00:08:22,250 --> 00:08:27,199
happens before making details of a

178
00:08:25,069 --> 00:08:29,319
vulnerability or patch public so they

179
00:08:27,199 --> 00:08:32,289
can patch the original vulnerability and

180
00:08:29,319 --> 00:08:35,300
all of the variants simultaneously

181
00:08:32,289 --> 00:08:37,729
because if they don't do this once the

182
00:08:35,299 --> 00:08:40,789
patch is released other people will take

183
00:08:37,729 --> 00:08:42,500
it upon themselves to find variants of

184
00:08:40,789 --> 00:08:45,709
these vulnerabilities and if possible

185
00:08:42,500 --> 00:08:49,430
exploit them and they they know this all

186
00:08:45,709 --> 00:08:51,800
too well so how do you actually perform

187
00:08:49,430 --> 00:08:54,560
very Nasus how do you take a known

188
00:08:51,800 --> 00:08:59,029
vulnerability and find other variants of

189
00:08:54,560 --> 00:09:01,219
it well to be honest until recently most

190
00:08:59,029 --> 00:09:03,199
of the big players have predominately

191
00:09:01,220 --> 00:09:05,540
been relying on a lot of manual work and

192
00:09:03,199 --> 00:09:08,510
by security response teams to try and

193
00:09:05,540 --> 00:09:10,730
find variants focusing on particularly

194
00:09:08,510 --> 00:09:12,260
sensitive areas of the code base where

195
00:09:10,730 --> 00:09:14,810
vulnerabilities are more likely to show

196
00:09:12,260 --> 00:09:16,430
up manually checking how data flows

197
00:09:14,810 --> 00:09:18,199
throughout the application using

198
00:09:16,430 --> 00:09:19,880
techniques like looking at the control

199
00:09:18,199 --> 00:09:21,180
flow which is you know looking at

200
00:09:19,880 --> 00:09:23,160
conditionals seeing

201
00:09:21,180 --> 00:09:26,040
what condition certain parts of the code

202
00:09:23,160 --> 00:09:27,870
execute looking at data flow like

203
00:09:26,040 --> 00:09:29,339
tracking data flowing through the

204
00:09:27,870 --> 00:09:32,370
application through variable assignments

205
00:09:29,340 --> 00:09:33,960
for through function calls etc and doing

206
00:09:32,370 --> 00:09:35,430
stuff like range analysis looking at the

207
00:09:33,960 --> 00:09:38,730
number of the certain values that a

208
00:09:35,430 --> 00:09:39,689
particular variable can take and seeing

209
00:09:38,730 --> 00:09:42,960
if the bounds are being tracked

210
00:09:39,690 --> 00:09:45,410
correctly stuff like that and one of the

211
00:09:42,960 --> 00:09:47,850
most important tools for doing this

212
00:09:45,410 --> 00:09:50,790
basic text search tools like grep or a

213
00:09:47,850 --> 00:09:54,030
wk and something that comes in extremely

214
00:09:50,790 --> 00:09:56,490
handy as well our IDE s that have a much

215
00:09:54,030 --> 00:09:57,510
more broader or much better

216
00:09:56,490 --> 00:09:59,580
understanding of the language you're

217
00:09:57,510 --> 00:10:01,410
dealing with where they have core graphs

218
00:09:59,580 --> 00:10:03,420
you can do jump to death for definition

219
00:10:01,410 --> 00:10:05,850
you can look at references it really

220
00:10:03,420 --> 00:10:08,280
helps you jump around the stack jump

221
00:10:05,850 --> 00:10:11,360
around the call graph and track data as

222
00:10:08,280 --> 00:10:13,560
it flows them as you do manual analysis

223
00:10:11,360 --> 00:10:18,230
now you might be thinking this sounds

224
00:10:13,560 --> 00:10:20,790
like a lot of work you wouldn't be wrong

225
00:10:18,230 --> 00:10:22,620
doing a lot of manual analysis can be

226
00:10:20,790 --> 00:10:25,020
pretty difficult yet it hasn't

227
00:10:22,620 --> 00:10:27,210
necessarily stopped these companies in

228
00:10:25,020 --> 00:10:28,829
the past doing exactly that putting a

229
00:10:27,210 --> 00:10:30,600
lot of man-hours into trying to find

230
00:10:28,830 --> 00:10:32,460
these things and effectively that's what

231
00:10:30,600 --> 00:10:34,230
companies like organizations like

232
00:10:32,460 --> 00:10:36,180
project zero are doing there they have

233
00:10:34,230 --> 00:10:37,830
some tools like fuzzing and stuff but a

234
00:10:36,180 --> 00:10:39,630
lot of what they're looking at is just

235
00:10:37,830 --> 00:10:40,800
manually looking at the code trying to

236
00:10:39,630 --> 00:10:45,330
understand it and see if it's doing

237
00:10:40,800 --> 00:10:48,120
something dodgy so could we do anything

238
00:10:45,330 --> 00:10:50,100
better than this I mean it's repetitive

239
00:10:48,120 --> 00:10:52,260
and time-consuming requires lots of

240
00:10:50,100 --> 00:10:53,400
iterative exploration you know you're

241
00:10:52,260 --> 00:10:54,840
clicking through function of the

242
00:10:53,400 --> 00:10:57,720
function after functionally see where

243
00:10:54,840 --> 00:11:00,000
the data goes and it's obviously prone

244
00:10:57,720 --> 00:11:02,070
to human error that the more complex the

245
00:11:00,000 --> 00:11:03,870
mistake is that you're looking for or

246
00:11:02,070 --> 00:11:05,480
the larger the code base or the closer

247
00:11:03,870 --> 00:11:07,560
the deadline that you need to know

248
00:11:05,480 --> 00:11:10,050
whether there are any other mistakes by

249
00:11:07,560 --> 00:11:11,969
is like the more likely it is that

250
00:11:10,050 --> 00:11:14,300
something will get missed that'll be a

251
00:11:11,970 --> 00:11:18,210
vulnerability that remains undiscovered

252
00:11:14,300 --> 00:11:20,819
it's also not scalable as the size of a

253
00:11:18,210 --> 00:11:22,740
code base increases manually checking

254
00:11:20,820 --> 00:11:24,450
for a class of vulnerability every

255
00:11:22,740 --> 00:11:26,460
single time anyone is discovered becomes

256
00:11:24,450 --> 00:11:30,090
completely infeasible particularly as

257
00:11:26,460 --> 00:11:33,590
security application security teams are

258
00:11:30,090 --> 00:11:38,660
often like so much smaller

259
00:11:33,590 --> 00:11:40,760
than the development teams and finally

260
00:11:38,660 --> 00:11:42,800
as your list of mistakes that you're

261
00:11:40,760 --> 00:11:45,170
finding the list of classes of mistakes

262
00:11:42,800 --> 00:11:46,370
T of finding grows over time the list of

263
00:11:45,170 --> 00:11:48,229
things you need to remember or your

264
00:11:46,370 --> 00:11:51,980
developers need a room to check our code

265
00:11:48,230 --> 00:11:52,970
review also increases and so the code

266
00:11:51,980 --> 00:11:56,800
review process will just become

267
00:11:52,970 --> 00:12:00,260
completely slow and painful or

268
00:11:56,800 --> 00:12:03,859
insufficient if you do that and to be

269
00:12:00,260 --> 00:12:05,360
honest developers will mostly I mean I

270
00:12:03,860 --> 00:12:06,620
certainly don't check every single thing

271
00:12:05,360 --> 00:12:10,520
I need to remember whenever I do code

272
00:12:06,620 --> 00:12:12,589
review so what can you do if variant

273
00:12:10,520 --> 00:12:14,180
analysis is critical for you if it's

274
00:12:12,589 --> 00:12:16,970
really necessary to find all of the

275
00:12:14,180 --> 00:12:21,439
vulnerabilities coming in and yet doing

276
00:12:16,970 --> 00:12:26,870
so isn't feasible can we automate it

277
00:12:21,440 --> 00:12:29,510
somehow what if there is a way that we

278
00:12:26,870 --> 00:12:31,760
could describe a mistake that allows us

279
00:12:29,510 --> 00:12:35,800
to automatically find other instances of

280
00:12:31,760 --> 00:12:38,210
that same mistake throughout our code a

281
00:12:35,800 --> 00:12:40,339
mistake that described a description

282
00:12:38,210 --> 00:12:42,200
that includes how data flow should look

283
00:12:40,339 --> 00:12:44,000
or how different parts of the code are

284
00:12:42,200 --> 00:12:46,670
related to each other including semantic

285
00:12:44,000 --> 00:12:47,810
information what we could do then is we

286
00:12:46,670 --> 00:12:49,790
could run it across the entire code base

287
00:12:47,810 --> 00:12:52,040
we could run it across multiple code

288
00:12:49,790 --> 00:12:55,459
bases we could even run it in the future

289
00:12:52,040 --> 00:12:58,939
to prevent reoccurrences of these

290
00:12:55,460 --> 00:13:00,650
mistakes well it turns out that there

291
00:12:58,940 --> 00:13:03,110
are a few tools that allow you to do

292
00:13:00,650 --> 00:13:04,939
exactly that so for example clanked ID

293
00:13:03,110 --> 00:13:07,040
which is part of the clang compiler

294
00:13:04,940 --> 00:13:09,740
allows you to extend it with certain

295
00:13:07,040 --> 00:13:13,939
rules to catch things at compile time

296
00:13:09,740 --> 00:13:15,410
and it and you can include both semantic

297
00:13:13,940 --> 00:13:19,810
and syntactic information and this rule

298
00:13:15,410 --> 00:13:21,709
says linters as well increasingly

299
00:13:19,810 --> 00:13:23,030
including more and more semantic

300
00:13:21,709 --> 00:13:25,579
information to be used in their rule

301
00:13:23,030 --> 00:13:28,220
sets so you can specify restrictions on

302
00:13:25,580 --> 00:13:30,620
what the code should look like there are

303
00:13:28,220 --> 00:13:32,480
also a number of technologies that

304
00:13:30,620 --> 00:13:35,870
emerging that allow you to write queries

305
00:13:32,480 --> 00:13:37,550
to look for things over source code and

306
00:13:35,870 --> 00:13:40,220
my company is one such company that

307
00:13:37,550 --> 00:13:42,469
provides a solution but I'm not going to

308
00:13:40,220 --> 00:13:44,330
go into detail compression in this talk

309
00:13:42,470 --> 00:13:45,890
and I just want you to know that these

310
00:13:44,330 --> 00:13:47,380
tools exist and people are starting to

311
00:13:45,890 --> 00:13:51,949
use them

312
00:13:47,380 --> 00:13:53,030
and I'm gonna show you how so next on

313
00:13:51,950 --> 00:13:56,090
the agenda is I'm going to show you a

314
00:13:53,030 --> 00:13:59,540
example from that same Microsoft blog

315
00:13:56,090 --> 00:14:03,680
post that I quoted from earlier of how

316
00:13:59,540 --> 00:14:07,880
they wrote a a semantic code query to

317
00:14:03,680 --> 00:14:10,160
look for a mistake so this is some

318
00:14:07,880 --> 00:14:13,850
example code from chakra which is the

319
00:14:10,160 --> 00:14:15,800
JavaScript engine behind edge and it

320
00:14:13,850 --> 00:14:18,670
also powers a bunch of the other Windows

321
00:14:15,800 --> 00:14:22,189
applications that are in in JavaScript

322
00:14:18,670 --> 00:14:24,229
so this C++ function on the screen is

323
00:14:22,190 --> 00:14:27,740
something that's made available and can

324
00:14:24,230 --> 00:14:28,940
be called from within JavaScript so they

325
00:14:27,740 --> 00:14:30,710
found a vulnerability here that I'm

326
00:14:28,940 --> 00:14:37,010
gonna I'm gonna run through and explain

327
00:14:30,710 --> 00:14:40,340
to you so the first thing that this

328
00:14:37,010 --> 00:14:42,980
function does is it looks at one of the

329
00:14:40,340 --> 00:14:47,120
arguments that's passed to it and it

330
00:14:42,980 --> 00:14:49,190
assigns the pointer or the address and

331
00:14:47,120 --> 00:14:51,650
the size of a block of memory that

332
00:14:49,190 --> 00:14:54,860
represents a JavaScript array buffer and

333
00:14:51,650 --> 00:14:59,540
it assigns them to two variables P

334
00:14:54,860 --> 00:15:01,070
buffer and buffer size following that

335
00:14:59,540 --> 00:15:02,900
the next thing it does is it calls a

336
00:15:01,070 --> 00:15:04,850
function where it tries to calculate the

337
00:15:02,900 --> 00:15:06,949
integer value of the second argument

338
00:15:04,850 --> 00:15:10,100
that's passed to it now the way that it

339
00:15:06,950 --> 00:15:12,340
does this is by calling the value of

340
00:15:10,100 --> 00:15:14,990
method of the object that's passed to it

341
00:15:12,340 --> 00:15:17,210
now in JavaScript it's possible to

342
00:15:14,990 --> 00:15:20,510
overwrite the value of method of an

343
00:15:17,210 --> 00:15:23,150
object to run your own code so we could

344
00:15:20,510 --> 00:15:26,530
potentially be running any arbitrary

345
00:15:23,150 --> 00:15:30,170
JavaScript code with this function call

346
00:15:26,530 --> 00:15:32,959
so for example you could in that

347
00:15:30,170 --> 00:15:35,329
overridden method decide to free the

348
00:15:32,960 --> 00:15:40,570
array buffer so that P bar becomes a

349
00:15:35,330 --> 00:15:44,060
dangling pointer and then at that point

350
00:15:40,570 --> 00:15:47,540
when you try and use the pointer you

351
00:15:44,060 --> 00:15:49,130
have a memory corruption issue now when

352
00:15:47,540 --> 00:15:52,209
Microsoft were assessing this

353
00:15:49,130 --> 00:15:56,060
vulnerability and they decided it was

354
00:15:52,210 --> 00:15:57,740
critical they pretty easily create an

355
00:15:56,060 --> 00:15:58,959
exploit that managed to crash the

356
00:15:57,740 --> 00:16:01,990
browser

357
00:15:58,960 --> 00:16:03,220
and it was their suspicion that it

358
00:16:01,990 --> 00:16:05,350
wouldn't take much more effort to create

359
00:16:03,220 --> 00:16:08,650
a full code execution vulnerability with

360
00:16:05,350 --> 00:16:10,150
this this is an example an illustrative

361
00:16:08,650 --> 00:16:12,670
example of what the JavaScript exploit

362
00:16:10,150 --> 00:16:15,819
look like you can see that we have an

363
00:16:12,670 --> 00:16:18,849
array buffer at the top there we are

364
00:16:15,820 --> 00:16:22,920
creating a value of function for this

365
00:16:18,850 --> 00:16:25,450
object and that frees the buffer and

366
00:16:22,920 --> 00:16:29,319
then calling the vulnerable function

367
00:16:25,450 --> 00:16:31,210
later on so Microsoft's found this

368
00:16:29,320 --> 00:16:34,180
vulnerability and they diagnosed it they

369
00:16:31,210 --> 00:16:36,280
found the root cause but they wanted to

370
00:16:34,180 --> 00:16:37,630
know whether they had any similar things

371
00:16:36,280 --> 00:16:38,800
elsewhere in the code base they wanted

372
00:16:37,630 --> 00:16:43,180
to know if a similar mistake had been

373
00:16:38,800 --> 00:16:46,030
made elsewhere so so they as part of the

374
00:16:43,180 --> 00:16:49,930
very analysis process write a query for

375
00:16:46,030 --> 00:16:51,850
it so this is what the query looked like

376
00:16:49,930 --> 00:16:56,979
I modified it a little bit to make sure

377
00:16:51,850 --> 00:17:00,220
that it completely fit on the slide yeah

378
00:16:56,980 --> 00:17:02,290
so anyone that's interacted with any

379
00:17:00,220 --> 00:17:04,690
database systems before in any query

380
00:17:02,290 --> 00:17:07,720
like SQL or something will find some

381
00:17:04,690 --> 00:17:10,510
pretty similar constructs here firstly

382
00:17:07,720 --> 00:17:12,730
we have a from statement that lists all

383
00:17:10,510 --> 00:17:14,770
the relations that were interested in

384
00:17:12,730 --> 00:17:16,690
looking at I remember that we routin

385
00:17:14,770 --> 00:17:19,720
code is data here so we're actually it's

386
00:17:16,690 --> 00:17:22,570
a database of code so in this case we're

387
00:17:19,720 --> 00:17:27,550
looking at variables assignments to

388
00:17:22,569 --> 00:17:29,560
array buffer pointers function calls and

389
00:17:27,550 --> 00:17:32,020
accesses to variables and accesses both

390
00:17:29,560 --> 00:17:35,740
reads and writes to variables in a local

391
00:17:32,020 --> 00:17:38,230
scope we have a where condition that

392
00:17:35,740 --> 00:17:39,910
lists what the requirements are for

393
00:17:38,230 --> 00:17:42,700
things to be outputted from the query

394
00:17:39,910 --> 00:17:45,130
and then we have a select clause that

395
00:17:42,700 --> 00:17:48,520
lists all the different columns that

396
00:17:45,130 --> 00:17:51,580
were interested in outfitting jumping

397
00:17:48,520 --> 00:17:53,170
into the where condition here line four

398
00:17:51,580 --> 00:17:56,800
effectively ensures that the pointer

399
00:17:53,170 --> 00:17:59,590
assignment and the variable use later on

400
00:17:56,800 --> 00:18:02,620
are talking about the same variable so

401
00:17:59,590 --> 00:18:04,300
make sure here that P buffer and P

402
00:18:02,620 --> 00:18:08,010
buffer at the top and the bottom are

403
00:18:04,300 --> 00:18:08,010
both the same variable

404
00:18:08,250 --> 00:18:15,910
Lane six ensures that the function is a

405
00:18:12,340 --> 00:18:17,800
function that may execute JavaScript now

406
00:18:15,910 --> 00:18:19,330
rather than enumerate in every single

407
00:18:17,800 --> 00:18:21,760
function in chakra that could call

408
00:18:19,330 --> 00:18:22,960
javascript there are lots of them as you

409
00:18:21,760 --> 00:18:25,990
can imagine it's a JavaScript

410
00:18:22,960 --> 00:18:27,400
interpreter the security researchers

411
00:18:25,990 --> 00:18:30,040
were aware that every single function

412
00:18:27,400 --> 00:18:31,560
that does this may eventually call this

413
00:18:30,040 --> 00:18:36,670
function called method called primitive

414
00:18:31,560 --> 00:18:39,520
so here they say and the the restriction

415
00:18:36,670 --> 00:18:42,700
is that cool the function call needs to

416
00:18:39,520 --> 00:18:44,260
be a call to a function that eventually

417
00:18:42,700 --> 00:18:45,790
calls method to primitive method called

418
00:18:44,260 --> 00:18:47,560
program so it's either a function that

419
00:18:45,790 --> 00:18:49,540
calls that or it's a function that calls

420
00:18:47,560 --> 00:18:50,620
function that calls that or a function

421
00:18:49,540 --> 00:18:55,300
that calls a function that calls a

422
00:18:50,620 --> 00:18:57,280
function that calls that and so on so

423
00:18:55,300 --> 00:19:01,540
yeah that's referring to this call here

424
00:18:57,280 --> 00:19:04,690
and then the last two conditions simply

425
00:19:01,540 --> 00:19:07,659
say that the call to the function must

426
00:19:04,690 --> 00:19:09,760
happen after the definition yeah so the

427
00:19:07,660 --> 00:19:11,140
definition must come first and then the

428
00:19:09,760 --> 00:19:16,480
called the function must happen later on

429
00:19:11,140 --> 00:19:18,010
and then the use of the people P buffer

430
00:19:16,480 --> 00:19:19,780
variable must happen after the call to

431
00:19:18,010 --> 00:19:22,600
the function so that we can be sure it's

432
00:19:19,780 --> 00:19:29,129
at a point where it might be a memory

433
00:19:22,600 --> 00:19:32,620
corruption issue so in the blog post

434
00:19:29,130 --> 00:19:34,720
Stephen hunter said that when they run

435
00:19:32,620 --> 00:19:36,330
this query they were able to find in

436
00:19:34,720 --> 00:19:40,180
addition to the original vulnerability

437
00:19:36,330 --> 00:19:42,460
for more instances of the same mistake

438
00:19:40,180 --> 00:19:45,130
being made elsewhere in the chakra code

439
00:19:42,460 --> 00:19:48,670
all of which were classified as critical

440
00:19:45,130 --> 00:19:50,170
vulnerabilities so then able to patch

441
00:19:48,670 --> 00:19:53,200
all of the all of them at the same time

442
00:19:50,170 --> 00:19:56,350
and release a single new version with a

443
00:19:53,200 --> 00:19:58,750
single announcement and have pretty good

444
00:19:56,350 --> 00:20:01,469
confidence that there won't be similar

445
00:19:58,750 --> 00:20:01,470
mistakes elsewhere

446
00:20:02,310 --> 00:20:08,710
so that that example was pretty specific

447
00:20:05,140 --> 00:20:10,000
to the chakra code base you might for

448
00:20:08,710 --> 00:20:13,230
example be able to do something similar

449
00:20:10,000 --> 00:20:18,060
for other JavaScript engines like VA or

450
00:20:13,230 --> 00:20:20,380
what gecko uses other use for Firefox

451
00:20:18,060 --> 00:20:21,520
but there are definitely kinds of

452
00:20:20,380 --> 00:20:24,610
mistakes that are a lot more

453
00:20:21,520 --> 00:20:26,050
general than that for example you might

454
00:20:24,610 --> 00:20:27,969
have a mistake that many people make

455
00:20:26,050 --> 00:20:31,540
there might be a misuse of a language

456
00:20:27,970 --> 00:20:32,950
feature or you might have a mistake that

457
00:20:31,540 --> 00:20:36,550
comes from a misunderstanding of how an

458
00:20:32,950 --> 00:20:37,960
API works or a framework and in those

459
00:20:36,550 --> 00:20:41,050
cases you can actually go a step further

460
00:20:37,960 --> 00:20:42,610
in as well as like writing some or just

461
00:20:41,050 --> 00:20:44,710
writing some description forms for a

462
00:20:42,610 --> 00:20:46,360
mistake and using it yourself you can

463
00:20:44,710 --> 00:20:47,620
then share that make that open source

464
00:20:46,360 --> 00:20:50,409
make it available to the world so that

465
00:20:47,620 --> 00:20:52,899
security teams and developers from other

466
00:20:50,410 --> 00:20:54,910
organizations or open-source developers

467
00:20:52,900 --> 00:20:56,620
can take advantage of the research that

468
00:20:54,910 --> 00:20:59,320
you've had and the mistakes that you've

469
00:20:56,620 --> 00:21:04,000
made so I'm gonna talk about another

470
00:20:59,320 --> 00:21:06,580
story Oh before I do that I have a

471
00:21:04,000 --> 00:21:08,950
couple of bullet points first ones were

472
00:21:06,580 --> 00:21:10,929
under said second one in addition to of

473
00:21:08,950 --> 00:21:12,730
course sharing your own knowledge you

474
00:21:10,930 --> 00:21:14,170
can use the knowledge that other people

475
00:21:12,730 --> 00:21:15,910
are sharing if there's a security

476
00:21:14,170 --> 00:21:18,190
research team from Microsoft and you're

477
00:21:15,910 --> 00:21:19,630
at Google for example and Microsoft

478
00:21:18,190 --> 00:21:22,570
published something you can then use

479
00:21:19,630 --> 00:21:24,160
that to check your own code to see if

480
00:21:22,570 --> 00:21:27,520
you're making similar mistakes to the

481
00:21:24,160 --> 00:21:30,370
ones that they have right now I'm going

482
00:21:27,520 --> 00:21:34,120
to talk about another story so here here

483
00:21:30,370 --> 00:21:38,020
is head of zip slip a couple two three

484
00:21:34,120 --> 00:21:44,020
so this is an interesting vulnerability

485
00:21:38,020 --> 00:21:46,270
class back in June of 2018 a company

486
00:21:44,020 --> 00:21:48,160
called snick who does dependency

487
00:21:46,270 --> 00:21:49,900
analysis to make sure that dependencies

488
00:21:48,160 --> 00:21:52,380
that you're running are up-to-date and

489
00:21:49,900 --> 00:21:56,070
don't have any vulnerabilities they

490
00:21:52,380 --> 00:21:58,210
found a whirring the large number of

491
00:21:56,070 --> 00:22:01,780
mistakes being made that all seem to

492
00:21:58,210 --> 00:22:03,160
kind of be the same mistake so like any

493
00:22:01,780 --> 00:22:11,050
good vulnerability they designed a logo

494
00:22:03,160 --> 00:22:14,020
for it and went put a lot of effort into

495
00:22:11,050 --> 00:22:16,210
trying to find as many places that they

496
00:22:14,020 --> 00:22:18,490
can in like high-impact projects and

497
00:22:16,210 --> 00:22:20,770
disclose them before making the public

498
00:22:18,490 --> 00:22:23,220
announcement so I'm going to quickly

499
00:22:20,770 --> 00:22:26,310
explain what the vulnerability was so

500
00:22:23,220 --> 00:22:30,130
who here is ever in any code that

501
00:22:26,310 --> 00:22:33,000
extracts an archive one two three four

502
00:22:30,130 --> 00:22:33,000
okay a bunch of you

503
00:22:33,279 --> 00:22:40,250
so the way the zip files work are

504
00:22:36,559 --> 00:22:43,629
they're effectively a list of file paths

505
00:22:40,250 --> 00:22:47,539
paired with the contents of those files

506
00:22:43,629 --> 00:22:49,809
now file paths are simply strings

507
00:22:47,539 --> 00:22:52,850
they're just they're just some text

508
00:22:49,809 --> 00:22:54,110
there isn't actually any more structure

509
00:22:52,850 --> 00:22:57,620
than that in zip file so when you have

510
00:22:54,110 --> 00:23:00,199
directories and zip files it's they

511
00:22:57,620 --> 00:23:01,729
don't really exist and the knot is not

512
00:23:00,200 --> 00:23:07,100
really a tree like structure it's just a

513
00:23:01,730 --> 00:23:09,049
list so what that means is you are in

514
00:23:07,100 --> 00:23:13,580
these paths you actually have like

515
00:23:09,049 --> 00:23:15,860
slashes like path components and what

516
00:23:13,580 --> 00:23:19,490
that also means is you could potentially

517
00:23:15,860 --> 00:23:24,350
put path traversal path components in

518
00:23:19,490 --> 00:23:29,419
there such as dot dot slash now who's

519
00:23:24,350 --> 00:23:33,019
familiar with what slash does cool it

520
00:23:29,419 --> 00:23:35,450
goes to the parent directory right so

521
00:23:33,019 --> 00:23:41,059
you might start to feel where this is

522
00:23:35,450 --> 00:23:45,950
going if you are not careful and you're

523
00:23:41,059 --> 00:23:50,450
trying to unzip as if file when you join

524
00:23:45,950 --> 00:23:54,259
the destination directory with the path

525
00:23:50,450 --> 00:23:56,809
name from the entry the parent of

526
00:23:54,259 --> 00:24:01,460
wrestles will collapse and unzip the

527
00:23:56,809 --> 00:24:04,519
files to outside of your destination you

528
00:24:01,460 --> 00:24:06,169
could for example if you if you are

529
00:24:04,519 --> 00:24:08,480
unzipping a potentially malicious zip

530
00:24:06,169 --> 00:24:11,779
file and it may be able to override

531
00:24:08,480 --> 00:24:16,279
important user or system files insert

532
00:24:11,779 --> 00:24:19,100
shell scripts reconfigure things for

533
00:24:16,279 --> 00:24:23,629
example anyone who use ansible for

534
00:24:19,100 --> 00:24:25,549
configuration a few people ansible you

535
00:24:23,629 --> 00:24:27,289
may you know a common use case might be

536
00:24:25,549 --> 00:24:28,370
running as a root user on a target

537
00:24:27,289 --> 00:24:34,610
machine that you're installing some

538
00:24:28,370 --> 00:24:38,418
packages on you may decide to unzip a

539
00:24:34,610 --> 00:24:41,330
zip file from a third party which could

540
00:24:38,419 --> 00:24:44,629
potentially be malicious and may

541
00:24:41,330 --> 00:24:45,510
actually override them system files

542
00:24:44,629 --> 00:24:46,860
there so

543
00:24:45,510 --> 00:24:53,129
ansible were one of the projects that

544
00:24:46,860 --> 00:24:54,600
actually had this vulnerability so this

545
00:24:53,130 --> 00:24:58,710
is some example Java code that's

546
00:24:54,600 --> 00:25:00,689
vulnerable to zip slip the problematic

547
00:24:58,710 --> 00:25:02,480
line is this one here where you're

548
00:25:00,690 --> 00:25:08,130
basically joining the destination path

549
00:25:02,480 --> 00:25:09,570
to the path of a particular entry and as

550
00:25:08,130 --> 00:25:13,140
there's no sanitization as you're not

551
00:25:09,570 --> 00:25:16,520
checking at all the contents of the path

552
00:25:13,140 --> 00:25:21,890
this could potentially go anywhere

553
00:25:16,520 --> 00:25:25,110
so after snip made this announcement

554
00:25:21,890 --> 00:25:26,850
Microsoft's were curious to see if they

555
00:25:25,110 --> 00:25:28,010
were making this mistake anywhere you

556
00:25:26,850 --> 00:25:30,840
might be sensing a theme here and

557
00:25:28,010 --> 00:25:34,080
Microsoft like queries so they wrote a

558
00:25:30,840 --> 00:25:35,610
query they wrote a query for c-sharp

559
00:25:34,080 --> 00:25:38,460
that checks whether any of their c-sharp

560
00:25:35,610 --> 00:25:40,830
code potentially does something like

561
00:25:38,460 --> 00:25:45,720
this and that the basic description of

562
00:25:40,830 --> 00:25:49,500
the mistake was find places where data

563
00:25:45,720 --> 00:25:55,040
flows from the path of an entry to an

564
00:25:49,500 --> 00:25:55,040
i/o operation pretty simple conceptually

565
00:25:56,090 --> 00:26:00,000
unsurprisingly they found a number of

566
00:25:58,110 --> 00:26:02,040
vulnerabilities in a bunch of their

567
00:26:00,000 --> 00:26:04,860
projects across their portfolio that

568
00:26:02,040 --> 00:26:09,080
were handling zip files in an unsafe

569
00:26:04,860 --> 00:26:11,939
manner after they fixed a bunch of them

570
00:26:09,080 --> 00:26:14,399
they decided to then open source this

571
00:26:11,940 --> 00:26:17,100
query because it is a very general

572
00:26:14,400 --> 00:26:18,929
purpose query anyone that handling zip

573
00:26:17,100 --> 00:26:20,010
files at all or any applications

574
00:26:18,929 --> 00:26:22,230
handling zip files at all could

575
00:26:20,010 --> 00:26:25,950
potentially be vulnerable so the open

576
00:26:22,230 --> 00:26:30,000
source tip and basically contributed to

577
00:26:25,950 --> 00:26:33,330
this central repository of of queries

578
00:26:30,000 --> 00:26:37,260
and automated checks for mistakes that

579
00:26:33,330 --> 00:26:40,080
have come up in the past my company went

580
00:26:37,260 --> 00:26:43,350
and wrote a few more of these queries

581
00:26:40,080 --> 00:26:47,309
for other languages and we found a bunch

582
00:26:43,350 --> 00:26:51,899
of vulnerabilities in a few dozen open

583
00:26:47,309 --> 00:26:55,908
source projects a large open source

584
00:26:51,900 --> 00:26:55,909
projects that we responsibly displaced

585
00:26:57,190 --> 00:27:05,780
so that's variant analysis now you may

586
00:27:03,200 --> 00:27:07,690
be wondering you know I've talked a bit

587
00:27:05,780 --> 00:27:09,950
about how it works why it's important

588
00:27:07,690 --> 00:27:11,540
but next is like how can you actually

589
00:27:09,950 --> 00:27:12,890
use this as an organization you might be

590
00:27:11,540 --> 00:27:16,250
a security researcher or you might be a

591
00:27:12,890 --> 00:27:19,370
developer or you might be CSO or some

592
00:27:16,250 --> 00:27:24,560
other manager and you need to know how

593
00:27:19,370 --> 00:27:26,870
to how you can actually use this so for

594
00:27:24,560 --> 00:27:29,690
now I'm going to assume that you already

595
00:27:26,870 --> 00:27:32,479
have a security or a workflow in place

596
00:27:29,690 --> 00:27:34,280
for dealing with vulnerabilities say you

597
00:27:32,480 --> 00:27:36,500
might get a vulnerability through pen

598
00:27:34,280 --> 00:27:38,290
testing through a bug bounty through

599
00:27:36,500 --> 00:27:40,670
some audit through something else and

600
00:27:38,290 --> 00:27:42,139
you need to deal with it that that

601
00:27:40,670 --> 00:27:43,580
vulnerability might be known by someone

602
00:27:42,140 --> 00:27:45,980
outside it might be known by a malicious

603
00:27:43,580 --> 00:27:47,629
party and it might be known by the

604
00:27:45,980 --> 00:27:49,640
person that reported it to you who could

605
00:27:47,630 --> 00:27:50,990
be external to the organization I need

606
00:27:49,640 --> 00:27:52,880
to deal with that as soon as possible so

607
00:27:50,990 --> 00:27:56,390
you look at the root cause you

608
00:27:52,880 --> 00:27:59,720
understand what's happening you then fix

609
00:27:56,390 --> 00:28:03,050
that vulnerability and release it

610
00:27:59,720 --> 00:28:05,210
release the patch so the most natural

611
00:28:03,050 --> 00:28:07,159
place for variant analysis to fit in

612
00:28:05,210 --> 00:28:08,480
would be after you have discovered or

613
00:28:07,160 --> 00:28:11,960
after you've diagnosed what the root

614
00:28:08,480 --> 00:28:14,180
causes at this point you can use using

615
00:28:11,960 --> 00:28:17,510
your platform of choice and just

616
00:28:14,180 --> 00:28:19,310
describe the mistake in a way that

617
00:28:17,510 --> 00:28:22,540
allows you to automatically check if

618
00:28:19,310 --> 00:28:26,080
that mistake is being made anywhere else

619
00:28:22,540 --> 00:28:28,820
you can then see what results come up

620
00:28:26,080 --> 00:28:30,080
it's likely for the first few times you

621
00:28:28,820 --> 00:28:32,899
try this there'll be a lot of false

622
00:28:30,080 --> 00:28:36,070
positives and things you didn't really

623
00:28:32,900 --> 00:28:39,920
consider and described in your mistake

624
00:28:36,070 --> 00:28:41,389
so you iterate you improve the query see

625
00:28:39,920 --> 00:28:42,950
what results come up until you've got a

626
00:28:41,390 --> 00:28:46,570
small enough number of results that you

627
00:28:42,950 --> 00:28:49,460
can kind of look through it manually

628
00:28:46,570 --> 00:28:54,590
discover what potential variants you

629
00:28:49,460 --> 00:28:57,290
have at that point fix them and really

630
00:28:54,590 --> 00:28:59,419
it should be at this point that you

631
00:28:57,290 --> 00:29:01,550
deploy your fix wait until you have

632
00:28:59,420 --> 00:29:03,140
fairly good certainty that you've

633
00:29:01,550 --> 00:29:07,580
covered all of the instances of that

634
00:29:03,140 --> 00:29:09,680
same mistake going beyond this now that

635
00:29:07,580 --> 00:29:11,600
you've written an automated check

636
00:29:09,680 --> 00:29:15,800
you can actually start running this

637
00:29:11,600 --> 00:29:17,300
continuously potentially just before

638
00:29:15,800 --> 00:29:19,040
making a release of your software you

639
00:29:17,300 --> 00:29:21,530
might want to check see haven't got any

640
00:29:19,040 --> 00:29:23,059
new problems or any new instances of

641
00:29:21,530 --> 00:29:25,430
that problem we found a couple of years

642
00:29:23,059 --> 00:29:28,190
ago you can you can check you can you

643
00:29:25,430 --> 00:29:29,690
can see if that's the case even better

644
00:29:28,190 --> 00:29:31,790
than that you might incorporate this as

645
00:29:29,690 --> 00:29:34,760
part of your code review process if you

646
00:29:31,790 --> 00:29:37,460
are if your organization uses something

647
00:29:34,760 --> 00:29:40,520
like github or bitbucket or get lab you

648
00:29:37,460 --> 00:29:42,650
could incorporate this so that for every

649
00:29:40,520 --> 00:29:44,559
single code contribution you can check

650
00:29:42,650 --> 00:29:46,340
whether that contribution introduces a

651
00:29:44,559 --> 00:29:50,928
mistake that you're already familiar

652
00:29:46,340 --> 00:29:52,970
with and then of course you can fix it

653
00:29:50,929 --> 00:29:57,410
before it even becomes part of your code

654
00:29:52,970 --> 00:30:00,110
base and then going a step beyond this

655
00:29:57,410 --> 00:30:02,050
once you've written once you've written

656
00:30:00,110 --> 00:30:05,409
some automated checks for some mistakes

657
00:30:02,050 --> 00:30:07,820
open source it share it with the world

658
00:30:05,410 --> 00:30:11,450
allow other security teams and other

659
00:30:07,820 --> 00:30:13,040
development teams to benefit from your

660
00:30:11,450 --> 00:30:17,059
own mistakes benefit from your knowledge

661
00:30:13,040 --> 00:30:19,899
and then finally incorporate other

662
00:30:17,059 --> 00:30:19,899
people's knowledge as well

663
00:30:22,480 --> 00:30:28,240
so maybe you don't have a vulnerability

664
00:30:25,179 --> 00:30:29,799
response process maybe you might be part

665
00:30:28,240 --> 00:30:31,270
of a very small software startup that's

666
00:30:29,799 --> 00:30:32,470
only just getting off the ground you

667
00:30:31,270 --> 00:30:34,570
might not have released a product yet

668
00:30:32,470 --> 00:30:38,320
and you might be working on open source

669
00:30:34,570 --> 00:30:39,610
projects are pretty small one well first

670
00:30:38,320 --> 00:30:42,250
thing to understand is that sooner or

671
00:30:39,610 --> 00:30:43,600
later you probably will be faced with a

672
00:30:42,250 --> 00:30:47,200
situation where you need to deal with

673
00:30:43,600 --> 00:30:48,850
the vulnerability and it's probably a

674
00:30:47,200 --> 00:30:51,160
good idea to have an idea of how you

675
00:30:48,850 --> 00:30:55,870
would go about doing that when the time

676
00:30:51,160 --> 00:30:58,690
comes but in the mean time until you do

677
00:30:55,870 --> 00:31:01,000
have to deal with a vulnerability I will

678
00:30:58,690 --> 00:31:03,490
highly recommend using some free

679
00:31:01,000 --> 00:31:04,600
automated tools to check your code use

680
00:31:03,490 --> 00:31:08,620
all of this knowledge that's been

681
00:31:04,600 --> 00:31:10,418
continuously published and attitude nsrc

682
00:31:08,620 --> 00:31:11,739
have some great blog post detailing the

683
00:31:10,419 --> 00:31:20,919
sorts of mistakes they're dealing with

684
00:31:11,740 --> 00:31:22,720
which is really fascinating so I'm

685
00:31:20,919 --> 00:31:24,880
running through this quite quickly I'm

686
00:31:22,720 --> 00:31:26,620
very aware that everyone is you get to

687
00:31:24,880 --> 00:31:28,120
get on to the after party so there's

688
00:31:26,620 --> 00:31:30,489
only a couple of slides left but I just

689
00:31:28,120 --> 00:31:34,530
want to finish up with just talking a

690
00:31:30,490 --> 00:31:34,530
bit about what variant analysis is not

691
00:31:35,010 --> 00:31:41,230
variant analysis is not a replacement

692
00:31:37,600 --> 00:31:45,070
for good security architecture for

693
00:31:41,230 --> 00:31:47,710
example if you're facing a lot of

694
00:31:45,070 --> 00:31:50,168
different memory corruption issues in

695
00:31:47,710 --> 00:31:52,809
your C application maybe consider

696
00:31:50,169 --> 00:31:56,650
migrating to rust I would not argue

697
00:31:52,809 --> 00:31:58,840
against that if you are seeing lots of

698
00:31:56,650 --> 00:32:00,429
vulnerabilities caused by evaluating

699
00:31:58,840 --> 00:32:03,159
user data or certain kinds of

700
00:32:00,429 --> 00:32:05,710
expressions maybe don't use those

701
00:32:03,160 --> 00:32:10,090
expressions maybe don't use a GL or

702
00:32:05,710 --> 00:32:12,970
spell if you're seeing lots of SQL

703
00:32:10,090 --> 00:32:15,220
injection vulnerabilities maybe switch

704
00:32:12,970 --> 00:32:21,010
to a database library that does also

705
00:32:15,220 --> 00:32:22,830
escaping for you variant analysis is not

706
00:32:21,010 --> 00:32:25,990
a replacement for exploit mitigation

707
00:32:22,830 --> 00:32:29,379
please please use technologies like

708
00:32:25,990 --> 00:32:30,790
address space layout randomization you

709
00:32:29,380 --> 00:32:34,030
want to make it as hard as possible for

710
00:32:30,790 --> 00:32:35,408
when an attacker gets a vulnerability or

711
00:32:34,030 --> 00:32:36,260
finds an exploit you want to make as

712
00:32:35,409 --> 00:32:39,500
hard as possible for

713
00:32:36,260 --> 00:32:41,150
to do anything with it so use address

714
00:32:39,500 --> 00:32:48,470
space layout randomization use things

715
00:32:41,150 --> 00:32:50,630
like a Palmer on Linux etc etc variant

716
00:32:48,470 --> 00:32:53,180
analysis is not a replacement for

717
00:32:50,630 --> 00:32:54,800
existing security practices it does not

718
00:32:53,180 --> 00:32:57,170
replace fuzzing I would highly encourage

719
00:32:54,800 --> 00:32:58,700
you to if you're doing fuzzing to

720
00:32:57,170 --> 00:32:59,930
continue doing fuzzing and add variant

721
00:32:58,700 --> 00:33:02,450
analysis to it it's actually a

722
00:32:59,930 --> 00:33:04,210
compliment you can find something you

723
00:33:02,450 --> 00:33:06,020
can find a vulnerability with fuzzing

724
00:33:04,210 --> 00:33:08,960
look at the root cause of the

725
00:33:06,020 --> 00:33:10,910
vulnerability and then describe it the

726
00:33:08,960 --> 00:33:13,810
mistake and find more of those mistakes

727
00:33:10,910 --> 00:33:16,040
you know it works pretty well together

728
00:33:13,810 --> 00:33:17,870
it's not a replacement for having

729
00:33:16,040 --> 00:33:20,659
vulnerability disclosure and bug bounty

730
00:33:17,870 --> 00:33:23,419
programs I also highly recommend that

731
00:33:20,660 --> 00:33:24,590
you and you do those or you do research

732
00:33:23,420 --> 00:33:27,020
into whether those would be appropriate

733
00:33:24,590 --> 00:33:28,669
for your company it's not a replacement

734
00:33:27,020 --> 00:33:31,370
for auditing your code it's not a

735
00:33:28,670 --> 00:33:34,520
replacement for pen testing or doing

736
00:33:31,370 --> 00:33:37,840
read team exercises it's not a

737
00:33:34,520 --> 00:33:40,340
replacement for unit tests if anything

738
00:33:37,840 --> 00:33:41,780
results for variant analysis can often

739
00:33:40,340 --> 00:33:45,649
indicate that you need to add more unit

740
00:33:41,780 --> 00:33:48,740
tests and variant analysis is not

741
00:33:45,650 --> 00:33:49,910
dependency monitoring something else

742
00:33:48,740 --> 00:33:52,220
that I would highly recommend that you

743
00:33:49,910 --> 00:33:54,680
do there are many companies offer this

744
00:33:52,220 --> 00:33:57,950
service like Black Duck or snake or

745
00:33:54,680 --> 00:34:00,050
white sauce who will look what code your

746
00:33:57,950 --> 00:34:02,930
code is using and ensure that all the

747
00:34:00,050 --> 00:34:09,620
versions are up-to-date or don't have

748
00:34:02,930 --> 00:34:11,240
any vulnerabilities if anything very

749
00:34:09,620 --> 00:34:13,100
nice is actually something that will

750
00:34:11,239 --> 00:34:15,759
later feed those for you the information

751
00:34:13,100 --> 00:34:18,770
of those companies it's a process that

752
00:34:15,760 --> 00:34:20,270
produces more CVS it checks your code

753
00:34:18,770 --> 00:34:27,560
not the code of the libraries you're

754
00:34:20,270 --> 00:34:29,960
using variant analysis is not something

755
00:34:27,560 --> 00:34:31,610
that automatically fixes bugs for you or

756
00:34:29,960 --> 00:34:33,860
tells you how to fix them it just points

757
00:34:31,610 --> 00:34:35,389
them out you still need to put the

758
00:34:33,860 --> 00:34:36,980
effort into thinking about how you're

759
00:34:35,389 --> 00:34:40,330
going to solve something once

760
00:34:36,980 --> 00:34:40,330
something's been pointed out to you

761
00:34:41,199 --> 00:34:49,009
there was one other thing that I forgot

762
00:34:43,639 --> 00:34:51,190
out of the slide never mind come to me

763
00:34:49,010 --> 00:34:56,420
later

764
00:34:51,190 --> 00:35:00,200
so to recap do variant analysis it's

765
00:34:56,420 --> 00:35:01,130
it's very important and all the big

766
00:35:00,200 --> 00:35:05,410
players are starting to do it

767
00:35:01,130 --> 00:35:08,290
Google's doing it Mozilla is doing it

768
00:35:05,410 --> 00:35:11,870
Microsoft is doing it NASA is doing it

769
00:35:08,290 --> 00:35:15,770
large new startups like uber are doing

770
00:35:11,870 --> 00:35:19,970
it and I'm regularly hearing reports

771
00:35:15,770 --> 00:35:21,770
that people are finding around three to

772
00:35:19,970 --> 00:35:26,259
four times as many vulnerabilities as

773
00:35:21,770 --> 00:35:26,259
they were before they were doing it and

774
00:35:26,710 --> 00:35:33,590
more importantly or better yet you

775
00:35:32,060 --> 00:35:35,930
should do automated very analysis

776
00:35:33,590 --> 00:35:37,490
describe your mistakes in a way that

777
00:35:35,930 --> 00:35:41,120
some sort can automatically check for

778
00:35:37,490 --> 00:35:46,850
them it reduces the the labor reduces

779
00:35:41,120 --> 00:35:48,380
the workload and overall you can many

780
00:35:46,850 --> 00:35:50,299
companies are actually finding their

781
00:35:48,380 --> 00:35:52,790
overall workload for that Security

782
00:35:50,300 --> 00:35:54,650
Response Team is decreasing the more

783
00:35:52,790 --> 00:35:55,820
variant analysis they do because the

784
00:35:54,650 --> 00:35:57,650
number of vulnerabilities that are

785
00:35:55,820 --> 00:36:05,150
coming in that would have otherwise been

786
00:35:57,650 --> 00:36:06,560
caught through VA is increased use and

787
00:36:05,150 --> 00:36:10,120
contribute to the shared knowledge and

788
00:36:06,560 --> 00:36:13,009
checks from Security Response Teams

789
00:36:10,120 --> 00:36:16,609
open-source your checks use open source

790
00:36:13,010 --> 00:36:18,410
checks everyone we we can't do this in

791
00:36:16,610 --> 00:36:21,020
isolation there's not a single security

792
00:36:18,410 --> 00:36:22,580
research team that can think of every

793
00:36:21,020 --> 00:36:24,680
single type of attack vector that their

794
00:36:22,580 --> 00:36:26,569
software might be hit with learn from

795
00:36:24,680 --> 00:36:28,220
the knowledge of other people from other

796
00:36:26,570 --> 00:36:29,780
security research teams that have dealt

797
00:36:28,220 --> 00:36:33,740
with different situations so you have

798
00:36:29,780 --> 00:36:39,710
learn from the knowledge of your bug

799
00:36:33,740 --> 00:36:42,109
bounty and submitters checks should be

800
00:36:39,710 --> 00:36:43,880
run continuously and not once off don't

801
00:36:42,110 --> 00:36:45,500
just think that doing variant analysis

802
00:36:43,880 --> 00:36:47,960
for a particular mistake once it's good

803
00:36:45,500 --> 00:36:49,370
enough because people will probably make

804
00:36:47,960 --> 00:36:51,620
that mistake again in the future

805
00:36:49,370 --> 00:36:54,140
make sure it's part of your process to

806
00:36:51,620 --> 00:36:59,240
prevent new instances of these mistakes

807
00:36:54,140 --> 00:37:02,089
coming in and finally variance analysis

808
00:36:59,240 --> 00:37:02,299
complements and doesn't replace many of

809
00:37:02,090 --> 00:37:03,619
the

810
00:37:02,299 --> 00:37:06,199
existing security practices out there

811
00:37:03,619 --> 00:37:10,910
and indeed can actually reduce the

812
00:37:06,199 --> 00:37:13,969
overall workload when it's combined so

813
00:37:10,910 --> 00:37:16,779
I'm finished about 15 minutes early

814
00:37:13,969 --> 00:37:16,779
that's about

815
00:37:17,190 --> 00:37:25,979
[Applause]

