1
00:00:06,190 --> 00:00:17,550
[Music]

2
00:00:14,030 --> 00:00:20,009
I'm canoe from China and it's really a

3
00:00:17,550 --> 00:00:22,980
great honor to share some of my

4
00:00:20,010 --> 00:00:25,769
researchers here first of all I'd like

5
00:00:22,980 --> 00:00:29,070
to thank all the people that made it is

6
00:00:25,769 --> 00:00:31,859
also humane passport and today I'm going

7
00:00:29,070 --> 00:00:35,100
to talk about a can of interesting

8
00:00:31,859 --> 00:00:38,910
vulnerabilities which will fund in Adobe

9
00:00:35,100 --> 00:00:41,700
Acrobat and reader I hope it can bring

10
00:00:38,910 --> 00:00:48,419
you some new ideas about finding and

11
00:00:41,700 --> 00:00:50,760
exploiting vulnerabilities so first of

12
00:00:48,420 --> 00:00:52,350
all please allow me to introduce myself

13
00:00:50,760 --> 00:00:55,289
briefly

14
00:00:52,350 --> 00:00:58,680
I'm a senior security researcher from

15
00:00:55,289 --> 00:01:02,309
tensing the security sharing lab during

16
00:00:58,680 --> 00:01:05,909
the past years I have fun and reported

17
00:01:02,309 --> 00:01:10,020
about 400 of our abilities in product

18
00:01:05,909 --> 00:01:13,740
from Adobe Apple Google Microsoft and

19
00:01:10,020 --> 00:01:18,869
some other companies and one of the

20
00:01:13,740 --> 00:01:22,169
nominees of the pony Awards in 2017 also

21
00:01:18,869 --> 00:01:25,380
I shared some of my researches about

22
00:01:22,170 --> 00:01:30,590
finding vulnerabilities in PDF readers

23
00:01:25,380 --> 00:01:35,490
and blackhead Asia also in 2017 am

24
00:01:30,590 --> 00:01:36,689
amanda nsrc top 100 list from 2016 to

25
00:01:35,490 --> 00:01:40,979
2018

26
00:01:36,689 --> 00:01:45,359
last year upon the Adobe Reader at Tim's

27
00:01:40,979 --> 00:01:52,799
cut which is a patent on mic competition

28
00:01:45,360 --> 00:01:56,280
held in China and I'm also one of the

29
00:01:52,799 --> 00:01:58,280
speakers of the Google Escalade and bugs

30
00:01:56,280 --> 00:02:03,509
wat event this year

31
00:01:58,280 --> 00:02:07,110
ok so first of all this is the agenda of

32
00:02:03,509 --> 00:02:10,919
the presentation we had talked about the

33
00:02:07,110 --> 00:02:13,950
topic front six parts including basic

34
00:02:10,919 --> 00:02:17,790
concepts root cause analysis

35
00:02:13,950 --> 00:02:23,609
Fuzzy's strategies case studies patch

36
00:02:17,790 --> 00:02:25,859
analysis and the nation's nerd first of

37
00:02:23,610 --> 00:02:29,280
all needs to talk about the following

38
00:02:25,860 --> 00:02:33,390
basic concepts including character sets

39
00:02:29,280 --> 00:02:40,140
string tabs stream functions and the pet

40
00:02:33,390 --> 00:02:43,679
order mark the first one is the

41
00:02:40,140 --> 00:02:49,579
character sets here we need teeth for

42
00:02:43,680 --> 00:02:55,590
common character sets including s key NC

43
00:02:49,580 --> 00:02:58,500
uses two and utf-16 the NC character

44
00:02:55,590 --> 00:03:02,040
said has a hundred and twenty eight

45
00:02:58,500 --> 00:03:07,970
characters and the size of each

46
00:03:02,040 --> 00:03:14,730
character is seven bits the NC character

47
00:03:07,970 --> 00:03:18,870
had said has 256 characters the size of

48
00:03:14,730 --> 00:03:22,138
each character is one byte and the uses

49
00:03:18,870 --> 00:03:25,380
two character said has more than sixty

50
00:03:22,139 --> 00:03:29,359
thousand characters the size of each

51
00:03:25,380 --> 00:03:33,090
character is to party and the utf-16

52
00:03:29,359 --> 00:03:36,420
character said has more than a million

53
00:03:33,090 --> 00:03:41,660
characters characters and the size of

54
00:03:36,420 --> 00:03:46,708
each character is two to four parts also

55
00:03:41,660 --> 00:03:49,859
youtube the utf-8 character set is also

56
00:03:46,709 --> 00:03:55,160
an common character set but we a lot

57
00:03:49,859 --> 00:03:55,160
discuss it in this presentation and

58
00:03:55,970 --> 00:04:03,329
another thing is that we can see that

59
00:03:58,980 --> 00:04:07,220
the NC character set is based on the

60
00:04:03,329 --> 00:04:11,010
ASCII character set and the utf-16

61
00:04:07,220 --> 00:04:16,738
character set is based on the uses two

62
00:04:11,010 --> 00:04:20,039
character set the second one is a string

63
00:04:16,738 --> 00:04:23,159
tabs under windows developing

64
00:04:20,039 --> 00:04:27,620
environment strings can be divided into

65
00:04:23,159 --> 00:04:31,580
two categories one is NC stream

66
00:04:27,620 --> 00:04:36,199
as is your code stream an acid stream is

67
00:04:31,580 --> 00:04:39,380
a series of NC characters as we sit

68
00:04:36,199 --> 00:04:44,120
before the cells of each character is

69
00:04:39,380 --> 00:04:49,460
one page and it can be represented as a

70
00:04:44,120 --> 00:04:53,120
chart hibari in the C language and the

71
00:04:49,460 --> 00:04:58,070
stream Terminator is a one page nor

72
00:04:53,120 --> 00:05:02,260
character just one bad and as a Unicode

73
00:04:58,070 --> 00:05:08,270
stream is a series of unicode characters

74
00:05:02,260 --> 00:05:11,449
more precisely as we said before the

75
00:05:08,270 --> 00:05:13,760
unicode character said is based on the

76
00:05:11,449 --> 00:05:17,080
uses two character set

77
00:05:13,760 --> 00:05:21,289
so under windows developing environment

78
00:05:17,080 --> 00:05:25,370
an oracle stream actually is a series of

79
00:05:21,289 --> 00:05:29,570
uses two characters and the cells of

80
00:05:25,370 --> 00:05:33,139
each character is too bad it can be

81
00:05:29,570 --> 00:05:36,860
represented as a red chart help array in

82
00:05:33,139 --> 00:05:42,919
c language and as a string terminator is

83
00:05:36,860 --> 00:05:46,220
a true pad nor character so we can see

84
00:05:42,919 --> 00:05:49,460
here that the string terminator for the

85
00:05:46,220 --> 00:05:51,789
NC string is only one page but for the

86
00:05:49,460 --> 00:05:58,190
unicode string it has two parts

87
00:05:51,789 --> 00:06:00,530
okay so I think everyone sitting here

88
00:05:58,190 --> 00:06:04,820
are very familiar with these stream

89
00:06:00,530 --> 00:06:08,659
functions such as string compare string

90
00:06:04,820 --> 00:06:12,110
copy and screen names there are two

91
00:06:08,660 --> 00:06:14,830
versions of the stream functions the

92
00:06:12,110 --> 00:06:17,990
ansan version and the Unicode version

93
00:06:14,830 --> 00:06:25,599
both the versions are vulnerable to

94
00:06:17,990 --> 00:06:29,240
buffer overflow attacks so there is a

95
00:06:25,599 --> 00:06:33,710
enhanced version these stream functions

96
00:06:29,240 --> 00:06:36,979
as a security enhanced ones as we can

97
00:06:33,710 --> 00:06:40,799
see here there is an ATM in the

98
00:06:36,979 --> 00:06:43,979
functions names this nature in the

99
00:06:40,800 --> 00:06:46,370
the number of characters that will be

100
00:06:43,979 --> 00:06:46,370
processed

101
00:06:46,970 --> 00:06:54,120
however those functions ostia variable

102
00:06:50,759 --> 00:07:00,090
to buffer overflow attacks for example

103
00:06:54,120 --> 00:07:03,080
the string in copy function as listed in

104
00:07:00,090 --> 00:07:05,520
the bottom of the slide is the probe

105
00:07:03,080 --> 00:07:08,909
prototype of the string and copy

106
00:07:05,520 --> 00:07:13,349
function as we can see here there are

107
00:07:08,909 --> 00:07:16,949
three parameters the first one is a

108
00:07:13,349 --> 00:07:19,860
destination buffer the second one is the

109
00:07:16,949 --> 00:07:24,349
source stream and the third one is a

110
00:07:19,860 --> 00:07:29,789
number of characters to be processed so

111
00:07:24,349 --> 00:07:33,780
if the if the length of the source

112
00:07:29,789 --> 00:07:38,068
stream is equal or greater than the

113
00:07:33,780 --> 00:07:41,008
third parameter the num parameter this

114
00:07:38,069 --> 00:07:45,509
function will not append a null

115
00:07:41,009 --> 00:07:49,650
character to the destination stream so

116
00:07:45,509 --> 00:07:52,560
if this happened the destination stream

117
00:07:49,650 --> 00:07:58,039
will not have a stream terminator and

118
00:07:52,560 --> 00:07:58,039
this were needed to security problems

119
00:07:59,630 --> 00:08:06,389
another security enhanced version of

120
00:08:02,639 --> 00:08:10,139
stream functions those functions are

121
00:08:06,389 --> 00:08:14,759
implemented by Microsoft and they are

122
00:08:10,139 --> 00:08:17,759
only available on Windows the invalid

123
00:08:14,759 --> 00:08:21,509
parameter handler will be called if the

124
00:08:17,759 --> 00:08:25,620
operation feared the default behavior of

125
00:08:21,509 --> 00:08:30,569
the handler is to care the process so as

126
00:08:25,620 --> 00:08:34,289
we can see in the Box the pattern of the

127
00:08:30,569 --> 00:08:36,659
slide there are two functions one is the

128
00:08:34,289 --> 00:08:40,078
enhanced version for string copy and

129
00:08:36,659 --> 00:08:43,349
another one is the enhanced version for

130
00:08:40,078 --> 00:08:48,750
string and copy and as we can see here

131
00:08:43,349 --> 00:08:52,290
the second parameter indicates the size

132
00:08:48,750 --> 00:08:54,600
of the destination buffer it will make

133
00:08:52,290 --> 00:08:58,680
sure that wim

134
00:08:54,600 --> 00:09:04,700
copy streams live a lot overflows the

135
00:08:58,680 --> 00:09:04,699
destination puffer so it's more secure

136
00:09:04,970 --> 00:09:11,580
now let's talk about the pet odor mark

137
00:09:08,580 --> 00:09:15,510
as used in the title of this

138
00:09:11,580 --> 00:09:20,690
presentation it plays an important role

139
00:09:15,510 --> 00:09:26,670
to help checkers of our abilities so as

140
00:09:20,690 --> 00:09:31,680
we discussed before each unicode

141
00:09:26,670 --> 00:09:35,490
character has two parts of data so it

142
00:09:31,680 --> 00:09:38,790
has a pet order problem here we can

143
00:09:35,490 --> 00:09:40,010
specify the bat order in the character

144
00:09:38,790 --> 00:09:45,839
set name

145
00:09:40,010 --> 00:09:50,120
the first one is utf-16 le le indicates

146
00:09:45,840 --> 00:09:55,800
that the bad order is Nita ending and

147
00:09:50,120 --> 00:10:02,010
utf-16 PE her PE indicates the pet order

148
00:09:55,800 --> 00:10:03,689
is pig ending the pet order will be

149
00:10:02,010 --> 00:10:06,750
platform-specific

150
00:10:03,690 --> 00:10:11,220
if we did not specify it in the

151
00:10:06,750 --> 00:10:15,000
character set name explicitly however we

152
00:10:11,220 --> 00:10:21,930
can specify the pet order by using the

153
00:10:15,000 --> 00:10:26,670
pad order mark the pet odor mark is the

154
00:10:21,930 --> 00:10:30,839
utf-16 character of e FF the value is a

155
00:10:26,670 --> 00:10:35,160
v FF and it's only used for specifying

156
00:10:30,840 --> 00:10:37,560
the pet odor of a data stream so if we

157
00:10:35,160 --> 00:10:43,699
are always at the beginning of a data

158
00:10:37,560 --> 00:10:48,000
stream there is a simple example to show

159
00:10:43,700 --> 00:10:50,820
how the bad odor mark works here we have

160
00:10:48,000 --> 00:10:57,030
two characters there are Chinese

161
00:10:50,820 --> 00:11:02,490
characters the value of the first

162
00:10:57,030 --> 00:11:06,350
character is for yi 2d and the value of

163
00:11:02,490 --> 00:11:08,019
the second character is six five eight

164
00:11:06,350 --> 00:11:12,129
seven

165
00:11:08,019 --> 00:11:18,339
so Anita painting format the data stream

166
00:11:12,129 --> 00:11:19,059
via p FF f e 2t forty eight seven six

167
00:11:18,339 --> 00:11:24,639
five

168
00:11:19,059 --> 00:11:27,129
here F F F E is the pet odor mark and in

169
00:11:24,639 --> 00:11:34,899
peak ending format the terror stream

170
00:11:27,129 --> 00:11:38,499
therapy f EF f40 26 Feb 8 7 and the

171
00:11:34,899 --> 00:11:45,879
first two pads also is the pet odor mark

172
00:11:38,499 --> 00:11:49,929
I think this is very clear long it's

173
00:11:45,879 --> 00:11:52,989
time to do a recap we talked about and

174
00:11:49,929 --> 00:11:56,410
since trains and the unicode strings and

175
00:11:52,989 --> 00:11:59,079
we know that the traditional stream

176
00:11:56,410 --> 00:12:02,410
functions a vulnerable to buffer

177
00:11:59,079 --> 00:12:06,008
overflow attacks we also talked about

178
00:12:02,410 --> 00:12:10,238
the security enhanced stream functions

179
00:12:06,009 --> 00:12:15,129
which have more arguments and we talked

180
00:12:10,239 --> 00:12:18,579
about the pet odor mark fe FF the pet

181
00:12:15,129 --> 00:12:23,019
order of its self specifies the pet odor

182
00:12:18,579 --> 00:12:26,019
of the whole data stream so that all the

183
00:12:23,019 --> 00:12:33,220
basic concept that we need to know all

184
00:12:26,019 --> 00:12:36,189
listed in this page so a security

185
00:12:33,220 --> 00:12:40,449
enhanced stream functions of is secure

186
00:12:36,189 --> 00:12:43,959
that depends on how you use it the

187
00:12:40,449 --> 00:12:47,469
security is guaranteed only if the

188
00:12:43,959 --> 00:12:50,618
functions are used correctly talking

189
00:12:47,470 --> 00:12:53,889
about security is meaningless if they

190
00:12:50,619 --> 00:12:57,790
are used incorrectly in the following

191
00:12:53,889 --> 00:13:00,839
example we try to copy data from the

192
00:12:57,790 --> 00:13:04,599
source stream to the destination stream

193
00:13:00,839 --> 00:13:12,009
however we see the value of the second

194
00:13:04,600 --> 00:13:15,549
parameter - civil F F F which is much

195
00:13:12,009 --> 00:13:19,329
greater than the actual process here the

196
00:13:15,549 --> 00:13:21,819
actual process of the first parameter

197
00:13:19,329 --> 00:13:29,140
that destination strength

198
00:13:21,820 --> 00:13:33,880
is only templates usage exists we are

199
00:13:29,140 --> 00:13:37,330
care all the security features so even

200
00:13:33,880 --> 00:13:43,570
if we are using the security enhanced

201
00:13:37,330 --> 00:13:46,600
version string copy is actually this

202
00:13:43,570 --> 00:13:48,850
function were just an act like the

203
00:13:46,600 --> 00:13:55,780
traditional string copy function as

204
00:13:48,850 --> 00:13:58,690
listed below so if he even we use the

205
00:13:55,780 --> 00:14:02,050
string copy as the security enhanced

206
00:13:58,690 --> 00:14:11,410
function we also need to buffer overflow

207
00:14:02,050 --> 00:14:14,560
because we used it incorrectly so Adobe

208
00:14:11,410 --> 00:14:17,920
Reader implemented a set of stream

209
00:14:14,560 --> 00:14:21,550
functions including NC version and the

210
00:14:17,920 --> 00:14:25,870
unicode version and the top level API

211
00:14:21,550 --> 00:14:28,510
can handle strings automatically it will

212
00:14:25,870 --> 00:14:31,150
redirect to the request to corresponding

213
00:14:28,510 --> 00:14:35,860
functions according to the string types

214
00:14:31,150 --> 00:14:39,069
that sounds great so here we have three

215
00:14:35,860 --> 00:14:43,320
columns the first one is the top-level

216
00:14:39,070 --> 00:14:45,670
API and the second one is the NC

217
00:14:43,320 --> 00:14:48,850
implementation the third one is a

218
00:14:45,670 --> 00:14:51,819
Unicode implementation if you are a

219
00:14:48,850 --> 00:14:56,580
developer of the Adobe Reader

220
00:14:51,820 --> 00:14:56,580
you can use all the functions directly

221
00:14:58,860 --> 00:15:03,610
so needs no care to the implementations

222
00:15:01,960 --> 00:15:08,050
of the top Naver

223
00:15:03,610 --> 00:15:12,940
APs and the nets take string and then

224
00:15:08,050 --> 00:15:18,160
save as an example so let's review the

225
00:15:12,940 --> 00:15:21,370
code here as we can see in the box this

226
00:15:18,160 --> 00:15:25,870
function has four parameters the first

227
00:15:21,370 --> 00:15:28,570
one is the string to be processed the

228
00:15:25,870 --> 00:15:32,890
second one is the maximum path of

229
00:15:28,570 --> 00:15:35,570
content that will be processed and the

230
00:15:32,890 --> 00:15:38,810
third one is error handling

231
00:15:35,570 --> 00:15:42,050
function pointer if the function detect

232
00:15:38,810 --> 00:15:46,069
some arrow the arrow handler they are

233
00:15:42,050 --> 00:15:48,949
because here's a function needs review

234
00:15:46,070 --> 00:15:52,820
the code of the function as we can see

235
00:15:48,950 --> 00:15:56,090
in the if statement the function will

236
00:15:52,820 --> 00:15:59,480
check if the first part of the string is

237
00:15:56,090 --> 00:16:04,730
Fe and the second part of the string is

238
00:15:59,480 --> 00:16:07,280
FF so the request will be redirected to

239
00:16:04,730 --> 00:16:10,040
the corresponding URI code stream

240
00:16:07,280 --> 00:16:16,670
function if all the requirements are

241
00:16:10,040 --> 00:16:21,490
made otherwise the request will be

242
00:16:16,670 --> 00:16:21,490
redirected to the ANSI stream function

243
00:16:22,240 --> 00:16:30,830
so what's the problems here there are

244
00:16:26,420 --> 00:16:34,189
two flaws the first one is that the

245
00:16:30,830 --> 00:16:36,950
functions are used incorrectly as we can

246
00:16:34,190 --> 00:16:42,610
see here the value of the second

247
00:16:36,950 --> 00:16:46,550
parameter was 7 followed by 7f that is 7

248
00:16:42,610 --> 00:16:51,320
ffffff in and the most cases they are

249
00:16:46,550 --> 00:16:53,030
used this value as discussed before this

250
00:16:51,320 --> 00:16:58,180
we are needed to security

251
00:16:53,030 --> 00:17:01,490
vulnerabilities the second flaw is that

252
00:16:58,180 --> 00:17:06,579
chicken string types according to the

253
00:17:01,490 --> 00:17:11,420
pet order mark the fe FF is insufficient

254
00:17:06,579 --> 00:17:16,280
here we have a string in the middle of

255
00:17:11,420 --> 00:17:20,810
the slide so once at head of this stream

256
00:17:16,280 --> 00:17:27,319
and C Oracle stream and that's not an

257
00:17:20,810 --> 00:17:30,200
easy question for Adobe Reader here's a

258
00:17:27,319 --> 00:17:35,530
table shows the content of the string

259
00:17:30,200 --> 00:17:35,530
memory in the middle of the slide

260
00:17:36,220 --> 00:17:44,090
obviously it's an icy stream since the

261
00:17:39,770 --> 00:17:46,940
cells of each character is one page but

262
00:17:44,090 --> 00:17:49,370
Adobe Reader we are treating it as a

263
00:17:46,940 --> 00:17:53,830
Unicode stream

264
00:17:49,370 --> 00:17:56,179
the first two parts are Fe and the FF as

265
00:17:53,830 --> 00:18:00,199
shown in the figure

266
00:17:56,180 --> 00:18:04,070
Olivier is the first part is Fe and the

267
00:18:00,200 --> 00:18:10,640
second part is FF so Adobe Reader we are

268
00:18:04,070 --> 00:18:13,310
treated as a Unicode string we can

269
00:18:10,640 --> 00:18:16,490
easily trigger the variability by

270
00:18:13,310 --> 00:18:21,200
passing an insane string to the Unicode

271
00:18:16,490 --> 00:18:25,310
functions because the terminator for NZ

272
00:18:21,200 --> 00:18:28,460
string is a one pad nor character and is

273
00:18:25,310 --> 00:18:32,629
a terminator for unicode string is a two

274
00:18:28,460 --> 00:18:35,990
pads nor character even NZ stream was

275
00:18:32,630 --> 00:18:40,070
hindered by the Unicode functions out of

276
00:18:35,990 --> 00:18:46,790
buns axis can be triggered since the

277
00:18:40,070 --> 00:18:48,830
string Terminator cannot be found so

278
00:18:46,790 --> 00:18:53,149
time to do a recap again

279
00:18:48,830 --> 00:18:56,360
first of all Adobe implemented a set of

280
00:18:53,150 --> 00:18:59,420
functions for string headings but the

281
00:18:56,360 --> 00:19:04,219
functions were used incorrectly in most

282
00:18:59,420 --> 00:19:08,710
cases the developers always passing 7

283
00:19:04,220 --> 00:19:12,950
followed by 7/8 2 parameter maximum pets

284
00:19:08,710 --> 00:19:16,510
also checking string types according to

285
00:19:12,950 --> 00:19:20,390
the pet order mark is insufficient under

286
00:19:16,510 --> 00:19:23,270
such circumstances hey Denis ends in

287
00:19:20,390 --> 00:19:30,230
stream with Unicode functions we are

288
00:19:23,270 --> 00:19:32,740
needed to security vulnerabilities so

289
00:19:30,230 --> 00:19:36,650
how to first such kind of

290
00:19:32,740 --> 00:19:41,150
vulnerabilities that very simple we can

291
00:19:36,650 --> 00:19:45,260
test all possible places such as objects

292
00:19:41,150 --> 00:19:49,190
properties and functions name functions

293
00:19:45,260 --> 00:19:53,920
parameters with malformed ends in stream

294
00:19:49,190 --> 00:19:57,470
which starts respects fe and the FF a

295
00:19:53,920 --> 00:20:01,010
fund about ten independent where our

296
00:19:57,470 --> 00:20:02,410
abilities using this method and all

297
00:20:01,010 --> 00:20:06,640
versions of a

298
00:20:02,410 --> 00:20:09,370
the Acrobat Reader DC were affected the

299
00:20:06,640 --> 00:20:15,550
first version of it was released in

300
00:20:09,370 --> 00:20:18,429
April 2015 lon need staff deep into the

301
00:20:15,550 --> 00:20:21,520
vulnerabilities with some case studies

302
00:20:18,430 --> 00:20:24,640
and we talked about two interesting

303
00:20:21,520 --> 00:20:27,160
cases one could achieve information

304
00:20:24,640 --> 00:20:31,330
disclosure and the Lassa could achieve

305
00:20:27,160 --> 00:20:34,150
code execution and if we still have time

306
00:20:31,330 --> 00:20:38,230
I will talk about some other trivial

307
00:20:34,150 --> 00:20:41,500
cases all the proof of concept' code can

308
00:20:38,230 --> 00:20:43,960
be found within these slides you can

309
00:20:41,500 --> 00:20:46,570
download and read the site in case we

310
00:20:43,960 --> 00:20:54,990
don't have him to discuss the additional

311
00:20:46,570 --> 00:20:58,780
cases here the first one is a CVE 20

312
00:20:54,990 --> 00:21:01,230
1970 statute - this is a basic

313
00:20:58,780 --> 00:21:04,300
information of the first variability

314
00:21:01,230 --> 00:21:07,360
it's an out of pulse rate variability

315
00:21:04,300 --> 00:21:12,340
and the code needs to information

316
00:21:07,360 --> 00:21:16,000
disclosure so this is the proof of

317
00:21:12,340 --> 00:21:19,270
concept code it's very simple just the

318
00:21:16,000 --> 00:21:23,020
two lines of JavaScript code can trigger

319
00:21:19,270 --> 00:21:27,760
the variability Nature Reviews occurred

320
00:21:23,020 --> 00:21:31,540
in the first box first we call the add

321
00:21:27,760 --> 00:21:35,710
field method of the document object here

322
00:21:31,540 --> 00:21:40,120
this the cable disease is the document

323
00:21:35,710 --> 00:21:44,830
object because I had feared method to

324
00:21:40,120 --> 00:21:48,699
create a feared instance theme we ascend

325
00:21:44,830 --> 00:21:52,870
string Fe FF choose a username property

326
00:21:48,700 --> 00:21:56,590
of the fed object Adobe Reader will

327
00:21:52,870 --> 00:22:00,280
crash when opening a PDF contains those

328
00:21:56,590 --> 00:22:03,850
two lines of JavaScript code and as we

329
00:22:00,280 --> 00:22:06,760
can see here in the second box the

330
00:22:03,850 --> 00:22:11,639
exception information indicates that

331
00:22:06,760 --> 00:22:11,640
it's an out of pants read for ability

332
00:22:13,330 --> 00:22:19,340
except the mission code that can trigger

333
00:22:16,760 --> 00:22:22,610
the variability have fun Zedd

334
00:22:19,340 --> 00:22:25,970
there are 18 passport combinations to

335
00:22:22,610 --> 00:22:29,539
trigger it the underlying root causes of

336
00:22:25,970 --> 00:22:33,529
the crashes are all the sim as we can

337
00:22:29,539 --> 00:22:37,370
see in the table we can change the type

338
00:22:33,529 --> 00:22:39,620
of the field we can change it to text

339
00:22:37,370 --> 00:22:42,379
field radio button field

340
00:22:39,620 --> 00:22:46,879
combo box via the trip Oxford and some

341
00:22:42,380 --> 00:22:51,110
other types and we can also change the

342
00:22:46,880 --> 00:22:56,320
property front username to submit name

343
00:22:51,110 --> 00:23:02,029
or value here we can trigger the

344
00:22:56,320 --> 00:23:04,700
vulnerability with 18 combinations the

345
00:23:02,029 --> 00:23:06,260
root cause of the vulnerability is also

346
00:23:04,700 --> 00:23:10,480
very simple needs

347
00:23:06,260 --> 00:23:15,230
reviewer code member named here we can

348
00:23:10,480 --> 00:23:18,679
let's review the coding in the box here

349
00:23:15,230 --> 00:23:23,539
we can control 40 control the content of

350
00:23:18,679 --> 00:23:27,830
the source stream as specified in the

351
00:23:23,539 --> 00:23:33,590
Box it's fair that user name and we set

352
00:23:27,830 --> 00:23:38,418
it to every FF please note this is an

353
00:23:33,590 --> 00:23:42,980
icy stream so it will be handled with

354
00:23:38,419 --> 00:23:48,860
function string and then safe this is a

355
00:23:42,980 --> 00:23:51,980
top level API and it will need to out

356
00:23:48,860 --> 00:23:55,668
response rate because the stream will be

357
00:23:51,980 --> 00:23:58,750
handled by the URI code function seeing

358
00:23:55,669 --> 00:24:03,529
a heap buffer we are being allocated

359
00:23:58,750 --> 00:24:05,840
according to the calculated size and the

360
00:24:03,529 --> 00:24:08,899
zimwi we are trying to copy data from

361
00:24:05,840 --> 00:24:12,980
source strength to destination stream

362
00:24:08,899 --> 00:24:18,020
with memory copy the MEMS EP wave

363
00:24:12,980 --> 00:24:21,620
function and is a copy data they are be

364
00:24:18,020 --> 00:24:23,918
referenced by the username property so

365
00:24:21,620 --> 00:24:26,149
that we can read the data from

366
00:24:23,919 --> 00:24:31,819
JavaScript code

367
00:24:26,149 --> 00:24:35,748
so we can leak some information here how

368
00:24:31,819 --> 00:24:40,039
to exploit this vulnerability the way to

369
00:24:35,749 --> 00:24:44,089
exploit it is very straightforward first

370
00:24:40,039 --> 00:24:47,929
we can put an object with virtual table

371
00:24:44,089 --> 00:24:50,178
pointer behind the source stream then we

372
00:24:47,929 --> 00:24:53,809
can read the virtual table pointer

373
00:24:50,179 --> 00:24:56,689
petrichor in the variability the virtual

374
00:24:53,809 --> 00:25:00,918
table pointer will be used to calculate

375
00:24:56,689 --> 00:25:06,589
the base address of the module here are

376
00:25:00,919 --> 00:25:10,579
the exploiting steps first we esprit

377
00:25:06,589 --> 00:25:15,049
lots of livius bring lots of objects

378
00:25:10,579 --> 00:25:18,589
which have virtual table printers them

379
00:25:15,049 --> 00:25:23,869
the free half of the spread objects to

380
00:25:18,589 --> 00:25:26,418
make some memory horse felony we try to

381
00:25:23,869 --> 00:25:29,208
trigger the vulnerability to nix a

382
00:25:26,419 --> 00:25:36,949
virtual table pointer of one of the

383
00:25:29,209 --> 00:25:38,499
spirit objects here are some exploiting

384
00:25:36,949 --> 00:25:42,019
tricks

385
00:25:38,499 --> 00:25:45,319
unfortunately normal JavaScript objects

386
00:25:42,019 --> 00:25:49,189
do not have vegetable pointers but

387
00:25:45,319 --> 00:25:51,979
offended the xma attack objects whizzing

388
00:25:49,189 --> 00:25:55,059
exactly mode to have virtual table

389
00:25:51,979 --> 00:25:59,059
pointers they are ideal candidates for

390
00:25:55,059 --> 00:26:02,119
exploiting this vulnerability we can

391
00:25:59,059 --> 00:26:08,119
create such kind of objects by corn in

392
00:26:02,119 --> 00:26:10,698
the create node function however the add

393
00:26:08,119 --> 00:26:14,329
feared method we are not be allowed to

394
00:26:10,699 --> 00:26:17,799
be caught whizzing xfa mode as we can

395
00:26:14,329 --> 00:26:22,688
see in the future a lot alarmed arrow

396
00:26:17,799 --> 00:26:26,569
exception where this rod if we call it

397
00:26:22,689 --> 00:26:29,869
here comes a ladder tree also we cannot

398
00:26:26,569 --> 00:26:33,819
create a fear dynamically we can define

399
00:26:29,869 --> 00:26:37,399
one state chigney this piece of PDF code

400
00:26:33,819 --> 00:26:39,889
defends a text feared called mayfair one

401
00:26:37,399 --> 00:26:42,830
we can manipulate it

402
00:26:39,890 --> 00:26:46,029
in the Quebec function of an initialized

403
00:26:42,830 --> 00:26:52,189
event and this line of JavaScript code

404
00:26:46,029 --> 00:26:54,710
listed in the second box here can get

405
00:26:52,190 --> 00:26:57,740
the reference of the feared object and

406
00:26:54,710 --> 00:27:01,730
now we can trigger the variability and

407
00:26:57,740 --> 00:27:05,090
make some information so this is the

408
00:27:01,730 --> 00:27:08,330
exploiting result here we successfully

409
00:27:05,090 --> 00:27:11,480
nicked the base address of macho Accra

410
00:27:08,330 --> 00:27:16,850
phone and this can be used to pay us a

411
00:27:11,480 --> 00:27:19,730
SAR now mayor talk about the second

412
00:27:16,850 --> 00:27:23,120
variability which was an out of puns

413
00:27:19,730 --> 00:27:24,470
read and write one and could need to

414
00:27:23,120 --> 00:27:30,070
code execution

415
00:27:24,470 --> 00:27:30,070
it was just fixed in October this year

416
00:27:30,279 --> 00:27:37,580
the proof of concept code is also very

417
00:27:33,950 --> 00:27:41,659
simple we can trigger the variability /

418
00:27:37,580 --> 00:27:44,600
89 of the code listed here here are two

419
00:27:41,659 --> 00:27:47,779
lines of JavaScript in the first box we

420
00:27:44,600 --> 00:27:51,709
can trigger the variability with any

421
00:27:47,779 --> 00:27:56,179
nine of the code and the exception

422
00:27:51,710 --> 00:28:01,130
information indicates that the process

423
00:27:56,179 --> 00:28:04,399
crash winfrey corrupted hip plug that

424
00:28:01,130 --> 00:28:08,779
means out of puns right happened at

425
00:28:04,399 --> 00:28:13,070
least the root cause of the variability

426
00:28:08,779 --> 00:28:16,159
was the same as a previous one handling

427
00:28:13,070 --> 00:28:20,029
mer formed NC strings with unicode

428
00:28:16,159 --> 00:28:24,169
functions let's review the code in the

429
00:28:20,029 --> 00:28:27,730
parks name balum first we can phony

430
00:28:24,169 --> 00:28:31,490
controls a content of the source stream

431
00:28:27,730 --> 00:28:34,700
it was handled with the NC function as

432
00:28:31,490 --> 00:28:40,610
we can see in the first line of the code

433
00:28:34,700 --> 00:28:43,580
and that looks great seeing a hip buffer

434
00:28:40,610 --> 00:28:47,510
was allocated according to the

435
00:28:43,580 --> 00:28:50,899
calculated names and a string copy was

436
00:28:47,510 --> 00:28:53,559
performed by calling the function string

437
00:28:50,899 --> 00:28:57,320
copy safe which would treat

438
00:28:53,559 --> 00:29:00,649
ability this function will redirect the

439
00:28:57,320 --> 00:29:04,250
request to the unicode function because

440
00:29:00,650 --> 00:29:08,980
the source stream start with a V and FF

441
00:29:04,250 --> 00:29:12,950
out of puns read and read can be treated

442
00:29:08,980 --> 00:29:18,380
since the destination stream is not big

443
00:29:12,950 --> 00:29:22,010
enough to hold the the unicode stream

444
00:29:18,380 --> 00:29:24,590
it's only the space of the destination

445
00:29:22,010 --> 00:29:30,799
buffer is only available for the NC

446
00:29:24,590 --> 00:29:33,639
stream so how to exploit it to express

447
00:29:30,799 --> 00:29:36,440
the variability we can put Eliza

448
00:29:33,640 --> 00:29:39,590
controllable stream just behind the

449
00:29:36,440 --> 00:29:43,070
source stream such that we can control

450
00:29:39,590 --> 00:29:48,620
the data to be read in wrote and we can

451
00:29:43,070 --> 00:29:52,610
stop copying data whenever we want we

452
00:29:48,620 --> 00:29:55,969
should also put an Reaper object just

453
00:29:52,610 --> 00:29:58,760
behind the destination path such that we

454
00:29:55,970 --> 00:30:01,730
can overwrite the pattern instead of the

455
00:29:58,760 --> 00:30:06,890
array buffer object now we can change

456
00:30:01,730 --> 00:30:11,380
patterns video to 8f talking up to read

457
00:30:06,890 --> 00:30:16,280
and read ability the exploiting steps

458
00:30:11,380 --> 00:30:19,580
first we spread lots of objects here we

459
00:30:16,280 --> 00:30:22,370
created four objects as a unit at one

460
00:30:19,580 --> 00:30:25,309
time except the second one is a

461
00:30:22,370 --> 00:30:30,409
controllable string object all the

462
00:30:25,309 --> 00:30:33,379
others as a reaper object then we free

463
00:30:30,410 --> 00:30:38,290
half of the objects to create memory

464
00:30:33,380 --> 00:30:41,450
horse and we trigger in the variability

465
00:30:38,290 --> 00:30:44,600
we can make the source string get

466
00:30:41,450 --> 00:30:47,150
allocated in the first hole and the

467
00:30:44,600 --> 00:30:51,168
destination string get allocated in the

468
00:30:47,150 --> 00:30:55,460
second hole then we perform the string

469
00:30:51,169 --> 00:30:59,809
copy operation and we overwrite the path

470
00:30:55,460 --> 00:31:02,929
length value to add F such that we can

471
00:30:59,809 --> 00:31:06,700
fold it in the purity to read and write

472
00:31:02,929 --> 00:31:06,700
at arbitrary address

473
00:31:07,059 --> 00:31:12,860
there are also some exploiting tricks

474
00:31:10,130 --> 00:31:13,429
please no cat is a code listed in the

475
00:31:12,860 --> 00:31:17,110
box

476
00:31:13,429 --> 00:31:20,570
the first part is some JavaScript code

477
00:31:17,110 --> 00:31:26,240
here we created an array buffer object

478
00:31:20,570 --> 00:31:30,110
and associated it with a DW object the

479
00:31:26,240 --> 00:31:36,139
second part is a memory layout here the

480
00:31:30,110 --> 00:31:39,678
text in red color is a data view sorry

481
00:31:36,139 --> 00:31:42,949
the text in red color is pet names value

482
00:31:39,679 --> 00:31:46,309
and the text in yellow color is a data

483
00:31:42,950 --> 00:31:49,610
view pointer being over writing the data

484
00:31:46,309 --> 00:31:52,309
please make sure you cannot corrupt the

485
00:31:49,610 --> 00:31:57,350
date of you printer otherwise the

486
00:31:52,309 --> 00:32:01,309
process will crash immediately so we can

487
00:31:57,350 --> 00:32:04,279
only change patterns to four F because

488
00:32:01,309 --> 00:32:07,340
function string copy they are read a

489
00:32:04,279 --> 00:32:13,309
string terminator here the text in red

490
00:32:07,340 --> 00:32:16,610
color is the string terminator so for F

491
00:32:13,309 --> 00:32:21,139
is multi love to read and read globally

492
00:32:16,610 --> 00:32:24,229
we need a TF instead so how to change

493
00:32:21,139 --> 00:32:26,959
patterns to add F without touching the

494
00:32:24,230 --> 00:32:31,940
view pointer we can achieve this go up

495
00:32:26,960 --> 00:32:35,210
by setting the view pointer to null when

496
00:32:31,940 --> 00:32:38,210
creating a rebuff our object we can call

497
00:32:35,210 --> 00:32:43,250
the smash function to get a duplicate

498
00:32:38,210 --> 00:32:46,000
one so we may spray re buffer objects we

499
00:32:43,250 --> 00:32:49,909
can cause a slash function to create

500
00:32:46,000 --> 00:32:52,759
duplicates now we can overwrite pattern

501
00:32:49,909 --> 00:32:55,990
ends with a t-value and wrote the string

502
00:32:52,759 --> 00:33:01,220
terminator at the view pointers address

503
00:32:55,990 --> 00:33:04,279
it has no side effect since the original

504
00:33:01,220 --> 00:33:07,399
value is also zero here we change the

505
00:33:04,279 --> 00:33:10,970
pattern ends to ATF and the string

506
00:33:07,399 --> 00:33:16,459
terminator was wrote in the video

507
00:33:10,970 --> 00:33:19,129
printer we still have something to do

508
00:33:16,460 --> 00:33:20,559
here also we cannot read and read

509
00:33:19,129 --> 00:33:24,080
globally

510
00:33:20,559 --> 00:33:27,230
we cannot read and read at absolute

511
00:33:24,080 --> 00:33:30,110
memory address because a rebirth doesn't

512
00:33:27,230 --> 00:33:32,330
have such ability to achieve this goal

513
00:33:30,110 --> 00:33:35,600
we need to figure out the absolute

514
00:33:32,330 --> 00:33:38,449
memory address of the array buffers back

515
00:33:35,600 --> 00:33:41,510
in store the backing store is the buffer

516
00:33:38,450 --> 00:33:45,890
which is used to store the perimeter of

517
00:33:41,510 --> 00:33:50,179
this river a windows we can search

518
00:33:45,890 --> 00:33:56,840
backward to find some values such as FF

519
00:33:50,179 --> 00:33:59,600
e e FF e and F 0 e 0 t 0 C 0 there are

520
00:33:56,840 --> 00:34:02,658
some values around the same that can be

521
00:33:59,600 --> 00:34:05,719
used to calculate the absolute memory

522
00:34:02,659 --> 00:34:08,810
address of the heap buffer here the

523
00:34:05,720 --> 00:34:11,750
values in yellow color are the ones that

524
00:34:08,810 --> 00:34:15,080
we are looking for we can use in to

525
00:34:11,750 --> 00:34:19,460
calculate the absolute memory address of

526
00:34:15,080 --> 00:34:22,369
the heap buffer once we can read and

527
00:34:19,460 --> 00:34:25,070
read at any given absolute memory

528
00:34:22,369 --> 00:34:27,470
address it's very easy to finish the

529
00:34:25,070 --> 00:34:30,290
remaining steps to exploit the

530
00:34:27,469 --> 00:34:32,658
vulnerability these steps will not be

531
00:34:30,290 --> 00:34:35,629
discussed in this presentation because

532
00:34:32,659 --> 00:34:38,750
there are the common techniques required

533
00:34:35,629 --> 00:34:45,368
to really exploit here we still need to

534
00:34:38,750 --> 00:34:49,099
pass a CR safe G DP and hijack year P

535
00:34:45,369 --> 00:34:52,730
saw the exploiting result we can execute

536
00:34:49,099 --> 00:34:54,490
arbitrary code within the sandbox being

537
00:34:52,730 --> 00:34:57,940
exploiting this vulnerability

538
00:34:54,489 --> 00:35:01,430
successfully to demonstrate the

539
00:34:57,940 --> 00:35:04,089
exploitability I disabled the sandbox

540
00:35:01,430 --> 00:35:08,899
protection so that we can pop up the

541
00:35:04,089 --> 00:35:14,170
calculator law needs to some hedge

542
00:35:08,900 --> 00:35:18,380
analysis work for civil year 2019 1732

543
00:35:14,170 --> 00:35:21,200
Adobe put three external characters at

544
00:35:18,380 --> 00:35:24,380
the end of the source stream nan Zi

545
00:35:21,200 --> 00:35:27,319
there are four new characters in total

546
00:35:24,380 --> 00:35:29,119
and it will stop the out of puns read

547
00:35:27,320 --> 00:35:31,849
behavior to be triggered

548
00:35:29,119 --> 00:35:34,180
although not perfect it works as

549
00:35:31,849 --> 00:35:34,180
expected

550
00:35:35,890 --> 00:35:41,000
yeah

551
00:35:37,220 --> 00:35:44,660
here are four characters behind the

552
00:35:41,000 --> 00:35:47,180
source stream for the second

553
00:35:44,660 --> 00:35:51,310
vulnerability there are two patches for

554
00:35:47,180 --> 00:35:55,370
each the first page was developed 70

555
00:35:51,310 --> 00:35:58,250
Adobe put two external characters at the

556
00:35:55,370 --> 00:36:01,460
end of the source stream and the non Z

557
00:35:58,250 --> 00:36:04,840
there are three new characters in total

558
00:36:01,460 --> 00:36:08,690
this will make functions drinker pieces

559
00:36:04,840 --> 00:36:12,560
stop copying data earlier and we can

560
00:36:08,690 --> 00:36:15,260
only over read a single pet because the

561
00:36:12,560 --> 00:36:18,940
destination buffer is not big enough to

562
00:36:15,260 --> 00:36:22,100
receive the Unicode stream terminator

563
00:36:18,940 --> 00:36:28,190
now we cannot express the variability

564
00:36:22,100 --> 00:36:31,220
anymore the second patch family fixed it

565
00:36:28,190 --> 00:36:34,160
when calculating the length of the

566
00:36:31,220 --> 00:36:37,220
source stream a topi used function

567
00:36:34,160 --> 00:36:41,480
string and hence safe instead of using

568
00:36:37,220 --> 00:36:46,220
the ANSI version and it is allocated to

569
00:36:41,480 --> 00:36:49,310
extra pets of memory to store the string

570
00:36:46,220 --> 00:36:51,819
terminator now the destination buffer is

571
00:36:49,310 --> 00:36:56,029
big enough to receive the string data

572
00:36:51,820 --> 00:37:02,440
including the string Terminator nan the

573
00:36:56,030 --> 00:37:03,580
bar ability fixed so some patch

574
00:37:02,440 --> 00:37:06,520
suggestions

575
00:37:03,580 --> 00:37:10,009
although Adobe fixed the variability

576
00:37:06,520 --> 00:37:13,240
successfully the root causes still exist

577
00:37:10,010 --> 00:37:16,490
the functions are used incorrectly and

578
00:37:13,240 --> 00:37:19,549
tab confusions can be made between the

579
00:37:16,490 --> 00:37:22,250
ANSI and Unicode strings following are

580
00:37:19,550 --> 00:37:25,070
some of my suggestions for patrons of

581
00:37:22,250 --> 00:37:27,830
our abilities first we can try to

582
00:37:25,070 --> 00:37:31,370
distinguish ANSI and Unicode strings

583
00:37:27,830 --> 00:37:34,850
more carefully oh we should always use

584
00:37:31,370 --> 00:37:38,240
your constraints and convert to ANSI

585
00:37:34,850 --> 00:37:40,520
strains only when needed this may not be

586
00:37:38,240 --> 00:37:43,540
so easy to implement

587
00:37:40,520 --> 00:37:46,970
compared with adding our characters

588
00:37:43,540 --> 00:37:47,220
because we design the architecture we

589
00:37:46,970 --> 00:37:50,669
are

590
00:37:47,220 --> 00:37:55,078
faked a lot of sins and the set of

591
00:37:50,670 --> 00:37:58,890
images was taken from the now Kim the

592
00:37:55,079 --> 00:38:04,920
vividly expresses where developers don't

593
00:37:58,890 --> 00:38:07,710
want to touch the Nagisa code above the

594
00:38:04,920 --> 00:38:10,619
parameter although it may be hard to

595
00:38:07,710 --> 00:38:14,099
redesign the architecture at least we

596
00:38:10,619 --> 00:38:17,220
should not use seven followed by 7f for

597
00:38:14,099 --> 00:38:19,800
parameter maximum pads the venule does

598
00:38:17,220 --> 00:38:22,279
give you some time but innovative in it

599
00:38:19,800 --> 00:38:25,050
in it destroys the security features and

600
00:38:22,280 --> 00:38:29,960
sooner or later you will get some

601
00:38:25,050 --> 00:38:34,079
punishment for using it the Nessen stern

602
00:38:29,960 --> 00:38:37,160
we should try to avoid the problems the

603
00:38:34,079 --> 00:38:40,579
architecture design phase and we should

604
00:38:37,160 --> 00:38:43,828
refactor the Nagisa code when needed

605
00:38:40,579 --> 00:38:46,490
master but not least we should increase

606
00:38:43,829 --> 00:38:54,810
the developers consciousness about

607
00:38:46,490 --> 00:38:57,750
security so we still have a few minutes

608
00:38:54,810 --> 00:39:03,599
and maybe I can talk about some other

609
00:38:57,750 --> 00:39:07,250
trivial cases so the first one there are

610
00:39:03,599 --> 00:39:10,230
two boxes as we can see in the first box

611
00:39:07,250 --> 00:39:13,349
just one line code to trigger the

612
00:39:10,230 --> 00:39:15,510
vulnerability this case was much like

613
00:39:13,349 --> 00:39:19,890
the information is crucial variability

614
00:39:15,510 --> 00:39:22,890
we talked about earlier only one line of

615
00:39:19,890 --> 00:39:25,710
JavaScript code can trigger it however

616
00:39:22,890 --> 00:39:28,770
we cannot retrieve the leaked

617
00:39:25,710 --> 00:39:31,380
information franchise script code so I

618
00:39:28,770 --> 00:39:35,700
think it's probably not expressed for

619
00:39:31,380 --> 00:39:38,910
the second one a similar case that can

620
00:39:35,700 --> 00:39:41,189
only trigger the crash we also cannot

621
00:39:38,910 --> 00:39:44,160
retrieve the leaked information French

622
00:39:41,190 --> 00:39:49,079
our script code I think is also not

623
00:39:44,160 --> 00:39:51,950
expressed for and the third one can be

624
00:39:49,079 --> 00:39:56,310
treated by 89 of the JavaScript code and

625
00:39:51,950 --> 00:39:59,250
can lead to out of puns read after doing

626
00:39:56,310 --> 00:40:02,450
some further analysis I think it's also

627
00:39:59,250 --> 00:40:02,450
not expressed

628
00:40:03,980 --> 00:40:10,350
and this one is a little different

629
00:40:07,400 --> 00:40:13,530
although this one had nothing to do with

630
00:40:10,350 --> 00:40:16,980
the bad odor mark we can specify the

631
00:40:13,530 --> 00:40:20,310
string tab by using the character set

632
00:40:16,980 --> 00:40:23,970
name as we can see in in the first box

633
00:40:20,310 --> 00:40:29,370
the certain line of code we sit the

634
00:40:23,970 --> 00:40:33,509
second parameter to utf-16 le indicates

635
00:40:29,370 --> 00:40:36,600
we should we show that recognize the

636
00:40:33,510 --> 00:40:39,570
string as a leader in diem stream and

637
00:40:36,600 --> 00:40:42,930
this will need to out of pants read when

638
00:40:39,570 --> 00:40:45,090
calculating the string names and out of

639
00:40:42,930 --> 00:40:48,000
one's read can also be triggered in

640
00:40:45,090 --> 00:40:50,310
later however we cannot retrieve the

641
00:40:48,000 --> 00:40:53,580
leaked information franchise script code

642
00:40:50,310 --> 00:40:56,610
no can we corrupt some data structures

643
00:40:53,580 --> 00:41:01,470
to achieve code execution so I think

644
00:40:56,610 --> 00:41:04,860
it's also not exploitable the fifth one

645
00:41:01,470 --> 00:41:08,700
this one also was much like the

646
00:41:04,860 --> 00:41:11,450
information disclosure one but we also

647
00:41:08,700 --> 00:41:14,279
cannot retrieve the negative information

648
00:41:11,450 --> 00:41:18,060
we cannot give the information in

649
00:41:14,280 --> 00:41:21,180
JavaScript code so I think it's also not

650
00:41:18,060 --> 00:41:22,200
expressible and this one was fixed the

651
00:41:21,180 --> 00:41:26,549
salient needs

652
00:41:22,200 --> 00:41:31,439
so no severe number for this one the

653
00:41:26,550 --> 00:41:34,260
last one so the last case in this

654
00:41:31,440 --> 00:41:36,540
presentation it has similar root cause

655
00:41:34,260 --> 00:41:39,420
but it cannot be treated a French our

656
00:41:36,540 --> 00:41:43,550
script code actually the code in the box

657
00:41:39,420 --> 00:41:47,280
is a piece of chalice of PDF code and

658
00:41:43,550 --> 00:41:52,260
here we can specify the value of the URI

659
00:41:47,280 --> 00:41:54,930
entry to Fe FF in green color the code

660
00:41:52,260 --> 00:41:57,540
in green color you will need to out of

661
00:41:54,930 --> 00:42:01,560
pants red ring hidden in the URI with

662
00:41:57,540 --> 00:42:04,820
Unicode functions and this case was fun

663
00:42:01,560 --> 00:42:10,440
excellency in 2016

664
00:42:04,820 --> 00:42:12,840
actually three years ago and okay that's

665
00:42:10,440 --> 00:42:14,340
all of my talk I hope you have done

666
00:42:12,840 --> 00:42:17,220
something from a talk

667
00:42:14,340 --> 00:42:20,900
and please feel free to ask me if you

668
00:42:17,220 --> 00:42:20,899
have any questions thank you

