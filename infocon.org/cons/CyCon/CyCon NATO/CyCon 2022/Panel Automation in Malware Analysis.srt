1
00:00:00,240 --> 00:00:02,480
okay thank you everybody uh let's go and

2
00:00:02,480 --> 00:00:04,000
get started if you are here for the

3
00:00:04,000 --> 00:00:05,600
automation in malware analysis you're in

4
00:00:05,600 --> 00:00:06,879
the right place

5
00:00:06,879 --> 00:00:08,960
uh i'm gonna be the moderator today

6
00:00:08,960 --> 00:00:10,880
commander jake galbraith i work here at

7
00:00:10,880 --> 00:00:14,160
ccdcoe at the strategic branch

8
00:00:14,160 --> 00:00:15,920
uh i'm professional i.t in the united

9
00:00:15,920 --> 00:00:17,119
states navy

10
00:00:17,119 --> 00:00:19,199
uh and most of my tours have been

11
00:00:19,199 --> 00:00:21,199
operational in the pacific

12
00:00:21,199 --> 00:00:24,320
in japan and the south china sea

13
00:00:24,320 --> 00:00:27,119
so i have the pleasure of introducing

14
00:00:27,119 --> 00:00:29,439
the topics and then the speakers the

15
00:00:29,439 --> 00:00:30,800
format will be

16
00:00:30,800 --> 00:00:33,120
uh after the introduction speakers will

17
00:00:33,120 --> 00:00:34,640
have about 25 minutes to do their

18
00:00:34,640 --> 00:00:36,239
presentation i'll do a question and

19
00:00:36,239 --> 00:00:37,680
answer session at the end of each

20
00:00:37,680 --> 00:00:39,680
presentation and if we have time we'll

21
00:00:39,680 --> 00:00:42,000
do a bigger question answer session

22
00:00:42,000 --> 00:00:43,440
at the very end

23
00:00:43,440 --> 00:00:44,640
okay

24
00:00:44,640 --> 00:00:48,399
uh topics today will be uh

25
00:00:48,399 --> 00:00:50,079
philip charlin will be doing jarvis

26
00:00:50,079 --> 00:00:52,640
phenotype clone search for rapid zero

27
00:00:52,640 --> 00:00:54,800
day malware triage and functional

28
00:00:54,800 --> 00:00:56,960
decomposition for cyber threat

29
00:00:56,960 --> 00:00:58,480
intelligence

30
00:00:58,480 --> 00:01:00,160
uh to his right

31
00:01:00,160 --> 00:01:02,399
stephen enders will do rethinking

32
00:01:02,399 --> 00:01:04,879
decomposition for malware analysis

33
00:01:04,879 --> 00:01:07,760
and to his right at the end jake norwood

34
00:01:07,760 --> 00:01:09,840
business as usual

35
00:01:09,840 --> 00:01:11,200
a response

36
00:01:11,200 --> 00:01:13,280
to the cyber criminal to the russia

37
00:01:13,280 --> 00:01:15,759
ukraine conflict please come on in have

38
00:01:15,759 --> 00:01:17,360
a seat and we'll go ahead and get

39
00:01:17,360 --> 00:01:19,119
started

40
00:01:19,119 --> 00:01:21,759
all right first up our first uh guest

41
00:01:21,759 --> 00:01:23,040
speaker here

42
00:01:23,040 --> 00:01:25,680
is to my immediate right philip tarlin

43
00:01:25,680 --> 00:01:27,200
is a defense scientist at defense

44
00:01:27,200 --> 00:01:29,280
research and development canada

45
00:01:29,280 --> 00:01:31,040
of volcartier

46
00:01:31,040 --> 00:01:33,040
research center in the mission critical

47
00:01:33,040 --> 00:01:34,799
cyber security section

48
00:01:34,799 --> 00:01:36,079
where he leads the systems

49
00:01:36,079 --> 00:01:38,479
vulnerabilities and lethality group

50
00:01:38,479 --> 00:01:40,799
his research research focuses on

51
00:01:40,799 --> 00:01:42,799
software reverse engineering more

52
00:01:42,799 --> 00:01:44,320
specifically on the development of

53
00:01:44,320 --> 00:01:46,880
binary analysis tools to accelerate

54
00:01:46,880 --> 00:01:49,040
the reverse engineering process

55
00:01:49,040 --> 00:01:51,040
involved in malware and embedded system

56
00:01:51,040 --> 00:01:53,119
software analysis mr charlie holds a

57
00:01:53,119 --> 00:01:54,479
bachelor of master's degree in computer

58
00:01:54,479 --> 00:01:56,640
science both from concordia university

59
00:01:56,640 --> 00:01:58,560
in montreal canada

60
00:01:58,560 --> 00:02:01,200
sir please

61
00:02:02,159 --> 00:02:05,040
thank you for the introduction

62
00:02:05,040 --> 00:02:07,200
so defense research and development

63
00:02:07,200 --> 00:02:10,080
canada is an organization within the

64
00:02:10,080 --> 00:02:12,800
department of national defense

65
00:02:12,800 --> 00:02:15,760
so today i will present you the jarvis

66
00:02:15,760 --> 00:02:18,239
tool which implements a new approach

67
00:02:18,239 --> 00:02:20,800
called phenotype clone search

68
00:02:20,800 --> 00:02:23,680
which can be used for malware triage and

69
00:02:23,680 --> 00:02:27,280
cyber threat intelligence

70
00:02:27,520 --> 00:02:29,680
so i will start my presentation by

71
00:02:29,680 --> 00:02:32,239
giving you some background information

72
00:02:32,239 --> 00:02:33,440
which will

73
00:02:33,440 --> 00:02:36,560
highlight the motivation behind our work

74
00:02:36,560 --> 00:02:38,480
then i will present the

75
00:02:38,480 --> 00:02:41,120
our contribution i will explain what's

76
00:02:41,120 --> 00:02:44,000
uh phenotype clone search

77
00:02:44,000 --> 00:02:46,000
and how it can be used to analyze

78
00:02:46,000 --> 00:02:47,200
malware

79
00:02:47,200 --> 00:02:49,440
then i will give you the result of an

80
00:02:49,440 --> 00:02:53,440
experiment we conducted using jarvis

81
00:02:53,440 --> 00:02:55,280
where we analyze

82
00:02:55,280 --> 00:02:57,040
malware samples

83
00:02:57,040 --> 00:02:59,760
and at the end of my presentation i will

84
00:02:59,760 --> 00:03:01,200
give you

85
00:03:01,200 --> 00:03:03,760
i will show you a short youtube video

86
00:03:03,760 --> 00:03:06,879
which gives you a short demonstration of

87
00:03:06,879 --> 00:03:10,319
the jarvis tool

88
00:03:11,040 --> 00:03:13,360
so at the defense research and

89
00:03:13,360 --> 00:03:15,599
development canada we don't do

90
00:03:15,599 --> 00:03:18,319
everything internally so we collaborate

91
00:03:18,319 --> 00:03:21,360
with the universities among others

92
00:03:21,360 --> 00:03:24,879
either through contracts or partnerships

93
00:03:24,879 --> 00:03:25,920
so

94
00:03:25,920 --> 00:03:27,920
the work that i will present you to do

95
00:03:27,920 --> 00:03:30,159
it today is an example of such a

96
00:03:30,159 --> 00:03:34,159
collaboration so the jarvis tool was

97
00:03:34,159 --> 00:03:36,640
developed in collaboration with mcgill

98
00:03:36,640 --> 00:03:39,280
university in montreal canada

99
00:03:39,280 --> 00:03:41,519
and queen's university

100
00:03:41,519 --> 00:03:46,599
from kingston also in canada

101
00:03:47,120 --> 00:03:50,799
nowadays uh since there are so much open

102
00:03:50,799 --> 00:03:52,480
source code we uh

103
00:03:52,480 --> 00:03:54,879
open source code available

104
00:03:54,879 --> 00:03:57,680
code views is a common practice in

105
00:03:57,680 --> 00:03:59,439
software development

106
00:03:59,439 --> 00:04:02,400
and the same thing apply for uh for

107
00:04:02,400 --> 00:04:04,480
malware development

108
00:04:04,480 --> 00:04:05,760
because

109
00:04:05,760 --> 00:04:08,400
malware authors they don't want to

110
00:04:08,400 --> 00:04:10,319
start their development process from

111
00:04:10,319 --> 00:04:12,959
scratch they want to reuse as much code

112
00:04:12,959 --> 00:04:15,200
as possible

113
00:04:15,200 --> 00:04:18,320
and malware samples which have a similar

114
00:04:18,320 --> 00:04:20,560
high level behaviors are considered

115
00:04:20,560 --> 00:04:23,520
variants of the same family

116
00:04:23,520 --> 00:04:27,919
and over the years malware variants have

117
00:04:27,919 --> 00:04:32,000
exponentially increased both in terms of

118
00:04:32,000 --> 00:04:34,960
volume and threat potential so just to

119
00:04:34,960 --> 00:04:36,800
give you an idea

120
00:04:36,800 --> 00:04:41,360
so the av test institute identified in

121
00:04:41,360 --> 00:04:42,880
2021

122
00:04:42,880 --> 00:04:45,360
more than 21 million new malware

123
00:04:45,360 --> 00:04:47,840
variants that they were targeting the

124
00:04:47,840 --> 00:04:51,600
microsoft windows operating system

125
00:04:51,600 --> 00:04:52,720
and the

126
00:04:52,720 --> 00:04:56,960
emo net malware has now more than 70 70

127
00:04:56,960 --> 00:05:00,800
000 variants and each emonet malware

128
00:05:00,800 --> 00:05:03,440
incident can cost up to a

129
00:05:03,440 --> 00:05:05,199
1 million to

130
00:05:05,199 --> 00:05:07,759
to clean up and the reason why we have

131
00:05:07,759 --> 00:05:10,479
so many variants is because malware

132
00:05:10,479 --> 00:05:12,960
authors they play a cat and mouse game

133
00:05:12,960 --> 00:05:16,080
with the antivirus engine so

134
00:05:16,080 --> 00:05:19,120
a malware alter will write some

135
00:05:19,120 --> 00:05:21,600
some malware at one point this smart

136
00:05:21,600 --> 00:05:24,240
wire will get detected by antivirus

137
00:05:24,240 --> 00:05:26,800
engine so the malware author

138
00:05:26,800 --> 00:05:30,240
will modify it slightly to be able to

139
00:05:30,240 --> 00:05:34,000
bypass the antivirus detection

140
00:05:34,000 --> 00:05:36,880
the the motivations are slight but

141
00:05:36,880 --> 00:05:39,440
they preserve the functionalities of the

142
00:05:39,440 --> 00:05:41,759
malware and then

143
00:05:41,759 --> 00:05:44,160
the malware engine will start detecting

144
00:05:44,160 --> 00:05:47,919
this new new variant and it's uh ongoing

145
00:05:47,919 --> 00:05:51,039
ongoing process

146
00:05:51,280 --> 00:05:54,000
one process which is really important in

147
00:05:54,000 --> 00:05:56,880
malware triage is to be able to match

148
00:05:56,880 --> 00:05:58,880
unknown variants to their malware

149
00:05:58,880 --> 00:06:00,000
families

150
00:06:00,000 --> 00:06:02,000
and also to identify

151
00:06:02,000 --> 00:06:04,720
uh new malware from unknown families the

152
00:06:04,720 --> 00:06:06,800
reason why this is so important it's

153
00:06:06,800 --> 00:06:08,479
because

154
00:06:08,479 --> 00:06:10,240
this will

155
00:06:10,240 --> 00:06:12,720
help you to to decide where to put your

156
00:06:12,720 --> 00:06:15,360
efforts so let's say that you

157
00:06:15,360 --> 00:06:17,280
encounter a new

158
00:06:17,280 --> 00:06:19,440
a new malware variant of a family you

159
00:06:19,440 --> 00:06:21,600
know very well because you have analyzed

160
00:06:21,600 --> 00:06:24,080
it in the past maybe you will not

161
00:06:24,080 --> 00:06:26,639
spend too much time analyzing analyzing

162
00:06:26,639 --> 00:06:27,440
it

163
00:06:27,440 --> 00:06:31,440
compare if if you encounter a a a novel

164
00:06:31,440 --> 00:06:33,919
a malware which doesn't belong to any

165
00:06:33,919 --> 00:06:36,319
previous malware family that you have

166
00:06:36,319 --> 00:06:38,720
seen in the past

167
00:06:38,720 --> 00:06:40,000
so they are

168
00:06:40,000 --> 00:06:42,000
they are existing approach to malware

169
00:06:42,000 --> 00:06:45,280
triage such as a dynamic analysis

170
00:06:45,280 --> 00:06:48,400
signatures and machine learning so each

171
00:06:48,400 --> 00:06:51,840
approach has its pros and cons

172
00:06:51,840 --> 00:06:54,000
the problem with dynamic analysis is

173
00:06:54,000 --> 00:06:55,039
that

174
00:06:55,039 --> 00:06:57,520
some malware they have anti-sandboxing

175
00:06:57,520 --> 00:07:00,240
techniques so they are able to detect

176
00:07:00,240 --> 00:07:02,000
when they are being executed in a

177
00:07:02,000 --> 00:07:04,080
virtual environment

178
00:07:04,080 --> 00:07:06,400
and in this case they would they will

179
00:07:06,400 --> 00:07:10,240
avoid launching their malicious payload

180
00:07:10,240 --> 00:07:12,800
in the case of signatures

181
00:07:12,800 --> 00:07:14,479
some malware

182
00:07:14,479 --> 00:07:17,360
use certain techniques to impede the

183
00:07:17,360 --> 00:07:21,680
signature extraction extracting process

184
00:07:21,680 --> 00:07:24,639
and machine and to address this problem

185
00:07:24,639 --> 00:07:26,479
machine learning techniques have been

186
00:07:26,479 --> 00:07:29,120
proposed but one limitation that they

187
00:07:29,120 --> 00:07:30,479
have is

188
00:07:30,479 --> 00:07:32,639
they don't provide an ex any

189
00:07:32,639 --> 00:07:35,280
explainability with their classification

190
00:07:35,280 --> 00:07:37,759
result so you know the result but you

191
00:07:37,759 --> 00:07:39,680
don't know uh

192
00:07:39,680 --> 00:07:42,240
what was used to to to come up with this

193
00:07:42,240 --> 00:07:45,120
uh with this result

194
00:07:45,120 --> 00:07:46,240
so

195
00:07:46,240 --> 00:07:49,039
to complement the existing approaches

196
00:07:49,039 --> 00:07:52,479
and to address some of their limitations

197
00:07:52,479 --> 00:07:54,879
we propose a new approach called

198
00:07:54,879 --> 00:07:57,919
phenotype clone search

199
00:07:57,919 --> 00:08:00,720
phenotype are basic elements of

200
00:08:00,720 --> 00:08:03,919
observable characteristic extracted from

201
00:08:03,919 --> 00:08:06,560
a given malware sample

202
00:08:06,560 --> 00:08:09,840
so examples of phenotypes are code

203
00:08:09,840 --> 00:08:11,199
fragments

204
00:08:11,199 --> 00:08:14,639
constants and strings

205
00:08:14,639 --> 00:08:17,599
phenotypes can be directly observed

206
00:08:17,599 --> 00:08:20,319
without sandboxing or emulation

207
00:08:20,319 --> 00:08:22,639
and since they can be directly observed

208
00:08:22,639 --> 00:08:26,840
they can be easily interpreted

209
00:08:26,879 --> 00:08:28,240
as i said

210
00:08:28,240 --> 00:08:29,440
previously

211
00:08:29,440 --> 00:08:31,599
malware variants of the same family

212
00:08:31,599 --> 00:08:34,240
share a similar code base so our

213
00:08:34,240 --> 00:08:35,919
assumption is that

214
00:08:35,919 --> 00:08:38,399
malware variants of the same family will

215
00:08:38,399 --> 00:08:39,200
share

216
00:08:39,200 --> 00:08:42,719
many phenotypes

217
00:08:43,839 --> 00:08:46,640
so this is how phenotype clone search

218
00:08:46,640 --> 00:08:47,519
works

219
00:08:47,519 --> 00:08:50,399
so given a

220
00:08:50,399 --> 00:08:53,519
malware to analyze we will extract all

221
00:08:53,519 --> 00:08:56,240
its functions and for each function we

222
00:08:56,240 --> 00:08:58,800
will extract all its phenotypes

223
00:08:58,800 --> 00:09:00,640
and we will try to match these

224
00:09:00,640 --> 00:09:02,000
phenotypes

225
00:09:02,000 --> 00:09:04,320
with phenotypes of functions which are

226
00:09:04,320 --> 00:09:07,680
contained in a frequency of a malware

227
00:09:07,680 --> 00:09:10,480
and we will repeat this process for all

228
00:09:10,480 --> 00:09:12,560
the functions of the

229
00:09:12,560 --> 00:09:15,040
of the malware and at the end we will

230
00:09:15,040 --> 00:09:17,120
aggregate all the results

231
00:09:17,120 --> 00:09:20,399
and this will give us uh the

232
00:09:20,399 --> 00:09:22,480
the the malware family to which the

233
00:09:22,480 --> 00:09:23,440
malware

234
00:09:23,440 --> 00:09:27,519
sample belongs to uh this can also tell

235
00:09:27,519 --> 00:09:30,880
us the the behaviors of the malware

236
00:09:30,880 --> 00:09:36,320
and the ept group to which it belongs

237
00:09:36,320 --> 00:09:38,720
so i will give you an example using the

238
00:09:38,720 --> 00:09:42,880
uh detract malware sample so the detract

239
00:09:42,880 --> 00:09:45,200
malware is a remote administration tool

240
00:09:45,200 --> 00:09:46,959
malware which has been found in a

241
00:09:46,959 --> 00:09:49,200
nuclear power plant

242
00:09:49,200 --> 00:09:52,320
so the sample that we analyzed contained

243
00:09:52,320 --> 00:09:55,360
more than 11 000 functions

244
00:09:55,360 --> 00:09:56,720
that

245
00:09:56,720 --> 00:09:58,880
come from common code found in bin

246
00:09:58,880 --> 00:10:01,600
benign non-malicious malware so later on

247
00:10:01,600 --> 00:10:03,839
in my presentation i will

248
00:10:03,839 --> 00:10:06,000
explain you how we are able to determine

249
00:10:06,000 --> 00:10:06,800
this

250
00:10:06,800 --> 00:10:09,480
and of the remaining function

251
00:10:09,480 --> 00:10:13,920
663 function 563 functions were found in

252
00:10:13,920 --> 00:10:16,160
function from the sample from samples of

253
00:10:16,160 --> 00:10:18,399
the same family

254
00:10:18,399 --> 00:10:21,200
and what's interesting is that we also

255
00:10:21,200 --> 00:10:23,920
there also common malware culture with

256
00:10:23,920 --> 00:10:27,360
other families as well

257
00:10:28,000 --> 00:10:31,360
so this is an example of a visualization

258
00:10:31,360 --> 00:10:34,480
that jarvis provides

259
00:10:34,480 --> 00:10:38,279
so the sample that we analyze contain

260
00:10:38,279 --> 00:10:41,760
1897 functions so you see at the top of

261
00:10:41,760 --> 00:10:43,680
the image

262
00:10:43,680 --> 00:10:46,399
so this is a tree tri-map view

263
00:10:46,399 --> 00:10:47,839
so

264
00:10:47,839 --> 00:10:49,640
there was

265
00:10:49,640 --> 00:10:54,160
1136 functions that were non-malicious

266
00:10:54,160 --> 00:10:55,320
and

267
00:10:55,320 --> 00:10:59,200
563 functions that were coming from

268
00:10:59,200 --> 00:11:02,000
the d-trac malware family and as you can

269
00:11:02,000 --> 00:11:04,160
see at the back

270
00:11:04,160 --> 00:11:07,279
there was also 99 functions that were

271
00:11:07,279 --> 00:11:12,399
from the cobalt strike malware

272
00:11:13,760 --> 00:11:16,399
so uh our contribution

273
00:11:16,399 --> 00:11:18,959
as part of this work is that we propose

274
00:11:18,959 --> 00:11:21,040
a novel approach to malware functional

275
00:11:21,040 --> 00:11:22,720
decomposition

276
00:11:22,720 --> 00:11:26,079
to complement existing uh malware triage

277
00:11:26,079 --> 00:11:28,640
solutions like dynamic signature and

278
00:11:28,640 --> 00:11:32,000
machine learning based techniques

279
00:11:32,000 --> 00:11:35,440
we implemented this new approach in a

280
00:11:35,440 --> 00:11:37,680
new distributed clone search based

281
00:11:37,680 --> 00:11:40,880
analytic framework

282
00:11:40,880 --> 00:11:43,200
and we also provide a

283
00:11:43,200 --> 00:11:45,360
interactive and scalable visualization

284
00:11:45,360 --> 00:11:47,839
to decompose a target

285
00:11:47,839 --> 00:11:52,000
malware into noun functionalities

286
00:11:52,880 --> 00:11:55,360
so to perform a malware functional

287
00:11:55,360 --> 00:11:58,000
decomposition we need to perform two

288
00:11:58,000 --> 00:12:00,720
steps the first one is indexing and the

289
00:12:00,720 --> 00:12:03,279
second one is analysis

290
00:12:03,279 --> 00:12:05,519
so indexing is where you build your

291
00:12:05,519 --> 00:12:07,920
repository of known malware or if you

292
00:12:07,920 --> 00:12:10,720
have an existing repository

293
00:12:10,720 --> 00:12:13,680
you will add additional malwares to your

294
00:12:13,680 --> 00:12:15,760
uh your repository

295
00:12:15,760 --> 00:12:17,680
and once this is done

296
00:12:17,680 --> 00:12:21,600
you can conduct a decomposition analysis

297
00:12:21,600 --> 00:12:25,839
for a target malware sample

298
00:12:26,560 --> 00:12:29,360
so as part of the indexing we need to

299
00:12:29,360 --> 00:12:30,880
perform

300
00:12:30,880 --> 00:12:33,040
extraction steps for each malware

301
00:12:33,040 --> 00:12:35,120
samples to index

302
00:12:35,120 --> 00:12:37,760
so if the malware has been packed we

303
00:12:37,760 --> 00:12:39,360
unpack it

304
00:12:39,360 --> 00:12:41,839
after that we disassemble it using a

305
00:12:41,839 --> 00:12:45,440
disassembler such as the idapro or gidra

306
00:12:45,440 --> 00:12:46,880
then we will

307
00:12:46,880 --> 00:12:49,360
extract the phenotypes

308
00:12:49,360 --> 00:12:52,000
so again the phenotypes are the code

309
00:12:52,000 --> 00:12:55,360
fragment constants and strings

310
00:12:55,360 --> 00:12:57,920
and we will take all the phenotypes

311
00:12:57,920 --> 00:12:59,519
extracted

312
00:12:59,519 --> 00:13:02,079
from the different malware and we will

313
00:13:02,079 --> 00:13:04,560
index them in the

314
00:13:04,560 --> 00:13:07,839
elasticsearch cluster

315
00:13:10,720 --> 00:13:13,680
so uh once we're done with the indexing

316
00:13:13,680 --> 00:13:17,440
we can perform the analysis

317
00:13:17,440 --> 00:13:18,550
so um

318
00:13:18,550 --> 00:13:19,680
[Music]

319
00:13:19,680 --> 00:13:22,079
so the first step consists of extracting

320
00:13:22,079 --> 00:13:24,160
the phenotypes for each function of the

321
00:13:24,160 --> 00:13:26,720
target malware sample

322
00:13:26,720 --> 00:13:29,279
and after that that we will search for

323
00:13:29,279 --> 00:13:31,839
clones of each function in a collection

324
00:13:31,839 --> 00:13:35,600
of non-malicious executables

325
00:13:35,600 --> 00:13:38,720
so uh at the beginning um

326
00:13:38,720 --> 00:13:41,600
when i explained i i talked about the

327
00:13:41,600 --> 00:13:42,639
the

328
00:13:42,639 --> 00:13:45,199
detract malware sample i said that we

329
00:13:45,199 --> 00:13:46,720
were able to

330
00:13:46,720 --> 00:13:48,959
identify that 11

331
00:13:48,959 --> 00:13:52,480
100 functions were non-malicious

332
00:13:52,480 --> 00:13:54,959
that's because we have a repository of

333
00:13:54,959 --> 00:13:57,519
non-malicious executable

334
00:13:57,519 --> 00:14:01,040
and when we analyze a new malware so we

335
00:14:01,040 --> 00:14:02,639
will try to find

336
00:14:02,639 --> 00:14:04,959
clones of its function

337
00:14:04,959 --> 00:14:07,519
in this collection of software

338
00:14:07,519 --> 00:14:09,199
executable

339
00:14:09,199 --> 00:14:11,440
and if there is a match that has been

340
00:14:11,440 --> 00:14:13,839
found so we discard this function

341
00:14:13,839 --> 00:14:16,000
because we know that this function will

342
00:14:16,000 --> 00:14:17,680
not help us

343
00:14:17,680 --> 00:14:20,079
to determine the malware family to which

344
00:14:20,079 --> 00:14:23,680
the malware belong

345
00:14:24,079 --> 00:14:25,519
so

346
00:14:25,519 --> 00:14:27,519
so during step two we eliminate a

347
00:14:27,519 --> 00:14:30,079
certain number of functions and of the

348
00:14:30,079 --> 00:14:32,480
remaining function we would search the

349
00:14:32,480 --> 00:14:34,880
phenotypes for the remaining function in

350
00:14:34,880 --> 00:14:37,279
our malware repository

351
00:14:37,279 --> 00:14:39,440
so

352
00:14:39,440 --> 00:14:42,160
precisely the phenotypes that you are

353
00:14:42,160 --> 00:14:44,160
using are two grams of assembly

354
00:14:44,160 --> 00:14:46,160
instructions three grams of assembly

355
00:14:46,160 --> 00:14:49,360
extraction the strings and the constants

356
00:14:49,360 --> 00:14:52,800
and all the constants are converted in

357
00:14:52,800 --> 00:14:57,079
exodus similar format

358
00:14:59,199 --> 00:15:00,560
so uh

359
00:15:00,560 --> 00:15:02,800
so the search method is a combination of

360
00:15:02,800 --> 00:15:05,199
the okapi bm25

361
00:15:05,199 --> 00:15:10,480
and the tf idf function so bm25 it's a

362
00:15:10,480 --> 00:15:13,199
function which is used a lot for a text

363
00:15:13,199 --> 00:15:15,040
retrieval

364
00:15:15,040 --> 00:15:16,480
techniques

365
00:15:16,480 --> 00:15:20,480
it is used in elastic search

366
00:15:20,480 --> 00:15:22,000
so

367
00:15:22,000 --> 00:15:24,240
we use a boat function because in some

368
00:15:24,240 --> 00:15:28,000
cases the bm 25 gives a very

369
00:15:28,000 --> 00:15:30,600
interesting result but in some certain

370
00:15:30,600 --> 00:15:33,279
circumstances the results are not that

371
00:15:33,279 --> 00:15:36,240
great so since we're combining the two

372
00:15:36,240 --> 00:15:39,600
at the two method we are getting the

373
00:15:39,600 --> 00:15:42,560
the better of both worlds

374
00:15:42,560 --> 00:15:44,480
so the methods are combined to generate

375
00:15:44,480 --> 00:15:46,800
a similarity score between the search

376
00:15:46,800 --> 00:15:49,279
and the stored final times

377
00:15:49,279 --> 00:15:51,199
and the family to which the majority of

378
00:15:51,199 --> 00:15:53,279
the functions belong to is the

379
00:15:53,279 --> 00:15:56,639
attributed family

380
00:15:56,800 --> 00:15:59,839
so we conducted an experiment uh

381
00:15:59,839 --> 00:16:03,199
using 200 000 malware samples and 100

382
00:16:03,199 --> 00:16:05,839
000 b9 samples

383
00:16:05,839 --> 00:16:07,519
and the malware samples were grouped

384
00:16:07,519 --> 00:16:10,160
bears based on their families

385
00:16:10,160 --> 00:16:14,880
so there were approximately 394 families

386
00:16:14,880 --> 00:16:18,399
it took 43 hours to unpack disassembled

387
00:16:18,399 --> 00:16:21,440
and then text all the samples

388
00:16:21,440 --> 00:16:24,079
the what takes most time is the

389
00:16:24,079 --> 00:16:27,440
disassembly because we rely on existing

390
00:16:27,440 --> 00:16:31,360
tools like ida pro and guidra and

391
00:16:31,360 --> 00:16:34,720
we have no way to to to improve

392
00:16:34,720 --> 00:16:37,839
the time it takes to disassemble a

393
00:16:37,839 --> 00:16:40,560
all the funnels

394
00:16:40,560 --> 00:16:41,360
and

395
00:16:41,360 --> 00:16:43,120
to simulate

396
00:16:43,120 --> 00:16:44,639
[Music]

397
00:16:44,639 --> 00:16:46,959
unknown malware families what we call

398
00:16:46,959 --> 00:16:49,120
the zero-day malware families

399
00:16:49,120 --> 00:16:52,079
we had a separate set of malware samples

400
00:16:52,079 --> 00:16:55,360
that were not included in our repository

401
00:16:55,360 --> 00:16:58,480
of known malware

402
00:16:59,839 --> 00:17:02,399
so here you have the

403
00:17:02,399 --> 00:17:04,160
different

404
00:17:04,160 --> 00:17:07,039
data set that we use so we have our

405
00:17:07,039 --> 00:17:09,520
non-malware repository

406
00:17:09,520 --> 00:17:11,679
you have a list of some of the malware

407
00:17:11,679 --> 00:17:14,799
families we have the list of our benign

408
00:17:14,799 --> 00:17:18,240
repository with some of the executables

409
00:17:18,240 --> 00:17:20,400
that were part of it

410
00:17:20,400 --> 00:17:22,880
and then we have our zero day set of

411
00:17:22,880 --> 00:17:26,319
malware so you see that

412
00:17:26,319 --> 00:17:29,120
the malware families in their zero days

413
00:17:29,120 --> 00:17:32,240
set were not included in our repository

414
00:17:32,240 --> 00:17:35,200
of known malware

415
00:17:36,480 --> 00:17:38,640
and here you have the results of our

416
00:17:38,640 --> 00:17:40,080
analysis

417
00:17:40,080 --> 00:17:42,320
so um

418
00:17:42,320 --> 00:17:44,320
all the zero-day

419
00:17:44,320 --> 00:17:46,559
malware samples

420
00:17:46,559 --> 00:17:48,480
were found in

421
00:17:48,480 --> 00:17:51,120
the zero-day malware families in other

422
00:17:51,120 --> 00:17:52,400
words

423
00:17:52,400 --> 00:17:53,760
there were no

424
00:17:53,760 --> 00:17:55,360
zero-day

425
00:17:55,360 --> 00:17:58,880
malware samples that were found in the

426
00:17:58,880 --> 00:18:00,880
known repository of

427
00:18:00,880 --> 00:18:03,679
of malware so this is very good

428
00:18:03,679 --> 00:18:06,640
the precision is quite good

429
00:18:06,640 --> 00:18:07,919
we got

430
00:18:07,919 --> 00:18:10,720
some false positive for the

431
00:18:10,720 --> 00:18:16,799
fatcula and the renault floss families

432
00:18:16,880 --> 00:18:19,280
so this is an example of a result that

433
00:18:19,280 --> 00:18:22,559
we were able to get

434
00:18:22,640 --> 00:18:25,440
so in this case

435
00:18:25,440 --> 00:18:27,760
the malware sample

436
00:18:27,760 --> 00:18:32,039
consisted of 356 functions

437
00:18:32,039 --> 00:18:33,600
156

438
00:18:33,600 --> 00:18:36,960
functions belong to the evora family and

439
00:18:36,960 --> 00:18:40,799
the 145 to the fatula family

440
00:18:40,799 --> 00:18:44,000
and since uh the evara family was the

441
00:18:44,000 --> 00:18:46,480
family which contained the most uh

442
00:18:46,480 --> 00:18:48,720
function then we

443
00:18:48,720 --> 00:18:52,080
the tool determined that this particular

444
00:18:52,080 --> 00:18:54,720
malware sample belonged to the evara

445
00:18:54,720 --> 00:18:57,720
family

446
00:18:58,000 --> 00:18:59,200
so

447
00:18:59,200 --> 00:19:01,280
as part of the experiment results the

448
00:19:01,280 --> 00:19:03,200
majority of the malware families were

449
00:19:03,200 --> 00:19:05,520
correctly matched

450
00:19:05,520 --> 00:19:08,240
was a 100 percent ratio

451
00:19:08,240 --> 00:19:10,880
there were two false negative for the

452
00:19:10,880 --> 00:19:12,320
fatula

453
00:19:12,320 --> 00:19:14,720
family and one false negative for the

454
00:19:14,720 --> 00:19:17,039
renal floss family

455
00:19:17,039 --> 00:19:18,400
and

456
00:19:18,400 --> 00:19:21,120
if i go back to this

457
00:19:21,120 --> 00:19:22,559
to this result

458
00:19:22,559 --> 00:19:26,160
so um if it was so in this case we

459
00:19:26,160 --> 00:19:27,520
treated

460
00:19:27,520 --> 00:19:30,640
these malware samples as unknown malware

461
00:19:30,640 --> 00:19:32,960
but in reality we knew

462
00:19:32,960 --> 00:19:35,760
what they were but if we had really used

463
00:19:35,760 --> 00:19:39,039
unknown malware so we have we we would

464
00:19:39,039 --> 00:19:42,559
have obtained the same uh

465
00:19:42,559 --> 00:19:45,039
similarity matrix but the only

466
00:19:45,039 --> 00:19:47,440
difference is that we wouldn't have any

467
00:19:47,440 --> 00:19:48,559
labels

468
00:19:48,559 --> 00:19:51,039
so the only thing that we would know is

469
00:19:51,039 --> 00:19:52,400
that

470
00:19:52,400 --> 00:19:53,670
let's say

471
00:19:53,670 --> 00:19:55,440
[Music]

472
00:19:55,440 --> 00:19:57,039
so there were a certain number of

473
00:19:57,039 --> 00:19:59,520
families and

474
00:19:59,520 --> 00:20:01,840
all the malware samples belonging to

475
00:20:01,840 --> 00:20:04,400
this family had never been seen in our

476
00:20:04,400 --> 00:20:05,679
previous

477
00:20:05,679 --> 00:20:08,159
they were not in our previous repository

478
00:20:08,159 --> 00:20:11,120
of known malware

479
00:20:11,679 --> 00:20:12,559
so

480
00:20:12,559 --> 00:20:15,919
now i will show you a quick youtube

481
00:20:15,919 --> 00:20:18,159
video which gives you a short

482
00:20:18,159 --> 00:20:20,400
demonstration of the

483
00:20:20,400 --> 00:20:23,120
jarvis tool in action so this video was

484
00:20:23,120 --> 00:20:26,080
produced by a student from

485
00:20:26,080 --> 00:20:29,120
queen's university

486
00:20:30,400 --> 00:20:32,320
this is the main user interface for

487
00:20:32,320 --> 00:20:33,679
jarvis

488
00:20:33,679 --> 00:20:35,600
assets can be organized into searchable

489
00:20:35,600 --> 00:20:38,559
repositories and task driven projects

490
00:20:38,559 --> 00:20:41,440
in this demo we use the gw2 repo as an

491
00:20:41,440 --> 00:20:43,919
example

492
00:20:44,640 --> 00:20:46,960
here we see a list of projects

493
00:20:46,960 --> 00:20:48,640
basically they are virtual folders

494
00:20:48,640 --> 00:20:50,240
containing the malwares

495
00:20:50,240 --> 00:20:52,000
here we name them based on the malware

496
00:20:52,000 --> 00:20:52,880
family

497
00:20:52,880 --> 00:20:54,400
let's have a look at the reno floss

498
00:20:54,400 --> 00:20:56,799
family

499
00:20:59,280 --> 00:21:01,280
this folder contains some reno floss

500
00:21:01,280 --> 00:21:03,200
malware and analytic results under the

501
00:21:03,200 --> 00:21:04,400
tree view

502
00:21:04,400 --> 00:21:06,720
in this interactive interface you can

503
00:21:06,720 --> 00:21:08,720
inspect the disassembled content by

504
00:21:08,720 --> 00:21:12,799
clicking on one of the assets

505
00:21:15,120 --> 00:21:17,039
here on the left you can find a full

506
00:21:17,039 --> 00:21:18,640
list of assembly functions for this

507
00:21:18,640 --> 00:21:21,039
malware clicking any of them will bring

508
00:21:21,039 --> 00:21:25,640
us to its assembly code on the right

509
00:21:35,679 --> 00:21:37,679
at the same time the system will show

510
00:21:37,679 --> 00:21:40,159
similar functions searched in real time

511
00:21:40,159 --> 00:21:43,039
on the right hand side

512
00:21:43,120 --> 00:21:44,799
let's have a look at the decomposition

513
00:21:44,799 --> 00:21:46,000
analysis

514
00:21:46,000 --> 00:21:48,720
going back to the project

515
00:21:48,720 --> 00:21:50,559
we can see that there is a composition

516
00:21:50,559 --> 00:21:54,480
result associated with this malware

517
00:21:56,080 --> 00:21:58,159
it shows the decomposition tree of the

518
00:21:58,159 --> 00:21:59,440
analysis

519
00:21:59,440 --> 00:22:03,200
there are 10 933 functions in total with

520
00:22:03,200 --> 00:22:05,679
over 8 000 of them that are matched to

521
00:22:05,679 --> 00:22:07,440
benign libraries

522
00:22:07,440 --> 00:22:09,360
clicking on the benign rectangle we can

523
00:22:09,360 --> 00:22:11,360
see what libraries are matched to the

524
00:22:11,360 --> 00:22:13,840
benign code

525
00:22:17,120 --> 00:22:19,360
and going back to the full view we can

526
00:22:19,360 --> 00:22:22,960
see that about 1 400 functions have been

527
00:22:22,960 --> 00:22:25,360
found from the reno floss family

528
00:22:25,360 --> 00:22:27,520
and clicking it we can see that one of

529
00:22:27,520 --> 00:22:29,919
them or all of them have been matched to

530
00:22:29,919 --> 00:22:34,080
this specific reno floss file

531
00:22:34,640 --> 00:22:36,320
on the right we can see a list of

532
00:22:36,320 --> 00:22:38,559
assembly functions extracted from this

533
00:22:38,559 --> 00:22:39,679
binary

534
00:22:39,679 --> 00:22:41,760
clicking on one entry will show the

535
00:22:41,760 --> 00:22:44,640
matched functions

536
00:22:47,360 --> 00:22:49,679
malware decomposition analysis enables

537
00:22:49,679 --> 00:22:52,000
us to inspect how code is reused and

538
00:22:52,000 --> 00:22:54,559
shared among malware enabling a deeper

539
00:22:54,559 --> 00:22:58,080
insight for threat analysis

540
00:22:58,720 --> 00:23:01,039
thank you

541
00:23:05,600 --> 00:23:07,280
thank you very much i'd like to take

542
00:23:07,280 --> 00:23:08,799
this opportunity to ask you for a

543
00:23:08,799 --> 00:23:10,000
question

544
00:23:10,000 --> 00:23:12,320
fascinating

545
00:23:12,320 --> 00:23:15,360
has your team thought about maybe using

546
00:23:15,360 --> 00:23:17,760
this kind of application in a general

547
00:23:17,760 --> 00:23:19,600
binary repository

548
00:23:19,600 --> 00:23:22,320
like a linux binary distribution or

549
00:23:22,320 --> 00:23:24,240
maybe like off of github

550
00:23:24,240 --> 00:23:25,600
where

551
00:23:25,600 --> 00:23:27,520
the general consensus or at least the

552
00:23:27,520 --> 00:23:28,880
general thought in many government and

553
00:23:28,880 --> 00:23:29,840
commodity

554
00:23:29,840 --> 00:23:32,000
businesses that hey we can't chose open

555
00:23:32,000 --> 00:23:33,120
source software there might be an

556
00:23:33,120 --> 00:23:34,720
embedded code and all that so i'm

557
00:23:34,720 --> 00:23:36,559
curious of like are you planning on

558
00:23:36,559 --> 00:23:38,320
broadening out

559
00:23:38,320 --> 00:23:40,080
the repositories of what you might use

560
00:23:40,080 --> 00:23:42,240
as a sample to short like i'm sure

561
00:23:42,240 --> 00:23:44,080
microsoft might be interested in you

562
00:23:44,080 --> 00:23:46,159
running this on microsoft store

563
00:23:46,159 --> 00:23:48,960
or apple or some other things because we

564
00:23:48,960 --> 00:23:51,840
have this is one of the many tools that

565
00:23:51,840 --> 00:23:54,480
we develop so we have other tools that

566
00:23:54,480 --> 00:23:55,200
we

567
00:23:55,200 --> 00:23:57,760
don't talk about it publicly that are

568
00:23:57,760 --> 00:23:59,520
doing the kind of thing that you're

569
00:23:59,520 --> 00:24:02,840
proposing perfect so each tool has its

570
00:24:02,840 --> 00:24:05,120
specific purpose

571
00:24:05,120 --> 00:24:07,120
okay since you said it was top secret

572
00:24:07,120 --> 00:24:08,880
and i can't you can't answer it i'm

573
00:24:08,880 --> 00:24:11,039
gonna ask you a different question uh

574
00:24:11,039 --> 00:24:14,480
we we saw a couple false positives um

575
00:24:14,480 --> 00:24:16,880
so i guess my next question would be uh

576
00:24:16,880 --> 00:24:18,640
of the benign code

577
00:24:18,640 --> 00:24:20,880
that you may have identified

578
00:24:20,880 --> 00:24:21,840
um

579
00:24:21,840 --> 00:24:23,279
how often you go back and maybe

580
00:24:23,279 --> 00:24:26,480
re-sample this or maybe do do peer

581
00:24:26,480 --> 00:24:28,799
cross-checking to see if the code is in

582
00:24:28,799 --> 00:24:31,279
truly benign because that could be an

583
00:24:31,279 --> 00:24:34,559
indication of yes positive so uh like in

584
00:24:34,559 --> 00:24:36,640
any tool you have you will have false

585
00:24:36,640 --> 00:24:39,360
positives but in the case of your benign

586
00:24:39,360 --> 00:24:40,480
samples

587
00:24:40,480 --> 00:24:42,640
the larger your set is

588
00:24:42,640 --> 00:24:45,279
the less false positives that you you

589
00:24:45,279 --> 00:24:46,400
will have

590
00:24:46,400 --> 00:24:47,919
thank you sir i don't want to take all

591
00:24:47,919 --> 00:24:49,440
the questions please uh we have a few

592
00:24:49,440 --> 00:24:50,320
minutes

593
00:24:50,320 --> 00:24:52,559
uh anybody else in the audience i could

594
00:24:52,559 --> 00:24:53,360
ask

595
00:24:53,360 --> 00:24:57,559
so many questions please sir

596
00:25:03,840 --> 00:25:05,520
first of all very impressive research

597
00:25:05,520 --> 00:25:07,440
that you did um let me take from a

598
00:25:07,440 --> 00:25:09,039
threat hunting perspective we usually

599
00:25:09,039 --> 00:25:10,559
always look at the red side what they

600
00:25:10,559 --> 00:25:13,120
would do to evade those detection

601
00:25:13,120 --> 00:25:15,520
techniques so in your case we would try

602
00:25:15,520 --> 00:25:18,480
to uh enhance the false positive so what

603
00:25:18,480 --> 00:25:20,880
would the attacker do actually to evade

604
00:25:20,880 --> 00:25:23,279
your analysis maybe just add random

605
00:25:23,279 --> 00:25:25,120
functions so that the the set of

606
00:25:25,120 --> 00:25:28,720
functions would would increase uh

607
00:25:28,720 --> 00:25:30,240
yeah it's um

608
00:25:30,240 --> 00:25:33,600
because you see when when you have a a

609
00:25:33,600 --> 00:25:36,960
malware sample and you are generating uh

610
00:25:36,960 --> 00:25:38,159
variants

611
00:25:38,159 --> 00:25:40,640
of this malware sample

612
00:25:40,640 --> 00:25:43,039
you you can modify it

613
00:25:43,039 --> 00:25:45,679
to some extent but it still has to to

614
00:25:45,679 --> 00:25:49,120
perform its uh malicious functions

615
00:25:49,120 --> 00:25:52,480
so they it they are a certain you you

616
00:25:52,480 --> 00:25:55,679
cannot change the malware from a to to z

617
00:25:55,679 --> 00:25:58,320
because it will it will not suit your

618
00:25:58,320 --> 00:26:00,080
your purpose

619
00:26:00,080 --> 00:26:01,120
so

620
00:26:01,120 --> 00:26:03,039
that's why we

621
00:26:03,039 --> 00:26:04,960
our assumption

622
00:26:04,960 --> 00:26:09,360
that i stated in my presentation is that

623
00:26:09,360 --> 00:26:12,000
malware variants they share the source

624
00:26:12,000 --> 00:26:15,520
code and they will share many phenotypes

625
00:26:15,520 --> 00:26:17,840
maybe not all of them but we believe

626
00:26:17,840 --> 00:26:22,000
that they will share many phenotypes

627
00:26:22,400 --> 00:26:23,120
but

628
00:26:23,120 --> 00:26:25,919
like like any solution it's not uh

629
00:26:25,919 --> 00:26:27,760
bulletproof

630
00:26:27,760 --> 00:26:29,200
it's like uh

631
00:26:29,200 --> 00:26:32,080
you know you know the virustotal website

632
00:26:32,080 --> 00:26:33,919
so uh

633
00:26:33,919 --> 00:26:36,720
some people they modify their malware

634
00:26:36,720 --> 00:26:40,000
they upload it to on the the website and

635
00:26:40,000 --> 00:26:42,640
they see how many of antivirus they

636
00:26:42,640 --> 00:26:44,559
detect their new var uh

637
00:26:44,559 --> 00:26:46,960
their new variant and they

638
00:26:46,960 --> 00:26:49,200
they keep modifying until they are

639
00:26:49,200 --> 00:26:51,679
satisfied with the results so

640
00:26:51,679 --> 00:26:55,039
the same thing could apply here but

641
00:26:55,039 --> 00:26:58,080
since we're not at the

642
00:26:58,080 --> 00:27:00,000
since we are looking at

643
00:27:00,000 --> 00:27:02,080
the phenotypes you know the

644
00:27:02,080 --> 00:27:04,400
containing the functions

645
00:27:04,400 --> 00:27:06,880
i believe this approach is more robust

646
00:27:06,880 --> 00:27:09,120
to uh to the different techniques that

647
00:27:09,120 --> 00:27:12,000
the malware authors are using to bypass

648
00:27:12,000 --> 00:27:15,600
antivirus engines

649
00:27:15,840 --> 00:27:17,440
thank you uh very much one more round of

650
00:27:17,440 --> 00:27:21,840
applause for philip uh thank you so much

651
00:27:23,520 --> 00:27:25,039
and again we'll we'll try to get to

652
00:27:25,039 --> 00:27:26,480
another question and answer at the very

653
00:27:26,480 --> 00:27:29,039
end if we have time uh

654
00:27:29,039 --> 00:27:31,039
i'd like to introduce my next uh guest

655
00:27:31,039 --> 00:27:32,640
speaker stefan anders is a security

656
00:27:32,640 --> 00:27:35,279
researcher at fraunhofer fkie cyber

657
00:27:35,279 --> 00:27:37,200
analysis and defense department and a

658
00:27:37,200 --> 00:27:39,600
phd candidate at the university of bonn

659
00:27:39,600 --> 00:27:41,679
his phd research focuses on developing

660
00:27:41,679 --> 00:27:42,799
new decom

661
00:27:42,799 --> 00:27:44,640
compilation approaches to facilitate

662
00:27:44,640 --> 00:27:47,120
malware analysis and program analysis in

663
00:27:47,120 --> 00:27:49,919
general simultaneously stefan is also

664
00:27:49,919 --> 00:27:51,279
involved in various teaching activities

665
00:27:51,279 --> 00:27:53,760
the university of bonn and hbrs in

666
00:27:53,760 --> 00:27:55,679
zhangtang esteem

667
00:27:55,679 --> 00:27:59,399
please flourish yours

668
00:28:02,000 --> 00:28:03,919
all right so my topic today is

669
00:28:03,919 --> 00:28:05,760
rethinking the compilation for malware

670
00:28:05,760 --> 00:28:07,039
analysis

671
00:28:07,039 --> 00:28:08,799
for those of you who know decompilation

672
00:28:08,799 --> 00:28:11,360
they know this is a highly technical

673
00:28:11,360 --> 00:28:13,840
topic so i try to break it down to a

674
00:28:13,840 --> 00:28:17,039
more high level and high level problem

675
00:28:17,039 --> 00:28:19,120
so first of all before we start a few

676
00:28:19,120 --> 00:28:22,000
words about myself and about my employer

677
00:28:22,000 --> 00:28:24,240
so i'm with fraunhofer fke

678
00:28:24,240 --> 00:28:25,840
for those of you who don't know

679
00:28:25,840 --> 00:28:28,240
fraunhofer it's europe's largest

680
00:28:28,240 --> 00:28:30,399
organization for applied research

681
00:28:30,399 --> 00:28:31,919
and

682
00:28:31,919 --> 00:28:33,440
well i'm working at the department for

683
00:28:33,440 --> 00:28:35,200
cyber analysis and defense at founder

684
00:28:35,200 --> 00:28:37,919
for fke where we have different working

685
00:28:37,919 --> 00:28:40,559
groups aiming at reaction prevention and

686
00:28:40,559 --> 00:28:43,440
detection of cyber attacks and yeah i

687
00:28:43,440 --> 00:28:45,600
myself working at mario analysis and

688
00:28:45,600 --> 00:28:47,760
intelligence somewhere between reaction

689
00:28:47,760 --> 00:28:49,840
and prevention

690
00:28:49,840 --> 00:28:50,720
so

691
00:28:50,720 --> 00:28:52,559
as introduced i'm also a phd candidate

692
00:28:52,559 --> 00:28:55,360
at university of born and both doing my

693
00:28:55,360 --> 00:28:58,480
day job and doing my phd studies i'm

694
00:28:58,480 --> 00:29:01,120
focusing on research about malaria

695
00:29:01,120 --> 00:29:04,000
program analysis and decompilation

696
00:29:04,000 --> 00:29:06,399
especially so

697
00:29:06,399 --> 00:29:08,880
yeah the most two

698
00:29:08,880 --> 00:29:10,720
the most two important projects right

699
00:29:10,720 --> 00:29:13,360
now for myself are the ufd compiler

700
00:29:13,360 --> 00:29:15,200
which you're going to see in the final

701
00:29:15,200 --> 00:29:16,880
part of this talk

702
00:29:16,880 --> 00:29:19,600
and also mypedia which some of you may

703
00:29:19,600 --> 00:29:21,120
already know

704
00:29:21,120 --> 00:29:23,440
it's basically an encyclopedia for for

705
00:29:23,440 --> 00:29:25,919
malware so we just heard about um

706
00:29:25,919 --> 00:29:27,919
malware families and

707
00:29:27,919 --> 00:29:30,080
that one mirror family basically is like

708
00:29:30,080 --> 00:29:31,279
a code base

709
00:29:31,279 --> 00:29:34,000
for um for given like a software base

710
00:29:34,000 --> 00:29:36,799
for a given memory fm and

711
00:29:36,799 --> 00:29:39,039
well at milpita we try to track all of

712
00:29:39,039 --> 00:29:41,679
the versions of the same area

713
00:29:41,679 --> 00:29:43,919
and

714
00:29:43,919 --> 00:29:46,720
and annotate them with some references

715
00:29:46,720 --> 00:29:48,960
yaha rules and so on so

716
00:29:48,960 --> 00:29:50,640
i suggest to check it out if you don't

717
00:29:50,640 --> 00:29:52,960
already know it

718
00:29:52,960 --> 00:29:55,279
so i probably don't have to tell you

719
00:29:55,279 --> 00:29:56,240
that

720
00:29:56,240 --> 00:29:58,159
malware is more important than ever so

721
00:29:58,159 --> 00:29:59,440
there are

722
00:29:59,440 --> 00:30:02,480
individuals companies states hospitals

723
00:30:02,480 --> 00:30:03,760
universities

724
00:30:03,760 --> 00:30:06,559
and they're all attacked by

725
00:30:06,559 --> 00:30:08,960
by cyber threats there's malware

726
00:30:08,960 --> 00:30:10,799
everywhere

727
00:30:10,799 --> 00:30:12,880
if you take a look at the latest av test

728
00:30:12,880 --> 00:30:14,640
statistics

729
00:30:14,640 --> 00:30:17,520
we already surpassed the number of 1

730
00:30:17,520 --> 00:30:20,559
billion total unique memory samples

731
00:30:20,559 --> 00:30:23,039
which with millions

732
00:30:23,039 --> 00:30:24,480
with new

733
00:30:24,480 --> 00:30:26,240
with millions of new male samples each

734
00:30:26,240 --> 00:30:27,120
year

735
00:30:27,120 --> 00:30:29,120
and this is already the first main

736
00:30:29,120 --> 00:30:30,799
challenge in my opinion

737
00:30:30,799 --> 00:30:32,799
in melee analysis so we just have too

738
00:30:32,799 --> 00:30:35,120
much malware that we are not able to

739
00:30:35,120 --> 00:30:38,480
analyze um and on the other hand

740
00:30:38,480 --> 00:30:40,880
the second major challenge is that where

741
00:30:40,880 --> 00:30:42,480
we have too much malware and we have too

742
00:30:42,480 --> 00:30:45,679
few analysts and this is because mario

743
00:30:45,679 --> 00:30:48,080
analysis is highly it's a very complex

744
00:30:48,080 --> 00:30:49,120
topic

745
00:30:49,120 --> 00:30:52,000
it requires years of exercise and

746
00:30:52,000 --> 00:30:53,039
training

747
00:30:53,039 --> 00:30:55,360
so for all of you who try to find a good

748
00:30:55,360 --> 00:30:57,360
reverse engineer you should probably

749
00:30:57,360 --> 00:31:00,000
know that it's not easy to find one

750
00:31:00,000 --> 00:31:03,200
um at that there are very few on on this

751
00:31:03,200 --> 00:31:04,480
planet

752
00:31:04,480 --> 00:31:05,600
so yeah those are the two main

753
00:31:05,600 --> 00:31:07,440
challenges and at front of her we

754
00:31:07,440 --> 00:31:10,240
thought what can we do to solve this to

755
00:31:10,240 --> 00:31:11,919
counter the steadily increasing number

756
00:31:11,919 --> 00:31:13,600
of malware samples

757
00:31:13,600 --> 00:31:14,399
and

758
00:31:14,399 --> 00:31:17,120
we came up with two basic solutions so

759
00:31:17,120 --> 00:31:18,960
on the one hand we want to simplify

760
00:31:18,960 --> 00:31:21,440
analysis so that

761
00:31:21,440 --> 00:31:22,960
that more people would be able to

762
00:31:22,960 --> 00:31:25,440
analyze malware and not only those who

763
00:31:25,440 --> 00:31:27,519
had been exercising and

764
00:31:27,519 --> 00:31:29,360
doing this for years

765
00:31:29,360 --> 00:31:31,360
and on the other hand also support the

766
00:31:31,360 --> 00:31:34,080
analysis of those so yeah and the great

767
00:31:34,080 --> 00:31:35,279
thing

768
00:31:35,279 --> 00:31:36,880
and this is also where i showed this for

769
00:31:36,880 --> 00:31:39,360
my phd studies is that by improving

770
00:31:39,360 --> 00:31:42,159
decompilation we can actually do both so

771
00:31:42,159 --> 00:31:44,559
we can ease analysis and we can also

772
00:31:44,559 --> 00:31:48,240
support experienced analysts

773
00:31:48,240 --> 00:31:50,559
so i was talking about decompilation a

774
00:31:50,559 --> 00:31:52,720
lot so let me first

775
00:31:52,720 --> 00:31:54,240
first explain what decompilation

776
00:31:54,240 --> 00:31:55,360
actually is

777
00:31:55,360 --> 00:31:58,240
so if let's say a malware a malware

778
00:31:58,240 --> 00:32:01,279
author is writing new malware so

779
00:32:01,279 --> 00:32:03,600
some arbitrary thread actor

780
00:32:03,600 --> 00:32:06,080
the way this works is that as for usual

781
00:32:06,080 --> 00:32:08,080
computer programs you would write it in

782
00:32:08,080 --> 00:32:09,440
some kind of source code like on the

783
00:32:09,440 --> 00:32:12,159
slide in the c language and then it has

784
00:32:12,159 --> 00:32:14,080
to be compiled to binary code using a

785
00:32:14,080 --> 00:32:15,200
compiler

786
00:32:15,200 --> 00:32:17,279
and there is a substantial information

787
00:32:17,279 --> 00:32:20,080
loss during look during compilation

788
00:32:20,080 --> 00:32:22,559
so there are just some things that are

789
00:32:22,559 --> 00:32:24,480
not necessary for execution like the

790
00:32:24,480 --> 00:32:27,120
variable names or function names that

791
00:32:27,120 --> 00:32:30,240
have been assigned by the developer

792
00:32:30,240 --> 00:32:32,799
so be aware that this process is by

793
00:32:32,799 --> 00:32:35,279
nature not reversible

794
00:32:35,279 --> 00:32:37,440
well and then as in memory analysis

795
00:32:37,440 --> 00:32:39,279
you're given this executable code and

796
00:32:39,279 --> 00:32:40,799
have to analyze it because the source

797
00:32:40,799 --> 00:32:43,360
code is apparently and obviously not

798
00:32:43,360 --> 00:32:46,399
distributed because only the sample

799
00:32:46,399 --> 00:32:49,840
the executable code is needed to be ran

800
00:32:49,840 --> 00:32:52,240
to cause to cause some damage

801
00:32:52,240 --> 00:32:54,159
yeah so the question is how to analyze

802
00:32:54,159 --> 00:32:56,799
the executable code so the first step

803
00:32:56,799 --> 00:32:58,640
would be to use a disassembler to get

804
00:32:58,640 --> 00:33:00,960
back the assembly code so so each byte

805
00:33:00,960 --> 00:33:03,679
sequence of the executable binary code

806
00:33:03,679 --> 00:33:05,600
corresponds to certain assembly

807
00:33:05,600 --> 00:33:08,080
instructions and you'll end up with the

808
00:33:08,080 --> 00:33:09,679
assembly code like display on the right

809
00:33:09,679 --> 00:33:11,039
on the slide

810
00:33:11,039 --> 00:33:13,360
which is still pretty

811
00:33:13,360 --> 00:33:17,360
well pretty low level and hard to read

812
00:33:17,360 --> 00:33:19,600
many years ago meta analysis when

813
00:33:19,600 --> 00:33:22,000
decompilers went around or at least not

814
00:33:22,000 --> 00:33:24,480
as advanced as today's we're just using

815
00:33:24,480 --> 00:33:26,159
this assembly language to analyze the

816
00:33:26,159 --> 00:33:28,799
malware and it requires use of training

817
00:33:28,799 --> 00:33:31,600
to be able to adequately understand this

818
00:33:31,600 --> 00:33:33,120
because it's so low level there are no

819
00:33:33,120 --> 00:33:35,679
concepts like variables or conditions

820
00:33:35,679 --> 00:33:39,360
only stack usages registers and flags

821
00:33:39,360 --> 00:33:41,279
so this is where the compilers come into

822
00:33:41,279 --> 00:33:43,360
place the goal of a decompiler is to

823
00:33:43,360 --> 00:33:45,919
derive a more high level representation

824
00:33:45,919 --> 00:33:48,000
so we essentially want something like we

825
00:33:48,000 --> 00:33:51,200
had before something like like c code

826
00:33:51,200 --> 00:33:53,360
that is easier to understand that is

827
00:33:53,360 --> 00:33:55,360
made for humans to be understand and to

828
00:33:55,360 --> 00:33:56,720
be written

829
00:33:56,720 --> 00:33:58,640
and this can then be used especially for

830
00:33:58,640 --> 00:34:00,480
manual analysis but also for some

831
00:34:00,480 --> 00:34:02,399
automated approaches

832
00:34:02,399 --> 00:34:04,240
and as you can see on this example the

833
00:34:04,240 --> 00:34:06,640
variable names already don't have the

834
00:34:06,640 --> 00:34:08,960
original ones because they were lost

835
00:34:08,960 --> 00:34:10,960
during compilation so the decompiler has

836
00:34:10,960 --> 00:34:12,399
to choose

837
00:34:12,399 --> 00:34:14,719
um how to replace those information that

838
00:34:14,719 --> 00:34:16,879
have been lost

839
00:34:16,879 --> 00:34:19,520
yeah so basically decompilation is very

840
00:34:19,520 --> 00:34:21,760
complex but also essential for malware

841
00:34:21,760 --> 00:34:22,879
analysis

842
00:34:22,879 --> 00:34:25,119
as i said there is and there is a

843
00:34:25,119 --> 00:34:26,560
substantial information loss during

844
00:34:26,560 --> 00:34:29,040
compilation but that's not all we also

845
00:34:29,040 --> 00:34:31,199
have various compiler optimizations

846
00:34:31,199 --> 00:34:33,199
which which actually aggravate the

847
00:34:33,199 --> 00:34:35,520
decompilation process and aggravate

848
00:34:35,520 --> 00:34:37,839
analysis on assembly level

849
00:34:37,839 --> 00:34:40,399
so because it's such a highly complex

850
00:34:40,399 --> 00:34:42,399
complex field there are not that many

851
00:34:42,399 --> 00:34:43,918
approaches for decompilation but there

852
00:34:43,918 --> 00:34:45,280
are some

853
00:34:45,280 --> 00:34:48,159
i think many or most of you have heard

854
00:34:48,159 --> 00:34:50,480
of jidra which is the

855
00:34:50,480 --> 00:34:52,879
the binary analysis framework from the

856
00:34:52,879 --> 00:34:54,079
nsa

857
00:34:54,079 --> 00:34:56,399
and then there's also the

858
00:34:56,399 --> 00:34:58,640
the commercial state of the ad compiler

859
00:34:58,640 --> 00:35:01,440
hex-rays which is integrated in ida pro

860
00:35:01,440 --> 00:35:03,280
and basically used by everyone who's

861
00:35:03,280 --> 00:35:05,440
professionally reversing malware

862
00:35:05,440 --> 00:35:07,440
so here there are a bunch of others

863
00:35:07,440 --> 00:35:09,359
especially research decompilers each

864
00:35:09,359 --> 00:35:11,040
having their flaws

865
00:35:11,040 --> 00:35:13,119
and all in all which led to always what

866
00:35:13,119 --> 00:35:16,079
led to our research is that at fauna we

867
00:35:16,079 --> 00:35:18,240
think there is still a lot of room for

868
00:35:18,240 --> 00:35:20,720
improvements because um

869
00:35:20,720 --> 00:35:22,880
none of those existing approaches are

870
00:35:22,880 --> 00:35:24,800
optimal yet and

871
00:35:24,800 --> 00:35:26,320
produce optimal results for malware

872
00:35:26,320 --> 00:35:29,839
analysis and this is one major challenge

873
00:35:29,839 --> 00:35:30,640
when

874
00:35:30,640 --> 00:35:32,160
when dealing with the increasing number

875
00:35:32,160 --> 00:35:33,359
of samples

876
00:35:33,359 --> 00:35:35,760
yeah so what we try to do is we wanted

877
00:35:35,760 --> 00:35:38,240
to try find out what aspects in the

878
00:35:38,240 --> 00:35:41,280
compilation we we should improve

879
00:35:41,280 --> 00:35:43,359
so almost naturally we thought let's get

880
00:35:43,359 --> 00:35:44,400
in touch with

881
00:35:44,400 --> 00:35:46,720
with some more professionals ask some

882
00:35:46,720 --> 00:35:48,640
professional reversals

883
00:35:48,640 --> 00:35:49,920
and then let's assess the current

884
00:35:49,920 --> 00:35:52,960
limitation of limitations of approaches

885
00:35:52,960 --> 00:35:53,760
so

886
00:35:53,760 --> 00:35:56,160
yeah basically leverage on on domain

887
00:35:56,160 --> 00:35:58,960
knowledge of all kinds of people and two

888
00:35:58,960 --> 00:36:00,640
main questions we asked ourselves was

889
00:36:00,640 --> 00:36:02,880
how can we support automated approaches

890
00:36:02,880 --> 00:36:04,480
that they're already using or that

891
00:36:04,480 --> 00:36:06,240
they're working on

892
00:36:06,240 --> 00:36:07,839
and how to increase readability for

893
00:36:07,839 --> 00:36:09,599
manual analysis

894
00:36:09,599 --> 00:36:11,680
the thing about automated versus manual

895
00:36:11,680 --> 00:36:14,000
analysis is that in our opinion that

896
00:36:14,000 --> 00:36:15,280
faunhofer

897
00:36:15,280 --> 00:36:18,000
you can only automate things to to a

898
00:36:18,000 --> 00:36:19,440
certain extent

899
00:36:19,440 --> 00:36:21,280
and oftentimes have to resort to manual

900
00:36:21,280 --> 00:36:23,920
lenses eventually so this is why we try

901
00:36:23,920 --> 00:36:26,240
to aim at both and not only support

902
00:36:26,240 --> 00:36:28,240
automation but also and especially

903
00:36:28,240 --> 00:36:30,640
manual analysis well and the final thing

904
00:36:30,640 --> 00:36:32,160
that i'd like to mention here is that we

905
00:36:32,160 --> 00:36:35,280
not only included reversers so we also

906
00:36:35,280 --> 00:36:37,839
asked and included people especially

907
00:36:37,839 --> 00:36:40,320
especially without reversing knowledge

908
00:36:40,320 --> 00:36:42,240
but programming knowledge because

909
00:36:42,240 --> 00:36:44,320
ultimately what we want to reach is a

910
00:36:44,320 --> 00:36:48,079
decompiler that that allows people even

911
00:36:48,079 --> 00:36:49,520
without reversing skills without

912
00:36:49,520 --> 00:36:52,000
assembly skills to analyze real world

913
00:36:52,000 --> 00:36:54,880
malware because this way we could

914
00:36:54,880 --> 00:36:56,880
increase the number of analysts and the

915
00:36:56,880 --> 00:37:00,079
number of samples that can be analyzed

916
00:37:00,079 --> 00:37:01,680
so i could talk hours about the results

917
00:37:01,680 --> 00:37:03,119
from those surveys

918
00:37:03,119 --> 00:37:05,920
we did a total of three of them one in

919
00:37:05,920 --> 00:37:10,000
the end of 2020 and to the last year

920
00:37:10,000 --> 00:37:11,920
as you may notice the number of

921
00:37:11,920 --> 00:37:13,760
participants is quite low

922
00:37:13,760 --> 00:37:14,640
um

923
00:37:14,640 --> 00:37:16,640
however this is this is just because

924
00:37:16,640 --> 00:37:19,440
there are so few reversals there and

925
00:37:19,440 --> 00:37:22,160
even fewer who agree to to participate

926
00:37:22,160 --> 00:37:23,359
in a survey

927
00:37:23,359 --> 00:37:25,440
that um takes

928
00:37:25,440 --> 00:37:27,680
yeah quite amount of time so we were

929
00:37:27,680 --> 00:37:30,079
told that a survey should not last

930
00:37:30,079 --> 00:37:33,119
longer than five minutes however

931
00:37:33,119 --> 00:37:34,880
for those of you who know you

932
00:37:34,880 --> 00:37:36,960
who some

933
00:37:36,960 --> 00:37:39,119
sometimes reverse some sample it's just

934
00:37:39,119 --> 00:37:40,720
not possible to do anything in five

935
00:37:40,720 --> 00:37:43,359
minutes so we tried to aim at one hour

936
00:37:43,359 --> 00:37:45,520
ended up with a median of two hours in

937
00:37:45,520 --> 00:37:47,119
our first survey

938
00:37:47,119 --> 00:37:48,960
we were able to bring it down

939
00:37:48,960 --> 00:37:51,200
to under one hour but

940
00:37:51,200 --> 00:37:53,440
that's basically the best you can do for

941
00:37:53,440 --> 00:37:56,160
such a specific and technical topic

942
00:37:56,160 --> 00:37:57,359
so what i'm going to do in the rest of

943
00:37:57,359 --> 00:38:00,079
this talk is i want to focus on the two

944
00:38:00,079 --> 00:38:02,880
key results we observed and found out

945
00:38:02,880 --> 00:38:05,359
during our surveys and how we can use

946
00:38:05,359 --> 00:38:07,040
them to improve decompilation and how

947
00:38:07,040 --> 00:38:08,400
others could use them to improve

948
00:38:08,400 --> 00:38:11,200
decompilation for memory analysis so the

949
00:38:11,200 --> 00:38:12,880
first key result is

950
00:38:12,880 --> 00:38:14,560
one thing that participants even

951
00:38:14,560 --> 00:38:16,720
mentioned without being asked already in

952
00:38:16,720 --> 00:38:19,040
the first survey is that current

953
00:38:19,040 --> 00:38:20,560
approaches and decompilers are not

954
00:38:20,560 --> 00:38:23,280
configurable enough and this is very

955
00:38:23,280 --> 00:38:25,079
surprising and unintuitive because

956
00:38:25,079 --> 00:38:27,200
configurability is

957
00:38:27,200 --> 00:38:29,680
very essential for many kinds of tools

958
00:38:29,680 --> 00:38:32,880
i put two very practical

959
00:38:32,880 --> 00:38:35,119
examples on the slide so

960
00:38:35,119 --> 00:38:37,359
let's say we have this adjustable wrench

961
00:38:37,359 --> 00:38:38,880
on on the right

962
00:38:38,880 --> 00:38:40,800
of course it has to be adjustable

963
00:38:40,800 --> 00:38:42,400
because otherwise you wouldn't be able

964
00:38:42,400 --> 00:38:44,400
to adjust it for the situation and

965
00:38:44,400 --> 00:38:47,040
tighten every type of screw or every

966
00:38:47,040 --> 00:38:48,800
size of screw

967
00:38:48,800 --> 00:38:50,560
then also like for the office chair you

968
00:38:50,560 --> 00:38:53,359
sometimes have to have to adjust your

969
00:38:53,359 --> 00:38:56,240
tool for the given use case or even more

970
00:38:56,240 --> 00:38:59,839
specific when talking manual analysis

971
00:38:59,839 --> 00:39:00,720
each

972
00:39:00,720 --> 00:39:01,680
each

973
00:39:01,680 --> 00:39:04,400
type of analysis from from two different

974
00:39:04,400 --> 00:39:06,960
people maybe may vastly differ from each

975
00:39:06,960 --> 00:39:09,040
other so they may be using different a

976
00:39:09,040 --> 00:39:11,119
different methodic or

977
00:39:11,119 --> 00:39:13,040
they just are used to different things

978
00:39:13,040 --> 00:39:15,760
so you can you can considerably increase

979
00:39:15,760 --> 00:39:18,320
effectiveness from their analysis when

980
00:39:18,320 --> 00:39:19,920
allowing them to adjust the tools to

981
00:39:19,920 --> 00:39:21,839
their needs so those are the two main

982
00:39:21,839 --> 00:39:23,680
reasons why we need configurability and

983
00:39:23,680 --> 00:39:25,440
decompilation

984
00:39:25,440 --> 00:39:27,040
let's take a look at

985
00:39:27,040 --> 00:39:29,359
two examples so

986
00:39:29,359 --> 00:39:31,440
the first one is is quite simple so we

987
00:39:31,440 --> 00:39:32,160
have

988
00:39:32,160 --> 00:39:34,640
the topic constant representation

989
00:39:34,640 --> 00:39:37,200
if we have some constant values in the

990
00:39:37,200 --> 00:39:39,119
compiler output

991
00:39:39,119 --> 00:39:40,960
the decompiler basically has to decide

992
00:39:40,960 --> 00:39:44,160
how to display them in the output c code

993
00:39:44,160 --> 00:39:46,079
and well there are different options

994
00:39:46,079 --> 00:39:48,079
let's say we have an integer value you

995
00:39:48,079 --> 00:39:50,880
can see on the left that for the sample

996
00:39:50,880 --> 00:39:52,640
we can choose between a character

997
00:39:52,640 --> 00:39:54,880
representation or a hexadecimal

998
00:39:54,880 --> 00:39:57,599
representation so all of those values

999
00:39:57,599 --> 00:40:00,160
have been in the ascii range so can also

1000
00:40:00,160 --> 00:40:02,560
be displayed at characters and because

1001
00:40:02,560 --> 00:40:04,079
in this sample

1002
00:40:04,079 --> 00:40:06,000
we actually compare individual letters

1003
00:40:06,000 --> 00:40:07,920
of a string it makes sense to use the

1004
00:40:07,920 --> 00:40:10,000
first option because those are actually

1005
00:40:10,000 --> 00:40:12,160
characters and this this as so

1006
00:40:12,160 --> 00:40:14,800
displaying constants this way may

1007
00:40:14,800 --> 00:40:17,920
facilitate analysis on the other side on

1008
00:40:17,920 --> 00:40:20,480
on the right side in sample 2 we are

1009
00:40:20,480 --> 00:40:22,560
calculating a number so we don't want to

1010
00:40:22,560 --> 00:40:26,240
have a child representation although you

1011
00:40:26,240 --> 00:40:29,520
might display the value 65

1012
00:40:29,520 --> 00:40:31,440
as a capital a

1013
00:40:31,440 --> 00:40:32,800
so it really just depends on the

1014
00:40:32,800 --> 00:40:34,560
situation you're in and on the sample

1015
00:40:34,560 --> 00:40:37,440
you're dealing and this is just a very

1016
00:40:37,440 --> 00:40:40,000
very simple example of why this should

1017
00:40:40,000 --> 00:40:42,480
be configurable in the compilers

1018
00:40:42,480 --> 00:40:43,920
the second one

1019
00:40:43,920 --> 00:40:46,079
maybe a little bit more interesting

1020
00:40:46,079 --> 00:40:48,079
is that we should also be able to

1021
00:40:48,079 --> 00:40:50,720
optimize depending on use case so as i

1022
00:40:50,720 --> 00:40:53,599
said depending on whether we have a

1023
00:40:53,599 --> 00:40:56,240
automated approach or manual approach

1024
00:40:56,240 --> 00:40:57,839
we want to have a different kind of

1025
00:40:57,839 --> 00:40:59,760
output so this is actually the same

1026
00:40:59,760 --> 00:41:03,280
sample that has been decompiled with

1027
00:41:03,280 --> 00:41:05,839
identical configurations except for one

1028
00:41:05,839 --> 00:41:07,599
option except for the autofocus

1029
00:41:07,599 --> 00:41:09,359
algorithm that we used

1030
00:41:09,359 --> 00:41:12,000
and as you can see changing this single

1031
00:41:12,000 --> 00:41:13,920
option produces a drastically

1032
00:41:13,920 --> 00:41:16,400
drastically different output so on the

1033
00:41:16,400 --> 00:41:17,839
left we have a quite low level

1034
00:41:17,839 --> 00:41:19,760
representation because we use a very

1035
00:41:19,760 --> 00:41:22,319
simple out of ssa algorithm this may be

1036
00:41:22,319 --> 00:41:24,640
beneficial for some automated approaches

1037
00:41:24,640 --> 00:41:25,839
that

1038
00:41:25,839 --> 00:41:28,400
don't don't profit from too many

1039
00:41:28,400 --> 00:41:30,560
abstraction layers on the other side

1040
00:41:30,560 --> 00:41:32,960
option two is

1041
00:41:32,960 --> 00:41:36,160
well pretty much more high level we

1042
00:41:36,160 --> 00:41:39,040
concluded certain variables and

1043
00:41:39,040 --> 00:41:40,400
well have

1044
00:41:40,400 --> 00:41:42,480
drastically fewer lines of code that the

1045
00:41:42,480 --> 00:41:45,119
analysts have to analyze so again we

1046
00:41:45,119 --> 00:41:48,000
have to optimize depending on use case

1047
00:41:48,000 --> 00:41:50,880
the second key result we observed where

1048
00:41:50,880 --> 00:41:53,359
we first observed it and then we

1049
00:41:53,359 --> 00:41:55,359
validated it using the survey

1050
00:41:55,359 --> 00:41:58,240
is that right now many decompilers try

1051
00:41:58,240 --> 00:42:00,720
to reconstruct the original source code

1052
00:42:00,720 --> 00:42:02,640
as good as they can

1053
00:42:02,640 --> 00:42:04,720
however this isn't this isn't always

1054
00:42:04,720 --> 00:42:07,280
what we want so because as i told you

1055
00:42:07,280 --> 00:42:08,960
the

1056
00:42:08,960 --> 00:42:09,920
the

1057
00:42:09,920 --> 00:42:12,000
compilation process has a heavy

1058
00:42:12,000 --> 00:42:13,839
information loss

1059
00:42:13,839 --> 00:42:16,400
so a real one-to-one reconstruction

1060
00:42:16,400 --> 00:42:18,560
isn't even possible so why bother trying

1061
00:42:18,560 --> 00:42:20,000
instead what we should do and what

1062
00:42:20,000 --> 00:42:21,520
decompilers should do

1063
00:42:21,520 --> 00:42:22,319
is

1064
00:42:22,319 --> 00:42:24,240
they they should focus on how the output

1065
00:42:24,240 --> 00:42:26,480
is used and then try to come up with the

1066
00:42:26,480 --> 00:42:29,119
best representation for it so right now

1067
00:42:29,119 --> 00:42:32,319
they try to stick to assembly very much

1068
00:42:32,319 --> 00:42:35,040
but this may not just not be optimal

1069
00:42:35,040 --> 00:42:38,000
so let's think of a practical example so

1070
00:42:38,000 --> 00:42:39,839
um on the slide you can see

1071
00:42:39,839 --> 00:42:42,000
where we are right now so a map of

1072
00:42:42,000 --> 00:42:43,040
thailand

1073
00:42:43,040 --> 00:42:45,520
and well i think we can all agree that

1074
00:42:45,520 --> 00:42:48,079
this google maps image is a quite

1075
00:42:48,079 --> 00:42:50,240
detailed representation of of where we

1076
00:42:50,240 --> 00:42:51,520
are right now

1077
00:42:51,520 --> 00:42:53,760
however depending on the use case so

1078
00:42:53,760 --> 00:42:56,000
let's say we want to find a way from

1079
00:42:56,000 --> 00:42:58,640
here to to some other point this might

1080
00:42:58,640 --> 00:43:00,319
just not be optimal because you can't

1081
00:43:00,319 --> 00:43:02,720
properly identify which streets are

1082
00:43:02,720 --> 00:43:05,119
which are there one-way streets which

1083
00:43:05,119 --> 00:43:07,280
ones are the fastest so you might want

1084
00:43:07,280 --> 00:43:09,200
to choose a completely different

1085
00:43:09,200 --> 00:43:10,960
different representation which is in our

1086
00:43:10,960 --> 00:43:13,359
case more abstract annotated with some

1087
00:43:13,359 --> 00:43:15,520
other informations and

1088
00:43:15,520 --> 00:43:18,079
most important in our use case easier to

1089
00:43:18,079 --> 00:43:20,079
pass for navigation

1090
00:43:20,079 --> 00:43:22,480
let's take a look at how this might

1091
00:43:22,480 --> 00:43:25,440
might look in the compiler output

1092
00:43:25,440 --> 00:43:27,280
here we have again the same function

1093
00:43:27,280 --> 00:43:31,280
which has been decompiled using a

1094
00:43:31,280 --> 00:43:33,440
different approach so on the left we can

1095
00:43:33,440 --> 00:43:36,800
see the result produced by jitra

1096
00:43:36,800 --> 00:43:39,359
which is pretty much what the assembly

1097
00:43:39,359 --> 00:43:40,880
looks like

1098
00:43:40,880 --> 00:43:42,720
so the structure is pretty much implied

1099
00:43:42,720 --> 00:43:45,920
by the assembly and what happens here is

1100
00:43:45,920 --> 00:43:47,920
that a variable

1101
00:43:47,920 --> 00:43:50,560
is is compared to various numbers and

1102
00:43:50,560 --> 00:43:53,280
the thing is that for this kind of

1103
00:43:53,280 --> 00:43:55,440
for of code structure we have a more

1104
00:43:55,440 --> 00:43:58,640
specific a more specific variant in c we

1105
00:43:58,640 --> 00:44:01,440
could also use a switch construct and

1106
00:44:01,440 --> 00:44:03,599
well what we try to do is

1107
00:44:03,599 --> 00:44:04,319
we

1108
00:44:04,319 --> 00:44:06,240
instead of focusing on assembly just

1109
00:44:06,240 --> 00:44:07,920
come up with the best representation for

1110
00:44:07,920 --> 00:44:10,480
the sample and this leads us to through

1111
00:44:10,480 --> 00:44:12,960
the right side which i hope

1112
00:44:12,960 --> 00:44:15,680
you can see is just a little bit cleaner

1113
00:44:15,680 --> 00:44:16,480
and

1114
00:44:16,480 --> 00:44:19,760
better comprehensible when looked at by

1115
00:44:19,760 --> 00:44:21,680
a human analyst

1116
00:44:21,680 --> 00:44:24,960
the second example may be

1117
00:44:24,960 --> 00:44:27,599
one different type of restructuring

1118
00:44:27,599 --> 00:44:28,720
so

1119
00:44:28,720 --> 00:44:30,560
again it's the same function on the left

1120
00:44:30,560 --> 00:44:32,560
you can see an option that some

1121
00:44:32,560 --> 00:44:34,640
decompilers are using

1122
00:44:34,640 --> 00:44:38,000
basically we have an inserted go to

1123
00:44:38,000 --> 00:44:38,880
where

1124
00:44:38,880 --> 00:44:41,359
it jumps to a given label so you can

1125
00:44:41,359 --> 00:44:43,520
have the same kind of code and jump from

1126
00:44:43,520 --> 00:44:45,680
different locations to it

1127
00:44:45,680 --> 00:44:47,520
however this is

1128
00:44:47,520 --> 00:44:49,040
well again when considering manual

1129
00:44:49,040 --> 00:44:51,119
analysis that's not the best option

1130
00:44:51,119 --> 00:44:53,760
because go-to are very hard to read and

1131
00:44:53,760 --> 00:44:56,800
equivalent following the control flow

1132
00:44:56,800 --> 00:44:59,119
so some decompilers came up with with a

1133
00:44:59,119 --> 00:45:00,880
different approach and just copied the

1134
00:45:00,880 --> 00:45:01,839
code

1135
00:45:01,839 --> 00:45:03,839
at the given location so in the middle

1136
00:45:03,839 --> 00:45:04,800
we have

1137
00:45:04,800 --> 00:45:06,800
the same output using the using

1138
00:45:06,800 --> 00:45:08,480
duplication

1139
00:45:08,480 --> 00:45:10,800
however again this is still not optimal

1140
00:45:10,800 --> 00:45:12,319
because

1141
00:45:12,319 --> 00:45:14,560
well if you insert duplicates without

1142
00:45:14,560 --> 00:45:15,839
marking them

1143
00:45:15,839 --> 00:45:18,000
analysts have to waste time analyze them

1144
00:45:18,000 --> 00:45:20,720
twice and where you don't even don't

1145
00:45:20,720 --> 00:45:22,720
even know it sometimes

1146
00:45:22,720 --> 00:45:25,119
so a third way that we

1147
00:45:25,119 --> 00:45:27,760
may use it's not nothing we've done yet

1148
00:45:27,760 --> 00:45:28,640
but

1149
00:45:28,640 --> 00:45:30,720
something we thought of is you could

1150
00:45:30,720 --> 00:45:33,119
alternatively just introduce a new

1151
00:45:33,119 --> 00:45:35,839
function that's not there in assembly so

1152
00:45:35,839 --> 00:45:38,640
we somehow discard the the information

1153
00:45:38,640 --> 00:45:40,880
from the assembly we have and instead

1154
00:45:40,880 --> 00:45:43,520
insert calls and we received

1155
00:45:43,520 --> 00:45:45,839
in our survey in our final survey we

1156
00:45:45,839 --> 00:45:48,720
received very positive feedback from

1157
00:45:48,720 --> 00:45:50,720
from professional reversers that

1158
00:45:50,720 --> 00:45:53,040
something like this may may be

1159
00:45:53,040 --> 00:45:55,280
beneficial during manual analysis even

1160
00:45:55,280 --> 00:45:58,800
if not imposed by the assembly

1161
00:45:58,800 --> 00:46:01,359
so what we came up with is called the

1162
00:46:01,359 --> 00:46:03,359
dofd compiler so it's basically a

1163
00:46:03,359 --> 00:46:05,520
research decompiler

1164
00:46:05,520 --> 00:46:07,119
which is already

1165
00:46:07,119 --> 00:46:10,000
highly configurable we we made sure that

1166
00:46:10,000 --> 00:46:12,400
it's highly expandable and open sourced

1167
00:46:12,400 --> 00:46:14,560
it just because we want it as a base for

1168
00:46:14,560 --> 00:46:16,480
additional research not only for

1169
00:46:16,480 --> 00:46:18,400
ourselves but also from other resource

1170
00:46:18,400 --> 00:46:20,400
researchers because

1171
00:46:20,400 --> 00:46:22,560
where we think decompilation is such a

1172
00:46:22,560 --> 00:46:25,119
complex field that we will not be able

1173
00:46:25,119 --> 00:46:26,960
to solve it alone

1174
00:46:26,960 --> 00:46:28,880
we also publish all server results so

1175
00:46:28,880 --> 00:46:32,000
for anyone who's interested they're all

1176
00:46:32,000 --> 00:46:33,839
published on github as is the source

1177
00:46:33,839 --> 00:46:34,800
code

1178
00:46:34,800 --> 00:46:36,319
well and we're also currently writing a

1179
00:46:36,319 --> 00:46:37,920
paper about it

1180
00:46:37,920 --> 00:46:40,160
which is not available yet but it's

1181
00:46:40,160 --> 00:46:42,720
pre-printed on archive

1182
00:46:42,720 --> 00:46:45,040
so a few words about dwolf i don't want

1183
00:46:45,040 --> 00:46:47,839
to get too much into detail here

1184
00:46:47,839 --> 00:46:50,160
so the main the main algorithms the main

1185
00:46:50,160 --> 00:46:52,640
data flow and control flow algorithms

1186
00:46:52,640 --> 00:46:53,440
are

1187
00:46:53,440 --> 00:46:55,680
platform independent so

1188
00:46:55,680 --> 00:46:57,680
those are the um they are those in the

1189
00:46:57,680 --> 00:46:59,520
middle in the pipeline

1190
00:46:59,520 --> 00:47:00,720
and

1191
00:47:00,720 --> 00:47:02,160
this means they are portable to

1192
00:47:02,160 --> 00:47:04,240
alternative architectures right now we

1193
00:47:04,240 --> 00:47:07,440
just focused on x86 and x64 due to the

1194
00:47:07,440 --> 00:47:09,760
context of malware but this can all be

1195
00:47:09,760 --> 00:47:11,599
imported to different architectures very

1196
00:47:11,599 --> 00:47:12,800
simply

1197
00:47:12,800 --> 00:47:14,160
for the front end so for the

1198
00:47:14,160 --> 00:47:16,240
disassembling part we didn't implement

1199
00:47:16,240 --> 00:47:19,119
it ourselves so we chose but we chose

1200
00:47:19,119 --> 00:47:21,040
binary ninja instead

1201
00:47:21,040 --> 00:47:23,440
binary ninjas also a

1202
00:47:23,440 --> 00:47:26,640
binary analysis platform which actually

1203
00:47:26,640 --> 00:47:30,240
is developing their own decompiler but

1204
00:47:30,240 --> 00:47:31,920
well that's a different topic

1205
00:47:31,920 --> 00:47:33,599
so we use those

1206
00:47:33,599 --> 00:47:34,400
those

1207
00:47:34,400 --> 00:47:36,720
disassembler and start off analysis on

1208
00:47:36,720 --> 00:47:38,240
intermediate language and this just

1209
00:47:38,240 --> 00:47:40,160
allows us that everything we do is

1210
00:47:40,160 --> 00:47:41,760
platform independent and can be ported

1211
00:47:41,760 --> 00:47:43,359
to different frontends that's

1212
00:47:43,359 --> 00:47:45,839
essentially the point i'm trying to make

1213
00:47:45,839 --> 00:47:48,400
so as a conclusion

1214
00:47:48,400 --> 00:47:50,480
i and we had found offer really think

1215
00:47:50,480 --> 00:47:52,160
that we should further improve the

1216
00:47:52,160 --> 00:47:53,359
compilation

1217
00:47:53,359 --> 00:47:54,400
to

1218
00:47:54,400 --> 00:47:56,319
to counter the steadily increasing

1219
00:47:56,319 --> 00:47:58,240
number of malware samples

1220
00:47:58,240 --> 00:47:59,280
so

1221
00:47:59,280 --> 00:48:01,280
this could both benefit automated and

1222
00:48:01,280 --> 00:48:02,880
manual approaches

1223
00:48:02,880 --> 00:48:04,400
this could

1224
00:48:04,400 --> 00:48:06,559
this could facilitate the analysis of

1225
00:48:06,559 --> 00:48:08,240
professional reversals and this could

1226
00:48:08,240 --> 00:48:11,920
allow more people to reverse malware

1227
00:48:11,920 --> 00:48:13,599
as i showed you current approaches still

1228
00:48:13,599 --> 00:48:17,200
have many limitations to have them

1229
00:48:17,200 --> 00:48:18,880
configurability

1230
00:48:18,880 --> 00:48:21,920
and i'm sticking to assembly so

1231
00:48:21,920 --> 00:48:24,319
we need we need more configurability and

1232
00:48:24,319 --> 00:48:26,880
less sticking to assembly um i presented

1233
00:48:26,880 --> 00:48:29,119
you on the slides so we ourselves our

1234
00:48:29,119 --> 00:48:31,200
contribution is for now that we

1235
00:48:31,200 --> 00:48:32,800
introduced d-wolf to be used for future

1236
00:48:32,800 --> 00:48:35,040
research not only from ourselves but

1237
00:48:35,040 --> 00:48:37,040
also from other people

1238
00:48:37,040 --> 00:48:38,480
by the way if you know someone

1239
00:48:38,480 --> 00:48:40,640
interested in decompilation and who

1240
00:48:40,640 --> 00:48:43,680
might be able to partake in user surveys

1241
00:48:43,680 --> 00:48:45,119
we are always happy about new

1242
00:48:45,119 --> 00:48:47,680
participants so i'm giving my contact

1243
00:48:47,680 --> 00:48:49,760
info or just the email address dwolf at

1244
00:48:49,760 --> 00:48:53,760
fk ie 400a

1245
00:48:53,839 --> 00:48:55,920
yeah and again

1246
00:48:55,920 --> 00:48:58,640
as an outlook key result implications

1247
00:48:58,640 --> 00:49:01,520
future future decompilers should first

1248
00:49:01,520 --> 00:49:03,839
really be configurable as i already told

1249
00:49:03,839 --> 00:49:07,119
you it just allows optimizing the output

1250
00:49:07,119 --> 00:49:09,440
based on the given situation and based

1251
00:49:09,440 --> 00:49:11,200
on the given sample

1252
00:49:11,200 --> 00:49:13,599
also for a given use case

1253
00:49:13,599 --> 00:49:16,079
and finally we should more focus on how

1254
00:49:16,079 --> 00:49:18,640
the outpost is used and not

1255
00:49:18,640 --> 00:49:20,240
through um

1256
00:49:20,240 --> 00:49:21,920
and not to get in a representation an

1257
00:49:21,920 --> 00:49:23,440
exact representation of the original

1258
00:49:23,440 --> 00:49:26,160
source code so this way

1259
00:49:26,160 --> 00:49:28,800
where maybe some somebody else we didn't

1260
00:49:28,800 --> 00:49:30,480
yet but maybe somebody else is able to

1261
00:49:30,480 --> 00:49:32,319
come up with an entirely alternative

1262
00:49:32,319 --> 00:49:34,960
representation

1263
00:49:34,960 --> 00:49:37,680
so yeah but this is subject to future

1264
00:49:37,680 --> 00:49:38,720
research

1265
00:49:38,720 --> 00:49:42,520
thank you very much for your attention

1266
00:49:46,000 --> 00:49:48,000
thank you stefan i'll ask you a quick

1267
00:49:48,000 --> 00:49:49,680
question we have a couple minutes for uh

1268
00:49:49,680 --> 00:49:51,200
some more uh i'll just do something a

1269
00:49:51,200 --> 00:49:53,599
little bit more simple uh obvious choice

1270
00:49:53,599 --> 00:49:56,079
for c or c plus plus kind of language

1271
00:49:56,079 --> 00:49:58,240
output uh but lot of the languages are

1272
00:49:58,240 --> 00:50:00,160
growing more in popularity you have uh

1273
00:50:00,160 --> 00:50:01,440
google's go

1274
00:50:01,440 --> 00:50:03,680
you have mozilla's rust a couple other

1275
00:50:03,680 --> 00:50:06,880
languages that do uh specific data types

1276
00:50:06,880 --> 00:50:08,640
uh obviously python would probably not

1277
00:50:08,640 --> 00:50:11,920
be very good for this uh but uh do you

1278
00:50:11,920 --> 00:50:14,240
have you uh

1279
00:50:14,240 --> 00:50:17,280
looked back at uh generated code versus

1280
00:50:17,280 --> 00:50:20,400
the original code and see mismatches uh

1281
00:50:20,400 --> 00:50:22,079
by picking different languages such as

1282
00:50:22,079 --> 00:50:23,680
cc plus plus

1283
00:50:23,680 --> 00:50:24,480
uh

1284
00:50:24,480 --> 00:50:27,599
do you see a first a need to maybe use

1285
00:50:27,599 --> 00:50:29,359
uh i wouldn't say more modern language

1286
00:50:29,359 --> 00:50:31,440
these come and go but so something like

1287
00:50:31,440 --> 00:50:33,680
go or rust or some of the other ones

1288
00:50:33,680 --> 00:50:36,640
uh that may be a little bit more current

1289
00:50:36,640 --> 00:50:39,359
you mean for the output correct okay so

1290
00:50:39,359 --> 00:50:42,160
the thing is as i as i said um as i was

1291
00:50:42,160 --> 00:50:44,319
trying to make a point um the main

1292
00:50:44,319 --> 00:50:46,640
algorithms from the pipeline are all

1293
00:50:46,640 --> 00:50:48,400
platform independent and also

1294
00:50:48,400 --> 00:50:50,319
independent from the back end from from

1295
00:50:50,319 --> 00:50:52,800
the output language so theoretically one

1296
00:50:52,800 --> 00:50:54,640
could produce an alternative language

1297
00:50:54,640 --> 00:50:57,280
output there are there are researchers

1298
00:50:57,280 --> 00:51:00,720
who actually produce python output okay

1299
00:51:00,720 --> 00:51:02,880
but we didn't try it out yet no okay

1300
00:51:02,880 --> 00:51:04,480
fair enough thank you

1301
00:51:04,480 --> 00:51:05,760
with that

1302
00:51:05,760 --> 00:51:07,520
lots of questions awesome i think sir

1303
00:51:07,520 --> 00:51:10,000
you were first over here on the right

1304
00:51:10,000 --> 00:51:11,920
and then back and then if we can to you

1305
00:51:11,920 --> 00:51:13,680
sir in the front

1306
00:51:13,680 --> 00:51:15,359
oh hi andrew dwyer from durham

1307
00:51:15,359 --> 00:51:17,599
university in the uk absolutely great

1308
00:51:17,599 --> 00:51:19,920
presentation i'm wondering

1309
00:51:19,920 --> 00:51:21,839
in your user surveys in particular

1310
00:51:21,839 --> 00:51:23,760
whether you're going back to those

1311
00:51:23,760 --> 00:51:26,240
reverse engineers and asking is that

1312
00:51:26,240 --> 00:51:28,160
helpful to them i think that's one of

1313
00:51:28,160 --> 00:51:30,319
the real difficulties is actually

1314
00:51:30,319 --> 00:51:31,920
generating the insight about whether

1315
00:51:31,920 --> 00:51:33,680
it's actually improving their

1316
00:51:33,680 --> 00:51:36,400
capacity to work right and do user

1317
00:51:36,400 --> 00:51:39,040
surveys catch that and because we maybe

1318
00:51:39,040 --> 00:51:40,720
look at doing other types of research to

1319
00:51:40,720 --> 00:51:43,200
look at that

1320
00:51:43,359 --> 00:51:44,960
well the surveys were actually quite

1321
00:51:44,960 --> 00:51:46,960
extensive so we started out by just

1322
00:51:46,960 --> 00:51:49,520
asking analysts and reversals what they

1323
00:51:49,520 --> 00:51:52,319
would like us to improve and then we we

1324
00:51:52,319 --> 00:51:54,160
tried out some some improvements

1325
00:51:54,160 --> 00:51:55,280
implemented them in our research

1326
00:51:55,280 --> 00:51:58,000
decompiler and in the further further

1327
00:51:58,000 --> 00:52:00,800
studies and surveys we actually compared

1328
00:52:00,800 --> 00:52:02,400
them with

1329
00:52:02,400 --> 00:52:04,160
the commercial open source state of the

1330
00:52:04,160 --> 00:52:07,440
art so where in the first survey we only

1331
00:52:07,440 --> 00:52:10,240
ask what they want and the second we

1332
00:52:10,240 --> 00:52:11,839
tried if they are helpful in the context

1333
00:52:11,839 --> 00:52:13,680
of malware analysis

1334
00:52:13,680 --> 00:52:15,599
so we gave them a

1335
00:52:15,599 --> 00:52:17,760
a very short dga function and had him

1336
00:52:17,760 --> 00:52:19,839
analyze it and then again in the third

1337
00:52:19,839 --> 00:52:22,480
survey we compared it actually to mgdra

1338
00:52:22,480 --> 00:52:26,400
and hex rays to um to see how our output

1339
00:52:26,400 --> 00:52:27,760
has

1340
00:52:27,760 --> 00:52:29,680
real advantage advantages over the other

1341
00:52:29,680 --> 00:52:30,559
ones

1342
00:52:30,559 --> 00:52:32,400
so yeah if you're interested in those

1343
00:52:32,400 --> 00:52:36,160
details then go check out the paper

1344
00:52:36,400 --> 00:52:39,760
in the back yes sir

1345
00:52:40,559 --> 00:52:42,160
um hello peter spikins from the

1346
00:52:42,160 --> 00:52:44,160
university of latvia

1347
00:52:44,160 --> 00:52:47,280
my question is about the application of

1348
00:52:47,280 --> 00:52:48,400
this

1349
00:52:48,400 --> 00:52:50,640
like the compilers are used mostly to

1350
00:52:50,640 --> 00:52:53,280
understand what the function does not

1351
00:52:53,280 --> 00:52:55,040
necessarily to get the actual source

1352
00:52:55,040 --> 00:52:57,040
code and given the context of the

1353
00:52:57,040 --> 00:52:58,480
previous talk

1354
00:52:58,480 --> 00:53:00,880
like i would assume that most of the

1355
00:53:00,880 --> 00:53:03,280
functions have already been analyzed by

1356
00:53:03,280 --> 00:53:05,200
someone else because they were

1357
00:53:05,200 --> 00:53:07,359
represented in previous malware so have

1358
00:53:07,359 --> 00:53:08,079
you

1359
00:53:08,079 --> 00:53:11,839
what's your opinion on applicability of

1360
00:53:11,839 --> 00:53:15,200
getting historical data from other power

1361
00:53:15,200 --> 00:53:16,800
analysis

1362
00:53:16,800 --> 00:53:18,960
yes that's a good good question so the

1363
00:53:18,960 --> 00:53:20,960
thing is

1364
00:53:20,960 --> 00:53:22,880
automated approaches

1365
00:53:22,880 --> 00:53:24,800
can in my opinion automatic approaches

1366
00:53:24,800 --> 00:53:26,400
can only

1367
00:53:26,400 --> 00:53:28,960
help analysis to a certain to a certain

1368
00:53:28,960 --> 00:53:31,200
point during the analysis phase so as

1369
00:53:31,200 --> 00:53:33,440
you said many things have already been

1370
00:53:33,440 --> 00:53:35,680
analyzed so it's important to identify

1371
00:53:35,680 --> 00:53:37,920
them and to save valuable time but

1372
00:53:37,920 --> 00:53:40,319
eventually you will end up with

1373
00:53:40,319 --> 00:53:42,400
with cases where you have to analyze

1374
00:53:42,400 --> 00:53:44,640
and get a deep understanding of a given

1375
00:53:44,640 --> 00:53:46,720
binary and of a given function using a

1376
00:53:46,720 --> 00:53:49,040
decompiler so for example if you have a

1377
00:53:49,040 --> 00:53:51,760
new variant of ransomware

1378
00:53:51,760 --> 00:53:55,280
you eventually have to analyze some

1379
00:53:55,280 --> 00:53:57,599
custom crypto routines that haven't been

1380
00:53:57,599 --> 00:54:00,160
implemented haven't been analyzed before

1381
00:54:00,160 --> 00:54:02,720
so i think there is still a big need for

1382
00:54:02,720 --> 00:54:05,520
decompilation

1383
00:54:05,839 --> 00:54:06,960
thank you very much one more round of

1384
00:54:06,960 --> 00:54:08,960
applause we'll get back to you if we can

1385
00:54:08,960 --> 00:54:10,880
uh at the end one more round of applause

1386
00:54:10,880 --> 00:54:13,040
please

1387
00:54:13,040 --> 00:54:14,720
thank you much

1388
00:54:14,720 --> 00:54:16,480
so so we have just under five minutes

1389
00:54:16,480 --> 00:54:18,000
left i'd like to open the floor for

1390
00:54:18,000 --> 00:54:19,119
general questions to any of the

1391
00:54:19,119 --> 00:54:22,839
panelists uh as seen fit so

1392
00:54:22,839 --> 00:54:27,119
anybody yes sir one more time

1393
00:54:30,640 --> 00:54:32,800
i was also quite interested about the

1394
00:54:32,800 --> 00:54:34,880
two previous presentation

1395
00:54:34,880 --> 00:54:37,040
i'm kind of gray hair and i have been in

1396
00:54:37,040 --> 00:54:39,520
the business for something like

1397
00:54:39,520 --> 00:54:41,920
30 years now

1398
00:54:41,920 --> 00:54:44,000
once upon a time i remember the time

1399
00:54:44,000 --> 00:54:46,079
there were

1400
00:54:46,079 --> 00:54:48,559
disassemblers were forbidden

1401
00:54:48,559 --> 00:54:50,799
mainly because they were used by

1402
00:54:50,799 --> 00:54:53,200
four people for reproducing software or

1403
00:54:53,200 --> 00:54:54,160
for

1404
00:54:54,160 --> 00:54:56,079
you know copying

1405
00:54:56,079 --> 00:54:58,720
trade secret or something like that

1406
00:54:58,720 --> 00:55:01,599
meaning that the tools uh both

1407
00:55:01,599 --> 00:55:04,319
the static analyzer the static malware

1408
00:55:04,319 --> 00:55:05,440
analyzer

1409
00:55:05,440 --> 00:55:06,559
and

1410
00:55:06,559 --> 00:55:07,760
also

1411
00:55:07,760 --> 00:55:09,359
the disassembler

1412
00:55:09,359 --> 00:55:12,160
or kind of dual usage tools

1413
00:55:12,160 --> 00:55:15,440
that are helpful for the attacker

1414
00:55:15,440 --> 00:55:16,160
and

1415
00:55:16,160 --> 00:55:18,319
eventually even more helpful for the

1416
00:55:18,319 --> 00:55:20,960
attacker than for the defender because

1417
00:55:20,960 --> 00:55:23,040
the attacker have to look at one

1418
00:55:23,040 --> 00:55:25,839
specific piece of thing where the

1419
00:55:25,839 --> 00:55:29,040
defender have to look at the large scale

1420
00:55:29,040 --> 00:55:30,000
so

1421
00:55:30,000 --> 00:55:32,400
are we not going to help

1422
00:55:32,400 --> 00:55:35,040
the attacker to become more efficient

1423
00:55:35,040 --> 00:55:36,079
that's a great question i'm going to

1424
00:55:36,079 --> 00:55:37,599
start with you philip i think that falls

1425
00:55:37,599 --> 00:55:39,040
in you a little bit

1426
00:55:39,040 --> 00:55:41,200
um

1427
00:55:41,200 --> 00:55:42,240
like

1428
00:55:42,240 --> 00:55:45,040
for everything everything has a dual

1429
00:55:45,040 --> 00:55:46,839
purpose so

1430
00:55:46,839 --> 00:55:48,480
um

1431
00:55:48,480 --> 00:55:50,079
i don't know uh

1432
00:55:50,079 --> 00:55:51,680
what to say uh

1433
00:55:51,680 --> 00:55:54,720
it it's it's true that uh attacker has a

1434
00:55:54,720 --> 00:55:56,400
um

1435
00:55:56,400 --> 00:55:59,280
to be successful they only have to uh

1436
00:55:59,280 --> 00:56:01,359
identify one

1437
00:56:01,359 --> 00:56:02,880
one weak point

1438
00:56:02,880 --> 00:56:05,119
one vulnerability to exploit whereas

1439
00:56:05,119 --> 00:56:07,520
defender they have to secure the whole

1440
00:56:07,520 --> 00:56:09,520
perimeter so

1441
00:56:09,520 --> 00:56:12,319
attackers will always have the advantage

1442
00:56:12,319 --> 00:56:14,880
and attackers are more willing to share

1443
00:56:14,880 --> 00:56:17,280
information about them whereas

1444
00:56:17,280 --> 00:56:21,760
we are like like protecting our uh

1445
00:56:21,760 --> 00:56:23,440
know-how and

1446
00:56:23,440 --> 00:56:27,119
secrets so uh yeah so it's uh we are at

1447
00:56:27,119 --> 00:56:29,520
the disadvantage stefan do you think you

1448
00:56:29,520 --> 00:56:32,319
have an input on that um yes so

1449
00:56:32,319 --> 00:56:34,400
i think it's a good question because it

1450
00:56:34,400 --> 00:56:37,200
basically applies to many research

1451
00:56:37,200 --> 00:56:40,000
fields you always can say that the

1452
00:56:40,000 --> 00:56:42,319
research that there is results can be

1453
00:56:42,319 --> 00:56:45,119
used for the good or the bad but in my

1454
00:56:45,119 --> 00:56:48,000
opinion even though attackers only need

1455
00:56:48,000 --> 00:56:50,319
one specific attack vector

1456
00:56:50,319 --> 00:56:51,920
we still

1457
00:56:51,920 --> 00:56:55,520
help the good side the better and more

1458
00:56:55,520 --> 00:56:57,599
by improving those tools

1459
00:56:57,599 --> 00:57:00,079
so i think after all we should still be

1460
00:57:00,079 --> 00:57:03,280
focusing on improving analysis and

1461
00:57:03,280 --> 00:57:05,599
the anti-attacker side i'm going to go

1462
00:57:05,599 --> 00:57:07,040
ahead and stop here and i'm going to

1463
00:57:07,040 --> 00:57:08,960
give you an opportunity to please talk

1464
00:57:08,960 --> 00:57:10,240
to the speaker so one more round of

1465
00:57:10,240 --> 00:57:14,919
applause to everybody thank you so much

