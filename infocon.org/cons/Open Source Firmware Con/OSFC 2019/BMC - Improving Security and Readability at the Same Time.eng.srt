1
00:00:03,190 --> 00:00:06,259
[Music]

2
00:00:07,010 --> 00:00:09,750
so our next speaker is Verdun Maori from

3
00:00:09,750 --> 00:00:12,420
Intel he is a software engineer that

4
00:00:12,420 --> 00:00:15,269
works on embedded firmware and BMC's and

5
00:00:15,269 --> 00:00:17,430
he's also one of the maintainer zuv IPMI

6
00:00:17,430 --> 00:00:19,890
and Opeth emc so he'll be discussing how

7
00:00:19,890 --> 00:00:21,920
to improve security and reliability

8
00:00:21,920 --> 00:00:26,640
readability at the same time so I signed

9
00:00:26,640 --> 00:00:29,250
up a couple of years back to be the

10
00:00:29,250 --> 00:00:32,070
captain of the sinking ship I it was it

11
00:00:32,070 --> 00:00:33,210
was an intentional thing I've been

12
00:00:33,210 --> 00:00:37,980
working with IPMI since I was with IBM

13
00:00:37,980 --> 00:00:42,540
in the early 2000s so should I stand

14
00:00:42,540 --> 00:00:45,629
closer to the mic okay

15
00:00:45,629 --> 00:00:51,079
and so I've I've learned a lot of the

16
00:00:51,079 --> 00:00:53,550
the troubles that I had that it's had

17
00:00:53,550 --> 00:00:57,180
and so hearing that everybody Bagon ipmi

18
00:00:57,180 --> 00:00:59,609
it does make me a little bit happy

19
00:00:59,609 --> 00:01:02,879
because I am ready for it to to see the

20
00:01:02,879 --> 00:01:06,150
end of its life but I don't want open

21
00:01:06,150 --> 00:01:17,430
BMC to end up with a steaming demon well

22
00:01:17,430 --> 00:01:21,030
i PMI the IPM ID that open BMC has it

23
00:01:21,030 --> 00:01:23,369
originated as a proof of concept so it

24
00:01:23,369 --> 00:01:25,920
wasn't really intended to be a long-term

25
00:01:25,920 --> 00:01:28,710
solution but when everybody jumped on

26
00:01:28,710 --> 00:01:32,869
the ship it was the de facto demon and

27
00:01:32,869 --> 00:01:36,689
so I I took it upon myself as like this

28
00:01:36,689 --> 00:01:38,640
is this is something that really needs

29
00:01:38,640 --> 00:01:41,579
to change because we've got security

30
00:01:41,579 --> 00:01:44,490
issues and not armed CP problems but

31
00:01:44,490 --> 00:01:46,290
these are these are people problems

32
00:01:46,290 --> 00:01:50,280
these are coders writing code that is

33
00:01:50,280 --> 00:01:54,540
not secure and part of it is because the

34
00:01:54,540 --> 00:01:58,229
api's that IBM ID presented them with to

35
00:01:58,229 --> 00:02:01,829
write the code for the handlers had a

36
00:02:01,829 --> 00:02:02,509
hard time

37
00:02:02,509 --> 00:02:09,470
so basically parsing inputs is hard and

38
00:02:09,470 --> 00:02:12,330
as humans we we tend to make the same

39
00:02:12,330 --> 00:02:14,600
mistakes every time

40
00:02:14,600 --> 00:02:22,830
so you know you've got you've got to

41
00:02:22,830 --> 00:02:24,180
figure out how many bites you want what

42
00:02:24,180 --> 00:02:27,840
order they're in and you know IPMI has a

43
00:02:27,840 --> 00:02:33,900
lot of packing of bits into like a bunch

44
00:02:33,900 --> 00:02:35,940
of little bits into single bites and

45
00:02:35,940 --> 00:02:37,590
sometimes they even span across multiple

46
00:02:37,590 --> 00:02:43,350
bites and then the API is that

47
00:02:43,350 --> 00:02:45,540
historically have been presented are

48
00:02:45,540 --> 00:02:49,080
things like void pointers and if you're

49
00:02:49,080 --> 00:02:50,940
lucky you also get a length to tell you

50
00:02:50,940 --> 00:02:55,940
how many bytes you have so in short

51
00:02:55,940 --> 00:02:58,050
we're just setting ourselves up for

52
00:02:58,050 --> 00:03:03,300
failure and the the de facto IPM idea

53
00:03:03,300 --> 00:03:06,020
that open BMC had was not the only one

54
00:03:06,020 --> 00:03:08,310
every IP my stack that I've seen up to

55
00:03:08,310 --> 00:03:08,910
this point

56
00:03:08,910 --> 00:03:11,580
was that same sort of thing where you're

57
00:03:11,580 --> 00:03:15,510
your handler would get a void pointer or

58
00:03:15,510 --> 00:03:20,280
a you end a pointer and you would take a

59
00:03:20,280 --> 00:03:22,680
struct and you would cast the pointer to

60
00:03:22,680 --> 00:03:24,600
a struct pointer and then you would

61
00:03:24,600 --> 00:03:26,910
interpret it as if it was a safe thing

62
00:03:26,910 --> 00:03:35,790
to to touch and well computers are great

63
00:03:35,790 --> 00:03:38,880
at counting humans are pretty bad at it

64
00:03:38,880 --> 00:03:41,340
turns out I mean we're pretty good up to

65
00:03:41,340 --> 00:03:46,340
ten 1,024 if you use that binary system

66
00:03:46,340 --> 00:03:50,640
but on the whole you know we create this

67
00:03:50,640 --> 00:03:52,860
struct and we forget that oh there's a

68
00:03:52,860 --> 00:03:54,840
reserved byte in there that should be

69
00:03:54,840 --> 00:03:57,209
there or we forget to say it's a packed

70
00:03:57,209 --> 00:04:00,480
struck so that the padding isn't quite

71
00:04:00,480 --> 00:04:02,459
right because the compiler thinks it

72
00:04:02,459 --> 00:04:04,290
knows better than you do because let's

73
00:04:04,290 --> 00:04:08,060
face it it does so there are a lot of

74
00:04:08,060 --> 00:04:15,930
issues like that also you know you've

75
00:04:15,930 --> 00:04:18,329
got depending on what architecture

76
00:04:18,329 --> 00:04:19,500
you're on you've got little or

77
00:04:19,500 --> 00:04:22,470
big-endian or you know if you if you've

78
00:04:22,470 --> 00:04:25,979
got pointers to integers then that

79
00:04:25,979 --> 00:04:27,240
integer might

80
00:04:27,240 --> 00:04:28,620
be a different size or if you cast a

81
00:04:28,620 --> 00:04:30,270
pointer to an integer because you're a

82
00:04:30,270 --> 00:04:34,139
bad person then you also have other

83
00:04:34,139 --> 00:04:35,759
problems like they might not be the same

84
00:04:35,759 --> 00:04:39,330
size so you lose data or or talk to

85
00:04:39,330 --> 00:04:43,849
memory that isn't really yours and

86
00:04:43,849 --> 00:04:48,870
sometimes processors well I don't know

87
00:04:48,870 --> 00:04:51,539
the ARM processors they can be told to

88
00:04:51,539 --> 00:04:54,930
like be hard about that whole alignment

89
00:04:54,930 --> 00:04:59,430
issue and then you'll get a bus error if

90
00:04:59,430 --> 00:05:04,620
you do it unaligned multibyte access and

91
00:05:04,620 --> 00:05:07,889
then it goes into the org if it if it's

92
00:05:07,889 --> 00:05:09,210
in the emulation mode then it does a

93
00:05:09,210 --> 00:05:14,419
kernel trap and so you lose a lot of

94
00:05:15,470 --> 00:05:18,270
like your you're losing your throughput

95
00:05:18,270 --> 00:05:20,840
there and it's just not it's not great

96
00:05:20,840 --> 00:05:26,430
so I found a couple of interesting code

97
00:05:26,430 --> 00:05:32,550
snippets from our ipmi stack that some

98
00:05:32,550 --> 00:05:34,650
of them are still there some are have

99
00:05:34,650 --> 00:05:36,479
been removed and replaced with better

100
00:05:36,479 --> 00:05:38,460
code sense but this was part of the

101
00:05:38,460 --> 00:05:43,638
motivation I mean if you look at this

102
00:05:43,940 --> 00:05:47,159
stress aren't necessarily well if you

103
00:05:47,159 --> 00:05:48,570
create a struct on the stack the

104
00:05:48,570 --> 00:05:50,729
compiler will do its best to make sure

105
00:05:50,729 --> 00:05:53,389
it's aligned and stuff so that when you

106
00:05:53,389 --> 00:05:56,340
mess with it the you know the multibyte

107
00:05:56,340 --> 00:06:00,630
stuff will all be nice but in the ipmi

108
00:06:00,630 --> 00:06:02,699
handlers you're not getting something

109
00:06:02,699 --> 00:06:06,539
that's on the stack in legacy code it

110
00:06:06,539 --> 00:06:12,120
was just a buffer and then you would get

111
00:06:12,120 --> 00:06:14,969
passed a pointer to that buffer now if

112
00:06:14,969 --> 00:06:17,849
the buffer was allocated correctly then

113
00:06:17,849 --> 00:06:20,729
it should be aligned but really as the

114
00:06:20,729 --> 00:06:24,440
handler you you had no guarantees so

115
00:06:24,440 --> 00:06:26,550
taking something like this where you

116
00:06:26,550 --> 00:06:32,610
just do a cast and then immediately read

117
00:06:32,610 --> 00:06:37,680
a member that that could be a dangerous

118
00:06:37,680 --> 00:06:40,740
thing also

119
00:06:40,740 --> 00:06:43,470
in in this particular case we have a

120
00:06:43,470 --> 00:06:47,390
buffer with no length so that's fun

121
00:06:47,390 --> 00:06:50,430
we have no I know guarantees on how long

122
00:06:50,430 --> 00:07:01,080
that buffer really was another thing is

123
00:07:01,080 --> 00:07:03,240
as you're reading bits and bytes off

124
00:07:03,240 --> 00:07:07,200
this stream you have to know what order

125
00:07:07,200 --> 00:07:10,050
that stream was in versus what order

126
00:07:10,050 --> 00:07:12,900
your processors running in this is

127
00:07:12,900 --> 00:07:15,270
something I haven't tried yet but I know

128
00:07:15,270 --> 00:07:19,170
a lot of the ARM chips can bat both ways

129
00:07:19,170 --> 00:07:19,860
right

130
00:07:19,860 --> 00:07:21,510
they can be big ant big or little-endian

131
00:07:21,510 --> 00:07:25,770
and by default we run little endian

132
00:07:25,770 --> 00:07:27,780
because i guess that's what intel chose

133
00:07:27,780 --> 00:07:32,119
or something I don't really understand

134
00:07:33,290 --> 00:07:37,020
but the ipmi spec is mostly

135
00:07:37,020 --> 00:07:40,650
little-endian so if you were just

136
00:07:40,650 --> 00:07:42,450
writing code and you weren't considering

137
00:07:42,450 --> 00:07:44,870
what happened if your BMC was suddenly a

138
00:07:44,870 --> 00:07:49,200
RISC processor or something that might

139
00:07:49,200 --> 00:07:52,560
be a big endian processor than the code

140
00:07:52,560 --> 00:07:55,650
that you wrote naively wouldn't run

141
00:07:55,650 --> 00:07:57,030
because you're pulling off these

142
00:07:57,030 --> 00:07:58,860
multibyte things in your struct and

143
00:07:58,860 --> 00:08:01,410
forgetting to do a a network to hoster

144
00:08:01,410 --> 00:08:04,620
for that kind of stuff

145
00:08:04,620 --> 00:08:08,670
in addition bit fields for whatever

146
00:08:08,670 --> 00:08:13,050
reason swap order as well so here's a

147
00:08:13,050 --> 00:08:14,280
great example of that

148
00:08:14,280 --> 00:08:16,140
this is pretty common in ipmi like I

149
00:08:16,140 --> 00:08:18,780
said it was you know I came I started

150
00:08:18,780 --> 00:08:22,940
back before a lot of us were born and

151
00:08:22,940 --> 00:08:26,220
when space was important and so they

152
00:08:26,220 --> 00:08:28,410
would pack as many bits into the

153
00:08:28,410 --> 00:08:30,480
smallest space as they could which gives

154
00:08:30,480 --> 00:08:36,539
you bit fields and and then then you end

155
00:08:36,539 --> 00:08:39,140
up with code like this if you're unlucky

156
00:08:39,140 --> 00:08:42,870
so here they actually did do a request

157
00:08:42,870 --> 00:08:48,420
or length check but they still did that

158
00:08:48,420 --> 00:08:52,530
great static cast and because it's a bit

159
00:08:52,530 --> 00:08:53,750
field

160
00:08:53,750 --> 00:08:55,580
there should also be that there should

161
00:08:55,580 --> 00:08:58,520
be the you know if big andean elsif

162
00:08:58,520 --> 00:09:00,920
little endian so that you can switch

163
00:09:00,920 --> 00:09:03,680
those bits around and that I mean in

164
00:09:03,680 --> 00:09:05,540
addition to just looking great in your

165
00:09:05,540 --> 00:09:11,210
code it half the time it gets coded up

166
00:09:11,210 --> 00:09:14,180
wrong anyway because we forget which

167
00:09:14,180 --> 00:09:19,150
order the bits go on Indian order so

168
00:09:19,150 --> 00:09:24,440
this is just you know another example of

169
00:09:24,440 --> 00:09:26,510
the many ways that we can go wrong in

170
00:09:26,510 --> 00:09:35,660
code so is the code sanitary if you have

171
00:09:35,660 --> 00:09:39,880
to ask that question it's probably not

172
00:09:39,970 --> 00:09:43,880
so here's a bunch of things we can look

173
00:09:43,880 --> 00:09:48,350
out for but ultimately we're gonna miss

174
00:09:48,350 --> 00:09:50,690
one probably so it's it's better to just

175
00:09:50,690 --> 00:09:53,480
come up with a framework that just

176
00:09:53,480 --> 00:09:56,240
doesn't have these right if you're not

177
00:09:56,240 --> 00:09:58,520
ever passing around a pointer to a

178
00:09:58,520 --> 00:10:00,050
buffer you don't ever have to worry

179
00:10:00,050 --> 00:10:02,000
about that buffer getting overflowed

180
00:10:02,000 --> 00:10:09,110
right so I'm not saying that pointers

181
00:10:09,110 --> 00:10:11,650
are necessarily bad but they definitely

182
00:10:11,650 --> 00:10:19,550
invite abuse so oh one last pour code

183
00:10:19,550 --> 00:10:25,640
exhibit so void pointers don't offer

184
00:10:25,640 --> 00:10:31,250
sighs just an address and this in/out

185
00:10:31,250 --> 00:10:33,560
pointer is just asking for trouble so

186
00:10:33,560 --> 00:10:36,920
you the data length pointer you get it

187
00:10:36,920 --> 00:10:40,100
as a length of how many bytes you

188
00:10:40,100 --> 00:10:43,550
received and buffer but it also you're

189
00:10:43,550 --> 00:10:47,000
supposed to write how many bytes you're

190
00:10:47,000 --> 00:10:55,120
you're returning in the other buffer and

191
00:10:55,240 --> 00:10:59,680
this is this is part of the the legacy

192
00:10:59,680 --> 00:11:06,080
API for ipm ID so every every function

193
00:11:06,080 --> 00:11:07,460
has the same

194
00:11:07,460 --> 00:11:13,010
sort of look and feel so good security

195
00:11:13,010 --> 00:11:16,430
is is up to the user who's coding it up

196
00:11:16,430 --> 00:11:19,730
but when you're writing the API you can

197
00:11:19,730 --> 00:11:22,730
write api's that discourage these poor

198
00:11:22,730 --> 00:11:27,529
practices so I'm not sure if we even

199
00:11:27,529 --> 00:11:29,149
really need this slide at this point

200
00:11:29,149 --> 00:11:31,520
it's pretty obvious that the code was

201
00:11:31,520 --> 00:11:37,490
meant for an overhaul so the the goals

202
00:11:37,490 --> 00:11:40,520
for this I really wanted to come up with

203
00:11:40,520 --> 00:11:44,450
a way that made the the compiler do the

204
00:11:44,450 --> 00:11:47,630
heavy lifting like I said people tend to

205
00:11:47,630 --> 00:11:50,360
make the same mistakes you look at a

206
00:11:50,360 --> 00:11:51,920
function and say okay yeah this is the

207
00:11:51,920 --> 00:11:54,500
sort of thing I want to do copy paste

208
00:11:54,500 --> 00:11:59,240
modify compile oh yeah works forgetting

209
00:11:59,240 --> 00:12:02,240
that every error you had in the original

210
00:12:02,240 --> 00:12:04,810
code is now in your code as well and

211
00:12:04,810 --> 00:12:07,370
when that one gets fixed yours might not

212
00:12:07,370 --> 00:12:13,790
so leveraging the compiler which is more

213
00:12:13,790 --> 00:12:16,130
likely to to be writing good code than

214
00:12:16,130 --> 00:12:20,720
you is important I wanted to focus on

215
00:12:20,720 --> 00:12:23,120
the the parsing of the the packets

216
00:12:23,120 --> 00:12:26,150
because having these package structs and

217
00:12:26,150 --> 00:12:29,360
stuff was just a mess we would end up

218
00:12:29,360 --> 00:12:31,220
with all sorts of weird padding errors

219
00:12:31,220 --> 00:12:37,640
and and the pointers oh the pointers so

220
00:12:37,640 --> 00:12:40,880
I thought okay I looked at SD bus plus

221
00:12:40,880 --> 00:12:43,870
and they were doing a lot of this

222
00:12:43,870 --> 00:12:46,850
packing unpacking based on the type of

223
00:12:46,850 --> 00:12:50,839
the the tuple that it had and I thought

224
00:12:50,839 --> 00:12:52,190
okay we should be able to do this with

225
00:12:52,190 --> 00:12:56,930
item ID as well I did realize as I was

226
00:12:56,930 --> 00:12:58,279
implementing it there were some

227
00:12:58,279 --> 00:13:00,170
differences when I pee when an SD buzz

228
00:13:00,170 --> 00:13:02,690
plus was doing it they have a message

229
00:13:02,690 --> 00:13:05,329
that has encoded in the message the data

230
00:13:05,329 --> 00:13:06,950
types so that they could take that

231
00:13:06,950 --> 00:13:09,529
unpack to those data types look at the

232
00:13:09,529 --> 00:13:11,480
function see what data types it was

233
00:13:11,480 --> 00:13:13,459
looking for and try and match them up

234
00:13:13,459 --> 00:13:15,520
and throw some error if it didn't match

235
00:13:15,520 --> 00:13:19,100
with IPMI unfortunately if the data is

236
00:13:19,100 --> 00:13:21,279
not encoded into the mess

237
00:13:21,279 --> 00:13:25,790
so I did have to rely on the function

238
00:13:25,790 --> 00:13:28,010
arguments to do some sort of data

239
00:13:28,010 --> 00:13:29,779
checking and and really the best we can

240
00:13:29,779 --> 00:13:32,420
do at that point is make sure that the

241
00:13:32,420 --> 00:13:38,740
sizes match up so the api's hopefully

242
00:13:38,740 --> 00:13:44,089
would be easy to use I I think that when

243
00:13:44,089 --> 00:13:45,620
you're writing a library or an interface

244
00:13:45,620 --> 00:13:51,890
like this it's important to make it easy

245
00:13:51,890 --> 00:13:55,570
to use correctly and hard to abuse and

246
00:13:55,570 --> 00:13:58,790
that sometimes means that the internals

247
00:13:58,790 --> 00:14:04,490
of the library are complex but it should

248
00:14:04,490 --> 00:14:09,980
be pretty straightforward to use IPMI

249
00:14:09,980 --> 00:14:12,079
does have some functions that are

250
00:14:12,079 --> 00:14:14,450
variable length most of them are fixed

251
00:14:14,450 --> 00:14:17,180
length but it didn't need to have a way

252
00:14:17,180 --> 00:14:20,560
to handle variable length especially

253
00:14:20,560 --> 00:14:24,500
ones where you know it's a fixed length

254
00:14:24,500 --> 00:14:26,449
here but then the the payload beyond

255
00:14:26,449 --> 00:14:29,149
that depends on the contents of those

256
00:14:29,149 --> 00:14:32,630
fixed bytes so like a sub command sort

257
00:14:32,630 --> 00:14:34,610
of thing or something like that so we

258
00:14:34,610 --> 00:14:37,730
needed to be able to handle that as kind

259
00:14:37,730 --> 00:14:40,190
of a special case but still make it safe

260
00:14:40,190 --> 00:14:42,260
to do that right I still didn't want to

261
00:14:42,260 --> 00:14:44,899
say oh you get a bite and then a vector

262
00:14:44,899 --> 00:14:47,660
that's a possibility but hopefully

263
00:14:47,660 --> 00:14:51,010
that's not the way that it's being used

264
00:14:51,210 --> 00:14:54,229
[Music]

265
00:14:54,399 --> 00:15:01,279
yeah okay that does cover this like in

266
00:15:01,279 --> 00:15:04,640
addition to the variable packet length

267
00:15:04,640 --> 00:15:08,380
that sometimes you've you've got these

268
00:15:08,380 --> 00:15:11,630
bit fields and that needed to be handled

269
00:15:11,630 --> 00:15:16,339
as well there aren't really any good bit

270
00:15:16,339 --> 00:15:21,949
types native to native to C C++ does

271
00:15:21,949 --> 00:15:23,329
offer some of those but we weren't

272
00:15:23,329 --> 00:15:27,160
really using any in the old API so

273
00:15:27,160 --> 00:15:29,959
rather than I mean if we were doing just

274
00:15:29,959 --> 00:15:32,209
the the C style stuff then we would

275
00:15:32,209 --> 00:15:33,699
definitely want to shift in

276
00:15:33,699 --> 00:15:36,100
but I don't want to tell the user to do

277
00:15:36,100 --> 00:15:42,459
that because they probably won't so this

278
00:15:42,459 --> 00:15:44,980
is basically what the IP my spec looks

279
00:15:44,980 --> 00:15:47,889
like it's kind of a mess you've got you

280
00:15:47,889 --> 00:15:51,819
know bits and bytes that are mixed up

281
00:15:51,819 --> 00:15:54,639
and you've got you know reserved bytes

282
00:15:54,639 --> 00:15:57,970
scattered throughout it and you know

283
00:15:57,970 --> 00:16:01,329
this one in particular has a variable

284
00:16:01,329 --> 00:16:05,679
payload and it needed to be able to

285
00:16:05,679 --> 00:16:08,199
handle this right this actually wasn't

286
00:16:08,199 --> 00:16:11,439
even the worst one I think William

287
00:16:11,439 --> 00:16:12,759
Brannon did the worst one when he was

288
00:16:12,759 --> 00:16:15,999
trying to do the Landsat parameter

289
00:16:15,999 --> 00:16:23,709
command so this is basically what I came

290
00:16:23,709 --> 00:16:26,739
up with after talking with several

291
00:16:26,739 --> 00:16:28,749
people including the the other ipmi

292
00:16:28,749 --> 00:16:35,589
maintainer z-- we we came up with the

293
00:16:35,589 --> 00:16:37,859
idea of you know you you specify each

294
00:16:37,859 --> 00:16:40,869
parameter as a separate thing right you

295
00:16:40,869 --> 00:16:42,519
say okay well the first parameter I need

296
00:16:42,519 --> 00:16:47,109
is a is a seven bit integer so or or a

297
00:16:47,109 --> 00:16:51,100
boolean a one bit integer and and these

298
00:16:51,100 --> 00:16:54,249
these variable things that you asked for

299
00:16:54,249 --> 00:16:57,009
them individually and then when you've

300
00:16:57,009 --> 00:16:59,410
registered this handler the registration

301
00:16:59,410 --> 00:17:01,809
process would say okay let me inspect

302
00:17:01,809 --> 00:17:03,720
this function it needs these types and

303
00:17:03,720 --> 00:17:07,209
then it you know it would extract though

304
00:17:07,209 --> 00:17:09,669
it would know how to extract those from

305
00:17:09,669 --> 00:17:12,519
the from the payload when the when the

306
00:17:12,519 --> 00:17:19,260
message was called so this did involve

307
00:17:19,260 --> 00:17:21,970
creating some new data types you'll

308
00:17:21,970 --> 00:17:25,019
notice you went for and you went three

309
00:17:25,019 --> 00:17:30,220
those are not standard C types so I did

310
00:17:30,220 --> 00:17:32,799
some leveraging of the the boost multi

311
00:17:32,799 --> 00:17:36,220
precision library where it lets you

312
00:17:36,220 --> 00:17:38,820
define arbitrary precision integers and

313
00:17:38,820 --> 00:17:40,990
they for the most part they act just

314
00:17:40,990 --> 00:17:43,510
like regular integers they just take up

315
00:17:43,510 --> 00:17:46,419
a little bit more computation but it

316
00:17:46,419 --> 00:17:47,680
allows you to think

317
00:17:47,680 --> 00:17:53,200
in this space where where you're you're

318
00:17:53,200 --> 00:17:55,360
asking for a specific thing and that's

319
00:17:55,360 --> 00:18:04,930
what the parser will give you yeah so

320
00:18:04,930 --> 00:18:06,520
that was what the the first light was

321
00:18:06,520 --> 00:18:08,590
kind of what a new function would look

322
00:18:08,590 --> 00:18:10,900
like when you're registering it and and

323
00:18:10,900 --> 00:18:15,670
this is what the what what happens when

324
00:18:15,670 --> 00:18:18,420
the message is coming in to be executed

325
00:18:18,420 --> 00:18:22,540
this function it takes a request which

326
00:18:22,540 --> 00:18:26,230
is basically metadata plus the data that

327
00:18:26,230 --> 00:18:29,860
was pulled off d-bus so it does get a

328
00:18:29,860 --> 00:18:33,130
big buffer in this case it's a standard

329
00:18:33,130 --> 00:18:35,770
vector which has encoded in it a length

330
00:18:35,770 --> 00:18:42,900
as well as the that the pointer but the

331
00:18:42,900 --> 00:18:46,540
the request then takes the callback

332
00:18:46,540 --> 00:18:49,660
which is part of this class and it it

333
00:18:49,660 --> 00:18:56,260
uses the the boost callable traits which

334
00:18:56,260 --> 00:18:58,570
allows it to at compile time it's doing

335
00:18:58,570 --> 00:19:02,440
this it extracts the parameters of the

336
00:19:02,440 --> 00:19:07,000
function as a tuple and then using very

337
00:19:07,000 --> 00:19:08,590
attic templates we were able to extract

338
00:19:08,590 --> 00:19:12,700
those tuple members one at a time as

339
00:19:12,700 --> 00:19:20,290
part of this so the the unpack call it

340
00:19:20,290 --> 00:19:22,420
looks so simple there we say request

341
00:19:22,420 --> 00:19:24,880
unpack where the the thing that you're

342
00:19:24,880 --> 00:19:27,179
unpacking is actually a tuple of the

343
00:19:27,179 --> 00:19:29,650
parameter types for the function and

344
00:19:29,650 --> 00:19:34,360
that gets expanded kind of recursively

345
00:19:34,360 --> 00:19:39,670
by parameter templates into compiled

346
00:19:39,670 --> 00:19:44,800
functions that extract each one one at a

347
00:19:44,800 --> 00:19:50,890
time and then after it attempts to

348
00:19:50,890 --> 00:19:53,890
extract it it says well the extraction

349
00:19:53,890 --> 00:19:55,630
can fail at any point in time right so

350
00:19:55,630 --> 00:19:59,610
if you tell it I want you to extract a

351
00:19:59,610 --> 00:20:01,500
four-member array

352
00:20:01,500 --> 00:20:11,820
of bite you went 16 pairs then if it has

353
00:20:11,820 --> 00:20:14,310
too many bites or too few bites by the

354
00:20:14,310 --> 00:20:16,050
time it gets to the end of that array

355
00:20:16,050 --> 00:20:20,300
then it'll throw an error and then it'll

356
00:20:20,300 --> 00:20:23,850
respond with the appropriate you know

357
00:20:23,850 --> 00:20:25,650
insufficient bytes or wrong number of

358
00:20:25,650 --> 00:20:29,730
bytes message if it happens to unpack

359
00:20:29,730 --> 00:20:33,330
successfully then it has this tuple and

360
00:20:33,330 --> 00:20:35,910
then standard apply will basically call

361
00:20:35,910 --> 00:20:40,050
a funk tour with a set of parameters so

362
00:20:40,050 --> 00:20:42,570
that from the functions perspective it

363
00:20:42,570 --> 00:20:43,980
was just called as if it had those

364
00:20:43,980 --> 00:20:47,880
parameters passed in so this is a pretty

365
00:20:47,880 --> 00:20:50,430
simplified view there are multiple cases

366
00:20:50,430 --> 00:20:54,900
because because I did want to make it a

367
00:20:54,900 --> 00:20:58,740
lot easier to use but this is the basic

368
00:20:58,740 --> 00:21:01,770
overview of how it happens right the the

369
00:21:01,770 --> 00:21:04,200
function pass gets passed in a bunch of

370
00:21:04,200 --> 00:21:06,000
stuff and then it passes back this kind

371
00:21:06,000 --> 00:21:11,430
of thing called a response which I think

372
00:21:11,430 --> 00:21:14,360
I forgot to talk about

373
00:21:24,940 --> 00:21:28,460
so I did forget to talk about how it

374
00:21:28,460 --> 00:21:31,460
would have responses so when you define

375
00:21:31,460 --> 00:21:34,310
a function handler being able to return

376
00:21:34,310 --> 00:21:37,330
something kind of the same way that you

377
00:21:37,330 --> 00:21:40,610
receive it you get to you get to choose

378
00:21:40,610 --> 00:21:41,780
the shape of the thing that you're

379
00:21:41,780 --> 00:21:46,600
returning with this our response type

380
00:21:46,600 --> 00:21:50,480
declaration where you basically pass in

381
00:21:50,480 --> 00:21:53,300
the the types of a tuple that you want

382
00:21:53,300 --> 00:21:56,450
to return and then you return a tuple

383
00:21:56,450 --> 00:21:59,060
that will then get packed back into a

384
00:21:59,060 --> 00:22:01,670
bit stream that can get sent back to the

385
00:22:01,670 --> 00:22:06,080
to the caller so in this case it's

386
00:22:06,080 --> 00:22:09,140
returning a vector of of bytes which

387
00:22:09,140 --> 00:22:21,050
isn't very interesting but here the

388
00:22:21,050 --> 00:22:23,120
handler you the handler returns that

389
00:22:23,120 --> 00:22:25,310
tuple and then it you know packs in the

390
00:22:25,310 --> 00:22:27,710
the return code and then sends it on its

391
00:22:27,710 --> 00:22:34,310
way so this is where the magic kind of

392
00:22:34,310 --> 00:22:40,960
happens we've got a couple of unpack

393
00:22:40,960 --> 00:22:45,980
things where the when you call unpack

394
00:22:45,980 --> 00:22:47,840
this is what is getting called under the

395
00:22:47,840 --> 00:22:51,710
covers so for each type there's an

396
00:22:51,710 --> 00:22:55,910
overload to this template that gets

397
00:22:55,910 --> 00:22:58,880
called by the compiler so that each type

398
00:22:58,880 --> 00:23:01,130
has a specific set of code that knows

399
00:23:01,130 --> 00:23:03,230
how to unpack that type properly and

400
00:23:03,230 --> 00:23:07,360
this includes multi byte integers and

401
00:23:07,360 --> 00:23:12,050
arrays and vectors and tuples and you

402
00:23:12,050 --> 00:23:14,870
know all of the various types that this

403
00:23:14,870 --> 00:23:18,040
API can handle it it knows how to

404
00:23:18,040 --> 00:23:24,190
properly unpack each one of those and

405
00:23:24,190 --> 00:23:27,530
some of this means that it's kind of

406
00:23:27,530 --> 00:23:29,150
doing a recursive thing like if you

407
00:23:29,150 --> 00:23:32,290
unpack a tuple you actually want to

408
00:23:32,290 --> 00:23:34,760
unpack all the members of the tuple and

409
00:23:34,760 --> 00:23:37,520
if that fails

410
00:23:37,520 --> 00:23:39,290
then the tuple failed unpack and you

411
00:23:39,290 --> 00:23:46,100
returned the response there so some of

412
00:23:46,100 --> 00:23:49,220
these some of these unpack functions are

413
00:23:49,220 --> 00:23:51,430
a little more complex than others

414
00:23:51,430 --> 00:23:55,360
whereas like if you decided to unpack a

415
00:23:55,360 --> 00:23:59,240
single byte it's just a you know advance

416
00:23:59,240 --> 00:24:03,350
the the count in the payload and pop the

417
00:24:03,350 --> 00:24:09,560
next byte but it did offer a way to keep

418
00:24:09,560 --> 00:24:13,310
track of you can you can unpack a single

419
00:24:13,310 --> 00:24:16,490
byte a single bit or various things and

420
00:24:16,490 --> 00:24:19,160
then in case of you know if you're

421
00:24:19,160 --> 00:24:21,470
trying to unpack a byte when you haven't

422
00:24:21,470 --> 00:24:23,990
cleared out the the remaining extra bits

423
00:24:23,990 --> 00:24:26,960
that can throw an error as well so these

424
00:24:26,960 --> 00:24:28,970
alignment issues and stuff can be caught

425
00:24:28,970 --> 00:24:33,200
as well so that's this is all part of

426
00:24:33,200 --> 00:24:37,690
pushing the complexity into the the

427
00:24:37,690 --> 00:24:45,200
library internals so in addition to just

428
00:24:45,200 --> 00:24:49,010
being able to request the various basic

429
00:24:49,010 --> 00:24:52,790
types I wanted to be able to pass in

430
00:24:52,790 --> 00:24:55,880
some of the metadata as well so that's

431
00:24:55,880 --> 00:24:57,710
what this ipmi context thing is it

432
00:24:57,710 --> 00:25:02,300
passes an information like the channel

433
00:25:02,300 --> 00:25:08,980
that it came in on and it passes in a

434
00:25:08,980 --> 00:25:12,950
yield context which allows the handler

435
00:25:12,950 --> 00:25:16,480
to be executed in an asynchronous

436
00:25:16,480 --> 00:25:20,930
yielding API so that we don't end up

437
00:25:20,930 --> 00:25:25,580
with high latency handlers and it passes

438
00:25:25,580 --> 00:25:31,370
in a payload or sorry or you can request

439
00:25:31,370 --> 00:25:33,500
a payload which allows you to manually

440
00:25:33,500 --> 00:25:37,280
make these unpack calls in like the case

441
00:25:37,280 --> 00:25:40,340
of the set land parameter where the

442
00:25:40,340 --> 00:25:42,470
first byte tells you what parameter you

443
00:25:42,470 --> 00:25:44,360
want and that's how you know what types

444
00:25:44,360 --> 00:25:46,970
to unpack in this case you could unpack

445
00:25:46,970 --> 00:25:49,070
the unpack you could request a payload

446
00:25:49,070 --> 00:25:51,290
and then using that payload

447
00:25:51,290 --> 00:25:53,930
you could say okay now I need these

448
00:25:53,930 --> 00:26:01,780
twelve types or whatever so these extra

449
00:26:01,780 --> 00:26:04,970
metadata options are available for

450
00:26:04,970 --> 00:26:07,370
advanced functions that need to do

451
00:26:07,370 --> 00:26:14,390
special things initially when I first

452
00:26:14,390 --> 00:26:16,310
started writing these I think the first

453
00:26:16,310 --> 00:26:19,390
handler took me about 15 minutes to

454
00:26:19,390 --> 00:26:22,370
rewrite and after that it was pretty

455
00:26:22,370 --> 00:26:25,760
easy and I got quite a bit of feedback

456
00:26:25,760 --> 00:26:27,530
from people who were actively rewriting

457
00:26:27,530 --> 00:26:30,650
the handlers and they it was for the

458
00:26:30,650 --> 00:26:32,060
most part positive there were a few

459
00:26:32,060 --> 00:26:35,390
patches that needed to come in to handle

460
00:26:35,390 --> 00:26:38,320
corner cases that I hadn't come up with

461
00:26:38,320 --> 00:26:42,310
but for the most part it was it was

462
00:26:42,310 --> 00:26:45,140
exactly what we wanted it was easy to

463
00:26:45,140 --> 00:26:48,100
use and it provided a very safe

464
00:26:48,100 --> 00:26:50,960
mechanism for parsing these inputs and

465
00:26:50,960 --> 00:26:58,400
creating the outputs so we created this

466
00:26:58,400 --> 00:27:01,870
new API but all of the code was still in

467
00:27:01,870 --> 00:27:04,820
using the legacy handlers so in the

468
00:27:04,820 --> 00:27:10,930
meantime I did create a basically a shim

469
00:27:10,930 --> 00:27:16,850
handler that would just unpack the

470
00:27:16,850 --> 00:27:20,090
entire thing as a vector and send that

471
00:27:20,090 --> 00:27:22,360
out to the handler as a void pointer

472
00:27:22,360 --> 00:27:24,770
unfortunately but it means that all the

473
00:27:24,770 --> 00:27:26,360
old code would still work while we're

474
00:27:26,360 --> 00:27:30,770
trying to rewrite it and because I wrote

475
00:27:30,770 --> 00:27:35,480
it as a separate mechanism that way once

476
00:27:35,480 --> 00:27:38,690
we clear the bar of rewriting all the

477
00:27:38,690 --> 00:27:41,480
handlers then we can just easily pull

478
00:27:41,480 --> 00:27:44,090
that code out and only support this new

479
00:27:44,090 --> 00:27:49,540
API and we are making slow progress but

480
00:27:49,540 --> 00:27:59,960
it is progress indeed and the even some

481
00:27:59,960 --> 00:28:02,410
of them are actually using the async

482
00:28:02,410 --> 00:28:04,540
mechanism as well and

483
00:28:04,540 --> 00:28:06,280
I still have some patches that I'm

484
00:28:06,280 --> 00:28:08,919
working on to make it even easier to use

485
00:28:08,919 --> 00:28:16,630
some of those async things so it like I

486
00:28:16,630 --> 00:28:18,669
was saying it it did create the

487
00:28:18,669 --> 00:28:21,970
environment that I was looking for you

488
00:28:21,970 --> 00:28:25,980
no longer have to rely on people to

489
00:28:26,340 --> 00:28:29,140
write code that is counting every byte

490
00:28:29,140 --> 00:28:32,950
because that part's already done that

491
00:28:32,950 --> 00:28:36,960
part not only was it done but I also

492
00:28:36,960 --> 00:28:44,350
wrote my first unit tests yay and the

493
00:28:44,350 --> 00:28:46,990
unit tests tested the packing and

494
00:28:46,990 --> 00:28:49,990
unpacking of the payload because because

495
00:28:49,990 --> 00:28:52,000
that was the critical portion that I was

496
00:28:52,000 --> 00:28:55,450
trying to to fix I wanted to make sure

497
00:28:55,450 --> 00:28:57,790
that that part was correct so I did

498
00:28:57,790 --> 00:29:00,910
write a bunch of tests you know tests

499
00:29:00,910 --> 00:29:05,370
that get executed when you're building

500
00:29:06,419 --> 00:29:09,549
but now that means when this is all done

501
00:29:09,549 --> 00:29:12,549
we can get rid of you know C C style

502
00:29:12,549 --> 00:29:17,400
casts and void pointers and buffers and

503
00:29:17,400 --> 00:29:19,750
hopefully eventually this will also lead

504
00:29:19,750 --> 00:29:24,190
to an a new era of unit testing where we

505
00:29:24,190 --> 00:29:27,090
can have interfaces well defined and

506
00:29:27,090 --> 00:29:32,410
have small testable functions so that by

507
00:29:32,410 --> 00:29:34,450
the time ipmi dies we will have

508
00:29:34,450 --> 00:29:36,970
something that is way more beautiful

509
00:29:36,970 --> 00:29:43,890
than it currently is and I apparently

510
00:29:43,890 --> 00:29:47,500
talked way faster than I was supposed to

511
00:29:47,500 --> 00:29:50,350
or something I don't know are there any

512
00:29:50,350 --> 00:29:52,500
questions I think that's the end of my

513
00:29:52,500 --> 00:30:06,760
discussion here there is a little bit

514
00:30:06,760 --> 00:30:13,440
more code generated but it's all correct

515
00:30:13,880 --> 00:30:20,430
so it was a the code size of IBM ID did

516
00:30:20,430 --> 00:30:30,570
increase everybody saw it but I I am of

517
00:30:30,570 --> 00:30:31,920
the opinion that it was worth it right

518
00:30:31,920 --> 00:30:34,050
processors aren't only getting more

519
00:30:34,050 --> 00:30:53,280
powerful right right but that is another

520
00:30:53,280 --> 00:30:56,520
option from from a co maintainer see

521
00:30:56,520 --> 00:30:58,670
we're all rooting for the same thing

522
00:30:58,670 --> 00:31:05,910
redfish is a great alternative it's not

523
00:31:05,910 --> 00:31:08,730
but it is at least over a safe transport

524
00:31:08,730 --> 00:31:16,140
I mean any any security and coding

525
00:31:16,140 --> 00:31:18,420
mechanism that does this is going to add

526
00:31:18,420 --> 00:31:24,420
some overhead and yes if you hand coded

527
00:31:24,420 --> 00:31:28,020
perfectly every one of your handlers you

528
00:31:28,020 --> 00:31:30,320
would probably end up with less code a

529
00:31:30,320 --> 00:31:35,010
smaller compiled code you would you

530
00:31:35,010 --> 00:31:38,790
would also be you might win a Nobel

531
00:31:38,790 --> 00:31:50,370
Peace Prize I if I understand this

532
00:31:50,370 --> 00:31:52,380
correctly does this mean that we are

533
00:31:52,380 --> 00:31:54,210
moving the specification of them

534
00:31:54,210 --> 00:31:58,950
requests and responses from PAC structs

535
00:31:58,950 --> 00:32:03,690
into function parameters yes so the idea

536
00:32:03,690 --> 00:32:05,910
is the function parameter looks a lot

537
00:32:05,910 --> 00:32:10,110
like the API specification where you

538
00:32:10,110 --> 00:32:13,020
have seven fields in and two fields out

539
00:32:13,020 --> 00:32:17,130
and that's what your function does oh do

540
00:32:17,130 --> 00:32:18,600
you have any place where there's an

541
00:32:18,600 --> 00:32:21,030
example of how you potentially handle

542
00:32:21,030 --> 00:32:25,950
cases where the first byte says this

543
00:32:25,950 --> 00:32:27,480
message and then and

544
00:32:27,480 --> 00:32:29,610
I mean it essentially describes how

545
00:32:29,610 --> 00:32:31,110
we're going to interpret the remaining

546
00:32:31,110 --> 00:32:32,010
parts of the bytes

547
00:32:32,010 --> 00:32:34,470
like I mentioned optional sister yeah

548
00:32:34,470 --> 00:32:36,450
there there's a code review it hasn't

549
00:32:36,450 --> 00:32:42,240
been merged yet but William had a code

550
00:32:42,240 --> 00:32:45,560
review for the assent land parameter

551
00:32:45,560 --> 00:32:48,860
which like I said is the first byte

552
00:32:48,860 --> 00:32:53,130
tells the size or the the type of the

553
00:32:53,130 --> 00:32:56,250
message and then in a giant switch

554
00:32:56,250 --> 00:32:58,590
statement that says okay we need these

555
00:32:58,590 --> 00:33:00,510
types unpack it here we need these types

556
00:33:00,510 --> 00:33:03,150
on packet here and really what happens

557
00:33:03,150 --> 00:33:06,330
is you're using that same payload object

558
00:33:06,330 --> 00:33:09,990
and you're just calling unpack with the

559
00:33:09,990 --> 00:33:13,020
five types that you need instead of just

560
00:33:13,020 --> 00:33:15,030
receiving them as function parameters

561
00:33:15,030 --> 00:33:19,770
you just you you instantiate those five

562
00:33:19,770 --> 00:33:22,950
things on the stack and then call unpack

563
00:33:22,950 --> 00:33:38,160
referencing them depends on if you're

564
00:33:38,160 --> 00:33:40,740
doing om commands the way the IP my spec

565
00:33:40,740 --> 00:33:43,770
does it were the the cheater hands way

566
00:33:43,770 --> 00:33:47,670
so if you cheat and you just define your

567
00:33:47,670 --> 00:33:49,860
own om number then it's the same way as

568
00:33:49,860 --> 00:33:51,810
any other IPMI thing where there aren't

569
00:33:51,810 --> 00:33:53,490
any extra bytes if you do it according

570
00:33:53,490 --> 00:33:55,800
to the spec their group oe/oe m commands

571
00:33:55,800 --> 00:34:02,160
and just om commands and those when you

572
00:34:02,160 --> 00:34:04,430
register them you you tell it you know

573
00:34:04,430 --> 00:34:06,570
register with this group or with this

574
00:34:06,570 --> 00:34:10,440
out with this code and then those get

575
00:34:10,440 --> 00:34:16,199
handled magically for you okay you

576
00:34:16,199 --> 00:34:19,050
mentioned that the old API does not work

577
00:34:19,050 --> 00:34:22,290
any worker on little ending systems and

578
00:34:22,290 --> 00:34:24,989
not on beginning systems how about a new

579
00:34:24,989 --> 00:34:27,480
engine study to reload the Python issue

580
00:34:27,480 --> 00:34:30,750
this should resolve the by issues I

581
00:34:30,750 --> 00:34:32,130
haven't tested the old API

582
00:34:32,130 --> 00:34:35,070
it might work okay on big endian systems

583
00:34:35,070 --> 00:34:39,330
but I haven't I haven't tried it so but

584
00:34:39,330 --> 00:34:41,250
when

585
00:34:41,250 --> 00:34:45,100
when this code is unpacking a multi by

586
00:34:45,100 --> 00:34:49,030
integer it does the right thing and uses

587
00:34:49,030 --> 00:34:53,830
shifting and oaring instead of just

588
00:34:53,830 --> 00:34:56,679
casting and because shifting over they

589
00:34:56,679 --> 00:34:57,850
do the right thing

590
00:34:57,850 --> 00:35:00,490
based on the Indian Miss of your system

591
00:35:00,490 --> 00:35:03,210
then it's it always works

592
00:35:03,210 --> 00:35:07,030
it also works for pecking right because

593
00:35:07,030 --> 00:35:10,510
I'm patty is hot passing the request you

594
00:35:10,510 --> 00:35:13,630
need to also check the response though

595
00:35:13,630 --> 00:35:16,570
it also works for packing wrong

596
00:35:16,570 --> 00:35:19,630
beginning systems yeah so packing and

597
00:35:19,630 --> 00:35:24,160
unpacking I did have to create pack and

598
00:35:24,160 --> 00:35:28,090
unpack methods for each type but they

599
00:35:28,090 --> 00:35:29,680
basically do the inverse of each other

600
00:35:29,680 --> 00:35:32,050
so when you're packing something you're

601
00:35:32,050 --> 00:35:49,540
shifting and and masking okay think I

602
00:35:49,540 --> 00:35:57,880
pee my payload oh if you get a payload

603
00:35:57,880 --> 00:36:00,760
it's an object and you perform regular

604
00:36:00,760 --> 00:36:04,060
operations on it so you don't have to

605
00:36:04,060 --> 00:36:07,420
cast things you you can call pack well

606
00:36:07,420 --> 00:36:09,550
if it's a request payload then you're

607
00:36:09,550 --> 00:36:13,510
calling unpack on it and you and it it

608
00:36:13,510 --> 00:36:15,190
does all of the checking and stuff the

609
00:36:15,190 --> 00:36:16,869
same as if it got passed into the

610
00:36:16,869 --> 00:36:20,200
function yeah I was wondering the

611
00:36:20,200 --> 00:36:22,810
library you use for unit new API the

612
00:36:22,810 --> 00:36:25,450
parsing code the Platinum hat is that

613
00:36:25,450 --> 00:36:27,700
available for perhaps other demons as

614
00:36:27,700 --> 00:36:31,720
well it's funny you would ask as I do

615
00:36:31,720 --> 00:36:34,750
you see like for Pio diem for example it

616
00:36:34,750 --> 00:36:36,670
we have this very similar problem we

617
00:36:36,670 --> 00:36:40,600
write in big fields or the response can

618
00:36:40,600 --> 00:36:42,820
be variable length right he's almost the

619
00:36:42,820 --> 00:36:46,210
same as no PMI I I did not pay him I

620
00:36:46,210 --> 00:36:48,700
swear this is exactly one of the

621
00:36:48,700 --> 00:36:51,820
questions that I did want to happen this

622
00:36:51,820 --> 00:36:54,910
is not an IP mi specific thing

623
00:36:54,910 --> 00:36:58,599
like I mentioned earlier the ideas I

624
00:36:58,599 --> 00:37:03,250
stole from SD bus plus and so the the

625
00:37:03,250 --> 00:37:05,940
notion of being able to inspect a

626
00:37:05,940 --> 00:37:09,099
function and pack and unpack based on

627
00:37:09,099 --> 00:37:13,269
some tuple is generic yeah

628
00:37:13,269 --> 00:37:16,180
in the D bus case we also had extra

629
00:37:16,180 --> 00:37:18,730
metadata in the the message type itself

630
00:37:18,730 --> 00:37:24,460
but I assume P LD M is just packing it's

631
00:37:24,460 --> 00:37:27,190
kind of like IPMI does yeah it's very

632
00:37:27,190 --> 00:37:29,259
very similar and also the response type

633
00:37:29,259 --> 00:37:31,569
to him very based on let's say for spite

634
00:37:31,569 --> 00:37:33,160
it would tell you you know how many more

635
00:37:33,160 --> 00:37:37,059
bites to it it's bad right so the

636
00:37:37,059 --> 00:37:39,279
library itself while the library it's

637
00:37:39,279 --> 00:37:42,660
it's all just headers in the ipmi

638
00:37:42,660 --> 00:37:47,170
codebase but there there probably are

639
00:37:47,170 --> 00:37:49,720
enough tie-ins to other ipmi stuff that

640
00:37:49,720 --> 00:37:51,130
you wouldn't want to just use it

641
00:37:51,130 --> 00:37:54,069
directly but you could certainly cut and

642
00:37:54,069 --> 00:37:57,369
paste and and stuff but that the ideas

643
00:37:57,369 --> 00:38:01,509
exist across many domains that's why in

644
00:38:01,509 --> 00:38:03,910
the title of the presentation there was

645
00:38:03,910 --> 00:38:05,940
nothing about

646
00:38:05,940 --> 00:38:08,799
ipmi itself it was improving security

647
00:38:08,799 --> 00:38:12,339
and readability at the same time so yes

648
00:38:12,339 --> 00:38:15,730
this could help peel DM keep in mind it

649
00:38:15,730 --> 00:38:17,940
will increase the binary size though

650
00:38:17,940 --> 00:38:25,900
right thank you very much not currently

651
00:38:25,900 --> 00:38:30,819
but I I think Edie was considering

652
00:38:30,819 --> 00:38:34,869
something like this he Edie was very

653
00:38:34,869 --> 00:38:37,390
jealous that I did this to IPMI and he

654
00:38:37,390 --> 00:38:41,259
didn't get to do it first so if you go

655
00:38:41,259 --> 00:38:43,539
to Edie enough maybe he would do it for

656
00:38:43,539 --> 00:38:53,849
oh for BMC web as well for JSON okay

657
00:38:53,849 --> 00:38:56,680
what he didn't do so the parsing is

658
00:38:56,680 --> 00:39:00,309
there but and and that's equivalent to

659
00:39:00,309 --> 00:39:03,970
the SD bus plus but the SD bus plus SEO

660
00:39:03,970 --> 00:39:08,160
mechanism you get to specify the

661
00:39:08,160 --> 00:39:10,589
to unpack that way instead of calling

662
00:39:10,589 --> 00:39:13,230
unpack so that's the that's the only

663
00:39:13,230 --> 00:39:15,809
difference there was it was messing with

664
00:39:15,809 --> 00:39:19,440
the function callable traits and that

665
00:39:19,440 --> 00:39:24,480
kind of stuff that that makes this

666
00:39:24,480 --> 00:39:29,520
differ from the BMC web stuff to two

667
00:39:29,520 --> 00:39:31,589
good points that you can carry back to

668
00:39:31,589 --> 00:39:36,329
ed one is a definite applause for your

669
00:39:36,329 --> 00:39:41,849
use of unit testing another is the way

670
00:39:41,849 --> 00:39:44,309
that you implemented for ipm ID using

671
00:39:44,309 --> 00:39:46,470
very attic templates is actually

672
00:39:46,470 --> 00:39:48,450
superior to what was done for SD bus

673
00:39:48,450 --> 00:39:50,549
plus the issue there is that if you're

674
00:39:50,549 --> 00:39:54,000
using variants and templates you have

675
00:39:54,000 --> 00:39:57,200
the ability to generate a a runaway

676
00:39:57,200 --> 00:40:00,329
template case within the compiler so for

677
00:40:00,329 --> 00:40:01,650
example I have a couple cases I'm

678
00:40:01,650 --> 00:40:03,510
dealing with now where I add an SD bus

679
00:40:03,510 --> 00:40:05,730
plus create one of its structures for a

680
00:40:05,730 --> 00:40:08,849
response and my code goes from 200k to

681
00:40:08,849 --> 00:40:17,039
nine megabytes all right any other

682
00:40:17,039 --> 00:40:36,059
questions well I'm not sure that I have

683
00:40:36,059 --> 00:40:37,730
any specific plans for adding more

684
00:40:37,730 --> 00:40:44,609
commands because well we're expending

685
00:40:44,609 --> 00:40:47,250
more effort on in improving redfish and

686
00:40:47,250 --> 00:40:49,529
that kind of stuff because we do want to

687
00:40:49,529 --> 00:40:51,029
encourage people to move away from IP

688
00:40:51,029 --> 00:40:55,880
might be but there are some other

689
00:40:55,880 --> 00:40:59,339
improvements to IPM ID that I would like

690
00:40:59,339 --> 00:41:04,410
to see links the talk this is a comment

691
00:41:04,410 --> 00:41:07,079
on moving away from a few my I commend

692
00:41:07,079 --> 00:41:10,260
it but we're stuck with it for the host

693
00:41:10,260 --> 00:41:12,180
to BMC interface for probably a very

694
00:41:12,180 --> 00:41:14,039
long time so as much as redfish will get

695
00:41:14,039 --> 00:41:16,170
rid of the they're kind of um they'll

696
00:41:16,170 --> 00:41:18,089
work facing aspects we're stuck with our

697
00:41:18,089 --> 00:41:19,420
be my day for a long time

698
00:41:19,420 --> 00:41:23,970
alright I think that's all then

699
00:41:25,590 --> 00:41:29,179
[Applause]

700
00:41:30,250 --> 00:41:36,490
[Music]

