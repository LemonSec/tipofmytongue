1
00:00:03,190 --> 00:00:06,259
[Music]

2
00:00:06,770 --> 00:00:10,380
okay our next speaker is Crestwood she

3
00:00:10,380 --> 00:00:12,690
is a principal engineer at Lenovo and

4
00:00:12,690 --> 00:00:15,179
has been working on EMC firmware for 16

5
00:00:15,179 --> 00:00:16,980
years but just recently joined hope and

6
00:00:16,980 --> 00:00:20,910
BMC community today everybody good to be

7
00:00:20,910 --> 00:00:22,769
here I was here at the hackathon

8
00:00:22,769 --> 00:00:24,840
actually not here but in I guess it was

9
00:00:24,840 --> 00:00:27,779
Beaverton last year got to meet a lot of

10
00:00:27,779 --> 00:00:30,859
you see a lot of friendly familiar faces

11
00:00:30,859 --> 00:00:33,120
we were there for our first time when

12
00:00:33,120 --> 00:00:37,590
Nova was to get on board with open BMC

13
00:00:37,590 --> 00:00:40,440
and I should stand here when you hear me

14
00:00:40,440 --> 00:00:42,809
better so in the time since then we've

15
00:00:42,809 --> 00:00:47,969
done a few POCs in-house and just wanted

16
00:00:47,969 --> 00:00:49,230
to share with you some of the work that

17
00:00:49,230 --> 00:00:51,239
we've done on some of our our products

18
00:00:51,239 --> 00:00:53,610
that normally go out with our Lenovo

19
00:00:53,610 --> 00:00:56,480
branded BMC firmware but we're trying to

20
00:00:56,480 --> 00:00:59,340
explore and in the realm of open BMC so

21
00:00:59,340 --> 00:01:02,160
the most of this talk is all about open

22
00:01:02,160 --> 00:01:05,540
BMC on on lenovo branded hardware

23
00:01:05,540 --> 00:01:08,520
specifically the sr9 50 so I'll get in

24
00:01:08,520 --> 00:01:12,299
get into some of that so the first step

25
00:01:12,299 --> 00:01:15,479
is the the the the Perley based systems

26
00:01:15,479 --> 00:01:17,640
as the sr9 50 is a perlier based system

27
00:01:17,640 --> 00:01:20,820
and we we build our hardware with a

28
00:01:20,820 --> 00:01:23,820
speed pilot for chip so how many of you

29
00:01:23,820 --> 00:01:26,670
here have used the a speed pilot for or

30
00:01:26,670 --> 00:01:31,790
I've heard of it yeah okay great

31
00:01:31,790 --> 00:01:34,650
hmm a lot of customers have it so that's

32
00:01:34,650 --> 00:01:35,090
good

33
00:01:35,090 --> 00:01:40,439
anyway the pilot for chip goes on all of

34
00:01:40,439 --> 00:01:42,960
our pearly platforms and the first step

35
00:01:42,960 --> 00:01:44,399
in getting opened BMC working is to

36
00:01:44,399 --> 00:01:46,799
enable the silicon so we worked with the

37
00:01:46,799 --> 00:01:49,649
a speed hardware engineers who are here

38
00:01:49,649 --> 00:01:53,880
today and and firmware engineers to to

39
00:01:53,880 --> 00:01:58,409
get the you know open BMC support mostly

40
00:01:58,409 --> 00:02:04,159
the primarily getting the drivers on the

41
00:02:04,159 --> 00:02:08,280
the you know in the open BMC development

42
00:02:08,280 --> 00:02:12,000
framework so what the what did that

43
00:02:12,000 --> 00:02:13,500
involve the

44
00:02:13,500 --> 00:02:16,380
the a speed BSP or SDK comes with a lot

45
00:02:16,380 --> 00:02:17,700
of drivers that are primarily written

46
00:02:17,700 --> 00:02:19,470
for testing the hardware validating the

47
00:02:19,470 --> 00:02:22,200
hardware so a lot of the drivers needed

48
00:02:22,200 --> 00:02:25,440
to be touched to to work in the open BMC

49
00:02:25,440 --> 00:02:27,600
framework and so what I've got here is a

50
00:02:27,600 --> 00:02:29,790
very crude block diagram I did get

51
00:02:29,790 --> 00:02:31,290
permission to show a much more detailed

52
00:02:31,290 --> 00:02:34,050
one but anyway I went with this one

53
00:02:34,050 --> 00:02:35,720
because it conveys the information

54
00:02:35,720 --> 00:02:37,770
basically everything that's in green

55
00:02:37,770 --> 00:02:39,480
where all of the drivers that had to be

56
00:02:39,480 --> 00:02:40,910
touched to some degree or another

57
00:02:40,910 --> 00:02:43,560
including the the basic that the chip

58
00:02:43,560 --> 00:02:46,430
enablement for the for the processor

59
00:02:46,430 --> 00:02:49,410
mm-hmm this this represented many months

60
00:02:49,410 --> 00:02:52,650
of work to get going and you can see you

61
00:02:52,650 --> 00:02:54,360
could go out to the github app provided

62
00:02:54,360 --> 00:02:58,040
the github link on a speeds account to

63
00:02:58,040 --> 00:03:01,800
to pull that branch so you could

64
00:03:01,800 --> 00:03:03,180
actually play with this yourself you had

65
00:03:03,180 --> 00:03:08,430
a pilot for BSP or a Lenovo service the

66
00:03:08,430 --> 00:03:09,690
only hardware changes we had to make

67
00:03:09,690 --> 00:03:12,750
were the adding the 32 megabytes by ROM

68
00:03:12,750 --> 00:03:16,050
we boot from a smaller spy ROM so that's

69
00:03:16,050 --> 00:03:18,180
that hardware change plus the associated

70
00:03:18,180 --> 00:03:20,970
straps so that was step one which was

71
00:03:20,970 --> 00:03:23,100
not an insignificant step it took many

72
00:03:23,100 --> 00:03:25,440
months to get going we did initially

73
00:03:25,440 --> 00:03:27,750
enable it on one of our lower end

74
00:03:27,750 --> 00:03:30,209
servers SR 650 which is a two socket but

75
00:03:30,209 --> 00:03:32,040
this endeavor was to see who could get

76
00:03:32,040 --> 00:03:35,910
going on the SR 950 so that was a joint

77
00:03:35,910 --> 00:03:40,019
joint operation with HP SR 950 just to

78
00:03:40,019 --> 00:03:41,340
give you a brief introduction about it

79
00:03:41,340 --> 00:03:42,780
it's kind of our flagship server and

80
00:03:42,780 --> 00:03:44,549
this isn't a sales pitch about our

81
00:03:44,549 --> 00:03:45,780
server and just need to give you a

82
00:03:45,780 --> 00:03:47,370
little bit of background about what we

83
00:03:47,370 --> 00:03:52,170
chose it's it's a very dense system so

84
00:03:52,170 --> 00:03:54,959
it's a xeon based family the Perley

85
00:03:54,959 --> 00:03:57,989
generation of processors it's got a lot

86
00:03:57,989 --> 00:04:01,200
of i/o it's got sixteen PCIe slots for

87
00:04:01,200 --> 00:04:05,519
power supplies it's highly modularized

88
00:04:05,519 --> 00:04:08,519
so we have CPU trays and you can see

89
00:04:08,519 --> 00:04:11,959
there we support eight sockets 96 dims

90
00:04:11,959 --> 00:04:14,640
it's pretty storage rich and a lot of

91
00:04:14,640 --> 00:04:17,608
fans so what this means for open BMC is

92
00:04:17,608 --> 00:04:21,029
lots of sensors and a lot of potential

93
00:04:21,029 --> 00:04:23,160
you know d-bus activity so this is one

94
00:04:23,160 --> 00:04:24,360
of the reasons we were interested in

95
00:04:24,360 --> 00:04:26,550
targeting this to see how well open BMC

96
00:04:26,550 --> 00:04:27,120
scales

97
00:04:27,120 --> 00:04:31,199
out to a very dense platform also I

98
00:04:31,199 --> 00:04:34,560
wanted to point out the okay I wanted to

99
00:04:34,560 --> 00:04:37,919
get still hear me okay yeah I just want

100
00:04:37,919 --> 00:04:39,810
to point out the main board has of

101
00:04:39,810 --> 00:04:40,830
course the pilot for which we talked

102
00:04:40,830 --> 00:04:43,639
about and an FPGA the system FPGA is

103
00:04:43,639 --> 00:04:46,139
it's common to all our platforms and

104
00:04:46,139 --> 00:04:50,370
it's it it's a very significant piece of

105
00:04:50,370 --> 00:04:52,680
our hardware so I wanted to give it a

106
00:04:52,680 --> 00:04:54,780
little bit of a sound bite because

107
00:04:54,780 --> 00:04:56,850
enabling the FPGA was also part of

108
00:04:56,850 --> 00:05:00,810
getting the the open BMC to boot and run

109
00:05:00,810 --> 00:05:02,699
right this is where power control is

110
00:05:02,699 --> 00:05:05,520
this is where a lot of inventory comes

111
00:05:05,520 --> 00:05:07,949
from and some temperature sensors and

112
00:05:07,949 --> 00:05:10,710
fan control so we've offloaded a lot of

113
00:05:10,710 --> 00:05:14,039
things on to the FPGA so FPGA is I don't

114
00:05:14,039 --> 00:05:16,110
know how common they are in most of the

115
00:05:16,110 --> 00:05:17,699
building blocks with VMC's but obviously

116
00:05:17,699 --> 00:05:20,600
they've been around for a very long time

117
00:05:20,600 --> 00:05:23,630
we chose an FPGA for this system because

118
00:05:23,630 --> 00:05:25,830
frankly there's a lot of hyoe on it and

119
00:05:25,830 --> 00:05:28,560
it's for what it's capable of doing it's

120
00:05:28,560 --> 00:05:30,389
low-cost right you can you can change

121
00:05:30,389 --> 00:05:32,900
the fabric after you spend the board's

122
00:05:32,900 --> 00:05:35,070
we have a hundred and twenty voltage

123
00:05:35,070 --> 00:05:38,400
regulators on our VRD devices in the

124
00:05:38,400 --> 00:05:40,289
eight socket config of this platform so

125
00:05:40,289 --> 00:05:42,560
with the power okay and the power good

126
00:05:42,560 --> 00:05:47,160
there's you know 240 plus i/o that's

127
00:05:47,160 --> 00:05:49,560
that's putting a strain on a on a

128
00:05:49,560 --> 00:05:53,389
typical BMC just for GPIO it's also got

129
00:05:53,389 --> 00:05:57,690
as an FPGA it's more real-time right so

130
00:05:57,690 --> 00:06:00,210
you're responding in nanoseconds without

131
00:06:00,210 --> 00:06:03,419
you know program loops inside this is

132
00:06:03,419 --> 00:06:05,580
useful for power sequencing right so

133
00:06:05,580 --> 00:06:07,440
when when you have a power fault you

134
00:06:07,440 --> 00:06:09,030
need to back off those reels fast enough

135
00:06:09,030 --> 00:06:10,199
you've got to do it fast enough so that

136
00:06:10,199 --> 00:06:12,840
you don't get biasing this is to protect

137
00:06:12,840 --> 00:06:14,430
your hardware so the FPGA is quick

138
00:06:14,430 --> 00:06:15,300
enough to do that

139
00:06:15,300 --> 00:06:18,810
across all these rails also there's some

140
00:06:18,810 --> 00:06:21,090
LCD control so on this server we have

141
00:06:21,090 --> 00:06:23,880
little LCD front panel up front and the

142
00:06:23,880 --> 00:06:25,280
screen needs to be painted

143
00:06:25,280 --> 00:06:27,870
you don't want your BMC constantly

144
00:06:27,870 --> 00:06:30,169
painting pixels on the screen right so

145
00:06:30,169 --> 00:06:33,030
the fpga takes care of that there

146
00:06:33,030 --> 00:06:34,530
there's a long list of other things you

147
00:06:34,530 --> 00:06:37,229
might use an FPGA for that fall under

148
00:06:37,229 --> 00:06:38,760
the category of real-time offloading

149
00:06:38,760 --> 00:06:40,470
anything you can

150
00:06:40,470 --> 00:06:42,930
an FPGA up to your BMC and you have a

151
00:06:42,930 --> 00:06:44,760
fast-enough link low enough latency you

152
00:06:44,760 --> 00:06:48,480
can you know it's kind of a cool little

153
00:06:48,480 --> 00:06:51,000
playground to imagine what what software

154
00:06:51,000 --> 00:06:52,260
function you want to push out to the

155
00:06:52,260 --> 00:06:54,180
FPGA it doesn't have to be Hardware

156
00:06:54,180 --> 00:06:55,860
function you could accelerate a lot of

157
00:06:55,860 --> 00:06:58,800
things with that so I'll leave that to

158
00:06:58,800 --> 00:07:00,660
your imagination the other thing you

159
00:07:00,660 --> 00:07:03,450
might want to offload is like time zero

160
00:07:03,450 --> 00:07:05,580
so if you want to boot the server a

161
00:07:05,580 --> 00:07:07,080
little faster what sort of things can

162
00:07:07,080 --> 00:07:09,210
you can you have what the BMC could

163
00:07:09,210 --> 00:07:12,360
normally do but you want the BMC doing

164
00:07:12,360 --> 00:07:15,210
other things so it's not necessarily

165
00:07:15,210 --> 00:07:17,400
real time but you want to do it in

166
00:07:17,400 --> 00:07:19,230
parallel while you're booting so this is

167
00:07:19,230 --> 00:07:21,510
you know we may have to configure the VR

168
00:07:21,510 --> 00:07:23,280
DS based on the processor SKU that's in

169
00:07:23,280 --> 00:07:26,550
the system and we want to enable power

170
00:07:26,550 --> 00:07:28,620
as quickly as possible so the customer

171
00:07:28,620 --> 00:07:30,240
doesn't plug it in and have to wait four

172
00:07:30,240 --> 00:07:31,650
and a half minutes or whatever for their

173
00:07:31,650 --> 00:07:33,090
BMC to be ready before they could turn

174
00:07:33,090 --> 00:07:37,500
it on the LCD initialization - right

175
00:07:37,500 --> 00:07:39,480
before video you get you get nice little

176
00:07:39,480 --> 00:07:41,280
LCD telling you that the server's

177
00:07:41,280 --> 00:07:45,540
working properly inventory there's a lot

178
00:07:45,540 --> 00:07:47,580
of dims out here on well not on this

179
00:07:47,580 --> 00:07:50,280
board but on the CPU boards so one could

180
00:07:50,280 --> 00:07:52,530
imagine you can wire that FPGA and all

181
00:07:52,530 --> 00:07:55,500
its i/o into multiple i2c buses to

182
00:07:55,500 --> 00:07:58,200
pre-harvest SPD content or you know

183
00:07:58,200 --> 00:07:59,850
other other things right then the BMC

184
00:07:59,850 --> 00:08:01,530
can come back and ask the FPGA what

185
00:08:01,530 --> 00:08:04,169
changed so a lot of value in putting an

186
00:08:04,169 --> 00:08:10,830
FPGA with the BMC yeah so the other

187
00:08:10,830 --> 00:08:12,660
thing is that it's it's a field

188
00:08:12,660 --> 00:08:14,040
updatable I think I touched on that it's

189
00:08:14,040 --> 00:08:16,260
it's hardware that kind of changes after

190
00:08:16,260 --> 00:08:17,820
you build your board so you can you can

191
00:08:17,820 --> 00:08:19,650
offload function let's say you find some

192
00:08:19,650 --> 00:08:21,780
piece of function that's broken and you

193
00:08:21,780 --> 00:08:23,190
don't have time to resend silicon

194
00:08:23,190 --> 00:08:25,110
whether it's the BMC or something else

195
00:08:25,110 --> 00:08:27,960
right you you you can push stuff onto

196
00:08:27,960 --> 00:08:30,930
the FPGA and reduce your dependence on

197
00:08:30,930 --> 00:08:35,070
on other silicon okay so what did we get

198
00:08:35,070 --> 00:08:37,409
done with the SR 950 and this is this is

199
00:08:37,409 --> 00:08:38,940
the part that's made me nervous because

200
00:08:38,940 --> 00:08:41,190
we didn't actually get everything we

201
00:08:41,190 --> 00:08:44,420
wanted to do completed before today but

202
00:08:44,420 --> 00:08:48,030
we are still working on it right so we

203
00:08:48,030 --> 00:08:50,040
do have a made a Lenovo layer where we

204
00:08:50,040 --> 00:08:52,950
have support for the sr9 50 and the SR

205
00:08:52,950 --> 00:08:54,209
850

206
00:08:54,209 --> 00:08:56,069
the SR 650 is there as well I just

207
00:08:56,069 --> 00:08:57,869
didn't list it it's under a different

208
00:08:57,869 --> 00:09:03,720
name but yeah right now it's an internal

209
00:09:03,720 --> 00:09:05,100
get repo because it's not mature enough

210
00:09:05,100 --> 00:09:06,629
to share the rest of the world but the

211
00:09:06,629 --> 00:09:09,119
intention is to make it available at

212
00:09:09,119 --> 00:09:13,860
some point the it does include support

213
00:09:13,860 --> 00:09:16,170
for the system fpga we we were able to

214
00:09:16,170 --> 00:09:18,809
obviously build the code that's not

215
00:09:18,809 --> 00:09:20,699
really challenging although sometimes it

216
00:09:20,699 --> 00:09:24,569
is we you know there was some discussion

217
00:09:24,569 --> 00:09:27,899
about how you can deal with in the lab

218
00:09:27,899 --> 00:09:29,579
when you're developing on a system that

219
00:09:29,579 --> 00:09:31,740
has a spy ROM your spiral emulators

220
00:09:31,740 --> 00:09:33,990
those are great we've used those in this

221
00:09:33,990 --> 00:09:35,369
particular solution we've gone a

222
00:09:35,369 --> 00:09:37,019
different route we have a Raspberry Pi

223
00:09:37,019 --> 00:09:40,139
that basically has the flash ROM from I

224
00:09:40,139 --> 00:09:42,420
think the chromium project that we pull

225
00:09:42,420 --> 00:09:43,949
that in and we can use that from the

226
00:09:43,949 --> 00:09:47,220
command line to to read the ROM contents

227
00:09:47,220 --> 00:09:48,540
and then flash their own contents

228
00:09:48,540 --> 00:09:50,369
without having to go up and touch this

229
00:09:50,369 --> 00:09:51,720
thing so we can stick the Raspberry Pi

230
00:09:51,720 --> 00:09:53,279
on the server and throw it in a rack and

231
00:09:53,279 --> 00:09:55,529
walk away and SSH into the Raspberry Pi

232
00:09:55,529 --> 00:09:57,509
and have our way with the spy ROM

233
00:09:57,509 --> 00:10:00,089
without having to do anything physical

234
00:10:00,089 --> 00:10:02,369
with the server so this allows us to

235
00:10:02,369 --> 00:10:04,410
recover and and analyze in the case we

236
00:10:04,410 --> 00:10:06,360
we corrupt our spy ROM which we did

237
00:10:06,360 --> 00:10:08,910
quite a bit going from four megabyte ROM

238
00:10:08,910 --> 00:10:10,769
to 32 megabyte we had some issues with

239
00:10:10,769 --> 00:10:15,809
three by four byte translation let's see

240
00:10:15,809 --> 00:10:18,269
so we've got you know ipmi up and

241
00:10:18,269 --> 00:10:19,740
running so this is kind of a testament

242
00:10:19,740 --> 00:10:22,019
to the stability of open BMC in general

243
00:10:22,019 --> 00:10:23,759
right so you build it you put it on your

244
00:10:23,759 --> 00:10:27,990
chip it comes up and you get IPMI right

245
00:10:27,990 --> 00:10:30,119
there's not a lot more you have to do in

246
00:10:30,119 --> 00:10:32,249
order to get the core ipmi function so

247
00:10:32,249 --> 00:10:33,600
that was working and then some basic

248
00:10:33,600 --> 00:10:35,519
sensors came up automatically a couple

249
00:10:35,519 --> 00:10:37,319
of three voltage sensors and six fan

250
00:10:37,319 --> 00:10:39,389
sensors there nothing nothing behind

251
00:10:39,389 --> 00:10:39,779
them

252
00:10:39,779 --> 00:10:42,509
right so our goal was to implement all

253
00:10:42,509 --> 00:10:44,459
these sensors for all the devices right

254
00:10:44,459 --> 00:10:49,319
but we we didn't get that done but not

255
00:10:49,319 --> 00:10:53,209
to leave you hanging we do have some

256
00:10:53,209 --> 00:10:55,139
these are things that we were intending

257
00:10:55,139 --> 00:10:56,549
to do so we're gonna share that with you

258
00:10:56,549 --> 00:10:59,999
now because I think this speaks to a

259
00:10:59,999 --> 00:11:02,730
story that's often overlooked in

260
00:11:02,730 --> 00:11:05,100
performance and so our perspective here

261
00:11:05,100 --> 00:11:06,120
was that this is going to be a

262
00:11:06,120 --> 00:11:09,540
performance sort of survey of the Cape

263
00:11:09,540 --> 00:11:12,930
when we look at our when we go to our

264
00:11:12,930 --> 00:11:15,030
customers a lot of our customers ask us

265
00:11:15,030 --> 00:11:18,180
how fast the BMC Boots right what sits

266
00:11:18,180 --> 00:11:20,880
on an AC cycle Holland's it take before

267
00:11:20,880 --> 00:11:22,950
IPMI responds how long before the web

268
00:11:22,950 --> 00:11:26,690
responds and redfish etc warm resets and

269
00:11:26,690 --> 00:11:29,460
first boot scenarios after an AC flat

270
00:11:29,460 --> 00:11:31,470
sorry after a farmer update these are

271
00:11:31,470 --> 00:11:33,780
all different scenarios across which

272
00:11:33,780 --> 00:11:36,860
these times matter to customers and so

273
00:11:36,860 --> 00:11:40,230
we wanted to to profile open BMC in this

274
00:11:40,230 --> 00:11:42,060
category and you can see we got some

275
00:11:42,060 --> 00:11:44,280
numbers from the IPMI stack that was

276
00:11:44,280 --> 00:11:47,340
running in the base image with the pilot

277
00:11:47,340 --> 00:11:49,280
for support courses

278
00:11:49,280 --> 00:11:51,960
where did I get the time to live

279
00:11:51,960 --> 00:11:54,120
expected numbers right so that comes

280
00:11:54,120 --> 00:11:57,060
from our history and what our customers

281
00:11:57,060 --> 00:11:58,950
seem to be taller these are upper

282
00:11:58,950 --> 00:12:00,330
thresholds of what of a lot of our

283
00:12:00,330 --> 00:12:02,370
customers are tolerant of you go beyond

284
00:12:02,370 --> 00:12:05,370
that defects have written code has to be

285
00:12:05,370 --> 00:12:08,100
respond or you know it's it's not a good

286
00:12:08,100 --> 00:12:12,870
day so those are pretty high numbers I'm

287
00:12:12,870 --> 00:12:16,140
I think it would be interesting if we

288
00:12:16,140 --> 00:12:19,140
had a set of criteria for within open

289
00:12:19,140 --> 00:12:21,690
BMC to say these are our thresholds

290
00:12:21,690 --> 00:12:24,570
right obviously can be configuration

291
00:12:24,570 --> 00:12:26,400
dependent you put a high end server with

292
00:12:26,400 --> 00:12:27,990
a lot of sensors can take a little

293
00:12:27,990 --> 00:12:29,760
longer but what what should that be

294
00:12:29,760 --> 00:12:32,190
should there be sort of a formula based

295
00:12:32,190 --> 00:12:34,470
on how many dims what are the factors

296
00:12:34,470 --> 00:12:35,130
involved

297
00:12:35,130 --> 00:12:37,339
what should the upper limits be

298
00:12:37,339 --> 00:12:39,750
similarly the things the same thing can

299
00:12:39,750 --> 00:12:41,910
be said about service response times so

300
00:12:41,910 --> 00:12:43,890
it's not just how long it took your ipmi

301
00:12:43,890 --> 00:12:45,570
stack to come up but how responsive is

302
00:12:45,570 --> 00:12:47,310
it to get a sensor a complete sensor

303
00:12:47,310 --> 00:12:49,050
listing if that takes a minute and a

304
00:12:49,050 --> 00:12:51,240
half that's not very good

305
00:12:51,240 --> 00:12:54,510
if the round-trip time for an IPM I

306
00:12:54,510 --> 00:12:56,400
command is beyond a certain amount of

307
00:12:56,400 --> 00:12:58,050
time which at that time be that's not

308
00:12:58,050 --> 00:13:00,570
good because you know a lot of our

309
00:13:00,570 --> 00:13:02,460
customers when we analyze the IPMI

310
00:13:02,460 --> 00:13:04,860
traffic there's quite a bit of ipmi

311
00:13:04,860 --> 00:13:06,630
traffic there can be many thousands of

312
00:13:06,630 --> 00:13:08,160
IPMI commands that are issued every

313
00:13:08,160 --> 00:13:10,680
minute all right so these performance

314
00:13:10,680 --> 00:13:14,760
numbers matter walking you know other

315
00:13:14,760 --> 00:13:17,370
examples like walking the redfish tree

316
00:13:17,370 --> 00:13:18,600
if you want to go and just pull the

317
00:13:18,600 --> 00:13:20,850
whole schema pull all of the the urls

318
00:13:20,850 --> 00:13:21,730
and redfish

319
00:13:21,730 --> 00:13:23,439
that can take a while especially if

320
00:13:23,439 --> 00:13:25,329
there's a lot of elements there like

321
00:13:25,329 --> 00:13:29,439
logs and web login page this is

322
00:13:29,439 --> 00:13:31,559
something that that we've we've profiled

323
00:13:31,559 --> 00:13:35,230
on our side of things how long does it

324
00:13:35,230 --> 00:13:37,209
take for the login page to show up how

325
00:13:37,209 --> 00:13:38,829
long before you can actually type in

326
00:13:38,829 --> 00:13:40,929
your username credentials and then how

327
00:13:40,929 --> 00:13:44,169
long after you hit enter before the the

328
00:13:44,169 --> 00:13:45,999
home page is loaded right so a lot of

329
00:13:45,999 --> 00:13:47,829
those are a balance between just not

330
00:13:47,829 --> 00:13:49,689
just BMC performance but network

331
00:13:49,689 --> 00:13:51,279
performance which we can't really

332
00:13:51,279 --> 00:13:52,869
control a lot of that there are some

333
00:13:52,869 --> 00:13:55,720
variables we can control but the client

334
00:13:55,720 --> 00:13:57,129
performance if you've written your

335
00:13:57,129 --> 00:13:58,779
JavaScript poorly that can take a lot

336
00:13:58,779 --> 00:14:01,119
longer right so and how you're

337
00:14:01,119 --> 00:14:02,799
expressing your your web you know

338
00:14:02,799 --> 00:14:05,980
widgets that can that can take a lot

339
00:14:05,980 --> 00:14:09,160
longer these are things that it might be

340
00:14:09,160 --> 00:14:11,489
important for the client side to profile

341
00:14:11,489 --> 00:14:13,600
another thing that's very important is

342
00:14:13,600 --> 00:14:15,160
flashing times and I should also say

343
00:14:15,160 --> 00:14:17,079
flash sizes but mostly everything I'm

344
00:14:17,079 --> 00:14:20,339
here I'm focused on here as a time wise

345
00:14:20,339 --> 00:14:24,249
flash times so I you know three basic

346
00:14:24,249 --> 00:14:25,749
metrics are the time to transfer the

347
00:14:25,749 --> 00:14:27,759
image and the time to update the image

348
00:14:27,759 --> 00:14:29,439
in an activation which is usually

349
00:14:29,439 --> 00:14:31,509
deferred till later customers are okay

350
00:14:31,509 --> 00:14:34,559
to go ahead and push the image down and

351
00:14:34,559 --> 00:14:37,149
defer the activation until some other

352
00:14:37,149 --> 00:14:39,059
time when there's a maintenance window

353
00:14:39,059 --> 00:14:40,989
especially if it takes a long time to

354
00:14:40,989 --> 00:14:42,249
transfer the image they want to be able

355
00:14:42,249 --> 00:14:44,619
to do that while the server remains 100%

356
00:14:44,619 --> 00:14:46,869
functional so these are the metrics that

357
00:14:46,869 --> 00:14:49,419
were interested in gathering so we need

358
00:14:49,419 --> 00:14:51,669
some sort of system to gather this you

359
00:14:51,669 --> 00:14:53,259
could you could look external to the box

360
00:14:53,259 --> 00:14:55,899
that's that's that should definitely be

361
00:14:55,899 --> 00:14:57,339
done and it's probably the most obvious

362
00:14:57,339 --> 00:14:59,919
thing to do is to write some sort of

363
00:14:59,919 --> 00:15:01,929
automated test harness to go and every

364
00:15:01,929 --> 00:15:03,669
time you release code to run through

365
00:15:03,669 --> 00:15:07,499
these paces and find out where you sit

366
00:15:07,499 --> 00:15:09,970
but what I'm going to suggest is that

367
00:15:09,970 --> 00:15:11,949
part of keeping your performance hygiene

368
00:15:11,949 --> 00:15:15,249
is is an internal system inside the BMC

369
00:15:15,249 --> 00:15:17,289
it's not meant to replace an external

370
00:15:17,289 --> 00:15:19,239
system but it can augment it it can give

371
00:15:19,239 --> 00:15:21,789
you a better view of what happens when

372
00:15:21,789 --> 00:15:25,059
you fail to meet your IPMI boot time

373
00:15:25,059 --> 00:15:27,189
boot readiness time your IP my time to

374
00:15:27,189 --> 00:15:30,279
live if you if you have a test case that

375
00:15:30,279 --> 00:15:32,039
just tells you oh this release of code

376
00:15:32,039 --> 00:15:35,440
it broke that 90 second budget

377
00:15:35,440 --> 00:15:37,360
next okay so now you've got to go get

378
00:15:37,360 --> 00:15:40,300
all this data from the BMC reproduce it

379
00:15:40,300 --> 00:15:43,600
well you got to reproduce it or plug in

380
00:15:43,600 --> 00:15:45,640
serial debug or do some sort of analysis

381
00:15:45,640 --> 00:15:48,580
all right so the point of this proposal

382
00:15:48,580 --> 00:15:51,100
here is that the BMC can sort of self

383
00:15:51,100 --> 00:15:55,660
monitor and yeah so I'll just walk

384
00:15:55,660 --> 00:15:58,420
through the example the idea is that we

385
00:15:58,420 --> 00:15:59,680
use a hardware free running timer

386
00:15:59,680 --> 00:16:02,680
initialized at in start-up early

387
00:16:02,680 --> 00:16:04,720
assembly sorry early startup code in

388
00:16:04,720 --> 00:16:06,430
assembly so we start one of the timers

389
00:16:06,430 --> 00:16:10,600
we run it at about one tick a 10 ticks

390
00:16:10,600 --> 00:16:12,760
per second so 100 milliseconds per tick

391
00:16:12,760 --> 00:16:14,440
because for this kind of work you don't

392
00:16:14,440 --> 00:16:17,110
you're looking at how long a service

393
00:16:17,110 --> 00:16:19,090
takes to come up you don't necessarily

394
00:16:19,090 --> 00:16:21,790
need a lot of granularity or fine

395
00:16:21,790 --> 00:16:25,750
granularity we we don't have a real-time

396
00:16:25,750 --> 00:16:27,340
clock at time zero we're an early

397
00:16:27,340 --> 00:16:28,600
assembly code and maybe we want to

398
00:16:28,600 --> 00:16:30,580
profile some of that early code so we're

399
00:16:30,580 --> 00:16:32,770
gonna wait until we have the real-time

400
00:16:32,770 --> 00:16:35,260
clock and then try to fix up all those

401
00:16:35,260 --> 00:16:37,930
times after the fact so that it's nice

402
00:16:37,930 --> 00:16:39,610
and human readable when you get one of

403
00:16:39,610 --> 00:16:44,320
the the reports from this boot perf we

404
00:16:44,320 --> 00:16:47,950
log all of these snapshot entries to

405
00:16:47,950 --> 00:16:51,250
temp that's where we do it today I would

406
00:16:51,250 --> 00:16:53,260
I would recommend logging it to a temp

407
00:16:53,260 --> 00:16:55,930
file system there's some discussion I

408
00:16:55,930 --> 00:16:57,990
know there's a telemetry workgroup and

409
00:16:57,990 --> 00:17:00,010
you know this is something that we would

410
00:17:00,010 --> 00:17:01,720
like to work with them to see you that

411
00:17:01,720 --> 00:17:03,760
that this profiling data could be made

412
00:17:03,760 --> 00:17:06,459
available through the telemetry system

413
00:17:06,459 --> 00:17:10,770
as well so what is exactly boot perf

414
00:17:10,770 --> 00:17:13,359
it's basically just an API using this

415
00:17:13,359 --> 00:17:14,470
Hardware timer that's available

416
00:17:14,470 --> 00:17:16,449
throughout all phases of the code early

417
00:17:16,449 --> 00:17:20,439
assembly you boot see the kernel drivers

418
00:17:20,439 --> 00:17:24,069
and user space you could link it to a C

419
00:17:24,069 --> 00:17:26,619
program you could call it from a shell

420
00:17:26,619 --> 00:17:28,840
script there's a boot perf binary as

421
00:17:28,840 --> 00:17:30,220
well that you can run from a shell

422
00:17:30,220 --> 00:17:32,530
script and I apologize it's a little

423
00:17:32,530 --> 00:17:34,270
well it's bigger over here I guess but

424
00:17:34,270 --> 00:17:36,700
yeah it's a little small just an example

425
00:17:36,700 --> 00:17:40,750
of the entry of the API where it's going

426
00:17:40,750 --> 00:17:43,870
to make use of a region and SRAM that's

427
00:17:43,870 --> 00:17:46,900
available immediately and initialize it

428
00:17:46,900 --> 00:17:49,060
and then load it with every time you

429
00:17:49,060 --> 00:17:49,809
call it

430
00:17:49,809 --> 00:17:52,179
Stickley it's going to snapshot the free

431
00:17:52,179 --> 00:17:54,159
running timer it's to get in memory

432
00:17:54,159 --> 00:17:58,269
alongside the code that uniquely

433
00:17:58,269 --> 00:18:00,100
identifies the checkpoint that you've

434
00:18:00,100 --> 00:18:01,840
added to your source all right so it's a

435
00:18:01,840 --> 00:18:03,879
very simple call it's very low overhead

436
00:18:03,879 --> 00:18:07,600
you're not passing a lot of data we do

437
00:18:07,600 --> 00:18:10,299
pass two pieces of data we pass sort of

438
00:18:10,299 --> 00:18:15,460
a type and a subtype and the the idea

439
00:18:15,460 --> 00:18:17,049
behind that is we have components you

440
00:18:17,049 --> 00:18:18,340
might have an IPM I stack you on a

441
00:18:18,340 --> 00:18:20,559
profile you might have redfish stack so

442
00:18:20,559 --> 00:18:22,539
in you know large firmware components

443
00:18:22,539 --> 00:18:24,009
can have their own type identifier and

444
00:18:24,009 --> 00:18:26,409
subtypes can be common codes like zero

445
00:18:26,409 --> 00:18:29,559
for start-up maybe you can you could

446
00:18:29,559 --> 00:18:33,100
pick a number like 255 for fully up and

447
00:18:33,100 --> 00:18:35,019
running and then you can use any subtype

448
00:18:35,019 --> 00:18:37,090
you want in between to profile whatever

449
00:18:37,090 --> 00:18:39,730
of the startup code or throughout the

450
00:18:39,730 --> 00:18:41,679
lifetime of that that that service

451
00:18:41,679 --> 00:18:45,039
whatever metrics you want to publish you

452
00:18:45,039 --> 00:18:47,619
could call this API with you know just

453
00:18:47,619 --> 00:18:51,639
create a header file and define the

454
00:18:51,639 --> 00:18:53,710
values yourself so here's an example of

455
00:18:53,710 --> 00:18:56,649
the output after a boot of a system that

456
00:18:56,649 --> 00:18:59,200
shows just a little debug here where it

457
00:18:59,200 --> 00:19:01,809
shows the sink we use timer 5 in this

458
00:19:01,809 --> 00:19:04,090
example timer 5 happened to have that

459
00:19:04,090 --> 00:19:09,519
16-bit value and the real-time clock at

460
00:19:09,519 --> 00:19:13,480
that time was equal to that and this

461
00:19:13,480 --> 00:19:15,999
this was printed out after the real time

462
00:19:15,999 --> 00:19:18,009
was synced so you see the date and time

463
00:19:18,009 --> 00:19:21,369
on the right is all backwards notated

464
00:19:21,369 --> 00:19:23,619
right reverse notated so you can look at

465
00:19:23,619 --> 00:19:26,740
any any of the data and you know it's

466
00:19:26,740 --> 00:19:29,440
it's a human readable time so it's

467
00:19:29,440 --> 00:19:32,950
showing there that at 6 seconds the boot

468
00:19:32,950 --> 00:19:35,169
started so in this particular case you

469
00:19:35,169 --> 00:19:36,850
boot finished in 6 seconds that's where

470
00:19:36,850 --> 00:19:38,799
we happen to profile it we said there's

471
00:19:38,799 --> 00:19:40,149
no point in saying when you started you

472
00:19:40,149 --> 00:19:42,429
know that that's zero but you can say

473
00:19:42,429 --> 00:19:45,279
when the boot started and then we

474
00:19:45,279 --> 00:19:46,990
validate our kernel and that's at eight

475
00:19:46,990 --> 00:19:49,360
point three seconds and well that took

476
00:19:49,360 --> 00:19:53,409
you know 1.1 seconds to complete anyway

477
00:19:53,409 --> 00:19:55,470
you can fill this up any way you want

478
00:19:55,470 --> 00:19:59,110
the the value here is as I said earlier

479
00:19:59,110 --> 00:20:01,869
to be able to once you know something

480
00:20:01,869 --> 00:20:03,550
has exceeded a number

481
00:20:03,550 --> 00:20:05,770
you can go look at this data and get a

482
00:20:05,770 --> 00:20:07,300
lot more granularity you wouldn't

483
00:20:07,300 --> 00:20:10,030
necessarily test for each one of these

484
00:20:10,030 --> 00:20:12,700
you might just test only for IP my

485
00:20:12,700 --> 00:20:15,040
commands ready and if that blew up that

486
00:20:15,040 --> 00:20:17,200
was really long then you look at this

487
00:20:17,200 --> 00:20:18,880
and you can find out what other things

488
00:20:18,880 --> 00:20:21,010
were long that led up to that right it

489
00:20:21,010 --> 00:20:22,300
might not have been that last step that

490
00:20:22,300 --> 00:20:25,630
took a long time okay so this is this is

491
00:20:25,630 --> 00:20:29,940
a a way to get the data after the fact

492
00:20:29,940 --> 00:20:32,050
there's another concept that you can

493
00:20:32,050 --> 00:20:35,020
take from this and that's self reporting

494
00:20:35,020 --> 00:20:38,280
where the BMC itself and developers can

495
00:20:38,280 --> 00:20:41,679
at Build time specify what they think

496
00:20:41,679 --> 00:20:44,440
these thresholds should be so if I p.m.

497
00:20:44,440 --> 00:20:46,270
I ready should be up in 90 seconds or

498
00:20:46,270 --> 00:20:48,640
maybe you want yours to be up in 15

499
00:20:48,640 --> 00:20:53,380
seconds that's great you could you can

500
00:20:53,380 --> 00:20:55,360
create a config file in this case I gave

501
00:20:55,360 --> 00:20:58,440
you an example of JSON that says I want

502
00:20:58,440 --> 00:21:00,880
this particular service to be available

503
00:21:00,880 --> 00:21:04,390
in 300 seconds so the time to live it's

504
00:21:04,390 --> 00:21:06,010
in the domain of that timer running at

505
00:21:06,010 --> 00:21:09,190
one tick every North 10 ticks a second

506
00:21:09,190 --> 00:21:12,610
so that had better appear by that amount

507
00:21:12,610 --> 00:21:14,380
of time and if it didn't then I have an

508
00:21:14,380 --> 00:21:17,140
action I could generate a log I could

509
00:21:17,140 --> 00:21:18,460
mark it as a failure and what does that

510
00:21:18,460 --> 00:21:21,160
mean basically you have the service

511
00:21:21,160 --> 00:21:22,840
that's looking at these checkpoints and

512
00:21:22,840 --> 00:21:25,780
looking against these times that are

513
00:21:25,780 --> 00:21:28,900
specified in this JSON file and when

514
00:21:28,900 --> 00:21:31,000
something breaks the budget it takes

515
00:21:31,000 --> 00:21:35,440
these actions this allows the BMC to

516
00:21:35,440 --> 00:21:38,440
self-report there would be an OEM ipmi

517
00:21:38,440 --> 00:21:40,570
command that you can issue you could

518
00:21:40,570 --> 00:21:41,920
expose this through a variety of

519
00:21:41,920 --> 00:21:44,650
interfaces I just chose Oh am i PMI to

520
00:21:44,650 --> 00:21:46,750
find out like imagine a test harness

521
00:21:46,750 --> 00:21:49,600
that is doing flashing maybe they don't

522
00:21:49,600 --> 00:21:51,130
really care so much about performance

523
00:21:51,130 --> 00:21:53,590
but that's not the primary function for

524
00:21:53,590 --> 00:21:55,900
their their tests but along the way they

525
00:21:55,900 --> 00:21:58,240
want to know if the flashing if the if

526
00:21:58,240 --> 00:22:00,850
they broke any budget for the time

527
00:22:00,850 --> 00:22:03,280
constraints that were set this command

528
00:22:03,280 --> 00:22:04,510
would just give them a simple indicator

529
00:22:04,510 --> 00:22:06,040
that there was a failure

530
00:22:06,040 --> 00:22:08,350
an additional payload data would would

531
00:22:08,350 --> 00:22:09,730
tell them the breakdown of what failed

532
00:22:09,730 --> 00:22:11,200
then they could pull this log and and

533
00:22:11,200 --> 00:22:13,630
get more information so it's pretty

534
00:22:13,630 --> 00:22:16,240
simple the other idea is that you can

535
00:22:16,240 --> 00:22:16,870
have the B

536
00:22:16,870 --> 00:22:19,090
see identify the scenario so the BMC

537
00:22:19,090 --> 00:22:20,860
hardware is very capable of telling us

538
00:22:20,860 --> 00:22:22,870
what the reset sources were whether it's

539
00:22:22,870 --> 00:22:25,059
because power was lost or a user

540
00:22:25,059 --> 00:22:27,160
initiate initiated a reset command if

541
00:22:27,160 --> 00:22:29,050
our stacks robust enough we can tell

542
00:22:29,050 --> 00:22:31,140
whether that was through redfish or IPMI

543
00:22:31,140 --> 00:22:33,940
or there was a watchdog timer there all

544
00:22:33,940 --> 00:22:35,500
sorts of scenarios that reset scan

545
00:22:35,500 --> 00:22:37,270
occurred it could be because you were

546
00:22:37,270 --> 00:22:40,750
just flashed and then you reset you know

547
00:22:40,750 --> 00:22:42,730
it's noteworthy that the first boot

548
00:22:42,730 --> 00:22:43,930
after a flash there's a lot more

549
00:22:43,930 --> 00:22:47,140
maintenance to do on your way up so you

550
00:22:47,140 --> 00:22:48,760
might have a different threshold for

551
00:22:48,760 --> 00:22:50,710
that scenario so it's good to be able to

552
00:22:50,710 --> 00:22:52,809
identify that in the firmware and then

553
00:22:52,809 --> 00:22:56,920
compare it against that scenarios metric

554
00:22:56,920 --> 00:23:01,510
for success okay well any questions on

555
00:23:01,510 --> 00:23:16,660
the performance hygiene yeah actually

556
00:23:16,660 --> 00:23:18,790
and one of our implementations of this

557
00:23:18,790 --> 00:23:21,700
it's a very thin header file but but

558
00:23:21,700 --> 00:23:24,280
yeah right you could implement it as a

559
00:23:24,280 --> 00:23:26,350
library and you would have to have it in

560
00:23:26,350 --> 00:23:28,809
every phase of boot right so our

561
00:23:28,809 --> 00:23:31,630
implementation of this is it looks the

562
00:23:31,630 --> 00:23:33,309
the pound include basically determines

563
00:23:33,309 --> 00:23:34,720
whether it's being built for you boot or

564
00:23:34,720 --> 00:23:36,400
that's being built for the kernel or

565
00:23:36,400 --> 00:23:37,660
whether it's being built for user space

566
00:23:37,660 --> 00:23:44,320
so it's the same source file yeah not

567
00:23:44,320 --> 00:23:46,660
not publicly but yes we have that and

568
00:23:46,660 --> 00:23:48,520
that's just getting to what we're

569
00:23:48,520 --> 00:23:58,590
wanting to do yes that's the goal right

570
00:23:59,700 --> 00:24:02,590
yeah that's true certainly by looking at

571
00:24:02,590 --> 00:24:04,059
the experiment you you change the

572
00:24:04,059 --> 00:24:07,420
outcome right but the idea here what we

573
00:24:07,420 --> 00:24:09,820
found in the years and years that we've

574
00:24:09,820 --> 00:24:12,309
released firmware is that it's easy to

575
00:24:12,309 --> 00:24:14,890
not pay attention to these things and I

576
00:24:14,890 --> 00:24:16,420
think it's worth paying a little bit of

577
00:24:16,420 --> 00:24:22,960
price to to monitor them and yeah I I

578
00:24:22,960 --> 00:24:25,000
think that the you're using a hardware

579
00:24:25,000 --> 00:24:27,880
timer using a very simple API the code

580
00:24:27,880 --> 00:24:30,200
path is very very small once

581
00:24:30,200 --> 00:24:31,640
I should have mentioned once we move

582
00:24:31,640 --> 00:24:34,250
into the kernel we have access to more

583
00:24:34,250 --> 00:24:37,970
memory well in in early code the idea is

584
00:24:37,970 --> 00:24:38,900
that you're not going to have that many

585
00:24:38,900 --> 00:24:40,370
checkpoints so initially you're loading

586
00:24:40,370 --> 00:24:42,680
you're logging them to SRAM but these

587
00:24:42,680 --> 00:24:44,630
BMC's have limited SRAM so when you

588
00:24:44,630 --> 00:24:47,300
transition to the kernel then region of

589
00:24:47,300 --> 00:24:49,190
memory is allocated and it gets logged

590
00:24:49,190 --> 00:24:52,070
there but it can be a region that's not

591
00:24:52,070 --> 00:24:53,930
managed by the kernel right so it's not

592
00:24:53,930 --> 00:24:57,020
necessarily memory alloc you can just be

593
00:24:57,020 --> 00:25:02,660
a chunk of DRAM out there that is just

594
00:25:02,660 --> 00:25:05,570
as fast well it's not just as fast as

595
00:25:05,570 --> 00:25:06,950
SRAM but you get there's a couple more

596
00:25:06,950 --> 00:25:10,430
i/o cycles but it's it's fast it's not

597
00:25:10,430 --> 00:25:14,210
gonna you it'll be negligible the the

598
00:25:14,210 --> 00:25:16,040
mod so that's the logging portion of it

599
00:25:16,040 --> 00:25:19,400
the monitoring yeah that's gonna take

600
00:25:19,400 --> 00:25:21,020
some time but again I think I think it's

601
00:25:21,020 --> 00:25:23,780
probably worth it in order to have good

602
00:25:23,780 --> 00:25:26,450
hygiene so you're you're aware of when

603
00:25:26,450 --> 00:25:31,460
you break a budget I would expect the

604
00:25:31,460 --> 00:25:33,050
overall flow to go something like you

605
00:25:33,050 --> 00:25:35,420
you write a new piece of code and you

606
00:25:35,420 --> 00:25:37,520
you check it into and you test with it

607
00:25:37,520 --> 00:25:39,290
and you find that you've broken certain

608
00:25:39,290 --> 00:25:40,580
things you go back and check make sure

609
00:25:40,580 --> 00:25:43,040
that your code is well written there's

610
00:25:43,040 --> 00:25:44,270
no bugs in it for example

611
00:25:44,270 --> 00:25:46,790
but you realize now that there was some

612
00:25:46,790 --> 00:25:49,010
inherent impact to power on time that

613
00:25:49,010 --> 00:25:51,200
you just didn't you weren't aware of so

614
00:25:51,200 --> 00:25:52,820
at least it brought you brought that to

615
00:25:52,820 --> 00:25:59,630
your attention right so yeah so they so

616
00:25:59,630 --> 00:26:01,280
this was just a one-off implementation

617
00:26:01,280 --> 00:26:04,640
sort of in the general sense I think

618
00:26:04,640 --> 00:26:08,470
that they could be strings they could be

619
00:26:09,160 --> 00:26:11,750
defined by you know you could have your

620
00:26:11,750 --> 00:26:13,160
own definition for them they're

621
00:26:13,160 --> 00:26:14,780
associated with a string at some point

622
00:26:14,780 --> 00:26:16,990
right so we can generate this log book

623
00:26:16,990 --> 00:26:19,010
keep going the wrong way so we could

624
00:26:19,010 --> 00:26:20,300
generate this log here for the

625
00:26:20,300 --> 00:26:24,200
description the IPMI command you could

626
00:26:24,200 --> 00:26:25,970
you could issue and it would return the

627
00:26:25,970 --> 00:26:27,710
check points that exceeded their

628
00:26:27,710 --> 00:26:29,120
threshold they wouldn't have the string

629
00:26:29,120 --> 00:26:31,250
names for example I mean you could do it

630
00:26:31,250 --> 00:26:33,380
in a way that it you can query the

631
00:26:33,380 --> 00:26:37,040
strings that probably be more portable

632
00:26:37,040 --> 00:26:38,390
right so you don't actually have to have

633
00:26:38,390 --> 00:26:40,930
the source code

634
00:26:44,630 --> 00:26:49,399
yeah you could have your own things and

635
00:26:49,399 --> 00:26:52,110
this is this is something so if I were

636
00:26:52,110 --> 00:26:53,639
to jump to the very end it's kind of a

637
00:26:53,639 --> 00:26:55,580
call to action we we would like to

638
00:26:55,580 --> 00:26:58,200
sponsor a workgroup on performance I

639
00:26:58,200 --> 00:27:00,450
gene right so this is where we're

640
00:27:00,450 --> 00:27:01,769
sharing with you some of our ideas

641
00:27:01,769 --> 00:27:03,750
things that we've implemented one off

642
00:27:03,750 --> 00:27:06,840
that I think the we could if we could

643
00:27:06,840 --> 00:27:09,090
put into the open BMC and get some an

644
00:27:09,090 --> 00:27:11,070
input from everybody on what it you know

645
00:27:11,070 --> 00:27:12,860
how to make it a little bit more robust

646
00:27:12,860 --> 00:27:15,960
that that's our goal right so obviously

647
00:27:15,960 --> 00:27:23,129
changes welcome yes in our

648
00:27:23,129 --> 00:27:25,909
implementation it didn't it does not but

649
00:27:25,909 --> 00:27:29,909
you you could you could migrate to if

650
00:27:29,909 --> 00:27:31,289
you know for example you're gonna shut

651
00:27:31,289 --> 00:27:33,870
down you could move it over to long-term

652
00:27:33,870 --> 00:27:38,190
storage you could have something that's

653
00:27:38,190 --> 00:27:40,860
running in the background or you you

654
00:27:40,860 --> 00:27:42,509
haven't a chance every time boot perf is

655
00:27:42,509 --> 00:27:44,340
call to the API is called you could

656
00:27:44,340 --> 00:27:47,519
implement something to copy it if it

657
00:27:47,519 --> 00:27:48,809
gets to a certain size or under

658
00:27:48,809 --> 00:27:51,570
different conditions sure sure

659
00:27:51,570 --> 00:28:00,899
absolutely because of one failed

660
00:28:00,899 --> 00:28:09,000
component which is kind of that's true

661
00:28:09,000 --> 00:28:11,610
yeah and and and we've we've seen that

662
00:28:11,610 --> 00:28:12,000
before

663
00:28:12,000 --> 00:28:13,740
right so you could you could implement

664
00:28:13,740 --> 00:28:18,360
some rate limiting yeah right you can

665
00:28:18,360 --> 00:28:21,480
rotate the logs from temp to long-term

666
00:28:21,480 --> 00:28:23,330
file storage compress along the way

667
00:28:23,330 --> 00:28:26,669
right yeah that's a good that's a good

668
00:28:26,669 --> 00:28:32,600
problem sir no we haven't

669
00:28:32,600 --> 00:28:35,519
systemd analyze already has a profiling

670
00:28:35,519 --> 00:28:37,289
tool built into system D that lets you

671
00:28:37,289 --> 00:28:39,240
know when the kernel loads all the

672
00:28:39,240 --> 00:28:42,090
application start times yeah when just

673
00:28:42,090 --> 00:28:44,190
me execs it so it has a lot of the

674
00:28:44,190 --> 00:28:46,889
functionality already perfect yeah so I

675
00:28:46,889 --> 00:28:50,370
mean it the intent of this is to span

676
00:28:50,370 --> 00:28:52,200
all boot stages right so it gets the

677
00:28:52,200 --> 00:28:54,029
early assembly it gets the

678
00:28:54,029 --> 00:29:01,349
you booed as well and it right so the

679
00:29:01,349 --> 00:29:03,029
intent here was to be able to cover all

680
00:29:03,029 --> 00:29:05,789
phases of the boot but and if you're not

681
00:29:05,789 --> 00:29:19,979
using system D - of course but something

682
00:29:19,979 --> 00:29:21,479
we found is that sometimes when you're

683
00:29:21,479 --> 00:29:23,340
really analyzing performance problems

684
00:29:23,340 --> 00:29:25,529
you know at a top level it can look like

685
00:29:25,529 --> 00:29:28,229
wow this this program has launched at

686
00:29:28,229 --> 00:29:30,809
time zero and then 55 seconds later it

687
00:29:30,809 --> 00:29:32,700
came up and started responding to

688
00:29:32,700 --> 00:29:34,559
requests what the hell happened those 55

689
00:29:34,559 --> 00:29:37,019
seconds and boot cerf has come in handy

690
00:29:37,019 --> 00:29:39,719
for us where you know we found that this

691
00:29:39,719 --> 00:29:41,519
arrant condition caused us to go off

692
00:29:41,519 --> 00:29:43,440
into a for loop over here that we sit

693
00:29:43,440 --> 00:29:45,299
and spun for 35 seconds and that that

694
00:29:45,299 --> 00:29:47,580
was what was causing us to to break our

695
00:29:47,580 --> 00:29:50,249
performance budget so another benefit to

696
00:29:50,249 --> 00:29:53,219
this is that you can get inside your

697
00:29:53,219 --> 00:29:55,229
application and you can really profile

698
00:29:55,229 --> 00:29:59,009
your application as ad as granular at

699
00:29:59,009 --> 00:30:00,629
the level as you need you can use

700
00:30:00,629 --> 00:30:02,339
compiler flags to increase the

701
00:30:02,339 --> 00:30:04,049
granularity to decrease the granularity

702
00:30:04,049 --> 00:30:06,859
for that that's another benefit here

703
00:30:06,859 --> 00:30:10,139
that systemd analyze didn't provide to

704
00:30:10,139 --> 00:30:22,039
us okay so go the next thing one of the

705
00:30:23,239 --> 00:30:25,200
since your number of limitations has

706
00:30:25,200 --> 00:30:27,450
been mentioned a few times here and we

707
00:30:27,450 --> 00:30:30,809
did some poking around we've we ran into

708
00:30:30,809 --> 00:30:32,580
the sensor number of limitation years

709
00:30:32,580 --> 00:30:35,519
and years ago and this is sort of the

710
00:30:35,519 --> 00:30:37,379
approach that we've taken so I wanted to

711
00:30:37,379 --> 00:30:40,189
just share that with the community

712
00:30:40,999 --> 00:30:43,619
obviously you have 8-bit value for

713
00:30:43,619 --> 00:30:45,960
sensor number but there's the LUN number

714
00:30:45,960 --> 00:30:47,820
and there's there's some really good

715
00:30:47,820 --> 00:30:50,519
conversations that are out there on the

716
00:30:50,519 --> 00:30:53,759
open BMC forums about this but I didn't

717
00:30:53,759 --> 00:30:55,499
see where they landed on this particular

718
00:30:55,499 --> 00:30:57,389
solution and instead what I see is

719
00:30:57,389 --> 00:30:59,479
typical suggestions are OEM

720
00:30:59,479 --> 00:31:01,859
implementations right where you have om

721
00:31:01,859 --> 00:31:04,229
IP my commands and handlers to get the

722
00:31:04,229 --> 00:31:05,970
sensor numbers so what we found is that

723
00:31:05,970 --> 00:31:08,250
this works and this works with IBM i2

724
00:31:08,250 --> 00:31:10,980
which is a pretty common utility that

725
00:31:10,980 --> 00:31:14,370
customers use for managing their bmc's

726
00:31:14,370 --> 00:31:17,850
whenever they're doing IPMI so because

727
00:31:17,850 --> 00:31:22,200
they're limited to 255 well that's where

728
00:31:22,200 --> 00:31:24,690
you have your limitation so in the sdrs

729
00:31:24,690 --> 00:31:27,870
type 1 2 & 3 records there are the

730
00:31:27,870 --> 00:31:30,240
there's a lung field and I've got a

731
00:31:30,240 --> 00:31:32,669
pointer to it it's the second second

732
00:31:32,669 --> 00:31:35,940
image on the right that lung field can

733
00:31:35,940 --> 00:31:39,299
be used to associate that sensor with

734
00:31:39,299 --> 00:31:40,679
different lines right now it means

735
00:31:40,679 --> 00:31:42,030
pretty straightforward

736
00:31:42,030 --> 00:31:43,650
we know that Lund 2 is reserved for

737
00:31:43,650 --> 00:31:46,260
message messaging sorry the message

738
00:31:46,260 --> 00:31:51,510
bridging the get and send event commands

739
00:31:51,510 --> 00:31:54,809
this leaves you with since sensor 255 is

740
00:31:54,809 --> 00:31:56,580
reserved you have about seven hundred

741
00:31:56,580 --> 00:31:58,980
sixty eight sixty five sensors I did my

742
00:31:58,980 --> 00:32:04,440
math right the there's a little snippet

743
00:32:04,440 --> 00:32:06,840
of code over there on ipmi tool that

744
00:32:06,840 --> 00:32:09,929
shows where it is basically pulling the

745
00:32:09,929 --> 00:32:13,799
STR from the BMC and looking at that

746
00:32:13,799 --> 00:32:15,750
lung record this is what it does today

747
00:32:15,750 --> 00:32:17,820
and then it will go back to the BMC to

748
00:32:17,820 --> 00:32:19,260
get the sensor reading and it will use

749
00:32:19,260 --> 00:32:21,450
that lung to get that sensor reading so

750
00:32:21,450 --> 00:32:23,280
you actually will implement the sensors

751
00:32:23,280 --> 00:32:25,260
to get sensor data on a variety of lungs

752
00:32:25,260 --> 00:32:28,230
as you've defined your sensors or spread

753
00:32:28,230 --> 00:32:32,730
them out across the lung buckets but the

754
00:32:32,730 --> 00:32:35,580
the ipmi tool will actually use that

755
00:32:35,580 --> 00:32:37,320
lawn from the SGR record to do that

756
00:32:37,320 --> 00:32:39,570
interrogation sensor reading it works

757
00:32:39,570 --> 00:32:43,620
seamlessly so this gets us well beyond

758
00:32:43,620 --> 00:32:48,330
the 255 sensor limit for our server I

759
00:32:48,330 --> 00:32:50,070
think and Connor can help me out here

760
00:32:50,070 --> 00:32:51,270
with the number I think we were around

761
00:32:51,270 --> 00:32:57,540
392 sensors so now we have had some

762
00:32:57,540 --> 00:32:59,100
customers that require us to stay within

763
00:32:59,100 --> 00:33:00,900
one line maybe they have an older

764
00:33:00,900 --> 00:33:04,020
version of of an IPM I like IPMI util

765
00:33:04,020 --> 00:33:06,570
for example that does not play well with

766
00:33:06,570 --> 00:33:10,890
lund numbers I'll just type EMI

767
00:33:10,890 --> 00:33:12,390
utilities in play well with lots of

768
00:33:12,390 --> 00:33:16,470
things but they're you know one

769
00:33:16,470 --> 00:33:18,270
suggestion is if you're limited to IPMI

770
00:33:18,270 --> 00:33:19,590
is to become get a little bit more

771
00:33:19,590 --> 00:33:20,970
clever with

772
00:33:20,970 --> 00:33:23,520
using the use of a data to an event data

773
00:33:23,520 --> 00:33:25,230
three not necessarily suggesting you go

774
00:33:25,230 --> 00:33:26,040
OEM with it

775
00:33:26,040 --> 00:33:28,140
but them sensors for example we have 96

776
00:33:28,140 --> 00:33:30,810
of them so you can group them right you

777
00:33:30,810 --> 00:33:33,030
can you can have one sensor for a set of

778
00:33:33,030 --> 00:33:36,060
them and then use the event data to or

779
00:33:36,060 --> 00:33:37,530
you can use one sensor for all of them

780
00:33:37,530 --> 00:33:39,930
and use the event data to carry the the

781
00:33:39,930 --> 00:33:41,310
dim number of in data three and that's

782
00:33:41,310 --> 00:33:43,410
standard ipmi specification so that

783
00:33:43,410 --> 00:33:46,170
frees up a lot of things and if you want

784
00:33:46,170 --> 00:33:48,360
more than that then maybe it's time to

785
00:33:48,360 --> 00:33:54,000
move to redfish yeah so I wanted to

786
00:33:54,000 --> 00:33:55,730
share that with the community what has

787
00:33:55,730 --> 00:33:58,830
been your experience with using sensor

788
00:33:58,830 --> 00:34:03,150
numbers above 255 anybody reach that

789
00:34:03,150 --> 00:34:20,280
limit okay perfect perfect yeah there's

790
00:34:20,280 --> 00:34:23,159
always that right yeah so this works

791
00:34:23,159 --> 00:34:24,409
seamlessly I think there have been some

792
00:34:24,409 --> 00:34:27,780
patches to ipmi tool a long time ago

793
00:34:27,780 --> 00:34:30,239
that fix some bugs around this but yeah

794
00:34:30,239 --> 00:34:35,209
it's been working for a long time okay

795
00:34:35,239 --> 00:34:38,659
so another thing that we worked on in

796
00:34:38,659 --> 00:34:43,830
getting you know open BMC going on the

797
00:34:43,830 --> 00:34:47,370
pilot for was the enablement of QEMU for

798
00:34:47,370 --> 00:34:48,899
the pilot for chip something we're

799
00:34:48,899 --> 00:34:50,940
excited to do so we worked on that

800
00:34:50,940 --> 00:34:54,179
in-house and Lenovo and this is that

801
00:34:54,179 --> 00:34:56,668
same map with a few different colors on

802
00:34:56,668 --> 00:34:58,530
it kind of giving you the status of

803
00:34:58,530 --> 00:35:00,960
where we are we found this to be very

804
00:35:00,960 --> 00:35:03,600
useful I I think maybe open BMC is used

805
00:35:03,600 --> 00:35:05,250
primarily for getting the kernel up and

806
00:35:05,250 --> 00:35:06,900
running people that don't necessarily

807
00:35:06,900 --> 00:35:09,690
have a hardware available to them our

808
00:35:09,690 --> 00:35:12,390
approach was to try to enable a little

809
00:35:12,390 --> 00:35:14,310
bit more simulation of the system there

810
00:35:14,310 --> 00:35:16,500
obvious down pitfalls to that you can

811
00:35:16,500 --> 00:35:18,750
get really excited about some some some

812
00:35:18,750 --> 00:35:20,130
simulation that's just not really gonna

813
00:35:20,130 --> 00:35:23,550
work as well as you think but we wanted

814
00:35:23,550 --> 00:35:26,160
to do more than just the kernel because

815
00:35:26,160 --> 00:35:27,840
there's a lot of value there in running

816
00:35:27,840 --> 00:35:30,510
your precompiled binaries just plopping

817
00:35:30,510 --> 00:35:32,580
it right here and letting it rip and and

818
00:35:32,580 --> 00:35:34,650
you can do some profiling here you can

819
00:35:34,650 --> 00:35:34,829
do

820
00:35:34,829 --> 00:35:38,219
a lot of good things with qmu so we

821
00:35:38,219 --> 00:35:39,719
started with a pilot for model we got

822
00:35:39,719 --> 00:35:41,219
the processor up and running and then we

823
00:35:41,219 --> 00:35:42,869
started filling out some peripherals and

824
00:35:42,869 --> 00:35:44,700
you can see the green is what we've done

825
00:35:44,700 --> 00:35:48,029
the yellows sort of in progress in that

826
00:35:48,029 --> 00:35:50,279
we've done a lot of it enough of it for

827
00:35:50,279 --> 00:35:53,660
our internal stack to be able to boot

828
00:35:53,660 --> 00:35:58,499
and what's planned is you know in blue

829
00:35:58,499 --> 00:36:00,299
so we'd like to be able to fan it out

830
00:36:00,299 --> 00:36:01,769
more and you see that some of the system

831
00:36:01,769 --> 00:36:05,339
interfaces like kcs our plan so how do

832
00:36:05,339 --> 00:36:07,440
we go about in the host OS obviously

833
00:36:07,440 --> 00:36:09,599
we're not diving into running you feet

834
00:36:09,599 --> 00:36:11,910
on on qme without at least maybe that's

835
00:36:11,910 --> 00:36:14,339
not obvious but that's not where I would

836
00:36:14,339 --> 00:36:17,579
think we'd go this is for simulating the

837
00:36:17,579 --> 00:36:20,819
the BMC itself you can have all of the

838
00:36:20,819 --> 00:36:23,849
the backend of these peripherals go out

839
00:36:23,849 --> 00:36:26,130
to some socket server if you wish and

840
00:36:26,130 --> 00:36:27,329
then you can simulate your system

841
00:36:27,329 --> 00:36:31,559
however you want so some of the

842
00:36:31,559 --> 00:36:33,119
limitations that we had on the things

843
00:36:33,119 --> 00:36:36,049
that are in green for example are that

844
00:36:36,049 --> 00:36:40,319
we the the pilot for uses the tulip

845
00:36:40,319 --> 00:36:45,839
network controller we so instead of

846
00:36:45,839 --> 00:36:47,489
spending the time standing that up which

847
00:36:47,489 --> 00:36:50,219
is not supported in QEMU last the last I

848
00:36:50,219 --> 00:36:53,130
looked you know we can use the e 1000

849
00:36:53,130 --> 00:36:54,569
which is and that's just a matter of

850
00:36:54,569 --> 00:36:57,680
using a different driver in the kernel

851
00:36:57,680 --> 00:37:01,499
we did take the PWM attack and and route

852
00:37:01,499 --> 00:37:03,269
it out to an API this is what I was

853
00:37:03,269 --> 00:37:04,799
referring to earlier where you could go

854
00:37:04,799 --> 00:37:06,180
to a socket server and then simulate

855
00:37:06,180 --> 00:37:09,900
that with a dashboard if you want and

856
00:37:09,900 --> 00:37:12,180
whether that's a graphical dashboard or

857
00:37:12,180 --> 00:37:17,549
some automated test harness and I the

858
00:37:17,549 --> 00:37:18,989
reason I put that as a limitation is

859
00:37:18,989 --> 00:37:20,369
because I'm making the assumption that

860
00:37:20,369 --> 00:37:23,130
the PWM signals and the tax attack

861
00:37:23,130 --> 00:37:25,920
inputs are being used for like on a fan

862
00:37:25,920 --> 00:37:31,039
which might not always be the case and

863
00:37:31,039 --> 00:37:33,900
the ddr controller we didn't implement

864
00:37:33,900 --> 00:37:35,789
all the registers there that's just

865
00:37:35,789 --> 00:37:38,069
claiming i/o space enough to get us past

866
00:37:38,069 --> 00:37:41,640
ddr in it so we're picking our battles

867
00:37:41,640 --> 00:37:43,849
as to what we simulate which i think is

868
00:37:43,849 --> 00:37:46,979
a sane way to move forward we're not

869
00:37:46,979 --> 00:37:48,140
trying to read in

870
00:37:48,140 --> 00:37:50,140
laid everything at the register level

871
00:37:50,140 --> 00:37:52,610
you'll notice that one new block showed

872
00:37:52,610 --> 00:37:54,170
up there that wasn't in the pilot for

873
00:37:54,170 --> 00:37:55,910
block diagram and that's the system FPGA

874
00:37:55,910 --> 00:37:57,650
which is obviously not part of the pilot

875
00:37:57,650 --> 00:38:00,350
for so that is part of the this the qmu

876
00:38:00,350 --> 00:38:02,690
project as well that we're doing when we

877
00:38:02,690 --> 00:38:05,750
go into emulating the system so I'll

878
00:38:05,750 --> 00:38:11,510
move that on so we have preliminary

879
00:38:11,510 --> 00:38:14,030
support for this r9 50 in the SR 650 in

880
00:38:14,030 --> 00:38:18,400
our QEMU code base and we have the FPGA

881
00:38:18,400 --> 00:38:21,230
we communicate with FPGA over spy it's a

882
00:38:21,230 --> 00:38:23,210
it's not a terribly complicated protocol

883
00:38:23,210 --> 00:38:27,740
but it's it's fairly robust and and so

884
00:38:27,740 --> 00:38:29,600
all of that we've we've actually got

885
00:38:29,600 --> 00:38:32,240
modeled the FPGA itself and you can't

886
00:38:32,240 --> 00:38:33,670
really see this because it's so small

887
00:38:33,670 --> 00:38:37,070
but like I show the invocation for how

888
00:38:37,070 --> 00:38:41,000
we kick off the QEMU on the sr 950 with

889
00:38:41,000 --> 00:38:44,030
a pilot for using our xec code and then

890
00:38:44,030 --> 00:38:49,040
on the bottom using open BMC and really

891
00:38:49,040 --> 00:38:51,020
all we're doing there is changing the

892
00:38:51,020 --> 00:38:52,850
system because we have to have a

893
00:38:52,850 --> 00:38:55,280
different sized firearm and in the

894
00:38:55,280 --> 00:38:56,810
building blocks of the BMC that we're

895
00:38:56,810 --> 00:39:01,130
simulating but then also we we pass in

896
00:39:01,130 --> 00:39:05,000
the fpga def pj image it's the raw

897
00:39:05,000 --> 00:39:06,830
binary that we create for our fpga that

898
00:39:06,830 --> 00:39:08,690
we send to the manufacturing to flash on

899
00:39:08,690 --> 00:39:09,110
the chip

900
00:39:09,110 --> 00:39:11,810
I'm not simulating the FPGA by looking

901
00:39:11,810 --> 00:39:14,180
at the bin file right I'm looking inside

902
00:39:14,180 --> 00:39:15,950
the bin file for a signature basically

903
00:39:15,950 --> 00:39:18,050
and then and then the FPGA model and

904
00:39:18,050 --> 00:39:22,010
qemu is behaving accordingly so ideally

905
00:39:22,010 --> 00:39:23,510
if your model is thorough enough at a

906
00:39:23,510 --> 00:39:25,430
behavioral level then you can change the

907
00:39:25,430 --> 00:39:27,140
fpga image from version to version and

908
00:39:27,140 --> 00:39:28,640
your model will follow your response

909
00:39:28,640 --> 00:39:34,850
will follow yeah where are we with this

910
00:39:34,850 --> 00:39:37,340
unopened EMC I said we got our our

911
00:39:37,340 --> 00:39:42,050
internal firmware booting open BMC right

912
00:39:42,050 --> 00:39:43,430
now is hanging in new boots so we're in

913
00:39:43,430 --> 00:39:47,180
the middle of debugging that but you

914
00:39:47,180 --> 00:39:48,950
know debugging in qmu is pretty

915
00:39:48,950 --> 00:39:52,120
straightforward just a matter of time so

916
00:39:52,120 --> 00:39:56,420
our plan is to get that out to in that

917
00:39:56,420 --> 00:40:00,559
pilot for model in QEMU upstream

918
00:40:00,559 --> 00:40:02,299
when we get the kinks worked out so we

919
00:40:02,299 --> 00:40:04,459
have to we want to get open BMC booting

920
00:40:04,459 --> 00:40:05,749
all the way up and I think we're close

921
00:40:05,749 --> 00:40:07,519
on that because of all the other

922
00:40:07,519 --> 00:40:08,660
peripherals that are actually running

923
00:40:08,660 --> 00:40:10,459
and then we need a bit of a bit of

924
00:40:10,459 --> 00:40:13,640
cleanup I think I talked a little bit

925
00:40:13,640 --> 00:40:16,069
about some of the value of the qmu that

926
00:40:16,069 --> 00:40:19,099
what I found while while working on that

927
00:40:19,099 --> 00:40:22,130
port was right away we could see where

928
00:40:22,130 --> 00:40:23,930
there were a lot of wasted i/o cycles in

929
00:40:23,930 --> 00:40:26,299
our early startup code going out to

930
00:40:26,299 --> 00:40:29,479
registers more times than needed and you

931
00:40:29,479 --> 00:40:31,640
trace the code and find out why gosh

932
00:40:31,640 --> 00:40:33,709
we're calling this routine way too many

933
00:40:33,709 --> 00:40:36,109
times things you wouldn't notice if

934
00:40:36,109 --> 00:40:37,130
you're just going for functional

935
00:40:37,130 --> 00:40:41,959
correctness and you might not notice if

936
00:40:41,959 --> 00:40:44,119
you're just measuring time right because

937
00:40:44,119 --> 00:40:46,789
it's very fast to go through maybe spy

938
00:40:46,789 --> 00:40:48,739
initialization every time you go to the

939
00:40:48,739 --> 00:40:52,640
chip but you don't need to so it opens

940
00:40:52,640 --> 00:40:54,079
up your eyes to things that are doing if

941
00:40:54,079 --> 00:40:55,459
you start looking at things at the i/o

942
00:40:55,459 --> 00:40:57,289
level at the register i/o interaction

943
00:40:57,289 --> 00:41:00,979
level or the the bus interface level so

944
00:41:00,979 --> 00:41:02,479
if you tap into the spy bus and you can

945
00:41:02,479 --> 00:41:03,799
see the commands going back and forth on

946
00:41:03,799 --> 00:41:06,499
queuing yeah that's pretty useful you do

947
00:41:06,499 --> 00:41:09,049
snapshots with this so if you are

948
00:41:09,049 --> 00:41:12,920
simulating your system and you have a

949
00:41:12,920 --> 00:41:14,900
bug you could share that with other

950
00:41:14,900 --> 00:41:16,759
people right and then they can help you

951
00:41:16,759 --> 00:41:17,900
debug that problem they don't

952
00:41:17,900 --> 00:41:19,430
necessarily need the hardware that's

953
00:41:19,430 --> 00:41:20,569
assuming you can reproduce the problem

954
00:41:20,569 --> 00:41:25,670
with the simulator but that's one of the

955
00:41:25,670 --> 00:41:29,329
values of this another value and perhaps

956
00:41:29,329 --> 00:41:30,979
the primary reason that we wanted to go

957
00:41:30,979 --> 00:41:35,930
in here to get into qemu is resource

958
00:41:35,930 --> 00:41:38,329
limitations so we've got 512 megabytes

959
00:41:38,329 --> 00:41:41,420
of ddr4 solder down I'd love to run

960
00:41:41,420 --> 00:41:43,579
valgrind on some of our applications in

961
00:41:43,579 --> 00:41:46,249
the real real world obviously it's going

962
00:41:46,249 --> 00:41:47,359
to slow down a lot but you need a lot

963
00:41:47,359 --> 00:41:49,400
more memory to do that there are a lot

964
00:41:49,400 --> 00:41:51,259
of memory profilers we've thrown at our

965
00:41:51,259 --> 00:41:55,640
at our code right about if you want to

966
00:41:55,640 --> 00:41:58,519
throw many of them had it you need a lot

967
00:41:58,519 --> 00:42:03,920
more memory right so short of replacing

968
00:42:03,920 --> 00:42:08,449
that BGA ddr4 chip with a bigger one if

969
00:42:08,449 --> 00:42:10,969
you can get it running in qemu great and

970
00:42:10,969 --> 00:42:13,250
it's not really that hard to

971
00:42:13,250 --> 00:42:17,300
remember you have available to you in

972
00:42:17,300 --> 00:42:22,130
qmu let's see so and then as I mentioned

973
00:42:22,130 --> 00:42:24,110
earlier the lot of automation testing

974
00:42:24,110 --> 00:42:26,510
can be done at a lower level but just

975
00:42:26,510 --> 00:42:28,700
another caveat here to be careful what

976
00:42:28,700 --> 00:42:31,160
your expectations are time domains and

977
00:42:31,160 --> 00:42:34,040
simulations our problems your test

978
00:42:34,040 --> 00:42:36,140
harness has to be aware of a lot of

979
00:42:36,140 --> 00:42:39,440
those things so I think you just have

980
00:42:39,440 --> 00:42:42,140
the the word of caution is to just be

981
00:42:42,140 --> 00:42:43,670
mindful of what your gonna simulate and

982
00:42:43,670 --> 00:42:45,170
what the value of it is and before you

983
00:42:45,170 --> 00:42:46,730
spend too much time trying to write a

984
00:42:46,730 --> 00:42:48,860
model for something with hopes you're

985
00:42:48,860 --> 00:42:51,700
gonna get a lot of benefit out of it

986
00:42:51,700 --> 00:42:54,710
just think about a lot of that stuff up

987
00:42:54,710 --> 00:43:00,770
front that's pretty vague but we're not

988
00:43:00,770 --> 00:43:03,560
trying to do everything with this mall

989
00:43:03,560 --> 00:43:09,140
so what we'd like to do next is you know

990
00:43:09,140 --> 00:43:10,610
having said all of this stuff and shared

991
00:43:10,610 --> 00:43:12,530
with you what we've done so far you know

992
00:43:12,530 --> 00:43:16,730
enabling the pilot for on a variety of

993
00:43:16,730 --> 00:43:20,410
platforms right so in open BMC and QEMU

994
00:43:20,410 --> 00:43:24,890
is we'd like to you know being new to

995
00:43:24,890 --> 00:43:28,250
open BMC so I will try to sponsor well

996
00:43:28,250 --> 00:43:30,530
not try to but sponsor or begin a

997
00:43:30,530 --> 00:43:32,660
workgroup for the performance monitoring

998
00:43:32,660 --> 00:43:33,680
sounds like there might be some

999
00:43:33,680 --> 00:43:35,390
interesting comments so we can we can

1000
00:43:35,390 --> 00:43:39,620
work on here the as I mentioned earlier

1001
00:43:39,620 --> 00:43:42,200
being able to make use of the telemetry

1002
00:43:42,200 --> 00:43:44,480
for making this data available that's a

1003
00:43:44,480 --> 00:43:46,550
if it's just a file that you can pull

1004
00:43:46,550 --> 00:43:47,900
off externally and you don't necessarily

1005
00:43:47,900 --> 00:43:50,060
need the OEM IPMI command that's great

1006
00:43:50,060 --> 00:43:52,430
so we look forward to kind of partnering

1007
00:43:52,430 --> 00:43:54,680
with the telemetry guys on that the

1008
00:43:54,680 --> 00:43:58,310
multiline sensor support so enabling

1009
00:43:58,310 --> 00:44:03,500
that in open BMC would be a good thing

1010
00:44:03,500 --> 00:44:06,140
to have right so how many people are

1011
00:44:06,140 --> 00:44:08,300
doing that sort of lund solution today

1012
00:44:08,300 --> 00:44:11,750
in open BMC so we didn't see where where

1013
00:44:11,750 --> 00:44:13,130
you created the sensor that you could

1014
00:44:13,130 --> 00:44:14,840
actually specify the LUN its associated

1015
00:44:14,840 --> 00:44:21,470
with yeah yeah so we'd like to work on

1016
00:44:21,470 --> 00:44:23,570
trying to upstream something that the

1017
00:44:23,570 --> 00:44:26,530
community could benefit from

1018
00:44:29,410 --> 00:44:31,789
yeah perfect

1019
00:44:31,789 --> 00:44:39,170
Oh time oh-oh-oh-oh at the boundary of

1020
00:44:39,170 --> 00:44:50,989
this sensor limit yeah perfect okay yeah

1021
00:44:50,989 --> 00:44:55,549
okay thanks we talked I've done lots of

1022
00:44:55,549 --> 00:44:57,829
work on the a speed I'm a model upstream

1023
00:44:57,829 --> 00:45:00,140
and I do lots of kind of work for open

1024
00:45:00,140 --> 00:45:02,359
BMC in general and I used to come here a

1025
00:45:02,359 --> 00:45:04,700
lot it's it's great we write lots of

1026
00:45:04,700 --> 00:45:06,140
models for stuff that we don't have

1027
00:45:06,140 --> 00:45:09,109
silicon for we've bought the 2600 up in

1028
00:45:09,109 --> 00:45:11,239
comeyou before we had hardware and stuff

1029
00:45:11,239 --> 00:45:14,269
like that so yeah thanks for talking

1030
00:45:14,269 --> 00:45:17,690
about comeyou and how good it is just a

1031
00:45:17,690 --> 00:45:20,839
few comments you the ethernet driver i

1032
00:45:20,839 --> 00:45:22,759
model you're trying to do this PC ayah

1033
00:45:22,759 --> 00:45:24,829
so if you BMC doesn't have PCI you'll

1034
00:45:24,829 --> 00:45:26,749
have trouble okay come talk to me assets

1035
00:45:26,749 --> 00:45:29,059
I've got some ideas for you sure and

1036
00:45:29,059 --> 00:45:30,710
simply with you about hanging are using

1037
00:45:30,710 --> 00:45:32,479
upstream we're using the open BMC fork

1038
00:45:32,479 --> 00:45:36,950
we're using the the a speed off the a

1039
00:45:36,950 --> 00:45:38,450
speed repo that supports file for

1040
00:45:38,450 --> 00:45:41,239
because that's not upstream yet okay

1041
00:45:41,239 --> 00:45:43,190
cool Abbadon Singh which code base that

1042
00:45:43,190 --> 00:45:47,299
is yeah so that's I think off of what

1043
00:45:47,299 --> 00:45:49,489
Sud four one nine sorry I'm talking

1044
00:45:49,489 --> 00:45:50,719
about the KU mu brunch

1045
00:45:50,719 --> 00:45:52,940
well the Q mu branch oh yeah so I don't

1046
00:45:52,940 --> 00:45:54,019
remember the version number I should

1047
00:45:54,019 --> 00:45:55,460
have put that in the charts that's cool

1048
00:45:55,460 --> 00:45:58,880
I pulled it a while ago we updated who I

1049
00:45:58,880 --> 00:46:02,119
don't want to guess I can yeah

1050
00:46:02,119 --> 00:46:04,069
I see the FBI speak I'm a model that's

1051
00:46:04,069 --> 00:46:05,779
upstream is it's become pretty high

1052
00:46:05,779 --> 00:46:08,239
quality and the a the Kimmy maintainer

1053
00:46:08,239 --> 00:46:10,160
points to our model when he's telling

1054
00:46:10,160 --> 00:46:12,019
other people had a build a machine which

1055
00:46:12,019 --> 00:46:13,279
is good but it's also really annoying

1056
00:46:13,279 --> 00:46:14,509
when I'm trying to work out what to do

1057
00:46:14,509 --> 00:46:16,609
because there's no reference so yeah

1058
00:46:16,609 --> 00:46:17,599
that was one of the things we learned

1059
00:46:17,599 --> 00:46:19,910
with it was qemu is if you look there's

1060
00:46:19,910 --> 00:46:22,789
a variety of API is that I I suppose has

1061
00:46:22,789 --> 00:46:24,589
evolved over time and there's a lot of

1062
00:46:24,589 --> 00:46:28,489
machine implementations that use one or

1063
00:46:28,489 --> 00:46:32,359
the other of the the calls to

1064
00:46:32,359 --> 00:46:34,640
instantiate other components and so we

1065
00:46:34,640 --> 00:46:36,769
patterned it after the HP 2500

1066
00:46:36,769 --> 00:46:38,809
and which we found to be one of the more

1067
00:46:38,809 --> 00:46:39,170
mature

1068
00:46:39,170 --> 00:46:41,540
one's yeah spend a bit of time on that

1069
00:46:41,540 --> 00:46:45,140
it's very useful so the open BMC CI runs

1070
00:46:45,140 --> 00:46:47,900
against ku mu model for every clip that

1071
00:46:47,900 --> 00:46:50,510
goes in which is great when it passes

1072
00:46:50,510 --> 00:46:52,069
and it's really frustrating when someone

1073
00:46:52,069 --> 00:46:53,390
makes the kernel change that doesn't

1074
00:46:53,390 --> 00:46:55,190
support it but it's something we're

1075
00:46:55,190 --> 00:46:57,109
working through so thank you

1076
00:46:57,109 --> 00:47:14,240
great thank you well if the point is to

1077
00:47:14,240 --> 00:47:16,069
say that you can use an FPGA for

1078
00:47:16,069 --> 00:47:17,359
something like that right so your

1079
00:47:17,359 --> 00:47:19,010
implementation would be specific to you

1080
00:47:19,010 --> 00:47:20,510
all right

1081
00:47:20,510 --> 00:47:22,309
mostly what I'm trying to say in

1082
00:47:22,309 --> 00:47:24,349
introducing the FPGA at all is that it

1083
00:47:24,349 --> 00:47:25,549
was a bit of effort in order to get it

1084
00:47:25,549 --> 00:47:28,490
going with open BMC but that for

1085
00:47:28,490 --> 00:47:31,099
high-end systems like this

1086
00:47:31,099 --> 00:47:33,680
there's plenty of opportunity to offload

1087
00:47:33,680 --> 00:47:35,839
from the BMC onto something right so I

1088
00:47:35,839 --> 00:47:39,230
don't know I maybe one could predict

1089
00:47:39,230 --> 00:47:42,319
that FPGA czar may be more likely to

1090
00:47:42,319 --> 00:47:44,119
appear in the common building block

1091
00:47:44,119 --> 00:47:46,190
hardware that is a BMC that goes down

1092
00:47:46,190 --> 00:47:48,980
onto a server with that many iOS for the

1093
00:47:48,980 --> 00:47:51,890
RDS for example you need something right

1094
00:47:51,890 --> 00:48:08,510
faster than code in our particular case

1095
00:48:08,510 --> 00:48:10,520
that's what we do we go and we go talk

1096
00:48:10,520 --> 00:48:13,190
to the FPGA to get dem SPD and we pull

1097
00:48:13,190 --> 00:48:15,700
that it's very it's much faster yeah and

1098
00:48:15,700 --> 00:48:18,890
and where has the benefit of us not

1099
00:48:18,890 --> 00:48:21,740
being on the i2c bus playing playing

1100
00:48:21,740 --> 00:48:24,650
poorly with the CPU alright to see or at

1101
00:48:24,650 --> 00:48:26,480
some bus controller there's some

1102
00:48:26,480 --> 00:48:32,500
advantages okay thank you very much

1103
00:48:33,180 --> 00:48:35,840
[Applause]

1104
00:48:35,840 --> 00:48:43,490
[Music]

