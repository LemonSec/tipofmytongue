1
00:00:03,190 --> 00:00:06,259
[Music]

2
00:00:07,309 --> 00:00:11,429
so this is a both a security talk and a

3
00:00:11,429 --> 00:00:15,120
unit testing talk so I've filled you all

4
00:00:15,120 --> 00:00:17,250
into software quality by making this

5
00:00:17,250 --> 00:00:18,570
look like a security presentation

6
00:00:18,570 --> 00:00:19,890
congratulations it's a great way to

7
00:00:19,890 --> 00:00:23,070
start the morning what I want to talk

8
00:00:23,070 --> 00:00:26,220
about is primarily what firmware

9
00:00:26,220 --> 00:00:27,859
developers have to face when it comes to

10
00:00:27,859 --> 00:00:31,170
testing and verification look at the

11
00:00:31,170 --> 00:00:33,180
tools that we already have for driver

12
00:00:33,180 --> 00:00:35,610
and application developers primarily for

13
00:00:35,610 --> 00:00:38,430
UEFI introduce the concept host based

14
00:00:38,430 --> 00:00:41,010
firmware analysis talk about how we use

15
00:00:41,010 --> 00:00:43,100
this for techniques like fuzzing and

16
00:00:43,100 --> 00:00:45,360
show some examples of how we build and

17
00:00:45,360 --> 00:00:47,129
run test cases but what we have an open

18
00:00:47,129 --> 00:00:49,410
source oh yeah of course because of this

19
00:00:49,410 --> 00:00:51,559
conference this is an open source tool

20
00:00:51,559 --> 00:00:55,050
but first some of you know firmware very

21
00:00:55,050 --> 00:00:56,430
well some of you are just getting into

22
00:00:56,430 --> 00:00:58,850
it so I want to set a background for

23
00:00:58,850 --> 00:01:01,140
what a firmware developer has to deal

24
00:01:01,140 --> 00:01:03,329
with today I've been doing firmware

25
00:01:03,329 --> 00:01:05,850
development for an embarrassingly long

26
00:01:05,850 --> 00:01:08,909
amount of time starting out writing

27
00:01:08,909 --> 00:01:10,350
assembly code and explaining to people

28
00:01:10,350 --> 00:01:12,600
why they should use X or ax ax instead

29
00:01:12,600 --> 00:01:17,189
of moving ax 0 into ax yeah if you know

30
00:01:17,189 --> 00:01:18,900
the reason why been doing this as long

31
00:01:18,900 --> 00:01:21,900
as I have but flat platform firmware is

32
00:01:21,900 --> 00:01:23,220
an essential component and root of trust

33
00:01:23,220 --> 00:01:25,439
we're the thing that gets control after

34
00:01:25,439 --> 00:01:27,930
the reset vector you can have a really

35
00:01:27,930 --> 00:01:29,820
fun party between the reset vector and

36
00:01:29,820 --> 00:01:31,259
handing off to the OS so they want to

37
00:01:31,259 --> 00:01:33,180
make sure that this is the code that

38
00:01:33,180 --> 00:01:36,119
we're expecting to run it's a low-level

39
00:01:36,119 --> 00:01:38,460
component many of you are at this

40
00:01:38,460 --> 00:01:40,140
conference because you look at the

41
00:01:40,140 --> 00:01:41,340
current state of firmware and think

42
00:01:41,340 --> 00:01:43,290
there may be some security issues I

43
00:01:43,290 --> 00:01:45,899
would like to inspect yeah that's what

44
00:01:45,899 --> 00:01:48,570
every firmware developer is now thinking

45
00:01:48,570 --> 00:01:50,189
unfortunately most firmware validation

46
00:01:50,189 --> 00:01:52,680
happens at integration testing because

47
00:01:52,680 --> 00:01:55,259
it's tested as part of a platform not as

48
00:01:55,259 --> 00:01:59,430
an independent item so the usual way we

49
00:01:59,430 --> 00:02:01,680
do testing is we get the unit we plug

50
00:02:01,680 --> 00:02:03,420
everything into it and we do some kind

51
00:02:03,420 --> 00:02:06,600
of external input some sort of test

52
00:02:06,600 --> 00:02:07,520
harness or apparatus

53
00:02:07,520 --> 00:02:09,300
frankenstein-looking thing with cables

54
00:02:09,300 --> 00:02:10,800
all over it

55
00:02:10,800 --> 00:02:13,710
to test the firmware as

56
00:02:13,710 --> 00:02:16,410
a component not as okay well what makes

57
00:02:16,410 --> 00:02:19,350
up the firmware dozens possibly hundreds

58
00:02:19,350 --> 00:02:21,000
of little independent drivers that have

59
00:02:21,000 --> 00:02:22,650
been written not always by the same

60
00:02:22,650 --> 00:02:23,910
company not always by the same developer

61
00:02:23,910 --> 00:02:26,760
we put them in a big pile and if one of

62
00:02:26,760 --> 00:02:28,380
them fails we may not see the side

63
00:02:28,380 --> 00:02:30,480
effect of that until way into run time

64
00:02:30,480 --> 00:02:33,870
of the platform so we're going after

65
00:02:33,870 --> 00:02:37,080
functionality and stability but the way

66
00:02:37,080 --> 00:02:38,640
that we do integration testing you can't

67
00:02:38,640 --> 00:02:42,060
really figure out what the issue is with

68
00:02:42,060 --> 00:02:43,800
an independent component whether it's

69
00:02:43,800 --> 00:02:45,630
something you developed and hand it off

70
00:02:45,630 --> 00:02:47,070
to a team for integration or whether

71
00:02:47,070 --> 00:02:48,270
it's something you absorb from a third

72
00:02:48,270 --> 00:02:50,100
party or a different open source project

73
00:02:50,100 --> 00:02:53,940
so I look at software release in kind of

74
00:02:53,940 --> 00:02:56,010
two ways when you say you're releasing

75
00:02:56,010 --> 00:02:57,450
software you're are you releasing doves

76
00:02:57,450 --> 00:02:59,700
at the Olympics or is a bear being

77
00:02:59,700 --> 00:03:02,130
released from the zoo like one of these

78
00:03:02,130 --> 00:03:06,480
is obviously better than the other okay

79
00:03:06,480 --> 00:03:09,750
so our dependency on integration there

80
00:03:09,750 --> 00:03:11,070
are a lot of tools that we use that are

81
00:03:11,070 --> 00:03:14,040
focused on integration testing some of

82
00:03:14,040 --> 00:03:15,060
the folks in the back of the room work

83
00:03:15,060 --> 00:03:17,880
on test harnesses I see you guys

84
00:03:17,880 --> 00:03:19,440
those are pretty fun but if you're

85
00:03:19,440 --> 00:03:22,440
looking at security one of the few tools

86
00:03:22,440 --> 00:03:25,230
that we have this chip SEC so chip SEC

87
00:03:25,230 --> 00:03:27,300
is essentially a open source framework

88
00:03:27,300 --> 00:03:29,520
for analyzing the security of a platform

89
00:03:29,520 --> 00:03:32,100
firmware and hardware treats them as

90
00:03:32,100 --> 00:03:35,670
kind of codependent components but it

91
00:03:35,670 --> 00:03:37,560
evaluates the system condition at one

92
00:03:37,560 --> 00:03:40,890
time not the underlying code so chipset

93
00:03:40,890 --> 00:03:43,860
can tell you I set the bit correctly it

94
00:03:43,860 --> 00:03:45,690
can't tell you if you set the bit in the

95
00:03:45,690 --> 00:03:49,140
most optimal way so what most people

96
00:03:49,140 --> 00:03:50,640
exploit is not the setting of the bit

97
00:03:50,640 --> 00:03:54,270
but it's how you set the bit so it's

98
00:03:54,270 --> 00:03:56,040
really expensive to mitigate issues in

99
00:03:56,040 --> 00:03:57,270
integration by the time you get to

100
00:03:57,270 --> 00:03:59,580
integration you're possibly into what

101
00:03:59,580 --> 00:04:01,170
you optimistically are calling a beta

102
00:04:01,170 --> 00:04:02,730
which is probably really still an alpha

103
00:04:02,730 --> 00:04:04,500
but we'll call it a beta just to be nice

104
00:04:04,500 --> 00:04:07,050
to everybody and then you do most of

105
00:04:07,050 --> 00:04:08,520
your testing on that if you find

106
00:04:08,520 --> 00:04:10,410
something at that phase it's way more

107
00:04:10,410 --> 00:04:13,140
expensive to go back and isolate down to

108
00:04:13,140 --> 00:04:14,910
the single driver than it is to test

109
00:04:14,910 --> 00:04:17,310
that driver independently before you

110
00:04:17,310 --> 00:04:18,899
integrate it and it disappears into a

111
00:04:18,899 --> 00:04:22,740
mass of other code so can we improve our

112
00:04:22,740 --> 00:04:24,990
testing before integration well of

113
00:04:24,990 --> 00:04:26,310
course we can't otherwise this would be

114
00:04:26,310 --> 00:04:27,270
really short presentation

115
00:04:27,270 --> 00:04:30,840
but turns out application developers

116
00:04:30,840 --> 00:04:32,550
have done this for years this is not a

117
00:04:32,550 --> 00:04:34,560
new thing we're getting into somebody in

118
00:04:34,560 --> 00:04:37,379
Windows or Linux land will have said of

119
00:04:37,379 --> 00:04:39,780
course I tested my driver in isolation

120
00:04:39,780 --> 00:04:40,949
before I give it to the rest of the

121
00:04:40,949 --> 00:04:42,720
world because I'm in an upper-level

122
00:04:42,720 --> 00:04:45,150
application environment so I can do cool

123
00:04:45,150 --> 00:04:48,259
things like fuzzing guy walks into a bar

124
00:04:48,259 --> 00:04:51,440
two guys walk into a bar

125
00:04:51,440 --> 00:04:54,030
you know priest a rabbi and a monk walk

126
00:04:54,030 --> 00:04:56,789
into a bar negative one people walk into

127
00:04:56,789 --> 00:05:00,840
a bar X F F F people walk into a bar

128
00:05:00,840 --> 00:05:03,720
right so there's your edge cases on

129
00:05:03,720 --> 00:05:05,610
fuzzing no integration is a guy walks

130
00:05:05,610 --> 00:05:06,840
into a bar ask you what time it is and

131
00:05:06,840 --> 00:05:07,800
the bar burns down

132
00:05:07,800 --> 00:05:10,259
so you still do integration testing but

133
00:05:10,259 --> 00:05:13,289
you can do basic things on fuzz testing

134
00:05:13,289 --> 00:05:15,960
that just threw garbage inputs and that

135
00:05:15,960 --> 00:05:17,340
by the way is how we get most of our

136
00:05:17,340 --> 00:05:19,380
friendly little buffer overflows and

137
00:05:19,380 --> 00:05:25,229
memory issues address sanitizing so this

138
00:05:25,229 --> 00:05:26,370
is another way to detect memory

139
00:05:26,370 --> 00:05:28,680
corruption issues which is another fun

140
00:05:28,680 --> 00:05:31,199
way that people try to get into the

141
00:05:31,199 --> 00:05:32,280
world of firmware they'll corrupt

142
00:05:32,280 --> 00:05:34,500
variables they'll throw random garbage

143
00:05:34,500 --> 00:05:36,900
to try to force asserts or get you down

144
00:05:36,900 --> 00:05:38,520
into edge cases that you haven't fully

145
00:05:38,520 --> 00:05:42,360
tested code coverage did you really test

146
00:05:42,360 --> 00:05:44,550
all the code you have a switch that says

147
00:05:44,550 --> 00:05:48,330
on if you test it off you have a switch

148
00:05:48,330 --> 00:05:51,599
that uses on/off and other did you test

149
00:05:51,599 --> 00:05:54,270
other you did all the ifs did you do all

150
00:05:54,270 --> 00:05:55,979
the else's code coverage will allow you

151
00:05:55,979 --> 00:05:57,840
to look at your test cases and see if

152
00:05:57,840 --> 00:05:59,909
they are actually measuring everything

153
00:05:59,909 --> 00:06:02,639
that you do now these are very easy to

154
00:06:02,639 --> 00:06:04,529
do in an operating system compared to

155
00:06:04,529 --> 00:06:07,680
firmware so because an application

156
00:06:07,680 --> 00:06:09,150
developer will say oh I've got this OS

157
00:06:09,150 --> 00:06:11,340
layer underneath and I can use that to

158
00:06:11,340 --> 00:06:13,529
expose all of these inputs API

159
00:06:13,529 --> 00:06:16,650
interfaces that I can put into fuzzing

160
00:06:16,650 --> 00:06:19,830
firmwares existing at a quasi hardware

161
00:06:19,830 --> 00:06:21,180
level and it's harder to get those

162
00:06:21,180 --> 00:06:23,159
pieces in place so this is something

163
00:06:23,159 --> 00:06:28,289
we've run into a lot at Intel so I'm

164
00:06:28,289 --> 00:06:30,389
gonna focus more on fuzzing as a test

165
00:06:30,389 --> 00:06:33,120
approach there's tons of other cases

166
00:06:33,120 --> 00:06:34,979
just you can do but it's a 30-minute

167
00:06:34,979 --> 00:06:37,949
presentation so an effective fuzzer will

168
00:06:37,949 --> 00:06:40,560
do semi valid inputs

169
00:06:40,560 --> 00:06:43,410
something that looks just right enough

170
00:06:43,410 --> 00:06:45,780
to be passed on by the program but

171
00:06:45,780 --> 00:06:47,810
hopefully the program doesn't do

172
00:06:47,810 --> 00:06:50,370
validation right one of the problems

173
00:06:50,370 --> 00:06:51,690
that we've had from the nine set of

174
00:06:51,690 --> 00:06:54,990
older firmware developers is that this

175
00:06:54,990 --> 00:06:56,820
is my tres pantry the flash part is my

176
00:06:56,820 --> 00:06:58,410
truss boundary anything that happens in

177
00:06:58,410 --> 00:07:00,630
here I must validate it I trust all the

178
00:07:00,630 --> 00:07:03,120
people involved in it in the 80s

179
00:07:03,120 --> 00:07:05,760
probably those are six people at your

180
00:07:05,760 --> 00:07:07,260
company they did firmware they all sat

181
00:07:07,260 --> 00:07:08,550
in the same room they probably all wore

182
00:07:08,550 --> 00:07:10,290
the same polo shirt from the trade same

183
00:07:10,290 --> 00:07:12,540
tradeshow they went to but you get up

184
00:07:12,540 --> 00:07:14,460
into firmware development now and I

185
00:07:14,460 --> 00:07:16,590
bought a Nick from one company I got a

186
00:07:16,590 --> 00:07:19,020
cop driver for my graphics company and

187
00:07:19,020 --> 00:07:21,960
then my department has folks in three

188
00:07:21,960 --> 00:07:25,980
countries so I can't always assume

189
00:07:25,980 --> 00:07:27,660
there's a trust boundary on that then we

190
00:07:27,660 --> 00:07:29,190
get a supply chain and that's a whole

191
00:07:29,190 --> 00:07:34,410
different problem so you have again from

192
00:07:34,410 --> 00:07:36,810
the OS environment things like aflp CH

193
00:07:36,810 --> 00:07:40,380
lib buzzer that go into let me let me

194
00:07:40,380 --> 00:07:42,060
throw random inputs at this and make

195
00:07:42,060 --> 00:07:44,280
sure that it is trusted before I

196
00:07:44,280 --> 00:07:49,260
integrate it into a piece so AFL against

197
00:07:49,260 --> 00:07:50,960
very security oriented fuzzer

198
00:07:50,960 --> 00:07:53,760
it works across a variety of operating

199
00:07:53,760 --> 00:07:56,610
systems it's patchy licensed so it uses

200
00:07:56,610 --> 00:07:58,919
compile time instrumentation genetic

201
00:07:58,919 --> 00:08:00,510
algorithms I'm not gonna pretend to

202
00:08:00,510 --> 00:08:02,910
understand that I got my master's degree

203
00:08:02,910 --> 00:08:05,550
a long time ago but you're trying to

204
00:08:05,550 --> 00:08:07,860
find test cases that trigger what they

205
00:08:07,860 --> 00:08:09,780
call politely new internal states and

206
00:08:09,780 --> 00:08:12,630
the target binaries in other words edge

207
00:08:12,630 --> 00:08:13,229
cases

208
00:08:13,229 --> 00:08:16,530
stuff you didn't test and the idea is

209
00:08:16,530 --> 00:08:17,700
that you're improving your functional

210
00:08:17,700 --> 00:08:21,840
coverage for what you're testing peach

211
00:08:21,840 --> 00:08:25,440
is more known as a smart fuzzer so it's

212
00:08:25,440 --> 00:08:27,210
mutation based testing it takes the

213
00:08:27,210 --> 00:08:28,979
cases you build and starts to build its

214
00:08:28,979 --> 00:08:32,610
own edge cases around it so it's going

215
00:08:32,610 --> 00:08:34,200
to attempt to do things that you don't

216
00:08:34,200 --> 00:08:35,610
think of I don't know how many of you

217
00:08:35,610 --> 00:08:37,710
actually your security folks who deal

218
00:08:37,710 --> 00:08:39,240
with developers or developers to deal

219
00:08:39,240 --> 00:08:41,309
with security folks but you all think

220
00:08:41,309 --> 00:08:44,190
differently security folks think in a

221
00:08:44,190 --> 00:08:46,350
way of here's this box and I don't know

222
00:08:46,350 --> 00:08:48,260
where to put the crowbar to pry it open

223
00:08:48,260 --> 00:08:50,220
right there's a completely different

224
00:08:50,220 --> 00:08:51,660
approach for that and something like a

225
00:08:51,660 --> 00:08:53,580
mutation based buzzer

226
00:08:53,580 --> 00:08:55,560
means that you're testing people don't

227
00:08:55,560 --> 00:08:57,090
have to think about every edge case it

228
00:08:57,090 --> 00:08:59,970
tries to create them it tries to create

229
00:08:59,970 --> 00:09:02,190
input that will trigger edge cases based

230
00:09:02,190 --> 00:09:05,100
on what you fed it makes a thing called

231
00:09:05,100 --> 00:09:07,560
a peach pit file which is an XML file it

232
00:09:07,560 --> 00:09:09,810
defines the structure now this is an MIT

233
00:09:09,810 --> 00:09:14,760
license tool lib buzzer kind of works

234
00:09:14,760 --> 00:09:18,330
off of LLVM compiler infrastructure LLVM

235
00:09:18,330 --> 00:09:19,880
is very good at adding things like

236
00:09:19,880 --> 00:09:23,730
sanitization coverage so this is coming

237
00:09:23,730 --> 00:09:27,690
up with inputs for target functions that

238
00:09:27,690 --> 00:09:28,980
are based on this so this is where you

239
00:09:28,980 --> 00:09:32,450
find a heap stack and global issues

240
00:09:32,450 --> 00:09:33,780
memory leaks

241
00:09:33,780 --> 00:09:37,230
so you allocated memory you didn't free

242
00:09:37,230 --> 00:09:40,290
memory assembly code to see programmers

243
00:09:40,290 --> 00:09:41,700
people that have gone from the legacy

244
00:09:41,700 --> 00:09:46,410
BIOS to UEFI days assembly programmers

245
00:09:46,410 --> 00:09:47,850
never had to allocate memory we were

246
00:09:47,850 --> 00:09:49,500
just like there's memory it's at this

247
00:09:49,500 --> 00:09:52,950
fixed address upper level application

248
00:09:52,950 --> 00:09:55,050
programmers people been doing C++ for a

249
00:09:55,050 --> 00:09:57,000
while understand these concepts better

250
00:09:57,000 --> 00:10:00,120
so you will find a lot more of these I

251
00:10:00,120 --> 00:10:02,670
made memory at it and take memory away

252
00:10:02,670 --> 00:10:04,830
I didn't free my and clean up my after

253
00:10:04,830 --> 00:10:08,430
myself kind of issues in firmware all

254
00:10:08,430 --> 00:10:08,760
right

255
00:10:08,760 --> 00:10:10,910
these are cool upper-level OS tools

256
00:10:10,910 --> 00:10:12,750
let's try to put them in a firmware

257
00:10:12,750 --> 00:10:15,750
environment so turns out a couple years

258
00:10:15,750 --> 00:10:19,320
ago some very smart people at my very

259
00:10:19,320 --> 00:10:22,050
large fortune 500 company tried this the

260
00:10:22,050 --> 00:10:25,170
short answer is it's really hard getting

261
00:10:25,170 --> 00:10:25,950
something that's designed for

262
00:10:25,950 --> 00:10:29,370
multi-threaded OS environment down into

263
00:10:29,370 --> 00:10:33,930
firmware it'll work but it's the polite

264
00:10:33,930 --> 00:10:34,830
word at this time in the morning

265
00:10:34,830 --> 00:10:37,710
professional setting a suboptimal it was

266
00:10:37,710 --> 00:10:38,970
not good

267
00:10:38,970 --> 00:10:41,520
okay well let's flip this over we've

268
00:10:41,520 --> 00:10:43,400
already been running UEFI code in

269
00:10:43,400 --> 00:10:46,590
simulators we've got qmu we've got

270
00:10:46,590 --> 00:10:48,210
commercial stuff that we use it intel

271
00:10:48,210 --> 00:10:50,520
likes MX maybe we do a simulation

272
00:10:50,520 --> 00:10:52,290
environment again simulation

273
00:10:52,290 --> 00:10:53,700
environments are more for simulating a

274
00:10:53,700 --> 00:10:55,530
system so that's more of an integration

275
00:10:55,530 --> 00:10:58,830
idea okay well what if we well this is

276
00:10:58,830 --> 00:11:00,840
just a driver it's just a set of API so

277
00:11:00,840 --> 00:11:01,830
I don't want to see if the code is

278
00:11:01,830 --> 00:11:05,430
functional I'm trying to do edge case

279
00:11:05,430 --> 00:11:07,290
testing I really want to test just the

280
00:11:07,290 --> 00:11:10,699
ins and outs again I'm not looking at

281
00:11:10,699 --> 00:11:13,019
can I set a bid on a piece of hardware

282
00:11:13,019 --> 00:11:15,000
at this phase of testing I'm looking at

283
00:11:15,000 --> 00:11:18,240
does the API have established in this

284
00:11:18,240 --> 00:11:20,430
firmware interface do input and output

285
00:11:20,430 --> 00:11:23,730
correctly does it you know check who's

286
00:11:23,730 --> 00:11:24,630
coming in the door

287
00:11:24,630 --> 00:11:26,490
you know they open up the velvet rope at

288
00:11:26,490 --> 00:11:30,839
the club for the right people so again

289
00:11:30,839 --> 00:11:32,339
what we're trying to do is just test

290
00:11:32,339 --> 00:11:34,319
this native UEFI code if it's not gonna

291
00:11:34,319 --> 00:11:36,720
touch the hardware then why don't we

292
00:11:36,720 --> 00:11:38,459
just stub it out and make it so that

293
00:11:38,459 --> 00:11:41,279
these existing test apparatus that work

294
00:11:41,279 --> 00:11:43,529
for the OS work on this individual unit

295
00:11:43,529 --> 00:11:45,449
test not gonna find a hundred percent of

296
00:11:45,449 --> 00:11:47,970
the problems but you will find that

297
00:11:47,970 --> 00:11:49,620
stupid piece of code that doesn't call

298
00:11:49,620 --> 00:11:52,949
in de package correctly so this allows

299
00:11:52,949 --> 00:11:54,420
you V Phi code to be tested on the

300
00:11:54,420 --> 00:11:56,399
developer system hence post based not

301
00:11:56,399 --> 00:12:01,680
target based so same smart people went

302
00:12:01,680 --> 00:12:03,329
off and made a tool called host based

303
00:12:03,329 --> 00:12:05,910
firmer analyzer this has been out in

304
00:12:05,910 --> 00:12:07,800
open source for a bit when announced

305
00:12:07,800 --> 00:12:11,279
this at RSA 2019 we put the first code

306
00:12:11,279 --> 00:12:14,160
up in a repo I think in April it's in

307
00:12:14,160 --> 00:12:16,260
the UK to staging repo links at the back

308
00:12:16,260 --> 00:12:19,740
of the presentation but the idea is that

309
00:12:19,740 --> 00:12:22,940
we've created a set of interfaces and a

310
00:12:22,940 --> 00:12:26,699
way to stub out et k2 code that allows

311
00:12:26,699 --> 00:12:29,760
you to run existing tools including

312
00:12:29,760 --> 00:12:35,279
fuzzing address sanitization and we

313
00:12:35,279 --> 00:12:36,690
create a database of unit test cases

314
00:12:36,690 --> 00:12:38,940
which a lot of unit test cases we're

315
00:12:38,940 --> 00:12:40,740
using are just up in the repo with

316
00:12:40,740 --> 00:12:45,000
everything else and we're using really

317
00:12:45,000 --> 00:12:47,190
what this is designed to do is say we're

318
00:12:47,190 --> 00:12:48,810
not reinventing the wheel on this other

319
00:12:48,810 --> 00:12:51,000
people have done fuzz testing address

320
00:12:51,000 --> 00:12:52,560
sanitizers better than we have and

321
00:12:52,560 --> 00:12:54,779
firmware let's just go take that stuff

322
00:12:54,779 --> 00:12:57,600
and use it on what we're doing so it's

323
00:12:57,600 --> 00:12:59,339
not a tool it's really more of a

324
00:12:59,339 --> 00:13:00,449
framework where you can run

325
00:13:00,449 --> 00:13:02,370
best-in-class tools from other people

326
00:13:02,370 --> 00:13:03,870
something else comes along that does a

327
00:13:03,870 --> 00:13:05,730
cool thing we're not doing there's a way

328
00:13:05,730 --> 00:13:07,259
to stub that out and put it into this

329
00:13:07,259 --> 00:13:13,079
framework so again we're moving some of

330
00:13:13,079 --> 00:13:16,770
the unit testing to an OS environment

331
00:13:16,770 --> 00:13:18,840
this doesn't get you off the hook for

332
00:13:18,840 --> 00:13:21,960
testing your own code on a platform but

333
00:13:21,960 --> 00:13:24,240
it does come up with cases that you

334
00:13:24,240 --> 00:13:26,010
would have trouble isolating on a

335
00:13:26,010 --> 00:13:27,780
platform when they when you encounter

336
00:13:27,780 --> 00:13:32,430
them so OS based tools typically have

337
00:13:32,430 --> 00:13:35,070
native code coverage support we can take

338
00:13:35,070 --> 00:13:37,170
advantage of that as well the question

339
00:13:37,170 --> 00:13:40,290
is what cannon can't be tested in this

340
00:13:40,290 --> 00:13:42,600
environment the stuff that is optimal

341
00:13:42,600 --> 00:13:44,700
for testing an OS environment or

342
00:13:44,700 --> 00:13:45,870
features that are based purely on

343
00:13:45,870 --> 00:13:49,140
software logic not UEFI or architecture

344
00:13:49,140 --> 00:13:52,350
dependencies so I'm gonna pass my boot

345
00:13:52,350 --> 00:13:58,440
logo as BMP into the into the BMP parser

346
00:13:58,440 --> 00:13:59,610
so that it displays the logo on the

347
00:13:59,610 --> 00:14:00,900
screen you get a little spinny wheel

348
00:14:00,900 --> 00:14:02,070
underneath and when you start loading

349
00:14:02,070 --> 00:14:04,140
the OS okay

350
00:14:04,140 --> 00:14:07,050
well people have abused that there's no

351
00:14:07,050 --> 00:14:11,130
cases where people passed in a BMP and

352
00:14:11,130 --> 00:14:13,740
it tried to execute code so that's one

353
00:14:13,740 --> 00:14:14,910
that doesn't depend on anything in the

354
00:14:14,910 --> 00:14:16,230
hardware it's purely software logic

355
00:14:16,230 --> 00:14:18,480
that's a great case to test in this

356
00:14:18,480 --> 00:14:21,720
environment you if I cut that it's good

357
00:14:21,720 --> 00:14:25,890
modularity actually I know some of you

358
00:14:25,890 --> 00:14:26,910
in the audience will be shocked people

359
00:14:26,910 --> 00:14:28,680
can write really good module you if I

360
00:14:28,680 --> 00:14:31,110
code not everyone which is why we still

361
00:14:31,110 --> 00:14:34,200
have unit testing but things that follow

362
00:14:34,200 --> 00:14:35,850
more of the boundaries we set up in 80

363
00:14:35,850 --> 00:14:37,830
key to that are more portable pieces of

364
00:14:37,830 --> 00:14:40,950
code and some features of hardware

365
00:14:40,950 --> 00:14:43,740
dependency so mmt our settings PCI

366
00:14:43,740 --> 00:14:47,130
Express bus access USB hardware that's

367
00:14:47,130 --> 00:14:49,830
not going to work great in this

368
00:14:49,830 --> 00:14:52,290
environment but they require some code

369
00:14:52,290 --> 00:14:54,240
steps to eliminate dependencies so you

370
00:14:54,240 --> 00:14:55,500
still want to be able to see if your

371
00:14:55,500 --> 00:14:56,970
input gets passed correctly to a

372
00:14:56,970 --> 00:14:59,010
function that sets an MTR are because

373
00:14:59,010 --> 00:15:00,840
that's something that's abusable but

374
00:15:00,840 --> 00:15:03,600
don't expect your system to set that MTR

375
00:15:03,600 --> 00:15:05,760
are in a host environment in fact please

376
00:15:05,760 --> 00:15:07,080
make sure you don't do that because I

377
00:15:07,080 --> 00:15:10,220
don't want to crash your host system

378
00:15:11,000 --> 00:15:13,470
okay again I'm gonna focus more on fuss

379
00:15:13,470 --> 00:15:16,080
testing here there's seven or eight

380
00:15:16,080 --> 00:15:17,730
different packages that you can put into

381
00:15:17,730 --> 00:15:20,780
a host-based firmer analysis or hbf a

382
00:15:20,780 --> 00:15:24,300
but again bad way to wake up is to have

383
00:15:24,300 --> 00:15:26,370
me read documents at you so let's just

384
00:15:26,370 --> 00:15:29,280
look at fuzz test casting fuzz test case

385
00:15:29,280 --> 00:15:31,420
design

386
00:15:31,420 --> 00:15:34,449
so within the framework of HP FA you

387
00:15:34,449 --> 00:15:36,970
have a test case folder called test case

388
00:15:36,970 --> 00:15:39,100
it sits under a directory that is

389
00:15:39,100 --> 00:15:42,130
obviously for fuzzing there's a tool

390
00:15:42,130 --> 00:15:44,079
chain hardest library that goes into the

391
00:15:44,079 --> 00:15:45,610
library class if you're not familiar

392
00:15:45,610 --> 00:15:49,089
with ET k2 we use INF files to define

393
00:15:49,089 --> 00:15:51,819
the basically the needs and wants of the

394
00:15:51,819 --> 00:15:54,100
compiler for making a dot efi file that

395
00:15:54,100 --> 00:15:55,420
is spit out for that particular

396
00:15:55,420 --> 00:15:58,360
component we're not looking at the d c--

397
00:15:58,360 --> 00:16:01,029
or DSC things that you need to build an

398
00:16:01,029 --> 00:16:03,910
entire to our firmware image we're just

399
00:16:03,910 --> 00:16:06,220
looking at the DSC and INF files that

400
00:16:06,220 --> 00:16:08,050
you need to build one individual

401
00:16:08,050 --> 00:16:11,500
component there are three functions that

402
00:16:11,500 --> 00:16:13,990
need to be implemented get max buffer

403
00:16:13,990 --> 00:16:15,399
size run test harness and there's an

404
00:16:15,399 --> 00:16:17,529
optional fix buffer I will assume that

405
00:16:17,529 --> 00:16:20,889
your program is intelligently and

406
00:16:20,889 --> 00:16:24,279
obviously named test why why why never

407
00:16:24,279 --> 00:16:27,490
name real code that sort of thing but

408
00:16:27,490 --> 00:16:29,470
once you have created these three

409
00:16:29,470 --> 00:16:31,569
functions for this component then you

410
00:16:31,569 --> 00:16:35,069
add an entry in the INF file to use the

411
00:16:35,069 --> 00:16:38,860
host fuzz test case package this of

412
00:16:38,860 --> 00:16:40,510
course is just me reading a portion of

413
00:16:40,510 --> 00:16:42,220
the wiki yes we did actually document

414
00:16:42,220 --> 00:16:44,440
some of the stuff right now a lot of the

415
00:16:44,440 --> 00:16:45,910
documentation is in one of the developer

416
00:16:45,910 --> 00:16:48,339
staging branches but we're folding this

417
00:16:48,339 --> 00:16:51,279
back into the main documentation for HB

418
00:16:51,279 --> 00:16:58,420
fa okay here's us steering a code ooh

419
00:16:58,420 --> 00:17:00,040
this really doesn't look that impressive

420
00:17:00,040 --> 00:17:02,050
when I'm developing presenting to a

421
00:17:02,050 --> 00:17:04,599
rumor developers but it is something you

422
00:17:04,599 --> 00:17:05,709
can look at the slides will be available

423
00:17:05,709 --> 00:17:09,480
along with the video on the OSF C site

424
00:17:09,480 --> 00:17:13,720
but again what we're doing is roughly

425
00:17:13,720 --> 00:17:15,549
initializing a test before running that

426
00:17:15,549 --> 00:17:16,869
test case and cleaning up after

427
00:17:16,869 --> 00:17:20,399
ourselves because we're good adults

428
00:17:21,900 --> 00:17:25,179
again you have to do three additional

429
00:17:25,179 --> 00:17:26,890
functions this is why is great for unit

430
00:17:26,890 --> 00:17:28,419
testing this is terrible to do an

431
00:17:28,419 --> 00:17:29,620
integration we're not gonna leave these

432
00:17:29,620 --> 00:17:31,900
things in when we actually deliver our

433
00:17:31,900 --> 00:17:35,230
code to the integration team but we do

434
00:17:35,230 --> 00:17:37,240
want to make sure that we've got this

435
00:17:37,240 --> 00:17:39,190
sort of repeatable set of functions that

436
00:17:39,190 --> 00:17:41,080
can be dropped in for stepping once

437
00:17:41,080 --> 00:17:42,370
you've done this fuzz testing a couple

438
00:17:42,370 --> 00:17:43,160
of times

439
00:17:43,160 --> 00:17:45,380
in early development and unit testing it

440
00:17:45,380 --> 00:17:53,570
easily drops out and then again there's

441
00:17:53,570 --> 00:17:55,970
this additional testing partitioned etsy

442
00:17:55,970 --> 00:18:02,200
file all right so for the case of

443
00:18:02,200 --> 00:18:04,070
fuzzing if we're using something like a

444
00:18:04,070 --> 00:18:07,000
FL Lib fuzzer or peach

445
00:18:07,000 --> 00:18:09,500
we're basically have an entry point into

446
00:18:09,500 --> 00:18:11,840
tool chain harness function the fuzzing

447
00:18:11,840 --> 00:18:14,870
framework will feed garbage semi garbage

448
00:18:14,870 --> 00:18:17,900
inputs in they will trigger the function

449
00:18:17,900 --> 00:18:22,520
to be tested set up the function record

450
00:18:22,520 --> 00:18:23,990
and measure the results and return a

451
00:18:23,990 --> 00:18:27,770
test report this tool spits out a lot of

452
00:18:27,770 --> 00:18:30,680
information but it's really easy to go

453
00:18:30,680 --> 00:18:31,640
through and see where you've got

454
00:18:31,640 --> 00:18:33,050
potentially failing cases from the

455
00:18:33,050 --> 00:18:40,040
different test tools there is a GUI way

456
00:18:40,040 --> 00:18:42,950
of running the tests you add hbf a to

457
00:18:42,950 --> 00:18:44,600
your packages path that's part of your

458
00:18:44,600 --> 00:18:47,930
edk to environment setup you'll set up

459
00:18:47,930 --> 00:18:50,780
the UDK build environment for Linux

460
00:18:50,780 --> 00:18:55,160
windows there's a Python script that you

461
00:18:55,160 --> 00:18:56,960
run to generate the configuration with a

462
00:18:56,960 --> 00:18:58,970
new tool chain that'll set up the host

463
00:18:58,970 --> 00:19:02,570
test host buzz test package it's really

464
00:19:02,570 --> 00:19:03,950
hard to read camelcase in the morning

465
00:19:03,950 --> 00:19:07,250
and then you run a Python script that

466
00:19:07,250 --> 00:19:09,530
starts the GUI and then the GUI allows

467
00:19:09,530 --> 00:19:11,020
you to select the different test cases

468
00:19:11,020 --> 00:19:14,540
this depends entirely on which test

469
00:19:14,540 --> 00:19:16,940
apparatus you've installed you have the

470
00:19:16,940 --> 00:19:18,620
option of installing every single thing

471
00:19:18,620 --> 00:19:21,380
that HP FA supports or just doing a

472
00:19:21,380 --> 00:19:27,680
subset test reproductions again we spit

473
00:19:27,680 --> 00:19:30,470
out lots o data failure inputs are

474
00:19:30,470 --> 00:19:31,910
automatically recorded by the fuzzing

475
00:19:31,910 --> 00:19:35,390
frameworks AFL AFL peach and lip fuzz

476
00:19:35,390 --> 00:19:37,520
have a different directory structure so

477
00:19:37,520 --> 00:19:41,390
AFL has two main output files or folders

478
00:19:41,390 --> 00:19:43,210
one is for crashes and one is for hangs

479
00:19:43,210 --> 00:19:46,670
so crashes is the Avis obviously went

480
00:19:46,670 --> 00:19:48,290
off the rails and hangs is it went so

481
00:19:48,290 --> 00:19:49,670
far off the rails that it just tipped

482
00:19:49,670 --> 00:19:53,480
over sideways and died so that allows

483
00:19:53,480 --> 00:19:54,860
you to classify different types of

484
00:19:54,860 --> 00:19:56,150
inputs and then in

485
00:19:56,150 --> 00:19:59,390
let's have an ID format peachfuzz just

486
00:19:59,390 --> 00:20:01,910
has a folder called faults in any of

487
00:20:01,910 --> 00:20:04,670
your checked at failure inputs come as

488
00:20:04,670 --> 00:20:06,830
some kind of initial action and they'll

489
00:20:06,830 --> 00:20:08,960
be sequentially numbered and then lib

490
00:20:08,960 --> 00:20:11,570
buzzer has an output folder for failure

491
00:20:11,570 --> 00:20:13,400
inputs and again what you're trying to

492
00:20:13,400 --> 00:20:15,110
isolate is this is the input that caused

493
00:20:15,110 --> 00:20:16,820
your code to go bad and then you can go

494
00:20:16,820 --> 00:20:18,920
in and see why that weather's not a

495
00:20:18,920 --> 00:20:24,320
validation check for that it's windows a

496
00:20:24,320 --> 00:20:26,210
Linux based tool for some reason I'll

497
00:20:26,210 --> 00:20:28,730
just read the bottom part and read the

498
00:20:28,730 --> 00:20:29,750
rim Brian read the rim

499
00:20:29,750 --> 00:20:33,200
so gdb can actually be used for going

500
00:20:33,200 --> 00:20:36,890
through your test case information so

501
00:20:36,890 --> 00:20:41,030
you can use your standard BR c SNP type

502
00:20:41,030 --> 00:20:45,530
of commands to step through and if you

503
00:20:45,530 --> 00:20:47,240
really feel like it apparently Microsoft

504
00:20:47,240 --> 00:20:48,590
Visual Studio makes the tools that are

505
00:20:48,590 --> 00:20:52,180
GUI based and you can go play with those

506
00:20:52,180 --> 00:20:54,770
alright why in the world would we do

507
00:20:54,770 --> 00:21:00,050
this again integration testing is not a

508
00:21:00,050 --> 00:21:01,550
really good way to find security

509
00:21:01,550 --> 00:21:04,400
problems let's just be honest again

510
00:21:04,400 --> 00:21:06,200
because integration testing we're all

511
00:21:06,200 --> 00:21:07,940
focused on the functionality our

512
00:21:07,940 --> 00:21:10,160
customers like security but they really

513
00:21:10,160 --> 00:21:12,680
get more shouty and Yeley about booting

514
00:21:12,680 --> 00:21:13,550
the operating system running

515
00:21:13,550 --> 00:21:17,690
applications speed issues compatibility

516
00:21:17,690 --> 00:21:20,630
with devices so security is something

517
00:21:20,630 --> 00:21:22,310
that we push through our entire

518
00:21:22,310 --> 00:21:26,270
development cycle but it's you can't

519
00:21:26,270 --> 00:21:27,830
have security testing and then

520
00:21:27,830 --> 00:21:29,180
integration testing right you kind of

521
00:21:29,180 --> 00:21:30,350
have to make sure these are all combined

522
00:21:30,350 --> 00:21:33,290
so what this allows a developer to do is

523
00:21:33,290 --> 00:21:35,420
quickly execute a variety of tests prior

524
00:21:35,420 --> 00:21:37,580
to integration that will find the most

525
00:21:37,580 --> 00:21:39,740
common dumb of things you did that

526
00:21:39,740 --> 00:21:40,940
causes someone to be able to break in

527
00:21:40,940 --> 00:21:43,070
it's easier to get the crowbar under the

528
00:21:43,070 --> 00:21:44,660
box lid if you forgot to put one of the

529
00:21:44,660 --> 00:21:48,530
corners on right so we're taking

530
00:21:48,530 --> 00:21:50,600
existing tools that do this for OS

531
00:21:50,600 --> 00:21:52,430
development again one thing that I've

532
00:21:52,430 --> 00:21:54,140
learned over time with firmware is the

533
00:21:54,140 --> 00:21:57,250
reason we become the happy target for

534
00:21:57,250 --> 00:21:59,990
people in security world is because

535
00:21:59,990 --> 00:22:01,700
there's a perception that we've done

536
00:22:01,700 --> 00:22:03,350
less work on this type of thing than the

537
00:22:03,350 --> 00:22:05,690
OS and application people if you look at

538
00:22:05,690 --> 00:22:07,910
the progress in application security

539
00:22:07,910 --> 00:22:09,980
over the past decade

540
00:22:09,980 --> 00:22:12,140
applications have become very hard to

541
00:22:12,140 --> 00:22:14,270
break you watch bug bounties go up and

542
00:22:14,270 --> 00:22:15,950
up and up above bounty price as an

543
00:22:15,950 --> 00:22:17,450
indicator of how hard it is to break a

544
00:22:17,450 --> 00:22:20,179
thing so that's just the invisible hand

545
00:22:20,179 --> 00:22:22,880
saying okay it's worth more to do this

546
00:22:22,880 --> 00:22:25,970
because it's harder so firmware is kind

547
00:22:25,970 --> 00:22:27,020
of perceived as a place they should

548
00:22:27,020 --> 00:22:28,490
explore because everybody else is up

549
00:22:28,490 --> 00:22:30,470
there security game so all we're doing

550
00:22:30,470 --> 00:22:32,870
is bringing more game so that we are

551
00:22:32,870 --> 00:22:35,540
less attractive it's not just you keep

552
00:22:35,540 --> 00:22:36,799
breaking into the thing it just takes

553
00:22:36,799 --> 00:22:40,429
more effort somebody I talked to who

554
00:22:40,429 --> 00:22:42,530
works not in this building before this

555
00:22:42,530 --> 00:22:45,590
company told me have a concept of ten

556
00:22:45,590 --> 00:22:48,650
minutes of quality time if I can spend

557
00:22:48,650 --> 00:22:50,450
ten minutes of quality time with your

558
00:22:50,450 --> 00:22:54,919
laptop what can I do and if your 10

559
00:22:54,919 --> 00:22:57,650
minutes of quality time eight minutes of

560
00:22:57,650 --> 00:22:59,240
it is figuring out why this thing

561
00:22:59,240 --> 00:23:02,390
doesn't run in the firmware then they

562
00:23:02,390 --> 00:23:04,100
might just give up if it takes them a

563
00:23:04,100 --> 00:23:05,780
minute to get the thing to run you're

564
00:23:05,780 --> 00:23:06,860
the most attractive target on the

565
00:23:06,860 --> 00:23:09,169
platform if it takes nine of those ten

566
00:23:09,169 --> 00:23:11,059
minutes you're the least attractive part

567
00:23:11,059 --> 00:23:14,000
of that platform you are not as easy of

568
00:23:14,000 --> 00:23:15,350
a deterrent you're not the person

569
00:23:15,350 --> 00:23:17,480
walking home from the bar going look at

570
00:23:17,480 --> 00:23:19,340
all this cash in my hand you're less

571
00:23:19,340 --> 00:23:21,020
likely to get mugged if you have that in

572
00:23:21,020 --> 00:23:23,540
your pocket right so it's the same kind

573
00:23:23,540 --> 00:23:24,500
of mentality let's take the tools

574
00:23:24,500 --> 00:23:26,030
everybody else used to up their game run

575
00:23:26,030 --> 00:23:28,070
them on our stuff it's extensible

576
00:23:28,070 --> 00:23:30,919
because we don't know what the next tool

577
00:23:30,919 --> 00:23:32,150
is gonna be we don't know what the next

578
00:23:32,150 --> 00:23:33,950
threat is going to be we pay people

579
00:23:33,950 --> 00:23:35,450
quite a lot of money to think about that

580
00:23:35,450 --> 00:23:38,120
sort of thing so if someone comes along

581
00:23:38,120 --> 00:23:39,950
and says I've got a new cool test method

582
00:23:39,950 --> 00:23:43,040
I came up with a Bitcoin jannettek blah

583
00:23:43,040 --> 00:23:45,380
blah startup buzzword algorithm that I

584
00:23:45,380 --> 00:23:47,809
can run cool we'll roll that in that'll

585
00:23:47,809 --> 00:23:50,950
be the ninth thing we can do in hbf a

586
00:23:50,950 --> 00:23:53,480
it's this is something repeating to the

587
00:23:53,480 --> 00:23:55,280
ecosystem we didn't Intel brand this

588
00:23:55,280 --> 00:23:57,830
it's not Intel register trademark HP FA

589
00:23:57,830 --> 00:24:02,809
it's just HP FA if we can only do the

590
00:24:02,809 --> 00:24:05,600
testing and replication and Intel and we

591
00:24:05,600 --> 00:24:07,400
can't have our customers do that how can

592
00:24:07,400 --> 00:24:09,049
expect them to secure the platform's

593
00:24:09,049 --> 00:24:10,429
because we're putting this code out in

594
00:24:10,429 --> 00:24:12,169
the open we're putting this code out to

595
00:24:12,169 --> 00:24:13,669
our customers putting this code out to

596
00:24:13,669 --> 00:24:15,919
people who want to write code for our

597
00:24:15,919 --> 00:24:17,960
customers or want to replace the code

598
00:24:17,960 --> 00:24:20,110
our customers right depending on your

599
00:24:20,110 --> 00:24:23,050
your particular firmware approach

600
00:24:23,050 --> 00:24:24,790
so we want to make sure everybody can

601
00:24:24,790 --> 00:24:27,100
replicate what we do so if we say we

602
00:24:27,100 --> 00:24:29,710
tested this cool you might not believe

603
00:24:29,710 --> 00:24:31,810
us if we say we tested this and here's

604
00:24:31,810 --> 00:24:33,940
how we did it I think that's called

605
00:24:33,940 --> 00:24:36,550
science so that makes a little bit more

606
00:24:36,550 --> 00:24:40,030
sense so really we've introduced this to

607
00:24:40,030 --> 00:24:42,100
bridge a gap that we saw in development

608
00:24:42,100 --> 00:24:45,190
which is that unit tests weren't you

609
00:24:45,190 --> 00:24:48,040
know producing enough security focused

610
00:24:48,040 --> 00:24:51,760
results all right

611
00:24:51,760 --> 00:24:55,660
homework I helped write a white paper on

612
00:24:55,660 --> 00:24:58,750
this a couple of months ago and our team

613
00:24:58,750 --> 00:25:00,940
has put this code into the edk to

614
00:25:00,940 --> 00:25:03,640
staging so edq to has a couple of

615
00:25:03,640 --> 00:25:04,870
different or channel core itself has a

616
00:25:04,870 --> 00:25:06,400
couple different projects ET k2 is the

617
00:25:06,400 --> 00:25:08,860
main firmware core development that's

618
00:25:08,860 --> 00:25:10,180
where you get your eticket to stable

619
00:25:10,180 --> 00:25:12,990
tags what we used to call UDK releases

620
00:25:12,990 --> 00:25:16,690
you have ATK 2 platforms which is code

621
00:25:16,690 --> 00:25:18,550
designed for a particular thing that's

622
00:25:18,550 --> 00:25:20,080
what system 76 was talking about

623
00:25:20,080 --> 00:25:22,630
yesterday with their tiana core for

624
00:25:22,630 --> 00:25:25,390
their kb like and whiskey like platforms

625
00:25:25,390 --> 00:25:28,360
and then you've got an e decay to test

626
00:25:28,360 --> 00:25:30,220
repo which this will eventually end up

627
00:25:30,220 --> 00:25:32,770
in but for code that we are like this is

628
00:25:32,770 --> 00:25:35,410
good but we don't think it's quite ready

629
00:25:35,410 --> 00:25:38,230
yet we put that in a TK 2 staging so

630
00:25:38,230 --> 00:25:41,380
that is that is four things that we

631
00:25:41,380 --> 00:25:43,450
think will go to production but we would

632
00:25:43,450 --> 00:25:45,640
like input before anybody relies on this

633
00:25:45,640 --> 00:25:47,230
in a production environment and that's

634
00:25:47,230 --> 00:25:49,600
where HP FA is right now we've had a

635
00:25:49,600 --> 00:25:51,280
couple of customers integrate this into

636
00:25:51,280 --> 00:25:54,760
their CI environments and we've had some

637
00:25:54,760 --> 00:25:56,920
people who are looking at it making

638
00:25:56,920 --> 00:25:58,600
contributions but are talking about

639
00:25:58,600 --> 00:26:00,100
baking in and once it leaves staging

640
00:26:00,100 --> 00:26:01,570
which we expect to happen before the end

641
00:26:01,570 --> 00:26:04,810
of the year the white paper is good if

642
00:26:04,810 --> 00:26:06,370
you have to convince a manager to go

643
00:26:06,370 --> 00:26:10,360
work on it and then all the stuff here

644
00:26:10,360 --> 00:26:13,600
like the evaluation version the build

645
00:26:13,600 --> 00:26:16,720
and run guide how to run a test case how

646
00:26:16,720 --> 00:26:18,040
to add a new test case there's a role

647
00:26:18,040 --> 00:26:20,620
for the development folks so and I've

648
00:26:20,620 --> 00:26:22,000
got a blog which is another good thing

649
00:26:22,000 --> 00:26:23,920
you can hand to a boss and go hey should

650
00:26:23,920 --> 00:26:26,100
I be working on this question mark and

651
00:26:26,100 --> 00:26:28,480
if you want to do real work don't read

652
00:26:28,480 --> 00:26:32,170
my stuff read the stuff in the wiki ok

653
00:26:32,170 --> 00:26:34,870
that is all the slides I got so we have

654
00:26:34,870 --> 00:26:37,770
time for some questions

655
00:26:48,330 --> 00:26:50,440
excellent can I do any of this stuff

656
00:26:50,440 --> 00:26:55,090
from the LV FS so that's a it's an

657
00:26:55,090 --> 00:26:57,970
interesting question the answer is

658
00:26:57,970 --> 00:26:59,290
probably not

659
00:26:59,290 --> 00:27:01,450
I brought a stunt security person with

660
00:27:01,450 --> 00:27:04,150
me if he wants to throw down any of this

661
00:27:04,150 --> 00:27:05,560
sorry I called you out so early in the

662
00:27:05,560 --> 00:27:08,140
morning really this is designed for code

663
00:27:08,140 --> 00:27:10,630
not for finished binaries so if he write

664
00:27:10,630 --> 00:27:12,010
some cool code that's gonna get

665
00:27:12,010 --> 00:27:14,020
integrated into somebody's edk 2 project

666
00:27:14,020 --> 00:27:17,620
yes but I think you would probably be

667
00:27:17,620 --> 00:27:19,420
using the same fuzzing tools of the OS

668
00:27:19,420 --> 00:27:21,160
layer to check your stuff before you

669
00:27:21,160 --> 00:27:23,440
release it I don't think it's really set

670
00:27:23,440 --> 00:27:26,980
up to do binary analysis binary to kind

671
00:27:26,980 --> 00:27:29,650
of now cuz it's a test harness that we

672
00:27:29,650 --> 00:27:32,080
got to wire it up right and by wire up I

673
00:27:32,080 --> 00:27:33,610
mean right some dummy functions that

674
00:27:33,610 --> 00:27:35,500
don't go into the final code so what

675
00:27:35,500 --> 00:27:38,770
else can I do you already talked to our

676
00:27:38,770 --> 00:27:40,300
chipset people and it's a loaded answer

677
00:27:40,300 --> 00:27:43,090
but chip SEC is still good again for the

678
00:27:43,090 --> 00:27:46,360
runtime state of a platform it's gonna

679
00:27:46,360 --> 00:27:48,160
be an integration type thing but again

680
00:27:48,160 --> 00:27:49,870
it's gonna measure if they left the

681
00:27:49,870 --> 00:27:51,310
platform and what you consider to be the

682
00:27:51,310 --> 00:27:54,610
most secure state or what we consider to

683
00:27:54,610 --> 00:27:57,910
be secure enough state for what has been

684
00:27:57,910 --> 00:28:02,590
released into the world I think we've

685
00:28:02,590 --> 00:28:03,730
already had a side discussion about

686
00:28:03,730 --> 00:28:06,430
whitelist and blacklist in chip SEC and

687
00:28:06,430 --> 00:28:08,290
if you can build enough whitelist data

688
00:28:08,290 --> 00:28:10,030
then it'll give you an idea because

689
00:28:10,030 --> 00:28:11,650
you're getting an aggregate through LV

690
00:28:11,650 --> 00:28:14,590
FS of all of the submissions and if

691
00:28:14,590 --> 00:28:17,890
you're getting signed pieces you can try

692
00:28:17,890 --> 00:28:19,720
to at least you know if you don't have

693
00:28:19,720 --> 00:28:21,070
only whitelist data you can say these

694
00:28:21,070 --> 00:28:22,390
are what I know is good and there's

695
00:28:22,390 --> 00:28:24,190
here's the units or the things that came

696
00:28:24,190 --> 00:28:25,570
in that I can't identify

697
00:28:25,570 --> 00:28:27,340
so that's white list and I guess what we

698
00:28:27,340 --> 00:28:29,590
call grey list I don't know applying a

699
00:28:29,590 --> 00:28:30,760
color scale to these things is kind of

700
00:28:30,760 --> 00:28:33,430
weird I don't know if you've got the

701
00:28:33,430 --> 00:28:35,140
ability to actually run like a black

702
00:28:35,140 --> 00:28:37,990
list type of scenario no but that's

703
00:28:37,990 --> 00:28:39,730
pretty valuable but that's gonna require

704
00:28:39,730 --> 00:28:45,010
on kind of accumulated knowledge way in

705
00:28:45,010 --> 00:28:47,220
the back

706
00:28:50,650 --> 00:28:56,630
buffering question please wait so would

707
00:28:56,630 --> 00:29:00,320
it be part of the ad ke release process

708
00:29:00,320 --> 00:29:04,060
do you plan to apply that to whole etk 3

709
00:29:04,060 --> 00:29:07,100
what we're looking at doing is so we

710
00:29:07,100 --> 00:29:08,750
can't automatically apply this to

711
00:29:08,750 --> 00:29:10,700
everything in the tree because it does

712
00:29:10,700 --> 00:29:13,640
require some manual work to bump in the

713
00:29:13,640 --> 00:29:15,860
different you know the three functions I

714
00:29:15,860 --> 00:29:17,240
was showing you that do the test

715
00:29:17,240 --> 00:29:22,220
instrumentation so I think in our

716
00:29:22,220 --> 00:29:26,120
process I need some help from my my

717
00:29:26,120 --> 00:29:28,310
stunt developer in the audits are we

718
00:29:28,310 --> 00:29:29,900
requiring this in our process right now

719
00:29:29,900 --> 00:29:31,640
or is this kind of still not a hundred

720
00:29:31,640 --> 00:29:33,770
percent rolled up and what we do

721
00:29:33,770 --> 00:29:36,230
internally did we know that I think this

722
00:29:36,230 --> 00:29:37,960
is a newer tool that we're still

723
00:29:37,960 --> 00:29:40,190
becoming more familiar with at Intel and

724
00:29:40,190 --> 00:29:43,010
so I think as we go forward I think we

725
00:29:43,010 --> 00:29:44,450
see more adoption but I don't think yes

726
00:29:44,450 --> 00:29:48,230
I require today I know that we're so one

727
00:29:48,230 --> 00:29:49,370
thing we're still defining for Tiano

728
00:29:49,370 --> 00:29:53,090
core is continuous integration path

729
00:29:53,090 --> 00:29:55,340
which hopefully the next time we get

730
00:29:55,340 --> 00:29:57,110
together we'll have a cool presentation

731
00:29:57,110 --> 00:29:58,330
and Stefano and what that looks like

732
00:29:58,330 --> 00:30:00,500
we're still talking to the community

733
00:30:00,500 --> 00:30:02,210
about what the best CI framework is

734
00:30:02,210 --> 00:30:03,740
that's most compatible with the

735
00:30:03,740 --> 00:30:05,750
community's needs just because we're

736
00:30:05,750 --> 00:30:06,890
doing something in Intel doesn't mean

737
00:30:06,890 --> 00:30:08,120
it's the process that everybody else

738
00:30:08,120 --> 00:30:10,760
needs to be using in the open either

739
00:30:10,760 --> 00:30:12,740
because of like we paid money for some

740
00:30:12,740 --> 00:30:15,080
things or we use one cloud framework and

741
00:30:15,080 --> 00:30:16,130
everybody else wants to use a different

742
00:30:16,130 --> 00:30:19,730
one but we are getting to the point

743
00:30:19,730 --> 00:30:22,270
where we'd like to do more automatic CI

744
00:30:22,270 --> 00:30:24,620
so you know if you check in a piece of

745
00:30:24,620 --> 00:30:27,680
code things automatically happen that do

746
00:30:27,680 --> 00:30:29,990
you know we can do the dumb stuff like

747
00:30:29,990 --> 00:30:32,180
tab servers to spaces or we can also do

748
00:30:32,180 --> 00:30:34,400
more intense things like could we snap

749
00:30:34,400 --> 00:30:37,070
in some of these CI pieces Microsoft has

750
00:30:37,070 --> 00:30:38,570
actually done quite a bit of work with

751
00:30:38,570 --> 00:30:41,870
HP FA and I think they've got something

752
00:30:41,870 --> 00:30:45,410
in their internal project new framework

753
00:30:45,410 --> 00:30:48,470
that is using this as part of their CI

754
00:30:48,470 --> 00:30:50,980
process

755
00:30:58,640 --> 00:31:02,330
in indicate oh so this is different than

756
00:31:02,330 --> 00:31:05,660
finding a seat well so you try my

757
00:31:05,660 --> 00:31:07,610
finding existing CVS or doing a research

758
00:31:07,610 --> 00:31:11,120
to find new ones yeah I mean new ones

759
00:31:11,120 --> 00:31:15,080
because fuzzing can reveal some some

760
00:31:15,080 --> 00:31:17,090
inputs that were not validated yeah

761
00:31:17,090 --> 00:31:20,210
triggered some yeah and that's that's

762
00:31:20,210 --> 00:31:22,010
one thing while we're looking at the the

763
00:31:22,010 --> 00:31:23,660
CI processes because anytime you do

764
00:31:23,660 --> 00:31:26,630
something that is security focused in an

765
00:31:26,630 --> 00:31:28,550
open-source project what you want to

766
00:31:28,550 --> 00:31:30,260
make sure you're doing is detecting

767
00:31:30,260 --> 00:31:33,650
issues and not publishing 0 days so you

768
00:31:33,650 --> 00:31:34,760
have to be a little careful about how

769
00:31:34,760 --> 00:31:38,210
you you roll the stuff up but we do have

770
00:31:38,210 --> 00:31:39,620
an interest in doing more of that kind

771
00:31:39,620 --> 00:31:41,990
of automatic work I think because it's

772
00:31:41,990 --> 00:31:45,230
more of a unit test idea it's more on

773
00:31:45,230 --> 00:31:47,990
the individual developers side to do the

774
00:31:47,990 --> 00:31:50,360
sort of thing as part of their you know

775
00:31:50,360 --> 00:31:51,290
check-in process

776
00:31:51,290 --> 00:31:53,030
I wouldn't necessarily expect someone to

777
00:31:53,030 --> 00:31:55,970
check in a version of their code into

778
00:31:55,970 --> 00:31:58,580
say the ek2 trunk that's got these

779
00:31:58,580 --> 00:32:01,220
functions stubbed in but they might have

780
00:32:01,220 --> 00:32:04,220
it in an internal github branch that

781
00:32:04,220 --> 00:32:06,260
they're using before they push it to a

782
00:32:06,260 --> 00:32:09,890
main yeah there is a so if we consider

783
00:32:09,890 --> 00:32:11,870
for example minnowboard building process

784
00:32:11,870 --> 00:32:16,070
that we can take some pieces some open

785
00:32:16,070 --> 00:32:18,290
pieces so you can wander it when you

786
00:32:18,290 --> 00:32:20,780
releasing any binary based on that or

787
00:32:20,780 --> 00:32:22,850
mint platform when you're releasing

788
00:32:22,850 --> 00:32:24,740
something based on that and that you

789
00:32:24,740 --> 00:32:27,530
want to use this tool and so what's the

790
00:32:27,530 --> 00:32:30,290
part if you find something yeah well I

791
00:32:30,290 --> 00:32:32,360
mean the path if you find something is

792
00:32:32,360 --> 00:32:33,680
already established there's two ways of

793
00:32:33,680 --> 00:32:36,170
submitting bugs in the tiyanak or one is

794
00:32:36,170 --> 00:32:37,910
I have standard functional bug and

795
00:32:37,910 --> 00:32:39,890
that's just the regular Bugzilla process

796
00:32:39,890 --> 00:32:43,250
and then there's a an info SEC team that

797
00:32:43,250 --> 00:32:46,040
works on a non-public version that

798
00:32:46,040 --> 00:32:47,540
Bugzilla if you enter something if like

799
00:32:47,540 --> 00:32:49,910
this security bug it you can't see that

800
00:32:49,910 --> 00:32:51,260
BZ unless you're part of the info set

801
00:32:51,260 --> 00:32:54,020
group and that allows security

802
00:32:54,020 --> 00:32:56,660
researchers and developers from a

803
00:32:56,660 --> 00:32:58,430
variety of the channel core contributors

804
00:32:58,430 --> 00:33:02,060
to take a look at it and see if it if

805
00:33:02,060 --> 00:33:04,600
security issue they go down the path of

806
00:33:04,600 --> 00:33:07,970
treating it as a you know a regular

807
00:33:07,970 --> 00:33:09,650
security issue so it goes into some kind

808
00:33:09,650 --> 00:33:10,820
of you know there's a if it's the

809
00:33:10,820 --> 00:33:11,870
appropriate company has a bug bounty

810
00:33:11,870 --> 00:33:12,440
program

811
00:33:12,440 --> 00:33:13,910
we push in another bug bounty program

812
00:33:13,910 --> 00:33:17,840
and treat it as a coordinated disclosure

813
00:33:17,840 --> 00:33:20,420
issue so again we're not gonna use our

814
00:33:20,420 --> 00:33:27,410
Bugzilla as a zero-day database but one

815
00:33:27,410 --> 00:33:28,790
thing that I do want to point out the

816
00:33:28,790 --> 00:33:31,130
reason why it's harder to just slap this

817
00:33:31,130 --> 00:33:32,750
instrumentation and like if it was just

818
00:33:32,750 --> 00:33:36,560
a you know automatic you know patch to

819
00:33:36,560 --> 00:33:37,850
throw these three functions and it would

820
00:33:37,850 --> 00:33:39,470
be really easy to put that into the CI

821
00:33:39,470 --> 00:33:41,300
but because you're dealing with things a

822
00:33:41,300 --> 00:33:43,970
touch hardware sometimes the stuffing

823
00:33:43,970 --> 00:33:45,380
process like the way that you would stub

824
00:33:45,380 --> 00:33:46,970
these functions in the USB drivers

825
00:33:46,970 --> 00:33:48,410
different from PCI different from

826
00:33:48,410 --> 00:33:49,850
something that's purely software logic

827
00:33:49,850 --> 00:33:52,010
so we haven't quite got to the point

828
00:33:52,010 --> 00:33:53,660
where we can at all just say oh this is

829
00:33:53,660 --> 00:33:55,760
the USB set of stubs versus this is the

830
00:33:55,760 --> 00:33:58,250
PCI setup steps right if we get to that

831
00:33:58,250 --> 00:33:59,690
point then it might be more of a snap-in

832
00:33:59,690 --> 00:34:05,090
type of environment yeah question from I

833
00:34:05,090 --> 00:34:07,100
said yeah I already mentioned science I

834
00:34:07,100 --> 00:34:09,260
know that people for example at the

835
00:34:09,260 --> 00:34:11,300
University of go home they do a lot with

836
00:34:11,300 --> 00:34:13,219
fuzzing have you approach any

837
00:34:13,219 --> 00:34:15,500
researchers if they approach you or

838
00:34:15,500 --> 00:34:18,710
how's the academia perception here we

839
00:34:18,710 --> 00:34:20,150
are right now what we're doing is taking

840
00:34:20,150 --> 00:34:22,010
the output of academic work because a

841
00:34:22,010 --> 00:34:23,630
lot of these fuzzers are the university

842
00:34:23,630 --> 00:34:26,780
projects or quasi university projects

843
00:34:26,780 --> 00:34:29,090
intel has a group called intel labs that

844
00:34:29,090 --> 00:34:30,949
is sort of our science fair experiment

845
00:34:30,949 --> 00:34:33,949
group and some of our tools that are

846
00:34:33,949 --> 00:34:35,600
adjacent to this things that we've done

847
00:34:35,600 --> 00:34:38,630
that involve fuzzing or weird unit test

848
00:34:38,630 --> 00:34:40,820
cases have come out of labs projects I

849
00:34:40,820 --> 00:34:44,989
don't know if you wanna I mean to some

850
00:34:44,989 --> 00:34:47,060
researchers from that University and I

851
00:34:47,060 --> 00:34:48,199
think a lot of them are very focused on

852
00:34:48,199 --> 00:34:50,810
kfl that's something that we're looking

853
00:34:50,810 --> 00:34:52,850
at adopting and sort of a parallel

854
00:34:52,850 --> 00:34:54,500
project to this yeah okay my mystery

855
00:34:54,500 --> 00:34:56,090
guest introduce himself hi I'm Brian

856
00:34:56,090 --> 00:34:58,220
Delgado I work at Intel I'm on the

857
00:34:58,220 --> 00:35:00,110
Excite project which also does firmer

858
00:35:00,110 --> 00:35:04,940
fuzzing yeah so he's my stump Brian all

859
00:35:04,940 --> 00:35:07,130
right well how much time we got left for

860
00:35:07,130 --> 00:35:11,770
questions with Cerf a few minutes so

861
00:35:13,840 --> 00:35:16,070
is this something that we can tear up

862
00:35:16,070 --> 00:35:18,560
and use for other architectures relying

863
00:35:18,560 --> 00:35:20,450
on you to get to our other operating

864
00:35:20,450 --> 00:35:22,610
systems I'm sorry can you repeat the

865
00:35:22,610 --> 00:35:24,280
question is this something that we can

866
00:35:24,280 --> 00:35:27,200
port to all that architectures based on

867
00:35:27,200 --> 00:35:28,700
you I mean that I need to get to on

868
00:35:28,700 --> 00:35:31,550
their path there's nothing in here I'm

869
00:35:31,550 --> 00:35:32,720
aware of that's an architectural

870
00:35:32,720 --> 00:35:34,340
limitation because we and that's another

871
00:35:34,340 --> 00:35:36,470
reason why we didn't Intel brand it if

872
00:35:36,470 --> 00:35:38,930
we stuck an Intel trademark on it even

873
00:35:38,930 --> 00:35:41,090
if it would work across architecture it

874
00:35:41,090 --> 00:35:42,560
would probably make some people think

875
00:35:42,560 --> 00:35:47,120
twice before they did honestly I I'm a

876
00:35:47,120 --> 00:35:48,920
rising tide

877
00:35:48,920 --> 00:35:51,200
you know raises all boats kind of

878
00:35:51,200 --> 00:35:54,740
mentality and open-source if you find

879
00:35:54,740 --> 00:35:56,720
bugs in a non Intel Architecture it's

880
00:35:56,720 --> 00:35:58,550
likely that it impacts an Intel

881
00:35:58,550 --> 00:36:01,400
Architecture because you're testing

882
00:36:01,400 --> 00:36:03,470
cases that we can't do in our

883
00:36:03,470 --> 00:36:05,770
architecture so I'll give you an example

884
00:36:05,770 --> 00:36:09,860
lonardo found this really nasty bug with

885
00:36:09,860 --> 00:36:12,770
memory mapping so it turns out that if

886
00:36:12,770 --> 00:36:14,570
you make an array and you can't count

887
00:36:14,570 --> 00:36:18,410
you get no pointers no pointers an intel

888
00:36:18,410 --> 00:36:21,290
architecture point 2 0 : 0 and old

889
00:36:21,290 --> 00:36:24,530
memory terms that's where our inner up 0

890
00:36:24,530 --> 00:36:26,810
handler lives because we put the

891
00:36:26,810 --> 00:36:27,890
interrupt table down at the base of

892
00:36:27,890 --> 00:36:29,690
memory and we boot from 1 megabyte

893
00:36:29,690 --> 00:36:31,340
because it was the 80s and people were

894
00:36:31,340 --> 00:36:34,400
doing a lot of weird things so it turns

895
00:36:34,400 --> 00:36:35,750
out an ARM architecture I didn't know

896
00:36:35,750 --> 00:36:37,550
this until last year you don't have to

897
00:36:37,550 --> 00:36:39,350
have physical memory at base address

898
00:36:39,350 --> 00:36:43,730
zero and a lot of platforms don't why no

899
00:36:43,730 --> 00:36:48,140
idea but if you say take an Nvidia card

900
00:36:48,140 --> 00:36:51,740
just as an example and use its graphics

901
00:36:51,740 --> 00:36:53,600
driver it'll work great on Intel but

902
00:36:53,600 --> 00:36:55,760
doesn't work so well unarmed right so

903
00:36:55,760 --> 00:36:56,840
what they did is they built this weird

904
00:36:56,840 --> 00:36:58,160
emulator package as a FOSDEM

905
00:36:58,160 --> 00:36:59,630
presentation from a couple years ago

906
00:36:59,630 --> 00:37:01,550
that's really cool and they essentially

907
00:37:01,550 --> 00:37:05,450
run qemu in memory and whenever they hit

908
00:37:05,450 --> 00:37:10,190
a an instruction that's not in the

909
00:37:10,190 --> 00:37:12,350
native instruction set instead of

910
00:37:12,350 --> 00:37:15,110
invoking the non execute bit handler it

911
00:37:15,110 --> 00:37:17,420
invokes qmu and runs the ah prom in an

912
00:37:17,420 --> 00:37:19,220
emulator so that you can run intel uh

913
00:37:19,220 --> 00:37:21,200
prompts an ARM architecture and it's

914
00:37:21,200 --> 00:37:23,300
it's proving ground things I don't well

915
00:37:23,300 --> 00:37:24,620
they may ship it but they probably

916
00:37:24,620 --> 00:37:26,510
shouldn't

917
00:37:26,510 --> 00:37:27,650
but it's just a proving ground piece so

918
00:37:27,650 --> 00:37:29,780
they can test more cards well you get a

919
00:37:29,780 --> 00:37:31,310
null pointer in that graphics output

920
00:37:31,310 --> 00:37:34,160
protocol and on our platform it would

921
00:37:34,160 --> 00:37:35,420
just look like garbage data at the

922
00:37:35,420 --> 00:37:37,640
bottom of the array in their platform it

923
00:37:37,640 --> 00:37:41,240
dies it halts can catch fire and then

924
00:37:41,240 --> 00:37:44,360
they actually see that oh this cop

925
00:37:44,360 --> 00:37:46,880
driver 4 X 64 has a bug in it and so arm

926
00:37:46,880 --> 00:37:48,110
reported that bug back to the

927
00:37:48,110 --> 00:37:50,570
manufacturer on our platform

928
00:37:50,570 --> 00:37:52,880
architecture we would have never found

929
00:37:52,880 --> 00:37:56,150
that bug so yeah go run it on something

930
00:37:56,150 --> 00:37:57,320
that we don't make see what happens

931
00:37:57,320 --> 00:38:06,260
check it out yeah absolutely

932
00:38:06,260 --> 00:38:08,090
again that's that's why it's need to

933
00:38:08,090 --> 00:38:09,350
keep to staging go ahead and play with

934
00:38:09,350 --> 00:38:12,530
it contribute it and definitely when if

935
00:38:12,530 --> 00:38:13,880
you work on this stuff don't just check

936
00:38:13,880 --> 00:38:16,100
the code back in check the test cases in

937
00:38:16,100 --> 00:38:17,450
because again you want to be able to

938
00:38:17,450 --> 00:38:19,100
prove your work it's it's a math class

939
00:38:19,100 --> 00:38:24,650
in this case alright then thanks again

940
00:38:24,650 --> 00:38:26,560
all right thank you

941
00:38:26,560 --> 00:38:30,679
[Applause]

942
00:38:32,050 --> 00:38:33,660
[Music]

943
00:38:33,660 --> 00:38:35,720
you

