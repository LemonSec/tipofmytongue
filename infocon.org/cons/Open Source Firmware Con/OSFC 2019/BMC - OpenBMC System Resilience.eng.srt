1
00:00:03,190 --> 00:00:06,259
[Music]

2
00:00:07,970 --> 00:00:10,500
so our next our next speaker today is a

3
00:00:10,500 --> 00:00:12,660
William Kennington he'll be talking to

4
00:00:12,660 --> 00:00:14,849
us about system resilience for open BMC

5
00:00:14,849 --> 00:00:17,520
so William is a software engineer at

6
00:00:17,520 --> 00:00:19,680
Google who's working on the open BMC

7
00:00:19,680 --> 00:00:21,869
upstream project he maintained some of

8
00:00:21,869 --> 00:00:23,910
the core system components and it has

9
00:00:23,910 --> 00:00:25,529
been contributing to improving the

10
00:00:25,529 --> 00:00:31,560
resiliency and power functionality of

11
00:00:31,560 --> 00:00:34,980
open BMC great thanks Benjamin so yeah

12
00:00:34,980 --> 00:00:37,290
as he said I'm working on GBMC at Google

13
00:00:37,290 --> 00:00:38,910
which is our internal distribution of

14
00:00:38,910 --> 00:00:41,760
the open BMC platform and as someone

15
00:00:41,760 --> 00:00:42,840
who's been working on bringing up

16
00:00:42,840 --> 00:00:45,030
servers now for three issues and then

17
00:00:45,030 --> 00:00:47,329
focusing more on BMC components nowadays

18
00:00:47,329 --> 00:00:50,129
the having things fail on you is

19
00:00:50,129 --> 00:00:51,539
something that just inevitably happens

20
00:00:51,539 --> 00:00:53,489
when you have lots of machines and so we

21
00:00:53,489 --> 00:00:56,160
need ways of resilience so that in the

22
00:00:56,160 --> 00:00:57,690
case of those failures we can either

23
00:00:57,690 --> 00:00:59,070
completely recover or we can do

24
00:00:59,070 --> 00:01:01,020
something that acts as a fallback that

25
00:01:01,020 --> 00:01:02,940
kind of like gets us far enough along

26
00:01:02,940 --> 00:01:04,559
that we're able to do critical

27
00:01:04,559 --> 00:01:06,090
functionality without may be servicing

28
00:01:06,090 --> 00:01:08,220
extraneous needs but we're still able to

29
00:01:08,220 --> 00:01:10,439
have the system operate in a functional

30
00:01:10,439 --> 00:01:12,900
state so what do these things look like

31
00:01:12,900 --> 00:01:15,750
so our background anyone who works on

32
00:01:15,750 --> 00:01:17,340
these platforms at Google comes from

33
00:01:17,340 --> 00:01:18,689
having many machines with a focus on

34
00:01:18,689 --> 00:01:20,580
automation and monitoring because you

35
00:01:20,580 --> 00:01:22,140
have so many machines you can't go in

36
00:01:22,140 --> 00:01:23,790
and manually intervene anytime something

37
00:01:23,790 --> 00:01:25,710
goes wrong you'd like to maybe for some

38
00:01:25,710 --> 00:01:27,090
of them but you definitely don't want to

39
00:01:27,090 --> 00:01:28,140
be at the point where you have someone

40
00:01:28,140 --> 00:01:30,119
going in physically and having to push

41
00:01:30,119 --> 00:01:31,710
and pull a server to restart it you want

42
00:01:31,710 --> 00:01:33,540
to have all of your tooling available so

43
00:01:33,540 --> 00:01:34,979
that you're able to go and to fix

44
00:01:34,979 --> 00:01:36,299
machines that are broken in the fleet

45
00:01:36,299 --> 00:01:38,820
without having to do anything by hand or

46
00:01:38,820 --> 00:01:40,560
going in one off and doing those things

47
00:01:40,560 --> 00:01:42,000
because you may not even have access to

48
00:01:42,000 --> 00:01:43,590
those machines right like in a lot of

49
00:01:43,590 --> 00:01:45,030
cases we deploy machines into production

50
00:01:45,030 --> 00:01:46,649
and the developers who work on these

51
00:01:46,649 --> 00:01:48,090
things that are able to dig in and debug

52
00:01:48,090 --> 00:01:49,770
the issues may have no access to that

53
00:01:49,770 --> 00:01:51,299
machine without DMC or any of the data

54
00:01:51,299 --> 00:01:53,759
there and so we've like in general for

55
00:01:53,759 --> 00:01:54,960
all of our failures to be self

56
00:01:54,960 --> 00:01:56,280
recoverable we'd like these things to be

57
00:01:56,280 --> 00:01:59,130
self-healing we really never ever ever

58
00:01:59,130 --> 00:02:01,649
want to have to intervene even if it's

59
00:02:01,649 --> 00:02:03,210
the case that we're losing mutable data

60
00:02:03,210 --> 00:02:04,500
so we actually have settings data

61
00:02:04,500 --> 00:02:06,450
written to the BMC we really don't

62
00:02:06,450 --> 00:02:08,489
actually care about that data that much

63
00:02:08,489 --> 00:02:09,568
so much that we'd rather have the

64
00:02:09,568 --> 00:02:12,000
Machine fail completely we'd rather it

65
00:02:12,000 --> 00:02:13,379
limp along and try and get back into a

66
00:02:13,379 --> 00:02:13,740
usable

67
00:02:13,740 --> 00:02:15,150
State and maybe go through some kind of

68
00:02:15,150 --> 00:02:18,480
automated repairs flow and so that kind

69
00:02:18,480 --> 00:02:21,180
of hits that next point and it's worth

70
00:02:21,180 --> 00:02:22,770
noting that for us we have very limited

71
00:02:22,770 --> 00:02:26,040
access to the BNC in general our BMC's

72
00:02:26,040 --> 00:02:28,200
really only have IP mi-access there's

73
00:02:28,200 --> 00:02:29,910
almost no form about a band you don't

74
00:02:29,910 --> 00:02:31,830
have SSH you don't have redfish you

75
00:02:31,830 --> 00:02:33,240
don't have any of these things so

76
00:02:33,240 --> 00:02:34,470
everything that we do has to be

77
00:02:34,470 --> 00:02:36,150
implemented as an IP mi command and we

78
00:02:36,150 --> 00:02:37,950
really don't want to extend the IP mi

79
00:02:37,950 --> 00:02:39,930
specification so much that we're able to

80
00:02:39,930 --> 00:02:41,220
do things like read and write to the

81
00:02:41,220 --> 00:02:43,740
file system an SSH tunnel through IP MI

82
00:02:43,740 --> 00:02:45,110
or something really bizarre and gross

83
00:02:45,110 --> 00:02:48,690
and so we want to sort of adapt as much

84
00:02:48,690 --> 00:02:50,010
an idea as we can to our troubleshooting

85
00:02:50,010 --> 00:02:51,780
needs without going too far and getting

86
00:02:51,780 --> 00:02:53,220
ourselves way too ingrained and building

87
00:02:53,220 --> 00:02:55,860
around custom stuff or ipmi and this

88
00:02:55,860 --> 00:02:58,140
makes it really hard to debug issues on

89
00:02:58,140 --> 00:03:00,300
the BMC because right now we have very

90
00:03:00,300 --> 00:03:01,800
little access to read a lot of the data

91
00:03:01,800 --> 00:03:03,480
that the BMC generates so the BMC

92
00:03:03,480 --> 00:03:06,450
generates logs in journal D or in any of

93
00:03:06,450 --> 00:03:08,430
the system D mechanisms and then those

94
00:03:08,430 --> 00:03:11,550
logs have no a CL representation maybe

95
00:03:11,550 --> 00:03:13,350
we have some things that do log of CLS

96
00:03:13,350 --> 00:03:14,670
but that's the only information we're

97
00:03:14,670 --> 00:03:16,050
able to actually extract when we see an

98
00:03:16,050 --> 00:03:18,840
error um so the open BMC system if

99
00:03:18,840 --> 00:03:20,340
you're unfamiliar is designed this kind

100
00:03:20,340 --> 00:03:21,930
of a whole bunch of micro services and

101
00:03:21,930 --> 00:03:23,670
then some routing functionality that

102
00:03:23,670 --> 00:03:25,050
allows the host system and out-of-band

103
00:03:25,050 --> 00:03:27,450
network to access it in our case we kind

104
00:03:27,450 --> 00:03:28,860
of ignore them out of being networked

105
00:03:28,860 --> 00:03:30,030
and that we're transport driver and

106
00:03:30,030 --> 00:03:32,040
redfish and those things for now because

107
00:03:32,040 --> 00:03:33,540
we don't deal with that so much as we

108
00:03:33,540 --> 00:03:35,340
deal with the IPM I going to the host

109
00:03:35,340 --> 00:03:37,530
system level and so you'll see we're

110
00:03:37,530 --> 00:03:38,580
actually running a fairly powerful

111
00:03:38,580 --> 00:03:39,960
microcontroller we're running something

112
00:03:39,960 --> 00:03:42,330
that runs Linux and it's running system

113
00:03:42,330 --> 00:03:44,160
D in user space and all of our micro

114
00:03:44,160 --> 00:03:46,410
service daemons I didn't list all the

115
00:03:46,410 --> 00:03:47,610
demons because quite frankly if we

116
00:03:47,610 --> 00:03:49,050
listed all of them there would be way

117
00:03:49,050 --> 00:03:50,400
too many and this would become even

118
00:03:50,400 --> 00:03:51,900
worse of a spider web and there than it

119
00:03:51,900 --> 00:03:54,720
already is but I did try and give some

120
00:03:54,720 --> 00:03:56,280
representative examples like having

121
00:03:56,280 --> 00:03:58,350
temperature sensors those are we have a

122
00:03:58,350 --> 00:03:59,520
whole bunch of those demons that are

123
00:03:59,520 --> 00:04:01,470
able to talk to the hardware Mon drivers

124
00:04:01,470 --> 00:04:03,120
in the kernel which then go out and talk

125
00:04:03,120 --> 00:04:05,370
to probes and dims and talk to the CPU

126
00:04:05,370 --> 00:04:07,380
those sorts of things and you have fan

127
00:04:07,380 --> 00:04:08,700
controllers where you have fans in the

128
00:04:08,700 --> 00:04:10,890
system so your BMC is monitoring the

129
00:04:10,890 --> 00:04:12,540
fans and it's issuing fan control

130
00:04:12,540 --> 00:04:13,920
actions and it's trying to set fan

131
00:04:13,920 --> 00:04:15,180
curves based on the temperature data

132
00:04:15,180 --> 00:04:16,829
it's getting and so you have the fan

133
00:04:16,829 --> 00:04:19,230
control demons those actually do talk to

134
00:04:19,230 --> 00:04:20,640
the temperature sensors because it does

135
00:04:20,640 --> 00:04:21,899
need to know for the different thermal

136
00:04:21,899 --> 00:04:24,090
zones what the fan configuration needs

137
00:04:24,090 --> 00:04:25,500
to be based on the thermal feedback it's

138
00:04:25,500 --> 00:04:26,970
getting and then you have demons like

139
00:04:26,970 --> 00:04:27,480
the hosts

140
00:04:27,480 --> 00:04:28,860
ogwuche actually has nil outside

141
00:04:28,860 --> 00:04:30,210
communication it's not talking to the

142
00:04:30,210 --> 00:04:31,860
colonel not talking to these external

143
00:04:31,860 --> 00:04:33,810
devices it's purely talking over d-bus

144
00:04:33,810 --> 00:04:36,210
to the IP mi demon and giving the host

145
00:04:36,210 --> 00:04:38,550
system a way to put this watchdog and in

146
00:04:38,550 --> 00:04:39,690
the worst case if the host stops

147
00:04:39,690 --> 00:04:41,670
responding then it's able to go and kill

148
00:04:41,670 --> 00:04:43,980
the host system and bring it back up and

149
00:04:43,980 --> 00:04:45,390
then you have network settings and user

150
00:04:45,390 --> 00:04:46,890
manager these are also things that live

151
00:04:46,890 --> 00:04:48,840
on the BMC but they have a sort of

152
00:04:48,840 --> 00:04:50,730
mutable state associated with them so

153
00:04:50,730 --> 00:04:52,950
when the user or the external agent on

154
00:04:52,950 --> 00:04:54,390
the host system comes in and wants to

155
00:04:54,390 --> 00:04:56,040
change the PMC's network configuration

156
00:04:56,040 --> 00:04:57,810
it will eventually get written through

157
00:04:57,810 --> 00:05:00,180
the ipmi router into that BMC network

158
00:05:00,180 --> 00:05:01,380
settings daemon and that will persist

159
00:05:01,380 --> 00:05:04,620
something on to the disk and sort of the

160
00:05:04,620 --> 00:05:06,780
core theme here that you'll see is that

161
00:05:06,780 --> 00:05:09,150
if you ignore the network components you

162
00:05:09,150 --> 00:05:11,190
really have these single points of

163
00:05:11,190 --> 00:05:13,560
transit to the outside world you're

164
00:05:13,560 --> 00:05:15,090
communicating only to the host system

165
00:05:15,090 --> 00:05:16,770
through the transport driver that could

166
00:05:16,770 --> 00:05:18,570
be the kcs bridge or some kind of block

167
00:05:18,570 --> 00:05:21,000
transport mode through the daemon that

168
00:05:21,000 --> 00:05:22,740
handles talking to that specific type of

169
00:05:22,740 --> 00:05:24,840
transport and then through that IPMI

170
00:05:24,840 --> 00:05:27,450
router which we call ipm ID and that

171
00:05:27,450 --> 00:05:29,310
then proxies into all the services but

172
00:05:29,310 --> 00:05:31,350
if any one of those things fail you now

173
00:05:31,350 --> 00:05:33,120
have no way of talking to the outside

174
00:05:33,120 --> 00:05:34,800
world the BMC is completely isolated and

175
00:05:34,800 --> 00:05:36,860
as far as you're concerned it's bricked

176
00:05:36,860 --> 00:05:39,330
now and so what are some problems that

177
00:05:39,330 --> 00:05:41,250
we have that we don't have resilience in

178
00:05:41,250 --> 00:05:42,990
place for so if our service locks up and

179
00:05:42,990 --> 00:05:44,400
just decides to not make any new

180
00:05:44,400 --> 00:05:45,990
progress then we have no way of

181
00:05:45,990 --> 00:05:47,850
servicing new requests let's say your

182
00:05:47,850 --> 00:05:49,350
network settings demon tries to parse

183
00:05:49,350 --> 00:05:52,110
some kind of ipv6 subnet mask for an IP

184
00:05:52,110 --> 00:05:55,950
that is just a single IP and while it's

185
00:05:55,950 --> 00:05:57,510
trying to parse that into a net mask it

186
00:05:57,510 --> 00:05:59,640
goes into an infinite loop and now none

187
00:05:59,640 --> 00:06:00,870
of the other requests coming into your

188
00:06:00,870 --> 00:06:01,920
network daemon have a way of being

189
00:06:01,920 --> 00:06:03,720
serviced that's a huge issue and

190
00:06:03,720 --> 00:06:04,920
something that a resilience feature

191
00:06:04,920 --> 00:06:06,480
could actually solve and would be able

192
00:06:06,480 --> 00:06:08,700
to restart that service how about

193
00:06:08,700 --> 00:06:10,680
pathological devices these things exist

194
00:06:10,680 --> 00:06:11,940
right our motherboard is covered in

195
00:06:11,940 --> 00:06:14,100
devices that talk over I squares see

196
00:06:14,100 --> 00:06:15,960
talk over one wire all sorts of

197
00:06:15,960 --> 00:06:18,930
protocols and they all inevitably have

198
00:06:18,930 --> 00:06:20,760
some sorts of pathological behavior in

199
00:06:20,760 --> 00:06:22,590
certain cases where they will just make

200
00:06:22,590 --> 00:06:24,420
the bus take forever and just maybe not

201
00:06:24,420 --> 00:06:26,940
respond to messages at all or you have

202
00:06:26,940 --> 00:06:29,160
C++ code it would be really nice if we

203
00:06:29,160 --> 00:06:30,660
were writing in safe languages like rust

204
00:06:30,660 --> 00:06:32,040
or go or something but right now we're

205
00:06:32,040 --> 00:06:33,690
not I mean that's that's a dream it'd be

206
00:06:33,690 --> 00:06:35,460
awesome but we're writing a lot of code

207
00:06:35,460 --> 00:06:36,420
and C and C++

208
00:06:36,420 --> 00:06:39,000
and there are there's a lot of easy ways

209
00:06:39,000 --> 00:06:40,530
to create undefined behavior and there

210
00:06:40,530 --> 00:06:40,920
are ways to

211
00:06:40,920 --> 00:06:43,170
crash the code and it happens if you

212
00:06:43,170 --> 00:06:44,850
introduce exceptions in C++ and you're

213
00:06:44,850 --> 00:06:46,500
not catching them for example that's

214
00:06:46,500 --> 00:06:48,360
something we did and it did cause a lot

215
00:06:48,360 --> 00:06:49,740
of demons to crash and it's really nice

216
00:06:49,740 --> 00:06:51,170
if you can recover from those crashes

217
00:06:51,170 --> 00:06:53,790
the IPM ID being unavailable for long

218
00:06:53,790 --> 00:06:55,410
periods of time this makes the BMC in

219
00:06:55,410 --> 00:06:57,510
our instance look like it's down and so

220
00:06:57,510 --> 00:06:59,040
we really want to make sure that we have

221
00:06:59,040 --> 00:07:01,350
some mechanism to guarantee that all of

222
00:07:01,350 --> 00:07:02,370
our demons are making forward progress

223
00:07:02,370 --> 00:07:03,960
because if you're not making forward

224
00:07:03,960 --> 00:07:06,900
progress then you have no way of being

225
00:07:06,900 --> 00:07:08,580
able to service any new requests and

226
00:07:08,580 --> 00:07:11,880
perform critical features corruption in

227
00:07:11,880 --> 00:07:13,140
the redirect file system file systems

228
00:07:13,140 --> 00:07:15,450
are hard devices that store data are

229
00:07:15,450 --> 00:07:18,510
notoriously bad at storing data and this

230
00:07:18,510 --> 00:07:20,400
is something where we have all sorts of

231
00:07:20,400 --> 00:07:22,350
we've seen this manifest in all sorts of

232
00:07:22,350 --> 00:07:24,660
ways in the past one of these ways is if

233
00:07:24,660 --> 00:07:26,520
the super blocks for JFS to get

234
00:07:26,520 --> 00:07:28,050
corrupted then you have no way being

235
00:07:28,050 --> 00:07:30,060
able to boot the BMC because this

236
00:07:30,060 --> 00:07:31,890
readwrite filesystem overlay is

237
00:07:31,890 --> 00:07:34,560
completely borked and unable to run and

238
00:07:34,560 --> 00:07:36,180
same with filling up the filesystem you

239
00:07:36,180 --> 00:07:37,170
need to make sure that you have

240
00:07:37,170 --> 00:07:39,120
constraints in place quotas to make sure

241
00:07:39,120 --> 00:07:40,680
the generated data doesn't take

242
00:07:40,680 --> 00:07:42,270
precedence over immutable data and

243
00:07:42,270 --> 00:07:43,590
things that are actually critical to

244
00:07:43,590 --> 00:07:45,380
system function and then you have

245
00:07:45,380 --> 00:07:47,430
corruption of runtime services or memory

246
00:07:47,430 --> 00:07:49,200
this is fairly straightforward this is

247
00:07:49,200 --> 00:07:51,390
basically use ECC memory it's something

248
00:07:51,390 --> 00:07:52,680
that is available and all the BMC

249
00:07:52,680 --> 00:07:54,480
platforms today and it's something that

250
00:07:54,480 --> 00:07:55,890
you should actually make sure you enable

251
00:07:55,890 --> 00:07:57,360
because when you deploy enough of them

252
00:07:57,360 --> 00:08:00,210
you'll end up eventually seeing bit

253
00:08:00,210 --> 00:08:02,700
errors in your memory so I'd like to

254
00:08:02,700 --> 00:08:04,260
start with the system be focused because

255
00:08:04,260 --> 00:08:06,600
we're so heavily systemd based I'd like

256
00:08:06,600 --> 00:08:07,740
to highlight some of the things we're

257
00:08:07,740 --> 00:08:09,600
already doing and then some of the

258
00:08:09,600 --> 00:08:11,040
features we could be using but I'd like

259
00:08:11,040 --> 00:08:12,750
to see use more that would actually fix

260
00:08:12,750 --> 00:08:13,890
some of the bugs that we've seen in the

261
00:08:13,890 --> 00:08:16,230
past so the restart equals directive

262
00:08:16,230 --> 00:08:18,240
this is something where when you create

263
00:08:18,240 --> 00:08:20,160
a service definition and system D you

264
00:08:20,160 --> 00:08:21,750
can tell it that any time it sees a

265
00:08:21,750 --> 00:08:23,370
failure or just always any time the

266
00:08:23,370 --> 00:08:25,410
service exits or changes State go back

267
00:08:25,410 --> 00:08:26,910
and restart it so it ensures that the

268
00:08:26,910 --> 00:08:29,190
thing is always running you can perform

269
00:08:29,190 --> 00:08:31,260
actions if the service fails so you

270
00:08:31,260 --> 00:08:33,299
could say if the service fails it's a

271
00:08:33,299 --> 00:08:34,799
really critical service it's the IPMI

272
00:08:34,799 --> 00:08:36,240
daemon it's the only way into the system

273
00:08:36,240 --> 00:08:38,309
make sure that when it fails you just

274
00:08:38,309 --> 00:08:39,840
reboot the system and try again just

275
00:08:39,840 --> 00:08:41,159
bring everything down bring it all back

276
00:08:41,159 --> 00:08:42,900
up and you can implement fallback

277
00:08:42,900 --> 00:08:44,310
services with those same actions it

278
00:08:44,310 --> 00:08:45,420
actually allows you to start any

279
00:08:45,420 --> 00:08:47,540
arbitrary system d-unit or service

280
00:08:47,540 --> 00:08:49,950
watchdog's great thing that system D

281
00:08:49,950 --> 00:08:52,740
provides you can have a notify socket

282
00:08:52,740 --> 00:08:54,150
pass to you and that will allow your

283
00:08:54,150 --> 00:08:55,800
service to be watched by the service

284
00:08:55,800 --> 00:08:57,480
manager and if you stop making progress

285
00:08:57,480 --> 00:08:59,340
and you stop petting that watchdog then

286
00:08:59,340 --> 00:09:00,270
you'll be able to have the service

287
00:09:00,270 --> 00:09:02,190
automatically restarted for you

288
00:09:02,190 --> 00:09:04,230
and then systemd also provides the

289
00:09:04,230 --> 00:09:05,850
option to control the system watchdog

290
00:09:05,850 --> 00:09:07,230
which I don't think is enabled by

291
00:09:07,230 --> 00:09:08,730
default on all of our platforms and it

292
00:09:08,730 --> 00:09:10,440
should be this is sort of that same

293
00:09:10,440 --> 00:09:12,060
thing where if for whatever reason

294
00:09:12,060 --> 00:09:14,310
system D stops making progress itself in

295
00:09:14,310 --> 00:09:15,900
monitoring the system then the system is

296
00:09:15,900 --> 00:09:18,330
able to kick itself and restart and

297
00:09:18,330 --> 00:09:19,950
really just check out the main pages

298
00:09:19,950 --> 00:09:22,110
form or the man pages for system D are

299
00:09:22,110 --> 00:09:24,750
fantastic they cover a ton of different

300
00:09:24,750 --> 00:09:26,130
options and there's always more being

301
00:09:26,130 --> 00:09:27,630
added and so this is definitely not

302
00:09:27,630 --> 00:09:28,380
comprehensive

303
00:09:28,380 --> 00:09:30,900
um so service restart let's say we have

304
00:09:30,900 --> 00:09:32,790
a crash e demon and I just call it crash

305
00:09:32,790 --> 00:09:35,370
ET because I'm boring and this thing

306
00:09:35,370 --> 00:09:38,100
always just exits at some point during

307
00:09:38,100 --> 00:09:40,050
its runtime and so what we want to do is

308
00:09:40,050 --> 00:09:41,520
we want to make sure that anytime we see

309
00:09:41,520 --> 00:09:44,210
the bad exit you know let's say it gets

310
00:09:44,210 --> 00:09:46,920
sig term or something randomly from

311
00:09:46,920 --> 00:09:48,420
somewhere else and it breaks or it's

312
00:09:48,420 --> 00:09:52,230
just has some kind of memory exception

313
00:09:52,230 --> 00:09:54,510
we want to make sure that we restart

314
00:09:54,510 --> 00:09:55,890
that anytime we see those conditions

315
00:09:55,890 --> 00:09:57,930
this is actually already pretty widely

316
00:09:57,930 --> 00:09:59,580
implemented in BMC if you go and you

317
00:09:59,580 --> 00:10:01,020
look at the service definitions in our

318
00:10:01,020 --> 00:10:03,150
repos you'll see that the restart equals

319
00:10:03,150 --> 00:10:04,650
something usually I think it's always

320
00:10:04,650 --> 00:10:06,870
for our demons but on failure is also a

321
00:10:06,870 --> 00:10:08,520
pretty reasonable option especially if

322
00:10:08,520 --> 00:10:10,050
you don't expect the success condition

323
00:10:10,050 --> 00:10:12,930
to ever happen the exit code is zero and

324
00:10:12,930 --> 00:10:14,550
this is nice because it requires no code

325
00:10:14,550 --> 00:10:16,080
changes all you have to do is update

326
00:10:16,080 --> 00:10:18,390
your system do service schemas and it

327
00:10:18,390 --> 00:10:19,500
really is helpful if you have

328
00:10:19,500 --> 00:10:21,300
intermittent crashes but it's not great

329
00:10:21,300 --> 00:10:23,190
if your code crashes immediately its

330
00:10:23,190 --> 00:10:25,200
startup continually because that would

331
00:10:25,200 --> 00:10:26,580
just cause the system to continually try

332
00:10:26,580 --> 00:10:28,500
over and over and over and over again to

333
00:10:28,500 --> 00:10:30,780
restart now system D isn't actually that

334
00:10:30,780 --> 00:10:33,120
naive it does actually have a limit I

335
00:10:33,120 --> 00:10:35,700
think it's like five starts every 30

336
00:10:35,700 --> 00:10:36,780
seconds and there are actually two

337
00:10:36,780 --> 00:10:38,430
parameters that control this they even

338
00:10:38,430 --> 00:10:40,290
tweak for the service so there's the

339
00:10:40,290 --> 00:10:41,610
start limit interval and there's a start

340
00:10:41,610 --> 00:10:43,590
limit burst and that kind of controls

341
00:10:43,590 --> 00:10:45,180
how often they will allow the service

342
00:10:45,180 --> 00:10:46,980
Weaver started before it says hey this

343
00:10:46,980 --> 00:10:48,750
thing isn't gonna start why would X plus

344
00:10:48,750 --> 00:10:50,520
one start if all X times didn't start

345
00:10:50,520 --> 00:10:52,560
let's just kill it and say it failed and

346
00:10:52,560 --> 00:10:53,970
then you report that to the journal and

347
00:10:53,970 --> 00:10:55,140
if you query the status of the service

348
00:10:55,140 --> 00:10:57,690
you'll see it in a failed state and I

349
00:10:57,690 --> 00:10:58,770
think this is something that's actually

350
00:10:58,770 --> 00:11:00,330
really important to keep in mind if

351
00:11:00,330 --> 00:11:02,190
you're designing demons that manage

352
00:11:02,190 --> 00:11:04,200
demons so in our case we have a network

353
00:11:04,200 --> 00:11:06,630
settings daemon that leverages system d

354
00:11:06,630 --> 00:11:07,440
network deed

355
00:11:07,440 --> 00:11:09,000
do all of its communication and so

356
00:11:09,000 --> 00:11:11,430
anytime any of the configuration changes

357
00:11:11,430 --> 00:11:13,350
in the network settings daemon it goes

358
00:11:13,350 --> 00:11:15,360
to system D Network D and it writes out

359
00:11:15,360 --> 00:11:17,310
the files and it restarts it but if you

360
00:11:17,310 --> 00:11:19,560
do this too many times so if you a bunch

361
00:11:19,560 --> 00:11:21,330
of network settings changes over IPMI

362
00:11:21,330 --> 00:11:23,520
and it doesn't coalesce them into one

363
00:11:23,520 --> 00:11:25,080
change then it will actually end up

364
00:11:25,080 --> 00:11:26,610
restarting the service a bunch of times

365
00:11:26,610 --> 00:11:28,380
in a burst and you'll hit the same limit

366
00:11:28,380 --> 00:11:30,060
so you need to be really careful if you

367
00:11:30,060 --> 00:11:32,040
do expect the daemon to restart and have

368
00:11:32,040 --> 00:11:33,930
changed behavior you need to reset these

369
00:11:33,930 --> 00:11:35,130
counters on the thing and it's something

370
00:11:35,130 --> 00:11:36,630
that we actually added fairly recently

371
00:11:36,630 --> 00:11:39,300
to the network settings daemon and then

372
00:11:39,300 --> 00:11:40,800
there's just unit failure options so you

373
00:11:40,800 --> 00:11:42,960
have your crashy daemon and it's so

374
00:11:42,960 --> 00:11:44,910
important to you that if you ever see it

375
00:11:44,910 --> 00:11:46,410
fails so it tries to restart it a couple

376
00:11:46,410 --> 00:11:48,570
times but eventually it hits that burst

377
00:11:48,570 --> 00:11:50,790
limit and then it fails and on the

378
00:11:50,790 --> 00:11:52,410
failure action what it will do is it

379
00:11:52,410 --> 00:11:53,850
will reboot the system so you have a

380
00:11:53,850 --> 00:11:55,110
couple of things you can do here they're

381
00:11:55,110 --> 00:11:57,090
fairly hard-coded one of them is power

382
00:11:57,090 --> 00:11:59,220
off one of them is reboot and the other

383
00:11:59,220 --> 00:12:01,860
is a exec and do a different kernel so

384
00:12:01,860 --> 00:12:03,810
it's really like you're just halt the

385
00:12:03,810 --> 00:12:05,220
whole system go and do something else

386
00:12:05,220 --> 00:12:07,050
type actions and there are different

387
00:12:07,050 --> 00:12:08,400
severity levels so in this case this is

388
00:12:08,400 --> 00:12:10,410
the force you could say immediate so it

389
00:12:10,410 --> 00:12:11,610
won't even sync the files as long as

390
00:12:11,610 --> 00:12:13,620
it'll just kill it'll just trigger the

391
00:12:13,620 --> 00:12:16,080
watchdog on the system cf9 whatever

392
00:12:16,080 --> 00:12:18,540
it'll just kill the whole thing and this

393
00:12:18,540 --> 00:12:20,640
is great for your very critical demons I

394
00:12:20,640 --> 00:12:22,350
would avoid trying to implement this

395
00:12:22,350 --> 00:12:24,120
widely because if you have something

396
00:12:24,120 --> 00:12:25,350
that's not critical like you have your

397
00:12:25,350 --> 00:12:27,030
temperature sensor daemon and it's

398
00:12:27,030 --> 00:12:28,560
monitoring a temperature and it crashes

399
00:12:28,560 --> 00:12:31,170
who cares if the temperature for some

400
00:12:31,170 --> 00:12:33,060
probe on the board decides to die off

401
00:12:33,060 --> 00:12:34,410
you don't want to have the whole BMC

402
00:12:34,410 --> 00:12:36,540
restart and then wait whole two minutes

403
00:12:36,540 --> 00:12:37,920
or something for the BMC to come back

404
00:12:37,920 --> 00:12:40,200
you could very easily cause yourself a

405
00:12:40,200 --> 00:12:41,700
denial of service and the BMC and then

406
00:12:41,700 --> 00:12:43,050
you wouldn't be able to obtain or do

407
00:12:43,050 --> 00:12:46,590
anything anymore there's also the

408
00:12:46,590 --> 00:12:48,540
ability to do a fallback action so this

409
00:12:48,540 --> 00:12:50,670
is like a more generalized version of

410
00:12:50,670 --> 00:12:53,130
the previous action and so instead of

411
00:12:53,130 --> 00:12:54,720
saying I want to reboot the system you

412
00:12:54,720 --> 00:12:56,820
could say I want to start a different

413
00:12:56,820 --> 00:12:59,820
service that maybe is less crashy so in

414
00:12:59,820 --> 00:13:01,380
this example we have a less crashy

415
00:13:01,380 --> 00:13:03,780
service you know in the real world we

416
00:13:03,780 --> 00:13:05,490
could use this with IBM ID we can have

417
00:13:05,490 --> 00:13:07,230
an IPM ID that's like a fallback or a

418
00:13:07,230 --> 00:13:09,630
recovery IPM ID and then in that case

419
00:13:09,630 --> 00:13:11,160
you would design it to be very small

420
00:13:11,160 --> 00:13:12,720
only handle the critical functions that

421
00:13:12,720 --> 00:13:14,220
you need and make sure that it's not

422
00:13:14,220 --> 00:13:15,720
servicing anything that's extraneous

423
00:13:15,720 --> 00:13:17,400
that might cause it to crash and so by

424
00:13:17,400 --> 00:13:19,560
reducing the code surface in your less

425
00:13:19,560 --> 00:13:20,880
crash you fall back

426
00:13:20,880 --> 00:13:23,220
you'll be able to recover it's important

427
00:13:23,220 --> 00:13:25,140
probably that if you do fall back into

428
00:13:25,140 --> 00:13:26,460
one of these modes you have some way of

429
00:13:26,460 --> 00:13:28,740
knowing typically like if it was

430
00:13:28,740 --> 00:13:30,150
something like ipmi D you would just

431
00:13:30,150 --> 00:13:31,530
start seeing all of the commands that

432
00:13:31,530 --> 00:13:33,570
you don't need erroring out with some

433
00:13:33,570 --> 00:13:35,490
non implemented type error just a system

434
00:13:35,490 --> 00:13:38,100
error and this I think in general will

435
00:13:38,100 --> 00:13:39,840
be very useful but it does require you

436
00:13:39,840 --> 00:13:41,760
to create code so it does not require

437
00:13:41,760 --> 00:13:44,400
code changes to your main daemon so your

438
00:13:44,400 --> 00:13:46,410
crashy D or whatever but if you were

439
00:13:46,410 --> 00:13:47,670
going to implement some kind of fall

440
00:13:47,670 --> 00:13:49,350
back then it would actually require you

441
00:13:49,350 --> 00:13:51,660
to make a whole bunch of new code or

442
00:13:51,660 --> 00:13:53,160
create some kind of build options to be

443
00:13:53,160 --> 00:13:55,050
able to reduce the functionality or code

444
00:13:55,050 --> 00:13:56,790
service of the original crashy daemon

445
00:13:56,790 --> 00:13:59,550
and for non-critical services this may

446
00:13:59,550 --> 00:14:01,080
be too much overhead you may not want to

447
00:14:01,080 --> 00:14:02,460
provide all of these different options

448
00:14:02,460 --> 00:14:04,350
but I think for something that's really

449
00:14:04,350 --> 00:14:06,390
core to your functionality and has a

450
00:14:06,390 --> 00:14:08,160
whole bunch of extraneous code that you

451
00:14:08,160 --> 00:14:09,600
don't necessarily need to recover a

452
00:14:09,600 --> 00:14:11,370
system you may want to consider doing

453
00:14:11,370 --> 00:14:14,070
something with a fall out here and then

454
00:14:14,070 --> 00:14:15,270
the other thing that system D provides

455
00:14:15,270 --> 00:14:17,250
is a service watchdog so let's say you

456
00:14:17,250 --> 00:14:18,390
create the infinite loop and your

457
00:14:18,390 --> 00:14:20,700
service again and the service stops

458
00:14:20,700 --> 00:14:22,260
making progress that stops funding on

459
00:14:22,260 --> 00:14:24,120
d-bus and that causes the whole system

460
00:14:24,120 --> 00:14:25,560
to become really sluggish and start

461
00:14:25,560 --> 00:14:27,150
timeing out all the D bus requests

462
00:14:27,150 --> 00:14:28,740
that's service and just become generally

463
00:14:28,740 --> 00:14:31,010
unserviceable for that specific action

464
00:14:31,010 --> 00:14:34,230
if you have a service of type notify and

465
00:14:34,230 --> 00:14:36,120
you get this notification socket pass

466
00:14:36,120 --> 00:14:38,160
from system D the service can request

467
00:14:38,160 --> 00:14:39,930
system D and it can say hey and able to

468
00:14:39,930 --> 00:14:41,400
watchdog with a certain timeout so you

469
00:14:41,400 --> 00:14:43,110
say you send it this variable called

470
00:14:43,110 --> 00:14:45,270
watchdog you sick over the socket you

471
00:14:45,270 --> 00:14:46,920
pass it the actual you set parameter

472
00:14:46,920 --> 00:14:48,720
after it's like a key value pair thing

473
00:14:48,720 --> 00:14:50,670
but it's all straightforward if you look

474
00:14:50,670 --> 00:14:52,710
at the man page for SD underscore notify

475
00:14:52,710 --> 00:14:55,170
and or you just use something like SD

476
00:14:55,170 --> 00:14:57,780
event press d event plus you pass it

477
00:14:57,780 --> 00:15:00,780
this you set timeout and then every

478
00:15:00,780 --> 00:15:03,030
couple periods in that interval you go

479
00:15:03,030 --> 00:15:04,770
and you pet the watchdog so as long as

480
00:15:04,770 --> 00:15:06,780
you're petting the watchdog maybe three

481
00:15:06,780 --> 00:15:08,700
times as often as your timeout you

482
00:15:08,700 --> 00:15:10,230
should be okay and it'll know that your

483
00:15:10,230 --> 00:15:11,610
service is continually making progress

484
00:15:11,610 --> 00:15:13,830
and so if you're using an event loop

485
00:15:13,830 --> 00:15:16,470
something where any one transaction

486
00:15:16,470 --> 00:15:17,970
could cause the entire event loop to

487
00:15:17,970 --> 00:15:19,920
stop this will protect you from those

488
00:15:19,920 --> 00:15:21,480
cases and it will be able to restart the

489
00:15:21,480 --> 00:15:23,070
service anytime the watchdog stops being

490
00:15:23,070 --> 00:15:25,050
pet like I said if you're using SD event

491
00:15:25,050 --> 00:15:26,640
or SD event plus this is built-in all

492
00:15:26,640 --> 00:15:28,020
you have to do is say

493
00:15:28,020 --> 00:15:30,030
SD event and they belong and it will

494
00:15:30,030 --> 00:15:31,380
enable the watchdog with the timeout you

495
00:15:31,380 --> 00:15:33,089
give it and it will handle all that for

496
00:15:33,089 --> 00:15:34,660
you and has like an internal event so

497
00:15:34,660 --> 00:15:37,959
that's able to be run every so often in

498
00:15:37,959 --> 00:15:39,399
the event loop and make sure that that

499
00:15:39,399 --> 00:15:40,720
is actually going and updating your

500
00:15:40,720 --> 00:15:42,730
watchdog there's no reason you couldn't

501
00:15:42,730 --> 00:15:44,500
retrofit any other event loop is support

502
00:15:44,500 --> 00:15:45,970
this thing we have a lot of a CO code

503
00:15:45,970 --> 00:15:48,129
that's out there and you could plumb

504
00:15:48,129 --> 00:15:49,779
this in as some sort of source within

505
00:15:49,779 --> 00:15:51,579
the Ezio framework that just goes and

506
00:15:51,579 --> 00:15:53,709
make sure on some kind of timeout it

507
00:15:53,709 --> 00:15:55,269
runs us to notifying it tests the

508
00:15:55,269 --> 00:15:57,910
watchdog for you so this is kind of a

509
00:15:57,910 --> 00:15:59,259
minor code change but I think it's

510
00:15:59,259 --> 00:16:00,550
fairly easy especially if you're already

511
00:16:00,550 --> 00:16:02,740
using one of the standard lip system the

512
00:16:02,740 --> 00:16:04,540
event loops and so I think it's kind of

513
00:16:04,540 --> 00:16:07,629
a win in the short term and then this is

514
00:16:07,629 --> 00:16:09,250
sort of a harder problem we have a whole

515
00:16:09,250 --> 00:16:10,629
bunch of single points of failure as

516
00:16:10,629 --> 00:16:12,490
we're seeing in that diagram so I like

517
00:16:12,490 --> 00:16:14,439
to pick on IPM ID here because this is

518
00:16:14,439 --> 00:16:16,449
the one that has a lot of code and it's

519
00:16:16,449 --> 00:16:18,579
one of the core critical pieces that we

520
00:16:18,579 --> 00:16:20,980
need to perform like system resets and

521
00:16:20,980 --> 00:16:22,750
get the controller info and do updates

522
00:16:22,750 --> 00:16:26,050
and it ends up having a myriad of issues

523
00:16:26,050 --> 00:16:27,910
when we deploy it widely and start

524
00:16:27,910 --> 00:16:30,160
really stressing it out and so this is

525
00:16:30,160 --> 00:16:32,259
something where if you have a whole

526
00:16:32,259 --> 00:16:35,620
bunch of communications happening to a

527
00:16:35,620 --> 00:16:38,769
single demon on your bus and it performs

528
00:16:38,769 --> 00:16:41,139
blocking calls it's only able to service

529
00:16:41,139 --> 00:16:42,759
one of those things at a time if you're

530
00:16:42,759 --> 00:16:44,500
not using POSIX threads or something

531
00:16:44,500 --> 00:16:44,860
like that

532
00:16:44,860 --> 00:16:46,839
any time you block you're preventing any

533
00:16:46,839 --> 00:16:48,550
other work from being done and so your

534
00:16:48,550 --> 00:16:50,350
demon is waiting on i/o for something

535
00:16:50,350 --> 00:16:51,670
that it doesn't need to actually wait

536
00:16:51,670 --> 00:16:53,079
for it could be servicing other requests

537
00:16:53,079 --> 00:16:54,939
have nothing to do aren't actually

538
00:16:54,939 --> 00:16:56,350
mutually exclusive to the requests being

539
00:16:56,350 --> 00:16:58,389
processed and it means that if you have

540
00:16:58,389 --> 00:17:00,819
a huge queue of IPMI traffic that's

541
00:17:00,819 --> 00:17:02,500
servicing sensor reads and your sensors

542
00:17:02,500 --> 00:17:04,000
are for some reason taking forever to

543
00:17:04,000 --> 00:17:06,490
read because you have some wonky sensors

544
00:17:06,490 --> 00:17:08,559
or the colonel's kind of busted or who

545
00:17:08,559 --> 00:17:10,390
knows there's a whole bunch of reasons

546
00:17:10,390 --> 00:17:12,250
why your sensors might be flaky they are

547
00:17:12,250 --> 00:17:14,500
external devices after all but that

548
00:17:14,500 --> 00:17:16,299
means that your hosts watchdog isn't

549
00:17:16,299 --> 00:17:18,429
able to be pet because your IPM IQ is

550
00:17:18,429 --> 00:17:19,839
backed up by all of these sensor

551
00:17:19,839 --> 00:17:21,640
transactions and so eventually what

552
00:17:21,640 --> 00:17:23,349
happens is the sensors take all this

553
00:17:23,349 --> 00:17:25,329
time the watchdog never gets pet and the

554
00:17:25,329 --> 00:17:26,829
watchdog eventually trips and there and

555
00:17:26,829 --> 00:17:29,770
also it's a trouble or it just makes it

556
00:17:29,770 --> 00:17:31,419
really hard for you to reset the host or

557
00:17:31,419 --> 00:17:32,770
makes it really hard for you to upgrade

558
00:17:32,770 --> 00:17:34,480
the system because those upgrade

559
00:17:34,480 --> 00:17:36,520
commands take forever it is start timing

560
00:17:36,520 --> 00:17:38,289
out and so it's really important in

561
00:17:38,289 --> 00:17:40,150
general that we sort of reduce these

562
00:17:40,150 --> 00:17:42,220
points of congestion and I think that we

563
00:17:42,220 --> 00:17:43,840
are doing a pretty good job we are kind

564
00:17:43,840 --> 00:17:45,220
of working our way there

565
00:17:45,220 --> 00:17:47,500
and this isn't exclusive to just the

566
00:17:47,500 --> 00:17:48,520
system services that we do

567
00:17:48,520 --> 00:17:50,830
this also includes the colonel Colonel

568
00:17:50,830 --> 00:17:52,870
drivers have probe functions and it

569
00:17:52,870 --> 00:17:54,280
turns out that if the colonel drivers

570
00:17:54,280 --> 00:17:55,870
don't specify that they are a sync

571
00:17:55,870 --> 00:17:57,970
compatible their probes run in serial

572
00:17:57,970 --> 00:17:59,650
and if you set up a device tree that's

573
00:17:59,650 --> 00:18:01,330
processed and starts probing at the

574
00:18:01,330 --> 00:18:02,950
beginning of boot what happens is your

575
00:18:02,950 --> 00:18:04,390
probe functions actually hold up you're

576
00:18:04,390 --> 00:18:05,890
in it and everything else in the system

577
00:18:05,890 --> 00:18:09,340
and so if you have some wonky voltage

578
00:18:09,340 --> 00:18:10,660
regulator that tries to report your

579
00:18:10,660 --> 00:18:12,010
voltages and you need that probe

580
00:18:12,010 --> 00:18:14,230
function to read the version of that

581
00:18:14,230 --> 00:18:15,790
voltage regulator to know how to handle

582
00:18:15,790 --> 00:18:18,670
it then what ends up happening is your

583
00:18:18,670 --> 00:18:20,350
boot gets held up for 200 seconds

584
00:18:20,350 --> 00:18:21,880
because it's trying to read the version

585
00:18:21,880 --> 00:18:23,620
of this voltage regulator and not doing

586
00:18:23,620 --> 00:18:26,470
anything else and honestly if you want

587
00:18:26,470 --> 00:18:28,330
to be able to talk to the ipmi daemon or

588
00:18:28,330 --> 00:18:30,310
manage some of this system VMC services

589
00:18:30,310 --> 00:18:32,800
or manage those power control or deal

590
00:18:32,800 --> 00:18:34,120
with the watchdog none of that is

591
00:18:34,120 --> 00:18:36,160
actually relevant to you you don't need

592
00:18:36,160 --> 00:18:38,320
this one sensor that has no relevant

593
00:18:38,320 --> 00:18:39,700
information to the critical paths in

594
00:18:39,700 --> 00:18:41,980
your boot and so in general I think

595
00:18:41,980 --> 00:18:44,230
having the colonel do more things

596
00:18:44,230 --> 00:18:45,790
asynchronously in terms of probing when

597
00:18:45,790 --> 00:18:48,430
you really mess and so this kind of

598
00:18:48,430 --> 00:18:50,110
boils into the next point which is a

599
00:18:50,110 --> 00:18:51,430
sink request handling I think we're

600
00:18:51,430 --> 00:18:52,660
getting there I think we're sort of

601
00:18:52,660 --> 00:18:54,490
doing a good job but it's one of those

602
00:18:54,490 --> 00:18:56,320
things where as we start having more of

603
00:18:56,320 --> 00:18:57,880
these applications that are using event

604
00:18:57,880 --> 00:18:59,500
loops we need to make sure that we're

605
00:18:59,500 --> 00:19:01,210
never blocking on calls that we don't

606
00:19:01,210 --> 00:19:02,980
need to so if you're making d-bus calls

607
00:19:02,980 --> 00:19:04,840
you really ought to make them async as

608
00:19:04,840 --> 00:19:06,910
much as possible that way other work

609
00:19:06,910 --> 00:19:08,740
that isn't actually dependent on those

610
00:19:08,740 --> 00:19:10,150
calls being made can be done in the

611
00:19:10,150 --> 00:19:11,770
background and so you can actually

612
00:19:11,770 --> 00:19:14,260
thread effectively thread out to doing

613
00:19:14,260 --> 00:19:15,370
moldable requests but really you're

614
00:19:15,370 --> 00:19:17,350
doing it a single thread and this is

615
00:19:17,350 --> 00:19:18,700
really a big issue when you have these

616
00:19:18,700 --> 00:19:20,770
aggregation points like ipm ID so you

617
00:19:20,770 --> 00:19:22,150
don't want your sensor calls that are

618
00:19:22,150 --> 00:19:23,680
going to false for hardware Mon to block

619
00:19:23,680 --> 00:19:25,060
up your calls that are setting network

620
00:19:25,060 --> 00:19:27,250
settings completely irrelevant and not

621
00:19:27,250 --> 00:19:30,250
actually necessary and in general I

622
00:19:30,250 --> 00:19:32,110
would say those are a less critical path

623
00:19:32,110 --> 00:19:34,270
than being able to upgrade or reset the

624
00:19:34,270 --> 00:19:35,980
system or get the version make sure IPM

625
00:19:35,980 --> 00:19:36,700
is alive

626
00:19:36,700 --> 00:19:38,410
do the watchdog actions those sorts of

627
00:19:38,410 --> 00:19:41,530
things um and I think the statements the

628
00:19:41,530 --> 00:19:43,510
state machine type of a sync is a good

629
00:19:43,510 --> 00:19:45,700
place to be in general I really wish we

630
00:19:45,700 --> 00:19:47,260
had something like rust where they build

631
00:19:47,260 --> 00:19:48,520
in the state machine is synchronous

632
00:19:48,520 --> 00:19:51,160
behavior for you but we're not there yet

633
00:19:51,160 --> 00:19:52,870
I don't know how hard it would be to

634
00:19:52,870 --> 00:19:54,610
actually get it working I got a hello

635
00:19:54,610 --> 00:19:56,650
world and rust working on the BMC and it

636
00:19:56,650 --> 00:19:59,350
was like 8k and I was really happy but I

637
00:19:59,350 --> 00:20:01,060
don't know how scalable that'll be once

638
00:20:01,060 --> 00:20:02,260
you start including a whole bunch of

639
00:20:02,260 --> 00:20:03,760
libraries that end up being statically

640
00:20:03,760 --> 00:20:05,950
linked into single rust binaries and so

641
00:20:05,950 --> 00:20:07,210
that's something to investigate but I

642
00:20:07,210 --> 00:20:09,370
think going down the path of using us

643
00:20:09,370 --> 00:20:10,810
the event or a CEO or any of these

644
00:20:10,810 --> 00:20:12,910
things is generally good and will allow

645
00:20:12,910 --> 00:20:14,740
us to be more available and process more

646
00:20:14,740 --> 00:20:18,310
things simultaneously and this leaves us

647
00:20:18,310 --> 00:20:19,750
kind of in to file system issues so

648
00:20:19,750 --> 00:20:21,730
we've had a whole bunch of trouble and

649
00:20:21,730 --> 00:20:24,250
deployment where spy devices or drivers

650
00:20:24,250 --> 00:20:26,470
or anything in the stack that's under

651
00:20:26,470 --> 00:20:27,940
the file system ends up causing some

652
00:20:27,940 --> 00:20:29,440
kind of corruption at the block level

653
00:20:29,440 --> 00:20:32,620
and so what ends up happening is in the

654
00:20:32,620 --> 00:20:34,840
BMC right now the way open BMC's

655
00:20:34,840 --> 00:20:36,670
architected we have a read-only file

656
00:20:36,670 --> 00:20:37,900
system and we have a readwrite file

657
00:20:37,900 --> 00:20:40,030
system unfortunately they're overlaid on

658
00:20:40,030 --> 00:20:41,470
top of each other so the first thing it

659
00:20:41,470 --> 00:20:43,210
does before it calls into an it is it

660
00:20:43,210 --> 00:20:45,070
tries to mount both of them and so if

661
00:20:45,070 --> 00:20:46,630
for some reason your BMC decides it

662
00:20:46,630 --> 00:20:48,430
could corrupt the readwrite portion in

663
00:20:48,430 --> 00:20:50,470
some way like the GFS to metadata just

664
00:20:50,470 --> 00:20:53,020
gets corrupted the CRC's error out and

665
00:20:53,020 --> 00:20:54,880
it decides to not mount then your BMC is

666
00:20:54,880 --> 00:20:56,440
completely bricked unbootable you have

667
00:20:56,440 --> 00:20:58,090
to go in you have to do a chip swap or

668
00:20:58,090 --> 00:20:59,650
reflash the B and C or something along

669
00:20:59,650 --> 00:21:02,050
those lines and so maybe in the best

670
00:21:02,050 --> 00:21:03,400
case all that happens is you have data

671
00:21:03,400 --> 00:21:05,320
corruption ideally you'd have file

672
00:21:05,320 --> 00:21:06,880
systems that don't allow that but we're

673
00:21:06,880 --> 00:21:09,580
not there JFS to just has no checks

674
00:21:09,580 --> 00:21:11,590
something of your data and so if you

675
00:21:11,590 --> 00:21:13,360
write partial amounts of data then that

676
00:21:13,360 --> 00:21:14,950
may be what you get back you may get

677
00:21:14,950 --> 00:21:16,420
back complete garbage because the spy

678
00:21:16,420 --> 00:21:19,570
chip just hates you that day it's it's a

679
00:21:19,570 --> 00:21:20,710
kind of what you got to deal with

680
00:21:20,710 --> 00:21:22,660
unfortunately and then again the worst

681
00:21:22,660 --> 00:21:24,160
case metadata gets corrupted and you're

682
00:21:24,160 --> 00:21:26,470
unable to mount and so you probably need

683
00:21:26,470 --> 00:21:27,940
some way to recover from that scenario

684
00:21:27,940 --> 00:21:29,770
because you're gonna end up doing chip

685
00:21:29,770 --> 00:21:33,190
swaps otherwise and this is kind of a

686
00:21:33,190 --> 00:21:34,540
problem and then you also just have the

687
00:21:34,540 --> 00:21:36,070
file system becoming full something

688
00:21:36,070 --> 00:21:38,470
that's not great and so one thing would

689
00:21:38,470 --> 00:21:40,060
be more resilient file systems that'd be

690
00:21:40,060 --> 00:21:41,800
really nice maybe we have built in data

691
00:21:41,800 --> 00:21:43,630
integrity something like butter if SR

692
00:21:43,630 --> 00:21:45,070
ZFS I know some of us in the audience

693
00:21:45,070 --> 00:21:47,740
maybe not so hot on butter fests and

694
00:21:47,740 --> 00:21:49,360
these two file systems aren't great

695
00:21:49,360 --> 00:21:52,990
solutions I think in general on the BMC

696
00:21:52,990 --> 00:21:54,610
because you have such a small amount of

697
00:21:54,610 --> 00:21:56,020
Flash and you don't have a ton of RAM to

698
00:21:56,020 --> 00:21:57,700
begin with and so these are fairly

699
00:21:57,700 --> 00:21:59,290
heavyweight solutions that we may not

700
00:21:59,290 --> 00:22:01,150
actually be able to leverage but I think

701
00:22:01,150 --> 00:22:03,610
if we just try and J I think if someone

702
00:22:03,610 --> 00:22:05,860
were to build something it may not be

703
00:22:05,860 --> 00:22:07,390
fully POSIX compliant it may be some

704
00:22:07,390 --> 00:22:09,370
kind of key value store I think that

705
00:22:09,370 --> 00:22:10,600
could be useful if there was some way

706
00:22:10,600 --> 00:22:12,520
that we could provide really good data

707
00:22:12,520 --> 00:22:14,080
integrity in the small amount of space

708
00:22:14,080 --> 00:22:15,410
even if it's not terribly

709
00:22:15,410 --> 00:22:17,390
format random access I think that would

710
00:22:17,390 --> 00:22:19,450
be really nice and I think in general

711
00:22:19,450 --> 00:22:22,310
having something where we reduce the

712
00:22:22,310 --> 00:22:23,810
dependence on the mutable overlay would

713
00:22:23,810 --> 00:22:26,060
be good because that blocks us really

714
00:22:26,060 --> 00:22:27,590
early in the boot process and it locks

715
00:22:27,590 --> 00:22:28,850
us into needing that readwrite

716
00:22:28,850 --> 00:22:30,740
filesystem would be available if we can

717
00:22:30,740 --> 00:22:32,380
defer to later in the boot process

718
00:22:32,380 --> 00:22:34,790
opening up that readwrite FS and then

719
00:22:34,790 --> 00:22:36,170
having fewer dependencies on it I think

720
00:22:36,170 --> 00:22:38,360
that would be good the system defaults

721
00:22:38,360 --> 00:22:40,280
propose a stateless filesystem layout

722
00:22:40,280 --> 00:22:42,530
and I don't really necessarily care to

723
00:22:42,530 --> 00:22:44,090
be tied in to that specific layout but I

724
00:22:44,090 --> 00:22:45,590
think taking something where you have

725
00:22:45,590 --> 00:22:46,940
stateless components and then you have

726
00:22:46,940 --> 00:22:48,710
stateful components that are managed

727
00:22:48,710 --> 00:22:50,330
separately and not everything depends on

728
00:22:50,330 --> 00:22:51,980
the state for parts I think that would

729
00:22:51,980 --> 00:22:53,090
be really helpful because it allows you

730
00:22:53,090 --> 00:22:54,500
to get farther into the boot process

731
00:22:54,500 --> 00:22:55,940
before you have to deal with the fact

732
00:22:55,940 --> 00:22:57,620
that your read/write storage is actually

733
00:22:57,620 --> 00:23:00,080
corrupted but this would require some

734
00:23:00,080 --> 00:23:01,790
storage redefinition I'd like to

735
00:23:01,790 --> 00:23:03,170
actually start taking on this work and

736
00:23:03,170 --> 00:23:05,150
see how bad it would be if we just don't

737
00:23:05,150 --> 00:23:06,980
have a readwrite filesystem at all see

738
00:23:06,980 --> 00:23:08,900
what actually comes up start adding

739
00:23:08,900 --> 00:23:10,970
things like our Lib and bar log and Etsy

740
00:23:10,970 --> 00:23:13,190
to that readwrite space and see how much

741
00:23:13,190 --> 00:23:14,540
farther we get along those sorts of

742
00:23:14,540 --> 00:23:14,900
things

743
00:23:14,900 --> 00:23:17,570
but more importantly if your file system

744
00:23:17,570 --> 00:23:19,400
is completely corrupt you need to do

745
00:23:19,400 --> 00:23:21,140
something about it and so I think

746
00:23:21,140 --> 00:23:22,940
providing an image feature for just Auto

747
00:23:22,940 --> 00:23:24,800
purging if the file system is corrupt is

748
00:23:24,800 --> 00:23:26,510
a really good idea because otherwise

749
00:23:26,510 --> 00:23:27,950
you're just gonna get no feedback from

750
00:23:27,950 --> 00:23:29,150
the system if you're not monitoring the

751
00:23:29,150 --> 00:23:31,130
serial console or your some other kind

752
00:23:31,130 --> 00:23:32,570
of like out-of-band mechanism that's

753
00:23:32,570 --> 00:23:34,400
very low level to know if the BMC is

754
00:23:34,400 --> 00:23:36,440
hitting this really early on in boot you

755
00:23:36,440 --> 00:23:38,060
need it to just say ok the mutable data

756
00:23:38,060 --> 00:23:40,400
is not really that important we really

757
00:23:40,400 --> 00:23:41,720
want to recover the system get it back

758
00:23:41,720 --> 00:23:42,800
up and running and then we can reap

759
00:23:42,800 --> 00:23:45,220
revision things as necessary

760
00:23:45,220 --> 00:23:47,960
um and then once you do find that

761
00:23:47,960 --> 00:23:49,070
corruption and you eliminate it you

762
00:23:49,070 --> 00:23:50,810
purge it you do something about it you

763
00:23:50,810 --> 00:23:52,040
need a way to communicate that that's

764
00:23:52,040 --> 00:23:53,420
what happened because you need services

765
00:23:53,420 --> 00:23:54,530
to make sure that they Reaper vision

766
00:23:54,530 --> 00:23:56,150
their settings we would like to be able

767
00:23:56,150 --> 00:23:57,560
to emit logs but it's not that

768
00:23:57,560 --> 00:23:58,820
straightforward if you're doing it this

769
00:23:58,820 --> 00:24:00,860
early undo because your system D journal

770
00:24:00,860 --> 00:24:02,060
won't have a place to persist its

771
00:24:02,060 --> 00:24:03,290
journal it's not even actually running

772
00:24:03,290 --> 00:24:04,940
at this time and so we'll need to come

773
00:24:04,940 --> 00:24:06,410
up with some mechanism for communicating

774
00:24:06,410 --> 00:24:08,120
up the stack that we hit file system

775
00:24:08,120 --> 00:24:09,860
corruption and rependa resetting from

776
00:24:09,860 --> 00:24:13,220
factory defaults and I think in general

777
00:24:13,220 --> 00:24:14,810
our applications need to become better

778
00:24:14,810 --> 00:24:17,480
at handling corrupt data do we just

779
00:24:17,480 --> 00:24:19,430
ignore it and emit warnings I think

780
00:24:19,430 --> 00:24:21,350
right now in a lot of instances you'll

781
00:24:21,350 --> 00:24:23,000
see that applications when they get data

782
00:24:23,000 --> 00:24:24,170
off the disk that is kind of

783
00:24:24,170 --> 00:24:25,880
inconsistent especially from the

784
00:24:25,880 --> 00:24:27,830
readwrite portion they'll do something

785
00:24:27,830 --> 00:24:28,590
weird they'll cry

786
00:24:28,590 --> 00:24:30,210
we'll handle it poorly and I think in

787
00:24:30,210 --> 00:24:34,740
general they need to be more they need

788
00:24:34,740 --> 00:24:37,559
to hard panic less often and do things

789
00:24:37,559 --> 00:24:39,029
that tell you that the data is broken

790
00:24:39,029 --> 00:24:40,890
but they need to just kind of ignore it

791
00:24:40,890 --> 00:24:42,750
and move on and try and recover back to

792
00:24:42,750 --> 00:24:45,419
a sane working state and then another

793
00:24:45,419 --> 00:24:47,010
thing I noticed pretty commonly is that

794
00:24:47,010 --> 00:24:48,360
we're not implementing good right

795
00:24:48,360 --> 00:24:50,490
consistency we could use proven database

796
00:24:50,490 --> 00:24:52,529
formats which I realize aren't actually

797
00:24:52,529 --> 00:24:53,970
perfect using something like sequel Lite

798
00:24:53,970 --> 00:24:55,590
will make it better but it's not

799
00:24:55,590 --> 00:24:57,000
necessarily a given that it will work

800
00:24:57,000 --> 00:24:59,429
perfectly and then if you're writing

801
00:24:59,429 --> 00:25:01,260
text files that don't have some kind of

802
00:25:01,260 --> 00:25:02,940
journal schema or anything you need to

803
00:25:02,940 --> 00:25:04,230
make sure that you actually write those

804
00:25:04,230 --> 00:25:06,029
separately and don't overwrite the file

805
00:25:06,029 --> 00:25:07,409
that you're actually intending to update

806
00:25:07,409 --> 00:25:08,820
because some of the rights may not

807
00:25:08,820 --> 00:25:10,440
actually persist a disk if you have

808
00:25:10,440 --> 00:25:11,669
power loss or something along those

809
00:25:11,669 --> 00:25:14,220
lines and so you need to make sure that

810
00:25:14,220 --> 00:25:15,240
you're writing somewhere else

811
00:25:15,240 --> 00:25:17,070
and then using an atomic move over the

812
00:25:17,070 --> 00:25:19,110
file so that it's just a metadata update

813
00:25:19,110 --> 00:25:21,000
that Flitz the data into place and you

814
00:25:21,000 --> 00:25:22,350
don't have partial writes going along

815
00:25:22,350 --> 00:25:24,600
into the file and then not every one is

816
00:25:24,600 --> 00:25:26,279
similar needs maybe we want it to auto

817
00:25:26,279 --> 00:25:27,809
recover and blow away all the settings

818
00:25:27,809 --> 00:25:29,340
willy-nilly and that's okay

819
00:25:29,340 --> 00:25:31,890
but others may have use cases where they

820
00:25:31,890 --> 00:25:33,600
just want the BMC to open panic because

821
00:25:33,600 --> 00:25:35,460
they want to be able to diagnose go in

822
00:25:35,460 --> 00:25:37,980
root cause the issue and be able to see

823
00:25:37,980 --> 00:25:39,240
what happens and they don't want the

824
00:25:39,240 --> 00:25:41,190
files to be blown away and so I think

825
00:25:41,190 --> 00:25:43,440
that presenting these things as options

826
00:25:43,440 --> 00:25:45,570
at build time or his run time really

827
00:25:45,570 --> 00:25:46,799
build time configurable because if

828
00:25:46,799 --> 00:25:48,330
you're mutable state is completely

829
00:25:48,330 --> 00:25:50,130
broken you need some way to determine

830
00:25:50,130 --> 00:25:52,230
what action you're going to take and so

831
00:25:52,230 --> 00:25:53,909
having a build time configurable would

832
00:25:53,909 --> 00:25:56,159
be really nice for that and then what

833
00:25:56,159 --> 00:25:57,840
about free space I think a simple

834
00:25:57,840 --> 00:25:59,399
solution to this is just implementing

835
00:25:59,399 --> 00:26:01,529
some kind of quota system this is

836
00:26:01,529 --> 00:26:02,880
something that we don't currently have

837
00:26:02,880 --> 00:26:04,380
but I think would be really nice

838
00:26:04,380 --> 00:26:06,000
especially for those of us that are

839
00:26:06,000 --> 00:26:07,440
logging our journal to a persistent

840
00:26:07,440 --> 00:26:09,059
medium right now

841
00:26:09,059 --> 00:26:11,760
I think our distribution doesn't do any

842
00:26:11,760 --> 00:26:13,409
of this we put almost everything in ran

843
00:26:13,409 --> 00:26:14,970
because we don't trust ourselves with

844
00:26:14,970 --> 00:26:16,590
not filling up the rewrite file system

845
00:26:16,590 --> 00:26:18,000
but I think if we implement better

846
00:26:18,000 --> 00:26:19,799
policies it should be possible for us to

847
00:26:19,799 --> 00:26:22,200
store some of that data without filling

848
00:26:22,200 --> 00:26:23,370
up the entire thing and making the

849
00:26:23,370 --> 00:26:25,200
system completely unusable and so a

850
00:26:25,200 --> 00:26:26,490
trivial solution to make it more

851
00:26:26,490 --> 00:26:28,740
reliable would just be to say 70% of the

852
00:26:28,740 --> 00:26:30,990
space can be dedicated to this autofill

853
00:26:30,990 --> 00:26:33,240
generated data and then 30% of the space

854
00:26:33,240 --> 00:26:34,740
would be used for those things like user

855
00:26:34,740 --> 00:26:36,059
settings and stuff that's generally

856
00:26:36,059 --> 00:26:38,880
fairly small or has exercises and then

857
00:26:38,880 --> 00:26:40,530
this goes back to the monitoring

858
00:26:40,530 --> 00:26:42,360
question how do we know if we're

859
00:26:42,360 --> 00:26:43,770
running low on space I think right now

860
00:26:43,770 --> 00:26:44,640
we don't have a good communication

861
00:26:44,640 --> 00:26:46,200
mechanism for that and it's something

862
00:26:46,200 --> 00:26:47,490
that we really need to think about and

863
00:26:47,490 --> 00:26:51,870
consider which brings us to sort of the

864
00:26:51,870 --> 00:26:54,150
host watchdog issues now the host

865
00:26:54,150 --> 00:26:55,860
watchdog seems like something that's

866
00:26:55,860 --> 00:26:58,200
really simple to do all you have to be

867
00:26:58,200 --> 00:27:00,000
able to do is set the watchdog pet the

868
00:27:00,000 --> 00:27:02,310
watchdog and stop the watchdog and it's

869
00:27:02,310 --> 00:27:03,630
like three commands this should be

870
00:27:03,630 --> 00:27:05,190
really easy and it's something where a

871
00:27:05,190 --> 00:27:06,960
demon just has to implement a timer and

872
00:27:06,960 --> 00:27:08,430
wait and if it doesn't get pet then it

873
00:27:08,430 --> 00:27:10,170
trips the watchdog and it says okay I'm

874
00:27:10,170 --> 00:27:11,880
gonna restart the system or I'm gonna do

875
00:27:11,880 --> 00:27:13,320
nothing there are a couple actions it's

876
00:27:13,320 --> 00:27:15,450
not really that complicated if you just

877
00:27:15,450 --> 00:27:17,070
look at the spec and it seems really

878
00:27:17,070 --> 00:27:18,990
useful because every platform that

879
00:27:18,990 --> 00:27:20,940
supports ipmi supports this watchdog as

880
00:27:20,940 --> 00:27:22,590
long as your Linux kernel supports the

881
00:27:22,590 --> 00:27:24,420
ipmi driver you need and your watchdog

882
00:27:24,420 --> 00:27:26,460
stack on your Linux system supports the

883
00:27:26,460 --> 00:27:28,080
watchdog then it's really easy to

884
00:27:28,080 --> 00:27:29,610
support furthering your IBM power

885
00:27:29,610 --> 00:27:31,920
systems your Intel x86 systems and your

886
00:27:31,920 --> 00:27:33,390
AMD Exedy SiC systems or your arm

887
00:27:33,390 --> 00:27:35,190
systems whatever doesn't matter it's

888
00:27:35,190 --> 00:27:37,200
fairly ubiquitous to all of them whereas

889
00:27:37,200 --> 00:27:38,340
if you went to any one of those

890
00:27:38,340 --> 00:27:39,510
platforms and you wanted to use the

891
00:27:39,510 --> 00:27:40,920
platform watchdog you'd have to have a

892
00:27:40,920 --> 00:27:42,360
separate driver for each one because

893
00:27:42,360 --> 00:27:45,090
they're all unique the problem with this

894
00:27:45,090 --> 00:27:47,490
watchdog is the pipeline from the host

895
00:27:47,490 --> 00:27:48,960
all the way down to the BMC is

896
00:27:48,960 --> 00:27:50,850
incredibly complicated than anytime you

897
00:27:50,850 --> 00:27:52,890
have all this complication you end up

898
00:27:52,890 --> 00:27:54,240
with issues you end up with congestion

899
00:27:54,240 --> 00:27:56,160
you end up with things crashing you end

900
00:27:56,160 --> 00:27:57,630
up with messages that just somehow get

901
00:27:57,630 --> 00:28:00,450
lost in transit and because this pipe

902
00:28:00,450 --> 00:28:02,490
that sends the watchdog messages don't

903
00:28:02,490 --> 00:28:05,090
be as they're question

904
00:28:05,090 --> 00:28:08,310
I'm saying it's complet

905
00:28:08,310 --> 00:28:10,020
pipeline is complicated because it's not

906
00:28:10,020 --> 00:28:12,180
something like you have fixed Hardware

907
00:28:12,180 --> 00:28:15,060
where it's some like shared in this case

908
00:28:15,060 --> 00:28:16,620
it's a shared communication medium

909
00:28:16,620 --> 00:28:18,240
see it's complicated than that you have

910
00:28:18,240 --> 00:28:19,320
a whole bunch of demons that are

911
00:28:19,320 --> 00:28:21,360
handling packets along the way you go

912
00:28:21,360 --> 00:28:23,250
from the hosts so probably a user space

913
00:28:23,250 --> 00:28:24,900
demon running on the host into the hosts

914
00:28:24,900 --> 00:28:27,150
kernel down to something that puts it on

915
00:28:27,150 --> 00:28:30,030
the platform's LPC bus down to the BMC

916
00:28:30,030 --> 00:28:31,920
which then has a driver that has to read

917
00:28:31,920 --> 00:28:33,690
it in it needs a system in Hardware

918
00:28:33,690 --> 00:28:35,100
actually to notify it that that message

919
00:28:35,100 --> 00:28:37,050
is even there then it goes into the host

920
00:28:37,050 --> 00:28:39,150
transport driver then to the IPMI daemon

921
00:28:39,150 --> 00:28:42,090
then over d bus to the actual watchdog

922
00:28:42,090 --> 00:28:44,070
that's monitoring everything and so

923
00:28:44,070 --> 00:28:45,330
because you have all of those different

924
00:28:45,330 --> 00:28:47,940
things in the chain of critical path it

925
00:28:47,940 --> 00:28:50,070
ends up being fairly complicated and you

926
00:28:50,070 --> 00:28:51,990
do run into issues pretty frequently I

927
00:28:51,990 --> 00:28:55,290
found at least with our deployments and

928
00:28:55,290 --> 00:28:56,160
because

929
00:28:56,160 --> 00:28:57,690
communication medium is also shared with

930
00:28:57,690 --> 00:28:59,370
things like sensor reads or network

931
00:28:59,370 --> 00:29:01,500
settings or any of those things if one

932
00:29:01,500 --> 00:29:03,120
of those requests times out and we don't

933
00:29:03,120 --> 00:29:04,890
have a sink completely implemented which

934
00:29:04,890 --> 00:29:06,510
I think we're doing better and we're

935
00:29:06,510 --> 00:29:08,060
getting there but we're not there yet

936
00:29:08,060 --> 00:29:10,110
then you end up not being able to

937
00:29:10,110 --> 00:29:11,670
process the watchdog message when you're

938
00:29:11,670 --> 00:29:13,320
doing something like some really long

939
00:29:13,320 --> 00:29:16,830
hanging sitting sensory and so both of

940
00:29:16,830 --> 00:29:18,270
those things give it to watchdog trips

941
00:29:18,270 --> 00:29:20,430
we really don't want the host to go down

942
00:29:20,430 --> 00:29:22,050
if the host is fine but it's the BMC

943
00:29:22,050 --> 00:29:24,030
communication that's having a problem we

944
00:29:24,030 --> 00:29:26,370
really could do something if we decide

945
00:29:26,370 --> 00:29:28,020
that the BMC communication channel is

946
00:29:28,020 --> 00:29:30,030
locking up but it should not be killing

947
00:29:30,030 --> 00:29:31,590
off the host and bringing it back that

948
00:29:31,590 --> 00:29:32,970
disrupts workflows and that's generally

949
00:29:32,970 --> 00:29:36,090
just not desirable for us and I think it

950
00:29:36,090 --> 00:29:37,290
would be really nice if we could design

951
00:29:37,290 --> 00:29:39,000
a simpler mechanism for this that we're

952
00:29:39,000 --> 00:29:39,960
not depending on the shared

953
00:29:39,960 --> 00:29:42,060
communication channel I realize we can

954
00:29:42,060 --> 00:29:43,920
improve that to make it better but I

955
00:29:43,920 --> 00:29:45,240
think that having just like some

956
00:29:45,240 --> 00:29:47,220
out-of-band LPC access where you're just

957
00:29:47,220 --> 00:29:49,260
like reading and writing to a register

958
00:29:49,260 --> 00:29:51,030
in LPC and the BMC is picking that up

959
00:29:51,030 --> 00:29:52,380
and the daemon is completely severed

960
00:29:52,380 --> 00:29:54,270
from the ipmi path would be much more

961
00:29:54,270 --> 00:29:55,560
ideal because it would be much simpler

962
00:29:55,560 --> 00:29:58,590
and it also turns out that platform

963
00:29:58,590 --> 00:30:00,480
resets are hard there's not just a

964
00:30:00,480 --> 00:30:02,040
single type of reset you have Warren

965
00:30:02,040 --> 00:30:04,110
resets you have soft resets you have

966
00:30:04,110 --> 00:30:05,640
power cycles and all sorts of things and

967
00:30:05,640 --> 00:30:07,170
these actually trigger different types

968
00:30:07,170 --> 00:30:09,570
of behaviors on the host and for us

969
00:30:09,570 --> 00:30:11,490
maybe we don't always want a power cycle

970
00:30:11,490 --> 00:30:13,050
maybe we actually want to be able to get

971
00:30:13,050 --> 00:30:14,910
the Machine check information off of the

972
00:30:14,910 --> 00:30:17,190
CPU that requires you to do a warm reset

973
00:30:17,190 --> 00:30:18,960
and that allows your bios then to come

974
00:30:18,960 --> 00:30:20,460
back and pick up all that mutable state

975
00:30:20,460 --> 00:30:22,170
that was left in the cpu because it was

976
00:30:22,170 --> 00:30:24,510
only warm reset and not cold Lisa but

977
00:30:24,510 --> 00:30:26,970
other times you have soft resets that

978
00:30:26,970 --> 00:30:28,170
don't do anything or they make the

979
00:30:28,170 --> 00:30:29,490
platform even less stable and they make

980
00:30:29,490 --> 00:30:31,260
the platform go away until it gets a

981
00:30:31,260 --> 00:30:31,980
cold reset

982
00:30:31,980 --> 00:30:34,620
now the IPMI functionality doesn't

983
00:30:34,620 --> 00:30:35,970
actually support that but we added

984
00:30:35,970 --> 00:30:37,590
something called the fallback watchdog

985
00:30:37,590 --> 00:30:39,870
that you can configure at Build time to

986
00:30:39,870 --> 00:30:41,370
make sure that you're able to do a cold

987
00:30:41,370 --> 00:30:43,140
reset in the cases the machine never

988
00:30:43,140 --> 00:30:45,570
comes back alive from the first one and

989
00:30:45,570 --> 00:30:47,430
the fact that this is just getting more

990
00:30:47,430 --> 00:30:49,200
and more complicated shows that it's

991
00:30:49,200 --> 00:30:50,970
really difficult and probably should be

992
00:30:50,970 --> 00:30:52,890
left up to the platform vendor because

993
00:30:52,890 --> 00:30:54,870
they know what types of resets they need

994
00:30:54,870 --> 00:30:56,390
in order to recover the system correctly

995
00:30:56,390 --> 00:30:58,920
and so I really don't think this is ever

996
00:30:58,920 --> 00:31:00,540
going to be quite as good as a platform

997
00:31:00,540 --> 00:31:02,850
watchdog but I think sticking towards

998
00:31:02,850 --> 00:31:04,530
using the hardest reset you have on the

999
00:31:04,530 --> 00:31:06,350
host is probably a good way to go

1000
00:31:06,350 --> 00:31:08,760
now I mean it's also just surprisingly

1001
00:31:08,760 --> 00:31:09,990
hard to get perfect

1002
00:31:09,990 --> 00:31:12,690
Brij I spent a lot of time with the open

1003
00:31:12,690 --> 00:31:14,040
power firmware guys trying to get

1004
00:31:14,040 --> 00:31:15,870
coverage all the way from initial boot

1005
00:31:15,870 --> 00:31:17,850
up until the end of ski boot and so if

1006
00:31:17,850 --> 00:31:19,380
you're unfamiliar they have an initial

1007
00:31:19,380 --> 00:31:21,179
boot payload which boots what they call

1008
00:31:21,179 --> 00:31:23,100
host boot and this trains memory and

1009
00:31:23,100 --> 00:31:24,780
piece and a whole bunch of peripheral

1010
00:31:24,780 --> 00:31:26,850
devices and they get into ski boot which

1011
00:31:26,850 --> 00:31:28,950
does PCIe training another link training

1012
00:31:28,950 --> 00:31:31,380
external stuff and then they get into

1013
00:31:31,380 --> 00:31:33,330
their little small stage one boot loader

1014
00:31:33,330 --> 00:31:34,920
which boots a Linux kernel or secondary

1015
00:31:34,920 --> 00:31:36,270
boot loader that sort of thing and so

1016
00:31:36,270 --> 00:31:37,830
just getting coverage so that their

1017
00:31:37,830 --> 00:31:39,300
firmware is supported but the watchdog

1018
00:31:39,300 --> 00:31:40,320
was actually something that was fairly

1019
00:31:40,320 --> 00:31:42,780
challenging but I think it was worth it

1020
00:31:42,780 --> 00:31:44,070
and we're finally there and that's good

1021
00:31:44,070 --> 00:31:46,050
but that's not true of all platforms so

1022
00:31:46,050 --> 00:31:48,570
I think right now on UEFI platforms you

1023
00:31:48,570 --> 00:31:50,820
typically don't get watched on coverage

1024
00:31:50,820 --> 00:31:54,570
until the Dixie phase of the boot and so

1025
00:31:54,570 --> 00:31:56,100
anything that happens before that just

1026
00:31:56,100 --> 00:31:58,230
isn't even covered and this can actually

1027
00:31:58,230 --> 00:31:59,790
cause a whole bunch of issues and the

1028
00:31:59,790 --> 00:32:01,200
lack of coverage is not necessarily

1029
00:32:01,200 --> 00:32:03,330
ideal and so if you use the fallback

1030
00:32:03,330 --> 00:32:05,429
watchdog plus having some functionality

1031
00:32:05,429 --> 00:32:07,559
to monitor postcodes you can kind of get

1032
00:32:07,559 --> 00:32:08,850
Watchtower functionality and it's a

1033
00:32:08,850 --> 00:32:10,470
little bit more reliable than the IPMI

1034
00:32:10,470 --> 00:32:12,570
method but then you have to fall back to

1035
00:32:12,570 --> 00:32:14,490
IPMI once you leave and so all of this

1036
00:32:14,490 --> 00:32:17,010
it's just very difficult to get this to

1037
00:32:17,010 --> 00:32:18,570
work reliably and to not have false

1038
00:32:18,570 --> 00:32:20,220
positives and trip your hosts when you

1039
00:32:20,220 --> 00:32:23,520
don't want it to and this kind of goes

1040
00:32:23,520 --> 00:32:25,800
back to monitoring I think all of these

1041
00:32:25,800 --> 00:32:28,050
resilience features are nice to have but

1042
00:32:28,050 --> 00:32:29,309
you need to know that they happened

1043
00:32:29,309 --> 00:32:30,570
especially if they're causing you to

1044
00:32:30,570 --> 00:32:32,280
have reduced functionality or destroy

1045
00:32:32,280 --> 00:32:34,890
mutable data and so we really need ways

1046
00:32:34,890 --> 00:32:36,960
to be able to know if our data was wiped

1047
00:32:36,960 --> 00:32:40,890
and we need to know sort of the problems

1048
00:32:40,890 --> 00:32:42,780
arise in general we need to be able to

1049
00:32:42,780 --> 00:32:44,280
see that sensors have failed and that we

1050
00:32:44,280 --> 00:32:46,110
have recovery paths to go in and cause

1051
00:32:46,110 --> 00:32:48,630
that and this I think will be covered

1052
00:32:48,630 --> 00:32:51,140
more in depth by Kuhn later in the day

1053
00:32:51,140 --> 00:33:04,380
and so are there any questions in our

1054
00:33:04,380 --> 00:33:06,030
case it's not true of every system but I

1055
00:33:06,030 --> 00:33:08,429
think in general it's unlikely that

1056
00:33:08,429 --> 00:33:09,720
you're going to want to implement in

1057
00:33:09,720 --> 00:33:11,370
multiple communication channels and your

1058
00:33:11,370 --> 00:33:19,840
BMC right exactly

1059
00:33:19,840 --> 00:33:23,180
so I think in so there actually are

1060
00:33:23,180 --> 00:33:25,670
things that we have implemented through

1061
00:33:25,670 --> 00:33:26,960
if you're familiar with the blobs

1062
00:33:26,960 --> 00:33:29,870
protocol that Patrick venture created he

1063
00:33:29,870 --> 00:33:31,910
also created the tool that I believe he

1064
00:33:31,910 --> 00:33:33,380
published that allows you to just pull

1065
00:33:33,380 --> 00:33:35,000
and read arbitrary files from the file

1066
00:33:35,000 --> 00:33:36,980
system of the BMC and so you could

1067
00:33:36,980 --> 00:33:38,750
actually get journal information from

1068
00:33:38,750 --> 00:33:40,040
the system day journal through that

1069
00:33:40,040 --> 00:33:41,930
mechanism by just pulling the journal

1070
00:33:41,930 --> 00:33:43,190
files straight out and running it

1071
00:33:43,190 --> 00:33:47,320
through a journal CTL processor locally

1072
00:33:52,210 --> 00:33:55,700
yeah so in our case the post has to be

1073
00:33:55,700 --> 00:33:57,260
available for the BMC to be reachable

1074
00:33:57,260 --> 00:33:59,540
which is it's just something we deal

1075
00:33:59,540 --> 00:34:01,340
with and that that actually makes it

1076
00:34:01,340 --> 00:34:02,870
even more challenging to me resilient

1077
00:34:02,870 --> 00:34:05,360
because now not only do you have to have

1078
00:34:05,360 --> 00:34:06,800
the BMC working and like talk to the

1079
00:34:06,800 --> 00:34:08,120
network you actually need the entire

1080
00:34:08,120 --> 00:34:09,409
host to come all the way up and have a

1081
00:34:09,409 --> 00:34:11,540
communication channel into the BMC which

1082
00:34:11,540 --> 00:34:15,699
is surprisingly difficult in some cases

1083
00:34:17,860 --> 00:34:20,690
I know I

1084
00:34:20,690 --> 00:34:24,860
yeah I know I mentioned that in there

1085
00:34:24,860 --> 00:34:26,780
actually like it would be so nice but I

1086
00:34:26,780 --> 00:34:28,820
don't think ZFS works on an arm v6 that

1087
00:34:28,820 --> 00:34:34,879
has like no memory basically right also

1088
00:34:34,879 --> 00:34:36,949
I guess my other question would be how

1089
00:34:36,949 --> 00:34:38,239
well does it handle only having like

1090
00:34:38,239 --> 00:34:41,500
five Meg's of space on disk to work with

1091
00:34:41,500 --> 00:34:44,980
would that be possible

1092
00:34:45,879 --> 00:34:52,179
I agree I tend to agree with that yeah

1093
00:34:53,168 --> 00:34:55,969
yeah no it's definitely interesting

1094
00:34:55,969 --> 00:34:57,620
especially if you could do even some

1095
00:34:57,620 --> 00:34:59,300
kind of replication in there I mean I

1096
00:34:59,300 --> 00:35:00,530
realize it's such a limited amount of

1097
00:35:00,530 --> 00:35:17,240
space exactly I agree yeah I agree yeah

1098
00:35:17,240 --> 00:35:20,049
that'd be nice

1099
00:35:29,180 --> 00:35:31,830
yeah so it would be nice to have

1100
00:35:31,830 --> 00:35:33,660
something that's able to report I think

1101
00:35:33,660 --> 00:35:35,520
having the systemd Journal is actually a

1102
00:35:35,520 --> 00:35:38,700
pretty good sort of way to get coverage

1103
00:35:38,700 --> 00:35:40,170
on that as long as it's actually

1104
00:35:40,170 --> 00:35:41,730
persisting that out to the disk like is

1105
00:35:41,730 --> 00:35:42,839
it crashing and persisting the

1106
00:35:42,839 --> 00:35:44,369
information how that's kind of them the

1107
00:35:44,369 --> 00:35:46,770
question that I have and I don't know

1108
00:35:46,770 --> 00:35:48,750
how solvable that would be like I think

1109
00:35:48,750 --> 00:35:50,460
in general it's not the case that the

1110
00:35:50,460 --> 00:35:53,040
BMC's kernel dies and goes away I think

1111
00:35:53,040 --> 00:35:55,080
that's less common in general than just

1112
00:35:55,080 --> 00:35:57,300
having issues with the user space demons

1113
00:35:57,300 --> 00:36:10,500
and then becoming unavailable yeah no

1114
00:36:10,500 --> 00:36:11,700
one I think that's good that's something

1115
00:36:11,700 --> 00:36:13,020
we should definitely look at having for

1116
00:36:13,020 --> 00:36:28,849
sure yes sorry say that again

1117
00:36:28,849 --> 00:36:31,109
and you proposal are you talking about

1118
00:36:31,109 --> 00:36:33,890
or are you proposing that the host

1119
00:36:33,890 --> 00:36:36,960
agents can tap in the BMC watchdog

1120
00:36:36,960 --> 00:36:38,970
periodically to get the hills monitoring

1121
00:36:38,970 --> 00:36:42,480
I mean how does the BMC know if you

1122
00:36:42,480 --> 00:36:44,190
might if the host is kind of you know

1123
00:36:44,190 --> 00:36:46,320
healthy and running yes so that's

1124
00:36:46,320 --> 00:36:48,150
actually kind of a hard problem and it

1125
00:36:48,150 --> 00:36:49,740
relies on the host correctly reporting

1126
00:36:49,740 --> 00:36:51,270
its own state typically there are

1127
00:36:51,270 --> 00:36:54,000
frameworks on the host that could a

1128
00:36:54,000 --> 00:36:55,170
granade a whole bunch of their own

1129
00:36:55,170 --> 00:36:57,150
internal watchdogs and then only pet the

1130
00:36:57,150 --> 00:37:02,160
watchdog when everything's healthy and

1131
00:37:02,160 --> 00:37:04,170
so the BMC I mean you could make it more

1132
00:37:04,170 --> 00:37:06,089
in charge of monitoring health data for

1133
00:37:06,089 --> 00:37:07,320
the server to determine if it should

1134
00:37:07,320 --> 00:37:09,000
restart but that's not it's kind of

1135
00:37:09,000 --> 00:37:10,320
outside of the scope of the watchdog

1136
00:37:10,320 --> 00:37:12,390
itself the watchdog is purely there to

1137
00:37:12,390 --> 00:37:14,250
exist to be pet and then when it stops

1138
00:37:14,250 --> 00:37:16,230
being pet by the host then it goes and

1139
00:37:16,230 --> 00:37:19,670
performs some kind of corrective action

1140
00:37:26,270 --> 00:37:28,440
for resiliency I guess it goes the other

1141
00:37:28,440 --> 00:37:31,020
way to have you can how many of the

1142
00:37:31,020 --> 00:37:32,160
hardware watched how many of the

1143
00:37:32,160 --> 00:37:34,410
watchdog functions take the host

1144
00:37:34,410 --> 00:37:36,720
watchdog for example are implemented or

1145
00:37:36,720 --> 00:37:38,339
backed by an actual hardware watchdog

1146
00:37:38,339 --> 00:37:40,349
timer because the payment itself could

1147
00:37:40,349 --> 00:37:42,510
could stop responding right right

1148
00:37:42,510 --> 00:37:43,500
actually it is kind of interesting

1149
00:37:43,500 --> 00:37:47,130
because the watchdog Damon now is

1150
00:37:47,130 --> 00:37:49,530
protected by that systemd watchdog which

1151
00:37:49,530 --> 00:37:51,780
should be protected by the PMC's

1152
00:37:51,780 --> 00:37:53,880
watchdog and so theoretically all of

1153
00:37:53,880 --> 00:37:55,260
those things need to continue to make

1154
00:37:55,260 --> 00:37:56,670
progress in order for the whole system

1155
00:37:56,670 --> 00:37:58,650
to be happy and so if for whatever

1156
00:37:58,650 --> 00:38:00,420
reason that hosts watchdog demon that

1157
00:38:00,420 --> 00:38:01,740
service that's providing the watch type

1158
00:38:01,740 --> 00:38:03,540
functionality over the host if that ever

1159
00:38:03,540 --> 00:38:04,950
decided to stop running it's at that

1160
00:38:04,950 --> 00:38:06,840
loop then systemd would catch that and

1161
00:38:06,840 --> 00:38:08,520
restart it if the BMC for whatever

1162
00:38:08,520 --> 00:38:10,080
reason ever got into a state where it

1163
00:38:10,080 --> 00:38:12,120
completely hung up and then its watchdog

1164
00:38:12,120 --> 00:38:13,680
would restart itself and we'd be back up

1165
00:38:13,680 --> 00:38:17,970
again everything ends up relying on

1166
00:38:17,970 --> 00:38:21,870
layers of watchdogs basically yeah which

1167
00:38:21,870 --> 00:38:29,700
can also cause problems right so you

1168
00:38:29,700 --> 00:38:32,720
mentioned I think a couple of slides ago

1169
00:38:32,720 --> 00:38:36,750
to implement direct access to BNC logs

1170
00:38:36,750 --> 00:38:41,240
oh yeah you referring to like the

1171
00:38:41,240 --> 00:38:44,430
journalist I think that's down here yeah

1172
00:38:44,430 --> 00:38:46,950
yeah this one were you referring to the

1173
00:38:46,950 --> 00:38:49,500
Journal d-logs exactly yeah yeah I mean

1174
00:38:49,500 --> 00:38:50,730
it doesn't have to necessarily just be

1175
00:38:50,730 --> 00:38:52,410
the file like file system level access

1176
00:38:52,410 --> 00:38:53,760
is one thing but I think that's less

1177
00:38:53,760 --> 00:38:55,560
clean than having a way to get the

1178
00:38:55,560 --> 00:38:58,650
metadata in a format that we sort of

1179
00:38:58,650 --> 00:39:01,200
have a defined interface for um you

1180
00:39:01,200 --> 00:39:02,310
could maybe just pumping out as plain

1181
00:39:02,310 --> 00:39:04,350
text instead of pumping out the binary

1182
00:39:04,350 --> 00:39:06,510
data that is kind of horrible to work

1183
00:39:06,510 --> 00:39:10,380
with in general me but and if in a case

1184
00:39:10,380 --> 00:39:13,110
where you don't have SSH access how do

1185
00:39:13,110 --> 00:39:16,200
you actually get it out if say you don't

1186
00:39:16,200 --> 00:39:19,400
have bread fish implemented yeah so I

1187
00:39:19,400 --> 00:39:21,690
like I said there's a file system access

1188
00:39:21,690 --> 00:39:24,090
mechanism through blobs that we have so

1189
00:39:24,090 --> 00:39:26,100
we can actually say go grab all of it

1190
00:39:26,100 --> 00:39:27,330
like list all the files and numerate

1191
00:39:27,330 --> 00:39:29,610
them all in VAR log and then I think

1192
00:39:29,610 --> 00:39:30,900
it's far logged journal actually is

1193
00:39:30,900 --> 00:39:32,100
where it stores all the journal entries

1194
00:39:32,100 --> 00:39:33,930
and it's a couple nestled high or is it

1195
00:39:33,930 --> 00:39:36,180
directories and some binary files but

1196
00:39:36,180 --> 00:39:37,890
inside of that once you enumerate those

1197
00:39:37,890 --> 00:39:39,330
you pull them all down to the system

1198
00:39:39,330 --> 00:39:40,710
using this blob mechanism for

1199
00:39:40,710 --> 00:39:42,030
transferring files and doing this

1200
00:39:42,030 --> 00:39:44,490
read-only access and then you may need

1201
00:39:44,490 --> 00:39:45,750
to deal with the fact that one of them

1202
00:39:45,750 --> 00:39:47,100
was currently being written to because

1203
00:39:47,100 --> 00:39:48,330
it's like the current journal that it's

1204
00:39:48,330 --> 00:39:50,940
writing but hopefully because the format

1205
00:39:50,940 --> 00:39:52,920
is append-only you would have all the

1206
00:39:52,920 --> 00:39:54,180
previous entries intact and you just

1207
00:39:54,180 --> 00:39:55,820
have to deal with truncating whatever

1208
00:39:55,820 --> 00:39:57,620
the end that got corrupted because it

1209
00:39:57,620 --> 00:39:58,910
was partially ran or something in the

1210
00:39:58,910 --> 00:40:07,040
process are we doing which it would be

1211
00:40:07,040 --> 00:40:08,480
totally up to your monitoring solution

1212
00:40:08,480 --> 00:40:09,740
as to how often you would want to read

1213
00:40:09,740 --> 00:40:10,850
it maybe you only read it when it

1214
00:40:10,850 --> 00:40:12,320
crashes maybe you just like never read

1215
00:40:12,320 --> 00:40:14,210
it at all and you wait that's the thing

1216
00:40:14,210 --> 00:40:18,410
that can work mm-hmm

1217
00:40:18,410 --> 00:40:20,660
and you can block a block it might be

1218
00:40:20,660 --> 00:40:22,070
Mike yeah yeah there's all sorts of

1219
00:40:22,070 --> 00:40:24,470
problems there I think the nice thing is

1220
00:40:24,470 --> 00:40:26,240
that the blobs mechanism does support

1221
00:40:26,240 --> 00:40:28,130
out-of-band transfers so you're really

1222
00:40:28,130 --> 00:40:29,720
just sending metadata through the idea

1223
00:40:29,720 --> 00:40:31,490
my channel and then you're able to use

1224
00:40:31,490 --> 00:40:33,590
like PCI Express or LPC or something to

1225
00:40:33,590 --> 00:40:35,150
do the bulk transmission of data back

1226
00:40:35,150 --> 00:40:37,100
and forth so at least you're not

1227
00:40:37,100 --> 00:40:38,990
blocking up IP am i sending all the data

1228
00:40:38,990 --> 00:40:40,670
that is actually an option that it

1229
00:40:40,670 --> 00:40:41,990
provides but I wouldn't do that if the

1230
00:40:41,990 --> 00:40:43,730
logs were huge or if you were sending

1231
00:40:43,730 --> 00:40:45,530
like a big update or something the BMC

1232
00:40:45,530 --> 00:40:47,360
where you're gonna send 32 Meg's through

1233
00:40:47,360 --> 00:40:52,460
I pay my packets it's not great so how

1234
00:40:52,460 --> 00:40:55,430
do you improve the system resiliency

1235
00:40:55,430 --> 00:40:57,920
during the BMC boot what if the BMC

1236
00:40:57,920 --> 00:41:00,920
fails to boot I mean like the different

1237
00:41:00,920 --> 00:41:02,600
stages right I mean what if it hangs at

1238
00:41:02,600 --> 00:41:04,250
you boo what every times is Colonel

1239
00:41:04,250 --> 00:41:05,870
whatever time yes hopefully you have

1240
00:41:05,870 --> 00:41:07,610
good watchdog coverage and those are

1241
00:41:07,610 --> 00:41:09,950
failures that you don't see consistently

1242
00:41:09,950 --> 00:41:11,300
but if it's something that happens

1243
00:41:11,300 --> 00:41:12,860
consistently over and over a watchdog

1244
00:41:12,860 --> 00:41:14,750
isn't gonna help you with that like if

1245
00:41:14,750 --> 00:41:16,430
you just have a crash that you hit every

1246
00:41:16,430 --> 00:41:17,780
single time deterministically you're not

1247
00:41:17,780 --> 00:41:18,860
actually gonna be able to recover from

1248
00:41:18,860 --> 00:41:20,240
that without just producing new firmware

1249
00:41:20,240 --> 00:41:22,640
and reflashing hopefully your QA caught

1250
00:41:22,640 --> 00:41:24,290
that prior to you releasing that image

1251
00:41:24,290 --> 00:41:27,170
and so you do need separate mechanisms

1252
00:41:27,170 --> 00:41:29,030
for machines that you're that are going

1253
00:41:29,030 --> 00:41:30,560
through testing that you want to be able

1254
00:41:30,560 --> 00:41:32,420
to reflash a lot I recommend spy

1255
00:41:32,420 --> 00:41:34,190
emulation for those that would be the

1256
00:41:34,190 --> 00:41:35,750
best way to go just so that you don't

1257
00:41:35,750 --> 00:41:37,400
have to deal with continually pulling

1258
00:41:37,400 --> 00:41:39,200
chips or reflashing or that sort of

1259
00:41:39,200 --> 00:41:41,270
thing if you use emulation it flashes

1260
00:41:41,270 --> 00:41:42,710
incredibly quickly and you can recover

1261
00:41:42,710 --> 00:41:55,000
from anything I'm sure this depends

1262
00:41:55,000 --> 00:41:57,320
based on the image type that you have I

1263
00:41:57,320 --> 00:41:59,120
think with the ubi system it doesn't

1264
00:41:59,120 --> 00:42:00,590
flash the whole thing it's only flashing

1265
00:42:00,590 --> 00:42:02,150
the read-only parts that need to update

1266
00:42:02,150 --> 00:42:04,400
but with the flat file system you're

1267
00:42:04,400 --> 00:42:06,170
flashing basically everything except for

1268
00:42:06,170 --> 00:42:07,340
the readwrite part and you're actually

1269
00:42:07,340 --> 00:42:08,230
rewriting that

1270
00:42:08,230 --> 00:42:09,400
process because you want to empty

1271
00:42:09,400 --> 00:42:10,690
everything out and only use the

1272
00:42:10,690 --> 00:42:16,720
whitelisted section of it and even that

1273
00:42:16,720 --> 00:42:18,760
actually has issues because if you read

1274
00:42:18,760 --> 00:42:20,349
out the whole thing and you don't

1275
00:42:20,349 --> 00:42:22,359
persist that data similar and then you

1276
00:42:22,359 --> 00:42:23,890
lose power while you're reading all the

1277
00:42:23,890 --> 00:42:25,420
data out and then going to write it back

1278
00:42:25,420 --> 00:42:26,800
you lose all the data that you had in

1279
00:42:26,800 --> 00:42:28,720
your file system becomes empty again so

1280
00:42:28,720 --> 00:42:30,369
we do have lots of issues that we need

1281
00:42:30,369 --> 00:42:32,260
to think about and make sure you end up

1282
00:42:32,260 --> 00:42:33,730
persisting data as much as we possibly

1283
00:42:33,730 --> 00:42:35,730
can in all different cases that we have

1284
00:42:35,730 --> 00:42:38,170
and just be very tolerant to power loss

1285
00:42:38,170 --> 00:42:40,750
because the BMC is a component on the

1286
00:42:40,750 --> 00:42:42,369
motherboard that the user probably

1287
00:42:42,369 --> 00:42:43,780
doesn't really think about I think in a

1288
00:42:43,780 --> 00:42:46,180
lot of cases maybe if you own the whole

1289
00:42:46,180 --> 00:42:47,680
stack you think about it more and you

1290
00:42:47,680 --> 00:42:49,390
have instructions for you know not to

1291
00:42:49,390 --> 00:42:51,940
pull power but realistically depending

1292
00:42:51,940 --> 00:42:53,950
on power not being pulled is not a great

1293
00:42:53,950 --> 00:42:55,150
solution you generally want to avoid

1294
00:42:55,150 --> 00:42:56,589
that so you don't want to have the

1295
00:42:56,589 --> 00:42:58,119
dependence on needing to be power to be

1296
00:42:58,119 --> 00:43:07,599
consistent that is a whole can of worms

1297
00:43:07,599 --> 00:43:09,760
for us and why if that doesn't work but

1298
00:43:09,760 --> 00:43:11,320
it doesn't work in our city in our

1299
00:43:11,320 --> 00:43:14,230
situation it might work for some of

1300
00:43:14,230 --> 00:43:16,650
these other issues

1301
00:43:26,540 --> 00:43:29,690
all right

1302
00:43:31,990 --> 00:43:37,160
[Applause]

1303
00:43:37,160 --> 00:43:44,890
[Music]

