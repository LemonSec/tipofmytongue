1
00:00:03,190 --> 00:00:06,259
[Music]

2
00:00:07,280 --> 00:00:10,230
next up will be Ryan and he'll be

3
00:00:10,230 --> 00:00:11,849
talking about or boo the project I'm

4
00:00:11,849 --> 00:00:15,150
really excited about because you can see

5
00:00:15,150 --> 00:00:18,210
if you take some really good concepts of

6
00:00:18,210 --> 00:00:20,220
open source firmware and combine them

7
00:00:20,220 --> 00:00:24,320
with a really good fundamental parts

8
00:00:24,320 --> 00:00:27,930
language which is rust in that case so

9
00:00:27,930 --> 00:00:29,820
please give her a big round of applause

10
00:00:29,820 --> 00:00:36,809
for Ryan O'Leary Thank You Julian so

11
00:00:36,809 --> 00:00:39,149
today I'm gonna present a boot

12
00:00:39,149 --> 00:00:41,070
so I worked on it in the last few months

13
00:00:41,070 --> 00:00:44,190
with Ron we've gone with crotchy with

14
00:00:44,190 --> 00:00:46,850
Chris from Google and also want to thank

15
00:00:46,850 --> 00:00:49,710
andreas Viktor from the grass embedded

16
00:00:49,710 --> 00:00:51,180
working with there's some excellent

17
00:00:51,180 --> 00:00:54,360
people there trying to make rust easier

18
00:00:54,360 --> 00:00:57,170
to use in firmware as well as Troy Ben

19
00:00:57,170 --> 00:01:01,079
Jerris these from the sci-fi who really

20
00:01:01,079 --> 00:01:03,780
helped us get our boot to work on the

21
00:01:03,780 --> 00:01:06,780
high five I'm Mitch wood so in this talk

22
00:01:06,780 --> 00:01:08,760
I'm going to talk I'm gonna discuss what

23
00:01:08,760 --> 00:01:12,830
is why we chose rest for this project

24
00:01:12,830 --> 00:01:16,140
some of the design principles behind the

25
00:01:16,140 --> 00:01:20,159
project how we got to run in QEMU on the

26
00:01:20,159 --> 00:01:24,090
ast 2 5 0 0 the a speed um Boyet as well

27
00:01:24,090 --> 00:01:26,610
as on hardware I'm the hi-5 Unleashed

28
00:01:26,610 --> 00:01:29,159
wood as well as how you can get involved

29
00:01:29,159 --> 00:01:32,750
in the project so there's ass working on

30
00:01:32,750 --> 00:01:35,280
or boot trying to get to work on some

31
00:01:35,280 --> 00:01:38,520
hardware so yeah first thing I look at

32
00:01:38,520 --> 00:01:41,280
what is orbit so or boot is essentially

33
00:01:41,280 --> 00:01:43,979
quad boot without seesaw I'll give you a

34
00:01:43,979 --> 00:01:47,310
moment to appreciate this fine so it's a

35
00:01:47,310 --> 00:01:50,070
downstream downstream Fork of Kobol

36
00:01:50,070 --> 00:01:53,390
which makes it open source and gplv2

37
00:01:53,390 --> 00:01:56,130
it's completely written in grass there's

38
00:01:56,130 --> 00:01:58,770
not a line of C code there's a bit of

39
00:01:58,770 --> 00:02:00,149
assembly because you need a bit of

40
00:02:00,149 --> 00:02:02,460
assembly to initialize like the very

41
00:02:02,460 --> 00:02:03,110
low-level

42
00:02:03,110 --> 00:02:05,759
CPU and initialize the stack pointer and

43
00:02:05,759 --> 00:02:09,598
stuff but very little assembly and the

44
00:02:09,598 --> 00:02:11,340
main aim is to jump to the kernel as

45
00:02:11,340 --> 00:02:13,800
quickly as possible so this is sort of

46
00:02:13,800 --> 00:02:16,140
the Linux boot model we don't want the

47
00:02:16,140 --> 00:02:18,540
the firmware to have any disk drivers or

48
00:02:18,540 --> 00:02:21,120
have like a network stack or debug shell

49
00:02:21,120 --> 00:02:25,280
we want to punt all that into Linux boot

50
00:02:25,280 --> 00:02:28,070
because Linux already has some excellent

51
00:02:28,070 --> 00:02:30,720
network stack excellent drivers very

52
00:02:30,720 --> 00:02:32,310
high performance and we don't want to be

53
00:02:32,310 --> 00:02:35,520
instrumental and the policy we really

54
00:02:35,520 --> 00:02:37,980
want to do going forward is to only

55
00:02:37,980 --> 00:02:40,590
accept fully open source components in

56
00:02:40,590 --> 00:02:43,860
this project so for example we wouldn't

57
00:02:43,860 --> 00:02:46,950
want any flow source blobs like FSP and

58
00:02:46,950 --> 00:02:48,930
we want all the data sheets for the

59
00:02:48,930 --> 00:02:52,410
project to be open source sorry not open

60
00:02:52,410 --> 00:02:55,260
source bet be able to do them publicly

61
00:02:55,260 --> 00:02:59,160
without an NDA so here's a basic route

62
00:02:59,160 --> 00:03:00,990
flow for good and this is very similar

63
00:03:00,990 --> 00:03:04,080
to a Abu so we start with what we call

64
00:03:04,080 --> 00:03:05,850
the boot blob it's not a single block

65
00:03:05,850 --> 00:03:08,610
it's a it's a blob of code and this is

66
00:03:08,610 --> 00:03:11,820
mostly assembly it executes directly at

67
00:03:11,820 --> 00:03:14,250
a spy it's the first instruction in

68
00:03:14,250 --> 00:03:16,470
familiar it does the simple tasks like

69
00:03:16,470 --> 00:03:19,230
initializing the CPU printing a welcome

70
00:03:19,230 --> 00:03:21,150
message so in case it crashes say that

71
00:03:21,150 --> 00:03:22,709
you knew something happened at least

72
00:03:22,709 --> 00:03:27,180
sets up the the SRAM or caches RAM and

73
00:03:27,180 --> 00:03:31,020
then it finds and jumps the ROM stage so

74
00:03:31,020 --> 00:03:33,180
the realm sage mainly has one purpose so

75
00:03:33,180 --> 00:03:34,770
at this point you can't start Linux yet

76
00:03:34,770 --> 00:03:37,020
because your machine hasn't initialized

77
00:03:37,020 --> 00:03:40,650
the main memory you only have about 30

78
00:03:40,650 --> 00:03:42,600
kilobytes so just like a few megabytes

79
00:03:42,600 --> 00:03:45,840
of RAM or Cash's room so at this point

80
00:03:45,840 --> 00:03:50,820
the code just initializes the RAM or the

81
00:03:50,820 --> 00:03:53,459
DDR controller so once that's done we go

82
00:03:53,459 --> 00:03:56,370
to what we call the pelota stage so this

83
00:03:56,370 --> 00:03:58,890
is a bit different from the RAM stage in

84
00:03:58,890 --> 00:04:01,080
Corbett the pylorus stage has one

85
00:04:01,080 --> 00:04:03,840
purpose it is to run the payload and it

86
00:04:03,840 --> 00:04:05,700
doesn't do anything else so there's no

87
00:04:05,700 --> 00:04:09,360
shell no USB stack no storage drivers no

88
00:04:09,360 --> 00:04:11,610
nothing else it just loads the payload

89
00:04:11,610 --> 00:04:14,459
and jumps to it so that's why we called

90
00:04:14,459 --> 00:04:17,510
it the payload a stage to prevent other

91
00:04:17,510 --> 00:04:21,560
like other things from getting in

92
00:04:21,560 --> 00:04:25,200
then finally you usually jump to a

93
00:04:25,200 --> 00:04:27,770
colonel such as Linux which performs the

94
00:04:27,770 --> 00:04:31,950
job that Linux boot which has an FM FS

95
00:04:31,950 --> 00:04:34,740
which either fetches the next kernel

96
00:04:34,740 --> 00:04:36,840
from the network or loads from desk

97
00:04:36,840 --> 00:04:40,830
extract and one other goal of what boot

98
00:04:40,830 --> 00:04:45,350
is we want to focus on performant boot

99
00:04:45,350 --> 00:04:48,780
so the holy grail of firmware is wheel

100
00:04:48,780 --> 00:04:52,470
to boot machine in less than a second as

101
00:04:52,470 --> 00:04:54,540
you probably noticed machines nowadays

102
00:04:54,540 --> 00:04:57,720
get slower and slower so like a laptop

103
00:04:57,720 --> 00:04:59,700
or desktop may take a few minutes to

104
00:04:59,700 --> 00:05:02,370
boot service could take like up to ten

105
00:05:02,370 --> 00:05:04,490
minutes VMC's could take a few minutes

106
00:05:04,490 --> 00:05:06,420
but doesn't have to be this way

107
00:05:06,420 --> 00:05:07,590
and there's many counter points like

108
00:05:07,590 --> 00:05:10,980
Chromebooks go quickly servers from like

109
00:05:10,980 --> 00:05:14,550
a decade or two ago really quickly like

110
00:05:14,550 --> 00:05:18,270
where is requirements such as an

111
00:05:18,270 --> 00:05:20,370
automobiles to be quickly machines can

112
00:05:20,370 --> 00:05:22,830
be quickly it's definitely possible but

113
00:05:22,830 --> 00:05:24,600
there are few pain points like memory

114
00:05:24,600 --> 00:05:29,040
training takes time oftentimes drivers

115
00:05:29,040 --> 00:05:31,530
aren't run concurrently which slows you

116
00:05:31,530 --> 00:05:34,950
in the boot process and a few other

117
00:05:34,950 --> 00:05:37,350
things so a mingle is will to boot the

118
00:05:37,350 --> 00:05:39,450
high five processor which is Linux

119
00:05:39,450 --> 00:05:42,200
capable into Linux in less than a second

120
00:05:42,200 --> 00:05:44,250
so now I'm going to talk about why we

121
00:05:44,250 --> 00:05:47,220
chose to use dressed and why we didn't

122
00:05:47,220 --> 00:05:49,470
want to you see and this is kind of

123
00:05:49,470 --> 00:05:51,240
similar to the discussion which happened

124
00:05:51,240 --> 00:05:54,330
I guess two decades ago of why do you

125
00:05:54,330 --> 00:05:55,670
want to you see why can't we use

126
00:05:55,670 --> 00:05:58,130
assembly in our firmware

127
00:05:58,130 --> 00:06:02,400
uh-huh and the main reason to zest is

128
00:06:02,400 --> 00:06:04,080
because it's a it's a more modeling

129
00:06:04,080 --> 00:06:05,340
which is the language which which was

130
00:06:05,340 --> 00:06:08,940
created in the last decade and have many

131
00:06:08,940 --> 00:06:11,640
features to show many features which

132
00:06:11,640 --> 00:06:14,490
benefit the productivity the quality of

133
00:06:14,490 --> 00:06:16,200
the code the value I ability the

134
00:06:16,200 --> 00:06:18,480
security so for example we have the bajo

135
00:06:18,480 --> 00:06:21,720
checker I don't know how many of you are

136
00:06:21,720 --> 00:06:25,380
you familiar with last year quite a few

137
00:06:25,380 --> 00:06:28,970
it's really good so you have namespaces

138
00:06:28,970 --> 00:06:31,440
you don't need a link assess I can see

139
00:06:31,440 --> 00:06:34,590
you have hygienic Macker you

140
00:06:34,590 --> 00:06:38,340
typesafe printf you don't have to kill

141
00:06:38,340 --> 00:06:40,020
inlining code as much you have a

142
00:06:40,020 --> 00:06:41,490
standard package manager you have asked

143
00:06:41,490 --> 00:06:43,950
for a man on and on and on and so go

144
00:06:43,950 --> 00:06:46,530
over each one these briefly so the core

145
00:06:46,530 --> 00:06:48,620
principle of the bow jacket and this

146
00:06:48,620 --> 00:06:51,000
reading this sentence in the vast

147
00:06:51,000 --> 00:06:52,770
programming language but really my to me

148
00:06:52,770 --> 00:06:54,990
the code principle the bow jacket is at

149
00:06:54,990 --> 00:06:58,200
any given time you can have either one

150
00:06:58,200 --> 00:07:00,930
mutable reference or any number of

151
00:07:00,930 --> 00:07:03,389
immutable references references must

152
00:07:03,389 --> 00:07:06,960
always be valid so this doesn't really

153
00:07:06,960 --> 00:07:09,450
have pointers instead you have an owner

154
00:07:09,450 --> 00:07:13,229
of data and then you have references to

155
00:07:13,229 --> 00:07:16,050
it and you can have multiple and mutable

156
00:07:16,050 --> 00:07:18,419
references to that data or you can have

157
00:07:18,419 --> 00:07:23,070
one mutable reference to it so here's an

158
00:07:23,070 --> 00:07:24,660
example of C code which is really bad is

159
00:07:24,660 --> 00:07:28,200
multiple problems here so one is well

160
00:07:28,200 --> 00:07:29,970
you're casting from a in pointer to a

161
00:07:29,970 --> 00:07:32,220
void pointer which is generally a bad

162
00:07:32,220 --> 00:07:35,250
idea but the bigger problem is there's

163
00:07:35,250 --> 00:07:39,510
no guarantee that what X points do will

164
00:07:39,510 --> 00:07:43,229
outlive Y so your static Y variable

165
00:07:43,229 --> 00:07:45,960
might outlive the thing it's being

166
00:07:45,960 --> 00:07:51,780
pointed to so this is legal C it's very

167
00:07:51,780 --> 00:07:54,690
bad it's not possible to do something

168
00:07:54,690 --> 00:07:56,910
this bad in rest unless use unsafe

169
00:07:56,910 --> 00:08:00,180
keyword mess will and greatly increase

170
00:08:00,180 --> 00:08:03,539
safety and with the bio jacket it

171
00:08:03,539 --> 00:08:07,770
provides more opportunities to the vast

172
00:08:07,770 --> 00:08:10,169
compiler to optimize your code I'll have

173
00:08:10,169 --> 00:08:12,210
an example of using baha tracker in

174
00:08:12,210 --> 00:08:16,050
Raths later another great feature of

175
00:08:16,050 --> 00:08:19,320
assets namespaces so in law projects

176
00:08:19,320 --> 00:08:21,570
like Linux or Co boot you see that you

177
00:08:21,570 --> 00:08:23,820
have an arc directory and inside of your

178
00:08:23,820 --> 00:08:26,100
architecture you have like this v if you

179
00:08:26,100 --> 00:08:28,500
have army of x86 and in each one of

180
00:08:28,500 --> 00:08:30,690
these folders you have an implementation

181
00:08:30,690 --> 00:08:34,049
of for example the hold function so you

182
00:08:34,049 --> 00:08:35,700
have three functions with the same name

183
00:08:35,700 --> 00:08:37,589
and when you compile that and see

184
00:08:37,589 --> 00:08:40,409
generally you would have a multiple

185
00:08:40,409 --> 00:08:43,080
functions of the same name area in your

186
00:08:43,080 --> 00:08:44,560
linker

187
00:08:44,560 --> 00:08:46,390
and the way they work around this and

188
00:08:46,390 --> 00:08:48,520
see it's mostly hacks so we have f

189
00:08:48,520 --> 00:08:51,820
deaths you have weak symbols you have

190
00:08:51,820 --> 00:08:55,360
some magic in your make files sometimes

191
00:08:55,360 --> 00:08:59,260
you have pointers but in Nast you have a

192
00:08:59,260 --> 00:09:01,390
very simple mechanism called namespaces

193
00:09:01,390 --> 00:09:04,030
where you simply put each hold function

194
00:09:04,030 --> 00:09:06,460
into its own respective namespace and

195
00:09:06,460 --> 00:09:07,510
then when you import it

196
00:09:07,510 --> 00:09:09,100
you could rename the namespace to

197
00:09:09,100 --> 00:09:12,010
Architecture and you don't have to have

198
00:09:12,010 --> 00:09:15,670
any DC hacks another great thing about

199
00:09:15,670 --> 00:09:18,910
rest is it pretty much alleviates need

200
00:09:18,910 --> 00:09:22,170
for linker sets if you know what that is

201
00:09:22,170 --> 00:09:25,660
which is very good thing it also makes

202
00:09:25,660 --> 00:09:28,120
them make files a lot less crazy so this

203
00:09:28,120 --> 00:09:29,500
is an example of part of the make file

204
00:09:29,500 --> 00:09:33,430
in quote there's a lot going on here but

205
00:09:33,430 --> 00:09:38,310
you can see that it does get messy in

206
00:09:38,310 --> 00:09:40,510
math you have this tool called cago

207
00:09:40,510 --> 00:09:43,300
which essentially like figures of the

208
00:09:43,300 --> 00:09:44,440
dependencies for you and has a much

209
00:09:44,440 --> 00:09:47,320
simpler language than this another great

210
00:09:47,320 --> 00:09:49,930
thing about vast oversea is has what

211
00:09:49,930 --> 00:09:53,290
they call hygienic macros in c macro

212
00:09:53,290 --> 00:09:56,740
expansion happens before just after

213
00:09:56,740 --> 00:09:58,770
tokenization but before the parsing

214
00:09:58,770 --> 00:10:02,050
stage in the compiler so you could have

215
00:10:02,050 --> 00:10:05,500
strange things like this where i yeah

216
00:10:05,500 --> 00:10:07,360
macro accidentally captures may identify

217
00:10:07,360 --> 00:10:10,450
ER from outside the macro or something

218
00:10:10,450 --> 00:10:12,610
you would hack it happens or like in

219
00:10:12,610 --> 00:10:14,380
this example there should be more

220
00:10:14,380 --> 00:10:20,920
parentheses around identifies the

221
00:10:20,920 --> 00:10:23,650
example this is the format args function

222
00:10:23,650 --> 00:10:28,750
in rust where you can the the formatting

223
00:10:28,750 --> 00:10:30,640
happens at compile time using a hygienic

224
00:10:30,640 --> 00:10:32,680
macro and this example here the

225
00:10:32,680 --> 00:10:35,200
exclamation mark indicate sets macro the

226
00:10:35,200 --> 00:10:38,290
two curly brackets indicate where the

227
00:10:38,290 --> 00:10:39,490
format documents go

228
00:10:39,490 --> 00:10:41,710
so the first string goes into the first

229
00:10:41,710 --> 00:10:43,630
going back it the southern goes into the

230
00:10:43,630 --> 00:10:45,340
second one you don't have to think about

231
00:10:45,340 --> 00:10:46,960
try use a percent Diorshow use the

232
00:10:46,960 --> 00:10:48,640
percent Lu or should I use the percent

233
00:10:48,640 --> 00:10:52,060
ll do a compile time are nasty figures

234
00:10:52,060 --> 00:10:53,650
of the types if you put too many

235
00:10:53,650 --> 00:10:54,790
arguments

236
00:10:54,790 --> 00:10:57,220
it's a compile time here if you have an

237
00:10:57,220 --> 00:10:57,860
argument which

238
00:10:57,860 --> 00:11:00,560
can't print it's a compile-time her and

239
00:11:00,560 --> 00:11:06,950
see it's like that's like you could have

240
00:11:06,950 --> 00:11:09,440
mistakes like that we cast the five to a

241
00:11:09,440 --> 00:11:11,209
car pointer and this is completely

242
00:11:11,209 --> 00:11:13,880
undefined behavior there's the compiler

243
00:11:13,880 --> 00:11:15,470
usually doesn't check that some in some

244
00:11:15,470 --> 00:11:18,350
compilers you have warnings but it's

245
00:11:18,350 --> 00:11:23,209
undefined behavior here's another

246
00:11:23,209 --> 00:11:27,560
example in C undefined behavior it's

247
00:11:27,560 --> 00:11:30,880
kind of difficult to tell but that

248
00:11:30,880 --> 00:11:33,500
buffer there's no guarantee that this

249
00:11:33,500 --> 00:11:35,720
buffer is initialized to a value it

250
00:11:35,720 --> 00:11:37,010
actually depends on the implementation

251
00:11:37,010 --> 00:11:40,040
of bas print in some Senate libraries

252
00:11:40,040 --> 00:11:42,649
and might initialize it to a valid value

253
00:11:42,649 --> 00:11:48,140
in some it might not so this is sultan

254
00:11:48,140 --> 00:11:49,760
just because you can't have a reference

255
00:11:49,760 --> 00:11:54,740
just something that is not valid move

256
00:11:54,740 --> 00:11:57,470
need for inlining oh another great thing

257
00:11:57,470 --> 00:12:00,019
is about format in many c projects you

258
00:12:00,019 --> 00:12:02,600
might find different developers argue

259
00:12:02,600 --> 00:12:06,199
over tabs with spaces or clement styles

260
00:12:06,199 --> 00:12:09,860
in nasta is one way which is even less

261
00:12:09,860 --> 00:12:12,440
format on your code and you just don't

262
00:12:12,440 --> 00:12:15,230
talk about anymore and mess format also

263
00:12:15,230 --> 00:12:18,140
has also simplifies the code here so you

264
00:12:18,140 --> 00:12:21,019
can see so this is a diff before and

265
00:12:21,019 --> 00:12:22,610
after winning best format and you can

266
00:12:22,610 --> 00:12:28,060
see it removes this empty generic thing

267
00:12:28,060 --> 00:12:30,680
this simplifies the code it wasn't

268
00:12:30,680 --> 00:12:33,920
needed it's quite nice so now i'm gonna

269
00:12:33,920 --> 00:12:35,899
go over the design principles behind

270
00:12:35,899 --> 00:12:38,570
what we have this thing called the

271
00:12:38,570 --> 00:12:41,060
driver model and we're still debating

272
00:12:41,060 --> 00:12:42,709
whether or not this is the correct model

273
00:12:42,709 --> 00:12:45,380
but we find it quite useful so far

274
00:12:45,380 --> 00:12:48,019
so essentially what a trait is in rest a

275
00:12:48,019 --> 00:12:50,690
trait is kind of like an interface and

276
00:12:50,690 --> 00:12:52,220
you implement this interface by

277
00:12:52,220 --> 00:12:53,779
implementing the four functions you have

278
00:12:53,779 --> 00:12:56,899
to admit you have a read a write my shut

279
00:12:56,899 --> 00:12:59,750
down so we call it pv dispositional need

280
00:12:59,750 --> 00:13:02,600
the second argument is the position the

281
00:13:02,600 --> 00:13:06,170
same as p right when you read you pass

282
00:13:06,170 --> 00:13:09,110
in a mutable buffer so a reference to a

283
00:13:09,110 --> 00:13:11,270
mutable buffer the read function fills

284
00:13:11,270 --> 00:13:11,839
in the bath

285
00:13:11,839 --> 00:13:14,420
with data from the driver and it returns

286
00:13:14,420 --> 00:13:17,689
a result type so result typing rest is

287
00:13:17,689 --> 00:13:22,160
either number so in this case would be

288
00:13:22,160 --> 00:13:24,769
you size a number or it's an error and

289
00:13:24,769 --> 00:13:28,519
the error as you see up here is a string

290
00:13:28,519 --> 00:13:30,860
so all our error codes are strings which

291
00:13:30,860 --> 00:13:35,089
you can print and are human readable so

292
00:13:35,089 --> 00:13:36,800
we kind of this drive is kind of if I

293
00:13:36,800 --> 00:13:38,420
could be used for like what you'd call

294
00:13:38,420 --> 00:13:41,389
block devices or car devices since you

295
00:13:41,389 --> 00:13:43,370
could ignore the driver who ignore the

296
00:13:43,370 --> 00:13:46,100
position like the offset and it behaves

297
00:13:46,100 --> 00:13:49,129
comes like a car device or it could be

298
00:13:49,129 --> 00:13:54,100
used as kind of a block device as well

299
00:13:54,100 --> 00:13:56,120
so you here's some examples of the

300
00:13:56,120 --> 00:13:59,809
drivers we implemented so we have what

301
00:13:59,809 --> 00:14:01,220
we call physical drivers which are

302
00:14:01,220 --> 00:14:03,620
backed by actual devices in hardware so

303
00:14:03,620 --> 00:14:05,509
we have memory which reads and writes to

304
00:14:05,509 --> 00:14:09,050
memory we have a couple serials drivers

305
00:14:09,050 --> 00:14:12,649
the read and write to steal devices we

306
00:14:12,649 --> 00:14:15,589
have clock DDR they initialize the clock

307
00:14:15,589 --> 00:14:17,899
you need you have respectively then we

308
00:14:17,899 --> 00:14:19,459
have are these useful things for the

309
00:14:19,459 --> 00:14:21,470
virtual drivers so these ones aren't

310
00:14:21,470 --> 00:14:25,220
backed by actual hardware but they still

311
00:14:25,220 --> 00:14:27,230
implement the driver interface so we

312
00:14:27,230 --> 00:14:30,199
have Union this one is very useful and

313
00:14:30,199 --> 00:14:33,259
you you sort of it's useful in sense i

314
00:14:33,259 --> 00:14:34,939
if you have multiple you hot drivers and

315
00:14:34,939 --> 00:14:36,920
machine so for example if you have you

316
00:14:36,920 --> 00:14:40,639
at 0 you want one you can create a union

317
00:14:40,639 --> 00:14:42,230
of them and whenever you perform a right

318
00:14:42,230 --> 00:14:45,860
to the Union driver it pushes the

319
00:14:45,860 --> 00:14:48,319
characters to both of the yacht's so

320
00:14:48,319 --> 00:14:50,360
it's kind of like a fork I'll explain it

321
00:14:50,360 --> 00:14:52,069
more in the next slide then we have a

322
00:14:52,069 --> 00:14:53,629
slice sweeter so if you're not familiar

323
00:14:53,629 --> 00:14:55,519
a slice is kind of like nerve a in the

324
00:14:55,519 --> 00:14:57,800
rest I mean essentially the striper just

325
00:14:57,800 --> 00:15:00,889
reads from a prefilled in slice and this

326
00:15:00,889 --> 00:15:03,170
is useful in testing as well as a

327
00:15:03,170 --> 00:15:05,689
section reader this one's particularly

328
00:15:05,689 --> 00:15:08,029
useful so for example if you have a spy

329
00:15:08,029 --> 00:15:11,480
device which reads from a like just say

330
00:15:11,480 --> 00:15:13,129
for example you spy as 32 megabytes

331
00:15:13,129 --> 00:15:15,610
they kind of want to have a driver which

332
00:15:15,610 --> 00:15:19,100
is a partition of that spy device you

333
00:15:19,100 --> 00:15:21,050
can initialize a slide you reader with

334
00:15:21,050 --> 00:15:23,480
offset and size so that driver could

335
00:15:23,480 --> 00:15:25,020
only read from that small

336
00:15:25,020 --> 00:15:27,810
petitioning of the spy driver and use it

337
00:15:27,810 --> 00:15:29,130
the section unit for multiple things

338
00:15:29,130 --> 00:15:32,520
it's pretty nice so yeah here's an

339
00:15:32,520 --> 00:15:35,220
example where we create a console with

340
00:15:35,220 --> 00:15:38,160
multiple yachts now so this was on the

341
00:15:38,160 --> 00:15:43,410
ast 2 5 0 0 and they had five yachts so

342
00:15:43,410 --> 00:15:45,750
we kind of wanted to write to all of us

343
00:15:45,750 --> 00:15:48,330
at once we created many of them we

344
00:15:48,330 --> 00:15:49,920
created the Union driver using this

345
00:15:49,920 --> 00:15:52,020
array we initialized it when you're

346
00:15:52,020 --> 00:15:54,060
doing in it it knits all the drivers all

347
00:15:54,060 --> 00:15:56,850
five of them we do a PV so we write to

348
00:15:56,850 --> 00:15:57,990
it it doesn't matter what the position

349
00:15:57,990 --> 00:15:59,760
read to it because it's a kind of like a

350
00:15:59,760 --> 00:16:03,000
car device amiright to it awaits welcome

351
00:16:03,000 --> 00:16:08,060
to our boot to all the yours and then

352
00:16:08,060 --> 00:16:10,399
down here we show the example of using

353
00:16:10,399 --> 00:16:17,730
the like the the vast printf the amico

354
00:16:17,730 --> 00:16:20,250
the for my uggs and we can of eight the

355
00:16:20,250 --> 00:16:23,480
format the output seven to that console

356
00:16:23,480 --> 00:16:25,680
so we essentially get printf for free

357
00:16:25,680 --> 00:16:28,770
here as easy to add and configure new

358
00:16:28,770 --> 00:16:31,440
drivers we talked to V implement printf

359
00:16:31,440 --> 00:16:35,630
like every other C project in existence

360
00:16:35,630 --> 00:16:38,399
so here's some examples of with that in

361
00:16:38,399 --> 00:16:39,540
mind here's an example of the bio

362
00:16:39,540 --> 00:16:42,839
checker and we have saved us so in this

363
00:16:42,839 --> 00:16:45,209
example minish lies you I mean it you

364
00:16:45,209 --> 00:16:49,579
what we're 8/8 yacht and that's all fine

365
00:16:49,579 --> 00:16:52,170
then we tried to initialize the clocks

366
00:16:52,170 --> 00:16:53,940
so if we see down there the line with

367
00:16:53,940 --> 00:16:57,000
clock new that creates a new clock

368
00:16:57,000 --> 00:16:59,310
driver and then we have P rate on to the

369
00:16:59,310 --> 00:17:01,170
clock driver and that turns on the

370
00:17:01,170 --> 00:17:06,209
clocks but when you turn the clocks you

371
00:17:06,209 --> 00:17:09,929
have to update the divider in the uot

372
00:17:09,929 --> 00:17:12,329
otherwise the UART will be much faster

373
00:17:12,329 --> 00:17:15,179
than expected so first you decrease the

374
00:17:15,179 --> 00:17:17,040
divider in you what they need to run the

375
00:17:17,040 --> 00:17:19,949
clocks so that the UI has a constant 1 1

376
00:17:19,949 --> 00:17:24,329
5 0 0 so a 1 1 5 2 0 0 Padre so we pass

377
00:17:24,329 --> 00:17:30,570
in all the drivers into the clock and it

378
00:17:30,570 --> 00:17:32,550
flushes you our drivers before changing

379
00:17:32,550 --> 00:17:34,260
the speed such that you don't you lose

380
00:17:34,260 --> 00:17:37,440
any characters so in this case we

381
00:17:37,440 --> 00:17:38,610
essentially

382
00:17:38,610 --> 00:17:44,880
passing the clock driver is taking

383
00:17:44,880 --> 00:17:48,390
immutable immutable reference to the uot

384
00:17:48,390 --> 00:17:52,169
driver reinitialized here and it's using

385
00:17:52,169 --> 00:17:54,419
this reference so we initialize a new

386
00:17:54,419 --> 00:17:57,059
clock drivers using this reference on

387
00:17:57,059 --> 00:18:00,390
this line inside the P wave function but

388
00:18:00,390 --> 00:18:03,140
since the clock driver has a reference

389
00:18:03,140 --> 00:18:07,409
we can't also pivot to it yeah where we

390
00:18:07,409 --> 00:18:11,010
can P right afterwards because the clock

391
00:18:11,010 --> 00:18:13,110
driver is no longer borrowing the

392
00:18:13,110 --> 00:18:17,789
reference to the UART driver and this

393
00:18:17,789 --> 00:18:19,470
might seem complicated and you can see

394
00:18:19,470 --> 00:18:21,480
here's the the error message here and

395
00:18:21,480 --> 00:18:23,370
the end messages are actually quite

396
00:18:23,370 --> 00:18:26,669
useful it says the line where the first

397
00:18:26,669 --> 00:18:29,909
middle occurs and the line where is

398
00:18:29,909 --> 00:18:33,720
later captured and as well as where the

399
00:18:33,720 --> 00:18:36,750
second mutable reference occurs and so

400
00:18:36,750 --> 00:18:38,880
it's good to remember this quote at any

401
00:18:38,880 --> 00:18:40,710
given time you can have either one

402
00:18:40,710 --> 00:18:42,539
middle of reference or any number of

403
00:18:42,539 --> 00:18:44,669
mutable references references must

404
00:18:44,669 --> 00:18:47,970
always be valid so that breaks the first

405
00:18:47,970 --> 00:18:50,090
rule

406
00:18:50,279 --> 00:18:52,049
so this is how he layout flash it will

407
00:18:52,049 --> 00:18:56,549
be the the flash on the the high five

408
00:18:56,549 --> 00:19:00,120
processor where we tested this has 32

409
00:19:00,120 --> 00:19:01,500
megabytes which is much more than we

410
00:19:01,500 --> 00:19:05,039
need so we're kind of we kind of had

411
00:19:05,039 --> 00:19:07,559
large partitions much larger than we

412
00:19:07,559 --> 00:19:10,380
needed so the boot blob which is the

413
00:19:10,380 --> 00:19:13,529
initial assembly jumps down to the ROM

414
00:19:13,529 --> 00:19:17,370
payload and this is the a and B

415
00:19:17,370 --> 00:19:19,080
partition and we have the am/pm payload

416
00:19:19,080 --> 00:19:21,659
a and B partition we invited this thing

417
00:19:21,659 --> 00:19:26,279
called a device G filesystem so we store

418
00:19:26,279 --> 00:19:28,409
all the information in essentially a

419
00:19:28,409 --> 00:19:31,139
device tree it's kind of an abuse of

420
00:19:31,139 --> 00:19:32,549
what you might think of the pastries

421
00:19:32,549 --> 00:19:34,860
like a list of devices essentially it's

422
00:19:34,860 --> 00:19:37,260
a list of files stored in the device

423
00:19:37,260 --> 00:19:40,500
tree to be used as if it were filesystem

424
00:19:40,500 --> 00:19:43,320
and the reason we film is convenient is

425
00:19:43,320 --> 00:19:45,299
dimensionally we are planning to use C

426
00:19:45,299 --> 00:19:48,539
BFS and to be able to access the files

427
00:19:48,539 --> 00:19:50,850
from Linux in C BFS we were originally

428
00:19:50,850 --> 00:19:52,240
planning to raid a

429
00:19:52,240 --> 00:19:55,360
fewest file system to read CB FS from

430
00:19:55,360 --> 00:19:58,990
Linux we found if we just use DT like

431
00:19:58,990 --> 00:20:01,720
device trees we can pass the device tree

432
00:20:01,720 --> 00:20:04,990
into Linux - the typical means and the

433
00:20:04,990 --> 00:20:06,940
device tree would appear under sis

434
00:20:06,940 --> 00:20:09,220
firmware DT so all the files that you'd

435
00:20:09,220 --> 00:20:11,800
have access to infirmary you can pass to

436
00:20:11,800 --> 00:20:15,880
the kernel through this interface so for

437
00:20:15,880 --> 00:20:19,290
example if you wanted to store a like a

438
00:20:19,290 --> 00:20:22,540
for example splash screen that you want

439
00:20:22,540 --> 00:20:25,000
to display in Linux you store in the

440
00:20:25,000 --> 00:20:28,090
GTFS extreme littlenecks you know

441
00:20:28,090 --> 00:20:30,550
automatically appear insists firmware DT

442
00:20:30,550 --> 00:20:32,500
and it's kind of an abuse of semantics

443
00:20:32,500 --> 00:20:34,660
is device chase supposed to be for

444
00:20:34,660 --> 00:20:37,360
devices but you can also store our files

445
00:20:37,360 --> 00:20:39,730
in it which we found quite nice so

446
00:20:39,730 --> 00:20:43,230
currently our boot is only 31 kilobytes

447
00:20:43,230 --> 00:20:46,990
which is very small it's about thousand

448
00:20:46,990 --> 00:20:52,360
times smaller than the flash point so

449
00:20:52,360 --> 00:20:55,450
this is an example of how like the the

450
00:20:55,450 --> 00:20:57,280
vice tree file system you can see the

451
00:20:57,280 --> 00:21:00,760
files that we straw in it like how we we

452
00:21:00,760 --> 00:21:02,710
mapped the previous description of the

453
00:21:02,710 --> 00:21:08,320
areas to a device tree format this is

454
00:21:08,320 --> 00:21:10,630
kind of how we our build system so

455
00:21:10,630 --> 00:21:13,059
currently we use what they call the the

456
00:21:13,059 --> 00:21:16,870
cargo make extension to cargo so we

457
00:21:16,870 --> 00:21:18,370
still have these make files but in there

458
00:21:18,370 --> 00:21:22,450
in a Tamil format we're trying to avoid

459
00:21:22,450 --> 00:21:24,280
key config it seems like we'll have to

460
00:21:24,280 --> 00:21:26,740
come up with a similar system because

461
00:21:26,740 --> 00:21:29,290
it's a bit difficult to like configure

462
00:21:29,290 --> 00:21:31,840
stuff by directly editing the make files

463
00:21:31,840 --> 00:21:36,460
at this time here's an example of the

464
00:21:36,460 --> 00:21:40,300
the source organization it's very

465
00:21:40,300 --> 00:21:42,130
similar to qua boot it's based off of

466
00:21:42,130 --> 00:21:44,380
Abu we have the main boards inside each

467
00:21:44,380 --> 00:21:47,200
main board we have a vendor and then we

468
00:21:47,200 --> 00:21:49,900
have the individual boards inside the

469
00:21:49,900 --> 00:21:53,559
vendor directory we have socks which the

470
00:21:53,559 --> 00:21:55,570
main board usually imports the sock and

471
00:21:55,570 --> 00:21:57,400
the sock imports the drivers or the

472
00:21:57,400 --> 00:21:59,190
mainboard and puts a driver's directly

473
00:21:59,190 --> 00:22:01,090
payloads is outside of the source

474
00:22:01,090 --> 00:22:03,130
directory because you could build a

475
00:22:03,130 --> 00:22:05,050
payload externally to building a boot

476
00:22:05,050 --> 00:22:05,590
and

477
00:22:05,590 --> 00:22:09,820
and the payload later another useful

478
00:22:09,820 --> 00:22:12,850
property vest is there's no dynamic you

479
00:22:12,850 --> 00:22:14,110
could use it without any dynamic

480
00:22:14,110 --> 00:22:17,559
allocation it's very easy to stack

481
00:22:17,559 --> 00:22:23,169
allocating and last has a as a tool you

482
00:22:23,169 --> 00:22:25,690
can use that the LLVM compiler to tell

483
00:22:25,690 --> 00:22:28,360
you how large your stack size is so at

484
00:22:28,360 --> 00:22:29,860
compile time you can prove that you

485
00:22:29,860 --> 00:22:32,440
won't have a stack overflow because the

486
00:22:32,440 --> 00:22:34,240
compiler told you how biggest stack is

487
00:22:34,240 --> 00:22:36,279
you make sure you allocate that much

488
00:22:36,279 --> 00:22:38,649
space and then you don't really have to

489
00:22:38,649 --> 00:22:42,450
worry about there being stack overflow

490
00:22:42,450 --> 00:22:44,470
something else we want to implement is

491
00:22:44,470 --> 00:22:48,640
curvy jeans so the squared again is

492
00:22:48,640 --> 00:22:50,890
useful here at any given time you can

493
00:22:50,890 --> 00:22:53,020
either have one mutable reference by any

494
00:22:53,020 --> 00:22:54,360
number of immutable references

495
00:22:54,360 --> 00:22:57,190
references must always be valid which is

496
00:22:57,190 --> 00:23:00,730
very similar to databases in grasp so it

497
00:23:00,730 --> 00:23:03,010
databases in computer science so you

498
00:23:03,010 --> 00:23:04,690
have a database when you have two things

499
00:23:04,690 --> 00:23:06,730
relating to the same object at the same

500
00:23:06,730 --> 00:23:10,059
time memory unless that's not possible

501
00:23:10,059 --> 00:23:11,919
because you can't have two mutable

502
00:23:11,919 --> 00:23:16,840
references the same thing which sort of

503
00:23:16,840 --> 00:23:18,580
in a way makes rescue memory safe as

504
00:23:18,580 --> 00:23:20,490
long as you don't use unsafe keyword

505
00:23:20,490 --> 00:23:22,720
this is something we've not implemented

506
00:23:22,720 --> 00:23:24,940
yet but it's something that we will need

507
00:23:24,940 --> 00:23:28,659
if you want to have our the holy grail

508
00:23:28,659 --> 00:23:32,529
of firmware which is one second boots so

509
00:23:32,529 --> 00:23:34,480
we'd have a separate codeine for you at

510
00:23:34,480 --> 00:23:39,299
step one for Spy they'd be pulling on

511
00:23:39,299 --> 00:23:43,960
being ready for new data and out of each

512
00:23:43,960 --> 00:23:46,059
cycle of the pole they would yield the

513
00:23:46,059 --> 00:23:48,100
scheduler the schedule of and robbing

514
00:23:48,100 --> 00:23:51,039
everything that was yielding to it it's

515
00:23:51,039 --> 00:23:52,320
fairly simple

516
00:23:52,320 --> 00:23:54,760
Perris we still need help to implement

517
00:23:54,760 --> 00:24:01,450
this so okay so finally running on

518
00:24:01,450 --> 00:24:04,059
hardware so I first talked it was creamy

519
00:24:04,059 --> 00:24:07,960
system on the stem was very short we

520
00:24:07,960 --> 00:24:12,730
only will need this one in QEMU so see

521
00:24:12,730 --> 00:24:13,630
here when you run it

522
00:24:13,630 --> 00:24:16,149
okay CD to the rate directory let's see

523
00:24:16,149 --> 00:24:17,600
if you speed this up

524
00:24:17,600 --> 00:24:22,610
Ceri mainboards emulation mu we have

525
00:24:22,610 --> 00:24:25,160
this convenience function a mikvah which

526
00:24:25,160 --> 00:24:28,100
is cargo make run and just runs it for

527
00:24:28,100 --> 00:24:32,929
you in q mu so you can see here what we

528
00:24:32,929 --> 00:24:35,690
did was it went by kind of fast you can

529
00:24:35,690 --> 00:24:37,610
see it printed the device tree then put

530
00:24:37,610 --> 00:24:39,679
Linux it jumped to you root and then

531
00:24:39,679 --> 00:24:42,500
said the huge shell I listed some

532
00:24:42,500 --> 00:24:49,309
directories so this was relatively

533
00:24:49,309 --> 00:24:55,909
simple but this was only incur mu when

534
00:24:55,909 --> 00:24:57,919
he went to him when he went to port it

535
00:24:57,919 --> 00:25:00,140
from q mu into hardware we had some

536
00:25:00,140 --> 00:25:04,490
difficulty because the data she was NDA

537
00:25:04,490 --> 00:25:07,100
so we didn't have access to the data

538
00:25:07,100 --> 00:25:09,679
sheet which made the poor team kind of

539
00:25:09,679 --> 00:25:12,740
difficult so in debt stead we jump to

540
00:25:12,740 --> 00:25:17,679
this v this is a high five on each board

541
00:25:17,679 --> 00:25:22,190
it has a sigh v fu 540 processor it has

542
00:25:22,190 --> 00:25:24,980
one management processor and there has

543
00:25:24,980 --> 00:25:27,890
four processors which are capable of an

544
00:25:27,890 --> 00:25:31,760
English has EQ bytes of ddr4 as 30

545
00:25:31,760 --> 00:25:34,100
megabytes of flash has spy you watch

546
00:25:34,100 --> 00:25:36,559
pretty much everything you want it's

547
00:25:36,559 --> 00:25:39,110
very convenient to program the

548
00:25:39,110 --> 00:25:40,690
architecture is a bit different from arm

549
00:25:40,690 --> 00:25:44,120
so you can see here the boot blob runs

550
00:25:44,120 --> 00:25:49,820
from that so the code starts on the the

551
00:25:49,820 --> 00:25:55,340
management koi you can initialize the

552
00:25:55,340 --> 00:25:58,190
CPU set up the car then you jump to the

553
00:25:58,190 --> 00:26:00,650
realm stage we you print the you up

554
00:26:00,650 --> 00:26:02,600
message initialize the clocks and the

555
00:26:02,600 --> 00:26:05,630
pure CI which is the power reset clock

556
00:26:05,630 --> 00:26:10,789
interrupts unity initialize the DDI so

557
00:26:10,789 --> 00:26:13,190
until DB asana flies use the caches name

558
00:26:13,190 --> 00:26:15,799
the l2 cache it's fairly simple to

559
00:26:15,799 --> 00:26:18,770
initialize DDR and then you copy the

560
00:26:18,770 --> 00:26:21,830
payload from Spy intagram and you jump

561
00:26:21,830 --> 00:26:24,919
to and the payload is mix so the way we

562
00:26:24,919 --> 00:26:27,559
program this was at the daddy prog you

563
00:26:27,559 --> 00:26:29,390
have to make sure these n cell bits on

564
00:26:29,390 --> 00:26:31,340
the right positions

565
00:26:31,340 --> 00:26:34,810
and in this position it jumps over the F

566
00:26:34,810 --> 00:26:38,030
SPFs BL and the b BL and it goes rate

567
00:26:38,030 --> 00:26:40,130
two of you so we skipped the existing

568
00:26:40,130 --> 00:26:43,820
bouleris on that system the blue blob is

569
00:26:43,820 --> 00:26:45,440
very small sizes all the assembly we

570
00:26:45,440 --> 00:26:48,340
have in wobbu it's like one two three

571
00:26:48,340 --> 00:26:52,040
four five lines so we initialize caches

572
00:26:52,040 --> 00:26:55,910
Ram we spend currently we spin all the

573
00:26:55,910 --> 00:26:58,730
CPUs except for CPU zero we want to

574
00:26:58,730 --> 00:27:00,830
implement SMP in future but currently

575
00:27:00,830 --> 00:27:02,810
we're only booting one CPU and then we

576
00:27:02,810 --> 00:27:06,470
jump to start the REM stage is some

577
00:27:06,470 --> 00:27:10,310
simple Europeans then we initialize our

578
00:27:10,310 --> 00:27:12,170
clocks and you see this is the first

579
00:27:12,170 --> 00:27:14,120
time we initialize the clocks we made

580
00:27:14,120 --> 00:27:16,130
the mistake where you I was running up

581
00:27:16,130 --> 00:27:18,770
this body weight and the UI is a clock

582
00:27:18,770 --> 00:27:22,220
divider on the the core clock and we

583
00:27:22,220 --> 00:27:24,470
went to initialize the clocks it jumped

584
00:27:24,470 --> 00:27:26,240
to like 50 times faster than the

585
00:27:26,240 --> 00:27:28,070
expected baud rate so that shows you

586
00:27:28,070 --> 00:27:29,690
first have to drop the clock divider

587
00:27:29,690 --> 00:27:33,190
then initialize UART

588
00:27:33,190 --> 00:27:35,390
the memory net was fairly simple

589
00:27:35,390 --> 00:27:37,490
essentially it's code which copies is

590
00:27:37,490 --> 00:27:39,230
like a thousand control registers you

591
00:27:39,230 --> 00:27:41,240
just copy them into the memory mapped

592
00:27:41,240 --> 00:27:45,920
address we use the FSB L and the Kabu

593
00:27:45,920 --> 00:27:49,820
implementations as reference it's pretty

594
00:27:49,820 --> 00:27:51,860
much currently it's pretty much a direct

595
00:27:51,860 --> 00:27:55,010
C to vast translation of the code it was

596
00:27:55,010 --> 00:27:57,260
only a few days of work which is it's

597
00:27:57,260 --> 00:28:01,730
fairly easy eventual goal is to boot the

598
00:28:01,730 --> 00:28:05,240
kernel in M mode so currently we're

599
00:28:05,240 --> 00:28:08,570
using this patch the no MMU patch from

600
00:28:08,570 --> 00:28:11,060
Krista's Hellwig and this lets us boot

601
00:28:11,060 --> 00:28:16,130
the kernel in M mode on in qmu it

602
00:28:16,130 --> 00:28:17,380
currently does not support

603
00:28:17,380 --> 00:28:20,090
actual hardware that's hopefully

604
00:28:20,090 --> 00:28:21,320
something we want to work on on

605
00:28:21,320 --> 00:28:23,630
hackathon this week it's a very exciting

606
00:28:23,630 --> 00:28:25,160
project so if you don't know m mode is

607
00:28:25,160 --> 00:28:29,000
kind of the SMM mode of this v we want

608
00:28:29,000 --> 00:28:35,720
to run the kernel in this M mode okay so

609
00:28:35,720 --> 00:28:37,940
this is how you can get involved so we

610
00:28:37,940 --> 00:28:39,920
have to a discussion as Lakhia the orbit

611
00:28:39,920 --> 00:28:42,440
channel on the you slack

612
00:28:42,440 --> 00:28:44,450
yeah github there's a bunch of bugs you

613
00:28:44,450 --> 00:28:45,880
could like

614
00:28:45,880 --> 00:28:48,220
if you're kind of new to Aston want to

615
00:28:48,220 --> 00:28:49,810
learn bit rest I highly recommend this

616
00:28:49,810 --> 00:28:52,660
online book the way I'll invest is you

617
00:28:52,660 --> 00:28:55,240
go through every single chapter you look

618
00:28:55,240 --> 00:28:57,130
at the code an epi chapter you type it

619
00:28:57,130 --> 00:28:59,680
out by hand make sure it compiles try

620
00:28:59,680 --> 00:29:01,240
flipping around some lines in the code

621
00:29:01,240 --> 00:29:04,840
to see how the see how the bajo chapter

622
00:29:04,840 --> 00:29:08,200
reacts it takes a bit of time to learn

623
00:29:08,200 --> 00:29:09,430
but it's definitely worth it

624
00:29:09,430 --> 00:29:11,320
I've fallen in this five I highly

625
00:29:11,320 --> 00:29:13,090
recommend this book it subscribe a

626
00:29:13,090 --> 00:29:15,010
hundred I think a hundred twenty pages

627
00:29:15,010 --> 00:29:17,350
but it describes the entire describe

628
00:29:17,350 --> 00:29:20,140
architecture which is very short for

629
00:29:20,140 --> 00:29:22,830
whole architecture and then we have a

630
00:29:22,830 --> 00:29:25,120
there's a bunch of tasks and you kind of

631
00:29:25,120 --> 00:29:27,220
want help with and we'll probably be

632
00:29:27,220 --> 00:29:29,680
working on some of these in the

633
00:29:29,680 --> 00:29:31,570
hackathon this week so if you want to

634
00:29:31,570 --> 00:29:33,430
drop by and like experience what it is

635
00:29:33,430 --> 00:29:37,240
like to work on Kabu Kabu please feel

636
00:29:37,240 --> 00:29:43,060
free and that's it any questions Thank

637
00:29:43,060 --> 00:29:44,290
You Ryan let's have another round of

638
00:29:44,290 --> 00:29:50,890
applause alright exactly on time so

639
00:29:50,890 --> 00:29:54,240
we've time for about ten ten questions

640
00:29:54,240 --> 00:29:57,460
j-just go up with microphones and ask

641
00:29:57,460 --> 00:30:04,600
you questions just line up yeah you said

642
00:30:04,600 --> 00:30:06,610
something about no NDA's but one of your

643
00:30:06,610 --> 00:30:08,230
supported target is the a speed which

644
00:30:08,230 --> 00:30:11,710
does not have a non NDA manual yeah and

645
00:30:11,710 --> 00:30:13,150
that's the reason we moved away from the

646
00:30:13,150 --> 00:30:15,070
a speed and we worked on the high five

647
00:30:15,070 --> 00:30:16,990
processor so are you planning to remove

648
00:30:16,990 --> 00:30:20,740
it until gives you an open area or it's

649
00:30:20,740 --> 00:30:22,720
pretty much removed at this time so you

650
00:30:22,720 --> 00:30:24,640
can still find the source code there in

651
00:30:24,640 --> 00:30:26,500
a directory but likely doesn't Kampala

652
00:30:26,500 --> 00:30:27,880
because you moved it from a CI system

653
00:30:27,880 --> 00:30:31,030
and no one really tests it so if it feel

654
00:30:31,030 --> 00:30:36,930
free to send a patch to move it I

655
00:30:36,930 --> 00:30:40,210
interested how the code size looks with

656
00:30:40,210 --> 00:30:42,400
us for example you said that you

657
00:30:42,400 --> 00:30:43,960
essentially get a printer for free right

658
00:30:43,960 --> 00:30:45,460
but you don't really get it for free you

659
00:30:45,460 --> 00:30:47,560
get it by dragging in a giant standard

660
00:30:47,560 --> 00:30:50,260
libraries so currently all the abu code

661
00:30:50,260 --> 00:30:54,550
that we use the boot of e-ink um you use

662
00:30:54,550 --> 00:30:58,000
it so we use the same or boot by me for

663
00:30:58,000 --> 00:30:58,759
qm you

664
00:30:58,759 --> 00:31:01,009
and on hardware which is kind of nice

665
00:31:01,009 --> 00:31:02,839
because you could test ink um you you

666
00:31:02,839 --> 00:31:05,629
take someone test on hardware taboo

667
00:31:05,629 --> 00:31:08,779
Linux ink um you it's only 31 kilobytes

668
00:31:08,779 --> 00:31:10,940
and that's including the printf

669
00:31:10,940 --> 00:31:13,609
statement so it's very small I'm pretty

670
00:31:13,609 --> 00:31:15,649
impressed by the LLVM compiler we use

671
00:31:15,649 --> 00:31:18,049
what they call link time optimizations

672
00:31:18,049 --> 00:31:20,659
which is really able to like remove a

673
00:31:20,659 --> 00:31:23,179
lot of code like it it's kind of

674
00:31:23,179 --> 00:31:25,699
inlining but between different modules

675
00:31:25,699 --> 00:31:28,549
and the code is very very very good but

676
00:31:28,549 --> 00:31:30,709
if you done something like take about

677
00:31:30,709 --> 00:31:32,449
the same amount of code like the same

678
00:31:32,449 --> 00:31:34,129
driver or something from core wood and

679
00:31:34,129 --> 00:31:36,440
or board and compare um we haven't

680
00:31:36,440 --> 00:31:40,609
really done that comparison yet know how

681
00:31:40,609 --> 00:31:43,009
do you put the same orbit on cameo and

682
00:31:43,009 --> 00:31:44,659
hardware ah so essentially what we have

683
00:31:44,659 --> 00:31:49,190
is it's kind of a hack but we have these

684
00:31:49,190 --> 00:31:52,399
is qemu functions so it is if it is not

685
00:31:52,399 --> 00:31:55,690
creamy we skip how do you know oh

686
00:31:55,690 --> 00:31:57,859
there's actually a few ways of telling

687
00:31:57,859 --> 00:31:59,719
what we do right now is we look at this

688
00:31:59,719 --> 00:32:02,629
register in the mask ROM and curiam you

689
00:32:02,629 --> 00:32:04,399
we know it should be this value and on

690
00:32:04,399 --> 00:32:06,169
Hardware we know it's that value and

691
00:32:06,169 --> 00:32:07,729
they kind of differ in the

692
00:32:07,729 --> 00:32:10,369
implementations so in the future QM you

693
00:32:10,369 --> 00:32:13,009
might look more like hardware in which

694
00:32:13,009 --> 00:32:14,479
case we kind of have to change our is

695
00:32:14,479 --> 00:32:18,440
QEMU function but for now it works all

696
00:32:18,440 --> 00:32:19,729
right so what's the plan for like

697
00:32:19,729 --> 00:32:22,009
running on the hi-5 Unleashed income you

698
00:32:22,009 --> 00:32:24,889
the model of the Unleashed income

699
00:32:24,889 --> 00:32:27,499
yeah so right now the Machine type

700
00:32:27,499 --> 00:32:29,809
you're using Q mu is the size 5 and the

701
00:32:29,809 --> 00:32:32,809
square you we have we had to make a few

702
00:32:32,809 --> 00:32:34,639
patches to that to make it look more

703
00:32:34,639 --> 00:32:38,709
like hardware so for example Q mu loads

704
00:32:38,709 --> 00:32:42,859
the the firmware at offset zero X 8 with

705
00:32:42,859 --> 00:32:45,979
seven zeros when Hardware loads at 0 X 2

706
00:32:45,979 --> 00:32:47,690
with seven zeros so we had to make some

707
00:32:47,690 --> 00:32:49,429
patches in cream.you to add that section

708
00:32:49,429 --> 00:32:52,549
and load into different place but for

709
00:32:52,549 --> 00:32:54,199
the most part the code is very similar

710
00:32:54,199 --> 00:32:56,089
okay so you're right you're running this

711
00:32:56,089 --> 00:33:07,309
i-5 you that what you have to use the

712
00:33:07,309 --> 00:33:09,499
initialize the UART and then adjust the

713
00:33:09,499 --> 00:33:12,230
clocks why you don't do it

714
00:33:12,230 --> 00:33:14,059
when you before you initialize the your

715
00:33:14,059 --> 00:33:15,919
tour during the installation because

716
00:33:15,919 --> 00:33:17,480
what we want some prints to happen

717
00:33:17,480 --> 00:33:19,730
before we initialize the clocks and we

718
00:33:19,730 --> 00:33:21,110
want some prints to happen afterwards

719
00:33:21,110 --> 00:33:24,320
but since the you what they use the same

720
00:33:24,320 --> 00:33:26,840
clock sort it you should use the clock

721
00:33:26,840 --> 00:33:30,110
source the same one as the CPU so CPU

722
00:33:30,110 --> 00:33:32,029
clock Swiss by default events at 33

723
00:33:32,029 --> 00:33:34,039
megahertz and then when you initialize

724
00:33:34,039 --> 00:33:36,460
the PLL it jumps to I think 1 gigahertz

725
00:33:36,460 --> 00:33:40,159
and since the UI is a clock divided on

726
00:33:40,159 --> 00:33:41,510
that clock you kind of have to change

727
00:33:41,510 --> 00:33:44,630
the divider at some point so you want to

728
00:33:44,630 --> 00:33:46,880
see some new arts for debug yeah before

729
00:33:46,880 --> 00:33:49,580
you bumped yeah ok

730
00:33:49,580 --> 00:33:57,260
and then I have another question would

731
00:33:57,260 --> 00:33:59,299
rust would be a good potential to

732
00:33:59,299 --> 00:34:02,299
replace other usage of C oh it's only

733
00:34:02,299 --> 00:34:07,789
kind of targeted to bootloader BIOS and

734
00:34:07,789 --> 00:34:11,960
Oh Stephanie is like elsewhere sorry for

735
00:34:11,960 --> 00:34:13,909
- a mass was originally created by

736
00:34:13,909 --> 00:34:16,879
Mozilla to be used in the web browser

737
00:34:16,879 --> 00:34:20,418
because they have a lot of I think it's

738
00:34:20,418 --> 00:34:22,790
a lab layout I'm not too familiar with

739
00:34:22,790 --> 00:34:24,829
the field bit they they want to lay out

740
00:34:24,829 --> 00:34:27,020
their webpages but currently it's very

741
00:34:27,020 --> 00:34:29,810
difficult to do safely in C++ so he

742
00:34:29,810 --> 00:34:31,940
wanted to put that to a safer language

743
00:34:31,940 --> 00:34:34,129
but one didn't exist which was efficient

744
00:34:34,129 --> 00:34:38,270
so they created rest for the task but it

745
00:34:38,270 --> 00:34:39,710
was also film that mass was also very

746
00:34:39,710 --> 00:34:42,918
useful for boot loaders or like firmware

747
00:34:42,918 --> 00:34:44,599
in general so it's kind of the other

748
00:34:44,599 --> 00:34:46,879
event first or is used in other fields

749
00:34:46,879 --> 00:34:51,639
and then it moved to family ok thank you

750
00:34:54,469 --> 00:35:02,270
why a mode Linux oh why um I think so I

751
00:35:02,270 --> 00:35:06,140
guess the idea behind this is like we're

752
00:35:06,140 --> 00:35:08,720
from a mostly x86 background alkene and

753
00:35:08,720 --> 00:35:11,980
we have this aversion to SMM mode and

754
00:35:11,980 --> 00:35:16,369
seeing a mode on this 5 we sort of had

755
00:35:16,369 --> 00:35:18,980
the senior version and we feel that we

756
00:35:18,980 --> 00:35:21,020
can sort of solve this problem by

757
00:35:21,020 --> 00:35:22,700
running the kernel and mode in the most

758
00:35:22,700 --> 00:35:24,890
privileged mode and then there won't be

759
00:35:24,890 --> 00:35:25,970
anything below

760
00:35:25,970 --> 00:35:28,160
the chronology interferes with it that's

761
00:35:28,160 --> 00:35:30,260
nice but then there's no MMU right so

762
00:35:30,260 --> 00:35:52,520
yeah and no hypervisor support and more

763
00:35:52,520 --> 00:35:53,930
than that right hypervisors don't work

764
00:35:53,930 --> 00:35:56,540
then if you're running in M mode you

765
00:35:56,540 --> 00:35:58,520
know other future things you're gonna

766
00:35:58,520 --> 00:36:05,390
run into issues just wanted to add one

767
00:36:05,390 --> 00:36:09,140
point so no me me mode though anomia put

768
00:36:09,140 --> 00:36:11,119
the patches in now you pointed out yeah

769
00:36:11,119 --> 00:36:13,280
so does work on the cane right board

770
00:36:13,280 --> 00:36:16,099
hardware yeah yeah you said no hardware

771
00:36:16,099 --> 00:36:19,190
supports oh yeah that's just yeah yeah

772
00:36:19,190 --> 00:36:21,859
so it works on the it's the K two one

773
00:36:21,859 --> 00:36:22,190
zero

774
00:36:22,190 --> 00:36:24,140
but doesn't work on high five at the

775
00:36:24,140 --> 00:36:26,060
moment but I think our our main goals to

776
00:36:26,060 --> 00:36:27,800
get it to work on the high five this

777
00:36:27,800 --> 00:36:29,980
week

778
00:36:35,910 --> 00:36:38,220
rust is a relatively young language this

779
00:36:38,220 --> 00:36:40,440
is the first project I've heard of that

780
00:36:40,440 --> 00:36:41,849
uses it for firmware weird any

781
00:36:41,849 --> 00:36:43,890
challenges and making working embedded

782
00:36:43,890 --> 00:36:46,500
development um actually it's fairly easy

783
00:36:46,500 --> 00:36:49,680
I think most of the work has already

784
00:36:49,680 --> 00:36:52,559
been done to get working for firmware

785
00:36:52,559 --> 00:36:55,170
I'm albeit we actually do use the main

786
00:36:55,170 --> 00:36:56,670
Tunisian of acid you can't do any of

787
00:36:56,670 --> 00:37:00,089
this in a stable version but the working

788
00:37:00,089 --> 00:37:04,259
group for firmware for vast has done a

789
00:37:04,259 --> 00:37:06,089
really good job like setting up all the

790
00:37:06,089 --> 00:37:07,519
tools and making them easily accessible

791
00:37:07,519 --> 00:37:09,690
there are future tools you could find

792
00:37:09,690 --> 00:37:10,740
online

793
00:37:10,740 --> 00:37:14,880
to set up your tool chain to build rest

794
00:37:14,880 --> 00:37:20,039
for firmware so I had another question

795
00:37:20,039 --> 00:37:23,190
you mentioned there's no blobs but then

796
00:37:23,190 --> 00:37:25,410
you said to initialize memory you just

797
00:37:25,410 --> 00:37:27,630
copy like two kilobytes or whatever 10

798
00:37:27,630 --> 00:37:30,390
kilobytes of something into registers

799
00:37:30,390 --> 00:37:33,569
yeah it's a blob but you lose it yeah so

800
00:37:33,569 --> 00:37:35,910
I guess it's some I guess yeah there's

801
00:37:35,910 --> 00:37:39,329
some semantics behind it but so like

802
00:37:39,329 --> 00:37:41,430
it's not the blob is an executable code

803
00:37:41,430 --> 00:37:42,690
it's like a bunch of register

804
00:37:42,690 --> 00:37:46,680
configuration specific to this board it

805
00:37:46,680 --> 00:37:49,799
is true that we don't necessarily know

806
00:37:49,799 --> 00:37:54,539
what all these control registers do but

807
00:37:54,539 --> 00:37:57,329
at least it's not like X executable code

808
00:37:57,329 --> 00:37:59,250
that we don't know what it does but

809
00:37:59,250 --> 00:38:02,009
still you do you do have a good point as

810
00:38:02,009 --> 00:38:03,980
far as I know at the moment aren't as

811
00:38:03,980 --> 00:38:07,410
far as DDR controllers go it's very hard

812
00:38:07,410 --> 00:38:09,230
to find one which is actually fully

813
00:38:09,230 --> 00:38:15,539
opens open source I just wanted to

814
00:38:15,539 --> 00:38:17,670
mention after I put the tooling I laid

815
00:38:17,670 --> 00:38:19,680
out the first risk five sort of

816
00:38:19,680 --> 00:38:22,289
structure and then I did a cargo make

817
00:38:22,289 --> 00:38:24,539
and watch the thing say oh looks like

818
00:38:24,539 --> 00:38:26,460
you need the risk v version of rest okay

819
00:38:26,460 --> 00:38:28,410
pulling it down done few seconds later

820
00:38:28,410 --> 00:38:30,210
for anyone who has ever been through the

821
00:38:30,210 --> 00:38:33,119
hell of cross GCC building it was quite

822
00:38:33,119 --> 00:38:34,289
a miracle to watch it happen

823
00:38:34,289 --> 00:38:37,049
yeah the tooling is fairly excellent so

824
00:38:37,049 --> 00:38:40,650
like for example with cargo you just

825
00:38:40,650 --> 00:38:42,720
type cargo object dump and it does the

826
00:38:42,720 --> 00:38:44,400
object dump and you don't have to care

827
00:38:44,400 --> 00:38:46,109
if it's this five or arm or whatever you

828
00:38:46,109 --> 00:38:48,180
just you just take cargo object dump and

829
00:38:48,180 --> 00:38:49,700
it figures out doctor

830
00:38:49,700 --> 00:38:53,510
in dumps the the sandy code it's quite

831
00:38:53,510 --> 00:38:55,340
nice so like if you can bear that to GCC

832
00:38:55,340 --> 00:38:57,740
where you have your risk five GCC

833
00:38:57,740 --> 00:38:59,960
toolchain in your arm GCC toolchain you

834
00:38:59,960 --> 00:39:01,430
have to make sure you have the rate one

835
00:39:01,430 --> 00:39:02,630
and you have to pass in the rate

836
00:39:02,630 --> 00:39:04,760
arguments and everything it's a it's

837
00:39:04,760 --> 00:39:09,200
it's very nice so the last question it

838
00:39:09,200 --> 00:39:10,700
sounds like you're not doing memory

839
00:39:10,700 --> 00:39:12,890
training are you planning to do memory

840
00:39:12,890 --> 00:39:14,210
training because all those magic numbers

841
00:39:14,210 --> 00:39:17,420
you're copying probably have to change

842
00:39:17,420 --> 00:39:19,670
based on variations in the board to

843
00:39:19,670 --> 00:39:22,370
reach maximum memory performance yeah

844
00:39:22,370 --> 00:39:24,470
yeah that's probably true so we're using

845
00:39:24,470 --> 00:39:27,560
D the the values of the control

846
00:39:27,560 --> 00:39:32,060
registers specific to the hi-5 board at

847
00:39:32,060 --> 00:39:35,720
this time bit performing actually actual

848
00:39:35,720 --> 00:39:38,750
memory training should be fairly similar

849
00:39:38,750 --> 00:39:44,930
I believe I I'm not too experienced okay

850
00:39:44,930 --> 00:39:46,280
Thank You Ryan please give another round

851
00:39:46,280 --> 00:39:47,450
of applause

852
00:39:47,450 --> 00:39:54,410
[Applause]

853
00:39:54,410 --> 00:39:56,030
[Music]

854
00:39:56,030 --> 00:39:58,090
you

