1
00:00:03,190 --> 00:00:06,259
[Music]

2
00:00:07,550 --> 00:00:11,240
next up is a talk by mike libecki

3
00:00:11,240 --> 00:00:15,480
Michael works at Intel and here you will

4
00:00:15,480 --> 00:00:18,119
be talking about how Intel is putting

5
00:00:18,119 --> 00:00:21,000
their closed source firmware parts of

6
00:00:21,000 --> 00:00:23,100
the closed false rumor and opening them

7
00:00:23,100 --> 00:00:25,590
opening them up step-by-step piece by

8
00:00:25,590 --> 00:00:26,939
piece

9
00:00:26,939 --> 00:00:30,840
in what they call a minimum platform so

10
00:00:30,840 --> 00:00:37,770
give it up for Michael thank you thank

11
00:00:37,770 --> 00:00:40,260
you for attending my presentation my

12
00:00:40,260 --> 00:00:43,530
name is Michael my co-author was Nate on

13
00:00:43,530 --> 00:00:46,260
this I'm here today to talk about the

14
00:00:46,260 --> 00:00:49,260
edk to minimum platform and the changes

15
00:00:49,260 --> 00:00:50,879
that Intel is making to bring more of

16
00:00:50,879 --> 00:00:53,160
our will be called platform code into

17
00:00:53,160 --> 00:00:55,710
open source if you've caught a glimpse

18
00:00:55,710 --> 00:00:57,629
of Intel's open firmware strategy

19
00:00:57,629 --> 00:00:59,460
recently you'll see whether it's from

20
00:00:59,460 --> 00:01:03,120
system 76 or from even last year's OSF C

21
00:01:03,120 --> 00:01:05,549
keynote by Vincent Zimmer this mint

22
00:01:05,549 --> 00:01:07,350
platform topic come up and so I'm going

23
00:01:07,350 --> 00:01:10,229
to explain that in more detail as part

24
00:01:10,229 --> 00:01:11,939
of explaining that I'm also going to

25
00:01:11,939 --> 00:01:13,619
cover some of the background needed so I

26
00:01:13,619 --> 00:01:14,970
understand a lot of people here come

27
00:01:14,970 --> 00:01:17,220
from diverse firmware backgrounds and

28
00:01:17,220 --> 00:01:18,509
you might not be familiar with all the

29
00:01:18,509 --> 00:01:21,299
terminology so I'll do a brief build up

30
00:01:21,299 --> 00:01:23,310
into the min platform by covering the

31
00:01:23,310 --> 00:01:25,409
background and the pieces necessary to

32
00:01:25,409 --> 00:01:28,080
build an open platform with what Intel

33
00:01:28,080 --> 00:01:32,850
is providing so Intel breaks our

34
00:01:32,850 --> 00:01:35,579
firmware into three major pieces this

35
00:01:35,579 --> 00:01:38,070
has implications on the way that we

36
00:01:38,070 --> 00:01:39,869
deliver firmware and the way that we

37
00:01:39,869 --> 00:01:41,700
develop firmware and likely the way that

38
00:01:41,700 --> 00:01:43,950
you interact with our firmware we do

39
00:01:43,950 --> 00:01:45,710
this for very important reasons because

40
00:01:45,710 --> 00:01:48,329
the separating the pieces out this way

41
00:01:48,329 --> 00:01:51,659
allows us to abstract some of the pieces

42
00:01:51,659 --> 00:01:53,850
from another through interfaces we can

43
00:01:53,850 --> 00:01:56,729
better leverage code and we can also

44
00:01:56,729 --> 00:01:59,430
better share code and so the first piece

45
00:01:59,430 --> 00:02:02,189
is what we call the core code this is

46
00:02:02,189 --> 00:02:03,659
the piece that's probably most familiar

47
00:02:03,659 --> 00:02:06,090
to people here because it's our mainly

48
00:02:06,090 --> 00:02:08,160
our main public visible piece of the

49
00:02:08,160 --> 00:02:10,169
codebase it's in the Tiano core project

50
00:02:10,169 --> 00:02:13,500
and the edk tube repository

51
00:02:13,500 --> 00:02:15,930
this is typically open-source code this

52
00:02:15,930 --> 00:02:17,879
is code that implements what we called

53
00:02:17,879 --> 00:02:19,620
general firmware infrastructure things

54
00:02:19,620 --> 00:02:21,780
like timer services dispatcher memory

55
00:02:21,780 --> 00:02:25,500
allocation this is the code that we

56
00:02:25,500 --> 00:02:27,720
directly use an intel products and you

57
00:02:27,720 --> 00:02:30,780
can go find their so all of our edk -

58
00:02:30,780 --> 00:02:34,260
based code uses the edk - core code on

59
00:02:34,260 --> 00:02:37,950
the silicon side as a silicon vendor we

60
00:02:37,950 --> 00:02:40,410
distribute our silicon initialization

61
00:02:40,410 --> 00:02:42,629
code in the form of the Intel firmware

62
00:02:42,629 --> 00:02:46,650
support package or FSP binary this is

63
00:02:46,650 --> 00:02:48,720
typically closed source code it's a way

64
00:02:48,720 --> 00:02:51,329
for us to distribute proprietary code

65
00:02:51,329 --> 00:02:53,670
and make it easier to be able to

66
00:02:53,670 --> 00:02:55,769
integrate that into other boot loaders

67
00:02:55,769 --> 00:02:58,310
so for example core boot and you boot

68
00:02:58,310 --> 00:03:01,860
edk can all call in to this opaque

69
00:03:01,860 --> 00:03:04,410
binary using the interfaces described in

70
00:03:04,410 --> 00:03:07,860
the Intel FSP specification and so as in

71
00:03:07,860 --> 00:03:09,690
as a silicon vendor we provide the

72
00:03:09,690 --> 00:03:11,400
silicon init code in the form of that

73
00:03:11,400 --> 00:03:14,099
binary the platform code are kind of all

74
00:03:14,099 --> 00:03:16,170
the other pieces and so whenever you

75
00:03:16,170 --> 00:03:17,850
think about everything that goes into a

76
00:03:17,850 --> 00:03:20,940
firmware that is not covered by core or

77
00:03:20,940 --> 00:03:22,709
silicon that generally falls into the

78
00:03:22,709 --> 00:03:25,500
platform bucket the platform bucket is

79
00:03:25,500 --> 00:03:28,380
typically closed source Intel built we

80
00:03:28,380 --> 00:03:30,690
build reference platforms for all of our

81
00:03:30,690 --> 00:03:32,970
products and whenever we do that we

82
00:03:32,970 --> 00:03:35,489
build a fully functional firmware the

83
00:03:35,489 --> 00:03:37,049
platform code is part of that and we

84
00:03:37,049 --> 00:03:39,510
share the platform code with a small set

85
00:03:39,510 --> 00:03:41,459
of licensees but this is typically the

86
00:03:41,459 --> 00:03:43,139
most elusive part of the codebase so if

87
00:03:43,139 --> 00:03:45,049
you're trying to build a piece of code

88
00:03:45,049 --> 00:03:48,239
you need something to use your core code

89
00:03:48,239 --> 00:03:50,430
and to call into your silicon binary and

90
00:03:50,430 --> 00:03:52,230
that's what the platform code does and

91
00:03:52,230 --> 00:03:54,720
so might the focus of this presentation

92
00:03:54,720 --> 00:03:56,730
is going to be taking this platform code

93
00:03:56,730 --> 00:03:58,290
that we write it Intel this kind of

94
00:03:58,290 --> 00:04:00,269
missing piece that binds the others and

95
00:04:00,269 --> 00:04:03,919
how we're moving that into open source

96
00:04:04,790 --> 00:04:07,440
so before I get started I just want to

97
00:04:07,440 --> 00:04:11,400
show how we develop code today and and

98
00:04:11,400 --> 00:04:14,130
why we're able to share the code that we

99
00:04:14,130 --> 00:04:16,228
can share on the core and silicon sides

100
00:04:16,228 --> 00:04:19,019
and why platforms a problem and so if

101
00:04:19,019 --> 00:04:21,000
you look at the the core code our

102
00:04:21,000 --> 00:04:22,560
specifications are maintained by the

103
00:04:22,560 --> 00:04:24,810
UEFI forum we have two main

104
00:04:24,810 --> 00:04:26,550
specifications the Yui

105
00:04:26,550 --> 00:04:29,250
by spec and the ACPI specification the

106
00:04:29,250 --> 00:04:31,319
UEFI specification describing the

107
00:04:31,319 --> 00:04:33,150
interface between the operating system

108
00:04:33,150 --> 00:04:34,979
and the firmware and the a CPI

109
00:04:34,979 --> 00:04:37,199
specification describing an interpreted

110
00:04:37,199 --> 00:04:38,970
runtime language that can offer some

111
00:04:38,970 --> 00:04:42,659
basic hardware abstraction the platform

112
00:04:42,659 --> 00:04:44,639
initialization spec is generally what

113
00:04:44,639 --> 00:04:47,340
makes our UDK to form where 80 k2 and so

114
00:04:47,340 --> 00:04:49,860
the platform initialization specs define

115
00:04:49,860 --> 00:04:52,289
how to construct from where and so you

116
00:04:52,289 --> 00:04:54,810
can mix and match various boot loaders

117
00:04:54,810 --> 00:04:56,310
with these specifications right some

118
00:04:56,310 --> 00:04:58,440
boot loaders limp limit UEFI some will

119
00:04:58,440 --> 00:05:01,530
do a CPI and then edk to does the

120
00:05:01,530 --> 00:05:04,830
platform initialization spec the on the

121
00:05:04,830 --> 00:05:06,770
silicon side we have the Intel firmware

122
00:05:06,770 --> 00:05:09,240
specification the earth tail firmware

123
00:05:09,240 --> 00:05:09,979
Support Package

124
00:05:09,979 --> 00:05:12,180
specification and this allows us to

125
00:05:12,180 --> 00:05:14,069
distribute our silicon code in a way

126
00:05:14,069 --> 00:05:16,229
that you can call in to the silicon and

127
00:05:16,229 --> 00:05:18,990
api's and be able to reliably initialize

128
00:05:18,990 --> 00:05:22,050
the silicon the parameters or what we

129
00:05:22,050 --> 00:05:25,800
call the u PD's of how to configure what

130
00:05:25,800 --> 00:05:27,840
the FSP does changes and that's part of

131
00:05:27,840 --> 00:05:29,400
the integration guide that we ship but

132
00:05:29,400 --> 00:05:31,889
in general we try to simplify the

133
00:05:31,889 --> 00:05:33,990
interface to do silicon initialization

134
00:05:33,990 --> 00:05:37,139
through this FSP spec and then on the

135
00:05:37,139 --> 00:05:39,509
hardware side we write tons of firmware

136
00:05:39,509 --> 00:05:41,520
that works generation over generation it

137
00:05:41,520 --> 00:05:43,199
works with multiple hardware vendors

138
00:05:43,199 --> 00:05:44,250
because of the hardware specifications

139
00:05:44,250 --> 00:05:47,190
and so whenever we look at all of this

140
00:05:47,190 --> 00:05:49,259
we see quite a bit of consistency across

141
00:05:49,259 --> 00:05:51,870
the way that we develop these pieces of

142
00:05:51,870 --> 00:05:54,779
the firmware but we don't really have

143
00:05:54,779 --> 00:05:57,539
anything on the platform side and so the

144
00:05:57,539 --> 00:05:58,979
platform side is kind of left in the

145
00:05:58,979 --> 00:06:00,960
wild in terms of what people do to bring

146
00:06:00,960 --> 00:06:04,080
all these other pieces together so

147
00:06:04,080 --> 00:06:06,360
getting down more specifically to what

148
00:06:06,360 --> 00:06:08,009
the platform does it defines the

149
00:06:08,009 --> 00:06:10,529
firmware flash map and so you can

150
00:06:10,529 --> 00:06:12,300
imagine that's very platform specific or

151
00:06:12,300 --> 00:06:14,159
board specific depending on what kind of

152
00:06:14,159 --> 00:06:16,909
security boot technology you're using or

153
00:06:16,909 --> 00:06:19,680
how your cache properties you may choose

154
00:06:19,680 --> 00:06:22,379
to adjust your from our flash map it

155
00:06:22,379 --> 00:06:25,500
specifies the hardware drivers need in

156
00:06:25,500 --> 00:06:27,479
the core drivers needed so part of

157
00:06:27,479 --> 00:06:29,009
having all these other drivers available

158
00:06:29,009 --> 00:06:31,770
in silicon and in the core is being able

159
00:06:31,770 --> 00:06:33,479
to integrate them into a firmware that's

160
00:06:33,479 --> 00:06:35,550
actually used on a particular

161
00:06:35,550 --> 00:06:37,469
motherboard the platform code chooses

162
00:06:37,469 --> 00:06:39,750
which drivers to use it calls into the

163
00:06:39,750 --> 00:06:40,289
silicon

164
00:06:40,289 --> 00:06:44,369
API so it will call into the FSP to do

165
00:06:44,369 --> 00:06:47,550
the f SP t Elmen s AP is for temporary

166
00:06:47,550 --> 00:06:49,649
RAM your memory in it and your silicon

167
00:06:49,649 --> 00:06:52,110
initialization and a lot of the board

168
00:06:52,110 --> 00:06:54,240
specific information like your GPIO s

169
00:06:54,240 --> 00:06:56,849
serial presence detect those things are

170
00:06:56,849 --> 00:06:59,039
in the R in this code so if you have

171
00:06:59,039 --> 00:07:01,169
soldered down memory you might have your

172
00:07:01,169 --> 00:07:03,930
CR SPD table hard-coded and your board

173
00:07:03,930 --> 00:07:05,639
code otherwise you might read it over sm

174
00:07:05,639 --> 00:07:08,069
bus write those details all fall into

175
00:07:08,069 --> 00:07:09,930
your motherboard design and into what we

176
00:07:09,930 --> 00:07:14,039
call this platform code so this one I

177
00:07:14,039 --> 00:07:17,009
quickly show how where we're at today in

178
00:07:17,009 --> 00:07:18,839
terms of the lineage of Intel firmware

179
00:07:18,839 --> 00:07:20,999
is kind of a natural extension of the

180
00:07:20,999 --> 00:07:23,039
way that we've moved from legacy BIOS

181
00:07:23,039 --> 00:07:25,800
into UEFI and so if we go back to legacy

182
00:07:25,800 --> 00:07:27,689
BIOS which was 16-bit real mode code

183
00:07:27,689 --> 00:07:30,209
written in assembly we realized that as

184
00:07:30,209 --> 00:07:32,189
computing systems became more complex

185
00:07:32,189 --> 00:07:34,349
that wouldn't scale so we needed to move

186
00:07:34,349 --> 00:07:36,119
to C code we needed to have a more

187
00:07:36,119 --> 00:07:38,430
robust interface and so UEFI enters the

188
00:07:38,430 --> 00:07:42,110
picture and 2004 we start to implement

189
00:07:42,110 --> 00:07:46,949
the efi or the the original edk code in

190
00:07:46,949 --> 00:07:49,169
this code that is compliant to the UEFI

191
00:07:49,169 --> 00:07:53,519
specification at intel we start to move

192
00:07:53,519 --> 00:07:55,830
to a converged core so we start to align

193
00:07:55,830 --> 00:07:58,949
the product lines around that code a few

194
00:07:58,949 --> 00:08:02,219
years later we move all the segments so

195
00:08:02,219 --> 00:08:05,219
from adam to z on onto this UEFI code

196
00:08:05,219 --> 00:08:07,800
base by 2015 and so at this point if you

197
00:08:07,800 --> 00:08:09,569
think about that core pillar we're now

198
00:08:09,569 --> 00:08:13,199
getting everything on the core code then

199
00:08:13,199 --> 00:08:16,169
we realize and it's actually around 2012

200
00:08:16,169 --> 00:08:18,659
this actually happened but that we

201
00:08:18,659 --> 00:08:20,759
started working on the FSP and so people

202
00:08:20,759 --> 00:08:23,069
wanted we weren't providing the platform

203
00:08:23,069 --> 00:08:24,779
code and people wanted to be able to

204
00:08:24,779 --> 00:08:27,629
wrap their silicon in it code and so

205
00:08:27,629 --> 00:08:30,990
projects like coreboot you boot to be

206
00:08:30,990 --> 00:08:32,639
able to do that in a consistent way we

207
00:08:32,639 --> 00:08:35,010
developed the Intel FSP and that comes

208
00:08:35,010 --> 00:08:37,740
in the picture to satisfy that silicon

209
00:08:37,740 --> 00:08:40,019
pillar and so now what we're left with

210
00:08:40,019 --> 00:08:42,630
naturally is the platform piece and so

211
00:08:42,630 --> 00:08:45,180
I'm just showing you now how we go from

212
00:08:45,180 --> 00:08:47,100
legacy BIOS to where we are today and

213
00:08:47,100 --> 00:08:49,199
what we're trying to do to standardize

214
00:08:49,199 --> 00:08:50,880
the way that we deliver firmware so you

215
00:08:50,880 --> 00:08:54,019
can use it in a reliable way

216
00:08:54,520 --> 00:08:57,000
from a UEFI platform initialization

217
00:08:57,000 --> 00:09:00,460
perspective we deliver the if you look

218
00:09:00,460 --> 00:09:02,080
at the hardware on the bottom the UEFI

219
00:09:02,080 --> 00:09:03,790
spec is the interface between the OS and

220
00:09:03,790 --> 00:09:07,630
the hardware we deliver the the silicon

221
00:09:07,630 --> 00:09:09,580
code in terms of the FSP binary and then

222
00:09:09,580 --> 00:09:11,530
you have all these platform drivers we

223
00:09:11,530 --> 00:09:13,630
have what we called the green H which is

224
00:09:13,630 --> 00:09:15,130
kind of this

225
00:09:15,130 --> 00:09:18,130
it's the pei what we call the pei and

226
00:09:18,130 --> 00:09:19,810
dixie foundation it's this set of

227
00:09:19,810 --> 00:09:22,180
reliable interfaces that you can use to

228
00:09:22,180 --> 00:09:24,220
initialize your firmware that are

229
00:09:24,220 --> 00:09:26,530
silicon and our platform code use so

230
00:09:26,530 --> 00:09:29,770
that they can be be swapped out more

231
00:09:29,770 --> 00:09:32,110
easily basically it's a Rob it's a it's

232
00:09:32,110 --> 00:09:35,290
a stable set of interfaces so the UEFI

233
00:09:35,290 --> 00:09:37,900
PI spec defines the pei and the dixie

234
00:09:37,900 --> 00:09:39,580
phases and so if you've worked in a

235
00:09:39,580 --> 00:09:40,990
decay code you've heard of those and

236
00:09:40,990 --> 00:09:43,540
that's what that's what we use in the

237
00:09:43,540 --> 00:09:45,100
minimum platform so if you look at the

238
00:09:45,100 --> 00:09:46,630
minimum platform compared to a lot of

239
00:09:46,630 --> 00:09:49,540
other bootloader solutions it it

240
00:09:49,540 --> 00:09:52,180
complies with the UEFI PI specifications

241
00:09:52,180 --> 00:09:58,270
whereas many today do not so silicon

242
00:09:58,270 --> 00:10:00,040
initialization is a big piece of

243
00:10:00,040 --> 00:10:02,620
bringing up your open platform we do

244
00:10:02,620 --> 00:10:04,720
that like I said with the Intel FSP so

245
00:10:04,720 --> 00:10:07,990
this is just covering the silicon in it

246
00:10:07,990 --> 00:10:09,850
side of bringing up a platform and so

247
00:10:09,850 --> 00:10:12,430
Intel delivers the FSP with two primary

248
00:10:12,430 --> 00:10:15,220
objectives one is to distribute binaries

249
00:10:15,220 --> 00:10:17,590
of our proprietary silicon code to the

250
00:10:17,590 --> 00:10:19,810
public the second one is to enable this

251
00:10:19,810 --> 00:10:23,580
to plug in the arbitrary designs we also

252
00:10:23,580 --> 00:10:27,010
realize that initializing the silicon is

253
00:10:27,010 --> 00:10:31,090
relatively complex undertaking and so a

254
00:10:31,090 --> 00:10:33,070
kind of a secondary goal of this is to

255
00:10:33,070 --> 00:10:35,290
abstract the complexity of silicon many

256
00:10:35,290 --> 00:10:36,880
small vendors and other people that

257
00:10:36,880 --> 00:10:38,560
don't have the resources to necessarily

258
00:10:38,560 --> 00:10:40,420
write all the silicon code generation of

259
00:10:40,420 --> 00:10:42,670
our generation can rely on using the FSP

260
00:10:42,670 --> 00:10:44,740
with its api is to initialize their

261
00:10:44,740 --> 00:10:50,020
platform and what you're most familiar

262
00:10:50,020 --> 00:10:52,150
with today is probably what we call it

263
00:10:52,150 --> 00:10:55,720
as P 2 dot o f SP 2 dot o the main goal

264
00:10:55,720 --> 00:10:59,500
of this was to make a binary interface

265
00:10:59,500 --> 00:11:01,300
that could be plugged into arbitrary

266
00:11:01,300 --> 00:11:03,730
boot loaders and allow you to be able to

267
00:11:03,730 --> 00:11:07,060
call into it using a reliable set of API

268
00:11:07,060 --> 00:11:09,100
you pass the data in with what we call

269
00:11:09,100 --> 00:11:10,900
you PDS or update a little Product data

270
00:11:10,900 --> 00:11:12,670
and you get the results back with

271
00:11:12,670 --> 00:11:16,300
handoff blocks or Hobbs this provided

272
00:11:16,300 --> 00:11:20,470
the 32-bit entry point api's and the FSB

273
00:11:20,470 --> 00:11:22,360
spec talks about how to discover and

274
00:11:22,360 --> 00:11:26,110
call into those api's underneath this is

275
00:11:26,110 --> 00:11:28,600
really just a dk2 firmware and so at

276
00:11:28,600 --> 00:11:31,960
Intel we we write all of this code using

277
00:11:31,960 --> 00:11:33,400
the platform initialization

278
00:11:33,400 --> 00:11:36,690
specifications the UEFI PI specs and

279
00:11:36,690 --> 00:11:39,610
underneath that binary you'll find that

280
00:11:39,610 --> 00:11:41,740
it's just UEFI firmware in fact we boot

281
00:11:41,740 --> 00:11:44,770
this code without using AF SP api's at

282
00:11:44,770 --> 00:11:47,050
all we just run a straight edk to bios

283
00:11:47,050 --> 00:11:50,530
our firmware and then we just launch all

284
00:11:50,530 --> 00:11:53,500
of this code using the UEFI PI dispatch

285
00:11:53,500 --> 00:11:56,110
algorithms because it's all in firmware

286
00:11:56,110 --> 00:11:58,540
volumes it's all in EFI modules it gets

287
00:11:58,540 --> 00:12:01,570
dispatched and runs and so what we

288
00:12:01,570 --> 00:12:07,210
realized was that this is very very kind

289
00:12:07,210 --> 00:12:09,180
of awkward if you're doing an ad k2

290
00:12:09,180 --> 00:12:13,420
wrapper because you're basically going

291
00:12:13,420 --> 00:12:15,190
you're treating this blob like it's not

292
00:12:15,190 --> 00:12:17,140
edk to code even though it is and so

293
00:12:17,140 --> 00:12:18,490
there's a lot of overhead associated

294
00:12:18,490 --> 00:12:21,160
with that this is where we introduced

295
00:12:21,160 --> 00:12:25,060
Intel FSP 2.1 recently and the primary

296
00:12:25,060 --> 00:12:26,200
objective here is to seamlessly

297
00:12:26,200 --> 00:12:30,840
integrate with UEFI firmware this

298
00:12:30,840 --> 00:12:33,880
provides two modes the API mode and the

299
00:12:33,880 --> 00:12:36,640
dispatch mode the API mode operates just

300
00:12:36,640 --> 00:12:39,460
like before but the dispatch mode has an

301
00:12:39,460 --> 00:12:41,770
important advantage and that the FSP is

302
00:12:41,770 --> 00:12:45,790
treated like a native UEFI PI binary so

303
00:12:45,790 --> 00:12:47,470
that means you don't have to convert

304
00:12:47,470 --> 00:12:50,260
from the data structures that are native

305
00:12:50,260 --> 00:12:54,460
to tui dk2 into the u PDS and then

306
00:12:54,460 --> 00:12:57,340
inside convert back and then do this

307
00:12:57,340 --> 00:12:59,050
conversion process you're not converting

308
00:12:59,050 --> 00:13:01,150
data structures back and forth as if

309
00:13:01,150 --> 00:13:05,110
this is not edk to code so this in the

310
00:13:05,110 --> 00:13:07,960
dispatch mode we we share the pei core

311
00:13:07,960 --> 00:13:10,110
and so if you're familiar with edk 2

312
00:13:10,110 --> 00:13:13,180
there's a there's a core called the pei

313
00:13:13,180 --> 00:13:15,850
core and whenever you're using api mode

314
00:13:15,850 --> 00:13:17,800
with an e dk2 wrapper you actually have

315
00:13:17,800 --> 00:13:18,290
to pee

316
00:13:18,290 --> 00:13:20,899
di course and so this leads to a lot of

317
00:13:20,899 --> 00:13:22,910
overhead in terms of maintaining the two

318
00:13:22,910 --> 00:13:24,639
cores and keeping them synchronized in

319
00:13:24,639 --> 00:13:26,480
addition to the data structure

320
00:13:26,480 --> 00:13:28,339
conversion and so with dispatch mode we

321
00:13:28,339 --> 00:13:30,829
get rid of the two IM Pei cores we get

322
00:13:30,829 --> 00:13:33,320
rid of the stacks which we get rid of

323
00:13:33,320 --> 00:13:35,750
the two separate PCD databases the ppi

324
00:13:35,750 --> 00:13:39,110
databases and we start to treat it like

325
00:13:39,110 --> 00:13:41,600
a UEFI PI binary and you get quite a bit

326
00:13:41,600 --> 00:13:46,420
of efficiency improvement for that the

327
00:13:46,420 --> 00:13:49,009
once we did all this though the problem

328
00:13:49,009 --> 00:13:52,009
was is we can demonstrate this FSP

329
00:13:52,009 --> 00:13:54,019
dispatch mode but we don't have an open

330
00:13:54,019 --> 00:13:55,880
source platform wrapper to be able to

331
00:13:55,880 --> 00:13:58,730
exercise it and so at this point we

332
00:13:58,730 --> 00:14:01,459
realized that it would make sense for us

333
00:14:01,459 --> 00:14:03,920
to release the platform code be able to

334
00:14:03,920 --> 00:14:06,110
use this dispatch mode and demonstrate

335
00:14:06,110 --> 00:14:08,870
how how you use the dispatch mode in

336
00:14:08,870 --> 00:14:10,579
addition to the API mode already used by

337
00:14:10,579 --> 00:14:14,089
other boot loaders the main thing

338
00:14:14,089 --> 00:14:15,709
whenever we looked at the platform code

339
00:14:15,709 --> 00:14:17,959
was a lack of consistency and so the

340
00:14:17,959 --> 00:14:20,600
code was written for specific platforms

341
00:14:20,600 --> 00:14:22,399
which means a lot of developers wrote

342
00:14:22,399 --> 00:14:24,769
the code so that you did you just do

343
00:14:24,769 --> 00:14:25,970
what you need to do to get the platform

344
00:14:25,970 --> 00:14:27,829
up and running you can touch five pieces

345
00:14:27,829 --> 00:14:29,690
of hardware in the same file and there's

346
00:14:29,690 --> 00:14:31,940
no real reason why you need to touch

347
00:14:31,940 --> 00:14:33,500
those in the same file other than you

348
00:14:33,500 --> 00:14:35,420
just know that you have a rough order

349
00:14:35,420 --> 00:14:36,860
that you want the execution that

350
00:14:36,860 --> 00:14:38,360
happenin and to initialize the hardware

351
00:14:38,360 --> 00:14:39,769
that way

352
00:14:39,769 --> 00:14:42,019
this made writing code to bring up

353
00:14:42,019 --> 00:14:43,790
platforms relatively quick for

354
00:14:43,790 --> 00:14:45,410
developers but it also doesn't really

355
00:14:45,410 --> 00:14:48,110
lend well to the reuse in the leverage

356
00:14:48,110 --> 00:14:50,060
that we want to have in the open-source

357
00:14:50,060 --> 00:14:51,800
community whenever we start publishing

358
00:14:51,800 --> 00:14:54,980
code out in addition the code is

359
00:14:54,980 --> 00:14:56,660
difficult to understand and debug in

360
00:14:56,660 --> 00:14:58,310
general because you have this deviation

361
00:14:58,310 --> 00:15:00,199
and implementations if you understand

362
00:15:00,199 --> 00:15:01,910
the way that one implementation is done

363
00:15:01,910 --> 00:15:03,769
it doesn't necessarily translate super

364
00:15:03,769 --> 00:15:06,319
well to the others and doing the same

365
00:15:06,319 --> 00:15:07,699
thing different ways always makes things

366
00:15:07,699 --> 00:15:09,319
difficult to secure so if we're writing

367
00:15:09,319 --> 00:15:12,199
the same feature and five different

368
00:15:12,199 --> 00:15:14,600
platforms and you're not cheering code

369
00:15:14,600 --> 00:15:16,790
between those and your it makes it

370
00:15:16,790 --> 00:15:18,290
difficult to secure and update that code

371
00:15:18,290 --> 00:15:20,689
and so this is one of the areas of

372
00:15:20,689 --> 00:15:22,189
improvement that we're bringing in

373
00:15:22,189 --> 00:15:23,269
addition to moving the code to

374
00:15:23,269 --> 00:15:25,100
open-source is to move to this minimum

375
00:15:25,100 --> 00:15:27,500
platform the single converged platform

376
00:15:27,500 --> 00:15:29,810
code and then move that into the open

377
00:15:29,810 --> 00:15:31,190
and have our

378
00:15:31,190 --> 00:15:32,840
platforms be able to leverage from that

379
00:15:32,840 --> 00:15:36,050
open source platform core and that will

380
00:15:36,050 --> 00:15:37,700
happen across our server client and

381
00:15:37,700 --> 00:15:39,800
ultra mobile line so across from Adam up

382
00:15:39,800 --> 00:15:41,900
until Z on while we be use them in

383
00:15:41,900 --> 00:15:45,590
platform so if you look at what it takes

384
00:15:45,590 --> 00:15:47,210
to go from where we are today to where

385
00:15:47,210 --> 00:15:48,880
we want to go it's quite an undertaking

386
00:15:48,880 --> 00:15:51,800
and github we have the IDI k2 repository

387
00:15:51,800 --> 00:15:54,230
and the 80k 2 platforms repository and

388
00:15:54,230 --> 00:15:58,130
this is showing the closed source code

389
00:15:58,130 --> 00:15:59,780
at the bottom this is a stuff internal

390
00:15:59,780 --> 00:16:02,330
to Intel and then what we have today an

391
00:16:02,330 --> 00:16:04,460
open source so today we have the IDI k2

392
00:16:04,460 --> 00:16:06,800
repository and it has a lot of packages

393
00:16:06,800 --> 00:16:09,650
there you'll find a lot of mde of the

394
00:16:09,650 --> 00:16:11,720
module package and UEFI CPU are some of

395
00:16:11,720 --> 00:16:14,030
the more common ones but there's a lot

396
00:16:14,030 --> 00:16:16,700
there and ebk two platforms we haven't

397
00:16:16,700 --> 00:16:18,500
really used super well but what we plan

398
00:16:18,500 --> 00:16:20,930
to do and what we are doing at the

399
00:16:20,930 --> 00:16:23,270
moment is moving all of our platform

400
00:16:23,270 --> 00:16:25,220
support code to ATK tube platforms and

401
00:16:25,220 --> 00:16:27,770
so we today we have the mint platform

402
00:16:27,770 --> 00:16:29,690
package up there and so whenever we

403
00:16:29,690 --> 00:16:31,220
started going through all this work we

404
00:16:31,220 --> 00:16:32,870
realized we needed to write a

405
00:16:32,870 --> 00:16:37,100
specification to basically describe how

406
00:16:37,100 --> 00:16:40,130
to write consistent platform interfaces

407
00:16:40,130 --> 00:16:41,810
so if we're building an atom product a

408
00:16:41,810 --> 00:16:44,570
core product or Xeon product there's a

409
00:16:44,570 --> 00:16:46,250
row there's a there's basically a

410
00:16:46,250 --> 00:16:48,350
blueprint as to how you put together the

411
00:16:48,350 --> 00:16:49,790
firmware in a way that all the pieces

412
00:16:49,790 --> 00:16:52,730
plug together the same and that that

413
00:16:52,730 --> 00:16:55,280
specification became the ATK to minimum

414
00:16:55,280 --> 00:16:57,200
platform specification so we contributed

415
00:16:57,200 --> 00:16:59,810
that to the Tiano core project and the

416
00:16:59,810 --> 00:17:01,700
min platform package kind of has these

417
00:17:01,700 --> 00:17:03,890
generic flows about how to do the

418
00:17:03,890 --> 00:17:06,500
platform code so for example if you need

419
00:17:06,500 --> 00:17:08,329
to do board detection or you need to do

420
00:17:08,329 --> 00:17:10,430
GPIO initialization the min platform

421
00:17:10,430 --> 00:17:12,530
package defines a linear flow throughout

422
00:17:12,530 --> 00:17:14,689
the boot of when that's done and so if

423
00:17:14,689 --> 00:17:17,209
you work on an atom system or a server

424
00:17:17,209 --> 00:17:19,250
system you can take your knowledge about

425
00:17:19,250 --> 00:17:21,500
how the boot flow works and it's fairly

426
00:17:21,500 --> 00:17:23,959
consistent across the product lines so

427
00:17:23,959 --> 00:17:25,939
that min platform package is kind of the

428
00:17:25,939 --> 00:17:28,250
core piece it's open for extension not

429
00:17:28,250 --> 00:17:30,050
modification we do not change it in

430
00:17:30,050 --> 00:17:31,820
order to boot any type of system we use

431
00:17:31,820 --> 00:17:35,120
it as is along with that we have the

432
00:17:35,120 --> 00:17:37,880
advanced feature package and the open

433
00:17:37,880 --> 00:17:40,370
board packages and so the idea here is

434
00:17:40,370 --> 00:17:42,350
that the min platform package contains

435
00:17:42,350 --> 00:17:43,960
this generic control flow

436
00:17:43,960 --> 00:17:45,879
that kind of goes through the boot and

437
00:17:45,879 --> 00:17:47,919
it says what needs to be done when and

438
00:17:47,919 --> 00:17:49,960
it's doing the minimum amount of

439
00:17:49,960 --> 00:17:52,090
call-outs that it needs to do to get the

440
00:17:52,090 --> 00:17:54,940
system to an operating system a UEFI can

441
00:17:54,940 --> 00:17:57,399
fly an operating system on top of that

442
00:17:57,399 --> 00:17:59,440
we put all the other functionality into

443
00:17:59,440 --> 00:18:01,450
what we call it vance features and so

444
00:18:01,450 --> 00:18:02,830
that moves into advanced feature

445
00:18:02,830 --> 00:18:05,259
packages and so i'm here it says

446
00:18:05,259 --> 00:18:06,940
advanced feature package and we do have

447
00:18:06,940 --> 00:18:08,499
that but what we're starting to move

448
00:18:08,499 --> 00:18:11,610
we're trending more toward is having

449
00:18:11,610 --> 00:18:13,779
separate packages we have one called

450
00:18:13,779 --> 00:18:15,429
debug feature package one called power

451
00:18:15,429 --> 00:18:17,379
management feature package and we're

452
00:18:17,379 --> 00:18:18,990
kind of taking these high-level

453
00:18:18,990 --> 00:18:21,159
classifications of code and moving them

454
00:18:21,159 --> 00:18:23,889
into these packages the main idea here

455
00:18:23,889 --> 00:18:26,619
is to keep some cohesiveness inside the

456
00:18:26,619 --> 00:18:28,419
package but also not get it too bloated

457
00:18:28,419 --> 00:18:30,070
a lot of times people look at their

458
00:18:30,070 --> 00:18:31,899
files and they see oh this package is

459
00:18:31,899 --> 00:18:33,279
doing power management it's doing

460
00:18:33,279 --> 00:18:35,049
security it's doing all this stuff it's

461
00:18:35,049 --> 00:18:37,119
I don't you know need all of that so or

462
00:18:37,119 --> 00:18:38,649
we're breaking it out into separate

463
00:18:38,649 --> 00:18:39,509
packages

464
00:18:39,509 --> 00:18:42,610
the other interesting thing is we're

465
00:18:42,610 --> 00:18:44,919
supplying the what we call the board

466
00:18:44,919 --> 00:18:47,409
code for every Intel reference board so

467
00:18:47,409 --> 00:18:50,019
whenever we release a product will

468
00:18:50,019 --> 00:18:52,659
supply the open board package for a

469
00:18:52,659 --> 00:18:54,610
reference Intel platform for that

470
00:18:54,610 --> 00:18:57,070
product the idea here is that you can

471
00:18:57,070 --> 00:18:59,590
take this package and you can use it to

472
00:18:59,590 --> 00:19:02,379
bring up your own board so you look at

473
00:19:02,379 --> 00:19:04,779
our SPD settings you look at our GPIO

474
00:19:04,779 --> 00:19:07,119
values and you have obvious places that

475
00:19:07,119 --> 00:19:08,889
you can swap out your board information

476
00:19:08,889 --> 00:19:10,840
to be able to take that package and

477
00:19:10,840 --> 00:19:13,179
bring it up on your board today we we

478
00:19:13,179 --> 00:19:14,860
have the KB Lake and the whiskey lake

479
00:19:14,860 --> 00:19:18,460
open board packages we plan to add comet

480
00:19:18,460 --> 00:19:21,309
Lake soon and and in addition ice lake

481
00:19:21,309 --> 00:19:23,529
and once we're still in kind of in the

482
00:19:23,529 --> 00:19:25,749
ketchup phase of all of this once we get

483
00:19:25,749 --> 00:19:27,730
caught up with releasing these then you

484
00:19:27,730 --> 00:19:29,649
should expect it a product launch

485
00:19:29,649 --> 00:19:31,269
so whenever the product launches you'll

486
00:19:31,269 --> 00:19:33,820
get an F is P binary you'll get an open

487
00:19:33,820 --> 00:19:35,409
board package for an Intel reference

488
00:19:35,409 --> 00:19:38,289
platform that uses that FSP binary and

489
00:19:38,289 --> 00:19:41,409
you can start using them in platform

490
00:19:41,409 --> 00:19:45,009
spec to understand the open board

491
00:19:45,009 --> 00:19:46,659
package and how its interacting with the

492
00:19:46,659 --> 00:19:48,369
min platform package and how you can

493
00:19:48,369 --> 00:19:50,409
make your board be supported on top of

494
00:19:50,409 --> 00:19:55,210
that the other thing we're going to do

495
00:19:55,210 --> 00:19:57,760
is move the features one by one into the

496
00:19:57,760 --> 00:19:59,860
open-source so it Intel a typical

497
00:19:59,860 --> 00:20:01,240
platform can have over three million

498
00:20:01,240 --> 00:20:04,900
lines of code they're very big so moving

499
00:20:04,900 --> 00:20:06,940
everything into open-source is not the

500
00:20:06,940 --> 00:20:08,980
greatest strategy for sustainability so

501
00:20:08,980 --> 00:20:11,410
we're going to move each feature one as

502
00:20:11,410 --> 00:20:13,660
we now that we've kind of carved out

503
00:20:13,660 --> 00:20:15,010
these advanced features we're going to

504
00:20:15,010 --> 00:20:16,840
move them one at a time into the open

505
00:20:16,840 --> 00:20:19,630
and so today we have like I said some

506
00:20:19,630 --> 00:20:21,310
debug features there we have some

507
00:20:21,310 --> 00:20:22,810
Thunderbolt code but we're going to move

508
00:20:22,810 --> 00:20:25,020
them one at a time into the open and

509
00:20:25,020 --> 00:20:27,550
directly use them back into the close

510
00:20:27,550 --> 00:20:29,560
source and so at this point our close

511
00:20:29,560 --> 00:20:31,840
our next generation board package which

512
00:20:31,840 --> 00:20:34,000
we work on at Intel up to product launch

513
00:20:34,000 --> 00:20:36,040
will be directly using them in platform

514
00:20:36,040 --> 00:20:37,150
package from open source

515
00:20:37,150 --> 00:20:39,280
it'll be directly using the advanced

516
00:20:39,280 --> 00:20:41,170
features from open source and so

517
00:20:41,170 --> 00:20:43,570
whenever you see those packages and open

518
00:20:43,570 --> 00:20:45,160
source although you don't have the

519
00:20:45,160 --> 00:20:47,020
next-generation code yet the

520
00:20:47,020 --> 00:20:49,000
next-generation code we'll be using will

521
00:20:49,000 --> 00:20:50,470
be using those advanced features and

522
00:20:50,470 --> 00:20:51,760
we'll be using that mint platform

523
00:20:51,760 --> 00:20:55,150
package and then once we hit product

524
00:20:55,150 --> 00:20:56,800
launch we move that next gen board

525
00:20:56,800 --> 00:20:59,290
package into the UDK 2 platforms repo

526
00:20:59,290 --> 00:21:02,200
and we continue so if you look at the

527
00:21:02,200 --> 00:21:04,480
open platform firmware stack the way

528
00:21:04,480 --> 00:21:06,760
that we see it is edk 2 is our core code

529
00:21:06,760 --> 00:21:08,590
across all of the different computing

530
00:21:08,590 --> 00:21:11,140
segments the main platform package is

531
00:21:11,140 --> 00:21:12,010
there as well

532
00:21:12,010 --> 00:21:13,720
and so whether you're building a server

533
00:21:13,720 --> 00:21:16,120
system client once again or a mobile

534
00:21:16,120 --> 00:21:18,010
system those are the consistent pieces

535
00:21:18,010 --> 00:21:22,440
that you use as is the Intel FSP is our

536
00:21:22,440 --> 00:21:25,120
way to initialize the Intel silicon and

537
00:21:25,120 --> 00:21:27,790
so once again regardless of which

538
00:21:27,790 --> 00:21:29,740
segment you're working in the these

539
00:21:29,740 --> 00:21:31,390
interfaces and the view should look very

540
00:21:31,390 --> 00:21:33,190
similar to you as you work across the

541
00:21:33,190 --> 00:21:35,380
various products and then you have these

542
00:21:35,380 --> 00:21:37,240
board packages and the board packages

543
00:21:37,240 --> 00:21:38,800
are probably the only piece that you

544
00:21:38,800 --> 00:21:42,100
really need to touch so you take our our

545
00:21:42,100 --> 00:21:44,680
open board package our sample board

546
00:21:44,680 --> 00:21:46,150
package that we're providing you and you

547
00:21:46,150 --> 00:21:47,440
just swap out what you need for your

548
00:21:47,440 --> 00:21:49,150
board and you should be able to get up

549
00:21:49,150 --> 00:21:53,980
and running now whenever we start

550
00:21:53,980 --> 00:21:56,680
talking about minimum a lot of people

551
00:21:56,680 --> 00:21:58,540
have different ways to define minimum it

552
00:21:58,540 --> 00:22:00,160
seems somewhat subjective on what

553
00:22:00,160 --> 00:22:02,590
minimum is and so in order to talk about

554
00:22:02,590 --> 00:22:05,290
the minimum platform and what we mean

555
00:22:05,290 --> 00:22:07,090
whenever I say the basic support needed

556
00:22:07,090 --> 00:22:09,010
to get to a UEFI compliant operating

557
00:22:09,010 --> 00:22:11,260
system we defined what we call the stage

558
00:22:11,260 --> 00:22:11,720
plat

559
00:22:11,720 --> 00:22:14,690
approach and so the idea here is to be

560
00:22:14,690 --> 00:22:17,630
able to classify what is needed in order

561
00:22:17,630 --> 00:22:19,400
to meet specific milestones throughout

562
00:22:19,400 --> 00:22:21,890
the boot and so if you're going through

563
00:22:21,890 --> 00:22:25,010
a stage 1 we call minimum debug and this

564
00:22:25,010 --> 00:22:26,990
is the code that you need to basically

565
00:22:26,990 --> 00:22:28,610
just get debug up and running on the

566
00:22:28,610 --> 00:22:30,350
system and so whenever we asked is

567
00:22:30,350 --> 00:22:32,539
something going the stage 1 if it's not

568
00:22:32,539 --> 00:22:34,120
needed to get debug up the answer's no

569
00:22:34,120 --> 00:22:36,260
then we go to stage two memory

570
00:22:36,260 --> 00:22:39,200
functional same thing and so as we start

571
00:22:39,200 --> 00:22:41,210
to talk about what to put into the main

572
00:22:41,210 --> 00:22:43,580
platform package the answer is fairly

573
00:22:43,580 --> 00:22:46,159
simple if it's not needed in order to

574
00:22:46,159 --> 00:22:48,590
get through any of these basic stages

575
00:22:48,590 --> 00:22:50,539
the minimum platform stage 1 through 5

576
00:22:50,539 --> 00:22:52,760
it's not going into the main platform

577
00:22:52,760 --> 00:22:57,409
package and it also won't be executed

578
00:22:57,409 --> 00:22:59,600
outside of that stage so for example if

579
00:22:59,600 --> 00:23:01,250
you're doing a stage 3 boot which is

580
00:23:01,250 --> 00:23:03,440
boot to UEFI shell you don't need to do

581
00:23:03,440 --> 00:23:05,659
a CPI table initialization for that and

582
00:23:05,659 --> 00:23:07,850
so this is the way that the idea behind

583
00:23:07,850 --> 00:23:09,830
this is to keep our execution paths

584
00:23:09,830 --> 00:23:12,919
clean and so the minimum platform

585
00:23:12,919 --> 00:23:14,690
specification is where we describe the

586
00:23:14,690 --> 00:23:17,179
stage boots and why we do them and the

587
00:23:17,179 --> 00:23:19,370
but the main thing to take away here is

588
00:23:19,370 --> 00:23:22,400
that if you want to just do a stage to

589
00:23:22,400 --> 00:23:24,230
boot and have minimal stuff in your way

590
00:23:24,230 --> 00:23:25,940
to get to memory in it and then jump

591
00:23:25,940 --> 00:23:28,520
into some other environment normally we

592
00:23:28,520 --> 00:23:30,169
would jump into what we call dixie IPL

593
00:23:30,169 --> 00:23:32,929
the the next stage of our boot you could

594
00:23:32,929 --> 00:23:35,390
jump somewhere else if you want to just

595
00:23:35,390 --> 00:23:37,159
boot to OS and not have any of the other

596
00:23:37,159 --> 00:23:39,380
stuff in your way you just do a stage 4

597
00:23:39,380 --> 00:23:40,669
boot it takes all the advanced features

598
00:23:40,669 --> 00:23:42,950
out and so we're build we're trying to

599
00:23:42,950 --> 00:23:45,260
provide a clean foundation that you can

600
00:23:45,260 --> 00:23:47,419
modularly build on top of to be able to

601
00:23:47,419 --> 00:23:50,870
construct firmware and one of the things

602
00:23:50,870 --> 00:23:53,210
that we see and in addition to the kind

603
00:23:53,210 --> 00:23:55,460
of classic reasons for moving code in

604
00:23:55,460 --> 00:23:58,490
the open source with the emergence of

605
00:23:58,490 --> 00:24:01,850
clouds we think that with the vertically

606
00:24:01,850 --> 00:24:03,559
integrated solutions that you see and

607
00:24:03,559 --> 00:24:05,090
the smaller development teams that are

608
00:24:05,090 --> 00:24:06,909
building firmware for the semi-custom

609
00:24:06,909 --> 00:24:09,049
designs that have off-the-shelf

610
00:24:09,049 --> 00:24:11,120
processors paired with accelerators and

611
00:24:11,120 --> 00:24:13,520
we think that though for those

612
00:24:13,520 --> 00:24:14,840
vertically integrated solutions these

613
00:24:14,840 --> 00:24:16,400
open-source building blocks that we're

614
00:24:16,400 --> 00:24:17,690
providing and the source of advanced

615
00:24:17,690 --> 00:24:19,700
features can help and so what we're

616
00:24:19,700 --> 00:24:21,140
trying to do is make this code available

617
00:24:21,140 --> 00:24:23,539
that's close source today and then you

618
00:24:23,539 --> 00:24:25,140
can use it to fill

619
00:24:25,140 --> 00:24:28,430
on your Intel platform however you like

620
00:24:28,430 --> 00:24:30,720
so this is going back to that original

621
00:24:30,720 --> 00:24:32,370
picture and just showing that the

622
00:24:32,370 --> 00:24:34,530
silicon code becomes Intel FSP in this

623
00:24:34,530 --> 00:24:37,440
your platform piece becomes min platform

624
00:24:37,440 --> 00:24:39,450
on top of that you have your board code

625
00:24:39,450 --> 00:24:41,400
and any other drivers that you may need

626
00:24:41,400 --> 00:24:43,650
such as the Intel Gough driver for

627
00:24:43,650 --> 00:24:46,250
graphics initialization things like that

628
00:24:46,250 --> 00:24:50,280
the basic point of this is that the UEFI

629
00:24:50,280 --> 00:24:51,930
was built with this a PC supply chain of

630
00:24:51,930 --> 00:24:54,570
mind and so there is a great deal of

631
00:24:54,570 --> 00:24:56,790
flexibility in terms of the PCI Specht

632
00:24:56,790 --> 00:24:58,140
and how you mix and match components

633
00:24:58,140 --> 00:24:59,580
from various vendors so binary

634
00:24:59,580 --> 00:25:02,010
compatibility is an important piece of

635
00:25:02,010 --> 00:25:04,820
the specification and so we're

636
00:25:04,820 --> 00:25:07,290
continuing to support that model because

637
00:25:07,290 --> 00:25:09,210
realistically that is the way that the

638
00:25:09,210 --> 00:25:11,250
people the large-scale OE on PC

639
00:25:11,250 --> 00:25:14,040
ecosystem is is operating but at the

640
00:25:14,040 --> 00:25:16,110
same time we're opening up as much code

641
00:25:16,110 --> 00:25:17,970
as we can to be able to be plugged into

642
00:25:17,970 --> 00:25:19,650
these smaller designs and people to be

643
00:25:19,650 --> 00:25:21,510
able to experiment to innovate on the

644
00:25:21,510 --> 00:25:26,070
Intel hardware so what can you do this

645
00:25:26,070 --> 00:25:29,010
is some of the things that we look at as

646
00:25:29,010 --> 00:25:31,380
people getting involved is you can

647
00:25:31,380 --> 00:25:33,360
create modify Intel system firmware so

648
00:25:33,360 --> 00:25:35,730
we encourage you to go take the open

649
00:25:35,730 --> 00:25:37,800
board package for one of our reference

650
00:25:37,800 --> 00:25:40,610
platforms and and port it for your board

651
00:25:40,610 --> 00:25:43,650
we encourage you to share platform

652
00:25:43,650 --> 00:25:46,050
features and use our features so if you

653
00:25:46,050 --> 00:25:48,300
could enhance our features or if you

654
00:25:48,300 --> 00:25:50,730
want to contribute features or get

655
00:25:50,730 --> 00:25:52,380
involved there that's also a way to do

656
00:25:52,380 --> 00:25:55,500
it embedded system development is

657
00:25:55,500 --> 00:25:57,630
another place that we see so the simpler

658
00:25:57,630 --> 00:25:59,400
execution path we hear a lot of people

659
00:25:59,400 --> 00:26:01,200
say whether they're doing emulation or

660
00:26:01,200 --> 00:26:03,870
simulation or a simple embedded device

661
00:26:03,870 --> 00:26:05,670
that they just want a simple way to get

662
00:26:05,670 --> 00:26:07,830
memory initialized and then jump into

663
00:26:07,830 --> 00:26:10,710
their embedded operating system or do

664
00:26:10,710 --> 00:26:13,860
some IP checkout so inside with like

665
00:26:13,860 --> 00:26:15,480
some efi app or something so there's a

666
00:26:15,480 --> 00:26:17,970
lot of environments we think that the

667
00:26:17,970 --> 00:26:19,500
simpler execution flows with the

668
00:26:19,500 --> 00:26:20,880
advanced features moved out of the way

669
00:26:20,880 --> 00:26:24,390
can help and if you want to create a new

670
00:26:24,390 --> 00:26:26,250
board package this is kind of the

671
00:26:26,250 --> 00:26:27,600
overview so I'm just going to show here

672
00:26:27,600 --> 00:26:29,700
it's not super complicated you start

673
00:26:29,700 --> 00:26:32,040
with our sample open board you update

674
00:26:32,040 --> 00:26:35,190
the board specific information you can

675
00:26:35,190 --> 00:26:36,960
get a simple you boot through the stages

676
00:26:36,960 --> 00:26:38,790
so we encourage you to go to a stage one

677
00:26:38,790 --> 00:26:40,500
get your debug working do a stage to

678
00:26:40,500 --> 00:26:42,480
boot get to memory in it and bring it up

679
00:26:42,480 --> 00:26:44,160
one stage at a time and then in addition

680
00:26:44,160 --> 00:26:46,980
to that you need to configure the FSP

681
00:26:46,980 --> 00:26:49,860
for your specific board and so you can

682
00:26:49,860 --> 00:26:51,570
use your FSP integration guide to do

683
00:26:51,570 --> 00:26:54,600
that this is the current status of where

684
00:26:54,600 --> 00:26:56,340
we're at in upcoming plans so we

685
00:26:56,340 --> 00:26:59,850
currently support the KB Lake platform

686
00:26:59,850 --> 00:27:02,730
we have the KB like you ddr3 our VP in

687
00:27:02,730 --> 00:27:05,310
addition as system76 said we have

688
00:27:05,310 --> 00:27:07,500
partnered with them on bring bringing

689
00:27:07,500 --> 00:27:08,940
this to a commercial system we

690
00:27:08,940 --> 00:27:10,980
understand that not everyone has access

691
00:27:10,980 --> 00:27:12,690
to Intel reference platform so we're

692
00:27:12,690 --> 00:27:15,090
bringing it to the the Galago commercial

693
00:27:15,090 --> 00:27:18,000
system that one we actually have booting

694
00:27:18,000 --> 00:27:19,890
to the the operating system now so

695
00:27:19,890 --> 00:27:22,290
that's been an ongoing effort to try to

696
00:27:22,290 --> 00:27:24,600
do that as part of this commercial work

697
00:27:24,600 --> 00:27:26,820
I would also note at Intel we typically

698
00:27:26,820 --> 00:27:28,770
have quite a bit of debug capability on

699
00:27:28,770 --> 00:27:31,110
our platforms one of the things that we

700
00:27:31,110 --> 00:27:32,760
found whenever we went to the commercial

701
00:27:32,760 --> 00:27:34,530
one and we started actually trying to do

702
00:27:34,530 --> 00:27:37,080
this ourselves take our open board and

703
00:27:37,080 --> 00:27:38,820
move it to a commercial system there

704
00:27:38,820 --> 00:27:40,710
were quite a few challenges that we're

705
00:27:40,710 --> 00:27:42,390
trying to address and make easier for

706
00:27:42,390 --> 00:27:44,640
people one of those is a close chassis

707
00:27:44,640 --> 00:27:48,330
debug and so an example here is we're

708
00:27:48,330 --> 00:27:51,060
putting out a new driver that can

709
00:27:51,060 --> 00:27:53,070
actually do BIOS debug messages over the

710
00:27:53,070 --> 00:27:56,670
HDMI port and so you can use the i2c

711
00:27:56,670 --> 00:27:58,200
lines that are normally used for II did

712
00:27:58,200 --> 00:28:00,540
and we can send BIOS debug messages over

713
00:28:00,540 --> 00:28:02,640
those to a bus pirate that's operating

714
00:28:02,640 --> 00:28:06,630
in slave mode and so we've also done

715
00:28:06,630 --> 00:28:08,310
things like move a lot of the build

716
00:28:08,310 --> 00:28:11,100
tools that we use to Linux and test them

717
00:28:11,100 --> 00:28:13,290
as well on various Linux distributions

718
00:28:13,290 --> 00:28:15,150
and so we're trying to make this all

719
00:28:15,150 --> 00:28:18,270
more friendly and easier to use across

720
00:28:18,270 --> 00:28:21,030
the environments but that documentation

721
00:28:21,030 --> 00:28:22,500
it's not in the upcoming plans that's

722
00:28:22,500 --> 00:28:23,970
something that we do plan to expand on

723
00:28:23,970 --> 00:28:25,350
as well so we understand that core boot

724
00:28:25,350 --> 00:28:28,110
has good documentation Intel slim boot

725
00:28:28,110 --> 00:28:29,790
loader has good documentation and so

726
00:28:29,790 --> 00:28:31,290
with the min platform we're also gonna

727
00:28:31,290 --> 00:28:32,730
put some of those how-to guides and

728
00:28:32,730 --> 00:28:34,680
practical information about how do you

729
00:28:34,680 --> 00:28:36,660
get the debug over the HDMI port how do

730
00:28:36,660 --> 00:28:38,790
you flash your firmware that type of

731
00:28:38,790 --> 00:28:40,760
information we're going to be publishing

732
00:28:40,760 --> 00:28:44,640
and this is the are three main kind of

733
00:28:44,640 --> 00:28:46,290
imperatives at the time at this moment

734
00:28:46,290 --> 00:28:48,210
is we want to continue to roll out more

735
00:28:48,210 --> 00:28:50,250
Intel open source platform code so as

736
00:28:50,250 --> 00:28:52,800
Intel we realized that we need to

737
00:28:52,800 --> 00:28:54,450
kind of unlocked this code so we're

738
00:28:54,450 --> 00:28:57,450
primarily focusing on getting the open

739
00:28:57,450 --> 00:28:58,860
board packages out

740
00:28:58,860 --> 00:29:00,680
that's our it's one of our primary

741
00:29:00,680 --> 00:29:02,940
priorities and then the other one is

742
00:29:02,940 --> 00:29:04,770
expand the advanced feature code and

743
00:29:04,770 --> 00:29:07,560
quality and so as we get these advanced

744
00:29:07,560 --> 00:29:09,570
features out we want to keep move

745
00:29:09,570 --> 00:29:12,150
modularizing the chunks of our internal

746
00:29:12,150 --> 00:29:14,340
platforms and moving them out to

747
00:29:14,340 --> 00:29:16,080
advanced features and then pulling them

748
00:29:16,080 --> 00:29:18,870
back in to our our platforms using them

749
00:29:18,870 --> 00:29:21,780
in platform model and finally we want to

750
00:29:21,780 --> 00:29:23,700
support open source community continuous

751
00:29:23,700 --> 00:29:25,920
integration and so this is one of the

752
00:29:25,920 --> 00:29:27,690
places where at Intel everything that

753
00:29:27,690 --> 00:29:29,910
happens on the edk - and the 80k two

754
00:29:29,910 --> 00:29:31,800
platforms mailing list we're actually we

755
00:29:31,800 --> 00:29:33,720
have CI running inside the company we're

756
00:29:33,720 --> 00:29:37,260
doing GCC five Visual Studio 2015 builds

757
00:29:37,260 --> 00:29:40,230
we're doing xcode and clang builds but

758
00:29:40,230 --> 00:29:42,690
none of that's publicly visible and so

759
00:29:42,690 --> 00:29:44,550
one of the other things that we want to

760
00:29:44,550 --> 00:29:47,070
do in the next you know a few weeks here

761
00:29:47,070 --> 00:29:48,960
is move that into the open so it's it's

762
00:29:48,960 --> 00:29:52,860
publicly available and with that that's

763
00:29:52,860 --> 00:29:56,550
the end of my presentation so I am happy

764
00:29:56,550 --> 00:29:58,080
to take questions now for anyone thank

765
00:29:58,080 --> 00:30:01,220
you Michael the round of applause please

766
00:30:04,070 --> 00:30:08,130
we have time for about ten questions so

767
00:30:08,130 --> 00:30:09,600
please zip up through the microphones if

768
00:30:09,600 --> 00:30:12,020
you have any

769
00:30:17,470 --> 00:30:20,230
I'm curious do you know how it impacts

770
00:30:20,230 --> 00:30:22,570
the schedule for say ODMs to deliver in

771
00:30:22,570 --> 00:30:25,720
a new board you know what's the the old

772
00:30:25,720 --> 00:30:28,180
time for building a firmer image for a

773
00:30:28,180 --> 00:30:32,320
new system versus using the platform so

774
00:30:32,320 --> 00:30:33,880
we hope we haven't directly worked with

775
00:30:33,880 --> 00:30:38,350
any o diems yet what we hope will be the

776
00:30:38,350 --> 00:30:39,970
case is that we'll start to develop

777
00:30:39,970 --> 00:30:43,180
these stable pieces of functionality in

778
00:30:43,180 --> 00:30:45,160
the open source that the community will

779
00:30:45,160 --> 00:30:48,130
continue to use and we can improve both

780
00:30:48,130 --> 00:30:49,090
from a security and functionality

781
00:30:49,090 --> 00:30:51,460
perspective and that'll make integration

782
00:30:51,460 --> 00:30:54,640
into the designs much easier and so what

783
00:30:54,640 --> 00:30:57,010
we're doing is we're basically just

784
00:30:57,010 --> 00:30:59,350
moving this out to the open and we're

785
00:30:59,350 --> 00:31:01,360
going to support it and just see how

786
00:31:01,360 --> 00:31:03,670
people can find it to improve products

787
00:31:03,670 --> 00:31:05,500
and that that's what we're doing from

788
00:31:05,500 --> 00:31:12,250
Intel site I used to be the u-boot x86

789
00:31:12,250 --> 00:31:15,010
maintainer and really impressed with

790
00:31:15,010 --> 00:31:16,420
what you're doing here I just wanted to

791
00:31:16,420 --> 00:31:19,900
know though is there any interest in

792
00:31:19,900 --> 00:31:23,020
open sourcing the FSB itself and though

793
00:31:23,020 --> 00:31:26,140
that platform in it that Intel has yeah

794
00:31:26,140 --> 00:31:29,470
so the the FSP is if you look at these

795
00:31:29,470 --> 00:31:31,780
open board packages one of the things

796
00:31:31,780 --> 00:31:33,850
that we pair with it is what we call a

797
00:31:33,850 --> 00:31:35,650
silicon package and so if you go to the

798
00:31:35,650 --> 00:31:37,840
e DK 2 platforms repository you'll find

799
00:31:37,840 --> 00:31:39,850
that we have at KB Lake silicon package

800
00:31:39,850 --> 00:31:41,440
we have a coffee like silicon package

801
00:31:41,440 --> 00:31:44,890
and so we've started kind of moving some

802
00:31:44,890 --> 00:31:46,960
of this silicon and it code into the

803
00:31:46,960 --> 00:31:48,660
open source and pairing it here and

804
00:31:48,660 --> 00:31:50,590
that's one of the things that we are

805
00:31:50,590 --> 00:31:52,630
looking at is how to bring more of that

806
00:31:52,630 --> 00:31:55,390
code into the the open but as far as

807
00:31:55,390 --> 00:31:57,580
this minimum platform initiative goes

808
00:31:57,580 --> 00:31:59,830
the the main focus right now is getting

809
00:31:59,830 --> 00:32:01,630
all this platform code into the open and

810
00:32:01,630 --> 00:32:05,590
using the Intel FSP that we release I

811
00:32:05,590 --> 00:32:08,530
have a question is oh you're talking

812
00:32:08,530 --> 00:32:10,630
about mini platform is a very good

813
00:32:10,630 --> 00:32:14,500
concept that perhaps is still one

814
00:32:14,500 --> 00:32:17,520
platform right but have you considered

815
00:32:17,520 --> 00:32:20,770
mini platform is actually considered a

816
00:32:20,770 --> 00:32:23,950
main platform which device Orion for

817
00:32:23,950 --> 00:32:26,830
example like the notebook at home can

818
00:32:26,830 --> 00:32:29,950
actually control everything from your

819
00:32:29,950 --> 00:32:31,450
switch

820
00:32:31,450 --> 00:32:36,969
you know other device right light ball

821
00:32:36,969 --> 00:32:40,359
in the debt so the platform is actually

822
00:32:40,359 --> 00:32:44,079
not physical platform but it's connected

823
00:32:44,079 --> 00:32:48,429
platform so to address the world

824
00:32:48,429 --> 00:32:52,659
everything is connected so you're

825
00:32:52,659 --> 00:32:55,559
talking about like a salon I want a mini

826
00:32:55,559 --> 00:32:59,619
platform is not for both purpose is

827
00:32:59,619 --> 00:33:02,679
before example it's a CPI component

828
00:33:02,679 --> 00:33:05,409
actually can be product in another

829
00:33:05,409 --> 00:33:06,700
platform

830
00:33:06,700 --> 00:33:09,339
oh okay III think I think you're kind of

831
00:33:09,339 --> 00:33:11,679
alluding to the advanced features and so

832
00:33:11,679 --> 00:33:13,450
the advanced features the the idea of

833
00:33:13,450 --> 00:33:14,709
maybe I wasn't clear on that the idea

834
00:33:14,709 --> 00:33:16,329
behind the advanced features is that you

835
00:33:16,329 --> 00:33:19,149
can plug them into any min platform and

836
00:33:19,149 --> 00:33:21,369
so that's one of the things that we're

837
00:33:21,369 --> 00:33:23,109
working toward we're not we're not quite

838
00:33:23,109 --> 00:33:25,389
there yet but we want to get the

839
00:33:25,389 --> 00:33:27,489
advanced features such that whenever you

840
00:33:27,489 --> 00:33:29,019
have an advanced feature you if it works

841
00:33:29,019 --> 00:33:30,579
on KB like open board you can use it on

842
00:33:30,579 --> 00:33:33,639
whiskey like open board and if you're if

843
00:33:33,639 --> 00:33:35,139
you're working on board packages you can

844
00:33:35,139 --> 00:33:37,089
upload those edk to platforms as well

845
00:33:37,089 --> 00:33:39,489
and just show how you're using that

846
00:33:39,489 --> 00:33:41,769
feature and so one of the things that

847
00:33:41,769 --> 00:33:43,450
does happen whenever you're using these

848
00:33:43,450 --> 00:33:45,459
features is if you make an update to one

849
00:33:45,459 --> 00:33:47,999
it affects a lot of people now and so

850
00:33:47,999 --> 00:33:50,409
uploading at DDK tube platforms is

851
00:33:50,409 --> 00:33:52,059
probably I think the better way to

852
00:33:52,059 --> 00:33:54,279
ensure that you're able to get the

853
00:33:54,279 --> 00:33:55,989
support you need if you're using the

854
00:33:55,989 --> 00:33:58,989
advanced features but I think that's a

855
00:33:58,989 --> 00:34:01,509
good point we do have the advanced

856
00:34:01,509 --> 00:34:03,039
feature is able to plug in to the

857
00:34:03,039 --> 00:34:06,839
various open platforms that we deliver

858
00:34:06,839 --> 00:34:09,759
short question about platforms that you

859
00:34:09,759 --> 00:34:11,409
deliver because for some platforms for

860
00:34:11,409 --> 00:34:14,199
the coffee like you have slim boot boot

861
00:34:14,199 --> 00:34:16,059
loader support for others you have core

862
00:34:16,059 --> 00:34:17,168
boot for others you have to mint

863
00:34:17,168 --> 00:34:19,509
platform looking forward what will be

864
00:34:19,509 --> 00:34:21,849
the pledge for the the primary firmware

865
00:34:21,849 --> 00:34:23,849
that will receive most testing and

866
00:34:23,849 --> 00:34:27,089
what's if you start a new product today

867
00:34:27,089 --> 00:34:29,739
should you base it on coreboot slim boot

868
00:34:29,739 --> 00:34:31,359
min platform you good

869
00:34:31,359 --> 00:34:34,629
so the the way that that we look at this

870
00:34:34,629 --> 00:34:36,549
and I look at it is it there's not

871
00:34:36,549 --> 00:34:39,250
necessarily a best solution I think that

872
00:34:39,250 --> 00:34:41,049
all of these have their purpose and so

873
00:34:41,049 --> 00:34:42,969
the the difference if you look at kind

874
00:34:42,969 --> 00:34:44,889
of the difference between this and core

875
00:34:44,889 --> 00:34:45,190
boot

876
00:34:45,190 --> 00:34:47,949
slim boot is this is fully UEFI PPI spec

877
00:34:47,949 --> 00:34:50,679
compliant that's number one so you can

878
00:34:50,679 --> 00:34:53,530
use FSP dispatch mode you can't with the

879
00:34:53,530 --> 00:34:55,210
other solutions right whether it's slim

880
00:34:55,210 --> 00:34:57,129
boot or coreboot the other one is this

881
00:34:57,129 --> 00:35:00,069
is BSD licensed it's not GPL licensed

882
00:35:00,069 --> 00:35:03,599
and so that helps with some people and

883
00:35:03,599 --> 00:35:08,440
this is I think it integrates better

884
00:35:08,440 --> 00:35:10,119
with the way that the PC supply chain

885
00:35:10,119 --> 00:35:12,310
works today and so if we're talking

886
00:35:12,310 --> 00:35:14,290
about people that have commercial

887
00:35:14,290 --> 00:35:16,750
systems today built on edk to firmware

888
00:35:16,750 --> 00:35:19,630
this is fully dk2 compliant and kind of

889
00:35:19,630 --> 00:35:21,069
satisfies that need and so I think

890
00:35:21,069 --> 00:35:22,839
depending on your licensing and your

891
00:35:22,839 --> 00:35:25,810
goals with your system you could you

892
00:35:25,810 --> 00:35:28,089
could use any of them what we at Intel

893
00:35:28,089 --> 00:35:30,880
are hoping to do is to make building

894
00:35:30,880 --> 00:35:32,829
firmware on Intel products easier and so

895
00:35:32,829 --> 00:35:34,869
it's not about using Mint platform or

896
00:35:34,869 --> 00:35:37,210
using Core boot or using it's it's about

897
00:35:37,210 --> 00:35:39,220
what your needs are having this these

898
00:35:39,220 --> 00:35:40,930
resources available to you and then you

899
00:35:40,930 --> 00:35:43,030
can make the decision about how you want

900
00:35:43,030 --> 00:35:48,550
to build the firmware on there I just

901
00:35:48,550 --> 00:35:50,920
wanted to check when you put this in the

902
00:35:50,920 --> 00:35:52,540
ATK two platforms are you planning to

903
00:35:52,540 --> 00:35:54,550
put a documentation there for example

904
00:35:54,550 --> 00:35:55,690
normally you have a very good

905
00:35:55,690 --> 00:35:58,240
documentation piano core so for example

906
00:35:58,240 --> 00:35:59,770
for the main platform and for the

907
00:35:59,770 --> 00:36:02,020
advanced features you will be having

908
00:36:02,020 --> 00:36:04,030
some documentation on guiding how to put

909
00:36:04,030 --> 00:36:07,270
it to one's own boot yes so today we

910
00:36:07,270 --> 00:36:09,940
have the minimum platform spec that's

911
00:36:09,940 --> 00:36:11,589
our main documentation at the moment

912
00:36:11,589 --> 00:36:13,690
that's like a hundred plus page document

913
00:36:13,690 --> 00:36:15,940
that explains the architecture it

914
00:36:15,940 --> 00:36:18,130
explains the interfaces between the

915
00:36:18,130 --> 00:36:19,900
board code and the platform code and why

916
00:36:19,900 --> 00:36:21,849
we're doing what we're doing that one

917
00:36:21,849 --> 00:36:24,069
everyone's open to contribute to so that

918
00:36:24,069 --> 00:36:25,960
one you don't just have to take as you

919
00:36:25,960 --> 00:36:28,030
know the spec says it's this way that's

920
00:36:28,030 --> 00:36:29,680
an open specification it's in draft

921
00:36:29,680 --> 00:36:31,750
state so you can definitely give

922
00:36:31,750 --> 00:36:33,550
feedback we would highly encourage you

923
00:36:33,550 --> 00:36:36,069
to give feedback on that the other piece

924
00:36:36,069 --> 00:36:37,930
that we have is we have the readme dot

925
00:36:37,930 --> 00:36:40,000
MD in the github repository that has the

926
00:36:40,000 --> 00:36:42,010
quick practical up get up and running

927
00:36:42,010 --> 00:36:44,380
information and then the other thing I

928
00:36:44,380 --> 00:36:45,640
was kind of getting to in the

929
00:36:45,640 --> 00:36:47,619
presentation was we want to get to more

930
00:36:47,619 --> 00:36:50,560
of the hands-on documentation kind of

931
00:36:50,560 --> 00:36:52,180
like you would find in the core boot and

932
00:36:52,180 --> 00:36:53,470
slim boot repositories if you go to

933
00:36:53,470 --> 00:36:55,359
their wikis they have information about

934
00:36:55,359 --> 00:36:57,760
how to understand the memory map how do

935
00:36:57,760 --> 00:37:00,040
basically break apart your if we and see

936
00:37:00,040 --> 00:37:01,810
where the BIOS is and so we'll be

937
00:37:01,810 --> 00:37:03,460
building more of that but that's kind of

938
00:37:03,460 --> 00:37:04,810
the missing piece at the moment but we

939
00:37:04,810 --> 00:37:06,220
will be adding that kind of practical

940
00:37:06,220 --> 00:37:11,619
hands-on guide soon yeah we have about

941
00:37:11,619 --> 00:37:14,890
time for three more questions just one

942
00:37:14,890 --> 00:37:17,830
more question about about software our

943
00:37:17,830 --> 00:37:20,470
label can chew right if you were working

944
00:37:20,470 --> 00:37:22,510
on the open source Linux we have

945
00:37:22,510 --> 00:37:26,050
launched longtime stable labor right

946
00:37:26,050 --> 00:37:31,990
like Ubuntu 1604 but in the firmware

947
00:37:31,990 --> 00:37:36,010
world like we ced k2 we have thousands

948
00:37:36,010 --> 00:37:39,010
update you know throughout the year and

949
00:37:39,010 --> 00:37:42,160
then maybe we make one label but nobody

950
00:37:42,160 --> 00:37:45,190
really knows right when you ship a

951
00:37:45,190 --> 00:37:48,640
product what kind of version of your

952
00:37:48,640 --> 00:37:52,150
firmware is so end up everybody's keep

953
00:37:52,150 --> 00:37:54,780
up with version but from my experience

954
00:37:54,780 --> 00:37:58,119
before with the Phoenix nobody want to

955
00:37:58,119 --> 00:38:01,420
update the kernel a version

956
00:38:01,420 --> 00:38:04,690
yeah that's a good point so the edk 2

957
00:38:04,690 --> 00:38:06,880
project has what are called stable tags

958
00:38:06,880 --> 00:38:09,760
and so I believe it's every quarter we

959
00:38:09,760 --> 00:38:12,070
do label the code and do a very

960
00:38:12,070 --> 00:38:13,780
comprehensive validation on the code and

961
00:38:13,780 --> 00:38:15,310
produce that stable tag in the

962
00:38:15,310 --> 00:38:17,350
repository you'll find the stable tags

963
00:38:17,350 --> 00:38:20,050
there prior to this we did you DK

964
00:38:20,050 --> 00:38:22,000
releases we had these things called UDK

965
00:38:22,000 --> 00:38:25,630
2017-2018 and so we have we do have a

966
00:38:25,630 --> 00:38:28,210
concept of similar to Linux of having

967
00:38:28,210 --> 00:38:30,490
these released milestones and we and

968
00:38:30,490 --> 00:38:34,470
there is validation done at those but

969
00:38:34,470 --> 00:38:37,180
yeah so I think that that that's there

970
00:38:37,180 --> 00:38:41,140
today for for ATK to the ATK 2 platforms

971
00:38:41,140 --> 00:38:43,359
the nice thing that this brings is that

972
00:38:43,359 --> 00:38:45,400
this platform code actually uses the tip

973
00:38:45,400 --> 00:38:47,560
of e DK to and that's fairly rare if you

974
00:38:47,560 --> 00:38:50,470
look across the PC ecosystem today most

975
00:38:50,470 --> 00:38:52,180
people are building firmwares that latch

976
00:38:52,180 --> 00:38:55,450
on to a specific version of the e d of e

977
00:38:55,450 --> 00:38:58,030
DK 2 and it's often a fairly old version

978
00:38:58,030 --> 00:38:59,800
and so whenever you go get these open

979
00:38:59,800 --> 00:39:01,660
board packages we're actually doing the

980
00:39:01,660 --> 00:39:04,390
CI with the tip of e DK 2 and so you're

981
00:39:04,390 --> 00:39:05,740
getting the code that works with the

982
00:39:05,740 --> 00:39:08,080
code you see and the e DK 2 repository

983
00:39:08,080 --> 00:39:10,450
and so that that's another benefit to

984
00:39:10,450 --> 00:39:11,559
moving to this and we look

985
00:39:11,559 --> 00:39:13,989
that even in terms of deploying security

986
00:39:13,989 --> 00:39:16,959
updates and and getting fit patches and

987
00:39:16,959 --> 00:39:19,209
fixes out much faster being able to just

988
00:39:19,209 --> 00:39:21,009
have it push into the open and people go

989
00:39:21,009 --> 00:39:24,579
find it easily is we think of a nice

990
00:39:24,579 --> 00:39:26,109
improvement to have for where we are

991
00:39:26,109 --> 00:39:28,299
today we have time for two more

992
00:39:28,299 --> 00:39:30,479
questions

993
00:39:34,109 --> 00:39:38,439
the first is uses that so now the FSP

994
00:39:38,439 --> 00:39:40,869
right can be caught through two

995
00:39:40,869 --> 00:39:43,930
different modes one is API mode mmm

996
00:39:43,930 --> 00:39:48,579
another dispatch mode yeah um so so does

997
00:39:48,579 --> 00:39:50,349
that mean so how do you make sure that

998
00:39:50,349 --> 00:39:53,019
in your validation your internal

999
00:39:53,019 --> 00:39:56,079
validation you do you to vary the

1000
00:39:56,079 --> 00:39:59,650
post-modern okay yes so that that's a

1001
00:39:59,650 --> 00:40:01,660
good that's another good point so in the

1002
00:40:01,660 --> 00:40:02,979
validation this is one of the things

1003
00:40:02,979 --> 00:40:04,359
that we talked about whenever we moved

1004
00:40:04,359 --> 00:40:07,869
to these FSP modes we choose the the

1005
00:40:07,869 --> 00:40:09,969
default mode for the particular product

1006
00:40:09,969 --> 00:40:13,150
and so we'll do that as our every

1007
00:40:13,150 --> 00:40:15,430
check-in that we do we validate against

1008
00:40:15,430 --> 00:40:17,529
one of the modes and so we choose that

1009
00:40:17,529 --> 00:40:19,209
mode and then we move the other mode to

1010
00:40:19,209 --> 00:40:21,039
like daily testing or a more delayed

1011
00:40:21,039 --> 00:40:23,949
testing but whenever we release the FSP

1012
00:40:23,949 --> 00:40:26,219
binary both modes if they're indicated

1013
00:40:26,219 --> 00:40:28,779
so whenever you look at the SFSP info

1014
00:40:28,779 --> 00:40:30,039
header there'll be a bit they'll say

1015
00:40:30,039 --> 00:40:31,539
whether it's sports dispatch mode in

1016
00:40:31,539 --> 00:40:33,759
supports API mode if both modes show up

1017
00:40:33,759 --> 00:40:35,140
as supported then those modes are

1018
00:40:35,140 --> 00:40:37,539
validated by the time that binary is

1019
00:40:37,539 --> 00:40:40,329
released so as I extend you the question

1020
00:40:40,329 --> 00:40:42,969
so when you very face famos so you have

1021
00:40:42,969 --> 00:40:45,640
F F SP for different associate

1022
00:40:45,640 --> 00:40:48,549
so for different ISO system FSB banner

1023
00:40:48,549 --> 00:40:49,779
is different mhm

1024
00:40:49,779 --> 00:40:53,979
so how do you make sure that my vendor

1025
00:40:53,979 --> 00:40:55,959
you've added the FSB for all different

1026
00:40:55,959 --> 00:40:59,469
resources oh we have SOC specific

1027
00:40:59,469 --> 00:41:01,989
validation and so every product that we

1028
00:41:01,989 --> 00:41:04,449
we make we have a very large validation

1029
00:41:04,449 --> 00:41:06,519
team that does full validation across

1030
00:41:06,519 --> 00:41:09,009
that product and so the FSP is part of

1031
00:41:09,009 --> 00:41:11,349
that now the other thing to mention

1032
00:41:11,349 --> 00:41:12,910
while we're talking about that is we the

1033
00:41:12,910 --> 00:41:14,979
FSP gets posted on github so there's the

1034
00:41:14,979 --> 00:41:17,259
FSP repository if you go to the main for

1035
00:41:17,259 --> 00:41:19,089
the master branch there you'll find all

1036
00:41:19,089 --> 00:41:21,759
the FS ps4 Intel products that have FSP

1037
00:41:21,759 --> 00:41:24,519
binaries the open board packages use

1038
00:41:24,519 --> 00:41:25,400
that binary

1039
00:41:25,400 --> 00:41:27,260
directly and so it's not like there's

1040
00:41:27,260 --> 00:41:28,640
anything hidden or you have to go sign

1041
00:41:28,640 --> 00:41:30,890
up for you just go to the FSP repository

1042
00:41:30,890 --> 00:41:33,470
get the FSP binary go to the e DK 2

1043
00:41:33,470 --> 00:41:35,810
platforms repository get the open board

1044
00:41:35,810 --> 00:41:37,670
package the open board package will

1045
00:41:37,670 --> 00:41:39,590
already be written to use that FSP and

1046
00:41:39,590 --> 00:41:41,510
you can boot it up on your system and

1047
00:41:41,510 --> 00:41:43,940
that's the one that we're validating for

1048
00:41:43,940 --> 00:41:46,010
the open board package so you can kind

1049
00:41:46,010 --> 00:41:49,040
of make the link between those another

1050
00:41:49,040 --> 00:41:51,200
question I have is that in the corner um

1051
00:41:51,200 --> 00:41:54,590
you have a spec and the PS pack that the

1052
00:41:54,590 --> 00:41:58,700
FSP code right the interact with the

1053
00:41:58,700 --> 00:42:01,400
code of state the rest of the UEFI edk

1054
00:42:01,400 --> 00:42:04,100
to through the P aspect and and you FS

1055
00:42:04,100 --> 00:42:07,130
back or that exe porticos and a PR proto

1056
00:42:07,130 --> 00:42:09,590
goes right now your actor switching from

1057
00:42:09,590 --> 00:42:13,430
that operating mode to dispatch mode hmm

1058
00:42:13,430 --> 00:42:16,030
right within the improv foreign concept

1059
00:42:16,030 --> 00:42:19,460
so dispatch mode is fully compliant with

1060
00:42:19,460 --> 00:42:21,710
all those specifications so you don't

1061
00:42:21,710 --> 00:42:24,260
you don't actually have to modify this

1062
00:42:24,260 --> 00:42:27,230
back oh no no in fact this embraces the

1063
00:42:27,230 --> 00:42:29,150
spec because now we're we're not

1064
00:42:29,150 --> 00:42:31,490
pretending that the FSP is not a needy K

1065
00:42:31,490 --> 00:42:33,260
to firmware volume we're just saying it

1066
00:42:33,260 --> 00:42:34,850
is a firmware volume here you go

1067
00:42:34,850 --> 00:42:38,000
dispatcher find the efi modules inside

1068
00:42:38,000 --> 00:42:40,070
and dispatch them right so it used to be

1069
00:42:40,070 --> 00:42:42,410
mangled a tweezer scene choose a

1070
00:42:42,410 --> 00:42:44,990
firmware Wouter yeah and now it has its

1071
00:42:44,990 --> 00:42:46,850
own son and that's all you it

1072
00:42:46,850 --> 00:42:49,790
well the TI Monessen generally had their

1073
00:42:49,790 --> 00:42:51,440
own firmer volumes but we put the

1074
00:42:51,440 --> 00:42:53,300
firmware volumes together into an FD we

1075
00:42:53,300 --> 00:42:56,810
call it the the code has the ability

1076
00:42:56,810 --> 00:42:58,550
whenever you use an interface called

1077
00:42:58,550 --> 00:43:01,010
install firmware volume it can actually

1078
00:43:01,010 --> 00:43:04,070
give it the address of the Illman s from

1079
00:43:04,070 --> 00:43:05,990
our volume for example and it would know

1080
00:43:05,990 --> 00:43:08,090
how to parse it and move the images that

1081
00:43:08,090 --> 00:43:10,460
it finds into the list of images for the

1082
00:43:10,460 --> 00:43:13,010
dispatcher to be able to invoke and so

1083
00:43:13,010 --> 00:43:15,050
it's a very natural process it works the

1084
00:43:15,050 --> 00:43:17,090
same as if you just wrote I mean it is

1085
00:43:17,090 --> 00:43:18,770
native edk to code right so if you were

1086
00:43:18,770 --> 00:43:20,390
to write your own code and put it into a

1087
00:43:20,390 --> 00:43:22,160
firmer volume it would be dispatched

1088
00:43:22,160 --> 00:43:25,100
very similar to this there there is

1089
00:43:25,100 --> 00:43:26,060
though if you are planning on using

1090
00:43:26,060 --> 00:43:29,660
dispatch mode do check out the Intel FSP

1091
00:43:29,660 --> 00:43:31,790
2.1 spec because there are special

1092
00:43:31,790 --> 00:43:34,220
things that you need to consider so I

1093
00:43:34,220 --> 00:43:35,630
think that's maybe your point is there's

1094
00:43:35,630 --> 00:43:37,010
there's a little bit more you need to

1095
00:43:37,010 --> 00:43:38,250
think about one of

1096
00:43:38,250 --> 00:43:40,440
is the pei core like we only have one

1097
00:43:40,440 --> 00:43:42,750
pei core it gets used that's the one in

1098
00:43:42,750 --> 00:43:45,510
the FSP binary it's supposed to me it

1099
00:43:45,510 --> 00:43:46,500
doesn't have there's there's an

1100
00:43:46,500 --> 00:43:47,790
alternative boot flow in there that

1101
00:43:47,790 --> 00:43:48,900
talks about if you don't want to use the

1102
00:43:48,900 --> 00:43:50,520
one in the FSP binary because you want

1103
00:43:50,520 --> 00:43:51,990
to use your own with your own you know

1104
00:43:51,990 --> 00:43:54,030
stuff compiled in but if you're using

1105
00:43:54,030 --> 00:43:55,980
that one you have to produce a special

1106
00:43:55,980 --> 00:43:58,290
PPI and go through the process and the

1107
00:43:58,290 --> 00:44:00,930
spec that is described there so if you

1108
00:44:00,930 --> 00:44:02,550
are going to use this batch mode just

1109
00:44:02,550 --> 00:44:04,710
read that section of the specification

1110
00:44:04,710 --> 00:44:06,840
and use your FSP integration guide and

1111
00:44:06,840 --> 00:44:09,210
you can get the benefits of the despatch

1112
00:44:09,210 --> 00:44:11,580
mode thank you and that's about it for

1113
00:44:11,580 --> 00:44:12,960
questions please have another round of

1114
00:44:12,960 --> 00:44:15,150
applause so Michael thank you thank you

1115
00:44:15,150 --> 00:44:15,740
Michael

1116
00:44:15,740 --> 00:44:16,720
[Applause]

1117
00:44:16,720 --> 00:44:24,450
[Music]

