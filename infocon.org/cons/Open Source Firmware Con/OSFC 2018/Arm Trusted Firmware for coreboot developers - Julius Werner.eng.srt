1
00:00:00,000 --> 00:00:04,310
[Music]

2
00:00:04,310 --> 00:00:06,870
welcome back everyone I hope you had a

3
00:00:06,870 --> 00:00:10,230
great coffee break so we're going to

4
00:00:10,230 --> 00:00:14,549
hear more about arm so you lose that's

5
00:00:14,549 --> 00:00:17,250
your stage and let's hear about trusted

6
00:00:17,250 --> 00:00:20,010
for work okay thanks

7
00:00:20,010 --> 00:00:23,039
is this thing on okay great

8
00:00:23,039 --> 00:00:27,630
so hi everyone I'm Julius and I work for

9
00:00:27,630 --> 00:00:29,760
Google on Chrome OS firmware i'm also

10
00:00:29,760 --> 00:00:32,668
the co boot maintainer for arm

11
00:00:32,668 --> 00:00:35,309
architectures and i also wanted to talk

12
00:00:35,309 --> 00:00:37,920
about trusted firmware today so when i

13
00:00:37,920 --> 00:00:39,420
signed up for this talk actually didn't

14
00:00:39,420 --> 00:00:41,070
know that arm would also be here and

15
00:00:41,070 --> 00:00:42,360
talked about us as promised of one of

16
00:00:42,360 --> 00:00:43,469
this some of this may be a little

17
00:00:43,469 --> 00:00:46,620
duplicate but my main focus for this

18
00:00:46,620 --> 00:00:50,100
talk is a broad introduction to people

19
00:00:50,100 --> 00:00:51,629
who have no idea what trusted firmwares

20
00:00:51,629 --> 00:00:54,300
who may be no coreboot and don't really

21
00:00:54,300 --> 00:00:56,850
know why the two have been like why

22
00:00:56,850 --> 00:00:58,710
coreboot is using trusted firmware these

23
00:00:58,710 --> 00:01:00,800
days when I'm sixty-four systems

24
00:01:00,800 --> 00:01:04,438
actually when I thought about this talk

25
00:01:04,438 --> 00:01:08,070
first my intention was to do just the

26
00:01:08,070 --> 00:01:11,159
general call boot on arm 64 talk at two

27
00:01:11,159 --> 00:01:12,810
years ago in San Francisco I already

28
00:01:12,810 --> 00:01:15,540
gave a talk about Co boot on I'm 32 and

29
00:01:15,540 --> 00:01:17,549
this was supposed to be kind of the next

30
00:01:17,549 --> 00:01:20,040
situation of that but when I looked into

31
00:01:20,040 --> 00:01:22,740
this more closely I realized that in on

32
00:01:22,740 --> 00:01:24,299
the cob boot side there's really not a

33
00:01:24,299 --> 00:01:26,790
lot of difference between 32 and 64-bit

34
00:01:26,790 --> 00:01:28,650
arm there's of course the ISA is a

35
00:01:28,650 --> 00:01:29,579
little different there are some

36
00:01:29,579 --> 00:01:31,650
differences in the details but for the

37
00:01:31,650 --> 00:01:33,600
general coreboot framework at all pretty

38
00:01:33,600 --> 00:01:35,640
much works the same and the difference

39
00:01:35,640 --> 00:01:38,299
is compared to x86 core Buddha also

40
00:01:38,299 --> 00:01:41,250
pretty much all the same so if you look

41
00:01:41,250 --> 00:01:42,840
at that old talk most of these things

42
00:01:42,840 --> 00:01:46,350
are still true for 64-bit ARM platforms

43
00:01:46,350 --> 00:01:49,110
the one we our difference in how abude

44
00:01:49,110 --> 00:01:50,549
works the stays on these platforms this

45
00:01:50,549 --> 00:01:52,049
is a trusted firmware part so that's why

46
00:01:52,049 --> 00:01:55,860
I chose to focus on that and to start

47
00:01:55,860 --> 00:01:57,930
the motivation of what we why we even

48
00:01:57,930 --> 00:02:00,689
need this trusted firmware it actually

49
00:02:00,689 --> 00:02:02,850
has to do with the expectations that

50
00:02:02,850 --> 00:02:05,340
Linux has to the firmware environment so

51
00:02:05,340 --> 00:02:09,030
this is a little excerpt from the device

52
00:02:09,030 --> 00:02:10,649
through documentation in Linux the

53
00:02:10,649 --> 00:02:13,230
device tree is this thing which is

54
00:02:13,230 --> 00:02:13,870
essentially

55
00:02:13,870 --> 00:02:15,819
table of hardware description that the

56
00:02:15,819 --> 00:02:18,129
firmware passes to the kernel to so that

57
00:02:18,129 --> 00:02:20,049
the kernel knows how that how that

58
00:02:20,049 --> 00:02:23,830
particular hardware is laid out and as

59
00:02:23,830 --> 00:02:25,629
you can see here this part talks about

60
00:02:25,629 --> 00:02:28,209
CPU one-time power management so turning

61
00:02:28,209 --> 00:02:32,230
CPUs off and on to save power and on am

62
00:02:32,230 --> 00:02:34,150
32 that part was still optional and I'm

63
00:02:34,150 --> 00:02:36,310
64 it's now required that we have this

64
00:02:36,310 --> 00:02:41,079
weird PSC I thing so in order to figure

65
00:02:41,079 --> 00:02:43,090
out what that is and how we get there

66
00:02:43,090 --> 00:02:44,470
how we can support that with our

67
00:02:44,470 --> 00:02:46,750
firmware you have to follow me on a

68
00:02:46,750 --> 00:02:49,450
journey through the Trust's on

69
00:02:49,450 --> 00:02:53,650
I mostly put this up because I sometimes

70
00:02:53,650 --> 00:02:55,239
get the impression that people who don't

71
00:02:55,239 --> 00:02:57,670
know the architecture that well just

72
00:02:57,670 --> 00:03:00,069
have heard this term trust zone

73
00:03:00,069 --> 00:03:01,390
somewhere ever don't really know what it

74
00:03:01,390 --> 00:03:02,829
means and think it's this kind of scaly

75
00:03:02,829 --> 00:03:06,010
thing that once the evil code that spies

76
00:03:06,010 --> 00:03:09,359
on you or the DRM stuff or something so

77
00:03:09,359 --> 00:03:11,500
trying to take some of that fear away

78
00:03:11,500 --> 00:03:14,859
it's really not that complicated because

79
00:03:14,859 --> 00:03:16,209
if so if you're running open source

80
00:03:16,209 --> 00:03:18,040
firmware essentially you can also want

81
00:03:18,040 --> 00:03:19,569
an open source trust zone it's really

82
00:03:19,569 --> 00:03:23,079
just an architectural feature to run

83
00:03:23,079 --> 00:03:24,819
code outside of the context of the

84
00:03:24,819 --> 00:03:27,579
kernel so whoever seen the previous talk

85
00:03:27,579 --> 00:03:30,060
this is very similar slide essentially

86
00:03:30,060 --> 00:03:33,129
just telling you what this trust so and

87
00:03:33,129 --> 00:03:36,700
stuff is it's essentially comparable to

88
00:03:36,700 --> 00:03:39,040
system management mode on x86 with the

89
00:03:39,040 --> 00:03:40,480
difference that system management mode

90
00:03:40,480 --> 00:03:43,510
is a really ugly legacy thing and this

91
00:03:43,510 --> 00:03:46,000
is a much nicer and cleaner extension of

92
00:03:46,000 --> 00:03:47,319
the existing architecture so you

93
00:03:47,319 --> 00:03:49,269
shouldn't Lee just take the existing

94
00:03:49,269 --> 00:03:51,609
concept of kernel and use the land and

95
00:03:51,609 --> 00:03:54,579
expand it to another level so in the

96
00:03:54,579 --> 00:03:56,919
same way user land make system calls so

97
00:03:56,919 --> 00:03:58,840
the kernel the Kerner can make these

98
00:03:58,840 --> 00:04:01,540
secure monitor calls to the next

99
00:04:01,540 --> 00:04:05,859
exception level up there and the the

100
00:04:05,859 --> 00:04:07,900
whole trust zone isn't just the part on

101
00:04:07,900 --> 00:04:09,250
there but it's the whole part on the

102
00:04:09,250 --> 00:04:10,930
right side so it's like a whole separate

103
00:04:10,930 --> 00:04:13,209
operating system and user land that can

104
00:04:13,209 --> 00:04:14,980
run these trusted applications that are

105
00:04:14,980 --> 00:04:18,488
secured from the from the rest of the

106
00:04:18,488 --> 00:04:20,260
operating system and this is this

107
00:04:20,260 --> 00:04:22,479
barrier is sort of a one-way street so

108
00:04:22,479 --> 00:04:25,659
the secure stuff can still access the

109
00:04:25,659 --> 00:04:27,639
non secure stuff but not the other way

110
00:04:27,639 --> 00:04:32,949
and there's also no true no true memory

111
00:04:32,949 --> 00:04:35,499
virtualization on this right side over

112
00:04:35,499 --> 00:04:38,680
here so the the secure s can actually

113
00:04:38,680 --> 00:04:41,199
access the secure monitor memory and

114
00:04:41,199 --> 00:04:42,909
thus attack the secure monitor

115
00:04:42,909 --> 00:04:44,740
essentially unless of course you have

116
00:04:44,740 --> 00:04:46,060
those new architectural features which

117
00:04:46,060 --> 00:04:47,740
we just heard about in the previous talk

118
00:04:47,740 --> 00:04:52,900
and the the reason of that execu monitor

119
00:04:52,900 --> 00:04:54,610
down there is essentially to arbitrate

120
00:04:54,610 --> 00:04:57,159
between these trusted applications that

121
00:04:57,159 --> 00:04:58,960
one your DRM stuff or whatever you want

122
00:04:58,960 --> 00:05:01,300
them to run and the main operating

123
00:05:01,300 --> 00:05:02,699
system that's why it's at the highest

124
00:05:02,699 --> 00:05:05,469
it's called exception level and I'm 64

125
00:05:05,469 --> 00:05:06,699
but that essentially also means

126
00:05:06,699 --> 00:05:09,250
privilege level so use the land as level

127
00:05:09,250 --> 00:05:11,770
zero Karnas level one hypervisors level

128
00:05:11,770 --> 00:05:13,270
two and then the secure monitor is the

129
00:05:13,270 --> 00:05:16,529
most privileged thing at level three and

130
00:05:16,529 --> 00:05:19,120
this the definition of this memory

131
00:05:19,120 --> 00:05:21,669
barriers actually very completely SOC

132
00:05:21,669 --> 00:05:23,949
specific so there's no there's no

133
00:05:23,949 --> 00:05:25,479
architectural way and the ARM

134
00:05:25,479 --> 00:05:27,759
architecture to say which parts are

135
00:05:27,759 --> 00:05:29,529
secure memory and which parts are non

136
00:05:29,529 --> 00:05:31,629
secure memory every SOC has its own

137
00:05:31,629 --> 00:05:33,310
thing for that and usually it's just

138
00:05:33,310 --> 00:05:35,139
some sort of range register where you

139
00:05:35,139 --> 00:05:37,270
say okay starting from this offset for

140
00:05:37,270 --> 00:05:39,339
this size that memory area as part of

141
00:05:39,339 --> 00:05:42,129
secure memory and it's not just memory

142
00:05:42,129 --> 00:05:43,240
it's the whole physical address space

143
00:05:43,240 --> 00:05:45,580
actually so also all the MMI roper folds

144
00:05:45,580 --> 00:05:47,889
you can say that they only belong to the

145
00:05:47,889 --> 00:05:49,449
secure world and then non secure world

146
00:05:49,449 --> 00:05:51,339
cannot access that particular i2c

147
00:05:51,339 --> 00:05:55,569
control or something like that if we

148
00:05:55,569 --> 00:05:59,830
want to figure out why we need this to

149
00:05:59,830 --> 00:06:02,949
support Linux we got to again go to the

150
00:06:02,949 --> 00:06:05,349
CPU power management stuff so if you in

151
00:06:05,349 --> 00:06:07,449
case you know in Linux CPU power

152
00:06:07,449 --> 00:06:09,069
management called CPU idle is

153
00:06:09,069 --> 00:06:10,599
essentially turning off a CPU and you

154
00:06:10,599 --> 00:06:12,580
don't need it to save power and if you

155
00:06:12,580 --> 00:06:14,469
ignore the slide for a second on am 32

156
00:06:14,469 --> 00:06:16,779
this was completely handled within the

157
00:06:16,779 --> 00:06:18,520
neck so when linux decides it doesn't

158
00:06:18,520 --> 00:06:21,909
want to use the CPU then it turns the

159
00:06:21,909 --> 00:06:23,770
CPU off turns all the power wheels off

160
00:06:23,770 --> 00:06:25,899
to go to it and once the wait for

161
00:06:25,899 --> 00:06:27,490
interrupt instruction on the CPU and

162
00:06:27,490 --> 00:06:29,889
then when the CPU wakes back up it comes

163
00:06:29,889 --> 00:06:31,539
back right into Linux and the next does

164
00:06:31,539 --> 00:06:34,180
all the reinitialize ation for that the

165
00:06:34,180 --> 00:06:36,039
problem is if you have this trust zone

166
00:06:36,039 --> 00:06:37,659
on the side you can't really do that

167
00:06:37,659 --> 00:06:40,330
because the trust zone also needs to CPU

168
00:06:40,330 --> 00:06:41,390
right so first of all

169
00:06:41,390 --> 00:06:43,670
need something when Linux decides I

170
00:06:43,670 --> 00:06:45,830
don't want the CPU right now then you

171
00:06:45,830 --> 00:06:48,470
need something else to ask the secure

172
00:06:48,470 --> 00:06:50,300
part if it also doesn't need two CPU an

173
00:06:50,300 --> 00:06:51,710
hour maybe you need to keep the CPU

174
00:06:51,710 --> 00:06:53,950
alive because the secure parts needs it

175
00:06:53,950 --> 00:06:57,710
and the other thing is there's so if you

176
00:06:57,710 --> 00:06:59,390
turn a CPU completely often then turn it

177
00:06:59,390 --> 00:07:01,040
back on then it has lost all its state

178
00:07:01,040 --> 00:07:03,890
of course and some of that state is not

179
00:07:03,890 --> 00:07:05,540
accessible to the kernel for example the

180
00:07:05,540 --> 00:07:08,180
page table base address register there's

181
00:07:08,180 --> 00:07:09,440
one for the corner but there's a

182
00:07:09,440 --> 00:07:11,480
separate one for the trust for the

183
00:07:11,480 --> 00:07:13,490
secure monitor and of course the kernel

184
00:07:13,490 --> 00:07:15,020
cannot write the page table base address

185
00:07:15,020 --> 00:07:17,420
of the secure monitor because that would

186
00:07:17,420 --> 00:07:19,610
violate the security model so in order

187
00:07:19,610 --> 00:07:21,860
to reinitialize the CPU after it was

188
00:07:21,860 --> 00:07:25,280
completely off those parts that belong

189
00:07:25,280 --> 00:07:26,930
to the secure monitor also have to be

190
00:07:26,930 --> 00:07:29,030
reinitialized by the secure monitor and

191
00:07:29,030 --> 00:07:32,450
that's why every CPU on often on cycle

192
00:07:32,450 --> 00:07:33,560
essentially has to go all the way

193
00:07:33,560 --> 00:07:35,150
through the secure monitor and back down

194
00:07:35,150 --> 00:07:39,020
to the kernel and i'm has defined an

195
00:07:39,020 --> 00:07:40,820
interface a standardized interface for

196
00:07:40,820 --> 00:07:42,710
this called PS CI power state

197
00:07:42,710 --> 00:07:45,680
coordination interface which builds upon

198
00:07:45,680 --> 00:07:47,960
these secure monitor cards which are

199
00:07:47,960 --> 00:07:50,270
essentially like system calls just going

200
00:07:50,270 --> 00:07:52,040
to the secure monitor exception level

201
00:07:52,040 --> 00:07:56,630
and now you could ask so one one

202
00:07:56,630 --> 00:07:58,610
interesting thing is that this trust

203
00:07:58,610 --> 00:08:00,440
zone architecture already existed on our

204
00:08:00,440 --> 00:08:03,110
32 it was sort of bolted on and some of

205
00:08:03,110 --> 00:08:05,720
the later stages of the integrations of

206
00:08:05,720 --> 00:08:07,790
the architecture but you could also have

207
00:08:07,790 --> 00:08:09,290
it there and you will already have the

208
00:08:09,290 --> 00:08:11,270
same problems there but the thing is

209
00:08:11,270 --> 00:08:16,820
since this evolved alongside Linux Linux

210
00:08:16,820 --> 00:08:18,680
always supported systems that just

211
00:08:18,680 --> 00:08:20,780
didn't choose to use it and in coreboot

212
00:08:20,780 --> 00:08:22,700
we just never really had a need for a

213
00:08:22,700 --> 00:08:24,590
secure s or secure applications and

214
00:08:24,590 --> 00:08:26,810
that's why we just ignored it and used

215
00:08:26,810 --> 00:08:29,510
Linux ability to work without that but

216
00:08:29,510 --> 00:08:32,000
for arm 64 Linux essentially decided to

217
00:08:32,000 --> 00:08:34,370
have a clean break and now they say all

218
00:08:34,370 --> 00:08:36,320
the systems are going to have this trust

219
00:08:36,320 --> 00:08:38,510
on stuff anyway so we can just rely on

220
00:08:38,510 --> 00:08:40,070
it being there and we don't need to

221
00:08:40,070 --> 00:08:42,620
implement all this CPU power management

222
00:08:42,620 --> 00:08:45,500
ourselves anymore so the real reason why

223
00:08:45,500 --> 00:08:48,650
arm 64 devices need to provide this paci

224
00:08:48,650 --> 00:08:51,050
stuff now is essentially because Linux

225
00:08:51,050 --> 00:08:52,670
just got lazy and they just decided they

226
00:08:52,670 --> 00:08:54,050
don't want to implement the CPU power

227
00:08:54,050 --> 00:08:54,880
management them

228
00:08:54,880 --> 00:08:57,190
anymore so now we got to give this to

229
00:08:57,190 --> 00:08:59,710
them in order to us a full Linux

230
00:08:59,710 --> 00:09:01,060
platform even if we don't want to use

231
00:09:01,060 --> 00:09:04,990
the secure part now we could implement

232
00:09:04,990 --> 00:09:06,880
all of this ourselves and coreboot but

233
00:09:06,880 --> 00:09:08,680
before we do all that's worth that work

234
00:09:08,680 --> 00:09:10,600
let's maybe a look around to see what

235
00:09:10,600 --> 00:09:13,090
other options they are so what is this

236
00:09:13,090 --> 00:09:15,070
trusted firmware thing anyway for those

237
00:09:15,070 --> 00:09:16,330
of you who've been in the previous talk

238
00:09:16,330 --> 00:09:19,120
already most of this is the same it's a

239
00:09:19,120 --> 00:09:20,530
full firmware stack it's sort of a

240
00:09:20,530 --> 00:09:22,450
reference implementation by arm for the

241
00:09:22,450 --> 00:09:24,610
all the firmware you need both booting

242
00:09:24,610 --> 00:09:28,810
and runtime firmware and if we look from

243
00:09:28,810 --> 00:09:31,120
the coreboot point of view go boot is

244
00:09:31,120 --> 00:09:32,650
already the boot firmware essentially so

245
00:09:32,650 --> 00:09:33,910
we don't need that part but we are

246
00:09:33,910 --> 00:09:35,440
really interested in this runtime part

247
00:09:35,440 --> 00:09:37,810
and thankfully trusted Fermi has already

248
00:09:37,810 --> 00:09:39,730
split out into these separate stages and

249
00:09:39,730 --> 00:09:42,400
the one called bl3 one is the one that

250
00:09:42,400 --> 00:09:44,020
really interests us because that is the

251
00:09:44,020 --> 00:09:46,270
part where all this one-time power

252
00:09:46,270 --> 00:09:47,890
management stuff is sauce so that is the

253
00:09:47,890 --> 00:09:49,270
secure monitor that needs to stay

254
00:09:49,270 --> 00:09:52,330
resident across the whole lifetime of

255
00:09:52,330 --> 00:09:55,840
the system and if we compared with what

256
00:09:55,840 --> 00:09:57,790
coreboot already has it has a bunch of

257
00:09:57,790 --> 00:09:59,320
these nice features that kobu

258
00:09:59,320 --> 00:10:00,910
traditionally didn't provide for example

259
00:10:00,910 --> 00:10:03,610
right now on core boot in the arm

260
00:10:03,610 --> 00:10:05,170
architectures we have no multi

261
00:10:05,170 --> 00:10:06,730
processing support at all we just use

262
00:10:06,730 --> 00:10:08,380
the one CPU core we boot with and do

263
00:10:08,380 --> 00:10:09,940
everything with that which makes it

264
00:10:09,940 --> 00:10:11,290
really nice and easy for us but of

265
00:10:11,290 --> 00:10:13,300
course if you want to provide these

266
00:10:13,300 --> 00:10:15,610
services that turns CPUs off and on you

267
00:10:15,610 --> 00:10:17,170
need to do some multi processing you

268
00:10:17,170 --> 00:10:19,600
need to handle coherency and mutex thing

269
00:10:19,600 --> 00:10:22,570
and all that sort of stuff it also has a

270
00:10:22,570 --> 00:10:24,550
lot of nice CPU core support so for

271
00:10:24,550 --> 00:10:27,490
every CPU core that our releases a53 a

272
00:10:27,490 --> 00:10:29,110
fifty seven eight seventy whatever

273
00:10:29,110 --> 00:10:32,170
they're called all of these have a lot

274
00:10:32,170 --> 00:10:34,000
of their own little quirks and they have

275
00:10:34,000 --> 00:10:35,440
the little Radha's that you need to

276
00:10:35,440 --> 00:10:37,720
support so it's really nice to have a

277
00:10:37,720 --> 00:10:40,270
code base where the CPU vendor itself

278
00:10:40,270 --> 00:10:42,220
already programmed all of that stuff so

279
00:10:42,220 --> 00:10:43,750
that you can just use it for them and

280
00:10:43,750 --> 00:10:45,820
you don't have to keep up with all the

281
00:10:45,820 --> 00:10:47,940
new you are as they come out essentially

282
00:10:47,940 --> 00:10:50,830
actually more than once on one of our

283
00:10:50,830 --> 00:10:52,600
existing arm systems I've just pulled it

284
00:10:52,600 --> 00:10:54,220
up a new version of trusted firmware and

285
00:10:54,220 --> 00:10:55,840
then it told me and some lock message

286
00:10:55,840 --> 00:10:57,940
hey there's this new era I found that

287
00:10:57,940 --> 00:11:00,580
your CPU is susceptible to so it's kind

288
00:11:00,580 --> 00:11:02,290
of nice to get this thing from the CPU

289
00:11:02,290 --> 00:11:03,580
vendors who know what they're doing and

290
00:11:03,580 --> 00:11:06,839
don't have to do it yourself

291
00:11:07,170 --> 00:11:09,420
if we compare this trusted firmware

292
00:11:09,420 --> 00:11:12,029
architecture with coreboot more closely

293
00:11:12,029 --> 00:11:14,339
we can see that it's matching up pretty

294
00:11:14,339 --> 00:11:16,320
well so the Biel one and be a two part

295
00:11:16,320 --> 00:11:18,329
are the pure boot firmware part of

296
00:11:18,329 --> 00:11:20,250
trusted firmware which is essentially

297
00:11:20,250 --> 00:11:22,079
equivalent to the three stages of Co

298
00:11:22,079 --> 00:11:26,010
boot that we know and then the bier 3 2

299
00:11:26,010 --> 00:11:28,019
and B 3 are actually not part of trusted

300
00:11:28,019 --> 00:11:30,089
formats just names trusted firm a gives

301
00:11:30,089 --> 00:11:31,589
to the other stuff that it loads and

302
00:11:31,589 --> 00:11:33,390
it's therefore equivalent to the

303
00:11:33,390 --> 00:11:35,220
coreboot payload which is also not part

304
00:11:35,220 --> 00:11:37,380
of core wood but it's a bootloader that

305
00:11:37,380 --> 00:11:39,000
is one after core boot is finished

306
00:11:39,000 --> 00:11:41,550
essentially so if we want a secure

307
00:11:41,550 --> 00:11:43,649
monitor encore boot we really don't need

308
00:11:43,649 --> 00:11:44,910
to care about all this other stuff we

309
00:11:44,910 --> 00:11:46,980
can throw all that way all we want is

310
00:11:46,980 --> 00:11:48,360
the secure monitor pod it would be

311
00:11:48,360 --> 00:11:50,130
really nice if we could just yank it out

312
00:11:50,130 --> 00:11:51,660
of there and smash it and over here

313
00:11:51,660 --> 00:11:54,480
which is essentially exactly what we did

314
00:11:54,480 --> 00:11:59,100
so we integrate trusted firmware as a

315
00:11:59,100 --> 00:12:01,019
good sap module into core boot so when

316
00:12:01,019 --> 00:12:02,459
you check out the core boots or you

317
00:12:02,459 --> 00:12:03,930
automatically have the trusted from

318
00:12:03,930 --> 00:12:05,250
Essos through there as well and can

319
00:12:05,250 --> 00:12:07,769
develop in it and when you build core

320
00:12:07,769 --> 00:12:10,649
boot it also builds trusted firmware and

321
00:12:10,649 --> 00:12:12,300
then picks the right part that B if we

322
00:12:12,300 --> 00:12:14,100
run out of it and integrates it into

323
00:12:14,100 --> 00:12:15,779
core wood at the right place so it all

324
00:12:15,779 --> 00:12:19,199
works out pretty nicely and if you're

325
00:12:19,199 --> 00:12:20,760
curious about the details of how this is

326
00:12:20,760 --> 00:12:22,640
implemented in Co boot

327
00:12:22,640 --> 00:12:24,810
the nice part of your core wood is that

328
00:12:24,810 --> 00:12:26,430
most of it is architecture independent

329
00:12:26,430 --> 00:12:28,800
right so all this logic about figuring

330
00:12:28,800 --> 00:12:30,449
out for example where this payload is

331
00:12:30,449 --> 00:12:32,300
and how to load it and put it in place

332
00:12:32,300 --> 00:12:35,040
that's all independent of the

333
00:12:35,040 --> 00:12:36,180
architecture and we don't need to touch

334
00:12:36,180 --> 00:12:38,040
that the only thing we attaching is

335
00:12:38,040 --> 00:12:39,510
really the very last part of the RAM

336
00:12:39,510 --> 00:12:41,399
stage we had jumps to the payload that's

337
00:12:41,399 --> 00:12:43,170
an architecture specific callback and

338
00:12:43,170 --> 00:12:45,029
all we do for trusted firmware there's

339
00:12:45,029 --> 00:12:46,740
essentially we're saying if we're

340
00:12:46,740 --> 00:12:48,899
running clustered firmware then instead

341
00:12:48,899 --> 00:12:50,850
of jumping to the payload wait a second

342
00:12:50,850 --> 00:12:52,440
let's load this other thing over here

343
00:12:52,440 --> 00:12:54,690
first and run it and then we pass

344
00:12:54,690 --> 00:12:56,339
trusted firmware the information of how

345
00:12:56,339 --> 00:12:58,320
to jump to the payload and the payload

346
00:12:58,320 --> 00:12:59,930
has already noted so the nice thing is

347
00:12:59,930 --> 00:13:01,949
trusted form it doesn't really need to

348
00:13:01,949 --> 00:13:03,390
know anything about how to access the

349
00:13:03,390 --> 00:13:04,649
flash or something like that in these

350
00:13:04,649 --> 00:13:07,140
architectures the pain like the next

351
00:13:07,140 --> 00:13:08,730
stage is already loaded and we just tell

352
00:13:08,730 --> 00:13:10,500
it how to move on after it's done its

353
00:13:10,500 --> 00:13:14,490
thing essentially this is a quick

354
00:13:14,490 --> 00:13:17,170
overview about how the

355
00:13:17,170 --> 00:13:19,000
trusted for me repositories laid out so

356
00:13:19,000 --> 00:13:20,320
my goal here is essentially to give you

357
00:13:20,320 --> 00:13:22,240
a rough idea of where to look if you

358
00:13:22,240 --> 00:13:25,570
have to implement your own SOC for like

359
00:13:25,570 --> 00:13:26,769
if you're implementing in SOC in

360
00:13:26,769 --> 00:13:28,450
coreboot and want the trusted firmware

361
00:13:28,450 --> 00:13:30,310
support to get it working and I'm 64

362
00:13:30,310 --> 00:13:34,360
this is just a small excerpt of the

363
00:13:34,360 --> 00:13:35,610
directories there are a lot of these

364
00:13:35,610 --> 00:13:37,930
like I left the ones out that you don't

365
00:13:37,930 --> 00:13:39,070
need to care about essentially if you

366
00:13:39,070 --> 00:13:40,959
only care about core boots so next to

367
00:13:40,959 --> 00:13:42,880
the bf3 one directory there's also be a

368
00:13:42,880 --> 00:13:44,649
two and a BL one you can just ignore

369
00:13:44,649 --> 00:13:46,089
those because we are not using those

370
00:13:46,089 --> 00:13:47,829
there's a lot of really good

371
00:13:47,829 --> 00:13:50,139
documentation so if you're trying to

372
00:13:50,139 --> 00:13:51,810
work on trusted firmware my

373
00:13:51,810 --> 00:13:53,620
recommendations we need to look at those

374
00:13:53,620 --> 00:13:55,500
because they are great especially this

375
00:13:55,500 --> 00:13:57,699
porting guide is essentially your

376
00:13:57,699 --> 00:14:02,139
one-stop one shop stop for implementing

377
00:14:02,139 --> 00:14:03,639
a new platform it tells you all the

378
00:14:03,639 --> 00:14:05,110
macros you need to define all the

379
00:14:05,110 --> 00:14:06,550
functions you need to implement and so

380
00:14:06,550 --> 00:14:09,610
on if you're looking for drivers they

381
00:14:09,610 --> 00:14:12,820
are all sorted by vendor so if you're

382
00:14:12,820 --> 00:14:13,959
looking for the generic interrupt

383
00:14:13,959 --> 00:14:15,430
controller for example that most of the

384
00:14:15,430 --> 00:14:17,500
C's use that is under arm if you're

385
00:14:17,500 --> 00:14:19,810
looking for a standard 16 550 UART which

386
00:14:19,810 --> 00:14:22,029
most Associates used that is under Ti in

387
00:14:22,029 --> 00:14:24,850
this case but most of the drivers that

388
00:14:24,850 --> 00:14:27,430
cannot be reused between a sociis are

389
00:14:27,430 --> 00:14:28,990
just in the platform part over here so

390
00:14:28,990 --> 00:14:31,810
actually a lot of the like the the

391
00:14:31,810 --> 00:14:33,220
framework is pretty lean and a lot of

392
00:14:33,220 --> 00:14:34,720
the stuff is just implemented in the

393
00:14:34,720 --> 00:14:36,339
platform and every platform does it

394
00:14:36,339 --> 00:14:38,649
however things it wants to one of the

395
00:14:38,649 --> 00:14:42,070
few things that you still have generic

396
00:14:42,070 --> 00:14:44,019
for all platforms to use the CPU stuff

397
00:14:44,019 --> 00:14:45,670
is pretty great so as I said they have

398
00:14:45,670 --> 00:14:47,890
all the CPUs already implemented and you

399
00:14:47,890 --> 00:14:49,660
essentially just need to add the right

400
00:14:49,660 --> 00:14:52,089
CPUs that your SOC has and the makefile

401
00:14:52,089 --> 00:14:53,800
and then at builds them and then it can

402
00:14:53,800 --> 00:14:55,810
automatically detect which CPU is which

403
00:14:55,810 --> 00:14:58,000
so when it brings up a CPU it's the

404
00:14:58,000 --> 00:15:00,160
identification register and searches for

405
00:15:00,160 --> 00:15:02,140
all the CPUs you compiled and which one

406
00:15:02,140 --> 00:15:04,000
this is and which code to use for that

407
00:15:04,000 --> 00:15:08,170
and as I said in the platform first of

408
00:15:08,170 --> 00:15:09,670
all there's a common platform directory

409
00:15:09,670 --> 00:15:12,010
so there's a lot of call backs for

410
00:15:12,010 --> 00:15:14,139
things which the platform can change if

411
00:15:14,139 --> 00:15:16,120
it wants to but usually most platforms

412
00:15:16,120 --> 00:15:17,589
just want to do the one thing that makes

413
00:15:17,589 --> 00:15:19,540
sense to most of them so there's a bunch

414
00:15:19,540 --> 00:15:20,920
of stuff implemented in common that you

415
00:15:20,920 --> 00:15:22,209
can just link in because it will

416
00:15:22,209 --> 00:15:25,269
probably work for you and then every

417
00:15:25,269 --> 00:15:26,709
platform does its own thing there's

418
00:15:26,709 --> 00:15:29,470
usually a plaid setup thing that is the

419
00:15:29,470 --> 00:15:30,970
first thing that runs during boot

420
00:15:30,970 --> 00:15:32,889
that's all the boot initialization there

421
00:15:32,889 --> 00:15:34,720
is a PM thing usually that implements

422
00:15:34,720 --> 00:15:38,889
those pesky callbacks and a lot of

423
00:15:38,889 --> 00:15:40,930
vendors sort of factor out some of the

424
00:15:40,930 --> 00:15:42,579
common stuff and then the per se stuff

425
00:15:42,579 --> 00:15:45,519
and in the end you each platform has to

426
00:15:45,519 --> 00:15:46,839
make further defines all it does

427
00:15:46,839 --> 00:15:50,230
essentially so there's no there's no

428
00:15:50,230 --> 00:15:52,269
complicated configuration framework here

429
00:15:52,269 --> 00:15:54,009
it's not using K configure anything all

430
00:15:54,009 --> 00:15:55,720
the compile time configuration options

431
00:15:55,720 --> 00:15:57,759
you have are just options in the make

432
00:15:57,759 --> 00:15:59,709
file and then essentially which drivers

433
00:15:59,709 --> 00:16:02,920
you link in then the make file so if you

434
00:16:02,920 --> 00:16:04,509
want to support a new platform for

435
00:16:04,509 --> 00:16:06,069
coreboot the one thing you really need

436
00:16:06,069 --> 00:16:08,139
to implement it's those pesky stuff so

437
00:16:08,139 --> 00:16:12,670
let's look into that for a bit and the

438
00:16:12,670 --> 00:16:13,930
main message here is essentially it's

439
00:16:13,930 --> 00:16:15,639
very flexible you can do whatever you

440
00:16:15,639 --> 00:16:18,759
want whatever is best for you so see so

441
00:16:18,759 --> 00:16:22,029
each of the things that you can turn on

442
00:16:22,029 --> 00:16:23,740
and off essentially for one time power

443
00:16:23,740 --> 00:16:27,310
management you have these nodes at the

444
00:16:27,310 --> 00:16:29,470
bottom which are in a here a key of

445
00:16:29,470 --> 00:16:31,449
power levels and then the bottom level

446
00:16:31,449 --> 00:16:33,189
you always have the CPU or in case of

447
00:16:33,189 --> 00:16:34,629
multi-threading that will be the threads

448
00:16:34,629 --> 00:16:36,490
actually and then you can have as many

449
00:16:36,490 --> 00:16:38,079
layers above that as you want you don't

450
00:16:38,079 --> 00:16:39,759
need to have any layers but most

451
00:16:39,759 --> 00:16:43,120
associate the CPUs in some sort of

452
00:16:43,120 --> 00:16:44,800
cluster and when you turn off all the

453
00:16:44,800 --> 00:16:46,420
CPU in a cluster then you can turn off

454
00:16:46,420 --> 00:16:48,939
some extra stuff for the cluster so this

455
00:16:48,939 --> 00:16:51,339
power level stuff allows you to build

456
00:16:51,339 --> 00:16:53,500
the topology of your SOC in the

457
00:16:53,500 --> 00:16:55,449
framework essentially and you you just

458
00:16:55,449 --> 00:16:57,100
tell it which maximum power level you

459
00:16:57,100 --> 00:16:59,170
want to have and then it handles all the

460
00:16:59,170 --> 00:17:01,240
stuff of calling the white functions for

461
00:17:01,240 --> 00:17:02,529
each power level to turn them on and off

462
00:17:02,529 --> 00:17:05,740
for example and orthogonal to that you

463
00:17:05,740 --> 00:17:07,390
also have power States so there's not

464
00:17:07,390 --> 00:17:09,579
just on and off there can be as many as

465
00:17:09,579 --> 00:17:11,919
you want in between to have a trade-off

466
00:17:11,919 --> 00:17:15,640
between exit latency usually and power

467
00:17:15,640 --> 00:17:18,429
draw so rather than just turning it off

468
00:17:18,429 --> 00:17:20,289
you can maybe put it into a retention

469
00:17:20,289 --> 00:17:21,970
state that it can wake up from quickly

470
00:17:21,970 --> 00:17:23,559
and there again you can have as many

471
00:17:23,559 --> 00:17:25,030
states as you want you can define all of

472
00:17:25,030 --> 00:17:27,880
that inside your platform the only thing

473
00:17:27,880 --> 00:17:29,140
you tell the outside framework is

474
00:17:29,140 --> 00:17:31,030
whether this is an off state or

475
00:17:31,030 --> 00:17:32,950
retention state the difference there is

476
00:17:32,950 --> 00:17:35,789
that in the off state it loses all its

477
00:17:35,789 --> 00:17:38,200
state and you have to like the framework

478
00:17:38,200 --> 00:17:39,760
will we initialize all of the state for

479
00:17:39,760 --> 00:17:40,870
you when it comes back up and the

480
00:17:40,870 --> 00:17:42,790
retention state it's expected to keep

481
00:17:42,790 --> 00:17:45,400
and then the only thing you really need

482
00:17:45,400 --> 00:17:47,620
to implement once you've decided how the

483
00:17:47,620 --> 00:17:50,470
Serie key looks is a structure full of

484
00:17:50,470 --> 00:17:52,180
function pointers essentially which with

485
00:17:52,180 --> 00:17:53,830
all the callbacks for how do I turn off

486
00:17:53,830 --> 00:17:56,320
the CPU or any of these notes it

487
00:17:56,320 --> 00:17:58,180
actually not just CPUs how do I turn it

488
00:17:58,180 --> 00:18:00,730
back on what do I do with it after it's

489
00:18:00,730 --> 00:18:01,930
turned back on so that it's this

490
00:18:01,930 --> 00:18:04,270
finished car back down here and there's

491
00:18:04,270 --> 00:18:06,280
a bunch more but the general gist of it

492
00:18:06,280 --> 00:18:08,320
is this that you just have this a bunch

493
00:18:08,320 --> 00:18:09,670
of functions you need to implement and

494
00:18:09,670 --> 00:18:11,020
then the framework now so to call you

495
00:18:11,020 --> 00:18:14,650
correctly so that's really all you need

496
00:18:14,650 --> 00:18:17,950
for the pesky stuff and once again the

497
00:18:17,950 --> 00:18:20,140
documents are really great to look into

498
00:18:20,140 --> 00:18:22,360
how this works and specifics and also of

499
00:18:22,360 --> 00:18:24,550
course just look at existing platforms

500
00:18:24,550 --> 00:18:26,290
my favorite is always the watcher one

501
00:18:26,290 --> 00:18:27,430
because there's the C's tend to be

502
00:18:27,430 --> 00:18:28,900
really simple they don't have any of the

503
00:18:28,900 --> 00:18:31,750
weird books and crannies that some of

504
00:18:31,750 --> 00:18:34,120
the other more complicated LC safe so

505
00:18:34,120 --> 00:18:37,480
they usually make a good example once

506
00:18:37,480 --> 00:18:39,100
you have that you essentially done

507
00:18:39,100 --> 00:18:40,600
supporting Cawood but you can do some

508
00:18:40,600 --> 00:18:42,430
more stuff if you want to so one of the

509
00:18:42,430 --> 00:18:43,720
common things you might want to do is

510
00:18:43,720 --> 00:18:46,510
customize some C's of course this pesky

511
00:18:46,510 --> 00:18:48,610
also uses SMC s-- and all of those are

512
00:18:48,610 --> 00:18:50,080
already implemented in the framework so

513
00:18:50,080 --> 00:18:51,250
you don't need to worry about those but

514
00:18:51,250 --> 00:18:53,250
you can add your own if you want to

515
00:18:53,250 --> 00:18:56,050
common thing that we need find that we

516
00:18:56,050 --> 00:18:58,930
need is one time PDR frequency scaling

517
00:18:58,930 --> 00:19:00,400
for example because if you do anything

518
00:19:00,400 --> 00:19:03,010
that involves memories and memory is

519
00:19:03,010 --> 00:19:04,480
used by the whole platform usually it

520
00:19:04,480 --> 00:19:06,010
needs to go through the highs privilege

521
00:19:06,010 --> 00:19:08,740
level to allow that and it's also pretty

522
00:19:08,740 --> 00:19:10,900
simple they essentially have a macro

523
00:19:10,900 --> 00:19:12,730
that you can use to define a handler for

524
00:19:12,730 --> 00:19:15,090
a given range of SMC function IDs

525
00:19:15,090 --> 00:19:16,870
there's actually this whole big

526
00:19:16,870 --> 00:19:18,550
specification from arm that tells you

527
00:19:18,550 --> 00:19:21,370
which SMC function ID ranges are allowed

528
00:19:21,370 --> 00:19:24,370
to be used by whom usually the one you

529
00:19:24,370 --> 00:19:26,140
want to use is called es IP range

530
00:19:26,140 --> 00:19:28,090
I always forget what it stands for but

531
00:19:28,090 --> 00:19:29,920
it's essentially the SOC vendor range so

532
00:19:29,920 --> 00:19:31,960
if you implementing an SOC port that's

533
00:19:31,960 --> 00:19:35,680
usually the one you want to use an ass

534
00:19:35,680 --> 00:19:38,110
but not least we have some fun core boot

535
00:19:38,110 --> 00:19:42,130
support in there now one of the problems

536
00:19:42,130 --> 00:19:43,960
with integrating core boot is that

537
00:19:43,960 --> 00:19:45,880
there's not yet a great way to pass

538
00:19:45,880 --> 00:19:48,580
parameters in a generic way from core

539
00:19:48,580 --> 00:19:50,620
boot into trusted firmware this is

540
00:19:50,620 --> 00:19:51,970
something that I think the trusted Firma

541
00:19:51,970 --> 00:19:54,490
team is interested in making better and

542
00:19:54,490 --> 00:19:56,679
future but right now all that they have

543
00:19:56,679 --> 00:20:00,760
is essentially you can have one pointer

544
00:20:00,760 --> 00:20:02,830
of platform-specific information and

545
00:20:02,830 --> 00:20:04,179
then the platform has to figure out how

546
00:20:04,179 --> 00:20:08,020
to deal with that so when you the first

547
00:20:08,020 --> 00:20:09,760
piece of platform code that's called

548
00:20:09,760 --> 00:20:11,980
when you are in class system is usually

549
00:20:11,980 --> 00:20:13,000
the function over there

550
00:20:13,000 --> 00:20:15,790
which gets that one pointer and then you

551
00:20:15,790 --> 00:20:17,050
have to figure out what to do with that

552
00:20:17,050 --> 00:20:19,480
usually we find that we have to pass a

553
00:20:19,480 --> 00:20:21,160
bunch of things from core boot into

554
00:20:21,160 --> 00:20:23,230
trusted firmware so what we do is we

555
00:20:23,230 --> 00:20:24,670
build a sort of primitive linked list

556
00:20:24,670 --> 00:20:28,150
with that and then pause it when like at

557
00:20:28,150 --> 00:20:29,500
the very first thing and trusted

558
00:20:29,500 --> 00:20:32,950
firmware and one of the things you

559
00:20:32,950 --> 00:20:34,540
should pass is the Kabu table base

560
00:20:34,540 --> 00:20:36,760
address because then you can use this

561
00:20:36,760 --> 00:20:38,530
Kabu table setup function which we have

562
00:20:38,530 --> 00:20:40,059
interested firmware which gives you all

563
00:20:40,059 --> 00:20:42,970
that coreboot the generic goblet support

564
00:20:42,970 --> 00:20:44,830
that we implemented but just right now

565
00:20:44,830 --> 00:20:47,200
mostly console support so for example

566
00:20:47,200 --> 00:20:49,210
after that you have access to the

567
00:20:49,210 --> 00:20:52,480
console the Europe information over

568
00:20:52,480 --> 00:20:54,220
there so you don't have to hard code the

569
00:20:54,220 --> 00:20:55,960
US base address anymore you can use the

570
00:20:55,960 --> 00:20:58,380
one from coreboot and more importantly

571
00:20:58,380 --> 00:21:00,670
you essentially take over core boots

572
00:21:00,670 --> 00:21:01,900
configuration with that so if you

573
00:21:01,900 --> 00:21:03,670
disabled the UART and Kobuk a config

574
00:21:03,670 --> 00:21:04,960
then it would just not pass that and

575
00:21:04,960 --> 00:21:06,220
then trust it for them I will also not

576
00:21:06,220 --> 00:21:08,110
use it which is nicer than having to

577
00:21:08,110 --> 00:21:11,170
disable stuff in every every different

578
00:21:11,170 --> 00:21:14,260
repository your firmware is made of the

579
00:21:14,260 --> 00:21:15,340
other nice thing you get with this

580
00:21:15,340 --> 00:21:17,260
automatically is CB mem console supports

581
00:21:17,260 --> 00:21:19,090
or as soon as you like if you have a

582
00:21:19,090 --> 00:21:21,130
CBMM console and coreboot then

583
00:21:21,130 --> 00:21:22,900
information about that is fast in the

584
00:21:22,900 --> 00:21:24,429
Kabu table and then trusted forever

585
00:21:24,429 --> 00:21:26,410
automatically where just a console

586
00:21:26,410 --> 00:21:28,090
driver for that and then once you boot

587
00:21:28,090 --> 00:21:31,330
into user land you can dump the CBMM

588
00:21:31,330 --> 00:21:32,770
console and see all the trusted firmware

589
00:21:32,770 --> 00:21:36,450
logs right after the coreboot logs I

590
00:21:36,450 --> 00:21:39,250
think this is pretty much all I wanted

591
00:21:39,250 --> 00:21:40,720
to talk about about the basic trusted

592
00:21:40,720 --> 00:21:44,500
from architecture the one thing I want

593
00:21:44,500 --> 00:21:46,330
to leave you with this a little anecdote

594
00:21:46,330 --> 00:21:50,470
about some of the practical problems we

595
00:21:50,470 --> 00:21:51,820
had when implementing one of these

596
00:21:51,820 --> 00:21:54,100
seasoned trusted form and this is about

597
00:21:54,100 --> 00:21:57,730
the rockchip $33.99 and well we

598
00:21:57,730 --> 00:21:59,020
essentially had some trouble fitting

599
00:21:59,020 --> 00:22:01,540
everything there this story starts very

600
00:22:01,540 --> 00:22:04,169
simple with bringing up the chip and

601
00:22:04,169 --> 00:22:06,520
trying to get suspend resume support

602
00:22:06,520 --> 00:22:07,590
working so

603
00:22:07,590 --> 00:22:09,480
the whole system suspend resume also

604
00:22:09,480 --> 00:22:11,279
needs to go through the secured monitor

605
00:22:11,279 --> 00:22:12,690
because the the turns of the whole

606
00:22:12,690 --> 00:22:14,009
system so the highest privileged never

607
00:22:14,009 --> 00:22:17,639
needs to know about it and you usually

608
00:22:17,639 --> 00:22:19,470
turn out like the ddr controller usually

609
00:22:19,470 --> 00:22:21,149
uses a state doing that so you have to

610
00:22:21,149 --> 00:22:22,499
reinitialize it somehow when you come

611
00:22:22,499 --> 00:22:23,909
back up and of course the code for that

612
00:22:23,909 --> 00:22:27,149
can't be and um so thankfully we are

613
00:22:27,149 --> 00:22:28,590
nama so see we usually have a bunch of

614
00:22:28,590 --> 00:22:34,080
som so we can put it in there and we

615
00:22:34,080 --> 00:22:35,340
have quite a lot of SRAM on this

616
00:22:35,340 --> 00:22:37,730
platform so that's pretty easy to fit

617
00:22:37,730 --> 00:22:41,149
and then we had some other issues about

618
00:22:41,149 --> 00:22:44,369
we want to do some ddr frequency scaling

619
00:22:44,369 --> 00:22:46,889
at one time depending on the SOC this is

620
00:22:46,889 --> 00:22:48,509
sometimes pretty easy and sometimes a

621
00:22:48,509 --> 00:22:50,249
real chore and this one it was

622
00:22:50,249 --> 00:22:51,899
thankfully not that hard because we have

623
00:22:51,899 --> 00:22:54,299
this little separate microcontroller in

624
00:22:54,299 --> 00:22:56,519
the SOC like a cortex and zero

625
00:22:56,519 --> 00:22:58,139
essentially on the side of the normal

626
00:22:58,139 --> 00:23:00,929
CPUs which had the ability to just stop

627
00:23:00,929 --> 00:23:03,690
the CPUs in place we train ddr2 a

628
00:23:03,690 --> 00:23:05,009
different frequency and then kick them

629
00:23:05,009 --> 00:23:06,600
off again the main CPUs never really

630
00:23:06,600 --> 00:23:07,289
knew what hit them

631
00:23:07,289 --> 00:23:09,929
so this was pretty easy to implement but

632
00:23:09,929 --> 00:23:12,570
we still needed to put some code and

633
00:23:12,570 --> 00:23:14,610
like we needed to host that code for

634
00:23:14,610 --> 00:23:17,100
this M 0 in s time of course because TDR

635
00:23:17,100 --> 00:23:18,119
is inaccessible why we're changing

636
00:23:18,119 --> 00:23:21,779
frequencies and we had some more fun

637
00:23:21,779 --> 00:23:23,700
with trying to work around hardware back

638
00:23:23,700 --> 00:23:25,470
so this is a C at a particular thing

639
00:23:25,470 --> 00:23:28,619
where when it goes into system suspend

640
00:23:28,619 --> 00:23:30,419
and it gets a wake interrupt at just the

641
00:23:30,419 --> 00:23:32,580
right time like just after you turned

642
00:23:32,580 --> 00:23:34,289
off the main CPU then sometimes it

643
00:23:34,289 --> 00:23:36,539
wouldn't break up again so to work

644
00:23:36,539 --> 00:23:37,799
around that you essentially needed

645
00:23:37,799 --> 00:23:39,659
something to sit around and wait until

646
00:23:39,659 --> 00:23:42,389
after all the CPUs have been turned off

647
00:23:42,389 --> 00:23:43,769
and check for this condition and then

648
00:23:43,769 --> 00:23:45,929
cleared so here comes our and zero to

649
00:23:45,929 --> 00:23:47,279
the rescue again and we had to implement

650
00:23:47,279 --> 00:23:49,769
some code for that all of this still fit

651
00:23:49,769 --> 00:23:51,899
pretty nicely into som but then we had a

652
00:23:51,899 --> 00:23:53,190
great idea on how to save some more

653
00:23:53,190 --> 00:23:57,029
power wait this was very long to be

654
00:23:57,029 --> 00:23:59,999
which is essentially there was one more

655
00:23:59,999 --> 00:24:01,799
power rail we could turn off which

656
00:24:01,799 --> 00:24:04,740
powered most of the chip and turning it

657
00:24:04,740 --> 00:24:05,940
off would have saved us really a bunch

658
00:24:05,940 --> 00:24:08,220
of power unfortunately it also powered

659
00:24:08,220 --> 00:24:11,700
the SRAM so at that point we sort of

660
00:24:11,700 --> 00:24:12,929
have a problem because we can turn the

661
00:24:12,929 --> 00:24:14,340
system off but when we turn it back on

662
00:24:14,340 --> 00:24:17,309
we don't have anything to resume from so

663
00:24:17,309 --> 00:24:19,379
the one good thing we had was we have

664
00:24:19,379 --> 00:24:21,180
this little amount of p.m.

665
00:24:21,180 --> 00:24:23,480
you som which is sort of a separate

666
00:24:23,480 --> 00:24:26,040
amount of som that's implemented that's

667
00:24:26,040 --> 00:24:27,690
powered by a different power rail and

668
00:24:27,690 --> 00:24:29,730
would stay alive even if we turn this

669
00:24:29,730 --> 00:24:31,710
off but now we have to start fitting all

670
00:24:31,710 --> 00:24:33,330
of the stuff in there which is kind of

671
00:24:33,330 --> 00:24:36,810
awful the DDR and it stuffs the kind of

672
00:24:36,810 --> 00:24:39,510
it's one of the problems that we also

673
00:24:39,510 --> 00:24:41,760
have here's that the entry point of the

674
00:24:41,760 --> 00:24:44,010
CPU and comes back from resume you can

675
00:24:44,010 --> 00:24:46,050
essentially only give the SOC the top 60

676
00:24:46,050 --> 00:24:47,760
bit so it has to be 64 K lined

677
00:24:47,760 --> 00:24:50,490
thankfully the PMU som is 64 K line but

678
00:24:50,490 --> 00:24:51,720
it needs to sit at the very top for that

679
00:24:51,720 --> 00:24:54,690
and the M 0 code also needs to be 4 K

680
00:24:54,690 --> 00:24:57,030
line because that's how the M 0 works so

681
00:24:57,030 --> 00:24:59,520
first of all putting the whole M 0 code

682
00:24:59,520 --> 00:25:00,870
that we have right now in there doesn't

683
00:25:00,870 --> 00:25:04,470
fit at all there's no way so idea was

684
00:25:04,470 --> 00:25:06,420
rather than having 1 and 0 image and

685
00:25:06,420 --> 00:25:08,400
giving it an argument of which of the

686
00:25:08,400 --> 00:25:09,810
two functions it's supposed to do we

687
00:25:09,810 --> 00:25:12,000
could split it up and I have two m0

688
00:25:12,000 --> 00:25:15,300
images and then just always give the m0

689
00:25:15,300 --> 00:25:16,650
Base address for the one we want to use

690
00:25:16,650 --> 00:25:19,440
where we kick it off this sort of works

691
00:25:19,440 --> 00:25:22,140
but if you can see between these two it

692
00:25:22,140 --> 00:25:24,360
overlaps part of the DDR and it's stuff

693
00:25:24,360 --> 00:25:26,520
so it doesn't quite fit and it needs to

694
00:25:26,520 --> 00:25:27,690
be in the middle there because it needs

695
00:25:27,690 --> 00:25:29,250
to be 4k aligned so this also didn't

696
00:25:29,250 --> 00:25:32,940
quite work but then we realized the DD

697
00:25:32,940 --> 00:25:36,150
on it has to start at 64 K but after

698
00:25:36,150 --> 00:25:37,830
that it's really just normal code so we

699
00:25:37,830 --> 00:25:39,930
can really sort of rip it apart and

700
00:25:39,930 --> 00:25:42,450
sandwich it carefully around the m0 code

701
00:25:42,450 --> 00:25:48,060
and come on with a lot of you know

702
00:25:48,060 --> 00:25:51,570
juggling bits and counting instructions

703
00:25:51,570 --> 00:25:55,830
we managed to get this all in 8k you

704
00:25:55,830 --> 00:25:57,510
have one problem left if you do all this

705
00:25:57,510 --> 00:26:00,960
which is that since you lose som and s3

706
00:26:00,960 --> 00:26:03,030
of course you lose that dd a frequency

707
00:26:03,030 --> 00:26:05,700
scaling stuff so it would be not that

708
00:26:05,700 --> 00:26:08,340
great if DD a frequency scaling worked

709
00:26:08,340 --> 00:26:09,780
after you boot it but then once you

710
00:26:09,780 --> 00:26:11,430
suspend resume and once it doesn't work

711
00:26:11,430 --> 00:26:14,100
anymore so the ugly but obvious solution

712
00:26:14,100 --> 00:26:18,840
is to cash it in DRAM I think this thing

713
00:26:18,840 --> 00:26:22,860
is dying there and then just copy it

714
00:26:22,860 --> 00:26:26,370
back every time we resume essentially so

715
00:26:26,370 --> 00:26:27,960
if you want to look how this madness

716
00:26:27,960 --> 00:26:30,150
looks in the linker script I got it over

717
00:26:30,150 --> 00:26:32,030
here

718
00:26:32,030 --> 00:26:34,559
can we switch Switzer sighs manually

719
00:26:34,559 --> 00:26:36,559
Thanks

720
00:26:36,559 --> 00:26:39,840
so the ink pen stuff is essentially the

721
00:26:39,840 --> 00:26:42,179
m0 code so you see it needs to be 64k

722
00:26:42,179 --> 00:26:45,390
aligned and then even though the other

723
00:26:45,390 --> 00:26:47,460
stuff is the same program if we put the

724
00:26:47,460 --> 00:26:49,230
data section beyond that it just happens

725
00:26:49,230 --> 00:26:51,720
to magically work out and we just hoping

726
00:26:51,720 --> 00:26:53,730
that we never have a compiler change or

727
00:26:53,730 --> 00:26:54,929
anything that misses all of this up

728
00:26:54,929 --> 00:26:56,070
again because it's gonna be the most

729
00:26:56,070 --> 00:27:01,169
awful thing if you want to see some some

730
00:27:01,169 --> 00:27:04,500
details about how you do this sort of

731
00:27:04,500 --> 00:27:06,150
thing where you both the binary for a

732
00:27:06,150 --> 00:27:08,220
completely different chip inside the

733
00:27:08,220 --> 00:27:10,470
same software as the main like inside

734
00:27:10,470 --> 00:27:12,390
your main software package and Link it

735
00:27:12,390 --> 00:27:13,650
all together it's some more done like

736
00:27:13,650 --> 00:27:15,630
this so first of all like you

737
00:27:15,630 --> 00:27:17,340
essentially first pulled that m0 code

738
00:27:17,340 --> 00:27:19,620
completely separate into a strip binary

739
00:27:19,620 --> 00:27:21,690
and then you would define a makefile

740
00:27:21,690 --> 00:27:23,460
rule for the main software where that

741
00:27:23,460 --> 00:27:25,980
binary is another dependency for the

742
00:27:25,980 --> 00:27:29,039
port for one of the C files and you also

743
00:27:29,039 --> 00:27:31,669
pass the name of that binary and as a

744
00:27:31,669 --> 00:27:34,559
people source or macro and then you can

745
00:27:34,559 --> 00:27:36,720
use this reared assembly instruction

746
00:27:36,720 --> 00:27:38,130
called ink bin which essentially just

747
00:27:38,130 --> 00:27:40,140
helps the assembler to at this point

748
00:27:40,140 --> 00:27:42,150
include a whole nother file completely

749
00:27:42,150 --> 00:27:44,250
and then continue assembling and then

750
00:27:44,250 --> 00:27:45,929
you put a label on of it and then you

751
00:27:45,929 --> 00:27:48,620
can access it from seek out and tell the

752
00:27:48,620 --> 00:27:51,659
m0 base address register like just put

753
00:27:51,659 --> 00:27:53,370
put the address in there and then sort

754
00:27:53,370 --> 00:27:56,970
of run out and this is the m0 code we

755
00:27:56,970 --> 00:27:58,440
run on suspend and the end as you can

756
00:27:58,440 --> 00:27:59,730
see it's really simple and really stupid

757
00:27:59,730 --> 00:28:03,270
there's essentially this suspense state

758
00:28:03,270 --> 00:28:06,480
which keeps counting upwards as you go

759
00:28:06,480 --> 00:28:07,890
through the suspend and then again as

760
00:28:07,890 --> 00:28:09,510
you go through the resume later as you

761
00:28:09,510 --> 00:28:11,010
can see we had some other issues we also

762
00:28:11,010 --> 00:28:13,020
had to work upon in the end like I say

763
00:28:13,020 --> 00:28:14,400
keep testing more and more on the

764
00:28:14,400 --> 00:28:15,630
platform you keep finding more things

765
00:28:15,630 --> 00:28:17,970
and this is actually where the system is

766
00:28:17,970 --> 00:28:21,030
suspended in here so if you take one of

767
00:28:21,030 --> 00:28:22,799
these Chromebooks today and you close

768
00:28:22,799 --> 00:28:25,320
the lid then even though it's supposed

769
00:28:25,320 --> 00:28:27,240
to save power the whole time where the

770
00:28:27,240 --> 00:28:28,650
lid is closed you have this little code

771
00:28:28,650 --> 00:28:31,230
X and 0 was saying in a tight loop am i

772
00:28:31,230 --> 00:28:33,210
already resumed am I already resumed am

773
00:28:33,210 --> 00:28:35,309
I already resumed and it turns out that

774
00:28:35,309 --> 00:28:36,900
and zeros don't eat a lot of power and

775
00:28:36,900 --> 00:28:38,850
if you do that on a 32 kilohertz clock

776
00:28:38,850 --> 00:28:41,010
it's actually not as crazy as it sounds

777
00:28:41,010 --> 00:28:42,929
so just chill know how the sausage is

778
00:28:42,929 --> 00:28:45,020
made in that case

779
00:28:45,020 --> 00:28:47,670
yeah that's all I have so thanks for

780
00:28:47,670 --> 00:28:59,130
listening questions alright thanks so

781
00:28:59,130 --> 00:29:10,050
far ah questions why does the ddr3

782
00:29:10,050 --> 00:29:12,330
controller need to be reinitialized

783
00:29:12,330 --> 00:29:16,410
after a three resume why find sons can

784
00:29:16,410 --> 00:29:19,110
the hardware put that in self refresh

785
00:29:19,110 --> 00:29:22,770
and that boot it works basically right

786
00:29:22,770 --> 00:29:25,230
so this is not the DVR itself right so

787
00:29:25,230 --> 00:29:27,960
the ddr chip on the board has put into

788
00:29:27,960 --> 00:29:30,720
self refresh but the ddr controller on

789
00:29:30,720 --> 00:29:33,030
the SOC needs to know how to talk to the

790
00:29:33,030 --> 00:29:35,970
ddr and that part isn't maintained

791
00:29:35,970 --> 00:29:38,610
mostly to save power so we shut off most

792
00:29:38,610 --> 00:29:40,380
parts of the SOC when we go into a three

793
00:29:40,380 --> 00:29:41,910
and that's one of the parts we shut off

794
00:29:41,910 --> 00:29:44,790
so after the boot you need something to

795
00:29:44,790 --> 00:29:47,400
tell the ddr controller how the TDR chip

796
00:29:47,400 --> 00:29:50,370
like how many rows banks and columns and

797
00:29:50,370 --> 00:29:52,620
so on you have and to tell it to take

798
00:29:52,620 --> 00:29:54,420
the DDR out of self refresh and all that

799
00:29:54,420 --> 00:29:56,720
kind of code needs to live somewhere and

800
00:29:56,720 --> 00:30:02,760
second question why don't you do the

801
00:30:02,760 --> 00:30:05,820
initialization part like a normal boot

802
00:30:05,820 --> 00:30:09,300
in the like in coreboot on at x86 huh

803
00:30:09,300 --> 00:30:11,370
are you asking why we're not reading it

804
00:30:11,370 --> 00:30:14,850
from flash yes why why aren't you doing

805
00:30:14,850 --> 00:30:17,760
it dynamically from code that is in

806
00:30:17,760 --> 00:30:19,890
flash well you're necessarily saving

807
00:30:19,890 --> 00:30:23,640
that down flash but um you can do that

808
00:30:23,640 --> 00:30:26,220
it sort of depends on the SOC so this

809
00:30:26,220 --> 00:30:28,020
associ in particular I think was

810
00:30:28,020 --> 00:30:30,300
designed to resume from som so I'm not

811
00:30:30,300 --> 00:30:33,120
sure if starting the boot rom again from

812
00:30:33,120 --> 00:30:35,220
flash would even be possible the other

813
00:30:35,220 --> 00:30:37,260
reason you might not want that is it

814
00:30:37,260 --> 00:30:39,330
sort of depends on what how your system

815
00:30:39,330 --> 00:30:41,730
is designed our case this is a

816
00:30:41,730 --> 00:30:43,230
Chromebook so Chromebooks are always

817
00:30:43,230 --> 00:30:44,970
designed in a way to boot from a

818
00:30:44,970 --> 00:30:46,590
read-only partition and then do some

819
00:30:46,590 --> 00:30:48,960
crypto magic before we jump into the

820
00:30:48,960 --> 00:30:50,790
petition we can actually update on the

821
00:30:50,790 --> 00:30:54,450
flash and we found out in the past that

822
00:30:54,450 --> 00:30:57,270
tying the resume path to this read-only

823
00:30:57,270 --> 00:30:58,060
flash

824
00:30:58,060 --> 00:30:59,620
a very bad idea because that means that

825
00:30:59,620 --> 00:31:02,290
if you ever have a problem in your

826
00:31:02,290 --> 00:31:04,270
resume path in your early resume path

827
00:31:04,270 --> 00:31:06,400
you can't really fix it so resuming from

828
00:31:06,400 --> 00:31:07,990
som is very nice because then you can

829
00:31:07,990 --> 00:31:10,420
always update it and you're not bound to

830
00:31:10,420 --> 00:31:12,730
the stuff you have put on flash

831
00:31:12,730 --> 00:31:29,350
essentially questions go back to one of

832
00:31:29,350 --> 00:31:33,040
your earlier slides you've replaced the

833
00:31:33,040 --> 00:31:35,590
early stages of trusted firmware with Co

834
00:31:35,590 --> 00:31:39,420
boot code I'm not a trusted to fill my

835
00:31:39,420 --> 00:31:42,550
architecture expert but I sure would

836
00:31:42,550 --> 00:31:46,810
alarm those who are because the the

837
00:31:46,810 --> 00:31:49,300
whole root of trust derives from the

838
00:31:49,300 --> 00:31:51,240
early stages of the trusted firmware

839
00:31:51,240 --> 00:31:54,190
right I mean so it always depends on

840
00:31:54,190 --> 00:31:55,570
what you want to do with the system

841
00:31:55,570 --> 00:31:59,500
right so trusted firmware has many many

842
00:31:59,500 --> 00:32:01,450
things that does in many use cases um

843
00:32:01,450 --> 00:32:04,150
they do have a system of trusted boot

844
00:32:04,150 --> 00:32:06,160
where every stage verifies the next but

845
00:32:06,160 --> 00:32:07,510
of course you don't have to use that um

846
00:32:07,510 --> 00:32:10,450
in this case the goal was essentially to

847
00:32:10,450 --> 00:32:12,640
get coreboot working on am 64 and what

848
00:32:12,640 --> 00:32:14,710
we need it was a secure monitor so we

849
00:32:14,710 --> 00:32:16,300
just took the secure monitor that

850
00:32:16,300 --> 00:32:17,860
existed and don't really care about the

851
00:32:17,860 --> 00:32:21,070
other things if you want trusted boot Co

852
00:32:21,070 --> 00:32:23,080
boot has its own way of trusted boot

853
00:32:23,080 --> 00:32:26,350
which just derive from the way that

854
00:32:26,350 --> 00:32:27,790
Chrome OS it literally did it which is

855
00:32:27,790 --> 00:32:31,570
called verified boot reboot and they

856
00:32:31,570 --> 00:32:33,730
trusted the br3 one in this case as part

857
00:32:33,730 --> 00:32:35,080
of that so the way the cob would work

858
00:32:35,080 --> 00:32:37,570
way works is you you boot from a

859
00:32:37,570 --> 00:32:38,800
read-only partition of the flash you

860
00:32:38,800 --> 00:32:40,180
verify the readwrite partition of the

861
00:32:40,180 --> 00:32:42,130
flash and then you boot from there and

862
00:32:42,130 --> 00:32:43,960
trust it for me it's just one of the

863
00:32:43,960 --> 00:32:45,520
different components that are stored in

864
00:32:45,520 --> 00:32:47,530
the sweet white partition so we have our

865
00:32:47,530 --> 00:32:49,570
own trusted boot mechanism essentially

866
00:32:49,570 --> 00:32:50,890
and we're just using a component of

867
00:32:50,890 --> 00:32:53,790
trusted for man there

868
00:33:04,920 --> 00:33:09,480
so if you had like the ability to tell

869
00:33:09,480 --> 00:33:12,210
the sock guys here how to redesign their

870
00:33:12,210 --> 00:33:14,280
SRAM would you just say don't turn off

871
00:33:14,280 --> 00:33:16,050
the SRAM or did you like having the two

872
00:33:16,050 --> 00:33:19,110
partitions for para reasons or what's

873
00:33:19,110 --> 00:33:21,870
your feeling on that I'm not a power guy

874
00:33:21,870 --> 00:33:23,490
so I don't know how much sym itself

875
00:33:23,490 --> 00:33:25,200
actually takes I think in this case

876
00:33:25,200 --> 00:33:27,770
there was sort of a design problem of

877
00:33:27,770 --> 00:33:30,450
just tying everything to this one big

878
00:33:30,450 --> 00:33:32,160
power and so if you turned that off it

879
00:33:32,160 --> 00:33:33,780
was really other components that we

880
00:33:33,780 --> 00:33:35,160
wanted to turn off but the som just

881
00:33:35,160 --> 00:33:37,410
happened to also hang on there so it was

882
00:33:37,410 --> 00:33:39,180
probably be better to put som on a

883
00:33:39,180 --> 00:33:42,870
separate rail or put it on a on an

884
00:33:42,870 --> 00:33:44,400
always-on rail essentially that's

885
00:33:44,400 --> 00:33:46,410
supposed to stay alive but the problem

886
00:33:46,410 --> 00:33:48,300
is what we did on this chip is

887
00:33:48,300 --> 00:33:49,440
essentially something that the chip

888
00:33:49,440 --> 00:33:50,850
wasn't really designed for we just

889
00:33:50,850 --> 00:33:52,410
figured out afterwards hey this is

890
00:33:52,410 --> 00:33:53,760
something we could in theory turn off

891
00:33:53,760 --> 00:33:56,640
maybe if we just do it right I also

892
00:33:56,640 --> 00:33:58,560
think the idea of having split som is

893
00:33:58,560 --> 00:34:01,350
not that bad so 8k is unfortunately not

894
00:34:01,350 --> 00:34:03,900
that much so having something like 16 K

895
00:34:03,900 --> 00:34:05,880
32k would be much easier to work with

896
00:34:05,880 --> 00:34:07,710
and then then maybe that's good enough

897
00:34:07,710 --> 00:34:11,418
and it could turn off the main s room

898
00:34:12,649 --> 00:34:15,090
what kind of information are you passing

899
00:34:15,090 --> 00:34:19,620
from core boot to the femur so the core

900
00:34:19,620 --> 00:34:22,530
would table based it was for one the

901
00:34:22,530 --> 00:34:24,620
other things that we usually pass is

902
00:34:24,620 --> 00:34:27,149
some information specific to the board

903
00:34:27,149 --> 00:34:29,699
so we had this design philosophy when

904
00:34:29,699 --> 00:34:31,980
doing this to try to not pull bought

905
00:34:31,980 --> 00:34:33,899
specific information into trusted

906
00:34:33,899 --> 00:34:35,699
firmware because most of the stuff

907
00:34:35,699 --> 00:34:37,230
trusted from idiots with is only

908
00:34:37,230 --> 00:34:39,630
specific to the SOC so how to turn off

909
00:34:39,630 --> 00:34:41,730
CPUs on and off it doesn't really care

910
00:34:41,730 --> 00:34:42,989
about the rest of the components on the

911
00:34:42,989 --> 00:34:46,050
board and if we had a notion of the

912
00:34:46,050 --> 00:34:47,610
board entrusted firmware essentially it

913
00:34:47,610 --> 00:34:48,840
would make the whole thing way more

914
00:34:48,840 --> 00:34:50,580
complicated because every board that we

915
00:34:50,580 --> 00:34:52,710
implement with that SOC would have its

916
00:34:52,710 --> 00:34:54,780
own code and there and it will just

917
00:34:54,780 --> 00:34:56,699
become more complicated so what we

918
00:34:56,699 --> 00:34:58,830
decided to do is in those few cases

919
00:34:58,830 --> 00:35:00,450
where trusted for men needs to know

920
00:35:00,450 --> 00:35:02,400
something about the board this is for

921
00:35:02,400 --> 00:35:04,530
example when it wants to reboot like it

922
00:35:04,530 --> 00:35:06,480
needs the way to reboot and on some

923
00:35:06,480 --> 00:35:08,430
systems we rebooted through an external

924
00:35:08,430 --> 00:35:10,920
GPIO on others we use some SOC internal

925
00:35:10,920 --> 00:35:13,320
mechanism so in that case we would have

926
00:35:13,320 --> 00:35:15,390
a parameter that tells us that firmware

927
00:35:15,390 --> 00:35:17,100
which we boot mechanism to you

928
00:35:17,100 --> 00:35:19,290
and that way we can tell that both

929
00:35:19,290 --> 00:35:20,700
specific information and don't need to

930
00:35:20,700 --> 00:35:22,350
hard code both specific code in there

931
00:35:22,350 --> 00:35:25,410
okay I'm just telling you because now in

932
00:35:25,410 --> 00:35:28,320
the femur we support dynamic

933
00:35:28,320 --> 00:35:30,210
configuration which basically consists

934
00:35:30,210 --> 00:35:32,490
on passing a device tree between images

935
00:35:32,490 --> 00:35:34,920
so maybe this is something that you

936
00:35:34,920 --> 00:35:36,000
could use in the future

937
00:35:36,000 --> 00:35:38,040
right yeah I've heard about that I

938
00:35:38,040 --> 00:35:40,080
wasn't sure if it's finished yet or not

939
00:35:40,080 --> 00:35:43,530
but I'm not sure how it would work in

940
00:35:43,530 --> 00:35:46,050
your case with skipping the first stages

941
00:35:46,050 --> 00:35:49,050
of the groomer but yet I'm sure it it

942
00:35:49,050 --> 00:35:51,120
could work and we are already using it

943
00:35:51,120 --> 00:35:52,800
in some reference code for passing

944
00:35:52,800 --> 00:35:55,050
arguments between images to for example

945
00:35:55,050 --> 00:35:58,200
share memory between different images so

946
00:35:58,200 --> 00:36:00,180
yeah I'm pretty sure it could work as

947
00:36:00,180 --> 00:36:02,970
the past addresses for a peripheral or

948
00:36:02,970 --> 00:36:05,040
something so that interface between B R

949
00:36:05,040 --> 00:36:08,730
2 and B 3 1 or right now as far as I

950
00:36:08,730 --> 00:36:10,830
know we are using it between bill 1 and

951
00:36:10,830 --> 00:36:12,930
BL 2 but there's no reason why we

952
00:36:12,930 --> 00:36:14,250
couldn't use it in here through one

953
00:36:14,250 --> 00:36:16,050
right so I think that is the extension

954
00:36:16,050 --> 00:36:17,520
essentially that we are still waiting on

955
00:36:17,520 --> 00:36:19,920
before we can skip to better mechanism

956
00:36:19,920 --> 00:36:22,040
yeah

957
00:36:27,890 --> 00:36:30,750
hi what's the boot time penalty now that

958
00:36:30,750 --> 00:36:34,140
you have to use untrusted firmware it's

959
00:36:34,140 --> 00:36:36,810
usually not that bad because it doesn't

960
00:36:36,810 --> 00:36:39,350
do a lot doing boot it just sets up so

961
00:36:39,350 --> 00:36:41,610
trusted firmware is not to do supposed

962
00:36:41,610 --> 00:36:43,620
to do any SOC initialization we have all

963
00:36:43,620 --> 00:36:45,090
of that in core boot so really ordered

964
00:36:45,090 --> 00:36:47,370
us on boot is setting up its own stuff

965
00:36:47,370 --> 00:36:49,320
and then passing on to the next part and

966
00:36:49,320 --> 00:36:51,120
it's really only meant to do these

967
00:36:51,120 --> 00:36:53,940
one-time services so it's usually below

968
00:36:53,940 --> 00:36:56,340
15 milliseconds to go through the

969
00:36:56,340 --> 00:37:00,660
rehearsal for my part yep just out of

970
00:37:00,660 --> 00:37:02,490
curiosity I think on that rock ship

971
00:37:02,490 --> 00:37:03,860
platform there was a dedicated

972
00:37:03,860 --> 00:37:06,870
microcontroller for the roms to spend

973
00:37:06,870 --> 00:37:09,150
stuff the DCF can you tell us the story

974
00:37:09,150 --> 00:37:11,430
about that and whites it was replaced by

975
00:37:11,430 --> 00:37:14,790
the n0 yeah I don't think I can remember

976
00:37:14,790 --> 00:37:18,300
all the details the DCF was this thing

977
00:37:18,300 --> 00:37:20,580
that they implemented specifically to do

978
00:37:20,580 --> 00:37:22,950
the frequency switching and it was like

979
00:37:22,950 --> 00:37:25,080
their own little microcontroller with

980
00:37:25,080 --> 00:37:27,000
only a couple of instructions and really

981
00:37:27,000 --> 00:37:28,950
crazy thing essentially that like we

982
00:37:28,950 --> 00:37:30,690
didn't have an assembler for that we had

983
00:37:30,690 --> 00:37:33,600
to ask them for code for it and I don't

984
00:37:33,600 --> 00:37:34,980
really remember the details but at some

985
00:37:34,980 --> 00:37:36,480
point essentially we found something

986
00:37:36,480 --> 00:37:38,010
that we needed to do during the

987
00:37:38,010 --> 00:37:39,480
frequency scaling that we couldn't with

988
00:37:39,480 --> 00:37:41,700
the DCF and then we thought why are we

989
00:37:41,700 --> 00:37:43,860
doing this if we just have full arm cold

990
00:37:43,860 --> 00:37:45,180
air that can do everything and this

991
00:37:45,180 --> 00:37:47,550
fully general-purpose so we switched

992
00:37:47,550 --> 00:37:50,030
using that

993
00:37:53,539 --> 00:37:57,380
Oh is staff room for another two

994
00:37:57,380 --> 00:38:00,069
questions maybe

995
00:38:11,430 --> 00:38:13,920
and in terms of whether to use the like

996
00:38:13,920 --> 00:38:15,690
you know you you pulled the one part out

997
00:38:15,690 --> 00:38:17,549
and then a question was you know what

998
00:38:17,549 --> 00:38:19,079
about those earlier parts do you know

999
00:38:19,079 --> 00:38:23,190
their policy on you know booting versus

1000
00:38:23,190 --> 00:38:24,720
breaking and over it's a Corbett thing

1001
00:38:24,720 --> 00:38:26,249
is and always come up and it'll just

1002
00:38:26,249 --> 00:38:27,660
tell you things didn't go well but do

1003
00:38:27,660 --> 00:38:29,609
you know what the arm stuff does in that

1004
00:38:29,609 --> 00:38:32,789
case I'm just curious I'm not really

1005
00:38:32,789 --> 00:38:34,200
familiar honestly with those other two

1006
00:38:34,200 --> 00:38:38,039
parts okay but the thing is that I think

1007
00:38:38,039 --> 00:38:40,440
it's a very thin framework so a lot of

1008
00:38:40,440 --> 00:38:41,970
this stuff is left to the platform and

1009
00:38:41,970 --> 00:38:43,769
the platform is supposed to figure those

1010
00:38:43,769 --> 00:38:45,299
kinds of things out like what happens if

1011
00:38:45,299 --> 00:38:47,450
it fails or something I think the actual

1012
00:38:47,450 --> 00:38:49,980
generic framework parts for beer 1 and

1013
00:38:49,980 --> 00:38:51,930
beer to a very very lightweight and

1014
00:38:51,930 --> 00:38:55,129
don't really do that much

1015
00:39:04,800 --> 00:39:07,080
all right if there are no more questions

1016
00:39:07,080 --> 00:39:10,840
then thanks again very much it is

1017
00:39:10,840 --> 00:39:14,079
[Applause]

1018
00:39:16,380 --> 00:39:23,260
[Music]

