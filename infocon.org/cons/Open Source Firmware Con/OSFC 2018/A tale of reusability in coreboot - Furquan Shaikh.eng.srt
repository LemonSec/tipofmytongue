1
00:00:00,000 --> 00:00:04,250
[Music]

2
00:00:04,250 --> 00:00:07,620
okay so hi everyone welcome to the first

3
00:00:07,620 --> 00:00:10,519
talk of the second main track today

4
00:00:10,519 --> 00:00:12,809
today we are talking about

5
00:00:12,809 --> 00:00:16,199
reusability in coreboot and a bit of a

6
00:00:16,199 --> 00:00:19,410
tale about it so please give a big round

7
00:00:19,410 --> 00:00:26,730
of applause and enjoy thank you good

8
00:00:26,730 --> 00:00:29,340
afternoon everyone my name is firkin

9
00:00:29,340 --> 00:00:32,910
Shaikh and I'm here to narrate a tale of

10
00:00:32,910 --> 00:00:35,850
reusability in code boot a little about

11
00:00:35,850 --> 00:00:38,489
myself I work for Google in the Chrome

12
00:00:38,489 --> 00:00:40,860
OS firmware team I actually started out

13
00:00:40,860 --> 00:00:43,350
in this team as an intern and I have

14
00:00:43,350 --> 00:00:45,360
been working on code boot and Chrome OS

15
00:00:45,360 --> 00:00:50,160
for the past 5 years now so this is a

16
00:00:50,160 --> 00:00:51,960
quick overview of the topics that I have

17
00:00:51,960 --> 00:00:54,239
planned to cover today please feel free

18
00:00:54,239 --> 00:01:00,660
to ask me questions at any point okay so

19
00:01:00,660 --> 00:01:02,520
at the I believe some of you here are

20
00:01:02,520 --> 00:01:05,459
familiar with what Chrome OS is but for

21
00:01:05,459 --> 00:01:08,729
those who are not I would define it as a

22
00:01:08,729 --> 00:01:11,400
single collection of mostly open-source

23
00:01:11,400 --> 00:01:13,619
software running on a variety of

24
00:01:13,619 --> 00:01:16,830
hardware we have shipped Chromebooks

25
00:01:16,830 --> 00:01:20,670
with Intel x86 arm 32 arm 64 associates

26
00:01:20,670 --> 00:01:23,490
including the ones from Nvidia mediatek

27
00:01:23,490 --> 00:01:27,540
and ROK ship so all the Chromebooks

28
00:01:27,540 --> 00:01:30,360
except a few early ones use coreboot as

29
00:01:30,360 --> 00:01:33,840
their machine initialization routine and

30
00:01:33,840 --> 00:01:35,579
rest of the software stack includes

31
00:01:35,579 --> 00:01:37,890
libraries like verified boot library

32
00:01:37,890 --> 00:01:40,020
third-party firmware like arm trusted

33
00:01:40,020 --> 00:01:43,740
firmware some blobs FSP depth-charge

34
00:01:43,740 --> 00:01:46,020
which is the OS loader and finally the

35
00:01:46,020 --> 00:01:50,189
Linux kernel Chromebooks have actually

36
00:01:50,189 --> 00:01:52,350
gained a lot of popularity in the audio

37
00:01:52,350 --> 00:01:54,750
segment in us and with devices like

38
00:01:54,750 --> 00:01:57,479
Google pixel book HP Chromebook x2 the

39
00:01:57,479 --> 00:01:59,759
focus is expanding towards consumer

40
00:01:59,759 --> 00:02:05,450
segments as well so the combination of

41
00:02:05,450 --> 00:02:07,680
software and hardware that we saw is

42
00:02:07,680 --> 00:02:10,348
actually just one of the components that

43
00:02:10,348 --> 00:02:12,930
goes into building an entire Chrome OS

44
00:02:12,930 --> 00:02:13,740
platform

45
00:02:13,740 --> 00:02:16,170
and it is referred to as the application

46
00:02:16,170 --> 00:02:19,560
processor apart from the application

47
00:02:19,560 --> 00:02:21,840
processor there are a number of

48
00:02:21,840 --> 00:02:23,490
different controllers like the embedded

49
00:02:23,490 --> 00:02:26,760
controller t CP CP mech and a variety of

50
00:02:26,760 --> 00:02:28,860
peripherals like keyboard touchscreen

51
00:02:28,860 --> 00:02:32,850
trackpad and more this might actually

52
00:02:32,850 --> 00:02:35,340
look familiar to some of you since it is

53
00:02:35,340 --> 00:02:37,050
similar to any typical computing

54
00:02:37,050 --> 00:02:43,380
platform the model that Chrome OS

55
00:02:43,380 --> 00:02:46,080
follows for all of its platforms looks

56
00:02:46,080 --> 00:02:48,120
something like this the Chrome OS team

57
00:02:48,120 --> 00:02:50,160
at Google designs a reference platform

58
00:02:50,160 --> 00:02:53,300
using the components that we saw before

59
00:02:53,300 --> 00:02:56,040
then one of the OEMs is chosen as the

60
00:02:56,040 --> 00:02:58,140
lead om and they copy the reference

61
00:02:58,140 --> 00:03:02,480
platform as is and ship a device with it

62
00:03:02,480 --> 00:03:06,600
next multiple OMS come onboard and they

63
00:03:06,600 --> 00:03:08,430
add their own tweaks on top of the

64
00:03:08,430 --> 00:03:10,500
reference platform and ship multiple

65
00:03:10,500 --> 00:03:13,170
follower devices now even though there

66
00:03:13,170 --> 00:03:14,970
is a single block shown for each OM

67
00:03:14,970 --> 00:03:17,190
device there could be multiple SKUs here

68
00:03:17,190 --> 00:03:19,320
like convertible versus clamshell SKU

69
00:03:19,320 --> 00:03:21,720
that screen versus non touchscreen mid

70
00:03:21,720 --> 00:03:23,400
friend memory SKUs or different storage

71
00:03:23,400 --> 00:03:28,230
skills one example of this model is

72
00:03:28,230 --> 00:03:31,440
GLaDOS so the reference platform GLaDOS

73
00:03:31,440 --> 00:03:35,730
was designed using Intel skylake SOC the

74
00:03:35,730 --> 00:03:36,990
lead om Shiva

75
00:03:36,990 --> 00:03:40,170
using GLaDOS and different OEMs ship

76
00:03:40,170 --> 00:03:45,300
devices like Caroline and Cave a better

77
00:03:45,300 --> 00:03:47,450
example of this model is actually Reif

78
00:03:47,450 --> 00:03:49,950
the reference platform reef was designed

79
00:03:49,950 --> 00:03:54,000
using Intel Apollo Lake SOC the lead OMF

80
00:03:54,000 --> 00:03:57,630
asses and various OM Slater shipped on

81
00:03:57,630 --> 00:04:00,060
follower devices like nasha pyros san

82
00:04:00,060 --> 00:04:06,990
and snappy another example of this model

83
00:04:06,990 --> 00:04:10,110
is coral but coral was special in a

84
00:04:10,110 --> 00:04:12,900
number of ways one of the unique things

85
00:04:12,900 --> 00:04:14,880
about coral was that since it was a

86
00:04:14,880 --> 00:04:17,010
refresh device based on Intel Apollo

87
00:04:17,010 --> 00:04:19,320
Lake SOC it derived from the same

88
00:04:19,320 --> 00:04:22,500
reference platform reef and coral itself

89
00:04:22,500 --> 00:04:25,140
was never shipped but instead multiple

90
00:04:25,140 --> 00:04:26,820
follower OM devices were shipped like

91
00:04:26,820 --> 00:04:27,570
astronaut

92
00:04:27,570 --> 00:04:31,620
Robo national etc the other unique thing

93
00:04:31,620 --> 00:04:35,220
about coral is that all the OEM devices

94
00:04:35,220 --> 00:04:37,230
ship with a single unified firmware

95
00:04:37,230 --> 00:04:39,780
image that is a single a firmware image

96
00:04:39,780 --> 00:04:41,700
was used on all the OEM devices from

97
00:04:41,700 --> 00:04:44,310
this family now this approach had its

98
00:04:44,310 --> 00:04:46,170
own advantages and disadvantages and

99
00:04:46,170 --> 00:04:50,490
we'll take a look at that later finally

100
00:04:50,490 --> 00:04:54,060
the most recent platform is octopus here

101
00:04:54,060 --> 00:04:56,040
we have to reference platforms you're an

102
00:04:56,040 --> 00:04:58,920
PIP which allows the OEMs to have a

103
00:04:58,920 --> 00:05:01,310
wider selection of components and

104
00:05:01,310 --> 00:05:04,350
multiple OM devices like phaser me leaks

105
00:05:04,350 --> 00:05:10,950
and boba but you must be wondering that

106
00:05:10,950 --> 00:05:13,320
this story was supposed to be about code

107
00:05:13,320 --> 00:05:15,870
boot and all have been doing is talking

108
00:05:15,870 --> 00:05:19,170
to you about Chrome OS actually it is

109
00:05:19,170 --> 00:05:20,940
important to know the background here in

110
00:05:20,940 --> 00:05:22,920
order to understand the decisions that

111
00:05:22,920 --> 00:05:25,830
were taken within code boot so let's

112
00:05:25,830 --> 00:05:27,840
rewind back and first take a look at the

113
00:05:27,840 --> 00:05:31,190
objectives that we are trying to achieve

114
00:05:31,430 --> 00:05:33,720
the first objective is faster

115
00:05:33,720 --> 00:05:35,640
time-to-market so audience would like to

116
00:05:35,640 --> 00:05:39,090
ship devices as soon as possible they

117
00:05:39,090 --> 00:05:40,740
would like to have more flexibility with

118
00:05:40,740 --> 00:05:43,860
respect to component selection obviously

119
00:05:43,860 --> 00:05:45,390
we would like to avoid duplication of

120
00:05:45,390 --> 00:05:47,910
work within the software stack this kind

121
00:05:47,910 --> 00:05:49,830
of ties in with the first example of

122
00:05:49,830 --> 00:05:51,750
being able to ship devices as soon as

123
00:05:51,750 --> 00:05:54,660
possible so anytime a new device has to

124
00:05:54,660 --> 00:05:56,520
be added to the same family you would

125
00:05:56,520 --> 00:05:58,050
want to make use of the existing

126
00:05:58,050 --> 00:06:01,290
infrastructure next is making the whole

127
00:06:01,290 --> 00:06:03,570
process manageable for everyone this

128
00:06:03,570 --> 00:06:05,250
includes the electrical engineers who

129
00:06:05,250 --> 00:06:07,080
are designing the hardware software

130
00:06:07,080 --> 00:06:08,820
engineers who are designing the firmware

131
00:06:08,820 --> 00:06:12,060
and the OS for the OEMs and ODMs to

132
00:06:12,060 --> 00:06:14,190
actually ship devices and even for the

133
00:06:14,190 --> 00:06:15,840
test team to be able to validate these

134
00:06:15,840 --> 00:06:19,800
devices and finally making the whole

135
00:06:19,800 --> 00:06:22,050
process scalable so that way you're able

136
00:06:22,050 --> 00:06:24,030
to ship more and more devices each and

137
00:06:24,030 --> 00:06:27,090
every year so let's see how these

138
00:06:27,090 --> 00:06:29,280
objectives are being achieved using the

139
00:06:29,280 --> 00:06:33,690
same platforms that we saw before the

140
00:06:33,690 --> 00:06:37,380
first example was GLaDOS on the left is

141
00:06:37,380 --> 00:06:39,480
the hardware view of the platform and on

142
00:06:39,480 --> 00:06:40,650
the right is the software or firmware

143
00:06:40,650 --> 00:06:41,759
view

144
00:06:41,759 --> 00:06:43,949
my firm when I basically mean the BIOS

145
00:06:43,949 --> 00:06:45,659
or more specifically cold boot in this

146
00:06:45,659 --> 00:06:50,189
case here each om device got its own

147
00:06:50,189 --> 00:06:53,520
firmware now as you see on the hardware

148
00:06:53,520 --> 00:06:56,400
side there is a clear hierarchy or like

149
00:06:56,400 --> 00:06:58,559
reusability since all the different

150
00:06:58,559 --> 00:07:00,240
devices are based on the same reference

151
00:07:00,240 --> 00:07:03,439
platform GLaDOS but on the formal side

152
00:07:03,439 --> 00:07:06,150
apart from the common block one which is

153
00:07:06,150 --> 00:07:08,879
the arch SOC library code there was no

154
00:07:08,879 --> 00:07:10,919
sharing at the mainboard level even

155
00:07:10,919 --> 00:07:12,240
though they were all derived from the

156
00:07:12,240 --> 00:07:16,199
same reference platform one of the files

157
00:07:16,199 --> 00:07:18,389
that was very commonly duplicated across

158
00:07:18,389 --> 00:07:20,909
different boats was the mainboard ASL

159
00:07:20,909 --> 00:07:24,479
file member dot ASL basically allowed

160
00:07:24,479 --> 00:07:27,210
you to do like describe different

161
00:07:27,210 --> 00:07:28,680
devices that are present on a platform

162
00:07:28,680 --> 00:07:30,990
like that screen device trackpad device

163
00:07:30,990 --> 00:07:37,169
TPM device so here's an example of manbo

164
00:07:37,169 --> 00:07:39,870
dot ASL file from GLaDOS shell and

165
00:07:39,870 --> 00:07:42,509
Caroline respectively it specifically

166
00:07:42,509 --> 00:07:45,110
highlights the touchscreen device node

167
00:07:45,110 --> 00:07:48,599
so if you observe closely the entire

168
00:07:48,599 --> 00:07:50,669
device node or most of the device node

169
00:07:50,669 --> 00:07:52,620
looks similar across the different ports

170
00:07:52,620 --> 00:07:53,999
and there are just a very few

171
00:07:53,999 --> 00:07:56,069
differences like the head which is

172
00:07:56,069 --> 00:07:57,509
actually used by the kernel driver to

173
00:07:57,509 --> 00:07:59,189
identify the device the device

174
00:07:59,189 --> 00:08:01,680
descriptor the i2c address for the

175
00:08:01,680 --> 00:08:03,479
device and the touch screen irq

176
00:08:03,479 --> 00:08:05,009
basically the ones highlighted in red

177
00:08:05,009 --> 00:08:09,209
and this duplication was present not

178
00:08:09,209 --> 00:08:11,039
just for the touch screen node but for

179
00:08:11,039 --> 00:08:13,860
all the other devices as well and it's

180
00:08:13,860 --> 00:08:15,360
not restrict it was not restricted to

181
00:08:15,360 --> 00:08:17,219
GLaDOS we had a number of ports which

182
00:08:17,219 --> 00:08:20,879
did the same thing in order to fix this

183
00:08:20,879 --> 00:08:23,669
duplication SSDD generation was added to

184
00:08:23,669 --> 00:08:25,009
code boot

185
00:08:25,009 --> 00:08:28,020
so ssed generation basically allows a

186
00:08:28,020 --> 00:08:30,749
runtime edition of device notes to a CPI

187
00:08:30,749 --> 00:08:33,240
SSD T based on the device tree

188
00:08:33,240 --> 00:08:37,019
properties it basically relieves the

189
00:08:37,019 --> 00:08:39,120
developers from hectic task of having to

190
00:08:39,120 --> 00:08:41,159
define all these device nodes in a CPI

191
00:08:41,159 --> 00:08:44,159
source language ASL is not that

192
00:08:44,159 --> 00:08:46,019
difficult to learn but for a newcomer it

193
00:08:46,019 --> 00:08:49,170
could take some time so the underlying

194
00:08:49,170 --> 00:08:52,170
idea here is that a driver in RAM stage

195
00:08:52,170 --> 00:08:54,360
would be responsible for generation of

196
00:08:54,360 --> 00:08:55,640
these nodes a truant

197
00:08:55,640 --> 00:08:58,770
you can find some examples under eye to

198
00:08:58,770 --> 00:09:01,170
see generic spy ACPI or generate GPIO

199
00:09:01,170 --> 00:09:04,230
keys but these generators are not

200
00:09:04,230 --> 00:09:06,450
limited to just drivers you can also use

201
00:09:06,450 --> 00:09:08,430
them for like CP or no generation PCI

202
00:09:08,430 --> 00:09:11,610
device generation and mocha a good way

203
00:09:11,610 --> 00:09:13,530
to locate these generators is by doing a

204
00:09:13,530 --> 00:09:15,960
grep for a CPI fill SS DT generator in

205
00:09:15,960 --> 00:09:18,420
Co both sources it is basically the

206
00:09:18,420 --> 00:09:20,520
callback that is used for the table

207
00:09:20,520 --> 00:09:24,060
generation now using this SS DT

208
00:09:24,060 --> 00:09:26,190
generation the same touchscreen device

209
00:09:26,190 --> 00:09:28,470
node can be described using the block on

210
00:09:28,470 --> 00:09:30,540
the right now you just have to indicate

211
00:09:30,540 --> 00:09:32,520
what driver is to be used in this case

212
00:09:32,520 --> 00:09:34,710
the drivers eye to see generic and the

213
00:09:34,710 --> 00:09:35,880
same properties that were different

214
00:09:35,880 --> 00:09:37,980
among different devices like the head

215
00:09:37,980 --> 00:09:43,230
descriptor the irq and the i2c this SSD

216
00:09:43,230 --> 00:09:46,260
T generation has since been used on all

217
00:09:46,260 --> 00:09:48,360
the older as well as new platforms that

218
00:09:48,360 --> 00:09:54,840
are being added to code boot next

219
00:09:54,840 --> 00:10:00,450
example is the reef platform again on

220
00:10:00,450 --> 00:10:02,670
the left is the hardware view and on the

221
00:10:02,670 --> 00:10:06,120
pic is the firmware view similar to

222
00:10:06,120 --> 00:10:08,280
GLaDOS each device in the reef family

223
00:10:08,280 --> 00:10:11,670
got its own firmware so similar to

224
00:10:11,670 --> 00:10:13,230
GLaDOS we have a common block one which

225
00:10:13,230 --> 00:10:16,080
is the arch SOC library code but apart

226
00:10:16,080 --> 00:10:18,060
from that there is a common block to

227
00:10:18,060 --> 00:10:21,360
across all these different devices and a

228
00:10:21,360 --> 00:10:23,370
block 3 which is different among these

229
00:10:23,370 --> 00:10:27,870
devices the reason why we see a common

230
00:10:27,870 --> 00:10:29,970
block 2 on grief is because it

231
00:10:29,970 --> 00:10:32,280
introduced the concept of baseboard and

232
00:10:32,280 --> 00:10:36,990
variant structures so unlike GLaDOS

233
00:10:36,990 --> 00:10:39,690
which basically added a new directory

234
00:10:39,690 --> 00:10:42,000
under mainboard for each device from the

235
00:10:42,000 --> 00:10:44,340
GLaDOS family we followed a completely

236
00:10:44,340 --> 00:10:48,420
different hierarchy the underlying idea

237
00:10:48,420 --> 00:10:50,880
here is that the different devices that

238
00:10:50,880 --> 00:10:52,890
belong to the same family requires

239
00:10:52,890 --> 00:10:55,110
similar initialization and device logic

240
00:10:55,110 --> 00:10:57,300
so all of this common code can be placed

241
00:10:57,300 --> 00:11:00,330
under a baseboard directory and only the

242
00:11:00,330 --> 00:11:01,860
things that differ across these

243
00:11:01,860 --> 00:11:04,290
different devices can go under variant

244
00:11:04,290 --> 00:11:06,750
specific directories so we have a single

245
00:11:06,750 --> 00:11:09,150
directory reef under mainboard Google

246
00:11:09,150 --> 00:11:11,010
and under variants we have a baseboard

247
00:11:11,010 --> 00:11:12,390
which would be most of the common code

248
00:11:12,390 --> 00:11:14,640
and then different directories for the

249
00:11:14,640 --> 00:11:18,630
different variants this actually takes

250
00:11:18,630 --> 00:11:20,640
us a step closer to a data-driven

251
00:11:20,640 --> 00:11:23,370
approach where common code is doing all

252
00:11:23,370 --> 00:11:25,320
the work for you and the variant

253
00:11:25,320 --> 00:11:27,630
specific variant specific code or data

254
00:11:27,630 --> 00:11:29,700
is providing just the information that

255
00:11:29,700 --> 00:11:31,320
is required by the common code to do its

256
00:11:31,320 --> 00:11:37,140
work so because of this we have the

257
00:11:37,140 --> 00:11:38,850
common block two that we saw earlier was

258
00:11:38,850 --> 00:11:40,500
the baseboard specific code that is

259
00:11:40,500 --> 00:11:41,790
common across all the different devices

260
00:11:41,790 --> 00:11:44,400
in this family and the block 3 is the

261
00:11:44,400 --> 00:11:51,300
variant specific code end data let's see

262
00:11:51,300 --> 00:11:53,790
how much code had to be added to support

263
00:11:53,790 --> 00:11:56,810
each new variant in brief so as expected

264
00:11:56,810 --> 00:11:59,520
majority of the code went into mainboard

265
00:11:59,520 --> 00:12:03,380
googled reef and the baseboard directory

266
00:12:03,380 --> 00:12:06,330
if we look at the variants reef and

267
00:12:06,330 --> 00:12:09,240
Nashua pretty lightweight they almost

268
00:12:09,240 --> 00:12:11,520
had no new code in them it's basically

269
00:12:11,520 --> 00:12:13,050
consists of header files and those

270
00:12:13,050 --> 00:12:14,820
header files essentially just pointed

271
00:12:14,820 --> 00:12:18,960
back to the baseboard directory but if

272
00:12:18,960 --> 00:12:21,270
you look at sand pyro and snappy they

273
00:12:21,270 --> 00:12:24,330
still look pretty bulky and one of the

274
00:12:24,330 --> 00:12:27,030
reasons is the device tree dot CB file

275
00:12:27,030 --> 00:12:29,420
it's the one that is highlighted in red

276
00:12:29,420 --> 00:12:32,760
it kind of occupies more than 50% of the

277
00:12:32,760 --> 00:12:35,520
lines that are added I understand that

278
00:12:35,520 --> 00:12:37,260
lines of code might not be a very good

279
00:12:37,260 --> 00:12:39,270
metric here but it's just being used as

280
00:12:39,270 --> 00:12:42,780
a reference for comparison so apart from

281
00:12:42,780 --> 00:12:46,200
the device so ok let's keep the device I

282
00:12:46,200 --> 00:12:47,820
understand that the device tree had a

283
00:12:47,820 --> 00:12:50,220
lot of duplication in it and there was a

284
00:12:50,220 --> 00:12:52,560
lot of scope for optimization but we'll

285
00:12:52,560 --> 00:12:55,350
get back to that later so apart from the

286
00:12:55,350 --> 00:12:57,660
device tree file the differences that we

287
00:12:57,660 --> 00:13:00,390
see are in the DPT F dot SL which is

288
00:13:00,390 --> 00:13:02,250
basically the thermal table and this has

289
00:13:02,250 --> 00:13:03,660
to be different based on the different

290
00:13:03,660 --> 00:13:07,470
device devices the other differences are

291
00:13:07,470 --> 00:13:09,930
mainly in like memory dot C or GPIO

292
00:13:09,930 --> 00:13:12,690
configuration so the differences that we

293
00:13:12,690 --> 00:13:14,490
are seeing here were the actual

294
00:13:14,490 --> 00:13:15,810
differences that were present in

295
00:13:15,810 --> 00:13:17,850
hardware and so they required some

296
00:13:17,850 --> 00:13:20,400
amount of firmware code so if you ignore

297
00:13:20,400 --> 00:13:22,450
the device tree for a while

298
00:13:22,450 --> 00:13:24,220
the variant and baseboard structure

299
00:13:24,220 --> 00:13:26,470
actually allowed us to save a lot of

300
00:13:26,470 --> 00:13:28,950
duplicate code within kaput

301
00:13:28,950 --> 00:13:31,240
the baseboard in variant structure has

302
00:13:31,240 --> 00:13:32,800
since been used for all the new

303
00:13:32,800 --> 00:13:35,410
platforms that are being added and also

304
00:13:35,410 --> 00:13:36,700
some of the older platforms have been

305
00:13:36,700 --> 00:13:43,449
migrated to this structure a next

306
00:13:43,449 --> 00:13:47,829
platform is coral as I mentioned before

307
00:13:47,829 --> 00:13:51,120
coral was special in a number of ways

308
00:13:51,120 --> 00:13:53,589
and one of the unique things about coral

309
00:13:53,589 --> 00:13:55,690
was that it shipped using a single

310
00:13:55,690 --> 00:13:57,730
unified firmware image that is all the

311
00:13:57,730 --> 00:14:00,370
devices had the same firmware image so

312
00:14:00,370 --> 00:14:02,440
what we see here is the devices from

313
00:14:02,440 --> 00:14:04,420
this family have common block one two

314
00:14:04,420 --> 00:14:07,680
and three so there's no difference among

315
00:14:07,680 --> 00:14:09,970
this approach obviously have its own

316
00:14:09,970 --> 00:14:11,639
positives and negatives positives

317
00:14:11,639 --> 00:14:14,019
because it reduced the amount of work

318
00:14:14,019 --> 00:14:15,250
that was required on the firmware

319
00:14:15,250 --> 00:14:17,620
development front obviously we could use

320
00:14:17,620 --> 00:14:20,290
OEM IDs and SKU IDs to distinguish

321
00:14:20,290 --> 00:14:23,829
between these devices at runtime but it

322
00:14:23,829 --> 00:14:26,070
also had its own disadvantages

323
00:14:26,070 --> 00:14:28,899
disadvantages for the oils because it

324
00:14:28,899 --> 00:14:30,610
restricted them to the number of

325
00:14:30,610 --> 00:14:32,260
components or the components that they

326
00:14:32,260 --> 00:14:34,500
could actually use on the own device and

327
00:14:34,500 --> 00:14:38,140
to the test team because anytime a new

328
00:14:38,140 --> 00:14:39,910
firmware had to be released for any one

329
00:14:39,910 --> 00:14:42,100
device it had to be validated on the

330
00:14:42,100 --> 00:14:46,540
entire pool of devices this is actually

331
00:14:46,540 --> 00:14:48,640
a very good example which shows us that

332
00:14:48,640 --> 00:14:50,589
reusability might not always be

333
00:14:50,589 --> 00:14:53,890
beneficial or it might actually not help

334
00:14:53,890 --> 00:14:55,420
us achieve the objectives that we saw

335
00:14:55,420 --> 00:14:58,209
earlier so we need to find a fine line

336
00:14:58,209 --> 00:14:59,949
between achieving the objective of

337
00:14:59,949 --> 00:15:02,709
reusability and reducing the effort or

338
00:15:02,709 --> 00:15:09,519
achieving the other objectives so based

339
00:15:09,519 --> 00:15:11,370
on the learnings from other platforms

340
00:15:11,370 --> 00:15:15,990
here is the most recent platform octopus

341
00:15:16,380 --> 00:15:19,839
octopus moved back to using a different

342
00:15:19,839 --> 00:15:22,540
firmware image for each om device so you

343
00:15:22,540 --> 00:15:24,610
see that there's a common block one -

344
00:15:24,610 --> 00:15:26,230
but block three is different among these

345
00:15:26,230 --> 00:15:29,199
devices here we have to reference

346
00:15:29,199 --> 00:15:31,750
platforms your end bit which allows the

347
00:15:31,750 --> 00:15:33,519
OEMs to have a wider selection of

348
00:15:33,519 --> 00:15:34,990
components they can do a mix and match

349
00:15:34,990 --> 00:15:36,110
of different components from

350
00:15:36,110 --> 00:15:41,000
reference platform it also uses all the

351
00:15:41,000 --> 00:15:43,070
features that we saw earlier like SS DT

352
00:15:43,070 --> 00:15:46,820
generation and the baseboard and variant

353
00:15:46,820 --> 00:15:50,540
structure if you notice carefully the

354
00:15:50,540 --> 00:15:53,420
block 2 on octopus is slightly bigger or

355
00:15:53,420 --> 00:15:55,190
larger than the block that we saw on

356
00:15:55,190 --> 00:15:58,790
reef and one of the reasons for this is

357
00:15:58,790 --> 00:16:00,709
the same problem that we identified

358
00:16:00,709 --> 00:16:02,329
earlier regarding device tree

359
00:16:02,329 --> 00:16:07,190
duplication so let's go back to the

360
00:16:07,190 --> 00:16:09,920
brief example and look at what the

361
00:16:09,920 --> 00:16:12,800
problem with device trace was so these

362
00:16:12,800 --> 00:16:15,050
are the same three variants and pyro and

363
00:16:15,050 --> 00:16:19,459
snappy and on the right on the left you

364
00:16:19,459 --> 00:16:22,880
can see that even though the files were

365
00:16:22,880 --> 00:16:25,459
like more than 200 lines the actual

366
00:16:25,459 --> 00:16:27,170
differences between these device trees

367
00:16:27,170 --> 00:16:29,390
was less than 35 percent or even less

368
00:16:29,390 --> 00:16:32,959
than 10 percent in some cases so in case

369
00:16:32,959 --> 00:16:35,000
of sand even though the file was like

370
00:16:35,000 --> 00:16:37,550
230 lines the actual difference was just

371
00:16:37,550 --> 00:16:42,620
16 lines in order to fix this issue of

372
00:16:42,620 --> 00:16:45,890
duplication s config utility which is

373
00:16:45,890 --> 00:16:47,660
used to basically generate the static

374
00:16:47,660 --> 00:16:49,610
dot C files from device trees was

375
00:16:49,610 --> 00:16:53,029
updated to allow variants to specify an

376
00:16:53,029 --> 00:16:57,170
override tree what this does is it

377
00:16:57,170 --> 00:16:59,300
basically applies the variant specific

378
00:16:59,300 --> 00:17:01,640
overrides on top of the properties that

379
00:17:01,640 --> 00:17:03,410
are already provided by the base device

380
00:17:03,410 --> 00:17:06,500
tree obviously there are certain rules

381
00:17:06,500 --> 00:17:08,510
that need to be used for overriding

382
00:17:08,510 --> 00:17:10,939
so if a property is present in both the

383
00:17:10,939 --> 00:17:13,160
base tree and over.i tree then the one

384
00:17:13,160 --> 00:17:15,079
from the override tree gets precedence

385
00:17:15,079 --> 00:17:17,270
if it is present in only one tree then

386
00:17:17,270 --> 00:17:20,689
that's the one that's used if a device

387
00:17:20,689 --> 00:17:23,359
is present in the override tree then it

388
00:17:23,359 --> 00:17:25,339
gets added to the appropriate parent in

389
00:17:25,339 --> 00:17:28,700
the base tree if the base parent already

390
00:17:28,700 --> 00:17:30,919
had some children then this new device

391
00:17:30,919 --> 00:17:32,780
gets added as a sibling of those

392
00:17:32,780 --> 00:17:38,030
children an evening of this override

393
00:17:38,030 --> 00:17:40,669
device tree is as simple as basically

394
00:17:40,669 --> 00:17:42,230
just setting the override device tree

395
00:17:42,230 --> 00:17:45,679
config to point to the variants tree and

396
00:17:45,679 --> 00:17:47,300
setting the required properties and

397
00:17:47,300 --> 00:17:49,490
device info which is specific to this

398
00:17:49,490 --> 00:17:52,520
variant in that tree the S config

399
00:17:52,520 --> 00:17:54,020
utility will basically walk through the

400
00:17:54,020 --> 00:17:55,580
base tree and the over I tree in

401
00:17:55,580 --> 00:17:58,400
lockstep fashion applying the properties

402
00:17:58,400 --> 00:18:02,390
and device nodes as appropriate a good

403
00:18:02,390 --> 00:18:04,570
example of how device trees can be used

404
00:18:04,570 --> 00:18:08,390
can be found under octopus so that is

405
00:18:08,390 --> 00:18:10,130
the reason why we basically have a

406
00:18:10,130 --> 00:18:12,260
bigger common block to where we are able

407
00:18:12,260 --> 00:18:14,330
to use more common code across these

408
00:18:14,330 --> 00:18:18,010
different variants from the same family

409
00:18:20,559 --> 00:18:24,200
so to summarize we started with glados

410
00:18:24,200 --> 00:18:26,870
where we did not have any sharing at the

411
00:18:26,870 --> 00:18:28,370
mainboard level between different

412
00:18:28,370 --> 00:18:32,360
variants even though there was clearly

413
00:18:32,360 --> 00:18:35,480
reused at the hardware level then we

414
00:18:35,480 --> 00:18:38,120
moved on to reef where we added the

415
00:18:38,120 --> 00:18:40,730
concept of the baseboard and variant

416
00:18:40,730 --> 00:18:42,860
structures thus introducing the common

417
00:18:42,860 --> 00:18:48,140
block to on corals we went with complete

418
00:18:48,140 --> 00:18:50,090
reusability using the same firmware on

419
00:18:50,090 --> 00:18:52,040
all the different variants but we

420
00:18:52,040 --> 00:18:54,380
learned that having a lot of reusability

421
00:18:54,380 --> 00:18:56,860
might not actually be beneficial and

422
00:18:56,860 --> 00:18:59,200
finally the recent platform octopus

423
00:18:59,200 --> 00:19:02,030
where we were able to use override

424
00:19:02,030 --> 00:19:05,330
device trees to have more more sharing

425
00:19:05,330 --> 00:19:14,090
across the different variants so what's

426
00:19:14,090 --> 00:19:18,200
next I'd like to highlight one of the

427
00:19:18,200 --> 00:19:22,610
challenges that we current have which is

428
00:19:22,610 --> 00:19:27,350
GPIO config table duplication so similar

429
00:19:27,350 --> 00:19:29,540
to device trays here the base board

430
00:19:29,540 --> 00:19:31,670
basically provides one set of GPIO

431
00:19:31,670 --> 00:19:34,400
configurations the variant has two

432
00:19:34,400 --> 00:19:36,620
options either it can go with the one

433
00:19:36,620 --> 00:19:38,809
that is provided by the base port or it

434
00:19:38,809 --> 00:19:42,620
can define its own configuration if the

435
00:19:42,620 --> 00:19:44,720
variant basically share same GPIO

436
00:19:44,720 --> 00:19:47,210
routing as the base board then it is

437
00:19:47,210 --> 00:19:49,070
okay to just use the one provided by the

438
00:19:49,070 --> 00:19:52,220
base board but if there is even one GPIO

439
00:19:52,220 --> 00:19:54,050
that is different for the way for the

440
00:19:54,050 --> 00:19:56,330
variant then we have to make an entire

441
00:19:56,330 --> 00:19:58,130
copy of the base board GPIO config

442
00:19:58,130 --> 00:20:00,679
change that one entry and add it to the

443
00:20:00,679 --> 00:20:02,630
variants directory

444
00:20:02,630 --> 00:20:05,029
or we might be able to do the variant

445
00:20:05,029 --> 00:20:06,500
configuration after the baseboard

446
00:20:06,500 --> 00:20:08,919
configuration is done to let the variant

447
00:20:08,919 --> 00:20:11,720
configurations stay but none of these

448
00:20:11,720 --> 00:20:18,080
solutions seem optimal in order to work

449
00:20:18,080 --> 00:20:21,289
around this issue GPIO configure pads

450
00:20:21,289 --> 00:20:23,870
with override was added to code boot it

451
00:20:23,870 --> 00:20:26,059
basically allows the base board to

452
00:20:26,059 --> 00:20:29,149
provides its own GPIO config table and

453
00:20:29,149 --> 00:20:31,130
the variant provides an override table

454
00:20:31,130 --> 00:20:33,649
with only those GPIO s that differ from

455
00:20:33,649 --> 00:20:36,740
the baseboard and GPIO configure pads

456
00:20:36,740 --> 00:20:38,480
with override basically loops through

457
00:20:38,480 --> 00:20:40,669
all the GPIO s that are present in the

458
00:20:40,669 --> 00:20:43,399
base table and it checks if there is an

459
00:20:43,399 --> 00:20:45,590
override present for that GPIO if it

460
00:20:45,590 --> 00:20:47,269
finds an override then the override

461
00:20:47,269 --> 00:20:50,299
configuration is used if it doesn't find

462
00:20:50,299 --> 00:20:51,860
an override it just falls back to the

463
00:20:51,860 --> 00:20:55,399
one from the base table the solution

464
00:20:55,399 --> 00:20:59,500
seems okay but it might not be optimal

465
00:20:59,500 --> 00:21:03,039
the reason why I say this is because

466
00:21:03,039 --> 00:21:05,179
GPIO configuration when you are

467
00:21:05,179 --> 00:21:07,190
comparing the different variants it

468
00:21:07,190 --> 00:21:09,740
requires some amount of human effort to

469
00:21:09,740 --> 00:21:11,360
identify the differences between the

470
00:21:11,360 --> 00:21:14,169
base board and the variant GPIO s and

471
00:21:14,169 --> 00:21:16,190
considering the fact that there might be

472
00:21:16,190 --> 00:21:18,500
hundreds of GPIO s that are configured

473
00:21:18,500 --> 00:21:20,779
per port there is a lot of probability

474
00:21:20,779 --> 00:21:22,940
for human error especially as the number

475
00:21:22,940 --> 00:21:24,980
of variants go on increasing it might

476
00:21:24,980 --> 00:21:26,480
become really difficult to track the

477
00:21:26,480 --> 00:21:30,710
differences so I mean like I said this

478
00:21:30,710 --> 00:21:34,549
is one of the challenges and the

479
00:21:34,549 --> 00:21:36,379
solution for this problem might actually

480
00:21:36,379 --> 00:21:40,039
go beyond code boot as well like we saw

481
00:21:40,039 --> 00:21:43,100
that reusability might not always be the

482
00:21:43,100 --> 00:21:44,450
best solution we also need to think

483
00:21:44,450 --> 00:21:47,299
about the human effort or how easy it is

484
00:21:47,299 --> 00:21:50,179
for managing the whole process so we I

485
00:21:50,179 --> 00:21:51,980
mean there might be a solution where if

486
00:21:51,980 --> 00:21:54,110
we have an automated tool which can look

487
00:21:54,110 --> 00:21:55,600
through the different schematics and

488
00:21:55,600 --> 00:21:58,610
identify the GPIO s for that board and

489
00:21:58,610 --> 00:22:00,590
compare it with the different variants

490
00:22:00,590 --> 00:22:03,379
it might be able to minimize the effort

491
00:22:03,379 --> 00:22:06,889
or a human effort that is required we

492
00:22:06,889 --> 00:22:08,539
can even go a step ahead and actually

493
00:22:08,539 --> 00:22:10,940
generate code using these differences so

494
00:22:10,940 --> 00:22:12,919
that code boot or human actually doesn't

495
00:22:12,919 --> 00:22:14,750
have to do anything and just those

496
00:22:14,750 --> 00:22:16,280
tables generated by the tool

497
00:22:16,280 --> 00:22:20,540
can be integrated into code boot so I'd

498
00:22:20,540 --> 00:22:22,040
like to leave you with this thought and

499
00:22:22,040 --> 00:22:40,280
open it up for questions yeah

500
00:22:40,280 --> 00:22:43,220
with understanding your last model

501
00:22:43,220 --> 00:22:45,920
wished which was this octopus and I

502
00:22:45,920 --> 00:22:48,340
fully agree on it's not always optimal

503
00:22:48,340 --> 00:22:52,340
to have a common frame where I want to

504
00:22:52,340 --> 00:22:55,460
highlight that the difference here seems

505
00:22:55,460 --> 00:22:57,710
to be very small which is then only the

506
00:22:57,710 --> 00:23:01,460
variant specific coned which remind me

507
00:23:01,460 --> 00:23:03,680
of whatever you then change in the in

508
00:23:03,680 --> 00:23:05,570
the 1 and in the 2 means the baseball

509
00:23:05,570 --> 00:23:07,790
code you still have to go through all

510
00:23:07,790 --> 00:23:11,300
validation and testing I think I didn't

511
00:23:11,300 --> 00:23:14,710
get you your concern was that you on the

512
00:23:14,710 --> 00:23:17,510
previous version where you had the

513
00:23:17,510 --> 00:23:19,820
filler for all the same you need to test

514
00:23:19,820 --> 00:23:22,850
it then on all boards right ok so here

515
00:23:22,850 --> 00:23:26,060
you're not in the need of doing that but

516
00:23:26,060 --> 00:23:27,620
only if you change something in the

517
00:23:27,620 --> 00:23:30,440
variant specific code right but if you

518
00:23:30,440 --> 00:23:32,180
change it in the base board code then

519
00:23:32,180 --> 00:23:34,100
you have to go through the testing

520
00:23:34,100 --> 00:23:35,780
anyhow right that is was the effect at

521
00:23:35,780 --> 00:23:37,940
all or correct that is always been true

522
00:23:37,940 --> 00:23:39,860
like if there is something which affects

523
00:23:39,860 --> 00:23:41,780
all the boats like if you if you have to

524
00:23:41,780 --> 00:23:43,160
make a change of just going into the

525
00:23:43,160 --> 00:23:44,660
baseball or any kind of common directory

526
00:23:44,660 --> 00:23:46,970
then it is going to affect all the boats

527
00:23:46,970 --> 00:23:49,480
but I mean consider this case where

528
00:23:49,480 --> 00:23:53,540
device a has certain bug and we had to

529
00:23:53,540 --> 00:23:55,250
fix something with specifically for that

530
00:23:55,250 --> 00:23:58,160
device that won't affect any other

531
00:23:58,160 --> 00:24:00,170
device but in case of a single unified

532
00:24:00,170 --> 00:24:02,000
firmware image even that change or

533
00:24:02,000 --> 00:24:03,950
unrelated changes particular device

534
00:24:03,950 --> 00:24:05,990
would also affect all the other devices

535
00:24:05,990 --> 00:24:07,340
from that same family

536
00:24:07,340 --> 00:24:12,459
understood ok thanks thank you

537
00:24:18,340 --> 00:24:26,060
more questions even going further with

538
00:24:26,060 --> 00:24:41,930
all these nicknames then so can you put

539
00:24:41,930 --> 00:24:43,880
numbers on how many different vendors

540
00:24:43,880 --> 00:24:47,590
and variants and products your team

541
00:24:47,590 --> 00:24:51,290
supports in a year just to kind of give

542
00:24:51,290 --> 00:24:53,270
us a better idea of the scale of how

543
00:24:53,270 --> 00:24:55,910
this reusability helps ship Chromebooks

544
00:24:55,910 --> 00:25:00,410
so if you consider so is this like poor

545
00:25:00,410 --> 00:25:07,220
platform that you're considering so for

546
00:25:07,220 --> 00:25:09,140
every single platform we might have

547
00:25:09,140 --> 00:25:12,440
anywhere between like four to seven OMS

548
00:25:12,440 --> 00:25:17,390
and there could be like at least three

549
00:25:17,390 --> 00:25:19,190
to four platforms shipping every year so

550
00:25:19,190 --> 00:25:21,790
at least in development every year so

551
00:25:21,790 --> 00:25:33,230
four into and your multiple SOC is

552
00:25:33,230 --> 00:25:34,970
multiple volumes multiple ODMs

553
00:25:34,970 --> 00:25:39,340
so all of that just keeps on multiplying

554
00:25:51,990 --> 00:25:55,740
okay I guess that's it thank you thank

555
00:25:55,740 --> 00:25:56,060
you again

556
00:25:56,060 --> 00:26:01,740
[Applause]

557
00:26:01,740 --> 00:26:08,619
[Music]

