1
00:00:02,639 --> 00:00:05,819
yeah hello everybody my name is Georgie

2
00:00:05,819 --> 00:00:08,280
kocherin and I am working at kaspersky's

3
00:00:08,280 --> 00:00:10,260
Global Research and Analysis team

4
00:00:10,260 --> 00:00:12,780
overall I've been in the cyber security

5
00:00:12,780 --> 00:00:15,839
Community for two years that's not a lot

6
00:00:15,839 --> 00:00:19,560
but as a person who has been dealing

7
00:00:19,560 --> 00:00:22,859
with complex malware and apts every day

8
00:00:22,859 --> 00:00:26,519
for more than two years I perfectly know

9
00:00:26,519 --> 00:00:29,699
that Strat actors do not like it when we

10
00:00:29,699 --> 00:00:31,800
researchers discover their samples

11
00:00:31,800 --> 00:00:34,980
analyze them make reports about them and

12
00:00:34,980 --> 00:00:36,840
then discuss them as cyber security

13
00:00:36,840 --> 00:00:39,000
conferences like now at virus bulletin

14
00:00:39,000 --> 00:00:41,399
or discuss them on Twitter

15
00:00:41,399 --> 00:00:44,100
for that reason uh malware developers

16
00:00:44,100 --> 00:00:46,920
are trying to place obstacles along our

17
00:00:46,920 --> 00:00:49,379
path thus preventing attempting to

18
00:00:49,379 --> 00:00:52,200
prevent us from getting deep into the

19
00:00:52,200 --> 00:00:55,140
malware secrets and code obfuscation is

20
00:00:55,140 --> 00:00:57,899
an example of such an obstacle by

21
00:00:57,899 --> 00:01:00,780
introducing obfuscation they make her

22
00:01:00,780 --> 00:01:03,480
code more difficult to read and they

23
00:01:03,480 --> 00:01:06,060
extend reverse engineering Time by days

24
00:01:06,060 --> 00:01:09,540
weeks and in some cases even months

25
00:01:09,540 --> 00:01:12,299
and sometimes they also add custom

26
00:01:12,299 --> 00:01:15,119
obfuscation into malware

27
00:01:15,119 --> 00:01:18,000
custom obfuscation is obfuscation that

28
00:01:18,000 --> 00:01:19,680
cannot be broken through publicly

29
00:01:19,680 --> 00:01:22,740
available tools and I personally match

30
00:01:22,740 --> 00:01:26,040
the situation in March 2022 when I

31
00:01:26,040 --> 00:01:28,979
needed to analyze a.net wiper called

32
00:01:28,979 --> 00:01:31,520
double zero that was deployed in Ukraine

33
00:01:31,520 --> 00:01:34,799
its code was extended to tens of

34
00:01:34,799 --> 00:01:37,500
thousands lines through a technique

35
00:01:37,500 --> 00:01:40,020
that's called control flow flattening

36
00:01:40,020 --> 00:01:42,540
I'll tell you how it works later but for

37
00:01:42,540 --> 00:01:45,119
now I'll say that it is considered to be

38
00:01:45,119 --> 00:01:46,920
one of the most tough to crack

39
00:01:46,920 --> 00:01:49,740
techniques of course this technique is

40
00:01:49,740 --> 00:01:52,140
not new and it has been previously

41
00:01:52,140 --> 00:01:55,259
researched for C and C plus malware and

42
00:01:55,259 --> 00:01:57,720
there is even a plugin for Ida that

43
00:01:57,720 --> 00:02:00,840
allows you to remove flattening from CNC

44
00:02:00,840 --> 00:02:02,159
Plus Code

45
00:02:02,159 --> 00:02:04,680
however in my case I was dealing with

46
00:02:04,680 --> 00:02:07,619
c-sharp although C C plus plus and C

47
00:02:07,619 --> 00:02:10,258
sharp this these two languages they

48
00:02:10,258 --> 00:02:13,379
sound similar but c-sharp is entirely

49
00:02:13,379 --> 00:02:15,360
different in terms of architecture from

50
00:02:15,360 --> 00:02:16,860
C and C plus

51
00:02:16,860 --> 00:02:19,860
and existing tools they didn't work for

52
00:02:19,860 --> 00:02:20,640
me

53
00:02:20,640 --> 00:02:23,700
that is why I decided to create my own

54
00:02:23,700 --> 00:02:26,040
control flow on flattener with a double

55
00:02:26,040 --> 00:02:29,340
zero wiper and fill the Gap in the

56
00:02:29,340 --> 00:02:32,940
knowledge about al-fattening.net

57
00:02:32,940 --> 00:02:35,819
and today I would like to tell you how

58
00:02:35,819 --> 00:02:38,640
you can create your own on flattener for

59
00:02:38,640 --> 00:02:40,260
double zero

60
00:02:40,260 --> 00:02:44,819
but before we go into uh deep into the

61
00:02:44,819 --> 00:02:47,400
implementation details I let's first

62
00:02:47,400 --> 00:02:49,920
discuss uh overall strategy of how we're

63
00:02:49,920 --> 00:02:51,300
going to do it

64
00:02:51,300 --> 00:02:53,640
and to do that let's first look into

65
00:02:53,640 --> 00:02:56,700
double Zero's code in the mspy which is

66
00:02:56,700 --> 00:03:00,000
a.net decompiler so here we have one of

67
00:03:00,000 --> 00:03:03,120
a function let's just scroll down it

68
00:03:03,120 --> 00:03:05,360
as we can see the code is full of junk

69
00:03:05,360 --> 00:03:09,120
and it is unreadable

70
00:03:09,120 --> 00:03:11,040
by the way as you can see here this

71
00:03:11,040 --> 00:03:14,640
function has 317 lines originally this

72
00:03:14,640 --> 00:03:17,700
function consisted of four lines

73
00:03:17,700 --> 00:03:20,340
and although we see junk everywhere it

74
00:03:20,340 --> 00:03:23,540
looks as if code has been made in hell

75
00:03:23,540 --> 00:03:27,060
we can see a pattern in this junk and

76
00:03:27,060 --> 00:03:29,879
let's look at this pattern attentively

77
00:03:29,879 --> 00:03:34,200
over here we have an array of integers

78
00:03:34,200 --> 00:03:37,319
being assigned and if we look at some of

79
00:03:37,319 --> 00:03:40,379
these integers we will notice that they

80
00:03:40,379 --> 00:03:41,940
look quite large and random like here

81
00:03:41,940 --> 00:03:45,540
look 2 billion 1 billion those integers

82
00:03:45,540 --> 00:03:48,659
seem random and we have five such

83
00:03:48,659 --> 00:03:51,420
integers right here and now let's look

84
00:03:51,420 --> 00:03:54,180
at what we do with those integers we

85
00:03:54,180 --> 00:03:56,400
iterate over the arrays of integers in a

86
00:03:56,400 --> 00:03:59,220
while loop and we pass every array to

87
00:03:59,220 --> 00:04:01,200
this function with a random name

88
00:04:01,200 --> 00:04:03,060
let's try to deduce what this function

89
00:04:03,060 --> 00:04:04,080
does

90
00:04:04,080 --> 00:04:05,819
to do that let's look at the return

91
00:04:05,819 --> 00:04:08,640
value it's an integer called num

92
00:04:08,640 --> 00:04:11,159
and this integer as we can see is being

93
00:04:11,159 --> 00:04:15,239
compared to two values 19 and 221 these

94
00:04:15,239 --> 00:04:17,339
are quite small values so our function

95
00:04:17,339 --> 00:04:19,320
accepts quite big integers as an input

96
00:04:19,320 --> 00:04:22,260
and returns small integers is an output

97
00:04:22,260 --> 00:04:24,840
that is why we can deduce that this

98
00:04:24,840 --> 00:04:26,880
function is an integer decryption

99
00:04:26,880 --> 00:04:27,840
function

100
00:04:27,840 --> 00:04:30,060
and now let's see what we do with the

101
00:04:30,060 --> 00:04:32,820
decrypted integer as I've said we

102
00:04:32,820 --> 00:04:38,220
compare it to a number 13 or 121 if the

103
00:04:38,220 --> 00:04:40,500
number is 13 we take this go to

104
00:04:40,500 --> 00:04:41,880
statement right here

105
00:04:41,880 --> 00:04:45,419
and if it's 121 we fall into this large

106
00:04:45,419 --> 00:04:48,000
piece of code and here we have this

107
00:04:48,000 --> 00:04:50,759
pattern that we saw earlier

108
00:04:50,759 --> 00:04:53,040
just by looking at the code with our

109
00:04:53,040 --> 00:04:55,979
Naked Eyes we cannot deduce which if

110
00:04:55,979 --> 00:04:59,220
gets executed first the one with 13 or

111
00:04:59,220 --> 00:05:02,759
the one with 121. however the program

112
00:05:02,759 --> 00:05:06,360
knows how to execute these if conditions

113
00:05:06,360 --> 00:05:09,180
in a correct deterministic order because

114
00:05:09,180 --> 00:05:10,979
it has access to the execution order

115
00:05:10,979 --> 00:05:13,440
array but we reverse Engineers when we

116
00:05:13,440 --> 00:05:16,139
look at it we can see it

117
00:05:16,139 --> 00:05:19,680
and so or this technique that involves

118
00:05:19,680 --> 00:05:21,660
rearranging lines of code in random

119
00:05:21,660 --> 00:05:24,419
order and then using an execution order

120
00:05:24,419 --> 00:05:26,940
array this technique is called control

121
00:05:26,940 --> 00:05:28,560
flow flattening

122
00:05:28,560 --> 00:05:32,100
and now let's try to remove it

123
00:05:32,100 --> 00:05:34,919
but again before we deep down we dig

124
00:05:34,919 --> 00:05:37,139
deep into implementation details we

125
00:05:37,139 --> 00:05:40,560
first have to mark the overall strategy

126
00:05:40,560 --> 00:05:42,600
of how we're going to do it

127
00:05:42,600 --> 00:05:44,639
and this way it will be way more easier

128
00:05:44,639 --> 00:05:46,380
to curl stuff

129
00:05:46,380 --> 00:05:48,600
so as we remember we are dealing with an

130
00:05:48,600 --> 00:05:51,419
execution order array of integers we

131
00:05:51,419 --> 00:05:55,080
need to extract this array

132
00:05:55,080 --> 00:05:58,800
after we do that we need to match every

133
00:05:58,800 --> 00:06:01,620
number in the execution order array to

134
00:06:01,620 --> 00:06:04,680
lines of code that correspond to it let

135
00:06:04,680 --> 00:06:06,419
me show you an example

136
00:06:06,419 --> 00:06:09,419
in the case of num equals 13 we execute

137
00:06:09,419 --> 00:06:11,639
this line a go to statement

138
00:06:11,639 --> 00:06:14,100
we have to mark this line as

139
00:06:14,100 --> 00:06:16,860
corresponding to number 13. as well as

140
00:06:16,860 --> 00:06:19,620
everything that is at that go to

141
00:06:19,620 --> 00:06:23,340
statement namely these lines of code

142
00:06:23,340 --> 00:06:27,300
so we have to mark all the lines which

143
00:06:27,300 --> 00:06:29,940
are executed with a particular execution

144
00:06:29,940 --> 00:06:31,860
order number

145
00:06:31,860 --> 00:06:35,039
and once we do that we have to rearrange

146
00:06:35,039 --> 00:06:37,979
code just move blocks of code and this

147
00:06:37,979 --> 00:06:40,500
way we'll get an unflattened binary

148
00:06:40,500 --> 00:06:43,440
restore the original function

149
00:06:43,440 --> 00:06:46,380
and now let's go over each of the steps

150
00:06:46,380 --> 00:06:47,940
in Greater detail

151
00:06:47,940 --> 00:06:50,880
now about the execution order we all

152
00:06:50,880 --> 00:06:52,919
remember that it is stored in an array

153
00:06:52,919 --> 00:06:55,800
and this array has a type array of

154
00:06:55,800 --> 00:06:57,000
objects

155
00:06:57,000 --> 00:07:00,419
and this array of objects includes

156
00:07:00,419 --> 00:07:02,759
arrays of integers

157
00:07:02,759 --> 00:07:04,860
and in order to detect execution order

158
00:07:04,860 --> 00:07:07,560
arrays in our code we can use those two

159
00:07:07,560 --> 00:07:10,800
data types as a pattern and as we will

160
00:07:10,800 --> 00:07:12,660
see later this pattern is efficient

161
00:07:12,660 --> 00:07:14,639
enough it detects all the execution

162
00:07:14,639 --> 00:07:17,280
order arrays and it does not give any

163
00:07:17,280 --> 00:07:19,699
false positives

164
00:07:19,699 --> 00:07:22,380
now that's pretty much it for the first

165
00:07:22,380 --> 00:07:25,500
step and now the Second Step matching uh

166
00:07:25,500 --> 00:07:27,539
extracting lines that match a certain

167
00:07:27,539 --> 00:07:29,340
execution order number

168
00:07:29,340 --> 00:07:32,400
we can propose the following strategy or

169
00:07:32,400 --> 00:07:35,460
it's kind of obvious like here we can

170
00:07:35,460 --> 00:07:37,800
take the whole binary and decompile it

171
00:07:37,800 --> 00:07:40,680
into C sharp we have will have a files

172
00:07:40,680 --> 00:07:42,720
of code with functions and then we'll

173
00:07:42,720 --> 00:07:45,180
iterate over every function and we'll

174
00:07:45,180 --> 00:07:47,819
find if statements with which compare

175
00:07:47,819 --> 00:07:49,860
the execution or the variable

176
00:07:49,860 --> 00:07:53,160
and then here we have curly braces we

177
00:07:53,160 --> 00:07:55,259
take the code between curly braces

178
00:07:55,259 --> 00:07:58,500
right here and this is our code

179
00:07:58,500 --> 00:08:01,620
but unfortunately this approach it has a

180
00:08:01,620 --> 00:08:04,440
problem and this problem as you may see

181
00:08:04,440 --> 00:08:07,500
maybe it's go to statements here take a

182
00:08:07,500 --> 00:08:09,960
look at num equals 13 and take a look at

183
00:08:09,960 --> 00:08:12,060
this go to statement this go to

184
00:08:12,060 --> 00:08:15,120
statement it leads to code

185
00:08:15,120 --> 00:08:16,380
uh

186
00:08:16,380 --> 00:08:19,800
this code again now this code is outside

187
00:08:19,800 --> 00:08:22,560
the curly braces which corresponds to

188
00:08:22,560 --> 00:08:26,220
the num equals 13 if statement there is

189
00:08:26,220 --> 00:08:29,340
a the brackets ends there and the code

190
00:08:29,340 --> 00:08:32,339
that we need is elsewhere this is why if

191
00:08:32,339 --> 00:08:34,740
we use a strategy of just working with

192
00:08:34,740 --> 00:08:38,820
text we may use where we may lose some

193
00:08:38,820 --> 00:08:40,380
important code

194
00:08:40,380 --> 00:08:44,399
so we need something smarter and we can

195
00:08:44,399 --> 00:08:47,640
arrive at a smarter solution if we treat

196
00:08:47,640 --> 00:08:51,360
code not as a file with text of lines

197
00:08:51,360 --> 00:08:54,500
with lines but as a graph

198
00:08:54,500 --> 00:08:57,839
on the screen you see a graph that

199
00:08:57,839 --> 00:09:00,480
consists of blocks of code and these

200
00:09:00,480 --> 00:09:03,300
blocks of code are connected with arrows

201
00:09:03,300 --> 00:09:05,519
Whenever there is a branch in the code

202
00:09:05,519 --> 00:09:08,700
we connect the two blocks with an with

203
00:09:08,700 --> 00:09:11,040
an arrow and if you look attentive

204
00:09:11,040 --> 00:09:13,260
enough you will notice that we have

205
00:09:13,260 --> 00:09:15,420
three types of arrows here

206
00:09:15,420 --> 00:09:18,959
we have an orange arrow an orange arrow

207
00:09:18,959 --> 00:09:20,880
we draw it if the two blocks are

208
00:09:20,880 --> 00:09:23,640
connected through an unconditional jump

209
00:09:23,640 --> 00:09:26,940
then we have the red arrow a red arrow

210
00:09:26,940 --> 00:09:30,360
means a false branch of an if statement

211
00:09:30,360 --> 00:09:33,540
and a green arrow means a true branch of

212
00:09:33,540 --> 00:09:35,580
an if statement

213
00:09:35,580 --> 00:09:38,700
and these blocks in a of a graph they

214
00:09:38,700 --> 00:09:41,279
are called basic blocks and this whole

215
00:09:41,279 --> 00:09:44,700
graph is called a control flow graph

216
00:09:44,700 --> 00:09:47,160
and now let's see how we can leverage

217
00:09:47,160 --> 00:09:50,100
control flow graphs to match uh

218
00:09:50,100 --> 00:09:52,620
execution all the numbers to blocks of

219
00:09:52,620 --> 00:09:54,019
code

220
00:09:54,019 --> 00:09:57,899
here you can see we have uh some blocks

221
00:09:57,899 --> 00:10:01,019
that have both texts we need to assign

222
00:10:01,019 --> 00:10:03,060
an execution order number to each of

223
00:10:03,060 --> 00:10:05,279
these blocks these are useful blocks

224
00:10:05,279 --> 00:10:07,320
that were present in the original binary

225
00:10:07,320 --> 00:10:08,580
we need them

226
00:10:08,580 --> 00:10:10,860
and now let's see how we can do it I'll

227
00:10:10,860 --> 00:10:12,060
demonstrate

228
00:10:12,060 --> 00:10:14,880
we will start traversing the graph from

229
00:10:14,880 --> 00:10:16,200
the very top

230
00:10:16,200 --> 00:10:18,959
and we'll do that we'll explore all

231
00:10:18,959 --> 00:10:21,959
possible paths in our graph until we hit

232
00:10:21,959 --> 00:10:25,019
an if statement with an execution order

233
00:10:25,019 --> 00:10:28,019
variable let me show you that to you we

234
00:10:28,019 --> 00:10:29,880
are currently located in the top node

235
00:10:29,880 --> 00:10:32,399
and then we follow the orange arrow and

236
00:10:32,399 --> 00:10:35,100
we go down into the while loop

237
00:10:35,100 --> 00:10:37,260
here you can see we have two arrows two

238
00:10:37,260 --> 00:10:40,019
branches the Red Branch leads to a

239
00:10:40,019 --> 00:10:42,120
return statement if this is at that end

240
00:10:42,120 --> 00:10:45,480
we go to another branch which is in our

241
00:10:45,480 --> 00:10:47,579
case an if condition

242
00:10:47,579 --> 00:10:49,200
this is the if conditions that we need

243
00:10:49,200 --> 00:10:51,120
in it compares the execution or the

244
00:10:51,120 --> 00:10:52,019
variable

245
00:10:52,019 --> 00:10:54,779
whenever we see such an if condition we

246
00:10:54,779 --> 00:10:57,240
enter marking mode let me explain what

247
00:10:57,240 --> 00:10:58,800
marking mode is

248
00:10:58,800 --> 00:11:00,720
we go to the true branch of the if

249
00:11:00,720 --> 00:11:04,200
condition and we again explore all

250
00:11:04,200 --> 00:11:06,839
possible branches that we see but the

251
00:11:06,839 --> 00:11:08,760
difference is that if we see a new block

252
00:11:08,760 --> 00:11:12,240
we mark it as a corresponding to an

253
00:11:12,240 --> 00:11:14,760
execution order number again let me

254
00:11:14,760 --> 00:11:15,899
demonstrate that

255
00:11:15,899 --> 00:11:18,800
we go to the true branch and we hit

256
00:11:18,800 --> 00:11:23,640
block 1 of number equals 121 and we

257
00:11:23,640 --> 00:11:26,579
assign it a color a color means an

258
00:11:26,579 --> 00:11:28,800
execution order number and blue color in

259
00:11:28,800 --> 00:11:31,860
our case means 121.

260
00:11:31,860 --> 00:11:35,760
then we have two branches here let's go

261
00:11:35,760 --> 00:11:37,800
first to the true branch of the if

262
00:11:37,800 --> 00:11:40,560
statement by doing that we arrive at

263
00:11:40,560 --> 00:11:43,079
block three it is a new block we mark it

264
00:11:43,079 --> 00:11:45,060
we assign it to color

265
00:11:45,060 --> 00:11:48,959
from here we follow the orange arrow and

266
00:11:48,959 --> 00:11:51,660
we arrive at the I plus plus block now

267
00:11:51,660 --> 00:11:54,060
this block what it does is that it only

268
00:11:54,060 --> 00:11:57,060
increments the index used for the

269
00:11:57,060 --> 00:11:59,339
execution order array it does not

270
00:11:59,339 --> 00:12:01,680
correspond to any of the execution order

271
00:12:01,680 --> 00:12:02,700
numbers

272
00:12:02,700 --> 00:12:04,800
you can notice that it can be reached

273
00:12:04,800 --> 00:12:07,560
from num equals 13 on the graph

274
00:12:07,560 --> 00:12:10,820
that is why when we reach this block we

275
00:12:10,820 --> 00:12:14,100
consider this Branch at that end and we

276
00:12:14,100 --> 00:12:17,040
go to another branch which we'll do and

277
00:12:17,040 --> 00:12:19,200
this new Branch will be the false

278
00:12:19,200 --> 00:12:23,579
condition of the a if statement the red

279
00:12:23,579 --> 00:12:27,060
arrow of Row one by following it we go

280
00:12:27,060 --> 00:12:29,519
to block two again assign it an

281
00:12:29,519 --> 00:12:33,600
execution order number blue is 121. now

282
00:12:33,600 --> 00:12:37,019
we go to the orange arrow and again we

283
00:12:37,019 --> 00:12:40,560
arrive at I plus plus again at that end

284
00:12:40,560 --> 00:12:43,200
now we have finished exploring the num

285
00:12:43,200 --> 00:12:46,380
equals 121 Branch but we have another if

286
00:12:46,380 --> 00:12:49,019
condition here num equals 13.

287
00:12:49,019 --> 00:12:51,420
let's again follow the steps that we've

288
00:12:51,420 --> 00:12:53,540
done before we go to the true Branch

289
00:12:53,540 --> 00:12:57,480
encounter a block and Mark it uh now the

290
00:12:57,480 --> 00:13:00,600
color is green green means 13. then we

291
00:13:00,600 --> 00:13:03,899
go to the orange uh Arrow again I plus

292
00:13:03,899 --> 00:13:06,060
plus again at that end

293
00:13:06,060 --> 00:13:08,399
and as you can see here we have

294
00:13:08,399 --> 00:13:10,440
successfully assigned a color and

295
00:13:10,440 --> 00:13:13,560
execution order number to each of the

296
00:13:13,560 --> 00:13:16,939
blocks with bold text

297
00:13:16,980 --> 00:13:19,440
and this is it for matching lines of

298
00:13:19,440 --> 00:13:21,540
code and now we have to perform

299
00:13:21,540 --> 00:13:24,180
reordering let me show you what I mean

300
00:13:24,180 --> 00:13:27,000
by reordering let's say we have to

301
00:13:27,000 --> 00:13:29,940
execute the green block after the Blue

302
00:13:29,940 --> 00:13:34,019
Block we first execute 121 and then 13.

303
00:13:34,019 --> 00:13:35,880
in order to connect the blocks in the

304
00:13:35,880 --> 00:13:39,120
correct order we have to attach the Blue

305
00:13:39,120 --> 00:13:40,920
Block number two to the green block

306
00:13:40,920 --> 00:13:42,779
number one and the Blue Block number

307
00:13:42,779 --> 00:13:45,360
three to the green block number one and

308
00:13:45,360 --> 00:13:47,519
if we do that we'll obtain something

309
00:13:47,519 --> 00:13:50,279
like this and this is the control flow

310
00:13:50,279 --> 00:13:53,880
graph for the Agape scale function now

311
00:13:53,880 --> 00:13:57,300
all we have to do is convert this graph

312
00:13:57,300 --> 00:14:00,360
to c-sharp code and we'll obtain the

313
00:14:00,360 --> 00:14:02,480
unslattened function

314
00:14:02,480 --> 00:14:05,880
so that's it for the strategy and now

315
00:14:05,880 --> 00:14:07,380
let's see how we can automate the

316
00:14:07,380 --> 00:14:10,139
unfattening how we can code the on

317
00:14:10,139 --> 00:14:13,860
flattener to do that we'll use D for DOT

318
00:14:13,860 --> 00:14:16,740
it's a command line utility it's a

319
00:14:16,740 --> 00:14:18,839
popular command line of utility used for

320
00:14:18,839 --> 00:14:21,720
the obfuscating.net binaries

321
00:14:21,720 --> 00:14:24,959
and you may have heard of D4 dot when

322
00:14:24,959 --> 00:14:27,060
you're performing dotnet malware

323
00:14:27,060 --> 00:14:29,000
analysis you may have used it for

324
00:14:29,000 --> 00:14:32,279
unpacking.net malware or for performing

325
00:14:32,279 --> 00:14:34,260
string decryption in.net

326
00:14:34,260 --> 00:14:37,800
so this tool it already implements the

327
00:14:37,800 --> 00:14:40,500
obfuscatus for popular.net protectors

328
00:14:40,500 --> 00:14:44,220
such as.net reactor but today we're not

329
00:14:44,220 --> 00:14:46,680
going to just launch the photo instead

330
00:14:46,680 --> 00:14:50,399
we are going to modify its code and add

331
00:14:50,399 --> 00:14:52,440
our own geophysicator to it

332
00:14:52,440 --> 00:14:55,199
and as we will see working with default

333
00:14:55,199 --> 00:14:58,019
turns out to be very comfortable

334
00:14:58,019 --> 00:15:00,060
in order to start working with D4 dot

335
00:15:00,060 --> 00:15:01,920
you have to head to its official

336
00:15:01,920 --> 00:15:04,579
repository and download the source code

337
00:15:04,579 --> 00:15:08,339
then you open it in Visual Studio

338
00:15:08,339 --> 00:15:12,180
after that you head to the default.code

339
00:15:12,180 --> 00:15:15,000
project and open a folder called the

340
00:15:15,000 --> 00:15:18,060
obfuscatus and this folder it contains

341
00:15:18,060 --> 00:15:20,519
many subfolders it has this folder

342
00:15:20,519 --> 00:15:22,019
corresponds to a different job for

343
00:15:22,019 --> 00:15:25,380
skater will create our own folder in it

344
00:15:25,380 --> 00:15:28,019
and create our own the obfuscator we'll

345
00:15:28,019 --> 00:15:30,899
name our folder double zero

346
00:15:30,899 --> 00:15:33,779
then we have to place a template file

347
00:15:33,779 --> 00:15:36,360
for our theophiscator what's important

348
00:15:36,360 --> 00:15:39,120
to know about this template file is that

349
00:15:39,120 --> 00:15:42,600
we have to assign a name for our job

350
00:15:42,600 --> 00:15:45,120
skater which will be double zero in our

351
00:15:45,120 --> 00:15:45,959
case

352
00:15:45,959 --> 00:15:48,300
and once we assign the name we can

353
00:15:48,300 --> 00:15:50,880
compile defa Dot and launch it through

354
00:15:50,880 --> 00:15:53,160
the command line and if we have done

355
00:15:53,160 --> 00:15:56,279
everything correctly we will see the

356
00:15:56,279 --> 00:15:59,160
description of our the obfuscater appear

357
00:15:59,160 --> 00:16:03,300
among the list of all the obfuscators

358
00:16:03,300 --> 00:16:06,180
so right now our the obfuscater does

359
00:16:06,180 --> 00:16:08,760
nothing it's just a template and let's

360
00:16:08,760 --> 00:16:10,680
add useful features to it

361
00:16:10,680 --> 00:16:13,260
as we remember our strategy heavily

362
00:16:13,260 --> 00:16:15,600
relies on constructing control flow

363
00:16:15,600 --> 00:16:17,519
graphs of functions

364
00:16:17,519 --> 00:16:21,899
D4 dot allows you to do that by defining

365
00:16:21,899 --> 00:16:24,180
a class that's called a block job for

366
00:16:24,180 --> 00:16:25,279
scator

367
00:16:25,279 --> 00:16:27,959
we should Define this class in our code

368
00:16:27,959 --> 00:16:30,720
and it should implement the I block the

369
00:16:30,720 --> 00:16:32,399
obfuscater interface

370
00:16:32,399 --> 00:16:34,680
as you can see from the slide this

371
00:16:34,680 --> 00:16:37,380
interface has three methods we are

372
00:16:37,380 --> 00:16:39,600
interested only in the last one which is

373
00:16:39,600 --> 00:16:41,220
called the obfuscate

374
00:16:41,220 --> 00:16:44,459
now if we Define this method then D for

375
00:16:44,459 --> 00:16:47,699
DOT will iterate over every function in

376
00:16:47,699 --> 00:16:49,440
the obfuscated binary

377
00:16:49,440 --> 00:16:51,540
it will construct a control flow graph

378
00:16:51,540 --> 00:16:52,920
for every function

379
00:16:52,920 --> 00:16:55,380
and for every function it will call the

380
00:16:55,380 --> 00:16:57,240
obfuscate method of our block the

381
00:16:57,240 --> 00:16:58,500
obfuscater

382
00:16:58,500 --> 00:17:00,720
it will pass the constructed control

383
00:17:00,720 --> 00:17:03,660
flow graph as a list of blocks in the

384
00:17:03,660 --> 00:17:06,359
all blocks argument and then we'll

385
00:17:06,359 --> 00:17:09,359
iterate over this list of blocks

386
00:17:09,359 --> 00:17:11,579
while iterating we'll be looking for

387
00:17:11,579 --> 00:17:14,220
execution order arrays we have already

388
00:17:14,220 --> 00:17:18,119
agreed to uh detect those execution

389
00:17:18,119 --> 00:17:22,199
order arrays with data types the array

390
00:17:22,199 --> 00:17:25,500
of objects and the array of integers

391
00:17:25,500 --> 00:17:27,780
but before we do any pattern matching

392
00:17:27,780 --> 00:17:30,299
before we code any pattern matching we

393
00:17:30,299 --> 00:17:34,260
need a first uh null that in default

394
00:17:34,260 --> 00:17:36,600
control flow graphs unlike we saw

395
00:17:36,600 --> 00:17:39,480
earlier they do not contain c-sharp code

396
00:17:39,480 --> 00:17:42,539
instead they contain a special kind of

397
00:17:42,539 --> 00:17:45,120
of assembly called Intermediate Language

398
00:17:45,120 --> 00:17:47,880
it's a special assembly for dotnet

399
00:17:47,880 --> 00:17:49,260
binaries

400
00:17:49,260 --> 00:17:53,820
and we can compare the c-sharp code with

401
00:17:53,820 --> 00:17:56,640
assembly in the end spy if we hear

402
00:17:56,640 --> 00:17:58,980
select Intermediate Language so this is

403
00:17:58,980 --> 00:18:02,280
how this assembly looks like

404
00:18:02,280 --> 00:18:05,039
and if we compare the c-sharp code and

405
00:18:05,039 --> 00:18:07,860
the assembly for assigning uh something

406
00:18:07,860 --> 00:18:10,140
to an array of objects we will see that

407
00:18:10,140 --> 00:18:13,080
it contains two instructions we are

408
00:18:13,080 --> 00:18:14,220
interested in the second instruction

409
00:18:14,220 --> 00:18:16,799
which is called New r

410
00:18:16,799 --> 00:18:18,720
we can use this instruction to perform

411
00:18:18,720 --> 00:18:20,640
pattern matching and let me show you how

412
00:18:20,640 --> 00:18:22,679
you can do that in C sharp

413
00:18:22,679 --> 00:18:25,559
we first check that the opcode of the

414
00:18:25,559 --> 00:18:26,940
instruction the name of the instruction

415
00:18:26,940 --> 00:18:30,360
is called New R and then we check that

416
00:18:30,360 --> 00:18:32,100
the operand the parameter of this

417
00:18:32,100 --> 00:18:34,860
instruction is system.object

418
00:18:34,860 --> 00:18:37,919
now if this pattern works then we are

419
00:18:37,919 --> 00:18:39,720
probably dealing with an execution order

420
00:18:39,720 --> 00:18:41,280
array

421
00:18:41,280 --> 00:18:43,140
and what we need to do next is to

422
00:18:43,140 --> 00:18:45,240
extract numbers from it

423
00:18:45,240 --> 00:18:48,299
now if we again go to the end spy and

424
00:18:48,299 --> 00:18:49,740
compare the c-sharp code with

425
00:18:49,740 --> 00:18:51,840
Intermediate Language we will notice

426
00:18:51,840 --> 00:18:55,020
that an assignment of an integer array

427
00:18:55,020 --> 00:18:57,299
with a constant value gets compiled to

428
00:18:57,299 --> 00:18:59,880
three instructions we are interested

429
00:18:59,880 --> 00:19:01,799
only in the first instruction which is

430
00:19:01,799 --> 00:19:03,480
called LT token

431
00:19:03,480 --> 00:19:05,880
it's important to us because this is the

432
00:19:05,880 --> 00:19:07,320
operand the parameter of this

433
00:19:07,320 --> 00:19:10,799
instruction it contains a circle token a

434
00:19:10,799 --> 00:19:14,340
token is a reference to the array value

435
00:19:14,340 --> 00:19:17,100
in order to extract a value from the

436
00:19:17,100 --> 00:19:19,620
token in c-sharp in this default we have

437
00:19:19,620 --> 00:19:21,179
to go we have to take the instructions

438
00:19:21,179 --> 00:19:24,240
operand and then take its initial Value

439
00:19:24,240 --> 00:19:27,299
method by doing that we'll obtain an

440
00:19:27,299 --> 00:19:30,120
array of bytes but we don't need an

441
00:19:30,120 --> 00:19:32,160
array of bytes we need an array of

442
00:19:32,160 --> 00:19:33,299
integers

443
00:19:33,299 --> 00:19:35,880
in order to convert an array of bytes to

444
00:19:35,880 --> 00:19:39,780
an array of integers we need to group

445
00:19:39,780 --> 00:19:42,960
every four integers every four bytes we

446
00:19:42,960 --> 00:19:44,880
have a group every four bytes into an

447
00:19:44,880 --> 00:19:47,340
integer and the Order of bytes is Little

448
00:19:47,340 --> 00:19:48,240
Engine

449
00:19:48,240 --> 00:19:51,059
and then once we do that for every array

450
00:19:51,059 --> 00:19:54,179
we will pass every array to the

451
00:19:54,179 --> 00:19:56,160
decryption function and by doing that

452
00:19:56,160 --> 00:19:59,100
we'll obtain an array of integers with

453
00:19:59,100 --> 00:20:01,500
the execution order like in our case the

454
00:20:01,500 --> 00:20:04,559
array would consist of two values 13 and

455
00:20:04,559 --> 00:20:07,260
121.

456
00:20:07,260 --> 00:20:10,080
now what we also did at the second step

457
00:20:10,080 --> 00:20:12,660
is that we Traverse the control flow

458
00:20:12,660 --> 00:20:15,299
graph but we didn't just explore all the

459
00:20:15,299 --> 00:20:18,059
basic blocks in a random order

460
00:20:18,059 --> 00:20:21,240
we follow the arrows we can't just

461
00:20:21,240 --> 00:20:23,160
iterate over the blocks in the for Loop

462
00:20:23,160 --> 00:20:25,799
we need to iterate over the blocks

463
00:20:25,799 --> 00:20:28,620
through arrows and default also allows

464
00:20:28,620 --> 00:20:31,380
you to do that a block object in D for

465
00:20:31,380 --> 00:20:35,400
DOT it has two Fields the first field is

466
00:20:35,400 --> 00:20:38,039
called fall through a forceful field

467
00:20:38,039 --> 00:20:41,640
corresponds to either a orange arrow and

468
00:20:41,640 --> 00:20:45,360
unconditional jump or a red arrow which

469
00:20:45,360 --> 00:20:47,940
is a false branch of an if statement you

470
00:20:47,940 --> 00:20:50,460
can see an example on the graph at the

471
00:20:50,460 --> 00:20:51,240
screen

472
00:20:51,240 --> 00:20:53,460
and another member is called targets

473
00:20:53,460 --> 00:20:57,840
it's an array it may correspond to a

474
00:20:57,840 --> 00:20:59,760
green arrow a true branch of an if

475
00:20:59,760 --> 00:21:02,520
statement or it may correspond to a

476
00:21:02,520 --> 00:21:03,840
switch statement

477
00:21:03,840 --> 00:21:06,660
by exploring the graph through those

478
00:21:06,660 --> 00:21:10,140
fall through and targets fields we will

479
00:21:10,140 --> 00:21:12,840
be able to follow the arrows and

480
00:21:12,840 --> 00:21:15,059
Traverse the graph in the order that we

481
00:21:15,059 --> 00:21:18,840
need and uh extra and visit every basic

482
00:21:18,840 --> 00:21:20,400
block

483
00:21:20,400 --> 00:21:22,559
and now the last step reconnecting

484
00:21:22,559 --> 00:21:23,760
blocks

485
00:21:23,760 --> 00:21:26,280
surprisingly in default you can perform

486
00:21:26,280 --> 00:21:29,280
reconnection of basic blocks in just one

487
00:21:29,280 --> 00:21:30,539
line of code

488
00:21:30,539 --> 00:21:34,620
imagine if you had to perform basic

489
00:21:34,620 --> 00:21:36,720
block reconnection in a disassembler

490
00:21:36,720 --> 00:21:40,140
such as Ida or gidra in this case you

491
00:21:40,140 --> 00:21:42,000
would probably have to write a script

492
00:21:42,000 --> 00:21:44,640
like an either python script consisting

493
00:21:44,640 --> 00:21:47,280
of at least maybe a hundred lines but

494
00:21:47,280 --> 00:21:49,500
with different dot it's just one line of

495
00:21:49,500 --> 00:21:50,280
code

496
00:21:50,280 --> 00:21:52,260
if he wanted two blocks to be connected

497
00:21:52,260 --> 00:21:55,080
through an unconditional jump then we

498
00:21:55,080 --> 00:21:57,240
use the set new falls through method

499
00:21:57,240 --> 00:22:00,059
an unconditional jump it may correspond

500
00:22:00,059 --> 00:22:04,799
to either a orange or a red arrow but if

501
00:22:04,799 --> 00:22:05,880
we want the blocks to be connected

502
00:22:05,880 --> 00:22:07,559
through a true branch of an if statement

503
00:22:07,559 --> 00:22:11,159
then we use the set new Target method in

504
00:22:11,159 --> 00:22:13,679
all cases the new Target block is

505
00:22:13,679 --> 00:22:16,559
specified in the method arguments

506
00:22:16,559 --> 00:22:19,679
and once we do that we have to piece

507
00:22:19,679 --> 00:22:22,320
those three steps in a single program in

508
00:22:22,320 --> 00:22:24,419
a single job obfuscator and then we'll

509
00:22:24,419 --> 00:22:27,600
be able to launch a default and it will

510
00:22:27,600 --> 00:22:31,080
uh the office case the binary if you are

511
00:22:31,080 --> 00:22:35,700
interested in low level details uh I

512
00:22:35,700 --> 00:22:37,740
suggest you to look at my code of the

513
00:22:37,740 --> 00:22:40,620
obfuscater on GitHub

514
00:22:40,620 --> 00:22:43,679
and as for the foreign strategy that we

515
00:22:43,679 --> 00:22:46,140
use today it can be applied to any

516
00:22:46,140 --> 00:22:48,480
programming language it's independent of

517
00:22:48,480 --> 00:22:50,400
a programming language all you need to

518
00:22:50,400 --> 00:22:53,940
do is a way to uh extract execution

519
00:22:53,940 --> 00:22:55,679
order numbers the execution order

520
00:22:55,679 --> 00:22:58,080
sequence then you have to match every

521
00:22:58,080 --> 00:23:01,020
number in the sequence to lines of code

522
00:23:01,020 --> 00:23:04,080
and then to reconnect those lines of

523
00:23:04,080 --> 00:23:05,039
code

524
00:23:05,039 --> 00:23:07,080
and as for default

525
00:23:07,080 --> 00:23:10,320
uh s4.net it turned out to be extremely

526
00:23:10,320 --> 00:23:12,480
convenient to perform all those three

527
00:23:12,480 --> 00:23:14,340
steps using default

528
00:23:14,340 --> 00:23:17,340
and that is because default allows you

529
00:23:17,340 --> 00:23:19,740
to perform complex things like uh

530
00:23:19,740 --> 00:23:22,980
reconnecting blocks as we saw in a

531
00:23:22,980 --> 00:23:27,419
rather small number of code one line in

532
00:23:27,419 --> 00:23:29,100
our case

533
00:23:29,100 --> 00:23:31,860
when I was coding the obfuscator I

534
00:23:31,860 --> 00:23:34,919
expected it to be at least or a few

535
00:23:34,919 --> 00:23:37,500
thousand lines long but much to my

536
00:23:37,500 --> 00:23:41,400
surprise uh it turned out to be only 250

537
00:23:41,400 --> 00:23:44,280
block of 250 lines of code

538
00:23:44,280 --> 00:23:46,260
for a complex obfuscation such as

539
00:23:46,260 --> 00:23:49,080
control flow flattening I believe that

540
00:23:49,080 --> 00:23:52,080
it's amazing maybe the code of the

541
00:23:52,080 --> 00:23:54,000
obfuscater that the malware developers

542
00:23:54,000 --> 00:23:56,460
used maybe it had more lines than the

543
00:23:56,460 --> 00:23:59,179
obfuscate

544
00:23:59,820 --> 00:24:02,280
I hope that today I help you learn

545
00:24:02,280 --> 00:24:05,100
something new about a control flow on

546
00:24:05,100 --> 00:24:07,820
flattening or default

547
00:24:07,820 --> 00:24:11,400
I advise you to go to the GitHub

548
00:24:11,400 --> 00:24:13,740
repository with the on flattener and

549
00:24:13,740 --> 00:24:16,340
take a look at it the code is very small

550
00:24:16,340 --> 00:24:20,100
250 lines and I put comments into it I

551
00:24:20,100 --> 00:24:22,080
put a lot of comments into it I try to

552
00:24:22,080 --> 00:24:24,360
make it as readable as possible I

553
00:24:24,360 --> 00:24:27,539
especially advise you to do that if you

554
00:24:27,539 --> 00:24:30,059
ever try to understand how to perform

555
00:24:30,059 --> 00:24:31,860
control flow on flattening maybe if you

556
00:24:31,860 --> 00:24:33,900
try to search for some articles for some

557
00:24:33,900 --> 00:24:36,000
reason you couldn't figure it out in

558
00:24:36,000 --> 00:24:38,880
this case please download the code load

559
00:24:38,880 --> 00:24:41,220
it into visual studio and debug it step

560
00:24:41,220 --> 00:24:44,640
by step explore the variables their

561
00:24:44,640 --> 00:24:47,460
values and once you spend some time

562
00:24:47,460 --> 00:24:50,580
debugging the code and running step by

563
00:24:50,580 --> 00:24:53,640
step I'm sure that you will understand

564
00:24:53,640 --> 00:24:55,620
how to perform control flow on

565
00:24:55,620 --> 00:24:58,080
threatening and right now if you have

566
00:24:58,080 --> 00:25:00,000
any questions I'm ready to answer them

567
00:25:00,000 --> 00:25:01,600
thank you

568
00:25:01,600 --> 00:25:04,799
[Applause]

569
00:25:04,799 --> 00:25:06,780
thank you Georgie for the interesting

570
00:25:06,780 --> 00:25:09,240
presentation we have plenty of time for

571
00:25:09,240 --> 00:25:13,400
questions one is at the back

572
00:25:13,500 --> 00:25:16,080
hey man uh firstly that was that was

573
00:25:16,080 --> 00:25:17,580
awesome I know you're a second year

574
00:25:17,580 --> 00:25:19,620
student at University like your

575
00:25:19,620 --> 00:25:22,380
trajectory is insane so uh congrats that

576
00:25:22,380 --> 00:25:23,340
was awesome

577
00:25:23,340 --> 00:25:26,279
um the the control flow flattening

578
00:25:26,279 --> 00:25:28,500
technique is that is is that something

579
00:25:28,500 --> 00:25:30,840
that's implemented by a number of threat

580
00:25:30,840 --> 00:25:32,820
actors that you've seen or is that is it

581
00:25:32,820 --> 00:25:36,000
specific to to double zero on its own

582
00:25:36,000 --> 00:25:37,740
thank you very much for your question I

583
00:25:37,740 --> 00:25:40,020
met a control flow flattening in many

584
00:25:40,020 --> 00:25:43,440
malware families I first of all a common

585
00:25:43,440 --> 00:25:46,200
malware family is like imoted it's there

586
00:25:46,200 --> 00:25:49,260
then uh it's also implemented in complex

587
00:25:49,260 --> 00:25:52,740
malware like Finn Fisher it was a

588
00:25:52,740 --> 00:25:56,760
malware a commercial spyware uh an apt

589
00:25:56,760 --> 00:25:59,159
it also had control flow flattening in

590
00:25:59,159 --> 00:26:02,039
CMC plus plus so it is quite widespread

591
00:26:02,039 --> 00:26:04,320
but although it is widespread every

592
00:26:04,320 --> 00:26:05,880
malware developer implements control

593
00:26:05,880 --> 00:26:08,340
flow of flattening in their own way and

594
00:26:08,340 --> 00:26:10,740
that is why there is no Silver Bullet to

595
00:26:10,740 --> 00:26:13,700
countering it in every case you have to

596
00:26:13,700 --> 00:26:17,159
find pattern matching stuff and for

597
00:26:17,159 --> 00:26:18,779
every malware you have to tune the

598
00:26:18,779 --> 00:26:21,440
obfuscater

599
00:26:24,480 --> 00:26:27,059
any more questions uh I have one

600
00:26:27,059 --> 00:26:28,760
question if there are no more questions

601
00:26:28,760 --> 00:26:31,799
so you say you practically have to write

602
00:26:31,799 --> 00:26:34,799
a new obfuscater for each each family

603
00:26:34,799 --> 00:26:37,500
how much time does it take in your

604
00:26:37,500 --> 00:26:40,320
estimation uh it depends on the level if

605
00:26:40,320 --> 00:26:42,299
you are experienced with writing the

606
00:26:42,299 --> 00:26:44,159
obfuscatus if you ever wrote one on

607
00:26:44,159 --> 00:26:46,740
flattener then it will maybe take just

608
00:26:46,740 --> 00:26:49,380
maybe one from few hours to one day to

609
00:26:49,380 --> 00:26:51,539
tune whatever you have it depends on the

610
00:26:51,539 --> 00:26:54,720
complexity and the language for me I had

611
00:26:54,720 --> 00:26:57,480
no prior experience of writing uh from

612
00:26:57,480 --> 00:27:00,659
scratch the obfuscater so uncertain as I

613
00:27:00,659 --> 00:27:01,980
didn't have any experience so I spent

614
00:27:01,980 --> 00:27:03,600
like about three days like looking

615
00:27:03,600 --> 00:27:05,240
through difficult code and then

616
00:27:05,240 --> 00:27:07,799
exploring the possibilities it took me

617
00:27:07,799 --> 00:27:08,760
three days

618
00:27:08,760 --> 00:27:11,760
and in the case of double zero maybe you

619
00:27:11,760 --> 00:27:16,200
analyzed it it's a small wiper and if

620
00:27:16,200 --> 00:27:19,260
you uh uh out of time it may be actually

621
00:27:19,260 --> 00:27:21,240
better to just run the code in a

622
00:27:21,240 --> 00:27:23,460
debugger but it's important to know how

623
00:27:23,460 --> 00:27:25,020
to perform such things because if you

624
00:27:25,020 --> 00:27:27,600
have a sophisticated uh framework

625
00:27:27,600 --> 00:27:31,380
consisting of tens of modules then just

626
00:27:31,380 --> 00:27:33,059
running everything in a debugger won't

627
00:27:33,059 --> 00:27:35,340
work and you have to resort to static

628
00:27:35,340 --> 00:27:39,659
analysis so it depends on the complexity

629
00:27:39,659 --> 00:27:43,940
and whatever level of knowledge you have

630
00:27:43,980 --> 00:27:45,900
thank you again for the interesting

631
00:27:45,900 --> 00:27:47,890
presentation okay very useful

632
00:27:47,890 --> 00:27:51,159
[Applause]

