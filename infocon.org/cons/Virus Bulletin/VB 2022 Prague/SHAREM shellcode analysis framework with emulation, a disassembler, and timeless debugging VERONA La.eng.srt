1
00:00:02,580 --> 00:00:04,319
thank you for that wonderful

2
00:00:04,319 --> 00:00:06,899
introduction so our topic is sharums

3
00:00:06,899 --> 00:00:10,260
shelter analysis and framework

4
00:00:10,260 --> 00:00:12,540
my name is Dr Bramwell brzendine I'm an

5
00:00:12,540 --> 00:00:13,920
assistant professor at the University of

6
00:00:13,920 --> 00:00:16,379
Alabama in Huntsville I'm also the

7
00:00:16,379 --> 00:00:17,940
former director of the Verona lab which

8
00:00:17,940 --> 00:00:20,220
is the entity responsible for This

9
00:00:20,220 --> 00:00:22,980
research creator of the job rocket for

10
00:00:22,980 --> 00:00:25,800
jump oriented programming and I'm also

11
00:00:25,800 --> 00:00:28,019
the pi on the research grant that

12
00:00:28,019 --> 00:00:30,599
allowed us to fund this uh this

13
00:00:30,599 --> 00:00:32,820
wonderful research that we did and I

14
00:00:32,820 --> 00:00:36,480
have a PhD in cyber operations

15
00:00:36,480 --> 00:00:39,120
we have several different uh co-authors

16
00:00:39,120 --> 00:00:41,340
and contributors they include Jake

17
00:00:41,340 --> 00:00:45,600
Austin Shelby Sasha and Tariq uh here

18
00:00:45,600 --> 00:00:48,899
today we also have Shelby and Sasha who

19
00:00:48,899 --> 00:00:50,160
will be speaking

20
00:00:50,160 --> 00:00:52,620
uh we'd also like to recognize other

21
00:00:52,620 --> 00:00:55,020
contributors Evan Reed Dylan Park and

22
00:00:55,020 --> 00:00:57,059
Cade brost

23
00:00:57,059 --> 00:00:58,980
so let's start with the kind of a

24
00:00:58,980 --> 00:01:02,160
summary style introduction to to Sharon

25
00:01:02,160 --> 00:01:05,040
so it's a framework designed to be a

26
00:01:05,040 --> 00:01:06,900
total solution to anything and

27
00:01:06,900 --> 00:01:08,939
everything related to Shell Code and

28
00:01:08,939 --> 00:01:12,119
specifically Windows Shell Code

29
00:01:12,119 --> 00:01:14,939
uh funded by an NSA research Grant over

30
00:01:14,939 --> 00:01:17,520
a two-year period

31
00:01:17,520 --> 00:01:18,299
um

32
00:01:18,299 --> 00:01:20,280
with three hundred thousand dollars this

33
00:01:20,280 --> 00:01:22,080
allowed us to do a tremendous amount of

34
00:01:22,080 --> 00:01:24,659
work uh has numerous special features

35
00:01:24,659 --> 00:01:26,159
it's able to emulate Shell Code

36
00:01:26,159 --> 00:01:29,100
including windows apis and for the first

37
00:01:29,100 --> 00:01:31,979
time ever ever uh Windows assist calls

38
00:01:31,979 --> 00:01:34,860
it has a custom disassembler with some

39
00:01:34,860 --> 00:01:36,840
unprecedented features that we will

40
00:01:36,840 --> 00:01:39,240
learn about additionally it has the

41
00:01:39,240 --> 00:01:41,460
ability to do Timeless debugging and

42
00:01:41,460 --> 00:01:44,100
brute force de-offification of encrypted

43
00:01:44,100 --> 00:01:46,140
Shell Code now the last point is one we

44
00:01:46,140 --> 00:01:47,939
won't have time to dive into so I'll

45
00:01:47,939 --> 00:01:50,040
just briefly explain what it is you can

46
00:01:50,040 --> 00:01:51,479
read about it in the paper if you are

47
00:01:51,479 --> 00:01:54,299
interested so the Brute Force brute

48
00:01:54,299 --> 00:01:57,380
force de-offification can enable us to

49
00:01:57,380 --> 00:01:59,520
de-officate the Shell Code without

50
00:01:59,520 --> 00:02:01,740
emulation

51
00:02:01,740 --> 00:02:03,600
um and even without a decoder stud being

52
00:02:03,600 --> 00:02:05,100
present and it also has support for

53
00:02:05,100 --> 00:02:08,098
distributed computing as well

54
00:02:08,098 --> 00:02:10,919
okay so let's dive straight into the

55
00:02:10,919 --> 00:02:13,080
emulator which is the heart and the soul

56
00:02:13,080 --> 00:02:14,940
of Sharon

57
00:02:14,940 --> 00:02:17,280
so it does utilize unicorn engine and

58
00:02:17,280 --> 00:02:19,800
provides support for both 32 as well as

59
00:02:19,800 --> 00:02:22,560
64-bit Shell Code and again Windows

60
00:02:22,560 --> 00:02:24,360
assist calls

61
00:02:24,360 --> 00:02:26,900
uh virtually all of those are supported

62
00:02:26,900 --> 00:02:30,060
Sharon is able to discover not only the

63
00:02:30,060 --> 00:02:33,540
parameters to these apis but also

64
00:02:33,540 --> 00:02:36,239
complete structures which is also an

65
00:02:36,239 --> 00:02:38,580
unprecedented feature sherim is also

66
00:02:38,580 --> 00:02:40,739
able to take this emulation data to

67
00:02:40,739 --> 00:02:42,480
merge it with a disassembler and to

68
00:02:42,480 --> 00:02:45,480
provide nearly Flawless disassembly for

69
00:02:45,480 --> 00:02:47,700
the Shell Code so let's talk about the

70
00:02:47,700 --> 00:02:50,940
initial setup of share share them it is

71
00:02:50,940 --> 00:02:52,440
a little bit uh unusual a little bit

72
00:02:52,440 --> 00:02:54,599
different but what we would do is we go

73
00:02:54,599 --> 00:02:58,980
and harvest actual dlls from CIS wow 64

74
00:02:58,980 --> 00:03:03,239
and system 32 both for 32 and 64-bit

75
00:03:03,239 --> 00:03:05,580
Shell Code we Harvest these and then we

76
00:03:05,580 --> 00:03:08,280
inflate each of them a very precise

77
00:03:08,280 --> 00:03:11,040
amount according to the PE file format

78
00:03:11,040 --> 00:03:13,920
specifications we kind of created a sort

79
00:03:13,920 --> 00:03:16,379
of formula allowing us to do that the

80
00:03:16,379 --> 00:03:18,780
reason why is if we have a dll on disk

81
00:03:18,780 --> 00:03:21,360
it's not equivalent to the dll once it's

82
00:03:21,360 --> 00:03:23,459
in memory so it is absolutely necessary

83
00:03:23,459 --> 00:03:25,500
to inflate that dll

84
00:03:25,500 --> 00:03:28,080
so this is an initial setup stat that

85
00:03:28,080 --> 00:03:31,440
does uh take about several minutes to do

86
00:03:31,440 --> 00:03:33,000
but once it's done then you don't need

87
00:03:33,000 --> 00:03:36,360
to repeat it again we support 31 of the

88
00:03:36,360 --> 00:03:38,819
most common dlls we can probably will

89
00:03:38,819 --> 00:03:41,220
add more later in the future if your

90
00:03:41,220 --> 00:03:44,760
Linux utilizer user then you'll need to

91
00:03:44,760 --> 00:03:48,000
place these dlls in there directly we'll

92
00:03:48,000 --> 00:03:49,920
provide a link to that in the future and

93
00:03:49,920 --> 00:03:51,360
the reason for that is obviously we

94
00:03:51,360 --> 00:03:52,980
can't Harvest Windows deals from from

95
00:03:52,980 --> 00:03:56,220
Linux so the PE file a python Library

96
00:03:56,220 --> 00:03:58,620
will actually go through it'll analyze

97
00:03:58,620 --> 00:04:00,720
the dll and it will enumerate the

98
00:04:00,720 --> 00:04:03,299
runtime addresses match them to the API

99
00:04:03,299 --> 00:04:06,840
and then we can use that subsequently

100
00:04:06,840 --> 00:04:09,299
uh with Windows Shell Code it is very

101
00:04:09,299 --> 00:04:11,519
complex and it's a lot more complex than

102
00:04:11,519 --> 00:04:14,879
something like Linux and so by necessity

103
00:04:14,879 --> 00:04:17,639
we need to emulate and provide several

104
00:04:17,639 --> 00:04:19,440
different uh very special Windows

105
00:04:19,440 --> 00:04:21,298
structures things like the process

106
00:04:21,298 --> 00:04:23,400
environment block the PEB the thread

107
00:04:23,400 --> 00:04:26,100
information block uh the three doubly

108
00:04:26,100 --> 00:04:28,919
link module lists both for 32 as well as

109
00:04:28,919 --> 00:04:31,860
64-bit and map all of those out if we

110
00:04:31,860 --> 00:04:34,979
don't do this then the Shell Code cannot

111
00:04:34,979 --> 00:04:37,560
be correctly emulated

112
00:04:37,560 --> 00:04:40,560
and we do actually use real dlls as we

113
00:04:40,560 --> 00:04:43,320
mentioned the reason why is because this

114
00:04:43,320 --> 00:04:46,500
allows us to be able to successfully

115
00:04:46,500 --> 00:04:50,100
emulate any and every shell code uh

116
00:04:50,100 --> 00:04:51,960
certainly we could simulate a lot of

117
00:04:51,960 --> 00:04:53,940
these values and that without having the

118
00:04:53,940 --> 00:04:55,620
actual dlls and that would probably work

119
00:04:55,620 --> 00:04:58,139
for a majority of shell killed samples

120
00:04:58,139 --> 00:05:01,080
but unfortunately not for all of them so

121
00:05:01,080 --> 00:05:03,720
by having the actual dlls in there we

122
00:05:03,720 --> 00:05:06,120
can allow for the kind of sometimes

123
00:05:06,120 --> 00:05:08,580
bizarre unpredictable behavior that some

124
00:05:08,580 --> 00:05:11,699
Shell Code will will do to to function

125
00:05:11,699 --> 00:05:15,419
and to avoid it from failing

126
00:05:15,419 --> 00:05:17,639
uh of course when the the Shell Code

127
00:05:17,639 --> 00:05:20,460
attempts to go to an API address even

128
00:05:20,460 --> 00:05:22,259
though we have the actual dlls in memory

129
00:05:22,259 --> 00:05:23,759
we're not going to emulate that instead

130
00:05:23,759 --> 00:05:26,759
we will simply intercept it simulate an

131
00:05:26,759 --> 00:05:29,160
appropriate response and then log it as

132
00:05:29,160 --> 00:05:30,479
well as all the parameters or even

133
00:05:30,479 --> 00:05:32,400
structures

134
00:05:32,400 --> 00:05:34,500
so we actually created uh numerous

135
00:05:34,500 --> 00:05:36,539
different lookup dictionaries to provide

136
00:05:36,539 --> 00:05:39,720
support for about 12 000 windows apis

137
00:05:39,720 --> 00:05:42,419
and so if we're able to uh if the Shell

138
00:05:42,419 --> 00:05:45,180
Code traverses the PE file format goes

139
00:05:45,180 --> 00:05:47,160
to the exports directory and then

140
00:05:47,160 --> 00:05:50,759
eventually finds uh an API that it

141
00:05:50,759 --> 00:05:53,100
wishes to call when the Shell Code goes

142
00:05:53,100 --> 00:05:55,259
to that runtime address we'll have we'll

143
00:05:55,259 --> 00:05:56,940
be able to map that out to the

144
00:05:56,940 --> 00:05:59,639
appropriate API and then we can use that

145
00:05:59,639 --> 00:06:02,039
API to then look up and see how many

146
00:06:02,039 --> 00:06:04,080
parameters do we want to extract from

147
00:06:04,080 --> 00:06:06,660
the stack and then also information like

148
00:06:06,660 --> 00:06:09,300
parameter names parameter types return

149
00:06:09,300 --> 00:06:12,419
values all of that good stuff and so

150
00:06:12,419 --> 00:06:15,840
that enables us to provide support for

151
00:06:15,840 --> 00:06:18,360
thousands of apis

152
00:06:18,360 --> 00:06:20,639
whenever possible we Endeavor to provide

153
00:06:20,639 --> 00:06:24,660
human readable output so hex 40 is

154
00:06:24,660 --> 00:06:27,060
something that's pretty well known is

155
00:06:27,060 --> 00:06:29,699
the the FL protect value stands for

156
00:06:29,699 --> 00:06:32,280
Pages execute read write

157
00:06:32,280 --> 00:06:33,720
um that's pretty

158
00:06:33,720 --> 00:06:36,900
predictable but sharim also provides

159
00:06:36,900 --> 00:06:39,900
support for several hundred other

160
00:06:39,900 --> 00:06:42,120
um values so we can map out those

161
00:06:42,120 --> 00:06:44,460
hexadecimal values to the human readable

162
00:06:44,460 --> 00:06:47,639
equivalents just saving time so that the

163
00:06:47,639 --> 00:06:49,440
the user doesn't have to to look them up

164
00:06:49,440 --> 00:06:51,419
and try to figure out what the shell

165
00:06:51,419 --> 00:06:54,120
code is trying to communicate to us

166
00:06:54,120 --> 00:06:55,919
one of the ways in which we do that is

167
00:06:55,919 --> 00:06:59,100
through Custom Custom implementation so

168
00:06:59,100 --> 00:07:00,960
we have several hundred customer

169
00:07:00,960 --> 00:07:03,720
implementations that allow us to do a

170
00:07:03,720 --> 00:07:05,280
lot more special activities with shell

171
00:07:05,280 --> 00:07:06,780
codes for instance providing human

172
00:07:06,780 --> 00:07:10,259
readable uh output this also enables us

173
00:07:10,259 --> 00:07:13,100
to make sure that the the Shell Code

174
00:07:13,100 --> 00:07:16,680
apis behave in an appropriate way so for

175
00:07:16,680 --> 00:07:18,660
instance virtual Outlook will actually

176
00:07:18,660 --> 00:07:20,759
create a region of memory URL download

177
00:07:20,759 --> 00:07:23,039
to file a we'll go and simulate

178
00:07:23,039 --> 00:07:24,660
downloading a file or even actually

179
00:07:24,660 --> 00:07:27,180
download the actual file so all of that

180
00:07:27,180 --> 00:07:29,340
we're able to customize and of course

181
00:07:29,340 --> 00:07:30,840
something like structures that's a very

182
00:07:30,840 --> 00:07:33,599
complex thing and so that requires a

183
00:07:33,599 --> 00:07:35,699
customer implementation however if

184
00:07:35,699 --> 00:07:37,620
something is not necessarily very

185
00:07:37,620 --> 00:07:40,080
sophisticated we don't uh have a need to

186
00:07:40,080 --> 00:07:42,900
do to do that then we can make use of

187
00:07:42,900 --> 00:07:45,780
the the lookup dictionaries

188
00:07:45,780 --> 00:07:48,120
so here's an example of create remote

189
00:07:48,120 --> 00:07:50,520
thread and you can see that it's highly

190
00:07:50,520 --> 00:07:52,380
modular we have several different helper

191
00:07:52,380 --> 00:07:54,240
functions that we created to allow us to

192
00:07:54,240 --> 00:07:57,020
do a great deal with

193
00:07:57,020 --> 00:07:59,880
not taking up too much space towards the

194
00:07:59,880 --> 00:08:01,259
middle you're you can see that we're

195
00:08:01,259 --> 00:08:03,780
able to actually firstly create a

196
00:08:03,780 --> 00:08:05,940
structure and then extract the

197
00:08:05,940 --> 00:08:09,000
appropriate values from the stack and

198
00:08:09,000 --> 00:08:11,280
from different locations in memory could

199
00:08:11,280 --> 00:08:13,199
be the Heap could be wherever and then

200
00:08:13,199 --> 00:08:16,199
to to be able to log those

201
00:08:16,199 --> 00:08:18,720
so let's talk about Windows sys calls so

202
00:08:18,720 --> 00:08:20,580
uh many of you probably know about

203
00:08:20,580 --> 00:08:22,680
Windows calls from egg hunters egg

204
00:08:22,680 --> 00:08:25,259
hunters have been around forever 15 20

205
00:08:25,259 --> 00:08:27,900
years widely used an exploitation used

206
00:08:27,900 --> 00:08:30,539
in malware as well and they very often

207
00:08:30,539 --> 00:08:32,399
will use a Windows sys call but outside

208
00:08:32,399 --> 00:08:36,479
of that uh realm until about 2018 they

209
00:08:36,479 --> 00:08:40,320
just were not widely used uh as part of

210
00:08:40,320 --> 00:08:43,559
this research one of our goals was to

211
00:08:43,559 --> 00:08:45,060
again be the total solution for

212
00:08:45,060 --> 00:08:47,160
everything Windows Shell Code so that

213
00:08:47,160 --> 00:08:48,839
meant we needed to be able to emulate

214
00:08:48,839 --> 00:08:51,839
Windows sys calls as it turned out

215
00:08:51,839 --> 00:08:54,000
windows syscalls in the form of shell

216
00:08:54,000 --> 00:08:56,940
code is extremely rare outside of the

217
00:08:56,940 --> 00:08:59,519
context of egg hunters so we actually

218
00:08:59,519 --> 00:09:01,320
did quite a bit of reverse engineering

219
00:09:01,320 --> 00:09:02,700
quite a bit of research to make sure

220
00:09:02,700 --> 00:09:04,380
that we were able to have the

221
00:09:04,380 --> 00:09:07,080
appropriate and correct behavior that

222
00:09:07,080 --> 00:09:10,080
also led to a separate presentation that

223
00:09:10,080 --> 00:09:12,480
we created for uh just this last Defcon

224
00:09:12,480 --> 00:09:14,640
in Las Vegas where we have uh we created

225
00:09:14,640 --> 00:09:17,519
a totally unrelated tool that will go

226
00:09:17,519 --> 00:09:19,680
and create syscall Shell Code or help

227
00:09:19,680 --> 00:09:23,100
the user to do that and we demoed an

228
00:09:23,100 --> 00:09:25,560
advanced syscall Shell Code so we do

229
00:09:25,560 --> 00:09:28,620
anticipate that

230
00:09:28,620 --> 00:09:30,360
while it's just called shell codes are

231
00:09:30,360 --> 00:09:31,680
not popular now that may be something

232
00:09:31,680 --> 00:09:33,839
that may increase in frequency in the

233
00:09:33,839 --> 00:09:36,420
future and when that does happen Sharon

234
00:09:36,420 --> 00:09:37,980
will be ready for it because we support

235
00:09:37,980 --> 00:09:40,560
virtually all user mode Windows sys

236
00:09:40,560 --> 00:09:42,779
calls as part of that process I want to

237
00:09:42,779 --> 00:09:44,459
track down the function prototypes for

238
00:09:44,459 --> 00:09:47,220
all user mode Windows syscalls I got

239
00:09:47,220 --> 00:09:50,040
about 200 or so from undocumented ntdll

240
00:09:50,040 --> 00:09:53,160
functions some from msdn but more than

241
00:09:53,160 --> 00:09:55,560
half of them was just me searching for

242
00:09:55,560 --> 00:09:57,899
function prototypes whenever or wherever

243
00:09:57,899 --> 00:10:00,120
I could find them but we do have them

244
00:10:00,120 --> 00:10:02,100
and they are supported and so what we

245
00:10:02,100 --> 00:10:05,880
will do is we will initialize uh fsc0 to

246
00:10:05,880 --> 00:10:07,620
point to a special location in memory

247
00:10:07,620 --> 00:10:09,720
and so if the Shelf code attempts to go

248
00:10:09,720 --> 00:10:11,940
to that location we can then intercept

249
00:10:11,940 --> 00:10:15,899
it and then do our syscall magic 64-bit

250
00:10:15,899 --> 00:10:17,160
is a little bit different so we'll

251
00:10:17,160 --> 00:10:18,540
actually hook the the syscall

252
00:10:18,540 --> 00:10:20,640
instruction

253
00:10:20,640 --> 00:10:23,100
here you can see an example of a syscall

254
00:10:23,100 --> 00:10:25,080
shell code and T allocate virtual memory

255
00:10:25,080 --> 00:10:28,260
it's also an NT deal function but this

256
00:10:28,260 --> 00:10:30,300
is the syscall form and you can tell

257
00:10:30,300 --> 00:10:33,480
because it's returning a value in eax uh

258
00:10:33,480 --> 00:10:36,000
the value of 15 and one thing about

259
00:10:36,000 --> 00:10:39,480
syscalls is its usage will vary based

260
00:10:39,480 --> 00:10:41,820
upon the windows OS for instance Windows

261
00:10:41,820 --> 00:10:44,579
10 has more than 13 different OS builds

262
00:10:44,579 --> 00:10:47,640
and for each of those the the SSN values

263
00:10:47,640 --> 00:10:50,459
or the values in eax can can change so

264
00:10:50,459 --> 00:10:52,620
if you are emulating sys calls which

265
00:10:52,620 --> 00:10:54,839
again is not common then you actually

266
00:10:54,839 --> 00:10:56,880
will want to specify the OS build which

267
00:10:56,880 --> 00:11:00,959
probably will be the most recent build

268
00:11:00,959 --> 00:11:03,660
uh structures are a very important

269
00:11:03,660 --> 00:11:07,200
aspect of the windows ecosystem so we

270
00:11:07,200 --> 00:11:10,140
want to be able to capture these rather

271
00:11:10,140 --> 00:11:12,180
than just simply having a hexadecimal

272
00:11:12,180 --> 00:11:15,000
address to a structure why not go and

273
00:11:15,000 --> 00:11:17,519
get that entire structure so we do

274
00:11:17,519 --> 00:11:19,920
provide that ability so startup in fully

275
00:11:19,920 --> 00:11:23,579
is a widely used structure and we do

276
00:11:23,579 --> 00:11:26,880
support that and so if the function is

277
00:11:26,880 --> 00:11:28,920
set up for that then it will just be

278
00:11:28,920 --> 00:11:31,140
automatically done and taken care of for

279
00:11:31,140 --> 00:11:32,040
you

280
00:11:32,040 --> 00:11:34,620
so right here you can see uh that we

281
00:11:34,620 --> 00:11:36,959
have two structures that are captured

282
00:11:36,959 --> 00:11:39,540
from create process a including the

283
00:11:39,540 --> 00:11:41,040
aforementioned

284
00:11:41,040 --> 00:11:41,959
um

285
00:11:41,959 --> 00:11:44,339
startup in fully

286
00:11:44,339 --> 00:11:46,200
and what about structures within

287
00:11:46,200 --> 00:11:48,600
structures so this this function is

288
00:11:48,600 --> 00:11:50,399
actually kind of curious uh get time

289
00:11:50,399 --> 00:11:53,519
zone information it actually has only

290
00:11:53,519 --> 00:11:56,100
one parameter which is a pointer to a

291
00:11:56,100 --> 00:11:59,399
structure whose members also include two

292
00:11:59,399 --> 00:12:01,980
other nested structures and Sharon is

293
00:12:01,980 --> 00:12:03,720
able to display all three of them and

294
00:12:03,720 --> 00:12:06,839
also to visually convey that nested

295
00:12:06,839 --> 00:12:09,440
relationship for us

296
00:12:09,440 --> 00:12:11,640
unions so unions can also be an

297
00:12:11,640 --> 00:12:14,220
important part of the windows

298
00:12:14,220 --> 00:12:15,959
um ecosystem

299
00:12:15,959 --> 00:12:18,720
so a union is where two

300
00:12:18,720 --> 00:12:19,320
um

301
00:12:19,320 --> 00:12:21,600
parameters will share the same memory

302
00:12:21,600 --> 00:12:22,620
and of course we wouldn't be able to

303
00:12:22,620 --> 00:12:24,899
parse that accurately and so share them

304
00:12:24,899 --> 00:12:28,260
does provide that ability for us

305
00:12:28,260 --> 00:12:30,420
whenever possible share and Endeavors to

306
00:12:30,420 --> 00:12:35,100
provide uh success so even if the shell

307
00:12:35,100 --> 00:12:36,540
code is supposed to download a

308
00:12:36,540 --> 00:12:38,220
particular resource that resource is not

309
00:12:38,220 --> 00:12:39,000
there

310
00:12:39,000 --> 00:12:41,100
serum will always simulate with every

311
00:12:41,100 --> 00:12:45,000
single API as successful result so SLK

312
00:12:45,000 --> 00:12:46,740
is something that's pretty common the

313
00:12:46,740 --> 00:12:48,779
hex value 0 0 which will be returned in

314
00:12:48,779 --> 00:12:51,540
the eax register and so some Shell Code

315
00:12:51,540 --> 00:12:53,880
will actually go and check to see is

316
00:12:53,880 --> 00:12:56,220
zero zero present in eax if it's not it

317
00:12:56,220 --> 00:12:58,800
may prematurely terminate so we'll do

318
00:12:58,800 --> 00:13:01,019
that and also much more specific ways of

319
00:13:01,019 --> 00:13:03,600
trying to simulate success and also

320
00:13:03,600 --> 00:13:06,660
output parameters so the windows will

321
00:13:06,660 --> 00:13:08,000
also utilize

322
00:13:08,000 --> 00:13:10,620
parameters to Output parameters as well

323
00:13:10,620 --> 00:13:14,880
so ldr low dll will typically receive

324
00:13:14,880 --> 00:13:16,019
the

325
00:13:16,019 --> 00:13:16,620
um

326
00:13:16,620 --> 00:13:19,079
address of the load a dll and you can

327
00:13:19,079 --> 00:13:22,019
see that displayed there as we have the

328
00:13:22,019 --> 00:13:23,639
handle there we've actually converted

329
00:13:23,639 --> 00:13:26,040
the handle to

330
00:13:26,040 --> 00:13:26,880
um

331
00:13:26,880 --> 00:13:29,339
shell 32 so instead of a hex value we

332
00:13:29,339 --> 00:13:31,680
see the actual dll that is supposed to

333
00:13:31,680 --> 00:13:33,000
represent

334
00:13:33,000 --> 00:13:35,040
breaking out of Loops it's not a novel

335
00:13:35,040 --> 00:13:37,139
concept but it's one that is incredibly

336
00:13:37,139 --> 00:13:38,880
important so we do provide that ability

337
00:13:38,880 --> 00:13:41,760
uh you can set it up however you like in

338
00:13:41,760 --> 00:13:43,519
the config file

339
00:13:43,519 --> 00:13:45,959
complete code coverage is probably one

340
00:13:45,959 --> 00:13:47,880
of the more revolutionary things about

341
00:13:47,880 --> 00:13:49,339
Sharon

342
00:13:49,339 --> 00:13:53,820
inspired by AFL which is a a fuzzer that

343
00:13:53,820 --> 00:13:56,279
tries to explore every potential code

344
00:13:56,279 --> 00:13:58,079
path

345
00:13:58,079 --> 00:14:00,300
um Sharon does something similar so it

346
00:14:00,300 --> 00:14:03,180
wants to go down every single chord code

347
00:14:03,180 --> 00:14:05,040
path so what it will do is it will

348
00:14:05,040 --> 00:14:07,380
record all code pass it'll do that by

349
00:14:07,380 --> 00:14:10,320
creating a list of objects and that will

350
00:14:10,320 --> 00:14:12,360
uh contain a good deal of information

351
00:14:12,360 --> 00:14:15,480
for instance the original location uh

352
00:14:15,480 --> 00:14:18,120
the registers the values of them uh and

353
00:14:18,120 --> 00:14:21,779
also take a snapshot of the stack values

354
00:14:21,779 --> 00:14:24,959
and in addition it will dump the shell

355
00:14:24,959 --> 00:14:27,180
codes memory so when the Shell Code

356
00:14:27,180 --> 00:14:29,160
terminates if there are any unvisited

357
00:14:29,160 --> 00:14:30,899
areas of the code sure I'm going to

358
00:14:30,899 --> 00:14:33,480
restart and it's going to revisit those

359
00:14:33,480 --> 00:14:36,480
lists until it has uh successfully

360
00:14:36,480 --> 00:14:38,820
visited all of them and by doing this we

361
00:14:38,820 --> 00:14:40,440
can discover more functionality to the

362
00:14:40,440 --> 00:14:43,680
left you see two apis enumerated and to

363
00:14:43,680 --> 00:14:46,139
the right we are able to discover a

364
00:14:46,139 --> 00:14:49,500
third one reg set key value a which this

365
00:14:49,500 --> 00:14:52,740
is only accessible for one specific uh

366
00:14:52,740 --> 00:14:54,180
computer and that's why we have git

367
00:14:54,180 --> 00:14:56,519
computer and am a so uh that's not

368
00:14:56,519 --> 00:14:58,260
that's something that on any other

369
00:14:58,260 --> 00:14:59,880
machine would be completely inaccessible

370
00:14:59,880 --> 00:15:02,220
but with complete code coverage we are

371
00:15:02,220 --> 00:15:05,940
able to view that

372
00:15:05,940 --> 00:15:08,220
self modifying code is a prevalent

373
00:15:08,220 --> 00:15:10,980
aspect of Windows shell codes so Shell

374
00:15:10,980 --> 00:15:13,440
Code decrypting itself in memory and one

375
00:15:13,440 --> 00:15:15,120
very special thing the sharum can do is

376
00:15:15,120 --> 00:15:17,279
once the Shell Code has decrypted itself

377
00:15:17,279 --> 00:15:20,040
we will send the decrypted form to the

378
00:15:20,040 --> 00:15:22,680
disassembler and we can view that we

379
00:15:22,680 --> 00:15:25,139
achieve this by using SSD but fuzzy hash

380
00:15:25,139 --> 00:15:27,480
so we can just check to see

381
00:15:27,480 --> 00:15:29,760
um how similar or dissimilar thing it is

382
00:15:29,760 --> 00:15:33,120
from how it started and this is a shell

383
00:15:33,120 --> 00:15:35,880
curl that actually was or is encrypted

384
00:15:35,880 --> 00:15:38,339
but we're viewing the decrypted form of

385
00:15:38,339 --> 00:15:40,740
it so a lot of ways I view that as kind

386
00:15:40,740 --> 00:15:42,600
of a game changer for cell code because

387
00:15:42,600 --> 00:15:44,399
you can take something that is uh

388
00:15:44,399 --> 00:15:47,040
encoded and then view the decoded format

389
00:15:47,040 --> 00:15:50,540
of it in a disassembler

390
00:15:50,639 --> 00:15:53,220
the same thing in Ida Pro we have a

391
00:15:53,220 --> 00:15:54,720
decoder stub at the top and then a

392
00:15:54,720 --> 00:15:56,220
series of encrypted bytes it's

393
00:15:56,220 --> 00:15:58,260
absolutely correct it's just perhaps not

394
00:15:58,260 --> 00:16:00,420
as useful

395
00:16:00,420 --> 00:16:02,639
uh and with that we will then have

396
00:16:02,639 --> 00:16:04,560
Shelby

397
00:16:04,560 --> 00:16:07,320
um the memory manager is responsible for

398
00:16:07,320 --> 00:16:10,019
the emulated memory being allocated it

399
00:16:10,019 --> 00:16:12,000
also ensures that no collisions occur

400
00:16:12,000 --> 00:16:15,060
between multiple allocations in addition

401
00:16:15,060 --> 00:16:17,100
to the memory manager we also have a

402
00:16:17,100 --> 00:16:19,800
handle manager that is used to map

403
00:16:19,800 --> 00:16:22,440
handles to different objects these

404
00:16:22,440 --> 00:16:24,420
objects can be a variety of types such

405
00:16:24,420 --> 00:16:27,360
as register Keys files and other

406
00:16:27,360 --> 00:16:29,820
resources

407
00:16:29,820 --> 00:16:34,079
if a handle object has a name field we

408
00:16:34,079 --> 00:16:36,420
are then able to show that name instead

409
00:16:36,420 --> 00:16:38,940
of the handle ID

410
00:16:38,940 --> 00:16:41,699
in this example you see that two

411
00:16:41,699 --> 00:16:44,579
registry functions and their handles are

412
00:16:44,579 --> 00:16:46,079
instead being mapped to the registry

413
00:16:46,079 --> 00:16:49,519
paths that are being modified

414
00:16:50,279 --> 00:16:53,220
the registry manager is responsible for

415
00:16:53,220 --> 00:16:56,279
the emulation of the registry tree it

416
00:16:56,279 --> 00:16:59,040
handles all operations such as creation

417
00:16:59,040 --> 00:17:01,320
modification

418
00:17:01,320 --> 00:17:03,420
we are also able to read the values that

419
00:17:03,420 --> 00:17:05,760
are stored into the registry and if the

420
00:17:05,760 --> 00:17:08,520
value has not been created yet we can

421
00:17:08,520 --> 00:17:10,380
return a dummy value that is

422
00:17:10,380 --> 00:17:14,480
customizable via the config file

423
00:17:15,119 --> 00:17:17,819
um throughout the emulation

424
00:17:17,819 --> 00:17:20,400
um Sharon will record the additions

425
00:17:20,400 --> 00:17:22,140
modifications and deletions to the

426
00:17:22,140 --> 00:17:25,079
registry then after emulation is done

427
00:17:25,079 --> 00:17:27,780
it'll go back and analyze for common

428
00:17:27,780 --> 00:17:29,700
miter techniques that make use of the

429
00:17:29,700 --> 00:17:31,620
registry such as persistence and

430
00:17:31,620 --> 00:17:32,820
credentials

431
00:17:32,820 --> 00:17:34,700
it also

432
00:17:34,700 --> 00:17:37,140
records and displays the hierarchy

433
00:17:37,140 --> 00:17:39,740
information for the registry

434
00:17:39,740 --> 00:17:43,440
so in this example we see a Windows sys

435
00:17:43,440 --> 00:17:45,840
call that makes use of the registry we

436
00:17:45,840 --> 00:17:47,039
can see

437
00:17:47,039 --> 00:17:49,500
the path is displayed instead of the

438
00:17:49,500 --> 00:17:51,299
handle we can also see an object

439
00:17:51,299 --> 00:17:56,360
attribute structure and now Sasha

440
00:17:58,620 --> 00:17:59,580
all right

441
00:17:59,580 --> 00:18:02,580
so Sharon has uh whenever we do our API

442
00:18:02,580 --> 00:18:04,500
Discovery and the data from it we

443
00:18:04,500 --> 00:18:06,419
subject all of that to regular

444
00:18:06,419 --> 00:18:09,179
Expressions to sort into categories

445
00:18:09,179 --> 00:18:10,860
so uh

446
00:18:10,860 --> 00:18:13,080
here we can see categories with like

447
00:18:13,080 --> 00:18:15,179
command line and web artifacts and then

448
00:18:15,179 --> 00:18:18,419
in this next example we can see we

449
00:18:18,419 --> 00:18:21,000
extract all the paths uh the files which

450
00:18:21,000 --> 00:18:24,660
we maintain a pseudo file system for to

451
00:18:24,660 --> 00:18:26,900
keep track of any modifications renaming

452
00:18:26,900 --> 00:18:30,120
uh deletion and so on

453
00:18:30,120 --> 00:18:32,100
and then we also keep track of any web

454
00:18:32,100 --> 00:18:34,860
artifacts that do pop up

455
00:18:34,860 --> 00:18:37,140
um with the web artifacts we can

456
00:18:37,140 --> 00:18:40,799
actually download live files uh if the

457
00:18:40,799 --> 00:18:42,900
resource is still active and has not

458
00:18:42,900 --> 00:18:44,299
been terminated

459
00:18:44,299 --> 00:18:47,880
so with an example uh URL download a

460
00:18:47,880 --> 00:18:50,580
file we would download the file load

461
00:18:50,580 --> 00:18:53,100
into our memory create an md5 hash of it

462
00:18:53,100 --> 00:18:57,000
and then use it where it needed this

463
00:18:57,000 --> 00:18:59,460
option is disabled by default but it can

464
00:18:59,460 --> 00:19:01,919
be enabled through our config and here

465
00:19:01,919 --> 00:19:05,340
we can see a uh example of a file being

466
00:19:05,340 --> 00:19:07,260
created with a successful download along

467
00:19:07,260 --> 00:19:10,380
with the md5 hash and then the file

468
00:19:10,380 --> 00:19:12,480
correlations with our simulated file

469
00:19:12,480 --> 00:19:15,720
system where this downloaded file has

470
00:19:15,720 --> 00:19:18,900
been renamed uh if it was renamed or

471
00:19:18,900 --> 00:19:20,760
moved around in our simulate file system

472
00:19:20,760 --> 00:19:22,919
it would show up right here

473
00:19:22,919 --> 00:19:25,799
and we can see the web artifacts being

474
00:19:25,799 --> 00:19:28,760
popped up with a 200 which will be said

475
00:19:28,760 --> 00:19:30,840
successfully download from the website

476
00:19:30,840 --> 00:19:35,360
and then back Ram well here

477
00:19:35,700 --> 00:19:39,600
all right thank you Sasha and Shelby

478
00:19:39,600 --> 00:19:41,820
so Sharon also provides functionality

479
00:19:41,820 --> 00:19:44,340
for a heap manager which we actually

480
00:19:44,340 --> 00:19:46,260
Implement very specific functionality

481
00:19:46,260 --> 00:19:48,900
for all aspects of the Heap uh even

482
00:19:48,900 --> 00:19:50,100
though it's probably not necessary in

483
00:19:50,100 --> 00:19:51,960
most cases for Shell Code we try

484
00:19:51,960 --> 00:19:55,740
whenever possible to be accurate and so

485
00:19:55,740 --> 00:19:58,500
Sharon does take care of that for us

486
00:19:58,500 --> 00:20:01,679
we do support a 64-bit Shadow code so we

487
00:20:01,679 --> 00:20:03,480
can emulate it and also disassemble it

488
00:20:03,480 --> 00:20:05,940
as well it's not very common in Windows

489
00:20:05,940 --> 00:20:07,740
it's typically 32-bit but we do have

490
00:20:07,740 --> 00:20:09,480
that functionality

491
00:20:09,480 --> 00:20:11,940
so let's dive into the disassembler

492
00:20:11,940 --> 00:20:14,640
now what actually motivated this was my

493
00:20:14,640 --> 00:20:16,260
uh somewhat I guess you could say

494
00:20:16,260 --> 00:20:18,660
displeasure with leading disassemblers

495
00:20:18,660 --> 00:20:21,360
Ida Pro guidra

496
00:20:21,360 --> 00:20:23,280
um binary ninja and the way in which

497
00:20:23,280 --> 00:20:25,080
they would encounter a lot of or

498
00:20:25,080 --> 00:20:26,820
disassemble a lot of Windows shell codes

499
00:20:26,820 --> 00:20:29,100
so you could have data misinterpreted as

500
00:20:29,100 --> 00:20:31,020
instructions instructions would start at

501
00:20:31,020 --> 00:20:33,059
incorrect offsets it was just very

502
00:20:33,059 --> 00:20:35,940
frustrating so I decided to create my

503
00:20:35,940 --> 00:20:37,500
own solution so I developed a

504
00:20:37,500 --> 00:20:39,720
disassembly analysis engine to provide

505
00:20:39,720 --> 00:20:41,580
that functionality and at the heart of

506
00:20:41,580 --> 00:20:43,200
this we need to distinguish for each and

507
00:20:43,200 --> 00:20:45,840
every byte is it data or is it

508
00:20:45,840 --> 00:20:48,120
instructions and specifically where does

509
00:20:48,120 --> 00:20:49,679
it begin where does it end if we're able

510
00:20:49,679 --> 00:20:51,900
to achieve that then the resulting

511
00:20:51,900 --> 00:20:55,080
disassembly should be correct so for

512
00:20:55,080 --> 00:20:57,059
each and every byte we share and

513
00:20:57,059 --> 00:20:59,160
maintains complex metadata so that we

514
00:20:59,160 --> 00:21:02,820
can display uh the disassembly correctly

515
00:21:02,820 --> 00:21:06,600
so our approach is exclusively with

516
00:21:06,600 --> 00:21:08,160
um Shell Code

517
00:21:08,160 --> 00:21:10,380
and it's based very much on

518
00:21:10,380 --> 00:21:11,880
experimentation a very empirical

519
00:21:11,880 --> 00:21:15,179
approach so I had a lot of numerous

520
00:21:15,179 --> 00:21:17,820
Windows shell codes examples for which I

521
00:21:17,820 --> 00:21:20,220
possess the source code I would then

522
00:21:20,220 --> 00:21:22,919
look at them in a disassembler and try

523
00:21:22,919 --> 00:21:24,600
to figure out why is this being

524
00:21:24,600 --> 00:21:26,760
misinterpreted if I could identify the

525
00:21:26,760 --> 00:21:28,260
root cause causing it to be

526
00:21:28,260 --> 00:21:31,559
misidentified or misinterpreted then I

527
00:21:31,559 --> 00:21:34,460
could correct it for all other instances

528
00:21:34,460 --> 00:21:37,799
and I was able to be rather successful

529
00:21:37,799 --> 00:21:40,980
with that so again this is not designed

530
00:21:40,980 --> 00:21:44,460
to be 100 percent uh accurate but it is

531
00:21:44,460 --> 00:21:48,299
significantly more accurate than leading

532
00:21:48,299 --> 00:21:50,340
disassemblers

533
00:21:50,340 --> 00:21:51,960
there are several different uh

534
00:21:51,960 --> 00:21:54,840
disassembly analysis phases for these I

535
00:21:54,840 --> 00:21:56,700
will refer you to the to the paper it's

536
00:21:56,700 --> 00:21:58,380
not really that interesting to to talk

537
00:21:58,380 --> 00:21:59,460
about

538
00:21:59,460 --> 00:22:01,860
but once we are able to achieve the more

539
00:22:01,860 --> 00:22:04,200
accurate disassembly we can do things

540
00:22:04,200 --> 00:22:08,039
like uh put in AP calls to apis which is

541
00:22:08,039 --> 00:22:10,020
something that of course uh no other

542
00:22:10,020 --> 00:22:12,419
disassembler is able to do not only do

543
00:22:12,419 --> 00:22:14,460
we have the API we also have the

544
00:22:14,460 --> 00:22:17,159
parameters that are displayed and it

545
00:22:17,159 --> 00:22:19,380
does support the sys calls as well so

546
00:22:19,380 --> 00:22:20,940
instead of seeing something like call

547
00:22:20,940 --> 00:22:23,940
eax which is kind of mysterious what's

548
00:22:23,940 --> 00:22:26,340
eax or what's ebx

549
00:22:26,340 --> 00:22:30,179
we'll actually see the label to the API

550
00:22:30,179 --> 00:22:32,580
so incredibly useful

551
00:22:32,580 --> 00:22:34,880
Sharon does also have the ability to

552
00:22:34,880 --> 00:22:38,159
search and analyze the Shell Code for a

553
00:22:38,159 --> 00:22:40,380
lot of very special things for which it

554
00:22:40,380 --> 00:22:42,659
collects many different data points get

555
00:22:42,659 --> 00:22:44,880
PC instructions your call Pops fast

556
00:22:44,880 --> 00:22:47,340
environments push Frets which which

557
00:22:47,340 --> 00:22:49,620
allows us to kind of discreetly modify

558
00:22:49,620 --> 00:22:51,900
control flow Heaven's Gate which I

559
00:22:51,900 --> 00:22:53,280
actually haven't seen in Shell killed

560
00:22:53,280 --> 00:22:55,440
but you potentially could do that all of

561
00:22:55,440 --> 00:22:56,940
that is supported

562
00:22:56,940 --> 00:22:59,039
uh PEB identification we get many

563
00:22:59,039 --> 00:23:01,320
diverse uh data points so you can

564
00:23:01,320 --> 00:23:03,960
display very unique aspects of the PEB

565
00:23:03,960 --> 00:23:06,720
and that's all done automatically

566
00:23:06,720 --> 00:23:10,140
API tables so we can analyze the the

567
00:23:10,140 --> 00:23:13,200
memory and determined

568
00:23:13,200 --> 00:23:15,000
um something for instance could begin as

569
00:23:15,000 --> 00:23:16,740
a series of no bias and then later be

570
00:23:16,740 --> 00:23:18,780
initialized to a runtime address and we

571
00:23:18,780 --> 00:23:21,240
can have that updated and so we can not

572
00:23:21,240 --> 00:23:23,039
only see what that

573
00:23:23,039 --> 00:23:25,380
those specific bytes are supposed to be

574
00:23:25,380 --> 00:23:28,020
but we also have them labeled

575
00:23:28,020 --> 00:23:30,179
so let's compare Idaho Pro to share them

576
00:23:30,179 --> 00:23:33,059
so Ida Pro we're not able to identify

577
00:23:33,059 --> 00:23:35,580
the apis is unfortunate we're not able

578
00:23:35,580 --> 00:23:38,100
to see PEB information also unfortunate

579
00:23:38,100 --> 00:23:40,440
but over in sharim we have all of that

580
00:23:40,440 --> 00:23:44,700
displayed for us uh in Vivid color

581
00:23:44,700 --> 00:23:46,679
Sharon also has the ability to discover

582
00:23:46,679 --> 00:23:49,500
strings has its own custom functions to

583
00:23:49,500 --> 00:23:50,820
do that some of them are slightly

584
00:23:50,820 --> 00:23:53,159
different down below you see push stack

585
00:23:53,159 --> 00:23:55,320
strings are discovered and you have an

586
00:23:55,320 --> 00:23:58,559
auto comment here for load Library

587
00:23:58,559 --> 00:24:00,240
one of the other very special aspects

588
00:24:00,240 --> 00:24:02,880
about Sharon is it's able to utilize

589
00:24:02,880 --> 00:24:05,039
emulation data and merge that with the

590
00:24:05,039 --> 00:24:07,140
Shell Code to achieve much higher

591
00:24:07,140 --> 00:24:08,640
quality much more accurate results

592
00:24:08,640 --> 00:24:11,520
because if we emulate Shell Code then we

593
00:24:11,520 --> 00:24:13,080
can definitively know that a particular

594
00:24:13,080 --> 00:24:15,900
Shell Code will start execution at this

595
00:24:15,900 --> 00:24:19,080
offset and then end at this offset so we

596
00:24:19,080 --> 00:24:20,880
can take that data and then merge that

597
00:24:20,880 --> 00:24:23,820
into what would otherwise be produced as

598
00:24:23,820 --> 00:24:25,620
far as data we can analyze our memory

599
00:24:25,620 --> 00:24:27,720
reads and writes and then conclusively

600
00:24:27,720 --> 00:24:30,419
determine hey this is data other things

601
00:24:30,419 --> 00:24:32,700
like strings or d word arrays for our

602
00:24:32,700 --> 00:24:35,520
API cables are pretty simple to identify

603
00:24:35,520 --> 00:24:37,700
you might also ask well what about

604
00:24:37,700 --> 00:24:39,600
self-modifying code because every single

605
00:24:39,600 --> 00:24:41,820
byte that that is going to be read and

606
00:24:41,820 --> 00:24:43,500
modified well we take that into

607
00:24:43,500 --> 00:24:45,360
consideration so in that case if we

608
00:24:45,360 --> 00:24:47,640
determine a self-modifying then we will

609
00:24:47,640 --> 00:24:49,799
only classify things as data if it's

610
00:24:49,799 --> 00:24:52,740
modified or accessed more than once and

611
00:24:52,740 --> 00:24:55,140
so that solves that issue and this one

612
00:24:55,140 --> 00:24:57,360
right here actually is encoded but we

613
00:24:57,360 --> 00:24:58,919
see the decrypted form and you can Can

614
00:24:58,919 --> 00:25:02,039
See Clearly up on top the instructions

615
00:25:02,039 --> 00:25:04,740
are clearly identified we also see an

616
00:25:04,740 --> 00:25:06,600
API identified and then down below it's

617
00:25:06,600 --> 00:25:09,720
all data distinct types of data and they

618
00:25:09,720 --> 00:25:11,280
are labeled correctly if you were to

619
00:25:11,280 --> 00:25:13,080
view this and another disassembler you

620
00:25:13,080 --> 00:25:16,100
would just see a series of bytes being

621
00:25:16,100 --> 00:25:19,080
misinterpreted is instructions which

622
00:25:19,080 --> 00:25:20,400
they're not so the gibberish

623
00:25:20,400 --> 00:25:22,080
instructions

624
00:25:22,080 --> 00:25:24,179
now one thing that sharum does of course

625
00:25:24,179 --> 00:25:27,960
is it tries to display the the encoded

626
00:25:27,960 --> 00:25:29,940
Shell Code as if it were decrypted how

627
00:25:29,940 --> 00:25:34,080
do we do that well we take a snapshot of

628
00:25:34,080 --> 00:25:35,760
the starting form and then the final

629
00:25:35,760 --> 00:25:37,740
form and then after every CPU

630
00:25:37,740 --> 00:25:40,020
instruction is executed we'll take an

631
00:25:40,020 --> 00:25:42,960
image of the specific bytes being

632
00:25:42,960 --> 00:25:45,059
executed they're starting an ending

633
00:25:45,059 --> 00:25:47,400
location then we will merge all of these

634
00:25:47,400 --> 00:25:49,380
together the executed form the final

635
00:25:49,380 --> 00:25:51,600
form in the starting form this way if

636
00:25:51,600 --> 00:25:54,240
the shell Cobra to re encode itself we

637
00:25:54,240 --> 00:25:56,279
would still be able to reveal its true

638
00:25:56,279 --> 00:25:58,320
inner form which by the way that's not

639
00:25:58,320 --> 00:25:59,880
very common but it's something that

640
00:25:59,880 --> 00:26:01,200
could be done

641
00:26:01,200 --> 00:26:03,360
so again here's another example of a

642
00:26:03,360 --> 00:26:05,640
decoded Shell Code we're able to see

643
00:26:05,640 --> 00:26:09,779
several different apis identified for us

644
00:26:09,779 --> 00:26:12,299
Timeless debugging so Timeless debugging

645
00:26:12,299 --> 00:26:15,419
can be extremely immensely beneficial in

646
00:26:15,419 --> 00:26:17,520
analyzing a Shell Code or just really

647
00:26:17,520 --> 00:26:19,679
anything and so what this will do is

648
00:26:19,679 --> 00:26:21,960
I'll log the all CPU instructions

649
00:26:21,960 --> 00:26:24,120
executed by the Shell Code throughout

650
00:26:24,120 --> 00:26:25,919
the the life the history of the Shell

651
00:26:25,919 --> 00:26:28,500
Code from beginning to end and we do

652
00:26:28,500 --> 00:26:30,840
this in a very lightweight fashion so

653
00:26:30,840 --> 00:26:33,000
it's output just simply to a text file

654
00:26:33,000 --> 00:26:35,580
and so you could uh I find the visual

655
00:26:35,580 --> 00:26:37,919
code works very well better than some

656
00:26:37,919 --> 00:26:40,440
other options for displaying it so we

657
00:26:40,440 --> 00:26:42,480
can see the registers both before and

658
00:26:42,480 --> 00:26:43,860
after every

659
00:26:43,860 --> 00:26:44,580
um

660
00:26:44,580 --> 00:26:46,860
CPU instruction

661
00:26:46,860 --> 00:26:48,360
so we've actually used the Timeless

662
00:26:48,360 --> 00:26:50,640
debugging on many different occasions to

663
00:26:50,640 --> 00:26:52,559
analyze shell code on a better

664
00:26:52,559 --> 00:26:54,240
understand as functionality to

665
00:26:54,240 --> 00:26:56,940
troubleshoot different issues

666
00:26:56,940 --> 00:26:58,380
Sherman is also designed to be able to

667
00:26:58,380 --> 00:27:01,260
integrate with web services so this was

668
00:27:01,260 --> 00:27:03,120
done from the ground up so it can also

669
00:27:03,120 --> 00:27:04,520
can be

670
00:27:04,520 --> 00:27:07,559
deployed using a startup enabled config

671
00:27:07,559 --> 00:27:10,020
and then it will generate a json.json

672
00:27:10,020 --> 00:27:12,600
can then be ingested by some web service

673
00:27:12,600 --> 00:27:15,419
and then they can make use of that Json

674
00:27:15,419 --> 00:27:18,120
hover they want so black hat Arsenal

675
00:27:18,120 --> 00:27:22,440
2022 Aaron Baker presented as subparse

676
00:27:22,440 --> 00:27:24,480
and that parses many different types of

677
00:27:24,480 --> 00:27:27,480
files and he actually used share them is

678
00:27:27,480 --> 00:27:30,059
we work with him use share them as the

679
00:27:30,059 --> 00:27:31,740
Shell Code parser he didn't talk about

680
00:27:31,740 --> 00:27:33,419
Sharon or Shell Code was about other

681
00:27:33,419 --> 00:27:35,400
things but Sherman was kind of a hidden

682
00:27:35,400 --> 00:27:37,200
feature there and he was able to display

683
00:27:37,200 --> 00:27:39,840
that Json output and his own fashion

684
00:27:39,840 --> 00:27:41,279
which you can see down below there

685
00:27:41,279 --> 00:27:44,159
that's not serum output that is subparse

686
00:27:44,159 --> 00:27:46,380
output utilizing share them

687
00:27:46,380 --> 00:27:49,559
so Sharon reports on a rich rich set of

688
00:27:49,559 --> 00:27:52,320
data probably a lot more things than you

689
00:27:52,320 --> 00:27:54,120
would anticipate could be possible with

690
00:27:54,120 --> 00:27:56,760
shell code it also analyzes PE files

691
00:27:56,760 --> 00:27:57,840
which we don't have time to talk about

692
00:27:57,840 --> 00:28:00,419
and it can also get traditional PE file

693
00:28:00,419 --> 00:28:02,520
features and some things that are

694
00:28:02,520 --> 00:28:04,320
somewhat related to Shell Code as well

695
00:28:04,320 --> 00:28:07,860
uh gives a lot of data points on those

696
00:28:07,860 --> 00:28:09,299
Sharon provides several different

697
00:28:09,299 --> 00:28:11,279
outputs it'll print to the screen and

698
00:28:11,279 --> 00:28:13,559
it'll provide text format output as well

699
00:28:13,559 --> 00:28:16,260
as Json and then additionally for each

700
00:28:16,260 --> 00:28:18,480
Shell Code it'll generate a C file by

701
00:28:18,480 --> 00:28:20,460
default so you could go and compile that

702
00:28:20,460 --> 00:28:22,140
in visual studio and if you feel the

703
00:28:22,140 --> 00:28:23,640
need to actually debug it for real and

704
00:28:23,640 --> 00:28:25,919
window bug or whatever you prefer then

705
00:28:25,919 --> 00:28:28,620
you have the ability to do so

706
00:28:28,620 --> 00:28:31,679
uh Sharon was first released today so

707
00:28:31,679 --> 00:28:32,940
it's the first day that it's available

708
00:28:32,940 --> 00:28:35,220
right here uh for virus bulletin so we

709
00:28:35,220 --> 00:28:36,659
hope you check it out and we'd also like

710
00:28:36,659 --> 00:28:39,659
to thank the our sponsor the NSA and

711
00:28:39,659 --> 00:28:41,340
with that we are if we have time we'll

712
00:28:41,340 --> 00:28:42,600
take questions

713
00:28:42,600 --> 00:28:44,039
thank you very much

714
00:28:44,039 --> 00:28:46,919
thank you very much for your impressing

715
00:28:46,919 --> 00:28:48,170
work and uh

716
00:28:48,170 --> 00:28:53,039
[Applause]

717
00:28:53,039 --> 00:28:55,559
we have time for one quick question

718
00:28:55,559 --> 00:28:59,820
uh yeah from Freedom okay one really

719
00:28:59,820 --> 00:29:03,000
quick question how big is the project in

720
00:29:03,000 --> 00:29:04,559
terms of how much effort has gone into

721
00:29:04,559 --> 00:29:06,840
it in man months or many years

722
00:29:06,840 --> 00:29:09,539
it was a tremendous amount

723
00:29:09,539 --> 00:29:11,279
um at least thousands of hours I

724
00:29:11,279 --> 00:29:13,020
couldn't say how many thousands we had

725
00:29:13,020 --> 00:29:14,640
several different people working on it

726
00:29:14,640 --> 00:29:17,460
for over a period of two years but and

727
00:29:17,460 --> 00:29:19,260
okay I'm going to sneak in the second

728
00:29:19,260 --> 00:29:20,520
question

729
00:29:20,520 --> 00:29:23,279
um it sounds like to me like you have

730
00:29:23,279 --> 00:29:25,260
almost everything you need for a

731
00:29:25,260 --> 00:29:30,059
full-blown PE file emulation but missing

732
00:29:30,059 --> 00:29:31,640
some parts like

733
00:29:31,640 --> 00:29:34,799
multi-threaded issues and so on or how

734
00:29:34,799 --> 00:29:36,419
is that something I've looked and have

735
00:29:36,419 --> 00:29:38,880
you looked on evolving this into a full

736
00:29:38,880 --> 00:29:43,080
emulator for applications oh no we don't

737
00:29:43,080 --> 00:29:45,240
have plans to do that at this time uh

738
00:29:45,240 --> 00:29:46,980
it's a great idea but I think there

739
00:29:46,980 --> 00:29:49,140
would be a lot of additional work for

740
00:29:49,140 --> 00:29:49,919
that

741
00:29:49,919 --> 00:29:50,820
um

742
00:29:50,820 --> 00:29:55,158
but maybe we'll think about it

743
00:29:55,260 --> 00:29:58,039
thank you again

